
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         000096ac  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000b800  8000b800  0000bc00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001220  8000ba00  8000ba00  0000be00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a18  00000004  8000cc20  0000d404  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .balign       00000004  00000a1c  8000d638  0000de1c  2**0
                  ALLOC
  7 .bss          00001588  00000a20  8000d638  0000de20  2**2
                  ALLOC
  8 .comment      00000030  00000000  00000000  0000de1c  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 000016f8  00000000  00000000  0000de50  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 0000356a  00000000  00000000  0000f548  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0002c643  00000000  00000000  00012ab2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 000074c1  00000000  00000000  0003f0f5  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000d848  00000000  00000000  000465b6  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00003eec  00000000  00000000  00053e00  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00007df3  00000000  00000000  00057cec  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000f9ef  00000000  00000000  0005fadf  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 18 .debug_ranges 000017b8  00000000  00000000  0006f4d0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf d7 b0 	sub	pc,pc,-10320

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0c e0       	st.h	--r6,r0

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 38       	cp.w	r8,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384//1024//800//384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 08       	add	r8,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	32 04       	mov	r4,32
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 90       	sub	r0,9
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	20 a4       	sub	r4,10
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	31 a8       	mov	r8,26
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	ba 00       	st.h	sp[0x0],r0
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	27 3c       	sub	r12,115
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	57 48       	stdsp	sp[0x1d0],r8
8000208c:	00 00       	add	r0,r0
8000208e:	0a 34       	cp.w	r4,r5

80002090 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002090:	d4 01       	pushm	lr
  log("R");
80002092:	48 3c       	lddpc	r12,8000209c <app_payload_tx_proc+0xc>
80002094:	f0 1f 00 03 	mcall	800020a0 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002098:	d8 02       	popm	pc
8000209a:	00 00       	add	r0,r0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	ba 08       	st.h	sp[0x0],r8
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	5b 0c       	cp.w	r12,-16

800020a4 <app_payload_rx_proc>:
}



static void app_payload_rx_proc(void  * payload)
{
800020a4:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
800020a6:	48 99       	lddpc	r9,800020c8 <app_payload_rx_proc+0x24>
800020a8:	13 88       	ld.ub	r8,r9[0x0]
800020aa:	2f f8       	sub	r8,-1
800020ac:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
800020ae:	30 39       	mov	r9,3
800020b0:	f2 08 18 00 	cp.b	r8,r9
800020b4:	c0 71       	brne	800020c2 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
800020b6:	30 09       	mov	r9,0
800020b8:	48 48       	lddpc	r8,800020c8 <app_payload_rx_proc+0x24>
800020ba:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800020bc:	48 4c       	lddpc	r12,800020cc <app_payload_rx_proc+0x28>
800020be:	f0 1f 00 05 	mcall	800020d0 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
800020c2:	48 58       	lddpc	r8,800020d4 <app_payload_rx_proc+0x30>
800020c4:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
800020c6:	d8 02       	popm	pc
800020c8:	00 00       	add	r0,r0
800020ca:	0a 28       	rsub	r8,r5
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	ba 0c       	st.h	sp[0x0],r12
800020d0:	80 00       	ld.sh	r0,r0[0x0]
800020d2:	5b 0c       	cp.w	r12,-16
800020d4:	00 00       	add	r0,r0
800020d6:	0a 21       	rsub	r1,r5

800020d8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020da:	48 3c       	lddpc	r12,800020e4 <FD_brdcst_func+0xc>
800020dc:	f0 1f 00 03 	mcall	800020e8 <FD_brdcst_func+0x10>
	
}
800020e0:	d8 02       	popm	pc
800020e2:	00 00       	add	r0,r0
800020e4:	80 00       	ld.sh	r0,r0[0x0]
800020e6:	ba 18       	st.h	sp[0x2],r8
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	5b 0c       	cp.w	r12,-16

800020ec <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020ec:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ee:	48 3c       	lddpc	r12,800020f8 <FD_reply_func+0xc>
800020f0:	f0 1f 00 03 	mcall	800020fc <FD_reply_func+0x10>
	
	
}
800020f4:	d8 02       	popm	pc
800020f6:	00 00       	add	r0,r0
800020f8:	80 00       	ld.sh	r0,r0[0x0]
800020fa:	ba 38       	st.h	sp[0x6],r8
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	5b 0c       	cp.w	r12,-16

80002100 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002100:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002102:	48 3c       	lddpc	r12,8000210c <FD_request_func+0xc>
80002104:	f0 1f 00 03 	mcall	80002110 <FD_request_func+0x10>
	
	
}
80002108:	d8 02       	popm	pc
8000210a:	00 00       	add	r0,r0
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	ba 54       	st.h	sp[0xa],r4
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	5b 0c       	cp.w	r12,-16

80002114 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002114:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002116:	48 3c       	lddpc	r12,80002120 <EnOB_brdcst_func+0xc>
80002118:	f0 1f 00 03 	mcall	80002124 <EnOB_brdcst_func+0x10>
}
8000211c:	d8 02       	popm	pc
8000211e:	00 00       	add	r0,r0
80002120:	80 00       	ld.sh	r0,r0[0x0]
80002122:	ba 70       	st.h	sp[0xe],r0
80002124:	80 00       	ld.sh	r0,r0[0x0]
80002126:	5b 0c       	cp.w	r12,-16

80002128 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002128:	eb cd 40 80 	pushm	r7,lr
8000212c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000212e:	19 a9       	ld.ub	r9,r12[0x2]
80002130:	30 08       	mov	r8,0
80002132:	f0 09 18 00 	cp.b	r9,r8
80002136:	c1 91       	brne	80002168 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002138:	19 b8       	ld.ub	r8,r12[0x3]
8000213a:	30 19       	mov	r9,1
8000213c:	f2 08 18 00 	cp.b	r8,r9
80002140:	c0 61       	brne	8000214c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002142:	49 0c       	lddpc	r12,80002180 <EnOB_reply_func+0x58>
80002144:	f0 1f 00 10 	mcall	80002184 <EnOB_reply_func+0x5c>
80002148:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000214c:	58 08       	cp.w	r8,0
8000214e:	c0 61       	brne	8000215a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002150:	48 ec       	lddpc	r12,80002188 <EnOB_reply_func+0x60>
80002152:	f0 1f 00 0d 	mcall	80002184 <EnOB_reply_func+0x5c>
80002156:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000215a:	1a d8       	st.w	--sp,r8
8000215c:	48 cc       	lddpc	r12,8000218c <EnOB_reply_func+0x64>
8000215e:	f0 1f 00 0a 	mcall	80002184 <EnOB_reply_func+0x5c>
80002162:	2f fd       	sub	sp,-4
80002164:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002168:	48 ac       	lddpc	r12,80002190 <EnOB_reply_func+0x68>
8000216a:	f0 1f 00 07 	mcall	80002184 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000216e:	0f a8       	ld.ub	r8,r7[0x2]
80002170:	1a d8       	st.w	--sp,r8
80002172:	48 9c       	lddpc	r12,80002194 <EnOB_reply_func+0x6c>
80002174:	f0 1f 00 04 	mcall	80002184 <EnOB_reply_func+0x5c>
80002178:	2f fd       	sub	sp,-4
8000217a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	ba 88       	st.b	sp[0x0],r8
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	5b 0c       	cp.w	r12,-16
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	ba a0       	st.b	sp[0x2],r0
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	ba b4       	st.b	sp[0x3],r4
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	ba cc       	st.b	sp[0x4],r12
80002194:	80 00       	ld.sh	r0,r0[0x0]
80002196:	ba e8       	st.b	sp[0x6],r8

80002198 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002198:	eb cd 40 80 	pushm	r7,lr
8000219c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000219e:	19 a9       	ld.ub	r9,r12[0x2]
800021a0:	31 18       	mov	r8,17
800021a2:	f0 09 18 00 	cp.b	r9,r8
800021a6:	c0 91       	brne	800021b8 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021a8:	48 ac       	lddpc	r12,800021d0 <SingleDetection_brdcst_func+0x38>
800021aa:	f0 1f 00 0b 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
800021ae:	30 19       	mov	r9,1
800021b0:	48 a8       	lddpc	r8,800021d8 <SingleDetection_brdcst_func+0x40>
800021b2:	b0 89       	st.b	r8[0x0],r9
800021b4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
800021b8:	48 9c       	lddpc	r12,800021dc <SingleDetection_brdcst_func+0x44>
800021ba:	f0 1f 00 07 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
800021be:	0f a8       	ld.ub	r8,r7[0x2]
800021c0:	1a d8       	st.w	--sp,r8
800021c2:	48 8c       	lddpc	r12,800021e0 <SingleDetection_brdcst_func+0x48>
800021c4:	f0 1f 00 04 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
800021c8:	2f fd       	sub	sp,-4
800021ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800021ce:	00 00       	add	r0,r0
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	bb 00       	ld.d	r0,sp
800021d4:	80 00       	ld.sh	r0,r0[0x0]
800021d6:	5b 0c       	cp.w	r12,-16
800021d8:	00 00       	add	r0,r0
800021da:	00 04       	add	r4,r0
800021dc:	80 00       	ld.sh	r0,r0[0x0]
800021de:	bb 14       	ld.d	r4,--sp
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	bb 24       	st.d	sp++,r4

800021e4 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021e4:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021e6:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021ea:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021ec:	4a bc       	lddpc	r12,80002298 <ButtonConfig_brdcst_func+0xb4>
800021ee:	f0 1f 00 2c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021f2:	0f 88       	ld.ub	r8,r7[0x0]
800021f4:	1a d8       	st.w	--sp,r8
800021f6:	4a bc       	lddpc	r12,800022a0 <ButtonConfig_brdcst_func+0xbc>
800021f8:	f0 1f 00 29 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021fc:	1a d5       	st.w	--sp,r5
800021fe:	4a ac       	lddpc	r12,800022a4 <ButtonConfig_brdcst_func+0xc0>
80002200:	f0 1f 00 27 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002204:	0f a8       	ld.ub	r8,r7[0x2]
80002206:	1a d8       	st.w	--sp,r8
80002208:	4a 8c       	lddpc	r12,800022a8 <ButtonConfig_brdcst_func+0xc4>
8000220a:	f0 1f 00 25 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000220e:	2f dd       	sub	sp,-12
80002210:	58 05       	cp.w	r5,0
80002212:	c4 10       	breq	80002294 <ButtonConfig_brdcst_func+0xb0>
80002214:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002216:	4a 64       	lddpc	r4,800022ac <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002218:	4a 63       	lddpc	r3,800022b0 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000221a:	4a 72       	lddpc	r2,800022b4 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000221c:	4a 71       	lddpc	r1,800022b8 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000221e:	4a 80       	lddpc	r0,800022bc <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002220:	0f b9       	ld.ub	r9,r7[0x3]
80002222:	0f c8       	ld.ub	r8,r7[0x4]
80002224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002228:	1a d8       	st.w	--sp,r8
8000222a:	1a d6       	st.w	--sp,r6
8000222c:	08 9c       	mov	r12,r4
8000222e:	f0 1f 00 1c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002232:	0f d9       	ld.ub	r9,r7[0x5]
80002234:	0f e8       	ld.ub	r8,r7[0x6]
80002236:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000223a:	1a d8       	st.w	--sp,r8
8000223c:	1a d6       	st.w	--sp,r6
8000223e:	06 9c       	mov	r12,r3
80002240:	f0 1f 00 17 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002244:	0f f9       	ld.ub	r9,r7[0x7]
80002246:	ef 38 00 08 	ld.ub	r8,r7[8]
8000224a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000224e:	1a d8       	st.w	--sp,r8
80002250:	1a d6       	st.w	--sp,r6
80002252:	04 9c       	mov	r12,r2
80002254:	f0 1f 00 12 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002258:	ef 39 00 09 	ld.ub	r9,r7[9]
8000225c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002260:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002264:	1a d8       	st.w	--sp,r8
80002266:	1a d6       	st.w	--sp,r6
80002268:	02 9c       	mov	r12,r1
8000226a:	f0 1f 00 0d 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000226e:	2f 8d       	sub	sp,-32
80002270:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002274:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002278:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227c:	1a d8       	st.w	--sp,r8
8000227e:	1a d6       	st.w	--sp,r6
80002280:	00 9c       	mov	r12,r0
80002282:	f0 1f 00 07 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
80002286:	2f f6       	sub	r6,-1
80002288:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000228a:	2f ed       	sub	sp,-8
8000228c:	ec 05 18 00 	cp.b	r5,r6
80002290:	fe 9b ff c8 	brhi	80002220 <ButtonConfig_brdcst_func+0x3c>
80002294:	d8 32       	popm	r0-r7,pc
80002296:	00 00       	add	r0,r0
80002298:	80 00       	ld.sh	r0,r0[0x0]
8000229a:	bb 38       	mul	r8,sp
8000229c:	80 00       	ld.sh	r0,r0[0x0]
8000229e:	5b 0c       	cp.w	r12,-16
800022a0:	80 00       	ld.sh	r0,r0[0x0]
800022a2:	bb 58       	asr	r8,0x1b
800022a4:	80 00       	ld.sh	r0,r0[0x0]
800022a6:	bb 6c       	lsl	r12,0x1a
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	bb 84       	lsr	r4,0x1a
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	bb a4       	sbr	r4,0x1a
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	bb cc       	cbr	r12,0x1a
800022b4:	80 00       	ld.sh	r0,r0[0x0]
800022b6:	bb f4       	*unknown*
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	bc 18       	st.h	lr[0x2],r8
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	bc 40       	st.h	lr[0x8],r0

800022c0 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022c0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022c4:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022c8:	0f 89       	ld.ub	r9,r7[0x0]
800022ca:	30 08       	mov	r8,0
800022cc:	f0 09 18 00 	cp.b	r9,r8
800022d0:	c0 c1       	brne	800022e8 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022d2:	48 9c       	lddpc	r12,800022f4 <ButtonConfig_reply_func+0x34>
800022d4:	f0 1f 00 09 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022d8:	0f 98       	ld.ub	r8,r7[0x1]
800022da:	1a d8       	st.w	--sp,r8
800022dc:	48 8c       	lddpc	r12,800022fc <ButtonConfig_reply_func+0x3c>
800022de:	f0 1f 00 07 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022e2:	2f fd       	sub	sp,-4
800022e4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022e8:	48 6c       	lddpc	r12,80002300 <ButtonConfig_reply_func+0x40>
800022ea:	f0 1f 00 04 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800022f2:	00 00       	add	r0,r0
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	bc 64       	st.h	lr[0xc],r4
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	5b 0c       	cp.w	r12,-16
800022fc:	80 00       	ld.sh	r0,r0[0x0]
800022fe:	bb 58       	asr	r8,0x1b
80002300:	80 00       	ld.sh	r0,r0[0x0]
80002302:	bc 7c       	st.h	lr[0xe],r12

80002304 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002304:	eb cd 40 80 	pushm	r7,lr
80002308:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000230a:	19 a9       	ld.ub	r9,r12[0x2]
8000230c:	30 08       	mov	r8,0
8000230e:	f0 09 18 00 	cp.b	r9,r8
80002312:	c1 11       	brne	80002334 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
80002314:	49 3c       	lddpc	r12,80002360 <DataSession_reply_func+0x5c>
80002316:	f0 1f 00 14 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
8000231a:	0f b8       	ld.ub	r8,r7[0x3]
8000231c:	1a d8       	st.w	--sp,r8
8000231e:	49 3c       	lddpc	r12,80002368 <DataSession_reply_func+0x64>
80002320:	f0 1f 00 11 	mcall	80002364 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
80002324:	0f c8       	ld.ub	r8,r7[0x4]
80002326:	1a d8       	st.w	--sp,r8
80002328:	49 1c       	lddpc	r12,8000236c <DataSession_reply_func+0x68>
8000232a:	f0 1f 00 0f 	mcall	80002364 <DataSession_reply_func+0x60>
8000232e:	2f ed       	sub	sp,-8
80002330:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
80002334:	48 fc       	lddpc	r12,80002370 <DataSession_reply_func+0x6c>
80002336:	f0 1f 00 0c 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
8000233a:	0f a8       	ld.ub	r8,r7[0x2]
8000233c:	1a d8       	st.w	--sp,r8
8000233e:	48 ec       	lddpc	r12,80002374 <DataSession_reply_func+0x70>
80002340:	f0 1f 00 09 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
80002344:	0f b8       	ld.ub	r8,r7[0x3]
80002346:	1a d8       	st.w	--sp,r8
80002348:	48 cc       	lddpc	r12,80002378 <DataSession_reply_func+0x74>
8000234a:	f0 1f 00 07 	mcall	80002364 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
8000234e:	0f c8       	ld.ub	r8,r7[0x4]
80002350:	1a d8       	st.w	--sp,r8
80002352:	48 bc       	lddpc	r12,8000237c <DataSession_reply_func+0x78>
80002354:	f0 1f 00 04 	mcall	80002364 <DataSession_reply_func+0x60>
80002358:	2f dd       	sub	sp,-12
8000235a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000235e:	00 00       	add	r0,r0
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	bc 98       	st.b	lr[0x1],r8
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	5b 0c       	cp.w	r12,-16
80002368:	80 00       	ld.sh	r0,r0[0x0]
8000236a:	bc a8       	st.b	lr[0x2],r8
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	bc b4       	st.b	lr[0x3],r4
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	bc c0       	st.b	lr[0x4],r0
80002374:	80 00       	ld.sh	r0,r0[0x0]
80002376:	bc d0       	st.b	lr[0x5],r0
80002378:	80 00       	ld.sh	r0,r0[0x0]
8000237a:	bc e0       	st.b	lr[0x6],r0
8000237c:	80 00       	ld.sh	r0,r0[0x0]
8000237e:	bc ec       	st.b	lr[0x6],r12

80002380 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002380:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002384:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002388:	0f 98       	ld.ub	r8,r7[0x1]
8000238a:	1a d8       	st.w	--sp,r8
8000238c:	48 bc       	lddpc	r12,800023b8 <CallControl_brdcst_func+0x38>
8000238e:	f0 1f 00 0c 	mcall	800023bc <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
80002392:	2f fd       	sub	sp,-4
80002394:	0f 99       	ld.ub	r9,r7[0x1]
80002396:	30 38       	mov	r8,3
80002398:	f0 09 18 00 	cp.b	r9,r8
8000239c:	c0 41       	brne	800023a4 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
8000239e:	30 09       	mov	r9,0
800023a0:	48 88       	lddpc	r8,800023c0 <CallControl_brdcst_func+0x40>
800023a2:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800023a4:	0f 99       	ld.ub	r9,r7[0x1]
800023a6:	30 48       	mov	r8,4
800023a8:	f0 09 18 00 	cp.b	r9,r8
800023ac:	c0 41       	brne	800023b4 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800023ae:	30 19       	mov	r9,1
800023b0:	48 48       	lddpc	r8,800023c0 <CallControl_brdcst_func+0x40>
800023b2:	b0 89       	st.b	r8[0x0],r9
800023b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800023b8:	80 00       	ld.sh	r0,r0[0x0]
800023ba:	bc f8       	st.b	lr[0x7],r8
800023bc:	80 00       	ld.sh	r0,r0[0x0]
800023be:	5b 0c       	cp.w	r12,-16
800023c0:	00 00       	add	r0,r0
800023c2:	0a 23       	rsub	r3,r5

800023c4 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023c4:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800023c8:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800023cc:	0f 99       	ld.ub	r9,r7[0x1]
800023ce:	30 08       	mov	r8,0
800023d0:	f0 09 18 00 	cp.b	r9,r8
800023d4:	c0 71       	brne	800023e2 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800023d6:	48 ac       	lddpc	r12,800023fc <TransmitControl_brdcst_func+0x38>
800023d8:	f0 1f 00 0a 	mcall	80002400 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800023dc:	30 09       	mov	r9,0
800023de:	48 a8       	lddpc	r8,80002404 <TransmitControl_brdcst_func+0x40>
800023e0:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800023e2:	0f 99       	ld.ub	r9,r7[0x1]
800023e4:	30 18       	mov	r8,1
800023e6:	f0 09 18 00 	cp.b	r9,r8
800023ea:	c0 71       	brne	800023f8 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800023ec:	48 7c       	lddpc	r12,80002408 <TransmitControl_brdcst_func+0x44>
800023ee:	f0 1f 00 05 	mcall	80002400 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800023f2:	30 19       	mov	r9,1
800023f4:	48 48       	lddpc	r8,80002404 <TransmitControl_brdcst_func+0x40>
800023f6:	b0 89       	st.b	r8[0x0],r9
800023f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	bd 10       	ld.d	r0,--lr
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	5b 0c       	cp.w	r12,-16
80002404:	00 00       	add	r0,r0
80002406:	0a 22       	rsub	r2,r5
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	bd 28       	st.d	lr++,r8

8000240c <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
8000240c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002410:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002414:	0f 89       	ld.ub	r9,r7[0x0]
80002416:	30 08       	mov	r8,0
80002418:	f0 09 18 00 	cp.b	r9,r8
8000241c:	c1 61       	brne	80002448 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000241e:	48 ec       	lddpc	r12,80002454 <TransmitControl_reply_func+0x48>
80002420:	f0 1f 00 0e 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002424:	0f 98       	ld.ub	r8,r7[0x1]
80002426:	1a d8       	st.w	--sp,r8
80002428:	48 dc       	lddpc	r12,8000245c <TransmitControl_reply_func+0x50>
8000242a:	f0 1f 00 0c 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000242e:	0f a8       	ld.ub	r8,r7[0x2]
80002430:	1a d8       	st.w	--sp,r8
80002432:	48 cc       	lddpc	r12,80002460 <TransmitControl_reply_func+0x54>
80002434:	f0 1f 00 09 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002438:	0f b8       	ld.ub	r8,r7[0x3]
8000243a:	1a d8       	st.w	--sp,r8
8000243c:	48 ac       	lddpc	r12,80002464 <TransmitControl_reply_func+0x58>
8000243e:	f0 1f 00 07 	mcall	80002458 <TransmitControl_reply_func+0x4c>
80002442:	2f dd       	sub	sp,-12
80002444:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002448:	48 8c       	lddpc	r12,80002468 <TransmitControl_reply_func+0x5c>
8000244a:	f0 1f 00 04 	mcall	80002458 <TransmitControl_reply_func+0x4c>
8000244e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002452:	00 00       	add	r0,r0
80002454:	80 00       	ld.sh	r0,r0[0x0]
80002456:	bd 3c       	mul	r12,lr
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	5b 0c       	cp.w	r12,-16
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	bd 58       	asr	r8,0x1d
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	bd 6c       	lsl	r12,0x1c
80002464:	80 00       	ld.sh	r0,r0[0x0]
80002466:	bd 88       	lsr	r8,0x1c
80002468:	80 00       	ld.sh	r0,r0[0x0]
8000246a:	bd 98       	lsr	r8,0x1d

8000246c <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
8000246c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000246e:	19 a9       	ld.ub	r9,r12[0x2]
80002470:	30 08       	mov	r8,0
80002472:	f0 09 18 00 	cp.b	r9,r8
80002476:	c0 51       	brne	80002480 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002478:	48 4c       	lddpc	r12,80002488 <AudioRoutingControl_reply_func+0x1c>
8000247a:	f0 1f 00 05 	mcall	8000248c <AudioRoutingControl_reply_func+0x20>
8000247e:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002480:	48 4c       	lddpc	r12,80002490 <AudioRoutingControl_reply_func+0x24>
80002482:	f0 1f 00 03 	mcall	8000248c <AudioRoutingControl_reply_func+0x20>
80002486:	d8 02       	popm	pc
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	bd b0       	sbr	r0,0x1d
8000248c:	80 00       	ld.sh	r0,r0[0x0]
8000248e:	5b 0c       	cp.w	r12,-16
80002490:	80 00       	ld.sh	r0,r0[0x0]
80002492:	bd c0       	cbr	r0,0x1c

80002494 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002494:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002498:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000249c:	0f 89       	ld.ub	r9,r7[0x0]
8000249e:	30 08       	mov	r8,0
800024a0:	f0 09 18 00 	cp.b	r9,r8
800024a4:	c1 b1       	brne	800024da <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800024a6:	0f b8       	ld.ub	r8,r7[0x3]
800024a8:	31 09       	mov	r9,16
800024aa:	f2 08 18 00 	cp.b	r8,r9
800024ae:	c0 f1       	brne	800024cc <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800024b0:	48 dc       	lddpc	r12,800024e4 <Volume_reply_func+0x50>
800024b2:	f0 1f 00 0e 	mcall	800024e8 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800024b6:	0f 99       	ld.ub	r9,r7[0x1]
800024b8:	0f a8       	ld.ub	r8,r7[0x2]
800024ba:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800024be:	1a d8       	st.w	--sp,r8
800024c0:	48 bc       	lddpc	r12,800024ec <Volume_reply_func+0x58>
800024c2:	f0 1f 00 0a 	mcall	800024e8 <Volume_reply_func+0x54>
800024c6:	2f fd       	sub	sp,-4
800024c8:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800024cc:	1a d8       	st.w	--sp,r8
800024ce:	48 9c       	lddpc	r12,800024f0 <Volume_reply_func+0x5c>
800024d0:	f0 1f 00 06 	mcall	800024e8 <Volume_reply_func+0x54>
800024d4:	2f fd       	sub	sp,-4
800024d6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024da:	48 7c       	lddpc	r12,800024f4 <Volume_reply_func+0x60>
800024dc:	f0 1f 00 03 	mcall	800024e8 <Volume_reply_func+0x54>
800024e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800024e4:	80 00       	ld.sh	r0,r0[0x0]
800024e6:	bd d4       	cbr	r4,0x1d
800024e8:	80 00       	ld.sh	r0,r0[0x0]
800024ea:	5b 0c       	cp.w	r12,-16
800024ec:	80 00       	ld.sh	r0,r0[0x0]
800024ee:	bd e8       	*unknown*
800024f0:	80 00       	ld.sh	r0,r0[0x0]
800024f2:	be 04       	st.h	pc[0x0],r4
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	be 1c       	st.h	pc[0x2],r12

800024f8 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800024f8:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800024fa:	19 d9       	ld.ub	r9,r12[0x5]
800024fc:	30 08       	mov	r8,0
800024fe:	f0 09 18 00 	cp.b	r9,r8
80002502:	c0 81       	brne	80002512 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002504:	10 99       	mov	r9,r8
80002506:	48 78       	lddpc	r8,80002520 <spk_brdcst_func+0x28>
80002508:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
8000250a:	48 7c       	lddpc	r12,80002524 <spk_brdcst_func+0x2c>
8000250c:	f0 1f 00 07 	mcall	80002528 <spk_brdcst_func+0x30>
80002510:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002512:	30 19       	mov	r9,1
80002514:	48 38       	lddpc	r8,80002520 <spk_brdcst_func+0x28>
80002516:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002518:	48 5c       	lddpc	r12,8000252c <spk_brdcst_func+0x34>
8000251a:	f0 1f 00 04 	mcall	80002528 <spk_brdcst_func+0x30>
8000251e:	d8 02       	popm	pc
80002520:	00 00       	add	r0,r0
80002522:	0a 20       	rsub	r0,r5
80002524:	80 00       	ld.sh	r0,r0[0x0]
80002526:	be 34       	st.h	pc[0x6],r4
80002528:	80 00       	ld.sh	r0,r0[0x0]
8000252a:	5b 0c       	cp.w	r12,-16
8000252c:	80 00       	ld.sh	r0,r0[0x0]
8000252e:	be 44       	st.h	pc[0x8],r4

80002530 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002530:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002532:	19 a9       	ld.ub	r9,r12[0x2]
80002534:	30 08       	mov	r8,0
80002536:	f0 09 18 00 	cp.b	r9,r8
8000253a:	c0 f1       	brne	80002558 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
8000253c:	19 e9       	ld.ub	r9,r12[0x6]
8000253e:	f0 09 18 00 	cp.b	r9,r8
80002542:	c0 40       	breq	8000254a <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002544:	30 19       	mov	r9,1
80002546:	48 98       	lddpc	r8,80002568 <spk_reply_func+0x38>
80002548:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000254a:	19 e8       	ld.ub	r8,r12[0x6]
8000254c:	1a d8       	st.w	--sp,r8
8000254e:	48 8c       	lddpc	r12,8000256c <spk_reply_func+0x3c>
80002550:	f0 1f 00 08 	mcall	80002570 <spk_reply_func+0x40>
80002554:	2f fd       	sub	sp,-4
80002556:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002558:	30 09       	mov	r9,0
8000255a:	48 48       	lddpc	r8,80002568 <spk_reply_func+0x38>
8000255c:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000255e:	48 6c       	lddpc	r12,80002574 <spk_reply_func+0x44>
80002560:	f0 1f 00 04 	mcall	80002570 <spk_reply_func+0x40>
80002564:	d8 02       	popm	pc
80002566:	00 00       	add	r0,r0
80002568:	00 00       	add	r0,r0
8000256a:	0a 20       	rsub	r0,r5
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	be 50       	st.h	pc[0xa],r0
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	5b 0c       	cp.w	r12,-16
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	be 60       	st.h	pc[0xc],r0

80002578 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002578:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
8000257c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002580:	0f a9       	ld.ub	r9,r7[0x2]
80002582:	30 08       	mov	r8,0
80002584:	f0 09 18 00 	cp.b	r9,r8
80002588:	c0 71       	brne	80002596 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000258a:	48 dc       	lddpc	r12,800025bc <mic_brdcst_func+0x44>
8000258c:	f0 1f 00 0d 	mcall	800025c0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002590:	30 09       	mov	r9,0
80002592:	48 d8       	lddpc	r8,800025c4 <mic_brdcst_func+0x4c>
80002594:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002596:	0f a9       	ld.ub	r9,r7[0x2]
80002598:	31 18       	mov	r8,17
8000259a:	f0 09 18 00 	cp.b	r9,r8
8000259e:	c0 d1       	brne	800025b8 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800025a0:	48 ac       	lddpc	r12,800025c8 <mic_brdcst_func+0x50>
800025a2:	f0 1f 00 08 	mcall	800025c0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800025a6:	48 89       	lddpc	r9,800025c4 <mic_brdcst_func+0x4c>
800025a8:	30 18       	mov	r8,1
800025aa:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800025ac:	13 89       	ld.ub	r9,r9[0x0]
800025ae:	f0 09 18 00 	cp.b	r9,r8
800025b2:	c0 31       	brne	800025b8 <mic_brdcst_func+0x40>
800025b4:	48 68       	lddpc	r8,800025cc <mic_brdcst_func+0x54>
800025b6:	11 88       	ld.ub	r8,r8[0x0]
800025b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800025bc:	80 00       	ld.sh	r0,r0[0x0]
800025be:	be 6c       	st.h	pc[0xc],r12
800025c0:	80 00       	ld.sh	r0,r0[0x0]
800025c2:	5b 0c       	cp.w	r12,-16
800025c4:	00 00       	add	r0,r0
800025c6:	0a 30       	cp.w	r0,r5
800025c8:	80 00       	ld.sh	r0,r0[0x0]
800025ca:	be 80       	st.b	pc[0x0],r0
800025cc:	00 00       	add	r0,r0
800025ce:	0a 23       	rsub	r3,r5

800025d0 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025d0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025d4:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025d8:	49 ac       	lddpc	r12,80002640 <mic_reply_func+0x70>
800025da:	f0 1f 00 1b 	mcall	80002644 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025de:	0f 89       	ld.ub	r9,r7[0x0]
800025e0:	30 08       	mov	r8,0
800025e2:	f0 09 18 00 	cp.b	r9,r8
800025e6:	c2 71       	brne	80002634 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025e8:	0f 98       	ld.ub	r8,r7[0x1]
800025ea:	30 29       	mov	r9,2
800025ec:	f2 08 18 00 	cp.b	r8,r9
800025f0:	c1 b1       	brne	80002626 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800025f2:	49 6c       	lddpc	r12,80002648 <mic_reply_func+0x78>
800025f4:	f0 1f 00 14 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800025f8:	0f a8       	ld.ub	r8,r7[0x2]
800025fa:	1a d8       	st.w	--sp,r8
800025fc:	49 4c       	lddpc	r12,8000264c <mic_reply_func+0x7c>
800025fe:	f0 1f 00 12 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002602:	0f b8       	ld.ub	r8,r7[0x3]
80002604:	1a d8       	st.w	--sp,r8
80002606:	49 3c       	lddpc	r12,80002650 <mic_reply_func+0x80>
80002608:	f0 1f 00 0f 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000260c:	0f c8       	ld.ub	r8,r7[0x4]
8000260e:	1a d8       	st.w	--sp,r8
80002610:	49 1c       	lddpc	r12,80002654 <mic_reply_func+0x84>
80002612:	f0 1f 00 0d 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002616:	0f d8       	ld.ub	r8,r7[0x5]
80002618:	1a d8       	st.w	--sp,r8
8000261a:	49 0c       	lddpc	r12,80002658 <mic_reply_func+0x88>
8000261c:	f0 1f 00 0a 	mcall	80002644 <mic_reply_func+0x74>
80002620:	2f cd       	sub	sp,-16
80002622:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002626:	1a d8       	st.w	--sp,r8
80002628:	48 dc       	lddpc	r12,8000265c <mic_reply_func+0x8c>
8000262a:	f0 1f 00 07 	mcall	80002644 <mic_reply_func+0x74>
8000262e:	2f fd       	sub	sp,-4
80002630:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002634:	48 bc       	lddpc	r12,80002660 <mic_reply_func+0x90>
80002636:	f0 1f 00 04 	mcall	80002644 <mic_reply_func+0x74>
8000263a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000263e:	00 00       	add	r0,r0
80002640:	80 00       	ld.sh	r0,r0[0x0]
80002642:	be 94       	st.b	pc[0x1],r4
80002644:	80 00       	ld.sh	r0,r0[0x0]
80002646:	5b 0c       	cp.w	r12,-16
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	be a4       	st.b	pc[0x2],r4
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	be b8       	st.b	pc[0x3],r8
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	be cc       	st.b	pc[0x4],r12
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	be e8       	st.b	pc[0x6],r8
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	bf 00       	ld.d	r0,pc
8000265c:	80 00       	ld.sh	r0,r0[0x0]
8000265e:	bf 18       	ld.d	r8,--pc
80002660:	80 00       	ld.sh	r0,r0[0x0]
80002662:	bf 30       	mul	r0,pc

80002664 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002664:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002668:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
8000266c:	48 bc       	lddpc	r12,80002698 <dcm_brdcst_func+0x34>
8000266e:	f0 1f 00 0c 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002672:	0f 88       	ld.ub	r8,r7[0x0]
80002674:	1a d8       	st.w	--sp,r8
80002676:	48 bc       	lddpc	r12,800026a0 <dcm_brdcst_func+0x3c>
80002678:	f0 1f 00 09 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000267c:	0f a8       	ld.ub	r8,r7[0x2]
8000267e:	1a d8       	st.w	--sp,r8
80002680:	48 9c       	lddpc	r12,800026a4 <dcm_brdcst_func+0x40>
80002682:	f0 1f 00 07 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002686:	0f 98       	ld.ub	r8,r7[0x1]
80002688:	1a d8       	st.w	--sp,r8
8000268a:	48 8c       	lddpc	r12,800026a8 <dcm_brdcst_func+0x44>
8000268c:	f0 1f 00 04 	mcall	8000269c <dcm_brdcst_func+0x38>
80002690:	2f dd       	sub	sp,-12
	
	
}
80002692:	e3 cd 80 80 	ldm	sp++,r7,pc
80002696:	00 00       	add	r0,r0
80002698:	80 00       	ld.sh	r0,r0[0x0]
8000269a:	bf 40       	asr	r0,0x1e
8000269c:	80 00       	ld.sh	r0,r0[0x0]
8000269e:	5b 0c       	cp.w	r12,-16
800026a0:	80 00       	ld.sh	r0,r0[0x0]
800026a2:	bf 54       	asr	r4,0x1f
800026a4:	80 00       	ld.sh	r0,r0[0x0]
800026a6:	bf 68       	lsl	r8,0x1e
800026a8:	80 00       	ld.sh	r0,r0[0x0]
800026aa:	bf 80       	lsr	r0,0x1e

800026ac <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800026ac:	eb cd 40 80 	pushm	r7,lr
800026b0:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800026b2:	19 a9       	ld.ub	r9,r12[0x2]
800026b4:	30 08       	mov	r8,0
800026b6:	f0 09 18 00 	cp.b	r9,r8
800026ba:	c1 b1       	brne	800026f0 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800026bc:	19 b8       	ld.ub	r8,r12[0x3]
800026be:	30 19       	mov	r9,1
800026c0:	f2 08 18 00 	cp.b	r8,r9
800026c4:	c0 51       	brne	800026ce <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800026c6:	48 ec       	lddpc	r12,800026fc <dcm_reply_func+0x50>
800026c8:	f0 1f 00 0e 	mcall	80002700 <dcm_reply_func+0x54>
800026cc:	c0 a8       	rjmp	800026e0 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800026ce:	58 08       	cp.w	r8,0
800026d0:	c0 51       	brne	800026da <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026d2:	48 dc       	lddpc	r12,80002704 <dcm_reply_func+0x58>
800026d4:	f0 1f 00 0b 	mcall	80002700 <dcm_reply_func+0x54>
800026d8:	c0 48       	rjmp	800026e0 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026da:	48 cc       	lddpc	r12,80002708 <dcm_reply_func+0x5c>
800026dc:	f0 1f 00 09 	mcall	80002700 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026e0:	0f d8       	ld.ub	r8,r7[0x5]
800026e2:	1a d8       	st.w	--sp,r8
800026e4:	48 ac       	lddpc	r12,8000270c <dcm_reply_func+0x60>
800026e6:	f0 1f 00 07 	mcall	80002700 <dcm_reply_func+0x54>
800026ea:	2f fd       	sub	sp,-4
800026ec:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800026f0:	48 8c       	lddpc	r12,80002710 <dcm_reply_func+0x64>
800026f2:	f0 1f 00 04 	mcall	80002700 <dcm_reply_func+0x54>
800026f6:	e3 cd 80 80 	ldm	sp++,r7,pc
800026fa:	00 00       	add	r0,r0
800026fc:	80 00       	ld.sh	r0,r0[0x0]
800026fe:	bf 9c       	lsr	r12,0x1f
80002700:	80 00       	ld.sh	r0,r0[0x0]
80002702:	5b 0c       	cp.w	r12,-16
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	bf b0       	sbr	r0,0x1f
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	bf c4       	cbr	r4,0x1e
8000270c:	80 00       	ld.sh	r0,r0[0x0]
8000270e:	bf d8       	cbr	r8,0x1f
80002710:	80 00       	ld.sh	r0,r0[0x0]
80002712:	bf e4       	*unknown*

80002714 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002714:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002716:	19 a9       	ld.ub	r9,r12[0x2]
80002718:	30 08       	mov	r8,0
8000271a:	f0 09 18 00 	cp.b	r9,r8
8000271e:	c0 51       	brne	80002728 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002720:	48 4c       	lddpc	r12,80002730 <ToneControl_reply_func+0x1c>
80002722:	f0 1f 00 05 	mcall	80002734 <ToneControl_reply_func+0x20>
80002726:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002728:	48 4c       	lddpc	r12,80002738 <ToneControl_reply_func+0x24>
8000272a:	f0 1f 00 03 	mcall	80002734 <ToneControl_reply_func+0x20>
8000272e:	d8 02       	popm	pc
80002730:	80 00       	ld.sh	r0,r0[0x0]
80002732:	bf f0       	*unknown*
80002734:	80 00       	ld.sh	r0,r0[0x0]
80002736:	5b 0c       	cp.w	r12,-16
80002738:	80 00       	ld.sh	r0,r0[0x0]
8000273a:	bf fc       	*unknown*

8000273c <app_cfg>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
8000273c:	d4 31       	pushm	r0-r7,lr
8000273e:	20 1d       	sub	sp,4
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	//static const uint8_t test_data[8] = {0x11, 0x23, 0x33, 0x67, 0x89, 0xAB, 0xCD, 0xEF};
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	xLastWakeTime = xTaskGetTickCount();
80002740:	f0 1f 00 39 	mcall	80002824 <app_cfg+0xe8>
80002744:	4b 98       	lddpc	r8,80002828 <app_cfg+0xec>
80002746:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		switch(OB_State)
80002748:	4b 97       	lddpc	r7,8000282c <app_cfg+0xf0>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
8000274a:	4b a5       	lddpc	r5,80002830 <app_cfg+0xf4>
							OB_State = OB_WAITINGAPPTASK;
							log("get time okay!\n");
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
8000274c:	30 92       	mov	r2,9
8000274e:	32 01       	mov	r1,32
80002750:	30 06       	mov	r6,0
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
							
							OB_State = OB_WAITINGAPPTASK;
80002752:	30 30       	mov	r0,3
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
						}
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
80002754:	4b 84       	lddpc	r4,80002834 <app_cfg+0xf8>
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		switch(OB_State)
80002756:	6e 08       	ld.w	r8,r7[0x0]
80002758:	58 28       	cp.w	r8,2
8000275a:	c3 40       	breq	800027c2 <app_cfg+0x86>
8000275c:	58 38       	cp.w	r8,3
8000275e:	c4 00       	breq	800027de <app_cfg+0xa2>
80002760:	58 08       	cp.w	r8,0
80002762:	c5 a1       	brne	80002816 <app_cfg+0xda>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002764:	4b 58       	lddpc	r8,80002838 <app_cfg+0xfc>
80002766:	70 08       	ld.w	r8,r8[0x0]
80002768:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000276c:	58 38       	cp.w	r8,3
8000276e:	c1 21       	brne	80002792 <app_cfg+0x56>
80002770:	4b 38       	lddpc	r8,8000283c <app_cfg+0x100>
80002772:	11 88       	ld.ub	r8,r8[0x0]
80002774:	58 08       	cp.w	r8,0
80002776:	c0 e1       	brne	80002792 <app_cfg+0x56>
				{
					connect_flag=1;
80002778:	30 19       	mov	r9,1
8000277a:	4b 18       	lddpc	r8,8000283c <app_cfg+0x100>
8000277c:	b0 89       	st.b	r8[0x0],r9
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
8000277e:	30 cb       	mov	r11,12
80002780:	30 1c       	mov	r12,1
80002782:	f0 1f 00 30 	mcall	80002840 <app_cfg+0x104>
					OB_State = OB_CONNECTEDWAITTINGSYNTIME;
80002786:	30 28       	mov	r8,2
80002788:	8f 08       	st.w	r7[0x0],r8
					//vTaskResume(save_handle);
					log("connect OB okay!\n");
8000278a:	4a fc       	lddpc	r12,80002844 <app_cfg+0x108>
8000278c:	f0 1f 00 2f 	mcall	80002848 <app_cfg+0x10c>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002790:	c4 38       	rjmp	80002816 <app_cfg+0xda>
					//vTaskResume(save_handle);
					log("connect OB okay!\n");
				}
				else
				{
					nop();
80002792:	d7 03       	nop
					nop();
80002794:	d7 03       	nop
					nop();
80002796:	d7 03       	nop
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
80002798:	4a dc       	lddpc	r12,8000284c <app_cfg+0x110>
8000279a:	f0 1f 00 2c 	mcall	80002848 <app_cfg+0x10c>
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
					Current_time.Hour, Current_time.Minute, Current_time.Second);
8000279e:	4a d8       	lddpc	r8,80002850 <app_cfg+0x114>
800027a0:	11 de       	ld.ub	lr,r8[0x5]
800027a2:	11 cc       	ld.ub	r12,r8[0x4]
800027a4:	11 bb       	ld.ub	r11,r8[0x3]
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
800027a6:	11 aa       	ld.ub	r10,r8[0x2]
800027a8:	11 99       	ld.ub	r9,r8[0x1]
800027aa:	11 88       	ld.ub	r8,r8[0x0]
					nop();
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
800027ac:	1a de       	st.w	--sp,lr
800027ae:	1a dc       	st.w	--sp,r12
800027b0:	1a db       	st.w	--sp,r11
800027b2:	1a da       	st.w	--sp,r10
800027b4:	1a d9       	st.w	--sp,r9
800027b6:	1a d8       	st.w	--sp,r8
800027b8:	4a 7c       	lddpc	r12,80002854 <app_cfg+0x118>
800027ba:	f0 1f 00 24 	mcall	80002848 <app_cfg+0x10c>
800027be:	2f ad       	sub	sp,-24
800027c0:	c2 b8       	rjmp	80002816 <app_cfg+0xda>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
800027c2:	0b 88       	ld.ub	r8,r5[0x0]
800027c4:	58 08       	cp.w	r8,0
800027c6:	c0 60       	breq	800027d2 <app_cfg+0x96>
							
							OB_State = OB_WAITINGAPPTASK;
800027c8:	8f 00       	st.w	r7[0x0],r0
							log("get time okay!\n");
800027ca:	4a 4c       	lddpc	r12,80002858 <app_cfg+0x11c>
800027cc:	f0 1f 00 1f 	mcall	80002848 <app_cfg+0x10c>
800027d0:	c2 38       	rjmp	80002816 <app_cfg+0xda>
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
800027d2:	04 9a       	mov	r10,r2
800027d4:	02 9b       	mov	r11,r1
800027d6:	0c 9c       	mov	r12,r6
800027d8:	f0 1f 00 21 	mcall	8000285c <app_cfg+0x120>
800027dc:	c1 d8       	rjmp	80002816 <app_cfg+0xda>
						}
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
800027de:	68 0c       	ld.w	r12,r4[0x0]
800027e0:	0c 99       	mov	r9,r6
800027e2:	e0 6a 0f a0 	mov	r10,4000
800027e6:	1a 9b       	mov	r11,sp
800027e8:	f0 1f 00 1e 	mcall	80002860 <app_cfg+0x124>
800027ec:	58 1c       	cp.w	r12,1
800027ee:	c1 01       	brne	8000280e <app_cfg+0xd2>
					{
						if(data_ptr!=NULL){//Resend message
800027f0:	40 0c       	lddsp	r12,sp[0x0]
800027f2:	58 0c       	cp.w	r12,0
800027f4:	c0 d0       	breq	8000280e <app_cfg+0xd2>
							
							//Message_Protocol_t *ptr = (Message_Protocol_t* )data_ptr;
							//xgflash_message_save(data_ptr, sizeof(Message_Protocol_t), TRUE);
							//log("receive data : %d", ptr->data.XG_Time.Second);
							xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);
800027f6:	04 9a       	mov	r10,r2
800027f8:	02 9b       	mov	r11,r1
800027fa:	f0 1f 00 19 	mcall	8000285c <app_cfg+0x120>
							
							//flashc_memset8((void*)0x80038000, 0x02, 5, TRUE);
							
							set_message_store(data_ptr);
800027fe:	49 a8       	lddpc	r8,80002864 <app_cfg+0x128>
80002800:	70 0c       	ld.w	r12,r8[0x0]
80002802:	40 0b       	lddsp	r11,sp[0x0]
80002804:	f0 1f 00 19 	mcall	80002868 <app_cfg+0x12c>
							log("receive okay!\n");
80002808:	49 9c       	lddpc	r12,8000286c <app_cfg+0x130>
8000280a:	f0 1f 00 10 	mcall	80002848 <app_cfg+0x10c>
					//}
					//else
					//{
					//log("no find card...\n");
					//}
					nop();
8000280e:	d7 03       	nop
					//log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					//Current_time.Year, Current_time.Month, Current_time.Day,
					//Current_time.Hour, Current_time.Minute, Current_time.Second);
					log("app task run!\n");
80002810:	49 8c       	lddpc	r12,80002870 <app_cfg+0x134>
80002812:	f0 1f 00 0e 	mcall	80002848 <app_cfg+0x10c>
			break;
				
		} //End of switch on OB_State.
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002816:	e0 6b 0f a0 	mov	r11,4000
8000281a:	48 4c       	lddpc	r12,80002828 <app_cfg+0xec>
8000281c:	f0 1f 00 16 	mcall	80002874 <app_cfg+0x138>
	}
80002820:	c9 bb       	rjmp	80002756 <app_cfg+0x1a>
80002822:	00 00       	add	r0,r0
80002824:	80 00       	ld.sh	r0,r0[0x0]
80002826:	54 38       	stdsp	sp[0x10c],r8
80002828:	00 00       	add	r0,r0
8000282a:	0a 2c       	rsub	r12,r5
8000282c:	00 00       	add	r0,r0
8000282e:	0a 24       	rsub	r4,r5
80002830:	00 00       	add	r0,r0
80002832:	00 04       	add	r4,r0
80002834:	00 00       	add	r0,r0
80002836:	0a 5c       	eor	r12,r5
80002838:	00 00       	add	r0,r0
8000283a:	0c e0       	st.h	--r6,r0
8000283c:	00 00       	add	r0,r0
8000283e:	0a 29       	rsub	r9,r5
80002840:	80 00       	ld.sh	r0,r0[0x0]
80002842:	33 24       	mov	r4,50
80002844:	80 00       	ld.sh	r0,r0[0x0]
80002846:	c0 08       	rjmp	80002846 <app_cfg+0x10a>
80002848:	80 00       	ld.sh	r0,r0[0x0]
8000284a:	5b 0c       	cp.w	r12,-16
8000284c:	80 00       	ld.sh	r0,r0[0x0]
8000284e:	c0 1c       	rcall	80002850 <app_cfg+0x114>
80002850:	00 00       	add	r0,r0
80002852:	0c e4       	st.h	--r6,r4
80002854:	80 00       	ld.sh	r0,r0[0x0]
80002856:	c0 2c       	rcall	8000285a <app_cfg+0x11e>
80002858:	80 00       	ld.sh	r0,r0[0x0]
8000285a:	c0 58       	rjmp	80002864 <app_cfg+0x128>
8000285c:	80 00       	ld.sh	r0,r0[0x0]
8000285e:	32 58       	mov	r8,37
80002860:	80 00       	ld.sh	r0,r0[0x0]
80002862:	4d 18       	lddpc	r8,800029a4 <DataSession_brdcst_func+0xd4>
80002864:	00 00       	add	r0,r0
80002866:	0a 68       	and	r8,r5
80002868:	80 00       	ld.sh	r0,r0[0x0]
8000286a:	31 bc       	mov	r12,27
8000286c:	80 00       	ld.sh	r0,r0[0x0]
8000286e:	c0 68       	rjmp	8000287a <Phyuserinput_brdcst_func+0x2>
80002870:	80 00       	ld.sh	r0,r0[0x0]
80002872:	c0 78       	rjmp	80002880 <Phyuserinput_brdcst_func+0x8>
80002874:	80 00       	ld.sh	r0,r0[0x0]
80002876:	55 e8       	stdsp	sp[0x178],r8

80002878 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002878:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
8000287c:	19 c7       	ld.ub	r7,r12[0x4]
8000287e:	19 d8       	ld.ub	r8,r12[0x5]
80002880:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002884:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
80002886:	48 dc       	lddpc	r12,800028b8 <Phyuserinput_brdcst_func+0x40>
80002888:	f0 1f 00 0d 	mcall	800028bc <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
8000288c:	36 08       	mov	r8,96
8000288e:	f0 07 19 00 	cp.h	r7,r8
80002892:	c1 11       	brne	800028b4 <Phyuserinput_brdcst_func+0x3c>
80002894:	48 b8       	lddpc	r8,800028c0 <Phyuserinput_brdcst_func+0x48>
80002896:	11 89       	ld.ub	r9,r8[0x0]
80002898:	30 18       	mov	r8,1
8000289a:	f0 09 18 00 	cp.b	r9,r8
8000289e:	c0 b1       	brne	800028b4 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, ACK_Received_Tone);//set tone to indicate the scan!!!
800028a0:	31 4b       	mov	r11,20
800028a2:	30 1c       	mov	r12,1
800028a4:	f0 1f 00 08 	mcall	800028c4 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(400*2 / portTICK_RATE_MS);//延迟400ms
800028a8:	e0 6c 03 20 	mov	r12,800
800028ac:	f0 1f 00 07 	mcall	800028c8 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		rfid_sendID_message();//send message		
800028b0:	f0 1f 00 07 	mcall	800028cc <Phyuserinput_brdcst_func+0x54>
800028b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800028b8:	80 00       	ld.sh	r0,r0[0x0]
800028ba:	c0 88       	rjmp	800028ca <Phyuserinput_brdcst_func+0x52>
800028bc:	80 00       	ld.sh	r0,r0[0x0]
800028be:	5b 0c       	cp.w	r12,-16
800028c0:	00 00       	add	r0,r0
800028c2:	0a 29       	rsub	r9,r5
800028c4:	80 00       	ld.sh	r0,r0[0x0]
800028c6:	33 24       	mov	r4,50
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	55 a0       	stdsp	sp[0x168],r0
800028cc:	80 00       	ld.sh	r0,r0[0x0]
800028ce:	3a 8c       	mov	r12,-88

800028d0 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800028d0:	d4 21       	pushm	r4-r7,lr
800028d2:	20 9d       	sub	sp,36
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800028d4:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
800028d8:	0d 88       	ld.ub	r8,r6[0x0]
800028da:	32 49       	mov	r9,36
800028dc:	f2 08 18 00 	cp.b	r8,r9
800028e0:	c2 91       	brne	80002932 <DataSession_brdcst_func+0x62>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800028e2:	4a dc       	lddpc	r12,80002994 <DataSession_brdcst_func+0xc4>
800028e4:	f0 1f 00 2d 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800028e8:	0d a5       	ld.ub	r5,r6[0x2]
800028ea:	0d b8       	ld.ub	r8,r6[0x3]
800028ec:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800028f0:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800028f2:	0d 98       	ld.ub	r8,r6[0x1]
800028f4:	1a d8       	st.w	--sp,r8
800028f6:	4a ac       	lddpc	r12,8000299c <DataSession_brdcst_func+0xcc>
800028f8:	f0 1f 00 28 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		log("\n\r paylaod_length: %d \n\r",data_length );
800028fc:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002900:	1a d8       	st.w	--sp,r8
80002902:	4a 8c       	lddpc	r12,800029a0 <DataSession_brdcst_func+0xd0>
80002904:	f0 1f 00 25 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		for(i=0; i<data_length; i++)
80002908:	2f ed       	sub	sp,-8
8000290a:	58 05       	cp.w	r5,0
8000290c:	c4 10       	breq	8000298e <DataSession_brdcst_func+0xbe>
8000290e:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002910:	4a 54       	lddpc	r4,800029a4 <DataSession_brdcst_func+0xd4>
80002912:	ec 07 00 08 	add	r8,r6,r7
80002916:	11 c8       	ld.ub	r8,r8[0x4]
80002918:	1a d8       	st.w	--sp,r8
8000291a:	1a d7       	st.w	--sp,r7
8000291c:	08 9c       	mov	r12,r4
8000291e:	f0 1f 00 1f 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002922:	2f f7       	sub	r7,-1
80002924:	5c 57       	castu.b	r7
80002926:	2f ed       	sub	sp,-8
80002928:	ee 05 19 00 	cp.h	r5,r7
8000292c:	fe 9b ff f3 	brhi	80002912 <DataSession_brdcst_func+0x42>
80002930:	c2 f8       	rjmp	8000298e <DataSession_brdcst_func+0xbe>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
80002932:	1a d8       	st.w	--sp,r8
80002934:	49 dc       	lddpc	r12,800029a8 <DataSession_brdcst_func+0xd8>
80002936:	f0 1f 00 19 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		if (ptr->State == DATA_SESSION_TX_Suc)
8000293a:	0d 88       	ld.ub	r8,r6[0x0]
8000293c:	2f fd       	sub	sp,-4
8000293e:	30 39       	mov	r9,3
80002940:	f2 08 18 00 	cp.b	r8,r9
80002944:	c0 51       	brne	8000294e <DataSession_brdcst_func+0x7e>
		{
			log("data transmit success\n");
80002946:	49 ac       	lddpc	r12,800029ac <DataSession_brdcst_func+0xdc>
80002948:	f0 1f 00 14 	mcall	80002998 <DataSession_brdcst_func+0xc8>
8000294c:	c2 18       	rjmp	8000298e <DataSession_brdcst_func+0xbe>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
8000294e:	30 49       	mov	r9,4
80002950:	f2 08 18 00 	cp.b	r8,r9
80002954:	c1 d1       	brne	8000298e <DataSession_brdcst_func+0xbe>
		{
			//Message_Protocol_t  *xgmessage = (Message_Protocol_t  *)ptr->DataPayload.DataPayload;
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
80002956:	32 0a       	mov	r10,32
80002958:	ec cb ff fc 	sub	r11,r6,-4
8000295c:	1a 9c       	mov	r12,sp
8000295e:	f0 1f 00 15 	mcall	800029b0 <DataSession_brdcst_func+0xe0>
			//xgmessage.data.XG_Time.Year, xgmessage.data.XG_Time.Month, xgmessage.data.XG_Time.Day,
			//xgmessage.data.XG_Time.Hour, xgmessage.data.XG_Time.Minute, xgmessage.data.XG_Time.Second);

			//return_value = xgflash_message_save(&xgmessage, sizeof(Message_Protocol_t), TRUE);

			Message_Protocol_t * myptr = get_message_store();	
80002962:	49 58       	lddpc	r8,800029b4 <DataSession_brdcst_func+0xe4>
80002964:	70 0c       	ld.w	r12,r8[0x0]
80002966:	f0 1f 00 15 	mcall	800029b8 <DataSession_brdcst_func+0xe8>
8000296a:	50 8c       	stdsp	sp[0x20],r12
			if(NULL != myptr)
8000296c:	c0 e0       	breq	80002988 <DataSession_brdcst_func+0xb8>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
8000296e:	32 0a       	mov	r10,32
80002970:	1a 9b       	mov	r11,sp
80002972:	f0 1f 00 10 	mcall	800029b0 <DataSession_brdcst_func+0xe0>
				xQueueSend(xg_resend_queue, &myptr, 0);
80002976:	49 28       	lddpc	r8,800029bc <DataSession_brdcst_func+0xec>
80002978:	70 0c       	ld.w	r12,r8[0x0]
8000297a:	30 09       	mov	r9,0
8000297c:	12 9a       	mov	r10,r9
8000297e:	fa cb ff e0 	sub	r11,sp,-32
80002982:	f0 1f 00 10 	mcall	800029c0 <DataSession_brdcst_func+0xf0>
80002986:	c0 48       	rjmp	8000298e <DataSession_brdcst_func+0xbe>
			}
			else
			{
				log("myptr: err\n\r" );
80002988:	48 fc       	lddpc	r12,800029c4 <DataSession_brdcst_func+0xf4>
8000298a:	f0 1f 00 04 	mcall	80002998 <DataSession_brdcst_func+0xc8>
				//
		//}
		
	}
	
}
8000298e:	2f 7d       	sub	sp,-36
80002990:	d8 22       	popm	r4-r7,pc
80002992:	00 00       	add	r0,r0
80002994:	80 00       	ld.sh	r0,r0[0x0]
80002996:	c0 a8       	rjmp	800029aa <DataSession_brdcst_func+0xda>
80002998:	80 00       	ld.sh	r0,r0[0x0]
8000299a:	5b 0c       	cp.w	r12,-16
8000299c:	80 00       	ld.sh	r0,r0[0x0]
8000299e:	c0 bc       	rcall	800029b4 <DataSession_brdcst_func+0xe4>
800029a0:	80 00       	ld.sh	r0,r0[0x0]
800029a2:	c0 d4       	brge	800029bc <DataSession_brdcst_func+0xec>
800029a4:	80 00       	ld.sh	r0,r0[0x0]
800029a6:	c0 f0       	breq	800029c4 <DataSession_brdcst_func+0xf4>
800029a8:	80 00       	ld.sh	r0,r0[0x0]
800029aa:	c1 08       	rjmp	800029ca <DeviceInitializationStatus_brdcst_func+0x2>
800029ac:	80 00       	ld.sh	r0,r0[0x0]
800029ae:	c1 14       	brge	800029d0 <DeviceInitializationStatus_brdcst_func+0x8>
800029b0:	80 00       	ld.sh	r0,r0[0x0]
800029b2:	62 26       	ld.w	r6,r1[0x8]
800029b4:	00 00       	add	r0,r0
800029b6:	0a 68       	and	r8,r5
800029b8:	80 00       	ld.sh	r0,r0[0x0]
800029ba:	31 dc       	mov	r12,29
800029bc:	00 00       	add	r0,r0
800029be:	0a 5c       	eor	r12,r5
800029c0:	80 00       	ld.sh	r0,r0[0x0]
800029c2:	4e d4       	lddpc	r4,80002b74 <send_flash_command+0x174>
800029c4:	80 00       	ld.sh	r0,r0[0x0]
800029c6:	c1 2c       	rcall	800029ea <DeviceInitializationStatus_brdcst_func+0x22>

800029c8 <DeviceInitializationStatus_brdcst_func>:
extern volatile xQueueHandle xg_resend_queue ;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800029c8:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800029ca:	19 e8       	ld.ub	r8,r12[0x6]
800029cc:	30 19       	mov	r9,1
800029ce:	f2 08 18 00 	cp.b	r8,r9
800029d2:	c0 61       	brne	800029de <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800029d4:	48 98       	lddpc	r8,800029f8 <DeviceInitializationStatus_brdcst_func+0x30>
800029d6:	70 09       	ld.w	r9,r8[0x0]
800029d8:	a1 a9       	sbr	r9,0x0
800029da:	91 09       	st.w	r8[0x0],r9
800029dc:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800029de:	30 29       	mov	r9,2
800029e0:	f2 08 18 00 	cp.b	r8,r9
800029e4:	c0 80       	breq	800029f4 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800029e6:	48 58       	lddpc	r8,800029f8 <DeviceInitializationStatus_brdcst_func+0x30>
800029e8:	70 09       	ld.w	r9,r8[0x0]
800029ea:	e0 19 ff fc 	andl	r9,0xfffc
800029ee:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800029f0:	f0 1f 00 03 	mcall	800029fc <DeviceInitializationStatus_brdcst_func+0x34>
800029f4:	d8 02       	popm	pc
800029f6:	00 00       	add	r0,r0
800029f8:	00 00       	add	r0,r0
800029fa:	0c e0       	st.h	--r6,r0
800029fc:	80 00       	ld.sh	r0,r0[0x0]
800029fe:	32 e4       	mov	r4,46

80002a00 <send_flash_command>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
U16 send_flash_command(U16 command, U32 address, U8 *data_ptr, U16 length)
{
80002a00:	eb cd 40 fc 	pushm	r2-r7,lr
80002a04:	20 1d       	sub	sp,4
80002a06:	18 97       	mov	r7,r12
80002a08:	14 95       	mov	r5,r10
80002a0a:	12 96       	mov	r6,r9
	U16 status = 1;
80002a0c:	30 18       	mov	r8,1
80002a0e:	ba 18       	st.h	sp[0x2],r8
	U16 i = 0;

    /* in order to call spi_write(U16* data), change 3-bytes address to 3-U16 address */
	U16 addr[3];
	addr[2] = (address & 0x00ff0000) >> 16;
80002a10:	e9 db c2 08 	bfextu	r4,r11,0x10,0x8
	addr[1] = (address & 0x0000ff00) >> 8;
80002a14:	e7 db c1 08 	bfextu	r3,r11,0x8,0x8
	addr[0] = (address & 0x000000ff);
80002a18:	e5 db c0 08 	bfextu	r2,r11,0x0,0x8

	U16 data_u16;

	spi_selectChip(spi, DF_SPI_PCS_1);
80002a1c:	30 1b       	mov	r11,1
80002a1e:	4e 58       	lddpc	r8,80002bb0 <send_flash_command+0x1b0>
80002a20:	70 0c       	ld.w	r12,r8[0x0]
80002a22:	f0 1f 00 65 	mcall	80002bb4 <send_flash_command+0x1b4>

    switch (command)
80002a26:	30 58       	mov	r8,5
80002a28:	f0 07 19 00 	cp.h	r7,r8
80002a2c:	c3 40       	breq	80002a94 <send_flash_command+0x94>
80002a2e:	e0 8b 00 18 	brhi	80002a5e <send_flash_command+0x5e>
80002a32:	30 28       	mov	r8,2
80002a34:	f0 07 19 00 	cp.h	r7,r8
80002a38:	c5 e0       	breq	80002af4 <send_flash_command+0xf4>
80002a3a:	e0 8b 00 08 	brhi	80002a4a <send_flash_command+0x4a>
80002a3e:	30 18       	mov	r8,1
80002a40:	f0 07 19 00 	cp.h	r7,r8
80002a44:	e0 81 00 ad 	brne	80002b9e <send_flash_command+0x19e>
80002a48:	c9 e8       	rjmp	80002b84 <send_flash_command+0x184>
80002a4a:	30 38       	mov	r8,3
80002a4c:	f0 07 19 00 	cp.h	r7,r8
80002a50:	c7 20       	breq	80002b34 <send_flash_command+0x134>
80002a52:	30 48       	mov	r8,4
80002a54:	f0 07 19 00 	cp.h	r7,r8
80002a58:	e0 81 00 a3 	brne	80002b9e <send_flash_command+0x19e>
80002a5c:	c2 c8       	rjmp	80002ab4 <send_flash_command+0xb4>
80002a5e:	35 28       	mov	r8,82
80002a60:	f0 07 19 00 	cp.h	r7,r8
80002a64:	c2 f0       	breq	80002ac2 <send_flash_command+0xc2>
80002a66:	e0 8b 00 0c 	brhi	80002a7e <send_flash_command+0x7e>
80002a6a:	30 68       	mov	r8,6
80002a6c:	f0 07 19 00 	cp.h	r7,r8
80002a70:	c2 20       	breq	80002ab4 <send_flash_command+0xb4>
80002a72:	32 08       	mov	r8,32
80002a74:	f0 07 19 00 	cp.h	r7,r8
80002a78:	e0 81 00 93 	brne	80002b9e <send_flash_command+0x19e>
80002a7c:	c2 38       	rjmp	80002ac2 <send_flash_command+0xc2>
80002a7e:	36 08       	mov	r8,96
80002a80:	f0 07 19 00 	cp.h	r7,r8
80002a84:	c3 20       	breq	80002ae8 <send_flash_command+0xe8>
80002a86:	e0 68 00 d8 	mov	r8,216
80002a8a:	f0 07 19 00 	cp.h	r7,r8
80002a8e:	e0 81 00 88 	brne	80002b9e <send_flash_command+0x19e>
80002a92:	c1 88       	rjmp	80002ac2 <send_flash_command+0xc2>
	{
		case READ_STATUS_REG:
			spi_write_byte(command);
80002a94:	4c 77       	lddpc	r7,80002bb0 <send_flash_command+0x1b0>
80002a96:	30 5b       	mov	r11,5
80002a98:	6e 0c       	ld.w	r12,r7[0x0]
80002a9a:	f0 1f 00 48 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_dummy();
80002a9e:	e0 6b 00 ff 	mov	r11,255
80002aa2:	6e 0c       	ld.w	r12,r7[0x0]
80002aa4:	f0 1f 00 45 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_read_byte(&status);
80002aa8:	fa cb ff fe 	sub	r11,sp,-2
80002aac:	6e 0c       	ld.w	r12,r7[0x0]
80002aae:	f0 1f 00 44 	mcall	80002bbc <send_flash_command+0x1bc>
			break;
80002ab2:	c7 68       	rjmp	80002b9e <send_flash_command+0x19e>
		case WRITE_ENABLE:
		case WRITE_DISABLE:
			spi_write_byte(command);
80002ab4:	0e 9b       	mov	r11,r7
80002ab6:	5c 7b       	castu.h	r11
80002ab8:	4b e8       	lddpc	r8,80002bb0 <send_flash_command+0x1b0>
80002aba:	70 0c       	ld.w	r12,r8[0x0]
80002abc:	f0 1f 00 3f 	mcall	80002bb8 <send_flash_command+0x1b8>
			break;
80002ac0:	c6 f8       	rjmp	80002b9e <send_flash_command+0x19e>
		case BLOCK_ERASE_4KB:
		case BLOCK_ERASE_32KB:
		case BLOCK_ERASE_64KB:
			spi_write_byte(command);
80002ac2:	4b c6       	lddpc	r6,80002bb0 <send_flash_command+0x1b0>
80002ac4:	0e 9b       	mov	r11,r7
80002ac6:	5c 7b       	castu.h	r11
80002ac8:	6c 0c       	ld.w	r12,r6[0x0]
80002aca:	f0 1f 00 3c 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002ace:	08 9b       	mov	r11,r4
80002ad0:	6c 0c       	ld.w	r12,r6[0x0]
80002ad2:	f0 1f 00 3a 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002ad6:	06 9b       	mov	r11,r3
80002ad8:	6c 0c       	ld.w	r12,r6[0x0]
80002ada:	f0 1f 00 38 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002ade:	04 9b       	mov	r11,r2
80002ae0:	6c 0c       	ld.w	r12,r6[0x0]
80002ae2:	f0 1f 00 36 	mcall	80002bb8 <send_flash_command+0x1b8>
			break;
80002ae6:	c5 c8       	rjmp	80002b9e <send_flash_command+0x19e>
		case CHIP_ERASE:
			spi_write_byte(command);
80002ae8:	36 0b       	mov	r11,96
80002aea:	4b 28       	lddpc	r8,80002bb0 <send_flash_command+0x1b0>
80002aec:	70 0c       	ld.w	r12,r8[0x0]
80002aee:	f0 1f 00 33 	mcall	80002bb8 <send_flash_command+0x1b8>
			break;
80002af2:	c5 68       	rjmp	80002b9e <send_flash_command+0x19e>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
80002af4:	4a f7       	lddpc	r7,80002bb0 <send_flash_command+0x1b0>
80002af6:	30 2b       	mov	r11,2
80002af8:	6e 0c       	ld.w	r12,r7[0x0]
80002afa:	f0 1f 00 30 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002afe:	08 9b       	mov	r11,r4
80002b00:	6e 0c       	ld.w	r12,r7[0x0]
80002b02:	f0 1f 00 2e 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002b06:	06 9b       	mov	r11,r3
80002b08:	6e 0c       	ld.w	r12,r7[0x0]
80002b0a:	f0 1f 00 2c 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002b0e:	04 9b       	mov	r11,r2
80002b10:	6e 0c       	ld.w	r12,r7[0x0]
80002b12:	f0 1f 00 2a 	mcall	80002bb8 <send_flash_command+0x1b8>
			for (i = 0; i < length; i++)
80002b16:	58 06       	cp.w	r6,0
80002b18:	c4 30       	breq	80002b9e <send_flash_command+0x19e>
80002b1a:	0a 97       	mov	r7,r5
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
				data_ptr++;
				spi_write_byte(data_u16);
80002b1c:	4a 54       	lddpc	r4,80002bb0 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
80002b1e:	0f 3b       	ld.ub	r11,r7++
80002b20:	ba 0b       	st.h	sp[0x0],r11
				data_ptr++;
				spi_write_byte(data_u16);
80002b22:	68 0c       	ld.w	r12,r4[0x0]
80002b24:	f0 1f 00 25 	mcall	80002bb8 <send_flash_command+0x1b8>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002b28:	0e 98       	mov	r8,r7
80002b2a:	0a 18       	sub	r8,r5
80002b2c:	ec 08 19 00 	cp.h	r8,r6
80002b30:	cf 73       	brcs	80002b1e <send_flash_command+0x11e>
80002b32:	c3 68       	rjmp	80002b9e <send_flash_command+0x19e>
				data_ptr++;
				spi_write_byte(data_u16);
			}
			break;
		case READ_ARRAY:
			spi_write_byte(command);
80002b34:	49 f7       	lddpc	r7,80002bb0 <send_flash_command+0x1b0>
80002b36:	30 3b       	mov	r11,3
80002b38:	6e 0c       	ld.w	r12,r7[0x0]
80002b3a:	f0 1f 00 20 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002b3e:	08 9b       	mov	r11,r4
80002b40:	6e 0c       	ld.w	r12,r7[0x0]
80002b42:	f0 1f 00 1e 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002b46:	06 9b       	mov	r11,r3
80002b48:	6e 0c       	ld.w	r12,r7[0x0]
80002b4a:	f0 1f 00 1c 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002b4e:	04 9b       	mov	r11,r2
80002b50:	6e 0c       	ld.w	r12,r7[0x0]
80002b52:	f0 1f 00 1a 	mcall	80002bb8 <send_flash_command+0x1b8>
			for (i = 0; i < length; i++)
80002b56:	58 06       	cp.w	r6,0
80002b58:	c2 30       	breq	80002b9e <send_flash_command+0x19e>
80002b5a:	0a 97       	mov	r7,r5
			{
				spi_write_dummy();
80002b5c:	49 54       	lddpc	r4,80002bb0 <send_flash_command+0x1b0>
80002b5e:	e0 63 00 ff 	mov	r3,255
				spi_read_byte(&data_u16);
80002b62:	1a 92       	mov	r2,sp
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				spi_write_dummy();
80002b64:	06 9b       	mov	r11,r3
80002b66:	68 0c       	ld.w	r12,r4[0x0]
80002b68:	f0 1f 00 14 	mcall	80002bb8 <send_flash_command+0x1b8>
				spi_read_byte(&data_u16);
80002b6c:	1a 9b       	mov	r11,sp
80002b6e:	68 0c       	ld.w	r12,r4[0x0]
80002b70:	f0 1f 00 13 	mcall	80002bbc <send_flash_command+0x1bc>
				*data_ptr = (U8)data_u16;
80002b74:	9a 08       	ld.sh	r8,sp[0x0]
80002b76:	0e c8       	st.b	r7++,r8
		case READ_ARRAY:
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002b78:	0e 98       	mov	r8,r7
80002b7a:	0a 18       	sub	r8,r5
80002b7c:	ec 08 19 00 	cp.h	r8,r6
80002b80:	cf 23       	brcs	80002b64 <send_flash_command+0x164>
80002b82:	c0 e8       	rjmp	80002b9e <send_flash_command+0x19e>
				*data_ptr = (U8)data_u16;
				data_ptr++;
			}
			break;
		case WRITE_STATUS_REG_BYTE_1:
			spi_write_byte(command);
80002b84:	48 b7       	lddpc	r7,80002bb0 <send_flash_command+0x1b0>
80002b86:	30 1b       	mov	r11,1
80002b88:	6e 0c       	ld.w	r12,r7[0x0]
80002b8a:	f0 1f 00 0c 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002b8e:	30 0b       	mov	r11,0
80002b90:	6e 0c       	ld.w	r12,r7[0x0]
80002b92:	f0 1f 00 0a 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002b96:	30 0b       	mov	r11,0
80002b98:	6e 0c       	ld.w	r12,r7[0x0]
80002b9a:	f0 1f 00 08 	mcall	80002bb8 <send_flash_command+0x1b8>
			break;
		default:
			break;
	}

	spi_unselectChip(spi, DF_SPI_PCS_1);
80002b9e:	30 1b       	mov	r11,1
80002ba0:	48 48       	lddpc	r8,80002bb0 <send_flash_command+0x1b0>
80002ba2:	70 0c       	ld.w	r12,r8[0x0]
80002ba4:	f0 1f 00 07 	mcall	80002bc0 <send_flash_command+0x1c0>

	return status;
}
80002ba8:	9a 1c       	ld.sh	r12,sp[0x2]
80002baa:	2f fd       	sub	sp,-4
80002bac:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002bb0:	00 00       	add	r0,r0
80002bb2:	1f 6c       	ld.uh	r12,--pc
80002bb4:	80 00       	ld.sh	r0,r0[0x0]
80002bb6:	45 d0       	lddsp	r0,sp[0x174]
80002bb8:	80 00       	ld.sh	r0,r0[0x0]
80002bba:	44 6a       	lddsp	r10,sp[0x118]
80002bbc:	80 00       	ld.sh	r0,r0[0x0]
80002bbe:	44 86       	lddsp	r6,sp[0x120]
80002bc0:	80 00       	ld.sh	r0,r0[0x0]
80002bc2:	45 90       	lddsp	r0,sp[0x164]

80002bc4 <data_flash_read_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_read_block(U32 address, U16 length, U8 *data_ptr)
{
80002bc4:	d4 01       	pushm	lr
	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > 0x1000)
80002bc6:	58 0a       	cp.w	r10,0
80002bc8:	5f 09       	sreq	r9
80002bca:	e0 68 ff fe 	mov	r8,65534
80002bce:	ea 18 00 7f 	orh	r8,0x7f
80002bd2:	10 3c       	cp.w	r12,r8
80002bd4:	5f b8       	srhi	r8
80002bd6:	f3 e8 10 08 	or	r8,r9,r8
80002bda:	c0 e1       	brne	80002bf6 <data_flash_read_block+0x32>
80002bdc:	e0 68 10 00 	mov	r8,4096
80002be0:	f0 0b 19 00 	cp.h	r11,r8
80002be4:	e0 8b 00 09 	brhi	80002bf6 <data_flash_read_block+0x32>
	{
		return DF_INVALID_PARAM;
	}

	send_flash_command(READ_ARRAY, address, data_ptr, length);
80002be8:	f3 db c0 10 	bfextu	r9,r11,0x0,0x10
80002bec:	18 9b       	mov	r11,r12
80002bee:	30 3c       	mov	r12,3
80002bf0:	f0 1f 00 02 	mcall	80002bf8 <data_flash_read_block+0x34>
80002bf4:	d8 0a       	popm	pc,r12=0

	return DF_OK;
80002bf6:	da 0a       	popm	pc,r12=1
80002bf8:	80 00       	ld.sh	r0,r0[0x0]
80002bfa:	2a 00       	sub	r0,-96

80002bfc <data_flash_write_page>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_page(U8 *data_ptr, U32 address, U16 length)
{
80002bfc:	eb cd 40 fc 	pushm	r2-r7,lr
80002c00:	18 94       	mov	r4,r12
80002c02:	16 93       	mov	r3,r11
80002c04:	14 92       	mov	r2,r10
	U16 status = 1;
	df_status_t return_code = DF_WRITE_FAIL;
	U16 count = 0; /* to monitor write time consumption */

	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > DF_PAGE_SIZE)
80002c06:	58 0c       	cp.w	r12,0
80002c08:	5f 09       	sreq	r9
80002c0a:	e0 68 ff fe 	mov	r8,65534
80002c0e:	ea 18 00 7f 	orh	r8,0x7f
80002c12:	10 3b       	cp.w	r11,r8
80002c14:	5f b8       	srhi	r8
80002c16:	f3 e8 10 08 	or	r8,r9,r8
80002c1a:	c3 a1       	brne	80002c8e <data_flash_write_page+0x92>
80002c1c:	e0 68 01 00 	mov	r8,256
80002c20:	f0 0a 19 00 	cp.h	r10,r8
80002c24:	e0 8b 00 35 	brhi	80002c8e <data_flash_write_page+0x92>
	{
		return DF_INVALID_PARAM;
	}

	while(status = send_flash_command(READ_STATUS_REG, 0, NULL, 0) == STATUS_BUSY);
80002c28:	30 06       	mov	r6,0
80002c2a:	30 55       	mov	r5,5
80002c2c:	30 17       	mov	r7,1
80002c2e:	0c 99       	mov	r9,r6
80002c30:	0c 9a       	mov	r10,r6
80002c32:	0c 9b       	mov	r11,r6
80002c34:	0a 9c       	mov	r12,r5
80002c36:	f0 1f 00 19 	mcall	80002c98 <data_flash_write_page+0x9c>
80002c3a:	ee 0c 19 00 	cp.h	r12,r7
80002c3e:	cf 80       	breq	80002c2e <data_flash_write_page+0x32>
	//{
		//return DF_DEVICE_BUSY;
	//}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002c40:	30 09       	mov	r9,0
80002c42:	12 9a       	mov	r10,r9
80002c44:	12 9b       	mov	r11,r9
80002c46:	30 6c       	mov	r12,6
80002c48:	f0 1f 00 14 	mcall	80002c98 <data_flash_write_page+0x9c>

	/* send PAGE_PROGRAM command */
	send_flash_command(PAGE_PROGRAM, address, data_ptr, length);
80002c4c:	f3 d2 c0 10 	bfextu	r9,r2,0x0,0x10
80002c50:	08 9a       	mov	r10,r4
80002c52:	06 9b       	mov	r11,r3
80002c54:	30 2c       	mov	r12,2
80002c56:	f0 1f 00 11 	mcall	80002c98 <data_flash_write_page+0x9c>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002c5a:	30 06       	mov	r6,0
80002c5c:	30 57       	mov	r7,5
80002c5e:	0c 99       	mov	r9,r6
80002c60:	0c 9a       	mov	r10,r6
80002c62:	0c 9b       	mov	r11,r6
80002c64:	0e 9c       	mov	r12,r7
80002c66:	f0 1f 00 0d 	mcall	80002c98 <data_flash_write_page+0x9c>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002c6a:	5c 7c       	castu.h	r12
80002c6c:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002c70:	cf 71       	brne	80002c5e <data_flash_write_page+0x62>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002c72:	18 97       	mov	r7,r12
80002c74:	e2 17 00 20 	andl	r7,0x20,COH
80002c78:	f9 b7 01 06 	movne	r7,6
80002c7c:	f9 b7 00 07 	moveq	r7,7
		/*  Erase Successful.  */
		return_code = DF_WRITE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002c80:	30 09       	mov	r9,0
80002c82:	12 9a       	mov	r10,r9
80002c84:	12 9b       	mov	r11,r9
80002c86:	30 4c       	mov	r12,4
80002c88:	f0 1f 00 04 	mcall	80002c98 <data_flash_write_page+0x9c>

	return return_code;
80002c8c:	c0 28       	rjmp	80002c90 <data_flash_write_page+0x94>
80002c8e:	30 17       	mov	r7,1
}
80002c90:	0e 9c       	mov	r12,r7
80002c92:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002c96:	00 00       	add	r0,r0
80002c98:	80 00       	ld.sh	r0,r0[0x0]
80002c9a:	2a 00       	sub	r0,-96

80002c9c <data_flash_write_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_block(U8 *data_ptr, U32 address, U16 data_length)
{
80002c9c:	d4 31       	pushm	r0-r7,lr
80002c9e:	18 94       	mov	r4,r12
80002ca0:	ed da b0 10 	bfexts	r6,r10,0x0,0x10
80002ca4:	16 97       	mov	r7,r11
80002ca6:	30 7c       	mov	r12,7
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002ca8:	30 03       	mov	r3,0
80002caa:	06 92       	mov	r2,r3
	{
		if ((write_addr & 0xFF) == 0)
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002cac:	e0 60 01 00 	mov	r0,256
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002cb0:	c4 98       	rjmp	80002d42 <data_flash_write_block+0xa6>
	{
		if ((write_addr & 0xFF) == 0)
80002cb2:	eb d7 c0 08 	bfextu	r5,r7,0x0,0x8
80002cb6:	c1 b1       	brne	80002cec <data_flash_write_block+0x50>
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002cb8:	e0 06 19 00 	cp.h	r6,r0
80002cbc:	e0 8b 00 0a 	brhi	80002cd0 <data_flash_write_block+0x34>
			{
				/* bytes remained less than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002cc0:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002cc4:	0e 9b       	mov	r11,r7
80002cc6:	08 9c       	mov	r12,r4
80002cc8:	f0 1f 00 24 	mcall	80002d58 <data_flash_write_block+0xbc>
80002ccc:	30 06       	mov	r6,0
80002cce:	c3 a8       	rjmp	80002d42 <data_flash_write_block+0xa6>
				bytes_remained = 0;	/* end while loop */
			}
			else /* (bytes_remained > DF_PAGE_SIZE) */
			{
				/* bytes remained more than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, DF_PAGE_SIZE);
80002cd0:	e0 6a 01 00 	mov	r10,256
80002cd4:	0e 9b       	mov	r11,r7
80002cd6:	08 9c       	mov	r12,r4
80002cd8:	f0 1f 00 20 	mcall	80002d58 <data_flash_write_block+0xbc>
				bytes_remained -= DF_PAGE_SIZE;
80002cdc:	ec c6 01 00 	sub	r6,r6,256
80002ce0:	5c 86       	casts.h	r6
				data_ptr += DF_PAGE_SIZE;
80002ce2:	e8 c4 ff 00 	sub	r4,r4,-256
				write_addr += DF_PAGE_SIZE;
80002ce6:	ee c7 ff 00 	sub	r7,r7,-256
80002cea:	c2 c8       	rjmp	80002d42 <data_flash_write_block+0xa6>
		}
		else
		{
			/*(write_addr & 0xFF != 0), address not 256 bytes aligned */

			if (BEYOND_PAGE_BOUNDARY(write_addr, bytes_remained) == TRUE)
80002cec:	f3 d6 c0 10 	bfextu	r9,r6,0x0,0x10
80002cf0:	0e 09       	add	r9,r7
80002cf2:	0e 98       	mov	r8,r7
80002cf4:	e4 18 00 7f 	andh	r8,0x7f
80002cf8:	e0 18 ff 00 	andl	r8,0xff00
80002cfc:	f0 c8 ff 00 	sub	r8,r8,-256
80002d00:	10 39       	cp.w	r9,r8
80002d02:	e0 88 00 19 	brls	80002d34 <data_flash_write_block+0x98>
			{
				/* bytes remained exceed current page, only write data within current page */
				return_code = data_flash_write_page(data_ptr, write_addr, BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr));
80002d06:	0e 91       	mov	r1,r7
80002d08:	5c 51       	castu.b	r1
80002d0a:	e0 6a 01 00 	mov	r10,256
80002d0e:	02 1a       	sub	r10,r1
80002d10:	5c 7a       	castu.h	r10
80002d12:	0e 9b       	mov	r11,r7
80002d14:	08 9c       	mov	r12,r4
80002d16:	f0 1f 00 11 	mcall	80002d58 <data_flash_write_block+0xbc>
				bytes_remained -= BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002d1a:	ec c6 01 00 	sub	r6,r6,256
80002d1e:	02 06       	add	r6,r1
80002d20:	5c 86       	casts.h	r6
				data_ptr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002d22:	e0 68 01 00 	mov	r8,256
80002d26:	f0 05 01 05 	sub	r5,r8,r5
80002d2a:	0a 04       	add	r4,r5
				write_addr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr); /* now became 256 bytes aligned */
80002d2c:	e0 17 ff 00 	andl	r7,0xff00
80002d30:	10 07       	add	r7,r8
80002d32:	c0 88       	rjmp	80002d42 <data_flash_write_block+0xa6>
			}
			else
			{
				/* bytes remained not exceed current page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002d34:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002d38:	0e 9b       	mov	r11,r7
80002d3a:	08 9c       	mov	r12,r4
80002d3c:	f0 1f 00 07 	mcall	80002d58 <data_flash_write_block+0xbc>
80002d40:	30 06       	mov	r6,0
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002d42:	e6 06 19 00 	cp.h	r6,r3
80002d46:	5f 19       	srne	r9
80002d48:	58 7c       	cp.w	r12,7
80002d4a:	5f 08       	sreq	r8
80002d4c:	f3 e8 00 08 	and	r8,r9,r8
80002d50:	e4 08 18 00 	cp.b	r8,r2
80002d54:	ca f1       	brne	80002cb2 <data_flash_write_block+0x16>
			}
		}
	}	/* end of while */

	return return_code;
}
80002d56:	d8 32       	popm	r0-r7,pc
80002d58:	80 00       	ld.sh	r0,r0[0x0]
80002d5a:	2b fc       	sub	r12,-65

80002d5c <data_flash_erase_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_erase_block(U32 address, df_block_size_t block_size)
{
80002d5c:	eb cd 40 f8 	pushm	r3-r7,lr
80002d60:	18 94       	mov	r4,r12
	U16 erase_commond;
	df_status_t return_code = DF_ERASE_FAIL;
	U16 count = 0; /* to monitor erase time consumption */

	/* check input parameter */
	if (address >= DF_MAX_ADDR)
80002d62:	e0 68 ff fe 	mov	r8,65534
80002d66:	ea 18 00 7f 	orh	r8,0x7f
80002d6a:	10 3c       	cp.w	r12,r8
80002d6c:	e0 88 00 04 	brls	80002d74 <data_flash_erase_block+0x18>
80002d70:	30 17       	mov	r7,1
80002d72:	c3 f8       	rjmp	80002df0 <data_flash_erase_block+0x94>
	{
		return DF_INVALID_PARAM;
	}

	/* determine erase command to be issued */
	if (block_size == DF_BLOCK_4KB)
80002d74:	58 1b       	cp.w	r11,1
80002d76:	c0 31       	brne	80002d7c <data_flash_erase_block+0x20>
80002d78:	32 03       	mov	r3,32
80002d7a:	c0 a8       	rjmp	80002d8e <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_4KB;
	else if (block_size == DF_BLOCK_32KB)
80002d7c:	58 2b       	cp.w	r11,2
80002d7e:	c0 31       	brne	80002d84 <data_flash_erase_block+0x28>
80002d80:	35 23       	mov	r3,82
80002d82:	c0 68       	rjmp	80002d8e <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_32KB;
	else if(block_size == DF_BLOCK_64KB)
80002d84:	e0 63 00 d8 	mov	r3,216
80002d88:	58 3b       	cp.w	r11,3
80002d8a:	f9 b3 01 60 	movne	r3,96
		erase_commond = BLOCK_ERASE_64KB;
	else/*(block_size == DF_BLOCK_ALL)*/
		erase_commond = CHIP_ERASE;

	while(status = send_flash_command(READ_STATUS_REG, 0, NULL, 0) == STATUS_BUSY);
80002d8e:	30 06       	mov	r6,0
80002d90:	30 55       	mov	r5,5
80002d92:	30 17       	mov	r7,1
80002d94:	0c 99       	mov	r9,r6
80002d96:	0c 9a       	mov	r10,r6
80002d98:	0c 9b       	mov	r11,r6
80002d9a:	0a 9c       	mov	r12,r5
80002d9c:	f0 1f 00 17 	mcall	80002df8 <data_flash_erase_block+0x9c>
80002da0:	ee 0c 19 00 	cp.h	r12,r7
80002da4:	cf 80       	breq	80002d94 <data_flash_erase_block+0x38>
	//{
		//return DF_DEVICE_BUSY;
	//}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002da6:	30 09       	mov	r9,0
80002da8:	12 9a       	mov	r10,r9
80002daa:	12 9b       	mov	r11,r9
80002dac:	30 6c       	mov	r12,6
80002dae:	f0 1f 00 13 	mcall	80002df8 <data_flash_erase_block+0x9c>

	/* send BLOCK_ERASE command */
	send_flash_command(erase_commond, address, NULL, 0);
80002db2:	30 09       	mov	r9,0
80002db4:	12 9a       	mov	r10,r9
80002db6:	08 9b       	mov	r11,r4
80002db8:	06 9c       	mov	r12,r3
80002dba:	f0 1f 00 10 	mcall	80002df8 <data_flash_erase_block+0x9c>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002dbe:	30 06       	mov	r6,0
80002dc0:	30 57       	mov	r7,5
80002dc2:	0c 99       	mov	r9,r6
80002dc4:	0c 9a       	mov	r10,r6
80002dc6:	0c 9b       	mov	r11,r6
80002dc8:	0e 9c       	mov	r12,r7
80002dca:	f0 1f 00 0c 	mcall	80002df8 <data_flash_erase_block+0x9c>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002dce:	5c 7c       	castu.h	r12
80002dd0:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002dd4:	cf 71       	brne	80002dc2 <data_flash_erase_block+0x66>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002dd6:	18 97       	mov	r7,r12
80002dd8:	e2 17 00 20 	andl	r7,0x20,COH
80002ddc:	f9 b7 01 04 	movne	r7,4
80002de0:	f9 b7 00 05 	moveq	r7,5
		/*  Erase Successful.  */
		return_code = DF_ERASE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002de4:	30 09       	mov	r9,0
80002de6:	12 9a       	mov	r10,r9
80002de8:	12 9b       	mov	r11,r9
80002dea:	30 4c       	mov	r12,4
80002dec:	f0 1f 00 03 	mcall	80002df8 <data_flash_erase_block+0x9c>

	return return_code;
}
80002df0:	0e 9c       	mov	r12,r7
80002df2:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002df6:	00 00       	add	r0,r0
80002df8:	80 00       	ld.sh	r0,r0[0x0]
80002dfa:	2a 00       	sub	r0,-96

80002dfc <data_flash_write>:
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
{
80002dfc:	d4 31       	pushm	r0-r7,lr
80002dfe:	20 3d       	sub	sp,12
80002e00:	50 0c       	stdsp	sp[0x0],r12
80002e02:	16 91       	mov	r1,r11
80002e04:	14 95       	mov	r5,r10
	U16 secremain;
	U16 i;
	df_status_t return_code = DF_OK;

	secpos	=	address/4096;//扇区地址 0~2047 for AT25DF641 
	secoff	=	address%4096;//在扇区内的偏移
80002e06:	f5 db c0 0c 	bfextu	r10,r11,0x0,0xc
80002e0a:	50 1a       	stdsp	sp[0x4],r10
	secremain	=	4096-secoff;//扇区剩余空间大小
80002e0c:	e0 69 10 00 	mov	r9,4096
80002e10:	f2 0a 01 07 	sub	r7,r9,r10
80002e14:	ea 07 19 00 	cp.h	r7,r5
80002e18:	ea 07 17 b0 	movhi	r7,r5
80002e1c:	5c 87       	casts.h	r7
80002e1e:	16 92       	mov	r2,r11
80002e20:	e0 12 f0 00 	andl	r2,0xf000
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002e24:	4a e4       	lddpc	r4,80002edc <data_flash_write+0xe0>
		for(i=0; i<secremain; i++)//校验数据
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002e26:	3f f6       	mov	r6,-1
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002e28:	e8 c8 ff ff 	sub	r8,r4,-1
80002e2c:	50 28       	stdsp	sp[0x8],r8
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
			address+=secremain;//写地址偏移
			data_length-=secremain;				//字节数递减
80002e2e:	12 90       	mov	r0,r9
	secoff	=	address%4096;//在扇区内的偏移
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002e30:	08 9a       	mov	r10,r4
80002e32:	e0 6b 10 00 	mov	r11,4096
80002e36:	04 9c       	mov	r12,r2
80002e38:	f0 1f 00 2a 	mcall	80002ee0 <data_flash_write+0xe4>
		for(i=0; i<secremain; i++)//校验数据
80002e3c:	58 07       	cp.w	r7,0
80002e3e:	c3 00       	breq	80002e9e <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002e40:	40 13       	lddsp	r3,sp[0x4]
80002e42:	5c 73       	castu.h	r3
80002e44:	e8 03 07 08 	ld.ub	r8,r4[r3]
80002e48:	ec 08 18 00 	cp.b	r8,r6
80002e4c:	c1 11       	brne	80002e6e <data_flash_write+0x72>
80002e4e:	e6 c9 ff ff 	sub	r9,r3,-1
80002e52:	08 09       	add	r9,r4
80002e54:	30 08       	mov	r8,0
80002e56:	c0 58       	rjmp	80002e60 <data_flash_write+0x64>
80002e58:	13 3a       	ld.ub	r10,r9++
80002e5a:	ec 0a 18 00 	cp.b	r10,r6
80002e5e:	c0 81       	brne	80002e6e <data_flash_write+0x72>
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
		for(i=0; i<secremain; i++)//校验数据
80002e60:	2f f8       	sub	r8,-1
80002e62:	5c 88       	casts.h	r8
80002e64:	f0 07 19 00 	cp.h	r7,r8
80002e68:	fe 9b ff f8 	brhi	80002e58 <data_flash_write+0x5c>
80002e6c:	c1 98       	rjmp	80002e9e <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
80002e6e:	30 1b       	mov	r11,1
80002e70:	04 9c       	mov	r12,r2
80002e72:	f0 1f 00 1d 	mcall	80002ee4 <data_flash_write+0xe8>
80002e76:	40 08       	lddsp	r8,sp[0x0]
80002e78:	08 03       	add	r3,r4
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002e7a:	40 2a       	lddsp	r10,sp[0x8]
80002e7c:	40 19       	lddsp	r9,sp[0x4]
80002e7e:	12 0a       	add	r10,r9
80002e80:	0e 99       	mov	r9,r7
80002e82:	20 19       	sub	r9,1
80002e84:	5c 79       	castu.h	r9
80002e86:	12 0a       	add	r10,r9
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
80002e88:	11 39       	ld.ub	r9,r8++
80002e8a:	06 c9       	st.b	r3++,r9
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
80002e8c:	14 33       	cp.w	r3,r10
80002e8e:	cf d1       	brne	80002e88 <data_flash_write+0x8c>
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
			}
			return_code = data_flash_write_block(FLASH_BUF, secpos*4096, 4096);//写入整个扇区
80002e90:	e0 6a 10 00 	mov	r10,4096
80002e94:	04 9b       	mov	r11,r2
80002e96:	08 9c       	mov	r12,r4
80002e98:	f0 1f 00 14 	mcall	80002ee8 <data_flash_write+0xec>
80002e9c:	c0 78       	rjmp	80002eaa <data_flash_write+0xae>

		}
		else 
		{
			return_code = data_flash_write_block(data_ptr, address, secremain);//写已经擦除了的,直接写入扇区剩余区间.
80002e9e:	0e 9a       	mov	r10,r7
80002ea0:	5c 7a       	castu.h	r10
80002ea2:	02 9b       	mov	r11,r1
80002ea4:	40 0c       	lddsp	r12,sp[0x0]
80002ea6:	f0 1f 00 11 	mcall	80002ee8 <data_flash_write+0xec>
80002eaa:	e4 c2 f0 00 	sub	r2,r2,-4096
		}
		if(data_length==secremain)break;//写入结束了
80002eae:	0e 98       	mov	r8,r7
80002eb0:	ee 05 19 00 	cp.h	r5,r7
80002eb4:	c1 20       	breq	80002ed8 <data_flash_write+0xdc>
		else//写入未结束
		{
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
80002eb6:	5c 78       	castu.h	r8
80002eb8:	40 0a       	lddsp	r10,sp[0x0]
80002eba:	10 0a       	add	r10,r8
80002ebc:	50 0a       	stdsp	sp[0x0],r10
			address+=secremain;//写地址偏移
80002ebe:	10 01       	add	r1,r8
			data_length-=secremain;				//字节数递减
80002ec0:	0e 15       	sub	r5,r7
80002ec2:	5c 85       	casts.h	r5
80002ec4:	e0 05 19 00 	cp.h	r5,r0
80002ec8:	ea 07 17 80 	movls	r7,r5
80002ecc:	e0 07 17 b0 	movhi	r7,r0
80002ed0:	5c 87       	casts.h	r7
80002ed2:	30 09       	mov	r9,0
80002ed4:	50 19       	stdsp	sp[0x4],r9
80002ed6:	ca db       	rjmp	80002e30 <data_flash_write+0x34>
		}
	}
	
	return return_code;
	
}
80002ed8:	2f dd       	sub	sp,-12
80002eda:	d8 32       	popm	r0-r7,pc
80002edc:	00 00       	add	r0,r0
80002ede:	0f 6c       	ld.uh	r12,--r7
80002ee0:	80 00       	ld.sh	r0,r0[0x0]
80002ee2:	2b c4       	sub	r4,-68
80002ee4:	80 00       	ld.sh	r0,r0[0x0]
80002ee6:	2d 5c       	sub	r12,-43
80002ee8:	80 00       	ld.sh	r0,r0[0x0]
80002eea:	2c 9c       	sub	r12,-55

80002eec <data_flash_init>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void data_flash_init(void)
{
80002eec:	eb cd 40 c0 	pushm	r6-r7,lr
80002ef0:	20 5d       	sub	sp,20
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 1,//0,0 针对不同的存储芯片，注意模式
		.modfdis      = 1
	};
80002ef2:	4c 28       	lddpc	r8,80002ff8 <data_flash_init+0x10c>
80002ef4:	fa c6 ff fc 	sub	r6,sp,-4
80002ef8:	f0 ea 00 00 	ld.d	r10,r8[0]
80002efc:	ec eb 00 00 	st.d	r6[0],r10
80002f00:	f0 e8 00 08 	ld.d	r8,r8[8]
80002f04:	ec e9 00 08 	st.d	r6[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(DF_SPI_GPIO_MAP, sizeof(DF_SPI_GPIO_MAP) / sizeof(DF_SPI_GPIO_MAP[0]));
80002f08:	30 4b       	mov	r11,4
80002f0a:	4b dc       	lddpc	r12,80002ffc <data_flash_init+0x110>
80002f0c:	f0 1f 00 3d 	mcall	80003000 <data_flash_init+0x114>

	spi = &AVR32_SPI;
80002f10:	4b d7       	lddpc	r7,80003004 <data_flash_init+0x118>
80002f12:	fe 7c 24 00 	mov	r12,-56320
80002f16:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80002f18:	0c 9b       	mov	r11,r6
80002f1a:	f0 1f 00 3c 	mcall	80003008 <data_flash_init+0x11c>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80002f1e:	30 09       	mov	r9,0
80002f20:	12 9a       	mov	r10,r9
80002f22:	12 9b       	mov	r11,r9
80002f24:	6e 0c       	ld.w	r12,r7[0x0]
80002f26:	f0 1f 00 3a 	mcall	8000300c <data_flash_init+0x120>

	// Enable SPI.
	spi_enable(spi);
80002f2a:	6e 0c       	ld.w	r12,r7[0x0]
80002f2c:	f0 1f 00 39 	mcall	80003010 <data_flash_init+0x124>

	// Initialize data flash with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80002f30:	e0 6a 36 00 	mov	r10,13824
80002f34:	ea 1a 01 6e 	orh	r10,0x16e
80002f38:	0c 9b       	mov	r11,r6
80002f3a:	6e 0c       	ld.w	r12,r7[0x0]
80002f3c:	f0 1f 00 36 	mcall	80003014 <data_flash_init+0x128>
80002f40:	c0 50       	breq	80002f4a <data_flash_init+0x5e>
	{
		data_flash_failure = FATAL_ERROR_DATA_FLASH_SPI_INIT;
80002f42:	30 29       	mov	r9,2
80002f44:	4b 58       	lddpc	r8,80003018 <data_flash_init+0x12c>
80002f46:	b0 89       	st.b	r8[0x0],r9
		return;
80002f48:	c5 58       	rjmp	80002ff2 <data_flash_init+0x106>
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
static Bool data_flash_check_device_id(void)
{
	U16 manufacturer_device_id[2] = {0x5A5A, 0x5A5A};
80002f4a:	1a 96       	mov	r6,sp
80002f4c:	30 4a       	mov	r10,4
80002f4e:	4b 4b       	lddpc	r11,8000301c <data_flash_init+0x130>
80002f50:	1a 9c       	mov	r12,sp
80002f52:	f0 1f 00 34 	mcall	80003020 <data_flash_init+0x134>

	/* DF memory check. */
	/* Select the DF memory to check. */
	spi_selectChip(spi, DF_SPI_PCS_1);
80002f56:	4a c7       	lddpc	r7,80003004 <data_flash_init+0x118>
80002f58:	30 1b       	mov	r11,1
80002f5a:	6e 0c       	ld.w	r12,r7[0x0]
80002f5c:	f0 1f 00 32 	mcall	80003024 <data_flash_init+0x138>

	/* Send the Manufacturer/Device ID Read command. */
	spi_write(spi, READ_M_D_ID);	
80002f60:	e0 6b 00 90 	mov	r11,144
80002f64:	6e 0c       	ld.w	r12,r7[0x0]
80002f66:	f0 1f 00 31 	mcall	80003028 <data_flash_init+0x13c>
	spi_write_zero();
80002f6a:	30 0b       	mov	r11,0
80002f6c:	6e 0c       	ld.w	r12,r7[0x0]
80002f6e:	f0 1f 00 2f 	mcall	80003028 <data_flash_init+0x13c>
	spi_write_zero();
80002f72:	30 0b       	mov	r11,0
80002f74:	6e 0c       	ld.w	r12,r7[0x0]
80002f76:	f0 1f 00 2d 	mcall	80003028 <data_flash_init+0x13c>
	spi_write_zero();
80002f7a:	30 0b       	mov	r11,0
80002f7c:	6e 0c       	ld.w	r12,r7[0x0]
80002f7e:	f0 1f 00 2b 	mcall	80003028 <data_flash_init+0x13c>

	/* Send 2 dummy byte to read the status register. */
	
	spi_write_dummy();
80002f82:	e0 6b 00 ff 	mov	r11,255
80002f86:	6e 0c       	ld.w	r12,r7[0x0]
80002f88:	f0 1f 00 28 	mcall	80003028 <data_flash_init+0x13c>
	spi_read(spi, &manufacturer_device_id[0]);
80002f8c:	1a 9b       	mov	r11,sp
80002f8e:	6e 0c       	ld.w	r12,r7[0x0]
80002f90:	f0 1f 00 27 	mcall	8000302c <data_flash_init+0x140>
	
	spi_write_dummy();
80002f94:	e0 6b 00 ff 	mov	r11,255
80002f98:	6e 0c       	ld.w	r12,r7[0x0]
80002f9a:	f0 1f 00 24 	mcall	80003028 <data_flash_init+0x13c>
	spi_read(spi, &manufacturer_device_id[1]);
80002f9e:	fa cb ff fe 	sub	r11,sp,-2
80002fa2:	6e 0c       	ld.w	r12,r7[0x0]
80002fa4:	f0 1f 00 22 	mcall	8000302c <data_flash_init+0x140>

	/* Unselect the checked DF memory. */
	spi_unselectChip(spi, DF_SPI_PCS_1);
80002fa8:	30 1b       	mov	r11,1
80002faa:	6e 0c       	ld.w	r12,r7[0x0]
80002fac:	f0 1f 00 21 	mcall	80003030 <data_flash_init+0x144>

	/* Unexpected device ID. */
    if ((manufacturer_device_id[0] != 0xEF) || (manufacturer_device_id[1] != 0x16))
80002fb0:	e0 68 00 ef 	mov	r8,239
80002fb4:	9a 09       	ld.sh	r9,sp[0x0]
80002fb6:	f0 09 19 00 	cp.h	r9,r8
80002fba:	c0 61       	brne	80002fc6 <data_flash_init+0xda>
80002fbc:	31 68       	mov	r8,22
80002fbe:	9a 19       	ld.sh	r9,sp[0x2]
80002fc0:	f0 09 19 00 	cp.h	r9,r8
80002fc4:	c0 50       	breq	80002fce <data_flash_init+0xe2>
		return;
	}
	 
	if (data_flash_check_device_id() != TRUE)//check W25Q64 ID
	{
		data_flash_failure = FATAL_ERROR_DATA_FLASH_READ_ID;
80002fc6:	30 39       	mov	r9,3
80002fc8:	49 48       	lddpc	r8,80003018 <data_flash_init+0x12c>
80002fca:	b0 89       	st.b	r8[0x0],r9
		return;
80002fcc:	c1 38       	rjmp	80002ff2 <data_flash_init+0x106>
	}

	// Set STATUS reg to unprotect all sect
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002fce:	30 09       	mov	r9,0
80002fd0:	12 9a       	mov	r10,r9
80002fd2:	12 9b       	mov	r11,r9
80002fd4:	30 6c       	mov	r12,6
80002fd6:	f0 1f 00 18 	mcall	80003034 <data_flash_init+0x148>
	send_flash_command(WRITE_STATUS_REG_BYTE_1, 0, NULL, 0);
80002fda:	30 09       	mov	r9,0
80002fdc:	12 9a       	mov	r10,r9
80002fde:	12 9b       	mov	r11,r9
80002fe0:	30 1c       	mov	r12,1
80002fe2:	f0 1f 00 15 	mcall	80003034 <data_flash_init+0x148>
	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002fe6:	30 09       	mov	r9,0
80002fe8:	12 9a       	mov	r10,r9
80002fea:	12 9b       	mov	r11,r9
80002fec:	30 5c       	mov	r12,5
80002fee:	f0 1f 00 12 	mcall	80003034 <data_flash_init+0x148>
	
	return;
}
80002ff2:	2f bd       	sub	sp,-20
80002ff4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002ff8:	80 00       	ld.sh	r0,r0[0x0]
80002ffa:	c1 60       	breq	80003026 <data_flash_init+0x13a>
80002ffc:	80 00       	ld.sh	r0,r0[0x0]
80002ffe:	c1 40       	breq	80003026 <data_flash_init+0x13a>
80003000:	80 00       	ld.sh	r0,r0[0x0]
80003002:	3f a8       	mov	r8,-6
80003004:	00 00       	add	r0,r0
80003006:	1f 6c       	ld.uh	r12,--pc
80003008:	80 00       	ld.sh	r0,r0[0x0]
8000300a:	44 00       	lddsp	r0,sp[0x100]
8000300c:	80 00       	ld.sh	r0,r0[0x0]
8000300e:	44 38       	lddsp	r8,sp[0x10c]
80003010:	80 00       	ld.sh	r0,r0[0x0]
80003012:	44 64       	lddsp	r4,sp[0x118]
80003014:	80 00       	ld.sh	r0,r0[0x0]
80003016:	44 a8       	lddsp	r8,sp[0x128]
80003018:	00 00       	add	r0,r0
8000301a:	0a 3c       	cp.w	r12,r5
8000301c:	80 00       	ld.sh	r0,r0[0x0]
8000301e:	c1 3a       	rjmp	80002c44 <data_flash_write_page+0x48>
80003020:	80 00       	ld.sh	r0,r0[0x0]
80003022:	62 26       	ld.w	r6,r1[0x8]
80003024:	80 00       	ld.sh	r0,r0[0x0]
80003026:	45 d0       	lddsp	r0,sp[0x174]
80003028:	80 00       	ld.sh	r0,r0[0x0]
8000302a:	44 6a       	lddsp	r10,sp[0x118]
8000302c:	80 00       	ld.sh	r0,r0[0x0]
8000302e:	44 86       	lddsp	r6,sp[0x120]
80003030:	80 00       	ld.sh	r0,r0[0x0]
80003032:	45 90       	lddsp	r0,sp[0x164]
80003034:	80 00       	ld.sh	r0,r0[0x0]
80003036:	2a 00       	sub	r0,-96

80003038 <xg_rtc_init>:
}



void xg_rtc_init(void)
{
80003038:	d4 01       	pushm	lr
	
	// Disable all interrupts. */
	Disable_global_interrupt();
8000303a:	d3 03       	ssrf	0x10
	  
	// Register the RTC interrupt handler to the interrupt controller.
	INTC_register_interrupt(&rtc_irq, AVR32_RTC_IRQ, AVR32_INTC_INT0);
8000303c:	30 0a       	mov	r10,0
8000303e:	32 8b       	mov	r11,40
80003040:	49 5c       	lddpc	r12,80003094 <xg_rtc_init+0x5c>
80003042:	f0 1f 00 16 	mcall	80003098 <xg_rtc_init+0x60>

	// Initialize the RTC
	//if (!rtc_init(&AVR32_RTC, RTC_OSC_RC, RTC_PSEL_RC_1_76HZ))
	if (!rtc_init(&AVR32_RTC, RTC_OSC_32KHZ, RTC_PSEL_32KHZ_1HZ))
80003046:	30 ea       	mov	r10,14
80003048:	30 1b       	mov	r11,1
8000304a:	fe 7c 0d 00 	mov	r12,-62208
8000304e:	f0 1f 00 14 	mcall	8000309c <xg_rtc_init+0x64>
80003052:	c0 41       	brne	8000305a <xg_rtc_init+0x22>
	{
		log("Error initializing the RTC\r\n");
80003054:	49 3c       	lddpc	r12,800030a0 <xg_rtc_init+0x68>
80003056:	f0 1f 00 14 	mcall	800030a4 <xg_rtc_init+0x6c>
	}
	// Set top value to 0 to generate an interrupt every seconds */
	rtc_set_top_value(&AVR32_RTC, 0);
8000305a:	30 0b       	mov	r11,0
8000305c:	fe 7c 0d 00 	mov	r12,-62208
80003060:	f0 1f 00 12 	mcall	800030a8 <xg_rtc_init+0x70>
	// Enable the interrupts
	rtc_enable_interrupt(&AVR32_RTC);
80003064:	fe 7c 0d 00 	mov	r12,-62208
80003068:	f0 1f 00 11 	mcall	800030ac <xg_rtc_init+0x74>
	// Enable the RTC
	rtc_enable(&AVR32_RTC);
8000306c:	fe 7c 0d 00 	mov	r12,-62208
80003070:	f0 1f 00 10 	mcall	800030b0 <xg_rtc_init+0x78>

	Current_time.Year		= 16;
80003074:	49 08       	lddpc	r8,800030b4 <xg_rtc_init+0x7c>
80003076:	31 09       	mov	r9,16
80003078:	b0 89       	st.b	r8[0x0],r9
	Current_time.Month		= 2;
8000307a:	30 29       	mov	r9,2
8000307c:	b0 99       	st.b	r8[0x1],r9
	Current_time.Day		= 29;
8000307e:	31 d9       	mov	r9,29
80003080:	b0 a9       	st.b	r8[0x2],r9
	Current_time.Hour		= 23;
80003082:	31 79       	mov	r9,23
80003084:	b0 b9       	st.b	r8[0x3],r9
	Current_time.Minute		= 59;
80003086:	33 b9       	mov	r9,59
80003088:	b0 c9       	st.b	r8[0x4],r9
	Current_time.Second		= 40;
8000308a:	32 89       	mov	r9,40
8000308c:	b0 d9       	st.b	r8[0x5],r9
	
	// Enable global interrupts
	Enable_global_interrupt();
8000308e:	d5 03       	csrf	0x10
	  
	//RTC_Test();	

}
80003090:	d8 02       	popm	pc
80003092:	00 00       	add	r0,r0
80003094:	80 00       	ld.sh	r0,r0[0x0]
80003096:	30 b8       	mov	r8,11
80003098:	80 00       	ld.sh	r0,r0[0x0]
8000309a:	40 14       	lddsp	r4,sp[0x4]
8000309c:	80 00       	ld.sh	r0,r0[0x0]
8000309e:	43 60       	lddsp	r0,sp[0xd8]
800030a0:	80 00       	ld.sh	r0,r0[0x0]
800030a2:	c1 70       	breq	800030d0 <rtc_irq+0x18>
800030a4:	80 00       	ld.sh	r0,r0[0x0]
800030a6:	5b 0c       	cp.w	r12,-16
800030a8:	80 00       	ld.sh	r0,r0[0x0]
800030aa:	43 1c       	lddsp	r12,sp[0xc4]
800030ac:	80 00       	ld.sh	r0,r0[0x0]
800030ae:	43 14       	lddsp	r4,sp[0xc4]
800030b0:	80 00       	ld.sh	r0,r0[0x0]
800030b2:	42 f0       	lddsp	r0,sp[0xbc]
800030b4:	00 00       	add	r0,r0
800030b6:	0c e4       	st.h	--r6,r4

800030b8 <rtc_irq>:
/* RTC Interrupt  */
#pragma handler = AVR32_RTC_IRQ_GROUP, 1
__interrupt
#endif
void rtc_irq(void)
{
800030b8:	d4 01       	pushm	lr
	U8 T,K;
	U32 T16,K16;
	// Increment the minutes counter
	//sec++;
	
	Current_time.Second++;
800030ba:	4b 98       	lddpc	r8,8000319c <rtc_irq+0xe4>
800030bc:	11 d9       	ld.ub	r9,r8[0x5]
800030be:	2f f9       	sub	r9,-1
800030c0:	b0 d9       	st.b	r8[0x5],r9
	if(Current_time.Second>=60)
800030c2:	11 d9       	ld.ub	r9,r8[0x5]
800030c4:	33 b8       	mov	r8,59
800030c6:	f0 09 18 00 	cp.b	r9,r8
800030ca:	e0 88 00 5f 	brls	80003188 <rtc_irq+0xd0>
	{
		Current_time.Second =0;
800030ce:	4b 48       	lddpc	r8,8000319c <rtc_irq+0xe4>
800030d0:	30 09       	mov	r9,0
800030d2:	b0 d9       	st.b	r8[0x5],r9
		Current_time.Minute++;
800030d4:	11 c9       	ld.ub	r9,r8[0x4]
800030d6:	2f f9       	sub	r9,-1
800030d8:	b0 c9       	st.b	r8[0x4],r9
		if(Current_time.Minute>=60)
800030da:	11 c9       	ld.ub	r9,r8[0x4]
800030dc:	33 b8       	mov	r8,59
800030de:	f0 09 18 00 	cp.b	r9,r8
800030e2:	e0 88 00 53 	brls	80003188 <rtc_irq+0xd0>
		{
			Current_time.Minute=0;
800030e6:	4a e8       	lddpc	r8,8000319c <rtc_irq+0xe4>
800030e8:	30 09       	mov	r9,0
800030ea:	b0 c9       	st.b	r8[0x4],r9
			Current_time.Hour++;
800030ec:	11 b9       	ld.ub	r9,r8[0x3]
800030ee:	2f f9       	sub	r9,-1
800030f0:	b0 b9       	st.b	r8[0x3],r9
			if (Current_time.Hour>=24)
800030f2:	11 b9       	ld.ub	r9,r8[0x3]
800030f4:	31 78       	mov	r8,23
800030f6:	f0 09 18 00 	cp.b	r9,r8
800030fa:	e0 88 00 47 	brls	80003188 <rtc_irq+0xd0>
			{
				Current_time.Hour=0;
800030fe:	4a 88       	lddpc	r8,8000319c <rtc_irq+0xe4>
80003100:	30 09       	mov	r9,0
80003102:	b0 b9       	st.b	r8[0x3],r9
				K16=(Current_time.Year&0x03)?365:366;				//判断当年是否为闰年,并获取当年的总天数（此算法时间起点为2000年）
80003104:	11 88       	ld.ub	r8,r8[0x0]
80003106:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000310a:	e0 69 01 6e 	mov	r9,366
8000310e:	e0 6a 01 6d 	mov	r10,365
80003112:	f4 08 17 10 	movne	r8,r10
80003116:	f2 08 17 00 	moveq	r8,r9
				K16-=337;											//计算当年二月份天数
				//统计当月天数				
				K=(Current_time.Month==2)?K16:(((Current_time.Month+(Current_time.Month>>3))&0x01)+30);			
8000311a:	4a 19       	lddpc	r9,8000319c <rtc_irq+0xe4>
8000311c:	13 9a       	ld.ub	r10,r9[0x1]
8000311e:	30 29       	mov	r9,2
80003120:	f2 0a 18 00 	cp.b	r10,r9
80003124:	c0 b0       	breq	8000313a <rtc_irq+0x82>
80003126:	49 e8       	lddpc	r8,8000319c <rtc_irq+0xe4>
80003128:	11 99       	ld.ub	r9,r8[0x1]
8000312a:	11 9a       	ld.ub	r10,r8[0x1]
8000312c:	a3 9a       	lsr	r10,0x3
8000312e:	12 0a       	add	r10,r9
80003130:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80003134:	2e 2a       	sub	r10,-30
80003136:	5c 5a       	castu.b	r10
80003138:	c0 58       	rjmp	80003142 <rtc_irq+0x8a>
8000313a:	f0 c8 01 51 	sub	r8,r8,337
8000313e:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
				Current_time.Day++;
80003142:	49 78       	lddpc	r8,8000319c <rtc_irq+0xe4>
80003144:	11 a9       	ld.ub	r9,r8[0x2]
80003146:	2f f9       	sub	r9,-1
80003148:	b0 a9       	st.b	r8[0x2],r9
				if(Current_time.Day>K)
8000314a:	11 a8       	ld.ub	r8,r8[0x2]
8000314c:	f0 0a 18 00 	cp.b	r10,r8
80003150:	c1 c2       	brcc	80003188 <rtc_irq+0xd0>
				{	
					Current_time.Day = 1;//重置到下月1号
80003152:	49 38       	lddpc	r8,8000319c <rtc_irq+0xe4>
80003154:	30 19       	mov	r9,1
80003156:	b0 a9       	st.b	r8[0x2],r9
					Current_time.Month++;
80003158:	11 99       	ld.ub	r9,r8[0x1]
8000315a:	2f f9       	sub	r9,-1
8000315c:	b0 99       	st.b	r8[0x1],r9
					if(Current_time.Month>12)
8000315e:	11 99       	ld.ub	r9,r8[0x1]
80003160:	30 c8       	mov	r8,12
80003162:	f0 09 18 00 	cp.b	r9,r8
80003166:	e0 88 00 11 	brls	80003188 <rtc_irq+0xd0>
					{
						Current_time.Month = 1;//重置到下一年的第一个月
8000316a:	48 d8       	lddpc	r8,8000319c <rtc_irq+0xe4>
8000316c:	30 19       	mov	r9,1
8000316e:	b0 99       	st.b	r8[0x1],r9
						Current_time.Year++;
80003170:	11 89       	ld.ub	r9,r8[0x0]
80003172:	2f f9       	sub	r9,-1
80003174:	b0 89       	st.b	r8[0x0],r9
						if (Current_time.Year>150)Current_time.Year=0;//重置年份											
80003176:	11 89       	ld.ub	r9,r8[0x0]
80003178:	39 68       	mov	r8,-106
8000317a:	f0 09 18 00 	cp.b	r9,r8
8000317e:	e0 88 00 05 	brls	80003188 <rtc_irq+0xd0>
80003182:	30 09       	mov	r9,0
80003184:	48 68       	lddpc	r8,8000319c <rtc_irq+0xe4>
80003186:	b0 89       	st.b	r8[0x0],r9
	}
	
	//Time_scale++;

	// clear the interrupt flag
	rtc_clear_interrupt(&AVR32_RTC);
80003188:	fe 7c 0d 00 	mov	r12,-62208
8000318c:	f0 1f 00 05 	mcall	800031a0 <rtc_irq+0xe8>

	// specify that an interrupt has been raised
	print_sec = 1;
80003190:	30 19       	mov	r9,1
80003192:	48 58       	lddpc	r8,800031a4 <rtc_irq+0xec>
80003194:	91 09       	st.w	r8[0x0],r9
}
80003196:	d4 02       	popm	lr
80003198:	d6 03       	rete
8000319a:	00 00       	add	r0,r0
8000319c:	00 00       	add	r0,r0
8000319e:	0c e4       	st.h	--r6,r4
800031a0:	80 00       	ld.sh	r0,r0[0x0]
800031a2:	43 40       	lddsp	r0,sp[0xd0]
800031a4:	00 00       	add	r0,r0
800031a6:	04 f4       	st.b	--r2,r4

800031a8 <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
800031a8:	48 38       	lddpc	r8,800031b4 <payload_init+0xc>
800031aa:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
800031ac:	48 38       	lddpc	r8,800031b8 <payload_init+0x10>
800031ae:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
800031b0:	5e fc       	retal	r12
800031b2:	00 00       	add	r0,r0
800031b4:	00 00       	add	r0,r0
800031b6:	0a 40       	or	r0,r5
800031b8:	00 00       	add	r0,r0
800031ba:	0a 44       	or	r4,r5

800031bc <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
800031bc:	eb cd 40 80 	pushm	r7,lr
800031c0:	20 1d       	sub	sp,4
800031c2:	fa c7 ff fc 	sub	r7,sp,-4
800031c6:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
800031c8:	30 09       	mov	r9,0
800031ca:	12 9a       	mov	r10,r9
800031cc:	1a 9b       	mov	r11,sp
800031ce:	f0 1f 00 03 	mcall	800031d8 <set_idle_store+0x1c>
}
800031d2:	2f fd       	sub	sp,-4
800031d4:	e3 cd 80 80 	ldm	sp++,r7,pc
800031d8:	80 00       	ld.sh	r0,r0[0x0]
800031da:	4e d4       	lddpc	r4,8000338c <xnl_tx+0x8>

800031dc <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
800031dc:	d4 01       	pushm	lr
800031de:	20 1d       	sub	sp,4
	void * ptr = NULL;
800031e0:	30 0a       	mov	r10,0
800031e2:	fa cb ff fc 	sub	r11,sp,-4
800031e6:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
800031e8:	14 99       	mov	r9,r10
800031ea:	1a 9b       	mov	r11,sp
800031ec:	f0 1f 00 05 	mcall	80003200 <get_idle_store+0x24>
800031f0:	58 1c       	cp.w	r12,1
800031f2:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
800031f6:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
800031fa:	2f fd       	sub	sp,-4
800031fc:	d8 02       	popm	pc
800031fe:	00 00       	add	r0,r0
80003200:	80 00       	ld.sh	r0,r0[0x0]
80003202:	4d 18       	lddpc	r8,80003344 <xcmp_IdleTestTone+0x20>

80003204 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003204:	48 28       	lddpc	r8,8000320c <xcmp_register_app_list+0x8>
80003206:	91 0c       	st.w	r8[0x0],r12
}
80003208:	5e fc       	retal	r12
8000320a:	00 00       	add	r0,r0
8000320c:	00 00       	add	r0,r0
8000320e:	1f 70       	ld.ub	r0,--pc

80003210 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003210:	eb cd 40 80 	pushm	r7,lr
80003214:	fa cd 01 00 	sub	sp,sp,256
80003218:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
8000321a:	16 98       	mov	r8,r11
8000321c:	2f 08       	sub	r8,-16
8000321e:	af a8       	sbr	r8,0xe
80003220:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003222:	3f f8       	mov	r8,-1
80003224:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003226:	30 b9       	mov	r9,11
80003228:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
8000322a:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
8000322c:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
8000322e:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003230:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003232:	f6 ca ff fe 	sub	r10,r11,-2
80003236:	18 9b       	mov	r11,r12
80003238:	fa cc ff f0 	sub	r12,sp,-16
8000323c:	f0 1f 00 05 	mcall	80003250 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003240:	2f e7       	sub	r7,-2
80003242:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003244:	1a 9c       	mov	r12,sp
80003246:	f0 1f 00 04 	mcall	80003254 <xcmp_tx+0x44>
}
8000324a:	2c 0d       	sub	sp,-256
8000324c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003250:	80 00       	ld.sh	r0,r0[0x0]
80003252:	62 26       	ld.w	r6,r1[0x8]
80003254:	80 00       	ld.sh	r0,r0[0x0]
80003256:	33 84       	mov	r4,56

80003258 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80003258:	d4 21       	pushm	r4-r7,lr
8000325a:	fa cd 00 d0 	sub	sp,sp,208
8000325e:	18 94       	mov	r4,r12
80003260:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003262:	e0 68 01 00 	mov	r8,256
80003266:	f0 0b 19 00 	cp.h	r11,r8
8000326a:	e0 8b 00 36 	brhi	800032d6 <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
8000326e:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003272:	e0 68 04 1d 	mov	r8,1053
80003276:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003278:	30 18       	mov	r8,1
8000327a:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
8000327c:	32 08       	mov	r8,32
8000327e:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003280:	30 28       	mov	r8,2
80003282:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003284:	30 48       	mov	r8,4
80003286:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80003288:	ea 1a 0c 00 	orh	r10,0xc00
8000328c:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
8000328e:	30 4a       	mov	r10,4
80003290:	1a 9b       	mov	r11,sp
80003292:	fa cc ff f4 	sub	r12,sp,-12
80003296:	f0 1f 00 12 	mcall	800032dc <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
8000329a:	30 f8       	mov	r8,15
8000329c:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
800032a0:	3a 78       	mov	r8,-89
800032a2:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
800032a6:	30 08       	mov	r8,0
800032a8:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
800032ac:	0e 9a       	mov	r10,r7
800032ae:	5c 7a       	castu.h	r10
800032b0:	f4 08 16 08 	lsr	r8,r10,0x8
800032b4:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
800032b8:	0e 96       	mov	r6,r7
800032ba:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
800032be:	08 9b       	mov	r11,r4
800032c0:	fa cc ff eb 	sub	r12,sp,-21
800032c4:	f0 1f 00 06 	mcall	800032dc <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
800032c8:	ee cb ff f3 	sub	r11,r7,-13
800032cc:	5c 5b       	castu.b	r11
800032ce:	fa cc ff fa 	sub	r12,sp,-6
800032d2:	f0 1f 00 04 	mcall	800032e0 <xcmp_data_session_req+0x88>
}
800032d6:	2c cd       	sub	sp,-208
800032d8:	d8 22       	popm	r4-r7,pc
800032da:	00 00       	add	r0,r0
800032dc:	80 00       	ld.sh	r0,r0[0x0]
800032de:	62 26       	ld.w	r6,r1[0x8]
800032e0:	80 00       	ld.sh	r0,r0[0x0]
800032e2:	32 10       	mov	r0,33

800032e4 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
800032e4:	d4 01       	pushm	lr
800032e6:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
800032ea:	fe 78 b4 00 	mov	r8,-19456
800032ee:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
800032f0:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
800032f4:	30 89       	mov	r9,8
800032f6:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
800032f8:	30 19       	mov	r9,1
800032fa:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
800032fc:	30 09       	mov	r9,0
800032fe:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003300:	30 5a       	mov	r10,5
80003302:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003304:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003306:	30 7a       	mov	r10,7
80003308:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
8000330a:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
8000330c:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
8000330e:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003312:	30 9b       	mov	r11,9
80003314:	fa cc ff fe 	sub	r12,sp,-2
80003318:	f0 1f 00 02 	mcall	80003320 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
8000331c:	2c dd       	sub	sp,-204
8000331e:	d8 02       	popm	pc
80003320:	80 00       	ld.sh	r0,r0[0x0]
80003322:	32 10       	mov	r0,33

80003324 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80003324:	d4 01       	pushm	lr
80003326:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
8000332a:	e0 68 04 09 	mov	r8,1033
8000332e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80003330:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80003334:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
80003336:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
8000333a:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
8000333c:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
8000333e:	30 09       	mov	r9,0
80003340:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80003342:	fb 69 00 08 	st.b	sp[8],r9
80003346:	fa c8 ff f7 	sub	r8,sp,-9
8000334a:	b0 89       	st.b	r8[0x0],r9
8000334c:	fa c8 ff f6 	sub	r8,sp,-10
80003350:	b0 89       	st.b	r8[0x0],r9
80003352:	fa c8 ff f5 	sub	r8,sp,-11
80003356:	b0 89       	st.b	r8[0x0],r9
80003358:	fa c8 ff f4 	sub	r8,sp,-12
8000335c:	b0 89       	st.b	r8[0x0],r9
8000335e:	fa c8 ff f3 	sub	r8,sp,-13
80003362:	b0 89       	st.b	r8[0x0],r9
80003364:	fa c8 ff f2 	sub	r8,sp,-14
80003368:	b0 89       	st.b	r8[0x0],r9
8000336a:	fa c8 ff f1 	sub	r8,sp,-15
8000336e:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80003370:	30 cb       	mov	r11,12
80003372:	fa cc ff fe 	sub	r12,sp,-2
80003376:	f0 1f 00 03 	mcall	80003380 <xcmp_IdleTestTone+0x5c>
}
8000337a:	2c dd       	sub	sp,-204
8000337c:	d8 02       	popm	pc
8000337e:	00 00       	add	r0,r0
80003380:	80 00       	ld.sh	r0,r0[0x0]
80003382:	32 10       	mov	r0,33

80003384 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80003384:	eb cd 40 c0 	pushm	r6-r7,lr
80003388:	20 1d       	sub	sp,4
8000338a:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
8000338c:	98 39       	ld.sh	r9,r12[0x6]
8000338e:	3f f8       	mov	r8,-1
80003390:	f0 09 19 00 	cp.h	r9,r8
80003394:	c0 a1       	brne	800033a8 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80003396:	4a e9       	lddpc	r9,8000344c <xnl_tx+0xc8>
80003398:	13 88       	ld.ub	r8,r9[0x0]
8000339a:	2f f8       	sub	r8,-1
8000339c:	5c 58       	castu.b	r8
8000339e:	b2 88       	st.b	r9[0x0],r8
800033a0:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800033a4:	a9 a8       	sbr	r8,0x8
800033a6:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800033a8:	8c 49       	ld.sh	r9,r6[0x8]
800033aa:	3f f8       	mov	r8,-1
800033ac:	f0 09 19 00 	cp.h	r9,r8
800033b0:	c0 41       	brne	800033b8 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800033b2:	4a 88       	lddpc	r8,80003450 <xnl_tx+0xcc>
800033b4:	90 18       	ld.sh	r8,r8[0x2]
800033b6:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800033b8:	8c 59       	ld.sh	r9,r6[0xa]
800033ba:	3f f8       	mov	r8,-1
800033bc:	f0 09 19 00 	cp.h	r9,r8
800033c0:	c0 41       	brne	800033c8 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800033c2:	4a 48       	lddpc	r8,80003450 <xnl_tx+0xcc>
800033c4:	90 28       	ld.sh	r8,r8[0x4]
800033c6:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
800033c8:	8c 69       	ld.sh	r9,r6[0xc]
800033ca:	3f f8       	mov	r8,-1
800033cc:	f0 09 19 00 	cp.h	r9,r8
800033d0:	c0 e1       	brne	800033ec <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
800033d2:	4a 08       	lddpc	r8,80003450 <xnl_tx+0xcc>
800033d4:	90 49       	ld.sh	r9,r8[0x8]
800033d6:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800033d8:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
800033da:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800033dc:	90 49       	ld.sh	r9,r8[0x8]
800033de:	e0 19 ff 00 	andl	r9,0xff00
800033e2:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
800033e6:	f3 e8 10 08 	or	r8,r9,r8
800033ea:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
800033ec:	0d 98       	ld.ub	r8,r6[0x1]
800033ee:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
800033f0:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
800033f4:	10 0c       	add	r12,r8
800033f6:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800033f8:	58 0c       	cp.w	r12,0
800033fa:	e0 89 00 04 	brgt	80003402 <xnl_tx+0x7e>
800033fe:	30 09       	mov	r9,0
80003400:	c0 d8       	rjmp	8000341a <xnl_tx+0x96>
80003402:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80003406:	2f ec       	sub	r12,-2
80003408:	30 09       	mov	r9,0
8000340a:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
8000340c:	15 1b       	ld.sh	r11,r10++
8000340e:	f6 09 00 09 	add	r9,r11,r9
80003412:	5c 89       	casts.h	r9
		indextohWord     += 1;
80003414:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80003416:	18 38       	cp.w	r8,r12
80003418:	cf a1       	brne	8000340c <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
8000341a:	5c 39       	neg	r9
8000341c:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000341e:	48 e8       	lddpc	r8,80003454 <xnl_tx+0xd0>
80003420:	70 0c       	ld.w	r12,r8[0x0]
80003422:	f0 1f 00 0e 	mcall	80003458 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80003426:	c1 00       	breq	80003446 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80003428:	fa c7 ff fc 	sub	r7,sp,-4
8000342c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
8000342e:	e0 6a 01 00 	mov	r10,256
80003432:	0c 9b       	mov	r11,r6
80003434:	f0 1f 00 0a 	mcall	8000345c <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80003438:	48 a8       	lddpc	r8,80003460 <xnl_tx+0xdc>
8000343a:	70 0c       	ld.w	r12,r8[0x0]
8000343c:	30 09       	mov	r9,0
8000343e:	12 9a       	mov	r10,r9
80003440:	1a 9b       	mov	r11,sp
80003442:	f0 1f 00 09 	mcall	80003464 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80003446:	2f fd       	sub	sp,-4
80003448:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000344c:	00 00       	add	r0,r0
8000344e:	0a 4c       	or	r12,r5
80003450:	00 00       	add	r0,r0
80003452:	0a 4e       	or	lr,r5
80003454:	00 00       	add	r0,r0
80003456:	0a 48       	or	r8,r5
80003458:	80 00       	ld.sh	r0,r0[0x0]
8000345a:	31 dc       	mov	r12,29
8000345c:	80 00       	ld.sh	r0,r0[0x0]
8000345e:	62 26       	ld.w	r6,r1[0x8]
80003460:	00 00       	add	r0,r0
80003462:	0a 58       	eor	r8,r5
80003464:	80 00       	ld.sh	r0,r0[0x0]
80003466:	4e d4       	lddpc	r4,80003618 <PcdComMF522>

80003468 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
80003468:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
8000346c:	48 76       	lddpc	r6,80003488 <RC522_ReadByte+0x20>
8000346e:	e0 6b 00 ff 	mov	r11,255
80003472:	6c 0c       	ld.w	r12,r6[0x0]
80003474:	f0 1f 00 06 	mcall	8000348c <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
80003478:	30 07       	mov	r7,0
8000347a:	0e 9b       	mov	r11,r7
8000347c:	6c 0c       	ld.w	r12,r6[0x0]
8000347e:	f0 1f 00 05 	mcall	80003490 <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
80003482:	0f 9c       	ld.ub	r12,r7[0x1]
80003484:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003488:	00 00       	add	r0,r0
8000348a:	1f 6c       	ld.uh	r12,--pc
8000348c:	80 00       	ld.sh	r0,r0[0x0]
8000348e:	44 6a       	lddsp	r10,sp[0x118]
80003490:	80 00       	ld.sh	r0,r0[0x0]
80003492:	44 86       	lddsp	r6,sp[0x120]

80003494 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
80003494:	eb cd 40 80 	pushm	r7,lr
80003498:	20 1d       	sub	sp,4
8000349a:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
8000349c:	48 77       	lddpc	r7,800034b8 <RC522_WriteByte+0x24>
8000349e:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
800034a2:	6e 0c       	ld.w	r12,r7[0x0]
800034a4:	f0 1f 00 06 	mcall	800034bc <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
800034a8:	1a 9b       	mov	r11,sp
800034aa:	6e 0c       	ld.w	r12,r7[0x0]
800034ac:	f0 1f 00 05 	mcall	800034c0 <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
800034b0:	5c 5c       	castu.b	r12
800034b2:	2f fd       	sub	sp,-4
800034b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800034b8:	00 00       	add	r0,r0
800034ba:	1f 6c       	ld.uh	r12,--pc
800034bc:	80 00       	ld.sh	r0,r0[0x0]
800034be:	44 6a       	lddsp	r10,sp[0x118]
800034c0:	80 00       	ld.sh	r0,r0[0x0]
800034c2:	44 86       	lddsp	r6,sp[0x120]

800034c4 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
800034c4:	eb cd 40 e0 	pushm	r5-r7,lr
800034c8:	18 96       	mov	r6,r12
800034ca:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
800034cc:	48 a7       	lddpc	r7,800034f4 <WriteRawRC+0x30>
800034ce:	30 0b       	mov	r11,0
800034d0:	6e 0c       	ld.w	r12,r7[0x0]
800034d2:	f0 1f 00 0a 	mcall	800034f8 <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
800034d6:	ec 0c 15 01 	lsl	r12,r6,0x1
800034da:	e2 1c 00 7e 	andl	r12,0x7e,COH
800034de:	f0 1f 00 08 	mcall	800034fc <WriteRawRC+0x38>
	RC522_WriteByte(value);
800034e2:	0a 9c       	mov	r12,r5
800034e4:	f0 1f 00 06 	mcall	800034fc <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800034e8:	30 0b       	mov	r11,0
800034ea:	6e 0c       	ld.w	r12,r7[0x0]
800034ec:	f0 1f 00 05 	mcall	80003500 <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
800034f0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800034f4:	00 00       	add	r0,r0
800034f6:	1f 6c       	ld.uh	r12,--pc
800034f8:	80 00       	ld.sh	r0,r0[0x0]
800034fa:	45 d0       	lddsp	r0,sp[0x174]
800034fc:	80 00       	ld.sh	r0,r0[0x0]
800034fe:	34 94       	mov	r4,73
80003500:	80 00       	ld.sh	r0,r0[0x0]
80003502:	45 90       	lddsp	r0,sp[0x164]

80003504 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
80003504:	d4 01       	pushm	lr

	SET_RC522RST;
80003506:	31 9c       	mov	r12,25
80003508:	f0 1f 00 1b 	mcall	80003574 <PcdReset+0x70>
	delay_ns(10);
8000350c:	30 ac       	mov	r12,10
8000350e:	f0 1f 00 1b 	mcall	80003578 <PcdReset+0x74>

	CLR_RC522RST;
80003512:	31 9c       	mov	r12,25
80003514:	f0 1f 00 1a 	mcall	8000357c <PcdReset+0x78>
	delay_ns(10);
80003518:	30 ac       	mov	r12,10
8000351a:	f0 1f 00 18 	mcall	80003578 <PcdReset+0x74>

	SET_RC522RST;
8000351e:	31 9c       	mov	r12,25
80003520:	f0 1f 00 15 	mcall	80003574 <PcdReset+0x70>
	delay_ns(10);
80003524:	30 ac       	mov	r12,10
80003526:	f0 1f 00 15 	mcall	80003578 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
8000352a:	30 fb       	mov	r11,15
8000352c:	30 1c       	mov	r12,1
8000352e:	f0 1f 00 15 	mcall	80003580 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80003532:	30 fb       	mov	r11,15
80003534:	30 1c       	mov	r12,1
80003536:	f0 1f 00 13 	mcall	80003580 <PcdReset+0x7c>
	delay_ns(10);
8000353a:	30 ac       	mov	r12,10
8000353c:	f0 1f 00 0f 	mcall	80003578 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80003540:	33 db       	mov	r11,61
80003542:	31 1c       	mov	r12,17
80003544:	f0 1f 00 0f 	mcall	80003580 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
80003548:	31 eb       	mov	r11,30
8000354a:	32 dc       	mov	r12,45
8000354c:	f0 1f 00 0d 	mcall	80003580 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80003550:	30 0b       	mov	r11,0
80003552:	32 cc       	mov	r12,44
80003554:	f0 1f 00 0b 	mcall	80003580 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
80003558:	e0 6b 00 8d 	mov	r11,141
8000355c:	32 ac       	mov	r12,42
8000355e:	f0 1f 00 09 	mcall	80003580 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
80003562:	33 eb       	mov	r11,62
80003564:	32 bc       	mov	r12,43
80003566:	f0 1f 00 07 	mcall	80003580 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
8000356a:	34 0b       	mov	r11,64
8000356c:	31 5c       	mov	r12,21
8000356e:	f0 1f 00 05 	mcall	80003580 <PcdReset+0x7c>
	
	return MI_OK;
}
80003572:	d8 0a       	popm	pc,r12=0
80003574:	80 00       	ld.sh	r0,r0[0x0]
80003576:	3f d8       	mov	r8,-3
80003578:	80 00       	ld.sh	r0,r0[0x0]
8000357a:	3b fc       	mov	r12,-65
8000357c:	80 00       	ld.sh	r0,r0[0x0]
8000357e:	3f f4       	mov	r4,-1
80003580:	80 00       	ld.sh	r0,r0[0x0]
80003582:	34 c4       	mov	r4,76

80003584 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
80003584:	eb cd 40 c0 	pushm	r6-r7,lr
80003588:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
8000358a:	48 c7       	lddpc	r7,800035b8 <ReadRawRC+0x34>
8000358c:	30 0b       	mov	r11,0
8000358e:	6e 0c       	ld.w	r12,r7[0x0]
80003590:	f0 1f 00 0b 	mcall	800035bc <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
80003594:	a1 76       	lsl	r6,0x1
80003596:	0c 9c       	mov	r12,r6
80003598:	e2 1c 00 7e 	andl	r12,0x7e,COH
8000359c:	a7 bc       	sbr	r12,0x7
8000359e:	f0 1f 00 09 	mcall	800035c0 <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
800035a2:	f0 1f 00 09 	mcall	800035c4 <ReadRawRC+0x40>
800035a6:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800035a8:	30 0b       	mov	r11,0
800035aa:	6e 0c       	ld.w	r12,r7[0x0]
800035ac:	f0 1f 00 07 	mcall	800035c8 <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
800035b0:	0c 9c       	mov	r12,r6
800035b2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800035b6:	00 00       	add	r0,r0
800035b8:	00 00       	add	r0,r0
800035ba:	1f 6c       	ld.uh	r12,--pc
800035bc:	80 00       	ld.sh	r0,r0[0x0]
800035be:	45 d0       	lddsp	r0,sp[0x174]
800035c0:	80 00       	ld.sh	r0,r0[0x0]
800035c2:	34 94       	mov	r4,73
800035c4:	80 00       	ld.sh	r0,r0[0x0]
800035c6:	34 68       	mov	r8,70
800035c8:	80 00       	ld.sh	r0,r0[0x0]
800035ca:	45 90       	lddsp	r0,sp[0x164]

800035cc <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
800035cc:	eb cd 40 c0 	pushm	r6-r7,lr
800035d0:	18 97       	mov	r7,r12
800035d2:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
800035d4:	f0 1f 00 05 	mcall	800035e8 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
800035d8:	f9 e6 10 0b 	or	r11,r12,r6
800035dc:	5c 5b       	castu.b	r11
800035de:	0e 9c       	mov	r12,r7
800035e0:	f0 1f 00 03 	mcall	800035ec <SetBitMask+0x20>
}
800035e4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800035e8:	80 00       	ld.sh	r0,r0[0x0]
800035ea:	35 84       	mov	r4,88
800035ec:	80 00       	ld.sh	r0,r0[0x0]
800035ee:	34 c4       	mov	r4,76

800035f0 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
800035f0:	eb cd 40 c0 	pushm	r6-r7,lr
800035f4:	18 97       	mov	r7,r12
800035f6:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
800035f8:	f0 1f 00 06 	mcall	80003610 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
800035fc:	5c d6       	com	r6
800035fe:	f9 e6 00 06 	and	r6,r12,r6
80003602:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80003606:	0e 9c       	mov	r12,r7
80003608:	f0 1f 00 03 	mcall	80003614 <ClearBitMask+0x24>
	
}
8000360c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003610:	80 00       	ld.sh	r0,r0[0x0]
80003612:	35 84       	mov	r4,88
80003614:	80 00       	ld.sh	r0,r0[0x0]
80003616:	34 c4       	mov	r4,76

80003618 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80003618:	d4 31       	pushm	r0-r7,lr
8000361a:	20 1d       	sub	sp,4
8000361c:	18 92       	mov	r2,r12
8000361e:	16 95       	mov	r5,r11
80003620:	14 96       	mov	r6,r10
80003622:	50 09       	stdsp	sp[0x0],r9
80003624:	10 90       	mov	r0,r8
80003626:	f8 c8 00 0c 	sub	r8,r12,12
8000362a:	5c 58       	castu.b	r8
8000362c:	30 29       	mov	r9,2
8000362e:	f2 08 18 00 	cp.b	r8,r9
80003632:	e0 88 00 05 	brls	8000363c <PcdComMF522+0x24>
80003636:	30 03       	mov	r3,0
80003638:	06 91       	mov	r1,r3
8000363a:	c0 78       	rjmp	80003648 <PcdComMF522+0x30>
8000363c:	4c f9       	lddpc	r9,80003778 <PcdComMF522+0x160>
8000363e:	f2 08 07 01 	ld.ub	r1,r9[r8]
80003642:	4c f9       	lddpc	r9,8000377c <PcdComMF522+0x164>
80003644:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80003648:	02 9b       	mov	r11,r1
8000364a:	a7 bb       	sbr	r11,0x7
8000364c:	30 2c       	mov	r12,2
8000364e:	f0 1f 00 4d 	mcall	80003780 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80003652:	e0 6b 00 80 	mov	r11,128
80003656:	30 4c       	mov	r12,4
80003658:	f0 1f 00 4b 	mcall	80003784 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
8000365c:	30 0b       	mov	r11,0
8000365e:	30 1c       	mov	r12,1
80003660:	f0 1f 00 48 	mcall	80003780 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80003664:	e0 6b 00 80 	mov	r11,128
80003668:	30 ac       	mov	r12,10
8000366a:	f0 1f 00 48 	mcall	80003788 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
8000366e:	58 06       	cp.w	r6,0
80003670:	c0 c0       	breq	80003688 <PcdComMF522+0x70>
80003672:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80003674:	30 94       	mov	r4,9
80003676:	0f 3b       	ld.ub	r11,r7++
80003678:	08 9c       	mov	r12,r4
8000367a:	f0 1f 00 42 	mcall	80003780 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
8000367e:	0e 98       	mov	r8,r7
80003680:	0a 18       	sub	r8,r5
80003682:	ec 08 19 00 	cp.h	r8,r6
80003686:	cf 83       	brcs	80003676 <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80003688:	04 9b       	mov	r11,r2
8000368a:	30 1c       	mov	r12,1
8000368c:	f0 1f 00 3d 	mcall	80003780 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80003690:	30 c8       	mov	r8,12
80003692:	f0 02 18 00 	cp.b	r2,r8
80003696:	c0 61       	brne	800036a2 <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80003698:	e0 6b 00 80 	mov	r11,128
8000369c:	30 dc       	mov	r12,13
8000369e:	f0 1f 00 3b 	mcall	80003788 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
800036a2:	30 4c       	mov	r12,4
800036a4:	f0 1f 00 3a 	mcall	8000378c <PcdComMF522+0x174>
800036a8:	18 97       	mov	r7,r12
800036aa:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
800036ae:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
800036b0:	30 44       	mov	r4,4
800036b2:	c0 88       	rjmp	800036c2 <PcdComMF522+0xaa>
800036b4:	08 9c       	mov	r12,r4
800036b6:	f0 1f 00 36 	mcall	8000378c <PcdComMF522+0x174>
800036ba:	18 97       	mov	r7,r12
		i--;
800036bc:	20 16       	sub	r6,1
800036be:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
800036c0:	c0 a0       	breq	800036d4 <PcdComMF522+0xbc>
800036c2:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
800036c6:	c4 c1       	brne	8000375e <PcdComMF522+0x146>
800036c8:	ef e3 00 08 	and	r8,r7,r3
800036cc:	ea 08 18 00 	cp.b	r8,r5
800036d0:	cf 20       	breq	800036b4 <PcdComMF522+0x9c>
800036d2:	c4 68       	rjmp	8000375e <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
800036d4:	e0 6b 00 80 	mov	r11,128
800036d8:	30 dc       	mov	r12,13
800036da:	f0 1f 00 2b 	mcall	80003784 <PcdComMF522+0x16c>
800036de:	30 27       	mov	r7,2
800036e0:	c3 38       	rjmp	80003746 <PcdComMF522+0x12e>
800036e2:	02 67       	and	r7,r1
800036e4:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
800036e8:	30 c8       	mov	r8,12
800036ea:	f0 02 18 00 	cp.b	r2,r8
800036ee:	c2 c1       	brne	80003746 <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
800036f0:	30 ac       	mov	r12,10
800036f2:	f0 1f 00 27 	mcall	8000378c <PcdComMF522+0x174>
800036f6:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
800036f8:	30 cc       	mov	r12,12
800036fa:	f0 1f 00 25 	mcall	8000378c <PcdComMF522+0x174>
800036fe:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80003702:	c0 70       	breq	80003710 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80003704:	08 98       	mov	r8,r4
80003706:	20 18       	sub	r8,1
80003708:	f8 08 00 3c 	add	r12,r12,r8<<0x3
8000370c:	a0 8c       	st.b	r0[0x0],r12
8000370e:	c0 48       	rjmp	80003716 <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80003710:	e8 08 15 03 	lsl	r8,r4,0x3
80003714:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80003716:	58 04       	cp.w	r4,0
80003718:	c0 61       	brne	80003724 <PcdComMF522+0x10c>
8000371a:	30 14       	mov	r4,1
8000371c:	40 05       	lddsp	r5,sp[0x0]
8000371e:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80003720:	30 93       	mov	r3,9
80003722:	c0 98       	rjmp	80003734 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80003724:	31 28       	mov	r8,18
80003726:	f0 04 18 00 	cp.b	r4,r8
8000372a:	f9 b4 0b 12 	movhi	r4,18
8000372e:	58 04       	cp.w	r4,0
80003730:	cf 61       	brne	8000371c <PcdComMF522+0x104>
80003732:	c0 a8       	rjmp	80003746 <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80003734:	06 9c       	mov	r12,r3
80003736:	f0 1f 00 16 	mcall	8000378c <PcdComMF522+0x174>
8000373a:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
8000373c:	ec 05 01 08 	sub	r8,r6,r5
80003740:	e8 08 19 00 	cp.h	r8,r4
80003744:	cf 83       	brcs	80003734 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80003746:	e0 6b 00 80 	mov	r11,128
8000374a:	30 cc       	mov	r12,12
8000374c:	f0 1f 00 0f 	mcall	80003788 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80003750:	30 0b       	mov	r11,0
80003752:	30 1c       	mov	r12,1
80003754:	f0 1f 00 0b 	mcall	80003780 <PcdComMF522+0x168>
	return status;
}
80003758:	0e 9c       	mov	r12,r7
8000375a:	2f fd       	sub	sp,-4
8000375c:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
8000375e:	e0 6b 00 80 	mov	r11,128
80003762:	30 dc       	mov	r12,13
80003764:	f0 1f 00 08 	mcall	80003784 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80003768:	30 6c       	mov	r12,6
8000376a:	f0 1f 00 09 	mcall	8000378c <PcdComMF522+0x174>
8000376e:	e2 1c 00 1b 	andl	r12,0x1b,COH
80003772:	cb 80       	breq	800036e2 <PcdComMF522+0xca>
80003774:	30 27       	mov	r7,2
80003776:	ce 8b       	rjmp	80003746 <PcdComMF522+0x12e>
80003778:	80 00       	ld.sh	r0,r0[0x0]
8000377a:	c1 94       	brge	800037ac <PcdAnticoll+0x1c>
8000377c:	80 00       	ld.sh	r0,r0[0x0]
8000377e:	c1 90       	breq	800037b0 <PcdAnticoll+0x20>
80003780:	80 00       	ld.sh	r0,r0[0x0]
80003782:	34 c4       	mov	r4,76
80003784:	80 00       	ld.sh	r0,r0[0x0]
80003786:	35 f0       	mov	r0,95
80003788:	80 00       	ld.sh	r0,r0[0x0]
8000378a:	35 cc       	mov	r12,92
8000378c:	80 00       	ld.sh	r0,r0[0x0]
8000378e:	35 84       	mov	r4,88

80003790 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80003790:	eb cd 40 c0 	pushm	r6-r7,lr
80003794:	20 5d       	sub	sp,20
80003796:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80003798:	30 8b       	mov	r11,8
8000379a:	16 9c       	mov	r12,r11
8000379c:	f0 1f 00 1a 	mcall	80003804 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
800037a0:	30 0b       	mov	r11,0
800037a2:	30 dc       	mov	r12,13
800037a4:	f0 1f 00 19 	mcall	80003808 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
800037a8:	e0 6b 00 80 	mov	r11,128
800037ac:	30 ec       	mov	r12,14
800037ae:	f0 1f 00 16 	mcall	80003804 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
800037b2:	39 38       	mov	r8,-109
800037b4:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
800037b6:	32 08       	mov	r8,32
800037b8:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
800037ba:	1a 9b       	mov	r11,sp
800037bc:	fa c8 ff ed 	sub	r8,sp,-19
800037c0:	1a 99       	mov	r9,sp
800037c2:	30 2a       	mov	r10,2
800037c4:	30 cc       	mov	r12,12
800037c6:	f0 1f 00 12 	mcall	8000380c <PcdAnticoll+0x7c>
800037ca:	18 97       	mov	r7,r12

	if (status == MI_OK)
800037cc:	c1 21       	brne	800037f0 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
800037ce:	1b 89       	ld.ub	r9,sp[0x0]
800037d0:	ac 89       	st.b	r6[0x0],r9
800037d2:	1b 98       	ld.ub	r8,sp[0x1]
800037d4:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
800037d6:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
800037d8:	1b a8       	ld.ub	r8,sp[0x2]
800037da:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
800037dc:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
800037e0:	1b b9       	ld.ub	r9,sp[0x3]
800037e2:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
800037e4:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
800037e6:	1b c9       	ld.ub	r9,sp[0x4]
800037e8:	f0 09 18 00 	cp.b	r9,r8
800037ec:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
800037f0:	e0 6b 00 80 	mov	r11,128
800037f4:	30 ec       	mov	r12,14
800037f6:	f0 1f 00 07 	mcall	80003810 <PcdAnticoll+0x80>
	return status;
}
800037fa:	0e 9c       	mov	r12,r7
800037fc:	2f bd       	sub	sp,-20
800037fe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003802:	00 00       	add	r0,r0
80003804:	80 00       	ld.sh	r0,r0[0x0]
80003806:	35 f0       	mov	r0,95
80003808:	80 00       	ld.sh	r0,r0[0x0]
8000380a:	34 c4       	mov	r4,76
8000380c:	80 00       	ld.sh	r0,r0[0x0]
8000380e:	36 18       	mov	r8,97
80003810:	80 00       	ld.sh	r0,r0[0x0]
80003812:	35 cc       	mov	r12,92

80003814 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80003814:	eb cd 40 c0 	pushm	r6-r7,lr
80003818:	20 5d       	sub	sp,20
8000381a:	18 97       	mov	r7,r12
8000381c:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
8000381e:	30 8b       	mov	r11,8
80003820:	16 9c       	mov	r12,r11
80003822:	f0 1f 00 12 	mcall	80003868 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80003826:	30 7b       	mov	r11,7
80003828:	30 dc       	mov	r12,13
8000382a:	f0 1f 00 11 	mcall	8000386c <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
8000382e:	30 3b       	mov	r11,3
80003830:	31 4c       	mov	r12,20
80003832:	f0 1f 00 10 	mcall	80003870 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80003836:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80003838:	1a 9b       	mov	r11,sp
8000383a:	fa c8 ff ed 	sub	r8,sp,-19
8000383e:	1a 99       	mov	r9,sp
80003840:	30 1a       	mov	r10,1
80003842:	30 cc       	mov	r12,12
80003844:	f0 1f 00 0c 	mcall	80003874 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80003848:	c0 c1       	brne	80003860 <PcdRequest+0x4c>
8000384a:	31 08       	mov	r8,16
8000384c:	fb 39 00 13 	ld.ub	r9,sp[19]
80003850:	f0 09 18 00 	cp.b	r9,r8
80003854:	c0 61       	brne	80003860 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80003856:	1b 88       	ld.ub	r8,sp[0x0]
80003858:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
8000385a:	1b 98       	ld.ub	r8,sp[0x1]
8000385c:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
8000385e:	c0 28       	rjmp	80003862 <PcdRequest+0x4e>
80003860:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80003862:	2f bd       	sub	sp,-20
80003864:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003868:	80 00       	ld.sh	r0,r0[0x0]
8000386a:	35 f0       	mov	r0,95
8000386c:	80 00       	ld.sh	r0,r0[0x0]
8000386e:	34 c4       	mov	r4,76
80003870:	80 00       	ld.sh	r0,r0[0x0]
80003872:	35 cc       	mov	r12,92
80003874:	80 00       	ld.sh	r0,r0[0x0]
80003876:	36 18       	mov	r8,97

80003878 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80003878:	eb cd 40 f8 	pushm	r3-r7,lr
8000387c:	18 95       	mov	r5,r12
8000387e:	16 96       	mov	r6,r11
80003880:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80003882:	30 4b       	mov	r11,4
80003884:	30 5c       	mov	r12,5
80003886:	f0 1f 00 1c 	mcall	800038f4 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
8000388a:	30 0b       	mov	r11,0
8000388c:	30 1c       	mov	r12,1
8000388e:	f0 1f 00 1b 	mcall	800038f8 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80003892:	e0 6b 00 80 	mov	r11,128
80003896:	30 ac       	mov	r12,10
80003898:	f0 1f 00 19 	mcall	800038fc <CalulateCRC+0x84>
	for (i=0; i<len; i++)
8000389c:	58 06       	cp.w	r6,0
8000389e:	c0 c0       	breq	800038b6 <CalulateCRC+0x3e>
800038a0:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
800038a2:	30 94       	mov	r4,9
800038a4:	0f 3b       	ld.ub	r11,r7++
800038a6:	08 9c       	mov	r12,r4
800038a8:	f0 1f 00 14 	mcall	800038f8 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
800038ac:	0e 98       	mov	r8,r7
800038ae:	0a 18       	sub	r8,r5
800038b0:	ec 08 18 00 	cp.b	r8,r6
800038b4:	cf 83       	brcs	800038a4 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
800038b6:	30 3b       	mov	r11,3
800038b8:	30 1c       	mov	r12,1
800038ba:	f0 1f 00 10 	mcall	800038f8 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
800038be:	30 5c       	mov	r12,5
800038c0:	f0 1f 00 10 	mcall	80003900 <CalulateCRC+0x88>
800038c4:	e0 67 00 fe 	mov	r7,254
800038c8:	30 56       	mov	r6,5
800038ca:	c0 78       	rjmp	800038d8 <CalulateCRC+0x60>
800038cc:	0c 9c       	mov	r12,r6
800038ce:	f0 1f 00 0d 	mcall	80003900 <CalulateCRC+0x88>
		i--;
800038d2:	20 17       	sub	r7,1
800038d4:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
800038d6:	c0 40       	breq	800038de <CalulateCRC+0x66>
800038d8:	e2 1c 00 04 	andl	r12,0x4,COH
800038dc:	cf 80       	breq	800038cc <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
800038de:	32 2c       	mov	r12,34
800038e0:	f0 1f 00 08 	mcall	80003900 <CalulateCRC+0x88>
800038e4:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
800038e6:	32 1c       	mov	r12,33
800038e8:	f0 1f 00 06 	mcall	80003900 <CalulateCRC+0x88>
800038ec:	a6 9c       	st.b	r3[0x1],r12
}
800038ee:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800038f2:	00 00       	add	r0,r0
800038f4:	80 00       	ld.sh	r0,r0[0x0]
800038f6:	35 f0       	mov	r0,95
800038f8:	80 00       	ld.sh	r0,r0[0x0]
800038fa:	34 c4       	mov	r4,76
800038fc:	80 00       	ld.sh	r0,r0[0x0]
800038fe:	35 cc       	mov	r12,92
80003900:	80 00       	ld.sh	r0,r0[0x0]
80003902:	35 84       	mov	r4,88

80003904 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80003904:	eb cd 40 80 	pushm	r7,lr
80003908:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
8000390a:	39 38       	mov	r8,-109
8000390c:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
8000390e:	37 08       	mov	r8,112
80003910:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80003912:	30 08       	mov	r8,0
80003914:	ba e8       	st.b	sp[0x6],r8
80003916:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
8000391a:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
8000391e:	19 89       	ld.ub	r9,r12[0x0]
80003920:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80003922:	19 3a       	ld.ub	r10,r12++
80003924:	1b e9       	ld.ub	r9,sp[0x6]
80003926:	f5 e9 20 09 	eor	r9,r10,r9
8000392a:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
8000392c:	16 38       	cp.w	r8,r11
8000392e:	cf 81       	brne	8000391e <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80003930:	1a 97       	mov	r7,sp
80003932:	fa ca ff f9 	sub	r10,sp,-7
80003936:	30 7b       	mov	r11,7
80003938:	1a 9c       	mov	r12,sp
8000393a:	f0 1f 00 0d 	mcall	8000396c <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
8000393e:	30 8b       	mov	r11,8
80003940:	16 9c       	mov	r12,r11
80003942:	f0 1f 00 0c 	mcall	80003970 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80003946:	fa c8 ff ed 	sub	r8,sp,-19
8000394a:	1a 99       	mov	r9,sp
8000394c:	30 9a       	mov	r10,9
8000394e:	1a 9b       	mov	r11,sp
80003950:	30 cc       	mov	r12,12
80003952:	f0 1f 00 09 	mcall	80003974 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80003956:	c0 71       	brne	80003964 <PcdSelect+0x60>
80003958:	31 88       	mov	r8,24
8000395a:	fb 39 00 13 	ld.ub	r9,sp[19]
8000395e:	f0 09 18 00 	cp.b	r9,r8
80003962:	c0 20       	breq	80003966 <PcdSelect+0x62>
80003964:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80003966:	2f bd       	sub	sp,-20
80003968:	e3 cd 80 80 	ldm	sp++,r7,pc
8000396c:	80 00       	ld.sh	r0,r0[0x0]
8000396e:	38 78       	mov	r8,-121
80003970:	80 00       	ld.sh	r0,r0[0x0]
80003972:	35 f0       	mov	r0,95
80003974:	80 00       	ld.sh	r0,r0[0x0]
80003976:	36 18       	mov	r8,97

80003978 <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80003978:	d4 31       	pushm	r0-r7,lr
8000397a:	18 92       	mov	r2,r12
	U8 status = MI_ERR;
	
	PcdReset();
8000397c:	f0 1f 00 34 	mcall	80003a4c <rfid_auto_reader+0xd4>
while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80003980:	4b 47       	lddpc	r7,80003a50 <rfid_auto_reader+0xd8>
80003982:	35 25       	mov	r5,82
	if(status!=MI_OK) //return status;
	continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80003984:	30 44       	mov	r4,4
	else if(CT[0]==0x44&&CT[1]==0x03)
		log("MF Desire\n");
	else
		log("Unknown\n");
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80003986:	4b 46       	lddpc	r6,80003a54 <rfid_auto_reader+0xdc>
	status=PcdSelect(SN);//
	if(status!=MI_OK)//return status;
	continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80003988:	30 41       	mov	r1,4
		log("select okay\n");
8000398a:	4b 40       	lddpc	r0,80003a58 <rfid_auto_reader+0xe0>
	if(status!=MI_OK) //return status;
	continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
8000398c:	30 23       	mov	r3,2
{
	U8 status = MI_ERR;
	
	PcdReset();
while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
8000398e:	0e 9b       	mov	r11,r7
80003990:	0a 9c       	mov	r12,r5
80003992:	f0 1f 00 33 	mcall	80003a5c <rfid_auto_reader+0xe4>
	if(status!=MI_OK) //return status;
80003996:	cf c1       	brne	8000398e <rfid_auto_reader+0x16>
	continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80003998:	0f 88       	ld.ub	r8,r7[0x0]
8000399a:	e8 08 18 00 	cp.b	r8,r4
8000399e:	c0 a1       	brne	800039b2 <rfid_auto_reader+0x3a>
800039a0:	0f 9a       	ld.ub	r10,r7[0x1]
800039a2:	30 09       	mov	r9,0
800039a4:	f2 0a 18 00 	cp.b	r10,r9
800039a8:	c0 51       	brne	800039b2 <rfid_auto_reader+0x3a>
		log("MFOne-S50\n");
800039aa:	4a ec       	lddpc	r12,80003a60 <rfid_auto_reader+0xe8>
800039ac:	f0 1f 00 2e 	mcall	80003a64 <rfid_auto_reader+0xec>
while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) //return status;
	continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
800039b0:	c3 78       	rjmp	80003a1e <rfid_auto_reader+0xa6>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
800039b2:	e6 08 18 00 	cp.b	r8,r3
800039b6:	c0 a1       	brne	800039ca <rfid_auto_reader+0x52>
800039b8:	0f 9a       	ld.ub	r10,r7[0x1]
800039ba:	30 09       	mov	r9,0
800039bc:	f2 0a 18 00 	cp.b	r10,r9
800039c0:	c0 51       	brne	800039ca <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
800039c2:	4a ac       	lddpc	r12,80003a68 <rfid_auto_reader+0xf0>
800039c4:	f0 1f 00 28 	mcall	80003a64 <rfid_auto_reader+0xec>
	if(status!=MI_OK) //return status;
	continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
800039c8:	c2 b8       	rjmp	80003a1e <rfid_auto_reader+0xa6>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
800039ca:	34 49       	mov	r9,68
800039cc:	f2 08 18 00 	cp.b	r8,r9
800039d0:	c0 a1       	brne	800039e4 <rfid_auto_reader+0x6c>
800039d2:	0f 9a       	ld.ub	r10,r7[0x1]
800039d4:	30 09       	mov	r9,0
800039d6:	f2 0a 18 00 	cp.b	r10,r9
800039da:	c0 51       	brne	800039e4 <rfid_auto_reader+0x6c>
		log("MF-UltraLight\n");
800039dc:	4a 4c       	lddpc	r12,80003a6c <rfid_auto_reader+0xf4>
800039de:	f0 1f 00 22 	mcall	80003a64 <rfid_auto_reader+0xec>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
800039e2:	c1 e8       	rjmp	80003a1e <rfid_auto_reader+0xa6>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
800039e4:	30 89       	mov	r9,8
800039e6:	f2 08 18 00 	cp.b	r8,r9
800039ea:	c0 a1       	brne	800039fe <rfid_auto_reader+0x86>
800039ec:	0f 9a       	ld.ub	r10,r7[0x1]
800039ee:	30 09       	mov	r9,0
800039f0:	f2 0a 18 00 	cp.b	r10,r9
800039f4:	c0 51       	brne	800039fe <rfid_auto_reader+0x86>
		log("MF-Pro\n");
800039f6:	49 fc       	lddpc	r12,80003a70 <rfid_auto_reader+0xf8>
800039f8:	f0 1f 00 1b 	mcall	80003a64 <rfid_auto_reader+0xec>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
800039fc:	c1 18       	rjmp	80003a1e <rfid_auto_reader+0xa6>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
800039fe:	34 49       	mov	r9,68
80003a00:	f2 08 18 00 	cp.b	r8,r9
80003a04:	c0 a1       	brne	80003a18 <rfid_auto_reader+0xa0>
80003a06:	0f 99       	ld.ub	r9,r7[0x1]
80003a08:	30 38       	mov	r8,3
80003a0a:	f0 09 18 00 	cp.b	r9,r8
80003a0e:	c0 51       	brne	80003a18 <rfid_auto_reader+0xa0>
		log("MF Desire\n");
80003a10:	49 9c       	lddpc	r12,80003a74 <rfid_auto_reader+0xfc>
80003a12:	f0 1f 00 15 	mcall	80003a64 <rfid_auto_reader+0xec>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80003a16:	c0 48       	rjmp	80003a1e <rfid_auto_reader+0xa6>
		log("MF Desire\n");
	else
		log("Unknown\n");
80003a18:	49 8c       	lddpc	r12,80003a78 <rfid_auto_reader+0x100>
80003a1a:	f0 1f 00 13 	mcall	80003a64 <rfid_auto_reader+0xec>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80003a1e:	0c 9c       	mov	r12,r6
80003a20:	f0 1f 00 17 	mcall	80003a7c <rfid_auto_reader+0x104>
	if(status!=MI_OK)
80003a24:	c0 60       	breq	80003a30 <rfid_auto_reader+0xb8>
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
80003a26:	37 8b       	mov	r11,120
80003a28:	30 1c       	mov	r12,1
80003a2a:	f0 1f 00 16 	mcall	80003a80 <rfid_auto_reader+0x108>
		//return status;
		continue;
80003a2e:	cb 0b       	rjmp	8000398e <rfid_auto_reader+0x16>
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80003a30:	0c 9c       	mov	r12,r6
80003a32:	f0 1f 00 15 	mcall	80003a84 <rfid_auto_reader+0x10c>
	if(status!=MI_OK)//return status;
80003a36:	ca c1       	brne	8000398e <rfid_auto_reader+0x16>
	continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80003a38:	02 9a       	mov	r10,r1
80003a3a:	0c 9b       	mov	r11,r6
80003a3c:	04 9c       	mov	r12,r2
80003a3e:	f0 1f 00 13 	mcall	80003a88 <rfid_auto_reader+0x110>
		log("select okay\n");
80003a42:	00 9c       	mov	r12,r0
80003a44:	f0 1f 00 08 	mcall	80003a64 <rfid_auto_reader+0xec>
80003a48:	ca 3b       	rjmp	8000398e <rfid_auto_reader+0x16>
80003a4a:	00 00       	add	r0,r0
80003a4c:	80 00       	ld.sh	r0,r0[0x0]
80003a4e:	35 04       	mov	r4,80
80003a50:	00 00       	add	r0,r0
80003a52:	1f 84       	ld.ub	r4,pc[0x0]
80003a54:	00 00       	add	r0,r0
80003a56:	1f 88       	ld.ub	r8,pc[0x0]
80003a58:	80 00       	ld.sh	r0,r0[0x0]
80003a5a:	c1 e0       	breq	80003a96 <rfid_sendID_message+0xa>
80003a5c:	80 00       	ld.sh	r0,r0[0x0]
80003a5e:	38 14       	mov	r4,-127
80003a60:	80 00       	ld.sh	r0,r0[0x0]
80003a62:	c1 98       	rjmp	80003a94 <rfid_sendID_message+0x8>
80003a64:	80 00       	ld.sh	r0,r0[0x0]
80003a66:	5b 0c       	cp.w	r12,-16
80003a68:	80 00       	ld.sh	r0,r0[0x0]
80003a6a:	c1 a4       	brge	80003a9e <rfid_sendID_message+0x12>
80003a6c:	80 00       	ld.sh	r0,r0[0x0]
80003a6e:	c1 b0       	breq	80003aa4 <rfid_sendID_message+0x18>
80003a70:	80 00       	ld.sh	r0,r0[0x0]
80003a72:	c1 c0       	breq	80003aaa <rfid_sendID_message+0x1e>
80003a74:	80 00       	ld.sh	r0,r0[0x0]
80003a76:	c1 c8       	rjmp	80003aae <rfid_sendID_message+0x22>
80003a78:	80 00       	ld.sh	r0,r0[0x0]
80003a7a:	c1 d4       	brge	80003ab4 <rfid_sendID_message+0x28>
80003a7c:	80 00       	ld.sh	r0,r0[0x0]
80003a7e:	37 90       	mov	r0,121
80003a80:	80 00       	ld.sh	r0,r0[0x0]
80003a82:	33 24       	mov	r4,50
80003a84:	80 00       	ld.sh	r0,r0[0x0]
80003a86:	39 04       	mov	r4,-112
80003a88:	80 00       	ld.sh	r0,r0[0x0]
80003a8a:	62 26       	ld.w	r6,r1[0x8]

80003a8c <rfid_sendID_message>:
	
}

extern volatile DateTime_t Current_time;
U8 rfid_sendID_message()
{
80003a8c:	eb cd 40 e0 	pushm	r5-r7,lr
80003a90:	21 fd       	sub	sp,124
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	//memset(data_buffer, 0x00, 16);
	memset(SN, 0x00, 10);
80003a92:	fa cc ff 90 	sub	r12,sp,-112
80003a96:	30 08       	mov	r8,0
80003a98:	30 09       	mov	r9,0
80003a9a:	f8 e9 00 00 	st.d	r12[0],r8
80003a9e:	30 0a       	mov	r10,0
80003aa0:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80003aa2:	fa e9 00 20 	st.d	sp[32],r8
80003aa6:	fa e9 00 28 	st.d	sp[40],r8
80003aaa:	fa e9 00 30 	st.d	sp[48],r8
80003aae:	fa e9 00 38 	st.d	sp[56],r8
80003ab2:	fa e9 00 40 	st.d	sp[64],r8
80003ab6:	fa e9 00 48 	st.d	sp[72],r8
80003aba:	fa e9 00 50 	st.d	sp[80],r8
80003abe:	fa e9 00 58 	st.d	sp[88],r8
80003ac2:	fa e9 00 60 	st.d	sp[96],r8
80003ac6:	fa e9 00 68 	st.d	sp[104],r8

	return_err = rfid_auto_reader(SN);
80003aca:	f0 1f 00 43 	mcall	80003bd4 <rfid_sendID_message+0x148>
80003ace:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80003ad0:	c7 61       	brne	80003bbc <rfid_sendID_message+0x130>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80003ad2:	fb 38 00 73 	ld.ub	r8,sp[115]
80003ad6:	1a d8       	st.w	--sp,r8
80003ad8:	fb 38 00 76 	ld.ub	r8,sp[118]
80003adc:	1a d8       	st.w	--sp,r8
80003ade:	fb 38 00 79 	ld.ub	r8,sp[121]
80003ae2:	1a d8       	st.w	--sp,r8
80003ae4:	fb 38 00 7c 	ld.ub	r8,sp[124]
80003ae8:	1a d8       	st.w	--sp,r8
80003aea:	4b cc       	lddpc	r12,80003bd8 <rfid_sendID_message+0x14c>
80003aec:	f0 1f 00 3c 	mcall	80003bdc <rfid_sendID_message+0x150>
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
80003af0:	37 7b       	mov	r11,119
80003af2:	30 1c       	mov	r12,1
80003af4:	f0 1f 00 3b 	mcall	80003be0 <rfid_sendID_message+0x154>
80003af8:	fa c9 ff 80 	sub	r9,sp,-128
80003afc:	fa c8 ff f0 	sub	r8,sp,-16
80003b00:	fa ca ff ee 	sub	r10,sp,-18
}
	
}

extern volatile DateTime_t Current_time;
U8 rfid_sendID_message()
80003b04:	fa c5 ff 7c 	sub	r5,sp,-132
80003b08:	10 9d       	mov	sp,r8
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80003b0a:	30 9e       	mov	lr,9
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80003b0c:	30 06       	mov	r6,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80003b0e:	13 8b       	ld.ub	r11,r9[0x0]
80003b10:	f6 0c 16 04 	lsr	r12,r11,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80003b14:	fc 0c 18 00 	cp.b	r12,lr
80003b18:	f7 bc 08 d0 	subls	r12,-48
80003b1c:	f1 fc 8e 00 	st.bls	r8[0x0],r12
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
80003b20:	f7 bc 0b a9 	subhi	r12,-87
80003b24:	f1 fc be 00 	st.bhi	r8[0x0],r12
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80003b28:	b0 96       	st.b	r8[0x1],r6
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
80003b2a:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
80003b2e:	fc 0b 18 00 	cp.b	r11,lr
80003b32:	f7 bb 08 d0 	subls	r11,-48
80003b36:	f5 fb 8e 00 	st.bls	r10[0x0],r11
			 else
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
80003b3a:	f7 bb 0b a9 	subhi	r11,-87
80003b3e:	f5 fb be 00 	st.bhi	r10[0x0],r11

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
80003b42:	b0 b6       	st.b	r8[0x3],r6
80003b44:	2f f9       	sub	r9,-1
80003b46:	2f c8       	sub	r8,-4
80003b48:	2f ca       	sub	r10,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
80003b4a:	0a 39       	cp.w	r9,r5
80003b4c:	ce 11       	brne	80003b0e <rfid_sendID_message+0x82>
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
		}
		
		memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
80003b4e:	30 6a       	mov	r10,6
80003b50:	4a 5b       	lddpc	r11,80003be4 <rfid_sendID_message+0x158>
80003b52:	fa cc ff f0 	sub	r12,sp,-16
80003b56:	f0 1f 00 25 	mcall	80003be8 <rfid_sendID_message+0x15c>
	
		header.length = (0x0008 + sizeof(Message_Data_t));
	
		if(start_session > 0x9f)start_session = 0x80;
80003b5a:	4a 58       	lddpc	r8,80003bec <rfid_sendID_message+0x160>
80003b5c:	11 89       	ld.ub	r9,r8[0x0]
80003b5e:	39 f8       	mov	r8,-97
80003b60:	f0 09 18 00 	cp.b	r9,r8
80003b64:	e0 88 00 05 	brls	80003b6e <rfid_sendID_message+0xe2>
80003b68:	38 09       	mov	r9,-128
80003b6a:	4a 18       	lddpc	r8,80003bec <rfid_sendID_message+0x160>
80003b6c:	b0 89       	st.b	r8[0x0],r9
	
		header.session_id = (++start_session);
80003b6e:	4a 08       	lddpc	r8,80003bec <rfid_sendID_message+0x160>
80003b70:	11 86       	ld.ub	r6,r8[0x0]
80003b72:	2f f6       	sub	r6,-1
80003b74:	b0 86       	st.b	r8[0x0],r6
	
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
80003b76:	30 5a       	mov	r10,5
80003b78:	49 eb       	lddpc	r11,80003bf0 <rfid_sendID_message+0x164>
80003b7a:	fa cc ff e5 	sub	r12,sp,-27
80003b7e:	f0 1f 00 1b 	mcall	80003be8 <rfid_sendID_message+0x15c>
		header.type = 0xe000;
	
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
80003b82:	31 e8       	mov	r8,30
80003b84:	fb 58 00 16 	st.h	sp[22],r8
80003b88:	fb 66 00 1a 	st.b	sp[26],r6
80003b8c:	fe 78 e0 00 	mov	r8,-8192
80003b90:	fb 58 00 18 	st.h	sp[24],r8
80003b94:	fa c6 ff e0 	sub	r6,sp,-32
80003b98:	30 aa       	mov	r10,10
80003b9a:	fa cb ff ea 	sub	r11,sp,-22
80003b9e:	0c 9c       	mov	r12,r6
80003ba0:	f0 1f 00 12 	mcall	80003be8 <rfid_sendID_message+0x15c>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
80003ba4:	31 6a       	mov	r10,22
80003ba6:	1a 9b       	mov	r11,sp
80003ba8:	fa cc ff d6 	sub	r12,sp,-42
80003bac:	f0 1f 00 0f 	mcall	80003be8 <rfid_sendID_message+0x15c>
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
80003bb0:	30 9a       	mov	r10,9
80003bb2:	32 0b       	mov	r11,32
80003bb4:	0c 9c       	mov	r12,r6
80003bb6:	f0 1f 00 10 	mcall	80003bf4 <rfid_sendID_message+0x168>
80003bba:	c0 88       	rjmp	80003bca <rfid_sendID_message+0x13e>
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate scan rfid failure!!!
80003bbc:	37 8b       	mov	r11,120
80003bbe:	30 1c       	mov	r12,1
80003bc0:	f0 1f 00 08 	mcall	80003be0 <rfid_sendID_message+0x154>
		log("no card find...\n");
80003bc4:	48 dc       	lddpc	r12,80003bf8 <rfid_sendID_message+0x16c>
80003bc6:	f0 1f 00 06 	mcall	80003bdc <rfid_sendID_message+0x150>
	}
	
	return return_err;
	
}
80003bca:	0e 9c       	mov	r12,r7
80003bcc:	2e 1d       	sub	sp,-124
80003bce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003bd2:	00 00       	add	r0,r0
80003bd4:	80 00       	ld.sh	r0,r0[0x0]
80003bd6:	39 78       	mov	r8,-105
80003bd8:	80 00       	ld.sh	r0,r0[0x0]
80003bda:	c1 f0       	breq	80003c18 <local_start_timer+0x4>
80003bdc:	80 00       	ld.sh	r0,r0[0x0]
80003bde:	5b 0c       	cp.w	r12,-16
80003be0:	80 00       	ld.sh	r0,r0[0x0]
80003be2:	33 24       	mov	r4,50
80003be4:	00 00       	add	r0,r0
80003be6:	0c e4       	st.h	--r6,r4
80003be8:	80 00       	ld.sh	r0,r0[0x0]
80003bea:	62 26       	ld.w	r6,r1[0x8]
80003bec:	00 00       	add	r0,r0
80003bee:	05 00       	ld.w	r0,r2++
80003bf0:	00 00       	add	r0,r0
80003bf2:	04 f8       	st.b	--r2,r8
80003bf4:	80 00       	ld.sh	r0,r0[0x0]
80003bf6:	32 58       	mov	r8,37
80003bf8:	80 00       	ld.sh	r0,r0[0x0]
80003bfa:	c2 0c       	rcall	80003c3a <local_start_timer+0x26>

80003bfc <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80003bfc:	58 0c       	cp.w	r12,0
80003bfe:	5e 0c       	reteq	r12
80003c00:	30 08       	mov	r8,0
	{
		nop();
80003c02:	d7 03       	nop
		nop();
80003c04:	d7 03       	nop
		nop();
80003c06:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80003c08:	2f f8       	sub	r8,-1
80003c0a:	10 3c       	cp.w	r12,r8
80003c0c:	fe 9b ff fb 	brhi	80003c02 <delay_ns+0x6>
80003c10:	5e fc       	retal	r12
80003c12:	d7 03       	nop

80003c14 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80003c14:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80003c16:	30 3b       	mov	r11,3
80003c18:	48 8c       	lddpc	r12,80003c38 <local_start_timer+0x24>
80003c1a:	f0 1f 00 09 	mcall	80003c3c <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
80003c1e:	fe 78 38 00 	mov	r8,-51200
80003c22:	e0 69 91 0d 	mov	r9,37133
80003c26:	ea 19 00 52 	orh	r9,0x52
80003c2a:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80003c2c:	32 09       	mov	r9,32
80003c2e:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80003c30:	30 59       	mov	r9,5
80003c32:	91 09       	st.w	r8[0x0],r9
}
80003c34:	d8 02       	popm	pc
80003c36:	00 00       	add	r0,r0
80003c38:	80 00       	ld.sh	r0,r0[0x0]
80003c3a:	c2 44       	brge	80003c82 <local_start_pll0+0x42>
80003c3c:	80 00       	ld.sh	r0,r0[0x0]
80003c3e:	3f a8       	mov	r8,-6

80003c40 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
80003c40:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
80003c42:	30 3a       	mov	r10,3
80003c44:	e0 6b 1b 00 	mov	r11,6912
80003c48:	ea 1b 00 b7 	orh	r11,0xb7
80003c4c:	fe 7c 0c 00 	mov	r12,-62464
80003c50:	f0 1f 00 19 	mcall	80003cb4 <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
80003c54:	31 08       	mov	r8,16
80003c56:	1a d8       	st.w	--sp,r8
80003c58:	30 08       	mov	r8,0
80003c5a:	30 19       	mov	r9,1
80003c5c:	30 7a       	mov	r10,7
80003c5e:	10 9b       	mov	r11,r8
80003c60:	fe 7c 0c 00 	mov	r12,-62464
80003c64:	f0 1f 00 15 	mcall	80003cb8 <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
80003c68:	30 08       	mov	r8,0
80003c6a:	30 19       	mov	r9,1
80003c6c:	12 9a       	mov	r10,r9
80003c6e:	10 9b       	mov	r11,r8
80003c70:	fe 7c 0c 00 	mov	r12,-62464
80003c74:	f0 1f 00 12 	mcall	80003cbc <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
80003c78:	30 0b       	mov	r11,0
80003c7a:	fe 7c 0c 00 	mov	r12,-62464
80003c7e:	f0 1f 00 11 	mcall	80003cc0 <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
80003c82:	fe 7c 0c 00 	mov	r12,-62464
80003c86:	f0 1f 00 10 	mcall	80003cc4 <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
80003c8a:	30 0a       	mov	r10,0
80003c8c:	1a da       	st.w	--sp,r10
80003c8e:	1a da       	st.w	--sp,r10
80003c90:	14 98       	mov	r8,r10
80003c92:	14 99       	mov	r9,r10
80003c94:	30 1b       	mov	r11,1
80003c96:	fe 7c 0c 00 	mov	r12,-62464
80003c9a:	f0 1f 00 0c 	mcall	80003cc8 <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
80003c9e:	30 1c       	mov	r12,1
80003ca0:	f0 1f 00 0b 	mcall	80003ccc <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
80003ca4:	30 2b       	mov	r11,2
80003ca6:	fe 7c 0c 00 	mov	r12,-62464
80003caa:	f0 1f 00 0a 	mcall	80003cd0 <local_start_pll0+0x90>
80003cae:	2f dd       	sub	sp,-12
/****/
}
80003cb0:	d8 02       	popm	pc
80003cb2:	00 00       	add	r0,r0
80003cb4:	80 00       	ld.sh	r0,r0[0x0]
80003cb6:	42 98       	lddsp	r8,sp[0xa4]
80003cb8:	80 00       	ld.sh	r0,r0[0x0]
80003cba:	42 3a       	lddsp	r10,sp[0x8c]
80003cbc:	80 00       	ld.sh	r0,r0[0x0]
80003cbe:	42 5c       	lddsp	r12,sp[0x94]
80003cc0:	80 00       	ld.sh	r0,r0[0x0]
80003cc2:	42 76       	lddsp	r6,sp[0x9c]
80003cc4:	80 00       	ld.sh	r0,r0[0x0]
80003cc6:	42 84       	lddsp	r4,sp[0xa0]
80003cc8:	80 00       	ld.sh	r0,r0[0x0]
80003cca:	41 f4       	lddsp	r4,sp[0x7c]
80003ccc:	80 00       	ld.sh	r0,r0[0x0]
80003cce:	3f 48       	mov	r8,-12
80003cd0:	80 00       	ld.sh	r0,r0[0x0]
80003cd2:	42 8e       	lddsp	lr,sp[0xa0]

80003cd4 <xg_flashc_init>:
}


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
80003cd4:	d4 31       	pushm	r0-r7,lr
80003cd6:	20 3d       	sub	sp,12
	
	/* Create the mutex semaphore to guard a shared xgflash.*/
	xgflash_mutex = xSemaphoreCreateMutex();
80003cd8:	f0 1f 00 80 	mcall	80003ed8 <xg_flashc_init+0x204>
80003cdc:	fe f8 02 00 	ld.w	r8,pc[512]
80003ce0:	91 0c       	st.w	r8[0x0],r12
	if (xgflash_mutex == NULL)
80003ce2:	70 08       	ld.w	r8,r8[0x0]
80003ce4:	58 08       	cp.w	r8,0
80003ce6:	c0 41       	brne	80003cee <xg_flashc_init+0x1a>
	{
		log("Create the xgflash_mutex semaphore failure\n");
80003ce8:	4f ec       	lddpc	r12,80003ee0 <xg_flashc_init+0x20c>
80003cea:	f0 1f 00 7f 	mcall	80003ee4 <xg_flashc_init+0x210>
	}
	
	/* Create the binary semaphore to Synchronize other threads.*/
	vSemaphoreCreateBinary(xBinarySemaphore);
80003cee:	30 0b       	mov	r11,0
80003cf0:	30 1c       	mov	r12,1
80003cf2:	f0 1f 00 7e 	mcall	80003ee8 <xg_flashc_init+0x214>
80003cf6:	4f e8       	lddpc	r8,80003eec <xg_flashc_init+0x218>
80003cf8:	91 0c       	st.w	r8[0x0],r12
80003cfa:	70 08       	ld.w	r8,r8[0x0]
80003cfc:	58 08       	cp.w	r8,0
80003cfe:	c0 80       	breq	80003d0e <xg_flashc_init+0x3a>
80003d00:	4f b8       	lddpc	r8,80003eec <xg_flashc_init+0x218>
80003d02:	70 0c       	ld.w	r12,r8[0x0]
80003d04:	30 09       	mov	r9,0
80003d06:	12 9a       	mov	r10,r9
80003d08:	12 9b       	mov	r11,r9
80003d0a:	f0 1f 00 7a 	mcall	80003ef0 <xg_flashc_init+0x21c>
	
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
80003d0e:	30 4b       	mov	r11,4
80003d10:	31 4c       	mov	r12,20
80003d12:	f0 1f 00 76 	mcall	80003ee8 <xg_flashc_init+0x214>
80003d16:	4f 88       	lddpc	r8,80003ef4 <xg_flashc_init+0x220>
80003d18:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
80003d1a:	30 4b       	mov	r11,4
80003d1c:	31 4c       	mov	r12,20
80003d1e:	f0 1f 00 73 	mcall	80003ee8 <xg_flashc_init+0x214>
80003d22:	4f 68       	lddpc	r8,80003ef8 <xg_flashc_init+0x224>
80003d24:	91 0c       	st.w	r8[0x0],r12
80003d26:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
80003d28:	10 96       	mov	r6,r8
80003d2a:	4f 55       	lddpc	r5,80003efc <xg_flashc_init+0x228>
80003d2c:	6c 0c       	ld.w	r12,r6[0x0]
80003d2e:	ea 07 00 0b 	add	r11,r5,r7
80003d32:	f0 1f 00 74 	mcall	80003f00 <xg_flashc_init+0x22c>
80003d36:	2e 07       	sub	r7,-32
	
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
80003d38:	e0 47 02 80 	cp.w	r7,640
80003d3c:	cf 81       	brne	80003d2c <xg_flashc_init+0x58>
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
	}
	
	
	data_flash_init();//interface
80003d3e:	f0 1f 00 72 	mcall	80003f04 <xg_flashc_init+0x230>
	df_status_t return_code = DF_OK;
	static U32 current_page_number =0;
	unsigned int i = 0;
	unsigned int address =0x00000000;
	static char str[80];
	memset(str, 0x00, sizeof(str));
80003d42:	30 0a       	mov	r10,0
80003d44:	30 0b       	mov	r11,0
80003d46:	4f 18       	lddpc	r8,80003f08 <xg_flashc_init+0x234>
80003d48:	b1 2a       	st.d	r8++,r10
80003d4a:	b1 2a       	st.d	r8++,r10
80003d4c:	b1 2a       	st.d	r8++,r10
80003d4e:	b1 2a       	st.d	r8++,r10
80003d50:	b1 2a       	st.d	r8++,r10
80003d52:	b1 2a       	st.d	r8++,r10
80003d54:	b1 2a       	st.d	r8++,r10
80003d56:	b1 2a       	st.d	r8++,r10
80003d58:	b1 2a       	st.d	r8++,r10
80003d5a:	f0 eb 00 00 	st.d	r8[0],r10
80003d5e:	30 05       	mov	r5,0
	
start:
	
	 //bytes remained less than one page 
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80003d60:	4e a7       	lddpc	r7,80003f08 <xg_flashc_init+0x234>
			if(return_code == DF_OK)
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
					
					memset(str, 0x00, sizeof(str));	
80003d62:	ee c4 ff f8 	sub	r4,r7,-8
80003d66:	e8 c3 ff f8 	sub	r3,r4,-8
80003d6a:	e6 c2 ff f8 	sub	r2,r3,-8
80003d6e:	e4 c1 ff f8 	sub	r1,r2,-8
80003d72:	e2 c0 ff f8 	sub	r0,r1,-8
80003d76:	e0 ca ff f8 	sub	r10,r0,-8
80003d7a:	50 0a       	stdsp	sp[0x0],r10
80003d7c:	2f 8a       	sub	r10,-8
80003d7e:	50 1a       	stdsp	sp[0x4],r10
80003d80:	2f 8a       	sub	r10,-8
80003d82:	50 2a       	stdsp	sp[0x8],r10
	memset(str, 0x00, sizeof(str));
	
start:
	
	 //bytes remained less than one page 
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80003d84:	0e 9a       	mov	r10,r7
80003d86:	30 6b       	mov	r11,6
80003d88:	30 0c       	mov	r12,0
80003d8a:	f0 1f 00 61 	mcall	80003f0c <xg_flashc_init+0x238>
	{
		if(memcmp(XGFlashLabel, str, sizeof(XGFlashLabel)-1) != 0)//compare label
80003d8e:	30 6a       	mov	r10,6
80003d90:	0e 9b       	mov	r11,r7
80003d92:	4e 0c       	lddpc	r12,80003f10 <xg_flashc_init+0x23c>
80003d94:	f0 1f 00 60 	mcall	80003f14 <xg_flashc_init+0x240>
80003d98:	c1 c0       	breq	80003dd0 <xg_flashc_init+0xfc>
80003d9a:	c8 58       	rjmp	80003ea4 <xg_flashc_init+0x1d0>
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
			}
			//set label
			return_code = data_flash_write(XGFlashLabel, LABEL_ADDRESS, LABEL_LENGTH);
80003d9c:	30 6a       	mov	r10,6
80003d9e:	30 0b       	mov	r11,0
80003da0:	4d cc       	lddpc	r12,80003f10 <xg_flashc_init+0x23c>
80003da2:	f0 1f 00 5e 	mcall	80003f18 <xg_flashc_init+0x244>
			
			//set current_voice_index
			memset(str, 0x00, sizeof(str));
80003da6:	4d 97       	lddpc	r7,80003f08 <xg_flashc_init+0x234>
80003da8:	35 0a       	mov	r10,80
80003daa:	30 0b       	mov	r11,0
80003dac:	0e 9c       	mov	r12,r7
80003dae:	f0 1f 00 5c 	mcall	80003f1c <xg_flashc_init+0x248>
			return_code = data_flash_write(str, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
80003db2:	30 2a       	mov	r10,2
80003db4:	30 6b       	mov	r11,6
80003db6:	0e 9c       	mov	r12,r7
80003db8:	f0 1f 00 58 	mcall	80003f18 <xg_flashc_init+0x244>
			if(return_code != DF_WRITE_COMPLETED)
80003dbc:	58 7c       	cp.w	r12,7
80003dbe:	e0 81 00 8a 	brne	80003ed2 <xg_flashc_init+0x1fe>
			{
				return FALSE;
			}
			current_message_index = 0;
80003dc2:	30 09       	mov	r9,0
80003dc4:	4d 78       	lddpc	r8,80003f20 <xg_flashc_init+0x24c>
80003dc6:	b0 09       	st.h	r8[0x0],r9
			log("\r\n----create xg message info okay!----\r\n");
80003dc8:	4d 7c       	lddpc	r12,80003f24 <xg_flashc_init+0x250>
80003dca:	f0 1f 00 47 	mcall	80003ee4 <xg_flashc_init+0x210>
80003dce:	c7 f8       	rjmp	80003ecc <xg_flashc_init+0x1f8>
		}
		else//success
		{
			log("\nLABEL: %s\n", str);
80003dd0:	1a d7       	st.w	--sp,r7
80003dd2:	4d 6c       	lddpc	r12,80003f28 <xg_flashc_init+0x254>
80003dd4:	f0 1f 00 44 	mcall	80003ee4 <xg_flashc_init+0x210>
			//Get the current voice index
			return_code = data_flash_read_block(MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH, &current_message_index);								
80003dd8:	4d 2a       	lddpc	r10,80003f20 <xg_flashc_init+0x24c>
80003dda:	30 2b       	mov	r11,2
80003ddc:	30 6c       	mov	r12,6
80003dde:	f0 1f 00 4c 	mcall	80003f0c <xg_flashc_init+0x238>
			if(return_code == DF_OK)
80003de2:	2f fd       	sub	sp,-4
80003de4:	58 0c       	cp.w	r12,0
80003de6:	c7 61       	brne	80003ed2 <xg_flashc_init+0x1fe>
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
80003de8:	4c e8       	lddpc	r8,80003f20 <xg_flashc_init+0x24c>
80003dea:	90 09       	ld.sh	r9,r8[0x0]
80003dec:	30 08       	mov	r8,0
80003dee:	f0 09 19 00 	cp.h	r9,r8
80003df2:	c6 a0       	breq	80003ec6 <xg_flashc_init+0x1f2>
					
					memset(str, 0x00, sizeof(str));	
80003df4:	30 08       	mov	r8,0
80003df6:	30 09       	mov	r9,0
80003df8:	ee e9 00 00 	st.d	r7[0],r8
80003dfc:	e8 e9 00 00 	st.d	r4[0],r8
80003e00:	e6 e9 00 00 	st.d	r3[0],r8
80003e04:	e4 e9 00 00 	st.d	r2[0],r8
80003e08:	e2 e9 00 00 	st.d	r1[0],r8
80003e0c:	e0 e9 00 00 	st.d	r0[0],r8
80003e10:	40 0a       	lddsp	r10,sp[0x0]
80003e12:	f4 e9 00 00 	st.d	r10[0],r8
80003e16:	40 1a       	lddsp	r10,sp[0x4]
80003e18:	f4 e9 00 00 	st.d	r10[0],r8
80003e1c:	40 2a       	lddsp	r10,sp[0x8]
80003e1e:	b5 28       	st.d	r10++,r8
80003e20:	f4 e9 00 00 	st.d	r10[0],r8
					address = XG_MESSAGE_INFO_HEADER_START_ADD + ((current_message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
80003e24:	4b f8       	lddpc	r8,80003f20 <xg_flashc_init+0x24c>
80003e26:	90 85       	ld.uh	r5,r8[0x0]
80003e28:	a3 75       	lsl	r5,0x3
					return_code = data_flash_read_block(address, XG_MESSAGE_INFO_HEADER_LENGTH, (U8 *)str);			
80003e2a:	0e 9a       	mov	r10,r7
80003e2c:	30 8b       	mov	r11,8
80003e2e:	0a 9c       	mov	r12,r5
80003e30:	f0 1f 00 37 	mcall	80003f0c <xg_flashc_init+0x238>
					if(return_code == DF_OK)
80003e34:	c4 91       	brne	80003ec6 <xg_flashc_init+0x1f2>
					{
						MessageList_Info_t *ptr = (MessageList_Info_t *)str;
						if(ptr->numb == current_message_index)
80003e36:	0f 89       	ld.ub	r9,r7[0x0]
80003e38:	0f 98       	ld.ub	r8,r7[0x1]
80003e3a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80003e3e:	4b 99       	lddpc	r9,80003f20 <xg_flashc_init+0x24c>
80003e40:	92 09       	ld.sh	r9,r9[0x0]
80003e42:	f0 09 19 00 	cp.h	r9,r8
80003e46:	c2 c1       	brne	80003e9e <xg_flashc_init+0x1ca>
						{
							current_save_message_offset = ptr->address + ptr->offset;
80003e48:	0f e9       	ld.ub	r9,r7[0x6]
80003e4a:	0f f8       	ld.ub	r8,r7[0x7]
80003e4c:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80003e50:	0f aa       	ld.ub	r10,r7[0x2]
80003e52:	0f b8       	ld.ub	r8,r7[0x3]
80003e54:	b1 68       	lsl	r8,0x10
80003e56:	f1 ea 11 88 	or	r8,r8,r10<<0x18
80003e5a:	0f ca       	ld.ub	r10,r7[0x4]
80003e5c:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80003e60:	0f da       	ld.ub	r10,r7[0x5]
80003e62:	f5 e8 10 08 	or	r8,r10,r8
80003e66:	f2 08 00 08 	add	r8,r9,r8
80003e6a:	4b 16       	lddpc	r6,80003f2c <xg_flashc_init+0x258>
80003e6c:	8d 08       	st.w	r6[0x0],r8
							log("current_save_message_offset : %X\n", current_save_message_offset);
80003e6e:	1a d8       	st.w	--sp,r8
80003e70:	4b 0c       	lddpc	r12,80003f30 <xg_flashc_init+0x25c>
80003e72:	f0 1f 00 1d 	mcall	80003ee4 <xg_flashc_init+0x210>
							if(current_save_message_offset > XG_MESSAGE_DATA_BOUNDARY_ADD){
80003e76:	2f fd       	sub	sp,-4
80003e78:	6c 08       	ld.w	r8,r6[0x0]
80003e7a:	e0 69 ff ff 	mov	r9,65535
80003e7e:	ea 19 00 7f 	orh	r9,0x7f
80003e82:	12 38       	cp.w	r8,r9
80003e84:	e0 88 00 21 	brls	80003ec6 <xg_flashc_init+0x1f2>
										
								log("\r\n----message storage is full!!!----\r\n");
80003e88:	4a bc       	lddpc	r12,80003f34 <xg_flashc_init+0x260>
80003e8a:	f0 1f 00 17 	mcall	80003ee4 <xg_flashc_init+0x210>
								//xgflash erase

								return_code = data_flash_erase_block(0, DF_BLOCK_ALL);
80003e8e:	30 4b       	mov	r11,4
80003e90:	30 0c       	mov	r12,0
80003e92:	f0 1f 00 2a 	mcall	80003f38 <xg_flashc_init+0x264>
								if(return_code == DF_ERASE_COMPLETED)goto start;
80003e96:	58 5c       	cp.w	r12,5
80003e98:	fe 90 ff 76 	breq	80003d84 <xg_flashc_init+0xb0>
80003e9c:	c1 b8       	rjmp	80003ed2 <xg_flashc_init+0x1fe>

							}
						}
						else
						{
							log("\r\n----message storage is err!!!----\r\n");
80003e9e:	4a 8c       	lddpc	r12,80003f3c <xg_flashc_init+0x268>
80003ea0:	f0 1f 00 11 	mcall	80003ee4 <xg_flashc_init+0x210>
		{
			ERASE:
			//erase list
			for(i; i < (XG_MESSAGE_LISTINFO_BOUNDARY_ADD/(64*1024)); i++)//2*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80003ea4:	30 3b       	mov	r11,3
80003ea6:	0a 9c       	mov	r12,r5
80003ea8:	f0 1f 00 24 	mcall	80003f38 <xg_flashc_init+0x264>
				if(return_code != DF_ERASE_COMPLETED)
80003eac:	58 5c       	cp.w	r12,5
80003eae:	c1 21       	brne	80003ed2 <xg_flashc_init+0x1fe>
		{
			ERASE:
			//erase list
			for(i; i < (XG_MESSAGE_LISTINFO_BOUNDARY_ADD/(64*1024)); i++)//2*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80003eb0:	30 3b       	mov	r11,3
80003eb2:	e0 78 00 00 	mov	r8,65536
80003eb6:	ea 08 00 0c 	add	r12,r5,r8
80003eba:	f0 1f 00 20 	mcall	80003f38 <xg_flashc_init+0x264>
				if(return_code != DF_ERASE_COMPLETED)
80003ebe:	58 5c       	cp.w	r12,5
80003ec0:	fe 90 ff 6e 	breq	80003d9c <xg_flashc_init+0xc8>
80003ec4:	c0 78       	rjmp	80003ed2 <xg_flashc_init+0x1fe>
							log("\r\n----message storage is err!!!----\r\n");
							goto ERASE;
						}
					}
				}
				log("\r\n----xoxo read message info okay!----\r\n");
80003ec6:	49 fc       	lddpc	r12,80003f40 <xg_flashc_init+0x26c>
80003ec8:	f0 1f 00 07 	mcall	80003ee4 <xg_flashc_init+0x210>
			else
				return FALSE;
			
		}
				
		list_init_success_flag = 1;
80003ecc:	30 19       	mov	r9,1
80003ece:	49 e8       	lddpc	r8,80003f44 <xg_flashc_init+0x270>
80003ed0:	b0 89       	st.b	r8[0x0],r9
	
	//flashc_lock_all_regions(false);
	xgflash_list_info_init();
	//create_xg_flash_test_task();

}
80003ed2:	2f dd       	sub	sp,-12
80003ed4:	d8 32       	popm	r0-r7,pc
80003ed6:	00 00       	add	r0,r0
80003ed8:	80 00       	ld.sh	r0,r0[0x0]
80003eda:	4f d4       	lddpc	r4,800040cc <INTC_init_interrupts+0x38>
80003edc:	00 00       	add	r0,r0
80003ede:	0a 64       	and	r4,r5
80003ee0:	80 00       	ld.sh	r0,r0[0x0]
80003ee2:	c2 5c       	rcall	80003f2c <xg_flashc_init+0x258>
80003ee4:	80 00       	ld.sh	r0,r0[0x0]
80003ee6:	5b 0c       	cp.w	r12,-16
80003ee8:	80 00       	ld.sh	r0,r0[0x0]
80003eea:	50 2c       	stdsp	sp[0x8],r12
80003eec:	00 00       	add	r0,r0
80003eee:	1f 8c       	ld.ub	r12,pc[0x0]
80003ef0:	80 00       	ld.sh	r0,r0[0x0]
80003ef2:	4e d4       	lddpc	r4,800040a4 <INTC_init_interrupts+0x10>
80003ef4:	00 00       	add	r0,r0
80003ef6:	0a 5c       	eor	r12,r5
80003ef8:	00 00       	add	r0,r0
80003efa:	0a 68       	and	r8,r5
80003efc:	00 00       	add	r0,r0
80003efe:	0c ea       	st.h	--r6,r10
80003f00:	80 00       	ld.sh	r0,r0[0x0]
80003f02:	31 bc       	mov	r12,27
80003f04:	80 00       	ld.sh	r0,r0[0x0]
80003f06:	2e ec       	sub	r12,-18
80003f08:	00 00       	add	r0,r0
80003f0a:	0a 70       	tst	r0,r5
80003f0c:	80 00       	ld.sh	r0,r0[0x0]
80003f0e:	2b c4       	sub	r4,-68
80003f10:	00 00       	add	r0,r0
80003f12:	05 04       	ld.w	r4,r2++
80003f14:	80 00       	ld.sh	r0,r0[0x0]
80003f16:	62 00       	ld.w	r0,r1[0x0]
80003f18:	80 00       	ld.sh	r0,r0[0x0]
80003f1a:	2d fc       	sub	r12,-33
80003f1c:	80 00       	ld.sh	r0,r0[0x0]
80003f1e:	63 6e       	ld.w	lr,r1[0x58]
80003f20:	00 00       	add	r0,r0
80003f22:	0a 6c       	and	r12,r5
80003f24:	80 00       	ld.sh	r0,r0[0x0]
80003f26:	c2 88       	rjmp	80003f76 <gpio_enable_module_pin+0x20>
80003f28:	80 00       	ld.sh	r0,r0[0x0]
80003f2a:	c2 b4       	brge	80003f80 <gpio_enable_module_pin+0x2a>
80003f2c:	00 00       	add	r0,r0
80003f2e:	05 0c       	ld.w	r12,r2++
80003f30:	80 00       	ld.sh	r0,r0[0x0]
80003f32:	c2 c0       	breq	80003f8a <gpio_enable_module_pin+0x34>
80003f34:	80 00       	ld.sh	r0,r0[0x0]
80003f36:	c2 e4       	brge	80003f92 <gpio_enable_module_pin+0x3c>
80003f38:	80 00       	ld.sh	r0,r0[0x0]
80003f3a:	2d 5c       	sub	r12,-43
80003f3c:	80 00       	ld.sh	r0,r0[0x0]
80003f3e:	c3 0c       	rcall	80003f9e <gpio_enable_module_pin+0x48>
80003f40:	80 00       	ld.sh	r0,r0[0x0]
80003f42:	c3 34       	brge	80003fa8 <gpio_enable_module>
80003f44:	00 00       	add	r0,r0
80003f46:	0a 60       	and	r0,r5

80003f48 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
80003f48:	fe 68 14 00 	mov	r8,-125952
80003f4c:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
80003f4e:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80003f52:	91 09       	st.w	r8[0x0],r9
}
80003f54:	5e fc       	retal	r12

80003f56 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80003f56:	f8 08 16 05 	lsr	r8,r12,0x5
80003f5a:	a9 68       	lsl	r8,0x8
80003f5c:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80003f60:	58 1b       	cp.w	r11,1
80003f62:	c0 d0       	breq	80003f7c <gpio_enable_module_pin+0x26>
80003f64:	c0 63       	brcs	80003f70 <gpio_enable_module_pin+0x1a>
80003f66:	58 2b       	cp.w	r11,2
80003f68:	c1 00       	breq	80003f88 <gpio_enable_module_pin+0x32>
80003f6a:	58 3b       	cp.w	r11,3
80003f6c:	c1 40       	breq	80003f94 <gpio_enable_module_pin+0x3e>
80003f6e:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80003f70:	30 19       	mov	r9,1
80003f72:	f2 0c 09 49 	lsl	r9,r9,r12
80003f76:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80003f78:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80003f7a:	c1 28       	rjmp	80003f9e <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80003f7c:	30 19       	mov	r9,1
80003f7e:	f2 0c 09 49 	lsl	r9,r9,r12
80003f82:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80003f84:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80003f86:	c0 c8       	rjmp	80003f9e <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80003f88:	30 19       	mov	r9,1
80003f8a:	f2 0c 09 49 	lsl	r9,r9,r12
80003f8e:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80003f90:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80003f92:	c0 68       	rjmp	80003f9e <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80003f94:	30 19       	mov	r9,1
80003f96:	f2 0c 09 49 	lsl	r9,r9,r12
80003f9a:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80003f9c:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80003f9e:	30 19       	mov	r9,1
80003fa0:	f2 0c 09 4c 	lsl	r12,r9,r12
80003fa4:	91 2c       	st.w	r8[0x8],r12
80003fa6:	5e fd       	retal	0

80003fa8 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80003fa8:	d4 21       	pushm	r4-r7,lr
80003faa:	18 97       	mov	r7,r12
80003fac:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80003fae:	58 0b       	cp.w	r11,0
80003fb0:	c0 31       	brne	80003fb6 <gpio_enable_module+0xe>
80003fb2:	30 05       	mov	r5,0
80003fb4:	c0 d8       	rjmp	80003fce <gpio_enable_module+0x26>
80003fb6:	30 06       	mov	r6,0
80003fb8:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80003fba:	6e 1b       	ld.w	r11,r7[0x4]
80003fbc:	6e 0c       	ld.w	r12,r7[0x0]
80003fbe:	f0 1f 00 06 	mcall	80003fd4 <gpio_enable_module+0x2c>
80003fc2:	18 45       	or	r5,r12
		gpiomap++;
80003fc4:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80003fc6:	2f f6       	sub	r6,-1
80003fc8:	0c 34       	cp.w	r4,r6
80003fca:	fe 9b ff f8 	brhi	80003fba <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80003fce:	0a 9c       	mov	r12,r5
80003fd0:	d8 22       	popm	r4-r7,pc
80003fd2:	00 00       	add	r0,r0
80003fd4:	80 00       	ld.sh	r0,r0[0x0]
80003fd6:	3f 56       	mov	r6,-11

80003fd8 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80003fd8:	f8 08 16 05 	lsr	r8,r12,0x5
80003fdc:	a9 68       	lsl	r8,0x8
80003fde:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80003fe2:	30 19       	mov	r9,1
80003fe4:	f2 0c 09 4c 	lsl	r12,r9,r12
80003fe8:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80003fec:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80003ff0:	91 1c       	st.w	r8[0x4],r12
}
80003ff2:	5e fc       	retal	r12

80003ff4 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80003ff4:	f8 08 16 05 	lsr	r8,r12,0x5
80003ff8:	a9 68       	lsl	r8,0x8
80003ffa:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80003ffe:	30 19       	mov	r9,1
80004000:	f2 0c 09 4c 	lsl	r12,r9,r12
80004004:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80004008:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000400c:	91 1c       	st.w	r8[0x4],r12
}
8000400e:	5e fc       	retal	r12

80004010 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80004010:	c0 08       	rjmp	80004010 <_unhandled_interrupt>
80004012:	d7 03       	nop

80004014 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80004014:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004018:	49 99       	lddpc	r9,8000407c <INTC_register_interrupt+0x68>
8000401a:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000401e:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80004022:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80004024:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004028:	58 0a       	cp.w	r10,0
8000402a:	c0 91       	brne	8000403c <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000402c:	49 59       	lddpc	r9,80004080 <INTC_register_interrupt+0x6c>
8000402e:	49 6a       	lddpc	r10,80004084 <INTC_register_interrupt+0x70>
80004030:	12 1a       	sub	r10,r9
80004032:	fe 79 08 00 	mov	r9,-63488
80004036:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000403a:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
8000403c:	58 1a       	cp.w	r10,1
8000403e:	c0 a1       	brne	80004052 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80004040:	49 09       	lddpc	r9,80004080 <INTC_register_interrupt+0x6c>
80004042:	49 2a       	lddpc	r10,80004088 <INTC_register_interrupt+0x74>
80004044:	12 1a       	sub	r10,r9
80004046:	bf aa       	sbr	r10,0x1e
80004048:	fe 79 08 00 	mov	r9,-63488
8000404c:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004050:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80004052:	58 2a       	cp.w	r10,2
80004054:	c0 a1       	brne	80004068 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80004056:	48 b9       	lddpc	r9,80004080 <INTC_register_interrupt+0x6c>
80004058:	48 da       	lddpc	r10,8000408c <INTC_register_interrupt+0x78>
8000405a:	12 1a       	sub	r10,r9
8000405c:	bf ba       	sbr	r10,0x1f
8000405e:	fe 79 08 00 	mov	r9,-63488
80004062:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004066:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80004068:	48 69       	lddpc	r9,80004080 <INTC_register_interrupt+0x6c>
8000406a:	48 aa       	lddpc	r10,80004090 <INTC_register_interrupt+0x7c>
8000406c:	12 1a       	sub	r10,r9
8000406e:	ea 1a c0 00 	orh	r10,0xc000
80004072:	fe 79 08 00 	mov	r9,-63488
80004076:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000407a:	5e fc       	retal	r12
8000407c:	80 00       	ld.sh	r0,r0[0x0]
8000407e:	c4 40       	breq	80004106 <_get_interrupt_handler+0x1e>
80004080:	80 00       	ld.sh	r0,r0[0x0]
80004082:	b8 00       	st.h	r12[0x0],r0
80004084:	80 00       	ld.sh	r0,r0[0x0]
80004086:	b9 04       	ld.d	r4,r12
80004088:	80 00       	ld.sh	r0,r0[0x0]
8000408a:	b9 12       	ld.d	r2,--r12
8000408c:	80 00       	ld.sh	r0,r0[0x0]
8000408e:	b9 20       	st.d	r12++,r0
80004090:	80 00       	ld.sh	r0,r0[0x0]
80004092:	b9 2e       	st.d	r12++,lr

80004094 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80004094:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004096:	49 18       	lddpc	r8,800040d8 <INTC_init_interrupts+0x44>
80004098:	e3 b8 00 01 	mtsr	0x4,r8
8000409c:	49 0e       	lddpc	lr,800040dc <INTC_init_interrupts+0x48>
8000409e:	30 07       	mov	r7,0
800040a0:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800040a2:	49 0c       	lddpc	r12,800040e0 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800040a4:	49 05       	lddpc	r5,800040e4 <INTC_init_interrupts+0x50>
800040a6:	10 15       	sub	r5,r8
800040a8:	fe 76 08 00 	mov	r6,-63488
800040ac:	c1 08       	rjmp	800040cc <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800040ae:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800040b0:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800040b2:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800040b4:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800040b8:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800040ba:	10 3a       	cp.w	r10,r8
800040bc:	fe 9b ff fc 	brhi	800040b4 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800040c0:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800040c4:	2f f7       	sub	r7,-1
800040c6:	2f 8e       	sub	lr,-8
800040c8:	59 37       	cp.w	r7,19
800040ca:	c0 50       	breq	800040d4 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800040cc:	7c 08       	ld.w	r8,lr[0x0]
800040ce:	58 08       	cp.w	r8,0
800040d0:	ce f1       	brne	800040ae <INTC_init_interrupts+0x1a>
800040d2:	cf 7b       	rjmp	800040c0 <INTC_init_interrupts+0x2c>
800040d4:	d8 22       	popm	r4-r7,pc
800040d6:	00 00       	add	r0,r0
800040d8:	80 00       	ld.sh	r0,r0[0x0]
800040da:	b8 00       	st.h	r12[0x0],r0
800040dc:	80 00       	ld.sh	r0,r0[0x0]
800040de:	c4 40       	breq	80004166 <pm_enable_osc0_crystal+0x3a>
800040e0:	80 00       	ld.sh	r0,r0[0x0]
800040e2:	40 10       	lddsp	r0,sp[0x4]
800040e4:	80 00       	ld.sh	r0,r0[0x0]
800040e6:	b9 04       	ld.d	r4,r12

800040e8 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800040e8:	fe 78 08 00 	mov	r8,-63488
800040ec:	e0 69 00 83 	mov	r9,131
800040f0:	f2 0c 01 0c 	sub	r12,r9,r12
800040f4:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800040f8:	f2 ca ff c0 	sub	r10,r9,-64
800040fc:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80004100:	58 08       	cp.w	r8,0
80004102:	c0 21       	brne	80004106 <_get_interrupt_handler+0x1e>
80004104:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004106:	f0 08 12 00 	clz	r8,r8
8000410a:	48 5a       	lddpc	r10,8000411c <_get_interrupt_handler+0x34>
8000410c:	f4 09 00 39 	add	r9,r10,r9<<0x3
80004110:	f0 08 11 1f 	rsub	r8,r8,31
80004114:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80004116:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000411a:	5e fc       	retal	r12
8000411c:	80 00       	ld.sh	r0,r0[0x0]
8000411e:	c4 40       	breq	800041a6 <pm_set_osc32_mode+0x6>

80004120 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80004120:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
80004122:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80004126:	99 a8       	st.w	r12[0x28],r8
}
80004128:	5e fc       	retal	r12
8000412a:	d7 03       	nop

8000412c <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
8000412c:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
8000412e:	ec 5b bb 9f 	cp.w	r11,899999
80004132:	e0 8b 00 04 	brhi	8000413a <pm_enable_osc0_crystal+0xe>
80004136:	30 4b       	mov	r11,4
80004138:	c1 38       	rjmp	8000415e <pm_enable_osc0_crystal+0x32>
8000413a:	e0 68 c6 bf 	mov	r8,50879
8000413e:	ea 18 00 2d 	orh	r8,0x2d
80004142:	10 3b       	cp.w	r11,r8
80004144:	e0 8b 00 04 	brhi	8000414c <pm_enable_osc0_crystal+0x20>
80004148:	30 5b       	mov	r11,5
8000414a:	c0 a8       	rjmp	8000415e <pm_enable_osc0_crystal+0x32>
8000414c:	e0 68 12 00 	mov	r8,4608
80004150:	ea 18 00 7a 	orh	r8,0x7a
80004154:	10 3b       	cp.w	r11,r8
80004156:	f9 bb 03 06 	movlo	r11,6
8000415a:	f9 bb 02 07 	movhs	r11,7
8000415e:	f0 1f 00 02 	mcall	80004164 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80004162:	d8 02       	popm	pc
80004164:	80 00       	ld.sh	r0,r0[0x0]
80004166:	41 20       	lddsp	r0,sp[0x48]

80004168 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80004168:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
8000416a:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000416e:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80004170:	78 08       	ld.w	r8,r12[0x0]
80004172:	a3 a8       	sbr	r8,0x2
80004174:	99 08       	st.w	r12[0x0],r8
}
80004176:	5e fc       	retal	r12

80004178 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80004178:	79 58       	ld.w	r8,r12[0x54]
8000417a:	e2 18 00 80 	andl	r8,0x80,COH
8000417e:	cf d0       	breq	80004178 <pm_wait_for_clk0_ready>
}
80004180:	5e fc       	retal	r12
80004182:	d7 03       	nop

80004184 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80004184:	eb cd 40 80 	pushm	r7,lr
80004188:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
8000418a:	f0 1f 00 04 	mcall	80004198 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
8000418e:	0e 9c       	mov	r12,r7
80004190:	f0 1f 00 03 	mcall	8000419c <pm_enable_clk0+0x18>
}
80004194:	e3 cd 80 80 	ldm	sp++,r7,pc
80004198:	80 00       	ld.sh	r0,r0[0x0]
8000419a:	41 68       	lddsp	r8,sp[0x58]
8000419c:	80 00       	ld.sh	r0,r0[0x0]
8000419e:	41 78       	lddsp	r8,sp[0x5c]

800041a0 <pm_set_osc32_mode>:
 * \param mode 32-kHz oscillator mode (i.e. AVR32_PM_OSCCTRL32_MODE_x).
 */
static void pm_set_osc32_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
800041a0:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.mode = mode;
800041a2:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
800041a6:	99 c8       	st.w	r12[0x30],r8
}
800041a8:	5e fc       	retal	r12
800041aa:	d7 03       	nop

800041ac <pm_enable_osc32_crystal>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
}


void pm_enable_osc32_crystal(volatile avr32_pm_t *pm)
{
800041ac:	d4 01       	pushm	lr
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
800041ae:	30 1b       	mov	r11,1
800041b0:	f0 1f 00 02 	mcall	800041b8 <pm_enable_osc32_crystal+0xc>
}
800041b4:	d8 02       	popm	pc
800041b6:	00 00       	add	r0,r0
800041b8:	80 00       	ld.sh	r0,r0[0x0]
800041ba:	41 a0       	lddsp	r0,sp[0x68]

800041bc <pm_enable_clk32_no_wait>:


void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
800041bc:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.osc32en = 1;
800041be:	30 19       	mov	r9,1
800041c0:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_pm_oscctrl32.OSCCTRL32.startup = startup;
800041c4:	f1 db d2 03 	bfins	r8,r11,0x10,0x3
  // Write back
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
800041c8:	99 c8       	st.w	r12[0x30],r8
}
800041ca:	5e fc       	retal	r12

800041cc <pm_wait_for_clk32_ready>:


void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC32RDY_MASK));
800041cc:	79 58       	ld.w	r8,r12[0x54]
800041ce:	e2 18 02 00 	andl	r8,0x200,COH
800041d2:	cf d0       	breq	800041cc <pm_wait_for_clk32_ready>
}
800041d4:	5e fc       	retal	r12
800041d6:	d7 03       	nop

800041d8 <pm_enable_clk32>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
}


void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup)
{
800041d8:	eb cd 40 80 	pushm	r7,lr
800041dc:	18 97       	mov	r7,r12
  pm_enable_clk32_no_wait(pm, startup);
800041de:	f0 1f 00 04 	mcall	800041ec <pm_enable_clk32+0x14>
  pm_wait_for_clk32_ready(pm);
800041e2:	0e 9c       	mov	r12,r7
800041e4:	f0 1f 00 03 	mcall	800041f0 <pm_enable_clk32+0x18>
}
800041e8:	e3 cd 80 80 	ldm	sp++,r7,pc
800041ec:	80 00       	ld.sh	r0,r0[0x0]
800041ee:	41 bc       	lddsp	r12,sp[0x6c]
800041f0:	80 00       	ld.sh	r0,r0[0x0]
800041f2:	41 cc       	lddsp	r12,sp[0x70]

800041f4 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
800041f4:	eb cd 40 d0 	pushm	r4,r6-r7,lr
800041f8:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
800041fc:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
800041fe:	09 f7       	ld.ub	r7,r4[0x7]
80004200:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
80004204:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
80004208:	09 b4       	ld.ub	r4,r4[0x3]
8000420a:	08 96       	mov	r6,r4
8000420c:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
80004210:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
80004214:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
80004218:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
8000421c:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
80004220:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
80004224:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
80004228:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
8000422c:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
8000422e:	79 58       	ld.w	r8,r12[0x54]
80004230:	e2 18 00 20 	andl	r8,0x20,COH
80004234:	cf d0       	breq	8000422e <pm_cksel+0x3a>
}
80004236:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

8000423a <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
8000423a:	eb cd 40 80 	pushm	r7,lr
8000423e:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
80004240:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
80004242:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
80004246:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
8000424a:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
8000424e:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
80004252:	2f 8b       	sub	r11,-8
80004254:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80004258:	e3 cd 80 80 	ldm	sp++,r7,pc

8000425c <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
8000425c:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
8000425e:	2f 8b       	sub	r11,-8
80004260:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
80004264:	f5 e9 10 19 	or	r9,r10,r9<<0x1
80004268:	f3 e8 10 28 	or	r8,r9,r8<<0x2
8000426c:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
80004270:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80004274:	d8 02       	popm	pc

80004276 <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
80004276:	2f 8b       	sub	r11,-8
80004278:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
8000427c:	a1 a8       	sbr	r8,0x0
8000427e:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
80004282:	5e fc       	retal	r12

80004284 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80004284:	79 58       	ld.w	r8,r12[0x54]
80004286:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000428a:	cf d0       	breq	80004284 <pm_wait_for_pll0_locked>
}
8000428c:	5e fc       	retal	r12

8000428e <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
8000428e:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80004290:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80004294:	99 08       	st.w	r12[0x0],r8
}
80004296:	5e fc       	retal	r12

80004298 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80004298:	eb cd 40 c0 	pushm	r6-r7,lr
8000429c:	18 97       	mov	r7,r12
8000429e:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
800042a0:	f0 1f 00 06 	mcall	800042b8 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
800042a4:	0c 9b       	mov	r11,r6
800042a6:	0e 9c       	mov	r12,r7
800042a8:	f0 1f 00 05 	mcall	800042bc <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
800042ac:	30 1b       	mov	r11,1
800042ae:	0e 9c       	mov	r12,r7
800042b0:	f0 1f 00 04 	mcall	800042c0 <pm_switch_to_osc0+0x28>
}
800042b4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800042b8:	80 00       	ld.sh	r0,r0[0x0]
800042ba:	41 2c       	lddsp	r12,sp[0x48]
800042bc:	80 00       	ld.sh	r0,r0[0x0]
800042be:	41 84       	lddsp	r4,sp[0x60]
800042c0:	80 00       	ld.sh	r0,r0[0x0]
800042c2:	42 8e       	lddsp	lr,sp[0xa0]

800042c4 <rtc_is_busy>:
#include "rtc.h"


int rtc_is_busy(volatile avr32_rtc_t *rtc)
{
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
800042c4:	78 0c       	ld.w	r12,r12[0x0]
}
800042c6:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
800042ca:	5e fc       	retal	r12

800042cc <rtc_set_value>:
  return 1;
}


void rtc_set_value(volatile avr32_rtc_t *rtc, unsigned long val)
{
800042cc:	eb cd 40 c0 	pushm	r6-r7,lr
800042d0:	18 97       	mov	r7,r12
800042d2:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
800042d4:	0e 9c       	mov	r12,r7
800042d6:	f0 1f 00 06 	mcall	800042ec <rtc_set_value+0x20>
800042da:	cf d1       	brne	800042d4 <rtc_set_value+0x8>
  // Set the new val value
  rtc->val = val;
800042dc:	8f 16       	st.w	r7[0x4],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
800042de:	0e 9c       	mov	r12,r7
800042e0:	f0 1f 00 03 	mcall	800042ec <rtc_set_value+0x20>
800042e4:	cf d1       	brne	800042de <rtc_set_value+0x12>
}
800042e6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800042ea:	00 00       	add	r0,r0
800042ec:	80 00       	ld.sh	r0,r0[0x0]
800042ee:	42 c4       	lddsp	r4,sp[0xb0]

800042f0 <rtc_enable>:
  while (rtc_is_busy(rtc));
}


void rtc_enable(volatile avr32_rtc_t *rtc)
{
800042f0:	eb cd 40 80 	pushm	r7,lr
800042f4:	18 97       	mov	r7,r12
  // Wait until the rtc CTRL register is up-to-date
  while (rtc_is_busy(rtc));
800042f6:	0e 9c       	mov	r12,r7
800042f8:	f0 1f 00 06 	mcall	80004310 <rtc_enable+0x20>
800042fc:	cf d1       	brne	800042f6 <rtc_enable+0x6>
  // Enable the RTC
  rtc->ctrl |= AVR32_RTC_CTRL_EN_MASK;
800042fe:	6e 08       	ld.w	r8,r7[0x0]
80004300:	a1 a8       	sbr	r8,0x0
80004302:	8f 08       	st.w	r7[0x0],r8
  // Wait until write is done
  while (rtc_is_busy(rtc));
80004304:	0e 9c       	mov	r12,r7
80004306:	f0 1f 00 03 	mcall	80004310 <rtc_enable+0x20>
8000430a:	cf d1       	brne	80004304 <rtc_enable+0x14>
}
8000430c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004310:	80 00       	ld.sh	r0,r0[0x0]
80004312:	42 c4       	lddsp	r4,sp[0xb0]

80004314 <rtc_enable_interrupt>:
}


void rtc_enable_interrupt(volatile avr32_rtc_t *rtc)
{
  rtc->ier = AVR32_RTC_IER_TOPI_MASK;
80004314:	30 18       	mov	r8,1
80004316:	99 48       	st.w	r12[0x10],r8
}
80004318:	5e fc       	retal	r12
8000431a:	d7 03       	nop

8000431c <rtc_set_top_value>:
  if (global_interrupt_enabled) cpu_irq_enable();
}


void rtc_set_top_value(volatile avr32_rtc_t *rtc, unsigned long top)
{
8000431c:	eb cd 40 c0 	pushm	r6-r7,lr
80004320:	18 97       	mov	r7,r12
80004322:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
80004324:	0e 9c       	mov	r12,r7
80004326:	f0 1f 00 06 	mcall	8000433c <rtc_set_top_value+0x20>
8000432a:	cf d1       	brne	80004324 <rtc_set_top_value+0x8>
  // Set the new val value
  rtc->top = top;
8000432c:	8f 26       	st.w	r7[0x8],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
8000432e:	0e 9c       	mov	r12,r7
80004330:	f0 1f 00 03 	mcall	8000433c <rtc_set_top_value+0x20>
80004334:	cf d1       	brne	8000432e <rtc_set_top_value+0x12>
}
80004336:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000433a:	00 00       	add	r0,r0
8000433c:	80 00       	ld.sh	r0,r0[0x0]
8000433e:	42 c4       	lddsp	r4,sp[0xb0]

80004340 <rtc_clear_interrupt>:
}


void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80004340:	e1 b8 00 00 	mfsr	r8,0x0

  if (global_interrupt_enabled) cpu_irq_disable();
80004344:	e6 18 00 01 	andh	r8,0x1,COH
80004348:	c0 71       	brne	80004356 <rtc_clear_interrupt+0x16>
8000434a:	d3 03       	ssrf	0x10
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
8000434c:	30 18       	mov	r8,1
8000434e:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80004350:	78 78       	ld.w	r8,r12[0x1c]
  if (global_interrupt_enabled) cpu_irq_enable();
80004352:	d5 03       	csrf	0x10
80004354:	5e fc       	retal	r12
void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  if (global_interrupt_enabled) cpu_irq_disable();
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
80004356:	30 18       	mov	r8,1
80004358:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
8000435a:	78 78       	ld.w	r8,r12[0x1c]
8000435c:	5e fc       	retal	r12
8000435e:	d7 03       	nop

80004360 <rtc_init>:
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
}


int rtc_init(volatile avr32_rtc_t *rtc, unsigned char osc_type, unsigned char psel)
{
80004360:	eb cd 40 e0 	pushm	r5-r7,lr
80004364:	18 97       	mov	r7,r12
80004366:	16 96       	mov	r6,r11
80004368:	14 95       	mov	r5,r10
  // If exit, it means that the configuration has not been set correctly
  if (osc_type > (1 << AVR32_RTC_CTRL_CLK32_SIZE) - 1 ||
8000436a:	30 18       	mov	r8,1
8000436c:	f0 0b 18 00 	cp.b	r11,r8
80004370:	5f b9       	srhi	r9
80004372:	30 f8       	mov	r8,15
80004374:	f0 0a 18 00 	cp.b	r10,r8
80004378:	5f b8       	srhi	r8
8000437a:	f3 e8 10 08 	or	r8,r9,r8
8000437e:	c0 30       	breq	80004384 <rtc_init+0x24>
80004380:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
      psel > (1 << AVR32_RTC_CTRL_PSEL_SIZE) - 1)
    return 0;

  // If we use the 32-kHz oscillator, we have to enable it first
  if (osc_type == RTC_OSC_32KHZ)
80004384:	30 18       	mov	r8,1
80004386:	f0 0b 18 00 	cp.b	r11,r8
8000438a:	c0 a1       	brne	8000439e <rtc_init+0x3e>
  {
    // Select the 32-kHz oscillator crystal
    pm_enable_osc32_crystal(&AVR32_PM);
8000438c:	fe 7c 0c 00 	mov	r12,-62464
80004390:	f0 1f 00 0f 	mcall	800043cc <rtc_init+0x6c>
    // Enable the 32-kHz clock and wait until the osc32 clock is ready.
    pm_enable_clk32(&AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC);
80004394:	30 0b       	mov	r11,0
80004396:	fe 7c 0c 00 	mov	r12,-62464
8000439a:	f0 1f 00 0e 	mcall	800043d0 <rtc_init+0x70>
  }

  // Wait until the rtc accepts writes to the CTRL register
  while (rtc_is_busy(rtc));
8000439e:	0e 9c       	mov	r12,r7
800043a0:	f0 1f 00 0d 	mcall	800043d4 <rtc_init+0x74>
800043a4:	cf d1       	brne	8000439e <rtc_init+0x3e>

  // Set the new RTC configuration
  rtc->ctrl = osc_type << AVR32_RTC_CTRL_CLK32_OFFSET |
800043a6:	a3 76       	lsl	r6,0x3
800043a8:	b1 a6       	sbr	r6,0x10
800043aa:	ed e5 10 85 	or	r5,r6,r5<<0x8
800043ae:	8f 05       	st.w	r7[0x0],r5
              psel << AVR32_RTC_CTRL_PSEL_OFFSET |
              AVR32_RTC_CTRL_CLKEN_MASK;

  // Wait until write is done
  while (rtc_is_busy(rtc));
800043b0:	0e 9c       	mov	r12,r7
800043b2:	f0 1f 00 09 	mcall	800043d4 <rtc_init+0x74>
800043b6:	cf d1       	brne	800043b0 <rtc_init+0x50>

  // Set the counter value to 0
  rtc_set_value(rtc, 0x00000000);
800043b8:	30 0b       	mov	r11,0
800043ba:	0e 9c       	mov	r12,r7
800043bc:	f0 1f 00 07 	mcall	800043d8 <rtc_init+0x78>
  // Set the top value to 0xFFFFFFFF
  rtc_set_top_value(rtc, 0xFFFFFFFF);
800043c0:	3f fb       	mov	r11,-1
800043c2:	0e 9c       	mov	r12,r7
800043c4:	f0 1f 00 06 	mcall	800043dc <rtc_init+0x7c>
800043c8:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800043cc:	80 00       	ld.sh	r0,r0[0x0]
800043ce:	41 ac       	lddsp	r12,sp[0x68]
800043d0:	80 00       	ld.sh	r0,r0[0x0]
800043d2:	41 d8       	lddsp	r8,sp[0x74]
800043d4:	80 00       	ld.sh	r0,r0[0x0]
800043d6:	42 c4       	lddsp	r4,sp[0xb0]
800043d8:	80 00       	ld.sh	r0,r0[0x0]
800043da:	42 cc       	lddsp	r12,sp[0xb0]
800043dc:	80 00       	ld.sh	r0,r0[0x0]
800043de:	43 1c       	lddsp	r12,sp[0xc4]

800043e0 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
800043e0:	f8 c8 00 01 	sub	r8,r12,1
800043e4:	f0 0b 00 0b 	add	r11,r8,r11
800043e8:	f6 0c 0d 0a 	divu	r10,r11,r12
800043ec:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
800043ee:	f4 c8 00 01 	sub	r8,r10,1
800043f2:	e0 48 00 fe 	cp.w	r8,254
800043f6:	e0 88 00 03 	brls	800043fc <getBaudDiv+0x1c>
800043fa:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
800043fc:	5c 8c       	casts.h	r12
}
800043fe:	5e fc       	retal	r12

80004400 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80004400:	f7 39 00 0d 	ld.ub	r9,r11[13]
80004404:	30 18       	mov	r8,1
80004406:	f0 09 18 00 	cp.b	r9,r8
8000440a:	e0 88 00 04 	brls	80004412 <spi_initMaster+0x12>
8000440e:	30 2c       	mov	r12,2
80004410:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
80004412:	e0 68 00 80 	mov	r8,128
80004416:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80004418:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
8000441a:	30 19       	mov	r9,1
8000441c:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80004420:	f7 39 00 0d 	ld.ub	r9,r11[13]
80004424:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80004428:	30 09       	mov	r9,0
8000442a:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
8000442e:	30 fa       	mov	r10,15
80004430:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80004434:	99 18       	st.w	r12[0x4],r8
80004436:	5e f9       	retal	r9

80004438 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80004438:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
8000443a:	30 18       	mov	r8,1
8000443c:	f0 0b 18 00 	cp.b	r11,r8
80004440:	5f be       	srhi	lr
80004442:	f0 0a 18 00 	cp.b	r10,r8
80004446:	5f b8       	srhi	r8
80004448:	fd e8 10 08 	or	r8,lr,r8
8000444c:	c0 30       	breq	80004452 <spi_selectionMode+0x1a>
8000444e:	30 2c       	mov	r12,2
80004450:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80004452:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80004454:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80004458:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
8000445c:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80004460:	99 18       	st.w	r12[0x4],r8
80004462:	d8 0a       	popm	pc,r12=0

80004464 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80004464:	30 18       	mov	r8,1
80004466:	99 08       	st.w	r12[0x0],r8
}
80004468:	5e fc       	retal	r12

8000446a <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
8000446a:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000446e:	c0 58       	rjmp	80004478 <spi_write+0xe>
		if (!timeout--) {
80004470:	58 08       	cp.w	r8,0
80004472:	c0 21       	brne	80004476 <spi_write+0xc>
80004474:	5e ff       	retal	1
80004476:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80004478:	78 49       	ld.w	r9,r12[0x10]
8000447a:	e2 19 00 02 	andl	r9,0x2,COH
8000447e:	cf 90       	breq	80004470 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80004480:	5c 7b       	castu.h	r11
80004482:	99 3b       	st.w	r12[0xc],r11
80004484:	5e fd       	retal	0

80004486 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80004486:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
8000448a:	c0 58       	rjmp	80004494 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
8000448c:	58 08       	cp.w	r8,0
8000448e:	c0 21       	brne	80004492 <spi_read+0xc>
80004490:	5e ff       	retal	1
80004492:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80004494:	78 49       	ld.w	r9,r12[0x10]
80004496:	e2 19 02 01 	andl	r9,0x201,COH
8000449a:	e0 49 02 01 	cp.w	r9,513
8000449e:	cf 71       	brne	8000448c <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
800044a0:	78 28       	ld.w	r8,r12[0x8]
800044a2:	b6 08       	st.h	r11[0x0],r8
800044a4:	5e fd       	retal	0
800044a6:	d7 03       	nop

800044a8 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
800044a8:	eb cd 40 f8 	pushm	r3-r7,lr
800044ac:	18 95       	mov	r5,r12
800044ae:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800044b0:	f7 36 00 0c 	ld.ub	r6,r11[12]
800044b4:	30 38       	mov	r8,3
800044b6:	f0 06 18 00 	cp.b	r6,r8
800044ba:	e0 8b 00 5e 	brhi	80004576 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
800044be:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800044c2:	30 18       	mov	r8,1
800044c4:	f0 04 18 00 	cp.b	r4,r8
800044c8:	e0 8b 00 57 	brhi	80004576 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
800044cc:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800044d0:	30 78       	mov	r8,7
800044d2:	f0 03 18 00 	cp.b	r3,r8
800044d6:	e0 88 00 50 	brls	80004576 <spi_setupChipReg+0xce>
800044da:	31 08       	mov	r8,16
800044dc:	f0 03 18 00 	cp.b	r3,r8
800044e0:	e0 8b 00 4b 	brhi	80004576 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
800044e4:	14 9b       	mov	r11,r10
800044e6:	6e 1c       	ld.w	r12,r7[0x4]
800044e8:	f0 1f 00 26 	mcall	80004580 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
800044ec:	c4 55       	brlt	80004576 <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
800044ee:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
800044f0:	ec 09 16 01 	lsr	r9,r6,0x1
800044f4:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800044f8:	ec 16 00 01 	eorl	r6,0x1
800044fc:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80004500:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80004504:	20 83       	sub	r3,8
80004506:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
8000450a:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
8000450e:	ef 39 00 09 	ld.ub	r9,r7[9]
80004512:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80004516:	ef 39 00 0a 	ld.ub	r9,r7[10]
8000451a:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
8000451e:	0f 89       	ld.ub	r9,r7[0x0]
80004520:	30 1a       	mov	r10,1
80004522:	f4 09 18 00 	cp.b	r9,r10
80004526:	c0 d0       	breq	80004540 <spi_setupChipReg+0x98>
80004528:	c0 a3       	brcs	8000453c <spi_setupChipReg+0x94>
8000452a:	30 2a       	mov	r10,2
8000452c:	f4 09 18 00 	cp.b	r9,r10
80004530:	c0 a0       	breq	80004544 <spi_setupChipReg+0x9c>
80004532:	30 3a       	mov	r10,3
80004534:	f4 09 18 00 	cp.b	r9,r10
80004538:	c1 f1       	brne	80004576 <spi_setupChipReg+0xce>
8000453a:	c0 78       	rjmp	80004548 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
8000453c:	8b c8       	st.w	r5[0x30],r8
		break;
8000453e:	c0 68       	rjmp	8000454a <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80004540:	8b d8       	st.w	r5[0x34],r8
		break;
80004542:	c0 48       	rjmp	8000454a <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80004544:	8b e8       	st.w	r5[0x38],r8
		break;
80004546:	c0 28       	rjmp	8000454a <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80004548:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
8000454a:	48 f8       	lddpc	r8,80004584 <spi_setupChipReg+0xdc>
8000454c:	70 08       	ld.w	r8,r8[0x0]
8000454e:	58 08       	cp.w	r8,0
80004550:	c1 61       	brne	8000457c <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
80004552:	30 0b       	mov	r11,0
80004554:	30 1c       	mov	r12,1
80004556:	f0 1f 00 0d 	mcall	80004588 <spi_setupChipReg+0xe0>
8000455a:	48 b8       	lddpc	r8,80004584 <spi_setupChipReg+0xdc>
8000455c:	91 0c       	st.w	r8[0x0],r12
8000455e:	58 0c       	cp.w	r12,0
80004560:	c0 a0       	breq	80004574 <spi_setupChipReg+0xcc>
80004562:	30 09       	mov	r9,0
80004564:	12 9a       	mov	r10,r9
80004566:	12 9b       	mov	r11,r9
80004568:	f0 1f 00 09 	mcall	8000458c <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
8000456c:	48 68       	lddpc	r8,80004584 <spi_setupChipReg+0xdc>
8000456e:	70 08       	ld.w	r8,r8[0x0]
80004570:	58 08       	cp.w	r8,0
80004572:	c0 51       	brne	8000457c <spi_setupChipReg+0xd4>
80004574:	c0 08       	rjmp	80004574 <spi_setupChipReg+0xcc>
80004576:	30 2c       	mov	r12,2
80004578:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000457c:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80004580:	80 00       	ld.sh	r0,r0[0x0]
80004582:	43 e0       	lddsp	r0,sp[0xf8]
80004584:	00 00       	add	r0,r0
80004586:	1f 94       	ld.ub	r4,pc[0x1]
80004588:	80 00       	ld.sh	r0,r0[0x0]
8000458a:	50 2c       	stdsp	sp[0x8],r12
8000458c:	80 00       	ld.sh	r0,r0[0x0]
8000458e:	4e d4       	lddpc	r4,80004740 <usart_write_line+0xc>

80004590 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80004590:	d4 01       	pushm	lr
80004592:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80004596:	c0 58       	rjmp	800045a0 <spi_unselectChip+0x10>
		if (!timeout--) {
80004598:	58 08       	cp.w	r8,0
8000459a:	c0 21       	brne	8000459e <spi_unselectChip+0xe>
8000459c:	da 0a       	popm	pc,r12=1
8000459e:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800045a0:	78 49       	ld.w	r9,r12[0x10]
800045a2:	e2 19 02 00 	andl	r9,0x200,COH
800045a6:	cf 90       	breq	80004598 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800045a8:	78 18       	ld.w	r8,r12[0x4]
800045aa:	ea 18 00 0f 	orh	r8,0xf
800045ae:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
800045b0:	fc 18 01 00 	movh	r8,0x100
800045b4:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
800045b6:	30 09       	mov	r9,0
800045b8:	12 9a       	mov	r10,r9
800045ba:	12 9b       	mov	r11,r9
800045bc:	48 38       	lddpc	r8,800045c8 <spi_unselectChip+0x38>
800045be:	70 0c       	ld.w	r12,r8[0x0]
800045c0:	f0 1f 00 03 	mcall	800045cc <spi_unselectChip+0x3c>
800045c4:	d8 0a       	popm	pc,r12=0
800045c6:	00 00       	add	r0,r0
800045c8:	00 00       	add	r0,r0
800045ca:	1f 94       	ld.ub	r4,pc[0x1]
800045cc:	80 00       	ld.sh	r0,r0[0x0]
800045ce:	4e d4       	lddpc	r4,80004780 <usart_reset+0x28>

800045d0 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800045d0:	eb cd 40 f8 	pushm	r3-r7,lr
800045d4:	18 94       	mov	r4,r12
800045d6:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
800045d8:	49 a6       	lddpc	r6,80004640 <spi_selectChip+0x70>
800045da:	30 07       	mov	r7,0
800045dc:	31 45       	mov	r5,20
800045de:	0e 99       	mov	r9,r7
800045e0:	0a 9a       	mov	r10,r5
800045e2:	0e 9b       	mov	r11,r7
800045e4:	6c 0c       	ld.w	r12,r6[0x0]
800045e6:	f0 1f 00 18 	mcall	80004644 <spi_selectChip+0x74>
800045ea:	cf a0       	breq	800045de <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800045ec:	68 18       	ld.w	r8,r4[0x4]
800045ee:	ea 18 00 0f 	orh	r8,0xf
800045f2:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
800045f4:	68 18       	ld.w	r8,r4[0x4]
800045f6:	e2 18 00 04 	andl	r8,0x4,COH
800045fa:	c1 10       	breq	8000461c <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
800045fc:	30 e8       	mov	r8,14
800045fe:	f0 03 18 00 	cp.b	r3,r8
80004602:	e0 8b 00 1c 	brhi	8000463a <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80004606:	68 19       	ld.w	r9,r4[0x4]
80004608:	e6 08 15 10 	lsl	r8,r3,0x10
8000460c:	ea 18 ff f0 	orh	r8,0xfff0
80004610:	e8 18 ff ff 	orl	r8,0xffff
80004614:	12 68       	and	r8,r9
80004616:	89 18       	st.w	r4[0x4],r8
80004618:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
8000461c:	30 38       	mov	r8,3
8000461e:	f0 03 18 00 	cp.b	r3,r8
80004622:	e0 8b 00 0c 	brhi	8000463a <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80004626:	68 19       	ld.w	r9,r4[0x4]
80004628:	2f 03       	sub	r3,-16
8000462a:	30 18       	mov	r8,1
8000462c:	f0 03 09 48 	lsl	r8,r8,r3
80004630:	5c d8       	com	r8
80004632:	12 68       	and	r8,r9
80004634:	89 18       	st.w	r4[0x4],r8
80004636:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
8000463a:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
8000463c:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004640:	00 00       	add	r0,r0
80004642:	1f 94       	ld.ub	r4,pc[0x1]
80004644:	80 00       	ld.sh	r0,r0[0x0]
80004646:	4d 18       	lddpc	r8,80004788 <usart_init_rs232+0x4>

80004648 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80004648:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
8000464a:	f6 08 15 04 	lsl	r8,r11,0x4
8000464e:	14 38       	cp.w	r8,r10
80004650:	f9 b8 08 10 	movls	r8,16
80004654:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80004658:	f0 0b 02 4b 	mul	r11,r8,r11
8000465c:	f6 09 16 01 	lsr	r9,r11,0x1
80004660:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80004664:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80004668:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
8000466c:	f2 cb 00 01 	sub	r11,r9,1
80004670:	e0 4b ff fe 	cp.w	r11,65534
80004674:	e0 88 00 03 	brls	8000467a <usart_set_async_baudrate+0x32>
80004678:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
8000467a:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
8000467c:	e8 6e 00 00 	mov	lr,524288
80004680:	59 08       	cp.w	r8,16
80004682:	fc 08 17 10 	movne	r8,lr
80004686:	f9 b8 00 00 	moveq	r8,0
8000468a:	e4 1b ff f7 	andh	r11,0xfff7
8000468e:	e0 1b fe cf 	andl	r11,0xfecf
80004692:	16 48       	or	r8,r11
80004694:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80004696:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
8000469a:	f3 ea 11 09 	or	r9,r9,r10<<0x10
8000469e:	99 89       	st.w	r12[0x20],r9
800046a0:	d8 0a       	popm	pc,r12=0

800046a2 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
800046a2:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
800046a4:	e2 18 00 02 	andl	r8,0x2,COH
800046a8:	c0 31       	brne	800046ae <usart_write_char+0xc>
800046aa:	30 2c       	mov	r12,2
800046ac:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
800046ae:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
800046b2:	99 7b       	st.w	r12[0x1c],r11
800046b4:	5e fd       	retal	0
800046b6:	d7 03       	nop

800046b8 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
800046b8:	eb cd 40 e0 	pushm	r5-r7,lr
800046bc:	18 96       	mov	r6,r12
800046be:	16 95       	mov	r5,r11
800046c0:	e0 67 27 0f 	mov	r7,9999
800046c4:	c0 68       	rjmp	800046d0 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
800046c6:	58 07       	cp.w	r7,0
800046c8:	c0 31       	brne	800046ce <usart_putchar+0x16>
800046ca:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
800046ce:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
800046d0:	0a 9b       	mov	r11,r5
800046d2:	0c 9c       	mov	r12,r6
800046d4:	f0 1f 00 03 	mcall	800046e0 <usart_putchar+0x28>
800046d8:	cf 71       	brne	800046c6 <usart_putchar+0xe>

  return USART_SUCCESS;
}
800046da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800046de:	00 00       	add	r0,r0
800046e0:	80 00       	ld.sh	r0,r0[0x0]
800046e2:	46 a2       	lddsp	r2,sp[0x1a8]

800046e4 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
800046e4:	78 58       	ld.w	r8,r12[0x14]
800046e6:	e2 18 00 e0 	andl	r8,0xe0,COH
800046ea:	c0 30       	breq	800046f0 <usart_read_char+0xc>
800046ec:	30 4c       	mov	r12,4
800046ee:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
800046f0:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
800046f2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800046f6:	c0 31       	brne	800046fc <usart_read_char+0x18>
800046f8:	30 3c       	mov	r12,3
800046fa:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
800046fc:	78 68       	ld.w	r8,r12[0x18]
800046fe:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80004702:	97 08       	st.w	r11[0x0],r8
80004704:	5e fd       	retal	0
80004706:	d7 03       	nop

80004708 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80004708:	eb cd 40 c0 	pushm	r6-r7,lr
8000470c:	20 1d       	sub	sp,4
8000470e:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80004710:	1a 97       	mov	r7,sp
80004712:	1a 9b       	mov	r11,sp
80004714:	0c 9c       	mov	r12,r6
80004716:	f0 1f 00 07 	mcall	80004730 <usart_getchar+0x28>
8000471a:	58 3c       	cp.w	r12,3
8000471c:	cf b0       	breq	80004712 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
8000471e:	58 4c       	cp.w	r12,4
80004720:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80004724:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80004728:	2f fd       	sub	sp,-4
8000472a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000472e:	00 00       	add	r0,r0
80004730:	80 00       	ld.sh	r0,r0[0x0]
80004732:	46 e4       	lddsp	r4,sp[0x1b8]

80004734 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80004734:	eb cd 40 c0 	pushm	r6-r7,lr
80004738:	18 96       	mov	r6,r12
8000473a:	16 97       	mov	r7,r11
  while (*string != '\0')
8000473c:	17 8b       	ld.ub	r11,r11[0x0]
8000473e:	58 0b       	cp.w	r11,0
80004740:	c0 80       	breq	80004750 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80004742:	2f f7       	sub	r7,-1
80004744:	0c 9c       	mov	r12,r6
80004746:	f0 1f 00 04 	mcall	80004754 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
8000474a:	0f 8b       	ld.ub	r11,r7[0x0]
8000474c:	58 0b       	cp.w	r11,0
8000474e:	cf a1       	brne	80004742 <usart_write_line+0xe>
80004750:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004754:	80 00       	ld.sh	r0,r0[0x0]
80004756:	46 b8       	lddsp	r8,sp[0x1ac]

80004758 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80004758:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
8000475c:	e6 18 00 01 	andh	r8,0x1,COH
80004760:	c0 71       	brne	8000476e <usart_reset+0x16>
80004762:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80004764:	3f f8       	mov	r8,-1
80004766:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004768:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
8000476a:	d5 03       	csrf	0x10
8000476c:	c0 48       	rjmp	80004774 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
8000476e:	3f f8       	mov	r8,-1
80004770:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004772:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80004774:	30 08       	mov	r8,0
80004776:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80004778:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
8000477a:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
8000477c:	ea 68 61 0c 	mov	r8,680204
80004780:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80004782:	5e fc       	retal	r12

80004784 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80004784:	eb cd 40 e0 	pushm	r5-r7,lr
80004788:	18 96       	mov	r6,r12
8000478a:	16 97       	mov	r7,r11
8000478c:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
8000478e:	f0 1f 00 2f 	mcall	80004848 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80004792:	58 07       	cp.w	r7,0
80004794:	c5 80       	breq	80004844 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80004796:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004798:	30 49       	mov	r9,4
8000479a:	f2 08 18 00 	cp.b	r8,r9
8000479e:	e0 88 00 53 	brls	80004844 <usart_init_rs232+0xc0>
800047a2:	30 99       	mov	r9,9
800047a4:	f2 08 18 00 	cp.b	r8,r9
800047a8:	e0 8b 00 4e 	brhi	80004844 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
800047ac:	0f d9       	ld.ub	r9,r7[0x5]
800047ae:	30 78       	mov	r8,7
800047b0:	f0 09 18 00 	cp.b	r9,r8
800047b4:	e0 8b 00 48 	brhi	80004844 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
800047b8:	8e 39       	ld.sh	r9,r7[0x6]
800047ba:	e0 68 01 01 	mov	r8,257
800047be:	f0 09 19 00 	cp.h	r9,r8
800047c2:	e0 8b 00 41 	brhi	80004844 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
800047c6:	ef 39 00 08 	ld.ub	r9,r7[8]
800047ca:	30 38       	mov	r8,3
800047cc:	f0 09 18 00 	cp.b	r9,r8
800047d0:	e0 8b 00 3a 	brhi	80004844 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
800047d4:	0a 9a       	mov	r10,r5
800047d6:	6e 0b       	ld.w	r11,r7[0x0]
800047d8:	0c 9c       	mov	r12,r6
800047da:	f0 1f 00 1d 	mcall	8000484c <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800047de:	58 1c       	cp.w	r12,1
800047e0:	c3 20       	breq	80004844 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
800047e2:	0f c8       	ld.ub	r8,r7[0x4]
800047e4:	30 99       	mov	r9,9
800047e6:	f2 08 18 00 	cp.b	r8,r9
800047ea:	c0 51       	brne	800047f4 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
800047ec:	6c 18       	ld.w	r8,r6[0x4]
800047ee:	b1 b8       	sbr	r8,0x11
800047f0:	8d 18       	st.w	r6[0x4],r8
800047f2:	c0 68       	rjmp	800047fe <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
800047f4:	6c 19       	ld.w	r9,r6[0x4]
800047f6:	20 58       	sub	r8,5
800047f8:	f3 e8 10 68 	or	r8,r9,r8<<0x6
800047fc:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800047fe:	6c 19       	ld.w	r9,r6[0x4]
80004800:	ef 3a 00 08 	ld.ub	r10,r7[8]
80004804:	0f d8       	ld.ub	r8,r7[0x5]
80004806:	a9 78       	lsl	r8,0x9
80004808:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
8000480c:	12 48       	or	r8,r9
8000480e:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80004810:	8e 38       	ld.sh	r8,r7[0x6]
80004812:	30 29       	mov	r9,2
80004814:	f2 08 19 00 	cp.h	r8,r9
80004818:	e0 88 00 09 	brls	8000482a <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
8000481c:	6c 18       	ld.w	r8,r6[0x4]
8000481e:	ad b8       	sbr	r8,0xd
80004820:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80004822:	8e b8       	ld.uh	r8,r7[0x6]
80004824:	20 28       	sub	r8,2
80004826:	8d a8       	st.w	r6[0x28],r8
80004828:	c0 68       	rjmp	80004834 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
8000482a:	6c 19       	ld.w	r9,r6[0x4]
8000482c:	5c 78       	castu.h	r8
8000482e:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80004832:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80004834:	6c 18       	ld.w	r8,r6[0x4]
80004836:	e0 18 ff f0 	andl	r8,0xfff0
8000483a:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
8000483c:	35 08       	mov	r8,80
8000483e:	8d 08       	st.w	r6[0x0],r8
80004840:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80004844:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80004848:	80 00       	ld.sh	r0,r0[0x0]
8000484a:	47 58       	lddsp	r8,sp[0x1d4]
8000484c:	80 00       	ld.sh	r0,r0[0x0]
8000484e:	46 48       	lddsp	r8,sp[0x190]

80004850 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80004850:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80004854:	fe c0 90 54 	sub	r0,pc,-28588

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80004858:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
8000485c:	d5 53       	csrf	0x15
  cp      r0, r1
8000485e:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80004860:	e0 61 0a 20 	mov	r1,2592
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80004864:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80004866:	c0 62       	brcc	80004872 <idata_load_loop_end>
  cp      r0, r1
80004868:	48 92       	lddpc	r2,8000488c <udata_clear_loop_end+0x4>

8000486a <idata_load_loop>:
  brlo    idata_load_loop
8000486a:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
8000486c:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
8000486e:	02 30       	cp.w	r0,r1
  cp      r0, r1
80004870:	cf d3       	brcs	8000486a <idata_load_loop>

80004872 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80004872:	e0 60 0a 20 	mov	r0,2592
  mov     r2, 0
  mov     r3, 0
80004876:	e0 61 1f a8 	mov	r1,8104
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
8000487a:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
8000487c:	c0 62       	brcc	80004888 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
8000487e:	30 02       	mov	r2,0
80004880:	30 03       	mov	r3,0

80004882 <udata_clear_loop>:
80004882:	a1 22       	st.d	r0++,r2
80004884:	02 30       	cp.w	r0,r1
80004886:	cf e3       	brcs	80004882 <udata_clear_loop>

80004888 <udata_clear_loop_end>:
80004888:	fe cf eb 48 	sub	pc,pc,-5304
8000488c:	80 00       	ld.sh	r0,r0[0x0]
8000488e:	cc 20       	breq	80004812 <usart_init_rs232+0x8e>

80004890 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80004890:	f8 c8 ff f8 	sub	r8,r12,-8
80004894:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80004896:	3f f9       	mov	r9,-1
80004898:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
8000489a:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
8000489c:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
8000489e:	30 08       	mov	r8,0
800048a0:	99 08       	st.w	r12[0x0],r8
}
800048a2:	5e fc       	retal	r12

800048a4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
800048a4:	30 08       	mov	r8,0
800048a6:	99 48       	st.w	r12[0x10],r8
}
800048a8:	5e fc       	retal	r12

800048aa <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
800048aa:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
800048ac:	70 19       	ld.w	r9,r8[0x4]
800048ae:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
800048b0:	78 19       	ld.w	r9,r12[0x4]
800048b2:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800048b4:	70 19       	ld.w	r9,r8[0x4]
800048b6:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
800048b8:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
800048ba:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800048bc:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800048be:	78 08       	ld.w	r8,r12[0x0]
800048c0:	2f f8       	sub	r8,-1
800048c2:	99 08       	st.w	r12[0x0],r8
}
800048c4:	5e fc       	retal	r12

800048c6 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
800048c6:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
800048c8:	5b fa       	cp.w	r10,-1
800048ca:	c0 31       	brne	800048d0 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
800048cc:	78 48       	ld.w	r8,r12[0x10]
800048ce:	c0 c8       	rjmp	800048e6 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
800048d0:	f8 c8 ff f8 	sub	r8,r12,-8
800048d4:	70 19       	ld.w	r9,r8[0x4]
800048d6:	72 09       	ld.w	r9,r9[0x0]
800048d8:	12 3a       	cp.w	r10,r9
800048da:	c0 63       	brcs	800048e6 <vListInsert+0x20>
800048dc:	70 18       	ld.w	r8,r8[0x4]
800048de:	70 19       	ld.w	r9,r8[0x4]
800048e0:	72 09       	ld.w	r9,r9[0x0]
800048e2:	12 3a       	cp.w	r10,r9
800048e4:	cf c2       	brcc	800048dc <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
800048e6:	70 19       	ld.w	r9,r8[0x4]
800048e8:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800048ea:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
800048ec:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
800048ee:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800048f0:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800048f2:	78 08       	ld.w	r8,r12[0x0]
800048f4:	2f f8       	sub	r8,-1
800048f6:	99 08       	st.w	r12[0x0],r8
}
800048f8:	5e fc       	retal	r12

800048fa <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
800048fa:	78 18       	ld.w	r8,r12[0x4]
800048fc:	78 29       	ld.w	r9,r12[0x8]
800048fe:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80004900:	78 28       	ld.w	r8,r12[0x8]
80004902:	78 19       	ld.w	r9,r12[0x4]
80004904:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80004906:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80004908:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
8000490a:	18 39       	cp.w	r9,r12
8000490c:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80004910:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80004914:	30 09       	mov	r9,0
80004916:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80004918:	70 09       	ld.w	r9,r8[0x0]
8000491a:	20 19       	sub	r9,1
8000491c:	91 09       	st.w	r8[0x0],r9
}
8000491e:	5e fc       	retal	r12

80004920 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80004920:	e0 68 08 08 	mov	r8,2056
80004924:	ea 18 08 08 	orh	r8,0x808
80004928:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
8000492a:	e0 68 09 09 	mov	r8,2313
8000492e:	ea 18 09 09 	orh	r8,0x909
80004932:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80004934:	e0 68 0a 0a 	mov	r8,2570
80004938:	ea 18 0a 0a 	orh	r8,0xa0a
8000493c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
8000493e:	e0 68 0b 0b 	mov	r8,2827
80004942:	ea 18 0b 0b 	orh	r8,0xb0b
80004946:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80004948:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
8000494a:	e0 68 be ef 	mov	r8,48879
8000494e:	ea 18 de ad 	orh	r8,0xdead
80004952:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80004954:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80004956:	fc 18 00 40 	movh	r8,0x40
8000495a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
8000495c:	e0 68 00 ff 	mov	r8,255
80004960:	ea 18 ff 00 	orh	r8,0xff00
80004964:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80004966:	e0 68 01 01 	mov	r8,257
8000496a:	ea 18 01 01 	orh	r8,0x101
8000496e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80004970:	e0 68 02 02 	mov	r8,514
80004974:	ea 18 02 02 	orh	r8,0x202
80004978:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
8000497a:	e0 68 03 03 	mov	r8,771
8000497e:	ea 18 03 03 	orh	r8,0x303
80004982:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80004984:	e0 68 04 04 	mov	r8,1028
80004988:	ea 18 04 04 	orh	r8,0x404
8000498c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
8000498e:	e0 68 05 05 	mov	r8,1285
80004992:	ea 18 05 05 	orh	r8,0x505
80004996:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80004998:	e0 68 06 06 	mov	r8,1542
8000499c:	ea 18 06 06 	orh	r8,0x606
800049a0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
800049a2:	e0 68 07 07 	mov	r8,1799
800049a6:	ea 18 07 07 	orh	r8,0x707
800049aa:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
800049ac:	30 08       	mov	r8,0
800049ae:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
800049b0:	5e fc       	retal	r12
800049b2:	d7 03       	nop

800049b4 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
800049b4:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
800049b6:	48 38       	lddpc	r8,800049c0 <vPortEnterCritical+0xc>
800049b8:	70 09       	ld.w	r9,r8[0x0]
800049ba:	2f f9       	sub	r9,-1
800049bc:	91 09       	st.w	r8[0x0],r9
}
800049be:	5e fc       	retal	r12
800049c0:	00 00       	add	r0,r0
800049c2:	05 10       	ld.sh	r0,r2++

800049c4 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
800049c4:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
800049c6:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
800049c8:	30 0a       	mov	r10,0
800049ca:	14 9b       	mov	r11,r10
800049cc:	49 2c       	lddpc	r12,80004a14 <xPortStartScheduler+0x50>
800049ce:	f0 1f 00 13 	mcall	80004a18 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
800049d2:	e0 68 5d c0 	mov	r8,24000
800049d6:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
800049da:	30 08       	mov	r8,0
800049dc:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
800049e0:	e0 68 0c 38 	mov	r8,3128
800049e4:	ea 18 00 00 	orh	r8,0x0
800049e8:	70 00       	ld.w	r0,r8[0x0]
800049ea:	60 0d       	ld.w	sp,r0[0x0]
800049ec:	1b 00       	ld.w	r0,sp++
800049ee:	e0 68 05 10 	mov	r8,1296
800049f2:	ea 18 00 00 	orh	r8,0x0
800049f6:	91 00       	st.w	r8[0x0],r0
800049f8:	e3 cd 00 ff 	ldm	sp++,r0-r7
800049fc:	2f ed       	sub	sp,-8
800049fe:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80004a02:	fa f0 ff e0 	ld.w	r0,sp[-32]
80004a06:	e3 b0 00 00 	mtsr	0x0,r0
80004a0a:	fa f0 ff dc 	ld.w	r0,sp[-36]
80004a0e:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80004a12:	d8 0a       	popm	pc,r12=0
80004a14:	80 00       	ld.sh	r0,r0[0x0]
80004a16:	4a e0       	lddpc	r0,80004acc <vPortExitCritical+0xc>
80004a18:	80 00       	ld.sh	r0,r0[0x0]
80004a1a:	40 14       	lddsp	r4,sp[0x4]

80004a1c <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80004a1c:	20 6d       	sub	sp,24
80004a1e:	eb cd 00 ff 	pushm	r0-r7
80004a22:	fa c7 ff c0 	sub	r7,sp,-64
80004a26:	ee f0 ff f8 	ld.w	r0,r7[-8]
80004a2a:	ef 40 ff e0 	st.w	r7[-32],r0
80004a2e:	ee f0 ff fc 	ld.w	r0,r7[-4]
80004a32:	ef 40 ff e4 	st.w	r7[-28],r0
80004a36:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80004a3a:	e0 68 05 10 	mov	r8,1296
80004a3e:	ea 18 00 00 	orh	r8,0x0
80004a42:	70 00       	ld.w	r0,r8[0x0]
80004a44:	1a d0       	st.w	--sp,r0
80004a46:	f0 1f 00 1a 	mcall	80004aac <LABEL_RET_SCALL_263+0x14>
80004a4a:	e0 68 0c 38 	mov	r8,3128
80004a4e:	ea 18 00 00 	orh	r8,0x0
80004a52:	70 00       	ld.w	r0,r8[0x0]
80004a54:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80004a56:	f0 1f 00 17 	mcall	80004ab0 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80004a5a:	e0 68 0c 38 	mov	r8,3128
80004a5e:	ea 18 00 00 	orh	r8,0x0
80004a62:	70 00       	ld.w	r0,r8[0x0]
80004a64:	60 0d       	ld.w	sp,r0[0x0]
80004a66:	1b 00       	ld.w	r0,sp++
80004a68:	e0 68 05 10 	mov	r8,1296
80004a6c:	ea 18 00 00 	orh	r8,0x0
80004a70:	91 00       	st.w	r8[0x0],r0
80004a72:	fa c7 ff d8 	sub	r7,sp,-40
80004a76:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80004a7a:	ee f0 ff e0 	ld.w	r0,r7[-32]
80004a7e:	e0 61 05 10 	mov	r1,1296
80004a82:	ea 11 00 00 	orh	r1,0x0
80004a86:	62 02       	ld.w	r2,r1[0x0]
80004a88:	58 02       	cp.w	r2,0
80004a8a:	c0 70       	breq	80004a98 <LABEL_RET_SCALL_263>
80004a8c:	e4 c2 00 01 	sub	r2,r2,1
80004a90:	83 02       	st.w	r1[0x0],r2
80004a92:	58 02       	cp.w	r2,0
80004a94:	c0 21       	brne	80004a98 <LABEL_RET_SCALL_263>
80004a96:	b1 c0       	cbr	r0,0x10

80004a98 <LABEL_RET_SCALL_263>:
80004a98:	ef 40 ff f8 	st.w	r7[-8],r0
80004a9c:	ee f0 ff e4 	ld.w	r0,r7[-28]
80004aa0:	ef 40 ff fc 	st.w	r7[-4],r0
80004aa4:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004aa8:	2f ad       	sub	sp,-24
80004aaa:	d6 13       	rets
80004aac:	80 00       	ld.sh	r0,r0[0x0]
80004aae:	49 b4       	lddpc	r4,80004b18 <LABEL_INT_SKIP_SAVE_CONTEXT_237+0x10>
80004ab0:	80 00       	ld.sh	r0,r0[0x0]
80004ab2:	50 b0       	stdsp	sp[0x2c],r0

80004ab4 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80004ab4:	e1 b8 00 43 	mfsr	r8,0x10c
80004ab8:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80004abc:	5e fc       	retal	r12
80004abe:	d7 03       	nop

80004ac0 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80004ac0:	48 78       	lddpc	r8,80004adc <vPortExitCritical+0x1c>
80004ac2:	70 08       	ld.w	r8,r8[0x0]
80004ac4:	58 08       	cp.w	r8,0
80004ac6:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80004ac8:	48 58       	lddpc	r8,80004adc <vPortExitCritical+0x1c>
80004aca:	70 09       	ld.w	r9,r8[0x0]
80004acc:	20 19       	sub	r9,1
80004ace:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80004ad0:	70 08       	ld.w	r8,r8[0x0]
80004ad2:	58 08       	cp.w	r8,0
80004ad4:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80004ad6:	d5 03       	csrf	0x10
80004ad8:	5e fc       	retal	r12
80004ada:	00 00       	add	r0,r0
80004adc:	00 00       	add	r0,r0
80004ade:	05 10       	ld.sh	r0,r2++

80004ae0 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80004ae0:	eb cd 00 ff 	pushm	r0-r7
80004ae4:	e0 68 05 10 	mov	r8,1296
80004ae8:	ea 18 00 00 	orh	r8,0x0
80004aec:	70 00       	ld.w	r0,r8[0x0]
80004aee:	1a d0       	st.w	--sp,r0
80004af0:	7a 90       	ld.w	r0,sp[0x24]
80004af2:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004af6:	58 10       	cp.w	r0,1
80004af8:	e0 8b 00 08 	brhi	80004b08 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80004afc:	e0 68 0c 38 	mov	r8,3128
80004b00:	ea 18 00 00 	orh	r8,0x0
80004b04:	70 00       	ld.w	r0,r8[0x0]
80004b06:	81 0d       	st.w	r0[0x0],sp

80004b08 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80004b08:	f0 1f 00 12 	mcall	80004b50 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80004b0c:	f0 1f 00 12 	mcall	80004b54 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80004b10:	f0 1f 00 12 	mcall	80004b58 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80004b14:	f0 1f 00 12 	mcall	80004b5c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80004b18:	7a 90       	ld.w	r0,sp[0x24]
80004b1a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004b1e:	58 10       	cp.w	r0,1
80004b20:	e0 8b 00 0e 	brhi	80004b3c <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80004b24:	f0 1f 00 0c 	mcall	80004b54 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80004b28:	f0 1f 00 0e 	mcall	80004b60 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80004b2c:	f0 1f 00 0c 	mcall	80004b5c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80004b30:	e0 68 0c 38 	mov	r8,3128
80004b34:	ea 18 00 00 	orh	r8,0x0
80004b38:	70 00       	ld.w	r0,r8[0x0]
80004b3a:	60 0d       	ld.w	sp,r0[0x0]

80004b3c <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80004b3c:	1b 00       	ld.w	r0,sp++
80004b3e:	e0 68 05 10 	mov	r8,1296
80004b42:	ea 18 00 00 	orh	r8,0x0
80004b46:	91 00       	st.w	r8[0x0],r0
80004b48:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004b4c:	d6 03       	rete
80004b4e:	00 00       	add	r0,r0
80004b50:	80 00       	ld.sh	r0,r0[0x0]
80004b52:	4a b4       	lddpc	r4,80004bfc <vPortFree+0x4>
80004b54:	80 00       	ld.sh	r0,r0[0x0]
80004b56:	49 b4       	lddpc	r4,80004bc0 <_write+0x4>
80004b58:	80 00       	ld.sh	r0,r0[0x0]
80004b5a:	52 b4       	stdsp	sp[0xac],r4
80004b5c:	80 00       	ld.sh	r0,r0[0x0]
80004b5e:	4a c0       	lddpc	r0,80004c0c <vPortFree+0x14>
80004b60:	80 00       	ld.sh	r0,r0[0x0]
80004b62:	50 b0       	stdsp	sp[0x2c],r0

80004b64 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80004b64:	d4 01       	pushm	lr
	vTaskSuspendAll();
80004b66:	f0 1f 00 02 	mcall	80004b6c <__malloc_lock+0x8>
}
80004b6a:	d8 02       	popm	pc
80004b6c:	80 00       	ld.sh	r0,r0[0x0]
80004b6e:	50 a0       	stdsp	sp[0x28],r0

80004b70 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80004b70:	d4 01       	pushm	lr
	xTaskResumeAll();
80004b72:	f0 1f 00 02 	mcall	80004b78 <__malloc_unlock+0x8>
}
80004b76:	d8 02       	popm	pc
80004b78:	80 00       	ld.sh	r0,r0[0x0]
80004b7a:	54 5c       	stdsp	sp[0x114],r12

80004b7c <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80004b7c:	d4 21       	pushm	r4-r7,lr
80004b7e:	16 95       	mov	r5,r11
80004b80:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80004b82:	58 0c       	cp.w	r12,0
80004b84:	c0 30       	breq	80004b8a <_read+0xe>
80004b86:	3f f7       	mov	r7,-1
80004b88:	c1 48       	rjmp	80004bb0 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80004b8a:	58 0a       	cp.w	r10,0
80004b8c:	e0 89 00 04 	brgt	80004b94 <_read+0x18>
80004b90:	30 07       	mov	r7,0
80004b92:	c0 f8       	rjmp	80004bb0 <_read+0x34>
80004b94:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80004b96:	48 84       	lddpc	r4,80004bb4 <_read+0x38>
80004b98:	68 0c       	ld.w	r12,r4[0x0]
80004b9a:	f0 1f 00 08 	mcall	80004bb8 <_read+0x3c>
    if (c < 0)
80004b9e:	c0 95       	brlt	80004bb0 <_read+0x34>
      break;

    *ptr++ = c;
80004ba0:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80004ba4:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80004ba6:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80004baa:	58 08       	cp.w	r8,0
80004bac:	fe 99 ff f6 	brgt	80004b98 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80004bb0:	0e 9c       	mov	r12,r7
80004bb2:	d8 22       	popm	r4-r7,pc
80004bb4:	00 00       	add	r0,r0
80004bb6:	1f 98       	ld.ub	r8,pc[0x1]
80004bb8:	80 00       	ld.sh	r0,r0[0x0]
80004bba:	47 08       	lddsp	r8,sp[0x1c0]

80004bbc <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80004bbc:	d4 21       	pushm	r4-r7,lr
80004bbe:	16 95       	mov	r5,r11
80004bc0:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80004bc2:	20 1c       	sub	r12,1
80004bc4:	58 2c       	cp.w	r12,2
80004bc6:	e0 8b 00 12 	brhi	80004bea <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80004bca:	58 0a       	cp.w	r10,0
80004bcc:	c0 31       	brne	80004bd2 <_write+0x16>
80004bce:	30 07       	mov	r7,0
80004bd0:	c0 e8       	rjmp	80004bec <_write+0x30>
80004bd2:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80004bd4:	48 74       	lddpc	r4,80004bf0 <_write+0x34>
80004bd6:	68 0c       	ld.w	r12,r4[0x0]
80004bd8:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80004bdc:	f0 1f 00 06 	mcall	80004bf4 <_write+0x38>
80004be0:	c0 55       	brlt	80004bea <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80004be2:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80004be4:	0e 36       	cp.w	r6,r7
80004be6:	cf 81       	brne	80004bd6 <_write+0x1a>
80004be8:	c0 28       	rjmp	80004bec <_write+0x30>
80004bea:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80004bec:	0e 9c       	mov	r12,r7
80004bee:	d8 22       	popm	r4-r7,pc
80004bf0:	00 00       	add	r0,r0
80004bf2:	1f 98       	ld.ub	r8,pc[0x1]
80004bf4:	80 00       	ld.sh	r0,r0[0x0]
80004bf6:	46 b8       	lddsp	r8,sp[0x1ac]

80004bf8 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80004bf8:	eb cd 40 80 	pushm	r7,lr
80004bfc:	18 97       	mov	r7,r12
	if( pv )
80004bfe:	58 0c       	cp.w	r12,0
80004c00:	c0 80       	breq	80004c10 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80004c02:	f0 1f 00 05 	mcall	80004c14 <vPortFree+0x1c>
		{
			free( pv );
80004c06:	0e 9c       	mov	r12,r7
80004c08:	f0 1f 00 04 	mcall	80004c18 <vPortFree+0x20>
		}
		xTaskResumeAll();
80004c0c:	f0 1f 00 04 	mcall	80004c1c <vPortFree+0x24>
80004c10:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c14:	80 00       	ld.sh	r0,r0[0x0]
80004c16:	50 a0       	stdsp	sp[0x28],r0
80004c18:	80 00       	ld.sh	r0,r0[0x0]
80004c1a:	5d a8       	*unknown*
80004c1c:	80 00       	ld.sh	r0,r0[0x0]
80004c1e:	54 5c       	stdsp	sp[0x114],r12

80004c20 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80004c20:	eb cd 40 80 	pushm	r7,lr
80004c24:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80004c26:	f0 1f 00 06 	mcall	80004c3c <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80004c2a:	0e 9c       	mov	r12,r7
80004c2c:	f0 1f 00 05 	mcall	80004c40 <pvPortMalloc+0x20>
80004c30:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80004c32:	f0 1f 00 05 	mcall	80004c44 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80004c36:	0e 9c       	mov	r12,r7
80004c38:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c3c:	80 00       	ld.sh	r0,r0[0x0]
80004c3e:	50 a0       	stdsp	sp[0x28],r0
80004c40:	80 00       	ld.sh	r0,r0[0x0]
80004c42:	5d b8       	*unknown*
80004c44:	80 00       	ld.sh	r0,r0[0x0]
80004c46:	54 5c       	stdsp	sp[0x114],r12

80004c48 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80004c48:	d4 01       	pushm	lr
80004c4a:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80004c4c:	78 09       	ld.w	r9,r12[0x0]
80004c4e:	58 09       	cp.w	r9,0
80004c50:	c1 10       	breq	80004c72 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80004c52:	78 3a       	ld.w	r10,r12[0xc]
80004c54:	79 09       	ld.w	r9,r12[0x40]
80004c56:	f4 09 00 09 	add	r9,r10,r9
80004c5a:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80004c5c:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80004c5e:	14 39       	cp.w	r9,r10
80004c60:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80004c64:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80004c68:	79 0a       	ld.w	r10,r12[0x40]
80004c6a:	78 3b       	ld.w	r11,r12[0xc]
80004c6c:	10 9c       	mov	r12,r8
80004c6e:	f0 1f 00 02 	mcall	80004c74 <prvCopyDataFromQueue+0x2c>
80004c72:	d8 02       	popm	pc
80004c74:	80 00       	ld.sh	r0,r0[0x0]
80004c76:	62 26       	ld.w	r6,r1[0x8]

80004c78 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80004c78:	eb cd 40 c0 	pushm	r6-r7,lr
80004c7c:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80004c7e:	f0 1f 00 23 	mcall	80004d08 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80004c82:	6f 28       	ld.w	r8,r7[0x48]
80004c84:	58 08       	cp.w	r8,0
80004c86:	e0 8a 00 18 	brle	80004cb6 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80004c8a:	6e 98       	ld.w	r8,r7[0x24]
80004c8c:	58 08       	cp.w	r8,0
80004c8e:	c1 40       	breq	80004cb6 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004c90:	ee c6 ff dc 	sub	r6,r7,-36
80004c94:	c0 48       	rjmp	80004c9c <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80004c96:	6e 98       	ld.w	r8,r7[0x24]
80004c98:	58 08       	cp.w	r8,0
80004c9a:	c0 e0       	breq	80004cb6 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004c9c:	0c 9c       	mov	r12,r6
80004c9e:	f0 1f 00 1c 	mcall	80004d0c <prvUnlockQueue+0x94>
80004ca2:	c0 30       	breq	80004ca8 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80004ca4:	f0 1f 00 1b 	mcall	80004d10 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80004ca8:	6f 28       	ld.w	r8,r7[0x48]
80004caa:	20 18       	sub	r8,1
80004cac:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80004cb0:	58 08       	cp.w	r8,0
80004cb2:	fe 99 ff f2 	brgt	80004c96 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80004cb6:	3f f8       	mov	r8,-1
80004cb8:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80004cbc:	f0 1f 00 16 	mcall	80004d14 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80004cc0:	f0 1f 00 12 	mcall	80004d08 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80004cc4:	6f 18       	ld.w	r8,r7[0x44]
80004cc6:	58 08       	cp.w	r8,0
80004cc8:	e0 8a 00 18 	brle	80004cf8 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004ccc:	6e 48       	ld.w	r8,r7[0x10]
80004cce:	58 08       	cp.w	r8,0
80004cd0:	c1 40       	breq	80004cf8 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80004cd2:	ee c6 ff f0 	sub	r6,r7,-16
80004cd6:	c0 48       	rjmp	80004cde <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004cd8:	6e 48       	ld.w	r8,r7[0x10]
80004cda:	58 08       	cp.w	r8,0
80004cdc:	c0 e0       	breq	80004cf8 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80004cde:	0c 9c       	mov	r12,r6
80004ce0:	f0 1f 00 0b 	mcall	80004d0c <prvUnlockQueue+0x94>
80004ce4:	c0 30       	breq	80004cea <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80004ce6:	f0 1f 00 0b 	mcall	80004d10 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80004cea:	6f 18       	ld.w	r8,r7[0x44]
80004cec:	20 18       	sub	r8,1
80004cee:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80004cf2:	58 08       	cp.w	r8,0
80004cf4:	fe 99 ff f2 	brgt	80004cd8 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80004cf8:	3f f8       	mov	r8,-1
80004cfa:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80004cfe:	f0 1f 00 06 	mcall	80004d14 <prvUnlockQueue+0x9c>
}
80004d02:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004d06:	00 00       	add	r0,r0
80004d08:	80 00       	ld.sh	r0,r0[0x0]
80004d0a:	49 b4       	lddpc	r4,80004d74 <xQueueGenericReceive+0x5c>
80004d0c:	80 00       	ld.sh	r0,r0[0x0]
80004d0e:	52 38       	stdsp	sp[0x8c],r8
80004d10:	80 00       	ld.sh	r0,r0[0x0]
80004d12:	51 44       	stdsp	sp[0x50],r4
80004d14:	80 00       	ld.sh	r0,r0[0x0]
80004d16:	4a c0       	lddpc	r0,80004dc4 <xQueueGenericReceive+0xac>

80004d18 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80004d18:	d4 31       	pushm	r0-r7,lr
80004d1a:	20 5d       	sub	sp,20
80004d1c:	18 97       	mov	r7,r12
80004d1e:	50 0b       	stdsp	sp[0x0],r11
80004d20:	50 2a       	stdsp	sp[0x8],r10
80004d22:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80004d24:	f8 c2 ff dc 	sub	r2,r12,-36
80004d28:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80004d2a:	fa c4 ff f4 	sub	r4,sp,-12
80004d2e:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80004d30:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80004d32:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80004d36:	f0 1f 00 3e 	mcall	80004e2c <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80004d3a:	6e e8       	ld.w	r8,r7[0x38]
80004d3c:	58 08       	cp.w	r8,0
80004d3e:	c2 a0       	breq	80004d92 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80004d40:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80004d42:	40 0b       	lddsp	r11,sp[0x0]
80004d44:	0e 9c       	mov	r12,r7
80004d46:	f0 1f 00 3b 	mcall	80004e30 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80004d4a:	40 18       	lddsp	r8,sp[0x4]
80004d4c:	58 08       	cp.w	r8,0
80004d4e:	c1 51       	brne	80004d78 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80004d50:	6e e8       	ld.w	r8,r7[0x38]
80004d52:	20 18       	sub	r8,1
80004d54:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80004d56:	6e 08       	ld.w	r8,r7[0x0]
80004d58:	58 08       	cp.w	r8,0
80004d5a:	c0 41       	brne	80004d62 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80004d5c:	f0 1f 00 36 	mcall	80004e34 <xQueueGenericReceive+0x11c>
80004d60:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004d62:	6e 48       	ld.w	r8,r7[0x10]
80004d64:	58 08       	cp.w	r8,0
80004d66:	c1 20       	breq	80004d8a <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80004d68:	ee cc ff f0 	sub	r12,r7,-16
80004d6c:	f0 1f 00 33 	mcall	80004e38 <xQueueGenericReceive+0x120>
80004d70:	58 1c       	cp.w	r12,1
80004d72:	c0 c1       	brne	80004d8a <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80004d74:	d7 33       	scall
80004d76:	c0 a8       	rjmp	80004d8a <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80004d78:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80004d7a:	6e 98       	ld.w	r8,r7[0x24]
80004d7c:	58 08       	cp.w	r8,0
80004d7e:	c0 60       	breq	80004d8a <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004d80:	04 9c       	mov	r12,r2
80004d82:	f0 1f 00 2e 	mcall	80004e38 <xQueueGenericReceive+0x120>
80004d86:	c0 20       	breq	80004d8a <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80004d88:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80004d8a:	f0 1f 00 2d 	mcall	80004e3c <xQueueGenericReceive+0x124>
80004d8e:	30 1c       	mov	r12,1
				return pdPASS;
80004d90:	c4 c8       	rjmp	80004e28 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80004d92:	40 28       	lddsp	r8,sp[0x8]
80004d94:	58 08       	cp.w	r8,0
80004d96:	c0 51       	brne	80004da0 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80004d98:	f0 1f 00 29 	mcall	80004e3c <xQueueGenericReceive+0x124>
80004d9c:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80004d9e:	c4 58       	rjmp	80004e28 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80004da0:	58 05       	cp.w	r5,0
80004da2:	c0 51       	brne	80004dac <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80004da4:	08 9c       	mov	r12,r4
80004da6:	f0 1f 00 27 	mcall	80004e40 <xQueueGenericReceive+0x128>
80004daa:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80004dac:	f0 1f 00 24 	mcall	80004e3c <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80004db0:	f0 1f 00 25 	mcall	80004e44 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80004db4:	f0 1f 00 1e 	mcall	80004e2c <xQueueGenericReceive+0x114>
80004db8:	6f 18       	ld.w	r8,r7[0x44]
80004dba:	5b f8       	cp.w	r8,-1
80004dbc:	ef f1 0a 11 	st.weq	r7[0x44],r1
80004dc0:	6f 28       	ld.w	r8,r7[0x48]
80004dc2:	5b f8       	cp.w	r8,-1
80004dc4:	ef f1 0a 12 	st.weq	r7[0x48],r1
80004dc8:	f0 1f 00 1d 	mcall	80004e3c <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80004dcc:	06 9b       	mov	r11,r3
80004dce:	08 9c       	mov	r12,r4
80004dd0:	f0 1f 00 1e 	mcall	80004e48 <xQueueGenericReceive+0x130>
80004dd4:	c2 41       	brne	80004e1c <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80004dd6:	f0 1f 00 16 	mcall	80004e2c <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80004dda:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80004ddc:	f0 1f 00 18 	mcall	80004e3c <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80004de0:	58 06       	cp.w	r6,0
80004de2:	c1 71       	brne	80004e10 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80004de4:	6e 08       	ld.w	r8,r7[0x0]
80004de6:	58 08       	cp.w	r8,0
80004de8:	c0 81       	brne	80004df8 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80004dea:	f0 1f 00 11 	mcall	80004e2c <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80004dee:	6e 1c       	ld.w	r12,r7[0x4]
80004df0:	f0 1f 00 17 	mcall	80004e4c <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80004df4:	f0 1f 00 12 	mcall	80004e3c <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80004df8:	40 2b       	lddsp	r11,sp[0x8]
80004dfa:	04 9c       	mov	r12,r2
80004dfc:	f0 1f 00 15 	mcall	80004e50 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80004e00:	0e 9c       	mov	r12,r7
80004e02:	f0 1f 00 15 	mcall	80004e54 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80004e06:	f0 1f 00 15 	mcall	80004e58 <xQueueGenericReceive+0x140>
80004e0a:	c9 61       	brne	80004d36 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80004e0c:	d7 33       	scall
80004e0e:	c9 4b       	rjmp	80004d36 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80004e10:	0e 9c       	mov	r12,r7
80004e12:	f0 1f 00 11 	mcall	80004e54 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80004e16:	f0 1f 00 11 	mcall	80004e58 <xQueueGenericReceive+0x140>
80004e1a:	c8 eb       	rjmp	80004d36 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80004e1c:	0e 9c       	mov	r12,r7
80004e1e:	f0 1f 00 0e 	mcall	80004e54 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80004e22:	f0 1f 00 0e 	mcall	80004e58 <xQueueGenericReceive+0x140>
80004e26:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80004e28:	2f bd       	sub	sp,-20
80004e2a:	d8 32       	popm	r0-r7,pc
80004e2c:	80 00       	ld.sh	r0,r0[0x0]
80004e2e:	49 b4       	lddpc	r4,80004e98 <prvCopyDataToQueue+0x3c>
80004e30:	80 00       	ld.sh	r0,r0[0x0]
80004e32:	4c 48       	lddpc	r8,80004f40 <xQueueGenericSend+0x6c>
80004e34:	80 00       	ld.sh	r0,r0[0x0]
80004e36:	51 50       	stdsp	sp[0x54],r0
80004e38:	80 00       	ld.sh	r0,r0[0x0]
80004e3a:	52 38       	stdsp	sp[0x8c],r8
80004e3c:	80 00       	ld.sh	r0,r0[0x0]
80004e3e:	4a c0       	lddpc	r0,80004eec <xQueueGenericSend+0x18>
80004e40:	80 00       	ld.sh	r0,r0[0x0]
80004e42:	51 2c       	stdsp	sp[0x48],r12
80004e44:	80 00       	ld.sh	r0,r0[0x0]
80004e46:	50 a0       	stdsp	sp[0x28],r0
80004e48:	80 00       	ld.sh	r0,r0[0x0]
80004e4a:	53 c8       	stdsp	sp[0xf0],r8
80004e4c:	80 00       	ld.sh	r0,r0[0x0]
80004e4e:	51 b4       	stdsp	sp[0x6c],r4
80004e50:	80 00       	ld.sh	r0,r0[0x0]
80004e52:	56 68       	stdsp	sp[0x198],r8
80004e54:	80 00       	ld.sh	r0,r0[0x0]
80004e56:	4c 78       	lddpc	r8,80004f70 <xQueueGenericSend+0x9c>
80004e58:	80 00       	ld.sh	r0,r0[0x0]
80004e5a:	54 5c       	stdsp	sp[0x114],r12

80004e5c <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80004e5c:	eb cd 40 80 	pushm	r7,lr
80004e60:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80004e62:	79 08       	ld.w	r8,r12[0x40]
80004e64:	58 08       	cp.w	r8,0
80004e66:	c0 a1       	brne	80004e7a <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80004e68:	78 08       	ld.w	r8,r12[0x0]
80004e6a:	58 08       	cp.w	r8,0
80004e6c:	c2 b1       	brne	80004ec2 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80004e6e:	78 1c       	ld.w	r12,r12[0x4]
80004e70:	f0 1f 00 17 	mcall	80004ecc <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80004e74:	30 08       	mov	r8,0
80004e76:	8f 18       	st.w	r7[0x4],r8
80004e78:	c2 58       	rjmp	80004ec2 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80004e7a:	58 0a       	cp.w	r10,0
80004e7c:	c1 01       	brne	80004e9c <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80004e7e:	10 9a       	mov	r10,r8
80004e80:	78 2c       	ld.w	r12,r12[0x8]
80004e82:	f0 1f 00 14 	mcall	80004ed0 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80004e86:	6e 29       	ld.w	r9,r7[0x8]
80004e88:	6f 08       	ld.w	r8,r7[0x40]
80004e8a:	f2 08 00 08 	add	r8,r9,r8
80004e8e:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80004e90:	6e 19       	ld.w	r9,r7[0x4]
80004e92:	12 38       	cp.w	r8,r9
80004e94:	c1 73       	brcs	80004ec2 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80004e96:	6e 08       	ld.w	r8,r7[0x0]
80004e98:	8f 28       	st.w	r7[0x8],r8
80004e9a:	c1 48       	rjmp	80004ec2 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80004e9c:	10 9a       	mov	r10,r8
80004e9e:	78 3c       	ld.w	r12,r12[0xc]
80004ea0:	f0 1f 00 0c 	mcall	80004ed0 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80004ea4:	6f 08       	ld.w	r8,r7[0x40]
80004ea6:	6e 39       	ld.w	r9,r7[0xc]
80004ea8:	f2 08 01 08 	sub	r8,r9,r8
80004eac:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80004eae:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80004eb0:	12 38       	cp.w	r8,r9
80004eb2:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80004eb6:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80004eba:	f3 d8 e3 19 	subcs	r9,r9,r8
80004ebe:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80004ec2:	6e e8       	ld.w	r8,r7[0x38]
80004ec4:	2f f8       	sub	r8,-1
80004ec6:	8f e8       	st.w	r7[0x38],r8
}
80004ec8:	e3 cd 80 80 	ldm	sp++,r7,pc
80004ecc:	80 00       	ld.sh	r0,r0[0x0]
80004ece:	51 5c       	stdsp	sp[0x54],r12
80004ed0:	80 00       	ld.sh	r0,r0[0x0]
80004ed2:	62 26       	ld.w	r6,r1[0x8]

80004ed4 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80004ed4:	d4 31       	pushm	r0-r7,lr
80004ed6:	20 5d       	sub	sp,20
80004ed8:	18 97       	mov	r7,r12
80004eda:	50 0b       	stdsp	sp[0x0],r11
80004edc:	50 2a       	stdsp	sp[0x8],r10
80004ede:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80004ee0:	f8 c0 ff f0 	sub	r0,r12,-16
80004ee4:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80004ee6:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80004eea:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80004eec:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80004ef0:	f0 1f 00 2f 	mcall	80004fac <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80004ef4:	6e e9       	ld.w	r9,r7[0x38]
80004ef6:	6e f8       	ld.w	r8,r7[0x3c]
80004ef8:	10 39       	cp.w	r9,r8
80004efa:	c1 42       	brcc	80004f22 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80004efc:	40 1a       	lddsp	r10,sp[0x4]
80004efe:	40 0b       	lddsp	r11,sp[0x0]
80004f00:	0e 9c       	mov	r12,r7
80004f02:	f0 1f 00 2c 	mcall	80004fb0 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80004f06:	6e 98       	ld.w	r8,r7[0x24]
80004f08:	58 08       	cp.w	r8,0
80004f0a:	c0 80       	breq	80004f1a <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80004f0c:	ee cc ff dc 	sub	r12,r7,-36
80004f10:	f0 1f 00 29 	mcall	80004fb4 <xQueueGenericSend+0xe0>
80004f14:	58 1c       	cp.w	r12,1
80004f16:	c0 21       	brne	80004f1a <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80004f18:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80004f1a:	f0 1f 00 28 	mcall	80004fb8 <xQueueGenericSend+0xe4>
80004f1e:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80004f20:	c4 38       	rjmp	80004fa6 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80004f22:	40 28       	lddsp	r8,sp[0x8]
80004f24:	58 08       	cp.w	r8,0
80004f26:	c0 51       	brne	80004f30 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80004f28:	f0 1f 00 24 	mcall	80004fb8 <xQueueGenericSend+0xe4>
80004f2c:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80004f2e:	c3 c8       	rjmp	80004fa6 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80004f30:	58 04       	cp.w	r4,0
80004f32:	c0 51       	brne	80004f3c <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80004f34:	06 9c       	mov	r12,r3
80004f36:	f0 1f 00 22 	mcall	80004fbc <xQueueGenericSend+0xe8>
80004f3a:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80004f3c:	f0 1f 00 1f 	mcall	80004fb8 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80004f40:	f0 1f 00 20 	mcall	80004fc0 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80004f44:	f0 1f 00 1a 	mcall	80004fac <xQueueGenericSend+0xd8>
80004f48:	6f 18       	ld.w	r8,r7[0x44]
80004f4a:	5b f8       	cp.w	r8,-1
80004f4c:	ef f1 0a 11 	st.weq	r7[0x44],r1
80004f50:	6f 28       	ld.w	r8,r7[0x48]
80004f52:	5b f8       	cp.w	r8,-1
80004f54:	ef f1 0a 12 	st.weq	r7[0x48],r1
80004f58:	f0 1f 00 18 	mcall	80004fb8 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80004f5c:	04 9b       	mov	r11,r2
80004f5e:	06 9c       	mov	r12,r3
80004f60:	f0 1f 00 19 	mcall	80004fc4 <xQueueGenericSend+0xf0>
80004f64:	c1 b1       	brne	80004f9a <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80004f66:	f0 1f 00 12 	mcall	80004fac <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80004f6a:	6e e5       	ld.w	r5,r7[0x38]
80004f6c:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80004f6e:	f0 1f 00 13 	mcall	80004fb8 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80004f72:	0c 35       	cp.w	r5,r6
80004f74:	c0 d1       	brne	80004f8e <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80004f76:	40 2b       	lddsp	r11,sp[0x8]
80004f78:	00 9c       	mov	r12,r0
80004f7a:	f0 1f 00 14 	mcall	80004fc8 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80004f7e:	0e 9c       	mov	r12,r7
80004f80:	f0 1f 00 13 	mcall	80004fcc <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80004f84:	f0 1f 00 13 	mcall	80004fd0 <xQueueGenericSend+0xfc>
80004f88:	cb 41       	brne	80004ef0 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80004f8a:	d7 33       	scall
80004f8c:	cb 2b       	rjmp	80004ef0 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80004f8e:	0e 9c       	mov	r12,r7
80004f90:	f0 1f 00 0f 	mcall	80004fcc <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80004f94:	f0 1f 00 0f 	mcall	80004fd0 <xQueueGenericSend+0xfc>
80004f98:	ca cb       	rjmp	80004ef0 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80004f9a:	0e 9c       	mov	r12,r7
80004f9c:	f0 1f 00 0c 	mcall	80004fcc <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80004fa0:	f0 1f 00 0c 	mcall	80004fd0 <xQueueGenericSend+0xfc>
80004fa4:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80004fa6:	2f bd       	sub	sp,-20
80004fa8:	d8 32       	popm	r0-r7,pc
80004faa:	00 00       	add	r0,r0
80004fac:	80 00       	ld.sh	r0,r0[0x0]
80004fae:	49 b4       	lddpc	r4,80005018 <xQueueCreateMutex+0x44>
80004fb0:	80 00       	ld.sh	r0,r0[0x0]
80004fb2:	4e 5c       	lddpc	r12,80005144 <vTaskMissedYield>
80004fb4:	80 00       	ld.sh	r0,r0[0x0]
80004fb6:	52 38       	stdsp	sp[0x8c],r8
80004fb8:	80 00       	ld.sh	r0,r0[0x0]
80004fba:	4a c0       	lddpc	r0,80005068 <xQueueCreate+0x3c>
80004fbc:	80 00       	ld.sh	r0,r0[0x0]
80004fbe:	51 2c       	stdsp	sp[0x48],r12
80004fc0:	80 00       	ld.sh	r0,r0[0x0]
80004fc2:	50 a0       	stdsp	sp[0x28],r0
80004fc4:	80 00       	ld.sh	r0,r0[0x0]
80004fc6:	53 c8       	stdsp	sp[0xf0],r8
80004fc8:	80 00       	ld.sh	r0,r0[0x0]
80004fca:	56 68       	stdsp	sp[0x198],r8
80004fcc:	80 00       	ld.sh	r0,r0[0x0]
80004fce:	4c 78       	lddpc	r8,800050e8 <vTaskSwitchContext+0x38>
80004fd0:	80 00       	ld.sh	r0,r0[0x0]
80004fd2:	54 5c       	stdsp	sp[0x114],r12

80004fd4 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80004fd4:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80004fd8:	34 cc       	mov	r12,76
80004fda:	f0 1f 00 12 	mcall	80005020 <xQueueCreateMutex+0x4c>
80004fde:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
80004fe0:	c1 d0       	breq	8000501a <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
80004fe2:	30 06       	mov	r6,0
80004fe4:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80004fe6:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80004fe8:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
80004fea:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80004fec:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
80004fee:	30 18       	mov	r8,1
80004ff0:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
80004ff2:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
80004ff6:	3f f8       	mov	r8,-1
80004ff8:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80004ffc:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005000:	2f 0c       	sub	r12,-16
80005002:	f0 1f 00 09 	mcall	80005024 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005006:	ee cc ff dc 	sub	r12,r7,-36
8000500a:	f0 1f 00 07 	mcall	80005024 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
8000500e:	0c 99       	mov	r9,r6
80005010:	0c 9a       	mov	r10,r6
80005012:	0c 9b       	mov	r11,r6
80005014:	0e 9c       	mov	r12,r7
80005016:	f0 1f 00 05 	mcall	80005028 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
8000501a:	0e 9c       	mov	r12,r7
8000501c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005020:	80 00       	ld.sh	r0,r0[0x0]
80005022:	4c 20       	lddpc	r0,80005128 <vTaskSwitchContext+0x78>
80005024:	80 00       	ld.sh	r0,r0[0x0]
80005026:	48 90       	lddpc	r0,80005048 <xQueueCreate+0x1c>
80005028:	80 00       	ld.sh	r0,r0[0x0]
8000502a:	4e d4       	lddpc	r4,800051dc <vTaskPriorityInherit+0x28>

8000502c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
8000502c:	d4 21       	pushm	r4-r7,lr
8000502e:	18 97       	mov	r7,r12
80005030:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80005032:	58 0c       	cp.w	r12,0
80005034:	c2 f0       	breq	80005092 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005036:	34 cc       	mov	r12,76
80005038:	f0 1f 00 17 	mcall	80005094 <xQueueCreate+0x68>
8000503c:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000503e:	c2 a0       	breq	80005092 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80005040:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80005044:	e8 cc ff ff 	sub	r12,r4,-1
80005048:	f0 1f 00 13 	mcall	80005094 <xQueueCreate+0x68>
8000504c:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000504e:	c1 e0       	breq	8000508a <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80005050:	f8 04 00 04 	add	r4,r12,r4
80005054:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005056:	30 08       	mov	r8,0
80005058:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
8000505a:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
8000505c:	ee c8 00 01 	sub	r8,r7,1
80005060:	ad 38       	mul	r8,r6
80005062:	10 0c       	add	r12,r8
80005064:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80005066:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80005068:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
8000506c:	3f f8       	mov	r8,-1
8000506e:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80005072:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005076:	ea cc ff f0 	sub	r12,r5,-16
8000507a:	f0 1f 00 08 	mcall	80005098 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000507e:	ea cc ff dc 	sub	r12,r5,-36
80005082:	f0 1f 00 06 	mcall	80005098 <xQueueCreate+0x6c>
80005086:	0a 9c       	mov	r12,r5
80005088:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
8000508a:	0a 9c       	mov	r12,r5
8000508c:	f0 1f 00 04 	mcall	8000509c <xQueueCreate+0x70>
80005090:	d8 2a       	popm	r4-r7,pc,r12=0
80005092:	d8 2a       	popm	r4-r7,pc,r12=0
80005094:	80 00       	ld.sh	r0,r0[0x0]
80005096:	4c 20       	lddpc	r0,8000519c <vTaskPriorityDisinherit+0x40>
80005098:	80 00       	ld.sh	r0,r0[0x0]
8000509a:	48 90       	lddpc	r0,800050bc <vTaskSwitchContext+0xc>
8000509c:	80 00       	ld.sh	r0,r0[0x0]
8000509e:	4b f8       	lddpc	r8,80005198 <vTaskPriorityDisinherit+0x3c>

800050a0 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800050a0:	48 38       	lddpc	r8,800050ac <vTaskSuspendAll+0xc>
800050a2:	70 09       	ld.w	r9,r8[0x0]
800050a4:	2f f9       	sub	r9,-1
800050a6:	91 09       	st.w	r8[0x0],r9
}
800050a8:	5e fc       	retal	r12
800050aa:	00 00       	add	r0,r0
800050ac:	00 00       	add	r0,r0
800050ae:	0c 68       	and	r8,r6

800050b0 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800050b0:	49 a8       	lddpc	r8,80005118 <vTaskSwitchContext+0x68>
800050b2:	70 08       	ld.w	r8,r8[0x0]
800050b4:	58 08       	cp.w	r8,0
800050b6:	c0 b1       	brne	800050cc <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800050b8:	49 98       	lddpc	r8,8000511c <vTaskSwitchContext+0x6c>
800050ba:	70 08       	ld.w	r8,r8[0x0]
800050bc:	f0 08 00 28 	add	r8,r8,r8<<0x2
800050c0:	49 89       	lddpc	r9,80005120 <vTaskSwitchContext+0x70>
800050c2:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800050c6:	58 08       	cp.w	r8,0
800050c8:	c0 60       	breq	800050d4 <vTaskSwitchContext+0x24>
800050ca:	c1 18       	rjmp	800050ec <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800050cc:	30 19       	mov	r9,1
800050ce:	49 68       	lddpc	r8,80005124 <vTaskSwitchContext+0x74>
800050d0:	91 09       	st.w	r8[0x0],r9
800050d2:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800050d4:	49 28       	lddpc	r8,8000511c <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800050d6:	49 3a       	lddpc	r10,80005120 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800050d8:	70 09       	ld.w	r9,r8[0x0]
800050da:	20 19       	sub	r9,1
800050dc:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800050de:	70 09       	ld.w	r9,r8[0x0]
800050e0:	f2 09 00 29 	add	r9,r9,r9<<0x2
800050e4:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800050e8:	58 09       	cp.w	r9,0
800050ea:	cf 70       	breq	800050d8 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800050ec:	48 c8       	lddpc	r8,8000511c <vTaskSwitchContext+0x6c>
800050ee:	70 08       	ld.w	r8,r8[0x0]
800050f0:	f0 08 00 28 	add	r8,r8,r8<<0x2
800050f4:	48 b9       	lddpc	r9,80005120 <vTaskSwitchContext+0x70>
800050f6:	f2 08 00 28 	add	r8,r9,r8<<0x2
800050fa:	70 19       	ld.w	r9,r8[0x4]
800050fc:	72 19       	ld.w	r9,r9[0x4]
800050fe:	91 19       	st.w	r8[0x4],r9
80005100:	f0 ca ff f8 	sub	r10,r8,-8
80005104:	14 39       	cp.w	r9,r10
80005106:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
8000510a:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000510e:	70 18       	ld.w	r8,r8[0x4]
80005110:	70 39       	ld.w	r9,r8[0xc]
80005112:	48 68       	lddpc	r8,80005128 <vTaskSwitchContext+0x78>
80005114:	91 09       	st.w	r8[0x0],r9
80005116:	5e fc       	retal	r12
80005118:	00 00       	add	r0,r0
8000511a:	0c 68       	and	r8,r6
8000511c:	00 00       	add	r0,r0
8000511e:	0c a0       	st.w	r6++,r0
80005120:	00 00       	add	r0,r0
80005122:	0b 84       	ld.ub	r4,r5[0x0]
80005124:	00 00       	add	r0,r0
80005126:	0c 88       	andn	r8,r6
80005128:	00 00       	add	r0,r0
8000512a:	0c 38       	cp.w	r8,r6

8000512c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
8000512c:	48 48       	lddpc	r8,8000513c <vTaskSetTimeOutState+0x10>
8000512e:	70 08       	ld.w	r8,r8[0x0]
80005130:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80005132:	48 48       	lddpc	r8,80005140 <vTaskSetTimeOutState+0x14>
80005134:	70 08       	ld.w	r8,r8[0x0]
80005136:	99 18       	st.w	r12[0x4],r8
}
80005138:	5e fc       	retal	r12
8000513a:	00 00       	add	r0,r0
8000513c:	00 00       	add	r0,r0
8000513e:	0b 7c       	ld.ub	r12,--r5
80005140:	00 00       	add	r0,r0
80005142:	0c 64       	and	r4,r6

80005144 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80005144:	30 19       	mov	r9,1
80005146:	48 28       	lddpc	r8,8000514c <vTaskMissedYield+0x8>
80005148:	91 09       	st.w	r8[0x0],r9
}
8000514a:	5e fc       	retal	r12
8000514c:	00 00       	add	r0,r0
8000514e:	0c 88       	andn	r8,r6

80005150 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80005150:	48 28       	lddpc	r8,80005158 <xTaskGetCurrentTaskHandle+0x8>
80005152:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80005154:	5e fc       	retal	r12
80005156:	00 00       	add	r0,r0
80005158:	00 00       	add	r0,r0
8000515a:	0c 38       	cp.w	r8,r6

8000515c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
8000515c:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80005160:	58 0c       	cp.w	r12,0
80005162:	c1 f0       	breq	800051a0 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80005164:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80005166:	78 b9       	ld.w	r9,r12[0x2c]
80005168:	79 18       	ld.w	r8,r12[0x44]
8000516a:	10 39       	cp.w	r9,r8
8000516c:	c1 a0       	breq	800051a0 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000516e:	f8 c6 ff fc 	sub	r6,r12,-4
80005172:	0c 9c       	mov	r12,r6
80005174:	f0 1f 00 0c 	mcall	800051a4 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80005178:	6f 1c       	ld.w	r12,r7[0x44]
8000517a:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
8000517c:	f8 08 11 08 	rsub	r8,r12,8
80005180:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80005182:	48 a8       	lddpc	r8,800051a8 <vTaskPriorityDisinherit+0x4c>
80005184:	70 08       	ld.w	r8,r8[0x0]
80005186:	10 3c       	cp.w	r12,r8
80005188:	e0 88 00 04 	brls	80005190 <vTaskPriorityDisinherit+0x34>
8000518c:	48 78       	lddpc	r8,800051a8 <vTaskPriorityDisinherit+0x4c>
8000518e:	91 0c       	st.w	r8[0x0],r12
80005190:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005194:	0c 9b       	mov	r11,r6
80005196:	48 68       	lddpc	r8,800051ac <vTaskPriorityDisinherit+0x50>
80005198:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000519c:	f0 1f 00 05 	mcall	800051b0 <vTaskPriorityDisinherit+0x54>
800051a0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800051a4:	80 00       	ld.sh	r0,r0[0x0]
800051a6:	48 fa       	lddpc	r10,800051e0 <vTaskPriorityInherit+0x2c>
800051a8:	00 00       	add	r0,r0
800051aa:	0c a0       	st.w	r6++,r0
800051ac:	00 00       	add	r0,r0
800051ae:	0b 84       	ld.ub	r4,r5[0x0]
800051b0:	80 00       	ld.sh	r0,r0[0x0]
800051b2:	48 aa       	lddpc	r10,800051d8 <vTaskPriorityInherit+0x24>

800051b4 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800051b4:	eb cd 40 c0 	pushm	r6-r7,lr
800051b8:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
800051ba:	49 b8       	lddpc	r8,80005224 <vTaskPriorityInherit+0x70>
800051bc:	70 08       	ld.w	r8,r8[0x0]
800051be:	78 b9       	ld.w	r9,r12[0x2c]
800051c0:	70 b8       	ld.w	r8,r8[0x2c]
800051c2:	10 39       	cp.w	r9,r8
800051c4:	c2 d2       	brcc	8000521e <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800051c6:	49 88       	lddpc	r8,80005224 <vTaskPriorityInherit+0x70>
800051c8:	70 08       	ld.w	r8,r8[0x0]
800051ca:	70 b8       	ld.w	r8,r8[0x2c]
800051cc:	f0 08 11 08 	rsub	r8,r8,8
800051d0:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800051d2:	f2 09 00 28 	add	r8,r9,r9<<0x2
800051d6:	49 59       	lddpc	r9,80005228 <vTaskPriorityInherit+0x74>
800051d8:	f2 08 00 28 	add	r8,r9,r8<<0x2
800051dc:	78 59       	ld.w	r9,r12[0x14]
800051de:	10 39       	cp.w	r9,r8
800051e0:	c1 b1       	brne	80005216 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800051e2:	f8 c6 ff fc 	sub	r6,r12,-4
800051e6:	0c 9c       	mov	r12,r6
800051e8:	f0 1f 00 11 	mcall	8000522c <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800051ec:	48 e8       	lddpc	r8,80005224 <vTaskPriorityInherit+0x70>
800051ee:	70 08       	ld.w	r8,r8[0x0]
800051f0:	70 bc       	ld.w	r12,r8[0x2c]
800051f2:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800051f4:	48 f8       	lddpc	r8,80005230 <vTaskPriorityInherit+0x7c>
800051f6:	70 08       	ld.w	r8,r8[0x0]
800051f8:	10 3c       	cp.w	r12,r8
800051fa:	e0 88 00 04 	brls	80005202 <vTaskPriorityInherit+0x4e>
800051fe:	48 d8       	lddpc	r8,80005230 <vTaskPriorityInherit+0x7c>
80005200:	91 0c       	st.w	r8[0x0],r12
80005202:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005206:	0c 9b       	mov	r11,r6
80005208:	48 88       	lddpc	r8,80005228 <vTaskPriorityInherit+0x74>
8000520a:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000520e:	f0 1f 00 0a 	mcall	80005234 <vTaskPriorityInherit+0x80>
80005212:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005216:	48 48       	lddpc	r8,80005224 <vTaskPriorityInherit+0x70>
80005218:	70 08       	ld.w	r8,r8[0x0]
8000521a:	70 b8       	ld.w	r8,r8[0x2c]
8000521c:	99 b8       	st.w	r12[0x2c],r8
8000521e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005222:	00 00       	add	r0,r0
80005224:	00 00       	add	r0,r0
80005226:	0c 38       	cp.w	r8,r6
80005228:	00 00       	add	r0,r0
8000522a:	0b 84       	ld.ub	r4,r5[0x0]
8000522c:	80 00       	ld.sh	r0,r0[0x0]
8000522e:	48 fa       	lddpc	r10,80005268 <xTaskRemoveFromEventList+0x30>
80005230:	00 00       	add	r0,r0
80005232:	0c a0       	st.w	r6++,r0
80005234:	80 00       	ld.sh	r0,r0[0x0]
80005236:	48 aa       	lddpc	r10,8000525c <xTaskRemoveFromEventList+0x24>

80005238 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80005238:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
8000523c:	78 38       	ld.w	r8,r12[0xc]
8000523e:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80005240:	ee c6 ff e8 	sub	r6,r7,-24
80005244:	0c 9c       	mov	r12,r6
80005246:	f0 1f 00 15 	mcall	80005298 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000524a:	49 58       	lddpc	r8,8000529c <xTaskRemoveFromEventList+0x64>
8000524c:	70 08       	ld.w	r8,r8[0x0]
8000524e:	58 08       	cp.w	r8,0
80005250:	c1 71       	brne	8000527e <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80005252:	ee c6 ff fc 	sub	r6,r7,-4
80005256:	0c 9c       	mov	r12,r6
80005258:	f0 1f 00 10 	mcall	80005298 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
8000525c:	6e bc       	ld.w	r12,r7[0x2c]
8000525e:	49 18       	lddpc	r8,800052a0 <xTaskRemoveFromEventList+0x68>
80005260:	70 08       	ld.w	r8,r8[0x0]
80005262:	10 3c       	cp.w	r12,r8
80005264:	e0 88 00 04 	brls	8000526c <xTaskRemoveFromEventList+0x34>
80005268:	48 e8       	lddpc	r8,800052a0 <xTaskRemoveFromEventList+0x68>
8000526a:	91 0c       	st.w	r8[0x0],r12
8000526c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005270:	0c 9b       	mov	r11,r6
80005272:	48 d8       	lddpc	r8,800052a4 <xTaskRemoveFromEventList+0x6c>
80005274:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005278:	f0 1f 00 0c 	mcall	800052a8 <xTaskRemoveFromEventList+0x70>
8000527c:	c0 58       	rjmp	80005286 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000527e:	0c 9b       	mov	r11,r6
80005280:	48 bc       	lddpc	r12,800052ac <xTaskRemoveFromEventList+0x74>
80005282:	f0 1f 00 0a 	mcall	800052a8 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005286:	48 b8       	lddpc	r8,800052b0 <xTaskRemoveFromEventList+0x78>
80005288:	70 08       	ld.w	r8,r8[0x0]
8000528a:	6e b9       	ld.w	r9,r7[0x2c]
8000528c:	70 b8       	ld.w	r8,r8[0x2c]
8000528e:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80005290:	5f 2c       	srhs	r12
80005292:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005296:	00 00       	add	r0,r0
80005298:	80 00       	ld.sh	r0,r0[0x0]
8000529a:	48 fa       	lddpc	r10,800052d4 <vTaskIncrementTick+0x20>
8000529c:	00 00       	add	r0,r0
8000529e:	0c 68       	and	r8,r6
800052a0:	00 00       	add	r0,r0
800052a2:	0c a0       	st.w	r6++,r0
800052a4:	00 00       	add	r0,r0
800052a6:	0b 84       	ld.ub	r4,r5[0x0]
800052a8:	80 00       	ld.sh	r0,r0[0x0]
800052aa:	48 aa       	lddpc	r10,800052d0 <vTaskIncrementTick+0x1c>
800052ac:	00 00       	add	r0,r0
800052ae:	0c 3c       	cp.w	r12,r6
800052b0:	00 00       	add	r0,r0
800052b2:	0c 38       	cp.w	r8,r6

800052b4 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800052b4:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800052b8:	4b 98       	lddpc	r8,8000539c <vTaskIncrementTick+0xe8>
800052ba:	70 08       	ld.w	r8,r8[0x0]
800052bc:	58 08       	cp.w	r8,0
800052be:	c6 91       	brne	80005390 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800052c0:	4b 88       	lddpc	r8,800053a0 <vTaskIncrementTick+0xec>
800052c2:	70 09       	ld.w	r9,r8[0x0]
800052c4:	2f f9       	sub	r9,-1
800052c6:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800052c8:	70 08       	ld.w	r8,r8[0x0]
800052ca:	58 08       	cp.w	r8,0
800052cc:	c1 a1       	brne	80005300 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800052ce:	4b 68       	lddpc	r8,800053a4 <vTaskIncrementTick+0xf0>
800052d0:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800052d2:	4b 69       	lddpc	r9,800053a8 <vTaskIncrementTick+0xf4>
800052d4:	72 0b       	ld.w	r11,r9[0x0]
800052d6:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800052d8:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800052da:	4b 59       	lddpc	r9,800053ac <vTaskIncrementTick+0xf8>
800052dc:	72 0a       	ld.w	r10,r9[0x0]
800052de:	2f fa       	sub	r10,-1
800052e0:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800052e2:	70 08       	ld.w	r8,r8[0x0]
800052e4:	70 08       	ld.w	r8,r8[0x0]
800052e6:	58 08       	cp.w	r8,0
800052e8:	c0 51       	brne	800052f2 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800052ea:	3f f9       	mov	r9,-1
800052ec:	4b 18       	lddpc	r8,800053b0 <vTaskIncrementTick+0xfc>
800052ee:	91 09       	st.w	r8[0x0],r9
800052f0:	c0 88       	rjmp	80005300 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800052f2:	4a d8       	lddpc	r8,800053a4 <vTaskIncrementTick+0xf0>
800052f4:	70 08       	ld.w	r8,r8[0x0]
800052f6:	70 38       	ld.w	r8,r8[0xc]
800052f8:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800052fa:	70 19       	ld.w	r9,r8[0x4]
800052fc:	4a d8       	lddpc	r8,800053b0 <vTaskIncrementTick+0xfc>
800052fe:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80005300:	4a 88       	lddpc	r8,800053a0 <vTaskIncrementTick+0xec>
80005302:	70 09       	ld.w	r9,r8[0x0]
80005304:	4a b8       	lddpc	r8,800053b0 <vTaskIncrementTick+0xfc>
80005306:	70 08       	ld.w	r8,r8[0x0]
80005308:	10 39       	cp.w	r9,r8
8000530a:	c4 73       	brcs	80005398 <vTaskIncrementTick+0xe4>
8000530c:	4a 68       	lddpc	r8,800053a4 <vTaskIncrementTick+0xf0>
8000530e:	70 08       	ld.w	r8,r8[0x0]
80005310:	70 08       	ld.w	r8,r8[0x0]
80005312:	58 08       	cp.w	r8,0
80005314:	c0 c0       	breq	8000532c <vTaskIncrementTick+0x78>
80005316:	4a 48       	lddpc	r8,800053a4 <vTaskIncrementTick+0xf0>
80005318:	70 08       	ld.w	r8,r8[0x0]
8000531a:	70 38       	ld.w	r8,r8[0xc]
8000531c:	70 37       	ld.w	r7,r8[0xc]
8000531e:	6e 18       	ld.w	r8,r7[0x4]
80005320:	4a 09       	lddpc	r9,800053a0 <vTaskIncrementTick+0xec>
80005322:	72 09       	ld.w	r9,r9[0x0]
80005324:	12 38       	cp.w	r8,r9
80005326:	e0 88 00 14 	brls	8000534e <vTaskIncrementTick+0x9a>
8000532a:	c0 e8       	rjmp	80005346 <vTaskIncrementTick+0x92>
8000532c:	3f f9       	mov	r9,-1
8000532e:	4a 18       	lddpc	r8,800053b0 <vTaskIncrementTick+0xfc>
80005330:	91 09       	st.w	r8[0x0],r9
80005332:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005336:	6a 08       	ld.w	r8,r5[0x0]
80005338:	70 38       	ld.w	r8,r8[0xc]
8000533a:	70 37       	ld.w	r7,r8[0xc]
8000533c:	6e 18       	ld.w	r8,r7[0x4]
8000533e:	64 09       	ld.w	r9,r2[0x0]
80005340:	12 38       	cp.w	r8,r9
80005342:	e0 88 00 0a 	brls	80005356 <vTaskIncrementTick+0xa2>
80005346:	49 b9       	lddpc	r9,800053b0 <vTaskIncrementTick+0xfc>
80005348:	93 08       	st.w	r9[0x0],r8
8000534a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000534e:	49 a4       	lddpc	r4,800053b4 <vTaskIncrementTick+0x100>
80005350:	49 a3       	lddpc	r3,800053b8 <vTaskIncrementTick+0x104>
80005352:	49 55       	lddpc	r5,800053a4 <vTaskIncrementTick+0xf0>
80005354:	49 32       	lddpc	r2,800053a0 <vTaskIncrementTick+0xec>
80005356:	ee c6 ff fc 	sub	r6,r7,-4
8000535a:	0c 9c       	mov	r12,r6
8000535c:	f0 1f 00 18 	mcall	800053bc <vTaskIncrementTick+0x108>
80005360:	6e a8       	ld.w	r8,r7[0x28]
80005362:	58 08       	cp.w	r8,0
80005364:	c0 50       	breq	8000536e <vTaskIncrementTick+0xba>
80005366:	ee cc ff e8 	sub	r12,r7,-24
8000536a:	f0 1f 00 15 	mcall	800053bc <vTaskIncrementTick+0x108>
8000536e:	6e bc       	ld.w	r12,r7[0x2c]
80005370:	68 08       	ld.w	r8,r4[0x0]
80005372:	10 3c       	cp.w	r12,r8
80005374:	e9 fc ba 00 	st.whi	r4[0x0],r12
80005378:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000537c:	0c 9b       	mov	r11,r6
8000537e:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80005382:	f0 1f 00 10 	mcall	800053c0 <vTaskIncrementTick+0x10c>
80005386:	6a 08       	ld.w	r8,r5[0x0]
80005388:	70 08       	ld.w	r8,r8[0x0]
8000538a:	58 08       	cp.w	r8,0
8000538c:	cd 51       	brne	80005336 <vTaskIncrementTick+0x82>
8000538e:	cc fb       	rjmp	8000532c <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80005390:	48 d8       	lddpc	r8,800053c4 <vTaskIncrementTick+0x110>
80005392:	70 09       	ld.w	r9,r8[0x0]
80005394:	2f f9       	sub	r9,-1
80005396:	91 09       	st.w	r8[0x0],r9
80005398:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000539c:	00 00       	add	r0,r0
8000539e:	0c 68       	and	r8,r6
800053a0:	00 00       	add	r0,r0
800053a2:	0c 64       	and	r4,r6
800053a4:	00 00       	add	r0,r0
800053a6:	0b 70       	ld.ub	r0,--r5
800053a8:	00 00       	add	r0,r0
800053aa:	0b 80       	ld.ub	r0,r5[0x0]
800053ac:	00 00       	add	r0,r0
800053ae:	0b 7c       	ld.ub	r12,--r5
800053b0:	00 00       	add	r0,r0
800053b2:	05 14       	ld.sh	r4,r2++
800053b4:	00 00       	add	r0,r0
800053b6:	0c a0       	st.w	r6++,r0
800053b8:	00 00       	add	r0,r0
800053ba:	0b 84       	ld.ub	r4,r5[0x0]
800053bc:	80 00       	ld.sh	r0,r0[0x0]
800053be:	48 fa       	lddpc	r10,800053f8 <xTaskCheckForTimeOut+0x30>
800053c0:	80 00       	ld.sh	r0,r0[0x0]
800053c2:	48 aa       	lddpc	r10,800053e8 <xTaskCheckForTimeOut+0x20>
800053c4:	00 00       	add	r0,r0
800053c6:	0b 68       	ld.uh	r8,--r5

800053c8 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800053c8:	eb cd 40 c0 	pushm	r6-r7,lr
800053cc:	18 97       	mov	r7,r12
800053ce:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800053d0:	f0 1f 00 15 	mcall	80005424 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800053d4:	6c 08       	ld.w	r8,r6[0x0]
800053d6:	5b f8       	cp.w	r8,-1
800053d8:	c0 31       	brne	800053de <xTaskCheckForTimeOut+0x16>
800053da:	30 07       	mov	r7,0
800053dc:	c1 f8       	rjmp	8000541a <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800053de:	49 39       	lddpc	r9,80005428 <xTaskCheckForTimeOut+0x60>
800053e0:	72 09       	ld.w	r9,r9[0x0]
800053e2:	6e 0a       	ld.w	r10,r7[0x0]
800053e4:	12 3a       	cp.w	r10,r9
800053e6:	c0 70       	breq	800053f4 <xTaskCheckForTimeOut+0x2c>
800053e8:	49 19       	lddpc	r9,8000542c <xTaskCheckForTimeOut+0x64>
800053ea:	72 09       	ld.w	r9,r9[0x0]
800053ec:	6e 1a       	ld.w	r10,r7[0x4]
800053ee:	12 3a       	cp.w	r10,r9
800053f0:	e0 88 00 14 	brls	80005418 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800053f4:	48 e9       	lddpc	r9,8000542c <xTaskCheckForTimeOut+0x64>
800053f6:	72 0a       	ld.w	r10,r9[0x0]
800053f8:	6e 19       	ld.w	r9,r7[0x4]
800053fa:	12 1a       	sub	r10,r9
800053fc:	14 38       	cp.w	r8,r10
800053fe:	e0 88 00 0d 	brls	80005418 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80005402:	48 ba       	lddpc	r10,8000542c <xTaskCheckForTimeOut+0x64>
80005404:	74 0a       	ld.w	r10,r10[0x0]
80005406:	14 19       	sub	r9,r10
80005408:	f2 08 00 08 	add	r8,r9,r8
8000540c:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000540e:	0e 9c       	mov	r12,r7
80005410:	f0 1f 00 08 	mcall	80005430 <xTaskCheckForTimeOut+0x68>
80005414:	30 07       	mov	r7,0
80005416:	c0 28       	rjmp	8000541a <xTaskCheckForTimeOut+0x52>
80005418:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
8000541a:	f0 1f 00 07 	mcall	80005434 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000541e:	0e 9c       	mov	r12,r7
80005420:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005424:	80 00       	ld.sh	r0,r0[0x0]
80005426:	49 b4       	lddpc	r4,80005490 <xTaskResumeAll+0x34>
80005428:	00 00       	add	r0,r0
8000542a:	0b 7c       	ld.ub	r12,--r5
8000542c:	00 00       	add	r0,r0
8000542e:	0c 64       	and	r4,r6
80005430:	80 00       	ld.sh	r0,r0[0x0]
80005432:	51 2c       	stdsp	sp[0x48],r12
80005434:	80 00       	ld.sh	r0,r0[0x0]
80005436:	4a c0       	lddpc	r0,800054e4 <xTaskResumeAll+0x88>

80005438 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80005438:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
8000543c:	f0 1f 00 05 	mcall	80005450 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80005440:	48 58       	lddpc	r8,80005454 <xTaskGetTickCount+0x1c>
80005442:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80005444:	f0 1f 00 05 	mcall	80005458 <xTaskGetTickCount+0x20>

	return xTicks;
}
80005448:	0e 9c       	mov	r12,r7
8000544a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000544e:	00 00       	add	r0,r0
80005450:	80 00       	ld.sh	r0,r0[0x0]
80005452:	49 b4       	lddpc	r4,800054bc <xTaskResumeAll+0x60>
80005454:	00 00       	add	r0,r0
80005456:	0c 64       	and	r4,r6
80005458:	80 00       	ld.sh	r0,r0[0x0]
8000545a:	4a c0       	lddpc	r0,80005508 <xTaskResumeAll+0xac>

8000545c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
8000545c:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80005460:	f0 1f 00 2c 	mcall	80005510 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80005464:	4a c8       	lddpc	r8,80005514 <xTaskResumeAll+0xb8>
80005466:	70 09       	ld.w	r9,r8[0x0]
80005468:	20 19       	sub	r9,1
8000546a:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000546c:	70 08       	ld.w	r8,r8[0x0]
8000546e:	58 08       	cp.w	r8,0
80005470:	c4 91       	brne	80005502 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80005472:	4a a8       	lddpc	r8,80005518 <xTaskResumeAll+0xbc>
80005474:	70 08       	ld.w	r8,r8[0x0]
80005476:	58 08       	cp.w	r8,0
80005478:	c4 50       	breq	80005502 <xTaskResumeAll+0xa6>
8000547a:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000547c:	4a 85       	lddpc	r5,8000551c <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
8000547e:	4a 93       	lddpc	r3,80005520 <xTaskResumeAll+0xc4>
80005480:	4a 92       	lddpc	r2,80005524 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005482:	4a a1       	lddpc	r1,80005528 <xTaskResumeAll+0xcc>
80005484:	c1 e8       	rjmp	800054c0 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80005486:	6a 38       	ld.w	r8,r5[0xc]
80005488:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000548a:	ee cc ff e8 	sub	r12,r7,-24
8000548e:	f0 1f 00 28 	mcall	8000552c <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80005492:	ee c6 ff fc 	sub	r6,r7,-4
80005496:	0c 9c       	mov	r12,r6
80005498:	f0 1f 00 25 	mcall	8000552c <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
8000549c:	6e bc       	ld.w	r12,r7[0x2c]
8000549e:	66 08       	ld.w	r8,r3[0x0]
800054a0:	10 3c       	cp.w	r12,r8
800054a2:	e7 fc ba 00 	st.whi	r3[0x0],r12
800054a6:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800054aa:	0c 9b       	mov	r11,r6
800054ac:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800054b0:	f0 1f 00 20 	mcall	80005530 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800054b4:	62 08       	ld.w	r8,r1[0x0]
800054b6:	6e b9       	ld.w	r9,r7[0x2c]
800054b8:	70 b8       	ld.w	r8,r8[0x2c]
800054ba:	10 39       	cp.w	r9,r8
800054bc:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800054c0:	6a 08       	ld.w	r8,r5[0x0]
800054c2:	58 08       	cp.w	r8,0
800054c4:	ce 11       	brne	80005486 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800054c6:	49 c8       	lddpc	r8,80005534 <xTaskResumeAll+0xd8>
800054c8:	70 08       	ld.w	r8,r8[0x0]
800054ca:	58 08       	cp.w	r8,0
800054cc:	c0 f0       	breq	800054ea <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800054ce:	49 a8       	lddpc	r8,80005534 <xTaskResumeAll+0xd8>
800054d0:	70 08       	ld.w	r8,r8[0x0]
800054d2:	58 08       	cp.w	r8,0
800054d4:	c1 10       	breq	800054f6 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800054d6:	49 87       	lddpc	r7,80005534 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800054d8:	f0 1f 00 18 	mcall	80005538 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800054dc:	6e 08       	ld.w	r8,r7[0x0]
800054de:	20 18       	sub	r8,1
800054e0:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800054e2:	6e 08       	ld.w	r8,r7[0x0]
800054e4:	58 08       	cp.w	r8,0
800054e6:	cf 91       	brne	800054d8 <xTaskResumeAll+0x7c>
800054e8:	c0 78       	rjmp	800054f6 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800054ea:	58 14       	cp.w	r4,1
800054ec:	c0 50       	breq	800054f6 <xTaskResumeAll+0x9a>
800054ee:	49 48       	lddpc	r8,8000553c <xTaskResumeAll+0xe0>
800054f0:	70 08       	ld.w	r8,r8[0x0]
800054f2:	58 18       	cp.w	r8,1
800054f4:	c0 71       	brne	80005502 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800054f6:	30 09       	mov	r9,0
800054f8:	49 18       	lddpc	r8,8000553c <xTaskResumeAll+0xe0>
800054fa:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800054fc:	d7 33       	scall
800054fe:	30 17       	mov	r7,1
80005500:	c0 28       	rjmp	80005504 <xTaskResumeAll+0xa8>
80005502:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80005504:	f0 1f 00 0f 	mcall	80005540 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80005508:	0e 9c       	mov	r12,r7
8000550a:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000550e:	00 00       	add	r0,r0
80005510:	80 00       	ld.sh	r0,r0[0x0]
80005512:	49 b4       	lddpc	r4,8000557c <prvAddCurrentTaskToDelayedList+0x38>
80005514:	00 00       	add	r0,r0
80005516:	0c 68       	and	r8,r6
80005518:	00 00       	add	r0,r0
8000551a:	0c 84       	andn	r4,r6
8000551c:	00 00       	add	r0,r0
8000551e:	0c 3c       	cp.w	r12,r6
80005520:	00 00       	add	r0,r0
80005522:	0c a0       	st.w	r6++,r0
80005524:	00 00       	add	r0,r0
80005526:	0b 84       	ld.ub	r4,r5[0x0]
80005528:	00 00       	add	r0,r0
8000552a:	0c 38       	cp.w	r8,r6
8000552c:	80 00       	ld.sh	r0,r0[0x0]
8000552e:	48 fa       	lddpc	r10,80005568 <prvAddCurrentTaskToDelayedList+0x24>
80005530:	80 00       	ld.sh	r0,r0[0x0]
80005532:	48 aa       	lddpc	r10,80005558 <prvAddCurrentTaskToDelayedList+0x14>
80005534:	00 00       	add	r0,r0
80005536:	0b 68       	ld.uh	r8,--r5
80005538:	80 00       	ld.sh	r0,r0[0x0]
8000553a:	52 b4       	stdsp	sp[0xac],r4
8000553c:	00 00       	add	r0,r0
8000553e:	0c 88       	andn	r8,r6
80005540:	80 00       	ld.sh	r0,r0[0x0]
80005542:	4a c0       	lddpc	r0,800055f0 <vTaskDelayUntil+0x8>

80005544 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80005544:	eb cd 40 80 	pushm	r7,lr
80005548:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000554a:	49 08       	lddpc	r8,80005588 <prvAddCurrentTaskToDelayedList+0x44>
8000554c:	70 08       	ld.w	r8,r8[0x0]
8000554e:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80005550:	48 f8       	lddpc	r8,8000558c <prvAddCurrentTaskToDelayedList+0x48>
80005552:	70 08       	ld.w	r8,r8[0x0]
80005554:	10 3c       	cp.w	r12,r8
80005556:	c0 a2       	brcc	8000556a <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005558:	48 c8       	lddpc	r8,80005588 <prvAddCurrentTaskToDelayedList+0x44>
8000555a:	70 0b       	ld.w	r11,r8[0x0]
8000555c:	48 d8       	lddpc	r8,80005590 <prvAddCurrentTaskToDelayedList+0x4c>
8000555e:	70 0c       	ld.w	r12,r8[0x0]
80005560:	2f cb       	sub	r11,-4
80005562:	f0 1f 00 0d 	mcall	80005594 <prvAddCurrentTaskToDelayedList+0x50>
80005566:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000556a:	48 88       	lddpc	r8,80005588 <prvAddCurrentTaskToDelayedList+0x44>
8000556c:	70 0b       	ld.w	r11,r8[0x0]
8000556e:	48 b8       	lddpc	r8,80005598 <prvAddCurrentTaskToDelayedList+0x54>
80005570:	70 0c       	ld.w	r12,r8[0x0]
80005572:	2f cb       	sub	r11,-4
80005574:	f0 1f 00 08 	mcall	80005594 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80005578:	48 98       	lddpc	r8,8000559c <prvAddCurrentTaskToDelayedList+0x58>
8000557a:	70 08       	ld.w	r8,r8[0x0]
8000557c:	10 37       	cp.w	r7,r8
8000557e:	c0 32       	brcc	80005584 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80005580:	48 78       	lddpc	r8,8000559c <prvAddCurrentTaskToDelayedList+0x58>
80005582:	91 07       	st.w	r8[0x0],r7
80005584:	e3 cd 80 80 	ldm	sp++,r7,pc
80005588:	00 00       	add	r0,r0
8000558a:	0c 38       	cp.w	r8,r6
8000558c:	00 00       	add	r0,r0
8000558e:	0c 64       	and	r4,r6
80005590:	00 00       	add	r0,r0
80005592:	0b 80       	ld.ub	r0,r5[0x0]
80005594:	80 00       	ld.sh	r0,r0[0x0]
80005596:	48 c6       	lddpc	r6,800055c4 <vTaskDelay+0x24>
80005598:	00 00       	add	r0,r0
8000559a:	0b 70       	ld.ub	r0,--r5
8000559c:	00 00       	add	r0,r0
8000559e:	05 14       	ld.sh	r4,r2++

800055a0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
800055a0:	eb cd 40 c0 	pushm	r6-r7,lr
800055a4:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
800055a6:	58 0c       	cp.w	r12,0
800055a8:	c1 10       	breq	800055ca <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
800055aa:	f0 1f 00 0a 	mcall	800055d0 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
800055ae:	48 a8       	lddpc	r8,800055d4 <vTaskDelay+0x34>
800055b0:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800055b2:	48 a8       	lddpc	r8,800055d8 <vTaskDelay+0x38>
800055b4:	70 0c       	ld.w	r12,r8[0x0]
800055b6:	2f cc       	sub	r12,-4
800055b8:	f0 1f 00 09 	mcall	800055dc <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800055bc:	ee 06 00 0c 	add	r12,r7,r6
800055c0:	f0 1f 00 08 	mcall	800055e0 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
800055c4:	f0 1f 00 08 	mcall	800055e4 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800055c8:	c0 21       	brne	800055cc <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
800055ca:	d7 33       	scall
800055cc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800055d0:	80 00       	ld.sh	r0,r0[0x0]
800055d2:	50 a0       	stdsp	sp[0x28],r0
800055d4:	00 00       	add	r0,r0
800055d6:	0c 64       	and	r4,r6
800055d8:	00 00       	add	r0,r0
800055da:	0c 38       	cp.w	r8,r6
800055dc:	80 00       	ld.sh	r0,r0[0x0]
800055de:	48 fa       	lddpc	r10,80005618 <vTaskDelayUntil+0x30>
800055e0:	80 00       	ld.sh	r0,r0[0x0]
800055e2:	55 44       	stdsp	sp[0x150],r4
800055e4:	80 00       	ld.sh	r0,r0[0x0]
800055e6:	54 5c       	stdsp	sp[0x114],r12

800055e8 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
800055e8:	eb cd 40 c0 	pushm	r6-r7,lr
800055ec:	18 96       	mov	r6,r12
800055ee:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
800055f0:	f0 1f 00 18 	mcall	80005650 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
800055f4:	6c 08       	ld.w	r8,r6[0x0]
800055f6:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
800055f8:	49 79       	lddpc	r9,80005654 <vTaskDelayUntil+0x6c>
800055fa:	72 09       	ld.w	r9,r9[0x0]
800055fc:	12 38       	cp.w	r8,r9
800055fe:	e0 88 00 0c 	brls	80005616 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80005602:	0e 38       	cp.w	r8,r7
80005604:	e0 88 00 22 	brls	80005648 <vTaskDelayUntil+0x60>
80005608:	49 38       	lddpc	r8,80005654 <vTaskDelayUntil+0x6c>
8000560a:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
8000560c:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
8000560e:	10 37       	cp.w	r7,r8
80005610:	e0 88 00 14 	brls	80005638 <vTaskDelayUntil+0x50>
80005614:	c0 a8       	rjmp	80005628 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80005616:	0e 38       	cp.w	r8,r7
80005618:	e0 8b 00 16 	brhi	80005644 <vTaskDelayUntil+0x5c>
8000561c:	48 e8       	lddpc	r8,80005654 <vTaskDelayUntil+0x6c>
8000561e:	70 08       	ld.w	r8,r8[0x0]
80005620:	10 37       	cp.w	r7,r8
80005622:	e0 8b 00 11 	brhi	80005644 <vTaskDelayUntil+0x5c>
80005626:	c1 18       	rjmp	80005648 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005628:	48 c8       	lddpc	r8,80005658 <vTaskDelayUntil+0x70>
8000562a:	70 0c       	ld.w	r12,r8[0x0]
8000562c:	2f cc       	sub	r12,-4
8000562e:	f0 1f 00 0c 	mcall	8000565c <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80005632:	0e 9c       	mov	r12,r7
80005634:	f0 1f 00 0b 	mcall	80005660 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80005638:	f0 1f 00 0b 	mcall	80005664 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
8000563c:	c0 81       	brne	8000564c <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
8000563e:	d7 33       	scall
80005640:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005644:	8d 07       	st.w	r6[0x0],r7
80005646:	cf 1b       	rjmp	80005628 <vTaskDelayUntil+0x40>
80005648:	8d 07       	st.w	r6[0x0],r7
8000564a:	cf 7b       	rjmp	80005638 <vTaskDelayUntil+0x50>
8000564c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005650:	80 00       	ld.sh	r0,r0[0x0]
80005652:	50 a0       	stdsp	sp[0x28],r0
80005654:	00 00       	add	r0,r0
80005656:	0c 64       	and	r4,r6
80005658:	00 00       	add	r0,r0
8000565a:	0c 38       	cp.w	r8,r6
8000565c:	80 00       	ld.sh	r0,r0[0x0]
8000565e:	48 fa       	lddpc	r10,80005698 <vTaskPlaceOnEventList+0x30>
80005660:	80 00       	ld.sh	r0,r0[0x0]
80005662:	55 44       	stdsp	sp[0x150],r4
80005664:	80 00       	ld.sh	r0,r0[0x0]
80005666:	54 5c       	stdsp	sp[0x114],r12

80005668 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80005668:	eb cd 40 c0 	pushm	r6-r7,lr
8000566c:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
8000566e:	48 e7       	lddpc	r7,800056a4 <vTaskPlaceOnEventList+0x3c>
80005670:	6e 0b       	ld.w	r11,r7[0x0]
80005672:	2e 8b       	sub	r11,-24
80005674:	f0 1f 00 0d 	mcall	800056a8 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005678:	6e 0c       	ld.w	r12,r7[0x0]
8000567a:	2f cc       	sub	r12,-4
8000567c:	f0 1f 00 0c 	mcall	800056ac <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80005680:	5b f6       	cp.w	r6,-1
80005682:	c0 81       	brne	80005692 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005684:	6e 0b       	ld.w	r11,r7[0x0]
80005686:	2f cb       	sub	r11,-4
80005688:	48 ac       	lddpc	r12,800056b0 <vTaskPlaceOnEventList+0x48>
8000568a:	f0 1f 00 0b 	mcall	800056b4 <vTaskPlaceOnEventList+0x4c>
8000568e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80005692:	48 a8       	lddpc	r8,800056b8 <vTaskPlaceOnEventList+0x50>
80005694:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80005696:	ec 0c 00 0c 	add	r12,r6,r12
8000569a:	f0 1f 00 09 	mcall	800056bc <vTaskPlaceOnEventList+0x54>
8000569e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800056a2:	00 00       	add	r0,r0
800056a4:	00 00       	add	r0,r0
800056a6:	0c 38       	cp.w	r8,r6
800056a8:	80 00       	ld.sh	r0,r0[0x0]
800056aa:	48 c6       	lddpc	r6,800056d8 <prvIdleTask+0x18>
800056ac:	80 00       	ld.sh	r0,r0[0x0]
800056ae:	48 fa       	lddpc	r10,800056e8 <prvIdleTask+0x28>
800056b0:	00 00       	add	r0,r0
800056b2:	0c 8c       	andn	r12,r6
800056b4:	80 00       	ld.sh	r0,r0[0x0]
800056b6:	48 aa       	lddpc	r10,800056dc <prvIdleTask+0x1c>
800056b8:	00 00       	add	r0,r0
800056ba:	0c 64       	and	r4,r6
800056bc:	80 00       	ld.sh	r0,r0[0x0]
800056be:	55 44       	stdsp	sp[0x150],r4

800056c0 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
800056c0:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800056c4:	49 67       	lddpc	r7,8000571c <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800056c6:	49 74       	lddpc	r4,80005720 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
800056c8:	49 73       	lddpc	r3,80005724 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800056ca:	49 85       	lddpc	r5,80005728 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800056cc:	6e 08       	ld.w	r8,r7[0x0]
800056ce:	58 08       	cp.w	r8,0
800056d0:	c1 e0       	breq	8000570c <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
800056d2:	f0 1f 00 17 	mcall	8000572c <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800056d6:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
800056d8:	f0 1f 00 16 	mcall	80005730 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
800056dc:	58 06       	cp.w	r6,0
800056de:	c1 70       	breq	8000570c <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
800056e0:	f0 1f 00 15 	mcall	80005734 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
800056e4:	68 38       	ld.w	r8,r4[0xc]
800056e6:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
800056e8:	ec cc ff fc 	sub	r12,r6,-4
800056ec:	f0 1f 00 13 	mcall	80005738 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
800056f0:	66 08       	ld.w	r8,r3[0x0]
800056f2:	20 18       	sub	r8,1
800056f4:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
800056f6:	6e 08       	ld.w	r8,r7[0x0]
800056f8:	20 18       	sub	r8,1
800056fa:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
800056fc:	f0 1f 00 10 	mcall	8000573c <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80005700:	6c cc       	ld.w	r12,r6[0x30]
80005702:	f0 1f 00 10 	mcall	80005740 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80005706:	0c 9c       	mov	r12,r6
80005708:	f0 1f 00 0e 	mcall	80005740 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
8000570c:	6a 08       	ld.w	r8,r5[0x0]
8000570e:	58 18       	cp.w	r8,1
80005710:	e0 88 00 03 	brls	80005716 <prvIdleTask+0x56>
			{
				taskYIELD();
80005714:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80005716:	f0 1f 00 0c 	mcall	80005744 <prvIdleTask+0x84>
		}
		#endif
	}
8000571a:	cd 9b       	rjmp	800056cc <prvIdleTask+0xc>
8000571c:	00 00       	add	r0,r0
8000571e:	0b 78       	ld.ub	r8,--r5
80005720:	00 00       	add	r0,r0
80005722:	0c 24       	rsub	r4,r6
80005724:	00 00       	add	r0,r0
80005726:	0c 84       	andn	r4,r6
80005728:	00 00       	add	r0,r0
8000572a:	0b 84       	ld.ub	r4,r5[0x0]
8000572c:	80 00       	ld.sh	r0,r0[0x0]
8000572e:	50 a0       	stdsp	sp[0x28],r0
80005730:	80 00       	ld.sh	r0,r0[0x0]
80005732:	54 5c       	stdsp	sp[0x114],r12
80005734:	80 00       	ld.sh	r0,r0[0x0]
80005736:	49 b4       	lddpc	r4,800057a0 <xTaskGenericCreate+0x58>
80005738:	80 00       	ld.sh	r0,r0[0x0]
8000573a:	48 fa       	lddpc	r10,80005774 <xTaskGenericCreate+0x2c>
8000573c:	80 00       	ld.sh	r0,r0[0x0]
8000573e:	4a c0       	lddpc	r0,800057ec <xTaskGenericCreate+0xa4>
80005740:	80 00       	ld.sh	r0,r0[0x0]
80005742:	4b f8       	lddpc	r8,8000583c <xTaskGenericCreate+0xf4>
80005744:	80 00       	ld.sh	r0,r0[0x0]
80005746:	20 2c       	sub	r12,2

80005748 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80005748:	d4 31       	pushm	r0-r7,lr
8000574a:	20 1d       	sub	sp,4
8000574c:	fa c4 ff d8 	sub	r4,sp,-40
80005750:	50 0c       	stdsp	sp[0x0],r12
80005752:	16 91       	mov	r1,r11
80005754:	14 97       	mov	r7,r10
80005756:	12 90       	mov	r0,r9
80005758:	10 93       	mov	r3,r8
8000575a:	68 02       	ld.w	r2,r4[0x0]
8000575c:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
8000575e:	34 8c       	mov	r12,72
80005760:	f0 1f 00 5c 	mcall	800058d0 <xTaskGenericCreate+0x188>
80005764:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80005766:	c0 31       	brne	8000576c <xTaskGenericCreate+0x24>
80005768:	3f fc       	mov	r12,-1
8000576a:	ca f8       	rjmp	800058c8 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
8000576c:	58 06       	cp.w	r6,0
8000576e:	e0 81 00 af 	brne	800058cc <xTaskGenericCreate+0x184>
80005772:	0e 9c       	mov	r12,r7
80005774:	5c 7c       	castu.h	r12
80005776:	a3 6c       	lsl	r12,0x2
80005778:	f0 1f 00 56 	mcall	800058d0 <xTaskGenericCreate+0x188>
8000577c:	18 96       	mov	r6,r12
8000577e:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80005780:	c0 61       	brne	8000578c <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80005782:	0a 9c       	mov	r12,r5
80005784:	f0 1f 00 54 	mcall	800058d4 <xTaskGenericCreate+0x18c>
80005788:	3f fc       	mov	r12,-1
8000578a:	c9 f8       	rjmp	800058c8 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
8000578c:	5c 77       	castu.h	r7
8000578e:	ee 0a 15 02 	lsl	r10,r7,0x2
80005792:	e0 6b 00 a5 	mov	r11,165
80005796:	0c 9c       	mov	r12,r6
80005798:	f0 1f 00 50 	mcall	800058d8 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
8000579c:	ee c6 00 01 	sub	r6,r7,1
800057a0:	6a c8       	ld.w	r8,r5[0x30]
800057a2:	f0 06 00 26 	add	r6,r8,r6<<0x2
800057a6:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
800057aa:	31 0a       	mov	r10,16
800057ac:	02 9b       	mov	r11,r1
800057ae:	ea cc ff cc 	sub	r12,r5,-52
800057b2:	f0 1f 00 4b 	mcall	800058dc <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
800057b6:	30 08       	mov	r8,0
800057b8:	eb 68 00 43 	st.b	r5[67],r8
800057bc:	58 73       	cp.w	r3,7
800057be:	e6 07 17 80 	movls	r7,r3
800057c2:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
800057c6:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
800057c8:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
800057cc:	ea c4 ff fc 	sub	r4,r5,-4
800057d0:	08 9c       	mov	r12,r4
800057d2:	f0 1f 00 44 	mcall	800058e0 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
800057d6:	ea cc ff e8 	sub	r12,r5,-24
800057da:	f0 1f 00 42 	mcall	800058e0 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
800057de:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
800057e0:	ee 07 11 08 	rsub	r7,r7,8
800057e4:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
800057e6:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
800057e8:	00 9a       	mov	r10,r0
800057ea:	40 0b       	lddsp	r11,sp[0x0]
800057ec:	0c 9c       	mov	r12,r6
800057ee:	f0 1f 00 3e 	mcall	800058e4 <xTaskGenericCreate+0x19c>
800057f2:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
800057f4:	58 02       	cp.w	r2,0
800057f6:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
800057fa:	f0 1f 00 3c 	mcall	800058e8 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
800057fe:	4b c8       	lddpc	r8,800058ec <xTaskGenericCreate+0x1a4>
80005800:	70 09       	ld.w	r9,r8[0x0]
80005802:	2f f9       	sub	r9,-1
80005804:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80005806:	4b b8       	lddpc	r8,800058f0 <xTaskGenericCreate+0x1a8>
80005808:	70 08       	ld.w	r8,r8[0x0]
8000580a:	58 08       	cp.w	r8,0
8000580c:	c2 61       	brne	80005858 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
8000580e:	4b 98       	lddpc	r8,800058f0 <xTaskGenericCreate+0x1a8>
80005810:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80005812:	4b 78       	lddpc	r8,800058ec <xTaskGenericCreate+0x1a4>
80005814:	70 08       	ld.w	r8,r8[0x0]
80005816:	58 18       	cp.w	r8,1
80005818:	c2 b1       	brne	8000586e <xTaskGenericCreate+0x126>
8000581a:	4b 77       	lddpc	r7,800058f4 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
8000581c:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80005820:	0e 9c       	mov	r12,r7
80005822:	f0 1f 00 36 	mcall	800058f8 <xTaskGenericCreate+0x1b0>
80005826:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80005828:	0c 37       	cp.w	r7,r6
8000582a:	cf b1       	brne	80005820 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
8000582c:	4b 47       	lddpc	r7,800058fc <xTaskGenericCreate+0x1b4>
8000582e:	0e 9c       	mov	r12,r7
80005830:	f0 1f 00 32 	mcall	800058f8 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80005834:	4b 36       	lddpc	r6,80005900 <xTaskGenericCreate+0x1b8>
80005836:	0c 9c       	mov	r12,r6
80005838:	f0 1f 00 30 	mcall	800058f8 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
8000583c:	4b 2c       	lddpc	r12,80005904 <xTaskGenericCreate+0x1bc>
8000583e:	f0 1f 00 2f 	mcall	800058f8 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80005842:	4b 2c       	lddpc	r12,80005908 <xTaskGenericCreate+0x1c0>
80005844:	f0 1f 00 2d 	mcall	800058f8 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80005848:	4b 1c       	lddpc	r12,8000590c <xTaskGenericCreate+0x1c4>
8000584a:	f0 1f 00 2c 	mcall	800058f8 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
8000584e:	4b 18       	lddpc	r8,80005910 <xTaskGenericCreate+0x1c8>
80005850:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80005852:	4b 18       	lddpc	r8,80005914 <xTaskGenericCreate+0x1cc>
80005854:	91 06       	st.w	r8[0x0],r6
80005856:	c0 c8       	rjmp	8000586e <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80005858:	4b 08       	lddpc	r8,80005918 <xTaskGenericCreate+0x1d0>
8000585a:	70 08       	ld.w	r8,r8[0x0]
8000585c:	58 08       	cp.w	r8,0
8000585e:	c0 81       	brne	8000586e <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80005860:	4a 48       	lddpc	r8,800058f0 <xTaskGenericCreate+0x1a8>
80005862:	70 08       	ld.w	r8,r8[0x0]
80005864:	70 b8       	ld.w	r8,r8[0x2c]
80005866:	10 33       	cp.w	r3,r8
80005868:	c0 33       	brcs	8000586e <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
8000586a:	4a 28       	lddpc	r8,800058f0 <xTaskGenericCreate+0x1a8>
8000586c:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
8000586e:	6a b8       	ld.w	r8,r5[0x2c]
80005870:	4a b9       	lddpc	r9,8000591c <xTaskGenericCreate+0x1d4>
80005872:	72 09       	ld.w	r9,r9[0x0]
80005874:	12 38       	cp.w	r8,r9
80005876:	e0 88 00 04 	brls	8000587e <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
8000587a:	4a 99       	lddpc	r9,8000591c <xTaskGenericCreate+0x1d4>
8000587c:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
8000587e:	4a 98       	lddpc	r8,80005920 <xTaskGenericCreate+0x1d8>
80005880:	70 09       	ld.w	r9,r8[0x0]
80005882:	2f f9       	sub	r9,-1
80005884:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80005886:	6a b8       	ld.w	r8,r5[0x2c]
80005888:	4a 79       	lddpc	r9,80005924 <xTaskGenericCreate+0x1dc>
8000588a:	72 09       	ld.w	r9,r9[0x0]
8000588c:	12 38       	cp.w	r8,r9
8000588e:	e0 88 00 04 	brls	80005896 <xTaskGenericCreate+0x14e>
80005892:	4a 59       	lddpc	r9,80005924 <xTaskGenericCreate+0x1dc>
80005894:	93 08       	st.w	r9[0x0],r8
80005896:	6a bc       	ld.w	r12,r5[0x2c]
80005898:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000589c:	08 9b       	mov	r11,r4
8000589e:	49 68       	lddpc	r8,800058f4 <xTaskGenericCreate+0x1ac>
800058a0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800058a4:	f0 1f 00 21 	mcall	80005928 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
800058a8:	f0 1f 00 21 	mcall	8000592c <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
800058ac:	49 b8       	lddpc	r8,80005918 <xTaskGenericCreate+0x1d0>
800058ae:	70 08       	ld.w	r8,r8[0x0]
800058b0:	58 08       	cp.w	r8,0
800058b2:	c0 a0       	breq	800058c6 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
800058b4:	48 f8       	lddpc	r8,800058f0 <xTaskGenericCreate+0x1a8>
800058b6:	70 08       	ld.w	r8,r8[0x0]
800058b8:	70 b8       	ld.w	r8,r8[0x2c]
800058ba:	10 33       	cp.w	r3,r8
800058bc:	e0 88 00 05 	brls	800058c6 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
800058c0:	d7 33       	scall
800058c2:	30 1c       	mov	r12,1
800058c4:	c0 28       	rjmp	800058c8 <xTaskGenericCreate+0x180>
800058c6:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
800058c8:	2f fd       	sub	sp,-4
800058ca:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800058cc:	99 c6       	st.w	r12[0x30],r6
800058ce:	c5 fb       	rjmp	8000578c <xTaskGenericCreate+0x44>
800058d0:	80 00       	ld.sh	r0,r0[0x0]
800058d2:	4c 20       	lddpc	r0,800059d8 <PrintHex+0x58>
800058d4:	80 00       	ld.sh	r0,r0[0x0]
800058d6:	4b f8       	lddpc	r8,800059d0 <PrintHex+0x50>
800058d8:	80 00       	ld.sh	r0,r0[0x0]
800058da:	63 6e       	ld.w	lr,r1[0x58]
800058dc:	80 00       	ld.sh	r0,r0[0x0]
800058de:	66 98       	ld.w	r8,r3[0x24]
800058e0:	80 00       	ld.sh	r0,r0[0x0]
800058e2:	48 a4       	lddpc	r4,80005908 <xTaskGenericCreate+0x1c0>
800058e4:	80 00       	ld.sh	r0,r0[0x0]
800058e6:	49 20       	lddpc	r0,8000592c <xTaskGenericCreate+0x1e4>
800058e8:	80 00       	ld.sh	r0,r0[0x0]
800058ea:	49 b4       	lddpc	r4,80005954 <vTaskStartScheduler+0x24>
800058ec:	00 00       	add	r0,r0
800058ee:	0c 84       	andn	r4,r6
800058f0:	00 00       	add	r0,r0
800058f2:	0c 38       	cp.w	r8,r6
800058f4:	00 00       	add	r0,r0
800058f6:	0b 84       	ld.ub	r4,r5[0x0]
800058f8:	80 00       	ld.sh	r0,r0[0x0]
800058fa:	48 90       	lddpc	r0,8000591c <xTaskGenericCreate+0x1d4>
800058fc:	00 00       	add	r0,r0
800058fe:	0c 50       	eor	r0,r6
80005900:	00 00       	add	r0,r0
80005902:	0c 6c       	and	r12,r6
80005904:	00 00       	add	r0,r0
80005906:	0c 3c       	cp.w	r12,r6
80005908:	00 00       	add	r0,r0
8000590a:	0c 24       	rsub	r4,r6
8000590c:	00 00       	add	r0,r0
8000590e:	0c 8c       	andn	r12,r6
80005910:	00 00       	add	r0,r0
80005912:	0b 70       	ld.ub	r0,--r5
80005914:	00 00       	add	r0,r0
80005916:	0b 80       	ld.ub	r0,r5[0x0]
80005918:	00 00       	add	r0,r0
8000591a:	0b 74       	ld.ub	r4,--r5
8000591c:	00 00       	add	r0,r0
8000591e:	0b 6c       	ld.uh	r12,--r5
80005920:	00 00       	add	r0,r0
80005922:	0c 80       	andn	r0,r6
80005924:	00 00       	add	r0,r0
80005926:	0c a0       	st.w	r6++,r0
80005928:	80 00       	ld.sh	r0,r0[0x0]
8000592a:	48 aa       	lddpc	r10,80005950 <vTaskStartScheduler+0x20>
8000592c:	80 00       	ld.sh	r0,r0[0x0]
8000592e:	4a c0       	lddpc	r0,800059dc <PrintHex+0x5c>

80005930 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80005930:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80005932:	30 09       	mov	r9,0
80005934:	1a d9       	st.w	--sp,r9
80005936:	1a d9       	st.w	--sp,r9
80005938:	1a d9       	st.w	--sp,r9
8000593a:	12 98       	mov	r8,r9
8000593c:	e0 6a 01 00 	mov	r10,256
80005940:	48 9b       	lddpc	r11,80005964 <vTaskStartScheduler+0x34>
80005942:	48 ac       	lddpc	r12,80005968 <vTaskStartScheduler+0x38>
80005944:	f0 1f 00 0a 	mcall	8000596c <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80005948:	2f dd       	sub	sp,-12
8000594a:	58 1c       	cp.w	r12,1
8000594c:	c0 a1       	brne	80005960 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
8000594e:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80005950:	30 19       	mov	r9,1
80005952:	48 88       	lddpc	r8,80005970 <vTaskStartScheduler+0x40>
80005954:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80005956:	30 09       	mov	r9,0
80005958:	48 78       	lddpc	r8,80005974 <vTaskStartScheduler+0x44>
8000595a:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
8000595c:	f0 1f 00 07 	mcall	80005978 <vTaskStartScheduler+0x48>
80005960:	d8 02       	popm	pc
80005962:	00 00       	add	r0,r0
80005964:	80 00       	ld.sh	r0,r0[0x0]
80005966:	c4 d8       	rjmp	80005a00 <PrintHex+0x80>
80005968:	80 00       	ld.sh	r0,r0[0x0]
8000596a:	56 c0       	stdsp	sp[0x1b0],r0
8000596c:	80 00       	ld.sh	r0,r0[0x0]
8000596e:	57 48       	stdsp	sp[0x1d0],r8
80005970:	00 00       	add	r0,r0
80005972:	0b 74       	ld.ub	r4,--r5
80005974:	00 00       	add	r0,r0
80005976:	0c 64       	and	r4,r6
80005978:	80 00       	ld.sh	r0,r0[0x0]
8000597a:	49 c4       	lddpc	r4,800059e8 <PrintHex+0x68>

8000597c <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
8000597c:	16 cc       	st.b	r11++,r12
	return str;
}
8000597e:	5e fb       	retal	r11

80005980 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80005980:	eb cd 40 c0 	pushm	r6-r7,lr
80005984:	20 3d       	sub	sp,12
80005986:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80005988:	30 06       	mov	r6,0
8000598a:	30 07       	mov	r7,0
8000598c:	fa e7 00 00 	st.d	sp[0],r6
80005990:	30 0c       	mov	r12,0
80005992:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80005994:	58 08       	cp.w	r8,0
80005996:	c1 30       	breq	800059bc <PrintHex+0x3c>
80005998:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
8000599a:	1a 9c       	mov	r12,sp
8000599c:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
800059a0:	58 9e       	cp.w	lr,9
800059a2:	e0 8a 00 04 	brle	800059aa <PrintHex+0x2a>
800059a6:	2c 9e       	sub	lr,-55
800059a8:	c0 48       	rjmp	800059b0 <PrintHex+0x30>
800059aa:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
800059ae:	2d 0e       	sub	lr,-48
800059b0:	f8 09 0b 0e 	st.b	r12[r9],lr
800059b4:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
800059b6:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
800059b8:	cf 21       	brne	8000599c <PrintHex+0x1c>
800059ba:	c0 48       	rjmp	800059c2 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
800059bc:	33 08       	mov	r8,48
800059be:	ba 88       	st.b	sp[0x0],r8
800059c0:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
800059c2:	f6 09 01 08 	sub	r8,r11,r9
800059c6:	58 08       	cp.w	r8,0
800059c8:	e0 8a 00 13 	brle	800059ee <PrintHex+0x6e>
	{
		char num = len - cnt;
800059cc:	12 1b       	sub	r11,r9
800059ce:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
800059d2:	18 9e       	mov	lr,r12
800059d4:	58 0c       	cp.w	r12,0
800059d6:	e0 8a 00 0c 	brle	800059ee <PrintHex+0x6e>
800059da:	1a 9b       	mov	r11,sp
800059dc:	12 0b       	add	r11,r9
800059de:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
800059e0:	33 07       	mov	r7,48
800059e2:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
800059e4:	2f f8       	sub	r8,-1
800059e6:	1c 38       	cp.w	r8,lr
800059e8:	cf d5       	brlt	800059e2 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
800059ea:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
800059ee:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
800059f2:	f0 cb ff ff 	sub	r11,r8,-1
800059f6:	58 0b       	cp.w	r11,0
800059f8:	e0 8a 00 19 	brle	80005a2a <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
800059fc:	fa cb ff f4 	sub	r11,sp,-12
80005a00:	f6 09 00 09 	add	r9,r11,r9
80005a04:	37 8b       	mov	r11,120
80005a06:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80005a0a:	fa c9 ff f4 	sub	r9,sp,-12
80005a0e:	10 09       	add	r9,r8
80005a10:	33 0b       	mov	r11,48
80005a12:	f3 6b ff f4 	st.b	r9[-12],r11
80005a16:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80005a1a:	fa ce 00 01 	sub	lr,sp,1
80005a1e:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80005a20:	11 8b       	ld.ub	r11,r8[0x0]
80005a22:	12 cb       	st.b	r9++,r11
80005a24:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80005a26:	1c 38       	cp.w	r8,lr
80005a28:	cf c1       	brne	80005a20 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80005a2a:	14 9c       	mov	r12,r10
80005a2c:	2f dd       	sub	sp,-12
80005a2e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80005a32 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80005a32:	d4 21       	pushm	r4-r7,lr
80005a34:	20 3d       	sub	sp,12
80005a36:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80005a38:	30 06       	mov	r6,0
80005a3a:	30 07       	mov	r7,0
80005a3c:	fa e7 00 00 	st.d	sp[0],r6
80005a40:	30 0c       	mov	r12,0
80005a42:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80005a44:	58 08       	cp.w	r8,0
80005a46:	c0 35       	brlt	80005a4c <PrintDec+0x1a>
80005a48:	14 97       	mov	r7,r10
80005a4a:	c0 58       	rjmp	80005a54 <PrintDec+0x22>
	{
		*p++ = '-';
80005a4c:	14 97       	mov	r7,r10
80005a4e:	32 d9       	mov	r9,45
80005a50:	0e c9       	st.b	r7++,r9
		i = -i;
80005a52:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80005a54:	58 08       	cp.w	r8,0
80005a56:	c0 51       	brne	80005a60 <PrintDec+0x2e>
80005a58:	33 08       	mov	r8,48
80005a5a:	ba 88       	st.b	sp[0x0],r8
80005a5c:	30 1e       	mov	lr,1
80005a5e:	c2 f8       	rjmp	80005abc <PrintDec+0x8a>
	
	int ten = i%10;
80005a60:	e0 65 66 67 	mov	r5,26215
80005a64:	ea 15 66 66 	orh	r5,0x6666
80005a68:	f0 05 04 44 	muls.d	r4,r8,r5
80005a6c:	ea 0c 14 02 	asr	r12,r5,0x2
80005a70:	f0 09 14 1f 	asr	r9,r8,0x1f
80005a74:	f8 09 01 09 	sub	r9,r12,r9
80005a78:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005a7c:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80005a80:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80005a82:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80005a84:	e0 66 66 67 	mov	r6,26215
80005a88:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80005a8c:	2d 09       	sub	r9,-48
80005a8e:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80005a92:	2f fe       	sub	lr,-1
		i /= 10;
80005a94:	f0 06 04 44 	muls.d	r4,r8,r6
80005a98:	ea 09 14 02 	asr	r9,r5,0x2
80005a9c:	bf 58       	asr	r8,0x1f
80005a9e:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80005aa2:	f0 06 04 44 	muls.d	r4,r8,r6
80005aa6:	ea 09 14 02 	asr	r9,r5,0x2
80005aaa:	f0 05 14 1f 	asr	r5,r8,0x1f
80005aae:	0a 19       	sub	r9,r5
80005ab0:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005ab4:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80005ab8:	58 08       	cp.w	r8,0
80005aba:	ce 91       	brne	80005a8c <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80005abc:	f6 0e 01 08 	sub	r8,r11,lr
80005ac0:	58 08       	cp.w	r8,0
80005ac2:	e0 89 00 06 	brgt	80005ace <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80005ac6:	58 0e       	cp.w	lr,0
80005ac8:	e0 89 00 14 	brgt	80005af0 <PrintDec+0xbe>
80005acc:	c1 d8       	rjmp	80005b06 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80005ace:	1c 1b       	sub	r11,lr
80005ad0:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80005ad2:	16 9c       	mov	r12,r11
80005ad4:	58 0b       	cp.w	r11,0
80005ad6:	fe 9a ff f8 	brle	80005ac6 <PrintDec+0x94>
80005ada:	1a 99       	mov	r9,sp
80005adc:	1c 09       	add	r9,lr
80005ade:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80005ae0:	33 06       	mov	r6,48
80005ae2:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80005ae4:	2f f8       	sub	r8,-1
80005ae6:	18 38       	cp.w	r8,r12
80005ae8:	cf d5       	brlt	80005ae2 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80005aea:	f6 0e 00 0e 	add	lr,r11,lr
80005aee:	ce cb       	rjmp	80005ac6 <PrintDec+0x94>
80005af0:	fa c8 ff f4 	sub	r8,sp,-12
80005af4:	1c 08       	add	r8,lr
80005af6:	20 d8       	sub	r8,13
80005af8:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80005afc:	11 89       	ld.ub	r9,r8[0x0]
80005afe:	0e c9       	st.b	r7++,r9
80005b00:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80005b02:	16 38       	cp.w	r8,r11
80005b04:	cf c1       	brne	80005afc <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80005b06:	14 9c       	mov	r12,r10
80005b08:	2f dd       	sub	sp,-12
80005b0a:	d8 22       	popm	r4-r7,pc

80005b0c <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80005b0c:	d4 31       	pushm	r0-r7,lr
80005b0e:	fa cd 02 08 	sub	sp,sp,520
80005b12:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80005b14:	e0 6a 01 00 	mov	r10,256
80005b18:	30 0b       	mov	r11,0
80005b1a:	fa cc fe f8 	sub	r12,sp,-264
80005b1e:	f0 1f 00 4e 	mcall	80005c54 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80005b22:	fa c4 fd d4 	sub	r4,sp,-556
80005b26:	30 0a       	mov	r10,0
80005b28:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005b2a:	fa c3 ff fc 	sub	r3,sp,-4
80005b2e:	e0 61 01 00 	mov	r1,256
80005b32:	14 90       	mov	r0,r10
			
					if(*str == '%')
80005b34:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80005b36:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005b3a:	02 9a       	mov	r10,r1
80005b3c:	00 9b       	mov	r11,r0
80005b3e:	06 9c       	mov	r12,r3
80005b40:	f0 1f 00 45 	mcall	80005c54 <log+0x148>
			
					if(*str == '%')
80005b44:	0f 88       	ld.ub	r8,r7[0x0]
80005b46:	e4 08 18 00 	cp.b	r8,r2
80005b4a:	c5 71       	brne	80005bf8 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80005b4c:	ee c8 ff ff 	sub	r8,r7,-1
80005b50:	11 89       	ld.ub	r9,r8[0x0]
80005b52:	4c 2a       	lddpc	r10,80005c58 <log+0x14c>
80005b54:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80005b56:	23 09       	sub	r9,48
80005b58:	30 9a       	mov	r10,9
80005b5a:	f4 09 18 00 	cp.b	r9,r10
80005b5e:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80005b62:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80005b66:	f7 b9 08 30 	subls	r9,48
80005b6a:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80005b6e:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80005b72:	0f 88       	ld.ub	r8,r7[0x0]
80005b74:	22 58       	sub	r8,37
80005b76:	e0 48 00 53 	cp.w	r8,83
80005b7a:	e0 8b 00 31 	brhi	80005bdc <log+0xd0>
80005b7e:	4b 89       	lddpc	r9,80005c5c <log+0x150>
80005b80:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80005b84:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80005b88:	06 9a       	mov	r10,r3
80005b8a:	40 0b       	lddsp	r11,sp[0x0]
80005b8c:	5c 5b       	castu.b	r11
80005b8e:	68 0c       	ld.w	r12,r4[0x0]
80005b90:	f0 1f 00 34 	mcall	80005c60 <log+0x154>
							break;
80005b94:	c2 98       	rjmp	80005be6 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80005b96:	4b 4c       	lddpc	r12,80005c64 <log+0x158>
80005b98:	f0 1f 00 34 	mcall	80005c68 <log+0x15c>
80005b9c:	08 95       	mov	r5,r4
80005b9e:	06 9c       	mov	r12,r3
							break;
80005ba0:	c2 38       	rjmp	80005be6 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80005ba2:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80005ba6:	06 9a       	mov	r10,r3
80005ba8:	40 0b       	lddsp	r11,sp[0x0]
80005baa:	5c 5b       	castu.b	r11
80005bac:	68 0c       	ld.w	r12,r4[0x0]
80005bae:	f0 1f 00 30 	mcall	80005c6c <log+0x160>
80005bb2:	06 9c       	mov	r12,r3
							break;
80005bb4:	c1 98       	rjmp	80005be6 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80005bb6:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80005bba:	06 9b       	mov	r11,r3
80005bbc:	09 bc       	ld.ub	r12,r4[0x3]
80005bbe:	f0 1f 00 2d 	mcall	80005c70 <log+0x164>
80005bc2:	06 9c       	mov	r12,r3
							break;
80005bc4:	c1 18       	rjmp	80005be6 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80005bc6:	e8 c5 ff fc 	sub	r5,r4,-4
80005bca:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80005bcc:	c0 d8       	rjmp	80005be6 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80005bce:	06 9b       	mov	r11,r3
80005bd0:	32 5c       	mov	r12,37
80005bd2:	f0 1f 00 28 	mcall	80005c70 <log+0x164>
80005bd6:	08 95       	mov	r5,r4
80005bd8:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80005bda:	c0 68       	rjmp	80005be6 <log+0xda>
							
							default:
							log("I need relax.");
80005bdc:	4a 6c       	lddpc	r12,80005c74 <log+0x168>
80005bde:	f0 1f 00 23 	mcall	80005c68 <log+0x15c>
80005be2:	08 95       	mov	r5,r4
80005be4:	06 9c       	mov	r12,r3
						}
						str++;
80005be6:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80005be8:	1a dc       	st.w	--sp,r12
80005bea:	1a d6       	st.w	--sp,r6
80005bec:	4a 3b       	lddpc	r11,80005c78 <log+0x16c>
80005bee:	0c 9c       	mov	r12,r6
80005bf0:	f0 1f 00 23 	mcall	80005c7c <log+0x170>
80005bf4:	2f ed       	sub	sp,-8
80005bf6:	c0 a8       	rjmp	80005c0a <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80005bf8:	2f f7       	sub	r7,-1
80005bfa:	1a d8       	st.w	--sp,r8
80005bfc:	1a d6       	st.w	--sp,r6
80005bfe:	4a 1b       	lddpc	r11,80005c80 <log+0x174>
80005c00:	0c 9c       	mov	r12,r6
80005c02:	f0 1f 00 1f 	mcall	80005c7c <log+0x170>
80005c06:	08 95       	mov	r5,r4
80005c08:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80005c0a:	0f 89       	ld.ub	r9,r7[0x0]
80005c0c:	30 08       	mov	r8,0
80005c0e:	f0 09 18 00 	cp.b	r9,r8
80005c12:	c0 30       	breq	80005c18 <log+0x10c>
80005c14:	0a 94       	mov	r4,r5
80005c16:	c9 2b       	rjmp	80005b3a <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80005c18:	fa c7 fe f8 	sub	r7,sp,-264
80005c1c:	1a d7       	st.w	--sp,r7
80005c1e:	49 ab       	lddpc	r11,80005c84 <log+0x178>
80005c20:	0e 9c       	mov	r12,r7
80005c22:	f0 1f 00 17 	mcall	80005c7c <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80005c26:	5c 5c       	castu.b	r12
80005c28:	f8 c6 ff ff 	sub	r6,r12,-1
80005c2c:	0c 9c       	mov	r12,r6
80005c2e:	f0 1f 00 17 	mcall	80005c88 <log+0x17c>
80005c32:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80005c34:	0c 9a       	mov	r10,r6
80005c36:	0e 9b       	mov	r11,r7
80005c38:	f0 1f 00 15 	mcall	80005c8c <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80005c3c:	30 09       	mov	r9,0
80005c3e:	30 5a       	mov	r10,5
80005c40:	fa cb fe f8 	sub	r11,sp,-264
80005c44:	49 38       	lddpc	r8,80005c90 <log+0x184>
80005c46:	70 0c       	ld.w	r12,r8[0x0]
80005c48:	f0 1f 00 13 	mcall	80005c94 <log+0x188>
80005c4c:	2f fd       	sub	sp,-4
	
	
}
80005c4e:	fe 3d fd f8 	sub	sp,-520
80005c52:	d8 32       	popm	r0-r7,pc
80005c54:	80 00       	ld.sh	r0,r0[0x0]
80005c56:	63 6e       	ld.w	lr,r1[0x58]
80005c58:	00 00       	add	r0,r0
80005c5a:	0c a4       	st.w	r6++,r4
80005c5c:	80 00       	ld.sh	r0,r0[0x0]
80005c5e:	c4 e0       	breq	80005cfa <log_init+0x62>
80005c60:	80 00       	ld.sh	r0,r0[0x0]
80005c62:	5a 32       	cp.w	r2,-29
80005c64:	80 00       	ld.sh	r0,r0[0x0]
80005c66:	c6 3c       	rcall	80005d2c <task_log+0x30>
80005c68:	80 00       	ld.sh	r0,r0[0x0]
80005c6a:	5b 0c       	cp.w	r12,-16
80005c6c:	80 00       	ld.sh	r0,r0[0x0]
80005c6e:	59 80       	cp.w	r0,24
80005c70:	80 00       	ld.sh	r0,r0[0x0]
80005c72:	59 7c       	cp.w	r12,23
80005c74:	80 00       	ld.sh	r0,r0[0x0]
80005c76:	c6 4c       	rcall	80005d3e <task_log+0x42>
80005c78:	80 00       	ld.sh	r0,r0[0x0]
80005c7a:	c6 5c       	rcall	80005d44 <main+0x4>
80005c7c:	80 00       	ld.sh	r0,r0[0x0]
80005c7e:	66 5c       	ld.w	r12,r3[0x14]
80005c80:	80 00       	ld.sh	r0,r0[0x0]
80005c82:	c6 64       	brge	80005d4e <main+0xe>
80005c84:	80 00       	ld.sh	r0,r0[0x0]
80005c86:	c6 6c       	rcall	80005d52 <main+0x12>
80005c88:	80 00       	ld.sh	r0,r0[0x0]
80005c8a:	4c 20       	lddpc	r0,80005d90 <main+0x50>
80005c8c:	80 00       	ld.sh	r0,r0[0x0]
80005c8e:	62 26       	ld.w	r6,r1[0x8]
80005c90:	00 00       	add	r0,r0
80005c92:	1f 9c       	ld.ub	r12,pc[0x1]
80005c94:	80 00       	ld.sh	r0,r0[0x0]
80005c96:	4e d4       	lddpc	r4,80005e48 <_malloc_r+0x80>

80005c98 <log_init>:
		
	return str;
}

void log_init(void)
{
80005c98:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80005c9a:	30 2b       	mov	r11,2
80005c9c:	48 fc       	lddpc	r12,80005cd8 <log_init+0x40>
80005c9e:	f0 1f 00 10 	mcall	80005cdc <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80005ca2:	e0 6a 36 00 	mov	r10,13824
80005ca6:	ea 1a 01 6e 	orh	r10,0x16e
80005caa:	48 eb       	lddpc	r11,80005ce0 <log_init+0x48>
80005cac:	fe 7c 18 00 	mov	r12,-59392
80005cb0:	f0 1f 00 0d 	mcall	80005ce4 <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80005cb4:	30 4b       	mov	r11,4
80005cb6:	33 2c       	mov	r12,50
80005cb8:	f0 1f 00 0c 	mcall	80005ce8 <log_init+0x50>
80005cbc:	48 c8       	lddpc	r8,80005cec <log_init+0x54>
80005cbe:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80005cc0:	30 09       	mov	r9,0
80005cc2:	1a d9       	st.w	--sp,r9
80005cc4:	1a d9       	st.w	--sp,r9
80005cc6:	1a d9       	st.w	--sp,r9
80005cc8:	30 28       	mov	r8,2
80005cca:	36 4a       	mov	r10,100
80005ccc:	48 9b       	lddpc	r11,80005cf0 <log_init+0x58>
80005cce:	48 ac       	lddpc	r12,80005cf4 <log_init+0x5c>
80005cd0:	f0 1f 00 0a 	mcall	80005cf8 <log_init+0x60>
80005cd4:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80005cd6:	d8 02       	popm	pc
80005cd8:	80 00       	ld.sh	r0,r0[0x0]
80005cda:	c6 78       	rjmp	80005da8 <free>
80005cdc:	80 00       	ld.sh	r0,r0[0x0]
80005cde:	3f a8       	mov	r8,-6
80005ce0:	80 00       	ld.sh	r0,r0[0x0]
80005ce2:	c6 30       	breq	80005da8 <free>
80005ce4:	80 00       	ld.sh	r0,r0[0x0]
80005ce6:	47 84       	lddsp	r4,sp[0x1e0]
80005ce8:	80 00       	ld.sh	r0,r0[0x0]
80005cea:	50 2c       	stdsp	sp[0x8],r12
80005cec:	00 00       	add	r0,r0
80005cee:	1f 9c       	ld.ub	r12,pc[0x1]
80005cf0:	80 00       	ld.sh	r0,r0[0x0]
80005cf2:	c6 74       	brge	80005dc0 <malloc+0x8>
80005cf4:	80 00       	ld.sh	r0,r0[0x0]
80005cf6:	5c fc       	rol	r12
80005cf8:	80 00       	ld.sh	r0,r0[0x0]
80005cfa:	57 48       	stdsp	sp[0x1d0],r8

80005cfc <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
80005cfc:	eb cd 40 f8 	pushm	r3-r7,lr
80005d00:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80005d02:	48 c7       	lddpc	r7,80005d30 <task_log+0x34>
80005d04:	30 05       	mov	r5,0
80005d06:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80005d08:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80005d0c:	0a 99       	mov	r9,r5
80005d0e:	08 9a       	mov	r10,r4
80005d10:	1a 9b       	mov	r11,sp
80005d12:	6e 0c       	ld.w	r12,r7[0x0]
80005d14:	f0 1f 00 08 	mcall	80005d34 <task_log+0x38>
80005d18:	58 1c       	cp.w	r12,1
80005d1a:	cf 91       	brne	80005d0c <task_log+0x10>
		{
			if( NULL != str)
80005d1c:	40 0b       	lddsp	r11,sp[0x0]
80005d1e:	58 0b       	cp.w	r11,0
80005d20:	cf 60       	breq	80005d0c <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80005d22:	06 9c       	mov	r12,r3
80005d24:	f0 1f 00 05 	mcall	80005d38 <task_log+0x3c>
				vPortFree(str);
80005d28:	40 0c       	lddsp	r12,sp[0x0]
80005d2a:	f0 1f 00 05 	mcall	80005d3c <task_log+0x40>
80005d2e:	ce fb       	rjmp	80005d0c <task_log+0x10>
80005d30:	00 00       	add	r0,r0
80005d32:	1f 9c       	ld.ub	r12,pc[0x1]
80005d34:	80 00       	ld.sh	r0,r0[0x0]
80005d36:	4d 18       	lddpc	r8,80005e78 <_malloc_r+0xb0>
80005d38:	80 00       	ld.sh	r0,r0[0x0]
80005d3a:	47 34       	lddsp	r4,sp[0x1cc]
80005d3c:	80 00       	ld.sh	r0,r0[0x0]
80005d3e:	4b f8       	lddpc	r8,80005e38 <_malloc_r+0x70>

80005d40 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
80005d40:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80005d42:	fe 78 10 00 	mov	r8,-61440
80005d46:	30 19       	mov	r9,1
80005d48:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80005d4c:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80005d50:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80005d54:	d3 03       	ssrf	0x10
	local_start_pll0();
80005d56:	f0 1f 00 0b 	mcall	80005d80 <main+0x40>
		
	INTC_init_interrupts();
80005d5a:	f0 1f 00 0b 	mcall	80005d84 <main+0x44>
		
	log_init();
80005d5e:	f0 1f 00 0b 	mcall	80005d88 <main+0x48>
	log("----start debug----");
80005d62:	48 bc       	lddpc	r12,80005d8c <main+0x4c>
80005d64:	f0 1f 00 0b 	mcall	80005d90 <main+0x50>
	
	xg_flashc_init();
80005d68:	f0 1f 00 0b 	mcall	80005d94 <main+0x54>

	//tc_init();
	
	//rfid_init();
		
	app_init();
80005d6c:	f0 1f 00 0b 	mcall	80005d98 <main+0x58>
	
	xg_rtc_init();
80005d70:	f0 1f 00 0b 	mcall	80005d9c <main+0x5c>
		
	//xcmp_init();

	local_start_timer();
80005d74:	f0 1f 00 0b 	mcall	80005da0 <main+0x60>
		
	vTaskStartScheduler();
80005d78:	f0 1f 00 0b 	mcall	80005da4 <main+0x64>
	return 0;
	
}
80005d7c:	d8 0a       	popm	pc,r12=0
80005d7e:	00 00       	add	r0,r0
80005d80:	80 00       	ld.sh	r0,r0[0x0]
80005d82:	3c 40       	mov	r0,-60
80005d84:	80 00       	ld.sh	r0,r0[0x0]
80005d86:	40 94       	lddsp	r4,sp[0x24]
80005d88:	80 00       	ld.sh	r0,r0[0x0]
80005d8a:	5c 98       	brev	r8
80005d8c:	80 00       	ld.sh	r0,r0[0x0]
80005d8e:	c6 88       	rjmp	80005e5e <_malloc_r+0x96>
80005d90:	80 00       	ld.sh	r0,r0[0x0]
80005d92:	5b 0c       	cp.w	r12,-16
80005d94:	80 00       	ld.sh	r0,r0[0x0]
80005d96:	3c d4       	mov	r4,-51
80005d98:	80 00       	ld.sh	r0,r0[0x0]
80005d9a:	20 3c       	sub	r12,3
80005d9c:	80 00       	ld.sh	r0,r0[0x0]
80005d9e:	30 38       	mov	r8,3
80005da0:	80 00       	ld.sh	r0,r0[0x0]
80005da2:	3c 14       	mov	r4,-63
80005da4:	80 00       	ld.sh	r0,r0[0x0]
80005da6:	59 30       	cp.w	r0,19

80005da8 <free>:
80005da8:	d4 01       	pushm	lr
80005daa:	e0 68 0a 18 	mov	r8,2584
80005dae:	18 9b       	mov	r11,r12
80005db0:	70 0c       	ld.w	r12,r8[0x0]
80005db2:	e0 a0 1e 73 	rcall	80009a98 <_free_r>
80005db6:	d8 02       	popm	pc

80005db8 <malloc>:
80005db8:	d4 01       	pushm	lr
80005dba:	e0 68 0a 18 	mov	r8,2584
80005dbe:	18 9b       	mov	r11,r12
80005dc0:	70 0c       	ld.w	r12,r8[0x0]
80005dc2:	c0 3c       	rcall	80005dc8 <_malloc_r>
80005dc4:	d8 02       	popm	pc
80005dc6:	d7 03       	nop

80005dc8 <_malloc_r>:
80005dc8:	d4 31       	pushm	r0-r7,lr
80005dca:	f6 c8 ff f5 	sub	r8,r11,-11
80005dce:	18 95       	mov	r5,r12
80005dd0:	10 97       	mov	r7,r8
80005dd2:	e0 17 ff f8 	andl	r7,0xfff8
80005dd6:	59 68       	cp.w	r8,22
80005dd8:	f9 b7 08 10 	movls	r7,16
80005ddc:	16 37       	cp.w	r7,r11
80005dde:	5f 38       	srlo	r8
80005de0:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80005de4:	c0 50       	breq	80005dee <_malloc_r+0x26>
80005de6:	30 c8       	mov	r8,12
80005de8:	99 38       	st.w	r12[0xc],r8
80005dea:	e0 8f 01 fa 	bral	800061de <_malloc_r+0x416>
80005dee:	fe b0 f6 bb 	rcall	80004b64 <__malloc_lock>
80005df2:	e0 47 01 f7 	cp.w	r7,503
80005df6:	e0 8b 00 1d 	brhi	80005e30 <_malloc_r+0x68>
80005dfa:	ee 03 16 03 	lsr	r3,r7,0x3
80005dfe:	e0 68 05 18 	mov	r8,1304
80005e02:	f0 03 00 38 	add	r8,r8,r3<<0x3
80005e06:	70 36       	ld.w	r6,r8[0xc]
80005e08:	10 36       	cp.w	r6,r8
80005e0a:	c0 61       	brne	80005e16 <_malloc_r+0x4e>
80005e0c:	ec c8 ff f8 	sub	r8,r6,-8
80005e10:	70 36       	ld.w	r6,r8[0xc]
80005e12:	10 36       	cp.w	r6,r8
80005e14:	c0 c0       	breq	80005e2c <_malloc_r+0x64>
80005e16:	6c 18       	ld.w	r8,r6[0x4]
80005e18:	e0 18 ff fc 	andl	r8,0xfffc
80005e1c:	6c 3a       	ld.w	r10,r6[0xc]
80005e1e:	ec 08 00 09 	add	r9,r6,r8
80005e22:	0a 9c       	mov	r12,r5
80005e24:	6c 28       	ld.w	r8,r6[0x8]
80005e26:	95 28       	st.w	r10[0x8],r8
80005e28:	91 3a       	st.w	r8[0xc],r10
80005e2a:	c4 78       	rjmp	80005eb8 <_malloc_r+0xf0>
80005e2c:	2f e3       	sub	r3,-2
80005e2e:	c4 d8       	rjmp	80005ec8 <_malloc_r+0x100>
80005e30:	ee 03 16 09 	lsr	r3,r7,0x9
80005e34:	c0 41       	brne	80005e3c <_malloc_r+0x74>
80005e36:	ee 03 16 03 	lsr	r3,r7,0x3
80005e3a:	c2 68       	rjmp	80005e86 <_malloc_r+0xbe>
80005e3c:	58 43       	cp.w	r3,4
80005e3e:	e0 8b 00 06 	brhi	80005e4a <_malloc_r+0x82>
80005e42:	ee 03 16 06 	lsr	r3,r7,0x6
80005e46:	2c 83       	sub	r3,-56
80005e48:	c1 f8       	rjmp	80005e86 <_malloc_r+0xbe>
80005e4a:	59 43       	cp.w	r3,20
80005e4c:	e0 8b 00 04 	brhi	80005e54 <_malloc_r+0x8c>
80005e50:	2a 53       	sub	r3,-91
80005e52:	c1 a8       	rjmp	80005e86 <_malloc_r+0xbe>
80005e54:	e0 43 00 54 	cp.w	r3,84
80005e58:	e0 8b 00 06 	brhi	80005e64 <_malloc_r+0x9c>
80005e5c:	ee 03 16 0c 	lsr	r3,r7,0xc
80005e60:	29 23       	sub	r3,-110
80005e62:	c1 28       	rjmp	80005e86 <_malloc_r+0xbe>
80005e64:	e0 43 01 54 	cp.w	r3,340
80005e68:	e0 8b 00 06 	brhi	80005e74 <_malloc_r+0xac>
80005e6c:	ee 03 16 0f 	lsr	r3,r7,0xf
80005e70:	28 93       	sub	r3,-119
80005e72:	c0 a8       	rjmp	80005e86 <_malloc_r+0xbe>
80005e74:	e0 43 05 54 	cp.w	r3,1364
80005e78:	e0 88 00 04 	brls	80005e80 <_malloc_r+0xb8>
80005e7c:	37 e3       	mov	r3,126
80005e7e:	c0 48       	rjmp	80005e86 <_malloc_r+0xbe>
80005e80:	ee 03 16 12 	lsr	r3,r7,0x12
80005e84:	28 43       	sub	r3,-124
80005e86:	e0 6a 05 18 	mov	r10,1304
80005e8a:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80005e8e:	74 36       	ld.w	r6,r10[0xc]
80005e90:	c1 98       	rjmp	80005ec2 <_malloc_r+0xfa>
80005e92:	6c 19       	ld.w	r9,r6[0x4]
80005e94:	e0 19 ff fc 	andl	r9,0xfffc
80005e98:	f2 07 01 0b 	sub	r11,r9,r7
80005e9c:	58 fb       	cp.w	r11,15
80005e9e:	e0 8a 00 04 	brle	80005ea6 <_malloc_r+0xde>
80005ea2:	20 13       	sub	r3,1
80005ea4:	c1 18       	rjmp	80005ec6 <_malloc_r+0xfe>
80005ea6:	6c 38       	ld.w	r8,r6[0xc]
80005ea8:	58 0b       	cp.w	r11,0
80005eaa:	c0 b5       	brlt	80005ec0 <_malloc_r+0xf8>
80005eac:	6c 2a       	ld.w	r10,r6[0x8]
80005eae:	ec 09 00 09 	add	r9,r6,r9
80005eb2:	0a 9c       	mov	r12,r5
80005eb4:	91 2a       	st.w	r8[0x8],r10
80005eb6:	95 38       	st.w	r10[0xc],r8
80005eb8:	72 18       	ld.w	r8,r9[0x4]
80005eba:	a1 a8       	sbr	r8,0x0
80005ebc:	93 18       	st.w	r9[0x4],r8
80005ebe:	cb c8       	rjmp	80006036 <_malloc_r+0x26e>
80005ec0:	10 96       	mov	r6,r8
80005ec2:	14 36       	cp.w	r6,r10
80005ec4:	ce 71       	brne	80005e92 <_malloc_r+0xca>
80005ec6:	2f f3       	sub	r3,-1
80005ec8:	e0 6a 05 18 	mov	r10,1304
80005ecc:	f4 cc ff f8 	sub	r12,r10,-8
80005ed0:	78 26       	ld.w	r6,r12[0x8]
80005ed2:	18 36       	cp.w	r6,r12
80005ed4:	c6 c0       	breq	80005fac <_malloc_r+0x1e4>
80005ed6:	6c 19       	ld.w	r9,r6[0x4]
80005ed8:	e0 19 ff fc 	andl	r9,0xfffc
80005edc:	f2 07 01 08 	sub	r8,r9,r7
80005ee0:	58 f8       	cp.w	r8,15
80005ee2:	e0 89 00 8f 	brgt	80006000 <_malloc_r+0x238>
80005ee6:	99 3c       	st.w	r12[0xc],r12
80005ee8:	99 2c       	st.w	r12[0x8],r12
80005eea:	58 08       	cp.w	r8,0
80005eec:	c0 55       	brlt	80005ef6 <_malloc_r+0x12e>
80005eee:	ec 09 00 09 	add	r9,r6,r9
80005ef2:	0a 9c       	mov	r12,r5
80005ef4:	ce 2b       	rjmp	80005eb8 <_malloc_r+0xf0>
80005ef6:	e0 49 01 ff 	cp.w	r9,511
80005efa:	e0 8b 00 13 	brhi	80005f20 <_malloc_r+0x158>
80005efe:	a3 99       	lsr	r9,0x3
80005f00:	f4 09 00 38 	add	r8,r10,r9<<0x3
80005f04:	70 2b       	ld.w	r11,r8[0x8]
80005f06:	8d 38       	st.w	r6[0xc],r8
80005f08:	8d 2b       	st.w	r6[0x8],r11
80005f0a:	97 36       	st.w	r11[0xc],r6
80005f0c:	91 26       	st.w	r8[0x8],r6
80005f0e:	a3 49       	asr	r9,0x2
80005f10:	74 18       	ld.w	r8,r10[0x4]
80005f12:	30 1b       	mov	r11,1
80005f14:	f6 09 09 49 	lsl	r9,r11,r9
80005f18:	f1 e9 10 09 	or	r9,r8,r9
80005f1c:	95 19       	st.w	r10[0x4],r9
80005f1e:	c4 78       	rjmp	80005fac <_malloc_r+0x1e4>
80005f20:	f2 0a 16 09 	lsr	r10,r9,0x9
80005f24:	58 4a       	cp.w	r10,4
80005f26:	e0 8b 00 07 	brhi	80005f34 <_malloc_r+0x16c>
80005f2a:	f2 0a 16 06 	lsr	r10,r9,0x6
80005f2e:	2c 8a       	sub	r10,-56
80005f30:	c2 08       	rjmp	80005f70 <_malloc_r+0x1a8>
80005f32:	d7 03       	nop
80005f34:	59 4a       	cp.w	r10,20
80005f36:	e0 8b 00 04 	brhi	80005f3e <_malloc_r+0x176>
80005f3a:	2a 5a       	sub	r10,-91
80005f3c:	c1 a8       	rjmp	80005f70 <_malloc_r+0x1a8>
80005f3e:	e0 4a 00 54 	cp.w	r10,84
80005f42:	e0 8b 00 06 	brhi	80005f4e <_malloc_r+0x186>
80005f46:	f2 0a 16 0c 	lsr	r10,r9,0xc
80005f4a:	29 2a       	sub	r10,-110
80005f4c:	c1 28       	rjmp	80005f70 <_malloc_r+0x1a8>
80005f4e:	e0 4a 01 54 	cp.w	r10,340
80005f52:	e0 8b 00 06 	brhi	80005f5e <_malloc_r+0x196>
80005f56:	f2 0a 16 0f 	lsr	r10,r9,0xf
80005f5a:	28 9a       	sub	r10,-119
80005f5c:	c0 a8       	rjmp	80005f70 <_malloc_r+0x1a8>
80005f5e:	e0 4a 05 54 	cp.w	r10,1364
80005f62:	e0 88 00 04 	brls	80005f6a <_malloc_r+0x1a2>
80005f66:	37 ea       	mov	r10,126
80005f68:	c0 48       	rjmp	80005f70 <_malloc_r+0x1a8>
80005f6a:	f2 0a 16 12 	lsr	r10,r9,0x12
80005f6e:	28 4a       	sub	r10,-124
80005f70:	e0 6b 05 18 	mov	r11,1304
80005f74:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80005f78:	68 28       	ld.w	r8,r4[0x8]
80005f7a:	08 38       	cp.w	r8,r4
80005f7c:	c0 e1       	brne	80005f98 <_malloc_r+0x1d0>
80005f7e:	76 19       	ld.w	r9,r11[0x4]
80005f80:	a3 4a       	asr	r10,0x2
80005f82:	30 1e       	mov	lr,1
80005f84:	fc 0a 09 4a 	lsl	r10,lr,r10
80005f88:	f3 ea 10 0a 	or	r10,r9,r10
80005f8c:	10 99       	mov	r9,r8
80005f8e:	97 1a       	st.w	r11[0x4],r10
80005f90:	c0 a8       	rjmp	80005fa4 <_malloc_r+0x1dc>
80005f92:	70 28       	ld.w	r8,r8[0x8]
80005f94:	08 38       	cp.w	r8,r4
80005f96:	c0 60       	breq	80005fa2 <_malloc_r+0x1da>
80005f98:	70 1a       	ld.w	r10,r8[0x4]
80005f9a:	e0 1a ff fc 	andl	r10,0xfffc
80005f9e:	14 39       	cp.w	r9,r10
80005fa0:	cf 93       	brcs	80005f92 <_malloc_r+0x1ca>
80005fa2:	70 39       	ld.w	r9,r8[0xc]
80005fa4:	8d 39       	st.w	r6[0xc],r9
80005fa6:	8d 28       	st.w	r6[0x8],r8
80005fa8:	91 36       	st.w	r8[0xc],r6
80005faa:	93 26       	st.w	r9[0x8],r6
80005fac:	e6 08 14 02 	asr	r8,r3,0x2
80005fb0:	30 1b       	mov	r11,1
80005fb2:	e0 64 05 18 	mov	r4,1304
80005fb6:	f6 08 09 4b 	lsl	r11,r11,r8
80005fba:	68 18       	ld.w	r8,r4[0x4]
80005fbc:	10 3b       	cp.w	r11,r8
80005fbe:	e0 8b 00 6b 	brhi	80006094 <_malloc_r+0x2cc>
80005fc2:	f7 e8 00 09 	and	r9,r11,r8
80005fc6:	c0 b1       	brne	80005fdc <_malloc_r+0x214>
80005fc8:	e0 13 ff fc 	andl	r3,0xfffc
80005fcc:	a1 7b       	lsl	r11,0x1
80005fce:	2f c3       	sub	r3,-4
80005fd0:	c0 38       	rjmp	80005fd6 <_malloc_r+0x20e>
80005fd2:	2f c3       	sub	r3,-4
80005fd4:	a1 7b       	lsl	r11,0x1
80005fd6:	f7 e8 00 09 	and	r9,r11,r8
80005fda:	cf c0       	breq	80005fd2 <_malloc_r+0x20a>
80005fdc:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80005fe0:	06 92       	mov	r2,r3
80005fe2:	1c 91       	mov	r1,lr
80005fe4:	62 36       	ld.w	r6,r1[0xc]
80005fe6:	c2 e8       	rjmp	80006042 <_malloc_r+0x27a>
80005fe8:	6c 1a       	ld.w	r10,r6[0x4]
80005fea:	e0 1a ff fc 	andl	r10,0xfffc
80005fee:	f4 07 01 08 	sub	r8,r10,r7
80005ff2:	58 f8       	cp.w	r8,15
80005ff4:	e0 8a 00 15 	brle	8000601e <_malloc_r+0x256>
80005ff8:	6c 3a       	ld.w	r10,r6[0xc]
80005ffa:	6c 29       	ld.w	r9,r6[0x8]
80005ffc:	95 29       	st.w	r10[0x8],r9
80005ffe:	93 3a       	st.w	r9[0xc],r10
80006000:	0e 99       	mov	r9,r7
80006002:	ec 07 00 07 	add	r7,r6,r7
80006006:	a1 a9       	sbr	r9,0x0
80006008:	99 37       	st.w	r12[0xc],r7
8000600a:	99 27       	st.w	r12[0x8],r7
8000600c:	8d 19       	st.w	r6[0x4],r9
8000600e:	ee 08 09 08 	st.w	r7[r8],r8
80006012:	8f 2c       	st.w	r7[0x8],r12
80006014:	8f 3c       	st.w	r7[0xc],r12
80006016:	a1 a8       	sbr	r8,0x0
80006018:	0a 9c       	mov	r12,r5
8000601a:	8f 18       	st.w	r7[0x4],r8
8000601c:	c0 d8       	rjmp	80006036 <_malloc_r+0x26e>
8000601e:	6c 39       	ld.w	r9,r6[0xc]
80006020:	58 08       	cp.w	r8,0
80006022:	c0 f5       	brlt	80006040 <_malloc_r+0x278>
80006024:	ec 0a 00 0a 	add	r10,r6,r10
80006028:	74 18       	ld.w	r8,r10[0x4]
8000602a:	a1 a8       	sbr	r8,0x0
8000602c:	0a 9c       	mov	r12,r5
8000602e:	95 18       	st.w	r10[0x4],r8
80006030:	6c 28       	ld.w	r8,r6[0x8]
80006032:	93 28       	st.w	r9[0x8],r8
80006034:	91 39       	st.w	r8[0xc],r9
80006036:	fe b0 f5 9d 	rcall	80004b70 <__malloc_unlock>
8000603a:	ec cc ff f8 	sub	r12,r6,-8
8000603e:	d8 32       	popm	r0-r7,pc
80006040:	12 96       	mov	r6,r9
80006042:	02 36       	cp.w	r6,r1
80006044:	cd 21       	brne	80005fe8 <_malloc_r+0x220>
80006046:	2f f2       	sub	r2,-1
80006048:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
8000604c:	c0 30       	breq	80006052 <_malloc_r+0x28a>
8000604e:	2f 81       	sub	r1,-8
80006050:	cc ab       	rjmp	80005fe4 <_malloc_r+0x21c>
80006052:	1c 98       	mov	r8,lr
80006054:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80006058:	c0 81       	brne	80006068 <_malloc_r+0x2a0>
8000605a:	68 19       	ld.w	r9,r4[0x4]
8000605c:	f6 08 11 ff 	rsub	r8,r11,-1
80006060:	f3 e8 00 08 	and	r8,r9,r8
80006064:	89 18       	st.w	r4[0x4],r8
80006066:	c0 78       	rjmp	80006074 <_malloc_r+0x2ac>
80006068:	f0 c9 00 08 	sub	r9,r8,8
8000606c:	20 13       	sub	r3,1
8000606e:	70 08       	ld.w	r8,r8[0x0]
80006070:	12 38       	cp.w	r8,r9
80006072:	cf 10       	breq	80006054 <_malloc_r+0x28c>
80006074:	a1 7b       	lsl	r11,0x1
80006076:	68 18       	ld.w	r8,r4[0x4]
80006078:	10 3b       	cp.w	r11,r8
8000607a:	e0 8b 00 0d 	brhi	80006094 <_malloc_r+0x2cc>
8000607e:	58 0b       	cp.w	r11,0
80006080:	c0 a0       	breq	80006094 <_malloc_r+0x2cc>
80006082:	04 93       	mov	r3,r2
80006084:	c0 38       	rjmp	8000608a <_malloc_r+0x2c2>
80006086:	2f c3       	sub	r3,-4
80006088:	a1 7b       	lsl	r11,0x1
8000608a:	f7 e8 00 09 	and	r9,r11,r8
8000608e:	ca 71       	brne	80005fdc <_malloc_r+0x214>
80006090:	cf bb       	rjmp	80006086 <_malloc_r+0x2be>
80006092:	d7 03       	nop
80006094:	68 23       	ld.w	r3,r4[0x8]
80006096:	66 12       	ld.w	r2,r3[0x4]
80006098:	e0 12 ff fc 	andl	r2,0xfffc
8000609c:	0e 32       	cp.w	r2,r7
8000609e:	5f 39       	srlo	r9
800060a0:	e4 07 01 08 	sub	r8,r2,r7
800060a4:	58 f8       	cp.w	r8,15
800060a6:	5f aa       	srle	r10
800060a8:	f5 e9 10 09 	or	r9,r10,r9
800060ac:	e0 80 00 9a 	breq	800061e0 <_malloc_r+0x418>
800060b0:	e0 68 0c b0 	mov	r8,3248
800060b4:	70 01       	ld.w	r1,r8[0x0]
800060b6:	e0 68 09 24 	mov	r8,2340
800060ba:	2f 01       	sub	r1,-16
800060bc:	70 08       	ld.w	r8,r8[0x0]
800060be:	0e 01       	add	r1,r7
800060c0:	5b f8       	cp.w	r8,-1
800060c2:	c0 40       	breq	800060ca <_malloc_r+0x302>
800060c4:	28 11       	sub	r1,-127
800060c6:	e0 11 ff 80 	andl	r1,0xff80
800060ca:	02 9b       	mov	r11,r1
800060cc:	0a 9c       	mov	r12,r5
800060ce:	e0 a0 02 b7 	rcall	8000663c <_sbrk_r>
800060d2:	18 96       	mov	r6,r12
800060d4:	5b fc       	cp.w	r12,-1
800060d6:	c7 50       	breq	800061c0 <_malloc_r+0x3f8>
800060d8:	e6 02 00 08 	add	r8,r3,r2
800060dc:	10 3c       	cp.w	r12,r8
800060de:	c0 32       	brcc	800060e4 <_malloc_r+0x31c>
800060e0:	08 33       	cp.w	r3,r4
800060e2:	c6 f1       	brne	800061c0 <_malloc_r+0x3f8>
800060e4:	e0 6a 0c b4 	mov	r10,3252
800060e8:	74 09       	ld.w	r9,r10[0x0]
800060ea:	e2 09 00 09 	add	r9,r1,r9
800060ee:	95 09       	st.w	r10[0x0],r9
800060f0:	10 36       	cp.w	r6,r8
800060f2:	c0 a1       	brne	80006106 <_malloc_r+0x33e>
800060f4:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800060f8:	c0 71       	brne	80006106 <_malloc_r+0x33e>
800060fa:	e2 02 00 02 	add	r2,r1,r2
800060fe:	68 28       	ld.w	r8,r4[0x8]
80006100:	a1 a2       	sbr	r2,0x0
80006102:	91 12       	st.w	r8[0x4],r2
80006104:	c4 f8       	rjmp	800061a2 <_malloc_r+0x3da>
80006106:	e0 6a 09 24 	mov	r10,2340
8000610a:	74 0b       	ld.w	r11,r10[0x0]
8000610c:	5b fb       	cp.w	r11,-1
8000610e:	c0 31       	brne	80006114 <_malloc_r+0x34c>
80006110:	95 06       	st.w	r10[0x0],r6
80006112:	c0 78       	rjmp	80006120 <_malloc_r+0x358>
80006114:	ec 09 00 09 	add	r9,r6,r9
80006118:	e0 6a 0c b4 	mov	r10,3252
8000611c:	10 19       	sub	r9,r8
8000611e:	95 09       	st.w	r10[0x0],r9
80006120:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80006124:	f0 09 11 08 	rsub	r9,r8,8
80006128:	58 08       	cp.w	r8,0
8000612a:	f2 08 17 10 	movne	r8,r9
8000612e:	ed d8 e1 06 	addne	r6,r6,r8
80006132:	28 08       	sub	r8,-128
80006134:	ec 01 00 01 	add	r1,r6,r1
80006138:	0a 9c       	mov	r12,r5
8000613a:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000613e:	f0 01 01 01 	sub	r1,r8,r1
80006142:	02 9b       	mov	r11,r1
80006144:	e0 a0 02 7c 	rcall	8000663c <_sbrk_r>
80006148:	e0 68 0c b4 	mov	r8,3252
8000614c:	5b fc       	cp.w	r12,-1
8000614e:	ec 0c 17 00 	moveq	r12,r6
80006152:	f9 b1 00 00 	moveq	r1,0
80006156:	70 09       	ld.w	r9,r8[0x0]
80006158:	0c 1c       	sub	r12,r6
8000615a:	89 26       	st.w	r4[0x8],r6
8000615c:	02 0c       	add	r12,r1
8000615e:	12 01       	add	r1,r9
80006160:	a1 ac       	sbr	r12,0x0
80006162:	91 01       	st.w	r8[0x0],r1
80006164:	8d 1c       	st.w	r6[0x4],r12
80006166:	08 33       	cp.w	r3,r4
80006168:	c1 d0       	breq	800061a2 <_malloc_r+0x3da>
8000616a:	58 f2       	cp.w	r2,15
8000616c:	e0 8b 00 05 	brhi	80006176 <_malloc_r+0x3ae>
80006170:	30 18       	mov	r8,1
80006172:	8d 18       	st.w	r6[0x4],r8
80006174:	c2 68       	rjmp	800061c0 <_malloc_r+0x3f8>
80006176:	30 59       	mov	r9,5
80006178:	20 c2       	sub	r2,12
8000617a:	e0 12 ff f8 	andl	r2,0xfff8
8000617e:	e6 02 00 08 	add	r8,r3,r2
80006182:	91 29       	st.w	r8[0x8],r9
80006184:	91 19       	st.w	r8[0x4],r9
80006186:	66 18       	ld.w	r8,r3[0x4]
80006188:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000618c:	e5 e8 10 08 	or	r8,r2,r8
80006190:	87 18       	st.w	r3[0x4],r8
80006192:	58 f2       	cp.w	r2,15
80006194:	e0 88 00 07 	brls	800061a2 <_malloc_r+0x3da>
80006198:	e6 cb ff f8 	sub	r11,r3,-8
8000619c:	0a 9c       	mov	r12,r5
8000619e:	e0 a0 1c 7d 	rcall	80009a98 <_free_r>
800061a2:	e0 69 0c ac 	mov	r9,3244
800061a6:	72 0a       	ld.w	r10,r9[0x0]
800061a8:	e0 68 0c b4 	mov	r8,3252
800061ac:	70 08       	ld.w	r8,r8[0x0]
800061ae:	14 38       	cp.w	r8,r10
800061b0:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800061b4:	e0 69 0c a8 	mov	r9,3240
800061b8:	72 0a       	ld.w	r10,r9[0x0]
800061ba:	14 38       	cp.w	r8,r10
800061bc:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800061c0:	68 28       	ld.w	r8,r4[0x8]
800061c2:	70 18       	ld.w	r8,r8[0x4]
800061c4:	e0 18 ff fc 	andl	r8,0xfffc
800061c8:	0e 38       	cp.w	r8,r7
800061ca:	5f 39       	srlo	r9
800061cc:	0e 18       	sub	r8,r7
800061ce:	58 f8       	cp.w	r8,15
800061d0:	5f aa       	srle	r10
800061d2:	f5 e9 10 09 	or	r9,r10,r9
800061d6:	c0 50       	breq	800061e0 <_malloc_r+0x418>
800061d8:	0a 9c       	mov	r12,r5
800061da:	fe b0 f4 cb 	rcall	80004b70 <__malloc_unlock>
800061de:	d8 3a       	popm	r0-r7,pc,r12=0
800061e0:	68 26       	ld.w	r6,r4[0x8]
800061e2:	a1 a8       	sbr	r8,0x0
800061e4:	0e 99       	mov	r9,r7
800061e6:	a1 a9       	sbr	r9,0x0
800061e8:	8d 19       	st.w	r6[0x4],r9
800061ea:	ec 07 00 07 	add	r7,r6,r7
800061ee:	0a 9c       	mov	r12,r5
800061f0:	89 27       	st.w	r4[0x8],r7
800061f2:	8f 18       	st.w	r7[0x4],r8
800061f4:	fe b0 f4 be 	rcall	80004b70 <__malloc_unlock>
800061f8:	ec cc ff f8 	sub	r12,r6,-8
800061fc:	d8 32       	popm	r0-r7,pc
800061fe:	d7 03       	nop

80006200 <memcmp>:
80006200:	d4 01       	pushm	lr
80006202:	30 08       	mov	r8,0
80006204:	c0 d8       	rjmp	8000621e <memcmp+0x1e>
80006206:	f8 08 07 0e 	ld.ub	lr,r12[r8]
8000620a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000620e:	20 1a       	sub	r10,1
80006210:	2f f8       	sub	r8,-1
80006212:	f2 0e 18 00 	cp.b	lr,r9
80006216:	c0 40       	breq	8000621e <memcmp+0x1e>
80006218:	fc 09 01 0c 	sub	r12,lr,r9
8000621c:	d8 02       	popm	pc
8000621e:	58 0a       	cp.w	r10,0
80006220:	cf 31       	brne	80006206 <memcmp+0x6>
80006222:	14 9c       	mov	r12,r10
80006224:	d8 02       	popm	pc

80006226 <memcpy>:
80006226:	58 8a       	cp.w	r10,8
80006228:	c2 f5       	brlt	80006286 <memcpy+0x60>
8000622a:	f9 eb 10 09 	or	r9,r12,r11
8000622e:	e2 19 00 03 	andl	r9,0x3,COH
80006232:	e0 81 00 97 	brne	80006360 <memcpy+0x13a>
80006236:	e0 4a 00 20 	cp.w	r10,32
8000623a:	c3 b4       	brge	800062b0 <memcpy+0x8a>
8000623c:	f4 08 14 02 	asr	r8,r10,0x2
80006240:	f0 09 11 08 	rsub	r9,r8,8
80006244:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80006248:	76 69       	ld.w	r9,r11[0x18]
8000624a:	99 69       	st.w	r12[0x18],r9
8000624c:	76 59       	ld.w	r9,r11[0x14]
8000624e:	99 59       	st.w	r12[0x14],r9
80006250:	76 49       	ld.w	r9,r11[0x10]
80006252:	99 49       	st.w	r12[0x10],r9
80006254:	76 39       	ld.w	r9,r11[0xc]
80006256:	99 39       	st.w	r12[0xc],r9
80006258:	76 29       	ld.w	r9,r11[0x8]
8000625a:	99 29       	st.w	r12[0x8],r9
8000625c:	76 19       	ld.w	r9,r11[0x4]
8000625e:	99 19       	st.w	r12[0x4],r9
80006260:	76 09       	ld.w	r9,r11[0x0]
80006262:	99 09       	st.w	r12[0x0],r9
80006264:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80006268:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000626c:	e0 1a 00 03 	andl	r10,0x3
80006270:	f4 0a 11 04 	rsub	r10,r10,4
80006274:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006278:	17 a9       	ld.ub	r9,r11[0x2]
8000627a:	b0 a9       	st.b	r8[0x2],r9
8000627c:	17 99       	ld.ub	r9,r11[0x1]
8000627e:	b0 99       	st.b	r8[0x1],r9
80006280:	17 89       	ld.ub	r9,r11[0x0]
80006282:	b0 89       	st.b	r8[0x0],r9
80006284:	5e fc       	retal	r12
80006286:	f4 0a 11 09 	rsub	r10,r10,9
8000628a:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000628e:	17 f9       	ld.ub	r9,r11[0x7]
80006290:	b8 f9       	st.b	r12[0x7],r9
80006292:	17 e9       	ld.ub	r9,r11[0x6]
80006294:	b8 e9       	st.b	r12[0x6],r9
80006296:	17 d9       	ld.ub	r9,r11[0x5]
80006298:	b8 d9       	st.b	r12[0x5],r9
8000629a:	17 c9       	ld.ub	r9,r11[0x4]
8000629c:	b8 c9       	st.b	r12[0x4],r9
8000629e:	17 b9       	ld.ub	r9,r11[0x3]
800062a0:	b8 b9       	st.b	r12[0x3],r9
800062a2:	17 a9       	ld.ub	r9,r11[0x2]
800062a4:	b8 a9       	st.b	r12[0x2],r9
800062a6:	17 99       	ld.ub	r9,r11[0x1]
800062a8:	b8 99       	st.b	r12[0x1],r9
800062aa:	17 89       	ld.ub	r9,r11[0x0]
800062ac:	b8 89       	st.b	r12[0x0],r9
800062ae:	5e fc       	retal	r12
800062b0:	eb cd 40 c0 	pushm	r6-r7,lr
800062b4:	18 99       	mov	r9,r12
800062b6:	22 0a       	sub	r10,32
800062b8:	b7 07       	ld.d	r6,r11++
800062ba:	b3 26       	st.d	r9++,r6
800062bc:	b7 07       	ld.d	r6,r11++
800062be:	b3 26       	st.d	r9++,r6
800062c0:	b7 07       	ld.d	r6,r11++
800062c2:	b3 26       	st.d	r9++,r6
800062c4:	b7 07       	ld.d	r6,r11++
800062c6:	b3 26       	st.d	r9++,r6
800062c8:	22 0a       	sub	r10,32
800062ca:	cf 74       	brge	800062b8 <memcpy+0x92>
800062cc:	2f 0a       	sub	r10,-16
800062ce:	c0 65       	brlt	800062da <memcpy+0xb4>
800062d0:	b7 07       	ld.d	r6,r11++
800062d2:	b3 26       	st.d	r9++,r6
800062d4:	b7 07       	ld.d	r6,r11++
800062d6:	b3 26       	st.d	r9++,r6
800062d8:	21 0a       	sub	r10,16
800062da:	5c 3a       	neg	r10
800062dc:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800062e0:	d7 03       	nop
800062e2:	d7 03       	nop
800062e4:	f7 36 00 0e 	ld.ub	r6,r11[14]
800062e8:	f3 66 00 0e 	st.b	r9[14],r6
800062ec:	f7 36 00 0d 	ld.ub	r6,r11[13]
800062f0:	f3 66 00 0d 	st.b	r9[13],r6
800062f4:	f7 36 00 0c 	ld.ub	r6,r11[12]
800062f8:	f3 66 00 0c 	st.b	r9[12],r6
800062fc:	f7 36 00 0b 	ld.ub	r6,r11[11]
80006300:	f3 66 00 0b 	st.b	r9[11],r6
80006304:	f7 36 00 0a 	ld.ub	r6,r11[10]
80006308:	f3 66 00 0a 	st.b	r9[10],r6
8000630c:	f7 36 00 09 	ld.ub	r6,r11[9]
80006310:	f3 66 00 09 	st.b	r9[9],r6
80006314:	f7 36 00 08 	ld.ub	r6,r11[8]
80006318:	f3 66 00 08 	st.b	r9[8],r6
8000631c:	f7 36 00 07 	ld.ub	r6,r11[7]
80006320:	f3 66 00 07 	st.b	r9[7],r6
80006324:	f7 36 00 06 	ld.ub	r6,r11[6]
80006328:	f3 66 00 06 	st.b	r9[6],r6
8000632c:	f7 36 00 05 	ld.ub	r6,r11[5]
80006330:	f3 66 00 05 	st.b	r9[5],r6
80006334:	f7 36 00 04 	ld.ub	r6,r11[4]
80006338:	f3 66 00 04 	st.b	r9[4],r6
8000633c:	f7 36 00 03 	ld.ub	r6,r11[3]
80006340:	f3 66 00 03 	st.b	r9[3],r6
80006344:	f7 36 00 02 	ld.ub	r6,r11[2]
80006348:	f3 66 00 02 	st.b	r9[2],r6
8000634c:	f7 36 00 01 	ld.ub	r6,r11[1]
80006350:	f3 66 00 01 	st.b	r9[1],r6
80006354:	f7 36 00 00 	ld.ub	r6,r11[0]
80006358:	f3 66 00 00 	st.b	r9[0],r6
8000635c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006360:	20 1a       	sub	r10,1
80006362:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80006366:	f8 0a 0b 09 	st.b	r12[r10],r9
8000636a:	cf b1       	brne	80006360 <memcpy+0x13a>
8000636c:	5e fc       	retal	r12

8000636e <memset>:
8000636e:	18 98       	mov	r8,r12
80006370:	c0 38       	rjmp	80006376 <memset+0x8>
80006372:	10 cb       	st.b	r8++,r11
80006374:	20 1a       	sub	r10,1
80006376:	58 0a       	cp.w	r10,0
80006378:	cf d1       	brne	80006372 <memset+0x4>
8000637a:	5e fc       	retal	r12

8000637c <_realloc_r>:
8000637c:	d4 31       	pushm	r0-r7,lr
8000637e:	20 1d       	sub	sp,4
80006380:	16 94       	mov	r4,r11
80006382:	18 92       	mov	r2,r12
80006384:	14 9b       	mov	r11,r10
80006386:	58 04       	cp.w	r4,0
80006388:	c0 51       	brne	80006392 <_realloc_r+0x16>
8000638a:	fe b0 fd 1f 	rcall	80005dc8 <_malloc_r>
8000638e:	18 95       	mov	r5,r12
80006390:	c5 39       	rjmp	80006636 <_realloc_r+0x2ba>
80006392:	50 0a       	stdsp	sp[0x0],r10
80006394:	fe b0 f3 e8 	rcall	80004b64 <__malloc_lock>
80006398:	40 0b       	lddsp	r11,sp[0x0]
8000639a:	f6 c8 ff f5 	sub	r8,r11,-11
8000639e:	e8 c1 00 08 	sub	r1,r4,8
800063a2:	10 96       	mov	r6,r8
800063a4:	62 1c       	ld.w	r12,r1[0x4]
800063a6:	e0 16 ff f8 	andl	r6,0xfff8
800063aa:	59 68       	cp.w	r8,22
800063ac:	f9 b6 08 10 	movls	r6,16
800063b0:	16 36       	cp.w	r6,r11
800063b2:	5f 38       	srlo	r8
800063b4:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
800063b8:	c0 50       	breq	800063c2 <_realloc_r+0x46>
800063ba:	30 c8       	mov	r8,12
800063bc:	30 05       	mov	r5,0
800063be:	85 38       	st.w	r2[0xc],r8
800063c0:	c3 b9       	rjmp	80006636 <_realloc_r+0x2ba>
800063c2:	18 90       	mov	r0,r12
800063c4:	e0 10 ff fc 	andl	r0,0xfffc
800063c8:	0c 30       	cp.w	r0,r6
800063ca:	e0 84 01 0b 	brge	800065e0 <_realloc_r+0x264>
800063ce:	e0 68 05 18 	mov	r8,1304
800063d2:	e2 00 00 09 	add	r9,r1,r0
800063d6:	70 25       	ld.w	r5,r8[0x8]
800063d8:	0a 39       	cp.w	r9,r5
800063da:	c0 90       	breq	800063ec <_realloc_r+0x70>
800063dc:	72 1a       	ld.w	r10,r9[0x4]
800063de:	a1 ca       	cbr	r10,0x0
800063e0:	f2 0a 00 0a 	add	r10,r9,r10
800063e4:	74 1a       	ld.w	r10,r10[0x4]
800063e6:	ed ba 00 00 	bld	r10,0x0
800063ea:	c2 20       	breq	8000642e <_realloc_r+0xb2>
800063ec:	72 1a       	ld.w	r10,r9[0x4]
800063ee:	e0 1a ff fc 	andl	r10,0xfffc
800063f2:	f4 00 00 03 	add	r3,r10,r0
800063f6:	0a 39       	cp.w	r9,r5
800063f8:	c1 31       	brne	8000641e <_realloc_r+0xa2>
800063fa:	ec c7 ff f0 	sub	r7,r6,-16
800063fe:	0e 33       	cp.w	r3,r7
80006400:	c1 95       	brlt	80006432 <_realloc_r+0xb6>
80006402:	e2 06 00 09 	add	r9,r1,r6
80006406:	0c 13       	sub	r3,r6
80006408:	a1 a3       	sbr	r3,0x0
8000640a:	93 13       	st.w	r9[0x4],r3
8000640c:	91 29       	st.w	r8[0x8],r9
8000640e:	04 9c       	mov	r12,r2
80006410:	62 18       	ld.w	r8,r1[0x4]
80006412:	08 95       	mov	r5,r4
80006414:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006418:	10 46       	or	r6,r8
8000641a:	83 16       	st.w	r1[0x4],r6
8000641c:	c0 b9       	rjmp	80006632 <_realloc_r+0x2b6>
8000641e:	0c 33       	cp.w	r3,r6
80006420:	c0 95       	brlt	80006432 <_realloc_r+0xb6>
80006422:	72 28       	ld.w	r8,r9[0x8]
80006424:	02 97       	mov	r7,r1
80006426:	72 39       	ld.w	r9,r9[0xc]
80006428:	93 28       	st.w	r9[0x8],r8
8000642a:	91 39       	st.w	r8[0xc],r9
8000642c:	cd c8       	rjmp	800065e4 <_realloc_r+0x268>
8000642e:	30 0a       	mov	r10,0
80006430:	14 99       	mov	r9,r10
80006432:	ed bc 00 00 	bld	r12,0x0
80006436:	e0 80 00 95 	breq	80006560 <_realloc_r+0x1e4>
8000643a:	62 07       	ld.w	r7,r1[0x0]
8000643c:	e2 07 01 07 	sub	r7,r1,r7
80006440:	6e 1c       	ld.w	r12,r7[0x4]
80006442:	e0 1c ff fc 	andl	r12,0xfffc
80006446:	58 09       	cp.w	r9,0
80006448:	c5 60       	breq	800064f4 <_realloc_r+0x178>
8000644a:	f8 00 00 03 	add	r3,r12,r0
8000644e:	0a 39       	cp.w	r9,r5
80006450:	c4 81       	brne	800064e0 <_realloc_r+0x164>
80006452:	14 03       	add	r3,r10
80006454:	ec c9 ff f0 	sub	r9,r6,-16
80006458:	12 33       	cp.w	r3,r9
8000645a:	c4 d5       	brlt	800064f4 <_realloc_r+0x178>
8000645c:	6e 3a       	ld.w	r10,r7[0xc]
8000645e:	6e 29       	ld.w	r9,r7[0x8]
80006460:	95 29       	st.w	r10[0x8],r9
80006462:	93 3a       	st.w	r9[0xc],r10
80006464:	ee c5 ff f8 	sub	r5,r7,-8
80006468:	e0 ca 00 04 	sub	r10,r0,4
8000646c:	e0 4a 00 24 	cp.w	r10,36
80006470:	e0 8b 00 25 	brhi	800064ba <_realloc_r+0x13e>
80006474:	0a 99       	mov	r9,r5
80006476:	59 3a       	cp.w	r10,19
80006478:	e0 88 00 1a 	brls	800064ac <_realloc_r+0x130>
8000647c:	09 09       	ld.w	r9,r4++
8000647e:	8b 09       	st.w	r5[0x0],r9
80006480:	09 09       	ld.w	r9,r4++
80006482:	8f 39       	st.w	r7[0xc],r9
80006484:	ee c9 ff f0 	sub	r9,r7,-16
80006488:	59 ba       	cp.w	r10,27
8000648a:	e0 88 00 11 	brls	800064ac <_realloc_r+0x130>
8000648e:	09 0b       	ld.w	r11,r4++
80006490:	93 0b       	st.w	r9[0x0],r11
80006492:	09 09       	ld.w	r9,r4++
80006494:	8f 59       	st.w	r7[0x14],r9
80006496:	ee c9 ff e8 	sub	r9,r7,-24
8000649a:	e0 4a 00 24 	cp.w	r10,36
8000649e:	c0 71       	brne	800064ac <_realloc_r+0x130>
800064a0:	09 0a       	ld.w	r10,r4++
800064a2:	93 0a       	st.w	r9[0x0],r10
800064a4:	ee c9 ff e0 	sub	r9,r7,-32
800064a8:	09 0a       	ld.w	r10,r4++
800064aa:	8f 7a       	st.w	r7[0x1c],r10
800064ac:	09 0a       	ld.w	r10,r4++
800064ae:	12 aa       	st.w	r9++,r10
800064b0:	68 0a       	ld.w	r10,r4[0x0]
800064b2:	93 0a       	st.w	r9[0x0],r10
800064b4:	68 1a       	ld.w	r10,r4[0x4]
800064b6:	93 1a       	st.w	r9[0x4],r10
800064b8:	c0 78       	rjmp	800064c6 <_realloc_r+0x14a>
800064ba:	50 08       	stdsp	sp[0x0],r8
800064bc:	08 9b       	mov	r11,r4
800064be:	0a 9c       	mov	r12,r5
800064c0:	e0 a0 1d 8f 	rcall	80009fde <memmove>
800064c4:	40 08       	lddsp	r8,sp[0x0]
800064c6:	ee 06 00 09 	add	r9,r7,r6
800064ca:	0c 13       	sub	r3,r6
800064cc:	a1 a3       	sbr	r3,0x0
800064ce:	93 13       	st.w	r9[0x4],r3
800064d0:	91 29       	st.w	r8[0x8],r9
800064d2:	04 9c       	mov	r12,r2
800064d4:	6e 18       	ld.w	r8,r7[0x4]
800064d6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800064da:	10 46       	or	r6,r8
800064dc:	8f 16       	st.w	r7[0x4],r6
800064de:	ca a8       	rjmp	80006632 <_realloc_r+0x2b6>
800064e0:	14 03       	add	r3,r10
800064e2:	0c 33       	cp.w	r3,r6
800064e4:	c0 85       	brlt	800064f4 <_realloc_r+0x178>
800064e6:	72 28       	ld.w	r8,r9[0x8]
800064e8:	72 39       	ld.w	r9,r9[0xc]
800064ea:	93 28       	st.w	r9[0x8],r8
800064ec:	91 39       	st.w	r8[0xc],r9
800064ee:	6e 28       	ld.w	r8,r7[0x8]
800064f0:	6e 39       	ld.w	r9,r7[0xc]
800064f2:	c0 78       	rjmp	80006500 <_realloc_r+0x184>
800064f4:	f8 00 00 03 	add	r3,r12,r0
800064f8:	0c 33       	cp.w	r3,r6
800064fa:	c3 35       	brlt	80006560 <_realloc_r+0x1e4>
800064fc:	6e 39       	ld.w	r9,r7[0xc]
800064fe:	6e 28       	ld.w	r8,r7[0x8]
80006500:	93 28       	st.w	r9[0x8],r8
80006502:	91 39       	st.w	r8[0xc],r9
80006504:	e0 ca 00 04 	sub	r10,r0,4
80006508:	ee cc ff f8 	sub	r12,r7,-8
8000650c:	e0 4a 00 24 	cp.w	r10,36
80006510:	e0 8b 00 24 	brhi	80006558 <_realloc_r+0x1dc>
80006514:	59 3a       	cp.w	r10,19
80006516:	e0 88 00 1a 	brls	8000654a <_realloc_r+0x1ce>
8000651a:	09 08       	ld.w	r8,r4++
8000651c:	99 08       	st.w	r12[0x0],r8
8000651e:	09 08       	ld.w	r8,r4++
80006520:	8f 38       	st.w	r7[0xc],r8
80006522:	ee cc ff f0 	sub	r12,r7,-16
80006526:	59 ba       	cp.w	r10,27
80006528:	e0 88 00 11 	brls	8000654a <_realloc_r+0x1ce>
8000652c:	09 08       	ld.w	r8,r4++
8000652e:	99 08       	st.w	r12[0x0],r8
80006530:	09 08       	ld.w	r8,r4++
80006532:	8f 58       	st.w	r7[0x14],r8
80006534:	ee cc ff e8 	sub	r12,r7,-24
80006538:	e0 4a 00 24 	cp.w	r10,36
8000653c:	c0 71       	brne	8000654a <_realloc_r+0x1ce>
8000653e:	09 08       	ld.w	r8,r4++
80006540:	99 08       	st.w	r12[0x0],r8
80006542:	ee cc ff e0 	sub	r12,r7,-32
80006546:	09 08       	ld.w	r8,r4++
80006548:	8f 78       	st.w	r7[0x1c],r8
8000654a:	09 08       	ld.w	r8,r4++
8000654c:	18 a8       	st.w	r12++,r8
8000654e:	68 08       	ld.w	r8,r4[0x0]
80006550:	99 08       	st.w	r12[0x0],r8
80006552:	68 18       	ld.w	r8,r4[0x4]
80006554:	99 18       	st.w	r12[0x4],r8
80006556:	c4 78       	rjmp	800065e4 <_realloc_r+0x268>
80006558:	08 9b       	mov	r11,r4
8000655a:	e0 a0 1d 42 	rcall	80009fde <memmove>
8000655e:	c4 38       	rjmp	800065e4 <_realloc_r+0x268>
80006560:	04 9c       	mov	r12,r2
80006562:	fe b0 fc 33 	rcall	80005dc8 <_malloc_r>
80006566:	18 95       	mov	r5,r12
80006568:	c3 a0       	breq	800065dc <_realloc_r+0x260>
8000656a:	62 18       	ld.w	r8,r1[0x4]
8000656c:	f8 c9 00 08 	sub	r9,r12,8
80006570:	a1 c8       	cbr	r8,0x0
80006572:	e2 08 00 08 	add	r8,r1,r8
80006576:	10 39       	cp.w	r9,r8
80006578:	c0 71       	brne	80006586 <_realloc_r+0x20a>
8000657a:	72 13       	ld.w	r3,r9[0x4]
8000657c:	02 97       	mov	r7,r1
8000657e:	e0 13 ff fc 	andl	r3,0xfffc
80006582:	00 03       	add	r3,r0
80006584:	c3 08       	rjmp	800065e4 <_realloc_r+0x268>
80006586:	e0 ca 00 04 	sub	r10,r0,4
8000658a:	e0 4a 00 24 	cp.w	r10,36
8000658e:	e0 8b 00 20 	brhi	800065ce <_realloc_r+0x252>
80006592:	08 99       	mov	r9,r4
80006594:	18 98       	mov	r8,r12
80006596:	59 3a       	cp.w	r10,19
80006598:	e0 88 00 14 	brls	800065c0 <_realloc_r+0x244>
8000659c:	13 0b       	ld.w	r11,r9++
8000659e:	10 ab       	st.w	r8++,r11
800065a0:	13 0b       	ld.w	r11,r9++
800065a2:	10 ab       	st.w	r8++,r11
800065a4:	59 ba       	cp.w	r10,27
800065a6:	e0 88 00 0d 	brls	800065c0 <_realloc_r+0x244>
800065aa:	13 0b       	ld.w	r11,r9++
800065ac:	10 ab       	st.w	r8++,r11
800065ae:	13 0b       	ld.w	r11,r9++
800065b0:	10 ab       	st.w	r8++,r11
800065b2:	e0 4a 00 24 	cp.w	r10,36
800065b6:	c0 51       	brne	800065c0 <_realloc_r+0x244>
800065b8:	13 0a       	ld.w	r10,r9++
800065ba:	10 aa       	st.w	r8++,r10
800065bc:	13 0a       	ld.w	r10,r9++
800065be:	10 aa       	st.w	r8++,r10
800065c0:	13 0a       	ld.w	r10,r9++
800065c2:	10 aa       	st.w	r8++,r10
800065c4:	72 0a       	ld.w	r10,r9[0x0]
800065c6:	91 0a       	st.w	r8[0x0],r10
800065c8:	72 19       	ld.w	r9,r9[0x4]
800065ca:	91 19       	st.w	r8[0x4],r9
800065cc:	c0 48       	rjmp	800065d4 <_realloc_r+0x258>
800065ce:	08 9b       	mov	r11,r4
800065d0:	e0 a0 1d 07 	rcall	80009fde <memmove>
800065d4:	08 9b       	mov	r11,r4
800065d6:	04 9c       	mov	r12,r2
800065d8:	e0 a0 1a 60 	rcall	80009a98 <_free_r>
800065dc:	04 9c       	mov	r12,r2
800065de:	c2 a8       	rjmp	80006632 <_realloc_r+0x2b6>
800065e0:	00 93       	mov	r3,r0
800065e2:	02 97       	mov	r7,r1
800065e4:	e6 06 01 09 	sub	r9,r3,r6
800065e8:	6e 18       	ld.w	r8,r7[0x4]
800065ea:	58 f9       	cp.w	r9,15
800065ec:	e0 88 00 16 	brls	80006618 <_realloc_r+0x29c>
800065f0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800065f4:	ed e8 10 08 	or	r8,r6,r8
800065f8:	8f 18       	st.w	r7[0x4],r8
800065fa:	12 98       	mov	r8,r9
800065fc:	a1 a8       	sbr	r8,0x0
800065fe:	ee 06 00 0b 	add	r11,r7,r6
80006602:	f6 09 00 09 	add	r9,r11,r9
80006606:	97 18       	st.w	r11[0x4],r8
80006608:	72 18       	ld.w	r8,r9[0x4]
8000660a:	a1 a8       	sbr	r8,0x0
8000660c:	2f 8b       	sub	r11,-8
8000660e:	93 18       	st.w	r9[0x4],r8
80006610:	04 9c       	mov	r12,r2
80006612:	e0 a0 1a 43 	rcall	80009a98 <_free_r>
80006616:	c0 b8       	rjmp	8000662c <_realloc_r+0x2b0>
80006618:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000661c:	e7 e8 10 08 	or	r8,r3,r8
80006620:	8f 18       	st.w	r7[0x4],r8
80006622:	ee 03 00 03 	add	r3,r7,r3
80006626:	66 18       	ld.w	r8,r3[0x4]
80006628:	a1 a8       	sbr	r8,0x0
8000662a:	87 18       	st.w	r3[0x4],r8
8000662c:	04 9c       	mov	r12,r2
8000662e:	ee c5 ff f8 	sub	r5,r7,-8
80006632:	fe b0 f2 9f 	rcall	80004b70 <__malloc_unlock>
80006636:	0a 9c       	mov	r12,r5
80006638:	2f fd       	sub	sp,-4
8000663a:	d8 32       	popm	r0-r7,pc

8000663c <_sbrk_r>:
8000663c:	d4 21       	pushm	r4-r7,lr
8000663e:	30 08       	mov	r8,0
80006640:	18 97       	mov	r7,r12
80006642:	e0 66 1f a0 	mov	r6,8096
80006646:	16 9c       	mov	r12,r11
80006648:	8d 08       	st.w	r6[0x0],r8
8000664a:	c8 5c       	rcall	80006754 <_sbrk>
8000664c:	5b fc       	cp.w	r12,-1
8000664e:	c0 51       	brne	80006658 <_sbrk_r+0x1c>
80006650:	6c 08       	ld.w	r8,r6[0x0]
80006652:	58 08       	cp.w	r8,0
80006654:	ef f8 1a 03 	st.wne	r7[0xc],r8
80006658:	d8 22       	popm	r4-r7,pc
8000665a:	d7 03       	nop

8000665c <sprintf>:
8000665c:	d4 01       	pushm	lr
8000665e:	21 7d       	sub	sp,92
80006660:	e0 68 ff ff 	mov	r8,65535
80006664:	ea 18 7f ff 	orh	r8,0x7fff
80006668:	50 58       	stdsp	sp[0x14],r8
8000666a:	50 28       	stdsp	sp[0x8],r8
8000666c:	e0 68 02 08 	mov	r8,520
80006670:	ba 68       	st.h	sp[0xc],r8
80006672:	3f f8       	mov	r8,-1
80006674:	ba 78       	st.h	sp[0xe],r8
80006676:	e0 68 0a 18 	mov	r8,2584
8000667a:	50 4c       	stdsp	sp[0x10],r12
8000667c:	16 9a       	mov	r10,r11
8000667e:	50 0c       	stdsp	sp[0x0],r12
80006680:	fa c9 ff a0 	sub	r9,sp,-96
80006684:	70 0c       	ld.w	r12,r8[0x0]
80006686:	1a 9b       	mov	r11,sp
80006688:	e0 a0 02 1a 	rcall	80006abc <_vfprintf_r>
8000668c:	30 09       	mov	r9,0
8000668e:	40 08       	lddsp	r8,sp[0x0]
80006690:	b0 89       	st.b	r8[0x0],r9
80006692:	2e 9d       	sub	sp,-92
80006694:	d8 02       	popm	pc
80006696:	d7 03       	nop

80006698 <strncpy>:
80006698:	30 08       	mov	r8,0
8000669a:	10 3a       	cp.w	r10,r8
8000669c:	5e 0c       	reteq	r12
8000669e:	f6 08 07 09 	ld.ub	r9,r11[r8]
800066a2:	f8 08 0b 09 	st.b	r12[r8],r9
800066a6:	2f f8       	sub	r8,-1
800066a8:	58 09       	cp.w	r9,0
800066aa:	cf 81       	brne	8000669a <strncpy+0x2>
800066ac:	10 3a       	cp.w	r10,r8
800066ae:	5e 0c       	reteq	r12
800066b0:	f8 08 0b 09 	st.b	r12[r8],r9
800066b4:	2f f8       	sub	r8,-1
800066b6:	cf bb       	rjmp	800066ac <strncpy+0x14>

800066b8 <_close>:
800066b8:	30 28       	mov	r8,2
800066ba:	d6 73       	breakpoint
800066bc:	3f fc       	mov	r12,-1
800066be:	35 8b       	mov	r11,88
800066c0:	58 0c       	cp.w	r12,0
800066c2:	5e 4c       	retge	r12
800066c4:	e0 6a 1f a0 	mov	r10,8096
800066c8:	95 0b       	st.w	r10[0x0],r11
800066ca:	5e fc       	retal	r12

800066cc <_lseek>:
800066cc:	30 58       	mov	r8,5
800066ce:	d6 73       	breakpoint
800066d0:	3f fc       	mov	r12,-1
800066d2:	35 8b       	mov	r11,88
800066d4:	58 0c       	cp.w	r12,0
800066d6:	5e 4c       	retge	r12
800066d8:	e0 6a 1f a0 	mov	r10,8096
800066dc:	95 0b       	st.w	r10[0x0],r11
800066de:	5e fc       	retal	r12

800066e0 <isatty>:
800066e0:	30 b8       	mov	r8,11
800066e2:	d6 73       	breakpoint
800066e4:	3f fc       	mov	r12,-1
800066e6:	35 8b       	mov	r11,88
800066e8:	58 0c       	cp.w	r12,0
800066ea:	5e 4c       	retge	r12
800066ec:	e0 6a 1f a0 	mov	r10,8096
800066f0:	95 0b       	st.w	r10[0x0],r11
800066f2:	5e fc       	retal	r12

800066f4 <_fstat_host>:
800066f4:	30 98       	mov	r8,9
800066f6:	d6 73       	breakpoint
800066f8:	3f fc       	mov	r12,-1
800066fa:	35 8b       	mov	r11,88
800066fc:	58 0c       	cp.w	r12,0
800066fe:	5e 4c       	retge	r12
80006700:	e0 6a 1f a0 	mov	r10,8096
80006704:	95 0b       	st.w	r10[0x0],r11
80006706:	5e fc       	retal	r12

80006708 <_fstat>:
80006708:	d4 21       	pushm	r4-r7,lr
8000670a:	21 0d       	sub	sp,64
8000670c:	16 97       	mov	r7,r11
8000670e:	1a 9b       	mov	r11,sp
80006710:	cf 2f       	rcall	800066f4 <_fstat_host>
80006712:	c0 34       	brge	80006718 <_fstat+0x10>
80006714:	3f fc       	mov	r12,-1
80006716:	c1 c8       	rjmp	8000674e <_fstat+0x46>
80006718:	40 08       	lddsp	r8,sp[0x0]
8000671a:	ae 08       	st.h	r7[0x0],r8
8000671c:	40 18       	lddsp	r8,sp[0x4]
8000671e:	ae 18       	st.h	r7[0x2],r8
80006720:	40 28       	lddsp	r8,sp[0x8]
80006722:	8f 18       	st.w	r7[0x4],r8
80006724:	40 38       	lddsp	r8,sp[0xc]
80006726:	ae 48       	st.h	r7[0x8],r8
80006728:	40 48       	lddsp	r8,sp[0x10]
8000672a:	ae 58       	st.h	r7[0xa],r8
8000672c:	40 58       	lddsp	r8,sp[0x14]
8000672e:	ae 68       	st.h	r7[0xc],r8
80006730:	40 68       	lddsp	r8,sp[0x18]
80006732:	ae 78       	st.h	r7[0xe],r8
80006734:	40 88       	lddsp	r8,sp[0x20]
80006736:	8f 48       	st.w	r7[0x10],r8
80006738:	40 a8       	lddsp	r8,sp[0x28]
8000673a:	8f b8       	st.w	r7[0x2c],r8
8000673c:	40 c8       	lddsp	r8,sp[0x30]
8000673e:	8f c8       	st.w	r7[0x30],r8
80006740:	40 d8       	lddsp	r8,sp[0x34]
80006742:	8f 58       	st.w	r7[0x14],r8
80006744:	40 e8       	lddsp	r8,sp[0x38]
80006746:	30 0c       	mov	r12,0
80006748:	8f 78       	st.w	r7[0x1c],r8
8000674a:	40 f8       	lddsp	r8,sp[0x3c]
8000674c:	8f 98       	st.w	r7[0x24],r8
8000674e:	2f 0d       	sub	sp,-64
80006750:	d8 22       	popm	r4-r7,pc
80006752:	d7 03       	nop

80006754 <_sbrk>:
80006754:	d4 01       	pushm	lr
80006756:	e0 68 0c dc 	mov	r8,3292
8000675a:	70 09       	ld.w	r9,r8[0x0]
8000675c:	58 09       	cp.w	r9,0
8000675e:	c0 41       	brne	80006766 <_sbrk+0x12>
80006760:	e0 69 1f a8 	mov	r9,8104
80006764:	91 09       	st.w	r8[0x0],r9
80006766:	e0 69 0c dc 	mov	r9,3292
8000676a:	e0 7a 70 00 	mov	r10,94208
8000676e:	72 08       	ld.w	r8,r9[0x0]
80006770:	f0 0c 00 0c 	add	r12,r8,r12
80006774:	14 3c       	cp.w	r12,r10
80006776:	e0 8b 00 04 	brhi	8000677e <_sbrk+0x2a>
8000677a:	93 0c       	st.w	r9[0x0],r12
8000677c:	c0 68       	rjmp	80006788 <_sbrk+0x34>
8000677e:	e0 a0 18 15 	rcall	800097a8 <__errno>
80006782:	30 c8       	mov	r8,12
80006784:	99 08       	st.w	r12[0x0],r8
80006786:	3f f8       	mov	r8,-1
80006788:	10 9c       	mov	r12,r8
8000678a:	d8 02       	popm	pc

8000678c <get_arg>:
8000678c:	d4 31       	pushm	r0-r7,lr
8000678e:	20 8d       	sub	sp,32
80006790:	fa c4 ff bc 	sub	r4,sp,-68
80006794:	50 4b       	stdsp	sp[0x10],r11
80006796:	68 2e       	ld.w	lr,r4[0x8]
80006798:	50 58       	stdsp	sp[0x14],r8
8000679a:	12 96       	mov	r6,r9
8000679c:	7c 0b       	ld.w	r11,lr[0x0]
8000679e:	70 05       	ld.w	r5,r8[0x0]
800067a0:	50 6e       	stdsp	sp[0x18],lr
800067a2:	58 0b       	cp.w	r11,0
800067a4:	f4 0b 17 00 	moveq	r11,r10
800067a8:	68 03       	ld.w	r3,r4[0x0]
800067aa:	68 11       	ld.w	r1,r4[0x4]
800067ac:	40 49       	lddsp	r9,sp[0x10]
800067ae:	30 08       	mov	r8,0
800067b0:	c2 89       	rjmp	80006a00 <get_arg+0x274>
800067b2:	2f fb       	sub	r11,-1
800067b4:	32 5c       	mov	r12,37
800067b6:	17 8a       	ld.ub	r10,r11[0x0]
800067b8:	f8 0a 18 00 	cp.b	r10,r12
800067bc:	5f 1e       	srne	lr
800067be:	f0 0a 18 00 	cp.b	r10,r8
800067c2:	5f 1c       	srne	r12
800067c4:	fd ec 00 0c 	and	r12,lr,r12
800067c8:	f0 0c 18 00 	cp.b	r12,r8
800067cc:	cf 31       	brne	800067b2 <get_arg+0x26>
800067ce:	58 0a       	cp.w	r10,0
800067d0:	e0 80 01 25 	breq	80006a1a <get_arg+0x28e>
800067d4:	30 0c       	mov	r12,0
800067d6:	3f fa       	mov	r10,-1
800067d8:	18 90       	mov	r0,r12
800067da:	50 3a       	stdsp	sp[0xc],r10
800067dc:	18 94       	mov	r4,r12
800067de:	18 92       	mov	r2,r12
800067e0:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
800067e4:	16 97       	mov	r7,r11
800067e6:	50 7c       	stdsp	sp[0x1c],r12
800067e8:	fe cc 9e 78 	sub	r12,pc,-24968
800067ec:	0f 3a       	ld.ub	r10,r7++
800067ee:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
800067f2:	40 7c       	lddsp	r12,sp[0x1c]
800067f4:	1c 0c       	add	r12,lr
800067f6:	fe ce 9f 4e 	sub	lr,pc,-24754
800067fa:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
800067fe:	20 1e       	sub	lr,1
80006800:	50 0e       	stdsp	sp[0x0],lr
80006802:	fe ce 9f c6 	sub	lr,pc,-24634
80006806:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8000680a:	50 7c       	stdsp	sp[0x1c],r12
8000680c:	40 0c       	lddsp	r12,sp[0x0]
8000680e:	58 7c       	cp.w	r12,7
80006810:	e0 8b 00 f1 	brhi	800069f2 <get_arg+0x266>
80006814:	fe ce a1 78 	sub	lr,pc,-24200
80006818:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
8000681c:	36 8b       	mov	r11,104
8000681e:	f6 0a 18 00 	cp.b	r10,r11
80006822:	e0 80 00 e8 	breq	800069f2 <get_arg+0x266>
80006826:	37 1b       	mov	r11,113
80006828:	f6 0a 18 00 	cp.b	r10,r11
8000682c:	c0 70       	breq	8000683a <get_arg+0xae>
8000682e:	34 cb       	mov	r11,76
80006830:	f6 0a 18 00 	cp.b	r10,r11
80006834:	c0 51       	brne	8000683e <get_arg+0xb2>
80006836:	a3 b4       	sbr	r4,0x3
80006838:	cd d8       	rjmp	800069f2 <get_arg+0x266>
8000683a:	a5 b4       	sbr	r4,0x5
8000683c:	cd b8       	rjmp	800069f2 <get_arg+0x266>
8000683e:	08 9a       	mov	r10,r4
80006840:	0e 9b       	mov	r11,r7
80006842:	a5 aa       	sbr	r10,0x4
80006844:	17 3c       	ld.ub	r12,r11++
80006846:	a5 b4       	sbr	r4,0x5
80006848:	36 ce       	mov	lr,108
8000684a:	fc 0c 18 00 	cp.b	r12,lr
8000684e:	e0 80 00 d3 	breq	800069f4 <get_arg+0x268>
80006852:	14 94       	mov	r4,r10
80006854:	cc f8       	rjmp	800069f2 <get_arg+0x266>
80006856:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000685a:	36 7c       	mov	r12,103
8000685c:	f8 0a 18 00 	cp.b	r10,r12
80006860:	e0 8b 00 27 	brhi	800068ae <get_arg+0x122>
80006864:	36 5b       	mov	r11,101
80006866:	f6 0a 18 00 	cp.b	r10,r11
8000686a:	c4 82       	brcc	800068fa <get_arg+0x16e>
8000686c:	34 fb       	mov	r11,79
8000686e:	f6 0a 18 00 	cp.b	r10,r11
80006872:	c4 80       	breq	80006902 <get_arg+0x176>
80006874:	e0 8b 00 0c 	brhi	8000688c <get_arg+0x100>
80006878:	34 5b       	mov	r11,69
8000687a:	f6 0a 18 00 	cp.b	r10,r11
8000687e:	c3 e0       	breq	800068fa <get_arg+0x16e>
80006880:	34 7b       	mov	r11,71
80006882:	f6 0a 18 00 	cp.b	r10,r11
80006886:	c3 a0       	breq	800068fa <get_arg+0x16e>
80006888:	34 4b       	mov	r11,68
8000688a:	c0 88       	rjmp	8000689a <get_arg+0x10e>
8000688c:	35 8b       	mov	r11,88
8000688e:	f6 0a 18 00 	cp.b	r10,r11
80006892:	c2 c0       	breq	800068ea <get_arg+0x15e>
80006894:	e0 8b 00 07 	brhi	800068a2 <get_arg+0x116>
80006898:	35 5b       	mov	r11,85
8000689a:	f6 0a 18 00 	cp.b	r10,r11
8000689e:	c3 51       	brne	80006908 <get_arg+0x17c>
800068a0:	c3 18       	rjmp	80006902 <get_arg+0x176>
800068a2:	36 3b       	mov	r11,99
800068a4:	f6 0a 18 00 	cp.b	r10,r11
800068a8:	c2 f0       	breq	80006906 <get_arg+0x17a>
800068aa:	36 4b       	mov	r11,100
800068ac:	c0 e8       	rjmp	800068c8 <get_arg+0x13c>
800068ae:	37 0b       	mov	r11,112
800068b0:	f6 0a 18 00 	cp.b	r10,r11
800068b4:	c2 50       	breq	800068fe <get_arg+0x172>
800068b6:	e0 8b 00 0d 	brhi	800068d0 <get_arg+0x144>
800068ba:	36 eb       	mov	r11,110
800068bc:	f6 0a 18 00 	cp.b	r10,r11
800068c0:	c1 f0       	breq	800068fe <get_arg+0x172>
800068c2:	e0 8b 00 14 	brhi	800068ea <get_arg+0x15e>
800068c6:	36 9b       	mov	r11,105
800068c8:	f6 0a 18 00 	cp.b	r10,r11
800068cc:	c1 e1       	brne	80006908 <get_arg+0x17c>
800068ce:	c0 e8       	rjmp	800068ea <get_arg+0x15e>
800068d0:	37 5b       	mov	r11,117
800068d2:	f6 0a 18 00 	cp.b	r10,r11
800068d6:	c0 a0       	breq	800068ea <get_arg+0x15e>
800068d8:	37 8b       	mov	r11,120
800068da:	f6 0a 18 00 	cp.b	r10,r11
800068de:	c0 60       	breq	800068ea <get_arg+0x15e>
800068e0:	37 3b       	mov	r11,115
800068e2:	f6 0a 18 00 	cp.b	r10,r11
800068e6:	c1 11       	brne	80006908 <get_arg+0x17c>
800068e8:	c0 b8       	rjmp	800068fe <get_arg+0x172>
800068ea:	ed b4 00 04 	bld	r4,0x4
800068ee:	c0 a0       	breq	80006902 <get_arg+0x176>
800068f0:	ed b4 00 05 	bld	r4,0x5
800068f4:	c0 91       	brne	80006906 <get_arg+0x17a>
800068f6:	30 20       	mov	r0,2
800068f8:	c0 88       	rjmp	80006908 <get_arg+0x17c>
800068fa:	30 40       	mov	r0,4
800068fc:	c0 68       	rjmp	80006908 <get_arg+0x17c>
800068fe:	30 30       	mov	r0,3
80006900:	c0 48       	rjmp	80006908 <get_arg+0x17c>
80006902:	30 10       	mov	r0,1
80006904:	c0 28       	rjmp	80006908 <get_arg+0x17c>
80006906:	30 00       	mov	r0,0
80006908:	40 3b       	lddsp	r11,sp[0xc]
8000690a:	5b fb       	cp.w	r11,-1
8000690c:	c0 40       	breq	80006914 <get_arg+0x188>
8000690e:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80006912:	c7 08       	rjmp	800069f2 <get_arg+0x266>
80006914:	58 60       	cp.w	r0,6
80006916:	e0 8b 00 6e 	brhi	800069f2 <get_arg+0x266>
8000691a:	6c 0a       	ld.w	r10,r6[0x0]
8000691c:	ea cc ff ff 	sub	r12,r5,-1
80006920:	fe ce a2 64 	sub	lr,pc,-23964
80006924:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80006928:	f4 cb ff f8 	sub	r11,r10,-8
8000692c:	8d 0b       	st.w	r6[0x0],r11
8000692e:	f4 ea 00 00 	ld.d	r10,r10[0]
80006932:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80006936:	c0 f8       	rjmp	80006954 <get_arg+0x1c8>
80006938:	f4 cb ff fc 	sub	r11,r10,-4
8000693c:	8d 0b       	st.w	r6[0x0],r11
8000693e:	74 0a       	ld.w	r10,r10[0x0]
80006940:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80006944:	c0 88       	rjmp	80006954 <get_arg+0x1c8>
80006946:	f4 cb ff f8 	sub	r11,r10,-8
8000694a:	8d 0b       	st.w	r6[0x0],r11
8000694c:	f4 ea 00 00 	ld.d	r10,r10[0]
80006950:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80006954:	0e 9b       	mov	r11,r7
80006956:	18 95       	mov	r5,r12
80006958:	c4 e8       	rjmp	800069f4 <get_arg+0x268>
8000695a:	62 0a       	ld.w	r10,r1[0x0]
8000695c:	5b fa       	cp.w	r10,-1
8000695e:	c0 b1       	brne	80006974 <get_arg+0x1e8>
80006960:	50 19       	stdsp	sp[0x4],r9
80006962:	50 28       	stdsp	sp[0x8],r8
80006964:	e0 6a 00 80 	mov	r10,128
80006968:	30 0b       	mov	r11,0
8000696a:	02 9c       	mov	r12,r1
8000696c:	fe b0 fd 01 	rcall	8000636e <memset>
80006970:	40 28       	lddsp	r8,sp[0x8]
80006972:	40 19       	lddsp	r9,sp[0x4]
80006974:	e4 cc 00 01 	sub	r12,r2,1
80006978:	0e 9b       	mov	r11,r7
8000697a:	50 3c       	stdsp	sp[0xc],r12
8000697c:	f2 0c 0c 49 	max	r9,r9,r12
80006980:	c3 a8       	rjmp	800069f4 <get_arg+0x268>
80006982:	62 0a       	ld.w	r10,r1[0x0]
80006984:	5b fa       	cp.w	r10,-1
80006986:	c0 b1       	brne	8000699c <get_arg+0x210>
80006988:	50 19       	stdsp	sp[0x4],r9
8000698a:	50 28       	stdsp	sp[0x8],r8
8000698c:	e0 6a 00 80 	mov	r10,128
80006990:	30 0b       	mov	r11,0
80006992:	02 9c       	mov	r12,r1
80006994:	fe b0 fc ed 	rcall	8000636e <memset>
80006998:	40 28       	lddsp	r8,sp[0x8]
8000699a:	40 19       	lddsp	r9,sp[0x4]
8000699c:	20 12       	sub	r2,1
8000699e:	30 0a       	mov	r10,0
800069a0:	0e 9b       	mov	r11,r7
800069a2:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
800069a6:	f2 02 0c 49 	max	r9,r9,r2
800069aa:	c2 58       	rjmp	800069f4 <get_arg+0x268>
800069ac:	16 97       	mov	r7,r11
800069ae:	6c 0a       	ld.w	r10,r6[0x0]
800069b0:	f4 cb ff fc 	sub	r11,r10,-4
800069b4:	8d 0b       	st.w	r6[0x0],r11
800069b6:	74 0a       	ld.w	r10,r10[0x0]
800069b8:	0e 9b       	mov	r11,r7
800069ba:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800069be:	2f f5       	sub	r5,-1
800069c0:	c1 a8       	rjmp	800069f4 <get_arg+0x268>
800069c2:	f4 c2 00 30 	sub	r2,r10,48
800069c6:	c0 68       	rjmp	800069d2 <get_arg+0x246>
800069c8:	e4 02 00 22 	add	r2,r2,r2<<0x2
800069cc:	2f f7       	sub	r7,-1
800069ce:	f4 02 00 12 	add	r2,r10,r2<<0x1
800069d2:	0f 8a       	ld.ub	r10,r7[0x0]
800069d4:	58 0a       	cp.w	r10,0
800069d6:	c0 e0       	breq	800069f2 <get_arg+0x266>
800069d8:	23 0a       	sub	r10,48
800069da:	58 9a       	cp.w	r10,9
800069dc:	fe 98 ff f6 	brls	800069c8 <get_arg+0x23c>
800069e0:	c0 98       	rjmp	800069f2 <get_arg+0x266>
800069e2:	2f f7       	sub	r7,-1
800069e4:	0f 8a       	ld.ub	r10,r7[0x0]
800069e6:	58 0a       	cp.w	r10,0
800069e8:	c0 50       	breq	800069f2 <get_arg+0x266>
800069ea:	23 0a       	sub	r10,48
800069ec:	58 9a       	cp.w	r10,9
800069ee:	fe 98 ff fa 	brls	800069e2 <get_arg+0x256>
800069f2:	0e 9b       	mov	r11,r7
800069f4:	40 7c       	lddsp	r12,sp[0x1c]
800069f6:	30 ba       	mov	r10,11
800069f8:	f4 0c 18 00 	cp.b	r12,r10
800069fc:	fe 91 fe f2 	brne	800067e0 <get_arg+0x54>
80006a00:	40 42       	lddsp	r2,sp[0x10]
80006a02:	17 8c       	ld.ub	r12,r11[0x0]
80006a04:	0a 32       	cp.w	r2,r5
80006a06:	5f 4a       	srge	r10
80006a08:	f0 0c 18 00 	cp.b	r12,r8
80006a0c:	5f 1c       	srne	r12
80006a0e:	f9 ea 00 0a 	and	r10,r12,r10
80006a12:	f0 0a 18 00 	cp.b	r10,r8
80006a16:	fe 91 fe cf 	brne	800067b4 <get_arg+0x28>
80006a1a:	30 08       	mov	r8,0
80006a1c:	40 4e       	lddsp	lr,sp[0x10]
80006a1e:	17 8a       	ld.ub	r10,r11[0x0]
80006a20:	e2 05 00 21 	add	r1,r1,r5<<0x2
80006a24:	f0 0a 18 00 	cp.b	r10,r8
80006a28:	fc 09 17 10 	movne	r9,lr
80006a2c:	e6 05 00 38 	add	r8,r3,r5<<0x3
80006a30:	06 9e       	mov	lr,r3
80006a32:	c2 a8       	rjmp	80006a86 <get_arg+0x2fa>
80006a34:	62 0a       	ld.w	r10,r1[0x0]
80006a36:	58 3a       	cp.w	r10,3
80006a38:	c1 e0       	breq	80006a74 <get_arg+0x2e8>
80006a3a:	e0 89 00 07 	brgt	80006a48 <get_arg+0x2bc>
80006a3e:	58 1a       	cp.w	r10,1
80006a40:	c1 a0       	breq	80006a74 <get_arg+0x2e8>
80006a42:	58 2a       	cp.w	r10,2
80006a44:	c1 81       	brne	80006a74 <get_arg+0x2e8>
80006a46:	c0 58       	rjmp	80006a50 <get_arg+0x2c4>
80006a48:	58 5a       	cp.w	r10,5
80006a4a:	c0 c0       	breq	80006a62 <get_arg+0x2d6>
80006a4c:	c0 b5       	brlt	80006a62 <get_arg+0x2d6>
80006a4e:	c1 38       	rjmp	80006a74 <get_arg+0x2e8>
80006a50:	6c 0a       	ld.w	r10,r6[0x0]
80006a52:	f4 cc ff f8 	sub	r12,r10,-8
80006a56:	8d 0c       	st.w	r6[0x0],r12
80006a58:	f4 e2 00 00 	ld.d	r2,r10[0]
80006a5c:	f0 e3 00 00 	st.d	r8[0],r2
80006a60:	c1 08       	rjmp	80006a80 <get_arg+0x2f4>
80006a62:	6c 0a       	ld.w	r10,r6[0x0]
80006a64:	f4 cc ff f8 	sub	r12,r10,-8
80006a68:	8d 0c       	st.w	r6[0x0],r12
80006a6a:	f4 e2 00 00 	ld.d	r2,r10[0]
80006a6e:	f0 e3 00 00 	st.d	r8[0],r2
80006a72:	c0 78       	rjmp	80006a80 <get_arg+0x2f4>
80006a74:	6c 0a       	ld.w	r10,r6[0x0]
80006a76:	f4 cc ff fc 	sub	r12,r10,-4
80006a7a:	8d 0c       	st.w	r6[0x0],r12
80006a7c:	74 0a       	ld.w	r10,r10[0x0]
80006a7e:	91 0a       	st.w	r8[0x0],r10
80006a80:	2f f5       	sub	r5,-1
80006a82:	2f 88       	sub	r8,-8
80006a84:	2f c1       	sub	r1,-4
80006a86:	12 35       	cp.w	r5,r9
80006a88:	fe 9a ff d6 	brle	80006a34 <get_arg+0x2a8>
80006a8c:	1c 93       	mov	r3,lr
80006a8e:	40 52       	lddsp	r2,sp[0x14]
80006a90:	40 6e       	lddsp	lr,sp[0x18]
80006a92:	85 05       	st.w	r2[0x0],r5
80006a94:	9d 0b       	st.w	lr[0x0],r11
80006a96:	40 4b       	lddsp	r11,sp[0x10]
80006a98:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80006a9c:	2f 8d       	sub	sp,-32
80006a9e:	d8 32       	popm	r0-r7,pc

80006aa0 <__sprint_r>:
80006aa0:	d4 21       	pushm	r4-r7,lr
80006aa2:	14 97       	mov	r7,r10
80006aa4:	74 28       	ld.w	r8,r10[0x8]
80006aa6:	58 08       	cp.w	r8,0
80006aa8:	c0 41       	brne	80006ab0 <__sprint_r+0x10>
80006aaa:	95 18       	st.w	r10[0x4],r8
80006aac:	10 9c       	mov	r12,r8
80006aae:	d8 22       	popm	r4-r7,pc
80006ab0:	e0 a0 18 ba 	rcall	80009c24 <__sfvwrite_r>
80006ab4:	30 08       	mov	r8,0
80006ab6:	8f 18       	st.w	r7[0x4],r8
80006ab8:	8f 28       	st.w	r7[0x8],r8
80006aba:	d8 22       	popm	r4-r7,pc

80006abc <_vfprintf_r>:
80006abc:	d4 31       	pushm	r0-r7,lr
80006abe:	fa cd 06 bc 	sub	sp,sp,1724
80006ac2:	51 09       	stdsp	sp[0x40],r9
80006ac4:	16 91       	mov	r1,r11
80006ac6:	14 97       	mov	r7,r10
80006ac8:	18 95       	mov	r5,r12
80006aca:	e0 a0 1a 1d 	rcall	80009f04 <_localeconv_r>
80006ace:	78 0c       	ld.w	r12,r12[0x0]
80006ad0:	50 cc       	stdsp	sp[0x30],r12
80006ad2:	58 05       	cp.w	r5,0
80006ad4:	c0 70       	breq	80006ae2 <_vfprintf_r+0x26>
80006ad6:	6a 68       	ld.w	r8,r5[0x18]
80006ad8:	58 08       	cp.w	r8,0
80006ada:	c0 41       	brne	80006ae2 <_vfprintf_r+0x26>
80006adc:	0a 9c       	mov	r12,r5
80006ade:	e0 a0 17 43 	rcall	80009964 <__sinit>
80006ae2:	fe c8 a0 62 	sub	r8,pc,-24478
80006ae6:	10 31       	cp.w	r1,r8
80006ae8:	c0 31       	brne	80006aee <_vfprintf_r+0x32>
80006aea:	6a 01       	ld.w	r1,r5[0x0]
80006aec:	c0 c8       	rjmp	80006b04 <_vfprintf_r+0x48>
80006aee:	fe c8 a0 4e 	sub	r8,pc,-24498
80006af2:	10 31       	cp.w	r1,r8
80006af4:	c0 31       	brne	80006afa <_vfprintf_r+0x3e>
80006af6:	6a 11       	ld.w	r1,r5[0x4]
80006af8:	c0 68       	rjmp	80006b04 <_vfprintf_r+0x48>
80006afa:	fe c8 a0 3a 	sub	r8,pc,-24518
80006afe:	10 31       	cp.w	r1,r8
80006b00:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80006b04:	82 68       	ld.sh	r8,r1[0xc]
80006b06:	ed b8 00 03 	bld	r8,0x3
80006b0a:	c0 41       	brne	80006b12 <_vfprintf_r+0x56>
80006b0c:	62 48       	ld.w	r8,r1[0x10]
80006b0e:	58 08       	cp.w	r8,0
80006b10:	c0 71       	brne	80006b1e <_vfprintf_r+0x62>
80006b12:	02 9b       	mov	r11,r1
80006b14:	0a 9c       	mov	r12,r5
80006b16:	e0 a0 0f 5d 	rcall	800089d0 <__swsetup_r>
80006b1a:	e0 81 0f 54 	brne	800089c2 <_vfprintf_r+0x1f06>
80006b1e:	82 68       	ld.sh	r8,r1[0xc]
80006b20:	10 99       	mov	r9,r8
80006b22:	e2 19 00 1a 	andl	r9,0x1a,COH
80006b26:	58 a9       	cp.w	r9,10
80006b28:	c3 c1       	brne	80006ba0 <_vfprintf_r+0xe4>
80006b2a:	82 79       	ld.sh	r9,r1[0xe]
80006b2c:	30 0a       	mov	r10,0
80006b2e:	f4 09 19 00 	cp.h	r9,r10
80006b32:	c3 75       	brlt	80006ba0 <_vfprintf_r+0xe4>
80006b34:	a1 d8       	cbr	r8,0x1
80006b36:	fb 58 05 d0 	st.h	sp[1488],r8
80006b3a:	62 88       	ld.w	r8,r1[0x20]
80006b3c:	fb 48 05 e4 	st.w	sp[1508],r8
80006b40:	62 a8       	ld.w	r8,r1[0x28]
80006b42:	fb 48 05 ec 	st.w	sp[1516],r8
80006b46:	fa c8 ff bc 	sub	r8,sp,-68
80006b4a:	fb 48 05 d4 	st.w	sp[1492],r8
80006b4e:	fb 48 05 c4 	st.w	sp[1476],r8
80006b52:	e0 68 04 00 	mov	r8,1024
80006b56:	fb 48 05 d8 	st.w	sp[1496],r8
80006b5a:	fb 48 05 cc 	st.w	sp[1484],r8
80006b5e:	30 08       	mov	r8,0
80006b60:	fb 59 05 d2 	st.h	sp[1490],r9
80006b64:	0e 9a       	mov	r10,r7
80006b66:	41 09       	lddsp	r9,sp[0x40]
80006b68:	fa c7 fa 3c 	sub	r7,sp,-1476
80006b6c:	fb 48 05 dc 	st.w	sp[1500],r8
80006b70:	0a 9c       	mov	r12,r5
80006b72:	0e 9b       	mov	r11,r7
80006b74:	ca 4f       	rcall	80006abc <_vfprintf_r>
80006b76:	50 bc       	stdsp	sp[0x2c],r12
80006b78:	c0 95       	brlt	80006b8a <_vfprintf_r+0xce>
80006b7a:	0e 9b       	mov	r11,r7
80006b7c:	0a 9c       	mov	r12,r5
80006b7e:	e0 a0 16 1b 	rcall	800097b4 <_fflush_r>
80006b82:	40 be       	lddsp	lr,sp[0x2c]
80006b84:	f9 be 01 ff 	movne	lr,-1
80006b88:	50 be       	stdsp	sp[0x2c],lr
80006b8a:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80006b8e:	ed b8 00 06 	bld	r8,0x6
80006b92:	e0 81 0f 1a 	brne	800089c6 <_vfprintf_r+0x1f0a>
80006b96:	82 68       	ld.sh	r8,r1[0xc]
80006b98:	a7 a8       	sbr	r8,0x6
80006b9a:	a2 68       	st.h	r1[0xc],r8
80006b9c:	e0 8f 0f 15 	bral	800089c6 <_vfprintf_r+0x1f0a>
80006ba0:	30 08       	mov	r8,0
80006ba2:	fb 48 06 b4 	st.w	sp[1716],r8
80006ba6:	fb 48 06 90 	st.w	sp[1680],r8
80006baa:	fb 48 06 8c 	st.w	sp[1676],r8
80006bae:	fb 48 06 b0 	st.w	sp[1712],r8
80006bb2:	30 08       	mov	r8,0
80006bb4:	30 09       	mov	r9,0
80006bb6:	50 a7       	stdsp	sp[0x28],r7
80006bb8:	50 78       	stdsp	sp[0x1c],r8
80006bba:	fa c3 f9 e0 	sub	r3,sp,-1568
80006bbe:	3f f8       	mov	r8,-1
80006bc0:	50 59       	stdsp	sp[0x14],r9
80006bc2:	fb 43 06 88 	st.w	sp[1672],r3
80006bc6:	fb 48 05 44 	st.w	sp[1348],r8
80006bca:	12 9c       	mov	r12,r9
80006bcc:	50 69       	stdsp	sp[0x18],r9
80006bce:	50 d9       	stdsp	sp[0x34],r9
80006bd0:	50 e9       	stdsp	sp[0x38],r9
80006bd2:	50 b9       	stdsp	sp[0x2c],r9
80006bd4:	12 97       	mov	r7,r9
80006bd6:	0a 94       	mov	r4,r5
80006bd8:	40 a2       	lddsp	r2,sp[0x28]
80006bda:	32 5a       	mov	r10,37
80006bdc:	30 08       	mov	r8,0
80006bde:	c0 28       	rjmp	80006be2 <_vfprintf_r+0x126>
80006be0:	2f f2       	sub	r2,-1
80006be2:	05 89       	ld.ub	r9,r2[0x0]
80006be4:	f0 09 18 00 	cp.b	r9,r8
80006be8:	5f 1b       	srne	r11
80006bea:	f4 09 18 00 	cp.b	r9,r10
80006bee:	5f 19       	srne	r9
80006bf0:	f3 eb 00 0b 	and	r11,r9,r11
80006bf4:	f0 0b 18 00 	cp.b	r11,r8
80006bf8:	cf 41       	brne	80006be0 <_vfprintf_r+0x124>
80006bfa:	40 ab       	lddsp	r11,sp[0x28]
80006bfc:	e4 0b 01 06 	sub	r6,r2,r11
80006c00:	c1 e0       	breq	80006c3c <_vfprintf_r+0x180>
80006c02:	fa f8 06 90 	ld.w	r8,sp[1680]
80006c06:	0c 08       	add	r8,r6
80006c08:	87 0b       	st.w	r3[0x0],r11
80006c0a:	fb 48 06 90 	st.w	sp[1680],r8
80006c0e:	87 16       	st.w	r3[0x4],r6
80006c10:	fa f8 06 8c 	ld.w	r8,sp[1676]
80006c14:	2f f8       	sub	r8,-1
80006c16:	fb 48 06 8c 	st.w	sp[1676],r8
80006c1a:	58 78       	cp.w	r8,7
80006c1c:	e0 89 00 04 	brgt	80006c24 <_vfprintf_r+0x168>
80006c20:	2f 83       	sub	r3,-8
80006c22:	c0 a8       	rjmp	80006c36 <_vfprintf_r+0x17a>
80006c24:	fa ca f9 78 	sub	r10,sp,-1672
80006c28:	02 9b       	mov	r11,r1
80006c2a:	08 9c       	mov	r12,r4
80006c2c:	c3 af       	rcall	80006aa0 <__sprint_r>
80006c2e:	e0 81 0e c6 	brne	800089ba <_vfprintf_r+0x1efe>
80006c32:	fa c3 f9 e0 	sub	r3,sp,-1568
80006c36:	40 ba       	lddsp	r10,sp[0x2c]
80006c38:	0c 0a       	add	r10,r6
80006c3a:	50 ba       	stdsp	sp[0x2c],r10
80006c3c:	05 89       	ld.ub	r9,r2[0x0]
80006c3e:	30 08       	mov	r8,0
80006c40:	f0 09 18 00 	cp.b	r9,r8
80006c44:	e0 80 0e aa 	breq	80008998 <_vfprintf_r+0x1edc>
80006c48:	30 09       	mov	r9,0
80006c4a:	fb 68 06 bb 	st.b	sp[1723],r8
80006c4e:	0e 96       	mov	r6,r7
80006c50:	e4 c8 ff ff 	sub	r8,r2,-1
80006c54:	3f fe       	mov	lr,-1
80006c56:	50 93       	stdsp	sp[0x24],r3
80006c58:	50 41       	stdsp	sp[0x10],r1
80006c5a:	0e 93       	mov	r3,r7
80006c5c:	04 91       	mov	r1,r2
80006c5e:	50 89       	stdsp	sp[0x20],r9
80006c60:	50 a8       	stdsp	sp[0x28],r8
80006c62:	50 2e       	stdsp	sp[0x8],lr
80006c64:	50 39       	stdsp	sp[0xc],r9
80006c66:	12 95       	mov	r5,r9
80006c68:	12 90       	mov	r0,r9
80006c6a:	10 97       	mov	r7,r8
80006c6c:	08 92       	mov	r2,r4
80006c6e:	c0 78       	rjmp	80006c7c <_vfprintf_r+0x1c0>
80006c70:	3f fc       	mov	r12,-1
80006c72:	08 97       	mov	r7,r4
80006c74:	50 2c       	stdsp	sp[0x8],r12
80006c76:	c0 38       	rjmp	80006c7c <_vfprintf_r+0x1c0>
80006c78:	30 0b       	mov	r11,0
80006c7a:	50 3b       	stdsp	sp[0xc],r11
80006c7c:	0f 38       	ld.ub	r8,r7++
80006c7e:	c0 28       	rjmp	80006c82 <_vfprintf_r+0x1c6>
80006c80:	12 90       	mov	r0,r9
80006c82:	f0 c9 00 20 	sub	r9,r8,32
80006c86:	e0 49 00 58 	cp.w	r9,88
80006c8a:	e0 8b 0a 30 	brhi	800080ea <_vfprintf_r+0x162e>
80006c8e:	fe ca a5 b6 	sub	r10,pc,-23114
80006c92:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80006c96:	50 a7       	stdsp	sp[0x28],r7
80006c98:	50 80       	stdsp	sp[0x20],r0
80006c9a:	0c 97       	mov	r7,r6
80006c9c:	04 94       	mov	r4,r2
80006c9e:	06 96       	mov	r6,r3
80006ca0:	02 92       	mov	r2,r1
80006ca2:	fe c9 a3 8e 	sub	r9,pc,-23666
80006ca6:	40 93       	lddsp	r3,sp[0x24]
80006ca8:	10 90       	mov	r0,r8
80006caa:	40 41       	lddsp	r1,sp[0x10]
80006cac:	50 d9       	stdsp	sp[0x34],r9
80006cae:	e0 8f 08 8e 	bral	80007dca <_vfprintf_r+0x130e>
80006cb2:	30 08       	mov	r8,0
80006cb4:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80006cb8:	f0 09 18 00 	cp.b	r9,r8
80006cbc:	ce 01       	brne	80006c7c <_vfprintf_r+0x1c0>
80006cbe:	32 08       	mov	r8,32
80006cc0:	c6 e8       	rjmp	80006d9c <_vfprintf_r+0x2e0>
80006cc2:	a1 a5       	sbr	r5,0x0
80006cc4:	cd cb       	rjmp	80006c7c <_vfprintf_r+0x1c0>
80006cc6:	0f 89       	ld.ub	r9,r7[0x0]
80006cc8:	f2 c8 00 30 	sub	r8,r9,48
80006ccc:	58 98       	cp.w	r8,9
80006cce:	e0 8b 00 1d 	brhi	80006d08 <_vfprintf_r+0x24c>
80006cd2:	ee c8 ff ff 	sub	r8,r7,-1
80006cd6:	30 0b       	mov	r11,0
80006cd8:	23 09       	sub	r9,48
80006cda:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80006cde:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80006ce2:	11 39       	ld.ub	r9,r8++
80006ce4:	f2 ca 00 30 	sub	r10,r9,48
80006ce8:	58 9a       	cp.w	r10,9
80006cea:	fe 98 ff f7 	brls	80006cd8 <_vfprintf_r+0x21c>
80006cee:	e0 49 00 24 	cp.w	r9,36
80006cf2:	cc 31       	brne	80006c78 <_vfprintf_r+0x1bc>
80006cf4:	e0 4b 00 20 	cp.w	r11,32
80006cf8:	e0 89 0e 60 	brgt	800089b8 <_vfprintf_r+0x1efc>
80006cfc:	20 1b       	sub	r11,1
80006cfe:	fa f9 06 b4 	ld.w	r9,sp[1716]
80006d02:	12 3b       	cp.w	r11,r9
80006d04:	c0 95       	brlt	80006d16 <_vfprintf_r+0x25a>
80006d06:	c1 08       	rjmp	80006d26 <_vfprintf_r+0x26a>
80006d08:	fa f9 06 b4 	ld.w	r9,sp[1716]
80006d0c:	ec ca ff ff 	sub	r10,r6,-1
80006d10:	12 36       	cp.w	r6,r9
80006d12:	c1 f5       	brlt	80006d50 <_vfprintf_r+0x294>
80006d14:	c2 68       	rjmp	80006d60 <_vfprintf_r+0x2a4>
80006d16:	fa ce f9 44 	sub	lr,sp,-1724
80006d1a:	10 97       	mov	r7,r8
80006d1c:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80006d20:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80006d24:	c3 58       	rjmp	80006d8e <_vfprintf_r+0x2d2>
80006d26:	10 97       	mov	r7,r8
80006d28:	fa c8 f9 50 	sub	r8,sp,-1712
80006d2c:	1a d8       	st.w	--sp,r8
80006d2e:	fa c8 fa b8 	sub	r8,sp,-1352
80006d32:	1a d8       	st.w	--sp,r8
80006d34:	fa c8 fb b4 	sub	r8,sp,-1100
80006d38:	02 9a       	mov	r10,r1
80006d3a:	1a d8       	st.w	--sp,r8
80006d3c:	04 9c       	mov	r12,r2
80006d3e:	fa c8 f9 40 	sub	r8,sp,-1728
80006d42:	fa c9 ff b4 	sub	r9,sp,-76
80006d46:	fe b0 fd 23 	rcall	8000678c <get_arg>
80006d4a:	2f dd       	sub	sp,-12
80006d4c:	78 00       	ld.w	r0,r12[0x0]
80006d4e:	c2 08       	rjmp	80006d8e <_vfprintf_r+0x2d2>
80006d50:	fa cc f9 44 	sub	r12,sp,-1724
80006d54:	14 96       	mov	r6,r10
80006d56:	f8 03 00 38 	add	r8,r12,r3<<0x3
80006d5a:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80006d5e:	c1 88       	rjmp	80006d8e <_vfprintf_r+0x2d2>
80006d60:	41 08       	lddsp	r8,sp[0x40]
80006d62:	59 f9       	cp.w	r9,31
80006d64:	e0 89 00 11 	brgt	80006d86 <_vfprintf_r+0x2ca>
80006d68:	f0 cb ff fc 	sub	r11,r8,-4
80006d6c:	51 0b       	stdsp	sp[0x40],r11
80006d6e:	70 00       	ld.w	r0,r8[0x0]
80006d70:	fa cb f9 44 	sub	r11,sp,-1724
80006d74:	f6 09 00 38 	add	r8,r11,r9<<0x3
80006d78:	f1 40 fd 88 	st.w	r8[-632],r0
80006d7c:	2f f9       	sub	r9,-1
80006d7e:	14 96       	mov	r6,r10
80006d80:	fb 49 06 b4 	st.w	sp[1716],r9
80006d84:	c0 58       	rjmp	80006d8e <_vfprintf_r+0x2d2>
80006d86:	70 00       	ld.w	r0,r8[0x0]
80006d88:	14 96       	mov	r6,r10
80006d8a:	2f c8       	sub	r8,-4
80006d8c:	51 08       	stdsp	sp[0x40],r8
80006d8e:	58 00       	cp.w	r0,0
80006d90:	fe 94 ff 76 	brge	80006c7c <_vfprintf_r+0x1c0>
80006d94:	5c 30       	neg	r0
80006d96:	a3 a5       	sbr	r5,0x2
80006d98:	c7 2b       	rjmp	80006c7c <_vfprintf_r+0x1c0>
80006d9a:	32 b8       	mov	r8,43
80006d9c:	fb 68 06 bb 	st.b	sp[1723],r8
80006da0:	c6 eb       	rjmp	80006c7c <_vfprintf_r+0x1c0>
80006da2:	0f 38       	ld.ub	r8,r7++
80006da4:	e0 48 00 2a 	cp.w	r8,42
80006da8:	c0 30       	breq	80006dae <_vfprintf_r+0x2f2>
80006daa:	30 09       	mov	r9,0
80006dac:	c7 98       	rjmp	80006e9e <_vfprintf_r+0x3e2>
80006dae:	0f 88       	ld.ub	r8,r7[0x0]
80006db0:	f0 c9 00 30 	sub	r9,r8,48
80006db4:	58 99       	cp.w	r9,9
80006db6:	e0 8b 00 1f 	brhi	80006df4 <_vfprintf_r+0x338>
80006dba:	ee c4 ff ff 	sub	r4,r7,-1
80006dbe:	30 0b       	mov	r11,0
80006dc0:	23 08       	sub	r8,48
80006dc2:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80006dc6:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80006dca:	09 38       	ld.ub	r8,r4++
80006dcc:	f0 c9 00 30 	sub	r9,r8,48
80006dd0:	58 99       	cp.w	r9,9
80006dd2:	fe 98 ff f7 	brls	80006dc0 <_vfprintf_r+0x304>
80006dd6:	e0 48 00 24 	cp.w	r8,36
80006dda:	fe 91 ff 4f 	brne	80006c78 <_vfprintf_r+0x1bc>
80006dde:	e0 4b 00 20 	cp.w	r11,32
80006de2:	e0 89 0d eb 	brgt	800089b8 <_vfprintf_r+0x1efc>
80006de6:	20 1b       	sub	r11,1
80006de8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80006dec:	10 3b       	cp.w	r11,r8
80006dee:	c0 a5       	brlt	80006e02 <_vfprintf_r+0x346>
80006df0:	c1 18       	rjmp	80006e12 <_vfprintf_r+0x356>
80006df2:	d7 03       	nop
80006df4:	fa fa 06 b4 	ld.w	r10,sp[1716]
80006df8:	ec c9 ff ff 	sub	r9,r6,-1
80006dfc:	14 36       	cp.w	r6,r10
80006dfe:	c1 f5       	brlt	80006e3c <_vfprintf_r+0x380>
80006e00:	c2 88       	rjmp	80006e50 <_vfprintf_r+0x394>
80006e02:	fa ca f9 44 	sub	r10,sp,-1724
80006e06:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80006e0a:	f6 fb fd 88 	ld.w	r11,r11[-632]
80006e0e:	50 2b       	stdsp	sp[0x8],r11
80006e10:	c3 c8       	rjmp	80006e88 <_vfprintf_r+0x3cc>
80006e12:	fa c8 f9 50 	sub	r8,sp,-1712
80006e16:	1a d8       	st.w	--sp,r8
80006e18:	fa c8 fa b8 	sub	r8,sp,-1352
80006e1c:	1a d8       	st.w	--sp,r8
80006e1e:	fa c8 fb b4 	sub	r8,sp,-1100
80006e22:	02 9a       	mov	r10,r1
80006e24:	1a d8       	st.w	--sp,r8
80006e26:	04 9c       	mov	r12,r2
80006e28:	fa c8 f9 40 	sub	r8,sp,-1728
80006e2c:	fa c9 ff b4 	sub	r9,sp,-76
80006e30:	fe b0 fc ae 	rcall	8000678c <get_arg>
80006e34:	2f dd       	sub	sp,-12
80006e36:	78 0c       	ld.w	r12,r12[0x0]
80006e38:	50 2c       	stdsp	sp[0x8],r12
80006e3a:	c2 78       	rjmp	80006e88 <_vfprintf_r+0x3cc>
80006e3c:	12 96       	mov	r6,r9
80006e3e:	0e 94       	mov	r4,r7
80006e40:	fa c9 f9 44 	sub	r9,sp,-1724
80006e44:	f2 03 00 38 	add	r8,r9,r3<<0x3
80006e48:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80006e4c:	50 28       	stdsp	sp[0x8],r8
80006e4e:	c1 d8       	rjmp	80006e88 <_vfprintf_r+0x3cc>
80006e50:	41 08       	lddsp	r8,sp[0x40]
80006e52:	59 fa       	cp.w	r10,31
80006e54:	e0 89 00 14 	brgt	80006e7c <_vfprintf_r+0x3c0>
80006e58:	f0 cb ff fc 	sub	r11,r8,-4
80006e5c:	70 08       	ld.w	r8,r8[0x0]
80006e5e:	51 0b       	stdsp	sp[0x40],r11
80006e60:	50 28       	stdsp	sp[0x8],r8
80006e62:	fa c6 f9 44 	sub	r6,sp,-1724
80006e66:	40 2e       	lddsp	lr,sp[0x8]
80006e68:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80006e6c:	f1 4e fd 88 	st.w	r8[-632],lr
80006e70:	2f fa       	sub	r10,-1
80006e72:	0e 94       	mov	r4,r7
80006e74:	fb 4a 06 b4 	st.w	sp[1716],r10
80006e78:	12 96       	mov	r6,r9
80006e7a:	c0 78       	rjmp	80006e88 <_vfprintf_r+0x3cc>
80006e7c:	70 0c       	ld.w	r12,r8[0x0]
80006e7e:	0e 94       	mov	r4,r7
80006e80:	2f c8       	sub	r8,-4
80006e82:	50 2c       	stdsp	sp[0x8],r12
80006e84:	12 96       	mov	r6,r9
80006e86:	51 08       	stdsp	sp[0x40],r8
80006e88:	40 2b       	lddsp	r11,sp[0x8]
80006e8a:	58 0b       	cp.w	r11,0
80006e8c:	fe 95 fe f2 	brlt	80006c70 <_vfprintf_r+0x1b4>
80006e90:	08 97       	mov	r7,r4
80006e92:	cf 5a       	rjmp	80006c7c <_vfprintf_r+0x1c0>
80006e94:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006e98:	0f 38       	ld.ub	r8,r7++
80006e9a:	f4 09 00 19 	add	r9,r10,r9<<0x1
80006e9e:	f0 ca 00 30 	sub	r10,r8,48
80006ea2:	58 9a       	cp.w	r10,9
80006ea4:	fe 98 ff f8 	brls	80006e94 <_vfprintf_r+0x3d8>
80006ea8:	3f fa       	mov	r10,-1
80006eaa:	f2 0a 0c 49 	max	r9,r9,r10
80006eae:	50 29       	stdsp	sp[0x8],r9
80006eb0:	ce 9a       	rjmp	80006c82 <_vfprintf_r+0x1c6>
80006eb2:	a7 b5       	sbr	r5,0x7
80006eb4:	ce 4a       	rjmp	80006c7c <_vfprintf_r+0x1c0>
80006eb6:	30 09       	mov	r9,0
80006eb8:	23 08       	sub	r8,48
80006eba:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006ebe:	f0 09 00 19 	add	r9,r8,r9<<0x1
80006ec2:	0f 38       	ld.ub	r8,r7++
80006ec4:	f0 ca 00 30 	sub	r10,r8,48
80006ec8:	58 9a       	cp.w	r10,9
80006eca:	fe 98 ff f7 	brls	80006eb8 <_vfprintf_r+0x3fc>
80006ece:	e0 48 00 24 	cp.w	r8,36
80006ed2:	fe 91 fe d7 	brne	80006c80 <_vfprintf_r+0x1c4>
80006ed6:	e0 49 00 20 	cp.w	r9,32
80006eda:	e0 89 0d 6f 	brgt	800089b8 <_vfprintf_r+0x1efc>
80006ede:	f2 c3 00 01 	sub	r3,r9,1
80006ee2:	30 19       	mov	r9,1
80006ee4:	50 39       	stdsp	sp[0xc],r9
80006ee6:	cc ba       	rjmp	80006c7c <_vfprintf_r+0x1c0>
80006ee8:	a3 b5       	sbr	r5,0x3
80006eea:	cc 9a       	rjmp	80006c7c <_vfprintf_r+0x1c0>
80006eec:	a7 a5       	sbr	r5,0x6
80006eee:	cc 7a       	rjmp	80006c7c <_vfprintf_r+0x1c0>
80006ef0:	0a 98       	mov	r8,r5
80006ef2:	a5 b5       	sbr	r5,0x5
80006ef4:	a5 a8       	sbr	r8,0x4
80006ef6:	0f 89       	ld.ub	r9,r7[0x0]
80006ef8:	36 ce       	mov	lr,108
80006efa:	fc 09 18 00 	cp.b	r9,lr
80006efe:	f7 b7 00 ff 	subeq	r7,-1
80006f02:	f0 05 17 10 	movne	r5,r8
80006f06:	cb ba       	rjmp	80006c7c <_vfprintf_r+0x1c0>
80006f08:	a5 b5       	sbr	r5,0x5
80006f0a:	cb 9a       	rjmp	80006c7c <_vfprintf_r+0x1c0>
80006f0c:	50 a7       	stdsp	sp[0x28],r7
80006f0e:	50 80       	stdsp	sp[0x20],r0
80006f10:	0c 97       	mov	r7,r6
80006f12:	10 90       	mov	r0,r8
80006f14:	06 96       	mov	r6,r3
80006f16:	04 94       	mov	r4,r2
80006f18:	40 93       	lddsp	r3,sp[0x24]
80006f1a:	02 92       	mov	r2,r1
80006f1c:	0e 99       	mov	r9,r7
80006f1e:	40 41       	lddsp	r1,sp[0x10]
80006f20:	fa f8 06 b4 	ld.w	r8,sp[1716]
80006f24:	40 3c       	lddsp	r12,sp[0xc]
80006f26:	58 0c       	cp.w	r12,0
80006f28:	c1 d0       	breq	80006f62 <_vfprintf_r+0x4a6>
80006f2a:	10 36       	cp.w	r6,r8
80006f2c:	c0 64       	brge	80006f38 <_vfprintf_r+0x47c>
80006f2e:	fa cb f9 44 	sub	r11,sp,-1724
80006f32:	f6 06 00 36 	add	r6,r11,r6<<0x3
80006f36:	c1 d8       	rjmp	80006f70 <_vfprintf_r+0x4b4>
80006f38:	fa c8 f9 50 	sub	r8,sp,-1712
80006f3c:	1a d8       	st.w	--sp,r8
80006f3e:	fa c8 fa b8 	sub	r8,sp,-1352
80006f42:	1a d8       	st.w	--sp,r8
80006f44:	fa c8 fb b4 	sub	r8,sp,-1100
80006f48:	1a d8       	st.w	--sp,r8
80006f4a:	fa c8 f9 40 	sub	r8,sp,-1728
80006f4e:	fa c9 ff b4 	sub	r9,sp,-76
80006f52:	04 9a       	mov	r10,r2
80006f54:	0c 9b       	mov	r11,r6
80006f56:	08 9c       	mov	r12,r4
80006f58:	fe b0 fc 1a 	rcall	8000678c <get_arg>
80006f5c:	2f dd       	sub	sp,-12
80006f5e:	19 b8       	ld.ub	r8,r12[0x3]
80006f60:	c2 28       	rjmp	80006fa4 <_vfprintf_r+0x4e8>
80006f62:	2f f7       	sub	r7,-1
80006f64:	10 39       	cp.w	r9,r8
80006f66:	c0 84       	brge	80006f76 <_vfprintf_r+0x4ba>
80006f68:	fa ca f9 44 	sub	r10,sp,-1724
80006f6c:	f4 06 00 36 	add	r6,r10,r6<<0x3
80006f70:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80006f74:	c1 88       	rjmp	80006fa4 <_vfprintf_r+0x4e8>
80006f76:	41 09       	lddsp	r9,sp[0x40]
80006f78:	59 f8       	cp.w	r8,31
80006f7a:	e0 89 00 12 	brgt	80006f9e <_vfprintf_r+0x4e2>
80006f7e:	f2 ca ff fc 	sub	r10,r9,-4
80006f82:	51 0a       	stdsp	sp[0x40],r10
80006f84:	72 09       	ld.w	r9,r9[0x0]
80006f86:	fa c6 f9 44 	sub	r6,sp,-1724
80006f8a:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80006f8e:	2f f8       	sub	r8,-1
80006f90:	f5 49 fd 88 	st.w	r10[-632],r9
80006f94:	fb 48 06 b4 	st.w	sp[1716],r8
80006f98:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80006f9c:	c0 48       	rjmp	80006fa4 <_vfprintf_r+0x4e8>
80006f9e:	13 b8       	ld.ub	r8,r9[0x3]
80006fa0:	2f c9       	sub	r9,-4
80006fa2:	51 09       	stdsp	sp[0x40],r9
80006fa4:	fb 68 06 60 	st.b	sp[1632],r8
80006fa8:	30 0e       	mov	lr,0
80006faa:	30 08       	mov	r8,0
80006fac:	30 12       	mov	r2,1
80006fae:	fb 68 06 bb 	st.b	sp[1723],r8
80006fb2:	50 2e       	stdsp	sp[0x8],lr
80006fb4:	e0 8f 08 ad 	bral	8000810e <_vfprintf_r+0x1652>
80006fb8:	50 a7       	stdsp	sp[0x28],r7
80006fba:	50 80       	stdsp	sp[0x20],r0
80006fbc:	0c 97       	mov	r7,r6
80006fbe:	04 94       	mov	r4,r2
80006fc0:	06 96       	mov	r6,r3
80006fc2:	02 92       	mov	r2,r1
80006fc4:	40 93       	lddsp	r3,sp[0x24]
80006fc6:	10 90       	mov	r0,r8
80006fc8:	40 41       	lddsp	r1,sp[0x10]
80006fca:	a5 a5       	sbr	r5,0x4
80006fcc:	c0 a8       	rjmp	80006fe0 <_vfprintf_r+0x524>
80006fce:	50 a7       	stdsp	sp[0x28],r7
80006fd0:	50 80       	stdsp	sp[0x20],r0
80006fd2:	0c 97       	mov	r7,r6
80006fd4:	04 94       	mov	r4,r2
80006fd6:	06 96       	mov	r6,r3
80006fd8:	02 92       	mov	r2,r1
80006fda:	40 93       	lddsp	r3,sp[0x24]
80006fdc:	10 90       	mov	r0,r8
80006fde:	40 41       	lddsp	r1,sp[0x10]
80006fe0:	ed b5 00 05 	bld	r5,0x5
80006fe4:	c5 11       	brne	80007086 <_vfprintf_r+0x5ca>
80006fe6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80006fea:	40 3c       	lddsp	r12,sp[0xc]
80006fec:	58 0c       	cp.w	r12,0
80006fee:	c1 e0       	breq	8000702a <_vfprintf_r+0x56e>
80006ff0:	10 36       	cp.w	r6,r8
80006ff2:	c0 64       	brge	80006ffe <_vfprintf_r+0x542>
80006ff4:	fa cb f9 44 	sub	r11,sp,-1724
80006ff8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80006ffc:	c2 08       	rjmp	8000703c <_vfprintf_r+0x580>
80006ffe:	fa c8 f9 50 	sub	r8,sp,-1712
80007002:	1a d8       	st.w	--sp,r8
80007004:	fa c8 fa b8 	sub	r8,sp,-1352
80007008:	0c 9b       	mov	r11,r6
8000700a:	1a d8       	st.w	--sp,r8
8000700c:	fa c8 fb b4 	sub	r8,sp,-1100
80007010:	1a d8       	st.w	--sp,r8
80007012:	fa c9 ff b4 	sub	r9,sp,-76
80007016:	fa c8 f9 40 	sub	r8,sp,-1728
8000701a:	04 9a       	mov	r10,r2
8000701c:	08 9c       	mov	r12,r4
8000701e:	fe b0 fb b7 	rcall	8000678c <get_arg>
80007022:	2f dd       	sub	sp,-12
80007024:	78 1b       	ld.w	r11,r12[0x4]
80007026:	78 09       	ld.w	r9,r12[0x0]
80007028:	c2 b8       	rjmp	8000707e <_vfprintf_r+0x5c2>
8000702a:	ee ca ff ff 	sub	r10,r7,-1
8000702e:	10 37       	cp.w	r7,r8
80007030:	c0 b4       	brge	80007046 <_vfprintf_r+0x58a>
80007032:	fa c9 f9 44 	sub	r9,sp,-1724
80007036:	14 97       	mov	r7,r10
80007038:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000703c:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007040:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007044:	c1 d8       	rjmp	8000707e <_vfprintf_r+0x5c2>
80007046:	41 09       	lddsp	r9,sp[0x40]
80007048:	59 f8       	cp.w	r8,31
8000704a:	e0 89 00 14 	brgt	80007072 <_vfprintf_r+0x5b6>
8000704e:	f2 cb ff f8 	sub	r11,r9,-8
80007052:	51 0b       	stdsp	sp[0x40],r11
80007054:	fa c6 f9 44 	sub	r6,sp,-1724
80007058:	72 1b       	ld.w	r11,r9[0x4]
8000705a:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000705e:	72 09       	ld.w	r9,r9[0x0]
80007060:	f9 4b fd 8c 	st.w	r12[-628],r11
80007064:	f9 49 fd 88 	st.w	r12[-632],r9
80007068:	2f f8       	sub	r8,-1
8000706a:	14 97       	mov	r7,r10
8000706c:	fb 48 06 b4 	st.w	sp[1716],r8
80007070:	c0 78       	rjmp	8000707e <_vfprintf_r+0x5c2>
80007072:	f2 c8 ff f8 	sub	r8,r9,-8
80007076:	72 1b       	ld.w	r11,r9[0x4]
80007078:	14 97       	mov	r7,r10
8000707a:	51 08       	stdsp	sp[0x40],r8
8000707c:	72 09       	ld.w	r9,r9[0x0]
8000707e:	16 98       	mov	r8,r11
80007080:	fa e9 00 00 	st.d	sp[0],r8
80007084:	ca e8       	rjmp	800071e0 <_vfprintf_r+0x724>
80007086:	ed b5 00 04 	bld	r5,0x4
8000708a:	c1 71       	brne	800070b8 <_vfprintf_r+0x5fc>
8000708c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007090:	40 3e       	lddsp	lr,sp[0xc]
80007092:	58 0e       	cp.w	lr,0
80007094:	c0 80       	breq	800070a4 <_vfprintf_r+0x5e8>
80007096:	10 36       	cp.w	r6,r8
80007098:	c6 94       	brge	8000716a <_vfprintf_r+0x6ae>
8000709a:	fa cc f9 44 	sub	r12,sp,-1724
8000709e:	f8 06 00 36 	add	r6,r12,r6<<0x3
800070a2:	c8 28       	rjmp	800071a6 <_vfprintf_r+0x6ea>
800070a4:	ee ca ff ff 	sub	r10,r7,-1
800070a8:	10 37       	cp.w	r7,r8
800070aa:	e0 84 00 81 	brge	800071ac <_vfprintf_r+0x6f0>
800070ae:	fa cb f9 44 	sub	r11,sp,-1724
800070b2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800070b6:	c7 78       	rjmp	800071a4 <_vfprintf_r+0x6e8>
800070b8:	ed b5 00 06 	bld	r5,0x6
800070bc:	c4 b1       	brne	80007152 <_vfprintf_r+0x696>
800070be:	fa f8 06 b4 	ld.w	r8,sp[1716]
800070c2:	40 3c       	lddsp	r12,sp[0xc]
800070c4:	58 0c       	cp.w	r12,0
800070c6:	c1 d0       	breq	80007100 <_vfprintf_r+0x644>
800070c8:	10 36       	cp.w	r6,r8
800070ca:	c0 64       	brge	800070d6 <_vfprintf_r+0x61a>
800070cc:	fa cb f9 44 	sub	r11,sp,-1724
800070d0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800070d4:	c1 f8       	rjmp	80007112 <_vfprintf_r+0x656>
800070d6:	fa c8 f9 50 	sub	r8,sp,-1712
800070da:	1a d8       	st.w	--sp,r8
800070dc:	fa c8 fa b8 	sub	r8,sp,-1352
800070e0:	1a d8       	st.w	--sp,r8
800070e2:	fa c8 fb b4 	sub	r8,sp,-1100
800070e6:	1a d8       	st.w	--sp,r8
800070e8:	fa c8 f9 40 	sub	r8,sp,-1728
800070ec:	fa c9 ff b4 	sub	r9,sp,-76
800070f0:	04 9a       	mov	r10,r2
800070f2:	0c 9b       	mov	r11,r6
800070f4:	08 9c       	mov	r12,r4
800070f6:	fe b0 fb 4b 	rcall	8000678c <get_arg>
800070fa:	2f dd       	sub	sp,-12
800070fc:	98 18       	ld.sh	r8,r12[0x2]
800070fe:	c2 68       	rjmp	8000714a <_vfprintf_r+0x68e>
80007100:	ee ca ff ff 	sub	r10,r7,-1
80007104:	10 37       	cp.w	r7,r8
80007106:	c0 94       	brge	80007118 <_vfprintf_r+0x65c>
80007108:	fa c9 f9 44 	sub	r9,sp,-1724
8000710c:	14 97       	mov	r7,r10
8000710e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007112:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007116:	c1 a8       	rjmp	8000714a <_vfprintf_r+0x68e>
80007118:	41 09       	lddsp	r9,sp[0x40]
8000711a:	59 f8       	cp.w	r8,31
8000711c:	e0 89 00 13 	brgt	80007142 <_vfprintf_r+0x686>
80007120:	f2 cb ff fc 	sub	r11,r9,-4
80007124:	51 0b       	stdsp	sp[0x40],r11
80007126:	72 09       	ld.w	r9,r9[0x0]
80007128:	fa c6 f9 44 	sub	r6,sp,-1724
8000712c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007130:	2f f8       	sub	r8,-1
80007132:	f7 49 fd 88 	st.w	r11[-632],r9
80007136:	fb 48 06 b4 	st.w	sp[1716],r8
8000713a:	14 97       	mov	r7,r10
8000713c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007140:	c0 58       	rjmp	8000714a <_vfprintf_r+0x68e>
80007142:	92 18       	ld.sh	r8,r9[0x2]
80007144:	14 97       	mov	r7,r10
80007146:	2f c9       	sub	r9,-4
80007148:	51 09       	stdsp	sp[0x40],r9
8000714a:	50 18       	stdsp	sp[0x4],r8
8000714c:	bf 58       	asr	r8,0x1f
8000714e:	50 08       	stdsp	sp[0x0],r8
80007150:	c4 88       	rjmp	800071e0 <_vfprintf_r+0x724>
80007152:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007156:	40 3c       	lddsp	r12,sp[0xc]
80007158:	58 0c       	cp.w	r12,0
8000715a:	c1 d0       	breq	80007194 <_vfprintf_r+0x6d8>
8000715c:	10 36       	cp.w	r6,r8
8000715e:	c0 64       	brge	8000716a <_vfprintf_r+0x6ae>
80007160:	fa cb f9 44 	sub	r11,sp,-1724
80007164:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007168:	c1 f8       	rjmp	800071a6 <_vfprintf_r+0x6ea>
8000716a:	fa c8 f9 50 	sub	r8,sp,-1712
8000716e:	1a d8       	st.w	--sp,r8
80007170:	fa c8 fa b8 	sub	r8,sp,-1352
80007174:	0c 9b       	mov	r11,r6
80007176:	1a d8       	st.w	--sp,r8
80007178:	fa c8 fb b4 	sub	r8,sp,-1100
8000717c:	04 9a       	mov	r10,r2
8000717e:	1a d8       	st.w	--sp,r8
80007180:	08 9c       	mov	r12,r4
80007182:	fa c8 f9 40 	sub	r8,sp,-1728
80007186:	fa c9 ff b4 	sub	r9,sp,-76
8000718a:	fe b0 fb 01 	rcall	8000678c <get_arg>
8000718e:	2f dd       	sub	sp,-12
80007190:	78 0b       	ld.w	r11,r12[0x0]
80007192:	c2 48       	rjmp	800071da <_vfprintf_r+0x71e>
80007194:	ee ca ff ff 	sub	r10,r7,-1
80007198:	10 37       	cp.w	r7,r8
8000719a:	c0 94       	brge	800071ac <_vfprintf_r+0x6f0>
8000719c:	fa c9 f9 44 	sub	r9,sp,-1724
800071a0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800071a4:	14 97       	mov	r7,r10
800071a6:	ec fb fd 88 	ld.w	r11,r6[-632]
800071aa:	c1 88       	rjmp	800071da <_vfprintf_r+0x71e>
800071ac:	41 09       	lddsp	r9,sp[0x40]
800071ae:	59 f8       	cp.w	r8,31
800071b0:	e0 89 00 11 	brgt	800071d2 <_vfprintf_r+0x716>
800071b4:	f2 cb ff fc 	sub	r11,r9,-4
800071b8:	51 0b       	stdsp	sp[0x40],r11
800071ba:	fa c6 f9 44 	sub	r6,sp,-1724
800071be:	72 0b       	ld.w	r11,r9[0x0]
800071c0:	ec 08 00 39 	add	r9,r6,r8<<0x3
800071c4:	f3 4b fd 88 	st.w	r9[-632],r11
800071c8:	2f f8       	sub	r8,-1
800071ca:	14 97       	mov	r7,r10
800071cc:	fb 48 06 b4 	st.w	sp[1716],r8
800071d0:	c0 58       	rjmp	800071da <_vfprintf_r+0x71e>
800071d2:	72 0b       	ld.w	r11,r9[0x0]
800071d4:	14 97       	mov	r7,r10
800071d6:	2f c9       	sub	r9,-4
800071d8:	51 09       	stdsp	sp[0x40],r9
800071da:	50 1b       	stdsp	sp[0x4],r11
800071dc:	bf 5b       	asr	r11,0x1f
800071de:	50 0b       	stdsp	sp[0x0],r11
800071e0:	fa ea 00 00 	ld.d	r10,sp[0]
800071e4:	58 0a       	cp.w	r10,0
800071e6:	5c 2b       	cpc	r11
800071e8:	c0 e4       	brge	80007204 <_vfprintf_r+0x748>
800071ea:	30 08       	mov	r8,0
800071ec:	fa ea 00 00 	ld.d	r10,sp[0]
800071f0:	30 09       	mov	r9,0
800071f2:	f0 0a 01 0a 	sub	r10,r8,r10
800071f6:	f2 0b 01 4b 	sbc	r11,r9,r11
800071fa:	32 d8       	mov	r8,45
800071fc:	fa eb 00 00 	st.d	sp[0],r10
80007200:	fb 68 06 bb 	st.b	sp[1723],r8
80007204:	30 18       	mov	r8,1
80007206:	e0 8f 06 fa 	bral	80007ffa <_vfprintf_r+0x153e>
8000720a:	50 a7       	stdsp	sp[0x28],r7
8000720c:	50 80       	stdsp	sp[0x20],r0
8000720e:	0c 97       	mov	r7,r6
80007210:	04 94       	mov	r4,r2
80007212:	06 96       	mov	r6,r3
80007214:	02 92       	mov	r2,r1
80007216:	40 93       	lddsp	r3,sp[0x24]
80007218:	10 90       	mov	r0,r8
8000721a:	40 41       	lddsp	r1,sp[0x10]
8000721c:	0e 99       	mov	r9,r7
8000721e:	ed b5 00 03 	bld	r5,0x3
80007222:	c4 11       	brne	800072a4 <_vfprintf_r+0x7e8>
80007224:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007228:	40 3a       	lddsp	r10,sp[0xc]
8000722a:	58 0a       	cp.w	r10,0
8000722c:	c1 90       	breq	8000725e <_vfprintf_r+0x7a2>
8000722e:	10 36       	cp.w	r6,r8
80007230:	c6 45       	brlt	800072f8 <_vfprintf_r+0x83c>
80007232:	fa c8 f9 50 	sub	r8,sp,-1712
80007236:	1a d8       	st.w	--sp,r8
80007238:	fa c8 fa b8 	sub	r8,sp,-1352
8000723c:	1a d8       	st.w	--sp,r8
8000723e:	fa c8 fb b4 	sub	r8,sp,-1100
80007242:	0c 9b       	mov	r11,r6
80007244:	1a d8       	st.w	--sp,r8
80007246:	04 9a       	mov	r10,r2
80007248:	fa c8 f9 40 	sub	r8,sp,-1728
8000724c:	fa c9 ff b4 	sub	r9,sp,-76
80007250:	08 9c       	mov	r12,r4
80007252:	fe b0 fa 9d 	rcall	8000678c <get_arg>
80007256:	2f dd       	sub	sp,-12
80007258:	78 16       	ld.w	r6,r12[0x4]
8000725a:	50 76       	stdsp	sp[0x1c],r6
8000725c:	c4 88       	rjmp	800072ec <_vfprintf_r+0x830>
8000725e:	2f f7       	sub	r7,-1
80007260:	10 39       	cp.w	r9,r8
80007262:	c0 c4       	brge	8000727a <_vfprintf_r+0x7be>
80007264:	fa ce f9 44 	sub	lr,sp,-1724
80007268:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000726c:	ec fc fd 8c 	ld.w	r12,r6[-628]
80007270:	50 7c       	stdsp	sp[0x1c],r12
80007272:	ec f6 fd 88 	ld.w	r6,r6[-632]
80007276:	50 56       	stdsp	sp[0x14],r6
80007278:	c6 68       	rjmp	80007344 <_vfprintf_r+0x888>
8000727a:	41 09       	lddsp	r9,sp[0x40]
8000727c:	59 f8       	cp.w	r8,31
8000727e:	e0 89 00 10 	brgt	8000729e <_vfprintf_r+0x7e2>
80007282:	f2 ca ff f8 	sub	r10,r9,-8
80007286:	72 1b       	ld.w	r11,r9[0x4]
80007288:	51 0a       	stdsp	sp[0x40],r10
8000728a:	72 09       	ld.w	r9,r9[0x0]
8000728c:	fa ca f9 44 	sub	r10,sp,-1724
80007290:	50 7b       	stdsp	sp[0x1c],r11
80007292:	50 59       	stdsp	sp[0x14],r9
80007294:	f4 08 00 39 	add	r9,r10,r8<<0x3
80007298:	40 5b       	lddsp	r11,sp[0x14]
8000729a:	40 7a       	lddsp	r10,sp[0x1c]
8000729c:	c4 78       	rjmp	8000732a <_vfprintf_r+0x86e>
8000729e:	72 18       	ld.w	r8,r9[0x4]
800072a0:	50 78       	stdsp	sp[0x1c],r8
800072a2:	c4 c8       	rjmp	8000733a <_vfprintf_r+0x87e>
800072a4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800072a8:	40 3e       	lddsp	lr,sp[0xc]
800072aa:	58 0e       	cp.w	lr,0
800072ac:	c2 30       	breq	800072f2 <_vfprintf_r+0x836>
800072ae:	10 36       	cp.w	r6,r8
800072b0:	c0 94       	brge	800072c2 <_vfprintf_r+0x806>
800072b2:	fa cc f9 44 	sub	r12,sp,-1724
800072b6:	f8 06 00 36 	add	r6,r12,r6<<0x3
800072ba:	ec fb fd 8c 	ld.w	r11,r6[-628]
800072be:	50 7b       	stdsp	sp[0x1c],r11
800072c0:	cd 9b       	rjmp	80007272 <_vfprintf_r+0x7b6>
800072c2:	fa c8 f9 50 	sub	r8,sp,-1712
800072c6:	1a d8       	st.w	--sp,r8
800072c8:	fa c8 fa b8 	sub	r8,sp,-1352
800072cc:	04 9a       	mov	r10,r2
800072ce:	1a d8       	st.w	--sp,r8
800072d0:	fa c8 fb b4 	sub	r8,sp,-1100
800072d4:	0c 9b       	mov	r11,r6
800072d6:	1a d8       	st.w	--sp,r8
800072d8:	08 9c       	mov	r12,r4
800072da:	fa c8 f9 40 	sub	r8,sp,-1728
800072de:	fa c9 ff b4 	sub	r9,sp,-76
800072e2:	fe b0 fa 55 	rcall	8000678c <get_arg>
800072e6:	2f dd       	sub	sp,-12
800072e8:	78 1a       	ld.w	r10,r12[0x4]
800072ea:	50 7a       	stdsp	sp[0x1c],r10
800072ec:	78 0c       	ld.w	r12,r12[0x0]
800072ee:	50 5c       	stdsp	sp[0x14],r12
800072f0:	c2 a8       	rjmp	80007344 <_vfprintf_r+0x888>
800072f2:	2f f7       	sub	r7,-1
800072f4:	10 39       	cp.w	r9,r8
800072f6:	c0 94       	brge	80007308 <_vfprintf_r+0x84c>
800072f8:	fa c9 f9 44 	sub	r9,sp,-1724
800072fc:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007300:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80007304:	50 78       	stdsp	sp[0x1c],r8
80007306:	cb 6b       	rjmp	80007272 <_vfprintf_r+0x7b6>
80007308:	41 09       	lddsp	r9,sp[0x40]
8000730a:	59 f8       	cp.w	r8,31
8000730c:	e0 89 00 15 	brgt	80007336 <_vfprintf_r+0x87a>
80007310:	f2 ca ff f8 	sub	r10,r9,-8
80007314:	72 16       	ld.w	r6,r9[0x4]
80007316:	72 09       	ld.w	r9,r9[0x0]
80007318:	51 0a       	stdsp	sp[0x40],r10
8000731a:	50 59       	stdsp	sp[0x14],r9
8000731c:	fa ce f9 44 	sub	lr,sp,-1724
80007320:	50 76       	stdsp	sp[0x1c],r6
80007322:	fc 08 00 39 	add	r9,lr,r8<<0x3
80007326:	40 5b       	lddsp	r11,sp[0x14]
80007328:	0c 9a       	mov	r10,r6
8000732a:	f2 eb fd 88 	st.d	r9[-632],r10
8000732e:	2f f8       	sub	r8,-1
80007330:	fb 48 06 b4 	st.w	sp[1716],r8
80007334:	c0 88       	rjmp	80007344 <_vfprintf_r+0x888>
80007336:	72 1c       	ld.w	r12,r9[0x4]
80007338:	50 7c       	stdsp	sp[0x1c],r12
8000733a:	f2 c8 ff f8 	sub	r8,r9,-8
8000733e:	51 08       	stdsp	sp[0x40],r8
80007340:	72 09       	ld.w	r9,r9[0x0]
80007342:	50 59       	stdsp	sp[0x14],r9
80007344:	40 5b       	lddsp	r11,sp[0x14]
80007346:	40 7a       	lddsp	r10,sp[0x1c]
80007348:	e0 a0 19 54 	rcall	8000a5f0 <__isinfd>
8000734c:	18 96       	mov	r6,r12
8000734e:	c1 70       	breq	8000737c <_vfprintf_r+0x8c0>
80007350:	30 08       	mov	r8,0
80007352:	30 09       	mov	r9,0
80007354:	40 5b       	lddsp	r11,sp[0x14]
80007356:	40 7a       	lddsp	r10,sp[0x1c]
80007358:	e0 a0 1d b4 	rcall	8000aec0 <__avr32_f64_cmp_lt>
8000735c:	c0 40       	breq	80007364 <_vfprintf_r+0x8a8>
8000735e:	32 d8       	mov	r8,45
80007360:	fb 68 06 bb 	st.b	sp[1723],r8
80007364:	fe c8 aa 3c 	sub	r8,pc,-21956
80007368:	fe c6 aa 3c 	sub	r6,pc,-21956
8000736c:	a7 d5       	cbr	r5,0x7
8000736e:	e0 40 00 47 	cp.w	r0,71
80007372:	f0 06 17 a0 	movle	r6,r8
80007376:	30 32       	mov	r2,3
80007378:	e0 8f 06 ce 	bral	80008114 <_vfprintf_r+0x1658>
8000737c:	40 5b       	lddsp	r11,sp[0x14]
8000737e:	40 7a       	lddsp	r10,sp[0x1c]
80007380:	e0 a0 19 4d 	rcall	8000a61a <__isnand>
80007384:	c0 e0       	breq	800073a0 <_vfprintf_r+0x8e4>
80007386:	50 26       	stdsp	sp[0x8],r6
80007388:	fe c8 aa 58 	sub	r8,pc,-21928
8000738c:	fe c6 aa 58 	sub	r6,pc,-21928
80007390:	a7 d5       	cbr	r5,0x7
80007392:	e0 40 00 47 	cp.w	r0,71
80007396:	f0 06 17 a0 	movle	r6,r8
8000739a:	30 32       	mov	r2,3
8000739c:	e0 8f 06 c2 	bral	80008120 <_vfprintf_r+0x1664>
800073a0:	40 2a       	lddsp	r10,sp[0x8]
800073a2:	5b fa       	cp.w	r10,-1
800073a4:	c0 41       	brne	800073ac <_vfprintf_r+0x8f0>
800073a6:	30 69       	mov	r9,6
800073a8:	50 29       	stdsp	sp[0x8],r9
800073aa:	c1 18       	rjmp	800073cc <_vfprintf_r+0x910>
800073ac:	e0 40 00 47 	cp.w	r0,71
800073b0:	5f 09       	sreq	r9
800073b2:	e0 40 00 67 	cp.w	r0,103
800073b6:	5f 08       	sreq	r8
800073b8:	f3 e8 10 08 	or	r8,r9,r8
800073bc:	f8 08 18 00 	cp.b	r8,r12
800073c0:	c0 60       	breq	800073cc <_vfprintf_r+0x910>
800073c2:	40 28       	lddsp	r8,sp[0x8]
800073c4:	58 08       	cp.w	r8,0
800073c6:	f9 b8 00 01 	moveq	r8,1
800073ca:	50 28       	stdsp	sp[0x8],r8
800073cc:	40 78       	lddsp	r8,sp[0x1c]
800073ce:	40 59       	lddsp	r9,sp[0x14]
800073d0:	fa e9 06 94 	st.d	sp[1684],r8
800073d4:	a9 a5       	sbr	r5,0x8
800073d6:	fa f8 06 94 	ld.w	r8,sp[1684]
800073da:	58 08       	cp.w	r8,0
800073dc:	c0 65       	brlt	800073e8 <_vfprintf_r+0x92c>
800073de:	40 5e       	lddsp	lr,sp[0x14]
800073e0:	30 0c       	mov	r12,0
800073e2:	50 6e       	stdsp	sp[0x18],lr
800073e4:	50 9c       	stdsp	sp[0x24],r12
800073e6:	c0 78       	rjmp	800073f4 <_vfprintf_r+0x938>
800073e8:	40 5b       	lddsp	r11,sp[0x14]
800073ea:	32 da       	mov	r10,45
800073ec:	ee 1b 80 00 	eorh	r11,0x8000
800073f0:	50 9a       	stdsp	sp[0x24],r10
800073f2:	50 6b       	stdsp	sp[0x18],r11
800073f4:	e0 40 00 46 	cp.w	r0,70
800073f8:	5f 09       	sreq	r9
800073fa:	e0 40 00 66 	cp.w	r0,102
800073fe:	5f 08       	sreq	r8
80007400:	f3 e8 10 08 	or	r8,r9,r8
80007404:	50 48       	stdsp	sp[0x10],r8
80007406:	c0 40       	breq	8000740e <_vfprintf_r+0x952>
80007408:	40 22       	lddsp	r2,sp[0x8]
8000740a:	30 39       	mov	r9,3
8000740c:	c1 08       	rjmp	8000742c <_vfprintf_r+0x970>
8000740e:	e0 40 00 45 	cp.w	r0,69
80007412:	5f 09       	sreq	r9
80007414:	e0 40 00 65 	cp.w	r0,101
80007418:	5f 08       	sreq	r8
8000741a:	40 22       	lddsp	r2,sp[0x8]
8000741c:	10 49       	or	r9,r8
8000741e:	2f f2       	sub	r2,-1
80007420:	40 46       	lddsp	r6,sp[0x10]
80007422:	ec 09 18 00 	cp.b	r9,r6
80007426:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000742a:	30 29       	mov	r9,2
8000742c:	fa c8 f9 5c 	sub	r8,sp,-1700
80007430:	1a d8       	st.w	--sp,r8
80007432:	fa c8 f9 54 	sub	r8,sp,-1708
80007436:	1a d8       	st.w	--sp,r8
80007438:	fa c8 f9 4c 	sub	r8,sp,-1716
8000743c:	08 9c       	mov	r12,r4
8000743e:	1a d8       	st.w	--sp,r8
80007440:	04 98       	mov	r8,r2
80007442:	40 9b       	lddsp	r11,sp[0x24]
80007444:	40 aa       	lddsp	r10,sp[0x28]
80007446:	e0 a0 0b c3 	rcall	80008bcc <_dtoa_r>
8000744a:	e0 40 00 47 	cp.w	r0,71
8000744e:	5f 19       	srne	r9
80007450:	e0 40 00 67 	cp.w	r0,103
80007454:	5f 18       	srne	r8
80007456:	18 96       	mov	r6,r12
80007458:	2f dd       	sub	sp,-12
8000745a:	f3 e8 00 08 	and	r8,r9,r8
8000745e:	c0 41       	brne	80007466 <_vfprintf_r+0x9aa>
80007460:	ed b5 00 00 	bld	r5,0x0
80007464:	c3 01       	brne	800074c4 <_vfprintf_r+0xa08>
80007466:	ec 02 00 0e 	add	lr,r6,r2
8000746a:	50 3e       	stdsp	sp[0xc],lr
8000746c:	40 4c       	lddsp	r12,sp[0x10]
8000746e:	58 0c       	cp.w	r12,0
80007470:	c1 50       	breq	8000749a <_vfprintf_r+0x9de>
80007472:	0d 89       	ld.ub	r9,r6[0x0]
80007474:	33 08       	mov	r8,48
80007476:	f0 09 18 00 	cp.b	r9,r8
8000747a:	c0 b1       	brne	80007490 <_vfprintf_r+0x9d4>
8000747c:	30 08       	mov	r8,0
8000747e:	30 09       	mov	r9,0
80007480:	40 6b       	lddsp	r11,sp[0x18]
80007482:	40 7a       	lddsp	r10,sp[0x1c]
80007484:	e0 a0 1c d7 	rcall	8000ae32 <__avr32_f64_cmp_eq>
80007488:	fb b2 00 01 	rsubeq	r2,1
8000748c:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80007490:	40 3b       	lddsp	r11,sp[0xc]
80007492:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007496:	10 0b       	add	r11,r8
80007498:	50 3b       	stdsp	sp[0xc],r11
8000749a:	40 6b       	lddsp	r11,sp[0x18]
8000749c:	30 08       	mov	r8,0
8000749e:	30 09       	mov	r9,0
800074a0:	40 7a       	lddsp	r10,sp[0x1c]
800074a2:	e0 a0 1c c8 	rcall	8000ae32 <__avr32_f64_cmp_eq>
800074a6:	c0 90       	breq	800074b8 <_vfprintf_r+0x9fc>
800074a8:	40 3a       	lddsp	r10,sp[0xc]
800074aa:	fb 4a 06 a4 	st.w	sp[1700],r10
800074ae:	c0 58       	rjmp	800074b8 <_vfprintf_r+0x9fc>
800074b0:	10 c9       	st.b	r8++,r9
800074b2:	fb 48 06 a4 	st.w	sp[1700],r8
800074b6:	c0 28       	rjmp	800074ba <_vfprintf_r+0x9fe>
800074b8:	33 09       	mov	r9,48
800074ba:	fa f8 06 a4 	ld.w	r8,sp[1700]
800074be:	40 3e       	lddsp	lr,sp[0xc]
800074c0:	1c 38       	cp.w	r8,lr
800074c2:	cf 73       	brcs	800074b0 <_vfprintf_r+0x9f4>
800074c4:	e0 40 00 47 	cp.w	r0,71
800074c8:	5f 09       	sreq	r9
800074ca:	e0 40 00 67 	cp.w	r0,103
800074ce:	5f 08       	sreq	r8
800074d0:	f3 e8 10 08 	or	r8,r9,r8
800074d4:	fa f9 06 a4 	ld.w	r9,sp[1700]
800074d8:	0c 19       	sub	r9,r6
800074da:	50 69       	stdsp	sp[0x18],r9
800074dc:	58 08       	cp.w	r8,0
800074de:	c0 b0       	breq	800074f4 <_vfprintf_r+0xa38>
800074e0:	fa f8 06 ac 	ld.w	r8,sp[1708]
800074e4:	5b d8       	cp.w	r8,-3
800074e6:	c0 55       	brlt	800074f0 <_vfprintf_r+0xa34>
800074e8:	40 2c       	lddsp	r12,sp[0x8]
800074ea:	18 38       	cp.w	r8,r12
800074ec:	e0 8a 00 6a 	brle	800075c0 <_vfprintf_r+0xb04>
800074f0:	20 20       	sub	r0,2
800074f2:	c0 58       	rjmp	800074fc <_vfprintf_r+0xa40>
800074f4:	e0 40 00 65 	cp.w	r0,101
800074f8:	e0 89 00 46 	brgt	80007584 <_vfprintf_r+0xac8>
800074fc:	fa fb 06 ac 	ld.w	r11,sp[1708]
80007500:	fb 60 06 9c 	st.b	sp[1692],r0
80007504:	20 1b       	sub	r11,1
80007506:	fb 4b 06 ac 	st.w	sp[1708],r11
8000750a:	c0 47       	brpl	80007512 <_vfprintf_r+0xa56>
8000750c:	5c 3b       	neg	r11
8000750e:	32 d8       	mov	r8,45
80007510:	c0 28       	rjmp	80007514 <_vfprintf_r+0xa58>
80007512:	32 b8       	mov	r8,43
80007514:	fb 68 06 9d 	st.b	sp[1693],r8
80007518:	58 9b       	cp.w	r11,9
8000751a:	e0 8a 00 1d 	brle	80007554 <_vfprintf_r+0xa98>
8000751e:	fa c9 fa 35 	sub	r9,sp,-1483
80007522:	30 aa       	mov	r10,10
80007524:	12 98       	mov	r8,r9
80007526:	0e 9c       	mov	r12,r7
80007528:	0c 92       	mov	r2,r6
8000752a:	f6 0a 0c 06 	divs	r6,r11,r10
8000752e:	0e 9b       	mov	r11,r7
80007530:	2d 0b       	sub	r11,-48
80007532:	10 fb       	st.b	--r8,r11
80007534:	0c 9b       	mov	r11,r6
80007536:	58 96       	cp.w	r6,9
80007538:	fe 99 ff f9 	brgt	8000752a <_vfprintf_r+0xa6e>
8000753c:	2d 0b       	sub	r11,-48
8000753e:	18 97       	mov	r7,r12
80007540:	04 96       	mov	r6,r2
80007542:	10 fb       	st.b	--r8,r11
80007544:	fa ca f9 62 	sub	r10,sp,-1694
80007548:	c0 38       	rjmp	8000754e <_vfprintf_r+0xa92>
8000754a:	11 3b       	ld.ub	r11,r8++
8000754c:	14 cb       	st.b	r10++,r11
8000754e:	12 38       	cp.w	r8,r9
80007550:	cf d3       	brcs	8000754a <_vfprintf_r+0xa8e>
80007552:	c0 98       	rjmp	80007564 <_vfprintf_r+0xaa8>
80007554:	2d 0b       	sub	r11,-48
80007556:	33 08       	mov	r8,48
80007558:	fb 6b 06 9f 	st.b	sp[1695],r11
8000755c:	fb 68 06 9e 	st.b	sp[1694],r8
80007560:	fa ca f9 60 	sub	r10,sp,-1696
80007564:	fa c8 f9 64 	sub	r8,sp,-1692
80007568:	f4 08 01 08 	sub	r8,r10,r8
8000756c:	50 e8       	stdsp	sp[0x38],r8
8000756e:	10 92       	mov	r2,r8
80007570:	40 6b       	lddsp	r11,sp[0x18]
80007572:	16 02       	add	r2,r11
80007574:	58 1b       	cp.w	r11,1
80007576:	e0 89 00 05 	brgt	80007580 <_vfprintf_r+0xac4>
8000757a:	ed b5 00 00 	bld	r5,0x0
8000757e:	c3 51       	brne	800075e8 <_vfprintf_r+0xb2c>
80007580:	2f f2       	sub	r2,-1
80007582:	c3 38       	rjmp	800075e8 <_vfprintf_r+0xb2c>
80007584:	e0 40 00 66 	cp.w	r0,102
80007588:	c1 c1       	brne	800075c0 <_vfprintf_r+0xb04>
8000758a:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000758e:	58 02       	cp.w	r2,0
80007590:	e0 8a 00 0c 	brle	800075a8 <_vfprintf_r+0xaec>
80007594:	40 2a       	lddsp	r10,sp[0x8]
80007596:	58 0a       	cp.w	r10,0
80007598:	c0 41       	brne	800075a0 <_vfprintf_r+0xae4>
8000759a:	ed b5 00 00 	bld	r5,0x0
8000759e:	c2 51       	brne	800075e8 <_vfprintf_r+0xb2c>
800075a0:	2f f2       	sub	r2,-1
800075a2:	40 29       	lddsp	r9,sp[0x8]
800075a4:	12 02       	add	r2,r9
800075a6:	c0 b8       	rjmp	800075bc <_vfprintf_r+0xb00>
800075a8:	40 28       	lddsp	r8,sp[0x8]
800075aa:	58 08       	cp.w	r8,0
800075ac:	c0 61       	brne	800075b8 <_vfprintf_r+0xafc>
800075ae:	ed b5 00 00 	bld	r5,0x0
800075b2:	c0 30       	breq	800075b8 <_vfprintf_r+0xafc>
800075b4:	30 12       	mov	r2,1
800075b6:	c1 98       	rjmp	800075e8 <_vfprintf_r+0xb2c>
800075b8:	40 22       	lddsp	r2,sp[0x8]
800075ba:	2f e2       	sub	r2,-2
800075bc:	36 60       	mov	r0,102
800075be:	c1 58       	rjmp	800075e8 <_vfprintf_r+0xb2c>
800075c0:	fa f2 06 ac 	ld.w	r2,sp[1708]
800075c4:	40 6e       	lddsp	lr,sp[0x18]
800075c6:	1c 32       	cp.w	r2,lr
800075c8:	c0 65       	brlt	800075d4 <_vfprintf_r+0xb18>
800075ca:	ed b5 00 00 	bld	r5,0x0
800075ce:	f7 b2 00 ff 	subeq	r2,-1
800075d2:	c0 a8       	rjmp	800075e6 <_vfprintf_r+0xb2a>
800075d4:	e4 08 11 02 	rsub	r8,r2,2
800075d8:	40 6c       	lddsp	r12,sp[0x18]
800075da:	58 02       	cp.w	r2,0
800075dc:	f0 02 17 a0 	movle	r2,r8
800075e0:	f9 b2 09 01 	movgt	r2,1
800075e4:	18 02       	add	r2,r12
800075e6:	36 70       	mov	r0,103
800075e8:	40 9b       	lddsp	r11,sp[0x24]
800075ea:	58 0b       	cp.w	r11,0
800075ec:	e0 80 05 94 	breq	80008114 <_vfprintf_r+0x1658>
800075f0:	32 d8       	mov	r8,45
800075f2:	fb 68 06 bb 	st.b	sp[1723],r8
800075f6:	e0 8f 05 93 	bral	8000811c <_vfprintf_r+0x1660>
800075fa:	50 a7       	stdsp	sp[0x28],r7
800075fc:	04 94       	mov	r4,r2
800075fe:	0c 97       	mov	r7,r6
80007600:	02 92       	mov	r2,r1
80007602:	06 96       	mov	r6,r3
80007604:	40 41       	lddsp	r1,sp[0x10]
80007606:	40 93       	lddsp	r3,sp[0x24]
80007608:	0e 99       	mov	r9,r7
8000760a:	ed b5 00 05 	bld	r5,0x5
8000760e:	c4 81       	brne	8000769e <_vfprintf_r+0xbe2>
80007610:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007614:	40 3e       	lddsp	lr,sp[0xc]
80007616:	58 0e       	cp.w	lr,0
80007618:	c1 d0       	breq	80007652 <_vfprintf_r+0xb96>
8000761a:	10 36       	cp.w	r6,r8
8000761c:	c0 64       	brge	80007628 <_vfprintf_r+0xb6c>
8000761e:	fa cc f9 44 	sub	r12,sp,-1724
80007622:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007626:	c1 d8       	rjmp	80007660 <_vfprintf_r+0xba4>
80007628:	fa c8 f9 50 	sub	r8,sp,-1712
8000762c:	1a d8       	st.w	--sp,r8
8000762e:	fa c8 fa b8 	sub	r8,sp,-1352
80007632:	04 9a       	mov	r10,r2
80007634:	1a d8       	st.w	--sp,r8
80007636:	fa c8 fb b4 	sub	r8,sp,-1100
8000763a:	0c 9b       	mov	r11,r6
8000763c:	1a d8       	st.w	--sp,r8
8000763e:	08 9c       	mov	r12,r4
80007640:	fa c8 f9 40 	sub	r8,sp,-1728
80007644:	fa c9 ff b4 	sub	r9,sp,-76
80007648:	fe b0 f8 a2 	rcall	8000678c <get_arg>
8000764c:	2f dd       	sub	sp,-12
8000764e:	78 0a       	ld.w	r10,r12[0x0]
80007650:	c2 08       	rjmp	80007690 <_vfprintf_r+0xbd4>
80007652:	2f f7       	sub	r7,-1
80007654:	10 39       	cp.w	r9,r8
80007656:	c0 84       	brge	80007666 <_vfprintf_r+0xbaa>
80007658:	fa cb f9 44 	sub	r11,sp,-1724
8000765c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007660:	ec fa fd 88 	ld.w	r10,r6[-632]
80007664:	c1 68       	rjmp	80007690 <_vfprintf_r+0xbd4>
80007666:	41 09       	lddsp	r9,sp[0x40]
80007668:	59 f8       	cp.w	r8,31
8000766a:	e0 89 00 10 	brgt	8000768a <_vfprintf_r+0xbce>
8000766e:	f2 ca ff fc 	sub	r10,r9,-4
80007672:	51 0a       	stdsp	sp[0x40],r10
80007674:	fa c6 f9 44 	sub	r6,sp,-1724
80007678:	72 0a       	ld.w	r10,r9[0x0]
8000767a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000767e:	f3 4a fd 88 	st.w	r9[-632],r10
80007682:	2f f8       	sub	r8,-1
80007684:	fb 48 06 b4 	st.w	sp[1716],r8
80007688:	c0 48       	rjmp	80007690 <_vfprintf_r+0xbd4>
8000768a:	72 0a       	ld.w	r10,r9[0x0]
8000768c:	2f c9       	sub	r9,-4
8000768e:	51 09       	stdsp	sp[0x40],r9
80007690:	40 be       	lddsp	lr,sp[0x2c]
80007692:	1c 98       	mov	r8,lr
80007694:	95 1e       	st.w	r10[0x4],lr
80007696:	bf 58       	asr	r8,0x1f
80007698:	95 08       	st.w	r10[0x0],r8
8000769a:	fe 9f fa 9f 	bral	80006bd8 <_vfprintf_r+0x11c>
8000769e:	ed b5 00 04 	bld	r5,0x4
800076a2:	c4 80       	breq	80007732 <_vfprintf_r+0xc76>
800076a4:	e2 15 00 40 	andl	r5,0x40,COH
800076a8:	c4 50       	breq	80007732 <_vfprintf_r+0xc76>
800076aa:	fa f8 06 b4 	ld.w	r8,sp[1716]
800076ae:	40 3c       	lddsp	r12,sp[0xc]
800076b0:	58 0c       	cp.w	r12,0
800076b2:	c1 d0       	breq	800076ec <_vfprintf_r+0xc30>
800076b4:	10 36       	cp.w	r6,r8
800076b6:	c0 64       	brge	800076c2 <_vfprintf_r+0xc06>
800076b8:	fa cb f9 44 	sub	r11,sp,-1724
800076bc:	f6 06 00 36 	add	r6,r11,r6<<0x3
800076c0:	c1 d8       	rjmp	800076fa <_vfprintf_r+0xc3e>
800076c2:	fa c8 f9 50 	sub	r8,sp,-1712
800076c6:	1a d8       	st.w	--sp,r8
800076c8:	fa c8 fa b8 	sub	r8,sp,-1352
800076cc:	04 9a       	mov	r10,r2
800076ce:	1a d8       	st.w	--sp,r8
800076d0:	fa c8 fb b4 	sub	r8,sp,-1100
800076d4:	0c 9b       	mov	r11,r6
800076d6:	1a d8       	st.w	--sp,r8
800076d8:	08 9c       	mov	r12,r4
800076da:	fa c8 f9 40 	sub	r8,sp,-1728
800076de:	fa c9 ff b4 	sub	r9,sp,-76
800076e2:	fe b0 f8 55 	rcall	8000678c <get_arg>
800076e6:	2f dd       	sub	sp,-12
800076e8:	78 0a       	ld.w	r10,r12[0x0]
800076ea:	c2 08       	rjmp	8000772a <_vfprintf_r+0xc6e>
800076ec:	2f f7       	sub	r7,-1
800076ee:	10 39       	cp.w	r9,r8
800076f0:	c0 84       	brge	80007700 <_vfprintf_r+0xc44>
800076f2:	fa ca f9 44 	sub	r10,sp,-1724
800076f6:	f4 06 00 36 	add	r6,r10,r6<<0x3
800076fa:	ec fa fd 88 	ld.w	r10,r6[-632]
800076fe:	c1 68       	rjmp	8000772a <_vfprintf_r+0xc6e>
80007700:	41 09       	lddsp	r9,sp[0x40]
80007702:	59 f8       	cp.w	r8,31
80007704:	e0 89 00 10 	brgt	80007724 <_vfprintf_r+0xc68>
80007708:	f2 ca ff fc 	sub	r10,r9,-4
8000770c:	51 0a       	stdsp	sp[0x40],r10
8000770e:	fa c6 f9 44 	sub	r6,sp,-1724
80007712:	72 0a       	ld.w	r10,r9[0x0]
80007714:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007718:	f3 4a fd 88 	st.w	r9[-632],r10
8000771c:	2f f8       	sub	r8,-1
8000771e:	fb 48 06 b4 	st.w	sp[1716],r8
80007722:	c0 48       	rjmp	8000772a <_vfprintf_r+0xc6e>
80007724:	72 0a       	ld.w	r10,r9[0x0]
80007726:	2f c9       	sub	r9,-4
80007728:	51 09       	stdsp	sp[0x40],r9
8000772a:	40 be       	lddsp	lr,sp[0x2c]
8000772c:	b4 0e       	st.h	r10[0x0],lr
8000772e:	fe 9f fa 55 	bral	80006bd8 <_vfprintf_r+0x11c>
80007732:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007736:	40 3c       	lddsp	r12,sp[0xc]
80007738:	58 0c       	cp.w	r12,0
8000773a:	c1 d0       	breq	80007774 <_vfprintf_r+0xcb8>
8000773c:	10 36       	cp.w	r6,r8
8000773e:	c0 64       	brge	8000774a <_vfprintf_r+0xc8e>
80007740:	fa cb f9 44 	sub	r11,sp,-1724
80007744:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007748:	c1 d8       	rjmp	80007782 <_vfprintf_r+0xcc6>
8000774a:	fa c8 f9 50 	sub	r8,sp,-1712
8000774e:	1a d8       	st.w	--sp,r8
80007750:	fa c8 fa b8 	sub	r8,sp,-1352
80007754:	04 9a       	mov	r10,r2
80007756:	1a d8       	st.w	--sp,r8
80007758:	fa c8 fb b4 	sub	r8,sp,-1100
8000775c:	0c 9b       	mov	r11,r6
8000775e:	1a d8       	st.w	--sp,r8
80007760:	08 9c       	mov	r12,r4
80007762:	fa c8 f9 40 	sub	r8,sp,-1728
80007766:	fa c9 ff b4 	sub	r9,sp,-76
8000776a:	fe b0 f8 11 	rcall	8000678c <get_arg>
8000776e:	2f dd       	sub	sp,-12
80007770:	78 0a       	ld.w	r10,r12[0x0]
80007772:	c2 08       	rjmp	800077b2 <_vfprintf_r+0xcf6>
80007774:	2f f7       	sub	r7,-1
80007776:	10 39       	cp.w	r9,r8
80007778:	c0 84       	brge	80007788 <_vfprintf_r+0xccc>
8000777a:	fa ca f9 44 	sub	r10,sp,-1724
8000777e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007782:	ec fa fd 88 	ld.w	r10,r6[-632]
80007786:	c1 68       	rjmp	800077b2 <_vfprintf_r+0xcf6>
80007788:	41 09       	lddsp	r9,sp[0x40]
8000778a:	59 f8       	cp.w	r8,31
8000778c:	e0 89 00 10 	brgt	800077ac <_vfprintf_r+0xcf0>
80007790:	f2 ca ff fc 	sub	r10,r9,-4
80007794:	51 0a       	stdsp	sp[0x40],r10
80007796:	fa c6 f9 44 	sub	r6,sp,-1724
8000779a:	72 0a       	ld.w	r10,r9[0x0]
8000779c:	ec 08 00 39 	add	r9,r6,r8<<0x3
800077a0:	f3 4a fd 88 	st.w	r9[-632],r10
800077a4:	2f f8       	sub	r8,-1
800077a6:	fb 48 06 b4 	st.w	sp[1716],r8
800077aa:	c0 48       	rjmp	800077b2 <_vfprintf_r+0xcf6>
800077ac:	72 0a       	ld.w	r10,r9[0x0]
800077ae:	2f c9       	sub	r9,-4
800077b0:	51 09       	stdsp	sp[0x40],r9
800077b2:	40 be       	lddsp	lr,sp[0x2c]
800077b4:	95 0e       	st.w	r10[0x0],lr
800077b6:	fe 9f fa 11 	bral	80006bd8 <_vfprintf_r+0x11c>
800077ba:	50 a7       	stdsp	sp[0x28],r7
800077bc:	50 80       	stdsp	sp[0x20],r0
800077be:	0c 97       	mov	r7,r6
800077c0:	04 94       	mov	r4,r2
800077c2:	06 96       	mov	r6,r3
800077c4:	02 92       	mov	r2,r1
800077c6:	40 93       	lddsp	r3,sp[0x24]
800077c8:	10 90       	mov	r0,r8
800077ca:	40 41       	lddsp	r1,sp[0x10]
800077cc:	a5 a5       	sbr	r5,0x4
800077ce:	c0 a8       	rjmp	800077e2 <_vfprintf_r+0xd26>
800077d0:	50 a7       	stdsp	sp[0x28],r7
800077d2:	50 80       	stdsp	sp[0x20],r0
800077d4:	0c 97       	mov	r7,r6
800077d6:	04 94       	mov	r4,r2
800077d8:	06 96       	mov	r6,r3
800077da:	02 92       	mov	r2,r1
800077dc:	40 93       	lddsp	r3,sp[0x24]
800077de:	10 90       	mov	r0,r8
800077e0:	40 41       	lddsp	r1,sp[0x10]
800077e2:	ed b5 00 05 	bld	r5,0x5
800077e6:	c5 d1       	brne	800078a0 <_vfprintf_r+0xde4>
800077e8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800077ec:	40 3c       	lddsp	r12,sp[0xc]
800077ee:	58 0c       	cp.w	r12,0
800077f0:	c2 60       	breq	8000783c <_vfprintf_r+0xd80>
800077f2:	10 36       	cp.w	r6,r8
800077f4:	c0 a4       	brge	80007808 <_vfprintf_r+0xd4c>
800077f6:	fa cb f9 44 	sub	r11,sp,-1724
800077fa:	f6 06 00 36 	add	r6,r11,r6<<0x3
800077fe:	ec e8 fd 88 	ld.d	r8,r6[-632]
80007802:	fa e9 00 00 	st.d	sp[0],r8
80007806:	c1 88       	rjmp	80007836 <_vfprintf_r+0xd7a>
80007808:	fa c8 f9 50 	sub	r8,sp,-1712
8000780c:	1a d8       	st.w	--sp,r8
8000780e:	fa c8 fa b8 	sub	r8,sp,-1352
80007812:	04 9a       	mov	r10,r2
80007814:	1a d8       	st.w	--sp,r8
80007816:	0c 9b       	mov	r11,r6
80007818:	fa c8 fb b4 	sub	r8,sp,-1100
8000781c:	08 9c       	mov	r12,r4
8000781e:	1a d8       	st.w	--sp,r8
80007820:	fa c8 f9 40 	sub	r8,sp,-1728
80007824:	fa c9 ff b4 	sub	r9,sp,-76
80007828:	fe b0 f7 b2 	rcall	8000678c <get_arg>
8000782c:	2f dd       	sub	sp,-12
8000782e:	f8 ea 00 00 	ld.d	r10,r12[0]
80007832:	fa eb 00 00 	st.d	sp[0],r10
80007836:	30 08       	mov	r8,0
80007838:	e0 8f 03 de 	bral	80007ff4 <_vfprintf_r+0x1538>
8000783c:	ee ca ff ff 	sub	r10,r7,-1
80007840:	10 37       	cp.w	r7,r8
80007842:	c0 b4       	brge	80007858 <_vfprintf_r+0xd9c>
80007844:	fa c9 f9 44 	sub	r9,sp,-1724
80007848:	14 97       	mov	r7,r10
8000784a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000784e:	ec ea fd 88 	ld.d	r10,r6[-632]
80007852:	fa eb 00 00 	st.d	sp[0],r10
80007856:	c1 88       	rjmp	80007886 <_vfprintf_r+0xdca>
80007858:	41 09       	lddsp	r9,sp[0x40]
8000785a:	59 f8       	cp.w	r8,31
8000785c:	e0 89 00 18 	brgt	8000788c <_vfprintf_r+0xdd0>
80007860:	f2 e6 00 00 	ld.d	r6,r9[0]
80007864:	f2 cb ff f8 	sub	r11,r9,-8
80007868:	fa e7 00 00 	st.d	sp[0],r6
8000786c:	51 0b       	stdsp	sp[0x40],r11
8000786e:	fa c6 f9 44 	sub	r6,sp,-1724
80007872:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007876:	fa e6 00 00 	ld.d	r6,sp[0]
8000787a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000787e:	2f f8       	sub	r8,-1
80007880:	14 97       	mov	r7,r10
80007882:	fb 48 06 b4 	st.w	sp[1716],r8
80007886:	40 38       	lddsp	r8,sp[0xc]
80007888:	e0 8f 03 b6 	bral	80007ff4 <_vfprintf_r+0x1538>
8000788c:	f2 e6 00 00 	ld.d	r6,r9[0]
80007890:	40 38       	lddsp	r8,sp[0xc]
80007892:	fa e7 00 00 	st.d	sp[0],r6
80007896:	2f 89       	sub	r9,-8
80007898:	14 97       	mov	r7,r10
8000789a:	51 09       	stdsp	sp[0x40],r9
8000789c:	e0 8f 03 ac 	bral	80007ff4 <_vfprintf_r+0x1538>
800078a0:	ed b5 00 04 	bld	r5,0x4
800078a4:	c1 61       	brne	800078d0 <_vfprintf_r+0xe14>
800078a6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800078aa:	40 3e       	lddsp	lr,sp[0xc]
800078ac:	58 0e       	cp.w	lr,0
800078ae:	c0 80       	breq	800078be <_vfprintf_r+0xe02>
800078b0:	10 36       	cp.w	r6,r8
800078b2:	c6 74       	brge	80007980 <_vfprintf_r+0xec4>
800078b4:	fa cc f9 44 	sub	r12,sp,-1724
800078b8:	f8 06 00 36 	add	r6,r12,r6<<0x3
800078bc:	c8 08       	rjmp	800079bc <_vfprintf_r+0xf00>
800078be:	ee ca ff ff 	sub	r10,r7,-1
800078c2:	10 37       	cp.w	r7,r8
800078c4:	c7 f4       	brge	800079c2 <_vfprintf_r+0xf06>
800078c6:	fa cb f9 44 	sub	r11,sp,-1724
800078ca:	f6 06 00 36 	add	r6,r11,r6<<0x3
800078ce:	c7 68       	rjmp	800079ba <_vfprintf_r+0xefe>
800078d0:	ed b5 00 06 	bld	r5,0x6
800078d4:	c4 a1       	brne	80007968 <_vfprintf_r+0xeac>
800078d6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800078da:	40 3c       	lddsp	r12,sp[0xc]
800078dc:	58 0c       	cp.w	r12,0
800078de:	c1 d0       	breq	80007918 <_vfprintf_r+0xe5c>
800078e0:	10 36       	cp.w	r6,r8
800078e2:	c0 64       	brge	800078ee <_vfprintf_r+0xe32>
800078e4:	fa cb f9 44 	sub	r11,sp,-1724
800078e8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800078ec:	c1 f8       	rjmp	8000792a <_vfprintf_r+0xe6e>
800078ee:	fa c8 f9 50 	sub	r8,sp,-1712
800078f2:	1a d8       	st.w	--sp,r8
800078f4:	fa c8 fa b8 	sub	r8,sp,-1352
800078f8:	1a d8       	st.w	--sp,r8
800078fa:	fa c8 fb b4 	sub	r8,sp,-1100
800078fe:	1a d8       	st.w	--sp,r8
80007900:	fa c8 f9 40 	sub	r8,sp,-1728
80007904:	fa c9 ff b4 	sub	r9,sp,-76
80007908:	04 9a       	mov	r10,r2
8000790a:	0c 9b       	mov	r11,r6
8000790c:	08 9c       	mov	r12,r4
8000790e:	fe b0 f7 3f 	rcall	8000678c <get_arg>
80007912:	2f dd       	sub	sp,-12
80007914:	98 18       	ld.sh	r8,r12[0x2]
80007916:	c2 68       	rjmp	80007962 <_vfprintf_r+0xea6>
80007918:	ee ca ff ff 	sub	r10,r7,-1
8000791c:	10 37       	cp.w	r7,r8
8000791e:	c0 94       	brge	80007930 <_vfprintf_r+0xe74>
80007920:	fa c9 f9 44 	sub	r9,sp,-1724
80007924:	14 97       	mov	r7,r10
80007926:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000792a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000792e:	c1 a8       	rjmp	80007962 <_vfprintf_r+0xea6>
80007930:	41 09       	lddsp	r9,sp[0x40]
80007932:	59 f8       	cp.w	r8,31
80007934:	e0 89 00 13 	brgt	8000795a <_vfprintf_r+0xe9e>
80007938:	f2 cb ff fc 	sub	r11,r9,-4
8000793c:	51 0b       	stdsp	sp[0x40],r11
8000793e:	72 09       	ld.w	r9,r9[0x0]
80007940:	fa c6 f9 44 	sub	r6,sp,-1724
80007944:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007948:	2f f8       	sub	r8,-1
8000794a:	f7 49 fd 88 	st.w	r11[-632],r9
8000794e:	fb 48 06 b4 	st.w	sp[1716],r8
80007952:	14 97       	mov	r7,r10
80007954:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007958:	c0 58       	rjmp	80007962 <_vfprintf_r+0xea6>
8000795a:	92 18       	ld.sh	r8,r9[0x2]
8000795c:	14 97       	mov	r7,r10
8000795e:	2f c9       	sub	r9,-4
80007960:	51 09       	stdsp	sp[0x40],r9
80007962:	5c 78       	castu.h	r8
80007964:	50 18       	stdsp	sp[0x4],r8
80007966:	c4 68       	rjmp	800079f2 <_vfprintf_r+0xf36>
80007968:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000796c:	40 3c       	lddsp	r12,sp[0xc]
8000796e:	58 0c       	cp.w	r12,0
80007970:	c1 d0       	breq	800079aa <_vfprintf_r+0xeee>
80007972:	10 36       	cp.w	r6,r8
80007974:	c0 64       	brge	80007980 <_vfprintf_r+0xec4>
80007976:	fa cb f9 44 	sub	r11,sp,-1724
8000797a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000797e:	c1 f8       	rjmp	800079bc <_vfprintf_r+0xf00>
80007980:	fa c8 f9 50 	sub	r8,sp,-1712
80007984:	1a d8       	st.w	--sp,r8
80007986:	fa c8 fa b8 	sub	r8,sp,-1352
8000798a:	0c 9b       	mov	r11,r6
8000798c:	1a d8       	st.w	--sp,r8
8000798e:	fa c8 fb b4 	sub	r8,sp,-1100
80007992:	04 9a       	mov	r10,r2
80007994:	1a d8       	st.w	--sp,r8
80007996:	08 9c       	mov	r12,r4
80007998:	fa c8 f9 40 	sub	r8,sp,-1728
8000799c:	fa c9 ff b4 	sub	r9,sp,-76
800079a0:	fe b0 f6 f6 	rcall	8000678c <get_arg>
800079a4:	2f dd       	sub	sp,-12
800079a6:	78 0b       	ld.w	r11,r12[0x0]
800079a8:	c2 48       	rjmp	800079f0 <_vfprintf_r+0xf34>
800079aa:	ee ca ff ff 	sub	r10,r7,-1
800079ae:	10 37       	cp.w	r7,r8
800079b0:	c0 94       	brge	800079c2 <_vfprintf_r+0xf06>
800079b2:	fa c9 f9 44 	sub	r9,sp,-1724
800079b6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800079ba:	14 97       	mov	r7,r10
800079bc:	ec fb fd 88 	ld.w	r11,r6[-632]
800079c0:	c1 88       	rjmp	800079f0 <_vfprintf_r+0xf34>
800079c2:	41 09       	lddsp	r9,sp[0x40]
800079c4:	59 f8       	cp.w	r8,31
800079c6:	e0 89 00 11 	brgt	800079e8 <_vfprintf_r+0xf2c>
800079ca:	f2 cb ff fc 	sub	r11,r9,-4
800079ce:	51 0b       	stdsp	sp[0x40],r11
800079d0:	fa c6 f9 44 	sub	r6,sp,-1724
800079d4:	72 0b       	ld.w	r11,r9[0x0]
800079d6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800079da:	f3 4b fd 88 	st.w	r9[-632],r11
800079de:	2f f8       	sub	r8,-1
800079e0:	14 97       	mov	r7,r10
800079e2:	fb 48 06 b4 	st.w	sp[1716],r8
800079e6:	c0 58       	rjmp	800079f0 <_vfprintf_r+0xf34>
800079e8:	72 0b       	ld.w	r11,r9[0x0]
800079ea:	14 97       	mov	r7,r10
800079ec:	2f c9       	sub	r9,-4
800079ee:	51 09       	stdsp	sp[0x40],r9
800079f0:	50 1b       	stdsp	sp[0x4],r11
800079f2:	30 0e       	mov	lr,0
800079f4:	50 0e       	stdsp	sp[0x0],lr
800079f6:	1c 98       	mov	r8,lr
800079f8:	e0 8f 02 fe 	bral	80007ff4 <_vfprintf_r+0x1538>
800079fc:	50 a7       	stdsp	sp[0x28],r7
800079fe:	50 80       	stdsp	sp[0x20],r0
80007a00:	0c 97       	mov	r7,r6
80007a02:	04 94       	mov	r4,r2
80007a04:	06 96       	mov	r6,r3
80007a06:	02 92       	mov	r2,r1
80007a08:	40 93       	lddsp	r3,sp[0x24]
80007a0a:	40 41       	lddsp	r1,sp[0x10]
80007a0c:	0e 99       	mov	r9,r7
80007a0e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007a12:	40 3c       	lddsp	r12,sp[0xc]
80007a14:	58 0c       	cp.w	r12,0
80007a16:	c1 d0       	breq	80007a50 <_vfprintf_r+0xf94>
80007a18:	10 36       	cp.w	r6,r8
80007a1a:	c0 64       	brge	80007a26 <_vfprintf_r+0xf6a>
80007a1c:	fa cb f9 44 	sub	r11,sp,-1724
80007a20:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007a24:	c1 d8       	rjmp	80007a5e <_vfprintf_r+0xfa2>
80007a26:	fa c8 f9 50 	sub	r8,sp,-1712
80007a2a:	1a d8       	st.w	--sp,r8
80007a2c:	fa c8 fa b8 	sub	r8,sp,-1352
80007a30:	1a d8       	st.w	--sp,r8
80007a32:	fa c8 fb b4 	sub	r8,sp,-1100
80007a36:	1a d8       	st.w	--sp,r8
80007a38:	fa c9 ff b4 	sub	r9,sp,-76
80007a3c:	fa c8 f9 40 	sub	r8,sp,-1728
80007a40:	04 9a       	mov	r10,r2
80007a42:	0c 9b       	mov	r11,r6
80007a44:	08 9c       	mov	r12,r4
80007a46:	fe b0 f6 a3 	rcall	8000678c <get_arg>
80007a4a:	2f dd       	sub	sp,-12
80007a4c:	78 09       	ld.w	r9,r12[0x0]
80007a4e:	c2 18       	rjmp	80007a90 <_vfprintf_r+0xfd4>
80007a50:	2f f7       	sub	r7,-1
80007a52:	10 39       	cp.w	r9,r8
80007a54:	c0 84       	brge	80007a64 <_vfprintf_r+0xfa8>
80007a56:	fa ca f9 44 	sub	r10,sp,-1724
80007a5a:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007a5e:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007a62:	c1 78       	rjmp	80007a90 <_vfprintf_r+0xfd4>
80007a64:	41 09       	lddsp	r9,sp[0x40]
80007a66:	59 f8       	cp.w	r8,31
80007a68:	e0 89 00 10 	brgt	80007a88 <_vfprintf_r+0xfcc>
80007a6c:	f2 ca ff fc 	sub	r10,r9,-4
80007a70:	51 0a       	stdsp	sp[0x40],r10
80007a72:	fa c6 f9 44 	sub	r6,sp,-1724
80007a76:	72 09       	ld.w	r9,r9[0x0]
80007a78:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007a7c:	f5 49 fd 88 	st.w	r10[-632],r9
80007a80:	2f f8       	sub	r8,-1
80007a82:	fb 48 06 b4 	st.w	sp[1716],r8
80007a86:	c0 58       	rjmp	80007a90 <_vfprintf_r+0xfd4>
80007a88:	f2 c8 ff fc 	sub	r8,r9,-4
80007a8c:	51 08       	stdsp	sp[0x40],r8
80007a8e:	72 09       	ld.w	r9,r9[0x0]
80007a90:	33 08       	mov	r8,48
80007a92:	fb 68 06 b8 	st.b	sp[1720],r8
80007a96:	37 88       	mov	r8,120
80007a98:	30 0e       	mov	lr,0
80007a9a:	fb 68 06 b9 	st.b	sp[1721],r8
80007a9e:	fe cc b1 66 	sub	r12,pc,-20122
80007aa2:	50 19       	stdsp	sp[0x4],r9
80007aa4:	a1 b5       	sbr	r5,0x1
80007aa6:	50 0e       	stdsp	sp[0x0],lr
80007aa8:	50 dc       	stdsp	sp[0x34],r12
80007aaa:	30 28       	mov	r8,2
80007aac:	37 80       	mov	r0,120
80007aae:	e0 8f 02 a3 	bral	80007ff4 <_vfprintf_r+0x1538>
80007ab2:	50 a7       	stdsp	sp[0x28],r7
80007ab4:	50 80       	stdsp	sp[0x20],r0
80007ab6:	10 90       	mov	r0,r8
80007ab8:	30 08       	mov	r8,0
80007aba:	fb 68 06 bb 	st.b	sp[1723],r8
80007abe:	0c 97       	mov	r7,r6
80007ac0:	04 94       	mov	r4,r2
80007ac2:	06 96       	mov	r6,r3
80007ac4:	02 92       	mov	r2,r1
80007ac6:	40 93       	lddsp	r3,sp[0x24]
80007ac8:	40 41       	lddsp	r1,sp[0x10]
80007aca:	0e 99       	mov	r9,r7
80007acc:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007ad0:	40 3b       	lddsp	r11,sp[0xc]
80007ad2:	58 0b       	cp.w	r11,0
80007ad4:	c1 d0       	breq	80007b0e <_vfprintf_r+0x1052>
80007ad6:	10 36       	cp.w	r6,r8
80007ad8:	c0 64       	brge	80007ae4 <_vfprintf_r+0x1028>
80007ada:	fa ca f9 44 	sub	r10,sp,-1724
80007ade:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007ae2:	c1 d8       	rjmp	80007b1c <_vfprintf_r+0x1060>
80007ae4:	fa c8 f9 50 	sub	r8,sp,-1712
80007ae8:	1a d8       	st.w	--sp,r8
80007aea:	fa c8 fa b8 	sub	r8,sp,-1352
80007aee:	1a d8       	st.w	--sp,r8
80007af0:	fa c8 fb b4 	sub	r8,sp,-1100
80007af4:	0c 9b       	mov	r11,r6
80007af6:	1a d8       	st.w	--sp,r8
80007af8:	04 9a       	mov	r10,r2
80007afa:	fa c8 f9 40 	sub	r8,sp,-1728
80007afe:	fa c9 ff b4 	sub	r9,sp,-76
80007b02:	08 9c       	mov	r12,r4
80007b04:	fe b0 f6 44 	rcall	8000678c <get_arg>
80007b08:	2f dd       	sub	sp,-12
80007b0a:	78 06       	ld.w	r6,r12[0x0]
80007b0c:	c2 08       	rjmp	80007b4c <_vfprintf_r+0x1090>
80007b0e:	2f f7       	sub	r7,-1
80007b10:	10 39       	cp.w	r9,r8
80007b12:	c0 84       	brge	80007b22 <_vfprintf_r+0x1066>
80007b14:	fa c9 f9 44 	sub	r9,sp,-1724
80007b18:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007b1c:	ec f6 fd 88 	ld.w	r6,r6[-632]
80007b20:	c1 68       	rjmp	80007b4c <_vfprintf_r+0x1090>
80007b22:	41 09       	lddsp	r9,sp[0x40]
80007b24:	59 f8       	cp.w	r8,31
80007b26:	e0 89 00 10 	brgt	80007b46 <_vfprintf_r+0x108a>
80007b2a:	f2 ca ff fc 	sub	r10,r9,-4
80007b2e:	51 0a       	stdsp	sp[0x40],r10
80007b30:	72 06       	ld.w	r6,r9[0x0]
80007b32:	fa ce f9 44 	sub	lr,sp,-1724
80007b36:	fc 08 00 39 	add	r9,lr,r8<<0x3
80007b3a:	f3 46 fd 88 	st.w	r9[-632],r6
80007b3e:	2f f8       	sub	r8,-1
80007b40:	fb 48 06 b4 	st.w	sp[1716],r8
80007b44:	c0 48       	rjmp	80007b4c <_vfprintf_r+0x1090>
80007b46:	72 06       	ld.w	r6,r9[0x0]
80007b48:	2f c9       	sub	r9,-4
80007b4a:	51 09       	stdsp	sp[0x40],r9
80007b4c:	40 2c       	lddsp	r12,sp[0x8]
80007b4e:	58 0c       	cp.w	r12,0
80007b50:	c1 05       	brlt	80007b70 <_vfprintf_r+0x10b4>
80007b52:	18 9a       	mov	r10,r12
80007b54:	30 0b       	mov	r11,0
80007b56:	0c 9c       	mov	r12,r6
80007b58:	e0 a0 12 38 	rcall	80009fc8 <memchr>
80007b5c:	e0 80 02 df 	breq	8000811a <_vfprintf_r+0x165e>
80007b60:	f8 06 01 02 	sub	r2,r12,r6
80007b64:	40 2b       	lddsp	r11,sp[0x8]
80007b66:	16 32       	cp.w	r2,r11
80007b68:	e0 89 02 d9 	brgt	8000811a <_vfprintf_r+0x165e>
80007b6c:	e0 8f 02 d4 	bral	80008114 <_vfprintf_r+0x1658>
80007b70:	30 0a       	mov	r10,0
80007b72:	0c 9c       	mov	r12,r6
80007b74:	50 2a       	stdsp	sp[0x8],r10
80007b76:	e0 a0 15 99 	rcall	8000a6a8 <strlen>
80007b7a:	18 92       	mov	r2,r12
80007b7c:	e0 8f 02 d2 	bral	80008120 <_vfprintf_r+0x1664>
80007b80:	50 a7       	stdsp	sp[0x28],r7
80007b82:	50 80       	stdsp	sp[0x20],r0
80007b84:	0c 97       	mov	r7,r6
80007b86:	04 94       	mov	r4,r2
80007b88:	06 96       	mov	r6,r3
80007b8a:	02 92       	mov	r2,r1
80007b8c:	40 93       	lddsp	r3,sp[0x24]
80007b8e:	10 90       	mov	r0,r8
80007b90:	40 41       	lddsp	r1,sp[0x10]
80007b92:	a5 a5       	sbr	r5,0x4
80007b94:	c0 a8       	rjmp	80007ba8 <_vfprintf_r+0x10ec>
80007b96:	50 a7       	stdsp	sp[0x28],r7
80007b98:	50 80       	stdsp	sp[0x20],r0
80007b9a:	0c 97       	mov	r7,r6
80007b9c:	04 94       	mov	r4,r2
80007b9e:	06 96       	mov	r6,r3
80007ba0:	02 92       	mov	r2,r1
80007ba2:	40 93       	lddsp	r3,sp[0x24]
80007ba4:	10 90       	mov	r0,r8
80007ba6:	40 41       	lddsp	r1,sp[0x10]
80007ba8:	ed b5 00 05 	bld	r5,0x5
80007bac:	c5 61       	brne	80007c58 <_vfprintf_r+0x119c>
80007bae:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007bb2:	40 39       	lddsp	r9,sp[0xc]
80007bb4:	58 09       	cp.w	r9,0
80007bb6:	c2 10       	breq	80007bf8 <_vfprintf_r+0x113c>
80007bb8:	10 36       	cp.w	r6,r8
80007bba:	c0 74       	brge	80007bc8 <_vfprintf_r+0x110c>
80007bbc:	fa c8 f9 44 	sub	r8,sp,-1724
80007bc0:	f0 06 00 36 	add	r6,r8,r6<<0x3
80007bc4:	c2 38       	rjmp	80007c0a <_vfprintf_r+0x114e>
80007bc6:	d7 03       	nop
80007bc8:	fa c8 f9 50 	sub	r8,sp,-1712
80007bcc:	1a d8       	st.w	--sp,r8
80007bce:	fa c8 fa b8 	sub	r8,sp,-1352
80007bd2:	1a d8       	st.w	--sp,r8
80007bd4:	fa c8 fb b4 	sub	r8,sp,-1100
80007bd8:	1a d8       	st.w	--sp,r8
80007bda:	fa c8 f9 40 	sub	r8,sp,-1728
80007bde:	fa c9 ff b4 	sub	r9,sp,-76
80007be2:	04 9a       	mov	r10,r2
80007be4:	0c 9b       	mov	r11,r6
80007be6:	08 9c       	mov	r12,r4
80007be8:	fe b0 f5 d2 	rcall	8000678c <get_arg>
80007bec:	2f dd       	sub	sp,-12
80007bee:	f8 e8 00 00 	ld.d	r8,r12[0]
80007bf2:	fa e9 00 00 	st.d	sp[0],r8
80007bf6:	c2 e8       	rjmp	80007c52 <_vfprintf_r+0x1196>
80007bf8:	ee ca ff ff 	sub	r10,r7,-1
80007bfc:	10 37       	cp.w	r7,r8
80007bfe:	c0 b4       	brge	80007c14 <_vfprintf_r+0x1158>
80007c00:	fa c8 f9 44 	sub	r8,sp,-1724
80007c04:	14 97       	mov	r7,r10
80007c06:	f0 06 00 36 	add	r6,r8,r6<<0x3
80007c0a:	ec ea fd 88 	ld.d	r10,r6[-632]
80007c0e:	fa eb 00 00 	st.d	sp[0],r10
80007c12:	c2 08       	rjmp	80007c52 <_vfprintf_r+0x1196>
80007c14:	41 09       	lddsp	r9,sp[0x40]
80007c16:	59 f8       	cp.w	r8,31
80007c18:	e0 89 00 16 	brgt	80007c44 <_vfprintf_r+0x1188>
80007c1c:	f2 e6 00 00 	ld.d	r6,r9[0]
80007c20:	f2 cb ff f8 	sub	r11,r9,-8
80007c24:	fa e7 00 00 	st.d	sp[0],r6
80007c28:	51 0b       	stdsp	sp[0x40],r11
80007c2a:	fa c6 f9 44 	sub	r6,sp,-1724
80007c2e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007c32:	fa e6 00 00 	ld.d	r6,sp[0]
80007c36:	f2 e7 fd 88 	st.d	r9[-632],r6
80007c3a:	2f f8       	sub	r8,-1
80007c3c:	14 97       	mov	r7,r10
80007c3e:	fb 48 06 b4 	st.w	sp[1716],r8
80007c42:	c0 88       	rjmp	80007c52 <_vfprintf_r+0x1196>
80007c44:	f2 e6 00 00 	ld.d	r6,r9[0]
80007c48:	2f 89       	sub	r9,-8
80007c4a:	fa e7 00 00 	st.d	sp[0],r6
80007c4e:	51 09       	stdsp	sp[0x40],r9
80007c50:	14 97       	mov	r7,r10
80007c52:	30 18       	mov	r8,1
80007c54:	e0 8f 01 d0 	bral	80007ff4 <_vfprintf_r+0x1538>
80007c58:	ed b5 00 04 	bld	r5,0x4
80007c5c:	c1 61       	brne	80007c88 <_vfprintf_r+0x11cc>
80007c5e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007c62:	40 3e       	lddsp	lr,sp[0xc]
80007c64:	58 0e       	cp.w	lr,0
80007c66:	c0 80       	breq	80007c76 <_vfprintf_r+0x11ba>
80007c68:	10 36       	cp.w	r6,r8
80007c6a:	c6 74       	brge	80007d38 <_vfprintf_r+0x127c>
80007c6c:	fa cc f9 44 	sub	r12,sp,-1724
80007c70:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007c74:	c8 08       	rjmp	80007d74 <_vfprintf_r+0x12b8>
80007c76:	ee ca ff ff 	sub	r10,r7,-1
80007c7a:	10 37       	cp.w	r7,r8
80007c7c:	c7 f4       	brge	80007d7a <_vfprintf_r+0x12be>
80007c7e:	fa cb f9 44 	sub	r11,sp,-1724
80007c82:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007c86:	c7 68       	rjmp	80007d72 <_vfprintf_r+0x12b6>
80007c88:	ed b5 00 06 	bld	r5,0x6
80007c8c:	c4 a1       	brne	80007d20 <_vfprintf_r+0x1264>
80007c8e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007c92:	40 3c       	lddsp	r12,sp[0xc]
80007c94:	58 0c       	cp.w	r12,0
80007c96:	c1 d0       	breq	80007cd0 <_vfprintf_r+0x1214>
80007c98:	10 36       	cp.w	r6,r8
80007c9a:	c0 64       	brge	80007ca6 <_vfprintf_r+0x11ea>
80007c9c:	fa cb f9 44 	sub	r11,sp,-1724
80007ca0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007ca4:	c1 f8       	rjmp	80007ce2 <_vfprintf_r+0x1226>
80007ca6:	fa c8 f9 50 	sub	r8,sp,-1712
80007caa:	1a d8       	st.w	--sp,r8
80007cac:	fa c8 fa b8 	sub	r8,sp,-1352
80007cb0:	1a d8       	st.w	--sp,r8
80007cb2:	fa c8 fb b4 	sub	r8,sp,-1100
80007cb6:	1a d8       	st.w	--sp,r8
80007cb8:	fa c8 f9 40 	sub	r8,sp,-1728
80007cbc:	fa c9 ff b4 	sub	r9,sp,-76
80007cc0:	04 9a       	mov	r10,r2
80007cc2:	0c 9b       	mov	r11,r6
80007cc4:	08 9c       	mov	r12,r4
80007cc6:	fe b0 f5 63 	rcall	8000678c <get_arg>
80007cca:	2f dd       	sub	sp,-12
80007ccc:	98 18       	ld.sh	r8,r12[0x2]
80007cce:	c2 68       	rjmp	80007d1a <_vfprintf_r+0x125e>
80007cd0:	ee ca ff ff 	sub	r10,r7,-1
80007cd4:	10 37       	cp.w	r7,r8
80007cd6:	c0 94       	brge	80007ce8 <_vfprintf_r+0x122c>
80007cd8:	fa c9 f9 44 	sub	r9,sp,-1724
80007cdc:	14 97       	mov	r7,r10
80007cde:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007ce2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007ce6:	c1 a8       	rjmp	80007d1a <_vfprintf_r+0x125e>
80007ce8:	41 09       	lddsp	r9,sp[0x40]
80007cea:	59 f8       	cp.w	r8,31
80007cec:	e0 89 00 13 	brgt	80007d12 <_vfprintf_r+0x1256>
80007cf0:	f2 cb ff fc 	sub	r11,r9,-4
80007cf4:	51 0b       	stdsp	sp[0x40],r11
80007cf6:	72 09       	ld.w	r9,r9[0x0]
80007cf8:	fa c6 f9 44 	sub	r6,sp,-1724
80007cfc:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007d00:	2f f8       	sub	r8,-1
80007d02:	f7 49 fd 88 	st.w	r11[-632],r9
80007d06:	fb 48 06 b4 	st.w	sp[1716],r8
80007d0a:	14 97       	mov	r7,r10
80007d0c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007d10:	c0 58       	rjmp	80007d1a <_vfprintf_r+0x125e>
80007d12:	92 18       	ld.sh	r8,r9[0x2]
80007d14:	14 97       	mov	r7,r10
80007d16:	2f c9       	sub	r9,-4
80007d18:	51 09       	stdsp	sp[0x40],r9
80007d1a:	5c 78       	castu.h	r8
80007d1c:	50 18       	stdsp	sp[0x4],r8
80007d1e:	c4 68       	rjmp	80007daa <_vfprintf_r+0x12ee>
80007d20:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007d24:	40 3c       	lddsp	r12,sp[0xc]
80007d26:	58 0c       	cp.w	r12,0
80007d28:	c1 d0       	breq	80007d62 <_vfprintf_r+0x12a6>
80007d2a:	10 36       	cp.w	r6,r8
80007d2c:	c0 64       	brge	80007d38 <_vfprintf_r+0x127c>
80007d2e:	fa cb f9 44 	sub	r11,sp,-1724
80007d32:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007d36:	c1 f8       	rjmp	80007d74 <_vfprintf_r+0x12b8>
80007d38:	fa c8 f9 50 	sub	r8,sp,-1712
80007d3c:	1a d8       	st.w	--sp,r8
80007d3e:	fa c8 fa b8 	sub	r8,sp,-1352
80007d42:	0c 9b       	mov	r11,r6
80007d44:	1a d8       	st.w	--sp,r8
80007d46:	fa c8 fb b4 	sub	r8,sp,-1100
80007d4a:	04 9a       	mov	r10,r2
80007d4c:	1a d8       	st.w	--sp,r8
80007d4e:	08 9c       	mov	r12,r4
80007d50:	fa c8 f9 40 	sub	r8,sp,-1728
80007d54:	fa c9 ff b4 	sub	r9,sp,-76
80007d58:	fe b0 f5 1a 	rcall	8000678c <get_arg>
80007d5c:	2f dd       	sub	sp,-12
80007d5e:	78 0b       	ld.w	r11,r12[0x0]
80007d60:	c2 48       	rjmp	80007da8 <_vfprintf_r+0x12ec>
80007d62:	ee ca ff ff 	sub	r10,r7,-1
80007d66:	10 37       	cp.w	r7,r8
80007d68:	c0 94       	brge	80007d7a <_vfprintf_r+0x12be>
80007d6a:	fa c9 f9 44 	sub	r9,sp,-1724
80007d6e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007d72:	14 97       	mov	r7,r10
80007d74:	ec fb fd 88 	ld.w	r11,r6[-632]
80007d78:	c1 88       	rjmp	80007da8 <_vfprintf_r+0x12ec>
80007d7a:	41 09       	lddsp	r9,sp[0x40]
80007d7c:	59 f8       	cp.w	r8,31
80007d7e:	e0 89 00 11 	brgt	80007da0 <_vfprintf_r+0x12e4>
80007d82:	f2 cb ff fc 	sub	r11,r9,-4
80007d86:	51 0b       	stdsp	sp[0x40],r11
80007d88:	fa c6 f9 44 	sub	r6,sp,-1724
80007d8c:	72 0b       	ld.w	r11,r9[0x0]
80007d8e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007d92:	f3 4b fd 88 	st.w	r9[-632],r11
80007d96:	2f f8       	sub	r8,-1
80007d98:	14 97       	mov	r7,r10
80007d9a:	fb 48 06 b4 	st.w	sp[1716],r8
80007d9e:	c0 58       	rjmp	80007da8 <_vfprintf_r+0x12ec>
80007da0:	72 0b       	ld.w	r11,r9[0x0]
80007da2:	14 97       	mov	r7,r10
80007da4:	2f c9       	sub	r9,-4
80007da6:	51 09       	stdsp	sp[0x40],r9
80007da8:	50 1b       	stdsp	sp[0x4],r11
80007daa:	30 0e       	mov	lr,0
80007dac:	30 18       	mov	r8,1
80007dae:	50 0e       	stdsp	sp[0x0],lr
80007db0:	c2 29       	rjmp	80007ff4 <_vfprintf_r+0x1538>
80007db2:	50 a7       	stdsp	sp[0x28],r7
80007db4:	50 80       	stdsp	sp[0x20],r0
80007db6:	0c 97       	mov	r7,r6
80007db8:	04 94       	mov	r4,r2
80007dba:	06 96       	mov	r6,r3
80007dbc:	02 92       	mov	r2,r1
80007dbe:	fe cc b4 86 	sub	r12,pc,-19322
80007dc2:	40 93       	lddsp	r3,sp[0x24]
80007dc4:	10 90       	mov	r0,r8
80007dc6:	40 41       	lddsp	r1,sp[0x10]
80007dc8:	50 dc       	stdsp	sp[0x34],r12
80007dca:	ed b5 00 05 	bld	r5,0x5
80007dce:	c5 51       	brne	80007e78 <_vfprintf_r+0x13bc>
80007dd0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007dd4:	40 3b       	lddsp	r11,sp[0xc]
80007dd6:	58 0b       	cp.w	r11,0
80007dd8:	c2 20       	breq	80007e1c <_vfprintf_r+0x1360>
80007dda:	10 36       	cp.w	r6,r8
80007ddc:	c0 a4       	brge	80007df0 <_vfprintf_r+0x1334>
80007dde:	fa ca f9 44 	sub	r10,sp,-1724
80007de2:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007de6:	ec e8 fd 88 	ld.d	r8,r6[-632]
80007dea:	fa e9 00 00 	st.d	sp[0],r8
80007dee:	cf 28       	rjmp	80007fd2 <_vfprintf_r+0x1516>
80007df0:	fa c8 f9 50 	sub	r8,sp,-1712
80007df4:	1a d8       	st.w	--sp,r8
80007df6:	fa c8 fa b8 	sub	r8,sp,-1352
80007dfa:	04 9a       	mov	r10,r2
80007dfc:	1a d8       	st.w	--sp,r8
80007dfe:	0c 9b       	mov	r11,r6
80007e00:	fa c8 fb b4 	sub	r8,sp,-1100
80007e04:	08 9c       	mov	r12,r4
80007e06:	1a d8       	st.w	--sp,r8
80007e08:	fa c8 f9 40 	sub	r8,sp,-1728
80007e0c:	fa c9 ff b4 	sub	r9,sp,-76
80007e10:	fe b0 f4 be 	rcall	8000678c <get_arg>
80007e14:	2f dd       	sub	sp,-12
80007e16:	f8 ea 00 00 	ld.d	r10,r12[0]
80007e1a:	c0 c8       	rjmp	80007e32 <_vfprintf_r+0x1376>
80007e1c:	ee ca ff ff 	sub	r10,r7,-1
80007e20:	10 37       	cp.w	r7,r8
80007e22:	c0 b4       	brge	80007e38 <_vfprintf_r+0x137c>
80007e24:	fa c9 f9 44 	sub	r9,sp,-1724
80007e28:	14 97       	mov	r7,r10
80007e2a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007e2e:	ec ea fd 88 	ld.d	r10,r6[-632]
80007e32:	fa eb 00 00 	st.d	sp[0],r10
80007e36:	cc e8       	rjmp	80007fd2 <_vfprintf_r+0x1516>
80007e38:	41 09       	lddsp	r9,sp[0x40]
80007e3a:	59 f8       	cp.w	r8,31
80007e3c:	e0 89 00 16 	brgt	80007e68 <_vfprintf_r+0x13ac>
80007e40:	f2 e6 00 00 	ld.d	r6,r9[0]
80007e44:	f2 cb ff f8 	sub	r11,r9,-8
80007e48:	fa e7 00 00 	st.d	sp[0],r6
80007e4c:	51 0b       	stdsp	sp[0x40],r11
80007e4e:	fa c6 f9 44 	sub	r6,sp,-1724
80007e52:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007e56:	fa e6 00 00 	ld.d	r6,sp[0]
80007e5a:	f2 e7 fd 88 	st.d	r9[-632],r6
80007e5e:	2f f8       	sub	r8,-1
80007e60:	14 97       	mov	r7,r10
80007e62:	fb 48 06 b4 	st.w	sp[1716],r8
80007e66:	cb 68       	rjmp	80007fd2 <_vfprintf_r+0x1516>
80007e68:	f2 e6 00 00 	ld.d	r6,r9[0]
80007e6c:	2f 89       	sub	r9,-8
80007e6e:	fa e7 00 00 	st.d	sp[0],r6
80007e72:	51 09       	stdsp	sp[0x40],r9
80007e74:	14 97       	mov	r7,r10
80007e76:	ca e8       	rjmp	80007fd2 <_vfprintf_r+0x1516>
80007e78:	ed b5 00 04 	bld	r5,0x4
80007e7c:	c1 71       	brne	80007eaa <_vfprintf_r+0x13ee>
80007e7e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007e82:	40 3e       	lddsp	lr,sp[0xc]
80007e84:	58 0e       	cp.w	lr,0
80007e86:	c0 80       	breq	80007e96 <_vfprintf_r+0x13da>
80007e88:	10 36       	cp.w	r6,r8
80007e8a:	c6 94       	brge	80007f5c <_vfprintf_r+0x14a0>
80007e8c:	fa cc f9 44 	sub	r12,sp,-1724
80007e90:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007e94:	c8 28       	rjmp	80007f98 <_vfprintf_r+0x14dc>
80007e96:	ee ca ff ff 	sub	r10,r7,-1
80007e9a:	10 37       	cp.w	r7,r8
80007e9c:	e0 84 00 81 	brge	80007f9e <_vfprintf_r+0x14e2>
80007ea0:	fa cb f9 44 	sub	r11,sp,-1724
80007ea4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007ea8:	c7 78       	rjmp	80007f96 <_vfprintf_r+0x14da>
80007eaa:	ed b5 00 06 	bld	r5,0x6
80007eae:	c4 b1       	brne	80007f44 <_vfprintf_r+0x1488>
80007eb0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007eb4:	40 3c       	lddsp	r12,sp[0xc]
80007eb6:	58 0c       	cp.w	r12,0
80007eb8:	c1 d0       	breq	80007ef2 <_vfprintf_r+0x1436>
80007eba:	10 36       	cp.w	r6,r8
80007ebc:	c0 64       	brge	80007ec8 <_vfprintf_r+0x140c>
80007ebe:	fa cb f9 44 	sub	r11,sp,-1724
80007ec2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007ec6:	c1 f8       	rjmp	80007f04 <_vfprintf_r+0x1448>
80007ec8:	fa c8 f9 50 	sub	r8,sp,-1712
80007ecc:	1a d8       	st.w	--sp,r8
80007ece:	fa c8 fa b8 	sub	r8,sp,-1352
80007ed2:	1a d8       	st.w	--sp,r8
80007ed4:	fa c8 fb b4 	sub	r8,sp,-1100
80007ed8:	1a d8       	st.w	--sp,r8
80007eda:	fa c8 f9 40 	sub	r8,sp,-1728
80007ede:	fa c9 ff b4 	sub	r9,sp,-76
80007ee2:	04 9a       	mov	r10,r2
80007ee4:	0c 9b       	mov	r11,r6
80007ee6:	08 9c       	mov	r12,r4
80007ee8:	fe b0 f4 52 	rcall	8000678c <get_arg>
80007eec:	2f dd       	sub	sp,-12
80007eee:	98 18       	ld.sh	r8,r12[0x2]
80007ef0:	c2 78       	rjmp	80007f3e <_vfprintf_r+0x1482>
80007ef2:	ee ca ff ff 	sub	r10,r7,-1
80007ef6:	10 37       	cp.w	r7,r8
80007ef8:	c0 a4       	brge	80007f0c <_vfprintf_r+0x1450>
80007efa:	fa c9 f9 44 	sub	r9,sp,-1724
80007efe:	14 97       	mov	r7,r10
80007f00:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007f04:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007f08:	c1 b8       	rjmp	80007f3e <_vfprintf_r+0x1482>
80007f0a:	d7 03       	nop
80007f0c:	41 09       	lddsp	r9,sp[0x40]
80007f0e:	59 f8       	cp.w	r8,31
80007f10:	e0 89 00 13 	brgt	80007f36 <_vfprintf_r+0x147a>
80007f14:	f2 cb ff fc 	sub	r11,r9,-4
80007f18:	51 0b       	stdsp	sp[0x40],r11
80007f1a:	72 09       	ld.w	r9,r9[0x0]
80007f1c:	fa c6 f9 44 	sub	r6,sp,-1724
80007f20:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007f24:	2f f8       	sub	r8,-1
80007f26:	f7 49 fd 88 	st.w	r11[-632],r9
80007f2a:	fb 48 06 b4 	st.w	sp[1716],r8
80007f2e:	14 97       	mov	r7,r10
80007f30:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007f34:	c0 58       	rjmp	80007f3e <_vfprintf_r+0x1482>
80007f36:	92 18       	ld.sh	r8,r9[0x2]
80007f38:	14 97       	mov	r7,r10
80007f3a:	2f c9       	sub	r9,-4
80007f3c:	51 09       	stdsp	sp[0x40],r9
80007f3e:	5c 78       	castu.h	r8
80007f40:	50 18       	stdsp	sp[0x4],r8
80007f42:	c4 68       	rjmp	80007fce <_vfprintf_r+0x1512>
80007f44:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007f48:	40 3c       	lddsp	r12,sp[0xc]
80007f4a:	58 0c       	cp.w	r12,0
80007f4c:	c1 d0       	breq	80007f86 <_vfprintf_r+0x14ca>
80007f4e:	10 36       	cp.w	r6,r8
80007f50:	c0 64       	brge	80007f5c <_vfprintf_r+0x14a0>
80007f52:	fa cb f9 44 	sub	r11,sp,-1724
80007f56:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007f5a:	c1 f8       	rjmp	80007f98 <_vfprintf_r+0x14dc>
80007f5c:	fa c8 f9 50 	sub	r8,sp,-1712
80007f60:	1a d8       	st.w	--sp,r8
80007f62:	fa c8 fa b8 	sub	r8,sp,-1352
80007f66:	0c 9b       	mov	r11,r6
80007f68:	1a d8       	st.w	--sp,r8
80007f6a:	fa c8 fb b4 	sub	r8,sp,-1100
80007f6e:	04 9a       	mov	r10,r2
80007f70:	1a d8       	st.w	--sp,r8
80007f72:	08 9c       	mov	r12,r4
80007f74:	fa c8 f9 40 	sub	r8,sp,-1728
80007f78:	fa c9 ff b4 	sub	r9,sp,-76
80007f7c:	fe b0 f4 08 	rcall	8000678c <get_arg>
80007f80:	2f dd       	sub	sp,-12
80007f82:	78 0b       	ld.w	r11,r12[0x0]
80007f84:	c2 48       	rjmp	80007fcc <_vfprintf_r+0x1510>
80007f86:	ee ca ff ff 	sub	r10,r7,-1
80007f8a:	10 37       	cp.w	r7,r8
80007f8c:	c0 94       	brge	80007f9e <_vfprintf_r+0x14e2>
80007f8e:	fa c9 f9 44 	sub	r9,sp,-1724
80007f92:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007f96:	14 97       	mov	r7,r10
80007f98:	ec fb fd 88 	ld.w	r11,r6[-632]
80007f9c:	c1 88       	rjmp	80007fcc <_vfprintf_r+0x1510>
80007f9e:	41 09       	lddsp	r9,sp[0x40]
80007fa0:	59 f8       	cp.w	r8,31
80007fa2:	e0 89 00 11 	brgt	80007fc4 <_vfprintf_r+0x1508>
80007fa6:	f2 cb ff fc 	sub	r11,r9,-4
80007faa:	51 0b       	stdsp	sp[0x40],r11
80007fac:	fa c6 f9 44 	sub	r6,sp,-1724
80007fb0:	72 0b       	ld.w	r11,r9[0x0]
80007fb2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007fb6:	f3 4b fd 88 	st.w	r9[-632],r11
80007fba:	2f f8       	sub	r8,-1
80007fbc:	14 97       	mov	r7,r10
80007fbe:	fb 48 06 b4 	st.w	sp[1716],r8
80007fc2:	c0 58       	rjmp	80007fcc <_vfprintf_r+0x1510>
80007fc4:	72 0b       	ld.w	r11,r9[0x0]
80007fc6:	14 97       	mov	r7,r10
80007fc8:	2f c9       	sub	r9,-4
80007fca:	51 09       	stdsp	sp[0x40],r9
80007fcc:	50 1b       	stdsp	sp[0x4],r11
80007fce:	30 0e       	mov	lr,0
80007fd0:	50 0e       	stdsp	sp[0x0],lr
80007fd2:	40 08       	lddsp	r8,sp[0x0]
80007fd4:	40 1c       	lddsp	r12,sp[0x4]
80007fd6:	18 48       	or	r8,r12
80007fd8:	5f 19       	srne	r9
80007fda:	0a 98       	mov	r8,r5
80007fdc:	eb e9 00 09 	and	r9,r5,r9
80007fe0:	a1 b8       	sbr	r8,0x1
80007fe2:	58 09       	cp.w	r9,0
80007fe4:	c0 70       	breq	80007ff2 <_vfprintf_r+0x1536>
80007fe6:	10 95       	mov	r5,r8
80007fe8:	fb 60 06 b9 	st.b	sp[1721],r0
80007fec:	33 08       	mov	r8,48
80007fee:	fb 68 06 b8 	st.b	sp[1720],r8
80007ff2:	30 28       	mov	r8,2
80007ff4:	30 09       	mov	r9,0
80007ff6:	fb 69 06 bb 	st.b	sp[1723],r9
80007ffa:	0a 99       	mov	r9,r5
80007ffc:	a7 d9       	cbr	r9,0x7
80007ffe:	40 2b       	lddsp	r11,sp[0x8]
80008000:	40 16       	lddsp	r6,sp[0x4]
80008002:	58 0b       	cp.w	r11,0
80008004:	5f 1a       	srne	r10
80008006:	f2 05 17 40 	movge	r5,r9
8000800a:	fa c2 f9 78 	sub	r2,sp,-1672
8000800e:	40 09       	lddsp	r9,sp[0x0]
80008010:	0c 49       	or	r9,r6
80008012:	5f 19       	srne	r9
80008014:	f5 e9 10 09 	or	r9,r10,r9
80008018:	c5 c0       	breq	800080d0 <_vfprintf_r+0x1614>
8000801a:	30 19       	mov	r9,1
8000801c:	f2 08 18 00 	cp.b	r8,r9
80008020:	c0 60       	breq	8000802c <_vfprintf_r+0x1570>
80008022:	30 29       	mov	r9,2
80008024:	f2 08 18 00 	cp.b	r8,r9
80008028:	c0 41       	brne	80008030 <_vfprintf_r+0x1574>
8000802a:	c3 c8       	rjmp	800080a2 <_vfprintf_r+0x15e6>
8000802c:	04 96       	mov	r6,r2
8000802e:	c3 08       	rjmp	8000808e <_vfprintf_r+0x15d2>
80008030:	04 96       	mov	r6,r2
80008032:	fa e8 00 00 	ld.d	r8,sp[0]
80008036:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000803a:	2d 0a       	sub	r10,-48
8000803c:	0c fa       	st.b	--r6,r10
8000803e:	f0 0b 16 03 	lsr	r11,r8,0x3
80008042:	f2 0c 16 03 	lsr	r12,r9,0x3
80008046:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000804a:	18 99       	mov	r9,r12
8000804c:	16 98       	mov	r8,r11
8000804e:	58 08       	cp.w	r8,0
80008050:	5c 29       	cpc	r9
80008052:	cf 21       	brne	80008036 <_vfprintf_r+0x157a>
80008054:	fa e9 00 00 	st.d	sp[0],r8
80008058:	ed b5 00 00 	bld	r5,0x0
8000805c:	c4 51       	brne	800080e6 <_vfprintf_r+0x162a>
8000805e:	33 09       	mov	r9,48
80008060:	f2 0a 18 00 	cp.b	r10,r9
80008064:	c4 10       	breq	800080e6 <_vfprintf_r+0x162a>
80008066:	0c f9       	st.b	--r6,r9
80008068:	c3 f8       	rjmp	800080e6 <_vfprintf_r+0x162a>
8000806a:	fa ea 00 00 	ld.d	r10,sp[0]
8000806e:	30 a8       	mov	r8,10
80008070:	30 09       	mov	r9,0
80008072:	e0 a0 1a 19 	rcall	8000b4a4 <__avr32_umod64>
80008076:	30 a8       	mov	r8,10
80008078:	2d 0a       	sub	r10,-48
8000807a:	30 09       	mov	r9,0
8000807c:	ac 8a       	st.b	r6[0x0],r10
8000807e:	fa ea 00 00 	ld.d	r10,sp[0]
80008082:	e0 a0 18 df 	rcall	8000b240 <__avr32_udiv64>
80008086:	16 99       	mov	r9,r11
80008088:	14 98       	mov	r8,r10
8000808a:	fa e9 00 00 	st.d	sp[0],r8
8000808e:	20 16       	sub	r6,1
80008090:	fa ea 00 00 	ld.d	r10,sp[0]
80008094:	58 9a       	cp.w	r10,9
80008096:	5c 2b       	cpc	r11
80008098:	fe 9b ff e9 	brhi	8000806a <_vfprintf_r+0x15ae>
8000809c:	1b f8       	ld.ub	r8,sp[0x7]
8000809e:	2d 08       	sub	r8,-48
800080a0:	c2 08       	rjmp	800080e0 <_vfprintf_r+0x1624>
800080a2:	04 96       	mov	r6,r2
800080a4:	fa e8 00 00 	ld.d	r8,sp[0]
800080a8:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
800080ac:	40 de       	lddsp	lr,sp[0x34]
800080ae:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
800080b2:	0c fa       	st.b	--r6,r10
800080b4:	f2 0b 16 04 	lsr	r11,r9,0x4
800080b8:	f0 0a 16 04 	lsr	r10,r8,0x4
800080bc:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
800080c0:	16 99       	mov	r9,r11
800080c2:	14 98       	mov	r8,r10
800080c4:	58 08       	cp.w	r8,0
800080c6:	5c 29       	cpc	r9
800080c8:	cf 01       	brne	800080a8 <_vfprintf_r+0x15ec>
800080ca:	fa e9 00 00 	st.d	sp[0],r8
800080ce:	c0 c8       	rjmp	800080e6 <_vfprintf_r+0x162a>
800080d0:	58 08       	cp.w	r8,0
800080d2:	c0 91       	brne	800080e4 <_vfprintf_r+0x1628>
800080d4:	ed b5 00 00 	bld	r5,0x0
800080d8:	c0 61       	brne	800080e4 <_vfprintf_r+0x1628>
800080da:	fa c6 f9 79 	sub	r6,sp,-1671
800080de:	33 08       	mov	r8,48
800080e0:	ac 88       	st.b	r6[0x0],r8
800080e2:	c0 28       	rjmp	800080e6 <_vfprintf_r+0x162a>
800080e4:	04 96       	mov	r6,r2
800080e6:	0c 12       	sub	r2,r6
800080e8:	c1 c8       	rjmp	80008120 <_vfprintf_r+0x1664>
800080ea:	50 a7       	stdsp	sp[0x28],r7
800080ec:	50 80       	stdsp	sp[0x20],r0
800080ee:	40 93       	lddsp	r3,sp[0x24]
800080f0:	0c 97       	mov	r7,r6
800080f2:	10 90       	mov	r0,r8
800080f4:	04 94       	mov	r4,r2
800080f6:	40 41       	lddsp	r1,sp[0x10]
800080f8:	58 08       	cp.w	r8,0
800080fa:	e0 80 04 4f 	breq	80008998 <_vfprintf_r+0x1edc>
800080fe:	fb 68 06 60 	st.b	sp[1632],r8
80008102:	30 0c       	mov	r12,0
80008104:	30 08       	mov	r8,0
80008106:	30 12       	mov	r2,1
80008108:	fb 68 06 bb 	st.b	sp[1723],r8
8000810c:	50 2c       	stdsp	sp[0x8],r12
8000810e:	fa c6 f9 a0 	sub	r6,sp,-1632
80008112:	c0 78       	rjmp	80008120 <_vfprintf_r+0x1664>
80008114:	30 0b       	mov	r11,0
80008116:	50 2b       	stdsp	sp[0x8],r11
80008118:	c0 48       	rjmp	80008120 <_vfprintf_r+0x1664>
8000811a:	40 22       	lddsp	r2,sp[0x8]
8000811c:	30 0a       	mov	r10,0
8000811e:	50 2a       	stdsp	sp[0x8],r10
80008120:	40 29       	lddsp	r9,sp[0x8]
80008122:	e4 09 0c 49 	max	r9,r2,r9
80008126:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000812a:	50 39       	stdsp	sp[0xc],r9
8000812c:	0a 9e       	mov	lr,r5
8000812e:	30 09       	mov	r9,0
80008130:	e2 1e 00 02 	andl	lr,0x2,COH
80008134:	f2 08 18 00 	cp.b	r8,r9
80008138:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000813c:	f7 b8 01 ff 	subne	r8,-1
80008140:	fb f8 1a 03 	st.wne	sp[0xc],r8
80008144:	0a 9b       	mov	r11,r5
80008146:	58 0e       	cp.w	lr,0
80008148:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000814c:	f7 bc 01 fe 	subne	r12,-2
80008150:	fb fc 1a 03 	st.wne	sp[0xc],r12
80008154:	e2 1b 00 84 	andl	r11,0x84,COH
80008158:	50 fe       	stdsp	sp[0x3c],lr
8000815a:	50 9b       	stdsp	sp[0x24],r11
8000815c:	c4 71       	brne	800081ea <_vfprintf_r+0x172e>
8000815e:	40 8a       	lddsp	r10,sp[0x20]
80008160:	40 39       	lddsp	r9,sp[0xc]
80008162:	12 1a       	sub	r10,r9
80008164:	50 4a       	stdsp	sp[0x10],r10
80008166:	58 0a       	cp.w	r10,0
80008168:	e0 89 00 20 	brgt	800081a8 <_vfprintf_r+0x16ec>
8000816c:	c3 f8       	rjmp	800081ea <_vfprintf_r+0x172e>
8000816e:	2f 09       	sub	r9,-16
80008170:	2f f8       	sub	r8,-1
80008172:	fe ce b8 22 	sub	lr,pc,-18398
80008176:	31 0c       	mov	r12,16
80008178:	fb 49 06 90 	st.w	sp[1680],r9
8000817c:	87 0e       	st.w	r3[0x0],lr
8000817e:	87 1c       	st.w	r3[0x4],r12
80008180:	fb 48 06 8c 	st.w	sp[1676],r8
80008184:	58 78       	cp.w	r8,7
80008186:	e0 89 00 04 	brgt	8000818e <_vfprintf_r+0x16d2>
8000818a:	2f 83       	sub	r3,-8
8000818c:	c0 b8       	rjmp	800081a2 <_vfprintf_r+0x16e6>
8000818e:	fa ca f9 78 	sub	r10,sp,-1672
80008192:	02 9b       	mov	r11,r1
80008194:	08 9c       	mov	r12,r4
80008196:	fe b0 f4 85 	rcall	80006aa0 <__sprint_r>
8000819a:	e0 81 04 10 	brne	800089ba <_vfprintf_r+0x1efe>
8000819e:	fa c3 f9 e0 	sub	r3,sp,-1568
800081a2:	40 4b       	lddsp	r11,sp[0x10]
800081a4:	21 0b       	sub	r11,16
800081a6:	50 4b       	stdsp	sp[0x10],r11
800081a8:	fa f9 06 90 	ld.w	r9,sp[1680]
800081ac:	fa f8 06 8c 	ld.w	r8,sp[1676]
800081b0:	fe ca b8 60 	sub	r10,pc,-18336
800081b4:	40 4e       	lddsp	lr,sp[0x10]
800081b6:	59 0e       	cp.w	lr,16
800081b8:	fe 99 ff db 	brgt	8000816e <_vfprintf_r+0x16b2>
800081bc:	1c 09       	add	r9,lr
800081be:	2f f8       	sub	r8,-1
800081c0:	87 0a       	st.w	r3[0x0],r10
800081c2:	fb 49 06 90 	st.w	sp[1680],r9
800081c6:	87 1e       	st.w	r3[0x4],lr
800081c8:	fb 48 06 8c 	st.w	sp[1676],r8
800081cc:	58 78       	cp.w	r8,7
800081ce:	e0 89 00 04 	brgt	800081d6 <_vfprintf_r+0x171a>
800081d2:	2f 83       	sub	r3,-8
800081d4:	c0 b8       	rjmp	800081ea <_vfprintf_r+0x172e>
800081d6:	fa ca f9 78 	sub	r10,sp,-1672
800081da:	02 9b       	mov	r11,r1
800081dc:	08 9c       	mov	r12,r4
800081de:	fe b0 f4 61 	rcall	80006aa0 <__sprint_r>
800081e2:	e0 81 03 ec 	brne	800089ba <_vfprintf_r+0x1efe>
800081e6:	fa c3 f9 e0 	sub	r3,sp,-1568
800081ea:	30 09       	mov	r9,0
800081ec:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800081f0:	f2 08 18 00 	cp.b	r8,r9
800081f4:	c1 f0       	breq	80008232 <_vfprintf_r+0x1776>
800081f6:	fa f8 06 90 	ld.w	r8,sp[1680]
800081fa:	fa c9 f9 45 	sub	r9,sp,-1723
800081fe:	2f f8       	sub	r8,-1
80008200:	87 09       	st.w	r3[0x0],r9
80008202:	fb 48 06 90 	st.w	sp[1680],r8
80008206:	30 19       	mov	r9,1
80008208:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000820c:	87 19       	st.w	r3[0x4],r9
8000820e:	2f f8       	sub	r8,-1
80008210:	fb 48 06 8c 	st.w	sp[1676],r8
80008214:	58 78       	cp.w	r8,7
80008216:	e0 89 00 04 	brgt	8000821e <_vfprintf_r+0x1762>
8000821a:	2f 83       	sub	r3,-8
8000821c:	c0 b8       	rjmp	80008232 <_vfprintf_r+0x1776>
8000821e:	fa ca f9 78 	sub	r10,sp,-1672
80008222:	02 9b       	mov	r11,r1
80008224:	08 9c       	mov	r12,r4
80008226:	fe b0 f4 3d 	rcall	80006aa0 <__sprint_r>
8000822a:	e0 81 03 c8 	brne	800089ba <_vfprintf_r+0x1efe>
8000822e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008232:	40 fc       	lddsp	r12,sp[0x3c]
80008234:	58 0c       	cp.w	r12,0
80008236:	c1 f0       	breq	80008274 <_vfprintf_r+0x17b8>
80008238:	fa f8 06 90 	ld.w	r8,sp[1680]
8000823c:	fa c9 f9 48 	sub	r9,sp,-1720
80008240:	2f e8       	sub	r8,-2
80008242:	87 09       	st.w	r3[0x0],r9
80008244:	fb 48 06 90 	st.w	sp[1680],r8
80008248:	30 29       	mov	r9,2
8000824a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000824e:	87 19       	st.w	r3[0x4],r9
80008250:	2f f8       	sub	r8,-1
80008252:	fb 48 06 8c 	st.w	sp[1676],r8
80008256:	58 78       	cp.w	r8,7
80008258:	e0 89 00 04 	brgt	80008260 <_vfprintf_r+0x17a4>
8000825c:	2f 83       	sub	r3,-8
8000825e:	c0 b8       	rjmp	80008274 <_vfprintf_r+0x17b8>
80008260:	fa ca f9 78 	sub	r10,sp,-1672
80008264:	02 9b       	mov	r11,r1
80008266:	08 9c       	mov	r12,r4
80008268:	fe b0 f4 1c 	rcall	80006aa0 <__sprint_r>
8000826c:	e0 81 03 a7 	brne	800089ba <_vfprintf_r+0x1efe>
80008270:	fa c3 f9 e0 	sub	r3,sp,-1568
80008274:	40 9b       	lddsp	r11,sp[0x24]
80008276:	e0 4b 00 80 	cp.w	r11,128
8000827a:	c4 71       	brne	80008308 <_vfprintf_r+0x184c>
8000827c:	40 8a       	lddsp	r10,sp[0x20]
8000827e:	40 39       	lddsp	r9,sp[0xc]
80008280:	12 1a       	sub	r10,r9
80008282:	50 4a       	stdsp	sp[0x10],r10
80008284:	58 0a       	cp.w	r10,0
80008286:	e0 89 00 20 	brgt	800082c6 <_vfprintf_r+0x180a>
8000828a:	c3 f8       	rjmp	80008308 <_vfprintf_r+0x184c>
8000828c:	2f 09       	sub	r9,-16
8000828e:	2f f8       	sub	r8,-1
80008290:	fe ce b9 30 	sub	lr,pc,-18128
80008294:	31 0c       	mov	r12,16
80008296:	fb 49 06 90 	st.w	sp[1680],r9
8000829a:	87 0e       	st.w	r3[0x0],lr
8000829c:	87 1c       	st.w	r3[0x4],r12
8000829e:	fb 48 06 8c 	st.w	sp[1676],r8
800082a2:	58 78       	cp.w	r8,7
800082a4:	e0 89 00 04 	brgt	800082ac <_vfprintf_r+0x17f0>
800082a8:	2f 83       	sub	r3,-8
800082aa:	c0 b8       	rjmp	800082c0 <_vfprintf_r+0x1804>
800082ac:	fa ca f9 78 	sub	r10,sp,-1672
800082b0:	02 9b       	mov	r11,r1
800082b2:	08 9c       	mov	r12,r4
800082b4:	fe b0 f3 f6 	rcall	80006aa0 <__sprint_r>
800082b8:	e0 81 03 81 	brne	800089ba <_vfprintf_r+0x1efe>
800082bc:	fa c3 f9 e0 	sub	r3,sp,-1568
800082c0:	40 4b       	lddsp	r11,sp[0x10]
800082c2:	21 0b       	sub	r11,16
800082c4:	50 4b       	stdsp	sp[0x10],r11
800082c6:	fa f9 06 90 	ld.w	r9,sp[1680]
800082ca:	fa f8 06 8c 	ld.w	r8,sp[1676]
800082ce:	fe ca b9 6e 	sub	r10,pc,-18066
800082d2:	40 4e       	lddsp	lr,sp[0x10]
800082d4:	59 0e       	cp.w	lr,16
800082d6:	fe 99 ff db 	brgt	8000828c <_vfprintf_r+0x17d0>
800082da:	1c 09       	add	r9,lr
800082dc:	2f f8       	sub	r8,-1
800082de:	87 0a       	st.w	r3[0x0],r10
800082e0:	fb 49 06 90 	st.w	sp[1680],r9
800082e4:	87 1e       	st.w	r3[0x4],lr
800082e6:	fb 48 06 8c 	st.w	sp[1676],r8
800082ea:	58 78       	cp.w	r8,7
800082ec:	e0 89 00 04 	brgt	800082f4 <_vfprintf_r+0x1838>
800082f0:	2f 83       	sub	r3,-8
800082f2:	c0 b8       	rjmp	80008308 <_vfprintf_r+0x184c>
800082f4:	fa ca f9 78 	sub	r10,sp,-1672
800082f8:	02 9b       	mov	r11,r1
800082fa:	08 9c       	mov	r12,r4
800082fc:	fe b0 f3 d2 	rcall	80006aa0 <__sprint_r>
80008300:	e0 81 03 5d 	brne	800089ba <_vfprintf_r+0x1efe>
80008304:	fa c3 f9 e0 	sub	r3,sp,-1568
80008308:	40 2c       	lddsp	r12,sp[0x8]
8000830a:	04 1c       	sub	r12,r2
8000830c:	50 2c       	stdsp	sp[0x8],r12
8000830e:	58 0c       	cp.w	r12,0
80008310:	e0 89 00 20 	brgt	80008350 <_vfprintf_r+0x1894>
80008314:	c3 f8       	rjmp	80008392 <_vfprintf_r+0x18d6>
80008316:	2f 09       	sub	r9,-16
80008318:	2f f8       	sub	r8,-1
8000831a:	fe cb b9 ba 	sub	r11,pc,-17990
8000831e:	31 0a       	mov	r10,16
80008320:	fb 49 06 90 	st.w	sp[1680],r9
80008324:	87 0b       	st.w	r3[0x0],r11
80008326:	87 1a       	st.w	r3[0x4],r10
80008328:	fb 48 06 8c 	st.w	sp[1676],r8
8000832c:	58 78       	cp.w	r8,7
8000832e:	e0 89 00 04 	brgt	80008336 <_vfprintf_r+0x187a>
80008332:	2f 83       	sub	r3,-8
80008334:	c0 b8       	rjmp	8000834a <_vfprintf_r+0x188e>
80008336:	fa ca f9 78 	sub	r10,sp,-1672
8000833a:	02 9b       	mov	r11,r1
8000833c:	08 9c       	mov	r12,r4
8000833e:	fe b0 f3 b1 	rcall	80006aa0 <__sprint_r>
80008342:	e0 81 03 3c 	brne	800089ba <_vfprintf_r+0x1efe>
80008346:	fa c3 f9 e0 	sub	r3,sp,-1568
8000834a:	40 29       	lddsp	r9,sp[0x8]
8000834c:	21 09       	sub	r9,16
8000834e:	50 29       	stdsp	sp[0x8],r9
80008350:	fa f9 06 90 	ld.w	r9,sp[1680]
80008354:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008358:	fe ca b9 f8 	sub	r10,pc,-17928
8000835c:	40 2e       	lddsp	lr,sp[0x8]
8000835e:	59 0e       	cp.w	lr,16
80008360:	fe 99 ff db 	brgt	80008316 <_vfprintf_r+0x185a>
80008364:	1c 09       	add	r9,lr
80008366:	2f f8       	sub	r8,-1
80008368:	87 0a       	st.w	r3[0x0],r10
8000836a:	fb 49 06 90 	st.w	sp[1680],r9
8000836e:	87 1e       	st.w	r3[0x4],lr
80008370:	fb 48 06 8c 	st.w	sp[1676],r8
80008374:	58 78       	cp.w	r8,7
80008376:	e0 89 00 04 	brgt	8000837e <_vfprintf_r+0x18c2>
8000837a:	2f 83       	sub	r3,-8
8000837c:	c0 b8       	rjmp	80008392 <_vfprintf_r+0x18d6>
8000837e:	fa ca f9 78 	sub	r10,sp,-1672
80008382:	02 9b       	mov	r11,r1
80008384:	08 9c       	mov	r12,r4
80008386:	fe b0 f3 8d 	rcall	80006aa0 <__sprint_r>
8000838a:	e0 81 03 18 	brne	800089ba <_vfprintf_r+0x1efe>
8000838e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008392:	ed b5 00 08 	bld	r5,0x8
80008396:	c0 b0       	breq	800083ac <_vfprintf_r+0x18f0>
80008398:	fa f8 06 90 	ld.w	r8,sp[1680]
8000839c:	87 12       	st.w	r3[0x4],r2
8000839e:	87 06       	st.w	r3[0x0],r6
800083a0:	f0 02 00 02 	add	r2,r8,r2
800083a4:	fb 42 06 90 	st.w	sp[1680],r2
800083a8:	e0 8f 01 d4 	bral	80008750 <_vfprintf_r+0x1c94>
800083ac:	e0 40 00 65 	cp.w	r0,101
800083b0:	e0 8a 01 d6 	brle	8000875c <_vfprintf_r+0x1ca0>
800083b4:	30 08       	mov	r8,0
800083b6:	30 09       	mov	r9,0
800083b8:	40 5b       	lddsp	r11,sp[0x14]
800083ba:	40 7a       	lddsp	r10,sp[0x1c]
800083bc:	e0 a0 15 3b 	rcall	8000ae32 <__avr32_f64_cmp_eq>
800083c0:	c7 90       	breq	800084b2 <_vfprintf_r+0x19f6>
800083c2:	fa f8 06 90 	ld.w	r8,sp[1680]
800083c6:	fe c9 ba 7a 	sub	r9,pc,-17798
800083ca:	2f f8       	sub	r8,-1
800083cc:	87 09       	st.w	r3[0x0],r9
800083ce:	fb 48 06 90 	st.w	sp[1680],r8
800083d2:	30 19       	mov	r9,1
800083d4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800083d8:	87 19       	st.w	r3[0x4],r9
800083da:	2f f8       	sub	r8,-1
800083dc:	fb 48 06 8c 	st.w	sp[1676],r8
800083e0:	58 78       	cp.w	r8,7
800083e2:	e0 89 00 05 	brgt	800083ec <_vfprintf_r+0x1930>
800083e6:	2f 83       	sub	r3,-8
800083e8:	c0 c8       	rjmp	80008400 <_vfprintf_r+0x1944>
800083ea:	d7 03       	nop
800083ec:	fa ca f9 78 	sub	r10,sp,-1672
800083f0:	02 9b       	mov	r11,r1
800083f2:	08 9c       	mov	r12,r4
800083f4:	fe b0 f3 56 	rcall	80006aa0 <__sprint_r>
800083f8:	e0 81 02 e1 	brne	800089ba <_vfprintf_r+0x1efe>
800083fc:	fa c3 f9 e0 	sub	r3,sp,-1568
80008400:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008404:	40 6c       	lddsp	r12,sp[0x18]
80008406:	18 38       	cp.w	r8,r12
80008408:	c0 55       	brlt	80008412 <_vfprintf_r+0x1956>
8000840a:	ed b5 00 00 	bld	r5,0x0
8000840e:	e0 81 02 6b 	brne	800088e4 <_vfprintf_r+0x1e28>
80008412:	fa f8 06 90 	ld.w	r8,sp[1680]
80008416:	2f f8       	sub	r8,-1
80008418:	40 cb       	lddsp	r11,sp[0x30]
8000841a:	fb 48 06 90 	st.w	sp[1680],r8
8000841e:	30 19       	mov	r9,1
80008420:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008424:	87 0b       	st.w	r3[0x0],r11
80008426:	2f f8       	sub	r8,-1
80008428:	87 19       	st.w	r3[0x4],r9
8000842a:	fb 48 06 8c 	st.w	sp[1676],r8
8000842e:	58 78       	cp.w	r8,7
80008430:	e0 89 00 04 	brgt	80008438 <_vfprintf_r+0x197c>
80008434:	2f 83       	sub	r3,-8
80008436:	c0 b8       	rjmp	8000844c <_vfprintf_r+0x1990>
80008438:	fa ca f9 78 	sub	r10,sp,-1672
8000843c:	02 9b       	mov	r11,r1
8000843e:	08 9c       	mov	r12,r4
80008440:	fe b0 f3 30 	rcall	80006aa0 <__sprint_r>
80008444:	e0 81 02 bb 	brne	800089ba <_vfprintf_r+0x1efe>
80008448:	fa c3 f9 e0 	sub	r3,sp,-1568
8000844c:	40 66       	lddsp	r6,sp[0x18]
8000844e:	20 16       	sub	r6,1
80008450:	58 06       	cp.w	r6,0
80008452:	e0 89 00 1d 	brgt	8000848c <_vfprintf_r+0x19d0>
80008456:	e0 8f 02 47 	bral	800088e4 <_vfprintf_r+0x1e28>
8000845a:	2f 09       	sub	r9,-16
8000845c:	2f f8       	sub	r8,-1
8000845e:	fb 49 06 90 	st.w	sp[1680],r9
80008462:	87 02       	st.w	r3[0x0],r2
80008464:	87 10       	st.w	r3[0x4],r0
80008466:	fb 48 06 8c 	st.w	sp[1676],r8
8000846a:	58 78       	cp.w	r8,7
8000846c:	e0 89 00 04 	brgt	80008474 <_vfprintf_r+0x19b8>
80008470:	2f 83       	sub	r3,-8
80008472:	c0 b8       	rjmp	80008488 <_vfprintf_r+0x19cc>
80008474:	fa ca f9 78 	sub	r10,sp,-1672
80008478:	02 9b       	mov	r11,r1
8000847a:	08 9c       	mov	r12,r4
8000847c:	fe b0 f3 12 	rcall	80006aa0 <__sprint_r>
80008480:	e0 81 02 9d 	brne	800089ba <_vfprintf_r+0x1efe>
80008484:	fa c3 f9 e0 	sub	r3,sp,-1568
80008488:	21 06       	sub	r6,16
8000848a:	c0 48       	rjmp	80008492 <_vfprintf_r+0x19d6>
8000848c:	fe c2 bb 2c 	sub	r2,pc,-17620
80008490:	31 00       	mov	r0,16
80008492:	fa f9 06 90 	ld.w	r9,sp[1680]
80008496:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000849a:	fe ca bb 3a 	sub	r10,pc,-17606
8000849e:	59 06       	cp.w	r6,16
800084a0:	fe 99 ff dd 	brgt	8000845a <_vfprintf_r+0x199e>
800084a4:	0c 09       	add	r9,r6
800084a6:	87 0a       	st.w	r3[0x0],r10
800084a8:	fb 49 06 90 	st.w	sp[1680],r9
800084ac:	2f f8       	sub	r8,-1
800084ae:	87 16       	st.w	r3[0x4],r6
800084b0:	c5 39       	rjmp	80008756 <_vfprintf_r+0x1c9a>
800084b2:	fa fa 06 ac 	ld.w	r10,sp[1708]
800084b6:	58 0a       	cp.w	r10,0
800084b8:	e0 89 00 92 	brgt	800085dc <_vfprintf_r+0x1b20>
800084bc:	fa f8 06 90 	ld.w	r8,sp[1680]
800084c0:	fe c9 bb 74 	sub	r9,pc,-17548
800084c4:	2f f8       	sub	r8,-1
800084c6:	87 09       	st.w	r3[0x0],r9
800084c8:	fb 48 06 90 	st.w	sp[1680],r8
800084cc:	30 19       	mov	r9,1
800084ce:	fa f8 06 8c 	ld.w	r8,sp[1676]
800084d2:	87 19       	st.w	r3[0x4],r9
800084d4:	2f f8       	sub	r8,-1
800084d6:	fb 48 06 8c 	st.w	sp[1676],r8
800084da:	58 78       	cp.w	r8,7
800084dc:	e0 89 00 04 	brgt	800084e4 <_vfprintf_r+0x1a28>
800084e0:	2f 83       	sub	r3,-8
800084e2:	c0 b8       	rjmp	800084f8 <_vfprintf_r+0x1a3c>
800084e4:	fa ca f9 78 	sub	r10,sp,-1672
800084e8:	02 9b       	mov	r11,r1
800084ea:	08 9c       	mov	r12,r4
800084ec:	fe b0 f2 da 	rcall	80006aa0 <__sprint_r>
800084f0:	e0 81 02 65 	brne	800089ba <_vfprintf_r+0x1efe>
800084f4:	fa c3 f9 e0 	sub	r3,sp,-1568
800084f8:	fa f8 06 ac 	ld.w	r8,sp[1708]
800084fc:	58 08       	cp.w	r8,0
800084fe:	c0 81       	brne	8000850e <_vfprintf_r+0x1a52>
80008500:	40 6a       	lddsp	r10,sp[0x18]
80008502:	58 0a       	cp.w	r10,0
80008504:	c0 51       	brne	8000850e <_vfprintf_r+0x1a52>
80008506:	ed b5 00 00 	bld	r5,0x0
8000850a:	e0 81 01 ed 	brne	800088e4 <_vfprintf_r+0x1e28>
8000850e:	40 c9       	lddsp	r9,sp[0x30]
80008510:	fa f8 06 90 	ld.w	r8,sp[1680]
80008514:	2f f8       	sub	r8,-1
80008516:	87 09       	st.w	r3[0x0],r9
80008518:	fb 48 06 90 	st.w	sp[1680],r8
8000851c:	30 19       	mov	r9,1
8000851e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008522:	87 19       	st.w	r3[0x4],r9
80008524:	2f f8       	sub	r8,-1
80008526:	fb 48 06 8c 	st.w	sp[1676],r8
8000852a:	58 78       	cp.w	r8,7
8000852c:	e0 89 00 04 	brgt	80008534 <_vfprintf_r+0x1a78>
80008530:	2f 83       	sub	r3,-8
80008532:	c0 b8       	rjmp	80008548 <_vfprintf_r+0x1a8c>
80008534:	fa ca f9 78 	sub	r10,sp,-1672
80008538:	02 9b       	mov	r11,r1
8000853a:	08 9c       	mov	r12,r4
8000853c:	fe b0 f2 b2 	rcall	80006aa0 <__sprint_r>
80008540:	e0 81 02 3d 	brne	800089ba <_vfprintf_r+0x1efe>
80008544:	fa c3 f9 e0 	sub	r3,sp,-1568
80008548:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000854c:	5c 32       	neg	r2
8000854e:	58 02       	cp.w	r2,0
80008550:	e0 89 00 1d 	brgt	8000858a <_vfprintf_r+0x1ace>
80008554:	c3 d8       	rjmp	800085ce <_vfprintf_r+0x1b12>
80008556:	2f 09       	sub	r9,-16
80008558:	2f f8       	sub	r8,-1
8000855a:	31 0e       	mov	lr,16
8000855c:	fb 49 06 90 	st.w	sp[1680],r9
80008560:	87 00       	st.w	r3[0x0],r0
80008562:	87 1e       	st.w	r3[0x4],lr
80008564:	fb 48 06 8c 	st.w	sp[1676],r8
80008568:	58 78       	cp.w	r8,7
8000856a:	e0 89 00 04 	brgt	80008572 <_vfprintf_r+0x1ab6>
8000856e:	2f 83       	sub	r3,-8
80008570:	c0 b8       	rjmp	80008586 <_vfprintf_r+0x1aca>
80008572:	fa ca f9 78 	sub	r10,sp,-1672
80008576:	02 9b       	mov	r11,r1
80008578:	08 9c       	mov	r12,r4
8000857a:	fe b0 f2 93 	rcall	80006aa0 <__sprint_r>
8000857e:	e0 81 02 1e 	brne	800089ba <_vfprintf_r+0x1efe>
80008582:	fa c3 f9 e0 	sub	r3,sp,-1568
80008586:	21 02       	sub	r2,16
80008588:	c0 38       	rjmp	8000858e <_vfprintf_r+0x1ad2>
8000858a:	fe c0 bc 2a 	sub	r0,pc,-17366
8000858e:	fa f9 06 90 	ld.w	r9,sp[1680]
80008592:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008596:	fe ca bc 36 	sub	r10,pc,-17354
8000859a:	59 02       	cp.w	r2,16
8000859c:	fe 99 ff dd 	brgt	80008556 <_vfprintf_r+0x1a9a>
800085a0:	04 09       	add	r9,r2
800085a2:	2f f8       	sub	r8,-1
800085a4:	87 0a       	st.w	r3[0x0],r10
800085a6:	fb 49 06 90 	st.w	sp[1680],r9
800085aa:	87 12       	st.w	r3[0x4],r2
800085ac:	fb 48 06 8c 	st.w	sp[1676],r8
800085b0:	58 78       	cp.w	r8,7
800085b2:	e0 89 00 04 	brgt	800085ba <_vfprintf_r+0x1afe>
800085b6:	2f 83       	sub	r3,-8
800085b8:	c0 b8       	rjmp	800085ce <_vfprintf_r+0x1b12>
800085ba:	fa ca f9 78 	sub	r10,sp,-1672
800085be:	02 9b       	mov	r11,r1
800085c0:	08 9c       	mov	r12,r4
800085c2:	fe b0 f2 6f 	rcall	80006aa0 <__sprint_r>
800085c6:	e0 81 01 fa 	brne	800089ba <_vfprintf_r+0x1efe>
800085ca:	fa c3 f9 e0 	sub	r3,sp,-1568
800085ce:	40 6c       	lddsp	r12,sp[0x18]
800085d0:	fa f8 06 90 	ld.w	r8,sp[1680]
800085d4:	87 06       	st.w	r3[0x0],r6
800085d6:	87 1c       	st.w	r3[0x4],r12
800085d8:	18 08       	add	r8,r12
800085da:	cb 98       	rjmp	8000874c <_vfprintf_r+0x1c90>
800085dc:	fa f9 06 90 	ld.w	r9,sp[1680]
800085e0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800085e4:	40 6b       	lddsp	r11,sp[0x18]
800085e6:	16 3a       	cp.w	r10,r11
800085e8:	c6 f5       	brlt	800086c6 <_vfprintf_r+0x1c0a>
800085ea:	16 09       	add	r9,r11
800085ec:	2f f8       	sub	r8,-1
800085ee:	87 06       	st.w	r3[0x0],r6
800085f0:	fb 49 06 90 	st.w	sp[1680],r9
800085f4:	87 1b       	st.w	r3[0x4],r11
800085f6:	fb 48 06 8c 	st.w	sp[1676],r8
800085fa:	58 78       	cp.w	r8,7
800085fc:	e0 89 00 04 	brgt	80008604 <_vfprintf_r+0x1b48>
80008600:	2f 83       	sub	r3,-8
80008602:	c0 b8       	rjmp	80008618 <_vfprintf_r+0x1b5c>
80008604:	fa ca f9 78 	sub	r10,sp,-1672
80008608:	02 9b       	mov	r11,r1
8000860a:	08 9c       	mov	r12,r4
8000860c:	fe b0 f2 4a 	rcall	80006aa0 <__sprint_r>
80008610:	e0 81 01 d5 	brne	800089ba <_vfprintf_r+0x1efe>
80008614:	fa c3 f9 e0 	sub	r3,sp,-1568
80008618:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000861c:	40 6a       	lddsp	r10,sp[0x18]
8000861e:	14 16       	sub	r6,r10
80008620:	58 06       	cp.w	r6,0
80008622:	e0 89 00 1c 	brgt	8000865a <_vfprintf_r+0x1b9e>
80008626:	c3 d8       	rjmp	800086a0 <_vfprintf_r+0x1be4>
80008628:	2f 09       	sub	r9,-16
8000862a:	2f f8       	sub	r8,-1
8000862c:	fb 49 06 90 	st.w	sp[1680],r9
80008630:	87 02       	st.w	r3[0x0],r2
80008632:	87 10       	st.w	r3[0x4],r0
80008634:	fb 48 06 8c 	st.w	sp[1676],r8
80008638:	58 78       	cp.w	r8,7
8000863a:	e0 89 00 04 	brgt	80008642 <_vfprintf_r+0x1b86>
8000863e:	2f 83       	sub	r3,-8
80008640:	c0 b8       	rjmp	80008656 <_vfprintf_r+0x1b9a>
80008642:	fa ca f9 78 	sub	r10,sp,-1672
80008646:	02 9b       	mov	r11,r1
80008648:	08 9c       	mov	r12,r4
8000864a:	fe b0 f2 2b 	rcall	80006aa0 <__sprint_r>
8000864e:	e0 81 01 b6 	brne	800089ba <_vfprintf_r+0x1efe>
80008652:	fa c3 f9 e0 	sub	r3,sp,-1568
80008656:	21 06       	sub	r6,16
80008658:	c0 48       	rjmp	80008660 <_vfprintf_r+0x1ba4>
8000865a:	fe c2 bc fa 	sub	r2,pc,-17158
8000865e:	31 00       	mov	r0,16
80008660:	fa f9 06 90 	ld.w	r9,sp[1680]
80008664:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008668:	fe ca bd 08 	sub	r10,pc,-17144
8000866c:	59 06       	cp.w	r6,16
8000866e:	fe 99 ff dd 	brgt	80008628 <_vfprintf_r+0x1b6c>
80008672:	0c 09       	add	r9,r6
80008674:	2f f8       	sub	r8,-1
80008676:	87 0a       	st.w	r3[0x0],r10
80008678:	fb 49 06 90 	st.w	sp[1680],r9
8000867c:	87 16       	st.w	r3[0x4],r6
8000867e:	fb 48 06 8c 	st.w	sp[1676],r8
80008682:	58 78       	cp.w	r8,7
80008684:	e0 89 00 04 	brgt	8000868c <_vfprintf_r+0x1bd0>
80008688:	2f 83       	sub	r3,-8
8000868a:	c0 b8       	rjmp	800086a0 <_vfprintf_r+0x1be4>
8000868c:	fa ca f9 78 	sub	r10,sp,-1672
80008690:	02 9b       	mov	r11,r1
80008692:	08 9c       	mov	r12,r4
80008694:	fe b0 f2 06 	rcall	80006aa0 <__sprint_r>
80008698:	e0 81 01 91 	brne	800089ba <_vfprintf_r+0x1efe>
8000869c:	fa c3 f9 e0 	sub	r3,sp,-1568
800086a0:	ed b5 00 00 	bld	r5,0x0
800086a4:	e0 81 01 20 	brne	800088e4 <_vfprintf_r+0x1e28>
800086a8:	40 c9       	lddsp	r9,sp[0x30]
800086aa:	fa f8 06 90 	ld.w	r8,sp[1680]
800086ae:	2f f8       	sub	r8,-1
800086b0:	87 09       	st.w	r3[0x0],r9
800086b2:	fb 48 06 90 	st.w	sp[1680],r8
800086b6:	30 19       	mov	r9,1
800086b8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800086bc:	87 19       	st.w	r3[0x4],r9
800086be:	2f f8       	sub	r8,-1
800086c0:	fb 48 06 8c 	st.w	sp[1676],r8
800086c4:	c0 29       	rjmp	800088c8 <_vfprintf_r+0x1e0c>
800086c6:	14 09       	add	r9,r10
800086c8:	2f f8       	sub	r8,-1
800086ca:	fb 49 06 90 	st.w	sp[1680],r9
800086ce:	87 06       	st.w	r3[0x0],r6
800086d0:	87 1a       	st.w	r3[0x4],r10
800086d2:	fb 48 06 8c 	st.w	sp[1676],r8
800086d6:	58 78       	cp.w	r8,7
800086d8:	e0 89 00 04 	brgt	800086e0 <_vfprintf_r+0x1c24>
800086dc:	2f 83       	sub	r3,-8
800086de:	c0 b8       	rjmp	800086f4 <_vfprintf_r+0x1c38>
800086e0:	fa ca f9 78 	sub	r10,sp,-1672
800086e4:	02 9b       	mov	r11,r1
800086e6:	08 9c       	mov	r12,r4
800086e8:	fe b0 f1 dc 	rcall	80006aa0 <__sprint_r>
800086ec:	e0 81 01 67 	brne	800089ba <_vfprintf_r+0x1efe>
800086f0:	fa c3 f9 e0 	sub	r3,sp,-1568
800086f4:	40 c8       	lddsp	r8,sp[0x30]
800086f6:	87 08       	st.w	r3[0x0],r8
800086f8:	fa f8 06 90 	ld.w	r8,sp[1680]
800086fc:	2f f8       	sub	r8,-1
800086fe:	30 19       	mov	r9,1
80008700:	fb 48 06 90 	st.w	sp[1680],r8
80008704:	87 19       	st.w	r3[0x4],r9
80008706:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000870a:	2f f8       	sub	r8,-1
8000870c:	fb 48 06 8c 	st.w	sp[1676],r8
80008710:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008714:	58 78       	cp.w	r8,7
80008716:	e0 89 00 04 	brgt	8000871e <_vfprintf_r+0x1c62>
8000871a:	2f 83       	sub	r3,-8
8000871c:	c0 b8       	rjmp	80008732 <_vfprintf_r+0x1c76>
8000871e:	fa ca f9 78 	sub	r10,sp,-1672
80008722:	02 9b       	mov	r11,r1
80008724:	08 9c       	mov	r12,r4
80008726:	fe b0 f1 bd 	rcall	80006aa0 <__sprint_r>
8000872a:	e0 81 01 48 	brne	800089ba <_vfprintf_r+0x1efe>
8000872e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008732:	04 06       	add	r6,r2
80008734:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008738:	87 06       	st.w	r3[0x0],r6
8000873a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000873e:	40 66       	lddsp	r6,sp[0x18]
80008740:	40 6e       	lddsp	lr,sp[0x18]
80008742:	10 16       	sub	r6,r8
80008744:	f2 08 01 08 	sub	r8,r9,r8
80008748:	87 16       	st.w	r3[0x4],r6
8000874a:	1c 08       	add	r8,lr
8000874c:	fb 48 06 90 	st.w	sp[1680],r8
80008750:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008754:	2f f8       	sub	r8,-1
80008756:	fb 48 06 8c 	st.w	sp[1676],r8
8000875a:	cb 78       	rjmp	800088c8 <_vfprintf_r+0x1e0c>
8000875c:	40 6c       	lddsp	r12,sp[0x18]
8000875e:	58 1c       	cp.w	r12,1
80008760:	e0 89 00 06 	brgt	8000876c <_vfprintf_r+0x1cb0>
80008764:	ed b5 00 00 	bld	r5,0x0
80008768:	e0 81 00 85 	brne	80008872 <_vfprintf_r+0x1db6>
8000876c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008770:	2f f8       	sub	r8,-1
80008772:	30 19       	mov	r9,1
80008774:	fb 48 06 90 	st.w	sp[1680],r8
80008778:	87 06       	st.w	r3[0x0],r6
8000877a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000877e:	87 19       	st.w	r3[0x4],r9
80008780:	2f f8       	sub	r8,-1
80008782:	fb 48 06 8c 	st.w	sp[1676],r8
80008786:	58 78       	cp.w	r8,7
80008788:	e0 89 00 04 	brgt	80008790 <_vfprintf_r+0x1cd4>
8000878c:	2f 83       	sub	r3,-8
8000878e:	c0 b8       	rjmp	800087a4 <_vfprintf_r+0x1ce8>
80008790:	fa ca f9 78 	sub	r10,sp,-1672
80008794:	02 9b       	mov	r11,r1
80008796:	08 9c       	mov	r12,r4
80008798:	fe b0 f1 84 	rcall	80006aa0 <__sprint_r>
8000879c:	e0 81 01 0f 	brne	800089ba <_vfprintf_r+0x1efe>
800087a0:	fa c3 f9 e0 	sub	r3,sp,-1568
800087a4:	fa f8 06 90 	ld.w	r8,sp[1680]
800087a8:	2f f8       	sub	r8,-1
800087aa:	40 cb       	lddsp	r11,sp[0x30]
800087ac:	fb 48 06 90 	st.w	sp[1680],r8
800087b0:	30 19       	mov	r9,1
800087b2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800087b6:	87 0b       	st.w	r3[0x0],r11
800087b8:	2f f8       	sub	r8,-1
800087ba:	87 19       	st.w	r3[0x4],r9
800087bc:	fb 48 06 8c 	st.w	sp[1676],r8
800087c0:	58 78       	cp.w	r8,7
800087c2:	e0 89 00 05 	brgt	800087cc <_vfprintf_r+0x1d10>
800087c6:	2f 83       	sub	r3,-8
800087c8:	c0 c8       	rjmp	800087e0 <_vfprintf_r+0x1d24>
800087ca:	d7 03       	nop
800087cc:	fa ca f9 78 	sub	r10,sp,-1672
800087d0:	02 9b       	mov	r11,r1
800087d2:	08 9c       	mov	r12,r4
800087d4:	fe b0 f1 66 	rcall	80006aa0 <__sprint_r>
800087d8:	e0 81 00 f1 	brne	800089ba <_vfprintf_r+0x1efe>
800087dc:	fa c3 f9 e0 	sub	r3,sp,-1568
800087e0:	30 08       	mov	r8,0
800087e2:	30 09       	mov	r9,0
800087e4:	40 5b       	lddsp	r11,sp[0x14]
800087e6:	40 7a       	lddsp	r10,sp[0x1c]
800087e8:	e0 a0 13 25 	rcall	8000ae32 <__avr32_f64_cmp_eq>
800087ec:	40 68       	lddsp	r8,sp[0x18]
800087ee:	20 18       	sub	r8,1
800087f0:	58 0c       	cp.w	r12,0
800087f2:	c0 d1       	brne	8000880c <_vfprintf_r+0x1d50>
800087f4:	2f f6       	sub	r6,-1
800087f6:	87 18       	st.w	r3[0x4],r8
800087f8:	87 06       	st.w	r3[0x0],r6
800087fa:	fa f6 06 90 	ld.w	r6,sp[1680]
800087fe:	10 06       	add	r6,r8
80008800:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008804:	fb 46 06 90 	st.w	sp[1680],r6
80008808:	2f f8       	sub	r8,-1
8000880a:	c3 18       	rjmp	8000886c <_vfprintf_r+0x1db0>
8000880c:	10 96       	mov	r6,r8
8000880e:	58 08       	cp.w	r8,0
80008810:	e0 89 00 1c 	brgt	80008848 <_vfprintf_r+0x1d8c>
80008814:	c4 b8       	rjmp	800088aa <_vfprintf_r+0x1dee>
80008816:	2f 09       	sub	r9,-16
80008818:	2f f8       	sub	r8,-1
8000881a:	fb 49 06 90 	st.w	sp[1680],r9
8000881e:	87 02       	st.w	r3[0x0],r2
80008820:	87 10       	st.w	r3[0x4],r0
80008822:	fb 48 06 8c 	st.w	sp[1676],r8
80008826:	58 78       	cp.w	r8,7
80008828:	e0 89 00 04 	brgt	80008830 <_vfprintf_r+0x1d74>
8000882c:	2f 83       	sub	r3,-8
8000882e:	c0 b8       	rjmp	80008844 <_vfprintf_r+0x1d88>
80008830:	fa ca f9 78 	sub	r10,sp,-1672
80008834:	02 9b       	mov	r11,r1
80008836:	08 9c       	mov	r12,r4
80008838:	fe b0 f1 34 	rcall	80006aa0 <__sprint_r>
8000883c:	e0 81 00 bf 	brne	800089ba <_vfprintf_r+0x1efe>
80008840:	fa c3 f9 e0 	sub	r3,sp,-1568
80008844:	21 06       	sub	r6,16
80008846:	c0 48       	rjmp	8000884e <_vfprintf_r+0x1d92>
80008848:	fe c2 be e8 	sub	r2,pc,-16664
8000884c:	31 00       	mov	r0,16
8000884e:	fa f9 06 90 	ld.w	r9,sp[1680]
80008852:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008856:	fe ca be f6 	sub	r10,pc,-16650
8000885a:	59 06       	cp.w	r6,16
8000885c:	fe 99 ff dd 	brgt	80008816 <_vfprintf_r+0x1d5a>
80008860:	0c 09       	add	r9,r6
80008862:	87 0a       	st.w	r3[0x0],r10
80008864:	fb 49 06 90 	st.w	sp[1680],r9
80008868:	2f f8       	sub	r8,-1
8000886a:	87 16       	st.w	r3[0x4],r6
8000886c:	fb 48 06 8c 	st.w	sp[1676],r8
80008870:	c0 e8       	rjmp	8000888c <_vfprintf_r+0x1dd0>
80008872:	fa f8 06 90 	ld.w	r8,sp[1680]
80008876:	2f f8       	sub	r8,-1
80008878:	30 19       	mov	r9,1
8000887a:	fb 48 06 90 	st.w	sp[1680],r8
8000887e:	87 06       	st.w	r3[0x0],r6
80008880:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008884:	87 19       	st.w	r3[0x4],r9
80008886:	2f f8       	sub	r8,-1
80008888:	fb 48 06 8c 	st.w	sp[1676],r8
8000888c:	58 78       	cp.w	r8,7
8000888e:	e0 89 00 04 	brgt	80008896 <_vfprintf_r+0x1dda>
80008892:	2f 83       	sub	r3,-8
80008894:	c0 b8       	rjmp	800088aa <_vfprintf_r+0x1dee>
80008896:	fa ca f9 78 	sub	r10,sp,-1672
8000889a:	02 9b       	mov	r11,r1
8000889c:	08 9c       	mov	r12,r4
8000889e:	fe b0 f1 01 	rcall	80006aa0 <__sprint_r>
800088a2:	e0 81 00 8c 	brne	800089ba <_vfprintf_r+0x1efe>
800088a6:	fa c3 f9 e0 	sub	r3,sp,-1568
800088aa:	40 ea       	lddsp	r10,sp[0x38]
800088ac:	fa f8 06 90 	ld.w	r8,sp[1680]
800088b0:	14 08       	add	r8,r10
800088b2:	fa c9 f9 64 	sub	r9,sp,-1692
800088b6:	fb 48 06 90 	st.w	sp[1680],r8
800088ba:	87 1a       	st.w	r3[0x4],r10
800088bc:	fa f8 06 8c 	ld.w	r8,sp[1676]
800088c0:	87 09       	st.w	r3[0x0],r9
800088c2:	2f f8       	sub	r8,-1
800088c4:	fb 48 06 8c 	st.w	sp[1676],r8
800088c8:	58 78       	cp.w	r8,7
800088ca:	e0 89 00 04 	brgt	800088d2 <_vfprintf_r+0x1e16>
800088ce:	2f 83       	sub	r3,-8
800088d0:	c0 a8       	rjmp	800088e4 <_vfprintf_r+0x1e28>
800088d2:	fa ca f9 78 	sub	r10,sp,-1672
800088d6:	02 9b       	mov	r11,r1
800088d8:	08 9c       	mov	r12,r4
800088da:	fe b0 f0 e3 	rcall	80006aa0 <__sprint_r>
800088de:	c6 e1       	brne	800089ba <_vfprintf_r+0x1efe>
800088e0:	fa c3 f9 e0 	sub	r3,sp,-1568
800088e4:	e2 15 00 04 	andl	r5,0x4,COH
800088e8:	c3 f0       	breq	80008966 <_vfprintf_r+0x1eaa>
800088ea:	40 86       	lddsp	r6,sp[0x20]
800088ec:	40 39       	lddsp	r9,sp[0xc]
800088ee:	12 16       	sub	r6,r9
800088f0:	58 06       	cp.w	r6,0
800088f2:	e0 89 00 1a 	brgt	80008926 <_vfprintf_r+0x1e6a>
800088f6:	c3 88       	rjmp	80008966 <_vfprintf_r+0x1eaa>
800088f8:	2f 09       	sub	r9,-16
800088fa:	2f f8       	sub	r8,-1
800088fc:	fb 49 06 90 	st.w	sp[1680],r9
80008900:	87 05       	st.w	r3[0x0],r5
80008902:	87 12       	st.w	r3[0x4],r2
80008904:	fb 48 06 8c 	st.w	sp[1676],r8
80008908:	58 78       	cp.w	r8,7
8000890a:	e0 89 00 04 	brgt	80008912 <_vfprintf_r+0x1e56>
8000890e:	2f 83       	sub	r3,-8
80008910:	c0 98       	rjmp	80008922 <_vfprintf_r+0x1e66>
80008912:	00 9a       	mov	r10,r0
80008914:	02 9b       	mov	r11,r1
80008916:	08 9c       	mov	r12,r4
80008918:	fe b0 f0 c4 	rcall	80006aa0 <__sprint_r>
8000891c:	c4 f1       	brne	800089ba <_vfprintf_r+0x1efe>
8000891e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008922:	21 06       	sub	r6,16
80008924:	c0 68       	rjmp	80008930 <_vfprintf_r+0x1e74>
80008926:	fe c5 bf d6 	sub	r5,pc,-16426
8000892a:	31 02       	mov	r2,16
8000892c:	fa c0 f9 78 	sub	r0,sp,-1672
80008930:	fa f9 06 90 	ld.w	r9,sp[1680]
80008934:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008938:	fe ca bf e8 	sub	r10,pc,-16408
8000893c:	59 06       	cp.w	r6,16
8000893e:	fe 99 ff dd 	brgt	800088f8 <_vfprintf_r+0x1e3c>
80008942:	0c 09       	add	r9,r6
80008944:	2f f8       	sub	r8,-1
80008946:	87 0a       	st.w	r3[0x0],r10
80008948:	87 16       	st.w	r3[0x4],r6
8000894a:	fb 49 06 90 	st.w	sp[1680],r9
8000894e:	fb 48 06 8c 	st.w	sp[1676],r8
80008952:	58 78       	cp.w	r8,7
80008954:	e0 8a 00 09 	brle	80008966 <_vfprintf_r+0x1eaa>
80008958:	fa ca f9 78 	sub	r10,sp,-1672
8000895c:	02 9b       	mov	r11,r1
8000895e:	08 9c       	mov	r12,r4
80008960:	fe b0 f0 a0 	rcall	80006aa0 <__sprint_r>
80008964:	c2 b1       	brne	800089ba <_vfprintf_r+0x1efe>
80008966:	40 bc       	lddsp	r12,sp[0x2c]
80008968:	40 36       	lddsp	r6,sp[0xc]
8000896a:	40 8e       	lddsp	lr,sp[0x20]
8000896c:	ec 0e 0c 48 	max	r8,r6,lr
80008970:	10 0c       	add	r12,r8
80008972:	50 bc       	stdsp	sp[0x2c],r12
80008974:	fa f8 06 90 	ld.w	r8,sp[1680]
80008978:	58 08       	cp.w	r8,0
8000897a:	c0 80       	breq	8000898a <_vfprintf_r+0x1ece>
8000897c:	fa ca f9 78 	sub	r10,sp,-1672
80008980:	02 9b       	mov	r11,r1
80008982:	08 9c       	mov	r12,r4
80008984:	fe b0 f0 8e 	rcall	80006aa0 <__sprint_r>
80008988:	c1 91       	brne	800089ba <_vfprintf_r+0x1efe>
8000898a:	30 0b       	mov	r11,0
8000898c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008990:	fb 4b 06 8c 	st.w	sp[1676],r11
80008994:	fe 9f f1 22 	bral	80006bd8 <_vfprintf_r+0x11c>
80008998:	08 95       	mov	r5,r4
8000899a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000899e:	58 08       	cp.w	r8,0
800089a0:	c0 80       	breq	800089b0 <_vfprintf_r+0x1ef4>
800089a2:	08 9c       	mov	r12,r4
800089a4:	fa ca f9 78 	sub	r10,sp,-1672
800089a8:	02 9b       	mov	r11,r1
800089aa:	fe b0 f0 7b 	rcall	80006aa0 <__sprint_r>
800089ae:	c0 61       	brne	800089ba <_vfprintf_r+0x1efe>
800089b0:	30 08       	mov	r8,0
800089b2:	fb 48 06 8c 	st.w	sp[1676],r8
800089b6:	c0 28       	rjmp	800089ba <_vfprintf_r+0x1efe>
800089b8:	40 41       	lddsp	r1,sp[0x10]
800089ba:	82 68       	ld.sh	r8,r1[0xc]
800089bc:	ed b8 00 06 	bld	r8,0x6
800089c0:	c0 31       	brne	800089c6 <_vfprintf_r+0x1f0a>
800089c2:	3f fa       	mov	r10,-1
800089c4:	50 ba       	stdsp	sp[0x2c],r10
800089c6:	40 bc       	lddsp	r12,sp[0x2c]
800089c8:	fe 3d f9 44 	sub	sp,-1724
800089cc:	d8 32       	popm	r0-r7,pc
800089ce:	d7 03       	nop

800089d0 <__swsetup_r>:
800089d0:	d4 21       	pushm	r4-r7,lr
800089d2:	e0 68 0a 18 	mov	r8,2584
800089d6:	18 96       	mov	r6,r12
800089d8:	16 97       	mov	r7,r11
800089da:	70 0c       	ld.w	r12,r8[0x0]
800089dc:	58 0c       	cp.w	r12,0
800089de:	c0 60       	breq	800089ea <__swsetup_r+0x1a>
800089e0:	78 68       	ld.w	r8,r12[0x18]
800089e2:	58 08       	cp.w	r8,0
800089e4:	c0 31       	brne	800089ea <__swsetup_r+0x1a>
800089e6:	e0 a0 07 bf 	rcall	80009964 <__sinit>
800089ea:	fe c8 bf 6a 	sub	r8,pc,-16534
800089ee:	10 37       	cp.w	r7,r8
800089f0:	c0 61       	brne	800089fc <__swsetup_r+0x2c>
800089f2:	e0 68 0a 18 	mov	r8,2584
800089f6:	70 08       	ld.w	r8,r8[0x0]
800089f8:	70 07       	ld.w	r7,r8[0x0]
800089fa:	c1 28       	rjmp	80008a1e <__swsetup_r+0x4e>
800089fc:	fe c8 bf 5c 	sub	r8,pc,-16548
80008a00:	10 37       	cp.w	r7,r8
80008a02:	c0 61       	brne	80008a0e <__swsetup_r+0x3e>
80008a04:	e0 68 0a 18 	mov	r8,2584
80008a08:	70 08       	ld.w	r8,r8[0x0]
80008a0a:	70 17       	ld.w	r7,r8[0x4]
80008a0c:	c0 98       	rjmp	80008a1e <__swsetup_r+0x4e>
80008a0e:	fe c8 bf 4e 	sub	r8,pc,-16562
80008a12:	10 37       	cp.w	r7,r8
80008a14:	c0 51       	brne	80008a1e <__swsetup_r+0x4e>
80008a16:	e0 68 0a 18 	mov	r8,2584
80008a1a:	70 08       	ld.w	r8,r8[0x0]
80008a1c:	70 27       	ld.w	r7,r8[0x8]
80008a1e:	8e 68       	ld.sh	r8,r7[0xc]
80008a20:	ed b8 00 03 	bld	r8,0x3
80008a24:	c1 e0       	breq	80008a60 <__swsetup_r+0x90>
80008a26:	ed b8 00 04 	bld	r8,0x4
80008a2a:	c3 e1       	brne	80008aa6 <__swsetup_r+0xd6>
80008a2c:	ed b8 00 02 	bld	r8,0x2
80008a30:	c1 51       	brne	80008a5a <__swsetup_r+0x8a>
80008a32:	6e db       	ld.w	r11,r7[0x34]
80008a34:	58 0b       	cp.w	r11,0
80008a36:	c0 a0       	breq	80008a4a <__swsetup_r+0x7a>
80008a38:	ee c8 ff bc 	sub	r8,r7,-68
80008a3c:	10 3b       	cp.w	r11,r8
80008a3e:	c0 40       	breq	80008a46 <__swsetup_r+0x76>
80008a40:	0c 9c       	mov	r12,r6
80008a42:	e0 a0 08 2b 	rcall	80009a98 <_free_r>
80008a46:	30 08       	mov	r8,0
80008a48:	8f d8       	st.w	r7[0x34],r8
80008a4a:	8e 68       	ld.sh	r8,r7[0xc]
80008a4c:	e0 18 ff db 	andl	r8,0xffdb
80008a50:	ae 68       	st.h	r7[0xc],r8
80008a52:	30 08       	mov	r8,0
80008a54:	8f 18       	st.w	r7[0x4],r8
80008a56:	6e 48       	ld.w	r8,r7[0x10]
80008a58:	8f 08       	st.w	r7[0x0],r8
80008a5a:	8e 68       	ld.sh	r8,r7[0xc]
80008a5c:	a3 b8       	sbr	r8,0x3
80008a5e:	ae 68       	st.h	r7[0xc],r8
80008a60:	6e 48       	ld.w	r8,r7[0x10]
80008a62:	58 08       	cp.w	r8,0
80008a64:	c0 b1       	brne	80008a7a <__swsetup_r+0xaa>
80008a66:	8e 68       	ld.sh	r8,r7[0xc]
80008a68:	e2 18 02 80 	andl	r8,0x280,COH
80008a6c:	e0 48 02 00 	cp.w	r8,512
80008a70:	c0 50       	breq	80008a7a <__swsetup_r+0xaa>
80008a72:	0c 9c       	mov	r12,r6
80008a74:	0e 9b       	mov	r11,r7
80008a76:	e0 a0 0a 4b 	rcall	80009f0c <__smakebuf_r>
80008a7a:	8e 69       	ld.sh	r9,r7[0xc]
80008a7c:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80008a80:	c0 70       	breq	80008a8e <__swsetup_r+0xbe>
80008a82:	30 08       	mov	r8,0
80008a84:	8f 28       	st.w	r7[0x8],r8
80008a86:	6e 58       	ld.w	r8,r7[0x14]
80008a88:	5c 38       	neg	r8
80008a8a:	8f 68       	st.w	r7[0x18],r8
80008a8c:	c0 68       	rjmp	80008a98 <__swsetup_r+0xc8>
80008a8e:	ed b9 00 01 	bld	r9,0x1
80008a92:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80008a96:	8f 28       	st.w	r7[0x8],r8
80008a98:	6e 48       	ld.w	r8,r7[0x10]
80008a9a:	58 08       	cp.w	r8,0
80008a9c:	c0 61       	brne	80008aa8 <__swsetup_r+0xd8>
80008a9e:	8e 68       	ld.sh	r8,r7[0xc]
80008aa0:	ed b8 00 07 	bld	r8,0x7
80008aa4:	c0 21       	brne	80008aa8 <__swsetup_r+0xd8>
80008aa6:	dc 2a       	popm	r4-r7,pc,r12=-1
80008aa8:	d8 2a       	popm	r4-r7,pc,r12=0
80008aaa:	d7 03       	nop

80008aac <quorem>:
80008aac:	d4 31       	pushm	r0-r7,lr
80008aae:	20 2d       	sub	sp,8
80008ab0:	18 97       	mov	r7,r12
80008ab2:	78 48       	ld.w	r8,r12[0x10]
80008ab4:	76 46       	ld.w	r6,r11[0x10]
80008ab6:	0c 38       	cp.w	r8,r6
80008ab8:	c0 34       	brge	80008abe <quorem+0x12>
80008aba:	30 0c       	mov	r12,0
80008abc:	c8 58       	rjmp	80008bc6 <quorem+0x11a>
80008abe:	ec c2 ff fc 	sub	r2,r6,-4
80008ac2:	f6 c3 ff ec 	sub	r3,r11,-20
80008ac6:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80008aca:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80008ace:	2f f9       	sub	r9,-1
80008ad0:	20 16       	sub	r6,1
80008ad2:	f8 09 0d 08 	divu	r8,r12,r9
80008ad6:	f6 02 00 22 	add	r2,r11,r2<<0x2
80008ada:	ee c4 ff ec 	sub	r4,r7,-20
80008ade:	10 95       	mov	r5,r8
80008ae0:	58 08       	cp.w	r8,0
80008ae2:	c4 10       	breq	80008b64 <quorem+0xb8>
80008ae4:	30 09       	mov	r9,0
80008ae6:	06 9a       	mov	r10,r3
80008ae8:	08 98       	mov	r8,r4
80008aea:	12 91       	mov	r1,r9
80008aec:	50 0b       	stdsp	sp[0x0],r11
80008aee:	70 0e       	ld.w	lr,r8[0x0]
80008af0:	b1 8e       	lsr	lr,0x10
80008af2:	50 1e       	stdsp	sp[0x4],lr
80008af4:	15 0e       	ld.w	lr,r10++
80008af6:	fc 00 16 10 	lsr	r0,lr,0x10
80008afa:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80008afe:	ea 0e 03 41 	mac	r1,r5,lr
80008b02:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80008b06:	b1 81       	lsr	r1,0x10
80008b08:	40 1b       	lddsp	r11,sp[0x4]
80008b0a:	ea 00 02 40 	mul	r0,r5,r0
80008b0e:	e2 00 00 00 	add	r0,r1,r0
80008b12:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80008b16:	02 1b       	sub	r11,r1
80008b18:	50 1b       	stdsp	sp[0x4],r11
80008b1a:	70 0b       	ld.w	r11,r8[0x0]
80008b1c:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80008b20:	02 09       	add	r9,r1
80008b22:	f2 0e 01 0e 	sub	lr,r9,lr
80008b26:	b0 1e       	st.h	r8[0x2],lr
80008b28:	fc 09 14 10 	asr	r9,lr,0x10
80008b2c:	40 1e       	lddsp	lr,sp[0x4]
80008b2e:	fc 09 00 09 	add	r9,lr,r9
80008b32:	b0 09       	st.h	r8[0x0],r9
80008b34:	e0 01 16 10 	lsr	r1,r0,0x10
80008b38:	2f c8       	sub	r8,-4
80008b3a:	b1 49       	asr	r9,0x10
80008b3c:	04 3a       	cp.w	r10,r2
80008b3e:	fe 98 ff d8 	brls	80008aee <quorem+0x42>
80008b42:	40 0b       	lddsp	r11,sp[0x0]
80008b44:	58 0c       	cp.w	r12,0
80008b46:	c0 f1       	brne	80008b64 <quorem+0xb8>
80008b48:	ec c8 ff fb 	sub	r8,r6,-5
80008b4c:	ee 08 00 28 	add	r8,r7,r8<<0x2
80008b50:	c0 28       	rjmp	80008b54 <quorem+0xa8>
80008b52:	20 16       	sub	r6,1
80008b54:	20 48       	sub	r8,4
80008b56:	08 38       	cp.w	r8,r4
80008b58:	e0 88 00 05 	brls	80008b62 <quorem+0xb6>
80008b5c:	70 09       	ld.w	r9,r8[0x0]
80008b5e:	58 09       	cp.w	r9,0
80008b60:	cf 90       	breq	80008b52 <quorem+0xa6>
80008b62:	8f 46       	st.w	r7[0x10],r6
80008b64:	0e 9c       	mov	r12,r7
80008b66:	e0 a0 0a d2 	rcall	8000a10a <__mcmp>
80008b6a:	c2 d5       	brlt	80008bc4 <quorem+0x118>
80008b6c:	2f f5       	sub	r5,-1
80008b6e:	08 98       	mov	r8,r4
80008b70:	30 09       	mov	r9,0
80008b72:	07 0b       	ld.w	r11,r3++
80008b74:	f6 0a 16 10 	lsr	r10,r11,0x10
80008b78:	70 0c       	ld.w	r12,r8[0x0]
80008b7a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80008b7e:	f8 0e 16 10 	lsr	lr,r12,0x10
80008b82:	14 1e       	sub	lr,r10
80008b84:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80008b88:	16 1a       	sub	r10,r11
80008b8a:	12 0a       	add	r10,r9
80008b8c:	b0 1a       	st.h	r8[0x2],r10
80008b8e:	b1 4a       	asr	r10,0x10
80008b90:	fc 0a 00 09 	add	r9,lr,r10
80008b94:	b0 09       	st.h	r8[0x0],r9
80008b96:	2f c8       	sub	r8,-4
80008b98:	b1 49       	asr	r9,0x10
80008b9a:	04 33       	cp.w	r3,r2
80008b9c:	fe 98 ff eb 	brls	80008b72 <quorem+0xc6>
80008ba0:	ec c8 ff fb 	sub	r8,r6,-5
80008ba4:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80008ba8:	58 09       	cp.w	r9,0
80008baa:	c0 d1       	brne	80008bc4 <quorem+0x118>
80008bac:	ee 08 00 28 	add	r8,r7,r8<<0x2
80008bb0:	c0 28       	rjmp	80008bb4 <quorem+0x108>
80008bb2:	20 16       	sub	r6,1
80008bb4:	20 48       	sub	r8,4
80008bb6:	08 38       	cp.w	r8,r4
80008bb8:	e0 88 00 05 	brls	80008bc2 <quorem+0x116>
80008bbc:	70 09       	ld.w	r9,r8[0x0]
80008bbe:	58 09       	cp.w	r9,0
80008bc0:	cf 90       	breq	80008bb2 <quorem+0x106>
80008bc2:	8f 46       	st.w	r7[0x10],r6
80008bc4:	0a 9c       	mov	r12,r5
80008bc6:	2f ed       	sub	sp,-8
80008bc8:	d8 32       	popm	r0-r7,pc
80008bca:	d7 03       	nop

80008bcc <_dtoa_r>:
80008bcc:	d4 31       	pushm	r0-r7,lr
80008bce:	21 ad       	sub	sp,104
80008bd0:	fa c4 ff 74 	sub	r4,sp,-140
80008bd4:	18 97       	mov	r7,r12
80008bd6:	16 95       	mov	r5,r11
80008bd8:	68 2c       	ld.w	r12,r4[0x8]
80008bda:	50 c9       	stdsp	sp[0x30],r9
80008bdc:	68 16       	ld.w	r6,r4[0x4]
80008bde:	68 09       	ld.w	r9,r4[0x0]
80008be0:	50 e8       	stdsp	sp[0x38],r8
80008be2:	14 94       	mov	r4,r10
80008be4:	51 2c       	stdsp	sp[0x48],r12
80008be6:	fa e5 00 08 	st.d	sp[8],r4
80008bea:	51 59       	stdsp	sp[0x54],r9
80008bec:	6e 95       	ld.w	r5,r7[0x24]
80008bee:	58 05       	cp.w	r5,0
80008bf0:	c0 91       	brne	80008c02 <_dtoa_r+0x36>
80008bf2:	31 0c       	mov	r12,16
80008bf4:	fe b0 e8 e2 	rcall	80005db8 <malloc>
80008bf8:	99 35       	st.w	r12[0xc],r5
80008bfa:	8f 9c       	st.w	r7[0x24],r12
80008bfc:	99 15       	st.w	r12[0x4],r5
80008bfe:	99 25       	st.w	r12[0x8],r5
80008c00:	99 05       	st.w	r12[0x0],r5
80008c02:	6e 99       	ld.w	r9,r7[0x24]
80008c04:	72 08       	ld.w	r8,r9[0x0]
80008c06:	58 08       	cp.w	r8,0
80008c08:	c0 f0       	breq	80008c26 <_dtoa_r+0x5a>
80008c0a:	72 1a       	ld.w	r10,r9[0x4]
80008c0c:	91 1a       	st.w	r8[0x4],r10
80008c0e:	30 1a       	mov	r10,1
80008c10:	72 19       	ld.w	r9,r9[0x4]
80008c12:	f4 09 09 49 	lsl	r9,r10,r9
80008c16:	10 9b       	mov	r11,r8
80008c18:	91 29       	st.w	r8[0x8],r9
80008c1a:	0e 9c       	mov	r12,r7
80008c1c:	e0 a0 0a 90 	rcall	8000a13c <_Bfree>
80008c20:	6e 98       	ld.w	r8,r7[0x24]
80008c22:	30 09       	mov	r9,0
80008c24:	91 09       	st.w	r8[0x0],r9
80008c26:	40 28       	lddsp	r8,sp[0x8]
80008c28:	10 94       	mov	r4,r8
80008c2a:	58 08       	cp.w	r8,0
80008c2c:	c0 64       	brge	80008c38 <_dtoa_r+0x6c>
80008c2e:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80008c32:	50 28       	stdsp	sp[0x8],r8
80008c34:	30 18       	mov	r8,1
80008c36:	c0 28       	rjmp	80008c3a <_dtoa_r+0x6e>
80008c38:	30 08       	mov	r8,0
80008c3a:	8d 08       	st.w	r6[0x0],r8
80008c3c:	fc 1c 7f f0 	movh	r12,0x7ff0
80008c40:	40 26       	lddsp	r6,sp[0x8]
80008c42:	0c 98       	mov	r8,r6
80008c44:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80008c48:	18 38       	cp.w	r8,r12
80008c4a:	c2 01       	brne	80008c8a <_dtoa_r+0xbe>
80008c4c:	e0 68 27 0f 	mov	r8,9999
80008c50:	41 5b       	lddsp	r11,sp[0x54]
80008c52:	97 08       	st.w	r11[0x0],r8
80008c54:	40 3a       	lddsp	r10,sp[0xc]
80008c56:	58 0a       	cp.w	r10,0
80008c58:	c0 71       	brne	80008c66 <_dtoa_r+0x9a>
80008c5a:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80008c5e:	c0 41       	brne	80008c66 <_dtoa_r+0x9a>
80008c60:	fe cc c1 f0 	sub	r12,pc,-15888
80008c64:	c0 38       	rjmp	80008c6a <_dtoa_r+0x9e>
80008c66:	fe cc c1 ea 	sub	r12,pc,-15894
80008c6a:	41 29       	lddsp	r9,sp[0x48]
80008c6c:	58 09       	cp.w	r9,0
80008c6e:	e0 80 05 9a 	breq	800097a2 <_dtoa_r+0xbd6>
80008c72:	f8 c8 ff fd 	sub	r8,r12,-3
80008c76:	f8 c9 ff f8 	sub	r9,r12,-8
80008c7a:	11 8b       	ld.ub	r11,r8[0x0]
80008c7c:	30 0a       	mov	r10,0
80008c7e:	41 25       	lddsp	r5,sp[0x48]
80008c80:	f4 0b 18 00 	cp.b	r11,r10
80008c84:	f2 08 17 10 	movne	r8,r9
80008c88:	c1 68       	rjmp	80008cb4 <_dtoa_r+0xe8>
80008c8a:	fa ea 00 08 	ld.d	r10,sp[8]
80008c8e:	30 08       	mov	r8,0
80008c90:	fa eb 00 3c 	st.d	sp[60],r10
80008c94:	30 09       	mov	r9,0
80008c96:	e0 a0 10 ce 	rcall	8000ae32 <__avr32_f64_cmp_eq>
80008c9a:	c1 00       	breq	80008cba <_dtoa_r+0xee>
80008c9c:	30 18       	mov	r8,1
80008c9e:	41 5a       	lddsp	r10,sp[0x54]
80008ca0:	95 08       	st.w	r10[0x0],r8
80008ca2:	fe cc c3 56 	sub	r12,pc,-15530
80008ca6:	41 29       	lddsp	r9,sp[0x48]
80008ca8:	f8 08 00 08 	add	r8,r12,r8
80008cac:	58 09       	cp.w	r9,0
80008cae:	e0 80 05 7a 	breq	800097a2 <_dtoa_r+0xbd6>
80008cb2:	12 95       	mov	r5,r9
80008cb4:	8b 08       	st.w	r5[0x0],r8
80008cb6:	e0 8f 05 76 	bral	800097a2 <_dtoa_r+0xbd6>
80008cba:	fa c8 ff 9c 	sub	r8,sp,-100
80008cbe:	fa c9 ff a0 	sub	r9,sp,-96
80008cc2:	fa ea 00 3c 	ld.d	r10,sp[60]
80008cc6:	0e 9c       	mov	r12,r7
80008cc8:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80008ccc:	e0 a0 0a 8a 	rcall	8000a1e0 <__d2b>
80008cd0:	18 93       	mov	r3,r12
80008cd2:	58 05       	cp.w	r5,0
80008cd4:	c0 d0       	breq	80008cee <_dtoa_r+0x122>
80008cd6:	fa ea 00 3c 	ld.d	r10,sp[60]
80008cda:	30 04       	mov	r4,0
80008cdc:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80008ce0:	ea c5 03 ff 	sub	r5,r5,1023
80008ce4:	10 9b       	mov	r11,r8
80008ce6:	51 74       	stdsp	sp[0x5c],r4
80008ce8:	ea 1b 3f f0 	orh	r11,0x3ff0
80008cec:	c2 58       	rjmp	80008d36 <_dtoa_r+0x16a>
80008cee:	41 88       	lddsp	r8,sp[0x60]
80008cf0:	41 9c       	lddsp	r12,sp[0x64]
80008cf2:	10 0c       	add	r12,r8
80008cf4:	f8 c5 fb ce 	sub	r5,r12,-1074
80008cf8:	e0 45 00 20 	cp.w	r5,32
80008cfc:	e0 8a 00 0e 	brle	80008d18 <_dtoa_r+0x14c>
80008d00:	f8 cc fb ee 	sub	r12,r12,-1042
80008d04:	40 3b       	lddsp	r11,sp[0xc]
80008d06:	ea 08 11 40 	rsub	r8,r5,64
80008d0a:	f6 0c 0a 4c 	lsr	r12,r11,r12
80008d0e:	ec 08 09 46 	lsl	r6,r6,r8
80008d12:	0c 4c       	or	r12,r6
80008d14:	c0 78       	rjmp	80008d22 <_dtoa_r+0x156>
80008d16:	d7 03       	nop
80008d18:	ea 0c 11 20 	rsub	r12,r5,32
80008d1c:	40 3a       	lddsp	r10,sp[0xc]
80008d1e:	f4 0c 09 4c 	lsl	r12,r10,r12
80008d22:	e0 a0 10 14 	rcall	8000ad4a <__avr32_u32_to_f64>
80008d26:	fc 18 fe 10 	movh	r8,0xfe10
80008d2a:	30 19       	mov	r9,1
80008d2c:	ea c5 04 33 	sub	r5,r5,1075
80008d30:	f0 0b 00 0b 	add	r11,r8,r11
80008d34:	51 79       	stdsp	sp[0x5c],r9
80008d36:	30 08       	mov	r8,0
80008d38:	fc 19 3f f8 	movh	r9,0x3ff8
80008d3c:	e0 a0 0e 9c 	rcall	8000aa74 <__avr32_f64_sub>
80008d40:	e0 68 43 61 	mov	r8,17249
80008d44:	ea 18 63 6f 	orh	r8,0x636f
80008d48:	e0 69 87 a7 	mov	r9,34727
80008d4c:	ea 19 3f d2 	orh	r9,0x3fd2
80008d50:	e0 a0 0d a6 	rcall	8000a89c <__avr32_f64_mul>
80008d54:	e0 68 c8 b3 	mov	r8,51379
80008d58:	ea 18 8b 60 	orh	r8,0x8b60
80008d5c:	e0 69 8a 28 	mov	r9,35368
80008d60:	ea 19 3f c6 	orh	r9,0x3fc6
80008d64:	e0 a0 0f 56 	rcall	8000ac10 <__avr32_f64_add>
80008d68:	0a 9c       	mov	r12,r5
80008d6a:	14 90       	mov	r0,r10
80008d6c:	16 91       	mov	r1,r11
80008d6e:	e0 a0 0f f2 	rcall	8000ad52 <__avr32_s32_to_f64>
80008d72:	e0 68 79 fb 	mov	r8,31227
80008d76:	ea 18 50 9f 	orh	r8,0x509f
80008d7a:	e0 69 44 13 	mov	r9,17427
80008d7e:	ea 19 3f d3 	orh	r9,0x3fd3
80008d82:	e0 a0 0d 8d 	rcall	8000a89c <__avr32_f64_mul>
80008d86:	14 98       	mov	r8,r10
80008d88:	16 99       	mov	r9,r11
80008d8a:	00 9a       	mov	r10,r0
80008d8c:	02 9b       	mov	r11,r1
80008d8e:	e0 a0 0f 41 	rcall	8000ac10 <__avr32_f64_add>
80008d92:	14 90       	mov	r0,r10
80008d94:	16 91       	mov	r1,r11
80008d96:	e0 a0 0f c7 	rcall	8000ad24 <__avr32_f64_to_s32>
80008d9a:	30 08       	mov	r8,0
80008d9c:	18 96       	mov	r6,r12
80008d9e:	30 09       	mov	r9,0
80008da0:	00 9a       	mov	r10,r0
80008da2:	02 9b       	mov	r11,r1
80008da4:	e0 a0 10 8e 	rcall	8000aec0 <__avr32_f64_cmp_lt>
80008da8:	c0 c0       	breq	80008dc0 <_dtoa_r+0x1f4>
80008daa:	0c 9c       	mov	r12,r6
80008dac:	e0 a0 0f d3 	rcall	8000ad52 <__avr32_s32_to_f64>
80008db0:	14 98       	mov	r8,r10
80008db2:	16 99       	mov	r9,r11
80008db4:	00 9a       	mov	r10,r0
80008db6:	02 9b       	mov	r11,r1
80008db8:	e0 a0 10 3d 	rcall	8000ae32 <__avr32_f64_cmp_eq>
80008dbc:	f7 b6 00 01 	subeq	r6,1
80008dc0:	59 66       	cp.w	r6,22
80008dc2:	e0 88 00 05 	brls	80008dcc <_dtoa_r+0x200>
80008dc6:	30 18       	mov	r8,1
80008dc8:	51 48       	stdsp	sp[0x50],r8
80008dca:	c1 38       	rjmp	80008df0 <_dtoa_r+0x224>
80008dcc:	fe c8 c2 9c 	sub	r8,pc,-15716
80008dd0:	fa ea 00 3c 	ld.d	r10,sp[60]
80008dd4:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
80008dd8:	e0 a0 10 74 	rcall	8000aec0 <__avr32_f64_cmp_lt>
80008ddc:	f9 b4 00 00 	moveq	r4,0
80008de0:	fb f4 0a 14 	st.weq	sp[0x50],r4
80008de4:	f7 b6 01 01 	subne	r6,1
80008de8:	f9 bc 01 00 	movne	r12,0
80008dec:	fb fc 1a 14 	st.wne	sp[0x50],r12
80008df0:	41 90       	lddsp	r0,sp[0x64]
80008df2:	20 10       	sub	r0,1
80008df4:	0a 10       	sub	r0,r5
80008df6:	c0 46       	brmi	80008dfe <_dtoa_r+0x232>
80008df8:	50 40       	stdsp	sp[0x10],r0
80008dfa:	30 00       	mov	r0,0
80008dfc:	c0 48       	rjmp	80008e04 <_dtoa_r+0x238>
80008dfe:	30 0b       	mov	r11,0
80008e00:	5c 30       	neg	r0
80008e02:	50 4b       	stdsp	sp[0x10],r11
80008e04:	ec 02 11 00 	rsub	r2,r6,0
80008e08:	58 06       	cp.w	r6,0
80008e0a:	fb fa 40 04 	ld.wge	r10,sp[0x10]
80008e0e:	f5 d6 e4 0a 	addge	r10,r10,r6
80008e12:	fb fa 4a 04 	st.wge	sp[0x10],r10
80008e16:	fb f6 4a 11 	st.wge	sp[0x44],r6
80008e1a:	f9 b2 04 00 	movge	r2,0
80008e1e:	e1 d6 e5 10 	sublt	r0,r0,r6
80008e22:	f9 b9 05 00 	movlt	r9,0
80008e26:	fb f9 5a 11 	st.wlt	sp[0x44],r9
80008e2a:	40 c8       	lddsp	r8,sp[0x30]
80008e2c:	58 98       	cp.w	r8,9
80008e2e:	e0 8b 00 20 	brhi	80008e6e <_dtoa_r+0x2a2>
80008e32:	58 58       	cp.w	r8,5
80008e34:	f9 b4 0a 01 	movle	r4,1
80008e38:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80008e3c:	f7 b5 09 04 	subgt	r5,4
80008e40:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80008e44:	f9 b4 09 00 	movgt	r4,0
80008e48:	40 cc       	lddsp	r12,sp[0x30]
80008e4a:	58 3c       	cp.w	r12,3
80008e4c:	c2 d0       	breq	80008ea6 <_dtoa_r+0x2da>
80008e4e:	e0 89 00 05 	brgt	80008e58 <_dtoa_r+0x28c>
80008e52:	58 2c       	cp.w	r12,2
80008e54:	c1 01       	brne	80008e74 <_dtoa_r+0x2a8>
80008e56:	c1 88       	rjmp	80008e86 <_dtoa_r+0x2ba>
80008e58:	40 cb       	lddsp	r11,sp[0x30]
80008e5a:	58 4b       	cp.w	r11,4
80008e5c:	c0 60       	breq	80008e68 <_dtoa_r+0x29c>
80008e5e:	58 5b       	cp.w	r11,5
80008e60:	c0 a1       	brne	80008e74 <_dtoa_r+0x2a8>
80008e62:	30 1a       	mov	r10,1
80008e64:	50 da       	stdsp	sp[0x34],r10
80008e66:	c2 28       	rjmp	80008eaa <_dtoa_r+0x2de>
80008e68:	30 19       	mov	r9,1
80008e6a:	50 d9       	stdsp	sp[0x34],r9
80008e6c:	c0 f8       	rjmp	80008e8a <_dtoa_r+0x2be>
80008e6e:	30 08       	mov	r8,0
80008e70:	30 14       	mov	r4,1
80008e72:	50 c8       	stdsp	sp[0x30],r8
80008e74:	3f f5       	mov	r5,-1
80008e76:	30 1c       	mov	r12,1
80008e78:	30 0b       	mov	r11,0
80008e7a:	50 95       	stdsp	sp[0x24],r5
80008e7c:	50 dc       	stdsp	sp[0x34],r12
80008e7e:	0a 91       	mov	r1,r5
80008e80:	31 28       	mov	r8,18
80008e82:	50 eb       	stdsp	sp[0x38],r11
80008e84:	c2 08       	rjmp	80008ec4 <_dtoa_r+0x2f8>
80008e86:	30 0a       	mov	r10,0
80008e88:	50 da       	stdsp	sp[0x34],r10
80008e8a:	40 e9       	lddsp	r9,sp[0x38]
80008e8c:	58 09       	cp.w	r9,0
80008e8e:	e0 89 00 07 	brgt	80008e9c <_dtoa_r+0x2d0>
80008e92:	30 18       	mov	r8,1
80008e94:	50 98       	stdsp	sp[0x24],r8
80008e96:	10 91       	mov	r1,r8
80008e98:	50 e8       	stdsp	sp[0x38],r8
80008e9a:	c1 58       	rjmp	80008ec4 <_dtoa_r+0x2f8>
80008e9c:	40 e5       	lddsp	r5,sp[0x38]
80008e9e:	50 95       	stdsp	sp[0x24],r5
80008ea0:	0a 91       	mov	r1,r5
80008ea2:	0a 98       	mov	r8,r5
80008ea4:	c1 08       	rjmp	80008ec4 <_dtoa_r+0x2f8>
80008ea6:	30 0c       	mov	r12,0
80008ea8:	50 dc       	stdsp	sp[0x34],r12
80008eaa:	40 eb       	lddsp	r11,sp[0x38]
80008eac:	ec 0b 00 0b 	add	r11,r6,r11
80008eb0:	50 9b       	stdsp	sp[0x24],r11
80008eb2:	16 98       	mov	r8,r11
80008eb4:	2f f8       	sub	r8,-1
80008eb6:	58 08       	cp.w	r8,0
80008eb8:	e0 89 00 05 	brgt	80008ec2 <_dtoa_r+0x2f6>
80008ebc:	10 91       	mov	r1,r8
80008ebe:	30 18       	mov	r8,1
80008ec0:	c0 28       	rjmp	80008ec4 <_dtoa_r+0x2f8>
80008ec2:	10 91       	mov	r1,r8
80008ec4:	30 09       	mov	r9,0
80008ec6:	6e 9a       	ld.w	r10,r7[0x24]
80008ec8:	95 19       	st.w	r10[0x4],r9
80008eca:	30 49       	mov	r9,4
80008ecc:	c0 68       	rjmp	80008ed8 <_dtoa_r+0x30c>
80008ece:	d7 03       	nop
80008ed0:	6a 1a       	ld.w	r10,r5[0x4]
80008ed2:	a1 79       	lsl	r9,0x1
80008ed4:	2f fa       	sub	r10,-1
80008ed6:	8b 1a       	st.w	r5[0x4],r10
80008ed8:	6e 95       	ld.w	r5,r7[0x24]
80008eda:	f2 ca ff ec 	sub	r10,r9,-20
80008ede:	10 3a       	cp.w	r10,r8
80008ee0:	fe 98 ff f8 	brls	80008ed0 <_dtoa_r+0x304>
80008ee4:	6a 1b       	ld.w	r11,r5[0x4]
80008ee6:	0e 9c       	mov	r12,r7
80008ee8:	e0 a0 09 44 	rcall	8000a170 <_Balloc>
80008eec:	58 e1       	cp.w	r1,14
80008eee:	5f 88       	srls	r8
80008ef0:	8b 0c       	st.w	r5[0x0],r12
80008ef2:	f1 e4 00 04 	and	r4,r8,r4
80008ef6:	6e 98       	ld.w	r8,r7[0x24]
80008ef8:	70 08       	ld.w	r8,r8[0x0]
80008efa:	50 88       	stdsp	sp[0x20],r8
80008efc:	e0 80 01 82 	breq	80009200 <_dtoa_r+0x634>
80008f00:	58 06       	cp.w	r6,0
80008f02:	e0 8a 00 43 	brle	80008f88 <_dtoa_r+0x3bc>
80008f06:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
80008f0a:	fe c8 c3 da 	sub	r8,pc,-15398
80008f0e:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
80008f12:	fa e5 00 18 	st.d	sp[24],r4
80008f16:	ec 04 14 04 	asr	r4,r6,0x4
80008f1a:	ed b4 00 04 	bld	r4,0x4
80008f1e:	c0 30       	breq	80008f24 <_dtoa_r+0x358>
80008f20:	30 25       	mov	r5,2
80008f22:	c1 08       	rjmp	80008f42 <_dtoa_r+0x376>
80008f24:	fe c8 c3 2c 	sub	r8,pc,-15572
80008f28:	f0 e8 00 20 	ld.d	r8,r8[32]
80008f2c:	fa ea 00 3c 	ld.d	r10,sp[60]
80008f30:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80008f34:	e0 a0 0f fa 	rcall	8000af28 <__avr32_f64_div>
80008f38:	30 35       	mov	r5,3
80008f3a:	14 98       	mov	r8,r10
80008f3c:	16 99       	mov	r9,r11
80008f3e:	fa e9 00 08 	st.d	sp[8],r8
80008f42:	fe cc c3 4a 	sub	r12,pc,-15542
80008f46:	50 a3       	stdsp	sp[0x28],r3
80008f48:	0c 93       	mov	r3,r6
80008f4a:	18 96       	mov	r6,r12
80008f4c:	c0 f8       	rjmp	80008f6a <_dtoa_r+0x39e>
80008f4e:	fa ea 00 18 	ld.d	r10,sp[24]
80008f52:	ed b4 00 00 	bld	r4,0x0
80008f56:	c0 81       	brne	80008f66 <_dtoa_r+0x39a>
80008f58:	ec e8 00 00 	ld.d	r8,r6[0]
80008f5c:	2f f5       	sub	r5,-1
80008f5e:	e0 a0 0c 9f 	rcall	8000a89c <__avr32_f64_mul>
80008f62:	fa eb 00 18 	st.d	sp[24],r10
80008f66:	a1 54       	asr	r4,0x1
80008f68:	2f 86       	sub	r6,-8
80008f6a:	58 04       	cp.w	r4,0
80008f6c:	cf 11       	brne	80008f4e <_dtoa_r+0x382>
80008f6e:	fa e8 00 18 	ld.d	r8,sp[24]
80008f72:	fa ea 00 08 	ld.d	r10,sp[8]
80008f76:	06 96       	mov	r6,r3
80008f78:	e0 a0 0f d8 	rcall	8000af28 <__avr32_f64_div>
80008f7c:	40 a3       	lddsp	r3,sp[0x28]
80008f7e:	14 98       	mov	r8,r10
80008f80:	16 99       	mov	r9,r11
80008f82:	fa e9 00 08 	st.d	sp[8],r8
80008f86:	c2 f8       	rjmp	80008fe4 <_dtoa_r+0x418>
80008f88:	ec 08 11 00 	rsub	r8,r6,0
80008f8c:	c0 31       	brne	80008f92 <_dtoa_r+0x3c6>
80008f8e:	30 25       	mov	r5,2
80008f90:	c2 a8       	rjmp	80008fe4 <_dtoa_r+0x418>
80008f92:	fe cc c3 9a 	sub	r12,pc,-15462
80008f96:	f0 04 14 04 	asr	r4,r8,0x4
80008f9a:	50 1c       	stdsp	sp[0x4],r12
80008f9c:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80008fa0:	fe c9 c4 70 	sub	r9,pc,-15248
80008fa4:	fa ea 00 3c 	ld.d	r10,sp[60]
80008fa8:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80008fac:	e0 a0 0c 78 	rcall	8000a89c <__avr32_f64_mul>
80008fb0:	40 1c       	lddsp	r12,sp[0x4]
80008fb2:	50 63       	stdsp	sp[0x18],r3
80008fb4:	30 25       	mov	r5,2
80008fb6:	0c 93       	mov	r3,r6
80008fb8:	fa eb 00 08 	st.d	sp[8],r10
80008fbc:	18 96       	mov	r6,r12
80008fbe:	c0 f8       	rjmp	80008fdc <_dtoa_r+0x410>
80008fc0:	fa ea 00 08 	ld.d	r10,sp[8]
80008fc4:	ed b4 00 00 	bld	r4,0x0
80008fc8:	c0 81       	brne	80008fd8 <_dtoa_r+0x40c>
80008fca:	ec e8 00 00 	ld.d	r8,r6[0]
80008fce:	2f f5       	sub	r5,-1
80008fd0:	e0 a0 0c 66 	rcall	8000a89c <__avr32_f64_mul>
80008fd4:	fa eb 00 08 	st.d	sp[8],r10
80008fd8:	a1 54       	asr	r4,0x1
80008fda:	2f 86       	sub	r6,-8
80008fdc:	58 04       	cp.w	r4,0
80008fde:	cf 11       	brne	80008fc0 <_dtoa_r+0x3f4>
80008fe0:	06 96       	mov	r6,r3
80008fe2:	40 63       	lddsp	r3,sp[0x18]
80008fe4:	41 4a       	lddsp	r10,sp[0x50]
80008fe6:	58 0a       	cp.w	r10,0
80008fe8:	c2 a0       	breq	8000903c <_dtoa_r+0x470>
80008fea:	fa e8 00 08 	ld.d	r8,sp[8]
80008fee:	58 01       	cp.w	r1,0
80008ff0:	5f 94       	srgt	r4
80008ff2:	fa e9 00 18 	st.d	sp[24],r8
80008ff6:	30 08       	mov	r8,0
80008ff8:	fc 19 3f f0 	movh	r9,0x3ff0
80008ffc:	fa ea 00 18 	ld.d	r10,sp[24]
80009000:	e0 a0 0f 60 	rcall	8000aec0 <__avr32_f64_cmp_lt>
80009004:	f9 bc 00 00 	moveq	r12,0
80009008:	f9 bc 01 01 	movne	r12,1
8000900c:	e9 ec 00 0c 	and	r12,r4,r12
80009010:	c1 60       	breq	8000903c <_dtoa_r+0x470>
80009012:	40 98       	lddsp	r8,sp[0x24]
80009014:	58 08       	cp.w	r8,0
80009016:	e0 8a 00 f1 	brle	800091f8 <_dtoa_r+0x62c>
8000901a:	30 08       	mov	r8,0
8000901c:	fc 19 40 24 	movh	r9,0x4024
80009020:	ec c4 00 01 	sub	r4,r6,1
80009024:	fa ea 00 18 	ld.d	r10,sp[24]
80009028:	2f f5       	sub	r5,-1
8000902a:	50 64       	stdsp	sp[0x18],r4
8000902c:	e0 a0 0c 38 	rcall	8000a89c <__avr32_f64_mul>
80009030:	40 94       	lddsp	r4,sp[0x24]
80009032:	14 98       	mov	r8,r10
80009034:	16 99       	mov	r9,r11
80009036:	fa e9 00 08 	st.d	sp[8],r8
8000903a:	c0 38       	rjmp	80009040 <_dtoa_r+0x474>
8000903c:	50 66       	stdsp	sp[0x18],r6
8000903e:	02 94       	mov	r4,r1
80009040:	0a 9c       	mov	r12,r5
80009042:	e0 a0 0e 88 	rcall	8000ad52 <__avr32_s32_to_f64>
80009046:	fa e8 00 08 	ld.d	r8,sp[8]
8000904a:	e0 a0 0c 29 	rcall	8000a89c <__avr32_f64_mul>
8000904e:	30 08       	mov	r8,0
80009050:	fc 19 40 1c 	movh	r9,0x401c
80009054:	e0 a0 0d de 	rcall	8000ac10 <__avr32_f64_add>
80009058:	14 98       	mov	r8,r10
8000905a:	16 99       	mov	r9,r11
8000905c:	fa e9 00 28 	st.d	sp[40],r8
80009060:	fc 18 fc c0 	movh	r8,0xfcc0
80009064:	40 a5       	lddsp	r5,sp[0x28]
80009066:	10 05       	add	r5,r8
80009068:	50 a5       	stdsp	sp[0x28],r5
8000906a:	58 04       	cp.w	r4,0
8000906c:	c2 11       	brne	800090ae <_dtoa_r+0x4e2>
8000906e:	fa ea 00 08 	ld.d	r10,sp[8]
80009072:	30 08       	mov	r8,0
80009074:	fc 19 40 14 	movh	r9,0x4014
80009078:	e0 a0 0c fe 	rcall	8000aa74 <__avr32_f64_sub>
8000907c:	40 bc       	lddsp	r12,sp[0x2c]
8000907e:	fa eb 00 08 	st.d	sp[8],r10
80009082:	14 98       	mov	r8,r10
80009084:	16 99       	mov	r9,r11
80009086:	18 9a       	mov	r10,r12
80009088:	0a 9b       	mov	r11,r5
8000908a:	e0 a0 0f 1b 	rcall	8000aec0 <__avr32_f64_cmp_lt>
8000908e:	e0 81 02 54 	brne	80009536 <_dtoa_r+0x96a>
80009092:	0a 98       	mov	r8,r5
80009094:	40 b9       	lddsp	r9,sp[0x2c]
80009096:	ee 18 80 00 	eorh	r8,0x8000
8000909a:	fa ea 00 08 	ld.d	r10,sp[8]
8000909e:	10 95       	mov	r5,r8
800090a0:	12 98       	mov	r8,r9
800090a2:	0a 99       	mov	r9,r5
800090a4:	e0 a0 0f 0e 	rcall	8000aec0 <__avr32_f64_cmp_lt>
800090a8:	e0 81 02 3e 	brne	80009524 <_dtoa_r+0x958>
800090ac:	ca 68       	rjmp	800091f8 <_dtoa_r+0x62c>
800090ae:	fe c9 c5 7e 	sub	r9,pc,-14978
800090b2:	e8 c8 00 01 	sub	r8,r4,1
800090b6:	40 d5       	lddsp	r5,sp[0x34]
800090b8:	58 05       	cp.w	r5,0
800090ba:	c4 f0       	breq	80009158 <_dtoa_r+0x58c>
800090bc:	30 0c       	mov	r12,0
800090be:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
800090c2:	51 3c       	stdsp	sp[0x4c],r12
800090c4:	30 0a       	mov	r10,0
800090c6:	fc 1b 3f e0 	movh	r11,0x3fe0
800090ca:	e0 a0 0f 2f 	rcall	8000af28 <__avr32_f64_div>
800090ce:	fa e8 00 28 	ld.d	r8,sp[40]
800090d2:	40 85       	lddsp	r5,sp[0x20]
800090d4:	e0 a0 0c d0 	rcall	8000aa74 <__avr32_f64_sub>
800090d8:	fa eb 00 28 	st.d	sp[40],r10
800090dc:	fa ea 00 08 	ld.d	r10,sp[8]
800090e0:	e0 a0 0e 22 	rcall	8000ad24 <__avr32_f64_to_s32>
800090e4:	51 6c       	stdsp	sp[0x58],r12
800090e6:	e0 a0 0e 36 	rcall	8000ad52 <__avr32_s32_to_f64>
800090ea:	14 98       	mov	r8,r10
800090ec:	16 99       	mov	r9,r11
800090ee:	fa ea 00 08 	ld.d	r10,sp[8]
800090f2:	e0 a0 0c c1 	rcall	8000aa74 <__avr32_f64_sub>
800090f6:	fa eb 00 08 	st.d	sp[8],r10
800090fa:	41 68       	lddsp	r8,sp[0x58]
800090fc:	2d 08       	sub	r8,-48
800090fe:	0a c8       	st.b	r5++,r8
80009100:	41 39       	lddsp	r9,sp[0x4c]
80009102:	2f f9       	sub	r9,-1
80009104:	51 39       	stdsp	sp[0x4c],r9
80009106:	fa e8 00 28 	ld.d	r8,sp[40]
8000910a:	e0 a0 0e db 	rcall	8000aec0 <__avr32_f64_cmp_lt>
8000910e:	e0 81 03 39 	brne	80009780 <_dtoa_r+0xbb4>
80009112:	fa e8 00 08 	ld.d	r8,sp[8]
80009116:	30 0a       	mov	r10,0
80009118:	fc 1b 3f f0 	movh	r11,0x3ff0
8000911c:	e0 a0 0c ac 	rcall	8000aa74 <__avr32_f64_sub>
80009120:	fa e8 00 28 	ld.d	r8,sp[40]
80009124:	e0 a0 0e ce 	rcall	8000aec0 <__avr32_f64_cmp_lt>
80009128:	fa ea 00 28 	ld.d	r10,sp[40]
8000912c:	30 08       	mov	r8,0
8000912e:	fc 19 40 24 	movh	r9,0x4024
80009132:	e0 81 00 da 	brne	800092e6 <_dtoa_r+0x71a>
80009136:	41 3c       	lddsp	r12,sp[0x4c]
80009138:	08 3c       	cp.w	r12,r4
8000913a:	c5 f4       	brge	800091f8 <_dtoa_r+0x62c>
8000913c:	e0 a0 0b b0 	rcall	8000a89c <__avr32_f64_mul>
80009140:	30 08       	mov	r8,0
80009142:	fa eb 00 28 	st.d	sp[40],r10
80009146:	fc 19 40 24 	movh	r9,0x4024
8000914a:	fa ea 00 08 	ld.d	r10,sp[8]
8000914e:	e0 a0 0b a7 	rcall	8000a89c <__avr32_f64_mul>
80009152:	fa eb 00 08 	st.d	sp[8],r10
80009156:	cc 3b       	rjmp	800090dc <_dtoa_r+0x510>
80009158:	40 85       	lddsp	r5,sp[0x20]
8000915a:	08 05       	add	r5,r4
8000915c:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80009160:	51 35       	stdsp	sp[0x4c],r5
80009162:	fa e8 00 28 	ld.d	r8,sp[40]
80009166:	40 85       	lddsp	r5,sp[0x20]
80009168:	e0 a0 0b 9a 	rcall	8000a89c <__avr32_f64_mul>
8000916c:	fa eb 00 28 	st.d	sp[40],r10
80009170:	fa ea 00 08 	ld.d	r10,sp[8]
80009174:	e0 a0 0d d8 	rcall	8000ad24 <__avr32_f64_to_s32>
80009178:	51 6c       	stdsp	sp[0x58],r12
8000917a:	e0 a0 0d ec 	rcall	8000ad52 <__avr32_s32_to_f64>
8000917e:	14 98       	mov	r8,r10
80009180:	16 99       	mov	r9,r11
80009182:	fa ea 00 08 	ld.d	r10,sp[8]
80009186:	e0 a0 0c 77 	rcall	8000aa74 <__avr32_f64_sub>
8000918a:	fa eb 00 08 	st.d	sp[8],r10
8000918e:	41 68       	lddsp	r8,sp[0x58]
80009190:	2d 08       	sub	r8,-48
80009192:	0a c8       	st.b	r5++,r8
80009194:	41 3c       	lddsp	r12,sp[0x4c]
80009196:	18 35       	cp.w	r5,r12
80009198:	c2 81       	brne	800091e8 <_dtoa_r+0x61c>
8000919a:	30 08       	mov	r8,0
8000919c:	fc 19 3f e0 	movh	r9,0x3fe0
800091a0:	fa ea 00 28 	ld.d	r10,sp[40]
800091a4:	e0 a0 0d 36 	rcall	8000ac10 <__avr32_f64_add>
800091a8:	40 85       	lddsp	r5,sp[0x20]
800091aa:	fa e8 00 08 	ld.d	r8,sp[8]
800091ae:	08 05       	add	r5,r4
800091b0:	e0 a0 0e 88 	rcall	8000aec0 <__avr32_f64_cmp_lt>
800091b4:	e0 81 00 99 	brne	800092e6 <_dtoa_r+0x71a>
800091b8:	fa e8 00 28 	ld.d	r8,sp[40]
800091bc:	30 0a       	mov	r10,0
800091be:	fc 1b 3f e0 	movh	r11,0x3fe0
800091c2:	e0 a0 0c 59 	rcall	8000aa74 <__avr32_f64_sub>
800091c6:	14 98       	mov	r8,r10
800091c8:	16 99       	mov	r9,r11
800091ca:	fa ea 00 08 	ld.d	r10,sp[8]
800091ce:	e0 a0 0e 79 	rcall	8000aec0 <__avr32_f64_cmp_lt>
800091d2:	c1 30       	breq	800091f8 <_dtoa_r+0x62c>
800091d4:	33 09       	mov	r9,48
800091d6:	0a 98       	mov	r8,r5
800091d8:	11 7a       	ld.ub	r10,--r8
800091da:	f2 0a 18 00 	cp.b	r10,r9
800091de:	e0 81 02 d1 	brne	80009780 <_dtoa_r+0xbb4>
800091e2:	10 95       	mov	r5,r8
800091e4:	cf 9b       	rjmp	800091d6 <_dtoa_r+0x60a>
800091e6:	d7 03       	nop
800091e8:	30 08       	mov	r8,0
800091ea:	fc 19 40 24 	movh	r9,0x4024
800091ee:	e0 a0 0b 57 	rcall	8000a89c <__avr32_f64_mul>
800091f2:	fa eb 00 08 	st.d	sp[8],r10
800091f6:	cb db       	rjmp	80009170 <_dtoa_r+0x5a4>
800091f8:	fa ea 00 3c 	ld.d	r10,sp[60]
800091fc:	fa eb 00 08 	st.d	sp[8],r10
80009200:	58 e6       	cp.w	r6,14
80009202:	5f ab       	srle	r11
80009204:	41 8a       	lddsp	r10,sp[0x60]
80009206:	30 08       	mov	r8,0
80009208:	f4 09 11 ff 	rsub	r9,r10,-1
8000920c:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
80009210:	f0 09 18 00 	cp.b	r9,r8
80009214:	e0 80 00 82 	breq	80009318 <_dtoa_r+0x74c>
80009218:	40 ea       	lddsp	r10,sp[0x38]
8000921a:	58 01       	cp.w	r1,0
8000921c:	5f a9       	srle	r9
8000921e:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
80009222:	fe ca c6 f2 	sub	r10,pc,-14606
80009226:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000922a:	fa e5 00 10 	st.d	sp[16],r4
8000922e:	f0 09 18 00 	cp.b	r9,r8
80009232:	c1 40       	breq	8000925a <_dtoa_r+0x68e>
80009234:	58 01       	cp.w	r1,0
80009236:	e0 81 01 77 	brne	80009524 <_dtoa_r+0x958>
8000923a:	30 08       	mov	r8,0
8000923c:	fc 19 40 14 	movh	r9,0x4014
80009240:	08 9a       	mov	r10,r4
80009242:	0a 9b       	mov	r11,r5
80009244:	e0 a0 0b 2c 	rcall	8000a89c <__avr32_f64_mul>
80009248:	fa e8 00 08 	ld.d	r8,sp[8]
8000924c:	e0 a0 0e 06 	rcall	8000ae58 <__avr32_f64_cmp_ge>
80009250:	e0 81 01 6a 	brne	80009524 <_dtoa_r+0x958>
80009254:	02 92       	mov	r2,r1
80009256:	e0 8f 01 72 	bral	8000953a <_dtoa_r+0x96e>
8000925a:	40 85       	lddsp	r5,sp[0x20]
8000925c:	30 14       	mov	r4,1
8000925e:	fa e8 00 10 	ld.d	r8,sp[16]
80009262:	fa ea 00 08 	ld.d	r10,sp[8]
80009266:	e0 a0 0e 61 	rcall	8000af28 <__avr32_f64_div>
8000926a:	e0 a0 0d 5d 	rcall	8000ad24 <__avr32_f64_to_s32>
8000926e:	18 92       	mov	r2,r12
80009270:	e0 a0 0d 71 	rcall	8000ad52 <__avr32_s32_to_f64>
80009274:	fa e8 00 10 	ld.d	r8,sp[16]
80009278:	e0 a0 0b 12 	rcall	8000a89c <__avr32_f64_mul>
8000927c:	14 98       	mov	r8,r10
8000927e:	16 99       	mov	r9,r11
80009280:	fa ea 00 08 	ld.d	r10,sp[8]
80009284:	e0 a0 0b f8 	rcall	8000aa74 <__avr32_f64_sub>
80009288:	fa eb 00 08 	st.d	sp[8],r10
8000928c:	e4 c8 ff d0 	sub	r8,r2,-48
80009290:	0a c8       	st.b	r5++,r8
80009292:	fc 19 40 24 	movh	r9,0x4024
80009296:	30 08       	mov	r8,0
80009298:	02 34       	cp.w	r4,r1
8000929a:	c3 31       	brne	80009300 <_dtoa_r+0x734>
8000929c:	fa e8 00 08 	ld.d	r8,sp[8]
800092a0:	e0 a0 0c b8 	rcall	8000ac10 <__avr32_f64_add>
800092a4:	16 91       	mov	r1,r11
800092a6:	14 90       	mov	r0,r10
800092a8:	14 98       	mov	r8,r10
800092aa:	02 99       	mov	r9,r1
800092ac:	fa ea 00 10 	ld.d	r10,sp[16]
800092b0:	e0 a0 0e 08 	rcall	8000aec0 <__avr32_f64_cmp_lt>
800092b4:	c1 a1       	brne	800092e8 <_dtoa_r+0x71c>
800092b6:	fa e8 00 10 	ld.d	r8,sp[16]
800092ba:	00 9a       	mov	r10,r0
800092bc:	02 9b       	mov	r11,r1
800092be:	e0 a0 0d ba 	rcall	8000ae32 <__avr32_f64_cmp_eq>
800092c2:	e0 80 02 5e 	breq	8000977e <_dtoa_r+0xbb2>
800092c6:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
800092ca:	c0 f1       	brne	800092e8 <_dtoa_r+0x71c>
800092cc:	e0 8f 02 59 	bral	8000977e <_dtoa_r+0xbb2>
800092d0:	40 8a       	lddsp	r10,sp[0x20]
800092d2:	14 38       	cp.w	r8,r10
800092d4:	c0 30       	breq	800092da <_dtoa_r+0x70e>
800092d6:	10 95       	mov	r5,r8
800092d8:	c0 98       	rjmp	800092ea <_dtoa_r+0x71e>
800092da:	33 08       	mov	r8,48
800092dc:	40 89       	lddsp	r9,sp[0x20]
800092de:	2f f6       	sub	r6,-1
800092e0:	b2 88       	st.b	r9[0x0],r8
800092e2:	40 88       	lddsp	r8,sp[0x20]
800092e4:	c0 88       	rjmp	800092f4 <_dtoa_r+0x728>
800092e6:	40 66       	lddsp	r6,sp[0x18]
800092e8:	33 99       	mov	r9,57
800092ea:	0a 98       	mov	r8,r5
800092ec:	11 7a       	ld.ub	r10,--r8
800092ee:	f2 0a 18 00 	cp.b	r10,r9
800092f2:	ce f0       	breq	800092d0 <_dtoa_r+0x704>
800092f4:	50 66       	stdsp	sp[0x18],r6
800092f6:	11 89       	ld.ub	r9,r8[0x0]
800092f8:	2f f9       	sub	r9,-1
800092fa:	b0 89       	st.b	r8[0x0],r9
800092fc:	e0 8f 02 42 	bral	80009780 <_dtoa_r+0xbb4>
80009300:	e0 a0 0a ce 	rcall	8000a89c <__avr32_f64_mul>
80009304:	2f f4       	sub	r4,-1
80009306:	fa eb 00 08 	st.d	sp[8],r10
8000930a:	30 08       	mov	r8,0
8000930c:	30 09       	mov	r9,0
8000930e:	e0 a0 0d 92 	rcall	8000ae32 <__avr32_f64_cmp_eq>
80009312:	ca 60       	breq	8000925e <_dtoa_r+0x692>
80009314:	e0 8f 02 35 	bral	8000977e <_dtoa_r+0xbb2>
80009318:	40 d8       	lddsp	r8,sp[0x34]
8000931a:	58 08       	cp.w	r8,0
8000931c:	c0 51       	brne	80009326 <_dtoa_r+0x75a>
8000931e:	04 98       	mov	r8,r2
80009320:	00 95       	mov	r5,r0
80009322:	40 d4       	lddsp	r4,sp[0x34]
80009324:	c3 78       	rjmp	80009392 <_dtoa_r+0x7c6>
80009326:	40 c5       	lddsp	r5,sp[0x30]
80009328:	58 15       	cp.w	r5,1
8000932a:	e0 89 00 0f 	brgt	80009348 <_dtoa_r+0x77c>
8000932e:	41 74       	lddsp	r4,sp[0x5c]
80009330:	58 04       	cp.w	r4,0
80009332:	c0 40       	breq	8000933a <_dtoa_r+0x76e>
80009334:	f4 c9 fb cd 	sub	r9,r10,-1075
80009338:	c0 48       	rjmp	80009340 <_dtoa_r+0x774>
8000933a:	41 99       	lddsp	r9,sp[0x64]
8000933c:	f2 09 11 36 	rsub	r9,r9,54
80009340:	04 98       	mov	r8,r2
80009342:	00 95       	mov	r5,r0
80009344:	c1 c8       	rjmp	8000937c <_dtoa_r+0x7b0>
80009346:	d7 03       	nop
80009348:	e2 c8 00 01 	sub	r8,r1,1
8000934c:	58 01       	cp.w	r1,0
8000934e:	e0 05 17 40 	movge	r5,r0
80009352:	e2 09 17 40 	movge	r9,r1
80009356:	e1 d1 e5 15 	sublt	r5,r0,r1
8000935a:	f9 b9 05 00 	movlt	r9,0
8000935e:	10 32       	cp.w	r2,r8
80009360:	e5 d8 e4 18 	subge	r8,r2,r8
80009364:	f1 d2 e5 18 	sublt	r8,r8,r2
80009368:	e5 d8 e5 02 	addlt	r2,r2,r8
8000936c:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
80009370:	f9 d8 e5 0c 	addlt	r12,r12,r8
80009374:	fb fc 5a 11 	st.wlt	sp[0x44],r12
80009378:	f9 b8 05 00 	movlt	r8,0
8000937c:	40 4b       	lddsp	r11,sp[0x10]
8000937e:	12 0b       	add	r11,r9
80009380:	50 08       	stdsp	sp[0x0],r8
80009382:	50 4b       	stdsp	sp[0x10],r11
80009384:	12 00       	add	r0,r9
80009386:	30 1b       	mov	r11,1
80009388:	0e 9c       	mov	r12,r7
8000938a:	e0 a0 08 a7 	rcall	8000a4d8 <__i2b>
8000938e:	40 08       	lddsp	r8,sp[0x0]
80009390:	18 94       	mov	r4,r12
80009392:	40 4a       	lddsp	r10,sp[0x10]
80009394:	58 05       	cp.w	r5,0
80009396:	5f 99       	srgt	r9
80009398:	58 0a       	cp.w	r10,0
8000939a:	5f 9a       	srgt	r10
8000939c:	f5 e9 00 09 	and	r9,r10,r9
800093a0:	c0 80       	breq	800093b0 <_dtoa_r+0x7e4>
800093a2:	40 4c       	lddsp	r12,sp[0x10]
800093a4:	f8 05 0d 49 	min	r9,r12,r5
800093a8:	12 1c       	sub	r12,r9
800093aa:	12 10       	sub	r0,r9
800093ac:	50 4c       	stdsp	sp[0x10],r12
800093ae:	12 15       	sub	r5,r9
800093b0:	58 02       	cp.w	r2,0
800093b2:	e0 8a 00 27 	brle	80009400 <_dtoa_r+0x834>
800093b6:	40 db       	lddsp	r11,sp[0x34]
800093b8:	58 0b       	cp.w	r11,0
800093ba:	c1 d0       	breq	800093f4 <_dtoa_r+0x828>
800093bc:	58 08       	cp.w	r8,0
800093be:	e0 8a 00 17 	brle	800093ec <_dtoa_r+0x820>
800093c2:	10 9a       	mov	r10,r8
800093c4:	50 08       	stdsp	sp[0x0],r8
800093c6:	08 9b       	mov	r11,r4
800093c8:	0e 9c       	mov	r12,r7
800093ca:	e0 a0 08 cd 	rcall	8000a564 <__pow5mult>
800093ce:	06 9a       	mov	r10,r3
800093d0:	18 9b       	mov	r11,r12
800093d2:	18 94       	mov	r4,r12
800093d4:	0e 9c       	mov	r12,r7
800093d6:	e0 a0 08 01 	rcall	8000a3d8 <__multiply>
800093da:	18 99       	mov	r9,r12
800093dc:	06 9b       	mov	r11,r3
800093de:	50 19       	stdsp	sp[0x4],r9
800093e0:	0e 9c       	mov	r12,r7
800093e2:	e0 a0 06 ad 	rcall	8000a13c <_Bfree>
800093e6:	40 19       	lddsp	r9,sp[0x4]
800093e8:	40 08       	lddsp	r8,sp[0x0]
800093ea:	12 93       	mov	r3,r9
800093ec:	e4 08 01 0a 	sub	r10,r2,r8
800093f0:	c0 80       	breq	80009400 <_dtoa_r+0x834>
800093f2:	c0 28       	rjmp	800093f6 <_dtoa_r+0x82a>
800093f4:	04 9a       	mov	r10,r2
800093f6:	06 9b       	mov	r11,r3
800093f8:	0e 9c       	mov	r12,r7
800093fa:	e0 a0 08 b5 	rcall	8000a564 <__pow5mult>
800093fe:	18 93       	mov	r3,r12
80009400:	30 1b       	mov	r11,1
80009402:	0e 9c       	mov	r12,r7
80009404:	e0 a0 08 6a 	rcall	8000a4d8 <__i2b>
80009408:	41 1a       	lddsp	r10,sp[0x44]
8000940a:	18 92       	mov	r2,r12
8000940c:	58 0a       	cp.w	r10,0
8000940e:	e0 8a 00 07 	brle	8000941c <_dtoa_r+0x850>
80009412:	18 9b       	mov	r11,r12
80009414:	0e 9c       	mov	r12,r7
80009416:	e0 a0 08 a7 	rcall	8000a564 <__pow5mult>
8000941a:	18 92       	mov	r2,r12
8000941c:	40 c9       	lddsp	r9,sp[0x30]
8000941e:	58 19       	cp.w	r9,1
80009420:	e0 89 00 14 	brgt	80009448 <_dtoa_r+0x87c>
80009424:	40 38       	lddsp	r8,sp[0xc]
80009426:	58 08       	cp.w	r8,0
80009428:	c1 01       	brne	80009448 <_dtoa_r+0x87c>
8000942a:	40 29       	lddsp	r9,sp[0x8]
8000942c:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
80009430:	c0 c1       	brne	80009448 <_dtoa_r+0x87c>
80009432:	12 98       	mov	r8,r9
80009434:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009438:	c0 80       	breq	80009448 <_dtoa_r+0x87c>
8000943a:	40 4c       	lddsp	r12,sp[0x10]
8000943c:	30 1b       	mov	r11,1
8000943e:	2f fc       	sub	r12,-1
80009440:	2f f0       	sub	r0,-1
80009442:	50 4c       	stdsp	sp[0x10],r12
80009444:	50 6b       	stdsp	sp[0x18],r11
80009446:	c0 38       	rjmp	8000944c <_dtoa_r+0x880>
80009448:	30 0a       	mov	r10,0
8000944a:	50 6a       	stdsp	sp[0x18],r10
8000944c:	41 19       	lddsp	r9,sp[0x44]
8000944e:	58 09       	cp.w	r9,0
80009450:	c0 31       	brne	80009456 <_dtoa_r+0x88a>
80009452:	30 1c       	mov	r12,1
80009454:	c0 98       	rjmp	80009466 <_dtoa_r+0x89a>
80009456:	64 48       	ld.w	r8,r2[0x10]
80009458:	2f c8       	sub	r8,-4
8000945a:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000945e:	e0 a0 05 df 	rcall	8000a01c <__hi0bits>
80009462:	f8 0c 11 20 	rsub	r12,r12,32
80009466:	40 4b       	lddsp	r11,sp[0x10]
80009468:	f8 0b 00 08 	add	r8,r12,r11
8000946c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80009470:	c0 c0       	breq	80009488 <_dtoa_r+0x8bc>
80009472:	f0 08 11 20 	rsub	r8,r8,32
80009476:	58 48       	cp.w	r8,4
80009478:	e0 8a 00 06 	brle	80009484 <_dtoa_r+0x8b8>
8000947c:	20 48       	sub	r8,4
8000947e:	10 0b       	add	r11,r8
80009480:	50 4b       	stdsp	sp[0x10],r11
80009482:	c0 78       	rjmp	80009490 <_dtoa_r+0x8c4>
80009484:	58 48       	cp.w	r8,4
80009486:	c0 70       	breq	80009494 <_dtoa_r+0x8c8>
80009488:	40 4a       	lddsp	r10,sp[0x10]
8000948a:	2e 48       	sub	r8,-28
8000948c:	10 0a       	add	r10,r8
8000948e:	50 4a       	stdsp	sp[0x10],r10
80009490:	10 00       	add	r0,r8
80009492:	10 05       	add	r5,r8
80009494:	58 00       	cp.w	r0,0
80009496:	e0 8a 00 08 	brle	800094a6 <_dtoa_r+0x8da>
8000949a:	06 9b       	mov	r11,r3
8000949c:	00 9a       	mov	r10,r0
8000949e:	0e 9c       	mov	r12,r7
800094a0:	e0 a0 07 58 	rcall	8000a350 <__lshift>
800094a4:	18 93       	mov	r3,r12
800094a6:	40 49       	lddsp	r9,sp[0x10]
800094a8:	58 09       	cp.w	r9,0
800094aa:	e0 8a 00 08 	brle	800094ba <_dtoa_r+0x8ee>
800094ae:	04 9b       	mov	r11,r2
800094b0:	12 9a       	mov	r10,r9
800094b2:	0e 9c       	mov	r12,r7
800094b4:	e0 a0 07 4e 	rcall	8000a350 <__lshift>
800094b8:	18 92       	mov	r2,r12
800094ba:	41 48       	lddsp	r8,sp[0x50]
800094bc:	58 08       	cp.w	r8,0
800094be:	c1 b0       	breq	800094f4 <_dtoa_r+0x928>
800094c0:	04 9b       	mov	r11,r2
800094c2:	06 9c       	mov	r12,r3
800094c4:	e0 a0 06 23 	rcall	8000a10a <__mcmp>
800094c8:	c1 64       	brge	800094f4 <_dtoa_r+0x928>
800094ca:	06 9b       	mov	r11,r3
800094cc:	30 09       	mov	r9,0
800094ce:	30 aa       	mov	r10,10
800094d0:	0e 9c       	mov	r12,r7
800094d2:	e0 a0 08 0b 	rcall	8000a4e8 <__multadd>
800094d6:	20 16       	sub	r6,1
800094d8:	18 93       	mov	r3,r12
800094da:	40 dc       	lddsp	r12,sp[0x34]
800094dc:	58 0c       	cp.w	r12,0
800094de:	c0 31       	brne	800094e4 <_dtoa_r+0x918>
800094e0:	40 91       	lddsp	r1,sp[0x24]
800094e2:	c0 98       	rjmp	800094f4 <_dtoa_r+0x928>
800094e4:	08 9b       	mov	r11,r4
800094e6:	40 91       	lddsp	r1,sp[0x24]
800094e8:	30 09       	mov	r9,0
800094ea:	30 aa       	mov	r10,10
800094ec:	0e 9c       	mov	r12,r7
800094ee:	e0 a0 07 fd 	rcall	8000a4e8 <__multadd>
800094f2:	18 94       	mov	r4,r12
800094f4:	58 01       	cp.w	r1,0
800094f6:	5f a9       	srle	r9
800094f8:	40 cb       	lddsp	r11,sp[0x30]
800094fa:	58 2b       	cp.w	r11,2
800094fc:	5f 98       	srgt	r8
800094fe:	f3 e8 00 08 	and	r8,r9,r8
80009502:	c2 50       	breq	8000954c <_dtoa_r+0x980>
80009504:	58 01       	cp.w	r1,0
80009506:	c1 11       	brne	80009528 <_dtoa_r+0x95c>
80009508:	04 9b       	mov	r11,r2
8000950a:	02 99       	mov	r9,r1
8000950c:	30 5a       	mov	r10,5
8000950e:	0e 9c       	mov	r12,r7
80009510:	e0 a0 07 ec 	rcall	8000a4e8 <__multadd>
80009514:	18 92       	mov	r2,r12
80009516:	18 9b       	mov	r11,r12
80009518:	06 9c       	mov	r12,r3
8000951a:	e0 a0 05 f8 	rcall	8000a10a <__mcmp>
8000951e:	e0 89 00 0f 	brgt	8000953c <_dtoa_r+0x970>
80009522:	c0 38       	rjmp	80009528 <_dtoa_r+0x95c>
80009524:	30 02       	mov	r2,0
80009526:	04 94       	mov	r4,r2
80009528:	40 ea       	lddsp	r10,sp[0x38]
8000952a:	30 09       	mov	r9,0
8000952c:	5c da       	com	r10
8000952e:	40 85       	lddsp	r5,sp[0x20]
80009530:	50 6a       	stdsp	sp[0x18],r10
80009532:	50 49       	stdsp	sp[0x10],r9
80009534:	c0 f9       	rjmp	80009752 <_dtoa_r+0xb86>
80009536:	08 92       	mov	r2,r4
80009538:	40 66       	lddsp	r6,sp[0x18]
8000953a:	04 94       	mov	r4,r2
8000953c:	2f f6       	sub	r6,-1
8000953e:	50 66       	stdsp	sp[0x18],r6
80009540:	33 18       	mov	r8,49
80009542:	40 85       	lddsp	r5,sp[0x20]
80009544:	0a c8       	st.b	r5++,r8
80009546:	30 08       	mov	r8,0
80009548:	50 48       	stdsp	sp[0x10],r8
8000954a:	c0 49       	rjmp	80009752 <_dtoa_r+0xb86>
8000954c:	40 dc       	lddsp	r12,sp[0x34]
8000954e:	58 0c       	cp.w	r12,0
80009550:	e0 80 00 b5 	breq	800096ba <_dtoa_r+0xaee>
80009554:	58 05       	cp.w	r5,0
80009556:	e0 8a 00 08 	brle	80009566 <_dtoa_r+0x99a>
8000955a:	08 9b       	mov	r11,r4
8000955c:	0a 9a       	mov	r10,r5
8000955e:	0e 9c       	mov	r12,r7
80009560:	e0 a0 06 f8 	rcall	8000a350 <__lshift>
80009564:	18 94       	mov	r4,r12
80009566:	40 6b       	lddsp	r11,sp[0x18]
80009568:	58 0b       	cp.w	r11,0
8000956a:	c0 31       	brne	80009570 <_dtoa_r+0x9a4>
8000956c:	08 9c       	mov	r12,r4
8000956e:	c1 38       	rjmp	80009594 <_dtoa_r+0x9c8>
80009570:	68 1b       	ld.w	r11,r4[0x4]
80009572:	0e 9c       	mov	r12,r7
80009574:	e0 a0 05 fe 	rcall	8000a170 <_Balloc>
80009578:	68 4a       	ld.w	r10,r4[0x10]
8000957a:	18 95       	mov	r5,r12
8000957c:	e8 cb ff f4 	sub	r11,r4,-12
80009580:	2f ea       	sub	r10,-2
80009582:	2f 4c       	sub	r12,-12
80009584:	a3 6a       	lsl	r10,0x2
80009586:	fe b0 e6 50 	rcall	80006226 <memcpy>
8000958a:	0a 9b       	mov	r11,r5
8000958c:	30 1a       	mov	r10,1
8000958e:	0e 9c       	mov	r12,r7
80009590:	e0 a0 06 e0 	rcall	8000a350 <__lshift>
80009594:	50 44       	stdsp	sp[0x10],r4
80009596:	40 3a       	lddsp	r10,sp[0xc]
80009598:	30 19       	mov	r9,1
8000959a:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000959e:	18 94       	mov	r4,r12
800095a0:	50 da       	stdsp	sp[0x34],r10
800095a2:	40 85       	lddsp	r5,sp[0x20]
800095a4:	50 99       	stdsp	sp[0x24],r9
800095a6:	50 26       	stdsp	sp[0x8],r6
800095a8:	50 e1       	stdsp	sp[0x38],r1
800095aa:	04 9b       	mov	r11,r2
800095ac:	06 9c       	mov	r12,r3
800095ae:	fe b0 fa 7f 	rcall	80008aac <quorem>
800095b2:	40 4b       	lddsp	r11,sp[0x10]
800095b4:	f8 c0 ff d0 	sub	r0,r12,-48
800095b8:	06 9c       	mov	r12,r3
800095ba:	e0 a0 05 a8 	rcall	8000a10a <__mcmp>
800095be:	08 9a       	mov	r10,r4
800095c0:	50 6c       	stdsp	sp[0x18],r12
800095c2:	04 9b       	mov	r11,r2
800095c4:	0e 9c       	mov	r12,r7
800095c6:	e0 a0 06 5d 	rcall	8000a280 <__mdiff>
800095ca:	18 91       	mov	r1,r12
800095cc:	78 38       	ld.w	r8,r12[0xc]
800095ce:	58 08       	cp.w	r8,0
800095d0:	c0 30       	breq	800095d6 <_dtoa_r+0xa0a>
800095d2:	30 16       	mov	r6,1
800095d4:	c0 68       	rjmp	800095e0 <_dtoa_r+0xa14>
800095d6:	18 9b       	mov	r11,r12
800095d8:	06 9c       	mov	r12,r3
800095da:	e0 a0 05 98 	rcall	8000a10a <__mcmp>
800095de:	18 96       	mov	r6,r12
800095e0:	0e 9c       	mov	r12,r7
800095e2:	02 9b       	mov	r11,r1
800095e4:	e0 a0 05 ac 	rcall	8000a13c <_Bfree>
800095e8:	40 cc       	lddsp	r12,sp[0x30]
800095ea:	ed ec 10 08 	or	r8,r6,r12
800095ee:	c0 d1       	brne	80009608 <_dtoa_r+0xa3c>
800095f0:	40 db       	lddsp	r11,sp[0x34]
800095f2:	58 0b       	cp.w	r11,0
800095f4:	c0 a1       	brne	80009608 <_dtoa_r+0xa3c>
800095f6:	40 26       	lddsp	r6,sp[0x8]
800095f8:	e0 40 00 39 	cp.w	r0,57
800095fc:	c3 00       	breq	8000965c <_dtoa_r+0xa90>
800095fe:	40 6a       	lddsp	r10,sp[0x18]
80009600:	58 0a       	cp.w	r10,0
80009602:	e0 89 00 24 	brgt	8000964a <_dtoa_r+0xa7e>
80009606:	c2 f8       	rjmp	80009664 <_dtoa_r+0xa98>
80009608:	40 69       	lddsp	r9,sp[0x18]
8000960a:	58 09       	cp.w	r9,0
8000960c:	c0 85       	brlt	8000961c <_dtoa_r+0xa50>
8000960e:	12 98       	mov	r8,r9
80009610:	40 cc       	lddsp	r12,sp[0x30]
80009612:	18 48       	or	r8,r12
80009614:	c1 d1       	brne	8000964e <_dtoa_r+0xa82>
80009616:	40 db       	lddsp	r11,sp[0x34]
80009618:	58 0b       	cp.w	r11,0
8000961a:	c1 a1       	brne	8000964e <_dtoa_r+0xa82>
8000961c:	0c 99       	mov	r9,r6
8000961e:	40 26       	lddsp	r6,sp[0x8]
80009620:	58 09       	cp.w	r9,0
80009622:	e0 8a 00 21 	brle	80009664 <_dtoa_r+0xa98>
80009626:	06 9b       	mov	r11,r3
80009628:	30 1a       	mov	r10,1
8000962a:	0e 9c       	mov	r12,r7
8000962c:	e0 a0 06 92 	rcall	8000a350 <__lshift>
80009630:	04 9b       	mov	r11,r2
80009632:	18 93       	mov	r3,r12
80009634:	e0 a0 05 6b 	rcall	8000a10a <__mcmp>
80009638:	e0 89 00 06 	brgt	80009644 <_dtoa_r+0xa78>
8000963c:	c1 41       	brne	80009664 <_dtoa_r+0xa98>
8000963e:	ed b0 00 00 	bld	r0,0x0
80009642:	c1 11       	brne	80009664 <_dtoa_r+0xa98>
80009644:	e0 40 00 39 	cp.w	r0,57
80009648:	c0 a0       	breq	8000965c <_dtoa_r+0xa90>
8000964a:	2f f0       	sub	r0,-1
8000964c:	c0 c8       	rjmp	80009664 <_dtoa_r+0xa98>
8000964e:	58 06       	cp.w	r6,0
80009650:	e0 8a 00 0c 	brle	80009668 <_dtoa_r+0xa9c>
80009654:	40 26       	lddsp	r6,sp[0x8]
80009656:	e0 40 00 39 	cp.w	r0,57
8000965a:	c0 41       	brne	80009662 <_dtoa_r+0xa96>
8000965c:	33 98       	mov	r8,57
8000965e:	0a c8       	st.b	r5++,r8
80009660:	c6 78       	rjmp	8000972e <_dtoa_r+0xb62>
80009662:	2f f0       	sub	r0,-1
80009664:	0a c0       	st.b	r5++,r0
80009666:	c7 58       	rjmp	80009750 <_dtoa_r+0xb84>
80009668:	0a c0       	st.b	r5++,r0
8000966a:	40 9a       	lddsp	r10,sp[0x24]
8000966c:	40 e9       	lddsp	r9,sp[0x38]
8000966e:	12 3a       	cp.w	r10,r9
80009670:	c4 30       	breq	800096f6 <_dtoa_r+0xb2a>
80009672:	06 9b       	mov	r11,r3
80009674:	30 09       	mov	r9,0
80009676:	30 aa       	mov	r10,10
80009678:	0e 9c       	mov	r12,r7
8000967a:	e0 a0 07 37 	rcall	8000a4e8 <__multadd>
8000967e:	40 48       	lddsp	r8,sp[0x10]
80009680:	18 93       	mov	r3,r12
80009682:	08 38       	cp.w	r8,r4
80009684:	c0 91       	brne	80009696 <_dtoa_r+0xaca>
80009686:	10 9b       	mov	r11,r8
80009688:	30 09       	mov	r9,0
8000968a:	30 aa       	mov	r10,10
8000968c:	0e 9c       	mov	r12,r7
8000968e:	e0 a0 07 2d 	rcall	8000a4e8 <__multadd>
80009692:	50 4c       	stdsp	sp[0x10],r12
80009694:	c0 e8       	rjmp	800096b0 <_dtoa_r+0xae4>
80009696:	40 4b       	lddsp	r11,sp[0x10]
80009698:	30 09       	mov	r9,0
8000969a:	30 aa       	mov	r10,10
8000969c:	0e 9c       	mov	r12,r7
8000969e:	e0 a0 07 25 	rcall	8000a4e8 <__multadd>
800096a2:	08 9b       	mov	r11,r4
800096a4:	50 4c       	stdsp	sp[0x10],r12
800096a6:	30 09       	mov	r9,0
800096a8:	30 aa       	mov	r10,10
800096aa:	0e 9c       	mov	r12,r7
800096ac:	e0 a0 07 1e 	rcall	8000a4e8 <__multadd>
800096b0:	18 94       	mov	r4,r12
800096b2:	40 9c       	lddsp	r12,sp[0x24]
800096b4:	2f fc       	sub	r12,-1
800096b6:	50 9c       	stdsp	sp[0x24],r12
800096b8:	c7 9b       	rjmp	800095aa <_dtoa_r+0x9de>
800096ba:	30 18       	mov	r8,1
800096bc:	06 90       	mov	r0,r3
800096be:	40 85       	lddsp	r5,sp[0x20]
800096c0:	08 93       	mov	r3,r4
800096c2:	0c 94       	mov	r4,r6
800096c4:	10 96       	mov	r6,r8
800096c6:	04 9b       	mov	r11,r2
800096c8:	00 9c       	mov	r12,r0
800096ca:	fe b0 f9 f1 	rcall	80008aac <quorem>
800096ce:	2d 0c       	sub	r12,-48
800096d0:	0a cc       	st.b	r5++,r12
800096d2:	02 36       	cp.w	r6,r1
800096d4:	c0 a4       	brge	800096e8 <_dtoa_r+0xb1c>
800096d6:	00 9b       	mov	r11,r0
800096d8:	30 09       	mov	r9,0
800096da:	30 aa       	mov	r10,10
800096dc:	0e 9c       	mov	r12,r7
800096de:	2f f6       	sub	r6,-1
800096e0:	e0 a0 07 04 	rcall	8000a4e8 <__multadd>
800096e4:	18 90       	mov	r0,r12
800096e6:	cf 0b       	rjmp	800096c6 <_dtoa_r+0xafa>
800096e8:	08 96       	mov	r6,r4
800096ea:	30 0b       	mov	r11,0
800096ec:	06 94       	mov	r4,r3
800096ee:	50 4b       	stdsp	sp[0x10],r11
800096f0:	00 93       	mov	r3,r0
800096f2:	18 90       	mov	r0,r12
800096f4:	c0 28       	rjmp	800096f8 <_dtoa_r+0xb2c>
800096f6:	40 26       	lddsp	r6,sp[0x8]
800096f8:	06 9b       	mov	r11,r3
800096fa:	30 1a       	mov	r10,1
800096fc:	0e 9c       	mov	r12,r7
800096fe:	e0 a0 06 29 	rcall	8000a350 <__lshift>
80009702:	04 9b       	mov	r11,r2
80009704:	18 93       	mov	r3,r12
80009706:	e0 a0 05 02 	rcall	8000a10a <__mcmp>
8000970a:	e0 89 00 12 	brgt	8000972e <_dtoa_r+0xb62>
8000970e:	c1 b1       	brne	80009744 <_dtoa_r+0xb78>
80009710:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
80009714:	c0 d1       	brne	8000972e <_dtoa_r+0xb62>
80009716:	c1 78       	rjmp	80009744 <_dtoa_r+0xb78>
80009718:	40 89       	lddsp	r9,sp[0x20]
8000971a:	12 38       	cp.w	r8,r9
8000971c:	c0 30       	breq	80009722 <_dtoa_r+0xb56>
8000971e:	10 95       	mov	r5,r8
80009720:	c0 88       	rjmp	80009730 <_dtoa_r+0xb64>
80009722:	2f f6       	sub	r6,-1
80009724:	50 66       	stdsp	sp[0x18],r6
80009726:	33 18       	mov	r8,49
80009728:	40 8c       	lddsp	r12,sp[0x20]
8000972a:	b8 88       	st.b	r12[0x0],r8
8000972c:	c1 38       	rjmp	80009752 <_dtoa_r+0xb86>
8000972e:	33 9a       	mov	r10,57
80009730:	0a 98       	mov	r8,r5
80009732:	11 79       	ld.ub	r9,--r8
80009734:	f4 09 18 00 	cp.b	r9,r10
80009738:	cf 00       	breq	80009718 <_dtoa_r+0xb4c>
8000973a:	2f f9       	sub	r9,-1
8000973c:	b0 89       	st.b	r8[0x0],r9
8000973e:	c0 98       	rjmp	80009750 <_dtoa_r+0xb84>
80009740:	10 95       	mov	r5,r8
80009742:	c0 28       	rjmp	80009746 <_dtoa_r+0xb7a>
80009744:	33 09       	mov	r9,48
80009746:	0a 98       	mov	r8,r5
80009748:	11 7a       	ld.ub	r10,--r8
8000974a:	f2 0a 18 00 	cp.b	r10,r9
8000974e:	cf 90       	breq	80009740 <_dtoa_r+0xb74>
80009750:	50 66       	stdsp	sp[0x18],r6
80009752:	04 9b       	mov	r11,r2
80009754:	0e 9c       	mov	r12,r7
80009756:	e0 a0 04 f3 	rcall	8000a13c <_Bfree>
8000975a:	58 04       	cp.w	r4,0
8000975c:	c1 20       	breq	80009780 <_dtoa_r+0xbb4>
8000975e:	40 4b       	lddsp	r11,sp[0x10]
80009760:	08 3b       	cp.w	r11,r4
80009762:	5f 19       	srne	r9
80009764:	58 0b       	cp.w	r11,0
80009766:	5f 18       	srne	r8
80009768:	f3 e8 00 08 	and	r8,r9,r8
8000976c:	c0 40       	breq	80009774 <_dtoa_r+0xba8>
8000976e:	0e 9c       	mov	r12,r7
80009770:	e0 a0 04 e6 	rcall	8000a13c <_Bfree>
80009774:	08 9b       	mov	r11,r4
80009776:	0e 9c       	mov	r12,r7
80009778:	e0 a0 04 e2 	rcall	8000a13c <_Bfree>
8000977c:	c0 28       	rjmp	80009780 <_dtoa_r+0xbb4>
8000977e:	50 66       	stdsp	sp[0x18],r6
80009780:	0e 9c       	mov	r12,r7
80009782:	06 9b       	mov	r11,r3
80009784:	e0 a0 04 dc 	rcall	8000a13c <_Bfree>
80009788:	30 08       	mov	r8,0
8000978a:	aa 88       	st.b	r5[0x0],r8
8000978c:	40 68       	lddsp	r8,sp[0x18]
8000978e:	41 5a       	lddsp	r10,sp[0x54]
80009790:	2f f8       	sub	r8,-1
80009792:	41 29       	lddsp	r9,sp[0x48]
80009794:	95 08       	st.w	r10[0x0],r8
80009796:	40 8c       	lddsp	r12,sp[0x20]
80009798:	58 09       	cp.w	r9,0
8000979a:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000979e:	f1 f5 1a 00 	st.wne	r8[0x0],r5
800097a2:	2e 6d       	sub	sp,-104
800097a4:	d8 32       	popm	r0-r7,pc
800097a6:	d7 03       	nop

800097a8 <__errno>:
800097a8:	e0 68 0a 18 	mov	r8,2584
800097ac:	70 0c       	ld.w	r12,r8[0x0]
800097ae:	2f 4c       	sub	r12,-12
800097b0:	5e fc       	retal	r12
800097b2:	d7 03       	nop

800097b4 <_fflush_r>:
800097b4:	d4 21       	pushm	r4-r7,lr
800097b6:	16 97       	mov	r7,r11
800097b8:	18 96       	mov	r6,r12
800097ba:	76 48       	ld.w	r8,r11[0x10]
800097bc:	58 08       	cp.w	r8,0
800097be:	c7 f0       	breq	800098bc <_fflush_r+0x108>
800097c0:	58 0c       	cp.w	r12,0
800097c2:	c0 50       	breq	800097cc <_fflush_r+0x18>
800097c4:	78 68       	ld.w	r8,r12[0x18]
800097c6:	58 08       	cp.w	r8,0
800097c8:	c0 21       	brne	800097cc <_fflush_r+0x18>
800097ca:	cc dc       	rcall	80009964 <__sinit>
800097cc:	fe c8 cd 4c 	sub	r8,pc,-12980
800097d0:	10 37       	cp.w	r7,r8
800097d2:	c0 31       	brne	800097d8 <_fflush_r+0x24>
800097d4:	6c 07       	ld.w	r7,r6[0x0]
800097d6:	c0 c8       	rjmp	800097ee <_fflush_r+0x3a>
800097d8:	fe c8 cd 38 	sub	r8,pc,-13000
800097dc:	10 37       	cp.w	r7,r8
800097de:	c0 31       	brne	800097e4 <_fflush_r+0x30>
800097e0:	6c 17       	ld.w	r7,r6[0x4]
800097e2:	c0 68       	rjmp	800097ee <_fflush_r+0x3a>
800097e4:	fe c8 cd 24 	sub	r8,pc,-13020
800097e8:	10 37       	cp.w	r7,r8
800097ea:	ed f7 00 02 	ld.weq	r7,r6[0x8]
800097ee:	8e 6a       	ld.sh	r10,r7[0xc]
800097f0:	14 98       	mov	r8,r10
800097f2:	ed ba 00 03 	bld	r10,0x3
800097f6:	c4 20       	breq	8000987a <_fflush_r+0xc6>
800097f8:	ab ba       	sbr	r10,0xb
800097fa:	ae 6a       	st.h	r7[0xc],r10
800097fc:	6e 18       	ld.w	r8,r7[0x4]
800097fe:	58 08       	cp.w	r8,0
80009800:	e0 89 00 06 	brgt	8000980c <_fflush_r+0x58>
80009804:	6f 08       	ld.w	r8,r7[0x40]
80009806:	58 08       	cp.w	r8,0
80009808:	e0 8a 00 5a 	brle	800098bc <_fflush_r+0x108>
8000980c:	6e b8       	ld.w	r8,r7[0x2c]
8000980e:	58 08       	cp.w	r8,0
80009810:	c5 60       	breq	800098bc <_fflush_r+0x108>
80009812:	e2 1a 10 00 	andl	r10,0x1000,COH
80009816:	c0 30       	breq	8000981c <_fflush_r+0x68>
80009818:	6f 55       	ld.w	r5,r7[0x54]
8000981a:	c0 f8       	rjmp	80009838 <_fflush_r+0x84>
8000981c:	30 19       	mov	r9,1
8000981e:	6e 8b       	ld.w	r11,r7[0x20]
80009820:	0c 9c       	mov	r12,r6
80009822:	5d 18       	icall	r8
80009824:	18 95       	mov	r5,r12
80009826:	5b fc       	cp.w	r12,-1
80009828:	c0 81       	brne	80009838 <_fflush_r+0x84>
8000982a:	6c 38       	ld.w	r8,r6[0xc]
8000982c:	59 d8       	cp.w	r8,29
8000982e:	c4 70       	breq	800098bc <_fflush_r+0x108>
80009830:	8e 68       	ld.sh	r8,r7[0xc]
80009832:	a7 a8       	sbr	r8,0x6
80009834:	ae 68       	st.h	r7[0xc],r8
80009836:	d8 22       	popm	r4-r7,pc
80009838:	8e 68       	ld.sh	r8,r7[0xc]
8000983a:	ed b8 00 02 	bld	r8,0x2
8000983e:	c0 91       	brne	80009850 <_fflush_r+0x9c>
80009840:	6e 18       	ld.w	r8,r7[0x4]
80009842:	10 15       	sub	r5,r8
80009844:	6e d8       	ld.w	r8,r7[0x34]
80009846:	58 08       	cp.w	r8,0
80009848:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000984c:	eb d8 e1 15 	subne	r5,r5,r8
80009850:	6e b8       	ld.w	r8,r7[0x2c]
80009852:	0c 9c       	mov	r12,r6
80009854:	30 09       	mov	r9,0
80009856:	0a 9a       	mov	r10,r5
80009858:	6e 8b       	ld.w	r11,r7[0x20]
8000985a:	5d 18       	icall	r8
8000985c:	8e 68       	ld.sh	r8,r7[0xc]
8000985e:	0a 3c       	cp.w	r12,r5
80009860:	c2 61       	brne	800098ac <_fflush_r+0xf8>
80009862:	ab d8       	cbr	r8,0xb
80009864:	30 0c       	mov	r12,0
80009866:	6e 49       	ld.w	r9,r7[0x10]
80009868:	ae 68       	st.h	r7[0xc],r8
8000986a:	8f 1c       	st.w	r7[0x4],r12
8000986c:	8f 09       	st.w	r7[0x0],r9
8000986e:	ed b8 00 0c 	bld	r8,0xc
80009872:	c2 51       	brne	800098bc <_fflush_r+0x108>
80009874:	ef 45 00 54 	st.w	r7[84],r5
80009878:	d8 22       	popm	r4-r7,pc
8000987a:	6e 45       	ld.w	r5,r7[0x10]
8000987c:	58 05       	cp.w	r5,0
8000987e:	c1 f0       	breq	800098bc <_fflush_r+0x108>
80009880:	6e 04       	ld.w	r4,r7[0x0]
80009882:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
80009886:	8f 05       	st.w	r7[0x0],r5
80009888:	f9 b8 01 00 	movne	r8,0
8000988c:	ef f8 00 05 	ld.weq	r8,r7[0x14]
80009890:	0a 14       	sub	r4,r5
80009892:	8f 28       	st.w	r7[0x8],r8
80009894:	c1 18       	rjmp	800098b6 <_fflush_r+0x102>
80009896:	08 99       	mov	r9,r4
80009898:	0a 9a       	mov	r10,r5
8000989a:	6e a8       	ld.w	r8,r7[0x28]
8000989c:	6e 8b       	ld.w	r11,r7[0x20]
8000989e:	0c 9c       	mov	r12,r6
800098a0:	5d 18       	icall	r8
800098a2:	18 14       	sub	r4,r12
800098a4:	58 0c       	cp.w	r12,0
800098a6:	e0 89 00 07 	brgt	800098b4 <_fflush_r+0x100>
800098aa:	8e 68       	ld.sh	r8,r7[0xc]
800098ac:	a7 a8       	sbr	r8,0x6
800098ae:	3f fc       	mov	r12,-1
800098b0:	ae 68       	st.h	r7[0xc],r8
800098b2:	d8 22       	popm	r4-r7,pc
800098b4:	18 05       	add	r5,r12
800098b6:	58 04       	cp.w	r4,0
800098b8:	fe 99 ff ef 	brgt	80009896 <_fflush_r+0xe2>
800098bc:	d8 2a       	popm	r4-r7,pc,r12=0
800098be:	d7 03       	nop

800098c0 <__sfp_lock_acquire>:
800098c0:	5e fc       	retal	r12

800098c2 <__sfp_lock_release>:
800098c2:	5e fc       	retal	r12

800098c4 <_cleanup_r>:
800098c4:	d4 01       	pushm	lr
800098c6:	fe cb f0 ae 	sub	r11,pc,-3922
800098ca:	e0 a0 02 f7 	rcall	80009eb8 <_fwalk>
800098ce:	d8 02       	popm	pc

800098d0 <__sfmoreglue>:
800098d0:	d4 21       	pushm	r4-r7,lr
800098d2:	16 95       	mov	r5,r11
800098d4:	f6 06 10 5c 	mul	r6,r11,92
800098d8:	ec cb ff f4 	sub	r11,r6,-12
800098dc:	fe b0 e2 76 	rcall	80005dc8 <_malloc_r>
800098e0:	18 97       	mov	r7,r12
800098e2:	c0 90       	breq	800098f4 <__sfmoreglue+0x24>
800098e4:	99 15       	st.w	r12[0x4],r5
800098e6:	30 0b       	mov	r11,0
800098e8:	2f 4c       	sub	r12,-12
800098ea:	0c 9a       	mov	r10,r6
800098ec:	8f 2c       	st.w	r7[0x8],r12
800098ee:	8f 0b       	st.w	r7[0x0],r11
800098f0:	fe b0 e5 3f 	rcall	8000636e <memset>
800098f4:	0e 9c       	mov	r12,r7
800098f6:	d8 22       	popm	r4-r7,pc

800098f8 <__sfp>:
800098f8:	d4 21       	pushm	r4-r7,lr
800098fa:	fe c8 ce 16 	sub	r8,pc,-12778
800098fe:	18 96       	mov	r6,r12
80009900:	70 07       	ld.w	r7,r8[0x0]
80009902:	6e 68       	ld.w	r8,r7[0x18]
80009904:	58 08       	cp.w	r8,0
80009906:	c0 31       	brne	8000990c <__sfp+0x14>
80009908:	0e 9c       	mov	r12,r7
8000990a:	c2 dc       	rcall	80009964 <__sinit>
8000990c:	ee c7 ff 28 	sub	r7,r7,-216
80009910:	30 05       	mov	r5,0
80009912:	6e 2c       	ld.w	r12,r7[0x8]
80009914:	6e 18       	ld.w	r8,r7[0x4]
80009916:	c0 68       	rjmp	80009922 <__sfp+0x2a>
80009918:	98 69       	ld.sh	r9,r12[0xc]
8000991a:	ea 09 19 00 	cp.h	r9,r5
8000991e:	c1 10       	breq	80009940 <__sfp+0x48>
80009920:	2a 4c       	sub	r12,-92
80009922:	20 18       	sub	r8,1
80009924:	cf a7       	brpl	80009918 <__sfp+0x20>
80009926:	6e 08       	ld.w	r8,r7[0x0]
80009928:	58 08       	cp.w	r8,0
8000992a:	c0 61       	brne	80009936 <__sfp+0x3e>
8000992c:	30 4b       	mov	r11,4
8000992e:	0c 9c       	mov	r12,r6
80009930:	cd 0f       	rcall	800098d0 <__sfmoreglue>
80009932:	8f 0c       	st.w	r7[0x0],r12
80009934:	c0 30       	breq	8000993a <__sfp+0x42>
80009936:	6e 07       	ld.w	r7,r7[0x0]
80009938:	ce db       	rjmp	80009912 <__sfp+0x1a>
8000993a:	30 c8       	mov	r8,12
8000993c:	8d 38       	st.w	r6[0xc],r8
8000993e:	d8 22       	popm	r4-r7,pc
80009940:	30 08       	mov	r8,0
80009942:	f9 48 00 4c 	st.w	r12[76],r8
80009946:	99 08       	st.w	r12[0x0],r8
80009948:	99 28       	st.w	r12[0x8],r8
8000994a:	99 18       	st.w	r12[0x4],r8
8000994c:	99 48       	st.w	r12[0x10],r8
8000994e:	99 58       	st.w	r12[0x14],r8
80009950:	99 68       	st.w	r12[0x18],r8
80009952:	99 d8       	st.w	r12[0x34],r8
80009954:	99 e8       	st.w	r12[0x38],r8
80009956:	f9 48 00 48 	st.w	r12[72],r8
8000995a:	3f f8       	mov	r8,-1
8000995c:	b8 78       	st.h	r12[0xe],r8
8000995e:	30 18       	mov	r8,1
80009960:	b8 68       	st.h	r12[0xc],r8
80009962:	d8 22       	popm	r4-r7,pc

80009964 <__sinit>:
80009964:	d4 21       	pushm	r4-r7,lr
80009966:	18 96       	mov	r6,r12
80009968:	78 67       	ld.w	r7,r12[0x18]
8000996a:	58 07       	cp.w	r7,0
8000996c:	c4 91       	brne	800099fe <__sinit+0x9a>
8000996e:	fe c8 00 aa 	sub	r8,pc,170
80009972:	30 15       	mov	r5,1
80009974:	99 a8       	st.w	r12[0x28],r8
80009976:	f9 47 00 d8 	st.w	r12[216],r7
8000997a:	f9 47 00 dc 	st.w	r12[220],r7
8000997e:	f9 47 00 e0 	st.w	r12[224],r7
80009982:	99 65       	st.w	r12[0x18],r5
80009984:	cb af       	rcall	800098f8 <__sfp>
80009986:	8d 0c       	st.w	r6[0x0],r12
80009988:	0c 9c       	mov	r12,r6
8000998a:	cb 7f       	rcall	800098f8 <__sfp>
8000998c:	8d 1c       	st.w	r6[0x4],r12
8000998e:	0c 9c       	mov	r12,r6
80009990:	cb 4f       	rcall	800098f8 <__sfp>
80009992:	6c 09       	ld.w	r9,r6[0x0]
80009994:	30 48       	mov	r8,4
80009996:	93 07       	st.w	r9[0x0],r7
80009998:	b2 68       	st.h	r9[0xc],r8
8000999a:	93 17       	st.w	r9[0x4],r7
8000999c:	93 27       	st.w	r9[0x8],r7
8000999e:	6c 18       	ld.w	r8,r6[0x4]
800099a0:	b2 77       	st.h	r9[0xe],r7
800099a2:	93 47       	st.w	r9[0x10],r7
800099a4:	93 57       	st.w	r9[0x14],r7
800099a6:	93 67       	st.w	r9[0x18],r7
800099a8:	93 89       	st.w	r9[0x20],r9
800099aa:	91 07       	st.w	r8[0x0],r7
800099ac:	91 17       	st.w	r8[0x4],r7
800099ae:	91 27       	st.w	r8[0x8],r7
800099b0:	fe ce f3 24 	sub	lr,pc,-3292
800099b4:	fe cb f3 54 	sub	r11,pc,-3244
800099b8:	93 9e       	st.w	r9[0x24],lr
800099ba:	93 ab       	st.w	r9[0x28],r11
800099bc:	fe ca f3 7c 	sub	r10,pc,-3204
800099c0:	fe c4 f3 88 	sub	r4,pc,-3192
800099c4:	93 ba       	st.w	r9[0x2c],r10
800099c6:	93 c4       	st.w	r9[0x30],r4
800099c8:	30 99       	mov	r9,9
800099ca:	b0 69       	st.h	r8[0xc],r9
800099cc:	b0 75       	st.h	r8[0xe],r5
800099ce:	91 c4       	st.w	r8[0x30],r4
800099d0:	91 47       	st.w	r8[0x10],r7
800099d2:	91 57       	st.w	r8[0x14],r7
800099d4:	91 67       	st.w	r8[0x18],r7
800099d6:	91 88       	st.w	r8[0x20],r8
800099d8:	91 9e       	st.w	r8[0x24],lr
800099da:	91 ab       	st.w	r8[0x28],r11
800099dc:	91 ba       	st.w	r8[0x2c],r10
800099de:	8d 2c       	st.w	r6[0x8],r12
800099e0:	31 28       	mov	r8,18
800099e2:	99 07       	st.w	r12[0x0],r7
800099e4:	b8 68       	st.h	r12[0xc],r8
800099e6:	99 17       	st.w	r12[0x4],r7
800099e8:	99 27       	st.w	r12[0x8],r7
800099ea:	30 28       	mov	r8,2
800099ec:	b8 78       	st.h	r12[0xe],r8
800099ee:	99 c4       	st.w	r12[0x30],r4
800099f0:	99 67       	st.w	r12[0x18],r7
800099f2:	99 9e       	st.w	r12[0x24],lr
800099f4:	99 ab       	st.w	r12[0x28],r11
800099f6:	99 ba       	st.w	r12[0x2c],r10
800099f8:	99 47       	st.w	r12[0x10],r7
800099fa:	99 57       	st.w	r12[0x14],r7
800099fc:	99 8c       	st.w	r12[0x20],r12
800099fe:	d8 22       	popm	r4-r7,pc

80009a00 <_malloc_trim_r>:
80009a00:	d4 21       	pushm	r4-r7,lr
80009a02:	16 95       	mov	r5,r11
80009a04:	18 97       	mov	r7,r12
80009a06:	fe b0 d8 af 	rcall	80004b64 <__malloc_lock>
80009a0a:	e0 64 05 18 	mov	r4,1304
80009a0e:	68 28       	ld.w	r8,r4[0x8]
80009a10:	70 16       	ld.w	r6,r8[0x4]
80009a12:	e0 16 ff fc 	andl	r6,0xfffc
80009a16:	ec c8 ff 91 	sub	r8,r6,-111
80009a1a:	f0 05 01 05 	sub	r5,r8,r5
80009a1e:	e0 15 ff 80 	andl	r5,0xff80
80009a22:	ea c5 00 80 	sub	r5,r5,128
80009a26:	e0 45 00 7f 	cp.w	r5,127
80009a2a:	e0 8a 00 25 	brle	80009a74 <_malloc_trim_r+0x74>
80009a2e:	30 0b       	mov	r11,0
80009a30:	0e 9c       	mov	r12,r7
80009a32:	fe b0 e6 05 	rcall	8000663c <_sbrk_r>
80009a36:	68 28       	ld.w	r8,r4[0x8]
80009a38:	0c 08       	add	r8,r6
80009a3a:	10 3c       	cp.w	r12,r8
80009a3c:	c1 c1       	brne	80009a74 <_malloc_trim_r+0x74>
80009a3e:	ea 0b 11 00 	rsub	r11,r5,0
80009a42:	0e 9c       	mov	r12,r7
80009a44:	fe b0 e5 fc 	rcall	8000663c <_sbrk_r>
80009a48:	5b fc       	cp.w	r12,-1
80009a4a:	c1 91       	brne	80009a7c <_malloc_trim_r+0x7c>
80009a4c:	30 0b       	mov	r11,0
80009a4e:	0e 9c       	mov	r12,r7
80009a50:	fe b0 e5 f6 	rcall	8000663c <_sbrk_r>
80009a54:	68 28       	ld.w	r8,r4[0x8]
80009a56:	f8 08 01 09 	sub	r9,r12,r8
80009a5a:	58 f9       	cp.w	r9,15
80009a5c:	e0 8a 00 0c 	brle	80009a74 <_malloc_trim_r+0x74>
80009a60:	a1 a9       	sbr	r9,0x0
80009a62:	91 19       	st.w	r8[0x4],r9
80009a64:	e0 68 09 24 	mov	r8,2340
80009a68:	70 09       	ld.w	r9,r8[0x0]
80009a6a:	e0 68 0c b4 	mov	r8,3252
80009a6e:	f8 09 01 09 	sub	r9,r12,r9
80009a72:	91 09       	st.w	r8[0x0],r9
80009a74:	0e 9c       	mov	r12,r7
80009a76:	fe b0 d8 7d 	rcall	80004b70 <__malloc_unlock>
80009a7a:	d8 2a       	popm	r4-r7,pc,r12=0
80009a7c:	68 28       	ld.w	r8,r4[0x8]
80009a7e:	0a 16       	sub	r6,r5
80009a80:	a1 a6       	sbr	r6,0x0
80009a82:	91 16       	st.w	r8[0x4],r6
80009a84:	e0 68 0c b4 	mov	r8,3252
80009a88:	70 09       	ld.w	r9,r8[0x0]
80009a8a:	0a 19       	sub	r9,r5
80009a8c:	0e 9c       	mov	r12,r7
80009a8e:	91 09       	st.w	r8[0x0],r9
80009a90:	fe b0 d8 70 	rcall	80004b70 <__malloc_unlock>
80009a94:	da 2a       	popm	r4-r7,pc,r12=1
80009a96:	d7 03       	nop

80009a98 <_free_r>:
80009a98:	d4 21       	pushm	r4-r7,lr
80009a9a:	16 96       	mov	r6,r11
80009a9c:	18 97       	mov	r7,r12
80009a9e:	58 0b       	cp.w	r11,0
80009aa0:	e0 80 00 c0 	breq	80009c20 <_free_r+0x188>
80009aa4:	fe b0 d8 60 	rcall	80004b64 <__malloc_lock>
80009aa8:	20 86       	sub	r6,8
80009aaa:	e0 6a 05 18 	mov	r10,1304
80009aae:	6c 18       	ld.w	r8,r6[0x4]
80009ab0:	74 2e       	ld.w	lr,r10[0x8]
80009ab2:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80009ab6:	a1 c8       	cbr	r8,0x0
80009ab8:	ec 08 00 09 	add	r9,r6,r8
80009abc:	72 1b       	ld.w	r11,r9[0x4]
80009abe:	e0 1b ff fc 	andl	r11,0xfffc
80009ac2:	1c 39       	cp.w	r9,lr
80009ac4:	c1 e1       	brne	80009b00 <_free_r+0x68>
80009ac6:	f6 08 00 08 	add	r8,r11,r8
80009aca:	58 0c       	cp.w	r12,0
80009acc:	c0 81       	brne	80009adc <_free_r+0x44>
80009ace:	6c 09       	ld.w	r9,r6[0x0]
80009ad0:	12 16       	sub	r6,r9
80009ad2:	12 08       	add	r8,r9
80009ad4:	6c 3b       	ld.w	r11,r6[0xc]
80009ad6:	6c 29       	ld.w	r9,r6[0x8]
80009ad8:	97 29       	st.w	r11[0x8],r9
80009ada:	93 3b       	st.w	r9[0xc],r11
80009adc:	10 99       	mov	r9,r8
80009ade:	95 26       	st.w	r10[0x8],r6
80009ae0:	a1 a9       	sbr	r9,0x0
80009ae2:	8d 19       	st.w	r6[0x4],r9
80009ae4:	e0 69 09 20 	mov	r9,2336
80009ae8:	72 09       	ld.w	r9,r9[0x0]
80009aea:	12 38       	cp.w	r8,r9
80009aec:	c0 63       	brcs	80009af8 <_free_r+0x60>
80009aee:	e0 68 0c b0 	mov	r8,3248
80009af2:	0e 9c       	mov	r12,r7
80009af4:	70 0b       	ld.w	r11,r8[0x0]
80009af6:	c8 5f       	rcall	80009a00 <_malloc_trim_r>
80009af8:	0e 9c       	mov	r12,r7
80009afa:	fe b0 d8 3b 	rcall	80004b70 <__malloc_unlock>
80009afe:	d8 22       	popm	r4-r7,pc
80009b00:	93 1b       	st.w	r9[0x4],r11
80009b02:	58 0c       	cp.w	r12,0
80009b04:	c0 30       	breq	80009b0a <_free_r+0x72>
80009b06:	30 0c       	mov	r12,0
80009b08:	c1 08       	rjmp	80009b28 <_free_r+0x90>
80009b0a:	6c 0e       	ld.w	lr,r6[0x0]
80009b0c:	f4 c5 ff f8 	sub	r5,r10,-8
80009b10:	1c 16       	sub	r6,lr
80009b12:	1c 08       	add	r8,lr
80009b14:	6c 2e       	ld.w	lr,r6[0x8]
80009b16:	0a 3e       	cp.w	lr,r5
80009b18:	f9 bc 00 01 	moveq	r12,1
80009b1c:	ed f5 10 03 	ld.wne	r5,r6[0xc]
80009b20:	eb fe 1a 02 	st.wne	r5[0x8],lr
80009b24:	fd f5 1a 03 	st.wne	lr[0xc],r5
80009b28:	f2 0b 00 0e 	add	lr,r9,r11
80009b2c:	7c 1e       	ld.w	lr,lr[0x4]
80009b2e:	ed be 00 00 	bld	lr,0x0
80009b32:	c1 40       	breq	80009b5a <_free_r+0xc2>
80009b34:	16 08       	add	r8,r11
80009b36:	58 0c       	cp.w	r12,0
80009b38:	c0 d1       	brne	80009b52 <_free_r+0xba>
80009b3a:	e0 6e 05 18 	mov	lr,1304
80009b3e:	72 2b       	ld.w	r11,r9[0x8]
80009b40:	2f 8e       	sub	lr,-8
80009b42:	1c 3b       	cp.w	r11,lr
80009b44:	c0 71       	brne	80009b52 <_free_r+0xba>
80009b46:	97 36       	st.w	r11[0xc],r6
80009b48:	97 26       	st.w	r11[0x8],r6
80009b4a:	8d 2b       	st.w	r6[0x8],r11
80009b4c:	8d 3b       	st.w	r6[0xc],r11
80009b4e:	30 1c       	mov	r12,1
80009b50:	c0 58       	rjmp	80009b5a <_free_r+0xc2>
80009b52:	72 2b       	ld.w	r11,r9[0x8]
80009b54:	72 39       	ld.w	r9,r9[0xc]
80009b56:	93 2b       	st.w	r9[0x8],r11
80009b58:	97 39       	st.w	r11[0xc],r9
80009b5a:	10 99       	mov	r9,r8
80009b5c:	ec 08 09 08 	st.w	r6[r8],r8
80009b60:	a1 a9       	sbr	r9,0x0
80009b62:	8d 19       	st.w	r6[0x4],r9
80009b64:	58 0c       	cp.w	r12,0
80009b66:	c5 a1       	brne	80009c1a <_free_r+0x182>
80009b68:	e0 48 01 ff 	cp.w	r8,511
80009b6c:	e0 8b 00 13 	brhi	80009b92 <_free_r+0xfa>
80009b70:	a3 98       	lsr	r8,0x3
80009b72:	f4 08 00 39 	add	r9,r10,r8<<0x3
80009b76:	72 2b       	ld.w	r11,r9[0x8]
80009b78:	8d 39       	st.w	r6[0xc],r9
80009b7a:	8d 2b       	st.w	r6[0x8],r11
80009b7c:	97 36       	st.w	r11[0xc],r6
80009b7e:	93 26       	st.w	r9[0x8],r6
80009b80:	a3 48       	asr	r8,0x2
80009b82:	74 19       	ld.w	r9,r10[0x4]
80009b84:	30 1b       	mov	r11,1
80009b86:	f6 08 09 48 	lsl	r8,r11,r8
80009b8a:	f3 e8 10 08 	or	r8,r9,r8
80009b8e:	95 18       	st.w	r10[0x4],r8
80009b90:	c4 58       	rjmp	80009c1a <_free_r+0x182>
80009b92:	f0 0b 16 09 	lsr	r11,r8,0x9
80009b96:	58 4b       	cp.w	r11,4
80009b98:	e0 8b 00 06 	brhi	80009ba4 <_free_r+0x10c>
80009b9c:	f0 0b 16 06 	lsr	r11,r8,0x6
80009ba0:	2c 8b       	sub	r11,-56
80009ba2:	c2 08       	rjmp	80009be2 <_free_r+0x14a>
80009ba4:	59 4b       	cp.w	r11,20
80009ba6:	e0 8b 00 04 	brhi	80009bae <_free_r+0x116>
80009baa:	2a 5b       	sub	r11,-91
80009bac:	c1 b8       	rjmp	80009be2 <_free_r+0x14a>
80009bae:	e0 4b 00 54 	cp.w	r11,84
80009bb2:	e0 8b 00 06 	brhi	80009bbe <_free_r+0x126>
80009bb6:	f0 0b 16 0c 	lsr	r11,r8,0xc
80009bba:	29 2b       	sub	r11,-110
80009bbc:	c1 38       	rjmp	80009be2 <_free_r+0x14a>
80009bbe:	e0 4b 01 54 	cp.w	r11,340
80009bc2:	e0 8b 00 06 	brhi	80009bce <_free_r+0x136>
80009bc6:	f0 0b 16 0f 	lsr	r11,r8,0xf
80009bca:	28 9b       	sub	r11,-119
80009bcc:	c0 b8       	rjmp	80009be2 <_free_r+0x14a>
80009bce:	e0 4b 05 54 	cp.w	r11,1364
80009bd2:	e0 88 00 05 	brls	80009bdc <_free_r+0x144>
80009bd6:	37 eb       	mov	r11,126
80009bd8:	c0 58       	rjmp	80009be2 <_free_r+0x14a>
80009bda:	d7 03       	nop
80009bdc:	f0 0b 16 12 	lsr	r11,r8,0x12
80009be0:	28 4b       	sub	r11,-124
80009be2:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
80009be6:	78 29       	ld.w	r9,r12[0x8]
80009be8:	18 39       	cp.w	r9,r12
80009bea:	c0 e1       	brne	80009c06 <_free_r+0x16e>
80009bec:	74 18       	ld.w	r8,r10[0x4]
80009bee:	a3 4b       	asr	r11,0x2
80009bf0:	30 1c       	mov	r12,1
80009bf2:	f8 0b 09 4b 	lsl	r11,r12,r11
80009bf6:	f1 eb 10 0b 	or	r11,r8,r11
80009bfa:	12 98       	mov	r8,r9
80009bfc:	95 1b       	st.w	r10[0x4],r11
80009bfe:	c0 a8       	rjmp	80009c12 <_free_r+0x17a>
80009c00:	72 29       	ld.w	r9,r9[0x8]
80009c02:	18 39       	cp.w	r9,r12
80009c04:	c0 60       	breq	80009c10 <_free_r+0x178>
80009c06:	72 1a       	ld.w	r10,r9[0x4]
80009c08:	e0 1a ff fc 	andl	r10,0xfffc
80009c0c:	14 38       	cp.w	r8,r10
80009c0e:	cf 93       	brcs	80009c00 <_free_r+0x168>
80009c10:	72 38       	ld.w	r8,r9[0xc]
80009c12:	8d 38       	st.w	r6[0xc],r8
80009c14:	8d 29       	st.w	r6[0x8],r9
80009c16:	93 36       	st.w	r9[0xc],r6
80009c18:	91 26       	st.w	r8[0x8],r6
80009c1a:	0e 9c       	mov	r12,r7
80009c1c:	fe b0 d7 aa 	rcall	80004b70 <__malloc_unlock>
80009c20:	d8 22       	popm	r4-r7,pc
80009c22:	d7 03       	nop

80009c24 <__sfvwrite_r>:
80009c24:	d4 31       	pushm	r0-r7,lr
80009c26:	20 3d       	sub	sp,12
80009c28:	14 94       	mov	r4,r10
80009c2a:	18 95       	mov	r5,r12
80009c2c:	16 97       	mov	r7,r11
80009c2e:	74 28       	ld.w	r8,r10[0x8]
80009c30:	58 08       	cp.w	r8,0
80009c32:	e0 80 01 40 	breq	80009eb2 <__sfvwrite_r+0x28e>
80009c36:	96 68       	ld.sh	r8,r11[0xc]
80009c38:	ed b8 00 03 	bld	r8,0x3
80009c3c:	c0 41       	brne	80009c44 <__sfvwrite_r+0x20>
80009c3e:	76 48       	ld.w	r8,r11[0x10]
80009c40:	58 08       	cp.w	r8,0
80009c42:	c0 c1       	brne	80009c5a <__sfvwrite_r+0x36>
80009c44:	0e 9b       	mov	r11,r7
80009c46:	0a 9c       	mov	r12,r5
80009c48:	fe b0 f6 c4 	rcall	800089d0 <__swsetup_r>
80009c4c:	c0 70       	breq	80009c5a <__sfvwrite_r+0x36>
80009c4e:	8e 68       	ld.sh	r8,r7[0xc]
80009c50:	a7 a8       	sbr	r8,0x6
80009c52:	ae 68       	st.h	r7[0xc],r8
80009c54:	30 98       	mov	r8,9
80009c56:	8b 38       	st.w	r5[0xc],r8
80009c58:	c2 b9       	rjmp	80009eae <__sfvwrite_r+0x28a>
80009c5a:	8e 63       	ld.sh	r3,r7[0xc]
80009c5c:	68 00       	ld.w	r0,r4[0x0]
80009c5e:	06 96       	mov	r6,r3
80009c60:	e2 16 00 02 	andl	r6,0x2,COH
80009c64:	c2 10       	breq	80009ca6 <__sfvwrite_r+0x82>
80009c66:	30 03       	mov	r3,0
80009c68:	e0 62 04 00 	mov	r2,1024
80009c6c:	06 96       	mov	r6,r3
80009c6e:	c0 48       	rjmp	80009c76 <__sfvwrite_r+0x52>
80009c70:	60 03       	ld.w	r3,r0[0x0]
80009c72:	60 16       	ld.w	r6,r0[0x4]
80009c74:	2f 80       	sub	r0,-8
80009c76:	58 06       	cp.w	r6,0
80009c78:	cf c0       	breq	80009c70 <__sfvwrite_r+0x4c>
80009c7a:	e0 46 04 00 	cp.w	r6,1024
80009c7e:	ec 09 17 80 	movls	r9,r6
80009c82:	e4 09 17 b0 	movhi	r9,r2
80009c86:	06 9a       	mov	r10,r3
80009c88:	6e a8       	ld.w	r8,r7[0x28]
80009c8a:	6e 8b       	ld.w	r11,r7[0x20]
80009c8c:	0a 9c       	mov	r12,r5
80009c8e:	5d 18       	icall	r8
80009c90:	18 16       	sub	r6,r12
80009c92:	58 0c       	cp.w	r12,0
80009c94:	e0 8a 01 0a 	brle	80009ea8 <__sfvwrite_r+0x284>
80009c98:	68 28       	ld.w	r8,r4[0x8]
80009c9a:	18 18       	sub	r8,r12
80009c9c:	89 28       	st.w	r4[0x8],r8
80009c9e:	e0 80 01 0a 	breq	80009eb2 <__sfvwrite_r+0x28e>
80009ca2:	18 03       	add	r3,r12
80009ca4:	ce 9b       	rjmp	80009c76 <__sfvwrite_r+0x52>
80009ca6:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
80009caa:	c0 70       	breq	80009cb8 <__sfvwrite_r+0x94>
80009cac:	50 06       	stdsp	sp[0x0],r6
80009cae:	0c 93       	mov	r3,r6
80009cb0:	0c 91       	mov	r1,r6
80009cb2:	50 15       	stdsp	sp[0x4],r5
80009cb4:	08 92       	mov	r2,r4
80009cb6:	c9 c8       	rjmp	80009dee <__sfvwrite_r+0x1ca>
80009cb8:	06 96       	mov	r6,r3
80009cba:	08 91       	mov	r1,r4
80009cbc:	c0 48       	rjmp	80009cc4 <__sfvwrite_r+0xa0>
80009cbe:	60 03       	ld.w	r3,r0[0x0]
80009cc0:	60 16       	ld.w	r6,r0[0x4]
80009cc2:	2f 80       	sub	r0,-8
80009cc4:	58 06       	cp.w	r6,0
80009cc6:	cf c0       	breq	80009cbe <__sfvwrite_r+0x9a>
80009cc8:	8e 68       	ld.sh	r8,r7[0xc]
80009cca:	6e 24       	ld.w	r4,r7[0x8]
80009ccc:	10 99       	mov	r9,r8
80009cce:	e2 19 02 00 	andl	r9,0x200,COH
80009cd2:	c5 50       	breq	80009d7c <__sfvwrite_r+0x158>
80009cd4:	08 36       	cp.w	r6,r4
80009cd6:	c4 43       	brcs	80009d5e <__sfvwrite_r+0x13a>
80009cd8:	10 99       	mov	r9,r8
80009cda:	e2 19 04 80 	andl	r9,0x480,COH
80009cde:	c4 00       	breq	80009d5e <__sfvwrite_r+0x13a>
80009ce0:	6e 4b       	ld.w	r11,r7[0x10]
80009ce2:	6e 09       	ld.w	r9,r7[0x0]
80009ce4:	16 19       	sub	r9,r11
80009ce6:	50 09       	stdsp	sp[0x0],r9
80009ce8:	6e 59       	ld.w	r9,r7[0x14]
80009cea:	10 9c       	mov	r12,r8
80009cec:	f2 09 00 1a 	add	r10,r9,r9<<0x1
80009cf0:	30 28       	mov	r8,2
80009cf2:	f4 08 0c 08 	divs	r8,r10,r8
80009cf6:	fa e9 00 04 	st.d	sp[4],r8
80009cfa:	10 94       	mov	r4,r8
80009cfc:	40 09       	lddsp	r9,sp[0x0]
80009cfe:	e2 1c 04 00 	andl	r12,0x400,COH
80009d02:	2f f9       	sub	r9,-1
80009d04:	0c 09       	add	r9,r6
80009d06:	12 38       	cp.w	r8,r9
80009d08:	f2 04 17 30 	movlo	r4,r9
80009d0c:	58 0c       	cp.w	r12,0
80009d0e:	c1 10       	breq	80009d30 <__sfvwrite_r+0x10c>
80009d10:	08 9b       	mov	r11,r4
80009d12:	0a 9c       	mov	r12,r5
80009d14:	fe b0 e0 5a 	rcall	80005dc8 <_malloc_r>
80009d18:	18 92       	mov	r2,r12
80009d1a:	c1 40       	breq	80009d42 <__sfvwrite_r+0x11e>
80009d1c:	40 0a       	lddsp	r10,sp[0x0]
80009d1e:	6e 4b       	ld.w	r11,r7[0x10]
80009d20:	fe b0 e2 83 	rcall	80006226 <memcpy>
80009d24:	8e 68       	ld.sh	r8,r7[0xc]
80009d26:	e0 18 fb 7f 	andl	r8,0xfb7f
80009d2a:	a7 b8       	sbr	r8,0x7
80009d2c:	ae 68       	st.h	r7[0xc],r8
80009d2e:	c0 d8       	rjmp	80009d48 <__sfvwrite_r+0x124>
80009d30:	08 9a       	mov	r10,r4
80009d32:	0a 9c       	mov	r12,r5
80009d34:	fe b0 e3 24 	rcall	8000637c <_realloc_r>
80009d38:	18 92       	mov	r2,r12
80009d3a:	c0 71       	brne	80009d48 <__sfvwrite_r+0x124>
80009d3c:	6e 4b       	ld.w	r11,r7[0x10]
80009d3e:	0a 9c       	mov	r12,r5
80009d40:	ca ce       	rcall	80009a98 <_free_r>
80009d42:	30 c8       	mov	r8,12
80009d44:	8b 38       	st.w	r5[0xc],r8
80009d46:	cb 18       	rjmp	80009ea8 <__sfvwrite_r+0x284>
80009d48:	40 0a       	lddsp	r10,sp[0x0]
80009d4a:	40 09       	lddsp	r9,sp[0x0]
80009d4c:	e8 0a 01 0a 	sub	r10,r4,r10
80009d50:	e4 09 00 08 	add	r8,r2,r9
80009d54:	8f 54       	st.w	r7[0x14],r4
80009d56:	8f 2a       	st.w	r7[0x8],r10
80009d58:	8f 08       	st.w	r7[0x0],r8
80009d5a:	8f 42       	st.w	r7[0x10],r2
80009d5c:	0c 94       	mov	r4,r6
80009d5e:	08 36       	cp.w	r6,r4
80009d60:	ec 04 17 30 	movlo	r4,r6
80009d64:	06 9b       	mov	r11,r3
80009d66:	08 9a       	mov	r10,r4
80009d68:	6e 0c       	ld.w	r12,r7[0x0]
80009d6a:	c3 ad       	rcall	80009fde <memmove>
80009d6c:	6e 08       	ld.w	r8,r7[0x0]
80009d6e:	08 08       	add	r8,r4
80009d70:	8f 08       	st.w	r7[0x0],r8
80009d72:	6e 28       	ld.w	r8,r7[0x8]
80009d74:	08 18       	sub	r8,r4
80009d76:	0c 94       	mov	r4,r6
80009d78:	8f 28       	st.w	r7[0x8],r8
80009d7a:	c2 e8       	rjmp	80009dd6 <__sfvwrite_r+0x1b2>
80009d7c:	08 36       	cp.w	r6,r4
80009d7e:	5f ba       	srhi	r10
80009d80:	6e 0c       	ld.w	r12,r7[0x0]
80009d82:	6e 48       	ld.w	r8,r7[0x10]
80009d84:	10 3c       	cp.w	r12,r8
80009d86:	5f b8       	srhi	r8
80009d88:	f5 e8 00 08 	and	r8,r10,r8
80009d8c:	f2 08 18 00 	cp.b	r8,r9
80009d90:	c0 d0       	breq	80009daa <__sfvwrite_r+0x186>
80009d92:	06 9b       	mov	r11,r3
80009d94:	08 9a       	mov	r10,r4
80009d96:	c2 4d       	rcall	80009fde <memmove>
80009d98:	6e 08       	ld.w	r8,r7[0x0]
80009d9a:	08 08       	add	r8,r4
80009d9c:	0e 9b       	mov	r11,r7
80009d9e:	8f 08       	st.w	r7[0x0],r8
80009da0:	0a 9c       	mov	r12,r5
80009da2:	fe b0 fd 09 	rcall	800097b4 <_fflush_r>
80009da6:	c1 80       	breq	80009dd6 <__sfvwrite_r+0x1b2>
80009da8:	c8 08       	rjmp	80009ea8 <__sfvwrite_r+0x284>
80009daa:	6e 59       	ld.w	r9,r7[0x14]
80009dac:	12 36       	cp.w	r6,r9
80009dae:	c0 a3       	brcs	80009dc2 <__sfvwrite_r+0x19e>
80009db0:	6e a8       	ld.w	r8,r7[0x28]
80009db2:	06 9a       	mov	r10,r3
80009db4:	6e 8b       	ld.w	r11,r7[0x20]
80009db6:	0a 9c       	mov	r12,r5
80009db8:	5d 18       	icall	r8
80009dba:	18 94       	mov	r4,r12
80009dbc:	e0 89 00 0d 	brgt	80009dd6 <__sfvwrite_r+0x1b2>
80009dc0:	c7 48       	rjmp	80009ea8 <__sfvwrite_r+0x284>
80009dc2:	0c 9a       	mov	r10,r6
80009dc4:	06 9b       	mov	r11,r3
80009dc6:	c0 cd       	rcall	80009fde <memmove>
80009dc8:	6e 08       	ld.w	r8,r7[0x0]
80009dca:	0c 08       	add	r8,r6
80009dcc:	0c 94       	mov	r4,r6
80009dce:	8f 08       	st.w	r7[0x0],r8
80009dd0:	6e 28       	ld.w	r8,r7[0x8]
80009dd2:	0c 18       	sub	r8,r6
80009dd4:	8f 28       	st.w	r7[0x8],r8
80009dd6:	62 28       	ld.w	r8,r1[0x8]
80009dd8:	08 18       	sub	r8,r4
80009dda:	83 28       	st.w	r1[0x8],r8
80009ddc:	c6 b0       	breq	80009eb2 <__sfvwrite_r+0x28e>
80009dde:	08 16       	sub	r6,r4
80009de0:	08 03       	add	r3,r4
80009de2:	c7 1b       	rjmp	80009cc4 <__sfvwrite_r+0xa0>
80009de4:	60 03       	ld.w	r3,r0[0x0]
80009de6:	60 11       	ld.w	r1,r0[0x4]
80009de8:	30 08       	mov	r8,0
80009dea:	2f 80       	sub	r0,-8
80009dec:	50 08       	stdsp	sp[0x0],r8
80009dee:	58 01       	cp.w	r1,0
80009df0:	cf a0       	breq	80009de4 <__sfvwrite_r+0x1c0>
80009df2:	40 0a       	lddsp	r10,sp[0x0]
80009df4:	58 0a       	cp.w	r10,0
80009df6:	c1 41       	brne	80009e1e <__sfvwrite_r+0x1fa>
80009df8:	e2 c6 ff ff 	sub	r6,r1,-1
80009dfc:	02 9a       	mov	r10,r1
80009dfe:	30 ab       	mov	r11,10
80009e00:	06 9c       	mov	r12,r3
80009e02:	ce 3c       	rcall	80009fc8 <memchr>
80009e04:	f8 c8 ff ff 	sub	r8,r12,-1
80009e08:	58 0c       	cp.w	r12,0
80009e0a:	f1 d3 e1 16 	subne	r6,r8,r3
80009e0e:	f9 b9 01 01 	movne	r9,1
80009e12:	fb f9 1a 00 	st.wne	sp[0x0],r9
80009e16:	f9 b8 00 01 	moveq	r8,1
80009e1a:	fb f8 0a 00 	st.weq	sp[0x0],r8
80009e1e:	02 36       	cp.w	r6,r1
80009e20:	ec 04 17 80 	movls	r4,r6
80009e24:	e2 04 17 b0 	movhi	r4,r1
80009e28:	6e 59       	ld.w	r9,r7[0x14]
80009e2a:	6e 25       	ld.w	r5,r7[0x8]
80009e2c:	f2 05 00 05 	add	r5,r9,r5
80009e30:	0a 34       	cp.w	r4,r5
80009e32:	5f 9a       	srgt	r10
80009e34:	6e 0c       	ld.w	r12,r7[0x0]
80009e36:	6e 48       	ld.w	r8,r7[0x10]
80009e38:	10 3c       	cp.w	r12,r8
80009e3a:	5f b8       	srhi	r8
80009e3c:	f5 e8 00 08 	and	r8,r10,r8
80009e40:	30 0a       	mov	r10,0
80009e42:	f4 08 18 00 	cp.b	r8,r10
80009e46:	c0 d0       	breq	80009e60 <__sfvwrite_r+0x23c>
80009e48:	06 9b       	mov	r11,r3
80009e4a:	0a 9a       	mov	r10,r5
80009e4c:	cc 9c       	rcall	80009fde <memmove>
80009e4e:	6e 08       	ld.w	r8,r7[0x0]
80009e50:	0a 08       	add	r8,r5
80009e52:	0e 9b       	mov	r11,r7
80009e54:	8f 08       	st.w	r7[0x0],r8
80009e56:	40 1c       	lddsp	r12,sp[0x4]
80009e58:	fe b0 fc ae 	rcall	800097b4 <_fflush_r>
80009e5c:	c1 70       	breq	80009e8a <__sfvwrite_r+0x266>
80009e5e:	c2 58       	rjmp	80009ea8 <__sfvwrite_r+0x284>
80009e60:	12 34       	cp.w	r4,r9
80009e62:	c0 a5       	brlt	80009e76 <__sfvwrite_r+0x252>
80009e64:	6e a8       	ld.w	r8,r7[0x28]
80009e66:	06 9a       	mov	r10,r3
80009e68:	6e 8b       	ld.w	r11,r7[0x20]
80009e6a:	40 1c       	lddsp	r12,sp[0x4]
80009e6c:	5d 18       	icall	r8
80009e6e:	18 95       	mov	r5,r12
80009e70:	e0 89 00 0d 	brgt	80009e8a <__sfvwrite_r+0x266>
80009e74:	c1 a8       	rjmp	80009ea8 <__sfvwrite_r+0x284>
80009e76:	08 9a       	mov	r10,r4
80009e78:	06 9b       	mov	r11,r3
80009e7a:	cb 2c       	rcall	80009fde <memmove>
80009e7c:	6e 08       	ld.w	r8,r7[0x0]
80009e7e:	08 08       	add	r8,r4
80009e80:	08 95       	mov	r5,r4
80009e82:	8f 08       	st.w	r7[0x0],r8
80009e84:	6e 28       	ld.w	r8,r7[0x8]
80009e86:	08 18       	sub	r8,r4
80009e88:	8f 28       	st.w	r7[0x8],r8
80009e8a:	0a 16       	sub	r6,r5
80009e8c:	c0 71       	brne	80009e9a <__sfvwrite_r+0x276>
80009e8e:	0e 9b       	mov	r11,r7
80009e90:	40 1c       	lddsp	r12,sp[0x4]
80009e92:	fe b0 fc 91 	rcall	800097b4 <_fflush_r>
80009e96:	c0 91       	brne	80009ea8 <__sfvwrite_r+0x284>
80009e98:	50 06       	stdsp	sp[0x0],r6
80009e9a:	64 28       	ld.w	r8,r2[0x8]
80009e9c:	0a 18       	sub	r8,r5
80009e9e:	85 28       	st.w	r2[0x8],r8
80009ea0:	c0 90       	breq	80009eb2 <__sfvwrite_r+0x28e>
80009ea2:	0a 11       	sub	r1,r5
80009ea4:	0a 03       	add	r3,r5
80009ea6:	ca 4b       	rjmp	80009dee <__sfvwrite_r+0x1ca>
80009ea8:	8e 68       	ld.sh	r8,r7[0xc]
80009eaa:	a7 a8       	sbr	r8,0x6
80009eac:	ae 68       	st.h	r7[0xc],r8
80009eae:	3f fc       	mov	r12,-1
80009eb0:	c0 28       	rjmp	80009eb4 <__sfvwrite_r+0x290>
80009eb2:	30 0c       	mov	r12,0
80009eb4:	2f dd       	sub	sp,-12
80009eb6:	d8 32       	popm	r0-r7,pc

80009eb8 <_fwalk>:
80009eb8:	d4 31       	pushm	r0-r7,lr
80009eba:	30 05       	mov	r5,0
80009ebc:	16 91       	mov	r1,r11
80009ebe:	f8 c7 ff 28 	sub	r7,r12,-216
80009ec2:	0a 92       	mov	r2,r5
80009ec4:	fe b0 fc fe 	rcall	800098c0 <__sfp_lock_acquire>
80009ec8:	3f f3       	mov	r3,-1
80009eca:	c1 68       	rjmp	80009ef6 <_fwalk+0x3e>
80009ecc:	6e 26       	ld.w	r6,r7[0x8]
80009ece:	6e 14       	ld.w	r4,r7[0x4]
80009ed0:	2f 46       	sub	r6,-12
80009ed2:	c0 c8       	rjmp	80009eea <_fwalk+0x32>
80009ed4:	8c 08       	ld.sh	r8,r6[0x0]
80009ed6:	e4 08 19 00 	cp.h	r8,r2
80009eda:	c0 70       	breq	80009ee8 <_fwalk+0x30>
80009edc:	8c 18       	ld.sh	r8,r6[0x2]
80009ede:	e6 08 19 00 	cp.h	r8,r3
80009ee2:	c0 30       	breq	80009ee8 <_fwalk+0x30>
80009ee4:	5d 11       	icall	r1
80009ee6:	18 45       	or	r5,r12
80009ee8:	2a 46       	sub	r6,-92
80009eea:	20 14       	sub	r4,1
80009eec:	ec cc 00 0c 	sub	r12,r6,12
80009ef0:	58 04       	cp.w	r4,0
80009ef2:	cf 14       	brge	80009ed4 <_fwalk+0x1c>
80009ef4:	6e 07       	ld.w	r7,r7[0x0]
80009ef6:	58 07       	cp.w	r7,0
80009ef8:	ce a1       	brne	80009ecc <_fwalk+0x14>
80009efa:	fe b0 fc e4 	rcall	800098c2 <__sfp_lock_release>
80009efe:	0a 9c       	mov	r12,r5
80009f00:	d8 32       	popm	r0-r7,pc
80009f02:	d7 03       	nop

80009f04 <_localeconv_r>:
80009f04:	fe cc d4 1c 	sub	r12,pc,-11236
80009f08:	5e fc       	retal	r12
80009f0a:	d7 03       	nop

80009f0c <__smakebuf_r>:
80009f0c:	d4 21       	pushm	r4-r7,lr
80009f0e:	20 fd       	sub	sp,60
80009f10:	96 68       	ld.sh	r8,r11[0xc]
80009f12:	16 97       	mov	r7,r11
80009f14:	18 96       	mov	r6,r12
80009f16:	e2 18 00 02 	andl	r8,0x2,COH
80009f1a:	c3 d1       	brne	80009f94 <__smakebuf_r+0x88>
80009f1c:	96 7b       	ld.sh	r11,r11[0xe]
80009f1e:	f0 0b 19 00 	cp.h	r11,r8
80009f22:	c0 55       	brlt	80009f2c <__smakebuf_r+0x20>
80009f24:	1a 9a       	mov	r10,sp
80009f26:	e0 a0 04 81 	rcall	8000a828 <_fstat_r>
80009f2a:	c0 f4       	brge	80009f48 <__smakebuf_r+0x3c>
80009f2c:	8e 65       	ld.sh	r5,r7[0xc]
80009f2e:	0a 98       	mov	r8,r5
80009f30:	ab b8       	sbr	r8,0xb
80009f32:	e2 15 00 80 	andl	r5,0x80,COH
80009f36:	ae 68       	st.h	r7[0xc],r8
80009f38:	30 04       	mov	r4,0
80009f3a:	e0 68 04 00 	mov	r8,1024
80009f3e:	f9 b5 01 40 	movne	r5,64
80009f42:	f0 05 17 00 	moveq	r5,r8
80009f46:	c1 c8       	rjmp	80009f7e <__smakebuf_r+0x72>
80009f48:	40 18       	lddsp	r8,sp[0x4]
80009f4a:	e2 18 f0 00 	andl	r8,0xf000,COH
80009f4e:	e0 48 20 00 	cp.w	r8,8192
80009f52:	5f 04       	sreq	r4
80009f54:	e0 48 80 00 	cp.w	r8,32768
80009f58:	c0 e1       	brne	80009f74 <__smakebuf_r+0x68>
80009f5a:	6e b9       	ld.w	r9,r7[0x2c]
80009f5c:	fe c8 f9 1c 	sub	r8,pc,-1764
80009f60:	10 39       	cp.w	r9,r8
80009f62:	c0 91       	brne	80009f74 <__smakebuf_r+0x68>
80009f64:	8e 68       	ld.sh	r8,r7[0xc]
80009f66:	e0 65 04 00 	mov	r5,1024
80009f6a:	ab a8       	sbr	r8,0xa
80009f6c:	ef 45 00 50 	st.w	r7[80],r5
80009f70:	ae 68       	st.h	r7[0xc],r8
80009f72:	c0 68       	rjmp	80009f7e <__smakebuf_r+0x72>
80009f74:	8e 68       	ld.sh	r8,r7[0xc]
80009f76:	e0 65 04 00 	mov	r5,1024
80009f7a:	ab b8       	sbr	r8,0xb
80009f7c:	ae 68       	st.h	r7[0xc],r8
80009f7e:	0a 9b       	mov	r11,r5
80009f80:	0c 9c       	mov	r12,r6
80009f82:	fe b0 df 23 	rcall	80005dc8 <_malloc_r>
80009f86:	8e 68       	ld.sh	r8,r7[0xc]
80009f88:	c0 d1       	brne	80009fa2 <__smakebuf_r+0x96>
80009f8a:	ed b8 00 09 	bld	r8,0x9
80009f8e:	c1 b0       	breq	80009fc4 <__smakebuf_r+0xb8>
80009f90:	a1 b8       	sbr	r8,0x1
80009f92:	ae 68       	st.h	r7[0xc],r8
80009f94:	ee c8 ff b9 	sub	r8,r7,-71
80009f98:	8f 48       	st.w	r7[0x10],r8
80009f9a:	8f 08       	st.w	r7[0x0],r8
80009f9c:	30 18       	mov	r8,1
80009f9e:	8f 58       	st.w	r7[0x14],r8
80009fa0:	c1 28       	rjmp	80009fc4 <__smakebuf_r+0xb8>
80009fa2:	a7 b8       	sbr	r8,0x7
80009fa4:	8f 4c       	st.w	r7[0x10],r12
80009fa6:	ae 68       	st.h	r7[0xc],r8
80009fa8:	8f 55       	st.w	r7[0x14],r5
80009faa:	fe c8 06 e6 	sub	r8,pc,1766
80009fae:	8f 0c       	st.w	r7[0x0],r12
80009fb0:	8d a8       	st.w	r6[0x28],r8
80009fb2:	58 04       	cp.w	r4,0
80009fb4:	c0 80       	breq	80009fc4 <__smakebuf_r+0xb8>
80009fb6:	8e 7c       	ld.sh	r12,r7[0xe]
80009fb8:	fe b0 e3 94 	rcall	800066e0 <isatty>
80009fbc:	c0 40       	breq	80009fc4 <__smakebuf_r+0xb8>
80009fbe:	8e 68       	ld.sh	r8,r7[0xc]
80009fc0:	a1 a8       	sbr	r8,0x0
80009fc2:	ae 68       	st.h	r7[0xc],r8
80009fc4:	2f 1d       	sub	sp,-60
80009fc6:	d8 22       	popm	r4-r7,pc

80009fc8 <memchr>:
80009fc8:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
80009fcc:	c0 68       	rjmp	80009fd8 <memchr+0x10>
80009fce:	20 1a       	sub	r10,1
80009fd0:	19 88       	ld.ub	r8,r12[0x0]
80009fd2:	16 38       	cp.w	r8,r11
80009fd4:	5e 0c       	reteq	r12
80009fd6:	2f fc       	sub	r12,-1
80009fd8:	58 0a       	cp.w	r10,0
80009fda:	cf a1       	brne	80009fce <memchr+0x6>
80009fdc:	5e fa       	retal	r10

80009fde <memmove>:
80009fde:	d4 01       	pushm	lr
80009fe0:	18 3b       	cp.w	r11,r12
80009fe2:	c1 92       	brcc	8000a014 <memmove+0x36>
80009fe4:	f6 0a 00 09 	add	r9,r11,r10
80009fe8:	12 3c       	cp.w	r12,r9
80009fea:	c1 52       	brcc	8000a014 <memmove+0x36>
80009fec:	f8 0a 00 0b 	add	r11,r12,r10
80009ff0:	30 08       	mov	r8,0
80009ff2:	c0 68       	rjmp	80009ffe <memmove+0x20>
80009ff4:	f2 08 07 0e 	ld.ub	lr,r9[r8]
80009ff8:	20 1a       	sub	r10,1
80009ffa:	f6 08 0b 0e 	st.b	r11[r8],lr
80009ffe:	20 18       	sub	r8,1
8000a000:	58 0a       	cp.w	r10,0
8000a002:	cf 91       	brne	80009ff4 <memmove+0x16>
8000a004:	d8 02       	popm	pc
8000a006:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a00a:	20 1a       	sub	r10,1
8000a00c:	f8 08 0b 09 	st.b	r12[r8],r9
8000a010:	2f f8       	sub	r8,-1
8000a012:	c0 28       	rjmp	8000a016 <memmove+0x38>
8000a014:	30 08       	mov	r8,0
8000a016:	58 0a       	cp.w	r10,0
8000a018:	cf 71       	brne	8000a006 <memmove+0x28>
8000a01a:	d8 02       	popm	pc

8000a01c <__hi0bits>:
8000a01c:	18 98       	mov	r8,r12
8000a01e:	e0 1c 00 00 	andl	r12,0x0
8000a022:	f0 09 15 10 	lsl	r9,r8,0x10
8000a026:	58 0c       	cp.w	r12,0
8000a028:	f2 08 17 00 	moveq	r8,r9
8000a02c:	f9 bc 00 10 	moveq	r12,16
8000a030:	f9 bc 01 00 	movne	r12,0
8000a034:	10 9a       	mov	r10,r8
8000a036:	f0 09 15 08 	lsl	r9,r8,0x8
8000a03a:	e6 1a ff 00 	andh	r10,0xff00,COH
8000a03e:	f7 bc 00 f8 	subeq	r12,-8
8000a042:	f2 08 17 00 	moveq	r8,r9
8000a046:	10 9a       	mov	r10,r8
8000a048:	f0 09 15 04 	lsl	r9,r8,0x4
8000a04c:	e6 1a f0 00 	andh	r10,0xf000,COH
8000a050:	f7 bc 00 fc 	subeq	r12,-4
8000a054:	f2 08 17 00 	moveq	r8,r9
8000a058:	10 9a       	mov	r10,r8
8000a05a:	f0 09 15 02 	lsl	r9,r8,0x2
8000a05e:	e6 1a c0 00 	andh	r10,0xc000,COH
8000a062:	f7 bc 00 fe 	subeq	r12,-2
8000a066:	f2 08 17 00 	moveq	r8,r9
8000a06a:	58 08       	cp.w	r8,0
8000a06c:	5e 5c       	retlt	r12
8000a06e:	ed b8 00 1e 	bld	r8,0x1e
8000a072:	f9 bc 01 20 	movne	r12,32
8000a076:	f7 bc 00 ff 	subeq	r12,-1
8000a07a:	5e fc       	retal	r12

8000a07c <__lo0bits>:
8000a07c:	18 99       	mov	r9,r12
8000a07e:	78 08       	ld.w	r8,r12[0x0]
8000a080:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000a084:	c1 50       	breq	8000a0ae <__lo0bits+0x32>
8000a086:	ed b8 00 00 	bld	r8,0x0
8000a08a:	c0 21       	brne	8000a08e <__lo0bits+0x12>
8000a08c:	5e fd       	retal	0
8000a08e:	10 9b       	mov	r11,r8
8000a090:	f0 0a 16 01 	lsr	r10,r8,0x1
8000a094:	e2 1b 00 02 	andl	r11,0x2,COH
8000a098:	a3 88       	lsr	r8,0x2
8000a09a:	58 0b       	cp.w	r11,0
8000a09c:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000a0a0:	f9 bc 01 01 	movne	r12,1
8000a0a4:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000a0a8:	f9 bc 00 02 	moveq	r12,2
8000a0ac:	5e fc       	retal	r12
8000a0ae:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000a0b2:	f0 0b 16 10 	lsr	r11,r8,0x10
8000a0b6:	58 0a       	cp.w	r10,0
8000a0b8:	f6 08 17 00 	moveq	r8,r11
8000a0bc:	f9 bc 00 10 	moveq	r12,16
8000a0c0:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000a0c4:	f0 0a 16 08 	lsr	r10,r8,0x8
8000a0c8:	58 0b       	cp.w	r11,0
8000a0ca:	f7 bc 00 f8 	subeq	r12,-8
8000a0ce:	f4 08 17 00 	moveq	r8,r10
8000a0d2:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000a0d6:	f0 0a 16 04 	lsr	r10,r8,0x4
8000a0da:	58 0b       	cp.w	r11,0
8000a0dc:	f7 bc 00 fc 	subeq	r12,-4
8000a0e0:	f4 08 17 00 	moveq	r8,r10
8000a0e4:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000a0e8:	f0 0a 16 02 	lsr	r10,r8,0x2
8000a0ec:	58 0b       	cp.w	r11,0
8000a0ee:	f7 bc 00 fe 	subeq	r12,-2
8000a0f2:	f4 08 17 00 	moveq	r8,r10
8000a0f6:	ed b8 00 00 	bld	r8,0x0
8000a0fa:	c0 60       	breq	8000a106 <__lo0bits+0x8a>
8000a0fc:	a1 98       	lsr	r8,0x1
8000a0fe:	c0 31       	brne	8000a104 <__lo0bits+0x88>
8000a100:	32 0c       	mov	r12,32
8000a102:	5e fc       	retal	r12
8000a104:	2f fc       	sub	r12,-1
8000a106:	93 08       	st.w	r9[0x0],r8
8000a108:	5e fc       	retal	r12

8000a10a <__mcmp>:
8000a10a:	d4 01       	pushm	lr
8000a10c:	18 98       	mov	r8,r12
8000a10e:	76 49       	ld.w	r9,r11[0x10]
8000a110:	78 4c       	ld.w	r12,r12[0x10]
8000a112:	12 1c       	sub	r12,r9
8000a114:	c1 31       	brne	8000a13a <__mcmp+0x30>
8000a116:	2f b9       	sub	r9,-5
8000a118:	a3 69       	lsl	r9,0x2
8000a11a:	12 0b       	add	r11,r9
8000a11c:	f0 09 00 09 	add	r9,r8,r9
8000a120:	2e c8       	sub	r8,-20
8000a122:	13 4e       	ld.w	lr,--r9
8000a124:	17 4a       	ld.w	r10,--r11
8000a126:	14 3e       	cp.w	lr,r10
8000a128:	c0 60       	breq	8000a134 <__mcmp+0x2a>
8000a12a:	f9 bc 03 ff 	movlo	r12,-1
8000a12e:	f9 bc 02 01 	movhs	r12,1
8000a132:	d8 02       	popm	pc
8000a134:	10 39       	cp.w	r9,r8
8000a136:	fe 9b ff f6 	brhi	8000a122 <__mcmp+0x18>
8000a13a:	d8 02       	popm	pc

8000a13c <_Bfree>:
8000a13c:	d4 21       	pushm	r4-r7,lr
8000a13e:	18 97       	mov	r7,r12
8000a140:	16 95       	mov	r5,r11
8000a142:	78 96       	ld.w	r6,r12[0x24]
8000a144:	58 06       	cp.w	r6,0
8000a146:	c0 91       	brne	8000a158 <_Bfree+0x1c>
8000a148:	31 0c       	mov	r12,16
8000a14a:	fe b0 de 37 	rcall	80005db8 <malloc>
8000a14e:	99 36       	st.w	r12[0xc],r6
8000a150:	8f 9c       	st.w	r7[0x24],r12
8000a152:	99 16       	st.w	r12[0x4],r6
8000a154:	99 26       	st.w	r12[0x8],r6
8000a156:	99 06       	st.w	r12[0x0],r6
8000a158:	58 05       	cp.w	r5,0
8000a15a:	c0 90       	breq	8000a16c <_Bfree+0x30>
8000a15c:	6a 19       	ld.w	r9,r5[0x4]
8000a15e:	6e 98       	ld.w	r8,r7[0x24]
8000a160:	70 38       	ld.w	r8,r8[0xc]
8000a162:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000a166:	8b 0a       	st.w	r5[0x0],r10
8000a168:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000a16c:	d8 22       	popm	r4-r7,pc
8000a16e:	d7 03       	nop

8000a170 <_Balloc>:
8000a170:	d4 21       	pushm	r4-r7,lr
8000a172:	18 97       	mov	r7,r12
8000a174:	16 96       	mov	r6,r11
8000a176:	78 95       	ld.w	r5,r12[0x24]
8000a178:	58 05       	cp.w	r5,0
8000a17a:	c0 91       	brne	8000a18c <_Balloc+0x1c>
8000a17c:	31 0c       	mov	r12,16
8000a17e:	fe b0 de 1d 	rcall	80005db8 <malloc>
8000a182:	99 35       	st.w	r12[0xc],r5
8000a184:	8f 9c       	st.w	r7[0x24],r12
8000a186:	99 15       	st.w	r12[0x4],r5
8000a188:	99 25       	st.w	r12[0x8],r5
8000a18a:	99 05       	st.w	r12[0x0],r5
8000a18c:	6e 95       	ld.w	r5,r7[0x24]
8000a18e:	6a 38       	ld.w	r8,r5[0xc]
8000a190:	58 08       	cp.w	r8,0
8000a192:	c0 b1       	brne	8000a1a8 <_Balloc+0x38>
8000a194:	31 0a       	mov	r10,16
8000a196:	30 4b       	mov	r11,4
8000a198:	0e 9c       	mov	r12,r7
8000a19a:	e0 a0 02 a7 	rcall	8000a6e8 <_calloc_r>
8000a19e:	8b 3c       	st.w	r5[0xc],r12
8000a1a0:	6e 98       	ld.w	r8,r7[0x24]
8000a1a2:	70 3c       	ld.w	r12,r8[0xc]
8000a1a4:	58 0c       	cp.w	r12,0
8000a1a6:	c1 b0       	breq	8000a1dc <_Balloc+0x6c>
8000a1a8:	6e 98       	ld.w	r8,r7[0x24]
8000a1aa:	70 38       	ld.w	r8,r8[0xc]
8000a1ac:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000a1b0:	70 0c       	ld.w	r12,r8[0x0]
8000a1b2:	58 0c       	cp.w	r12,0
8000a1b4:	c0 40       	breq	8000a1bc <_Balloc+0x4c>
8000a1b6:	78 09       	ld.w	r9,r12[0x0]
8000a1b8:	91 09       	st.w	r8[0x0],r9
8000a1ba:	c0 e8       	rjmp	8000a1d6 <_Balloc+0x66>
8000a1bc:	0e 9c       	mov	r12,r7
8000a1be:	30 17       	mov	r7,1
8000a1c0:	0e 9b       	mov	r11,r7
8000a1c2:	ee 06 09 47 	lsl	r7,r7,r6
8000a1c6:	ee ca ff fb 	sub	r10,r7,-5
8000a1ca:	a3 6a       	lsl	r10,0x2
8000a1cc:	e0 a0 02 8e 	rcall	8000a6e8 <_calloc_r>
8000a1d0:	c0 60       	breq	8000a1dc <_Balloc+0x6c>
8000a1d2:	99 16       	st.w	r12[0x4],r6
8000a1d4:	99 27       	st.w	r12[0x8],r7
8000a1d6:	30 08       	mov	r8,0
8000a1d8:	99 38       	st.w	r12[0xc],r8
8000a1da:	99 48       	st.w	r12[0x10],r8
8000a1dc:	d8 22       	popm	r4-r7,pc
8000a1de:	d7 03       	nop

8000a1e0 <__d2b>:
8000a1e0:	d4 31       	pushm	r0-r7,lr
8000a1e2:	20 2d       	sub	sp,8
8000a1e4:	16 93       	mov	r3,r11
8000a1e6:	12 96       	mov	r6,r9
8000a1e8:	10 95       	mov	r5,r8
8000a1ea:	14 92       	mov	r2,r10
8000a1ec:	30 1b       	mov	r11,1
8000a1ee:	cc 1f       	rcall	8000a170 <_Balloc>
8000a1f0:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000a1f4:	50 09       	stdsp	sp[0x0],r9
8000a1f6:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000a1fa:	b5 a9       	sbr	r9,0x14
8000a1fc:	f0 01 16 14 	lsr	r1,r8,0x14
8000a200:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a204:	18 94       	mov	r4,r12
8000a206:	58 02       	cp.w	r2,0
8000a208:	c1 d0       	breq	8000a242 <__d2b+0x62>
8000a20a:	fa cc ff f8 	sub	r12,sp,-8
8000a20e:	18 d2       	st.w	--r12,r2
8000a210:	c3 6f       	rcall	8000a07c <__lo0bits>
8000a212:	40 18       	lddsp	r8,sp[0x4]
8000a214:	c0 d0       	breq	8000a22e <__d2b+0x4e>
8000a216:	40 09       	lddsp	r9,sp[0x0]
8000a218:	f8 0a 11 20 	rsub	r10,r12,32
8000a21c:	f2 0a 09 4a 	lsl	r10,r9,r10
8000a220:	f5 e8 10 08 	or	r8,r10,r8
8000a224:	89 58       	st.w	r4[0x14],r8
8000a226:	f2 0c 0a 49 	lsr	r9,r9,r12
8000a22a:	50 09       	stdsp	sp[0x0],r9
8000a22c:	c0 28       	rjmp	8000a230 <__d2b+0x50>
8000a22e:	89 58       	st.w	r4[0x14],r8
8000a230:	40 08       	lddsp	r8,sp[0x0]
8000a232:	58 08       	cp.w	r8,0
8000a234:	f9 b3 01 02 	movne	r3,2
8000a238:	f9 b3 00 01 	moveq	r3,1
8000a23c:	89 68       	st.w	r4[0x18],r8
8000a23e:	89 43       	st.w	r4[0x10],r3
8000a240:	c0 88       	rjmp	8000a250 <__d2b+0x70>
8000a242:	1a 9c       	mov	r12,sp
8000a244:	c1 cf       	rcall	8000a07c <__lo0bits>
8000a246:	30 13       	mov	r3,1
8000a248:	40 08       	lddsp	r8,sp[0x0]
8000a24a:	2e 0c       	sub	r12,-32
8000a24c:	89 43       	st.w	r4[0x10],r3
8000a24e:	89 58       	st.w	r4[0x14],r8
8000a250:	58 01       	cp.w	r1,0
8000a252:	c0 90       	breq	8000a264 <__d2b+0x84>
8000a254:	e2 c1 04 33 	sub	r1,r1,1075
8000a258:	18 01       	add	r1,r12
8000a25a:	8d 01       	st.w	r6[0x0],r1
8000a25c:	f8 0c 11 35 	rsub	r12,r12,53
8000a260:	8b 0c       	st.w	r5[0x0],r12
8000a262:	c0 c8       	rjmp	8000a27a <__d2b+0x9a>
8000a264:	e6 c8 ff fc 	sub	r8,r3,-4
8000a268:	f8 cc 04 32 	sub	r12,r12,1074
8000a26c:	a5 73       	lsl	r3,0x5
8000a26e:	8d 0c       	st.w	r6[0x0],r12
8000a270:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000a274:	cd 4e       	rcall	8000a01c <__hi0bits>
8000a276:	18 13       	sub	r3,r12
8000a278:	8b 03       	st.w	r5[0x0],r3
8000a27a:	08 9c       	mov	r12,r4
8000a27c:	2f ed       	sub	sp,-8
8000a27e:	d8 32       	popm	r0-r7,pc

8000a280 <__mdiff>:
8000a280:	d4 31       	pushm	r0-r7,lr
8000a282:	74 48       	ld.w	r8,r10[0x10]
8000a284:	76 45       	ld.w	r5,r11[0x10]
8000a286:	16 97       	mov	r7,r11
8000a288:	14 96       	mov	r6,r10
8000a28a:	10 15       	sub	r5,r8
8000a28c:	c1 31       	brne	8000a2b2 <__mdiff+0x32>
8000a28e:	2f b8       	sub	r8,-5
8000a290:	ee ce ff ec 	sub	lr,r7,-20
8000a294:	a3 68       	lsl	r8,0x2
8000a296:	f4 08 00 0b 	add	r11,r10,r8
8000a29a:	ee 08 00 08 	add	r8,r7,r8
8000a29e:	11 4a       	ld.w	r10,--r8
8000a2a0:	17 49       	ld.w	r9,--r11
8000a2a2:	12 3a       	cp.w	r10,r9
8000a2a4:	c0 30       	breq	8000a2aa <__mdiff+0x2a>
8000a2a6:	c0 e2       	brcc	8000a2c2 <__mdiff+0x42>
8000a2a8:	c0 78       	rjmp	8000a2b6 <__mdiff+0x36>
8000a2aa:	1c 38       	cp.w	r8,lr
8000a2ac:	fe 9b ff f9 	brhi	8000a29e <__mdiff+0x1e>
8000a2b0:	c4 98       	rjmp	8000a342 <__mdiff+0xc2>
8000a2b2:	58 05       	cp.w	r5,0
8000a2b4:	c0 64       	brge	8000a2c0 <__mdiff+0x40>
8000a2b6:	0e 98       	mov	r8,r7
8000a2b8:	30 15       	mov	r5,1
8000a2ba:	0c 97       	mov	r7,r6
8000a2bc:	10 96       	mov	r6,r8
8000a2be:	c0 28       	rjmp	8000a2c2 <__mdiff+0x42>
8000a2c0:	30 05       	mov	r5,0
8000a2c2:	6e 1b       	ld.w	r11,r7[0x4]
8000a2c4:	c5 6f       	rcall	8000a170 <_Balloc>
8000a2c6:	6e 49       	ld.w	r9,r7[0x10]
8000a2c8:	6c 44       	ld.w	r4,r6[0x10]
8000a2ca:	99 35       	st.w	r12[0xc],r5
8000a2cc:	2f b4       	sub	r4,-5
8000a2ce:	f2 c5 ff fb 	sub	r5,r9,-5
8000a2d2:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000a2d6:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000a2da:	2e c6       	sub	r6,-20
8000a2dc:	2e c7       	sub	r7,-20
8000a2de:	f8 c8 ff ec 	sub	r8,r12,-20
8000a2e2:	30 0a       	mov	r10,0
8000a2e4:	0f 0e       	ld.w	lr,r7++
8000a2e6:	0d 0b       	ld.w	r11,r6++
8000a2e8:	fc 02 16 10 	lsr	r2,lr,0x10
8000a2ec:	f6 03 16 10 	lsr	r3,r11,0x10
8000a2f0:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a2f4:	e4 03 01 03 	sub	r3,r2,r3
8000a2f8:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a2fc:	fc 0b 01 0b 	sub	r11,lr,r11
8000a300:	f6 0a 00 0a 	add	r10,r11,r10
8000a304:	b0 1a       	st.h	r8[0x2],r10
8000a306:	b1 4a       	asr	r10,0x10
8000a308:	e6 0a 00 0a 	add	r10,r3,r10
8000a30c:	b0 0a       	st.h	r8[0x0],r10
8000a30e:	2f c8       	sub	r8,-4
8000a310:	b1 4a       	asr	r10,0x10
8000a312:	08 36       	cp.w	r6,r4
8000a314:	ce 83       	brcs	8000a2e4 <__mdiff+0x64>
8000a316:	c0 d8       	rjmp	8000a330 <__mdiff+0xb0>
8000a318:	0f 0b       	ld.w	r11,r7++
8000a31a:	f6 0e 16 10 	lsr	lr,r11,0x10
8000a31e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a322:	16 0a       	add	r10,r11
8000a324:	b0 1a       	st.h	r8[0x2],r10
8000a326:	b1 4a       	asr	r10,0x10
8000a328:	1c 0a       	add	r10,lr
8000a32a:	b0 0a       	st.h	r8[0x0],r10
8000a32c:	2f c8       	sub	r8,-4
8000a32e:	b1 4a       	asr	r10,0x10
8000a330:	0a 37       	cp.w	r7,r5
8000a332:	cf 33       	brcs	8000a318 <__mdiff+0x98>
8000a334:	c0 28       	rjmp	8000a338 <__mdiff+0xb8>
8000a336:	20 19       	sub	r9,1
8000a338:	11 4a       	ld.w	r10,--r8
8000a33a:	58 0a       	cp.w	r10,0
8000a33c:	cf d0       	breq	8000a336 <__mdiff+0xb6>
8000a33e:	99 49       	st.w	r12[0x10],r9
8000a340:	d8 32       	popm	r0-r7,pc
8000a342:	30 0b       	mov	r11,0
8000a344:	c1 6f       	rcall	8000a170 <_Balloc>
8000a346:	30 18       	mov	r8,1
8000a348:	99 48       	st.w	r12[0x10],r8
8000a34a:	30 08       	mov	r8,0
8000a34c:	99 58       	st.w	r12[0x14],r8
8000a34e:	d8 32       	popm	r0-r7,pc

8000a350 <__lshift>:
8000a350:	d4 31       	pushm	r0-r7,lr
8000a352:	16 97       	mov	r7,r11
8000a354:	76 46       	ld.w	r6,r11[0x10]
8000a356:	f4 02 14 05 	asr	r2,r10,0x5
8000a35a:	2f f6       	sub	r6,-1
8000a35c:	14 93       	mov	r3,r10
8000a35e:	18 94       	mov	r4,r12
8000a360:	04 06       	add	r6,r2
8000a362:	76 1b       	ld.w	r11,r11[0x4]
8000a364:	6e 28       	ld.w	r8,r7[0x8]
8000a366:	c0 38       	rjmp	8000a36c <__lshift+0x1c>
8000a368:	2f fb       	sub	r11,-1
8000a36a:	a1 78       	lsl	r8,0x1
8000a36c:	10 36       	cp.w	r6,r8
8000a36e:	fe 99 ff fd 	brgt	8000a368 <__lshift+0x18>
8000a372:	08 9c       	mov	r12,r4
8000a374:	cf ee       	rcall	8000a170 <_Balloc>
8000a376:	30 09       	mov	r9,0
8000a378:	18 95       	mov	r5,r12
8000a37a:	f8 c8 ff ec 	sub	r8,r12,-20
8000a37e:	12 9a       	mov	r10,r9
8000a380:	c0 38       	rjmp	8000a386 <__lshift+0x36>
8000a382:	10 aa       	st.w	r8++,r10
8000a384:	2f f9       	sub	r9,-1
8000a386:	04 39       	cp.w	r9,r2
8000a388:	cf d5       	brlt	8000a382 <__lshift+0x32>
8000a38a:	6e 4b       	ld.w	r11,r7[0x10]
8000a38c:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000a390:	2f bb       	sub	r11,-5
8000a392:	ee c9 ff ec 	sub	r9,r7,-20
8000a396:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000a39a:	58 03       	cp.w	r3,0
8000a39c:	c1 30       	breq	8000a3c2 <__lshift+0x72>
8000a39e:	e6 0c 11 20 	rsub	r12,r3,32
8000a3a2:	30 0a       	mov	r10,0
8000a3a4:	72 02       	ld.w	r2,r9[0x0]
8000a3a6:	e4 03 09 42 	lsl	r2,r2,r3
8000a3aa:	04 4a       	or	r10,r2
8000a3ac:	10 aa       	st.w	r8++,r10
8000a3ae:	13 0a       	ld.w	r10,r9++
8000a3b0:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000a3b4:	16 39       	cp.w	r9,r11
8000a3b6:	cf 73       	brcs	8000a3a4 <__lshift+0x54>
8000a3b8:	91 0a       	st.w	r8[0x0],r10
8000a3ba:	58 0a       	cp.w	r10,0
8000a3bc:	c0 70       	breq	8000a3ca <__lshift+0x7a>
8000a3be:	2f f6       	sub	r6,-1
8000a3c0:	c0 58       	rjmp	8000a3ca <__lshift+0x7a>
8000a3c2:	13 0a       	ld.w	r10,r9++
8000a3c4:	10 aa       	st.w	r8++,r10
8000a3c6:	16 39       	cp.w	r9,r11
8000a3c8:	cf d3       	brcs	8000a3c2 <__lshift+0x72>
8000a3ca:	08 9c       	mov	r12,r4
8000a3cc:	20 16       	sub	r6,1
8000a3ce:	0e 9b       	mov	r11,r7
8000a3d0:	8b 46       	st.w	r5[0x10],r6
8000a3d2:	cb 5e       	rcall	8000a13c <_Bfree>
8000a3d4:	0a 9c       	mov	r12,r5
8000a3d6:	d8 32       	popm	r0-r7,pc

8000a3d8 <__multiply>:
8000a3d8:	d4 31       	pushm	r0-r7,lr
8000a3da:	20 2d       	sub	sp,8
8000a3dc:	76 49       	ld.w	r9,r11[0x10]
8000a3de:	74 48       	ld.w	r8,r10[0x10]
8000a3e0:	16 96       	mov	r6,r11
8000a3e2:	14 95       	mov	r5,r10
8000a3e4:	10 39       	cp.w	r9,r8
8000a3e6:	ec 08 17 50 	movlt	r8,r6
8000a3ea:	ea 06 17 50 	movlt	r6,r5
8000a3ee:	f0 05 17 50 	movlt	r5,r8
8000a3f2:	6c 28       	ld.w	r8,r6[0x8]
8000a3f4:	76 43       	ld.w	r3,r11[0x10]
8000a3f6:	74 42       	ld.w	r2,r10[0x10]
8000a3f8:	76 1b       	ld.w	r11,r11[0x4]
8000a3fa:	e4 03 00 07 	add	r7,r2,r3
8000a3fe:	10 37       	cp.w	r7,r8
8000a400:	f7 bb 09 ff 	subgt	r11,-1
8000a404:	cb 6e       	rcall	8000a170 <_Balloc>
8000a406:	ee c4 ff fb 	sub	r4,r7,-5
8000a40a:	f8 c9 ff ec 	sub	r9,r12,-20
8000a40e:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000a412:	30 0a       	mov	r10,0
8000a414:	12 98       	mov	r8,r9
8000a416:	c0 28       	rjmp	8000a41a <__multiply+0x42>
8000a418:	10 aa       	st.w	r8++,r10
8000a41a:	08 38       	cp.w	r8,r4
8000a41c:	cf e3       	brcs	8000a418 <__multiply+0x40>
8000a41e:	2f b3       	sub	r3,-5
8000a420:	2f b2       	sub	r2,-5
8000a422:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000a426:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000a42a:	ec cb ff ec 	sub	r11,r6,-20
8000a42e:	50 12       	stdsp	sp[0x4],r2
8000a430:	ea ca ff ec 	sub	r10,r5,-20
8000a434:	c4 48       	rjmp	8000a4bc <__multiply+0xe4>
8000a436:	94 95       	ld.uh	r5,r10[0x2]
8000a438:	58 05       	cp.w	r5,0
8000a43a:	c2 00       	breq	8000a47a <__multiply+0xa2>
8000a43c:	12 98       	mov	r8,r9
8000a43e:	16 96       	mov	r6,r11
8000a440:	30 0e       	mov	lr,0
8000a442:	50 09       	stdsp	sp[0x0],r9
8000a444:	0d 02       	ld.w	r2,r6++
8000a446:	e4 00 16 10 	lsr	r0,r2,0x10
8000a44a:	70 01       	ld.w	r1,r8[0x0]
8000a44c:	70 09       	ld.w	r9,r8[0x0]
8000a44e:	b1 81       	lsr	r1,0x10
8000a450:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000a454:	e0 05 03 41 	mac	r1,r0,r5
8000a458:	ab 32       	mul	r2,r5
8000a45a:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000a45e:	00 02       	add	r2,r0
8000a460:	e4 0e 00 0e 	add	lr,r2,lr
8000a464:	b0 1e       	st.h	r8[0x2],lr
8000a466:	b1 8e       	lsr	lr,0x10
8000a468:	1c 01       	add	r1,lr
8000a46a:	b0 01       	st.h	r8[0x0],r1
8000a46c:	e2 0e 16 10 	lsr	lr,r1,0x10
8000a470:	2f c8       	sub	r8,-4
8000a472:	06 36       	cp.w	r6,r3
8000a474:	ce 83       	brcs	8000a444 <__multiply+0x6c>
8000a476:	40 09       	lddsp	r9,sp[0x0]
8000a478:	91 0e       	st.w	r8[0x0],lr
8000a47a:	94 86       	ld.uh	r6,r10[0x0]
8000a47c:	58 06       	cp.w	r6,0
8000a47e:	c1 d0       	breq	8000a4b8 <__multiply+0xe0>
8000a480:	72 02       	ld.w	r2,r9[0x0]
8000a482:	12 98       	mov	r8,r9
8000a484:	16 9e       	mov	lr,r11
8000a486:	30 05       	mov	r5,0
8000a488:	b0 12       	st.h	r8[0x2],r2
8000a48a:	1d 01       	ld.w	r1,lr++
8000a48c:	90 82       	ld.uh	r2,r8[0x0]
8000a48e:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000a492:	ad 30       	mul	r0,r6
8000a494:	e0 02 00 02 	add	r2,r0,r2
8000a498:	e4 05 00 05 	add	r5,r2,r5
8000a49c:	b0 05       	st.h	r8[0x0],r5
8000a49e:	b1 85       	lsr	r5,0x10
8000a4a0:	b1 81       	lsr	r1,0x10
8000a4a2:	2f c8       	sub	r8,-4
8000a4a4:	ad 31       	mul	r1,r6
8000a4a6:	90 92       	ld.uh	r2,r8[0x2]
8000a4a8:	e2 02 00 02 	add	r2,r1,r2
8000a4ac:	0a 02       	add	r2,r5
8000a4ae:	e4 05 16 10 	lsr	r5,r2,0x10
8000a4b2:	06 3e       	cp.w	lr,r3
8000a4b4:	ce a3       	brcs	8000a488 <__multiply+0xb0>
8000a4b6:	91 02       	st.w	r8[0x0],r2
8000a4b8:	2f ca       	sub	r10,-4
8000a4ba:	2f c9       	sub	r9,-4
8000a4bc:	40 18       	lddsp	r8,sp[0x4]
8000a4be:	10 3a       	cp.w	r10,r8
8000a4c0:	cb b3       	brcs	8000a436 <__multiply+0x5e>
8000a4c2:	c0 28       	rjmp	8000a4c6 <__multiply+0xee>
8000a4c4:	20 17       	sub	r7,1
8000a4c6:	58 07       	cp.w	r7,0
8000a4c8:	e0 8a 00 05 	brle	8000a4d2 <__multiply+0xfa>
8000a4cc:	09 48       	ld.w	r8,--r4
8000a4ce:	58 08       	cp.w	r8,0
8000a4d0:	cf a0       	breq	8000a4c4 <__multiply+0xec>
8000a4d2:	99 47       	st.w	r12[0x10],r7
8000a4d4:	2f ed       	sub	sp,-8
8000a4d6:	d8 32       	popm	r0-r7,pc

8000a4d8 <__i2b>:
8000a4d8:	d4 21       	pushm	r4-r7,lr
8000a4da:	16 97       	mov	r7,r11
8000a4dc:	30 1b       	mov	r11,1
8000a4de:	c4 9e       	rcall	8000a170 <_Balloc>
8000a4e0:	30 19       	mov	r9,1
8000a4e2:	99 57       	st.w	r12[0x14],r7
8000a4e4:	99 49       	st.w	r12[0x10],r9
8000a4e6:	d8 22       	popm	r4-r7,pc

8000a4e8 <__multadd>:
8000a4e8:	d4 31       	pushm	r0-r7,lr
8000a4ea:	30 08       	mov	r8,0
8000a4ec:	12 95       	mov	r5,r9
8000a4ee:	16 97       	mov	r7,r11
8000a4f0:	18 96       	mov	r6,r12
8000a4f2:	76 44       	ld.w	r4,r11[0x10]
8000a4f4:	f6 c9 ff ec 	sub	r9,r11,-20
8000a4f8:	72 0b       	ld.w	r11,r9[0x0]
8000a4fa:	f6 0c 16 10 	lsr	r12,r11,0x10
8000a4fe:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a502:	f4 0c 02 4c 	mul	r12,r10,r12
8000a506:	f4 0b 03 45 	mac	r5,r10,r11
8000a50a:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000a50e:	b1 85       	lsr	r5,0x10
8000a510:	18 05       	add	r5,r12
8000a512:	ea 0c 15 10 	lsl	r12,r5,0x10
8000a516:	f8 0b 00 0b 	add	r11,r12,r11
8000a51a:	12 ab       	st.w	r9++,r11
8000a51c:	2f f8       	sub	r8,-1
8000a51e:	b1 85       	lsr	r5,0x10
8000a520:	08 38       	cp.w	r8,r4
8000a522:	ce b5       	brlt	8000a4f8 <__multadd+0x10>
8000a524:	58 05       	cp.w	r5,0
8000a526:	c1 c0       	breq	8000a55e <__multadd+0x76>
8000a528:	6e 28       	ld.w	r8,r7[0x8]
8000a52a:	10 34       	cp.w	r4,r8
8000a52c:	c1 35       	brlt	8000a552 <__multadd+0x6a>
8000a52e:	6e 1b       	ld.w	r11,r7[0x4]
8000a530:	0c 9c       	mov	r12,r6
8000a532:	2f fb       	sub	r11,-1
8000a534:	c1 ee       	rcall	8000a170 <_Balloc>
8000a536:	6e 4a       	ld.w	r10,r7[0x10]
8000a538:	ee cb ff f4 	sub	r11,r7,-12
8000a53c:	18 93       	mov	r3,r12
8000a53e:	2f ea       	sub	r10,-2
8000a540:	2f 4c       	sub	r12,-12
8000a542:	a3 6a       	lsl	r10,0x2
8000a544:	fe b0 de 71 	rcall	80006226 <memcpy>
8000a548:	0e 9b       	mov	r11,r7
8000a54a:	0c 9c       	mov	r12,r6
8000a54c:	fe b0 fd f8 	rcall	8000a13c <_Bfree>
8000a550:	06 97       	mov	r7,r3
8000a552:	e8 c8 ff ff 	sub	r8,r4,-1
8000a556:	2f b4       	sub	r4,-5
8000a558:	8f 48       	st.w	r7[0x10],r8
8000a55a:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000a55e:	0e 9c       	mov	r12,r7
8000a560:	d8 32       	popm	r0-r7,pc
8000a562:	d7 03       	nop

8000a564 <__pow5mult>:
8000a564:	d4 31       	pushm	r0-r7,lr
8000a566:	14 96       	mov	r6,r10
8000a568:	18 97       	mov	r7,r12
8000a56a:	16 94       	mov	r4,r11
8000a56c:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000a570:	c0 90       	breq	8000a582 <__pow5mult+0x1e>
8000a572:	20 18       	sub	r8,1
8000a574:	fe c9 da 50 	sub	r9,pc,-9648
8000a578:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000a57c:	30 09       	mov	r9,0
8000a57e:	cb 5f       	rcall	8000a4e8 <__multadd>
8000a580:	18 94       	mov	r4,r12
8000a582:	a3 46       	asr	r6,0x2
8000a584:	c3 40       	breq	8000a5ec <__pow5mult+0x88>
8000a586:	6e 95       	ld.w	r5,r7[0x24]
8000a588:	58 05       	cp.w	r5,0
8000a58a:	c0 91       	brne	8000a59c <__pow5mult+0x38>
8000a58c:	31 0c       	mov	r12,16
8000a58e:	fe b0 dc 15 	rcall	80005db8 <malloc>
8000a592:	99 35       	st.w	r12[0xc],r5
8000a594:	8f 9c       	st.w	r7[0x24],r12
8000a596:	99 15       	st.w	r12[0x4],r5
8000a598:	99 25       	st.w	r12[0x8],r5
8000a59a:	99 05       	st.w	r12[0x0],r5
8000a59c:	6e 93       	ld.w	r3,r7[0x24]
8000a59e:	66 25       	ld.w	r5,r3[0x8]
8000a5a0:	58 05       	cp.w	r5,0
8000a5a2:	c0 c1       	brne	8000a5ba <__pow5mult+0x56>
8000a5a4:	e0 6b 02 71 	mov	r11,625
8000a5a8:	0e 9c       	mov	r12,r7
8000a5aa:	c9 7f       	rcall	8000a4d8 <__i2b>
8000a5ac:	87 2c       	st.w	r3[0x8],r12
8000a5ae:	30 08       	mov	r8,0
8000a5b0:	18 95       	mov	r5,r12
8000a5b2:	99 08       	st.w	r12[0x0],r8
8000a5b4:	c0 38       	rjmp	8000a5ba <__pow5mult+0x56>
8000a5b6:	06 9c       	mov	r12,r3
8000a5b8:	18 95       	mov	r5,r12
8000a5ba:	ed b6 00 00 	bld	r6,0x0
8000a5be:	c0 b1       	brne	8000a5d4 <__pow5mult+0x70>
8000a5c0:	08 9b       	mov	r11,r4
8000a5c2:	0a 9a       	mov	r10,r5
8000a5c4:	0e 9c       	mov	r12,r7
8000a5c6:	c0 9f       	rcall	8000a3d8 <__multiply>
8000a5c8:	08 9b       	mov	r11,r4
8000a5ca:	18 93       	mov	r3,r12
8000a5cc:	0e 9c       	mov	r12,r7
8000a5ce:	06 94       	mov	r4,r3
8000a5d0:	fe b0 fd b6 	rcall	8000a13c <_Bfree>
8000a5d4:	a1 56       	asr	r6,0x1
8000a5d6:	c0 b0       	breq	8000a5ec <__pow5mult+0x88>
8000a5d8:	6a 03       	ld.w	r3,r5[0x0]
8000a5da:	58 03       	cp.w	r3,0
8000a5dc:	ce d1       	brne	8000a5b6 <__pow5mult+0x52>
8000a5de:	0a 9a       	mov	r10,r5
8000a5e0:	0a 9b       	mov	r11,r5
8000a5e2:	0e 9c       	mov	r12,r7
8000a5e4:	cf ae       	rcall	8000a3d8 <__multiply>
8000a5e6:	8b 0c       	st.w	r5[0x0],r12
8000a5e8:	99 03       	st.w	r12[0x0],r3
8000a5ea:	ce 7b       	rjmp	8000a5b8 <__pow5mult+0x54>
8000a5ec:	08 9c       	mov	r12,r4
8000a5ee:	d8 32       	popm	r0-r7,pc

8000a5f0 <__isinfd>:
8000a5f0:	14 98       	mov	r8,r10
8000a5f2:	fc 19 7f f0 	movh	r9,0x7ff0
8000a5f6:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000a5fa:	f0 0b 11 00 	rsub	r11,r8,0
8000a5fe:	f7 e8 10 08 	or	r8,r11,r8
8000a602:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000a606:	f2 08 01 08 	sub	r8,r9,r8
8000a60a:	f0 0c 11 00 	rsub	r12,r8,0
8000a60e:	f9 e8 10 08 	or	r8,r12,r8
8000a612:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000a616:	2f fc       	sub	r12,-1
8000a618:	5e fc       	retal	r12

8000a61a <__isnand>:
8000a61a:	14 98       	mov	r8,r10
8000a61c:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000a620:	f0 0c 11 00 	rsub	r12,r8,0
8000a624:	10 4c       	or	r12,r8
8000a626:	fc 18 7f f0 	movh	r8,0x7ff0
8000a62a:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000a62e:	f0 0c 01 0c 	sub	r12,r8,r12
8000a632:	bf 9c       	lsr	r12,0x1f
8000a634:	5e fc       	retal	r12
8000a636:	d7 03       	nop

8000a638 <__sclose>:
8000a638:	d4 01       	pushm	lr
8000a63a:	96 7b       	ld.sh	r11,r11[0xe]
8000a63c:	c8 2c       	rcall	8000a740 <_close_r>
8000a63e:	d8 02       	popm	pc

8000a640 <__sseek>:
8000a640:	d4 21       	pushm	r4-r7,lr
8000a642:	16 97       	mov	r7,r11
8000a644:	96 7b       	ld.sh	r11,r11[0xe]
8000a646:	c0 3d       	rcall	8000a84c <_lseek_r>
8000a648:	8e 68       	ld.sh	r8,r7[0xc]
8000a64a:	10 99       	mov	r9,r8
8000a64c:	ad c8       	cbr	r8,0xc
8000a64e:	ad a9       	sbr	r9,0xc
8000a650:	5b fc       	cp.w	r12,-1
8000a652:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000a656:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000a65a:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000a65e:	d8 22       	popm	r4-r7,pc

8000a660 <__swrite>:
8000a660:	d4 21       	pushm	r4-r7,lr
8000a662:	96 68       	ld.sh	r8,r11[0xc]
8000a664:	16 97       	mov	r7,r11
8000a666:	14 95       	mov	r5,r10
8000a668:	12 94       	mov	r4,r9
8000a66a:	e2 18 01 00 	andl	r8,0x100,COH
8000a66e:	18 96       	mov	r6,r12
8000a670:	c0 50       	breq	8000a67a <__swrite+0x1a>
8000a672:	30 29       	mov	r9,2
8000a674:	30 0a       	mov	r10,0
8000a676:	96 7b       	ld.sh	r11,r11[0xe]
8000a678:	ce ac       	rcall	8000a84c <_lseek_r>
8000a67a:	8e 68       	ld.sh	r8,r7[0xc]
8000a67c:	ad c8       	cbr	r8,0xc
8000a67e:	08 99       	mov	r9,r4
8000a680:	0a 9a       	mov	r10,r5
8000a682:	8e 7b       	ld.sh	r11,r7[0xe]
8000a684:	0c 9c       	mov	r12,r6
8000a686:	ae 68       	st.h	r7[0xc],r8
8000a688:	c1 cc       	rcall	8000a6c0 <_write_r>
8000a68a:	d8 22       	popm	r4-r7,pc

8000a68c <__sread>:
8000a68c:	d4 21       	pushm	r4-r7,lr
8000a68e:	16 97       	mov	r7,r11
8000a690:	96 7b       	ld.sh	r11,r11[0xe]
8000a692:	cf 1c       	rcall	8000a874 <_read_r>
8000a694:	c0 65       	brlt	8000a6a0 <__sread+0x14>
8000a696:	6f 58       	ld.w	r8,r7[0x54]
8000a698:	18 08       	add	r8,r12
8000a69a:	ef 48 00 54 	st.w	r7[84],r8
8000a69e:	d8 22       	popm	r4-r7,pc
8000a6a0:	8e 68       	ld.sh	r8,r7[0xc]
8000a6a2:	ad c8       	cbr	r8,0xc
8000a6a4:	ae 68       	st.h	r7[0xc],r8
8000a6a6:	d8 22       	popm	r4-r7,pc

8000a6a8 <strlen>:
8000a6a8:	30 09       	mov	r9,0
8000a6aa:	18 98       	mov	r8,r12
8000a6ac:	c0 28       	rjmp	8000a6b0 <strlen+0x8>
8000a6ae:	2f f8       	sub	r8,-1
8000a6b0:	11 8a       	ld.ub	r10,r8[0x0]
8000a6b2:	f2 0a 18 00 	cp.b	r10,r9
8000a6b6:	cf c1       	brne	8000a6ae <strlen+0x6>
8000a6b8:	f0 0c 01 0c 	sub	r12,r8,r12
8000a6bc:	5e fc       	retal	r12
8000a6be:	d7 03       	nop

8000a6c0 <_write_r>:
8000a6c0:	d4 21       	pushm	r4-r7,lr
8000a6c2:	16 98       	mov	r8,r11
8000a6c4:	18 97       	mov	r7,r12
8000a6c6:	10 9c       	mov	r12,r8
8000a6c8:	30 08       	mov	r8,0
8000a6ca:	14 9b       	mov	r11,r10
8000a6cc:	e0 66 1f a0 	mov	r6,8096
8000a6d0:	12 9a       	mov	r10,r9
8000a6d2:	8d 08       	st.w	r6[0x0],r8
8000a6d4:	fe b0 d2 74 	rcall	80004bbc <_write>
8000a6d8:	5b fc       	cp.w	r12,-1
8000a6da:	c0 51       	brne	8000a6e4 <_write_r+0x24>
8000a6dc:	6c 08       	ld.w	r8,r6[0x0]
8000a6de:	58 08       	cp.w	r8,0
8000a6e0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000a6e4:	d8 22       	popm	r4-r7,pc
8000a6e6:	d7 03       	nop

8000a6e8 <_calloc_r>:
8000a6e8:	d4 21       	pushm	r4-r7,lr
8000a6ea:	f4 0b 02 4b 	mul	r11,r10,r11
8000a6ee:	fe b0 db 6d 	rcall	80005dc8 <_malloc_r>
8000a6f2:	18 97       	mov	r7,r12
8000a6f4:	c2 30       	breq	8000a73a <_calloc_r+0x52>
8000a6f6:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000a6fa:	e0 1a ff fc 	andl	r10,0xfffc
8000a6fe:	20 4a       	sub	r10,4
8000a700:	e0 4a 00 24 	cp.w	r10,36
8000a704:	e0 8b 00 18 	brhi	8000a734 <_calloc_r+0x4c>
8000a708:	18 98       	mov	r8,r12
8000a70a:	59 3a       	cp.w	r10,19
8000a70c:	e0 88 00 0f 	brls	8000a72a <_calloc_r+0x42>
8000a710:	30 09       	mov	r9,0
8000a712:	10 a9       	st.w	r8++,r9
8000a714:	10 a9       	st.w	r8++,r9
8000a716:	59 ba       	cp.w	r10,27
8000a718:	e0 88 00 09 	brls	8000a72a <_calloc_r+0x42>
8000a71c:	10 a9       	st.w	r8++,r9
8000a71e:	10 a9       	st.w	r8++,r9
8000a720:	e0 4a 00 24 	cp.w	r10,36
8000a724:	c0 31       	brne	8000a72a <_calloc_r+0x42>
8000a726:	10 a9       	st.w	r8++,r9
8000a728:	10 a9       	st.w	r8++,r9
8000a72a:	30 09       	mov	r9,0
8000a72c:	10 a9       	st.w	r8++,r9
8000a72e:	91 19       	st.w	r8[0x4],r9
8000a730:	91 09       	st.w	r8[0x0],r9
8000a732:	c0 48       	rjmp	8000a73a <_calloc_r+0x52>
8000a734:	30 0b       	mov	r11,0
8000a736:	fe b0 de 1c 	rcall	8000636e <memset>
8000a73a:	0e 9c       	mov	r12,r7
8000a73c:	d8 22       	popm	r4-r7,pc
8000a73e:	d7 03       	nop

8000a740 <_close_r>:
8000a740:	d4 21       	pushm	r4-r7,lr
8000a742:	30 08       	mov	r8,0
8000a744:	18 97       	mov	r7,r12
8000a746:	e0 66 1f a0 	mov	r6,8096
8000a74a:	16 9c       	mov	r12,r11
8000a74c:	8d 08       	st.w	r6[0x0],r8
8000a74e:	fe b0 df b5 	rcall	800066b8 <_close>
8000a752:	5b fc       	cp.w	r12,-1
8000a754:	c0 51       	brne	8000a75e <_close_r+0x1e>
8000a756:	6c 08       	ld.w	r8,r6[0x0]
8000a758:	58 08       	cp.w	r8,0
8000a75a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000a75e:	d8 22       	popm	r4-r7,pc

8000a760 <_fclose_r>:
8000a760:	d4 21       	pushm	r4-r7,lr
8000a762:	18 96       	mov	r6,r12
8000a764:	16 97       	mov	r7,r11
8000a766:	58 0b       	cp.w	r11,0
8000a768:	c0 31       	brne	8000a76e <_fclose_r+0xe>
8000a76a:	16 95       	mov	r5,r11
8000a76c:	c5 38       	rjmp	8000a812 <_fclose_r+0xb2>
8000a76e:	fe b0 f8 a9 	rcall	800098c0 <__sfp_lock_acquire>
8000a772:	58 06       	cp.w	r6,0
8000a774:	c0 70       	breq	8000a782 <_fclose_r+0x22>
8000a776:	6c 68       	ld.w	r8,r6[0x18]
8000a778:	58 08       	cp.w	r8,0
8000a77a:	c0 41       	brne	8000a782 <_fclose_r+0x22>
8000a77c:	0c 9c       	mov	r12,r6
8000a77e:	fe b0 f8 f3 	rcall	80009964 <__sinit>
8000a782:	fe c8 dd 02 	sub	r8,pc,-8958
8000a786:	10 37       	cp.w	r7,r8
8000a788:	c0 31       	brne	8000a78e <_fclose_r+0x2e>
8000a78a:	6c 07       	ld.w	r7,r6[0x0]
8000a78c:	c0 c8       	rjmp	8000a7a4 <_fclose_r+0x44>
8000a78e:	fe c8 dc ee 	sub	r8,pc,-8978
8000a792:	10 37       	cp.w	r7,r8
8000a794:	c0 31       	brne	8000a79a <_fclose_r+0x3a>
8000a796:	6c 17       	ld.w	r7,r6[0x4]
8000a798:	c0 68       	rjmp	8000a7a4 <_fclose_r+0x44>
8000a79a:	fe c8 dc da 	sub	r8,pc,-8998
8000a79e:	10 37       	cp.w	r7,r8
8000a7a0:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000a7a4:	8e 69       	ld.sh	r9,r7[0xc]
8000a7a6:	30 08       	mov	r8,0
8000a7a8:	f0 09 19 00 	cp.h	r9,r8
8000a7ac:	c0 51       	brne	8000a7b6 <_fclose_r+0x56>
8000a7ae:	fe b0 f8 8a 	rcall	800098c2 <__sfp_lock_release>
8000a7b2:	30 05       	mov	r5,0
8000a7b4:	c2 f8       	rjmp	8000a812 <_fclose_r+0xb2>
8000a7b6:	0e 9b       	mov	r11,r7
8000a7b8:	0c 9c       	mov	r12,r6
8000a7ba:	fe b0 f7 fd 	rcall	800097b4 <_fflush_r>
8000a7be:	6e c8       	ld.w	r8,r7[0x30]
8000a7c0:	18 95       	mov	r5,r12
8000a7c2:	58 08       	cp.w	r8,0
8000a7c4:	c0 60       	breq	8000a7d0 <_fclose_r+0x70>
8000a7c6:	6e 8b       	ld.w	r11,r7[0x20]
8000a7c8:	0c 9c       	mov	r12,r6
8000a7ca:	5d 18       	icall	r8
8000a7cc:	f9 b5 05 ff 	movlt	r5,-1
8000a7d0:	8e 68       	ld.sh	r8,r7[0xc]
8000a7d2:	ed b8 00 07 	bld	r8,0x7
8000a7d6:	c0 51       	brne	8000a7e0 <_fclose_r+0x80>
8000a7d8:	6e 4b       	ld.w	r11,r7[0x10]
8000a7da:	0c 9c       	mov	r12,r6
8000a7dc:	fe b0 f9 5e 	rcall	80009a98 <_free_r>
8000a7e0:	6e db       	ld.w	r11,r7[0x34]
8000a7e2:	58 0b       	cp.w	r11,0
8000a7e4:	c0 a0       	breq	8000a7f8 <_fclose_r+0x98>
8000a7e6:	ee c8 ff bc 	sub	r8,r7,-68
8000a7ea:	10 3b       	cp.w	r11,r8
8000a7ec:	c0 40       	breq	8000a7f4 <_fclose_r+0x94>
8000a7ee:	0c 9c       	mov	r12,r6
8000a7f0:	fe b0 f9 54 	rcall	80009a98 <_free_r>
8000a7f4:	30 08       	mov	r8,0
8000a7f6:	8f d8       	st.w	r7[0x34],r8
8000a7f8:	6f 2b       	ld.w	r11,r7[0x48]
8000a7fa:	58 0b       	cp.w	r11,0
8000a7fc:	c0 70       	breq	8000a80a <_fclose_r+0xaa>
8000a7fe:	0c 9c       	mov	r12,r6
8000a800:	fe b0 f9 4c 	rcall	80009a98 <_free_r>
8000a804:	30 08       	mov	r8,0
8000a806:	ef 48 00 48 	st.w	r7[72],r8
8000a80a:	30 08       	mov	r8,0
8000a80c:	ae 68       	st.h	r7[0xc],r8
8000a80e:	fe b0 f8 5a 	rcall	800098c2 <__sfp_lock_release>
8000a812:	0a 9c       	mov	r12,r5
8000a814:	d8 22       	popm	r4-r7,pc
8000a816:	d7 03       	nop

8000a818 <fclose>:
8000a818:	d4 01       	pushm	lr
8000a81a:	e0 68 0a 18 	mov	r8,2584
8000a81e:	18 9b       	mov	r11,r12
8000a820:	70 0c       	ld.w	r12,r8[0x0]
8000a822:	c9 ff       	rcall	8000a760 <_fclose_r>
8000a824:	d8 02       	popm	pc
8000a826:	d7 03       	nop

8000a828 <_fstat_r>:
8000a828:	d4 21       	pushm	r4-r7,lr
8000a82a:	16 98       	mov	r8,r11
8000a82c:	18 97       	mov	r7,r12
8000a82e:	10 9c       	mov	r12,r8
8000a830:	30 08       	mov	r8,0
8000a832:	e0 66 1f a0 	mov	r6,8096
8000a836:	14 9b       	mov	r11,r10
8000a838:	8d 08       	st.w	r6[0x0],r8
8000a83a:	fe b0 df 67 	rcall	80006708 <_fstat>
8000a83e:	5b fc       	cp.w	r12,-1
8000a840:	c0 51       	brne	8000a84a <_fstat_r+0x22>
8000a842:	6c 08       	ld.w	r8,r6[0x0]
8000a844:	58 08       	cp.w	r8,0
8000a846:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000a84a:	d8 22       	popm	r4-r7,pc

8000a84c <_lseek_r>:
8000a84c:	d4 21       	pushm	r4-r7,lr
8000a84e:	16 98       	mov	r8,r11
8000a850:	18 97       	mov	r7,r12
8000a852:	10 9c       	mov	r12,r8
8000a854:	30 08       	mov	r8,0
8000a856:	14 9b       	mov	r11,r10
8000a858:	e0 66 1f a0 	mov	r6,8096
8000a85c:	12 9a       	mov	r10,r9
8000a85e:	8d 08       	st.w	r6[0x0],r8
8000a860:	fe b0 df 36 	rcall	800066cc <_lseek>
8000a864:	5b fc       	cp.w	r12,-1
8000a866:	c0 51       	brne	8000a870 <_lseek_r+0x24>
8000a868:	6c 08       	ld.w	r8,r6[0x0]
8000a86a:	58 08       	cp.w	r8,0
8000a86c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000a870:	d8 22       	popm	r4-r7,pc
8000a872:	d7 03       	nop

8000a874 <_read_r>:
8000a874:	d4 21       	pushm	r4-r7,lr
8000a876:	16 98       	mov	r8,r11
8000a878:	18 97       	mov	r7,r12
8000a87a:	10 9c       	mov	r12,r8
8000a87c:	30 08       	mov	r8,0
8000a87e:	14 9b       	mov	r11,r10
8000a880:	e0 66 1f a0 	mov	r6,8096
8000a884:	12 9a       	mov	r10,r9
8000a886:	8d 08       	st.w	r6[0x0],r8
8000a888:	fe b0 d1 7a 	rcall	80004b7c <_read>
8000a88c:	5b fc       	cp.w	r12,-1
8000a88e:	c0 51       	brne	8000a898 <_read_r+0x24>
8000a890:	6c 08       	ld.w	r8,r6[0x0]
8000a892:	58 08       	cp.w	r8,0
8000a894:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000a898:	d8 22       	popm	r4-r7,pc
8000a89a:	d7 03       	nop

8000a89c <__avr32_f64_mul>:
8000a89c:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000a8a0:	e0 80 00 dc 	breq	8000aa58 <__avr32_f64_mul_op1_zero>
8000a8a4:	d4 21       	pushm	r4-r7,lr
8000a8a6:	f7 e9 20 0e 	eor	lr,r11,r9
8000a8aa:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000a8ae:	30 15       	mov	r5,1
8000a8b0:	c4 30       	breq	8000a936 <__avr32_f64_mul_op1_subnormal>
8000a8b2:	ab 6b       	lsl	r11,0xa
8000a8b4:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000a8b8:	ab 6a       	lsl	r10,0xa
8000a8ba:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000a8be:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000a8c2:	c5 c0       	breq	8000a97a <__avr32_f64_mul_op2_subnormal>
8000a8c4:	a1 78       	lsl	r8,0x1
8000a8c6:	5c f9       	rol	r9
8000a8c8:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000a8cc:	e0 47 07 ff 	cp.w	r7,2047
8000a8d0:	c7 70       	breq	8000a9be <__avr32_f64_mul_op_nan_or_inf>
8000a8d2:	e0 46 07 ff 	cp.w	r6,2047
8000a8d6:	c7 40       	breq	8000a9be <__avr32_f64_mul_op_nan_or_inf>
8000a8d8:	ee 06 00 0c 	add	r12,r7,r6
8000a8dc:	e0 2c 03 fe 	sub	r12,1022
8000a8e0:	f6 08 06 44 	mulu.d	r4,r11,r8
8000a8e4:	f4 09 07 44 	macu.d	r4,r10,r9
8000a8e8:	f4 08 06 46 	mulu.d	r6,r10,r8
8000a8ec:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000a8f0:	08 07       	add	r7,r4
8000a8f2:	f4 05 00 4a 	adc	r10,r10,r5
8000a8f6:	5c 0b       	acr	r11
8000a8f8:	ed bb 00 14 	bld	r11,0x14
8000a8fc:	c0 50       	breq	8000a906 <__avr32_f64_mul+0x6a>
8000a8fe:	a1 77       	lsl	r7,0x1
8000a900:	5c fa       	rol	r10
8000a902:	5c fb       	rol	r11
8000a904:	20 1c       	sub	r12,1
8000a906:	58 0c       	cp.w	r12,0
8000a908:	e0 8a 00 6f 	brle	8000a9e6 <__avr32_f64_mul_res_subnormal>
8000a90c:	e0 4c 07 ff 	cp.w	r12,2047
8000a910:	e0 84 00 9c 	brge	8000aa48 <__avr32_f64_mul_res_inf>
8000a914:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000a918:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000a91c:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000a920:	ee 17 80 00 	eorh	r7,0x8000
8000a924:	f1 b7 04 20 	satu	r7,0x1
8000a928:	0e 0a       	add	r10,r7
8000a92a:	5c 0b       	acr	r11
8000a92c:	ed be 00 1f 	bld	lr,0x1f
8000a930:	ef bb 00 1f 	bst	r11,0x1f
8000a934:	d8 22       	popm	r4-r7,pc

8000a936 <__avr32_f64_mul_op1_subnormal>:
8000a936:	e4 1b 00 0f 	andh	r11,0xf
8000a93a:	f4 0c 12 00 	clz	r12,r10
8000a93e:	f6 06 12 00 	clz	r6,r11
8000a942:	f7 bc 03 e1 	sublo	r12,-31
8000a946:	f8 06 17 30 	movlo	r6,r12
8000a94a:	f7 b6 02 01 	subhs	r6,1
8000a94e:	e0 46 00 20 	cp.w	r6,32
8000a952:	c0 d4       	brge	8000a96c <__avr32_f64_mul_op1_subnormal+0x36>
8000a954:	ec 0c 11 20 	rsub	r12,r6,32
8000a958:	f6 06 09 4b 	lsl	r11,r11,r6
8000a95c:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000a960:	18 4b       	or	r11,r12
8000a962:	f4 06 09 4a 	lsl	r10,r10,r6
8000a966:	20 b6       	sub	r6,11
8000a968:	0c 17       	sub	r7,r6
8000a96a:	ca ab       	rjmp	8000a8be <__avr32_f64_mul+0x22>
8000a96c:	f4 06 09 4b 	lsl	r11,r10,r6
8000a970:	c6 40       	breq	8000aa38 <__avr32_f64_mul_res_zero>
8000a972:	30 0a       	mov	r10,0
8000a974:	20 b6       	sub	r6,11
8000a976:	0c 17       	sub	r7,r6
8000a978:	ca 3b       	rjmp	8000a8be <__avr32_f64_mul+0x22>

8000a97a <__avr32_f64_mul_op2_subnormal>:
8000a97a:	e4 19 00 0f 	andh	r9,0xf
8000a97e:	f0 0c 12 00 	clz	r12,r8
8000a982:	f2 05 12 00 	clz	r5,r9
8000a986:	f7 bc 03 ea 	sublo	r12,-22
8000a98a:	f8 05 17 30 	movlo	r5,r12
8000a98e:	f7 b5 02 0a 	subhs	r5,10
8000a992:	e0 45 00 20 	cp.w	r5,32
8000a996:	c0 d4       	brge	8000a9b0 <__avr32_f64_mul_op2_subnormal+0x36>
8000a998:	ea 0c 11 20 	rsub	r12,r5,32
8000a99c:	f2 05 09 49 	lsl	r9,r9,r5
8000a9a0:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000a9a4:	18 49       	or	r9,r12
8000a9a6:	f0 05 09 48 	lsl	r8,r8,r5
8000a9aa:	20 25       	sub	r5,2
8000a9ac:	0a 16       	sub	r6,r5
8000a9ae:	c8 fb       	rjmp	8000a8cc <__avr32_f64_mul+0x30>
8000a9b0:	f0 05 09 49 	lsl	r9,r8,r5
8000a9b4:	c4 20       	breq	8000aa38 <__avr32_f64_mul_res_zero>
8000a9b6:	30 08       	mov	r8,0
8000a9b8:	20 25       	sub	r5,2
8000a9ba:	0a 16       	sub	r6,r5
8000a9bc:	c8 8b       	rjmp	8000a8cc <__avr32_f64_mul+0x30>

8000a9be <__avr32_f64_mul_op_nan_or_inf>:
8000a9be:	e4 19 00 0f 	andh	r9,0xf
8000a9c2:	e4 1b 00 0f 	andh	r11,0xf
8000a9c6:	14 4b       	or	r11,r10
8000a9c8:	10 49       	or	r9,r8
8000a9ca:	e0 47 07 ff 	cp.w	r7,2047
8000a9ce:	c0 91       	brne	8000a9e0 <__avr32_f64_mul_op1_not_naninf>
8000a9d0:	58 0b       	cp.w	r11,0
8000a9d2:	c3 81       	brne	8000aa42 <__avr32_f64_mul_res_nan>
8000a9d4:	e0 46 07 ff 	cp.w	r6,2047
8000a9d8:	c3 81       	brne	8000aa48 <__avr32_f64_mul_res_inf>
8000a9da:	58 09       	cp.w	r9,0
8000a9dc:	c3 60       	breq	8000aa48 <__avr32_f64_mul_res_inf>
8000a9de:	c3 28       	rjmp	8000aa42 <__avr32_f64_mul_res_nan>

8000a9e0 <__avr32_f64_mul_op1_not_naninf>:
8000a9e0:	58 09       	cp.w	r9,0
8000a9e2:	c3 30       	breq	8000aa48 <__avr32_f64_mul_res_inf>
8000a9e4:	c2 f8       	rjmp	8000aa42 <__avr32_f64_mul_res_nan>

8000a9e6 <__avr32_f64_mul_res_subnormal>:
8000a9e6:	5c 3c       	neg	r12
8000a9e8:	2f fc       	sub	r12,-1
8000a9ea:	f1 bc 04 c0 	satu	r12,0x6
8000a9ee:	e0 4c 00 20 	cp.w	r12,32
8000a9f2:	c1 14       	brge	8000aa14 <__avr32_f64_mul_res_subnormal+0x2e>
8000a9f4:	f8 08 11 20 	rsub	r8,r12,32
8000a9f8:	0e 46       	or	r6,r7
8000a9fa:	ee 0c 0a 47 	lsr	r7,r7,r12
8000a9fe:	f4 08 09 49 	lsl	r9,r10,r8
8000aa02:	12 47       	or	r7,r9
8000aa04:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000aa08:	f6 08 09 49 	lsl	r9,r11,r8
8000aa0c:	12 4a       	or	r10,r9
8000aa0e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000aa12:	c8 3b       	rjmp	8000a918 <__avr32_f64_mul+0x7c>
8000aa14:	f8 08 11 20 	rsub	r8,r12,32
8000aa18:	f9 b9 00 00 	moveq	r9,0
8000aa1c:	c0 30       	breq	8000aa22 <__avr32_f64_mul_res_subnormal+0x3c>
8000aa1e:	f6 08 09 49 	lsl	r9,r11,r8
8000aa22:	0e 46       	or	r6,r7
8000aa24:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000aa28:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000aa2c:	f3 ea 10 07 	or	r7,r9,r10
8000aa30:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000aa34:	30 0b       	mov	r11,0
8000aa36:	c7 1b       	rjmp	8000a918 <__avr32_f64_mul+0x7c>

8000aa38 <__avr32_f64_mul_res_zero>:
8000aa38:	1c 9b       	mov	r11,lr
8000aa3a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000aa3e:	30 0a       	mov	r10,0
8000aa40:	d8 22       	popm	r4-r7,pc

8000aa42 <__avr32_f64_mul_res_nan>:
8000aa42:	3f fb       	mov	r11,-1
8000aa44:	3f fa       	mov	r10,-1
8000aa46:	d8 22       	popm	r4-r7,pc

8000aa48 <__avr32_f64_mul_res_inf>:
8000aa48:	f0 6b 00 00 	mov	r11,-1048576
8000aa4c:	ed be 00 1f 	bld	lr,0x1f
8000aa50:	ef bb 00 1f 	bst	r11,0x1f
8000aa54:	30 0a       	mov	r10,0
8000aa56:	d8 22       	popm	r4-r7,pc

8000aa58 <__avr32_f64_mul_op1_zero>:
8000aa58:	f7 e9 20 0b 	eor	r11,r11,r9
8000aa5c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000aa60:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000aa64:	e0 4c 07 ff 	cp.w	r12,2047
8000aa68:	5e 1c       	retne	r12
8000aa6a:	3f fa       	mov	r10,-1
8000aa6c:	3f fb       	mov	r11,-1
8000aa6e:	5e fc       	retal	r12

8000aa70 <__avr32_f64_sub_from_add>:
8000aa70:	ee 19 80 00 	eorh	r9,0x8000

8000aa74 <__avr32_f64_sub>:
8000aa74:	f7 e9 20 0c 	eor	r12,r11,r9
8000aa78:	e0 86 00 ca 	brmi	8000ac0c <__avr32_f64_add_from_sub>
8000aa7c:	eb cd 40 e0 	pushm	r5-r7,lr
8000aa80:	16 9c       	mov	r12,r11
8000aa82:	e6 1c 80 00 	andh	r12,0x8000,COH
8000aa86:	bf db       	cbr	r11,0x1f
8000aa88:	bf d9       	cbr	r9,0x1f
8000aa8a:	10 3a       	cp.w	r10,r8
8000aa8c:	f2 0b 13 00 	cpc	r11,r9
8000aa90:	c0 92       	brcc	8000aaa2 <__avr32_f64_sub+0x2e>
8000aa92:	16 97       	mov	r7,r11
8000aa94:	12 9b       	mov	r11,r9
8000aa96:	0e 99       	mov	r9,r7
8000aa98:	14 97       	mov	r7,r10
8000aa9a:	10 9a       	mov	r10,r8
8000aa9c:	0e 98       	mov	r8,r7
8000aa9e:	ee 1c 80 00 	eorh	r12,0x8000
8000aaa2:	f6 07 16 14 	lsr	r7,r11,0x14
8000aaa6:	ab 7b       	lsl	r11,0xb
8000aaa8:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000aaac:	ab 7a       	lsl	r10,0xb
8000aaae:	bf bb       	sbr	r11,0x1f
8000aab0:	f2 06 16 14 	lsr	r6,r9,0x14
8000aab4:	c4 40       	breq	8000ab3c <__avr32_f64_sub_opL_subnormal>
8000aab6:	ab 79       	lsl	r9,0xb
8000aab8:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000aabc:	ab 78       	lsl	r8,0xb
8000aabe:	bf b9       	sbr	r9,0x1f

8000aac0 <__avr32_f64_sub_opL_subnormal_done>:
8000aac0:	e0 47 07 ff 	cp.w	r7,2047
8000aac4:	c4 f0       	breq	8000ab62 <__avr32_f64_sub_opH_nan_or_inf>
8000aac6:	0e 26       	rsub	r6,r7
8000aac8:	c1 20       	breq	8000aaec <__avr32_f64_sub_shift_done>
8000aaca:	ec 05 11 20 	rsub	r5,r6,32
8000aace:	e0 46 00 20 	cp.w	r6,32
8000aad2:	c7 c2       	brcc	8000abca <__avr32_f64_sub_longshift>
8000aad4:	f0 05 09 4e 	lsl	lr,r8,r5
8000aad8:	f2 05 09 45 	lsl	r5,r9,r5
8000aadc:	f0 06 0a 48 	lsr	r8,r8,r6
8000aae0:	f2 06 0a 49 	lsr	r9,r9,r6
8000aae4:	0a 48       	or	r8,r5
8000aae6:	58 0e       	cp.w	lr,0
8000aae8:	5f 1e       	srne	lr
8000aaea:	1c 48       	or	r8,lr

8000aaec <__avr32_f64_sub_shift_done>:
8000aaec:	10 1a       	sub	r10,r8
8000aaee:	f6 09 01 4b 	sbc	r11,r11,r9
8000aaf2:	f6 06 12 00 	clz	r6,r11
8000aaf6:	c0 e0       	breq	8000ab12 <__avr32_f64_sub_longnormalize_done>
8000aaf8:	c7 83       	brcs	8000abe8 <__avr32_f64_sub_longnormalize>
8000aafa:	ec 0e 11 20 	rsub	lr,r6,32
8000aafe:	f6 06 09 4b 	lsl	r11,r11,r6
8000ab02:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000ab06:	1c 4b       	or	r11,lr
8000ab08:	f4 06 09 4a 	lsl	r10,r10,r6
8000ab0c:	0c 17       	sub	r7,r6
8000ab0e:	e0 8a 00 39 	brle	8000ab80 <__avr32_f64_sub_subnormal_result>

8000ab12 <__avr32_f64_sub_longnormalize_done>:
8000ab12:	f4 09 15 15 	lsl	r9,r10,0x15
8000ab16:	ab 9a       	lsr	r10,0xb
8000ab18:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000ab1c:	ab 9b       	lsr	r11,0xb
8000ab1e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000ab22:	18 4b       	or	r11,r12

8000ab24 <__avr32_f64_sub_round>:
8000ab24:	fc 17 80 00 	movh	r7,0x8000
8000ab28:	ed ba 00 00 	bld	r10,0x0
8000ab2c:	f7 b7 01 ff 	subne	r7,-1
8000ab30:	0e 39       	cp.w	r9,r7
8000ab32:	5f 29       	srhs	r9
8000ab34:	12 0a       	add	r10,r9
8000ab36:	5c 0b       	acr	r11
8000ab38:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ab3c <__avr32_f64_sub_opL_subnormal>:
8000ab3c:	ab 79       	lsl	r9,0xb
8000ab3e:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000ab42:	ab 78       	lsl	r8,0xb
8000ab44:	f3 e8 10 0e 	or	lr,r9,r8
8000ab48:	f9 b6 01 01 	movne	r6,1
8000ab4c:	ee 0e 11 00 	rsub	lr,r7,0
8000ab50:	f9 b7 00 01 	moveq	r7,1
8000ab54:	ef bb 00 1f 	bst	r11,0x1f
8000ab58:	f7 ea 10 0e 	or	lr,r11,r10
8000ab5c:	f9 b7 00 00 	moveq	r7,0
8000ab60:	cb 0b       	rjmp	8000aac0 <__avr32_f64_sub_opL_subnormal_done>

8000ab62 <__avr32_f64_sub_opH_nan_or_inf>:
8000ab62:	bf db       	cbr	r11,0x1f
8000ab64:	f7 ea 10 0e 	or	lr,r11,r10
8000ab68:	c0 81       	brne	8000ab78 <__avr32_f64_sub_return_nan>
8000ab6a:	e0 46 07 ff 	cp.w	r6,2047
8000ab6e:	c0 50       	breq	8000ab78 <__avr32_f64_sub_return_nan>
8000ab70:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000ab74:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ab78 <__avr32_f64_sub_return_nan>:
8000ab78:	3f fa       	mov	r10,-1
8000ab7a:	3f fb       	mov	r11,-1
8000ab7c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ab80 <__avr32_f64_sub_subnormal_result>:
8000ab80:	5c 37       	neg	r7
8000ab82:	2f f7       	sub	r7,-1
8000ab84:	f1 b7 04 c0 	satu	r7,0x6
8000ab88:	e0 47 00 20 	cp.w	r7,32
8000ab8c:	c1 14       	brge	8000abae <__avr32_f64_sub_subnormal_result+0x2e>
8000ab8e:	ee 08 11 20 	rsub	r8,r7,32
8000ab92:	f4 08 09 49 	lsl	r9,r10,r8
8000ab96:	5f 16       	srne	r6
8000ab98:	f4 07 0a 4a 	lsr	r10,r10,r7
8000ab9c:	0c 4a       	or	r10,r6
8000ab9e:	f6 08 09 49 	lsl	r9,r11,r8
8000aba2:	f5 e9 10 0a 	or	r10,r10,r9
8000aba6:	f4 07 0a 4b 	lsr	r11,r10,r7
8000abaa:	30 07       	mov	r7,0
8000abac:	cb 3b       	rjmp	8000ab12 <__avr32_f64_sub_longnormalize_done>
8000abae:	ee 08 11 40 	rsub	r8,r7,64
8000abb2:	f6 08 09 49 	lsl	r9,r11,r8
8000abb6:	14 49       	or	r9,r10
8000abb8:	5f 16       	srne	r6
8000abba:	f6 07 0a 4a 	lsr	r10,r11,r7
8000abbe:	0c 4a       	or	r10,r6
8000abc0:	30 0b       	mov	r11,0
8000abc2:	30 07       	mov	r7,0
8000abc4:	ca 7b       	rjmp	8000ab12 <__avr32_f64_sub_longnormalize_done>
8000abc6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000abca <__avr32_f64_sub_longshift>:
8000abca:	f1 b6 04 c0 	satu	r6,0x6
8000abce:	f0 0e 17 00 	moveq	lr,r8
8000abd2:	c0 40       	breq	8000abda <__avr32_f64_sub_longshift+0x10>
8000abd4:	f2 05 09 4e 	lsl	lr,r9,r5
8000abd8:	10 4e       	or	lr,r8
8000abda:	f2 06 0a 48 	lsr	r8,r9,r6
8000abde:	30 09       	mov	r9,0
8000abe0:	58 0e       	cp.w	lr,0
8000abe2:	5f 1e       	srne	lr
8000abe4:	1c 48       	or	r8,lr
8000abe6:	c8 3b       	rjmp	8000aaec <__avr32_f64_sub_shift_done>

8000abe8 <__avr32_f64_sub_longnormalize>:
8000abe8:	f4 06 12 00 	clz	r6,r10
8000abec:	f9 b7 03 00 	movlo	r7,0
8000abf0:	f9 b6 03 00 	movlo	r6,0
8000abf4:	f9 bc 03 00 	movlo	r12,0
8000abf8:	f7 b6 02 e0 	subhs	r6,-32
8000abfc:	f4 06 09 4b 	lsl	r11,r10,r6
8000ac00:	30 0a       	mov	r10,0
8000ac02:	0c 17       	sub	r7,r6
8000ac04:	fe 9a ff be 	brle	8000ab80 <__avr32_f64_sub_subnormal_result>
8000ac08:	c8 5b       	rjmp	8000ab12 <__avr32_f64_sub_longnormalize_done>
8000ac0a:	d7 03       	nop

8000ac0c <__avr32_f64_add_from_sub>:
8000ac0c:	ee 19 80 00 	eorh	r9,0x8000

8000ac10 <__avr32_f64_add>:
8000ac10:	f7 e9 20 0c 	eor	r12,r11,r9
8000ac14:	fe 96 ff 2e 	brmi	8000aa70 <__avr32_f64_sub_from_add>
8000ac18:	eb cd 40 e0 	pushm	r5-r7,lr
8000ac1c:	16 9c       	mov	r12,r11
8000ac1e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000ac22:	bf db       	cbr	r11,0x1f
8000ac24:	bf d9       	cbr	r9,0x1f
8000ac26:	12 3b       	cp.w	r11,r9
8000ac28:	c0 72       	brcc	8000ac36 <__avr32_f64_add+0x26>
8000ac2a:	16 97       	mov	r7,r11
8000ac2c:	12 9b       	mov	r11,r9
8000ac2e:	0e 99       	mov	r9,r7
8000ac30:	14 97       	mov	r7,r10
8000ac32:	10 9a       	mov	r10,r8
8000ac34:	0e 98       	mov	r8,r7
8000ac36:	30 0e       	mov	lr,0
8000ac38:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000ac3c:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000ac40:	b5 ab       	sbr	r11,0x14
8000ac42:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000ac46:	c6 20       	breq	8000ad0a <__avr32_f64_add_op2_subnormal>
8000ac48:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000ac4c:	b5 a9       	sbr	r9,0x14
8000ac4e:	e0 47 07 ff 	cp.w	r7,2047
8000ac52:	c2 80       	breq	8000aca2 <__avr32_f64_add_opH_nan_or_inf>
8000ac54:	0e 26       	rsub	r6,r7
8000ac56:	c1 20       	breq	8000ac7a <__avr32_f64_add_shift_done>
8000ac58:	e0 46 00 36 	cp.w	r6,54
8000ac5c:	c1 52       	brcc	8000ac86 <__avr32_f64_add_res_of_done>
8000ac5e:	ec 05 11 20 	rsub	r5,r6,32
8000ac62:	e0 46 00 20 	cp.w	r6,32
8000ac66:	c3 52       	brcc	8000acd0 <__avr32_f64_add_longshift>
8000ac68:	f0 05 09 4e 	lsl	lr,r8,r5
8000ac6c:	f2 05 09 45 	lsl	r5,r9,r5
8000ac70:	f0 06 0a 48 	lsr	r8,r8,r6
8000ac74:	f2 06 0a 49 	lsr	r9,r9,r6
8000ac78:	0a 48       	or	r8,r5

8000ac7a <__avr32_f64_add_shift_done>:
8000ac7a:	10 0a       	add	r10,r8
8000ac7c:	f6 09 00 4b 	adc	r11,r11,r9
8000ac80:	ed bb 00 15 	bld	r11,0x15
8000ac84:	c3 40       	breq	8000acec <__avr32_f64_add_res_of>

8000ac86 <__avr32_f64_add_res_of_done>:
8000ac86:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000ac8a:	18 4b       	or	r11,r12

8000ac8c <__avr32_f64_add_round>:
8000ac8c:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000ac90:	18 4e       	or	lr,r12
8000ac92:	ee 1e 80 00 	eorh	lr,0x8000
8000ac96:	f1 be 04 20 	satu	lr,0x1
8000ac9a:	1c 0a       	add	r10,lr
8000ac9c:	5c 0b       	acr	r11
8000ac9e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000aca2 <__avr32_f64_add_opH_nan_or_inf>:
8000aca2:	b5 cb       	cbr	r11,0x14
8000aca4:	f7 ea 10 0e 	or	lr,r11,r10
8000aca8:	c1 01       	brne	8000acc8 <__avr32_f64_add_return_nan>
8000acaa:	e0 46 07 ff 	cp.w	r6,2047
8000acae:	c0 30       	breq	8000acb4 <__avr32_f64_add_opL_nan_or_inf>
8000acb0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000acb4 <__avr32_f64_add_opL_nan_or_inf>:
8000acb4:	b5 c9       	cbr	r9,0x14
8000acb6:	f3 e8 10 0e 	or	lr,r9,r8
8000acba:	c0 71       	brne	8000acc8 <__avr32_f64_add_return_nan>
8000acbc:	30 0a       	mov	r10,0
8000acbe:	fc 1b 7f f0 	movh	r11,0x7ff0
8000acc2:	18 4b       	or	r11,r12
8000acc4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000acc8 <__avr32_f64_add_return_nan>:
8000acc8:	3f fa       	mov	r10,-1
8000acca:	3f fb       	mov	r11,-1
8000accc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000acd0 <__avr32_f64_add_longshift>:
8000acd0:	f1 b6 04 c0 	satu	r6,0x6
8000acd4:	f0 0e 17 00 	moveq	lr,r8
8000acd8:	c0 60       	breq	8000ace4 <__avr32_f64_add_longshift+0x14>
8000acda:	f2 05 09 4e 	lsl	lr,r9,r5
8000acde:	58 08       	cp.w	r8,0
8000ace0:	5f 18       	srne	r8
8000ace2:	10 4e       	or	lr,r8
8000ace4:	f2 06 0a 48 	lsr	r8,r9,r6
8000ace8:	30 09       	mov	r9,0
8000acea:	cc 8b       	rjmp	8000ac7a <__avr32_f64_add_shift_done>

8000acec <__avr32_f64_add_res_of>:
8000acec:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000acf0:	a1 9b       	lsr	r11,0x1
8000acf2:	5d 0a       	ror	r10
8000acf4:	5d 0e       	ror	lr
8000acf6:	2f f7       	sub	r7,-1
8000acf8:	e0 47 07 ff 	cp.w	r7,2047
8000acfc:	f9 ba 00 00 	moveq	r10,0
8000ad00:	f9 bb 00 00 	moveq	r11,0
8000ad04:	f9 be 00 00 	moveq	lr,0
8000ad08:	cb fb       	rjmp	8000ac86 <__avr32_f64_add_res_of_done>

8000ad0a <__avr32_f64_add_op2_subnormal>:
8000ad0a:	30 16       	mov	r6,1
8000ad0c:	58 07       	cp.w	r7,0
8000ad0e:	ca 01       	brne	8000ac4e <__avr32_f64_add+0x3e>
8000ad10:	b5 cb       	cbr	r11,0x14
8000ad12:	10 0a       	add	r10,r8
8000ad14:	f6 09 00 4b 	adc	r11,r11,r9
8000ad18:	18 4b       	or	r11,r12
8000ad1a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000ad1e:	d7 03       	nop

8000ad20 <__avr32_f64_to_u32>:
8000ad20:	58 0b       	cp.w	r11,0
8000ad22:	5e 6d       	retmi	0

8000ad24 <__avr32_f64_to_s32>:
8000ad24:	f6 0c 15 01 	lsl	r12,r11,0x1
8000ad28:	b5 9c       	lsr	r12,0x15
8000ad2a:	e0 2c 03 ff 	sub	r12,1023
8000ad2e:	5e 3d       	retlo	0
8000ad30:	f8 0c 11 1f 	rsub	r12,r12,31
8000ad34:	16 99       	mov	r9,r11
8000ad36:	ab 7b       	lsl	r11,0xb
8000ad38:	bf bb       	sbr	r11,0x1f
8000ad3a:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000ad3e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000ad42:	a1 79       	lsl	r9,0x1
8000ad44:	5e 2b       	reths	r11
8000ad46:	5c 3b       	neg	r11
8000ad48:	5e fb       	retal	r11

8000ad4a <__avr32_u32_to_f64>:
8000ad4a:	f8 cb 00 00 	sub	r11,r12,0
8000ad4e:	30 0c       	mov	r12,0
8000ad50:	c0 38       	rjmp	8000ad56 <__avr32_s32_to_f64+0x4>

8000ad52 <__avr32_s32_to_f64>:
8000ad52:	18 9b       	mov	r11,r12
8000ad54:	5c 4b       	abs	r11
8000ad56:	30 0a       	mov	r10,0
8000ad58:	5e 0b       	reteq	r11
8000ad5a:	d4 01       	pushm	lr
8000ad5c:	e0 69 04 1e 	mov	r9,1054
8000ad60:	f6 08 12 00 	clz	r8,r11
8000ad64:	c1 70       	breq	8000ad92 <__avr32_s32_to_f64+0x40>
8000ad66:	c0 c3       	brcs	8000ad7e <__avr32_s32_to_f64+0x2c>
8000ad68:	f0 0e 11 20 	rsub	lr,r8,32
8000ad6c:	f6 08 09 4b 	lsl	r11,r11,r8
8000ad70:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000ad74:	1c 4b       	or	r11,lr
8000ad76:	f4 08 09 4a 	lsl	r10,r10,r8
8000ad7a:	10 19       	sub	r9,r8
8000ad7c:	c0 b8       	rjmp	8000ad92 <__avr32_s32_to_f64+0x40>
8000ad7e:	f4 08 12 00 	clz	r8,r10
8000ad82:	f9 b8 03 00 	movlo	r8,0
8000ad86:	f7 b8 02 e0 	subhs	r8,-32
8000ad8a:	f4 08 09 4b 	lsl	r11,r10,r8
8000ad8e:	30 0a       	mov	r10,0
8000ad90:	10 19       	sub	r9,r8
8000ad92:	58 09       	cp.w	r9,0
8000ad94:	e0 89 00 30 	brgt	8000adf4 <__avr32_s32_to_f64+0xa2>
8000ad98:	5c 39       	neg	r9
8000ad9a:	2f f9       	sub	r9,-1
8000ad9c:	e0 49 00 36 	cp.w	r9,54
8000ada0:	c0 43       	brcs	8000ada8 <__avr32_s32_to_f64+0x56>
8000ada2:	30 0b       	mov	r11,0
8000ada4:	30 0a       	mov	r10,0
8000ada6:	c2 68       	rjmp	8000adf2 <__avr32_s32_to_f64+0xa0>
8000ada8:	2f 69       	sub	r9,-10
8000adaa:	f2 08 11 20 	rsub	r8,r9,32
8000adae:	e0 49 00 20 	cp.w	r9,32
8000adb2:	c0 b2       	brcc	8000adc8 <__avr32_s32_to_f64+0x76>
8000adb4:	f4 08 09 4e 	lsl	lr,r10,r8
8000adb8:	f6 08 09 48 	lsl	r8,r11,r8
8000adbc:	f4 09 0a 4a 	lsr	r10,r10,r9
8000adc0:	f6 09 0a 4b 	lsr	r11,r11,r9
8000adc4:	10 4b       	or	r11,r8
8000adc6:	c0 88       	rjmp	8000add6 <__avr32_s32_to_f64+0x84>
8000adc8:	f6 08 09 4e 	lsl	lr,r11,r8
8000adcc:	14 4e       	or	lr,r10
8000adce:	16 9a       	mov	r10,r11
8000add0:	30 0b       	mov	r11,0
8000add2:	f4 09 0a 4a 	lsr	r10,r10,r9
8000add6:	ed ba 00 00 	bld	r10,0x0
8000adda:	c0 92       	brcc	8000adec <__avr32_s32_to_f64+0x9a>
8000addc:	1c 7e       	tst	lr,lr
8000adde:	c0 41       	brne	8000ade6 <__avr32_s32_to_f64+0x94>
8000ade0:	ed ba 00 01 	bld	r10,0x1
8000ade4:	c0 42       	brcc	8000adec <__avr32_s32_to_f64+0x9a>
8000ade6:	2f fa       	sub	r10,-1
8000ade8:	f7 bb 02 ff 	subhs	r11,-1
8000adec:	5c fc       	rol	r12
8000adee:	5d 0b       	ror	r11
8000adf0:	5d 0a       	ror	r10
8000adf2:	d8 02       	popm	pc
8000adf4:	e0 68 03 ff 	mov	r8,1023
8000adf8:	ed ba 00 0b 	bld	r10,0xb
8000adfc:	f7 b8 00 ff 	subeq	r8,-1
8000ae00:	10 0a       	add	r10,r8
8000ae02:	5c 0b       	acr	r11
8000ae04:	f7 b9 03 fe 	sublo	r9,-2
8000ae08:	e0 49 07 ff 	cp.w	r9,2047
8000ae0c:	c0 55       	brlt	8000ae16 <__avr32_s32_to_f64+0xc4>
8000ae0e:	30 0a       	mov	r10,0
8000ae10:	fc 1b ff e0 	movh	r11,0xffe0
8000ae14:	c0 c8       	rjmp	8000ae2c <__floatsidf_return_op1>
8000ae16:	ed bb 00 1f 	bld	r11,0x1f
8000ae1a:	f7 b9 01 01 	subne	r9,1
8000ae1e:	ab 9a       	lsr	r10,0xb
8000ae20:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000ae24:	a1 7b       	lsl	r11,0x1
8000ae26:	ab 9b       	lsr	r11,0xb
8000ae28:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000ae2c <__floatsidf_return_op1>:
8000ae2c:	a1 7c       	lsl	r12,0x1
8000ae2e:	5d 0b       	ror	r11
8000ae30:	d8 02       	popm	pc

8000ae32 <__avr32_f64_cmp_eq>:
8000ae32:	10 3a       	cp.w	r10,r8
8000ae34:	f2 0b 13 00 	cpc	r11,r9
8000ae38:	c0 80       	breq	8000ae48 <__avr32_f64_cmp_eq+0x16>
8000ae3a:	a1 7b       	lsl	r11,0x1
8000ae3c:	a1 79       	lsl	r9,0x1
8000ae3e:	14 4b       	or	r11,r10
8000ae40:	12 4b       	or	r11,r9
8000ae42:	10 4b       	or	r11,r8
8000ae44:	5e 0f       	reteq	1
8000ae46:	5e fd       	retal	0
8000ae48:	a1 7b       	lsl	r11,0x1
8000ae4a:	fc 1c ff e0 	movh	r12,0xffe0
8000ae4e:	58 0a       	cp.w	r10,0
8000ae50:	f8 0b 13 00 	cpc	r11,r12
8000ae54:	5e 8f       	retls	1
8000ae56:	5e fd       	retal	0

8000ae58 <__avr32_f64_cmp_ge>:
8000ae58:	1a de       	st.w	--sp,lr
8000ae5a:	1a d7       	st.w	--sp,r7
8000ae5c:	a1 7b       	lsl	r11,0x1
8000ae5e:	5f 3c       	srlo	r12
8000ae60:	a1 79       	lsl	r9,0x1
8000ae62:	5f 37       	srlo	r7
8000ae64:	5c fc       	rol	r12
8000ae66:	fc 1e ff e0 	movh	lr,0xffe0
8000ae6a:	58 0a       	cp.w	r10,0
8000ae6c:	fc 0b 13 00 	cpc	r11,lr
8000ae70:	e0 8b 00 1d 	brhi	8000aeaa <__avr32_f64_cmp_ge+0x52>
8000ae74:	58 08       	cp.w	r8,0
8000ae76:	fc 09 13 00 	cpc	r9,lr
8000ae7a:	e0 8b 00 18 	brhi	8000aeaa <__avr32_f64_cmp_ge+0x52>
8000ae7e:	58 0b       	cp.w	r11,0
8000ae80:	f5 ba 00 00 	subfeq	r10,0
8000ae84:	c1 50       	breq	8000aeae <__avr32_f64_cmp_ge+0x56>
8000ae86:	1b 07       	ld.w	r7,sp++
8000ae88:	1b 0e       	ld.w	lr,sp++
8000ae8a:	58 3c       	cp.w	r12,3
8000ae8c:	c0 a0       	breq	8000aea0 <__avr32_f64_cmp_ge+0x48>
8000ae8e:	58 1c       	cp.w	r12,1
8000ae90:	c0 33       	brcs	8000ae96 <__avr32_f64_cmp_ge+0x3e>
8000ae92:	5e 0f       	reteq	1
8000ae94:	5e 1d       	retne	0
8000ae96:	10 3a       	cp.w	r10,r8
8000ae98:	f2 0b 13 00 	cpc	r11,r9
8000ae9c:	5e 2f       	reths	1
8000ae9e:	5e 3d       	retlo	0
8000aea0:	14 38       	cp.w	r8,r10
8000aea2:	f6 09 13 00 	cpc	r9,r11
8000aea6:	5e 2f       	reths	1
8000aea8:	5e 3d       	retlo	0
8000aeaa:	1b 07       	ld.w	r7,sp++
8000aeac:	d8 0a       	popm	pc,r12=0
8000aeae:	58 17       	cp.w	r7,1
8000aeb0:	5f 0c       	sreq	r12
8000aeb2:	58 09       	cp.w	r9,0
8000aeb4:	f5 b8 00 00 	subfeq	r8,0
8000aeb8:	1b 07       	ld.w	r7,sp++
8000aeba:	1b 0e       	ld.w	lr,sp++
8000aebc:	5e 0f       	reteq	1
8000aebe:	5e fc       	retal	r12

8000aec0 <__avr32_f64_cmp_lt>:
8000aec0:	1a de       	st.w	--sp,lr
8000aec2:	1a d7       	st.w	--sp,r7
8000aec4:	a1 7b       	lsl	r11,0x1
8000aec6:	5f 3c       	srlo	r12
8000aec8:	a1 79       	lsl	r9,0x1
8000aeca:	5f 37       	srlo	r7
8000aecc:	5c fc       	rol	r12
8000aece:	fc 1e ff e0 	movh	lr,0xffe0
8000aed2:	58 0a       	cp.w	r10,0
8000aed4:	fc 0b 13 00 	cpc	r11,lr
8000aed8:	e0 8b 00 1d 	brhi	8000af12 <__avr32_f64_cmp_lt+0x52>
8000aedc:	58 08       	cp.w	r8,0
8000aede:	fc 09 13 00 	cpc	r9,lr
8000aee2:	e0 8b 00 18 	brhi	8000af12 <__avr32_f64_cmp_lt+0x52>
8000aee6:	58 0b       	cp.w	r11,0
8000aee8:	f5 ba 00 00 	subfeq	r10,0
8000aeec:	c1 50       	breq	8000af16 <__avr32_f64_cmp_lt+0x56>
8000aeee:	1b 07       	ld.w	r7,sp++
8000aef0:	1b 0e       	ld.w	lr,sp++
8000aef2:	58 3c       	cp.w	r12,3
8000aef4:	c0 a0       	breq	8000af08 <__avr32_f64_cmp_lt+0x48>
8000aef6:	58 1c       	cp.w	r12,1
8000aef8:	c0 33       	brcs	8000aefe <__avr32_f64_cmp_lt+0x3e>
8000aefa:	5e 0d       	reteq	0
8000aefc:	5e 1f       	retne	1
8000aefe:	10 3a       	cp.w	r10,r8
8000af00:	f2 0b 13 00 	cpc	r11,r9
8000af04:	5e 2d       	reths	0
8000af06:	5e 3f       	retlo	1
8000af08:	14 38       	cp.w	r8,r10
8000af0a:	f6 09 13 00 	cpc	r9,r11
8000af0e:	5e 2d       	reths	0
8000af10:	5e 3f       	retlo	1
8000af12:	1b 07       	ld.w	r7,sp++
8000af14:	d8 0a       	popm	pc,r12=0
8000af16:	58 17       	cp.w	r7,1
8000af18:	5f 1c       	srne	r12
8000af1a:	58 09       	cp.w	r9,0
8000af1c:	f5 b8 00 00 	subfeq	r8,0
8000af20:	1b 07       	ld.w	r7,sp++
8000af22:	1b 0e       	ld.w	lr,sp++
8000af24:	5e 0d       	reteq	0
8000af26:	5e fc       	retal	r12

8000af28 <__avr32_f64_div>:
8000af28:	eb cd 40 ff 	pushm	r0-r7,lr
8000af2c:	f7 e9 20 0e 	eor	lr,r11,r9
8000af30:	f6 07 16 14 	lsr	r7,r11,0x14
8000af34:	a9 7b       	lsl	r11,0x9
8000af36:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000af3a:	a9 7a       	lsl	r10,0x9
8000af3c:	bd bb       	sbr	r11,0x1d
8000af3e:	e4 1b 3f ff 	andh	r11,0x3fff
8000af42:	ab d7       	cbr	r7,0xb
8000af44:	e0 80 00 cc 	breq	8000b0dc <__avr32_f64_div_round_subnormal+0x54>
8000af48:	e0 47 07 ff 	cp.w	r7,2047
8000af4c:	e0 84 00 b5 	brge	8000b0b6 <__avr32_f64_div_round_subnormal+0x2e>
8000af50:	f2 06 16 14 	lsr	r6,r9,0x14
8000af54:	a9 79       	lsl	r9,0x9
8000af56:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000af5a:	a9 78       	lsl	r8,0x9
8000af5c:	bd b9       	sbr	r9,0x1d
8000af5e:	e4 19 3f ff 	andh	r9,0x3fff
8000af62:	ab d6       	cbr	r6,0xb
8000af64:	e0 80 00 e2 	breq	8000b128 <__avr32_f64_div_round_subnormal+0xa0>
8000af68:	e0 46 07 ff 	cp.w	r6,2047
8000af6c:	e0 84 00 b2 	brge	8000b0d0 <__avr32_f64_div_round_subnormal+0x48>
8000af70:	0c 17       	sub	r7,r6
8000af72:	fe 37 fc 01 	sub	r7,-1023
8000af76:	fc 1c 80 00 	movh	r12,0x8000
8000af7a:	f8 03 16 01 	lsr	r3,r12,0x1
8000af7e:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000af82:	5c d4       	com	r4
8000af84:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000af88:	e6 09 06 44 	mulu.d	r4,r3,r9
8000af8c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000af90:	e6 05 06 44 	mulu.d	r4,r3,r5
8000af94:	ea 03 15 02 	lsl	r3,r5,0x2
8000af98:	e6 09 06 44 	mulu.d	r4,r3,r9
8000af9c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000afa0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000afa4:	ea 03 15 02 	lsl	r3,r5,0x2
8000afa8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000afac:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000afb0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000afb4:	ea 03 15 02 	lsl	r3,r5,0x2
8000afb8:	e6 08 06 40 	mulu.d	r0,r3,r8
8000afbc:	e4 09 07 40 	macu.d	r0,r2,r9
8000afc0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000afc4:	02 04       	add	r4,r1
8000afc6:	5c 05       	acr	r5
8000afc8:	a3 65       	lsl	r5,0x2
8000afca:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000afce:	a3 64       	lsl	r4,0x2
8000afd0:	5c 34       	neg	r4
8000afd2:	f8 05 01 45 	sbc	r5,r12,r5
8000afd6:	e6 04 06 40 	mulu.d	r0,r3,r4
8000afda:	e4 05 07 40 	macu.d	r0,r2,r5
8000afde:	e6 05 06 44 	mulu.d	r4,r3,r5
8000afe2:	02 04       	add	r4,r1
8000afe4:	5c 05       	acr	r5
8000afe6:	ea 03 15 02 	lsl	r3,r5,0x2
8000afea:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000afee:	e8 02 15 02 	lsl	r2,r4,0x2
8000aff2:	e6 08 06 40 	mulu.d	r0,r3,r8
8000aff6:	e4 09 07 40 	macu.d	r0,r2,r9
8000affa:	e6 09 06 44 	mulu.d	r4,r3,r9
8000affe:	02 04       	add	r4,r1
8000b000:	5c 05       	acr	r5
8000b002:	a3 65       	lsl	r5,0x2
8000b004:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b008:	a3 64       	lsl	r4,0x2
8000b00a:	5c 34       	neg	r4
8000b00c:	f8 05 01 45 	sbc	r5,r12,r5
8000b010:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b014:	e4 05 07 40 	macu.d	r0,r2,r5
8000b018:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b01c:	02 04       	add	r4,r1
8000b01e:	5c 05       	acr	r5
8000b020:	ea 03 15 02 	lsl	r3,r5,0x2
8000b024:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b028:	e8 02 15 02 	lsl	r2,r4,0x2
8000b02c:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000b030:	e4 0b 07 40 	macu.d	r0,r2,r11
8000b034:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000b038:	02 02       	add	r2,r1
8000b03a:	5c 03       	acr	r3
8000b03c:	ed b3 00 1c 	bld	r3,0x1c
8000b040:	c0 90       	breq	8000b052 <__avr32_f64_div+0x12a>
8000b042:	a1 72       	lsl	r2,0x1
8000b044:	5c f3       	rol	r3
8000b046:	20 17       	sub	r7,1
8000b048:	a3 9a       	lsr	r10,0x3
8000b04a:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000b04e:	a3 9b       	lsr	r11,0x3
8000b050:	c0 58       	rjmp	8000b05a <__avr32_f64_div+0x132>
8000b052:	a5 8a       	lsr	r10,0x4
8000b054:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000b058:	a5 8b       	lsr	r11,0x4
8000b05a:	58 07       	cp.w	r7,0
8000b05c:	e0 8a 00 8b 	brle	8000b172 <__avr32_f64_div_res_subnormal>
8000b060:	e0 12 ff 00 	andl	r2,0xff00
8000b064:	e8 12 00 80 	orl	r2,0x80
8000b068:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b06c:	e4 09 07 40 	macu.d	r0,r2,r9
8000b070:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b074:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b078:	00 05       	add	r5,r0
8000b07a:	f0 01 00 48 	adc	r8,r8,r1
8000b07e:	5c 09       	acr	r9
8000b080:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b084:	58 04       	cp.w	r4,0
8000b086:	5c 25       	cpc	r5

8000b088 <__avr32_f64_div_round_subnormal>:
8000b088:	f4 08 13 00 	cpc	r8,r10
8000b08c:	f6 09 13 00 	cpc	r9,r11
8000b090:	5f 36       	srlo	r6
8000b092:	f8 06 17 00 	moveq	r6,r12
8000b096:	e4 0a 16 08 	lsr	r10,r2,0x8
8000b09a:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000b09e:	e6 0b 16 08 	lsr	r11,r3,0x8
8000b0a2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b0a6:	ed be 00 1f 	bld	lr,0x1f
8000b0aa:	ef bb 00 1f 	bst	r11,0x1f
8000b0ae:	0c 0a       	add	r10,r6
8000b0b0:	5c 0b       	acr	r11
8000b0b2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b0b6:	e4 1b 00 0f 	andh	r11,0xf
8000b0ba:	14 4b       	or	r11,r10
8000b0bc:	e0 81 00 a7 	brne	8000b20a <__avr32_f64_div_res_subnormal+0x98>
8000b0c0:	f2 06 16 14 	lsr	r6,r9,0x14
8000b0c4:	ab d6       	cbr	r6,0xb
8000b0c6:	e0 46 07 ff 	cp.w	r6,2047
8000b0ca:	e0 81 00 a4 	brne	8000b212 <__avr32_f64_div_res_subnormal+0xa0>
8000b0ce:	c9 e8       	rjmp	8000b20a <__avr32_f64_div_res_subnormal+0x98>
8000b0d0:	e4 19 00 0f 	andh	r9,0xf
8000b0d4:	10 49       	or	r9,r8
8000b0d6:	e0 81 00 9a 	brne	8000b20a <__avr32_f64_div_res_subnormal+0x98>
8000b0da:	c9 28       	rjmp	8000b1fe <__avr32_f64_div_res_subnormal+0x8c>
8000b0dc:	a3 7b       	lsl	r11,0x3
8000b0de:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000b0e2:	a3 7a       	lsl	r10,0x3
8000b0e4:	f5 eb 10 04 	or	r4,r10,r11
8000b0e8:	e0 80 00 a0 	breq	8000b228 <__avr32_f64_div_op1_zero>
8000b0ec:	f6 04 12 00 	clz	r4,r11
8000b0f0:	c1 70       	breq	8000b11e <__avr32_f64_div_round_subnormal+0x96>
8000b0f2:	c0 c3       	brcs	8000b10a <__avr32_f64_div_round_subnormal+0x82>
8000b0f4:	e8 05 11 20 	rsub	r5,r4,32
8000b0f8:	f6 04 09 4b 	lsl	r11,r11,r4
8000b0fc:	f4 05 0a 45 	lsr	r5,r10,r5
8000b100:	0a 4b       	or	r11,r5
8000b102:	f4 04 09 4a 	lsl	r10,r10,r4
8000b106:	08 17       	sub	r7,r4
8000b108:	c0 b8       	rjmp	8000b11e <__avr32_f64_div_round_subnormal+0x96>
8000b10a:	f4 04 12 00 	clz	r4,r10
8000b10e:	f9 b4 03 00 	movlo	r4,0
8000b112:	f7 b4 02 e0 	subhs	r4,-32
8000b116:	f4 04 09 4b 	lsl	r11,r10,r4
8000b11a:	30 0a       	mov	r10,0
8000b11c:	08 17       	sub	r7,r4
8000b11e:	a3 8a       	lsr	r10,0x2
8000b120:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000b124:	a3 8b       	lsr	r11,0x2
8000b126:	c1 1b       	rjmp	8000af48 <__avr32_f64_div+0x20>
8000b128:	a3 79       	lsl	r9,0x3
8000b12a:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000b12e:	a3 78       	lsl	r8,0x3
8000b130:	f3 e8 10 04 	or	r4,r9,r8
8000b134:	c6 f0       	breq	8000b212 <__avr32_f64_div_res_subnormal+0xa0>
8000b136:	f2 04 12 00 	clz	r4,r9
8000b13a:	c1 70       	breq	8000b168 <__avr32_f64_div_round_subnormal+0xe0>
8000b13c:	c0 c3       	brcs	8000b154 <__avr32_f64_div_round_subnormal+0xcc>
8000b13e:	e8 05 11 20 	rsub	r5,r4,32
8000b142:	f2 04 09 49 	lsl	r9,r9,r4
8000b146:	f0 05 0a 45 	lsr	r5,r8,r5
8000b14a:	0a 49       	or	r9,r5
8000b14c:	f0 04 09 48 	lsl	r8,r8,r4
8000b150:	08 16       	sub	r6,r4
8000b152:	c0 b8       	rjmp	8000b168 <__avr32_f64_div_round_subnormal+0xe0>
8000b154:	f0 04 12 00 	clz	r4,r8
8000b158:	f9 b4 03 00 	movlo	r4,0
8000b15c:	f7 b4 02 e0 	subhs	r4,-32
8000b160:	f0 04 09 49 	lsl	r9,r8,r4
8000b164:	30 08       	mov	r8,0
8000b166:	08 16       	sub	r6,r4
8000b168:	a3 88       	lsr	r8,0x2
8000b16a:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000b16e:	a3 89       	lsr	r9,0x2
8000b170:	cf ca       	rjmp	8000af68 <__avr32_f64_div+0x40>

8000b172 <__avr32_f64_div_res_subnormal>:
8000b172:	5c 37       	neg	r7
8000b174:	2f f7       	sub	r7,-1
8000b176:	f1 b7 04 c0 	satu	r7,0x6
8000b17a:	e0 47 00 20 	cp.w	r7,32
8000b17e:	c1 54       	brge	8000b1a8 <__avr32_f64_div_res_subnormal+0x36>
8000b180:	ee 06 11 20 	rsub	r6,r7,32
8000b184:	e4 07 0a 42 	lsr	r2,r2,r7
8000b188:	e6 06 09 4c 	lsl	r12,r3,r6
8000b18c:	18 42       	or	r2,r12
8000b18e:	e6 07 0a 43 	lsr	r3,r3,r7
8000b192:	f4 06 09 41 	lsl	r1,r10,r6
8000b196:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b19a:	f6 06 09 4c 	lsl	r12,r11,r6
8000b19e:	18 4a       	or	r10,r12
8000b1a0:	f6 07 0a 4b 	lsr	r11,r11,r7
8000b1a4:	30 00       	mov	r0,0
8000b1a6:	c1 58       	rjmp	8000b1d0 <__avr32_f64_div_res_subnormal+0x5e>
8000b1a8:	ee 06 11 20 	rsub	r6,r7,32
8000b1ac:	f9 b0 00 00 	moveq	r0,0
8000b1b0:	f9 bc 00 00 	moveq	r12,0
8000b1b4:	c0 50       	breq	8000b1be <__avr32_f64_div_res_subnormal+0x4c>
8000b1b6:	f4 06 09 40 	lsl	r0,r10,r6
8000b1ba:	f6 06 09 4c 	lsl	r12,r11,r6
8000b1be:	e6 07 0a 42 	lsr	r2,r3,r7
8000b1c2:	30 03       	mov	r3,0
8000b1c4:	f4 07 0a 41 	lsr	r1,r10,r7
8000b1c8:	18 41       	or	r1,r12
8000b1ca:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b1ce:	30 0b       	mov	r11,0
8000b1d0:	e0 12 ff 00 	andl	r2,0xff00
8000b1d4:	e8 12 00 80 	orl	r2,0x80
8000b1d8:	e6 08 06 46 	mulu.d	r6,r3,r8
8000b1dc:	e4 09 07 46 	macu.d	r6,r2,r9
8000b1e0:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b1e4:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b1e8:	0c 05       	add	r5,r6
8000b1ea:	f0 07 00 48 	adc	r8,r8,r7
8000b1ee:	5c 09       	acr	r9
8000b1f0:	30 07       	mov	r7,0
8000b1f2:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b1f6:	00 34       	cp.w	r4,r0
8000b1f8:	e2 05 13 00 	cpc	r5,r1
8000b1fc:	c4 6b       	rjmp	8000b088 <__avr32_f64_div_round_subnormal>
8000b1fe:	1c 9b       	mov	r11,lr
8000b200:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b204:	30 0a       	mov	r10,0
8000b206:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b20a:	3f fb       	mov	r11,-1
8000b20c:	30 0a       	mov	r10,0
8000b20e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b212:	f5 eb 10 04 	or	r4,r10,r11
8000b216:	c0 90       	breq	8000b228 <__avr32_f64_div_op1_zero>
8000b218:	1c 9b       	mov	r11,lr
8000b21a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b21e:	ea 1b 7f f0 	orh	r11,0x7ff0
8000b222:	30 0a       	mov	r10,0
8000b224:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000b228 <__avr32_f64_div_op1_zero>:
8000b228:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000b22c:	ce f0       	breq	8000b20a <__avr32_f64_div_res_subnormal+0x98>
8000b22e:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000b232:	e0 44 07 ff 	cp.w	r4,2047
8000b236:	ce 41       	brne	8000b1fe <__avr32_f64_div_res_subnormal+0x8c>
8000b238:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000b23c:	ce 10       	breq	8000b1fe <__avr32_f64_div_res_subnormal+0x8c>
8000b23e:	ce 6b       	rjmp	8000b20a <__avr32_f64_div_res_subnormal+0x98>

8000b240 <__avr32_udiv64>:
8000b240:	d4 31       	pushm	r0-r7,lr
8000b242:	1a 97       	mov	r7,sp
8000b244:	20 3d       	sub	sp,12
8000b246:	10 9c       	mov	r12,r8
8000b248:	12 9e       	mov	lr,r9
8000b24a:	14 93       	mov	r3,r10
8000b24c:	58 09       	cp.w	r9,0
8000b24e:	e0 81 00 bd 	brne	8000b3c8 <__avr32_udiv64+0x188>
8000b252:	16 38       	cp.w	r8,r11
8000b254:	e0 88 00 40 	brls	8000b2d4 <__avr32_udiv64+0x94>
8000b258:	f0 08 12 00 	clz	r8,r8
8000b25c:	c0 d0       	breq	8000b276 <__avr32_udiv64+0x36>
8000b25e:	f6 08 09 4b 	lsl	r11,r11,r8
8000b262:	f0 09 11 20 	rsub	r9,r8,32
8000b266:	f8 08 09 4c 	lsl	r12,r12,r8
8000b26a:	f4 09 0a 49 	lsr	r9,r10,r9
8000b26e:	f4 08 09 43 	lsl	r3,r10,r8
8000b272:	f3 eb 10 0b 	or	r11,r9,r11
8000b276:	f8 0e 16 10 	lsr	lr,r12,0x10
8000b27a:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000b27e:	f6 0e 0d 00 	divu	r0,r11,lr
8000b282:	e6 0b 16 10 	lsr	r11,r3,0x10
8000b286:	00 99       	mov	r9,r0
8000b288:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b28c:	e0 0a 02 48 	mul	r8,r0,r10
8000b290:	10 3b       	cp.w	r11,r8
8000b292:	c0 a2       	brcc	8000b2a6 <__avr32_udiv64+0x66>
8000b294:	20 19       	sub	r9,1
8000b296:	18 0b       	add	r11,r12
8000b298:	18 3b       	cp.w	r11,r12
8000b29a:	c0 63       	brcs	8000b2a6 <__avr32_udiv64+0x66>
8000b29c:	10 3b       	cp.w	r11,r8
8000b29e:	f7 b9 03 01 	sublo	r9,1
8000b2a2:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b2a6:	f6 08 01 01 	sub	r1,r11,r8
8000b2aa:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000b2ae:	e2 0e 0d 00 	divu	r0,r1,lr
8000b2b2:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000b2b6:	00 98       	mov	r8,r0
8000b2b8:	e0 0a 02 4a 	mul	r10,r0,r10
8000b2bc:	14 33       	cp.w	r3,r10
8000b2be:	c0 82       	brcc	8000b2ce <__avr32_udiv64+0x8e>
8000b2c0:	20 18       	sub	r8,1
8000b2c2:	18 03       	add	r3,r12
8000b2c4:	18 33       	cp.w	r3,r12
8000b2c6:	c0 43       	brcs	8000b2ce <__avr32_udiv64+0x8e>
8000b2c8:	14 33       	cp.w	r3,r10
8000b2ca:	f7 b8 03 01 	sublo	r8,1
8000b2ce:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000b2d2:	cd f8       	rjmp	8000b490 <__avr32_udiv64+0x250>
8000b2d4:	58 08       	cp.w	r8,0
8000b2d6:	c0 51       	brne	8000b2e0 <__avr32_udiv64+0xa0>
8000b2d8:	30 19       	mov	r9,1
8000b2da:	f2 08 0d 08 	divu	r8,r9,r8
8000b2de:	10 9c       	mov	r12,r8
8000b2e0:	f8 06 12 00 	clz	r6,r12
8000b2e4:	c0 41       	brne	8000b2ec <__avr32_udiv64+0xac>
8000b2e6:	18 1b       	sub	r11,r12
8000b2e8:	30 19       	mov	r9,1
8000b2ea:	c4 08       	rjmp	8000b36a <__avr32_udiv64+0x12a>
8000b2ec:	ec 01 11 20 	rsub	r1,r6,32
8000b2f0:	f4 01 0a 49 	lsr	r9,r10,r1
8000b2f4:	f8 06 09 4c 	lsl	r12,r12,r6
8000b2f8:	f6 06 09 48 	lsl	r8,r11,r6
8000b2fc:	f6 01 0a 41 	lsr	r1,r11,r1
8000b300:	f3 e8 10 08 	or	r8,r9,r8
8000b304:	f8 03 16 10 	lsr	r3,r12,0x10
8000b308:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000b30c:	e2 03 0d 00 	divu	r0,r1,r3
8000b310:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b314:	00 9e       	mov	lr,r0
8000b316:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b31a:	e0 05 02 49 	mul	r9,r0,r5
8000b31e:	12 3b       	cp.w	r11,r9
8000b320:	c0 a2       	brcc	8000b334 <__avr32_udiv64+0xf4>
8000b322:	20 1e       	sub	lr,1
8000b324:	18 0b       	add	r11,r12
8000b326:	18 3b       	cp.w	r11,r12
8000b328:	c0 63       	brcs	8000b334 <__avr32_udiv64+0xf4>
8000b32a:	12 3b       	cp.w	r11,r9
8000b32c:	f7 be 03 01 	sublo	lr,1
8000b330:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b334:	12 1b       	sub	r11,r9
8000b336:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000b33a:	f6 03 0d 02 	divu	r2,r11,r3
8000b33e:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000b342:	04 99       	mov	r9,r2
8000b344:	e4 05 02 4b 	mul	r11,r2,r5
8000b348:	16 38       	cp.w	r8,r11
8000b34a:	c0 a2       	brcc	8000b35e <__avr32_udiv64+0x11e>
8000b34c:	20 19       	sub	r9,1
8000b34e:	18 08       	add	r8,r12
8000b350:	18 38       	cp.w	r8,r12
8000b352:	c0 63       	brcs	8000b35e <__avr32_udiv64+0x11e>
8000b354:	16 38       	cp.w	r8,r11
8000b356:	f7 b9 03 01 	sublo	r9,1
8000b35a:	f1 dc e3 08 	addcs	r8,r8,r12
8000b35e:	f4 06 09 43 	lsl	r3,r10,r6
8000b362:	f0 0b 01 0b 	sub	r11,r8,r11
8000b366:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000b36a:	f8 06 16 10 	lsr	r6,r12,0x10
8000b36e:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000b372:	f6 06 0d 00 	divu	r0,r11,r6
8000b376:	e6 0b 16 10 	lsr	r11,r3,0x10
8000b37a:	00 9a       	mov	r10,r0
8000b37c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b380:	e0 0e 02 48 	mul	r8,r0,lr
8000b384:	10 3b       	cp.w	r11,r8
8000b386:	c0 a2       	brcc	8000b39a <__avr32_udiv64+0x15a>
8000b388:	20 1a       	sub	r10,1
8000b38a:	18 0b       	add	r11,r12
8000b38c:	18 3b       	cp.w	r11,r12
8000b38e:	c0 63       	brcs	8000b39a <__avr32_udiv64+0x15a>
8000b390:	10 3b       	cp.w	r11,r8
8000b392:	f7 ba 03 01 	sublo	r10,1
8000b396:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b39a:	f6 08 01 01 	sub	r1,r11,r8
8000b39e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000b3a2:	e2 06 0d 00 	divu	r0,r1,r6
8000b3a6:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000b3aa:	00 98       	mov	r8,r0
8000b3ac:	e0 0e 02 4b 	mul	r11,r0,lr
8000b3b0:	16 33       	cp.w	r3,r11
8000b3b2:	c0 82       	brcc	8000b3c2 <__avr32_udiv64+0x182>
8000b3b4:	20 18       	sub	r8,1
8000b3b6:	18 03       	add	r3,r12
8000b3b8:	18 33       	cp.w	r3,r12
8000b3ba:	c0 43       	brcs	8000b3c2 <__avr32_udiv64+0x182>
8000b3bc:	16 33       	cp.w	r3,r11
8000b3be:	f7 b8 03 01 	sublo	r8,1
8000b3c2:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000b3c6:	c6 98       	rjmp	8000b498 <__avr32_udiv64+0x258>
8000b3c8:	16 39       	cp.w	r9,r11
8000b3ca:	e0 8b 00 65 	brhi	8000b494 <__avr32_udiv64+0x254>
8000b3ce:	f2 09 12 00 	clz	r9,r9
8000b3d2:	c0 b1       	brne	8000b3e8 <__avr32_udiv64+0x1a8>
8000b3d4:	10 3a       	cp.w	r10,r8
8000b3d6:	5f 2a       	srhs	r10
8000b3d8:	1c 3b       	cp.w	r11,lr
8000b3da:	5f b8       	srhi	r8
8000b3dc:	10 4a       	or	r10,r8
8000b3de:	f2 0a 18 00 	cp.b	r10,r9
8000b3e2:	c5 90       	breq	8000b494 <__avr32_udiv64+0x254>
8000b3e4:	30 18       	mov	r8,1
8000b3e6:	c5 98       	rjmp	8000b498 <__avr32_udiv64+0x258>
8000b3e8:	f0 09 09 46 	lsl	r6,r8,r9
8000b3ec:	f2 03 11 20 	rsub	r3,r9,32
8000b3f0:	fc 09 09 4e 	lsl	lr,lr,r9
8000b3f4:	f0 03 0a 48 	lsr	r8,r8,r3
8000b3f8:	f6 09 09 4c 	lsl	r12,r11,r9
8000b3fc:	f4 03 0a 42 	lsr	r2,r10,r3
8000b400:	ef 46 ff f4 	st.w	r7[-12],r6
8000b404:	f6 03 0a 43 	lsr	r3,r11,r3
8000b408:	18 42       	or	r2,r12
8000b40a:	f1 ee 10 0c 	or	r12,r8,lr
8000b40e:	f8 01 16 10 	lsr	r1,r12,0x10
8000b412:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000b416:	e6 01 0d 04 	divu	r4,r3,r1
8000b41a:	e4 03 16 10 	lsr	r3,r2,0x10
8000b41e:	08 9e       	mov	lr,r4
8000b420:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000b424:	e8 06 02 48 	mul	r8,r4,r6
8000b428:	10 33       	cp.w	r3,r8
8000b42a:	c0 a2       	brcc	8000b43e <__avr32_udiv64+0x1fe>
8000b42c:	20 1e       	sub	lr,1
8000b42e:	18 03       	add	r3,r12
8000b430:	18 33       	cp.w	r3,r12
8000b432:	c0 63       	brcs	8000b43e <__avr32_udiv64+0x1fe>
8000b434:	10 33       	cp.w	r3,r8
8000b436:	f7 be 03 01 	sublo	lr,1
8000b43a:	e7 dc e3 03 	addcs	r3,r3,r12
8000b43e:	10 13       	sub	r3,r8
8000b440:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000b444:	e6 01 0d 00 	divu	r0,r3,r1
8000b448:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b44c:	00 98       	mov	r8,r0
8000b44e:	e0 06 02 46 	mul	r6,r0,r6
8000b452:	0c 3b       	cp.w	r11,r6
8000b454:	c0 a2       	brcc	8000b468 <__avr32_udiv64+0x228>
8000b456:	20 18       	sub	r8,1
8000b458:	18 0b       	add	r11,r12
8000b45a:	18 3b       	cp.w	r11,r12
8000b45c:	c0 63       	brcs	8000b468 <__avr32_udiv64+0x228>
8000b45e:	0c 3b       	cp.w	r11,r6
8000b460:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b464:	f7 b8 03 01 	sublo	r8,1
8000b468:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000b46c:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000b470:	0c 1b       	sub	r11,r6
8000b472:	f0 04 06 42 	mulu.d	r2,r8,r4
8000b476:	06 95       	mov	r5,r3
8000b478:	16 35       	cp.w	r5,r11
8000b47a:	e0 8b 00 0a 	brhi	8000b48e <__avr32_udiv64+0x24e>
8000b47e:	5f 0b       	sreq	r11
8000b480:	f4 09 09 49 	lsl	r9,r10,r9
8000b484:	12 32       	cp.w	r2,r9
8000b486:	5f b9       	srhi	r9
8000b488:	f7 e9 00 09 	and	r9,r11,r9
8000b48c:	c0 60       	breq	8000b498 <__avr32_udiv64+0x258>
8000b48e:	20 18       	sub	r8,1
8000b490:	30 09       	mov	r9,0
8000b492:	c0 38       	rjmp	8000b498 <__avr32_udiv64+0x258>
8000b494:	30 09       	mov	r9,0
8000b496:	12 98       	mov	r8,r9
8000b498:	10 9a       	mov	r10,r8
8000b49a:	12 93       	mov	r3,r9
8000b49c:	10 92       	mov	r2,r8
8000b49e:	12 9b       	mov	r11,r9
8000b4a0:	2f dd       	sub	sp,-12
8000b4a2:	d8 32       	popm	r0-r7,pc

8000b4a4 <__avr32_umod64>:
8000b4a4:	d4 31       	pushm	r0-r7,lr
8000b4a6:	1a 97       	mov	r7,sp
8000b4a8:	20 3d       	sub	sp,12
8000b4aa:	10 9c       	mov	r12,r8
8000b4ac:	12 95       	mov	r5,r9
8000b4ae:	14 9e       	mov	lr,r10
8000b4b0:	16 91       	mov	r1,r11
8000b4b2:	16 96       	mov	r6,r11
8000b4b4:	58 09       	cp.w	r9,0
8000b4b6:	e0 81 00 81 	brne	8000b5b8 <__avr32_umod64+0x114>
8000b4ba:	16 38       	cp.w	r8,r11
8000b4bc:	e0 88 00 12 	brls	8000b4e0 <__avr32_umod64+0x3c>
8000b4c0:	f0 08 12 00 	clz	r8,r8
8000b4c4:	c4 e0       	breq	8000b560 <__avr32_umod64+0xbc>
8000b4c6:	f6 08 09 46 	lsl	r6,r11,r8
8000b4ca:	f8 08 09 4c 	lsl	r12,r12,r8
8000b4ce:	f0 0b 11 20 	rsub	r11,r8,32
8000b4d2:	f4 08 09 4e 	lsl	lr,r10,r8
8000b4d6:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000b4da:	f7 e6 10 06 	or	r6,r11,r6
8000b4de:	c4 18       	rjmp	8000b560 <__avr32_umod64+0xbc>
8000b4e0:	58 08       	cp.w	r8,0
8000b4e2:	c0 51       	brne	8000b4ec <__avr32_umod64+0x48>
8000b4e4:	30 19       	mov	r9,1
8000b4e6:	f2 08 0d 08 	divu	r8,r9,r8
8000b4ea:	10 9c       	mov	r12,r8
8000b4ec:	f8 08 12 00 	clz	r8,r12
8000b4f0:	c0 31       	brne	8000b4f6 <__avr32_umod64+0x52>
8000b4f2:	18 16       	sub	r6,r12
8000b4f4:	c3 68       	rjmp	8000b560 <__avr32_umod64+0xbc>
8000b4f6:	f0 03 11 20 	rsub	r3,r8,32
8000b4fa:	f4 03 0a 4b 	lsr	r11,r10,r3
8000b4fe:	f8 08 09 4c 	lsl	r12,r12,r8
8000b502:	ec 08 09 49 	lsl	r9,r6,r8
8000b506:	ec 03 0a 43 	lsr	r3,r6,r3
8000b50a:	f7 e9 10 09 	or	r9,r11,r9
8000b50e:	f8 05 16 10 	lsr	r5,r12,0x10
8000b512:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000b516:	e6 05 0d 02 	divu	r2,r3,r5
8000b51a:	f2 0e 16 10 	lsr	lr,r9,0x10
8000b51e:	ec 02 02 4b 	mul	r11,r6,r2
8000b522:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000b526:	16 3e       	cp.w	lr,r11
8000b528:	c0 72       	brcc	8000b536 <__avr32_umod64+0x92>
8000b52a:	18 0e       	add	lr,r12
8000b52c:	18 3e       	cp.w	lr,r12
8000b52e:	c0 43       	brcs	8000b536 <__avr32_umod64+0x92>
8000b530:	16 3e       	cp.w	lr,r11
8000b532:	fd dc e3 0e 	addcs	lr,lr,r12
8000b536:	fc 0b 01 03 	sub	r3,lr,r11
8000b53a:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000b53e:	e6 05 0d 02 	divu	r2,r3,r5
8000b542:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000b546:	a5 36       	mul	r6,r2
8000b548:	0c 39       	cp.w	r9,r6
8000b54a:	c0 72       	brcc	8000b558 <__avr32_umod64+0xb4>
8000b54c:	18 09       	add	r9,r12
8000b54e:	18 39       	cp.w	r9,r12
8000b550:	c0 43       	brcs	8000b558 <__avr32_umod64+0xb4>
8000b552:	0c 39       	cp.w	r9,r6
8000b554:	f3 dc e3 09 	addcs	r9,r9,r12
8000b558:	f2 06 01 06 	sub	r6,r9,r6
8000b55c:	f4 08 09 4e 	lsl	lr,r10,r8
8000b560:	f8 0a 16 10 	lsr	r10,r12,0x10
8000b564:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000b568:	ec 0a 0d 02 	divu	r2,r6,r10
8000b56c:	fc 09 16 10 	lsr	r9,lr,0x10
8000b570:	ea 02 02 4b 	mul	r11,r5,r2
8000b574:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000b578:	16 39       	cp.w	r9,r11
8000b57a:	c0 72       	brcc	8000b588 <__avr32_umod64+0xe4>
8000b57c:	18 09       	add	r9,r12
8000b57e:	18 39       	cp.w	r9,r12
8000b580:	c0 43       	brcs	8000b588 <__avr32_umod64+0xe4>
8000b582:	16 39       	cp.w	r9,r11
8000b584:	f3 dc e3 09 	addcs	r9,r9,r12
8000b588:	f2 0b 01 0b 	sub	r11,r9,r11
8000b58c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b590:	f6 0a 0d 0a 	divu	r10,r11,r10
8000b594:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000b598:	ea 0a 02 4a 	mul	r10,r5,r10
8000b59c:	14 3e       	cp.w	lr,r10
8000b59e:	c0 72       	brcc	8000b5ac <__avr32_umod64+0x108>
8000b5a0:	18 0e       	add	lr,r12
8000b5a2:	18 3e       	cp.w	lr,r12
8000b5a4:	c0 43       	brcs	8000b5ac <__avr32_umod64+0x108>
8000b5a6:	14 3e       	cp.w	lr,r10
8000b5a8:	fd dc e3 0e 	addcs	lr,lr,r12
8000b5ac:	fc 0a 01 0a 	sub	r10,lr,r10
8000b5b0:	30 0b       	mov	r11,0
8000b5b2:	f4 08 0a 4a 	lsr	r10,r10,r8
8000b5b6:	c7 b8       	rjmp	8000b6ac <__avr32_umod64+0x208>
8000b5b8:	16 39       	cp.w	r9,r11
8000b5ba:	e0 8b 00 79 	brhi	8000b6ac <__avr32_umod64+0x208>
8000b5be:	f2 09 12 00 	clz	r9,r9
8000b5c2:	c1 21       	brne	8000b5e6 <__avr32_umod64+0x142>
8000b5c4:	10 3a       	cp.w	r10,r8
8000b5c6:	5f 2b       	srhs	r11
8000b5c8:	0a 31       	cp.w	r1,r5
8000b5ca:	5f ba       	srhi	r10
8000b5cc:	f7 ea 10 0a 	or	r10,r11,r10
8000b5d0:	f2 0a 18 00 	cp.b	r10,r9
8000b5d4:	c0 60       	breq	8000b5e0 <__avr32_umod64+0x13c>
8000b5d6:	fc 08 01 0c 	sub	r12,lr,r8
8000b5da:	e2 05 01 46 	sbc	r6,r1,r5
8000b5de:	18 9e       	mov	lr,r12
8000b5e0:	0c 9b       	mov	r11,r6
8000b5e2:	1c 9a       	mov	r10,lr
8000b5e4:	c6 48       	rjmp	8000b6ac <__avr32_umod64+0x208>
8000b5e6:	ea 09 09 4c 	lsl	r12,r5,r9
8000b5ea:	f2 06 11 20 	rsub	r6,r9,32
8000b5ee:	f6 09 09 4b 	lsl	r11,r11,r9
8000b5f2:	f0 09 09 42 	lsl	r2,r8,r9
8000b5f6:	ef 46 ff f4 	st.w	r7[-12],r6
8000b5fa:	f0 06 0a 48 	lsr	r8,r8,r6
8000b5fe:	18 48       	or	r8,r12
8000b600:	e2 06 0a 4c 	lsr	r12,r1,r6
8000b604:	f4 09 09 43 	lsl	r3,r10,r9
8000b608:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000b60c:	f4 06 0a 4a 	lsr	r10,r10,r6
8000b610:	16 4a       	or	r10,r11
8000b612:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b616:	f8 0b 0d 04 	divu	r4,r12,r11
8000b61a:	f4 0c 16 10 	lsr	r12,r10,0x10
8000b61e:	08 91       	mov	r1,r4
8000b620:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000b624:	e8 0e 02 46 	mul	r6,r4,lr
8000b628:	0c 3c       	cp.w	r12,r6
8000b62a:	c0 a2       	brcc	8000b63e <__avr32_umod64+0x19a>
8000b62c:	20 11       	sub	r1,1
8000b62e:	10 0c       	add	r12,r8
8000b630:	10 3c       	cp.w	r12,r8
8000b632:	c0 63       	brcs	8000b63e <__avr32_umod64+0x19a>
8000b634:	0c 3c       	cp.w	r12,r6
8000b636:	f7 b1 03 01 	sublo	r1,1
8000b63a:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000b63e:	0c 1c       	sub	r12,r6
8000b640:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000b644:	f8 0b 0d 04 	divu	r4,r12,r11
8000b648:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000b64c:	08 96       	mov	r6,r4
8000b64e:	e8 0e 02 4e 	mul	lr,r4,lr
8000b652:	1c 3b       	cp.w	r11,lr
8000b654:	c0 a2       	brcc	8000b668 <__avr32_umod64+0x1c4>
8000b656:	20 16       	sub	r6,1
8000b658:	10 0b       	add	r11,r8
8000b65a:	10 3b       	cp.w	r11,r8
8000b65c:	c0 63       	brcs	8000b668 <__avr32_umod64+0x1c4>
8000b65e:	1c 3b       	cp.w	r11,lr
8000b660:	f7 b6 03 01 	sublo	r6,1
8000b664:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000b668:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000b66c:	1c 1b       	sub	r11,lr
8000b66e:	e2 02 06 40 	mulu.d	r0,r1,r2
8000b672:	00 9e       	mov	lr,r0
8000b674:	02 9c       	mov	r12,r1
8000b676:	16 3c       	cp.w	r12,r11
8000b678:	e0 8b 00 08 	brhi	8000b688 <__avr32_umod64+0x1e4>
8000b67c:	5f 06       	sreq	r6
8000b67e:	06 30       	cp.w	r0,r3
8000b680:	5f ba       	srhi	r10
8000b682:	ed ea 00 0a 	and	r10,r6,r10
8000b686:	c0 60       	breq	8000b692 <__avr32_umod64+0x1ee>
8000b688:	fc 02 01 04 	sub	r4,lr,r2
8000b68c:	f8 08 01 4c 	sbc	r12,r12,r8
8000b690:	08 9e       	mov	lr,r4
8000b692:	e6 0e 01 0a 	sub	r10,r3,lr
8000b696:	f6 0c 01 4c 	sbc	r12,r11,r12
8000b69a:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000b69e:	f8 09 0a 4b 	lsr	r11,r12,r9
8000b6a2:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b6a6:	f8 01 09 4c 	lsl	r12,r12,r1
8000b6aa:	18 4a       	or	r10,r12
8000b6ac:	2f dd       	sub	sp,-12
8000b6ae:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000b800 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000b800:	c0 08       	rjmp	8000b800 <_evba>
	...

8000b804 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000b804:	c0 08       	rjmp	8000b804 <_handle_TLB_Multiple_Hit>
	...

8000b808 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000b808:	c0 08       	rjmp	8000b808 <_handle_Bus_Error_Data_Fetch>
	...

8000b80c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000b80c:	c0 08       	rjmp	8000b80c <_handle_Bus_Error_Instruction_Fetch>
	...

8000b810 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000b810:	c0 08       	rjmp	8000b810 <_handle_NMI>
	...

8000b814 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000b814:	c0 08       	rjmp	8000b814 <_handle_Instruction_Address>
	...

8000b818 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000b818:	c0 08       	rjmp	8000b818 <_handle_ITLB_Protection>
	...

8000b81c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000b81c:	c0 08       	rjmp	8000b81c <_handle_Breakpoint>
	...

8000b820 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000b820:	c0 08       	rjmp	8000b820 <_handle_Illegal_Opcode>
	...

8000b824 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000b824:	c0 08       	rjmp	8000b824 <_handle_Unimplemented_Instruction>
	...

8000b828 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000b828:	c0 08       	rjmp	8000b828 <_handle_Privilege_Violation>
	...

8000b82c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000b82c:	c0 08       	rjmp	8000b82c <_handle_Floating_Point>
	...

8000b830 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000b830:	c0 08       	rjmp	8000b830 <_handle_Coprocessor_Absent>
	...

8000b834 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000b834:	c0 08       	rjmp	8000b834 <_handle_Data_Address_Read>
	...

8000b838 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000b838:	c0 08       	rjmp	8000b838 <_handle_Data_Address_Write>
	...

8000b83c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000b83c:	c0 08       	rjmp	8000b83c <_handle_DTLB_Protection_Read>
	...

8000b840 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000b840:	c0 08       	rjmp	8000b840 <_handle_DTLB_Protection_Write>
	...

8000b844 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000b844:	c0 08       	rjmp	8000b844 <_handle_DTLB_Modified>
	...

8000b850 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000b850:	c0 08       	rjmp	8000b850 <_handle_ITLB_Miss>
	...

8000b860 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000b860:	c0 08       	rjmp	8000b860 <_handle_DTLB_Miss_Read>
	...

8000b870 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000b870:	c0 08       	rjmp	8000b870 <_handle_DTLB_Miss_Write>
	...

8000b900 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000b900:	fe cf 6e e4 	sub	pc,pc,28388

8000b904 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000b904:	30 0c       	mov	r12,0
8000b906:	fe b0 c3 f1 	rcall	800040e8 <_get_interrupt_handler>
8000b90a:	58 0c       	cp.w	r12,0
8000b90c:	f8 0f 17 10 	movne	pc,r12
8000b910:	d6 03       	rete

8000b912 <_int1>:
8000b912:	30 1c       	mov	r12,1
8000b914:	fe b0 c3 ea 	rcall	800040e8 <_get_interrupt_handler>
8000b918:	58 0c       	cp.w	r12,0
8000b91a:	f8 0f 17 10 	movne	pc,r12
8000b91e:	d6 03       	rete

8000b920 <_int2>:
8000b920:	30 2c       	mov	r12,2
8000b922:	fe b0 c3 e3 	rcall	800040e8 <_get_interrupt_handler>
8000b926:	58 0c       	cp.w	r12,0
8000b928:	f8 0f 17 10 	movne	pc,r12
8000b92c:	d6 03       	rete

8000b92e <_int3>:
8000b92e:	30 3c       	mov	r12,3
8000b930:	fe b0 c3 dc 	rcall	800040e8 <_get_interrupt_handler>
8000b934:	58 0c       	cp.w	r12,0
8000b936:	f8 0f 17 10 	movne	pc,r12
8000b93a:	d6 03       	rete

8000b93c <ipr_val>:
8000b93c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000b94c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b95c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b96c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b97c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b98c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b99c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b9ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b9bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b9cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b9dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b9ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b9fc:	d7 03 d7 03                                         ....
