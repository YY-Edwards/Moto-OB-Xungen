
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000aa1c  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000cc00  8000cc00  0000d000  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000011a0  8000ce00  8000ce00  0000d200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a3c  00000004  8000dfa0  0000e404  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          000046e8  00000a40  8000e9dc  0000ee40  2**2
                  ALLOC
  7 .comment      00000030  00000000  00000000  0000ee40  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 000014b0  00000000  00000000  0000ee70  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 00002def  00000000  00000000  00010320  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0002c1d5  00000000  00000000  0001310f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 0000719c  00000000  00000000  0003f2e4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000ce45  00000000  00000000  00046480  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  000036c8  00000000  00000000  000532c8  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000076da  00000000  00000000  00056990  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0000e59d  00000000  00000000  0005e06a  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 17 .debug_ranges 00001578  00000000  00000000  0006c608  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c5 f0 	sub	pc,pc,-14864

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d 7c       	ld.ub	r12,--r6

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 58       	eor	r8,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 04       	add	r4,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	3e 94       	mov	r4,-23
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 90       	sub	r0,9
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	20 a4       	sub	r4,10
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	2a 94       	sub	r4,-87
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	ce 00       	breq	80002042 <app_init+0x6>
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	27 d8       	sub	r8,125
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	69 50       	ld.w	r0,r4[0x54]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 4c       	or	r12,r5

80002090 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002090:	d4 01       	pushm	lr
  log("R");
80002092:	48 3c       	lddpc	r12,8000209c <app_payload_tx_proc+0xc>
80002094:	f0 1f 00 03 	mcall	800020a0 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002098:	d8 02       	popm	pc
8000209a:	00 00       	add	r0,r0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	ce 08       	rjmp	8000225e <ButtonConfig_brdcst_func+0xaa>
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	6d 14       	ld.w	r4,r6[0x44]

800020a4 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
800020a4:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
800020a6:	48 99       	lddpc	r9,800020c8 <app_payload_rx_proc+0x24>
800020a8:	13 88       	ld.ub	r8,r9[0x0]
800020aa:	2f f8       	sub	r8,-1
800020ac:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
800020ae:	30 39       	mov	r9,3
800020b0:	f2 08 18 00 	cp.b	r8,r9
800020b4:	c0 71       	brne	800020c2 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
800020b6:	30 09       	mov	r9,0
800020b8:	48 48       	lddpc	r8,800020c8 <app_payload_rx_proc+0x24>
800020ba:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800020bc:	48 4c       	lddpc	r12,800020cc <app_payload_rx_proc+0x28>
800020be:	f0 1f 00 05 	mcall	800020d0 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
800020c2:	48 58       	lddpc	r8,800020d4 <app_payload_rx_proc+0x30>
800020c4:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
800020c6:	d8 02       	popm	pc
800020c8:	00 00       	add	r0,r0
800020ca:	0a 54       	eor	r4,r5
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	ce 0c       	rcall	8000228e <ButtonConfig_brdcst_func+0xda>
800020d0:	80 00       	ld.sh	r0,r0[0x0]
800020d2:	6d 14       	ld.w	r4,r6[0x44]
800020d4:	00 00       	add	r0,r0
800020d6:	0a 50       	eor	r0,r5

800020d8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020da:	48 3c       	lddpc	r12,800020e4 <FD_brdcst_func+0xc>
800020dc:	f0 1f 00 03 	mcall	800020e8 <FD_brdcst_func+0x10>
	
}
800020e0:	d8 02       	popm	pc
800020e2:	00 00       	add	r0,r0
800020e4:	80 00       	ld.sh	r0,r0[0x0]
800020e6:	ce 18       	rjmp	800022a8 <ButtonConfig_reply_func+0x18>
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	6d 14       	ld.w	r4,r6[0x44]

800020ec <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020ec:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ee:	48 3c       	lddpc	r12,800020f8 <FD_reply_func+0xc>
800020f0:	f0 1f 00 03 	mcall	800020fc <FD_reply_func+0x10>
	
	
}
800020f4:	d8 02       	popm	pc
800020f6:	00 00       	add	r0,r0
800020f8:	80 00       	ld.sh	r0,r0[0x0]
800020fa:	ce 38       	rjmp	800022c0 <ButtonConfig_reply_func+0x30>
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	6d 14       	ld.w	r4,r6[0x44]

80002100 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002100:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002102:	48 3c       	lddpc	r12,8000210c <FD_request_func+0xc>
80002104:	f0 1f 00 03 	mcall	80002110 <FD_request_func+0x10>
	
	
}
80002108:	d8 02       	popm	pc
8000210a:	00 00       	add	r0,r0
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	ce 54       	brge	800020d8 <FD_brdcst_func>
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	6d 14       	ld.w	r4,r6[0x44]

80002114 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002114:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002116:	48 3c       	lddpc	r12,80002120 <EnOB_brdcst_func+0xc>
80002118:	f0 1f 00 03 	mcall	80002124 <EnOB_brdcst_func+0x10>
}
8000211c:	d8 02       	popm	pc
8000211e:	00 00       	add	r0,r0
80002120:	80 00       	ld.sh	r0,r0[0x0]
80002122:	ce 70       	breq	800020f0 <FD_reply_func+0x4>
80002124:	80 00       	ld.sh	r0,r0[0x0]
80002126:	6d 14       	ld.w	r4,r6[0x44]

80002128 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002128:	eb cd 40 80 	pushm	r7,lr
8000212c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000212e:	19 a9       	ld.ub	r9,r12[0x2]
80002130:	30 08       	mov	r8,0
80002132:	f0 09 18 00 	cp.b	r9,r8
80002136:	c1 91       	brne	80002168 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002138:	19 b8       	ld.ub	r8,r12[0x3]
8000213a:	30 19       	mov	r9,1
8000213c:	f2 08 18 00 	cp.b	r8,r9
80002140:	c0 61       	brne	8000214c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002142:	49 0c       	lddpc	r12,80002180 <EnOB_reply_func+0x58>
80002144:	f0 1f 00 10 	mcall	80002184 <EnOB_reply_func+0x5c>
80002148:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000214c:	58 08       	cp.w	r8,0
8000214e:	c0 61       	brne	8000215a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002150:	48 ec       	lddpc	r12,80002188 <EnOB_reply_func+0x60>
80002152:	f0 1f 00 0d 	mcall	80002184 <EnOB_reply_func+0x5c>
80002156:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000215a:	1a d8       	st.w	--sp,r8
8000215c:	48 cc       	lddpc	r12,8000218c <EnOB_reply_func+0x64>
8000215e:	f0 1f 00 0a 	mcall	80002184 <EnOB_reply_func+0x5c>
80002162:	2f fd       	sub	sp,-4
80002164:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002168:	48 ac       	lddpc	r12,80002190 <EnOB_reply_func+0x68>
8000216a:	f0 1f 00 07 	mcall	80002184 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000216e:	0f a8       	ld.ub	r8,r7[0x2]
80002170:	1a d8       	st.w	--sp,r8
80002172:	48 9c       	lddpc	r12,80002194 <EnOB_reply_func+0x6c>
80002174:	f0 1f 00 04 	mcall	80002184 <EnOB_reply_func+0x5c>
80002178:	2f fd       	sub	sp,-4
8000217a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	ce 88       	rjmp	80002352 <DataSession_brdcst_func+0x7e>
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	6d 14       	ld.w	r4,r6[0x44]
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	ce a0       	breq	8000215e <EnOB_reply_func+0x36>
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	ce b4       	brge	80002164 <EnOB_reply_func+0x3c>
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	ce cc       	rcall	8000236a <DataSession_brdcst_func+0x96>
80002194:	80 00       	ld.sh	r0,r0[0x0]
80002196:	ce e8       	rjmp	80002372 <DataSession_brdcst_func+0x9e>

80002198 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002198:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
8000219a:	19 a9       	ld.ub	r9,r12[0x2]
8000219c:	31 18       	mov	r8,17
8000219e:	f0 09 18 00 	cp.b	r9,r8
800021a2:	c0 41       	brne	800021aa <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021a4:	48 2c       	lddpc	r12,800021ac <SingleDetection_brdcst_func+0x14>
800021a6:	f0 1f 00 03 	mcall	800021b0 <SingleDetection_brdcst_func+0x18>
800021aa:	d8 02       	popm	pc
800021ac:	80 00       	ld.sh	r0,r0[0x0]
800021ae:	cf 00       	breq	8000218e <EnOB_reply_func+0x66>
800021b0:	80 00       	ld.sh	r0,r0[0x0]
800021b2:	6d 14       	ld.w	r4,r6[0x44]

800021b4 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021b4:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021b6:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021ba:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021bc:	4a bc       	lddpc	r12,80002268 <ButtonConfig_brdcst_func+0xb4>
800021be:	f0 1f 00 2c 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021c2:	0f 88       	ld.ub	r8,r7[0x0]
800021c4:	1a d8       	st.w	--sp,r8
800021c6:	4a bc       	lddpc	r12,80002270 <ButtonConfig_brdcst_func+0xbc>
800021c8:	f0 1f 00 29 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021cc:	1a d5       	st.w	--sp,r5
800021ce:	4a ac       	lddpc	r12,80002274 <ButtonConfig_brdcst_func+0xc0>
800021d0:	f0 1f 00 27 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021d4:	0f a8       	ld.ub	r8,r7[0x2]
800021d6:	1a d8       	st.w	--sp,r8
800021d8:	4a 8c       	lddpc	r12,80002278 <ButtonConfig_brdcst_func+0xc4>
800021da:	f0 1f 00 25 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021de:	2f dd       	sub	sp,-12
800021e0:	58 05       	cp.w	r5,0
800021e2:	c4 10       	breq	80002264 <ButtonConfig_brdcst_func+0xb0>
800021e4:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021e6:	4a 64       	lddpc	r4,8000227c <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021e8:	4a 63       	lddpc	r3,80002280 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021ea:	4a 72       	lddpc	r2,80002284 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021ec:	4a 71       	lddpc	r1,80002288 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021ee:	4a 80       	lddpc	r0,8000228c <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021f0:	0f b9       	ld.ub	r9,r7[0x3]
800021f2:	0f c8       	ld.ub	r8,r7[0x4]
800021f4:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021f8:	1a d8       	st.w	--sp,r8
800021fa:	1a d6       	st.w	--sp,r6
800021fc:	08 9c       	mov	r12,r4
800021fe:	f0 1f 00 1c 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002202:	0f d9       	ld.ub	r9,r7[0x5]
80002204:	0f e8       	ld.ub	r8,r7[0x6]
80002206:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000220a:	1a d8       	st.w	--sp,r8
8000220c:	1a d6       	st.w	--sp,r6
8000220e:	06 9c       	mov	r12,r3
80002210:	f0 1f 00 17 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002214:	0f f9       	ld.ub	r9,r7[0x7]
80002216:	ef 38 00 08 	ld.ub	r8,r7[8]
8000221a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000221e:	1a d8       	st.w	--sp,r8
80002220:	1a d6       	st.w	--sp,r6
80002222:	04 9c       	mov	r12,r2
80002224:	f0 1f 00 12 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002228:	ef 39 00 09 	ld.ub	r9,r7[9]
8000222c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002230:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002234:	1a d8       	st.w	--sp,r8
80002236:	1a d6       	st.w	--sp,r6
80002238:	02 9c       	mov	r12,r1
8000223a:	f0 1f 00 0d 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000223e:	2f 8d       	sub	sp,-32
80002240:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002244:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002248:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000224c:	1a d8       	st.w	--sp,r8
8000224e:	1a d6       	st.w	--sp,r6
80002250:	00 9c       	mov	r12,r0
80002252:	f0 1f 00 07 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
80002256:	2f f6       	sub	r6,-1
80002258:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000225a:	2f ed       	sub	sp,-8
8000225c:	ec 05 18 00 	cp.b	r5,r6
80002260:	fe 9b ff c8 	brhi	800021f0 <ButtonConfig_brdcst_func+0x3c>
80002264:	d8 32       	popm	r0-r7,pc
80002266:	00 00       	add	r0,r0
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	cf 14       	brge	8000224c <ButtonConfig_brdcst_func+0x98>
8000226c:	80 00       	ld.sh	r0,r0[0x0]
8000226e:	6d 14       	ld.w	r4,r6[0x44]
80002270:	80 00       	ld.sh	r0,r0[0x0]
80002272:	cf 34       	brge	80002258 <ButtonConfig_brdcst_func+0xa4>
80002274:	80 00       	ld.sh	r0,r0[0x0]
80002276:	cf 48       	rjmp	8000245e <CallControl_brdcst_func+0x42>
80002278:	80 00       	ld.sh	r0,r0[0x0]
8000227a:	cf 60       	breq	80002266 <ButtonConfig_brdcst_func+0xb2>
8000227c:	80 00       	ld.sh	r0,r0[0x0]
8000227e:	cf 80       	breq	8000226e <ButtonConfig_brdcst_func+0xba>
80002280:	80 00       	ld.sh	r0,r0[0x0]
80002282:	cf a8       	rjmp	80002476 <TransmitControl_brdcst_func+0x16>
80002284:	80 00       	ld.sh	r0,r0[0x0]
80002286:	cf d0       	breq	80002280 <ButtonConfig_brdcst_func+0xcc>
80002288:	80 00       	ld.sh	r0,r0[0x0]
8000228a:	cf f4       	brge	80002288 <ButtonConfig_brdcst_func+0xd4>
8000228c:	80 00       	ld.sh	r0,r0[0x0]
8000228e:	d0 1c       	*unknown*

80002290 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002290:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002294:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002298:	0f 89       	ld.ub	r9,r7[0x0]
8000229a:	30 08       	mov	r8,0
8000229c:	f0 09 18 00 	cp.b	r9,r8
800022a0:	c0 c1       	brne	800022b8 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022a2:	48 9c       	lddpc	r12,800022c4 <ButtonConfig_reply_func+0x34>
800022a4:	f0 1f 00 09 	mcall	800022c8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022a8:	0f 98       	ld.ub	r8,r7[0x1]
800022aa:	1a d8       	st.w	--sp,r8
800022ac:	48 8c       	lddpc	r12,800022cc <ButtonConfig_reply_func+0x3c>
800022ae:	f0 1f 00 07 	mcall	800022c8 <ButtonConfig_reply_func+0x38>
800022b2:	2f fd       	sub	sp,-4
800022b4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022b8:	48 6c       	lddpc	r12,800022d0 <ButtonConfig_reply_func+0x40>
800022ba:	f0 1f 00 04 	mcall	800022c8 <ButtonConfig_reply_func+0x38>
800022be:	e3 cd 80 80 	ldm	sp++,r7,pc
800022c2:	00 00       	add	r0,r0
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	d0 40       	acall	0x4
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	6d 14       	ld.w	r4,r6[0x44]
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	cf 34       	brge	800022b4 <ButtonConfig_reply_func+0x24>
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	d0 58       	*unknown*

800022d4 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800022d4:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800022d6:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
800022da:	0d 88       	ld.ub	r8,r6[0x0]
800022dc:	32 49       	mov	r9,36
800022de:	f2 08 18 00 	cp.b	r8,r9
800022e2:	c2 91       	brne	80002334 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800022e4:	4a 7c       	lddpc	r12,80002380 <DataSession_brdcst_func+0xac>
800022e6:	f0 1f 00 28 	mcall	80002384 <DataSession_brdcst_func+0xb0>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800022ea:	0d a5       	ld.ub	r5,r6[0x2]
800022ec:	0d b8       	ld.ub	r8,r6[0x3]
800022ee:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800022f2:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800022f4:	0d 98       	ld.ub	r8,r6[0x1]
800022f6:	1a d8       	st.w	--sp,r8
800022f8:	4a 4c       	lddpc	r12,80002388 <DataSession_brdcst_func+0xb4>
800022fa:	f0 1f 00 23 	mcall	80002384 <DataSession_brdcst_func+0xb0>
		log("\n\r paylaod_length: %d \n\r",data_length );
800022fe:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002302:	1a d8       	st.w	--sp,r8
80002304:	4a 2c       	lddpc	r12,8000238c <DataSession_brdcst_func+0xb8>
80002306:	f0 1f 00 20 	mcall	80002384 <DataSession_brdcst_func+0xb0>
		for(i=0; i<data_length; i++)
8000230a:	2f ed       	sub	sp,-8
8000230c:	58 05       	cp.w	r5,0
8000230e:	c3 70       	breq	8000237c <DataSession_brdcst_func+0xa8>
80002310:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002312:	4a 04       	lddpc	r4,80002390 <DataSession_brdcst_func+0xbc>
80002314:	ec 07 00 08 	add	r8,r6,r7
80002318:	11 c8       	ld.ub	r8,r8[0x4]
8000231a:	1a d8       	st.w	--sp,r8
8000231c:	1a d7       	st.w	--sp,r7
8000231e:	08 9c       	mov	r12,r4
80002320:	f0 1f 00 19 	mcall	80002384 <DataSession_brdcst_func+0xb0>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002324:	2f f7       	sub	r7,-1
80002326:	5c 57       	castu.b	r7
80002328:	2f ed       	sub	sp,-8
8000232a:	ee 05 19 00 	cp.h	r5,r7
8000232e:	fe 9b ff f3 	brhi	80002314 <DataSession_brdcst_func+0x40>
80002332:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("State: %X \n", ptr->State);
80002334:	1a d8       	st.w	--sp,r8
80002336:	49 8c       	lddpc	r12,80002394 <DataSession_brdcst_func+0xc0>
80002338:	f0 1f 00 13 	mcall	80002384 <DataSession_brdcst_func+0xb0>
		if (ptr->State == DATA_SESSION_TX_Suc)
8000233c:	0d 88       	ld.ub	r8,r6[0x0]
8000233e:	2f fd       	sub	sp,-4
80002340:	30 39       	mov	r9,3
80002342:	f2 08 18 00 	cp.b	r8,r9
80002346:	c0 51       	brne	80002350 <DataSession_brdcst_func+0x7c>
		{
			log("data transmit success\n");
80002348:	49 4c       	lddpc	r12,80002398 <DataSession_brdcst_func+0xc4>
8000234a:	f0 1f 00 0f 	mcall	80002384 <DataSession_brdcst_func+0xb0>
8000234e:	c0 88       	rjmp	8000235e <DataSession_brdcst_func+0x8a>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
80002350:	30 49       	mov	r9,4
80002352:	f2 08 18 00 	cp.b	r8,r9
80002356:	c0 41       	brne	8000235e <DataSession_brdcst_func+0x8a>
		{
			log("data transmit failure\n");
80002358:	49 1c       	lddpc	r12,8000239c <DataSession_brdcst_func+0xc8>
8000235a:	f0 1f 00 0b 	mcall	80002384 <DataSession_brdcst_func+0xb0>
			//xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate send-failure!!!
		}
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
			
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
8000235e:	0d a7       	ld.ub	r7,r6[0x2]
80002360:	0d b8       	ld.ub	r8,r6[0x3]
80002362:	f1 e7 10 87 	or	r7,r8,r7<<0x8

		log("\n\r Session_ID: %x \n\r",Session_number );
80002366:	0d 98       	ld.ub	r8,r6[0x1]
80002368:	1a d8       	st.w	--sp,r8
8000236a:	48 8c       	lddpc	r12,80002388 <DataSession_brdcst_func+0xb4>
8000236c:	f0 1f 00 06 	mcall	80002384 <DataSession_brdcst_func+0xb0>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002370:	5c 77       	castu.h	r7
80002372:	1a d7       	st.w	--sp,r7
80002374:	48 6c       	lddpc	r12,8000238c <DataSession_brdcst_func+0xb8>
80002376:	f0 1f 00 04 	mcall	80002384 <DataSession_brdcst_func+0xb0>
8000237a:	2f ed       	sub	sp,-8
8000237c:	d8 22       	popm	r4-r7,pc
8000237e:	00 00       	add	r0,r0
80002380:	80 00       	ld.sh	r0,r0[0x0]
80002382:	d0 74       	*unknown*
80002384:	80 00       	ld.sh	r0,r0[0x0]
80002386:	6d 14       	ld.w	r4,r6[0x44]
80002388:	80 00       	ld.sh	r0,r0[0x0]
8000238a:	d0 88       	*unknown*
8000238c:	80 00       	ld.sh	r0,r0[0x0]
8000238e:	d0 a0       	acall	0xa
80002390:	80 00       	ld.sh	r0,r0[0x0]
80002392:	d0 bc       	*unknown*
80002394:	80 00       	ld.sh	r0,r0[0x0]
80002396:	d0 d4       	*unknown*
80002398:	80 00       	ld.sh	r0,r0[0x0]
8000239a:	d0 e0       	acall	0xe
8000239c:	80 00       	ld.sh	r0,r0[0x0]
8000239e:	d0 f8       	*unknown*

800023a0 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
800023a0:	eb cd 40 80 	pushm	r7,lr
800023a4:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800023a6:	19 a9       	ld.ub	r9,r12[0x2]
800023a8:	30 08       	mov	r8,0
800023aa:	f0 09 18 00 	cp.b	r9,r8
800023ae:	c1 11       	brne	800023d0 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
800023b0:	49 3c       	lddpc	r12,800023fc <DataSession_reply_func+0x5c>
800023b2:	f0 1f 00 14 	mcall	80002400 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
800023b6:	0f b8       	ld.ub	r8,r7[0x3]
800023b8:	1a d8       	st.w	--sp,r8
800023ba:	49 3c       	lddpc	r12,80002404 <DataSession_reply_func+0x64>
800023bc:	f0 1f 00 11 	mcall	80002400 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
800023c0:	0f c8       	ld.ub	r8,r7[0x4]
800023c2:	1a d8       	st.w	--sp,r8
800023c4:	49 1c       	lddpc	r12,80002408 <DataSession_reply_func+0x68>
800023c6:	f0 1f 00 0f 	mcall	80002400 <DataSession_reply_func+0x60>
800023ca:	2f ed       	sub	sp,-8
800023cc:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
800023d0:	48 fc       	lddpc	r12,8000240c <DataSession_reply_func+0x6c>
800023d2:	f0 1f 00 0c 	mcall	80002400 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
800023d6:	0f a8       	ld.ub	r8,r7[0x2]
800023d8:	1a d8       	st.w	--sp,r8
800023da:	48 ec       	lddpc	r12,80002410 <DataSession_reply_func+0x70>
800023dc:	f0 1f 00 09 	mcall	80002400 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
800023e0:	0f b8       	ld.ub	r8,r7[0x3]
800023e2:	1a d8       	st.w	--sp,r8
800023e4:	48 cc       	lddpc	r12,80002414 <DataSession_reply_func+0x74>
800023e6:	f0 1f 00 07 	mcall	80002400 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
800023ea:	0f c8       	ld.ub	r8,r7[0x4]
800023ec:	1a d8       	st.w	--sp,r8
800023ee:	48 bc       	lddpc	r12,80002418 <DataSession_reply_func+0x78>
800023f0:	f0 1f 00 04 	mcall	80002400 <DataSession_reply_func+0x60>
800023f4:	2f dd       	sub	sp,-12
800023f6:	e3 cd 80 80 	ldm	sp++,r7,pc
800023fa:	00 00       	add	r0,r0
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	d1 10       	acall	0x11
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	6d 14       	ld.w	r4,r6[0x44]
80002404:	80 00       	ld.sh	r0,r0[0x0]
80002406:	d1 20       	acall	0x12
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	d1 2c       	*unknown*
8000240c:	80 00       	ld.sh	r0,r0[0x0]
8000240e:	d1 38       	*unknown*
80002410:	80 00       	ld.sh	r0,r0[0x0]
80002412:	d1 48       	*unknown*
80002414:	80 00       	ld.sh	r0,r0[0x0]
80002416:	d1 58       	*unknown*
80002418:	80 00       	ld.sh	r0,r0[0x0]
8000241a:	d1 64       	*unknown*

8000241c <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
8000241c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002420:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002424:	0f 98       	ld.ub	r8,r7[0x1]
80002426:	1a d8       	st.w	--sp,r8
80002428:	48 bc       	lddpc	r12,80002454 <CallControl_brdcst_func+0x38>
8000242a:	f0 1f 00 0c 	mcall	80002458 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000242e:	2f fd       	sub	sp,-4
80002430:	0f 99       	ld.ub	r9,r7[0x1]
80002432:	30 38       	mov	r8,3
80002434:	f0 09 18 00 	cp.b	r9,r8
80002438:	c0 41       	brne	80002440 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
8000243a:	30 09       	mov	r9,0
8000243c:	48 88       	lddpc	r8,8000245c <CallControl_brdcst_func+0x40>
8000243e:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
80002440:	0f 99       	ld.ub	r9,r7[0x1]
80002442:	30 48       	mov	r8,4
80002444:	f0 09 18 00 	cp.b	r9,r8
80002448:	c0 41       	brne	80002450 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
8000244a:	30 19       	mov	r9,1
8000244c:	48 48       	lddpc	r8,8000245c <CallControl_brdcst_func+0x40>
8000244e:	b0 89       	st.b	r8[0x0],r9
80002450:	e3 cd 80 80 	ldm	sp++,r7,pc
80002454:	80 00       	ld.sh	r0,r0[0x0]
80002456:	d1 70       	acall	0x17
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	6d 14       	ld.w	r4,r6[0x44]
8000245c:	00 00       	add	r0,r0
8000245e:	0a 52       	eor	r2,r5

80002460 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002460:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002464:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002468:	0f 99       	ld.ub	r9,r7[0x1]
8000246a:	30 08       	mov	r8,0
8000246c:	f0 09 18 00 	cp.b	r9,r8
80002470:	c0 71       	brne	8000247e <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
80002472:	48 ac       	lddpc	r12,80002498 <TransmitControl_brdcst_func+0x38>
80002474:	f0 1f 00 0a 	mcall	8000249c <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
80002478:	30 09       	mov	r9,0
8000247a:	48 a8       	lddpc	r8,800024a0 <TransmitControl_brdcst_func+0x40>
8000247c:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
8000247e:	0f 99       	ld.ub	r9,r7[0x1]
80002480:	30 18       	mov	r8,1
80002482:	f0 09 18 00 	cp.b	r9,r8
80002486:	c0 71       	brne	80002494 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
80002488:	48 7c       	lddpc	r12,800024a4 <TransmitControl_brdcst_func+0x44>
8000248a:	f0 1f 00 05 	mcall	8000249c <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
8000248e:	30 19       	mov	r9,1
80002490:	48 48       	lddpc	r8,800024a0 <TransmitControl_brdcst_func+0x40>
80002492:	b0 89       	st.b	r8[0x0],r9
80002494:	e3 cd 80 80 	ldm	sp++,r7,pc
80002498:	80 00       	ld.sh	r0,r0[0x0]
8000249a:	d1 88       	*unknown*
8000249c:	80 00       	ld.sh	r0,r0[0x0]
8000249e:	6d 14       	ld.w	r4,r6[0x44]
800024a0:	00 00       	add	r0,r0
800024a2:	0a 51       	eor	r1,r5
800024a4:	80 00       	ld.sh	r0,r0[0x0]
800024a6:	d1 a0       	acall	0x1a

800024a8 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
800024a8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
800024ac:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
800024b0:	0f 89       	ld.ub	r9,r7[0x0]
800024b2:	30 08       	mov	r8,0
800024b4:	f0 09 18 00 	cp.b	r9,r8
800024b8:	c1 61       	brne	800024e4 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
800024ba:	48 ec       	lddpc	r12,800024f0 <TransmitControl_reply_func+0x48>
800024bc:	f0 1f 00 0e 	mcall	800024f4 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
800024c0:	0f 98       	ld.ub	r8,r7[0x1]
800024c2:	1a d8       	st.w	--sp,r8
800024c4:	48 dc       	lddpc	r12,800024f8 <TransmitControl_reply_func+0x50>
800024c6:	f0 1f 00 0c 	mcall	800024f4 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
800024ca:	0f a8       	ld.ub	r8,r7[0x2]
800024cc:	1a d8       	st.w	--sp,r8
800024ce:	48 cc       	lddpc	r12,800024fc <TransmitControl_reply_func+0x54>
800024d0:	f0 1f 00 09 	mcall	800024f4 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
800024d4:	0f b8       	ld.ub	r8,r7[0x3]
800024d6:	1a d8       	st.w	--sp,r8
800024d8:	48 ac       	lddpc	r12,80002500 <TransmitControl_reply_func+0x58>
800024da:	f0 1f 00 07 	mcall	800024f4 <TransmitControl_reply_func+0x4c>
800024de:	2f dd       	sub	sp,-12
800024e0:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
800024e4:	48 8c       	lddpc	r12,80002504 <TransmitControl_reply_func+0x5c>
800024e6:	f0 1f 00 04 	mcall	800024f4 <TransmitControl_reply_func+0x4c>
800024ea:	e3 cd 80 80 	ldm	sp++,r7,pc
800024ee:	00 00       	add	r0,r0
800024f0:	80 00       	ld.sh	r0,r0[0x0]
800024f2:	d1 b4       	*unknown*
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	6d 14       	ld.w	r4,r6[0x44]
800024f8:	80 00       	ld.sh	r0,r0[0x0]
800024fa:	d1 d0       	acall	0x1d
800024fc:	80 00       	ld.sh	r0,r0[0x0]
800024fe:	d1 e4       	*unknown*
80002500:	80 00       	ld.sh	r0,r0[0x0]
80002502:	d2 00       	acall	0x20
80002504:	80 00       	ld.sh	r0,r0[0x0]
80002506:	d2 10       	acall	0x21

80002508 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002508:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000250a:	19 a9       	ld.ub	r9,r12[0x2]
8000250c:	30 08       	mov	r8,0
8000250e:	f0 09 18 00 	cp.b	r9,r8
80002512:	c0 51       	brne	8000251c <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002514:	48 4c       	lddpc	r12,80002524 <AudioRoutingControl_reply_func+0x1c>
80002516:	f0 1f 00 05 	mcall	80002528 <AudioRoutingControl_reply_func+0x20>
8000251a:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
8000251c:	48 4c       	lddpc	r12,8000252c <AudioRoutingControl_reply_func+0x24>
8000251e:	f0 1f 00 03 	mcall	80002528 <AudioRoutingControl_reply_func+0x20>
80002522:	d8 02       	popm	pc
80002524:	80 00       	ld.sh	r0,r0[0x0]
80002526:	d2 28       	*unknown*
80002528:	80 00       	ld.sh	r0,r0[0x0]
8000252a:	6d 14       	ld.w	r4,r6[0x44]
8000252c:	80 00       	ld.sh	r0,r0[0x0]
8000252e:	d2 38       	*unknown*

80002530 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002530:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002534:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80002538:	0f 89       	ld.ub	r9,r7[0x0]
8000253a:	30 08       	mov	r8,0
8000253c:	f0 09 18 00 	cp.b	r9,r8
80002540:	c1 b1       	brne	80002576 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002542:	0f b8       	ld.ub	r8,r7[0x3]
80002544:	31 09       	mov	r9,16
80002546:	f2 08 18 00 	cp.b	r8,r9
8000254a:	c0 f1       	brne	80002568 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
8000254c:	48 dc       	lddpc	r12,80002580 <Volume_reply_func+0x50>
8000254e:	f0 1f 00 0e 	mcall	80002584 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002552:	0f 99       	ld.ub	r9,r7[0x1]
80002554:	0f a8       	ld.ub	r8,r7[0x2]
80002556:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000255a:	1a d8       	st.w	--sp,r8
8000255c:	48 bc       	lddpc	r12,80002588 <Volume_reply_func+0x58>
8000255e:	f0 1f 00 0a 	mcall	80002584 <Volume_reply_func+0x54>
80002562:	2f fd       	sub	sp,-4
80002564:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
80002568:	1a d8       	st.w	--sp,r8
8000256a:	48 9c       	lddpc	r12,8000258c <Volume_reply_func+0x5c>
8000256c:	f0 1f 00 06 	mcall	80002584 <Volume_reply_func+0x54>
80002570:	2f fd       	sub	sp,-4
80002572:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
80002576:	48 7c       	lddpc	r12,80002590 <Volume_reply_func+0x60>
80002578:	f0 1f 00 03 	mcall	80002584 <Volume_reply_func+0x54>
8000257c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002580:	80 00       	ld.sh	r0,r0[0x0]
80002582:	d2 4c       	*unknown*
80002584:	80 00       	ld.sh	r0,r0[0x0]
80002586:	6d 14       	ld.w	r4,r6[0x44]
80002588:	80 00       	ld.sh	r0,r0[0x0]
8000258a:	d2 60       	acall	0x26
8000258c:	80 00       	ld.sh	r0,r0[0x0]
8000258e:	d2 7c       	*unknown*
80002590:	80 00       	ld.sh	r0,r0[0x0]
80002592:	d2 94       	*unknown*

80002594 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002594:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002596:	19 d9       	ld.ub	r9,r12[0x5]
80002598:	30 08       	mov	r8,0
8000259a:	f0 09 18 00 	cp.b	r9,r8
8000259e:	c0 81       	brne	800025ae <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
800025a0:	10 99       	mov	r9,r8
800025a2:	48 78       	lddpc	r8,800025bc <spk_brdcst_func+0x28>
800025a4:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
800025a6:	48 7c       	lddpc	r12,800025c0 <spk_brdcst_func+0x2c>
800025a8:	f0 1f 00 07 	mcall	800025c4 <spk_brdcst_func+0x30>
800025ac:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
800025ae:	30 19       	mov	r9,1
800025b0:	48 38       	lddpc	r8,800025bc <spk_brdcst_func+0x28>
800025b2:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
800025b4:	48 5c       	lddpc	r12,800025c8 <spk_brdcst_func+0x34>
800025b6:	f0 1f 00 04 	mcall	800025c4 <spk_brdcst_func+0x30>
800025ba:	d8 02       	popm	pc
800025bc:	00 00       	add	r0,r0
800025be:	0a 40       	or	r0,r5
800025c0:	80 00       	ld.sh	r0,r0[0x0]
800025c2:	d2 ac       	*unknown*
800025c4:	80 00       	ld.sh	r0,r0[0x0]
800025c6:	6d 14       	ld.w	r4,r6[0x44]
800025c8:	80 00       	ld.sh	r0,r0[0x0]
800025ca:	d2 bc       	*unknown*

800025cc <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
800025cc:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800025ce:	19 a9       	ld.ub	r9,r12[0x2]
800025d0:	30 08       	mov	r8,0
800025d2:	f0 09 18 00 	cp.b	r9,r8
800025d6:	c0 f1       	brne	800025f4 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
800025d8:	19 e9       	ld.ub	r9,r12[0x6]
800025da:	f0 09 18 00 	cp.b	r9,r8
800025de:	c0 40       	breq	800025e6 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
800025e0:	30 19       	mov	r9,1
800025e2:	48 98       	lddpc	r8,80002604 <spk_reply_func+0x38>
800025e4:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
800025e6:	19 e8       	ld.ub	r8,r12[0x6]
800025e8:	1a d8       	st.w	--sp,r8
800025ea:	48 8c       	lddpc	r12,80002608 <spk_reply_func+0x3c>
800025ec:	f0 1f 00 08 	mcall	8000260c <spk_reply_func+0x40>
800025f0:	2f fd       	sub	sp,-4
800025f2:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
800025f4:	30 09       	mov	r9,0
800025f6:	48 48       	lddpc	r8,80002604 <spk_reply_func+0x38>
800025f8:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
800025fa:	48 6c       	lddpc	r12,80002610 <spk_reply_func+0x44>
800025fc:	f0 1f 00 04 	mcall	8000260c <spk_reply_func+0x40>
80002600:	d8 02       	popm	pc
80002602:	00 00       	add	r0,r0
80002604:	00 00       	add	r0,r0
80002606:	0a 40       	or	r0,r5
80002608:	80 00       	ld.sh	r0,r0[0x0]
8000260a:	d2 c8       	*unknown*
8000260c:	80 00       	ld.sh	r0,r0[0x0]
8000260e:	6d 14       	ld.w	r4,r6[0x44]
80002610:	80 00       	ld.sh	r0,r0[0x0]
80002612:	d2 d8       	*unknown*

80002614 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002614:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002618:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
8000261c:	0f a9       	ld.ub	r9,r7[0x2]
8000261e:	30 08       	mov	r8,0
80002620:	f0 09 18 00 	cp.b	r9,r8
80002624:	c0 71       	brne	80002632 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
80002626:	48 dc       	lddpc	r12,80002658 <mic_brdcst_func+0x44>
80002628:	f0 1f 00 0d 	mcall	8000265c <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
8000262c:	30 09       	mov	r9,0
8000262e:	48 d8       	lddpc	r8,80002660 <mic_brdcst_func+0x4c>
80002630:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002632:	0f a9       	ld.ub	r9,r7[0x2]
80002634:	31 18       	mov	r8,17
80002636:	f0 09 18 00 	cp.b	r9,r8
8000263a:	c0 d1       	brne	80002654 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
8000263c:	48 ac       	lddpc	r12,80002664 <mic_brdcst_func+0x50>
8000263e:	f0 1f 00 08 	mcall	8000265c <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
80002642:	48 89       	lddpc	r9,80002660 <mic_brdcst_func+0x4c>
80002644:	30 18       	mov	r8,1
80002646:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
80002648:	13 89       	ld.ub	r9,r9[0x0]
8000264a:	f0 09 18 00 	cp.b	r9,r8
8000264e:	c0 31       	brne	80002654 <mic_brdcst_func+0x40>
80002650:	48 68       	lddpc	r8,80002668 <mic_brdcst_func+0x54>
80002652:	11 88       	ld.ub	r8,r8[0x0]
80002654:	e3 cd 80 80 	ldm	sp++,r7,pc
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	d2 e4       	*unknown*
8000265c:	80 00       	ld.sh	r0,r0[0x0]
8000265e:	6d 14       	ld.w	r4,r6[0x44]
80002660:	00 00       	add	r0,r0
80002662:	0a 56       	eor	r6,r5
80002664:	80 00       	ld.sh	r0,r0[0x0]
80002666:	d2 f8       	*unknown*
80002668:	00 00       	add	r0,r0
8000266a:	0a 52       	eor	r2,r5

8000266c <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
8000266c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002670:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002674:	49 ac       	lddpc	r12,800026dc <mic_reply_func+0x70>
80002676:	f0 1f 00 1b 	mcall	800026e0 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
8000267a:	0f 89       	ld.ub	r9,r7[0x0]
8000267c:	30 08       	mov	r8,0
8000267e:	f0 09 18 00 	cp.b	r9,r8
80002682:	c2 71       	brne	800026d0 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
80002684:	0f 98       	ld.ub	r8,r7[0x1]
80002686:	30 29       	mov	r9,2
80002688:	f2 08 18 00 	cp.b	r8,r9
8000268c:	c1 b1       	brne	800026c2 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
8000268e:	49 6c       	lddpc	r12,800026e4 <mic_reply_func+0x78>
80002690:	f0 1f 00 14 	mcall	800026e0 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002694:	0f a8       	ld.ub	r8,r7[0x2]
80002696:	1a d8       	st.w	--sp,r8
80002698:	49 4c       	lddpc	r12,800026e8 <mic_reply_func+0x7c>
8000269a:	f0 1f 00 12 	mcall	800026e0 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
8000269e:	0f b8       	ld.ub	r8,r7[0x3]
800026a0:	1a d8       	st.w	--sp,r8
800026a2:	49 3c       	lddpc	r12,800026ec <mic_reply_func+0x80>
800026a4:	f0 1f 00 0f 	mcall	800026e0 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
800026a8:	0f c8       	ld.ub	r8,r7[0x4]
800026aa:	1a d8       	st.w	--sp,r8
800026ac:	49 1c       	lddpc	r12,800026f0 <mic_reply_func+0x84>
800026ae:	f0 1f 00 0d 	mcall	800026e0 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
800026b2:	0f d8       	ld.ub	r8,r7[0x5]
800026b4:	1a d8       	st.w	--sp,r8
800026b6:	49 0c       	lddpc	r12,800026f4 <mic_reply_func+0x88>
800026b8:	f0 1f 00 0a 	mcall	800026e0 <mic_reply_func+0x74>
800026bc:	2f cd       	sub	sp,-16
800026be:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800026c2:	1a d8       	st.w	--sp,r8
800026c4:	48 dc       	lddpc	r12,800026f8 <mic_reply_func+0x8c>
800026c6:	f0 1f 00 07 	mcall	800026e0 <mic_reply_func+0x74>
800026ca:	2f fd       	sub	sp,-4
800026cc:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800026d0:	48 bc       	lddpc	r12,800026fc <mic_reply_func+0x90>
800026d2:	f0 1f 00 04 	mcall	800026e0 <mic_reply_func+0x74>
800026d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800026da:	00 00       	add	r0,r0
800026dc:	80 00       	ld.sh	r0,r0[0x0]
800026de:	d3 0c       	*unknown*
800026e0:	80 00       	ld.sh	r0,r0[0x0]
800026e2:	6d 14       	ld.w	r4,r6[0x44]
800026e4:	80 00       	ld.sh	r0,r0[0x0]
800026e6:	d3 1c       	*unknown*
800026e8:	80 00       	ld.sh	r0,r0[0x0]
800026ea:	d3 30       	acall	0x33
800026ec:	80 00       	ld.sh	r0,r0[0x0]
800026ee:	d3 44       	*unknown*
800026f0:	80 00       	ld.sh	r0,r0[0x0]
800026f2:	d3 60       	acall	0x36
800026f4:	80 00       	ld.sh	r0,r0[0x0]
800026f6:	d3 78       	*unknown*
800026f8:	80 00       	ld.sh	r0,r0[0x0]
800026fa:	d3 90       	acall	0x39
800026fc:	80 00       	ld.sh	r0,r0[0x0]
800026fe:	d3 a8       	*unknown*

80002700 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002700:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002704:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002708:	48 bc       	lddpc	r12,80002734 <dcm_brdcst_func+0x34>
8000270a:	f0 1f 00 0c 	mcall	80002738 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
8000270e:	0f 88       	ld.ub	r8,r7[0x0]
80002710:	1a d8       	st.w	--sp,r8
80002712:	48 bc       	lddpc	r12,8000273c <dcm_brdcst_func+0x3c>
80002714:	f0 1f 00 09 	mcall	80002738 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002718:	0f a8       	ld.ub	r8,r7[0x2]
8000271a:	1a d8       	st.w	--sp,r8
8000271c:	48 9c       	lddpc	r12,80002740 <dcm_brdcst_func+0x40>
8000271e:	f0 1f 00 07 	mcall	80002738 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002722:	0f 98       	ld.ub	r8,r7[0x1]
80002724:	1a d8       	st.w	--sp,r8
80002726:	48 8c       	lddpc	r12,80002744 <dcm_brdcst_func+0x44>
80002728:	f0 1f 00 04 	mcall	80002738 <dcm_brdcst_func+0x38>
8000272c:	2f dd       	sub	sp,-12
	
	
}
8000272e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002732:	00 00       	add	r0,r0
80002734:	80 00       	ld.sh	r0,r0[0x0]
80002736:	d3 b8       	*unknown*
80002738:	80 00       	ld.sh	r0,r0[0x0]
8000273a:	6d 14       	ld.w	r4,r6[0x44]
8000273c:	80 00       	ld.sh	r0,r0[0x0]
8000273e:	d3 cc       	*unknown*
80002740:	80 00       	ld.sh	r0,r0[0x0]
80002742:	d3 e0       	acall	0x3e
80002744:	80 00       	ld.sh	r0,r0[0x0]
80002746:	d3 f8       	*unknown*

80002748 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002748:	eb cd 40 80 	pushm	r7,lr
8000274c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000274e:	19 a9       	ld.ub	r9,r12[0x2]
80002750:	30 08       	mov	r8,0
80002752:	f0 09 18 00 	cp.b	r9,r8
80002756:	c1 b1       	brne	8000278c <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
80002758:	19 b8       	ld.ub	r8,r12[0x3]
8000275a:	30 19       	mov	r9,1
8000275c:	f2 08 18 00 	cp.b	r8,r9
80002760:	c0 51       	brne	8000276a <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
80002762:	48 ec       	lddpc	r12,80002798 <dcm_reply_func+0x50>
80002764:	f0 1f 00 0e 	mcall	8000279c <dcm_reply_func+0x54>
80002768:	c0 a8       	rjmp	8000277c <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
8000276a:	58 08       	cp.w	r8,0
8000276c:	c0 51       	brne	80002776 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
8000276e:	48 dc       	lddpc	r12,800027a0 <dcm_reply_func+0x58>
80002770:	f0 1f 00 0b 	mcall	8000279c <dcm_reply_func+0x54>
80002774:	c0 48       	rjmp	8000277c <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
80002776:	48 cc       	lddpc	r12,800027a4 <dcm_reply_func+0x5c>
80002778:	f0 1f 00 09 	mcall	8000279c <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
8000277c:	0f d8       	ld.ub	r8,r7[0x5]
8000277e:	1a d8       	st.w	--sp,r8
80002780:	48 ac       	lddpc	r12,800027a8 <dcm_reply_func+0x60>
80002782:	f0 1f 00 07 	mcall	8000279c <dcm_reply_func+0x54>
80002786:	2f fd       	sub	sp,-4
80002788:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
8000278c:	48 8c       	lddpc	r12,800027ac <dcm_reply_func+0x64>
8000278e:	f0 1f 00 04 	mcall	8000279c <dcm_reply_func+0x54>
80002792:	e3 cd 80 80 	ldm	sp++,r7,pc
80002796:	00 00       	add	r0,r0
80002798:	80 00       	ld.sh	r0,r0[0x0]
8000279a:	d4 14       	*unknown*
8000279c:	80 00       	ld.sh	r0,r0[0x0]
8000279e:	6d 14       	ld.w	r4,r6[0x44]
800027a0:	80 00       	ld.sh	r0,r0[0x0]
800027a2:	d4 28       	*unknown*
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	d4 3c       	*unknown*
800027a8:	80 00       	ld.sh	r0,r0[0x0]
800027aa:	d4 50       	acall	0x45
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	d4 5c       	*unknown*

800027b0 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800027b0:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800027b2:	19 a9       	ld.ub	r9,r12[0x2]
800027b4:	30 08       	mov	r8,0
800027b6:	f0 09 18 00 	cp.b	r9,r8
800027ba:	c0 51       	brne	800027c4 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
800027bc:	48 4c       	lddpc	r12,800027cc <ToneControl_reply_func+0x1c>
800027be:	f0 1f 00 05 	mcall	800027d0 <ToneControl_reply_func+0x20>
800027c2:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027c4:	48 4c       	lddpc	r12,800027d4 <ToneControl_reply_func+0x24>
800027c6:	f0 1f 00 03 	mcall	800027d0 <ToneControl_reply_func+0x20>
800027ca:	d8 02       	popm	pc
800027cc:	80 00       	ld.sh	r0,r0[0x0]
800027ce:	d4 68       	*unknown*
800027d0:	80 00       	ld.sh	r0,r0[0x0]
800027d2:	6d 14       	ld.w	r4,r6[0x44]
800027d4:	80 00       	ld.sh	r0,r0[0x0]
800027d6:	d4 74       	*unknown*

800027d8 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;
extern volatile DateTime Current_time;
static __app_Thread_(app_cfg)
{
800027d8:	d4 31       	pushm	r0-r7,lr
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	
	 xLastWakeTime = xTaskGetTickCount();
800027da:	f0 1f 00 1f 	mcall	80002854 <app_cfg+0x7c>
800027de:	49 f8       	lddpc	r8,80002858 <app_cfg+0x80>
800027e0:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027e2:	49 f6       	lddpc	r6,8000285c <app_cfg+0x84>
		{	
			connect_flag=1;	
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!

		}
		else if(connect_flag)
800027e4:	49 f5       	lddpc	r5,80002860 <app_cfg+0x88>
		else
		{
			nop();
			nop();
			nop();
			xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
800027e6:	30 62       	mov	r2,6
800027e8:	30 13       	mov	r3,1
					//log("no find card...\n");
				//}
				nop();
				log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n", 
				Current_time.Year, Current_time.Month, Current_time.Day, 
				Current_time.Hour, Current_time.Minute, Current_time.Second);
800027ea:	49 f7       	lddpc	r7,80002864 <app_cfg+0x8c>
				//else
				//{
					//log("no find card...\n");
				//}
				nop();
				log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n", 
800027ec:	49 f1       	lddpc	r1,80002868 <app_cfg+0x90>
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
		{	
			connect_flag=1;	
800027ee:	30 10       	mov	r0,1
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800027f0:	10 94       	mov	r4,r8
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027f2:	6c 08       	ld.w	r8,r6[0x0]
800027f4:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800027f8:	58 38       	cp.w	r8,3
800027fa:	c0 a1       	brne	8000280e <app_cfg+0x36>
800027fc:	0b 88       	ld.ub	r8,r5[0x0]
800027fe:	58 08       	cp.w	r8,0
80002800:	c0 71       	brne	8000280e <app_cfg+0x36>
		{	
			connect_flag=1;	
80002802:	aa 80       	st.b	r5[0x0],r0
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002804:	30 cb       	mov	r11,12
80002806:	06 9c       	mov	r12,r3
80002808:	f0 1f 00 19 	mcall	8000286c <app_cfg+0x94>
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
8000280c:	c1 d8       	rjmp	80002846 <app_cfg+0x6e>
		{	
			connect_flag=1;	
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!

		}
		else if(connect_flag)
8000280e:	0b 88       	ld.ub	r8,r5[0x0]
80002810:	58 08       	cp.w	r8,0
80002812:	c1 30       	breq	80002838 <app_cfg+0x60>
				//}
				//else
				//{
					//log("no find card...\n");
				//}
				nop();
80002814:	d7 03       	nop
				log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n", 
				Current_time.Year, Current_time.Month, Current_time.Day, 
				Current_time.Hour, Current_time.Minute, Current_time.Second);
80002816:	0f de       	ld.ub	lr,r7[0x5]
80002818:	0f cc       	ld.ub	r12,r7[0x4]
8000281a:	0f bb       	ld.ub	r11,r7[0x3]
				//{
					//log("no find card...\n");
				//}
				nop();
				log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n", 
				Current_time.Year, Current_time.Month, Current_time.Day, 
8000281c:	0f aa       	ld.ub	r10,r7[0x2]
8000281e:	0f 99       	ld.ub	r9,r7[0x1]
80002820:	0f 88       	ld.ub	r8,r7[0x0]
				//else
				//{
					//log("no find card...\n");
				//}
				nop();
				log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n", 
80002822:	1a de       	st.w	--sp,lr
80002824:	1a dc       	st.w	--sp,r12
80002826:	1a db       	st.w	--sp,r11
80002828:	1a da       	st.w	--sp,r10
8000282a:	1a d9       	st.w	--sp,r9
8000282c:	1a d8       	st.w	--sp,r8
8000282e:	02 9c       	mov	r12,r1
80002830:	f0 1f 00 10 	mcall	80002870 <app_cfg+0x98>
80002834:	2f ad       	sub	sp,-24
80002836:	c0 88       	rjmp	80002846 <app_cfg+0x6e>
				Current_time.Hour, Current_time.Minute, Current_time.Second);
				
		}
		else
		{
			nop();
80002838:	d7 03       	nop
			nop();
8000283a:	d7 03       	nop
			nop();
8000283c:	d7 03       	nop
			xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
8000283e:	04 9b       	mov	r11,r2
80002840:	06 9c       	mov	r12,r3
80002842:	f0 1f 00 0b 	mcall	8000286c <app_cfg+0x94>
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002846:	e0 6b 0f a0 	mov	r11,4000
8000284a:	08 9c       	mov	r12,r4
8000284c:	f0 1f 00 0a 	mcall	80002874 <app_cfg+0x9c>
	}
80002850:	cd 1b       	rjmp	800027f2 <app_cfg+0x1a>
80002852:	00 00       	add	r0,r0
80002854:	80 00       	ld.sh	r0,r0[0x0]
80002856:	66 40       	ld.w	r0,r3[0x10]
80002858:	00 00       	add	r0,r0
8000285a:	0a 44       	or	r4,r5
8000285c:	00 00       	add	r0,r0
8000285e:	0d 7c       	ld.ub	r12,--r6
80002860:	00 00       	add	r0,r0
80002862:	0a 55       	eor	r5,r5
80002864:	00 00       	add	r0,r0
80002866:	0d 80       	ld.ub	r0,r6[0x0]
80002868:	80 00       	ld.sh	r0,r0[0x0]
8000286a:	d4 80       	acall	0x48
8000286c:	80 00       	ld.sh	r0,r0[0x0]
8000286e:	40 20       	lddsp	r0,sp[0x8]
80002870:	80 00       	ld.sh	r0,r0[0x0]
80002872:	6d 14       	ld.w	r4,r6[0x44]
80002874:	80 00       	ld.sh	r0,r0[0x0]
80002876:	67 f0       	ld.w	r0,r3[0x7c]

80002878 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002878:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
8000287c:	19 c7       	ld.ub	r7,r12[0x4]
8000287e:	19 d8       	ld.ub	r8,r12[0x5]
80002880:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002884:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
80002886:	48 dc       	lddpc	r12,800028b8 <Phyuserinput_brdcst_func+0x40>
80002888:	f0 1f 00 0d 	mcall	800028bc <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
8000288c:	36 08       	mov	r8,96
8000288e:	f0 07 19 00 	cp.h	r7,r8
80002892:	c1 11       	brne	800028b4 <Phyuserinput_brdcst_func+0x3c>
80002894:	48 b8       	lddpc	r8,800028c0 <Phyuserinput_brdcst_func+0x48>
80002896:	11 89       	ld.ub	r9,r8[0x0]
80002898:	30 18       	mov	r8,1
8000289a:	f0 09 18 00 	cp.b	r9,r8
8000289e:	c0 b1       	brne	800028b4 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, ACK_Received_Tone);//set tone to indicate the scan!!!
800028a0:	31 4b       	mov	r11,20
800028a2:	30 1c       	mov	r12,1
800028a4:	f0 1f 00 08 	mcall	800028c4 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(400*2 / portTICK_RATE_MS);//延迟400ms
800028a8:	e0 6c 03 20 	mov	r12,800
800028ac:	f0 1f 00 07 	mcall	800028c8 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		rfid_sendID_message();//send message		
800028b0:	f0 1f 00 07 	mcall	800028cc <Phyuserinput_brdcst_func+0x54>
800028b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800028b8:	80 00       	ld.sh	r0,r0[0x0]
800028ba:	d4 ac       	*unknown*
800028bc:	80 00       	ld.sh	r0,r0[0x0]
800028be:	6d 14       	ld.w	r4,r6[0x44]
800028c0:	00 00       	add	r0,r0
800028c2:	0a 55       	eor	r5,r5
800028c4:	80 00       	ld.sh	r0,r0[0x0]
800028c6:	40 20       	lddsp	r0,sp[0x8]
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	67 a8       	ld.w	r8,r3[0x68]
800028cc:	80 00       	ld.sh	r0,r0[0x0]
800028ce:	4f f4       	lddpc	r4,80002ac8 <payload_init+0x34>

800028d0 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800028d0:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800028d2:	19 e8       	ld.ub	r8,r12[0x6]
800028d4:	30 19       	mov	r9,1
800028d6:	f2 08 18 00 	cp.b	r8,r9
800028da:	c0 61       	brne	800028e6 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028dc:	48 98       	lddpc	r8,80002900 <DeviceInitializationStatus_brdcst_func+0x30>
800028de:	70 09       	ld.w	r9,r8[0x0]
800028e0:	a1 a9       	sbr	r9,0x0
800028e2:	91 09       	st.w	r8[0x0],r9
800028e4:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028e6:	30 29       	mov	r9,2
800028e8:	f2 08 18 00 	cp.b	r8,r9
800028ec:	c0 80       	breq	800028fc <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028ee:	48 58       	lddpc	r8,80002900 <DeviceInitializationStatus_brdcst_func+0x30>
800028f0:	70 09       	ld.w	r9,r8[0x0]
800028f2:	e0 19 ff fc 	andl	r9,0xfffc
800028f6:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028f8:	f0 1f 00 03 	mcall	80002904 <DeviceInitializationStatus_brdcst_func+0x34>
800028fc:	d8 02       	popm	pc
800028fe:	00 00       	add	r0,r0
80002900:	00 00       	add	r0,r0
80002902:	0d 7c       	ld.ub	r12,--r6
80002904:	80 00       	ld.sh	r0,r0[0x0]
80002906:	3f 74       	mov	r4,-9

80002908 <xg_rtc_init>:
}



void xg_rtc_init(void)
{
80002908:	d4 01       	pushm	lr
	//{
		//return 3;
	//}
	  	
	  // Disable all interrupts. */
	  Disable_global_interrupt();
8000290a:	d3 03       	ssrf	0x10
	  
	  // Register the RTC interrupt handler to the interrupt controller.
	  INTC_register_interrupt(&rtc_irq, AVR32_RTC_IRQ, AVR32_INTC_INT0);
8000290c:	30 0a       	mov	r10,0
8000290e:	32 8b       	mov	r11,40
80002910:	49 5c       	lddpc	r12,80002964 <xg_rtc_init+0x5c>
80002912:	f0 1f 00 16 	mcall	80002968 <xg_rtc_init+0x60>

	  // Initialize the RTC
	  if (!rtc_init(&AVR32_RTC, RTC_OSC_RC, RTC_PSEL_RC_1_76HZ))
80002916:	30 fa       	mov	r10,15
80002918:	30 0b       	mov	r11,0
8000291a:	fe 7c 0d 00 	mov	r12,-62208
8000291e:	f0 1f 00 14 	mcall	8000296c <xg_rtc_init+0x64>
80002922:	c0 41       	brne	8000292a <xg_rtc_init+0x22>
	  //if (!rtc_init(&AVR32_RTC, RTC_OSC_32KHZ, RTC_PSEL_32KHZ_1HZ))
	  {
		  log("Error initializing the RTC\r\n");
80002924:	49 3c       	lddpc	r12,80002970 <xg_rtc_init+0x68>
80002926:	f0 1f 00 14 	mcall	80002974 <xg_rtc_init+0x6c>
	  }
	  // Set top value to 0 to generate an interrupt every seconds */
	  rtc_set_top_value(&AVR32_RTC, 0);
8000292a:	30 0b       	mov	r11,0
8000292c:	fe 7c 0d 00 	mov	r12,-62208
80002930:	f0 1f 00 12 	mcall	80002978 <xg_rtc_init+0x70>
	  // Enable the interrupts
	  rtc_enable_interrupt(&AVR32_RTC);
80002934:	fe 7c 0d 00 	mov	r12,-62208
80002938:	f0 1f 00 11 	mcall	8000297c <xg_rtc_init+0x74>
	  // Enable the RTC
	  rtc_enable(&AVR32_RTC);
8000293c:	fe 7c 0d 00 	mov	r12,-62208
80002940:	f0 1f 00 10 	mcall	80002980 <xg_rtc_init+0x78>

	Current_time.Year		= 16;
80002944:	49 08       	lddpc	r8,80002984 <xg_rtc_init+0x7c>
80002946:	31 09       	mov	r9,16
80002948:	b0 89       	st.b	r8[0x0],r9
	Current_time.Month		= 2;
8000294a:	30 29       	mov	r9,2
8000294c:	b0 99       	st.b	r8[0x1],r9
	Current_time.Day		= 29;
8000294e:	31 d9       	mov	r9,29
80002950:	b0 a9       	st.b	r8[0x2],r9
	Current_time.Hour		= 23;
80002952:	31 79       	mov	r9,23
80002954:	b0 b9       	st.b	r8[0x3],r9
	Current_time.Minute		= 59;
80002956:	33 b9       	mov	r9,59
80002958:	b0 c9       	st.b	r8[0x4],r9
	Current_time.Second		= 40;
8000295a:	32 89       	mov	r9,40
8000295c:	b0 d9       	st.b	r8[0x5],r9
	/*finished accessing the shared resource.Release the semaphore.*/
	//xSemaphoreGive(rtc_mutex);
	
	//sec = Current_time.Second;
	// Enable global interrupts
	Enable_global_interrupt();
8000295e:	d5 03       	csrf	0x10
	  
	//RTC_Test();	

}
80002960:	d8 02       	popm	pc
80002962:	00 00       	add	r0,r0
80002964:	80 00       	ld.sh	r0,r0[0x0]
80002966:	29 88       	sub	r8,-104
80002968:	80 00       	ld.sh	r0,r0[0x0]
8000296a:	53 24       	stdsp	sp[0xc8],r4
8000296c:	80 00       	ld.sh	r0,r0[0x0]
8000296e:	55 20       	stdsp	sp[0x148],r0
80002970:	80 00       	ld.sh	r0,r0[0x0]
80002972:	d4 cc       	*unknown*
80002974:	80 00       	ld.sh	r0,r0[0x0]
80002976:	6d 14       	ld.w	r4,r6[0x44]
80002978:	80 00       	ld.sh	r0,r0[0x0]
8000297a:	54 dc       	stdsp	sp[0x134],r12
8000297c:	80 00       	ld.sh	r0,r0[0x0]
8000297e:	54 d4       	stdsp	sp[0x134],r4
80002980:	80 00       	ld.sh	r0,r0[0x0]
80002982:	54 b0       	stdsp	sp[0x12c],r0
80002984:	00 00       	add	r0,r0
80002986:	0d 80       	ld.ub	r0,r6[0x0]

80002988 <rtc_irq>:
/* RTC Interrupt  */
#pragma handler = AVR32_RTC_IRQ_GROUP, 1
__interrupt
#endif
void rtc_irq(void)
{
80002988:	d4 01       	pushm	lr
	U8 T,K;
	U32 T16,K16;
	// Increment the minutes counter
	//sec++;
	
	Current_time.Second++;
8000298a:	4b 98       	lddpc	r8,80002a6c <rtc_irq+0xe4>
8000298c:	11 d9       	ld.ub	r9,r8[0x5]
8000298e:	2f f9       	sub	r9,-1
80002990:	b0 d9       	st.b	r8[0x5],r9
	if(Current_time.Second>=60)
80002992:	11 d9       	ld.ub	r9,r8[0x5]
80002994:	33 b8       	mov	r8,59
80002996:	f0 09 18 00 	cp.b	r9,r8
8000299a:	e0 88 00 5f 	brls	80002a58 <rtc_irq+0xd0>
	{
		Current_time.Second =0;
8000299e:	4b 48       	lddpc	r8,80002a6c <rtc_irq+0xe4>
800029a0:	30 09       	mov	r9,0
800029a2:	b0 d9       	st.b	r8[0x5],r9
		Current_time.Minute++;
800029a4:	11 c9       	ld.ub	r9,r8[0x4]
800029a6:	2f f9       	sub	r9,-1
800029a8:	b0 c9       	st.b	r8[0x4],r9
		if(Current_time.Minute>=60)
800029aa:	11 c9       	ld.ub	r9,r8[0x4]
800029ac:	33 b8       	mov	r8,59
800029ae:	f0 09 18 00 	cp.b	r9,r8
800029b2:	e0 88 00 53 	brls	80002a58 <rtc_irq+0xd0>
		{
			Current_time.Minute=0;
800029b6:	4a e8       	lddpc	r8,80002a6c <rtc_irq+0xe4>
800029b8:	30 09       	mov	r9,0
800029ba:	b0 c9       	st.b	r8[0x4],r9
			Current_time.Hour++;
800029bc:	11 b9       	ld.ub	r9,r8[0x3]
800029be:	2f f9       	sub	r9,-1
800029c0:	b0 b9       	st.b	r8[0x3],r9
			if (Current_time.Hour>=24)
800029c2:	11 b9       	ld.ub	r9,r8[0x3]
800029c4:	31 78       	mov	r8,23
800029c6:	f0 09 18 00 	cp.b	r9,r8
800029ca:	e0 88 00 47 	brls	80002a58 <rtc_irq+0xd0>
			{
				Current_time.Hour=0;
800029ce:	4a 88       	lddpc	r8,80002a6c <rtc_irq+0xe4>
800029d0:	30 09       	mov	r9,0
800029d2:	b0 b9       	st.b	r8[0x3],r9
				K16=(Current_time.Year&0x03)?365:366;				//判断当年是否为闰年,并获取当年的总天数（此算法时间起点为2000年）
800029d4:	11 88       	ld.ub	r8,r8[0x0]
800029d6:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800029da:	e0 69 01 6e 	mov	r9,366
800029de:	e0 6a 01 6d 	mov	r10,365
800029e2:	f4 08 17 10 	movne	r8,r10
800029e6:	f2 08 17 00 	moveq	r8,r9
				K16-=337;											//计算当年二月份天数
				//统计当月天数				
				K=(Current_time.Month==2)?K16:(((Current_time.Month+(Current_time.Month>>3))&0x01)+30);			
800029ea:	4a 19       	lddpc	r9,80002a6c <rtc_irq+0xe4>
800029ec:	13 9a       	ld.ub	r10,r9[0x1]
800029ee:	30 29       	mov	r9,2
800029f0:	f2 0a 18 00 	cp.b	r10,r9
800029f4:	c0 b0       	breq	80002a0a <rtc_irq+0x82>
800029f6:	49 e8       	lddpc	r8,80002a6c <rtc_irq+0xe4>
800029f8:	11 99       	ld.ub	r9,r8[0x1]
800029fa:	11 9a       	ld.ub	r10,r8[0x1]
800029fc:	a3 9a       	lsr	r10,0x3
800029fe:	12 0a       	add	r10,r9
80002a00:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80002a04:	2e 2a       	sub	r10,-30
80002a06:	5c 5a       	castu.b	r10
80002a08:	c0 58       	rjmp	80002a12 <rtc_irq+0x8a>
80002a0a:	f0 c8 01 51 	sub	r8,r8,337
80002a0e:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
				Current_time.Day++;
80002a12:	49 78       	lddpc	r8,80002a6c <rtc_irq+0xe4>
80002a14:	11 a9       	ld.ub	r9,r8[0x2]
80002a16:	2f f9       	sub	r9,-1
80002a18:	b0 a9       	st.b	r8[0x2],r9
				if(Current_time.Day>K)
80002a1a:	11 a8       	ld.ub	r8,r8[0x2]
80002a1c:	f0 0a 18 00 	cp.b	r10,r8
80002a20:	c1 c2       	brcc	80002a58 <rtc_irq+0xd0>
				{	
					Current_time.Day = 1;//重置到下月1号
80002a22:	49 38       	lddpc	r8,80002a6c <rtc_irq+0xe4>
80002a24:	30 19       	mov	r9,1
80002a26:	b0 a9       	st.b	r8[0x2],r9
					Current_time.Month++;
80002a28:	11 99       	ld.ub	r9,r8[0x1]
80002a2a:	2f f9       	sub	r9,-1
80002a2c:	b0 99       	st.b	r8[0x1],r9
					if(Current_time.Month>12)
80002a2e:	11 99       	ld.ub	r9,r8[0x1]
80002a30:	30 c8       	mov	r8,12
80002a32:	f0 09 18 00 	cp.b	r9,r8
80002a36:	e0 88 00 11 	brls	80002a58 <rtc_irq+0xd0>
					{
						Current_time.Month = 1;//重置到下一年的第一个月
80002a3a:	48 d8       	lddpc	r8,80002a6c <rtc_irq+0xe4>
80002a3c:	30 19       	mov	r9,1
80002a3e:	b0 99       	st.b	r8[0x1],r9
						Current_time.Year++;
80002a40:	11 89       	ld.ub	r9,r8[0x0]
80002a42:	2f f9       	sub	r9,-1
80002a44:	b0 89       	st.b	r8[0x0],r9
						if (Current_time.Year>150)Current_time.Year=0;//重置年份											
80002a46:	11 89       	ld.ub	r9,r8[0x0]
80002a48:	39 68       	mov	r8,-106
80002a4a:	f0 09 18 00 	cp.b	r9,r8
80002a4e:	e0 88 00 05 	brls	80002a58 <rtc_irq+0xd0>
80002a52:	30 09       	mov	r9,0
80002a54:	48 68       	lddpc	r8,80002a6c <rtc_irq+0xe4>
80002a56:	b0 89       	st.b	r8[0x0],r9
	}
	
	//Time_scale++;

	// clear the interrupt flag
	rtc_clear_interrupt(&AVR32_RTC);
80002a58:	fe 7c 0d 00 	mov	r12,-62208
80002a5c:	f0 1f 00 05 	mcall	80002a70 <rtc_irq+0xe8>

	// specify that an interrupt has been raised
	print_sec = 1;
80002a60:	30 19       	mov	r9,1
80002a62:	48 58       	lddpc	r8,80002a74 <rtc_irq+0xec>
80002a64:	91 09       	st.w	r8[0x0],r9
}
80002a66:	d4 02       	popm	lr
80002a68:	d6 03       	rete
80002a6a:	00 00       	add	r0,r0
80002a6c:	00 00       	add	r0,r0
80002a6e:	0d 80       	ld.ub	r0,r6[0x0]
80002a70:	80 00       	ld.sh	r0,r0[0x0]
80002a72:	55 00       	stdsp	sp[0x140],r0
80002a74:	00 00       	add	r0,r0
80002a76:	04 f0       	st.b	--r2,r0

80002a78 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002a78:	20 1c       	sub	r12,1
80002a7a:	5c 5c       	castu.b	r12
80002a7c:	31 18       	mov	r8,17
80002a7e:	f0 0c 18 00 	cp.b	r12,r8
80002a82:	e0 88 00 03 	brls	80002a88 <CalculateBurst+0x10>
80002a86:	5e fd       	retal	0
80002a88:	48 28       	lddpc	r8,80002a90 <CalculateBurst+0x18>
80002a8a:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002a8e:	5e fc       	retal	r12
80002a90:	80 00       	ld.sh	r0,r0[0x0]
80002a92:	d4 ec       	*unknown*

80002a94 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80002a94:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
80002a96:	48 98       	lddpc	r8,80002ab8 <payload_init+0x24>
80002a98:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002a9a:	48 98       	lddpc	r8,80002abc <payload_init+0x28>
80002a9c:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80002a9e:	30 09       	mov	r9,0
80002aa0:	1a d9       	st.w	--sp,r9
80002aa2:	1a d9       	st.w	--sp,r9
80002aa4:	1a d9       	st.w	--sp,r9
80002aa6:	30 28       	mov	r8,2
80002aa8:	e0 6a 04 00 	mov	r10,1024
80002aac:	48 5b       	lddpc	r11,80002ac0 <payload_init+0x2c>
80002aae:	48 6c       	lddpc	r12,80002ac4 <payload_init+0x30>
80002ab0:	f0 1f 00 06 	mcall	80002ac8 <payload_init+0x34>
80002ab4:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
80002ab6:	d8 02       	popm	pc
80002ab8:	00 00       	add	r0,r0
80002aba:	0a 5c       	eor	r12,r5
80002abc:	00 00       	add	r0,r0
80002abe:	0a 60       	and	r0,r5
80002ac0:	80 00       	ld.sh	r0,r0[0x0]
80002ac2:	d5 34       	*unknown*
80002ac4:	80 00       	ld.sh	r0,r0[0x0]
80002ac6:	2a cc       	sub	r12,-84
80002ac8:	80 00       	ld.sh	r0,r0[0x0]
80002aca:	69 50       	ld.w	r0,r4[0x54]

80002acc <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002acc:	eb cd 40 f8 	pushm	r3-r7,lr
80002ad0:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80002ad2:	48 e8       	lddpc	r8,80002b08 <payload_rx_process+0x3c>
80002ad4:	70 08       	ld.w	r8,r8[0x0]
80002ad6:	58 08       	cp.w	r8,0
80002ad8:	c0 71       	brne	80002ae6 <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002ada:	30 4b       	mov	r11,4
80002adc:	30 5c       	mov	r12,5
80002ade:	f0 1f 00 0c 	mcall	80002b0c <payload_rx_process+0x40>
80002ae2:	48 a8       	lddpc	r8,80002b08 <payload_rx_process+0x3c>
80002ae4:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002ae6:	48 96       	lddpc	r6,80002b08 <payload_rx_process+0x3c>
80002ae8:	30 05       	mov	r5,0
80002aea:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002aec:	48 93       	lddpc	r3,80002b10 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002aee:	6c 0c       	ld.w	r12,r6[0x0]
80002af0:	0a 99       	mov	r9,r5
80002af2:	08 9a       	mov	r10,r4
80002af4:	1a 9b       	mov	r11,sp
80002af6:	f0 1f 00 08 	mcall	80002b14 <payload_rx_process+0x48>
80002afa:	58 1c       	cp.w	r12,1
80002afc:	cf 91       	brne	80002aee <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002afe:	66 08       	ld.w	r8,r3[0x0]
80002b00:	40 0c       	lddsp	r12,sp[0x0]
80002b02:	5d 18       	icall	r8
80002b04:	cf 5b       	rjmp	80002aee <payload_rx_process+0x22>
80002b06:	00 00       	add	r0,r0
80002b08:	00 00       	add	r0,r0
80002b0a:	0a 8c       	andn	r12,r5
80002b0c:	80 00       	ld.sh	r0,r0[0x0]
80002b0e:	62 34       	ld.w	r4,r1[0xc]
80002b10:	00 00       	add	r0,r0
80002b12:	0a 5c       	eor	r12,r5
80002b14:	80 00       	ld.sh	r0,r0[0x0]
80002b16:	5f 28       	srhs	r8

80002b18 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002b18:	d4 01       	pushm	lr
80002b1a:	20 2d       	sub	sp,8
80002b1c:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002b1e:	30 09       	mov	r9,0
80002b20:	fa ca ff f8 	sub	r10,sp,-8
80002b24:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002b26:	1a 9b       	mov	r11,sp
80002b28:	f0 1f 00 02 	mcall	80002b30 <set_idle_store_isr+0x18>
}
80002b2c:	2f ed       	sub	sp,-8
80002b2e:	d8 02       	popm	pc
80002b30:	80 00       	ld.sh	r0,r0[0x0]
80002b32:	60 e4       	ld.w	r4,r0[0x38]

80002b34 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002b34:	d4 01       	pushm	lr
80002b36:	20 2d       	sub	sp,8
80002b38:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002b3a:	58 0c       	cp.w	r12,0
80002b3c:	c1 10       	breq	80002b5e <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002b3e:	30 08       	mov	r8,0
80002b40:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002b42:	98 88       	ld.uh	r8,r12[0x0]
80002b44:	e2 18 f0 00 	andl	r8,0xf000,COH
80002b48:	e0 48 40 00 	cp.w	r8,16384
80002b4c:	c0 91       	brne	80002b5e <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002b4e:	48 68       	lddpc	r8,80002b64 <phy_rx+0x30>
80002b50:	70 0c       	ld.w	r12,r8[0x0]
80002b52:	30 09       	mov	r9,0
80002b54:	fa ca ff fc 	sub	r10,sp,-4
80002b58:	1a 9b       	mov	r11,sp
80002b5a:	f0 1f 00 04 	mcall	80002b68 <phy_rx+0x34>
		}	

    }
		
 
}
80002b5e:	2f ed       	sub	sp,-8
80002b60:	d8 02       	popm	pc
80002b62:	00 00       	add	r0,r0
80002b64:	00 00       	add	r0,r0
80002b66:	0a b8       	st.h	r5++,r8
80002b68:	80 00       	ld.sh	r0,r0[0x0]
80002b6a:	60 e4       	ld.w	r4,r0[0x38]

80002b6c <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002b6c:	eb cd 40 80 	pushm	r7,lr
80002b70:	20 1d       	sub	sp,4
80002b72:	fa c7 ff fc 	sub	r7,sp,-4
80002b76:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002b78:	30 09       	mov	r9,0
80002b7a:	12 9a       	mov	r10,r9
80002b7c:	1a 9b       	mov	r11,sp
80002b7e:	f0 1f 00 03 	mcall	80002b88 <set_idle_store+0x1c>
}
80002b82:	2f fd       	sub	sp,-4
80002b84:	e3 cd 80 80 	ldm	sp++,r7,pc
80002b88:	80 00       	ld.sh	r0,r0[0x0]
80002b8a:	61 34       	ld.w	r4,r0[0x4c]

80002b8c <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002b8c:	d4 01       	pushm	lr
80002b8e:	20 1d       	sub	sp,4
80002b90:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002b92:	98 88       	ld.uh	r8,r12[0x0]
80002b94:	e2 18 f0 00 	andl	r8,0xf000,COH
80002b98:	e0 48 40 00 	cp.w	r8,16384
80002b9c:	c0 d1       	brne	80002bb6 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002b9e:	49 08       	lddpc	r8,80002bdc <phy_tx+0x50>
80002ba0:	70 08       	ld.w	r8,r8[0x0]
80002ba2:	58 08       	cp.w	r8,0
80002ba4:	c1 a0       	breq	80002bd8 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002ba6:	48 e8       	lddpc	r8,80002bdc <phy_tx+0x50>
80002ba8:	70 0c       	ld.w	r12,r8[0x0]
80002baa:	30 09       	mov	r9,0
80002bac:	12 9a       	mov	r10,r9
80002bae:	1a 9b       	mov	r11,sp
80002bb0:	f0 1f 00 0c 	mcall	80002be0 <phy_tx+0x54>
80002bb4:	c1 28       	rjmp	80002bd8 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002bb6:	e0 48 10 00 	cp.w	r8,4096
80002bba:	5f 0a       	sreq	r10
80002bbc:	e0 48 20 00 	cp.w	r8,8192
80002bc0:	5f 09       	sreq	r9
80002bc2:	f5 e9 10 09 	or	r9,r10,r9
80002bc6:	c0 71       	brne	80002bd4 <phy_tx+0x48>
80002bc8:	e0 48 50 00 	cp.w	r8,20480
80002bcc:	c0 40       	breq	80002bd4 <phy_tx+0x48>
80002bce:	e0 48 60 00 	cp.w	r8,24576
80002bd2:	c0 31       	brne	80002bd8 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002bd4:	48 48       	lddpc	r8,80002be4 <phy_tx+0x58>
80002bd6:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002bd8:	2f fd       	sub	sp,-4
80002bda:	d8 02       	popm	pc
80002bdc:	00 00       	add	r0,r0
80002bde:	0a c4       	st.b	r5++,r4
80002be0:	80 00       	ld.sh	r0,r0[0x0]
80002be2:	61 34       	ld.w	r4,r0[0x4c]
80002be4:	00 00       	add	r0,r0
80002be6:	0a ac       	st.w	r5++,r12

80002be8 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002be8:	d4 01       	pushm	lr
80002bea:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002bec:	30 08       	mov	r8,0
80002bee:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002bf0:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002bf2:	1a 9a       	mov	r10,sp
80002bf4:	fa cb ff fc 	sub	r11,sp,-4
80002bf8:	f0 1f 00 05 	mcall	80002c0c <get_idle_store_isr+0x24>
80002bfc:	58 1c       	cp.w	r12,1
80002bfe:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002c02:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002c06:	2f ed       	sub	sp,-8
80002c08:	d8 02       	popm	pc
80002c0a:	00 00       	add	r0,r0
80002c0c:	80 00       	ld.sh	r0,r0[0x0]
80002c0e:	5e 38       	retlo	r8

80002c10 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002c10:	eb cd 40 c0 	pushm	r6-r7,lr
80002c14:	20 1d       	sub	sp,4
80002c16:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002c18:	4b a8       	lddpc	r8,80002d00 <phy_tx_func+0xf0>
80002c1a:	70 08       	ld.w	r8,r8[0x0]
80002c1c:	58 08       	cp.w	r8,0
80002c1e:	c6 60       	breq	80002cea <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002c20:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002c22:	30 08       	mov	r8,0
80002c24:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002c26:	4b 88       	lddpc	r8,80002d04 <phy_tx_func+0xf4>
80002c28:	70 08       	ld.w	r8,r8[0x0]
80002c2a:	58 18       	cp.w	r8,1
80002c2c:	c2 60       	breq	80002c78 <phy_tx_func+0x68>
80002c2e:	c0 43       	brcs	80002c36 <phy_tx_func+0x26>
80002c30:	58 28       	cp.w	r8,2
80002c32:	c5 c1       	brne	80002cea <phy_tx_func+0xda>
80002c34:	c5 58       	rjmp	80002cde <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002c36:	4b 38       	lddpc	r8,80002d00 <phy_tx_func+0xf0>
80002c38:	70 0c       	ld.w	r12,r8[0x0]
80002c3a:	1a 9a       	mov	r10,sp
80002c3c:	4b 3b       	lddpc	r11,80002d08 <phy_tx_func+0xf8>
80002c3e:	f0 1f 00 34 	mcall	80002d0c <phy_tx_func+0xfc>
80002c42:	58 1c       	cp.w	r12,1
80002c44:	c1 41       	brne	80002c6c <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002c46:	4b 18       	lddpc	r8,80002d08 <phy_tx_func+0xf8>
80002c48:	70 08       	ld.w	r8,r8[0x0]
80002c4a:	90 08       	ld.sh	r8,r8[0x0]
80002c4c:	10 9a       	mov	r10,r8
80002c4e:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002c52:	4b 09       	lddpc	r9,80002d10 <phy_tx_func+0x100>
80002c54:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002c56:	5c 78       	castu.h	r8
80002c58:	ea 18 ab cd 	orh	r8,0xabcd
80002c5c:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002c5e:	30 19       	mov	r9,1
80002c60:	4a d8       	lddpc	r8,80002d14 <phy_tx_func+0x104>
80002c62:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002c64:	30 19       	mov	r9,1
80002c66:	4a 88       	lddpc	r8,80002d04 <phy_tx_func+0xf4>
80002c68:	91 09       	st.w	r8[0x0],r9
80002c6a:	c4 08       	rjmp	80002cea <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002c6c:	e0 68 5a 5a 	mov	r8,23130
80002c70:	ea 18 ab cd 	orh	r8,0xabcd
80002c74:	8f 18       	st.w	r7[0x4],r8
80002c76:	c3 a8       	rjmp	80002cea <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002c78:	4a 7a       	lddpc	r10,80002d14 <phy_tx_func+0x104>
80002c7a:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002c7c:	4a 39       	lddpc	r9,80002d08 <phy_tx_func+0xf8>
80002c7e:	72 09       	ld.w	r9,r9[0x0]
80002c80:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002c84:	b1 69       	lsl	r9,0x10
80002c86:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002c88:	2f f8       	sub	r8,-1
80002c8a:	5c 58       	castu.b	r8
80002c8c:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002c8e:	4a 1b       	lddpc	r11,80002d10 <phy_tx_func+0x100>
80002c90:	96 0c       	ld.sh	r12,r11[0x0]
80002c92:	20 2c       	sub	r12,2
80002c94:	5c 8c       	casts.h	r12
80002c96:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002c9a:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002c9c:	30 0b       	mov	r11,0
80002c9e:	f6 0a 19 00 	cp.h	r10,r11
80002ca2:	e0 89 00 09 	brgt	80002cb4 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002ca6:	e8 19 00 ba 	orl	r9,0xba
80002caa:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002cac:	30 09       	mov	r9,0
80002cae:	49 68       	lddpc	r8,80002d04 <phy_tx_func+0xf4>
80002cb0:	91 09       	st.w	r8[0x0],r9
80002cb2:	c1 c8       	rjmp	80002cea <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002cb4:	49 5a       	lddpc	r10,80002d08 <phy_tx_func+0xf8>
80002cb6:	74 0a       	ld.w	r10,r10[0x0]
80002cb8:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002cbc:	14 49       	or	r9,r10
80002cbe:	8f 19       	st.w	r7[0x4],r9
80002cc0:	2f f8       	sub	r8,-1
80002cc2:	49 59       	lddpc	r9,80002d14 <phy_tx_func+0x104>
80002cc4:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002cc6:	20 2c       	sub	r12,2
80002cc8:	49 28       	lddpc	r8,80002d10 <phy_tx_func+0x100>
80002cca:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002ccc:	30 08       	mov	r8,0
80002cce:	f0 0c 19 00 	cp.h	r12,r8
80002cd2:	e0 89 00 0c 	brgt	80002cea <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002cd6:	30 29       	mov	r9,2
80002cd8:	48 b8       	lddpc	r8,80002d04 <phy_tx_func+0xf4>
80002cda:	91 09       	st.w	r8[0x0],r9
80002cdc:	c0 78       	rjmp	80002cea <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002cde:	fc 18 00 ba 	movh	r8,0xba
80002ce2:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002ce4:	30 09       	mov	r9,0
80002ce6:	48 88       	lddpc	r8,80002d04 <phy_tx_func+0xf4>
80002ce8:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002cea:	e0 68 5a 5a 	mov	r8,23130
80002cee:	ea 18 ab cd 	orh	r8,0xabcd
80002cf2:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002cf4:	30 08       	mov	r8,0
80002cf6:	8f 38       	st.w	r7[0xc],r8
}
80002cf8:	2f fd       	sub	sp,-4
80002cfa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002cfe:	00 00       	add	r0,r0
80002d00:	00 00       	add	r0,r0
80002d02:	0a c4       	st.b	r5++,r4
80002d04:	00 00       	add	r0,r0
80002d06:	0a 80       	andn	r0,r5
80002d08:	00 00       	add	r0,r0
80002d0a:	0a cc       	st.b	r5++,r12
80002d0c:	80 00       	ld.sh	r0,r0[0x0]
80002d0e:	5e 38       	retlo	r8
80002d10:	00 00       	add	r0,r0
80002d12:	0a a8       	st.w	r5++,r8
80002d14:	00 00       	add	r0,r0
80002d16:	0a 64       	and	r4,r5

80002d18 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002d18:	d4 01       	pushm	lr
80002d1a:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002d1c:	30 0a       	mov	r10,0
80002d1e:	fa cb ff fc 	sub	r11,sp,-4
80002d22:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002d24:	14 99       	mov	r9,r10
80002d26:	1a 9b       	mov	r11,sp
80002d28:	f0 1f 00 05 	mcall	80002d3c <get_idle_store+0x24>
80002d2c:	58 1c       	cp.w	r12,1
80002d2e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002d32:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002d36:	2f fd       	sub	sp,-4
80002d38:	d8 02       	popm	pc
80002d3a:	00 00       	add	r0,r0
80002d3c:	80 00       	ld.sh	r0,r0[0x0]
80002d3e:	5f 28       	srhs	r8

80002d40 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002d40:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002d42:	48 5b       	lddpc	r11,80002d54 <phy_init+0x14>
80002d44:	48 5c       	lddpc	r12,80002d58 <phy_init+0x18>
80002d46:	f0 1f 00 06 	mcall	80002d5c <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002d4a:	f0 1f 00 06 	mcall	80002d60 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002d4e:	f0 1f 00 06 	mcall	80002d64 <phy_init+0x24>
	
}
80002d52:	d8 02       	popm	pc
80002d54:	80 00       	ld.sh	r0,r0[0x0]
80002d56:	2c 10       	sub	r0,-63
80002d58:	80 00       	ld.sh	r0,r0[0x0]
80002d5a:	2d c8       	sub	r8,-36
80002d5c:	80 00       	ld.sh	r0,r0[0x0]
80002d5e:	3e 10       	mov	r0,-31
80002d60:	80 00       	ld.sh	r0,r0[0x0]
80002d62:	3e 24       	mov	r4,-30
80002d64:	80 00       	ld.sh	r0,r0[0x0]
80002d66:	47 cc       	lddsp	r12,sp[0x1f0]

80002d68 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002d68:	d4 01       	pushm	lr
80002d6a:	20 2d       	sub	sp,8
80002d6c:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002d6e:	30 08       	mov	r8,0
80002d70:	50 18       	stdsp	sp[0x4],r8
	
	if(NULL == phy_payload_frame_rx)
80002d72:	48 f8       	lddpc	r8,80002dac <payload_rx+0x44>
80002d74:	70 08       	ld.w	r8,r8[0x0]
80002d76:	58 08       	cp.w	r8,0
80002d78:	c0 71       	brne	80002d86 <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80002d7a:	30 4b       	mov	r11,4
80002d7c:	30 5c       	mov	r12,5
80002d7e:	f0 1f 00 0d 	mcall	80002db0 <payload_rx+0x48>
80002d82:	48 b8       	lddpc	r8,80002dac <payload_rx+0x44>
80002d84:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
80002d86:	48 a8       	lddpc	r8,80002dac <payload_rx+0x44>
80002d88:	70 0c       	ld.w	r12,r8[0x0]
80002d8a:	30 09       	mov	r9,0
80002d8c:	fa ca ff fc 	sub	r10,sp,-4
80002d90:	1a 9b       	mov	r11,sp
80002d92:	f0 1f 00 09 	mcall	80002db4 <payload_rx+0x4c>
80002d96:	c0 91       	brne	80002da8 <payload_rx+0x40>
	{
		
		set_payload_idle_isr(payload);
80002d98:	48 88       	lddpc	r8,80002db8 <payload_rx+0x50>
80002d9a:	70 0c       	ld.w	r12,r8[0x0]
80002d9c:	40 0b       	lddsp	r11,sp[0x0]
80002d9e:	f0 1f 00 08 	mcall	80002dbc <payload_rx+0x54>
		logFromISR("mm");
80002da2:	48 8c       	lddpc	r12,80002dc0 <payload_rx+0x58>
80002da4:	f0 1f 00 08 	mcall	80002dc4 <payload_rx+0x5c>
	}
	else
	{
		//logFromISR("ss");
	}
}
80002da8:	2f ed       	sub	sp,-8
80002daa:	d8 02       	popm	pc
80002dac:	00 00       	add	r0,r0
80002dae:	0a 8c       	andn	r12,r5
80002db0:	80 00       	ld.sh	r0,r0[0x0]
80002db2:	62 34       	ld.w	r4,r1[0xc]
80002db4:	80 00       	ld.sh	r0,r0[0x0]
80002db6:	60 e4       	ld.w	r4,r0[0x38]
80002db8:	00 00       	add	r0,r0
80002dba:	0a 70       	tst	r0,r5
80002dbc:	80 00       	ld.sh	r0,r0[0x0]
80002dbe:	2b 18       	sub	r8,-79
80002dc0:	80 00       	ld.sh	r0,r0[0x0]
80002dc2:	d5 40       	acall	0x54
80002dc4:	80 00       	ld.sh	r0,r0[0x0]
80002dc6:	6e a0       	ld.w	r0,r7[0x28]

80002dc8 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002dc8:	eb cd 40 e0 	pushm	r5-r7,lr
80002dcc:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002dce:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002dd2:	70 08       	ld.w	r8,r8[0x0]
80002dd4:	58 08       	cp.w	r8,0
80002dd6:	e0 80 01 08 	breq	80002fe6 <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002dda:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002ddc:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002de0:	70 09       	ld.w	r9,r8[0x0]
80002de2:	2f f9       	sub	r9,-1
80002de4:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002de6:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002dea:	70 08       	ld.w	r8,r8[0x0]
80002dec:	58 18       	cp.w	r8,1
80002dee:	e0 80 00 85 	breq	80002ef8 <phy_rx_func+0x130>
80002df2:	c0 73       	brcs	80002e00 <phy_rx_func+0x38>
80002df4:	58 28       	cp.w	r8,2
80002df6:	c5 c0       	breq	80002eae <phy_rx_func+0xe6>
80002df8:	58 38       	cp.w	r8,3
80002dfa:	e0 81 00 f6 	brne	80002fe6 <phy_rx_func+0x21e>
80002dfe:	cd 58       	rjmp	80002fa8 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002e00:	e0 6a 5a 5a 	mov	r10,23130
80002e04:	ea 1a ab cd 	orh	r10,0xabcd
80002e08:	14 36       	cp.w	r6,r10
80002e0a:	e0 80 00 ee 	breq	80002fe6 <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002e0e:	ec 08 16 10 	lsr	r8,r6,0x10
80002e12:	e0 48 ab cd 	cp.w	r8,43981
80002e16:	e0 81 00 e8 	brne	80002fe6 <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002e1a:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002e1e:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002e22:	20 28       	sub	r8,2
80002e24:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002e28:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002e2a:	30 09       	mov	r9,0
80002e2c:	f2 08 19 00 	cp.h	r8,r9
80002e30:	e0 8a 00 db 	brle	80002fe6 <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002e34:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002e38:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002e3a:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002e3e:	70 0c       	ld.w	r12,r8[0x0]
80002e40:	f0 1f 03 88 	mcall	80003c60 <phy_rx_func+0xe98>
80002e44:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002e48:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002e4a:	58 0c       	cp.w	r12,0
80002e4c:	e0 80 00 cd 	breq	80002fe6 <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002e50:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002e54:	90 09       	ld.sh	r9,r8[0x0]
80002e56:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002e5a:	2f f9       	sub	r9,-1
80002e5c:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002e5e:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002e62:	74 0a       	ld.w	r10,r10[0x0]
80002e64:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002e68:	76 0b       	ld.w	r11,r11[0x0]
80002e6a:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002e6e:	2f f9       	sub	r9,-1
80002e70:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002e72:	e2 16 0f 00 	andl	r6,0xf00,COH
80002e76:	e0 46 01 00 	cp.w	r6,256
80002e7a:	c0 c0       	breq	80002e92 <phy_rx_func+0xca>
80002e7c:	e0 8b 00 05 	brhi	80002e86 <phy_rx_func+0xbe>
80002e80:	58 06       	cp.w	r6,0
80002e82:	c0 80       	breq	80002e92 <phy_rx_func+0xca>
80002e84:	c0 c8       	rjmp	80002e9c <phy_rx_func+0xd4>
80002e86:	e0 46 02 00 	cp.w	r6,512
80002e8a:	c0 40       	breq	80002e92 <phy_rx_func+0xca>
80002e8c:	e0 46 03 00 	cp.w	r6,768
80002e90:	c0 61       	brne	80002e9c <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002e92:	30 29       	mov	r9,2
80002e94:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002e98:	91 09       	st.w	r8[0x0],r9
80002e9a:	ca 68       	rjmp	80002fe6 <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002e9c:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002ea0:	70 0c       	ld.w	r12,r8[0x0]
80002ea2:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002ea6:	70 0b       	ld.w	r11,r8[0x0]
80002ea8:	f0 1f 03 70 	mcall	80003c68 <phy_rx_func+0xea0>
80002eac:	c9 d8       	rjmp	80002fe6 <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002eae:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002eb2:	b1 86       	lsr	r6,0x10
80002eb4:	14 06       	add	r6,r10
80002eb6:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002eba:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002ebc:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002ec0:	90 09       	ld.sh	r9,r8[0x0]
80002ec2:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002ec6:	76 0b       	ld.w	r11,r11[0x0]
80002ec8:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002ecc:	2f f9       	sub	r9,-1
80002ece:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002ed0:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002ed4:	92 08       	ld.sh	r8,r9[0x0]
80002ed6:	20 28       	sub	r8,2
80002ed8:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002eda:	30 09       	mov	r9,0
80002edc:	f2 08 19 00 	cp.h	r8,r9
80002ee0:	e0 8a 00 07 	brle	80002eee <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002ee4:	30 19       	mov	r9,1
80002ee6:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002eea:	91 09       	st.w	r8[0x0],r9
80002eec:	c7 d8       	rjmp	80002fe6 <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002eee:	30 39       	mov	r9,3
80002ef0:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002ef4:	91 09       	st.w	r8[0x0],r9
80002ef6:	c7 88       	rjmp	80002fe6 <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002ef8:	ec 0a 14 10 	asr	r10,r6,0x10
80002efc:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002f00:	90 09       	ld.sh	r9,r8[0x0]
80002f02:	14 09       	add	r9,r10
80002f04:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002f06:	fe f9 0d 52 	ld.w	r9,pc[3410]
80002f0a:	92 08       	ld.sh	r8,r9[0x0]
80002f0c:	fe fb 0d 58 	ld.w	r11,pc[3416]
80002f10:	76 0b       	ld.w	r11,r11[0x0]
80002f12:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002f16:	2f f8       	sub	r8,-1
80002f18:	5c 88       	casts.h	r8
80002f1a:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002f1c:	fe fa 0d 38 	ld.w	r10,pc[3384]
80002f20:	94 09       	ld.sh	r9,r10[0x0]
80002f22:	20 29       	sub	r9,2
80002f24:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80002f26:	30 0a       	mov	r10,0
80002f28:	f4 09 19 00 	cp.h	r9,r10
80002f2c:	e0 89 00 20 	brgt	80002f6c <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80002f30:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80002f34:	e0 46 00 ba 	cp.w	r6,186
80002f38:	c0 d1       	brne	80002f52 <phy_rx_func+0x18a>
80002f3a:	fe f8 0d 32 	ld.w	r8,pc[3378]
80002f3e:	90 09       	ld.sh	r9,r8[0x0]
80002f40:	f4 09 19 00 	cp.h	r9,r10
80002f44:	c0 71       	brne	80002f52 <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80002f46:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80002f4a:	70 0c       	ld.w	r12,r8[0x0]
80002f4c:	f0 1f 03 49 	mcall	80003c70 <phy_rx_func+0xea8>
80002f50:	c0 98       	rjmp	80002f62 <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80002f52:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80002f56:	70 0c       	ld.w	r12,r8[0x0]
80002f58:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80002f5c:	70 0b       	ld.w	r11,r8[0x0]
80002f5e:	f0 1f 03 43 	mcall	80003c68 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80002f62:	30 09       	mov	r9,0
80002f64:	fe f8 0c ec 	ld.w	r8,pc[3308]
80002f68:	91 09       	st.w	r8[0x0],r9
80002f6a:	c3 e8       	rjmp	80002fe6 <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80002f6c:	5c 86       	casts.h	r6
80002f6e:	fe f9 0c fe 	ld.w	r9,pc[3326]
80002f72:	92 0a       	ld.sh	r10,r9[0x0]
80002f74:	0c 0a       	add	r10,r6
80002f76:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002f78:	fe f9 0c ec 	ld.w	r9,pc[3308]
80002f7c:	72 09       	ld.w	r9,r9[0x0]
80002f7e:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80002f82:	2f f8       	sub	r8,-1
80002f84:	fe f9 0c d4 	ld.w	r9,pc[3284]
80002f88:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80002f8a:	fe f9 0c ca 	ld.w	r9,pc[3274]
80002f8e:	92 08       	ld.sh	r8,r9[0x0]
80002f90:	20 28       	sub	r8,2
80002f92:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80002f94:	30 09       	mov	r9,0
80002f96:	f2 08 19 00 	cp.h	r8,r9
80002f9a:	e0 89 00 26 	brgt	80002fe6 <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80002f9e:	30 39       	mov	r9,3
80002fa0:	fe f8 0c b0 	ld.w	r8,pc[3248]
80002fa4:	91 09       	st.w	r8[0x0],r9
80002fa6:	c2 08       	rjmp	80002fe6 <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80002fa8:	e6 16 00 ff 	andh	r6,0xff,COH
80002fac:	fc 19 00 ba 	movh	r9,0xba
80002fb0:	12 36       	cp.w	r6,r9
80002fb2:	c0 e1       	brne	80002fce <phy_rx_func+0x206>
80002fb4:	fe f8 0c b8 	ld.w	r8,pc[3256]
80002fb8:	90 09       	ld.sh	r9,r8[0x0]
80002fba:	30 08       	mov	r8,0
80002fbc:	f0 09 19 00 	cp.h	r9,r8
80002fc0:	c0 71       	brne	80002fce <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80002fc2:	fe f8 0c a2 	ld.w	r8,pc[3234]
80002fc6:	70 0c       	ld.w	r12,r8[0x0]
80002fc8:	f0 1f 03 2a 	mcall	80003c70 <phy_rx_func+0xea8>
80002fcc:	c0 98       	rjmp	80002fde <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80002fce:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002fd2:	70 0c       	ld.w	r12,r8[0x0]
80002fd4:	fe f8 0c 90 	ld.w	r8,pc[3216]
80002fd8:	70 0b       	ld.w	r11,r8[0x0]
80002fda:	f0 1f 03 24 	mcall	80003c68 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80002fde:	30 09       	mov	r9,0
80002fe0:	fe f8 0c 70 	ld.w	r8,pc[3184]
80002fe4:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80002fe6:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002fea:	11 89       	ld.ub	r9,r8[0x0]
80002fec:	30 08       	mov	r8,0
80002fee:	f0 09 18 00 	cp.b	r9,r8
80002ff2:	c1 31       	brne	80003018 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80002ff4:	fe f6 0c 84 	ld.w	r6,pc[3204]
80002ff8:	6c 0c       	ld.w	r12,r6[0x0]
80002ffa:	f0 1f 03 1a 	mcall	80003c60 <phy_rx_func+0xe98>
80002ffe:	fe f8 0c 7e 	ld.w	r8,pc[3198]
80003002:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80003004:	6c 0c       	ld.w	r12,r6[0x0]
80003006:	f0 1f 03 17 	mcall	80003c60 <phy_rx_func+0xe98>
8000300a:	fe f8 0c 76 	ld.w	r8,pc[3190]
8000300e:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80003010:	30 19       	mov	r9,1
80003012:	fe f8 0c 62 	ld.w	r8,pc[3170]
80003016:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80003018:	fe f8 0c 6c 	ld.w	r8,pc[3180]
8000301c:	70 08       	ld.w	r8,r8[0x0]
8000301e:	58 28       	cp.w	r8,2
80003020:	e0 80 01 98 	breq	80003350 <phy_rx_func+0x588>
80003024:	e0 8b 00 06 	brhi	80003030 <phy_rx_func+0x268>
80003028:	58 08       	cp.w	r8,0
8000302a:	c0 b0       	breq	80003040 <phy_rx_func+0x278>
8000302c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003030:	58 38       	cp.w	r8,3
80003032:	e0 80 05 c5 	breq	80003bbc <phy_rx_func+0xdf4>
80003036:	58 48       	cp.w	r8,4
80003038:	e0 81 06 05 	brne	80003c42 <phy_rx_func+0xe7a>
8000303c:	e0 8f 02 4b 	bral	800034d2 <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80003040:	6e 28       	ld.w	r8,r7[0x8]
80003042:	e0 6a 5a 5a 	mov	r10,23130
80003046:	ea 1a ab cd 	orh	r10,0xabcd
8000304a:	14 38       	cp.w	r8,r10
8000304c:	c0 71       	brne	8000305a <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
8000304e:	30 09       	mov	r9,0
80003050:	fe f8 0c 38 	ld.w	r8,pc[3128]
80003054:	91 09       	st.w	r8[0x0],r9
80003056:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
8000305a:	10 99       	mov	r9,r8
8000305c:	e0 19 00 00 	andl	r9,0x0
80003060:	fc 1a ab cd 	movh	r10,0xabcd
80003064:	14 39       	cp.w	r9,r10
80003066:	e0 81 05 ee 	brne	80003c42 <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
8000306a:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
8000306e:	fe f9 0c 1e 	ld.w	r9,pc[3102]
80003072:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80003074:	6e 29       	ld.w	r9,r7[0x8]
80003076:	e2 19 f0 00 	andl	r9,0xf000,COH
8000307a:	e0 49 c0 00 	cp.w	r9,49152
8000307e:	e0 81 00 ce 	brne	8000321a <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
80003082:	30 1a       	mov	r10,1
80003084:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80003088:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
8000308a:	fe f9 0b f6 	ld.w	r9,pc[3062]
8000308e:	72 09       	ld.w	r9,r9[0x0]
80003090:	58 09       	cp.w	r9,0
80003092:	c0 71       	brne	800030a0 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003094:	fe fc 0c 00 	ld.w	r12,pc[3072]
80003098:	f0 1f 03 00 	mcall	80003c98 <phy_rx_func+0xed0>
8000309c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
800030a0:	ef 3a 00 0d 	ld.ub	r10,r7[13]
800030a4:	fe f9 0b f8 	ld.w	r9,pc[3064]
800030a8:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
800030aa:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800030ae:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
800030b2:	fe fa 0b ee 	ld.w	r10,pc[3054]
800030b6:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
800030b8:	13 89       	ld.ub	r9,r9[0x0]
800030ba:	37 fa       	mov	r10,127
800030bc:	f4 09 18 00 	cp.b	r9,r10
800030c0:	c6 d0       	breq	8000319a <phy_rx_func+0x3d2>
800030c2:	e0 8b 00 0c 	brhi	800030da <phy_rx_func+0x312>
800030c6:	31 2a       	mov	r10,18
800030c8:	f4 09 18 00 	cp.b	r9,r10
800030cc:	c4 20       	breq	80003150 <phy_rx_func+0x388>
800030ce:	31 3a       	mov	r10,19
800030d0:	f4 09 18 00 	cp.b	r9,r10
800030d4:	e0 81 00 83 	brne	800031da <phy_rx_func+0x412>
800030d8:	c5 b8       	rjmp	8000318e <phy_rx_func+0x3c6>
800030da:	2f 09       	sub	r9,-16
800030dc:	30 1a       	mov	r10,1
800030de:	f4 09 18 00 	cp.b	r9,r10
800030e2:	e0 8b 00 7c 	brhi	800031da <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
800030e6:	ef 38 00 0e 	ld.ub	r8,r7[14]
800030ea:	e2 18 00 f0 	andl	r8,0xf0,COH
800030ee:	59 08       	cp.w	r8,16
800030f0:	c0 71       	brne	800030fe <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
800030f2:	30 19       	mov	r9,1
800030f4:	fe f8 0b 94 	ld.w	r8,pc[2964]
800030f8:	91 09       	st.w	r8[0x0],r9
800030fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
800030fe:	e0 48 00 20 	cp.w	r8,32
80003102:	c2 11       	brne	80003144 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80003104:	30 a9       	mov	r9,10
80003106:	fe f8 0b 82 	ld.w	r8,pc[2946]
8000310a:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
8000310c:	fe f6 0b 98 	ld.w	r6,pc[2968]
80003110:	6c 08       	ld.w	r8,r6[0x0]
80003112:	f0 0a 11 ff 	rsub	r10,r8,-1
80003116:	fe f7 0b 6a 	ld.w	r7,pc[2922]
8000311a:	2f f8       	sub	r8,-1
8000311c:	6e 0c       	ld.w	r12,r7[0x0]
8000311e:	f4 ca fe 00 	sub	r10,r10,-512
80003122:	30 0b       	mov	r11,0
80003124:	10 0c       	add	r12,r8
80003126:	f0 1f 02 e1 	mcall	80003ca8 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
8000312a:	30 08       	mov	r8,0
8000312c:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
8000312e:	6e 0c       	ld.w	r12,r7[0x0]
80003130:	f0 1f 02 df 	mcall	80003cac <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003134:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003138:	70 0c       	ld.w	r12,r8[0x0]
8000313a:	f0 1f 02 ca 	mcall	80003c60 <phy_rx_func+0xe98>
8000313e:	8f 0c       	st.w	r7[0x0],r12
80003140:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003144:	30 09       	mov	r9,0
80003146:	fe f8 0b 42 	ld.w	r8,pc[2882]
8000314a:	91 09       	st.w	r8[0x0],r9
8000314c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003150:	20 48       	sub	r8,4
80003152:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80003156:	93 08       	st.w	r9[0x0],r8
80003158:	58 08       	cp.w	r8,0
8000315a:	e0 80 05 74 	breq	80003c42 <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
8000315e:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80003162:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003166:	fe f8 0b 4a 	ld.w	r8,pc[2890]
8000316a:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
8000316c:	8e 69       	ld.sh	r9,r7[0xc]
8000316e:	fe f8 0b 46 	ld.w	r8,pc[2886]
80003172:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80003174:	8e 79       	ld.sh	r9,r7[0xe]
80003176:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003178:	f0 1f 02 d0 	mcall	80003cb8 <phy_rx_func+0xef0>
8000317c:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80003180:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003182:	30 49       	mov	r9,4
80003184:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003188:	91 09       	st.w	r8[0x0],r9
8000318a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
8000318e:	30 09       	mov	r9,0
80003190:	fe f8 0a f8 	ld.w	r8,pc[2808]
80003194:	91 09       	st.w	r8[0x0],r9
80003196:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
8000319a:	20 48       	sub	r8,4
8000319c:	fe f9 0a f0 	ld.w	r9,pc[2800]
800031a0:	93 08       	st.w	r9[0x0],r8
800031a2:	58 08       	cp.w	r8,0
800031a4:	e0 80 05 4f 	breq	80003c42 <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
800031a8:	fe f8 0b 14 	ld.w	r8,pc[2836]
800031ac:	70 09       	ld.w	r9,r8[0x0]
800031ae:	8e 7b       	ld.sh	r11,r7[0xe]
800031b0:	fe fa 0b 10 	ld.w	r10,pc[2832]
800031b4:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
800031b8:	2f f9       	sub	r9,-1
800031ba:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
800031bc:	fe f8 0a e4 	ld.w	r8,pc[2788]
800031c0:	70 09       	ld.w	r9,r8[0x0]
800031c2:	20 29       	sub	r9,2
800031c4:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
800031c6:	30 29       	mov	r9,2
800031c8:	fe f8 0a c0 	ld.w	r8,pc[2752]
800031cc:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
800031ce:	30 39       	mov	r9,3
800031d0:	fe f8 0a b4 	ld.w	r8,pc[2740]
800031d4:	91 09       	st.w	r8[0x0],r9
800031d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
800031da:	30 3a       	mov	r10,3
800031dc:	fe f9 0a ac 	ld.w	r9,pc[2732]
800031e0:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
800031e2:	6e 2a       	ld.w	r10,r7[0x8]
800031e4:	fe f9 0a e0 	ld.w	r9,pc[2784]
800031e8:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
800031ea:	6e 3a       	ld.w	r10,r7[0xc]
800031ec:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
800031ee:	59 48       	cp.w	r8,20
800031f0:	c0 61       	brne	800031fc <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
800031f2:	31 89       	mov	r9,24
800031f4:	fe f8 0a 98 	ld.w	r8,pc[2712]
800031f8:	91 09       	st.w	r8[0x0],r9
800031fa:	c0 a8       	rjmp	8000320e <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
800031fc:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003200:	70 08       	ld.w	r8,r8[0x0]
80003202:	59 08       	cp.w	r8,16
80003204:	c0 51       	brne	8000320e <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003206:	31 09       	mov	r9,16
80003208:	fe f8 0a 84 	ld.w	r8,pc[2692]
8000320c:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000320e:	30 49       	mov	r9,4
80003210:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003214:	91 09       	st.w	r8[0x0],r9
80003216:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
8000321a:	e0 49 10 00 	cp.w	r9,4096
8000321e:	5f 1a       	srne	r10
80003220:	e0 49 20 00 	cp.w	r9,8192
80003224:	5f 19       	srne	r9
80003226:	f5 e9 00 09 	and	r9,r10,r9
8000322a:	e0 81 05 0c 	brne	80003c42 <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
8000322e:	fe fa 0a 9a 	ld.w	r10,pc[2714]
80003232:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003234:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003238:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
8000323a:	fe fa 0a 62 	ld.w	r10,pc[2658]
8000323e:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
80003240:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80003244:	72 09       	ld.w	r9,r9[0x0]
80003246:	58 09       	cp.w	r9,0
80003248:	c0 71       	brne	80003256 <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
8000324a:	fe fc 0a 4a 	ld.w	r12,pc[2634]
8000324e:	f0 1f 02 93 	mcall	80003c98 <phy_rx_func+0xed0>
80003252:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003256:	6e 2a       	ld.w	r10,r7[0x8]
80003258:	e2 1a 0f 00 	andl	r10,0xf00,COH
8000325c:	58 1a       	cp.w	r10,1
8000325e:	e0 8b 00 4d 	brhi	800032f8 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
80003262:	20 48       	sub	r8,4
80003264:	fe f9 0a 28 	ld.w	r9,pc[2600]
80003268:	93 08       	st.w	r9[0x0],r8
8000326a:	58 08       	cp.w	r8,0
8000326c:	e0 80 04 eb 	breq	80003c42 <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
80003270:	8e 68       	ld.sh	r8,r7[0xc]
80003272:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80003276:	fe f9 0a 5a 	ld.w	r9,pc[2650]
8000327a:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
8000327c:	30 09       	mov	r9,0
8000327e:	f2 08 19 00 	cp.h	r8,r9
80003282:	c0 70       	breq	80003290 <phy_rx_func+0x4c8>
80003284:	30 19       	mov	r9,1
80003286:	f2 08 19 00 	cp.h	r8,r9
8000328a:	e0 81 04 dc 	brne	80003c42 <phy_rx_func+0xe7a>
8000328e:	c2 68       	rjmp	800032da <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003290:	fe f8 0a 44 	ld.w	r8,pc[2628]
80003294:	70 0a       	ld.w	r10,r8[0x0]
80003296:	fe f9 09 e6 	ld.w	r9,pc[2534]
8000329a:	72 09       	ld.w	r9,r9[0x0]
8000329c:	8e 7b       	ld.sh	r11,r7[0xe]
8000329e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800032a2:	70 09       	ld.w	r9,r8[0x0]
800032a4:	2f f9       	sub	r9,-1
800032a6:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800032a8:	e0 49 00 ff 	cp.w	r9,255
800032ac:	e0 88 00 11 	brls	800032ce <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
800032b0:	30 09       	mov	r9,0
800032b2:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
800032b4:	fe f7 09 c8 	ld.w	r7,pc[2504]
800032b8:	6e 0c       	ld.w	r12,r7[0x0]
800032ba:	f0 1f 02 7d 	mcall	80003cac <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
800032be:	fe f8 09 ba 	ld.w	r8,pc[2490]
800032c2:	70 0c       	ld.w	r12,r8[0x0]
800032c4:	f0 1f 02 67 	mcall	80003c60 <phy_rx_func+0xe98>
800032c8:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
800032ca:	e0 80 04 bc 	breq	80003c42 <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
800032ce:	30 29       	mov	r9,2
800032d0:	fe f8 09 b4 	ld.w	r8,pc[2484]
800032d4:	91 09       	st.w	r8[0x0],r9
800032d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800032da:	8e 79       	ld.sh	r9,r7[0xe]
800032dc:	30 38       	mov	r8,3
800032de:	f0 09 19 00 	cp.h	r9,r8
800032e2:	c0 51       	brne	800032ec <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
800032e4:	30 19       	mov	r9,1
800032e6:	fe f8 09 f2 	ld.w	r8,pc[2546]
800032ea:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
800032ec:	30 29       	mov	r9,2
800032ee:	fe f8 09 96 	ld.w	r8,pc[2454]
800032f2:	91 09       	st.w	r8[0x0],r9
800032f4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
800032f8:	58 18       	cp.w	r8,1
800032fa:	e0 88 04 a4 	brls	80003c42 <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
800032fe:	fe f8 09 d6 	ld.w	r8,pc[2518]
80003302:	70 0a       	ld.w	r10,r8[0x0]
80003304:	6e 3b       	ld.w	r11,r7[0xc]
80003306:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000330a:	70 09       	ld.w	r9,r8[0x0]
8000330c:	2f f9       	sub	r9,-1
8000330e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003310:	e0 49 00 ff 	cp.w	r9,255
80003314:	e0 88 00 11 	brls	80003336 <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003318:	30 09       	mov	r9,0
8000331a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000331c:	fe f7 09 60 	ld.w	r7,pc[2400]
80003320:	6e 0c       	ld.w	r12,r7[0x0]
80003322:	f0 1f 02 63 	mcall	80003cac <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003326:	fe f8 09 52 	ld.w	r8,pc[2386]
8000332a:	70 0c       	ld.w	r12,r8[0x0]
8000332c:	f0 1f 02 4d 	mcall	80003c60 <phy_rx_func+0xe98>
80003330:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003332:	e0 80 04 88 	breq	80003c42 <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003336:	fe f9 09 56 	ld.w	r9,pc[2390]
8000333a:	72 08       	ld.w	r8,r9[0x0]
8000333c:	20 28       	sub	r8,2
8000333e:	93 08       	st.w	r9[0x0],r8
80003340:	e0 80 04 81 	breq	80003c42 <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80003344:	30 29       	mov	r9,2
80003346:	fe f8 09 3e 	ld.w	r8,pc[2366]
8000334a:	91 09       	st.w	r8[0x0],r9
8000334c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003350:	fe f8 09 84 	ld.w	r8,pc[2436]
80003354:	70 0a       	ld.w	r10,r8[0x0]
80003356:	fe f9 09 26 	ld.w	r9,pc[2342]
8000335a:	72 09       	ld.w	r9,r9[0x0]
8000335c:	8e 4b       	ld.sh	r11,r7[0x8]
8000335e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
80003362:	70 09       	ld.w	r9,r8[0x0]
80003364:	2f f9       	sub	r9,-1
80003366:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003368:	e0 49 00 ff 	cp.w	r9,255
8000336c:	e0 88 00 16 	brls	80003398 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
80003370:	30 09       	mov	r9,0
80003372:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003374:	fe f6 09 08 	ld.w	r6,pc[2312]
80003378:	6c 0c       	ld.w	r12,r6[0x0]
8000337a:	f0 1f 02 4d 	mcall	80003cac <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000337e:	fe f8 08 fa 	ld.w	r8,pc[2298]
80003382:	70 0c       	ld.w	r12,r8[0x0]
80003384:	f0 1f 02 37 	mcall	80003c60 <phy_rx_func+0xe98>
80003388:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000338a:	c0 71       	brne	80003398 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
8000338c:	30 09       	mov	r9,0
8000338e:	fe f8 08 f6 	ld.w	r8,pc[2294]
80003392:	91 09       	st.w	r8[0x0],r9
80003394:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
80003398:	fe f9 08 f4 	ld.w	r9,pc[2292]
8000339c:	72 08       	ld.w	r8,r9[0x0]
8000339e:	20 28       	sub	r8,2
800033a0:	93 08       	st.w	r9[0x0],r8
800033a2:	c0 71       	brne	800033b0 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
800033a4:	30 09       	mov	r9,0
800033a6:	fe f8 08 de 	ld.w	r8,pc[2270]
800033aa:	91 09       	st.w	r8[0x0],r9
800033ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
800033b0:	fe f8 09 24 	ld.w	r8,pc[2340]
800033b4:	70 0a       	ld.w	r10,r8[0x0]
800033b6:	fe f9 08 c6 	ld.w	r9,pc[2246]
800033ba:	72 09       	ld.w	r9,r9[0x0]
800033bc:	8e 5b       	ld.sh	r11,r7[0xa]
800033be:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800033c2:	70 09       	ld.w	r9,r8[0x0]
800033c4:	2f f9       	sub	r9,-1
800033c6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800033c8:	e0 49 00 ff 	cp.w	r9,255
800033cc:	e0 88 00 16 	brls	800033f8 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
800033d0:	30 09       	mov	r9,0
800033d2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800033d4:	fe f6 08 a8 	ld.w	r6,pc[2216]
800033d8:	6c 0c       	ld.w	r12,r6[0x0]
800033da:	f0 1f 02 35 	mcall	80003cac <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800033de:	fe f8 08 9a 	ld.w	r8,pc[2202]
800033e2:	70 0c       	ld.w	r12,r8[0x0]
800033e4:	f0 1f 02 1f 	mcall	80003c60 <phy_rx_func+0xe98>
800033e8:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800033ea:	c0 71       	brne	800033f8 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
800033ec:	30 09       	mov	r9,0
800033ee:	fe f8 08 96 	ld.w	r8,pc[2198]
800033f2:	91 09       	st.w	r8[0x0],r9
800033f4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800033f8:	fe f9 08 94 	ld.w	r9,pc[2196]
800033fc:	72 08       	ld.w	r8,r9[0x0]
800033fe:	20 28       	sub	r8,2
80003400:	93 08       	st.w	r9[0x0],r8
80003402:	c0 71       	brne	80003410 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003404:	30 09       	mov	r9,0
80003406:	fe f8 08 7e 	ld.w	r8,pc[2174]
8000340a:	91 09       	st.w	r8[0x0],r9
8000340c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003410:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003414:	70 0a       	ld.w	r10,r8[0x0]
80003416:	fe f9 08 66 	ld.w	r9,pc[2150]
8000341a:	72 09       	ld.w	r9,r9[0x0]
8000341c:	8e 6b       	ld.sh	r11,r7[0xc]
8000341e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003422:	70 09       	ld.w	r9,r8[0x0]
80003424:	2f f9       	sub	r9,-1
80003426:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003428:	e0 49 00 ff 	cp.w	r9,255
8000342c:	e0 88 00 16 	brls	80003458 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003430:	30 09       	mov	r9,0
80003432:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003434:	fe f6 08 48 	ld.w	r6,pc[2120]
80003438:	6c 0c       	ld.w	r12,r6[0x0]
8000343a:	f0 1f 02 1d 	mcall	80003cac <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000343e:	fe f8 08 3a 	ld.w	r8,pc[2106]
80003442:	70 0c       	ld.w	r12,r8[0x0]
80003444:	f0 1f 02 07 	mcall	80003c60 <phy_rx_func+0xe98>
80003448:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000344a:	c0 71       	brne	80003458 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
8000344c:	30 09       	mov	r9,0
8000344e:	fe f8 08 36 	ld.w	r8,pc[2102]
80003452:	91 09       	st.w	r8[0x0],r9
80003454:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003458:	fe f9 08 34 	ld.w	r9,pc[2100]
8000345c:	72 08       	ld.w	r8,r9[0x0]
8000345e:	20 28       	sub	r8,2
80003460:	93 08       	st.w	r9[0x0],r8
80003462:	c0 71       	brne	80003470 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
80003464:	30 09       	mov	r9,0
80003466:	fe f8 08 1e 	ld.w	r8,pc[2078]
8000346a:	91 09       	st.w	r8[0x0],r9
8000346c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003470:	fe f8 08 64 	ld.w	r8,pc[2148]
80003474:	70 0a       	ld.w	r10,r8[0x0]
80003476:	fe f9 08 06 	ld.w	r9,pc[2054]
8000347a:	72 09       	ld.w	r9,r9[0x0]
8000347c:	8e 7b       	ld.sh	r11,r7[0xe]
8000347e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003482:	70 09       	ld.w	r9,r8[0x0]
80003484:	2f f9       	sub	r9,-1
80003486:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003488:	e0 49 00 ff 	cp.w	r9,255
8000348c:	e0 88 00 16 	brls	800034b8 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
80003490:	30 09       	mov	r9,0
80003492:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003494:	fe f7 07 e8 	ld.w	r7,pc[2024]
80003498:	6e 0c       	ld.w	r12,r7[0x0]
8000349a:	f0 1f 02 05 	mcall	80003cac <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000349e:	fe f8 07 da 	ld.w	r8,pc[2010]
800034a2:	70 0c       	ld.w	r12,r8[0x0]
800034a4:	f0 1f 01 ef 	mcall	80003c60 <phy_rx_func+0xe98>
800034a8:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800034aa:	c0 71       	brne	800034b8 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
800034ac:	30 09       	mov	r9,0
800034ae:	fe f8 07 d6 	ld.w	r8,pc[2006]
800034b2:	91 09       	st.w	r8[0x0],r9
800034b4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800034b8:	fe f9 07 d4 	ld.w	r9,pc[2004]
800034bc:	72 08       	ld.w	r8,r9[0x0]
800034be:	20 28       	sub	r8,2
800034c0:	93 08       	st.w	r9[0x0],r8
800034c2:	e0 81 03 c0 	brne	80003c42 <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
800034c6:	30 09       	mov	r9,0
800034c8:	fe f8 07 bc 	ld.w	r8,pc[1980]
800034cc:	91 09       	st.w	r8[0x0],r9
800034ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
800034d2:	fe f8 07 ca 	ld.w	r8,pc[1994]
800034d6:	11 89       	ld.ub	r9,r8[0x0]
800034d8:	31 28       	mov	r8,18
800034da:	f0 09 18 00 	cp.b	r9,r8
800034de:	e0 81 01 4c 	brne	80003776 <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
800034e2:	ef 39 00 09 	ld.ub	r9,r7[9]
800034e6:	fe f8 07 b6 	ld.w	r8,pc[1974]
800034ea:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
800034ec:	11 89       	ld.ub	r9,r8[0x0]
800034ee:	3f 28       	mov	r8,-14
800034f0:	f0 09 18 00 	cp.b	r9,r8
800034f4:	e0 81 01 3b 	brne	8000376a <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
800034f8:	30 19       	mov	r9,1
800034fa:	fe f8 07 ce 	ld.w	r8,pc[1998]
800034fe:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003500:	6e 29       	ld.w	r9,r7[0x8]
80003502:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003506:	fe f8 07 86 	ld.w	r8,pc[1926]
8000350a:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
8000350c:	8e 59       	ld.sh	r9,r7[0xa]
8000350e:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003512:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003514:	8e 69       	ld.sh	r9,r7[0xc]
80003516:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003518:	8e 79       	ld.sh	r9,r7[0xe]
8000351a:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
8000351c:	fe f8 07 88 	ld.w	r8,pc[1928]
80003520:	fe f9 07 60 	ld.w	r9,pc[1888]
80003524:	72 0a       	ld.w	r10,r9[0x0]
80003526:	70 09       	ld.w	r9,r8[0x0]
80003528:	ef 3b 00 0a 	ld.ub	r11,r7[10]
8000352c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003530:	70 09       	ld.w	r9,r8[0x0]
80003532:	2f f9       	sub	r9,-1
80003534:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003536:	e0 49 01 ff 	cp.w	r9,511
8000353a:	e0 88 00 16 	brls	80003566 <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
8000353e:	30 09       	mov	r9,0
80003540:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003542:	fe f6 07 3e 	ld.w	r6,pc[1854]
80003546:	6c 0c       	ld.w	r12,r6[0x0]
80003548:	f0 1f 01 d9 	mcall	80003cac <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000354c:	fe f8 07 2c 	ld.w	r8,pc[1836]
80003550:	70 0c       	ld.w	r12,r8[0x0]
80003552:	f0 1f 01 c4 	mcall	80003c60 <phy_rx_func+0xe98>
80003556:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003558:	c0 71       	brne	80003566 <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
8000355a:	30 09       	mov	r9,0
8000355c:	fe f8 07 28 	ld.w	r8,pc[1832]
80003560:	91 09       	st.w	r8[0x0],r9
80003562:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003566:	fe f9 07 26 	ld.w	r9,pc[1830]
8000356a:	72 08       	ld.w	r8,r9[0x0]
8000356c:	20 18       	sub	r8,1
8000356e:	93 08       	st.w	r9[0x0],r8
80003570:	c0 71       	brne	8000357e <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
80003572:	30 09       	mov	r9,0
80003574:	fe f8 07 10 	ld.w	r8,pc[1808]
80003578:	91 09       	st.w	r8[0x0],r9
8000357a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
8000357e:	fe f8 07 26 	ld.w	r8,pc[1830]
80003582:	fe f9 06 fe 	ld.w	r9,pc[1790]
80003586:	72 0a       	ld.w	r10,r9[0x0]
80003588:	70 09       	ld.w	r9,r8[0x0]
8000358a:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000358e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003592:	70 09       	ld.w	r9,r8[0x0]
80003594:	2f f9       	sub	r9,-1
80003596:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003598:	e0 49 01 ff 	cp.w	r9,511
8000359c:	e0 88 00 16 	brls	800035c8 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
800035a0:	30 09       	mov	r9,0
800035a2:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035a4:	fe f6 06 dc 	ld.w	r6,pc[1756]
800035a8:	6c 0c       	ld.w	r12,r6[0x0]
800035aa:	f0 1f 01 c1 	mcall	80003cac <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800035ae:	fe f8 06 ca 	ld.w	r8,pc[1738]
800035b2:	70 0c       	ld.w	r12,r8[0x0]
800035b4:	f0 1f 01 ab 	mcall	80003c60 <phy_rx_func+0xe98>
800035b8:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035ba:	c0 71       	brne	800035c8 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
800035bc:	30 09       	mov	r9,0
800035be:	fe f8 06 c6 	ld.w	r8,pc[1734]
800035c2:	91 09       	st.w	r8[0x0],r9
800035c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035c8:	fe f9 06 c4 	ld.w	r9,pc[1732]
800035cc:	72 08       	ld.w	r8,r9[0x0]
800035ce:	20 18       	sub	r8,1
800035d0:	93 08       	st.w	r9[0x0],r8
800035d2:	c0 71       	brne	800035e0 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
800035d4:	30 09       	mov	r9,0
800035d6:	fe f8 06 ae 	ld.w	r8,pc[1710]
800035da:	91 09       	st.w	r8[0x0],r9
800035dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
800035e0:	fe f8 06 c4 	ld.w	r8,pc[1732]
800035e4:	fe f9 06 9c 	ld.w	r9,pc[1692]
800035e8:	72 0a       	ld.w	r10,r9[0x0]
800035ea:	70 09       	ld.w	r9,r8[0x0]
800035ec:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800035f0:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800035f4:	70 09       	ld.w	r9,r8[0x0]
800035f6:	2f f9       	sub	r9,-1
800035f8:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035fa:	e0 49 01 ff 	cp.w	r9,511
800035fe:	e0 88 00 16 	brls	8000362a <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80003602:	30 09       	mov	r9,0
80003604:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003606:	fe f6 06 7a 	ld.w	r6,pc[1658]
8000360a:	6c 0c       	ld.w	r12,r6[0x0]
8000360c:	f0 1f 01 a8 	mcall	80003cac <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003610:	fe f8 06 68 	ld.w	r8,pc[1640]
80003614:	70 0c       	ld.w	r12,r8[0x0]
80003616:	f0 1f 01 93 	mcall	80003c60 <phy_rx_func+0xe98>
8000361a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000361c:	c0 71       	brne	8000362a <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
8000361e:	30 09       	mov	r9,0
80003620:	fe f8 06 64 	ld.w	r8,pc[1636]
80003624:	91 09       	st.w	r8[0x0],r9
80003626:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000362a:	fe f9 06 62 	ld.w	r9,pc[1634]
8000362e:	72 08       	ld.w	r8,r9[0x0]
80003630:	20 18       	sub	r8,1
80003632:	93 08       	st.w	r9[0x0],r8
80003634:	c0 71       	brne	80003642 <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
80003636:	30 09       	mov	r9,0
80003638:	fe f8 06 4c 	ld.w	r8,pc[1612]
8000363c:	91 09       	st.w	r8[0x0],r9
8000363e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003642:	fe f8 06 62 	ld.w	r8,pc[1634]
80003646:	fe f9 06 3a 	ld.w	r9,pc[1594]
8000364a:	72 0a       	ld.w	r10,r9[0x0]
8000364c:	70 09       	ld.w	r9,r8[0x0]
8000364e:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003652:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003656:	70 09       	ld.w	r9,r8[0x0]
80003658:	2f f9       	sub	r9,-1
8000365a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000365c:	e0 49 01 ff 	cp.w	r9,511
80003660:	e0 88 00 16 	brls	8000368c <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003664:	30 09       	mov	r9,0
80003666:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003668:	fe f6 06 18 	ld.w	r6,pc[1560]
8000366c:	6c 0c       	ld.w	r12,r6[0x0]
8000366e:	f0 1f 01 90 	mcall	80003cac <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003672:	fe f8 06 06 	ld.w	r8,pc[1542]
80003676:	70 0c       	ld.w	r12,r8[0x0]
80003678:	f0 1f 01 7a 	mcall	80003c60 <phy_rx_func+0xe98>
8000367c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000367e:	c0 71       	brne	8000368c <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80003680:	30 09       	mov	r9,0
80003682:	fe f8 06 02 	ld.w	r8,pc[1538]
80003686:	91 09       	st.w	r8[0x0],r9
80003688:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000368c:	fe f9 06 00 	ld.w	r9,pc[1536]
80003690:	72 08       	ld.w	r8,r9[0x0]
80003692:	20 18       	sub	r8,1
80003694:	93 08       	st.w	r9[0x0],r8
80003696:	c0 71       	brne	800036a4 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
80003698:	30 09       	mov	r9,0
8000369a:	fe f8 05 ea 	ld.w	r8,pc[1514]
8000369e:	91 09       	st.w	r8[0x0],r9
800036a0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
800036a4:	fe f8 06 00 	ld.w	r8,pc[1536]
800036a8:	fe f9 05 d8 	ld.w	r9,pc[1496]
800036ac:	72 0a       	ld.w	r10,r9[0x0]
800036ae:	70 09       	ld.w	r9,r8[0x0]
800036b0:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800036b4:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800036b8:	70 09       	ld.w	r9,r8[0x0]
800036ba:	2f f9       	sub	r9,-1
800036bc:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036be:	e0 49 01 ff 	cp.w	r9,511
800036c2:	e0 88 00 16 	brls	800036ee <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
800036c6:	30 09       	mov	r9,0
800036c8:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800036ca:	fe f6 05 b6 	ld.w	r6,pc[1462]
800036ce:	6c 0c       	ld.w	r12,r6[0x0]
800036d0:	f0 1f 01 77 	mcall	80003cac <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800036d4:	fe f8 05 a4 	ld.w	r8,pc[1444]
800036d8:	70 0c       	ld.w	r12,r8[0x0]
800036da:	f0 1f 01 62 	mcall	80003c60 <phy_rx_func+0xe98>
800036de:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800036e0:	c0 71       	brne	800036ee <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
800036e2:	30 09       	mov	r9,0
800036e4:	fe f8 05 a0 	ld.w	r8,pc[1440]
800036e8:	91 09       	st.w	r8[0x0],r9
800036ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800036ee:	fe f9 05 9e 	ld.w	r9,pc[1438]
800036f2:	72 08       	ld.w	r8,r9[0x0]
800036f4:	20 18       	sub	r8,1
800036f6:	93 08       	st.w	r9[0x0],r8
800036f8:	c0 71       	brne	80003706 <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
800036fa:	30 09       	mov	r9,0
800036fc:	fe f8 05 88 	ld.w	r8,pc[1416]
80003700:	91 09       	st.w	r8[0x0],r9
80003702:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003706:	fe f8 05 9e 	ld.w	r8,pc[1438]
8000370a:	fe f9 05 76 	ld.w	r9,pc[1398]
8000370e:	72 0a       	ld.w	r10,r9[0x0]
80003710:	70 09       	ld.w	r9,r8[0x0]
80003712:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003716:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000371a:	70 09       	ld.w	r9,r8[0x0]
8000371c:	2f f9       	sub	r9,-1
8000371e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003720:	e0 49 01 ff 	cp.w	r9,511
80003724:	e0 88 00 16 	brls	80003750 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003728:	30 09       	mov	r9,0
8000372a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000372c:	fe f7 05 54 	ld.w	r7,pc[1364]
80003730:	6e 0c       	ld.w	r12,r7[0x0]
80003732:	f0 1f 01 5f 	mcall	80003cac <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003736:	fe f8 05 42 	ld.w	r8,pc[1346]
8000373a:	70 0c       	ld.w	r12,r8[0x0]
8000373c:	f0 1f 01 49 	mcall	80003c60 <phy_rx_func+0xe98>
80003740:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003742:	c0 71       	brne	80003750 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
80003744:	30 09       	mov	r9,0
80003746:	fe f8 05 3e 	ld.w	r8,pc[1342]
8000374a:	91 09       	st.w	r8[0x0],r9
8000374c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003750:	fe f9 05 3c 	ld.w	r9,pc[1340]
80003754:	72 08       	ld.w	r8,r9[0x0]
80003756:	20 18       	sub	r8,1
80003758:	93 08       	st.w	r9[0x0],r8
8000375a:	e0 81 02 74 	brne	80003c42 <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
8000375e:	30 09       	mov	r9,0
80003760:	fe f8 05 24 	ld.w	r8,pc[1316]
80003764:	91 09       	st.w	r8[0x0],r9
80003766:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
8000376a:	30 09       	mov	r9,0
8000376c:	fe f8 05 18 	ld.w	r8,pc[1304]
80003770:	91 09       	st.w	r8[0x0],r9
80003772:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003776:	fe f8 05 26 	ld.w	r8,pc[1318]
8000377a:	11 89       	ld.ub	r9,r8[0x0]
8000377c:	3f 28       	mov	r8,-14
8000377e:	f0 09 18 00 	cp.b	r9,r8
80003782:	c4 31       	brne	80003808 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003784:	8e 49       	ld.sh	r9,r7[0x8]
80003786:	fe f8 05 56 	ld.w	r8,pc[1366]
8000378a:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
8000378c:	fe f8 05 18 	ld.w	r8,pc[1304]
80003790:	fe f9 04 f0 	ld.w	r9,pc[1264]
80003794:	72 0a       	ld.w	r10,r9[0x0]
80003796:	70 09       	ld.w	r9,r8[0x0]
80003798:	ef 3b 00 08 	ld.ub	r11,r7[8]
8000379c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800037a0:	70 09       	ld.w	r9,r8[0x0]
800037a2:	2f f9       	sub	r9,-1
800037a4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037a6:	e0 49 01 ff 	cp.w	r9,511
800037aa:	e0 88 00 16 	brls	800037d6 <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
800037ae:	30 09       	mov	r9,0
800037b0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800037b2:	fe f7 04 ce 	ld.w	r7,pc[1230]
800037b6:	6e 0c       	ld.w	r12,r7[0x0]
800037b8:	f0 1f 01 3d 	mcall	80003cac <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800037bc:	fe f8 04 bc 	ld.w	r8,pc[1212]
800037c0:	70 0c       	ld.w	r12,r8[0x0]
800037c2:	f0 1f 01 28 	mcall	80003c60 <phy_rx_func+0xe98>
800037c6:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800037c8:	c0 71       	brne	800037d6 <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
800037ca:	30 09       	mov	r9,0
800037cc:	fe f8 04 b8 	ld.w	r8,pc[1208]
800037d0:	91 09       	st.w	r8[0x0],r9
800037d2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800037d6:	fe f9 04 b6 	ld.w	r9,pc[1206]
800037da:	72 08       	ld.w	r8,r9[0x0]
800037dc:	20 18       	sub	r8,1
800037de:	93 08       	st.w	r9[0x0],r8
800037e0:	c0 71       	brne	800037ee <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
800037e2:	30 09       	mov	r9,0
800037e4:	fe f8 04 a0 	ld.w	r8,pc[1184]
800037e8:	91 09       	st.w	r8[0x0],r9
800037ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
800037ee:	20 18       	sub	r8,1
800037f0:	fe f9 04 9c 	ld.w	r9,pc[1180]
800037f4:	93 08       	st.w	r9[0x0],r8
800037f6:	58 08       	cp.w	r8,0
800037f8:	e0 81 02 25 	brne	80003c42 <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
800037fc:	30 09       	mov	r9,0
800037fe:	fe f8 04 86 	ld.w	r8,pc[1158]
80003802:	91 09       	st.w	r8[0x0],r9
80003804:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003808:	fe f8 04 94 	ld.w	r8,pc[1172]
8000380c:	11 89       	ld.ub	r9,r8[0x0]
8000380e:	3f 38       	mov	r8,-13
80003810:	f0 09 18 00 	cp.b	r9,r8
80003814:	e0 81 01 0c 	brne	80003a2c <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003818:	8e 49       	ld.sh	r9,r7[0x8]
8000381a:	fe f8 04 c2 	ld.w	r8,pc[1218]
8000381e:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003820:	8e 59       	ld.sh	r9,r7[0xa]
80003822:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003824:	8e 69       	ld.sh	r9,r7[0xc]
80003826:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003828:	fe f8 04 7c 	ld.w	r8,pc[1148]
8000382c:	fe f9 04 54 	ld.w	r9,pc[1108]
80003830:	72 0a       	ld.w	r10,r9[0x0]
80003832:	70 09       	ld.w	r9,r8[0x0]
80003834:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003838:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000383c:	70 09       	ld.w	r9,r8[0x0]
8000383e:	2f f9       	sub	r9,-1
80003840:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003842:	e0 49 01 ff 	cp.w	r9,511
80003846:	e0 88 00 16 	brls	80003872 <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
8000384a:	30 09       	mov	r9,0
8000384c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000384e:	fe f6 04 32 	ld.w	r6,pc[1074]
80003852:	6c 0c       	ld.w	r12,r6[0x0]
80003854:	f0 1f 01 16 	mcall	80003cac <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003858:	fe f8 04 20 	ld.w	r8,pc[1056]
8000385c:	70 0c       	ld.w	r12,r8[0x0]
8000385e:	f0 1f 01 01 	mcall	80003c60 <phy_rx_func+0xe98>
80003862:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003864:	c0 71       	brne	80003872 <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
80003866:	30 09       	mov	r9,0
80003868:	fe f8 04 1c 	ld.w	r8,pc[1052]
8000386c:	91 09       	st.w	r8[0x0],r9
8000386e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003872:	fe f9 04 1a 	ld.w	r9,pc[1050]
80003876:	72 08       	ld.w	r8,r9[0x0]
80003878:	20 18       	sub	r8,1
8000387a:	93 08       	st.w	r9[0x0],r8
8000387c:	c0 71       	brne	8000388a <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
8000387e:	30 09       	mov	r9,0
80003880:	fe f8 04 04 	ld.w	r8,pc[1028]
80003884:	91 09       	st.w	r8[0x0],r9
80003886:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
8000388a:	fe f8 04 1a 	ld.w	r8,pc[1050]
8000388e:	fe f9 03 f2 	ld.w	r9,pc[1010]
80003892:	72 0a       	ld.w	r10,r9[0x0]
80003894:	70 09       	ld.w	r9,r8[0x0]
80003896:	ef 3b 00 09 	ld.ub	r11,r7[9]
8000389a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000389e:	70 09       	ld.w	r9,r8[0x0]
800038a0:	2f f9       	sub	r9,-1
800038a2:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038a4:	e0 49 01 ff 	cp.w	r9,511
800038a8:	e0 88 00 16 	brls	800038d4 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
800038ac:	30 09       	mov	r9,0
800038ae:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800038b0:	fe f6 03 d0 	ld.w	r6,pc[976]
800038b4:	6c 0c       	ld.w	r12,r6[0x0]
800038b6:	f0 1f 00 fe 	mcall	80003cac <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800038ba:	fe f8 03 be 	ld.w	r8,pc[958]
800038be:	70 0c       	ld.w	r12,r8[0x0]
800038c0:	f0 1f 00 e8 	mcall	80003c60 <phy_rx_func+0xe98>
800038c4:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038c6:	c0 71       	brne	800038d4 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
800038c8:	30 09       	mov	r9,0
800038ca:	fe f8 03 ba 	ld.w	r8,pc[954]
800038ce:	91 09       	st.w	r8[0x0],r9
800038d0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038d4:	fe f9 03 b8 	ld.w	r9,pc[952]
800038d8:	72 08       	ld.w	r8,r9[0x0]
800038da:	20 18       	sub	r8,1
800038dc:	93 08       	st.w	r9[0x0],r8
800038de:	c0 71       	brne	800038ec <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
800038e0:	30 09       	mov	r9,0
800038e2:	fe f8 03 a2 	ld.w	r8,pc[930]
800038e6:	91 09       	st.w	r8[0x0],r9
800038e8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
800038ec:	fe f8 03 b8 	ld.w	r8,pc[952]
800038f0:	fe f9 03 90 	ld.w	r9,pc[912]
800038f4:	72 0a       	ld.w	r10,r9[0x0]
800038f6:	70 09       	ld.w	r9,r8[0x0]
800038f8:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800038fc:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003900:	70 09       	ld.w	r9,r8[0x0]
80003902:	2f f9       	sub	r9,-1
80003904:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003906:	e0 49 01 ff 	cp.w	r9,511
8000390a:	e0 88 00 16 	brls	80003936 <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
8000390e:	30 09       	mov	r9,0
80003910:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003912:	fe f6 03 6e 	ld.w	r6,pc[878]
80003916:	6c 0c       	ld.w	r12,r6[0x0]
80003918:	f0 1f 00 e5 	mcall	80003cac <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000391c:	fe f8 03 5c 	ld.w	r8,pc[860]
80003920:	70 0c       	ld.w	r12,r8[0x0]
80003922:	f0 1f 00 d0 	mcall	80003c60 <phy_rx_func+0xe98>
80003926:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003928:	c0 71       	brne	80003936 <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
8000392a:	30 09       	mov	r9,0
8000392c:	fe f8 03 58 	ld.w	r8,pc[856]
80003930:	91 09       	st.w	r8[0x0],r9
80003932:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003936:	fe f9 03 56 	ld.w	r9,pc[854]
8000393a:	72 08       	ld.w	r8,r9[0x0]
8000393c:	20 18       	sub	r8,1
8000393e:	93 08       	st.w	r9[0x0],r8
80003940:	c0 71       	brne	8000394e <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
80003942:	30 09       	mov	r9,0
80003944:	fe f8 03 40 	ld.w	r8,pc[832]
80003948:	91 09       	st.w	r8[0x0],r9
8000394a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
8000394e:	fe f8 03 56 	ld.w	r8,pc[854]
80003952:	fe f9 03 2e 	ld.w	r9,pc[814]
80003956:	72 0a       	ld.w	r10,r9[0x0]
80003958:	70 09       	ld.w	r9,r8[0x0]
8000395a:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000395e:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003962:	70 09       	ld.w	r9,r8[0x0]
80003964:	2f f9       	sub	r9,-1
80003966:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003968:	e0 49 01 ff 	cp.w	r9,511
8000396c:	e0 88 00 16 	brls	80003998 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003970:	30 09       	mov	r9,0
80003972:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003974:	fe f6 03 0c 	ld.w	r6,pc[780]
80003978:	6c 0c       	ld.w	r12,r6[0x0]
8000397a:	f0 1f 00 cd 	mcall	80003cac <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000397e:	fe f8 02 fa 	ld.w	r8,pc[762]
80003982:	70 0c       	ld.w	r12,r8[0x0]
80003984:	f0 1f 00 b7 	mcall	80003c60 <phy_rx_func+0xe98>
80003988:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000398a:	c0 71       	brne	80003998 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
8000398c:	30 09       	mov	r9,0
8000398e:	fe f8 02 f6 	ld.w	r8,pc[758]
80003992:	91 09       	st.w	r8[0x0],r9
80003994:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003998:	fe f9 02 f4 	ld.w	r9,pc[756]
8000399c:	72 08       	ld.w	r8,r9[0x0]
8000399e:	20 18       	sub	r8,1
800039a0:	93 08       	st.w	r9[0x0],r8
800039a2:	c0 71       	brne	800039b0 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
800039a4:	30 09       	mov	r9,0
800039a6:	fe f8 02 de 	ld.w	r8,pc[734]
800039aa:	91 09       	st.w	r8[0x0],r9
800039ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
800039b0:	fe f8 02 f4 	ld.w	r8,pc[756]
800039b4:	fe f9 02 cc 	ld.w	r9,pc[716]
800039b8:	72 0a       	ld.w	r10,r9[0x0]
800039ba:	70 09       	ld.w	r9,r8[0x0]
800039bc:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800039c0:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800039c4:	70 09       	ld.w	r9,r8[0x0]
800039c6:	2f f9       	sub	r9,-1
800039c8:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039ca:	e0 49 01 ff 	cp.w	r9,511
800039ce:	e0 88 00 16 	brls	800039fa <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
800039d2:	30 09       	mov	r9,0
800039d4:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800039d6:	fe f7 02 aa 	ld.w	r7,pc[682]
800039da:	6e 0c       	ld.w	r12,r7[0x0]
800039dc:	f0 1f 00 b4 	mcall	80003cac <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800039e0:	fe f8 02 98 	ld.w	r8,pc[664]
800039e4:	70 0c       	ld.w	r12,r8[0x0]
800039e6:	f0 1f 00 9f 	mcall	80003c60 <phy_rx_func+0xe98>
800039ea:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800039ec:	c0 71       	brne	800039fa <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
800039ee:	30 09       	mov	r9,0
800039f0:	fe f8 02 94 	ld.w	r8,pc[660]
800039f4:	91 09       	st.w	r8[0x0],r9
800039f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800039fa:	fe f9 02 92 	ld.w	r9,pc[658]
800039fe:	72 08       	ld.w	r8,r9[0x0]
80003a00:	20 18       	sub	r8,1
80003a02:	93 08       	st.w	r9[0x0],r8
80003a04:	c0 71       	brne	80003a12 <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003a06:	30 09       	mov	r9,0
80003a08:	fe f8 02 7c 	ld.w	r8,pc[636]
80003a0c:	91 09       	st.w	r8[0x0],r9
80003a0e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003a12:	20 18       	sub	r8,1
80003a14:	fe f9 02 78 	ld.w	r9,pc[632]
80003a18:	93 08       	st.w	r9[0x0],r8
80003a1a:	58 08       	cp.w	r8,0
80003a1c:	e0 81 01 13 	brne	80003c42 <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003a20:	30 09       	mov	r9,0
80003a22:	fe f8 02 62 	ld.w	r8,pc[610]
80003a26:	91 09       	st.w	r8[0x0],r9
80003a28:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003a2c:	fe f8 02 70 	ld.w	r8,pc[624]
80003a30:	11 89       	ld.ub	r9,r8[0x0]
80003a32:	30 48       	mov	r8,4
80003a34:	f0 09 18 00 	cp.b	r9,r8
80003a38:	c0 80       	breq	80003a48 <phy_rx_func+0xc80>
80003a3a:	fe f8 02 62 	ld.w	r8,pc[610]
80003a3e:	11 89       	ld.ub	r9,r8[0x0]
80003a40:	30 38       	mov	r8,3
80003a42:	f0 09 18 00 	cp.b	r9,r8
80003a46:	c1 41       	brne	80003a6e <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003a48:	6e 29       	ld.w	r9,r7[0x8]
80003a4a:	fe f8 02 7a 	ld.w	r8,pc[634]
80003a4e:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003a50:	6e 39       	ld.w	r9,r7[0xc]
80003a52:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003a54:	fe f9 02 38 	ld.w	r9,pc[568]
80003a58:	72 08       	ld.w	r8,r9[0x0]
80003a5a:	20 88       	sub	r8,8
80003a5c:	93 08       	st.w	r9[0x0],r8
80003a5e:	e0 81 00 f2 	brne	80003c42 <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003a62:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003a64:	fe f9 02 20 	ld.w	r9,pc[544]
80003a68:	93 08       	st.w	r9[0x0],r8
80003a6a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003a6e:	fe f8 02 2e 	ld.w	r8,pc[558]
80003a72:	11 89       	ld.ub	r9,r8[0x0]
80003a74:	31 38       	mov	r8,19
80003a76:	f0 09 18 00 	cp.b	r9,r8
80003a7a:	e0 81 00 9c 	brne	80003bb2 <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80003a7e:	fe f8 02 62 	ld.w	r8,pc[610]
80003a82:	11 88       	ld.ub	r8,r8[0x0]
80003a84:	30 c9       	mov	r9,12
80003a86:	f2 08 18 00 	cp.b	r8,r9
80003a8a:	e0 81 00 7b 	brne	80003b80 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003a8e:	8e 49       	ld.sh	r9,r7[0x8]
80003a90:	fe f8 02 54 	ld.w	r8,pc[596]
80003a94:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003a98:	30 09       	mov	r9,0
80003a9a:	fe f8 02 46 	ld.w	r8,pc[582]
80003a9e:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003aa0:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003aa4:	3f 38       	mov	r8,-13
80003aa6:	f0 09 18 00 	cp.b	r9,r8
80003aaa:	c6 61       	brne	80003b76 <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003aac:	10 99       	mov	r9,r8
80003aae:	4f c8       	lddpc	r8,80003c9c <phy_rx_func+0xed4>
80003ab0:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003ab2:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003ab6:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003aba:	4f 58       	lddpc	r8,80003c8c <phy_rx_func+0xec4>
80003abc:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003abe:	30 19       	mov	r9,1
80003ac0:	fe f8 02 0c 	ld.w	r8,pc[524]
80003ac4:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003ac6:	8e 79       	ld.sh	r9,r7[0xe]
80003ac8:	fe f8 02 14 	ld.w	r8,pc[532]
80003acc:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003ace:	4f 68       	lddpc	r8,80003ca4 <phy_rx_func+0xedc>
80003ad0:	4e c9       	lddpc	r9,80003c80 <phy_rx_func+0xeb8>
80003ad2:	72 0a       	ld.w	r10,r9[0x0]
80003ad4:	70 09       	ld.w	r9,r8[0x0]
80003ad6:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003ada:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003ade:	70 09       	ld.w	r9,r8[0x0]
80003ae0:	2f f9       	sub	r9,-1
80003ae2:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ae4:	e0 49 01 ff 	cp.w	r9,511
80003ae8:	e0 88 00 13 	brls	80003b0e <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003aec:	30 09       	mov	r9,0
80003aee:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003af0:	4e 46       	lddpc	r6,80003c80 <phy_rx_func+0xeb8>
80003af2:	6c 0c       	ld.w	r12,r6[0x0]
80003af4:	f0 1f 00 6e 	mcall	80003cac <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003af8:	4e 08       	lddpc	r8,80003c78 <phy_rx_func+0xeb0>
80003afa:	70 0c       	ld.w	r12,r8[0x0]
80003afc:	f0 1f 00 59 	mcall	80003c60 <phy_rx_func+0xe98>
80003b00:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003b02:	c0 61       	brne	80003b0e <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003b04:	30 09       	mov	r9,0
80003b06:	4e 08       	lddpc	r8,80003c84 <phy_rx_func+0xebc>
80003b08:	91 09       	st.w	r8[0x0],r9
80003b0a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003b0e:	4e 09       	lddpc	r9,80003c8c <phy_rx_func+0xec4>
80003b10:	72 08       	ld.w	r8,r9[0x0]
80003b12:	20 18       	sub	r8,1
80003b14:	93 08       	st.w	r9[0x0],r8
80003b16:	c0 61       	brne	80003b22 <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003b18:	30 09       	mov	r9,0
80003b1a:	4d b8       	lddpc	r8,80003c84 <phy_rx_func+0xebc>
80003b1c:	91 09       	st.w	r8[0x0],r9
80003b1e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003b22:	4e 18       	lddpc	r8,80003ca4 <phy_rx_func+0xedc>
80003b24:	4d 79       	lddpc	r9,80003c80 <phy_rx_func+0xeb8>
80003b26:	72 0a       	ld.w	r10,r9[0x0]
80003b28:	70 09       	ld.w	r9,r8[0x0]
80003b2a:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003b2e:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003b32:	70 09       	ld.w	r9,r8[0x0]
80003b34:	2f f9       	sub	r9,-1
80003b36:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b38:	e0 49 01 ff 	cp.w	r9,511
80003b3c:	e0 88 00 13 	brls	80003b62 <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003b40:	30 09       	mov	r9,0
80003b42:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003b44:	4c f7       	lddpc	r7,80003c80 <phy_rx_func+0xeb8>
80003b46:	6e 0c       	ld.w	r12,r7[0x0]
80003b48:	f0 1f 00 59 	mcall	80003cac <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003b4c:	4c b8       	lddpc	r8,80003c78 <phy_rx_func+0xeb0>
80003b4e:	70 0c       	ld.w	r12,r8[0x0]
80003b50:	f0 1f 00 44 	mcall	80003c60 <phy_rx_func+0xe98>
80003b54:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003b56:	c0 61       	brne	80003b62 <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003b58:	30 09       	mov	r9,0
80003b5a:	4c b8       	lddpc	r8,80003c84 <phy_rx_func+0xebc>
80003b5c:	91 09       	st.w	r8[0x0],r9
80003b5e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003b62:	4c b9       	lddpc	r9,80003c8c <phy_rx_func+0xec4>
80003b64:	72 08       	ld.w	r8,r9[0x0]
80003b66:	20 18       	sub	r8,1
80003b68:	93 08       	st.w	r9[0x0],r8
80003b6a:	c6 c1       	brne	80003c42 <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003b6c:	30 09       	mov	r9,0
80003b6e:	4c 68       	lddpc	r8,80003c84 <phy_rx_func+0xebc>
80003b70:	91 09       	st.w	r8[0x0],r9
80003b72:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003b76:	30 09       	mov	r9,0
80003b78:	4c 38       	lddpc	r8,80003c84 <phy_rx_func+0xebc>
80003b7a:	91 09       	st.w	r8[0x0],r9
80003b7c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003b80:	8e 4a       	ld.sh	r10,r7[0x8]
80003b82:	4d 99       	lddpc	r9,80003ce4 <phy_rx_func+0xf1c>
80003b84:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003b88:	4d 6a       	lddpc	r10,80003ce0 <phy_rx_func+0xf18>
80003b8a:	15 88       	ld.ub	r8,r10[0x0]
80003b8c:	f0 cb ff ff 	sub	r11,r8,-1
80003b90:	8e 5c       	ld.sh	r12,r7[0xa]
80003b92:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003b96:	f0 cb ff fe 	sub	r11,r8,-2
80003b9a:	8e 6c       	ld.sh	r12,r7[0xc]
80003b9c:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003ba0:	f0 cb ff fd 	sub	r11,r8,-3
80003ba4:	8e 7c       	ld.sh	r12,r7[0xe]
80003ba6:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003baa:	2f c8       	sub	r8,-4
80003bac:	b4 88       	st.b	r10[0x0],r8
80003bae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003bb2:	30 09       	mov	r9,0
80003bb4:	4b 48       	lddpc	r8,80003c84 <phy_rx_func+0xebc>
80003bb6:	91 09       	st.w	r8[0x0],r9
80003bb8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003bbc:	4c 08       	lddpc	r8,80003cbc <phy_rx_func+0xef4>
80003bbe:	70 09       	ld.w	r9,r8[0x0]
80003bc0:	8e 4b       	ld.sh	r11,r7[0x8]
80003bc2:	4c 0a       	lddpc	r10,80003cc0 <phy_rx_func+0xef8>
80003bc4:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003bc8:	2f f9       	sub	r9,-1
80003bca:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003bcc:	4b 58       	lddpc	r8,80003ca0 <phy_rx_func+0xed8>
80003bce:	70 09       	ld.w	r9,r8[0x0]
80003bd0:	20 29       	sub	r9,2
80003bd2:	91 09       	st.w	r8[0x0],r9
80003bd4:	70 08       	ld.w	r8,r8[0x0]
80003bd6:	58 08       	cp.w	r8,0
80003bd8:	c2 f1       	brne	80003c36 <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003bda:	30 09       	mov	r9,0
80003bdc:	4b 88       	lddpc	r8,80003cbc <phy_rx_func+0xef4>
80003bde:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003be0:	8e 59       	ld.sh	r9,r7[0xa]
80003be2:	fe 78 82 12 	mov	r8,-32238
80003be6:	f0 09 19 00 	cp.h	r9,r8
80003bea:	c2 11       	brne	80003c2c <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003bec:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003bf0:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003bf4:	4a f8       	lddpc	r8,80003cb0 <phy_rx_func+0xee8>
80003bf6:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003bf8:	8e 59       	ld.sh	r9,r7[0xa]
80003bfa:	4a f8       	lddpc	r8,80003cb4 <phy_rx_func+0xeec>
80003bfc:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003bfe:	8e 69       	ld.sh	r9,r7[0xc]
80003c00:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003c02:	f0 1f 00 2e 	mcall	80003cb8 <phy_rx_func+0xef0>
80003c06:	4a 18       	lddpc	r8,80003c88 <phy_rx_func+0xec0>
80003c08:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003c0a:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003c0e:	31 38       	mov	r8,19
80003c10:	f0 09 18 00 	cp.b	r9,r8
80003c14:	c0 71       	brne	80003c22 <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003c16:	10 99       	mov	r9,r8
80003c18:	4a 18       	lddpc	r8,80003c9c <phy_rx_func+0xed4>
80003c1a:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003c1c:	30 09       	mov	r9,0
80003c1e:	49 c8       	lddpc	r8,80003c8c <phy_rx_func+0xec4>
80003c20:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003c22:	30 49       	mov	r9,4
80003c24:	49 88       	lddpc	r8,80003c84 <phy_rx_func+0xebc>
80003c26:	91 09       	st.w	r8[0x0],r9
80003c28:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003c2c:	30 09       	mov	r9,0
80003c2e:	49 68       	lddpc	r8,80003c84 <phy_rx_func+0xebc>
80003c30:	91 09       	st.w	r8[0x0],r9
80003c32:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003c36:	4a dc       	lddpc	r12,80003ce8 <phy_rx_func+0xf20>
80003c38:	f0 1f 00 18 	mcall	80003c98 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003c3c:	30 09       	mov	r9,0
80003c3e:	49 28       	lddpc	r8,80003c84 <phy_rx_func+0xebc>
80003c40:	91 09       	st.w	r8[0x0],r9
80003c42:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003c46:	00 00       	add	r0,r0
80003c48:	00 00       	add	r0,r0
80003c4a:	0a b8       	st.h	r5++,r8
80003c4c:	00 00       	add	r0,r0
80003c4e:	0a bc       	st.h	r5++,r12
80003c50:	00 00       	add	r0,r0
80003c52:	0a a0       	st.w	r5++,r0
80003c54:	00 00       	add	r0,r0
80003c56:	0a 7c       	tst	r12,r5
80003c58:	00 00       	add	r0,r0
80003c5a:	0a 74       	tst	r4,r5
80003c5c:	00 00       	add	r0,r0
80003c5e:	0a b4       	st.h	r5++,r4
80003c60:	80 00       	ld.sh	r0,r0[0x0]
80003c62:	2b e8       	sub	r8,-66
80003c64:	00 00       	add	r0,r0
80003c66:	0a 88       	andn	r8,r5
80003c68:	80 00       	ld.sh	r0,r0[0x0]
80003c6a:	2b 18       	sub	r8,-79
80003c6c:	00 00       	add	r0,r0
80003c6e:	0a 6c       	and	r12,r5
80003c70:	80 00       	ld.sh	r0,r0[0x0]
80003c72:	2b 34       	sub	r4,-77
80003c74:	00 00       	add	r0,r0
80003c76:	0a 85       	andn	r5,r5
80003c78:	00 00       	add	r0,r0
80003c7a:	0a 70       	tst	r0,r5
80003c7c:	00 00       	add	r0,r0
80003c7e:	0a 9c       	mov	r12,r5
80003c80:	00 00       	add	r0,r0
80003c82:	0a 94       	mov	r4,r5
80003c84:	00 00       	add	r0,r0
80003c86:	0a d0       	st.w	--r5,r0
80003c88:	00 00       	add	r0,r0
80003c8a:	0a 68       	and	r8,r5
80003c8c:	00 00       	add	r0,r0
80003c8e:	0a 78       	tst	r8,r5
80003c90:	00 00       	add	r0,r0
80003c92:	0a 53       	eor	r3,r5
80003c94:	80 00       	ld.sh	r0,r0[0x0]
80003c96:	d5 44       	*unknown*
80003c98:	80 00       	ld.sh	r0,r0[0x0]
80003c9a:	6e a0       	ld.w	r0,r7[0x28]
80003c9c:	00 00       	add	r0,r0
80003c9e:	0a 84       	andn	r4,r5
80003ca0:	00 00       	add	r0,r0
80003ca2:	0a 90       	mov	r0,r5
80003ca4:	00 00       	add	r0,r0
80003ca6:	0a a4       	st.w	r5++,r4
80003ca8:	80 00       	ld.sh	r0,r0[0x0]
80003caa:	76 dc       	ld.w	r12,r11[0x34]
80003cac:	80 00       	ld.sh	r0,r0[0x0]
80003cae:	2d 68       	sub	r8,-42
80003cb0:	00 00       	add	r0,r0
80003cb2:	0a 48       	or	r8,r5
80003cb4:	00 00       	add	r0,r0
80003cb6:	1e 90       	mov	r0,pc
80003cb8:	80 00       	ld.sh	r0,r0[0x0]
80003cba:	2a 78       	sub	r8,-89
80003cbc:	00 00       	add	r0,r0
80003cbe:	0a c0       	st.b	r5++,r0
80003cc0:	00 00       	add	r0,r0
80003cc2:	1d 94       	ld.ub	r4,lr[0x1]
80003cc4:	00 00       	add	r0,r0
80003cc6:	0a d4       	st.w	--r5,r4
80003cc8:	00 00       	add	r0,r0
80003cca:	0a 50       	eor	r0,r5
80003ccc:	00 00       	add	r0,r0
80003cce:	0a 41       	or	r1,r5
80003cd0:	00 00       	add	r0,r0
80003cd2:	0a b0       	st.h	r5++,r0
80003cd4:	00 00       	add	r0,r0
80003cd6:	0a 98       	mov	r8,r5
80003cd8:	00 00       	add	r0,r0
80003cda:	0a 57       	eor	r7,r5
80003cdc:	00 00       	add	r0,r0
80003cde:	1d 8c       	ld.ub	r12,lr[0x0]
80003ce0:	00 00       	add	r0,r0
80003ce2:	0a c8       	st.b	r5++,r8
80003ce4:	00 00       	add	r0,r0
80003ce6:	1e 94       	mov	r4,pc
80003ce8:	80 00       	ld.sh	r0,r0[0x0]
80003cea:	d5 5c       	*unknown*

80003cec <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003cec:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003cee:	49 88       	lddpc	r8,80003d4c <pdca_int_handler+0x60>
80003cf0:	11 89       	ld.ub	r9,r8[0x0]
80003cf2:	ec 19 00 01 	eorl	r9,0x1
80003cf6:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003cf8:	11 89       	ld.ub	r9,r8[0x0]
80003cfa:	a5 69       	lsl	r9,0x4
80003cfc:	2f c9       	sub	r9,-4
80003cfe:	49 5a       	lddpc	r10,80003d50 <pdca_int_handler+0x64>
80003d00:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003d02:	fe 7a 00 40 	mov	r10,-65472
80003d06:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003d08:	30 39       	mov	r9,3
80003d0a:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003d0c:	11 8a       	ld.ub	r10,r8[0x0]
80003d0e:	a5 6a       	lsl	r10,0x4
80003d10:	2f ca       	sub	r10,-4
80003d12:	49 18       	lddpc	r8,80003d54 <pdca_int_handler+0x68>
80003d14:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003d16:	fe 78 00 00 	mov	r8,-65536
80003d1a:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003d1c:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003d1e:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003d20:	48 e8       	lddpc	r8,80003d58 <pdca_int_handler+0x6c>
80003d22:	70 08       	ld.w	r8,r8[0x0]
80003d24:	58 08       	cp.w	r8,0
80003d26:	c0 70       	breq	80003d34 <pdca_int_handler+0x48>
80003d28:	48 99       	lddpc	r9,80003d4c <pdca_int_handler+0x60>
80003d2a:	13 89       	ld.ub	r9,r9[0x0]
80003d2c:	a5 69       	lsl	r9,0x4
80003d2e:	48 ac       	lddpc	r12,80003d54 <pdca_int_handler+0x68>
80003d30:	12 0c       	add	r12,r9
80003d32:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003d34:	48 a8       	lddpc	r8,80003d5c <pdca_int_handler+0x70>
80003d36:	70 08       	ld.w	r8,r8[0x0]
80003d38:	58 08       	cp.w	r8,0
80003d3a:	c0 70       	breq	80003d48 <pdca_int_handler+0x5c>
80003d3c:	48 49       	lddpc	r9,80003d4c <pdca_int_handler+0x60>
80003d3e:	13 89       	ld.ub	r9,r9[0x0]
80003d40:	a5 69       	lsl	r9,0x4
80003d42:	48 4c       	lddpc	r12,80003d50 <pdca_int_handler+0x64>
80003d44:	12 0c       	add	r12,r9
80003d46:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003d48:	d4 02       	popm	lr
80003d4a:	d6 03       	rete
80003d4c:	00 00       	add	r0,r0
80003d4e:	50 b4       	stdsp	sp[0x2c],r4
80003d50:	00 00       	add	r0,r0
80003d52:	50 dc       	stdsp	sp[0x34],r12
80003d54:	00 00       	add	r0,r0
80003d56:	50 bc       	stdsp	sp[0x2c],r12
80003d58:	00 00       	add	r0,r0
80003d5a:	0a dc       	st.w	--r5,r12
80003d5c:	00 00       	add	r0,r0
80003d5e:	0a e0       	st.h	--r5,r0

80003d60 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003d60:	fe 78 10 00 	mov	r8,-61440
80003d64:	e0 69 0d c0 	mov	r9,3520
80003d68:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003d6c:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003d70:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003d74:	fe 78 34 00 	mov	r8,-52224
80003d78:	e0 69 80 00 	mov	r9,32768
80003d7c:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003d7e:	30 09       	mov	r9,0
80003d80:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003d82:	e0 69 04 21 	mov	r9,1057
80003d86:	ea 19 3f 20 	orh	r9,0x3f20
80003d8a:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80003d8c:	e0 69 02 9f 	mov	r9,671
80003d90:	ea 19 01 00 	orh	r9,0x100
80003d94:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80003d96:	e0 6a 04 02 	mov	r10,1026
80003d9a:	ea 1a 3f 20 	orh	r10,0x3f20
80003d9e:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80003da0:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003da2:	5e fc       	retal	r12

80003da4 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003da4:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003da6:	30 19       	mov	r9,1
80003da8:	49 78       	lddpc	r8,80003e04 <local_start_PDC+0x60>
80003daa:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003dac:	fe 78 00 00 	mov	r8,-65536
80003db0:	30 7b       	mov	r11,7
80003db2:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003db4:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003db6:	49 59       	lddpc	r9,80003e08 <local_start_PDC+0x64>
80003db8:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003dbc:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003dbe:	30 3a       	mov	r10,3
80003dc0:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003dc2:	30 1c       	mov	r12,1
80003dc4:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003dc6:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003dc8:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003dca:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003dcc:	30 2c       	mov	r12,2
80003dce:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003dd0:	48 f9       	lddpc	r9,80003e0c <local_start_PDC+0x68>
80003dd2:	e0 68 5a 5a 	mov	r8,23130
80003dd6:	ea 18 ab cd 	orh	r8,0xabcd
80003dda:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003ddc:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003dde:	30 0e       	mov	lr,0
80003de0:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003de2:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003de4:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003de6:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003de8:	fe 78 00 40 	mov	r8,-65472
80003dec:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003dee:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003df0:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003df4:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003df6:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003df8:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003dfa:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003dfc:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003dfe:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003e00:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003e02:	d8 02       	popm	pc
80003e04:	00 00       	add	r0,r0
80003e06:	50 b4       	stdsp	sp[0x2c],r4
80003e08:	00 00       	add	r0,r0
80003e0a:	50 bc       	stdsp	sp[0x2c],r12
80003e0c:	00 00       	add	r0,r0
80003e0e:	50 dc       	stdsp	sp[0x34],r12

80003e10 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003e10:	48 38       	lddpc	r8,80003e1c <register_rx_tx_func+0xc>
80003e12:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003e14:	48 38       	lddpc	r8,80003e20 <register_rx_tx_func+0x10>
80003e16:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003e18:	5e fc       	retal	r12
80003e1a:	00 00       	add	r0,r0
80003e1c:	00 00       	add	r0,r0
80003e1e:	0a dc       	st.w	--r5,r12
80003e20:	00 00       	add	r0,r0
80003e22:	0a e0       	st.h	--r5,r0

80003e24 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003e24:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003e26:	fe 78 10 00 	mov	r8,-61440
80003e2a:	30 29       	mov	r9,2
80003e2c:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003e30:	f1 49 01 04 	st.w	r8[260],r9
	
	INTC_register_interrupt (
80003e34:	30 3a       	mov	r10,3
80003e36:	36 0b       	mov	r11,96
80003e38:	49 3c       	lddpc	r12,80003e84 <ssc_init+0x60>
80003e3a:	f0 1f 00 14 	mcall	80003e88 <ssc_init+0x64>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0
	, AVR32_INTC_INT3
	);
	
	Enable_global_interrupt();
80003e3e:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003e40:	fe 79 10 00 	mov	r9,-61440
80003e44:	f2 f8 01 60 	ld.w	r8,r9[352]
80003e48:	e2 18 00 02 	andl	r8,0x2,COH
80003e4c:	cf c0       	breq	80003e44 <ssc_init+0x20>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003e4e:	fe 79 10 00 	mov	r9,-61440
80003e52:	f2 f8 01 60 	ld.w	r8,r9[352]
80003e56:	e2 18 00 02 	andl	r8,0x2,COH
80003e5a:	cf c1       	brne	80003e52 <ssc_init+0x2e>
			
	Disable_global_interrupt(); // resume to before
80003e5c:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80003e5e:	f0 1f 00 0c 	mcall	80003e8c <ssc_init+0x68>

    /*config the PDCA*/
    local_start_PDC();
80003e62:	f0 1f 00 0c 	mcall	80003e90 <ssc_init+0x6c>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003e66:	fe 79 00 00 	mov	r9,-65536
80003e6a:	30 18       	mov	r8,1
80003e6c:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003e6e:	fe 7a 00 40 	mov	r10,-65472
80003e72:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003e74:	e0 6b 01 01 	mov	r11,257
80003e78:	fe 7a 34 00 	mov	r10,-52224
80003e7c:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80003e7e:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80003e80:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80003e82:	d8 02       	popm	pc
80003e84:	80 00       	ld.sh	r0,r0[0x0]
80003e86:	3c ec       	mov	r12,-50
80003e88:	80 00       	ld.sh	r0,r0[0x0]
80003e8a:	53 24       	stdsp	sp[0xc8],r4
80003e8c:	80 00       	ld.sh	r0,r0[0x0]
80003e8e:	3d 60       	mov	r0,-42
80003e90:	80 00       	ld.sh	r0,r0[0x0]
80003e92:	3d a4       	mov	r4,-38

80003e94 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003e94:	48 28       	lddpc	r8,80003e9c <xcmp_register_app_list+0x8>
80003e96:	91 0c       	st.w	r8[0x0],r12
}
80003e98:	5e fc       	retal	r12
80003e9a:	00 00       	add	r0,r0
80003e9c:	00 00       	add	r0,r0
80003e9e:	50 fc       	stdsp	sp[0x3c],r12

80003ea0 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003ea0:	eb cd 40 80 	pushm	r7,lr
80003ea4:	fa cd 01 00 	sub	sp,sp,256
80003ea8:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003eaa:	16 98       	mov	r8,r11
80003eac:	2f 08       	sub	r8,-16
80003eae:	af a8       	sbr	r8,0xe
80003eb0:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003eb2:	3f f8       	mov	r8,-1
80003eb4:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003eb6:	30 b9       	mov	r9,11
80003eb8:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003eba:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003ebc:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003ebe:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003ec0:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003ec2:	f6 ca ff fe 	sub	r10,r11,-2
80003ec6:	18 9b       	mov	r11,r12
80003ec8:	fa cc ff f0 	sub	r12,sp,-16
80003ecc:	f0 1f 00 05 	mcall	80003ee0 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003ed0:	2f e7       	sub	r7,-2
80003ed2:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003ed4:	1a 9c       	mov	r12,sp
80003ed6:	f0 1f 00 04 	mcall	80003ee4 <xcmp_tx+0x44>
}
80003eda:	2c 0d       	sub	sp,-256
80003edc:	e3 cd 80 80 	ldm	sp++,r7,pc
80003ee0:	80 00       	ld.sh	r0,r0[0x0]
80003ee2:	75 94       	ld.w	r4,r10[0x64]
80003ee4:	80 00       	ld.sh	r0,r0[0x0]
80003ee6:	44 ac       	lddsp	r12,sp[0x128]

80003ee8 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80003ee8:	d4 21       	pushm	r4-r7,lr
80003eea:	fa cd 00 d0 	sub	sp,sp,208
80003eee:	18 94       	mov	r4,r12
80003ef0:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003ef2:	e0 68 01 00 	mov	r8,256
80003ef6:	f0 0b 19 00 	cp.h	r11,r8
80003efa:	e0 8b 00 36 	brhi	80003f66 <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003efe:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003f02:	e0 68 04 1d 	mov	r8,1053
80003f06:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003f08:	30 18       	mov	r8,1
80003f0a:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80003f0c:	32 08       	mov	r8,32
80003f0e:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003f10:	30 28       	mov	r8,2
80003f12:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003f14:	30 48       	mov	r8,4
80003f16:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80003f18:	ea 1a 0c 00 	orh	r10,0xc00
80003f1c:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80003f1e:	30 4a       	mov	r10,4
80003f20:	1a 9b       	mov	r11,sp
80003f22:	fa cc ff f4 	sub	r12,sp,-12
80003f26:	f0 1f 00 12 	mcall	80003f6c <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80003f2a:	30 f8       	mov	r8,15
80003f2c:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80003f30:	3a 78       	mov	r8,-89
80003f32:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80003f36:	30 08       	mov	r8,0
80003f38:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80003f3c:	0e 9a       	mov	r10,r7
80003f3e:	5c 7a       	castu.h	r10
80003f40:	f4 08 16 08 	lsr	r8,r10,0x8
80003f44:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80003f48:	0e 96       	mov	r6,r7
80003f4a:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80003f4e:	08 9b       	mov	r11,r4
80003f50:	fa cc ff eb 	sub	r12,sp,-21
80003f54:	f0 1f 00 06 	mcall	80003f6c <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80003f58:	ee cb ff f3 	sub	r11,r7,-13
80003f5c:	5c 5b       	castu.b	r11
80003f5e:	fa cc ff fa 	sub	r12,sp,-6
80003f62:	f0 1f 00 04 	mcall	80003f70 <xcmp_data_session_req+0x88>
}
80003f66:	2c cd       	sub	sp,-208
80003f68:	d8 22       	popm	r4-r7,pc
80003f6a:	00 00       	add	r0,r0
80003f6c:	80 00       	ld.sh	r0,r0[0x0]
80003f6e:	75 94       	ld.w	r4,r10[0x64]
80003f70:	80 00       	ld.sh	r0,r0[0x0]
80003f72:	3e a0       	mov	r0,-22

80003f74 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003f74:	d4 01       	pushm	lr
80003f76:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003f7a:	fe 78 b4 00 	mov	r8,-19456
80003f7e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003f80:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003f84:	30 89       	mov	r9,8
80003f86:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003f88:	30 19       	mov	r9,1
80003f8a:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003f8c:	30 09       	mov	r9,0
80003f8e:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003f90:	30 5a       	mov	r10,5
80003f92:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003f94:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003f96:	30 7a       	mov	r10,7
80003f98:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003f9a:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003f9c:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003f9e:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003fa2:	30 9b       	mov	r11,9
80003fa4:	fa cc ff fe 	sub	r12,sp,-2
80003fa8:	f0 1f 00 02 	mcall	80003fb0 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003fac:	2c dd       	sub	sp,-204
80003fae:	d8 02       	popm	pc
80003fb0:	80 00       	ld.sh	r0,r0[0x0]
80003fb2:	3e a0       	mov	r0,-22

80003fb4 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003fb4:	d4 01       	pushm	lr
80003fb6:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003fba:	fe 78 80 00 	mov	r8,-32768
80003fbe:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003fc0:	30 38       	mov	r8,3
80003fc2:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80003fc4:	30 1b       	mov	r11,1
80003fc6:	fa cc ff fe 	sub	r12,sp,-2
80003fca:	f0 1f 00 03 	mcall	80003fd4 <xcmp_opcode_not_supported+0x20>
}
80003fce:	2c dd       	sub	sp,-204
80003fd0:	d8 02       	popm	pc
80003fd2:	00 00       	add	r0,r0
80003fd4:	80 00       	ld.sh	r0,r0[0x0]
80003fd6:	3e a0       	mov	r0,-22

80003fd8 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80003fd8:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80003fda:	96 88       	ld.uh	r8,r11[0x0]
80003fdc:	e2 18 f0 00 	andl	r8,0xf000,COH
80003fe0:	e0 48 80 00 	cp.w	r8,32768
80003fe4:	c0 f0       	breq	80004002 <xcmp_exec_func+0x2a>
80003fe6:	e0 48 b0 00 	cp.w	r8,45056
80003fea:	c1 20       	breq	8000400e <xcmp_exec_func+0x36>
80003fec:	58 08       	cp.w	r8,0
80003fee:	c1 51       	brne	80004018 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80003ff0:	78 08       	ld.w	r8,r12[0x0]
80003ff2:	58 08       	cp.w	r8,0
80003ff4:	c0 40       	breq	80003ffc <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80003ff6:	16 9c       	mov	r12,r11
80003ff8:	5d 18       	icall	r8
80003ffa:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80003ffc:	f0 1f 00 08 	mcall	8000401c <xcmp_exec_func+0x44>
80004000:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80004002:	78 18       	ld.w	r8,r12[0x4]
80004004:	58 08       	cp.w	r8,0
80004006:	c0 90       	breq	80004018 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004008:	16 9c       	mov	r12,r11
8000400a:	5d 18       	icall	r8
8000400c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
8000400e:	78 28       	ld.w	r8,r12[0x8]
80004010:	58 08       	cp.w	r8,0
80004012:	c0 30       	breq	80004018 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004014:	16 9c       	mov	r12,r11
80004016:	5d 18       	icall	r8
80004018:	d8 02       	popm	pc
8000401a:	00 00       	add	r0,r0
8000401c:	80 00       	ld.sh	r0,r0[0x0]
8000401e:	3f b4       	mov	r4,-5

80004020 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80004020:	d4 01       	pushm	lr
80004022:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80004026:	e0 68 04 09 	mov	r8,1033
8000402a:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
8000402c:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80004030:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
80004032:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
80004036:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80004038:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
8000403a:	30 09       	mov	r9,0
8000403c:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
8000403e:	fb 69 00 08 	st.b	sp[8],r9
80004042:	fa c8 ff f7 	sub	r8,sp,-9
80004046:	b0 89       	st.b	r8[0x0],r9
80004048:	fa c8 ff f6 	sub	r8,sp,-10
8000404c:	b0 89       	st.b	r8[0x0],r9
8000404e:	fa c8 ff f5 	sub	r8,sp,-11
80004052:	b0 89       	st.b	r8[0x0],r9
80004054:	fa c8 ff f4 	sub	r8,sp,-12
80004058:	b0 89       	st.b	r8[0x0],r9
8000405a:	fa c8 ff f3 	sub	r8,sp,-13
8000405e:	b0 89       	st.b	r8[0x0],r9
80004060:	fa c8 ff f2 	sub	r8,sp,-14
80004064:	b0 89       	st.b	r8[0x0],r9
80004066:	fa c8 ff f1 	sub	r8,sp,-15
8000406a:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
8000406c:	30 cb       	mov	r11,12
8000406e:	fa cc ff fe 	sub	r12,sp,-2
80004072:	f0 1f 00 03 	mcall	8000407c <xcmp_IdleTestTone+0x5c>
}
80004076:	2c dd       	sub	sp,-204
80004078:	d8 02       	popm	pc
8000407a:	00 00       	add	r0,r0
8000407c:	80 00       	ld.sh	r0,r0[0x0]
8000407e:	3e a0       	mov	r0,-22

80004080 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80004080:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80004082:	48 dc       	lddpc	r12,800040b4 <xcmp_init+0x34>
80004084:	f0 1f 00 0d 	mcall	800040b8 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004088:	30 4b       	mov	r11,4
8000408a:	31 4c       	mov	r12,20
8000408c:	f0 1f 00 0c 	mcall	800040bc <xcmp_init+0x3c>
80004090:	48 c8       	lddpc	r8,800040c0 <xcmp_init+0x40>
80004092:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80004094:	30 09       	mov	r9,0
80004096:	1a d9       	st.w	--sp,r9
80004098:	1a d9       	st.w	--sp,r9
8000409a:	1a d9       	st.w	--sp,r9
8000409c:	30 38       	mov	r8,3
8000409e:	e0 6a 01 80 	mov	r10,384
800040a2:	48 9b       	lddpc	r11,800040c4 <xcmp_init+0x44>
800040a4:	48 9c       	lddpc	r12,800040c8 <xcmp_init+0x48>
800040a6:	f0 1f 00 0a 	mcall	800040cc <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
800040aa:	f0 1f 00 0a 	mcall	800040d0 <xcmp_init+0x50>
800040ae:	2f dd       	sub	sp,-12
	
}
800040b0:	d8 02       	popm	pc
800040b2:	00 00       	add	r0,r0
800040b4:	80 00       	ld.sh	r0,r0[0x0]
800040b6:	41 d0       	lddsp	r0,sp[0x74]
800040b8:	80 00       	ld.sh	r0,r0[0x0]
800040ba:	42 1c       	lddsp	r12,sp[0x84]
800040bc:	80 00       	ld.sh	r0,r0[0x0]
800040be:	62 34       	ld.w	r4,r1[0xc]
800040c0:	00 00       	add	r0,r0
800040c2:	0a fc       	st.b	--r5,r12
800040c4:	80 00       	ld.sh	r0,r0[0x0]
800040c6:	d5 88       	*unknown*
800040c8:	80 00       	ld.sh	r0,r0[0x0]
800040ca:	40 d4       	lddsp	r4,sp[0x34]
800040cc:	80 00       	ld.sh	r0,r0[0x0]
800040ce:	69 50       	ld.w	r0,r4[0x54]
800040d0:	80 00       	ld.sh	r0,r0[0x0]
800040d2:	42 54       	lddsp	r4,sp[0x94]

800040d4 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
800040d4:	d4 31       	pushm	r0-r7,lr
800040d6:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800040d8:	4b 16       	lddpc	r6,8000419c <xcmp_rx_process+0xc8>
800040da:	30 05       	mov	r5,0
800040dc:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800040de:	4b 13       	lddpc	r3,800041a0 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800040e0:	4b 12       	lddpc	r2,800041a4 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800040e2:	4b 21       	lddpc	r1,800041a8 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800040e4:	4b 20       	lddpc	r0,800041ac <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800040e6:	6c 0c       	ld.w	r12,r6[0x0]
800040e8:	0a 99       	mov	r9,r5
800040ea:	08 9a       	mov	r10,r4
800040ec:	1a 9b       	mov	r11,sp
800040ee:	f0 1f 00 31 	mcall	800041b0 <xcmp_rx_process+0xdc>
800040f2:	58 1c       	cp.w	r12,1
800040f4:	cf 91       	brne	800040e6 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
800040f6:	40 0b       	lddsp	r11,sp[0x0]
800040f8:	58 0b       	cp.w	r11,0
800040fa:	cf 60       	breq	800040e6 <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
800040fc:	96 0a       	ld.sh	r10,r11[0x0]
800040fe:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004102:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80004106:	59 c8       	cp.w	r8,28
80004108:	c1 e0       	breq	80004144 <xcmp_rx_process+0x70>
8000410a:	e0 89 00 07 	brgt	80004118 <xcmp_rx_process+0x44>
8000410e:	58 e8       	cp.w	r8,14
80004110:	c0 e0       	breq	8000412c <xcmp_rx_process+0x58>
80004112:	58 f8       	cp.w	r8,15
80004114:	c2 41       	brne	8000415c <xcmp_rx_process+0x88>
80004116:	c0 f8       	rjmp	80004134 <xcmp_rx_process+0x60>
80004118:	e0 48 01 09 	cp.w	r8,265
8000411c:	c1 80       	breq	8000414c <xcmp_rx_process+0x78>
8000411e:	e0 48 01 0a 	cp.w	r8,266
80004122:	c1 90       	breq	80004154 <xcmp_rx_process+0x80>
80004124:	e0 48 00 2c 	cp.w	r8,44
80004128:	c1 a1       	brne	8000415c <xcmp_rx_process+0x88>
8000412a:	c0 98       	rjmp	8000413c <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
8000412c:	4a 2c       	lddpc	r12,800041b4 <xcmp_rx_process+0xe0>
8000412e:	f0 1f 00 23 	mcall	800041b8 <xcmp_rx_process+0xe4>
					break;
80004132:	c2 f8       	rjmp	80004190 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004134:	4a 2c       	lddpc	r12,800041bc <xcmp_rx_process+0xe8>
80004136:	f0 1f 00 21 	mcall	800041b8 <xcmp_rx_process+0xe4>
					break;
8000413a:	c2 b8       	rjmp	80004190 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
8000413c:	4a 1c       	lddpc	r12,800041c0 <xcmp_rx_process+0xec>
8000413e:	f0 1f 00 1f 	mcall	800041b8 <xcmp_rx_process+0xe4>
					break;
80004142:	c2 78       	rjmp	80004190 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004144:	04 9c       	mov	r12,r2
80004146:	f0 1f 00 1d 	mcall	800041b8 <xcmp_rx_process+0xe4>
						, ptr);
					break;
8000414a:	c2 38       	rjmp	80004190 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000414c:	02 9c       	mov	r12,r1
8000414e:	f0 1f 00 1b 	mcall	800041b8 <xcmp_rx_process+0xe4>
					break;
80004152:	c1 f8       	rjmp	80004190 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004154:	00 9c       	mov	r12,r0
80004156:	f0 1f 00 19 	mcall	800041b8 <xcmp_rx_process+0xe4>
					break;
8000415a:	c1 b8       	rjmp	80004190 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
8000415c:	12 98       	mov	r8,r9
8000415e:	e2 18 04 00 	andl	r8,0x400,COH
80004162:	c0 70       	breq	80004170 <xcmp_rx_process+0x9c>
80004164:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004168:	e0 48 00 68 	cp.w	r8,104
8000416c:	e0 8a 00 08 	brle	8000417c <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004170:	e2 19 f0 00 	andl	r9,0xf000,COH
80004174:	c0 e1       	brne	80004190 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80004176:	f0 1f 00 14 	mcall	800041c4 <xcmp_rx_process+0xf0>
8000417a:	c0 b8       	rjmp	80004190 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
8000417c:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80004180:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80004184:	49 19       	lddpc	r9,800041c8 <xcmp_rx_process+0xf4>
80004186:	72 08       	ld.w	r8,r9[0x0]
80004188:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000418c:	f0 1f 00 0b 	mcall	800041b8 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004190:	66 0c       	ld.w	r12,r3[0x0]
80004192:	40 0b       	lddsp	r11,sp[0x0]
80004194:	f0 1f 00 0e 	mcall	800041cc <xcmp_rx_process+0xf8>
80004198:	ca 7b       	rjmp	800040e6 <xcmp_rx_process+0x12>
8000419a:	00 00       	add	r0,r0
8000419c:	00 00       	add	r0,r0
8000419e:	0a fc       	st.b	--r5,r12
800041a0:	00 00       	add	r0,r0
800041a2:	0a b4       	st.h	r5++,r4
800041a4:	00 00       	add	r0,r0
800041a6:	0b 0c       	ld.w	r12,r5++
800041a8:	00 00       	add	r0,r0
800041aa:	0b 00       	ld.w	r0,r5++
800041ac:	00 00       	add	r0,r0
800041ae:	0a f0       	st.b	--r5,r0
800041b0:	80 00       	ld.sh	r0,r0[0x0]
800041b2:	5f 28       	srhs	r8
800041b4:	00 00       	add	r0,r0
800041b6:	0b 24       	ld.uh	r4,r5++
800041b8:	80 00       	ld.sh	r0,r0[0x0]
800041ba:	3f d8       	mov	r8,-3
800041bc:	00 00       	add	r0,r0
800041be:	0a e4       	st.h	--r5,r4
800041c0:	00 00       	add	r0,r0
800041c2:	0b 18       	ld.sh	r8,r5++
800041c4:	80 00       	ld.sh	r0,r0[0x0]
800041c6:	3f b4       	mov	r4,-5
800041c8:	00 00       	add	r0,r0
800041ca:	50 fc       	stdsp	sp[0x3c],r12
800041cc:	80 00       	ld.sh	r0,r0[0x0]
800041ce:	2b 6c       	sub	r12,-74

800041d0 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800041d0:	eb cd 40 90 	pushm	r4,r7,lr
800041d4:	20 1d       	sub	sp,4
800041d6:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800041da:	48 c8       	lddpc	r8,80004208 <xcmp_rx+0x38>
800041dc:	70 0c       	ld.w	r12,r8[0x0]
800041de:	f0 1f 00 0c 	mcall	8000420c <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
800041e2:	c1 00       	breq	80004202 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800041e4:	fa c7 ff fc 	sub	r7,sp,-4
800041e8:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
800041ea:	e0 6a 00 ca 	mov	r10,202
800041ee:	08 9b       	mov	r11,r4
800041f0:	f0 1f 00 08 	mcall	80004210 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
800041f4:	48 88       	lddpc	r8,80004214 <xcmp_rx+0x44>
800041f6:	70 0c       	ld.w	r12,r8[0x0]
800041f8:	30 09       	mov	r9,0
800041fa:	12 9a       	mov	r10,r9
800041fc:	1a 9b       	mov	r11,sp
800041fe:	f0 1f 00 07 	mcall	80004218 <xcmp_rx+0x48>
	}	
}
80004202:	2f fd       	sub	sp,-4
80004204:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004208:	00 00       	add	r0,r0
8000420a:	0a b4       	st.h	r5++,r4
8000420c:	80 00       	ld.sh	r0,r0[0x0]
8000420e:	2d 18       	sub	r8,-47
80004210:	80 00       	ld.sh	r0,r0[0x0]
80004212:	75 94       	ld.w	r4,r10[0x64]
80004214:	00 00       	add	r0,r0
80004216:	0a fc       	st.b	--r5,r12
80004218:	80 00       	ld.sh	r0,r0[0x0]
8000421a:	61 34       	ld.w	r4,r0[0x4c]

8000421c <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
8000421c:	48 28       	lddpc	r8,80004224 <xnl_register_xcmp_func+0x8>
8000421e:	91 0c       	st.w	r8[0x0],r12
}
80004220:	5e fc       	retal	r12
80004222:	00 00       	add	r0,r0
80004224:	00 00       	add	r0,r0
80004226:	0b 54       	ld.sh	r4,--r5

80004228 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004228:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
8000422a:	48 88       	lddpc	r8,80004248 <xnl_get_msg_ack_func+0x20>
8000422c:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
8000422e:	98 49       	ld.sh	r9,r12[0x8]
80004230:	f0 09 19 00 	cp.h	r9,r8
80004234:	c0 81       	brne	80004244 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80004236:	48 68       	lddpc	r8,8000424c <xnl_get_msg_ack_func+0x24>
80004238:	70 0c       	ld.w	r12,r8[0x0]
8000423a:	30 09       	mov	r9,0
8000423c:	12 9a       	mov	r10,r9
8000423e:	12 9b       	mov	r11,r9
80004240:	f0 1f 00 04 	mcall	80004250 <xnl_get_msg_ack_func+0x28>
80004244:	d8 02       	popm	pc
80004246:	00 00       	add	r0,r0
80004248:	00 00       	add	r0,r0
8000424a:	0b 34       	ld.ub	r4,r5++
8000424c:	00 00       	add	r0,r0
8000424e:	0b 30       	ld.ub	r0,r5++
80004250:	80 00       	ld.sh	r0,r0[0x0]
80004252:	61 34       	ld.w	r4,r0[0x4c]

80004254 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004254:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
80004258:	30 09       	mov	r9,0
8000425a:	4b 78       	lddpc	r8,80004334 <xnl_init+0xe0>
8000425c:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
8000425e:	30 0b       	mov	r11,0
80004260:	30 1c       	mov	r12,1
80004262:	f0 1f 00 36 	mcall	80004338 <xnl_init+0xe4>
80004266:	4b 68       	lddpc	r8,8000433c <xnl_init+0xe8>
80004268:	91 0c       	st.w	r8[0x0],r12
8000426a:	70 08       	ld.w	r8,r8[0x0]
8000426c:	58 08       	cp.w	r8,0
8000426e:	c0 80       	breq	8000427e <xnl_init+0x2a>
80004270:	4b 38       	lddpc	r8,8000433c <xnl_init+0xe8>
80004272:	70 0c       	ld.w	r12,r8[0x0]
80004274:	30 09       	mov	r9,0
80004276:	12 9a       	mov	r10,r9
80004278:	12 9b       	mov	r11,r9
8000427a:	f0 1f 00 32 	mcall	80004340 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
8000427e:	30 4b       	mov	r11,4
80004280:	31 4c       	mov	r12,20
80004282:	f0 1f 00 2e 	mcall	80004338 <xnl_init+0xe4>
80004286:	4b 08       	lddpc	r8,80004344 <xnl_init+0xf0>
80004288:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
8000428a:	30 4b       	mov	r11,4
8000428c:	31 ec       	mov	r12,30
8000428e:	f0 1f 00 2b 	mcall	80004338 <xnl_init+0xe4>
80004292:	4a e8       	lddpc	r8,80004348 <xnl_init+0xf4>
80004294:	91 0c       	st.w	r8[0x0],r12
80004296:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004298:	10 96       	mov	r6,r8
8000429a:	4a d5       	lddpc	r5,8000434c <xnl_init+0xf8>
8000429c:	6c 0c       	ld.w	r12,r6[0x0]
8000429e:	ea 07 00 0b 	add	r11,r5,r7
800042a2:	f0 1f 00 2c 	mcall	80004350 <xnl_init+0xfc>
800042a6:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
800042aa:	e0 47 1e 00 	cp.w	r7,7680
800042ae:	cf 71       	brne	8000429c <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800042b0:	30 4b       	mov	r11,4
800042b2:	31 4c       	mov	r12,20
800042b4:	f0 1f 00 21 	mcall	80004338 <xnl_init+0xe4>
800042b8:	4a 78       	lddpc	r8,80004354 <xnl_init+0x100>
800042ba:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800042bc:	30 4b       	mov	r11,4
800042be:	30 ac       	mov	r12,10
800042c0:	f0 1f 00 1e 	mcall	80004338 <xnl_init+0xe4>
800042c4:	4a 58       	lddpc	r8,80004358 <xnl_init+0x104>
800042c6:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
800042c8:	30 4b       	mov	r11,4
800042ca:	30 ac       	mov	r12,10
800042cc:	f0 1f 00 1b 	mcall	80004338 <xnl_init+0xe4>
800042d0:	4a 38       	lddpc	r8,8000435c <xnl_init+0x108>
800042d2:	91 0c       	st.w	r8[0x0],r12
800042d4:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
800042d6:	10 96       	mov	r6,r8
800042d8:	4a 25       	lddpc	r5,80004360 <xnl_init+0x10c>
800042da:	6c 0c       	ld.w	r12,r6[0x0]
800042dc:	ea 07 00 0b 	add	r11,r5,r7
800042e0:	f0 1f 00 1c 	mcall	80004350 <xnl_init+0xfc>
800042e4:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
800042e8:	e0 47 14 00 	cp.w	r7,5120
800042ec:	cf 71       	brne	800042da <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
800042ee:	30 4b       	mov	r11,4
800042f0:	30 5c       	mov	r12,5
800042f2:	f0 1f 00 12 	mcall	80004338 <xnl_init+0xe4>
800042f6:	49 c8       	lddpc	r8,80004364 <xnl_init+0x110>
800042f8:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800042fa:	30 07       	mov	r7,0
800042fc:	1a d7       	st.w	--sp,r7
800042fe:	1a d7       	st.w	--sp,r7
80004300:	1a d7       	st.w	--sp,r7
80004302:	30 38       	mov	r8,3
80004304:	0e 99       	mov	r9,r7
80004306:	e0 6a 02 00 	mov	r10,512
8000430a:	49 8b       	lddpc	r11,80004368 <xnl_init+0x114>
8000430c:	49 8c       	lddpc	r12,8000436c <xnl_init+0x118>
8000430e:	f0 1f 00 19 	mcall	80004370 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004312:	1a d7       	st.w	--sp,r7
80004314:	1a d7       	st.w	--sp,r7
80004316:	1a d7       	st.w	--sp,r7
80004318:	30 38       	mov	r8,3
8000431a:	0e 99       	mov	r9,r7
8000431c:	e0 6a 03 20 	mov	r10,800
80004320:	49 5b       	lddpc	r11,80004374 <xnl_init+0x120>
80004322:	49 6c       	lddpc	r12,80004378 <xnl_init+0x124>
80004324:	f0 1f 00 13 	mcall	80004370 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004328:	f0 1f 00 15 	mcall	8000437c <xnl_init+0x128>
8000432c:	2f ad       	sub	sp,-24
}
8000432e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004332:	00 00       	add	r0,r0
80004334:	00 00       	add	r0,r0
80004336:	0b 34       	ld.ub	r4,r5++
80004338:	80 00       	ld.sh	r0,r0[0x0]
8000433a:	62 34       	ld.w	r4,r1[0xc]
8000433c:	00 00       	add	r0,r0
8000433e:	0b 30       	ld.ub	r0,r5++
80004340:	80 00       	ld.sh	r0,r0[0x0]
80004342:	61 34       	ld.w	r4,r0[0x4c]
80004344:	00 00       	add	r0,r0
80004346:	0b 40       	ld.w	r0,--r5
80004348:	00 00       	add	r0,r0
8000434a:	0a b4       	st.h	r5++,r4
8000434c:	00 00       	add	r0,r0
8000434e:	32 ae       	mov	lr,42
80004350:	80 00       	ld.sh	r0,r0[0x0]
80004352:	2b 6c       	sub	r12,-74
80004354:	00 00       	add	r0,r0
80004356:	0a c4       	st.b	r5++,r4
80004358:	00 00       	add	r0,r0
8000435a:	0a b8       	st.h	r5++,r8
8000435c:	00 00       	add	r0,r0
8000435e:	0a 70       	tst	r0,r5
80004360:	00 00       	add	r0,r0
80004362:	1e ae       	st.w	pc++,lr
80004364:	00 00       	add	r0,r0
80004366:	0a 8c       	andn	r12,r5
80004368:	80 00       	ld.sh	r0,r0[0x0]
8000436a:	d5 90       	acall	0x59
8000436c:	80 00       	ld.sh	r0,r0[0x0]
8000436e:	43 80       	lddsp	r0,sp[0xe0]
80004370:	80 00       	ld.sh	r0,r0[0x0]
80004372:	69 50       	ld.w	r0,r4[0x54]
80004374:	80 00       	ld.sh	r0,r0[0x0]
80004376:	ce 00       	breq	80004336 <xnl_init+0xe2>
80004378:	80 00       	ld.sh	r0,r0[0x0]
8000437a:	43 e0       	lddsp	r0,sp[0xf8]
8000437c:	80 00       	ld.sh	r0,r0[0x0]
8000437e:	2d 40       	sub	r0,-44

80004380 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80004380:	eb cd 40 fe 	pushm	r1-r7,lr
80004384:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004386:	49 26       	lddpc	r6,800043cc <xnl_rx_process+0x4c>
80004388:	30 05       	mov	r5,0
8000438a:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
8000438c:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000438e:	49 11       	lddpc	r1,800043d0 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004390:	49 12       	lddpc	r2,800043d4 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004392:	6c 0c       	ld.w	r12,r6[0x0]
80004394:	0a 99       	mov	r9,r5
80004396:	08 9a       	mov	r10,r4
80004398:	1a 9b       	mov	r11,sp
8000439a:	f0 1f 00 10 	mcall	800043d8 <xnl_rx_process+0x58>
8000439e:	58 1c       	cp.w	r12,1
800043a0:	cf 91       	brne	80004392 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
800043a2:	40 0c       	lddsp	r12,sp[0x0]
800043a4:	58 0c       	cp.w	r12,0
800043a6:	cf 60       	breq	80004392 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800043a8:	98 28       	ld.sh	r8,r12[0x4]
800043aa:	e6 08 19 00 	cp.h	r8,r3
800043ae:	e0 8b 00 0a 	brhi	800043c2 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800043b2:	5c 78       	castu.h	r8
800043b4:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
800043b8:	58 09       	cp.w	r9,0
800043ba:	c0 40       	breq	800043c2 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
800043bc:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
800043c0:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800043c2:	62 0c       	ld.w	r12,r1[0x0]
800043c4:	40 0b       	lddsp	r11,sp[0x0]
800043c6:	f0 1f 00 06 	mcall	800043dc <xnl_rx_process+0x5c>
800043ca:	ce 4b       	rjmp	80004392 <xnl_rx_process+0x12>
800043cc:	00 00       	add	r0,r0
800043ce:	0a b8       	st.h	r5++,r8
800043d0:	00 00       	add	r0,r0
800043d2:	0a b4       	st.h	r5++,r4
800043d4:	00 00       	add	r0,r0
800043d6:	04 f4       	st.b	--r2,r4
800043d8:	80 00       	ld.sh	r0,r0[0x0]
800043da:	5f 28       	srhs	r8
800043dc:	80 00       	ld.sh	r0,r0[0x0]
800043de:	2b 6c       	sub	r12,-74

800043e0 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
800043e0:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
800043e2:	4a a6       	lddpc	r6,80004488 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800043e4:	4a a2       	lddpc	r2,8000448c <xnl_tx_process+0xac>
800043e6:	4a b4       	lddpc	r4,80004490 <xnl_tx_process+0xb0>
800043e8:	30 07       	mov	r7,0
800043ea:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800043ec:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
800043ee:	4a a5       	lddpc	r5,80004494 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800043f0:	4a a3       	lddpc	r3,80004498 <xnl_tx_process+0xb8>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
800043f2:	6c 08       	ld.w	r8,r6[0x0]
800043f4:	58 08       	cp.w	r8,0
800043f6:	c0 40       	breq	800043fe <xnl_tx_process+0x1e>
800043f8:	58 18       	cp.w	r8,1
800043fa:	cf d1       	brne	800043f4 <xnl_tx_process+0x14>
800043fc:	c2 48       	rjmp	80004444 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800043fe:	64 0c       	ld.w	r12,r2[0x0]
80004400:	0e 99       	mov	r9,r7
80004402:	02 9a       	mov	r10,r1
80004404:	08 9b       	mov	r11,r4
80004406:	f0 1f 00 26 	mcall	8000449c <xnl_tx_process+0xbc>
8000440a:	58 1c       	cp.w	r12,1
8000440c:	cf 31       	brne	800043f2 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
8000440e:	68 0b       	ld.w	r11,r4[0x0]
80004410:	58 0b       	cp.w	r11,0
80004412:	cf 00       	breq	800043f2 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004414:	96 28       	ld.sh	r8,r11[0x4]
80004416:	e0 08 19 00 	cp.h	r8,r0
8000441a:	c0 71       	brne	80004428 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
8000441c:	4a 18       	lddpc	r8,800044a0 <xnl_tx_process+0xc0>
8000441e:	70 08       	ld.w	r8,r8[0x0]
80004420:	10 9c       	mov	r12,r8
80004422:	f0 1f 00 21 	mcall	800044a4 <xnl_tx_process+0xc4>
						break;
80004426:	ce 6b       	rjmp	800043f2 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004428:	16 9c       	mov	r12,r11
8000442a:	f0 1f 00 20 	mcall	800044a8 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000442e:	30 18       	mov	r8,1
80004430:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004432:	66 0c       	ld.w	r12,r3[0x0]
80004434:	0e 99       	mov	r9,r7
80004436:	0e 9a       	mov	r10,r7
80004438:	0e 9b       	mov	r11,r7
8000443a:	f0 1f 00 19 	mcall	8000449c <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
8000443e:	30 18       	mov	r8,1
80004440:	8d 08       	st.w	r6[0x0],r8
80004442:	cd 8b       	rjmp	800043f2 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004444:	66 0c       	ld.w	r12,r3[0x0]
80004446:	0e 99       	mov	r9,r7
80004448:	36 4a       	mov	r10,100
8000444a:	0e 9b       	mov	r11,r7
8000444c:	f0 1f 00 14 	mcall	8000449c <xnl_tx_process+0xbc>
80004450:	58 1c       	cp.w	r12,1
80004452:	c0 81       	brne	80004462 <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
80004454:	49 38       	lddpc	r8,800044a0 <xnl_tx_process+0xc0>
80004456:	70 0c       	ld.w	r12,r8[0x0]
80004458:	68 0b       	ld.w	r11,r4[0x0]
8000445a:	f0 1f 00 13 	mcall	800044a4 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
8000445e:	8d 07       	st.w	r6[0x0],r7
80004460:	cc 9b       	rjmp	800043f2 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004462:	6a 08       	ld.w	r8,r5[0x0]
80004464:	58 38       	cp.w	r8,3
80004466:	e0 89 00 09 	brgt	80004478 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
8000446a:	68 0c       	ld.w	r12,r4[0x0]
8000446c:	f0 1f 00 0f 	mcall	800044a8 <xnl_tx_process+0xc8>
						xnl_send_times++;
80004470:	6a 08       	ld.w	r8,r5[0x0]
80004472:	2f f8       	sub	r8,-1
80004474:	8b 08       	st.w	r5[0x0],r8
80004476:	cb eb       	rjmp	800043f2 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004478:	48 a8       	lddpc	r8,800044a0 <xnl_tx_process+0xc0>
8000447a:	70 0c       	ld.w	r12,r8[0x0]
8000447c:	68 0b       	ld.w	r11,r4[0x0]
8000447e:	f0 1f 00 0a 	mcall	800044a4 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80004482:	8d 07       	st.w	r6[0x0],r7
80004484:	cb 7b       	rjmp	800043f2 <xnl_tx_process+0x12>
80004486:	00 00       	add	r0,r0
80004488:	00 00       	add	r0,r0
8000448a:	0b 50       	ld.sh	r0,--r5
8000448c:	00 00       	add	r0,r0
8000448e:	0b 40       	ld.w	r0,--r5
80004490:	00 00       	add	r0,r0
80004492:	0b 48       	ld.w	r8,--r5
80004494:	00 00       	add	r0,r0
80004496:	0b 44       	ld.w	r4,--r5
80004498:	00 00       	add	r0,r0
8000449a:	0b 30       	ld.ub	r0,r5++
8000449c:	80 00       	ld.sh	r0,r0[0x0]
8000449e:	5f 28       	srhs	r8
800044a0:	00 00       	add	r0,r0
800044a2:	0a b4       	st.h	r5++,r4
800044a4:	80 00       	ld.sh	r0,r0[0x0]
800044a6:	2b 6c       	sub	r12,-74
800044a8:	80 00       	ld.sh	r0,r0[0x0]
800044aa:	2b 8c       	sub	r12,-72

800044ac <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800044ac:	eb cd 40 c0 	pushm	r6-r7,lr
800044b0:	20 1d       	sub	sp,4
800044b2:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800044b4:	98 39       	ld.sh	r9,r12[0x6]
800044b6:	3f f8       	mov	r8,-1
800044b8:	f0 09 19 00 	cp.h	r9,r8
800044bc:	c0 a1       	brne	800044d0 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800044be:	4a e9       	lddpc	r9,80004574 <xnl_tx+0xc8>
800044c0:	13 88       	ld.ub	r8,r9[0x0]
800044c2:	2f f8       	sub	r8,-1
800044c4:	5c 58       	castu.b	r8
800044c6:	b2 88       	st.b	r9[0x0],r8
800044c8:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800044cc:	a9 a8       	sbr	r8,0x8
800044ce:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800044d0:	8c 49       	ld.sh	r9,r6[0x8]
800044d2:	3f f8       	mov	r8,-1
800044d4:	f0 09 19 00 	cp.h	r9,r8
800044d8:	c0 41       	brne	800044e0 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800044da:	4a 88       	lddpc	r8,80004578 <xnl_tx+0xcc>
800044dc:	90 18       	ld.sh	r8,r8[0x2]
800044de:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800044e0:	8c 59       	ld.sh	r9,r6[0xa]
800044e2:	3f f8       	mov	r8,-1
800044e4:	f0 09 19 00 	cp.h	r9,r8
800044e8:	c0 41       	brne	800044f0 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800044ea:	4a 48       	lddpc	r8,80004578 <xnl_tx+0xcc>
800044ec:	90 28       	ld.sh	r8,r8[0x4]
800044ee:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
800044f0:	8c 69       	ld.sh	r9,r6[0xc]
800044f2:	3f f8       	mov	r8,-1
800044f4:	f0 09 19 00 	cp.h	r9,r8
800044f8:	c0 e1       	brne	80004514 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
800044fa:	4a 08       	lddpc	r8,80004578 <xnl_tx+0xcc>
800044fc:	90 49       	ld.sh	r9,r8[0x8]
800044fe:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004500:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004502:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004504:	90 49       	ld.sh	r9,r8[0x8]
80004506:	e0 19 ff 00 	andl	r9,0xff00
8000450a:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
8000450e:	f3 e8 10 08 	or	r8,r9,r8
80004512:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004514:	0d 98       	ld.ub	r8,r6[0x1]
80004516:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004518:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000451c:	10 0c       	add	r12,r8
8000451e:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004520:	58 0c       	cp.w	r12,0
80004522:	e0 89 00 04 	brgt	8000452a <xnl_tx+0x7e>
80004526:	30 09       	mov	r9,0
80004528:	c0 d8       	rjmp	80004542 <xnl_tx+0x96>
8000452a:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
8000452e:	2f ec       	sub	r12,-2
80004530:	30 09       	mov	r9,0
80004532:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004534:	15 1b       	ld.sh	r11,r10++
80004536:	f6 09 00 09 	add	r9,r11,r9
8000453a:	5c 89       	casts.h	r9
		indextohWord     += 1;
8000453c:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000453e:	18 38       	cp.w	r8,r12
80004540:	cf a1       	brne	80004534 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004542:	5c 39       	neg	r9
80004544:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004546:	48 e8       	lddpc	r8,8000457c <xnl_tx+0xd0>
80004548:	70 0c       	ld.w	r12,r8[0x0]
8000454a:	f0 1f 00 0e 	mcall	80004580 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
8000454e:	c1 00       	breq	8000456e <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004550:	fa c7 ff fc 	sub	r7,sp,-4
80004554:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80004556:	e0 6a 01 00 	mov	r10,256
8000455a:	0c 9b       	mov	r11,r6
8000455c:	f0 1f 00 0a 	mcall	80004584 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004560:	48 a8       	lddpc	r8,80004588 <xnl_tx+0xdc>
80004562:	70 0c       	ld.w	r12,r8[0x0]
80004564:	30 09       	mov	r9,0
80004566:	12 9a       	mov	r10,r9
80004568:	1a 9b       	mov	r11,sp
8000456a:	f0 1f 00 09 	mcall	8000458c <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
8000456e:	2f fd       	sub	sp,-4
80004570:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004574:	00 00       	add	r0,r0
80004576:	0b 4c       	ld.w	r12,--r5
80004578:	00 00       	add	r0,r0
8000457a:	0b 34       	ld.ub	r4,r5++
8000457c:	00 00       	add	r0,r0
8000457e:	0a b4       	st.h	r5++,r4
80004580:	80 00       	ld.sh	r0,r0[0x0]
80004582:	2d 18       	sub	r8,-47
80004584:	80 00       	ld.sh	r0,r0[0x0]
80004586:	75 94       	ld.w	r4,r10[0x64]
80004588:	00 00       	add	r0,r0
8000458a:	0b 40       	ld.w	r0,--r5
8000458c:	80 00       	ld.sh	r0,r0[0x0]
8000458e:	61 34       	ld.w	r4,r0[0x4c]

80004590 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004590:	eb cd 40 80 	pushm	r7,lr
80004594:	fa cd 01 00 	sub	sp,sp,256
80004598:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000459a:	e0 68 40 0e 	mov	r8,16398
8000459e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800045a0:	3f f8       	mov	r8,-1
800045a2:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
800045a4:	30 c8       	mov	r8,12
800045a6:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
800045a8:	98 38       	ld.sh	r8,r12[0x6]
800045aa:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
800045ac:	98 58       	ld.sh	r8,r12[0xa]
800045ae:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
800045b0:	98 48       	ld.sh	r8,r12[0x8]
800045b2:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
800045b4:	98 68       	ld.sh	r8,r12[0xc]
800045b6:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
800045b8:	30 08       	mov	r8,0
800045ba:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800045bc:	1a 9c       	mov	r12,sp
800045be:	f0 1f 00 0a 	mcall	800045e4 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
800045c2:	fa cd 00 cc 	sub	sp,sp,204
800045c6:	e0 6a 00 ca 	mov	r10,202
800045ca:	ee cb ff f0 	sub	r11,r7,-16
800045ce:	1a 9c       	mov	r12,sp
800045d0:	f0 1f 00 06 	mcall	800045e8 <xnl_data_msg_func+0x58>
800045d4:	48 68       	lddpc	r8,800045ec <xnl_data_msg_func+0x5c>
800045d6:	70 08       	ld.w	r8,r8[0x0]
800045d8:	5d 18       	icall	r8
800045da:	fa cd ff 34 	sub	sp,sp,-204
}
800045de:	2c 0d       	sub	sp,-256
800045e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800045e4:	80 00       	ld.sh	r0,r0[0x0]
800045e6:	44 ac       	lddsp	r12,sp[0x128]
800045e8:	80 00       	ld.sh	r0,r0[0x0]
800045ea:	75 94       	ld.w	r4,r10[0x64]
800045ec:	00 00       	add	r0,r0
800045ee:	0b 54       	ld.sh	r4,--r5

800045f0 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
800045f0:	d4 21       	pushm	r4-r7,lr
800045f2:	fa cd 01 00 	sub	sp,sp,256
800045f6:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
800045f8:	4c 28       	lddpc	r8,80004700 <xnl_device_auth_reply_func+0x110>
800045fa:	11 88       	ld.ub	r8,r8[0x0]
800045fc:	58 08       	cp.w	r8,0
800045fe:	e0 81 00 7f 	brne	800046fc <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004602:	4c 18       	lddpc	r8,80004704 <xnl_device_auth_reply_func+0x114>
80004604:	70 0c       	ld.w	r12,r8[0x0]
80004606:	30 09       	mov	r9,0
80004608:	12 9a       	mov	r10,r9
8000460a:	12 9b       	mov	r11,r9
8000460c:	f0 1f 00 3f 	mcall	80004708 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004610:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004614:	4b b8       	lddpc	r8,80004700 <xnl_device_auth_reply_func+0x110>
80004616:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004618:	ef 39 00 12 	ld.ub	r9,r7[18]
8000461c:	ef 38 00 13 	ld.ub	r8,r7[19]
80004620:	b1 68       	lsl	r8,0x10
80004622:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004626:	ef 38 00 15 	ld.ub	r8,r7[21]
8000462a:	f3 e8 10 08 	or	r8,r9,r8
8000462e:	ef 39 00 14 	ld.ub	r9,r7[20]
80004632:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004636:	ef 3a 00 16 	ld.ub	r10,r7[22]
8000463a:	ef 38 00 17 	ld.ub	r8,r7[23]
8000463e:	b1 68       	lsl	r8,0x10
80004640:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004644:	ef 38 00 19 	ld.ub	r8,r7[25]
80004648:	f5 e8 10 08 	or	r8,r10,r8
8000464c:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004650:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004654:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004656:	e0 64 79 b9 	mov	r4,31161
8000465a:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
8000465e:	e0 65 45 07 	mov	r5,17671
80004662:	ea 15 8a bd 	orh	r5,0x8abd
80004666:	e0 66 f9 3d 	mov	r6,63805
8000466a:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
8000466e:	e0 6e b8 cf 	mov	lr,47311
80004672:	ea 1e 36 83 	orh	lr,0x3683
80004676:	e0 67 aa 1c 	mov	r7,43548
8000467a:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000467e:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004680:	f4 08 00 0c 	add	r12,r10,r8
80004684:	f0 0b 15 04 	lsl	r11,r8,0x4
80004688:	0a 0b       	add	r11,r5
8000468a:	f9 eb 20 0b 	eor	r11,r12,r11
8000468e:	f0 0c 16 05 	lsr	r12,r8,0x5
80004692:	0c 0c       	add	r12,r6
80004694:	18 5b       	eor	r11,r12
80004696:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004698:	f2 0c 15 04 	lsl	r12,r9,0x4
8000469c:	1c 0c       	add	r12,lr
8000469e:	f2 0b 16 05 	lsr	r11,r9,0x5
800046a2:	0e 0b       	add	r11,r7
800046a4:	f9 eb 20 0b 	eor	r11,r12,r11
800046a8:	f2 0a 00 0c 	add	r12,r9,r10
800046ac:	18 5b       	eor	r11,r12
800046ae:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
800046b0:	e0 6b 37 20 	mov	r11,14112
800046b4:	ea 1b c6 ef 	orh	r11,0xc6ef
800046b8:	16 3a       	cp.w	r10,r11
800046ba:	ce 21       	brne	8000467e <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
800046bc:	e0 6a 40 1a 	mov	r10,16410
800046c0:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800046c2:	3f fa       	mov	r10,-1
800046c4:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
800046c6:	30 6b       	mov	r11,6
800046c8:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800046ca:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800046cc:	48 db       	lddpc	r11,80004700 <xnl_device_auth_reply_func+0x110>
800046ce:	96 1c       	ld.sh	r12,r11[0x2]
800046d0:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
800046d2:	96 2b       	ld.sh	r11,r11[0x4]
800046d4:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800046d6:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
800046d8:	30 ca       	mov	r10,12
800046da:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
800046dc:	30 0a       	mov	r10,0
800046de:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
800046e2:	30 7a       	mov	r10,7
800046e4:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
800046e8:	30 2a       	mov	r10,2
800046ea:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800046ee:	fa ca ff ec 	sub	r10,sp,-20
800046f2:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800046f4:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
800046f6:	1a 9c       	mov	r12,sp
800046f8:	f0 1f 00 05 	mcall	8000470c <xnl_device_auth_reply_func+0x11c>
}
800046fc:	2c 0d       	sub	sp,-256
800046fe:	d8 22       	popm	r4-r7,pc
80004700:	00 00       	add	r0,r0
80004702:	0b 34       	ld.ub	r4,r5++
80004704:	00 00       	add	r0,r0
80004706:	0b 30       	ld.ub	r0,r5++
80004708:	80 00       	ld.sh	r0,r0[0x0]
8000470a:	61 34       	ld.w	r4,r0[0x4c]
8000470c:	80 00       	ld.sh	r0,r0[0x0]
8000470e:	44 ac       	lddsp	r12,sp[0x128]

80004710 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004710:	eb cd 40 80 	pushm	r7,lr
80004714:	fa cd 01 00 	sub	sp,sp,256
80004718:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
8000471a:	49 28       	lddpc	r8,80004760 <xnl_master_status_brdcst_func+0x50>
8000471c:	11 88       	ld.ub	r8,r8[0x0]
8000471e:	58 08       	cp.w	r8,0
80004720:	c1 c1       	brne	80004758 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004722:	49 18       	lddpc	r8,80004764 <xnl_master_status_brdcst_func+0x54>
80004724:	70 0c       	ld.w	r12,r8[0x0]
80004726:	30 09       	mov	r9,0
80004728:	12 9a       	mov	r10,r9
8000472a:	12 9b       	mov	r11,r9
8000472c:	f0 1f 00 0f 	mcall	80004768 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004730:	8e 58       	ld.sh	r8,r7[0xa]
80004732:	48 c9       	lddpc	r9,80004760 <xnl_master_status_brdcst_func+0x50>
80004734:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004736:	e0 68 40 0e 	mov	r8,16398
8000473a:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000473c:	3f f8       	mov	r8,-1
8000473e:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004740:	30 4a       	mov	r10,4
80004742:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004744:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004746:	92 19       	ld.sh	r9,r9[0x2]
80004748:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
8000474a:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000474c:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
8000474e:	30 08       	mov	r8,0
80004750:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80004752:	1a 9c       	mov	r12,sp
80004754:	f0 1f 00 06 	mcall	8000476c <xnl_master_status_brdcst_func+0x5c>
}
80004758:	2c 0d       	sub	sp,-256
8000475a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000475e:	00 00       	add	r0,r0
80004760:	00 00       	add	r0,r0
80004762:	0b 34       	ld.ub	r4,r5++
80004764:	00 00       	add	r0,r0
80004766:	0b 30       	ld.ub	r0,r5++
80004768:	80 00       	ld.sh	r0,r0[0x0]
8000476a:	61 34       	ld.w	r4,r0[0x4c]
8000476c:	80 00       	ld.sh	r0,r0[0x0]
8000476e:	44 ac       	lddsp	r12,sp[0x128]

80004770 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004770:	eb cd 40 80 	pushm	r7,lr
80004774:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80004776:	49 28       	lddpc	r8,800047bc <xnl_device_conn_reply_func+0x4c>
80004778:	70 0c       	ld.w	r12,r8[0x0]
8000477a:	30 09       	mov	r9,0
8000477c:	12 9a       	mov	r10,r9
8000477e:	12 9b       	mov	r11,r9
80004780:	f0 1f 00 10 	mcall	800047c0 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80004784:	ef 18 00 10 	ld.uh	r8,r7[16]
80004788:	10 99       	mov	r9,r8
8000478a:	e2 19 ff 00 	andl	r9,0xff00,COH
8000478e:	e0 49 01 00 	cp.w	r9,256
80004792:	c0 60       	breq	8000479e <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80004794:	0e 9c       	mov	r12,r7
80004796:	f0 1f 00 0c 	mcall	800047c4 <xnl_device_conn_reply_func+0x54>
8000479a:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
8000479e:	a9 68       	lsl	r8,0x8
800047a0:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800047a4:	48 98       	lddpc	r8,800047c8 <xnl_device_conn_reply_func+0x58>
800047a6:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
800047a8:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
800047ac:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
800047ae:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
800047b2:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
800047b4:	30 19       	mov	r9,1
800047b6:	b0 89       	st.b	r8[0x0],r9
800047b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800047bc:	00 00       	add	r0,r0
800047be:	0b 30       	ld.ub	r0,r5++
800047c0:	80 00       	ld.sh	r0,r0[0x0]
800047c2:	61 34       	ld.w	r4,r0[0x4c]
800047c4:	80 00       	ld.sh	r0,r0[0x0]
800047c6:	47 10       	lddsp	r0,sp[0x1c4]
800047c8:	00 00       	add	r0,r0
800047ca:	0b 34       	ld.ub	r4,r5++

800047cc <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
800047cc:	d4 01       	pushm	lr
800047ce:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800047d2:	e0 68 40 0e 	mov	r8,16398
800047d6:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800047d8:	3f f8       	mov	r8,-1
800047da:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
800047dc:	30 38       	mov	r8,3
800047de:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
800047e0:	30 08       	mov	r8,0
800047e2:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
800047e4:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
800047e6:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
800047e8:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
800047ea:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800047ec:	1a 9c       	mov	r12,sp
800047ee:	f0 1f 00 03 	mcall	800047f8 <xnl_send_device_master_query+0x2c>
}
800047f2:	2c 0d       	sub	sp,-256
800047f4:	d8 02       	popm	pc
800047f6:	00 00       	add	r0,r0
800047f8:	80 00       	ld.sh	r0,r0[0x0]
800047fa:	44 ac       	lddsp	r12,sp[0x128]

800047fc <RC522_SPI_SetSpeed>:
	SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
800047fc:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
800047fe:	48 78       	lddpc	r8,80004818 <RC522_SPI_SetSpeed+0x1c>
80004800:	70 09       	ld.w	r9,r8[0x0]
80004802:	72 ca       	ld.w	r10,r9[0x30]
80004804:	5c 7c       	castu.h	r12
80004806:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
8000480a:	f9 ea 10 0a 	or	r10,r12,r10
8000480e:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
80004810:	70 0c       	ld.w	r12,r8[0x0]
80004812:	f0 1f 00 03 	mcall	8000481c <RC522_SPI_SetSpeed+0x20>
		
	
}
80004816:	d8 02       	popm	pc
80004818:	00 00       	add	r0,r0
8000481a:	1d 88       	ld.ub	r8,lr[0x0]
8000481c:	80 00       	ld.sh	r0,r0[0x0]
8000481e:	56 24       	stdsp	sp[0x188],r4

80004820 <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
80004820:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0400);//baudDiv=4
80004822:	e0 6c 04 00 	mov	r12,1024
80004826:	f0 1f 00 02 	mcall	8000482c <RC522_SPI_SetSpeedLow+0xc>
	
}
8000482a:	d8 02       	popm	pc
8000482c:	80 00       	ld.sh	r0,r0[0x0]
8000482e:	47 fc       	lddsp	r12,sp[0x1fc]

80004830 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
80004830:	eb cd 40 c0 	pushm	r6-r7,lr
	U16 *Data ;

	//蹇椤昏锋芥ｅ父璇诲
	spi_selectChip(spi, DF_SPI_PCS_0);
80004834:	48 b7       	lddpc	r7,80004860 <RC522_ReadByte+0x30>
80004836:	30 0b       	mov	r11,0
80004838:	6e 0c       	ld.w	r12,r7[0x0]
8000483a:	f0 1f 00 0b 	mcall	80004864 <RC522_ReadByte+0x34>
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
8000483e:	e0 6b 00 ff 	mov	r11,255
80004842:	6e 0c       	ld.w	r12,r7[0x0]
80004844:	f0 1f 00 09 	mcall	80004868 <RC522_ReadByte+0x38>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
80004848:	30 06       	mov	r6,0
8000484a:	0c 9b       	mov	r11,r6
8000484c:	6e 0c       	ld.w	r12,r7[0x0]
8000484e:	f0 1f 00 08 	mcall	8000486c <RC522_ReadByte+0x3c>

	/*!< Return the shifted data */
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004852:	0c 9b       	mov	r11,r6
80004854:	6e 0c       	ld.w	r12,r7[0x0]
80004856:	f0 1f 00 07 	mcall	80004870 <RC522_ReadByte+0x40>
	
	return (U8)(*Data);
	
}
8000485a:	0d 9c       	ld.ub	r12,r6[0x1]
8000485c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004860:	00 00       	add	r0,r0
80004862:	1d 88       	ld.ub	r8,lr[0x0]
80004864:	80 00       	ld.sh	r0,r0[0x0]
80004866:	57 90       	stdsp	sp[0x1e4],r0
80004868:	80 00       	ld.sh	r0,r0[0x0]
8000486a:	56 2a       	stdsp	sp[0x188],r10
8000486c:	80 00       	ld.sh	r0,r0[0x0]
8000486e:	56 46       	stdsp	sp[0x190],r6
80004870:	80 00       	ld.sh	r0,r0[0x0]
80004872:	57 50       	stdsp	sp[0x1d4],r0

80004874 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
80004874:	eb cd 40 c0 	pushm	r6-r7,lr
80004878:	20 1d       	sub	sp,4
8000487a:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	spi_selectChip(spi, DF_SPI_PCS_0);
8000487c:	48 c7       	lddpc	r7,800048ac <RC522_WriteByte+0x38>
8000487e:	30 0b       	mov	r11,0
80004880:	6e 0c       	ld.w	r12,r7[0x0]
80004882:	f0 1f 00 0c 	mcall	800048b0 <RC522_WriteByte+0x3c>
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
80004886:	1b 8b       	ld.ub	r11,sp[0x0]
80004888:	6e 0c       	ld.w	r12,r7[0x0]
8000488a:	f0 1f 00 0b 	mcall	800048b4 <RC522_WriteByte+0x40>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
8000488e:	1a 9b       	mov	r11,sp
80004890:	6e 0c       	ld.w	r12,r7[0x0]
80004892:	f0 1f 00 0a 	mcall	800048b8 <RC522_WriteByte+0x44>
80004896:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004898:	30 0b       	mov	r11,0
8000489a:	6e 0c       	ld.w	r12,r7[0x0]
8000489c:	f0 1f 00 08 	mcall	800048bc <RC522_WriteByte+0x48>
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
800048a0:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
800048a4:	2f fd       	sub	sp,-4
800048a6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800048aa:	00 00       	add	r0,r0
800048ac:	00 00       	add	r0,r0
800048ae:	1d 88       	ld.ub	r8,lr[0x0]
800048b0:	80 00       	ld.sh	r0,r0[0x0]
800048b2:	57 90       	stdsp	sp[0x1e4],r0
800048b4:	80 00       	ld.sh	r0,r0[0x0]
800048b6:	56 2a       	stdsp	sp[0x188],r10
800048b8:	80 00       	ld.sh	r0,r0[0x0]
800048ba:	56 46       	stdsp	sp[0x190],r6
800048bc:	80 00       	ld.sh	r0,r0[0x0]
800048be:	57 50       	stdsp	sp[0x1d4],r0

800048c0 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
800048c0:	eb cd 40 c0 	pushm	r6-r7,lr
800048c4:	18 96       	mov	r6,r12
800048c6:	16 97       	mov	r7,r11
	U8   ucAddr;

	CLR_SPI_CS;	
800048c8:	31 8c       	mov	r12,24
800048ca:	f0 1f 00 09 	mcall	800048ec <WriteRawRC+0x2c>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
800048ce:	ec 0c 15 01 	lsl	r12,r6,0x1
800048d2:	e2 1c 00 7e 	andl	r12,0x7e,COH
800048d6:	f0 1f 00 07 	mcall	800048f0 <WriteRawRC+0x30>
	RC522_WriteByte(value);
800048da:	0e 9c       	mov	r12,r7
800048dc:	f0 1f 00 05 	mcall	800048f0 <WriteRawRC+0x30>
	
	SET_SPI_CS;
800048e0:	31 8c       	mov	r12,24
800048e2:	f0 1f 00 05 	mcall	800048f4 <WriteRawRC+0x34>

}
800048e6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800048ea:	00 00       	add	r0,r0
800048ec:	80 00       	ld.sh	r0,r0[0x0]
800048ee:	53 04       	stdsp	sp[0xc0],r4
800048f0:	80 00       	ld.sh	r0,r0[0x0]
800048f2:	48 74       	lddpc	r4,8000490c <PcdReset+0x14>
800048f4:	80 00       	ld.sh	r0,r0[0x0]
800048f6:	52 e8       	stdsp	sp[0xb8],r8

800048f8 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
800048f8:	d4 01       	pushm	lr

	SET_RC522RST;
800048fa:	31 9c       	mov	r12,25
800048fc:	f0 1f 00 1b 	mcall	80004968 <PcdReset+0x70>
	delay_ns(10);
80004900:	30 ac       	mov	r12,10
80004902:	f0 1f 00 1b 	mcall	8000496c <PcdReset+0x74>

	CLR_RC522RST;
80004906:	31 9c       	mov	r12,25
80004908:	f0 1f 00 1a 	mcall	80004970 <PcdReset+0x78>
	delay_ns(10);
8000490c:	30 ac       	mov	r12,10
8000490e:	f0 1f 00 18 	mcall	8000496c <PcdReset+0x74>

	SET_RC522RST;
80004912:	31 9c       	mov	r12,25
80004914:	f0 1f 00 15 	mcall	80004968 <PcdReset+0x70>
	delay_ns(10);
80004918:	30 ac       	mov	r12,10
8000491a:	f0 1f 00 15 	mcall	8000496c <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
8000491e:	30 fb       	mov	r11,15
80004920:	30 1c       	mov	r12,1
80004922:	f0 1f 00 15 	mcall	80004974 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004926:	30 fb       	mov	r11,15
80004928:	30 1c       	mov	r12,1
8000492a:	f0 1f 00 13 	mcall	80004974 <PcdReset+0x7c>
	delay_ns(10);
8000492e:	30 ac       	mov	r12,10
80004930:	f0 1f 00 0f 	mcall	8000496c <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80004934:	33 db       	mov	r11,61
80004936:	31 1c       	mov	r12,17
80004938:	f0 1f 00 0f 	mcall	80004974 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
8000493c:	31 eb       	mov	r11,30
8000493e:	32 dc       	mov	r12,45
80004940:	f0 1f 00 0d 	mcall	80004974 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80004944:	30 0b       	mov	r11,0
80004946:	32 cc       	mov	r12,44
80004948:	f0 1f 00 0b 	mcall	80004974 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
8000494c:	e0 6b 00 8d 	mov	r11,141
80004950:	32 ac       	mov	r12,42
80004952:	f0 1f 00 09 	mcall	80004974 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
80004956:	33 eb       	mov	r11,62
80004958:	32 bc       	mov	r12,43
8000495a:	f0 1f 00 07 	mcall	80004974 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
8000495e:	34 0b       	mov	r11,64
80004960:	31 5c       	mov	r12,21
80004962:	f0 1f 00 05 	mcall	80004974 <PcdReset+0x7c>
	
	return MI_OK;
}
80004966:	d8 0a       	popm	pc,r12=0
80004968:	80 00       	ld.sh	r0,r0[0x0]
8000496a:	52 e8       	stdsp	sp[0xb8],r8
8000496c:	80 00       	ld.sh	r0,r0[0x0]
8000496e:	51 b8       	stdsp	sp[0x6c],r8
80004970:	80 00       	ld.sh	r0,r0[0x0]
80004972:	53 04       	stdsp	sp[0xc0],r4
80004974:	80 00       	ld.sh	r0,r0[0x0]
80004976:	48 c0       	lddpc	r0,800049a4 <ReadRawRC+0x2c>

80004978 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
80004978:	eb cd 40 80 	pushm	r7,lr
8000497c:	18 97       	mov	r7,r12
	U8   ucAddr;
	U8   ucResult=0;
	CLR_SPI_CS;	
8000497e:	31 8c       	mov	r12,24
80004980:	f0 1f 00 0a 	mcall	800049a8 <ReadRawRC+0x30>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
80004984:	ee 08 15 01 	lsl	r8,r7,0x1
80004988:	10 9c       	mov	r12,r8
8000498a:	e2 1c 00 7e 	andl	r12,0x7e,COH
8000498e:	a7 bc       	sbr	r12,0x7
80004990:	f0 1f 00 07 	mcall	800049ac <ReadRawRC+0x34>
	ucResult = RC522_ReadByte();
80004994:	f0 1f 00 07 	mcall	800049b0 <ReadRawRC+0x38>
80004998:	18 97       	mov	r7,r12
	
	SET_SPI_CS;
8000499a:	31 8c       	mov	r12,24
8000499c:	f0 1f 00 06 	mcall	800049b4 <ReadRawRC+0x3c>
	return ucResult;
}
800049a0:	0e 9c       	mov	r12,r7
800049a2:	e3 cd 80 80 	ldm	sp++,r7,pc
800049a6:	00 00       	add	r0,r0
800049a8:	80 00       	ld.sh	r0,r0[0x0]
800049aa:	53 04       	stdsp	sp[0xc0],r4
800049ac:	80 00       	ld.sh	r0,r0[0x0]
800049ae:	48 74       	lddpc	r4,800049c8 <SetBitMask+0x10>
800049b0:	80 00       	ld.sh	r0,r0[0x0]
800049b2:	48 30       	lddpc	r0,800049bc <SetBitMask+0x4>
800049b4:	80 00       	ld.sh	r0,r0[0x0]
800049b6:	52 e8       	stdsp	sp[0xb8],r8

800049b8 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
800049b8:	eb cd 40 c0 	pushm	r6-r7,lr
800049bc:	18 97       	mov	r7,r12
800049be:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
800049c0:	f0 1f 00 05 	mcall	800049d4 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
800049c4:	f9 e6 10 0b 	or	r11,r12,r6
800049c8:	5c 5b       	castu.b	r11
800049ca:	0e 9c       	mov	r12,r7
800049cc:	f0 1f 00 03 	mcall	800049d8 <SetBitMask+0x20>
}
800049d0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800049d4:	80 00       	ld.sh	r0,r0[0x0]
800049d6:	49 78       	lddpc	r8,80004a30 <PcdAntennaOff+0xc>
800049d8:	80 00       	ld.sh	r0,r0[0x0]
800049da:	48 c0       	lddpc	r0,80004a08 <ClearBitMask+0xc>

800049dc <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
800049dc:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
800049de:	31 4c       	mov	r12,20
800049e0:	f0 1f 00 05 	mcall	800049f4 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
800049e4:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
800049e8:	c0 51       	brne	800049f2 <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
800049ea:	30 3b       	mov	r11,3
800049ec:	31 4c       	mov	r12,20
800049ee:	f0 1f 00 03 	mcall	800049f8 <PcdAntennaOn+0x1c>
800049f2:	d8 02       	popm	pc
800049f4:	80 00       	ld.sh	r0,r0[0x0]
800049f6:	49 78       	lddpc	r8,80004a50 <M500PcdConfigISOType+0x1c>
800049f8:	80 00       	ld.sh	r0,r0[0x0]
800049fa:	49 b8       	lddpc	r8,80004a64 <M500PcdConfigISOType+0x30>

800049fc <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
800049fc:	eb cd 40 c0 	pushm	r6-r7,lr
80004a00:	18 97       	mov	r7,r12
80004a02:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80004a04:	f0 1f 00 06 	mcall	80004a1c <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80004a08:	5c d6       	com	r6
80004a0a:	f9 e6 00 06 	and	r6,r12,r6
80004a0e:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80004a12:	0e 9c       	mov	r12,r7
80004a14:	f0 1f 00 03 	mcall	80004a20 <ClearBitMask+0x24>
	
}
80004a18:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a1c:	80 00       	ld.sh	r0,r0[0x0]
80004a1e:	49 78       	lddpc	r8,80004a78 <M500PcdConfigISOType+0x44>
80004a20:	80 00       	ld.sh	r0,r0[0x0]
80004a22:	48 c0       	lddpc	r0,80004a50 <M500PcdConfigISOType+0x1c>

80004a24 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
80004a24:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
80004a26:	30 3b       	mov	r11,3
80004a28:	31 4c       	mov	r12,20
80004a2a:	f0 1f 00 02 	mcall	80004a30 <PcdAntennaOff+0xc>
}
80004a2e:	d8 02       	popm	pc
80004a30:	80 00       	ld.sh	r0,r0[0x0]
80004a32:	49 fc       	lddpc	r12,80004aac <rc522_init+0x8>

80004a34 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
80004a34:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
80004a36:	34 18       	mov	r8,65
80004a38:	f0 0c 18 00 	cp.b	r12,r8
80004a3c:	c0 20       	breq	80004a40 <M500PcdConfigISOType+0xc>
80004a3e:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80004a40:	30 8b       	mov	r11,8
80004a42:	16 9c       	mov	r12,r11
80004a44:	f0 1f 00 14 	mcall	80004a94 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
80004a48:	33 db       	mov	r11,61
80004a4a:	31 1c       	mov	r12,17
80004a4c:	f0 1f 00 13 	mcall	80004a98 <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80004a50:	e0 6b 00 86 	mov	r11,134
80004a54:	31 7c       	mov	r12,23
80004a56:	f0 1f 00 11 	mcall	80004a98 <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
80004a5a:	37 fb       	mov	r11,127
80004a5c:	32 6c       	mov	r12,38
80004a5e:	f0 1f 00 0f 	mcall	80004a98 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
80004a62:	31 eb       	mov	r11,30
80004a64:	32 dc       	mov	r12,45
80004a66:	f0 1f 00 0d 	mcall	80004a98 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
80004a6a:	30 0b       	mov	r11,0
80004a6c:	32 cc       	mov	r12,44
80004a6e:	f0 1f 00 0b 	mcall	80004a98 <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
80004a72:	e0 6b 00 8d 	mov	r11,141
80004a76:	32 ac       	mov	r12,42
80004a78:	f0 1f 00 08 	mcall	80004a98 <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80004a7c:	33 eb       	mov	r11,62
80004a7e:	32 bc       	mov	r12,43
80004a80:	f0 1f 00 06 	mcall	80004a98 <M500PcdConfigISOType+0x64>
		delay_ns(1000);
80004a84:	e0 6c 03 e8 	mov	r12,1000
80004a88:	f0 1f 00 05 	mcall	80004a9c <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80004a8c:	f0 1f 00 05 	mcall	80004aa0 <M500PcdConfigISOType+0x6c>
80004a90:	d8 0a       	popm	pc,r12=0
80004a92:	00 00       	add	r0,r0
80004a94:	80 00       	ld.sh	r0,r0[0x0]
80004a96:	49 fc       	lddpc	r12,80004b10 <rc522_init+0x6c>
80004a98:	80 00       	ld.sh	r0,r0[0x0]
80004a9a:	48 c0       	lddpc	r0,80004ac8 <rc522_init+0x24>
80004a9c:	80 00       	ld.sh	r0,r0[0x0]
80004a9e:	51 b8       	stdsp	sp[0x6c],r8
80004aa0:	80 00       	ld.sh	r0,r0[0x0]
80004aa2:	49 dc       	lddpc	r12,80004b14 <rc522_init+0x70>

80004aa4 <rc522_init>:


//mfrc522 init

void rc522_init()
{
80004aa4:	eb cd 40 c0 	pushm	r6-r7,lr
80004aa8:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004aaa:	4a 28       	lddpc	r8,80004b30 <rc522_init+0x8c>
80004aac:	1a 96       	mov	r6,sp
80004aae:	f0 ea 00 00 	ld.d	r10,r8[0]
80004ab2:	fa eb 00 00 	st.d	sp[0],r10
80004ab6:	f0 e8 00 08 	ld.d	r8,r8[8]
80004aba:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80004abe:	30 4b       	mov	r11,4
80004ac0:	49 dc       	lddpc	r12,80004b34 <rc522_init+0x90>
80004ac2:	f0 1f 00 1e 	mcall	80004b38 <rc522_init+0x94>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80004ac6:	31 9c       	mov	r12,25
80004ac8:	f0 1f 00 1d 	mcall	80004b3c <rc522_init+0x98>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80004acc:	31 9c       	mov	r12,25
80004ace:	f0 1f 00 1d 	mcall	80004b40 <rc522_init+0x9c>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
80004ad2:	49 d7       	lddpc	r7,80004b44 <rc522_init+0xa0>
80004ad4:	fe 7c 24 00 	mov	r12,-56320
80004ad8:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80004ada:	1a 9b       	mov	r11,sp
80004adc:	f0 1f 00 1b 	mcall	80004b48 <rc522_init+0xa4>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80004ae0:	30 09       	mov	r9,0
80004ae2:	12 9a       	mov	r10,r9
80004ae4:	12 9b       	mov	r11,r9
80004ae6:	6e 0c       	ld.w	r12,r7[0x0]
80004ae8:	f0 1f 00 19 	mcall	80004b4c <rc522_init+0xa8>

	// Enable SPI.
	spi_enable(spi);
80004aec:	6e 0c       	ld.w	r12,r7[0x0]
80004aee:	f0 1f 00 19 	mcall	80004b50 <rc522_init+0xac>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80004af2:	e0 6a 36 00 	mov	r10,13824
80004af6:	ea 1a 01 6e 	orh	r10,0x16e
80004afa:	1a 9b       	mov	r11,sp
80004afc:	6e 0c       	ld.w	r12,r7[0x0]
80004afe:	f0 1f 00 16 	mcall	80004b54 <rc522_init+0xb0>
80004b02:	c0 50       	breq	80004b0c <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80004b04:	30 29       	mov	r9,2
80004b06:	49 58       	lddpc	r8,80004b58 <rc522_init+0xb4>
80004b08:	b0 89       	st.b	r8[0x0],r9
80004b0a:	c0 38       	rjmp	80004b10 <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80004b0c:	f0 1f 00 14 	mcall	80004b5c <rc522_init+0xb8>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80004b10:	f0 1f 00 14 	mcall	80004b60 <rc522_init+0xbc>
	
	PcdAntennaOff();
80004b14:	f0 1f 00 14 	mcall	80004b64 <rc522_init+0xc0>
	
	delay_ms(2); 
80004b18:	30 2c       	mov	r12,2
80004b1a:	f0 1f 00 14 	mcall	80004b68 <rc522_init+0xc4>
	
	PcdAntennaOn();
80004b1e:	f0 1f 00 14 	mcall	80004b6c <rc522_init+0xc8>
	
	M500PcdConfigISOType( 'A' );
80004b22:	34 1c       	mov	r12,65
80004b24:	f0 1f 00 13 	mcall	80004b70 <rc522_init+0xcc>
	

80004b28:	2f cd       	sub	sp,-16
80004b2a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004b2e:	00 00       	add	r0,r0
80004b30:	80 00       	ld.sh	r0,r0[0x0]
80004b32:	d5 c0       	acall	0x5c
80004b34:	80 00       	ld.sh	r0,r0[0x0]
80004b36:	d5 98       	*unknown*
80004b38:	80 00       	ld.sh	r0,r0[0x0]
80004b3a:	52 a0       	stdsp	sp[0xa8],r0
80004b3c:	80 00       	ld.sh	r0,r0[0x0]
80004b3e:	52 d0       	stdsp	sp[0xb4],r0
80004b40:	80 00       	ld.sh	r0,r0[0x0]
80004b42:	52 e8       	stdsp	sp[0xb8],r8
80004b44:	00 00       	add	r0,r0
80004b46:	1d 88       	ld.ub	r8,lr[0x0]
80004b48:	80 00       	ld.sh	r0,r0[0x0]
80004b4a:	55 c0       	stdsp	sp[0x170],r0
80004b4c:	80 00       	ld.sh	r0,r0[0x0]
80004b4e:	55 f8       	stdsp	sp[0x17c],r8
80004b50:	80 00       	ld.sh	r0,r0[0x0]
80004b52:	56 24       	stdsp	sp[0x188],r4
80004b54:	80 00       	ld.sh	r0,r0[0x0]
80004b56:	56 68       	stdsp	sp[0x198],r8
80004b58:	00 00       	add	r0,r0
80004b5a:	0b 58       	ld.sh	r8,--r5
80004b5c:	80 00       	ld.sh	r0,r0[0x0]
80004b5e:	48 20       	lddpc	r0,80004b64 <rc522_init+0xc0>
80004b60:	80 00       	ld.sh	r0,r0[0x0]
80004b62:	48 f8       	lddpc	r8,80004b9c <PcdComMF522+0x28>
80004b64:	80 00       	ld.sh	r0,r0[0x0]
80004b66:	4a 24       	lddpc	r4,80004bec <PcdComMF522+0x78>
80004b68:	80 00       	ld.sh	r0,r0[0x0]
80004b6a:	51 f8       	stdsp	sp[0x7c],r8
80004b6c:	80 00       	ld.sh	r0,r0[0x0]
80004b6e:	49 dc       	lddpc	r12,80004be0 <PcdComMF522+0x6c>
80004b70:	80 00       	ld.sh	r0,r0[0x0]
80004b72:	4a 34       	lddpc	r4,80004bfc <PcdComMF522+0x88>

80004b74 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004b74:	d4 31       	pushm	r0-r7,lr
80004b76:	20 1d       	sub	sp,4
80004b78:	18 92       	mov	r2,r12
80004b7a:	16 95       	mov	r5,r11
80004b7c:	14 96       	mov	r6,r10
80004b7e:	50 09       	stdsp	sp[0x0],r9
80004b80:	10 90       	mov	r0,r8
80004b82:	f8 c8 00 0c 	sub	r8,r12,12
80004b86:	5c 58       	castu.b	r8
80004b88:	30 29       	mov	r9,2
80004b8a:	f2 08 18 00 	cp.b	r8,r9
80004b8e:	e0 88 00 05 	brls	80004b98 <PcdComMF522+0x24>
80004b92:	30 03       	mov	r3,0
80004b94:	06 91       	mov	r1,r3
80004b96:	c0 78       	rjmp	80004ba4 <PcdComMF522+0x30>
80004b98:	4c f9       	lddpc	r9,80004cd4 <PcdComMF522+0x160>
80004b9a:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004b9e:	4c f9       	lddpc	r9,80004cd8 <PcdComMF522+0x164>
80004ba0:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004ba4:	02 9b       	mov	r11,r1
80004ba6:	a7 bb       	sbr	r11,0x7
80004ba8:	30 2c       	mov	r12,2
80004baa:	f0 1f 00 4d 	mcall	80004cdc <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004bae:	e0 6b 00 80 	mov	r11,128
80004bb2:	30 4c       	mov	r12,4
80004bb4:	f0 1f 00 4b 	mcall	80004ce0 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004bb8:	30 0b       	mov	r11,0
80004bba:	30 1c       	mov	r12,1
80004bbc:	f0 1f 00 48 	mcall	80004cdc <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004bc0:	e0 6b 00 80 	mov	r11,128
80004bc4:	30 ac       	mov	r12,10
80004bc6:	f0 1f 00 48 	mcall	80004ce4 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004bca:	58 06       	cp.w	r6,0
80004bcc:	c0 c0       	breq	80004be4 <PcdComMF522+0x70>
80004bce:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004bd0:	30 94       	mov	r4,9
80004bd2:	0f 3b       	ld.ub	r11,r7++
80004bd4:	08 9c       	mov	r12,r4
80004bd6:	f0 1f 00 42 	mcall	80004cdc <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004bda:	0e 98       	mov	r8,r7
80004bdc:	0a 18       	sub	r8,r5
80004bde:	ec 08 19 00 	cp.h	r8,r6
80004be2:	cf 83       	brcs	80004bd2 <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004be4:	04 9b       	mov	r11,r2
80004be6:	30 1c       	mov	r12,1
80004be8:	f0 1f 00 3d 	mcall	80004cdc <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004bec:	30 c8       	mov	r8,12
80004bee:	f0 02 18 00 	cp.b	r2,r8
80004bf2:	c0 61       	brne	80004bfe <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004bf4:	e0 6b 00 80 	mov	r11,128
80004bf8:	30 dc       	mov	r12,13
80004bfa:	f0 1f 00 3b 	mcall	80004ce4 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004bfe:	30 4c       	mov	r12,4
80004c00:	f0 1f 00 3a 	mcall	80004ce8 <PcdComMF522+0x174>
80004c04:	18 97       	mov	r7,r12
80004c06:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004c0a:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004c0c:	30 44       	mov	r4,4
80004c0e:	c0 88       	rjmp	80004c1e <PcdComMF522+0xaa>
80004c10:	08 9c       	mov	r12,r4
80004c12:	f0 1f 00 36 	mcall	80004ce8 <PcdComMF522+0x174>
80004c16:	18 97       	mov	r7,r12
		i--;
80004c18:	20 16       	sub	r6,1
80004c1a:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004c1c:	c0 a0       	breq	80004c30 <PcdComMF522+0xbc>
80004c1e:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004c22:	c4 c1       	brne	80004cba <PcdComMF522+0x146>
80004c24:	ef e3 00 08 	and	r8,r7,r3
80004c28:	ea 08 18 00 	cp.b	r8,r5
80004c2c:	cf 20       	breq	80004c10 <PcdComMF522+0x9c>
80004c2e:	c4 68       	rjmp	80004cba <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004c30:	e0 6b 00 80 	mov	r11,128
80004c34:	30 dc       	mov	r12,13
80004c36:	f0 1f 00 2b 	mcall	80004ce0 <PcdComMF522+0x16c>
80004c3a:	30 27       	mov	r7,2
80004c3c:	c3 38       	rjmp	80004ca2 <PcdComMF522+0x12e>
80004c3e:	02 67       	and	r7,r1
80004c40:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004c44:	30 c8       	mov	r8,12
80004c46:	f0 02 18 00 	cp.b	r2,r8
80004c4a:	c2 c1       	brne	80004ca2 <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004c4c:	30 ac       	mov	r12,10
80004c4e:	f0 1f 00 27 	mcall	80004ce8 <PcdComMF522+0x174>
80004c52:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004c54:	30 cc       	mov	r12,12
80004c56:	f0 1f 00 25 	mcall	80004ce8 <PcdComMF522+0x174>
80004c5a:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004c5e:	c0 70       	breq	80004c6c <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004c60:	08 98       	mov	r8,r4
80004c62:	20 18       	sub	r8,1
80004c64:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004c68:	a0 8c       	st.b	r0[0x0],r12
80004c6a:	c0 48       	rjmp	80004c72 <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004c6c:	e8 08 15 03 	lsl	r8,r4,0x3
80004c70:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004c72:	58 04       	cp.w	r4,0
80004c74:	c0 61       	brne	80004c80 <PcdComMF522+0x10c>
80004c76:	30 14       	mov	r4,1
80004c78:	40 05       	lddsp	r5,sp[0x0]
80004c7a:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004c7c:	30 93       	mov	r3,9
80004c7e:	c0 98       	rjmp	80004c90 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004c80:	31 28       	mov	r8,18
80004c82:	f0 04 18 00 	cp.b	r4,r8
80004c86:	f9 b4 0b 12 	movhi	r4,18
80004c8a:	58 04       	cp.w	r4,0
80004c8c:	cf 61       	brne	80004c78 <PcdComMF522+0x104>
80004c8e:	c0 a8       	rjmp	80004ca2 <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004c90:	06 9c       	mov	r12,r3
80004c92:	f0 1f 00 16 	mcall	80004ce8 <PcdComMF522+0x174>
80004c96:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004c98:	ec 05 01 08 	sub	r8,r6,r5
80004c9c:	e8 08 19 00 	cp.h	r8,r4
80004ca0:	cf 83       	brcs	80004c90 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004ca2:	e0 6b 00 80 	mov	r11,128
80004ca6:	30 cc       	mov	r12,12
80004ca8:	f0 1f 00 0f 	mcall	80004ce4 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004cac:	30 0b       	mov	r11,0
80004cae:	30 1c       	mov	r12,1
80004cb0:	f0 1f 00 0b 	mcall	80004cdc <PcdComMF522+0x168>
	return status;
}
80004cb4:	0e 9c       	mov	r12,r7
80004cb6:	2f fd       	sub	sp,-4
80004cb8:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004cba:	e0 6b 00 80 	mov	r11,128
80004cbe:	30 dc       	mov	r12,13
80004cc0:	f0 1f 00 08 	mcall	80004ce0 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004cc4:	30 6c       	mov	r12,6
80004cc6:	f0 1f 00 09 	mcall	80004ce8 <PcdComMF522+0x174>
80004cca:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004cce:	cb 80       	breq	80004c3e <PcdComMF522+0xca>
80004cd0:	30 27       	mov	r7,2
80004cd2:	ce 8b       	rjmp	80004ca2 <PcdComMF522+0x12e>
80004cd4:	80 00       	ld.sh	r0,r0[0x0]
80004cd6:	d5 b8       	*unknown*
80004cd8:	80 00       	ld.sh	r0,r0[0x0]
80004cda:	d5 bc       	*unknown*
80004cdc:	80 00       	ld.sh	r0,r0[0x0]
80004cde:	48 c0       	lddpc	r0,80004d0c <PcdAnticoll+0x20>
80004ce0:	80 00       	ld.sh	r0,r0[0x0]
80004ce2:	49 fc       	lddpc	r12,80004d5c <PcdAnticoll+0x70>
80004ce4:	80 00       	ld.sh	r0,r0[0x0]
80004ce6:	49 b8       	lddpc	r8,80004d50 <PcdAnticoll+0x64>
80004ce8:	80 00       	ld.sh	r0,r0[0x0]
80004cea:	49 78       	lddpc	r8,80004d44 <PcdAnticoll+0x58>

80004cec <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004cec:	eb cd 40 c0 	pushm	r6-r7,lr
80004cf0:	20 5d       	sub	sp,20
80004cf2:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004cf4:	30 8b       	mov	r11,8
80004cf6:	16 9c       	mov	r12,r11
80004cf8:	f0 1f 00 1a 	mcall	80004d60 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004cfc:	30 0b       	mov	r11,0
80004cfe:	30 dc       	mov	r12,13
80004d00:	f0 1f 00 19 	mcall	80004d64 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004d04:	e0 6b 00 80 	mov	r11,128
80004d08:	30 ec       	mov	r12,14
80004d0a:	f0 1f 00 16 	mcall	80004d60 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004d0e:	39 38       	mov	r8,-109
80004d10:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004d12:	32 08       	mov	r8,32
80004d14:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004d16:	1a 9b       	mov	r11,sp
80004d18:	fa c8 ff ed 	sub	r8,sp,-19
80004d1c:	1a 99       	mov	r9,sp
80004d1e:	30 2a       	mov	r10,2
80004d20:	30 cc       	mov	r12,12
80004d22:	f0 1f 00 12 	mcall	80004d68 <PcdAnticoll+0x7c>
80004d26:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004d28:	c1 21       	brne	80004d4c <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004d2a:	1b 89       	ld.ub	r9,sp[0x0]
80004d2c:	ac 89       	st.b	r6[0x0],r9
80004d2e:	1b 98       	ld.ub	r8,sp[0x1]
80004d30:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004d32:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004d34:	1b a8       	ld.ub	r8,sp[0x2]
80004d36:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004d38:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004d3c:	1b b9       	ld.ub	r9,sp[0x3]
80004d3e:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004d40:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004d42:	1b c9       	ld.ub	r9,sp[0x4]
80004d44:	f0 09 18 00 	cp.b	r9,r8
80004d48:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004d4c:	e0 6b 00 80 	mov	r11,128
80004d50:	30 ec       	mov	r12,14
80004d52:	f0 1f 00 07 	mcall	80004d6c <PcdAnticoll+0x80>
	return status;
}
80004d56:	0e 9c       	mov	r12,r7
80004d58:	2f bd       	sub	sp,-20
80004d5a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004d5e:	00 00       	add	r0,r0
80004d60:	80 00       	ld.sh	r0,r0[0x0]
80004d62:	49 fc       	lddpc	r12,80004ddc <CalulateCRC+0x8>
80004d64:	80 00       	ld.sh	r0,r0[0x0]
80004d66:	48 c0       	lddpc	r0,80004d94 <PcdRequest+0x24>
80004d68:	80 00       	ld.sh	r0,r0[0x0]
80004d6a:	4b 74       	lddpc	r4,80004e44 <CalulateCRC+0x70>
80004d6c:	80 00       	ld.sh	r0,r0[0x0]
80004d6e:	49 b8       	lddpc	r8,80004dd8 <CalulateCRC+0x4>

80004d70 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004d70:	eb cd 40 c0 	pushm	r6-r7,lr
80004d74:	20 5d       	sub	sp,20
80004d76:	18 97       	mov	r7,r12
80004d78:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004d7a:	30 8b       	mov	r11,8
80004d7c:	16 9c       	mov	r12,r11
80004d7e:	f0 1f 00 12 	mcall	80004dc4 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004d82:	30 7b       	mov	r11,7
80004d84:	30 dc       	mov	r12,13
80004d86:	f0 1f 00 11 	mcall	80004dc8 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004d8a:	30 3b       	mov	r11,3
80004d8c:	31 4c       	mov	r12,20
80004d8e:	f0 1f 00 10 	mcall	80004dcc <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004d92:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004d94:	1a 9b       	mov	r11,sp
80004d96:	fa c8 ff ed 	sub	r8,sp,-19
80004d9a:	1a 99       	mov	r9,sp
80004d9c:	30 1a       	mov	r10,1
80004d9e:	30 cc       	mov	r12,12
80004da0:	f0 1f 00 0c 	mcall	80004dd0 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004da4:	c0 c1       	brne	80004dbc <PcdRequest+0x4c>
80004da6:	31 08       	mov	r8,16
80004da8:	fb 39 00 13 	ld.ub	r9,sp[19]
80004dac:	f0 09 18 00 	cp.b	r9,r8
80004db0:	c0 61       	brne	80004dbc <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004db2:	1b 88       	ld.ub	r8,sp[0x0]
80004db4:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004db6:	1b 98       	ld.ub	r8,sp[0x1]
80004db8:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004dba:	c0 28       	rjmp	80004dbe <PcdRequest+0x4e>
80004dbc:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004dbe:	2f bd       	sub	sp,-20
80004dc0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004dc4:	80 00       	ld.sh	r0,r0[0x0]
80004dc6:	49 fc       	lddpc	r12,80004e40 <CalulateCRC+0x6c>
80004dc8:	80 00       	ld.sh	r0,r0[0x0]
80004dca:	48 c0       	lddpc	r0,80004df8 <CalulateCRC+0x24>
80004dcc:	80 00       	ld.sh	r0,r0[0x0]
80004dce:	49 b8       	lddpc	r8,80004e38 <CalulateCRC+0x64>
80004dd0:	80 00       	ld.sh	r0,r0[0x0]
80004dd2:	4b 74       	lddpc	r4,80004eac <PcdSelect+0x4c>

80004dd4 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004dd4:	eb cd 40 f8 	pushm	r3-r7,lr
80004dd8:	18 95       	mov	r5,r12
80004dda:	16 96       	mov	r6,r11
80004ddc:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004dde:	30 4b       	mov	r11,4
80004de0:	30 5c       	mov	r12,5
80004de2:	f0 1f 00 1c 	mcall	80004e50 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004de6:	30 0b       	mov	r11,0
80004de8:	30 1c       	mov	r12,1
80004dea:	f0 1f 00 1b 	mcall	80004e54 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004dee:	e0 6b 00 80 	mov	r11,128
80004df2:	30 ac       	mov	r12,10
80004df4:	f0 1f 00 19 	mcall	80004e58 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004df8:	58 06       	cp.w	r6,0
80004dfa:	c0 c0       	breq	80004e12 <CalulateCRC+0x3e>
80004dfc:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004dfe:	30 94       	mov	r4,9
80004e00:	0f 3b       	ld.ub	r11,r7++
80004e02:	08 9c       	mov	r12,r4
80004e04:	f0 1f 00 14 	mcall	80004e54 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004e08:	0e 98       	mov	r8,r7
80004e0a:	0a 18       	sub	r8,r5
80004e0c:	ec 08 18 00 	cp.b	r8,r6
80004e10:	cf 83       	brcs	80004e00 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004e12:	30 3b       	mov	r11,3
80004e14:	30 1c       	mov	r12,1
80004e16:	f0 1f 00 10 	mcall	80004e54 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004e1a:	30 5c       	mov	r12,5
80004e1c:	f0 1f 00 10 	mcall	80004e5c <CalulateCRC+0x88>
80004e20:	e0 67 00 fe 	mov	r7,254
80004e24:	30 56       	mov	r6,5
80004e26:	c0 78       	rjmp	80004e34 <CalulateCRC+0x60>
80004e28:	0c 9c       	mov	r12,r6
80004e2a:	f0 1f 00 0d 	mcall	80004e5c <CalulateCRC+0x88>
		i--;
80004e2e:	20 17       	sub	r7,1
80004e30:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004e32:	c0 40       	breq	80004e3a <CalulateCRC+0x66>
80004e34:	e2 1c 00 04 	andl	r12,0x4,COH
80004e38:	cf 80       	breq	80004e28 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004e3a:	32 2c       	mov	r12,34
80004e3c:	f0 1f 00 08 	mcall	80004e5c <CalulateCRC+0x88>
80004e40:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004e42:	32 1c       	mov	r12,33
80004e44:	f0 1f 00 06 	mcall	80004e5c <CalulateCRC+0x88>
80004e48:	a6 9c       	st.b	r3[0x1],r12
}
80004e4a:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004e4e:	00 00       	add	r0,r0
80004e50:	80 00       	ld.sh	r0,r0[0x0]
80004e52:	49 fc       	lddpc	r12,80004ecc <PcdSelect+0x6c>
80004e54:	80 00       	ld.sh	r0,r0[0x0]
80004e56:	48 c0       	lddpc	r0,80004e84 <PcdSelect+0x24>
80004e58:	80 00       	ld.sh	r0,r0[0x0]
80004e5a:	49 b8       	lddpc	r8,80004ec4 <PcdSelect+0x64>
80004e5c:	80 00       	ld.sh	r0,r0[0x0]
80004e5e:	49 78       	lddpc	r8,80004eb8 <PcdSelect+0x58>

80004e60 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004e60:	eb cd 40 80 	pushm	r7,lr
80004e64:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004e66:	39 38       	mov	r8,-109
80004e68:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004e6a:	37 08       	mov	r8,112
80004e6c:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004e6e:	30 08       	mov	r8,0
80004e70:	ba e8       	st.b	sp[0x6],r8
80004e72:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004e76:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004e7a:	19 89       	ld.ub	r9,r12[0x0]
80004e7c:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004e7e:	19 3a       	ld.ub	r10,r12++
80004e80:	1b e9       	ld.ub	r9,sp[0x6]
80004e82:	f5 e9 20 09 	eor	r9,r10,r9
80004e86:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004e88:	16 38       	cp.w	r8,r11
80004e8a:	cf 81       	brne	80004e7a <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004e8c:	1a 97       	mov	r7,sp
80004e8e:	fa ca ff f9 	sub	r10,sp,-7
80004e92:	30 7b       	mov	r11,7
80004e94:	1a 9c       	mov	r12,sp
80004e96:	f0 1f 00 0d 	mcall	80004ec8 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004e9a:	30 8b       	mov	r11,8
80004e9c:	16 9c       	mov	r12,r11
80004e9e:	f0 1f 00 0c 	mcall	80004ecc <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004ea2:	fa c8 ff ed 	sub	r8,sp,-19
80004ea6:	1a 99       	mov	r9,sp
80004ea8:	30 9a       	mov	r10,9
80004eaa:	1a 9b       	mov	r11,sp
80004eac:	30 cc       	mov	r12,12
80004eae:	f0 1f 00 09 	mcall	80004ed0 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80004eb2:	c0 71       	brne	80004ec0 <PcdSelect+0x60>
80004eb4:	31 88       	mov	r8,24
80004eb6:	fb 39 00 13 	ld.ub	r9,sp[19]
80004eba:	f0 09 18 00 	cp.b	r9,r8
80004ebe:	c0 20       	breq	80004ec2 <PcdSelect+0x62>
80004ec0:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80004ec2:	2f bd       	sub	sp,-20
80004ec4:	e3 cd 80 80 	ldm	sp++,r7,pc
80004ec8:	80 00       	ld.sh	r0,r0[0x0]
80004eca:	4d d4       	lddpc	r4,8000503c <rfid_sendID_message+0x48>
80004ecc:	80 00       	ld.sh	r0,r0[0x0]
80004ece:	49 fc       	lddpc	r12,80004f48 <rfid_auto_reader+0x74>
80004ed0:	80 00       	ld.sh	r0,r0[0x0]
80004ed2:	4b 74       	lddpc	r4,80004fac <rfid_auto_reader+0xd8>

80004ed4 <rfid_auto_reader>:
		
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80004ed4:	eb cd 40 c0 	pushm	r6-r7,lr
80004ed8:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80004eda:	f0 1f 00 37 	mcall	80004fb4 <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80004ede:	4b 7b       	lddpc	r11,80004fb8 <rfid_auto_reader+0xe4>
80004ee0:	35 2c       	mov	r12,82
80004ee2:	f0 1f 00 37 	mcall	80004fbc <rfid_auto_reader+0xe8>
80004ee6:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80004ee8:	c6 31       	brne	80004fae <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004eea:	4b 48       	lddpc	r8,80004fb8 <rfid_auto_reader+0xe4>
80004eec:	11 88       	ld.ub	r8,r8[0x0]
80004eee:	30 49       	mov	r9,4
80004ef0:	f2 08 18 00 	cp.b	r8,r9
80004ef4:	c0 b1       	brne	80004f0a <rfid_auto_reader+0x36>
80004ef6:	4b 19       	lddpc	r9,80004fb8 <rfid_auto_reader+0xe4>
80004ef8:	13 9a       	ld.ub	r10,r9[0x1]
80004efa:	30 09       	mov	r9,0
80004efc:	f2 0a 18 00 	cp.b	r10,r9
80004f00:	c0 51       	brne	80004f0a <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
80004f02:	4b 0c       	lddpc	r12,80004fc0 <rfid_auto_reader+0xec>
80004f04:	f0 1f 00 30 	mcall	80004fc4 <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004f08:	c3 c8       	rjmp	80004f80 <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004f0a:	30 29       	mov	r9,2
80004f0c:	f2 08 18 00 	cp.b	r8,r9
80004f10:	c0 b1       	brne	80004f26 <rfid_auto_reader+0x52>
80004f12:	4a a9       	lddpc	r9,80004fb8 <rfid_auto_reader+0xe4>
80004f14:	13 9a       	ld.ub	r10,r9[0x1]
80004f16:	30 09       	mov	r9,0
80004f18:	f2 0a 18 00 	cp.b	r10,r9
80004f1c:	c0 51       	brne	80004f26 <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80004f1e:	4a bc       	lddpc	r12,80004fc8 <rfid_auto_reader+0xf4>
80004f20:	f0 1f 00 29 	mcall	80004fc4 <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004f24:	c2 e8       	rjmp	80004f80 <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004f26:	34 49       	mov	r9,68
80004f28:	f2 08 18 00 	cp.b	r8,r9
80004f2c:	c0 b1       	brne	80004f42 <rfid_auto_reader+0x6e>
80004f2e:	4a 39       	lddpc	r9,80004fb8 <rfid_auto_reader+0xe4>
80004f30:	13 9a       	ld.ub	r10,r9[0x1]
80004f32:	30 09       	mov	r9,0
80004f34:	f2 0a 18 00 	cp.b	r10,r9
80004f38:	c0 51       	brne	80004f42 <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80004f3a:	4a 5c       	lddpc	r12,80004fcc <rfid_auto_reader+0xf8>
80004f3c:	f0 1f 00 22 	mcall	80004fc4 <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004f40:	c2 08       	rjmp	80004f80 <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004f42:	30 89       	mov	r9,8
80004f44:	f2 08 18 00 	cp.b	r8,r9
80004f48:	c0 b1       	brne	80004f5e <rfid_auto_reader+0x8a>
80004f4a:	49 c9       	lddpc	r9,80004fb8 <rfid_auto_reader+0xe4>
80004f4c:	13 9a       	ld.ub	r10,r9[0x1]
80004f4e:	30 09       	mov	r9,0
80004f50:	f2 0a 18 00 	cp.b	r10,r9
80004f54:	c0 51       	brne	80004f5e <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80004f56:	49 fc       	lddpc	r12,80004fd0 <rfid_auto_reader+0xfc>
80004f58:	f0 1f 00 1b 	mcall	80004fc4 <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004f5c:	c1 28       	rjmp	80004f80 <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004f5e:	34 49       	mov	r9,68
80004f60:	f2 08 18 00 	cp.b	r8,r9
80004f64:	c0 b1       	brne	80004f7a <rfid_auto_reader+0xa6>
80004f66:	49 58       	lddpc	r8,80004fb8 <rfid_auto_reader+0xe4>
80004f68:	11 99       	ld.ub	r9,r8[0x1]
80004f6a:	30 38       	mov	r8,3
80004f6c:	f0 09 18 00 	cp.b	r9,r8
80004f70:	c0 51       	brne	80004f7a <rfid_auto_reader+0xa6>
		log("MF Desire\n");
80004f72:	49 9c       	lddpc	r12,80004fd4 <rfid_auto_reader+0x100>
80004f74:	f0 1f 00 14 	mcall	80004fc4 <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004f78:	c0 48       	rjmp	80004f80 <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80004f7a:	49 8c       	lddpc	r12,80004fd8 <rfid_auto_reader+0x104>
80004f7c:	f0 1f 00 12 	mcall	80004fc4 <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80004f80:	49 7c       	lddpc	r12,80004fdc <rfid_auto_reader+0x108>
80004f82:	f0 1f 00 18 	mcall	80004fe0 <rfid_auto_reader+0x10c>
80004f86:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80004f88:	c0 60       	breq	80004f94 <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
80004f8a:	37 8b       	mov	r11,120
80004f8c:	30 1c       	mov	r12,1
80004f8e:	f0 1f 00 16 	mcall	80004fe4 <rfid_auto_reader+0x110>
		return status;
80004f92:	c0 e8       	rjmp	80004fae <rfid_auto_reader+0xda>
	}
	//continue;
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80004f94:	49 2c       	lddpc	r12,80004fdc <rfid_auto_reader+0x108>
80004f96:	f0 1f 00 15 	mcall	80004fe8 <rfid_auto_reader+0x114>
80004f9a:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80004f9c:	c0 91       	brne	80004fae <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80004f9e:	30 4a       	mov	r10,4
80004fa0:	48 fb       	lddpc	r11,80004fdc <rfid_auto_reader+0x108>
80004fa2:	0c 9c       	mov	r12,r6
80004fa4:	f0 1f 00 12 	mcall	80004fec <rfid_auto_reader+0x118>
		log("select okay\n");
80004fa8:	49 2c       	lddpc	r12,80004ff0 <rfid_auto_reader+0x11c>
80004faa:	f0 1f 00 07 	mcall	80004fc4 <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
80004fae:	0e 9c       	mov	r12,r7
80004fb0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004fb4:	80 00       	ld.sh	r0,r0[0x0]
80004fb6:	48 f8       	lddpc	r8,80004ff0 <rfid_auto_reader+0x11c>
80004fb8:	00 00       	add	r0,r0
80004fba:	51 10       	stdsp	sp[0x44],r0
80004fbc:	80 00       	ld.sh	r0,r0[0x0]
80004fbe:	4d 70       	lddpc	r0,80005118 <rfid_sendID_message+0x124>
80004fc0:	80 00       	ld.sh	r0,r0[0x0]
80004fc2:	d5 d0       	acall	0x5d
80004fc4:	80 00       	ld.sh	r0,r0[0x0]
80004fc6:	6d 14       	ld.w	r4,r6[0x44]
80004fc8:	80 00       	ld.sh	r0,r0[0x0]
80004fca:	d5 dc       	*unknown*
80004fcc:	80 00       	ld.sh	r0,r0[0x0]
80004fce:	d5 e8       	*unknown*
80004fd0:	80 00       	ld.sh	r0,r0[0x0]
80004fd2:	d5 f8       	*unknown*
80004fd4:	80 00       	ld.sh	r0,r0[0x0]
80004fd6:	d6 00       	acall	0x60
80004fd8:	80 00       	ld.sh	r0,r0[0x0]
80004fda:	d6 0c       	*unknown*
80004fdc:	00 00       	add	r0,r0
80004fde:	51 14       	stdsp	sp[0x44],r4
80004fe0:	80 00       	ld.sh	r0,r0[0x0]
80004fe2:	4c ec       	lddpc	r12,80005118 <rfid_sendID_message+0x124>
80004fe4:	80 00       	ld.sh	r0,r0[0x0]
80004fe6:	40 20       	lddsp	r0,sp[0x8]
80004fe8:	80 00       	ld.sh	r0,r0[0x0]
80004fea:	4e 60       	lddpc	r0,80005180 <local_start_pll0+0x18>
80004fec:	80 00       	ld.sh	r0,r0[0x0]
80004fee:	75 94       	ld.w	r4,r10[0x64]
80004ff0:	80 00       	ld.sh	r0,r0[0x0]
80004ff2:	d6 18       	*unknown*

80004ff4 <rfid_sendID_message>:


U8 rfid_sendID_message()
{
80004ff4:	eb cd 40 e0 	pushm	r5-r7,lr
80004ff8:	21 ed       	sub	sp,120
	U8 temp =0;
	U8 destination = DEST;
	static U8 start_session = 0x80;
	Message_Header_t header;
	
	memset(data_buffer, 0x00, 16);
80004ffa:	fa ca ff a4 	sub	r10,sp,-92
80004ffe:	30 08       	mov	r8,0
80005000:	30 09       	mov	r9,0
80005002:	f4 e9 00 00 	st.d	r10[0],r8
80005006:	f4 e9 00 08 	st.d	r10[8],r8
	memset(SN, 0x00, 10);
8000500a:	fa cc ff 94 	sub	r12,sp,-108
8000500e:	f8 e9 00 00 	st.d	r12[0],r8
80005012:	30 0a       	mov	r10,0
80005014:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80005016:	fa e9 00 0c 	st.d	sp[12],r8
8000501a:	fa e9 00 14 	st.d	sp[20],r8
8000501e:	fa e9 00 1c 	st.d	sp[28],r8
80005022:	fa e9 00 24 	st.d	sp[36],r8
80005026:	fa e9 00 2c 	st.d	sp[44],r8
8000502a:	fa e9 00 34 	st.d	sp[52],r8
8000502e:	fa e9 00 3c 	st.d	sp[60],r8
80005032:	fa e9 00 44 	st.d	sp[68],r8
80005036:	fa e9 00 4c 	st.d	sp[76],r8
8000503a:	fa e9 00 54 	st.d	sp[84],r8

	return_err = rfid_auto_reader(SN);
8000503e:	f0 1f 00 3f 	mcall	80005138 <rfid_sendID_message+0x144>
80005042:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80005044:	c6 e1       	brne	80005120 <rfid_sendID_message+0x12c>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80005046:	fb 38 00 6f 	ld.ub	r8,sp[111]
8000504a:	1a d8       	st.w	--sp,r8
8000504c:	fb 38 00 72 	ld.ub	r8,sp[114]
80005050:	1a d8       	st.w	--sp,r8
80005052:	fb 38 00 75 	ld.ub	r8,sp[117]
80005056:	1a d8       	st.w	--sp,r8
80005058:	fb 38 00 78 	ld.ub	r8,sp[120]
8000505c:	1a d8       	st.w	--sp,r8
8000505e:	4b 8c       	lddpc	r12,8000513c <rfid_sendID_message+0x148>
80005060:	f0 1f 00 38 	mcall	80005140 <rfid_sendID_message+0x14c>
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
80005064:	37 7b       	mov	r11,119
80005066:	30 1c       	mov	r12,1
80005068:	f0 1f 00 37 	mcall	80005144 <rfid_sendID_message+0x150>
8000506c:	fa c9 ff 84 	sub	r9,sp,-124
80005070:	fa c8 ff 94 	sub	r8,sp,-108
80005074:	fa ca ff 92 	sub	r10,sp,-110
//}
	
}


U8 rfid_sendID_message()
80005078:	fa c5 ff 80 	sub	r5,sp,-128
8000507c:	2f cd       	sub	sp,-16
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer[i*4] = temp+0x30;
8000507e:	30 9e       	mov	lr,9
			 else 
				data_buffer[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer[i*4+1] = 0x00; 
80005080:	30 06       	mov	r6,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80005082:	13 8b       	ld.ub	r11,r9[0x0]
80005084:	f6 0c 16 04 	lsr	r12,r11,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer[i*4] = temp+0x30;
80005088:	fc 0c 18 00 	cp.b	r12,lr
8000508c:	f7 bc 08 d0 	subls	r12,-48
80005090:	f1 fc 8e 00 	st.bls	r8[0x0],r12
			 else 
				data_buffer[i*4] = ((temp - 0x0a)+0x61);
80005094:	f7 bc 0b a9 	subhi	r12,-87
80005098:	f1 fc be 00 	st.bhi	r8[0x0],r12
			
			 data_buffer[i*4+1] = 0x00; 
8000509c:	b0 96       	st.b	r8[0x1],r6
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
8000509e:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer[i*4+2] = temp+0x30;
800050a2:	fc 0b 18 00 	cp.b	r11,lr
800050a6:	f7 bb 08 d0 	subls	r11,-48
800050aa:	f5 fb 8e 00 	st.bls	r10[0x0],r11
			 else
				data_buffer[i*4+2] = ((temp - 0x0a)+0x61);
800050ae:	f7 bb 0b a9 	subhi	r11,-87
800050b2:	f5 fb be 00 	st.bhi	r10[0x0],r11

		 
			 data_buffer[i*4+3] = 0x00; 
800050b6:	b0 b6       	st.b	r8[0x3],r6
800050b8:	2f f9       	sub	r9,-1
800050ba:	2f c8       	sub	r8,-4
800050bc:	2f ca       	sub	r10,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
800050be:	0a 39       	cp.w	r9,r5
800050c0:	ce 11       	brne	80005082 <rfid_sendID_message+0x8e>
			 data_buffer[i*4+3] = 0x00; 
		}
	
		header.length = (0x0008 + sizeof(data_buffer));
	
		if(start_session > 0x9f)start_session = 0x80;
800050c2:	4a 28       	lddpc	r8,80005148 <rfid_sendID_message+0x154>
800050c4:	11 89       	ld.ub	r9,r8[0x0]
800050c6:	39 f8       	mov	r8,-97
800050c8:	f0 09 18 00 	cp.b	r9,r8
800050cc:	e0 88 00 05 	brls	800050d6 <rfid_sendID_message+0xe2>
800050d0:	38 09       	mov	r9,-128
800050d2:	49 e8       	lddpc	r8,80005148 <rfid_sendID_message+0x154>
800050d4:	b0 89       	st.b	r8[0x0],r9
	
		header.session_id = (++start_session);
800050d6:	49 d8       	lddpc	r8,80005148 <rfid_sendID_message+0x154>
800050d8:	11 86       	ld.ub	r6,r8[0x0]
800050da:	2f f6       	sub	r6,-1
800050dc:	b0 86       	st.b	r8[0x0],r6
	
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
800050de:	30 5a       	mov	r10,5
800050e0:	49 bb       	lddpc	r11,8000514c <rfid_sendID_message+0x158>
800050e2:	fa cc ff f9 	sub	r12,sp,-7
800050e6:	f0 1f 00 1b 	mcall	80005150 <rfid_sendID_message+0x15c>
		header.type = 0xe000;
	
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
800050ea:	31 88       	mov	r8,24
800050ec:	ba 18       	st.h	sp[0x2],r8
800050ee:	ba e6       	st.b	sp[0x6],r6
800050f0:	fe 78 e0 00 	mov	r8,-8192
800050f4:	ba 28       	st.h	sp[0x4],r8
800050f6:	fa c6 ff f4 	sub	r6,sp,-12
800050fa:	30 aa       	mov	r10,10
800050fc:	fa cb ff fe 	sub	r11,sp,-2
80005100:	0c 9c       	mov	r12,r6
80005102:	f0 1f 00 14 	mcall	80005150 <rfid_sendID_message+0x15c>
		memcpy(&message[sizeof(Message_Header_t)], data_buffer, sizeof(data_buffer));//疯淇″瀹规版
80005106:	31 0a       	mov	r10,16
80005108:	fa cb ff a4 	sub	r11,sp,-92
8000510c:	fa cc ff ea 	sub	r12,sp,-22
80005110:	f0 1f 00 10 	mcall	80005150 <rfid_sendID_message+0x15c>
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(data_buffer)), destination);
80005114:	30 9a       	mov	r10,9
80005116:	31 ab       	mov	r11,26
80005118:	0c 9c       	mov	r12,r6
8000511a:	f0 1f 00 0f 	mcall	80005154 <rfid_sendID_message+0x160>
8000511e:	c0 88       	rjmp	8000512e <rfid_sendID_message+0x13a>
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate scan rfid failure!!!
80005120:	37 8b       	mov	r11,120
80005122:	30 1c       	mov	r12,1
80005124:	f0 1f 00 08 	mcall	80005144 <rfid_sendID_message+0x150>
		log("no card find...\n");
80005128:	48 cc       	lddpc	r12,80005158 <rfid_sendID_message+0x164>
8000512a:	f0 1f 00 06 	mcall	80005140 <rfid_sendID_message+0x14c>
	}
	
	return return_err;
	
}
8000512e:	0e 9c       	mov	r12,r7
80005130:	2e 2d       	sub	sp,-120
80005132:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005136:	00 00       	add	r0,r0
80005138:	80 00       	ld.sh	r0,r0[0x0]
8000513a:	4e d4       	lddpc	r4,800052ec <gpio_set_gpio_pin+0x4>
8000513c:	80 00       	ld.sh	r0,r0[0x0]
8000513e:	d6 28       	*unknown*
80005140:	80 00       	ld.sh	r0,r0[0x0]
80005142:	6d 14       	ld.w	r4,r6[0x44]
80005144:	80 00       	ld.sh	r0,r0[0x0]
80005146:	40 20       	lddsp	r0,sp[0x8]
80005148:	00 00       	add	r0,r0
8000514a:	05 30       	ld.ub	r0,r2++
8000514c:	00 00       	add	r0,r0
8000514e:	05 28       	ld.uh	r8,r2++
80005150:	80 00       	ld.sh	r0,r0[0x0]
80005152:	75 94       	ld.w	r4,r10[0x64]
80005154:	80 00       	ld.sh	r0,r0[0x0]
80005156:	3e e8       	mov	r8,-18
80005158:	80 00       	ld.sh	r0,r0[0x0]
8000515a:	d6 44       	*unknown*

8000515c <rfid_init>:
U8 RFID[16];			//瀛RFID
U8 unsure_data[5]={0x04, 0x0d, 0x00, 0x0a, 0x00};


void rfid_init()
{
8000515c:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
8000515e:	f0 1f 00 02 	mcall	80005164 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		
}
80005162:	d8 02       	popm	pc
80005164:	80 00       	ld.sh	r0,r0[0x0]
80005166:	4a a4       	lddpc	r4,8000520c <delay_ms+0x14>

80005168 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80005168:	fe 78 0c 00 	mov	r8,-62464
8000516c:	e0 69 03 07 	mov	r9,775
80005170:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80005172:	30 49       	mov	r9,4
80005174:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80005176:	71 59       	ld.w	r9,r8[0x54]
80005178:	e2 19 00 80 	andl	r9,0x80,COH
8000517c:	cf d0       	breq	80005176 <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
8000517e:	fe 78 0c 00 	mov	r8,-62464
80005182:	30 59       	mov	r9,5
80005184:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80005186:	e0 69 01 0d 	mov	r9,269
8000518a:	ea 19 10 07 	orh	r9,0x1007
8000518e:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80005190:	71 59       	ld.w	r9,r8[0x54]
80005192:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80005196:	cf d0       	breq	80005190 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80005198:	fe 78 0c 00 	mov	r8,-62464
8000519c:	fc 19 00 80 	movh	r9,0x80
800051a0:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
800051a2:	34 0a       	mov	r10,64
800051a4:	fe 69 14 00 	mov	r9,-125952
800051a8:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
800051aa:	30 69       	mov	r9,6
800051ac:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
800051ae:	30 19       	mov	r9,1
800051b0:	fe 68 10 00 	mov	r8,-126976
800051b4:	91 19       	st.w	r8[0x4],r9
	flashc_set_wait_state(1);
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
****/
}
800051b6:	5e fc       	retal	r12

800051b8 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
800051b8:	58 0c       	cp.w	r12,0
800051ba:	5e 0c       	reteq	r12
800051bc:	30 08       	mov	r8,0
	{
		nop();
800051be:	d7 03       	nop
		nop();
800051c0:	d7 03       	nop
		nop();
800051c2:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
800051c4:	2f f8       	sub	r8,-1
800051c6:	10 3c       	cp.w	r12,r8
800051c8:	fe 9b ff fb 	brhi	800051be <delay_ns+0x6>
800051cc:	5e fc       	retal	r12
800051ce:	d7 03       	nop

800051d0 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
800051d0:	eb cd 40 e0 	pushm	r5-r7,lr
800051d4:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
800051d6:	58 0c       	cp.w	r12,0
800051d8:	c0 b0       	breq	800051ee <delay_us+0x1e>
800051da:	30 07       	mov	r7,0
		delay_ns(1000);
800051dc:	e0 65 03 e8 	mov	r5,1000
800051e0:	0a 9c       	mov	r12,r5
800051e2:	f0 1f 00 05 	mcall	800051f4 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
800051e6:	2f f7       	sub	r7,-1
800051e8:	0e 36       	cp.w	r6,r7
800051ea:	fe 9b ff fb 	brhi	800051e0 <delay_us+0x10>
800051ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800051f2:	00 00       	add	r0,r0
800051f4:	80 00       	ld.sh	r0,r0[0x0]
800051f6:	51 b8       	stdsp	sp[0x6c],r8

800051f8 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
800051f8:	eb cd 40 e0 	pushm	r5-r7,lr
800051fc:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
800051fe:	58 0c       	cp.w	r12,0
80005200:	c0 b0       	breq	80005216 <delay_ms+0x1e>
80005202:	30 07       	mov	r7,0
		delay_us(1000);
80005204:	e0 65 03 e8 	mov	r5,1000
80005208:	0a 9c       	mov	r12,r5
8000520a:	f0 1f 00 05 	mcall	8000521c <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
8000520e:	2f f7       	sub	r7,-1
80005210:	0e 36       	cp.w	r6,r7
80005212:	fe 9b ff fb 	brhi	80005208 <delay_ms+0x10>
80005216:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000521a:	00 00       	add	r0,r0
8000521c:	80 00       	ld.sh	r0,r0[0x0]
8000521e:	51 d0       	stdsp	sp[0x74],r0

80005220 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80005220:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80005222:	30 3b       	mov	r11,3
80005224:	48 8c       	lddpc	r12,80005244 <local_start_timer+0x24>
80005226:	f0 1f 00 09 	mcall	80005248 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
8000522a:	fe 78 38 00 	mov	r8,-51200
8000522e:	e0 69 91 0d 	mov	r9,37133
80005232:	ea 19 00 52 	orh	r9,0x52
80005236:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005238:	32 09       	mov	r9,32
8000523a:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
8000523c:	30 59       	mov	r9,5
8000523e:	91 09       	st.w	r8[0x0],r9
}
80005240:	d8 02       	popm	pc
80005242:	00 00       	add	r0,r0
80005244:	80 00       	ld.sh	r0,r0[0x0]
80005246:	d6 58       	*unknown*
80005248:	80 00       	ld.sh	r0,r0[0x0]
8000524a:	52 a0       	stdsp	sp[0xa8],r0

8000524c <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000524c:	f8 08 16 05 	lsr	r8,r12,0x5
80005250:	a9 68       	lsl	r8,0x8
80005252:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80005256:	58 1b       	cp.w	r11,1
80005258:	c0 d0       	breq	80005272 <gpio_enable_module_pin+0x26>
8000525a:	c0 63       	brcs	80005266 <gpio_enable_module_pin+0x1a>
8000525c:	58 2b       	cp.w	r11,2
8000525e:	c1 00       	breq	8000527e <gpio_enable_module_pin+0x32>
80005260:	58 3b       	cp.w	r11,3
80005262:	c1 40       	breq	8000528a <gpio_enable_module_pin+0x3e>
80005264:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005266:	30 19       	mov	r9,1
80005268:	f2 0c 09 49 	lsl	r9,r9,r12
8000526c:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000526e:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005270:	c1 28       	rjmp	80005294 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005272:	30 19       	mov	r9,1
80005274:	f2 0c 09 49 	lsl	r9,r9,r12
80005278:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000527a:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000527c:	c0 c8       	rjmp	80005294 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000527e:	30 19       	mov	r9,1
80005280:	f2 0c 09 49 	lsl	r9,r9,r12
80005284:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005286:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005288:	c0 68       	rjmp	80005294 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000528a:	30 19       	mov	r9,1
8000528c:	f2 0c 09 49 	lsl	r9,r9,r12
80005290:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005292:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80005294:	30 19       	mov	r9,1
80005296:	f2 0c 09 4c 	lsl	r12,r9,r12
8000529a:	91 2c       	st.w	r8[0x8],r12
8000529c:	5e fd       	retal	0
8000529e:	d7 03       	nop

800052a0 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800052a0:	d4 21       	pushm	r4-r7,lr
800052a2:	18 97       	mov	r7,r12
800052a4:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800052a6:	58 0b       	cp.w	r11,0
800052a8:	c0 31       	brne	800052ae <gpio_enable_module+0xe>
800052aa:	30 05       	mov	r5,0
800052ac:	c0 d8       	rjmp	800052c6 <gpio_enable_module+0x26>
800052ae:	30 06       	mov	r6,0
800052b0:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800052b2:	6e 1b       	ld.w	r11,r7[0x4]
800052b4:	6e 0c       	ld.w	r12,r7[0x0]
800052b6:	f0 1f 00 06 	mcall	800052cc <gpio_enable_module+0x2c>
800052ba:	18 45       	or	r5,r12
		gpiomap++;
800052bc:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800052be:	2f f6       	sub	r6,-1
800052c0:	0c 34       	cp.w	r4,r6
800052c2:	fe 9b ff f8 	brhi	800052b2 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
800052c6:	0a 9c       	mov	r12,r5
800052c8:	d8 22       	popm	r4-r7,pc
800052ca:	00 00       	add	r0,r0
800052cc:	80 00       	ld.sh	r0,r0[0x0]
800052ce:	52 4c       	stdsp	sp[0x90],r12

800052d0 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800052d0:	f8 08 16 05 	lsr	r8,r12,0x5
800052d4:	a9 68       	lsl	r8,0x8
800052d6:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
800052da:	30 19       	mov	r9,1
800052dc:	f2 0c 09 4c 	lsl	r12,r9,r12
800052e0:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
800052e4:	91 1c       	st.w	r8[0x4],r12
}
800052e6:	5e fc       	retal	r12

800052e8 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800052e8:	f8 08 16 05 	lsr	r8,r12,0x5
800052ec:	a9 68       	lsl	r8,0x8
800052ee:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
800052f2:	30 19       	mov	r9,1
800052f4:	f2 0c 09 4c 	lsl	r12,r9,r12
800052f8:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
800052fc:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005300:	91 1c       	st.w	r8[0x4],r12
}
80005302:	5e fc       	retal	r12

80005304 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005304:	f8 08 16 05 	lsr	r8,r12,0x5
80005308:	a9 68       	lsl	r8,0x8
8000530a:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
8000530e:	30 19       	mov	r9,1
80005310:	f2 0c 09 4c 	lsl	r12,r9,r12
80005314:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80005318:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000531c:	91 1c       	st.w	r8[0x4],r12
}
8000531e:	5e fc       	retal	r12

80005320 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80005320:	c0 08       	rjmp	80005320 <_unhandled_interrupt>
80005322:	d7 03       	nop

80005324 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005324:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005328:	49 99       	lddpc	r9,8000538c <INTC_register_interrupt+0x68>
8000532a:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000532e:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80005332:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80005334:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80005338:	58 0a       	cp.w	r10,0
8000533a:	c0 91       	brne	8000534c <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000533c:	49 59       	lddpc	r9,80005390 <INTC_register_interrupt+0x6c>
8000533e:	49 6a       	lddpc	r10,80005394 <INTC_register_interrupt+0x70>
80005340:	12 1a       	sub	r10,r9
80005342:	fe 79 08 00 	mov	r9,-63488
80005346:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000534a:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
8000534c:	58 1a       	cp.w	r10,1
8000534e:	c0 a1       	brne	80005362 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80005350:	49 09       	lddpc	r9,80005390 <INTC_register_interrupt+0x6c>
80005352:	49 2a       	lddpc	r10,80005398 <INTC_register_interrupt+0x74>
80005354:	12 1a       	sub	r10,r9
80005356:	bf aa       	sbr	r10,0x1e
80005358:	fe 79 08 00 	mov	r9,-63488
8000535c:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005360:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80005362:	58 2a       	cp.w	r10,2
80005364:	c0 a1       	brne	80005378 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80005366:	48 b9       	lddpc	r9,80005390 <INTC_register_interrupt+0x6c>
80005368:	48 da       	lddpc	r10,8000539c <INTC_register_interrupt+0x78>
8000536a:	12 1a       	sub	r10,r9
8000536c:	bf ba       	sbr	r10,0x1f
8000536e:	fe 79 08 00 	mov	r9,-63488
80005372:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005376:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80005378:	48 69       	lddpc	r9,80005390 <INTC_register_interrupt+0x6c>
8000537a:	48 aa       	lddpc	r10,800053a0 <INTC_register_interrupt+0x7c>
8000537c:	12 1a       	sub	r10,r9
8000537e:	ea 1a c0 00 	orh	r10,0xc000
80005382:	fe 79 08 00 	mov	r9,-63488
80005386:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000538a:	5e fc       	retal	r12
8000538c:	80 00       	ld.sh	r0,r0[0x0]
8000538e:	d6 70       	acall	0x67
80005390:	80 00       	ld.sh	r0,r0[0x0]
80005392:	cc 00       	breq	80005312 <gpio_clr_gpio_pin+0xe>
80005394:	80 00       	ld.sh	r0,r0[0x0]
80005396:	cd 04       	brge	80005336 <INTC_register_interrupt+0x12>
80005398:	80 00       	ld.sh	r0,r0[0x0]
8000539a:	cd 12       	brcc	8000533c <INTC_register_interrupt+0x18>
8000539c:	80 00       	ld.sh	r0,r0[0x0]
8000539e:	cd 20       	breq	80005342 <INTC_register_interrupt+0x1e>
800053a0:	80 00       	ld.sh	r0,r0[0x0]
800053a2:	cd 2e       	rcall	80005146 <rfid_sendID_message+0x152>

800053a4 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800053a4:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800053a6:	49 18       	lddpc	r8,800053e8 <INTC_init_interrupts+0x44>
800053a8:	e3 b8 00 01 	mtsr	0x4,r8
800053ac:	49 0e       	lddpc	lr,800053ec <INTC_init_interrupts+0x48>
800053ae:	30 07       	mov	r7,0
800053b0:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800053b2:	49 0c       	lddpc	r12,800053f0 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800053b4:	49 05       	lddpc	r5,800053f4 <INTC_init_interrupts+0x50>
800053b6:	10 15       	sub	r5,r8
800053b8:	fe 76 08 00 	mov	r6,-63488
800053bc:	c1 08       	rjmp	800053dc <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800053be:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800053c0:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800053c2:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800053c4:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800053c8:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800053ca:	10 3a       	cp.w	r10,r8
800053cc:	fe 9b ff fc 	brhi	800053c4 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800053d0:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800053d4:	2f f7       	sub	r7,-1
800053d6:	2f 8e       	sub	lr,-8
800053d8:	59 37       	cp.w	r7,19
800053da:	c0 50       	breq	800053e4 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800053dc:	7c 08       	ld.w	r8,lr[0x0]
800053de:	58 08       	cp.w	r8,0
800053e0:	ce f1       	brne	800053be <INTC_init_interrupts+0x1a>
800053e2:	cf 7b       	rjmp	800053d0 <INTC_init_interrupts+0x2c>
800053e4:	d8 22       	popm	r4-r7,pc
800053e6:	00 00       	add	r0,r0
800053e8:	80 00       	ld.sh	r0,r0[0x0]
800053ea:	cc 00       	breq	8000536a <INTC_register_interrupt+0x46>
800053ec:	80 00       	ld.sh	r0,r0[0x0]
800053ee:	d6 70       	acall	0x67
800053f0:	80 00       	ld.sh	r0,r0[0x0]
800053f2:	53 20       	stdsp	sp[0xc8],r0
800053f4:	80 00       	ld.sh	r0,r0[0x0]
800053f6:	cd 04       	brge	80005396 <INTC_register_interrupt+0x72>

800053f8 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800053f8:	fe 78 08 00 	mov	r8,-63488
800053fc:	e0 69 00 83 	mov	r9,131
80005400:	f2 0c 01 0c 	sub	r12,r9,r12
80005404:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005408:	f2 ca ff c0 	sub	r10,r9,-64
8000540c:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005410:	58 08       	cp.w	r8,0
80005412:	c0 21       	brne	80005416 <_get_interrupt_handler+0x1e>
80005414:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80005416:	f0 08 12 00 	clz	r8,r8
8000541a:	48 5a       	lddpc	r10,8000542c <_get_interrupt_handler+0x34>
8000541c:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005420:	f0 08 11 1f 	rsub	r8,r8,31
80005424:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005426:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000542a:	5e fc       	retal	r12
8000542c:	80 00       	ld.sh	r0,r0[0x0]
8000542e:	d6 70       	acall	0x67

80005430 <pm_set_osc32_mode>:
 * \param mode 32-kHz oscillator mode (i.e. AVR32_PM_OSCCTRL32_MODE_x).
 */
static void pm_set_osc32_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
80005430:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.mode = mode;
80005432:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
80005436:	99 c8       	st.w	r12[0x30],r8
}
80005438:	5e fc       	retal	r12
8000543a:	d7 03       	nop

8000543c <pm_enable_osc32_crystal>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
}


void pm_enable_osc32_crystal(volatile avr32_pm_t *pm)
{
8000543c:	d4 01       	pushm	lr
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
8000543e:	30 1b       	mov	r11,1
80005440:	f0 1f 00 02 	mcall	80005448 <pm_enable_osc32_crystal+0xc>
}
80005444:	d8 02       	popm	pc
80005446:	00 00       	add	r0,r0
80005448:	80 00       	ld.sh	r0,r0[0x0]
8000544a:	54 30       	stdsp	sp[0x10c],r0

8000544c <pm_enable_clk32_no_wait>:


void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
8000544c:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.osc32en = 1;
8000544e:	30 19       	mov	r9,1
80005450:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_pm_oscctrl32.OSCCTRL32.startup = startup;
80005454:	f1 db d2 03 	bfins	r8,r11,0x10,0x3
  // Write back
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
80005458:	99 c8       	st.w	r12[0x30],r8
}
8000545a:	5e fc       	retal	r12

8000545c <pm_wait_for_clk32_ready>:


void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC32RDY_MASK));
8000545c:	79 58       	ld.w	r8,r12[0x54]
8000545e:	e2 18 02 00 	andl	r8,0x200,COH
80005462:	cf d0       	breq	8000545c <pm_wait_for_clk32_ready>
}
80005464:	5e fc       	retal	r12
80005466:	d7 03       	nop

80005468 <pm_enable_clk32>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
}


void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup)
{
80005468:	eb cd 40 80 	pushm	r7,lr
8000546c:	18 97       	mov	r7,r12
  pm_enable_clk32_no_wait(pm, startup);
8000546e:	f0 1f 00 04 	mcall	8000547c <pm_enable_clk32+0x14>
  pm_wait_for_clk32_ready(pm);
80005472:	0e 9c       	mov	r12,r7
80005474:	f0 1f 00 03 	mcall	80005480 <pm_enable_clk32+0x18>
}
80005478:	e3 cd 80 80 	ldm	sp++,r7,pc
8000547c:	80 00       	ld.sh	r0,r0[0x0]
8000547e:	54 4c       	stdsp	sp[0x110],r12
80005480:	80 00       	ld.sh	r0,r0[0x0]
80005482:	54 5c       	stdsp	sp[0x114],r12

80005484 <rtc_is_busy>:
#include "rtc.h"


int rtc_is_busy(volatile avr32_rtc_t *rtc)
{
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
80005484:	78 0c       	ld.w	r12,r12[0x0]
}
80005486:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
8000548a:	5e fc       	retal	r12

8000548c <rtc_set_value>:
  return 1;
}


void rtc_set_value(volatile avr32_rtc_t *rtc, unsigned long val)
{
8000548c:	eb cd 40 c0 	pushm	r6-r7,lr
80005490:	18 97       	mov	r7,r12
80005492:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
80005494:	0e 9c       	mov	r12,r7
80005496:	f0 1f 00 06 	mcall	800054ac <rtc_set_value+0x20>
8000549a:	cf d1       	brne	80005494 <rtc_set_value+0x8>
  // Set the new val value
  rtc->val = val;
8000549c:	8f 16       	st.w	r7[0x4],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
8000549e:	0e 9c       	mov	r12,r7
800054a0:	f0 1f 00 03 	mcall	800054ac <rtc_set_value+0x20>
800054a4:	cf d1       	brne	8000549e <rtc_set_value+0x12>
}
800054a6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800054aa:	00 00       	add	r0,r0
800054ac:	80 00       	ld.sh	r0,r0[0x0]
800054ae:	54 84       	stdsp	sp[0x120],r4

800054b0 <rtc_enable>:
  while (rtc_is_busy(rtc));
}


void rtc_enable(volatile avr32_rtc_t *rtc)
{
800054b0:	eb cd 40 80 	pushm	r7,lr
800054b4:	18 97       	mov	r7,r12
  // Wait until the rtc CTRL register is up-to-date
  while (rtc_is_busy(rtc));
800054b6:	0e 9c       	mov	r12,r7
800054b8:	f0 1f 00 06 	mcall	800054d0 <rtc_enable+0x20>
800054bc:	cf d1       	brne	800054b6 <rtc_enable+0x6>
  // Enable the RTC
  rtc->ctrl |= AVR32_RTC_CTRL_EN_MASK;
800054be:	6e 08       	ld.w	r8,r7[0x0]
800054c0:	a1 a8       	sbr	r8,0x0
800054c2:	8f 08       	st.w	r7[0x0],r8
  // Wait until write is done
  while (rtc_is_busy(rtc));
800054c4:	0e 9c       	mov	r12,r7
800054c6:	f0 1f 00 03 	mcall	800054d0 <rtc_enable+0x20>
800054ca:	cf d1       	brne	800054c4 <rtc_enable+0x14>
}
800054cc:	e3 cd 80 80 	ldm	sp++,r7,pc
800054d0:	80 00       	ld.sh	r0,r0[0x0]
800054d2:	54 84       	stdsp	sp[0x120],r4

800054d4 <rtc_enable_interrupt>:
}


void rtc_enable_interrupt(volatile avr32_rtc_t *rtc)
{
  rtc->ier = AVR32_RTC_IER_TOPI_MASK;
800054d4:	30 18       	mov	r8,1
800054d6:	99 48       	st.w	r12[0x10],r8
}
800054d8:	5e fc       	retal	r12
800054da:	d7 03       	nop

800054dc <rtc_set_top_value>:
  if (global_interrupt_enabled) cpu_irq_enable();
}


void rtc_set_top_value(volatile avr32_rtc_t *rtc, unsigned long top)
{
800054dc:	eb cd 40 c0 	pushm	r6-r7,lr
800054e0:	18 97       	mov	r7,r12
800054e2:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
800054e4:	0e 9c       	mov	r12,r7
800054e6:	f0 1f 00 06 	mcall	800054fc <rtc_set_top_value+0x20>
800054ea:	cf d1       	brne	800054e4 <rtc_set_top_value+0x8>
  // Set the new val value
  rtc->top = top;
800054ec:	8f 26       	st.w	r7[0x8],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
800054ee:	0e 9c       	mov	r12,r7
800054f0:	f0 1f 00 03 	mcall	800054fc <rtc_set_top_value+0x20>
800054f4:	cf d1       	brne	800054ee <rtc_set_top_value+0x12>
}
800054f6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800054fa:	00 00       	add	r0,r0
800054fc:	80 00       	ld.sh	r0,r0[0x0]
800054fe:	54 84       	stdsp	sp[0x120],r4

80005500 <rtc_clear_interrupt>:
}


void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005500:	e1 b8 00 00 	mfsr	r8,0x0

  if (global_interrupt_enabled) cpu_irq_disable();
80005504:	e6 18 00 01 	andh	r8,0x1,COH
80005508:	c0 71       	brne	80005516 <rtc_clear_interrupt+0x16>
8000550a:	d3 03       	ssrf	0x10
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
8000550c:	30 18       	mov	r8,1
8000550e:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80005510:	78 78       	ld.w	r8,r12[0x1c]
  if (global_interrupt_enabled) cpu_irq_enable();
80005512:	d5 03       	csrf	0x10
80005514:	5e fc       	retal	r12
void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  if (global_interrupt_enabled) cpu_irq_disable();
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
80005516:	30 18       	mov	r8,1
80005518:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
8000551a:	78 78       	ld.w	r8,r12[0x1c]
8000551c:	5e fc       	retal	r12
8000551e:	d7 03       	nop

80005520 <rtc_init>:
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
}


int rtc_init(volatile avr32_rtc_t *rtc, unsigned char osc_type, unsigned char psel)
{
80005520:	eb cd 40 e0 	pushm	r5-r7,lr
80005524:	18 97       	mov	r7,r12
80005526:	16 96       	mov	r6,r11
80005528:	14 95       	mov	r5,r10
  // If exit, it means that the configuration has not been set correctly
  if (osc_type > (1 << AVR32_RTC_CTRL_CLK32_SIZE) - 1 ||
8000552a:	30 18       	mov	r8,1
8000552c:	f0 0b 18 00 	cp.b	r11,r8
80005530:	5f b9       	srhi	r9
80005532:	30 f8       	mov	r8,15
80005534:	f0 0a 18 00 	cp.b	r10,r8
80005538:	5f b8       	srhi	r8
8000553a:	f3 e8 10 08 	or	r8,r9,r8
8000553e:	c0 30       	breq	80005544 <rtc_init+0x24>
80005540:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
      psel > (1 << AVR32_RTC_CTRL_PSEL_SIZE) - 1)
    return 0;

  // If we use the 32-kHz oscillator, we have to enable it first
  if (osc_type == RTC_OSC_32KHZ)
80005544:	30 18       	mov	r8,1
80005546:	f0 0b 18 00 	cp.b	r11,r8
8000554a:	c0 a1       	brne	8000555e <rtc_init+0x3e>
  {
    // Select the 32-kHz oscillator crystal
    pm_enable_osc32_crystal(&AVR32_PM);
8000554c:	fe 7c 0c 00 	mov	r12,-62464
80005550:	f0 1f 00 0f 	mcall	8000558c <rtc_init+0x6c>
    // Enable the 32-kHz clock and wait until the osc32 clock is ready.
    pm_enable_clk32(&AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC);
80005554:	30 0b       	mov	r11,0
80005556:	fe 7c 0c 00 	mov	r12,-62464
8000555a:	f0 1f 00 0e 	mcall	80005590 <rtc_init+0x70>
  }

  // Wait until the rtc accepts writes to the CTRL register
  while (rtc_is_busy(rtc));
8000555e:	0e 9c       	mov	r12,r7
80005560:	f0 1f 00 0d 	mcall	80005594 <rtc_init+0x74>
80005564:	cf d1       	brne	8000555e <rtc_init+0x3e>

  // Set the new RTC configuration
  rtc->ctrl = osc_type << AVR32_RTC_CTRL_CLK32_OFFSET |
80005566:	a3 76       	lsl	r6,0x3
80005568:	b1 a6       	sbr	r6,0x10
8000556a:	ed e5 10 85 	or	r5,r6,r5<<0x8
8000556e:	8f 05       	st.w	r7[0x0],r5
              psel << AVR32_RTC_CTRL_PSEL_OFFSET |
              AVR32_RTC_CTRL_CLKEN_MASK;

  // Wait until write is done
  while (rtc_is_busy(rtc));
80005570:	0e 9c       	mov	r12,r7
80005572:	f0 1f 00 09 	mcall	80005594 <rtc_init+0x74>
80005576:	cf d1       	brne	80005570 <rtc_init+0x50>

  // Set the counter value to 0
  rtc_set_value(rtc, 0x00000000);
80005578:	30 0b       	mov	r11,0
8000557a:	0e 9c       	mov	r12,r7
8000557c:	f0 1f 00 07 	mcall	80005598 <rtc_init+0x78>
  // Set the top value to 0xFFFFFFFF
  rtc_set_top_value(rtc, 0xFFFFFFFF);
80005580:	3f fb       	mov	r11,-1
80005582:	0e 9c       	mov	r12,r7
80005584:	f0 1f 00 06 	mcall	8000559c <rtc_init+0x7c>
80005588:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
8000558c:	80 00       	ld.sh	r0,r0[0x0]
8000558e:	54 3c       	stdsp	sp[0x10c],r12
80005590:	80 00       	ld.sh	r0,r0[0x0]
80005592:	54 68       	stdsp	sp[0x118],r8
80005594:	80 00       	ld.sh	r0,r0[0x0]
80005596:	54 84       	stdsp	sp[0x120],r4
80005598:	80 00       	ld.sh	r0,r0[0x0]
8000559a:	54 8c       	stdsp	sp[0x120],r12
8000559c:	80 00       	ld.sh	r0,r0[0x0]
8000559e:	54 dc       	stdsp	sp[0x134],r12

800055a0 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
800055a0:	f8 c8 00 01 	sub	r8,r12,1
800055a4:	f0 0b 00 0b 	add	r11,r8,r11
800055a8:	f6 0c 0d 0a 	divu	r10,r11,r12
800055ac:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
800055ae:	f4 c8 00 01 	sub	r8,r10,1
800055b2:	e0 48 00 fe 	cp.w	r8,254
800055b6:	e0 88 00 03 	brls	800055bc <getBaudDiv+0x1c>
800055ba:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
800055bc:	5c 8c       	casts.h	r12
}
800055be:	5e fc       	retal	r12

800055c0 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800055c0:	f7 39 00 0d 	ld.ub	r9,r11[13]
800055c4:	30 18       	mov	r8,1
800055c6:	f0 09 18 00 	cp.b	r9,r8
800055ca:	e0 88 00 04 	brls	800055d2 <spi_initMaster+0x12>
800055ce:	30 2c       	mov	r12,2
800055d0:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800055d2:	e0 68 00 80 	mov	r8,128
800055d6:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
800055d8:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
800055da:	30 19       	mov	r9,1
800055dc:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800055e0:	f7 39 00 0d 	ld.ub	r9,r11[13]
800055e4:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
800055e8:	30 09       	mov	r9,0
800055ea:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800055ee:	30 fa       	mov	r10,15
800055f0:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
800055f4:	99 18       	st.w	r12[0x4],r8
800055f6:	5e f9       	retal	r9

800055f8 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800055f8:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
800055fa:	30 18       	mov	r8,1
800055fc:	f0 0b 18 00 	cp.b	r11,r8
80005600:	5f be       	srhi	lr
80005602:	f0 0a 18 00 	cp.b	r10,r8
80005606:	5f b8       	srhi	r8
80005608:	fd e8 10 08 	or	r8,lr,r8
8000560c:	c0 30       	breq	80005612 <spi_selectionMode+0x1a>
8000560e:	30 2c       	mov	r12,2
80005610:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80005612:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80005614:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005618:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
8000561c:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80005620:	99 18       	st.w	r12[0x4],r8
80005622:	d8 0a       	popm	pc,r12=0

80005624 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80005624:	30 18       	mov	r8,1
80005626:	99 08       	st.w	r12[0x0],r8
}
80005628:	5e fc       	retal	r12

8000562a <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
8000562a:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000562e:	c0 58       	rjmp	80005638 <spi_write+0xe>
		if (!timeout--) {
80005630:	58 08       	cp.w	r8,0
80005632:	c0 21       	brne	80005636 <spi_write+0xc>
80005634:	5e ff       	retal	1
80005636:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005638:	78 49       	ld.w	r9,r12[0x10]
8000563a:	e2 19 00 02 	andl	r9,0x2,COH
8000563e:	cf 90       	breq	80005630 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005640:	5c 7b       	castu.h	r11
80005642:	99 3b       	st.w	r12[0xc],r11
80005644:	5e fd       	retal	0

80005646 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80005646:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
8000564a:	c0 58       	rjmp	80005654 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
8000564c:	58 08       	cp.w	r8,0
8000564e:	c0 21       	brne	80005652 <spi_read+0xc>
80005650:	5e ff       	retal	1
80005652:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005654:	78 49       	ld.w	r9,r12[0x10]
80005656:	e2 19 02 01 	andl	r9,0x201,COH
8000565a:	e0 49 02 01 	cp.w	r9,513
8000565e:	cf 71       	brne	8000564c <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005660:	78 28       	ld.w	r8,r12[0x8]
80005662:	b6 08       	st.h	r11[0x0],r8
80005664:	5e fd       	retal	0
80005666:	d7 03       	nop

80005668 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80005668:	eb cd 40 f8 	pushm	r3-r7,lr
8000566c:	18 95       	mov	r5,r12
8000566e:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005670:	f7 36 00 0c 	ld.ub	r6,r11[12]
80005674:	30 38       	mov	r8,3
80005676:	f0 06 18 00 	cp.b	r6,r8
8000567a:	e0 8b 00 5e 	brhi	80005736 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
8000567e:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005682:	30 18       	mov	r8,1
80005684:	f0 04 18 00 	cp.b	r4,r8
80005688:	e0 8b 00 57 	brhi	80005736 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
8000568c:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005690:	30 78       	mov	r8,7
80005692:	f0 03 18 00 	cp.b	r3,r8
80005696:	e0 88 00 50 	brls	80005736 <spi_setupChipReg+0xce>
8000569a:	31 08       	mov	r8,16
8000569c:	f0 03 18 00 	cp.b	r3,r8
800056a0:	e0 8b 00 4b 	brhi	80005736 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
800056a4:	14 9b       	mov	r11,r10
800056a6:	6e 1c       	ld.w	r12,r7[0x4]
800056a8:	f0 1f 00 26 	mcall	80005740 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
800056ac:	c4 55       	brlt	80005736 <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
800056ae:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
800056b0:	ec 09 16 01 	lsr	r9,r6,0x1
800056b4:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800056b8:	ec 16 00 01 	eorl	r6,0x1
800056bc:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
800056c0:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800056c4:	20 83       	sub	r3,8
800056c6:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
800056ca:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
800056ce:	ef 39 00 09 	ld.ub	r9,r7[9]
800056d2:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
800056d6:	ef 39 00 0a 	ld.ub	r9,r7[10]
800056da:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
800056de:	0f 89       	ld.ub	r9,r7[0x0]
800056e0:	30 1a       	mov	r10,1
800056e2:	f4 09 18 00 	cp.b	r9,r10
800056e6:	c0 d0       	breq	80005700 <spi_setupChipReg+0x98>
800056e8:	c0 a3       	brcs	800056fc <spi_setupChipReg+0x94>
800056ea:	30 2a       	mov	r10,2
800056ec:	f4 09 18 00 	cp.b	r9,r10
800056f0:	c0 a0       	breq	80005704 <spi_setupChipReg+0x9c>
800056f2:	30 3a       	mov	r10,3
800056f4:	f4 09 18 00 	cp.b	r9,r10
800056f8:	c1 f1       	brne	80005736 <spi_setupChipReg+0xce>
800056fa:	c0 78       	rjmp	80005708 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
800056fc:	8b c8       	st.w	r5[0x30],r8
		break;
800056fe:	c0 68       	rjmp	8000570a <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80005700:	8b d8       	st.w	r5[0x34],r8
		break;
80005702:	c0 48       	rjmp	8000570a <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80005704:	8b e8       	st.w	r5[0x38],r8
		break;
80005706:	c0 28       	rjmp	8000570a <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80005708:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
8000570a:	48 f8       	lddpc	r8,80005744 <spi_setupChipReg+0xdc>
8000570c:	70 08       	ld.w	r8,r8[0x0]
8000570e:	58 08       	cp.w	r8,0
80005710:	c1 61       	brne	8000573c <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
80005712:	30 0b       	mov	r11,0
80005714:	30 1c       	mov	r12,1
80005716:	f0 1f 00 0d 	mcall	80005748 <spi_setupChipReg+0xe0>
8000571a:	48 b8       	lddpc	r8,80005744 <spi_setupChipReg+0xdc>
8000571c:	91 0c       	st.w	r8[0x0],r12
8000571e:	58 0c       	cp.w	r12,0
80005720:	c0 a0       	breq	80005734 <spi_setupChipReg+0xcc>
80005722:	30 09       	mov	r9,0
80005724:	12 9a       	mov	r10,r9
80005726:	12 9b       	mov	r11,r9
80005728:	f0 1f 00 09 	mcall	8000574c <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
8000572c:	48 68       	lddpc	r8,80005744 <spi_setupChipReg+0xdc>
8000572e:	70 08       	ld.w	r8,r8[0x0]
80005730:	58 08       	cp.w	r8,0
80005732:	c0 51       	brne	8000573c <spi_setupChipReg+0xd4>
80005734:	c0 08       	rjmp	80005734 <spi_setupChipReg+0xcc>
80005736:	30 2c       	mov	r12,2
80005738:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000573c:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005740:	80 00       	ld.sh	r0,r0[0x0]
80005742:	55 a0       	stdsp	sp[0x168],r0
80005744:	00 00       	add	r0,r0
80005746:	51 18       	stdsp	sp[0x44],r8
80005748:	80 00       	ld.sh	r0,r0[0x0]
8000574a:	62 34       	ld.w	r4,r1[0xc]
8000574c:	80 00       	ld.sh	r0,r0[0x0]
8000574e:	61 34       	ld.w	r4,r0[0x4c]

80005750 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005750:	d4 01       	pushm	lr
80005752:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005756:	c0 58       	rjmp	80005760 <spi_unselectChip+0x10>
		if (!timeout--) {
80005758:	58 08       	cp.w	r8,0
8000575a:	c0 21       	brne	8000575e <spi_unselectChip+0xe>
8000575c:	da 0a       	popm	pc,r12=1
8000575e:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005760:	78 49       	ld.w	r9,r12[0x10]
80005762:	e2 19 02 00 	andl	r9,0x200,COH
80005766:	cf 90       	breq	80005758 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005768:	78 18       	ld.w	r8,r12[0x4]
8000576a:	ea 18 00 0f 	orh	r8,0xf
8000576e:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80005770:	fc 18 01 00 	movh	r8,0x100
80005774:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80005776:	30 09       	mov	r9,0
80005778:	12 9a       	mov	r10,r9
8000577a:	12 9b       	mov	r11,r9
8000577c:	48 38       	lddpc	r8,80005788 <spi_unselectChip+0x38>
8000577e:	70 0c       	ld.w	r12,r8[0x0]
80005780:	f0 1f 00 03 	mcall	8000578c <spi_unselectChip+0x3c>
80005784:	d8 0a       	popm	pc,r12=0
80005786:	00 00       	add	r0,r0
80005788:	00 00       	add	r0,r0
8000578a:	51 18       	stdsp	sp[0x44],r8
8000578c:	80 00       	ld.sh	r0,r0[0x0]
8000578e:	61 34       	ld.w	r4,r0[0x4c]

80005790 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005790:	eb cd 40 f8 	pushm	r3-r7,lr
80005794:	18 94       	mov	r4,r12
80005796:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80005798:	49 a6       	lddpc	r6,80005800 <spi_selectChip+0x70>
8000579a:	30 07       	mov	r7,0
8000579c:	31 45       	mov	r5,20
8000579e:	0e 99       	mov	r9,r7
800057a0:	0a 9a       	mov	r10,r5
800057a2:	0e 9b       	mov	r11,r7
800057a4:	6c 0c       	ld.w	r12,r6[0x0]
800057a6:	f0 1f 00 18 	mcall	80005804 <spi_selectChip+0x74>
800057aa:	cf a0       	breq	8000579e <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800057ac:	68 18       	ld.w	r8,r4[0x4]
800057ae:	ea 18 00 0f 	orh	r8,0xf
800057b2:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
800057b4:	68 18       	ld.w	r8,r4[0x4]
800057b6:	e2 18 00 04 	andl	r8,0x4,COH
800057ba:	c1 10       	breq	800057dc <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
800057bc:	30 e8       	mov	r8,14
800057be:	f0 03 18 00 	cp.b	r3,r8
800057c2:	e0 8b 00 1c 	brhi	800057fa <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800057c6:	68 19       	ld.w	r9,r4[0x4]
800057c8:	e6 08 15 10 	lsl	r8,r3,0x10
800057cc:	ea 18 ff f0 	orh	r8,0xfff0
800057d0:	e8 18 ff ff 	orl	r8,0xffff
800057d4:	12 68       	and	r8,r9
800057d6:	89 18       	st.w	r4[0x4],r8
800057d8:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800057dc:	30 38       	mov	r8,3
800057de:	f0 03 18 00 	cp.b	r3,r8
800057e2:	e0 8b 00 0c 	brhi	800057fa <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800057e6:	68 19       	ld.w	r9,r4[0x4]
800057e8:	2f 03       	sub	r3,-16
800057ea:	30 18       	mov	r8,1
800057ec:	f0 03 09 48 	lsl	r8,r8,r3
800057f0:	5c d8       	com	r8
800057f2:	12 68       	and	r8,r9
800057f4:	89 18       	st.w	r4[0x4],r8
800057f6:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800057fa:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
800057fc:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005800:	00 00       	add	r0,r0
80005802:	51 18       	stdsp	sp[0x44],r8
80005804:	80 00       	ld.sh	r0,r0[0x0]
80005806:	5f 28       	srhs	r8

80005808 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005808:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
8000580a:	f6 08 15 04 	lsl	r8,r11,0x4
8000580e:	14 38       	cp.w	r8,r10
80005810:	f9 b8 08 10 	movls	r8,16
80005814:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005818:	f0 0b 02 4b 	mul	r11,r8,r11
8000581c:	f6 09 16 01 	lsr	r9,r11,0x1
80005820:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80005824:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005828:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
8000582c:	f2 cb 00 01 	sub	r11,r9,1
80005830:	e0 4b ff fe 	cp.w	r11,65534
80005834:	e0 88 00 03 	brls	8000583a <usart_set_async_baudrate+0x32>
80005838:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
8000583a:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
8000583c:	e8 6e 00 00 	mov	lr,524288
80005840:	59 08       	cp.w	r8,16
80005842:	fc 08 17 10 	movne	r8,lr
80005846:	f9 b8 00 00 	moveq	r8,0
8000584a:	e4 1b ff f7 	andh	r11,0xfff7
8000584e:	e0 1b fe cf 	andl	r11,0xfecf
80005852:	16 48       	or	r8,r11
80005854:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005856:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
8000585a:	f3 ea 11 09 	or	r9,r9,r10<<0x10
8000585e:	99 89       	st.w	r12[0x20],r9
80005860:	d8 0a       	popm	pc,r12=0

80005862 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80005862:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005864:	e2 18 00 02 	andl	r8,0x2,COH
80005868:	c0 31       	brne	8000586e <usart_write_char+0xc>
8000586a:	30 2c       	mov	r12,2
8000586c:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
8000586e:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80005872:	99 7b       	st.w	r12[0x1c],r11
80005874:	5e fd       	retal	0
80005876:	d7 03       	nop

80005878 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005878:	eb cd 40 e0 	pushm	r5-r7,lr
8000587c:	18 96       	mov	r6,r12
8000587e:	16 95       	mov	r5,r11
80005880:	e0 67 27 0f 	mov	r7,9999
80005884:	c0 68       	rjmp	80005890 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80005886:	58 07       	cp.w	r7,0
80005888:	c0 31       	brne	8000588e <usart_putchar+0x16>
8000588a:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
8000588e:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005890:	0a 9b       	mov	r11,r5
80005892:	0c 9c       	mov	r12,r6
80005894:	f0 1f 00 03 	mcall	800058a0 <usart_putchar+0x28>
80005898:	cf 71       	brne	80005886 <usart_putchar+0xe>

  return USART_SUCCESS;
}
8000589a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000589e:	00 00       	add	r0,r0
800058a0:	80 00       	ld.sh	r0,r0[0x0]
800058a2:	58 62       	cp.w	r2,6

800058a4 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
800058a4:	78 58       	ld.w	r8,r12[0x14]
800058a6:	e2 18 00 e0 	andl	r8,0xe0,COH
800058aa:	c0 30       	breq	800058b0 <usart_read_char+0xc>
800058ac:	30 4c       	mov	r12,4
800058ae:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
800058b0:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
800058b2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800058b6:	c0 31       	brne	800058bc <usart_read_char+0x18>
800058b8:	30 3c       	mov	r12,3
800058ba:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
800058bc:	78 68       	ld.w	r8,r12[0x18]
800058be:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800058c2:	97 08       	st.w	r11[0x0],r8
800058c4:	5e fd       	retal	0
800058c6:	d7 03       	nop

800058c8 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
800058c8:	eb cd 40 c0 	pushm	r6-r7,lr
800058cc:	20 1d       	sub	sp,4
800058ce:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
800058d0:	1a 97       	mov	r7,sp
800058d2:	1a 9b       	mov	r11,sp
800058d4:	0c 9c       	mov	r12,r6
800058d6:	f0 1f 00 07 	mcall	800058f0 <usart_getchar+0x28>
800058da:	58 3c       	cp.w	r12,3
800058dc:	cf b0       	breq	800058d2 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
800058de:	58 4c       	cp.w	r12,4
800058e0:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
800058e4:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
800058e8:	2f fd       	sub	sp,-4
800058ea:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800058ee:	00 00       	add	r0,r0
800058f0:	80 00       	ld.sh	r0,r0[0x0]
800058f2:	58 a4       	cp.w	r4,10

800058f4 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
800058f4:	eb cd 40 c0 	pushm	r6-r7,lr
800058f8:	18 96       	mov	r6,r12
800058fa:	16 97       	mov	r7,r11
  while (*string != '\0')
800058fc:	17 8b       	ld.ub	r11,r11[0x0]
800058fe:	58 0b       	cp.w	r11,0
80005900:	c0 80       	breq	80005910 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80005902:	2f f7       	sub	r7,-1
80005904:	0c 9c       	mov	r12,r6
80005906:	f0 1f 00 04 	mcall	80005914 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
8000590a:	0f 8b       	ld.ub	r11,r7[0x0]
8000590c:	58 0b       	cp.w	r11,0
8000590e:	cf a1       	brne	80005902 <usart_write_line+0xe>
80005910:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005914:	80 00       	ld.sh	r0,r0[0x0]
80005916:	58 78       	cp.w	r8,7

80005918 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005918:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
8000591c:	e6 18 00 01 	andh	r8,0x1,COH
80005920:	c0 71       	brne	8000592e <usart_reset+0x16>
80005922:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005924:	3f f8       	mov	r8,-1
80005926:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005928:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
8000592a:	d5 03       	csrf	0x10
8000592c:	c0 48       	rjmp	80005934 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
8000592e:	3f f8       	mov	r8,-1
80005930:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005932:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005934:	30 08       	mov	r8,0
80005936:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005938:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
8000593a:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
8000593c:	ea 68 61 0c 	mov	r8,680204
80005940:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80005942:	5e fc       	retal	r12

80005944 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005944:	eb cd 40 e0 	pushm	r5-r7,lr
80005948:	18 96       	mov	r6,r12
8000594a:	16 97       	mov	r7,r11
8000594c:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
8000594e:	f0 1f 00 2f 	mcall	80005a08 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80005952:	58 07       	cp.w	r7,0
80005954:	c5 80       	breq	80005a04 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005956:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005958:	30 49       	mov	r9,4
8000595a:	f2 08 18 00 	cp.b	r8,r9
8000595e:	e0 88 00 53 	brls	80005a04 <usart_init_rs232+0xc0>
80005962:	30 99       	mov	r9,9
80005964:	f2 08 18 00 	cp.b	r8,r9
80005968:	e0 8b 00 4e 	brhi	80005a04 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
8000596c:	0f d9       	ld.ub	r9,r7[0x5]
8000596e:	30 78       	mov	r8,7
80005970:	f0 09 18 00 	cp.b	r9,r8
80005974:	e0 8b 00 48 	brhi	80005a04 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005978:	8e 39       	ld.sh	r9,r7[0x6]
8000597a:	e0 68 01 01 	mov	r8,257
8000597e:	f0 09 19 00 	cp.h	r9,r8
80005982:	e0 8b 00 41 	brhi	80005a04 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005986:	ef 39 00 08 	ld.ub	r9,r7[8]
8000598a:	30 38       	mov	r8,3
8000598c:	f0 09 18 00 	cp.b	r9,r8
80005990:	e0 8b 00 3a 	brhi	80005a04 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005994:	0a 9a       	mov	r10,r5
80005996:	6e 0b       	ld.w	r11,r7[0x0]
80005998:	0c 9c       	mov	r12,r6
8000599a:	f0 1f 00 1d 	mcall	80005a0c <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000599e:	58 1c       	cp.w	r12,1
800059a0:	c3 20       	breq	80005a04 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
800059a2:	0f c8       	ld.ub	r8,r7[0x4]
800059a4:	30 99       	mov	r9,9
800059a6:	f2 08 18 00 	cp.b	r8,r9
800059aa:	c0 51       	brne	800059b4 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
800059ac:	6c 18       	ld.w	r8,r6[0x4]
800059ae:	b1 b8       	sbr	r8,0x11
800059b0:	8d 18       	st.w	r6[0x4],r8
800059b2:	c0 68       	rjmp	800059be <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
800059b4:	6c 19       	ld.w	r9,r6[0x4]
800059b6:	20 58       	sub	r8,5
800059b8:	f3 e8 10 68 	or	r8,r9,r8<<0x6
800059bc:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800059be:	6c 19       	ld.w	r9,r6[0x4]
800059c0:	ef 3a 00 08 	ld.ub	r10,r7[8]
800059c4:	0f d8       	ld.ub	r8,r7[0x5]
800059c6:	a9 78       	lsl	r8,0x9
800059c8:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
800059cc:	12 48       	or	r8,r9
800059ce:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
800059d0:	8e 38       	ld.sh	r8,r7[0x6]
800059d2:	30 29       	mov	r9,2
800059d4:	f2 08 19 00 	cp.h	r8,r9
800059d8:	e0 88 00 09 	brls	800059ea <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
800059dc:	6c 18       	ld.w	r8,r6[0x4]
800059de:	ad b8       	sbr	r8,0xd
800059e0:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
800059e2:	8e b8       	ld.uh	r8,r7[0x6]
800059e4:	20 28       	sub	r8,2
800059e6:	8d a8       	st.w	r6[0x28],r8
800059e8:	c0 68       	rjmp	800059f4 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
800059ea:	6c 19       	ld.w	r9,r6[0x4]
800059ec:	5c 78       	castu.h	r8
800059ee:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
800059f2:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
800059f4:	6c 18       	ld.w	r8,r6[0x4]
800059f6:	e0 18 ff f0 	andl	r8,0xfff0
800059fa:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
800059fc:	35 08       	mov	r8,80
800059fe:	8d 08       	st.w	r6[0x0],r8
80005a00:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005a04:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005a08:	80 00       	ld.sh	r0,r0[0x0]
80005a0a:	59 18       	cp.w	r8,17
80005a0c:	80 00       	ld.sh	r0,r0[0x0]
80005a0e:	58 08       	cp.w	r8,0

80005a10 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005a10:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005a14:	fe c0 8e 14 	sub	r0,pc,-29164

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005a18:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005a1c:	d5 53       	csrf	0x15
  cp      r0, r1
80005a1e:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005a20:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005a24:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80005a26:	c0 62       	brcc	80005a32 <idata_load_loop_end>
  cp      r0, r1
80005a28:	48 92       	lddpc	r2,80005a4c <udata_clear_loop_end+0x4>

80005a2a <idata_load_loop>:
  brlo    idata_load_loop
80005a2a:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005a2c:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005a2e:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005a30:	cf d3       	brcs	80005a2a <idata_load_loop>

80005a32 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005a32:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
80005a36:	e0 61 51 28 	mov	r1,20776
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005a3a:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005a3c:	c0 62       	brcc	80005a48 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005a3e:	30 02       	mov	r2,0
80005a40:	30 03       	mov	r3,0

80005a42 <udata_clear_loop>:
80005a42:	a1 22       	st.d	r0++,r2
80005a44:	02 30       	cp.w	r0,r1
80005a46:	cf e3       	brcs	80005a42 <udata_clear_loop>

80005a48 <udata_clear_loop_end>:
80005a48:	fe cf e9 7c 	sub	pc,pc,-5764
80005a4c:	80 00       	ld.sh	r0,r0[0x0]
80005a4e:	df a0       	acall	0xfa

80005a50 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005a50:	f8 c8 ff f8 	sub	r8,r12,-8
80005a54:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005a56:	3f f9       	mov	r9,-1
80005a58:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005a5a:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005a5c:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005a5e:	30 08       	mov	r8,0
80005a60:	99 08       	st.w	r12[0x0],r8
}
80005a62:	5e fc       	retal	r12

80005a64 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005a64:	30 08       	mov	r8,0
80005a66:	99 48       	st.w	r12[0x10],r8
}
80005a68:	5e fc       	retal	r12

80005a6a <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005a6a:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005a6c:	70 19       	ld.w	r9,r8[0x4]
80005a6e:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005a70:	78 19       	ld.w	r9,r12[0x4]
80005a72:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005a74:	70 19       	ld.w	r9,r8[0x4]
80005a76:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005a78:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005a7a:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005a7c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005a7e:	78 08       	ld.w	r8,r12[0x0]
80005a80:	2f f8       	sub	r8,-1
80005a82:	99 08       	st.w	r12[0x0],r8
}
80005a84:	5e fc       	retal	r12

80005a86 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005a86:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005a88:	5b fa       	cp.w	r10,-1
80005a8a:	c0 31       	brne	80005a90 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005a8c:	78 48       	ld.w	r8,r12[0x10]
80005a8e:	c0 c8       	rjmp	80005aa6 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005a90:	f8 c8 ff f8 	sub	r8,r12,-8
80005a94:	70 19       	ld.w	r9,r8[0x4]
80005a96:	72 09       	ld.w	r9,r9[0x0]
80005a98:	12 3a       	cp.w	r10,r9
80005a9a:	c0 63       	brcs	80005aa6 <vListInsert+0x20>
80005a9c:	70 18       	ld.w	r8,r8[0x4]
80005a9e:	70 19       	ld.w	r9,r8[0x4]
80005aa0:	72 09       	ld.w	r9,r9[0x0]
80005aa2:	12 3a       	cp.w	r10,r9
80005aa4:	cf c2       	brcc	80005a9c <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005aa6:	70 19       	ld.w	r9,r8[0x4]
80005aa8:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005aaa:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005aac:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005aae:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005ab0:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005ab2:	78 08       	ld.w	r8,r12[0x0]
80005ab4:	2f f8       	sub	r8,-1
80005ab6:	99 08       	st.w	r12[0x0],r8
}
80005ab8:	5e fc       	retal	r12

80005aba <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005aba:	78 18       	ld.w	r8,r12[0x4]
80005abc:	78 29       	ld.w	r9,r12[0x8]
80005abe:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005ac0:	78 28       	ld.w	r8,r12[0x8]
80005ac2:	78 19       	ld.w	r9,r12[0x4]
80005ac4:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005ac6:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005ac8:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005aca:	18 39       	cp.w	r9,r12
80005acc:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005ad0:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005ad4:	30 09       	mov	r9,0
80005ad6:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005ad8:	70 09       	ld.w	r9,r8[0x0]
80005ada:	20 19       	sub	r9,1
80005adc:	91 09       	st.w	r8[0x0],r9
}
80005ade:	5e fc       	retal	r12

80005ae0 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005ae0:	e0 68 08 08 	mov	r8,2056
80005ae4:	ea 18 08 08 	orh	r8,0x808
80005ae8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005aea:	e0 68 09 09 	mov	r8,2313
80005aee:	ea 18 09 09 	orh	r8,0x909
80005af2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005af4:	e0 68 0a 0a 	mov	r8,2570
80005af8:	ea 18 0a 0a 	orh	r8,0xa0a
80005afc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005afe:	e0 68 0b 0b 	mov	r8,2827
80005b02:	ea 18 0b 0b 	orh	r8,0xb0b
80005b06:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005b08:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005b0a:	e0 68 be ef 	mov	r8,48879
80005b0e:	ea 18 de ad 	orh	r8,0xdead
80005b12:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005b14:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005b16:	fc 18 00 40 	movh	r8,0x40
80005b1a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005b1c:	e0 68 00 ff 	mov	r8,255
80005b20:	ea 18 ff 00 	orh	r8,0xff00
80005b24:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005b26:	e0 68 01 01 	mov	r8,257
80005b2a:	ea 18 01 01 	orh	r8,0x101
80005b2e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005b30:	e0 68 02 02 	mov	r8,514
80005b34:	ea 18 02 02 	orh	r8,0x202
80005b38:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005b3a:	e0 68 03 03 	mov	r8,771
80005b3e:	ea 18 03 03 	orh	r8,0x303
80005b42:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005b44:	e0 68 04 04 	mov	r8,1028
80005b48:	ea 18 04 04 	orh	r8,0x404
80005b4c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005b4e:	e0 68 05 05 	mov	r8,1285
80005b52:	ea 18 05 05 	orh	r8,0x505
80005b56:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005b58:	e0 68 06 06 	mov	r8,1542
80005b5c:	ea 18 06 06 	orh	r8,0x606
80005b60:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005b62:	e0 68 07 07 	mov	r8,1799
80005b66:	ea 18 07 07 	orh	r8,0x707
80005b6a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005b6c:	30 08       	mov	r8,0
80005b6e:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005b70:	5e fc       	retal	r12
80005b72:	d7 03       	nop

80005b74 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005b74:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005b76:	48 38       	lddpc	r8,80005b80 <vPortEnterCritical+0xc>
80005b78:	70 09       	ld.w	r9,r8[0x0]
80005b7a:	2f f9       	sub	r9,-1
80005b7c:	91 09       	st.w	r8[0x0],r9
}
80005b7e:	5e fc       	retal	r12
80005b80:	00 00       	add	r0,r0
80005b82:	05 34       	ld.ub	r4,r2++

80005b84 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005b84:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005b86:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005b88:	30 0a       	mov	r10,0
80005b8a:	14 9b       	mov	r11,r10
80005b8c:	49 2c       	lddpc	r12,80005bd4 <xPortStartScheduler+0x50>
80005b8e:	f0 1f 00 13 	mcall	80005bd8 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005b92:	e0 68 5d c0 	mov	r8,24000
80005b96:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005b9a:	30 08       	mov	r8,0
80005b9c:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005ba0:	e0 68 0c d4 	mov	r8,3284
80005ba4:	ea 18 00 00 	orh	r8,0x0
80005ba8:	70 00       	ld.w	r0,r8[0x0]
80005baa:	60 0d       	ld.w	sp,r0[0x0]
80005bac:	1b 00       	ld.w	r0,sp++
80005bae:	e0 68 05 34 	mov	r8,1332
80005bb2:	ea 18 00 00 	orh	r8,0x0
80005bb6:	91 00       	st.w	r8[0x0],r0
80005bb8:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005bbc:	2f ed       	sub	sp,-8
80005bbe:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005bc2:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005bc6:	e3 b0 00 00 	mtsr	0x0,r0
80005bca:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005bce:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005bd2:	d8 0a       	popm	pc,r12=0
80005bd4:	80 00       	ld.sh	r0,r0[0x0]
80005bd6:	5c a0       	swap.h	r0
80005bd8:	80 00       	ld.sh	r0,r0[0x0]
80005bda:	53 24       	stdsp	sp[0xc8],r4

80005bdc <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005bdc:	20 6d       	sub	sp,24
80005bde:	eb cd 00 ff 	pushm	r0-r7
80005be2:	fa c7 ff c0 	sub	r7,sp,-64
80005be6:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005bea:	ef 40 ff e0 	st.w	r7[-32],r0
80005bee:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005bf2:	ef 40 ff e4 	st.w	r7[-28],r0
80005bf6:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005bfa:	e0 68 05 34 	mov	r8,1332
80005bfe:	ea 18 00 00 	orh	r8,0x0
80005c02:	70 00       	ld.w	r0,r8[0x0]
80005c04:	1a d0       	st.w	--sp,r0
80005c06:	f0 1f 00 1a 	mcall	80005c6c <LABEL_RET_SCALL_263+0x14>
80005c0a:	e0 68 0c d4 	mov	r8,3284
80005c0e:	ea 18 00 00 	orh	r8,0x0
80005c12:	70 00       	ld.w	r0,r8[0x0]
80005c14:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005c16:	f0 1f 00 17 	mcall	80005c70 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005c1a:	e0 68 0c d4 	mov	r8,3284
80005c1e:	ea 18 00 00 	orh	r8,0x0
80005c22:	70 00       	ld.w	r0,r8[0x0]
80005c24:	60 0d       	ld.w	sp,r0[0x0]
80005c26:	1b 00       	ld.w	r0,sp++
80005c28:	e0 68 05 34 	mov	r8,1332
80005c2c:	ea 18 00 00 	orh	r8,0x0
80005c30:	91 00       	st.w	r8[0x0],r0
80005c32:	fa c7 ff d8 	sub	r7,sp,-40
80005c36:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005c3a:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005c3e:	e0 61 05 34 	mov	r1,1332
80005c42:	ea 11 00 00 	orh	r1,0x0
80005c46:	62 02       	ld.w	r2,r1[0x0]
80005c48:	58 02       	cp.w	r2,0
80005c4a:	c0 70       	breq	80005c58 <LABEL_RET_SCALL_263>
80005c4c:	e4 c2 00 01 	sub	r2,r2,1
80005c50:	83 02       	st.w	r1[0x0],r2
80005c52:	58 02       	cp.w	r2,0
80005c54:	c0 21       	brne	80005c58 <LABEL_RET_SCALL_263>
80005c56:	b1 c0       	cbr	r0,0x10

80005c58 <LABEL_RET_SCALL_263>:
80005c58:	ef 40 ff f8 	st.w	r7[-8],r0
80005c5c:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005c60:	ef 40 ff fc 	st.w	r7[-4],r0
80005c64:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005c68:	2f ad       	sub	sp,-24
80005c6a:	d6 13       	rets
80005c6c:	80 00       	ld.sh	r0,r0[0x0]
80005c6e:	5b 74       	cp.w	r4,-9
80005c70:	80 00       	ld.sh	r0,r0[0x0]
80005c72:	62 b8       	ld.w	r8,r1[0x2c]

80005c74 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005c74:	e1 b8 00 43 	mfsr	r8,0x10c
80005c78:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005c7c:	5e fc       	retal	r12
80005c7e:	d7 03       	nop

80005c80 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005c80:	48 78       	lddpc	r8,80005c9c <vPortExitCritical+0x1c>
80005c82:	70 08       	ld.w	r8,r8[0x0]
80005c84:	58 08       	cp.w	r8,0
80005c86:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005c88:	48 58       	lddpc	r8,80005c9c <vPortExitCritical+0x1c>
80005c8a:	70 09       	ld.w	r9,r8[0x0]
80005c8c:	20 19       	sub	r9,1
80005c8e:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005c90:	70 08       	ld.w	r8,r8[0x0]
80005c92:	58 08       	cp.w	r8,0
80005c94:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005c96:	d5 03       	csrf	0x10
80005c98:	5e fc       	retal	r12
80005c9a:	00 00       	add	r0,r0
80005c9c:	00 00       	add	r0,r0
80005c9e:	05 34       	ld.ub	r4,r2++

80005ca0 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005ca0:	eb cd 00 ff 	pushm	r0-r7
80005ca4:	e0 68 05 34 	mov	r8,1332
80005ca8:	ea 18 00 00 	orh	r8,0x0
80005cac:	70 00       	ld.w	r0,r8[0x0]
80005cae:	1a d0       	st.w	--sp,r0
80005cb0:	7a 90       	ld.w	r0,sp[0x24]
80005cb2:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005cb6:	58 10       	cp.w	r0,1
80005cb8:	e0 8b 00 08 	brhi	80005cc8 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005cbc:	e0 68 0c d4 	mov	r8,3284
80005cc0:	ea 18 00 00 	orh	r8,0x0
80005cc4:	70 00       	ld.w	r0,r8[0x0]
80005cc6:	81 0d       	st.w	r0[0x0],sp

80005cc8 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005cc8:	f0 1f 00 12 	mcall	80005d10 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005ccc:	f0 1f 00 12 	mcall	80005d14 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005cd0:	f0 1f 00 12 	mcall	80005d18 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005cd4:	f0 1f 00 12 	mcall	80005d1c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005cd8:	7a 90       	ld.w	r0,sp[0x24]
80005cda:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005cde:	58 10       	cp.w	r0,1
80005ce0:	e0 8b 00 0e 	brhi	80005cfc <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005ce4:	f0 1f 00 0c 	mcall	80005d14 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005ce8:	f0 1f 00 0e 	mcall	80005d20 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005cec:	f0 1f 00 0c 	mcall	80005d1c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005cf0:	e0 68 0c d4 	mov	r8,3284
80005cf4:	ea 18 00 00 	orh	r8,0x0
80005cf8:	70 00       	ld.w	r0,r8[0x0]
80005cfa:	60 0d       	ld.w	sp,r0[0x0]

80005cfc <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005cfc:	1b 00       	ld.w	r0,sp++
80005cfe:	e0 68 05 34 	mov	r8,1332
80005d02:	ea 18 00 00 	orh	r8,0x0
80005d06:	91 00       	st.w	r8[0x0],r0
80005d08:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005d0c:	d6 03       	rete
80005d0e:	00 00       	add	r0,r0
80005d10:	80 00       	ld.sh	r0,r0[0x0]
80005d12:	5c 74       	castu.h	r4
80005d14:	80 00       	ld.sh	r0,r0[0x0]
80005d16:	5b 74       	cp.w	r4,-9
80005d18:	80 00       	ld.sh	r0,r0[0x0]
80005d1a:	64 bc       	ld.w	r12,r2[0x2c]
80005d1c:	80 00       	ld.sh	r0,r0[0x0]
80005d1e:	5c 80       	casts.h	r0
80005d20:	80 00       	ld.sh	r0,r0[0x0]
80005d22:	62 b8       	ld.w	r8,r1[0x2c]

80005d24 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005d24:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005d26:	f0 1f 00 02 	mcall	80005d2c <__malloc_lock+0x8>
}
80005d2a:	d8 02       	popm	pc
80005d2c:	80 00       	ld.sh	r0,r0[0x0]
80005d2e:	62 a8       	ld.w	r8,r1[0x28]

80005d30 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005d30:	d4 01       	pushm	lr
	xTaskResumeAll();
80005d32:	f0 1f 00 02 	mcall	80005d38 <__malloc_unlock+0x8>
}
80005d36:	d8 02       	popm	pc
80005d38:	80 00       	ld.sh	r0,r0[0x0]
80005d3a:	66 64       	ld.w	r4,r3[0x18]

80005d3c <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005d3c:	d4 21       	pushm	r4-r7,lr
80005d3e:	16 95       	mov	r5,r11
80005d40:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005d42:	58 0c       	cp.w	r12,0
80005d44:	c0 30       	breq	80005d4a <_read+0xe>
80005d46:	3f f7       	mov	r7,-1
80005d48:	c1 48       	rjmp	80005d70 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005d4a:	58 0a       	cp.w	r10,0
80005d4c:	e0 89 00 04 	brgt	80005d54 <_read+0x18>
80005d50:	30 07       	mov	r7,0
80005d52:	c0 f8       	rjmp	80005d70 <_read+0x34>
80005d54:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005d56:	48 84       	lddpc	r4,80005d74 <_read+0x38>
80005d58:	68 0c       	ld.w	r12,r4[0x0]
80005d5a:	f0 1f 00 08 	mcall	80005d78 <_read+0x3c>
    if (c < 0)
80005d5e:	c0 95       	brlt	80005d70 <_read+0x34>
      break;

    *ptr++ = c;
80005d60:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005d64:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005d66:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005d6a:	58 08       	cp.w	r8,0
80005d6c:	fe 99 ff f6 	brgt	80005d58 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005d70:	0e 9c       	mov	r12,r7
80005d72:	d8 22       	popm	r4-r7,pc
80005d74:	00 00       	add	r0,r0
80005d76:	51 1c       	stdsp	sp[0x44],r12
80005d78:	80 00       	ld.sh	r0,r0[0x0]
80005d7a:	58 c8       	cp.w	r8,12

80005d7c <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005d7c:	d4 21       	pushm	r4-r7,lr
80005d7e:	16 95       	mov	r5,r11
80005d80:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005d82:	20 1c       	sub	r12,1
80005d84:	58 2c       	cp.w	r12,2
80005d86:	e0 8b 00 12 	brhi	80005daa <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005d8a:	58 0a       	cp.w	r10,0
80005d8c:	c0 31       	brne	80005d92 <_write+0x16>
80005d8e:	30 07       	mov	r7,0
80005d90:	c0 e8       	rjmp	80005dac <_write+0x30>
80005d92:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005d94:	48 74       	lddpc	r4,80005db0 <_write+0x34>
80005d96:	68 0c       	ld.w	r12,r4[0x0]
80005d98:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005d9c:	f0 1f 00 06 	mcall	80005db4 <_write+0x38>
80005da0:	c0 55       	brlt	80005daa <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005da2:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005da4:	0e 36       	cp.w	r6,r7
80005da6:	cf 81       	brne	80005d96 <_write+0x1a>
80005da8:	c0 28       	rjmp	80005dac <_write+0x30>
80005daa:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005dac:	0e 9c       	mov	r12,r7
80005dae:	d8 22       	popm	r4-r7,pc
80005db0:	00 00       	add	r0,r0
80005db2:	51 1c       	stdsp	sp[0x44],r12
80005db4:	80 00       	ld.sh	r0,r0[0x0]
80005db6:	58 78       	cp.w	r8,7

80005db8 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005db8:	eb cd 40 80 	pushm	r7,lr
80005dbc:	18 97       	mov	r7,r12
	if( pv )
80005dbe:	58 0c       	cp.w	r12,0
80005dc0:	c0 80       	breq	80005dd0 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005dc2:	f0 1f 00 05 	mcall	80005dd4 <vPortFree+0x1c>
		{
			free( pv );
80005dc6:	0e 9c       	mov	r12,r7
80005dc8:	f0 1f 00 04 	mcall	80005dd8 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005dcc:	f0 1f 00 04 	mcall	80005ddc <vPortFree+0x24>
80005dd0:	e3 cd 80 80 	ldm	sp++,r7,pc
80005dd4:	80 00       	ld.sh	r0,r0[0x0]
80005dd6:	62 a8       	ld.w	r8,r1[0x28]
80005dd8:	80 00       	ld.sh	r0,r0[0x0]
80005dda:	71 3c       	ld.w	r12,r8[0x4c]
80005ddc:	80 00       	ld.sh	r0,r0[0x0]
80005dde:	66 64       	ld.w	r4,r3[0x18]

80005de0 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005de0:	eb cd 40 80 	pushm	r7,lr
80005de4:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005de6:	f0 1f 00 06 	mcall	80005dfc <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005dea:	0e 9c       	mov	r12,r7
80005dec:	f0 1f 00 05 	mcall	80005e00 <pvPortMalloc+0x20>
80005df0:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005df2:	f0 1f 00 05 	mcall	80005e04 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005df6:	0e 9c       	mov	r12,r7
80005df8:	e3 cd 80 80 	ldm	sp++,r7,pc
80005dfc:	80 00       	ld.sh	r0,r0[0x0]
80005dfe:	62 a8       	ld.w	r8,r1[0x28]
80005e00:	80 00       	ld.sh	r0,r0[0x0]
80005e02:	71 4c       	ld.w	r12,r8[0x50]
80005e04:	80 00       	ld.sh	r0,r0[0x0]
80005e06:	66 64       	ld.w	r4,r3[0x18]

80005e08 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005e08:	d4 01       	pushm	lr
80005e0a:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005e0c:	78 09       	ld.w	r9,r12[0x0]
80005e0e:	58 09       	cp.w	r9,0
80005e10:	c1 10       	breq	80005e32 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005e12:	78 3a       	ld.w	r10,r12[0xc]
80005e14:	79 09       	ld.w	r9,r12[0x40]
80005e16:	f4 09 00 09 	add	r9,r10,r9
80005e1a:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005e1c:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005e1e:	14 39       	cp.w	r9,r10
80005e20:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005e24:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005e28:	79 0a       	ld.w	r10,r12[0x40]
80005e2a:	78 3b       	ld.w	r11,r12[0xc]
80005e2c:	10 9c       	mov	r12,r8
80005e2e:	f0 1f 00 02 	mcall	80005e34 <prvCopyDataFromQueue+0x2c>
80005e32:	d8 02       	popm	pc
80005e34:	80 00       	ld.sh	r0,r0[0x0]
80005e36:	75 94       	ld.w	r4,r10[0x64]

80005e38 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005e38:	eb cd 40 c0 	pushm	r6-r7,lr
80005e3c:	18 97       	mov	r7,r12
80005e3e:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005e40:	78 e8       	ld.w	r8,r12[0x38]
80005e42:	58 08       	cp.w	r8,0
80005e44:	c0 31       	brne	80005e4a <xQueueReceiveFromISR+0x12>
80005e46:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005e4a:	f0 1f 00 0e 	mcall	80005e80 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80005e4e:	6e e8       	ld.w	r8,r7[0x38]
80005e50:	20 18       	sub	r8,1
80005e52:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80005e54:	6f 18       	ld.w	r8,r7[0x44]
80005e56:	5b f8       	cp.w	r8,-1
80005e58:	c0 d1       	brne	80005e72 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005e5a:	6e 48       	ld.w	r8,r7[0x10]
80005e5c:	58 08       	cp.w	r8,0
80005e5e:	c0 f0       	breq	80005e7c <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005e60:	ee cc ff f0 	sub	r12,r7,-16
80005e64:	f0 1f 00 08 	mcall	80005e84 <xQueueReceiveFromISR+0x4c>
80005e68:	c0 a0       	breq	80005e7c <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80005e6a:	30 1c       	mov	r12,1
80005e6c:	8d 0c       	st.w	r6[0x0],r12
80005e6e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80005e72:	2f f8       	sub	r8,-1
80005e74:	ef 48 00 44 	st.w	r7[68],r8
80005e78:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005e7c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005e80:	80 00       	ld.sh	r0,r0[0x0]
80005e82:	5e 08       	reteq	r8
80005e84:	80 00       	ld.sh	r0,r0[0x0]
80005e86:	64 40       	ld.w	r0,r2[0x10]

80005e88 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005e88:	eb cd 40 c0 	pushm	r6-r7,lr
80005e8c:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005e8e:	f0 1f 00 23 	mcall	80005f18 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005e92:	6f 28       	ld.w	r8,r7[0x48]
80005e94:	58 08       	cp.w	r8,0
80005e96:	e0 8a 00 18 	brle	80005ec6 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005e9a:	6e 98       	ld.w	r8,r7[0x24]
80005e9c:	58 08       	cp.w	r8,0
80005e9e:	c1 40       	breq	80005ec6 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005ea0:	ee c6 ff dc 	sub	r6,r7,-36
80005ea4:	c0 48       	rjmp	80005eac <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005ea6:	6e 98       	ld.w	r8,r7[0x24]
80005ea8:	58 08       	cp.w	r8,0
80005eaa:	c0 e0       	breq	80005ec6 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005eac:	0c 9c       	mov	r12,r6
80005eae:	f0 1f 00 1c 	mcall	80005f1c <prvUnlockQueue+0x94>
80005eb2:	c0 30       	breq	80005eb8 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005eb4:	f0 1f 00 1b 	mcall	80005f20 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005eb8:	6f 28       	ld.w	r8,r7[0x48]
80005eba:	20 18       	sub	r8,1
80005ebc:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005ec0:	58 08       	cp.w	r8,0
80005ec2:	fe 99 ff f2 	brgt	80005ea6 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005ec6:	3f f8       	mov	r8,-1
80005ec8:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005ecc:	f0 1f 00 16 	mcall	80005f24 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005ed0:	f0 1f 00 12 	mcall	80005f18 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005ed4:	6f 18       	ld.w	r8,r7[0x44]
80005ed6:	58 08       	cp.w	r8,0
80005ed8:	e0 8a 00 18 	brle	80005f08 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005edc:	6e 48       	ld.w	r8,r7[0x10]
80005ede:	58 08       	cp.w	r8,0
80005ee0:	c1 40       	breq	80005f08 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005ee2:	ee c6 ff f0 	sub	r6,r7,-16
80005ee6:	c0 48       	rjmp	80005eee <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005ee8:	6e 48       	ld.w	r8,r7[0x10]
80005eea:	58 08       	cp.w	r8,0
80005eec:	c0 e0       	breq	80005f08 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005eee:	0c 9c       	mov	r12,r6
80005ef0:	f0 1f 00 0b 	mcall	80005f1c <prvUnlockQueue+0x94>
80005ef4:	c0 30       	breq	80005efa <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80005ef6:	f0 1f 00 0b 	mcall	80005f20 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005efa:	6f 18       	ld.w	r8,r7[0x44]
80005efc:	20 18       	sub	r8,1
80005efe:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005f02:	58 08       	cp.w	r8,0
80005f04:	fe 99 ff f2 	brgt	80005ee8 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005f08:	3f f8       	mov	r8,-1
80005f0a:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80005f0e:	f0 1f 00 06 	mcall	80005f24 <prvUnlockQueue+0x9c>
}
80005f12:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005f16:	00 00       	add	r0,r0
80005f18:	80 00       	ld.sh	r0,r0[0x0]
80005f1a:	5b 74       	cp.w	r4,-9
80005f1c:	80 00       	ld.sh	r0,r0[0x0]
80005f1e:	64 40       	ld.w	r0,r2[0x10]
80005f20:	80 00       	ld.sh	r0,r0[0x0]
80005f22:	63 4c       	ld.w	r12,r1[0x50]
80005f24:	80 00       	ld.sh	r0,r0[0x0]
80005f26:	5c 80       	casts.h	r0

80005f28 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005f28:	d4 31       	pushm	r0-r7,lr
80005f2a:	20 5d       	sub	sp,20
80005f2c:	18 97       	mov	r7,r12
80005f2e:	50 0b       	stdsp	sp[0x0],r11
80005f30:	50 2a       	stdsp	sp[0x8],r10
80005f32:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005f34:	f8 c2 ff dc 	sub	r2,r12,-36
80005f38:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005f3a:	fa c4 ff f4 	sub	r4,sp,-12
80005f3e:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005f40:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005f42:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80005f46:	f0 1f 00 3e 	mcall	8000603c <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005f4a:	6e e8       	ld.w	r8,r7[0x38]
80005f4c:	58 08       	cp.w	r8,0
80005f4e:	c2 a0       	breq	80005fa2 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80005f50:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80005f52:	40 0b       	lddsp	r11,sp[0x0]
80005f54:	0e 9c       	mov	r12,r7
80005f56:	f0 1f 00 3b 	mcall	80006040 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80005f5a:	40 18       	lddsp	r8,sp[0x4]
80005f5c:	58 08       	cp.w	r8,0
80005f5e:	c1 51       	brne	80005f88 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80005f60:	6e e8       	ld.w	r8,r7[0x38]
80005f62:	20 18       	sub	r8,1
80005f64:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005f66:	6e 08       	ld.w	r8,r7[0x0]
80005f68:	58 08       	cp.w	r8,0
80005f6a:	c0 41       	brne	80005f72 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80005f6c:	f0 1f 00 36 	mcall	80006044 <xQueueGenericReceive+0x11c>
80005f70:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005f72:	6e 48       	ld.w	r8,r7[0x10]
80005f74:	58 08       	cp.w	r8,0
80005f76:	c1 20       	breq	80005f9a <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80005f78:	ee cc ff f0 	sub	r12,r7,-16
80005f7c:	f0 1f 00 33 	mcall	80006048 <xQueueGenericReceive+0x120>
80005f80:	58 1c       	cp.w	r12,1
80005f82:	c0 c1       	brne	80005f9a <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80005f84:	d7 33       	scall
80005f86:	c0 a8       	rjmp	80005f9a <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80005f88:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005f8a:	6e 98       	ld.w	r8,r7[0x24]
80005f8c:	58 08       	cp.w	r8,0
80005f8e:	c0 60       	breq	80005f9a <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005f90:	04 9c       	mov	r12,r2
80005f92:	f0 1f 00 2e 	mcall	80006048 <xQueueGenericReceive+0x120>
80005f96:	c0 20       	breq	80005f9a <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80005f98:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80005f9a:	f0 1f 00 2d 	mcall	8000604c <xQueueGenericReceive+0x124>
80005f9e:	30 1c       	mov	r12,1
				return pdPASS;
80005fa0:	c4 c8       	rjmp	80006038 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005fa2:	40 28       	lddsp	r8,sp[0x8]
80005fa4:	58 08       	cp.w	r8,0
80005fa6:	c0 51       	brne	80005fb0 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005fa8:	f0 1f 00 29 	mcall	8000604c <xQueueGenericReceive+0x124>
80005fac:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80005fae:	c4 58       	rjmp	80006038 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80005fb0:	58 05       	cp.w	r5,0
80005fb2:	c0 51       	brne	80005fbc <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005fb4:	08 9c       	mov	r12,r4
80005fb6:	f0 1f 00 27 	mcall	80006050 <xQueueGenericReceive+0x128>
80005fba:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005fbc:	f0 1f 00 24 	mcall	8000604c <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005fc0:	f0 1f 00 25 	mcall	80006054 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005fc4:	f0 1f 00 1e 	mcall	8000603c <xQueueGenericReceive+0x114>
80005fc8:	6f 18       	ld.w	r8,r7[0x44]
80005fca:	5b f8       	cp.w	r8,-1
80005fcc:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005fd0:	6f 28       	ld.w	r8,r7[0x48]
80005fd2:	5b f8       	cp.w	r8,-1
80005fd4:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005fd8:	f0 1f 00 1d 	mcall	8000604c <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005fdc:	06 9b       	mov	r11,r3
80005fde:	08 9c       	mov	r12,r4
80005fe0:	f0 1f 00 1e 	mcall	80006058 <xQueueGenericReceive+0x130>
80005fe4:	c2 41       	brne	8000602c <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005fe6:	f0 1f 00 16 	mcall	8000603c <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005fea:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80005fec:	f0 1f 00 18 	mcall	8000604c <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80005ff0:	58 06       	cp.w	r6,0
80005ff2:	c1 71       	brne	80006020 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005ff4:	6e 08       	ld.w	r8,r7[0x0]
80005ff6:	58 08       	cp.w	r8,0
80005ff8:	c0 81       	brne	80006008 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80005ffa:	f0 1f 00 11 	mcall	8000603c <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80005ffe:	6e 1c       	ld.w	r12,r7[0x4]
80006000:	f0 1f 00 17 	mcall	8000605c <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80006004:	f0 1f 00 12 	mcall	8000604c <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006008:	40 2b       	lddsp	r11,sp[0x8]
8000600a:	04 9c       	mov	r12,r2
8000600c:	f0 1f 00 15 	mcall	80006060 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80006010:	0e 9c       	mov	r12,r7
80006012:	f0 1f 00 15 	mcall	80006064 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80006016:	f0 1f 00 15 	mcall	80006068 <xQueueGenericReceive+0x140>
8000601a:	c9 61       	brne	80005f46 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
8000601c:	d7 33       	scall
8000601e:	c9 4b       	rjmp	80005f46 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006020:	0e 9c       	mov	r12,r7
80006022:	f0 1f 00 11 	mcall	80006064 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80006026:	f0 1f 00 11 	mcall	80006068 <xQueueGenericReceive+0x140>
8000602a:	c8 eb       	rjmp	80005f46 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
8000602c:	0e 9c       	mov	r12,r7
8000602e:	f0 1f 00 0e 	mcall	80006064 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80006032:	f0 1f 00 0e 	mcall	80006068 <xQueueGenericReceive+0x140>
80006036:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80006038:	2f bd       	sub	sp,-20
8000603a:	d8 32       	popm	r0-r7,pc
8000603c:	80 00       	ld.sh	r0,r0[0x0]
8000603e:	5b 74       	cp.w	r4,-9
80006040:	80 00       	ld.sh	r0,r0[0x0]
80006042:	5e 08       	reteq	r8
80006044:	80 00       	ld.sh	r0,r0[0x0]
80006046:	63 58       	ld.w	r8,r1[0x54]
80006048:	80 00       	ld.sh	r0,r0[0x0]
8000604a:	64 40       	ld.w	r0,r2[0x10]
8000604c:	80 00       	ld.sh	r0,r0[0x0]
8000604e:	5c 80       	casts.h	r0
80006050:	80 00       	ld.sh	r0,r0[0x0]
80006052:	63 34       	ld.w	r4,r1[0x4c]
80006054:	80 00       	ld.sh	r0,r0[0x0]
80006056:	62 a8       	ld.w	r8,r1[0x28]
80006058:	80 00       	ld.sh	r0,r0[0x0]
8000605a:	65 d0       	ld.w	r0,r2[0x74]
8000605c:	80 00       	ld.sh	r0,r0[0x0]
8000605e:	63 bc       	ld.w	r12,r1[0x6c]
80006060:	80 00       	ld.sh	r0,r0[0x0]
80006062:	68 70       	ld.w	r0,r4[0x1c]
80006064:	80 00       	ld.sh	r0,r0[0x0]
80006066:	5e 88       	retls	r8
80006068:	80 00       	ld.sh	r0,r0[0x0]
8000606a:	66 64       	ld.w	r4,r3[0x18]

8000606c <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
8000606c:	eb cd 40 80 	pushm	r7,lr
80006070:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80006072:	79 08       	ld.w	r8,r12[0x40]
80006074:	58 08       	cp.w	r8,0
80006076:	c0 a1       	brne	8000608a <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006078:	78 08       	ld.w	r8,r12[0x0]
8000607a:	58 08       	cp.w	r8,0
8000607c:	c2 b1       	brne	800060d2 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
8000607e:	78 1c       	ld.w	r12,r12[0x4]
80006080:	f0 1f 00 17 	mcall	800060dc <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80006084:	30 08       	mov	r8,0
80006086:	8f 18       	st.w	r7[0x4],r8
80006088:	c2 58       	rjmp	800060d2 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
8000608a:	58 0a       	cp.w	r10,0
8000608c:	c1 01       	brne	800060ac <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000608e:	10 9a       	mov	r10,r8
80006090:	78 2c       	ld.w	r12,r12[0x8]
80006092:	f0 1f 00 14 	mcall	800060e0 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80006096:	6e 29       	ld.w	r9,r7[0x8]
80006098:	6f 08       	ld.w	r8,r7[0x40]
8000609a:	f2 08 00 08 	add	r8,r9,r8
8000609e:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
800060a0:	6e 19       	ld.w	r9,r7[0x4]
800060a2:	12 38       	cp.w	r8,r9
800060a4:	c1 73       	brcs	800060d2 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
800060a6:	6e 08       	ld.w	r8,r7[0x0]
800060a8:	8f 28       	st.w	r7[0x8],r8
800060aa:	c1 48       	rjmp	800060d2 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800060ac:	10 9a       	mov	r10,r8
800060ae:	78 3c       	ld.w	r12,r12[0xc]
800060b0:	f0 1f 00 0c 	mcall	800060e0 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
800060b4:	6f 08       	ld.w	r8,r7[0x40]
800060b6:	6e 39       	ld.w	r9,r7[0xc]
800060b8:	f2 08 01 08 	sub	r8,r9,r8
800060bc:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800060be:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800060c0:	12 38       	cp.w	r8,r9
800060c2:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
800060c6:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
800060ca:	f3 d8 e3 19 	subcs	r9,r9,r8
800060ce:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800060d2:	6e e8       	ld.w	r8,r7[0x38]
800060d4:	2f f8       	sub	r8,-1
800060d6:	8f e8       	st.w	r7[0x38],r8
}
800060d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800060dc:	80 00       	ld.sh	r0,r0[0x0]
800060de:	63 64       	ld.w	r4,r1[0x58]
800060e0:	80 00       	ld.sh	r0,r0[0x0]
800060e2:	75 94       	ld.w	r4,r10[0x64]

800060e4 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
800060e4:	eb cd 40 c0 	pushm	r6-r7,lr
800060e8:	18 97       	mov	r7,r12
800060ea:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800060ec:	78 ec       	ld.w	r12,r12[0x38]
800060ee:	6e f8       	ld.w	r8,r7[0x3c]
800060f0:	10 3c       	cp.w	r12,r8
800060f2:	c0 33       	brcs	800060f8 <xQueueGenericSendFromISR+0x14>
800060f4:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800060f8:	12 9a       	mov	r10,r9
800060fa:	0e 9c       	mov	r12,r7
800060fc:	f0 1f 00 0c 	mcall	8000612c <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80006100:	6f 28       	ld.w	r8,r7[0x48]
80006102:	5b f8       	cp.w	r8,-1
80006104:	c0 d1       	brne	8000611e <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006106:	6e 98       	ld.w	r8,r7[0x24]
80006108:	58 08       	cp.w	r8,0
8000610a:	c0 f0       	breq	80006128 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000610c:	ee cc ff dc 	sub	r12,r7,-36
80006110:	f0 1f 00 08 	mcall	80006130 <xQueueGenericSendFromISR+0x4c>
80006114:	c0 a0       	breq	80006128 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80006116:	30 1c       	mov	r12,1
80006118:	8d 0c       	st.w	r6[0x0],r12
8000611a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
8000611e:	2f f8       	sub	r8,-1
80006120:	ef 48 00 48 	st.w	r7[72],r8
80006124:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006128:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000612c:	80 00       	ld.sh	r0,r0[0x0]
8000612e:	60 6c       	ld.w	r12,r0[0x18]
80006130:	80 00       	ld.sh	r0,r0[0x0]
80006132:	64 40       	ld.w	r0,r2[0x10]

80006134 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80006134:	d4 31       	pushm	r0-r7,lr
80006136:	20 5d       	sub	sp,20
80006138:	18 97       	mov	r7,r12
8000613a:	50 0b       	stdsp	sp[0x0],r11
8000613c:	50 2a       	stdsp	sp[0x8],r10
8000613e:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80006140:	f8 c0 ff f0 	sub	r0,r12,-16
80006144:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006146:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
8000614a:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000614c:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80006150:	f0 1f 00 2f 	mcall	8000620c <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006154:	6e e9       	ld.w	r9,r7[0x38]
80006156:	6e f8       	ld.w	r8,r7[0x3c]
80006158:	10 39       	cp.w	r9,r8
8000615a:	c1 42       	brcc	80006182 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
8000615c:	40 1a       	lddsp	r10,sp[0x4]
8000615e:	40 0b       	lddsp	r11,sp[0x0]
80006160:	0e 9c       	mov	r12,r7
80006162:	f0 1f 00 2c 	mcall	80006210 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006166:	6e 98       	ld.w	r8,r7[0x24]
80006168:	58 08       	cp.w	r8,0
8000616a:	c0 80       	breq	8000617a <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
8000616c:	ee cc ff dc 	sub	r12,r7,-36
80006170:	f0 1f 00 29 	mcall	80006214 <xQueueGenericSend+0xe0>
80006174:	58 1c       	cp.w	r12,1
80006176:	c0 21       	brne	8000617a <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80006178:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
8000617a:	f0 1f 00 28 	mcall	80006218 <xQueueGenericSend+0xe4>
8000617e:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80006180:	c4 38       	rjmp	80006206 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80006182:	40 28       	lddsp	r8,sp[0x8]
80006184:	58 08       	cp.w	r8,0
80006186:	c0 51       	brne	80006190 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006188:	f0 1f 00 24 	mcall	80006218 <xQueueGenericSend+0xe4>
8000618c:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
8000618e:	c3 c8       	rjmp	80006206 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80006190:	58 04       	cp.w	r4,0
80006192:	c0 51       	brne	8000619c <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006194:	06 9c       	mov	r12,r3
80006196:	f0 1f 00 22 	mcall	8000621c <xQueueGenericSend+0xe8>
8000619a:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
8000619c:	f0 1f 00 1f 	mcall	80006218 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800061a0:	f0 1f 00 20 	mcall	80006220 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
800061a4:	f0 1f 00 1a 	mcall	8000620c <xQueueGenericSend+0xd8>
800061a8:	6f 18       	ld.w	r8,r7[0x44]
800061aa:	5b f8       	cp.w	r8,-1
800061ac:	ef f1 0a 11 	st.weq	r7[0x44],r1
800061b0:	6f 28       	ld.w	r8,r7[0x48]
800061b2:	5b f8       	cp.w	r8,-1
800061b4:	ef f1 0a 12 	st.weq	r7[0x48],r1
800061b8:	f0 1f 00 18 	mcall	80006218 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800061bc:	04 9b       	mov	r11,r2
800061be:	06 9c       	mov	r12,r3
800061c0:	f0 1f 00 19 	mcall	80006224 <xQueueGenericSend+0xf0>
800061c4:	c1 b1       	brne	800061fa <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800061c6:	f0 1f 00 12 	mcall	8000620c <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800061ca:	6e e5       	ld.w	r5,r7[0x38]
800061cc:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800061ce:	f0 1f 00 13 	mcall	80006218 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800061d2:	0c 35       	cp.w	r5,r6
800061d4:	c0 d1       	brne	800061ee <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800061d6:	40 2b       	lddsp	r11,sp[0x8]
800061d8:	00 9c       	mov	r12,r0
800061da:	f0 1f 00 14 	mcall	80006228 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800061de:	0e 9c       	mov	r12,r7
800061e0:	f0 1f 00 13 	mcall	8000622c <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800061e4:	f0 1f 00 13 	mcall	80006230 <xQueueGenericSend+0xfc>
800061e8:	cb 41       	brne	80006150 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
800061ea:	d7 33       	scall
800061ec:	cb 2b       	rjmp	80006150 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800061ee:	0e 9c       	mov	r12,r7
800061f0:	f0 1f 00 0f 	mcall	8000622c <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800061f4:	f0 1f 00 0f 	mcall	80006230 <xQueueGenericSend+0xfc>
800061f8:	ca cb       	rjmp	80006150 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800061fa:	0e 9c       	mov	r12,r7
800061fc:	f0 1f 00 0c 	mcall	8000622c <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80006200:	f0 1f 00 0c 	mcall	80006230 <xQueueGenericSend+0xfc>
80006204:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80006206:	2f bd       	sub	sp,-20
80006208:	d8 32       	popm	r0-r7,pc
8000620a:	00 00       	add	r0,r0
8000620c:	80 00       	ld.sh	r0,r0[0x0]
8000620e:	5b 74       	cp.w	r4,-9
80006210:	80 00       	ld.sh	r0,r0[0x0]
80006212:	60 6c       	ld.w	r12,r0[0x18]
80006214:	80 00       	ld.sh	r0,r0[0x0]
80006216:	64 40       	ld.w	r0,r2[0x10]
80006218:	80 00       	ld.sh	r0,r0[0x0]
8000621a:	5c 80       	casts.h	r0
8000621c:	80 00       	ld.sh	r0,r0[0x0]
8000621e:	63 34       	ld.w	r4,r1[0x4c]
80006220:	80 00       	ld.sh	r0,r0[0x0]
80006222:	62 a8       	ld.w	r8,r1[0x28]
80006224:	80 00       	ld.sh	r0,r0[0x0]
80006226:	65 d0       	ld.w	r0,r2[0x74]
80006228:	80 00       	ld.sh	r0,r0[0x0]
8000622a:	68 70       	ld.w	r0,r4[0x1c]
8000622c:	80 00       	ld.sh	r0,r0[0x0]
8000622e:	5e 88       	retls	r8
80006230:	80 00       	ld.sh	r0,r0[0x0]
80006232:	66 64       	ld.w	r4,r3[0x18]

80006234 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80006234:	d4 21       	pushm	r4-r7,lr
80006236:	18 97       	mov	r7,r12
80006238:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
8000623a:	58 0c       	cp.w	r12,0
8000623c:	c2 f0       	breq	8000629a <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
8000623e:	34 cc       	mov	r12,76
80006240:	f0 1f 00 17 	mcall	8000629c <xQueueCreate+0x68>
80006244:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80006246:	c2 a0       	breq	8000629a <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80006248:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
8000624c:	e8 cc ff ff 	sub	r12,r4,-1
80006250:	f0 1f 00 13 	mcall	8000629c <xQueueCreate+0x68>
80006254:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80006256:	c1 e0       	breq	80006292 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80006258:	f8 04 00 04 	add	r4,r12,r4
8000625c:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
8000625e:	30 08       	mov	r8,0
80006260:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80006262:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80006264:	ee c8 00 01 	sub	r8,r7,1
80006268:	ad 38       	mul	r8,r6
8000626a:	10 0c       	add	r12,r8
8000626c:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
8000626e:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80006270:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80006274:	3f f8       	mov	r8,-1
80006276:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
8000627a:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000627e:	ea cc ff f0 	sub	r12,r5,-16
80006282:	f0 1f 00 08 	mcall	800062a0 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80006286:	ea cc ff dc 	sub	r12,r5,-36
8000628a:	f0 1f 00 06 	mcall	800062a0 <xQueueCreate+0x6c>
8000628e:	0a 9c       	mov	r12,r5
80006290:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80006292:	0a 9c       	mov	r12,r5
80006294:	f0 1f 00 04 	mcall	800062a4 <xQueueCreate+0x70>
80006298:	d8 2a       	popm	r4-r7,pc,r12=0
8000629a:	d8 2a       	popm	r4-r7,pc,r12=0
8000629c:	80 00       	ld.sh	r0,r0[0x0]
8000629e:	5d e0       	*unknown*
800062a0:	80 00       	ld.sh	r0,r0[0x0]
800062a2:	5a 50       	cp.w	r0,-27
800062a4:	80 00       	ld.sh	r0,r0[0x0]
800062a6:	5d b8       	*unknown*

800062a8 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800062a8:	48 38       	lddpc	r8,800062b4 <vTaskSuspendAll+0xc>
800062aa:	70 09       	ld.w	r9,r8[0x0]
800062ac:	2f f9       	sub	r9,-1
800062ae:	91 09       	st.w	r8[0x0],r9
}
800062b0:	5e fc       	retal	r12
800062b2:	00 00       	add	r0,r0
800062b4:	00 00       	add	r0,r0
800062b6:	0d 04       	ld.w	r4,r6++

800062b8 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800062b8:	49 a8       	lddpc	r8,80006320 <vTaskSwitchContext+0x68>
800062ba:	70 08       	ld.w	r8,r8[0x0]
800062bc:	58 08       	cp.w	r8,0
800062be:	c0 b1       	brne	800062d4 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800062c0:	49 98       	lddpc	r8,80006324 <vTaskSwitchContext+0x6c>
800062c2:	70 08       	ld.w	r8,r8[0x0]
800062c4:	f0 08 00 28 	add	r8,r8,r8<<0x2
800062c8:	49 89       	lddpc	r9,80006328 <vTaskSwitchContext+0x70>
800062ca:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800062ce:	58 08       	cp.w	r8,0
800062d0:	c0 60       	breq	800062dc <vTaskSwitchContext+0x24>
800062d2:	c1 18       	rjmp	800062f4 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800062d4:	30 19       	mov	r9,1
800062d6:	49 68       	lddpc	r8,8000632c <vTaskSwitchContext+0x74>
800062d8:	91 09       	st.w	r8[0x0],r9
800062da:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800062dc:	49 28       	lddpc	r8,80006324 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800062de:	49 3a       	lddpc	r10,80006328 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800062e0:	70 09       	ld.w	r9,r8[0x0]
800062e2:	20 19       	sub	r9,1
800062e4:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800062e6:	70 09       	ld.w	r9,r8[0x0]
800062e8:	f2 09 00 29 	add	r9,r9,r9<<0x2
800062ec:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800062f0:	58 09       	cp.w	r9,0
800062f2:	cf 70       	breq	800062e0 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800062f4:	48 c8       	lddpc	r8,80006324 <vTaskSwitchContext+0x6c>
800062f6:	70 08       	ld.w	r8,r8[0x0]
800062f8:	f0 08 00 28 	add	r8,r8,r8<<0x2
800062fc:	48 b9       	lddpc	r9,80006328 <vTaskSwitchContext+0x70>
800062fe:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006302:	70 19       	ld.w	r9,r8[0x4]
80006304:	72 19       	ld.w	r9,r9[0x4]
80006306:	91 19       	st.w	r8[0x4],r9
80006308:	f0 ca ff f8 	sub	r10,r8,-8
8000630c:	14 39       	cp.w	r9,r10
8000630e:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80006312:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80006316:	70 18       	ld.w	r8,r8[0x4]
80006318:	70 39       	ld.w	r9,r8[0xc]
8000631a:	48 68       	lddpc	r8,80006330 <vTaskSwitchContext+0x78>
8000631c:	91 09       	st.w	r8[0x0],r9
8000631e:	5e fc       	retal	r12
80006320:	00 00       	add	r0,r0
80006322:	0d 04       	ld.w	r4,r6++
80006324:	00 00       	add	r0,r0
80006326:	0d 3c       	ld.ub	r12,r6++
80006328:	00 00       	add	r0,r0
8000632a:	0c 20       	rsub	r0,r6
8000632c:	00 00       	add	r0,r0
8000632e:	0d 24       	ld.uh	r4,r6++
80006330:	00 00       	add	r0,r0
80006332:	0c d4       	st.w	--r6,r4

80006334 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80006334:	48 48       	lddpc	r8,80006344 <vTaskSetTimeOutState+0x10>
80006336:	70 08       	ld.w	r8,r8[0x0]
80006338:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
8000633a:	48 48       	lddpc	r8,80006348 <vTaskSetTimeOutState+0x14>
8000633c:	70 08       	ld.w	r8,r8[0x0]
8000633e:	99 18       	st.w	r12[0x4],r8
}
80006340:	5e fc       	retal	r12
80006342:	00 00       	add	r0,r0
80006344:	00 00       	add	r0,r0
80006346:	0c 18       	sub	r8,r6
80006348:	00 00       	add	r0,r0
8000634a:	0d 00       	ld.w	r0,r6++

8000634c <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
8000634c:	30 19       	mov	r9,1
8000634e:	48 28       	lddpc	r8,80006354 <vTaskMissedYield+0x8>
80006350:	91 09       	st.w	r8[0x0],r9
}
80006352:	5e fc       	retal	r12
80006354:	00 00       	add	r0,r0
80006356:	0d 24       	ld.uh	r4,r6++

80006358 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80006358:	48 28       	lddpc	r8,80006360 <xTaskGetCurrentTaskHandle+0x8>
8000635a:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
8000635c:	5e fc       	retal	r12
8000635e:	00 00       	add	r0,r0
80006360:	00 00       	add	r0,r0
80006362:	0c d4       	st.w	--r6,r4

80006364 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80006364:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80006368:	58 0c       	cp.w	r12,0
8000636a:	c1 f0       	breq	800063a8 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
8000636c:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
8000636e:	78 b9       	ld.w	r9,r12[0x2c]
80006370:	79 18       	ld.w	r8,r12[0x44]
80006372:	10 39       	cp.w	r9,r8
80006374:	c1 a0       	breq	800063a8 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80006376:	f8 c6 ff fc 	sub	r6,r12,-4
8000637a:	0c 9c       	mov	r12,r6
8000637c:	f0 1f 00 0c 	mcall	800063ac <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80006380:	6f 1c       	ld.w	r12,r7[0x44]
80006382:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80006384:	f8 08 11 08 	rsub	r8,r12,8
80006388:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
8000638a:	48 a8       	lddpc	r8,800063b0 <vTaskPriorityDisinherit+0x4c>
8000638c:	70 08       	ld.w	r8,r8[0x0]
8000638e:	10 3c       	cp.w	r12,r8
80006390:	e0 88 00 04 	brls	80006398 <vTaskPriorityDisinherit+0x34>
80006394:	48 78       	lddpc	r8,800063b0 <vTaskPriorityDisinherit+0x4c>
80006396:	91 0c       	st.w	r8[0x0],r12
80006398:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000639c:	0c 9b       	mov	r11,r6
8000639e:	48 68       	lddpc	r8,800063b4 <vTaskPriorityDisinherit+0x50>
800063a0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800063a4:	f0 1f 00 05 	mcall	800063b8 <vTaskPriorityDisinherit+0x54>
800063a8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800063ac:	80 00       	ld.sh	r0,r0[0x0]
800063ae:	5a ba       	cp.w	r10,-21
800063b0:	00 00       	add	r0,r0
800063b2:	0d 3c       	ld.ub	r12,r6++
800063b4:	00 00       	add	r0,r0
800063b6:	0c 20       	rsub	r0,r6
800063b8:	80 00       	ld.sh	r0,r0[0x0]
800063ba:	5a 6a       	cp.w	r10,-26

800063bc <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800063bc:	eb cd 40 c0 	pushm	r6-r7,lr
800063c0:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
800063c2:	49 b8       	lddpc	r8,8000642c <vTaskPriorityInherit+0x70>
800063c4:	70 08       	ld.w	r8,r8[0x0]
800063c6:	78 b9       	ld.w	r9,r12[0x2c]
800063c8:	70 b8       	ld.w	r8,r8[0x2c]
800063ca:	10 39       	cp.w	r9,r8
800063cc:	c2 d2       	brcc	80006426 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800063ce:	49 88       	lddpc	r8,8000642c <vTaskPriorityInherit+0x70>
800063d0:	70 08       	ld.w	r8,r8[0x0]
800063d2:	70 b8       	ld.w	r8,r8[0x2c]
800063d4:	f0 08 11 08 	rsub	r8,r8,8
800063d8:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800063da:	f2 09 00 28 	add	r8,r9,r9<<0x2
800063de:	49 59       	lddpc	r9,80006430 <vTaskPriorityInherit+0x74>
800063e0:	f2 08 00 28 	add	r8,r9,r8<<0x2
800063e4:	78 59       	ld.w	r9,r12[0x14]
800063e6:	10 39       	cp.w	r9,r8
800063e8:	c1 b1       	brne	8000641e <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800063ea:	f8 c6 ff fc 	sub	r6,r12,-4
800063ee:	0c 9c       	mov	r12,r6
800063f0:	f0 1f 00 11 	mcall	80006434 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800063f4:	48 e8       	lddpc	r8,8000642c <vTaskPriorityInherit+0x70>
800063f6:	70 08       	ld.w	r8,r8[0x0]
800063f8:	70 bc       	ld.w	r12,r8[0x2c]
800063fa:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800063fc:	48 f8       	lddpc	r8,80006438 <vTaskPriorityInherit+0x7c>
800063fe:	70 08       	ld.w	r8,r8[0x0]
80006400:	10 3c       	cp.w	r12,r8
80006402:	e0 88 00 04 	brls	8000640a <vTaskPriorityInherit+0x4e>
80006406:	48 d8       	lddpc	r8,80006438 <vTaskPriorityInherit+0x7c>
80006408:	91 0c       	st.w	r8[0x0],r12
8000640a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000640e:	0c 9b       	mov	r11,r6
80006410:	48 88       	lddpc	r8,80006430 <vTaskPriorityInherit+0x74>
80006412:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006416:	f0 1f 00 0a 	mcall	8000643c <vTaskPriorityInherit+0x80>
8000641a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000641e:	48 48       	lddpc	r8,8000642c <vTaskPriorityInherit+0x70>
80006420:	70 08       	ld.w	r8,r8[0x0]
80006422:	70 b8       	ld.w	r8,r8[0x2c]
80006424:	99 b8       	st.w	r12[0x2c],r8
80006426:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000642a:	00 00       	add	r0,r0
8000642c:	00 00       	add	r0,r0
8000642e:	0c d4       	st.w	--r6,r4
80006430:	00 00       	add	r0,r0
80006432:	0c 20       	rsub	r0,r6
80006434:	80 00       	ld.sh	r0,r0[0x0]
80006436:	5a ba       	cp.w	r10,-21
80006438:	00 00       	add	r0,r0
8000643a:	0d 3c       	ld.ub	r12,r6++
8000643c:	80 00       	ld.sh	r0,r0[0x0]
8000643e:	5a 6a       	cp.w	r10,-26

80006440 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80006440:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80006444:	78 38       	ld.w	r8,r12[0xc]
80006446:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80006448:	ee c6 ff e8 	sub	r6,r7,-24
8000644c:	0c 9c       	mov	r12,r6
8000644e:	f0 1f 00 15 	mcall	800064a0 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006452:	49 58       	lddpc	r8,800064a4 <xTaskRemoveFromEventList+0x64>
80006454:	70 08       	ld.w	r8,r8[0x0]
80006456:	58 08       	cp.w	r8,0
80006458:	c1 71       	brne	80006486 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
8000645a:	ee c6 ff fc 	sub	r6,r7,-4
8000645e:	0c 9c       	mov	r12,r6
80006460:	f0 1f 00 10 	mcall	800064a0 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80006464:	6e bc       	ld.w	r12,r7[0x2c]
80006466:	49 18       	lddpc	r8,800064a8 <xTaskRemoveFromEventList+0x68>
80006468:	70 08       	ld.w	r8,r8[0x0]
8000646a:	10 3c       	cp.w	r12,r8
8000646c:	e0 88 00 04 	brls	80006474 <xTaskRemoveFromEventList+0x34>
80006470:	48 e8       	lddpc	r8,800064a8 <xTaskRemoveFromEventList+0x68>
80006472:	91 0c       	st.w	r8[0x0],r12
80006474:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006478:	0c 9b       	mov	r11,r6
8000647a:	48 d8       	lddpc	r8,800064ac <xTaskRemoveFromEventList+0x6c>
8000647c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006480:	f0 1f 00 0c 	mcall	800064b0 <xTaskRemoveFromEventList+0x70>
80006484:	c0 58       	rjmp	8000648e <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80006486:	0c 9b       	mov	r11,r6
80006488:	48 bc       	lddpc	r12,800064b4 <xTaskRemoveFromEventList+0x74>
8000648a:	f0 1f 00 0a 	mcall	800064b0 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000648e:	48 b8       	lddpc	r8,800064b8 <xTaskRemoveFromEventList+0x78>
80006490:	70 08       	ld.w	r8,r8[0x0]
80006492:	6e b9       	ld.w	r9,r7[0x2c]
80006494:	70 b8       	ld.w	r8,r8[0x2c]
80006496:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80006498:	5f 2c       	srhs	r12
8000649a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000649e:	00 00       	add	r0,r0
800064a0:	80 00       	ld.sh	r0,r0[0x0]
800064a2:	5a ba       	cp.w	r10,-21
800064a4:	00 00       	add	r0,r0
800064a6:	0d 04       	ld.w	r4,r6++
800064a8:	00 00       	add	r0,r0
800064aa:	0d 3c       	ld.ub	r12,r6++
800064ac:	00 00       	add	r0,r0
800064ae:	0c 20       	rsub	r0,r6
800064b0:	80 00       	ld.sh	r0,r0[0x0]
800064b2:	5a 6a       	cp.w	r10,-26
800064b4:	00 00       	add	r0,r0
800064b6:	0c d8       	st.w	--r6,r8
800064b8:	00 00       	add	r0,r0
800064ba:	0c d4       	st.w	--r6,r4

800064bc <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800064bc:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800064c0:	4b 98       	lddpc	r8,800065a4 <vTaskIncrementTick+0xe8>
800064c2:	70 08       	ld.w	r8,r8[0x0]
800064c4:	58 08       	cp.w	r8,0
800064c6:	c6 91       	brne	80006598 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800064c8:	4b 88       	lddpc	r8,800065a8 <vTaskIncrementTick+0xec>
800064ca:	70 09       	ld.w	r9,r8[0x0]
800064cc:	2f f9       	sub	r9,-1
800064ce:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800064d0:	70 08       	ld.w	r8,r8[0x0]
800064d2:	58 08       	cp.w	r8,0
800064d4:	c1 a1       	brne	80006508 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800064d6:	4b 68       	lddpc	r8,800065ac <vTaskIncrementTick+0xf0>
800064d8:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800064da:	4b 69       	lddpc	r9,800065b0 <vTaskIncrementTick+0xf4>
800064dc:	72 0b       	ld.w	r11,r9[0x0]
800064de:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800064e0:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800064e2:	4b 59       	lddpc	r9,800065b4 <vTaskIncrementTick+0xf8>
800064e4:	72 0a       	ld.w	r10,r9[0x0]
800064e6:	2f fa       	sub	r10,-1
800064e8:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800064ea:	70 08       	ld.w	r8,r8[0x0]
800064ec:	70 08       	ld.w	r8,r8[0x0]
800064ee:	58 08       	cp.w	r8,0
800064f0:	c0 51       	brne	800064fa <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800064f2:	3f f9       	mov	r9,-1
800064f4:	4b 18       	lddpc	r8,800065b8 <vTaskIncrementTick+0xfc>
800064f6:	91 09       	st.w	r8[0x0],r9
800064f8:	c0 88       	rjmp	80006508 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800064fa:	4a d8       	lddpc	r8,800065ac <vTaskIncrementTick+0xf0>
800064fc:	70 08       	ld.w	r8,r8[0x0]
800064fe:	70 38       	ld.w	r8,r8[0xc]
80006500:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80006502:	70 19       	ld.w	r9,r8[0x4]
80006504:	4a d8       	lddpc	r8,800065b8 <vTaskIncrementTick+0xfc>
80006506:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80006508:	4a 88       	lddpc	r8,800065a8 <vTaskIncrementTick+0xec>
8000650a:	70 09       	ld.w	r9,r8[0x0]
8000650c:	4a b8       	lddpc	r8,800065b8 <vTaskIncrementTick+0xfc>
8000650e:	70 08       	ld.w	r8,r8[0x0]
80006510:	10 39       	cp.w	r9,r8
80006512:	c4 73       	brcs	800065a0 <vTaskIncrementTick+0xe4>
80006514:	4a 68       	lddpc	r8,800065ac <vTaskIncrementTick+0xf0>
80006516:	70 08       	ld.w	r8,r8[0x0]
80006518:	70 08       	ld.w	r8,r8[0x0]
8000651a:	58 08       	cp.w	r8,0
8000651c:	c0 c0       	breq	80006534 <vTaskIncrementTick+0x78>
8000651e:	4a 48       	lddpc	r8,800065ac <vTaskIncrementTick+0xf0>
80006520:	70 08       	ld.w	r8,r8[0x0]
80006522:	70 38       	ld.w	r8,r8[0xc]
80006524:	70 37       	ld.w	r7,r8[0xc]
80006526:	6e 18       	ld.w	r8,r7[0x4]
80006528:	4a 09       	lddpc	r9,800065a8 <vTaskIncrementTick+0xec>
8000652a:	72 09       	ld.w	r9,r9[0x0]
8000652c:	12 38       	cp.w	r8,r9
8000652e:	e0 88 00 14 	brls	80006556 <vTaskIncrementTick+0x9a>
80006532:	c0 e8       	rjmp	8000654e <vTaskIncrementTick+0x92>
80006534:	3f f9       	mov	r9,-1
80006536:	4a 18       	lddpc	r8,800065b8 <vTaskIncrementTick+0xfc>
80006538:	91 09       	st.w	r8[0x0],r9
8000653a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000653e:	6a 08       	ld.w	r8,r5[0x0]
80006540:	70 38       	ld.w	r8,r8[0xc]
80006542:	70 37       	ld.w	r7,r8[0xc]
80006544:	6e 18       	ld.w	r8,r7[0x4]
80006546:	64 09       	ld.w	r9,r2[0x0]
80006548:	12 38       	cp.w	r8,r9
8000654a:	e0 88 00 0a 	brls	8000655e <vTaskIncrementTick+0xa2>
8000654e:	49 b9       	lddpc	r9,800065b8 <vTaskIncrementTick+0xfc>
80006550:	93 08       	st.w	r9[0x0],r8
80006552:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006556:	49 a4       	lddpc	r4,800065bc <vTaskIncrementTick+0x100>
80006558:	49 a3       	lddpc	r3,800065c0 <vTaskIncrementTick+0x104>
8000655a:	49 55       	lddpc	r5,800065ac <vTaskIncrementTick+0xf0>
8000655c:	49 32       	lddpc	r2,800065a8 <vTaskIncrementTick+0xec>
8000655e:	ee c6 ff fc 	sub	r6,r7,-4
80006562:	0c 9c       	mov	r12,r6
80006564:	f0 1f 00 18 	mcall	800065c4 <vTaskIncrementTick+0x108>
80006568:	6e a8       	ld.w	r8,r7[0x28]
8000656a:	58 08       	cp.w	r8,0
8000656c:	c0 50       	breq	80006576 <vTaskIncrementTick+0xba>
8000656e:	ee cc ff e8 	sub	r12,r7,-24
80006572:	f0 1f 00 15 	mcall	800065c4 <vTaskIncrementTick+0x108>
80006576:	6e bc       	ld.w	r12,r7[0x2c]
80006578:	68 08       	ld.w	r8,r4[0x0]
8000657a:	10 3c       	cp.w	r12,r8
8000657c:	e9 fc ba 00 	st.whi	r4[0x0],r12
80006580:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006584:	0c 9b       	mov	r11,r6
80006586:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
8000658a:	f0 1f 00 10 	mcall	800065c8 <vTaskIncrementTick+0x10c>
8000658e:	6a 08       	ld.w	r8,r5[0x0]
80006590:	70 08       	ld.w	r8,r8[0x0]
80006592:	58 08       	cp.w	r8,0
80006594:	cd 51       	brne	8000653e <vTaskIncrementTick+0x82>
80006596:	cc fb       	rjmp	80006534 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80006598:	48 d8       	lddpc	r8,800065cc <vTaskIncrementTick+0x110>
8000659a:	70 09       	ld.w	r9,r8[0x0]
8000659c:	2f f9       	sub	r9,-1
8000659e:	91 09       	st.w	r8[0x0],r9
800065a0:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800065a4:	00 00       	add	r0,r0
800065a6:	0d 04       	ld.w	r4,r6++
800065a8:	00 00       	add	r0,r0
800065aa:	0d 00       	ld.w	r0,r6++
800065ac:	00 00       	add	r0,r0
800065ae:	0c 0c       	add	r12,r6
800065b0:	00 00       	add	r0,r0
800065b2:	0c 1c       	sub	r12,r6
800065b4:	00 00       	add	r0,r0
800065b6:	0c 18       	sub	r8,r6
800065b8:	00 00       	add	r0,r0
800065ba:	05 38       	ld.ub	r8,r2++
800065bc:	00 00       	add	r0,r0
800065be:	0d 3c       	ld.ub	r12,r6++
800065c0:	00 00       	add	r0,r0
800065c2:	0c 20       	rsub	r0,r6
800065c4:	80 00       	ld.sh	r0,r0[0x0]
800065c6:	5a ba       	cp.w	r10,-21
800065c8:	80 00       	ld.sh	r0,r0[0x0]
800065ca:	5a 6a       	cp.w	r10,-26
800065cc:	00 00       	add	r0,r0
800065ce:	0c 04       	add	r4,r6

800065d0 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800065d0:	eb cd 40 c0 	pushm	r6-r7,lr
800065d4:	18 97       	mov	r7,r12
800065d6:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800065d8:	f0 1f 00 15 	mcall	8000662c <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800065dc:	6c 08       	ld.w	r8,r6[0x0]
800065de:	5b f8       	cp.w	r8,-1
800065e0:	c0 31       	brne	800065e6 <xTaskCheckForTimeOut+0x16>
800065e2:	30 07       	mov	r7,0
800065e4:	c1 f8       	rjmp	80006622 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800065e6:	49 39       	lddpc	r9,80006630 <xTaskCheckForTimeOut+0x60>
800065e8:	72 09       	ld.w	r9,r9[0x0]
800065ea:	6e 0a       	ld.w	r10,r7[0x0]
800065ec:	12 3a       	cp.w	r10,r9
800065ee:	c0 70       	breq	800065fc <xTaskCheckForTimeOut+0x2c>
800065f0:	49 19       	lddpc	r9,80006634 <xTaskCheckForTimeOut+0x64>
800065f2:	72 09       	ld.w	r9,r9[0x0]
800065f4:	6e 1a       	ld.w	r10,r7[0x4]
800065f6:	12 3a       	cp.w	r10,r9
800065f8:	e0 88 00 14 	brls	80006620 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800065fc:	48 e9       	lddpc	r9,80006634 <xTaskCheckForTimeOut+0x64>
800065fe:	72 0a       	ld.w	r10,r9[0x0]
80006600:	6e 19       	ld.w	r9,r7[0x4]
80006602:	12 1a       	sub	r10,r9
80006604:	14 38       	cp.w	r8,r10
80006606:	e0 88 00 0d 	brls	80006620 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
8000660a:	48 ba       	lddpc	r10,80006634 <xTaskCheckForTimeOut+0x64>
8000660c:	74 0a       	ld.w	r10,r10[0x0]
8000660e:	14 19       	sub	r9,r10
80006610:	f2 08 00 08 	add	r8,r9,r8
80006614:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80006616:	0e 9c       	mov	r12,r7
80006618:	f0 1f 00 08 	mcall	80006638 <xTaskCheckForTimeOut+0x68>
8000661c:	30 07       	mov	r7,0
8000661e:	c0 28       	rjmp	80006622 <xTaskCheckForTimeOut+0x52>
80006620:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80006622:	f0 1f 00 07 	mcall	8000663c <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80006626:	0e 9c       	mov	r12,r7
80006628:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000662c:	80 00       	ld.sh	r0,r0[0x0]
8000662e:	5b 74       	cp.w	r4,-9
80006630:	00 00       	add	r0,r0
80006632:	0c 18       	sub	r8,r6
80006634:	00 00       	add	r0,r0
80006636:	0d 00       	ld.w	r0,r6++
80006638:	80 00       	ld.sh	r0,r0[0x0]
8000663a:	63 34       	ld.w	r4,r1[0x4c]
8000663c:	80 00       	ld.sh	r0,r0[0x0]
8000663e:	5c 80       	casts.h	r0

80006640 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80006640:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80006644:	f0 1f 00 05 	mcall	80006658 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80006648:	48 58       	lddpc	r8,8000665c <xTaskGetTickCount+0x1c>
8000664a:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
8000664c:	f0 1f 00 05 	mcall	80006660 <xTaskGetTickCount+0x20>

	return xTicks;
}
80006650:	0e 9c       	mov	r12,r7
80006652:	e3 cd 80 80 	ldm	sp++,r7,pc
80006656:	00 00       	add	r0,r0
80006658:	80 00       	ld.sh	r0,r0[0x0]
8000665a:	5b 74       	cp.w	r4,-9
8000665c:	00 00       	add	r0,r0
8000665e:	0d 00       	ld.w	r0,r6++
80006660:	80 00       	ld.sh	r0,r0[0x0]
80006662:	5c 80       	casts.h	r0

80006664 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80006664:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80006668:	f0 1f 00 2c 	mcall	80006718 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
8000666c:	4a c8       	lddpc	r8,8000671c <xTaskResumeAll+0xb8>
8000666e:	70 09       	ld.w	r9,r8[0x0]
80006670:	20 19       	sub	r9,1
80006672:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006674:	70 08       	ld.w	r8,r8[0x0]
80006676:	58 08       	cp.w	r8,0
80006678:	c4 91       	brne	8000670a <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
8000667a:	4a a8       	lddpc	r8,80006720 <xTaskResumeAll+0xbc>
8000667c:	70 08       	ld.w	r8,r8[0x0]
8000667e:	58 08       	cp.w	r8,0
80006680:	c4 50       	breq	8000670a <xTaskResumeAll+0xa6>
80006682:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006684:	4a 85       	lddpc	r5,80006724 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80006686:	4a 93       	lddpc	r3,80006728 <xTaskResumeAll+0xc4>
80006688:	4a 92       	lddpc	r2,8000672c <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000668a:	4a a1       	lddpc	r1,80006730 <xTaskResumeAll+0xcc>
8000668c:	c1 e8       	rjmp	800066c8 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
8000668e:	6a 38       	ld.w	r8,r5[0xc]
80006690:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80006692:	ee cc ff e8 	sub	r12,r7,-24
80006696:	f0 1f 00 28 	mcall	80006734 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
8000669a:	ee c6 ff fc 	sub	r6,r7,-4
8000669e:	0c 9c       	mov	r12,r6
800066a0:	f0 1f 00 25 	mcall	80006734 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800066a4:	6e bc       	ld.w	r12,r7[0x2c]
800066a6:	66 08       	ld.w	r8,r3[0x0]
800066a8:	10 3c       	cp.w	r12,r8
800066aa:	e7 fc ba 00 	st.whi	r3[0x0],r12
800066ae:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800066b2:	0c 9b       	mov	r11,r6
800066b4:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800066b8:	f0 1f 00 20 	mcall	80006738 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800066bc:	62 08       	ld.w	r8,r1[0x0]
800066be:	6e b9       	ld.w	r9,r7[0x2c]
800066c0:	70 b8       	ld.w	r8,r8[0x2c]
800066c2:	10 39       	cp.w	r9,r8
800066c4:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800066c8:	6a 08       	ld.w	r8,r5[0x0]
800066ca:	58 08       	cp.w	r8,0
800066cc:	ce 11       	brne	8000668e <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800066ce:	49 c8       	lddpc	r8,8000673c <xTaskResumeAll+0xd8>
800066d0:	70 08       	ld.w	r8,r8[0x0]
800066d2:	58 08       	cp.w	r8,0
800066d4:	c0 f0       	breq	800066f2 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800066d6:	49 a8       	lddpc	r8,8000673c <xTaskResumeAll+0xd8>
800066d8:	70 08       	ld.w	r8,r8[0x0]
800066da:	58 08       	cp.w	r8,0
800066dc:	c1 10       	breq	800066fe <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800066de:	49 87       	lddpc	r7,8000673c <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800066e0:	f0 1f 00 18 	mcall	80006740 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800066e4:	6e 08       	ld.w	r8,r7[0x0]
800066e6:	20 18       	sub	r8,1
800066e8:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800066ea:	6e 08       	ld.w	r8,r7[0x0]
800066ec:	58 08       	cp.w	r8,0
800066ee:	cf 91       	brne	800066e0 <xTaskResumeAll+0x7c>
800066f0:	c0 78       	rjmp	800066fe <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800066f2:	58 14       	cp.w	r4,1
800066f4:	c0 50       	breq	800066fe <xTaskResumeAll+0x9a>
800066f6:	49 48       	lddpc	r8,80006744 <xTaskResumeAll+0xe0>
800066f8:	70 08       	ld.w	r8,r8[0x0]
800066fa:	58 18       	cp.w	r8,1
800066fc:	c0 71       	brne	8000670a <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800066fe:	30 09       	mov	r9,0
80006700:	49 18       	lddpc	r8,80006744 <xTaskResumeAll+0xe0>
80006702:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80006704:	d7 33       	scall
80006706:	30 17       	mov	r7,1
80006708:	c0 28       	rjmp	8000670c <xTaskResumeAll+0xa8>
8000670a:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
8000670c:	f0 1f 00 0f 	mcall	80006748 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80006710:	0e 9c       	mov	r12,r7
80006712:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80006716:	00 00       	add	r0,r0
80006718:	80 00       	ld.sh	r0,r0[0x0]
8000671a:	5b 74       	cp.w	r4,-9
8000671c:	00 00       	add	r0,r0
8000671e:	0d 04       	ld.w	r4,r6++
80006720:	00 00       	add	r0,r0
80006722:	0d 20       	ld.uh	r0,r6++
80006724:	00 00       	add	r0,r0
80006726:	0c d8       	st.w	--r6,r8
80006728:	00 00       	add	r0,r0
8000672a:	0d 3c       	ld.ub	r12,r6++
8000672c:	00 00       	add	r0,r0
8000672e:	0c 20       	rsub	r0,r6
80006730:	00 00       	add	r0,r0
80006732:	0c d4       	st.w	--r6,r4
80006734:	80 00       	ld.sh	r0,r0[0x0]
80006736:	5a ba       	cp.w	r10,-21
80006738:	80 00       	ld.sh	r0,r0[0x0]
8000673a:	5a 6a       	cp.w	r10,-26
8000673c:	00 00       	add	r0,r0
8000673e:	0c 04       	add	r4,r6
80006740:	80 00       	ld.sh	r0,r0[0x0]
80006742:	64 bc       	ld.w	r12,r2[0x2c]
80006744:	00 00       	add	r0,r0
80006746:	0d 24       	ld.uh	r4,r6++
80006748:	80 00       	ld.sh	r0,r0[0x0]
8000674a:	5c 80       	casts.h	r0

8000674c <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
8000674c:	eb cd 40 80 	pushm	r7,lr
80006750:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80006752:	49 08       	lddpc	r8,80006790 <prvAddCurrentTaskToDelayedList+0x44>
80006754:	70 08       	ld.w	r8,r8[0x0]
80006756:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006758:	48 f8       	lddpc	r8,80006794 <prvAddCurrentTaskToDelayedList+0x48>
8000675a:	70 08       	ld.w	r8,r8[0x0]
8000675c:	10 3c       	cp.w	r12,r8
8000675e:	c0 a2       	brcc	80006772 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006760:	48 c8       	lddpc	r8,80006790 <prvAddCurrentTaskToDelayedList+0x44>
80006762:	70 0b       	ld.w	r11,r8[0x0]
80006764:	48 d8       	lddpc	r8,80006798 <prvAddCurrentTaskToDelayedList+0x4c>
80006766:	70 0c       	ld.w	r12,r8[0x0]
80006768:	2f cb       	sub	r11,-4
8000676a:	f0 1f 00 0d 	mcall	8000679c <prvAddCurrentTaskToDelayedList+0x50>
8000676e:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006772:	48 88       	lddpc	r8,80006790 <prvAddCurrentTaskToDelayedList+0x44>
80006774:	70 0b       	ld.w	r11,r8[0x0]
80006776:	48 b8       	lddpc	r8,800067a0 <prvAddCurrentTaskToDelayedList+0x54>
80006778:	70 0c       	ld.w	r12,r8[0x0]
8000677a:	2f cb       	sub	r11,-4
8000677c:	f0 1f 00 08 	mcall	8000679c <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006780:	48 98       	lddpc	r8,800067a4 <prvAddCurrentTaskToDelayedList+0x58>
80006782:	70 08       	ld.w	r8,r8[0x0]
80006784:	10 37       	cp.w	r7,r8
80006786:	c0 32       	brcc	8000678c <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006788:	48 78       	lddpc	r8,800067a4 <prvAddCurrentTaskToDelayedList+0x58>
8000678a:	91 07       	st.w	r8[0x0],r7
8000678c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006790:	00 00       	add	r0,r0
80006792:	0c d4       	st.w	--r6,r4
80006794:	00 00       	add	r0,r0
80006796:	0d 00       	ld.w	r0,r6++
80006798:	00 00       	add	r0,r0
8000679a:	0c 1c       	sub	r12,r6
8000679c:	80 00       	ld.sh	r0,r0[0x0]
8000679e:	5a 86       	cp.w	r6,-24
800067a0:	00 00       	add	r0,r0
800067a2:	0c 0c       	add	r12,r6
800067a4:	00 00       	add	r0,r0
800067a6:	05 38       	ld.ub	r8,r2++

800067a8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
800067a8:	eb cd 40 c0 	pushm	r6-r7,lr
800067ac:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
800067ae:	58 0c       	cp.w	r12,0
800067b0:	c1 10       	breq	800067d2 <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
800067b2:	f0 1f 00 0a 	mcall	800067d8 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
800067b6:	48 a8       	lddpc	r8,800067dc <vTaskDelay+0x34>
800067b8:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800067ba:	48 a8       	lddpc	r8,800067e0 <vTaskDelay+0x38>
800067bc:	70 0c       	ld.w	r12,r8[0x0]
800067be:	2f cc       	sub	r12,-4
800067c0:	f0 1f 00 09 	mcall	800067e4 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800067c4:	ee 06 00 0c 	add	r12,r7,r6
800067c8:	f0 1f 00 08 	mcall	800067e8 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
800067cc:	f0 1f 00 08 	mcall	800067ec <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800067d0:	c0 21       	brne	800067d4 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
800067d2:	d7 33       	scall
800067d4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800067d8:	80 00       	ld.sh	r0,r0[0x0]
800067da:	62 a8       	ld.w	r8,r1[0x28]
800067dc:	00 00       	add	r0,r0
800067de:	0d 00       	ld.w	r0,r6++
800067e0:	00 00       	add	r0,r0
800067e2:	0c d4       	st.w	--r6,r4
800067e4:	80 00       	ld.sh	r0,r0[0x0]
800067e6:	5a ba       	cp.w	r10,-21
800067e8:	80 00       	ld.sh	r0,r0[0x0]
800067ea:	67 4c       	ld.w	r12,r3[0x50]
800067ec:	80 00       	ld.sh	r0,r0[0x0]
800067ee:	66 64       	ld.w	r4,r3[0x18]

800067f0 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
800067f0:	eb cd 40 c0 	pushm	r6-r7,lr
800067f4:	18 96       	mov	r6,r12
800067f6:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
800067f8:	f0 1f 00 18 	mcall	80006858 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
800067fc:	6c 08       	ld.w	r8,r6[0x0]
800067fe:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006800:	49 79       	lddpc	r9,8000685c <vTaskDelayUntil+0x6c>
80006802:	72 09       	ld.w	r9,r9[0x0]
80006804:	12 38       	cp.w	r8,r9
80006806:	e0 88 00 0c 	brls	8000681e <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
8000680a:	0e 38       	cp.w	r8,r7
8000680c:	e0 88 00 22 	brls	80006850 <vTaskDelayUntil+0x60>
80006810:	49 38       	lddpc	r8,8000685c <vTaskDelayUntil+0x6c>
80006812:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006814:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80006816:	10 37       	cp.w	r7,r8
80006818:	e0 88 00 14 	brls	80006840 <vTaskDelayUntil+0x50>
8000681c:	c0 a8       	rjmp	80006830 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
8000681e:	0e 38       	cp.w	r8,r7
80006820:	e0 8b 00 16 	brhi	8000684c <vTaskDelayUntil+0x5c>
80006824:	48 e8       	lddpc	r8,8000685c <vTaskDelayUntil+0x6c>
80006826:	70 08       	ld.w	r8,r8[0x0]
80006828:	10 37       	cp.w	r7,r8
8000682a:	e0 8b 00 11 	brhi	8000684c <vTaskDelayUntil+0x5c>
8000682e:	c1 18       	rjmp	80006850 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006830:	48 c8       	lddpc	r8,80006860 <vTaskDelayUntil+0x70>
80006832:	70 0c       	ld.w	r12,r8[0x0]
80006834:	2f cc       	sub	r12,-4
80006836:	f0 1f 00 0c 	mcall	80006864 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
8000683a:	0e 9c       	mov	r12,r7
8000683c:	f0 1f 00 0b 	mcall	80006868 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006840:	f0 1f 00 0b 	mcall	8000686c <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006844:	c0 81       	brne	80006854 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80006846:	d7 33       	scall
80006848:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
8000684c:	8d 07       	st.w	r6[0x0],r7
8000684e:	cf 1b       	rjmp	80006830 <vTaskDelayUntil+0x40>
80006850:	8d 07       	st.w	r6[0x0],r7
80006852:	cf 7b       	rjmp	80006840 <vTaskDelayUntil+0x50>
80006854:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006858:	80 00       	ld.sh	r0,r0[0x0]
8000685a:	62 a8       	ld.w	r8,r1[0x28]
8000685c:	00 00       	add	r0,r0
8000685e:	0d 00       	ld.w	r0,r6++
80006860:	00 00       	add	r0,r0
80006862:	0c d4       	st.w	--r6,r4
80006864:	80 00       	ld.sh	r0,r0[0x0]
80006866:	5a ba       	cp.w	r10,-21
80006868:	80 00       	ld.sh	r0,r0[0x0]
8000686a:	67 4c       	ld.w	r12,r3[0x50]
8000686c:	80 00       	ld.sh	r0,r0[0x0]
8000686e:	66 64       	ld.w	r4,r3[0x18]

80006870 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006870:	eb cd 40 c0 	pushm	r6-r7,lr
80006874:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006876:	48 e7       	lddpc	r7,800068ac <vTaskPlaceOnEventList+0x3c>
80006878:	6e 0b       	ld.w	r11,r7[0x0]
8000687a:	2e 8b       	sub	r11,-24
8000687c:	f0 1f 00 0d 	mcall	800068b0 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006880:	6e 0c       	ld.w	r12,r7[0x0]
80006882:	2f cc       	sub	r12,-4
80006884:	f0 1f 00 0c 	mcall	800068b4 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006888:	5b f6       	cp.w	r6,-1
8000688a:	c0 81       	brne	8000689a <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000688c:	6e 0b       	ld.w	r11,r7[0x0]
8000688e:	2f cb       	sub	r11,-4
80006890:	48 ac       	lddpc	r12,800068b8 <vTaskPlaceOnEventList+0x48>
80006892:	f0 1f 00 0b 	mcall	800068bc <vTaskPlaceOnEventList+0x4c>
80006896:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
8000689a:	48 a8       	lddpc	r8,800068c0 <vTaskPlaceOnEventList+0x50>
8000689c:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
8000689e:	ec 0c 00 0c 	add	r12,r6,r12
800068a2:	f0 1f 00 09 	mcall	800068c4 <vTaskPlaceOnEventList+0x54>
800068a6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800068aa:	00 00       	add	r0,r0
800068ac:	00 00       	add	r0,r0
800068ae:	0c d4       	st.w	--r6,r4
800068b0:	80 00       	ld.sh	r0,r0[0x0]
800068b2:	5a 86       	cp.w	r6,-24
800068b4:	80 00       	ld.sh	r0,r0[0x0]
800068b6:	5a ba       	cp.w	r10,-21
800068b8:	00 00       	add	r0,r0
800068ba:	0d 28       	ld.uh	r8,r6++
800068bc:	80 00       	ld.sh	r0,r0[0x0]
800068be:	5a 6a       	cp.w	r10,-26
800068c0:	00 00       	add	r0,r0
800068c2:	0d 00       	ld.w	r0,r6++
800068c4:	80 00       	ld.sh	r0,r0[0x0]
800068c6:	67 4c       	ld.w	r12,r3[0x50]

800068c8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
800068c8:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800068cc:	49 67       	lddpc	r7,80006924 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800068ce:	49 74       	lddpc	r4,80006928 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
800068d0:	49 73       	lddpc	r3,8000692c <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800068d2:	49 85       	lddpc	r5,80006930 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800068d4:	6e 08       	ld.w	r8,r7[0x0]
800068d6:	58 08       	cp.w	r8,0
800068d8:	c1 e0       	breq	80006914 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
800068da:	f0 1f 00 17 	mcall	80006934 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800068de:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
800068e0:	f0 1f 00 16 	mcall	80006938 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
800068e4:	58 06       	cp.w	r6,0
800068e6:	c1 70       	breq	80006914 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
800068e8:	f0 1f 00 15 	mcall	8000693c <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
800068ec:	68 38       	ld.w	r8,r4[0xc]
800068ee:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
800068f0:	ec cc ff fc 	sub	r12,r6,-4
800068f4:	f0 1f 00 13 	mcall	80006940 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
800068f8:	66 08       	ld.w	r8,r3[0x0]
800068fa:	20 18       	sub	r8,1
800068fc:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
800068fe:	6e 08       	ld.w	r8,r7[0x0]
80006900:	20 18       	sub	r8,1
80006902:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006904:	f0 1f 00 10 	mcall	80006944 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006908:	6c cc       	ld.w	r12,r6[0x30]
8000690a:	f0 1f 00 10 	mcall	80006948 <prvIdleTask+0x80>
		vPortFree( pxTCB );
8000690e:	0c 9c       	mov	r12,r6
80006910:	f0 1f 00 0e 	mcall	80006948 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006914:	6a 08       	ld.w	r8,r5[0x0]
80006916:	58 18       	cp.w	r8,1
80006918:	e0 88 00 03 	brls	8000691e <prvIdleTask+0x56>
			{
				taskYIELD();
8000691c:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
8000691e:	f0 1f 00 0c 	mcall	8000694c <prvIdleTask+0x84>
		}
		#endif
	}
80006922:	cd 9b       	rjmp	800068d4 <prvIdleTask+0xc>
80006924:	00 00       	add	r0,r0
80006926:	0c 14       	sub	r4,r6
80006928:	00 00       	add	r0,r0
8000692a:	0c c0       	st.b	r6++,r0
8000692c:	00 00       	add	r0,r0
8000692e:	0d 20       	ld.uh	r0,r6++
80006930:	00 00       	add	r0,r0
80006932:	0c 20       	rsub	r0,r6
80006934:	80 00       	ld.sh	r0,r0[0x0]
80006936:	62 a8       	ld.w	r8,r1[0x28]
80006938:	80 00       	ld.sh	r0,r0[0x0]
8000693a:	66 64       	ld.w	r4,r3[0x18]
8000693c:	80 00       	ld.sh	r0,r0[0x0]
8000693e:	5b 74       	cp.w	r4,-9
80006940:	80 00       	ld.sh	r0,r0[0x0]
80006942:	5a ba       	cp.w	r10,-21
80006944:	80 00       	ld.sh	r0,r0[0x0]
80006946:	5c 80       	casts.h	r0
80006948:	80 00       	ld.sh	r0,r0[0x0]
8000694a:	5d b8       	*unknown*
8000694c:	80 00       	ld.sh	r0,r0[0x0]
8000694e:	20 2c       	sub	r12,2

80006950 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006950:	d4 31       	pushm	r0-r7,lr
80006952:	20 1d       	sub	sp,4
80006954:	fa c4 ff d8 	sub	r4,sp,-40
80006958:	50 0c       	stdsp	sp[0x0],r12
8000695a:	16 91       	mov	r1,r11
8000695c:	14 97       	mov	r7,r10
8000695e:	12 90       	mov	r0,r9
80006960:	10 93       	mov	r3,r8
80006962:	68 02       	ld.w	r2,r4[0x0]
80006964:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006966:	34 8c       	mov	r12,72
80006968:	f0 1f 00 5c 	mcall	80006ad8 <xTaskGenericCreate+0x188>
8000696c:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
8000696e:	c0 31       	brne	80006974 <xTaskGenericCreate+0x24>
80006970:	3f fc       	mov	r12,-1
80006972:	ca f8       	rjmp	80006ad0 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006974:	58 06       	cp.w	r6,0
80006976:	e0 81 00 af 	brne	80006ad4 <xTaskGenericCreate+0x184>
8000697a:	0e 9c       	mov	r12,r7
8000697c:	5c 7c       	castu.h	r12
8000697e:	a3 6c       	lsl	r12,0x2
80006980:	f0 1f 00 56 	mcall	80006ad8 <xTaskGenericCreate+0x188>
80006984:	18 96       	mov	r6,r12
80006986:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006988:	c0 61       	brne	80006994 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
8000698a:	0a 9c       	mov	r12,r5
8000698c:	f0 1f 00 54 	mcall	80006adc <xTaskGenericCreate+0x18c>
80006990:	3f fc       	mov	r12,-1
80006992:	c9 f8       	rjmp	80006ad0 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006994:	5c 77       	castu.h	r7
80006996:	ee 0a 15 02 	lsl	r10,r7,0x2
8000699a:	e0 6b 00 a5 	mov	r11,165
8000699e:	0c 9c       	mov	r12,r6
800069a0:	f0 1f 00 50 	mcall	80006ae0 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
800069a4:	ee c6 00 01 	sub	r6,r7,1
800069a8:	6a c8       	ld.w	r8,r5[0x30]
800069aa:	f0 06 00 26 	add	r6,r8,r6<<0x2
800069ae:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
800069b2:	31 0a       	mov	r10,16
800069b4:	02 9b       	mov	r11,r1
800069b6:	ea cc ff cc 	sub	r12,r5,-52
800069ba:	f0 1f 00 4b 	mcall	80006ae4 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
800069be:	30 08       	mov	r8,0
800069c0:	eb 68 00 43 	st.b	r5[67],r8
800069c4:	58 73       	cp.w	r3,7
800069c6:	e6 07 17 80 	movls	r7,r3
800069ca:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
800069ce:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
800069d0:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
800069d4:	ea c4 ff fc 	sub	r4,r5,-4
800069d8:	08 9c       	mov	r12,r4
800069da:	f0 1f 00 44 	mcall	80006ae8 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
800069de:	ea cc ff e8 	sub	r12,r5,-24
800069e2:	f0 1f 00 42 	mcall	80006ae8 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
800069e6:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
800069e8:	ee 07 11 08 	rsub	r7,r7,8
800069ec:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
800069ee:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
800069f0:	00 9a       	mov	r10,r0
800069f2:	40 0b       	lddsp	r11,sp[0x0]
800069f4:	0c 9c       	mov	r12,r6
800069f6:	f0 1f 00 3e 	mcall	80006aec <xTaskGenericCreate+0x19c>
800069fa:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
800069fc:	58 02       	cp.w	r2,0
800069fe:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006a02:	f0 1f 00 3c 	mcall	80006af0 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006a06:	4b c8       	lddpc	r8,80006af4 <xTaskGenericCreate+0x1a4>
80006a08:	70 09       	ld.w	r9,r8[0x0]
80006a0a:	2f f9       	sub	r9,-1
80006a0c:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006a0e:	4b b8       	lddpc	r8,80006af8 <xTaskGenericCreate+0x1a8>
80006a10:	70 08       	ld.w	r8,r8[0x0]
80006a12:	58 08       	cp.w	r8,0
80006a14:	c2 61       	brne	80006a60 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006a16:	4b 98       	lddpc	r8,80006af8 <xTaskGenericCreate+0x1a8>
80006a18:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006a1a:	4b 78       	lddpc	r8,80006af4 <xTaskGenericCreate+0x1a4>
80006a1c:	70 08       	ld.w	r8,r8[0x0]
80006a1e:	58 18       	cp.w	r8,1
80006a20:	c2 b1       	brne	80006a76 <xTaskGenericCreate+0x126>
80006a22:	4b 77       	lddpc	r7,80006afc <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006a24:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006a28:	0e 9c       	mov	r12,r7
80006a2a:	f0 1f 00 36 	mcall	80006b00 <xTaskGenericCreate+0x1b0>
80006a2e:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006a30:	0c 37       	cp.w	r7,r6
80006a32:	cf b1       	brne	80006a28 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006a34:	4b 47       	lddpc	r7,80006b04 <xTaskGenericCreate+0x1b4>
80006a36:	0e 9c       	mov	r12,r7
80006a38:	f0 1f 00 32 	mcall	80006b00 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006a3c:	4b 36       	lddpc	r6,80006b08 <xTaskGenericCreate+0x1b8>
80006a3e:	0c 9c       	mov	r12,r6
80006a40:	f0 1f 00 30 	mcall	80006b00 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006a44:	4b 2c       	lddpc	r12,80006b0c <xTaskGenericCreate+0x1bc>
80006a46:	f0 1f 00 2f 	mcall	80006b00 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006a4a:	4b 2c       	lddpc	r12,80006b10 <xTaskGenericCreate+0x1c0>
80006a4c:	f0 1f 00 2d 	mcall	80006b00 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006a50:	4b 1c       	lddpc	r12,80006b14 <xTaskGenericCreate+0x1c4>
80006a52:	f0 1f 00 2c 	mcall	80006b00 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006a56:	4b 18       	lddpc	r8,80006b18 <xTaskGenericCreate+0x1c8>
80006a58:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006a5a:	4b 18       	lddpc	r8,80006b1c <xTaskGenericCreate+0x1cc>
80006a5c:	91 06       	st.w	r8[0x0],r6
80006a5e:	c0 c8       	rjmp	80006a76 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006a60:	4b 08       	lddpc	r8,80006b20 <xTaskGenericCreate+0x1d0>
80006a62:	70 08       	ld.w	r8,r8[0x0]
80006a64:	58 08       	cp.w	r8,0
80006a66:	c0 81       	brne	80006a76 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006a68:	4a 48       	lddpc	r8,80006af8 <xTaskGenericCreate+0x1a8>
80006a6a:	70 08       	ld.w	r8,r8[0x0]
80006a6c:	70 b8       	ld.w	r8,r8[0x2c]
80006a6e:	10 33       	cp.w	r3,r8
80006a70:	c0 33       	brcs	80006a76 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006a72:	4a 28       	lddpc	r8,80006af8 <xTaskGenericCreate+0x1a8>
80006a74:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006a76:	6a b8       	ld.w	r8,r5[0x2c]
80006a78:	4a b9       	lddpc	r9,80006b24 <xTaskGenericCreate+0x1d4>
80006a7a:	72 09       	ld.w	r9,r9[0x0]
80006a7c:	12 38       	cp.w	r8,r9
80006a7e:	e0 88 00 04 	brls	80006a86 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006a82:	4a 99       	lddpc	r9,80006b24 <xTaskGenericCreate+0x1d4>
80006a84:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006a86:	4a 98       	lddpc	r8,80006b28 <xTaskGenericCreate+0x1d8>
80006a88:	70 09       	ld.w	r9,r8[0x0]
80006a8a:	2f f9       	sub	r9,-1
80006a8c:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006a8e:	6a b8       	ld.w	r8,r5[0x2c]
80006a90:	4a 79       	lddpc	r9,80006b2c <xTaskGenericCreate+0x1dc>
80006a92:	72 09       	ld.w	r9,r9[0x0]
80006a94:	12 38       	cp.w	r8,r9
80006a96:	e0 88 00 04 	brls	80006a9e <xTaskGenericCreate+0x14e>
80006a9a:	4a 59       	lddpc	r9,80006b2c <xTaskGenericCreate+0x1dc>
80006a9c:	93 08       	st.w	r9[0x0],r8
80006a9e:	6a bc       	ld.w	r12,r5[0x2c]
80006aa0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006aa4:	08 9b       	mov	r11,r4
80006aa6:	49 68       	lddpc	r8,80006afc <xTaskGenericCreate+0x1ac>
80006aa8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006aac:	f0 1f 00 21 	mcall	80006b30 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006ab0:	f0 1f 00 21 	mcall	80006b34 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006ab4:	49 b8       	lddpc	r8,80006b20 <xTaskGenericCreate+0x1d0>
80006ab6:	70 08       	ld.w	r8,r8[0x0]
80006ab8:	58 08       	cp.w	r8,0
80006aba:	c0 a0       	breq	80006ace <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006abc:	48 f8       	lddpc	r8,80006af8 <xTaskGenericCreate+0x1a8>
80006abe:	70 08       	ld.w	r8,r8[0x0]
80006ac0:	70 b8       	ld.w	r8,r8[0x2c]
80006ac2:	10 33       	cp.w	r3,r8
80006ac4:	e0 88 00 05 	brls	80006ace <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006ac8:	d7 33       	scall
80006aca:	30 1c       	mov	r12,1
80006acc:	c0 28       	rjmp	80006ad0 <xTaskGenericCreate+0x180>
80006ace:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006ad0:	2f fd       	sub	sp,-4
80006ad2:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006ad4:	99 c6       	st.w	r12[0x30],r6
80006ad6:	c5 fb       	rjmp	80006994 <xTaskGenericCreate+0x44>
80006ad8:	80 00       	ld.sh	r0,r0[0x0]
80006ada:	5d e0       	*unknown*
80006adc:	80 00       	ld.sh	r0,r0[0x0]
80006ade:	5d b8       	*unknown*
80006ae0:	80 00       	ld.sh	r0,r0[0x0]
80006ae2:	76 dc       	ld.w	r12,r11[0x34]
80006ae4:	80 00       	ld.sh	r0,r0[0x0]
80006ae6:	7a 08       	ld.w	r8,sp[0x0]
80006ae8:	80 00       	ld.sh	r0,r0[0x0]
80006aea:	5a 64       	cp.w	r4,-26
80006aec:	80 00       	ld.sh	r0,r0[0x0]
80006aee:	5a e0       	cp.w	r0,-18
80006af0:	80 00       	ld.sh	r0,r0[0x0]
80006af2:	5b 74       	cp.w	r4,-9
80006af4:	00 00       	add	r0,r0
80006af6:	0d 20       	ld.uh	r0,r6++
80006af8:	00 00       	add	r0,r0
80006afa:	0c d4       	st.w	--r6,r4
80006afc:	00 00       	add	r0,r0
80006afe:	0c 20       	rsub	r0,r6
80006b00:	80 00       	ld.sh	r0,r0[0x0]
80006b02:	5a 50       	cp.w	r0,-27
80006b04:	00 00       	add	r0,r0
80006b06:	0c ec       	st.h	--r6,r12
80006b08:	00 00       	add	r0,r0
80006b0a:	0d 08       	ld.w	r8,r6++
80006b0c:	00 00       	add	r0,r0
80006b0e:	0c d8       	st.w	--r6,r8
80006b10:	00 00       	add	r0,r0
80006b12:	0c c0       	st.b	r6++,r0
80006b14:	00 00       	add	r0,r0
80006b16:	0d 28       	ld.uh	r8,r6++
80006b18:	00 00       	add	r0,r0
80006b1a:	0c 0c       	add	r12,r6
80006b1c:	00 00       	add	r0,r0
80006b1e:	0c 1c       	sub	r12,r6
80006b20:	00 00       	add	r0,r0
80006b22:	0c 10       	sub	r0,r6
80006b24:	00 00       	add	r0,r0
80006b26:	0c 08       	add	r8,r6
80006b28:	00 00       	add	r0,r0
80006b2a:	0d 1c       	ld.sh	r12,r6++
80006b2c:	00 00       	add	r0,r0
80006b2e:	0d 3c       	ld.ub	r12,r6++
80006b30:	80 00       	ld.sh	r0,r0[0x0]
80006b32:	5a 6a       	cp.w	r10,-26
80006b34:	80 00       	ld.sh	r0,r0[0x0]
80006b36:	5c 80       	casts.h	r0

80006b38 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006b38:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006b3a:	30 09       	mov	r9,0
80006b3c:	1a d9       	st.w	--sp,r9
80006b3e:	1a d9       	st.w	--sp,r9
80006b40:	1a d9       	st.w	--sp,r9
80006b42:	12 98       	mov	r8,r9
80006b44:	e0 6a 01 00 	mov	r10,256
80006b48:	48 9b       	lddpc	r11,80006b6c <vTaskStartScheduler+0x34>
80006b4a:	48 ac       	lddpc	r12,80006b70 <vTaskStartScheduler+0x38>
80006b4c:	f0 1f 00 0a 	mcall	80006b74 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006b50:	2f dd       	sub	sp,-12
80006b52:	58 1c       	cp.w	r12,1
80006b54:	c0 a1       	brne	80006b68 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006b56:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006b58:	30 19       	mov	r9,1
80006b5a:	48 88       	lddpc	r8,80006b78 <vTaskStartScheduler+0x40>
80006b5c:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006b5e:	30 09       	mov	r9,0
80006b60:	48 78       	lddpc	r8,80006b7c <vTaskStartScheduler+0x44>
80006b62:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006b64:	f0 1f 00 07 	mcall	80006b80 <vTaskStartScheduler+0x48>
80006b68:	d8 02       	popm	pc
80006b6a:	00 00       	add	r0,r0
80006b6c:	80 00       	ld.sh	r0,r0[0x0]
80006b6e:	d7 08       	*unknown*
80006b70:	80 00       	ld.sh	r0,r0[0x0]
80006b72:	68 c8       	ld.w	r8,r4[0x30]
80006b74:	80 00       	ld.sh	r0,r0[0x0]
80006b76:	69 50       	ld.w	r0,r4[0x54]
80006b78:	00 00       	add	r0,r0
80006b7a:	0c 10       	sub	r0,r6
80006b7c:	00 00       	add	r0,r0
80006b7e:	0d 00       	ld.w	r0,r6++
80006b80:	80 00       	ld.sh	r0,r0[0x0]
80006b82:	5b 84       	cp.w	r4,-8

80006b84 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006b84:	16 cc       	st.b	r11++,r12
	return str;
}
80006b86:	5e fb       	retal	r11

80006b88 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006b88:	eb cd 40 c0 	pushm	r6-r7,lr
80006b8c:	20 3d       	sub	sp,12
80006b8e:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006b90:	30 06       	mov	r6,0
80006b92:	30 07       	mov	r7,0
80006b94:	fa e7 00 00 	st.d	sp[0],r6
80006b98:	30 0c       	mov	r12,0
80006b9a:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006b9c:	58 08       	cp.w	r8,0
80006b9e:	c1 30       	breq	80006bc4 <PrintHex+0x3c>
80006ba0:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006ba2:	1a 9c       	mov	r12,sp
80006ba4:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006ba8:	58 9e       	cp.w	lr,9
80006baa:	e0 8a 00 04 	brle	80006bb2 <PrintHex+0x2a>
80006bae:	2c 9e       	sub	lr,-55
80006bb0:	c0 48       	rjmp	80006bb8 <PrintHex+0x30>
80006bb2:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006bb6:	2d 0e       	sub	lr,-48
80006bb8:	f8 09 0b 0e 	st.b	r12[r9],lr
80006bbc:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006bbe:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006bc0:	cf 21       	brne	80006ba4 <PrintHex+0x1c>
80006bc2:	c0 48       	rjmp	80006bca <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006bc4:	33 08       	mov	r8,48
80006bc6:	ba 88       	st.b	sp[0x0],r8
80006bc8:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006bca:	f6 09 01 08 	sub	r8,r11,r9
80006bce:	58 08       	cp.w	r8,0
80006bd0:	e0 8a 00 13 	brle	80006bf6 <PrintHex+0x6e>
	{
		char num = len - cnt;
80006bd4:	12 1b       	sub	r11,r9
80006bd6:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006bda:	18 9e       	mov	lr,r12
80006bdc:	58 0c       	cp.w	r12,0
80006bde:	e0 8a 00 0c 	brle	80006bf6 <PrintHex+0x6e>
80006be2:	1a 9b       	mov	r11,sp
80006be4:	12 0b       	add	r11,r9
80006be6:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006be8:	33 07       	mov	r7,48
80006bea:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006bec:	2f f8       	sub	r8,-1
80006bee:	1c 38       	cp.w	r8,lr
80006bf0:	cf d5       	brlt	80006bea <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006bf2:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006bf6:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006bfa:	f0 cb ff ff 	sub	r11,r8,-1
80006bfe:	58 0b       	cp.w	r11,0
80006c00:	e0 8a 00 19 	brle	80006c32 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006c04:	fa cb ff f4 	sub	r11,sp,-12
80006c08:	f6 09 00 09 	add	r9,r11,r9
80006c0c:	37 8b       	mov	r11,120
80006c0e:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006c12:	fa c9 ff f4 	sub	r9,sp,-12
80006c16:	10 09       	add	r9,r8
80006c18:	33 0b       	mov	r11,48
80006c1a:	f3 6b ff f4 	st.b	r9[-12],r11
80006c1e:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006c22:	fa ce 00 01 	sub	lr,sp,1
80006c26:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006c28:	11 8b       	ld.ub	r11,r8[0x0]
80006c2a:	12 cb       	st.b	r9++,r11
80006c2c:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006c2e:	1c 38       	cp.w	r8,lr
80006c30:	cf c1       	brne	80006c28 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006c32:	14 9c       	mov	r12,r10
80006c34:	2f dd       	sub	sp,-12
80006c36:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006c3a <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006c3a:	d4 21       	pushm	r4-r7,lr
80006c3c:	20 3d       	sub	sp,12
80006c3e:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006c40:	30 06       	mov	r6,0
80006c42:	30 07       	mov	r7,0
80006c44:	fa e7 00 00 	st.d	sp[0],r6
80006c48:	30 0c       	mov	r12,0
80006c4a:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006c4c:	58 08       	cp.w	r8,0
80006c4e:	c0 35       	brlt	80006c54 <PrintDec+0x1a>
80006c50:	14 97       	mov	r7,r10
80006c52:	c0 58       	rjmp	80006c5c <PrintDec+0x22>
	{
		*p++ = '-';
80006c54:	14 97       	mov	r7,r10
80006c56:	32 d9       	mov	r9,45
80006c58:	0e c9       	st.b	r7++,r9
		i = -i;
80006c5a:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006c5c:	58 08       	cp.w	r8,0
80006c5e:	c0 51       	brne	80006c68 <PrintDec+0x2e>
80006c60:	33 08       	mov	r8,48
80006c62:	ba 88       	st.b	sp[0x0],r8
80006c64:	30 1e       	mov	lr,1
80006c66:	c2 f8       	rjmp	80006cc4 <PrintDec+0x8a>
	
	int ten = i%10;
80006c68:	e0 65 66 67 	mov	r5,26215
80006c6c:	ea 15 66 66 	orh	r5,0x6666
80006c70:	f0 05 04 44 	muls.d	r4,r8,r5
80006c74:	ea 0c 14 02 	asr	r12,r5,0x2
80006c78:	f0 09 14 1f 	asr	r9,r8,0x1f
80006c7c:	f8 09 01 09 	sub	r9,r12,r9
80006c80:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006c84:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006c88:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006c8a:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006c8c:	e0 66 66 67 	mov	r6,26215
80006c90:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006c94:	2d 09       	sub	r9,-48
80006c96:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006c9a:	2f fe       	sub	lr,-1
		i /= 10;
80006c9c:	f0 06 04 44 	muls.d	r4,r8,r6
80006ca0:	ea 09 14 02 	asr	r9,r5,0x2
80006ca4:	bf 58       	asr	r8,0x1f
80006ca6:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006caa:	f0 06 04 44 	muls.d	r4,r8,r6
80006cae:	ea 09 14 02 	asr	r9,r5,0x2
80006cb2:	f0 05 14 1f 	asr	r5,r8,0x1f
80006cb6:	0a 19       	sub	r9,r5
80006cb8:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006cbc:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006cc0:	58 08       	cp.w	r8,0
80006cc2:	ce 91       	brne	80006c94 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006cc4:	f6 0e 01 08 	sub	r8,r11,lr
80006cc8:	58 08       	cp.w	r8,0
80006cca:	e0 89 00 06 	brgt	80006cd6 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006cce:	58 0e       	cp.w	lr,0
80006cd0:	e0 89 00 14 	brgt	80006cf8 <PrintDec+0xbe>
80006cd4:	c1 d8       	rjmp	80006d0e <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006cd6:	1c 1b       	sub	r11,lr
80006cd8:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006cda:	16 9c       	mov	r12,r11
80006cdc:	58 0b       	cp.w	r11,0
80006cde:	fe 9a ff f8 	brle	80006cce <PrintDec+0x94>
80006ce2:	1a 99       	mov	r9,sp
80006ce4:	1c 09       	add	r9,lr
80006ce6:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006ce8:	33 06       	mov	r6,48
80006cea:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006cec:	2f f8       	sub	r8,-1
80006cee:	18 38       	cp.w	r8,r12
80006cf0:	cf d5       	brlt	80006cea <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006cf2:	f6 0e 00 0e 	add	lr,r11,lr
80006cf6:	ce cb       	rjmp	80006cce <PrintDec+0x94>
80006cf8:	fa c8 ff f4 	sub	r8,sp,-12
80006cfc:	1c 08       	add	r8,lr
80006cfe:	20 d8       	sub	r8,13
80006d00:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006d04:	11 89       	ld.ub	r9,r8[0x0]
80006d06:	0e c9       	st.b	r7++,r9
80006d08:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006d0a:	16 38       	cp.w	r8,r11
80006d0c:	cf c1       	brne	80006d04 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80006d0e:	14 9c       	mov	r12,r10
80006d10:	2f dd       	sub	sp,-12
80006d12:	d8 22       	popm	r4-r7,pc

80006d14 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006d14:	d4 31       	pushm	r0-r7,lr
80006d16:	fa cd 02 08 	sub	sp,sp,520
80006d1a:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006d1c:	e0 6a 01 00 	mov	r10,256
80006d20:	30 0b       	mov	r11,0
80006d22:	fa cc fe f8 	sub	r12,sp,-264
80006d26:	f0 1f 00 4e 	mcall	80006e5c <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006d2a:	fa c4 fd d4 	sub	r4,sp,-556
80006d2e:	30 0a       	mov	r10,0
80006d30:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006d32:	fa c3 ff fc 	sub	r3,sp,-4
80006d36:	e0 61 01 00 	mov	r1,256
80006d3a:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006d3c:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006d3e:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006d42:	02 9a       	mov	r10,r1
80006d44:	00 9b       	mov	r11,r0
80006d46:	06 9c       	mov	r12,r3
80006d48:	f0 1f 00 45 	mcall	80006e5c <log+0x148>
			
					if(*str == '%')
80006d4c:	0f 88       	ld.ub	r8,r7[0x0]
80006d4e:	e4 08 18 00 	cp.b	r8,r2
80006d52:	c5 71       	brne	80006e00 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80006d54:	ee c8 ff ff 	sub	r8,r7,-1
80006d58:	11 89       	ld.ub	r9,r8[0x0]
80006d5a:	4c 2a       	lddpc	r10,80006e60 <log+0x14c>
80006d5c:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80006d5e:	23 09       	sub	r9,48
80006d60:	30 9a       	mov	r10,9
80006d62:	f4 09 18 00 	cp.b	r9,r10
80006d66:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80006d6a:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006d6e:	f7 b9 08 30 	subls	r9,48
80006d72:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80006d76:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80006d7a:	0f 88       	ld.ub	r8,r7[0x0]
80006d7c:	22 58       	sub	r8,37
80006d7e:	e0 48 00 53 	cp.w	r8,83
80006d82:	e0 8b 00 31 	brhi	80006de4 <log+0xd0>
80006d86:	4b 89       	lddpc	r9,80006e64 <log+0x150>
80006d88:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006d8c:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006d90:	06 9a       	mov	r10,r3
80006d92:	40 0b       	lddsp	r11,sp[0x0]
80006d94:	5c 5b       	castu.b	r11
80006d96:	68 0c       	ld.w	r12,r4[0x0]
80006d98:	f0 1f 00 34 	mcall	80006e68 <log+0x154>
							break;
80006d9c:	c2 98       	rjmp	80006dee <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006d9e:	4b 4c       	lddpc	r12,80006e6c <log+0x158>
80006da0:	f0 1f 00 34 	mcall	80006e70 <log+0x15c>
80006da4:	08 95       	mov	r5,r4
80006da6:	06 9c       	mov	r12,r3
							break;
80006da8:	c2 38       	rjmp	80006dee <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80006daa:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006dae:	06 9a       	mov	r10,r3
80006db0:	40 0b       	lddsp	r11,sp[0x0]
80006db2:	5c 5b       	castu.b	r11
80006db4:	68 0c       	ld.w	r12,r4[0x0]
80006db6:	f0 1f 00 30 	mcall	80006e74 <log+0x160>
80006dba:	06 9c       	mov	r12,r3
							break;
80006dbc:	c1 98       	rjmp	80006dee <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006dbe:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006dc2:	06 9b       	mov	r11,r3
80006dc4:	09 bc       	ld.ub	r12,r4[0x3]
80006dc6:	f0 1f 00 2d 	mcall	80006e78 <log+0x164>
80006dca:	06 9c       	mov	r12,r3
							break;
80006dcc:	c1 18       	rjmp	80006dee <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006dce:	e8 c5 ff fc 	sub	r5,r4,-4
80006dd2:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006dd4:	c0 d8       	rjmp	80006dee <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006dd6:	06 9b       	mov	r11,r3
80006dd8:	32 5c       	mov	r12,37
80006dda:	f0 1f 00 28 	mcall	80006e78 <log+0x164>
80006dde:	08 95       	mov	r5,r4
80006de0:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80006de2:	c0 68       	rjmp	80006dee <log+0xda>
							
							default:
							log("I need relax.");
80006de4:	4a 6c       	lddpc	r12,80006e7c <log+0x168>
80006de6:	f0 1f 00 23 	mcall	80006e70 <log+0x15c>
80006dea:	08 95       	mov	r5,r4
80006dec:	06 9c       	mov	r12,r3
						}
						str++;
80006dee:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006df0:	1a dc       	st.w	--sp,r12
80006df2:	1a d6       	st.w	--sp,r6
80006df4:	4a 3b       	lddpc	r11,80006e80 <log+0x16c>
80006df6:	0c 9c       	mov	r12,r6
80006df8:	f0 1f 00 23 	mcall	80006e84 <log+0x170>
80006dfc:	2f ed       	sub	sp,-8
80006dfe:	c0 a8       	rjmp	80006e12 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006e00:	2f f7       	sub	r7,-1
80006e02:	1a d8       	st.w	--sp,r8
80006e04:	1a d6       	st.w	--sp,r6
80006e06:	4a 1b       	lddpc	r11,80006e88 <log+0x174>
80006e08:	0c 9c       	mov	r12,r6
80006e0a:	f0 1f 00 1f 	mcall	80006e84 <log+0x170>
80006e0e:	08 95       	mov	r5,r4
80006e10:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80006e12:	0f 89       	ld.ub	r9,r7[0x0]
80006e14:	30 08       	mov	r8,0
80006e16:	f0 09 18 00 	cp.b	r9,r8
80006e1a:	c0 30       	breq	80006e20 <log+0x10c>
80006e1c:	0a 94       	mov	r4,r5
80006e1e:	c9 2b       	rjmp	80006d42 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006e20:	fa c7 fe f8 	sub	r7,sp,-264
80006e24:	1a d7       	st.w	--sp,r7
80006e26:	49 ab       	lddpc	r11,80006e8c <log+0x178>
80006e28:	0e 9c       	mov	r12,r7
80006e2a:	f0 1f 00 17 	mcall	80006e84 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80006e2e:	5c 5c       	castu.b	r12
80006e30:	f8 c6 ff ff 	sub	r6,r12,-1
80006e34:	0c 9c       	mov	r12,r6
80006e36:	f0 1f 00 17 	mcall	80006e90 <log+0x17c>
80006e3a:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80006e3c:	0c 9a       	mov	r10,r6
80006e3e:	0e 9b       	mov	r11,r7
80006e40:	f0 1f 00 15 	mcall	80006e94 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80006e44:	30 09       	mov	r9,0
80006e46:	30 5a       	mov	r10,5
80006e48:	fa cb fe f8 	sub	r11,sp,-264
80006e4c:	49 38       	lddpc	r8,80006e98 <log+0x184>
80006e4e:	70 0c       	ld.w	r12,r8[0x0]
80006e50:	f0 1f 00 13 	mcall	80006e9c <log+0x188>
80006e54:	2f fd       	sub	sp,-4
	
	
}
80006e56:	fe 3d fd f8 	sub	sp,-520
80006e5a:	d8 32       	popm	r0-r7,pc
80006e5c:	80 00       	ld.sh	r0,r0[0x0]
80006e5e:	76 dc       	ld.w	r12,r11[0x34]
80006e60:	00 00       	add	r0,r0
80006e62:	0d 40       	ld.w	r0,--r6
80006e64:	80 00       	ld.sh	r0,r0[0x0]
80006e66:	d7 10       	acall	0x71
80006e68:	80 00       	ld.sh	r0,r0[0x0]
80006e6a:	6c 3a       	ld.w	r10,r6[0xc]
80006e6c:	80 00       	ld.sh	r0,r0[0x0]
80006e6e:	d9 bc       	*unknown*
80006e70:	80 00       	ld.sh	r0,r0[0x0]
80006e72:	6d 14       	ld.w	r4,r6[0x44]
80006e74:	80 00       	ld.sh	r0,r0[0x0]
80006e76:	6b 88       	ld.w	r8,r5[0x60]
80006e78:	80 00       	ld.sh	r0,r0[0x0]
80006e7a:	6b 84       	ld.w	r4,r5[0x60]
80006e7c:	80 00       	ld.sh	r0,r0[0x0]
80006e7e:	d9 cc       	*unknown*
80006e80:	80 00       	ld.sh	r0,r0[0x0]
80006e82:	d9 dc       	*unknown*
80006e84:	80 00       	ld.sh	r0,r0[0x0]
80006e86:	79 cc       	ld.w	r12,r12[0x70]
80006e88:	80 00       	ld.sh	r0,r0[0x0]
80006e8a:	d9 e4       	*unknown*
80006e8c:	80 00       	ld.sh	r0,r0[0x0]
80006e8e:	d9 ec       	*unknown*
80006e90:	80 00       	ld.sh	r0,r0[0x0]
80006e92:	5d e0       	*unknown*
80006e94:	80 00       	ld.sh	r0,r0[0x0]
80006e96:	75 94       	ld.w	r4,r10[0x64]
80006e98:	00 00       	add	r0,r0
80006e9a:	51 20       	stdsp	sp[0x48],r0
80006e9c:	80 00       	ld.sh	r0,r0[0x0]
80006e9e:	61 34       	ld.w	r4,r0[0x4c]

80006ea0 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006ea0:	d4 31       	pushm	r0-r7,lr
80006ea2:	fa cd 02 0c 	sub	sp,sp,524
80006ea6:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006ea8:	e0 6a 01 00 	mov	r10,256
80006eac:	30 0b       	mov	r11,0
80006eae:	fa cc fe f4 	sub	r12,sp,-268
80006eb2:	f0 1f 00 4c 	mcall	80006fe0 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80006eb6:	fa c4 fd d0 	sub	r4,sp,-560
80006eba:	30 0a       	mov	r10,0
80006ebc:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006ebe:	fa c3 ff fc 	sub	r3,sp,-4
80006ec2:	e0 61 01 00 	mov	r1,256
80006ec6:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006ec8:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006eca:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006ece:	02 9a       	mov	r10,r1
80006ed0:	00 9b       	mov	r11,r0
80006ed2:	06 9c       	mov	r12,r3
80006ed4:	f0 1f 00 43 	mcall	80006fe0 <logFromISR+0x140>
			
			if(*str == '%')
80006ed8:	0f 88       	ld.ub	r8,r7[0x0]
80006eda:	e4 08 18 00 	cp.b	r8,r2
80006ede:	c5 11       	brne	80006f80 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80006ee0:	ee c8 ff ff 	sub	r8,r7,-1
80006ee4:	11 89       	ld.ub	r9,r8[0x0]
80006ee6:	4c 0a       	lddpc	r10,80006fe4 <logFromISR+0x144>
80006ee8:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80006eea:	23 09       	sub	r9,48
80006eec:	30 9a       	mov	r10,9
80006eee:	f4 09 18 00 	cp.b	r9,r10
80006ef2:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80006ef6:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006efa:	f7 b9 08 30 	subls	r9,48
80006efe:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80006f02:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80006f06:	0f 88       	ld.ub	r8,r7[0x0]
80006f08:	22 58       	sub	r8,37
80006f0a:	e0 48 00 53 	cp.w	r8,83
80006f0e:	e0 8b 00 2b 	brhi	80006f64 <logFromISR+0xc4>
80006f12:	4b 69       	lddpc	r9,80006fe8 <logFromISR+0x148>
80006f14:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006f18:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006f1c:	06 9a       	mov	r10,r3
80006f1e:	40 0b       	lddsp	r11,sp[0x0]
80006f20:	5c 5b       	castu.b	r11
80006f22:	68 0c       	ld.w	r12,r4[0x0]
80006f24:	f0 1f 00 32 	mcall	80006fec <logFromISR+0x14c>
					break;
80006f28:	c2 38       	rjmp	80006f6e <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80006f2a:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80006f2e:	06 9a       	mov	r10,r3
80006f30:	40 0b       	lddsp	r11,sp[0x0]
80006f32:	5c 5b       	castu.b	r11
80006f34:	68 0c       	ld.w	r12,r4[0x0]
80006f36:	f0 1f 00 2f 	mcall	80006ff0 <logFromISR+0x150>
80006f3a:	06 9c       	mov	r12,r3
					break;
80006f3c:	c1 98       	rjmp	80006f6e <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80006f3e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80006f42:	06 9b       	mov	r11,r3
80006f44:	09 bc       	ld.ub	r12,r4[0x3]
80006f46:	f0 1f 00 2c 	mcall	80006ff4 <logFromISR+0x154>
80006f4a:	06 9c       	mov	r12,r3
					break;
80006f4c:	c1 18       	rjmp	80006f6e <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80006f4e:	e8 c5 ff fc 	sub	r5,r4,-4
80006f52:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80006f54:	c0 d8       	rjmp	80006f6e <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80006f56:	06 9b       	mov	r11,r3
80006f58:	32 5c       	mov	r12,37
80006f5a:	f0 1f 00 27 	mcall	80006ff4 <logFromISR+0x154>
80006f5e:	08 95       	mov	r5,r4
80006f60:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80006f62:	c0 68       	rjmp	80006f6e <logFromISR+0xce>
					default:
					log("I need relax.");
80006f64:	4a 5c       	lddpc	r12,80006ff8 <logFromISR+0x158>
80006f66:	f0 1f 00 26 	mcall	80006ffc <logFromISR+0x15c>
80006f6a:	08 95       	mov	r5,r4
80006f6c:	06 9c       	mov	r12,r3
				}
				str++;
80006f6e:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006f70:	1a dc       	st.w	--sp,r12
80006f72:	1a d6       	st.w	--sp,r6
80006f74:	4a 3b       	lddpc	r11,80007000 <logFromISR+0x160>
80006f76:	0c 9c       	mov	r12,r6
80006f78:	f0 1f 00 23 	mcall	80007004 <logFromISR+0x164>
80006f7c:	2f ed       	sub	sp,-8
80006f7e:	c0 a8       	rjmp	80006f92 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006f80:	2f f7       	sub	r7,-1
80006f82:	1a d8       	st.w	--sp,r8
80006f84:	1a d6       	st.w	--sp,r6
80006f86:	4a 1b       	lddpc	r11,80007008 <logFromISR+0x168>
80006f88:	0c 9c       	mov	r12,r6
80006f8a:	f0 1f 00 1f 	mcall	80007004 <logFromISR+0x164>
80006f8e:	08 95       	mov	r5,r4
80006f90:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80006f92:	0f 89       	ld.ub	r9,r7[0x0]
80006f94:	30 08       	mov	r8,0
80006f96:	f0 09 18 00 	cp.b	r9,r8
80006f9a:	c0 30       	breq	80006fa0 <logFromISR+0x100>
80006f9c:	0a 94       	mov	r4,r5
80006f9e:	c9 8b       	rjmp	80006ece <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80006fa0:	fa c7 fe f4 	sub	r7,sp,-268
80006fa4:	1a d7       	st.w	--sp,r7
80006fa6:	49 ab       	lddpc	r11,8000700c <logFromISR+0x16c>
80006fa8:	0e 9c       	mov	r12,r7
80006faa:	f0 1f 00 17 	mcall	80007004 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80006fae:	5c 5c       	castu.b	r12
80006fb0:	f8 c6 ff ff 	sub	r6,r12,-1
80006fb4:	0c 9c       	mov	r12,r6
80006fb6:	f0 1f 00 17 	mcall	80007010 <logFromISR+0x170>
80006fba:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80006fbc:	0c 9a       	mov	r10,r6
80006fbe:	0e 9b       	mov	r11,r7
80006fc0:	f0 1f 00 15 	mcall	80007014 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006fc4:	30 09       	mov	r9,0
80006fc6:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80006fc8:	fa ca fe f8 	sub	r10,sp,-264
80006fcc:	fa cb fe f4 	sub	r11,sp,-268
80006fd0:	49 28       	lddpc	r8,80007018 <logFromISR+0x178>
80006fd2:	70 0c       	ld.w	r12,r8[0x0]
80006fd4:	f0 1f 00 12 	mcall	8000701c <logFromISR+0x17c>
80006fd8:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80006fda:	fe 3d fd f4 	sub	sp,-524
80006fde:	d8 32       	popm	r0-r7,pc
80006fe0:	80 00       	ld.sh	r0,r0[0x0]
80006fe2:	76 dc       	ld.w	r12,r11[0x34]
80006fe4:	00 00       	add	r0,r0
80006fe6:	0d 41       	ld.w	r1,--r6
80006fe8:	80 00       	ld.sh	r0,r0[0x0]
80006fea:	d8 60       	acall	0x86
80006fec:	80 00       	ld.sh	r0,r0[0x0]
80006fee:	6c 3a       	ld.w	r10,r6[0xc]
80006ff0:	80 00       	ld.sh	r0,r0[0x0]
80006ff2:	6b 88       	ld.w	r8,r5[0x60]
80006ff4:	80 00       	ld.sh	r0,r0[0x0]
80006ff6:	6b 84       	ld.w	r4,r5[0x60]
80006ff8:	80 00       	ld.sh	r0,r0[0x0]
80006ffa:	d9 cc       	*unknown*
80006ffc:	80 00       	ld.sh	r0,r0[0x0]
80006ffe:	6d 14       	ld.w	r4,r6[0x44]
80007000:	80 00       	ld.sh	r0,r0[0x0]
80007002:	d9 dc       	*unknown*
80007004:	80 00       	ld.sh	r0,r0[0x0]
80007006:	79 cc       	ld.w	r12,r12[0x70]
80007008:	80 00       	ld.sh	r0,r0[0x0]
8000700a:	d9 e4       	*unknown*
8000700c:	80 00       	ld.sh	r0,r0[0x0]
8000700e:	d9 ec       	*unknown*
80007010:	80 00       	ld.sh	r0,r0[0x0]
80007012:	5d e0       	*unknown*
80007014:	80 00       	ld.sh	r0,r0[0x0]
80007016:	75 94       	ld.w	r4,r10[0x64]
80007018:	00 00       	add	r0,r0
8000701a:	51 20       	stdsp	sp[0x48],r0
8000701c:	80 00       	ld.sh	r0,r0[0x0]
8000701e:	60 e4       	ld.w	r4,r0[0x38]

80007020 <log_init>:
		
	return str;
}

void log_init(void)
{
80007020:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80007022:	30 2b       	mov	r11,2
80007024:	49 0c       	lddpc	r12,80007064 <log_init+0x44>
80007026:	f0 1f 00 11 	mcall	80007068 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
8000702a:	e0 6a 36 00 	mov	r10,13824
8000702e:	ea 1a 01 6e 	orh	r10,0x16e
80007032:	48 fb       	lddpc	r11,8000706c <log_init+0x4c>
80007034:	fe 7c 18 00 	mov	r12,-59392
80007038:	f0 1f 00 0e 	mcall	80007070 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
8000703c:	30 4b       	mov	r11,4
8000703e:	33 2c       	mov	r12,50
80007040:	f0 1f 00 0d 	mcall	80007074 <log_init+0x54>
80007044:	48 d8       	lddpc	r8,80007078 <log_init+0x58>
80007046:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80007048:	30 09       	mov	r9,0
8000704a:	1a d9       	st.w	--sp,r9
8000704c:	1a d9       	st.w	--sp,r9
8000704e:	1a d9       	st.w	--sp,r9
80007050:	30 28       	mov	r8,2
80007052:	e0 6a 01 80 	mov	r10,384
80007056:	48 ab       	lddpc	r11,8000707c <log_init+0x5c>
80007058:	48 ac       	lddpc	r12,80007080 <log_init+0x60>
8000705a:	f0 1f 00 0b 	mcall	80007084 <log_init+0x64>
8000705e:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80007060:	d8 02       	popm	pc
80007062:	00 00       	add	r0,r0
80007064:	80 00       	ld.sh	r0,r0[0x0]
80007066:	d9 f8       	*unknown*
80007068:	80 00       	ld.sh	r0,r0[0x0]
8000706a:	52 a0       	stdsp	sp[0xa8],r0
8000706c:	80 00       	ld.sh	r0,r0[0x0]
8000706e:	d9 b0       	acall	0x9b
80007070:	80 00       	ld.sh	r0,r0[0x0]
80007072:	59 44       	cp.w	r4,20
80007074:	80 00       	ld.sh	r0,r0[0x0]
80007076:	62 34       	ld.w	r4,r1[0xc]
80007078:	00 00       	add	r0,r0
8000707a:	51 20       	stdsp	sp[0x48],r0
8000707c:	80 00       	ld.sh	r0,r0[0x0]
8000707e:	d9 f4       	*unknown*
80007080:	80 00       	ld.sh	r0,r0[0x0]
80007082:	70 88       	ld.w	r8,r8[0x20]
80007084:	80 00       	ld.sh	r0,r0[0x0]
80007086:	69 50       	ld.w	r0,r4[0x54]

80007088 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80007088:	eb cd 40 f8 	pushm	r3-r7,lr
8000708c:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000708e:	48 c7       	lddpc	r7,800070bc <task_log+0x34>
80007090:	30 05       	mov	r5,0
80007092:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80007094:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80007098:	0a 99       	mov	r9,r5
8000709a:	08 9a       	mov	r10,r4
8000709c:	1a 9b       	mov	r11,sp
8000709e:	6e 0c       	ld.w	r12,r7[0x0]
800070a0:	f0 1f 00 08 	mcall	800070c0 <task_log+0x38>
800070a4:	58 1c       	cp.w	r12,1
800070a6:	cf 91       	brne	80007098 <task_log+0x10>
		{
			if( NULL != str)
800070a8:	40 0b       	lddsp	r11,sp[0x0]
800070aa:	58 0b       	cp.w	r11,0
800070ac:	cf 60       	breq	80007098 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
800070ae:	06 9c       	mov	r12,r3
800070b0:	f0 1f 00 05 	mcall	800070c4 <task_log+0x3c>
				vPortFree(str);
800070b4:	40 0c       	lddsp	r12,sp[0x0]
800070b6:	f0 1f 00 05 	mcall	800070c8 <task_log+0x40>
800070ba:	ce fb       	rjmp	80007098 <task_log+0x10>
800070bc:	00 00       	add	r0,r0
800070be:	51 20       	stdsp	sp[0x48],r0
800070c0:	80 00       	ld.sh	r0,r0[0x0]
800070c2:	5f 28       	srhs	r8
800070c4:	80 00       	ld.sh	r0,r0[0x0]
800070c6:	58 f4       	cp.w	r4,15
800070c8:	80 00       	ld.sh	r0,r0[0x0]
800070ca:	5d b8       	*unknown*

800070cc <main>:
#include "xgrtc.h"
#include "app.h"


int main (void)
{
800070cc:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
800070ce:	fe 78 10 00 	mov	r8,-61440
800070d2:	30 19       	mov	r9,1
800070d4:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
800070d8:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
800070dc:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
800070e0:	d3 03       	ssrf	0x10
	local_start_pll0();
800070e2:	f0 1f 00 0c 	mcall	80007110 <main+0x44>
		
	INTC_init_interrupts();
800070e6:	f0 1f 00 0c 	mcall	80007114 <main+0x48>
		
	log_init();
800070ea:	f0 1f 00 0c 	mcall	80007118 <main+0x4c>
	log("----start debug----");
800070ee:	48 cc       	lddpc	r12,8000711c <main+0x50>
800070f0:	f0 1f 00 0c 	mcall	80007120 <main+0x54>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
800070f4:	f0 1f 00 0c 	mcall	80007124 <main+0x58>
		
	app_init();
800070f8:	f0 1f 00 0c 	mcall	80007128 <main+0x5c>
		
	xcmp_init();
800070fc:	f0 1f 00 0c 	mcall	8000712c <main+0x60>

	local_start_timer();
80007100:	f0 1f 00 0c 	mcall	80007130 <main+0x64>
	
	xg_rtc_init();
80007104:	f0 1f 00 0c 	mcall	80007134 <main+0x68>
		
	vTaskStartScheduler();
80007108:	f0 1f 00 0c 	mcall	80007138 <main+0x6c>
	return 0;
	
}
8000710c:	d8 0a       	popm	pc,r12=0
8000710e:	00 00       	add	r0,r0
80007110:	80 00       	ld.sh	r0,r0[0x0]
80007112:	51 68       	stdsp	sp[0x58],r8
80007114:	80 00       	ld.sh	r0,r0[0x0]
80007116:	53 a4       	stdsp	sp[0xe8],r4
80007118:	80 00       	ld.sh	r0,r0[0x0]
8000711a:	70 20       	ld.w	r0,r8[0x8]
8000711c:	80 00       	ld.sh	r0,r0[0x0]
8000711e:	da 08       	*unknown*
80007120:	80 00       	ld.sh	r0,r0[0x0]
80007122:	6d 14       	ld.w	r4,r6[0x44]
80007124:	80 00       	ld.sh	r0,r0[0x0]
80007126:	51 5c       	stdsp	sp[0x54],r12
80007128:	80 00       	ld.sh	r0,r0[0x0]
8000712a:	20 3c       	sub	r12,3
8000712c:	80 00       	ld.sh	r0,r0[0x0]
8000712e:	40 80       	lddsp	r0,sp[0x20]
80007130:	80 00       	ld.sh	r0,r0[0x0]
80007132:	52 20       	stdsp	sp[0x88],r0
80007134:	80 00       	ld.sh	r0,r0[0x0]
80007136:	29 08       	sub	r8,-112
80007138:	80 00       	ld.sh	r0,r0[0x0]
8000713a:	6b 38       	ld.w	r8,r5[0x4c]

8000713c <free>:
8000713c:	d4 01       	pushm	lr
8000713e:	e0 68 0a 3c 	mov	r8,2620
80007142:	18 9b       	mov	r11,r12
80007144:	70 0c       	ld.w	r12,r8[0x0]
80007146:	e0 a0 1e 61 	rcall	8000ae08 <_free_r>
8000714a:	d8 02       	popm	pc

8000714c <malloc>:
8000714c:	d4 01       	pushm	lr
8000714e:	e0 68 0a 3c 	mov	r8,2620
80007152:	18 9b       	mov	r11,r12
80007154:	70 0c       	ld.w	r12,r8[0x0]
80007156:	c0 3c       	rcall	8000715c <_malloc_r>
80007158:	d8 02       	popm	pc
8000715a:	d7 03       	nop

8000715c <_malloc_r>:
8000715c:	d4 31       	pushm	r0-r7,lr
8000715e:	f6 c8 ff f5 	sub	r8,r11,-11
80007162:	18 95       	mov	r5,r12
80007164:	10 97       	mov	r7,r8
80007166:	e0 17 ff f8 	andl	r7,0xfff8
8000716a:	59 68       	cp.w	r8,22
8000716c:	f9 b7 08 10 	movls	r7,16
80007170:	16 37       	cp.w	r7,r11
80007172:	5f 38       	srlo	r8
80007174:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80007178:	c0 50       	breq	80007182 <_malloc_r+0x26>
8000717a:	30 c8       	mov	r8,12
8000717c:	99 38       	st.w	r12[0xc],r8
8000717e:	e0 8f 01 fa 	bral	80007572 <_malloc_r+0x416>
80007182:	fe b0 f5 d1 	rcall	80005d24 <__malloc_lock>
80007186:	e0 47 01 f7 	cp.w	r7,503
8000718a:	e0 8b 00 1d 	brhi	800071c4 <_malloc_r+0x68>
8000718e:	ee 03 16 03 	lsr	r3,r7,0x3
80007192:	e0 68 05 3c 	mov	r8,1340
80007196:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000719a:	70 36       	ld.w	r6,r8[0xc]
8000719c:	10 36       	cp.w	r6,r8
8000719e:	c0 61       	brne	800071aa <_malloc_r+0x4e>
800071a0:	ec c8 ff f8 	sub	r8,r6,-8
800071a4:	70 36       	ld.w	r6,r8[0xc]
800071a6:	10 36       	cp.w	r6,r8
800071a8:	c0 c0       	breq	800071c0 <_malloc_r+0x64>
800071aa:	6c 18       	ld.w	r8,r6[0x4]
800071ac:	e0 18 ff fc 	andl	r8,0xfffc
800071b0:	6c 3a       	ld.w	r10,r6[0xc]
800071b2:	ec 08 00 09 	add	r9,r6,r8
800071b6:	0a 9c       	mov	r12,r5
800071b8:	6c 28       	ld.w	r8,r6[0x8]
800071ba:	95 28       	st.w	r10[0x8],r8
800071bc:	91 3a       	st.w	r8[0xc],r10
800071be:	c4 78       	rjmp	8000724c <_malloc_r+0xf0>
800071c0:	2f e3       	sub	r3,-2
800071c2:	c4 d8       	rjmp	8000725c <_malloc_r+0x100>
800071c4:	ee 03 16 09 	lsr	r3,r7,0x9
800071c8:	c0 41       	brne	800071d0 <_malloc_r+0x74>
800071ca:	ee 03 16 03 	lsr	r3,r7,0x3
800071ce:	c2 68       	rjmp	8000721a <_malloc_r+0xbe>
800071d0:	58 43       	cp.w	r3,4
800071d2:	e0 8b 00 06 	brhi	800071de <_malloc_r+0x82>
800071d6:	ee 03 16 06 	lsr	r3,r7,0x6
800071da:	2c 83       	sub	r3,-56
800071dc:	c1 f8       	rjmp	8000721a <_malloc_r+0xbe>
800071de:	59 43       	cp.w	r3,20
800071e0:	e0 8b 00 04 	brhi	800071e8 <_malloc_r+0x8c>
800071e4:	2a 53       	sub	r3,-91
800071e6:	c1 a8       	rjmp	8000721a <_malloc_r+0xbe>
800071e8:	e0 43 00 54 	cp.w	r3,84
800071ec:	e0 8b 00 06 	brhi	800071f8 <_malloc_r+0x9c>
800071f0:	ee 03 16 0c 	lsr	r3,r7,0xc
800071f4:	29 23       	sub	r3,-110
800071f6:	c1 28       	rjmp	8000721a <_malloc_r+0xbe>
800071f8:	e0 43 01 54 	cp.w	r3,340
800071fc:	e0 8b 00 06 	brhi	80007208 <_malloc_r+0xac>
80007200:	ee 03 16 0f 	lsr	r3,r7,0xf
80007204:	28 93       	sub	r3,-119
80007206:	c0 a8       	rjmp	8000721a <_malloc_r+0xbe>
80007208:	e0 43 05 54 	cp.w	r3,1364
8000720c:	e0 88 00 04 	brls	80007214 <_malloc_r+0xb8>
80007210:	37 e3       	mov	r3,126
80007212:	c0 48       	rjmp	8000721a <_malloc_r+0xbe>
80007214:	ee 03 16 12 	lsr	r3,r7,0x12
80007218:	28 43       	sub	r3,-124
8000721a:	e0 6a 05 3c 	mov	r10,1340
8000721e:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80007222:	74 36       	ld.w	r6,r10[0xc]
80007224:	c1 98       	rjmp	80007256 <_malloc_r+0xfa>
80007226:	6c 19       	ld.w	r9,r6[0x4]
80007228:	e0 19 ff fc 	andl	r9,0xfffc
8000722c:	f2 07 01 0b 	sub	r11,r9,r7
80007230:	58 fb       	cp.w	r11,15
80007232:	e0 8a 00 04 	brle	8000723a <_malloc_r+0xde>
80007236:	20 13       	sub	r3,1
80007238:	c1 18       	rjmp	8000725a <_malloc_r+0xfe>
8000723a:	6c 38       	ld.w	r8,r6[0xc]
8000723c:	58 0b       	cp.w	r11,0
8000723e:	c0 b5       	brlt	80007254 <_malloc_r+0xf8>
80007240:	6c 2a       	ld.w	r10,r6[0x8]
80007242:	ec 09 00 09 	add	r9,r6,r9
80007246:	0a 9c       	mov	r12,r5
80007248:	91 2a       	st.w	r8[0x8],r10
8000724a:	95 38       	st.w	r10[0xc],r8
8000724c:	72 18       	ld.w	r8,r9[0x4]
8000724e:	a1 a8       	sbr	r8,0x0
80007250:	93 18       	st.w	r9[0x4],r8
80007252:	cb c8       	rjmp	800073ca <_malloc_r+0x26e>
80007254:	10 96       	mov	r6,r8
80007256:	14 36       	cp.w	r6,r10
80007258:	ce 71       	brne	80007226 <_malloc_r+0xca>
8000725a:	2f f3       	sub	r3,-1
8000725c:	e0 6a 05 3c 	mov	r10,1340
80007260:	f4 cc ff f8 	sub	r12,r10,-8
80007264:	78 26       	ld.w	r6,r12[0x8]
80007266:	18 36       	cp.w	r6,r12
80007268:	c6 c0       	breq	80007340 <_malloc_r+0x1e4>
8000726a:	6c 19       	ld.w	r9,r6[0x4]
8000726c:	e0 19 ff fc 	andl	r9,0xfffc
80007270:	f2 07 01 08 	sub	r8,r9,r7
80007274:	58 f8       	cp.w	r8,15
80007276:	e0 89 00 8f 	brgt	80007394 <_malloc_r+0x238>
8000727a:	99 3c       	st.w	r12[0xc],r12
8000727c:	99 2c       	st.w	r12[0x8],r12
8000727e:	58 08       	cp.w	r8,0
80007280:	c0 55       	brlt	8000728a <_malloc_r+0x12e>
80007282:	ec 09 00 09 	add	r9,r6,r9
80007286:	0a 9c       	mov	r12,r5
80007288:	ce 2b       	rjmp	8000724c <_malloc_r+0xf0>
8000728a:	e0 49 01 ff 	cp.w	r9,511
8000728e:	e0 8b 00 13 	brhi	800072b4 <_malloc_r+0x158>
80007292:	a3 99       	lsr	r9,0x3
80007294:	f4 09 00 38 	add	r8,r10,r9<<0x3
80007298:	70 2b       	ld.w	r11,r8[0x8]
8000729a:	8d 38       	st.w	r6[0xc],r8
8000729c:	8d 2b       	st.w	r6[0x8],r11
8000729e:	97 36       	st.w	r11[0xc],r6
800072a0:	91 26       	st.w	r8[0x8],r6
800072a2:	a3 49       	asr	r9,0x2
800072a4:	74 18       	ld.w	r8,r10[0x4]
800072a6:	30 1b       	mov	r11,1
800072a8:	f6 09 09 49 	lsl	r9,r11,r9
800072ac:	f1 e9 10 09 	or	r9,r8,r9
800072b0:	95 19       	st.w	r10[0x4],r9
800072b2:	c4 78       	rjmp	80007340 <_malloc_r+0x1e4>
800072b4:	f2 0a 16 09 	lsr	r10,r9,0x9
800072b8:	58 4a       	cp.w	r10,4
800072ba:	e0 8b 00 07 	brhi	800072c8 <_malloc_r+0x16c>
800072be:	f2 0a 16 06 	lsr	r10,r9,0x6
800072c2:	2c 8a       	sub	r10,-56
800072c4:	c2 08       	rjmp	80007304 <_malloc_r+0x1a8>
800072c6:	d7 03       	nop
800072c8:	59 4a       	cp.w	r10,20
800072ca:	e0 8b 00 04 	brhi	800072d2 <_malloc_r+0x176>
800072ce:	2a 5a       	sub	r10,-91
800072d0:	c1 a8       	rjmp	80007304 <_malloc_r+0x1a8>
800072d2:	e0 4a 00 54 	cp.w	r10,84
800072d6:	e0 8b 00 06 	brhi	800072e2 <_malloc_r+0x186>
800072da:	f2 0a 16 0c 	lsr	r10,r9,0xc
800072de:	29 2a       	sub	r10,-110
800072e0:	c1 28       	rjmp	80007304 <_malloc_r+0x1a8>
800072e2:	e0 4a 01 54 	cp.w	r10,340
800072e6:	e0 8b 00 06 	brhi	800072f2 <_malloc_r+0x196>
800072ea:	f2 0a 16 0f 	lsr	r10,r9,0xf
800072ee:	28 9a       	sub	r10,-119
800072f0:	c0 a8       	rjmp	80007304 <_malloc_r+0x1a8>
800072f2:	e0 4a 05 54 	cp.w	r10,1364
800072f6:	e0 88 00 04 	brls	800072fe <_malloc_r+0x1a2>
800072fa:	37 ea       	mov	r10,126
800072fc:	c0 48       	rjmp	80007304 <_malloc_r+0x1a8>
800072fe:	f2 0a 16 12 	lsr	r10,r9,0x12
80007302:	28 4a       	sub	r10,-124
80007304:	e0 6b 05 3c 	mov	r11,1340
80007308:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000730c:	68 28       	ld.w	r8,r4[0x8]
8000730e:	08 38       	cp.w	r8,r4
80007310:	c0 e1       	brne	8000732c <_malloc_r+0x1d0>
80007312:	76 19       	ld.w	r9,r11[0x4]
80007314:	a3 4a       	asr	r10,0x2
80007316:	30 1e       	mov	lr,1
80007318:	fc 0a 09 4a 	lsl	r10,lr,r10
8000731c:	f3 ea 10 0a 	or	r10,r9,r10
80007320:	10 99       	mov	r9,r8
80007322:	97 1a       	st.w	r11[0x4],r10
80007324:	c0 a8       	rjmp	80007338 <_malloc_r+0x1dc>
80007326:	70 28       	ld.w	r8,r8[0x8]
80007328:	08 38       	cp.w	r8,r4
8000732a:	c0 60       	breq	80007336 <_malloc_r+0x1da>
8000732c:	70 1a       	ld.w	r10,r8[0x4]
8000732e:	e0 1a ff fc 	andl	r10,0xfffc
80007332:	14 39       	cp.w	r9,r10
80007334:	cf 93       	brcs	80007326 <_malloc_r+0x1ca>
80007336:	70 39       	ld.w	r9,r8[0xc]
80007338:	8d 39       	st.w	r6[0xc],r9
8000733a:	8d 28       	st.w	r6[0x8],r8
8000733c:	91 36       	st.w	r8[0xc],r6
8000733e:	93 26       	st.w	r9[0x8],r6
80007340:	e6 08 14 02 	asr	r8,r3,0x2
80007344:	30 1b       	mov	r11,1
80007346:	e0 64 05 3c 	mov	r4,1340
8000734a:	f6 08 09 4b 	lsl	r11,r11,r8
8000734e:	68 18       	ld.w	r8,r4[0x4]
80007350:	10 3b       	cp.w	r11,r8
80007352:	e0 8b 00 6b 	brhi	80007428 <_malloc_r+0x2cc>
80007356:	f7 e8 00 09 	and	r9,r11,r8
8000735a:	c0 b1       	brne	80007370 <_malloc_r+0x214>
8000735c:	e0 13 ff fc 	andl	r3,0xfffc
80007360:	a1 7b       	lsl	r11,0x1
80007362:	2f c3       	sub	r3,-4
80007364:	c0 38       	rjmp	8000736a <_malloc_r+0x20e>
80007366:	2f c3       	sub	r3,-4
80007368:	a1 7b       	lsl	r11,0x1
8000736a:	f7 e8 00 09 	and	r9,r11,r8
8000736e:	cf c0       	breq	80007366 <_malloc_r+0x20a>
80007370:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80007374:	06 92       	mov	r2,r3
80007376:	1c 91       	mov	r1,lr
80007378:	62 36       	ld.w	r6,r1[0xc]
8000737a:	c2 e8       	rjmp	800073d6 <_malloc_r+0x27a>
8000737c:	6c 1a       	ld.w	r10,r6[0x4]
8000737e:	e0 1a ff fc 	andl	r10,0xfffc
80007382:	f4 07 01 08 	sub	r8,r10,r7
80007386:	58 f8       	cp.w	r8,15
80007388:	e0 8a 00 15 	brle	800073b2 <_malloc_r+0x256>
8000738c:	6c 3a       	ld.w	r10,r6[0xc]
8000738e:	6c 29       	ld.w	r9,r6[0x8]
80007390:	95 29       	st.w	r10[0x8],r9
80007392:	93 3a       	st.w	r9[0xc],r10
80007394:	0e 99       	mov	r9,r7
80007396:	ec 07 00 07 	add	r7,r6,r7
8000739a:	a1 a9       	sbr	r9,0x0
8000739c:	99 37       	st.w	r12[0xc],r7
8000739e:	99 27       	st.w	r12[0x8],r7
800073a0:	8d 19       	st.w	r6[0x4],r9
800073a2:	ee 08 09 08 	st.w	r7[r8],r8
800073a6:	8f 2c       	st.w	r7[0x8],r12
800073a8:	8f 3c       	st.w	r7[0xc],r12
800073aa:	a1 a8       	sbr	r8,0x0
800073ac:	0a 9c       	mov	r12,r5
800073ae:	8f 18       	st.w	r7[0x4],r8
800073b0:	c0 d8       	rjmp	800073ca <_malloc_r+0x26e>
800073b2:	6c 39       	ld.w	r9,r6[0xc]
800073b4:	58 08       	cp.w	r8,0
800073b6:	c0 f5       	brlt	800073d4 <_malloc_r+0x278>
800073b8:	ec 0a 00 0a 	add	r10,r6,r10
800073bc:	74 18       	ld.w	r8,r10[0x4]
800073be:	a1 a8       	sbr	r8,0x0
800073c0:	0a 9c       	mov	r12,r5
800073c2:	95 18       	st.w	r10[0x4],r8
800073c4:	6c 28       	ld.w	r8,r6[0x8]
800073c6:	93 28       	st.w	r9[0x8],r8
800073c8:	91 39       	st.w	r8[0xc],r9
800073ca:	fe b0 f4 b3 	rcall	80005d30 <__malloc_unlock>
800073ce:	ec cc ff f8 	sub	r12,r6,-8
800073d2:	d8 32       	popm	r0-r7,pc
800073d4:	12 96       	mov	r6,r9
800073d6:	02 36       	cp.w	r6,r1
800073d8:	cd 21       	brne	8000737c <_malloc_r+0x220>
800073da:	2f f2       	sub	r2,-1
800073dc:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800073e0:	c0 30       	breq	800073e6 <_malloc_r+0x28a>
800073e2:	2f 81       	sub	r1,-8
800073e4:	cc ab       	rjmp	80007378 <_malloc_r+0x21c>
800073e6:	1c 98       	mov	r8,lr
800073e8:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
800073ec:	c0 81       	brne	800073fc <_malloc_r+0x2a0>
800073ee:	68 19       	ld.w	r9,r4[0x4]
800073f0:	f6 08 11 ff 	rsub	r8,r11,-1
800073f4:	f3 e8 00 08 	and	r8,r9,r8
800073f8:	89 18       	st.w	r4[0x4],r8
800073fa:	c0 78       	rjmp	80007408 <_malloc_r+0x2ac>
800073fc:	f0 c9 00 08 	sub	r9,r8,8
80007400:	20 13       	sub	r3,1
80007402:	70 08       	ld.w	r8,r8[0x0]
80007404:	12 38       	cp.w	r8,r9
80007406:	cf 10       	breq	800073e8 <_malloc_r+0x28c>
80007408:	a1 7b       	lsl	r11,0x1
8000740a:	68 18       	ld.w	r8,r4[0x4]
8000740c:	10 3b       	cp.w	r11,r8
8000740e:	e0 8b 00 0d 	brhi	80007428 <_malloc_r+0x2cc>
80007412:	58 0b       	cp.w	r11,0
80007414:	c0 a0       	breq	80007428 <_malloc_r+0x2cc>
80007416:	04 93       	mov	r3,r2
80007418:	c0 38       	rjmp	8000741e <_malloc_r+0x2c2>
8000741a:	2f c3       	sub	r3,-4
8000741c:	a1 7b       	lsl	r11,0x1
8000741e:	f7 e8 00 09 	and	r9,r11,r8
80007422:	ca 71       	brne	80007370 <_malloc_r+0x214>
80007424:	cf bb       	rjmp	8000741a <_malloc_r+0x2be>
80007426:	d7 03       	nop
80007428:	68 23       	ld.w	r3,r4[0x8]
8000742a:	66 12       	ld.w	r2,r3[0x4]
8000742c:	e0 12 ff fc 	andl	r2,0xfffc
80007430:	0e 32       	cp.w	r2,r7
80007432:	5f 39       	srlo	r9
80007434:	e4 07 01 08 	sub	r8,r2,r7
80007438:	58 f8       	cp.w	r8,15
8000743a:	5f aa       	srle	r10
8000743c:	f5 e9 10 09 	or	r9,r10,r9
80007440:	e0 80 00 9a 	breq	80007574 <_malloc_r+0x418>
80007444:	e0 68 0d 4c 	mov	r8,3404
80007448:	70 01       	ld.w	r1,r8[0x0]
8000744a:	e0 68 09 48 	mov	r8,2376
8000744e:	2f 01       	sub	r1,-16
80007450:	70 08       	ld.w	r8,r8[0x0]
80007452:	0e 01       	add	r1,r7
80007454:	5b f8       	cp.w	r8,-1
80007456:	c0 40       	breq	8000745e <_malloc_r+0x302>
80007458:	28 11       	sub	r1,-127
8000745a:	e0 11 ff 80 	andl	r1,0xff80
8000745e:	02 9b       	mov	r11,r1
80007460:	0a 9c       	mov	r12,r5
80007462:	e0 a0 02 a5 	rcall	800079ac <_sbrk_r>
80007466:	18 96       	mov	r6,r12
80007468:	5b fc       	cp.w	r12,-1
8000746a:	c7 50       	breq	80007554 <_malloc_r+0x3f8>
8000746c:	e6 02 00 08 	add	r8,r3,r2
80007470:	10 3c       	cp.w	r12,r8
80007472:	c0 32       	brcc	80007478 <_malloc_r+0x31c>
80007474:	08 33       	cp.w	r3,r4
80007476:	c6 f1       	brne	80007554 <_malloc_r+0x3f8>
80007478:	e0 6a 0d 50 	mov	r10,3408
8000747c:	74 09       	ld.w	r9,r10[0x0]
8000747e:	e2 09 00 09 	add	r9,r1,r9
80007482:	95 09       	st.w	r10[0x0],r9
80007484:	10 36       	cp.w	r6,r8
80007486:	c0 a1       	brne	8000749a <_malloc_r+0x33e>
80007488:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000748c:	c0 71       	brne	8000749a <_malloc_r+0x33e>
8000748e:	e2 02 00 02 	add	r2,r1,r2
80007492:	68 28       	ld.w	r8,r4[0x8]
80007494:	a1 a2       	sbr	r2,0x0
80007496:	91 12       	st.w	r8[0x4],r2
80007498:	c4 f8       	rjmp	80007536 <_malloc_r+0x3da>
8000749a:	e0 6a 09 48 	mov	r10,2376
8000749e:	74 0b       	ld.w	r11,r10[0x0]
800074a0:	5b fb       	cp.w	r11,-1
800074a2:	c0 31       	brne	800074a8 <_malloc_r+0x34c>
800074a4:	95 06       	st.w	r10[0x0],r6
800074a6:	c0 78       	rjmp	800074b4 <_malloc_r+0x358>
800074a8:	ec 09 00 09 	add	r9,r6,r9
800074ac:	e0 6a 0d 50 	mov	r10,3408
800074b0:	10 19       	sub	r9,r8
800074b2:	95 09       	st.w	r10[0x0],r9
800074b4:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
800074b8:	f0 09 11 08 	rsub	r9,r8,8
800074bc:	58 08       	cp.w	r8,0
800074be:	f2 08 17 10 	movne	r8,r9
800074c2:	ed d8 e1 06 	addne	r6,r6,r8
800074c6:	28 08       	sub	r8,-128
800074c8:	ec 01 00 01 	add	r1,r6,r1
800074cc:	0a 9c       	mov	r12,r5
800074ce:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800074d2:	f0 01 01 01 	sub	r1,r8,r1
800074d6:	02 9b       	mov	r11,r1
800074d8:	e0 a0 02 6a 	rcall	800079ac <_sbrk_r>
800074dc:	e0 68 0d 50 	mov	r8,3408
800074e0:	5b fc       	cp.w	r12,-1
800074e2:	ec 0c 17 00 	moveq	r12,r6
800074e6:	f9 b1 00 00 	moveq	r1,0
800074ea:	70 09       	ld.w	r9,r8[0x0]
800074ec:	0c 1c       	sub	r12,r6
800074ee:	89 26       	st.w	r4[0x8],r6
800074f0:	02 0c       	add	r12,r1
800074f2:	12 01       	add	r1,r9
800074f4:	a1 ac       	sbr	r12,0x0
800074f6:	91 01       	st.w	r8[0x0],r1
800074f8:	8d 1c       	st.w	r6[0x4],r12
800074fa:	08 33       	cp.w	r3,r4
800074fc:	c1 d0       	breq	80007536 <_malloc_r+0x3da>
800074fe:	58 f2       	cp.w	r2,15
80007500:	e0 8b 00 05 	brhi	8000750a <_malloc_r+0x3ae>
80007504:	30 18       	mov	r8,1
80007506:	8d 18       	st.w	r6[0x4],r8
80007508:	c2 68       	rjmp	80007554 <_malloc_r+0x3f8>
8000750a:	30 59       	mov	r9,5
8000750c:	20 c2       	sub	r2,12
8000750e:	e0 12 ff f8 	andl	r2,0xfff8
80007512:	e6 02 00 08 	add	r8,r3,r2
80007516:	91 29       	st.w	r8[0x8],r9
80007518:	91 19       	st.w	r8[0x4],r9
8000751a:	66 18       	ld.w	r8,r3[0x4]
8000751c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007520:	e5 e8 10 08 	or	r8,r2,r8
80007524:	87 18       	st.w	r3[0x4],r8
80007526:	58 f2       	cp.w	r2,15
80007528:	e0 88 00 07 	brls	80007536 <_malloc_r+0x3da>
8000752c:	e6 cb ff f8 	sub	r11,r3,-8
80007530:	0a 9c       	mov	r12,r5
80007532:	e0 a0 1c 6b 	rcall	8000ae08 <_free_r>
80007536:	e0 69 0d 48 	mov	r9,3400
8000753a:	72 0a       	ld.w	r10,r9[0x0]
8000753c:	e0 68 0d 50 	mov	r8,3408
80007540:	70 08       	ld.w	r8,r8[0x0]
80007542:	14 38       	cp.w	r8,r10
80007544:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007548:	e0 69 0d 44 	mov	r9,3396
8000754c:	72 0a       	ld.w	r10,r9[0x0]
8000754e:	14 38       	cp.w	r8,r10
80007550:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007554:	68 28       	ld.w	r8,r4[0x8]
80007556:	70 18       	ld.w	r8,r8[0x4]
80007558:	e0 18 ff fc 	andl	r8,0xfffc
8000755c:	0e 38       	cp.w	r8,r7
8000755e:	5f 39       	srlo	r9
80007560:	0e 18       	sub	r8,r7
80007562:	58 f8       	cp.w	r8,15
80007564:	5f aa       	srle	r10
80007566:	f5 e9 10 09 	or	r9,r10,r9
8000756a:	c0 50       	breq	80007574 <_malloc_r+0x418>
8000756c:	0a 9c       	mov	r12,r5
8000756e:	fe b0 f3 e1 	rcall	80005d30 <__malloc_unlock>
80007572:	d8 3a       	popm	r0-r7,pc,r12=0
80007574:	68 26       	ld.w	r6,r4[0x8]
80007576:	a1 a8       	sbr	r8,0x0
80007578:	0e 99       	mov	r9,r7
8000757a:	a1 a9       	sbr	r9,0x0
8000757c:	8d 19       	st.w	r6[0x4],r9
8000757e:	ec 07 00 07 	add	r7,r6,r7
80007582:	0a 9c       	mov	r12,r5
80007584:	89 27       	st.w	r4[0x8],r7
80007586:	8f 18       	st.w	r7[0x4],r8
80007588:	fe b0 f3 d4 	rcall	80005d30 <__malloc_unlock>
8000758c:	ec cc ff f8 	sub	r12,r6,-8
80007590:	d8 32       	popm	r0-r7,pc
80007592:	d7 03       	nop

80007594 <memcpy>:
80007594:	58 8a       	cp.w	r10,8
80007596:	c2 f5       	brlt	800075f4 <memcpy+0x60>
80007598:	f9 eb 10 09 	or	r9,r12,r11
8000759c:	e2 19 00 03 	andl	r9,0x3,COH
800075a0:	e0 81 00 97 	brne	800076ce <memcpy+0x13a>
800075a4:	e0 4a 00 20 	cp.w	r10,32
800075a8:	c3 b4       	brge	8000761e <memcpy+0x8a>
800075aa:	f4 08 14 02 	asr	r8,r10,0x2
800075ae:	f0 09 11 08 	rsub	r9,r8,8
800075b2:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800075b6:	76 69       	ld.w	r9,r11[0x18]
800075b8:	99 69       	st.w	r12[0x18],r9
800075ba:	76 59       	ld.w	r9,r11[0x14]
800075bc:	99 59       	st.w	r12[0x14],r9
800075be:	76 49       	ld.w	r9,r11[0x10]
800075c0:	99 49       	st.w	r12[0x10],r9
800075c2:	76 39       	ld.w	r9,r11[0xc]
800075c4:	99 39       	st.w	r12[0xc],r9
800075c6:	76 29       	ld.w	r9,r11[0x8]
800075c8:	99 29       	st.w	r12[0x8],r9
800075ca:	76 19       	ld.w	r9,r11[0x4]
800075cc:	99 19       	st.w	r12[0x4],r9
800075ce:	76 09       	ld.w	r9,r11[0x0]
800075d0:	99 09       	st.w	r12[0x0],r9
800075d2:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800075d6:	f8 08 00 28 	add	r8,r12,r8<<0x2
800075da:	e0 1a 00 03 	andl	r10,0x3
800075de:	f4 0a 11 04 	rsub	r10,r10,4
800075e2:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800075e6:	17 a9       	ld.ub	r9,r11[0x2]
800075e8:	b0 a9       	st.b	r8[0x2],r9
800075ea:	17 99       	ld.ub	r9,r11[0x1]
800075ec:	b0 99       	st.b	r8[0x1],r9
800075ee:	17 89       	ld.ub	r9,r11[0x0]
800075f0:	b0 89       	st.b	r8[0x0],r9
800075f2:	5e fc       	retal	r12
800075f4:	f4 0a 11 09 	rsub	r10,r10,9
800075f8:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800075fc:	17 f9       	ld.ub	r9,r11[0x7]
800075fe:	b8 f9       	st.b	r12[0x7],r9
80007600:	17 e9       	ld.ub	r9,r11[0x6]
80007602:	b8 e9       	st.b	r12[0x6],r9
80007604:	17 d9       	ld.ub	r9,r11[0x5]
80007606:	b8 d9       	st.b	r12[0x5],r9
80007608:	17 c9       	ld.ub	r9,r11[0x4]
8000760a:	b8 c9       	st.b	r12[0x4],r9
8000760c:	17 b9       	ld.ub	r9,r11[0x3]
8000760e:	b8 b9       	st.b	r12[0x3],r9
80007610:	17 a9       	ld.ub	r9,r11[0x2]
80007612:	b8 a9       	st.b	r12[0x2],r9
80007614:	17 99       	ld.ub	r9,r11[0x1]
80007616:	b8 99       	st.b	r12[0x1],r9
80007618:	17 89       	ld.ub	r9,r11[0x0]
8000761a:	b8 89       	st.b	r12[0x0],r9
8000761c:	5e fc       	retal	r12
8000761e:	eb cd 40 c0 	pushm	r6-r7,lr
80007622:	18 99       	mov	r9,r12
80007624:	22 0a       	sub	r10,32
80007626:	b7 07       	ld.d	r6,r11++
80007628:	b3 26       	st.d	r9++,r6
8000762a:	b7 07       	ld.d	r6,r11++
8000762c:	b3 26       	st.d	r9++,r6
8000762e:	b7 07       	ld.d	r6,r11++
80007630:	b3 26       	st.d	r9++,r6
80007632:	b7 07       	ld.d	r6,r11++
80007634:	b3 26       	st.d	r9++,r6
80007636:	22 0a       	sub	r10,32
80007638:	cf 74       	brge	80007626 <memcpy+0x92>
8000763a:	2f 0a       	sub	r10,-16
8000763c:	c0 65       	brlt	80007648 <memcpy+0xb4>
8000763e:	b7 07       	ld.d	r6,r11++
80007640:	b3 26       	st.d	r9++,r6
80007642:	b7 07       	ld.d	r6,r11++
80007644:	b3 26       	st.d	r9++,r6
80007646:	21 0a       	sub	r10,16
80007648:	5c 3a       	neg	r10
8000764a:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000764e:	d7 03       	nop
80007650:	d7 03       	nop
80007652:	f7 36 00 0e 	ld.ub	r6,r11[14]
80007656:	f3 66 00 0e 	st.b	r9[14],r6
8000765a:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000765e:	f3 66 00 0d 	st.b	r9[13],r6
80007662:	f7 36 00 0c 	ld.ub	r6,r11[12]
80007666:	f3 66 00 0c 	st.b	r9[12],r6
8000766a:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000766e:	f3 66 00 0b 	st.b	r9[11],r6
80007672:	f7 36 00 0a 	ld.ub	r6,r11[10]
80007676:	f3 66 00 0a 	st.b	r9[10],r6
8000767a:	f7 36 00 09 	ld.ub	r6,r11[9]
8000767e:	f3 66 00 09 	st.b	r9[9],r6
80007682:	f7 36 00 08 	ld.ub	r6,r11[8]
80007686:	f3 66 00 08 	st.b	r9[8],r6
8000768a:	f7 36 00 07 	ld.ub	r6,r11[7]
8000768e:	f3 66 00 07 	st.b	r9[7],r6
80007692:	f7 36 00 06 	ld.ub	r6,r11[6]
80007696:	f3 66 00 06 	st.b	r9[6],r6
8000769a:	f7 36 00 05 	ld.ub	r6,r11[5]
8000769e:	f3 66 00 05 	st.b	r9[5],r6
800076a2:	f7 36 00 04 	ld.ub	r6,r11[4]
800076a6:	f3 66 00 04 	st.b	r9[4],r6
800076aa:	f7 36 00 03 	ld.ub	r6,r11[3]
800076ae:	f3 66 00 03 	st.b	r9[3],r6
800076b2:	f7 36 00 02 	ld.ub	r6,r11[2]
800076b6:	f3 66 00 02 	st.b	r9[2],r6
800076ba:	f7 36 00 01 	ld.ub	r6,r11[1]
800076be:	f3 66 00 01 	st.b	r9[1],r6
800076c2:	f7 36 00 00 	ld.ub	r6,r11[0]
800076c6:	f3 66 00 00 	st.b	r9[0],r6
800076ca:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800076ce:	20 1a       	sub	r10,1
800076d0:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800076d4:	f8 0a 0b 09 	st.b	r12[r10],r9
800076d8:	cf b1       	brne	800076ce <memcpy+0x13a>
800076da:	5e fc       	retal	r12

800076dc <memset>:
800076dc:	18 98       	mov	r8,r12
800076de:	c0 38       	rjmp	800076e4 <memset+0x8>
800076e0:	10 cb       	st.b	r8++,r11
800076e2:	20 1a       	sub	r10,1
800076e4:	58 0a       	cp.w	r10,0
800076e6:	cf d1       	brne	800076e0 <memset+0x4>
800076e8:	5e fc       	retal	r12
800076ea:	d7 03       	nop

800076ec <_realloc_r>:
800076ec:	d4 31       	pushm	r0-r7,lr
800076ee:	20 1d       	sub	sp,4
800076f0:	16 94       	mov	r4,r11
800076f2:	18 92       	mov	r2,r12
800076f4:	14 9b       	mov	r11,r10
800076f6:	58 04       	cp.w	r4,0
800076f8:	c0 51       	brne	80007702 <_realloc_r+0x16>
800076fa:	fe b0 fd 31 	rcall	8000715c <_malloc_r>
800076fe:	18 95       	mov	r5,r12
80007700:	c5 39       	rjmp	800079a6 <_realloc_r+0x2ba>
80007702:	50 0a       	stdsp	sp[0x0],r10
80007704:	fe b0 f3 10 	rcall	80005d24 <__malloc_lock>
80007708:	40 0b       	lddsp	r11,sp[0x0]
8000770a:	f6 c8 ff f5 	sub	r8,r11,-11
8000770e:	e8 c1 00 08 	sub	r1,r4,8
80007712:	10 96       	mov	r6,r8
80007714:	62 1c       	ld.w	r12,r1[0x4]
80007716:	e0 16 ff f8 	andl	r6,0xfff8
8000771a:	59 68       	cp.w	r8,22
8000771c:	f9 b6 08 10 	movls	r6,16
80007720:	16 36       	cp.w	r6,r11
80007722:	5f 38       	srlo	r8
80007724:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80007728:	c0 50       	breq	80007732 <_realloc_r+0x46>
8000772a:	30 c8       	mov	r8,12
8000772c:	30 05       	mov	r5,0
8000772e:	85 38       	st.w	r2[0xc],r8
80007730:	c3 b9       	rjmp	800079a6 <_realloc_r+0x2ba>
80007732:	18 90       	mov	r0,r12
80007734:	e0 10 ff fc 	andl	r0,0xfffc
80007738:	0c 30       	cp.w	r0,r6
8000773a:	e0 84 01 0b 	brge	80007950 <_realloc_r+0x264>
8000773e:	e0 68 05 3c 	mov	r8,1340
80007742:	e2 00 00 09 	add	r9,r1,r0
80007746:	70 25       	ld.w	r5,r8[0x8]
80007748:	0a 39       	cp.w	r9,r5
8000774a:	c0 90       	breq	8000775c <_realloc_r+0x70>
8000774c:	72 1a       	ld.w	r10,r9[0x4]
8000774e:	a1 ca       	cbr	r10,0x0
80007750:	f2 0a 00 0a 	add	r10,r9,r10
80007754:	74 1a       	ld.w	r10,r10[0x4]
80007756:	ed ba 00 00 	bld	r10,0x0
8000775a:	c2 20       	breq	8000779e <_realloc_r+0xb2>
8000775c:	72 1a       	ld.w	r10,r9[0x4]
8000775e:	e0 1a ff fc 	andl	r10,0xfffc
80007762:	f4 00 00 03 	add	r3,r10,r0
80007766:	0a 39       	cp.w	r9,r5
80007768:	c1 31       	brne	8000778e <_realloc_r+0xa2>
8000776a:	ec c7 ff f0 	sub	r7,r6,-16
8000776e:	0e 33       	cp.w	r3,r7
80007770:	c1 95       	brlt	800077a2 <_realloc_r+0xb6>
80007772:	e2 06 00 09 	add	r9,r1,r6
80007776:	0c 13       	sub	r3,r6
80007778:	a1 a3       	sbr	r3,0x0
8000777a:	93 13       	st.w	r9[0x4],r3
8000777c:	91 29       	st.w	r8[0x8],r9
8000777e:	04 9c       	mov	r12,r2
80007780:	62 18       	ld.w	r8,r1[0x4]
80007782:	08 95       	mov	r5,r4
80007784:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007788:	10 46       	or	r6,r8
8000778a:	83 16       	st.w	r1[0x4],r6
8000778c:	c0 b9       	rjmp	800079a2 <_realloc_r+0x2b6>
8000778e:	0c 33       	cp.w	r3,r6
80007790:	c0 95       	brlt	800077a2 <_realloc_r+0xb6>
80007792:	72 28       	ld.w	r8,r9[0x8]
80007794:	02 97       	mov	r7,r1
80007796:	72 39       	ld.w	r9,r9[0xc]
80007798:	93 28       	st.w	r9[0x8],r8
8000779a:	91 39       	st.w	r8[0xc],r9
8000779c:	cd c8       	rjmp	80007954 <_realloc_r+0x268>
8000779e:	30 0a       	mov	r10,0
800077a0:	14 99       	mov	r9,r10
800077a2:	ed bc 00 00 	bld	r12,0x0
800077a6:	e0 80 00 95 	breq	800078d0 <_realloc_r+0x1e4>
800077aa:	62 07       	ld.w	r7,r1[0x0]
800077ac:	e2 07 01 07 	sub	r7,r1,r7
800077b0:	6e 1c       	ld.w	r12,r7[0x4]
800077b2:	e0 1c ff fc 	andl	r12,0xfffc
800077b6:	58 09       	cp.w	r9,0
800077b8:	c5 60       	breq	80007864 <_realloc_r+0x178>
800077ba:	f8 00 00 03 	add	r3,r12,r0
800077be:	0a 39       	cp.w	r9,r5
800077c0:	c4 81       	brne	80007850 <_realloc_r+0x164>
800077c2:	14 03       	add	r3,r10
800077c4:	ec c9 ff f0 	sub	r9,r6,-16
800077c8:	12 33       	cp.w	r3,r9
800077ca:	c4 d5       	brlt	80007864 <_realloc_r+0x178>
800077cc:	6e 3a       	ld.w	r10,r7[0xc]
800077ce:	6e 29       	ld.w	r9,r7[0x8]
800077d0:	95 29       	st.w	r10[0x8],r9
800077d2:	93 3a       	st.w	r9[0xc],r10
800077d4:	ee c5 ff f8 	sub	r5,r7,-8
800077d8:	e0 ca 00 04 	sub	r10,r0,4
800077dc:	e0 4a 00 24 	cp.w	r10,36
800077e0:	e0 8b 00 25 	brhi	8000782a <_realloc_r+0x13e>
800077e4:	0a 99       	mov	r9,r5
800077e6:	59 3a       	cp.w	r10,19
800077e8:	e0 88 00 1a 	brls	8000781c <_realloc_r+0x130>
800077ec:	09 09       	ld.w	r9,r4++
800077ee:	8b 09       	st.w	r5[0x0],r9
800077f0:	09 09       	ld.w	r9,r4++
800077f2:	8f 39       	st.w	r7[0xc],r9
800077f4:	ee c9 ff f0 	sub	r9,r7,-16
800077f8:	59 ba       	cp.w	r10,27
800077fa:	e0 88 00 11 	brls	8000781c <_realloc_r+0x130>
800077fe:	09 0b       	ld.w	r11,r4++
80007800:	93 0b       	st.w	r9[0x0],r11
80007802:	09 09       	ld.w	r9,r4++
80007804:	8f 59       	st.w	r7[0x14],r9
80007806:	ee c9 ff e8 	sub	r9,r7,-24
8000780a:	e0 4a 00 24 	cp.w	r10,36
8000780e:	c0 71       	brne	8000781c <_realloc_r+0x130>
80007810:	09 0a       	ld.w	r10,r4++
80007812:	93 0a       	st.w	r9[0x0],r10
80007814:	ee c9 ff e0 	sub	r9,r7,-32
80007818:	09 0a       	ld.w	r10,r4++
8000781a:	8f 7a       	st.w	r7[0x1c],r10
8000781c:	09 0a       	ld.w	r10,r4++
8000781e:	12 aa       	st.w	r9++,r10
80007820:	68 0a       	ld.w	r10,r4[0x0]
80007822:	93 0a       	st.w	r9[0x0],r10
80007824:	68 1a       	ld.w	r10,r4[0x4]
80007826:	93 1a       	st.w	r9[0x4],r10
80007828:	c0 78       	rjmp	80007836 <_realloc_r+0x14a>
8000782a:	50 08       	stdsp	sp[0x0],r8
8000782c:	08 9b       	mov	r11,r4
8000782e:	0a 9c       	mov	r12,r5
80007830:	e0 a0 1d 8f 	rcall	8000b34e <memmove>
80007834:	40 08       	lddsp	r8,sp[0x0]
80007836:	ee 06 00 09 	add	r9,r7,r6
8000783a:	0c 13       	sub	r3,r6
8000783c:	a1 a3       	sbr	r3,0x0
8000783e:	93 13       	st.w	r9[0x4],r3
80007840:	91 29       	st.w	r8[0x8],r9
80007842:	04 9c       	mov	r12,r2
80007844:	6e 18       	ld.w	r8,r7[0x4]
80007846:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000784a:	10 46       	or	r6,r8
8000784c:	8f 16       	st.w	r7[0x4],r6
8000784e:	ca a8       	rjmp	800079a2 <_realloc_r+0x2b6>
80007850:	14 03       	add	r3,r10
80007852:	0c 33       	cp.w	r3,r6
80007854:	c0 85       	brlt	80007864 <_realloc_r+0x178>
80007856:	72 28       	ld.w	r8,r9[0x8]
80007858:	72 39       	ld.w	r9,r9[0xc]
8000785a:	93 28       	st.w	r9[0x8],r8
8000785c:	91 39       	st.w	r8[0xc],r9
8000785e:	6e 28       	ld.w	r8,r7[0x8]
80007860:	6e 39       	ld.w	r9,r7[0xc]
80007862:	c0 78       	rjmp	80007870 <_realloc_r+0x184>
80007864:	f8 00 00 03 	add	r3,r12,r0
80007868:	0c 33       	cp.w	r3,r6
8000786a:	c3 35       	brlt	800078d0 <_realloc_r+0x1e4>
8000786c:	6e 39       	ld.w	r9,r7[0xc]
8000786e:	6e 28       	ld.w	r8,r7[0x8]
80007870:	93 28       	st.w	r9[0x8],r8
80007872:	91 39       	st.w	r8[0xc],r9
80007874:	e0 ca 00 04 	sub	r10,r0,4
80007878:	ee cc ff f8 	sub	r12,r7,-8
8000787c:	e0 4a 00 24 	cp.w	r10,36
80007880:	e0 8b 00 24 	brhi	800078c8 <_realloc_r+0x1dc>
80007884:	59 3a       	cp.w	r10,19
80007886:	e0 88 00 1a 	brls	800078ba <_realloc_r+0x1ce>
8000788a:	09 08       	ld.w	r8,r4++
8000788c:	99 08       	st.w	r12[0x0],r8
8000788e:	09 08       	ld.w	r8,r4++
80007890:	8f 38       	st.w	r7[0xc],r8
80007892:	ee cc ff f0 	sub	r12,r7,-16
80007896:	59 ba       	cp.w	r10,27
80007898:	e0 88 00 11 	brls	800078ba <_realloc_r+0x1ce>
8000789c:	09 08       	ld.w	r8,r4++
8000789e:	99 08       	st.w	r12[0x0],r8
800078a0:	09 08       	ld.w	r8,r4++
800078a2:	8f 58       	st.w	r7[0x14],r8
800078a4:	ee cc ff e8 	sub	r12,r7,-24
800078a8:	e0 4a 00 24 	cp.w	r10,36
800078ac:	c0 71       	brne	800078ba <_realloc_r+0x1ce>
800078ae:	09 08       	ld.w	r8,r4++
800078b0:	99 08       	st.w	r12[0x0],r8
800078b2:	ee cc ff e0 	sub	r12,r7,-32
800078b6:	09 08       	ld.w	r8,r4++
800078b8:	8f 78       	st.w	r7[0x1c],r8
800078ba:	09 08       	ld.w	r8,r4++
800078bc:	18 a8       	st.w	r12++,r8
800078be:	68 08       	ld.w	r8,r4[0x0]
800078c0:	99 08       	st.w	r12[0x0],r8
800078c2:	68 18       	ld.w	r8,r4[0x4]
800078c4:	99 18       	st.w	r12[0x4],r8
800078c6:	c4 78       	rjmp	80007954 <_realloc_r+0x268>
800078c8:	08 9b       	mov	r11,r4
800078ca:	e0 a0 1d 42 	rcall	8000b34e <memmove>
800078ce:	c4 38       	rjmp	80007954 <_realloc_r+0x268>
800078d0:	04 9c       	mov	r12,r2
800078d2:	fe b0 fc 45 	rcall	8000715c <_malloc_r>
800078d6:	18 95       	mov	r5,r12
800078d8:	c3 a0       	breq	8000794c <_realloc_r+0x260>
800078da:	62 18       	ld.w	r8,r1[0x4]
800078dc:	f8 c9 00 08 	sub	r9,r12,8
800078e0:	a1 c8       	cbr	r8,0x0
800078e2:	e2 08 00 08 	add	r8,r1,r8
800078e6:	10 39       	cp.w	r9,r8
800078e8:	c0 71       	brne	800078f6 <_realloc_r+0x20a>
800078ea:	72 13       	ld.w	r3,r9[0x4]
800078ec:	02 97       	mov	r7,r1
800078ee:	e0 13 ff fc 	andl	r3,0xfffc
800078f2:	00 03       	add	r3,r0
800078f4:	c3 08       	rjmp	80007954 <_realloc_r+0x268>
800078f6:	e0 ca 00 04 	sub	r10,r0,4
800078fa:	e0 4a 00 24 	cp.w	r10,36
800078fe:	e0 8b 00 20 	brhi	8000793e <_realloc_r+0x252>
80007902:	08 99       	mov	r9,r4
80007904:	18 98       	mov	r8,r12
80007906:	59 3a       	cp.w	r10,19
80007908:	e0 88 00 14 	brls	80007930 <_realloc_r+0x244>
8000790c:	13 0b       	ld.w	r11,r9++
8000790e:	10 ab       	st.w	r8++,r11
80007910:	13 0b       	ld.w	r11,r9++
80007912:	10 ab       	st.w	r8++,r11
80007914:	59 ba       	cp.w	r10,27
80007916:	e0 88 00 0d 	brls	80007930 <_realloc_r+0x244>
8000791a:	13 0b       	ld.w	r11,r9++
8000791c:	10 ab       	st.w	r8++,r11
8000791e:	13 0b       	ld.w	r11,r9++
80007920:	10 ab       	st.w	r8++,r11
80007922:	e0 4a 00 24 	cp.w	r10,36
80007926:	c0 51       	brne	80007930 <_realloc_r+0x244>
80007928:	13 0a       	ld.w	r10,r9++
8000792a:	10 aa       	st.w	r8++,r10
8000792c:	13 0a       	ld.w	r10,r9++
8000792e:	10 aa       	st.w	r8++,r10
80007930:	13 0a       	ld.w	r10,r9++
80007932:	10 aa       	st.w	r8++,r10
80007934:	72 0a       	ld.w	r10,r9[0x0]
80007936:	91 0a       	st.w	r8[0x0],r10
80007938:	72 19       	ld.w	r9,r9[0x4]
8000793a:	91 19       	st.w	r8[0x4],r9
8000793c:	c0 48       	rjmp	80007944 <_realloc_r+0x258>
8000793e:	08 9b       	mov	r11,r4
80007940:	e0 a0 1d 07 	rcall	8000b34e <memmove>
80007944:	08 9b       	mov	r11,r4
80007946:	04 9c       	mov	r12,r2
80007948:	e0 a0 1a 60 	rcall	8000ae08 <_free_r>
8000794c:	04 9c       	mov	r12,r2
8000794e:	c2 a8       	rjmp	800079a2 <_realloc_r+0x2b6>
80007950:	00 93       	mov	r3,r0
80007952:	02 97       	mov	r7,r1
80007954:	e6 06 01 09 	sub	r9,r3,r6
80007958:	6e 18       	ld.w	r8,r7[0x4]
8000795a:	58 f9       	cp.w	r9,15
8000795c:	e0 88 00 16 	brls	80007988 <_realloc_r+0x29c>
80007960:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007964:	ed e8 10 08 	or	r8,r6,r8
80007968:	8f 18       	st.w	r7[0x4],r8
8000796a:	12 98       	mov	r8,r9
8000796c:	a1 a8       	sbr	r8,0x0
8000796e:	ee 06 00 0b 	add	r11,r7,r6
80007972:	f6 09 00 09 	add	r9,r11,r9
80007976:	97 18       	st.w	r11[0x4],r8
80007978:	72 18       	ld.w	r8,r9[0x4]
8000797a:	a1 a8       	sbr	r8,0x0
8000797c:	2f 8b       	sub	r11,-8
8000797e:	93 18       	st.w	r9[0x4],r8
80007980:	04 9c       	mov	r12,r2
80007982:	e0 a0 1a 43 	rcall	8000ae08 <_free_r>
80007986:	c0 b8       	rjmp	8000799c <_realloc_r+0x2b0>
80007988:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000798c:	e7 e8 10 08 	or	r8,r3,r8
80007990:	8f 18       	st.w	r7[0x4],r8
80007992:	ee 03 00 03 	add	r3,r7,r3
80007996:	66 18       	ld.w	r8,r3[0x4]
80007998:	a1 a8       	sbr	r8,0x0
8000799a:	87 18       	st.w	r3[0x4],r8
8000799c:	04 9c       	mov	r12,r2
8000799e:	ee c5 ff f8 	sub	r5,r7,-8
800079a2:	fe b0 f1 c7 	rcall	80005d30 <__malloc_unlock>
800079a6:	0a 9c       	mov	r12,r5
800079a8:	2f fd       	sub	sp,-4
800079aa:	d8 32       	popm	r0-r7,pc

800079ac <_sbrk_r>:
800079ac:	d4 21       	pushm	r4-r7,lr
800079ae:	30 08       	mov	r8,0
800079b0:	18 97       	mov	r7,r12
800079b2:	e0 66 51 24 	mov	r6,20772
800079b6:	16 9c       	mov	r12,r11
800079b8:	8d 08       	st.w	r6[0x0],r8
800079ba:	c8 5c       	rcall	80007ac4 <_sbrk>
800079bc:	5b fc       	cp.w	r12,-1
800079be:	c0 51       	brne	800079c8 <_sbrk_r+0x1c>
800079c0:	6c 08       	ld.w	r8,r6[0x0]
800079c2:	58 08       	cp.w	r8,0
800079c4:	ef f8 1a 03 	st.wne	r7[0xc],r8
800079c8:	d8 22       	popm	r4-r7,pc
800079ca:	d7 03       	nop

800079cc <sprintf>:
800079cc:	d4 01       	pushm	lr
800079ce:	21 7d       	sub	sp,92
800079d0:	e0 68 ff ff 	mov	r8,65535
800079d4:	ea 18 7f ff 	orh	r8,0x7fff
800079d8:	50 58       	stdsp	sp[0x14],r8
800079da:	50 28       	stdsp	sp[0x8],r8
800079dc:	e0 68 02 08 	mov	r8,520
800079e0:	ba 68       	st.h	sp[0xc],r8
800079e2:	3f f8       	mov	r8,-1
800079e4:	ba 78       	st.h	sp[0xe],r8
800079e6:	e0 68 0a 3c 	mov	r8,2620
800079ea:	50 4c       	stdsp	sp[0x10],r12
800079ec:	16 9a       	mov	r10,r11
800079ee:	50 0c       	stdsp	sp[0x0],r12
800079f0:	fa c9 ff a0 	sub	r9,sp,-96
800079f4:	70 0c       	ld.w	r12,r8[0x0]
800079f6:	1a 9b       	mov	r11,sp
800079f8:	e0 a0 02 1a 	rcall	80007e2c <_vfprintf_r>
800079fc:	30 09       	mov	r9,0
800079fe:	40 08       	lddsp	r8,sp[0x0]
80007a00:	b0 89       	st.b	r8[0x0],r9
80007a02:	2e 9d       	sub	sp,-92
80007a04:	d8 02       	popm	pc
80007a06:	d7 03       	nop

80007a08 <strncpy>:
80007a08:	30 08       	mov	r8,0
80007a0a:	10 3a       	cp.w	r10,r8
80007a0c:	5e 0c       	reteq	r12
80007a0e:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007a12:	f8 08 0b 09 	st.b	r12[r8],r9
80007a16:	2f f8       	sub	r8,-1
80007a18:	58 09       	cp.w	r9,0
80007a1a:	cf 81       	brne	80007a0a <strncpy+0x2>
80007a1c:	10 3a       	cp.w	r10,r8
80007a1e:	5e 0c       	reteq	r12
80007a20:	f8 08 0b 09 	st.b	r12[r8],r9
80007a24:	2f f8       	sub	r8,-1
80007a26:	cf bb       	rjmp	80007a1c <strncpy+0x14>

80007a28 <_close>:
80007a28:	30 28       	mov	r8,2
80007a2a:	d6 73       	breakpoint
80007a2c:	3f fc       	mov	r12,-1
80007a2e:	35 8b       	mov	r11,88
80007a30:	58 0c       	cp.w	r12,0
80007a32:	5e 4c       	retge	r12
80007a34:	e0 6a 51 24 	mov	r10,20772
80007a38:	95 0b       	st.w	r10[0x0],r11
80007a3a:	5e fc       	retal	r12

80007a3c <_lseek>:
80007a3c:	30 58       	mov	r8,5
80007a3e:	d6 73       	breakpoint
80007a40:	3f fc       	mov	r12,-1
80007a42:	35 8b       	mov	r11,88
80007a44:	58 0c       	cp.w	r12,0
80007a46:	5e 4c       	retge	r12
80007a48:	e0 6a 51 24 	mov	r10,20772
80007a4c:	95 0b       	st.w	r10[0x0],r11
80007a4e:	5e fc       	retal	r12

80007a50 <isatty>:
80007a50:	30 b8       	mov	r8,11
80007a52:	d6 73       	breakpoint
80007a54:	3f fc       	mov	r12,-1
80007a56:	35 8b       	mov	r11,88
80007a58:	58 0c       	cp.w	r12,0
80007a5a:	5e 4c       	retge	r12
80007a5c:	e0 6a 51 24 	mov	r10,20772
80007a60:	95 0b       	st.w	r10[0x0],r11
80007a62:	5e fc       	retal	r12

80007a64 <_fstat_host>:
80007a64:	30 98       	mov	r8,9
80007a66:	d6 73       	breakpoint
80007a68:	3f fc       	mov	r12,-1
80007a6a:	35 8b       	mov	r11,88
80007a6c:	58 0c       	cp.w	r12,0
80007a6e:	5e 4c       	retge	r12
80007a70:	e0 6a 51 24 	mov	r10,20772
80007a74:	95 0b       	st.w	r10[0x0],r11
80007a76:	5e fc       	retal	r12

80007a78 <_fstat>:
80007a78:	d4 21       	pushm	r4-r7,lr
80007a7a:	21 0d       	sub	sp,64
80007a7c:	16 97       	mov	r7,r11
80007a7e:	1a 9b       	mov	r11,sp
80007a80:	cf 2f       	rcall	80007a64 <_fstat_host>
80007a82:	c0 34       	brge	80007a88 <_fstat+0x10>
80007a84:	3f fc       	mov	r12,-1
80007a86:	c1 c8       	rjmp	80007abe <_fstat+0x46>
80007a88:	40 08       	lddsp	r8,sp[0x0]
80007a8a:	ae 08       	st.h	r7[0x0],r8
80007a8c:	40 18       	lddsp	r8,sp[0x4]
80007a8e:	ae 18       	st.h	r7[0x2],r8
80007a90:	40 28       	lddsp	r8,sp[0x8]
80007a92:	8f 18       	st.w	r7[0x4],r8
80007a94:	40 38       	lddsp	r8,sp[0xc]
80007a96:	ae 48       	st.h	r7[0x8],r8
80007a98:	40 48       	lddsp	r8,sp[0x10]
80007a9a:	ae 58       	st.h	r7[0xa],r8
80007a9c:	40 58       	lddsp	r8,sp[0x14]
80007a9e:	ae 68       	st.h	r7[0xc],r8
80007aa0:	40 68       	lddsp	r8,sp[0x18]
80007aa2:	ae 78       	st.h	r7[0xe],r8
80007aa4:	40 88       	lddsp	r8,sp[0x20]
80007aa6:	8f 48       	st.w	r7[0x10],r8
80007aa8:	40 a8       	lddsp	r8,sp[0x28]
80007aaa:	8f b8       	st.w	r7[0x2c],r8
80007aac:	40 c8       	lddsp	r8,sp[0x30]
80007aae:	8f c8       	st.w	r7[0x30],r8
80007ab0:	40 d8       	lddsp	r8,sp[0x34]
80007ab2:	8f 58       	st.w	r7[0x14],r8
80007ab4:	40 e8       	lddsp	r8,sp[0x38]
80007ab6:	30 0c       	mov	r12,0
80007ab8:	8f 78       	st.w	r7[0x1c],r8
80007aba:	40 f8       	lddsp	r8,sp[0x3c]
80007abc:	8f 98       	st.w	r7[0x24],r8
80007abe:	2f 0d       	sub	sp,-64
80007ac0:	d8 22       	popm	r4-r7,pc
80007ac2:	d7 03       	nop

80007ac4 <_sbrk>:
80007ac4:	d4 01       	pushm	lr
80007ac6:	e0 68 0d 78 	mov	r8,3448
80007aca:	70 09       	ld.w	r9,r8[0x0]
80007acc:	58 09       	cp.w	r9,0
80007ace:	c0 41       	brne	80007ad6 <_sbrk+0x12>
80007ad0:	e0 69 51 28 	mov	r9,20776
80007ad4:	91 09       	st.w	r8[0x0],r9
80007ad6:	e0 69 0d 78 	mov	r9,3448
80007ada:	e0 7a 70 00 	mov	r10,94208
80007ade:	72 08       	ld.w	r8,r9[0x0]
80007ae0:	f0 0c 00 0c 	add	r12,r8,r12
80007ae4:	14 3c       	cp.w	r12,r10
80007ae6:	e0 8b 00 04 	brhi	80007aee <_sbrk+0x2a>
80007aea:	93 0c       	st.w	r9[0x0],r12
80007aec:	c0 68       	rjmp	80007af8 <_sbrk+0x34>
80007aee:	e0 a0 18 15 	rcall	8000ab18 <__errno>
80007af2:	30 c8       	mov	r8,12
80007af4:	99 08       	st.w	r12[0x0],r8
80007af6:	3f f8       	mov	r8,-1
80007af8:	10 9c       	mov	r12,r8
80007afa:	d8 02       	popm	pc

80007afc <get_arg>:
80007afc:	d4 31       	pushm	r0-r7,lr
80007afe:	20 8d       	sub	sp,32
80007b00:	fa c4 ff bc 	sub	r4,sp,-68
80007b04:	50 4b       	stdsp	sp[0x10],r11
80007b06:	68 2e       	ld.w	lr,r4[0x8]
80007b08:	50 58       	stdsp	sp[0x14],r8
80007b0a:	12 96       	mov	r6,r9
80007b0c:	7c 0b       	ld.w	r11,lr[0x0]
80007b0e:	70 05       	ld.w	r5,r8[0x0]
80007b10:	50 6e       	stdsp	sp[0x18],lr
80007b12:	58 0b       	cp.w	r11,0
80007b14:	f4 0b 17 00 	moveq	r11,r10
80007b18:	68 03       	ld.w	r3,r4[0x0]
80007b1a:	68 11       	ld.w	r1,r4[0x4]
80007b1c:	40 49       	lddsp	r9,sp[0x10]
80007b1e:	30 08       	mov	r8,0
80007b20:	c2 89       	rjmp	80007d70 <get_arg+0x274>
80007b22:	2f fb       	sub	r11,-1
80007b24:	32 5c       	mov	r12,37
80007b26:	17 8a       	ld.ub	r10,r11[0x0]
80007b28:	f8 0a 18 00 	cp.b	r10,r12
80007b2c:	5f 1e       	srne	lr
80007b2e:	f0 0a 18 00 	cp.b	r10,r8
80007b32:	5f 1c       	srne	r12
80007b34:	fd ec 00 0c 	and	r12,lr,r12
80007b38:	f0 0c 18 00 	cp.b	r12,r8
80007b3c:	cf 31       	brne	80007b22 <get_arg+0x26>
80007b3e:	58 0a       	cp.w	r10,0
80007b40:	e0 80 01 25 	breq	80007d8a <get_arg+0x28e>
80007b44:	30 0c       	mov	r12,0
80007b46:	3f fa       	mov	r10,-1
80007b48:	18 90       	mov	r0,r12
80007b4a:	50 3a       	stdsp	sp[0xc],r10
80007b4c:	18 94       	mov	r4,r12
80007b4e:	18 92       	mov	r2,r12
80007b50:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007b54:	16 97       	mov	r7,r11
80007b56:	50 7c       	stdsp	sp[0x1c],r12
80007b58:	fe cc 9e 68 	sub	r12,pc,-24984
80007b5c:	0f 3a       	ld.ub	r10,r7++
80007b5e:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007b62:	40 7c       	lddsp	r12,sp[0x1c]
80007b64:	1c 0c       	add	r12,lr
80007b66:	fe ce 9f 3e 	sub	lr,pc,-24770
80007b6a:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007b6e:	20 1e       	sub	lr,1
80007b70:	50 0e       	stdsp	sp[0x0],lr
80007b72:	fe ce 9f b6 	sub	lr,pc,-24650
80007b76:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007b7a:	50 7c       	stdsp	sp[0x1c],r12
80007b7c:	40 0c       	lddsp	r12,sp[0x0]
80007b7e:	58 7c       	cp.w	r12,7
80007b80:	e0 8b 00 f1 	brhi	80007d62 <get_arg+0x266>
80007b84:	fe ce a1 68 	sub	lr,pc,-24216
80007b88:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007b8c:	36 8b       	mov	r11,104
80007b8e:	f6 0a 18 00 	cp.b	r10,r11
80007b92:	e0 80 00 e8 	breq	80007d62 <get_arg+0x266>
80007b96:	37 1b       	mov	r11,113
80007b98:	f6 0a 18 00 	cp.b	r10,r11
80007b9c:	c0 70       	breq	80007baa <get_arg+0xae>
80007b9e:	34 cb       	mov	r11,76
80007ba0:	f6 0a 18 00 	cp.b	r10,r11
80007ba4:	c0 51       	brne	80007bae <get_arg+0xb2>
80007ba6:	a3 b4       	sbr	r4,0x3
80007ba8:	cd d8       	rjmp	80007d62 <get_arg+0x266>
80007baa:	a5 b4       	sbr	r4,0x5
80007bac:	cd b8       	rjmp	80007d62 <get_arg+0x266>
80007bae:	08 9a       	mov	r10,r4
80007bb0:	0e 9b       	mov	r11,r7
80007bb2:	a5 aa       	sbr	r10,0x4
80007bb4:	17 3c       	ld.ub	r12,r11++
80007bb6:	a5 b4       	sbr	r4,0x5
80007bb8:	36 ce       	mov	lr,108
80007bba:	fc 0c 18 00 	cp.b	r12,lr
80007bbe:	e0 80 00 d3 	breq	80007d64 <get_arg+0x268>
80007bc2:	14 94       	mov	r4,r10
80007bc4:	cc f8       	rjmp	80007d62 <get_arg+0x266>
80007bc6:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007bca:	36 7c       	mov	r12,103
80007bcc:	f8 0a 18 00 	cp.b	r10,r12
80007bd0:	e0 8b 00 27 	brhi	80007c1e <get_arg+0x122>
80007bd4:	36 5b       	mov	r11,101
80007bd6:	f6 0a 18 00 	cp.b	r10,r11
80007bda:	c4 82       	brcc	80007c6a <get_arg+0x16e>
80007bdc:	34 fb       	mov	r11,79
80007bde:	f6 0a 18 00 	cp.b	r10,r11
80007be2:	c4 80       	breq	80007c72 <get_arg+0x176>
80007be4:	e0 8b 00 0c 	brhi	80007bfc <get_arg+0x100>
80007be8:	34 5b       	mov	r11,69
80007bea:	f6 0a 18 00 	cp.b	r10,r11
80007bee:	c3 e0       	breq	80007c6a <get_arg+0x16e>
80007bf0:	34 7b       	mov	r11,71
80007bf2:	f6 0a 18 00 	cp.b	r10,r11
80007bf6:	c3 a0       	breq	80007c6a <get_arg+0x16e>
80007bf8:	34 4b       	mov	r11,68
80007bfa:	c0 88       	rjmp	80007c0a <get_arg+0x10e>
80007bfc:	35 8b       	mov	r11,88
80007bfe:	f6 0a 18 00 	cp.b	r10,r11
80007c02:	c2 c0       	breq	80007c5a <get_arg+0x15e>
80007c04:	e0 8b 00 07 	brhi	80007c12 <get_arg+0x116>
80007c08:	35 5b       	mov	r11,85
80007c0a:	f6 0a 18 00 	cp.b	r10,r11
80007c0e:	c3 51       	brne	80007c78 <get_arg+0x17c>
80007c10:	c3 18       	rjmp	80007c72 <get_arg+0x176>
80007c12:	36 3b       	mov	r11,99
80007c14:	f6 0a 18 00 	cp.b	r10,r11
80007c18:	c2 f0       	breq	80007c76 <get_arg+0x17a>
80007c1a:	36 4b       	mov	r11,100
80007c1c:	c0 e8       	rjmp	80007c38 <get_arg+0x13c>
80007c1e:	37 0b       	mov	r11,112
80007c20:	f6 0a 18 00 	cp.b	r10,r11
80007c24:	c2 50       	breq	80007c6e <get_arg+0x172>
80007c26:	e0 8b 00 0d 	brhi	80007c40 <get_arg+0x144>
80007c2a:	36 eb       	mov	r11,110
80007c2c:	f6 0a 18 00 	cp.b	r10,r11
80007c30:	c1 f0       	breq	80007c6e <get_arg+0x172>
80007c32:	e0 8b 00 14 	brhi	80007c5a <get_arg+0x15e>
80007c36:	36 9b       	mov	r11,105
80007c38:	f6 0a 18 00 	cp.b	r10,r11
80007c3c:	c1 e1       	brne	80007c78 <get_arg+0x17c>
80007c3e:	c0 e8       	rjmp	80007c5a <get_arg+0x15e>
80007c40:	37 5b       	mov	r11,117
80007c42:	f6 0a 18 00 	cp.b	r10,r11
80007c46:	c0 a0       	breq	80007c5a <get_arg+0x15e>
80007c48:	37 8b       	mov	r11,120
80007c4a:	f6 0a 18 00 	cp.b	r10,r11
80007c4e:	c0 60       	breq	80007c5a <get_arg+0x15e>
80007c50:	37 3b       	mov	r11,115
80007c52:	f6 0a 18 00 	cp.b	r10,r11
80007c56:	c1 11       	brne	80007c78 <get_arg+0x17c>
80007c58:	c0 b8       	rjmp	80007c6e <get_arg+0x172>
80007c5a:	ed b4 00 04 	bld	r4,0x4
80007c5e:	c0 a0       	breq	80007c72 <get_arg+0x176>
80007c60:	ed b4 00 05 	bld	r4,0x5
80007c64:	c0 91       	brne	80007c76 <get_arg+0x17a>
80007c66:	30 20       	mov	r0,2
80007c68:	c0 88       	rjmp	80007c78 <get_arg+0x17c>
80007c6a:	30 40       	mov	r0,4
80007c6c:	c0 68       	rjmp	80007c78 <get_arg+0x17c>
80007c6e:	30 30       	mov	r0,3
80007c70:	c0 48       	rjmp	80007c78 <get_arg+0x17c>
80007c72:	30 10       	mov	r0,1
80007c74:	c0 28       	rjmp	80007c78 <get_arg+0x17c>
80007c76:	30 00       	mov	r0,0
80007c78:	40 3b       	lddsp	r11,sp[0xc]
80007c7a:	5b fb       	cp.w	r11,-1
80007c7c:	c0 40       	breq	80007c84 <get_arg+0x188>
80007c7e:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007c82:	c7 08       	rjmp	80007d62 <get_arg+0x266>
80007c84:	58 60       	cp.w	r0,6
80007c86:	e0 8b 00 6e 	brhi	80007d62 <get_arg+0x266>
80007c8a:	6c 0a       	ld.w	r10,r6[0x0]
80007c8c:	ea cc ff ff 	sub	r12,r5,-1
80007c90:	fe ce a2 54 	sub	lr,pc,-23980
80007c94:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007c98:	f4 cb ff f8 	sub	r11,r10,-8
80007c9c:	8d 0b       	st.w	r6[0x0],r11
80007c9e:	f4 ea 00 00 	ld.d	r10,r10[0]
80007ca2:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007ca6:	c0 f8       	rjmp	80007cc4 <get_arg+0x1c8>
80007ca8:	f4 cb ff fc 	sub	r11,r10,-4
80007cac:	8d 0b       	st.w	r6[0x0],r11
80007cae:	74 0a       	ld.w	r10,r10[0x0]
80007cb0:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007cb4:	c0 88       	rjmp	80007cc4 <get_arg+0x1c8>
80007cb6:	f4 cb ff f8 	sub	r11,r10,-8
80007cba:	8d 0b       	st.w	r6[0x0],r11
80007cbc:	f4 ea 00 00 	ld.d	r10,r10[0]
80007cc0:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007cc4:	0e 9b       	mov	r11,r7
80007cc6:	18 95       	mov	r5,r12
80007cc8:	c4 e8       	rjmp	80007d64 <get_arg+0x268>
80007cca:	62 0a       	ld.w	r10,r1[0x0]
80007ccc:	5b fa       	cp.w	r10,-1
80007cce:	c0 b1       	brne	80007ce4 <get_arg+0x1e8>
80007cd0:	50 19       	stdsp	sp[0x4],r9
80007cd2:	50 28       	stdsp	sp[0x8],r8
80007cd4:	e0 6a 00 80 	mov	r10,128
80007cd8:	30 0b       	mov	r11,0
80007cda:	02 9c       	mov	r12,r1
80007cdc:	fe b0 fd 00 	rcall	800076dc <memset>
80007ce0:	40 28       	lddsp	r8,sp[0x8]
80007ce2:	40 19       	lddsp	r9,sp[0x4]
80007ce4:	e4 cc 00 01 	sub	r12,r2,1
80007ce8:	0e 9b       	mov	r11,r7
80007cea:	50 3c       	stdsp	sp[0xc],r12
80007cec:	f2 0c 0c 49 	max	r9,r9,r12
80007cf0:	c3 a8       	rjmp	80007d64 <get_arg+0x268>
80007cf2:	62 0a       	ld.w	r10,r1[0x0]
80007cf4:	5b fa       	cp.w	r10,-1
80007cf6:	c0 b1       	brne	80007d0c <get_arg+0x210>
80007cf8:	50 19       	stdsp	sp[0x4],r9
80007cfa:	50 28       	stdsp	sp[0x8],r8
80007cfc:	e0 6a 00 80 	mov	r10,128
80007d00:	30 0b       	mov	r11,0
80007d02:	02 9c       	mov	r12,r1
80007d04:	fe b0 fc ec 	rcall	800076dc <memset>
80007d08:	40 28       	lddsp	r8,sp[0x8]
80007d0a:	40 19       	lddsp	r9,sp[0x4]
80007d0c:	20 12       	sub	r2,1
80007d0e:	30 0a       	mov	r10,0
80007d10:	0e 9b       	mov	r11,r7
80007d12:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007d16:	f2 02 0c 49 	max	r9,r9,r2
80007d1a:	c2 58       	rjmp	80007d64 <get_arg+0x268>
80007d1c:	16 97       	mov	r7,r11
80007d1e:	6c 0a       	ld.w	r10,r6[0x0]
80007d20:	f4 cb ff fc 	sub	r11,r10,-4
80007d24:	8d 0b       	st.w	r6[0x0],r11
80007d26:	74 0a       	ld.w	r10,r10[0x0]
80007d28:	0e 9b       	mov	r11,r7
80007d2a:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007d2e:	2f f5       	sub	r5,-1
80007d30:	c1 a8       	rjmp	80007d64 <get_arg+0x268>
80007d32:	f4 c2 00 30 	sub	r2,r10,48
80007d36:	c0 68       	rjmp	80007d42 <get_arg+0x246>
80007d38:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007d3c:	2f f7       	sub	r7,-1
80007d3e:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007d42:	0f 8a       	ld.ub	r10,r7[0x0]
80007d44:	58 0a       	cp.w	r10,0
80007d46:	c0 e0       	breq	80007d62 <get_arg+0x266>
80007d48:	23 0a       	sub	r10,48
80007d4a:	58 9a       	cp.w	r10,9
80007d4c:	fe 98 ff f6 	brls	80007d38 <get_arg+0x23c>
80007d50:	c0 98       	rjmp	80007d62 <get_arg+0x266>
80007d52:	2f f7       	sub	r7,-1
80007d54:	0f 8a       	ld.ub	r10,r7[0x0]
80007d56:	58 0a       	cp.w	r10,0
80007d58:	c0 50       	breq	80007d62 <get_arg+0x266>
80007d5a:	23 0a       	sub	r10,48
80007d5c:	58 9a       	cp.w	r10,9
80007d5e:	fe 98 ff fa 	brls	80007d52 <get_arg+0x256>
80007d62:	0e 9b       	mov	r11,r7
80007d64:	40 7c       	lddsp	r12,sp[0x1c]
80007d66:	30 ba       	mov	r10,11
80007d68:	f4 0c 18 00 	cp.b	r12,r10
80007d6c:	fe 91 fe f2 	brne	80007b50 <get_arg+0x54>
80007d70:	40 42       	lddsp	r2,sp[0x10]
80007d72:	17 8c       	ld.ub	r12,r11[0x0]
80007d74:	0a 32       	cp.w	r2,r5
80007d76:	5f 4a       	srge	r10
80007d78:	f0 0c 18 00 	cp.b	r12,r8
80007d7c:	5f 1c       	srne	r12
80007d7e:	f9 ea 00 0a 	and	r10,r12,r10
80007d82:	f0 0a 18 00 	cp.b	r10,r8
80007d86:	fe 91 fe cf 	brne	80007b24 <get_arg+0x28>
80007d8a:	30 08       	mov	r8,0
80007d8c:	40 4e       	lddsp	lr,sp[0x10]
80007d8e:	17 8a       	ld.ub	r10,r11[0x0]
80007d90:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007d94:	f0 0a 18 00 	cp.b	r10,r8
80007d98:	fc 09 17 10 	movne	r9,lr
80007d9c:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007da0:	06 9e       	mov	lr,r3
80007da2:	c2 a8       	rjmp	80007df6 <get_arg+0x2fa>
80007da4:	62 0a       	ld.w	r10,r1[0x0]
80007da6:	58 3a       	cp.w	r10,3
80007da8:	c1 e0       	breq	80007de4 <get_arg+0x2e8>
80007daa:	e0 89 00 07 	brgt	80007db8 <get_arg+0x2bc>
80007dae:	58 1a       	cp.w	r10,1
80007db0:	c1 a0       	breq	80007de4 <get_arg+0x2e8>
80007db2:	58 2a       	cp.w	r10,2
80007db4:	c1 81       	brne	80007de4 <get_arg+0x2e8>
80007db6:	c0 58       	rjmp	80007dc0 <get_arg+0x2c4>
80007db8:	58 5a       	cp.w	r10,5
80007dba:	c0 c0       	breq	80007dd2 <get_arg+0x2d6>
80007dbc:	c0 b5       	brlt	80007dd2 <get_arg+0x2d6>
80007dbe:	c1 38       	rjmp	80007de4 <get_arg+0x2e8>
80007dc0:	6c 0a       	ld.w	r10,r6[0x0]
80007dc2:	f4 cc ff f8 	sub	r12,r10,-8
80007dc6:	8d 0c       	st.w	r6[0x0],r12
80007dc8:	f4 e2 00 00 	ld.d	r2,r10[0]
80007dcc:	f0 e3 00 00 	st.d	r8[0],r2
80007dd0:	c1 08       	rjmp	80007df0 <get_arg+0x2f4>
80007dd2:	6c 0a       	ld.w	r10,r6[0x0]
80007dd4:	f4 cc ff f8 	sub	r12,r10,-8
80007dd8:	8d 0c       	st.w	r6[0x0],r12
80007dda:	f4 e2 00 00 	ld.d	r2,r10[0]
80007dde:	f0 e3 00 00 	st.d	r8[0],r2
80007de2:	c0 78       	rjmp	80007df0 <get_arg+0x2f4>
80007de4:	6c 0a       	ld.w	r10,r6[0x0]
80007de6:	f4 cc ff fc 	sub	r12,r10,-4
80007dea:	8d 0c       	st.w	r6[0x0],r12
80007dec:	74 0a       	ld.w	r10,r10[0x0]
80007dee:	91 0a       	st.w	r8[0x0],r10
80007df0:	2f f5       	sub	r5,-1
80007df2:	2f 88       	sub	r8,-8
80007df4:	2f c1       	sub	r1,-4
80007df6:	12 35       	cp.w	r5,r9
80007df8:	fe 9a ff d6 	brle	80007da4 <get_arg+0x2a8>
80007dfc:	1c 93       	mov	r3,lr
80007dfe:	40 52       	lddsp	r2,sp[0x14]
80007e00:	40 6e       	lddsp	lr,sp[0x18]
80007e02:	85 05       	st.w	r2[0x0],r5
80007e04:	9d 0b       	st.w	lr[0x0],r11
80007e06:	40 4b       	lddsp	r11,sp[0x10]
80007e08:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007e0c:	2f 8d       	sub	sp,-32
80007e0e:	d8 32       	popm	r0-r7,pc

80007e10 <__sprint_r>:
80007e10:	d4 21       	pushm	r4-r7,lr
80007e12:	14 97       	mov	r7,r10
80007e14:	74 28       	ld.w	r8,r10[0x8]
80007e16:	58 08       	cp.w	r8,0
80007e18:	c0 41       	brne	80007e20 <__sprint_r+0x10>
80007e1a:	95 18       	st.w	r10[0x4],r8
80007e1c:	10 9c       	mov	r12,r8
80007e1e:	d8 22       	popm	r4-r7,pc
80007e20:	e0 a0 18 ba 	rcall	8000af94 <__sfvwrite_r>
80007e24:	30 08       	mov	r8,0
80007e26:	8f 18       	st.w	r7[0x4],r8
80007e28:	8f 28       	st.w	r7[0x8],r8
80007e2a:	d8 22       	popm	r4-r7,pc

80007e2c <_vfprintf_r>:
80007e2c:	d4 31       	pushm	r0-r7,lr
80007e2e:	fa cd 06 bc 	sub	sp,sp,1724
80007e32:	51 09       	stdsp	sp[0x40],r9
80007e34:	16 91       	mov	r1,r11
80007e36:	14 97       	mov	r7,r10
80007e38:	18 95       	mov	r5,r12
80007e3a:	e0 a0 1a 1d 	rcall	8000b274 <_localeconv_r>
80007e3e:	78 0c       	ld.w	r12,r12[0x0]
80007e40:	50 cc       	stdsp	sp[0x30],r12
80007e42:	58 05       	cp.w	r5,0
80007e44:	c0 70       	breq	80007e52 <_vfprintf_r+0x26>
80007e46:	6a 68       	ld.w	r8,r5[0x18]
80007e48:	58 08       	cp.w	r8,0
80007e4a:	c0 41       	brne	80007e52 <_vfprintf_r+0x26>
80007e4c:	0a 9c       	mov	r12,r5
80007e4e:	e0 a0 17 43 	rcall	8000acd4 <__sinit>
80007e52:	fe c8 a0 52 	sub	r8,pc,-24494
80007e56:	10 31       	cp.w	r1,r8
80007e58:	c0 31       	brne	80007e5e <_vfprintf_r+0x32>
80007e5a:	6a 01       	ld.w	r1,r5[0x0]
80007e5c:	c0 c8       	rjmp	80007e74 <_vfprintf_r+0x48>
80007e5e:	fe c8 a0 3e 	sub	r8,pc,-24514
80007e62:	10 31       	cp.w	r1,r8
80007e64:	c0 31       	brne	80007e6a <_vfprintf_r+0x3e>
80007e66:	6a 11       	ld.w	r1,r5[0x4]
80007e68:	c0 68       	rjmp	80007e74 <_vfprintf_r+0x48>
80007e6a:	fe c8 a0 2a 	sub	r8,pc,-24534
80007e6e:	10 31       	cp.w	r1,r8
80007e70:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007e74:	82 68       	ld.sh	r8,r1[0xc]
80007e76:	ed b8 00 03 	bld	r8,0x3
80007e7a:	c0 41       	brne	80007e82 <_vfprintf_r+0x56>
80007e7c:	62 48       	ld.w	r8,r1[0x10]
80007e7e:	58 08       	cp.w	r8,0
80007e80:	c0 71       	brne	80007e8e <_vfprintf_r+0x62>
80007e82:	02 9b       	mov	r11,r1
80007e84:	0a 9c       	mov	r12,r5
80007e86:	e0 a0 0f 5d 	rcall	80009d40 <__swsetup_r>
80007e8a:	e0 81 0f 54 	brne	80009d32 <_vfprintf_r+0x1f06>
80007e8e:	82 68       	ld.sh	r8,r1[0xc]
80007e90:	10 99       	mov	r9,r8
80007e92:	e2 19 00 1a 	andl	r9,0x1a,COH
80007e96:	58 a9       	cp.w	r9,10
80007e98:	c3 c1       	brne	80007f10 <_vfprintf_r+0xe4>
80007e9a:	82 79       	ld.sh	r9,r1[0xe]
80007e9c:	30 0a       	mov	r10,0
80007e9e:	f4 09 19 00 	cp.h	r9,r10
80007ea2:	c3 75       	brlt	80007f10 <_vfprintf_r+0xe4>
80007ea4:	a1 d8       	cbr	r8,0x1
80007ea6:	fb 58 05 d0 	st.h	sp[1488],r8
80007eaa:	62 88       	ld.w	r8,r1[0x20]
80007eac:	fb 48 05 e4 	st.w	sp[1508],r8
80007eb0:	62 a8       	ld.w	r8,r1[0x28]
80007eb2:	fb 48 05 ec 	st.w	sp[1516],r8
80007eb6:	fa c8 ff bc 	sub	r8,sp,-68
80007eba:	fb 48 05 d4 	st.w	sp[1492],r8
80007ebe:	fb 48 05 c4 	st.w	sp[1476],r8
80007ec2:	e0 68 04 00 	mov	r8,1024
80007ec6:	fb 48 05 d8 	st.w	sp[1496],r8
80007eca:	fb 48 05 cc 	st.w	sp[1484],r8
80007ece:	30 08       	mov	r8,0
80007ed0:	fb 59 05 d2 	st.h	sp[1490],r9
80007ed4:	0e 9a       	mov	r10,r7
80007ed6:	41 09       	lddsp	r9,sp[0x40]
80007ed8:	fa c7 fa 3c 	sub	r7,sp,-1476
80007edc:	fb 48 05 dc 	st.w	sp[1500],r8
80007ee0:	0a 9c       	mov	r12,r5
80007ee2:	0e 9b       	mov	r11,r7
80007ee4:	ca 4f       	rcall	80007e2c <_vfprintf_r>
80007ee6:	50 bc       	stdsp	sp[0x2c],r12
80007ee8:	c0 95       	brlt	80007efa <_vfprintf_r+0xce>
80007eea:	0e 9b       	mov	r11,r7
80007eec:	0a 9c       	mov	r12,r5
80007eee:	e0 a0 16 1b 	rcall	8000ab24 <_fflush_r>
80007ef2:	40 be       	lddsp	lr,sp[0x2c]
80007ef4:	f9 be 01 ff 	movne	lr,-1
80007ef8:	50 be       	stdsp	sp[0x2c],lr
80007efa:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007efe:	ed b8 00 06 	bld	r8,0x6
80007f02:	e0 81 0f 1a 	brne	80009d36 <_vfprintf_r+0x1f0a>
80007f06:	82 68       	ld.sh	r8,r1[0xc]
80007f08:	a7 a8       	sbr	r8,0x6
80007f0a:	a2 68       	st.h	r1[0xc],r8
80007f0c:	e0 8f 0f 15 	bral	80009d36 <_vfprintf_r+0x1f0a>
80007f10:	30 08       	mov	r8,0
80007f12:	fb 48 06 b4 	st.w	sp[1716],r8
80007f16:	fb 48 06 90 	st.w	sp[1680],r8
80007f1a:	fb 48 06 8c 	st.w	sp[1676],r8
80007f1e:	fb 48 06 b0 	st.w	sp[1712],r8
80007f22:	30 08       	mov	r8,0
80007f24:	30 09       	mov	r9,0
80007f26:	50 a7       	stdsp	sp[0x28],r7
80007f28:	50 78       	stdsp	sp[0x1c],r8
80007f2a:	fa c3 f9 e0 	sub	r3,sp,-1568
80007f2e:	3f f8       	mov	r8,-1
80007f30:	50 59       	stdsp	sp[0x14],r9
80007f32:	fb 43 06 88 	st.w	sp[1672],r3
80007f36:	fb 48 05 44 	st.w	sp[1348],r8
80007f3a:	12 9c       	mov	r12,r9
80007f3c:	50 69       	stdsp	sp[0x18],r9
80007f3e:	50 d9       	stdsp	sp[0x34],r9
80007f40:	50 e9       	stdsp	sp[0x38],r9
80007f42:	50 b9       	stdsp	sp[0x2c],r9
80007f44:	12 97       	mov	r7,r9
80007f46:	0a 94       	mov	r4,r5
80007f48:	40 a2       	lddsp	r2,sp[0x28]
80007f4a:	32 5a       	mov	r10,37
80007f4c:	30 08       	mov	r8,0
80007f4e:	c0 28       	rjmp	80007f52 <_vfprintf_r+0x126>
80007f50:	2f f2       	sub	r2,-1
80007f52:	05 89       	ld.ub	r9,r2[0x0]
80007f54:	f0 09 18 00 	cp.b	r9,r8
80007f58:	5f 1b       	srne	r11
80007f5a:	f4 09 18 00 	cp.b	r9,r10
80007f5e:	5f 19       	srne	r9
80007f60:	f3 eb 00 0b 	and	r11,r9,r11
80007f64:	f0 0b 18 00 	cp.b	r11,r8
80007f68:	cf 41       	brne	80007f50 <_vfprintf_r+0x124>
80007f6a:	40 ab       	lddsp	r11,sp[0x28]
80007f6c:	e4 0b 01 06 	sub	r6,r2,r11
80007f70:	c1 e0       	breq	80007fac <_vfprintf_r+0x180>
80007f72:	fa f8 06 90 	ld.w	r8,sp[1680]
80007f76:	0c 08       	add	r8,r6
80007f78:	87 0b       	st.w	r3[0x0],r11
80007f7a:	fb 48 06 90 	st.w	sp[1680],r8
80007f7e:	87 16       	st.w	r3[0x4],r6
80007f80:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007f84:	2f f8       	sub	r8,-1
80007f86:	fb 48 06 8c 	st.w	sp[1676],r8
80007f8a:	58 78       	cp.w	r8,7
80007f8c:	e0 89 00 04 	brgt	80007f94 <_vfprintf_r+0x168>
80007f90:	2f 83       	sub	r3,-8
80007f92:	c0 a8       	rjmp	80007fa6 <_vfprintf_r+0x17a>
80007f94:	fa ca f9 78 	sub	r10,sp,-1672
80007f98:	02 9b       	mov	r11,r1
80007f9a:	08 9c       	mov	r12,r4
80007f9c:	c3 af       	rcall	80007e10 <__sprint_r>
80007f9e:	e0 81 0e c6 	brne	80009d2a <_vfprintf_r+0x1efe>
80007fa2:	fa c3 f9 e0 	sub	r3,sp,-1568
80007fa6:	40 ba       	lddsp	r10,sp[0x2c]
80007fa8:	0c 0a       	add	r10,r6
80007faa:	50 ba       	stdsp	sp[0x2c],r10
80007fac:	05 89       	ld.ub	r9,r2[0x0]
80007fae:	30 08       	mov	r8,0
80007fb0:	f0 09 18 00 	cp.b	r9,r8
80007fb4:	e0 80 0e aa 	breq	80009d08 <_vfprintf_r+0x1edc>
80007fb8:	30 09       	mov	r9,0
80007fba:	fb 68 06 bb 	st.b	sp[1723],r8
80007fbe:	0e 96       	mov	r6,r7
80007fc0:	e4 c8 ff ff 	sub	r8,r2,-1
80007fc4:	3f fe       	mov	lr,-1
80007fc6:	50 93       	stdsp	sp[0x24],r3
80007fc8:	50 41       	stdsp	sp[0x10],r1
80007fca:	0e 93       	mov	r3,r7
80007fcc:	04 91       	mov	r1,r2
80007fce:	50 89       	stdsp	sp[0x20],r9
80007fd0:	50 a8       	stdsp	sp[0x28],r8
80007fd2:	50 2e       	stdsp	sp[0x8],lr
80007fd4:	50 39       	stdsp	sp[0xc],r9
80007fd6:	12 95       	mov	r5,r9
80007fd8:	12 90       	mov	r0,r9
80007fda:	10 97       	mov	r7,r8
80007fdc:	08 92       	mov	r2,r4
80007fde:	c0 78       	rjmp	80007fec <_vfprintf_r+0x1c0>
80007fe0:	3f fc       	mov	r12,-1
80007fe2:	08 97       	mov	r7,r4
80007fe4:	50 2c       	stdsp	sp[0x8],r12
80007fe6:	c0 38       	rjmp	80007fec <_vfprintf_r+0x1c0>
80007fe8:	30 0b       	mov	r11,0
80007fea:	50 3b       	stdsp	sp[0xc],r11
80007fec:	0f 38       	ld.ub	r8,r7++
80007fee:	c0 28       	rjmp	80007ff2 <_vfprintf_r+0x1c6>
80007ff0:	12 90       	mov	r0,r9
80007ff2:	f0 c9 00 20 	sub	r9,r8,32
80007ff6:	e0 49 00 58 	cp.w	r9,88
80007ffa:	e0 8b 0a 30 	brhi	8000945a <_vfprintf_r+0x162e>
80007ffe:	fe ca a5 a6 	sub	r10,pc,-23130
80008002:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80008006:	50 a7       	stdsp	sp[0x28],r7
80008008:	50 80       	stdsp	sp[0x20],r0
8000800a:	0c 97       	mov	r7,r6
8000800c:	04 94       	mov	r4,r2
8000800e:	06 96       	mov	r6,r3
80008010:	02 92       	mov	r2,r1
80008012:	fe c9 a3 7e 	sub	r9,pc,-23682
80008016:	40 93       	lddsp	r3,sp[0x24]
80008018:	10 90       	mov	r0,r8
8000801a:	40 41       	lddsp	r1,sp[0x10]
8000801c:	50 d9       	stdsp	sp[0x34],r9
8000801e:	e0 8f 08 8e 	bral	8000913a <_vfprintf_r+0x130e>
80008022:	30 08       	mov	r8,0
80008024:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80008028:	f0 09 18 00 	cp.b	r9,r8
8000802c:	ce 01       	brne	80007fec <_vfprintf_r+0x1c0>
8000802e:	32 08       	mov	r8,32
80008030:	c6 e8       	rjmp	8000810c <_vfprintf_r+0x2e0>
80008032:	a1 a5       	sbr	r5,0x0
80008034:	cd cb       	rjmp	80007fec <_vfprintf_r+0x1c0>
80008036:	0f 89       	ld.ub	r9,r7[0x0]
80008038:	f2 c8 00 30 	sub	r8,r9,48
8000803c:	58 98       	cp.w	r8,9
8000803e:	e0 8b 00 1d 	brhi	80008078 <_vfprintf_r+0x24c>
80008042:	ee c8 ff ff 	sub	r8,r7,-1
80008046:	30 0b       	mov	r11,0
80008048:	23 09       	sub	r9,48
8000804a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000804e:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80008052:	11 39       	ld.ub	r9,r8++
80008054:	f2 ca 00 30 	sub	r10,r9,48
80008058:	58 9a       	cp.w	r10,9
8000805a:	fe 98 ff f7 	brls	80008048 <_vfprintf_r+0x21c>
8000805e:	e0 49 00 24 	cp.w	r9,36
80008062:	cc 31       	brne	80007fe8 <_vfprintf_r+0x1bc>
80008064:	e0 4b 00 20 	cp.w	r11,32
80008068:	e0 89 0e 60 	brgt	80009d28 <_vfprintf_r+0x1efc>
8000806c:	20 1b       	sub	r11,1
8000806e:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008072:	12 3b       	cp.w	r11,r9
80008074:	c0 95       	brlt	80008086 <_vfprintf_r+0x25a>
80008076:	c1 08       	rjmp	80008096 <_vfprintf_r+0x26a>
80008078:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000807c:	ec ca ff ff 	sub	r10,r6,-1
80008080:	12 36       	cp.w	r6,r9
80008082:	c1 f5       	brlt	800080c0 <_vfprintf_r+0x294>
80008084:	c2 68       	rjmp	800080d0 <_vfprintf_r+0x2a4>
80008086:	fa ce f9 44 	sub	lr,sp,-1724
8000808a:	10 97       	mov	r7,r8
8000808c:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80008090:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80008094:	c3 58       	rjmp	800080fe <_vfprintf_r+0x2d2>
80008096:	10 97       	mov	r7,r8
80008098:	fa c8 f9 50 	sub	r8,sp,-1712
8000809c:	1a d8       	st.w	--sp,r8
8000809e:	fa c8 fa b8 	sub	r8,sp,-1352
800080a2:	1a d8       	st.w	--sp,r8
800080a4:	fa c8 fb b4 	sub	r8,sp,-1100
800080a8:	02 9a       	mov	r10,r1
800080aa:	1a d8       	st.w	--sp,r8
800080ac:	04 9c       	mov	r12,r2
800080ae:	fa c8 f9 40 	sub	r8,sp,-1728
800080b2:	fa c9 ff b4 	sub	r9,sp,-76
800080b6:	fe b0 fd 23 	rcall	80007afc <get_arg>
800080ba:	2f dd       	sub	sp,-12
800080bc:	78 00       	ld.w	r0,r12[0x0]
800080be:	c2 08       	rjmp	800080fe <_vfprintf_r+0x2d2>
800080c0:	fa cc f9 44 	sub	r12,sp,-1724
800080c4:	14 96       	mov	r6,r10
800080c6:	f8 03 00 38 	add	r8,r12,r3<<0x3
800080ca:	f0 f0 fd 88 	ld.w	r0,r8[-632]
800080ce:	c1 88       	rjmp	800080fe <_vfprintf_r+0x2d2>
800080d0:	41 08       	lddsp	r8,sp[0x40]
800080d2:	59 f9       	cp.w	r9,31
800080d4:	e0 89 00 11 	brgt	800080f6 <_vfprintf_r+0x2ca>
800080d8:	f0 cb ff fc 	sub	r11,r8,-4
800080dc:	51 0b       	stdsp	sp[0x40],r11
800080de:	70 00       	ld.w	r0,r8[0x0]
800080e0:	fa cb f9 44 	sub	r11,sp,-1724
800080e4:	f6 09 00 38 	add	r8,r11,r9<<0x3
800080e8:	f1 40 fd 88 	st.w	r8[-632],r0
800080ec:	2f f9       	sub	r9,-1
800080ee:	14 96       	mov	r6,r10
800080f0:	fb 49 06 b4 	st.w	sp[1716],r9
800080f4:	c0 58       	rjmp	800080fe <_vfprintf_r+0x2d2>
800080f6:	70 00       	ld.w	r0,r8[0x0]
800080f8:	14 96       	mov	r6,r10
800080fa:	2f c8       	sub	r8,-4
800080fc:	51 08       	stdsp	sp[0x40],r8
800080fe:	58 00       	cp.w	r0,0
80008100:	fe 94 ff 76 	brge	80007fec <_vfprintf_r+0x1c0>
80008104:	5c 30       	neg	r0
80008106:	a3 a5       	sbr	r5,0x2
80008108:	c7 2b       	rjmp	80007fec <_vfprintf_r+0x1c0>
8000810a:	32 b8       	mov	r8,43
8000810c:	fb 68 06 bb 	st.b	sp[1723],r8
80008110:	c6 eb       	rjmp	80007fec <_vfprintf_r+0x1c0>
80008112:	0f 38       	ld.ub	r8,r7++
80008114:	e0 48 00 2a 	cp.w	r8,42
80008118:	c0 30       	breq	8000811e <_vfprintf_r+0x2f2>
8000811a:	30 09       	mov	r9,0
8000811c:	c7 98       	rjmp	8000820e <_vfprintf_r+0x3e2>
8000811e:	0f 88       	ld.ub	r8,r7[0x0]
80008120:	f0 c9 00 30 	sub	r9,r8,48
80008124:	58 99       	cp.w	r9,9
80008126:	e0 8b 00 1f 	brhi	80008164 <_vfprintf_r+0x338>
8000812a:	ee c4 ff ff 	sub	r4,r7,-1
8000812e:	30 0b       	mov	r11,0
80008130:	23 08       	sub	r8,48
80008132:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008136:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000813a:	09 38       	ld.ub	r8,r4++
8000813c:	f0 c9 00 30 	sub	r9,r8,48
80008140:	58 99       	cp.w	r9,9
80008142:	fe 98 ff f7 	brls	80008130 <_vfprintf_r+0x304>
80008146:	e0 48 00 24 	cp.w	r8,36
8000814a:	fe 91 ff 4f 	brne	80007fe8 <_vfprintf_r+0x1bc>
8000814e:	e0 4b 00 20 	cp.w	r11,32
80008152:	e0 89 0d eb 	brgt	80009d28 <_vfprintf_r+0x1efc>
80008156:	20 1b       	sub	r11,1
80008158:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000815c:	10 3b       	cp.w	r11,r8
8000815e:	c0 a5       	brlt	80008172 <_vfprintf_r+0x346>
80008160:	c1 18       	rjmp	80008182 <_vfprintf_r+0x356>
80008162:	d7 03       	nop
80008164:	fa fa 06 b4 	ld.w	r10,sp[1716]
80008168:	ec c9 ff ff 	sub	r9,r6,-1
8000816c:	14 36       	cp.w	r6,r10
8000816e:	c1 f5       	brlt	800081ac <_vfprintf_r+0x380>
80008170:	c2 88       	rjmp	800081c0 <_vfprintf_r+0x394>
80008172:	fa ca f9 44 	sub	r10,sp,-1724
80008176:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000817a:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000817e:	50 2b       	stdsp	sp[0x8],r11
80008180:	c3 c8       	rjmp	800081f8 <_vfprintf_r+0x3cc>
80008182:	fa c8 f9 50 	sub	r8,sp,-1712
80008186:	1a d8       	st.w	--sp,r8
80008188:	fa c8 fa b8 	sub	r8,sp,-1352
8000818c:	1a d8       	st.w	--sp,r8
8000818e:	fa c8 fb b4 	sub	r8,sp,-1100
80008192:	02 9a       	mov	r10,r1
80008194:	1a d8       	st.w	--sp,r8
80008196:	04 9c       	mov	r12,r2
80008198:	fa c8 f9 40 	sub	r8,sp,-1728
8000819c:	fa c9 ff b4 	sub	r9,sp,-76
800081a0:	fe b0 fc ae 	rcall	80007afc <get_arg>
800081a4:	2f dd       	sub	sp,-12
800081a6:	78 0c       	ld.w	r12,r12[0x0]
800081a8:	50 2c       	stdsp	sp[0x8],r12
800081aa:	c2 78       	rjmp	800081f8 <_vfprintf_r+0x3cc>
800081ac:	12 96       	mov	r6,r9
800081ae:	0e 94       	mov	r4,r7
800081b0:	fa c9 f9 44 	sub	r9,sp,-1724
800081b4:	f2 03 00 38 	add	r8,r9,r3<<0x3
800081b8:	f0 f8 fd 88 	ld.w	r8,r8[-632]
800081bc:	50 28       	stdsp	sp[0x8],r8
800081be:	c1 d8       	rjmp	800081f8 <_vfprintf_r+0x3cc>
800081c0:	41 08       	lddsp	r8,sp[0x40]
800081c2:	59 fa       	cp.w	r10,31
800081c4:	e0 89 00 14 	brgt	800081ec <_vfprintf_r+0x3c0>
800081c8:	f0 cb ff fc 	sub	r11,r8,-4
800081cc:	70 08       	ld.w	r8,r8[0x0]
800081ce:	51 0b       	stdsp	sp[0x40],r11
800081d0:	50 28       	stdsp	sp[0x8],r8
800081d2:	fa c6 f9 44 	sub	r6,sp,-1724
800081d6:	40 2e       	lddsp	lr,sp[0x8]
800081d8:	ec 0a 00 38 	add	r8,r6,r10<<0x3
800081dc:	f1 4e fd 88 	st.w	r8[-632],lr
800081e0:	2f fa       	sub	r10,-1
800081e2:	0e 94       	mov	r4,r7
800081e4:	fb 4a 06 b4 	st.w	sp[1716],r10
800081e8:	12 96       	mov	r6,r9
800081ea:	c0 78       	rjmp	800081f8 <_vfprintf_r+0x3cc>
800081ec:	70 0c       	ld.w	r12,r8[0x0]
800081ee:	0e 94       	mov	r4,r7
800081f0:	2f c8       	sub	r8,-4
800081f2:	50 2c       	stdsp	sp[0x8],r12
800081f4:	12 96       	mov	r6,r9
800081f6:	51 08       	stdsp	sp[0x40],r8
800081f8:	40 2b       	lddsp	r11,sp[0x8]
800081fa:	58 0b       	cp.w	r11,0
800081fc:	fe 95 fe f2 	brlt	80007fe0 <_vfprintf_r+0x1b4>
80008200:	08 97       	mov	r7,r4
80008202:	cf 5a       	rjmp	80007fec <_vfprintf_r+0x1c0>
80008204:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008208:	0f 38       	ld.ub	r8,r7++
8000820a:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000820e:	f0 ca 00 30 	sub	r10,r8,48
80008212:	58 9a       	cp.w	r10,9
80008214:	fe 98 ff f8 	brls	80008204 <_vfprintf_r+0x3d8>
80008218:	3f fa       	mov	r10,-1
8000821a:	f2 0a 0c 49 	max	r9,r9,r10
8000821e:	50 29       	stdsp	sp[0x8],r9
80008220:	ce 9a       	rjmp	80007ff2 <_vfprintf_r+0x1c6>
80008222:	a7 b5       	sbr	r5,0x7
80008224:	ce 4a       	rjmp	80007fec <_vfprintf_r+0x1c0>
80008226:	30 09       	mov	r9,0
80008228:	23 08       	sub	r8,48
8000822a:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000822e:	f0 09 00 19 	add	r9,r8,r9<<0x1
80008232:	0f 38       	ld.ub	r8,r7++
80008234:	f0 ca 00 30 	sub	r10,r8,48
80008238:	58 9a       	cp.w	r10,9
8000823a:	fe 98 ff f7 	brls	80008228 <_vfprintf_r+0x3fc>
8000823e:	e0 48 00 24 	cp.w	r8,36
80008242:	fe 91 fe d7 	brne	80007ff0 <_vfprintf_r+0x1c4>
80008246:	e0 49 00 20 	cp.w	r9,32
8000824a:	e0 89 0d 6f 	brgt	80009d28 <_vfprintf_r+0x1efc>
8000824e:	f2 c3 00 01 	sub	r3,r9,1
80008252:	30 19       	mov	r9,1
80008254:	50 39       	stdsp	sp[0xc],r9
80008256:	cc ba       	rjmp	80007fec <_vfprintf_r+0x1c0>
80008258:	a3 b5       	sbr	r5,0x3
8000825a:	cc 9a       	rjmp	80007fec <_vfprintf_r+0x1c0>
8000825c:	a7 a5       	sbr	r5,0x6
8000825e:	cc 7a       	rjmp	80007fec <_vfprintf_r+0x1c0>
80008260:	0a 98       	mov	r8,r5
80008262:	a5 b5       	sbr	r5,0x5
80008264:	a5 a8       	sbr	r8,0x4
80008266:	0f 89       	ld.ub	r9,r7[0x0]
80008268:	36 ce       	mov	lr,108
8000826a:	fc 09 18 00 	cp.b	r9,lr
8000826e:	f7 b7 00 ff 	subeq	r7,-1
80008272:	f0 05 17 10 	movne	r5,r8
80008276:	cb ba       	rjmp	80007fec <_vfprintf_r+0x1c0>
80008278:	a5 b5       	sbr	r5,0x5
8000827a:	cb 9a       	rjmp	80007fec <_vfprintf_r+0x1c0>
8000827c:	50 a7       	stdsp	sp[0x28],r7
8000827e:	50 80       	stdsp	sp[0x20],r0
80008280:	0c 97       	mov	r7,r6
80008282:	10 90       	mov	r0,r8
80008284:	06 96       	mov	r6,r3
80008286:	04 94       	mov	r4,r2
80008288:	40 93       	lddsp	r3,sp[0x24]
8000828a:	02 92       	mov	r2,r1
8000828c:	0e 99       	mov	r9,r7
8000828e:	40 41       	lddsp	r1,sp[0x10]
80008290:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008294:	40 3c       	lddsp	r12,sp[0xc]
80008296:	58 0c       	cp.w	r12,0
80008298:	c1 d0       	breq	800082d2 <_vfprintf_r+0x4a6>
8000829a:	10 36       	cp.w	r6,r8
8000829c:	c0 64       	brge	800082a8 <_vfprintf_r+0x47c>
8000829e:	fa cb f9 44 	sub	r11,sp,-1724
800082a2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800082a6:	c1 d8       	rjmp	800082e0 <_vfprintf_r+0x4b4>
800082a8:	fa c8 f9 50 	sub	r8,sp,-1712
800082ac:	1a d8       	st.w	--sp,r8
800082ae:	fa c8 fa b8 	sub	r8,sp,-1352
800082b2:	1a d8       	st.w	--sp,r8
800082b4:	fa c8 fb b4 	sub	r8,sp,-1100
800082b8:	1a d8       	st.w	--sp,r8
800082ba:	fa c8 f9 40 	sub	r8,sp,-1728
800082be:	fa c9 ff b4 	sub	r9,sp,-76
800082c2:	04 9a       	mov	r10,r2
800082c4:	0c 9b       	mov	r11,r6
800082c6:	08 9c       	mov	r12,r4
800082c8:	fe b0 fc 1a 	rcall	80007afc <get_arg>
800082cc:	2f dd       	sub	sp,-12
800082ce:	19 b8       	ld.ub	r8,r12[0x3]
800082d0:	c2 28       	rjmp	80008314 <_vfprintf_r+0x4e8>
800082d2:	2f f7       	sub	r7,-1
800082d4:	10 39       	cp.w	r9,r8
800082d6:	c0 84       	brge	800082e6 <_vfprintf_r+0x4ba>
800082d8:	fa ca f9 44 	sub	r10,sp,-1724
800082dc:	f4 06 00 36 	add	r6,r10,r6<<0x3
800082e0:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
800082e4:	c1 88       	rjmp	80008314 <_vfprintf_r+0x4e8>
800082e6:	41 09       	lddsp	r9,sp[0x40]
800082e8:	59 f8       	cp.w	r8,31
800082ea:	e0 89 00 12 	brgt	8000830e <_vfprintf_r+0x4e2>
800082ee:	f2 ca ff fc 	sub	r10,r9,-4
800082f2:	51 0a       	stdsp	sp[0x40],r10
800082f4:	72 09       	ld.w	r9,r9[0x0]
800082f6:	fa c6 f9 44 	sub	r6,sp,-1724
800082fa:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800082fe:	2f f8       	sub	r8,-1
80008300:	f5 49 fd 88 	st.w	r10[-632],r9
80008304:	fb 48 06 b4 	st.w	sp[1716],r8
80008308:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000830c:	c0 48       	rjmp	80008314 <_vfprintf_r+0x4e8>
8000830e:	13 b8       	ld.ub	r8,r9[0x3]
80008310:	2f c9       	sub	r9,-4
80008312:	51 09       	stdsp	sp[0x40],r9
80008314:	fb 68 06 60 	st.b	sp[1632],r8
80008318:	30 0e       	mov	lr,0
8000831a:	30 08       	mov	r8,0
8000831c:	30 12       	mov	r2,1
8000831e:	fb 68 06 bb 	st.b	sp[1723],r8
80008322:	50 2e       	stdsp	sp[0x8],lr
80008324:	e0 8f 08 ad 	bral	8000947e <_vfprintf_r+0x1652>
80008328:	50 a7       	stdsp	sp[0x28],r7
8000832a:	50 80       	stdsp	sp[0x20],r0
8000832c:	0c 97       	mov	r7,r6
8000832e:	04 94       	mov	r4,r2
80008330:	06 96       	mov	r6,r3
80008332:	02 92       	mov	r2,r1
80008334:	40 93       	lddsp	r3,sp[0x24]
80008336:	10 90       	mov	r0,r8
80008338:	40 41       	lddsp	r1,sp[0x10]
8000833a:	a5 a5       	sbr	r5,0x4
8000833c:	c0 a8       	rjmp	80008350 <_vfprintf_r+0x524>
8000833e:	50 a7       	stdsp	sp[0x28],r7
80008340:	50 80       	stdsp	sp[0x20],r0
80008342:	0c 97       	mov	r7,r6
80008344:	04 94       	mov	r4,r2
80008346:	06 96       	mov	r6,r3
80008348:	02 92       	mov	r2,r1
8000834a:	40 93       	lddsp	r3,sp[0x24]
8000834c:	10 90       	mov	r0,r8
8000834e:	40 41       	lddsp	r1,sp[0x10]
80008350:	ed b5 00 05 	bld	r5,0x5
80008354:	c5 11       	brne	800083f6 <_vfprintf_r+0x5ca>
80008356:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000835a:	40 3c       	lddsp	r12,sp[0xc]
8000835c:	58 0c       	cp.w	r12,0
8000835e:	c1 e0       	breq	8000839a <_vfprintf_r+0x56e>
80008360:	10 36       	cp.w	r6,r8
80008362:	c0 64       	brge	8000836e <_vfprintf_r+0x542>
80008364:	fa cb f9 44 	sub	r11,sp,-1724
80008368:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000836c:	c2 08       	rjmp	800083ac <_vfprintf_r+0x580>
8000836e:	fa c8 f9 50 	sub	r8,sp,-1712
80008372:	1a d8       	st.w	--sp,r8
80008374:	fa c8 fa b8 	sub	r8,sp,-1352
80008378:	0c 9b       	mov	r11,r6
8000837a:	1a d8       	st.w	--sp,r8
8000837c:	fa c8 fb b4 	sub	r8,sp,-1100
80008380:	1a d8       	st.w	--sp,r8
80008382:	fa c9 ff b4 	sub	r9,sp,-76
80008386:	fa c8 f9 40 	sub	r8,sp,-1728
8000838a:	04 9a       	mov	r10,r2
8000838c:	08 9c       	mov	r12,r4
8000838e:	fe b0 fb b7 	rcall	80007afc <get_arg>
80008392:	2f dd       	sub	sp,-12
80008394:	78 1b       	ld.w	r11,r12[0x4]
80008396:	78 09       	ld.w	r9,r12[0x0]
80008398:	c2 b8       	rjmp	800083ee <_vfprintf_r+0x5c2>
8000839a:	ee ca ff ff 	sub	r10,r7,-1
8000839e:	10 37       	cp.w	r7,r8
800083a0:	c0 b4       	brge	800083b6 <_vfprintf_r+0x58a>
800083a2:	fa c9 f9 44 	sub	r9,sp,-1724
800083a6:	14 97       	mov	r7,r10
800083a8:	f2 06 00 36 	add	r6,r9,r6<<0x3
800083ac:	ec fb fd 8c 	ld.w	r11,r6[-628]
800083b0:	ec f9 fd 88 	ld.w	r9,r6[-632]
800083b4:	c1 d8       	rjmp	800083ee <_vfprintf_r+0x5c2>
800083b6:	41 09       	lddsp	r9,sp[0x40]
800083b8:	59 f8       	cp.w	r8,31
800083ba:	e0 89 00 14 	brgt	800083e2 <_vfprintf_r+0x5b6>
800083be:	f2 cb ff f8 	sub	r11,r9,-8
800083c2:	51 0b       	stdsp	sp[0x40],r11
800083c4:	fa c6 f9 44 	sub	r6,sp,-1724
800083c8:	72 1b       	ld.w	r11,r9[0x4]
800083ca:	ec 08 00 3c 	add	r12,r6,r8<<0x3
800083ce:	72 09       	ld.w	r9,r9[0x0]
800083d0:	f9 4b fd 8c 	st.w	r12[-628],r11
800083d4:	f9 49 fd 88 	st.w	r12[-632],r9
800083d8:	2f f8       	sub	r8,-1
800083da:	14 97       	mov	r7,r10
800083dc:	fb 48 06 b4 	st.w	sp[1716],r8
800083e0:	c0 78       	rjmp	800083ee <_vfprintf_r+0x5c2>
800083e2:	f2 c8 ff f8 	sub	r8,r9,-8
800083e6:	72 1b       	ld.w	r11,r9[0x4]
800083e8:	14 97       	mov	r7,r10
800083ea:	51 08       	stdsp	sp[0x40],r8
800083ec:	72 09       	ld.w	r9,r9[0x0]
800083ee:	16 98       	mov	r8,r11
800083f0:	fa e9 00 00 	st.d	sp[0],r8
800083f4:	ca e8       	rjmp	80008550 <_vfprintf_r+0x724>
800083f6:	ed b5 00 04 	bld	r5,0x4
800083fa:	c1 71       	brne	80008428 <_vfprintf_r+0x5fc>
800083fc:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008400:	40 3e       	lddsp	lr,sp[0xc]
80008402:	58 0e       	cp.w	lr,0
80008404:	c0 80       	breq	80008414 <_vfprintf_r+0x5e8>
80008406:	10 36       	cp.w	r6,r8
80008408:	c6 94       	brge	800084da <_vfprintf_r+0x6ae>
8000840a:	fa cc f9 44 	sub	r12,sp,-1724
8000840e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008412:	c8 28       	rjmp	80008516 <_vfprintf_r+0x6ea>
80008414:	ee ca ff ff 	sub	r10,r7,-1
80008418:	10 37       	cp.w	r7,r8
8000841a:	e0 84 00 81 	brge	8000851c <_vfprintf_r+0x6f0>
8000841e:	fa cb f9 44 	sub	r11,sp,-1724
80008422:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008426:	c7 78       	rjmp	80008514 <_vfprintf_r+0x6e8>
80008428:	ed b5 00 06 	bld	r5,0x6
8000842c:	c4 b1       	brne	800084c2 <_vfprintf_r+0x696>
8000842e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008432:	40 3c       	lddsp	r12,sp[0xc]
80008434:	58 0c       	cp.w	r12,0
80008436:	c1 d0       	breq	80008470 <_vfprintf_r+0x644>
80008438:	10 36       	cp.w	r6,r8
8000843a:	c0 64       	brge	80008446 <_vfprintf_r+0x61a>
8000843c:	fa cb f9 44 	sub	r11,sp,-1724
80008440:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008444:	c1 f8       	rjmp	80008482 <_vfprintf_r+0x656>
80008446:	fa c8 f9 50 	sub	r8,sp,-1712
8000844a:	1a d8       	st.w	--sp,r8
8000844c:	fa c8 fa b8 	sub	r8,sp,-1352
80008450:	1a d8       	st.w	--sp,r8
80008452:	fa c8 fb b4 	sub	r8,sp,-1100
80008456:	1a d8       	st.w	--sp,r8
80008458:	fa c8 f9 40 	sub	r8,sp,-1728
8000845c:	fa c9 ff b4 	sub	r9,sp,-76
80008460:	04 9a       	mov	r10,r2
80008462:	0c 9b       	mov	r11,r6
80008464:	08 9c       	mov	r12,r4
80008466:	fe b0 fb 4b 	rcall	80007afc <get_arg>
8000846a:	2f dd       	sub	sp,-12
8000846c:	98 18       	ld.sh	r8,r12[0x2]
8000846e:	c2 68       	rjmp	800084ba <_vfprintf_r+0x68e>
80008470:	ee ca ff ff 	sub	r10,r7,-1
80008474:	10 37       	cp.w	r7,r8
80008476:	c0 94       	brge	80008488 <_vfprintf_r+0x65c>
80008478:	fa c9 f9 44 	sub	r9,sp,-1724
8000847c:	14 97       	mov	r7,r10
8000847e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008482:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008486:	c1 a8       	rjmp	800084ba <_vfprintf_r+0x68e>
80008488:	41 09       	lddsp	r9,sp[0x40]
8000848a:	59 f8       	cp.w	r8,31
8000848c:	e0 89 00 13 	brgt	800084b2 <_vfprintf_r+0x686>
80008490:	f2 cb ff fc 	sub	r11,r9,-4
80008494:	51 0b       	stdsp	sp[0x40],r11
80008496:	72 09       	ld.w	r9,r9[0x0]
80008498:	fa c6 f9 44 	sub	r6,sp,-1724
8000849c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800084a0:	2f f8       	sub	r8,-1
800084a2:	f7 49 fd 88 	st.w	r11[-632],r9
800084a6:	fb 48 06 b4 	st.w	sp[1716],r8
800084aa:	14 97       	mov	r7,r10
800084ac:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800084b0:	c0 58       	rjmp	800084ba <_vfprintf_r+0x68e>
800084b2:	92 18       	ld.sh	r8,r9[0x2]
800084b4:	14 97       	mov	r7,r10
800084b6:	2f c9       	sub	r9,-4
800084b8:	51 09       	stdsp	sp[0x40],r9
800084ba:	50 18       	stdsp	sp[0x4],r8
800084bc:	bf 58       	asr	r8,0x1f
800084be:	50 08       	stdsp	sp[0x0],r8
800084c0:	c4 88       	rjmp	80008550 <_vfprintf_r+0x724>
800084c2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084c6:	40 3c       	lddsp	r12,sp[0xc]
800084c8:	58 0c       	cp.w	r12,0
800084ca:	c1 d0       	breq	80008504 <_vfprintf_r+0x6d8>
800084cc:	10 36       	cp.w	r6,r8
800084ce:	c0 64       	brge	800084da <_vfprintf_r+0x6ae>
800084d0:	fa cb f9 44 	sub	r11,sp,-1724
800084d4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800084d8:	c1 f8       	rjmp	80008516 <_vfprintf_r+0x6ea>
800084da:	fa c8 f9 50 	sub	r8,sp,-1712
800084de:	1a d8       	st.w	--sp,r8
800084e0:	fa c8 fa b8 	sub	r8,sp,-1352
800084e4:	0c 9b       	mov	r11,r6
800084e6:	1a d8       	st.w	--sp,r8
800084e8:	fa c8 fb b4 	sub	r8,sp,-1100
800084ec:	04 9a       	mov	r10,r2
800084ee:	1a d8       	st.w	--sp,r8
800084f0:	08 9c       	mov	r12,r4
800084f2:	fa c8 f9 40 	sub	r8,sp,-1728
800084f6:	fa c9 ff b4 	sub	r9,sp,-76
800084fa:	fe b0 fb 01 	rcall	80007afc <get_arg>
800084fe:	2f dd       	sub	sp,-12
80008500:	78 0b       	ld.w	r11,r12[0x0]
80008502:	c2 48       	rjmp	8000854a <_vfprintf_r+0x71e>
80008504:	ee ca ff ff 	sub	r10,r7,-1
80008508:	10 37       	cp.w	r7,r8
8000850a:	c0 94       	brge	8000851c <_vfprintf_r+0x6f0>
8000850c:	fa c9 f9 44 	sub	r9,sp,-1724
80008510:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008514:	14 97       	mov	r7,r10
80008516:	ec fb fd 88 	ld.w	r11,r6[-632]
8000851a:	c1 88       	rjmp	8000854a <_vfprintf_r+0x71e>
8000851c:	41 09       	lddsp	r9,sp[0x40]
8000851e:	59 f8       	cp.w	r8,31
80008520:	e0 89 00 11 	brgt	80008542 <_vfprintf_r+0x716>
80008524:	f2 cb ff fc 	sub	r11,r9,-4
80008528:	51 0b       	stdsp	sp[0x40],r11
8000852a:	fa c6 f9 44 	sub	r6,sp,-1724
8000852e:	72 0b       	ld.w	r11,r9[0x0]
80008530:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008534:	f3 4b fd 88 	st.w	r9[-632],r11
80008538:	2f f8       	sub	r8,-1
8000853a:	14 97       	mov	r7,r10
8000853c:	fb 48 06 b4 	st.w	sp[1716],r8
80008540:	c0 58       	rjmp	8000854a <_vfprintf_r+0x71e>
80008542:	72 0b       	ld.w	r11,r9[0x0]
80008544:	14 97       	mov	r7,r10
80008546:	2f c9       	sub	r9,-4
80008548:	51 09       	stdsp	sp[0x40],r9
8000854a:	50 1b       	stdsp	sp[0x4],r11
8000854c:	bf 5b       	asr	r11,0x1f
8000854e:	50 0b       	stdsp	sp[0x0],r11
80008550:	fa ea 00 00 	ld.d	r10,sp[0]
80008554:	58 0a       	cp.w	r10,0
80008556:	5c 2b       	cpc	r11
80008558:	c0 e4       	brge	80008574 <_vfprintf_r+0x748>
8000855a:	30 08       	mov	r8,0
8000855c:	fa ea 00 00 	ld.d	r10,sp[0]
80008560:	30 09       	mov	r9,0
80008562:	f0 0a 01 0a 	sub	r10,r8,r10
80008566:	f2 0b 01 4b 	sbc	r11,r9,r11
8000856a:	32 d8       	mov	r8,45
8000856c:	fa eb 00 00 	st.d	sp[0],r10
80008570:	fb 68 06 bb 	st.b	sp[1723],r8
80008574:	30 18       	mov	r8,1
80008576:	e0 8f 06 fa 	bral	8000936a <_vfprintf_r+0x153e>
8000857a:	50 a7       	stdsp	sp[0x28],r7
8000857c:	50 80       	stdsp	sp[0x20],r0
8000857e:	0c 97       	mov	r7,r6
80008580:	04 94       	mov	r4,r2
80008582:	06 96       	mov	r6,r3
80008584:	02 92       	mov	r2,r1
80008586:	40 93       	lddsp	r3,sp[0x24]
80008588:	10 90       	mov	r0,r8
8000858a:	40 41       	lddsp	r1,sp[0x10]
8000858c:	0e 99       	mov	r9,r7
8000858e:	ed b5 00 03 	bld	r5,0x3
80008592:	c4 11       	brne	80008614 <_vfprintf_r+0x7e8>
80008594:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008598:	40 3a       	lddsp	r10,sp[0xc]
8000859a:	58 0a       	cp.w	r10,0
8000859c:	c1 90       	breq	800085ce <_vfprintf_r+0x7a2>
8000859e:	10 36       	cp.w	r6,r8
800085a0:	c6 45       	brlt	80008668 <_vfprintf_r+0x83c>
800085a2:	fa c8 f9 50 	sub	r8,sp,-1712
800085a6:	1a d8       	st.w	--sp,r8
800085a8:	fa c8 fa b8 	sub	r8,sp,-1352
800085ac:	1a d8       	st.w	--sp,r8
800085ae:	fa c8 fb b4 	sub	r8,sp,-1100
800085b2:	0c 9b       	mov	r11,r6
800085b4:	1a d8       	st.w	--sp,r8
800085b6:	04 9a       	mov	r10,r2
800085b8:	fa c8 f9 40 	sub	r8,sp,-1728
800085bc:	fa c9 ff b4 	sub	r9,sp,-76
800085c0:	08 9c       	mov	r12,r4
800085c2:	fe b0 fa 9d 	rcall	80007afc <get_arg>
800085c6:	2f dd       	sub	sp,-12
800085c8:	78 16       	ld.w	r6,r12[0x4]
800085ca:	50 76       	stdsp	sp[0x1c],r6
800085cc:	c4 88       	rjmp	8000865c <_vfprintf_r+0x830>
800085ce:	2f f7       	sub	r7,-1
800085d0:	10 39       	cp.w	r9,r8
800085d2:	c0 c4       	brge	800085ea <_vfprintf_r+0x7be>
800085d4:	fa ce f9 44 	sub	lr,sp,-1724
800085d8:	fc 06 00 36 	add	r6,lr,r6<<0x3
800085dc:	ec fc fd 8c 	ld.w	r12,r6[-628]
800085e0:	50 7c       	stdsp	sp[0x1c],r12
800085e2:	ec f6 fd 88 	ld.w	r6,r6[-632]
800085e6:	50 56       	stdsp	sp[0x14],r6
800085e8:	c6 68       	rjmp	800086b4 <_vfprintf_r+0x888>
800085ea:	41 09       	lddsp	r9,sp[0x40]
800085ec:	59 f8       	cp.w	r8,31
800085ee:	e0 89 00 10 	brgt	8000860e <_vfprintf_r+0x7e2>
800085f2:	f2 ca ff f8 	sub	r10,r9,-8
800085f6:	72 1b       	ld.w	r11,r9[0x4]
800085f8:	51 0a       	stdsp	sp[0x40],r10
800085fa:	72 09       	ld.w	r9,r9[0x0]
800085fc:	fa ca f9 44 	sub	r10,sp,-1724
80008600:	50 7b       	stdsp	sp[0x1c],r11
80008602:	50 59       	stdsp	sp[0x14],r9
80008604:	f4 08 00 39 	add	r9,r10,r8<<0x3
80008608:	40 5b       	lddsp	r11,sp[0x14]
8000860a:	40 7a       	lddsp	r10,sp[0x1c]
8000860c:	c4 78       	rjmp	8000869a <_vfprintf_r+0x86e>
8000860e:	72 18       	ld.w	r8,r9[0x4]
80008610:	50 78       	stdsp	sp[0x1c],r8
80008612:	c4 c8       	rjmp	800086aa <_vfprintf_r+0x87e>
80008614:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008618:	40 3e       	lddsp	lr,sp[0xc]
8000861a:	58 0e       	cp.w	lr,0
8000861c:	c2 30       	breq	80008662 <_vfprintf_r+0x836>
8000861e:	10 36       	cp.w	r6,r8
80008620:	c0 94       	brge	80008632 <_vfprintf_r+0x806>
80008622:	fa cc f9 44 	sub	r12,sp,-1724
80008626:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000862a:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000862e:	50 7b       	stdsp	sp[0x1c],r11
80008630:	cd 9b       	rjmp	800085e2 <_vfprintf_r+0x7b6>
80008632:	fa c8 f9 50 	sub	r8,sp,-1712
80008636:	1a d8       	st.w	--sp,r8
80008638:	fa c8 fa b8 	sub	r8,sp,-1352
8000863c:	04 9a       	mov	r10,r2
8000863e:	1a d8       	st.w	--sp,r8
80008640:	fa c8 fb b4 	sub	r8,sp,-1100
80008644:	0c 9b       	mov	r11,r6
80008646:	1a d8       	st.w	--sp,r8
80008648:	08 9c       	mov	r12,r4
8000864a:	fa c8 f9 40 	sub	r8,sp,-1728
8000864e:	fa c9 ff b4 	sub	r9,sp,-76
80008652:	fe b0 fa 55 	rcall	80007afc <get_arg>
80008656:	2f dd       	sub	sp,-12
80008658:	78 1a       	ld.w	r10,r12[0x4]
8000865a:	50 7a       	stdsp	sp[0x1c],r10
8000865c:	78 0c       	ld.w	r12,r12[0x0]
8000865e:	50 5c       	stdsp	sp[0x14],r12
80008660:	c2 a8       	rjmp	800086b4 <_vfprintf_r+0x888>
80008662:	2f f7       	sub	r7,-1
80008664:	10 39       	cp.w	r9,r8
80008666:	c0 94       	brge	80008678 <_vfprintf_r+0x84c>
80008668:	fa c9 f9 44 	sub	r9,sp,-1724
8000866c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008670:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80008674:	50 78       	stdsp	sp[0x1c],r8
80008676:	cb 6b       	rjmp	800085e2 <_vfprintf_r+0x7b6>
80008678:	41 09       	lddsp	r9,sp[0x40]
8000867a:	59 f8       	cp.w	r8,31
8000867c:	e0 89 00 15 	brgt	800086a6 <_vfprintf_r+0x87a>
80008680:	f2 ca ff f8 	sub	r10,r9,-8
80008684:	72 16       	ld.w	r6,r9[0x4]
80008686:	72 09       	ld.w	r9,r9[0x0]
80008688:	51 0a       	stdsp	sp[0x40],r10
8000868a:	50 59       	stdsp	sp[0x14],r9
8000868c:	fa ce f9 44 	sub	lr,sp,-1724
80008690:	50 76       	stdsp	sp[0x1c],r6
80008692:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008696:	40 5b       	lddsp	r11,sp[0x14]
80008698:	0c 9a       	mov	r10,r6
8000869a:	f2 eb fd 88 	st.d	r9[-632],r10
8000869e:	2f f8       	sub	r8,-1
800086a0:	fb 48 06 b4 	st.w	sp[1716],r8
800086a4:	c0 88       	rjmp	800086b4 <_vfprintf_r+0x888>
800086a6:	72 1c       	ld.w	r12,r9[0x4]
800086a8:	50 7c       	stdsp	sp[0x1c],r12
800086aa:	f2 c8 ff f8 	sub	r8,r9,-8
800086ae:	51 08       	stdsp	sp[0x40],r8
800086b0:	72 09       	ld.w	r9,r9[0x0]
800086b2:	50 59       	stdsp	sp[0x14],r9
800086b4:	40 5b       	lddsp	r11,sp[0x14]
800086b6:	40 7a       	lddsp	r10,sp[0x1c]
800086b8:	e0 a0 19 54 	rcall	8000b960 <__isinfd>
800086bc:	18 96       	mov	r6,r12
800086be:	c1 70       	breq	800086ec <_vfprintf_r+0x8c0>
800086c0:	30 08       	mov	r8,0
800086c2:	30 09       	mov	r9,0
800086c4:	40 5b       	lddsp	r11,sp[0x14]
800086c6:	40 7a       	lddsp	r10,sp[0x1c]
800086c8:	e0 a0 1d b4 	rcall	8000c230 <__avr32_f64_cmp_lt>
800086cc:	c0 40       	breq	800086d4 <_vfprintf_r+0x8a8>
800086ce:	32 d8       	mov	r8,45
800086d0:	fb 68 06 bb 	st.b	sp[1723],r8
800086d4:	fe c8 aa 2c 	sub	r8,pc,-21972
800086d8:	fe c6 aa 2c 	sub	r6,pc,-21972
800086dc:	a7 d5       	cbr	r5,0x7
800086de:	e0 40 00 47 	cp.w	r0,71
800086e2:	f0 06 17 a0 	movle	r6,r8
800086e6:	30 32       	mov	r2,3
800086e8:	e0 8f 06 ce 	bral	80009484 <_vfprintf_r+0x1658>
800086ec:	40 5b       	lddsp	r11,sp[0x14]
800086ee:	40 7a       	lddsp	r10,sp[0x1c]
800086f0:	e0 a0 19 4d 	rcall	8000b98a <__isnand>
800086f4:	c0 e0       	breq	80008710 <_vfprintf_r+0x8e4>
800086f6:	50 26       	stdsp	sp[0x8],r6
800086f8:	fe c8 aa 48 	sub	r8,pc,-21944
800086fc:	fe c6 aa 48 	sub	r6,pc,-21944
80008700:	a7 d5       	cbr	r5,0x7
80008702:	e0 40 00 47 	cp.w	r0,71
80008706:	f0 06 17 a0 	movle	r6,r8
8000870a:	30 32       	mov	r2,3
8000870c:	e0 8f 06 c2 	bral	80009490 <_vfprintf_r+0x1664>
80008710:	40 2a       	lddsp	r10,sp[0x8]
80008712:	5b fa       	cp.w	r10,-1
80008714:	c0 41       	brne	8000871c <_vfprintf_r+0x8f0>
80008716:	30 69       	mov	r9,6
80008718:	50 29       	stdsp	sp[0x8],r9
8000871a:	c1 18       	rjmp	8000873c <_vfprintf_r+0x910>
8000871c:	e0 40 00 47 	cp.w	r0,71
80008720:	5f 09       	sreq	r9
80008722:	e0 40 00 67 	cp.w	r0,103
80008726:	5f 08       	sreq	r8
80008728:	f3 e8 10 08 	or	r8,r9,r8
8000872c:	f8 08 18 00 	cp.b	r8,r12
80008730:	c0 60       	breq	8000873c <_vfprintf_r+0x910>
80008732:	40 28       	lddsp	r8,sp[0x8]
80008734:	58 08       	cp.w	r8,0
80008736:	f9 b8 00 01 	moveq	r8,1
8000873a:	50 28       	stdsp	sp[0x8],r8
8000873c:	40 78       	lddsp	r8,sp[0x1c]
8000873e:	40 59       	lddsp	r9,sp[0x14]
80008740:	fa e9 06 94 	st.d	sp[1684],r8
80008744:	a9 a5       	sbr	r5,0x8
80008746:	fa f8 06 94 	ld.w	r8,sp[1684]
8000874a:	58 08       	cp.w	r8,0
8000874c:	c0 65       	brlt	80008758 <_vfprintf_r+0x92c>
8000874e:	40 5e       	lddsp	lr,sp[0x14]
80008750:	30 0c       	mov	r12,0
80008752:	50 6e       	stdsp	sp[0x18],lr
80008754:	50 9c       	stdsp	sp[0x24],r12
80008756:	c0 78       	rjmp	80008764 <_vfprintf_r+0x938>
80008758:	40 5b       	lddsp	r11,sp[0x14]
8000875a:	32 da       	mov	r10,45
8000875c:	ee 1b 80 00 	eorh	r11,0x8000
80008760:	50 9a       	stdsp	sp[0x24],r10
80008762:	50 6b       	stdsp	sp[0x18],r11
80008764:	e0 40 00 46 	cp.w	r0,70
80008768:	5f 09       	sreq	r9
8000876a:	e0 40 00 66 	cp.w	r0,102
8000876e:	5f 08       	sreq	r8
80008770:	f3 e8 10 08 	or	r8,r9,r8
80008774:	50 48       	stdsp	sp[0x10],r8
80008776:	c0 40       	breq	8000877e <_vfprintf_r+0x952>
80008778:	40 22       	lddsp	r2,sp[0x8]
8000877a:	30 39       	mov	r9,3
8000877c:	c1 08       	rjmp	8000879c <_vfprintf_r+0x970>
8000877e:	e0 40 00 45 	cp.w	r0,69
80008782:	5f 09       	sreq	r9
80008784:	e0 40 00 65 	cp.w	r0,101
80008788:	5f 08       	sreq	r8
8000878a:	40 22       	lddsp	r2,sp[0x8]
8000878c:	10 49       	or	r9,r8
8000878e:	2f f2       	sub	r2,-1
80008790:	40 46       	lddsp	r6,sp[0x10]
80008792:	ec 09 18 00 	cp.b	r9,r6
80008796:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000879a:	30 29       	mov	r9,2
8000879c:	fa c8 f9 5c 	sub	r8,sp,-1700
800087a0:	1a d8       	st.w	--sp,r8
800087a2:	fa c8 f9 54 	sub	r8,sp,-1708
800087a6:	1a d8       	st.w	--sp,r8
800087a8:	fa c8 f9 4c 	sub	r8,sp,-1716
800087ac:	08 9c       	mov	r12,r4
800087ae:	1a d8       	st.w	--sp,r8
800087b0:	04 98       	mov	r8,r2
800087b2:	40 9b       	lddsp	r11,sp[0x24]
800087b4:	40 aa       	lddsp	r10,sp[0x28]
800087b6:	e0 a0 0b c3 	rcall	80009f3c <_dtoa_r>
800087ba:	e0 40 00 47 	cp.w	r0,71
800087be:	5f 19       	srne	r9
800087c0:	e0 40 00 67 	cp.w	r0,103
800087c4:	5f 18       	srne	r8
800087c6:	18 96       	mov	r6,r12
800087c8:	2f dd       	sub	sp,-12
800087ca:	f3 e8 00 08 	and	r8,r9,r8
800087ce:	c0 41       	brne	800087d6 <_vfprintf_r+0x9aa>
800087d0:	ed b5 00 00 	bld	r5,0x0
800087d4:	c3 01       	brne	80008834 <_vfprintf_r+0xa08>
800087d6:	ec 02 00 0e 	add	lr,r6,r2
800087da:	50 3e       	stdsp	sp[0xc],lr
800087dc:	40 4c       	lddsp	r12,sp[0x10]
800087de:	58 0c       	cp.w	r12,0
800087e0:	c1 50       	breq	8000880a <_vfprintf_r+0x9de>
800087e2:	0d 89       	ld.ub	r9,r6[0x0]
800087e4:	33 08       	mov	r8,48
800087e6:	f0 09 18 00 	cp.b	r9,r8
800087ea:	c0 b1       	brne	80008800 <_vfprintf_r+0x9d4>
800087ec:	30 08       	mov	r8,0
800087ee:	30 09       	mov	r9,0
800087f0:	40 6b       	lddsp	r11,sp[0x18]
800087f2:	40 7a       	lddsp	r10,sp[0x1c]
800087f4:	e0 a0 1c d7 	rcall	8000c1a2 <__avr32_f64_cmp_eq>
800087f8:	fb b2 00 01 	rsubeq	r2,1
800087fc:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008800:	40 3b       	lddsp	r11,sp[0xc]
80008802:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008806:	10 0b       	add	r11,r8
80008808:	50 3b       	stdsp	sp[0xc],r11
8000880a:	40 6b       	lddsp	r11,sp[0x18]
8000880c:	30 08       	mov	r8,0
8000880e:	30 09       	mov	r9,0
80008810:	40 7a       	lddsp	r10,sp[0x1c]
80008812:	e0 a0 1c c8 	rcall	8000c1a2 <__avr32_f64_cmp_eq>
80008816:	c0 90       	breq	80008828 <_vfprintf_r+0x9fc>
80008818:	40 3a       	lddsp	r10,sp[0xc]
8000881a:	fb 4a 06 a4 	st.w	sp[1700],r10
8000881e:	c0 58       	rjmp	80008828 <_vfprintf_r+0x9fc>
80008820:	10 c9       	st.b	r8++,r9
80008822:	fb 48 06 a4 	st.w	sp[1700],r8
80008826:	c0 28       	rjmp	8000882a <_vfprintf_r+0x9fe>
80008828:	33 09       	mov	r9,48
8000882a:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000882e:	40 3e       	lddsp	lr,sp[0xc]
80008830:	1c 38       	cp.w	r8,lr
80008832:	cf 73       	brcs	80008820 <_vfprintf_r+0x9f4>
80008834:	e0 40 00 47 	cp.w	r0,71
80008838:	5f 09       	sreq	r9
8000883a:	e0 40 00 67 	cp.w	r0,103
8000883e:	5f 08       	sreq	r8
80008840:	f3 e8 10 08 	or	r8,r9,r8
80008844:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008848:	0c 19       	sub	r9,r6
8000884a:	50 69       	stdsp	sp[0x18],r9
8000884c:	58 08       	cp.w	r8,0
8000884e:	c0 b0       	breq	80008864 <_vfprintf_r+0xa38>
80008850:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008854:	5b d8       	cp.w	r8,-3
80008856:	c0 55       	brlt	80008860 <_vfprintf_r+0xa34>
80008858:	40 2c       	lddsp	r12,sp[0x8]
8000885a:	18 38       	cp.w	r8,r12
8000885c:	e0 8a 00 6a 	brle	80008930 <_vfprintf_r+0xb04>
80008860:	20 20       	sub	r0,2
80008862:	c0 58       	rjmp	8000886c <_vfprintf_r+0xa40>
80008864:	e0 40 00 65 	cp.w	r0,101
80008868:	e0 89 00 46 	brgt	800088f4 <_vfprintf_r+0xac8>
8000886c:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008870:	fb 60 06 9c 	st.b	sp[1692],r0
80008874:	20 1b       	sub	r11,1
80008876:	fb 4b 06 ac 	st.w	sp[1708],r11
8000887a:	c0 47       	brpl	80008882 <_vfprintf_r+0xa56>
8000887c:	5c 3b       	neg	r11
8000887e:	32 d8       	mov	r8,45
80008880:	c0 28       	rjmp	80008884 <_vfprintf_r+0xa58>
80008882:	32 b8       	mov	r8,43
80008884:	fb 68 06 9d 	st.b	sp[1693],r8
80008888:	58 9b       	cp.w	r11,9
8000888a:	e0 8a 00 1d 	brle	800088c4 <_vfprintf_r+0xa98>
8000888e:	fa c9 fa 35 	sub	r9,sp,-1483
80008892:	30 aa       	mov	r10,10
80008894:	12 98       	mov	r8,r9
80008896:	0e 9c       	mov	r12,r7
80008898:	0c 92       	mov	r2,r6
8000889a:	f6 0a 0c 06 	divs	r6,r11,r10
8000889e:	0e 9b       	mov	r11,r7
800088a0:	2d 0b       	sub	r11,-48
800088a2:	10 fb       	st.b	--r8,r11
800088a4:	0c 9b       	mov	r11,r6
800088a6:	58 96       	cp.w	r6,9
800088a8:	fe 99 ff f9 	brgt	8000889a <_vfprintf_r+0xa6e>
800088ac:	2d 0b       	sub	r11,-48
800088ae:	18 97       	mov	r7,r12
800088b0:	04 96       	mov	r6,r2
800088b2:	10 fb       	st.b	--r8,r11
800088b4:	fa ca f9 62 	sub	r10,sp,-1694
800088b8:	c0 38       	rjmp	800088be <_vfprintf_r+0xa92>
800088ba:	11 3b       	ld.ub	r11,r8++
800088bc:	14 cb       	st.b	r10++,r11
800088be:	12 38       	cp.w	r8,r9
800088c0:	cf d3       	brcs	800088ba <_vfprintf_r+0xa8e>
800088c2:	c0 98       	rjmp	800088d4 <_vfprintf_r+0xaa8>
800088c4:	2d 0b       	sub	r11,-48
800088c6:	33 08       	mov	r8,48
800088c8:	fb 6b 06 9f 	st.b	sp[1695],r11
800088cc:	fb 68 06 9e 	st.b	sp[1694],r8
800088d0:	fa ca f9 60 	sub	r10,sp,-1696
800088d4:	fa c8 f9 64 	sub	r8,sp,-1692
800088d8:	f4 08 01 08 	sub	r8,r10,r8
800088dc:	50 e8       	stdsp	sp[0x38],r8
800088de:	10 92       	mov	r2,r8
800088e0:	40 6b       	lddsp	r11,sp[0x18]
800088e2:	16 02       	add	r2,r11
800088e4:	58 1b       	cp.w	r11,1
800088e6:	e0 89 00 05 	brgt	800088f0 <_vfprintf_r+0xac4>
800088ea:	ed b5 00 00 	bld	r5,0x0
800088ee:	c3 51       	brne	80008958 <_vfprintf_r+0xb2c>
800088f0:	2f f2       	sub	r2,-1
800088f2:	c3 38       	rjmp	80008958 <_vfprintf_r+0xb2c>
800088f4:	e0 40 00 66 	cp.w	r0,102
800088f8:	c1 c1       	brne	80008930 <_vfprintf_r+0xb04>
800088fa:	fa f2 06 ac 	ld.w	r2,sp[1708]
800088fe:	58 02       	cp.w	r2,0
80008900:	e0 8a 00 0c 	brle	80008918 <_vfprintf_r+0xaec>
80008904:	40 2a       	lddsp	r10,sp[0x8]
80008906:	58 0a       	cp.w	r10,0
80008908:	c0 41       	brne	80008910 <_vfprintf_r+0xae4>
8000890a:	ed b5 00 00 	bld	r5,0x0
8000890e:	c2 51       	brne	80008958 <_vfprintf_r+0xb2c>
80008910:	2f f2       	sub	r2,-1
80008912:	40 29       	lddsp	r9,sp[0x8]
80008914:	12 02       	add	r2,r9
80008916:	c0 b8       	rjmp	8000892c <_vfprintf_r+0xb00>
80008918:	40 28       	lddsp	r8,sp[0x8]
8000891a:	58 08       	cp.w	r8,0
8000891c:	c0 61       	brne	80008928 <_vfprintf_r+0xafc>
8000891e:	ed b5 00 00 	bld	r5,0x0
80008922:	c0 30       	breq	80008928 <_vfprintf_r+0xafc>
80008924:	30 12       	mov	r2,1
80008926:	c1 98       	rjmp	80008958 <_vfprintf_r+0xb2c>
80008928:	40 22       	lddsp	r2,sp[0x8]
8000892a:	2f e2       	sub	r2,-2
8000892c:	36 60       	mov	r0,102
8000892e:	c1 58       	rjmp	80008958 <_vfprintf_r+0xb2c>
80008930:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008934:	40 6e       	lddsp	lr,sp[0x18]
80008936:	1c 32       	cp.w	r2,lr
80008938:	c0 65       	brlt	80008944 <_vfprintf_r+0xb18>
8000893a:	ed b5 00 00 	bld	r5,0x0
8000893e:	f7 b2 00 ff 	subeq	r2,-1
80008942:	c0 a8       	rjmp	80008956 <_vfprintf_r+0xb2a>
80008944:	e4 08 11 02 	rsub	r8,r2,2
80008948:	40 6c       	lddsp	r12,sp[0x18]
8000894a:	58 02       	cp.w	r2,0
8000894c:	f0 02 17 a0 	movle	r2,r8
80008950:	f9 b2 09 01 	movgt	r2,1
80008954:	18 02       	add	r2,r12
80008956:	36 70       	mov	r0,103
80008958:	40 9b       	lddsp	r11,sp[0x24]
8000895a:	58 0b       	cp.w	r11,0
8000895c:	e0 80 05 94 	breq	80009484 <_vfprintf_r+0x1658>
80008960:	32 d8       	mov	r8,45
80008962:	fb 68 06 bb 	st.b	sp[1723],r8
80008966:	e0 8f 05 93 	bral	8000948c <_vfprintf_r+0x1660>
8000896a:	50 a7       	stdsp	sp[0x28],r7
8000896c:	04 94       	mov	r4,r2
8000896e:	0c 97       	mov	r7,r6
80008970:	02 92       	mov	r2,r1
80008972:	06 96       	mov	r6,r3
80008974:	40 41       	lddsp	r1,sp[0x10]
80008976:	40 93       	lddsp	r3,sp[0x24]
80008978:	0e 99       	mov	r9,r7
8000897a:	ed b5 00 05 	bld	r5,0x5
8000897e:	c4 81       	brne	80008a0e <_vfprintf_r+0xbe2>
80008980:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008984:	40 3e       	lddsp	lr,sp[0xc]
80008986:	58 0e       	cp.w	lr,0
80008988:	c1 d0       	breq	800089c2 <_vfprintf_r+0xb96>
8000898a:	10 36       	cp.w	r6,r8
8000898c:	c0 64       	brge	80008998 <_vfprintf_r+0xb6c>
8000898e:	fa cc f9 44 	sub	r12,sp,-1724
80008992:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008996:	c1 d8       	rjmp	800089d0 <_vfprintf_r+0xba4>
80008998:	fa c8 f9 50 	sub	r8,sp,-1712
8000899c:	1a d8       	st.w	--sp,r8
8000899e:	fa c8 fa b8 	sub	r8,sp,-1352
800089a2:	04 9a       	mov	r10,r2
800089a4:	1a d8       	st.w	--sp,r8
800089a6:	fa c8 fb b4 	sub	r8,sp,-1100
800089aa:	0c 9b       	mov	r11,r6
800089ac:	1a d8       	st.w	--sp,r8
800089ae:	08 9c       	mov	r12,r4
800089b0:	fa c8 f9 40 	sub	r8,sp,-1728
800089b4:	fa c9 ff b4 	sub	r9,sp,-76
800089b8:	fe b0 f8 a2 	rcall	80007afc <get_arg>
800089bc:	2f dd       	sub	sp,-12
800089be:	78 0a       	ld.w	r10,r12[0x0]
800089c0:	c2 08       	rjmp	80008a00 <_vfprintf_r+0xbd4>
800089c2:	2f f7       	sub	r7,-1
800089c4:	10 39       	cp.w	r9,r8
800089c6:	c0 84       	brge	800089d6 <_vfprintf_r+0xbaa>
800089c8:	fa cb f9 44 	sub	r11,sp,-1724
800089cc:	f6 06 00 36 	add	r6,r11,r6<<0x3
800089d0:	ec fa fd 88 	ld.w	r10,r6[-632]
800089d4:	c1 68       	rjmp	80008a00 <_vfprintf_r+0xbd4>
800089d6:	41 09       	lddsp	r9,sp[0x40]
800089d8:	59 f8       	cp.w	r8,31
800089da:	e0 89 00 10 	brgt	800089fa <_vfprintf_r+0xbce>
800089de:	f2 ca ff fc 	sub	r10,r9,-4
800089e2:	51 0a       	stdsp	sp[0x40],r10
800089e4:	fa c6 f9 44 	sub	r6,sp,-1724
800089e8:	72 0a       	ld.w	r10,r9[0x0]
800089ea:	ec 08 00 39 	add	r9,r6,r8<<0x3
800089ee:	f3 4a fd 88 	st.w	r9[-632],r10
800089f2:	2f f8       	sub	r8,-1
800089f4:	fb 48 06 b4 	st.w	sp[1716],r8
800089f8:	c0 48       	rjmp	80008a00 <_vfprintf_r+0xbd4>
800089fa:	72 0a       	ld.w	r10,r9[0x0]
800089fc:	2f c9       	sub	r9,-4
800089fe:	51 09       	stdsp	sp[0x40],r9
80008a00:	40 be       	lddsp	lr,sp[0x2c]
80008a02:	1c 98       	mov	r8,lr
80008a04:	95 1e       	st.w	r10[0x4],lr
80008a06:	bf 58       	asr	r8,0x1f
80008a08:	95 08       	st.w	r10[0x0],r8
80008a0a:	fe 9f fa 9f 	bral	80007f48 <_vfprintf_r+0x11c>
80008a0e:	ed b5 00 04 	bld	r5,0x4
80008a12:	c4 80       	breq	80008aa2 <_vfprintf_r+0xc76>
80008a14:	e2 15 00 40 	andl	r5,0x40,COH
80008a18:	c4 50       	breq	80008aa2 <_vfprintf_r+0xc76>
80008a1a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a1e:	40 3c       	lddsp	r12,sp[0xc]
80008a20:	58 0c       	cp.w	r12,0
80008a22:	c1 d0       	breq	80008a5c <_vfprintf_r+0xc30>
80008a24:	10 36       	cp.w	r6,r8
80008a26:	c0 64       	brge	80008a32 <_vfprintf_r+0xc06>
80008a28:	fa cb f9 44 	sub	r11,sp,-1724
80008a2c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a30:	c1 d8       	rjmp	80008a6a <_vfprintf_r+0xc3e>
80008a32:	fa c8 f9 50 	sub	r8,sp,-1712
80008a36:	1a d8       	st.w	--sp,r8
80008a38:	fa c8 fa b8 	sub	r8,sp,-1352
80008a3c:	04 9a       	mov	r10,r2
80008a3e:	1a d8       	st.w	--sp,r8
80008a40:	fa c8 fb b4 	sub	r8,sp,-1100
80008a44:	0c 9b       	mov	r11,r6
80008a46:	1a d8       	st.w	--sp,r8
80008a48:	08 9c       	mov	r12,r4
80008a4a:	fa c8 f9 40 	sub	r8,sp,-1728
80008a4e:	fa c9 ff b4 	sub	r9,sp,-76
80008a52:	fe b0 f8 55 	rcall	80007afc <get_arg>
80008a56:	2f dd       	sub	sp,-12
80008a58:	78 0a       	ld.w	r10,r12[0x0]
80008a5a:	c2 08       	rjmp	80008a9a <_vfprintf_r+0xc6e>
80008a5c:	2f f7       	sub	r7,-1
80008a5e:	10 39       	cp.w	r9,r8
80008a60:	c0 84       	brge	80008a70 <_vfprintf_r+0xc44>
80008a62:	fa ca f9 44 	sub	r10,sp,-1724
80008a66:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008a6a:	ec fa fd 88 	ld.w	r10,r6[-632]
80008a6e:	c1 68       	rjmp	80008a9a <_vfprintf_r+0xc6e>
80008a70:	41 09       	lddsp	r9,sp[0x40]
80008a72:	59 f8       	cp.w	r8,31
80008a74:	e0 89 00 10 	brgt	80008a94 <_vfprintf_r+0xc68>
80008a78:	f2 ca ff fc 	sub	r10,r9,-4
80008a7c:	51 0a       	stdsp	sp[0x40],r10
80008a7e:	fa c6 f9 44 	sub	r6,sp,-1724
80008a82:	72 0a       	ld.w	r10,r9[0x0]
80008a84:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008a88:	f3 4a fd 88 	st.w	r9[-632],r10
80008a8c:	2f f8       	sub	r8,-1
80008a8e:	fb 48 06 b4 	st.w	sp[1716],r8
80008a92:	c0 48       	rjmp	80008a9a <_vfprintf_r+0xc6e>
80008a94:	72 0a       	ld.w	r10,r9[0x0]
80008a96:	2f c9       	sub	r9,-4
80008a98:	51 09       	stdsp	sp[0x40],r9
80008a9a:	40 be       	lddsp	lr,sp[0x2c]
80008a9c:	b4 0e       	st.h	r10[0x0],lr
80008a9e:	fe 9f fa 55 	bral	80007f48 <_vfprintf_r+0x11c>
80008aa2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008aa6:	40 3c       	lddsp	r12,sp[0xc]
80008aa8:	58 0c       	cp.w	r12,0
80008aaa:	c1 d0       	breq	80008ae4 <_vfprintf_r+0xcb8>
80008aac:	10 36       	cp.w	r6,r8
80008aae:	c0 64       	brge	80008aba <_vfprintf_r+0xc8e>
80008ab0:	fa cb f9 44 	sub	r11,sp,-1724
80008ab4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008ab8:	c1 d8       	rjmp	80008af2 <_vfprintf_r+0xcc6>
80008aba:	fa c8 f9 50 	sub	r8,sp,-1712
80008abe:	1a d8       	st.w	--sp,r8
80008ac0:	fa c8 fa b8 	sub	r8,sp,-1352
80008ac4:	04 9a       	mov	r10,r2
80008ac6:	1a d8       	st.w	--sp,r8
80008ac8:	fa c8 fb b4 	sub	r8,sp,-1100
80008acc:	0c 9b       	mov	r11,r6
80008ace:	1a d8       	st.w	--sp,r8
80008ad0:	08 9c       	mov	r12,r4
80008ad2:	fa c8 f9 40 	sub	r8,sp,-1728
80008ad6:	fa c9 ff b4 	sub	r9,sp,-76
80008ada:	fe b0 f8 11 	rcall	80007afc <get_arg>
80008ade:	2f dd       	sub	sp,-12
80008ae0:	78 0a       	ld.w	r10,r12[0x0]
80008ae2:	c2 08       	rjmp	80008b22 <_vfprintf_r+0xcf6>
80008ae4:	2f f7       	sub	r7,-1
80008ae6:	10 39       	cp.w	r9,r8
80008ae8:	c0 84       	brge	80008af8 <_vfprintf_r+0xccc>
80008aea:	fa ca f9 44 	sub	r10,sp,-1724
80008aee:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008af2:	ec fa fd 88 	ld.w	r10,r6[-632]
80008af6:	c1 68       	rjmp	80008b22 <_vfprintf_r+0xcf6>
80008af8:	41 09       	lddsp	r9,sp[0x40]
80008afa:	59 f8       	cp.w	r8,31
80008afc:	e0 89 00 10 	brgt	80008b1c <_vfprintf_r+0xcf0>
80008b00:	f2 ca ff fc 	sub	r10,r9,-4
80008b04:	51 0a       	stdsp	sp[0x40],r10
80008b06:	fa c6 f9 44 	sub	r6,sp,-1724
80008b0a:	72 0a       	ld.w	r10,r9[0x0]
80008b0c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008b10:	f3 4a fd 88 	st.w	r9[-632],r10
80008b14:	2f f8       	sub	r8,-1
80008b16:	fb 48 06 b4 	st.w	sp[1716],r8
80008b1a:	c0 48       	rjmp	80008b22 <_vfprintf_r+0xcf6>
80008b1c:	72 0a       	ld.w	r10,r9[0x0]
80008b1e:	2f c9       	sub	r9,-4
80008b20:	51 09       	stdsp	sp[0x40],r9
80008b22:	40 be       	lddsp	lr,sp[0x2c]
80008b24:	95 0e       	st.w	r10[0x0],lr
80008b26:	fe 9f fa 11 	bral	80007f48 <_vfprintf_r+0x11c>
80008b2a:	50 a7       	stdsp	sp[0x28],r7
80008b2c:	50 80       	stdsp	sp[0x20],r0
80008b2e:	0c 97       	mov	r7,r6
80008b30:	04 94       	mov	r4,r2
80008b32:	06 96       	mov	r6,r3
80008b34:	02 92       	mov	r2,r1
80008b36:	40 93       	lddsp	r3,sp[0x24]
80008b38:	10 90       	mov	r0,r8
80008b3a:	40 41       	lddsp	r1,sp[0x10]
80008b3c:	a5 a5       	sbr	r5,0x4
80008b3e:	c0 a8       	rjmp	80008b52 <_vfprintf_r+0xd26>
80008b40:	50 a7       	stdsp	sp[0x28],r7
80008b42:	50 80       	stdsp	sp[0x20],r0
80008b44:	0c 97       	mov	r7,r6
80008b46:	04 94       	mov	r4,r2
80008b48:	06 96       	mov	r6,r3
80008b4a:	02 92       	mov	r2,r1
80008b4c:	40 93       	lddsp	r3,sp[0x24]
80008b4e:	10 90       	mov	r0,r8
80008b50:	40 41       	lddsp	r1,sp[0x10]
80008b52:	ed b5 00 05 	bld	r5,0x5
80008b56:	c5 d1       	brne	80008c10 <_vfprintf_r+0xde4>
80008b58:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b5c:	40 3c       	lddsp	r12,sp[0xc]
80008b5e:	58 0c       	cp.w	r12,0
80008b60:	c2 60       	breq	80008bac <_vfprintf_r+0xd80>
80008b62:	10 36       	cp.w	r6,r8
80008b64:	c0 a4       	brge	80008b78 <_vfprintf_r+0xd4c>
80008b66:	fa cb f9 44 	sub	r11,sp,-1724
80008b6a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008b6e:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008b72:	fa e9 00 00 	st.d	sp[0],r8
80008b76:	c1 88       	rjmp	80008ba6 <_vfprintf_r+0xd7a>
80008b78:	fa c8 f9 50 	sub	r8,sp,-1712
80008b7c:	1a d8       	st.w	--sp,r8
80008b7e:	fa c8 fa b8 	sub	r8,sp,-1352
80008b82:	04 9a       	mov	r10,r2
80008b84:	1a d8       	st.w	--sp,r8
80008b86:	0c 9b       	mov	r11,r6
80008b88:	fa c8 fb b4 	sub	r8,sp,-1100
80008b8c:	08 9c       	mov	r12,r4
80008b8e:	1a d8       	st.w	--sp,r8
80008b90:	fa c8 f9 40 	sub	r8,sp,-1728
80008b94:	fa c9 ff b4 	sub	r9,sp,-76
80008b98:	fe b0 f7 b2 	rcall	80007afc <get_arg>
80008b9c:	2f dd       	sub	sp,-12
80008b9e:	f8 ea 00 00 	ld.d	r10,r12[0]
80008ba2:	fa eb 00 00 	st.d	sp[0],r10
80008ba6:	30 08       	mov	r8,0
80008ba8:	e0 8f 03 de 	bral	80009364 <_vfprintf_r+0x1538>
80008bac:	ee ca ff ff 	sub	r10,r7,-1
80008bb0:	10 37       	cp.w	r7,r8
80008bb2:	c0 b4       	brge	80008bc8 <_vfprintf_r+0xd9c>
80008bb4:	fa c9 f9 44 	sub	r9,sp,-1724
80008bb8:	14 97       	mov	r7,r10
80008bba:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008bbe:	ec ea fd 88 	ld.d	r10,r6[-632]
80008bc2:	fa eb 00 00 	st.d	sp[0],r10
80008bc6:	c1 88       	rjmp	80008bf6 <_vfprintf_r+0xdca>
80008bc8:	41 09       	lddsp	r9,sp[0x40]
80008bca:	59 f8       	cp.w	r8,31
80008bcc:	e0 89 00 18 	brgt	80008bfc <_vfprintf_r+0xdd0>
80008bd0:	f2 e6 00 00 	ld.d	r6,r9[0]
80008bd4:	f2 cb ff f8 	sub	r11,r9,-8
80008bd8:	fa e7 00 00 	st.d	sp[0],r6
80008bdc:	51 0b       	stdsp	sp[0x40],r11
80008bde:	fa c6 f9 44 	sub	r6,sp,-1724
80008be2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008be6:	fa e6 00 00 	ld.d	r6,sp[0]
80008bea:	f2 e7 fd 88 	st.d	r9[-632],r6
80008bee:	2f f8       	sub	r8,-1
80008bf0:	14 97       	mov	r7,r10
80008bf2:	fb 48 06 b4 	st.w	sp[1716],r8
80008bf6:	40 38       	lddsp	r8,sp[0xc]
80008bf8:	e0 8f 03 b6 	bral	80009364 <_vfprintf_r+0x1538>
80008bfc:	f2 e6 00 00 	ld.d	r6,r9[0]
80008c00:	40 38       	lddsp	r8,sp[0xc]
80008c02:	fa e7 00 00 	st.d	sp[0],r6
80008c06:	2f 89       	sub	r9,-8
80008c08:	14 97       	mov	r7,r10
80008c0a:	51 09       	stdsp	sp[0x40],r9
80008c0c:	e0 8f 03 ac 	bral	80009364 <_vfprintf_r+0x1538>
80008c10:	ed b5 00 04 	bld	r5,0x4
80008c14:	c1 61       	brne	80008c40 <_vfprintf_r+0xe14>
80008c16:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c1a:	40 3e       	lddsp	lr,sp[0xc]
80008c1c:	58 0e       	cp.w	lr,0
80008c1e:	c0 80       	breq	80008c2e <_vfprintf_r+0xe02>
80008c20:	10 36       	cp.w	r6,r8
80008c22:	c6 74       	brge	80008cf0 <_vfprintf_r+0xec4>
80008c24:	fa cc f9 44 	sub	r12,sp,-1724
80008c28:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008c2c:	c8 08       	rjmp	80008d2c <_vfprintf_r+0xf00>
80008c2e:	ee ca ff ff 	sub	r10,r7,-1
80008c32:	10 37       	cp.w	r7,r8
80008c34:	c7 f4       	brge	80008d32 <_vfprintf_r+0xf06>
80008c36:	fa cb f9 44 	sub	r11,sp,-1724
80008c3a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c3e:	c7 68       	rjmp	80008d2a <_vfprintf_r+0xefe>
80008c40:	ed b5 00 06 	bld	r5,0x6
80008c44:	c4 a1       	brne	80008cd8 <_vfprintf_r+0xeac>
80008c46:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c4a:	40 3c       	lddsp	r12,sp[0xc]
80008c4c:	58 0c       	cp.w	r12,0
80008c4e:	c1 d0       	breq	80008c88 <_vfprintf_r+0xe5c>
80008c50:	10 36       	cp.w	r6,r8
80008c52:	c0 64       	brge	80008c5e <_vfprintf_r+0xe32>
80008c54:	fa cb f9 44 	sub	r11,sp,-1724
80008c58:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c5c:	c1 f8       	rjmp	80008c9a <_vfprintf_r+0xe6e>
80008c5e:	fa c8 f9 50 	sub	r8,sp,-1712
80008c62:	1a d8       	st.w	--sp,r8
80008c64:	fa c8 fa b8 	sub	r8,sp,-1352
80008c68:	1a d8       	st.w	--sp,r8
80008c6a:	fa c8 fb b4 	sub	r8,sp,-1100
80008c6e:	1a d8       	st.w	--sp,r8
80008c70:	fa c8 f9 40 	sub	r8,sp,-1728
80008c74:	fa c9 ff b4 	sub	r9,sp,-76
80008c78:	04 9a       	mov	r10,r2
80008c7a:	0c 9b       	mov	r11,r6
80008c7c:	08 9c       	mov	r12,r4
80008c7e:	fe b0 f7 3f 	rcall	80007afc <get_arg>
80008c82:	2f dd       	sub	sp,-12
80008c84:	98 18       	ld.sh	r8,r12[0x2]
80008c86:	c2 68       	rjmp	80008cd2 <_vfprintf_r+0xea6>
80008c88:	ee ca ff ff 	sub	r10,r7,-1
80008c8c:	10 37       	cp.w	r7,r8
80008c8e:	c0 94       	brge	80008ca0 <_vfprintf_r+0xe74>
80008c90:	fa c9 f9 44 	sub	r9,sp,-1724
80008c94:	14 97       	mov	r7,r10
80008c96:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008c9a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008c9e:	c1 a8       	rjmp	80008cd2 <_vfprintf_r+0xea6>
80008ca0:	41 09       	lddsp	r9,sp[0x40]
80008ca2:	59 f8       	cp.w	r8,31
80008ca4:	e0 89 00 13 	brgt	80008cca <_vfprintf_r+0xe9e>
80008ca8:	f2 cb ff fc 	sub	r11,r9,-4
80008cac:	51 0b       	stdsp	sp[0x40],r11
80008cae:	72 09       	ld.w	r9,r9[0x0]
80008cb0:	fa c6 f9 44 	sub	r6,sp,-1724
80008cb4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008cb8:	2f f8       	sub	r8,-1
80008cba:	f7 49 fd 88 	st.w	r11[-632],r9
80008cbe:	fb 48 06 b4 	st.w	sp[1716],r8
80008cc2:	14 97       	mov	r7,r10
80008cc4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008cc8:	c0 58       	rjmp	80008cd2 <_vfprintf_r+0xea6>
80008cca:	92 18       	ld.sh	r8,r9[0x2]
80008ccc:	14 97       	mov	r7,r10
80008cce:	2f c9       	sub	r9,-4
80008cd0:	51 09       	stdsp	sp[0x40],r9
80008cd2:	5c 78       	castu.h	r8
80008cd4:	50 18       	stdsp	sp[0x4],r8
80008cd6:	c4 68       	rjmp	80008d62 <_vfprintf_r+0xf36>
80008cd8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008cdc:	40 3c       	lddsp	r12,sp[0xc]
80008cde:	58 0c       	cp.w	r12,0
80008ce0:	c1 d0       	breq	80008d1a <_vfprintf_r+0xeee>
80008ce2:	10 36       	cp.w	r6,r8
80008ce4:	c0 64       	brge	80008cf0 <_vfprintf_r+0xec4>
80008ce6:	fa cb f9 44 	sub	r11,sp,-1724
80008cea:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008cee:	c1 f8       	rjmp	80008d2c <_vfprintf_r+0xf00>
80008cf0:	fa c8 f9 50 	sub	r8,sp,-1712
80008cf4:	1a d8       	st.w	--sp,r8
80008cf6:	fa c8 fa b8 	sub	r8,sp,-1352
80008cfa:	0c 9b       	mov	r11,r6
80008cfc:	1a d8       	st.w	--sp,r8
80008cfe:	fa c8 fb b4 	sub	r8,sp,-1100
80008d02:	04 9a       	mov	r10,r2
80008d04:	1a d8       	st.w	--sp,r8
80008d06:	08 9c       	mov	r12,r4
80008d08:	fa c8 f9 40 	sub	r8,sp,-1728
80008d0c:	fa c9 ff b4 	sub	r9,sp,-76
80008d10:	fe b0 f6 f6 	rcall	80007afc <get_arg>
80008d14:	2f dd       	sub	sp,-12
80008d16:	78 0b       	ld.w	r11,r12[0x0]
80008d18:	c2 48       	rjmp	80008d60 <_vfprintf_r+0xf34>
80008d1a:	ee ca ff ff 	sub	r10,r7,-1
80008d1e:	10 37       	cp.w	r7,r8
80008d20:	c0 94       	brge	80008d32 <_vfprintf_r+0xf06>
80008d22:	fa c9 f9 44 	sub	r9,sp,-1724
80008d26:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008d2a:	14 97       	mov	r7,r10
80008d2c:	ec fb fd 88 	ld.w	r11,r6[-632]
80008d30:	c1 88       	rjmp	80008d60 <_vfprintf_r+0xf34>
80008d32:	41 09       	lddsp	r9,sp[0x40]
80008d34:	59 f8       	cp.w	r8,31
80008d36:	e0 89 00 11 	brgt	80008d58 <_vfprintf_r+0xf2c>
80008d3a:	f2 cb ff fc 	sub	r11,r9,-4
80008d3e:	51 0b       	stdsp	sp[0x40],r11
80008d40:	fa c6 f9 44 	sub	r6,sp,-1724
80008d44:	72 0b       	ld.w	r11,r9[0x0]
80008d46:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008d4a:	f3 4b fd 88 	st.w	r9[-632],r11
80008d4e:	2f f8       	sub	r8,-1
80008d50:	14 97       	mov	r7,r10
80008d52:	fb 48 06 b4 	st.w	sp[1716],r8
80008d56:	c0 58       	rjmp	80008d60 <_vfprintf_r+0xf34>
80008d58:	72 0b       	ld.w	r11,r9[0x0]
80008d5a:	14 97       	mov	r7,r10
80008d5c:	2f c9       	sub	r9,-4
80008d5e:	51 09       	stdsp	sp[0x40],r9
80008d60:	50 1b       	stdsp	sp[0x4],r11
80008d62:	30 0e       	mov	lr,0
80008d64:	50 0e       	stdsp	sp[0x0],lr
80008d66:	1c 98       	mov	r8,lr
80008d68:	e0 8f 02 fe 	bral	80009364 <_vfprintf_r+0x1538>
80008d6c:	50 a7       	stdsp	sp[0x28],r7
80008d6e:	50 80       	stdsp	sp[0x20],r0
80008d70:	0c 97       	mov	r7,r6
80008d72:	04 94       	mov	r4,r2
80008d74:	06 96       	mov	r6,r3
80008d76:	02 92       	mov	r2,r1
80008d78:	40 93       	lddsp	r3,sp[0x24]
80008d7a:	40 41       	lddsp	r1,sp[0x10]
80008d7c:	0e 99       	mov	r9,r7
80008d7e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d82:	40 3c       	lddsp	r12,sp[0xc]
80008d84:	58 0c       	cp.w	r12,0
80008d86:	c1 d0       	breq	80008dc0 <_vfprintf_r+0xf94>
80008d88:	10 36       	cp.w	r6,r8
80008d8a:	c0 64       	brge	80008d96 <_vfprintf_r+0xf6a>
80008d8c:	fa cb f9 44 	sub	r11,sp,-1724
80008d90:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d94:	c1 d8       	rjmp	80008dce <_vfprintf_r+0xfa2>
80008d96:	fa c8 f9 50 	sub	r8,sp,-1712
80008d9a:	1a d8       	st.w	--sp,r8
80008d9c:	fa c8 fa b8 	sub	r8,sp,-1352
80008da0:	1a d8       	st.w	--sp,r8
80008da2:	fa c8 fb b4 	sub	r8,sp,-1100
80008da6:	1a d8       	st.w	--sp,r8
80008da8:	fa c9 ff b4 	sub	r9,sp,-76
80008dac:	fa c8 f9 40 	sub	r8,sp,-1728
80008db0:	04 9a       	mov	r10,r2
80008db2:	0c 9b       	mov	r11,r6
80008db4:	08 9c       	mov	r12,r4
80008db6:	fe b0 f6 a3 	rcall	80007afc <get_arg>
80008dba:	2f dd       	sub	sp,-12
80008dbc:	78 09       	ld.w	r9,r12[0x0]
80008dbe:	c2 18       	rjmp	80008e00 <_vfprintf_r+0xfd4>
80008dc0:	2f f7       	sub	r7,-1
80008dc2:	10 39       	cp.w	r9,r8
80008dc4:	c0 84       	brge	80008dd4 <_vfprintf_r+0xfa8>
80008dc6:	fa ca f9 44 	sub	r10,sp,-1724
80008dca:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008dce:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008dd2:	c1 78       	rjmp	80008e00 <_vfprintf_r+0xfd4>
80008dd4:	41 09       	lddsp	r9,sp[0x40]
80008dd6:	59 f8       	cp.w	r8,31
80008dd8:	e0 89 00 10 	brgt	80008df8 <_vfprintf_r+0xfcc>
80008ddc:	f2 ca ff fc 	sub	r10,r9,-4
80008de0:	51 0a       	stdsp	sp[0x40],r10
80008de2:	fa c6 f9 44 	sub	r6,sp,-1724
80008de6:	72 09       	ld.w	r9,r9[0x0]
80008de8:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008dec:	f5 49 fd 88 	st.w	r10[-632],r9
80008df0:	2f f8       	sub	r8,-1
80008df2:	fb 48 06 b4 	st.w	sp[1716],r8
80008df6:	c0 58       	rjmp	80008e00 <_vfprintf_r+0xfd4>
80008df8:	f2 c8 ff fc 	sub	r8,r9,-4
80008dfc:	51 08       	stdsp	sp[0x40],r8
80008dfe:	72 09       	ld.w	r9,r9[0x0]
80008e00:	33 08       	mov	r8,48
80008e02:	fb 68 06 b8 	st.b	sp[1720],r8
80008e06:	37 88       	mov	r8,120
80008e08:	30 0e       	mov	lr,0
80008e0a:	fb 68 06 b9 	st.b	sp[1721],r8
80008e0e:	fe cc b1 56 	sub	r12,pc,-20138
80008e12:	50 19       	stdsp	sp[0x4],r9
80008e14:	a1 b5       	sbr	r5,0x1
80008e16:	50 0e       	stdsp	sp[0x0],lr
80008e18:	50 dc       	stdsp	sp[0x34],r12
80008e1a:	30 28       	mov	r8,2
80008e1c:	37 80       	mov	r0,120
80008e1e:	e0 8f 02 a3 	bral	80009364 <_vfprintf_r+0x1538>
80008e22:	50 a7       	stdsp	sp[0x28],r7
80008e24:	50 80       	stdsp	sp[0x20],r0
80008e26:	10 90       	mov	r0,r8
80008e28:	30 08       	mov	r8,0
80008e2a:	fb 68 06 bb 	st.b	sp[1723],r8
80008e2e:	0c 97       	mov	r7,r6
80008e30:	04 94       	mov	r4,r2
80008e32:	06 96       	mov	r6,r3
80008e34:	02 92       	mov	r2,r1
80008e36:	40 93       	lddsp	r3,sp[0x24]
80008e38:	40 41       	lddsp	r1,sp[0x10]
80008e3a:	0e 99       	mov	r9,r7
80008e3c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e40:	40 3b       	lddsp	r11,sp[0xc]
80008e42:	58 0b       	cp.w	r11,0
80008e44:	c1 d0       	breq	80008e7e <_vfprintf_r+0x1052>
80008e46:	10 36       	cp.w	r6,r8
80008e48:	c0 64       	brge	80008e54 <_vfprintf_r+0x1028>
80008e4a:	fa ca f9 44 	sub	r10,sp,-1724
80008e4e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008e52:	c1 d8       	rjmp	80008e8c <_vfprintf_r+0x1060>
80008e54:	fa c8 f9 50 	sub	r8,sp,-1712
80008e58:	1a d8       	st.w	--sp,r8
80008e5a:	fa c8 fa b8 	sub	r8,sp,-1352
80008e5e:	1a d8       	st.w	--sp,r8
80008e60:	fa c8 fb b4 	sub	r8,sp,-1100
80008e64:	0c 9b       	mov	r11,r6
80008e66:	1a d8       	st.w	--sp,r8
80008e68:	04 9a       	mov	r10,r2
80008e6a:	fa c8 f9 40 	sub	r8,sp,-1728
80008e6e:	fa c9 ff b4 	sub	r9,sp,-76
80008e72:	08 9c       	mov	r12,r4
80008e74:	fe b0 f6 44 	rcall	80007afc <get_arg>
80008e78:	2f dd       	sub	sp,-12
80008e7a:	78 06       	ld.w	r6,r12[0x0]
80008e7c:	c2 08       	rjmp	80008ebc <_vfprintf_r+0x1090>
80008e7e:	2f f7       	sub	r7,-1
80008e80:	10 39       	cp.w	r9,r8
80008e82:	c0 84       	brge	80008e92 <_vfprintf_r+0x1066>
80008e84:	fa c9 f9 44 	sub	r9,sp,-1724
80008e88:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008e8c:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008e90:	c1 68       	rjmp	80008ebc <_vfprintf_r+0x1090>
80008e92:	41 09       	lddsp	r9,sp[0x40]
80008e94:	59 f8       	cp.w	r8,31
80008e96:	e0 89 00 10 	brgt	80008eb6 <_vfprintf_r+0x108a>
80008e9a:	f2 ca ff fc 	sub	r10,r9,-4
80008e9e:	51 0a       	stdsp	sp[0x40],r10
80008ea0:	72 06       	ld.w	r6,r9[0x0]
80008ea2:	fa ce f9 44 	sub	lr,sp,-1724
80008ea6:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008eaa:	f3 46 fd 88 	st.w	r9[-632],r6
80008eae:	2f f8       	sub	r8,-1
80008eb0:	fb 48 06 b4 	st.w	sp[1716],r8
80008eb4:	c0 48       	rjmp	80008ebc <_vfprintf_r+0x1090>
80008eb6:	72 06       	ld.w	r6,r9[0x0]
80008eb8:	2f c9       	sub	r9,-4
80008eba:	51 09       	stdsp	sp[0x40],r9
80008ebc:	40 2c       	lddsp	r12,sp[0x8]
80008ebe:	58 0c       	cp.w	r12,0
80008ec0:	c1 05       	brlt	80008ee0 <_vfprintf_r+0x10b4>
80008ec2:	18 9a       	mov	r10,r12
80008ec4:	30 0b       	mov	r11,0
80008ec6:	0c 9c       	mov	r12,r6
80008ec8:	e0 a0 12 38 	rcall	8000b338 <memchr>
80008ecc:	e0 80 02 df 	breq	8000948a <_vfprintf_r+0x165e>
80008ed0:	f8 06 01 02 	sub	r2,r12,r6
80008ed4:	40 2b       	lddsp	r11,sp[0x8]
80008ed6:	16 32       	cp.w	r2,r11
80008ed8:	e0 89 02 d9 	brgt	8000948a <_vfprintf_r+0x165e>
80008edc:	e0 8f 02 d4 	bral	80009484 <_vfprintf_r+0x1658>
80008ee0:	30 0a       	mov	r10,0
80008ee2:	0c 9c       	mov	r12,r6
80008ee4:	50 2a       	stdsp	sp[0x8],r10
80008ee6:	e0 a0 15 99 	rcall	8000ba18 <strlen>
80008eea:	18 92       	mov	r2,r12
80008eec:	e0 8f 02 d2 	bral	80009490 <_vfprintf_r+0x1664>
80008ef0:	50 a7       	stdsp	sp[0x28],r7
80008ef2:	50 80       	stdsp	sp[0x20],r0
80008ef4:	0c 97       	mov	r7,r6
80008ef6:	04 94       	mov	r4,r2
80008ef8:	06 96       	mov	r6,r3
80008efa:	02 92       	mov	r2,r1
80008efc:	40 93       	lddsp	r3,sp[0x24]
80008efe:	10 90       	mov	r0,r8
80008f00:	40 41       	lddsp	r1,sp[0x10]
80008f02:	a5 a5       	sbr	r5,0x4
80008f04:	c0 a8       	rjmp	80008f18 <_vfprintf_r+0x10ec>
80008f06:	50 a7       	stdsp	sp[0x28],r7
80008f08:	50 80       	stdsp	sp[0x20],r0
80008f0a:	0c 97       	mov	r7,r6
80008f0c:	04 94       	mov	r4,r2
80008f0e:	06 96       	mov	r6,r3
80008f10:	02 92       	mov	r2,r1
80008f12:	40 93       	lddsp	r3,sp[0x24]
80008f14:	10 90       	mov	r0,r8
80008f16:	40 41       	lddsp	r1,sp[0x10]
80008f18:	ed b5 00 05 	bld	r5,0x5
80008f1c:	c5 61       	brne	80008fc8 <_vfprintf_r+0x119c>
80008f1e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f22:	40 39       	lddsp	r9,sp[0xc]
80008f24:	58 09       	cp.w	r9,0
80008f26:	c2 10       	breq	80008f68 <_vfprintf_r+0x113c>
80008f28:	10 36       	cp.w	r6,r8
80008f2a:	c0 74       	brge	80008f38 <_vfprintf_r+0x110c>
80008f2c:	fa c8 f9 44 	sub	r8,sp,-1724
80008f30:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008f34:	c2 38       	rjmp	80008f7a <_vfprintf_r+0x114e>
80008f36:	d7 03       	nop
80008f38:	fa c8 f9 50 	sub	r8,sp,-1712
80008f3c:	1a d8       	st.w	--sp,r8
80008f3e:	fa c8 fa b8 	sub	r8,sp,-1352
80008f42:	1a d8       	st.w	--sp,r8
80008f44:	fa c8 fb b4 	sub	r8,sp,-1100
80008f48:	1a d8       	st.w	--sp,r8
80008f4a:	fa c8 f9 40 	sub	r8,sp,-1728
80008f4e:	fa c9 ff b4 	sub	r9,sp,-76
80008f52:	04 9a       	mov	r10,r2
80008f54:	0c 9b       	mov	r11,r6
80008f56:	08 9c       	mov	r12,r4
80008f58:	fe b0 f5 d2 	rcall	80007afc <get_arg>
80008f5c:	2f dd       	sub	sp,-12
80008f5e:	f8 e8 00 00 	ld.d	r8,r12[0]
80008f62:	fa e9 00 00 	st.d	sp[0],r8
80008f66:	c2 e8       	rjmp	80008fc2 <_vfprintf_r+0x1196>
80008f68:	ee ca ff ff 	sub	r10,r7,-1
80008f6c:	10 37       	cp.w	r7,r8
80008f6e:	c0 b4       	brge	80008f84 <_vfprintf_r+0x1158>
80008f70:	fa c8 f9 44 	sub	r8,sp,-1724
80008f74:	14 97       	mov	r7,r10
80008f76:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008f7a:	ec ea fd 88 	ld.d	r10,r6[-632]
80008f7e:	fa eb 00 00 	st.d	sp[0],r10
80008f82:	c2 08       	rjmp	80008fc2 <_vfprintf_r+0x1196>
80008f84:	41 09       	lddsp	r9,sp[0x40]
80008f86:	59 f8       	cp.w	r8,31
80008f88:	e0 89 00 16 	brgt	80008fb4 <_vfprintf_r+0x1188>
80008f8c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008f90:	f2 cb ff f8 	sub	r11,r9,-8
80008f94:	fa e7 00 00 	st.d	sp[0],r6
80008f98:	51 0b       	stdsp	sp[0x40],r11
80008f9a:	fa c6 f9 44 	sub	r6,sp,-1724
80008f9e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008fa2:	fa e6 00 00 	ld.d	r6,sp[0]
80008fa6:	f2 e7 fd 88 	st.d	r9[-632],r6
80008faa:	2f f8       	sub	r8,-1
80008fac:	14 97       	mov	r7,r10
80008fae:	fb 48 06 b4 	st.w	sp[1716],r8
80008fb2:	c0 88       	rjmp	80008fc2 <_vfprintf_r+0x1196>
80008fb4:	f2 e6 00 00 	ld.d	r6,r9[0]
80008fb8:	2f 89       	sub	r9,-8
80008fba:	fa e7 00 00 	st.d	sp[0],r6
80008fbe:	51 09       	stdsp	sp[0x40],r9
80008fc0:	14 97       	mov	r7,r10
80008fc2:	30 18       	mov	r8,1
80008fc4:	e0 8f 01 d0 	bral	80009364 <_vfprintf_r+0x1538>
80008fc8:	ed b5 00 04 	bld	r5,0x4
80008fcc:	c1 61       	brne	80008ff8 <_vfprintf_r+0x11cc>
80008fce:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008fd2:	40 3e       	lddsp	lr,sp[0xc]
80008fd4:	58 0e       	cp.w	lr,0
80008fd6:	c0 80       	breq	80008fe6 <_vfprintf_r+0x11ba>
80008fd8:	10 36       	cp.w	r6,r8
80008fda:	c6 74       	brge	800090a8 <_vfprintf_r+0x127c>
80008fdc:	fa cc f9 44 	sub	r12,sp,-1724
80008fe0:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008fe4:	c8 08       	rjmp	800090e4 <_vfprintf_r+0x12b8>
80008fe6:	ee ca ff ff 	sub	r10,r7,-1
80008fea:	10 37       	cp.w	r7,r8
80008fec:	c7 f4       	brge	800090ea <_vfprintf_r+0x12be>
80008fee:	fa cb f9 44 	sub	r11,sp,-1724
80008ff2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008ff6:	c7 68       	rjmp	800090e2 <_vfprintf_r+0x12b6>
80008ff8:	ed b5 00 06 	bld	r5,0x6
80008ffc:	c4 a1       	brne	80009090 <_vfprintf_r+0x1264>
80008ffe:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009002:	40 3c       	lddsp	r12,sp[0xc]
80009004:	58 0c       	cp.w	r12,0
80009006:	c1 d0       	breq	80009040 <_vfprintf_r+0x1214>
80009008:	10 36       	cp.w	r6,r8
8000900a:	c0 64       	brge	80009016 <_vfprintf_r+0x11ea>
8000900c:	fa cb f9 44 	sub	r11,sp,-1724
80009010:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009014:	c1 f8       	rjmp	80009052 <_vfprintf_r+0x1226>
80009016:	fa c8 f9 50 	sub	r8,sp,-1712
8000901a:	1a d8       	st.w	--sp,r8
8000901c:	fa c8 fa b8 	sub	r8,sp,-1352
80009020:	1a d8       	st.w	--sp,r8
80009022:	fa c8 fb b4 	sub	r8,sp,-1100
80009026:	1a d8       	st.w	--sp,r8
80009028:	fa c8 f9 40 	sub	r8,sp,-1728
8000902c:	fa c9 ff b4 	sub	r9,sp,-76
80009030:	04 9a       	mov	r10,r2
80009032:	0c 9b       	mov	r11,r6
80009034:	08 9c       	mov	r12,r4
80009036:	fe b0 f5 63 	rcall	80007afc <get_arg>
8000903a:	2f dd       	sub	sp,-12
8000903c:	98 18       	ld.sh	r8,r12[0x2]
8000903e:	c2 68       	rjmp	8000908a <_vfprintf_r+0x125e>
80009040:	ee ca ff ff 	sub	r10,r7,-1
80009044:	10 37       	cp.w	r7,r8
80009046:	c0 94       	brge	80009058 <_vfprintf_r+0x122c>
80009048:	fa c9 f9 44 	sub	r9,sp,-1724
8000904c:	14 97       	mov	r7,r10
8000904e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009052:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009056:	c1 a8       	rjmp	8000908a <_vfprintf_r+0x125e>
80009058:	41 09       	lddsp	r9,sp[0x40]
8000905a:	59 f8       	cp.w	r8,31
8000905c:	e0 89 00 13 	brgt	80009082 <_vfprintf_r+0x1256>
80009060:	f2 cb ff fc 	sub	r11,r9,-4
80009064:	51 0b       	stdsp	sp[0x40],r11
80009066:	72 09       	ld.w	r9,r9[0x0]
80009068:	fa c6 f9 44 	sub	r6,sp,-1724
8000906c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009070:	2f f8       	sub	r8,-1
80009072:	f7 49 fd 88 	st.w	r11[-632],r9
80009076:	fb 48 06 b4 	st.w	sp[1716],r8
8000907a:	14 97       	mov	r7,r10
8000907c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009080:	c0 58       	rjmp	8000908a <_vfprintf_r+0x125e>
80009082:	92 18       	ld.sh	r8,r9[0x2]
80009084:	14 97       	mov	r7,r10
80009086:	2f c9       	sub	r9,-4
80009088:	51 09       	stdsp	sp[0x40],r9
8000908a:	5c 78       	castu.h	r8
8000908c:	50 18       	stdsp	sp[0x4],r8
8000908e:	c4 68       	rjmp	8000911a <_vfprintf_r+0x12ee>
80009090:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009094:	40 3c       	lddsp	r12,sp[0xc]
80009096:	58 0c       	cp.w	r12,0
80009098:	c1 d0       	breq	800090d2 <_vfprintf_r+0x12a6>
8000909a:	10 36       	cp.w	r6,r8
8000909c:	c0 64       	brge	800090a8 <_vfprintf_r+0x127c>
8000909e:	fa cb f9 44 	sub	r11,sp,-1724
800090a2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800090a6:	c1 f8       	rjmp	800090e4 <_vfprintf_r+0x12b8>
800090a8:	fa c8 f9 50 	sub	r8,sp,-1712
800090ac:	1a d8       	st.w	--sp,r8
800090ae:	fa c8 fa b8 	sub	r8,sp,-1352
800090b2:	0c 9b       	mov	r11,r6
800090b4:	1a d8       	st.w	--sp,r8
800090b6:	fa c8 fb b4 	sub	r8,sp,-1100
800090ba:	04 9a       	mov	r10,r2
800090bc:	1a d8       	st.w	--sp,r8
800090be:	08 9c       	mov	r12,r4
800090c0:	fa c8 f9 40 	sub	r8,sp,-1728
800090c4:	fa c9 ff b4 	sub	r9,sp,-76
800090c8:	fe b0 f5 1a 	rcall	80007afc <get_arg>
800090cc:	2f dd       	sub	sp,-12
800090ce:	78 0b       	ld.w	r11,r12[0x0]
800090d0:	c2 48       	rjmp	80009118 <_vfprintf_r+0x12ec>
800090d2:	ee ca ff ff 	sub	r10,r7,-1
800090d6:	10 37       	cp.w	r7,r8
800090d8:	c0 94       	brge	800090ea <_vfprintf_r+0x12be>
800090da:	fa c9 f9 44 	sub	r9,sp,-1724
800090de:	f2 06 00 36 	add	r6,r9,r6<<0x3
800090e2:	14 97       	mov	r7,r10
800090e4:	ec fb fd 88 	ld.w	r11,r6[-632]
800090e8:	c1 88       	rjmp	80009118 <_vfprintf_r+0x12ec>
800090ea:	41 09       	lddsp	r9,sp[0x40]
800090ec:	59 f8       	cp.w	r8,31
800090ee:	e0 89 00 11 	brgt	80009110 <_vfprintf_r+0x12e4>
800090f2:	f2 cb ff fc 	sub	r11,r9,-4
800090f6:	51 0b       	stdsp	sp[0x40],r11
800090f8:	fa c6 f9 44 	sub	r6,sp,-1724
800090fc:	72 0b       	ld.w	r11,r9[0x0]
800090fe:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009102:	f3 4b fd 88 	st.w	r9[-632],r11
80009106:	2f f8       	sub	r8,-1
80009108:	14 97       	mov	r7,r10
8000910a:	fb 48 06 b4 	st.w	sp[1716],r8
8000910e:	c0 58       	rjmp	80009118 <_vfprintf_r+0x12ec>
80009110:	72 0b       	ld.w	r11,r9[0x0]
80009112:	14 97       	mov	r7,r10
80009114:	2f c9       	sub	r9,-4
80009116:	51 09       	stdsp	sp[0x40],r9
80009118:	50 1b       	stdsp	sp[0x4],r11
8000911a:	30 0e       	mov	lr,0
8000911c:	30 18       	mov	r8,1
8000911e:	50 0e       	stdsp	sp[0x0],lr
80009120:	c2 29       	rjmp	80009364 <_vfprintf_r+0x1538>
80009122:	50 a7       	stdsp	sp[0x28],r7
80009124:	50 80       	stdsp	sp[0x20],r0
80009126:	0c 97       	mov	r7,r6
80009128:	04 94       	mov	r4,r2
8000912a:	06 96       	mov	r6,r3
8000912c:	02 92       	mov	r2,r1
8000912e:	fe cc b4 76 	sub	r12,pc,-19338
80009132:	40 93       	lddsp	r3,sp[0x24]
80009134:	10 90       	mov	r0,r8
80009136:	40 41       	lddsp	r1,sp[0x10]
80009138:	50 dc       	stdsp	sp[0x34],r12
8000913a:	ed b5 00 05 	bld	r5,0x5
8000913e:	c5 51       	brne	800091e8 <_vfprintf_r+0x13bc>
80009140:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009144:	40 3b       	lddsp	r11,sp[0xc]
80009146:	58 0b       	cp.w	r11,0
80009148:	c2 20       	breq	8000918c <_vfprintf_r+0x1360>
8000914a:	10 36       	cp.w	r6,r8
8000914c:	c0 a4       	brge	80009160 <_vfprintf_r+0x1334>
8000914e:	fa ca f9 44 	sub	r10,sp,-1724
80009152:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009156:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000915a:	fa e9 00 00 	st.d	sp[0],r8
8000915e:	cf 28       	rjmp	80009342 <_vfprintf_r+0x1516>
80009160:	fa c8 f9 50 	sub	r8,sp,-1712
80009164:	1a d8       	st.w	--sp,r8
80009166:	fa c8 fa b8 	sub	r8,sp,-1352
8000916a:	04 9a       	mov	r10,r2
8000916c:	1a d8       	st.w	--sp,r8
8000916e:	0c 9b       	mov	r11,r6
80009170:	fa c8 fb b4 	sub	r8,sp,-1100
80009174:	08 9c       	mov	r12,r4
80009176:	1a d8       	st.w	--sp,r8
80009178:	fa c8 f9 40 	sub	r8,sp,-1728
8000917c:	fa c9 ff b4 	sub	r9,sp,-76
80009180:	fe b0 f4 be 	rcall	80007afc <get_arg>
80009184:	2f dd       	sub	sp,-12
80009186:	f8 ea 00 00 	ld.d	r10,r12[0]
8000918a:	c0 c8       	rjmp	800091a2 <_vfprintf_r+0x1376>
8000918c:	ee ca ff ff 	sub	r10,r7,-1
80009190:	10 37       	cp.w	r7,r8
80009192:	c0 b4       	brge	800091a8 <_vfprintf_r+0x137c>
80009194:	fa c9 f9 44 	sub	r9,sp,-1724
80009198:	14 97       	mov	r7,r10
8000919a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000919e:	ec ea fd 88 	ld.d	r10,r6[-632]
800091a2:	fa eb 00 00 	st.d	sp[0],r10
800091a6:	cc e8       	rjmp	80009342 <_vfprintf_r+0x1516>
800091a8:	41 09       	lddsp	r9,sp[0x40]
800091aa:	59 f8       	cp.w	r8,31
800091ac:	e0 89 00 16 	brgt	800091d8 <_vfprintf_r+0x13ac>
800091b0:	f2 e6 00 00 	ld.d	r6,r9[0]
800091b4:	f2 cb ff f8 	sub	r11,r9,-8
800091b8:	fa e7 00 00 	st.d	sp[0],r6
800091bc:	51 0b       	stdsp	sp[0x40],r11
800091be:	fa c6 f9 44 	sub	r6,sp,-1724
800091c2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800091c6:	fa e6 00 00 	ld.d	r6,sp[0]
800091ca:	f2 e7 fd 88 	st.d	r9[-632],r6
800091ce:	2f f8       	sub	r8,-1
800091d0:	14 97       	mov	r7,r10
800091d2:	fb 48 06 b4 	st.w	sp[1716],r8
800091d6:	cb 68       	rjmp	80009342 <_vfprintf_r+0x1516>
800091d8:	f2 e6 00 00 	ld.d	r6,r9[0]
800091dc:	2f 89       	sub	r9,-8
800091de:	fa e7 00 00 	st.d	sp[0],r6
800091e2:	51 09       	stdsp	sp[0x40],r9
800091e4:	14 97       	mov	r7,r10
800091e6:	ca e8       	rjmp	80009342 <_vfprintf_r+0x1516>
800091e8:	ed b5 00 04 	bld	r5,0x4
800091ec:	c1 71       	brne	8000921a <_vfprintf_r+0x13ee>
800091ee:	fa f8 06 b4 	ld.w	r8,sp[1716]
800091f2:	40 3e       	lddsp	lr,sp[0xc]
800091f4:	58 0e       	cp.w	lr,0
800091f6:	c0 80       	breq	80009206 <_vfprintf_r+0x13da>
800091f8:	10 36       	cp.w	r6,r8
800091fa:	c6 94       	brge	800092cc <_vfprintf_r+0x14a0>
800091fc:	fa cc f9 44 	sub	r12,sp,-1724
80009200:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009204:	c8 28       	rjmp	80009308 <_vfprintf_r+0x14dc>
80009206:	ee ca ff ff 	sub	r10,r7,-1
8000920a:	10 37       	cp.w	r7,r8
8000920c:	e0 84 00 81 	brge	8000930e <_vfprintf_r+0x14e2>
80009210:	fa cb f9 44 	sub	r11,sp,-1724
80009214:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009218:	c7 78       	rjmp	80009306 <_vfprintf_r+0x14da>
8000921a:	ed b5 00 06 	bld	r5,0x6
8000921e:	c4 b1       	brne	800092b4 <_vfprintf_r+0x1488>
80009220:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009224:	40 3c       	lddsp	r12,sp[0xc]
80009226:	58 0c       	cp.w	r12,0
80009228:	c1 d0       	breq	80009262 <_vfprintf_r+0x1436>
8000922a:	10 36       	cp.w	r6,r8
8000922c:	c0 64       	brge	80009238 <_vfprintf_r+0x140c>
8000922e:	fa cb f9 44 	sub	r11,sp,-1724
80009232:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009236:	c1 f8       	rjmp	80009274 <_vfprintf_r+0x1448>
80009238:	fa c8 f9 50 	sub	r8,sp,-1712
8000923c:	1a d8       	st.w	--sp,r8
8000923e:	fa c8 fa b8 	sub	r8,sp,-1352
80009242:	1a d8       	st.w	--sp,r8
80009244:	fa c8 fb b4 	sub	r8,sp,-1100
80009248:	1a d8       	st.w	--sp,r8
8000924a:	fa c8 f9 40 	sub	r8,sp,-1728
8000924e:	fa c9 ff b4 	sub	r9,sp,-76
80009252:	04 9a       	mov	r10,r2
80009254:	0c 9b       	mov	r11,r6
80009256:	08 9c       	mov	r12,r4
80009258:	fe b0 f4 52 	rcall	80007afc <get_arg>
8000925c:	2f dd       	sub	sp,-12
8000925e:	98 18       	ld.sh	r8,r12[0x2]
80009260:	c2 78       	rjmp	800092ae <_vfprintf_r+0x1482>
80009262:	ee ca ff ff 	sub	r10,r7,-1
80009266:	10 37       	cp.w	r7,r8
80009268:	c0 a4       	brge	8000927c <_vfprintf_r+0x1450>
8000926a:	fa c9 f9 44 	sub	r9,sp,-1724
8000926e:	14 97       	mov	r7,r10
80009270:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009274:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009278:	c1 b8       	rjmp	800092ae <_vfprintf_r+0x1482>
8000927a:	d7 03       	nop
8000927c:	41 09       	lddsp	r9,sp[0x40]
8000927e:	59 f8       	cp.w	r8,31
80009280:	e0 89 00 13 	brgt	800092a6 <_vfprintf_r+0x147a>
80009284:	f2 cb ff fc 	sub	r11,r9,-4
80009288:	51 0b       	stdsp	sp[0x40],r11
8000928a:	72 09       	ld.w	r9,r9[0x0]
8000928c:	fa c6 f9 44 	sub	r6,sp,-1724
80009290:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009294:	2f f8       	sub	r8,-1
80009296:	f7 49 fd 88 	st.w	r11[-632],r9
8000929a:	fb 48 06 b4 	st.w	sp[1716],r8
8000929e:	14 97       	mov	r7,r10
800092a0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800092a4:	c0 58       	rjmp	800092ae <_vfprintf_r+0x1482>
800092a6:	92 18       	ld.sh	r8,r9[0x2]
800092a8:	14 97       	mov	r7,r10
800092aa:	2f c9       	sub	r9,-4
800092ac:	51 09       	stdsp	sp[0x40],r9
800092ae:	5c 78       	castu.h	r8
800092b0:	50 18       	stdsp	sp[0x4],r8
800092b2:	c4 68       	rjmp	8000933e <_vfprintf_r+0x1512>
800092b4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800092b8:	40 3c       	lddsp	r12,sp[0xc]
800092ba:	58 0c       	cp.w	r12,0
800092bc:	c1 d0       	breq	800092f6 <_vfprintf_r+0x14ca>
800092be:	10 36       	cp.w	r6,r8
800092c0:	c0 64       	brge	800092cc <_vfprintf_r+0x14a0>
800092c2:	fa cb f9 44 	sub	r11,sp,-1724
800092c6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800092ca:	c1 f8       	rjmp	80009308 <_vfprintf_r+0x14dc>
800092cc:	fa c8 f9 50 	sub	r8,sp,-1712
800092d0:	1a d8       	st.w	--sp,r8
800092d2:	fa c8 fa b8 	sub	r8,sp,-1352
800092d6:	0c 9b       	mov	r11,r6
800092d8:	1a d8       	st.w	--sp,r8
800092da:	fa c8 fb b4 	sub	r8,sp,-1100
800092de:	04 9a       	mov	r10,r2
800092e0:	1a d8       	st.w	--sp,r8
800092e2:	08 9c       	mov	r12,r4
800092e4:	fa c8 f9 40 	sub	r8,sp,-1728
800092e8:	fa c9 ff b4 	sub	r9,sp,-76
800092ec:	fe b0 f4 08 	rcall	80007afc <get_arg>
800092f0:	2f dd       	sub	sp,-12
800092f2:	78 0b       	ld.w	r11,r12[0x0]
800092f4:	c2 48       	rjmp	8000933c <_vfprintf_r+0x1510>
800092f6:	ee ca ff ff 	sub	r10,r7,-1
800092fa:	10 37       	cp.w	r7,r8
800092fc:	c0 94       	brge	8000930e <_vfprintf_r+0x14e2>
800092fe:	fa c9 f9 44 	sub	r9,sp,-1724
80009302:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009306:	14 97       	mov	r7,r10
80009308:	ec fb fd 88 	ld.w	r11,r6[-632]
8000930c:	c1 88       	rjmp	8000933c <_vfprintf_r+0x1510>
8000930e:	41 09       	lddsp	r9,sp[0x40]
80009310:	59 f8       	cp.w	r8,31
80009312:	e0 89 00 11 	brgt	80009334 <_vfprintf_r+0x1508>
80009316:	f2 cb ff fc 	sub	r11,r9,-4
8000931a:	51 0b       	stdsp	sp[0x40],r11
8000931c:	fa c6 f9 44 	sub	r6,sp,-1724
80009320:	72 0b       	ld.w	r11,r9[0x0]
80009322:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009326:	f3 4b fd 88 	st.w	r9[-632],r11
8000932a:	2f f8       	sub	r8,-1
8000932c:	14 97       	mov	r7,r10
8000932e:	fb 48 06 b4 	st.w	sp[1716],r8
80009332:	c0 58       	rjmp	8000933c <_vfprintf_r+0x1510>
80009334:	72 0b       	ld.w	r11,r9[0x0]
80009336:	14 97       	mov	r7,r10
80009338:	2f c9       	sub	r9,-4
8000933a:	51 09       	stdsp	sp[0x40],r9
8000933c:	50 1b       	stdsp	sp[0x4],r11
8000933e:	30 0e       	mov	lr,0
80009340:	50 0e       	stdsp	sp[0x0],lr
80009342:	40 08       	lddsp	r8,sp[0x0]
80009344:	40 1c       	lddsp	r12,sp[0x4]
80009346:	18 48       	or	r8,r12
80009348:	5f 19       	srne	r9
8000934a:	0a 98       	mov	r8,r5
8000934c:	eb e9 00 09 	and	r9,r5,r9
80009350:	a1 b8       	sbr	r8,0x1
80009352:	58 09       	cp.w	r9,0
80009354:	c0 70       	breq	80009362 <_vfprintf_r+0x1536>
80009356:	10 95       	mov	r5,r8
80009358:	fb 60 06 b9 	st.b	sp[1721],r0
8000935c:	33 08       	mov	r8,48
8000935e:	fb 68 06 b8 	st.b	sp[1720],r8
80009362:	30 28       	mov	r8,2
80009364:	30 09       	mov	r9,0
80009366:	fb 69 06 bb 	st.b	sp[1723],r9
8000936a:	0a 99       	mov	r9,r5
8000936c:	a7 d9       	cbr	r9,0x7
8000936e:	40 2b       	lddsp	r11,sp[0x8]
80009370:	40 16       	lddsp	r6,sp[0x4]
80009372:	58 0b       	cp.w	r11,0
80009374:	5f 1a       	srne	r10
80009376:	f2 05 17 40 	movge	r5,r9
8000937a:	fa c2 f9 78 	sub	r2,sp,-1672
8000937e:	40 09       	lddsp	r9,sp[0x0]
80009380:	0c 49       	or	r9,r6
80009382:	5f 19       	srne	r9
80009384:	f5 e9 10 09 	or	r9,r10,r9
80009388:	c5 c0       	breq	80009440 <_vfprintf_r+0x1614>
8000938a:	30 19       	mov	r9,1
8000938c:	f2 08 18 00 	cp.b	r8,r9
80009390:	c0 60       	breq	8000939c <_vfprintf_r+0x1570>
80009392:	30 29       	mov	r9,2
80009394:	f2 08 18 00 	cp.b	r8,r9
80009398:	c0 41       	brne	800093a0 <_vfprintf_r+0x1574>
8000939a:	c3 c8       	rjmp	80009412 <_vfprintf_r+0x15e6>
8000939c:	04 96       	mov	r6,r2
8000939e:	c3 08       	rjmp	800093fe <_vfprintf_r+0x15d2>
800093a0:	04 96       	mov	r6,r2
800093a2:	fa e8 00 00 	ld.d	r8,sp[0]
800093a6:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800093aa:	2d 0a       	sub	r10,-48
800093ac:	0c fa       	st.b	--r6,r10
800093ae:	f0 0b 16 03 	lsr	r11,r8,0x3
800093b2:	f2 0c 16 03 	lsr	r12,r9,0x3
800093b6:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
800093ba:	18 99       	mov	r9,r12
800093bc:	16 98       	mov	r8,r11
800093be:	58 08       	cp.w	r8,0
800093c0:	5c 29       	cpc	r9
800093c2:	cf 21       	brne	800093a6 <_vfprintf_r+0x157a>
800093c4:	fa e9 00 00 	st.d	sp[0],r8
800093c8:	ed b5 00 00 	bld	r5,0x0
800093cc:	c4 51       	brne	80009456 <_vfprintf_r+0x162a>
800093ce:	33 09       	mov	r9,48
800093d0:	f2 0a 18 00 	cp.b	r10,r9
800093d4:	c4 10       	breq	80009456 <_vfprintf_r+0x162a>
800093d6:	0c f9       	st.b	--r6,r9
800093d8:	c3 f8       	rjmp	80009456 <_vfprintf_r+0x162a>
800093da:	fa ea 00 00 	ld.d	r10,sp[0]
800093de:	30 a8       	mov	r8,10
800093e0:	30 09       	mov	r9,0
800093e2:	e0 a0 1a 19 	rcall	8000c814 <__avr32_umod64>
800093e6:	30 a8       	mov	r8,10
800093e8:	2d 0a       	sub	r10,-48
800093ea:	30 09       	mov	r9,0
800093ec:	ac 8a       	st.b	r6[0x0],r10
800093ee:	fa ea 00 00 	ld.d	r10,sp[0]
800093f2:	e0 a0 18 df 	rcall	8000c5b0 <__avr32_udiv64>
800093f6:	16 99       	mov	r9,r11
800093f8:	14 98       	mov	r8,r10
800093fa:	fa e9 00 00 	st.d	sp[0],r8
800093fe:	20 16       	sub	r6,1
80009400:	fa ea 00 00 	ld.d	r10,sp[0]
80009404:	58 9a       	cp.w	r10,9
80009406:	5c 2b       	cpc	r11
80009408:	fe 9b ff e9 	brhi	800093da <_vfprintf_r+0x15ae>
8000940c:	1b f8       	ld.ub	r8,sp[0x7]
8000940e:	2d 08       	sub	r8,-48
80009410:	c2 08       	rjmp	80009450 <_vfprintf_r+0x1624>
80009412:	04 96       	mov	r6,r2
80009414:	fa e8 00 00 	ld.d	r8,sp[0]
80009418:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000941c:	40 de       	lddsp	lr,sp[0x34]
8000941e:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80009422:	0c fa       	st.b	--r6,r10
80009424:	f2 0b 16 04 	lsr	r11,r9,0x4
80009428:	f0 0a 16 04 	lsr	r10,r8,0x4
8000942c:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009430:	16 99       	mov	r9,r11
80009432:	14 98       	mov	r8,r10
80009434:	58 08       	cp.w	r8,0
80009436:	5c 29       	cpc	r9
80009438:	cf 01       	brne	80009418 <_vfprintf_r+0x15ec>
8000943a:	fa e9 00 00 	st.d	sp[0],r8
8000943e:	c0 c8       	rjmp	80009456 <_vfprintf_r+0x162a>
80009440:	58 08       	cp.w	r8,0
80009442:	c0 91       	brne	80009454 <_vfprintf_r+0x1628>
80009444:	ed b5 00 00 	bld	r5,0x0
80009448:	c0 61       	brne	80009454 <_vfprintf_r+0x1628>
8000944a:	fa c6 f9 79 	sub	r6,sp,-1671
8000944e:	33 08       	mov	r8,48
80009450:	ac 88       	st.b	r6[0x0],r8
80009452:	c0 28       	rjmp	80009456 <_vfprintf_r+0x162a>
80009454:	04 96       	mov	r6,r2
80009456:	0c 12       	sub	r2,r6
80009458:	c1 c8       	rjmp	80009490 <_vfprintf_r+0x1664>
8000945a:	50 a7       	stdsp	sp[0x28],r7
8000945c:	50 80       	stdsp	sp[0x20],r0
8000945e:	40 93       	lddsp	r3,sp[0x24]
80009460:	0c 97       	mov	r7,r6
80009462:	10 90       	mov	r0,r8
80009464:	04 94       	mov	r4,r2
80009466:	40 41       	lddsp	r1,sp[0x10]
80009468:	58 08       	cp.w	r8,0
8000946a:	e0 80 04 4f 	breq	80009d08 <_vfprintf_r+0x1edc>
8000946e:	fb 68 06 60 	st.b	sp[1632],r8
80009472:	30 0c       	mov	r12,0
80009474:	30 08       	mov	r8,0
80009476:	30 12       	mov	r2,1
80009478:	fb 68 06 bb 	st.b	sp[1723],r8
8000947c:	50 2c       	stdsp	sp[0x8],r12
8000947e:	fa c6 f9 a0 	sub	r6,sp,-1632
80009482:	c0 78       	rjmp	80009490 <_vfprintf_r+0x1664>
80009484:	30 0b       	mov	r11,0
80009486:	50 2b       	stdsp	sp[0x8],r11
80009488:	c0 48       	rjmp	80009490 <_vfprintf_r+0x1664>
8000948a:	40 22       	lddsp	r2,sp[0x8]
8000948c:	30 0a       	mov	r10,0
8000948e:	50 2a       	stdsp	sp[0x8],r10
80009490:	40 29       	lddsp	r9,sp[0x8]
80009492:	e4 09 0c 49 	max	r9,r2,r9
80009496:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000949a:	50 39       	stdsp	sp[0xc],r9
8000949c:	0a 9e       	mov	lr,r5
8000949e:	30 09       	mov	r9,0
800094a0:	e2 1e 00 02 	andl	lr,0x2,COH
800094a4:	f2 08 18 00 	cp.b	r8,r9
800094a8:	fb f8 10 03 	ld.wne	r8,sp[0xc]
800094ac:	f7 b8 01 ff 	subne	r8,-1
800094b0:	fb f8 1a 03 	st.wne	sp[0xc],r8
800094b4:	0a 9b       	mov	r11,r5
800094b6:	58 0e       	cp.w	lr,0
800094b8:	fb fc 10 03 	ld.wne	r12,sp[0xc]
800094bc:	f7 bc 01 fe 	subne	r12,-2
800094c0:	fb fc 1a 03 	st.wne	sp[0xc],r12
800094c4:	e2 1b 00 84 	andl	r11,0x84,COH
800094c8:	50 fe       	stdsp	sp[0x3c],lr
800094ca:	50 9b       	stdsp	sp[0x24],r11
800094cc:	c4 71       	brne	8000955a <_vfprintf_r+0x172e>
800094ce:	40 8a       	lddsp	r10,sp[0x20]
800094d0:	40 39       	lddsp	r9,sp[0xc]
800094d2:	12 1a       	sub	r10,r9
800094d4:	50 4a       	stdsp	sp[0x10],r10
800094d6:	58 0a       	cp.w	r10,0
800094d8:	e0 89 00 20 	brgt	80009518 <_vfprintf_r+0x16ec>
800094dc:	c3 f8       	rjmp	8000955a <_vfprintf_r+0x172e>
800094de:	2f 09       	sub	r9,-16
800094e0:	2f f8       	sub	r8,-1
800094e2:	fe ce b8 12 	sub	lr,pc,-18414
800094e6:	31 0c       	mov	r12,16
800094e8:	fb 49 06 90 	st.w	sp[1680],r9
800094ec:	87 0e       	st.w	r3[0x0],lr
800094ee:	87 1c       	st.w	r3[0x4],r12
800094f0:	fb 48 06 8c 	st.w	sp[1676],r8
800094f4:	58 78       	cp.w	r8,7
800094f6:	e0 89 00 04 	brgt	800094fe <_vfprintf_r+0x16d2>
800094fa:	2f 83       	sub	r3,-8
800094fc:	c0 b8       	rjmp	80009512 <_vfprintf_r+0x16e6>
800094fe:	fa ca f9 78 	sub	r10,sp,-1672
80009502:	02 9b       	mov	r11,r1
80009504:	08 9c       	mov	r12,r4
80009506:	fe b0 f4 85 	rcall	80007e10 <__sprint_r>
8000950a:	e0 81 04 10 	brne	80009d2a <_vfprintf_r+0x1efe>
8000950e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009512:	40 4b       	lddsp	r11,sp[0x10]
80009514:	21 0b       	sub	r11,16
80009516:	50 4b       	stdsp	sp[0x10],r11
80009518:	fa f9 06 90 	ld.w	r9,sp[1680]
8000951c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009520:	fe ca b8 50 	sub	r10,pc,-18352
80009524:	40 4e       	lddsp	lr,sp[0x10]
80009526:	59 0e       	cp.w	lr,16
80009528:	fe 99 ff db 	brgt	800094de <_vfprintf_r+0x16b2>
8000952c:	1c 09       	add	r9,lr
8000952e:	2f f8       	sub	r8,-1
80009530:	87 0a       	st.w	r3[0x0],r10
80009532:	fb 49 06 90 	st.w	sp[1680],r9
80009536:	87 1e       	st.w	r3[0x4],lr
80009538:	fb 48 06 8c 	st.w	sp[1676],r8
8000953c:	58 78       	cp.w	r8,7
8000953e:	e0 89 00 04 	brgt	80009546 <_vfprintf_r+0x171a>
80009542:	2f 83       	sub	r3,-8
80009544:	c0 b8       	rjmp	8000955a <_vfprintf_r+0x172e>
80009546:	fa ca f9 78 	sub	r10,sp,-1672
8000954a:	02 9b       	mov	r11,r1
8000954c:	08 9c       	mov	r12,r4
8000954e:	fe b0 f4 61 	rcall	80007e10 <__sprint_r>
80009552:	e0 81 03 ec 	brne	80009d2a <_vfprintf_r+0x1efe>
80009556:	fa c3 f9 e0 	sub	r3,sp,-1568
8000955a:	30 09       	mov	r9,0
8000955c:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009560:	f2 08 18 00 	cp.b	r8,r9
80009564:	c1 f0       	breq	800095a2 <_vfprintf_r+0x1776>
80009566:	fa f8 06 90 	ld.w	r8,sp[1680]
8000956a:	fa c9 f9 45 	sub	r9,sp,-1723
8000956e:	2f f8       	sub	r8,-1
80009570:	87 09       	st.w	r3[0x0],r9
80009572:	fb 48 06 90 	st.w	sp[1680],r8
80009576:	30 19       	mov	r9,1
80009578:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000957c:	87 19       	st.w	r3[0x4],r9
8000957e:	2f f8       	sub	r8,-1
80009580:	fb 48 06 8c 	st.w	sp[1676],r8
80009584:	58 78       	cp.w	r8,7
80009586:	e0 89 00 04 	brgt	8000958e <_vfprintf_r+0x1762>
8000958a:	2f 83       	sub	r3,-8
8000958c:	c0 b8       	rjmp	800095a2 <_vfprintf_r+0x1776>
8000958e:	fa ca f9 78 	sub	r10,sp,-1672
80009592:	02 9b       	mov	r11,r1
80009594:	08 9c       	mov	r12,r4
80009596:	fe b0 f4 3d 	rcall	80007e10 <__sprint_r>
8000959a:	e0 81 03 c8 	brne	80009d2a <_vfprintf_r+0x1efe>
8000959e:	fa c3 f9 e0 	sub	r3,sp,-1568
800095a2:	40 fc       	lddsp	r12,sp[0x3c]
800095a4:	58 0c       	cp.w	r12,0
800095a6:	c1 f0       	breq	800095e4 <_vfprintf_r+0x17b8>
800095a8:	fa f8 06 90 	ld.w	r8,sp[1680]
800095ac:	fa c9 f9 48 	sub	r9,sp,-1720
800095b0:	2f e8       	sub	r8,-2
800095b2:	87 09       	st.w	r3[0x0],r9
800095b4:	fb 48 06 90 	st.w	sp[1680],r8
800095b8:	30 29       	mov	r9,2
800095ba:	fa f8 06 8c 	ld.w	r8,sp[1676]
800095be:	87 19       	st.w	r3[0x4],r9
800095c0:	2f f8       	sub	r8,-1
800095c2:	fb 48 06 8c 	st.w	sp[1676],r8
800095c6:	58 78       	cp.w	r8,7
800095c8:	e0 89 00 04 	brgt	800095d0 <_vfprintf_r+0x17a4>
800095cc:	2f 83       	sub	r3,-8
800095ce:	c0 b8       	rjmp	800095e4 <_vfprintf_r+0x17b8>
800095d0:	fa ca f9 78 	sub	r10,sp,-1672
800095d4:	02 9b       	mov	r11,r1
800095d6:	08 9c       	mov	r12,r4
800095d8:	fe b0 f4 1c 	rcall	80007e10 <__sprint_r>
800095dc:	e0 81 03 a7 	brne	80009d2a <_vfprintf_r+0x1efe>
800095e0:	fa c3 f9 e0 	sub	r3,sp,-1568
800095e4:	40 9b       	lddsp	r11,sp[0x24]
800095e6:	e0 4b 00 80 	cp.w	r11,128
800095ea:	c4 71       	brne	80009678 <_vfprintf_r+0x184c>
800095ec:	40 8a       	lddsp	r10,sp[0x20]
800095ee:	40 39       	lddsp	r9,sp[0xc]
800095f0:	12 1a       	sub	r10,r9
800095f2:	50 4a       	stdsp	sp[0x10],r10
800095f4:	58 0a       	cp.w	r10,0
800095f6:	e0 89 00 20 	brgt	80009636 <_vfprintf_r+0x180a>
800095fa:	c3 f8       	rjmp	80009678 <_vfprintf_r+0x184c>
800095fc:	2f 09       	sub	r9,-16
800095fe:	2f f8       	sub	r8,-1
80009600:	fe ce b9 20 	sub	lr,pc,-18144
80009604:	31 0c       	mov	r12,16
80009606:	fb 49 06 90 	st.w	sp[1680],r9
8000960a:	87 0e       	st.w	r3[0x0],lr
8000960c:	87 1c       	st.w	r3[0x4],r12
8000960e:	fb 48 06 8c 	st.w	sp[1676],r8
80009612:	58 78       	cp.w	r8,7
80009614:	e0 89 00 04 	brgt	8000961c <_vfprintf_r+0x17f0>
80009618:	2f 83       	sub	r3,-8
8000961a:	c0 b8       	rjmp	80009630 <_vfprintf_r+0x1804>
8000961c:	fa ca f9 78 	sub	r10,sp,-1672
80009620:	02 9b       	mov	r11,r1
80009622:	08 9c       	mov	r12,r4
80009624:	fe b0 f3 f6 	rcall	80007e10 <__sprint_r>
80009628:	e0 81 03 81 	brne	80009d2a <_vfprintf_r+0x1efe>
8000962c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009630:	40 4b       	lddsp	r11,sp[0x10]
80009632:	21 0b       	sub	r11,16
80009634:	50 4b       	stdsp	sp[0x10],r11
80009636:	fa f9 06 90 	ld.w	r9,sp[1680]
8000963a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000963e:	fe ca b9 5e 	sub	r10,pc,-18082
80009642:	40 4e       	lddsp	lr,sp[0x10]
80009644:	59 0e       	cp.w	lr,16
80009646:	fe 99 ff db 	brgt	800095fc <_vfprintf_r+0x17d0>
8000964a:	1c 09       	add	r9,lr
8000964c:	2f f8       	sub	r8,-1
8000964e:	87 0a       	st.w	r3[0x0],r10
80009650:	fb 49 06 90 	st.w	sp[1680],r9
80009654:	87 1e       	st.w	r3[0x4],lr
80009656:	fb 48 06 8c 	st.w	sp[1676],r8
8000965a:	58 78       	cp.w	r8,7
8000965c:	e0 89 00 04 	brgt	80009664 <_vfprintf_r+0x1838>
80009660:	2f 83       	sub	r3,-8
80009662:	c0 b8       	rjmp	80009678 <_vfprintf_r+0x184c>
80009664:	fa ca f9 78 	sub	r10,sp,-1672
80009668:	02 9b       	mov	r11,r1
8000966a:	08 9c       	mov	r12,r4
8000966c:	fe b0 f3 d2 	rcall	80007e10 <__sprint_r>
80009670:	e0 81 03 5d 	brne	80009d2a <_vfprintf_r+0x1efe>
80009674:	fa c3 f9 e0 	sub	r3,sp,-1568
80009678:	40 2c       	lddsp	r12,sp[0x8]
8000967a:	04 1c       	sub	r12,r2
8000967c:	50 2c       	stdsp	sp[0x8],r12
8000967e:	58 0c       	cp.w	r12,0
80009680:	e0 89 00 20 	brgt	800096c0 <_vfprintf_r+0x1894>
80009684:	c3 f8       	rjmp	80009702 <_vfprintf_r+0x18d6>
80009686:	2f 09       	sub	r9,-16
80009688:	2f f8       	sub	r8,-1
8000968a:	fe cb b9 aa 	sub	r11,pc,-18006
8000968e:	31 0a       	mov	r10,16
80009690:	fb 49 06 90 	st.w	sp[1680],r9
80009694:	87 0b       	st.w	r3[0x0],r11
80009696:	87 1a       	st.w	r3[0x4],r10
80009698:	fb 48 06 8c 	st.w	sp[1676],r8
8000969c:	58 78       	cp.w	r8,7
8000969e:	e0 89 00 04 	brgt	800096a6 <_vfprintf_r+0x187a>
800096a2:	2f 83       	sub	r3,-8
800096a4:	c0 b8       	rjmp	800096ba <_vfprintf_r+0x188e>
800096a6:	fa ca f9 78 	sub	r10,sp,-1672
800096aa:	02 9b       	mov	r11,r1
800096ac:	08 9c       	mov	r12,r4
800096ae:	fe b0 f3 b1 	rcall	80007e10 <__sprint_r>
800096b2:	e0 81 03 3c 	brne	80009d2a <_vfprintf_r+0x1efe>
800096b6:	fa c3 f9 e0 	sub	r3,sp,-1568
800096ba:	40 29       	lddsp	r9,sp[0x8]
800096bc:	21 09       	sub	r9,16
800096be:	50 29       	stdsp	sp[0x8],r9
800096c0:	fa f9 06 90 	ld.w	r9,sp[1680]
800096c4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096c8:	fe ca b9 e8 	sub	r10,pc,-17944
800096cc:	40 2e       	lddsp	lr,sp[0x8]
800096ce:	59 0e       	cp.w	lr,16
800096d0:	fe 99 ff db 	brgt	80009686 <_vfprintf_r+0x185a>
800096d4:	1c 09       	add	r9,lr
800096d6:	2f f8       	sub	r8,-1
800096d8:	87 0a       	st.w	r3[0x0],r10
800096da:	fb 49 06 90 	st.w	sp[1680],r9
800096de:	87 1e       	st.w	r3[0x4],lr
800096e0:	fb 48 06 8c 	st.w	sp[1676],r8
800096e4:	58 78       	cp.w	r8,7
800096e6:	e0 89 00 04 	brgt	800096ee <_vfprintf_r+0x18c2>
800096ea:	2f 83       	sub	r3,-8
800096ec:	c0 b8       	rjmp	80009702 <_vfprintf_r+0x18d6>
800096ee:	fa ca f9 78 	sub	r10,sp,-1672
800096f2:	02 9b       	mov	r11,r1
800096f4:	08 9c       	mov	r12,r4
800096f6:	fe b0 f3 8d 	rcall	80007e10 <__sprint_r>
800096fa:	e0 81 03 18 	brne	80009d2a <_vfprintf_r+0x1efe>
800096fe:	fa c3 f9 e0 	sub	r3,sp,-1568
80009702:	ed b5 00 08 	bld	r5,0x8
80009706:	c0 b0       	breq	8000971c <_vfprintf_r+0x18f0>
80009708:	fa f8 06 90 	ld.w	r8,sp[1680]
8000970c:	87 12       	st.w	r3[0x4],r2
8000970e:	87 06       	st.w	r3[0x0],r6
80009710:	f0 02 00 02 	add	r2,r8,r2
80009714:	fb 42 06 90 	st.w	sp[1680],r2
80009718:	e0 8f 01 d4 	bral	80009ac0 <_vfprintf_r+0x1c94>
8000971c:	e0 40 00 65 	cp.w	r0,101
80009720:	e0 8a 01 d6 	brle	80009acc <_vfprintf_r+0x1ca0>
80009724:	30 08       	mov	r8,0
80009726:	30 09       	mov	r9,0
80009728:	40 5b       	lddsp	r11,sp[0x14]
8000972a:	40 7a       	lddsp	r10,sp[0x1c]
8000972c:	e0 a0 15 3b 	rcall	8000c1a2 <__avr32_f64_cmp_eq>
80009730:	c7 90       	breq	80009822 <_vfprintf_r+0x19f6>
80009732:	fa f8 06 90 	ld.w	r8,sp[1680]
80009736:	fe c9 ba 6a 	sub	r9,pc,-17814
8000973a:	2f f8       	sub	r8,-1
8000973c:	87 09       	st.w	r3[0x0],r9
8000973e:	fb 48 06 90 	st.w	sp[1680],r8
80009742:	30 19       	mov	r9,1
80009744:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009748:	87 19       	st.w	r3[0x4],r9
8000974a:	2f f8       	sub	r8,-1
8000974c:	fb 48 06 8c 	st.w	sp[1676],r8
80009750:	58 78       	cp.w	r8,7
80009752:	e0 89 00 05 	brgt	8000975c <_vfprintf_r+0x1930>
80009756:	2f 83       	sub	r3,-8
80009758:	c0 c8       	rjmp	80009770 <_vfprintf_r+0x1944>
8000975a:	d7 03       	nop
8000975c:	fa ca f9 78 	sub	r10,sp,-1672
80009760:	02 9b       	mov	r11,r1
80009762:	08 9c       	mov	r12,r4
80009764:	fe b0 f3 56 	rcall	80007e10 <__sprint_r>
80009768:	e0 81 02 e1 	brne	80009d2a <_vfprintf_r+0x1efe>
8000976c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009770:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009774:	40 6c       	lddsp	r12,sp[0x18]
80009776:	18 38       	cp.w	r8,r12
80009778:	c0 55       	brlt	80009782 <_vfprintf_r+0x1956>
8000977a:	ed b5 00 00 	bld	r5,0x0
8000977e:	e0 81 02 6b 	brne	80009c54 <_vfprintf_r+0x1e28>
80009782:	fa f8 06 90 	ld.w	r8,sp[1680]
80009786:	2f f8       	sub	r8,-1
80009788:	40 cb       	lddsp	r11,sp[0x30]
8000978a:	fb 48 06 90 	st.w	sp[1680],r8
8000978e:	30 19       	mov	r9,1
80009790:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009794:	87 0b       	st.w	r3[0x0],r11
80009796:	2f f8       	sub	r8,-1
80009798:	87 19       	st.w	r3[0x4],r9
8000979a:	fb 48 06 8c 	st.w	sp[1676],r8
8000979e:	58 78       	cp.w	r8,7
800097a0:	e0 89 00 04 	brgt	800097a8 <_vfprintf_r+0x197c>
800097a4:	2f 83       	sub	r3,-8
800097a6:	c0 b8       	rjmp	800097bc <_vfprintf_r+0x1990>
800097a8:	fa ca f9 78 	sub	r10,sp,-1672
800097ac:	02 9b       	mov	r11,r1
800097ae:	08 9c       	mov	r12,r4
800097b0:	fe b0 f3 30 	rcall	80007e10 <__sprint_r>
800097b4:	e0 81 02 bb 	brne	80009d2a <_vfprintf_r+0x1efe>
800097b8:	fa c3 f9 e0 	sub	r3,sp,-1568
800097bc:	40 66       	lddsp	r6,sp[0x18]
800097be:	20 16       	sub	r6,1
800097c0:	58 06       	cp.w	r6,0
800097c2:	e0 89 00 1d 	brgt	800097fc <_vfprintf_r+0x19d0>
800097c6:	e0 8f 02 47 	bral	80009c54 <_vfprintf_r+0x1e28>
800097ca:	2f 09       	sub	r9,-16
800097cc:	2f f8       	sub	r8,-1
800097ce:	fb 49 06 90 	st.w	sp[1680],r9
800097d2:	87 02       	st.w	r3[0x0],r2
800097d4:	87 10       	st.w	r3[0x4],r0
800097d6:	fb 48 06 8c 	st.w	sp[1676],r8
800097da:	58 78       	cp.w	r8,7
800097dc:	e0 89 00 04 	brgt	800097e4 <_vfprintf_r+0x19b8>
800097e0:	2f 83       	sub	r3,-8
800097e2:	c0 b8       	rjmp	800097f8 <_vfprintf_r+0x19cc>
800097e4:	fa ca f9 78 	sub	r10,sp,-1672
800097e8:	02 9b       	mov	r11,r1
800097ea:	08 9c       	mov	r12,r4
800097ec:	fe b0 f3 12 	rcall	80007e10 <__sprint_r>
800097f0:	e0 81 02 9d 	brne	80009d2a <_vfprintf_r+0x1efe>
800097f4:	fa c3 f9 e0 	sub	r3,sp,-1568
800097f8:	21 06       	sub	r6,16
800097fa:	c0 48       	rjmp	80009802 <_vfprintf_r+0x19d6>
800097fc:	fe c2 bb 1c 	sub	r2,pc,-17636
80009800:	31 00       	mov	r0,16
80009802:	fa f9 06 90 	ld.w	r9,sp[1680]
80009806:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000980a:	fe ca bb 2a 	sub	r10,pc,-17622
8000980e:	59 06       	cp.w	r6,16
80009810:	fe 99 ff dd 	brgt	800097ca <_vfprintf_r+0x199e>
80009814:	0c 09       	add	r9,r6
80009816:	87 0a       	st.w	r3[0x0],r10
80009818:	fb 49 06 90 	st.w	sp[1680],r9
8000981c:	2f f8       	sub	r8,-1
8000981e:	87 16       	st.w	r3[0x4],r6
80009820:	c5 39       	rjmp	80009ac6 <_vfprintf_r+0x1c9a>
80009822:	fa fa 06 ac 	ld.w	r10,sp[1708]
80009826:	58 0a       	cp.w	r10,0
80009828:	e0 89 00 92 	brgt	8000994c <_vfprintf_r+0x1b20>
8000982c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009830:	fe c9 bb 64 	sub	r9,pc,-17564
80009834:	2f f8       	sub	r8,-1
80009836:	87 09       	st.w	r3[0x0],r9
80009838:	fb 48 06 90 	st.w	sp[1680],r8
8000983c:	30 19       	mov	r9,1
8000983e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009842:	87 19       	st.w	r3[0x4],r9
80009844:	2f f8       	sub	r8,-1
80009846:	fb 48 06 8c 	st.w	sp[1676],r8
8000984a:	58 78       	cp.w	r8,7
8000984c:	e0 89 00 04 	brgt	80009854 <_vfprintf_r+0x1a28>
80009850:	2f 83       	sub	r3,-8
80009852:	c0 b8       	rjmp	80009868 <_vfprintf_r+0x1a3c>
80009854:	fa ca f9 78 	sub	r10,sp,-1672
80009858:	02 9b       	mov	r11,r1
8000985a:	08 9c       	mov	r12,r4
8000985c:	fe b0 f2 da 	rcall	80007e10 <__sprint_r>
80009860:	e0 81 02 65 	brne	80009d2a <_vfprintf_r+0x1efe>
80009864:	fa c3 f9 e0 	sub	r3,sp,-1568
80009868:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000986c:	58 08       	cp.w	r8,0
8000986e:	c0 81       	brne	8000987e <_vfprintf_r+0x1a52>
80009870:	40 6a       	lddsp	r10,sp[0x18]
80009872:	58 0a       	cp.w	r10,0
80009874:	c0 51       	brne	8000987e <_vfprintf_r+0x1a52>
80009876:	ed b5 00 00 	bld	r5,0x0
8000987a:	e0 81 01 ed 	brne	80009c54 <_vfprintf_r+0x1e28>
8000987e:	40 c9       	lddsp	r9,sp[0x30]
80009880:	fa f8 06 90 	ld.w	r8,sp[1680]
80009884:	2f f8       	sub	r8,-1
80009886:	87 09       	st.w	r3[0x0],r9
80009888:	fb 48 06 90 	st.w	sp[1680],r8
8000988c:	30 19       	mov	r9,1
8000988e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009892:	87 19       	st.w	r3[0x4],r9
80009894:	2f f8       	sub	r8,-1
80009896:	fb 48 06 8c 	st.w	sp[1676],r8
8000989a:	58 78       	cp.w	r8,7
8000989c:	e0 89 00 04 	brgt	800098a4 <_vfprintf_r+0x1a78>
800098a0:	2f 83       	sub	r3,-8
800098a2:	c0 b8       	rjmp	800098b8 <_vfprintf_r+0x1a8c>
800098a4:	fa ca f9 78 	sub	r10,sp,-1672
800098a8:	02 9b       	mov	r11,r1
800098aa:	08 9c       	mov	r12,r4
800098ac:	fe b0 f2 b2 	rcall	80007e10 <__sprint_r>
800098b0:	e0 81 02 3d 	brne	80009d2a <_vfprintf_r+0x1efe>
800098b4:	fa c3 f9 e0 	sub	r3,sp,-1568
800098b8:	fa f2 06 ac 	ld.w	r2,sp[1708]
800098bc:	5c 32       	neg	r2
800098be:	58 02       	cp.w	r2,0
800098c0:	e0 89 00 1d 	brgt	800098fa <_vfprintf_r+0x1ace>
800098c4:	c3 d8       	rjmp	8000993e <_vfprintf_r+0x1b12>
800098c6:	2f 09       	sub	r9,-16
800098c8:	2f f8       	sub	r8,-1
800098ca:	31 0e       	mov	lr,16
800098cc:	fb 49 06 90 	st.w	sp[1680],r9
800098d0:	87 00       	st.w	r3[0x0],r0
800098d2:	87 1e       	st.w	r3[0x4],lr
800098d4:	fb 48 06 8c 	st.w	sp[1676],r8
800098d8:	58 78       	cp.w	r8,7
800098da:	e0 89 00 04 	brgt	800098e2 <_vfprintf_r+0x1ab6>
800098de:	2f 83       	sub	r3,-8
800098e0:	c0 b8       	rjmp	800098f6 <_vfprintf_r+0x1aca>
800098e2:	fa ca f9 78 	sub	r10,sp,-1672
800098e6:	02 9b       	mov	r11,r1
800098e8:	08 9c       	mov	r12,r4
800098ea:	fe b0 f2 93 	rcall	80007e10 <__sprint_r>
800098ee:	e0 81 02 1e 	brne	80009d2a <_vfprintf_r+0x1efe>
800098f2:	fa c3 f9 e0 	sub	r3,sp,-1568
800098f6:	21 02       	sub	r2,16
800098f8:	c0 38       	rjmp	800098fe <_vfprintf_r+0x1ad2>
800098fa:	fe c0 bc 1a 	sub	r0,pc,-17382
800098fe:	fa f9 06 90 	ld.w	r9,sp[1680]
80009902:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009906:	fe ca bc 26 	sub	r10,pc,-17370
8000990a:	59 02       	cp.w	r2,16
8000990c:	fe 99 ff dd 	brgt	800098c6 <_vfprintf_r+0x1a9a>
80009910:	04 09       	add	r9,r2
80009912:	2f f8       	sub	r8,-1
80009914:	87 0a       	st.w	r3[0x0],r10
80009916:	fb 49 06 90 	st.w	sp[1680],r9
8000991a:	87 12       	st.w	r3[0x4],r2
8000991c:	fb 48 06 8c 	st.w	sp[1676],r8
80009920:	58 78       	cp.w	r8,7
80009922:	e0 89 00 04 	brgt	8000992a <_vfprintf_r+0x1afe>
80009926:	2f 83       	sub	r3,-8
80009928:	c0 b8       	rjmp	8000993e <_vfprintf_r+0x1b12>
8000992a:	fa ca f9 78 	sub	r10,sp,-1672
8000992e:	02 9b       	mov	r11,r1
80009930:	08 9c       	mov	r12,r4
80009932:	fe b0 f2 6f 	rcall	80007e10 <__sprint_r>
80009936:	e0 81 01 fa 	brne	80009d2a <_vfprintf_r+0x1efe>
8000993a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000993e:	40 6c       	lddsp	r12,sp[0x18]
80009940:	fa f8 06 90 	ld.w	r8,sp[1680]
80009944:	87 06       	st.w	r3[0x0],r6
80009946:	87 1c       	st.w	r3[0x4],r12
80009948:	18 08       	add	r8,r12
8000994a:	cb 98       	rjmp	80009abc <_vfprintf_r+0x1c90>
8000994c:	fa f9 06 90 	ld.w	r9,sp[1680]
80009950:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009954:	40 6b       	lddsp	r11,sp[0x18]
80009956:	16 3a       	cp.w	r10,r11
80009958:	c6 f5       	brlt	80009a36 <_vfprintf_r+0x1c0a>
8000995a:	16 09       	add	r9,r11
8000995c:	2f f8       	sub	r8,-1
8000995e:	87 06       	st.w	r3[0x0],r6
80009960:	fb 49 06 90 	st.w	sp[1680],r9
80009964:	87 1b       	st.w	r3[0x4],r11
80009966:	fb 48 06 8c 	st.w	sp[1676],r8
8000996a:	58 78       	cp.w	r8,7
8000996c:	e0 89 00 04 	brgt	80009974 <_vfprintf_r+0x1b48>
80009970:	2f 83       	sub	r3,-8
80009972:	c0 b8       	rjmp	80009988 <_vfprintf_r+0x1b5c>
80009974:	fa ca f9 78 	sub	r10,sp,-1672
80009978:	02 9b       	mov	r11,r1
8000997a:	08 9c       	mov	r12,r4
8000997c:	fe b0 f2 4a 	rcall	80007e10 <__sprint_r>
80009980:	e0 81 01 d5 	brne	80009d2a <_vfprintf_r+0x1efe>
80009984:	fa c3 f9 e0 	sub	r3,sp,-1568
80009988:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000998c:	40 6a       	lddsp	r10,sp[0x18]
8000998e:	14 16       	sub	r6,r10
80009990:	58 06       	cp.w	r6,0
80009992:	e0 89 00 1c 	brgt	800099ca <_vfprintf_r+0x1b9e>
80009996:	c3 d8       	rjmp	80009a10 <_vfprintf_r+0x1be4>
80009998:	2f 09       	sub	r9,-16
8000999a:	2f f8       	sub	r8,-1
8000999c:	fb 49 06 90 	st.w	sp[1680],r9
800099a0:	87 02       	st.w	r3[0x0],r2
800099a2:	87 10       	st.w	r3[0x4],r0
800099a4:	fb 48 06 8c 	st.w	sp[1676],r8
800099a8:	58 78       	cp.w	r8,7
800099aa:	e0 89 00 04 	brgt	800099b2 <_vfprintf_r+0x1b86>
800099ae:	2f 83       	sub	r3,-8
800099b0:	c0 b8       	rjmp	800099c6 <_vfprintf_r+0x1b9a>
800099b2:	fa ca f9 78 	sub	r10,sp,-1672
800099b6:	02 9b       	mov	r11,r1
800099b8:	08 9c       	mov	r12,r4
800099ba:	fe b0 f2 2b 	rcall	80007e10 <__sprint_r>
800099be:	e0 81 01 b6 	brne	80009d2a <_vfprintf_r+0x1efe>
800099c2:	fa c3 f9 e0 	sub	r3,sp,-1568
800099c6:	21 06       	sub	r6,16
800099c8:	c0 48       	rjmp	800099d0 <_vfprintf_r+0x1ba4>
800099ca:	fe c2 bc ea 	sub	r2,pc,-17174
800099ce:	31 00       	mov	r0,16
800099d0:	fa f9 06 90 	ld.w	r9,sp[1680]
800099d4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099d8:	fe ca bc f8 	sub	r10,pc,-17160
800099dc:	59 06       	cp.w	r6,16
800099de:	fe 99 ff dd 	brgt	80009998 <_vfprintf_r+0x1b6c>
800099e2:	0c 09       	add	r9,r6
800099e4:	2f f8       	sub	r8,-1
800099e6:	87 0a       	st.w	r3[0x0],r10
800099e8:	fb 49 06 90 	st.w	sp[1680],r9
800099ec:	87 16       	st.w	r3[0x4],r6
800099ee:	fb 48 06 8c 	st.w	sp[1676],r8
800099f2:	58 78       	cp.w	r8,7
800099f4:	e0 89 00 04 	brgt	800099fc <_vfprintf_r+0x1bd0>
800099f8:	2f 83       	sub	r3,-8
800099fa:	c0 b8       	rjmp	80009a10 <_vfprintf_r+0x1be4>
800099fc:	fa ca f9 78 	sub	r10,sp,-1672
80009a00:	02 9b       	mov	r11,r1
80009a02:	08 9c       	mov	r12,r4
80009a04:	fe b0 f2 06 	rcall	80007e10 <__sprint_r>
80009a08:	e0 81 01 91 	brne	80009d2a <_vfprintf_r+0x1efe>
80009a0c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a10:	ed b5 00 00 	bld	r5,0x0
80009a14:	e0 81 01 20 	brne	80009c54 <_vfprintf_r+0x1e28>
80009a18:	40 c9       	lddsp	r9,sp[0x30]
80009a1a:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a1e:	2f f8       	sub	r8,-1
80009a20:	87 09       	st.w	r3[0x0],r9
80009a22:	fb 48 06 90 	st.w	sp[1680],r8
80009a26:	30 19       	mov	r9,1
80009a28:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a2c:	87 19       	st.w	r3[0x4],r9
80009a2e:	2f f8       	sub	r8,-1
80009a30:	fb 48 06 8c 	st.w	sp[1676],r8
80009a34:	c0 29       	rjmp	80009c38 <_vfprintf_r+0x1e0c>
80009a36:	14 09       	add	r9,r10
80009a38:	2f f8       	sub	r8,-1
80009a3a:	fb 49 06 90 	st.w	sp[1680],r9
80009a3e:	87 06       	st.w	r3[0x0],r6
80009a40:	87 1a       	st.w	r3[0x4],r10
80009a42:	fb 48 06 8c 	st.w	sp[1676],r8
80009a46:	58 78       	cp.w	r8,7
80009a48:	e0 89 00 04 	brgt	80009a50 <_vfprintf_r+0x1c24>
80009a4c:	2f 83       	sub	r3,-8
80009a4e:	c0 b8       	rjmp	80009a64 <_vfprintf_r+0x1c38>
80009a50:	fa ca f9 78 	sub	r10,sp,-1672
80009a54:	02 9b       	mov	r11,r1
80009a56:	08 9c       	mov	r12,r4
80009a58:	fe b0 f1 dc 	rcall	80007e10 <__sprint_r>
80009a5c:	e0 81 01 67 	brne	80009d2a <_vfprintf_r+0x1efe>
80009a60:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a64:	40 c8       	lddsp	r8,sp[0x30]
80009a66:	87 08       	st.w	r3[0x0],r8
80009a68:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a6c:	2f f8       	sub	r8,-1
80009a6e:	30 19       	mov	r9,1
80009a70:	fb 48 06 90 	st.w	sp[1680],r8
80009a74:	87 19       	st.w	r3[0x4],r9
80009a76:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a7a:	2f f8       	sub	r8,-1
80009a7c:	fb 48 06 8c 	st.w	sp[1676],r8
80009a80:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009a84:	58 78       	cp.w	r8,7
80009a86:	e0 89 00 04 	brgt	80009a8e <_vfprintf_r+0x1c62>
80009a8a:	2f 83       	sub	r3,-8
80009a8c:	c0 b8       	rjmp	80009aa2 <_vfprintf_r+0x1c76>
80009a8e:	fa ca f9 78 	sub	r10,sp,-1672
80009a92:	02 9b       	mov	r11,r1
80009a94:	08 9c       	mov	r12,r4
80009a96:	fe b0 f1 bd 	rcall	80007e10 <__sprint_r>
80009a9a:	e0 81 01 48 	brne	80009d2a <_vfprintf_r+0x1efe>
80009a9e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009aa2:	04 06       	add	r6,r2
80009aa4:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009aa8:	87 06       	st.w	r3[0x0],r6
80009aaa:	fa f9 06 90 	ld.w	r9,sp[1680]
80009aae:	40 66       	lddsp	r6,sp[0x18]
80009ab0:	40 6e       	lddsp	lr,sp[0x18]
80009ab2:	10 16       	sub	r6,r8
80009ab4:	f2 08 01 08 	sub	r8,r9,r8
80009ab8:	87 16       	st.w	r3[0x4],r6
80009aba:	1c 08       	add	r8,lr
80009abc:	fb 48 06 90 	st.w	sp[1680],r8
80009ac0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ac4:	2f f8       	sub	r8,-1
80009ac6:	fb 48 06 8c 	st.w	sp[1676],r8
80009aca:	cb 78       	rjmp	80009c38 <_vfprintf_r+0x1e0c>
80009acc:	40 6c       	lddsp	r12,sp[0x18]
80009ace:	58 1c       	cp.w	r12,1
80009ad0:	e0 89 00 06 	brgt	80009adc <_vfprintf_r+0x1cb0>
80009ad4:	ed b5 00 00 	bld	r5,0x0
80009ad8:	e0 81 00 85 	brne	80009be2 <_vfprintf_r+0x1db6>
80009adc:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ae0:	2f f8       	sub	r8,-1
80009ae2:	30 19       	mov	r9,1
80009ae4:	fb 48 06 90 	st.w	sp[1680],r8
80009ae8:	87 06       	st.w	r3[0x0],r6
80009aea:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009aee:	87 19       	st.w	r3[0x4],r9
80009af0:	2f f8       	sub	r8,-1
80009af2:	fb 48 06 8c 	st.w	sp[1676],r8
80009af6:	58 78       	cp.w	r8,7
80009af8:	e0 89 00 04 	brgt	80009b00 <_vfprintf_r+0x1cd4>
80009afc:	2f 83       	sub	r3,-8
80009afe:	c0 b8       	rjmp	80009b14 <_vfprintf_r+0x1ce8>
80009b00:	fa ca f9 78 	sub	r10,sp,-1672
80009b04:	02 9b       	mov	r11,r1
80009b06:	08 9c       	mov	r12,r4
80009b08:	fe b0 f1 84 	rcall	80007e10 <__sprint_r>
80009b0c:	e0 81 01 0f 	brne	80009d2a <_vfprintf_r+0x1efe>
80009b10:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b14:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b18:	2f f8       	sub	r8,-1
80009b1a:	40 cb       	lddsp	r11,sp[0x30]
80009b1c:	fb 48 06 90 	st.w	sp[1680],r8
80009b20:	30 19       	mov	r9,1
80009b22:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b26:	87 0b       	st.w	r3[0x0],r11
80009b28:	2f f8       	sub	r8,-1
80009b2a:	87 19       	st.w	r3[0x4],r9
80009b2c:	fb 48 06 8c 	st.w	sp[1676],r8
80009b30:	58 78       	cp.w	r8,7
80009b32:	e0 89 00 05 	brgt	80009b3c <_vfprintf_r+0x1d10>
80009b36:	2f 83       	sub	r3,-8
80009b38:	c0 c8       	rjmp	80009b50 <_vfprintf_r+0x1d24>
80009b3a:	d7 03       	nop
80009b3c:	fa ca f9 78 	sub	r10,sp,-1672
80009b40:	02 9b       	mov	r11,r1
80009b42:	08 9c       	mov	r12,r4
80009b44:	fe b0 f1 66 	rcall	80007e10 <__sprint_r>
80009b48:	e0 81 00 f1 	brne	80009d2a <_vfprintf_r+0x1efe>
80009b4c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b50:	30 08       	mov	r8,0
80009b52:	30 09       	mov	r9,0
80009b54:	40 5b       	lddsp	r11,sp[0x14]
80009b56:	40 7a       	lddsp	r10,sp[0x1c]
80009b58:	e0 a0 13 25 	rcall	8000c1a2 <__avr32_f64_cmp_eq>
80009b5c:	40 68       	lddsp	r8,sp[0x18]
80009b5e:	20 18       	sub	r8,1
80009b60:	58 0c       	cp.w	r12,0
80009b62:	c0 d1       	brne	80009b7c <_vfprintf_r+0x1d50>
80009b64:	2f f6       	sub	r6,-1
80009b66:	87 18       	st.w	r3[0x4],r8
80009b68:	87 06       	st.w	r3[0x0],r6
80009b6a:	fa f6 06 90 	ld.w	r6,sp[1680]
80009b6e:	10 06       	add	r6,r8
80009b70:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b74:	fb 46 06 90 	st.w	sp[1680],r6
80009b78:	2f f8       	sub	r8,-1
80009b7a:	c3 18       	rjmp	80009bdc <_vfprintf_r+0x1db0>
80009b7c:	10 96       	mov	r6,r8
80009b7e:	58 08       	cp.w	r8,0
80009b80:	e0 89 00 1c 	brgt	80009bb8 <_vfprintf_r+0x1d8c>
80009b84:	c4 b8       	rjmp	80009c1a <_vfprintf_r+0x1dee>
80009b86:	2f 09       	sub	r9,-16
80009b88:	2f f8       	sub	r8,-1
80009b8a:	fb 49 06 90 	st.w	sp[1680],r9
80009b8e:	87 02       	st.w	r3[0x0],r2
80009b90:	87 10       	st.w	r3[0x4],r0
80009b92:	fb 48 06 8c 	st.w	sp[1676],r8
80009b96:	58 78       	cp.w	r8,7
80009b98:	e0 89 00 04 	brgt	80009ba0 <_vfprintf_r+0x1d74>
80009b9c:	2f 83       	sub	r3,-8
80009b9e:	c0 b8       	rjmp	80009bb4 <_vfprintf_r+0x1d88>
80009ba0:	fa ca f9 78 	sub	r10,sp,-1672
80009ba4:	02 9b       	mov	r11,r1
80009ba6:	08 9c       	mov	r12,r4
80009ba8:	fe b0 f1 34 	rcall	80007e10 <__sprint_r>
80009bac:	e0 81 00 bf 	brne	80009d2a <_vfprintf_r+0x1efe>
80009bb0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bb4:	21 06       	sub	r6,16
80009bb6:	c0 48       	rjmp	80009bbe <_vfprintf_r+0x1d92>
80009bb8:	fe c2 be d8 	sub	r2,pc,-16680
80009bbc:	31 00       	mov	r0,16
80009bbe:	fa f9 06 90 	ld.w	r9,sp[1680]
80009bc2:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009bc6:	fe ca be e6 	sub	r10,pc,-16666
80009bca:	59 06       	cp.w	r6,16
80009bcc:	fe 99 ff dd 	brgt	80009b86 <_vfprintf_r+0x1d5a>
80009bd0:	0c 09       	add	r9,r6
80009bd2:	87 0a       	st.w	r3[0x0],r10
80009bd4:	fb 49 06 90 	st.w	sp[1680],r9
80009bd8:	2f f8       	sub	r8,-1
80009bda:	87 16       	st.w	r3[0x4],r6
80009bdc:	fb 48 06 8c 	st.w	sp[1676],r8
80009be0:	c0 e8       	rjmp	80009bfc <_vfprintf_r+0x1dd0>
80009be2:	fa f8 06 90 	ld.w	r8,sp[1680]
80009be6:	2f f8       	sub	r8,-1
80009be8:	30 19       	mov	r9,1
80009bea:	fb 48 06 90 	st.w	sp[1680],r8
80009bee:	87 06       	st.w	r3[0x0],r6
80009bf0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009bf4:	87 19       	st.w	r3[0x4],r9
80009bf6:	2f f8       	sub	r8,-1
80009bf8:	fb 48 06 8c 	st.w	sp[1676],r8
80009bfc:	58 78       	cp.w	r8,7
80009bfe:	e0 89 00 04 	brgt	80009c06 <_vfprintf_r+0x1dda>
80009c02:	2f 83       	sub	r3,-8
80009c04:	c0 b8       	rjmp	80009c1a <_vfprintf_r+0x1dee>
80009c06:	fa ca f9 78 	sub	r10,sp,-1672
80009c0a:	02 9b       	mov	r11,r1
80009c0c:	08 9c       	mov	r12,r4
80009c0e:	fe b0 f1 01 	rcall	80007e10 <__sprint_r>
80009c12:	e0 81 00 8c 	brne	80009d2a <_vfprintf_r+0x1efe>
80009c16:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c1a:	40 ea       	lddsp	r10,sp[0x38]
80009c1c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c20:	14 08       	add	r8,r10
80009c22:	fa c9 f9 64 	sub	r9,sp,-1692
80009c26:	fb 48 06 90 	st.w	sp[1680],r8
80009c2a:	87 1a       	st.w	r3[0x4],r10
80009c2c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c30:	87 09       	st.w	r3[0x0],r9
80009c32:	2f f8       	sub	r8,-1
80009c34:	fb 48 06 8c 	st.w	sp[1676],r8
80009c38:	58 78       	cp.w	r8,7
80009c3a:	e0 89 00 04 	brgt	80009c42 <_vfprintf_r+0x1e16>
80009c3e:	2f 83       	sub	r3,-8
80009c40:	c0 a8       	rjmp	80009c54 <_vfprintf_r+0x1e28>
80009c42:	fa ca f9 78 	sub	r10,sp,-1672
80009c46:	02 9b       	mov	r11,r1
80009c48:	08 9c       	mov	r12,r4
80009c4a:	fe b0 f0 e3 	rcall	80007e10 <__sprint_r>
80009c4e:	c6 e1       	brne	80009d2a <_vfprintf_r+0x1efe>
80009c50:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c54:	e2 15 00 04 	andl	r5,0x4,COH
80009c58:	c3 f0       	breq	80009cd6 <_vfprintf_r+0x1eaa>
80009c5a:	40 86       	lddsp	r6,sp[0x20]
80009c5c:	40 39       	lddsp	r9,sp[0xc]
80009c5e:	12 16       	sub	r6,r9
80009c60:	58 06       	cp.w	r6,0
80009c62:	e0 89 00 1a 	brgt	80009c96 <_vfprintf_r+0x1e6a>
80009c66:	c3 88       	rjmp	80009cd6 <_vfprintf_r+0x1eaa>
80009c68:	2f 09       	sub	r9,-16
80009c6a:	2f f8       	sub	r8,-1
80009c6c:	fb 49 06 90 	st.w	sp[1680],r9
80009c70:	87 05       	st.w	r3[0x0],r5
80009c72:	87 12       	st.w	r3[0x4],r2
80009c74:	fb 48 06 8c 	st.w	sp[1676],r8
80009c78:	58 78       	cp.w	r8,7
80009c7a:	e0 89 00 04 	brgt	80009c82 <_vfprintf_r+0x1e56>
80009c7e:	2f 83       	sub	r3,-8
80009c80:	c0 98       	rjmp	80009c92 <_vfprintf_r+0x1e66>
80009c82:	00 9a       	mov	r10,r0
80009c84:	02 9b       	mov	r11,r1
80009c86:	08 9c       	mov	r12,r4
80009c88:	fe b0 f0 c4 	rcall	80007e10 <__sprint_r>
80009c8c:	c4 f1       	brne	80009d2a <_vfprintf_r+0x1efe>
80009c8e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c92:	21 06       	sub	r6,16
80009c94:	c0 68       	rjmp	80009ca0 <_vfprintf_r+0x1e74>
80009c96:	fe c5 bf c6 	sub	r5,pc,-16442
80009c9a:	31 02       	mov	r2,16
80009c9c:	fa c0 f9 78 	sub	r0,sp,-1672
80009ca0:	fa f9 06 90 	ld.w	r9,sp[1680]
80009ca4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ca8:	fe ca bf d8 	sub	r10,pc,-16424
80009cac:	59 06       	cp.w	r6,16
80009cae:	fe 99 ff dd 	brgt	80009c68 <_vfprintf_r+0x1e3c>
80009cb2:	0c 09       	add	r9,r6
80009cb4:	2f f8       	sub	r8,-1
80009cb6:	87 0a       	st.w	r3[0x0],r10
80009cb8:	87 16       	st.w	r3[0x4],r6
80009cba:	fb 49 06 90 	st.w	sp[1680],r9
80009cbe:	fb 48 06 8c 	st.w	sp[1676],r8
80009cc2:	58 78       	cp.w	r8,7
80009cc4:	e0 8a 00 09 	brle	80009cd6 <_vfprintf_r+0x1eaa>
80009cc8:	fa ca f9 78 	sub	r10,sp,-1672
80009ccc:	02 9b       	mov	r11,r1
80009cce:	08 9c       	mov	r12,r4
80009cd0:	fe b0 f0 a0 	rcall	80007e10 <__sprint_r>
80009cd4:	c2 b1       	brne	80009d2a <_vfprintf_r+0x1efe>
80009cd6:	40 bc       	lddsp	r12,sp[0x2c]
80009cd8:	40 36       	lddsp	r6,sp[0xc]
80009cda:	40 8e       	lddsp	lr,sp[0x20]
80009cdc:	ec 0e 0c 48 	max	r8,r6,lr
80009ce0:	10 0c       	add	r12,r8
80009ce2:	50 bc       	stdsp	sp[0x2c],r12
80009ce4:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ce8:	58 08       	cp.w	r8,0
80009cea:	c0 80       	breq	80009cfa <_vfprintf_r+0x1ece>
80009cec:	fa ca f9 78 	sub	r10,sp,-1672
80009cf0:	02 9b       	mov	r11,r1
80009cf2:	08 9c       	mov	r12,r4
80009cf4:	fe b0 f0 8e 	rcall	80007e10 <__sprint_r>
80009cf8:	c1 91       	brne	80009d2a <_vfprintf_r+0x1efe>
80009cfa:	30 0b       	mov	r11,0
80009cfc:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d00:	fb 4b 06 8c 	st.w	sp[1676],r11
80009d04:	fe 9f f1 22 	bral	80007f48 <_vfprintf_r+0x11c>
80009d08:	08 95       	mov	r5,r4
80009d0a:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d0e:	58 08       	cp.w	r8,0
80009d10:	c0 80       	breq	80009d20 <_vfprintf_r+0x1ef4>
80009d12:	08 9c       	mov	r12,r4
80009d14:	fa ca f9 78 	sub	r10,sp,-1672
80009d18:	02 9b       	mov	r11,r1
80009d1a:	fe b0 f0 7b 	rcall	80007e10 <__sprint_r>
80009d1e:	c0 61       	brne	80009d2a <_vfprintf_r+0x1efe>
80009d20:	30 08       	mov	r8,0
80009d22:	fb 48 06 8c 	st.w	sp[1676],r8
80009d26:	c0 28       	rjmp	80009d2a <_vfprintf_r+0x1efe>
80009d28:	40 41       	lddsp	r1,sp[0x10]
80009d2a:	82 68       	ld.sh	r8,r1[0xc]
80009d2c:	ed b8 00 06 	bld	r8,0x6
80009d30:	c0 31       	brne	80009d36 <_vfprintf_r+0x1f0a>
80009d32:	3f fa       	mov	r10,-1
80009d34:	50 ba       	stdsp	sp[0x2c],r10
80009d36:	40 bc       	lddsp	r12,sp[0x2c]
80009d38:	fe 3d f9 44 	sub	sp,-1724
80009d3c:	d8 32       	popm	r0-r7,pc
80009d3e:	d7 03       	nop

80009d40 <__swsetup_r>:
80009d40:	d4 21       	pushm	r4-r7,lr
80009d42:	e0 68 0a 3c 	mov	r8,2620
80009d46:	18 96       	mov	r6,r12
80009d48:	16 97       	mov	r7,r11
80009d4a:	70 0c       	ld.w	r12,r8[0x0]
80009d4c:	58 0c       	cp.w	r12,0
80009d4e:	c0 60       	breq	80009d5a <__swsetup_r+0x1a>
80009d50:	78 68       	ld.w	r8,r12[0x18]
80009d52:	58 08       	cp.w	r8,0
80009d54:	c0 31       	brne	80009d5a <__swsetup_r+0x1a>
80009d56:	e0 a0 07 bf 	rcall	8000acd4 <__sinit>
80009d5a:	fe c8 bf 5a 	sub	r8,pc,-16550
80009d5e:	10 37       	cp.w	r7,r8
80009d60:	c0 61       	brne	80009d6c <__swsetup_r+0x2c>
80009d62:	e0 68 0a 3c 	mov	r8,2620
80009d66:	70 08       	ld.w	r8,r8[0x0]
80009d68:	70 07       	ld.w	r7,r8[0x0]
80009d6a:	c1 28       	rjmp	80009d8e <__swsetup_r+0x4e>
80009d6c:	fe c8 bf 4c 	sub	r8,pc,-16564
80009d70:	10 37       	cp.w	r7,r8
80009d72:	c0 61       	brne	80009d7e <__swsetup_r+0x3e>
80009d74:	e0 68 0a 3c 	mov	r8,2620
80009d78:	70 08       	ld.w	r8,r8[0x0]
80009d7a:	70 17       	ld.w	r7,r8[0x4]
80009d7c:	c0 98       	rjmp	80009d8e <__swsetup_r+0x4e>
80009d7e:	fe c8 bf 3e 	sub	r8,pc,-16578
80009d82:	10 37       	cp.w	r7,r8
80009d84:	c0 51       	brne	80009d8e <__swsetup_r+0x4e>
80009d86:	e0 68 0a 3c 	mov	r8,2620
80009d8a:	70 08       	ld.w	r8,r8[0x0]
80009d8c:	70 27       	ld.w	r7,r8[0x8]
80009d8e:	8e 68       	ld.sh	r8,r7[0xc]
80009d90:	ed b8 00 03 	bld	r8,0x3
80009d94:	c1 e0       	breq	80009dd0 <__swsetup_r+0x90>
80009d96:	ed b8 00 04 	bld	r8,0x4
80009d9a:	c3 e1       	brne	80009e16 <__swsetup_r+0xd6>
80009d9c:	ed b8 00 02 	bld	r8,0x2
80009da0:	c1 51       	brne	80009dca <__swsetup_r+0x8a>
80009da2:	6e db       	ld.w	r11,r7[0x34]
80009da4:	58 0b       	cp.w	r11,0
80009da6:	c0 a0       	breq	80009dba <__swsetup_r+0x7a>
80009da8:	ee c8 ff bc 	sub	r8,r7,-68
80009dac:	10 3b       	cp.w	r11,r8
80009dae:	c0 40       	breq	80009db6 <__swsetup_r+0x76>
80009db0:	0c 9c       	mov	r12,r6
80009db2:	e0 a0 08 2b 	rcall	8000ae08 <_free_r>
80009db6:	30 08       	mov	r8,0
80009db8:	8f d8       	st.w	r7[0x34],r8
80009dba:	8e 68       	ld.sh	r8,r7[0xc]
80009dbc:	e0 18 ff db 	andl	r8,0xffdb
80009dc0:	ae 68       	st.h	r7[0xc],r8
80009dc2:	30 08       	mov	r8,0
80009dc4:	8f 18       	st.w	r7[0x4],r8
80009dc6:	6e 48       	ld.w	r8,r7[0x10]
80009dc8:	8f 08       	st.w	r7[0x0],r8
80009dca:	8e 68       	ld.sh	r8,r7[0xc]
80009dcc:	a3 b8       	sbr	r8,0x3
80009dce:	ae 68       	st.h	r7[0xc],r8
80009dd0:	6e 48       	ld.w	r8,r7[0x10]
80009dd2:	58 08       	cp.w	r8,0
80009dd4:	c0 b1       	brne	80009dea <__swsetup_r+0xaa>
80009dd6:	8e 68       	ld.sh	r8,r7[0xc]
80009dd8:	e2 18 02 80 	andl	r8,0x280,COH
80009ddc:	e0 48 02 00 	cp.w	r8,512
80009de0:	c0 50       	breq	80009dea <__swsetup_r+0xaa>
80009de2:	0c 9c       	mov	r12,r6
80009de4:	0e 9b       	mov	r11,r7
80009de6:	e0 a0 0a 4b 	rcall	8000b27c <__smakebuf_r>
80009dea:	8e 69       	ld.sh	r9,r7[0xc]
80009dec:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009df0:	c0 70       	breq	80009dfe <__swsetup_r+0xbe>
80009df2:	30 08       	mov	r8,0
80009df4:	8f 28       	st.w	r7[0x8],r8
80009df6:	6e 58       	ld.w	r8,r7[0x14]
80009df8:	5c 38       	neg	r8
80009dfa:	8f 68       	st.w	r7[0x18],r8
80009dfc:	c0 68       	rjmp	80009e08 <__swsetup_r+0xc8>
80009dfe:	ed b9 00 01 	bld	r9,0x1
80009e02:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009e06:	8f 28       	st.w	r7[0x8],r8
80009e08:	6e 48       	ld.w	r8,r7[0x10]
80009e0a:	58 08       	cp.w	r8,0
80009e0c:	c0 61       	brne	80009e18 <__swsetup_r+0xd8>
80009e0e:	8e 68       	ld.sh	r8,r7[0xc]
80009e10:	ed b8 00 07 	bld	r8,0x7
80009e14:	c0 21       	brne	80009e18 <__swsetup_r+0xd8>
80009e16:	dc 2a       	popm	r4-r7,pc,r12=-1
80009e18:	d8 2a       	popm	r4-r7,pc,r12=0
80009e1a:	d7 03       	nop

80009e1c <quorem>:
80009e1c:	d4 31       	pushm	r0-r7,lr
80009e1e:	20 2d       	sub	sp,8
80009e20:	18 97       	mov	r7,r12
80009e22:	78 48       	ld.w	r8,r12[0x10]
80009e24:	76 46       	ld.w	r6,r11[0x10]
80009e26:	0c 38       	cp.w	r8,r6
80009e28:	c0 34       	brge	80009e2e <quorem+0x12>
80009e2a:	30 0c       	mov	r12,0
80009e2c:	c8 58       	rjmp	80009f36 <quorem+0x11a>
80009e2e:	ec c2 ff fc 	sub	r2,r6,-4
80009e32:	f6 c3 ff ec 	sub	r3,r11,-20
80009e36:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80009e3a:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009e3e:	2f f9       	sub	r9,-1
80009e40:	20 16       	sub	r6,1
80009e42:	f8 09 0d 08 	divu	r8,r12,r9
80009e46:	f6 02 00 22 	add	r2,r11,r2<<0x2
80009e4a:	ee c4 ff ec 	sub	r4,r7,-20
80009e4e:	10 95       	mov	r5,r8
80009e50:	58 08       	cp.w	r8,0
80009e52:	c4 10       	breq	80009ed4 <quorem+0xb8>
80009e54:	30 09       	mov	r9,0
80009e56:	06 9a       	mov	r10,r3
80009e58:	08 98       	mov	r8,r4
80009e5a:	12 91       	mov	r1,r9
80009e5c:	50 0b       	stdsp	sp[0x0],r11
80009e5e:	70 0e       	ld.w	lr,r8[0x0]
80009e60:	b1 8e       	lsr	lr,0x10
80009e62:	50 1e       	stdsp	sp[0x4],lr
80009e64:	15 0e       	ld.w	lr,r10++
80009e66:	fc 00 16 10 	lsr	r0,lr,0x10
80009e6a:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80009e6e:	ea 0e 03 41 	mac	r1,r5,lr
80009e72:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80009e76:	b1 81       	lsr	r1,0x10
80009e78:	40 1b       	lddsp	r11,sp[0x4]
80009e7a:	ea 00 02 40 	mul	r0,r5,r0
80009e7e:	e2 00 00 00 	add	r0,r1,r0
80009e82:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80009e86:	02 1b       	sub	r11,r1
80009e88:	50 1b       	stdsp	sp[0x4],r11
80009e8a:	70 0b       	ld.w	r11,r8[0x0]
80009e8c:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009e90:	02 09       	add	r9,r1
80009e92:	f2 0e 01 0e 	sub	lr,r9,lr
80009e96:	b0 1e       	st.h	r8[0x2],lr
80009e98:	fc 09 14 10 	asr	r9,lr,0x10
80009e9c:	40 1e       	lddsp	lr,sp[0x4]
80009e9e:	fc 09 00 09 	add	r9,lr,r9
80009ea2:	b0 09       	st.h	r8[0x0],r9
80009ea4:	e0 01 16 10 	lsr	r1,r0,0x10
80009ea8:	2f c8       	sub	r8,-4
80009eaa:	b1 49       	asr	r9,0x10
80009eac:	04 3a       	cp.w	r10,r2
80009eae:	fe 98 ff d8 	brls	80009e5e <quorem+0x42>
80009eb2:	40 0b       	lddsp	r11,sp[0x0]
80009eb4:	58 0c       	cp.w	r12,0
80009eb6:	c0 f1       	brne	80009ed4 <quorem+0xb8>
80009eb8:	ec c8 ff fb 	sub	r8,r6,-5
80009ebc:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009ec0:	c0 28       	rjmp	80009ec4 <quorem+0xa8>
80009ec2:	20 16       	sub	r6,1
80009ec4:	20 48       	sub	r8,4
80009ec6:	08 38       	cp.w	r8,r4
80009ec8:	e0 88 00 05 	brls	80009ed2 <quorem+0xb6>
80009ecc:	70 09       	ld.w	r9,r8[0x0]
80009ece:	58 09       	cp.w	r9,0
80009ed0:	cf 90       	breq	80009ec2 <quorem+0xa6>
80009ed2:	8f 46       	st.w	r7[0x10],r6
80009ed4:	0e 9c       	mov	r12,r7
80009ed6:	e0 a0 0a d2 	rcall	8000b47a <__mcmp>
80009eda:	c2 d5       	brlt	80009f34 <quorem+0x118>
80009edc:	2f f5       	sub	r5,-1
80009ede:	08 98       	mov	r8,r4
80009ee0:	30 09       	mov	r9,0
80009ee2:	07 0b       	ld.w	r11,r3++
80009ee4:	f6 0a 16 10 	lsr	r10,r11,0x10
80009ee8:	70 0c       	ld.w	r12,r8[0x0]
80009eea:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009eee:	f8 0e 16 10 	lsr	lr,r12,0x10
80009ef2:	14 1e       	sub	lr,r10
80009ef4:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009ef8:	16 1a       	sub	r10,r11
80009efa:	12 0a       	add	r10,r9
80009efc:	b0 1a       	st.h	r8[0x2],r10
80009efe:	b1 4a       	asr	r10,0x10
80009f00:	fc 0a 00 09 	add	r9,lr,r10
80009f04:	b0 09       	st.h	r8[0x0],r9
80009f06:	2f c8       	sub	r8,-4
80009f08:	b1 49       	asr	r9,0x10
80009f0a:	04 33       	cp.w	r3,r2
80009f0c:	fe 98 ff eb 	brls	80009ee2 <quorem+0xc6>
80009f10:	ec c8 ff fb 	sub	r8,r6,-5
80009f14:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80009f18:	58 09       	cp.w	r9,0
80009f1a:	c0 d1       	brne	80009f34 <quorem+0x118>
80009f1c:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009f20:	c0 28       	rjmp	80009f24 <quorem+0x108>
80009f22:	20 16       	sub	r6,1
80009f24:	20 48       	sub	r8,4
80009f26:	08 38       	cp.w	r8,r4
80009f28:	e0 88 00 05 	brls	80009f32 <quorem+0x116>
80009f2c:	70 09       	ld.w	r9,r8[0x0]
80009f2e:	58 09       	cp.w	r9,0
80009f30:	cf 90       	breq	80009f22 <quorem+0x106>
80009f32:	8f 46       	st.w	r7[0x10],r6
80009f34:	0a 9c       	mov	r12,r5
80009f36:	2f ed       	sub	sp,-8
80009f38:	d8 32       	popm	r0-r7,pc
80009f3a:	d7 03       	nop

80009f3c <_dtoa_r>:
80009f3c:	d4 31       	pushm	r0-r7,lr
80009f3e:	21 ad       	sub	sp,104
80009f40:	fa c4 ff 74 	sub	r4,sp,-140
80009f44:	18 97       	mov	r7,r12
80009f46:	16 95       	mov	r5,r11
80009f48:	68 2c       	ld.w	r12,r4[0x8]
80009f4a:	50 c9       	stdsp	sp[0x30],r9
80009f4c:	68 16       	ld.w	r6,r4[0x4]
80009f4e:	68 09       	ld.w	r9,r4[0x0]
80009f50:	50 e8       	stdsp	sp[0x38],r8
80009f52:	14 94       	mov	r4,r10
80009f54:	51 2c       	stdsp	sp[0x48],r12
80009f56:	fa e5 00 08 	st.d	sp[8],r4
80009f5a:	51 59       	stdsp	sp[0x54],r9
80009f5c:	6e 95       	ld.w	r5,r7[0x24]
80009f5e:	58 05       	cp.w	r5,0
80009f60:	c0 91       	brne	80009f72 <_dtoa_r+0x36>
80009f62:	31 0c       	mov	r12,16
80009f64:	fe b0 e8 f4 	rcall	8000714c <malloc>
80009f68:	99 35       	st.w	r12[0xc],r5
80009f6a:	8f 9c       	st.w	r7[0x24],r12
80009f6c:	99 15       	st.w	r12[0x4],r5
80009f6e:	99 25       	st.w	r12[0x8],r5
80009f70:	99 05       	st.w	r12[0x0],r5
80009f72:	6e 99       	ld.w	r9,r7[0x24]
80009f74:	72 08       	ld.w	r8,r9[0x0]
80009f76:	58 08       	cp.w	r8,0
80009f78:	c0 f0       	breq	80009f96 <_dtoa_r+0x5a>
80009f7a:	72 1a       	ld.w	r10,r9[0x4]
80009f7c:	91 1a       	st.w	r8[0x4],r10
80009f7e:	30 1a       	mov	r10,1
80009f80:	72 19       	ld.w	r9,r9[0x4]
80009f82:	f4 09 09 49 	lsl	r9,r10,r9
80009f86:	10 9b       	mov	r11,r8
80009f88:	91 29       	st.w	r8[0x8],r9
80009f8a:	0e 9c       	mov	r12,r7
80009f8c:	e0 a0 0a 90 	rcall	8000b4ac <_Bfree>
80009f90:	6e 98       	ld.w	r8,r7[0x24]
80009f92:	30 09       	mov	r9,0
80009f94:	91 09       	st.w	r8[0x0],r9
80009f96:	40 28       	lddsp	r8,sp[0x8]
80009f98:	10 94       	mov	r4,r8
80009f9a:	58 08       	cp.w	r8,0
80009f9c:	c0 64       	brge	80009fa8 <_dtoa_r+0x6c>
80009f9e:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009fa2:	50 28       	stdsp	sp[0x8],r8
80009fa4:	30 18       	mov	r8,1
80009fa6:	c0 28       	rjmp	80009faa <_dtoa_r+0x6e>
80009fa8:	30 08       	mov	r8,0
80009faa:	8d 08       	st.w	r6[0x0],r8
80009fac:	fc 1c 7f f0 	movh	r12,0x7ff0
80009fb0:	40 26       	lddsp	r6,sp[0x8]
80009fb2:	0c 98       	mov	r8,r6
80009fb4:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009fb8:	18 38       	cp.w	r8,r12
80009fba:	c2 01       	brne	80009ffa <_dtoa_r+0xbe>
80009fbc:	e0 68 27 0f 	mov	r8,9999
80009fc0:	41 5b       	lddsp	r11,sp[0x54]
80009fc2:	97 08       	st.w	r11[0x0],r8
80009fc4:	40 3a       	lddsp	r10,sp[0xc]
80009fc6:	58 0a       	cp.w	r10,0
80009fc8:	c0 71       	brne	80009fd6 <_dtoa_r+0x9a>
80009fca:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009fce:	c0 41       	brne	80009fd6 <_dtoa_r+0x9a>
80009fd0:	fe cc c1 e0 	sub	r12,pc,-15904
80009fd4:	c0 38       	rjmp	80009fda <_dtoa_r+0x9e>
80009fd6:	fe cc c1 da 	sub	r12,pc,-15910
80009fda:	41 29       	lddsp	r9,sp[0x48]
80009fdc:	58 09       	cp.w	r9,0
80009fde:	e0 80 05 9a 	breq	8000ab12 <_dtoa_r+0xbd6>
80009fe2:	f8 c8 ff fd 	sub	r8,r12,-3
80009fe6:	f8 c9 ff f8 	sub	r9,r12,-8
80009fea:	11 8b       	ld.ub	r11,r8[0x0]
80009fec:	30 0a       	mov	r10,0
80009fee:	41 25       	lddsp	r5,sp[0x48]
80009ff0:	f4 0b 18 00 	cp.b	r11,r10
80009ff4:	f2 08 17 10 	movne	r8,r9
80009ff8:	c1 68       	rjmp	8000a024 <_dtoa_r+0xe8>
80009ffa:	fa ea 00 08 	ld.d	r10,sp[8]
80009ffe:	30 08       	mov	r8,0
8000a000:	fa eb 00 3c 	st.d	sp[60],r10
8000a004:	30 09       	mov	r9,0
8000a006:	e0 a0 10 ce 	rcall	8000c1a2 <__avr32_f64_cmp_eq>
8000a00a:	c1 00       	breq	8000a02a <_dtoa_r+0xee>
8000a00c:	30 18       	mov	r8,1
8000a00e:	41 5a       	lddsp	r10,sp[0x54]
8000a010:	95 08       	st.w	r10[0x0],r8
8000a012:	fe cc c3 46 	sub	r12,pc,-15546
8000a016:	41 29       	lddsp	r9,sp[0x48]
8000a018:	f8 08 00 08 	add	r8,r12,r8
8000a01c:	58 09       	cp.w	r9,0
8000a01e:	e0 80 05 7a 	breq	8000ab12 <_dtoa_r+0xbd6>
8000a022:	12 95       	mov	r5,r9
8000a024:	8b 08       	st.w	r5[0x0],r8
8000a026:	e0 8f 05 76 	bral	8000ab12 <_dtoa_r+0xbd6>
8000a02a:	fa c8 ff 9c 	sub	r8,sp,-100
8000a02e:	fa c9 ff a0 	sub	r9,sp,-96
8000a032:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a036:	0e 9c       	mov	r12,r7
8000a038:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000a03c:	e0 a0 0a 8a 	rcall	8000b550 <__d2b>
8000a040:	18 93       	mov	r3,r12
8000a042:	58 05       	cp.w	r5,0
8000a044:	c0 d0       	breq	8000a05e <_dtoa_r+0x122>
8000a046:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a04a:	30 04       	mov	r4,0
8000a04c:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000a050:	ea c5 03 ff 	sub	r5,r5,1023
8000a054:	10 9b       	mov	r11,r8
8000a056:	51 74       	stdsp	sp[0x5c],r4
8000a058:	ea 1b 3f f0 	orh	r11,0x3ff0
8000a05c:	c2 58       	rjmp	8000a0a6 <_dtoa_r+0x16a>
8000a05e:	41 88       	lddsp	r8,sp[0x60]
8000a060:	41 9c       	lddsp	r12,sp[0x64]
8000a062:	10 0c       	add	r12,r8
8000a064:	f8 c5 fb ce 	sub	r5,r12,-1074
8000a068:	e0 45 00 20 	cp.w	r5,32
8000a06c:	e0 8a 00 0e 	brle	8000a088 <_dtoa_r+0x14c>
8000a070:	f8 cc fb ee 	sub	r12,r12,-1042
8000a074:	40 3b       	lddsp	r11,sp[0xc]
8000a076:	ea 08 11 40 	rsub	r8,r5,64
8000a07a:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000a07e:	ec 08 09 46 	lsl	r6,r6,r8
8000a082:	0c 4c       	or	r12,r6
8000a084:	c0 78       	rjmp	8000a092 <_dtoa_r+0x156>
8000a086:	d7 03       	nop
8000a088:	ea 0c 11 20 	rsub	r12,r5,32
8000a08c:	40 3a       	lddsp	r10,sp[0xc]
8000a08e:	f4 0c 09 4c 	lsl	r12,r10,r12
8000a092:	e0 a0 10 14 	rcall	8000c0ba <__avr32_u32_to_f64>
8000a096:	fc 18 fe 10 	movh	r8,0xfe10
8000a09a:	30 19       	mov	r9,1
8000a09c:	ea c5 04 33 	sub	r5,r5,1075
8000a0a0:	f0 0b 00 0b 	add	r11,r8,r11
8000a0a4:	51 79       	stdsp	sp[0x5c],r9
8000a0a6:	30 08       	mov	r8,0
8000a0a8:	fc 19 3f f8 	movh	r9,0x3ff8
8000a0ac:	e0 a0 0e 9c 	rcall	8000bde4 <__avr32_f64_sub>
8000a0b0:	e0 68 43 61 	mov	r8,17249
8000a0b4:	ea 18 63 6f 	orh	r8,0x636f
8000a0b8:	e0 69 87 a7 	mov	r9,34727
8000a0bc:	ea 19 3f d2 	orh	r9,0x3fd2
8000a0c0:	e0 a0 0d a6 	rcall	8000bc0c <__avr32_f64_mul>
8000a0c4:	e0 68 c8 b3 	mov	r8,51379
8000a0c8:	ea 18 8b 60 	orh	r8,0x8b60
8000a0cc:	e0 69 8a 28 	mov	r9,35368
8000a0d0:	ea 19 3f c6 	orh	r9,0x3fc6
8000a0d4:	e0 a0 0f 56 	rcall	8000bf80 <__avr32_f64_add>
8000a0d8:	0a 9c       	mov	r12,r5
8000a0da:	14 90       	mov	r0,r10
8000a0dc:	16 91       	mov	r1,r11
8000a0de:	e0 a0 0f f2 	rcall	8000c0c2 <__avr32_s32_to_f64>
8000a0e2:	e0 68 79 fb 	mov	r8,31227
8000a0e6:	ea 18 50 9f 	orh	r8,0x509f
8000a0ea:	e0 69 44 13 	mov	r9,17427
8000a0ee:	ea 19 3f d3 	orh	r9,0x3fd3
8000a0f2:	e0 a0 0d 8d 	rcall	8000bc0c <__avr32_f64_mul>
8000a0f6:	14 98       	mov	r8,r10
8000a0f8:	16 99       	mov	r9,r11
8000a0fa:	00 9a       	mov	r10,r0
8000a0fc:	02 9b       	mov	r11,r1
8000a0fe:	e0 a0 0f 41 	rcall	8000bf80 <__avr32_f64_add>
8000a102:	14 90       	mov	r0,r10
8000a104:	16 91       	mov	r1,r11
8000a106:	e0 a0 0f c7 	rcall	8000c094 <__avr32_f64_to_s32>
8000a10a:	30 08       	mov	r8,0
8000a10c:	18 96       	mov	r6,r12
8000a10e:	30 09       	mov	r9,0
8000a110:	00 9a       	mov	r10,r0
8000a112:	02 9b       	mov	r11,r1
8000a114:	e0 a0 10 8e 	rcall	8000c230 <__avr32_f64_cmp_lt>
8000a118:	c0 c0       	breq	8000a130 <_dtoa_r+0x1f4>
8000a11a:	0c 9c       	mov	r12,r6
8000a11c:	e0 a0 0f d3 	rcall	8000c0c2 <__avr32_s32_to_f64>
8000a120:	14 98       	mov	r8,r10
8000a122:	16 99       	mov	r9,r11
8000a124:	00 9a       	mov	r10,r0
8000a126:	02 9b       	mov	r11,r1
8000a128:	e0 a0 10 3d 	rcall	8000c1a2 <__avr32_f64_cmp_eq>
8000a12c:	f7 b6 00 01 	subeq	r6,1
8000a130:	59 66       	cp.w	r6,22
8000a132:	e0 88 00 05 	brls	8000a13c <_dtoa_r+0x200>
8000a136:	30 18       	mov	r8,1
8000a138:	51 48       	stdsp	sp[0x50],r8
8000a13a:	c1 38       	rjmp	8000a160 <_dtoa_r+0x224>
8000a13c:	fe c8 c2 8c 	sub	r8,pc,-15732
8000a140:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a144:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a148:	e0 a0 10 74 	rcall	8000c230 <__avr32_f64_cmp_lt>
8000a14c:	f9 b4 00 00 	moveq	r4,0
8000a150:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a154:	f7 b6 01 01 	subne	r6,1
8000a158:	f9 bc 01 00 	movne	r12,0
8000a15c:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a160:	41 90       	lddsp	r0,sp[0x64]
8000a162:	20 10       	sub	r0,1
8000a164:	0a 10       	sub	r0,r5
8000a166:	c0 46       	brmi	8000a16e <_dtoa_r+0x232>
8000a168:	50 40       	stdsp	sp[0x10],r0
8000a16a:	30 00       	mov	r0,0
8000a16c:	c0 48       	rjmp	8000a174 <_dtoa_r+0x238>
8000a16e:	30 0b       	mov	r11,0
8000a170:	5c 30       	neg	r0
8000a172:	50 4b       	stdsp	sp[0x10],r11
8000a174:	ec 02 11 00 	rsub	r2,r6,0
8000a178:	58 06       	cp.w	r6,0
8000a17a:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a17e:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a182:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a186:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a18a:	f9 b2 04 00 	movge	r2,0
8000a18e:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a192:	f9 b9 05 00 	movlt	r9,0
8000a196:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a19a:	40 c8       	lddsp	r8,sp[0x30]
8000a19c:	58 98       	cp.w	r8,9
8000a19e:	e0 8b 00 20 	brhi	8000a1de <_dtoa_r+0x2a2>
8000a1a2:	58 58       	cp.w	r8,5
8000a1a4:	f9 b4 0a 01 	movle	r4,1
8000a1a8:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a1ac:	f7 b5 09 04 	subgt	r5,4
8000a1b0:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a1b4:	f9 b4 09 00 	movgt	r4,0
8000a1b8:	40 cc       	lddsp	r12,sp[0x30]
8000a1ba:	58 3c       	cp.w	r12,3
8000a1bc:	c2 d0       	breq	8000a216 <_dtoa_r+0x2da>
8000a1be:	e0 89 00 05 	brgt	8000a1c8 <_dtoa_r+0x28c>
8000a1c2:	58 2c       	cp.w	r12,2
8000a1c4:	c1 01       	brne	8000a1e4 <_dtoa_r+0x2a8>
8000a1c6:	c1 88       	rjmp	8000a1f6 <_dtoa_r+0x2ba>
8000a1c8:	40 cb       	lddsp	r11,sp[0x30]
8000a1ca:	58 4b       	cp.w	r11,4
8000a1cc:	c0 60       	breq	8000a1d8 <_dtoa_r+0x29c>
8000a1ce:	58 5b       	cp.w	r11,5
8000a1d0:	c0 a1       	brne	8000a1e4 <_dtoa_r+0x2a8>
8000a1d2:	30 1a       	mov	r10,1
8000a1d4:	50 da       	stdsp	sp[0x34],r10
8000a1d6:	c2 28       	rjmp	8000a21a <_dtoa_r+0x2de>
8000a1d8:	30 19       	mov	r9,1
8000a1da:	50 d9       	stdsp	sp[0x34],r9
8000a1dc:	c0 f8       	rjmp	8000a1fa <_dtoa_r+0x2be>
8000a1de:	30 08       	mov	r8,0
8000a1e0:	30 14       	mov	r4,1
8000a1e2:	50 c8       	stdsp	sp[0x30],r8
8000a1e4:	3f f5       	mov	r5,-1
8000a1e6:	30 1c       	mov	r12,1
8000a1e8:	30 0b       	mov	r11,0
8000a1ea:	50 95       	stdsp	sp[0x24],r5
8000a1ec:	50 dc       	stdsp	sp[0x34],r12
8000a1ee:	0a 91       	mov	r1,r5
8000a1f0:	31 28       	mov	r8,18
8000a1f2:	50 eb       	stdsp	sp[0x38],r11
8000a1f4:	c2 08       	rjmp	8000a234 <_dtoa_r+0x2f8>
8000a1f6:	30 0a       	mov	r10,0
8000a1f8:	50 da       	stdsp	sp[0x34],r10
8000a1fa:	40 e9       	lddsp	r9,sp[0x38]
8000a1fc:	58 09       	cp.w	r9,0
8000a1fe:	e0 89 00 07 	brgt	8000a20c <_dtoa_r+0x2d0>
8000a202:	30 18       	mov	r8,1
8000a204:	50 98       	stdsp	sp[0x24],r8
8000a206:	10 91       	mov	r1,r8
8000a208:	50 e8       	stdsp	sp[0x38],r8
8000a20a:	c1 58       	rjmp	8000a234 <_dtoa_r+0x2f8>
8000a20c:	40 e5       	lddsp	r5,sp[0x38]
8000a20e:	50 95       	stdsp	sp[0x24],r5
8000a210:	0a 91       	mov	r1,r5
8000a212:	0a 98       	mov	r8,r5
8000a214:	c1 08       	rjmp	8000a234 <_dtoa_r+0x2f8>
8000a216:	30 0c       	mov	r12,0
8000a218:	50 dc       	stdsp	sp[0x34],r12
8000a21a:	40 eb       	lddsp	r11,sp[0x38]
8000a21c:	ec 0b 00 0b 	add	r11,r6,r11
8000a220:	50 9b       	stdsp	sp[0x24],r11
8000a222:	16 98       	mov	r8,r11
8000a224:	2f f8       	sub	r8,-1
8000a226:	58 08       	cp.w	r8,0
8000a228:	e0 89 00 05 	brgt	8000a232 <_dtoa_r+0x2f6>
8000a22c:	10 91       	mov	r1,r8
8000a22e:	30 18       	mov	r8,1
8000a230:	c0 28       	rjmp	8000a234 <_dtoa_r+0x2f8>
8000a232:	10 91       	mov	r1,r8
8000a234:	30 09       	mov	r9,0
8000a236:	6e 9a       	ld.w	r10,r7[0x24]
8000a238:	95 19       	st.w	r10[0x4],r9
8000a23a:	30 49       	mov	r9,4
8000a23c:	c0 68       	rjmp	8000a248 <_dtoa_r+0x30c>
8000a23e:	d7 03       	nop
8000a240:	6a 1a       	ld.w	r10,r5[0x4]
8000a242:	a1 79       	lsl	r9,0x1
8000a244:	2f fa       	sub	r10,-1
8000a246:	8b 1a       	st.w	r5[0x4],r10
8000a248:	6e 95       	ld.w	r5,r7[0x24]
8000a24a:	f2 ca ff ec 	sub	r10,r9,-20
8000a24e:	10 3a       	cp.w	r10,r8
8000a250:	fe 98 ff f8 	brls	8000a240 <_dtoa_r+0x304>
8000a254:	6a 1b       	ld.w	r11,r5[0x4]
8000a256:	0e 9c       	mov	r12,r7
8000a258:	e0 a0 09 44 	rcall	8000b4e0 <_Balloc>
8000a25c:	58 e1       	cp.w	r1,14
8000a25e:	5f 88       	srls	r8
8000a260:	8b 0c       	st.w	r5[0x0],r12
8000a262:	f1 e4 00 04 	and	r4,r8,r4
8000a266:	6e 98       	ld.w	r8,r7[0x24]
8000a268:	70 08       	ld.w	r8,r8[0x0]
8000a26a:	50 88       	stdsp	sp[0x20],r8
8000a26c:	e0 80 01 82 	breq	8000a570 <_dtoa_r+0x634>
8000a270:	58 06       	cp.w	r6,0
8000a272:	e0 8a 00 43 	brle	8000a2f8 <_dtoa_r+0x3bc>
8000a276:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a27a:	fe c8 c3 ca 	sub	r8,pc,-15414
8000a27e:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a282:	fa e5 00 18 	st.d	sp[24],r4
8000a286:	ec 04 14 04 	asr	r4,r6,0x4
8000a28a:	ed b4 00 04 	bld	r4,0x4
8000a28e:	c0 30       	breq	8000a294 <_dtoa_r+0x358>
8000a290:	30 25       	mov	r5,2
8000a292:	c1 08       	rjmp	8000a2b2 <_dtoa_r+0x376>
8000a294:	fe c8 c3 1c 	sub	r8,pc,-15588
8000a298:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a29c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a2a0:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a2a4:	e0 a0 0f fa 	rcall	8000c298 <__avr32_f64_div>
8000a2a8:	30 35       	mov	r5,3
8000a2aa:	14 98       	mov	r8,r10
8000a2ac:	16 99       	mov	r9,r11
8000a2ae:	fa e9 00 08 	st.d	sp[8],r8
8000a2b2:	fe cc c3 3a 	sub	r12,pc,-15558
8000a2b6:	50 a3       	stdsp	sp[0x28],r3
8000a2b8:	0c 93       	mov	r3,r6
8000a2ba:	18 96       	mov	r6,r12
8000a2bc:	c0 f8       	rjmp	8000a2da <_dtoa_r+0x39e>
8000a2be:	fa ea 00 18 	ld.d	r10,sp[24]
8000a2c2:	ed b4 00 00 	bld	r4,0x0
8000a2c6:	c0 81       	brne	8000a2d6 <_dtoa_r+0x39a>
8000a2c8:	ec e8 00 00 	ld.d	r8,r6[0]
8000a2cc:	2f f5       	sub	r5,-1
8000a2ce:	e0 a0 0c 9f 	rcall	8000bc0c <__avr32_f64_mul>
8000a2d2:	fa eb 00 18 	st.d	sp[24],r10
8000a2d6:	a1 54       	asr	r4,0x1
8000a2d8:	2f 86       	sub	r6,-8
8000a2da:	58 04       	cp.w	r4,0
8000a2dc:	cf 11       	brne	8000a2be <_dtoa_r+0x382>
8000a2de:	fa e8 00 18 	ld.d	r8,sp[24]
8000a2e2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a2e6:	06 96       	mov	r6,r3
8000a2e8:	e0 a0 0f d8 	rcall	8000c298 <__avr32_f64_div>
8000a2ec:	40 a3       	lddsp	r3,sp[0x28]
8000a2ee:	14 98       	mov	r8,r10
8000a2f0:	16 99       	mov	r9,r11
8000a2f2:	fa e9 00 08 	st.d	sp[8],r8
8000a2f6:	c2 f8       	rjmp	8000a354 <_dtoa_r+0x418>
8000a2f8:	ec 08 11 00 	rsub	r8,r6,0
8000a2fc:	c0 31       	brne	8000a302 <_dtoa_r+0x3c6>
8000a2fe:	30 25       	mov	r5,2
8000a300:	c2 a8       	rjmp	8000a354 <_dtoa_r+0x418>
8000a302:	fe cc c3 8a 	sub	r12,pc,-15478
8000a306:	f0 04 14 04 	asr	r4,r8,0x4
8000a30a:	50 1c       	stdsp	sp[0x4],r12
8000a30c:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a310:	fe c9 c4 60 	sub	r9,pc,-15264
8000a314:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a318:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a31c:	e0 a0 0c 78 	rcall	8000bc0c <__avr32_f64_mul>
8000a320:	40 1c       	lddsp	r12,sp[0x4]
8000a322:	50 63       	stdsp	sp[0x18],r3
8000a324:	30 25       	mov	r5,2
8000a326:	0c 93       	mov	r3,r6
8000a328:	fa eb 00 08 	st.d	sp[8],r10
8000a32c:	18 96       	mov	r6,r12
8000a32e:	c0 f8       	rjmp	8000a34c <_dtoa_r+0x410>
8000a330:	fa ea 00 08 	ld.d	r10,sp[8]
8000a334:	ed b4 00 00 	bld	r4,0x0
8000a338:	c0 81       	brne	8000a348 <_dtoa_r+0x40c>
8000a33a:	ec e8 00 00 	ld.d	r8,r6[0]
8000a33e:	2f f5       	sub	r5,-1
8000a340:	e0 a0 0c 66 	rcall	8000bc0c <__avr32_f64_mul>
8000a344:	fa eb 00 08 	st.d	sp[8],r10
8000a348:	a1 54       	asr	r4,0x1
8000a34a:	2f 86       	sub	r6,-8
8000a34c:	58 04       	cp.w	r4,0
8000a34e:	cf 11       	brne	8000a330 <_dtoa_r+0x3f4>
8000a350:	06 96       	mov	r6,r3
8000a352:	40 63       	lddsp	r3,sp[0x18]
8000a354:	41 4a       	lddsp	r10,sp[0x50]
8000a356:	58 0a       	cp.w	r10,0
8000a358:	c2 a0       	breq	8000a3ac <_dtoa_r+0x470>
8000a35a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a35e:	58 01       	cp.w	r1,0
8000a360:	5f 94       	srgt	r4
8000a362:	fa e9 00 18 	st.d	sp[24],r8
8000a366:	30 08       	mov	r8,0
8000a368:	fc 19 3f f0 	movh	r9,0x3ff0
8000a36c:	fa ea 00 18 	ld.d	r10,sp[24]
8000a370:	e0 a0 0f 60 	rcall	8000c230 <__avr32_f64_cmp_lt>
8000a374:	f9 bc 00 00 	moveq	r12,0
8000a378:	f9 bc 01 01 	movne	r12,1
8000a37c:	e9 ec 00 0c 	and	r12,r4,r12
8000a380:	c1 60       	breq	8000a3ac <_dtoa_r+0x470>
8000a382:	40 98       	lddsp	r8,sp[0x24]
8000a384:	58 08       	cp.w	r8,0
8000a386:	e0 8a 00 f1 	brle	8000a568 <_dtoa_r+0x62c>
8000a38a:	30 08       	mov	r8,0
8000a38c:	fc 19 40 24 	movh	r9,0x4024
8000a390:	ec c4 00 01 	sub	r4,r6,1
8000a394:	fa ea 00 18 	ld.d	r10,sp[24]
8000a398:	2f f5       	sub	r5,-1
8000a39a:	50 64       	stdsp	sp[0x18],r4
8000a39c:	e0 a0 0c 38 	rcall	8000bc0c <__avr32_f64_mul>
8000a3a0:	40 94       	lddsp	r4,sp[0x24]
8000a3a2:	14 98       	mov	r8,r10
8000a3a4:	16 99       	mov	r9,r11
8000a3a6:	fa e9 00 08 	st.d	sp[8],r8
8000a3aa:	c0 38       	rjmp	8000a3b0 <_dtoa_r+0x474>
8000a3ac:	50 66       	stdsp	sp[0x18],r6
8000a3ae:	02 94       	mov	r4,r1
8000a3b0:	0a 9c       	mov	r12,r5
8000a3b2:	e0 a0 0e 88 	rcall	8000c0c2 <__avr32_s32_to_f64>
8000a3b6:	fa e8 00 08 	ld.d	r8,sp[8]
8000a3ba:	e0 a0 0c 29 	rcall	8000bc0c <__avr32_f64_mul>
8000a3be:	30 08       	mov	r8,0
8000a3c0:	fc 19 40 1c 	movh	r9,0x401c
8000a3c4:	e0 a0 0d de 	rcall	8000bf80 <__avr32_f64_add>
8000a3c8:	14 98       	mov	r8,r10
8000a3ca:	16 99       	mov	r9,r11
8000a3cc:	fa e9 00 28 	st.d	sp[40],r8
8000a3d0:	fc 18 fc c0 	movh	r8,0xfcc0
8000a3d4:	40 a5       	lddsp	r5,sp[0x28]
8000a3d6:	10 05       	add	r5,r8
8000a3d8:	50 a5       	stdsp	sp[0x28],r5
8000a3da:	58 04       	cp.w	r4,0
8000a3dc:	c2 11       	brne	8000a41e <_dtoa_r+0x4e2>
8000a3de:	fa ea 00 08 	ld.d	r10,sp[8]
8000a3e2:	30 08       	mov	r8,0
8000a3e4:	fc 19 40 14 	movh	r9,0x4014
8000a3e8:	e0 a0 0c fe 	rcall	8000bde4 <__avr32_f64_sub>
8000a3ec:	40 bc       	lddsp	r12,sp[0x2c]
8000a3ee:	fa eb 00 08 	st.d	sp[8],r10
8000a3f2:	14 98       	mov	r8,r10
8000a3f4:	16 99       	mov	r9,r11
8000a3f6:	18 9a       	mov	r10,r12
8000a3f8:	0a 9b       	mov	r11,r5
8000a3fa:	e0 a0 0f 1b 	rcall	8000c230 <__avr32_f64_cmp_lt>
8000a3fe:	e0 81 02 54 	brne	8000a8a6 <_dtoa_r+0x96a>
8000a402:	0a 98       	mov	r8,r5
8000a404:	40 b9       	lddsp	r9,sp[0x2c]
8000a406:	ee 18 80 00 	eorh	r8,0x8000
8000a40a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a40e:	10 95       	mov	r5,r8
8000a410:	12 98       	mov	r8,r9
8000a412:	0a 99       	mov	r9,r5
8000a414:	e0 a0 0f 0e 	rcall	8000c230 <__avr32_f64_cmp_lt>
8000a418:	e0 81 02 3e 	brne	8000a894 <_dtoa_r+0x958>
8000a41c:	ca 68       	rjmp	8000a568 <_dtoa_r+0x62c>
8000a41e:	fe c9 c5 6e 	sub	r9,pc,-14994
8000a422:	e8 c8 00 01 	sub	r8,r4,1
8000a426:	40 d5       	lddsp	r5,sp[0x34]
8000a428:	58 05       	cp.w	r5,0
8000a42a:	c4 f0       	breq	8000a4c8 <_dtoa_r+0x58c>
8000a42c:	30 0c       	mov	r12,0
8000a42e:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a432:	51 3c       	stdsp	sp[0x4c],r12
8000a434:	30 0a       	mov	r10,0
8000a436:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a43a:	e0 a0 0f 2f 	rcall	8000c298 <__avr32_f64_div>
8000a43e:	fa e8 00 28 	ld.d	r8,sp[40]
8000a442:	40 85       	lddsp	r5,sp[0x20]
8000a444:	e0 a0 0c d0 	rcall	8000bde4 <__avr32_f64_sub>
8000a448:	fa eb 00 28 	st.d	sp[40],r10
8000a44c:	fa ea 00 08 	ld.d	r10,sp[8]
8000a450:	e0 a0 0e 22 	rcall	8000c094 <__avr32_f64_to_s32>
8000a454:	51 6c       	stdsp	sp[0x58],r12
8000a456:	e0 a0 0e 36 	rcall	8000c0c2 <__avr32_s32_to_f64>
8000a45a:	14 98       	mov	r8,r10
8000a45c:	16 99       	mov	r9,r11
8000a45e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a462:	e0 a0 0c c1 	rcall	8000bde4 <__avr32_f64_sub>
8000a466:	fa eb 00 08 	st.d	sp[8],r10
8000a46a:	41 68       	lddsp	r8,sp[0x58]
8000a46c:	2d 08       	sub	r8,-48
8000a46e:	0a c8       	st.b	r5++,r8
8000a470:	41 39       	lddsp	r9,sp[0x4c]
8000a472:	2f f9       	sub	r9,-1
8000a474:	51 39       	stdsp	sp[0x4c],r9
8000a476:	fa e8 00 28 	ld.d	r8,sp[40]
8000a47a:	e0 a0 0e db 	rcall	8000c230 <__avr32_f64_cmp_lt>
8000a47e:	e0 81 03 39 	brne	8000aaf0 <_dtoa_r+0xbb4>
8000a482:	fa e8 00 08 	ld.d	r8,sp[8]
8000a486:	30 0a       	mov	r10,0
8000a488:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a48c:	e0 a0 0c ac 	rcall	8000bde4 <__avr32_f64_sub>
8000a490:	fa e8 00 28 	ld.d	r8,sp[40]
8000a494:	e0 a0 0e ce 	rcall	8000c230 <__avr32_f64_cmp_lt>
8000a498:	fa ea 00 28 	ld.d	r10,sp[40]
8000a49c:	30 08       	mov	r8,0
8000a49e:	fc 19 40 24 	movh	r9,0x4024
8000a4a2:	e0 81 00 da 	brne	8000a656 <_dtoa_r+0x71a>
8000a4a6:	41 3c       	lddsp	r12,sp[0x4c]
8000a4a8:	08 3c       	cp.w	r12,r4
8000a4aa:	c5 f4       	brge	8000a568 <_dtoa_r+0x62c>
8000a4ac:	e0 a0 0b b0 	rcall	8000bc0c <__avr32_f64_mul>
8000a4b0:	30 08       	mov	r8,0
8000a4b2:	fa eb 00 28 	st.d	sp[40],r10
8000a4b6:	fc 19 40 24 	movh	r9,0x4024
8000a4ba:	fa ea 00 08 	ld.d	r10,sp[8]
8000a4be:	e0 a0 0b a7 	rcall	8000bc0c <__avr32_f64_mul>
8000a4c2:	fa eb 00 08 	st.d	sp[8],r10
8000a4c6:	cc 3b       	rjmp	8000a44c <_dtoa_r+0x510>
8000a4c8:	40 85       	lddsp	r5,sp[0x20]
8000a4ca:	08 05       	add	r5,r4
8000a4cc:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a4d0:	51 35       	stdsp	sp[0x4c],r5
8000a4d2:	fa e8 00 28 	ld.d	r8,sp[40]
8000a4d6:	40 85       	lddsp	r5,sp[0x20]
8000a4d8:	e0 a0 0b 9a 	rcall	8000bc0c <__avr32_f64_mul>
8000a4dc:	fa eb 00 28 	st.d	sp[40],r10
8000a4e0:	fa ea 00 08 	ld.d	r10,sp[8]
8000a4e4:	e0 a0 0d d8 	rcall	8000c094 <__avr32_f64_to_s32>
8000a4e8:	51 6c       	stdsp	sp[0x58],r12
8000a4ea:	e0 a0 0d ec 	rcall	8000c0c2 <__avr32_s32_to_f64>
8000a4ee:	14 98       	mov	r8,r10
8000a4f0:	16 99       	mov	r9,r11
8000a4f2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a4f6:	e0 a0 0c 77 	rcall	8000bde4 <__avr32_f64_sub>
8000a4fa:	fa eb 00 08 	st.d	sp[8],r10
8000a4fe:	41 68       	lddsp	r8,sp[0x58]
8000a500:	2d 08       	sub	r8,-48
8000a502:	0a c8       	st.b	r5++,r8
8000a504:	41 3c       	lddsp	r12,sp[0x4c]
8000a506:	18 35       	cp.w	r5,r12
8000a508:	c2 81       	brne	8000a558 <_dtoa_r+0x61c>
8000a50a:	30 08       	mov	r8,0
8000a50c:	fc 19 3f e0 	movh	r9,0x3fe0
8000a510:	fa ea 00 28 	ld.d	r10,sp[40]
8000a514:	e0 a0 0d 36 	rcall	8000bf80 <__avr32_f64_add>
8000a518:	40 85       	lddsp	r5,sp[0x20]
8000a51a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a51e:	08 05       	add	r5,r4
8000a520:	e0 a0 0e 88 	rcall	8000c230 <__avr32_f64_cmp_lt>
8000a524:	e0 81 00 99 	brne	8000a656 <_dtoa_r+0x71a>
8000a528:	fa e8 00 28 	ld.d	r8,sp[40]
8000a52c:	30 0a       	mov	r10,0
8000a52e:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a532:	e0 a0 0c 59 	rcall	8000bde4 <__avr32_f64_sub>
8000a536:	14 98       	mov	r8,r10
8000a538:	16 99       	mov	r9,r11
8000a53a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a53e:	e0 a0 0e 79 	rcall	8000c230 <__avr32_f64_cmp_lt>
8000a542:	c1 30       	breq	8000a568 <_dtoa_r+0x62c>
8000a544:	33 09       	mov	r9,48
8000a546:	0a 98       	mov	r8,r5
8000a548:	11 7a       	ld.ub	r10,--r8
8000a54a:	f2 0a 18 00 	cp.b	r10,r9
8000a54e:	e0 81 02 d1 	brne	8000aaf0 <_dtoa_r+0xbb4>
8000a552:	10 95       	mov	r5,r8
8000a554:	cf 9b       	rjmp	8000a546 <_dtoa_r+0x60a>
8000a556:	d7 03       	nop
8000a558:	30 08       	mov	r8,0
8000a55a:	fc 19 40 24 	movh	r9,0x4024
8000a55e:	e0 a0 0b 57 	rcall	8000bc0c <__avr32_f64_mul>
8000a562:	fa eb 00 08 	st.d	sp[8],r10
8000a566:	cb db       	rjmp	8000a4e0 <_dtoa_r+0x5a4>
8000a568:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a56c:	fa eb 00 08 	st.d	sp[8],r10
8000a570:	58 e6       	cp.w	r6,14
8000a572:	5f ab       	srle	r11
8000a574:	41 8a       	lddsp	r10,sp[0x60]
8000a576:	30 08       	mov	r8,0
8000a578:	f4 09 11 ff 	rsub	r9,r10,-1
8000a57c:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a580:	f0 09 18 00 	cp.b	r9,r8
8000a584:	e0 80 00 82 	breq	8000a688 <_dtoa_r+0x74c>
8000a588:	40 ea       	lddsp	r10,sp[0x38]
8000a58a:	58 01       	cp.w	r1,0
8000a58c:	5f a9       	srle	r9
8000a58e:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a592:	fe ca c6 e2 	sub	r10,pc,-14622
8000a596:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a59a:	fa e5 00 10 	st.d	sp[16],r4
8000a59e:	f0 09 18 00 	cp.b	r9,r8
8000a5a2:	c1 40       	breq	8000a5ca <_dtoa_r+0x68e>
8000a5a4:	58 01       	cp.w	r1,0
8000a5a6:	e0 81 01 77 	brne	8000a894 <_dtoa_r+0x958>
8000a5aa:	30 08       	mov	r8,0
8000a5ac:	fc 19 40 14 	movh	r9,0x4014
8000a5b0:	08 9a       	mov	r10,r4
8000a5b2:	0a 9b       	mov	r11,r5
8000a5b4:	e0 a0 0b 2c 	rcall	8000bc0c <__avr32_f64_mul>
8000a5b8:	fa e8 00 08 	ld.d	r8,sp[8]
8000a5bc:	e0 a0 0e 06 	rcall	8000c1c8 <__avr32_f64_cmp_ge>
8000a5c0:	e0 81 01 6a 	brne	8000a894 <_dtoa_r+0x958>
8000a5c4:	02 92       	mov	r2,r1
8000a5c6:	e0 8f 01 72 	bral	8000a8aa <_dtoa_r+0x96e>
8000a5ca:	40 85       	lddsp	r5,sp[0x20]
8000a5cc:	30 14       	mov	r4,1
8000a5ce:	fa e8 00 10 	ld.d	r8,sp[16]
8000a5d2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a5d6:	e0 a0 0e 61 	rcall	8000c298 <__avr32_f64_div>
8000a5da:	e0 a0 0d 5d 	rcall	8000c094 <__avr32_f64_to_s32>
8000a5de:	18 92       	mov	r2,r12
8000a5e0:	e0 a0 0d 71 	rcall	8000c0c2 <__avr32_s32_to_f64>
8000a5e4:	fa e8 00 10 	ld.d	r8,sp[16]
8000a5e8:	e0 a0 0b 12 	rcall	8000bc0c <__avr32_f64_mul>
8000a5ec:	14 98       	mov	r8,r10
8000a5ee:	16 99       	mov	r9,r11
8000a5f0:	fa ea 00 08 	ld.d	r10,sp[8]
8000a5f4:	e0 a0 0b f8 	rcall	8000bde4 <__avr32_f64_sub>
8000a5f8:	fa eb 00 08 	st.d	sp[8],r10
8000a5fc:	e4 c8 ff d0 	sub	r8,r2,-48
8000a600:	0a c8       	st.b	r5++,r8
8000a602:	fc 19 40 24 	movh	r9,0x4024
8000a606:	30 08       	mov	r8,0
8000a608:	02 34       	cp.w	r4,r1
8000a60a:	c3 31       	brne	8000a670 <_dtoa_r+0x734>
8000a60c:	fa e8 00 08 	ld.d	r8,sp[8]
8000a610:	e0 a0 0c b8 	rcall	8000bf80 <__avr32_f64_add>
8000a614:	16 91       	mov	r1,r11
8000a616:	14 90       	mov	r0,r10
8000a618:	14 98       	mov	r8,r10
8000a61a:	02 99       	mov	r9,r1
8000a61c:	fa ea 00 10 	ld.d	r10,sp[16]
8000a620:	e0 a0 0e 08 	rcall	8000c230 <__avr32_f64_cmp_lt>
8000a624:	c1 a1       	brne	8000a658 <_dtoa_r+0x71c>
8000a626:	fa e8 00 10 	ld.d	r8,sp[16]
8000a62a:	00 9a       	mov	r10,r0
8000a62c:	02 9b       	mov	r11,r1
8000a62e:	e0 a0 0d ba 	rcall	8000c1a2 <__avr32_f64_cmp_eq>
8000a632:	e0 80 02 5e 	breq	8000aaee <_dtoa_r+0xbb2>
8000a636:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a63a:	c0 f1       	brne	8000a658 <_dtoa_r+0x71c>
8000a63c:	e0 8f 02 59 	bral	8000aaee <_dtoa_r+0xbb2>
8000a640:	40 8a       	lddsp	r10,sp[0x20]
8000a642:	14 38       	cp.w	r8,r10
8000a644:	c0 30       	breq	8000a64a <_dtoa_r+0x70e>
8000a646:	10 95       	mov	r5,r8
8000a648:	c0 98       	rjmp	8000a65a <_dtoa_r+0x71e>
8000a64a:	33 08       	mov	r8,48
8000a64c:	40 89       	lddsp	r9,sp[0x20]
8000a64e:	2f f6       	sub	r6,-1
8000a650:	b2 88       	st.b	r9[0x0],r8
8000a652:	40 88       	lddsp	r8,sp[0x20]
8000a654:	c0 88       	rjmp	8000a664 <_dtoa_r+0x728>
8000a656:	40 66       	lddsp	r6,sp[0x18]
8000a658:	33 99       	mov	r9,57
8000a65a:	0a 98       	mov	r8,r5
8000a65c:	11 7a       	ld.ub	r10,--r8
8000a65e:	f2 0a 18 00 	cp.b	r10,r9
8000a662:	ce f0       	breq	8000a640 <_dtoa_r+0x704>
8000a664:	50 66       	stdsp	sp[0x18],r6
8000a666:	11 89       	ld.ub	r9,r8[0x0]
8000a668:	2f f9       	sub	r9,-1
8000a66a:	b0 89       	st.b	r8[0x0],r9
8000a66c:	e0 8f 02 42 	bral	8000aaf0 <_dtoa_r+0xbb4>
8000a670:	e0 a0 0a ce 	rcall	8000bc0c <__avr32_f64_mul>
8000a674:	2f f4       	sub	r4,-1
8000a676:	fa eb 00 08 	st.d	sp[8],r10
8000a67a:	30 08       	mov	r8,0
8000a67c:	30 09       	mov	r9,0
8000a67e:	e0 a0 0d 92 	rcall	8000c1a2 <__avr32_f64_cmp_eq>
8000a682:	ca 60       	breq	8000a5ce <_dtoa_r+0x692>
8000a684:	e0 8f 02 35 	bral	8000aaee <_dtoa_r+0xbb2>
8000a688:	40 d8       	lddsp	r8,sp[0x34]
8000a68a:	58 08       	cp.w	r8,0
8000a68c:	c0 51       	brne	8000a696 <_dtoa_r+0x75a>
8000a68e:	04 98       	mov	r8,r2
8000a690:	00 95       	mov	r5,r0
8000a692:	40 d4       	lddsp	r4,sp[0x34]
8000a694:	c3 78       	rjmp	8000a702 <_dtoa_r+0x7c6>
8000a696:	40 c5       	lddsp	r5,sp[0x30]
8000a698:	58 15       	cp.w	r5,1
8000a69a:	e0 89 00 0f 	brgt	8000a6b8 <_dtoa_r+0x77c>
8000a69e:	41 74       	lddsp	r4,sp[0x5c]
8000a6a0:	58 04       	cp.w	r4,0
8000a6a2:	c0 40       	breq	8000a6aa <_dtoa_r+0x76e>
8000a6a4:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a6a8:	c0 48       	rjmp	8000a6b0 <_dtoa_r+0x774>
8000a6aa:	41 99       	lddsp	r9,sp[0x64]
8000a6ac:	f2 09 11 36 	rsub	r9,r9,54
8000a6b0:	04 98       	mov	r8,r2
8000a6b2:	00 95       	mov	r5,r0
8000a6b4:	c1 c8       	rjmp	8000a6ec <_dtoa_r+0x7b0>
8000a6b6:	d7 03       	nop
8000a6b8:	e2 c8 00 01 	sub	r8,r1,1
8000a6bc:	58 01       	cp.w	r1,0
8000a6be:	e0 05 17 40 	movge	r5,r0
8000a6c2:	e2 09 17 40 	movge	r9,r1
8000a6c6:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a6ca:	f9 b9 05 00 	movlt	r9,0
8000a6ce:	10 32       	cp.w	r2,r8
8000a6d0:	e5 d8 e4 18 	subge	r8,r2,r8
8000a6d4:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a6d8:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a6dc:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a6e0:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a6e4:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a6e8:	f9 b8 05 00 	movlt	r8,0
8000a6ec:	40 4b       	lddsp	r11,sp[0x10]
8000a6ee:	12 0b       	add	r11,r9
8000a6f0:	50 08       	stdsp	sp[0x0],r8
8000a6f2:	50 4b       	stdsp	sp[0x10],r11
8000a6f4:	12 00       	add	r0,r9
8000a6f6:	30 1b       	mov	r11,1
8000a6f8:	0e 9c       	mov	r12,r7
8000a6fa:	e0 a0 08 a7 	rcall	8000b848 <__i2b>
8000a6fe:	40 08       	lddsp	r8,sp[0x0]
8000a700:	18 94       	mov	r4,r12
8000a702:	40 4a       	lddsp	r10,sp[0x10]
8000a704:	58 05       	cp.w	r5,0
8000a706:	5f 99       	srgt	r9
8000a708:	58 0a       	cp.w	r10,0
8000a70a:	5f 9a       	srgt	r10
8000a70c:	f5 e9 00 09 	and	r9,r10,r9
8000a710:	c0 80       	breq	8000a720 <_dtoa_r+0x7e4>
8000a712:	40 4c       	lddsp	r12,sp[0x10]
8000a714:	f8 05 0d 49 	min	r9,r12,r5
8000a718:	12 1c       	sub	r12,r9
8000a71a:	12 10       	sub	r0,r9
8000a71c:	50 4c       	stdsp	sp[0x10],r12
8000a71e:	12 15       	sub	r5,r9
8000a720:	58 02       	cp.w	r2,0
8000a722:	e0 8a 00 27 	brle	8000a770 <_dtoa_r+0x834>
8000a726:	40 db       	lddsp	r11,sp[0x34]
8000a728:	58 0b       	cp.w	r11,0
8000a72a:	c1 d0       	breq	8000a764 <_dtoa_r+0x828>
8000a72c:	58 08       	cp.w	r8,0
8000a72e:	e0 8a 00 17 	brle	8000a75c <_dtoa_r+0x820>
8000a732:	10 9a       	mov	r10,r8
8000a734:	50 08       	stdsp	sp[0x0],r8
8000a736:	08 9b       	mov	r11,r4
8000a738:	0e 9c       	mov	r12,r7
8000a73a:	e0 a0 08 cd 	rcall	8000b8d4 <__pow5mult>
8000a73e:	06 9a       	mov	r10,r3
8000a740:	18 9b       	mov	r11,r12
8000a742:	18 94       	mov	r4,r12
8000a744:	0e 9c       	mov	r12,r7
8000a746:	e0 a0 08 01 	rcall	8000b748 <__multiply>
8000a74a:	18 99       	mov	r9,r12
8000a74c:	06 9b       	mov	r11,r3
8000a74e:	50 19       	stdsp	sp[0x4],r9
8000a750:	0e 9c       	mov	r12,r7
8000a752:	e0 a0 06 ad 	rcall	8000b4ac <_Bfree>
8000a756:	40 19       	lddsp	r9,sp[0x4]
8000a758:	40 08       	lddsp	r8,sp[0x0]
8000a75a:	12 93       	mov	r3,r9
8000a75c:	e4 08 01 0a 	sub	r10,r2,r8
8000a760:	c0 80       	breq	8000a770 <_dtoa_r+0x834>
8000a762:	c0 28       	rjmp	8000a766 <_dtoa_r+0x82a>
8000a764:	04 9a       	mov	r10,r2
8000a766:	06 9b       	mov	r11,r3
8000a768:	0e 9c       	mov	r12,r7
8000a76a:	e0 a0 08 b5 	rcall	8000b8d4 <__pow5mult>
8000a76e:	18 93       	mov	r3,r12
8000a770:	30 1b       	mov	r11,1
8000a772:	0e 9c       	mov	r12,r7
8000a774:	e0 a0 08 6a 	rcall	8000b848 <__i2b>
8000a778:	41 1a       	lddsp	r10,sp[0x44]
8000a77a:	18 92       	mov	r2,r12
8000a77c:	58 0a       	cp.w	r10,0
8000a77e:	e0 8a 00 07 	brle	8000a78c <_dtoa_r+0x850>
8000a782:	18 9b       	mov	r11,r12
8000a784:	0e 9c       	mov	r12,r7
8000a786:	e0 a0 08 a7 	rcall	8000b8d4 <__pow5mult>
8000a78a:	18 92       	mov	r2,r12
8000a78c:	40 c9       	lddsp	r9,sp[0x30]
8000a78e:	58 19       	cp.w	r9,1
8000a790:	e0 89 00 14 	brgt	8000a7b8 <_dtoa_r+0x87c>
8000a794:	40 38       	lddsp	r8,sp[0xc]
8000a796:	58 08       	cp.w	r8,0
8000a798:	c1 01       	brne	8000a7b8 <_dtoa_r+0x87c>
8000a79a:	40 29       	lddsp	r9,sp[0x8]
8000a79c:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a7a0:	c0 c1       	brne	8000a7b8 <_dtoa_r+0x87c>
8000a7a2:	12 98       	mov	r8,r9
8000a7a4:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a7a8:	c0 80       	breq	8000a7b8 <_dtoa_r+0x87c>
8000a7aa:	40 4c       	lddsp	r12,sp[0x10]
8000a7ac:	30 1b       	mov	r11,1
8000a7ae:	2f fc       	sub	r12,-1
8000a7b0:	2f f0       	sub	r0,-1
8000a7b2:	50 4c       	stdsp	sp[0x10],r12
8000a7b4:	50 6b       	stdsp	sp[0x18],r11
8000a7b6:	c0 38       	rjmp	8000a7bc <_dtoa_r+0x880>
8000a7b8:	30 0a       	mov	r10,0
8000a7ba:	50 6a       	stdsp	sp[0x18],r10
8000a7bc:	41 19       	lddsp	r9,sp[0x44]
8000a7be:	58 09       	cp.w	r9,0
8000a7c0:	c0 31       	brne	8000a7c6 <_dtoa_r+0x88a>
8000a7c2:	30 1c       	mov	r12,1
8000a7c4:	c0 98       	rjmp	8000a7d6 <_dtoa_r+0x89a>
8000a7c6:	64 48       	ld.w	r8,r2[0x10]
8000a7c8:	2f c8       	sub	r8,-4
8000a7ca:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a7ce:	e0 a0 05 df 	rcall	8000b38c <__hi0bits>
8000a7d2:	f8 0c 11 20 	rsub	r12,r12,32
8000a7d6:	40 4b       	lddsp	r11,sp[0x10]
8000a7d8:	f8 0b 00 08 	add	r8,r12,r11
8000a7dc:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a7e0:	c0 c0       	breq	8000a7f8 <_dtoa_r+0x8bc>
8000a7e2:	f0 08 11 20 	rsub	r8,r8,32
8000a7e6:	58 48       	cp.w	r8,4
8000a7e8:	e0 8a 00 06 	brle	8000a7f4 <_dtoa_r+0x8b8>
8000a7ec:	20 48       	sub	r8,4
8000a7ee:	10 0b       	add	r11,r8
8000a7f0:	50 4b       	stdsp	sp[0x10],r11
8000a7f2:	c0 78       	rjmp	8000a800 <_dtoa_r+0x8c4>
8000a7f4:	58 48       	cp.w	r8,4
8000a7f6:	c0 70       	breq	8000a804 <_dtoa_r+0x8c8>
8000a7f8:	40 4a       	lddsp	r10,sp[0x10]
8000a7fa:	2e 48       	sub	r8,-28
8000a7fc:	10 0a       	add	r10,r8
8000a7fe:	50 4a       	stdsp	sp[0x10],r10
8000a800:	10 00       	add	r0,r8
8000a802:	10 05       	add	r5,r8
8000a804:	58 00       	cp.w	r0,0
8000a806:	e0 8a 00 08 	brle	8000a816 <_dtoa_r+0x8da>
8000a80a:	06 9b       	mov	r11,r3
8000a80c:	00 9a       	mov	r10,r0
8000a80e:	0e 9c       	mov	r12,r7
8000a810:	e0 a0 07 58 	rcall	8000b6c0 <__lshift>
8000a814:	18 93       	mov	r3,r12
8000a816:	40 49       	lddsp	r9,sp[0x10]
8000a818:	58 09       	cp.w	r9,0
8000a81a:	e0 8a 00 08 	brle	8000a82a <_dtoa_r+0x8ee>
8000a81e:	04 9b       	mov	r11,r2
8000a820:	12 9a       	mov	r10,r9
8000a822:	0e 9c       	mov	r12,r7
8000a824:	e0 a0 07 4e 	rcall	8000b6c0 <__lshift>
8000a828:	18 92       	mov	r2,r12
8000a82a:	41 48       	lddsp	r8,sp[0x50]
8000a82c:	58 08       	cp.w	r8,0
8000a82e:	c1 b0       	breq	8000a864 <_dtoa_r+0x928>
8000a830:	04 9b       	mov	r11,r2
8000a832:	06 9c       	mov	r12,r3
8000a834:	e0 a0 06 23 	rcall	8000b47a <__mcmp>
8000a838:	c1 64       	brge	8000a864 <_dtoa_r+0x928>
8000a83a:	06 9b       	mov	r11,r3
8000a83c:	30 09       	mov	r9,0
8000a83e:	30 aa       	mov	r10,10
8000a840:	0e 9c       	mov	r12,r7
8000a842:	e0 a0 08 0b 	rcall	8000b858 <__multadd>
8000a846:	20 16       	sub	r6,1
8000a848:	18 93       	mov	r3,r12
8000a84a:	40 dc       	lddsp	r12,sp[0x34]
8000a84c:	58 0c       	cp.w	r12,0
8000a84e:	c0 31       	brne	8000a854 <_dtoa_r+0x918>
8000a850:	40 91       	lddsp	r1,sp[0x24]
8000a852:	c0 98       	rjmp	8000a864 <_dtoa_r+0x928>
8000a854:	08 9b       	mov	r11,r4
8000a856:	40 91       	lddsp	r1,sp[0x24]
8000a858:	30 09       	mov	r9,0
8000a85a:	30 aa       	mov	r10,10
8000a85c:	0e 9c       	mov	r12,r7
8000a85e:	e0 a0 07 fd 	rcall	8000b858 <__multadd>
8000a862:	18 94       	mov	r4,r12
8000a864:	58 01       	cp.w	r1,0
8000a866:	5f a9       	srle	r9
8000a868:	40 cb       	lddsp	r11,sp[0x30]
8000a86a:	58 2b       	cp.w	r11,2
8000a86c:	5f 98       	srgt	r8
8000a86e:	f3 e8 00 08 	and	r8,r9,r8
8000a872:	c2 50       	breq	8000a8bc <_dtoa_r+0x980>
8000a874:	58 01       	cp.w	r1,0
8000a876:	c1 11       	brne	8000a898 <_dtoa_r+0x95c>
8000a878:	04 9b       	mov	r11,r2
8000a87a:	02 99       	mov	r9,r1
8000a87c:	30 5a       	mov	r10,5
8000a87e:	0e 9c       	mov	r12,r7
8000a880:	e0 a0 07 ec 	rcall	8000b858 <__multadd>
8000a884:	18 92       	mov	r2,r12
8000a886:	18 9b       	mov	r11,r12
8000a888:	06 9c       	mov	r12,r3
8000a88a:	e0 a0 05 f8 	rcall	8000b47a <__mcmp>
8000a88e:	e0 89 00 0f 	brgt	8000a8ac <_dtoa_r+0x970>
8000a892:	c0 38       	rjmp	8000a898 <_dtoa_r+0x95c>
8000a894:	30 02       	mov	r2,0
8000a896:	04 94       	mov	r4,r2
8000a898:	40 ea       	lddsp	r10,sp[0x38]
8000a89a:	30 09       	mov	r9,0
8000a89c:	5c da       	com	r10
8000a89e:	40 85       	lddsp	r5,sp[0x20]
8000a8a0:	50 6a       	stdsp	sp[0x18],r10
8000a8a2:	50 49       	stdsp	sp[0x10],r9
8000a8a4:	c0 f9       	rjmp	8000aac2 <_dtoa_r+0xb86>
8000a8a6:	08 92       	mov	r2,r4
8000a8a8:	40 66       	lddsp	r6,sp[0x18]
8000a8aa:	04 94       	mov	r4,r2
8000a8ac:	2f f6       	sub	r6,-1
8000a8ae:	50 66       	stdsp	sp[0x18],r6
8000a8b0:	33 18       	mov	r8,49
8000a8b2:	40 85       	lddsp	r5,sp[0x20]
8000a8b4:	0a c8       	st.b	r5++,r8
8000a8b6:	30 08       	mov	r8,0
8000a8b8:	50 48       	stdsp	sp[0x10],r8
8000a8ba:	c0 49       	rjmp	8000aac2 <_dtoa_r+0xb86>
8000a8bc:	40 dc       	lddsp	r12,sp[0x34]
8000a8be:	58 0c       	cp.w	r12,0
8000a8c0:	e0 80 00 b5 	breq	8000aa2a <_dtoa_r+0xaee>
8000a8c4:	58 05       	cp.w	r5,0
8000a8c6:	e0 8a 00 08 	brle	8000a8d6 <_dtoa_r+0x99a>
8000a8ca:	08 9b       	mov	r11,r4
8000a8cc:	0a 9a       	mov	r10,r5
8000a8ce:	0e 9c       	mov	r12,r7
8000a8d0:	e0 a0 06 f8 	rcall	8000b6c0 <__lshift>
8000a8d4:	18 94       	mov	r4,r12
8000a8d6:	40 6b       	lddsp	r11,sp[0x18]
8000a8d8:	58 0b       	cp.w	r11,0
8000a8da:	c0 31       	brne	8000a8e0 <_dtoa_r+0x9a4>
8000a8dc:	08 9c       	mov	r12,r4
8000a8de:	c1 38       	rjmp	8000a904 <_dtoa_r+0x9c8>
8000a8e0:	68 1b       	ld.w	r11,r4[0x4]
8000a8e2:	0e 9c       	mov	r12,r7
8000a8e4:	e0 a0 05 fe 	rcall	8000b4e0 <_Balloc>
8000a8e8:	68 4a       	ld.w	r10,r4[0x10]
8000a8ea:	18 95       	mov	r5,r12
8000a8ec:	e8 cb ff f4 	sub	r11,r4,-12
8000a8f0:	2f ea       	sub	r10,-2
8000a8f2:	2f 4c       	sub	r12,-12
8000a8f4:	a3 6a       	lsl	r10,0x2
8000a8f6:	fe b0 e6 4f 	rcall	80007594 <memcpy>
8000a8fa:	0a 9b       	mov	r11,r5
8000a8fc:	30 1a       	mov	r10,1
8000a8fe:	0e 9c       	mov	r12,r7
8000a900:	e0 a0 06 e0 	rcall	8000b6c0 <__lshift>
8000a904:	50 44       	stdsp	sp[0x10],r4
8000a906:	40 3a       	lddsp	r10,sp[0xc]
8000a908:	30 19       	mov	r9,1
8000a90a:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a90e:	18 94       	mov	r4,r12
8000a910:	50 da       	stdsp	sp[0x34],r10
8000a912:	40 85       	lddsp	r5,sp[0x20]
8000a914:	50 99       	stdsp	sp[0x24],r9
8000a916:	50 26       	stdsp	sp[0x8],r6
8000a918:	50 e1       	stdsp	sp[0x38],r1
8000a91a:	04 9b       	mov	r11,r2
8000a91c:	06 9c       	mov	r12,r3
8000a91e:	fe b0 fa 7f 	rcall	80009e1c <quorem>
8000a922:	40 4b       	lddsp	r11,sp[0x10]
8000a924:	f8 c0 ff d0 	sub	r0,r12,-48
8000a928:	06 9c       	mov	r12,r3
8000a92a:	e0 a0 05 a8 	rcall	8000b47a <__mcmp>
8000a92e:	08 9a       	mov	r10,r4
8000a930:	50 6c       	stdsp	sp[0x18],r12
8000a932:	04 9b       	mov	r11,r2
8000a934:	0e 9c       	mov	r12,r7
8000a936:	e0 a0 06 5d 	rcall	8000b5f0 <__mdiff>
8000a93a:	18 91       	mov	r1,r12
8000a93c:	78 38       	ld.w	r8,r12[0xc]
8000a93e:	58 08       	cp.w	r8,0
8000a940:	c0 30       	breq	8000a946 <_dtoa_r+0xa0a>
8000a942:	30 16       	mov	r6,1
8000a944:	c0 68       	rjmp	8000a950 <_dtoa_r+0xa14>
8000a946:	18 9b       	mov	r11,r12
8000a948:	06 9c       	mov	r12,r3
8000a94a:	e0 a0 05 98 	rcall	8000b47a <__mcmp>
8000a94e:	18 96       	mov	r6,r12
8000a950:	0e 9c       	mov	r12,r7
8000a952:	02 9b       	mov	r11,r1
8000a954:	e0 a0 05 ac 	rcall	8000b4ac <_Bfree>
8000a958:	40 cc       	lddsp	r12,sp[0x30]
8000a95a:	ed ec 10 08 	or	r8,r6,r12
8000a95e:	c0 d1       	brne	8000a978 <_dtoa_r+0xa3c>
8000a960:	40 db       	lddsp	r11,sp[0x34]
8000a962:	58 0b       	cp.w	r11,0
8000a964:	c0 a1       	brne	8000a978 <_dtoa_r+0xa3c>
8000a966:	40 26       	lddsp	r6,sp[0x8]
8000a968:	e0 40 00 39 	cp.w	r0,57
8000a96c:	c3 00       	breq	8000a9cc <_dtoa_r+0xa90>
8000a96e:	40 6a       	lddsp	r10,sp[0x18]
8000a970:	58 0a       	cp.w	r10,0
8000a972:	e0 89 00 24 	brgt	8000a9ba <_dtoa_r+0xa7e>
8000a976:	c2 f8       	rjmp	8000a9d4 <_dtoa_r+0xa98>
8000a978:	40 69       	lddsp	r9,sp[0x18]
8000a97a:	58 09       	cp.w	r9,0
8000a97c:	c0 85       	brlt	8000a98c <_dtoa_r+0xa50>
8000a97e:	12 98       	mov	r8,r9
8000a980:	40 cc       	lddsp	r12,sp[0x30]
8000a982:	18 48       	or	r8,r12
8000a984:	c1 d1       	brne	8000a9be <_dtoa_r+0xa82>
8000a986:	40 db       	lddsp	r11,sp[0x34]
8000a988:	58 0b       	cp.w	r11,0
8000a98a:	c1 a1       	brne	8000a9be <_dtoa_r+0xa82>
8000a98c:	0c 99       	mov	r9,r6
8000a98e:	40 26       	lddsp	r6,sp[0x8]
8000a990:	58 09       	cp.w	r9,0
8000a992:	e0 8a 00 21 	brle	8000a9d4 <_dtoa_r+0xa98>
8000a996:	06 9b       	mov	r11,r3
8000a998:	30 1a       	mov	r10,1
8000a99a:	0e 9c       	mov	r12,r7
8000a99c:	e0 a0 06 92 	rcall	8000b6c0 <__lshift>
8000a9a0:	04 9b       	mov	r11,r2
8000a9a2:	18 93       	mov	r3,r12
8000a9a4:	e0 a0 05 6b 	rcall	8000b47a <__mcmp>
8000a9a8:	e0 89 00 06 	brgt	8000a9b4 <_dtoa_r+0xa78>
8000a9ac:	c1 41       	brne	8000a9d4 <_dtoa_r+0xa98>
8000a9ae:	ed b0 00 00 	bld	r0,0x0
8000a9b2:	c1 11       	brne	8000a9d4 <_dtoa_r+0xa98>
8000a9b4:	e0 40 00 39 	cp.w	r0,57
8000a9b8:	c0 a0       	breq	8000a9cc <_dtoa_r+0xa90>
8000a9ba:	2f f0       	sub	r0,-1
8000a9bc:	c0 c8       	rjmp	8000a9d4 <_dtoa_r+0xa98>
8000a9be:	58 06       	cp.w	r6,0
8000a9c0:	e0 8a 00 0c 	brle	8000a9d8 <_dtoa_r+0xa9c>
8000a9c4:	40 26       	lddsp	r6,sp[0x8]
8000a9c6:	e0 40 00 39 	cp.w	r0,57
8000a9ca:	c0 41       	brne	8000a9d2 <_dtoa_r+0xa96>
8000a9cc:	33 98       	mov	r8,57
8000a9ce:	0a c8       	st.b	r5++,r8
8000a9d0:	c6 78       	rjmp	8000aa9e <_dtoa_r+0xb62>
8000a9d2:	2f f0       	sub	r0,-1
8000a9d4:	0a c0       	st.b	r5++,r0
8000a9d6:	c7 58       	rjmp	8000aac0 <_dtoa_r+0xb84>
8000a9d8:	0a c0       	st.b	r5++,r0
8000a9da:	40 9a       	lddsp	r10,sp[0x24]
8000a9dc:	40 e9       	lddsp	r9,sp[0x38]
8000a9de:	12 3a       	cp.w	r10,r9
8000a9e0:	c4 30       	breq	8000aa66 <_dtoa_r+0xb2a>
8000a9e2:	06 9b       	mov	r11,r3
8000a9e4:	30 09       	mov	r9,0
8000a9e6:	30 aa       	mov	r10,10
8000a9e8:	0e 9c       	mov	r12,r7
8000a9ea:	e0 a0 07 37 	rcall	8000b858 <__multadd>
8000a9ee:	40 48       	lddsp	r8,sp[0x10]
8000a9f0:	18 93       	mov	r3,r12
8000a9f2:	08 38       	cp.w	r8,r4
8000a9f4:	c0 91       	brne	8000aa06 <_dtoa_r+0xaca>
8000a9f6:	10 9b       	mov	r11,r8
8000a9f8:	30 09       	mov	r9,0
8000a9fa:	30 aa       	mov	r10,10
8000a9fc:	0e 9c       	mov	r12,r7
8000a9fe:	e0 a0 07 2d 	rcall	8000b858 <__multadd>
8000aa02:	50 4c       	stdsp	sp[0x10],r12
8000aa04:	c0 e8       	rjmp	8000aa20 <_dtoa_r+0xae4>
8000aa06:	40 4b       	lddsp	r11,sp[0x10]
8000aa08:	30 09       	mov	r9,0
8000aa0a:	30 aa       	mov	r10,10
8000aa0c:	0e 9c       	mov	r12,r7
8000aa0e:	e0 a0 07 25 	rcall	8000b858 <__multadd>
8000aa12:	08 9b       	mov	r11,r4
8000aa14:	50 4c       	stdsp	sp[0x10],r12
8000aa16:	30 09       	mov	r9,0
8000aa18:	30 aa       	mov	r10,10
8000aa1a:	0e 9c       	mov	r12,r7
8000aa1c:	e0 a0 07 1e 	rcall	8000b858 <__multadd>
8000aa20:	18 94       	mov	r4,r12
8000aa22:	40 9c       	lddsp	r12,sp[0x24]
8000aa24:	2f fc       	sub	r12,-1
8000aa26:	50 9c       	stdsp	sp[0x24],r12
8000aa28:	c7 9b       	rjmp	8000a91a <_dtoa_r+0x9de>
8000aa2a:	30 18       	mov	r8,1
8000aa2c:	06 90       	mov	r0,r3
8000aa2e:	40 85       	lddsp	r5,sp[0x20]
8000aa30:	08 93       	mov	r3,r4
8000aa32:	0c 94       	mov	r4,r6
8000aa34:	10 96       	mov	r6,r8
8000aa36:	04 9b       	mov	r11,r2
8000aa38:	00 9c       	mov	r12,r0
8000aa3a:	fe b0 f9 f1 	rcall	80009e1c <quorem>
8000aa3e:	2d 0c       	sub	r12,-48
8000aa40:	0a cc       	st.b	r5++,r12
8000aa42:	02 36       	cp.w	r6,r1
8000aa44:	c0 a4       	brge	8000aa58 <_dtoa_r+0xb1c>
8000aa46:	00 9b       	mov	r11,r0
8000aa48:	30 09       	mov	r9,0
8000aa4a:	30 aa       	mov	r10,10
8000aa4c:	0e 9c       	mov	r12,r7
8000aa4e:	2f f6       	sub	r6,-1
8000aa50:	e0 a0 07 04 	rcall	8000b858 <__multadd>
8000aa54:	18 90       	mov	r0,r12
8000aa56:	cf 0b       	rjmp	8000aa36 <_dtoa_r+0xafa>
8000aa58:	08 96       	mov	r6,r4
8000aa5a:	30 0b       	mov	r11,0
8000aa5c:	06 94       	mov	r4,r3
8000aa5e:	50 4b       	stdsp	sp[0x10],r11
8000aa60:	00 93       	mov	r3,r0
8000aa62:	18 90       	mov	r0,r12
8000aa64:	c0 28       	rjmp	8000aa68 <_dtoa_r+0xb2c>
8000aa66:	40 26       	lddsp	r6,sp[0x8]
8000aa68:	06 9b       	mov	r11,r3
8000aa6a:	30 1a       	mov	r10,1
8000aa6c:	0e 9c       	mov	r12,r7
8000aa6e:	e0 a0 06 29 	rcall	8000b6c0 <__lshift>
8000aa72:	04 9b       	mov	r11,r2
8000aa74:	18 93       	mov	r3,r12
8000aa76:	e0 a0 05 02 	rcall	8000b47a <__mcmp>
8000aa7a:	e0 89 00 12 	brgt	8000aa9e <_dtoa_r+0xb62>
8000aa7e:	c1 b1       	brne	8000aab4 <_dtoa_r+0xb78>
8000aa80:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000aa84:	c0 d1       	brne	8000aa9e <_dtoa_r+0xb62>
8000aa86:	c1 78       	rjmp	8000aab4 <_dtoa_r+0xb78>
8000aa88:	40 89       	lddsp	r9,sp[0x20]
8000aa8a:	12 38       	cp.w	r8,r9
8000aa8c:	c0 30       	breq	8000aa92 <_dtoa_r+0xb56>
8000aa8e:	10 95       	mov	r5,r8
8000aa90:	c0 88       	rjmp	8000aaa0 <_dtoa_r+0xb64>
8000aa92:	2f f6       	sub	r6,-1
8000aa94:	50 66       	stdsp	sp[0x18],r6
8000aa96:	33 18       	mov	r8,49
8000aa98:	40 8c       	lddsp	r12,sp[0x20]
8000aa9a:	b8 88       	st.b	r12[0x0],r8
8000aa9c:	c1 38       	rjmp	8000aac2 <_dtoa_r+0xb86>
8000aa9e:	33 9a       	mov	r10,57
8000aaa0:	0a 98       	mov	r8,r5
8000aaa2:	11 79       	ld.ub	r9,--r8
8000aaa4:	f4 09 18 00 	cp.b	r9,r10
8000aaa8:	cf 00       	breq	8000aa88 <_dtoa_r+0xb4c>
8000aaaa:	2f f9       	sub	r9,-1
8000aaac:	b0 89       	st.b	r8[0x0],r9
8000aaae:	c0 98       	rjmp	8000aac0 <_dtoa_r+0xb84>
8000aab0:	10 95       	mov	r5,r8
8000aab2:	c0 28       	rjmp	8000aab6 <_dtoa_r+0xb7a>
8000aab4:	33 09       	mov	r9,48
8000aab6:	0a 98       	mov	r8,r5
8000aab8:	11 7a       	ld.ub	r10,--r8
8000aaba:	f2 0a 18 00 	cp.b	r10,r9
8000aabe:	cf 90       	breq	8000aab0 <_dtoa_r+0xb74>
8000aac0:	50 66       	stdsp	sp[0x18],r6
8000aac2:	04 9b       	mov	r11,r2
8000aac4:	0e 9c       	mov	r12,r7
8000aac6:	e0 a0 04 f3 	rcall	8000b4ac <_Bfree>
8000aaca:	58 04       	cp.w	r4,0
8000aacc:	c1 20       	breq	8000aaf0 <_dtoa_r+0xbb4>
8000aace:	40 4b       	lddsp	r11,sp[0x10]
8000aad0:	08 3b       	cp.w	r11,r4
8000aad2:	5f 19       	srne	r9
8000aad4:	58 0b       	cp.w	r11,0
8000aad6:	5f 18       	srne	r8
8000aad8:	f3 e8 00 08 	and	r8,r9,r8
8000aadc:	c0 40       	breq	8000aae4 <_dtoa_r+0xba8>
8000aade:	0e 9c       	mov	r12,r7
8000aae0:	e0 a0 04 e6 	rcall	8000b4ac <_Bfree>
8000aae4:	08 9b       	mov	r11,r4
8000aae6:	0e 9c       	mov	r12,r7
8000aae8:	e0 a0 04 e2 	rcall	8000b4ac <_Bfree>
8000aaec:	c0 28       	rjmp	8000aaf0 <_dtoa_r+0xbb4>
8000aaee:	50 66       	stdsp	sp[0x18],r6
8000aaf0:	0e 9c       	mov	r12,r7
8000aaf2:	06 9b       	mov	r11,r3
8000aaf4:	e0 a0 04 dc 	rcall	8000b4ac <_Bfree>
8000aaf8:	30 08       	mov	r8,0
8000aafa:	aa 88       	st.b	r5[0x0],r8
8000aafc:	40 68       	lddsp	r8,sp[0x18]
8000aafe:	41 5a       	lddsp	r10,sp[0x54]
8000ab00:	2f f8       	sub	r8,-1
8000ab02:	41 29       	lddsp	r9,sp[0x48]
8000ab04:	95 08       	st.w	r10[0x0],r8
8000ab06:	40 8c       	lddsp	r12,sp[0x20]
8000ab08:	58 09       	cp.w	r9,0
8000ab0a:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000ab0e:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000ab12:	2e 6d       	sub	sp,-104
8000ab14:	d8 32       	popm	r0-r7,pc
8000ab16:	d7 03       	nop

8000ab18 <__errno>:
8000ab18:	e0 68 0a 3c 	mov	r8,2620
8000ab1c:	70 0c       	ld.w	r12,r8[0x0]
8000ab1e:	2f 4c       	sub	r12,-12
8000ab20:	5e fc       	retal	r12
8000ab22:	d7 03       	nop

8000ab24 <_fflush_r>:
8000ab24:	d4 21       	pushm	r4-r7,lr
8000ab26:	16 97       	mov	r7,r11
8000ab28:	18 96       	mov	r6,r12
8000ab2a:	76 48       	ld.w	r8,r11[0x10]
8000ab2c:	58 08       	cp.w	r8,0
8000ab2e:	c7 f0       	breq	8000ac2c <_fflush_r+0x108>
8000ab30:	58 0c       	cp.w	r12,0
8000ab32:	c0 50       	breq	8000ab3c <_fflush_r+0x18>
8000ab34:	78 68       	ld.w	r8,r12[0x18]
8000ab36:	58 08       	cp.w	r8,0
8000ab38:	c0 21       	brne	8000ab3c <_fflush_r+0x18>
8000ab3a:	cc dc       	rcall	8000acd4 <__sinit>
8000ab3c:	fe c8 cd 3c 	sub	r8,pc,-12996
8000ab40:	10 37       	cp.w	r7,r8
8000ab42:	c0 31       	brne	8000ab48 <_fflush_r+0x24>
8000ab44:	6c 07       	ld.w	r7,r6[0x0]
8000ab46:	c0 c8       	rjmp	8000ab5e <_fflush_r+0x3a>
8000ab48:	fe c8 cd 28 	sub	r8,pc,-13016
8000ab4c:	10 37       	cp.w	r7,r8
8000ab4e:	c0 31       	brne	8000ab54 <_fflush_r+0x30>
8000ab50:	6c 17       	ld.w	r7,r6[0x4]
8000ab52:	c0 68       	rjmp	8000ab5e <_fflush_r+0x3a>
8000ab54:	fe c8 cd 14 	sub	r8,pc,-13036
8000ab58:	10 37       	cp.w	r7,r8
8000ab5a:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000ab5e:	8e 6a       	ld.sh	r10,r7[0xc]
8000ab60:	14 98       	mov	r8,r10
8000ab62:	ed ba 00 03 	bld	r10,0x3
8000ab66:	c4 20       	breq	8000abea <_fflush_r+0xc6>
8000ab68:	ab ba       	sbr	r10,0xb
8000ab6a:	ae 6a       	st.h	r7[0xc],r10
8000ab6c:	6e 18       	ld.w	r8,r7[0x4]
8000ab6e:	58 08       	cp.w	r8,0
8000ab70:	e0 89 00 06 	brgt	8000ab7c <_fflush_r+0x58>
8000ab74:	6f 08       	ld.w	r8,r7[0x40]
8000ab76:	58 08       	cp.w	r8,0
8000ab78:	e0 8a 00 5a 	brle	8000ac2c <_fflush_r+0x108>
8000ab7c:	6e b8       	ld.w	r8,r7[0x2c]
8000ab7e:	58 08       	cp.w	r8,0
8000ab80:	c5 60       	breq	8000ac2c <_fflush_r+0x108>
8000ab82:	e2 1a 10 00 	andl	r10,0x1000,COH
8000ab86:	c0 30       	breq	8000ab8c <_fflush_r+0x68>
8000ab88:	6f 55       	ld.w	r5,r7[0x54]
8000ab8a:	c0 f8       	rjmp	8000aba8 <_fflush_r+0x84>
8000ab8c:	30 19       	mov	r9,1
8000ab8e:	6e 8b       	ld.w	r11,r7[0x20]
8000ab90:	0c 9c       	mov	r12,r6
8000ab92:	5d 18       	icall	r8
8000ab94:	18 95       	mov	r5,r12
8000ab96:	5b fc       	cp.w	r12,-1
8000ab98:	c0 81       	brne	8000aba8 <_fflush_r+0x84>
8000ab9a:	6c 38       	ld.w	r8,r6[0xc]
8000ab9c:	59 d8       	cp.w	r8,29
8000ab9e:	c4 70       	breq	8000ac2c <_fflush_r+0x108>
8000aba0:	8e 68       	ld.sh	r8,r7[0xc]
8000aba2:	a7 a8       	sbr	r8,0x6
8000aba4:	ae 68       	st.h	r7[0xc],r8
8000aba6:	d8 22       	popm	r4-r7,pc
8000aba8:	8e 68       	ld.sh	r8,r7[0xc]
8000abaa:	ed b8 00 02 	bld	r8,0x2
8000abae:	c0 91       	brne	8000abc0 <_fflush_r+0x9c>
8000abb0:	6e 18       	ld.w	r8,r7[0x4]
8000abb2:	10 15       	sub	r5,r8
8000abb4:	6e d8       	ld.w	r8,r7[0x34]
8000abb6:	58 08       	cp.w	r8,0
8000abb8:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000abbc:	eb d8 e1 15 	subne	r5,r5,r8
8000abc0:	6e b8       	ld.w	r8,r7[0x2c]
8000abc2:	0c 9c       	mov	r12,r6
8000abc4:	30 09       	mov	r9,0
8000abc6:	0a 9a       	mov	r10,r5
8000abc8:	6e 8b       	ld.w	r11,r7[0x20]
8000abca:	5d 18       	icall	r8
8000abcc:	8e 68       	ld.sh	r8,r7[0xc]
8000abce:	0a 3c       	cp.w	r12,r5
8000abd0:	c2 61       	brne	8000ac1c <_fflush_r+0xf8>
8000abd2:	ab d8       	cbr	r8,0xb
8000abd4:	30 0c       	mov	r12,0
8000abd6:	6e 49       	ld.w	r9,r7[0x10]
8000abd8:	ae 68       	st.h	r7[0xc],r8
8000abda:	8f 1c       	st.w	r7[0x4],r12
8000abdc:	8f 09       	st.w	r7[0x0],r9
8000abde:	ed b8 00 0c 	bld	r8,0xc
8000abe2:	c2 51       	brne	8000ac2c <_fflush_r+0x108>
8000abe4:	ef 45 00 54 	st.w	r7[84],r5
8000abe8:	d8 22       	popm	r4-r7,pc
8000abea:	6e 45       	ld.w	r5,r7[0x10]
8000abec:	58 05       	cp.w	r5,0
8000abee:	c1 f0       	breq	8000ac2c <_fflush_r+0x108>
8000abf0:	6e 04       	ld.w	r4,r7[0x0]
8000abf2:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000abf6:	8f 05       	st.w	r7[0x0],r5
8000abf8:	f9 b8 01 00 	movne	r8,0
8000abfc:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000ac00:	0a 14       	sub	r4,r5
8000ac02:	8f 28       	st.w	r7[0x8],r8
8000ac04:	c1 18       	rjmp	8000ac26 <_fflush_r+0x102>
8000ac06:	08 99       	mov	r9,r4
8000ac08:	0a 9a       	mov	r10,r5
8000ac0a:	6e a8       	ld.w	r8,r7[0x28]
8000ac0c:	6e 8b       	ld.w	r11,r7[0x20]
8000ac0e:	0c 9c       	mov	r12,r6
8000ac10:	5d 18       	icall	r8
8000ac12:	18 14       	sub	r4,r12
8000ac14:	58 0c       	cp.w	r12,0
8000ac16:	e0 89 00 07 	brgt	8000ac24 <_fflush_r+0x100>
8000ac1a:	8e 68       	ld.sh	r8,r7[0xc]
8000ac1c:	a7 a8       	sbr	r8,0x6
8000ac1e:	3f fc       	mov	r12,-1
8000ac20:	ae 68       	st.h	r7[0xc],r8
8000ac22:	d8 22       	popm	r4-r7,pc
8000ac24:	18 05       	add	r5,r12
8000ac26:	58 04       	cp.w	r4,0
8000ac28:	fe 99 ff ef 	brgt	8000ac06 <_fflush_r+0xe2>
8000ac2c:	d8 2a       	popm	r4-r7,pc,r12=0
8000ac2e:	d7 03       	nop

8000ac30 <__sfp_lock_acquire>:
8000ac30:	5e fc       	retal	r12

8000ac32 <__sfp_lock_release>:
8000ac32:	5e fc       	retal	r12

8000ac34 <_cleanup_r>:
8000ac34:	d4 01       	pushm	lr
8000ac36:	fe cb f0 ae 	sub	r11,pc,-3922
8000ac3a:	e0 a0 02 f7 	rcall	8000b228 <_fwalk>
8000ac3e:	d8 02       	popm	pc

8000ac40 <__sfmoreglue>:
8000ac40:	d4 21       	pushm	r4-r7,lr
8000ac42:	16 95       	mov	r5,r11
8000ac44:	f6 06 10 5c 	mul	r6,r11,92
8000ac48:	ec cb ff f4 	sub	r11,r6,-12
8000ac4c:	fe b0 e2 88 	rcall	8000715c <_malloc_r>
8000ac50:	18 97       	mov	r7,r12
8000ac52:	c0 90       	breq	8000ac64 <__sfmoreglue+0x24>
8000ac54:	99 15       	st.w	r12[0x4],r5
8000ac56:	30 0b       	mov	r11,0
8000ac58:	2f 4c       	sub	r12,-12
8000ac5a:	0c 9a       	mov	r10,r6
8000ac5c:	8f 2c       	st.w	r7[0x8],r12
8000ac5e:	8f 0b       	st.w	r7[0x0],r11
8000ac60:	fe b0 e5 3e 	rcall	800076dc <memset>
8000ac64:	0e 9c       	mov	r12,r7
8000ac66:	d8 22       	popm	r4-r7,pc

8000ac68 <__sfp>:
8000ac68:	d4 21       	pushm	r4-r7,lr
8000ac6a:	fe c8 ce 06 	sub	r8,pc,-12794
8000ac6e:	18 96       	mov	r6,r12
8000ac70:	70 07       	ld.w	r7,r8[0x0]
8000ac72:	6e 68       	ld.w	r8,r7[0x18]
8000ac74:	58 08       	cp.w	r8,0
8000ac76:	c0 31       	brne	8000ac7c <__sfp+0x14>
8000ac78:	0e 9c       	mov	r12,r7
8000ac7a:	c2 dc       	rcall	8000acd4 <__sinit>
8000ac7c:	ee c7 ff 28 	sub	r7,r7,-216
8000ac80:	30 05       	mov	r5,0
8000ac82:	6e 2c       	ld.w	r12,r7[0x8]
8000ac84:	6e 18       	ld.w	r8,r7[0x4]
8000ac86:	c0 68       	rjmp	8000ac92 <__sfp+0x2a>
8000ac88:	98 69       	ld.sh	r9,r12[0xc]
8000ac8a:	ea 09 19 00 	cp.h	r9,r5
8000ac8e:	c1 10       	breq	8000acb0 <__sfp+0x48>
8000ac90:	2a 4c       	sub	r12,-92
8000ac92:	20 18       	sub	r8,1
8000ac94:	cf a7       	brpl	8000ac88 <__sfp+0x20>
8000ac96:	6e 08       	ld.w	r8,r7[0x0]
8000ac98:	58 08       	cp.w	r8,0
8000ac9a:	c0 61       	brne	8000aca6 <__sfp+0x3e>
8000ac9c:	30 4b       	mov	r11,4
8000ac9e:	0c 9c       	mov	r12,r6
8000aca0:	cd 0f       	rcall	8000ac40 <__sfmoreglue>
8000aca2:	8f 0c       	st.w	r7[0x0],r12
8000aca4:	c0 30       	breq	8000acaa <__sfp+0x42>
8000aca6:	6e 07       	ld.w	r7,r7[0x0]
8000aca8:	ce db       	rjmp	8000ac82 <__sfp+0x1a>
8000acaa:	30 c8       	mov	r8,12
8000acac:	8d 38       	st.w	r6[0xc],r8
8000acae:	d8 22       	popm	r4-r7,pc
8000acb0:	30 08       	mov	r8,0
8000acb2:	f9 48 00 4c 	st.w	r12[76],r8
8000acb6:	99 08       	st.w	r12[0x0],r8
8000acb8:	99 28       	st.w	r12[0x8],r8
8000acba:	99 18       	st.w	r12[0x4],r8
8000acbc:	99 48       	st.w	r12[0x10],r8
8000acbe:	99 58       	st.w	r12[0x14],r8
8000acc0:	99 68       	st.w	r12[0x18],r8
8000acc2:	99 d8       	st.w	r12[0x34],r8
8000acc4:	99 e8       	st.w	r12[0x38],r8
8000acc6:	f9 48 00 48 	st.w	r12[72],r8
8000acca:	3f f8       	mov	r8,-1
8000accc:	b8 78       	st.h	r12[0xe],r8
8000acce:	30 18       	mov	r8,1
8000acd0:	b8 68       	st.h	r12[0xc],r8
8000acd2:	d8 22       	popm	r4-r7,pc

8000acd4 <__sinit>:
8000acd4:	d4 21       	pushm	r4-r7,lr
8000acd6:	18 96       	mov	r6,r12
8000acd8:	78 67       	ld.w	r7,r12[0x18]
8000acda:	58 07       	cp.w	r7,0
8000acdc:	c4 91       	brne	8000ad6e <__sinit+0x9a>
8000acde:	fe c8 00 aa 	sub	r8,pc,170
8000ace2:	30 15       	mov	r5,1
8000ace4:	99 a8       	st.w	r12[0x28],r8
8000ace6:	f9 47 00 d8 	st.w	r12[216],r7
8000acea:	f9 47 00 dc 	st.w	r12[220],r7
8000acee:	f9 47 00 e0 	st.w	r12[224],r7
8000acf2:	99 65       	st.w	r12[0x18],r5
8000acf4:	cb af       	rcall	8000ac68 <__sfp>
8000acf6:	8d 0c       	st.w	r6[0x0],r12
8000acf8:	0c 9c       	mov	r12,r6
8000acfa:	cb 7f       	rcall	8000ac68 <__sfp>
8000acfc:	8d 1c       	st.w	r6[0x4],r12
8000acfe:	0c 9c       	mov	r12,r6
8000ad00:	cb 4f       	rcall	8000ac68 <__sfp>
8000ad02:	6c 09       	ld.w	r9,r6[0x0]
8000ad04:	30 48       	mov	r8,4
8000ad06:	93 07       	st.w	r9[0x0],r7
8000ad08:	b2 68       	st.h	r9[0xc],r8
8000ad0a:	93 17       	st.w	r9[0x4],r7
8000ad0c:	93 27       	st.w	r9[0x8],r7
8000ad0e:	6c 18       	ld.w	r8,r6[0x4]
8000ad10:	b2 77       	st.h	r9[0xe],r7
8000ad12:	93 47       	st.w	r9[0x10],r7
8000ad14:	93 57       	st.w	r9[0x14],r7
8000ad16:	93 67       	st.w	r9[0x18],r7
8000ad18:	93 89       	st.w	r9[0x20],r9
8000ad1a:	91 07       	st.w	r8[0x0],r7
8000ad1c:	91 17       	st.w	r8[0x4],r7
8000ad1e:	91 27       	st.w	r8[0x8],r7
8000ad20:	fe ce f3 24 	sub	lr,pc,-3292
8000ad24:	fe cb f3 54 	sub	r11,pc,-3244
8000ad28:	93 9e       	st.w	r9[0x24],lr
8000ad2a:	93 ab       	st.w	r9[0x28],r11
8000ad2c:	fe ca f3 7c 	sub	r10,pc,-3204
8000ad30:	fe c4 f3 88 	sub	r4,pc,-3192
8000ad34:	93 ba       	st.w	r9[0x2c],r10
8000ad36:	93 c4       	st.w	r9[0x30],r4
8000ad38:	30 99       	mov	r9,9
8000ad3a:	b0 69       	st.h	r8[0xc],r9
8000ad3c:	b0 75       	st.h	r8[0xe],r5
8000ad3e:	91 c4       	st.w	r8[0x30],r4
8000ad40:	91 47       	st.w	r8[0x10],r7
8000ad42:	91 57       	st.w	r8[0x14],r7
8000ad44:	91 67       	st.w	r8[0x18],r7
8000ad46:	91 88       	st.w	r8[0x20],r8
8000ad48:	91 9e       	st.w	r8[0x24],lr
8000ad4a:	91 ab       	st.w	r8[0x28],r11
8000ad4c:	91 ba       	st.w	r8[0x2c],r10
8000ad4e:	8d 2c       	st.w	r6[0x8],r12
8000ad50:	31 28       	mov	r8,18
8000ad52:	99 07       	st.w	r12[0x0],r7
8000ad54:	b8 68       	st.h	r12[0xc],r8
8000ad56:	99 17       	st.w	r12[0x4],r7
8000ad58:	99 27       	st.w	r12[0x8],r7
8000ad5a:	30 28       	mov	r8,2
8000ad5c:	b8 78       	st.h	r12[0xe],r8
8000ad5e:	99 c4       	st.w	r12[0x30],r4
8000ad60:	99 67       	st.w	r12[0x18],r7
8000ad62:	99 9e       	st.w	r12[0x24],lr
8000ad64:	99 ab       	st.w	r12[0x28],r11
8000ad66:	99 ba       	st.w	r12[0x2c],r10
8000ad68:	99 47       	st.w	r12[0x10],r7
8000ad6a:	99 57       	st.w	r12[0x14],r7
8000ad6c:	99 8c       	st.w	r12[0x20],r12
8000ad6e:	d8 22       	popm	r4-r7,pc

8000ad70 <_malloc_trim_r>:
8000ad70:	d4 21       	pushm	r4-r7,lr
8000ad72:	16 95       	mov	r5,r11
8000ad74:	18 97       	mov	r7,r12
8000ad76:	fe b0 d7 d7 	rcall	80005d24 <__malloc_lock>
8000ad7a:	e0 64 05 3c 	mov	r4,1340
8000ad7e:	68 28       	ld.w	r8,r4[0x8]
8000ad80:	70 16       	ld.w	r6,r8[0x4]
8000ad82:	e0 16 ff fc 	andl	r6,0xfffc
8000ad86:	ec c8 ff 91 	sub	r8,r6,-111
8000ad8a:	f0 05 01 05 	sub	r5,r8,r5
8000ad8e:	e0 15 ff 80 	andl	r5,0xff80
8000ad92:	ea c5 00 80 	sub	r5,r5,128
8000ad96:	e0 45 00 7f 	cp.w	r5,127
8000ad9a:	e0 8a 00 25 	brle	8000ade4 <_malloc_trim_r+0x74>
8000ad9e:	30 0b       	mov	r11,0
8000ada0:	0e 9c       	mov	r12,r7
8000ada2:	fe b0 e6 05 	rcall	800079ac <_sbrk_r>
8000ada6:	68 28       	ld.w	r8,r4[0x8]
8000ada8:	0c 08       	add	r8,r6
8000adaa:	10 3c       	cp.w	r12,r8
8000adac:	c1 c1       	brne	8000ade4 <_malloc_trim_r+0x74>
8000adae:	ea 0b 11 00 	rsub	r11,r5,0
8000adb2:	0e 9c       	mov	r12,r7
8000adb4:	fe b0 e5 fc 	rcall	800079ac <_sbrk_r>
8000adb8:	5b fc       	cp.w	r12,-1
8000adba:	c1 91       	brne	8000adec <_malloc_trim_r+0x7c>
8000adbc:	30 0b       	mov	r11,0
8000adbe:	0e 9c       	mov	r12,r7
8000adc0:	fe b0 e5 f6 	rcall	800079ac <_sbrk_r>
8000adc4:	68 28       	ld.w	r8,r4[0x8]
8000adc6:	f8 08 01 09 	sub	r9,r12,r8
8000adca:	58 f9       	cp.w	r9,15
8000adcc:	e0 8a 00 0c 	brle	8000ade4 <_malloc_trim_r+0x74>
8000add0:	a1 a9       	sbr	r9,0x0
8000add2:	91 19       	st.w	r8[0x4],r9
8000add4:	e0 68 09 48 	mov	r8,2376
8000add8:	70 09       	ld.w	r9,r8[0x0]
8000adda:	e0 68 0d 50 	mov	r8,3408
8000adde:	f8 09 01 09 	sub	r9,r12,r9
8000ade2:	91 09       	st.w	r8[0x0],r9
8000ade4:	0e 9c       	mov	r12,r7
8000ade6:	fe b0 d7 a5 	rcall	80005d30 <__malloc_unlock>
8000adea:	d8 2a       	popm	r4-r7,pc,r12=0
8000adec:	68 28       	ld.w	r8,r4[0x8]
8000adee:	0a 16       	sub	r6,r5
8000adf0:	a1 a6       	sbr	r6,0x0
8000adf2:	91 16       	st.w	r8[0x4],r6
8000adf4:	e0 68 0d 50 	mov	r8,3408
8000adf8:	70 09       	ld.w	r9,r8[0x0]
8000adfa:	0a 19       	sub	r9,r5
8000adfc:	0e 9c       	mov	r12,r7
8000adfe:	91 09       	st.w	r8[0x0],r9
8000ae00:	fe b0 d7 98 	rcall	80005d30 <__malloc_unlock>
8000ae04:	da 2a       	popm	r4-r7,pc,r12=1
8000ae06:	d7 03       	nop

8000ae08 <_free_r>:
8000ae08:	d4 21       	pushm	r4-r7,lr
8000ae0a:	16 96       	mov	r6,r11
8000ae0c:	18 97       	mov	r7,r12
8000ae0e:	58 0b       	cp.w	r11,0
8000ae10:	e0 80 00 c0 	breq	8000af90 <_free_r+0x188>
8000ae14:	fe b0 d7 88 	rcall	80005d24 <__malloc_lock>
8000ae18:	20 86       	sub	r6,8
8000ae1a:	e0 6a 05 3c 	mov	r10,1340
8000ae1e:	6c 18       	ld.w	r8,r6[0x4]
8000ae20:	74 2e       	ld.w	lr,r10[0x8]
8000ae22:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000ae26:	a1 c8       	cbr	r8,0x0
8000ae28:	ec 08 00 09 	add	r9,r6,r8
8000ae2c:	72 1b       	ld.w	r11,r9[0x4]
8000ae2e:	e0 1b ff fc 	andl	r11,0xfffc
8000ae32:	1c 39       	cp.w	r9,lr
8000ae34:	c1 e1       	brne	8000ae70 <_free_r+0x68>
8000ae36:	f6 08 00 08 	add	r8,r11,r8
8000ae3a:	58 0c       	cp.w	r12,0
8000ae3c:	c0 81       	brne	8000ae4c <_free_r+0x44>
8000ae3e:	6c 09       	ld.w	r9,r6[0x0]
8000ae40:	12 16       	sub	r6,r9
8000ae42:	12 08       	add	r8,r9
8000ae44:	6c 3b       	ld.w	r11,r6[0xc]
8000ae46:	6c 29       	ld.w	r9,r6[0x8]
8000ae48:	97 29       	st.w	r11[0x8],r9
8000ae4a:	93 3b       	st.w	r9[0xc],r11
8000ae4c:	10 99       	mov	r9,r8
8000ae4e:	95 26       	st.w	r10[0x8],r6
8000ae50:	a1 a9       	sbr	r9,0x0
8000ae52:	8d 19       	st.w	r6[0x4],r9
8000ae54:	e0 69 09 44 	mov	r9,2372
8000ae58:	72 09       	ld.w	r9,r9[0x0]
8000ae5a:	12 38       	cp.w	r8,r9
8000ae5c:	c0 63       	brcs	8000ae68 <_free_r+0x60>
8000ae5e:	e0 68 0d 4c 	mov	r8,3404
8000ae62:	0e 9c       	mov	r12,r7
8000ae64:	70 0b       	ld.w	r11,r8[0x0]
8000ae66:	c8 5f       	rcall	8000ad70 <_malloc_trim_r>
8000ae68:	0e 9c       	mov	r12,r7
8000ae6a:	fe b0 d7 63 	rcall	80005d30 <__malloc_unlock>
8000ae6e:	d8 22       	popm	r4-r7,pc
8000ae70:	93 1b       	st.w	r9[0x4],r11
8000ae72:	58 0c       	cp.w	r12,0
8000ae74:	c0 30       	breq	8000ae7a <_free_r+0x72>
8000ae76:	30 0c       	mov	r12,0
8000ae78:	c1 08       	rjmp	8000ae98 <_free_r+0x90>
8000ae7a:	6c 0e       	ld.w	lr,r6[0x0]
8000ae7c:	f4 c5 ff f8 	sub	r5,r10,-8
8000ae80:	1c 16       	sub	r6,lr
8000ae82:	1c 08       	add	r8,lr
8000ae84:	6c 2e       	ld.w	lr,r6[0x8]
8000ae86:	0a 3e       	cp.w	lr,r5
8000ae88:	f9 bc 00 01 	moveq	r12,1
8000ae8c:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000ae90:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000ae94:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000ae98:	f2 0b 00 0e 	add	lr,r9,r11
8000ae9c:	7c 1e       	ld.w	lr,lr[0x4]
8000ae9e:	ed be 00 00 	bld	lr,0x0
8000aea2:	c1 40       	breq	8000aeca <_free_r+0xc2>
8000aea4:	16 08       	add	r8,r11
8000aea6:	58 0c       	cp.w	r12,0
8000aea8:	c0 d1       	brne	8000aec2 <_free_r+0xba>
8000aeaa:	e0 6e 05 3c 	mov	lr,1340
8000aeae:	72 2b       	ld.w	r11,r9[0x8]
8000aeb0:	2f 8e       	sub	lr,-8
8000aeb2:	1c 3b       	cp.w	r11,lr
8000aeb4:	c0 71       	brne	8000aec2 <_free_r+0xba>
8000aeb6:	97 36       	st.w	r11[0xc],r6
8000aeb8:	97 26       	st.w	r11[0x8],r6
8000aeba:	8d 2b       	st.w	r6[0x8],r11
8000aebc:	8d 3b       	st.w	r6[0xc],r11
8000aebe:	30 1c       	mov	r12,1
8000aec0:	c0 58       	rjmp	8000aeca <_free_r+0xc2>
8000aec2:	72 2b       	ld.w	r11,r9[0x8]
8000aec4:	72 39       	ld.w	r9,r9[0xc]
8000aec6:	93 2b       	st.w	r9[0x8],r11
8000aec8:	97 39       	st.w	r11[0xc],r9
8000aeca:	10 99       	mov	r9,r8
8000aecc:	ec 08 09 08 	st.w	r6[r8],r8
8000aed0:	a1 a9       	sbr	r9,0x0
8000aed2:	8d 19       	st.w	r6[0x4],r9
8000aed4:	58 0c       	cp.w	r12,0
8000aed6:	c5 a1       	brne	8000af8a <_free_r+0x182>
8000aed8:	e0 48 01 ff 	cp.w	r8,511
8000aedc:	e0 8b 00 13 	brhi	8000af02 <_free_r+0xfa>
8000aee0:	a3 98       	lsr	r8,0x3
8000aee2:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000aee6:	72 2b       	ld.w	r11,r9[0x8]
8000aee8:	8d 39       	st.w	r6[0xc],r9
8000aeea:	8d 2b       	st.w	r6[0x8],r11
8000aeec:	97 36       	st.w	r11[0xc],r6
8000aeee:	93 26       	st.w	r9[0x8],r6
8000aef0:	a3 48       	asr	r8,0x2
8000aef2:	74 19       	ld.w	r9,r10[0x4]
8000aef4:	30 1b       	mov	r11,1
8000aef6:	f6 08 09 48 	lsl	r8,r11,r8
8000aefa:	f3 e8 10 08 	or	r8,r9,r8
8000aefe:	95 18       	st.w	r10[0x4],r8
8000af00:	c4 58       	rjmp	8000af8a <_free_r+0x182>
8000af02:	f0 0b 16 09 	lsr	r11,r8,0x9
8000af06:	58 4b       	cp.w	r11,4
8000af08:	e0 8b 00 06 	brhi	8000af14 <_free_r+0x10c>
8000af0c:	f0 0b 16 06 	lsr	r11,r8,0x6
8000af10:	2c 8b       	sub	r11,-56
8000af12:	c2 08       	rjmp	8000af52 <_free_r+0x14a>
8000af14:	59 4b       	cp.w	r11,20
8000af16:	e0 8b 00 04 	brhi	8000af1e <_free_r+0x116>
8000af1a:	2a 5b       	sub	r11,-91
8000af1c:	c1 b8       	rjmp	8000af52 <_free_r+0x14a>
8000af1e:	e0 4b 00 54 	cp.w	r11,84
8000af22:	e0 8b 00 06 	brhi	8000af2e <_free_r+0x126>
8000af26:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000af2a:	29 2b       	sub	r11,-110
8000af2c:	c1 38       	rjmp	8000af52 <_free_r+0x14a>
8000af2e:	e0 4b 01 54 	cp.w	r11,340
8000af32:	e0 8b 00 06 	brhi	8000af3e <_free_r+0x136>
8000af36:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000af3a:	28 9b       	sub	r11,-119
8000af3c:	c0 b8       	rjmp	8000af52 <_free_r+0x14a>
8000af3e:	e0 4b 05 54 	cp.w	r11,1364
8000af42:	e0 88 00 05 	brls	8000af4c <_free_r+0x144>
8000af46:	37 eb       	mov	r11,126
8000af48:	c0 58       	rjmp	8000af52 <_free_r+0x14a>
8000af4a:	d7 03       	nop
8000af4c:	f0 0b 16 12 	lsr	r11,r8,0x12
8000af50:	28 4b       	sub	r11,-124
8000af52:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000af56:	78 29       	ld.w	r9,r12[0x8]
8000af58:	18 39       	cp.w	r9,r12
8000af5a:	c0 e1       	brne	8000af76 <_free_r+0x16e>
8000af5c:	74 18       	ld.w	r8,r10[0x4]
8000af5e:	a3 4b       	asr	r11,0x2
8000af60:	30 1c       	mov	r12,1
8000af62:	f8 0b 09 4b 	lsl	r11,r12,r11
8000af66:	f1 eb 10 0b 	or	r11,r8,r11
8000af6a:	12 98       	mov	r8,r9
8000af6c:	95 1b       	st.w	r10[0x4],r11
8000af6e:	c0 a8       	rjmp	8000af82 <_free_r+0x17a>
8000af70:	72 29       	ld.w	r9,r9[0x8]
8000af72:	18 39       	cp.w	r9,r12
8000af74:	c0 60       	breq	8000af80 <_free_r+0x178>
8000af76:	72 1a       	ld.w	r10,r9[0x4]
8000af78:	e0 1a ff fc 	andl	r10,0xfffc
8000af7c:	14 38       	cp.w	r8,r10
8000af7e:	cf 93       	brcs	8000af70 <_free_r+0x168>
8000af80:	72 38       	ld.w	r8,r9[0xc]
8000af82:	8d 38       	st.w	r6[0xc],r8
8000af84:	8d 29       	st.w	r6[0x8],r9
8000af86:	93 36       	st.w	r9[0xc],r6
8000af88:	91 26       	st.w	r8[0x8],r6
8000af8a:	0e 9c       	mov	r12,r7
8000af8c:	fe b0 d6 d2 	rcall	80005d30 <__malloc_unlock>
8000af90:	d8 22       	popm	r4-r7,pc
8000af92:	d7 03       	nop

8000af94 <__sfvwrite_r>:
8000af94:	d4 31       	pushm	r0-r7,lr
8000af96:	20 3d       	sub	sp,12
8000af98:	14 94       	mov	r4,r10
8000af9a:	18 95       	mov	r5,r12
8000af9c:	16 97       	mov	r7,r11
8000af9e:	74 28       	ld.w	r8,r10[0x8]
8000afa0:	58 08       	cp.w	r8,0
8000afa2:	e0 80 01 40 	breq	8000b222 <__sfvwrite_r+0x28e>
8000afa6:	96 68       	ld.sh	r8,r11[0xc]
8000afa8:	ed b8 00 03 	bld	r8,0x3
8000afac:	c0 41       	brne	8000afb4 <__sfvwrite_r+0x20>
8000afae:	76 48       	ld.w	r8,r11[0x10]
8000afb0:	58 08       	cp.w	r8,0
8000afb2:	c0 c1       	brne	8000afca <__sfvwrite_r+0x36>
8000afb4:	0e 9b       	mov	r11,r7
8000afb6:	0a 9c       	mov	r12,r5
8000afb8:	fe b0 f6 c4 	rcall	80009d40 <__swsetup_r>
8000afbc:	c0 70       	breq	8000afca <__sfvwrite_r+0x36>
8000afbe:	8e 68       	ld.sh	r8,r7[0xc]
8000afc0:	a7 a8       	sbr	r8,0x6
8000afc2:	ae 68       	st.h	r7[0xc],r8
8000afc4:	30 98       	mov	r8,9
8000afc6:	8b 38       	st.w	r5[0xc],r8
8000afc8:	c2 b9       	rjmp	8000b21e <__sfvwrite_r+0x28a>
8000afca:	8e 63       	ld.sh	r3,r7[0xc]
8000afcc:	68 00       	ld.w	r0,r4[0x0]
8000afce:	06 96       	mov	r6,r3
8000afd0:	e2 16 00 02 	andl	r6,0x2,COH
8000afd4:	c2 10       	breq	8000b016 <__sfvwrite_r+0x82>
8000afd6:	30 03       	mov	r3,0
8000afd8:	e0 62 04 00 	mov	r2,1024
8000afdc:	06 96       	mov	r6,r3
8000afde:	c0 48       	rjmp	8000afe6 <__sfvwrite_r+0x52>
8000afe0:	60 03       	ld.w	r3,r0[0x0]
8000afe2:	60 16       	ld.w	r6,r0[0x4]
8000afe4:	2f 80       	sub	r0,-8
8000afe6:	58 06       	cp.w	r6,0
8000afe8:	cf c0       	breq	8000afe0 <__sfvwrite_r+0x4c>
8000afea:	e0 46 04 00 	cp.w	r6,1024
8000afee:	ec 09 17 80 	movls	r9,r6
8000aff2:	e4 09 17 b0 	movhi	r9,r2
8000aff6:	06 9a       	mov	r10,r3
8000aff8:	6e a8       	ld.w	r8,r7[0x28]
8000affa:	6e 8b       	ld.w	r11,r7[0x20]
8000affc:	0a 9c       	mov	r12,r5
8000affe:	5d 18       	icall	r8
8000b000:	18 16       	sub	r6,r12
8000b002:	58 0c       	cp.w	r12,0
8000b004:	e0 8a 01 0a 	brle	8000b218 <__sfvwrite_r+0x284>
8000b008:	68 28       	ld.w	r8,r4[0x8]
8000b00a:	18 18       	sub	r8,r12
8000b00c:	89 28       	st.w	r4[0x8],r8
8000b00e:	e0 80 01 0a 	breq	8000b222 <__sfvwrite_r+0x28e>
8000b012:	18 03       	add	r3,r12
8000b014:	ce 9b       	rjmp	8000afe6 <__sfvwrite_r+0x52>
8000b016:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000b01a:	c0 70       	breq	8000b028 <__sfvwrite_r+0x94>
8000b01c:	50 06       	stdsp	sp[0x0],r6
8000b01e:	0c 93       	mov	r3,r6
8000b020:	0c 91       	mov	r1,r6
8000b022:	50 15       	stdsp	sp[0x4],r5
8000b024:	08 92       	mov	r2,r4
8000b026:	c9 c8       	rjmp	8000b15e <__sfvwrite_r+0x1ca>
8000b028:	06 96       	mov	r6,r3
8000b02a:	08 91       	mov	r1,r4
8000b02c:	c0 48       	rjmp	8000b034 <__sfvwrite_r+0xa0>
8000b02e:	60 03       	ld.w	r3,r0[0x0]
8000b030:	60 16       	ld.w	r6,r0[0x4]
8000b032:	2f 80       	sub	r0,-8
8000b034:	58 06       	cp.w	r6,0
8000b036:	cf c0       	breq	8000b02e <__sfvwrite_r+0x9a>
8000b038:	8e 68       	ld.sh	r8,r7[0xc]
8000b03a:	6e 24       	ld.w	r4,r7[0x8]
8000b03c:	10 99       	mov	r9,r8
8000b03e:	e2 19 02 00 	andl	r9,0x200,COH
8000b042:	c5 50       	breq	8000b0ec <__sfvwrite_r+0x158>
8000b044:	08 36       	cp.w	r6,r4
8000b046:	c4 43       	brcs	8000b0ce <__sfvwrite_r+0x13a>
8000b048:	10 99       	mov	r9,r8
8000b04a:	e2 19 04 80 	andl	r9,0x480,COH
8000b04e:	c4 00       	breq	8000b0ce <__sfvwrite_r+0x13a>
8000b050:	6e 4b       	ld.w	r11,r7[0x10]
8000b052:	6e 09       	ld.w	r9,r7[0x0]
8000b054:	16 19       	sub	r9,r11
8000b056:	50 09       	stdsp	sp[0x0],r9
8000b058:	6e 59       	ld.w	r9,r7[0x14]
8000b05a:	10 9c       	mov	r12,r8
8000b05c:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000b060:	30 28       	mov	r8,2
8000b062:	f4 08 0c 08 	divs	r8,r10,r8
8000b066:	fa e9 00 04 	st.d	sp[4],r8
8000b06a:	10 94       	mov	r4,r8
8000b06c:	40 09       	lddsp	r9,sp[0x0]
8000b06e:	e2 1c 04 00 	andl	r12,0x400,COH
8000b072:	2f f9       	sub	r9,-1
8000b074:	0c 09       	add	r9,r6
8000b076:	12 38       	cp.w	r8,r9
8000b078:	f2 04 17 30 	movlo	r4,r9
8000b07c:	58 0c       	cp.w	r12,0
8000b07e:	c1 10       	breq	8000b0a0 <__sfvwrite_r+0x10c>
8000b080:	08 9b       	mov	r11,r4
8000b082:	0a 9c       	mov	r12,r5
8000b084:	fe b0 e0 6c 	rcall	8000715c <_malloc_r>
8000b088:	18 92       	mov	r2,r12
8000b08a:	c1 40       	breq	8000b0b2 <__sfvwrite_r+0x11e>
8000b08c:	40 0a       	lddsp	r10,sp[0x0]
8000b08e:	6e 4b       	ld.w	r11,r7[0x10]
8000b090:	fe b0 e2 82 	rcall	80007594 <memcpy>
8000b094:	8e 68       	ld.sh	r8,r7[0xc]
8000b096:	e0 18 fb 7f 	andl	r8,0xfb7f
8000b09a:	a7 b8       	sbr	r8,0x7
8000b09c:	ae 68       	st.h	r7[0xc],r8
8000b09e:	c0 d8       	rjmp	8000b0b8 <__sfvwrite_r+0x124>
8000b0a0:	08 9a       	mov	r10,r4
8000b0a2:	0a 9c       	mov	r12,r5
8000b0a4:	fe b0 e3 24 	rcall	800076ec <_realloc_r>
8000b0a8:	18 92       	mov	r2,r12
8000b0aa:	c0 71       	brne	8000b0b8 <__sfvwrite_r+0x124>
8000b0ac:	6e 4b       	ld.w	r11,r7[0x10]
8000b0ae:	0a 9c       	mov	r12,r5
8000b0b0:	ca ce       	rcall	8000ae08 <_free_r>
8000b0b2:	30 c8       	mov	r8,12
8000b0b4:	8b 38       	st.w	r5[0xc],r8
8000b0b6:	cb 18       	rjmp	8000b218 <__sfvwrite_r+0x284>
8000b0b8:	40 0a       	lddsp	r10,sp[0x0]
8000b0ba:	40 09       	lddsp	r9,sp[0x0]
8000b0bc:	e8 0a 01 0a 	sub	r10,r4,r10
8000b0c0:	e4 09 00 08 	add	r8,r2,r9
8000b0c4:	8f 54       	st.w	r7[0x14],r4
8000b0c6:	8f 2a       	st.w	r7[0x8],r10
8000b0c8:	8f 08       	st.w	r7[0x0],r8
8000b0ca:	8f 42       	st.w	r7[0x10],r2
8000b0cc:	0c 94       	mov	r4,r6
8000b0ce:	08 36       	cp.w	r6,r4
8000b0d0:	ec 04 17 30 	movlo	r4,r6
8000b0d4:	06 9b       	mov	r11,r3
8000b0d6:	08 9a       	mov	r10,r4
8000b0d8:	6e 0c       	ld.w	r12,r7[0x0]
8000b0da:	c3 ad       	rcall	8000b34e <memmove>
8000b0dc:	6e 08       	ld.w	r8,r7[0x0]
8000b0de:	08 08       	add	r8,r4
8000b0e0:	8f 08       	st.w	r7[0x0],r8
8000b0e2:	6e 28       	ld.w	r8,r7[0x8]
8000b0e4:	08 18       	sub	r8,r4
8000b0e6:	0c 94       	mov	r4,r6
8000b0e8:	8f 28       	st.w	r7[0x8],r8
8000b0ea:	c2 e8       	rjmp	8000b146 <__sfvwrite_r+0x1b2>
8000b0ec:	08 36       	cp.w	r6,r4
8000b0ee:	5f ba       	srhi	r10
8000b0f0:	6e 0c       	ld.w	r12,r7[0x0]
8000b0f2:	6e 48       	ld.w	r8,r7[0x10]
8000b0f4:	10 3c       	cp.w	r12,r8
8000b0f6:	5f b8       	srhi	r8
8000b0f8:	f5 e8 00 08 	and	r8,r10,r8
8000b0fc:	f2 08 18 00 	cp.b	r8,r9
8000b100:	c0 d0       	breq	8000b11a <__sfvwrite_r+0x186>
8000b102:	06 9b       	mov	r11,r3
8000b104:	08 9a       	mov	r10,r4
8000b106:	c2 4d       	rcall	8000b34e <memmove>
8000b108:	6e 08       	ld.w	r8,r7[0x0]
8000b10a:	08 08       	add	r8,r4
8000b10c:	0e 9b       	mov	r11,r7
8000b10e:	8f 08       	st.w	r7[0x0],r8
8000b110:	0a 9c       	mov	r12,r5
8000b112:	fe b0 fd 09 	rcall	8000ab24 <_fflush_r>
8000b116:	c1 80       	breq	8000b146 <__sfvwrite_r+0x1b2>
8000b118:	c8 08       	rjmp	8000b218 <__sfvwrite_r+0x284>
8000b11a:	6e 59       	ld.w	r9,r7[0x14]
8000b11c:	12 36       	cp.w	r6,r9
8000b11e:	c0 a3       	brcs	8000b132 <__sfvwrite_r+0x19e>
8000b120:	6e a8       	ld.w	r8,r7[0x28]
8000b122:	06 9a       	mov	r10,r3
8000b124:	6e 8b       	ld.w	r11,r7[0x20]
8000b126:	0a 9c       	mov	r12,r5
8000b128:	5d 18       	icall	r8
8000b12a:	18 94       	mov	r4,r12
8000b12c:	e0 89 00 0d 	brgt	8000b146 <__sfvwrite_r+0x1b2>
8000b130:	c7 48       	rjmp	8000b218 <__sfvwrite_r+0x284>
8000b132:	0c 9a       	mov	r10,r6
8000b134:	06 9b       	mov	r11,r3
8000b136:	c0 cd       	rcall	8000b34e <memmove>
8000b138:	6e 08       	ld.w	r8,r7[0x0]
8000b13a:	0c 08       	add	r8,r6
8000b13c:	0c 94       	mov	r4,r6
8000b13e:	8f 08       	st.w	r7[0x0],r8
8000b140:	6e 28       	ld.w	r8,r7[0x8]
8000b142:	0c 18       	sub	r8,r6
8000b144:	8f 28       	st.w	r7[0x8],r8
8000b146:	62 28       	ld.w	r8,r1[0x8]
8000b148:	08 18       	sub	r8,r4
8000b14a:	83 28       	st.w	r1[0x8],r8
8000b14c:	c6 b0       	breq	8000b222 <__sfvwrite_r+0x28e>
8000b14e:	08 16       	sub	r6,r4
8000b150:	08 03       	add	r3,r4
8000b152:	c7 1b       	rjmp	8000b034 <__sfvwrite_r+0xa0>
8000b154:	60 03       	ld.w	r3,r0[0x0]
8000b156:	60 11       	ld.w	r1,r0[0x4]
8000b158:	30 08       	mov	r8,0
8000b15a:	2f 80       	sub	r0,-8
8000b15c:	50 08       	stdsp	sp[0x0],r8
8000b15e:	58 01       	cp.w	r1,0
8000b160:	cf a0       	breq	8000b154 <__sfvwrite_r+0x1c0>
8000b162:	40 0a       	lddsp	r10,sp[0x0]
8000b164:	58 0a       	cp.w	r10,0
8000b166:	c1 41       	brne	8000b18e <__sfvwrite_r+0x1fa>
8000b168:	e2 c6 ff ff 	sub	r6,r1,-1
8000b16c:	02 9a       	mov	r10,r1
8000b16e:	30 ab       	mov	r11,10
8000b170:	06 9c       	mov	r12,r3
8000b172:	ce 3c       	rcall	8000b338 <memchr>
8000b174:	f8 c8 ff ff 	sub	r8,r12,-1
8000b178:	58 0c       	cp.w	r12,0
8000b17a:	f1 d3 e1 16 	subne	r6,r8,r3
8000b17e:	f9 b9 01 01 	movne	r9,1
8000b182:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b186:	f9 b8 00 01 	moveq	r8,1
8000b18a:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b18e:	02 36       	cp.w	r6,r1
8000b190:	ec 04 17 80 	movls	r4,r6
8000b194:	e2 04 17 b0 	movhi	r4,r1
8000b198:	6e 59       	ld.w	r9,r7[0x14]
8000b19a:	6e 25       	ld.w	r5,r7[0x8]
8000b19c:	f2 05 00 05 	add	r5,r9,r5
8000b1a0:	0a 34       	cp.w	r4,r5
8000b1a2:	5f 9a       	srgt	r10
8000b1a4:	6e 0c       	ld.w	r12,r7[0x0]
8000b1a6:	6e 48       	ld.w	r8,r7[0x10]
8000b1a8:	10 3c       	cp.w	r12,r8
8000b1aa:	5f b8       	srhi	r8
8000b1ac:	f5 e8 00 08 	and	r8,r10,r8
8000b1b0:	30 0a       	mov	r10,0
8000b1b2:	f4 08 18 00 	cp.b	r8,r10
8000b1b6:	c0 d0       	breq	8000b1d0 <__sfvwrite_r+0x23c>
8000b1b8:	06 9b       	mov	r11,r3
8000b1ba:	0a 9a       	mov	r10,r5
8000b1bc:	cc 9c       	rcall	8000b34e <memmove>
8000b1be:	6e 08       	ld.w	r8,r7[0x0]
8000b1c0:	0a 08       	add	r8,r5
8000b1c2:	0e 9b       	mov	r11,r7
8000b1c4:	8f 08       	st.w	r7[0x0],r8
8000b1c6:	40 1c       	lddsp	r12,sp[0x4]
8000b1c8:	fe b0 fc ae 	rcall	8000ab24 <_fflush_r>
8000b1cc:	c1 70       	breq	8000b1fa <__sfvwrite_r+0x266>
8000b1ce:	c2 58       	rjmp	8000b218 <__sfvwrite_r+0x284>
8000b1d0:	12 34       	cp.w	r4,r9
8000b1d2:	c0 a5       	brlt	8000b1e6 <__sfvwrite_r+0x252>
8000b1d4:	6e a8       	ld.w	r8,r7[0x28]
8000b1d6:	06 9a       	mov	r10,r3
8000b1d8:	6e 8b       	ld.w	r11,r7[0x20]
8000b1da:	40 1c       	lddsp	r12,sp[0x4]
8000b1dc:	5d 18       	icall	r8
8000b1de:	18 95       	mov	r5,r12
8000b1e0:	e0 89 00 0d 	brgt	8000b1fa <__sfvwrite_r+0x266>
8000b1e4:	c1 a8       	rjmp	8000b218 <__sfvwrite_r+0x284>
8000b1e6:	08 9a       	mov	r10,r4
8000b1e8:	06 9b       	mov	r11,r3
8000b1ea:	cb 2c       	rcall	8000b34e <memmove>
8000b1ec:	6e 08       	ld.w	r8,r7[0x0]
8000b1ee:	08 08       	add	r8,r4
8000b1f0:	08 95       	mov	r5,r4
8000b1f2:	8f 08       	st.w	r7[0x0],r8
8000b1f4:	6e 28       	ld.w	r8,r7[0x8]
8000b1f6:	08 18       	sub	r8,r4
8000b1f8:	8f 28       	st.w	r7[0x8],r8
8000b1fa:	0a 16       	sub	r6,r5
8000b1fc:	c0 71       	brne	8000b20a <__sfvwrite_r+0x276>
8000b1fe:	0e 9b       	mov	r11,r7
8000b200:	40 1c       	lddsp	r12,sp[0x4]
8000b202:	fe b0 fc 91 	rcall	8000ab24 <_fflush_r>
8000b206:	c0 91       	brne	8000b218 <__sfvwrite_r+0x284>
8000b208:	50 06       	stdsp	sp[0x0],r6
8000b20a:	64 28       	ld.w	r8,r2[0x8]
8000b20c:	0a 18       	sub	r8,r5
8000b20e:	85 28       	st.w	r2[0x8],r8
8000b210:	c0 90       	breq	8000b222 <__sfvwrite_r+0x28e>
8000b212:	0a 11       	sub	r1,r5
8000b214:	0a 03       	add	r3,r5
8000b216:	ca 4b       	rjmp	8000b15e <__sfvwrite_r+0x1ca>
8000b218:	8e 68       	ld.sh	r8,r7[0xc]
8000b21a:	a7 a8       	sbr	r8,0x6
8000b21c:	ae 68       	st.h	r7[0xc],r8
8000b21e:	3f fc       	mov	r12,-1
8000b220:	c0 28       	rjmp	8000b224 <__sfvwrite_r+0x290>
8000b222:	30 0c       	mov	r12,0
8000b224:	2f dd       	sub	sp,-12
8000b226:	d8 32       	popm	r0-r7,pc

8000b228 <_fwalk>:
8000b228:	d4 31       	pushm	r0-r7,lr
8000b22a:	30 05       	mov	r5,0
8000b22c:	16 91       	mov	r1,r11
8000b22e:	f8 c7 ff 28 	sub	r7,r12,-216
8000b232:	0a 92       	mov	r2,r5
8000b234:	fe b0 fc fe 	rcall	8000ac30 <__sfp_lock_acquire>
8000b238:	3f f3       	mov	r3,-1
8000b23a:	c1 68       	rjmp	8000b266 <_fwalk+0x3e>
8000b23c:	6e 26       	ld.w	r6,r7[0x8]
8000b23e:	6e 14       	ld.w	r4,r7[0x4]
8000b240:	2f 46       	sub	r6,-12
8000b242:	c0 c8       	rjmp	8000b25a <_fwalk+0x32>
8000b244:	8c 08       	ld.sh	r8,r6[0x0]
8000b246:	e4 08 19 00 	cp.h	r8,r2
8000b24a:	c0 70       	breq	8000b258 <_fwalk+0x30>
8000b24c:	8c 18       	ld.sh	r8,r6[0x2]
8000b24e:	e6 08 19 00 	cp.h	r8,r3
8000b252:	c0 30       	breq	8000b258 <_fwalk+0x30>
8000b254:	5d 11       	icall	r1
8000b256:	18 45       	or	r5,r12
8000b258:	2a 46       	sub	r6,-92
8000b25a:	20 14       	sub	r4,1
8000b25c:	ec cc 00 0c 	sub	r12,r6,12
8000b260:	58 04       	cp.w	r4,0
8000b262:	cf 14       	brge	8000b244 <_fwalk+0x1c>
8000b264:	6e 07       	ld.w	r7,r7[0x0]
8000b266:	58 07       	cp.w	r7,0
8000b268:	ce a1       	brne	8000b23c <_fwalk+0x14>
8000b26a:	fe b0 fc e4 	rcall	8000ac32 <__sfp_lock_release>
8000b26e:	0a 9c       	mov	r12,r5
8000b270:	d8 32       	popm	r0-r7,pc
8000b272:	d7 03       	nop

8000b274 <_localeconv_r>:
8000b274:	fe cc d4 0c 	sub	r12,pc,-11252
8000b278:	5e fc       	retal	r12
8000b27a:	d7 03       	nop

8000b27c <__smakebuf_r>:
8000b27c:	d4 21       	pushm	r4-r7,lr
8000b27e:	20 fd       	sub	sp,60
8000b280:	96 68       	ld.sh	r8,r11[0xc]
8000b282:	16 97       	mov	r7,r11
8000b284:	18 96       	mov	r6,r12
8000b286:	e2 18 00 02 	andl	r8,0x2,COH
8000b28a:	c3 d1       	brne	8000b304 <__smakebuf_r+0x88>
8000b28c:	96 7b       	ld.sh	r11,r11[0xe]
8000b28e:	f0 0b 19 00 	cp.h	r11,r8
8000b292:	c0 55       	brlt	8000b29c <__smakebuf_r+0x20>
8000b294:	1a 9a       	mov	r10,sp
8000b296:	e0 a0 04 81 	rcall	8000bb98 <_fstat_r>
8000b29a:	c0 f4       	brge	8000b2b8 <__smakebuf_r+0x3c>
8000b29c:	8e 65       	ld.sh	r5,r7[0xc]
8000b29e:	0a 98       	mov	r8,r5
8000b2a0:	ab b8       	sbr	r8,0xb
8000b2a2:	e2 15 00 80 	andl	r5,0x80,COH
8000b2a6:	ae 68       	st.h	r7[0xc],r8
8000b2a8:	30 04       	mov	r4,0
8000b2aa:	e0 68 04 00 	mov	r8,1024
8000b2ae:	f9 b5 01 40 	movne	r5,64
8000b2b2:	f0 05 17 00 	moveq	r5,r8
8000b2b6:	c1 c8       	rjmp	8000b2ee <__smakebuf_r+0x72>
8000b2b8:	40 18       	lddsp	r8,sp[0x4]
8000b2ba:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b2be:	e0 48 20 00 	cp.w	r8,8192
8000b2c2:	5f 04       	sreq	r4
8000b2c4:	e0 48 80 00 	cp.w	r8,32768
8000b2c8:	c0 e1       	brne	8000b2e4 <__smakebuf_r+0x68>
8000b2ca:	6e b9       	ld.w	r9,r7[0x2c]
8000b2cc:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b2d0:	10 39       	cp.w	r9,r8
8000b2d2:	c0 91       	brne	8000b2e4 <__smakebuf_r+0x68>
8000b2d4:	8e 68       	ld.sh	r8,r7[0xc]
8000b2d6:	e0 65 04 00 	mov	r5,1024
8000b2da:	ab a8       	sbr	r8,0xa
8000b2dc:	ef 45 00 50 	st.w	r7[80],r5
8000b2e0:	ae 68       	st.h	r7[0xc],r8
8000b2e2:	c0 68       	rjmp	8000b2ee <__smakebuf_r+0x72>
8000b2e4:	8e 68       	ld.sh	r8,r7[0xc]
8000b2e6:	e0 65 04 00 	mov	r5,1024
8000b2ea:	ab b8       	sbr	r8,0xb
8000b2ec:	ae 68       	st.h	r7[0xc],r8
8000b2ee:	0a 9b       	mov	r11,r5
8000b2f0:	0c 9c       	mov	r12,r6
8000b2f2:	fe b0 df 35 	rcall	8000715c <_malloc_r>
8000b2f6:	8e 68       	ld.sh	r8,r7[0xc]
8000b2f8:	c0 d1       	brne	8000b312 <__smakebuf_r+0x96>
8000b2fa:	ed b8 00 09 	bld	r8,0x9
8000b2fe:	c1 b0       	breq	8000b334 <__smakebuf_r+0xb8>
8000b300:	a1 b8       	sbr	r8,0x1
8000b302:	ae 68       	st.h	r7[0xc],r8
8000b304:	ee c8 ff b9 	sub	r8,r7,-71
8000b308:	8f 48       	st.w	r7[0x10],r8
8000b30a:	8f 08       	st.w	r7[0x0],r8
8000b30c:	30 18       	mov	r8,1
8000b30e:	8f 58       	st.w	r7[0x14],r8
8000b310:	c1 28       	rjmp	8000b334 <__smakebuf_r+0xb8>
8000b312:	a7 b8       	sbr	r8,0x7
8000b314:	8f 4c       	st.w	r7[0x10],r12
8000b316:	ae 68       	st.h	r7[0xc],r8
8000b318:	8f 55       	st.w	r7[0x14],r5
8000b31a:	fe c8 06 e6 	sub	r8,pc,1766
8000b31e:	8f 0c       	st.w	r7[0x0],r12
8000b320:	8d a8       	st.w	r6[0x28],r8
8000b322:	58 04       	cp.w	r4,0
8000b324:	c0 80       	breq	8000b334 <__smakebuf_r+0xb8>
8000b326:	8e 7c       	ld.sh	r12,r7[0xe]
8000b328:	fe b0 e3 94 	rcall	80007a50 <isatty>
8000b32c:	c0 40       	breq	8000b334 <__smakebuf_r+0xb8>
8000b32e:	8e 68       	ld.sh	r8,r7[0xc]
8000b330:	a1 a8       	sbr	r8,0x0
8000b332:	ae 68       	st.h	r7[0xc],r8
8000b334:	2f 1d       	sub	sp,-60
8000b336:	d8 22       	popm	r4-r7,pc

8000b338 <memchr>:
8000b338:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b33c:	c0 68       	rjmp	8000b348 <memchr+0x10>
8000b33e:	20 1a       	sub	r10,1
8000b340:	19 88       	ld.ub	r8,r12[0x0]
8000b342:	16 38       	cp.w	r8,r11
8000b344:	5e 0c       	reteq	r12
8000b346:	2f fc       	sub	r12,-1
8000b348:	58 0a       	cp.w	r10,0
8000b34a:	cf a1       	brne	8000b33e <memchr+0x6>
8000b34c:	5e fa       	retal	r10

8000b34e <memmove>:
8000b34e:	d4 01       	pushm	lr
8000b350:	18 3b       	cp.w	r11,r12
8000b352:	c1 92       	brcc	8000b384 <memmove+0x36>
8000b354:	f6 0a 00 09 	add	r9,r11,r10
8000b358:	12 3c       	cp.w	r12,r9
8000b35a:	c1 52       	brcc	8000b384 <memmove+0x36>
8000b35c:	f8 0a 00 0b 	add	r11,r12,r10
8000b360:	30 08       	mov	r8,0
8000b362:	c0 68       	rjmp	8000b36e <memmove+0x20>
8000b364:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b368:	20 1a       	sub	r10,1
8000b36a:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b36e:	20 18       	sub	r8,1
8000b370:	58 0a       	cp.w	r10,0
8000b372:	cf 91       	brne	8000b364 <memmove+0x16>
8000b374:	d8 02       	popm	pc
8000b376:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b37a:	20 1a       	sub	r10,1
8000b37c:	f8 08 0b 09 	st.b	r12[r8],r9
8000b380:	2f f8       	sub	r8,-1
8000b382:	c0 28       	rjmp	8000b386 <memmove+0x38>
8000b384:	30 08       	mov	r8,0
8000b386:	58 0a       	cp.w	r10,0
8000b388:	cf 71       	brne	8000b376 <memmove+0x28>
8000b38a:	d8 02       	popm	pc

8000b38c <__hi0bits>:
8000b38c:	18 98       	mov	r8,r12
8000b38e:	e0 1c 00 00 	andl	r12,0x0
8000b392:	f0 09 15 10 	lsl	r9,r8,0x10
8000b396:	58 0c       	cp.w	r12,0
8000b398:	f2 08 17 00 	moveq	r8,r9
8000b39c:	f9 bc 00 10 	moveq	r12,16
8000b3a0:	f9 bc 01 00 	movne	r12,0
8000b3a4:	10 9a       	mov	r10,r8
8000b3a6:	f0 09 15 08 	lsl	r9,r8,0x8
8000b3aa:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b3ae:	f7 bc 00 f8 	subeq	r12,-8
8000b3b2:	f2 08 17 00 	moveq	r8,r9
8000b3b6:	10 9a       	mov	r10,r8
8000b3b8:	f0 09 15 04 	lsl	r9,r8,0x4
8000b3bc:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b3c0:	f7 bc 00 fc 	subeq	r12,-4
8000b3c4:	f2 08 17 00 	moveq	r8,r9
8000b3c8:	10 9a       	mov	r10,r8
8000b3ca:	f0 09 15 02 	lsl	r9,r8,0x2
8000b3ce:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b3d2:	f7 bc 00 fe 	subeq	r12,-2
8000b3d6:	f2 08 17 00 	moveq	r8,r9
8000b3da:	58 08       	cp.w	r8,0
8000b3dc:	5e 5c       	retlt	r12
8000b3de:	ed b8 00 1e 	bld	r8,0x1e
8000b3e2:	f9 bc 01 20 	movne	r12,32
8000b3e6:	f7 bc 00 ff 	subeq	r12,-1
8000b3ea:	5e fc       	retal	r12

8000b3ec <__lo0bits>:
8000b3ec:	18 99       	mov	r9,r12
8000b3ee:	78 08       	ld.w	r8,r12[0x0]
8000b3f0:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b3f4:	c1 50       	breq	8000b41e <__lo0bits+0x32>
8000b3f6:	ed b8 00 00 	bld	r8,0x0
8000b3fa:	c0 21       	brne	8000b3fe <__lo0bits+0x12>
8000b3fc:	5e fd       	retal	0
8000b3fe:	10 9b       	mov	r11,r8
8000b400:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b404:	e2 1b 00 02 	andl	r11,0x2,COH
8000b408:	a3 88       	lsr	r8,0x2
8000b40a:	58 0b       	cp.w	r11,0
8000b40c:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b410:	f9 bc 01 01 	movne	r12,1
8000b414:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b418:	f9 bc 00 02 	moveq	r12,2
8000b41c:	5e fc       	retal	r12
8000b41e:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b422:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b426:	58 0a       	cp.w	r10,0
8000b428:	f6 08 17 00 	moveq	r8,r11
8000b42c:	f9 bc 00 10 	moveq	r12,16
8000b430:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b434:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b438:	58 0b       	cp.w	r11,0
8000b43a:	f7 bc 00 f8 	subeq	r12,-8
8000b43e:	f4 08 17 00 	moveq	r8,r10
8000b442:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b446:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b44a:	58 0b       	cp.w	r11,0
8000b44c:	f7 bc 00 fc 	subeq	r12,-4
8000b450:	f4 08 17 00 	moveq	r8,r10
8000b454:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b458:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b45c:	58 0b       	cp.w	r11,0
8000b45e:	f7 bc 00 fe 	subeq	r12,-2
8000b462:	f4 08 17 00 	moveq	r8,r10
8000b466:	ed b8 00 00 	bld	r8,0x0
8000b46a:	c0 60       	breq	8000b476 <__lo0bits+0x8a>
8000b46c:	a1 98       	lsr	r8,0x1
8000b46e:	c0 31       	brne	8000b474 <__lo0bits+0x88>
8000b470:	32 0c       	mov	r12,32
8000b472:	5e fc       	retal	r12
8000b474:	2f fc       	sub	r12,-1
8000b476:	93 08       	st.w	r9[0x0],r8
8000b478:	5e fc       	retal	r12

8000b47a <__mcmp>:
8000b47a:	d4 01       	pushm	lr
8000b47c:	18 98       	mov	r8,r12
8000b47e:	76 49       	ld.w	r9,r11[0x10]
8000b480:	78 4c       	ld.w	r12,r12[0x10]
8000b482:	12 1c       	sub	r12,r9
8000b484:	c1 31       	brne	8000b4aa <__mcmp+0x30>
8000b486:	2f b9       	sub	r9,-5
8000b488:	a3 69       	lsl	r9,0x2
8000b48a:	12 0b       	add	r11,r9
8000b48c:	f0 09 00 09 	add	r9,r8,r9
8000b490:	2e c8       	sub	r8,-20
8000b492:	13 4e       	ld.w	lr,--r9
8000b494:	17 4a       	ld.w	r10,--r11
8000b496:	14 3e       	cp.w	lr,r10
8000b498:	c0 60       	breq	8000b4a4 <__mcmp+0x2a>
8000b49a:	f9 bc 03 ff 	movlo	r12,-1
8000b49e:	f9 bc 02 01 	movhs	r12,1
8000b4a2:	d8 02       	popm	pc
8000b4a4:	10 39       	cp.w	r9,r8
8000b4a6:	fe 9b ff f6 	brhi	8000b492 <__mcmp+0x18>
8000b4aa:	d8 02       	popm	pc

8000b4ac <_Bfree>:
8000b4ac:	d4 21       	pushm	r4-r7,lr
8000b4ae:	18 97       	mov	r7,r12
8000b4b0:	16 95       	mov	r5,r11
8000b4b2:	78 96       	ld.w	r6,r12[0x24]
8000b4b4:	58 06       	cp.w	r6,0
8000b4b6:	c0 91       	brne	8000b4c8 <_Bfree+0x1c>
8000b4b8:	31 0c       	mov	r12,16
8000b4ba:	fe b0 de 49 	rcall	8000714c <malloc>
8000b4be:	99 36       	st.w	r12[0xc],r6
8000b4c0:	8f 9c       	st.w	r7[0x24],r12
8000b4c2:	99 16       	st.w	r12[0x4],r6
8000b4c4:	99 26       	st.w	r12[0x8],r6
8000b4c6:	99 06       	st.w	r12[0x0],r6
8000b4c8:	58 05       	cp.w	r5,0
8000b4ca:	c0 90       	breq	8000b4dc <_Bfree+0x30>
8000b4cc:	6a 19       	ld.w	r9,r5[0x4]
8000b4ce:	6e 98       	ld.w	r8,r7[0x24]
8000b4d0:	70 38       	ld.w	r8,r8[0xc]
8000b4d2:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b4d6:	8b 0a       	st.w	r5[0x0],r10
8000b4d8:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b4dc:	d8 22       	popm	r4-r7,pc
8000b4de:	d7 03       	nop

8000b4e0 <_Balloc>:
8000b4e0:	d4 21       	pushm	r4-r7,lr
8000b4e2:	18 97       	mov	r7,r12
8000b4e4:	16 96       	mov	r6,r11
8000b4e6:	78 95       	ld.w	r5,r12[0x24]
8000b4e8:	58 05       	cp.w	r5,0
8000b4ea:	c0 91       	brne	8000b4fc <_Balloc+0x1c>
8000b4ec:	31 0c       	mov	r12,16
8000b4ee:	fe b0 de 2f 	rcall	8000714c <malloc>
8000b4f2:	99 35       	st.w	r12[0xc],r5
8000b4f4:	8f 9c       	st.w	r7[0x24],r12
8000b4f6:	99 15       	st.w	r12[0x4],r5
8000b4f8:	99 25       	st.w	r12[0x8],r5
8000b4fa:	99 05       	st.w	r12[0x0],r5
8000b4fc:	6e 95       	ld.w	r5,r7[0x24]
8000b4fe:	6a 38       	ld.w	r8,r5[0xc]
8000b500:	58 08       	cp.w	r8,0
8000b502:	c0 b1       	brne	8000b518 <_Balloc+0x38>
8000b504:	31 0a       	mov	r10,16
8000b506:	30 4b       	mov	r11,4
8000b508:	0e 9c       	mov	r12,r7
8000b50a:	e0 a0 02 a7 	rcall	8000ba58 <_calloc_r>
8000b50e:	8b 3c       	st.w	r5[0xc],r12
8000b510:	6e 98       	ld.w	r8,r7[0x24]
8000b512:	70 3c       	ld.w	r12,r8[0xc]
8000b514:	58 0c       	cp.w	r12,0
8000b516:	c1 b0       	breq	8000b54c <_Balloc+0x6c>
8000b518:	6e 98       	ld.w	r8,r7[0x24]
8000b51a:	70 38       	ld.w	r8,r8[0xc]
8000b51c:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b520:	70 0c       	ld.w	r12,r8[0x0]
8000b522:	58 0c       	cp.w	r12,0
8000b524:	c0 40       	breq	8000b52c <_Balloc+0x4c>
8000b526:	78 09       	ld.w	r9,r12[0x0]
8000b528:	91 09       	st.w	r8[0x0],r9
8000b52a:	c0 e8       	rjmp	8000b546 <_Balloc+0x66>
8000b52c:	0e 9c       	mov	r12,r7
8000b52e:	30 17       	mov	r7,1
8000b530:	0e 9b       	mov	r11,r7
8000b532:	ee 06 09 47 	lsl	r7,r7,r6
8000b536:	ee ca ff fb 	sub	r10,r7,-5
8000b53a:	a3 6a       	lsl	r10,0x2
8000b53c:	e0 a0 02 8e 	rcall	8000ba58 <_calloc_r>
8000b540:	c0 60       	breq	8000b54c <_Balloc+0x6c>
8000b542:	99 16       	st.w	r12[0x4],r6
8000b544:	99 27       	st.w	r12[0x8],r7
8000b546:	30 08       	mov	r8,0
8000b548:	99 38       	st.w	r12[0xc],r8
8000b54a:	99 48       	st.w	r12[0x10],r8
8000b54c:	d8 22       	popm	r4-r7,pc
8000b54e:	d7 03       	nop

8000b550 <__d2b>:
8000b550:	d4 31       	pushm	r0-r7,lr
8000b552:	20 2d       	sub	sp,8
8000b554:	16 93       	mov	r3,r11
8000b556:	12 96       	mov	r6,r9
8000b558:	10 95       	mov	r5,r8
8000b55a:	14 92       	mov	r2,r10
8000b55c:	30 1b       	mov	r11,1
8000b55e:	cc 1f       	rcall	8000b4e0 <_Balloc>
8000b560:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b564:	50 09       	stdsp	sp[0x0],r9
8000b566:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b56a:	b5 a9       	sbr	r9,0x14
8000b56c:	f0 01 16 14 	lsr	r1,r8,0x14
8000b570:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b574:	18 94       	mov	r4,r12
8000b576:	58 02       	cp.w	r2,0
8000b578:	c1 d0       	breq	8000b5b2 <__d2b+0x62>
8000b57a:	fa cc ff f8 	sub	r12,sp,-8
8000b57e:	18 d2       	st.w	--r12,r2
8000b580:	c3 6f       	rcall	8000b3ec <__lo0bits>
8000b582:	40 18       	lddsp	r8,sp[0x4]
8000b584:	c0 d0       	breq	8000b59e <__d2b+0x4e>
8000b586:	40 09       	lddsp	r9,sp[0x0]
8000b588:	f8 0a 11 20 	rsub	r10,r12,32
8000b58c:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b590:	f5 e8 10 08 	or	r8,r10,r8
8000b594:	89 58       	st.w	r4[0x14],r8
8000b596:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b59a:	50 09       	stdsp	sp[0x0],r9
8000b59c:	c0 28       	rjmp	8000b5a0 <__d2b+0x50>
8000b59e:	89 58       	st.w	r4[0x14],r8
8000b5a0:	40 08       	lddsp	r8,sp[0x0]
8000b5a2:	58 08       	cp.w	r8,0
8000b5a4:	f9 b3 01 02 	movne	r3,2
8000b5a8:	f9 b3 00 01 	moveq	r3,1
8000b5ac:	89 68       	st.w	r4[0x18],r8
8000b5ae:	89 43       	st.w	r4[0x10],r3
8000b5b0:	c0 88       	rjmp	8000b5c0 <__d2b+0x70>
8000b5b2:	1a 9c       	mov	r12,sp
8000b5b4:	c1 cf       	rcall	8000b3ec <__lo0bits>
8000b5b6:	30 13       	mov	r3,1
8000b5b8:	40 08       	lddsp	r8,sp[0x0]
8000b5ba:	2e 0c       	sub	r12,-32
8000b5bc:	89 43       	st.w	r4[0x10],r3
8000b5be:	89 58       	st.w	r4[0x14],r8
8000b5c0:	58 01       	cp.w	r1,0
8000b5c2:	c0 90       	breq	8000b5d4 <__d2b+0x84>
8000b5c4:	e2 c1 04 33 	sub	r1,r1,1075
8000b5c8:	18 01       	add	r1,r12
8000b5ca:	8d 01       	st.w	r6[0x0],r1
8000b5cc:	f8 0c 11 35 	rsub	r12,r12,53
8000b5d0:	8b 0c       	st.w	r5[0x0],r12
8000b5d2:	c0 c8       	rjmp	8000b5ea <__d2b+0x9a>
8000b5d4:	e6 c8 ff fc 	sub	r8,r3,-4
8000b5d8:	f8 cc 04 32 	sub	r12,r12,1074
8000b5dc:	a5 73       	lsl	r3,0x5
8000b5de:	8d 0c       	st.w	r6[0x0],r12
8000b5e0:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b5e4:	cd 4e       	rcall	8000b38c <__hi0bits>
8000b5e6:	18 13       	sub	r3,r12
8000b5e8:	8b 03       	st.w	r5[0x0],r3
8000b5ea:	08 9c       	mov	r12,r4
8000b5ec:	2f ed       	sub	sp,-8
8000b5ee:	d8 32       	popm	r0-r7,pc

8000b5f0 <__mdiff>:
8000b5f0:	d4 31       	pushm	r0-r7,lr
8000b5f2:	74 48       	ld.w	r8,r10[0x10]
8000b5f4:	76 45       	ld.w	r5,r11[0x10]
8000b5f6:	16 97       	mov	r7,r11
8000b5f8:	14 96       	mov	r6,r10
8000b5fa:	10 15       	sub	r5,r8
8000b5fc:	c1 31       	brne	8000b622 <__mdiff+0x32>
8000b5fe:	2f b8       	sub	r8,-5
8000b600:	ee ce ff ec 	sub	lr,r7,-20
8000b604:	a3 68       	lsl	r8,0x2
8000b606:	f4 08 00 0b 	add	r11,r10,r8
8000b60a:	ee 08 00 08 	add	r8,r7,r8
8000b60e:	11 4a       	ld.w	r10,--r8
8000b610:	17 49       	ld.w	r9,--r11
8000b612:	12 3a       	cp.w	r10,r9
8000b614:	c0 30       	breq	8000b61a <__mdiff+0x2a>
8000b616:	c0 e2       	brcc	8000b632 <__mdiff+0x42>
8000b618:	c0 78       	rjmp	8000b626 <__mdiff+0x36>
8000b61a:	1c 38       	cp.w	r8,lr
8000b61c:	fe 9b ff f9 	brhi	8000b60e <__mdiff+0x1e>
8000b620:	c4 98       	rjmp	8000b6b2 <__mdiff+0xc2>
8000b622:	58 05       	cp.w	r5,0
8000b624:	c0 64       	brge	8000b630 <__mdiff+0x40>
8000b626:	0e 98       	mov	r8,r7
8000b628:	30 15       	mov	r5,1
8000b62a:	0c 97       	mov	r7,r6
8000b62c:	10 96       	mov	r6,r8
8000b62e:	c0 28       	rjmp	8000b632 <__mdiff+0x42>
8000b630:	30 05       	mov	r5,0
8000b632:	6e 1b       	ld.w	r11,r7[0x4]
8000b634:	c5 6f       	rcall	8000b4e0 <_Balloc>
8000b636:	6e 49       	ld.w	r9,r7[0x10]
8000b638:	6c 44       	ld.w	r4,r6[0x10]
8000b63a:	99 35       	st.w	r12[0xc],r5
8000b63c:	2f b4       	sub	r4,-5
8000b63e:	f2 c5 ff fb 	sub	r5,r9,-5
8000b642:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b646:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b64a:	2e c6       	sub	r6,-20
8000b64c:	2e c7       	sub	r7,-20
8000b64e:	f8 c8 ff ec 	sub	r8,r12,-20
8000b652:	30 0a       	mov	r10,0
8000b654:	0f 0e       	ld.w	lr,r7++
8000b656:	0d 0b       	ld.w	r11,r6++
8000b658:	fc 02 16 10 	lsr	r2,lr,0x10
8000b65c:	f6 03 16 10 	lsr	r3,r11,0x10
8000b660:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b664:	e4 03 01 03 	sub	r3,r2,r3
8000b668:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b66c:	fc 0b 01 0b 	sub	r11,lr,r11
8000b670:	f6 0a 00 0a 	add	r10,r11,r10
8000b674:	b0 1a       	st.h	r8[0x2],r10
8000b676:	b1 4a       	asr	r10,0x10
8000b678:	e6 0a 00 0a 	add	r10,r3,r10
8000b67c:	b0 0a       	st.h	r8[0x0],r10
8000b67e:	2f c8       	sub	r8,-4
8000b680:	b1 4a       	asr	r10,0x10
8000b682:	08 36       	cp.w	r6,r4
8000b684:	ce 83       	brcs	8000b654 <__mdiff+0x64>
8000b686:	c0 d8       	rjmp	8000b6a0 <__mdiff+0xb0>
8000b688:	0f 0b       	ld.w	r11,r7++
8000b68a:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b68e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b692:	16 0a       	add	r10,r11
8000b694:	b0 1a       	st.h	r8[0x2],r10
8000b696:	b1 4a       	asr	r10,0x10
8000b698:	1c 0a       	add	r10,lr
8000b69a:	b0 0a       	st.h	r8[0x0],r10
8000b69c:	2f c8       	sub	r8,-4
8000b69e:	b1 4a       	asr	r10,0x10
8000b6a0:	0a 37       	cp.w	r7,r5
8000b6a2:	cf 33       	brcs	8000b688 <__mdiff+0x98>
8000b6a4:	c0 28       	rjmp	8000b6a8 <__mdiff+0xb8>
8000b6a6:	20 19       	sub	r9,1
8000b6a8:	11 4a       	ld.w	r10,--r8
8000b6aa:	58 0a       	cp.w	r10,0
8000b6ac:	cf d0       	breq	8000b6a6 <__mdiff+0xb6>
8000b6ae:	99 49       	st.w	r12[0x10],r9
8000b6b0:	d8 32       	popm	r0-r7,pc
8000b6b2:	30 0b       	mov	r11,0
8000b6b4:	c1 6f       	rcall	8000b4e0 <_Balloc>
8000b6b6:	30 18       	mov	r8,1
8000b6b8:	99 48       	st.w	r12[0x10],r8
8000b6ba:	30 08       	mov	r8,0
8000b6bc:	99 58       	st.w	r12[0x14],r8
8000b6be:	d8 32       	popm	r0-r7,pc

8000b6c0 <__lshift>:
8000b6c0:	d4 31       	pushm	r0-r7,lr
8000b6c2:	16 97       	mov	r7,r11
8000b6c4:	76 46       	ld.w	r6,r11[0x10]
8000b6c6:	f4 02 14 05 	asr	r2,r10,0x5
8000b6ca:	2f f6       	sub	r6,-1
8000b6cc:	14 93       	mov	r3,r10
8000b6ce:	18 94       	mov	r4,r12
8000b6d0:	04 06       	add	r6,r2
8000b6d2:	76 1b       	ld.w	r11,r11[0x4]
8000b6d4:	6e 28       	ld.w	r8,r7[0x8]
8000b6d6:	c0 38       	rjmp	8000b6dc <__lshift+0x1c>
8000b6d8:	2f fb       	sub	r11,-1
8000b6da:	a1 78       	lsl	r8,0x1
8000b6dc:	10 36       	cp.w	r6,r8
8000b6de:	fe 99 ff fd 	brgt	8000b6d8 <__lshift+0x18>
8000b6e2:	08 9c       	mov	r12,r4
8000b6e4:	cf ee       	rcall	8000b4e0 <_Balloc>
8000b6e6:	30 09       	mov	r9,0
8000b6e8:	18 95       	mov	r5,r12
8000b6ea:	f8 c8 ff ec 	sub	r8,r12,-20
8000b6ee:	12 9a       	mov	r10,r9
8000b6f0:	c0 38       	rjmp	8000b6f6 <__lshift+0x36>
8000b6f2:	10 aa       	st.w	r8++,r10
8000b6f4:	2f f9       	sub	r9,-1
8000b6f6:	04 39       	cp.w	r9,r2
8000b6f8:	cf d5       	brlt	8000b6f2 <__lshift+0x32>
8000b6fa:	6e 4b       	ld.w	r11,r7[0x10]
8000b6fc:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b700:	2f bb       	sub	r11,-5
8000b702:	ee c9 ff ec 	sub	r9,r7,-20
8000b706:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b70a:	58 03       	cp.w	r3,0
8000b70c:	c1 30       	breq	8000b732 <__lshift+0x72>
8000b70e:	e6 0c 11 20 	rsub	r12,r3,32
8000b712:	30 0a       	mov	r10,0
8000b714:	72 02       	ld.w	r2,r9[0x0]
8000b716:	e4 03 09 42 	lsl	r2,r2,r3
8000b71a:	04 4a       	or	r10,r2
8000b71c:	10 aa       	st.w	r8++,r10
8000b71e:	13 0a       	ld.w	r10,r9++
8000b720:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b724:	16 39       	cp.w	r9,r11
8000b726:	cf 73       	brcs	8000b714 <__lshift+0x54>
8000b728:	91 0a       	st.w	r8[0x0],r10
8000b72a:	58 0a       	cp.w	r10,0
8000b72c:	c0 70       	breq	8000b73a <__lshift+0x7a>
8000b72e:	2f f6       	sub	r6,-1
8000b730:	c0 58       	rjmp	8000b73a <__lshift+0x7a>
8000b732:	13 0a       	ld.w	r10,r9++
8000b734:	10 aa       	st.w	r8++,r10
8000b736:	16 39       	cp.w	r9,r11
8000b738:	cf d3       	brcs	8000b732 <__lshift+0x72>
8000b73a:	08 9c       	mov	r12,r4
8000b73c:	20 16       	sub	r6,1
8000b73e:	0e 9b       	mov	r11,r7
8000b740:	8b 46       	st.w	r5[0x10],r6
8000b742:	cb 5e       	rcall	8000b4ac <_Bfree>
8000b744:	0a 9c       	mov	r12,r5
8000b746:	d8 32       	popm	r0-r7,pc

8000b748 <__multiply>:
8000b748:	d4 31       	pushm	r0-r7,lr
8000b74a:	20 2d       	sub	sp,8
8000b74c:	76 49       	ld.w	r9,r11[0x10]
8000b74e:	74 48       	ld.w	r8,r10[0x10]
8000b750:	16 96       	mov	r6,r11
8000b752:	14 95       	mov	r5,r10
8000b754:	10 39       	cp.w	r9,r8
8000b756:	ec 08 17 50 	movlt	r8,r6
8000b75a:	ea 06 17 50 	movlt	r6,r5
8000b75e:	f0 05 17 50 	movlt	r5,r8
8000b762:	6c 28       	ld.w	r8,r6[0x8]
8000b764:	76 43       	ld.w	r3,r11[0x10]
8000b766:	74 42       	ld.w	r2,r10[0x10]
8000b768:	76 1b       	ld.w	r11,r11[0x4]
8000b76a:	e4 03 00 07 	add	r7,r2,r3
8000b76e:	10 37       	cp.w	r7,r8
8000b770:	f7 bb 09 ff 	subgt	r11,-1
8000b774:	cb 6e       	rcall	8000b4e0 <_Balloc>
8000b776:	ee c4 ff fb 	sub	r4,r7,-5
8000b77a:	f8 c9 ff ec 	sub	r9,r12,-20
8000b77e:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b782:	30 0a       	mov	r10,0
8000b784:	12 98       	mov	r8,r9
8000b786:	c0 28       	rjmp	8000b78a <__multiply+0x42>
8000b788:	10 aa       	st.w	r8++,r10
8000b78a:	08 38       	cp.w	r8,r4
8000b78c:	cf e3       	brcs	8000b788 <__multiply+0x40>
8000b78e:	2f b3       	sub	r3,-5
8000b790:	2f b2       	sub	r2,-5
8000b792:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b796:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b79a:	ec cb ff ec 	sub	r11,r6,-20
8000b79e:	50 12       	stdsp	sp[0x4],r2
8000b7a0:	ea ca ff ec 	sub	r10,r5,-20
8000b7a4:	c4 48       	rjmp	8000b82c <__multiply+0xe4>
8000b7a6:	94 95       	ld.uh	r5,r10[0x2]
8000b7a8:	58 05       	cp.w	r5,0
8000b7aa:	c2 00       	breq	8000b7ea <__multiply+0xa2>
8000b7ac:	12 98       	mov	r8,r9
8000b7ae:	16 96       	mov	r6,r11
8000b7b0:	30 0e       	mov	lr,0
8000b7b2:	50 09       	stdsp	sp[0x0],r9
8000b7b4:	0d 02       	ld.w	r2,r6++
8000b7b6:	e4 00 16 10 	lsr	r0,r2,0x10
8000b7ba:	70 01       	ld.w	r1,r8[0x0]
8000b7bc:	70 09       	ld.w	r9,r8[0x0]
8000b7be:	b1 81       	lsr	r1,0x10
8000b7c0:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b7c4:	e0 05 03 41 	mac	r1,r0,r5
8000b7c8:	ab 32       	mul	r2,r5
8000b7ca:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b7ce:	00 02       	add	r2,r0
8000b7d0:	e4 0e 00 0e 	add	lr,r2,lr
8000b7d4:	b0 1e       	st.h	r8[0x2],lr
8000b7d6:	b1 8e       	lsr	lr,0x10
8000b7d8:	1c 01       	add	r1,lr
8000b7da:	b0 01       	st.h	r8[0x0],r1
8000b7dc:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b7e0:	2f c8       	sub	r8,-4
8000b7e2:	06 36       	cp.w	r6,r3
8000b7e4:	ce 83       	brcs	8000b7b4 <__multiply+0x6c>
8000b7e6:	40 09       	lddsp	r9,sp[0x0]
8000b7e8:	91 0e       	st.w	r8[0x0],lr
8000b7ea:	94 86       	ld.uh	r6,r10[0x0]
8000b7ec:	58 06       	cp.w	r6,0
8000b7ee:	c1 d0       	breq	8000b828 <__multiply+0xe0>
8000b7f0:	72 02       	ld.w	r2,r9[0x0]
8000b7f2:	12 98       	mov	r8,r9
8000b7f4:	16 9e       	mov	lr,r11
8000b7f6:	30 05       	mov	r5,0
8000b7f8:	b0 12       	st.h	r8[0x2],r2
8000b7fa:	1d 01       	ld.w	r1,lr++
8000b7fc:	90 82       	ld.uh	r2,r8[0x0]
8000b7fe:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b802:	ad 30       	mul	r0,r6
8000b804:	e0 02 00 02 	add	r2,r0,r2
8000b808:	e4 05 00 05 	add	r5,r2,r5
8000b80c:	b0 05       	st.h	r8[0x0],r5
8000b80e:	b1 85       	lsr	r5,0x10
8000b810:	b1 81       	lsr	r1,0x10
8000b812:	2f c8       	sub	r8,-4
8000b814:	ad 31       	mul	r1,r6
8000b816:	90 92       	ld.uh	r2,r8[0x2]
8000b818:	e2 02 00 02 	add	r2,r1,r2
8000b81c:	0a 02       	add	r2,r5
8000b81e:	e4 05 16 10 	lsr	r5,r2,0x10
8000b822:	06 3e       	cp.w	lr,r3
8000b824:	ce a3       	brcs	8000b7f8 <__multiply+0xb0>
8000b826:	91 02       	st.w	r8[0x0],r2
8000b828:	2f ca       	sub	r10,-4
8000b82a:	2f c9       	sub	r9,-4
8000b82c:	40 18       	lddsp	r8,sp[0x4]
8000b82e:	10 3a       	cp.w	r10,r8
8000b830:	cb b3       	brcs	8000b7a6 <__multiply+0x5e>
8000b832:	c0 28       	rjmp	8000b836 <__multiply+0xee>
8000b834:	20 17       	sub	r7,1
8000b836:	58 07       	cp.w	r7,0
8000b838:	e0 8a 00 05 	brle	8000b842 <__multiply+0xfa>
8000b83c:	09 48       	ld.w	r8,--r4
8000b83e:	58 08       	cp.w	r8,0
8000b840:	cf a0       	breq	8000b834 <__multiply+0xec>
8000b842:	99 47       	st.w	r12[0x10],r7
8000b844:	2f ed       	sub	sp,-8
8000b846:	d8 32       	popm	r0-r7,pc

8000b848 <__i2b>:
8000b848:	d4 21       	pushm	r4-r7,lr
8000b84a:	16 97       	mov	r7,r11
8000b84c:	30 1b       	mov	r11,1
8000b84e:	c4 9e       	rcall	8000b4e0 <_Balloc>
8000b850:	30 19       	mov	r9,1
8000b852:	99 57       	st.w	r12[0x14],r7
8000b854:	99 49       	st.w	r12[0x10],r9
8000b856:	d8 22       	popm	r4-r7,pc

8000b858 <__multadd>:
8000b858:	d4 31       	pushm	r0-r7,lr
8000b85a:	30 08       	mov	r8,0
8000b85c:	12 95       	mov	r5,r9
8000b85e:	16 97       	mov	r7,r11
8000b860:	18 96       	mov	r6,r12
8000b862:	76 44       	ld.w	r4,r11[0x10]
8000b864:	f6 c9 ff ec 	sub	r9,r11,-20
8000b868:	72 0b       	ld.w	r11,r9[0x0]
8000b86a:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b86e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b872:	f4 0c 02 4c 	mul	r12,r10,r12
8000b876:	f4 0b 03 45 	mac	r5,r10,r11
8000b87a:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b87e:	b1 85       	lsr	r5,0x10
8000b880:	18 05       	add	r5,r12
8000b882:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b886:	f8 0b 00 0b 	add	r11,r12,r11
8000b88a:	12 ab       	st.w	r9++,r11
8000b88c:	2f f8       	sub	r8,-1
8000b88e:	b1 85       	lsr	r5,0x10
8000b890:	08 38       	cp.w	r8,r4
8000b892:	ce b5       	brlt	8000b868 <__multadd+0x10>
8000b894:	58 05       	cp.w	r5,0
8000b896:	c1 c0       	breq	8000b8ce <__multadd+0x76>
8000b898:	6e 28       	ld.w	r8,r7[0x8]
8000b89a:	10 34       	cp.w	r4,r8
8000b89c:	c1 35       	brlt	8000b8c2 <__multadd+0x6a>
8000b89e:	6e 1b       	ld.w	r11,r7[0x4]
8000b8a0:	0c 9c       	mov	r12,r6
8000b8a2:	2f fb       	sub	r11,-1
8000b8a4:	c1 ee       	rcall	8000b4e0 <_Balloc>
8000b8a6:	6e 4a       	ld.w	r10,r7[0x10]
8000b8a8:	ee cb ff f4 	sub	r11,r7,-12
8000b8ac:	18 93       	mov	r3,r12
8000b8ae:	2f ea       	sub	r10,-2
8000b8b0:	2f 4c       	sub	r12,-12
8000b8b2:	a3 6a       	lsl	r10,0x2
8000b8b4:	fe b0 de 70 	rcall	80007594 <memcpy>
8000b8b8:	0e 9b       	mov	r11,r7
8000b8ba:	0c 9c       	mov	r12,r6
8000b8bc:	fe b0 fd f8 	rcall	8000b4ac <_Bfree>
8000b8c0:	06 97       	mov	r7,r3
8000b8c2:	e8 c8 ff ff 	sub	r8,r4,-1
8000b8c6:	2f b4       	sub	r4,-5
8000b8c8:	8f 48       	st.w	r7[0x10],r8
8000b8ca:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b8ce:	0e 9c       	mov	r12,r7
8000b8d0:	d8 32       	popm	r0-r7,pc
8000b8d2:	d7 03       	nop

8000b8d4 <__pow5mult>:
8000b8d4:	d4 31       	pushm	r0-r7,lr
8000b8d6:	14 96       	mov	r6,r10
8000b8d8:	18 97       	mov	r7,r12
8000b8da:	16 94       	mov	r4,r11
8000b8dc:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b8e0:	c0 90       	breq	8000b8f2 <__pow5mult+0x1e>
8000b8e2:	20 18       	sub	r8,1
8000b8e4:	fe c9 da 40 	sub	r9,pc,-9664
8000b8e8:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b8ec:	30 09       	mov	r9,0
8000b8ee:	cb 5f       	rcall	8000b858 <__multadd>
8000b8f0:	18 94       	mov	r4,r12
8000b8f2:	a3 46       	asr	r6,0x2
8000b8f4:	c3 40       	breq	8000b95c <__pow5mult+0x88>
8000b8f6:	6e 95       	ld.w	r5,r7[0x24]
8000b8f8:	58 05       	cp.w	r5,0
8000b8fa:	c0 91       	brne	8000b90c <__pow5mult+0x38>
8000b8fc:	31 0c       	mov	r12,16
8000b8fe:	fe b0 dc 27 	rcall	8000714c <malloc>
8000b902:	99 35       	st.w	r12[0xc],r5
8000b904:	8f 9c       	st.w	r7[0x24],r12
8000b906:	99 15       	st.w	r12[0x4],r5
8000b908:	99 25       	st.w	r12[0x8],r5
8000b90a:	99 05       	st.w	r12[0x0],r5
8000b90c:	6e 93       	ld.w	r3,r7[0x24]
8000b90e:	66 25       	ld.w	r5,r3[0x8]
8000b910:	58 05       	cp.w	r5,0
8000b912:	c0 c1       	brne	8000b92a <__pow5mult+0x56>
8000b914:	e0 6b 02 71 	mov	r11,625
8000b918:	0e 9c       	mov	r12,r7
8000b91a:	c9 7f       	rcall	8000b848 <__i2b>
8000b91c:	87 2c       	st.w	r3[0x8],r12
8000b91e:	30 08       	mov	r8,0
8000b920:	18 95       	mov	r5,r12
8000b922:	99 08       	st.w	r12[0x0],r8
8000b924:	c0 38       	rjmp	8000b92a <__pow5mult+0x56>
8000b926:	06 9c       	mov	r12,r3
8000b928:	18 95       	mov	r5,r12
8000b92a:	ed b6 00 00 	bld	r6,0x0
8000b92e:	c0 b1       	brne	8000b944 <__pow5mult+0x70>
8000b930:	08 9b       	mov	r11,r4
8000b932:	0a 9a       	mov	r10,r5
8000b934:	0e 9c       	mov	r12,r7
8000b936:	c0 9f       	rcall	8000b748 <__multiply>
8000b938:	08 9b       	mov	r11,r4
8000b93a:	18 93       	mov	r3,r12
8000b93c:	0e 9c       	mov	r12,r7
8000b93e:	06 94       	mov	r4,r3
8000b940:	fe b0 fd b6 	rcall	8000b4ac <_Bfree>
8000b944:	a1 56       	asr	r6,0x1
8000b946:	c0 b0       	breq	8000b95c <__pow5mult+0x88>
8000b948:	6a 03       	ld.w	r3,r5[0x0]
8000b94a:	58 03       	cp.w	r3,0
8000b94c:	ce d1       	brne	8000b926 <__pow5mult+0x52>
8000b94e:	0a 9a       	mov	r10,r5
8000b950:	0a 9b       	mov	r11,r5
8000b952:	0e 9c       	mov	r12,r7
8000b954:	cf ae       	rcall	8000b748 <__multiply>
8000b956:	8b 0c       	st.w	r5[0x0],r12
8000b958:	99 03       	st.w	r12[0x0],r3
8000b95a:	ce 7b       	rjmp	8000b928 <__pow5mult+0x54>
8000b95c:	08 9c       	mov	r12,r4
8000b95e:	d8 32       	popm	r0-r7,pc

8000b960 <__isinfd>:
8000b960:	14 98       	mov	r8,r10
8000b962:	fc 19 7f f0 	movh	r9,0x7ff0
8000b966:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b96a:	f0 0b 11 00 	rsub	r11,r8,0
8000b96e:	f7 e8 10 08 	or	r8,r11,r8
8000b972:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000b976:	f2 08 01 08 	sub	r8,r9,r8
8000b97a:	f0 0c 11 00 	rsub	r12,r8,0
8000b97e:	f9 e8 10 08 	or	r8,r12,r8
8000b982:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000b986:	2f fc       	sub	r12,-1
8000b988:	5e fc       	retal	r12

8000b98a <__isnand>:
8000b98a:	14 98       	mov	r8,r10
8000b98c:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b990:	f0 0c 11 00 	rsub	r12,r8,0
8000b994:	10 4c       	or	r12,r8
8000b996:	fc 18 7f f0 	movh	r8,0x7ff0
8000b99a:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000b99e:	f0 0c 01 0c 	sub	r12,r8,r12
8000b9a2:	bf 9c       	lsr	r12,0x1f
8000b9a4:	5e fc       	retal	r12
8000b9a6:	d7 03       	nop

8000b9a8 <__sclose>:
8000b9a8:	d4 01       	pushm	lr
8000b9aa:	96 7b       	ld.sh	r11,r11[0xe]
8000b9ac:	c8 2c       	rcall	8000bab0 <_close_r>
8000b9ae:	d8 02       	popm	pc

8000b9b0 <__sseek>:
8000b9b0:	d4 21       	pushm	r4-r7,lr
8000b9b2:	16 97       	mov	r7,r11
8000b9b4:	96 7b       	ld.sh	r11,r11[0xe]
8000b9b6:	c0 3d       	rcall	8000bbbc <_lseek_r>
8000b9b8:	8e 68       	ld.sh	r8,r7[0xc]
8000b9ba:	10 99       	mov	r9,r8
8000b9bc:	ad c8       	cbr	r8,0xc
8000b9be:	ad a9       	sbr	r9,0xc
8000b9c0:	5b fc       	cp.w	r12,-1
8000b9c2:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000b9c6:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000b9ca:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000b9ce:	d8 22       	popm	r4-r7,pc

8000b9d0 <__swrite>:
8000b9d0:	d4 21       	pushm	r4-r7,lr
8000b9d2:	96 68       	ld.sh	r8,r11[0xc]
8000b9d4:	16 97       	mov	r7,r11
8000b9d6:	14 95       	mov	r5,r10
8000b9d8:	12 94       	mov	r4,r9
8000b9da:	e2 18 01 00 	andl	r8,0x100,COH
8000b9de:	18 96       	mov	r6,r12
8000b9e0:	c0 50       	breq	8000b9ea <__swrite+0x1a>
8000b9e2:	30 29       	mov	r9,2
8000b9e4:	30 0a       	mov	r10,0
8000b9e6:	96 7b       	ld.sh	r11,r11[0xe]
8000b9e8:	ce ac       	rcall	8000bbbc <_lseek_r>
8000b9ea:	8e 68       	ld.sh	r8,r7[0xc]
8000b9ec:	ad c8       	cbr	r8,0xc
8000b9ee:	08 99       	mov	r9,r4
8000b9f0:	0a 9a       	mov	r10,r5
8000b9f2:	8e 7b       	ld.sh	r11,r7[0xe]
8000b9f4:	0c 9c       	mov	r12,r6
8000b9f6:	ae 68       	st.h	r7[0xc],r8
8000b9f8:	c1 cc       	rcall	8000ba30 <_write_r>
8000b9fa:	d8 22       	popm	r4-r7,pc

8000b9fc <__sread>:
8000b9fc:	d4 21       	pushm	r4-r7,lr
8000b9fe:	16 97       	mov	r7,r11
8000ba00:	96 7b       	ld.sh	r11,r11[0xe]
8000ba02:	cf 1c       	rcall	8000bbe4 <_read_r>
8000ba04:	c0 65       	brlt	8000ba10 <__sread+0x14>
8000ba06:	6f 58       	ld.w	r8,r7[0x54]
8000ba08:	18 08       	add	r8,r12
8000ba0a:	ef 48 00 54 	st.w	r7[84],r8
8000ba0e:	d8 22       	popm	r4-r7,pc
8000ba10:	8e 68       	ld.sh	r8,r7[0xc]
8000ba12:	ad c8       	cbr	r8,0xc
8000ba14:	ae 68       	st.h	r7[0xc],r8
8000ba16:	d8 22       	popm	r4-r7,pc

8000ba18 <strlen>:
8000ba18:	30 09       	mov	r9,0
8000ba1a:	18 98       	mov	r8,r12
8000ba1c:	c0 28       	rjmp	8000ba20 <strlen+0x8>
8000ba1e:	2f f8       	sub	r8,-1
8000ba20:	11 8a       	ld.ub	r10,r8[0x0]
8000ba22:	f2 0a 18 00 	cp.b	r10,r9
8000ba26:	cf c1       	brne	8000ba1e <strlen+0x6>
8000ba28:	f0 0c 01 0c 	sub	r12,r8,r12
8000ba2c:	5e fc       	retal	r12
8000ba2e:	d7 03       	nop

8000ba30 <_write_r>:
8000ba30:	d4 21       	pushm	r4-r7,lr
8000ba32:	16 98       	mov	r8,r11
8000ba34:	18 97       	mov	r7,r12
8000ba36:	10 9c       	mov	r12,r8
8000ba38:	30 08       	mov	r8,0
8000ba3a:	14 9b       	mov	r11,r10
8000ba3c:	e0 66 51 24 	mov	r6,20772
8000ba40:	12 9a       	mov	r10,r9
8000ba42:	8d 08       	st.w	r6[0x0],r8
8000ba44:	fe b0 d1 9c 	rcall	80005d7c <_write>
8000ba48:	5b fc       	cp.w	r12,-1
8000ba4a:	c0 51       	brne	8000ba54 <_write_r+0x24>
8000ba4c:	6c 08       	ld.w	r8,r6[0x0]
8000ba4e:	58 08       	cp.w	r8,0
8000ba50:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ba54:	d8 22       	popm	r4-r7,pc
8000ba56:	d7 03       	nop

8000ba58 <_calloc_r>:
8000ba58:	d4 21       	pushm	r4-r7,lr
8000ba5a:	f4 0b 02 4b 	mul	r11,r10,r11
8000ba5e:	fe b0 db 7f 	rcall	8000715c <_malloc_r>
8000ba62:	18 97       	mov	r7,r12
8000ba64:	c2 30       	breq	8000baaa <_calloc_r+0x52>
8000ba66:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000ba6a:	e0 1a ff fc 	andl	r10,0xfffc
8000ba6e:	20 4a       	sub	r10,4
8000ba70:	e0 4a 00 24 	cp.w	r10,36
8000ba74:	e0 8b 00 18 	brhi	8000baa4 <_calloc_r+0x4c>
8000ba78:	18 98       	mov	r8,r12
8000ba7a:	59 3a       	cp.w	r10,19
8000ba7c:	e0 88 00 0f 	brls	8000ba9a <_calloc_r+0x42>
8000ba80:	30 09       	mov	r9,0
8000ba82:	10 a9       	st.w	r8++,r9
8000ba84:	10 a9       	st.w	r8++,r9
8000ba86:	59 ba       	cp.w	r10,27
8000ba88:	e0 88 00 09 	brls	8000ba9a <_calloc_r+0x42>
8000ba8c:	10 a9       	st.w	r8++,r9
8000ba8e:	10 a9       	st.w	r8++,r9
8000ba90:	e0 4a 00 24 	cp.w	r10,36
8000ba94:	c0 31       	brne	8000ba9a <_calloc_r+0x42>
8000ba96:	10 a9       	st.w	r8++,r9
8000ba98:	10 a9       	st.w	r8++,r9
8000ba9a:	30 09       	mov	r9,0
8000ba9c:	10 a9       	st.w	r8++,r9
8000ba9e:	91 19       	st.w	r8[0x4],r9
8000baa0:	91 09       	st.w	r8[0x0],r9
8000baa2:	c0 48       	rjmp	8000baaa <_calloc_r+0x52>
8000baa4:	30 0b       	mov	r11,0
8000baa6:	fe b0 de 1b 	rcall	800076dc <memset>
8000baaa:	0e 9c       	mov	r12,r7
8000baac:	d8 22       	popm	r4-r7,pc
8000baae:	d7 03       	nop

8000bab0 <_close_r>:
8000bab0:	d4 21       	pushm	r4-r7,lr
8000bab2:	30 08       	mov	r8,0
8000bab4:	18 97       	mov	r7,r12
8000bab6:	e0 66 51 24 	mov	r6,20772
8000baba:	16 9c       	mov	r12,r11
8000babc:	8d 08       	st.w	r6[0x0],r8
8000babe:	fe b0 df b5 	rcall	80007a28 <_close>
8000bac2:	5b fc       	cp.w	r12,-1
8000bac4:	c0 51       	brne	8000bace <_close_r+0x1e>
8000bac6:	6c 08       	ld.w	r8,r6[0x0]
8000bac8:	58 08       	cp.w	r8,0
8000baca:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bace:	d8 22       	popm	r4-r7,pc

8000bad0 <_fclose_r>:
8000bad0:	d4 21       	pushm	r4-r7,lr
8000bad2:	18 96       	mov	r6,r12
8000bad4:	16 97       	mov	r7,r11
8000bad6:	58 0b       	cp.w	r11,0
8000bad8:	c0 31       	brne	8000bade <_fclose_r+0xe>
8000bada:	16 95       	mov	r5,r11
8000badc:	c5 38       	rjmp	8000bb82 <_fclose_r+0xb2>
8000bade:	fe b0 f8 a9 	rcall	8000ac30 <__sfp_lock_acquire>
8000bae2:	58 06       	cp.w	r6,0
8000bae4:	c0 70       	breq	8000baf2 <_fclose_r+0x22>
8000bae6:	6c 68       	ld.w	r8,r6[0x18]
8000bae8:	58 08       	cp.w	r8,0
8000baea:	c0 41       	brne	8000baf2 <_fclose_r+0x22>
8000baec:	0c 9c       	mov	r12,r6
8000baee:	fe b0 f8 f3 	rcall	8000acd4 <__sinit>
8000baf2:	fe c8 dc f2 	sub	r8,pc,-8974
8000baf6:	10 37       	cp.w	r7,r8
8000baf8:	c0 31       	brne	8000bafe <_fclose_r+0x2e>
8000bafa:	6c 07       	ld.w	r7,r6[0x0]
8000bafc:	c0 c8       	rjmp	8000bb14 <_fclose_r+0x44>
8000bafe:	fe c8 dc de 	sub	r8,pc,-8994
8000bb02:	10 37       	cp.w	r7,r8
8000bb04:	c0 31       	brne	8000bb0a <_fclose_r+0x3a>
8000bb06:	6c 17       	ld.w	r7,r6[0x4]
8000bb08:	c0 68       	rjmp	8000bb14 <_fclose_r+0x44>
8000bb0a:	fe c8 dc ca 	sub	r8,pc,-9014
8000bb0e:	10 37       	cp.w	r7,r8
8000bb10:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000bb14:	8e 69       	ld.sh	r9,r7[0xc]
8000bb16:	30 08       	mov	r8,0
8000bb18:	f0 09 19 00 	cp.h	r9,r8
8000bb1c:	c0 51       	brne	8000bb26 <_fclose_r+0x56>
8000bb1e:	fe b0 f8 8a 	rcall	8000ac32 <__sfp_lock_release>
8000bb22:	30 05       	mov	r5,0
8000bb24:	c2 f8       	rjmp	8000bb82 <_fclose_r+0xb2>
8000bb26:	0e 9b       	mov	r11,r7
8000bb28:	0c 9c       	mov	r12,r6
8000bb2a:	fe b0 f7 fd 	rcall	8000ab24 <_fflush_r>
8000bb2e:	6e c8       	ld.w	r8,r7[0x30]
8000bb30:	18 95       	mov	r5,r12
8000bb32:	58 08       	cp.w	r8,0
8000bb34:	c0 60       	breq	8000bb40 <_fclose_r+0x70>
8000bb36:	6e 8b       	ld.w	r11,r7[0x20]
8000bb38:	0c 9c       	mov	r12,r6
8000bb3a:	5d 18       	icall	r8
8000bb3c:	f9 b5 05 ff 	movlt	r5,-1
8000bb40:	8e 68       	ld.sh	r8,r7[0xc]
8000bb42:	ed b8 00 07 	bld	r8,0x7
8000bb46:	c0 51       	brne	8000bb50 <_fclose_r+0x80>
8000bb48:	6e 4b       	ld.w	r11,r7[0x10]
8000bb4a:	0c 9c       	mov	r12,r6
8000bb4c:	fe b0 f9 5e 	rcall	8000ae08 <_free_r>
8000bb50:	6e db       	ld.w	r11,r7[0x34]
8000bb52:	58 0b       	cp.w	r11,0
8000bb54:	c0 a0       	breq	8000bb68 <_fclose_r+0x98>
8000bb56:	ee c8 ff bc 	sub	r8,r7,-68
8000bb5a:	10 3b       	cp.w	r11,r8
8000bb5c:	c0 40       	breq	8000bb64 <_fclose_r+0x94>
8000bb5e:	0c 9c       	mov	r12,r6
8000bb60:	fe b0 f9 54 	rcall	8000ae08 <_free_r>
8000bb64:	30 08       	mov	r8,0
8000bb66:	8f d8       	st.w	r7[0x34],r8
8000bb68:	6f 2b       	ld.w	r11,r7[0x48]
8000bb6a:	58 0b       	cp.w	r11,0
8000bb6c:	c0 70       	breq	8000bb7a <_fclose_r+0xaa>
8000bb6e:	0c 9c       	mov	r12,r6
8000bb70:	fe b0 f9 4c 	rcall	8000ae08 <_free_r>
8000bb74:	30 08       	mov	r8,0
8000bb76:	ef 48 00 48 	st.w	r7[72],r8
8000bb7a:	30 08       	mov	r8,0
8000bb7c:	ae 68       	st.h	r7[0xc],r8
8000bb7e:	fe b0 f8 5a 	rcall	8000ac32 <__sfp_lock_release>
8000bb82:	0a 9c       	mov	r12,r5
8000bb84:	d8 22       	popm	r4-r7,pc
8000bb86:	d7 03       	nop

8000bb88 <fclose>:
8000bb88:	d4 01       	pushm	lr
8000bb8a:	e0 68 0a 3c 	mov	r8,2620
8000bb8e:	18 9b       	mov	r11,r12
8000bb90:	70 0c       	ld.w	r12,r8[0x0]
8000bb92:	c9 ff       	rcall	8000bad0 <_fclose_r>
8000bb94:	d8 02       	popm	pc
8000bb96:	d7 03       	nop

8000bb98 <_fstat_r>:
8000bb98:	d4 21       	pushm	r4-r7,lr
8000bb9a:	16 98       	mov	r8,r11
8000bb9c:	18 97       	mov	r7,r12
8000bb9e:	10 9c       	mov	r12,r8
8000bba0:	30 08       	mov	r8,0
8000bba2:	e0 66 51 24 	mov	r6,20772
8000bba6:	14 9b       	mov	r11,r10
8000bba8:	8d 08       	st.w	r6[0x0],r8
8000bbaa:	fe b0 df 67 	rcall	80007a78 <_fstat>
8000bbae:	5b fc       	cp.w	r12,-1
8000bbb0:	c0 51       	brne	8000bbba <_fstat_r+0x22>
8000bbb2:	6c 08       	ld.w	r8,r6[0x0]
8000bbb4:	58 08       	cp.w	r8,0
8000bbb6:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bbba:	d8 22       	popm	r4-r7,pc

8000bbbc <_lseek_r>:
8000bbbc:	d4 21       	pushm	r4-r7,lr
8000bbbe:	16 98       	mov	r8,r11
8000bbc0:	18 97       	mov	r7,r12
8000bbc2:	10 9c       	mov	r12,r8
8000bbc4:	30 08       	mov	r8,0
8000bbc6:	14 9b       	mov	r11,r10
8000bbc8:	e0 66 51 24 	mov	r6,20772
8000bbcc:	12 9a       	mov	r10,r9
8000bbce:	8d 08       	st.w	r6[0x0],r8
8000bbd0:	fe b0 df 36 	rcall	80007a3c <_lseek>
8000bbd4:	5b fc       	cp.w	r12,-1
8000bbd6:	c0 51       	brne	8000bbe0 <_lseek_r+0x24>
8000bbd8:	6c 08       	ld.w	r8,r6[0x0]
8000bbda:	58 08       	cp.w	r8,0
8000bbdc:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bbe0:	d8 22       	popm	r4-r7,pc
8000bbe2:	d7 03       	nop

8000bbe4 <_read_r>:
8000bbe4:	d4 21       	pushm	r4-r7,lr
8000bbe6:	16 98       	mov	r8,r11
8000bbe8:	18 97       	mov	r7,r12
8000bbea:	10 9c       	mov	r12,r8
8000bbec:	30 08       	mov	r8,0
8000bbee:	14 9b       	mov	r11,r10
8000bbf0:	e0 66 51 24 	mov	r6,20772
8000bbf4:	12 9a       	mov	r10,r9
8000bbf6:	8d 08       	st.w	r6[0x0],r8
8000bbf8:	fe b0 d0 a2 	rcall	80005d3c <_read>
8000bbfc:	5b fc       	cp.w	r12,-1
8000bbfe:	c0 51       	brne	8000bc08 <_read_r+0x24>
8000bc00:	6c 08       	ld.w	r8,r6[0x0]
8000bc02:	58 08       	cp.w	r8,0
8000bc04:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bc08:	d8 22       	popm	r4-r7,pc
8000bc0a:	d7 03       	nop

8000bc0c <__avr32_f64_mul>:
8000bc0c:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000bc10:	e0 80 00 dc 	breq	8000bdc8 <__avr32_f64_mul_op1_zero>
8000bc14:	d4 21       	pushm	r4-r7,lr
8000bc16:	f7 e9 20 0e 	eor	lr,r11,r9
8000bc1a:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bc1e:	30 15       	mov	r5,1
8000bc20:	c4 30       	breq	8000bca6 <__avr32_f64_mul_op1_subnormal>
8000bc22:	ab 6b       	lsl	r11,0xa
8000bc24:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000bc28:	ab 6a       	lsl	r10,0xa
8000bc2a:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000bc2e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bc32:	c5 c0       	breq	8000bcea <__avr32_f64_mul_op2_subnormal>
8000bc34:	a1 78       	lsl	r8,0x1
8000bc36:	5c f9       	rol	r9
8000bc38:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000bc3c:	e0 47 07 ff 	cp.w	r7,2047
8000bc40:	c7 70       	breq	8000bd2e <__avr32_f64_mul_op_nan_or_inf>
8000bc42:	e0 46 07 ff 	cp.w	r6,2047
8000bc46:	c7 40       	breq	8000bd2e <__avr32_f64_mul_op_nan_or_inf>
8000bc48:	ee 06 00 0c 	add	r12,r7,r6
8000bc4c:	e0 2c 03 fe 	sub	r12,1022
8000bc50:	f6 08 06 44 	mulu.d	r4,r11,r8
8000bc54:	f4 09 07 44 	macu.d	r4,r10,r9
8000bc58:	f4 08 06 46 	mulu.d	r6,r10,r8
8000bc5c:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000bc60:	08 07       	add	r7,r4
8000bc62:	f4 05 00 4a 	adc	r10,r10,r5
8000bc66:	5c 0b       	acr	r11
8000bc68:	ed bb 00 14 	bld	r11,0x14
8000bc6c:	c0 50       	breq	8000bc76 <__avr32_f64_mul+0x6a>
8000bc6e:	a1 77       	lsl	r7,0x1
8000bc70:	5c fa       	rol	r10
8000bc72:	5c fb       	rol	r11
8000bc74:	20 1c       	sub	r12,1
8000bc76:	58 0c       	cp.w	r12,0
8000bc78:	e0 8a 00 6f 	brle	8000bd56 <__avr32_f64_mul_res_subnormal>
8000bc7c:	e0 4c 07 ff 	cp.w	r12,2047
8000bc80:	e0 84 00 9c 	brge	8000bdb8 <__avr32_f64_mul_res_inf>
8000bc84:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000bc88:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000bc8c:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000bc90:	ee 17 80 00 	eorh	r7,0x8000
8000bc94:	f1 b7 04 20 	satu	r7,0x1
8000bc98:	0e 0a       	add	r10,r7
8000bc9a:	5c 0b       	acr	r11
8000bc9c:	ed be 00 1f 	bld	lr,0x1f
8000bca0:	ef bb 00 1f 	bst	r11,0x1f
8000bca4:	d8 22       	popm	r4-r7,pc

8000bca6 <__avr32_f64_mul_op1_subnormal>:
8000bca6:	e4 1b 00 0f 	andh	r11,0xf
8000bcaa:	f4 0c 12 00 	clz	r12,r10
8000bcae:	f6 06 12 00 	clz	r6,r11
8000bcb2:	f7 bc 03 e1 	sublo	r12,-31
8000bcb6:	f8 06 17 30 	movlo	r6,r12
8000bcba:	f7 b6 02 01 	subhs	r6,1
8000bcbe:	e0 46 00 20 	cp.w	r6,32
8000bcc2:	c0 d4       	brge	8000bcdc <__avr32_f64_mul_op1_subnormal+0x36>
8000bcc4:	ec 0c 11 20 	rsub	r12,r6,32
8000bcc8:	f6 06 09 4b 	lsl	r11,r11,r6
8000bccc:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000bcd0:	18 4b       	or	r11,r12
8000bcd2:	f4 06 09 4a 	lsl	r10,r10,r6
8000bcd6:	20 b6       	sub	r6,11
8000bcd8:	0c 17       	sub	r7,r6
8000bcda:	ca ab       	rjmp	8000bc2e <__avr32_f64_mul+0x22>
8000bcdc:	f4 06 09 4b 	lsl	r11,r10,r6
8000bce0:	c6 40       	breq	8000bda8 <__avr32_f64_mul_res_zero>
8000bce2:	30 0a       	mov	r10,0
8000bce4:	20 b6       	sub	r6,11
8000bce6:	0c 17       	sub	r7,r6
8000bce8:	ca 3b       	rjmp	8000bc2e <__avr32_f64_mul+0x22>

8000bcea <__avr32_f64_mul_op2_subnormal>:
8000bcea:	e4 19 00 0f 	andh	r9,0xf
8000bcee:	f0 0c 12 00 	clz	r12,r8
8000bcf2:	f2 05 12 00 	clz	r5,r9
8000bcf6:	f7 bc 03 ea 	sublo	r12,-22
8000bcfa:	f8 05 17 30 	movlo	r5,r12
8000bcfe:	f7 b5 02 0a 	subhs	r5,10
8000bd02:	e0 45 00 20 	cp.w	r5,32
8000bd06:	c0 d4       	brge	8000bd20 <__avr32_f64_mul_op2_subnormal+0x36>
8000bd08:	ea 0c 11 20 	rsub	r12,r5,32
8000bd0c:	f2 05 09 49 	lsl	r9,r9,r5
8000bd10:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000bd14:	18 49       	or	r9,r12
8000bd16:	f0 05 09 48 	lsl	r8,r8,r5
8000bd1a:	20 25       	sub	r5,2
8000bd1c:	0a 16       	sub	r6,r5
8000bd1e:	c8 fb       	rjmp	8000bc3c <__avr32_f64_mul+0x30>
8000bd20:	f0 05 09 49 	lsl	r9,r8,r5
8000bd24:	c4 20       	breq	8000bda8 <__avr32_f64_mul_res_zero>
8000bd26:	30 08       	mov	r8,0
8000bd28:	20 25       	sub	r5,2
8000bd2a:	0a 16       	sub	r6,r5
8000bd2c:	c8 8b       	rjmp	8000bc3c <__avr32_f64_mul+0x30>

8000bd2e <__avr32_f64_mul_op_nan_or_inf>:
8000bd2e:	e4 19 00 0f 	andh	r9,0xf
8000bd32:	e4 1b 00 0f 	andh	r11,0xf
8000bd36:	14 4b       	or	r11,r10
8000bd38:	10 49       	or	r9,r8
8000bd3a:	e0 47 07 ff 	cp.w	r7,2047
8000bd3e:	c0 91       	brne	8000bd50 <__avr32_f64_mul_op1_not_naninf>
8000bd40:	58 0b       	cp.w	r11,0
8000bd42:	c3 81       	brne	8000bdb2 <__avr32_f64_mul_res_nan>
8000bd44:	e0 46 07 ff 	cp.w	r6,2047
8000bd48:	c3 81       	brne	8000bdb8 <__avr32_f64_mul_res_inf>
8000bd4a:	58 09       	cp.w	r9,0
8000bd4c:	c3 60       	breq	8000bdb8 <__avr32_f64_mul_res_inf>
8000bd4e:	c3 28       	rjmp	8000bdb2 <__avr32_f64_mul_res_nan>

8000bd50 <__avr32_f64_mul_op1_not_naninf>:
8000bd50:	58 09       	cp.w	r9,0
8000bd52:	c3 30       	breq	8000bdb8 <__avr32_f64_mul_res_inf>
8000bd54:	c2 f8       	rjmp	8000bdb2 <__avr32_f64_mul_res_nan>

8000bd56 <__avr32_f64_mul_res_subnormal>:
8000bd56:	5c 3c       	neg	r12
8000bd58:	2f fc       	sub	r12,-1
8000bd5a:	f1 bc 04 c0 	satu	r12,0x6
8000bd5e:	e0 4c 00 20 	cp.w	r12,32
8000bd62:	c1 14       	brge	8000bd84 <__avr32_f64_mul_res_subnormal+0x2e>
8000bd64:	f8 08 11 20 	rsub	r8,r12,32
8000bd68:	0e 46       	or	r6,r7
8000bd6a:	ee 0c 0a 47 	lsr	r7,r7,r12
8000bd6e:	f4 08 09 49 	lsl	r9,r10,r8
8000bd72:	12 47       	or	r7,r9
8000bd74:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bd78:	f6 08 09 49 	lsl	r9,r11,r8
8000bd7c:	12 4a       	or	r10,r9
8000bd7e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bd82:	c8 3b       	rjmp	8000bc88 <__avr32_f64_mul+0x7c>
8000bd84:	f8 08 11 20 	rsub	r8,r12,32
8000bd88:	f9 b9 00 00 	moveq	r9,0
8000bd8c:	c0 30       	breq	8000bd92 <__avr32_f64_mul_res_subnormal+0x3c>
8000bd8e:	f6 08 09 49 	lsl	r9,r11,r8
8000bd92:	0e 46       	or	r6,r7
8000bd94:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000bd98:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bd9c:	f3 ea 10 07 	or	r7,r9,r10
8000bda0:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000bda4:	30 0b       	mov	r11,0
8000bda6:	c7 1b       	rjmp	8000bc88 <__avr32_f64_mul+0x7c>

8000bda8 <__avr32_f64_mul_res_zero>:
8000bda8:	1c 9b       	mov	r11,lr
8000bdaa:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bdae:	30 0a       	mov	r10,0
8000bdb0:	d8 22       	popm	r4-r7,pc

8000bdb2 <__avr32_f64_mul_res_nan>:
8000bdb2:	3f fb       	mov	r11,-1
8000bdb4:	3f fa       	mov	r10,-1
8000bdb6:	d8 22       	popm	r4-r7,pc

8000bdb8 <__avr32_f64_mul_res_inf>:
8000bdb8:	f0 6b 00 00 	mov	r11,-1048576
8000bdbc:	ed be 00 1f 	bld	lr,0x1f
8000bdc0:	ef bb 00 1f 	bst	r11,0x1f
8000bdc4:	30 0a       	mov	r10,0
8000bdc6:	d8 22       	popm	r4-r7,pc

8000bdc8 <__avr32_f64_mul_op1_zero>:
8000bdc8:	f7 e9 20 0b 	eor	r11,r11,r9
8000bdcc:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bdd0:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000bdd4:	e0 4c 07 ff 	cp.w	r12,2047
8000bdd8:	5e 1c       	retne	r12
8000bdda:	3f fa       	mov	r10,-1
8000bddc:	3f fb       	mov	r11,-1
8000bdde:	5e fc       	retal	r12

8000bde0 <__avr32_f64_sub_from_add>:
8000bde0:	ee 19 80 00 	eorh	r9,0x8000

8000bde4 <__avr32_f64_sub>:
8000bde4:	f7 e9 20 0c 	eor	r12,r11,r9
8000bde8:	e0 86 00 ca 	brmi	8000bf7c <__avr32_f64_add_from_sub>
8000bdec:	eb cd 40 e0 	pushm	r5-r7,lr
8000bdf0:	16 9c       	mov	r12,r11
8000bdf2:	e6 1c 80 00 	andh	r12,0x8000,COH
8000bdf6:	bf db       	cbr	r11,0x1f
8000bdf8:	bf d9       	cbr	r9,0x1f
8000bdfa:	10 3a       	cp.w	r10,r8
8000bdfc:	f2 0b 13 00 	cpc	r11,r9
8000be00:	c0 92       	brcc	8000be12 <__avr32_f64_sub+0x2e>
8000be02:	16 97       	mov	r7,r11
8000be04:	12 9b       	mov	r11,r9
8000be06:	0e 99       	mov	r9,r7
8000be08:	14 97       	mov	r7,r10
8000be0a:	10 9a       	mov	r10,r8
8000be0c:	0e 98       	mov	r8,r7
8000be0e:	ee 1c 80 00 	eorh	r12,0x8000
8000be12:	f6 07 16 14 	lsr	r7,r11,0x14
8000be16:	ab 7b       	lsl	r11,0xb
8000be18:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000be1c:	ab 7a       	lsl	r10,0xb
8000be1e:	bf bb       	sbr	r11,0x1f
8000be20:	f2 06 16 14 	lsr	r6,r9,0x14
8000be24:	c4 40       	breq	8000beac <__avr32_f64_sub_opL_subnormal>
8000be26:	ab 79       	lsl	r9,0xb
8000be28:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000be2c:	ab 78       	lsl	r8,0xb
8000be2e:	bf b9       	sbr	r9,0x1f

8000be30 <__avr32_f64_sub_opL_subnormal_done>:
8000be30:	e0 47 07 ff 	cp.w	r7,2047
8000be34:	c4 f0       	breq	8000bed2 <__avr32_f64_sub_opH_nan_or_inf>
8000be36:	0e 26       	rsub	r6,r7
8000be38:	c1 20       	breq	8000be5c <__avr32_f64_sub_shift_done>
8000be3a:	ec 05 11 20 	rsub	r5,r6,32
8000be3e:	e0 46 00 20 	cp.w	r6,32
8000be42:	c7 c2       	brcc	8000bf3a <__avr32_f64_sub_longshift>
8000be44:	f0 05 09 4e 	lsl	lr,r8,r5
8000be48:	f2 05 09 45 	lsl	r5,r9,r5
8000be4c:	f0 06 0a 48 	lsr	r8,r8,r6
8000be50:	f2 06 0a 49 	lsr	r9,r9,r6
8000be54:	0a 48       	or	r8,r5
8000be56:	58 0e       	cp.w	lr,0
8000be58:	5f 1e       	srne	lr
8000be5a:	1c 48       	or	r8,lr

8000be5c <__avr32_f64_sub_shift_done>:
8000be5c:	10 1a       	sub	r10,r8
8000be5e:	f6 09 01 4b 	sbc	r11,r11,r9
8000be62:	f6 06 12 00 	clz	r6,r11
8000be66:	c0 e0       	breq	8000be82 <__avr32_f64_sub_longnormalize_done>
8000be68:	c7 83       	brcs	8000bf58 <__avr32_f64_sub_longnormalize>
8000be6a:	ec 0e 11 20 	rsub	lr,r6,32
8000be6e:	f6 06 09 4b 	lsl	r11,r11,r6
8000be72:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000be76:	1c 4b       	or	r11,lr
8000be78:	f4 06 09 4a 	lsl	r10,r10,r6
8000be7c:	0c 17       	sub	r7,r6
8000be7e:	e0 8a 00 39 	brle	8000bef0 <__avr32_f64_sub_subnormal_result>

8000be82 <__avr32_f64_sub_longnormalize_done>:
8000be82:	f4 09 15 15 	lsl	r9,r10,0x15
8000be86:	ab 9a       	lsr	r10,0xb
8000be88:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000be8c:	ab 9b       	lsr	r11,0xb
8000be8e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000be92:	18 4b       	or	r11,r12

8000be94 <__avr32_f64_sub_round>:
8000be94:	fc 17 80 00 	movh	r7,0x8000
8000be98:	ed ba 00 00 	bld	r10,0x0
8000be9c:	f7 b7 01 ff 	subne	r7,-1
8000bea0:	0e 39       	cp.w	r9,r7
8000bea2:	5f 29       	srhs	r9
8000bea4:	12 0a       	add	r10,r9
8000bea6:	5c 0b       	acr	r11
8000bea8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000beac <__avr32_f64_sub_opL_subnormal>:
8000beac:	ab 79       	lsl	r9,0xb
8000beae:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000beb2:	ab 78       	lsl	r8,0xb
8000beb4:	f3 e8 10 0e 	or	lr,r9,r8
8000beb8:	f9 b6 01 01 	movne	r6,1
8000bebc:	ee 0e 11 00 	rsub	lr,r7,0
8000bec0:	f9 b7 00 01 	moveq	r7,1
8000bec4:	ef bb 00 1f 	bst	r11,0x1f
8000bec8:	f7 ea 10 0e 	or	lr,r11,r10
8000becc:	f9 b7 00 00 	moveq	r7,0
8000bed0:	cb 0b       	rjmp	8000be30 <__avr32_f64_sub_opL_subnormal_done>

8000bed2 <__avr32_f64_sub_opH_nan_or_inf>:
8000bed2:	bf db       	cbr	r11,0x1f
8000bed4:	f7 ea 10 0e 	or	lr,r11,r10
8000bed8:	c0 81       	brne	8000bee8 <__avr32_f64_sub_return_nan>
8000beda:	e0 46 07 ff 	cp.w	r6,2047
8000bede:	c0 50       	breq	8000bee8 <__avr32_f64_sub_return_nan>
8000bee0:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000bee4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bee8 <__avr32_f64_sub_return_nan>:
8000bee8:	3f fa       	mov	r10,-1
8000beea:	3f fb       	mov	r11,-1
8000beec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bef0 <__avr32_f64_sub_subnormal_result>:
8000bef0:	5c 37       	neg	r7
8000bef2:	2f f7       	sub	r7,-1
8000bef4:	f1 b7 04 c0 	satu	r7,0x6
8000bef8:	e0 47 00 20 	cp.w	r7,32
8000befc:	c1 14       	brge	8000bf1e <__avr32_f64_sub_subnormal_result+0x2e>
8000befe:	ee 08 11 20 	rsub	r8,r7,32
8000bf02:	f4 08 09 49 	lsl	r9,r10,r8
8000bf06:	5f 16       	srne	r6
8000bf08:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bf0c:	0c 4a       	or	r10,r6
8000bf0e:	f6 08 09 49 	lsl	r9,r11,r8
8000bf12:	f5 e9 10 0a 	or	r10,r10,r9
8000bf16:	f4 07 0a 4b 	lsr	r11,r10,r7
8000bf1a:	30 07       	mov	r7,0
8000bf1c:	cb 3b       	rjmp	8000be82 <__avr32_f64_sub_longnormalize_done>
8000bf1e:	ee 08 11 40 	rsub	r8,r7,64
8000bf22:	f6 08 09 49 	lsl	r9,r11,r8
8000bf26:	14 49       	or	r9,r10
8000bf28:	5f 16       	srne	r6
8000bf2a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000bf2e:	0c 4a       	or	r10,r6
8000bf30:	30 0b       	mov	r11,0
8000bf32:	30 07       	mov	r7,0
8000bf34:	ca 7b       	rjmp	8000be82 <__avr32_f64_sub_longnormalize_done>
8000bf36:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bf3a <__avr32_f64_sub_longshift>:
8000bf3a:	f1 b6 04 c0 	satu	r6,0x6
8000bf3e:	f0 0e 17 00 	moveq	lr,r8
8000bf42:	c0 40       	breq	8000bf4a <__avr32_f64_sub_longshift+0x10>
8000bf44:	f2 05 09 4e 	lsl	lr,r9,r5
8000bf48:	10 4e       	or	lr,r8
8000bf4a:	f2 06 0a 48 	lsr	r8,r9,r6
8000bf4e:	30 09       	mov	r9,0
8000bf50:	58 0e       	cp.w	lr,0
8000bf52:	5f 1e       	srne	lr
8000bf54:	1c 48       	or	r8,lr
8000bf56:	c8 3b       	rjmp	8000be5c <__avr32_f64_sub_shift_done>

8000bf58 <__avr32_f64_sub_longnormalize>:
8000bf58:	f4 06 12 00 	clz	r6,r10
8000bf5c:	f9 b7 03 00 	movlo	r7,0
8000bf60:	f9 b6 03 00 	movlo	r6,0
8000bf64:	f9 bc 03 00 	movlo	r12,0
8000bf68:	f7 b6 02 e0 	subhs	r6,-32
8000bf6c:	f4 06 09 4b 	lsl	r11,r10,r6
8000bf70:	30 0a       	mov	r10,0
8000bf72:	0c 17       	sub	r7,r6
8000bf74:	fe 9a ff be 	brle	8000bef0 <__avr32_f64_sub_subnormal_result>
8000bf78:	c8 5b       	rjmp	8000be82 <__avr32_f64_sub_longnormalize_done>
8000bf7a:	d7 03       	nop

8000bf7c <__avr32_f64_add_from_sub>:
8000bf7c:	ee 19 80 00 	eorh	r9,0x8000

8000bf80 <__avr32_f64_add>:
8000bf80:	f7 e9 20 0c 	eor	r12,r11,r9
8000bf84:	fe 96 ff 2e 	brmi	8000bde0 <__avr32_f64_sub_from_add>
8000bf88:	eb cd 40 e0 	pushm	r5-r7,lr
8000bf8c:	16 9c       	mov	r12,r11
8000bf8e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000bf92:	bf db       	cbr	r11,0x1f
8000bf94:	bf d9       	cbr	r9,0x1f
8000bf96:	12 3b       	cp.w	r11,r9
8000bf98:	c0 72       	brcc	8000bfa6 <__avr32_f64_add+0x26>
8000bf9a:	16 97       	mov	r7,r11
8000bf9c:	12 9b       	mov	r11,r9
8000bf9e:	0e 99       	mov	r9,r7
8000bfa0:	14 97       	mov	r7,r10
8000bfa2:	10 9a       	mov	r10,r8
8000bfa4:	0e 98       	mov	r8,r7
8000bfa6:	30 0e       	mov	lr,0
8000bfa8:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bfac:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000bfb0:	b5 ab       	sbr	r11,0x14
8000bfb2:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bfb6:	c6 20       	breq	8000c07a <__avr32_f64_add_op2_subnormal>
8000bfb8:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000bfbc:	b5 a9       	sbr	r9,0x14
8000bfbe:	e0 47 07 ff 	cp.w	r7,2047
8000bfc2:	c2 80       	breq	8000c012 <__avr32_f64_add_opH_nan_or_inf>
8000bfc4:	0e 26       	rsub	r6,r7
8000bfc6:	c1 20       	breq	8000bfea <__avr32_f64_add_shift_done>
8000bfc8:	e0 46 00 36 	cp.w	r6,54
8000bfcc:	c1 52       	brcc	8000bff6 <__avr32_f64_add_res_of_done>
8000bfce:	ec 05 11 20 	rsub	r5,r6,32
8000bfd2:	e0 46 00 20 	cp.w	r6,32
8000bfd6:	c3 52       	brcc	8000c040 <__avr32_f64_add_longshift>
8000bfd8:	f0 05 09 4e 	lsl	lr,r8,r5
8000bfdc:	f2 05 09 45 	lsl	r5,r9,r5
8000bfe0:	f0 06 0a 48 	lsr	r8,r8,r6
8000bfe4:	f2 06 0a 49 	lsr	r9,r9,r6
8000bfe8:	0a 48       	or	r8,r5

8000bfea <__avr32_f64_add_shift_done>:
8000bfea:	10 0a       	add	r10,r8
8000bfec:	f6 09 00 4b 	adc	r11,r11,r9
8000bff0:	ed bb 00 15 	bld	r11,0x15
8000bff4:	c3 40       	breq	8000c05c <__avr32_f64_add_res_of>

8000bff6 <__avr32_f64_add_res_of_done>:
8000bff6:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bffa:	18 4b       	or	r11,r12

8000bffc <__avr32_f64_add_round>:
8000bffc:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c000:	18 4e       	or	lr,r12
8000c002:	ee 1e 80 00 	eorh	lr,0x8000
8000c006:	f1 be 04 20 	satu	lr,0x1
8000c00a:	1c 0a       	add	r10,lr
8000c00c:	5c 0b       	acr	r11
8000c00e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c012 <__avr32_f64_add_opH_nan_or_inf>:
8000c012:	b5 cb       	cbr	r11,0x14
8000c014:	f7 ea 10 0e 	or	lr,r11,r10
8000c018:	c1 01       	brne	8000c038 <__avr32_f64_add_return_nan>
8000c01a:	e0 46 07 ff 	cp.w	r6,2047
8000c01e:	c0 30       	breq	8000c024 <__avr32_f64_add_opL_nan_or_inf>
8000c020:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c024 <__avr32_f64_add_opL_nan_or_inf>:
8000c024:	b5 c9       	cbr	r9,0x14
8000c026:	f3 e8 10 0e 	or	lr,r9,r8
8000c02a:	c0 71       	brne	8000c038 <__avr32_f64_add_return_nan>
8000c02c:	30 0a       	mov	r10,0
8000c02e:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c032:	18 4b       	or	r11,r12
8000c034:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c038 <__avr32_f64_add_return_nan>:
8000c038:	3f fa       	mov	r10,-1
8000c03a:	3f fb       	mov	r11,-1
8000c03c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c040 <__avr32_f64_add_longshift>:
8000c040:	f1 b6 04 c0 	satu	r6,0x6
8000c044:	f0 0e 17 00 	moveq	lr,r8
8000c048:	c0 60       	breq	8000c054 <__avr32_f64_add_longshift+0x14>
8000c04a:	f2 05 09 4e 	lsl	lr,r9,r5
8000c04e:	58 08       	cp.w	r8,0
8000c050:	5f 18       	srne	r8
8000c052:	10 4e       	or	lr,r8
8000c054:	f2 06 0a 48 	lsr	r8,r9,r6
8000c058:	30 09       	mov	r9,0
8000c05a:	cc 8b       	rjmp	8000bfea <__avr32_f64_add_shift_done>

8000c05c <__avr32_f64_add_res_of>:
8000c05c:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c060:	a1 9b       	lsr	r11,0x1
8000c062:	5d 0a       	ror	r10
8000c064:	5d 0e       	ror	lr
8000c066:	2f f7       	sub	r7,-1
8000c068:	e0 47 07 ff 	cp.w	r7,2047
8000c06c:	f9 ba 00 00 	moveq	r10,0
8000c070:	f9 bb 00 00 	moveq	r11,0
8000c074:	f9 be 00 00 	moveq	lr,0
8000c078:	cb fb       	rjmp	8000bff6 <__avr32_f64_add_res_of_done>

8000c07a <__avr32_f64_add_op2_subnormal>:
8000c07a:	30 16       	mov	r6,1
8000c07c:	58 07       	cp.w	r7,0
8000c07e:	ca 01       	brne	8000bfbe <__avr32_f64_add+0x3e>
8000c080:	b5 cb       	cbr	r11,0x14
8000c082:	10 0a       	add	r10,r8
8000c084:	f6 09 00 4b 	adc	r11,r11,r9
8000c088:	18 4b       	or	r11,r12
8000c08a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000c08e:	d7 03       	nop

8000c090 <__avr32_f64_to_u32>:
8000c090:	58 0b       	cp.w	r11,0
8000c092:	5e 6d       	retmi	0

8000c094 <__avr32_f64_to_s32>:
8000c094:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c098:	b5 9c       	lsr	r12,0x15
8000c09a:	e0 2c 03 ff 	sub	r12,1023
8000c09e:	5e 3d       	retlo	0
8000c0a0:	f8 0c 11 1f 	rsub	r12,r12,31
8000c0a4:	16 99       	mov	r9,r11
8000c0a6:	ab 7b       	lsl	r11,0xb
8000c0a8:	bf bb       	sbr	r11,0x1f
8000c0aa:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c0ae:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c0b2:	a1 79       	lsl	r9,0x1
8000c0b4:	5e 2b       	reths	r11
8000c0b6:	5c 3b       	neg	r11
8000c0b8:	5e fb       	retal	r11

8000c0ba <__avr32_u32_to_f64>:
8000c0ba:	f8 cb 00 00 	sub	r11,r12,0
8000c0be:	30 0c       	mov	r12,0
8000c0c0:	c0 38       	rjmp	8000c0c6 <__avr32_s32_to_f64+0x4>

8000c0c2 <__avr32_s32_to_f64>:
8000c0c2:	18 9b       	mov	r11,r12
8000c0c4:	5c 4b       	abs	r11
8000c0c6:	30 0a       	mov	r10,0
8000c0c8:	5e 0b       	reteq	r11
8000c0ca:	d4 01       	pushm	lr
8000c0cc:	e0 69 04 1e 	mov	r9,1054
8000c0d0:	f6 08 12 00 	clz	r8,r11
8000c0d4:	c1 70       	breq	8000c102 <__avr32_s32_to_f64+0x40>
8000c0d6:	c0 c3       	brcs	8000c0ee <__avr32_s32_to_f64+0x2c>
8000c0d8:	f0 0e 11 20 	rsub	lr,r8,32
8000c0dc:	f6 08 09 4b 	lsl	r11,r11,r8
8000c0e0:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c0e4:	1c 4b       	or	r11,lr
8000c0e6:	f4 08 09 4a 	lsl	r10,r10,r8
8000c0ea:	10 19       	sub	r9,r8
8000c0ec:	c0 b8       	rjmp	8000c102 <__avr32_s32_to_f64+0x40>
8000c0ee:	f4 08 12 00 	clz	r8,r10
8000c0f2:	f9 b8 03 00 	movlo	r8,0
8000c0f6:	f7 b8 02 e0 	subhs	r8,-32
8000c0fa:	f4 08 09 4b 	lsl	r11,r10,r8
8000c0fe:	30 0a       	mov	r10,0
8000c100:	10 19       	sub	r9,r8
8000c102:	58 09       	cp.w	r9,0
8000c104:	e0 89 00 30 	brgt	8000c164 <__avr32_s32_to_f64+0xa2>
8000c108:	5c 39       	neg	r9
8000c10a:	2f f9       	sub	r9,-1
8000c10c:	e0 49 00 36 	cp.w	r9,54
8000c110:	c0 43       	brcs	8000c118 <__avr32_s32_to_f64+0x56>
8000c112:	30 0b       	mov	r11,0
8000c114:	30 0a       	mov	r10,0
8000c116:	c2 68       	rjmp	8000c162 <__avr32_s32_to_f64+0xa0>
8000c118:	2f 69       	sub	r9,-10
8000c11a:	f2 08 11 20 	rsub	r8,r9,32
8000c11e:	e0 49 00 20 	cp.w	r9,32
8000c122:	c0 b2       	brcc	8000c138 <__avr32_s32_to_f64+0x76>
8000c124:	f4 08 09 4e 	lsl	lr,r10,r8
8000c128:	f6 08 09 48 	lsl	r8,r11,r8
8000c12c:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c130:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c134:	10 4b       	or	r11,r8
8000c136:	c0 88       	rjmp	8000c146 <__avr32_s32_to_f64+0x84>
8000c138:	f6 08 09 4e 	lsl	lr,r11,r8
8000c13c:	14 4e       	or	lr,r10
8000c13e:	16 9a       	mov	r10,r11
8000c140:	30 0b       	mov	r11,0
8000c142:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c146:	ed ba 00 00 	bld	r10,0x0
8000c14a:	c0 92       	brcc	8000c15c <__avr32_s32_to_f64+0x9a>
8000c14c:	1c 7e       	tst	lr,lr
8000c14e:	c0 41       	brne	8000c156 <__avr32_s32_to_f64+0x94>
8000c150:	ed ba 00 01 	bld	r10,0x1
8000c154:	c0 42       	brcc	8000c15c <__avr32_s32_to_f64+0x9a>
8000c156:	2f fa       	sub	r10,-1
8000c158:	f7 bb 02 ff 	subhs	r11,-1
8000c15c:	5c fc       	rol	r12
8000c15e:	5d 0b       	ror	r11
8000c160:	5d 0a       	ror	r10
8000c162:	d8 02       	popm	pc
8000c164:	e0 68 03 ff 	mov	r8,1023
8000c168:	ed ba 00 0b 	bld	r10,0xb
8000c16c:	f7 b8 00 ff 	subeq	r8,-1
8000c170:	10 0a       	add	r10,r8
8000c172:	5c 0b       	acr	r11
8000c174:	f7 b9 03 fe 	sublo	r9,-2
8000c178:	e0 49 07 ff 	cp.w	r9,2047
8000c17c:	c0 55       	brlt	8000c186 <__avr32_s32_to_f64+0xc4>
8000c17e:	30 0a       	mov	r10,0
8000c180:	fc 1b ff e0 	movh	r11,0xffe0
8000c184:	c0 c8       	rjmp	8000c19c <__floatsidf_return_op1>
8000c186:	ed bb 00 1f 	bld	r11,0x1f
8000c18a:	f7 b9 01 01 	subne	r9,1
8000c18e:	ab 9a       	lsr	r10,0xb
8000c190:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c194:	a1 7b       	lsl	r11,0x1
8000c196:	ab 9b       	lsr	r11,0xb
8000c198:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c19c <__floatsidf_return_op1>:
8000c19c:	a1 7c       	lsl	r12,0x1
8000c19e:	5d 0b       	ror	r11
8000c1a0:	d8 02       	popm	pc

8000c1a2 <__avr32_f64_cmp_eq>:
8000c1a2:	10 3a       	cp.w	r10,r8
8000c1a4:	f2 0b 13 00 	cpc	r11,r9
8000c1a8:	c0 80       	breq	8000c1b8 <__avr32_f64_cmp_eq+0x16>
8000c1aa:	a1 7b       	lsl	r11,0x1
8000c1ac:	a1 79       	lsl	r9,0x1
8000c1ae:	14 4b       	or	r11,r10
8000c1b0:	12 4b       	or	r11,r9
8000c1b2:	10 4b       	or	r11,r8
8000c1b4:	5e 0f       	reteq	1
8000c1b6:	5e fd       	retal	0
8000c1b8:	a1 7b       	lsl	r11,0x1
8000c1ba:	fc 1c ff e0 	movh	r12,0xffe0
8000c1be:	58 0a       	cp.w	r10,0
8000c1c0:	f8 0b 13 00 	cpc	r11,r12
8000c1c4:	5e 8f       	retls	1
8000c1c6:	5e fd       	retal	0

8000c1c8 <__avr32_f64_cmp_ge>:
8000c1c8:	1a de       	st.w	--sp,lr
8000c1ca:	1a d7       	st.w	--sp,r7
8000c1cc:	a1 7b       	lsl	r11,0x1
8000c1ce:	5f 3c       	srlo	r12
8000c1d0:	a1 79       	lsl	r9,0x1
8000c1d2:	5f 37       	srlo	r7
8000c1d4:	5c fc       	rol	r12
8000c1d6:	fc 1e ff e0 	movh	lr,0xffe0
8000c1da:	58 0a       	cp.w	r10,0
8000c1dc:	fc 0b 13 00 	cpc	r11,lr
8000c1e0:	e0 8b 00 1d 	brhi	8000c21a <__avr32_f64_cmp_ge+0x52>
8000c1e4:	58 08       	cp.w	r8,0
8000c1e6:	fc 09 13 00 	cpc	r9,lr
8000c1ea:	e0 8b 00 18 	brhi	8000c21a <__avr32_f64_cmp_ge+0x52>
8000c1ee:	58 0b       	cp.w	r11,0
8000c1f0:	f5 ba 00 00 	subfeq	r10,0
8000c1f4:	c1 50       	breq	8000c21e <__avr32_f64_cmp_ge+0x56>
8000c1f6:	1b 07       	ld.w	r7,sp++
8000c1f8:	1b 0e       	ld.w	lr,sp++
8000c1fa:	58 3c       	cp.w	r12,3
8000c1fc:	c0 a0       	breq	8000c210 <__avr32_f64_cmp_ge+0x48>
8000c1fe:	58 1c       	cp.w	r12,1
8000c200:	c0 33       	brcs	8000c206 <__avr32_f64_cmp_ge+0x3e>
8000c202:	5e 0f       	reteq	1
8000c204:	5e 1d       	retne	0
8000c206:	10 3a       	cp.w	r10,r8
8000c208:	f2 0b 13 00 	cpc	r11,r9
8000c20c:	5e 2f       	reths	1
8000c20e:	5e 3d       	retlo	0
8000c210:	14 38       	cp.w	r8,r10
8000c212:	f6 09 13 00 	cpc	r9,r11
8000c216:	5e 2f       	reths	1
8000c218:	5e 3d       	retlo	0
8000c21a:	1b 07       	ld.w	r7,sp++
8000c21c:	d8 0a       	popm	pc,r12=0
8000c21e:	58 17       	cp.w	r7,1
8000c220:	5f 0c       	sreq	r12
8000c222:	58 09       	cp.w	r9,0
8000c224:	f5 b8 00 00 	subfeq	r8,0
8000c228:	1b 07       	ld.w	r7,sp++
8000c22a:	1b 0e       	ld.w	lr,sp++
8000c22c:	5e 0f       	reteq	1
8000c22e:	5e fc       	retal	r12

8000c230 <__avr32_f64_cmp_lt>:
8000c230:	1a de       	st.w	--sp,lr
8000c232:	1a d7       	st.w	--sp,r7
8000c234:	a1 7b       	lsl	r11,0x1
8000c236:	5f 3c       	srlo	r12
8000c238:	a1 79       	lsl	r9,0x1
8000c23a:	5f 37       	srlo	r7
8000c23c:	5c fc       	rol	r12
8000c23e:	fc 1e ff e0 	movh	lr,0xffe0
8000c242:	58 0a       	cp.w	r10,0
8000c244:	fc 0b 13 00 	cpc	r11,lr
8000c248:	e0 8b 00 1d 	brhi	8000c282 <__avr32_f64_cmp_lt+0x52>
8000c24c:	58 08       	cp.w	r8,0
8000c24e:	fc 09 13 00 	cpc	r9,lr
8000c252:	e0 8b 00 18 	brhi	8000c282 <__avr32_f64_cmp_lt+0x52>
8000c256:	58 0b       	cp.w	r11,0
8000c258:	f5 ba 00 00 	subfeq	r10,0
8000c25c:	c1 50       	breq	8000c286 <__avr32_f64_cmp_lt+0x56>
8000c25e:	1b 07       	ld.w	r7,sp++
8000c260:	1b 0e       	ld.w	lr,sp++
8000c262:	58 3c       	cp.w	r12,3
8000c264:	c0 a0       	breq	8000c278 <__avr32_f64_cmp_lt+0x48>
8000c266:	58 1c       	cp.w	r12,1
8000c268:	c0 33       	brcs	8000c26e <__avr32_f64_cmp_lt+0x3e>
8000c26a:	5e 0d       	reteq	0
8000c26c:	5e 1f       	retne	1
8000c26e:	10 3a       	cp.w	r10,r8
8000c270:	f2 0b 13 00 	cpc	r11,r9
8000c274:	5e 2d       	reths	0
8000c276:	5e 3f       	retlo	1
8000c278:	14 38       	cp.w	r8,r10
8000c27a:	f6 09 13 00 	cpc	r9,r11
8000c27e:	5e 2d       	reths	0
8000c280:	5e 3f       	retlo	1
8000c282:	1b 07       	ld.w	r7,sp++
8000c284:	d8 0a       	popm	pc,r12=0
8000c286:	58 17       	cp.w	r7,1
8000c288:	5f 1c       	srne	r12
8000c28a:	58 09       	cp.w	r9,0
8000c28c:	f5 b8 00 00 	subfeq	r8,0
8000c290:	1b 07       	ld.w	r7,sp++
8000c292:	1b 0e       	ld.w	lr,sp++
8000c294:	5e 0d       	reteq	0
8000c296:	5e fc       	retal	r12

8000c298 <__avr32_f64_div>:
8000c298:	eb cd 40 ff 	pushm	r0-r7,lr
8000c29c:	f7 e9 20 0e 	eor	lr,r11,r9
8000c2a0:	f6 07 16 14 	lsr	r7,r11,0x14
8000c2a4:	a9 7b       	lsl	r11,0x9
8000c2a6:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c2aa:	a9 7a       	lsl	r10,0x9
8000c2ac:	bd bb       	sbr	r11,0x1d
8000c2ae:	e4 1b 3f ff 	andh	r11,0x3fff
8000c2b2:	ab d7       	cbr	r7,0xb
8000c2b4:	e0 80 00 cc 	breq	8000c44c <__avr32_f64_div_round_subnormal+0x54>
8000c2b8:	e0 47 07 ff 	cp.w	r7,2047
8000c2bc:	e0 84 00 b5 	brge	8000c426 <__avr32_f64_div_round_subnormal+0x2e>
8000c2c0:	f2 06 16 14 	lsr	r6,r9,0x14
8000c2c4:	a9 79       	lsl	r9,0x9
8000c2c6:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c2ca:	a9 78       	lsl	r8,0x9
8000c2cc:	bd b9       	sbr	r9,0x1d
8000c2ce:	e4 19 3f ff 	andh	r9,0x3fff
8000c2d2:	ab d6       	cbr	r6,0xb
8000c2d4:	e0 80 00 e2 	breq	8000c498 <__avr32_f64_div_round_subnormal+0xa0>
8000c2d8:	e0 46 07 ff 	cp.w	r6,2047
8000c2dc:	e0 84 00 b2 	brge	8000c440 <__avr32_f64_div_round_subnormal+0x48>
8000c2e0:	0c 17       	sub	r7,r6
8000c2e2:	fe 37 fc 01 	sub	r7,-1023
8000c2e6:	fc 1c 80 00 	movh	r12,0x8000
8000c2ea:	f8 03 16 01 	lsr	r3,r12,0x1
8000c2ee:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c2f2:	5c d4       	com	r4
8000c2f4:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c2f8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c2fc:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c300:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c304:	ea 03 15 02 	lsl	r3,r5,0x2
8000c308:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c30c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c310:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c314:	ea 03 15 02 	lsl	r3,r5,0x2
8000c318:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c31c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c320:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c324:	ea 03 15 02 	lsl	r3,r5,0x2
8000c328:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c32c:	e4 09 07 40 	macu.d	r0,r2,r9
8000c330:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c334:	02 04       	add	r4,r1
8000c336:	5c 05       	acr	r5
8000c338:	a3 65       	lsl	r5,0x2
8000c33a:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c33e:	a3 64       	lsl	r4,0x2
8000c340:	5c 34       	neg	r4
8000c342:	f8 05 01 45 	sbc	r5,r12,r5
8000c346:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c34a:	e4 05 07 40 	macu.d	r0,r2,r5
8000c34e:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c352:	02 04       	add	r4,r1
8000c354:	5c 05       	acr	r5
8000c356:	ea 03 15 02 	lsl	r3,r5,0x2
8000c35a:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c35e:	e8 02 15 02 	lsl	r2,r4,0x2
8000c362:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c366:	e4 09 07 40 	macu.d	r0,r2,r9
8000c36a:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c36e:	02 04       	add	r4,r1
8000c370:	5c 05       	acr	r5
8000c372:	a3 65       	lsl	r5,0x2
8000c374:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c378:	a3 64       	lsl	r4,0x2
8000c37a:	5c 34       	neg	r4
8000c37c:	f8 05 01 45 	sbc	r5,r12,r5
8000c380:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c384:	e4 05 07 40 	macu.d	r0,r2,r5
8000c388:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c38c:	02 04       	add	r4,r1
8000c38e:	5c 05       	acr	r5
8000c390:	ea 03 15 02 	lsl	r3,r5,0x2
8000c394:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c398:	e8 02 15 02 	lsl	r2,r4,0x2
8000c39c:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c3a0:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c3a4:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c3a8:	02 02       	add	r2,r1
8000c3aa:	5c 03       	acr	r3
8000c3ac:	ed b3 00 1c 	bld	r3,0x1c
8000c3b0:	c0 90       	breq	8000c3c2 <__avr32_f64_div+0x12a>
8000c3b2:	a1 72       	lsl	r2,0x1
8000c3b4:	5c f3       	rol	r3
8000c3b6:	20 17       	sub	r7,1
8000c3b8:	a3 9a       	lsr	r10,0x3
8000c3ba:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c3be:	a3 9b       	lsr	r11,0x3
8000c3c0:	c0 58       	rjmp	8000c3ca <__avr32_f64_div+0x132>
8000c3c2:	a5 8a       	lsr	r10,0x4
8000c3c4:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c3c8:	a5 8b       	lsr	r11,0x4
8000c3ca:	58 07       	cp.w	r7,0
8000c3cc:	e0 8a 00 8b 	brle	8000c4e2 <__avr32_f64_div_res_subnormal>
8000c3d0:	e0 12 ff 00 	andl	r2,0xff00
8000c3d4:	e8 12 00 80 	orl	r2,0x80
8000c3d8:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c3dc:	e4 09 07 40 	macu.d	r0,r2,r9
8000c3e0:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c3e4:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c3e8:	00 05       	add	r5,r0
8000c3ea:	f0 01 00 48 	adc	r8,r8,r1
8000c3ee:	5c 09       	acr	r9
8000c3f0:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c3f4:	58 04       	cp.w	r4,0
8000c3f6:	5c 25       	cpc	r5

8000c3f8 <__avr32_f64_div_round_subnormal>:
8000c3f8:	f4 08 13 00 	cpc	r8,r10
8000c3fc:	f6 09 13 00 	cpc	r9,r11
8000c400:	5f 36       	srlo	r6
8000c402:	f8 06 17 00 	moveq	r6,r12
8000c406:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c40a:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c40e:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c412:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c416:	ed be 00 1f 	bld	lr,0x1f
8000c41a:	ef bb 00 1f 	bst	r11,0x1f
8000c41e:	0c 0a       	add	r10,r6
8000c420:	5c 0b       	acr	r11
8000c422:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c426:	e4 1b 00 0f 	andh	r11,0xf
8000c42a:	14 4b       	or	r11,r10
8000c42c:	e0 81 00 a7 	brne	8000c57a <__avr32_f64_div_res_subnormal+0x98>
8000c430:	f2 06 16 14 	lsr	r6,r9,0x14
8000c434:	ab d6       	cbr	r6,0xb
8000c436:	e0 46 07 ff 	cp.w	r6,2047
8000c43a:	e0 81 00 a4 	brne	8000c582 <__avr32_f64_div_res_subnormal+0xa0>
8000c43e:	c9 e8       	rjmp	8000c57a <__avr32_f64_div_res_subnormal+0x98>
8000c440:	e4 19 00 0f 	andh	r9,0xf
8000c444:	10 49       	or	r9,r8
8000c446:	e0 81 00 9a 	brne	8000c57a <__avr32_f64_div_res_subnormal+0x98>
8000c44a:	c9 28       	rjmp	8000c56e <__avr32_f64_div_res_subnormal+0x8c>
8000c44c:	a3 7b       	lsl	r11,0x3
8000c44e:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c452:	a3 7a       	lsl	r10,0x3
8000c454:	f5 eb 10 04 	or	r4,r10,r11
8000c458:	e0 80 00 a0 	breq	8000c598 <__avr32_f64_div_op1_zero>
8000c45c:	f6 04 12 00 	clz	r4,r11
8000c460:	c1 70       	breq	8000c48e <__avr32_f64_div_round_subnormal+0x96>
8000c462:	c0 c3       	brcs	8000c47a <__avr32_f64_div_round_subnormal+0x82>
8000c464:	e8 05 11 20 	rsub	r5,r4,32
8000c468:	f6 04 09 4b 	lsl	r11,r11,r4
8000c46c:	f4 05 0a 45 	lsr	r5,r10,r5
8000c470:	0a 4b       	or	r11,r5
8000c472:	f4 04 09 4a 	lsl	r10,r10,r4
8000c476:	08 17       	sub	r7,r4
8000c478:	c0 b8       	rjmp	8000c48e <__avr32_f64_div_round_subnormal+0x96>
8000c47a:	f4 04 12 00 	clz	r4,r10
8000c47e:	f9 b4 03 00 	movlo	r4,0
8000c482:	f7 b4 02 e0 	subhs	r4,-32
8000c486:	f4 04 09 4b 	lsl	r11,r10,r4
8000c48a:	30 0a       	mov	r10,0
8000c48c:	08 17       	sub	r7,r4
8000c48e:	a3 8a       	lsr	r10,0x2
8000c490:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c494:	a3 8b       	lsr	r11,0x2
8000c496:	c1 1b       	rjmp	8000c2b8 <__avr32_f64_div+0x20>
8000c498:	a3 79       	lsl	r9,0x3
8000c49a:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c49e:	a3 78       	lsl	r8,0x3
8000c4a0:	f3 e8 10 04 	or	r4,r9,r8
8000c4a4:	c6 f0       	breq	8000c582 <__avr32_f64_div_res_subnormal+0xa0>
8000c4a6:	f2 04 12 00 	clz	r4,r9
8000c4aa:	c1 70       	breq	8000c4d8 <__avr32_f64_div_round_subnormal+0xe0>
8000c4ac:	c0 c3       	brcs	8000c4c4 <__avr32_f64_div_round_subnormal+0xcc>
8000c4ae:	e8 05 11 20 	rsub	r5,r4,32
8000c4b2:	f2 04 09 49 	lsl	r9,r9,r4
8000c4b6:	f0 05 0a 45 	lsr	r5,r8,r5
8000c4ba:	0a 49       	or	r9,r5
8000c4bc:	f0 04 09 48 	lsl	r8,r8,r4
8000c4c0:	08 16       	sub	r6,r4
8000c4c2:	c0 b8       	rjmp	8000c4d8 <__avr32_f64_div_round_subnormal+0xe0>
8000c4c4:	f0 04 12 00 	clz	r4,r8
8000c4c8:	f9 b4 03 00 	movlo	r4,0
8000c4cc:	f7 b4 02 e0 	subhs	r4,-32
8000c4d0:	f0 04 09 49 	lsl	r9,r8,r4
8000c4d4:	30 08       	mov	r8,0
8000c4d6:	08 16       	sub	r6,r4
8000c4d8:	a3 88       	lsr	r8,0x2
8000c4da:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c4de:	a3 89       	lsr	r9,0x2
8000c4e0:	cf ca       	rjmp	8000c2d8 <__avr32_f64_div+0x40>

8000c4e2 <__avr32_f64_div_res_subnormal>:
8000c4e2:	5c 37       	neg	r7
8000c4e4:	2f f7       	sub	r7,-1
8000c4e6:	f1 b7 04 c0 	satu	r7,0x6
8000c4ea:	e0 47 00 20 	cp.w	r7,32
8000c4ee:	c1 54       	brge	8000c518 <__avr32_f64_div_res_subnormal+0x36>
8000c4f0:	ee 06 11 20 	rsub	r6,r7,32
8000c4f4:	e4 07 0a 42 	lsr	r2,r2,r7
8000c4f8:	e6 06 09 4c 	lsl	r12,r3,r6
8000c4fc:	18 42       	or	r2,r12
8000c4fe:	e6 07 0a 43 	lsr	r3,r3,r7
8000c502:	f4 06 09 41 	lsl	r1,r10,r6
8000c506:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c50a:	f6 06 09 4c 	lsl	r12,r11,r6
8000c50e:	18 4a       	or	r10,r12
8000c510:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c514:	30 00       	mov	r0,0
8000c516:	c1 58       	rjmp	8000c540 <__avr32_f64_div_res_subnormal+0x5e>
8000c518:	ee 06 11 20 	rsub	r6,r7,32
8000c51c:	f9 b0 00 00 	moveq	r0,0
8000c520:	f9 bc 00 00 	moveq	r12,0
8000c524:	c0 50       	breq	8000c52e <__avr32_f64_div_res_subnormal+0x4c>
8000c526:	f4 06 09 40 	lsl	r0,r10,r6
8000c52a:	f6 06 09 4c 	lsl	r12,r11,r6
8000c52e:	e6 07 0a 42 	lsr	r2,r3,r7
8000c532:	30 03       	mov	r3,0
8000c534:	f4 07 0a 41 	lsr	r1,r10,r7
8000c538:	18 41       	or	r1,r12
8000c53a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c53e:	30 0b       	mov	r11,0
8000c540:	e0 12 ff 00 	andl	r2,0xff00
8000c544:	e8 12 00 80 	orl	r2,0x80
8000c548:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c54c:	e4 09 07 46 	macu.d	r6,r2,r9
8000c550:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c554:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c558:	0c 05       	add	r5,r6
8000c55a:	f0 07 00 48 	adc	r8,r8,r7
8000c55e:	5c 09       	acr	r9
8000c560:	30 07       	mov	r7,0
8000c562:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c566:	00 34       	cp.w	r4,r0
8000c568:	e2 05 13 00 	cpc	r5,r1
8000c56c:	c4 6b       	rjmp	8000c3f8 <__avr32_f64_div_round_subnormal>
8000c56e:	1c 9b       	mov	r11,lr
8000c570:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c574:	30 0a       	mov	r10,0
8000c576:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c57a:	3f fb       	mov	r11,-1
8000c57c:	30 0a       	mov	r10,0
8000c57e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c582:	f5 eb 10 04 	or	r4,r10,r11
8000c586:	c0 90       	breq	8000c598 <__avr32_f64_div_op1_zero>
8000c588:	1c 9b       	mov	r11,lr
8000c58a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c58e:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c592:	30 0a       	mov	r10,0
8000c594:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c598 <__avr32_f64_div_op1_zero>:
8000c598:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c59c:	ce f0       	breq	8000c57a <__avr32_f64_div_res_subnormal+0x98>
8000c59e:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c5a2:	e0 44 07 ff 	cp.w	r4,2047
8000c5a6:	ce 41       	brne	8000c56e <__avr32_f64_div_res_subnormal+0x8c>
8000c5a8:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c5ac:	ce 10       	breq	8000c56e <__avr32_f64_div_res_subnormal+0x8c>
8000c5ae:	ce 6b       	rjmp	8000c57a <__avr32_f64_div_res_subnormal+0x98>

8000c5b0 <__avr32_udiv64>:
8000c5b0:	d4 31       	pushm	r0-r7,lr
8000c5b2:	1a 97       	mov	r7,sp
8000c5b4:	20 3d       	sub	sp,12
8000c5b6:	10 9c       	mov	r12,r8
8000c5b8:	12 9e       	mov	lr,r9
8000c5ba:	14 93       	mov	r3,r10
8000c5bc:	58 09       	cp.w	r9,0
8000c5be:	e0 81 00 bd 	brne	8000c738 <__avr32_udiv64+0x188>
8000c5c2:	16 38       	cp.w	r8,r11
8000c5c4:	e0 88 00 40 	brls	8000c644 <__avr32_udiv64+0x94>
8000c5c8:	f0 08 12 00 	clz	r8,r8
8000c5cc:	c0 d0       	breq	8000c5e6 <__avr32_udiv64+0x36>
8000c5ce:	f6 08 09 4b 	lsl	r11,r11,r8
8000c5d2:	f0 09 11 20 	rsub	r9,r8,32
8000c5d6:	f8 08 09 4c 	lsl	r12,r12,r8
8000c5da:	f4 09 0a 49 	lsr	r9,r10,r9
8000c5de:	f4 08 09 43 	lsl	r3,r10,r8
8000c5e2:	f3 eb 10 0b 	or	r11,r9,r11
8000c5e6:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c5ea:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c5ee:	f6 0e 0d 00 	divu	r0,r11,lr
8000c5f2:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c5f6:	00 99       	mov	r9,r0
8000c5f8:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c5fc:	e0 0a 02 48 	mul	r8,r0,r10
8000c600:	10 3b       	cp.w	r11,r8
8000c602:	c0 a2       	brcc	8000c616 <__avr32_udiv64+0x66>
8000c604:	20 19       	sub	r9,1
8000c606:	18 0b       	add	r11,r12
8000c608:	18 3b       	cp.w	r11,r12
8000c60a:	c0 63       	brcs	8000c616 <__avr32_udiv64+0x66>
8000c60c:	10 3b       	cp.w	r11,r8
8000c60e:	f7 b9 03 01 	sublo	r9,1
8000c612:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c616:	f6 08 01 01 	sub	r1,r11,r8
8000c61a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c61e:	e2 0e 0d 00 	divu	r0,r1,lr
8000c622:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c626:	00 98       	mov	r8,r0
8000c628:	e0 0a 02 4a 	mul	r10,r0,r10
8000c62c:	14 33       	cp.w	r3,r10
8000c62e:	c0 82       	brcc	8000c63e <__avr32_udiv64+0x8e>
8000c630:	20 18       	sub	r8,1
8000c632:	18 03       	add	r3,r12
8000c634:	18 33       	cp.w	r3,r12
8000c636:	c0 43       	brcs	8000c63e <__avr32_udiv64+0x8e>
8000c638:	14 33       	cp.w	r3,r10
8000c63a:	f7 b8 03 01 	sublo	r8,1
8000c63e:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c642:	cd f8       	rjmp	8000c800 <__avr32_udiv64+0x250>
8000c644:	58 08       	cp.w	r8,0
8000c646:	c0 51       	brne	8000c650 <__avr32_udiv64+0xa0>
8000c648:	30 19       	mov	r9,1
8000c64a:	f2 08 0d 08 	divu	r8,r9,r8
8000c64e:	10 9c       	mov	r12,r8
8000c650:	f8 06 12 00 	clz	r6,r12
8000c654:	c0 41       	brne	8000c65c <__avr32_udiv64+0xac>
8000c656:	18 1b       	sub	r11,r12
8000c658:	30 19       	mov	r9,1
8000c65a:	c4 08       	rjmp	8000c6da <__avr32_udiv64+0x12a>
8000c65c:	ec 01 11 20 	rsub	r1,r6,32
8000c660:	f4 01 0a 49 	lsr	r9,r10,r1
8000c664:	f8 06 09 4c 	lsl	r12,r12,r6
8000c668:	f6 06 09 48 	lsl	r8,r11,r6
8000c66c:	f6 01 0a 41 	lsr	r1,r11,r1
8000c670:	f3 e8 10 08 	or	r8,r9,r8
8000c674:	f8 03 16 10 	lsr	r3,r12,0x10
8000c678:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c67c:	e2 03 0d 00 	divu	r0,r1,r3
8000c680:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c684:	00 9e       	mov	lr,r0
8000c686:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c68a:	e0 05 02 49 	mul	r9,r0,r5
8000c68e:	12 3b       	cp.w	r11,r9
8000c690:	c0 a2       	brcc	8000c6a4 <__avr32_udiv64+0xf4>
8000c692:	20 1e       	sub	lr,1
8000c694:	18 0b       	add	r11,r12
8000c696:	18 3b       	cp.w	r11,r12
8000c698:	c0 63       	brcs	8000c6a4 <__avr32_udiv64+0xf4>
8000c69a:	12 3b       	cp.w	r11,r9
8000c69c:	f7 be 03 01 	sublo	lr,1
8000c6a0:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c6a4:	12 1b       	sub	r11,r9
8000c6a6:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c6aa:	f6 03 0d 02 	divu	r2,r11,r3
8000c6ae:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c6b2:	04 99       	mov	r9,r2
8000c6b4:	e4 05 02 4b 	mul	r11,r2,r5
8000c6b8:	16 38       	cp.w	r8,r11
8000c6ba:	c0 a2       	brcc	8000c6ce <__avr32_udiv64+0x11e>
8000c6bc:	20 19       	sub	r9,1
8000c6be:	18 08       	add	r8,r12
8000c6c0:	18 38       	cp.w	r8,r12
8000c6c2:	c0 63       	brcs	8000c6ce <__avr32_udiv64+0x11e>
8000c6c4:	16 38       	cp.w	r8,r11
8000c6c6:	f7 b9 03 01 	sublo	r9,1
8000c6ca:	f1 dc e3 08 	addcs	r8,r8,r12
8000c6ce:	f4 06 09 43 	lsl	r3,r10,r6
8000c6d2:	f0 0b 01 0b 	sub	r11,r8,r11
8000c6d6:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c6da:	f8 06 16 10 	lsr	r6,r12,0x10
8000c6de:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c6e2:	f6 06 0d 00 	divu	r0,r11,r6
8000c6e6:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c6ea:	00 9a       	mov	r10,r0
8000c6ec:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c6f0:	e0 0e 02 48 	mul	r8,r0,lr
8000c6f4:	10 3b       	cp.w	r11,r8
8000c6f6:	c0 a2       	brcc	8000c70a <__avr32_udiv64+0x15a>
8000c6f8:	20 1a       	sub	r10,1
8000c6fa:	18 0b       	add	r11,r12
8000c6fc:	18 3b       	cp.w	r11,r12
8000c6fe:	c0 63       	brcs	8000c70a <__avr32_udiv64+0x15a>
8000c700:	10 3b       	cp.w	r11,r8
8000c702:	f7 ba 03 01 	sublo	r10,1
8000c706:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c70a:	f6 08 01 01 	sub	r1,r11,r8
8000c70e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c712:	e2 06 0d 00 	divu	r0,r1,r6
8000c716:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c71a:	00 98       	mov	r8,r0
8000c71c:	e0 0e 02 4b 	mul	r11,r0,lr
8000c720:	16 33       	cp.w	r3,r11
8000c722:	c0 82       	brcc	8000c732 <__avr32_udiv64+0x182>
8000c724:	20 18       	sub	r8,1
8000c726:	18 03       	add	r3,r12
8000c728:	18 33       	cp.w	r3,r12
8000c72a:	c0 43       	brcs	8000c732 <__avr32_udiv64+0x182>
8000c72c:	16 33       	cp.w	r3,r11
8000c72e:	f7 b8 03 01 	sublo	r8,1
8000c732:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c736:	c6 98       	rjmp	8000c808 <__avr32_udiv64+0x258>
8000c738:	16 39       	cp.w	r9,r11
8000c73a:	e0 8b 00 65 	brhi	8000c804 <__avr32_udiv64+0x254>
8000c73e:	f2 09 12 00 	clz	r9,r9
8000c742:	c0 b1       	brne	8000c758 <__avr32_udiv64+0x1a8>
8000c744:	10 3a       	cp.w	r10,r8
8000c746:	5f 2a       	srhs	r10
8000c748:	1c 3b       	cp.w	r11,lr
8000c74a:	5f b8       	srhi	r8
8000c74c:	10 4a       	or	r10,r8
8000c74e:	f2 0a 18 00 	cp.b	r10,r9
8000c752:	c5 90       	breq	8000c804 <__avr32_udiv64+0x254>
8000c754:	30 18       	mov	r8,1
8000c756:	c5 98       	rjmp	8000c808 <__avr32_udiv64+0x258>
8000c758:	f0 09 09 46 	lsl	r6,r8,r9
8000c75c:	f2 03 11 20 	rsub	r3,r9,32
8000c760:	fc 09 09 4e 	lsl	lr,lr,r9
8000c764:	f0 03 0a 48 	lsr	r8,r8,r3
8000c768:	f6 09 09 4c 	lsl	r12,r11,r9
8000c76c:	f4 03 0a 42 	lsr	r2,r10,r3
8000c770:	ef 46 ff f4 	st.w	r7[-12],r6
8000c774:	f6 03 0a 43 	lsr	r3,r11,r3
8000c778:	18 42       	or	r2,r12
8000c77a:	f1 ee 10 0c 	or	r12,r8,lr
8000c77e:	f8 01 16 10 	lsr	r1,r12,0x10
8000c782:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c786:	e6 01 0d 04 	divu	r4,r3,r1
8000c78a:	e4 03 16 10 	lsr	r3,r2,0x10
8000c78e:	08 9e       	mov	lr,r4
8000c790:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c794:	e8 06 02 48 	mul	r8,r4,r6
8000c798:	10 33       	cp.w	r3,r8
8000c79a:	c0 a2       	brcc	8000c7ae <__avr32_udiv64+0x1fe>
8000c79c:	20 1e       	sub	lr,1
8000c79e:	18 03       	add	r3,r12
8000c7a0:	18 33       	cp.w	r3,r12
8000c7a2:	c0 63       	brcs	8000c7ae <__avr32_udiv64+0x1fe>
8000c7a4:	10 33       	cp.w	r3,r8
8000c7a6:	f7 be 03 01 	sublo	lr,1
8000c7aa:	e7 dc e3 03 	addcs	r3,r3,r12
8000c7ae:	10 13       	sub	r3,r8
8000c7b0:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c7b4:	e6 01 0d 00 	divu	r0,r3,r1
8000c7b8:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c7bc:	00 98       	mov	r8,r0
8000c7be:	e0 06 02 46 	mul	r6,r0,r6
8000c7c2:	0c 3b       	cp.w	r11,r6
8000c7c4:	c0 a2       	brcc	8000c7d8 <__avr32_udiv64+0x228>
8000c7c6:	20 18       	sub	r8,1
8000c7c8:	18 0b       	add	r11,r12
8000c7ca:	18 3b       	cp.w	r11,r12
8000c7cc:	c0 63       	brcs	8000c7d8 <__avr32_udiv64+0x228>
8000c7ce:	0c 3b       	cp.w	r11,r6
8000c7d0:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c7d4:	f7 b8 03 01 	sublo	r8,1
8000c7d8:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c7dc:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c7e0:	0c 1b       	sub	r11,r6
8000c7e2:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c7e6:	06 95       	mov	r5,r3
8000c7e8:	16 35       	cp.w	r5,r11
8000c7ea:	e0 8b 00 0a 	brhi	8000c7fe <__avr32_udiv64+0x24e>
8000c7ee:	5f 0b       	sreq	r11
8000c7f0:	f4 09 09 49 	lsl	r9,r10,r9
8000c7f4:	12 32       	cp.w	r2,r9
8000c7f6:	5f b9       	srhi	r9
8000c7f8:	f7 e9 00 09 	and	r9,r11,r9
8000c7fc:	c0 60       	breq	8000c808 <__avr32_udiv64+0x258>
8000c7fe:	20 18       	sub	r8,1
8000c800:	30 09       	mov	r9,0
8000c802:	c0 38       	rjmp	8000c808 <__avr32_udiv64+0x258>
8000c804:	30 09       	mov	r9,0
8000c806:	12 98       	mov	r8,r9
8000c808:	10 9a       	mov	r10,r8
8000c80a:	12 93       	mov	r3,r9
8000c80c:	10 92       	mov	r2,r8
8000c80e:	12 9b       	mov	r11,r9
8000c810:	2f dd       	sub	sp,-12
8000c812:	d8 32       	popm	r0-r7,pc

8000c814 <__avr32_umod64>:
8000c814:	d4 31       	pushm	r0-r7,lr
8000c816:	1a 97       	mov	r7,sp
8000c818:	20 3d       	sub	sp,12
8000c81a:	10 9c       	mov	r12,r8
8000c81c:	12 95       	mov	r5,r9
8000c81e:	14 9e       	mov	lr,r10
8000c820:	16 91       	mov	r1,r11
8000c822:	16 96       	mov	r6,r11
8000c824:	58 09       	cp.w	r9,0
8000c826:	e0 81 00 81 	brne	8000c928 <__avr32_umod64+0x114>
8000c82a:	16 38       	cp.w	r8,r11
8000c82c:	e0 88 00 12 	brls	8000c850 <__avr32_umod64+0x3c>
8000c830:	f0 08 12 00 	clz	r8,r8
8000c834:	c4 e0       	breq	8000c8d0 <__avr32_umod64+0xbc>
8000c836:	f6 08 09 46 	lsl	r6,r11,r8
8000c83a:	f8 08 09 4c 	lsl	r12,r12,r8
8000c83e:	f0 0b 11 20 	rsub	r11,r8,32
8000c842:	f4 08 09 4e 	lsl	lr,r10,r8
8000c846:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c84a:	f7 e6 10 06 	or	r6,r11,r6
8000c84e:	c4 18       	rjmp	8000c8d0 <__avr32_umod64+0xbc>
8000c850:	58 08       	cp.w	r8,0
8000c852:	c0 51       	brne	8000c85c <__avr32_umod64+0x48>
8000c854:	30 19       	mov	r9,1
8000c856:	f2 08 0d 08 	divu	r8,r9,r8
8000c85a:	10 9c       	mov	r12,r8
8000c85c:	f8 08 12 00 	clz	r8,r12
8000c860:	c0 31       	brne	8000c866 <__avr32_umod64+0x52>
8000c862:	18 16       	sub	r6,r12
8000c864:	c3 68       	rjmp	8000c8d0 <__avr32_umod64+0xbc>
8000c866:	f0 03 11 20 	rsub	r3,r8,32
8000c86a:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c86e:	f8 08 09 4c 	lsl	r12,r12,r8
8000c872:	ec 08 09 49 	lsl	r9,r6,r8
8000c876:	ec 03 0a 43 	lsr	r3,r6,r3
8000c87a:	f7 e9 10 09 	or	r9,r11,r9
8000c87e:	f8 05 16 10 	lsr	r5,r12,0x10
8000c882:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c886:	e6 05 0d 02 	divu	r2,r3,r5
8000c88a:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c88e:	ec 02 02 4b 	mul	r11,r6,r2
8000c892:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c896:	16 3e       	cp.w	lr,r11
8000c898:	c0 72       	brcc	8000c8a6 <__avr32_umod64+0x92>
8000c89a:	18 0e       	add	lr,r12
8000c89c:	18 3e       	cp.w	lr,r12
8000c89e:	c0 43       	brcs	8000c8a6 <__avr32_umod64+0x92>
8000c8a0:	16 3e       	cp.w	lr,r11
8000c8a2:	fd dc e3 0e 	addcs	lr,lr,r12
8000c8a6:	fc 0b 01 03 	sub	r3,lr,r11
8000c8aa:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c8ae:	e6 05 0d 02 	divu	r2,r3,r5
8000c8b2:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c8b6:	a5 36       	mul	r6,r2
8000c8b8:	0c 39       	cp.w	r9,r6
8000c8ba:	c0 72       	brcc	8000c8c8 <__avr32_umod64+0xb4>
8000c8bc:	18 09       	add	r9,r12
8000c8be:	18 39       	cp.w	r9,r12
8000c8c0:	c0 43       	brcs	8000c8c8 <__avr32_umod64+0xb4>
8000c8c2:	0c 39       	cp.w	r9,r6
8000c8c4:	f3 dc e3 09 	addcs	r9,r9,r12
8000c8c8:	f2 06 01 06 	sub	r6,r9,r6
8000c8cc:	f4 08 09 4e 	lsl	lr,r10,r8
8000c8d0:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c8d4:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c8d8:	ec 0a 0d 02 	divu	r2,r6,r10
8000c8dc:	fc 09 16 10 	lsr	r9,lr,0x10
8000c8e0:	ea 02 02 4b 	mul	r11,r5,r2
8000c8e4:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c8e8:	16 39       	cp.w	r9,r11
8000c8ea:	c0 72       	brcc	8000c8f8 <__avr32_umod64+0xe4>
8000c8ec:	18 09       	add	r9,r12
8000c8ee:	18 39       	cp.w	r9,r12
8000c8f0:	c0 43       	brcs	8000c8f8 <__avr32_umod64+0xe4>
8000c8f2:	16 39       	cp.w	r9,r11
8000c8f4:	f3 dc e3 09 	addcs	r9,r9,r12
8000c8f8:	f2 0b 01 0b 	sub	r11,r9,r11
8000c8fc:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c900:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c904:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c908:	ea 0a 02 4a 	mul	r10,r5,r10
8000c90c:	14 3e       	cp.w	lr,r10
8000c90e:	c0 72       	brcc	8000c91c <__avr32_umod64+0x108>
8000c910:	18 0e       	add	lr,r12
8000c912:	18 3e       	cp.w	lr,r12
8000c914:	c0 43       	brcs	8000c91c <__avr32_umod64+0x108>
8000c916:	14 3e       	cp.w	lr,r10
8000c918:	fd dc e3 0e 	addcs	lr,lr,r12
8000c91c:	fc 0a 01 0a 	sub	r10,lr,r10
8000c920:	30 0b       	mov	r11,0
8000c922:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c926:	c7 b8       	rjmp	8000ca1c <__avr32_umod64+0x208>
8000c928:	16 39       	cp.w	r9,r11
8000c92a:	e0 8b 00 79 	brhi	8000ca1c <__avr32_umod64+0x208>
8000c92e:	f2 09 12 00 	clz	r9,r9
8000c932:	c1 21       	brne	8000c956 <__avr32_umod64+0x142>
8000c934:	10 3a       	cp.w	r10,r8
8000c936:	5f 2b       	srhs	r11
8000c938:	0a 31       	cp.w	r1,r5
8000c93a:	5f ba       	srhi	r10
8000c93c:	f7 ea 10 0a 	or	r10,r11,r10
8000c940:	f2 0a 18 00 	cp.b	r10,r9
8000c944:	c0 60       	breq	8000c950 <__avr32_umod64+0x13c>
8000c946:	fc 08 01 0c 	sub	r12,lr,r8
8000c94a:	e2 05 01 46 	sbc	r6,r1,r5
8000c94e:	18 9e       	mov	lr,r12
8000c950:	0c 9b       	mov	r11,r6
8000c952:	1c 9a       	mov	r10,lr
8000c954:	c6 48       	rjmp	8000ca1c <__avr32_umod64+0x208>
8000c956:	ea 09 09 4c 	lsl	r12,r5,r9
8000c95a:	f2 06 11 20 	rsub	r6,r9,32
8000c95e:	f6 09 09 4b 	lsl	r11,r11,r9
8000c962:	f0 09 09 42 	lsl	r2,r8,r9
8000c966:	ef 46 ff f4 	st.w	r7[-12],r6
8000c96a:	f0 06 0a 48 	lsr	r8,r8,r6
8000c96e:	18 48       	or	r8,r12
8000c970:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c974:	f4 09 09 43 	lsl	r3,r10,r9
8000c978:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c97c:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c980:	16 4a       	or	r10,r11
8000c982:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c986:	f8 0b 0d 04 	divu	r4,r12,r11
8000c98a:	f4 0c 16 10 	lsr	r12,r10,0x10
8000c98e:	08 91       	mov	r1,r4
8000c990:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000c994:	e8 0e 02 46 	mul	r6,r4,lr
8000c998:	0c 3c       	cp.w	r12,r6
8000c99a:	c0 a2       	brcc	8000c9ae <__avr32_umod64+0x19a>
8000c99c:	20 11       	sub	r1,1
8000c99e:	10 0c       	add	r12,r8
8000c9a0:	10 3c       	cp.w	r12,r8
8000c9a2:	c0 63       	brcs	8000c9ae <__avr32_umod64+0x19a>
8000c9a4:	0c 3c       	cp.w	r12,r6
8000c9a6:	f7 b1 03 01 	sublo	r1,1
8000c9aa:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c9ae:	0c 1c       	sub	r12,r6
8000c9b0:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c9b4:	f8 0b 0d 04 	divu	r4,r12,r11
8000c9b8:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c9bc:	08 96       	mov	r6,r4
8000c9be:	e8 0e 02 4e 	mul	lr,r4,lr
8000c9c2:	1c 3b       	cp.w	r11,lr
8000c9c4:	c0 a2       	brcc	8000c9d8 <__avr32_umod64+0x1c4>
8000c9c6:	20 16       	sub	r6,1
8000c9c8:	10 0b       	add	r11,r8
8000c9ca:	10 3b       	cp.w	r11,r8
8000c9cc:	c0 63       	brcs	8000c9d8 <__avr32_umod64+0x1c4>
8000c9ce:	1c 3b       	cp.w	r11,lr
8000c9d0:	f7 b6 03 01 	sublo	r6,1
8000c9d4:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c9d8:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c9dc:	1c 1b       	sub	r11,lr
8000c9de:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c9e2:	00 9e       	mov	lr,r0
8000c9e4:	02 9c       	mov	r12,r1
8000c9e6:	16 3c       	cp.w	r12,r11
8000c9e8:	e0 8b 00 08 	brhi	8000c9f8 <__avr32_umod64+0x1e4>
8000c9ec:	5f 06       	sreq	r6
8000c9ee:	06 30       	cp.w	r0,r3
8000c9f0:	5f ba       	srhi	r10
8000c9f2:	ed ea 00 0a 	and	r10,r6,r10
8000c9f6:	c0 60       	breq	8000ca02 <__avr32_umod64+0x1ee>
8000c9f8:	fc 02 01 04 	sub	r4,lr,r2
8000c9fc:	f8 08 01 4c 	sbc	r12,r12,r8
8000ca00:	08 9e       	mov	lr,r4
8000ca02:	e6 0e 01 0a 	sub	r10,r3,lr
8000ca06:	f6 0c 01 4c 	sbc	r12,r11,r12
8000ca0a:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000ca0e:	f8 09 0a 4b 	lsr	r11,r12,r9
8000ca12:	f4 09 0a 4a 	lsr	r10,r10,r9
8000ca16:	f8 01 09 4c 	lsl	r12,r12,r1
8000ca1a:	18 4a       	or	r10,r12
8000ca1c:	2f dd       	sub	sp,-12
8000ca1e:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000cc00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000cc00:	c0 08       	rjmp	8000cc00 <_evba>
	...

8000cc04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000cc04:	c0 08       	rjmp	8000cc04 <_handle_TLB_Multiple_Hit>
	...

8000cc08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000cc08:	c0 08       	rjmp	8000cc08 <_handle_Bus_Error_Data_Fetch>
	...

8000cc0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000cc0c:	c0 08       	rjmp	8000cc0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000cc10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000cc10:	c0 08       	rjmp	8000cc10 <_handle_NMI>
	...

8000cc14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000cc14:	c0 08       	rjmp	8000cc14 <_handle_Instruction_Address>
	...

8000cc18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000cc18:	c0 08       	rjmp	8000cc18 <_handle_ITLB_Protection>
	...

8000cc1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000cc1c:	c0 08       	rjmp	8000cc1c <_handle_Breakpoint>
	...

8000cc20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000cc20:	c0 08       	rjmp	8000cc20 <_handle_Illegal_Opcode>
	...

8000cc24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000cc24:	c0 08       	rjmp	8000cc24 <_handle_Unimplemented_Instruction>
	...

8000cc28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000cc28:	c0 08       	rjmp	8000cc28 <_handle_Privilege_Violation>
	...

8000cc2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000cc2c:	c0 08       	rjmp	8000cc2c <_handle_Floating_Point>
	...

8000cc30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000cc30:	c0 08       	rjmp	8000cc30 <_handle_Coprocessor_Absent>
	...

8000cc34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000cc34:	c0 08       	rjmp	8000cc34 <_handle_Data_Address_Read>
	...

8000cc38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000cc38:	c0 08       	rjmp	8000cc38 <_handle_Data_Address_Write>
	...

8000cc3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000cc3c:	c0 08       	rjmp	8000cc3c <_handle_DTLB_Protection_Read>
	...

8000cc40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000cc40:	c0 08       	rjmp	8000cc40 <_handle_DTLB_Protection_Write>
	...

8000cc44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000cc44:	c0 08       	rjmp	8000cc44 <_handle_DTLB_Modified>
	...

8000cc50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000cc50:	c0 08       	rjmp	8000cc50 <_handle_ITLB_Miss>
	...

8000cc60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000cc60:	c0 08       	rjmp	8000cc60 <_handle_DTLB_Miss_Read>
	...

8000cc70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000cc70:	c0 08       	rjmp	8000cc70 <_handle_DTLB_Miss_Write>
	...

8000cd00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000cd00:	fe cf 71 24 	sub	pc,pc,28964

8000cd04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000cd04:	30 0c       	mov	r12,0
8000cd06:	fe b0 c3 79 	rcall	800053f8 <_get_interrupt_handler>
8000cd0a:	58 0c       	cp.w	r12,0
8000cd0c:	f8 0f 17 10 	movne	pc,r12
8000cd10:	d6 03       	rete

8000cd12 <_int1>:
8000cd12:	30 1c       	mov	r12,1
8000cd14:	fe b0 c3 72 	rcall	800053f8 <_get_interrupt_handler>
8000cd18:	58 0c       	cp.w	r12,0
8000cd1a:	f8 0f 17 10 	movne	pc,r12
8000cd1e:	d6 03       	rete

8000cd20 <_int2>:
8000cd20:	30 2c       	mov	r12,2
8000cd22:	fe b0 c3 6b 	rcall	800053f8 <_get_interrupt_handler>
8000cd26:	58 0c       	cp.w	r12,0
8000cd28:	f8 0f 17 10 	movne	pc,r12
8000cd2c:	d6 03       	rete

8000cd2e <_int3>:
8000cd2e:	30 3c       	mov	r12,3
8000cd30:	fe b0 c3 64 	rcall	800053f8 <_get_interrupt_handler>
8000cd34:	58 0c       	cp.w	r12,0
8000cd36:	f8 0f 17 10 	movne	pc,r12
8000cd3a:	d6 03       	rete

8000cd3c <ipr_val>:
8000cd3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000cd4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cddc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdfc:	d7 03 d7 03                                         ....
