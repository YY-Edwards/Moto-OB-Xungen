
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000a6bc  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000c800  8000c800  0000cc00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001138  8000ca00  8000ca00  0000ce00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a38  00000004  8000db38  0000e004  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .balign       00000004  00000a3c  8000e570  0000ea3c  2**0
                  ALLOC
  7 .bss          000046e0  00000a40  8000e570  0000ea40  2**2
                  ALLOC
  8 .comment      00000030  00000000  00000000  0000ea3c  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001290  00000000  00000000  0000ea70  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 000028a8  00000000  00000000  0000fd00  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   00029cb5  00000000  00000000  000125a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00006d07  00000000  00000000  0003c25d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   000162a1  00000000  00000000  00042f64  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000031c4  00000000  00000000  00059208  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    000072a0  00000000  00000000  0005c3cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000d997  00000000  00000000  0006366c  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_macinfo 0162e0a1  00000000  00000000  00071003  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 19 .debug_ranges 00001368  00000000  00000000  0169f0a8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c9 1c 	sub	pc,pc,-14052

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d 8c       	ld.ub	r12,r6[0x0]

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 58       	eor	r8,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 04       	add	r4,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	3c e8       	mov	r8,-50
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 fc       	sub	r12,15
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	21 10       	sub	r0,17
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	28 f0       	sub	r0,-113
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	ca 00       	breq	80001fc2 <_trampoline+0x1fc2>
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	20 90       	sub	r0,9
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	65 dc       	ld.w	r12,r2[0x74]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 50       	eor	r0,r5

80002090 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
80002090:	eb cd 40 fc 	pushm	r2-r7,lr
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	
	 xLastWakeTime = xTaskGetTickCount();
80002094:	f0 1f 00 13 	mcall	800020e0 <app_cfg+0x50>
80002098:	49 38       	lddpc	r8,800020e4 <app_cfg+0x54>
8000209a:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
8000209c:	49 36       	lddpc	r6,800020e8 <app_cfg+0x58>
		{	
			xcmp_IdleTestTone(Priority_Beep);
			connect_flag=1;	
		}
		else if(connect_flag)
8000209e:	49 47       	lddpc	r7,800020ec <app_cfg+0x5c>
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
		{	
			xcmp_IdleTestTone(Priority_Beep);
800020a0:	30 c2       	mov	r2,12
			connect_flag=1;	
800020a2:	30 13       	mov	r3,1
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020a4:	10 95       	mov	r5,r8
800020a6:	e0 64 0f a0 	mov	r4,4000
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800020aa:	6c 08       	ld.w	r8,r6[0x0]
800020ac:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800020b0:	58 38       	cp.w	r8,3
800020b2:	c0 91       	brne	800020c4 <app_cfg+0x34>
800020b4:	0f 88       	ld.ub	r8,r7[0x0]
800020b6:	58 08       	cp.w	r8,0
800020b8:	c0 61       	brne	800020c4 <app_cfg+0x34>
		{	
			xcmp_IdleTestTone(Priority_Beep);
800020ba:	04 9c       	mov	r12,r2
800020bc:	f0 1f 00 0d 	mcall	800020f0 <app_cfg+0x60>
			connect_flag=1;	
800020c0:	ae 83       	st.b	r7[0x0],r3
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800020c2:	c0 a8       	rjmp	800020d6 <app_cfg+0x46>
		{	
			xcmp_IdleTestTone(Priority_Beep);
			connect_flag=1;	
		}
		else if(connect_flag)
800020c4:	0f 88       	ld.ub	r8,r7[0x0]
800020c6:	58 08       	cp.w	r8,0
800020c8:	c0 40       	breq	800020d0 <app_cfg+0x40>
		{
				
				rfid_sendID_message();
800020ca:	f0 1f 00 0b 	mcall	800020f4 <app_cfg+0x64>
800020ce:	c0 48       	rjmp	800020d6 <app_cfg+0x46>
				//}
				
		}
		else
		{
			nop();
800020d0:	d7 03       	nop
			nop();
800020d2:	d7 03       	nop
			nop();
800020d4:	d7 03       	nop
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020d6:	08 9b       	mov	r11,r4
800020d8:	0a 9c       	mov	r12,r5
800020da:	f0 1f 00 08 	mcall	800020f8 <app_cfg+0x68>
	}
800020de:	ce 6b       	rjmp	800020aa <app_cfg+0x1a>
800020e0:	80 00       	ld.sh	r0,r0[0x0]
800020e2:	63 14       	ld.w	r4,r1[0x44]
800020e4:	00 00       	add	r0,r0
800020e6:	0a 48       	or	r8,r5
800020e8:	00 00       	add	r0,r0
800020ea:	0d 8c       	ld.ub	r12,r6[0x0]
800020ec:	00 00       	add	r0,r0
800020ee:	0a 54       	eor	r4,r5
800020f0:	80 00       	ld.sh	r0,r0[0x0]
800020f2:	3e 74       	mov	r4,-25
800020f4:	80 00       	ld.sh	r0,r0[0x0]
800020f6:	4e a0       	lddpc	r0,8000229c <ButtonConfig_brdcst_func+0x7c>
800020f8:	80 00       	ld.sh	r0,r0[0x0]
800020fa:	64 7c       	ld.w	r12,r2[0x1c]

800020fc <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
800020fc:	d4 01       	pushm	lr
  log("R");
800020fe:	48 3c       	lddpc	r12,80002108 <app_payload_tx_proc+0xc>
80002100:	f0 1f 00 03 	mcall	8000210c <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002104:	d8 02       	popm	pc
80002106:	00 00       	add	r0,r0
80002108:	80 00       	ld.sh	r0,r0[0x0]
8000210a:	ca 08       	rjmp	8000224a <ButtonConfig_brdcst_func+0x2a>
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	69 a0       	ld.w	r0,r4[0x68]

80002110 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
80002110:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
80002112:	48 99       	lddpc	r9,80002134 <app_payload_rx_proc+0x24>
80002114:	13 88       	ld.ub	r8,r9[0x0]
80002116:	2f f8       	sub	r8,-1
80002118:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
8000211a:	30 39       	mov	r9,3
8000211c:	f2 08 18 00 	cp.b	r8,r9
80002120:	c0 71       	brne	8000212e <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
80002122:	30 09       	mov	r9,0
80002124:	48 48       	lddpc	r8,80002134 <app_payload_rx_proc+0x24>
80002126:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002128:	48 4c       	lddpc	r12,80002138 <app_payload_rx_proc+0x28>
8000212a:	f0 1f 00 05 	mcall	8000213c <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
8000212e:	48 58       	lddpc	r8,80002140 <app_payload_rx_proc+0x30>
80002130:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
80002132:	d8 02       	popm	pc
80002134:	00 00       	add	r0,r0
80002136:	0a 55       	eor	r5,r5
80002138:	80 00       	ld.sh	r0,r0[0x0]
8000213a:	ca 0c       	rcall	8000227a <ButtonConfig_brdcst_func+0x5a>
8000213c:	80 00       	ld.sh	r0,r0[0x0]
8000213e:	69 a0       	ld.w	r0,r4[0x68]
80002140:	00 00       	add	r0,r0
80002142:	0a 43       	or	r3,r5

80002144 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
80002144:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
80002146:	48 3c       	lddpc	r12,80002150 <FD_brdcst_func+0xc>
80002148:	f0 1f 00 03 	mcall	80002154 <FD_brdcst_func+0x10>
	
}
8000214c:	d8 02       	popm	pc
8000214e:	00 00       	add	r0,r0
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	ca 18       	rjmp	80002294 <ButtonConfig_brdcst_func+0x74>
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	69 a0       	ld.w	r0,r4[0x68]

80002158 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
80002158:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
8000215a:	48 3c       	lddpc	r12,80002164 <FD_reply_func+0xc>
8000215c:	f0 1f 00 03 	mcall	80002168 <FD_reply_func+0x10>
	
	
}
80002160:	d8 02       	popm	pc
80002162:	00 00       	add	r0,r0
80002164:	80 00       	ld.sh	r0,r0[0x0]
80002166:	ca 38       	rjmp	800022ac <ButtonConfig_brdcst_func+0x8c>
80002168:	80 00       	ld.sh	r0,r0[0x0]
8000216a:	69 a0       	ld.w	r0,r4[0x68]

8000216c <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
8000216c:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
8000216e:	48 3c       	lddpc	r12,80002178 <FD_request_func+0xc>
80002170:	f0 1f 00 03 	mcall	8000217c <FD_request_func+0x10>
	
	
}
80002174:	d8 02       	popm	pc
80002176:	00 00       	add	r0,r0
80002178:	80 00       	ld.sh	r0,r0[0x0]
8000217a:	ca 54       	brge	800020c4 <app_cfg+0x34>
8000217c:	80 00       	ld.sh	r0,r0[0x0]
8000217e:	69 a0       	ld.w	r0,r4[0x68]

80002180 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002180:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002182:	48 3c       	lddpc	r12,8000218c <EnOB_brdcst_func+0xc>
80002184:	f0 1f 00 03 	mcall	80002190 <EnOB_brdcst_func+0x10>
}
80002188:	d8 02       	popm	pc
8000218a:	00 00       	add	r0,r0
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	ca 70       	breq	800020dc <app_cfg+0x4c>
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	69 a0       	ld.w	r0,r4[0x68]

80002194 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002194:	eb cd 40 80 	pushm	r7,lr
80002198:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000219a:	19 a9       	ld.ub	r9,r12[0x2]
8000219c:	30 08       	mov	r8,0
8000219e:	f0 09 18 00 	cp.b	r9,r8
800021a2:	c1 91       	brne	800021d4 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
800021a4:	19 b8       	ld.ub	r8,r12[0x3]
800021a6:	30 19       	mov	r9,1
800021a8:	f2 08 18 00 	cp.b	r8,r9
800021ac:	c0 61       	brne	800021b8 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
800021ae:	49 0c       	lddpc	r12,800021ec <EnOB_reply_func+0x58>
800021b0:	f0 1f 00 10 	mcall	800021f0 <EnOB_reply_func+0x5c>
800021b4:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
800021b8:	58 08       	cp.w	r8,0
800021ba:	c0 61       	brne	800021c6 <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
800021bc:	48 ec       	lddpc	r12,800021f4 <EnOB_reply_func+0x60>
800021be:	f0 1f 00 0d 	mcall	800021f0 <EnOB_reply_func+0x5c>
800021c2:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
800021c6:	1a d8       	st.w	--sp,r8
800021c8:	48 cc       	lddpc	r12,800021f8 <EnOB_reply_func+0x64>
800021ca:	f0 1f 00 0a 	mcall	800021f0 <EnOB_reply_func+0x5c>
800021ce:	2f fd       	sub	sp,-4
800021d0:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
800021d4:	48 ac       	lddpc	r12,800021fc <EnOB_reply_func+0x68>
800021d6:	f0 1f 00 07 	mcall	800021f0 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
800021da:	0f a8       	ld.ub	r8,r7[0x2]
800021dc:	1a d8       	st.w	--sp,r8
800021de:	48 9c       	lddpc	r12,80002200 <EnOB_reply_func+0x6c>
800021e0:	f0 1f 00 04 	mcall	800021f0 <EnOB_reply_func+0x5c>
800021e4:	2f fd       	sub	sp,-4
800021e6:	e3 cd 80 80 	ldm	sp++,r7,pc
800021ea:	00 00       	add	r0,r0
800021ec:	80 00       	ld.sh	r0,r0[0x0]
800021ee:	ca 88       	rjmp	8000233e <Phyuserinput_brdcst_func+0x42>
800021f0:	80 00       	ld.sh	r0,r0[0x0]
800021f2:	69 a0       	ld.w	r0,r4[0x68]
800021f4:	80 00       	ld.sh	r0,r0[0x0]
800021f6:	ca a0       	breq	8000214a <FD_brdcst_func+0x6>
800021f8:	80 00       	ld.sh	r0,r0[0x0]
800021fa:	ca b4       	brge	80002150 <FD_brdcst_func+0xc>
800021fc:	80 00       	ld.sh	r0,r0[0x0]
800021fe:	ca cc       	rcall	80002356 <ButtonConfig_reply_func+0x16>
80002200:	80 00       	ld.sh	r0,r0[0x0]
80002202:	ca e8       	rjmp	8000235e <ButtonConfig_reply_func+0x1e>

80002204 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002204:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
80002206:	19 a9       	ld.ub	r9,r12[0x2]
80002208:	31 18       	mov	r8,17
8000220a:	f0 09 18 00 	cp.b	r9,r8
8000220e:	c0 41       	brne	80002216 <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002210:	48 2c       	lddpc	r12,80002218 <SingleDetection_brdcst_func+0x14>
80002212:	f0 1f 00 03 	mcall	8000221c <SingleDetection_brdcst_func+0x18>
80002216:	d8 02       	popm	pc
80002218:	80 00       	ld.sh	r0,r0[0x0]
8000221a:	cb 00       	breq	8000217a <FD_request_func+0xe>
8000221c:	80 00       	ld.sh	r0,r0[0x0]
8000221e:	69 a0       	ld.w	r0,r4[0x68]

80002220 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002220:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
80002222:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
80002226:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002228:	4a bc       	lddpc	r12,800022d4 <ButtonConfig_brdcst_func+0xb4>
8000222a:	f0 1f 00 2c 	mcall	800022d8 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
8000222e:	0f 88       	ld.ub	r8,r7[0x0]
80002230:	1a d8       	st.w	--sp,r8
80002232:	4a bc       	lddpc	r12,800022dc <ButtonConfig_brdcst_func+0xbc>
80002234:	f0 1f 00 29 	mcall	800022d8 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
80002238:	1a d5       	st.w	--sp,r5
8000223a:	4a ac       	lddpc	r12,800022e0 <ButtonConfig_brdcst_func+0xc0>
8000223c:	f0 1f 00 27 	mcall	800022d8 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002240:	0f a8       	ld.ub	r8,r7[0x2]
80002242:	1a d8       	st.w	--sp,r8
80002244:	4a 8c       	lddpc	r12,800022e4 <ButtonConfig_brdcst_func+0xc4>
80002246:	f0 1f 00 25 	mcall	800022d8 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000224a:	2f dd       	sub	sp,-12
8000224c:	58 05       	cp.w	r5,0
8000224e:	c4 10       	breq	800022d0 <ButtonConfig_brdcst_func+0xb0>
80002250:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002252:	4a 64       	lddpc	r4,800022e8 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002254:	4a 63       	lddpc	r3,800022ec <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002256:	4a 72       	lddpc	r2,800022f0 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002258:	4a 71       	lddpc	r1,800022f4 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000225a:	4a 80       	lddpc	r0,800022f8 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
8000225c:	0f b9       	ld.ub	r9,r7[0x3]
8000225e:	0f c8       	ld.ub	r8,r7[0x4]
80002260:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002264:	1a d8       	st.w	--sp,r8
80002266:	1a d6       	st.w	--sp,r6
80002268:	08 9c       	mov	r12,r4
8000226a:	f0 1f 00 1c 	mcall	800022d8 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
8000226e:	0f d9       	ld.ub	r9,r7[0x5]
80002270:	0f e8       	ld.ub	r8,r7[0x6]
80002272:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002276:	1a d8       	st.w	--sp,r8
80002278:	1a d6       	st.w	--sp,r6
8000227a:	06 9c       	mov	r12,r3
8000227c:	f0 1f 00 17 	mcall	800022d8 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002280:	0f f9       	ld.ub	r9,r7[0x7]
80002282:	ef 38 00 08 	ld.ub	r8,r7[8]
80002286:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000228a:	1a d8       	st.w	--sp,r8
8000228c:	1a d6       	st.w	--sp,r6
8000228e:	04 9c       	mov	r12,r2
80002290:	f0 1f 00 12 	mcall	800022d8 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002294:	ef 39 00 09 	ld.ub	r9,r7[9]
80002298:	ef 38 00 0a 	ld.ub	r8,r7[10]
8000229c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022a0:	1a d8       	st.w	--sp,r8
800022a2:	1a d6       	st.w	--sp,r6
800022a4:	02 9c       	mov	r12,r1
800022a6:	f0 1f 00 0d 	mcall	800022d8 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800022aa:	2f 8d       	sub	sp,-32
800022ac:	ef 39 00 0b 	ld.ub	r9,r7[11]
800022b0:	ef 38 00 0c 	ld.ub	r8,r7[12]
800022b4:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022b8:	1a d8       	st.w	--sp,r8
800022ba:	1a d6       	st.w	--sp,r6
800022bc:	00 9c       	mov	r12,r0
800022be:	f0 1f 00 07 	mcall	800022d8 <ButtonConfig_brdcst_func+0xb8>
800022c2:	2f f6       	sub	r6,-1
800022c4:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
800022c6:	2f ed       	sub	sp,-8
800022c8:	ec 05 18 00 	cp.b	r5,r6
800022cc:	fe 9b ff c8 	brhi	8000225c <ButtonConfig_brdcst_func+0x3c>
800022d0:	d8 32       	popm	r0-r7,pc
800022d2:	00 00       	add	r0,r0
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	cb 14       	brge	80002238 <ButtonConfig_brdcst_func+0x18>
800022d8:	80 00       	ld.sh	r0,r0[0x0]
800022da:	69 a0       	ld.w	r0,r4[0x68]
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	cb 34       	brge	80002244 <ButtonConfig_brdcst_func+0x24>
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	cb 48       	rjmp	8000244a <DataSession_brdcst_func+0xc6>
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	cb 60       	breq	80002252 <ButtonConfig_brdcst_func+0x32>
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	cb 80       	breq	8000225a <ButtonConfig_brdcst_func+0x3a>
800022ec:	80 00       	ld.sh	r0,r0[0x0]
800022ee:	cb a8       	rjmp	80002462 <DataSession_brdcst_func+0xde>
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	cb d0       	breq	8000226c <ButtonConfig_brdcst_func+0x4c>
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	cb f4       	brge	80002274 <ButtonConfig_brdcst_func+0x54>
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	cc 1c       	rcall	8000247c <DataSession_reply_func+0x18>

800022fc <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800022fc:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002300:	19 c7       	ld.ub	r7,r12[0x4]
80002302:	19 d8       	ld.ub	r8,r12[0x5]
80002304:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002308:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
8000230a:	48 ac       	lddpc	r12,80002330 <Phyuserinput_brdcst_func+0x34>
8000230c:	f0 1f 00 0a 	mcall	80002334 <Phyuserinput_brdcst_func+0x38>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
80002310:	36 08       	mov	r8,96
80002312:	f0 07 19 00 	cp.h	r7,r8
80002316:	c0 a1       	brne	8000232a <Phyuserinput_brdcst_func+0x2e>
80002318:	48 88       	lddpc	r8,80002338 <Phyuserinput_brdcst_func+0x3c>
8000231a:	11 89       	ld.ub	r9,r8[0x0]
8000231c:	30 18       	mov	r8,1
8000231e:	f0 09 18 00 	cp.b	r9,r8
80002322:	c0 41       	brne	8000232a <Phyuserinput_brdcst_func+0x2e>
		log("send message\n");
80002324:	48 6c       	lddpc	r12,8000233c <Phyuserinput_brdcst_func+0x40>
80002326:	f0 1f 00 04 	mcall	80002334 <Phyuserinput_brdcst_func+0x38>
8000232a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000232e:	00 00       	add	r0,r0
80002330:	80 00       	ld.sh	r0,r0[0x0]
80002332:	cc 40       	breq	800022ba <ButtonConfig_brdcst_func+0x9a>
80002334:	80 00       	ld.sh	r0,r0[0x0]
80002336:	69 a0       	ld.w	r0,r4[0x68]
80002338:	00 00       	add	r0,r0
8000233a:	0a 54       	eor	r4,r5
8000233c:	80 00       	ld.sh	r0,r0[0x0]
8000233e:	cc 60       	breq	800022ca <ButtonConfig_brdcst_func+0xaa>

80002340 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002340:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002344:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002348:	0f 89       	ld.ub	r9,r7[0x0]
8000234a:	30 08       	mov	r8,0
8000234c:	f0 09 18 00 	cp.b	r9,r8
80002350:	c0 c1       	brne	80002368 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
80002352:	48 9c       	lddpc	r12,80002374 <ButtonConfig_reply_func+0x34>
80002354:	f0 1f 00 09 	mcall	80002378 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002358:	0f 98       	ld.ub	r8,r7[0x1]
8000235a:	1a d8       	st.w	--sp,r8
8000235c:	48 8c       	lddpc	r12,8000237c <ButtonConfig_reply_func+0x3c>
8000235e:	f0 1f 00 07 	mcall	80002378 <ButtonConfig_reply_func+0x38>
80002362:	2f fd       	sub	sp,-4
80002364:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002368:	48 6c       	lddpc	r12,80002380 <ButtonConfig_reply_func+0x40>
8000236a:	f0 1f 00 04 	mcall	80002378 <ButtonConfig_reply_func+0x38>
8000236e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002372:	00 00       	add	r0,r0
80002374:	80 00       	ld.sh	r0,r0[0x0]
80002376:	cc 70       	breq	80002304 <Phyuserinput_brdcst_func+0x8>
80002378:	80 00       	ld.sh	r0,r0[0x0]
8000237a:	69 a0       	ld.w	r0,r4[0x68]
8000237c:	80 00       	ld.sh	r0,r0[0x0]
8000237e:	cb 34       	brge	800022e4 <ButtonConfig_brdcst_func+0xc4>
80002380:	80 00       	ld.sh	r0,r0[0x0]
80002382:	cc 88       	rjmp	80002512 <CallControl_brdcst_func+0x32>

80002384 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002384:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002386:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
8000238a:	0d 88       	ld.ub	r8,r6[0x0]
8000238c:	32 49       	mov	r9,36
8000238e:	f2 08 18 00 	cp.b	r8,r9
80002392:	c2 91       	brne	800023e4 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002394:	4a dc       	lddpc	r12,80002448 <DataSession_brdcst_func+0xc4>
80002396:	f0 1f 00 2e 	mcall	8000244c <DataSession_brdcst_func+0xc8>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
8000239a:	0d a5       	ld.ub	r5,r6[0x2]
8000239c:	0d b8       	ld.ub	r8,r6[0x3]
8000239e:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800023a2:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800023a4:	0d 98       	ld.ub	r8,r6[0x1]
800023a6:	1a d8       	st.w	--sp,r8
800023a8:	4a ac       	lddpc	r12,80002450 <DataSession_brdcst_func+0xcc>
800023aa:	f0 1f 00 29 	mcall	8000244c <DataSession_brdcst_func+0xc8>
		log("\n\r paylaod_length: %d \n\r",data_length );
800023ae:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800023b2:	1a d8       	st.w	--sp,r8
800023b4:	4a 8c       	lddpc	r12,80002454 <DataSession_brdcst_func+0xd0>
800023b6:	f0 1f 00 26 	mcall	8000244c <DataSession_brdcst_func+0xc8>
		for(i=0; i<data_length; i++)
800023ba:	2f ed       	sub	sp,-8
800023bc:	58 05       	cp.w	r5,0
800023be:	c4 40       	breq	80002446 <DataSession_brdcst_func+0xc2>
800023c0:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
800023c2:	4a 64       	lddpc	r4,80002458 <DataSession_brdcst_func+0xd4>
800023c4:	ec 07 00 08 	add	r8,r6,r7
800023c8:	11 c8       	ld.ub	r8,r8[0x4]
800023ca:	1a d8       	st.w	--sp,r8
800023cc:	1a d7       	st.w	--sp,r7
800023ce:	08 9c       	mov	r12,r4
800023d0:	f0 1f 00 1f 	mcall	8000244c <DataSession_brdcst_func+0xc8>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
800023d4:	2f f7       	sub	r7,-1
800023d6:	5c 57       	castu.b	r7
800023d8:	2f ed       	sub	sp,-8
800023da:	ee 05 19 00 	cp.h	r5,r7
800023de:	fe 9b ff f3 	brhi	800023c4 <DataSession_brdcst_func+0x40>
800023e2:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("State: 0x %X \n", ptr->State);
800023e4:	1a d8       	st.w	--sp,r8
800023e6:	49 ec       	lddpc	r12,8000245c <DataSession_brdcst_func+0xd8>
800023e8:	f0 1f 00 19 	mcall	8000244c <DataSession_brdcst_func+0xc8>
		if (ptr->State)
800023ec:	2f fd       	sub	sp,-4
800023ee:	0d 89       	ld.ub	r9,r6[0x0]
800023f0:	30 08       	mov	r8,0
800023f2:	f0 09 18 00 	cp.b	r9,r8
800023f6:	c0 40       	breq	800023fe <DataSession_brdcst_func+0x7a>
		{
			log("data transmit success\n");
800023f8:	49 ac       	lddpc	r12,80002460 <DataSession_brdcst_func+0xdc>
800023fa:	f0 1f 00 15 	mcall	8000244c <DataSession_brdcst_func+0xc8>
		}
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
			
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800023fe:	0d a5       	ld.ub	r5,r6[0x2]
80002400:	0d b8       	ld.ub	r8,r6[0x3]
80002402:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002406:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002408:	0d 98       	ld.ub	r8,r6[0x1]
8000240a:	1a d8       	st.w	--sp,r8
8000240c:	49 1c       	lddpc	r12,80002450 <DataSession_brdcst_func+0xcc>
8000240e:	f0 1f 00 10 	mcall	8000244c <DataSession_brdcst_func+0xc8>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002412:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002416:	1a d8       	st.w	--sp,r8
80002418:	48 fc       	lddpc	r12,80002454 <DataSession_brdcst_func+0xd0>
8000241a:	f0 1f 00 0d 	mcall	8000244c <DataSession_brdcst_func+0xc8>
		for(i=0; i<data_length; i++)
8000241e:	2f ed       	sub	sp,-8
80002420:	58 05       	cp.w	r5,0
80002422:	c1 20       	breq	80002446 <DataSession_brdcst_func+0xc2>
80002424:	30 07       	mov	r7,0
		{
				
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002426:	48 d4       	lddpc	r4,80002458 <DataSession_brdcst_func+0xd4>
80002428:	ec 07 00 08 	add	r8,r6,r7
8000242c:	11 c8       	ld.ub	r8,r8[0x4]
8000242e:	1a d8       	st.w	--sp,r8
80002430:	1a d7       	st.w	--sp,r7
80002432:	08 9c       	mov	r12,r4
80002434:	f0 1f 00 06 	mcall	8000244c <DataSession_brdcst_func+0xc8>
			
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002438:	2f f7       	sub	r7,-1
8000243a:	5c 57       	castu.b	r7
8000243c:	2f ed       	sub	sp,-8
8000243e:	ee 05 19 00 	cp.h	r5,r7
80002442:	fe 9b ff f3 	brhi	80002428 <DataSession_brdcst_func+0xa4>
80002446:	d8 22       	popm	r4-r7,pc
80002448:	80 00       	ld.sh	r0,r0[0x0]
8000244a:	cc a4       	brge	800023de <DataSession_brdcst_func+0x5a>
8000244c:	80 00       	ld.sh	r0,r0[0x0]
8000244e:	69 a0       	ld.w	r0,r4[0x68]
80002450:	80 00       	ld.sh	r0,r0[0x0]
80002452:	cc b8       	rjmp	800025e8 <AudioRoutingControl_reply_func+0x1c>
80002454:	80 00       	ld.sh	r0,r0[0x0]
80002456:	cc d0       	breq	800023f0 <DataSession_brdcst_func+0x6c>
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	cc ec       	rcall	800025f6 <Volume_reply_func+0x2>
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	cd 04       	brge	800023fe <DataSession_brdcst_func+0x7a>
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	cd 14       	brge	80002404 <DataSession_brdcst_func+0x80>

80002464 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002464:	eb cd 40 80 	pushm	r7,lr
80002468:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000246a:	19 a9       	ld.ub	r9,r12[0x2]
8000246c:	30 08       	mov	r8,0
8000246e:	f0 09 18 00 	cp.b	r9,r8
80002472:	c1 11       	brne	80002494 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
80002474:	49 3c       	lddpc	r12,800024c0 <DataSession_reply_func+0x5c>
80002476:	f0 1f 00 14 	mcall	800024c4 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
8000247a:	0f b8       	ld.ub	r8,r7[0x3]
8000247c:	1a d8       	st.w	--sp,r8
8000247e:	49 3c       	lddpc	r12,800024c8 <DataSession_reply_func+0x64>
80002480:	f0 1f 00 11 	mcall	800024c4 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
80002484:	0f c8       	ld.ub	r8,r7[0x4]
80002486:	1a d8       	st.w	--sp,r8
80002488:	49 1c       	lddpc	r12,800024cc <DataSession_reply_func+0x68>
8000248a:	f0 1f 00 0f 	mcall	800024c4 <DataSession_reply_func+0x60>
8000248e:	2f ed       	sub	sp,-8
80002490:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
80002494:	48 fc       	lddpc	r12,800024d0 <DataSession_reply_func+0x6c>
80002496:	f0 1f 00 0c 	mcall	800024c4 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
8000249a:	0f a8       	ld.ub	r8,r7[0x2]
8000249c:	1a d8       	st.w	--sp,r8
8000249e:	48 ec       	lddpc	r12,800024d4 <DataSession_reply_func+0x70>
800024a0:	f0 1f 00 09 	mcall	800024c4 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
800024a4:	0f b8       	ld.ub	r8,r7[0x3]
800024a6:	1a d8       	st.w	--sp,r8
800024a8:	48 cc       	lddpc	r12,800024d8 <DataSession_reply_func+0x74>
800024aa:	f0 1f 00 07 	mcall	800024c4 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
800024ae:	0f c8       	ld.ub	r8,r7[0x4]
800024b0:	1a d8       	st.w	--sp,r8
800024b2:	48 bc       	lddpc	r12,800024dc <DataSession_reply_func+0x78>
800024b4:	f0 1f 00 04 	mcall	800024c4 <DataSession_reply_func+0x60>
800024b8:	2f dd       	sub	sp,-12
800024ba:	e3 cd 80 80 	ldm	sp++,r7,pc
800024be:	00 00       	add	r0,r0
800024c0:	80 00       	ld.sh	r0,r0[0x0]
800024c2:	cd 2c       	rcall	80002666 <spk_brdcst_func+0xe>
800024c4:	80 00       	ld.sh	r0,r0[0x0]
800024c6:	69 a0       	ld.w	r0,r4[0x68]
800024c8:	80 00       	ld.sh	r0,r0[0x0]
800024ca:	cd 3c       	rcall	80002670 <spk_brdcst_func+0x18>
800024cc:	80 00       	ld.sh	r0,r0[0x0]
800024ce:	cd 48       	rjmp	80002676 <spk_brdcst_func+0x1e>
800024d0:	80 00       	ld.sh	r0,r0[0x0]
800024d2:	cd 54       	brge	8000247c <DataSession_reply_func+0x18>
800024d4:	80 00       	ld.sh	r0,r0[0x0]
800024d6:	cd 64       	brge	80002482 <DataSession_reply_func+0x1e>
800024d8:	80 00       	ld.sh	r0,r0[0x0]
800024da:	cd 74       	brge	80002488 <DataSession_reply_func+0x24>
800024dc:	80 00       	ld.sh	r0,r0[0x0]
800024de:	cd 80       	breq	8000248e <DataSession_reply_func+0x2a>

800024e0 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800024e0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
800024e4:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
800024e8:	0f 98       	ld.ub	r8,r7[0x1]
800024ea:	1a d8       	st.w	--sp,r8
800024ec:	48 bc       	lddpc	r12,80002518 <CallControl_brdcst_func+0x38>
800024ee:	f0 1f 00 0c 	mcall	8000251c <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
800024f2:	2f fd       	sub	sp,-4
800024f4:	0f 99       	ld.ub	r9,r7[0x1]
800024f6:	30 38       	mov	r8,3
800024f8:	f0 09 18 00 	cp.b	r9,r8
800024fc:	c0 41       	brne	80002504 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
800024fe:	30 09       	mov	r9,0
80002500:	48 88       	lddpc	r8,80002520 <CallControl_brdcst_func+0x40>
80002502:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
80002504:	0f 99       	ld.ub	r9,r7[0x1]
80002506:	30 48       	mov	r8,4
80002508:	f0 09 18 00 	cp.b	r9,r8
8000250c:	c0 41       	brne	80002514 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
8000250e:	30 19       	mov	r9,1
80002510:	48 48       	lddpc	r8,80002520 <CallControl_brdcst_func+0x40>
80002512:	b0 89       	st.b	r8[0x0],r9
80002514:	e3 cd 80 80 	ldm	sp++,r7,pc
80002518:	80 00       	ld.sh	r0,r0[0x0]
8000251a:	cd 8c       	rcall	800026ca <spk_reply_func+0x3a>
8000251c:	80 00       	ld.sh	r0,r0[0x0]
8000251e:	69 a0       	ld.w	r0,r4[0x68]
80002520:	00 00       	add	r0,r0
80002522:	0a 45       	or	r5,r5

80002524 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002524:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002528:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
8000252c:	0f 99       	ld.ub	r9,r7[0x1]
8000252e:	30 08       	mov	r8,0
80002530:	f0 09 18 00 	cp.b	r9,r8
80002534:	c0 71       	brne	80002542 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
80002536:	48 ac       	lddpc	r12,8000255c <TransmitControl_brdcst_func+0x38>
80002538:	f0 1f 00 0a 	mcall	80002560 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
8000253c:	30 09       	mov	r9,0
8000253e:	48 a8       	lddpc	r8,80002564 <TransmitControl_brdcst_func+0x40>
80002540:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
80002542:	0f 99       	ld.ub	r9,r7[0x1]
80002544:	30 18       	mov	r8,1
80002546:	f0 09 18 00 	cp.b	r9,r8
8000254a:	c0 71       	brne	80002558 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
8000254c:	48 7c       	lddpc	r12,80002568 <TransmitControl_brdcst_func+0x44>
8000254e:	f0 1f 00 05 	mcall	80002560 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
80002552:	30 19       	mov	r9,1
80002554:	48 48       	lddpc	r8,80002564 <TransmitControl_brdcst_func+0x40>
80002556:	b0 89       	st.b	r8[0x0],r9
80002558:	e3 cd 80 80 	ldm	sp++,r7,pc
8000255c:	80 00       	ld.sh	r0,r0[0x0]
8000255e:	cd a4       	brge	80002512 <CallControl_brdcst_func+0x32>
80002560:	80 00       	ld.sh	r0,r0[0x0]
80002562:	69 a0       	ld.w	r0,r4[0x68]
80002564:	00 00       	add	r0,r0
80002566:	0a 44       	or	r4,r5
80002568:	80 00       	ld.sh	r0,r0[0x0]
8000256a:	cd bc       	rcall	80002720 <mic_brdcst_func+0x48>

8000256c <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
8000256c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002570:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002574:	0f 89       	ld.ub	r9,r7[0x0]
80002576:	30 08       	mov	r8,0
80002578:	f0 09 18 00 	cp.b	r9,r8
8000257c:	c1 61       	brne	800025a8 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000257e:	48 ec       	lddpc	r12,800025b4 <TransmitControl_reply_func+0x48>
80002580:	f0 1f 00 0e 	mcall	800025b8 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002584:	0f 98       	ld.ub	r8,r7[0x1]
80002586:	1a d8       	st.w	--sp,r8
80002588:	48 dc       	lddpc	r12,800025bc <TransmitControl_reply_func+0x50>
8000258a:	f0 1f 00 0c 	mcall	800025b8 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000258e:	0f a8       	ld.ub	r8,r7[0x2]
80002590:	1a d8       	st.w	--sp,r8
80002592:	48 cc       	lddpc	r12,800025c0 <TransmitControl_reply_func+0x54>
80002594:	f0 1f 00 09 	mcall	800025b8 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002598:	0f b8       	ld.ub	r8,r7[0x3]
8000259a:	1a d8       	st.w	--sp,r8
8000259c:	48 ac       	lddpc	r12,800025c4 <TransmitControl_reply_func+0x58>
8000259e:	f0 1f 00 07 	mcall	800025b8 <TransmitControl_reply_func+0x4c>
800025a2:	2f dd       	sub	sp,-12
800025a4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
800025a8:	48 8c       	lddpc	r12,800025c8 <TransmitControl_reply_func+0x5c>
800025aa:	f0 1f 00 04 	mcall	800025b8 <TransmitControl_reply_func+0x4c>
800025ae:	e3 cd 80 80 	ldm	sp++,r7,pc
800025b2:	00 00       	add	r0,r0
800025b4:	80 00       	ld.sh	r0,r0[0x0]
800025b6:	cd d0       	breq	80002570 <TransmitControl_reply_func+0x4>
800025b8:	80 00       	ld.sh	r0,r0[0x0]
800025ba:	69 a0       	ld.w	r0,r4[0x68]
800025bc:	80 00       	ld.sh	r0,r0[0x0]
800025be:	cd ec       	rcall	8000277a <mic_reply_func+0x4a>
800025c0:	80 00       	ld.sh	r0,r0[0x0]
800025c2:	ce 00       	breq	80002582 <TransmitControl_reply_func+0x16>
800025c4:	80 00       	ld.sh	r0,r0[0x0]
800025c6:	ce 1c       	rcall	80002788 <mic_reply_func+0x58>
800025c8:	80 00       	ld.sh	r0,r0[0x0]
800025ca:	ce 2c       	rcall	8000278e <mic_reply_func+0x5e>

800025cc <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
800025cc:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800025ce:	19 a9       	ld.ub	r9,r12[0x2]
800025d0:	30 08       	mov	r8,0
800025d2:	f0 09 18 00 	cp.b	r9,r8
800025d6:	c0 51       	brne	800025e0 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
800025d8:	48 4c       	lddpc	r12,800025e8 <AudioRoutingControl_reply_func+0x1c>
800025da:	f0 1f 00 05 	mcall	800025ec <AudioRoutingControl_reply_func+0x20>
800025de:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
800025e0:	48 4c       	lddpc	r12,800025f0 <AudioRoutingControl_reply_func+0x24>
800025e2:	f0 1f 00 03 	mcall	800025ec <AudioRoutingControl_reply_func+0x20>
800025e6:	d8 02       	popm	pc
800025e8:	80 00       	ld.sh	r0,r0[0x0]
800025ea:	ce 44       	brge	800025b2 <TransmitControl_reply_func+0x46>
800025ec:	80 00       	ld.sh	r0,r0[0x0]
800025ee:	69 a0       	ld.w	r0,r4[0x68]
800025f0:	80 00       	ld.sh	r0,r0[0x0]
800025f2:	ce 54       	brge	800025bc <TransmitControl_reply_func+0x50>

800025f4 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
800025f4:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
800025f8:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
800025fc:	0f 89       	ld.ub	r9,r7[0x0]
800025fe:	30 08       	mov	r8,0
80002600:	f0 09 18 00 	cp.b	r9,r8
80002604:	c1 b1       	brne	8000263a <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002606:	0f b8       	ld.ub	r8,r7[0x3]
80002608:	31 09       	mov	r9,16
8000260a:	f2 08 18 00 	cp.b	r8,r9
8000260e:	c0 f1       	brne	8000262c <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002610:	48 dc       	lddpc	r12,80002644 <Volume_reply_func+0x50>
80002612:	f0 1f 00 0e 	mcall	80002648 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002616:	0f 99       	ld.ub	r9,r7[0x1]
80002618:	0f a8       	ld.ub	r8,r7[0x2]
8000261a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000261e:	1a d8       	st.w	--sp,r8
80002620:	48 bc       	lddpc	r12,8000264c <Volume_reply_func+0x58>
80002622:	f0 1f 00 0a 	mcall	80002648 <Volume_reply_func+0x54>
80002626:	2f fd       	sub	sp,-4
80002628:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
8000262c:	1a d8       	st.w	--sp,r8
8000262e:	48 9c       	lddpc	r12,80002650 <Volume_reply_func+0x5c>
80002630:	f0 1f 00 06 	mcall	80002648 <Volume_reply_func+0x54>
80002634:	2f fd       	sub	sp,-4
80002636:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
8000263a:	48 7c       	lddpc	r12,80002654 <Volume_reply_func+0x60>
8000263c:	f0 1f 00 03 	mcall	80002648 <Volume_reply_func+0x54>
80002640:	e3 cd 80 80 	ldm	sp++,r7,pc
80002644:	80 00       	ld.sh	r0,r0[0x0]
80002646:	ce 68       	rjmp	80002812 <dcm_reply_func+0x6>
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	69 a0       	ld.w	r0,r4[0x68]
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	ce 7c       	rcall	8000281c <dcm_reply_func+0x10>
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	ce 98       	rjmp	80002824 <dcm_reply_func+0x18>
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	ce b0       	breq	8000262c <Volume_reply_func+0x38>

80002658 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002658:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
8000265a:	19 d9       	ld.ub	r9,r12[0x5]
8000265c:	30 08       	mov	r8,0
8000265e:	f0 09 18 00 	cp.b	r9,r8
80002662:	c0 81       	brne	80002672 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002664:	10 99       	mov	r9,r8
80002666:	48 78       	lddpc	r8,80002680 <spk_brdcst_func+0x28>
80002668:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
8000266a:	48 7c       	lddpc	r12,80002684 <spk_brdcst_func+0x2c>
8000266c:	f0 1f 00 07 	mcall	80002688 <spk_brdcst_func+0x30>
80002670:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002672:	30 19       	mov	r9,1
80002674:	48 38       	lddpc	r8,80002680 <spk_brdcst_func+0x28>
80002676:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002678:	48 5c       	lddpc	r12,8000268c <spk_brdcst_func+0x34>
8000267a:	f0 1f 00 04 	mcall	80002688 <spk_brdcst_func+0x30>
8000267e:	d8 02       	popm	pc
80002680:	00 00       	add	r0,r0
80002682:	0a 40       	or	r0,r5
80002684:	80 00       	ld.sh	r0,r0[0x0]
80002686:	ce c8       	rjmp	8000285e <dcm_reply_func+0x52>
80002688:	80 00       	ld.sh	r0,r0[0x0]
8000268a:	69 a0       	ld.w	r0,r4[0x68]
8000268c:	80 00       	ld.sh	r0,r0[0x0]
8000268e:	ce d8       	rjmp	80002868 <dcm_reply_func+0x5c>

80002690 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002690:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002692:	19 a9       	ld.ub	r9,r12[0x2]
80002694:	30 08       	mov	r8,0
80002696:	f0 09 18 00 	cp.b	r9,r8
8000269a:	c0 f1       	brne	800026b8 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
8000269c:	19 e9       	ld.ub	r9,r12[0x6]
8000269e:	f0 09 18 00 	cp.b	r9,r8
800026a2:	c0 40       	breq	800026aa <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
800026a4:	30 19       	mov	r9,1
800026a6:	48 98       	lddpc	r8,800026c8 <spk_reply_func+0x38>
800026a8:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
800026aa:	19 e8       	ld.ub	r8,r12[0x6]
800026ac:	1a d8       	st.w	--sp,r8
800026ae:	48 8c       	lddpc	r12,800026cc <spk_reply_func+0x3c>
800026b0:	f0 1f 00 08 	mcall	800026d0 <spk_reply_func+0x40>
800026b4:	2f fd       	sub	sp,-4
800026b6:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
800026b8:	30 09       	mov	r9,0
800026ba:	48 48       	lddpc	r8,800026c8 <spk_reply_func+0x38>
800026bc:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
800026be:	48 6c       	lddpc	r12,800026d4 <spk_reply_func+0x44>
800026c0:	f0 1f 00 04 	mcall	800026d0 <spk_reply_func+0x40>
800026c4:	d8 02       	popm	pc
800026c6:	00 00       	add	r0,r0
800026c8:	00 00       	add	r0,r0
800026ca:	0a 40       	or	r0,r5
800026cc:	80 00       	ld.sh	r0,r0[0x0]
800026ce:	ce e4       	brge	800026aa <spk_reply_func+0x1a>
800026d0:	80 00       	ld.sh	r0,r0[0x0]
800026d2:	69 a0       	ld.w	r0,r4[0x68]
800026d4:	80 00       	ld.sh	r0,r0[0x0]
800026d6:	ce f4       	brge	800026b4 <spk_reply_func+0x24>

800026d8 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
800026d8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
800026dc:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
800026e0:	0f a9       	ld.ub	r9,r7[0x2]
800026e2:	30 08       	mov	r8,0
800026e4:	f0 09 18 00 	cp.b	r9,r8
800026e8:	c0 71       	brne	800026f6 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
800026ea:	48 dc       	lddpc	r12,8000271c <mic_brdcst_func+0x44>
800026ec:	f0 1f 00 0d 	mcall	80002720 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
800026f0:	30 09       	mov	r9,0
800026f2:	48 d8       	lddpc	r8,80002724 <mic_brdcst_func+0x4c>
800026f4:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
800026f6:	0f a9       	ld.ub	r9,r7[0x2]
800026f8:	31 18       	mov	r8,17
800026fa:	f0 09 18 00 	cp.b	r9,r8
800026fe:	c0 d1       	brne	80002718 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
80002700:	48 ac       	lddpc	r12,80002728 <mic_brdcst_func+0x50>
80002702:	f0 1f 00 08 	mcall	80002720 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
80002706:	48 89       	lddpc	r9,80002724 <mic_brdcst_func+0x4c>
80002708:	30 18       	mov	r8,1
8000270a:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
8000270c:	13 89       	ld.ub	r9,r9[0x0]
8000270e:	f0 09 18 00 	cp.b	r9,r8
80002712:	c0 31       	brne	80002718 <mic_brdcst_func+0x40>
80002714:	48 68       	lddpc	r8,8000272c <mic_brdcst_func+0x54>
80002716:	11 88       	ld.ub	r8,r8[0x0]
80002718:	e3 cd 80 80 	ldm	sp++,r7,pc
8000271c:	80 00       	ld.sh	r0,r0[0x0]
8000271e:	cf 00       	breq	800026fe <mic_brdcst_func+0x26>
80002720:	80 00       	ld.sh	r0,r0[0x0]
80002722:	69 a0       	ld.w	r0,r4[0x68]
80002724:	00 00       	add	r0,r0
80002726:	0a 56       	eor	r6,r5
80002728:	80 00       	ld.sh	r0,r0[0x0]
8000272a:	cf 14       	brge	8000270c <mic_brdcst_func+0x34>
8000272c:	00 00       	add	r0,r0
8000272e:	0a 45       	or	r5,r5

80002730 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002730:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002734:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002738:	49 ac       	lddpc	r12,800027a0 <mic_reply_func+0x70>
8000273a:	f0 1f 00 1b 	mcall	800027a4 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
8000273e:	0f 89       	ld.ub	r9,r7[0x0]
80002740:	30 08       	mov	r8,0
80002742:	f0 09 18 00 	cp.b	r9,r8
80002746:	c2 71       	brne	80002794 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
80002748:	0f 98       	ld.ub	r8,r7[0x1]
8000274a:	30 29       	mov	r9,2
8000274c:	f2 08 18 00 	cp.b	r8,r9
80002750:	c1 b1       	brne	80002786 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
80002752:	49 6c       	lddpc	r12,800027a8 <mic_reply_func+0x78>
80002754:	f0 1f 00 14 	mcall	800027a4 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002758:	0f a8       	ld.ub	r8,r7[0x2]
8000275a:	1a d8       	st.w	--sp,r8
8000275c:	49 4c       	lddpc	r12,800027ac <mic_reply_func+0x7c>
8000275e:	f0 1f 00 12 	mcall	800027a4 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002762:	0f b8       	ld.ub	r8,r7[0x3]
80002764:	1a d8       	st.w	--sp,r8
80002766:	49 3c       	lddpc	r12,800027b0 <mic_reply_func+0x80>
80002768:	f0 1f 00 0f 	mcall	800027a4 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000276c:	0f c8       	ld.ub	r8,r7[0x4]
8000276e:	1a d8       	st.w	--sp,r8
80002770:	49 1c       	lddpc	r12,800027b4 <mic_reply_func+0x84>
80002772:	f0 1f 00 0d 	mcall	800027a4 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002776:	0f d8       	ld.ub	r8,r7[0x5]
80002778:	1a d8       	st.w	--sp,r8
8000277a:	49 0c       	lddpc	r12,800027b8 <mic_reply_func+0x88>
8000277c:	f0 1f 00 0a 	mcall	800027a4 <mic_reply_func+0x74>
80002780:	2f cd       	sub	sp,-16
80002782:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002786:	1a d8       	st.w	--sp,r8
80002788:	48 dc       	lddpc	r12,800027bc <mic_reply_func+0x8c>
8000278a:	f0 1f 00 07 	mcall	800027a4 <mic_reply_func+0x74>
8000278e:	2f fd       	sub	sp,-4
80002790:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002794:	48 bc       	lddpc	r12,800027c0 <mic_reply_func+0x90>
80002796:	f0 1f 00 04 	mcall	800027a4 <mic_reply_func+0x74>
8000279a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000279e:	00 00       	add	r0,r0
800027a0:	80 00       	ld.sh	r0,r0[0x0]
800027a2:	cf 28       	rjmp	80002986 <set_idle_store_isr+0x12>
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	69 a0       	ld.w	r0,r4[0x68]
800027a8:	80 00       	ld.sh	r0,r0[0x0]
800027aa:	cf 38       	rjmp	80002990 <phy_rx>
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	cf 4c       	rcall	80002996 <phy_rx+0x6>
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	cf 60       	breq	8000279e <mic_reply_func+0x6e>
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	cf 7c       	rcall	800029a4 <phy_rx+0x14>
800027b8:	80 00       	ld.sh	r0,r0[0x0]
800027ba:	cf 94       	brge	800027ac <mic_reply_func+0x7c>
800027bc:	80 00       	ld.sh	r0,r0[0x0]
800027be:	cf ac       	rcall	800029b2 <phy_rx+0x22>
800027c0:	80 00       	ld.sh	r0,r0[0x0]
800027c2:	cf c4       	brge	800027ba <mic_reply_func+0x8a>

800027c4 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800027c4:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800027c8:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
800027cc:	48 bc       	lddpc	r12,800027f8 <dcm_brdcst_func+0x34>
800027ce:	f0 1f 00 0c 	mcall	800027fc <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
800027d2:	0f 88       	ld.ub	r8,r7[0x0]
800027d4:	1a d8       	st.w	--sp,r8
800027d6:	48 bc       	lddpc	r12,80002800 <dcm_brdcst_func+0x3c>
800027d8:	f0 1f 00 09 	mcall	800027fc <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
800027dc:	0f a8       	ld.ub	r8,r7[0x2]
800027de:	1a d8       	st.w	--sp,r8
800027e0:	48 9c       	lddpc	r12,80002804 <dcm_brdcst_func+0x40>
800027e2:	f0 1f 00 07 	mcall	800027fc <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
800027e6:	0f 98       	ld.ub	r8,r7[0x1]
800027e8:	1a d8       	st.w	--sp,r8
800027ea:	48 8c       	lddpc	r12,80002808 <dcm_brdcst_func+0x44>
800027ec:	f0 1f 00 04 	mcall	800027fc <dcm_brdcst_func+0x38>
800027f0:	2f dd       	sub	sp,-12
	
	
}
800027f2:	e3 cd 80 80 	ldm	sp++,r7,pc
800027f6:	00 00       	add	r0,r0
800027f8:	80 00       	ld.sh	r0,r0[0x0]
800027fa:	cf d4       	brge	800027f4 <dcm_brdcst_func+0x30>
800027fc:	80 00       	ld.sh	r0,r0[0x0]
800027fe:	69 a0       	ld.w	r0,r4[0x68]
80002800:	80 00       	ld.sh	r0,r0[0x0]
80002802:	cf e8       	rjmp	800029fe <phy_tx+0x16>
80002804:	80 00       	ld.sh	r0,r0[0x0]
80002806:	cf fc       	rcall	80002a04 <phy_tx+0x1c>
80002808:	80 00       	ld.sh	r0,r0[0x0]
8000280a:	d0 14       	*unknown*

8000280c <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
8000280c:	eb cd 40 80 	pushm	r7,lr
80002810:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002812:	19 a9       	ld.ub	r9,r12[0x2]
80002814:	30 08       	mov	r8,0
80002816:	f0 09 18 00 	cp.b	r9,r8
8000281a:	c1 b1       	brne	80002850 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
8000281c:	19 b8       	ld.ub	r8,r12[0x3]
8000281e:	30 19       	mov	r9,1
80002820:	f2 08 18 00 	cp.b	r8,r9
80002824:	c0 51       	brne	8000282e <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
80002826:	48 ec       	lddpc	r12,8000285c <dcm_reply_func+0x50>
80002828:	f0 1f 00 0e 	mcall	80002860 <dcm_reply_func+0x54>
8000282c:	c0 a8       	rjmp	80002840 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
8000282e:	58 08       	cp.w	r8,0
80002830:	c0 51       	brne	8000283a <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
80002832:	48 dc       	lddpc	r12,80002864 <dcm_reply_func+0x58>
80002834:	f0 1f 00 0b 	mcall	80002860 <dcm_reply_func+0x54>
80002838:	c0 48       	rjmp	80002840 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
8000283a:	48 cc       	lddpc	r12,80002868 <dcm_reply_func+0x5c>
8000283c:	f0 1f 00 09 	mcall	80002860 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
80002840:	0f d8       	ld.ub	r8,r7[0x5]
80002842:	1a d8       	st.w	--sp,r8
80002844:	48 ac       	lddpc	r12,8000286c <dcm_reply_func+0x60>
80002846:	f0 1f 00 07 	mcall	80002860 <dcm_reply_func+0x54>
8000284a:	2f fd       	sub	sp,-4
8000284c:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002850:	48 8c       	lddpc	r12,80002870 <dcm_reply_func+0x64>
80002852:	f0 1f 00 04 	mcall	80002860 <dcm_reply_func+0x54>
80002856:	e3 cd 80 80 	ldm	sp++,r7,pc
8000285a:	00 00       	add	r0,r0
8000285c:	80 00       	ld.sh	r0,r0[0x0]
8000285e:	d0 30       	acall	0x3
80002860:	80 00       	ld.sh	r0,r0[0x0]
80002862:	69 a0       	ld.w	r0,r4[0x68]
80002864:	80 00       	ld.sh	r0,r0[0x0]
80002866:	d0 44       	*unknown*
80002868:	80 00       	ld.sh	r0,r0[0x0]
8000286a:	d0 58       	*unknown*
8000286c:	80 00       	ld.sh	r0,r0[0x0]
8000286e:	d0 6c       	*unknown*
80002870:	80 00       	ld.sh	r0,r0[0x0]
80002872:	d0 78       	*unknown*

80002874 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002874:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002876:	19 a9       	ld.ub	r9,r12[0x2]
80002878:	30 08       	mov	r8,0
8000287a:	f0 09 18 00 	cp.b	r9,r8
8000287e:	c0 51       	brne	80002888 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002880:	48 4c       	lddpc	r12,80002890 <ToneControl_reply_func+0x1c>
80002882:	f0 1f 00 05 	mcall	80002894 <ToneControl_reply_func+0x20>
80002886:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002888:	48 4c       	lddpc	r12,80002898 <ToneControl_reply_func+0x24>
8000288a:	f0 1f 00 03 	mcall	80002894 <ToneControl_reply_func+0x20>
8000288e:	d8 02       	popm	pc
80002890:	80 00       	ld.sh	r0,r0[0x0]
80002892:	d0 84       	*unknown*
80002894:	80 00       	ld.sh	r0,r0[0x0]
80002896:	69 a0       	ld.w	r0,r4[0x68]
80002898:	80 00       	ld.sh	r0,r0[0x0]
8000289a:	d0 90       	acall	0x9

8000289c <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
8000289c:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
8000289e:	19 e8       	ld.ub	r8,r12[0x6]
800028a0:	30 19       	mov	r9,1
800028a2:	f2 08 18 00 	cp.b	r8,r9
800028a6:	c0 61       	brne	800028b2 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028a8:	48 98       	lddpc	r8,800028cc <DeviceInitializationStatus_brdcst_func+0x30>
800028aa:	70 09       	ld.w	r9,r8[0x0]
800028ac:	a1 a9       	sbr	r9,0x0
800028ae:	91 09       	st.w	r8[0x0],r9
800028b0:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028b2:	30 29       	mov	r9,2
800028b4:	f2 08 18 00 	cp.b	r8,r9
800028b8:	c0 80       	breq	800028c8 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028ba:	48 58       	lddpc	r8,800028cc <DeviceInitializationStatus_brdcst_func+0x30>
800028bc:	70 09       	ld.w	r9,r8[0x0]
800028be:	e0 19 ff fc 	andl	r9,0xfffc
800028c2:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028c4:	f0 1f 00 03 	mcall	800028d0 <DeviceInitializationStatus_brdcst_func+0x34>
800028c8:	d8 02       	popm	pc
800028ca:	00 00       	add	r0,r0
800028cc:	00 00       	add	r0,r0
800028ce:	0d 8c       	ld.ub	r12,r6[0x0]
800028d0:	80 00       	ld.sh	r0,r0[0x0]
800028d2:	3d c8       	mov	r8,-36

800028d4 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
800028d4:	20 1c       	sub	r12,1
800028d6:	5c 5c       	castu.b	r12
800028d8:	31 18       	mov	r8,17
800028da:	f0 0c 18 00 	cp.b	r12,r8
800028de:	e0 88 00 03 	brls	800028e4 <CalculateBurst+0x10>
800028e2:	5e fd       	retal	0
800028e4:	48 28       	lddpc	r8,800028ec <CalculateBurst+0x18>
800028e6:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
800028ea:	5e fc       	retal	r12
800028ec:	80 00       	ld.sh	r0,r0[0x0]
800028ee:	d0 9c       	*unknown*

800028f0 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
800028f0:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
800028f2:	48 98       	lddpc	r8,80002914 <payload_init+0x24>
800028f4:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
800028f6:	48 98       	lddpc	r8,80002918 <payload_init+0x28>
800028f8:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800028fa:	30 09       	mov	r9,0
800028fc:	1a d9       	st.w	--sp,r9
800028fe:	1a d9       	st.w	--sp,r9
80002900:	1a d9       	st.w	--sp,r9
80002902:	30 28       	mov	r8,2
80002904:	e0 6a 04 00 	mov	r10,1024
80002908:	48 5b       	lddpc	r11,8000291c <payload_init+0x2c>
8000290a:	48 6c       	lddpc	r12,80002920 <payload_init+0x30>
8000290c:	f0 1f 00 06 	mcall	80002924 <payload_init+0x34>
80002910:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
80002912:	d8 02       	popm	pc
80002914:	00 00       	add	r0,r0
80002916:	0a 5c       	eor	r12,r5
80002918:	00 00       	add	r0,r0
8000291a:	0a 60       	and	r0,r5
8000291c:	80 00       	ld.sh	r0,r0[0x0]
8000291e:	d0 e4       	*unknown*
80002920:	80 00       	ld.sh	r0,r0[0x0]
80002922:	29 28       	sub	r8,-110
80002924:	80 00       	ld.sh	r0,r0[0x0]
80002926:	65 dc       	ld.w	r12,r2[0x74]

80002928 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002928:	eb cd 40 f8 	pushm	r3-r7,lr
8000292c:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
8000292e:	48 e8       	lddpc	r8,80002964 <payload_rx_process+0x3c>
80002930:	70 08       	ld.w	r8,r8[0x0]
80002932:	58 08       	cp.w	r8,0
80002934:	c0 71       	brne	80002942 <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002936:	30 4b       	mov	r11,4
80002938:	30 5c       	mov	r12,5
8000293a:	f0 1f 00 0c 	mcall	80002968 <payload_rx_process+0x40>
8000293e:	48 a8       	lddpc	r8,80002964 <payload_rx_process+0x3c>
80002940:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002942:	48 96       	lddpc	r6,80002964 <payload_rx_process+0x3c>
80002944:	30 05       	mov	r5,0
80002946:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002948:	48 93       	lddpc	r3,8000296c <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
8000294a:	6c 0c       	ld.w	r12,r6[0x0]
8000294c:	0a 99       	mov	r9,r5
8000294e:	08 9a       	mov	r10,r4
80002950:	1a 9b       	mov	r11,sp
80002952:	f0 1f 00 08 	mcall	80002970 <payload_rx_process+0x48>
80002956:	58 1c       	cp.w	r12,1
80002958:	cf 91       	brne	8000294a <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
8000295a:	66 08       	ld.w	r8,r3[0x0]
8000295c:	40 0c       	lddsp	r12,sp[0x0]
8000295e:	5d 18       	icall	r8
80002960:	cf 5b       	rjmp	8000294a <payload_rx_process+0x22>
80002962:	00 00       	add	r0,r0
80002964:	00 00       	add	r0,r0
80002966:	0a 8c       	andn	r12,r5
80002968:	80 00       	ld.sh	r0,r0[0x0]
8000296a:	5f 08       	sreq	r8
8000296c:	00 00       	add	r0,r0
8000296e:	0a 5c       	eor	r12,r5
80002970:	80 00       	ld.sh	r0,r0[0x0]
80002972:	5b fc       	cp.w	r12,-1

80002974 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002974:	d4 01       	pushm	lr
80002976:	20 2d       	sub	sp,8
80002978:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000297a:	30 09       	mov	r9,0
8000297c:	fa ca ff f8 	sub	r10,sp,-8
80002980:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002982:	1a 9b       	mov	r11,sp
80002984:	f0 1f 00 02 	mcall	8000298c <set_idle_store_isr+0x18>
}
80002988:	2f ed       	sub	sp,-8
8000298a:	d8 02       	popm	pc
8000298c:	80 00       	ld.sh	r0,r0[0x0]
8000298e:	5d b8       	*unknown*

80002990 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002990:	d4 01       	pushm	lr
80002992:	20 2d       	sub	sp,8
80002994:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002996:	58 0c       	cp.w	r12,0
80002998:	c1 10       	breq	800029ba <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000299a:	30 08       	mov	r8,0
8000299c:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
8000299e:	98 88       	ld.uh	r8,r12[0x0]
800029a0:	e2 18 f0 00 	andl	r8,0xf000,COH
800029a4:	e0 48 40 00 	cp.w	r8,16384
800029a8:	c0 91       	brne	800029ba <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
800029aa:	48 68       	lddpc	r8,800029c0 <phy_rx+0x30>
800029ac:	70 0c       	ld.w	r12,r8[0x0]
800029ae:	30 09       	mov	r9,0
800029b0:	fa ca ff fc 	sub	r10,sp,-4
800029b4:	1a 9b       	mov	r11,sp
800029b6:	f0 1f 00 04 	mcall	800029c4 <phy_rx+0x34>
		}	

    }
		
 
}
800029ba:	2f ed       	sub	sp,-8
800029bc:	d8 02       	popm	pc
800029be:	00 00       	add	r0,r0
800029c0:	00 00       	add	r0,r0
800029c2:	0a b8       	st.h	r5++,r8
800029c4:	80 00       	ld.sh	r0,r0[0x0]
800029c6:	5d b8       	*unknown*

800029c8 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
800029c8:	eb cd 40 80 	pushm	r7,lr
800029cc:	20 1d       	sub	sp,4
800029ce:	fa c7 ff fc 	sub	r7,sp,-4
800029d2:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
800029d4:	30 09       	mov	r9,0
800029d6:	12 9a       	mov	r10,r9
800029d8:	1a 9b       	mov	r11,sp
800029da:	f0 1f 00 03 	mcall	800029e4 <set_idle_store+0x1c>
}
800029de:	2f fd       	sub	sp,-4
800029e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800029e4:	80 00       	ld.sh	r0,r0[0x0]
800029e6:	5e 08       	reteq	r8

800029e8 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
800029e8:	d4 01       	pushm	lr
800029ea:	20 1d       	sub	sp,4
800029ec:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
800029ee:	98 88       	ld.uh	r8,r12[0x0]
800029f0:	e2 18 f0 00 	andl	r8,0xf000,COH
800029f4:	e0 48 40 00 	cp.w	r8,16384
800029f8:	c0 d1       	brne	80002a12 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
800029fa:	49 08       	lddpc	r8,80002a38 <phy_tx+0x50>
800029fc:	70 08       	ld.w	r8,r8[0x0]
800029fe:	58 08       	cp.w	r8,0
80002a00:	c1 a0       	breq	80002a34 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002a02:	48 e8       	lddpc	r8,80002a38 <phy_tx+0x50>
80002a04:	70 0c       	ld.w	r12,r8[0x0]
80002a06:	30 09       	mov	r9,0
80002a08:	12 9a       	mov	r10,r9
80002a0a:	1a 9b       	mov	r11,sp
80002a0c:	f0 1f 00 0c 	mcall	80002a3c <phy_tx+0x54>
80002a10:	c1 28       	rjmp	80002a34 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002a12:	e0 48 10 00 	cp.w	r8,4096
80002a16:	5f 0a       	sreq	r10
80002a18:	e0 48 20 00 	cp.w	r8,8192
80002a1c:	5f 09       	sreq	r9
80002a1e:	f5 e9 10 09 	or	r9,r10,r9
80002a22:	c0 71       	brne	80002a30 <phy_tx+0x48>
80002a24:	e0 48 50 00 	cp.w	r8,20480
80002a28:	c0 40       	breq	80002a30 <phy_tx+0x48>
80002a2a:	e0 48 60 00 	cp.w	r8,24576
80002a2e:	c0 31       	brne	80002a34 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002a30:	48 48       	lddpc	r8,80002a40 <phy_tx+0x58>
80002a32:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002a34:	2f fd       	sub	sp,-4
80002a36:	d8 02       	popm	pc
80002a38:	00 00       	add	r0,r0
80002a3a:	0a c4       	st.b	r5++,r4
80002a3c:	80 00       	ld.sh	r0,r0[0x0]
80002a3e:	5e 08       	reteq	r8
80002a40:	00 00       	add	r0,r0
80002a42:	0a ac       	st.w	r5++,r12

80002a44 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002a44:	d4 01       	pushm	lr
80002a46:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002a48:	30 08       	mov	r8,0
80002a4a:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a4c:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002a4e:	1a 9a       	mov	r10,sp
80002a50:	fa cb ff fc 	sub	r11,sp,-4
80002a54:	f0 1f 00 05 	mcall	80002a68 <get_idle_store_isr+0x24>
80002a58:	58 1c       	cp.w	r12,1
80002a5a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002a5e:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002a62:	2f ed       	sub	sp,-8
80002a64:	d8 02       	popm	pc
80002a66:	00 00       	add	r0,r0
80002a68:	80 00       	ld.sh	r0,r0[0x0]
80002a6a:	5b 0c       	cp.w	r12,-16

80002a6c <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002a6c:	eb cd 40 c0 	pushm	r6-r7,lr
80002a70:	20 1d       	sub	sp,4
80002a72:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002a74:	4b a8       	lddpc	r8,80002b5c <phy_tx_func+0xf0>
80002a76:	70 08       	ld.w	r8,r8[0x0]
80002a78:	58 08       	cp.w	r8,0
80002a7a:	c6 60       	breq	80002b46 <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002a7c:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a7e:	30 08       	mov	r8,0
80002a80:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002a82:	4b 88       	lddpc	r8,80002b60 <phy_tx_func+0xf4>
80002a84:	70 08       	ld.w	r8,r8[0x0]
80002a86:	58 18       	cp.w	r8,1
80002a88:	c2 60       	breq	80002ad4 <phy_tx_func+0x68>
80002a8a:	c0 43       	brcs	80002a92 <phy_tx_func+0x26>
80002a8c:	58 28       	cp.w	r8,2
80002a8e:	c5 c1       	brne	80002b46 <phy_tx_func+0xda>
80002a90:	c5 58       	rjmp	80002b3a <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002a92:	4b 38       	lddpc	r8,80002b5c <phy_tx_func+0xf0>
80002a94:	70 0c       	ld.w	r12,r8[0x0]
80002a96:	1a 9a       	mov	r10,sp
80002a98:	4b 3b       	lddpc	r11,80002b64 <phy_tx_func+0xf8>
80002a9a:	f0 1f 00 34 	mcall	80002b68 <phy_tx_func+0xfc>
80002a9e:	58 1c       	cp.w	r12,1
80002aa0:	c1 41       	brne	80002ac8 <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002aa2:	4b 18       	lddpc	r8,80002b64 <phy_tx_func+0xf8>
80002aa4:	70 08       	ld.w	r8,r8[0x0]
80002aa6:	90 08       	ld.sh	r8,r8[0x0]
80002aa8:	10 9a       	mov	r10,r8
80002aaa:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002aae:	4b 09       	lddpc	r9,80002b6c <phy_tx_func+0x100>
80002ab0:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002ab2:	5c 78       	castu.h	r8
80002ab4:	ea 18 ab cd 	orh	r8,0xabcd
80002ab8:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002aba:	30 19       	mov	r9,1
80002abc:	4a d8       	lddpc	r8,80002b70 <phy_tx_func+0x104>
80002abe:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002ac0:	30 19       	mov	r9,1
80002ac2:	4a 88       	lddpc	r8,80002b60 <phy_tx_func+0xf4>
80002ac4:	91 09       	st.w	r8[0x0],r9
80002ac6:	c4 08       	rjmp	80002b46 <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002ac8:	e0 68 5a 5a 	mov	r8,23130
80002acc:	ea 18 ab cd 	orh	r8,0xabcd
80002ad0:	8f 18       	st.w	r7[0x4],r8
80002ad2:	c3 a8       	rjmp	80002b46 <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002ad4:	4a 7a       	lddpc	r10,80002b70 <phy_tx_func+0x104>
80002ad6:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002ad8:	4a 39       	lddpc	r9,80002b64 <phy_tx_func+0xf8>
80002ada:	72 09       	ld.w	r9,r9[0x0]
80002adc:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002ae0:	b1 69       	lsl	r9,0x10
80002ae2:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002ae4:	2f f8       	sub	r8,-1
80002ae6:	5c 58       	castu.b	r8
80002ae8:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002aea:	4a 1b       	lddpc	r11,80002b6c <phy_tx_func+0x100>
80002aec:	96 0c       	ld.sh	r12,r11[0x0]
80002aee:	20 2c       	sub	r12,2
80002af0:	5c 8c       	casts.h	r12
80002af2:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002af6:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002af8:	30 0b       	mov	r11,0
80002afa:	f6 0a 19 00 	cp.h	r10,r11
80002afe:	e0 89 00 09 	brgt	80002b10 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002b02:	e8 19 00 ba 	orl	r9,0xba
80002b06:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002b08:	30 09       	mov	r9,0
80002b0a:	49 68       	lddpc	r8,80002b60 <phy_tx_func+0xf4>
80002b0c:	91 09       	st.w	r8[0x0],r9
80002b0e:	c1 c8       	rjmp	80002b46 <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002b10:	49 5a       	lddpc	r10,80002b64 <phy_tx_func+0xf8>
80002b12:	74 0a       	ld.w	r10,r10[0x0]
80002b14:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002b18:	14 49       	or	r9,r10
80002b1a:	8f 19       	st.w	r7[0x4],r9
80002b1c:	2f f8       	sub	r8,-1
80002b1e:	49 59       	lddpc	r9,80002b70 <phy_tx_func+0x104>
80002b20:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b22:	20 2c       	sub	r12,2
80002b24:	49 28       	lddpc	r8,80002b6c <phy_tx_func+0x100>
80002b26:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b28:	30 08       	mov	r8,0
80002b2a:	f0 0c 19 00 	cp.h	r12,r8
80002b2e:	e0 89 00 0c 	brgt	80002b46 <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002b32:	30 29       	mov	r9,2
80002b34:	48 b8       	lddpc	r8,80002b60 <phy_tx_func+0xf4>
80002b36:	91 09       	st.w	r8[0x0],r9
80002b38:	c0 78       	rjmp	80002b46 <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002b3a:	fc 18 00 ba 	movh	r8,0xba
80002b3e:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002b40:	30 09       	mov	r9,0
80002b42:	48 88       	lddpc	r8,80002b60 <phy_tx_func+0xf4>
80002b44:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002b46:	e0 68 5a 5a 	mov	r8,23130
80002b4a:	ea 18 ab cd 	orh	r8,0xabcd
80002b4e:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002b50:	30 08       	mov	r8,0
80002b52:	8f 38       	st.w	r7[0xc],r8
}
80002b54:	2f fd       	sub	sp,-4
80002b56:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002b5a:	00 00       	add	r0,r0
80002b5c:	00 00       	add	r0,r0
80002b5e:	0a c4       	st.b	r5++,r4
80002b60:	00 00       	add	r0,r0
80002b62:	0a 80       	andn	r0,r5
80002b64:	00 00       	add	r0,r0
80002b66:	0a cc       	st.b	r5++,r12
80002b68:	80 00       	ld.sh	r0,r0[0x0]
80002b6a:	5b 0c       	cp.w	r12,-16
80002b6c:	00 00       	add	r0,r0
80002b6e:	0a a8       	st.w	r5++,r8
80002b70:	00 00       	add	r0,r0
80002b72:	0a 64       	and	r4,r5

80002b74 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002b74:	d4 01       	pushm	lr
80002b76:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002b78:	30 0a       	mov	r10,0
80002b7a:	fa cb ff fc 	sub	r11,sp,-4
80002b7e:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002b80:	14 99       	mov	r9,r10
80002b82:	1a 9b       	mov	r11,sp
80002b84:	f0 1f 00 05 	mcall	80002b98 <get_idle_store+0x24>
80002b88:	58 1c       	cp.w	r12,1
80002b8a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002b8e:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002b92:	2f fd       	sub	sp,-4
80002b94:	d8 02       	popm	pc
80002b96:	00 00       	add	r0,r0
80002b98:	80 00       	ld.sh	r0,r0[0x0]
80002b9a:	5b fc       	cp.w	r12,-1

80002b9c <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002b9c:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002b9e:	48 5b       	lddpc	r11,80002bb0 <phy_init+0x14>
80002ba0:	48 5c       	lddpc	r12,80002bb4 <phy_init+0x18>
80002ba2:	f0 1f 00 06 	mcall	80002bb8 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002ba6:	f0 1f 00 06 	mcall	80002bbc <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002baa:	f0 1f 00 06 	mcall	80002bc0 <phy_init+0x24>
	
}
80002bae:	d8 02       	popm	pc
80002bb0:	80 00       	ld.sh	r0,r0[0x0]
80002bb2:	2a 6c       	sub	r12,-90
80002bb4:	80 00       	ld.sh	r0,r0[0x0]
80002bb6:	2c 24       	sub	r4,-62
80002bb8:	80 00       	ld.sh	r0,r0[0x0]
80002bba:	3c 6c       	mov	r12,-58
80002bbc:	80 00       	ld.sh	r0,r0[0x0]
80002bbe:	3c 80       	mov	r0,-56
80002bc0:	80 00       	ld.sh	r0,r0[0x0]
80002bc2:	46 20       	lddsp	r0,sp[0x188]

80002bc4 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002bc4:	d4 01       	pushm	lr
80002bc6:	20 2d       	sub	sp,8
80002bc8:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002bca:	30 08       	mov	r8,0
80002bcc:	50 18       	stdsp	sp[0x4],r8
	
	if(NULL == phy_payload_frame_rx)
80002bce:	48 f8       	lddpc	r8,80002c08 <payload_rx+0x44>
80002bd0:	70 08       	ld.w	r8,r8[0x0]
80002bd2:	58 08       	cp.w	r8,0
80002bd4:	c0 71       	brne	80002be2 <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80002bd6:	30 4b       	mov	r11,4
80002bd8:	30 5c       	mov	r12,5
80002bda:	f0 1f 00 0d 	mcall	80002c0c <payload_rx+0x48>
80002bde:	48 b8       	lddpc	r8,80002c08 <payload_rx+0x44>
80002be0:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
80002be2:	48 a8       	lddpc	r8,80002c08 <payload_rx+0x44>
80002be4:	70 0c       	ld.w	r12,r8[0x0]
80002be6:	30 09       	mov	r9,0
80002be8:	fa ca ff fc 	sub	r10,sp,-4
80002bec:	1a 9b       	mov	r11,sp
80002bee:	f0 1f 00 09 	mcall	80002c10 <payload_rx+0x4c>
80002bf2:	c0 91       	brne	80002c04 <payload_rx+0x40>
	{
		
		set_payload_idle_isr(payload);
80002bf4:	48 88       	lddpc	r8,80002c14 <payload_rx+0x50>
80002bf6:	70 0c       	ld.w	r12,r8[0x0]
80002bf8:	40 0b       	lddsp	r11,sp[0x0]
80002bfa:	f0 1f 00 08 	mcall	80002c18 <payload_rx+0x54>
		logFromISR("mm");
80002bfe:	48 8c       	lddpc	r12,80002c1c <payload_rx+0x58>
80002c00:	f0 1f 00 08 	mcall	80002c20 <payload_rx+0x5c>
	}
	else
	{
		//logFromISR("ss");
	}
}
80002c04:	2f ed       	sub	sp,-8
80002c06:	d8 02       	popm	pc
80002c08:	00 00       	add	r0,r0
80002c0a:	0a 8c       	andn	r12,r5
80002c0c:	80 00       	ld.sh	r0,r0[0x0]
80002c0e:	5f 08       	sreq	r8
80002c10:	80 00       	ld.sh	r0,r0[0x0]
80002c12:	5d b8       	*unknown*
80002c14:	00 00       	add	r0,r0
80002c16:	0a 70       	tst	r0,r5
80002c18:	80 00       	ld.sh	r0,r0[0x0]
80002c1a:	29 74       	sub	r4,-105
80002c1c:	80 00       	ld.sh	r0,r0[0x0]
80002c1e:	d0 f0       	acall	0xf
80002c20:	80 00       	ld.sh	r0,r0[0x0]
80002c22:	6b 2c       	ld.w	r12,r5[0x48]

80002c24 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002c24:	eb cd 40 e0 	pushm	r5-r7,lr
80002c28:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002c2a:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002c2e:	70 08       	ld.w	r8,r8[0x0]
80002c30:	58 08       	cp.w	r8,0
80002c32:	e0 80 01 08 	breq	80002e42 <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002c36:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002c38:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002c3c:	70 09       	ld.w	r9,r8[0x0]
80002c3e:	2f f9       	sub	r9,-1
80002c40:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002c42:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002c46:	70 08       	ld.w	r8,r8[0x0]
80002c48:	58 18       	cp.w	r8,1
80002c4a:	e0 80 00 85 	breq	80002d54 <phy_rx_func+0x130>
80002c4e:	c0 73       	brcs	80002c5c <phy_rx_func+0x38>
80002c50:	58 28       	cp.w	r8,2
80002c52:	c5 c0       	breq	80002d0a <phy_rx_func+0xe6>
80002c54:	58 38       	cp.w	r8,3
80002c56:	e0 81 00 f6 	brne	80002e42 <phy_rx_func+0x21e>
80002c5a:	cd 58       	rjmp	80002e04 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002c5c:	e0 6a 5a 5a 	mov	r10,23130
80002c60:	ea 1a ab cd 	orh	r10,0xabcd
80002c64:	14 36       	cp.w	r6,r10
80002c66:	e0 80 00 ee 	breq	80002e42 <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002c6a:	ec 08 16 10 	lsr	r8,r6,0x10
80002c6e:	e0 48 ab cd 	cp.w	r8,43981
80002c72:	e0 81 00 e8 	brne	80002e42 <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002c76:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002c7a:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002c7e:	20 28       	sub	r8,2
80002c80:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002c84:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002c86:	30 09       	mov	r9,0
80002c88:	f2 08 19 00 	cp.h	r8,r9
80002c8c:	e0 8a 00 db 	brle	80002e42 <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002c90:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002c94:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002c96:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002c9a:	70 0c       	ld.w	r12,r8[0x0]
80002c9c:	f0 1f 03 88 	mcall	80003abc <phy_rx_func+0xe98>
80002ca0:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002ca4:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002ca6:	58 0c       	cp.w	r12,0
80002ca8:	e0 80 00 cd 	breq	80002e42 <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002cac:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002cb0:	90 09       	ld.sh	r9,r8[0x0]
80002cb2:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002cb6:	2f f9       	sub	r9,-1
80002cb8:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002cba:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002cbe:	74 0a       	ld.w	r10,r10[0x0]
80002cc0:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002cc4:	76 0b       	ld.w	r11,r11[0x0]
80002cc6:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002cca:	2f f9       	sub	r9,-1
80002ccc:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002cce:	e2 16 0f 00 	andl	r6,0xf00,COH
80002cd2:	e0 46 01 00 	cp.w	r6,256
80002cd6:	c0 c0       	breq	80002cee <phy_rx_func+0xca>
80002cd8:	e0 8b 00 05 	brhi	80002ce2 <phy_rx_func+0xbe>
80002cdc:	58 06       	cp.w	r6,0
80002cde:	c0 80       	breq	80002cee <phy_rx_func+0xca>
80002ce0:	c0 c8       	rjmp	80002cf8 <phy_rx_func+0xd4>
80002ce2:	e0 46 02 00 	cp.w	r6,512
80002ce6:	c0 40       	breq	80002cee <phy_rx_func+0xca>
80002ce8:	e0 46 03 00 	cp.w	r6,768
80002cec:	c0 61       	brne	80002cf8 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002cee:	30 29       	mov	r9,2
80002cf0:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002cf4:	91 09       	st.w	r8[0x0],r9
80002cf6:	ca 68       	rjmp	80002e42 <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002cf8:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002cfc:	70 0c       	ld.w	r12,r8[0x0]
80002cfe:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002d02:	70 0b       	ld.w	r11,r8[0x0]
80002d04:	f0 1f 03 70 	mcall	80003ac4 <phy_rx_func+0xea0>
80002d08:	c9 d8       	rjmp	80002e42 <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002d0a:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002d0e:	b1 86       	lsr	r6,0x10
80002d10:	14 06       	add	r6,r10
80002d12:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002d16:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002d18:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002d1c:	90 09       	ld.sh	r9,r8[0x0]
80002d1e:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002d22:	76 0b       	ld.w	r11,r11[0x0]
80002d24:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002d28:	2f f9       	sub	r9,-1
80002d2a:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002d2c:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002d30:	92 08       	ld.sh	r8,r9[0x0]
80002d32:	20 28       	sub	r8,2
80002d34:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002d36:	30 09       	mov	r9,0
80002d38:	f2 08 19 00 	cp.h	r8,r9
80002d3c:	e0 8a 00 07 	brle	80002d4a <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002d40:	30 19       	mov	r9,1
80002d42:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002d46:	91 09       	st.w	r8[0x0],r9
80002d48:	c7 d8       	rjmp	80002e42 <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002d4a:	30 39       	mov	r9,3
80002d4c:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002d50:	91 09       	st.w	r8[0x0],r9
80002d52:	c7 88       	rjmp	80002e42 <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002d54:	ec 0a 14 10 	asr	r10,r6,0x10
80002d58:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002d5c:	90 09       	ld.sh	r9,r8[0x0]
80002d5e:	14 09       	add	r9,r10
80002d60:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002d62:	fe f9 0d 52 	ld.w	r9,pc[3410]
80002d66:	92 08       	ld.sh	r8,r9[0x0]
80002d68:	fe fb 0d 58 	ld.w	r11,pc[3416]
80002d6c:	76 0b       	ld.w	r11,r11[0x0]
80002d6e:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002d72:	2f f8       	sub	r8,-1
80002d74:	5c 88       	casts.h	r8
80002d76:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002d78:	fe fa 0d 38 	ld.w	r10,pc[3384]
80002d7c:	94 09       	ld.sh	r9,r10[0x0]
80002d7e:	20 29       	sub	r9,2
80002d80:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80002d82:	30 0a       	mov	r10,0
80002d84:	f4 09 19 00 	cp.h	r9,r10
80002d88:	e0 89 00 20 	brgt	80002dc8 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80002d8c:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80002d90:	e0 46 00 ba 	cp.w	r6,186
80002d94:	c0 d1       	brne	80002dae <phy_rx_func+0x18a>
80002d96:	fe f8 0d 32 	ld.w	r8,pc[3378]
80002d9a:	90 09       	ld.sh	r9,r8[0x0]
80002d9c:	f4 09 19 00 	cp.h	r9,r10
80002da0:	c0 71       	brne	80002dae <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80002da2:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80002da6:	70 0c       	ld.w	r12,r8[0x0]
80002da8:	f0 1f 03 49 	mcall	80003acc <phy_rx_func+0xea8>
80002dac:	c0 98       	rjmp	80002dbe <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80002dae:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80002db2:	70 0c       	ld.w	r12,r8[0x0]
80002db4:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80002db8:	70 0b       	ld.w	r11,r8[0x0]
80002dba:	f0 1f 03 43 	mcall	80003ac4 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80002dbe:	30 09       	mov	r9,0
80002dc0:	fe f8 0c ec 	ld.w	r8,pc[3308]
80002dc4:	91 09       	st.w	r8[0x0],r9
80002dc6:	c3 e8       	rjmp	80002e42 <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80002dc8:	5c 86       	casts.h	r6
80002dca:	fe f9 0c fe 	ld.w	r9,pc[3326]
80002dce:	92 0a       	ld.sh	r10,r9[0x0]
80002dd0:	0c 0a       	add	r10,r6
80002dd2:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002dd4:	fe f9 0c ec 	ld.w	r9,pc[3308]
80002dd8:	72 09       	ld.w	r9,r9[0x0]
80002dda:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80002dde:	2f f8       	sub	r8,-1
80002de0:	fe f9 0c d4 	ld.w	r9,pc[3284]
80002de4:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80002de6:	fe f9 0c ca 	ld.w	r9,pc[3274]
80002dea:	92 08       	ld.sh	r8,r9[0x0]
80002dec:	20 28       	sub	r8,2
80002dee:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80002df0:	30 09       	mov	r9,0
80002df2:	f2 08 19 00 	cp.h	r8,r9
80002df6:	e0 89 00 26 	brgt	80002e42 <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80002dfa:	30 39       	mov	r9,3
80002dfc:	fe f8 0c b0 	ld.w	r8,pc[3248]
80002e00:	91 09       	st.w	r8[0x0],r9
80002e02:	c2 08       	rjmp	80002e42 <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80002e04:	e6 16 00 ff 	andh	r6,0xff,COH
80002e08:	fc 19 00 ba 	movh	r9,0xba
80002e0c:	12 36       	cp.w	r6,r9
80002e0e:	c0 e1       	brne	80002e2a <phy_rx_func+0x206>
80002e10:	fe f8 0c b8 	ld.w	r8,pc[3256]
80002e14:	90 09       	ld.sh	r9,r8[0x0]
80002e16:	30 08       	mov	r8,0
80002e18:	f0 09 19 00 	cp.h	r9,r8
80002e1c:	c0 71       	brne	80002e2a <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80002e1e:	fe f8 0c a2 	ld.w	r8,pc[3234]
80002e22:	70 0c       	ld.w	r12,r8[0x0]
80002e24:	f0 1f 03 2a 	mcall	80003acc <phy_rx_func+0xea8>
80002e28:	c0 98       	rjmp	80002e3a <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80002e2a:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002e2e:	70 0c       	ld.w	r12,r8[0x0]
80002e30:	fe f8 0c 90 	ld.w	r8,pc[3216]
80002e34:	70 0b       	ld.w	r11,r8[0x0]
80002e36:	f0 1f 03 24 	mcall	80003ac4 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80002e3a:	30 09       	mov	r9,0
80002e3c:	fe f8 0c 70 	ld.w	r8,pc[3184]
80002e40:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80002e42:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002e46:	11 89       	ld.ub	r9,r8[0x0]
80002e48:	30 08       	mov	r8,0
80002e4a:	f0 09 18 00 	cp.b	r9,r8
80002e4e:	c1 31       	brne	80002e74 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80002e50:	fe f6 0c 84 	ld.w	r6,pc[3204]
80002e54:	6c 0c       	ld.w	r12,r6[0x0]
80002e56:	f0 1f 03 1a 	mcall	80003abc <phy_rx_func+0xe98>
80002e5a:	fe f8 0c 7e 	ld.w	r8,pc[3198]
80002e5e:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80002e60:	6c 0c       	ld.w	r12,r6[0x0]
80002e62:	f0 1f 03 17 	mcall	80003abc <phy_rx_func+0xe98>
80002e66:	fe f8 0c 76 	ld.w	r8,pc[3190]
80002e6a:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80002e6c:	30 19       	mov	r9,1
80002e6e:	fe f8 0c 62 	ld.w	r8,pc[3170]
80002e72:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80002e74:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80002e78:	70 08       	ld.w	r8,r8[0x0]
80002e7a:	58 28       	cp.w	r8,2
80002e7c:	e0 80 01 98 	breq	800031ac <phy_rx_func+0x588>
80002e80:	e0 8b 00 06 	brhi	80002e8c <phy_rx_func+0x268>
80002e84:	58 08       	cp.w	r8,0
80002e86:	c0 b0       	breq	80002e9c <phy_rx_func+0x278>
80002e88:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002e8c:	58 38       	cp.w	r8,3
80002e8e:	e0 80 05 c5 	breq	80003a18 <phy_rx_func+0xdf4>
80002e92:	58 48       	cp.w	r8,4
80002e94:	e0 81 06 05 	brne	80003a9e <phy_rx_func+0xe7a>
80002e98:	e0 8f 02 4b 	bral	8000332e <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80002e9c:	6e 28       	ld.w	r8,r7[0x8]
80002e9e:	e0 6a 5a 5a 	mov	r10,23130
80002ea2:	ea 1a ab cd 	orh	r10,0xabcd
80002ea6:	14 38       	cp.w	r8,r10
80002ea8:	c0 71       	brne	80002eb6 <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
80002eaa:	30 09       	mov	r9,0
80002eac:	fe f8 0c 38 	ld.w	r8,pc[3128]
80002eb0:	91 09       	st.w	r8[0x0],r9
80002eb2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80002eb6:	10 99       	mov	r9,r8
80002eb8:	e0 19 00 00 	andl	r9,0x0
80002ebc:	fc 1a ab cd 	movh	r10,0xabcd
80002ec0:	14 39       	cp.w	r9,r10
80002ec2:	e0 81 05 ee 	brne	80003a9e <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80002ec6:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80002eca:	fe f9 0c 1e 	ld.w	r9,pc[3102]
80002ece:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80002ed0:	6e 29       	ld.w	r9,r7[0x8]
80002ed2:	e2 19 f0 00 	andl	r9,0xf000,COH
80002ed6:	e0 49 c0 00 	cp.w	r9,49152
80002eda:	e0 81 00 ce 	brne	80003076 <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
80002ede:	30 1a       	mov	r10,1
80002ee0:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80002ee4:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
80002ee6:	fe f9 0b f6 	ld.w	r9,pc[3062]
80002eea:	72 09       	ld.w	r9,r9[0x0]
80002eec:	58 09       	cp.w	r9,0
80002eee:	c0 71       	brne	80002efc <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80002ef0:	fe fc 0c 00 	ld.w	r12,pc[3072]
80002ef4:	f0 1f 03 00 	mcall	80003af4 <phy_rx_func+0xed0>
80002ef8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80002efc:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80002f00:	fe f9 0b f8 	ld.w	r9,pc[3064]
80002f04:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80002f06:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80002f0a:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
80002f0e:	fe fa 0b ee 	ld.w	r10,pc[3054]
80002f12:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80002f14:	13 89       	ld.ub	r9,r9[0x0]
80002f16:	37 fa       	mov	r10,127
80002f18:	f4 09 18 00 	cp.b	r9,r10
80002f1c:	c6 d0       	breq	80002ff6 <phy_rx_func+0x3d2>
80002f1e:	e0 8b 00 0c 	brhi	80002f36 <phy_rx_func+0x312>
80002f22:	31 2a       	mov	r10,18
80002f24:	f4 09 18 00 	cp.b	r9,r10
80002f28:	c4 20       	breq	80002fac <phy_rx_func+0x388>
80002f2a:	31 3a       	mov	r10,19
80002f2c:	f4 09 18 00 	cp.b	r9,r10
80002f30:	e0 81 00 83 	brne	80003036 <phy_rx_func+0x412>
80002f34:	c5 b8       	rjmp	80002fea <phy_rx_func+0x3c6>
80002f36:	2f 09       	sub	r9,-16
80002f38:	30 1a       	mov	r10,1
80002f3a:	f4 09 18 00 	cp.b	r9,r10
80002f3e:	e0 8b 00 7c 	brhi	80003036 <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80002f42:	ef 38 00 0e 	ld.ub	r8,r7[14]
80002f46:	e2 18 00 f0 	andl	r8,0xf0,COH
80002f4a:	59 08       	cp.w	r8,16
80002f4c:	c0 71       	brne	80002f5a <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
80002f4e:	30 19       	mov	r9,1
80002f50:	fe f8 0b 94 	ld.w	r8,pc[2964]
80002f54:	91 09       	st.w	r8[0x0],r9
80002f56:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80002f5a:	e0 48 00 20 	cp.w	r8,32
80002f5e:	c2 11       	brne	80002fa0 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80002f60:	30 a9       	mov	r9,10
80002f62:	fe f8 0b 82 	ld.w	r8,pc[2946]
80002f66:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80002f68:	fe f6 0b 98 	ld.w	r6,pc[2968]
80002f6c:	6c 08       	ld.w	r8,r6[0x0]
80002f6e:	f0 0a 11 ff 	rsub	r10,r8,-1
80002f72:	fe f7 0b 6a 	ld.w	r7,pc[2922]
80002f76:	2f f8       	sub	r8,-1
80002f78:	6e 0c       	ld.w	r12,r7[0x0]
80002f7a:	f4 ca fe 00 	sub	r10,r10,-512
80002f7e:	30 0b       	mov	r11,0
80002f80:	10 0c       	add	r12,r8
80002f82:	f0 1f 02 e1 	mcall	80003b04 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80002f86:	30 08       	mov	r8,0
80002f88:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80002f8a:	6e 0c       	ld.w	r12,r7[0x0]
80002f8c:	f0 1f 02 df 	mcall	80003b08 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80002f90:	fe f8 0b 44 	ld.w	r8,pc[2884]
80002f94:	70 0c       	ld.w	r12,r8[0x0]
80002f96:	f0 1f 02 ca 	mcall	80003abc <phy_rx_func+0xe98>
80002f9a:	8f 0c       	st.w	r7[0x0],r12
80002f9c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80002fa0:	30 09       	mov	r9,0
80002fa2:	fe f8 0b 42 	ld.w	r8,pc[2882]
80002fa6:	91 09       	st.w	r8[0x0],r9
80002fa8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80002fac:	20 48       	sub	r8,4
80002fae:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80002fb2:	93 08       	st.w	r9[0x0],r8
80002fb4:	58 08       	cp.w	r8,0
80002fb6:	e0 80 05 74 	breq	80003a9e <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80002fba:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80002fbe:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80002fc2:	fe f8 0b 4a 	ld.w	r8,pc[2890]
80002fc6:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80002fc8:	8e 69       	ld.sh	r9,r7[0xc]
80002fca:	fe f8 0b 46 	ld.w	r8,pc[2886]
80002fce:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80002fd0:	8e 79       	ld.sh	r9,r7[0xe]
80002fd2:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80002fd4:	f0 1f 02 d0 	mcall	80003b14 <phy_rx_func+0xef0>
80002fd8:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80002fdc:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80002fde:	30 49       	mov	r9,4
80002fe0:	fe f8 0b 00 	ld.w	r8,pc[2816]
80002fe4:	91 09       	st.w	r8[0x0],r9
80002fe6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80002fea:	30 09       	mov	r9,0
80002fec:	fe f8 0a f8 	ld.w	r8,pc[2808]
80002ff0:	91 09       	st.w	r8[0x0],r9
80002ff2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80002ff6:	20 48       	sub	r8,4
80002ff8:	fe f9 0a f0 	ld.w	r9,pc[2800]
80002ffc:	93 08       	st.w	r9[0x0],r8
80002ffe:	58 08       	cp.w	r8,0
80003000:	e0 80 05 4f 	breq	80003a9e <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003004:	fe f8 0b 14 	ld.w	r8,pc[2836]
80003008:	70 09       	ld.w	r9,r8[0x0]
8000300a:	8e 7b       	ld.sh	r11,r7[0xe]
8000300c:	fe fa 0b 10 	ld.w	r10,pc[2832]
80003010:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003014:	2f f9       	sub	r9,-1
80003016:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003018:	fe f8 0a e4 	ld.w	r8,pc[2788]
8000301c:	70 09       	ld.w	r9,r8[0x0]
8000301e:	20 29       	sub	r9,2
80003020:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003022:	30 29       	mov	r9,2
80003024:	fe f8 0a c0 	ld.w	r8,pc[2752]
80003028:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
8000302a:	30 39       	mov	r9,3
8000302c:	fe f8 0a b4 	ld.w	r8,pc[2740]
80003030:	91 09       	st.w	r8[0x0],r9
80003032:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003036:	30 3a       	mov	r10,3
80003038:	fe f9 0a ac 	ld.w	r9,pc[2732]
8000303c:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
8000303e:	6e 2a       	ld.w	r10,r7[0x8]
80003040:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003044:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003046:	6e 3a       	ld.w	r10,r7[0xc]
80003048:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
8000304a:	59 48       	cp.w	r8,20
8000304c:	c0 61       	brne	80003058 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
8000304e:	31 89       	mov	r9,24
80003050:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003054:	91 09       	st.w	r8[0x0],r9
80003056:	c0 a8       	rjmp	8000306a <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003058:	fe f8 0a 90 	ld.w	r8,pc[2704]
8000305c:	70 08       	ld.w	r8,r8[0x0]
8000305e:	59 08       	cp.w	r8,16
80003060:	c0 51       	brne	8000306a <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003062:	31 09       	mov	r9,16
80003064:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003068:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000306a:	30 49       	mov	r9,4
8000306c:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003070:	91 09       	st.w	r8[0x0],r9
80003072:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80003076:	e0 49 10 00 	cp.w	r9,4096
8000307a:	5f 1a       	srne	r10
8000307c:	e0 49 20 00 	cp.w	r9,8192
80003080:	5f 19       	srne	r9
80003082:	f5 e9 00 09 	and	r9,r10,r9
80003086:	e0 81 05 0c 	brne	80003a9e <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
8000308a:	fe fa 0a 9a 	ld.w	r10,pc[2714]
8000308e:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003090:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003094:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
80003096:	fe fa 0a 62 	ld.w	r10,pc[2658]
8000309a:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
8000309c:	fe f9 0a 3c 	ld.w	r9,pc[2620]
800030a0:	72 09       	ld.w	r9,r9[0x0]
800030a2:	58 09       	cp.w	r9,0
800030a4:	c0 71       	brne	800030b2 <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800030a6:	fe fc 0a 4a 	ld.w	r12,pc[2634]
800030aa:	f0 1f 02 93 	mcall	80003af4 <phy_rx_func+0xed0>
800030ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800030b2:	6e 2a       	ld.w	r10,r7[0x8]
800030b4:	e2 1a 0f 00 	andl	r10,0xf00,COH
800030b8:	58 1a       	cp.w	r10,1
800030ba:	e0 8b 00 4d 	brhi	80003154 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
800030be:	20 48       	sub	r8,4
800030c0:	fe f9 0a 28 	ld.w	r9,pc[2600]
800030c4:	93 08       	st.w	r9[0x0],r8
800030c6:	58 08       	cp.w	r8,0
800030c8:	e0 80 04 eb 	breq	80003a9e <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
800030cc:	8e 68       	ld.sh	r8,r7[0xc]
800030ce:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
800030d2:	fe f9 0a 5a 	ld.w	r9,pc[2650]
800030d6:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
800030d8:	30 09       	mov	r9,0
800030da:	f2 08 19 00 	cp.h	r8,r9
800030de:	c0 70       	breq	800030ec <phy_rx_func+0x4c8>
800030e0:	30 19       	mov	r9,1
800030e2:	f2 08 19 00 	cp.h	r8,r9
800030e6:	e0 81 04 dc 	brne	80003a9e <phy_rx_func+0xe7a>
800030ea:	c2 68       	rjmp	80003136 <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800030ec:	fe f8 0a 44 	ld.w	r8,pc[2628]
800030f0:	70 0a       	ld.w	r10,r8[0x0]
800030f2:	fe f9 09 e6 	ld.w	r9,pc[2534]
800030f6:	72 09       	ld.w	r9,r9[0x0]
800030f8:	8e 7b       	ld.sh	r11,r7[0xe]
800030fa:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800030fe:	70 09       	ld.w	r9,r8[0x0]
80003100:	2f f9       	sub	r9,-1
80003102:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003104:	e0 49 00 ff 	cp.w	r9,255
80003108:	e0 88 00 11 	brls	8000312a <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
8000310c:	30 09       	mov	r9,0
8000310e:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
80003110:	fe f7 09 c8 	ld.w	r7,pc[2504]
80003114:	6e 0c       	ld.w	r12,r7[0x0]
80003116:	f0 1f 02 7d 	mcall	80003b08 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
8000311a:	fe f8 09 ba 	ld.w	r8,pc[2490]
8000311e:	70 0c       	ld.w	r12,r8[0x0]
80003120:	f0 1f 02 67 	mcall	80003abc <phy_rx_func+0xe98>
80003124:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
80003126:	e0 80 04 bc 	breq	80003a9e <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
8000312a:	30 29       	mov	r9,2
8000312c:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003130:	91 09       	st.w	r8[0x0],r9
80003132:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003136:	8e 79       	ld.sh	r9,r7[0xe]
80003138:	30 38       	mov	r8,3
8000313a:	f0 09 19 00 	cp.h	r9,r8
8000313e:	c0 51       	brne	80003148 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003140:	30 19       	mov	r9,1
80003142:	fe f8 09 f2 	ld.w	r8,pc[2546]
80003146:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
80003148:	30 29       	mov	r9,2
8000314a:	fe f8 09 96 	ld.w	r8,pc[2454]
8000314e:	91 09       	st.w	r8[0x0],r9
80003150:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003154:	58 18       	cp.w	r8,1
80003156:	e0 88 04 a4 	brls	80003a9e <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
8000315a:	fe f8 09 d6 	ld.w	r8,pc[2518]
8000315e:	70 0a       	ld.w	r10,r8[0x0]
80003160:	6e 3b       	ld.w	r11,r7[0xc]
80003162:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003166:	70 09       	ld.w	r9,r8[0x0]
80003168:	2f f9       	sub	r9,-1
8000316a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000316c:	e0 49 00 ff 	cp.w	r9,255
80003170:	e0 88 00 11 	brls	80003192 <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003174:	30 09       	mov	r9,0
80003176:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003178:	fe f7 09 60 	ld.w	r7,pc[2400]
8000317c:	6e 0c       	ld.w	r12,r7[0x0]
8000317e:	f0 1f 02 63 	mcall	80003b08 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003182:	fe f8 09 52 	ld.w	r8,pc[2386]
80003186:	70 0c       	ld.w	r12,r8[0x0]
80003188:	f0 1f 02 4d 	mcall	80003abc <phy_rx_func+0xe98>
8000318c:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
8000318e:	e0 80 04 88 	breq	80003a9e <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003192:	fe f9 09 56 	ld.w	r9,pc[2390]
80003196:	72 08       	ld.w	r8,r9[0x0]
80003198:	20 28       	sub	r8,2
8000319a:	93 08       	st.w	r9[0x0],r8
8000319c:	e0 80 04 81 	breq	80003a9e <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
800031a0:	30 29       	mov	r9,2
800031a2:	fe f8 09 3e 	ld.w	r8,pc[2366]
800031a6:	91 09       	st.w	r8[0x0],r9
800031a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
800031ac:	fe f8 09 84 	ld.w	r8,pc[2436]
800031b0:	70 0a       	ld.w	r10,r8[0x0]
800031b2:	fe f9 09 26 	ld.w	r9,pc[2342]
800031b6:	72 09       	ld.w	r9,r9[0x0]
800031b8:	8e 4b       	ld.sh	r11,r7[0x8]
800031ba:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
800031be:	70 09       	ld.w	r9,r8[0x0]
800031c0:	2f f9       	sub	r9,-1
800031c2:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800031c4:	e0 49 00 ff 	cp.w	r9,255
800031c8:	e0 88 00 16 	brls	800031f4 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
800031cc:	30 09       	mov	r9,0
800031ce:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800031d0:	fe f6 09 08 	ld.w	r6,pc[2312]
800031d4:	6c 0c       	ld.w	r12,r6[0x0]
800031d6:	f0 1f 02 4d 	mcall	80003b08 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800031da:	fe f8 08 fa 	ld.w	r8,pc[2298]
800031de:	70 0c       	ld.w	r12,r8[0x0]
800031e0:	f0 1f 02 37 	mcall	80003abc <phy_rx_func+0xe98>
800031e4:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800031e6:	c0 71       	brne	800031f4 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
800031e8:	30 09       	mov	r9,0
800031ea:	fe f8 08 f6 	ld.w	r8,pc[2294]
800031ee:	91 09       	st.w	r8[0x0],r9
800031f0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
800031f4:	fe f9 08 f4 	ld.w	r9,pc[2292]
800031f8:	72 08       	ld.w	r8,r9[0x0]
800031fa:	20 28       	sub	r8,2
800031fc:	93 08       	st.w	r9[0x0],r8
800031fe:	c0 71       	brne	8000320c <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
80003200:	30 09       	mov	r9,0
80003202:	fe f8 08 de 	ld.w	r8,pc[2270]
80003206:	91 09       	st.w	r8[0x0],r9
80003208:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
8000320c:	fe f8 09 24 	ld.w	r8,pc[2340]
80003210:	70 0a       	ld.w	r10,r8[0x0]
80003212:	fe f9 08 c6 	ld.w	r9,pc[2246]
80003216:	72 09       	ld.w	r9,r9[0x0]
80003218:	8e 5b       	ld.sh	r11,r7[0xa]
8000321a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000321e:	70 09       	ld.w	r9,r8[0x0]
80003220:	2f f9       	sub	r9,-1
80003222:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003224:	e0 49 00 ff 	cp.w	r9,255
80003228:	e0 88 00 16 	brls	80003254 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
8000322c:	30 09       	mov	r9,0
8000322e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003230:	fe f6 08 a8 	ld.w	r6,pc[2216]
80003234:	6c 0c       	ld.w	r12,r6[0x0]
80003236:	f0 1f 02 35 	mcall	80003b08 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000323a:	fe f8 08 9a 	ld.w	r8,pc[2202]
8000323e:	70 0c       	ld.w	r12,r8[0x0]
80003240:	f0 1f 02 1f 	mcall	80003abc <phy_rx_func+0xe98>
80003244:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003246:	c0 71       	brne	80003254 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003248:	30 09       	mov	r9,0
8000324a:	fe f8 08 96 	ld.w	r8,pc[2198]
8000324e:	91 09       	st.w	r8[0x0],r9
80003250:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003254:	fe f9 08 94 	ld.w	r9,pc[2196]
80003258:	72 08       	ld.w	r8,r9[0x0]
8000325a:	20 28       	sub	r8,2
8000325c:	93 08       	st.w	r9[0x0],r8
8000325e:	c0 71       	brne	8000326c <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003260:	30 09       	mov	r9,0
80003262:	fe f8 08 7e 	ld.w	r8,pc[2174]
80003266:	91 09       	st.w	r8[0x0],r9
80003268:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
8000326c:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003270:	70 0a       	ld.w	r10,r8[0x0]
80003272:	fe f9 08 66 	ld.w	r9,pc[2150]
80003276:	72 09       	ld.w	r9,r9[0x0]
80003278:	8e 6b       	ld.sh	r11,r7[0xc]
8000327a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000327e:	70 09       	ld.w	r9,r8[0x0]
80003280:	2f f9       	sub	r9,-1
80003282:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003284:	e0 49 00 ff 	cp.w	r9,255
80003288:	e0 88 00 16 	brls	800032b4 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
8000328c:	30 09       	mov	r9,0
8000328e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003290:	fe f6 08 48 	ld.w	r6,pc[2120]
80003294:	6c 0c       	ld.w	r12,r6[0x0]
80003296:	f0 1f 02 1d 	mcall	80003b08 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000329a:	fe f8 08 3a 	ld.w	r8,pc[2106]
8000329e:	70 0c       	ld.w	r12,r8[0x0]
800032a0:	f0 1f 02 07 	mcall	80003abc <phy_rx_func+0xe98>
800032a4:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800032a6:	c0 71       	brne	800032b4 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
800032a8:	30 09       	mov	r9,0
800032aa:	fe f8 08 36 	ld.w	r8,pc[2102]
800032ae:	91 09       	st.w	r8[0x0],r9
800032b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800032b4:	fe f9 08 34 	ld.w	r9,pc[2100]
800032b8:	72 08       	ld.w	r8,r9[0x0]
800032ba:	20 28       	sub	r8,2
800032bc:	93 08       	st.w	r9[0x0],r8
800032be:	c0 71       	brne	800032cc <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
800032c0:	30 09       	mov	r9,0
800032c2:	fe f8 08 1e 	ld.w	r8,pc[2078]
800032c6:	91 09       	st.w	r8[0x0],r9
800032c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800032cc:	fe f8 08 64 	ld.w	r8,pc[2148]
800032d0:	70 0a       	ld.w	r10,r8[0x0]
800032d2:	fe f9 08 06 	ld.w	r9,pc[2054]
800032d6:	72 09       	ld.w	r9,r9[0x0]
800032d8:	8e 7b       	ld.sh	r11,r7[0xe]
800032da:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800032de:	70 09       	ld.w	r9,r8[0x0]
800032e0:	2f f9       	sub	r9,-1
800032e2:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800032e4:	e0 49 00 ff 	cp.w	r9,255
800032e8:	e0 88 00 16 	brls	80003314 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
800032ec:	30 09       	mov	r9,0
800032ee:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800032f0:	fe f7 07 e8 	ld.w	r7,pc[2024]
800032f4:	6e 0c       	ld.w	r12,r7[0x0]
800032f6:	f0 1f 02 05 	mcall	80003b08 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800032fa:	fe f8 07 da 	ld.w	r8,pc[2010]
800032fe:	70 0c       	ld.w	r12,r8[0x0]
80003300:	f0 1f 01 ef 	mcall	80003abc <phy_rx_func+0xe98>
80003304:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003306:	c0 71       	brne	80003314 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
80003308:	30 09       	mov	r9,0
8000330a:	fe f8 07 d6 	ld.w	r8,pc[2006]
8000330e:	91 09       	st.w	r8[0x0],r9
80003310:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003314:	fe f9 07 d4 	ld.w	r9,pc[2004]
80003318:	72 08       	ld.w	r8,r9[0x0]
8000331a:	20 28       	sub	r8,2
8000331c:	93 08       	st.w	r9[0x0],r8
8000331e:	e0 81 03 c0 	brne	80003a9e <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
80003322:	30 09       	mov	r9,0
80003324:	fe f8 07 bc 	ld.w	r8,pc[1980]
80003328:	91 09       	st.w	r8[0x0],r9
8000332a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
8000332e:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003332:	11 89       	ld.ub	r9,r8[0x0]
80003334:	31 28       	mov	r8,18
80003336:	f0 09 18 00 	cp.b	r9,r8
8000333a:	e0 81 01 4c 	brne	800035d2 <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
8000333e:	ef 39 00 09 	ld.ub	r9,r7[9]
80003342:	fe f8 07 b6 	ld.w	r8,pc[1974]
80003346:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003348:	11 89       	ld.ub	r9,r8[0x0]
8000334a:	3f 28       	mov	r8,-14
8000334c:	f0 09 18 00 	cp.b	r9,r8
80003350:	e0 81 01 3b 	brne	800035c6 <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003354:	30 19       	mov	r9,1
80003356:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000335a:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
8000335c:	6e 29       	ld.w	r9,r7[0x8]
8000335e:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003362:	fe f8 07 86 	ld.w	r8,pc[1926]
80003366:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003368:	8e 59       	ld.sh	r9,r7[0xa]
8000336a:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000336e:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003370:	8e 69       	ld.sh	r9,r7[0xc]
80003372:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003374:	8e 79       	ld.sh	r9,r7[0xe]
80003376:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003378:	fe f8 07 88 	ld.w	r8,pc[1928]
8000337c:	fe f9 07 60 	ld.w	r9,pc[1888]
80003380:	72 0a       	ld.w	r10,r9[0x0]
80003382:	70 09       	ld.w	r9,r8[0x0]
80003384:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003388:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000338c:	70 09       	ld.w	r9,r8[0x0]
8000338e:	2f f9       	sub	r9,-1
80003390:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003392:	e0 49 01 ff 	cp.w	r9,511
80003396:	e0 88 00 16 	brls	800033c2 <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
8000339a:	30 09       	mov	r9,0
8000339c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000339e:	fe f6 07 3e 	ld.w	r6,pc[1854]
800033a2:	6c 0c       	ld.w	r12,r6[0x0]
800033a4:	f0 1f 01 d9 	mcall	80003b08 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800033a8:	fe f8 07 2c 	ld.w	r8,pc[1836]
800033ac:	70 0c       	ld.w	r12,r8[0x0]
800033ae:	f0 1f 01 c4 	mcall	80003abc <phy_rx_func+0xe98>
800033b2:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800033b4:	c0 71       	brne	800033c2 <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
800033b6:	30 09       	mov	r9,0
800033b8:	fe f8 07 28 	ld.w	r8,pc[1832]
800033bc:	91 09       	st.w	r8[0x0],r9
800033be:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800033c2:	fe f9 07 26 	ld.w	r9,pc[1830]
800033c6:	72 08       	ld.w	r8,r9[0x0]
800033c8:	20 18       	sub	r8,1
800033ca:	93 08       	st.w	r9[0x0],r8
800033cc:	c0 71       	brne	800033da <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
800033ce:	30 09       	mov	r9,0
800033d0:	fe f8 07 10 	ld.w	r8,pc[1808]
800033d4:	91 09       	st.w	r8[0x0],r9
800033d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
800033da:	fe f8 07 26 	ld.w	r8,pc[1830]
800033de:	fe f9 06 fe 	ld.w	r9,pc[1790]
800033e2:	72 0a       	ld.w	r10,r9[0x0]
800033e4:	70 09       	ld.w	r9,r8[0x0]
800033e6:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800033ea:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800033ee:	70 09       	ld.w	r9,r8[0x0]
800033f0:	2f f9       	sub	r9,-1
800033f2:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800033f4:	e0 49 01 ff 	cp.w	r9,511
800033f8:	e0 88 00 16 	brls	80003424 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
800033fc:	30 09       	mov	r9,0
800033fe:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003400:	fe f6 06 dc 	ld.w	r6,pc[1756]
80003404:	6c 0c       	ld.w	r12,r6[0x0]
80003406:	f0 1f 01 c1 	mcall	80003b08 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000340a:	fe f8 06 ca 	ld.w	r8,pc[1738]
8000340e:	70 0c       	ld.w	r12,r8[0x0]
80003410:	f0 1f 01 ab 	mcall	80003abc <phy_rx_func+0xe98>
80003414:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003416:	c0 71       	brne	80003424 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
80003418:	30 09       	mov	r9,0
8000341a:	fe f8 06 c6 	ld.w	r8,pc[1734]
8000341e:	91 09       	st.w	r8[0x0],r9
80003420:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003424:	fe f9 06 c4 	ld.w	r9,pc[1732]
80003428:	72 08       	ld.w	r8,r9[0x0]
8000342a:	20 18       	sub	r8,1
8000342c:	93 08       	st.w	r9[0x0],r8
8000342e:	c0 71       	brne	8000343c <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003430:	30 09       	mov	r9,0
80003432:	fe f8 06 ae 	ld.w	r8,pc[1710]
80003436:	91 09       	st.w	r8[0x0],r9
80003438:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
8000343c:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003440:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003444:	72 0a       	ld.w	r10,r9[0x0]
80003446:	70 09       	ld.w	r9,r8[0x0]
80003448:	ef 3b 00 0c 	ld.ub	r11,r7[12]
8000344c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003450:	70 09       	ld.w	r9,r8[0x0]
80003452:	2f f9       	sub	r9,-1
80003454:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003456:	e0 49 01 ff 	cp.w	r9,511
8000345a:	e0 88 00 16 	brls	80003486 <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
8000345e:	30 09       	mov	r9,0
80003460:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003462:	fe f6 06 7a 	ld.w	r6,pc[1658]
80003466:	6c 0c       	ld.w	r12,r6[0x0]
80003468:	f0 1f 01 a8 	mcall	80003b08 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000346c:	fe f8 06 68 	ld.w	r8,pc[1640]
80003470:	70 0c       	ld.w	r12,r8[0x0]
80003472:	f0 1f 01 93 	mcall	80003abc <phy_rx_func+0xe98>
80003476:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003478:	c0 71       	brne	80003486 <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
8000347a:	30 09       	mov	r9,0
8000347c:	fe f8 06 64 	ld.w	r8,pc[1636]
80003480:	91 09       	st.w	r8[0x0],r9
80003482:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003486:	fe f9 06 62 	ld.w	r9,pc[1634]
8000348a:	72 08       	ld.w	r8,r9[0x0]
8000348c:	20 18       	sub	r8,1
8000348e:	93 08       	st.w	r9[0x0],r8
80003490:	c0 71       	brne	8000349e <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
80003492:	30 09       	mov	r9,0
80003494:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003498:	91 09       	st.w	r8[0x0],r9
8000349a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
8000349e:	fe f8 06 62 	ld.w	r8,pc[1634]
800034a2:	fe f9 06 3a 	ld.w	r9,pc[1594]
800034a6:	72 0a       	ld.w	r10,r9[0x0]
800034a8:	70 09       	ld.w	r9,r8[0x0]
800034aa:	ef 3b 00 0d 	ld.ub	r11,r7[13]
800034ae:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800034b2:	70 09       	ld.w	r9,r8[0x0]
800034b4:	2f f9       	sub	r9,-1
800034b6:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800034b8:	e0 49 01 ff 	cp.w	r9,511
800034bc:	e0 88 00 16 	brls	800034e8 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
800034c0:	30 09       	mov	r9,0
800034c2:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800034c4:	fe f6 06 18 	ld.w	r6,pc[1560]
800034c8:	6c 0c       	ld.w	r12,r6[0x0]
800034ca:	f0 1f 01 90 	mcall	80003b08 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800034ce:	fe f8 06 06 	ld.w	r8,pc[1542]
800034d2:	70 0c       	ld.w	r12,r8[0x0]
800034d4:	f0 1f 01 7a 	mcall	80003abc <phy_rx_func+0xe98>
800034d8:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800034da:	c0 71       	brne	800034e8 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
800034dc:	30 09       	mov	r9,0
800034de:	fe f8 06 02 	ld.w	r8,pc[1538]
800034e2:	91 09       	st.w	r8[0x0],r9
800034e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800034e8:	fe f9 06 00 	ld.w	r9,pc[1536]
800034ec:	72 08       	ld.w	r8,r9[0x0]
800034ee:	20 18       	sub	r8,1
800034f0:	93 08       	st.w	r9[0x0],r8
800034f2:	c0 71       	brne	80003500 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
800034f4:	30 09       	mov	r9,0
800034f6:	fe f8 05 ea 	ld.w	r8,pc[1514]
800034fa:	91 09       	st.w	r8[0x0],r9
800034fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003500:	fe f8 06 00 	ld.w	r8,pc[1536]
80003504:	fe f9 05 d8 	ld.w	r9,pc[1496]
80003508:	72 0a       	ld.w	r10,r9[0x0]
8000350a:	70 09       	ld.w	r9,r8[0x0]
8000350c:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003510:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003514:	70 09       	ld.w	r9,r8[0x0]
80003516:	2f f9       	sub	r9,-1
80003518:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000351a:	e0 49 01 ff 	cp.w	r9,511
8000351e:	e0 88 00 16 	brls	8000354a <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
80003522:	30 09       	mov	r9,0
80003524:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003526:	fe f6 05 b6 	ld.w	r6,pc[1462]
8000352a:	6c 0c       	ld.w	r12,r6[0x0]
8000352c:	f0 1f 01 77 	mcall	80003b08 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003530:	fe f8 05 a4 	ld.w	r8,pc[1444]
80003534:	70 0c       	ld.w	r12,r8[0x0]
80003536:	f0 1f 01 62 	mcall	80003abc <phy_rx_func+0xe98>
8000353a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000353c:	c0 71       	brne	8000354a <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
8000353e:	30 09       	mov	r9,0
80003540:	fe f8 05 a0 	ld.w	r8,pc[1440]
80003544:	91 09       	st.w	r8[0x0],r9
80003546:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000354a:	fe f9 05 9e 	ld.w	r9,pc[1438]
8000354e:	72 08       	ld.w	r8,r9[0x0]
80003550:	20 18       	sub	r8,1
80003552:	93 08       	st.w	r9[0x0],r8
80003554:	c0 71       	brne	80003562 <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
80003556:	30 09       	mov	r9,0
80003558:	fe f8 05 88 	ld.w	r8,pc[1416]
8000355c:	91 09       	st.w	r8[0x0],r9
8000355e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003562:	fe f8 05 9e 	ld.w	r8,pc[1438]
80003566:	fe f9 05 76 	ld.w	r9,pc[1398]
8000356a:	72 0a       	ld.w	r10,r9[0x0]
8000356c:	70 09       	ld.w	r9,r8[0x0]
8000356e:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003572:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003576:	70 09       	ld.w	r9,r8[0x0]
80003578:	2f f9       	sub	r9,-1
8000357a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000357c:	e0 49 01 ff 	cp.w	r9,511
80003580:	e0 88 00 16 	brls	800035ac <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003584:	30 09       	mov	r9,0
80003586:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003588:	fe f7 05 54 	ld.w	r7,pc[1364]
8000358c:	6e 0c       	ld.w	r12,r7[0x0]
8000358e:	f0 1f 01 5f 	mcall	80003b08 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003592:	fe f8 05 42 	ld.w	r8,pc[1346]
80003596:	70 0c       	ld.w	r12,r8[0x0]
80003598:	f0 1f 01 49 	mcall	80003abc <phy_rx_func+0xe98>
8000359c:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000359e:	c0 71       	brne	800035ac <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
800035a0:	30 09       	mov	r9,0
800035a2:	fe f8 05 3e 	ld.w	r8,pc[1342]
800035a6:	91 09       	st.w	r8[0x0],r9
800035a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035ac:	fe f9 05 3c 	ld.w	r9,pc[1340]
800035b0:	72 08       	ld.w	r8,r9[0x0]
800035b2:	20 18       	sub	r8,1
800035b4:	93 08       	st.w	r9[0x0],r8
800035b6:	e0 81 02 74 	brne	80003a9e <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
800035ba:	30 09       	mov	r9,0
800035bc:	fe f8 05 24 	ld.w	r8,pc[1316]
800035c0:	91 09       	st.w	r8[0x0],r9
800035c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
800035c6:	30 09       	mov	r9,0
800035c8:	fe f8 05 18 	ld.w	r8,pc[1304]
800035cc:	91 09       	st.w	r8[0x0],r9
800035ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
800035d2:	fe f8 05 26 	ld.w	r8,pc[1318]
800035d6:	11 89       	ld.ub	r9,r8[0x0]
800035d8:	3f 28       	mov	r8,-14
800035da:	f0 09 18 00 	cp.b	r9,r8
800035de:	c4 31       	brne	80003664 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
800035e0:	8e 49       	ld.sh	r9,r7[0x8]
800035e2:	fe f8 05 56 	ld.w	r8,pc[1366]
800035e6:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
800035e8:	fe f8 05 18 	ld.w	r8,pc[1304]
800035ec:	fe f9 04 f0 	ld.w	r9,pc[1264]
800035f0:	72 0a       	ld.w	r10,r9[0x0]
800035f2:	70 09       	ld.w	r9,r8[0x0]
800035f4:	ef 3b 00 08 	ld.ub	r11,r7[8]
800035f8:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800035fc:	70 09       	ld.w	r9,r8[0x0]
800035fe:	2f f9       	sub	r9,-1
80003600:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003602:	e0 49 01 ff 	cp.w	r9,511
80003606:	e0 88 00 16 	brls	80003632 <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
8000360a:	30 09       	mov	r9,0
8000360c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000360e:	fe f7 04 ce 	ld.w	r7,pc[1230]
80003612:	6e 0c       	ld.w	r12,r7[0x0]
80003614:	f0 1f 01 3d 	mcall	80003b08 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003618:	fe f8 04 bc 	ld.w	r8,pc[1212]
8000361c:	70 0c       	ld.w	r12,r8[0x0]
8000361e:	f0 1f 01 28 	mcall	80003abc <phy_rx_func+0xe98>
80003622:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003624:	c0 71       	brne	80003632 <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
80003626:	30 09       	mov	r9,0
80003628:	fe f8 04 b8 	ld.w	r8,pc[1208]
8000362c:	91 09       	st.w	r8[0x0],r9
8000362e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003632:	fe f9 04 b6 	ld.w	r9,pc[1206]
80003636:	72 08       	ld.w	r8,r9[0x0]
80003638:	20 18       	sub	r8,1
8000363a:	93 08       	st.w	r9[0x0],r8
8000363c:	c0 71       	brne	8000364a <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
8000363e:	30 09       	mov	r9,0
80003640:	fe f8 04 a0 	ld.w	r8,pc[1184]
80003644:	91 09       	st.w	r8[0x0],r9
80003646:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
8000364a:	20 18       	sub	r8,1
8000364c:	fe f9 04 9c 	ld.w	r9,pc[1180]
80003650:	93 08       	st.w	r9[0x0],r8
80003652:	58 08       	cp.w	r8,0
80003654:	e0 81 02 25 	brne	80003a9e <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80003658:	30 09       	mov	r9,0
8000365a:	fe f8 04 86 	ld.w	r8,pc[1158]
8000365e:	91 09       	st.w	r8[0x0],r9
80003660:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003664:	fe f8 04 94 	ld.w	r8,pc[1172]
80003668:	11 89       	ld.ub	r9,r8[0x0]
8000366a:	3f 38       	mov	r8,-13
8000366c:	f0 09 18 00 	cp.b	r9,r8
80003670:	e0 81 01 0c 	brne	80003888 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003674:	8e 49       	ld.sh	r9,r7[0x8]
80003676:	fe f8 04 c2 	ld.w	r8,pc[1218]
8000367a:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
8000367c:	8e 59       	ld.sh	r9,r7[0xa]
8000367e:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003680:	8e 69       	ld.sh	r9,r7[0xc]
80003682:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003684:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003688:	fe f9 04 54 	ld.w	r9,pc[1108]
8000368c:	72 0a       	ld.w	r10,r9[0x0]
8000368e:	70 09       	ld.w	r9,r8[0x0]
80003690:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003694:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003698:	70 09       	ld.w	r9,r8[0x0]
8000369a:	2f f9       	sub	r9,-1
8000369c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000369e:	e0 49 01 ff 	cp.w	r9,511
800036a2:	e0 88 00 16 	brls	800036ce <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
800036a6:	30 09       	mov	r9,0
800036a8:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800036aa:	fe f6 04 32 	ld.w	r6,pc[1074]
800036ae:	6c 0c       	ld.w	r12,r6[0x0]
800036b0:	f0 1f 01 16 	mcall	80003b08 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800036b4:	fe f8 04 20 	ld.w	r8,pc[1056]
800036b8:	70 0c       	ld.w	r12,r8[0x0]
800036ba:	f0 1f 01 01 	mcall	80003abc <phy_rx_func+0xe98>
800036be:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800036c0:	c0 71       	brne	800036ce <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
800036c2:	30 09       	mov	r9,0
800036c4:	fe f8 04 1c 	ld.w	r8,pc[1052]
800036c8:	91 09       	st.w	r8[0x0],r9
800036ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800036ce:	fe f9 04 1a 	ld.w	r9,pc[1050]
800036d2:	72 08       	ld.w	r8,r9[0x0]
800036d4:	20 18       	sub	r8,1
800036d6:	93 08       	st.w	r9[0x0],r8
800036d8:	c0 71       	brne	800036e6 <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
800036da:	30 09       	mov	r9,0
800036dc:	fe f8 04 04 	ld.w	r8,pc[1028]
800036e0:	91 09       	st.w	r8[0x0],r9
800036e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
800036e6:	fe f8 04 1a 	ld.w	r8,pc[1050]
800036ea:	fe f9 03 f2 	ld.w	r9,pc[1010]
800036ee:	72 0a       	ld.w	r10,r9[0x0]
800036f0:	70 09       	ld.w	r9,r8[0x0]
800036f2:	ef 3b 00 09 	ld.ub	r11,r7[9]
800036f6:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800036fa:	70 09       	ld.w	r9,r8[0x0]
800036fc:	2f f9       	sub	r9,-1
800036fe:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003700:	e0 49 01 ff 	cp.w	r9,511
80003704:	e0 88 00 16 	brls	80003730 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
80003708:	30 09       	mov	r9,0
8000370a:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000370c:	fe f6 03 d0 	ld.w	r6,pc[976]
80003710:	6c 0c       	ld.w	r12,r6[0x0]
80003712:	f0 1f 00 fe 	mcall	80003b08 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003716:	fe f8 03 be 	ld.w	r8,pc[958]
8000371a:	70 0c       	ld.w	r12,r8[0x0]
8000371c:	f0 1f 00 e8 	mcall	80003abc <phy_rx_func+0xe98>
80003720:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003722:	c0 71       	brne	80003730 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
80003724:	30 09       	mov	r9,0
80003726:	fe f8 03 ba 	ld.w	r8,pc[954]
8000372a:	91 09       	st.w	r8[0x0],r9
8000372c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003730:	fe f9 03 b8 	ld.w	r9,pc[952]
80003734:	72 08       	ld.w	r8,r9[0x0]
80003736:	20 18       	sub	r8,1
80003738:	93 08       	st.w	r9[0x0],r8
8000373a:	c0 71       	brne	80003748 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
8000373c:	30 09       	mov	r9,0
8000373e:	fe f8 03 a2 	ld.w	r8,pc[930]
80003742:	91 09       	st.w	r8[0x0],r9
80003744:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003748:	fe f8 03 b8 	ld.w	r8,pc[952]
8000374c:	fe f9 03 90 	ld.w	r9,pc[912]
80003750:	72 0a       	ld.w	r10,r9[0x0]
80003752:	70 09       	ld.w	r9,r8[0x0]
80003754:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003758:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000375c:	70 09       	ld.w	r9,r8[0x0]
8000375e:	2f f9       	sub	r9,-1
80003760:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003762:	e0 49 01 ff 	cp.w	r9,511
80003766:	e0 88 00 16 	brls	80003792 <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
8000376a:	30 09       	mov	r9,0
8000376c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000376e:	fe f6 03 6e 	ld.w	r6,pc[878]
80003772:	6c 0c       	ld.w	r12,r6[0x0]
80003774:	f0 1f 00 e5 	mcall	80003b08 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003778:	fe f8 03 5c 	ld.w	r8,pc[860]
8000377c:	70 0c       	ld.w	r12,r8[0x0]
8000377e:	f0 1f 00 d0 	mcall	80003abc <phy_rx_func+0xe98>
80003782:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003784:	c0 71       	brne	80003792 <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
80003786:	30 09       	mov	r9,0
80003788:	fe f8 03 58 	ld.w	r8,pc[856]
8000378c:	91 09       	st.w	r8[0x0],r9
8000378e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003792:	fe f9 03 56 	ld.w	r9,pc[854]
80003796:	72 08       	ld.w	r8,r9[0x0]
80003798:	20 18       	sub	r8,1
8000379a:	93 08       	st.w	r9[0x0],r8
8000379c:	c0 71       	brne	800037aa <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
8000379e:	30 09       	mov	r9,0
800037a0:	fe f8 03 40 	ld.w	r8,pc[832]
800037a4:	91 09       	st.w	r8[0x0],r9
800037a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
800037aa:	fe f8 03 56 	ld.w	r8,pc[854]
800037ae:	fe f9 03 2e 	ld.w	r9,pc[814]
800037b2:	72 0a       	ld.w	r10,r9[0x0]
800037b4:	70 09       	ld.w	r9,r8[0x0]
800037b6:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800037ba:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800037be:	70 09       	ld.w	r9,r8[0x0]
800037c0:	2f f9       	sub	r9,-1
800037c2:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037c4:	e0 49 01 ff 	cp.w	r9,511
800037c8:	e0 88 00 16 	brls	800037f4 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
800037cc:	30 09       	mov	r9,0
800037ce:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800037d0:	fe f6 03 0c 	ld.w	r6,pc[780]
800037d4:	6c 0c       	ld.w	r12,r6[0x0]
800037d6:	f0 1f 00 cd 	mcall	80003b08 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800037da:	fe f8 02 fa 	ld.w	r8,pc[762]
800037de:	70 0c       	ld.w	r12,r8[0x0]
800037e0:	f0 1f 00 b7 	mcall	80003abc <phy_rx_func+0xe98>
800037e4:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800037e6:	c0 71       	brne	800037f4 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
800037e8:	30 09       	mov	r9,0
800037ea:	fe f8 02 f6 	ld.w	r8,pc[758]
800037ee:	91 09       	st.w	r8[0x0],r9
800037f0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800037f4:	fe f9 02 f4 	ld.w	r9,pc[756]
800037f8:	72 08       	ld.w	r8,r9[0x0]
800037fa:	20 18       	sub	r8,1
800037fc:	93 08       	st.w	r9[0x0],r8
800037fe:	c0 71       	brne	8000380c <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
80003800:	30 09       	mov	r9,0
80003802:	fe f8 02 de 	ld.w	r8,pc[734]
80003806:	91 09       	st.w	r8[0x0],r9
80003808:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
8000380c:	fe f8 02 f4 	ld.w	r8,pc[756]
80003810:	fe f9 02 cc 	ld.w	r9,pc[716]
80003814:	72 0a       	ld.w	r10,r9[0x0]
80003816:	70 09       	ld.w	r9,r8[0x0]
80003818:	ef 3b 00 0c 	ld.ub	r11,r7[12]
8000381c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003820:	70 09       	ld.w	r9,r8[0x0]
80003822:	2f f9       	sub	r9,-1
80003824:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003826:	e0 49 01 ff 	cp.w	r9,511
8000382a:	e0 88 00 16 	brls	80003856 <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
8000382e:	30 09       	mov	r9,0
80003830:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003832:	fe f7 02 aa 	ld.w	r7,pc[682]
80003836:	6e 0c       	ld.w	r12,r7[0x0]
80003838:	f0 1f 00 b4 	mcall	80003b08 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000383c:	fe f8 02 98 	ld.w	r8,pc[664]
80003840:	70 0c       	ld.w	r12,r8[0x0]
80003842:	f0 1f 00 9f 	mcall	80003abc <phy_rx_func+0xe98>
80003846:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003848:	c0 71       	brne	80003856 <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
8000384a:	30 09       	mov	r9,0
8000384c:	fe f8 02 94 	ld.w	r8,pc[660]
80003850:	91 09       	st.w	r8[0x0],r9
80003852:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003856:	fe f9 02 92 	ld.w	r9,pc[658]
8000385a:	72 08       	ld.w	r8,r9[0x0]
8000385c:	20 18       	sub	r8,1
8000385e:	93 08       	st.w	r9[0x0],r8
80003860:	c0 71       	brne	8000386e <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003862:	30 09       	mov	r9,0
80003864:	fe f8 02 7c 	ld.w	r8,pc[636]
80003868:	91 09       	st.w	r8[0x0],r9
8000386a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
8000386e:	20 18       	sub	r8,1
80003870:	fe f9 02 78 	ld.w	r9,pc[632]
80003874:	93 08       	st.w	r9[0x0],r8
80003876:	58 08       	cp.w	r8,0
80003878:	e0 81 01 13 	brne	80003a9e <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
8000387c:	30 09       	mov	r9,0
8000387e:	fe f8 02 62 	ld.w	r8,pc[610]
80003882:	91 09       	st.w	r8[0x0],r9
80003884:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003888:	fe f8 02 70 	ld.w	r8,pc[624]
8000388c:	11 89       	ld.ub	r9,r8[0x0]
8000388e:	30 48       	mov	r8,4
80003890:	f0 09 18 00 	cp.b	r9,r8
80003894:	c0 80       	breq	800038a4 <phy_rx_func+0xc80>
80003896:	fe f8 02 62 	ld.w	r8,pc[610]
8000389a:	11 89       	ld.ub	r9,r8[0x0]
8000389c:	30 38       	mov	r8,3
8000389e:	f0 09 18 00 	cp.b	r9,r8
800038a2:	c1 41       	brne	800038ca <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
800038a4:	6e 29       	ld.w	r9,r7[0x8]
800038a6:	fe f8 02 7a 	ld.w	r8,pc[634]
800038aa:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
800038ac:	6e 39       	ld.w	r9,r7[0xc]
800038ae:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
800038b0:	fe f9 02 38 	ld.w	r9,pc[568]
800038b4:	72 08       	ld.w	r8,r9[0x0]
800038b6:	20 88       	sub	r8,8
800038b8:	93 08       	st.w	r9[0x0],r8
800038ba:	e0 81 00 f2 	brne	80003a9e <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
800038be:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
800038c0:	fe f9 02 20 	ld.w	r9,pc[544]
800038c4:	93 08       	st.w	r9[0x0],r8
800038c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
800038ca:	fe f8 02 2e 	ld.w	r8,pc[558]
800038ce:	11 89       	ld.ub	r9,r8[0x0]
800038d0:	31 38       	mov	r8,19
800038d2:	f0 09 18 00 	cp.b	r9,r8
800038d6:	e0 81 00 9c 	brne	80003a0e <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
800038da:	fe f8 02 62 	ld.w	r8,pc[610]
800038de:	11 88       	ld.ub	r8,r8[0x0]
800038e0:	30 c9       	mov	r9,12
800038e2:	f2 08 18 00 	cp.b	r8,r9
800038e6:	e0 81 00 7b 	brne	800039dc <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
800038ea:	8e 49       	ld.sh	r9,r7[0x8]
800038ec:	fe f8 02 54 	ld.w	r8,pc[596]
800038f0:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
800038f4:	30 09       	mov	r9,0
800038f6:	fe f8 02 46 	ld.w	r8,pc[582]
800038fa:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800038fc:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003900:	3f 38       	mov	r8,-13
80003902:	f0 09 18 00 	cp.b	r9,r8
80003906:	c6 61       	brne	800039d2 <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003908:	10 99       	mov	r9,r8
8000390a:	4f c8       	lddpc	r8,80003af8 <phy_rx_func+0xed4>
8000390c:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
8000390e:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003912:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003916:	4f 58       	lddpc	r8,80003ae8 <phy_rx_func+0xec4>
80003918:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
8000391a:	30 19       	mov	r9,1
8000391c:	fe f8 02 0c 	ld.w	r8,pc[524]
80003920:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003922:	8e 79       	ld.sh	r9,r7[0xe]
80003924:	fe f8 02 14 	ld.w	r8,pc[532]
80003928:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
8000392a:	4f 68       	lddpc	r8,80003b00 <phy_rx_func+0xedc>
8000392c:	4e c9       	lddpc	r9,80003adc <phy_rx_func+0xeb8>
8000392e:	72 0a       	ld.w	r10,r9[0x0]
80003930:	70 09       	ld.w	r9,r8[0x0]
80003932:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003936:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
8000393a:	70 09       	ld.w	r9,r8[0x0]
8000393c:	2f f9       	sub	r9,-1
8000393e:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003940:	e0 49 01 ff 	cp.w	r9,511
80003944:	e0 88 00 13 	brls	8000396a <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003948:	30 09       	mov	r9,0
8000394a:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
8000394c:	4e 46       	lddpc	r6,80003adc <phy_rx_func+0xeb8>
8000394e:	6c 0c       	ld.w	r12,r6[0x0]
80003950:	f0 1f 00 6e 	mcall	80003b08 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003954:	4e 08       	lddpc	r8,80003ad4 <phy_rx_func+0xeb0>
80003956:	70 0c       	ld.w	r12,r8[0x0]
80003958:	f0 1f 00 59 	mcall	80003abc <phy_rx_func+0xe98>
8000395c:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
8000395e:	c0 61       	brne	8000396a <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003960:	30 09       	mov	r9,0
80003962:	4e 08       	lddpc	r8,80003ae0 <phy_rx_func+0xebc>
80003964:	91 09       	st.w	r8[0x0],r9
80003966:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
8000396a:	4e 09       	lddpc	r9,80003ae8 <phy_rx_func+0xec4>
8000396c:	72 08       	ld.w	r8,r9[0x0]
8000396e:	20 18       	sub	r8,1
80003970:	93 08       	st.w	r9[0x0],r8
80003972:	c0 61       	brne	8000397e <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003974:	30 09       	mov	r9,0
80003976:	4d b8       	lddpc	r8,80003ae0 <phy_rx_func+0xebc>
80003978:	91 09       	st.w	r8[0x0],r9
8000397a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
8000397e:	4e 18       	lddpc	r8,80003b00 <phy_rx_func+0xedc>
80003980:	4d 79       	lddpc	r9,80003adc <phy_rx_func+0xeb8>
80003982:	72 0a       	ld.w	r10,r9[0x0]
80003984:	70 09       	ld.w	r9,r8[0x0]
80003986:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000398a:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
8000398e:	70 09       	ld.w	r9,r8[0x0]
80003990:	2f f9       	sub	r9,-1
80003992:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003994:	e0 49 01 ff 	cp.w	r9,511
80003998:	e0 88 00 13 	brls	800039be <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
8000399c:	30 09       	mov	r9,0
8000399e:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
800039a0:	4c f7       	lddpc	r7,80003adc <phy_rx_func+0xeb8>
800039a2:	6e 0c       	ld.w	r12,r7[0x0]
800039a4:	f0 1f 00 59 	mcall	80003b08 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
800039a8:	4c b8       	lddpc	r8,80003ad4 <phy_rx_func+0xeb0>
800039aa:	70 0c       	ld.w	r12,r8[0x0]
800039ac:	f0 1f 00 44 	mcall	80003abc <phy_rx_func+0xe98>
800039b0:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
800039b2:	c0 61       	brne	800039be <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
800039b4:	30 09       	mov	r9,0
800039b6:	4c b8       	lddpc	r8,80003ae0 <phy_rx_func+0xebc>
800039b8:	91 09       	st.w	r8[0x0],r9
800039ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
800039be:	4c b9       	lddpc	r9,80003ae8 <phy_rx_func+0xec4>
800039c0:	72 08       	ld.w	r8,r9[0x0]
800039c2:	20 18       	sub	r8,1
800039c4:	93 08       	st.w	r9[0x0],r8
800039c6:	c6 c1       	brne	80003a9e <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
800039c8:	30 09       	mov	r9,0
800039ca:	4c 68       	lddpc	r8,80003ae0 <phy_rx_func+0xebc>
800039cc:	91 09       	st.w	r8[0x0],r9
800039ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
800039d2:	30 09       	mov	r9,0
800039d4:	4c 38       	lddpc	r8,80003ae0 <phy_rx_func+0xebc>
800039d6:	91 09       	st.w	r8[0x0],r9
800039d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
800039dc:	8e 4a       	ld.sh	r10,r7[0x8]
800039de:	4d 99       	lddpc	r9,80003b40 <phy_rx_func+0xf1c>
800039e0:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
800039e4:	4d 6a       	lddpc	r10,80003b3c <phy_rx_func+0xf18>
800039e6:	15 88       	ld.ub	r8,r10[0x0]
800039e8:	f0 cb ff ff 	sub	r11,r8,-1
800039ec:	8e 5c       	ld.sh	r12,r7[0xa]
800039ee:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
800039f2:	f0 cb ff fe 	sub	r11,r8,-2
800039f6:	8e 6c       	ld.sh	r12,r7[0xc]
800039f8:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
800039fc:	f0 cb ff fd 	sub	r11,r8,-3
80003a00:	8e 7c       	ld.sh	r12,r7[0xe]
80003a02:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003a06:	2f c8       	sub	r8,-4
80003a08:	b4 88       	st.b	r10[0x0],r8
80003a0a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003a0e:	30 09       	mov	r9,0
80003a10:	4b 48       	lddpc	r8,80003ae0 <phy_rx_func+0xebc>
80003a12:	91 09       	st.w	r8[0x0],r9
80003a14:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003a18:	4c 08       	lddpc	r8,80003b18 <phy_rx_func+0xef4>
80003a1a:	70 09       	ld.w	r9,r8[0x0]
80003a1c:	8e 4b       	ld.sh	r11,r7[0x8]
80003a1e:	4c 0a       	lddpc	r10,80003b1c <phy_rx_func+0xef8>
80003a20:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003a24:	2f f9       	sub	r9,-1
80003a26:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003a28:	4b 58       	lddpc	r8,80003afc <phy_rx_func+0xed8>
80003a2a:	70 09       	ld.w	r9,r8[0x0]
80003a2c:	20 29       	sub	r9,2
80003a2e:	91 09       	st.w	r8[0x0],r9
80003a30:	70 08       	ld.w	r8,r8[0x0]
80003a32:	58 08       	cp.w	r8,0
80003a34:	c2 f1       	brne	80003a92 <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003a36:	30 09       	mov	r9,0
80003a38:	4b 88       	lddpc	r8,80003b18 <phy_rx_func+0xef4>
80003a3a:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003a3c:	8e 59       	ld.sh	r9,r7[0xa]
80003a3e:	fe 78 82 12 	mov	r8,-32238
80003a42:	f0 09 19 00 	cp.h	r9,r8
80003a46:	c2 11       	brne	80003a88 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003a48:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003a4c:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003a50:	4a f8       	lddpc	r8,80003b0c <phy_rx_func+0xee8>
80003a52:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003a54:	8e 59       	ld.sh	r9,r7[0xa]
80003a56:	4a f8       	lddpc	r8,80003b10 <phy_rx_func+0xeec>
80003a58:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003a5a:	8e 69       	ld.sh	r9,r7[0xc]
80003a5c:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003a5e:	f0 1f 00 2e 	mcall	80003b14 <phy_rx_func+0xef0>
80003a62:	4a 18       	lddpc	r8,80003ae4 <phy_rx_func+0xec0>
80003a64:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003a66:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003a6a:	31 38       	mov	r8,19
80003a6c:	f0 09 18 00 	cp.b	r9,r8
80003a70:	c0 71       	brne	80003a7e <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003a72:	10 99       	mov	r9,r8
80003a74:	4a 18       	lddpc	r8,80003af8 <phy_rx_func+0xed4>
80003a76:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003a78:	30 09       	mov	r9,0
80003a7a:	49 c8       	lddpc	r8,80003ae8 <phy_rx_func+0xec4>
80003a7c:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003a7e:	30 49       	mov	r9,4
80003a80:	49 88       	lddpc	r8,80003ae0 <phy_rx_func+0xebc>
80003a82:	91 09       	st.w	r8[0x0],r9
80003a84:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003a88:	30 09       	mov	r9,0
80003a8a:	49 68       	lddpc	r8,80003ae0 <phy_rx_func+0xebc>
80003a8c:	91 09       	st.w	r8[0x0],r9
80003a8e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003a92:	4a dc       	lddpc	r12,80003b44 <phy_rx_func+0xf20>
80003a94:	f0 1f 00 18 	mcall	80003af4 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003a98:	30 09       	mov	r9,0
80003a9a:	49 28       	lddpc	r8,80003ae0 <phy_rx_func+0xebc>
80003a9c:	91 09       	st.w	r8[0x0],r9
80003a9e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003aa2:	00 00       	add	r0,r0
80003aa4:	00 00       	add	r0,r0
80003aa6:	0a b8       	st.h	r5++,r8
80003aa8:	00 00       	add	r0,r0
80003aaa:	0a bc       	st.h	r5++,r12
80003aac:	00 00       	add	r0,r0
80003aae:	0a a0       	st.w	r5++,r0
80003ab0:	00 00       	add	r0,r0
80003ab2:	0a 7c       	tst	r12,r5
80003ab4:	00 00       	add	r0,r0
80003ab6:	0a 74       	tst	r4,r5
80003ab8:	00 00       	add	r0,r0
80003aba:	0a b4       	st.h	r5++,r4
80003abc:	80 00       	ld.sh	r0,r0[0x0]
80003abe:	2a 44       	sub	r4,-92
80003ac0:	00 00       	add	r0,r0
80003ac2:	0a 88       	andn	r8,r5
80003ac4:	80 00       	ld.sh	r0,r0[0x0]
80003ac6:	29 74       	sub	r4,-105
80003ac8:	00 00       	add	r0,r0
80003aca:	0a 6c       	and	r12,r5
80003acc:	80 00       	ld.sh	r0,r0[0x0]
80003ace:	29 90       	sub	r0,-103
80003ad0:	00 00       	add	r0,r0
80003ad2:	0a 85       	andn	r5,r5
80003ad4:	00 00       	add	r0,r0
80003ad6:	0a 70       	tst	r0,r5
80003ad8:	00 00       	add	r0,r0
80003ada:	0a 9c       	mov	r12,r5
80003adc:	00 00       	add	r0,r0
80003ade:	0a 94       	mov	r4,r5
80003ae0:	00 00       	add	r0,r0
80003ae2:	0a d0       	st.w	--r5,r0
80003ae4:	00 00       	add	r0,r0
80003ae6:	0a 68       	and	r8,r5
80003ae8:	00 00       	add	r0,r0
80003aea:	0a 78       	tst	r8,r5
80003aec:	00 00       	add	r0,r0
80003aee:	0a 4c       	or	r12,r5
80003af0:	80 00       	ld.sh	r0,r0[0x0]
80003af2:	d0 f4       	*unknown*
80003af4:	80 00       	ld.sh	r0,r0[0x0]
80003af6:	6b 2c       	ld.w	r12,r5[0x48]
80003af8:	00 00       	add	r0,r0
80003afa:	0a 84       	andn	r4,r5
80003afc:	00 00       	add	r0,r0
80003afe:	0a 90       	mov	r0,r5
80003b00:	00 00       	add	r0,r0
80003b02:	0a a4       	st.w	r5++,r4
80003b04:	80 00       	ld.sh	r0,r0[0x0]
80003b06:	73 7c       	ld.w	r12,r9[0x5c]
80003b08:	80 00       	ld.sh	r0,r0[0x0]
80003b0a:	2b c4       	sub	r4,-68
80003b0c:	00 00       	add	r0,r0
80003b0e:	0a 42       	or	r2,r5
80003b10:	00 00       	add	r0,r0
80003b12:	1e a0       	st.w	pc++,r0
80003b14:	80 00       	ld.sh	r0,r0[0x0]
80003b16:	28 d4       	sub	r4,-115
80003b18:	00 00       	add	r0,r0
80003b1a:	0a c0       	st.b	r5++,r0
80003b1c:	00 00       	add	r0,r0
80003b1e:	1d a4       	ld.ub	r4,lr[0x2]
80003b20:	00 00       	add	r0,r0
80003b22:	0a d4       	st.w	--r5,r4
80003b24:	00 00       	add	r0,r0
80003b26:	0a 43       	or	r3,r5
80003b28:	00 00       	add	r0,r0
80003b2a:	0a 41       	or	r1,r5
80003b2c:	00 00       	add	r0,r0
80003b2e:	0a b0       	st.h	r5++,r0
80003b30:	00 00       	add	r0,r0
80003b32:	0a 98       	mov	r8,r5
80003b34:	00 00       	add	r0,r0
80003b36:	0a 57       	eor	r7,r5
80003b38:	00 00       	add	r0,r0
80003b3a:	1d 9c       	ld.ub	r12,lr[0x1]
80003b3c:	00 00       	add	r0,r0
80003b3e:	0a c8       	st.b	r5++,r8
80003b40:	00 00       	add	r0,r0
80003b42:	1e a4       	st.w	pc++,r4
80003b44:	80 00       	ld.sh	r0,r0[0x0]
80003b46:	d1 0c       	*unknown*

80003b48 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003b48:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003b4a:	49 88       	lddpc	r8,80003ba8 <pdca_int_handler+0x60>
80003b4c:	11 89       	ld.ub	r9,r8[0x0]
80003b4e:	ec 19 00 01 	eorl	r9,0x1
80003b52:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003b54:	11 89       	ld.ub	r9,r8[0x0]
80003b56:	a5 69       	lsl	r9,0x4
80003b58:	2f c9       	sub	r9,-4
80003b5a:	49 5a       	lddpc	r10,80003bac <pdca_int_handler+0x64>
80003b5c:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003b5e:	fe 7a 00 40 	mov	r10,-65472
80003b62:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003b64:	30 39       	mov	r9,3
80003b66:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003b68:	11 8a       	ld.ub	r10,r8[0x0]
80003b6a:	a5 6a       	lsl	r10,0x4
80003b6c:	2f ca       	sub	r10,-4
80003b6e:	49 18       	lddpc	r8,80003bb0 <pdca_int_handler+0x68>
80003b70:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003b72:	fe 78 00 00 	mov	r8,-65536
80003b76:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003b78:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003b7a:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003b7c:	48 e8       	lddpc	r8,80003bb4 <pdca_int_handler+0x6c>
80003b7e:	70 08       	ld.w	r8,r8[0x0]
80003b80:	58 08       	cp.w	r8,0
80003b82:	c0 70       	breq	80003b90 <pdca_int_handler+0x48>
80003b84:	48 99       	lddpc	r9,80003ba8 <pdca_int_handler+0x60>
80003b86:	13 89       	ld.ub	r9,r9[0x0]
80003b88:	a5 69       	lsl	r9,0x4
80003b8a:	48 ac       	lddpc	r12,80003bb0 <pdca_int_handler+0x68>
80003b8c:	12 0c       	add	r12,r9
80003b8e:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003b90:	48 a8       	lddpc	r8,80003bb8 <pdca_int_handler+0x70>
80003b92:	70 08       	ld.w	r8,r8[0x0]
80003b94:	58 08       	cp.w	r8,0
80003b96:	c0 70       	breq	80003ba4 <pdca_int_handler+0x5c>
80003b98:	48 49       	lddpc	r9,80003ba8 <pdca_int_handler+0x60>
80003b9a:	13 89       	ld.ub	r9,r9[0x0]
80003b9c:	a5 69       	lsl	r9,0x4
80003b9e:	48 4c       	lddpc	r12,80003bac <pdca_int_handler+0x64>
80003ba0:	12 0c       	add	r12,r9
80003ba2:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003ba4:	d4 02       	popm	lr
80003ba6:	d6 03       	rete
80003ba8:	00 00       	add	r0,r0
80003baa:	50 c4       	stdsp	sp[0x30],r4
80003bac:	00 00       	add	r0,r0
80003bae:	50 ec       	stdsp	sp[0x38],r12
80003bb0:	00 00       	add	r0,r0
80003bb2:	50 cc       	stdsp	sp[0x30],r12
80003bb4:	00 00       	add	r0,r0
80003bb6:	0a dc       	st.w	--r5,r12
80003bb8:	00 00       	add	r0,r0
80003bba:	0a e0       	st.h	--r5,r0

80003bbc <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003bbc:	fe 78 10 00 	mov	r8,-61440
80003bc0:	e0 69 0d c0 	mov	r9,3520
80003bc4:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003bc8:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003bcc:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003bd0:	fe 78 34 00 	mov	r8,-52224
80003bd4:	e0 69 80 00 	mov	r9,32768
80003bd8:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003bda:	30 09       	mov	r9,0
80003bdc:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003bde:	e0 69 04 21 	mov	r9,1057
80003be2:	ea 19 3f 20 	orh	r9,0x3f20
80003be6:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80003be8:	e0 69 02 9f 	mov	r9,671
80003bec:	ea 19 01 00 	orh	r9,0x100
80003bf0:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80003bf2:	e0 6a 04 02 	mov	r10,1026
80003bf6:	ea 1a 3f 20 	orh	r10,0x3f20
80003bfa:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80003bfc:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003bfe:	5e fc       	retal	r12

80003c00 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003c00:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003c02:	30 19       	mov	r9,1
80003c04:	49 78       	lddpc	r8,80003c60 <local_start_PDC+0x60>
80003c06:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003c08:	fe 78 00 00 	mov	r8,-65536
80003c0c:	30 7b       	mov	r11,7
80003c0e:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003c10:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003c12:	49 59       	lddpc	r9,80003c64 <local_start_PDC+0x64>
80003c14:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003c18:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003c1a:	30 3a       	mov	r10,3
80003c1c:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003c1e:	30 1c       	mov	r12,1
80003c20:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003c22:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003c24:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003c26:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003c28:	30 2c       	mov	r12,2
80003c2a:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003c2c:	48 f9       	lddpc	r9,80003c68 <local_start_PDC+0x68>
80003c2e:	e0 68 5a 5a 	mov	r8,23130
80003c32:	ea 18 ab cd 	orh	r8,0xabcd
80003c36:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003c38:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003c3a:	30 0e       	mov	lr,0
80003c3c:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003c3e:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003c40:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003c42:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003c44:	fe 78 00 40 	mov	r8,-65472
80003c48:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003c4a:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003c4c:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003c50:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003c52:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003c54:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003c56:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003c58:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003c5a:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003c5c:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003c5e:	d8 02       	popm	pc
80003c60:	00 00       	add	r0,r0
80003c62:	50 c4       	stdsp	sp[0x30],r4
80003c64:	00 00       	add	r0,r0
80003c66:	50 cc       	stdsp	sp[0x30],r12
80003c68:	00 00       	add	r0,r0
80003c6a:	50 ec       	stdsp	sp[0x38],r12

80003c6c <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003c6c:	48 38       	lddpc	r8,80003c78 <register_rx_tx_func+0xc>
80003c6e:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003c70:	48 38       	lddpc	r8,80003c7c <register_rx_tx_func+0x10>
80003c72:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003c74:	5e fc       	retal	r12
80003c76:	00 00       	add	r0,r0
80003c78:	00 00       	add	r0,r0
80003c7a:	0a dc       	st.w	--r5,r12
80003c7c:	00 00       	add	r0,r0
80003c7e:	0a e0       	st.h	--r5,r0

80003c80 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003c80:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003c82:	fe 78 10 00 	mov	r8,-61440
80003c86:	30 29       	mov	r9,2
80003c88:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003c8c:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003c90:	10 99       	mov	r9,r8
80003c92:	f2 f8 01 60 	ld.w	r8,r9[352]
80003c96:	e2 18 00 02 	andl	r8,0x2,COH
80003c9a:	cf c0       	breq	80003c92 <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003c9c:	fe 79 10 00 	mov	r9,-61440
80003ca0:	f2 f8 01 60 	ld.w	r8,r9[352]
80003ca4:	e2 18 00 02 	andl	r8,0x2,COH
80003ca8:	cf c1       	brne	80003ca0 <ssc_init+0x20>
				
    INTC_register_interrupt (
80003caa:	30 3a       	mov	r10,3
80003cac:	36 0b       	mov	r11,96
80003cae:	48 bc       	lddpc	r12,80003cd8 <ssc_init+0x58>
80003cb0:	f0 1f 00 0b 	mcall	80003cdc <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80003cb4:	f0 1f 00 0b 	mcall	80003ce0 <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80003cb8:	f0 1f 00 0b 	mcall	80003ce4 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003cbc:	fe 79 00 00 	mov	r9,-65536
80003cc0:	30 18       	mov	r8,1
80003cc2:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003cc4:	fe 7a 00 40 	mov	r10,-65472
80003cc8:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003cca:	e0 6b 01 01 	mov	r11,257
80003cce:	fe 7a 34 00 	mov	r10,-52224
80003cd2:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80003cd4:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80003cd6:	d8 02       	popm	pc
80003cd8:	80 00       	ld.sh	r0,r0[0x0]
80003cda:	3b 48       	mov	r8,-76
80003cdc:	80 00       	ld.sh	r0,r0[0x0]
80003cde:	51 68       	stdsp	sp[0x58],r8
80003ce0:	80 00       	ld.sh	r0,r0[0x0]
80003ce2:	3b bc       	mov	r12,-69
80003ce4:	80 00       	ld.sh	r0,r0[0x0]
80003ce6:	3c 00       	mov	r0,-64

80003ce8 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003ce8:	48 28       	lddpc	r8,80003cf0 <xcmp_register_app_list+0x8>
80003cea:	91 0c       	st.w	r8[0x0],r12
}
80003cec:	5e fc       	retal	r12
80003cee:	00 00       	add	r0,r0
80003cf0:	00 00       	add	r0,r0
80003cf2:	51 0c       	stdsp	sp[0x40],r12

80003cf4 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003cf4:	eb cd 40 80 	pushm	r7,lr
80003cf8:	fa cd 01 00 	sub	sp,sp,256
80003cfc:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003cfe:	16 98       	mov	r8,r11
80003d00:	2f 08       	sub	r8,-16
80003d02:	af a8       	sbr	r8,0xe
80003d04:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003d06:	3f f8       	mov	r8,-1
80003d08:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003d0a:	30 b9       	mov	r9,11
80003d0c:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003d0e:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003d10:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003d12:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003d14:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003d16:	f6 ca ff fe 	sub	r10,r11,-2
80003d1a:	18 9b       	mov	r11,r12
80003d1c:	fa cc ff f0 	sub	r12,sp,-16
80003d20:	f0 1f 00 05 	mcall	80003d34 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003d24:	2f e7       	sub	r7,-2
80003d26:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003d28:	1a 9c       	mov	r12,sp
80003d2a:	f0 1f 00 04 	mcall	80003d38 <xcmp_tx+0x44>
}
80003d2e:	2c 0d       	sub	sp,-256
80003d30:	e3 cd 80 80 	ldm	sp++,r7,pc
80003d34:	80 00       	ld.sh	r0,r0[0x0]
80003d36:	72 34       	ld.w	r4,r9[0xc]
80003d38:	80 00       	ld.sh	r0,r0[0x0]
80003d3a:	43 00       	lddsp	r0,sp[0xc0]

80003d3c <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80003d3c:	d4 21       	pushm	r4-r7,lr
80003d3e:	fa cd 00 d0 	sub	sp,sp,208
80003d42:	18 94       	mov	r4,r12
80003d44:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003d46:	e0 68 01 00 	mov	r8,256
80003d4a:	f0 0b 19 00 	cp.h	r11,r8
80003d4e:	e0 8b 00 36 	brhi	80003dba <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003d52:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003d56:	e0 68 04 1d 	mov	r8,1053
80003d5a:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003d5c:	30 18       	mov	r8,1
80003d5e:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80003d60:	32 08       	mov	r8,32
80003d62:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003d64:	30 28       	mov	r8,2
80003d66:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003d68:	30 48       	mov	r8,4
80003d6a:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80003d6c:	ea 1a 0c 00 	orh	r10,0xc00
80003d70:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80003d72:	30 4a       	mov	r10,4
80003d74:	1a 9b       	mov	r11,sp
80003d76:	fa cc ff f4 	sub	r12,sp,-12
80003d7a:	f0 1f 00 12 	mcall	80003dc0 <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80003d7e:	30 f8       	mov	r8,15
80003d80:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80003d84:	3a 78       	mov	r8,-89
80003d86:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80003d8a:	30 08       	mov	r8,0
80003d8c:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80003d90:	0e 9a       	mov	r10,r7
80003d92:	5c 7a       	castu.h	r10
80003d94:	f4 08 16 08 	lsr	r8,r10,0x8
80003d98:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80003d9c:	0e 96       	mov	r6,r7
80003d9e:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80003da2:	08 9b       	mov	r11,r4
80003da4:	fa cc ff eb 	sub	r12,sp,-21
80003da8:	f0 1f 00 06 	mcall	80003dc0 <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80003dac:	ee cb ff f3 	sub	r11,r7,-13
80003db0:	5c 5b       	castu.b	r11
80003db2:	fa cc ff fa 	sub	r12,sp,-6
80003db6:	f0 1f 00 04 	mcall	80003dc4 <xcmp_data_session_req+0x88>
}
80003dba:	2c cd       	sub	sp,-208
80003dbc:	d8 22       	popm	r4-r7,pc
80003dbe:	00 00       	add	r0,r0
80003dc0:	80 00       	ld.sh	r0,r0[0x0]
80003dc2:	72 34       	ld.w	r4,r9[0xc]
80003dc4:	80 00       	ld.sh	r0,r0[0x0]
80003dc6:	3c f4       	mov	r4,-49

80003dc8 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003dc8:	d4 01       	pushm	lr
80003dca:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003dce:	fe 78 b4 00 	mov	r8,-19456
80003dd2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003dd4:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003dd8:	30 89       	mov	r9,8
80003dda:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003ddc:	30 19       	mov	r9,1
80003dde:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003de0:	30 09       	mov	r9,0
80003de2:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003de4:	30 5a       	mov	r10,5
80003de6:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003de8:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003dea:	30 7a       	mov	r10,7
80003dec:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003dee:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003df0:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003df2:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003df6:	30 9b       	mov	r11,9
80003df8:	fa cc ff fe 	sub	r12,sp,-2
80003dfc:	f0 1f 00 02 	mcall	80003e04 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003e00:	2c dd       	sub	sp,-204
80003e02:	d8 02       	popm	pc
80003e04:	80 00       	ld.sh	r0,r0[0x0]
80003e06:	3c f4       	mov	r4,-49

80003e08 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003e08:	d4 01       	pushm	lr
80003e0a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003e0e:	fe 78 80 00 	mov	r8,-32768
80003e12:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003e14:	30 38       	mov	r8,3
80003e16:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80003e18:	30 1b       	mov	r11,1
80003e1a:	fa cc ff fe 	sub	r12,sp,-2
80003e1e:	f0 1f 00 03 	mcall	80003e28 <xcmp_opcode_not_supported+0x20>
}
80003e22:	2c dd       	sub	sp,-204
80003e24:	d8 02       	popm	pc
80003e26:	00 00       	add	r0,r0
80003e28:	80 00       	ld.sh	r0,r0[0x0]
80003e2a:	3c f4       	mov	r4,-49

80003e2c <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80003e2c:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80003e2e:	96 88       	ld.uh	r8,r11[0x0]
80003e30:	e2 18 f0 00 	andl	r8,0xf000,COH
80003e34:	e0 48 80 00 	cp.w	r8,32768
80003e38:	c0 f0       	breq	80003e56 <xcmp_exec_func+0x2a>
80003e3a:	e0 48 b0 00 	cp.w	r8,45056
80003e3e:	c1 20       	breq	80003e62 <xcmp_exec_func+0x36>
80003e40:	58 08       	cp.w	r8,0
80003e42:	c1 51       	brne	80003e6c <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80003e44:	78 08       	ld.w	r8,r12[0x0]
80003e46:	58 08       	cp.w	r8,0
80003e48:	c0 40       	breq	80003e50 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80003e4a:	16 9c       	mov	r12,r11
80003e4c:	5d 18       	icall	r8
80003e4e:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80003e50:	f0 1f 00 08 	mcall	80003e70 <xcmp_exec_func+0x44>
80003e54:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80003e56:	78 18       	ld.w	r8,r12[0x4]
80003e58:	58 08       	cp.w	r8,0
80003e5a:	c0 90       	breq	80003e6c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80003e5c:	16 9c       	mov	r12,r11
80003e5e:	5d 18       	icall	r8
80003e60:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80003e62:	78 28       	ld.w	r8,r12[0x8]
80003e64:	58 08       	cp.w	r8,0
80003e66:	c0 30       	breq	80003e6c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80003e68:	16 9c       	mov	r12,r11
80003e6a:	5d 18       	icall	r8
80003e6c:	d8 02       	popm	pc
80003e6e:	00 00       	add	r0,r0
80003e70:	80 00       	ld.sh	r0,r0[0x0]
80003e72:	3e 08       	mov	r8,-32

80003e74 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U16 type)
{
80003e74:	d4 01       	pushm	lr
80003e76:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80003e7a:	e0 68 04 09 	mov	r8,1033
80003e7e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80003e80:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
80003e84:	30 19       	mov	r9,1
80003e86:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (type >> 8) & 0xFF;
80003e88:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
80003e8c:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = type & 0xFF;	
80003e8e:	b0 ac       	st.b	r8[0x2],r12
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80003e90:	30 09       	mov	r9,0
80003e92:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80003e94:	fb 69 00 08 	st.b	sp[8],r9
80003e98:	fa c8 ff f7 	sub	r8,sp,-9
80003e9c:	b0 89       	st.b	r8[0x0],r9
80003e9e:	fa c8 ff f6 	sub	r8,sp,-10
80003ea2:	b0 89       	st.b	r8[0x0],r9
80003ea4:	fa c8 ff f5 	sub	r8,sp,-11
80003ea8:	b0 89       	st.b	r8[0x0],r9
80003eaa:	fa c8 ff f4 	sub	r8,sp,-12
80003eae:	b0 89       	st.b	r8[0x0],r9
80003eb0:	fa c8 ff f3 	sub	r8,sp,-13
80003eb4:	b0 89       	st.b	r8[0x0],r9
80003eb6:	fa c8 ff f2 	sub	r8,sp,-14
80003eba:	b0 89       	st.b	r8[0x0],r9
80003ebc:	fa c8 ff f1 	sub	r8,sp,-15
80003ec0:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80003ec2:	30 cb       	mov	r11,12
80003ec4:	fa cc ff fe 	sub	r12,sp,-2
80003ec8:	f0 1f 00 02 	mcall	80003ed0 <xcmp_IdleTestTone+0x5c>
}
80003ecc:	2c dd       	sub	sp,-204
80003ece:	d8 02       	popm	pc
80003ed0:	80 00       	ld.sh	r0,r0[0x0]
80003ed2:	3c f4       	mov	r4,-49

80003ed4 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80003ed4:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80003ed6:	48 dc       	lddpc	r12,80003f08 <xcmp_init+0x34>
80003ed8:	f0 1f 00 0d 	mcall	80003f0c <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80003edc:	30 4b       	mov	r11,4
80003ede:	31 4c       	mov	r12,20
80003ee0:	f0 1f 00 0c 	mcall	80003f10 <xcmp_init+0x3c>
80003ee4:	48 c8       	lddpc	r8,80003f14 <xcmp_init+0x40>
80003ee6:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80003ee8:	30 09       	mov	r9,0
80003eea:	1a d9       	st.w	--sp,r9
80003eec:	1a d9       	st.w	--sp,r9
80003eee:	1a d9       	st.w	--sp,r9
80003ef0:	30 38       	mov	r8,3
80003ef2:	e0 6a 01 80 	mov	r10,384
80003ef6:	48 9b       	lddpc	r11,80003f18 <xcmp_init+0x44>
80003ef8:	48 9c       	lddpc	r12,80003f1c <xcmp_init+0x48>
80003efa:	f0 1f 00 0a 	mcall	80003f20 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80003efe:	f0 1f 00 0a 	mcall	80003f24 <xcmp_init+0x50>
80003f02:	2f dd       	sub	sp,-12
	
}
80003f04:	d8 02       	popm	pc
80003f06:	00 00       	add	r0,r0
80003f08:	80 00       	ld.sh	r0,r0[0x0]
80003f0a:	40 24       	lddsp	r4,sp[0x8]
80003f0c:	80 00       	ld.sh	r0,r0[0x0]
80003f0e:	40 70       	lddsp	r0,sp[0x1c]
80003f10:	80 00       	ld.sh	r0,r0[0x0]
80003f12:	5f 08       	sreq	r8
80003f14:	00 00       	add	r0,r0
80003f16:	0a fc       	st.b	--r5,r12
80003f18:	80 00       	ld.sh	r0,r0[0x0]
80003f1a:	d1 38       	*unknown*
80003f1c:	80 00       	ld.sh	r0,r0[0x0]
80003f1e:	3f 28       	mov	r8,-14
80003f20:	80 00       	ld.sh	r0,r0[0x0]
80003f22:	65 dc       	ld.w	r12,r2[0x74]
80003f24:	80 00       	ld.sh	r0,r0[0x0]
80003f26:	40 a8       	lddsp	r8,sp[0x28]

80003f28 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80003f28:	d4 31       	pushm	r0-r7,lr
80003f2a:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80003f2c:	4b 16       	lddpc	r6,80003ff0 <xcmp_rx_process+0xc8>
80003f2e:	30 05       	mov	r5,0
80003f30:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80003f32:	4b 13       	lddpc	r3,80003ff4 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80003f34:	4b 12       	lddpc	r2,80003ff8 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80003f36:	4b 21       	lddpc	r1,80003ffc <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80003f38:	4b 20       	lddpc	r0,80004000 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80003f3a:	6c 0c       	ld.w	r12,r6[0x0]
80003f3c:	0a 99       	mov	r9,r5
80003f3e:	08 9a       	mov	r10,r4
80003f40:	1a 9b       	mov	r11,sp
80003f42:	f0 1f 00 31 	mcall	80004004 <xcmp_rx_process+0xdc>
80003f46:	58 1c       	cp.w	r12,1
80003f48:	cf 91       	brne	80003f3a <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80003f4a:	40 0b       	lddsp	r11,sp[0x0]
80003f4c:	58 0b       	cp.w	r11,0
80003f4e:	cf 60       	breq	80003f3a <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80003f50:	96 0a       	ld.sh	r10,r11[0x0]
80003f52:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80003f56:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80003f5a:	59 c8       	cp.w	r8,28
80003f5c:	c1 e0       	breq	80003f98 <xcmp_rx_process+0x70>
80003f5e:	e0 89 00 07 	brgt	80003f6c <xcmp_rx_process+0x44>
80003f62:	58 e8       	cp.w	r8,14
80003f64:	c0 e0       	breq	80003f80 <xcmp_rx_process+0x58>
80003f66:	58 f8       	cp.w	r8,15
80003f68:	c2 41       	brne	80003fb0 <xcmp_rx_process+0x88>
80003f6a:	c0 f8       	rjmp	80003f88 <xcmp_rx_process+0x60>
80003f6c:	e0 48 01 09 	cp.w	r8,265
80003f70:	c1 80       	breq	80003fa0 <xcmp_rx_process+0x78>
80003f72:	e0 48 01 0a 	cp.w	r8,266
80003f76:	c1 90       	breq	80003fa8 <xcmp_rx_process+0x80>
80003f78:	e0 48 00 2c 	cp.w	r8,44
80003f7c:	c1 a1       	brne	80003fb0 <xcmp_rx_process+0x88>
80003f7e:	c0 98       	rjmp	80003f90 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80003f80:	4a 2c       	lddpc	r12,80004008 <xcmp_rx_process+0xe0>
80003f82:	f0 1f 00 23 	mcall	8000400c <xcmp_rx_process+0xe4>
					break;
80003f86:	c2 f8       	rjmp	80003fe4 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80003f88:	4a 2c       	lddpc	r12,80004010 <xcmp_rx_process+0xe8>
80003f8a:	f0 1f 00 21 	mcall	8000400c <xcmp_rx_process+0xe4>
					break;
80003f8e:	c2 b8       	rjmp	80003fe4 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80003f90:	4a 1c       	lddpc	r12,80004014 <xcmp_rx_process+0xec>
80003f92:	f0 1f 00 1f 	mcall	8000400c <xcmp_rx_process+0xe4>
					break;
80003f96:	c2 78       	rjmp	80003fe4 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80003f98:	04 9c       	mov	r12,r2
80003f9a:	f0 1f 00 1d 	mcall	8000400c <xcmp_rx_process+0xe4>
						, ptr);
					break;
80003f9e:	c2 38       	rjmp	80003fe4 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80003fa0:	02 9c       	mov	r12,r1
80003fa2:	f0 1f 00 1b 	mcall	8000400c <xcmp_rx_process+0xe4>
					break;
80003fa6:	c1 f8       	rjmp	80003fe4 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80003fa8:	00 9c       	mov	r12,r0
80003faa:	f0 1f 00 19 	mcall	8000400c <xcmp_rx_process+0xe4>
					break;
80003fae:	c1 b8       	rjmp	80003fe4 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80003fb0:	12 98       	mov	r8,r9
80003fb2:	e2 18 04 00 	andl	r8,0x400,COH
80003fb6:	c0 70       	breq	80003fc4 <xcmp_rx_process+0x9c>
80003fb8:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80003fbc:	e0 48 00 68 	cp.w	r8,104
80003fc0:	e0 8a 00 08 	brle	80003fd0 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80003fc4:	e2 19 f0 00 	andl	r9,0xf000,COH
80003fc8:	c0 e1       	brne	80003fe4 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80003fca:	f0 1f 00 14 	mcall	80004018 <xcmp_rx_process+0xf0>
80003fce:	c0 b8       	rjmp	80003fe4 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80003fd0:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80003fd4:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80003fd8:	49 19       	lddpc	r9,8000401c <xcmp_rx_process+0xf4>
80003fda:	72 08       	ld.w	r8,r9[0x0]
80003fdc:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80003fe0:	f0 1f 00 0b 	mcall	8000400c <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80003fe4:	66 0c       	ld.w	r12,r3[0x0]
80003fe6:	40 0b       	lddsp	r11,sp[0x0]
80003fe8:	f0 1f 00 0e 	mcall	80004020 <xcmp_rx_process+0xf8>
80003fec:	ca 7b       	rjmp	80003f3a <xcmp_rx_process+0x12>
80003fee:	00 00       	add	r0,r0
80003ff0:	00 00       	add	r0,r0
80003ff2:	0a fc       	st.b	--r5,r12
80003ff4:	00 00       	add	r0,r0
80003ff6:	0a b4       	st.h	r5++,r4
80003ff8:	00 00       	add	r0,r0
80003ffa:	0b 0c       	ld.w	r12,r5++
80003ffc:	00 00       	add	r0,r0
80003ffe:	0b 00       	ld.w	r0,r5++
80004000:	00 00       	add	r0,r0
80004002:	0a f0       	st.b	--r5,r0
80004004:	80 00       	ld.sh	r0,r0[0x0]
80004006:	5b fc       	cp.w	r12,-1
80004008:	00 00       	add	r0,r0
8000400a:	0b 24       	ld.uh	r4,r5++
8000400c:	80 00       	ld.sh	r0,r0[0x0]
8000400e:	3e 2c       	mov	r12,-30
80004010:	00 00       	add	r0,r0
80004012:	0a e4       	st.h	--r5,r4
80004014:	00 00       	add	r0,r0
80004016:	0b 18       	ld.sh	r8,r5++
80004018:	80 00       	ld.sh	r0,r0[0x0]
8000401a:	3e 08       	mov	r8,-32
8000401c:	00 00       	add	r0,r0
8000401e:	51 0c       	stdsp	sp[0x40],r12
80004020:	80 00       	ld.sh	r0,r0[0x0]
80004022:	29 c8       	sub	r8,-100

80004024 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004024:	eb cd 40 90 	pushm	r4,r7,lr
80004028:	20 1d       	sub	sp,4
8000402a:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000402e:	48 c8       	lddpc	r8,8000405c <xcmp_rx+0x38>
80004030:	70 0c       	ld.w	r12,r8[0x0]
80004032:	f0 1f 00 0c 	mcall	80004060 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80004036:	c1 00       	breq	80004056 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004038:	fa c7 ff fc 	sub	r7,sp,-4
8000403c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
8000403e:	e0 6a 00 ca 	mov	r10,202
80004042:	08 9b       	mov	r11,r4
80004044:	f0 1f 00 08 	mcall	80004064 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004048:	48 88       	lddpc	r8,80004068 <xcmp_rx+0x44>
8000404a:	70 0c       	ld.w	r12,r8[0x0]
8000404c:	30 09       	mov	r9,0
8000404e:	12 9a       	mov	r10,r9
80004050:	1a 9b       	mov	r11,sp
80004052:	f0 1f 00 07 	mcall	8000406c <xcmp_rx+0x48>
	}	
}
80004056:	2f fd       	sub	sp,-4
80004058:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
8000405c:	00 00       	add	r0,r0
8000405e:	0a b4       	st.h	r5++,r4
80004060:	80 00       	ld.sh	r0,r0[0x0]
80004062:	2b 74       	sub	r4,-73
80004064:	80 00       	ld.sh	r0,r0[0x0]
80004066:	72 34       	ld.w	r4,r9[0xc]
80004068:	00 00       	add	r0,r0
8000406a:	0a fc       	st.b	--r5,r12
8000406c:	80 00       	ld.sh	r0,r0[0x0]
8000406e:	5e 08       	reteq	r8

80004070 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004070:	48 28       	lddpc	r8,80004078 <xnl_register_xcmp_func+0x8>
80004072:	91 0c       	st.w	r8[0x0],r12
}
80004074:	5e fc       	retal	r12
80004076:	00 00       	add	r0,r0
80004078:	00 00       	add	r0,r0
8000407a:	0b 54       	ld.sh	r4,--r5

8000407c <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
8000407c:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
8000407e:	48 88       	lddpc	r8,8000409c <xnl_get_msg_ack_func+0x20>
80004080:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004082:	98 49       	ld.sh	r9,r12[0x8]
80004084:	f0 09 19 00 	cp.h	r9,r8
80004088:	c0 81       	brne	80004098 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
8000408a:	48 68       	lddpc	r8,800040a0 <xnl_get_msg_ack_func+0x24>
8000408c:	70 0c       	ld.w	r12,r8[0x0]
8000408e:	30 09       	mov	r9,0
80004090:	12 9a       	mov	r10,r9
80004092:	12 9b       	mov	r11,r9
80004094:	f0 1f 00 04 	mcall	800040a4 <xnl_get_msg_ack_func+0x28>
80004098:	d8 02       	popm	pc
8000409a:	00 00       	add	r0,r0
8000409c:	00 00       	add	r0,r0
8000409e:	0b 34       	ld.ub	r4,r5++
800040a0:	00 00       	add	r0,r0
800040a2:	0b 30       	ld.ub	r0,r5++
800040a4:	80 00       	ld.sh	r0,r0[0x0]
800040a6:	5e 08       	reteq	r8

800040a8 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800040a8:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
800040ac:	30 09       	mov	r9,0
800040ae:	4b 78       	lddpc	r8,80004188 <xnl_init+0xe0>
800040b0:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800040b2:	30 0b       	mov	r11,0
800040b4:	30 1c       	mov	r12,1
800040b6:	f0 1f 00 36 	mcall	8000418c <xnl_init+0xe4>
800040ba:	4b 68       	lddpc	r8,80004190 <xnl_init+0xe8>
800040bc:	91 0c       	st.w	r8[0x0],r12
800040be:	70 08       	ld.w	r8,r8[0x0]
800040c0:	58 08       	cp.w	r8,0
800040c2:	c0 80       	breq	800040d2 <xnl_init+0x2a>
800040c4:	4b 38       	lddpc	r8,80004190 <xnl_init+0xe8>
800040c6:	70 0c       	ld.w	r12,r8[0x0]
800040c8:	30 09       	mov	r9,0
800040ca:	12 9a       	mov	r10,r9
800040cc:	12 9b       	mov	r11,r9
800040ce:	f0 1f 00 32 	mcall	80004194 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
800040d2:	30 4b       	mov	r11,4
800040d4:	31 4c       	mov	r12,20
800040d6:	f0 1f 00 2e 	mcall	8000418c <xnl_init+0xe4>
800040da:	4b 08       	lddpc	r8,80004198 <xnl_init+0xf0>
800040dc:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800040de:	30 4b       	mov	r11,4
800040e0:	31 ec       	mov	r12,30
800040e2:	f0 1f 00 2b 	mcall	8000418c <xnl_init+0xe4>
800040e6:	4a e8       	lddpc	r8,8000419c <xnl_init+0xf4>
800040e8:	91 0c       	st.w	r8[0x0],r12
800040ea:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800040ec:	10 96       	mov	r6,r8
800040ee:	4a d5       	lddpc	r5,800041a0 <xnl_init+0xf8>
800040f0:	6c 0c       	ld.w	r12,r6[0x0]
800040f2:	ea 07 00 0b 	add	r11,r5,r7
800040f6:	f0 1f 00 2c 	mcall	800041a4 <xnl_init+0xfc>
800040fa:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
800040fe:	e0 47 1e 00 	cp.w	r7,7680
80004102:	cf 71       	brne	800040f0 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004104:	30 4b       	mov	r11,4
80004106:	31 4c       	mov	r12,20
80004108:	f0 1f 00 21 	mcall	8000418c <xnl_init+0xe4>
8000410c:	4a 78       	lddpc	r8,800041a8 <xnl_init+0x100>
8000410e:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004110:	30 4b       	mov	r11,4
80004112:	30 ac       	mov	r12,10
80004114:	f0 1f 00 1e 	mcall	8000418c <xnl_init+0xe4>
80004118:	4a 58       	lddpc	r8,800041ac <xnl_init+0x104>
8000411a:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
8000411c:	30 4b       	mov	r11,4
8000411e:	30 ac       	mov	r12,10
80004120:	f0 1f 00 1b 	mcall	8000418c <xnl_init+0xe4>
80004124:	4a 38       	lddpc	r8,800041b0 <xnl_init+0x108>
80004126:	91 0c       	st.w	r8[0x0],r12
80004128:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
8000412a:	10 96       	mov	r6,r8
8000412c:	4a 25       	lddpc	r5,800041b4 <xnl_init+0x10c>
8000412e:	6c 0c       	ld.w	r12,r6[0x0]
80004130:	ea 07 00 0b 	add	r11,r5,r7
80004134:	f0 1f 00 1c 	mcall	800041a4 <xnl_init+0xfc>
80004138:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
8000413c:	e0 47 14 00 	cp.w	r7,5120
80004140:	cf 71       	brne	8000412e <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004142:	30 4b       	mov	r11,4
80004144:	30 5c       	mov	r12,5
80004146:	f0 1f 00 12 	mcall	8000418c <xnl_init+0xe4>
8000414a:	49 c8       	lddpc	r8,800041b8 <xnl_init+0x110>
8000414c:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
8000414e:	30 07       	mov	r7,0
80004150:	1a d7       	st.w	--sp,r7
80004152:	1a d7       	st.w	--sp,r7
80004154:	1a d7       	st.w	--sp,r7
80004156:	30 38       	mov	r8,3
80004158:	0e 99       	mov	r9,r7
8000415a:	e0 6a 02 00 	mov	r10,512
8000415e:	49 8b       	lddpc	r11,800041bc <xnl_init+0x114>
80004160:	49 8c       	lddpc	r12,800041c0 <xnl_init+0x118>
80004162:	f0 1f 00 19 	mcall	800041c4 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004166:	1a d7       	st.w	--sp,r7
80004168:	1a d7       	st.w	--sp,r7
8000416a:	1a d7       	st.w	--sp,r7
8000416c:	30 38       	mov	r8,3
8000416e:	0e 99       	mov	r9,r7
80004170:	e0 6a 03 20 	mov	r10,800
80004174:	49 5b       	lddpc	r11,800041c8 <xnl_init+0x120>
80004176:	49 6c       	lddpc	r12,800041cc <xnl_init+0x124>
80004178:	f0 1f 00 13 	mcall	800041c4 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
8000417c:	f0 1f 00 15 	mcall	800041d0 <xnl_init+0x128>
80004180:	2f ad       	sub	sp,-24
}
80004182:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004186:	00 00       	add	r0,r0
80004188:	00 00       	add	r0,r0
8000418a:	0b 34       	ld.ub	r4,r5++
8000418c:	80 00       	ld.sh	r0,r0[0x0]
8000418e:	5f 08       	sreq	r8
80004190:	00 00       	add	r0,r0
80004192:	0b 30       	ld.ub	r0,r5++
80004194:	80 00       	ld.sh	r0,r0[0x0]
80004196:	5e 08       	reteq	r8
80004198:	00 00       	add	r0,r0
8000419a:	0b 40       	ld.w	r0,--r5
8000419c:	00 00       	add	r0,r0
8000419e:	0a b4       	st.h	r5++,r4
800041a0:	00 00       	add	r0,r0
800041a2:	32 be       	mov	lr,43
800041a4:	80 00       	ld.sh	r0,r0[0x0]
800041a6:	29 c8       	sub	r8,-100
800041a8:	00 00       	add	r0,r0
800041aa:	0a c4       	st.b	r5++,r4
800041ac:	00 00       	add	r0,r0
800041ae:	0a b8       	st.h	r5++,r8
800041b0:	00 00       	add	r0,r0
800041b2:	0a 70       	tst	r0,r5
800041b4:	00 00       	add	r0,r0
800041b6:	1e be       	st.h	pc++,lr
800041b8:	00 00       	add	r0,r0
800041ba:	0a 8c       	andn	r12,r5
800041bc:	80 00       	ld.sh	r0,r0[0x0]
800041be:	d1 40       	acall	0x14
800041c0:	80 00       	ld.sh	r0,r0[0x0]
800041c2:	41 d4       	lddsp	r4,sp[0x74]
800041c4:	80 00       	ld.sh	r0,r0[0x0]
800041c6:	65 dc       	ld.w	r12,r2[0x74]
800041c8:	80 00       	ld.sh	r0,r0[0x0]
800041ca:	ca 00       	breq	8000410a <xnl_init+0x62>
800041cc:	80 00       	ld.sh	r0,r0[0x0]
800041ce:	42 34       	lddsp	r4,sp[0x8c]
800041d0:	80 00       	ld.sh	r0,r0[0x0]
800041d2:	2b 9c       	sub	r12,-71

800041d4 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
800041d4:	eb cd 40 fe 	pushm	r1-r7,lr
800041d8:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800041da:	49 26       	lddpc	r6,80004220 <xnl_rx_process+0x4c>
800041dc:	30 05       	mov	r5,0
800041de:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800041e0:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800041e2:	49 11       	lddpc	r1,80004224 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800041e4:	49 12       	lddpc	r2,80004228 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800041e6:	6c 0c       	ld.w	r12,r6[0x0]
800041e8:	0a 99       	mov	r9,r5
800041ea:	08 9a       	mov	r10,r4
800041ec:	1a 9b       	mov	r11,sp
800041ee:	f0 1f 00 10 	mcall	8000422c <xnl_rx_process+0x58>
800041f2:	58 1c       	cp.w	r12,1
800041f4:	cf 91       	brne	800041e6 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
800041f6:	40 0c       	lddsp	r12,sp[0x0]
800041f8:	58 0c       	cp.w	r12,0
800041fa:	cf 60       	breq	800041e6 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800041fc:	98 28       	ld.sh	r8,r12[0x4]
800041fe:	e6 08 19 00 	cp.h	r8,r3
80004202:	e0 8b 00 0a 	brhi	80004216 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004206:	5c 78       	castu.h	r8
80004208:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
8000420c:	58 09       	cp.w	r9,0
8000420e:	c0 40       	breq	80004216 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004210:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004214:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004216:	62 0c       	ld.w	r12,r1[0x0]
80004218:	40 0b       	lddsp	r11,sp[0x0]
8000421a:	f0 1f 00 06 	mcall	80004230 <xnl_rx_process+0x5c>
8000421e:	ce 4b       	rjmp	800041e6 <xnl_rx_process+0x12>
80004220:	00 00       	add	r0,r0
80004222:	0a b8       	st.h	r5++,r8
80004224:	00 00       	add	r0,r0
80004226:	0a b4       	st.h	r5++,r4
80004228:	00 00       	add	r0,r0
8000422a:	04 f0       	st.b	--r2,r0
8000422c:	80 00       	ld.sh	r0,r0[0x0]
8000422e:	5b fc       	cp.w	r12,-1
80004230:	80 00       	ld.sh	r0,r0[0x0]
80004232:	29 c8       	sub	r8,-100

80004234 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80004234:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80004236:	4a a6       	lddpc	r6,800042dc <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004238:	4a a2       	lddpc	r2,800042e0 <xnl_tx_process+0xac>
8000423a:	4a b4       	lddpc	r4,800042e4 <xnl_tx_process+0xb0>
8000423c:	30 07       	mov	r7,0
8000423e:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004240:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004242:	4a a5       	lddpc	r5,800042e8 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004244:	4a a3       	lddpc	r3,800042ec <xnl_tx_process+0xb8>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80004246:	6c 08       	ld.w	r8,r6[0x0]
80004248:	58 08       	cp.w	r8,0
8000424a:	c0 40       	breq	80004252 <xnl_tx_process+0x1e>
8000424c:	58 18       	cp.w	r8,1
8000424e:	cf d1       	brne	80004248 <xnl_tx_process+0x14>
80004250:	c2 48       	rjmp	80004298 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004252:	64 0c       	ld.w	r12,r2[0x0]
80004254:	0e 99       	mov	r9,r7
80004256:	02 9a       	mov	r10,r1
80004258:	08 9b       	mov	r11,r4
8000425a:	f0 1f 00 26 	mcall	800042f0 <xnl_tx_process+0xbc>
8000425e:	58 1c       	cp.w	r12,1
80004260:	cf 31       	brne	80004246 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004262:	68 0b       	ld.w	r11,r4[0x0]
80004264:	58 0b       	cp.w	r11,0
80004266:	cf 00       	breq	80004246 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004268:	96 28       	ld.sh	r8,r11[0x4]
8000426a:	e0 08 19 00 	cp.h	r8,r0
8000426e:	c0 71       	brne	8000427c <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004270:	4a 18       	lddpc	r8,800042f4 <xnl_tx_process+0xc0>
80004272:	70 08       	ld.w	r8,r8[0x0]
80004274:	10 9c       	mov	r12,r8
80004276:	f0 1f 00 21 	mcall	800042f8 <xnl_tx_process+0xc4>
						break;
8000427a:	ce 6b       	rjmp	80004246 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
8000427c:	16 9c       	mov	r12,r11
8000427e:	f0 1f 00 20 	mcall	800042fc <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004282:	30 18       	mov	r8,1
80004284:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004286:	66 0c       	ld.w	r12,r3[0x0]
80004288:	0e 99       	mov	r9,r7
8000428a:	0e 9a       	mov	r10,r7
8000428c:	0e 9b       	mov	r11,r7
8000428e:	f0 1f 00 19 	mcall	800042f0 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
80004292:	30 18       	mov	r8,1
80004294:	8d 08       	st.w	r6[0x0],r8
80004296:	cd 8b       	rjmp	80004246 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004298:	66 0c       	ld.w	r12,r3[0x0]
8000429a:	0e 99       	mov	r9,r7
8000429c:	36 4a       	mov	r10,100
8000429e:	0e 9b       	mov	r11,r7
800042a0:	f0 1f 00 14 	mcall	800042f0 <xnl_tx_process+0xbc>
800042a4:	58 1c       	cp.w	r12,1
800042a6:	c0 81       	brne	800042b6 <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
800042a8:	49 38       	lddpc	r8,800042f4 <xnl_tx_process+0xc0>
800042aa:	70 0c       	ld.w	r12,r8[0x0]
800042ac:	68 0b       	ld.w	r11,r4[0x0]
800042ae:	f0 1f 00 13 	mcall	800042f8 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800042b2:	8d 07       	st.w	r6[0x0],r7
800042b4:	cc 9b       	rjmp	80004246 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800042b6:	6a 08       	ld.w	r8,r5[0x0]
800042b8:	58 38       	cp.w	r8,3
800042ba:	e0 89 00 09 	brgt	800042cc <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
800042be:	68 0c       	ld.w	r12,r4[0x0]
800042c0:	f0 1f 00 0f 	mcall	800042fc <xnl_tx_process+0xc8>
						xnl_send_times++;
800042c4:	6a 08       	ld.w	r8,r5[0x0]
800042c6:	2f f8       	sub	r8,-1
800042c8:	8b 08       	st.w	r5[0x0],r8
800042ca:	cb eb       	rjmp	80004246 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
800042cc:	48 a8       	lddpc	r8,800042f4 <xnl_tx_process+0xc0>
800042ce:	70 0c       	ld.w	r12,r8[0x0]
800042d0:	68 0b       	ld.w	r11,r4[0x0]
800042d2:	f0 1f 00 0a 	mcall	800042f8 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800042d6:	8d 07       	st.w	r6[0x0],r7
800042d8:	cb 7b       	rjmp	80004246 <xnl_tx_process+0x12>
800042da:	00 00       	add	r0,r0
800042dc:	00 00       	add	r0,r0
800042de:	0b 50       	ld.sh	r0,--r5
800042e0:	00 00       	add	r0,r0
800042e2:	0b 40       	ld.w	r0,--r5
800042e4:	00 00       	add	r0,r0
800042e6:	0b 48       	ld.w	r8,--r5
800042e8:	00 00       	add	r0,r0
800042ea:	0b 44       	ld.w	r4,--r5
800042ec:	00 00       	add	r0,r0
800042ee:	0b 30       	ld.ub	r0,r5++
800042f0:	80 00       	ld.sh	r0,r0[0x0]
800042f2:	5b fc       	cp.w	r12,-1
800042f4:	00 00       	add	r0,r0
800042f6:	0a b4       	st.h	r5++,r4
800042f8:	80 00       	ld.sh	r0,r0[0x0]
800042fa:	29 c8       	sub	r8,-100
800042fc:	80 00       	ld.sh	r0,r0[0x0]
800042fe:	29 e8       	sub	r8,-98

80004300 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004300:	eb cd 40 c0 	pushm	r6-r7,lr
80004304:	20 1d       	sub	sp,4
80004306:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004308:	98 39       	ld.sh	r9,r12[0x6]
8000430a:	3f f8       	mov	r8,-1
8000430c:	f0 09 19 00 	cp.h	r9,r8
80004310:	c0 a1       	brne	80004324 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004312:	4a e9       	lddpc	r9,800043c8 <xnl_tx+0xc8>
80004314:	13 88       	ld.ub	r8,r9[0x0]
80004316:	2f f8       	sub	r8,-1
80004318:	5c 58       	castu.b	r8
8000431a:	b2 88       	st.b	r9[0x0],r8
8000431c:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004320:	a9 a8       	sbr	r8,0x8
80004322:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004324:	8c 49       	ld.sh	r9,r6[0x8]
80004326:	3f f8       	mov	r8,-1
80004328:	f0 09 19 00 	cp.h	r9,r8
8000432c:	c0 41       	brne	80004334 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
8000432e:	4a 88       	lddpc	r8,800043cc <xnl_tx+0xcc>
80004330:	90 18       	ld.sh	r8,r8[0x2]
80004332:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004334:	8c 59       	ld.sh	r9,r6[0xa]
80004336:	3f f8       	mov	r8,-1
80004338:	f0 09 19 00 	cp.h	r9,r8
8000433c:	c0 41       	brne	80004344 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
8000433e:	4a 48       	lddpc	r8,800043cc <xnl_tx+0xcc>
80004340:	90 28       	ld.sh	r8,r8[0x4]
80004342:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004344:	8c 69       	ld.sh	r9,r6[0xc]
80004346:	3f f8       	mov	r8,-1
80004348:	f0 09 19 00 	cp.h	r9,r8
8000434c:	c0 e1       	brne	80004368 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
8000434e:	4a 08       	lddpc	r8,800043cc <xnl_tx+0xcc>
80004350:	90 49       	ld.sh	r9,r8[0x8]
80004352:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004354:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004356:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004358:	90 49       	ld.sh	r9,r8[0x8]
8000435a:	e0 19 ff 00 	andl	r9,0xff00
8000435e:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004362:	f3 e8 10 08 	or	r8,r9,r8
80004366:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004368:	0d 98       	ld.ub	r8,r6[0x1]
8000436a:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
8000436c:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004370:	10 0c       	add	r12,r8
80004372:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004374:	58 0c       	cp.w	r12,0
80004376:	e0 89 00 04 	brgt	8000437e <xnl_tx+0x7e>
8000437a:	30 09       	mov	r9,0
8000437c:	c0 d8       	rjmp	80004396 <xnl_tx+0x96>
8000437e:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004382:	2f ec       	sub	r12,-2
80004384:	30 09       	mov	r9,0
80004386:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004388:	15 1b       	ld.sh	r11,r10++
8000438a:	f6 09 00 09 	add	r9,r11,r9
8000438e:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004390:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004392:	18 38       	cp.w	r8,r12
80004394:	cf a1       	brne	80004388 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004396:	5c 39       	neg	r9
80004398:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000439a:	48 e8       	lddpc	r8,800043d0 <xnl_tx+0xd0>
8000439c:	70 0c       	ld.w	r12,r8[0x0]
8000439e:	f0 1f 00 0e 	mcall	800043d4 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800043a2:	c1 00       	breq	800043c2 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800043a4:	fa c7 ff fc 	sub	r7,sp,-4
800043a8:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
800043aa:	e0 6a 01 00 	mov	r10,256
800043ae:	0c 9b       	mov	r11,r6
800043b0:	f0 1f 00 0a 	mcall	800043d8 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
800043b4:	48 a8       	lddpc	r8,800043dc <xnl_tx+0xdc>
800043b6:	70 0c       	ld.w	r12,r8[0x0]
800043b8:	30 09       	mov	r9,0
800043ba:	12 9a       	mov	r10,r9
800043bc:	1a 9b       	mov	r11,sp
800043be:	f0 1f 00 09 	mcall	800043e0 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
800043c2:	2f fd       	sub	sp,-4
800043c4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800043c8:	00 00       	add	r0,r0
800043ca:	0b 4c       	ld.w	r12,--r5
800043cc:	00 00       	add	r0,r0
800043ce:	0b 34       	ld.ub	r4,r5++
800043d0:	00 00       	add	r0,r0
800043d2:	0a b4       	st.h	r5++,r4
800043d4:	80 00       	ld.sh	r0,r0[0x0]
800043d6:	2b 74       	sub	r4,-73
800043d8:	80 00       	ld.sh	r0,r0[0x0]
800043da:	72 34       	ld.w	r4,r9[0xc]
800043dc:	00 00       	add	r0,r0
800043de:	0b 40       	ld.w	r0,--r5
800043e0:	80 00       	ld.sh	r0,r0[0x0]
800043e2:	5e 08       	reteq	r8

800043e4 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800043e4:	eb cd 40 80 	pushm	r7,lr
800043e8:	fa cd 01 00 	sub	sp,sp,256
800043ec:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800043ee:	e0 68 40 0e 	mov	r8,16398
800043f2:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800043f4:	3f f8       	mov	r8,-1
800043f6:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
800043f8:	30 c8       	mov	r8,12
800043fa:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
800043fc:	98 38       	ld.sh	r8,r12[0x6]
800043fe:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004400:	98 58       	ld.sh	r8,r12[0xa]
80004402:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004404:	98 48       	ld.sh	r8,r12[0x8]
80004406:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004408:	98 68       	ld.sh	r8,r12[0xc]
8000440a:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
8000440c:	30 08       	mov	r8,0
8000440e:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004410:	1a 9c       	mov	r12,sp
80004412:	f0 1f 00 0a 	mcall	80004438 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80004416:	fa cd 00 cc 	sub	sp,sp,204
8000441a:	e0 6a 00 ca 	mov	r10,202
8000441e:	ee cb ff f0 	sub	r11,r7,-16
80004422:	1a 9c       	mov	r12,sp
80004424:	f0 1f 00 06 	mcall	8000443c <xnl_data_msg_func+0x58>
80004428:	48 68       	lddpc	r8,80004440 <xnl_data_msg_func+0x5c>
8000442a:	70 08       	ld.w	r8,r8[0x0]
8000442c:	5d 18       	icall	r8
8000442e:	fa cd ff 34 	sub	sp,sp,-204
}
80004432:	2c 0d       	sub	sp,-256
80004434:	e3 cd 80 80 	ldm	sp++,r7,pc
80004438:	80 00       	ld.sh	r0,r0[0x0]
8000443a:	43 00       	lddsp	r0,sp[0xc0]
8000443c:	80 00       	ld.sh	r0,r0[0x0]
8000443e:	72 34       	ld.w	r4,r9[0xc]
80004440:	00 00       	add	r0,r0
80004442:	0b 54       	ld.sh	r4,--r5

80004444 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004444:	d4 21       	pushm	r4-r7,lr
80004446:	fa cd 01 00 	sub	sp,sp,256
8000444a:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
8000444c:	4c 28       	lddpc	r8,80004554 <xnl_device_auth_reply_func+0x110>
8000444e:	11 88       	ld.ub	r8,r8[0x0]
80004450:	58 08       	cp.w	r8,0
80004452:	c7 e1       	brne	8000454e <xnl_device_auth_reply_func+0x10a>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004454:	4c 18       	lddpc	r8,80004558 <xnl_device_auth_reply_func+0x114>
80004456:	70 0c       	ld.w	r12,r8[0x0]
80004458:	30 09       	mov	r9,0
8000445a:	12 9a       	mov	r10,r9
8000445c:	12 9b       	mov	r11,r9
8000445e:	f0 1f 00 40 	mcall	8000455c <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004462:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004466:	4b c8       	lddpc	r8,80004554 <xnl_device_auth_reply_func+0x110>
80004468:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
8000446a:	ef 39 00 12 	ld.ub	r9,r7[18]
8000446e:	ef 38 00 13 	ld.ub	r8,r7[19]
80004472:	b1 68       	lsl	r8,0x10
80004474:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004478:	ef 38 00 15 	ld.ub	r8,r7[21]
8000447c:	f3 e8 10 08 	or	r8,r9,r8
80004480:	ef 39 00 14 	ld.ub	r9,r7[20]
80004484:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004488:	ef 3a 00 16 	ld.ub	r10,r7[22]
8000448c:	ef 38 00 17 	ld.ub	r8,r7[23]
80004490:	b1 68       	lsl	r8,0x10
80004492:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004496:	ef 38 00 19 	ld.ub	r8,r7[25]
8000449a:	f5 e8 10 08 	or	r8,r10,r8
8000449e:	ef 3a 00 18 	ld.ub	r10,r7[24]
800044a2:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800044a6:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800044a8:	e0 64 79 b9 	mov	r4,31161
800044ac:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800044b0:	e0 65 45 07 	mov	r5,17671
800044b4:	ea 15 8a bd 	orh	r5,0x8abd
800044b8:	e0 66 f9 3d 	mov	r6,63805
800044bc:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800044c0:	e0 6e b8 cf 	mov	lr,47311
800044c4:	ea 1e 36 83 	orh	lr,0x3683
800044c8:	e0 67 aa 1c 	mov	r7,43548
800044cc:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800044d0:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800044d2:	f4 08 00 0c 	add	r12,r10,r8
800044d6:	f0 0b 15 04 	lsl	r11,r8,0x4
800044da:	0a 0b       	add	r11,r5
800044dc:	f9 eb 20 0b 	eor	r11,r12,r11
800044e0:	f0 0c 16 05 	lsr	r12,r8,0x5
800044e4:	0c 0c       	add	r12,r6
800044e6:	18 5b       	eor	r11,r12
800044e8:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800044ea:	f2 0c 15 04 	lsl	r12,r9,0x4
800044ee:	1c 0c       	add	r12,lr
800044f0:	f2 0b 16 05 	lsr	r11,r9,0x5
800044f4:	0e 0b       	add	r11,r7
800044f6:	f9 eb 20 0b 	eor	r11,r12,r11
800044fa:	f2 0a 00 0c 	add	r12,r9,r10
800044fe:	18 5b       	eor	r11,r12
80004500:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004502:	e0 6b 37 20 	mov	r11,14112
80004506:	ea 1b c6 ef 	orh	r11,0xc6ef
8000450a:	16 3a       	cp.w	r10,r11
8000450c:	ce 21       	brne	800044d0 <xnl_device_auth_reply_func+0x8c>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
8000450e:	e0 6a 40 1a 	mov	r10,16410
80004512:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004514:	3f fa       	mov	r10,-1
80004516:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004518:	30 6b       	mov	r11,6
8000451a:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
8000451c:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000451e:	48 eb       	lddpc	r11,80004554 <xnl_device_auth_reply_func+0x110>
80004520:	96 1c       	ld.sh	r12,r11[0x2]
80004522:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004524:	96 2b       	ld.sh	r11,r11[0x4]
80004526:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004528:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
8000452a:	30 ca       	mov	r10,12
8000452c:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
8000452e:	30 0a       	mov	r10,0
80004530:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004534:	30 7a       	mov	r10,7
80004536:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
8000453a:	30 2a       	mov	r10,2
8000453c:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004540:	fa ca ff ec 	sub	r10,sp,-20
80004544:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004546:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004548:	1a 9c       	mov	r12,sp
8000454a:	f0 1f 00 06 	mcall	80004560 <xnl_device_auth_reply_func+0x11c>
}
8000454e:	2c 0d       	sub	sp,-256
80004550:	d8 22       	popm	r4-r7,pc
80004552:	00 00       	add	r0,r0
80004554:	00 00       	add	r0,r0
80004556:	0b 34       	ld.ub	r4,r5++
80004558:	00 00       	add	r0,r0
8000455a:	0b 30       	ld.ub	r0,r5++
8000455c:	80 00       	ld.sh	r0,r0[0x0]
8000455e:	5e 08       	reteq	r8
80004560:	80 00       	ld.sh	r0,r0[0x0]
80004562:	43 00       	lddsp	r0,sp[0xc0]

80004564 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004564:	eb cd 40 80 	pushm	r7,lr
80004568:	fa cd 01 00 	sub	sp,sp,256
8000456c:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
8000456e:	49 28       	lddpc	r8,800045b4 <xnl_master_status_brdcst_func+0x50>
80004570:	11 88       	ld.ub	r8,r8[0x0]
80004572:	58 08       	cp.w	r8,0
80004574:	c1 c1       	brne	800045ac <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004576:	49 18       	lddpc	r8,800045b8 <xnl_master_status_brdcst_func+0x54>
80004578:	70 0c       	ld.w	r12,r8[0x0]
8000457a:	30 09       	mov	r9,0
8000457c:	12 9a       	mov	r10,r9
8000457e:	12 9b       	mov	r11,r9
80004580:	f0 1f 00 0f 	mcall	800045bc <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004584:	8e 58       	ld.sh	r8,r7[0xa]
80004586:	48 c9       	lddpc	r9,800045b4 <xnl_master_status_brdcst_func+0x50>
80004588:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000458a:	e0 68 40 0e 	mov	r8,16398
8000458e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004590:	3f f8       	mov	r8,-1
80004592:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004594:	30 4a       	mov	r10,4
80004596:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004598:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000459a:	92 19       	ld.sh	r9,r9[0x2]
8000459c:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
8000459e:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800045a0:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800045a2:	30 08       	mov	r8,0
800045a4:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800045a6:	1a 9c       	mov	r12,sp
800045a8:	f0 1f 00 06 	mcall	800045c0 <xnl_master_status_brdcst_func+0x5c>
}
800045ac:	2c 0d       	sub	sp,-256
800045ae:	e3 cd 80 80 	ldm	sp++,r7,pc
800045b2:	00 00       	add	r0,r0
800045b4:	00 00       	add	r0,r0
800045b6:	0b 34       	ld.ub	r4,r5++
800045b8:	00 00       	add	r0,r0
800045ba:	0b 30       	ld.ub	r0,r5++
800045bc:	80 00       	ld.sh	r0,r0[0x0]
800045be:	5e 08       	reteq	r8
800045c0:	80 00       	ld.sh	r0,r0[0x0]
800045c2:	43 00       	lddsp	r0,sp[0xc0]

800045c4 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
800045c4:	eb cd 40 80 	pushm	r7,lr
800045c8:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
800045ca:	49 28       	lddpc	r8,80004610 <xnl_device_conn_reply_func+0x4c>
800045cc:	70 0c       	ld.w	r12,r8[0x0]
800045ce:	30 09       	mov	r9,0
800045d0:	12 9a       	mov	r10,r9
800045d2:	12 9b       	mov	r11,r9
800045d4:	f0 1f 00 10 	mcall	80004614 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800045d8:	ef 18 00 10 	ld.uh	r8,r7[16]
800045dc:	10 99       	mov	r9,r8
800045de:	e2 19 ff 00 	andl	r9,0xff00,COH
800045e2:	e0 49 01 00 	cp.w	r9,256
800045e6:	c0 60       	breq	800045f2 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800045e8:	0e 9c       	mov	r12,r7
800045ea:	f0 1f 00 0c 	mcall	80004618 <xnl_device_conn_reply_func+0x54>
800045ee:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
800045f2:	a9 68       	lsl	r8,0x8
800045f4:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800045f8:	48 98       	lddpc	r8,8000461c <xnl_device_conn_reply_func+0x58>
800045fa:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
800045fc:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004600:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004602:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004606:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004608:	30 19       	mov	r9,1
8000460a:	b0 89       	st.b	r8[0x0],r9
8000460c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004610:	00 00       	add	r0,r0
80004612:	0b 30       	ld.ub	r0,r5++
80004614:	80 00       	ld.sh	r0,r0[0x0]
80004616:	5e 08       	reteq	r8
80004618:	80 00       	ld.sh	r0,r0[0x0]
8000461a:	45 64       	lddsp	r4,sp[0x158]
8000461c:	00 00       	add	r0,r0
8000461e:	0b 34       	ld.ub	r4,r5++

80004620 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
80004620:	d4 01       	pushm	lr
80004622:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004626:	e0 68 40 0e 	mov	r8,16398
8000462a:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000462c:	3f f8       	mov	r8,-1
8000462e:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004630:	30 38       	mov	r8,3
80004632:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004634:	30 08       	mov	r8,0
80004636:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004638:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
8000463a:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
8000463c:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
8000463e:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004640:	1a 9c       	mov	r12,sp
80004642:	f0 1f 00 03 	mcall	8000464c <xnl_send_device_master_query+0x2c>
}
80004646:	2c 0d       	sub	sp,-256
80004648:	d8 02       	popm	pc
8000464a:	00 00       	add	r0,r0
8000464c:	80 00       	ld.sh	r0,r0[0x0]
8000464e:	43 00       	lddsp	r0,sp[0xc0]

80004650 <delay_ns>:
U8 rc522_init_failure =0;

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80004650:	58 0c       	cp.w	r12,0
80004652:	5e 0c       	reteq	r12
80004654:	30 08       	mov	r8,0
	{
		nop();
80004656:	d7 03       	nop
		nop();
80004658:	d7 03       	nop
		nop();
8000465a:	d7 03       	nop
U8 rc522_init_failure =0;

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
8000465c:	2f f8       	sub	r8,-1
8000465e:	10 3c       	cp.w	r12,r8
80004660:	fe 9b ff fb 	brhi	80004656 <delay_ns+0x6>
80004664:	5e fc       	retal	r12
80004666:	d7 03       	nop

80004668 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
80004668:	eb cd 40 e0 	pushm	r5-r7,lr
8000466c:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
8000466e:	58 0c       	cp.w	r12,0
80004670:	c0 b0       	breq	80004686 <delay_us+0x1e>
80004672:	30 07       	mov	r7,0
		delay_ns(1000);
80004674:	e0 65 03 e8 	mov	r5,1000
80004678:	0a 9c       	mov	r12,r5
8000467a:	f0 1f 00 05 	mcall	8000468c <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
8000467e:	2f f7       	sub	r7,-1
80004680:	0e 36       	cp.w	r6,r7
80004682:	fe 9b ff fb 	brhi	80004678 <delay_us+0x10>
80004686:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000468a:	00 00       	add	r0,r0
8000468c:	80 00       	ld.sh	r0,r0[0x0]
8000468e:	46 50       	lddsp	r0,sp[0x194]

80004690 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
80004690:	eb cd 40 e0 	pushm	r5-r7,lr
80004694:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
80004696:	58 0c       	cp.w	r12,0
80004698:	c0 b0       	breq	800046ae <delay_ms+0x1e>
8000469a:	30 07       	mov	r7,0
		delay_us(1000);
8000469c:	e0 65 03 e8 	mov	r5,1000
800046a0:	0a 9c       	mov	r12,r5
800046a2:	f0 1f 00 05 	mcall	800046b4 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
800046a6:	2f f7       	sub	r7,-1
800046a8:	0e 36       	cp.w	r6,r7
800046aa:	fe 9b ff fb 	brhi	800046a0 <delay_ms+0x10>
800046ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800046b2:	00 00       	add	r0,r0
800046b4:	80 00       	ld.sh	r0,r0[0x0]
800046b6:	46 68       	lddsp	r8,sp[0x198]

800046b8 <RC522_SPI_SetSpeed>:
	SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
800046b8:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
800046ba:	48 78       	lddpc	r8,800046d4 <RC522_SPI_SetSpeed+0x1c>
800046bc:	70 09       	ld.w	r9,r8[0x0]
800046be:	72 ca       	ld.w	r10,r9[0x30]
800046c0:	5c 7c       	castu.h	r12
800046c2:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
800046c6:	f9 ea 10 0a 	or	r10,r12,r10
800046ca:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
800046cc:	70 0c       	ld.w	r12,r8[0x0]
800046ce:	f0 1f 00 03 	mcall	800046d8 <RC522_SPI_SetSpeed+0x20>
		
	
}
800046d2:	d8 02       	popm	pc
800046d4:	00 00       	add	r0,r0
800046d6:	1d 98       	ld.ub	r8,lr[0x1]
800046d8:	80 00       	ld.sh	r0,r0[0x0]
800046da:	52 f8       	stdsp	sp[0xbc],r8

800046dc <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
800046dc:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0xFF00);//baudDiv=255
800046de:	e0 6c ff 00 	mov	r12,65280
800046e2:	f0 1f 00 02 	mcall	800046e8 <RC522_SPI_SetSpeedLow+0xc>
	
}
800046e6:	d8 02       	popm	pc
800046e8:	80 00       	ld.sh	r0,r0[0x0]
800046ea:	46 b8       	lddsp	r8,sp[0x1ac]

800046ec <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
800046ec:	eb cd 40 c0 	pushm	r6-r7,lr
	U16 *Data ;

	//蹇椤昏锋芥ｅ父璇诲
	spi_selectChip(spi, DF_SPI_PCS_0);
800046f0:	48 b7       	lddpc	r7,8000471c <RC522_ReadByte+0x30>
800046f2:	30 0b       	mov	r11,0
800046f4:	6e 0c       	ld.w	r12,r7[0x0]
800046f6:	f0 1f 00 0b 	mcall	80004720 <RC522_ReadByte+0x34>
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
800046fa:	e0 6b 00 ff 	mov	r11,255
800046fe:	6e 0c       	ld.w	r12,r7[0x0]
80004700:	f0 1f 00 09 	mcall	80004724 <RC522_ReadByte+0x38>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
80004704:	30 06       	mov	r6,0
80004706:	0c 9b       	mov	r11,r6
80004708:	6e 0c       	ld.w	r12,r7[0x0]
8000470a:	f0 1f 00 08 	mcall	80004728 <RC522_ReadByte+0x3c>

	/*!< Return the shifted data */
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
8000470e:	0c 9b       	mov	r11,r6
80004710:	6e 0c       	ld.w	r12,r7[0x0]
80004712:	f0 1f 00 07 	mcall	8000472c <RC522_ReadByte+0x40>
	
	return (U8)(*Data);
	
}
80004716:	0d 9c       	ld.ub	r12,r6[0x1]
80004718:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000471c:	00 00       	add	r0,r0
8000471e:	1d 98       	ld.ub	r8,lr[0x1]
80004720:	80 00       	ld.sh	r0,r0[0x0]
80004722:	54 64       	stdsp	sp[0x118],r4
80004724:	80 00       	ld.sh	r0,r0[0x0]
80004726:	52 fe       	stdsp	sp[0xbc],lr
80004728:	80 00       	ld.sh	r0,r0[0x0]
8000472a:	53 1a       	stdsp	sp[0xc4],r10
8000472c:	80 00       	ld.sh	r0,r0[0x0]
8000472e:	54 24       	stdsp	sp[0x108],r4

80004730 <RC522_WriteByte>:
	
}


U8 RC522_WriteByte(U8 Data)
{
80004730:	eb cd 40 c0 	pushm	r6-r7,lr
80004734:	20 1d       	sub	sp,4
80004736:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	spi_selectChip(spi, DF_SPI_PCS_0);
80004738:	48 c7       	lddpc	r7,80004768 <RC522_WriteByte+0x38>
8000473a:	30 0b       	mov	r11,0
8000473c:	6e 0c       	ld.w	r12,r7[0x0]
8000473e:	f0 1f 00 0c 	mcall	8000476c <RC522_WriteByte+0x3c>
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
80004742:	1b 8b       	ld.ub	r11,sp[0x0]
80004744:	6e 0c       	ld.w	r12,r7[0x0]
80004746:	f0 1f 00 0b 	mcall	80004770 <RC522_WriteByte+0x40>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
8000474a:	1a 9b       	mov	r11,sp
8000474c:	6e 0c       	ld.w	r12,r7[0x0]
8000474e:	f0 1f 00 0a 	mcall	80004774 <RC522_WriteByte+0x44>
80004752:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004754:	30 0b       	mov	r11,0
80004756:	6e 0c       	ld.w	r12,r7[0x0]
80004758:	f0 1f 00 08 	mcall	80004778 <RC522_WriteByte+0x48>
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
8000475c:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
80004760:	2f fd       	sub	sp,-4
80004762:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004766:	00 00       	add	r0,r0
80004768:	00 00       	add	r0,r0
8000476a:	1d 98       	ld.ub	r8,lr[0x1]
8000476c:	80 00       	ld.sh	r0,r0[0x0]
8000476e:	54 64       	stdsp	sp[0x118],r4
80004770:	80 00       	ld.sh	r0,r0[0x0]
80004772:	52 fe       	stdsp	sp[0xbc],lr
80004774:	80 00       	ld.sh	r0,r0[0x0]
80004776:	53 1a       	stdsp	sp[0xc4],r10
80004778:	80 00       	ld.sh	r0,r0[0x0]
8000477a:	54 24       	stdsp	sp[0x108],r4

8000477c <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
8000477c:	eb cd 40 c0 	pushm	r6-r7,lr
80004780:	18 96       	mov	r6,r12
80004782:	16 97       	mov	r7,r11
	U8   ucAddr;

	CLR_SPI_CS;	
80004784:	31 8c       	mov	r12,24
80004786:	f0 1f 00 09 	mcall	800047a8 <WriteRawRC+0x2c>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
8000478a:	ec 0c 15 01 	lsl	r12,r6,0x1
8000478e:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004792:	f0 1f 00 07 	mcall	800047ac <WriteRawRC+0x30>
	RC522_WriteByte(value);
80004796:	0e 9c       	mov	r12,r7
80004798:	f0 1f 00 05 	mcall	800047ac <WriteRawRC+0x30>
	
	SET_SPI_CS;
8000479c:	31 8c       	mov	r12,24
8000479e:	f0 1f 00 05 	mcall	800047b0 <WriteRawRC+0x34>

}
800047a2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800047a6:	00 00       	add	r0,r0
800047a8:	80 00       	ld.sh	r0,r0[0x0]
800047aa:	51 48       	stdsp	sp[0x50],r8
800047ac:	80 00       	ld.sh	r0,r0[0x0]
800047ae:	47 30       	lddsp	r0,sp[0x1cc]
800047b0:	80 00       	ld.sh	r0,r0[0x0]
800047b2:	51 2c       	stdsp	sp[0x48],r12

800047b4 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
800047b4:	d4 01       	pushm	lr

	SET_RC522RST;
800047b6:	31 9c       	mov	r12,25
800047b8:	f0 1f 00 1b 	mcall	80004824 <PcdReset+0x70>
	delay_ns(10);
800047bc:	30 ac       	mov	r12,10
800047be:	f0 1f 00 1b 	mcall	80004828 <PcdReset+0x74>

	CLR_RC522RST;
800047c2:	31 9c       	mov	r12,25
800047c4:	f0 1f 00 1a 	mcall	8000482c <PcdReset+0x78>
	delay_ns(10);
800047c8:	30 ac       	mov	r12,10
800047ca:	f0 1f 00 18 	mcall	80004828 <PcdReset+0x74>

	SET_RC522RST;
800047ce:	31 9c       	mov	r12,25
800047d0:	f0 1f 00 15 	mcall	80004824 <PcdReset+0x70>
	delay_ns(10);
800047d4:	30 ac       	mov	r12,10
800047d6:	f0 1f 00 15 	mcall	80004828 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
800047da:	30 fb       	mov	r11,15
800047dc:	30 1c       	mov	r12,1
800047de:	f0 1f 00 15 	mcall	80004830 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
800047e2:	30 fb       	mov	r11,15
800047e4:	30 1c       	mov	r12,1
800047e6:	f0 1f 00 13 	mcall	80004830 <PcdReset+0x7c>
	delay_ns(10);
800047ea:	30 ac       	mov	r12,10
800047ec:	f0 1f 00 0f 	mcall	80004828 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
800047f0:	33 db       	mov	r11,61
800047f2:	31 1c       	mov	r12,17
800047f4:	f0 1f 00 0f 	mcall	80004830 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
800047f8:	31 eb       	mov	r11,30
800047fa:	32 dc       	mov	r12,45
800047fc:	f0 1f 00 0d 	mcall	80004830 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80004800:	30 0b       	mov	r11,0
80004802:	32 cc       	mov	r12,44
80004804:	f0 1f 00 0b 	mcall	80004830 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
80004808:	e0 6b 00 8d 	mov	r11,141
8000480c:	32 ac       	mov	r12,42
8000480e:	f0 1f 00 09 	mcall	80004830 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
80004812:	33 eb       	mov	r11,62
80004814:	32 bc       	mov	r12,43
80004816:	f0 1f 00 07 	mcall	80004830 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
8000481a:	34 0b       	mov	r11,64
8000481c:	31 5c       	mov	r12,21
8000481e:	f0 1f 00 05 	mcall	80004830 <PcdReset+0x7c>
	
	return MI_OK;
}
80004822:	d8 0a       	popm	pc,r12=0
80004824:	80 00       	ld.sh	r0,r0[0x0]
80004826:	51 2c       	stdsp	sp[0x48],r12
80004828:	80 00       	ld.sh	r0,r0[0x0]
8000482a:	46 50       	lddsp	r0,sp[0x194]
8000482c:	80 00       	ld.sh	r0,r0[0x0]
8000482e:	51 48       	stdsp	sp[0x50],r8
80004830:	80 00       	ld.sh	r0,r0[0x0]
80004832:	47 7c       	lddsp	r12,sp[0x1dc]

80004834 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
80004834:	eb cd 40 80 	pushm	r7,lr
80004838:	18 97       	mov	r7,r12
	U8   ucAddr;
	U8   ucResult=0;
	CLR_SPI_CS;	
8000483a:	31 8c       	mov	r12,24
8000483c:	f0 1f 00 0a 	mcall	80004864 <ReadRawRC+0x30>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
80004840:	ee 08 15 01 	lsl	r8,r7,0x1
80004844:	10 9c       	mov	r12,r8
80004846:	e2 1c 00 7e 	andl	r12,0x7e,COH
8000484a:	a7 bc       	sbr	r12,0x7
8000484c:	f0 1f 00 07 	mcall	80004868 <ReadRawRC+0x34>
	ucResult = RC522_ReadByte();
80004850:	f0 1f 00 07 	mcall	8000486c <ReadRawRC+0x38>
80004854:	18 97       	mov	r7,r12
	
	SET_SPI_CS;
80004856:	31 8c       	mov	r12,24
80004858:	f0 1f 00 06 	mcall	80004870 <ReadRawRC+0x3c>
	return ucResult;
}
8000485c:	0e 9c       	mov	r12,r7
8000485e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004862:	00 00       	add	r0,r0
80004864:	80 00       	ld.sh	r0,r0[0x0]
80004866:	51 48       	stdsp	sp[0x50],r8
80004868:	80 00       	ld.sh	r0,r0[0x0]
8000486a:	47 30       	lddsp	r0,sp[0x1cc]
8000486c:	80 00       	ld.sh	r0,r0[0x0]
8000486e:	46 ec       	lddsp	r12,sp[0x1b8]
80004870:	80 00       	ld.sh	r0,r0[0x0]
80004872:	51 2c       	stdsp	sp[0x48],r12

80004874 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80004874:	eb cd 40 c0 	pushm	r6-r7,lr
80004878:	18 97       	mov	r7,r12
8000487a:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
8000487c:	f0 1f 00 05 	mcall	80004890 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80004880:	f9 e6 10 0b 	or	r11,r12,r6
80004884:	5c 5b       	castu.b	r11
80004886:	0e 9c       	mov	r12,r7
80004888:	f0 1f 00 03 	mcall	80004894 <SetBitMask+0x20>
}
8000488c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004890:	80 00       	ld.sh	r0,r0[0x0]
80004892:	48 34       	lddpc	r4,8000489c <PcdAntennaOn+0x4>
80004894:	80 00       	ld.sh	r0,r0[0x0]
80004896:	47 7c       	lddsp	r12,sp[0x1dc]

80004898 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80004898:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
8000489a:	31 4c       	mov	r12,20
8000489c:	f0 1f 00 05 	mcall	800048b0 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
800048a0:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
800048a4:	c0 51       	brne	800048ae <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
800048a6:	30 3b       	mov	r11,3
800048a8:	31 4c       	mov	r12,20
800048aa:	f0 1f 00 03 	mcall	800048b4 <PcdAntennaOn+0x1c>
800048ae:	d8 02       	popm	pc
800048b0:	80 00       	ld.sh	r0,r0[0x0]
800048b2:	48 34       	lddpc	r4,800048bc <ClearBitMask+0x4>
800048b4:	80 00       	ld.sh	r0,r0[0x0]
800048b6:	48 74       	lddpc	r4,800048d0 <ClearBitMask+0x18>

800048b8 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
800048b8:	eb cd 40 c0 	pushm	r6-r7,lr
800048bc:	18 97       	mov	r7,r12
800048be:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
800048c0:	f0 1f 00 06 	mcall	800048d8 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
800048c4:	5c d6       	com	r6
800048c6:	f9 e6 00 06 	and	r6,r12,r6
800048ca:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
800048ce:	0e 9c       	mov	r12,r7
800048d0:	f0 1f 00 03 	mcall	800048dc <ClearBitMask+0x24>
	
}
800048d4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800048d8:	80 00       	ld.sh	r0,r0[0x0]
800048da:	48 34       	lddpc	r4,800048e4 <PcdAntennaOff+0x4>
800048dc:	80 00       	ld.sh	r0,r0[0x0]
800048de:	47 7c       	lddsp	r12,sp[0x1dc]

800048e0 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
800048e0:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
800048e2:	30 3b       	mov	r11,3
800048e4:	31 4c       	mov	r12,20
800048e6:	f0 1f 00 02 	mcall	800048ec <PcdAntennaOff+0xc>
}
800048ea:	d8 02       	popm	pc
800048ec:	80 00       	ld.sh	r0,r0[0x0]
800048ee:	48 b8       	lddpc	r8,80004918 <M500PcdConfigISOType+0x28>

800048f0 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
800048f0:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
800048f2:	34 18       	mov	r8,65
800048f4:	f0 0c 18 00 	cp.b	r12,r8
800048f8:	c0 20       	breq	800048fc <M500PcdConfigISOType+0xc>
800048fa:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
800048fc:	30 8b       	mov	r11,8
800048fe:	16 9c       	mov	r12,r11
80004900:	f0 1f 00 14 	mcall	80004950 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
80004904:	33 db       	mov	r11,61
80004906:	31 1c       	mov	r12,17
80004908:	f0 1f 00 13 	mcall	80004954 <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
8000490c:	e0 6b 00 86 	mov	r11,134
80004910:	31 7c       	mov	r12,23
80004912:	f0 1f 00 11 	mcall	80004954 <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
80004916:	37 fb       	mov	r11,127
80004918:	32 6c       	mov	r12,38
8000491a:	f0 1f 00 0f 	mcall	80004954 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
8000491e:	31 eb       	mov	r11,30
80004920:	32 dc       	mov	r12,45
80004922:	f0 1f 00 0d 	mcall	80004954 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
80004926:	30 0b       	mov	r11,0
80004928:	32 cc       	mov	r12,44
8000492a:	f0 1f 00 0b 	mcall	80004954 <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
8000492e:	e0 6b 00 8d 	mov	r11,141
80004932:	32 ac       	mov	r12,42
80004934:	f0 1f 00 08 	mcall	80004954 <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80004938:	33 eb       	mov	r11,62
8000493a:	32 bc       	mov	r12,43
8000493c:	f0 1f 00 06 	mcall	80004954 <M500PcdConfigISOType+0x64>
		delay_ns(1000);
80004940:	e0 6c 03 e8 	mov	r12,1000
80004944:	f0 1f 00 05 	mcall	80004958 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80004948:	f0 1f 00 05 	mcall	8000495c <M500PcdConfigISOType+0x6c>
8000494c:	d8 0a       	popm	pc,r12=0
8000494e:	00 00       	add	r0,r0
80004950:	80 00       	ld.sh	r0,r0[0x0]
80004952:	48 b8       	lddpc	r8,8000497c <rc522_init+0x1c>
80004954:	80 00       	ld.sh	r0,r0[0x0]
80004956:	47 7c       	lddsp	r12,sp[0x1dc]
80004958:	80 00       	ld.sh	r0,r0[0x0]
8000495a:	46 50       	lddsp	r0,sp[0x194]
8000495c:	80 00       	ld.sh	r0,r0[0x0]
8000495e:	48 98       	lddpc	r8,80004980 <rc522_init+0x20>

80004960 <rc522_init>:


//mfrc522 init

void rc522_init()
{
80004960:	eb cd 40 c0 	pushm	r6-r7,lr
80004964:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004966:	4a 28       	lddpc	r8,800049ec <rc522_init+0x8c>
80004968:	1a 96       	mov	r6,sp
8000496a:	f0 ea 00 00 	ld.d	r10,r8[0]
8000496e:	fa eb 00 00 	st.d	sp[0],r10
80004972:	f0 e8 00 08 	ld.d	r8,r8[8]
80004976:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
8000497a:	30 4b       	mov	r11,4
8000497c:	49 dc       	lddpc	r12,800049f0 <rc522_init+0x90>
8000497e:	f0 1f 00 1e 	mcall	800049f4 <rc522_init+0x94>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80004982:	31 9c       	mov	r12,25
80004984:	f0 1f 00 1d 	mcall	800049f8 <rc522_init+0x98>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80004988:	31 9c       	mov	r12,25
8000498a:	f0 1f 00 1d 	mcall	800049fc <rc522_init+0x9c>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
8000498e:	49 d7       	lddpc	r7,80004a00 <rc522_init+0xa0>
80004990:	fe 7c 24 00 	mov	r12,-56320
80004994:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80004996:	1a 9b       	mov	r11,sp
80004998:	f0 1f 00 1b 	mcall	80004a04 <rc522_init+0xa4>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
8000499c:	30 09       	mov	r9,0
8000499e:	12 9a       	mov	r10,r9
800049a0:	12 9b       	mov	r11,r9
800049a2:	6e 0c       	ld.w	r12,r7[0x0]
800049a4:	f0 1f 00 19 	mcall	80004a08 <rc522_init+0xa8>

	// Enable SPI.
	spi_enable(spi);
800049a8:	6e 0c       	ld.w	r12,r7[0x0]
800049aa:	f0 1f 00 19 	mcall	80004a0c <rc522_init+0xac>

	// Initialize RC522 with SPI clock Osc0.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
800049ae:	e0 6a 36 00 	mov	r10,13824
800049b2:	ea 1a 01 6e 	orh	r10,0x16e
800049b6:	1a 9b       	mov	r11,sp
800049b8:	6e 0c       	ld.w	r12,r7[0x0]
800049ba:	f0 1f 00 16 	mcall	80004a10 <rc522_init+0xb0>
800049be:	c0 50       	breq	800049c8 <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
800049c0:	30 29       	mov	r9,2
800049c2:	49 58       	lddpc	r8,80004a14 <rc522_init+0xb4>
800049c4:	b0 89       	st.b	r8[0x0],r9
800049c6:	c0 38       	rjmp	800049cc <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
800049c8:	f0 1f 00 14 	mcall	80004a18 <rc522_init+0xb8>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
800049cc:	f0 1f 00 14 	mcall	80004a1c <rc522_init+0xbc>
	
	PcdAntennaOff();
800049d0:	f0 1f 00 14 	mcall	80004a20 <rc522_init+0xc0>
	
	delay_ms(2); 
800049d4:	30 2c       	mov	r12,2
800049d6:	f0 1f 00 14 	mcall	80004a24 <rc522_init+0xc4>
	
	PcdAntennaOn();
800049da:	f0 1f 00 14 	mcall	80004a28 <rc522_init+0xc8>
	
	M500PcdConfigISOType( 'A' );
800049de:	34 1c       	mov	r12,65
800049e0:	f0 1f 00 13 	mcall	80004a2c <rc522_init+0xcc>
	

800049e4:	2f cd       	sub	sp,-16
800049e6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800049ea:	00 00       	add	r0,r0
800049ec:	80 00       	ld.sh	r0,r0[0x0]
800049ee:	d1 4c       	*unknown*
800049f0:	80 00       	ld.sh	r0,r0[0x0]
800049f2:	d1 60       	acall	0x16
800049f4:	80 00       	ld.sh	r0,r0[0x0]
800049f6:	50 e4       	stdsp	sp[0x38],r4
800049f8:	80 00       	ld.sh	r0,r0[0x0]
800049fa:	51 14       	stdsp	sp[0x44],r4
800049fc:	80 00       	ld.sh	r0,r0[0x0]
800049fe:	51 2c       	stdsp	sp[0x48],r12
80004a00:	00 00       	add	r0,r0
80004a02:	1d 98       	ld.ub	r8,lr[0x1]
80004a04:	80 00       	ld.sh	r0,r0[0x0]
80004a06:	52 94       	stdsp	sp[0xa4],r4
80004a08:	80 00       	ld.sh	r0,r0[0x0]
80004a0a:	52 cc       	stdsp	sp[0xb0],r12
80004a0c:	80 00       	ld.sh	r0,r0[0x0]
80004a0e:	52 f8       	stdsp	sp[0xbc],r8
80004a10:	80 00       	ld.sh	r0,r0[0x0]
80004a12:	53 3c       	stdsp	sp[0xcc],r12
80004a14:	00 00       	add	r0,r0
80004a16:	0b 58       	ld.sh	r8,--r5
80004a18:	80 00       	ld.sh	r0,r0[0x0]
80004a1a:	46 dc       	lddsp	r12,sp[0x1b4]
80004a1c:	80 00       	ld.sh	r0,r0[0x0]
80004a1e:	47 b4       	lddsp	r4,sp[0x1ec]
80004a20:	80 00       	ld.sh	r0,r0[0x0]
80004a22:	48 e0       	lddpc	r0,80004a58 <PcdComMF522+0x28>
80004a24:	80 00       	ld.sh	r0,r0[0x0]
80004a26:	46 90       	lddsp	r0,sp[0x1a4]
80004a28:	80 00       	ld.sh	r0,r0[0x0]
80004a2a:	48 98       	lddpc	r8,80004a4c <PcdComMF522+0x1c>
80004a2c:	80 00       	ld.sh	r0,r0[0x0]
80004a2e:	48 f0       	lddpc	r0,80004a68 <PcdComMF522+0x38>

80004a30 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004a30:	d4 31       	pushm	r0-r7,lr
80004a32:	20 1d       	sub	sp,4
80004a34:	18 92       	mov	r2,r12
80004a36:	16 95       	mov	r5,r11
80004a38:	14 96       	mov	r6,r10
80004a3a:	50 09       	stdsp	sp[0x0],r9
80004a3c:	10 90       	mov	r0,r8
80004a3e:	f8 c8 00 0c 	sub	r8,r12,12
80004a42:	5c 58       	castu.b	r8
80004a44:	30 29       	mov	r9,2
80004a46:	f2 08 18 00 	cp.b	r8,r9
80004a4a:	e0 88 00 05 	brls	80004a54 <PcdComMF522+0x24>
80004a4e:	30 03       	mov	r3,0
80004a50:	06 91       	mov	r1,r3
80004a52:	c0 78       	rjmp	80004a60 <PcdComMF522+0x30>
80004a54:	4c f9       	lddpc	r9,80004b90 <PcdComMF522+0x160>
80004a56:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004a5a:	4c f9       	lddpc	r9,80004b94 <PcdComMF522+0x164>
80004a5c:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004a60:	02 9b       	mov	r11,r1
80004a62:	a7 bb       	sbr	r11,0x7
80004a64:	30 2c       	mov	r12,2
80004a66:	f0 1f 00 4d 	mcall	80004b98 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004a6a:	e0 6b 00 80 	mov	r11,128
80004a6e:	30 4c       	mov	r12,4
80004a70:	f0 1f 00 4b 	mcall	80004b9c <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004a74:	30 0b       	mov	r11,0
80004a76:	30 1c       	mov	r12,1
80004a78:	f0 1f 00 48 	mcall	80004b98 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004a7c:	e0 6b 00 80 	mov	r11,128
80004a80:	30 ac       	mov	r12,10
80004a82:	f0 1f 00 48 	mcall	80004ba0 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004a86:	58 06       	cp.w	r6,0
80004a88:	c0 c0       	breq	80004aa0 <PcdComMF522+0x70>
80004a8a:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004a8c:	30 94       	mov	r4,9
80004a8e:	0f 3b       	ld.ub	r11,r7++
80004a90:	08 9c       	mov	r12,r4
80004a92:	f0 1f 00 42 	mcall	80004b98 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004a96:	0e 98       	mov	r8,r7
80004a98:	0a 18       	sub	r8,r5
80004a9a:	ec 08 19 00 	cp.h	r8,r6
80004a9e:	cf 83       	brcs	80004a8e <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004aa0:	04 9b       	mov	r11,r2
80004aa2:	30 1c       	mov	r12,1
80004aa4:	f0 1f 00 3d 	mcall	80004b98 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004aa8:	30 c8       	mov	r8,12
80004aaa:	f0 02 18 00 	cp.b	r2,r8
80004aae:	c0 61       	brne	80004aba <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004ab0:	e0 6b 00 80 	mov	r11,128
80004ab4:	30 dc       	mov	r12,13
80004ab6:	f0 1f 00 3b 	mcall	80004ba0 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004aba:	30 4c       	mov	r12,4
80004abc:	f0 1f 00 3a 	mcall	80004ba4 <PcdComMF522+0x174>
80004ac0:	18 97       	mov	r7,r12
80004ac2:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004ac6:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004ac8:	30 44       	mov	r4,4
80004aca:	c0 88       	rjmp	80004ada <PcdComMF522+0xaa>
80004acc:	08 9c       	mov	r12,r4
80004ace:	f0 1f 00 36 	mcall	80004ba4 <PcdComMF522+0x174>
80004ad2:	18 97       	mov	r7,r12
		i--;
80004ad4:	20 16       	sub	r6,1
80004ad6:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004ad8:	c0 a0       	breq	80004aec <PcdComMF522+0xbc>
80004ada:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004ade:	c4 c1       	brne	80004b76 <PcdComMF522+0x146>
80004ae0:	ef e3 00 08 	and	r8,r7,r3
80004ae4:	ea 08 18 00 	cp.b	r8,r5
80004ae8:	cf 20       	breq	80004acc <PcdComMF522+0x9c>
80004aea:	c4 68       	rjmp	80004b76 <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004aec:	e0 6b 00 80 	mov	r11,128
80004af0:	30 dc       	mov	r12,13
80004af2:	f0 1f 00 2b 	mcall	80004b9c <PcdComMF522+0x16c>
80004af6:	30 27       	mov	r7,2
80004af8:	c3 38       	rjmp	80004b5e <PcdComMF522+0x12e>
80004afa:	02 67       	and	r7,r1
80004afc:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004b00:	30 c8       	mov	r8,12
80004b02:	f0 02 18 00 	cp.b	r2,r8
80004b06:	c2 c1       	brne	80004b5e <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004b08:	30 ac       	mov	r12,10
80004b0a:	f0 1f 00 27 	mcall	80004ba4 <PcdComMF522+0x174>
80004b0e:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004b10:	30 cc       	mov	r12,12
80004b12:	f0 1f 00 25 	mcall	80004ba4 <PcdComMF522+0x174>
80004b16:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004b1a:	c0 70       	breq	80004b28 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004b1c:	08 98       	mov	r8,r4
80004b1e:	20 18       	sub	r8,1
80004b20:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004b24:	a0 8c       	st.b	r0[0x0],r12
80004b26:	c0 48       	rjmp	80004b2e <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004b28:	e8 08 15 03 	lsl	r8,r4,0x3
80004b2c:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004b2e:	58 04       	cp.w	r4,0
80004b30:	c0 61       	brne	80004b3c <PcdComMF522+0x10c>
80004b32:	30 14       	mov	r4,1
80004b34:	40 05       	lddsp	r5,sp[0x0]
80004b36:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004b38:	30 93       	mov	r3,9
80004b3a:	c0 98       	rjmp	80004b4c <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004b3c:	31 28       	mov	r8,18
80004b3e:	f0 04 18 00 	cp.b	r4,r8
80004b42:	f9 b4 0b 12 	movhi	r4,18
80004b46:	58 04       	cp.w	r4,0
80004b48:	cf 61       	brne	80004b34 <PcdComMF522+0x104>
80004b4a:	c0 a8       	rjmp	80004b5e <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004b4c:	06 9c       	mov	r12,r3
80004b4e:	f0 1f 00 16 	mcall	80004ba4 <PcdComMF522+0x174>
80004b52:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004b54:	ec 05 01 08 	sub	r8,r6,r5
80004b58:	e8 08 19 00 	cp.h	r8,r4
80004b5c:	cf 83       	brcs	80004b4c <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004b5e:	e0 6b 00 80 	mov	r11,128
80004b62:	30 cc       	mov	r12,12
80004b64:	f0 1f 00 0f 	mcall	80004ba0 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004b68:	30 0b       	mov	r11,0
80004b6a:	30 1c       	mov	r12,1
80004b6c:	f0 1f 00 0b 	mcall	80004b98 <PcdComMF522+0x168>
	return status;
}
80004b70:	0e 9c       	mov	r12,r7
80004b72:	2f fd       	sub	sp,-4
80004b74:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004b76:	e0 6b 00 80 	mov	r11,128
80004b7a:	30 dc       	mov	r12,13
80004b7c:	f0 1f 00 08 	mcall	80004b9c <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004b80:	30 6c       	mov	r12,6
80004b82:	f0 1f 00 09 	mcall	80004ba4 <PcdComMF522+0x174>
80004b86:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004b8a:	cb 80       	breq	80004afa <PcdComMF522+0xca>
80004b8c:	30 27       	mov	r7,2
80004b8e:	ce 8b       	rjmp	80004b5e <PcdComMF522+0x12e>
80004b90:	80 00       	ld.sh	r0,r0[0x0]
80004b92:	d1 5c       	*unknown*
80004b94:	80 00       	ld.sh	r0,r0[0x0]
80004b96:	d1 48       	*unknown*
80004b98:	80 00       	ld.sh	r0,r0[0x0]
80004b9a:	47 7c       	lddsp	r12,sp[0x1dc]
80004b9c:	80 00       	ld.sh	r0,r0[0x0]
80004b9e:	48 b8       	lddpc	r8,80004bc8 <PcdAnticoll+0x20>
80004ba0:	80 00       	ld.sh	r0,r0[0x0]
80004ba2:	48 74       	lddpc	r4,80004bbc <PcdAnticoll+0x14>
80004ba4:	80 00       	ld.sh	r0,r0[0x0]
80004ba6:	48 34       	lddpc	r4,80004bb0 <PcdAnticoll+0x8>

80004ba8 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004ba8:	eb cd 40 c0 	pushm	r6-r7,lr
80004bac:	20 5d       	sub	sp,20
80004bae:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004bb0:	30 8b       	mov	r11,8
80004bb2:	16 9c       	mov	r12,r11
80004bb4:	f0 1f 00 1a 	mcall	80004c1c <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004bb8:	30 0b       	mov	r11,0
80004bba:	30 dc       	mov	r12,13
80004bbc:	f0 1f 00 19 	mcall	80004c20 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004bc0:	e0 6b 00 80 	mov	r11,128
80004bc4:	30 ec       	mov	r12,14
80004bc6:	f0 1f 00 16 	mcall	80004c1c <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004bca:	39 38       	mov	r8,-109
80004bcc:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004bce:	32 08       	mov	r8,32
80004bd0:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004bd2:	1a 9b       	mov	r11,sp
80004bd4:	fa c8 ff ed 	sub	r8,sp,-19
80004bd8:	1a 99       	mov	r9,sp
80004bda:	30 2a       	mov	r10,2
80004bdc:	30 cc       	mov	r12,12
80004bde:	f0 1f 00 12 	mcall	80004c24 <PcdAnticoll+0x7c>
80004be2:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004be4:	c1 21       	brne	80004c08 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004be6:	1b 89       	ld.ub	r9,sp[0x0]
80004be8:	ac 89       	st.b	r6[0x0],r9
80004bea:	1b 98       	ld.ub	r8,sp[0x1]
80004bec:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004bee:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004bf0:	1b a8       	ld.ub	r8,sp[0x2]
80004bf2:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004bf4:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004bf8:	1b b9       	ld.ub	r9,sp[0x3]
80004bfa:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004bfc:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004bfe:	1b c9       	ld.ub	r9,sp[0x4]
80004c00:	f0 09 18 00 	cp.b	r9,r8
80004c04:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004c08:	e0 6b 00 80 	mov	r11,128
80004c0c:	30 ec       	mov	r12,14
80004c0e:	f0 1f 00 07 	mcall	80004c28 <PcdAnticoll+0x80>
	return status;
}
80004c12:	0e 9c       	mov	r12,r7
80004c14:	2f bd       	sub	sp,-20
80004c16:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c1a:	00 00       	add	r0,r0
80004c1c:	80 00       	ld.sh	r0,r0[0x0]
80004c1e:	48 b8       	lddpc	r8,80004c48 <PcdRequest+0x1c>
80004c20:	80 00       	ld.sh	r0,r0[0x0]
80004c22:	47 7c       	lddsp	r12,sp[0x1dc]
80004c24:	80 00       	ld.sh	r0,r0[0x0]
80004c26:	4a 30       	lddpc	r0,80004cb0 <CalulateCRC+0x20>
80004c28:	80 00       	ld.sh	r0,r0[0x0]
80004c2a:	48 74       	lddpc	r4,80004c44 <PcdRequest+0x18>

80004c2c <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004c2c:	eb cd 40 c0 	pushm	r6-r7,lr
80004c30:	20 5d       	sub	sp,20
80004c32:	18 97       	mov	r7,r12
80004c34:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004c36:	30 8b       	mov	r11,8
80004c38:	16 9c       	mov	r12,r11
80004c3a:	f0 1f 00 12 	mcall	80004c80 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004c3e:	30 7b       	mov	r11,7
80004c40:	30 dc       	mov	r12,13
80004c42:	f0 1f 00 11 	mcall	80004c84 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004c46:	30 3b       	mov	r11,3
80004c48:	31 4c       	mov	r12,20
80004c4a:	f0 1f 00 10 	mcall	80004c88 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004c4e:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004c50:	1a 9b       	mov	r11,sp
80004c52:	fa c8 ff ed 	sub	r8,sp,-19
80004c56:	1a 99       	mov	r9,sp
80004c58:	30 1a       	mov	r10,1
80004c5a:	30 cc       	mov	r12,12
80004c5c:	f0 1f 00 0c 	mcall	80004c8c <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004c60:	c0 c1       	brne	80004c78 <PcdRequest+0x4c>
80004c62:	31 08       	mov	r8,16
80004c64:	fb 39 00 13 	ld.ub	r9,sp[19]
80004c68:	f0 09 18 00 	cp.b	r9,r8
80004c6c:	c0 61       	brne	80004c78 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004c6e:	1b 88       	ld.ub	r8,sp[0x0]
80004c70:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004c72:	1b 98       	ld.ub	r8,sp[0x1]
80004c74:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004c76:	c0 28       	rjmp	80004c7a <PcdRequest+0x4e>
80004c78:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004c7a:	2f bd       	sub	sp,-20
80004c7c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c80:	80 00       	ld.sh	r0,r0[0x0]
80004c82:	48 b8       	lddpc	r8,80004cac <CalulateCRC+0x1c>
80004c84:	80 00       	ld.sh	r0,r0[0x0]
80004c86:	47 7c       	lddsp	r12,sp[0x1dc]
80004c88:	80 00       	ld.sh	r0,r0[0x0]
80004c8a:	48 74       	lddpc	r4,80004ca4 <CalulateCRC+0x14>
80004c8c:	80 00       	ld.sh	r0,r0[0x0]
80004c8e:	4a 30       	lddpc	r0,80004d18 <CalulateCRC+0x88>

80004c90 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004c90:	eb cd 40 f8 	pushm	r3-r7,lr
80004c94:	18 95       	mov	r5,r12
80004c96:	16 96       	mov	r6,r11
80004c98:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004c9a:	30 4b       	mov	r11,4
80004c9c:	30 5c       	mov	r12,5
80004c9e:	f0 1f 00 1c 	mcall	80004d0c <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004ca2:	30 0b       	mov	r11,0
80004ca4:	30 1c       	mov	r12,1
80004ca6:	f0 1f 00 1b 	mcall	80004d10 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004caa:	e0 6b 00 80 	mov	r11,128
80004cae:	30 ac       	mov	r12,10
80004cb0:	f0 1f 00 19 	mcall	80004d14 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004cb4:	58 06       	cp.w	r6,0
80004cb6:	c0 c0       	breq	80004cce <CalulateCRC+0x3e>
80004cb8:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004cba:	30 94       	mov	r4,9
80004cbc:	0f 3b       	ld.ub	r11,r7++
80004cbe:	08 9c       	mov	r12,r4
80004cc0:	f0 1f 00 14 	mcall	80004d10 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004cc4:	0e 98       	mov	r8,r7
80004cc6:	0a 18       	sub	r8,r5
80004cc8:	ec 08 18 00 	cp.b	r8,r6
80004ccc:	cf 83       	brcs	80004cbc <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004cce:	30 3b       	mov	r11,3
80004cd0:	30 1c       	mov	r12,1
80004cd2:	f0 1f 00 10 	mcall	80004d10 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004cd6:	30 5c       	mov	r12,5
80004cd8:	f0 1f 00 10 	mcall	80004d18 <CalulateCRC+0x88>
80004cdc:	e0 67 00 fe 	mov	r7,254
80004ce0:	30 56       	mov	r6,5
80004ce2:	c0 78       	rjmp	80004cf0 <CalulateCRC+0x60>
80004ce4:	0c 9c       	mov	r12,r6
80004ce6:	f0 1f 00 0d 	mcall	80004d18 <CalulateCRC+0x88>
		i--;
80004cea:	20 17       	sub	r7,1
80004cec:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004cee:	c0 40       	breq	80004cf6 <CalulateCRC+0x66>
80004cf0:	e2 1c 00 04 	andl	r12,0x4,COH
80004cf4:	cf 80       	breq	80004ce4 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004cf6:	32 2c       	mov	r12,34
80004cf8:	f0 1f 00 08 	mcall	80004d18 <CalulateCRC+0x88>
80004cfc:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004cfe:	32 1c       	mov	r12,33
80004d00:	f0 1f 00 06 	mcall	80004d18 <CalulateCRC+0x88>
80004d04:	a6 9c       	st.b	r3[0x1],r12
}
80004d06:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004d0a:	00 00       	add	r0,r0
80004d0c:	80 00       	ld.sh	r0,r0[0x0]
80004d0e:	48 b8       	lddpc	r8,80004d38 <PcdSelect+0x1c>
80004d10:	80 00       	ld.sh	r0,r0[0x0]
80004d12:	47 7c       	lddsp	r12,sp[0x1dc]
80004d14:	80 00       	ld.sh	r0,r0[0x0]
80004d16:	48 74       	lddpc	r4,80004d30 <PcdSelect+0x14>
80004d18:	80 00       	ld.sh	r0,r0[0x0]
80004d1a:	48 34       	lddpc	r4,80004d24 <PcdSelect+0x8>

80004d1c <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004d1c:	eb cd 40 80 	pushm	r7,lr
80004d20:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004d22:	39 38       	mov	r8,-109
80004d24:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004d26:	37 08       	mov	r8,112
80004d28:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004d2a:	30 08       	mov	r8,0
80004d2c:	ba e8       	st.b	sp[0x6],r8
80004d2e:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004d32:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004d36:	19 89       	ld.ub	r9,r12[0x0]
80004d38:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004d3a:	19 3a       	ld.ub	r10,r12++
80004d3c:	1b e9       	ld.ub	r9,sp[0x6]
80004d3e:	f5 e9 20 09 	eor	r9,r10,r9
80004d42:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004d44:	16 38       	cp.w	r8,r11
80004d46:	cf 81       	brne	80004d36 <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004d48:	1a 97       	mov	r7,sp
80004d4a:	fa ca ff f9 	sub	r10,sp,-7
80004d4e:	30 7b       	mov	r11,7
80004d50:	1a 9c       	mov	r12,sp
80004d52:	f0 1f 00 0d 	mcall	80004d84 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004d56:	30 8b       	mov	r11,8
80004d58:	16 9c       	mov	r12,r11
80004d5a:	f0 1f 00 0c 	mcall	80004d88 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004d5e:	fa c8 ff ed 	sub	r8,sp,-19
80004d62:	1a 99       	mov	r9,sp
80004d64:	30 9a       	mov	r10,9
80004d66:	1a 9b       	mov	r11,sp
80004d68:	30 cc       	mov	r12,12
80004d6a:	f0 1f 00 09 	mcall	80004d8c <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80004d6e:	c0 71       	brne	80004d7c <PcdSelect+0x60>
80004d70:	31 88       	mov	r8,24
80004d72:	fb 39 00 13 	ld.ub	r9,sp[19]
80004d76:	f0 09 18 00 	cp.b	r9,r8
80004d7a:	c0 20       	breq	80004d7e <PcdSelect+0x62>
80004d7c:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80004d7e:	2f bd       	sub	sp,-20
80004d80:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d84:	80 00       	ld.sh	r0,r0[0x0]
80004d86:	4c 90       	lddpc	r0,80004ea8 <rfid_sendID_message+0x8>
80004d88:	80 00       	ld.sh	r0,r0[0x0]
80004d8a:	48 b8       	lddpc	r8,80004db4 <rfid_auto_reader+0x24>
80004d8c:	80 00       	ld.sh	r0,r0[0x0]
80004d8e:	4a 30       	lddpc	r0,80004e18 <rfid_auto_reader+0x88>

80004d90 <rfid_auto_reader>:
		
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80004d90:	eb cd 40 80 	pushm	r7,lr
80004d94:	18 97       	mov	r7,r12
	U8 status = MI_ERR;
	
	PcdReset();
80004d96:	f0 1f 00 34 	mcall	80004e64 <rfid_auto_reader+0xd4>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80004d9a:	4b 4b       	lddpc	r11,80004e68 <rfid_auto_reader+0xd8>
80004d9c:	35 2c       	mov	r12,82
80004d9e:	f0 1f 00 34 	mcall	80004e6c <rfid_auto_reader+0xdc>
	if(status!=MI_OK) return;//continue;
80004da2:	c5 e1       	brne	80004e5e <rfid_auto_reader+0xce>
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004da4:	4b 18       	lddpc	r8,80004e68 <rfid_auto_reader+0xd8>
80004da6:	11 88       	ld.ub	r8,r8[0x0]
80004da8:	30 49       	mov	r9,4
80004daa:	f2 08 18 00 	cp.b	r8,r9
80004dae:	c0 b1       	brne	80004dc4 <rfid_auto_reader+0x34>
80004db0:	4a e9       	lddpc	r9,80004e68 <rfid_auto_reader+0xd8>
80004db2:	13 9a       	ld.ub	r10,r9[0x1]
80004db4:	30 09       	mov	r9,0
80004db6:	f2 0a 18 00 	cp.b	r10,r9
80004dba:	c0 51       	brne	80004dc4 <rfid_auto_reader+0x34>
		log("MFOne-S50\n");
80004dbc:	4a dc       	lddpc	r12,80004e70 <rfid_auto_reader+0xe0>
80004dbe:	f0 1f 00 2e 	mcall	80004e74 <rfid_auto_reader+0xe4>
	PcdReset();
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return;//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004dc2:	c3 c8       	rjmp	80004e3a <rfid_auto_reader+0xaa>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004dc4:	30 29       	mov	r9,2
80004dc6:	f2 08 18 00 	cp.b	r8,r9
80004dca:	c0 b1       	brne	80004de0 <rfid_auto_reader+0x50>
80004dcc:	4a 79       	lddpc	r9,80004e68 <rfid_auto_reader+0xd8>
80004dce:	13 9a       	ld.ub	r10,r9[0x1]
80004dd0:	30 09       	mov	r9,0
80004dd2:	f2 0a 18 00 	cp.b	r10,r9
80004dd6:	c0 51       	brne	80004de0 <rfid_auto_reader+0x50>
		log("MFOne-S70\n");
80004dd8:	4a 8c       	lddpc	r12,80004e78 <rfid_auto_reader+0xe8>
80004dda:	f0 1f 00 27 	mcall	80004e74 <rfid_auto_reader+0xe4>
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return;//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004dde:	c2 e8       	rjmp	80004e3a <rfid_auto_reader+0xaa>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004de0:	34 49       	mov	r9,68
80004de2:	f2 08 18 00 	cp.b	r8,r9
80004de6:	c0 b1       	brne	80004dfc <rfid_auto_reader+0x6c>
80004de8:	4a 09       	lddpc	r9,80004e68 <rfid_auto_reader+0xd8>
80004dea:	13 9a       	ld.ub	r10,r9[0x1]
80004dec:	30 09       	mov	r9,0
80004dee:	f2 0a 18 00 	cp.b	r10,r9
80004df2:	c0 51       	brne	80004dfc <rfid_auto_reader+0x6c>
		log("MF-UltraLight\n");
80004df4:	4a 2c       	lddpc	r12,80004e7c <rfid_auto_reader+0xec>
80004df6:	f0 1f 00 20 	mcall	80004e74 <rfid_auto_reader+0xe4>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004dfa:	c2 08       	rjmp	80004e3a <rfid_auto_reader+0xaa>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004dfc:	30 89       	mov	r9,8
80004dfe:	f2 08 18 00 	cp.b	r8,r9
80004e02:	c0 b1       	brne	80004e18 <rfid_auto_reader+0x88>
80004e04:	49 99       	lddpc	r9,80004e68 <rfid_auto_reader+0xd8>
80004e06:	13 9a       	ld.ub	r10,r9[0x1]
80004e08:	30 09       	mov	r9,0
80004e0a:	f2 0a 18 00 	cp.b	r10,r9
80004e0e:	c0 51       	brne	80004e18 <rfid_auto_reader+0x88>
		log("MF-Pro\n");
80004e10:	49 cc       	lddpc	r12,80004e80 <rfid_auto_reader+0xf0>
80004e12:	f0 1f 00 19 	mcall	80004e74 <rfid_auto_reader+0xe4>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004e16:	c1 28       	rjmp	80004e3a <rfid_auto_reader+0xaa>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004e18:	34 49       	mov	r9,68
80004e1a:	f2 08 18 00 	cp.b	r8,r9
80004e1e:	c0 b1       	brne	80004e34 <rfid_auto_reader+0xa4>
80004e20:	49 28       	lddpc	r8,80004e68 <rfid_auto_reader+0xd8>
80004e22:	11 99       	ld.ub	r9,r8[0x1]
80004e24:	30 38       	mov	r8,3
80004e26:	f0 09 18 00 	cp.b	r9,r8
80004e2a:	c0 51       	brne	80004e34 <rfid_auto_reader+0xa4>
		log("MF Desire\n");
80004e2c:	49 6c       	lddpc	r12,80004e84 <rfid_auto_reader+0xf4>
80004e2e:	f0 1f 00 12 	mcall	80004e74 <rfid_auto_reader+0xe4>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004e32:	c0 48       	rjmp	80004e3a <rfid_auto_reader+0xaa>
		log("MF Desire\n");
	else
		log("Unknown\n");
80004e34:	49 5c       	lddpc	r12,80004e88 <rfid_auto_reader+0xf8>
80004e36:	f0 1f 00 10 	mcall	80004e74 <rfid_auto_reader+0xe4>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80004e3a:	49 5c       	lddpc	r12,80004e8c <rfid_auto_reader+0xfc>
80004e3c:	f0 1f 00 15 	mcall	80004e90 <rfid_auto_reader+0x100>
	if(status!=MI_OK)return;//continue;
80004e40:	c0 f1       	brne	80004e5e <rfid_auto_reader+0xce>
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80004e42:	49 3c       	lddpc	r12,80004e8c <rfid_auto_reader+0xfc>
80004e44:	f0 1f 00 14 	mcall	80004e94 <rfid_auto_reader+0x104>
	if(status!=MI_OK)return;//continue;
80004e48:	c0 b1       	brne	80004e5e <rfid_auto_reader+0xce>
	else{//℃
			
		memcpy(card_id, SN, 4);
80004e4a:	30 4a       	mov	r10,4
80004e4c:	49 0b       	lddpc	r11,80004e8c <rfid_auto_reader+0xfc>
80004e4e:	0e 9c       	mov	r12,r7
80004e50:	f0 1f 00 12 	mcall	80004e98 <rfid_auto_reader+0x108>
		log("select okay\n");
80004e54:	49 2c       	lddpc	r12,80004e9c <rfid_auto_reader+0x10c>
80004e56:	f0 1f 00 08 	mcall	80004e74 <rfid_auto_reader+0xe4>
		return status;	
	}
	
//}
	
}
80004e5a:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
80004e5e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004e62:	00 00       	add	r0,r0
80004e64:	80 00       	ld.sh	r0,r0[0x0]
80004e66:	47 b4       	lddsp	r4,sp[0x1ec]
80004e68:	00 00       	add	r0,r0
80004e6a:	0d 90       	ld.ub	r0,r6[0x1]
80004e6c:	80 00       	ld.sh	r0,r0[0x0]
80004e6e:	4c 2c       	lddpc	r12,80004f74 <rfid_sendID_message+0xd4>
80004e70:	80 00       	ld.sh	r0,r0[0x0]
80004e72:	d1 80       	acall	0x18
80004e74:	80 00       	ld.sh	r0,r0[0x0]
80004e76:	69 a0       	ld.w	r0,r4[0x68]
80004e78:	80 00       	ld.sh	r0,r0[0x0]
80004e7a:	d1 8c       	*unknown*
80004e7c:	80 00       	ld.sh	r0,r0[0x0]
80004e7e:	d1 98       	*unknown*
80004e80:	80 00       	ld.sh	r0,r0[0x0]
80004e82:	d1 a8       	*unknown*
80004e84:	80 00       	ld.sh	r0,r0[0x0]
80004e86:	d1 b0       	acall	0x1b
80004e88:	80 00       	ld.sh	r0,r0[0x0]
80004e8a:	d1 bc       	*unknown*
80004e8c:	00 00       	add	r0,r0
80004e8e:	0d 94       	ld.ub	r4,r6[0x1]
80004e90:	80 00       	ld.sh	r0,r0[0x0]
80004e92:	4b a8       	lddpc	r8,80004f78 <rfid_sendID_message+0xd8>
80004e94:	80 00       	ld.sh	r0,r0[0x0]
80004e96:	4d 1c       	lddpc	r12,80004fd8 <rfid_sendID_message+0x138>
80004e98:	80 00       	ld.sh	r0,r0[0x0]
80004e9a:	72 34       	ld.w	r4,r9[0xc]
80004e9c:	80 00       	ld.sh	r0,r0[0x0]
80004e9e:	d1 c8       	*unknown*

80004ea0 <rfid_sendID_message>:


U8 rfid_sendID_message()
{
80004ea0:	eb cd 40 e0 	pushm	r5-r7,lr
80004ea4:	21 ed       	sub	sp,120
	U8 temp =0;
	U8 destination = DEST;
	static U8 start_session = 0x80;
	Message_Header_t header;
	
	memset(data_buffer, 0x00, 16);
80004ea6:	fa ca ff a4 	sub	r10,sp,-92
80004eaa:	30 08       	mov	r8,0
80004eac:	30 09       	mov	r9,0
80004eae:	f4 e9 00 00 	st.d	r10[0],r8
80004eb2:	f4 e9 00 08 	st.d	r10[8],r8
	memset(SN, 0x00, 10);
80004eb6:	fa cc ff 94 	sub	r12,sp,-108
80004eba:	f8 e9 00 00 	st.d	r12[0],r8
80004ebe:	30 0a       	mov	r10,0
80004ec0:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80004ec2:	fa e9 00 0c 	st.d	sp[12],r8
80004ec6:	fa e9 00 14 	st.d	sp[20],r8
80004eca:	fa e9 00 1c 	st.d	sp[28],r8
80004ece:	fa e9 00 24 	st.d	sp[36],r8
80004ed2:	fa e9 00 2c 	st.d	sp[44],r8
80004ed6:	fa e9 00 34 	st.d	sp[52],r8
80004eda:	fa e9 00 3c 	st.d	sp[60],r8
80004ede:	fa e9 00 44 	st.d	sp[68],r8
80004ee2:	fa e9 00 4c 	st.d	sp[76],r8
80004ee6:	fa e9 00 54 	st.d	sp[84],r8

	return_err = rfid_auto_reader(SN);
80004eea:	f0 1f 00 3c 	mcall	80004fd8 <rfid_sendID_message+0x138>
80004eee:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80004ef0:	c6 d1       	brne	80004fca <rfid_sendID_message+0x12a>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80004ef2:	fb 38 00 6f 	ld.ub	r8,sp[111]
80004ef6:	1a d8       	st.w	--sp,r8
80004ef8:	fb 38 00 72 	ld.ub	r8,sp[114]
80004efc:	1a d8       	st.w	--sp,r8
80004efe:	fb 38 00 75 	ld.ub	r8,sp[117]
80004f02:	1a d8       	st.w	--sp,r8
80004f04:	fb 38 00 78 	ld.ub	r8,sp[120]
80004f08:	1a d8       	st.w	--sp,r8
80004f0a:	4b 5c       	lddpc	r12,80004fdc <rfid_sendID_message+0x13c>
80004f0c:	f0 1f 00 35 	mcall	80004fe0 <rfid_sendID_message+0x140>
		
		xcmp_IdleTestTone(Accessory_Connected);//set tone to noticy okay!!!
80004f10:	33 7c       	mov	r12,55
80004f12:	f0 1f 00 35 	mcall	80004fe4 <rfid_sendID_message+0x144>
80004f16:	fa c9 ff 84 	sub	r9,sp,-124
80004f1a:	fa c8 ff 94 	sub	r8,sp,-108
80004f1e:	fa ca ff 92 	sub	r10,sp,-110
//}
	
}


U8 rfid_sendID_message()
80004f22:	fa c5 ff 80 	sub	r5,sp,-128
80004f26:	2f cd       	sub	sp,-16
		xcmp_IdleTestTone(Accessory_Connected);//set tone to noticy okay!!!
		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer[i*4] = temp+0x30;
80004f28:	30 9e       	mov	lr,9
			 else 
				data_buffer[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer[i*4+1] = 0x00; 
80004f2a:	30 06       	mov	r6,0
		
		xcmp_IdleTestTone(Accessory_Connected);//set tone to noticy okay!!!
		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80004f2c:	13 8b       	ld.ub	r11,r9[0x0]
80004f2e:	f6 0c 16 04 	lsr	r12,r11,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer[i*4] = temp+0x30;
80004f32:	fc 0c 18 00 	cp.b	r12,lr
80004f36:	f7 bc 08 d0 	subls	r12,-48
80004f3a:	f1 fc 8e 00 	st.bls	r8[0x0],r12
			 else 
				data_buffer[i*4] = ((temp - 0x0a)+0x61);
80004f3e:	f7 bc 0b a9 	subhi	r12,-87
80004f42:	f1 fc be 00 	st.bhi	r8[0x0],r12
			
			 data_buffer[i*4+1] = 0x00; 
80004f46:	b0 96       	st.b	r8[0x1],r6
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
80004f48:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer[i*4+2] = temp+0x30;
80004f4c:	fc 0b 18 00 	cp.b	r11,lr
80004f50:	f7 bb 08 d0 	subls	r11,-48
80004f54:	f5 fb 8e 00 	st.bls	r10[0x0],r11
			 else
				data_buffer[i*4+2] = ((temp - 0x0a)+0x61);
80004f58:	f7 bb 0b a9 	subhi	r11,-87
80004f5c:	f5 fb be 00 	st.bhi	r10[0x0],r11

		 
			 data_buffer[i*4+3] = 0x00; 
80004f60:	b0 b6       	st.b	r8[0x3],r6
80004f62:	2f f9       	sub	r9,-1
80004f64:	2f c8       	sub	r8,-4
80004f66:	2f ca       	sub	r10,-4
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		
		xcmp_IdleTestTone(Accessory_Connected);//set tone to noticy okay!!!
		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
80004f68:	0a 39       	cp.w	r9,r5
80004f6a:	ce 11       	brne	80004f2c <rfid_sendID_message+0x8c>
			 data_buffer[i*4+3] = 0x00; 
		}
	
		header.length = (0x0008 + sizeof(data_buffer));
	
		if(start_session > 0x9f)start_session = 0x80;
80004f6c:	49 f8       	lddpc	r8,80004fe8 <rfid_sendID_message+0x148>
80004f6e:	11 89       	ld.ub	r9,r8[0x0]
80004f70:	39 f8       	mov	r8,-97
80004f72:	f0 09 18 00 	cp.b	r9,r8
80004f76:	e0 88 00 05 	brls	80004f80 <rfid_sendID_message+0xe0>
80004f7a:	38 09       	mov	r9,-128
80004f7c:	49 b8       	lddpc	r8,80004fe8 <rfid_sendID_message+0x148>
80004f7e:	b0 89       	st.b	r8[0x0],r9
	
		header.session_id = (++start_session);
80004f80:	49 a8       	lddpc	r8,80004fe8 <rfid_sendID_message+0x148>
80004f82:	11 86       	ld.ub	r6,r8[0x0]
80004f84:	2f f6       	sub	r6,-1
80004f86:	b0 86       	st.b	r8[0x0],r6
	
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
80004f88:	30 5a       	mov	r10,5
80004f8a:	49 9b       	lddpc	r11,80004fec <rfid_sendID_message+0x14c>
80004f8c:	fa cc ff f9 	sub	r12,sp,-7
80004f90:	f0 1f 00 18 	mcall	80004ff0 <rfid_sendID_message+0x150>
		header.type = 0xe000;
	
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
80004f94:	31 88       	mov	r8,24
80004f96:	ba 18       	st.h	sp[0x2],r8
80004f98:	ba e6       	st.b	sp[0x6],r6
80004f9a:	fe 78 e0 00 	mov	r8,-8192
80004f9e:	ba 28       	st.h	sp[0x4],r8
80004fa0:	fa c6 ff f4 	sub	r6,sp,-12
80004fa4:	30 aa       	mov	r10,10
80004fa6:	fa cb ff fe 	sub	r11,sp,-2
80004faa:	0c 9c       	mov	r12,r6
80004fac:	f0 1f 00 11 	mcall	80004ff0 <rfid_sendID_message+0x150>
		memcpy(&message[sizeof(Message_Header_t)], data_buffer, sizeof(data_buffer));//疯淇″瀹规版
80004fb0:	31 0a       	mov	r10,16
80004fb2:	fa cb ff a4 	sub	r11,sp,-92
80004fb6:	fa cc ff ea 	sub	r12,sp,-22
80004fba:	f0 1f 00 0e 	mcall	80004ff0 <rfid_sendID_message+0x150>
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(data_buffer)), destination);
80004fbe:	30 9a       	mov	r10,9
80004fc0:	31 ab       	mov	r11,26
80004fc2:	0c 9c       	mov	r12,r6
80004fc4:	f0 1f 00 0c 	mcall	80004ff4 <rfid_sendID_message+0x154>
80004fc8:	c0 48       	rjmp	80004fd0 <rfid_sendID_message+0x130>
		
	}
	else
	{
		log("no card find...\n");
80004fca:	48 cc       	lddpc	r12,80004ff8 <rfid_sendID_message+0x158>
80004fcc:	f0 1f 00 05 	mcall	80004fe0 <rfid_sendID_message+0x140>
	}
	
	return return_err;
	
}
80004fd0:	0e 9c       	mov	r12,r7
80004fd2:	2e 2d       	sub	sp,-120
80004fd4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004fd8:	80 00       	ld.sh	r0,r0[0x0]
80004fda:	4d 90       	lddpc	r0,8000513c <gpio_set_gpio_pin+0x10>
80004fdc:	80 00       	ld.sh	r0,r0[0x0]
80004fde:	d1 d8       	*unknown*
80004fe0:	80 00       	ld.sh	r0,r0[0x0]
80004fe2:	69 a0       	ld.w	r0,r4[0x68]
80004fe4:	80 00       	ld.sh	r0,r0[0x0]
80004fe6:	3e 74       	mov	r4,-25
80004fe8:	00 00       	add	r0,r0
80004fea:	05 2c       	ld.uh	r12,r2++
80004fec:	00 00       	add	r0,r0
80004fee:	05 24       	ld.uh	r4,r2++
80004ff0:	80 00       	ld.sh	r0,r0[0x0]
80004ff2:	72 34       	ld.w	r4,r9[0xc]
80004ff4:	80 00       	ld.sh	r0,r0[0x0]
80004ff6:	3d 3c       	mov	r12,-45
80004ff8:	80 00       	ld.sh	r0,r0[0x0]
80004ffa:	d1 f4       	*unknown*

80004ffc <rfid_init>:
#include "RFID.h"
U8 unsure_data[5]={0x04, 0x0d, 0x00, 0x0a, 0x00};


void rfid_init()
{
80004ffc:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
80004ffe:	f0 1f 00 02 	mcall	80005004 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%X, 0x%X, 0x%X, 0x%X\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		
}
80005002:	d8 02       	popm	pc
80005004:	80 00       	ld.sh	r0,r0[0x0]
80005006:	49 60       	lddpc	r0,8000505c <local_start_timer+0x4>

80005008 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80005008:	fe 78 0c 00 	mov	r8,-62464
8000500c:	e0 69 03 07 	mov	r9,775
80005010:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80005012:	30 49       	mov	r9,4
80005014:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80005016:	71 59       	ld.w	r9,r8[0x54]
80005018:	e2 19 00 80 	andl	r9,0x80,COH
8000501c:	cf d0       	breq	80005016 <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
8000501e:	fe 78 0c 00 	mov	r8,-62464
80005022:	30 59       	mov	r9,5
80005024:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80005026:	e0 69 01 0d 	mov	r9,269
8000502a:	ea 19 10 07 	orh	r9,0x1007
8000502e:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80005030:	71 59       	ld.w	r9,r8[0x54]
80005032:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80005036:	cf d0       	breq	80005030 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80005038:	fe 78 0c 00 	mov	r8,-62464
8000503c:	fc 19 00 80 	movh	r9,0x80
80005040:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80005042:	34 0a       	mov	r10,64
80005044:	fe 69 14 00 	mov	r9,-125952
80005048:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
8000504a:	30 69       	mov	r9,6
8000504c:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
8000504e:	30 19       	mov	r9,1
80005050:	fe 68 10 00 	mov	r8,-126976
80005054:	91 19       	st.w	r8[0x4],r9
}
80005056:	5e fc       	retal	r12

80005058 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80005058:	fe 78 10 00 	mov	r8,-61440
8000505c:	fc 19 00 10 	movh	r9,0x10
80005060:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
80005062:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80005064:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
80005066:	30 39       	mov	r9,3
80005068:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
8000506c:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80005070:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
80005074:	fe 78 38 00 	mov	r8,-51200
80005078:	30 49       	mov	r9,4
8000507a:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
8000507e:	e0 69 91 0d 	mov	r9,37133
80005082:	ea 19 00 52 	orh	r9,0x52
80005086:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005088:	32 09       	mov	r9,32
8000508a:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
8000508c:	30 59       	mov	r9,5
8000508e:	91 09       	st.w	r8[0x0],r9
}
80005090:	5e fc       	retal	r12

80005092 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005092:	f8 08 16 05 	lsr	r8,r12,0x5
80005096:	a9 68       	lsl	r8,0x8
80005098:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
8000509c:	58 1b       	cp.w	r11,1
8000509e:	c0 d0       	breq	800050b8 <gpio_enable_module_pin+0x26>
800050a0:	c0 63       	brcs	800050ac <gpio_enable_module_pin+0x1a>
800050a2:	58 2b       	cp.w	r11,2
800050a4:	c1 00       	breq	800050c4 <gpio_enable_module_pin+0x32>
800050a6:	58 3b       	cp.w	r11,3
800050a8:	c1 40       	breq	800050d0 <gpio_enable_module_pin+0x3e>
800050aa:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800050ac:	30 19       	mov	r9,1
800050ae:	f2 0c 09 49 	lsl	r9,r9,r12
800050b2:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800050b4:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800050b6:	c1 28       	rjmp	800050da <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800050b8:	30 19       	mov	r9,1
800050ba:	f2 0c 09 49 	lsl	r9,r9,r12
800050be:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800050c0:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800050c2:	c0 c8       	rjmp	800050da <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800050c4:	30 19       	mov	r9,1
800050c6:	f2 0c 09 49 	lsl	r9,r9,r12
800050ca:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800050cc:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800050ce:	c0 68       	rjmp	800050da <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800050d0:	30 19       	mov	r9,1
800050d2:	f2 0c 09 49 	lsl	r9,r9,r12
800050d6:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800050d8:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800050da:	30 19       	mov	r9,1
800050dc:	f2 0c 09 4c 	lsl	r12,r9,r12
800050e0:	91 2c       	st.w	r8[0x8],r12
800050e2:	5e fd       	retal	0

800050e4 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800050e4:	d4 21       	pushm	r4-r7,lr
800050e6:	18 97       	mov	r7,r12
800050e8:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800050ea:	58 0b       	cp.w	r11,0
800050ec:	c0 31       	brne	800050f2 <gpio_enable_module+0xe>
800050ee:	30 05       	mov	r5,0
800050f0:	c0 d8       	rjmp	8000510a <gpio_enable_module+0x26>
800050f2:	30 06       	mov	r6,0
800050f4:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800050f6:	6e 1b       	ld.w	r11,r7[0x4]
800050f8:	6e 0c       	ld.w	r12,r7[0x0]
800050fa:	f0 1f 00 06 	mcall	80005110 <gpio_enable_module+0x2c>
800050fe:	18 45       	or	r5,r12
		gpiomap++;
80005100:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005102:	2f f6       	sub	r6,-1
80005104:	0c 34       	cp.w	r4,r6
80005106:	fe 9b ff f8 	brhi	800050f6 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000510a:	0a 9c       	mov	r12,r5
8000510c:	d8 22       	popm	r4-r7,pc
8000510e:	00 00       	add	r0,r0
80005110:	80 00       	ld.sh	r0,r0[0x0]
80005112:	50 92       	stdsp	sp[0x24],r2

80005114 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005114:	f8 08 16 05 	lsr	r8,r12,0x5
80005118:	a9 68       	lsl	r8,0x8
8000511a:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
8000511e:	30 19       	mov	r9,1
80005120:	f2 0c 09 4c 	lsl	r12,r9,r12
80005124:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80005128:	91 1c       	st.w	r8[0x4],r12
}
8000512a:	5e fc       	retal	r12

8000512c <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000512c:	f8 08 16 05 	lsr	r8,r12,0x5
80005130:	a9 68       	lsl	r8,0x8
80005132:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80005136:	30 19       	mov	r9,1
80005138:	f2 0c 09 4c 	lsl	r12,r9,r12
8000513c:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80005140:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005144:	91 1c       	st.w	r8[0x4],r12
}
80005146:	5e fc       	retal	r12

80005148 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005148:	f8 08 16 05 	lsr	r8,r12,0x5
8000514c:	a9 68       	lsl	r8,0x8
8000514e:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80005152:	30 19       	mov	r9,1
80005154:	f2 0c 09 4c 	lsl	r12,r9,r12
80005158:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
8000515c:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005160:	91 1c       	st.w	r8[0x4],r12
}
80005162:	5e fc       	retal	r12

80005164 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80005164:	c0 08       	rjmp	80005164 <_unhandled_interrupt>
80005166:	d7 03       	nop

80005168 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005168:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
8000516c:	49 99       	lddpc	r9,800051d0 <INTC_register_interrupt+0x68>
8000516e:	f2 08 00 39 	add	r9,r9,r8<<0x3
80005172:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80005176:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80005178:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
8000517c:	58 0a       	cp.w	r10,0
8000517e:	c0 91       	brne	80005190 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005180:	49 59       	lddpc	r9,800051d4 <INTC_register_interrupt+0x6c>
80005182:	49 6a       	lddpc	r10,800051d8 <INTC_register_interrupt+0x70>
80005184:	12 1a       	sub	r10,r9
80005186:	fe 79 08 00 	mov	r9,-63488
8000518a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000518e:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005190:	58 1a       	cp.w	r10,1
80005192:	c0 a1       	brne	800051a6 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80005194:	49 09       	lddpc	r9,800051d4 <INTC_register_interrupt+0x6c>
80005196:	49 2a       	lddpc	r10,800051dc <INTC_register_interrupt+0x74>
80005198:	12 1a       	sub	r10,r9
8000519a:	bf aa       	sbr	r10,0x1e
8000519c:	fe 79 08 00 	mov	r9,-63488
800051a0:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800051a4:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800051a6:	58 2a       	cp.w	r10,2
800051a8:	c0 a1       	brne	800051bc <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800051aa:	48 b9       	lddpc	r9,800051d4 <INTC_register_interrupt+0x6c>
800051ac:	48 da       	lddpc	r10,800051e0 <INTC_register_interrupt+0x78>
800051ae:	12 1a       	sub	r10,r9
800051b0:	bf ba       	sbr	r10,0x1f
800051b2:	fe 79 08 00 	mov	r9,-63488
800051b6:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800051ba:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800051bc:	48 69       	lddpc	r9,800051d4 <INTC_register_interrupt+0x6c>
800051be:	48 aa       	lddpc	r10,800051e4 <INTC_register_interrupt+0x7c>
800051c0:	12 1a       	sub	r10,r9
800051c2:	ea 1a c0 00 	orh	r10,0xc000
800051c6:	fe 79 08 00 	mov	r9,-63488
800051ca:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800051ce:	5e fc       	retal	r12
800051d0:	80 00       	ld.sh	r0,r0[0x0]
800051d2:	d2 08       	*unknown*
800051d4:	80 00       	ld.sh	r0,r0[0x0]
800051d6:	c8 00       	breq	800050d6 <gpio_enable_module_pin+0x44>
800051d8:	80 00       	ld.sh	r0,r0[0x0]
800051da:	c9 04       	brge	800050fa <gpio_enable_module+0x16>
800051dc:	80 00       	ld.sh	r0,r0[0x0]
800051de:	c9 12       	brcc	80005100 <gpio_enable_module+0x1c>
800051e0:	80 00       	ld.sh	r0,r0[0x0]
800051e2:	c9 20       	breq	80005106 <gpio_enable_module+0x22>
800051e4:	80 00       	ld.sh	r0,r0[0x0]
800051e6:	c9 2e       	rcall	80004f0a <rfid_sendID_message+0x6a>

800051e8 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800051e8:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800051ea:	49 18       	lddpc	r8,8000522c <INTC_init_interrupts+0x44>
800051ec:	e3 b8 00 01 	mtsr	0x4,r8
800051f0:	49 0e       	lddpc	lr,80005230 <INTC_init_interrupts+0x48>
800051f2:	30 07       	mov	r7,0
800051f4:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800051f6:	49 0c       	lddpc	r12,80005234 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800051f8:	49 05       	lddpc	r5,80005238 <INTC_init_interrupts+0x50>
800051fa:	10 15       	sub	r5,r8
800051fc:	fe 76 08 00 	mov	r6,-63488
80005200:	c1 08       	rjmp	80005220 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005202:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80005204:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005206:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005208:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
8000520c:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000520e:	10 3a       	cp.w	r10,r8
80005210:	fe 9b ff fc 	brhi	80005208 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005214:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80005218:	2f f7       	sub	r7,-1
8000521a:	2f 8e       	sub	lr,-8
8000521c:	59 37       	cp.w	r7,19
8000521e:	c0 50       	breq	80005228 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005220:	7c 08       	ld.w	r8,lr[0x0]
80005222:	58 08       	cp.w	r8,0
80005224:	ce f1       	brne	80005202 <INTC_init_interrupts+0x1a>
80005226:	cf 7b       	rjmp	80005214 <INTC_init_interrupts+0x2c>
80005228:	d8 22       	popm	r4-r7,pc
8000522a:	00 00       	add	r0,r0
8000522c:	80 00       	ld.sh	r0,r0[0x0]
8000522e:	c8 00       	breq	8000512e <gpio_set_gpio_pin+0x2>
80005230:	80 00       	ld.sh	r0,r0[0x0]
80005232:	d2 08       	*unknown*
80005234:	80 00       	ld.sh	r0,r0[0x0]
80005236:	51 64       	stdsp	sp[0x58],r4
80005238:	80 00       	ld.sh	r0,r0[0x0]
8000523a:	c9 04       	brge	8000515a <gpio_clr_gpio_pin+0x12>

8000523c <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
8000523c:	fe 78 08 00 	mov	r8,-63488
80005240:	e0 69 00 83 	mov	r9,131
80005244:	f2 0c 01 0c 	sub	r12,r9,r12
80005248:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
8000524c:	f2 ca ff c0 	sub	r10,r9,-64
80005250:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005254:	58 08       	cp.w	r8,0
80005256:	c0 21       	brne	8000525a <_get_interrupt_handler+0x1e>
80005258:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000525a:	f0 08 12 00 	clz	r8,r8
8000525e:	48 5a       	lddpc	r10,80005270 <_get_interrupt_handler+0x34>
80005260:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005264:	f0 08 11 1f 	rsub	r8,r8,31
80005268:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000526a:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000526e:	5e fc       	retal	r12
80005270:	80 00       	ld.sh	r0,r0[0x0]
80005272:	d2 08       	*unknown*

80005274 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80005274:	f8 c8 00 01 	sub	r8,r12,1
80005278:	f0 0b 00 0b 	add	r11,r8,r11
8000527c:	f6 0c 0d 0a 	divu	r10,r11,r12
80005280:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80005282:	f4 c8 00 01 	sub	r8,r10,1
80005286:	e0 48 00 fe 	cp.w	r8,254
8000528a:	e0 88 00 03 	brls	80005290 <getBaudDiv+0x1c>
8000528e:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80005290:	5c 8c       	casts.h	r12
}
80005292:	5e fc       	retal	r12

80005294 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80005294:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005298:	30 18       	mov	r8,1
8000529a:	f0 09 18 00 	cp.b	r9,r8
8000529e:	e0 88 00 04 	brls	800052a6 <spi_initMaster+0x12>
800052a2:	30 2c       	mov	r12,2
800052a4:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800052a6:	e0 68 00 80 	mov	r8,128
800052aa:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
800052ac:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
800052ae:	30 19       	mov	r9,1
800052b0:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800052b4:	f7 39 00 0d 	ld.ub	r9,r11[13]
800052b8:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
800052bc:	30 09       	mov	r9,0
800052be:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800052c2:	30 fa       	mov	r10,15
800052c4:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
800052c8:	99 18       	st.w	r12[0x4],r8
800052ca:	5e f9       	retal	r9

800052cc <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800052cc:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
800052ce:	30 18       	mov	r8,1
800052d0:	f0 0b 18 00 	cp.b	r11,r8
800052d4:	5f be       	srhi	lr
800052d6:	f0 0a 18 00 	cp.b	r10,r8
800052da:	5f b8       	srhi	r8
800052dc:	fd e8 10 08 	or	r8,lr,r8
800052e0:	c0 30       	breq	800052e6 <spi_selectionMode+0x1a>
800052e2:	30 2c       	mov	r12,2
800052e4:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
800052e6:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
800052e8:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
800052ec:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
800052f0:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
800052f4:	99 18       	st.w	r12[0x4],r8
800052f6:	d8 0a       	popm	pc,r12=0

800052f8 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
800052f8:	30 18       	mov	r8,1
800052fa:	99 08       	st.w	r12[0x0],r8
}
800052fc:	5e fc       	retal	r12

800052fe <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
800052fe:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005302:	c0 58       	rjmp	8000530c <spi_write+0xe>
		if (!timeout--) {
80005304:	58 08       	cp.w	r8,0
80005306:	c0 21       	brne	8000530a <spi_write+0xc>
80005308:	5e ff       	retal	1
8000530a:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000530c:	78 49       	ld.w	r9,r12[0x10]
8000530e:	e2 19 00 02 	andl	r9,0x2,COH
80005312:	cf 90       	breq	80005304 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005314:	5c 7b       	castu.h	r11
80005316:	99 3b       	st.w	r12[0xc],r11
80005318:	5e fd       	retal	0

8000531a <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
8000531a:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
8000531e:	c0 58       	rjmp	80005328 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80005320:	58 08       	cp.w	r8,0
80005322:	c0 21       	brne	80005326 <spi_read+0xc>
80005324:	5e ff       	retal	1
80005326:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005328:	78 49       	ld.w	r9,r12[0x10]
8000532a:	e2 19 02 01 	andl	r9,0x201,COH
8000532e:	e0 49 02 01 	cp.w	r9,513
80005332:	cf 71       	brne	80005320 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005334:	78 28       	ld.w	r8,r12[0x8]
80005336:	b6 08       	st.h	r11[0x0],r8
80005338:	5e fd       	retal	0
8000533a:	d7 03       	nop

8000533c <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
8000533c:	eb cd 40 f8 	pushm	r3-r7,lr
80005340:	18 95       	mov	r5,r12
80005342:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005344:	f7 36 00 0c 	ld.ub	r6,r11[12]
80005348:	30 38       	mov	r8,3
8000534a:	f0 06 18 00 	cp.b	r6,r8
8000534e:	e0 8b 00 5e 	brhi	8000540a <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
80005352:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005356:	30 18       	mov	r8,1
80005358:	f0 04 18 00 	cp.b	r4,r8
8000535c:	e0 8b 00 57 	brhi	8000540a <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80005360:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005364:	30 78       	mov	r8,7
80005366:	f0 03 18 00 	cp.b	r3,r8
8000536a:	e0 88 00 50 	brls	8000540a <spi_setupChipReg+0xce>
8000536e:	31 08       	mov	r8,16
80005370:	f0 03 18 00 	cp.b	r3,r8
80005374:	e0 8b 00 4b 	brhi	8000540a <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80005378:	14 9b       	mov	r11,r10
8000537a:	6e 1c       	ld.w	r12,r7[0x4]
8000537c:	f0 1f 00 26 	mcall	80005414 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
80005380:	c4 55       	brlt	8000540a <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80005382:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80005384:	ec 09 16 01 	lsr	r9,r6,0x1
80005388:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
8000538c:	ec 16 00 01 	eorl	r6,0x1
80005390:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80005394:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80005398:	20 83       	sub	r3,8
8000539a:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
8000539e:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
800053a2:	ef 39 00 09 	ld.ub	r9,r7[9]
800053a6:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
800053aa:	ef 39 00 0a 	ld.ub	r9,r7[10]
800053ae:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
800053b2:	0f 89       	ld.ub	r9,r7[0x0]
800053b4:	30 1a       	mov	r10,1
800053b6:	f4 09 18 00 	cp.b	r9,r10
800053ba:	c0 d0       	breq	800053d4 <spi_setupChipReg+0x98>
800053bc:	c0 a3       	brcs	800053d0 <spi_setupChipReg+0x94>
800053be:	30 2a       	mov	r10,2
800053c0:	f4 09 18 00 	cp.b	r9,r10
800053c4:	c0 a0       	breq	800053d8 <spi_setupChipReg+0x9c>
800053c6:	30 3a       	mov	r10,3
800053c8:	f4 09 18 00 	cp.b	r9,r10
800053cc:	c1 f1       	brne	8000540a <spi_setupChipReg+0xce>
800053ce:	c0 78       	rjmp	800053dc <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
800053d0:	8b c8       	st.w	r5[0x30],r8
		break;
800053d2:	c0 68       	rjmp	800053de <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
800053d4:	8b d8       	st.w	r5[0x34],r8
		break;
800053d6:	c0 48       	rjmp	800053de <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
800053d8:	8b e8       	st.w	r5[0x38],r8
		break;
800053da:	c0 28       	rjmp	800053de <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
800053dc:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
800053de:	48 f8       	lddpc	r8,80005418 <spi_setupChipReg+0xdc>
800053e0:	70 08       	ld.w	r8,r8[0x0]
800053e2:	58 08       	cp.w	r8,0
800053e4:	c1 61       	brne	80005410 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
800053e6:	30 0b       	mov	r11,0
800053e8:	30 1c       	mov	r12,1
800053ea:	f0 1f 00 0d 	mcall	8000541c <spi_setupChipReg+0xe0>
800053ee:	48 b8       	lddpc	r8,80005418 <spi_setupChipReg+0xdc>
800053f0:	91 0c       	st.w	r8[0x0],r12
800053f2:	58 0c       	cp.w	r12,0
800053f4:	c0 a0       	breq	80005408 <spi_setupChipReg+0xcc>
800053f6:	30 09       	mov	r9,0
800053f8:	12 9a       	mov	r10,r9
800053fa:	12 9b       	mov	r11,r9
800053fc:	f0 1f 00 09 	mcall	80005420 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80005400:	48 68       	lddpc	r8,80005418 <spi_setupChipReg+0xdc>
80005402:	70 08       	ld.w	r8,r8[0x0]
80005404:	58 08       	cp.w	r8,0
80005406:	c0 51       	brne	80005410 <spi_setupChipReg+0xd4>
80005408:	c0 08       	rjmp	80005408 <spi_setupChipReg+0xcc>
8000540a:	30 2c       	mov	r12,2
8000540c:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005410:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005414:	80 00       	ld.sh	r0,r0[0x0]
80005416:	52 74       	stdsp	sp[0x9c],r4
80005418:	00 00       	add	r0,r0
8000541a:	51 10       	stdsp	sp[0x44],r0
8000541c:	80 00       	ld.sh	r0,r0[0x0]
8000541e:	5f 08       	sreq	r8
80005420:	80 00       	ld.sh	r0,r0[0x0]
80005422:	5e 08       	reteq	r8

80005424 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005424:	d4 01       	pushm	lr
80005426:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000542a:	c0 58       	rjmp	80005434 <spi_unselectChip+0x10>
		if (!timeout--) {
8000542c:	58 08       	cp.w	r8,0
8000542e:	c0 21       	brne	80005432 <spi_unselectChip+0xe>
80005430:	da 0a       	popm	pc,r12=1
80005432:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005434:	78 49       	ld.w	r9,r12[0x10]
80005436:	e2 19 02 00 	andl	r9,0x200,COH
8000543a:	cf 90       	breq	8000542c <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
8000543c:	78 18       	ld.w	r8,r12[0x4]
8000543e:	ea 18 00 0f 	orh	r8,0xf
80005442:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80005444:	fc 18 01 00 	movh	r8,0x100
80005448:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
8000544a:	30 09       	mov	r9,0
8000544c:	12 9a       	mov	r10,r9
8000544e:	12 9b       	mov	r11,r9
80005450:	48 38       	lddpc	r8,8000545c <spi_unselectChip+0x38>
80005452:	70 0c       	ld.w	r12,r8[0x0]
80005454:	f0 1f 00 03 	mcall	80005460 <spi_unselectChip+0x3c>
80005458:	d8 0a       	popm	pc,r12=0
8000545a:	00 00       	add	r0,r0
8000545c:	00 00       	add	r0,r0
8000545e:	51 10       	stdsp	sp[0x44],r0
80005460:	80 00       	ld.sh	r0,r0[0x0]
80005462:	5e 08       	reteq	r8

80005464 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005464:	eb cd 40 f8 	pushm	r3-r7,lr
80005468:	18 94       	mov	r4,r12
8000546a:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
8000546c:	49 a6       	lddpc	r6,800054d4 <spi_selectChip+0x70>
8000546e:	30 07       	mov	r7,0
80005470:	31 45       	mov	r5,20
80005472:	0e 99       	mov	r9,r7
80005474:	0a 9a       	mov	r10,r5
80005476:	0e 9b       	mov	r11,r7
80005478:	6c 0c       	ld.w	r12,r6[0x0]
8000547a:	f0 1f 00 18 	mcall	800054d8 <spi_selectChip+0x74>
8000547e:	cf a0       	breq	80005472 <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005480:	68 18       	ld.w	r8,r4[0x4]
80005482:	ea 18 00 0f 	orh	r8,0xf
80005486:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005488:	68 18       	ld.w	r8,r4[0x4]
8000548a:	e2 18 00 04 	andl	r8,0x4,COH
8000548e:	c1 10       	breq	800054b0 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80005490:	30 e8       	mov	r8,14
80005492:	f0 03 18 00 	cp.b	r3,r8
80005496:	e0 8b 00 1c 	brhi	800054ce <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
8000549a:	68 19       	ld.w	r9,r4[0x4]
8000549c:	e6 08 15 10 	lsl	r8,r3,0x10
800054a0:	ea 18 ff f0 	orh	r8,0xfff0
800054a4:	e8 18 ff ff 	orl	r8,0xffff
800054a8:	12 68       	and	r8,r9
800054aa:	89 18       	st.w	r4[0x4],r8
800054ac:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800054b0:	30 38       	mov	r8,3
800054b2:	f0 03 18 00 	cp.b	r3,r8
800054b6:	e0 8b 00 0c 	brhi	800054ce <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800054ba:	68 19       	ld.w	r9,r4[0x4]
800054bc:	2f 03       	sub	r3,-16
800054be:	30 18       	mov	r8,1
800054c0:	f0 03 09 48 	lsl	r8,r8,r3
800054c4:	5c d8       	com	r8
800054c6:	12 68       	and	r8,r9
800054c8:	89 18       	st.w	r4[0x4],r8
800054ca:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800054ce:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
800054d0:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800054d4:	00 00       	add	r0,r0
800054d6:	51 10       	stdsp	sp[0x44],r0
800054d8:	80 00       	ld.sh	r0,r0[0x0]
800054da:	5b fc       	cp.w	r12,-1

800054dc <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800054dc:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
800054de:	f6 08 15 04 	lsl	r8,r11,0x4
800054e2:	14 38       	cp.w	r8,r10
800054e4:	f9 b8 08 10 	movls	r8,16
800054e8:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
800054ec:	f0 0b 02 4b 	mul	r11,r8,r11
800054f0:	f6 09 16 01 	lsr	r9,r11,0x1
800054f4:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
800054f8:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
800054fc:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005500:	f2 cb 00 01 	sub	r11,r9,1
80005504:	e0 4b ff fe 	cp.w	r11,65534
80005508:	e0 88 00 03 	brls	8000550e <usart_set_async_baudrate+0x32>
8000550c:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
8000550e:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005510:	e8 6e 00 00 	mov	lr,524288
80005514:	59 08       	cp.w	r8,16
80005516:	fc 08 17 10 	movne	r8,lr
8000551a:	f9 b8 00 00 	moveq	r8,0
8000551e:	e4 1b ff f7 	andh	r11,0xfff7
80005522:	e0 1b fe cf 	andl	r11,0xfecf
80005526:	16 48       	or	r8,r11
80005528:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
8000552a:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
8000552e:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005532:	99 89       	st.w	r12[0x20],r9
80005534:	d8 0a       	popm	pc,r12=0

80005536 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80005536:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005538:	e2 18 00 02 	andl	r8,0x2,COH
8000553c:	c0 31       	brne	80005542 <usart_write_char+0xc>
8000553e:	30 2c       	mov	r12,2
80005540:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005542:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80005546:	99 7b       	st.w	r12[0x1c],r11
80005548:	5e fd       	retal	0
8000554a:	d7 03       	nop

8000554c <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
8000554c:	eb cd 40 e0 	pushm	r5-r7,lr
80005550:	18 96       	mov	r6,r12
80005552:	16 95       	mov	r5,r11
80005554:	e0 67 27 0f 	mov	r7,9999
80005558:	c0 68       	rjmp	80005564 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
8000555a:	58 07       	cp.w	r7,0
8000555c:	c0 31       	brne	80005562 <usart_putchar+0x16>
8000555e:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80005562:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005564:	0a 9b       	mov	r11,r5
80005566:	0c 9c       	mov	r12,r6
80005568:	f0 1f 00 03 	mcall	80005574 <usart_putchar+0x28>
8000556c:	cf 71       	brne	8000555a <usart_putchar+0xe>

  return USART_SUCCESS;
}
8000556e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005572:	00 00       	add	r0,r0
80005574:	80 00       	ld.sh	r0,r0[0x0]
80005576:	55 36       	stdsp	sp[0x14c],r6

80005578 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80005578:	78 58       	ld.w	r8,r12[0x14]
8000557a:	e2 18 00 e0 	andl	r8,0xe0,COH
8000557e:	c0 30       	breq	80005584 <usart_read_char+0xc>
80005580:	30 4c       	mov	r12,4
80005582:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80005584:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80005586:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000558a:	c0 31       	brne	80005590 <usart_read_char+0x18>
8000558c:	30 3c       	mov	r12,3
8000558e:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80005590:	78 68       	ld.w	r8,r12[0x18]
80005592:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80005596:	97 08       	st.w	r11[0x0],r8
80005598:	5e fd       	retal	0
8000559a:	d7 03       	nop

8000559c <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
8000559c:	eb cd 40 c0 	pushm	r6-r7,lr
800055a0:	20 1d       	sub	sp,4
800055a2:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
800055a4:	1a 97       	mov	r7,sp
800055a6:	1a 9b       	mov	r11,sp
800055a8:	0c 9c       	mov	r12,r6
800055aa:	f0 1f 00 07 	mcall	800055c4 <usart_getchar+0x28>
800055ae:	58 3c       	cp.w	r12,3
800055b0:	cf b0       	breq	800055a6 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
800055b2:	58 4c       	cp.w	r12,4
800055b4:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
800055b8:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
800055bc:	2f fd       	sub	sp,-4
800055be:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800055c2:	00 00       	add	r0,r0
800055c4:	80 00       	ld.sh	r0,r0[0x0]
800055c6:	55 78       	stdsp	sp[0x15c],r8

800055c8 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
800055c8:	eb cd 40 c0 	pushm	r6-r7,lr
800055cc:	18 96       	mov	r6,r12
800055ce:	16 97       	mov	r7,r11
  while (*string != '\0')
800055d0:	17 8b       	ld.ub	r11,r11[0x0]
800055d2:	58 0b       	cp.w	r11,0
800055d4:	c0 80       	breq	800055e4 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
800055d6:	2f f7       	sub	r7,-1
800055d8:	0c 9c       	mov	r12,r6
800055da:	f0 1f 00 04 	mcall	800055e8 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800055de:	0f 8b       	ld.ub	r11,r7[0x0]
800055e0:	58 0b       	cp.w	r11,0
800055e2:	cf a1       	brne	800055d6 <usart_write_line+0xe>
800055e4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800055e8:	80 00       	ld.sh	r0,r0[0x0]
800055ea:	55 4c       	stdsp	sp[0x150],r12

800055ec <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800055ec:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
800055f0:	e6 18 00 01 	andh	r8,0x1,COH
800055f4:	c0 71       	brne	80005602 <usart_reset+0x16>
800055f6:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
800055f8:	3f f8       	mov	r8,-1
800055fa:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800055fc:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800055fe:	d5 03       	csrf	0x10
80005600:	c0 48       	rjmp	80005608 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005602:	3f f8       	mov	r8,-1
80005604:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005606:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005608:	30 08       	mov	r8,0
8000560a:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
8000560c:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
8000560e:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005610:	ea 68 61 0c 	mov	r8,680204
80005614:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80005616:	5e fc       	retal	r12

80005618 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005618:	eb cd 40 e0 	pushm	r5-r7,lr
8000561c:	18 96       	mov	r6,r12
8000561e:	16 97       	mov	r7,r11
80005620:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005622:	f0 1f 00 2f 	mcall	800056dc <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80005626:	58 07       	cp.w	r7,0
80005628:	c5 80       	breq	800056d8 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
8000562a:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000562c:	30 49       	mov	r9,4
8000562e:	f2 08 18 00 	cp.b	r8,r9
80005632:	e0 88 00 53 	brls	800056d8 <usart_init_rs232+0xc0>
80005636:	30 99       	mov	r9,9
80005638:	f2 08 18 00 	cp.b	r8,r9
8000563c:	e0 8b 00 4e 	brhi	800056d8 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005640:	0f d9       	ld.ub	r9,r7[0x5]
80005642:	30 78       	mov	r8,7
80005644:	f0 09 18 00 	cp.b	r9,r8
80005648:	e0 8b 00 48 	brhi	800056d8 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
8000564c:	8e 39       	ld.sh	r9,r7[0x6]
8000564e:	e0 68 01 01 	mov	r8,257
80005652:	f0 09 19 00 	cp.h	r9,r8
80005656:	e0 8b 00 41 	brhi	800056d8 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
8000565a:	ef 39 00 08 	ld.ub	r9,r7[8]
8000565e:	30 38       	mov	r8,3
80005660:	f0 09 18 00 	cp.b	r9,r8
80005664:	e0 8b 00 3a 	brhi	800056d8 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005668:	0a 9a       	mov	r10,r5
8000566a:	6e 0b       	ld.w	r11,r7[0x0]
8000566c:	0c 9c       	mov	r12,r6
8000566e:	f0 1f 00 1d 	mcall	800056e0 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005672:	58 1c       	cp.w	r12,1
80005674:	c3 20       	breq	800056d8 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80005676:	0f c8       	ld.ub	r8,r7[0x4]
80005678:	30 99       	mov	r9,9
8000567a:	f2 08 18 00 	cp.b	r8,r9
8000567e:	c0 51       	brne	80005688 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005680:	6c 18       	ld.w	r8,r6[0x4]
80005682:	b1 b8       	sbr	r8,0x11
80005684:	8d 18       	st.w	r6[0x4],r8
80005686:	c0 68       	rjmp	80005692 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005688:	6c 19       	ld.w	r9,r6[0x4]
8000568a:	20 58       	sub	r8,5
8000568c:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005690:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005692:	6c 19       	ld.w	r9,r6[0x4]
80005694:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005698:	0f d8       	ld.ub	r8,r7[0x5]
8000569a:	a9 78       	lsl	r8,0x9
8000569c:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
800056a0:	12 48       	or	r8,r9
800056a2:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
800056a4:	8e 38       	ld.sh	r8,r7[0x6]
800056a6:	30 29       	mov	r9,2
800056a8:	f2 08 19 00 	cp.h	r8,r9
800056ac:	e0 88 00 09 	brls	800056be <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
800056b0:	6c 18       	ld.w	r8,r6[0x4]
800056b2:	ad b8       	sbr	r8,0xd
800056b4:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
800056b6:	8e b8       	ld.uh	r8,r7[0x6]
800056b8:	20 28       	sub	r8,2
800056ba:	8d a8       	st.w	r6[0x28],r8
800056bc:	c0 68       	rjmp	800056c8 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
800056be:	6c 19       	ld.w	r9,r6[0x4]
800056c0:	5c 78       	castu.h	r8
800056c2:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
800056c6:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
800056c8:	6c 18       	ld.w	r8,r6[0x4]
800056ca:	e0 18 ff f0 	andl	r8,0xfff0
800056ce:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
800056d0:	35 08       	mov	r8,80
800056d2:	8d 08       	st.w	r6[0x0],r8
800056d4:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
800056d8:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800056dc:	80 00       	ld.sh	r0,r0[0x0]
800056de:	55 ec       	stdsp	sp[0x178],r12
800056e0:	80 00       	ld.sh	r0,r0[0x0]
800056e2:	54 dc       	stdsp	sp[0x134],r12

800056e4 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
800056e4:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
800056e8:	fe c0 8e e8 	sub	r0,pc,-28952

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
800056ec:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
800056f0:	d5 53       	csrf	0x15
  cp      r0, r1
800056f2:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
800056f4:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
800056f8:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
800056fa:	c0 62       	brcc	80005706 <idata_load_loop_end>
  cp      r0, r1
800056fc:	48 92       	lddpc	r2,80005720 <udata_clear_loop_end+0x4>

800056fe <idata_load_loop>:
  brlo    idata_load_loop
800056fe:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005700:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005702:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005704:	cf d3       	brcs	800056fe <idata_load_loop>

80005706 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005706:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
8000570a:	e0 61 51 20 	mov	r1,20768
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
8000570e:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005710:	c0 62       	brcc	8000571c <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005712:	30 02       	mov	r2,0
80005714:	30 03       	mov	r3,0

80005716 <udata_clear_loop>:
80005716:	a1 22       	st.d	r0++,r2
80005718:	02 30       	cp.w	r0,r1
8000571a:	cf e3       	brcs	80005716 <udata_clear_loop>

8000571c <udata_clear_loop_end>:
8000571c:	fe cf e9 c4 	sub	pc,pc,-5692
80005720:	80 00       	ld.sh	r0,r0[0x0]
80005722:	db 38       	*unknown*

80005724 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005724:	f8 c8 ff f8 	sub	r8,r12,-8
80005728:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
8000572a:	3f f9       	mov	r9,-1
8000572c:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
8000572e:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005730:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005732:	30 08       	mov	r8,0
80005734:	99 08       	st.w	r12[0x0],r8
}
80005736:	5e fc       	retal	r12

80005738 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005738:	30 08       	mov	r8,0
8000573a:	99 48       	st.w	r12[0x10],r8
}
8000573c:	5e fc       	retal	r12

8000573e <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
8000573e:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005740:	70 19       	ld.w	r9,r8[0x4]
80005742:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005744:	78 19       	ld.w	r9,r12[0x4]
80005746:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005748:	70 19       	ld.w	r9,r8[0x4]
8000574a:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
8000574c:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
8000574e:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005750:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005752:	78 08       	ld.w	r8,r12[0x0]
80005754:	2f f8       	sub	r8,-1
80005756:	99 08       	st.w	r12[0x0],r8
}
80005758:	5e fc       	retal	r12

8000575a <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
8000575a:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
8000575c:	5b fa       	cp.w	r10,-1
8000575e:	c0 31       	brne	80005764 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005760:	78 48       	ld.w	r8,r12[0x10]
80005762:	c0 c8       	rjmp	8000577a <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005764:	f8 c8 ff f8 	sub	r8,r12,-8
80005768:	70 19       	ld.w	r9,r8[0x4]
8000576a:	72 09       	ld.w	r9,r9[0x0]
8000576c:	12 3a       	cp.w	r10,r9
8000576e:	c0 63       	brcs	8000577a <vListInsert+0x20>
80005770:	70 18       	ld.w	r8,r8[0x4]
80005772:	70 19       	ld.w	r9,r8[0x4]
80005774:	72 09       	ld.w	r9,r9[0x0]
80005776:	12 3a       	cp.w	r10,r9
80005778:	cf c2       	brcc	80005770 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
8000577a:	70 19       	ld.w	r9,r8[0x4]
8000577c:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
8000577e:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005780:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005782:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005784:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005786:	78 08       	ld.w	r8,r12[0x0]
80005788:	2f f8       	sub	r8,-1
8000578a:	99 08       	st.w	r12[0x0],r8
}
8000578c:	5e fc       	retal	r12

8000578e <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
8000578e:	78 18       	ld.w	r8,r12[0x4]
80005790:	78 29       	ld.w	r9,r12[0x8]
80005792:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005794:	78 28       	ld.w	r8,r12[0x8]
80005796:	78 19       	ld.w	r9,r12[0x4]
80005798:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
8000579a:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
8000579c:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
8000579e:	18 39       	cp.w	r9,r12
800057a0:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
800057a4:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
800057a8:	30 09       	mov	r9,0
800057aa:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
800057ac:	70 09       	ld.w	r9,r8[0x0]
800057ae:	20 19       	sub	r9,1
800057b0:	91 09       	st.w	r8[0x0],r9
}
800057b2:	5e fc       	retal	r12

800057b4 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
800057b4:	e0 68 08 08 	mov	r8,2056
800057b8:	ea 18 08 08 	orh	r8,0x808
800057bc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
800057be:	e0 68 09 09 	mov	r8,2313
800057c2:	ea 18 09 09 	orh	r8,0x909
800057c6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
800057c8:	e0 68 0a 0a 	mov	r8,2570
800057cc:	ea 18 0a 0a 	orh	r8,0xa0a
800057d0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
800057d2:	e0 68 0b 0b 	mov	r8,2827
800057d6:	ea 18 0b 0b 	orh	r8,0xb0b
800057da:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
800057dc:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
800057de:	e0 68 be ef 	mov	r8,48879
800057e2:	ea 18 de ad 	orh	r8,0xdead
800057e6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
800057e8:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
800057ea:	fc 18 00 40 	movh	r8,0x40
800057ee:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
800057f0:	e0 68 00 ff 	mov	r8,255
800057f4:	ea 18 ff 00 	orh	r8,0xff00
800057f8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
800057fa:	e0 68 01 01 	mov	r8,257
800057fe:	ea 18 01 01 	orh	r8,0x101
80005802:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005804:	e0 68 02 02 	mov	r8,514
80005808:	ea 18 02 02 	orh	r8,0x202
8000580c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
8000580e:	e0 68 03 03 	mov	r8,771
80005812:	ea 18 03 03 	orh	r8,0x303
80005816:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005818:	e0 68 04 04 	mov	r8,1028
8000581c:	ea 18 04 04 	orh	r8,0x404
80005820:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005822:	e0 68 05 05 	mov	r8,1285
80005826:	ea 18 05 05 	orh	r8,0x505
8000582a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
8000582c:	e0 68 06 06 	mov	r8,1542
80005830:	ea 18 06 06 	orh	r8,0x606
80005834:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005836:	e0 68 07 07 	mov	r8,1799
8000583a:	ea 18 07 07 	orh	r8,0x707
8000583e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005840:	30 08       	mov	r8,0
80005842:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005844:	5e fc       	retal	r12
80005846:	d7 03       	nop

80005848 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005848:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
8000584a:	48 38       	lddpc	r8,80005854 <vPortEnterCritical+0xc>
8000584c:	70 09       	ld.w	r9,r8[0x0]
8000584e:	2f f9       	sub	r9,-1
80005850:	91 09       	st.w	r8[0x0],r9
}
80005852:	5e fc       	retal	r12
80005854:	00 00       	add	r0,r0
80005856:	05 30       	ld.ub	r0,r2++

80005858 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005858:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
8000585a:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
8000585c:	30 0a       	mov	r10,0
8000585e:	14 9b       	mov	r11,r10
80005860:	49 2c       	lddpc	r12,800058a8 <xPortStartScheduler+0x50>
80005862:	f0 1f 00 13 	mcall	800058ac <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005866:	e0 68 5d c0 	mov	r8,24000
8000586a:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
8000586e:	30 08       	mov	r8,0
80005870:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005874:	e0 68 0c d4 	mov	r8,3284
80005878:	ea 18 00 00 	orh	r8,0x0
8000587c:	70 00       	ld.w	r0,r8[0x0]
8000587e:	60 0d       	ld.w	sp,r0[0x0]
80005880:	1b 00       	ld.w	r0,sp++
80005882:	e0 68 05 30 	mov	r8,1328
80005886:	ea 18 00 00 	orh	r8,0x0
8000588a:	91 00       	st.w	r8[0x0],r0
8000588c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005890:	2f ed       	sub	sp,-8
80005892:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005896:	fa f0 ff e0 	ld.w	r0,sp[-32]
8000589a:	e3 b0 00 00 	mtsr	0x0,r0
8000589e:	fa f0 ff dc 	ld.w	r0,sp[-36]
800058a2:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
800058a6:	d8 0a       	popm	pc,r12=0
800058a8:	80 00       	ld.sh	r0,r0[0x0]
800058aa:	59 74       	cp.w	r4,23
800058ac:	80 00       	ld.sh	r0,r0[0x0]
800058ae:	51 68       	stdsp	sp[0x58],r8

800058b0 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
800058b0:	20 6d       	sub	sp,24
800058b2:	eb cd 00 ff 	pushm	r0-r7
800058b6:	fa c7 ff c0 	sub	r7,sp,-64
800058ba:	ee f0 ff f8 	ld.w	r0,r7[-8]
800058be:	ef 40 ff e0 	st.w	r7[-32],r0
800058c2:	ee f0 ff fc 	ld.w	r0,r7[-4]
800058c6:	ef 40 ff e4 	st.w	r7[-28],r0
800058ca:	eb c7 5f 00 	stm	--r7,r8-r12,lr
800058ce:	e0 68 05 30 	mov	r8,1328
800058d2:	ea 18 00 00 	orh	r8,0x0
800058d6:	70 00       	ld.w	r0,r8[0x0]
800058d8:	1a d0       	st.w	--sp,r0
800058da:	f0 1f 00 1a 	mcall	80005940 <LABEL_RET_SCALL_263+0x14>
800058de:	e0 68 0c d4 	mov	r8,3284
800058e2:	ea 18 00 00 	orh	r8,0x0
800058e6:	70 00       	ld.w	r0,r8[0x0]
800058e8:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
800058ea:	f0 1f 00 17 	mcall	80005944 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
800058ee:	e0 68 0c d4 	mov	r8,3284
800058f2:	ea 18 00 00 	orh	r8,0x0
800058f6:	70 00       	ld.w	r0,r8[0x0]
800058f8:	60 0d       	ld.w	sp,r0[0x0]
800058fa:	1b 00       	ld.w	r0,sp++
800058fc:	e0 68 05 30 	mov	r8,1328
80005900:	ea 18 00 00 	orh	r8,0x0
80005904:	91 00       	st.w	r8[0x0],r0
80005906:	fa c7 ff d8 	sub	r7,sp,-40
8000590a:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
8000590e:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005912:	e0 61 05 30 	mov	r1,1328
80005916:	ea 11 00 00 	orh	r1,0x0
8000591a:	62 02       	ld.w	r2,r1[0x0]
8000591c:	58 02       	cp.w	r2,0
8000591e:	c0 70       	breq	8000592c <LABEL_RET_SCALL_263>
80005920:	e4 c2 00 01 	sub	r2,r2,1
80005924:	83 02       	st.w	r1[0x0],r2
80005926:	58 02       	cp.w	r2,0
80005928:	c0 21       	brne	8000592c <LABEL_RET_SCALL_263>
8000592a:	b1 c0       	cbr	r0,0x10

8000592c <LABEL_RET_SCALL_263>:
8000592c:	ef 40 ff f8 	st.w	r7[-8],r0
80005930:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005934:	ef 40 ff fc 	st.w	r7[-4],r0
80005938:	e3 cd 00 ff 	ldm	sp++,r0-r7
8000593c:	2f ad       	sub	sp,-24
8000593e:	d6 13       	rets
80005940:	80 00       	ld.sh	r0,r0[0x0]
80005942:	58 48       	cp.w	r8,4
80005944:	80 00       	ld.sh	r0,r0[0x0]
80005946:	5f 8c       	srls	r12

80005948 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005948:	e1 b8 00 43 	mfsr	r8,0x10c
8000594c:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005950:	5e fc       	retal	r12
80005952:	d7 03       	nop

80005954 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005954:	48 78       	lddpc	r8,80005970 <vPortExitCritical+0x1c>
80005956:	70 08       	ld.w	r8,r8[0x0]
80005958:	58 08       	cp.w	r8,0
8000595a:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
8000595c:	48 58       	lddpc	r8,80005970 <vPortExitCritical+0x1c>
8000595e:	70 09       	ld.w	r9,r8[0x0]
80005960:	20 19       	sub	r9,1
80005962:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005964:	70 08       	ld.w	r8,r8[0x0]
80005966:	58 08       	cp.w	r8,0
80005968:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
8000596a:	d5 03       	csrf	0x10
8000596c:	5e fc       	retal	r12
8000596e:	00 00       	add	r0,r0
80005970:	00 00       	add	r0,r0
80005972:	05 30       	ld.ub	r0,r2++

80005974 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005974:	eb cd 00 ff 	pushm	r0-r7
80005978:	e0 68 05 30 	mov	r8,1328
8000597c:	ea 18 00 00 	orh	r8,0x0
80005980:	70 00       	ld.w	r0,r8[0x0]
80005982:	1a d0       	st.w	--sp,r0
80005984:	7a 90       	ld.w	r0,sp[0x24]
80005986:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000598a:	58 10       	cp.w	r0,1
8000598c:	e0 8b 00 08 	brhi	8000599c <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005990:	e0 68 0c d4 	mov	r8,3284
80005994:	ea 18 00 00 	orh	r8,0x0
80005998:	70 00       	ld.w	r0,r8[0x0]
8000599a:	81 0d       	st.w	r0[0x0],sp

8000599c <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
8000599c:	f0 1f 00 12 	mcall	800059e4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
800059a0:	f0 1f 00 12 	mcall	800059e8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
800059a4:	f0 1f 00 12 	mcall	800059ec <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
800059a8:	f0 1f 00 12 	mcall	800059f0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
800059ac:	7a 90       	ld.w	r0,sp[0x24]
800059ae:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800059b2:	58 10       	cp.w	r0,1
800059b4:	e0 8b 00 0e 	brhi	800059d0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
800059b8:	f0 1f 00 0c 	mcall	800059e8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
800059bc:	f0 1f 00 0e 	mcall	800059f4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
800059c0:	f0 1f 00 0c 	mcall	800059f0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
800059c4:	e0 68 0c d4 	mov	r8,3284
800059c8:	ea 18 00 00 	orh	r8,0x0
800059cc:	70 00       	ld.w	r0,r8[0x0]
800059ce:	60 0d       	ld.w	sp,r0[0x0]

800059d0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
800059d0:	1b 00       	ld.w	r0,sp++
800059d2:	e0 68 05 30 	mov	r8,1328
800059d6:	ea 18 00 00 	orh	r8,0x0
800059da:	91 00       	st.w	r8[0x0],r0
800059dc:	e3 cd 00 ff 	ldm	sp++,r0-r7
800059e0:	d6 03       	rete
800059e2:	00 00       	add	r0,r0
800059e4:	80 00       	ld.sh	r0,r0[0x0]
800059e6:	59 48       	cp.w	r8,20
800059e8:	80 00       	ld.sh	r0,r0[0x0]
800059ea:	58 48       	cp.w	r8,4
800059ec:	80 00       	ld.sh	r0,r0[0x0]
800059ee:	61 90       	ld.w	r0,r0[0x64]
800059f0:	80 00       	ld.sh	r0,r0[0x0]
800059f2:	59 54       	cp.w	r4,21
800059f4:	80 00       	ld.sh	r0,r0[0x0]
800059f6:	5f 8c       	srls	r12

800059f8 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
800059f8:	d4 01       	pushm	lr
	vTaskSuspendAll();
800059fa:	f0 1f 00 02 	mcall	80005a00 <__malloc_lock+0x8>
}
800059fe:	d8 02       	popm	pc
80005a00:	80 00       	ld.sh	r0,r0[0x0]
80005a02:	5f 7c       	srpl	r12

80005a04 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005a04:	d4 01       	pushm	lr
	xTaskResumeAll();
80005a06:	f0 1f 00 02 	mcall	80005a0c <__malloc_unlock+0x8>
}
80005a0a:	d8 02       	popm	pc
80005a0c:	80 00       	ld.sh	r0,r0[0x0]
80005a0e:	63 38       	ld.w	r8,r1[0x4c]

80005a10 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005a10:	d4 21       	pushm	r4-r7,lr
80005a12:	16 95       	mov	r5,r11
80005a14:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005a16:	58 0c       	cp.w	r12,0
80005a18:	c0 30       	breq	80005a1e <_read+0xe>
80005a1a:	3f f7       	mov	r7,-1
80005a1c:	c1 48       	rjmp	80005a44 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005a1e:	58 0a       	cp.w	r10,0
80005a20:	e0 89 00 04 	brgt	80005a28 <_read+0x18>
80005a24:	30 07       	mov	r7,0
80005a26:	c0 f8       	rjmp	80005a44 <_read+0x34>
80005a28:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005a2a:	48 84       	lddpc	r4,80005a48 <_read+0x38>
80005a2c:	68 0c       	ld.w	r12,r4[0x0]
80005a2e:	f0 1f 00 08 	mcall	80005a4c <_read+0x3c>
    if (c < 0)
80005a32:	c0 95       	brlt	80005a44 <_read+0x34>
      break;

    *ptr++ = c;
80005a34:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005a38:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005a3a:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005a3e:	58 08       	cp.w	r8,0
80005a40:	fe 99 ff f6 	brgt	80005a2c <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005a44:	0e 9c       	mov	r12,r7
80005a46:	d8 22       	popm	r4-r7,pc
80005a48:	00 00       	add	r0,r0
80005a4a:	51 14       	stdsp	sp[0x44],r4
80005a4c:	80 00       	ld.sh	r0,r0[0x0]
80005a4e:	55 9c       	stdsp	sp[0x164],r12

80005a50 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005a50:	d4 21       	pushm	r4-r7,lr
80005a52:	16 95       	mov	r5,r11
80005a54:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005a56:	20 1c       	sub	r12,1
80005a58:	58 2c       	cp.w	r12,2
80005a5a:	e0 8b 00 12 	brhi	80005a7e <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005a5e:	58 0a       	cp.w	r10,0
80005a60:	c0 31       	brne	80005a66 <_write+0x16>
80005a62:	30 07       	mov	r7,0
80005a64:	c0 e8       	rjmp	80005a80 <_write+0x30>
80005a66:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005a68:	48 74       	lddpc	r4,80005a84 <_write+0x34>
80005a6a:	68 0c       	ld.w	r12,r4[0x0]
80005a6c:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005a70:	f0 1f 00 06 	mcall	80005a88 <_write+0x38>
80005a74:	c0 55       	brlt	80005a7e <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005a76:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005a78:	0e 36       	cp.w	r6,r7
80005a7a:	cf 81       	brne	80005a6a <_write+0x1a>
80005a7c:	c0 28       	rjmp	80005a80 <_write+0x30>
80005a7e:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005a80:	0e 9c       	mov	r12,r7
80005a82:	d8 22       	popm	r4-r7,pc
80005a84:	00 00       	add	r0,r0
80005a86:	51 14       	stdsp	sp[0x44],r4
80005a88:	80 00       	ld.sh	r0,r0[0x0]
80005a8a:	55 4c       	stdsp	sp[0x150],r12

80005a8c <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005a8c:	eb cd 40 80 	pushm	r7,lr
80005a90:	18 97       	mov	r7,r12
	if( pv )
80005a92:	58 0c       	cp.w	r12,0
80005a94:	c0 80       	breq	80005aa4 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005a96:	f0 1f 00 05 	mcall	80005aa8 <vPortFree+0x1c>
		{
			free( pv );
80005a9a:	0e 9c       	mov	r12,r7
80005a9c:	f0 1f 00 04 	mcall	80005aac <vPortFree+0x20>
		}
		xTaskResumeAll();
80005aa0:	f0 1f 00 04 	mcall	80005ab0 <vPortFree+0x24>
80005aa4:	e3 cd 80 80 	ldm	sp++,r7,pc
80005aa8:	80 00       	ld.sh	r0,r0[0x0]
80005aaa:	5f 7c       	srpl	r12
80005aac:	80 00       	ld.sh	r0,r0[0x0]
80005aae:	6d dc       	ld.w	r12,r6[0x74]
80005ab0:	80 00       	ld.sh	r0,r0[0x0]
80005ab2:	63 38       	ld.w	r8,r1[0x4c]

80005ab4 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005ab4:	eb cd 40 80 	pushm	r7,lr
80005ab8:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005aba:	f0 1f 00 06 	mcall	80005ad0 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005abe:	0e 9c       	mov	r12,r7
80005ac0:	f0 1f 00 05 	mcall	80005ad4 <pvPortMalloc+0x20>
80005ac4:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005ac6:	f0 1f 00 05 	mcall	80005ad8 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005aca:	0e 9c       	mov	r12,r7
80005acc:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ad0:	80 00       	ld.sh	r0,r0[0x0]
80005ad2:	5f 7c       	srpl	r12
80005ad4:	80 00       	ld.sh	r0,r0[0x0]
80005ad6:	6d ec       	ld.w	r12,r6[0x78]
80005ad8:	80 00       	ld.sh	r0,r0[0x0]
80005ada:	63 38       	ld.w	r8,r1[0x4c]

80005adc <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005adc:	d4 01       	pushm	lr
80005ade:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005ae0:	78 09       	ld.w	r9,r12[0x0]
80005ae2:	58 09       	cp.w	r9,0
80005ae4:	c1 10       	breq	80005b06 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005ae6:	78 3a       	ld.w	r10,r12[0xc]
80005ae8:	79 09       	ld.w	r9,r12[0x40]
80005aea:	f4 09 00 09 	add	r9,r10,r9
80005aee:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005af0:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005af2:	14 39       	cp.w	r9,r10
80005af4:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005af8:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005afc:	79 0a       	ld.w	r10,r12[0x40]
80005afe:	78 3b       	ld.w	r11,r12[0xc]
80005b00:	10 9c       	mov	r12,r8
80005b02:	f0 1f 00 02 	mcall	80005b08 <prvCopyDataFromQueue+0x2c>
80005b06:	d8 02       	popm	pc
80005b08:	80 00       	ld.sh	r0,r0[0x0]
80005b0a:	72 34       	ld.w	r4,r9[0xc]

80005b0c <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005b0c:	eb cd 40 c0 	pushm	r6-r7,lr
80005b10:	18 97       	mov	r7,r12
80005b12:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005b14:	78 e8       	ld.w	r8,r12[0x38]
80005b16:	58 08       	cp.w	r8,0
80005b18:	c0 31       	brne	80005b1e <xQueueReceiveFromISR+0x12>
80005b1a:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005b1e:	f0 1f 00 0e 	mcall	80005b54 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80005b22:	6e e8       	ld.w	r8,r7[0x38]
80005b24:	20 18       	sub	r8,1
80005b26:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80005b28:	6f 18       	ld.w	r8,r7[0x44]
80005b2a:	5b f8       	cp.w	r8,-1
80005b2c:	c0 d1       	brne	80005b46 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005b2e:	6e 48       	ld.w	r8,r7[0x10]
80005b30:	58 08       	cp.w	r8,0
80005b32:	c0 f0       	breq	80005b50 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005b34:	ee cc ff f0 	sub	r12,r7,-16
80005b38:	f0 1f 00 08 	mcall	80005b58 <xQueueReceiveFromISR+0x4c>
80005b3c:	c0 a0       	breq	80005b50 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80005b3e:	30 1c       	mov	r12,1
80005b40:	8d 0c       	st.w	r6[0x0],r12
80005b42:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80005b46:	2f f8       	sub	r8,-1
80005b48:	ef 48 00 44 	st.w	r7[68],r8
80005b4c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005b50:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005b54:	80 00       	ld.sh	r0,r0[0x0]
80005b56:	5a dc       	cp.w	r12,-19
80005b58:	80 00       	ld.sh	r0,r0[0x0]
80005b5a:	61 14       	ld.w	r4,r0[0x44]

80005b5c <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005b5c:	eb cd 40 c0 	pushm	r6-r7,lr
80005b60:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005b62:	f0 1f 00 23 	mcall	80005bec <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005b66:	6f 28       	ld.w	r8,r7[0x48]
80005b68:	58 08       	cp.w	r8,0
80005b6a:	e0 8a 00 18 	brle	80005b9a <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005b6e:	6e 98       	ld.w	r8,r7[0x24]
80005b70:	58 08       	cp.w	r8,0
80005b72:	c1 40       	breq	80005b9a <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005b74:	ee c6 ff dc 	sub	r6,r7,-36
80005b78:	c0 48       	rjmp	80005b80 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005b7a:	6e 98       	ld.w	r8,r7[0x24]
80005b7c:	58 08       	cp.w	r8,0
80005b7e:	c0 e0       	breq	80005b9a <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005b80:	0c 9c       	mov	r12,r6
80005b82:	f0 1f 00 1c 	mcall	80005bf0 <prvUnlockQueue+0x94>
80005b86:	c0 30       	breq	80005b8c <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005b88:	f0 1f 00 1b 	mcall	80005bf4 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005b8c:	6f 28       	ld.w	r8,r7[0x48]
80005b8e:	20 18       	sub	r8,1
80005b90:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005b94:	58 08       	cp.w	r8,0
80005b96:	fe 99 ff f2 	brgt	80005b7a <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005b9a:	3f f8       	mov	r8,-1
80005b9c:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005ba0:	f0 1f 00 16 	mcall	80005bf8 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005ba4:	f0 1f 00 12 	mcall	80005bec <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005ba8:	6f 18       	ld.w	r8,r7[0x44]
80005baa:	58 08       	cp.w	r8,0
80005bac:	e0 8a 00 18 	brle	80005bdc <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005bb0:	6e 48       	ld.w	r8,r7[0x10]
80005bb2:	58 08       	cp.w	r8,0
80005bb4:	c1 40       	breq	80005bdc <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005bb6:	ee c6 ff f0 	sub	r6,r7,-16
80005bba:	c0 48       	rjmp	80005bc2 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005bbc:	6e 48       	ld.w	r8,r7[0x10]
80005bbe:	58 08       	cp.w	r8,0
80005bc0:	c0 e0       	breq	80005bdc <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005bc2:	0c 9c       	mov	r12,r6
80005bc4:	f0 1f 00 0b 	mcall	80005bf0 <prvUnlockQueue+0x94>
80005bc8:	c0 30       	breq	80005bce <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80005bca:	f0 1f 00 0b 	mcall	80005bf4 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005bce:	6f 18       	ld.w	r8,r7[0x44]
80005bd0:	20 18       	sub	r8,1
80005bd2:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005bd6:	58 08       	cp.w	r8,0
80005bd8:	fe 99 ff f2 	brgt	80005bbc <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005bdc:	3f f8       	mov	r8,-1
80005bde:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80005be2:	f0 1f 00 06 	mcall	80005bf8 <prvUnlockQueue+0x9c>
}
80005be6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005bea:	00 00       	add	r0,r0
80005bec:	80 00       	ld.sh	r0,r0[0x0]
80005bee:	58 48       	cp.w	r8,4
80005bf0:	80 00       	ld.sh	r0,r0[0x0]
80005bf2:	61 14       	ld.w	r4,r0[0x44]
80005bf4:	80 00       	ld.sh	r0,r0[0x0]
80005bf6:	60 20       	ld.w	r0,r0[0x8]
80005bf8:	80 00       	ld.sh	r0,r0[0x0]
80005bfa:	59 54       	cp.w	r4,21

80005bfc <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005bfc:	d4 31       	pushm	r0-r7,lr
80005bfe:	20 5d       	sub	sp,20
80005c00:	18 97       	mov	r7,r12
80005c02:	50 0b       	stdsp	sp[0x0],r11
80005c04:	50 2a       	stdsp	sp[0x8],r10
80005c06:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005c08:	f8 c2 ff dc 	sub	r2,r12,-36
80005c0c:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005c0e:	fa c4 ff f4 	sub	r4,sp,-12
80005c12:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005c14:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005c16:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80005c1a:	f0 1f 00 3e 	mcall	80005d10 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005c1e:	6e e8       	ld.w	r8,r7[0x38]
80005c20:	58 08       	cp.w	r8,0
80005c22:	c2 a0       	breq	80005c76 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80005c24:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80005c26:	40 0b       	lddsp	r11,sp[0x0]
80005c28:	0e 9c       	mov	r12,r7
80005c2a:	f0 1f 00 3b 	mcall	80005d14 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80005c2e:	40 18       	lddsp	r8,sp[0x4]
80005c30:	58 08       	cp.w	r8,0
80005c32:	c1 51       	brne	80005c5c <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80005c34:	6e e8       	ld.w	r8,r7[0x38]
80005c36:	20 18       	sub	r8,1
80005c38:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005c3a:	6e 08       	ld.w	r8,r7[0x0]
80005c3c:	58 08       	cp.w	r8,0
80005c3e:	c0 41       	brne	80005c46 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80005c40:	f0 1f 00 36 	mcall	80005d18 <xQueueGenericReceive+0x11c>
80005c44:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005c46:	6e 48       	ld.w	r8,r7[0x10]
80005c48:	58 08       	cp.w	r8,0
80005c4a:	c1 20       	breq	80005c6e <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80005c4c:	ee cc ff f0 	sub	r12,r7,-16
80005c50:	f0 1f 00 33 	mcall	80005d1c <xQueueGenericReceive+0x120>
80005c54:	58 1c       	cp.w	r12,1
80005c56:	c0 c1       	brne	80005c6e <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80005c58:	d7 33       	scall
80005c5a:	c0 a8       	rjmp	80005c6e <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80005c5c:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005c5e:	6e 98       	ld.w	r8,r7[0x24]
80005c60:	58 08       	cp.w	r8,0
80005c62:	c0 60       	breq	80005c6e <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005c64:	04 9c       	mov	r12,r2
80005c66:	f0 1f 00 2e 	mcall	80005d1c <xQueueGenericReceive+0x120>
80005c6a:	c0 20       	breq	80005c6e <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80005c6c:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80005c6e:	f0 1f 00 2d 	mcall	80005d20 <xQueueGenericReceive+0x124>
80005c72:	30 1c       	mov	r12,1
				return pdPASS;
80005c74:	c4 c8       	rjmp	80005d0c <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005c76:	40 28       	lddsp	r8,sp[0x8]
80005c78:	58 08       	cp.w	r8,0
80005c7a:	c0 51       	brne	80005c84 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005c7c:	f0 1f 00 29 	mcall	80005d20 <xQueueGenericReceive+0x124>
80005c80:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80005c82:	c4 58       	rjmp	80005d0c <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80005c84:	58 05       	cp.w	r5,0
80005c86:	c0 51       	brne	80005c90 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005c88:	08 9c       	mov	r12,r4
80005c8a:	f0 1f 00 27 	mcall	80005d24 <xQueueGenericReceive+0x128>
80005c8e:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005c90:	f0 1f 00 24 	mcall	80005d20 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005c94:	f0 1f 00 25 	mcall	80005d28 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005c98:	f0 1f 00 1e 	mcall	80005d10 <xQueueGenericReceive+0x114>
80005c9c:	6f 18       	ld.w	r8,r7[0x44]
80005c9e:	5b f8       	cp.w	r8,-1
80005ca0:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005ca4:	6f 28       	ld.w	r8,r7[0x48]
80005ca6:	5b f8       	cp.w	r8,-1
80005ca8:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005cac:	f0 1f 00 1d 	mcall	80005d20 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005cb0:	06 9b       	mov	r11,r3
80005cb2:	08 9c       	mov	r12,r4
80005cb4:	f0 1f 00 1e 	mcall	80005d2c <xQueueGenericReceive+0x130>
80005cb8:	c2 41       	brne	80005d00 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005cba:	f0 1f 00 16 	mcall	80005d10 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005cbe:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80005cc0:	f0 1f 00 18 	mcall	80005d20 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80005cc4:	58 06       	cp.w	r6,0
80005cc6:	c1 71       	brne	80005cf4 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005cc8:	6e 08       	ld.w	r8,r7[0x0]
80005cca:	58 08       	cp.w	r8,0
80005ccc:	c0 81       	brne	80005cdc <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80005cce:	f0 1f 00 11 	mcall	80005d10 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80005cd2:	6e 1c       	ld.w	r12,r7[0x4]
80005cd4:	f0 1f 00 17 	mcall	80005d30 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80005cd8:	f0 1f 00 12 	mcall	80005d20 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005cdc:	40 2b       	lddsp	r11,sp[0x8]
80005cde:	04 9c       	mov	r12,r2
80005ce0:	f0 1f 00 15 	mcall	80005d34 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80005ce4:	0e 9c       	mov	r12,r7
80005ce6:	f0 1f 00 15 	mcall	80005d38 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80005cea:	f0 1f 00 15 	mcall	80005d3c <xQueueGenericReceive+0x140>
80005cee:	c9 61       	brne	80005c1a <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80005cf0:	d7 33       	scall
80005cf2:	c9 4b       	rjmp	80005c1a <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005cf4:	0e 9c       	mov	r12,r7
80005cf6:	f0 1f 00 11 	mcall	80005d38 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80005cfa:	f0 1f 00 11 	mcall	80005d3c <xQueueGenericReceive+0x140>
80005cfe:	c8 eb       	rjmp	80005c1a <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80005d00:	0e 9c       	mov	r12,r7
80005d02:	f0 1f 00 0e 	mcall	80005d38 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80005d06:	f0 1f 00 0e 	mcall	80005d3c <xQueueGenericReceive+0x140>
80005d0a:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80005d0c:	2f bd       	sub	sp,-20
80005d0e:	d8 32       	popm	r0-r7,pc
80005d10:	80 00       	ld.sh	r0,r0[0x0]
80005d12:	58 48       	cp.w	r8,4
80005d14:	80 00       	ld.sh	r0,r0[0x0]
80005d16:	5a dc       	cp.w	r12,-19
80005d18:	80 00       	ld.sh	r0,r0[0x0]
80005d1a:	60 2c       	ld.w	r12,r0[0x8]
80005d1c:	80 00       	ld.sh	r0,r0[0x0]
80005d1e:	61 14       	ld.w	r4,r0[0x44]
80005d20:	80 00       	ld.sh	r0,r0[0x0]
80005d22:	59 54       	cp.w	r4,21
80005d24:	80 00       	ld.sh	r0,r0[0x0]
80005d26:	60 08       	ld.w	r8,r0[0x0]
80005d28:	80 00       	ld.sh	r0,r0[0x0]
80005d2a:	5f 7c       	srpl	r12
80005d2c:	80 00       	ld.sh	r0,r0[0x0]
80005d2e:	62 a4       	ld.w	r4,r1[0x28]
80005d30:	80 00       	ld.sh	r0,r0[0x0]
80005d32:	60 90       	ld.w	r0,r0[0x24]
80005d34:	80 00       	ld.sh	r0,r0[0x0]
80005d36:	64 fc       	ld.w	r12,r2[0x3c]
80005d38:	80 00       	ld.sh	r0,r0[0x0]
80005d3a:	5b 5c       	cp.w	r12,-11
80005d3c:	80 00       	ld.sh	r0,r0[0x0]
80005d3e:	63 38       	ld.w	r8,r1[0x4c]

80005d40 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80005d40:	eb cd 40 80 	pushm	r7,lr
80005d44:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80005d46:	79 08       	ld.w	r8,r12[0x40]
80005d48:	58 08       	cp.w	r8,0
80005d4a:	c0 a1       	brne	80005d5e <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005d4c:	78 08       	ld.w	r8,r12[0x0]
80005d4e:	58 08       	cp.w	r8,0
80005d50:	c2 b1       	brne	80005da6 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80005d52:	78 1c       	ld.w	r12,r12[0x4]
80005d54:	f0 1f 00 17 	mcall	80005db0 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80005d58:	30 08       	mov	r8,0
80005d5a:	8f 18       	st.w	r7[0x4],r8
80005d5c:	c2 58       	rjmp	80005da6 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80005d5e:	58 0a       	cp.w	r10,0
80005d60:	c1 01       	brne	80005d80 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005d62:	10 9a       	mov	r10,r8
80005d64:	78 2c       	ld.w	r12,r12[0x8]
80005d66:	f0 1f 00 14 	mcall	80005db4 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80005d6a:	6e 29       	ld.w	r9,r7[0x8]
80005d6c:	6f 08       	ld.w	r8,r7[0x40]
80005d6e:	f2 08 00 08 	add	r8,r9,r8
80005d72:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80005d74:	6e 19       	ld.w	r9,r7[0x4]
80005d76:	12 38       	cp.w	r8,r9
80005d78:	c1 73       	brcs	80005da6 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80005d7a:	6e 08       	ld.w	r8,r7[0x0]
80005d7c:	8f 28       	st.w	r7[0x8],r8
80005d7e:	c1 48       	rjmp	80005da6 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005d80:	10 9a       	mov	r10,r8
80005d82:	78 3c       	ld.w	r12,r12[0xc]
80005d84:	f0 1f 00 0c 	mcall	80005db4 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005d88:	6f 08       	ld.w	r8,r7[0x40]
80005d8a:	6e 39       	ld.w	r9,r7[0xc]
80005d8c:	f2 08 01 08 	sub	r8,r9,r8
80005d90:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80005d92:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80005d94:	12 38       	cp.w	r8,r9
80005d96:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80005d9a:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80005d9e:	f3 d8 e3 19 	subcs	r9,r9,r8
80005da2:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80005da6:	6e e8       	ld.w	r8,r7[0x38]
80005da8:	2f f8       	sub	r8,-1
80005daa:	8f e8       	st.w	r7[0x38],r8
}
80005dac:	e3 cd 80 80 	ldm	sp++,r7,pc
80005db0:	80 00       	ld.sh	r0,r0[0x0]
80005db2:	60 38       	ld.w	r8,r0[0xc]
80005db4:	80 00       	ld.sh	r0,r0[0x0]
80005db6:	72 34       	ld.w	r4,r9[0xc]

80005db8 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80005db8:	eb cd 40 c0 	pushm	r6-r7,lr
80005dbc:	18 97       	mov	r7,r12
80005dbe:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005dc0:	78 ec       	ld.w	r12,r12[0x38]
80005dc2:	6e f8       	ld.w	r8,r7[0x3c]
80005dc4:	10 3c       	cp.w	r12,r8
80005dc6:	c0 33       	brcs	80005dcc <xQueueGenericSendFromISR+0x14>
80005dc8:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005dcc:	12 9a       	mov	r10,r9
80005dce:	0e 9c       	mov	r12,r7
80005dd0:	f0 1f 00 0c 	mcall	80005e00 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80005dd4:	6f 28       	ld.w	r8,r7[0x48]
80005dd6:	5b f8       	cp.w	r8,-1
80005dd8:	c0 d1       	brne	80005df2 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005dda:	6e 98       	ld.w	r8,r7[0x24]
80005ddc:	58 08       	cp.w	r8,0
80005dde:	c0 f0       	breq	80005dfc <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005de0:	ee cc ff dc 	sub	r12,r7,-36
80005de4:	f0 1f 00 08 	mcall	80005e04 <xQueueGenericSendFromISR+0x4c>
80005de8:	c0 a0       	breq	80005dfc <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80005dea:	30 1c       	mov	r12,1
80005dec:	8d 0c       	st.w	r6[0x0],r12
80005dee:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80005df2:	2f f8       	sub	r8,-1
80005df4:	ef 48 00 48 	st.w	r7[72],r8
80005df8:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005dfc:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005e00:	80 00       	ld.sh	r0,r0[0x0]
80005e02:	5d 40       	*unknown*
80005e04:	80 00       	ld.sh	r0,r0[0x0]
80005e06:	61 14       	ld.w	r4,r0[0x44]

80005e08 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80005e08:	d4 31       	pushm	r0-r7,lr
80005e0a:	20 5d       	sub	sp,20
80005e0c:	18 97       	mov	r7,r12
80005e0e:	50 0b       	stdsp	sp[0x0],r11
80005e10:	50 2a       	stdsp	sp[0x8],r10
80005e12:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005e14:	f8 c0 ff f0 	sub	r0,r12,-16
80005e18:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005e1a:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005e1e:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005e20:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80005e24:	f0 1f 00 2f 	mcall	80005ee0 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005e28:	6e e9       	ld.w	r9,r7[0x38]
80005e2a:	6e f8       	ld.w	r8,r7[0x3c]
80005e2c:	10 39       	cp.w	r9,r8
80005e2e:	c1 42       	brcc	80005e56 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005e30:	40 1a       	lddsp	r10,sp[0x4]
80005e32:	40 0b       	lddsp	r11,sp[0x0]
80005e34:	0e 9c       	mov	r12,r7
80005e36:	f0 1f 00 2c 	mcall	80005ee4 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005e3a:	6e 98       	ld.w	r8,r7[0x24]
80005e3c:	58 08       	cp.w	r8,0
80005e3e:	c0 80       	breq	80005e4e <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80005e40:	ee cc ff dc 	sub	r12,r7,-36
80005e44:	f0 1f 00 29 	mcall	80005ee8 <xQueueGenericSend+0xe0>
80005e48:	58 1c       	cp.w	r12,1
80005e4a:	c0 21       	brne	80005e4e <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80005e4c:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80005e4e:	f0 1f 00 28 	mcall	80005eec <xQueueGenericSend+0xe4>
80005e52:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80005e54:	c4 38       	rjmp	80005eda <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005e56:	40 28       	lddsp	r8,sp[0x8]
80005e58:	58 08       	cp.w	r8,0
80005e5a:	c0 51       	brne	80005e64 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005e5c:	f0 1f 00 24 	mcall	80005eec <xQueueGenericSend+0xe4>
80005e60:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80005e62:	c3 c8       	rjmp	80005eda <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80005e64:	58 04       	cp.w	r4,0
80005e66:	c0 51       	brne	80005e70 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005e68:	06 9c       	mov	r12,r3
80005e6a:	f0 1f 00 22 	mcall	80005ef0 <xQueueGenericSend+0xe8>
80005e6e:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005e70:	f0 1f 00 1f 	mcall	80005eec <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005e74:	f0 1f 00 20 	mcall	80005ef4 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80005e78:	f0 1f 00 1a 	mcall	80005ee0 <xQueueGenericSend+0xd8>
80005e7c:	6f 18       	ld.w	r8,r7[0x44]
80005e7e:	5b f8       	cp.w	r8,-1
80005e80:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005e84:	6f 28       	ld.w	r8,r7[0x48]
80005e86:	5b f8       	cp.w	r8,-1
80005e88:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005e8c:	f0 1f 00 18 	mcall	80005eec <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005e90:	04 9b       	mov	r11,r2
80005e92:	06 9c       	mov	r12,r3
80005e94:	f0 1f 00 19 	mcall	80005ef8 <xQueueGenericSend+0xf0>
80005e98:	c1 b1       	brne	80005ece <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005e9a:	f0 1f 00 12 	mcall	80005ee0 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005e9e:	6e e5       	ld.w	r5,r7[0x38]
80005ea0:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80005ea2:	f0 1f 00 13 	mcall	80005eec <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80005ea6:	0c 35       	cp.w	r5,r6
80005ea8:	c0 d1       	brne	80005ec2 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005eaa:	40 2b       	lddsp	r11,sp[0x8]
80005eac:	00 9c       	mov	r12,r0
80005eae:	f0 1f 00 14 	mcall	80005efc <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80005eb2:	0e 9c       	mov	r12,r7
80005eb4:	f0 1f 00 13 	mcall	80005f00 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80005eb8:	f0 1f 00 13 	mcall	80005f04 <xQueueGenericSend+0xfc>
80005ebc:	cb 41       	brne	80005e24 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80005ebe:	d7 33       	scall
80005ec0:	cb 2b       	rjmp	80005e24 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005ec2:	0e 9c       	mov	r12,r7
80005ec4:	f0 1f 00 0f 	mcall	80005f00 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80005ec8:	f0 1f 00 0f 	mcall	80005f04 <xQueueGenericSend+0xfc>
80005ecc:	ca cb       	rjmp	80005e24 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80005ece:	0e 9c       	mov	r12,r7
80005ed0:	f0 1f 00 0c 	mcall	80005f00 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80005ed4:	f0 1f 00 0c 	mcall	80005f04 <xQueueGenericSend+0xfc>
80005ed8:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80005eda:	2f bd       	sub	sp,-20
80005edc:	d8 32       	popm	r0-r7,pc
80005ede:	00 00       	add	r0,r0
80005ee0:	80 00       	ld.sh	r0,r0[0x0]
80005ee2:	58 48       	cp.w	r8,4
80005ee4:	80 00       	ld.sh	r0,r0[0x0]
80005ee6:	5d 40       	*unknown*
80005ee8:	80 00       	ld.sh	r0,r0[0x0]
80005eea:	61 14       	ld.w	r4,r0[0x44]
80005eec:	80 00       	ld.sh	r0,r0[0x0]
80005eee:	59 54       	cp.w	r4,21
80005ef0:	80 00       	ld.sh	r0,r0[0x0]
80005ef2:	60 08       	ld.w	r8,r0[0x0]
80005ef4:	80 00       	ld.sh	r0,r0[0x0]
80005ef6:	5f 7c       	srpl	r12
80005ef8:	80 00       	ld.sh	r0,r0[0x0]
80005efa:	62 a4       	ld.w	r4,r1[0x28]
80005efc:	80 00       	ld.sh	r0,r0[0x0]
80005efe:	64 fc       	ld.w	r12,r2[0x3c]
80005f00:	80 00       	ld.sh	r0,r0[0x0]
80005f02:	5b 5c       	cp.w	r12,-11
80005f04:	80 00       	ld.sh	r0,r0[0x0]
80005f06:	63 38       	ld.w	r8,r1[0x4c]

80005f08 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80005f08:	d4 21       	pushm	r4-r7,lr
80005f0a:	18 97       	mov	r7,r12
80005f0c:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80005f0e:	58 0c       	cp.w	r12,0
80005f10:	c2 f0       	breq	80005f6e <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005f12:	34 cc       	mov	r12,76
80005f14:	f0 1f 00 17 	mcall	80005f70 <xQueueCreate+0x68>
80005f18:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80005f1a:	c2 a0       	breq	80005f6e <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80005f1c:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80005f20:	e8 cc ff ff 	sub	r12,r4,-1
80005f24:	f0 1f 00 13 	mcall	80005f70 <xQueueCreate+0x68>
80005f28:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80005f2a:	c1 e0       	breq	80005f66 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80005f2c:	f8 04 00 04 	add	r4,r12,r4
80005f30:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005f32:	30 08       	mov	r8,0
80005f34:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80005f36:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80005f38:	ee c8 00 01 	sub	r8,r7,1
80005f3c:	ad 38       	mul	r8,r6
80005f3e:	10 0c       	add	r12,r8
80005f40:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80005f42:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80005f44:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80005f48:	3f f8       	mov	r8,-1
80005f4a:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80005f4e:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005f52:	ea cc ff f0 	sub	r12,r5,-16
80005f56:	f0 1f 00 08 	mcall	80005f74 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005f5a:	ea cc ff dc 	sub	r12,r5,-36
80005f5e:	f0 1f 00 06 	mcall	80005f74 <xQueueCreate+0x6c>
80005f62:	0a 9c       	mov	r12,r5
80005f64:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80005f66:	0a 9c       	mov	r12,r5
80005f68:	f0 1f 00 04 	mcall	80005f78 <xQueueCreate+0x70>
80005f6c:	d8 2a       	popm	r4-r7,pc,r12=0
80005f6e:	d8 2a       	popm	r4-r7,pc,r12=0
80005f70:	80 00       	ld.sh	r0,r0[0x0]
80005f72:	5a b4       	cp.w	r4,-21
80005f74:	80 00       	ld.sh	r0,r0[0x0]
80005f76:	57 24       	stdsp	sp[0x1c8],r4
80005f78:	80 00       	ld.sh	r0,r0[0x0]
80005f7a:	5a 8c       	cp.w	r12,-24

80005f7c <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80005f7c:	48 38       	lddpc	r8,80005f88 <vTaskSuspendAll+0xc>
80005f7e:	70 09       	ld.w	r9,r8[0x0]
80005f80:	2f f9       	sub	r9,-1
80005f82:	91 09       	st.w	r8[0x0],r9
}
80005f84:	5e fc       	retal	r12
80005f86:	00 00       	add	r0,r0
80005f88:	00 00       	add	r0,r0
80005f8a:	0d 04       	ld.w	r4,r6++

80005f8c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80005f8c:	49 a8       	lddpc	r8,80005ff4 <vTaskSwitchContext+0x68>
80005f8e:	70 08       	ld.w	r8,r8[0x0]
80005f90:	58 08       	cp.w	r8,0
80005f92:	c0 b1       	brne	80005fa8 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005f94:	49 98       	lddpc	r8,80005ff8 <vTaskSwitchContext+0x6c>
80005f96:	70 08       	ld.w	r8,r8[0x0]
80005f98:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005f9c:	49 89       	lddpc	r9,80005ffc <vTaskSwitchContext+0x70>
80005f9e:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80005fa2:	58 08       	cp.w	r8,0
80005fa4:	c0 60       	breq	80005fb0 <vTaskSwitchContext+0x24>
80005fa6:	c1 18       	rjmp	80005fc8 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005fa8:	30 19       	mov	r9,1
80005faa:	49 68       	lddpc	r8,80006000 <vTaskSwitchContext+0x74>
80005fac:	91 09       	st.w	r8[0x0],r9
80005fae:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005fb0:	49 28       	lddpc	r8,80005ff8 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005fb2:	49 3a       	lddpc	r10,80005ffc <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005fb4:	70 09       	ld.w	r9,r8[0x0]
80005fb6:	20 19       	sub	r9,1
80005fb8:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005fba:	70 09       	ld.w	r9,r8[0x0]
80005fbc:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005fc0:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80005fc4:	58 09       	cp.w	r9,0
80005fc6:	cf 70       	breq	80005fb4 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80005fc8:	48 c8       	lddpc	r8,80005ff8 <vTaskSwitchContext+0x6c>
80005fca:	70 08       	ld.w	r8,r8[0x0]
80005fcc:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005fd0:	48 b9       	lddpc	r9,80005ffc <vTaskSwitchContext+0x70>
80005fd2:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005fd6:	70 19       	ld.w	r9,r8[0x4]
80005fd8:	72 19       	ld.w	r9,r9[0x4]
80005fda:	91 19       	st.w	r8[0x4],r9
80005fdc:	f0 ca ff f8 	sub	r10,r8,-8
80005fe0:	14 39       	cp.w	r9,r10
80005fe2:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80005fe6:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80005fea:	70 18       	ld.w	r8,r8[0x4]
80005fec:	70 39       	ld.w	r9,r8[0xc]
80005fee:	48 68       	lddpc	r8,80006004 <vTaskSwitchContext+0x78>
80005ff0:	91 09       	st.w	r8[0x0],r9
80005ff2:	5e fc       	retal	r12
80005ff4:	00 00       	add	r0,r0
80005ff6:	0d 04       	ld.w	r4,r6++
80005ff8:	00 00       	add	r0,r0
80005ffa:	0d 3c       	ld.ub	r12,r6++
80005ffc:	00 00       	add	r0,r0
80005ffe:	0c 20       	rsub	r0,r6
80006000:	00 00       	add	r0,r0
80006002:	0d 24       	ld.uh	r4,r6++
80006004:	00 00       	add	r0,r0
80006006:	0c d4       	st.w	--r6,r4

80006008 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80006008:	48 48       	lddpc	r8,80006018 <vTaskSetTimeOutState+0x10>
8000600a:	70 08       	ld.w	r8,r8[0x0]
8000600c:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
8000600e:	48 48       	lddpc	r8,8000601c <vTaskSetTimeOutState+0x14>
80006010:	70 08       	ld.w	r8,r8[0x0]
80006012:	99 18       	st.w	r12[0x4],r8
}
80006014:	5e fc       	retal	r12
80006016:	00 00       	add	r0,r0
80006018:	00 00       	add	r0,r0
8000601a:	0c 18       	sub	r8,r6
8000601c:	00 00       	add	r0,r0
8000601e:	0d 00       	ld.w	r0,r6++

80006020 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80006020:	30 19       	mov	r9,1
80006022:	48 28       	lddpc	r8,80006028 <vTaskMissedYield+0x8>
80006024:	91 09       	st.w	r8[0x0],r9
}
80006026:	5e fc       	retal	r12
80006028:	00 00       	add	r0,r0
8000602a:	0d 24       	ld.uh	r4,r6++

8000602c <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
8000602c:	48 28       	lddpc	r8,80006034 <xTaskGetCurrentTaskHandle+0x8>
8000602e:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006030:	5e fc       	retal	r12
80006032:	00 00       	add	r0,r0
80006034:	00 00       	add	r0,r0
80006036:	0c d4       	st.w	--r6,r4

80006038 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80006038:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
8000603c:	58 0c       	cp.w	r12,0
8000603e:	c1 f0       	breq	8000607c <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80006040:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80006042:	78 b9       	ld.w	r9,r12[0x2c]
80006044:	79 18       	ld.w	r8,r12[0x44]
80006046:	10 39       	cp.w	r9,r8
80006048:	c1 a0       	breq	8000607c <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000604a:	f8 c6 ff fc 	sub	r6,r12,-4
8000604e:	0c 9c       	mov	r12,r6
80006050:	f0 1f 00 0c 	mcall	80006080 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80006054:	6f 1c       	ld.w	r12,r7[0x44]
80006056:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80006058:	f8 08 11 08 	rsub	r8,r12,8
8000605c:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
8000605e:	48 a8       	lddpc	r8,80006084 <vTaskPriorityDisinherit+0x4c>
80006060:	70 08       	ld.w	r8,r8[0x0]
80006062:	10 3c       	cp.w	r12,r8
80006064:	e0 88 00 04 	brls	8000606c <vTaskPriorityDisinherit+0x34>
80006068:	48 78       	lddpc	r8,80006084 <vTaskPriorityDisinherit+0x4c>
8000606a:	91 0c       	st.w	r8[0x0],r12
8000606c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006070:	0c 9b       	mov	r11,r6
80006072:	48 68       	lddpc	r8,80006088 <vTaskPriorityDisinherit+0x50>
80006074:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006078:	f0 1f 00 05 	mcall	8000608c <vTaskPriorityDisinherit+0x54>
8000607c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006080:	80 00       	ld.sh	r0,r0[0x0]
80006082:	57 8e       	stdsp	sp[0x1e0],lr
80006084:	00 00       	add	r0,r0
80006086:	0d 3c       	ld.ub	r12,r6++
80006088:	00 00       	add	r0,r0
8000608a:	0c 20       	rsub	r0,r6
8000608c:	80 00       	ld.sh	r0,r0[0x0]
8000608e:	57 3e       	stdsp	sp[0x1cc],lr

80006090 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80006090:	eb cd 40 c0 	pushm	r6-r7,lr
80006094:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80006096:	49 b8       	lddpc	r8,80006100 <vTaskPriorityInherit+0x70>
80006098:	70 08       	ld.w	r8,r8[0x0]
8000609a:	78 b9       	ld.w	r9,r12[0x2c]
8000609c:	70 b8       	ld.w	r8,r8[0x2c]
8000609e:	10 39       	cp.w	r9,r8
800060a0:	c2 d2       	brcc	800060fa <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800060a2:	49 88       	lddpc	r8,80006100 <vTaskPriorityInherit+0x70>
800060a4:	70 08       	ld.w	r8,r8[0x0]
800060a6:	70 b8       	ld.w	r8,r8[0x2c]
800060a8:	f0 08 11 08 	rsub	r8,r8,8
800060ac:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800060ae:	f2 09 00 28 	add	r8,r9,r9<<0x2
800060b2:	49 59       	lddpc	r9,80006104 <vTaskPriorityInherit+0x74>
800060b4:	f2 08 00 28 	add	r8,r9,r8<<0x2
800060b8:	78 59       	ld.w	r9,r12[0x14]
800060ba:	10 39       	cp.w	r9,r8
800060bc:	c1 b1       	brne	800060f2 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800060be:	f8 c6 ff fc 	sub	r6,r12,-4
800060c2:	0c 9c       	mov	r12,r6
800060c4:	f0 1f 00 11 	mcall	80006108 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800060c8:	48 e8       	lddpc	r8,80006100 <vTaskPriorityInherit+0x70>
800060ca:	70 08       	ld.w	r8,r8[0x0]
800060cc:	70 bc       	ld.w	r12,r8[0x2c]
800060ce:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800060d0:	48 f8       	lddpc	r8,8000610c <vTaskPriorityInherit+0x7c>
800060d2:	70 08       	ld.w	r8,r8[0x0]
800060d4:	10 3c       	cp.w	r12,r8
800060d6:	e0 88 00 04 	brls	800060de <vTaskPriorityInherit+0x4e>
800060da:	48 d8       	lddpc	r8,8000610c <vTaskPriorityInherit+0x7c>
800060dc:	91 0c       	st.w	r8[0x0],r12
800060de:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800060e2:	0c 9b       	mov	r11,r6
800060e4:	48 88       	lddpc	r8,80006104 <vTaskPriorityInherit+0x74>
800060e6:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800060ea:	f0 1f 00 0a 	mcall	80006110 <vTaskPriorityInherit+0x80>
800060ee:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800060f2:	48 48       	lddpc	r8,80006100 <vTaskPriorityInherit+0x70>
800060f4:	70 08       	ld.w	r8,r8[0x0]
800060f6:	70 b8       	ld.w	r8,r8[0x2c]
800060f8:	99 b8       	st.w	r12[0x2c],r8
800060fa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800060fe:	00 00       	add	r0,r0
80006100:	00 00       	add	r0,r0
80006102:	0c d4       	st.w	--r6,r4
80006104:	00 00       	add	r0,r0
80006106:	0c 20       	rsub	r0,r6
80006108:	80 00       	ld.sh	r0,r0[0x0]
8000610a:	57 8e       	stdsp	sp[0x1e0],lr
8000610c:	00 00       	add	r0,r0
8000610e:	0d 3c       	ld.ub	r12,r6++
80006110:	80 00       	ld.sh	r0,r0[0x0]
80006112:	57 3e       	stdsp	sp[0x1cc],lr

80006114 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80006114:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80006118:	78 38       	ld.w	r8,r12[0xc]
8000611a:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
8000611c:	ee c6 ff e8 	sub	r6,r7,-24
80006120:	0c 9c       	mov	r12,r6
80006122:	f0 1f 00 15 	mcall	80006174 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006126:	49 58       	lddpc	r8,80006178 <xTaskRemoveFromEventList+0x64>
80006128:	70 08       	ld.w	r8,r8[0x0]
8000612a:	58 08       	cp.w	r8,0
8000612c:	c1 71       	brne	8000615a <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
8000612e:	ee c6 ff fc 	sub	r6,r7,-4
80006132:	0c 9c       	mov	r12,r6
80006134:	f0 1f 00 10 	mcall	80006174 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80006138:	6e bc       	ld.w	r12,r7[0x2c]
8000613a:	49 18       	lddpc	r8,8000617c <xTaskRemoveFromEventList+0x68>
8000613c:	70 08       	ld.w	r8,r8[0x0]
8000613e:	10 3c       	cp.w	r12,r8
80006140:	e0 88 00 04 	brls	80006148 <xTaskRemoveFromEventList+0x34>
80006144:	48 e8       	lddpc	r8,8000617c <xTaskRemoveFromEventList+0x68>
80006146:	91 0c       	st.w	r8[0x0],r12
80006148:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000614c:	0c 9b       	mov	r11,r6
8000614e:	48 d8       	lddpc	r8,80006180 <xTaskRemoveFromEventList+0x6c>
80006150:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006154:	f0 1f 00 0c 	mcall	80006184 <xTaskRemoveFromEventList+0x70>
80006158:	c0 58       	rjmp	80006162 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000615a:	0c 9b       	mov	r11,r6
8000615c:	48 bc       	lddpc	r12,80006188 <xTaskRemoveFromEventList+0x74>
8000615e:	f0 1f 00 0a 	mcall	80006184 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006162:	48 b8       	lddpc	r8,8000618c <xTaskRemoveFromEventList+0x78>
80006164:	70 08       	ld.w	r8,r8[0x0]
80006166:	6e b9       	ld.w	r9,r7[0x2c]
80006168:	70 b8       	ld.w	r8,r8[0x2c]
8000616a:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
8000616c:	5f 2c       	srhs	r12
8000616e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006172:	00 00       	add	r0,r0
80006174:	80 00       	ld.sh	r0,r0[0x0]
80006176:	57 8e       	stdsp	sp[0x1e0],lr
80006178:	00 00       	add	r0,r0
8000617a:	0d 04       	ld.w	r4,r6++
8000617c:	00 00       	add	r0,r0
8000617e:	0d 3c       	ld.ub	r12,r6++
80006180:	00 00       	add	r0,r0
80006182:	0c 20       	rsub	r0,r6
80006184:	80 00       	ld.sh	r0,r0[0x0]
80006186:	57 3e       	stdsp	sp[0x1cc],lr
80006188:	00 00       	add	r0,r0
8000618a:	0c d8       	st.w	--r6,r8
8000618c:	00 00       	add	r0,r0
8000618e:	0c d4       	st.w	--r6,r4

80006190 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80006190:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006194:	4b 98       	lddpc	r8,80006278 <vTaskIncrementTick+0xe8>
80006196:	70 08       	ld.w	r8,r8[0x0]
80006198:	58 08       	cp.w	r8,0
8000619a:	c6 91       	brne	8000626c <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
8000619c:	4b 88       	lddpc	r8,8000627c <vTaskIncrementTick+0xec>
8000619e:	70 09       	ld.w	r9,r8[0x0]
800061a0:	2f f9       	sub	r9,-1
800061a2:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800061a4:	70 08       	ld.w	r8,r8[0x0]
800061a6:	58 08       	cp.w	r8,0
800061a8:	c1 a1       	brne	800061dc <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800061aa:	4b 68       	lddpc	r8,80006280 <vTaskIncrementTick+0xf0>
800061ac:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800061ae:	4b 69       	lddpc	r9,80006284 <vTaskIncrementTick+0xf4>
800061b0:	72 0b       	ld.w	r11,r9[0x0]
800061b2:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800061b4:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800061b6:	4b 59       	lddpc	r9,80006288 <vTaskIncrementTick+0xf8>
800061b8:	72 0a       	ld.w	r10,r9[0x0]
800061ba:	2f fa       	sub	r10,-1
800061bc:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800061be:	70 08       	ld.w	r8,r8[0x0]
800061c0:	70 08       	ld.w	r8,r8[0x0]
800061c2:	58 08       	cp.w	r8,0
800061c4:	c0 51       	brne	800061ce <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800061c6:	3f f9       	mov	r9,-1
800061c8:	4b 18       	lddpc	r8,8000628c <vTaskIncrementTick+0xfc>
800061ca:	91 09       	st.w	r8[0x0],r9
800061cc:	c0 88       	rjmp	800061dc <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800061ce:	4a d8       	lddpc	r8,80006280 <vTaskIncrementTick+0xf0>
800061d0:	70 08       	ld.w	r8,r8[0x0]
800061d2:	70 38       	ld.w	r8,r8[0xc]
800061d4:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800061d6:	70 19       	ld.w	r9,r8[0x4]
800061d8:	4a d8       	lddpc	r8,8000628c <vTaskIncrementTick+0xfc>
800061da:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800061dc:	4a 88       	lddpc	r8,8000627c <vTaskIncrementTick+0xec>
800061de:	70 09       	ld.w	r9,r8[0x0]
800061e0:	4a b8       	lddpc	r8,8000628c <vTaskIncrementTick+0xfc>
800061e2:	70 08       	ld.w	r8,r8[0x0]
800061e4:	10 39       	cp.w	r9,r8
800061e6:	c4 73       	brcs	80006274 <vTaskIncrementTick+0xe4>
800061e8:	4a 68       	lddpc	r8,80006280 <vTaskIncrementTick+0xf0>
800061ea:	70 08       	ld.w	r8,r8[0x0]
800061ec:	70 08       	ld.w	r8,r8[0x0]
800061ee:	58 08       	cp.w	r8,0
800061f0:	c0 c0       	breq	80006208 <vTaskIncrementTick+0x78>
800061f2:	4a 48       	lddpc	r8,80006280 <vTaskIncrementTick+0xf0>
800061f4:	70 08       	ld.w	r8,r8[0x0]
800061f6:	70 38       	ld.w	r8,r8[0xc]
800061f8:	70 37       	ld.w	r7,r8[0xc]
800061fa:	6e 18       	ld.w	r8,r7[0x4]
800061fc:	4a 09       	lddpc	r9,8000627c <vTaskIncrementTick+0xec>
800061fe:	72 09       	ld.w	r9,r9[0x0]
80006200:	12 38       	cp.w	r8,r9
80006202:	e0 88 00 14 	brls	8000622a <vTaskIncrementTick+0x9a>
80006206:	c0 e8       	rjmp	80006222 <vTaskIncrementTick+0x92>
80006208:	3f f9       	mov	r9,-1
8000620a:	4a 18       	lddpc	r8,8000628c <vTaskIncrementTick+0xfc>
8000620c:	91 09       	st.w	r8[0x0],r9
8000620e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006212:	6a 08       	ld.w	r8,r5[0x0]
80006214:	70 38       	ld.w	r8,r8[0xc]
80006216:	70 37       	ld.w	r7,r8[0xc]
80006218:	6e 18       	ld.w	r8,r7[0x4]
8000621a:	64 09       	ld.w	r9,r2[0x0]
8000621c:	12 38       	cp.w	r8,r9
8000621e:	e0 88 00 0a 	brls	80006232 <vTaskIncrementTick+0xa2>
80006222:	49 b9       	lddpc	r9,8000628c <vTaskIncrementTick+0xfc>
80006224:	93 08       	st.w	r9[0x0],r8
80006226:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000622a:	49 a4       	lddpc	r4,80006290 <vTaskIncrementTick+0x100>
8000622c:	49 a3       	lddpc	r3,80006294 <vTaskIncrementTick+0x104>
8000622e:	49 55       	lddpc	r5,80006280 <vTaskIncrementTick+0xf0>
80006230:	49 32       	lddpc	r2,8000627c <vTaskIncrementTick+0xec>
80006232:	ee c6 ff fc 	sub	r6,r7,-4
80006236:	0c 9c       	mov	r12,r6
80006238:	f0 1f 00 18 	mcall	80006298 <vTaskIncrementTick+0x108>
8000623c:	6e a8       	ld.w	r8,r7[0x28]
8000623e:	58 08       	cp.w	r8,0
80006240:	c0 50       	breq	8000624a <vTaskIncrementTick+0xba>
80006242:	ee cc ff e8 	sub	r12,r7,-24
80006246:	f0 1f 00 15 	mcall	80006298 <vTaskIncrementTick+0x108>
8000624a:	6e bc       	ld.w	r12,r7[0x2c]
8000624c:	68 08       	ld.w	r8,r4[0x0]
8000624e:	10 3c       	cp.w	r12,r8
80006250:	e9 fc ba 00 	st.whi	r4[0x0],r12
80006254:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006258:	0c 9b       	mov	r11,r6
8000625a:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
8000625e:	f0 1f 00 10 	mcall	8000629c <vTaskIncrementTick+0x10c>
80006262:	6a 08       	ld.w	r8,r5[0x0]
80006264:	70 08       	ld.w	r8,r8[0x0]
80006266:	58 08       	cp.w	r8,0
80006268:	cd 51       	brne	80006212 <vTaskIncrementTick+0x82>
8000626a:	cc fb       	rjmp	80006208 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
8000626c:	48 d8       	lddpc	r8,800062a0 <vTaskIncrementTick+0x110>
8000626e:	70 09       	ld.w	r9,r8[0x0]
80006270:	2f f9       	sub	r9,-1
80006272:	91 09       	st.w	r8[0x0],r9
80006274:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006278:	00 00       	add	r0,r0
8000627a:	0d 04       	ld.w	r4,r6++
8000627c:	00 00       	add	r0,r0
8000627e:	0d 00       	ld.w	r0,r6++
80006280:	00 00       	add	r0,r0
80006282:	0c 0c       	add	r12,r6
80006284:	00 00       	add	r0,r0
80006286:	0c 1c       	sub	r12,r6
80006288:	00 00       	add	r0,r0
8000628a:	0c 18       	sub	r8,r6
8000628c:	00 00       	add	r0,r0
8000628e:	05 34       	ld.ub	r4,r2++
80006290:	00 00       	add	r0,r0
80006292:	0d 3c       	ld.ub	r12,r6++
80006294:	00 00       	add	r0,r0
80006296:	0c 20       	rsub	r0,r6
80006298:	80 00       	ld.sh	r0,r0[0x0]
8000629a:	57 8e       	stdsp	sp[0x1e0],lr
8000629c:	80 00       	ld.sh	r0,r0[0x0]
8000629e:	57 3e       	stdsp	sp[0x1cc],lr
800062a0:	00 00       	add	r0,r0
800062a2:	0c 04       	add	r4,r6

800062a4 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800062a4:	eb cd 40 c0 	pushm	r6-r7,lr
800062a8:	18 97       	mov	r7,r12
800062aa:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800062ac:	f0 1f 00 15 	mcall	80006300 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800062b0:	6c 08       	ld.w	r8,r6[0x0]
800062b2:	5b f8       	cp.w	r8,-1
800062b4:	c0 31       	brne	800062ba <xTaskCheckForTimeOut+0x16>
800062b6:	30 07       	mov	r7,0
800062b8:	c1 f8       	rjmp	800062f6 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800062ba:	49 39       	lddpc	r9,80006304 <xTaskCheckForTimeOut+0x60>
800062bc:	72 09       	ld.w	r9,r9[0x0]
800062be:	6e 0a       	ld.w	r10,r7[0x0]
800062c0:	12 3a       	cp.w	r10,r9
800062c2:	c0 70       	breq	800062d0 <xTaskCheckForTimeOut+0x2c>
800062c4:	49 19       	lddpc	r9,80006308 <xTaskCheckForTimeOut+0x64>
800062c6:	72 09       	ld.w	r9,r9[0x0]
800062c8:	6e 1a       	ld.w	r10,r7[0x4]
800062ca:	12 3a       	cp.w	r10,r9
800062cc:	e0 88 00 14 	brls	800062f4 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800062d0:	48 e9       	lddpc	r9,80006308 <xTaskCheckForTimeOut+0x64>
800062d2:	72 0a       	ld.w	r10,r9[0x0]
800062d4:	6e 19       	ld.w	r9,r7[0x4]
800062d6:	12 1a       	sub	r10,r9
800062d8:	14 38       	cp.w	r8,r10
800062da:	e0 88 00 0d 	brls	800062f4 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800062de:	48 ba       	lddpc	r10,80006308 <xTaskCheckForTimeOut+0x64>
800062e0:	74 0a       	ld.w	r10,r10[0x0]
800062e2:	14 19       	sub	r9,r10
800062e4:	f2 08 00 08 	add	r8,r9,r8
800062e8:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
800062ea:	0e 9c       	mov	r12,r7
800062ec:	f0 1f 00 08 	mcall	8000630c <xTaskCheckForTimeOut+0x68>
800062f0:	30 07       	mov	r7,0
800062f2:	c0 28       	rjmp	800062f6 <xTaskCheckForTimeOut+0x52>
800062f4:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
800062f6:	f0 1f 00 07 	mcall	80006310 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
800062fa:	0e 9c       	mov	r12,r7
800062fc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006300:	80 00       	ld.sh	r0,r0[0x0]
80006302:	58 48       	cp.w	r8,4
80006304:	00 00       	add	r0,r0
80006306:	0c 18       	sub	r8,r6
80006308:	00 00       	add	r0,r0
8000630a:	0d 00       	ld.w	r0,r6++
8000630c:	80 00       	ld.sh	r0,r0[0x0]
8000630e:	60 08       	ld.w	r8,r0[0x0]
80006310:	80 00       	ld.sh	r0,r0[0x0]
80006312:	59 54       	cp.w	r4,21

80006314 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80006314:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80006318:	f0 1f 00 05 	mcall	8000632c <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
8000631c:	48 58       	lddpc	r8,80006330 <xTaskGetTickCount+0x1c>
8000631e:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80006320:	f0 1f 00 05 	mcall	80006334 <xTaskGetTickCount+0x20>

	return xTicks;
}
80006324:	0e 9c       	mov	r12,r7
80006326:	e3 cd 80 80 	ldm	sp++,r7,pc
8000632a:	00 00       	add	r0,r0
8000632c:	80 00       	ld.sh	r0,r0[0x0]
8000632e:	58 48       	cp.w	r8,4
80006330:	00 00       	add	r0,r0
80006332:	0d 00       	ld.w	r0,r6++
80006334:	80 00       	ld.sh	r0,r0[0x0]
80006336:	59 54       	cp.w	r4,21

80006338 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80006338:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
8000633c:	f0 1f 00 2c 	mcall	800063ec <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006340:	4a c8       	lddpc	r8,800063f0 <xTaskResumeAll+0xb8>
80006342:	70 09       	ld.w	r9,r8[0x0]
80006344:	20 19       	sub	r9,1
80006346:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006348:	70 08       	ld.w	r8,r8[0x0]
8000634a:	58 08       	cp.w	r8,0
8000634c:	c4 91       	brne	800063de <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
8000634e:	4a a8       	lddpc	r8,800063f4 <xTaskResumeAll+0xbc>
80006350:	70 08       	ld.w	r8,r8[0x0]
80006352:	58 08       	cp.w	r8,0
80006354:	c4 50       	breq	800063de <xTaskResumeAll+0xa6>
80006356:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006358:	4a 85       	lddpc	r5,800063f8 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
8000635a:	4a 93       	lddpc	r3,800063fc <xTaskResumeAll+0xc4>
8000635c:	4a 92       	lddpc	r2,80006400 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000635e:	4a a1       	lddpc	r1,80006404 <xTaskResumeAll+0xcc>
80006360:	c1 e8       	rjmp	8000639c <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80006362:	6a 38       	ld.w	r8,r5[0xc]
80006364:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80006366:	ee cc ff e8 	sub	r12,r7,-24
8000636a:	f0 1f 00 28 	mcall	80006408 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
8000636e:	ee c6 ff fc 	sub	r6,r7,-4
80006372:	0c 9c       	mov	r12,r6
80006374:	f0 1f 00 25 	mcall	80006408 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80006378:	6e bc       	ld.w	r12,r7[0x2c]
8000637a:	66 08       	ld.w	r8,r3[0x0]
8000637c:	10 3c       	cp.w	r12,r8
8000637e:	e7 fc ba 00 	st.whi	r3[0x0],r12
80006382:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006386:	0c 9b       	mov	r11,r6
80006388:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
8000638c:	f0 1f 00 20 	mcall	8000640c <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006390:	62 08       	ld.w	r8,r1[0x0]
80006392:	6e b9       	ld.w	r9,r7[0x2c]
80006394:	70 b8       	ld.w	r8,r8[0x2c]
80006396:	10 39       	cp.w	r9,r8
80006398:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000639c:	6a 08       	ld.w	r8,r5[0x0]
8000639e:	58 08       	cp.w	r8,0
800063a0:	ce 11       	brne	80006362 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800063a2:	49 c8       	lddpc	r8,80006410 <xTaskResumeAll+0xd8>
800063a4:	70 08       	ld.w	r8,r8[0x0]
800063a6:	58 08       	cp.w	r8,0
800063a8:	c0 f0       	breq	800063c6 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800063aa:	49 a8       	lddpc	r8,80006410 <xTaskResumeAll+0xd8>
800063ac:	70 08       	ld.w	r8,r8[0x0]
800063ae:	58 08       	cp.w	r8,0
800063b0:	c1 10       	breq	800063d2 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800063b2:	49 87       	lddpc	r7,80006410 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800063b4:	f0 1f 00 18 	mcall	80006414 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800063b8:	6e 08       	ld.w	r8,r7[0x0]
800063ba:	20 18       	sub	r8,1
800063bc:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800063be:	6e 08       	ld.w	r8,r7[0x0]
800063c0:	58 08       	cp.w	r8,0
800063c2:	cf 91       	brne	800063b4 <xTaskResumeAll+0x7c>
800063c4:	c0 78       	rjmp	800063d2 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800063c6:	58 14       	cp.w	r4,1
800063c8:	c0 50       	breq	800063d2 <xTaskResumeAll+0x9a>
800063ca:	49 48       	lddpc	r8,80006418 <xTaskResumeAll+0xe0>
800063cc:	70 08       	ld.w	r8,r8[0x0]
800063ce:	58 18       	cp.w	r8,1
800063d0:	c0 71       	brne	800063de <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800063d2:	30 09       	mov	r9,0
800063d4:	49 18       	lddpc	r8,80006418 <xTaskResumeAll+0xe0>
800063d6:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800063d8:	d7 33       	scall
800063da:	30 17       	mov	r7,1
800063dc:	c0 28       	rjmp	800063e0 <xTaskResumeAll+0xa8>
800063de:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800063e0:	f0 1f 00 0f 	mcall	8000641c <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
800063e4:	0e 9c       	mov	r12,r7
800063e6:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800063ea:	00 00       	add	r0,r0
800063ec:	80 00       	ld.sh	r0,r0[0x0]
800063ee:	58 48       	cp.w	r8,4
800063f0:	00 00       	add	r0,r0
800063f2:	0d 04       	ld.w	r4,r6++
800063f4:	00 00       	add	r0,r0
800063f6:	0d 20       	ld.uh	r0,r6++
800063f8:	00 00       	add	r0,r0
800063fa:	0c d8       	st.w	--r6,r8
800063fc:	00 00       	add	r0,r0
800063fe:	0d 3c       	ld.ub	r12,r6++
80006400:	00 00       	add	r0,r0
80006402:	0c 20       	rsub	r0,r6
80006404:	00 00       	add	r0,r0
80006406:	0c d4       	st.w	--r6,r4
80006408:	80 00       	ld.sh	r0,r0[0x0]
8000640a:	57 8e       	stdsp	sp[0x1e0],lr
8000640c:	80 00       	ld.sh	r0,r0[0x0]
8000640e:	57 3e       	stdsp	sp[0x1cc],lr
80006410:	00 00       	add	r0,r0
80006412:	0c 04       	add	r4,r6
80006414:	80 00       	ld.sh	r0,r0[0x0]
80006416:	61 90       	ld.w	r0,r0[0x64]
80006418:	00 00       	add	r0,r0
8000641a:	0d 24       	ld.uh	r4,r6++
8000641c:	80 00       	ld.sh	r0,r0[0x0]
8000641e:	59 54       	cp.w	r4,21

80006420 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006420:	eb cd 40 80 	pushm	r7,lr
80006424:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80006426:	49 08       	lddpc	r8,80006464 <prvAddCurrentTaskToDelayedList+0x44>
80006428:	70 08       	ld.w	r8,r8[0x0]
8000642a:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
8000642c:	48 f8       	lddpc	r8,80006468 <prvAddCurrentTaskToDelayedList+0x48>
8000642e:	70 08       	ld.w	r8,r8[0x0]
80006430:	10 3c       	cp.w	r12,r8
80006432:	c0 a2       	brcc	80006446 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006434:	48 c8       	lddpc	r8,80006464 <prvAddCurrentTaskToDelayedList+0x44>
80006436:	70 0b       	ld.w	r11,r8[0x0]
80006438:	48 d8       	lddpc	r8,8000646c <prvAddCurrentTaskToDelayedList+0x4c>
8000643a:	70 0c       	ld.w	r12,r8[0x0]
8000643c:	2f cb       	sub	r11,-4
8000643e:	f0 1f 00 0d 	mcall	80006470 <prvAddCurrentTaskToDelayedList+0x50>
80006442:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006446:	48 88       	lddpc	r8,80006464 <prvAddCurrentTaskToDelayedList+0x44>
80006448:	70 0b       	ld.w	r11,r8[0x0]
8000644a:	48 b8       	lddpc	r8,80006474 <prvAddCurrentTaskToDelayedList+0x54>
8000644c:	70 0c       	ld.w	r12,r8[0x0]
8000644e:	2f cb       	sub	r11,-4
80006450:	f0 1f 00 08 	mcall	80006470 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006454:	48 98       	lddpc	r8,80006478 <prvAddCurrentTaskToDelayedList+0x58>
80006456:	70 08       	ld.w	r8,r8[0x0]
80006458:	10 37       	cp.w	r7,r8
8000645a:	c0 32       	brcc	80006460 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
8000645c:	48 78       	lddpc	r8,80006478 <prvAddCurrentTaskToDelayedList+0x58>
8000645e:	91 07       	st.w	r8[0x0],r7
80006460:	e3 cd 80 80 	ldm	sp++,r7,pc
80006464:	00 00       	add	r0,r0
80006466:	0c d4       	st.w	--r6,r4
80006468:	00 00       	add	r0,r0
8000646a:	0d 00       	ld.w	r0,r6++
8000646c:	00 00       	add	r0,r0
8000646e:	0c 1c       	sub	r12,r6
80006470:	80 00       	ld.sh	r0,r0[0x0]
80006472:	57 5a       	stdsp	sp[0x1d4],r10
80006474:	00 00       	add	r0,r0
80006476:	0c 0c       	add	r12,r6
80006478:	00 00       	add	r0,r0
8000647a:	05 34       	ld.ub	r4,r2++

8000647c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
8000647c:	eb cd 40 c0 	pushm	r6-r7,lr
80006480:	18 96       	mov	r6,r12
80006482:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80006484:	f0 1f 00 18 	mcall	800064e4 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80006488:	6c 08       	ld.w	r8,r6[0x0]
8000648a:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
8000648c:	49 79       	lddpc	r9,800064e8 <vTaskDelayUntil+0x6c>
8000648e:	72 09       	ld.w	r9,r9[0x0]
80006490:	12 38       	cp.w	r8,r9
80006492:	e0 88 00 0c 	brls	800064aa <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80006496:	0e 38       	cp.w	r8,r7
80006498:	e0 88 00 22 	brls	800064dc <vTaskDelayUntil+0x60>
8000649c:	49 38       	lddpc	r8,800064e8 <vTaskDelayUntil+0x6c>
8000649e:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800064a0:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
800064a2:	10 37       	cp.w	r7,r8
800064a4:	e0 88 00 14 	brls	800064cc <vTaskDelayUntil+0x50>
800064a8:	c0 a8       	rjmp	800064bc <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
800064aa:	0e 38       	cp.w	r8,r7
800064ac:	e0 8b 00 16 	brhi	800064d8 <vTaskDelayUntil+0x5c>
800064b0:	48 e8       	lddpc	r8,800064e8 <vTaskDelayUntil+0x6c>
800064b2:	70 08       	ld.w	r8,r8[0x0]
800064b4:	10 37       	cp.w	r7,r8
800064b6:	e0 8b 00 11 	brhi	800064d8 <vTaskDelayUntil+0x5c>
800064ba:	c1 18       	rjmp	800064dc <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800064bc:	48 c8       	lddpc	r8,800064ec <vTaskDelayUntil+0x70>
800064be:	70 0c       	ld.w	r12,r8[0x0]
800064c0:	2f cc       	sub	r12,-4
800064c2:	f0 1f 00 0c 	mcall	800064f0 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800064c6:	0e 9c       	mov	r12,r7
800064c8:	f0 1f 00 0b 	mcall	800064f4 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
800064cc:	f0 1f 00 0b 	mcall	800064f8 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800064d0:	c0 81       	brne	800064e0 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
800064d2:	d7 33       	scall
800064d4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800064d8:	8d 07       	st.w	r6[0x0],r7
800064da:	cf 1b       	rjmp	800064bc <vTaskDelayUntil+0x40>
800064dc:	8d 07       	st.w	r6[0x0],r7
800064de:	cf 7b       	rjmp	800064cc <vTaskDelayUntil+0x50>
800064e0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800064e4:	80 00       	ld.sh	r0,r0[0x0]
800064e6:	5f 7c       	srpl	r12
800064e8:	00 00       	add	r0,r0
800064ea:	0d 00       	ld.w	r0,r6++
800064ec:	00 00       	add	r0,r0
800064ee:	0c d4       	st.w	--r6,r4
800064f0:	80 00       	ld.sh	r0,r0[0x0]
800064f2:	57 8e       	stdsp	sp[0x1e0],lr
800064f4:	80 00       	ld.sh	r0,r0[0x0]
800064f6:	64 20       	ld.w	r0,r2[0x8]
800064f8:	80 00       	ld.sh	r0,r0[0x0]
800064fa:	63 38       	ld.w	r8,r1[0x4c]

800064fc <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
800064fc:	eb cd 40 c0 	pushm	r6-r7,lr
80006500:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006502:	48 e7       	lddpc	r7,80006538 <vTaskPlaceOnEventList+0x3c>
80006504:	6e 0b       	ld.w	r11,r7[0x0]
80006506:	2e 8b       	sub	r11,-24
80006508:	f0 1f 00 0d 	mcall	8000653c <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000650c:	6e 0c       	ld.w	r12,r7[0x0]
8000650e:	2f cc       	sub	r12,-4
80006510:	f0 1f 00 0c 	mcall	80006540 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006514:	5b f6       	cp.w	r6,-1
80006516:	c0 81       	brne	80006526 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006518:	6e 0b       	ld.w	r11,r7[0x0]
8000651a:	2f cb       	sub	r11,-4
8000651c:	48 ac       	lddpc	r12,80006544 <vTaskPlaceOnEventList+0x48>
8000651e:	f0 1f 00 0b 	mcall	80006548 <vTaskPlaceOnEventList+0x4c>
80006522:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006526:	48 a8       	lddpc	r8,8000654c <vTaskPlaceOnEventList+0x50>
80006528:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
8000652a:	ec 0c 00 0c 	add	r12,r6,r12
8000652e:	f0 1f 00 09 	mcall	80006550 <vTaskPlaceOnEventList+0x54>
80006532:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006536:	00 00       	add	r0,r0
80006538:	00 00       	add	r0,r0
8000653a:	0c d4       	st.w	--r6,r4
8000653c:	80 00       	ld.sh	r0,r0[0x0]
8000653e:	57 5a       	stdsp	sp[0x1d4],r10
80006540:	80 00       	ld.sh	r0,r0[0x0]
80006542:	57 8e       	stdsp	sp[0x1e0],lr
80006544:	00 00       	add	r0,r0
80006546:	0d 28       	ld.uh	r8,r6++
80006548:	80 00       	ld.sh	r0,r0[0x0]
8000654a:	57 3e       	stdsp	sp[0x1cc],lr
8000654c:	00 00       	add	r0,r0
8000654e:	0d 00       	ld.w	r0,r6++
80006550:	80 00       	ld.sh	r0,r0[0x0]
80006552:	64 20       	ld.w	r0,r2[0x8]

80006554 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006554:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006558:	49 67       	lddpc	r7,800065b0 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000655a:	49 74       	lddpc	r4,800065b4 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
8000655c:	49 73       	lddpc	r3,800065b8 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
8000655e:	49 85       	lddpc	r5,800065bc <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006560:	6e 08       	ld.w	r8,r7[0x0]
80006562:	58 08       	cp.w	r8,0
80006564:	c1 e0       	breq	800065a0 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80006566:	f0 1f 00 17 	mcall	800065c0 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000656a:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
8000656c:	f0 1f 00 16 	mcall	800065c4 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006570:	58 06       	cp.w	r6,0
80006572:	c1 70       	breq	800065a0 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006574:	f0 1f 00 15 	mcall	800065c8 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006578:	68 38       	ld.w	r8,r4[0xc]
8000657a:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
8000657c:	ec cc ff fc 	sub	r12,r6,-4
80006580:	f0 1f 00 13 	mcall	800065cc <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80006584:	66 08       	ld.w	r8,r3[0x0]
80006586:	20 18       	sub	r8,1
80006588:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
8000658a:	6e 08       	ld.w	r8,r7[0x0]
8000658c:	20 18       	sub	r8,1
8000658e:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006590:	f0 1f 00 10 	mcall	800065d0 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006594:	6c cc       	ld.w	r12,r6[0x30]
80006596:	f0 1f 00 10 	mcall	800065d4 <prvIdleTask+0x80>
		vPortFree( pxTCB );
8000659a:	0c 9c       	mov	r12,r6
8000659c:	f0 1f 00 0e 	mcall	800065d4 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800065a0:	6a 08       	ld.w	r8,r5[0x0]
800065a2:	58 18       	cp.w	r8,1
800065a4:	e0 88 00 03 	brls	800065aa <prvIdleTask+0x56>
			{
				taskYIELD();
800065a8:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
800065aa:	f0 1f 00 0c 	mcall	800065d8 <prvIdleTask+0x84>
		}
		#endif
	}
800065ae:	cd 9b       	rjmp	80006560 <prvIdleTask+0xc>
800065b0:	00 00       	add	r0,r0
800065b2:	0c 14       	sub	r4,r6
800065b4:	00 00       	add	r0,r0
800065b6:	0c c0       	st.b	r6++,r0
800065b8:	00 00       	add	r0,r0
800065ba:	0d 20       	ld.uh	r0,r6++
800065bc:	00 00       	add	r0,r0
800065be:	0c 20       	rsub	r0,r6
800065c0:	80 00       	ld.sh	r0,r0[0x0]
800065c2:	5f 7c       	srpl	r12
800065c4:	80 00       	ld.sh	r0,r0[0x0]
800065c6:	63 38       	ld.w	r8,r1[0x4c]
800065c8:	80 00       	ld.sh	r0,r0[0x0]
800065ca:	58 48       	cp.w	r8,4
800065cc:	80 00       	ld.sh	r0,r0[0x0]
800065ce:	57 8e       	stdsp	sp[0x1e0],lr
800065d0:	80 00       	ld.sh	r0,r0[0x0]
800065d2:	59 54       	cp.w	r4,21
800065d4:	80 00       	ld.sh	r0,r0[0x0]
800065d6:	5a 8c       	cp.w	r12,-24
800065d8:	80 00       	ld.sh	r0,r0[0x0]
800065da:	20 2c       	sub	r12,2

800065dc <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
800065dc:	d4 31       	pushm	r0-r7,lr
800065de:	20 1d       	sub	sp,4
800065e0:	fa c4 ff d8 	sub	r4,sp,-40
800065e4:	50 0c       	stdsp	sp[0x0],r12
800065e6:	16 91       	mov	r1,r11
800065e8:	14 97       	mov	r7,r10
800065ea:	12 90       	mov	r0,r9
800065ec:	10 93       	mov	r3,r8
800065ee:	68 02       	ld.w	r2,r4[0x0]
800065f0:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
800065f2:	34 8c       	mov	r12,72
800065f4:	f0 1f 00 5c 	mcall	80006764 <xTaskGenericCreate+0x188>
800065f8:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
800065fa:	c0 31       	brne	80006600 <xTaskGenericCreate+0x24>
800065fc:	3f fc       	mov	r12,-1
800065fe:	ca f8       	rjmp	8000675c <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006600:	58 06       	cp.w	r6,0
80006602:	e0 81 00 af 	brne	80006760 <xTaskGenericCreate+0x184>
80006606:	0e 9c       	mov	r12,r7
80006608:	5c 7c       	castu.h	r12
8000660a:	a3 6c       	lsl	r12,0x2
8000660c:	f0 1f 00 56 	mcall	80006764 <xTaskGenericCreate+0x188>
80006610:	18 96       	mov	r6,r12
80006612:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006614:	c0 61       	brne	80006620 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006616:	0a 9c       	mov	r12,r5
80006618:	f0 1f 00 54 	mcall	80006768 <xTaskGenericCreate+0x18c>
8000661c:	3f fc       	mov	r12,-1
8000661e:	c9 f8       	rjmp	8000675c <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006620:	5c 77       	castu.h	r7
80006622:	ee 0a 15 02 	lsl	r10,r7,0x2
80006626:	e0 6b 00 a5 	mov	r11,165
8000662a:	0c 9c       	mov	r12,r6
8000662c:	f0 1f 00 50 	mcall	8000676c <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006630:	ee c6 00 01 	sub	r6,r7,1
80006634:	6a c8       	ld.w	r8,r5[0x30]
80006636:	f0 06 00 26 	add	r6,r8,r6<<0x2
8000663a:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
8000663e:	31 0a       	mov	r10,16
80006640:	02 9b       	mov	r11,r1
80006642:	ea cc ff cc 	sub	r12,r5,-52
80006646:	f0 1f 00 4b 	mcall	80006770 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
8000664a:	30 08       	mov	r8,0
8000664c:	eb 68 00 43 	st.b	r5[67],r8
80006650:	58 73       	cp.w	r3,7
80006652:	e6 07 17 80 	movls	r7,r3
80006656:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
8000665a:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
8000665c:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006660:	ea c4 ff fc 	sub	r4,r5,-4
80006664:	08 9c       	mov	r12,r4
80006666:	f0 1f 00 44 	mcall	80006774 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
8000666a:	ea cc ff e8 	sub	r12,r5,-24
8000666e:	f0 1f 00 42 	mcall	80006774 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006672:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006674:	ee 07 11 08 	rsub	r7,r7,8
80006678:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
8000667a:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
8000667c:	00 9a       	mov	r10,r0
8000667e:	40 0b       	lddsp	r11,sp[0x0]
80006680:	0c 9c       	mov	r12,r6
80006682:	f0 1f 00 3e 	mcall	80006778 <xTaskGenericCreate+0x19c>
80006686:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006688:	58 02       	cp.w	r2,0
8000668a:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
8000668e:	f0 1f 00 3c 	mcall	8000677c <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006692:	4b c8       	lddpc	r8,80006780 <xTaskGenericCreate+0x1a4>
80006694:	70 09       	ld.w	r9,r8[0x0]
80006696:	2f f9       	sub	r9,-1
80006698:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
8000669a:	4b b8       	lddpc	r8,80006784 <xTaskGenericCreate+0x1a8>
8000669c:	70 08       	ld.w	r8,r8[0x0]
8000669e:	58 08       	cp.w	r8,0
800066a0:	c2 61       	brne	800066ec <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
800066a2:	4b 98       	lddpc	r8,80006784 <xTaskGenericCreate+0x1a8>
800066a4:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
800066a6:	4b 78       	lddpc	r8,80006780 <xTaskGenericCreate+0x1a4>
800066a8:	70 08       	ld.w	r8,r8[0x0]
800066aa:	58 18       	cp.w	r8,1
800066ac:	c2 b1       	brne	80006702 <xTaskGenericCreate+0x126>
800066ae:	4b 77       	lddpc	r7,80006788 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
800066b0:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
800066b4:	0e 9c       	mov	r12,r7
800066b6:	f0 1f 00 36 	mcall	8000678c <xTaskGenericCreate+0x1b0>
800066ba:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
800066bc:	0c 37       	cp.w	r7,r6
800066be:	cf b1       	brne	800066b4 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
800066c0:	4b 47       	lddpc	r7,80006790 <xTaskGenericCreate+0x1b4>
800066c2:	0e 9c       	mov	r12,r7
800066c4:	f0 1f 00 32 	mcall	8000678c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
800066c8:	4b 36       	lddpc	r6,80006794 <xTaskGenericCreate+0x1b8>
800066ca:	0c 9c       	mov	r12,r6
800066cc:	f0 1f 00 30 	mcall	8000678c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
800066d0:	4b 2c       	lddpc	r12,80006798 <xTaskGenericCreate+0x1bc>
800066d2:	f0 1f 00 2f 	mcall	8000678c <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
800066d6:	4b 2c       	lddpc	r12,8000679c <xTaskGenericCreate+0x1c0>
800066d8:	f0 1f 00 2d 	mcall	8000678c <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
800066dc:	4b 1c       	lddpc	r12,800067a0 <xTaskGenericCreate+0x1c4>
800066de:	f0 1f 00 2c 	mcall	8000678c <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
800066e2:	4b 18       	lddpc	r8,800067a4 <xTaskGenericCreate+0x1c8>
800066e4:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
800066e6:	4b 18       	lddpc	r8,800067a8 <xTaskGenericCreate+0x1cc>
800066e8:	91 06       	st.w	r8[0x0],r6
800066ea:	c0 c8       	rjmp	80006702 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
800066ec:	4b 08       	lddpc	r8,800067ac <xTaskGenericCreate+0x1d0>
800066ee:	70 08       	ld.w	r8,r8[0x0]
800066f0:	58 08       	cp.w	r8,0
800066f2:	c0 81       	brne	80006702 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
800066f4:	4a 48       	lddpc	r8,80006784 <xTaskGenericCreate+0x1a8>
800066f6:	70 08       	ld.w	r8,r8[0x0]
800066f8:	70 b8       	ld.w	r8,r8[0x2c]
800066fa:	10 33       	cp.w	r3,r8
800066fc:	c0 33       	brcs	80006702 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
800066fe:	4a 28       	lddpc	r8,80006784 <xTaskGenericCreate+0x1a8>
80006700:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006702:	6a b8       	ld.w	r8,r5[0x2c]
80006704:	4a b9       	lddpc	r9,800067b0 <xTaskGenericCreate+0x1d4>
80006706:	72 09       	ld.w	r9,r9[0x0]
80006708:	12 38       	cp.w	r8,r9
8000670a:	e0 88 00 04 	brls	80006712 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
8000670e:	4a 99       	lddpc	r9,800067b0 <xTaskGenericCreate+0x1d4>
80006710:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006712:	4a 98       	lddpc	r8,800067b4 <xTaskGenericCreate+0x1d8>
80006714:	70 09       	ld.w	r9,r8[0x0]
80006716:	2f f9       	sub	r9,-1
80006718:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
8000671a:	6a b8       	ld.w	r8,r5[0x2c]
8000671c:	4a 79       	lddpc	r9,800067b8 <xTaskGenericCreate+0x1dc>
8000671e:	72 09       	ld.w	r9,r9[0x0]
80006720:	12 38       	cp.w	r8,r9
80006722:	e0 88 00 04 	brls	8000672a <xTaskGenericCreate+0x14e>
80006726:	4a 59       	lddpc	r9,800067b8 <xTaskGenericCreate+0x1dc>
80006728:	93 08       	st.w	r9[0x0],r8
8000672a:	6a bc       	ld.w	r12,r5[0x2c]
8000672c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006730:	08 9b       	mov	r11,r4
80006732:	49 68       	lddpc	r8,80006788 <xTaskGenericCreate+0x1ac>
80006734:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006738:	f0 1f 00 21 	mcall	800067bc <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
8000673c:	f0 1f 00 21 	mcall	800067c0 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006740:	49 b8       	lddpc	r8,800067ac <xTaskGenericCreate+0x1d0>
80006742:	70 08       	ld.w	r8,r8[0x0]
80006744:	58 08       	cp.w	r8,0
80006746:	c0 a0       	breq	8000675a <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006748:	48 f8       	lddpc	r8,80006784 <xTaskGenericCreate+0x1a8>
8000674a:	70 08       	ld.w	r8,r8[0x0]
8000674c:	70 b8       	ld.w	r8,r8[0x2c]
8000674e:	10 33       	cp.w	r3,r8
80006750:	e0 88 00 05 	brls	8000675a <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006754:	d7 33       	scall
80006756:	30 1c       	mov	r12,1
80006758:	c0 28       	rjmp	8000675c <xTaskGenericCreate+0x180>
8000675a:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
8000675c:	2f fd       	sub	sp,-4
8000675e:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006760:	99 c6       	st.w	r12[0x30],r6
80006762:	c5 fb       	rjmp	80006620 <xTaskGenericCreate+0x44>
80006764:	80 00       	ld.sh	r0,r0[0x0]
80006766:	5a b4       	cp.w	r4,-21
80006768:	80 00       	ld.sh	r0,r0[0x0]
8000676a:	5a 8c       	cp.w	r12,-24
8000676c:	80 00       	ld.sh	r0,r0[0x0]
8000676e:	73 7c       	ld.w	r12,r9[0x5c]
80006770:	80 00       	ld.sh	r0,r0[0x0]
80006772:	76 a8       	ld.w	r8,r11[0x28]
80006774:	80 00       	ld.sh	r0,r0[0x0]
80006776:	57 38       	stdsp	sp[0x1cc],r8
80006778:	80 00       	ld.sh	r0,r0[0x0]
8000677a:	57 b4       	stdsp	sp[0x1ec],r4
8000677c:	80 00       	ld.sh	r0,r0[0x0]
8000677e:	58 48       	cp.w	r8,4
80006780:	00 00       	add	r0,r0
80006782:	0d 20       	ld.uh	r0,r6++
80006784:	00 00       	add	r0,r0
80006786:	0c d4       	st.w	--r6,r4
80006788:	00 00       	add	r0,r0
8000678a:	0c 20       	rsub	r0,r6
8000678c:	80 00       	ld.sh	r0,r0[0x0]
8000678e:	57 24       	stdsp	sp[0x1c8],r4
80006790:	00 00       	add	r0,r0
80006792:	0c ec       	st.h	--r6,r12
80006794:	00 00       	add	r0,r0
80006796:	0d 08       	ld.w	r8,r6++
80006798:	00 00       	add	r0,r0
8000679a:	0c d8       	st.w	--r6,r8
8000679c:	00 00       	add	r0,r0
8000679e:	0c c0       	st.b	r6++,r0
800067a0:	00 00       	add	r0,r0
800067a2:	0d 28       	ld.uh	r8,r6++
800067a4:	00 00       	add	r0,r0
800067a6:	0c 0c       	add	r12,r6
800067a8:	00 00       	add	r0,r0
800067aa:	0c 1c       	sub	r12,r6
800067ac:	00 00       	add	r0,r0
800067ae:	0c 10       	sub	r0,r6
800067b0:	00 00       	add	r0,r0
800067b2:	0c 08       	add	r8,r6
800067b4:	00 00       	add	r0,r0
800067b6:	0d 1c       	ld.sh	r12,r6++
800067b8:	00 00       	add	r0,r0
800067ba:	0d 3c       	ld.ub	r12,r6++
800067bc:	80 00       	ld.sh	r0,r0[0x0]
800067be:	57 3e       	stdsp	sp[0x1cc],lr
800067c0:	80 00       	ld.sh	r0,r0[0x0]
800067c2:	59 54       	cp.w	r4,21

800067c4 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
800067c4:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
800067c6:	30 09       	mov	r9,0
800067c8:	1a d9       	st.w	--sp,r9
800067ca:	1a d9       	st.w	--sp,r9
800067cc:	1a d9       	st.w	--sp,r9
800067ce:	12 98       	mov	r8,r9
800067d0:	e0 6a 01 00 	mov	r10,256
800067d4:	48 9b       	lddpc	r11,800067f8 <vTaskStartScheduler+0x34>
800067d6:	48 ac       	lddpc	r12,800067fc <vTaskStartScheduler+0x38>
800067d8:	f0 1f 00 0a 	mcall	80006800 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
800067dc:	2f dd       	sub	sp,-12
800067de:	58 1c       	cp.w	r12,1
800067e0:	c0 a1       	brne	800067f4 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
800067e2:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
800067e4:	30 19       	mov	r9,1
800067e6:	48 88       	lddpc	r8,80006804 <vTaskStartScheduler+0x40>
800067e8:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
800067ea:	30 09       	mov	r9,0
800067ec:	48 78       	lddpc	r8,80006808 <vTaskStartScheduler+0x44>
800067ee:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
800067f0:	f0 1f 00 07 	mcall	8000680c <vTaskStartScheduler+0x48>
800067f4:	d8 02       	popm	pc
800067f6:	00 00       	add	r0,r0
800067f8:	80 00       	ld.sh	r0,r0[0x0]
800067fa:	d2 a0       	acall	0x2a
800067fc:	80 00       	ld.sh	r0,r0[0x0]
800067fe:	65 54       	ld.w	r4,r2[0x54]
80006800:	80 00       	ld.sh	r0,r0[0x0]
80006802:	65 dc       	ld.w	r12,r2[0x74]
80006804:	00 00       	add	r0,r0
80006806:	0c 10       	sub	r0,r6
80006808:	00 00       	add	r0,r0
8000680a:	0d 00       	ld.w	r0,r6++
8000680c:	80 00       	ld.sh	r0,r0[0x0]
8000680e:	58 58       	cp.w	r8,5

80006810 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006810:	16 cc       	st.b	r11++,r12
	return str;
}
80006812:	5e fb       	retal	r11

80006814 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006814:	eb cd 40 c0 	pushm	r6-r7,lr
80006818:	20 3d       	sub	sp,12
8000681a:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
8000681c:	30 06       	mov	r6,0
8000681e:	30 07       	mov	r7,0
80006820:	fa e7 00 00 	st.d	sp[0],r6
80006824:	30 0c       	mov	r12,0
80006826:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006828:	58 08       	cp.w	r8,0
8000682a:	c1 30       	breq	80006850 <PrintHex+0x3c>
8000682c:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
8000682e:	1a 9c       	mov	r12,sp
80006830:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006834:	58 9e       	cp.w	lr,9
80006836:	e0 8a 00 04 	brle	8000683e <PrintHex+0x2a>
8000683a:	2c 9e       	sub	lr,-55
8000683c:	c0 48       	rjmp	80006844 <PrintHex+0x30>
8000683e:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006842:	2d 0e       	sub	lr,-48
80006844:	f8 09 0b 0e 	st.b	r12[r9],lr
80006848:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
8000684a:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
8000684c:	cf 21       	brne	80006830 <PrintHex+0x1c>
8000684e:	c0 48       	rjmp	80006856 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006850:	33 08       	mov	r8,48
80006852:	ba 88       	st.b	sp[0x0],r8
80006854:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006856:	f6 09 01 08 	sub	r8,r11,r9
8000685a:	58 08       	cp.w	r8,0
8000685c:	e0 8a 00 13 	brle	80006882 <PrintHex+0x6e>
	{
		char num = len - cnt;
80006860:	12 1b       	sub	r11,r9
80006862:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006866:	18 9e       	mov	lr,r12
80006868:	58 0c       	cp.w	r12,0
8000686a:	e0 8a 00 0c 	brle	80006882 <PrintHex+0x6e>
8000686e:	1a 9b       	mov	r11,sp
80006870:	12 0b       	add	r11,r9
80006872:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006874:	33 07       	mov	r7,48
80006876:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006878:	2f f8       	sub	r8,-1
8000687a:	1c 38       	cp.w	r8,lr
8000687c:	cf d5       	brlt	80006876 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000687e:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006882:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006886:	f0 cb ff ff 	sub	r11,r8,-1
8000688a:	58 0b       	cp.w	r11,0
8000688c:	e0 8a 00 19 	brle	800068be <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006890:	fa cb ff f4 	sub	r11,sp,-12
80006894:	f6 09 00 09 	add	r9,r11,r9
80006898:	37 8b       	mov	r11,120
8000689a:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
8000689e:	fa c9 ff f4 	sub	r9,sp,-12
800068a2:	10 09       	add	r9,r8
800068a4:	33 0b       	mov	r11,48
800068a6:	f3 6b ff f4 	st.b	r9[-12],r11
800068aa:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
800068ae:	fa ce 00 01 	sub	lr,sp,1
800068b2:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
800068b4:	11 8b       	ld.ub	r11,r8[0x0]
800068b6:	12 cb       	st.b	r9++,r11
800068b8:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
800068ba:	1c 38       	cp.w	r8,lr
800068bc:	cf c1       	brne	800068b4 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
800068be:	14 9c       	mov	r12,r10
800068c0:	2f dd       	sub	sp,-12
800068c2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

800068c6 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
800068c6:	d4 21       	pushm	r4-r7,lr
800068c8:	20 3d       	sub	sp,12
800068ca:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
800068cc:	30 06       	mov	r6,0
800068ce:	30 07       	mov	r7,0
800068d0:	fa e7 00 00 	st.d	sp[0],r6
800068d4:	30 0c       	mov	r12,0
800068d6:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
800068d8:	58 08       	cp.w	r8,0
800068da:	c0 35       	brlt	800068e0 <PrintDec+0x1a>
800068dc:	14 97       	mov	r7,r10
800068de:	c0 58       	rjmp	800068e8 <PrintDec+0x22>
	{
		*p++ = '-';
800068e0:	14 97       	mov	r7,r10
800068e2:	32 d9       	mov	r9,45
800068e4:	0e c9       	st.b	r7++,r9
		i = -i;
800068e6:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
800068e8:	58 08       	cp.w	r8,0
800068ea:	c0 51       	brne	800068f4 <PrintDec+0x2e>
800068ec:	33 08       	mov	r8,48
800068ee:	ba 88       	st.b	sp[0x0],r8
800068f0:	30 1e       	mov	lr,1
800068f2:	c2 f8       	rjmp	80006950 <PrintDec+0x8a>
	
	int ten = i%10;
800068f4:	e0 65 66 67 	mov	r5,26215
800068f8:	ea 15 66 66 	orh	r5,0x6666
800068fc:	f0 05 04 44 	muls.d	r4,r8,r5
80006900:	ea 0c 14 02 	asr	r12,r5,0x2
80006904:	f0 09 14 1f 	asr	r9,r8,0x1f
80006908:	f8 09 01 09 	sub	r9,r12,r9
8000690c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006910:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006914:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006916:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006918:	e0 66 66 67 	mov	r6,26215
8000691c:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006920:	2d 09       	sub	r9,-48
80006922:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006926:	2f fe       	sub	lr,-1
		i /= 10;
80006928:	f0 06 04 44 	muls.d	r4,r8,r6
8000692c:	ea 09 14 02 	asr	r9,r5,0x2
80006930:	bf 58       	asr	r8,0x1f
80006932:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006936:	f0 06 04 44 	muls.d	r4,r8,r6
8000693a:	ea 09 14 02 	asr	r9,r5,0x2
8000693e:	f0 05 14 1f 	asr	r5,r8,0x1f
80006942:	0a 19       	sub	r9,r5
80006944:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006948:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
8000694c:	58 08       	cp.w	r8,0
8000694e:	ce 91       	brne	80006920 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006950:	f6 0e 01 08 	sub	r8,r11,lr
80006954:	58 08       	cp.w	r8,0
80006956:	e0 89 00 06 	brgt	80006962 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000695a:	58 0e       	cp.w	lr,0
8000695c:	e0 89 00 14 	brgt	80006984 <PrintDec+0xbe>
80006960:	c1 d8       	rjmp	8000699a <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006962:	1c 1b       	sub	r11,lr
80006964:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006966:	16 9c       	mov	r12,r11
80006968:	58 0b       	cp.w	r11,0
8000696a:	fe 9a ff f8 	brle	8000695a <PrintDec+0x94>
8000696e:	1a 99       	mov	r9,sp
80006970:	1c 09       	add	r9,lr
80006972:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006974:	33 06       	mov	r6,48
80006976:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006978:	2f f8       	sub	r8,-1
8000697a:	18 38       	cp.w	r8,r12
8000697c:	cf d5       	brlt	80006976 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
8000697e:	f6 0e 00 0e 	add	lr,r11,lr
80006982:	ce cb       	rjmp	8000695a <PrintDec+0x94>
80006984:	fa c8 ff f4 	sub	r8,sp,-12
80006988:	1c 08       	add	r8,lr
8000698a:	20 d8       	sub	r8,13
8000698c:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006990:	11 89       	ld.ub	r9,r8[0x0]
80006992:	0e c9       	st.b	r7++,r9
80006994:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006996:	16 38       	cp.w	r8,r11
80006998:	cf c1       	brne	80006990 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
8000699a:	14 9c       	mov	r12,r10
8000699c:	2f dd       	sub	sp,-12
8000699e:	d8 22       	popm	r4-r7,pc

800069a0 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
800069a0:	d4 31       	pushm	r0-r7,lr
800069a2:	fa cd 02 08 	sub	sp,sp,520
800069a6:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
800069a8:	e0 6a 01 00 	mov	r10,256
800069ac:	30 0b       	mov	r11,0
800069ae:	fa cc fe f8 	sub	r12,sp,-264
800069b2:	f0 1f 00 4e 	mcall	80006ae8 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
800069b6:	fa c4 fd d4 	sub	r4,sp,-556
800069ba:	30 0a       	mov	r10,0
800069bc:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800069be:	fa c3 ff fc 	sub	r3,sp,-4
800069c2:	e0 61 01 00 	mov	r1,256
800069c6:	14 90       	mov	r0,r10
			
					if(*str == '%')
800069c8:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800069ca:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800069ce:	02 9a       	mov	r10,r1
800069d0:	00 9b       	mov	r11,r0
800069d2:	06 9c       	mov	r12,r3
800069d4:	f0 1f 00 45 	mcall	80006ae8 <log+0x148>
			
					if(*str == '%')
800069d8:	0f 88       	ld.ub	r8,r7[0x0]
800069da:	e4 08 18 00 	cp.b	r8,r2
800069de:	c5 71       	brne	80006a8c <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
800069e0:	ee c8 ff ff 	sub	r8,r7,-1
800069e4:	11 89       	ld.ub	r9,r8[0x0]
800069e6:	4c 2a       	lddpc	r10,80006aec <log+0x14c>
800069e8:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
800069ea:	23 09       	sub	r9,48
800069ec:	30 9a       	mov	r10,9
800069ee:	f4 09 18 00 	cp.b	r9,r10
800069f2:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
800069f6:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800069fa:	f7 b9 08 30 	subls	r9,48
800069fe:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80006a02:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80006a06:	0f 88       	ld.ub	r8,r7[0x0]
80006a08:	22 58       	sub	r8,37
80006a0a:	e0 48 00 53 	cp.w	r8,83
80006a0e:	e0 8b 00 31 	brhi	80006a70 <log+0xd0>
80006a12:	4b 89       	lddpc	r9,80006af0 <log+0x150>
80006a14:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006a18:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006a1c:	06 9a       	mov	r10,r3
80006a1e:	40 0b       	lddsp	r11,sp[0x0]
80006a20:	5c 5b       	castu.b	r11
80006a22:	68 0c       	ld.w	r12,r4[0x0]
80006a24:	f0 1f 00 34 	mcall	80006af4 <log+0x154>
							break;
80006a28:	c2 98       	rjmp	80006a7a <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006a2a:	4b 4c       	lddpc	r12,80006af8 <log+0x158>
80006a2c:	f0 1f 00 34 	mcall	80006afc <log+0x15c>
80006a30:	08 95       	mov	r5,r4
80006a32:	06 9c       	mov	r12,r3
							break;
80006a34:	c2 38       	rjmp	80006a7a <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80006a36:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006a3a:	06 9a       	mov	r10,r3
80006a3c:	40 0b       	lddsp	r11,sp[0x0]
80006a3e:	5c 5b       	castu.b	r11
80006a40:	68 0c       	ld.w	r12,r4[0x0]
80006a42:	f0 1f 00 30 	mcall	80006b00 <log+0x160>
80006a46:	06 9c       	mov	r12,r3
							break;
80006a48:	c1 98       	rjmp	80006a7a <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006a4a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006a4e:	06 9b       	mov	r11,r3
80006a50:	09 bc       	ld.ub	r12,r4[0x3]
80006a52:	f0 1f 00 2d 	mcall	80006b04 <log+0x164>
80006a56:	06 9c       	mov	r12,r3
							break;
80006a58:	c1 18       	rjmp	80006a7a <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006a5a:	e8 c5 ff fc 	sub	r5,r4,-4
80006a5e:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006a60:	c0 d8       	rjmp	80006a7a <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006a62:	06 9b       	mov	r11,r3
80006a64:	32 5c       	mov	r12,37
80006a66:	f0 1f 00 28 	mcall	80006b04 <log+0x164>
80006a6a:	08 95       	mov	r5,r4
80006a6c:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80006a6e:	c0 68       	rjmp	80006a7a <log+0xda>
							
							default:
							log("I need relax.");
80006a70:	4a 6c       	lddpc	r12,80006b08 <log+0x168>
80006a72:	f0 1f 00 23 	mcall	80006afc <log+0x15c>
80006a76:	08 95       	mov	r5,r4
80006a78:	06 9c       	mov	r12,r3
						}
						str++;
80006a7a:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006a7c:	1a dc       	st.w	--sp,r12
80006a7e:	1a d6       	st.w	--sp,r6
80006a80:	4a 3b       	lddpc	r11,80006b0c <log+0x16c>
80006a82:	0c 9c       	mov	r12,r6
80006a84:	f0 1f 00 23 	mcall	80006b10 <log+0x170>
80006a88:	2f ed       	sub	sp,-8
80006a8a:	c0 a8       	rjmp	80006a9e <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006a8c:	2f f7       	sub	r7,-1
80006a8e:	1a d8       	st.w	--sp,r8
80006a90:	1a d6       	st.w	--sp,r6
80006a92:	4a 1b       	lddpc	r11,80006b14 <log+0x174>
80006a94:	0c 9c       	mov	r12,r6
80006a96:	f0 1f 00 1f 	mcall	80006b10 <log+0x170>
80006a9a:	08 95       	mov	r5,r4
80006a9c:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80006a9e:	0f 89       	ld.ub	r9,r7[0x0]
80006aa0:	30 08       	mov	r8,0
80006aa2:	f0 09 18 00 	cp.b	r9,r8
80006aa6:	c0 30       	breq	80006aac <log+0x10c>
80006aa8:	0a 94       	mov	r4,r5
80006aaa:	c9 2b       	rjmp	800069ce <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006aac:	fa c7 fe f8 	sub	r7,sp,-264
80006ab0:	1a d7       	st.w	--sp,r7
80006ab2:	49 ab       	lddpc	r11,80006b18 <log+0x178>
80006ab4:	0e 9c       	mov	r12,r7
80006ab6:	f0 1f 00 17 	mcall	80006b10 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80006aba:	5c 5c       	castu.b	r12
80006abc:	f8 c6 ff ff 	sub	r6,r12,-1
80006ac0:	0c 9c       	mov	r12,r6
80006ac2:	f0 1f 00 17 	mcall	80006b1c <log+0x17c>
80006ac6:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80006ac8:	0c 9a       	mov	r10,r6
80006aca:	0e 9b       	mov	r11,r7
80006acc:	f0 1f 00 15 	mcall	80006b20 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80006ad0:	30 09       	mov	r9,0
80006ad2:	30 5a       	mov	r10,5
80006ad4:	fa cb fe f8 	sub	r11,sp,-264
80006ad8:	49 38       	lddpc	r8,80006b24 <log+0x184>
80006ada:	70 0c       	ld.w	r12,r8[0x0]
80006adc:	f0 1f 00 13 	mcall	80006b28 <log+0x188>
80006ae0:	2f fd       	sub	sp,-4
	
	
}
80006ae2:	fe 3d fd f8 	sub	sp,-520
80006ae6:	d8 32       	popm	r0-r7,pc
80006ae8:	80 00       	ld.sh	r0,r0[0x0]
80006aea:	73 7c       	ld.w	r12,r9[0x5c]
80006aec:	00 00       	add	r0,r0
80006aee:	0d 40       	ld.w	r0,--r6
80006af0:	80 00       	ld.sh	r0,r0[0x0]
80006af2:	d2 a8       	*unknown*
80006af4:	80 00       	ld.sh	r0,r0[0x0]
80006af6:	68 c6       	ld.w	r6,r4[0x30]
80006af8:	80 00       	ld.sh	r0,r0[0x0]
80006afa:	d5 54       	*unknown*
80006afc:	80 00       	ld.sh	r0,r0[0x0]
80006afe:	69 a0       	ld.w	r0,r4[0x68]
80006b00:	80 00       	ld.sh	r0,r0[0x0]
80006b02:	68 14       	ld.w	r4,r4[0x4]
80006b04:	80 00       	ld.sh	r0,r0[0x0]
80006b06:	68 10       	ld.w	r0,r4[0x4]
80006b08:	80 00       	ld.sh	r0,r0[0x0]
80006b0a:	d5 64       	*unknown*
80006b0c:	80 00       	ld.sh	r0,r0[0x0]
80006b0e:	d5 74       	*unknown*
80006b10:	80 00       	ld.sh	r0,r0[0x0]
80006b12:	76 6c       	ld.w	r12,r11[0x18]
80006b14:	80 00       	ld.sh	r0,r0[0x0]
80006b16:	d5 7c       	*unknown*
80006b18:	80 00       	ld.sh	r0,r0[0x0]
80006b1a:	d5 84       	*unknown*
80006b1c:	80 00       	ld.sh	r0,r0[0x0]
80006b1e:	5a b4       	cp.w	r4,-21
80006b20:	80 00       	ld.sh	r0,r0[0x0]
80006b22:	72 34       	ld.w	r4,r9[0xc]
80006b24:	00 00       	add	r0,r0
80006b26:	51 18       	stdsp	sp[0x44],r8
80006b28:	80 00       	ld.sh	r0,r0[0x0]
80006b2a:	5e 08       	reteq	r8

80006b2c <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006b2c:	d4 31       	pushm	r0-r7,lr
80006b2e:	fa cd 02 0c 	sub	sp,sp,524
80006b32:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006b34:	e0 6a 01 00 	mov	r10,256
80006b38:	30 0b       	mov	r11,0
80006b3a:	fa cc fe f4 	sub	r12,sp,-268
80006b3e:	f0 1f 00 4c 	mcall	80006c6c <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80006b42:	fa c4 fd d0 	sub	r4,sp,-560
80006b46:	30 0a       	mov	r10,0
80006b48:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006b4a:	fa c3 ff fc 	sub	r3,sp,-4
80006b4e:	e0 61 01 00 	mov	r1,256
80006b52:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006b54:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006b56:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006b5a:	02 9a       	mov	r10,r1
80006b5c:	00 9b       	mov	r11,r0
80006b5e:	06 9c       	mov	r12,r3
80006b60:	f0 1f 00 43 	mcall	80006c6c <logFromISR+0x140>
			
			if(*str == '%')
80006b64:	0f 88       	ld.ub	r8,r7[0x0]
80006b66:	e4 08 18 00 	cp.b	r8,r2
80006b6a:	c5 11       	brne	80006c0c <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80006b6c:	ee c8 ff ff 	sub	r8,r7,-1
80006b70:	11 89       	ld.ub	r9,r8[0x0]
80006b72:	4c 0a       	lddpc	r10,80006c70 <logFromISR+0x144>
80006b74:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80006b76:	23 09       	sub	r9,48
80006b78:	30 9a       	mov	r10,9
80006b7a:	f4 09 18 00 	cp.b	r9,r10
80006b7e:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80006b82:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006b86:	f7 b9 08 30 	subls	r9,48
80006b8a:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80006b8e:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80006b92:	0f 88       	ld.ub	r8,r7[0x0]
80006b94:	22 58       	sub	r8,37
80006b96:	e0 48 00 53 	cp.w	r8,83
80006b9a:	e0 8b 00 2b 	brhi	80006bf0 <logFromISR+0xc4>
80006b9e:	4b 69       	lddpc	r9,80006c74 <logFromISR+0x148>
80006ba0:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006ba4:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006ba8:	06 9a       	mov	r10,r3
80006baa:	40 0b       	lddsp	r11,sp[0x0]
80006bac:	5c 5b       	castu.b	r11
80006bae:	68 0c       	ld.w	r12,r4[0x0]
80006bb0:	f0 1f 00 32 	mcall	80006c78 <logFromISR+0x14c>
					break;
80006bb4:	c2 38       	rjmp	80006bfa <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80006bb6:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80006bba:	06 9a       	mov	r10,r3
80006bbc:	40 0b       	lddsp	r11,sp[0x0]
80006bbe:	5c 5b       	castu.b	r11
80006bc0:	68 0c       	ld.w	r12,r4[0x0]
80006bc2:	f0 1f 00 2f 	mcall	80006c7c <logFromISR+0x150>
80006bc6:	06 9c       	mov	r12,r3
					break;
80006bc8:	c1 98       	rjmp	80006bfa <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80006bca:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80006bce:	06 9b       	mov	r11,r3
80006bd0:	09 bc       	ld.ub	r12,r4[0x3]
80006bd2:	f0 1f 00 2c 	mcall	80006c80 <logFromISR+0x154>
80006bd6:	06 9c       	mov	r12,r3
					break;
80006bd8:	c1 18       	rjmp	80006bfa <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80006bda:	e8 c5 ff fc 	sub	r5,r4,-4
80006bde:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80006be0:	c0 d8       	rjmp	80006bfa <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80006be2:	06 9b       	mov	r11,r3
80006be4:	32 5c       	mov	r12,37
80006be6:	f0 1f 00 27 	mcall	80006c80 <logFromISR+0x154>
80006bea:	08 95       	mov	r5,r4
80006bec:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80006bee:	c0 68       	rjmp	80006bfa <logFromISR+0xce>
					default:
					log("I need relax.");
80006bf0:	4a 5c       	lddpc	r12,80006c84 <logFromISR+0x158>
80006bf2:	f0 1f 00 26 	mcall	80006c88 <logFromISR+0x15c>
80006bf6:	08 95       	mov	r5,r4
80006bf8:	06 9c       	mov	r12,r3
				}
				str++;
80006bfa:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006bfc:	1a dc       	st.w	--sp,r12
80006bfe:	1a d6       	st.w	--sp,r6
80006c00:	4a 3b       	lddpc	r11,80006c8c <logFromISR+0x160>
80006c02:	0c 9c       	mov	r12,r6
80006c04:	f0 1f 00 23 	mcall	80006c90 <logFromISR+0x164>
80006c08:	2f ed       	sub	sp,-8
80006c0a:	c0 a8       	rjmp	80006c1e <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006c0c:	2f f7       	sub	r7,-1
80006c0e:	1a d8       	st.w	--sp,r8
80006c10:	1a d6       	st.w	--sp,r6
80006c12:	4a 1b       	lddpc	r11,80006c94 <logFromISR+0x168>
80006c14:	0c 9c       	mov	r12,r6
80006c16:	f0 1f 00 1f 	mcall	80006c90 <logFromISR+0x164>
80006c1a:	08 95       	mov	r5,r4
80006c1c:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80006c1e:	0f 89       	ld.ub	r9,r7[0x0]
80006c20:	30 08       	mov	r8,0
80006c22:	f0 09 18 00 	cp.b	r9,r8
80006c26:	c0 30       	breq	80006c2c <logFromISR+0x100>
80006c28:	0a 94       	mov	r4,r5
80006c2a:	c9 8b       	rjmp	80006b5a <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80006c2c:	fa c7 fe f4 	sub	r7,sp,-268
80006c30:	1a d7       	st.w	--sp,r7
80006c32:	49 ab       	lddpc	r11,80006c98 <logFromISR+0x16c>
80006c34:	0e 9c       	mov	r12,r7
80006c36:	f0 1f 00 17 	mcall	80006c90 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80006c3a:	5c 5c       	castu.b	r12
80006c3c:	f8 c6 ff ff 	sub	r6,r12,-1
80006c40:	0c 9c       	mov	r12,r6
80006c42:	f0 1f 00 17 	mcall	80006c9c <logFromISR+0x170>
80006c46:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80006c48:	0c 9a       	mov	r10,r6
80006c4a:	0e 9b       	mov	r11,r7
80006c4c:	f0 1f 00 15 	mcall	80006ca0 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006c50:	30 09       	mov	r9,0
80006c52:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80006c54:	fa ca fe f8 	sub	r10,sp,-264
80006c58:	fa cb fe f4 	sub	r11,sp,-268
80006c5c:	49 28       	lddpc	r8,80006ca4 <logFromISR+0x178>
80006c5e:	70 0c       	ld.w	r12,r8[0x0]
80006c60:	f0 1f 00 12 	mcall	80006ca8 <logFromISR+0x17c>
80006c64:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80006c66:	fe 3d fd f4 	sub	sp,-524
80006c6a:	d8 32       	popm	r0-r7,pc
80006c6c:	80 00       	ld.sh	r0,r0[0x0]
80006c6e:	73 7c       	ld.w	r12,r9[0x5c]
80006c70:	00 00       	add	r0,r0
80006c72:	0d 41       	ld.w	r1,--r6
80006c74:	80 00       	ld.sh	r0,r0[0x0]
80006c76:	d3 f8       	*unknown*
80006c78:	80 00       	ld.sh	r0,r0[0x0]
80006c7a:	68 c6       	ld.w	r6,r4[0x30]
80006c7c:	80 00       	ld.sh	r0,r0[0x0]
80006c7e:	68 14       	ld.w	r4,r4[0x4]
80006c80:	80 00       	ld.sh	r0,r0[0x0]
80006c82:	68 10       	ld.w	r0,r4[0x4]
80006c84:	80 00       	ld.sh	r0,r0[0x0]
80006c86:	d5 64       	*unknown*
80006c88:	80 00       	ld.sh	r0,r0[0x0]
80006c8a:	69 a0       	ld.w	r0,r4[0x68]
80006c8c:	80 00       	ld.sh	r0,r0[0x0]
80006c8e:	d5 74       	*unknown*
80006c90:	80 00       	ld.sh	r0,r0[0x0]
80006c92:	76 6c       	ld.w	r12,r11[0x18]
80006c94:	80 00       	ld.sh	r0,r0[0x0]
80006c96:	d5 7c       	*unknown*
80006c98:	80 00       	ld.sh	r0,r0[0x0]
80006c9a:	d5 84       	*unknown*
80006c9c:	80 00       	ld.sh	r0,r0[0x0]
80006c9e:	5a b4       	cp.w	r4,-21
80006ca0:	80 00       	ld.sh	r0,r0[0x0]
80006ca2:	72 34       	ld.w	r4,r9[0xc]
80006ca4:	00 00       	add	r0,r0
80006ca6:	51 18       	stdsp	sp[0x44],r8
80006ca8:	80 00       	ld.sh	r0,r0[0x0]
80006caa:	5d b8       	*unknown*

80006cac <log_init>:
		
	return str;
}

void log_init(void)
{
80006cac:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80006cae:	30 2b       	mov	r11,2
80006cb0:	49 0c       	lddpc	r12,80006cf0 <log_init+0x44>
80006cb2:	f0 1f 00 11 	mcall	80006cf4 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80006cb6:	e0 6a 36 00 	mov	r10,13824
80006cba:	ea 1a 01 6e 	orh	r10,0x16e
80006cbe:	48 fb       	lddpc	r11,80006cf8 <log_init+0x4c>
80006cc0:	fe 7c 18 00 	mov	r12,-59392
80006cc4:	f0 1f 00 0e 	mcall	80006cfc <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80006cc8:	30 4b       	mov	r11,4
80006cca:	33 2c       	mov	r12,50
80006ccc:	f0 1f 00 0d 	mcall	80006d00 <log_init+0x54>
80006cd0:	48 d8       	lddpc	r8,80006d04 <log_init+0x58>
80006cd2:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80006cd4:	30 09       	mov	r9,0
80006cd6:	1a d9       	st.w	--sp,r9
80006cd8:	1a d9       	st.w	--sp,r9
80006cda:	1a d9       	st.w	--sp,r9
80006cdc:	30 28       	mov	r8,2
80006cde:	e0 6a 01 80 	mov	r10,384
80006ce2:	48 ab       	lddpc	r11,80006d08 <log_init+0x5c>
80006ce4:	48 ac       	lddpc	r12,80006d0c <log_init+0x60>
80006ce6:	f0 1f 00 0b 	mcall	80006d10 <log_init+0x64>
80006cea:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80006cec:	d8 02       	popm	pc
80006cee:	00 00       	add	r0,r0
80006cf0:	80 00       	ld.sh	r0,r0[0x0]
80006cf2:	d5 90       	acall	0x59
80006cf4:	80 00       	ld.sh	r0,r0[0x0]
80006cf6:	50 e4       	stdsp	sp[0x38],r4
80006cf8:	80 00       	ld.sh	r0,r0[0x0]
80006cfa:	d5 48       	*unknown*
80006cfc:	80 00       	ld.sh	r0,r0[0x0]
80006cfe:	56 18       	stdsp	sp[0x184],r8
80006d00:	80 00       	ld.sh	r0,r0[0x0]
80006d02:	5f 08       	sreq	r8
80006d04:	00 00       	add	r0,r0
80006d06:	51 18       	stdsp	sp[0x44],r8
80006d08:	80 00       	ld.sh	r0,r0[0x0]
80006d0a:	d5 8c       	*unknown*
80006d0c:	80 00       	ld.sh	r0,r0[0x0]
80006d0e:	6d 14       	ld.w	r4,r6[0x44]
80006d10:	80 00       	ld.sh	r0,r0[0x0]
80006d12:	65 dc       	ld.w	r12,r2[0x74]

80006d14 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80006d14:	eb cd 40 f8 	pushm	r3-r7,lr
80006d18:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006d1a:	48 c7       	lddpc	r7,80006d48 <task_log+0x34>
80006d1c:	30 05       	mov	r5,0
80006d1e:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80006d20:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006d24:	0a 99       	mov	r9,r5
80006d26:	08 9a       	mov	r10,r4
80006d28:	1a 9b       	mov	r11,sp
80006d2a:	6e 0c       	ld.w	r12,r7[0x0]
80006d2c:	f0 1f 00 08 	mcall	80006d4c <task_log+0x38>
80006d30:	58 1c       	cp.w	r12,1
80006d32:	cf 91       	brne	80006d24 <task_log+0x10>
		{
			if( NULL != str)
80006d34:	40 0b       	lddsp	r11,sp[0x0]
80006d36:	58 0b       	cp.w	r11,0
80006d38:	cf 60       	breq	80006d24 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80006d3a:	06 9c       	mov	r12,r3
80006d3c:	f0 1f 00 05 	mcall	80006d50 <task_log+0x3c>
				vPortFree(str);
80006d40:	40 0c       	lddsp	r12,sp[0x0]
80006d42:	f0 1f 00 05 	mcall	80006d54 <task_log+0x40>
80006d46:	ce fb       	rjmp	80006d24 <task_log+0x10>
80006d48:	00 00       	add	r0,r0
80006d4a:	51 18       	stdsp	sp[0x44],r8
80006d4c:	80 00       	ld.sh	r0,r0[0x0]
80006d4e:	5b fc       	cp.w	r12,-1
80006d50:	80 00       	ld.sh	r0,r0[0x0]
80006d52:	55 c8       	stdsp	sp[0x170],r8
80006d54:	80 00       	ld.sh	r0,r0[0x0]
80006d56:	5a 8c       	cp.w	r12,-24

80006d58 <main>:
#include "rtc.h"
#include "app.h"


int main (void)
{
80006d58:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80006d5a:	fe 78 10 00 	mov	r8,-61440
80006d5e:	30 19       	mov	r9,1
80006d60:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80006d64:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80006d68:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80006d6c:	d3 03       	ssrf	0x10
	local_start_pll0();
80006d6e:	f0 1f 00 12 	mcall	80006db4 <main+0x5c>
		
	INTC_init_interrupts();
80006d72:	f0 1f 00 12 	mcall	80006db8 <main+0x60>
		
	log_init();
80006d76:	f0 1f 00 12 	mcall	80006dbc <main+0x64>
	log("----start debug----");
80006d7a:	49 2c       	lddpc	r12,80006dc0 <main+0x68>
80006d7c:	f0 1f 00 12 	mcall	80006dc4 <main+0x6c>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
80006d80:	f0 1f 00 12 	mcall	80006dc8 <main+0x70>
		
	app_init();
80006d84:	f0 1f 00 12 	mcall	80006dcc <main+0x74>
		
	xcmp_init();
80006d88:	f0 1f 00 12 	mcall	80006dd0 <main+0x78>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80006d8c:	fe 79 10 00 	mov	r9,-61440
80006d90:	f2 f8 01 60 	ld.w	r8,r9[352]
80006d94:	e2 18 00 02 	andl	r8,0x2,COH
80006d98:	cf c0       	breq	80006d90 <main+0x38>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80006d9a:	fe 79 10 00 	mov	r9,-61440
80006d9e:	f2 f8 01 60 	ld.w	r8,r9[352]
80006da2:	e2 18 00 02 	andl	r8,0x2,COH
80006da6:	cf c1       	brne	80006d9e <main+0x46>
	local_start_timer();
80006da8:	f0 1f 00 0b 	mcall	80006dd4 <main+0x7c>
		
	Enable_global_interrupt();
80006dac:	d5 03       	csrf	0x10
		
	vTaskStartScheduler();
80006dae:	f0 1f 00 0b 	mcall	80006dd8 <main+0x80>
	return 0;
	
}
80006db2:	d8 0a       	popm	pc,r12=0
80006db4:	80 00       	ld.sh	r0,r0[0x0]
80006db6:	50 08       	stdsp	sp[0x0],r8
80006db8:	80 00       	ld.sh	r0,r0[0x0]
80006dba:	51 e8       	stdsp	sp[0x78],r8
80006dbc:	80 00       	ld.sh	r0,r0[0x0]
80006dbe:	6c ac       	ld.w	r12,r6[0x28]
80006dc0:	80 00       	ld.sh	r0,r0[0x0]
80006dc2:	d5 a0       	acall	0x5a
80006dc4:	80 00       	ld.sh	r0,r0[0x0]
80006dc6:	69 a0       	ld.w	r0,r4[0x68]
80006dc8:	80 00       	ld.sh	r0,r0[0x0]
80006dca:	4f fc       	lddpc	r12,80006fc4 <_malloc_r+0x1c8>
80006dcc:	80 00       	ld.sh	r0,r0[0x0]
80006dce:	20 3c       	sub	r12,3
80006dd0:	80 00       	ld.sh	r0,r0[0x0]
80006dd2:	3e d4       	mov	r4,-19
80006dd4:	80 00       	ld.sh	r0,r0[0x0]
80006dd6:	50 58       	stdsp	sp[0x14],r8
80006dd8:	80 00       	ld.sh	r0,r0[0x0]
80006dda:	67 c4       	ld.w	r4,r3[0x70]

80006ddc <free>:
80006ddc:	d4 01       	pushm	lr
80006dde:	e0 68 0a 38 	mov	r8,2616
80006de2:	18 9b       	mov	r11,r12
80006de4:	70 0c       	ld.w	r12,r8[0x0]
80006de6:	e0 a0 1e 61 	rcall	8000aaa8 <_free_r>
80006dea:	d8 02       	popm	pc

80006dec <malloc>:
80006dec:	d4 01       	pushm	lr
80006dee:	e0 68 0a 38 	mov	r8,2616
80006df2:	18 9b       	mov	r11,r12
80006df4:	70 0c       	ld.w	r12,r8[0x0]
80006df6:	c0 3c       	rcall	80006dfc <_malloc_r>
80006df8:	d8 02       	popm	pc
80006dfa:	d7 03       	nop

80006dfc <_malloc_r>:
80006dfc:	d4 31       	pushm	r0-r7,lr
80006dfe:	f6 c8 ff f5 	sub	r8,r11,-11
80006e02:	18 95       	mov	r5,r12
80006e04:	10 97       	mov	r7,r8
80006e06:	e0 17 ff f8 	andl	r7,0xfff8
80006e0a:	59 68       	cp.w	r8,22
80006e0c:	f9 b7 08 10 	movls	r7,16
80006e10:	16 37       	cp.w	r7,r11
80006e12:	5f 38       	srlo	r8
80006e14:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80006e18:	c0 50       	breq	80006e22 <_malloc_r+0x26>
80006e1a:	30 c8       	mov	r8,12
80006e1c:	99 38       	st.w	r12[0xc],r8
80006e1e:	e0 8f 01 fa 	bral	80007212 <_malloc_r+0x416>
80006e22:	fe b0 f5 eb 	rcall	800059f8 <__malloc_lock>
80006e26:	e0 47 01 f7 	cp.w	r7,503
80006e2a:	e0 8b 00 1d 	brhi	80006e64 <_malloc_r+0x68>
80006e2e:	ee 03 16 03 	lsr	r3,r7,0x3
80006e32:	e0 68 05 38 	mov	r8,1336
80006e36:	f0 03 00 38 	add	r8,r8,r3<<0x3
80006e3a:	70 36       	ld.w	r6,r8[0xc]
80006e3c:	10 36       	cp.w	r6,r8
80006e3e:	c0 61       	brne	80006e4a <_malloc_r+0x4e>
80006e40:	ec c8 ff f8 	sub	r8,r6,-8
80006e44:	70 36       	ld.w	r6,r8[0xc]
80006e46:	10 36       	cp.w	r6,r8
80006e48:	c0 c0       	breq	80006e60 <_malloc_r+0x64>
80006e4a:	6c 18       	ld.w	r8,r6[0x4]
80006e4c:	e0 18 ff fc 	andl	r8,0xfffc
80006e50:	6c 3a       	ld.w	r10,r6[0xc]
80006e52:	ec 08 00 09 	add	r9,r6,r8
80006e56:	0a 9c       	mov	r12,r5
80006e58:	6c 28       	ld.w	r8,r6[0x8]
80006e5a:	95 28       	st.w	r10[0x8],r8
80006e5c:	91 3a       	st.w	r8[0xc],r10
80006e5e:	c4 78       	rjmp	80006eec <_malloc_r+0xf0>
80006e60:	2f e3       	sub	r3,-2
80006e62:	c4 d8       	rjmp	80006efc <_malloc_r+0x100>
80006e64:	ee 03 16 09 	lsr	r3,r7,0x9
80006e68:	c0 41       	brne	80006e70 <_malloc_r+0x74>
80006e6a:	ee 03 16 03 	lsr	r3,r7,0x3
80006e6e:	c2 68       	rjmp	80006eba <_malloc_r+0xbe>
80006e70:	58 43       	cp.w	r3,4
80006e72:	e0 8b 00 06 	brhi	80006e7e <_malloc_r+0x82>
80006e76:	ee 03 16 06 	lsr	r3,r7,0x6
80006e7a:	2c 83       	sub	r3,-56
80006e7c:	c1 f8       	rjmp	80006eba <_malloc_r+0xbe>
80006e7e:	59 43       	cp.w	r3,20
80006e80:	e0 8b 00 04 	brhi	80006e88 <_malloc_r+0x8c>
80006e84:	2a 53       	sub	r3,-91
80006e86:	c1 a8       	rjmp	80006eba <_malloc_r+0xbe>
80006e88:	e0 43 00 54 	cp.w	r3,84
80006e8c:	e0 8b 00 06 	brhi	80006e98 <_malloc_r+0x9c>
80006e90:	ee 03 16 0c 	lsr	r3,r7,0xc
80006e94:	29 23       	sub	r3,-110
80006e96:	c1 28       	rjmp	80006eba <_malloc_r+0xbe>
80006e98:	e0 43 01 54 	cp.w	r3,340
80006e9c:	e0 8b 00 06 	brhi	80006ea8 <_malloc_r+0xac>
80006ea0:	ee 03 16 0f 	lsr	r3,r7,0xf
80006ea4:	28 93       	sub	r3,-119
80006ea6:	c0 a8       	rjmp	80006eba <_malloc_r+0xbe>
80006ea8:	e0 43 05 54 	cp.w	r3,1364
80006eac:	e0 88 00 04 	brls	80006eb4 <_malloc_r+0xb8>
80006eb0:	37 e3       	mov	r3,126
80006eb2:	c0 48       	rjmp	80006eba <_malloc_r+0xbe>
80006eb4:	ee 03 16 12 	lsr	r3,r7,0x12
80006eb8:	28 43       	sub	r3,-124
80006eba:	e0 6a 05 38 	mov	r10,1336
80006ebe:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80006ec2:	74 36       	ld.w	r6,r10[0xc]
80006ec4:	c1 98       	rjmp	80006ef6 <_malloc_r+0xfa>
80006ec6:	6c 19       	ld.w	r9,r6[0x4]
80006ec8:	e0 19 ff fc 	andl	r9,0xfffc
80006ecc:	f2 07 01 0b 	sub	r11,r9,r7
80006ed0:	58 fb       	cp.w	r11,15
80006ed2:	e0 8a 00 04 	brle	80006eda <_malloc_r+0xde>
80006ed6:	20 13       	sub	r3,1
80006ed8:	c1 18       	rjmp	80006efa <_malloc_r+0xfe>
80006eda:	6c 38       	ld.w	r8,r6[0xc]
80006edc:	58 0b       	cp.w	r11,0
80006ede:	c0 b5       	brlt	80006ef4 <_malloc_r+0xf8>
80006ee0:	6c 2a       	ld.w	r10,r6[0x8]
80006ee2:	ec 09 00 09 	add	r9,r6,r9
80006ee6:	0a 9c       	mov	r12,r5
80006ee8:	91 2a       	st.w	r8[0x8],r10
80006eea:	95 38       	st.w	r10[0xc],r8
80006eec:	72 18       	ld.w	r8,r9[0x4]
80006eee:	a1 a8       	sbr	r8,0x0
80006ef0:	93 18       	st.w	r9[0x4],r8
80006ef2:	cb c8       	rjmp	8000706a <_malloc_r+0x26e>
80006ef4:	10 96       	mov	r6,r8
80006ef6:	14 36       	cp.w	r6,r10
80006ef8:	ce 71       	brne	80006ec6 <_malloc_r+0xca>
80006efa:	2f f3       	sub	r3,-1
80006efc:	e0 6a 05 38 	mov	r10,1336
80006f00:	f4 cc ff f8 	sub	r12,r10,-8
80006f04:	78 26       	ld.w	r6,r12[0x8]
80006f06:	18 36       	cp.w	r6,r12
80006f08:	c6 c0       	breq	80006fe0 <_malloc_r+0x1e4>
80006f0a:	6c 19       	ld.w	r9,r6[0x4]
80006f0c:	e0 19 ff fc 	andl	r9,0xfffc
80006f10:	f2 07 01 08 	sub	r8,r9,r7
80006f14:	58 f8       	cp.w	r8,15
80006f16:	e0 89 00 8f 	brgt	80007034 <_malloc_r+0x238>
80006f1a:	99 3c       	st.w	r12[0xc],r12
80006f1c:	99 2c       	st.w	r12[0x8],r12
80006f1e:	58 08       	cp.w	r8,0
80006f20:	c0 55       	brlt	80006f2a <_malloc_r+0x12e>
80006f22:	ec 09 00 09 	add	r9,r6,r9
80006f26:	0a 9c       	mov	r12,r5
80006f28:	ce 2b       	rjmp	80006eec <_malloc_r+0xf0>
80006f2a:	e0 49 01 ff 	cp.w	r9,511
80006f2e:	e0 8b 00 13 	brhi	80006f54 <_malloc_r+0x158>
80006f32:	a3 99       	lsr	r9,0x3
80006f34:	f4 09 00 38 	add	r8,r10,r9<<0x3
80006f38:	70 2b       	ld.w	r11,r8[0x8]
80006f3a:	8d 38       	st.w	r6[0xc],r8
80006f3c:	8d 2b       	st.w	r6[0x8],r11
80006f3e:	97 36       	st.w	r11[0xc],r6
80006f40:	91 26       	st.w	r8[0x8],r6
80006f42:	a3 49       	asr	r9,0x2
80006f44:	74 18       	ld.w	r8,r10[0x4]
80006f46:	30 1b       	mov	r11,1
80006f48:	f6 09 09 49 	lsl	r9,r11,r9
80006f4c:	f1 e9 10 09 	or	r9,r8,r9
80006f50:	95 19       	st.w	r10[0x4],r9
80006f52:	c4 78       	rjmp	80006fe0 <_malloc_r+0x1e4>
80006f54:	f2 0a 16 09 	lsr	r10,r9,0x9
80006f58:	58 4a       	cp.w	r10,4
80006f5a:	e0 8b 00 07 	brhi	80006f68 <_malloc_r+0x16c>
80006f5e:	f2 0a 16 06 	lsr	r10,r9,0x6
80006f62:	2c 8a       	sub	r10,-56
80006f64:	c2 08       	rjmp	80006fa4 <_malloc_r+0x1a8>
80006f66:	d7 03       	nop
80006f68:	59 4a       	cp.w	r10,20
80006f6a:	e0 8b 00 04 	brhi	80006f72 <_malloc_r+0x176>
80006f6e:	2a 5a       	sub	r10,-91
80006f70:	c1 a8       	rjmp	80006fa4 <_malloc_r+0x1a8>
80006f72:	e0 4a 00 54 	cp.w	r10,84
80006f76:	e0 8b 00 06 	brhi	80006f82 <_malloc_r+0x186>
80006f7a:	f2 0a 16 0c 	lsr	r10,r9,0xc
80006f7e:	29 2a       	sub	r10,-110
80006f80:	c1 28       	rjmp	80006fa4 <_malloc_r+0x1a8>
80006f82:	e0 4a 01 54 	cp.w	r10,340
80006f86:	e0 8b 00 06 	brhi	80006f92 <_malloc_r+0x196>
80006f8a:	f2 0a 16 0f 	lsr	r10,r9,0xf
80006f8e:	28 9a       	sub	r10,-119
80006f90:	c0 a8       	rjmp	80006fa4 <_malloc_r+0x1a8>
80006f92:	e0 4a 05 54 	cp.w	r10,1364
80006f96:	e0 88 00 04 	brls	80006f9e <_malloc_r+0x1a2>
80006f9a:	37 ea       	mov	r10,126
80006f9c:	c0 48       	rjmp	80006fa4 <_malloc_r+0x1a8>
80006f9e:	f2 0a 16 12 	lsr	r10,r9,0x12
80006fa2:	28 4a       	sub	r10,-124
80006fa4:	e0 6b 05 38 	mov	r11,1336
80006fa8:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80006fac:	68 28       	ld.w	r8,r4[0x8]
80006fae:	08 38       	cp.w	r8,r4
80006fb0:	c0 e1       	brne	80006fcc <_malloc_r+0x1d0>
80006fb2:	76 19       	ld.w	r9,r11[0x4]
80006fb4:	a3 4a       	asr	r10,0x2
80006fb6:	30 1e       	mov	lr,1
80006fb8:	fc 0a 09 4a 	lsl	r10,lr,r10
80006fbc:	f3 ea 10 0a 	or	r10,r9,r10
80006fc0:	10 99       	mov	r9,r8
80006fc2:	97 1a       	st.w	r11[0x4],r10
80006fc4:	c0 a8       	rjmp	80006fd8 <_malloc_r+0x1dc>
80006fc6:	70 28       	ld.w	r8,r8[0x8]
80006fc8:	08 38       	cp.w	r8,r4
80006fca:	c0 60       	breq	80006fd6 <_malloc_r+0x1da>
80006fcc:	70 1a       	ld.w	r10,r8[0x4]
80006fce:	e0 1a ff fc 	andl	r10,0xfffc
80006fd2:	14 39       	cp.w	r9,r10
80006fd4:	cf 93       	brcs	80006fc6 <_malloc_r+0x1ca>
80006fd6:	70 39       	ld.w	r9,r8[0xc]
80006fd8:	8d 39       	st.w	r6[0xc],r9
80006fda:	8d 28       	st.w	r6[0x8],r8
80006fdc:	91 36       	st.w	r8[0xc],r6
80006fde:	93 26       	st.w	r9[0x8],r6
80006fe0:	e6 08 14 02 	asr	r8,r3,0x2
80006fe4:	30 1b       	mov	r11,1
80006fe6:	e0 64 05 38 	mov	r4,1336
80006fea:	f6 08 09 4b 	lsl	r11,r11,r8
80006fee:	68 18       	ld.w	r8,r4[0x4]
80006ff0:	10 3b       	cp.w	r11,r8
80006ff2:	e0 8b 00 6b 	brhi	800070c8 <_malloc_r+0x2cc>
80006ff6:	f7 e8 00 09 	and	r9,r11,r8
80006ffa:	c0 b1       	brne	80007010 <_malloc_r+0x214>
80006ffc:	e0 13 ff fc 	andl	r3,0xfffc
80007000:	a1 7b       	lsl	r11,0x1
80007002:	2f c3       	sub	r3,-4
80007004:	c0 38       	rjmp	8000700a <_malloc_r+0x20e>
80007006:	2f c3       	sub	r3,-4
80007008:	a1 7b       	lsl	r11,0x1
8000700a:	f7 e8 00 09 	and	r9,r11,r8
8000700e:	cf c0       	breq	80007006 <_malloc_r+0x20a>
80007010:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80007014:	06 92       	mov	r2,r3
80007016:	1c 91       	mov	r1,lr
80007018:	62 36       	ld.w	r6,r1[0xc]
8000701a:	c2 e8       	rjmp	80007076 <_malloc_r+0x27a>
8000701c:	6c 1a       	ld.w	r10,r6[0x4]
8000701e:	e0 1a ff fc 	andl	r10,0xfffc
80007022:	f4 07 01 08 	sub	r8,r10,r7
80007026:	58 f8       	cp.w	r8,15
80007028:	e0 8a 00 15 	brle	80007052 <_malloc_r+0x256>
8000702c:	6c 3a       	ld.w	r10,r6[0xc]
8000702e:	6c 29       	ld.w	r9,r6[0x8]
80007030:	95 29       	st.w	r10[0x8],r9
80007032:	93 3a       	st.w	r9[0xc],r10
80007034:	0e 99       	mov	r9,r7
80007036:	ec 07 00 07 	add	r7,r6,r7
8000703a:	a1 a9       	sbr	r9,0x0
8000703c:	99 37       	st.w	r12[0xc],r7
8000703e:	99 27       	st.w	r12[0x8],r7
80007040:	8d 19       	st.w	r6[0x4],r9
80007042:	ee 08 09 08 	st.w	r7[r8],r8
80007046:	8f 2c       	st.w	r7[0x8],r12
80007048:	8f 3c       	st.w	r7[0xc],r12
8000704a:	a1 a8       	sbr	r8,0x0
8000704c:	0a 9c       	mov	r12,r5
8000704e:	8f 18       	st.w	r7[0x4],r8
80007050:	c0 d8       	rjmp	8000706a <_malloc_r+0x26e>
80007052:	6c 39       	ld.w	r9,r6[0xc]
80007054:	58 08       	cp.w	r8,0
80007056:	c0 f5       	brlt	80007074 <_malloc_r+0x278>
80007058:	ec 0a 00 0a 	add	r10,r6,r10
8000705c:	74 18       	ld.w	r8,r10[0x4]
8000705e:	a1 a8       	sbr	r8,0x0
80007060:	0a 9c       	mov	r12,r5
80007062:	95 18       	st.w	r10[0x4],r8
80007064:	6c 28       	ld.w	r8,r6[0x8]
80007066:	93 28       	st.w	r9[0x8],r8
80007068:	91 39       	st.w	r8[0xc],r9
8000706a:	fe b0 f4 cd 	rcall	80005a04 <__malloc_unlock>
8000706e:	ec cc ff f8 	sub	r12,r6,-8
80007072:	d8 32       	popm	r0-r7,pc
80007074:	12 96       	mov	r6,r9
80007076:	02 36       	cp.w	r6,r1
80007078:	cd 21       	brne	8000701c <_malloc_r+0x220>
8000707a:	2f f2       	sub	r2,-1
8000707c:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80007080:	c0 30       	breq	80007086 <_malloc_r+0x28a>
80007082:	2f 81       	sub	r1,-8
80007084:	cc ab       	rjmp	80007018 <_malloc_r+0x21c>
80007086:	1c 98       	mov	r8,lr
80007088:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
8000708c:	c0 81       	brne	8000709c <_malloc_r+0x2a0>
8000708e:	68 19       	ld.w	r9,r4[0x4]
80007090:	f6 08 11 ff 	rsub	r8,r11,-1
80007094:	f3 e8 00 08 	and	r8,r9,r8
80007098:	89 18       	st.w	r4[0x4],r8
8000709a:	c0 78       	rjmp	800070a8 <_malloc_r+0x2ac>
8000709c:	f0 c9 00 08 	sub	r9,r8,8
800070a0:	20 13       	sub	r3,1
800070a2:	70 08       	ld.w	r8,r8[0x0]
800070a4:	12 38       	cp.w	r8,r9
800070a6:	cf 10       	breq	80007088 <_malloc_r+0x28c>
800070a8:	a1 7b       	lsl	r11,0x1
800070aa:	68 18       	ld.w	r8,r4[0x4]
800070ac:	10 3b       	cp.w	r11,r8
800070ae:	e0 8b 00 0d 	brhi	800070c8 <_malloc_r+0x2cc>
800070b2:	58 0b       	cp.w	r11,0
800070b4:	c0 a0       	breq	800070c8 <_malloc_r+0x2cc>
800070b6:	04 93       	mov	r3,r2
800070b8:	c0 38       	rjmp	800070be <_malloc_r+0x2c2>
800070ba:	2f c3       	sub	r3,-4
800070bc:	a1 7b       	lsl	r11,0x1
800070be:	f7 e8 00 09 	and	r9,r11,r8
800070c2:	ca 71       	brne	80007010 <_malloc_r+0x214>
800070c4:	cf bb       	rjmp	800070ba <_malloc_r+0x2be>
800070c6:	d7 03       	nop
800070c8:	68 23       	ld.w	r3,r4[0x8]
800070ca:	66 12       	ld.w	r2,r3[0x4]
800070cc:	e0 12 ff fc 	andl	r2,0xfffc
800070d0:	0e 32       	cp.w	r2,r7
800070d2:	5f 39       	srlo	r9
800070d4:	e4 07 01 08 	sub	r8,r2,r7
800070d8:	58 f8       	cp.w	r8,15
800070da:	5f aa       	srle	r10
800070dc:	f5 e9 10 09 	or	r9,r10,r9
800070e0:	e0 80 00 9a 	breq	80007214 <_malloc_r+0x418>
800070e4:	e0 68 0d 4c 	mov	r8,3404
800070e8:	70 01       	ld.w	r1,r8[0x0]
800070ea:	e0 68 09 44 	mov	r8,2372
800070ee:	2f 01       	sub	r1,-16
800070f0:	70 08       	ld.w	r8,r8[0x0]
800070f2:	0e 01       	add	r1,r7
800070f4:	5b f8       	cp.w	r8,-1
800070f6:	c0 40       	breq	800070fe <_malloc_r+0x302>
800070f8:	28 11       	sub	r1,-127
800070fa:	e0 11 ff 80 	andl	r1,0xff80
800070fe:	02 9b       	mov	r11,r1
80007100:	0a 9c       	mov	r12,r5
80007102:	e0 a0 02 a5 	rcall	8000764c <_sbrk_r>
80007106:	18 96       	mov	r6,r12
80007108:	5b fc       	cp.w	r12,-1
8000710a:	c7 50       	breq	800071f4 <_malloc_r+0x3f8>
8000710c:	e6 02 00 08 	add	r8,r3,r2
80007110:	10 3c       	cp.w	r12,r8
80007112:	c0 32       	brcc	80007118 <_malloc_r+0x31c>
80007114:	08 33       	cp.w	r3,r4
80007116:	c6 f1       	brne	800071f4 <_malloc_r+0x3f8>
80007118:	e0 6a 0d 50 	mov	r10,3408
8000711c:	74 09       	ld.w	r9,r10[0x0]
8000711e:	e2 09 00 09 	add	r9,r1,r9
80007122:	95 09       	st.w	r10[0x0],r9
80007124:	10 36       	cp.w	r6,r8
80007126:	c0 a1       	brne	8000713a <_malloc_r+0x33e>
80007128:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000712c:	c0 71       	brne	8000713a <_malloc_r+0x33e>
8000712e:	e2 02 00 02 	add	r2,r1,r2
80007132:	68 28       	ld.w	r8,r4[0x8]
80007134:	a1 a2       	sbr	r2,0x0
80007136:	91 12       	st.w	r8[0x4],r2
80007138:	c4 f8       	rjmp	800071d6 <_malloc_r+0x3da>
8000713a:	e0 6a 09 44 	mov	r10,2372
8000713e:	74 0b       	ld.w	r11,r10[0x0]
80007140:	5b fb       	cp.w	r11,-1
80007142:	c0 31       	brne	80007148 <_malloc_r+0x34c>
80007144:	95 06       	st.w	r10[0x0],r6
80007146:	c0 78       	rjmp	80007154 <_malloc_r+0x358>
80007148:	ec 09 00 09 	add	r9,r6,r9
8000714c:	e0 6a 0d 50 	mov	r10,3408
80007150:	10 19       	sub	r9,r8
80007152:	95 09       	st.w	r10[0x0],r9
80007154:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80007158:	f0 09 11 08 	rsub	r9,r8,8
8000715c:	58 08       	cp.w	r8,0
8000715e:	f2 08 17 10 	movne	r8,r9
80007162:	ed d8 e1 06 	addne	r6,r6,r8
80007166:	28 08       	sub	r8,-128
80007168:	ec 01 00 01 	add	r1,r6,r1
8000716c:	0a 9c       	mov	r12,r5
8000716e:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80007172:	f0 01 01 01 	sub	r1,r8,r1
80007176:	02 9b       	mov	r11,r1
80007178:	e0 a0 02 6a 	rcall	8000764c <_sbrk_r>
8000717c:	e0 68 0d 50 	mov	r8,3408
80007180:	5b fc       	cp.w	r12,-1
80007182:	ec 0c 17 00 	moveq	r12,r6
80007186:	f9 b1 00 00 	moveq	r1,0
8000718a:	70 09       	ld.w	r9,r8[0x0]
8000718c:	0c 1c       	sub	r12,r6
8000718e:	89 26       	st.w	r4[0x8],r6
80007190:	02 0c       	add	r12,r1
80007192:	12 01       	add	r1,r9
80007194:	a1 ac       	sbr	r12,0x0
80007196:	91 01       	st.w	r8[0x0],r1
80007198:	8d 1c       	st.w	r6[0x4],r12
8000719a:	08 33       	cp.w	r3,r4
8000719c:	c1 d0       	breq	800071d6 <_malloc_r+0x3da>
8000719e:	58 f2       	cp.w	r2,15
800071a0:	e0 8b 00 05 	brhi	800071aa <_malloc_r+0x3ae>
800071a4:	30 18       	mov	r8,1
800071a6:	8d 18       	st.w	r6[0x4],r8
800071a8:	c2 68       	rjmp	800071f4 <_malloc_r+0x3f8>
800071aa:	30 59       	mov	r9,5
800071ac:	20 c2       	sub	r2,12
800071ae:	e0 12 ff f8 	andl	r2,0xfff8
800071b2:	e6 02 00 08 	add	r8,r3,r2
800071b6:	91 29       	st.w	r8[0x8],r9
800071b8:	91 19       	st.w	r8[0x4],r9
800071ba:	66 18       	ld.w	r8,r3[0x4]
800071bc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800071c0:	e5 e8 10 08 	or	r8,r2,r8
800071c4:	87 18       	st.w	r3[0x4],r8
800071c6:	58 f2       	cp.w	r2,15
800071c8:	e0 88 00 07 	brls	800071d6 <_malloc_r+0x3da>
800071cc:	e6 cb ff f8 	sub	r11,r3,-8
800071d0:	0a 9c       	mov	r12,r5
800071d2:	e0 a0 1c 6b 	rcall	8000aaa8 <_free_r>
800071d6:	e0 69 0d 48 	mov	r9,3400
800071da:	72 0a       	ld.w	r10,r9[0x0]
800071dc:	e0 68 0d 50 	mov	r8,3408
800071e0:	70 08       	ld.w	r8,r8[0x0]
800071e2:	14 38       	cp.w	r8,r10
800071e4:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800071e8:	e0 69 0d 44 	mov	r9,3396
800071ec:	72 0a       	ld.w	r10,r9[0x0]
800071ee:	14 38       	cp.w	r8,r10
800071f0:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800071f4:	68 28       	ld.w	r8,r4[0x8]
800071f6:	70 18       	ld.w	r8,r8[0x4]
800071f8:	e0 18 ff fc 	andl	r8,0xfffc
800071fc:	0e 38       	cp.w	r8,r7
800071fe:	5f 39       	srlo	r9
80007200:	0e 18       	sub	r8,r7
80007202:	58 f8       	cp.w	r8,15
80007204:	5f aa       	srle	r10
80007206:	f5 e9 10 09 	or	r9,r10,r9
8000720a:	c0 50       	breq	80007214 <_malloc_r+0x418>
8000720c:	0a 9c       	mov	r12,r5
8000720e:	fe b0 f3 fb 	rcall	80005a04 <__malloc_unlock>
80007212:	d8 3a       	popm	r0-r7,pc,r12=0
80007214:	68 26       	ld.w	r6,r4[0x8]
80007216:	a1 a8       	sbr	r8,0x0
80007218:	0e 99       	mov	r9,r7
8000721a:	a1 a9       	sbr	r9,0x0
8000721c:	8d 19       	st.w	r6[0x4],r9
8000721e:	ec 07 00 07 	add	r7,r6,r7
80007222:	0a 9c       	mov	r12,r5
80007224:	89 27       	st.w	r4[0x8],r7
80007226:	8f 18       	st.w	r7[0x4],r8
80007228:	fe b0 f3 ee 	rcall	80005a04 <__malloc_unlock>
8000722c:	ec cc ff f8 	sub	r12,r6,-8
80007230:	d8 32       	popm	r0-r7,pc
80007232:	d7 03       	nop

80007234 <memcpy>:
80007234:	58 8a       	cp.w	r10,8
80007236:	c2 f5       	brlt	80007294 <memcpy+0x60>
80007238:	f9 eb 10 09 	or	r9,r12,r11
8000723c:	e2 19 00 03 	andl	r9,0x3,COH
80007240:	e0 81 00 97 	brne	8000736e <memcpy+0x13a>
80007244:	e0 4a 00 20 	cp.w	r10,32
80007248:	c3 b4       	brge	800072be <memcpy+0x8a>
8000724a:	f4 08 14 02 	asr	r8,r10,0x2
8000724e:	f0 09 11 08 	rsub	r9,r8,8
80007252:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80007256:	76 69       	ld.w	r9,r11[0x18]
80007258:	99 69       	st.w	r12[0x18],r9
8000725a:	76 59       	ld.w	r9,r11[0x14]
8000725c:	99 59       	st.w	r12[0x14],r9
8000725e:	76 49       	ld.w	r9,r11[0x10]
80007260:	99 49       	st.w	r12[0x10],r9
80007262:	76 39       	ld.w	r9,r11[0xc]
80007264:	99 39       	st.w	r12[0xc],r9
80007266:	76 29       	ld.w	r9,r11[0x8]
80007268:	99 29       	st.w	r12[0x8],r9
8000726a:	76 19       	ld.w	r9,r11[0x4]
8000726c:	99 19       	st.w	r12[0x4],r9
8000726e:	76 09       	ld.w	r9,r11[0x0]
80007270:	99 09       	st.w	r12[0x0],r9
80007272:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80007276:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000727a:	e0 1a 00 03 	andl	r10,0x3
8000727e:	f4 0a 11 04 	rsub	r10,r10,4
80007282:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007286:	17 a9       	ld.ub	r9,r11[0x2]
80007288:	b0 a9       	st.b	r8[0x2],r9
8000728a:	17 99       	ld.ub	r9,r11[0x1]
8000728c:	b0 99       	st.b	r8[0x1],r9
8000728e:	17 89       	ld.ub	r9,r11[0x0]
80007290:	b0 89       	st.b	r8[0x0],r9
80007292:	5e fc       	retal	r12
80007294:	f4 0a 11 09 	rsub	r10,r10,9
80007298:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000729c:	17 f9       	ld.ub	r9,r11[0x7]
8000729e:	b8 f9       	st.b	r12[0x7],r9
800072a0:	17 e9       	ld.ub	r9,r11[0x6]
800072a2:	b8 e9       	st.b	r12[0x6],r9
800072a4:	17 d9       	ld.ub	r9,r11[0x5]
800072a6:	b8 d9       	st.b	r12[0x5],r9
800072a8:	17 c9       	ld.ub	r9,r11[0x4]
800072aa:	b8 c9       	st.b	r12[0x4],r9
800072ac:	17 b9       	ld.ub	r9,r11[0x3]
800072ae:	b8 b9       	st.b	r12[0x3],r9
800072b0:	17 a9       	ld.ub	r9,r11[0x2]
800072b2:	b8 a9       	st.b	r12[0x2],r9
800072b4:	17 99       	ld.ub	r9,r11[0x1]
800072b6:	b8 99       	st.b	r12[0x1],r9
800072b8:	17 89       	ld.ub	r9,r11[0x0]
800072ba:	b8 89       	st.b	r12[0x0],r9
800072bc:	5e fc       	retal	r12
800072be:	eb cd 40 c0 	pushm	r6-r7,lr
800072c2:	18 99       	mov	r9,r12
800072c4:	22 0a       	sub	r10,32
800072c6:	b7 07       	ld.d	r6,r11++
800072c8:	b3 26       	st.d	r9++,r6
800072ca:	b7 07       	ld.d	r6,r11++
800072cc:	b3 26       	st.d	r9++,r6
800072ce:	b7 07       	ld.d	r6,r11++
800072d0:	b3 26       	st.d	r9++,r6
800072d2:	b7 07       	ld.d	r6,r11++
800072d4:	b3 26       	st.d	r9++,r6
800072d6:	22 0a       	sub	r10,32
800072d8:	cf 74       	brge	800072c6 <memcpy+0x92>
800072da:	2f 0a       	sub	r10,-16
800072dc:	c0 65       	brlt	800072e8 <memcpy+0xb4>
800072de:	b7 07       	ld.d	r6,r11++
800072e0:	b3 26       	st.d	r9++,r6
800072e2:	b7 07       	ld.d	r6,r11++
800072e4:	b3 26       	st.d	r9++,r6
800072e6:	21 0a       	sub	r10,16
800072e8:	5c 3a       	neg	r10
800072ea:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800072ee:	d7 03       	nop
800072f0:	d7 03       	nop
800072f2:	f7 36 00 0e 	ld.ub	r6,r11[14]
800072f6:	f3 66 00 0e 	st.b	r9[14],r6
800072fa:	f7 36 00 0d 	ld.ub	r6,r11[13]
800072fe:	f3 66 00 0d 	st.b	r9[13],r6
80007302:	f7 36 00 0c 	ld.ub	r6,r11[12]
80007306:	f3 66 00 0c 	st.b	r9[12],r6
8000730a:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000730e:	f3 66 00 0b 	st.b	r9[11],r6
80007312:	f7 36 00 0a 	ld.ub	r6,r11[10]
80007316:	f3 66 00 0a 	st.b	r9[10],r6
8000731a:	f7 36 00 09 	ld.ub	r6,r11[9]
8000731e:	f3 66 00 09 	st.b	r9[9],r6
80007322:	f7 36 00 08 	ld.ub	r6,r11[8]
80007326:	f3 66 00 08 	st.b	r9[8],r6
8000732a:	f7 36 00 07 	ld.ub	r6,r11[7]
8000732e:	f3 66 00 07 	st.b	r9[7],r6
80007332:	f7 36 00 06 	ld.ub	r6,r11[6]
80007336:	f3 66 00 06 	st.b	r9[6],r6
8000733a:	f7 36 00 05 	ld.ub	r6,r11[5]
8000733e:	f3 66 00 05 	st.b	r9[5],r6
80007342:	f7 36 00 04 	ld.ub	r6,r11[4]
80007346:	f3 66 00 04 	st.b	r9[4],r6
8000734a:	f7 36 00 03 	ld.ub	r6,r11[3]
8000734e:	f3 66 00 03 	st.b	r9[3],r6
80007352:	f7 36 00 02 	ld.ub	r6,r11[2]
80007356:	f3 66 00 02 	st.b	r9[2],r6
8000735a:	f7 36 00 01 	ld.ub	r6,r11[1]
8000735e:	f3 66 00 01 	st.b	r9[1],r6
80007362:	f7 36 00 00 	ld.ub	r6,r11[0]
80007366:	f3 66 00 00 	st.b	r9[0],r6
8000736a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000736e:	20 1a       	sub	r10,1
80007370:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80007374:	f8 0a 0b 09 	st.b	r12[r10],r9
80007378:	cf b1       	brne	8000736e <memcpy+0x13a>
8000737a:	5e fc       	retal	r12

8000737c <memset>:
8000737c:	18 98       	mov	r8,r12
8000737e:	c0 38       	rjmp	80007384 <memset+0x8>
80007380:	10 cb       	st.b	r8++,r11
80007382:	20 1a       	sub	r10,1
80007384:	58 0a       	cp.w	r10,0
80007386:	cf d1       	brne	80007380 <memset+0x4>
80007388:	5e fc       	retal	r12
8000738a:	d7 03       	nop

8000738c <_realloc_r>:
8000738c:	d4 31       	pushm	r0-r7,lr
8000738e:	20 1d       	sub	sp,4
80007390:	16 94       	mov	r4,r11
80007392:	18 92       	mov	r2,r12
80007394:	14 9b       	mov	r11,r10
80007396:	58 04       	cp.w	r4,0
80007398:	c0 51       	brne	800073a2 <_realloc_r+0x16>
8000739a:	fe b0 fd 31 	rcall	80006dfc <_malloc_r>
8000739e:	18 95       	mov	r5,r12
800073a0:	c5 39       	rjmp	80007646 <_realloc_r+0x2ba>
800073a2:	50 0a       	stdsp	sp[0x0],r10
800073a4:	fe b0 f3 2a 	rcall	800059f8 <__malloc_lock>
800073a8:	40 0b       	lddsp	r11,sp[0x0]
800073aa:	f6 c8 ff f5 	sub	r8,r11,-11
800073ae:	e8 c1 00 08 	sub	r1,r4,8
800073b2:	10 96       	mov	r6,r8
800073b4:	62 1c       	ld.w	r12,r1[0x4]
800073b6:	e0 16 ff f8 	andl	r6,0xfff8
800073ba:	59 68       	cp.w	r8,22
800073bc:	f9 b6 08 10 	movls	r6,16
800073c0:	16 36       	cp.w	r6,r11
800073c2:	5f 38       	srlo	r8
800073c4:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
800073c8:	c0 50       	breq	800073d2 <_realloc_r+0x46>
800073ca:	30 c8       	mov	r8,12
800073cc:	30 05       	mov	r5,0
800073ce:	85 38       	st.w	r2[0xc],r8
800073d0:	c3 b9       	rjmp	80007646 <_realloc_r+0x2ba>
800073d2:	18 90       	mov	r0,r12
800073d4:	e0 10 ff fc 	andl	r0,0xfffc
800073d8:	0c 30       	cp.w	r0,r6
800073da:	e0 84 01 0b 	brge	800075f0 <_realloc_r+0x264>
800073de:	e0 68 05 38 	mov	r8,1336
800073e2:	e2 00 00 09 	add	r9,r1,r0
800073e6:	70 25       	ld.w	r5,r8[0x8]
800073e8:	0a 39       	cp.w	r9,r5
800073ea:	c0 90       	breq	800073fc <_realloc_r+0x70>
800073ec:	72 1a       	ld.w	r10,r9[0x4]
800073ee:	a1 ca       	cbr	r10,0x0
800073f0:	f2 0a 00 0a 	add	r10,r9,r10
800073f4:	74 1a       	ld.w	r10,r10[0x4]
800073f6:	ed ba 00 00 	bld	r10,0x0
800073fa:	c2 20       	breq	8000743e <_realloc_r+0xb2>
800073fc:	72 1a       	ld.w	r10,r9[0x4]
800073fe:	e0 1a ff fc 	andl	r10,0xfffc
80007402:	f4 00 00 03 	add	r3,r10,r0
80007406:	0a 39       	cp.w	r9,r5
80007408:	c1 31       	brne	8000742e <_realloc_r+0xa2>
8000740a:	ec c7 ff f0 	sub	r7,r6,-16
8000740e:	0e 33       	cp.w	r3,r7
80007410:	c1 95       	brlt	80007442 <_realloc_r+0xb6>
80007412:	e2 06 00 09 	add	r9,r1,r6
80007416:	0c 13       	sub	r3,r6
80007418:	a1 a3       	sbr	r3,0x0
8000741a:	93 13       	st.w	r9[0x4],r3
8000741c:	91 29       	st.w	r8[0x8],r9
8000741e:	04 9c       	mov	r12,r2
80007420:	62 18       	ld.w	r8,r1[0x4]
80007422:	08 95       	mov	r5,r4
80007424:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007428:	10 46       	or	r6,r8
8000742a:	83 16       	st.w	r1[0x4],r6
8000742c:	c0 b9       	rjmp	80007642 <_realloc_r+0x2b6>
8000742e:	0c 33       	cp.w	r3,r6
80007430:	c0 95       	brlt	80007442 <_realloc_r+0xb6>
80007432:	72 28       	ld.w	r8,r9[0x8]
80007434:	02 97       	mov	r7,r1
80007436:	72 39       	ld.w	r9,r9[0xc]
80007438:	93 28       	st.w	r9[0x8],r8
8000743a:	91 39       	st.w	r8[0xc],r9
8000743c:	cd c8       	rjmp	800075f4 <_realloc_r+0x268>
8000743e:	30 0a       	mov	r10,0
80007440:	14 99       	mov	r9,r10
80007442:	ed bc 00 00 	bld	r12,0x0
80007446:	e0 80 00 95 	breq	80007570 <_realloc_r+0x1e4>
8000744a:	62 07       	ld.w	r7,r1[0x0]
8000744c:	e2 07 01 07 	sub	r7,r1,r7
80007450:	6e 1c       	ld.w	r12,r7[0x4]
80007452:	e0 1c ff fc 	andl	r12,0xfffc
80007456:	58 09       	cp.w	r9,0
80007458:	c5 60       	breq	80007504 <_realloc_r+0x178>
8000745a:	f8 00 00 03 	add	r3,r12,r0
8000745e:	0a 39       	cp.w	r9,r5
80007460:	c4 81       	brne	800074f0 <_realloc_r+0x164>
80007462:	14 03       	add	r3,r10
80007464:	ec c9 ff f0 	sub	r9,r6,-16
80007468:	12 33       	cp.w	r3,r9
8000746a:	c4 d5       	brlt	80007504 <_realloc_r+0x178>
8000746c:	6e 3a       	ld.w	r10,r7[0xc]
8000746e:	6e 29       	ld.w	r9,r7[0x8]
80007470:	95 29       	st.w	r10[0x8],r9
80007472:	93 3a       	st.w	r9[0xc],r10
80007474:	ee c5 ff f8 	sub	r5,r7,-8
80007478:	e0 ca 00 04 	sub	r10,r0,4
8000747c:	e0 4a 00 24 	cp.w	r10,36
80007480:	e0 8b 00 25 	brhi	800074ca <_realloc_r+0x13e>
80007484:	0a 99       	mov	r9,r5
80007486:	59 3a       	cp.w	r10,19
80007488:	e0 88 00 1a 	brls	800074bc <_realloc_r+0x130>
8000748c:	09 09       	ld.w	r9,r4++
8000748e:	8b 09       	st.w	r5[0x0],r9
80007490:	09 09       	ld.w	r9,r4++
80007492:	8f 39       	st.w	r7[0xc],r9
80007494:	ee c9 ff f0 	sub	r9,r7,-16
80007498:	59 ba       	cp.w	r10,27
8000749a:	e0 88 00 11 	brls	800074bc <_realloc_r+0x130>
8000749e:	09 0b       	ld.w	r11,r4++
800074a0:	93 0b       	st.w	r9[0x0],r11
800074a2:	09 09       	ld.w	r9,r4++
800074a4:	8f 59       	st.w	r7[0x14],r9
800074a6:	ee c9 ff e8 	sub	r9,r7,-24
800074aa:	e0 4a 00 24 	cp.w	r10,36
800074ae:	c0 71       	brne	800074bc <_realloc_r+0x130>
800074b0:	09 0a       	ld.w	r10,r4++
800074b2:	93 0a       	st.w	r9[0x0],r10
800074b4:	ee c9 ff e0 	sub	r9,r7,-32
800074b8:	09 0a       	ld.w	r10,r4++
800074ba:	8f 7a       	st.w	r7[0x1c],r10
800074bc:	09 0a       	ld.w	r10,r4++
800074be:	12 aa       	st.w	r9++,r10
800074c0:	68 0a       	ld.w	r10,r4[0x0]
800074c2:	93 0a       	st.w	r9[0x0],r10
800074c4:	68 1a       	ld.w	r10,r4[0x4]
800074c6:	93 1a       	st.w	r9[0x4],r10
800074c8:	c0 78       	rjmp	800074d6 <_realloc_r+0x14a>
800074ca:	50 08       	stdsp	sp[0x0],r8
800074cc:	08 9b       	mov	r11,r4
800074ce:	0a 9c       	mov	r12,r5
800074d0:	e0 a0 1d 8f 	rcall	8000afee <memmove>
800074d4:	40 08       	lddsp	r8,sp[0x0]
800074d6:	ee 06 00 09 	add	r9,r7,r6
800074da:	0c 13       	sub	r3,r6
800074dc:	a1 a3       	sbr	r3,0x0
800074de:	93 13       	st.w	r9[0x4],r3
800074e0:	91 29       	st.w	r8[0x8],r9
800074e2:	04 9c       	mov	r12,r2
800074e4:	6e 18       	ld.w	r8,r7[0x4]
800074e6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800074ea:	10 46       	or	r6,r8
800074ec:	8f 16       	st.w	r7[0x4],r6
800074ee:	ca a8       	rjmp	80007642 <_realloc_r+0x2b6>
800074f0:	14 03       	add	r3,r10
800074f2:	0c 33       	cp.w	r3,r6
800074f4:	c0 85       	brlt	80007504 <_realloc_r+0x178>
800074f6:	72 28       	ld.w	r8,r9[0x8]
800074f8:	72 39       	ld.w	r9,r9[0xc]
800074fa:	93 28       	st.w	r9[0x8],r8
800074fc:	91 39       	st.w	r8[0xc],r9
800074fe:	6e 28       	ld.w	r8,r7[0x8]
80007500:	6e 39       	ld.w	r9,r7[0xc]
80007502:	c0 78       	rjmp	80007510 <_realloc_r+0x184>
80007504:	f8 00 00 03 	add	r3,r12,r0
80007508:	0c 33       	cp.w	r3,r6
8000750a:	c3 35       	brlt	80007570 <_realloc_r+0x1e4>
8000750c:	6e 39       	ld.w	r9,r7[0xc]
8000750e:	6e 28       	ld.w	r8,r7[0x8]
80007510:	93 28       	st.w	r9[0x8],r8
80007512:	91 39       	st.w	r8[0xc],r9
80007514:	e0 ca 00 04 	sub	r10,r0,4
80007518:	ee cc ff f8 	sub	r12,r7,-8
8000751c:	e0 4a 00 24 	cp.w	r10,36
80007520:	e0 8b 00 24 	brhi	80007568 <_realloc_r+0x1dc>
80007524:	59 3a       	cp.w	r10,19
80007526:	e0 88 00 1a 	brls	8000755a <_realloc_r+0x1ce>
8000752a:	09 08       	ld.w	r8,r4++
8000752c:	99 08       	st.w	r12[0x0],r8
8000752e:	09 08       	ld.w	r8,r4++
80007530:	8f 38       	st.w	r7[0xc],r8
80007532:	ee cc ff f0 	sub	r12,r7,-16
80007536:	59 ba       	cp.w	r10,27
80007538:	e0 88 00 11 	brls	8000755a <_realloc_r+0x1ce>
8000753c:	09 08       	ld.w	r8,r4++
8000753e:	99 08       	st.w	r12[0x0],r8
80007540:	09 08       	ld.w	r8,r4++
80007542:	8f 58       	st.w	r7[0x14],r8
80007544:	ee cc ff e8 	sub	r12,r7,-24
80007548:	e0 4a 00 24 	cp.w	r10,36
8000754c:	c0 71       	brne	8000755a <_realloc_r+0x1ce>
8000754e:	09 08       	ld.w	r8,r4++
80007550:	99 08       	st.w	r12[0x0],r8
80007552:	ee cc ff e0 	sub	r12,r7,-32
80007556:	09 08       	ld.w	r8,r4++
80007558:	8f 78       	st.w	r7[0x1c],r8
8000755a:	09 08       	ld.w	r8,r4++
8000755c:	18 a8       	st.w	r12++,r8
8000755e:	68 08       	ld.w	r8,r4[0x0]
80007560:	99 08       	st.w	r12[0x0],r8
80007562:	68 18       	ld.w	r8,r4[0x4]
80007564:	99 18       	st.w	r12[0x4],r8
80007566:	c4 78       	rjmp	800075f4 <_realloc_r+0x268>
80007568:	08 9b       	mov	r11,r4
8000756a:	e0 a0 1d 42 	rcall	8000afee <memmove>
8000756e:	c4 38       	rjmp	800075f4 <_realloc_r+0x268>
80007570:	04 9c       	mov	r12,r2
80007572:	fe b0 fc 45 	rcall	80006dfc <_malloc_r>
80007576:	18 95       	mov	r5,r12
80007578:	c3 a0       	breq	800075ec <_realloc_r+0x260>
8000757a:	62 18       	ld.w	r8,r1[0x4]
8000757c:	f8 c9 00 08 	sub	r9,r12,8
80007580:	a1 c8       	cbr	r8,0x0
80007582:	e2 08 00 08 	add	r8,r1,r8
80007586:	10 39       	cp.w	r9,r8
80007588:	c0 71       	brne	80007596 <_realloc_r+0x20a>
8000758a:	72 13       	ld.w	r3,r9[0x4]
8000758c:	02 97       	mov	r7,r1
8000758e:	e0 13 ff fc 	andl	r3,0xfffc
80007592:	00 03       	add	r3,r0
80007594:	c3 08       	rjmp	800075f4 <_realloc_r+0x268>
80007596:	e0 ca 00 04 	sub	r10,r0,4
8000759a:	e0 4a 00 24 	cp.w	r10,36
8000759e:	e0 8b 00 20 	brhi	800075de <_realloc_r+0x252>
800075a2:	08 99       	mov	r9,r4
800075a4:	18 98       	mov	r8,r12
800075a6:	59 3a       	cp.w	r10,19
800075a8:	e0 88 00 14 	brls	800075d0 <_realloc_r+0x244>
800075ac:	13 0b       	ld.w	r11,r9++
800075ae:	10 ab       	st.w	r8++,r11
800075b0:	13 0b       	ld.w	r11,r9++
800075b2:	10 ab       	st.w	r8++,r11
800075b4:	59 ba       	cp.w	r10,27
800075b6:	e0 88 00 0d 	brls	800075d0 <_realloc_r+0x244>
800075ba:	13 0b       	ld.w	r11,r9++
800075bc:	10 ab       	st.w	r8++,r11
800075be:	13 0b       	ld.w	r11,r9++
800075c0:	10 ab       	st.w	r8++,r11
800075c2:	e0 4a 00 24 	cp.w	r10,36
800075c6:	c0 51       	brne	800075d0 <_realloc_r+0x244>
800075c8:	13 0a       	ld.w	r10,r9++
800075ca:	10 aa       	st.w	r8++,r10
800075cc:	13 0a       	ld.w	r10,r9++
800075ce:	10 aa       	st.w	r8++,r10
800075d0:	13 0a       	ld.w	r10,r9++
800075d2:	10 aa       	st.w	r8++,r10
800075d4:	72 0a       	ld.w	r10,r9[0x0]
800075d6:	91 0a       	st.w	r8[0x0],r10
800075d8:	72 19       	ld.w	r9,r9[0x4]
800075da:	91 19       	st.w	r8[0x4],r9
800075dc:	c0 48       	rjmp	800075e4 <_realloc_r+0x258>
800075de:	08 9b       	mov	r11,r4
800075e0:	e0 a0 1d 07 	rcall	8000afee <memmove>
800075e4:	08 9b       	mov	r11,r4
800075e6:	04 9c       	mov	r12,r2
800075e8:	e0 a0 1a 60 	rcall	8000aaa8 <_free_r>
800075ec:	04 9c       	mov	r12,r2
800075ee:	c2 a8       	rjmp	80007642 <_realloc_r+0x2b6>
800075f0:	00 93       	mov	r3,r0
800075f2:	02 97       	mov	r7,r1
800075f4:	e6 06 01 09 	sub	r9,r3,r6
800075f8:	6e 18       	ld.w	r8,r7[0x4]
800075fa:	58 f9       	cp.w	r9,15
800075fc:	e0 88 00 16 	brls	80007628 <_realloc_r+0x29c>
80007600:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007604:	ed e8 10 08 	or	r8,r6,r8
80007608:	8f 18       	st.w	r7[0x4],r8
8000760a:	12 98       	mov	r8,r9
8000760c:	a1 a8       	sbr	r8,0x0
8000760e:	ee 06 00 0b 	add	r11,r7,r6
80007612:	f6 09 00 09 	add	r9,r11,r9
80007616:	97 18       	st.w	r11[0x4],r8
80007618:	72 18       	ld.w	r8,r9[0x4]
8000761a:	a1 a8       	sbr	r8,0x0
8000761c:	2f 8b       	sub	r11,-8
8000761e:	93 18       	st.w	r9[0x4],r8
80007620:	04 9c       	mov	r12,r2
80007622:	e0 a0 1a 43 	rcall	8000aaa8 <_free_r>
80007626:	c0 b8       	rjmp	8000763c <_realloc_r+0x2b0>
80007628:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000762c:	e7 e8 10 08 	or	r8,r3,r8
80007630:	8f 18       	st.w	r7[0x4],r8
80007632:	ee 03 00 03 	add	r3,r7,r3
80007636:	66 18       	ld.w	r8,r3[0x4]
80007638:	a1 a8       	sbr	r8,0x0
8000763a:	87 18       	st.w	r3[0x4],r8
8000763c:	04 9c       	mov	r12,r2
8000763e:	ee c5 ff f8 	sub	r5,r7,-8
80007642:	fe b0 f1 e1 	rcall	80005a04 <__malloc_unlock>
80007646:	0a 9c       	mov	r12,r5
80007648:	2f fd       	sub	sp,-4
8000764a:	d8 32       	popm	r0-r7,pc

8000764c <_sbrk_r>:
8000764c:	d4 21       	pushm	r4-r7,lr
8000764e:	30 08       	mov	r8,0
80007650:	18 97       	mov	r7,r12
80007652:	e0 66 51 1c 	mov	r6,20764
80007656:	16 9c       	mov	r12,r11
80007658:	8d 08       	st.w	r6[0x0],r8
8000765a:	c8 5c       	rcall	80007764 <_sbrk>
8000765c:	5b fc       	cp.w	r12,-1
8000765e:	c0 51       	brne	80007668 <_sbrk_r+0x1c>
80007660:	6c 08       	ld.w	r8,r6[0x0]
80007662:	58 08       	cp.w	r8,0
80007664:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007668:	d8 22       	popm	r4-r7,pc
8000766a:	d7 03       	nop

8000766c <sprintf>:
8000766c:	d4 01       	pushm	lr
8000766e:	21 7d       	sub	sp,92
80007670:	e0 68 ff ff 	mov	r8,65535
80007674:	ea 18 7f ff 	orh	r8,0x7fff
80007678:	50 58       	stdsp	sp[0x14],r8
8000767a:	50 28       	stdsp	sp[0x8],r8
8000767c:	e0 68 02 08 	mov	r8,520
80007680:	ba 68       	st.h	sp[0xc],r8
80007682:	3f f8       	mov	r8,-1
80007684:	ba 78       	st.h	sp[0xe],r8
80007686:	e0 68 0a 38 	mov	r8,2616
8000768a:	50 4c       	stdsp	sp[0x10],r12
8000768c:	16 9a       	mov	r10,r11
8000768e:	50 0c       	stdsp	sp[0x0],r12
80007690:	fa c9 ff a0 	sub	r9,sp,-96
80007694:	70 0c       	ld.w	r12,r8[0x0]
80007696:	1a 9b       	mov	r11,sp
80007698:	e0 a0 02 1a 	rcall	80007acc <_vfprintf_r>
8000769c:	30 09       	mov	r9,0
8000769e:	40 08       	lddsp	r8,sp[0x0]
800076a0:	b0 89       	st.b	r8[0x0],r9
800076a2:	2e 9d       	sub	sp,-92
800076a4:	d8 02       	popm	pc
800076a6:	d7 03       	nop

800076a8 <strncpy>:
800076a8:	30 08       	mov	r8,0
800076aa:	10 3a       	cp.w	r10,r8
800076ac:	5e 0c       	reteq	r12
800076ae:	f6 08 07 09 	ld.ub	r9,r11[r8]
800076b2:	f8 08 0b 09 	st.b	r12[r8],r9
800076b6:	2f f8       	sub	r8,-1
800076b8:	58 09       	cp.w	r9,0
800076ba:	cf 81       	brne	800076aa <strncpy+0x2>
800076bc:	10 3a       	cp.w	r10,r8
800076be:	5e 0c       	reteq	r12
800076c0:	f8 08 0b 09 	st.b	r12[r8],r9
800076c4:	2f f8       	sub	r8,-1
800076c6:	cf bb       	rjmp	800076bc <strncpy+0x14>

800076c8 <_close>:
800076c8:	30 28       	mov	r8,2
800076ca:	d6 73       	breakpoint
800076cc:	3f fc       	mov	r12,-1
800076ce:	35 8b       	mov	r11,88
800076d0:	58 0c       	cp.w	r12,0
800076d2:	5e 4c       	retge	r12
800076d4:	e0 6a 51 1c 	mov	r10,20764
800076d8:	95 0b       	st.w	r10[0x0],r11
800076da:	5e fc       	retal	r12

800076dc <_lseek>:
800076dc:	30 58       	mov	r8,5
800076de:	d6 73       	breakpoint
800076e0:	3f fc       	mov	r12,-1
800076e2:	35 8b       	mov	r11,88
800076e4:	58 0c       	cp.w	r12,0
800076e6:	5e 4c       	retge	r12
800076e8:	e0 6a 51 1c 	mov	r10,20764
800076ec:	95 0b       	st.w	r10[0x0],r11
800076ee:	5e fc       	retal	r12

800076f0 <isatty>:
800076f0:	30 b8       	mov	r8,11
800076f2:	d6 73       	breakpoint
800076f4:	3f fc       	mov	r12,-1
800076f6:	35 8b       	mov	r11,88
800076f8:	58 0c       	cp.w	r12,0
800076fa:	5e 4c       	retge	r12
800076fc:	e0 6a 51 1c 	mov	r10,20764
80007700:	95 0b       	st.w	r10[0x0],r11
80007702:	5e fc       	retal	r12

80007704 <_fstat_host>:
80007704:	30 98       	mov	r8,9
80007706:	d6 73       	breakpoint
80007708:	3f fc       	mov	r12,-1
8000770a:	35 8b       	mov	r11,88
8000770c:	58 0c       	cp.w	r12,0
8000770e:	5e 4c       	retge	r12
80007710:	e0 6a 51 1c 	mov	r10,20764
80007714:	95 0b       	st.w	r10[0x0],r11
80007716:	5e fc       	retal	r12

80007718 <_fstat>:
80007718:	d4 21       	pushm	r4-r7,lr
8000771a:	21 0d       	sub	sp,64
8000771c:	16 97       	mov	r7,r11
8000771e:	1a 9b       	mov	r11,sp
80007720:	cf 2f       	rcall	80007704 <_fstat_host>
80007722:	c0 34       	brge	80007728 <_fstat+0x10>
80007724:	3f fc       	mov	r12,-1
80007726:	c1 c8       	rjmp	8000775e <_fstat+0x46>
80007728:	40 08       	lddsp	r8,sp[0x0]
8000772a:	ae 08       	st.h	r7[0x0],r8
8000772c:	40 18       	lddsp	r8,sp[0x4]
8000772e:	ae 18       	st.h	r7[0x2],r8
80007730:	40 28       	lddsp	r8,sp[0x8]
80007732:	8f 18       	st.w	r7[0x4],r8
80007734:	40 38       	lddsp	r8,sp[0xc]
80007736:	ae 48       	st.h	r7[0x8],r8
80007738:	40 48       	lddsp	r8,sp[0x10]
8000773a:	ae 58       	st.h	r7[0xa],r8
8000773c:	40 58       	lddsp	r8,sp[0x14]
8000773e:	ae 68       	st.h	r7[0xc],r8
80007740:	40 68       	lddsp	r8,sp[0x18]
80007742:	ae 78       	st.h	r7[0xe],r8
80007744:	40 88       	lddsp	r8,sp[0x20]
80007746:	8f 48       	st.w	r7[0x10],r8
80007748:	40 a8       	lddsp	r8,sp[0x28]
8000774a:	8f b8       	st.w	r7[0x2c],r8
8000774c:	40 c8       	lddsp	r8,sp[0x30]
8000774e:	8f c8       	st.w	r7[0x30],r8
80007750:	40 d8       	lddsp	r8,sp[0x34]
80007752:	8f 58       	st.w	r7[0x14],r8
80007754:	40 e8       	lddsp	r8,sp[0x38]
80007756:	30 0c       	mov	r12,0
80007758:	8f 78       	st.w	r7[0x1c],r8
8000775a:	40 f8       	lddsp	r8,sp[0x3c]
8000775c:	8f 98       	st.w	r7[0x24],r8
8000775e:	2f 0d       	sub	sp,-64
80007760:	d8 22       	popm	r4-r7,pc
80007762:	d7 03       	nop

80007764 <_sbrk>:
80007764:	d4 01       	pushm	lr
80007766:	e0 68 0d 78 	mov	r8,3448
8000776a:	70 09       	ld.w	r9,r8[0x0]
8000776c:	58 09       	cp.w	r9,0
8000776e:	c0 41       	brne	80007776 <_sbrk+0x12>
80007770:	e0 69 51 20 	mov	r9,20768
80007774:	91 09       	st.w	r8[0x0],r9
80007776:	e0 69 0d 78 	mov	r9,3448
8000777a:	e0 7a 70 00 	mov	r10,94208
8000777e:	72 08       	ld.w	r8,r9[0x0]
80007780:	f0 0c 00 0c 	add	r12,r8,r12
80007784:	14 3c       	cp.w	r12,r10
80007786:	e0 8b 00 04 	brhi	8000778e <_sbrk+0x2a>
8000778a:	93 0c       	st.w	r9[0x0],r12
8000778c:	c0 68       	rjmp	80007798 <_sbrk+0x34>
8000778e:	e0 a0 18 15 	rcall	8000a7b8 <__errno>
80007792:	30 c8       	mov	r8,12
80007794:	99 08       	st.w	r12[0x0],r8
80007796:	3f f8       	mov	r8,-1
80007798:	10 9c       	mov	r12,r8
8000779a:	d8 02       	popm	pc

8000779c <get_arg>:
8000779c:	d4 31       	pushm	r0-r7,lr
8000779e:	20 8d       	sub	sp,32
800077a0:	fa c4 ff bc 	sub	r4,sp,-68
800077a4:	50 4b       	stdsp	sp[0x10],r11
800077a6:	68 2e       	ld.w	lr,r4[0x8]
800077a8:	50 58       	stdsp	sp[0x14],r8
800077aa:	12 96       	mov	r6,r9
800077ac:	7c 0b       	ld.w	r11,lr[0x0]
800077ae:	70 05       	ld.w	r5,r8[0x0]
800077b0:	50 6e       	stdsp	sp[0x18],lr
800077b2:	58 0b       	cp.w	r11,0
800077b4:	f4 0b 17 00 	moveq	r11,r10
800077b8:	68 03       	ld.w	r3,r4[0x0]
800077ba:	68 11       	ld.w	r1,r4[0x4]
800077bc:	40 49       	lddsp	r9,sp[0x10]
800077be:	30 08       	mov	r8,0
800077c0:	c2 89       	rjmp	80007a10 <get_arg+0x274>
800077c2:	2f fb       	sub	r11,-1
800077c4:	32 5c       	mov	r12,37
800077c6:	17 8a       	ld.ub	r10,r11[0x0]
800077c8:	f8 0a 18 00 	cp.b	r10,r12
800077cc:	5f 1e       	srne	lr
800077ce:	f0 0a 18 00 	cp.b	r10,r8
800077d2:	5f 1c       	srne	r12
800077d4:	fd ec 00 0c 	and	r12,lr,r12
800077d8:	f0 0c 18 00 	cp.b	r12,r8
800077dc:	cf 31       	brne	800077c2 <get_arg+0x26>
800077de:	58 0a       	cp.w	r10,0
800077e0:	e0 80 01 25 	breq	80007a2a <get_arg+0x28e>
800077e4:	30 0c       	mov	r12,0
800077e6:	3f fa       	mov	r10,-1
800077e8:	18 90       	mov	r0,r12
800077ea:	50 3a       	stdsp	sp[0xc],r10
800077ec:	18 94       	mov	r4,r12
800077ee:	18 92       	mov	r2,r12
800077f0:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
800077f4:	16 97       	mov	r7,r11
800077f6:	50 7c       	stdsp	sp[0x1c],r12
800077f8:	fe cc 9f 70 	sub	r12,pc,-24720
800077fc:	0f 3a       	ld.ub	r10,r7++
800077fe:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007802:	40 7c       	lddsp	r12,sp[0x1c]
80007804:	1c 0c       	add	r12,lr
80007806:	fe ce a0 46 	sub	lr,pc,-24506
8000780a:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
8000780e:	20 1e       	sub	lr,1
80007810:	50 0e       	stdsp	sp[0x0],lr
80007812:	fe ce a0 be 	sub	lr,pc,-24386
80007816:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8000781a:	50 7c       	stdsp	sp[0x1c],r12
8000781c:	40 0c       	lddsp	r12,sp[0x0]
8000781e:	58 7c       	cp.w	r12,7
80007820:	e0 8b 00 f1 	brhi	80007a02 <get_arg+0x266>
80007824:	fe ce a2 70 	sub	lr,pc,-23952
80007828:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
8000782c:	36 8b       	mov	r11,104
8000782e:	f6 0a 18 00 	cp.b	r10,r11
80007832:	e0 80 00 e8 	breq	80007a02 <get_arg+0x266>
80007836:	37 1b       	mov	r11,113
80007838:	f6 0a 18 00 	cp.b	r10,r11
8000783c:	c0 70       	breq	8000784a <get_arg+0xae>
8000783e:	34 cb       	mov	r11,76
80007840:	f6 0a 18 00 	cp.b	r10,r11
80007844:	c0 51       	brne	8000784e <get_arg+0xb2>
80007846:	a3 b4       	sbr	r4,0x3
80007848:	cd d8       	rjmp	80007a02 <get_arg+0x266>
8000784a:	a5 b4       	sbr	r4,0x5
8000784c:	cd b8       	rjmp	80007a02 <get_arg+0x266>
8000784e:	08 9a       	mov	r10,r4
80007850:	0e 9b       	mov	r11,r7
80007852:	a5 aa       	sbr	r10,0x4
80007854:	17 3c       	ld.ub	r12,r11++
80007856:	a5 b4       	sbr	r4,0x5
80007858:	36 ce       	mov	lr,108
8000785a:	fc 0c 18 00 	cp.b	r12,lr
8000785e:	e0 80 00 d3 	breq	80007a04 <get_arg+0x268>
80007862:	14 94       	mov	r4,r10
80007864:	cc f8       	rjmp	80007a02 <get_arg+0x266>
80007866:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000786a:	36 7c       	mov	r12,103
8000786c:	f8 0a 18 00 	cp.b	r10,r12
80007870:	e0 8b 00 27 	brhi	800078be <get_arg+0x122>
80007874:	36 5b       	mov	r11,101
80007876:	f6 0a 18 00 	cp.b	r10,r11
8000787a:	c4 82       	brcc	8000790a <get_arg+0x16e>
8000787c:	34 fb       	mov	r11,79
8000787e:	f6 0a 18 00 	cp.b	r10,r11
80007882:	c4 80       	breq	80007912 <get_arg+0x176>
80007884:	e0 8b 00 0c 	brhi	8000789c <get_arg+0x100>
80007888:	34 5b       	mov	r11,69
8000788a:	f6 0a 18 00 	cp.b	r10,r11
8000788e:	c3 e0       	breq	8000790a <get_arg+0x16e>
80007890:	34 7b       	mov	r11,71
80007892:	f6 0a 18 00 	cp.b	r10,r11
80007896:	c3 a0       	breq	8000790a <get_arg+0x16e>
80007898:	34 4b       	mov	r11,68
8000789a:	c0 88       	rjmp	800078aa <get_arg+0x10e>
8000789c:	35 8b       	mov	r11,88
8000789e:	f6 0a 18 00 	cp.b	r10,r11
800078a2:	c2 c0       	breq	800078fa <get_arg+0x15e>
800078a4:	e0 8b 00 07 	brhi	800078b2 <get_arg+0x116>
800078a8:	35 5b       	mov	r11,85
800078aa:	f6 0a 18 00 	cp.b	r10,r11
800078ae:	c3 51       	brne	80007918 <get_arg+0x17c>
800078b0:	c3 18       	rjmp	80007912 <get_arg+0x176>
800078b2:	36 3b       	mov	r11,99
800078b4:	f6 0a 18 00 	cp.b	r10,r11
800078b8:	c2 f0       	breq	80007916 <get_arg+0x17a>
800078ba:	36 4b       	mov	r11,100
800078bc:	c0 e8       	rjmp	800078d8 <get_arg+0x13c>
800078be:	37 0b       	mov	r11,112
800078c0:	f6 0a 18 00 	cp.b	r10,r11
800078c4:	c2 50       	breq	8000790e <get_arg+0x172>
800078c6:	e0 8b 00 0d 	brhi	800078e0 <get_arg+0x144>
800078ca:	36 eb       	mov	r11,110
800078cc:	f6 0a 18 00 	cp.b	r10,r11
800078d0:	c1 f0       	breq	8000790e <get_arg+0x172>
800078d2:	e0 8b 00 14 	brhi	800078fa <get_arg+0x15e>
800078d6:	36 9b       	mov	r11,105
800078d8:	f6 0a 18 00 	cp.b	r10,r11
800078dc:	c1 e1       	brne	80007918 <get_arg+0x17c>
800078de:	c0 e8       	rjmp	800078fa <get_arg+0x15e>
800078e0:	37 5b       	mov	r11,117
800078e2:	f6 0a 18 00 	cp.b	r10,r11
800078e6:	c0 a0       	breq	800078fa <get_arg+0x15e>
800078e8:	37 8b       	mov	r11,120
800078ea:	f6 0a 18 00 	cp.b	r10,r11
800078ee:	c0 60       	breq	800078fa <get_arg+0x15e>
800078f0:	37 3b       	mov	r11,115
800078f2:	f6 0a 18 00 	cp.b	r10,r11
800078f6:	c1 11       	brne	80007918 <get_arg+0x17c>
800078f8:	c0 b8       	rjmp	8000790e <get_arg+0x172>
800078fa:	ed b4 00 04 	bld	r4,0x4
800078fe:	c0 a0       	breq	80007912 <get_arg+0x176>
80007900:	ed b4 00 05 	bld	r4,0x5
80007904:	c0 91       	brne	80007916 <get_arg+0x17a>
80007906:	30 20       	mov	r0,2
80007908:	c0 88       	rjmp	80007918 <get_arg+0x17c>
8000790a:	30 40       	mov	r0,4
8000790c:	c0 68       	rjmp	80007918 <get_arg+0x17c>
8000790e:	30 30       	mov	r0,3
80007910:	c0 48       	rjmp	80007918 <get_arg+0x17c>
80007912:	30 10       	mov	r0,1
80007914:	c0 28       	rjmp	80007918 <get_arg+0x17c>
80007916:	30 00       	mov	r0,0
80007918:	40 3b       	lddsp	r11,sp[0xc]
8000791a:	5b fb       	cp.w	r11,-1
8000791c:	c0 40       	breq	80007924 <get_arg+0x188>
8000791e:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007922:	c7 08       	rjmp	80007a02 <get_arg+0x266>
80007924:	58 60       	cp.w	r0,6
80007926:	e0 8b 00 6e 	brhi	80007a02 <get_arg+0x266>
8000792a:	6c 0a       	ld.w	r10,r6[0x0]
8000792c:	ea cc ff ff 	sub	r12,r5,-1
80007930:	fe ce a3 5c 	sub	lr,pc,-23716
80007934:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007938:	f4 cb ff f8 	sub	r11,r10,-8
8000793c:	8d 0b       	st.w	r6[0x0],r11
8000793e:	f4 ea 00 00 	ld.d	r10,r10[0]
80007942:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007946:	c0 f8       	rjmp	80007964 <get_arg+0x1c8>
80007948:	f4 cb ff fc 	sub	r11,r10,-4
8000794c:	8d 0b       	st.w	r6[0x0],r11
8000794e:	74 0a       	ld.w	r10,r10[0x0]
80007950:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007954:	c0 88       	rjmp	80007964 <get_arg+0x1c8>
80007956:	f4 cb ff f8 	sub	r11,r10,-8
8000795a:	8d 0b       	st.w	r6[0x0],r11
8000795c:	f4 ea 00 00 	ld.d	r10,r10[0]
80007960:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007964:	0e 9b       	mov	r11,r7
80007966:	18 95       	mov	r5,r12
80007968:	c4 e8       	rjmp	80007a04 <get_arg+0x268>
8000796a:	62 0a       	ld.w	r10,r1[0x0]
8000796c:	5b fa       	cp.w	r10,-1
8000796e:	c0 b1       	brne	80007984 <get_arg+0x1e8>
80007970:	50 19       	stdsp	sp[0x4],r9
80007972:	50 28       	stdsp	sp[0x8],r8
80007974:	e0 6a 00 80 	mov	r10,128
80007978:	30 0b       	mov	r11,0
8000797a:	02 9c       	mov	r12,r1
8000797c:	fe b0 fd 00 	rcall	8000737c <memset>
80007980:	40 28       	lddsp	r8,sp[0x8]
80007982:	40 19       	lddsp	r9,sp[0x4]
80007984:	e4 cc 00 01 	sub	r12,r2,1
80007988:	0e 9b       	mov	r11,r7
8000798a:	50 3c       	stdsp	sp[0xc],r12
8000798c:	f2 0c 0c 49 	max	r9,r9,r12
80007990:	c3 a8       	rjmp	80007a04 <get_arg+0x268>
80007992:	62 0a       	ld.w	r10,r1[0x0]
80007994:	5b fa       	cp.w	r10,-1
80007996:	c0 b1       	brne	800079ac <get_arg+0x210>
80007998:	50 19       	stdsp	sp[0x4],r9
8000799a:	50 28       	stdsp	sp[0x8],r8
8000799c:	e0 6a 00 80 	mov	r10,128
800079a0:	30 0b       	mov	r11,0
800079a2:	02 9c       	mov	r12,r1
800079a4:	fe b0 fc ec 	rcall	8000737c <memset>
800079a8:	40 28       	lddsp	r8,sp[0x8]
800079aa:	40 19       	lddsp	r9,sp[0x4]
800079ac:	20 12       	sub	r2,1
800079ae:	30 0a       	mov	r10,0
800079b0:	0e 9b       	mov	r11,r7
800079b2:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
800079b6:	f2 02 0c 49 	max	r9,r9,r2
800079ba:	c2 58       	rjmp	80007a04 <get_arg+0x268>
800079bc:	16 97       	mov	r7,r11
800079be:	6c 0a       	ld.w	r10,r6[0x0]
800079c0:	f4 cb ff fc 	sub	r11,r10,-4
800079c4:	8d 0b       	st.w	r6[0x0],r11
800079c6:	74 0a       	ld.w	r10,r10[0x0]
800079c8:	0e 9b       	mov	r11,r7
800079ca:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800079ce:	2f f5       	sub	r5,-1
800079d0:	c1 a8       	rjmp	80007a04 <get_arg+0x268>
800079d2:	f4 c2 00 30 	sub	r2,r10,48
800079d6:	c0 68       	rjmp	800079e2 <get_arg+0x246>
800079d8:	e4 02 00 22 	add	r2,r2,r2<<0x2
800079dc:	2f f7       	sub	r7,-1
800079de:	f4 02 00 12 	add	r2,r10,r2<<0x1
800079e2:	0f 8a       	ld.ub	r10,r7[0x0]
800079e4:	58 0a       	cp.w	r10,0
800079e6:	c0 e0       	breq	80007a02 <get_arg+0x266>
800079e8:	23 0a       	sub	r10,48
800079ea:	58 9a       	cp.w	r10,9
800079ec:	fe 98 ff f6 	brls	800079d8 <get_arg+0x23c>
800079f0:	c0 98       	rjmp	80007a02 <get_arg+0x266>
800079f2:	2f f7       	sub	r7,-1
800079f4:	0f 8a       	ld.ub	r10,r7[0x0]
800079f6:	58 0a       	cp.w	r10,0
800079f8:	c0 50       	breq	80007a02 <get_arg+0x266>
800079fa:	23 0a       	sub	r10,48
800079fc:	58 9a       	cp.w	r10,9
800079fe:	fe 98 ff fa 	brls	800079f2 <get_arg+0x256>
80007a02:	0e 9b       	mov	r11,r7
80007a04:	40 7c       	lddsp	r12,sp[0x1c]
80007a06:	30 ba       	mov	r10,11
80007a08:	f4 0c 18 00 	cp.b	r12,r10
80007a0c:	fe 91 fe f2 	brne	800077f0 <get_arg+0x54>
80007a10:	40 42       	lddsp	r2,sp[0x10]
80007a12:	17 8c       	ld.ub	r12,r11[0x0]
80007a14:	0a 32       	cp.w	r2,r5
80007a16:	5f 4a       	srge	r10
80007a18:	f0 0c 18 00 	cp.b	r12,r8
80007a1c:	5f 1c       	srne	r12
80007a1e:	f9 ea 00 0a 	and	r10,r12,r10
80007a22:	f0 0a 18 00 	cp.b	r10,r8
80007a26:	fe 91 fe cf 	brne	800077c4 <get_arg+0x28>
80007a2a:	30 08       	mov	r8,0
80007a2c:	40 4e       	lddsp	lr,sp[0x10]
80007a2e:	17 8a       	ld.ub	r10,r11[0x0]
80007a30:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007a34:	f0 0a 18 00 	cp.b	r10,r8
80007a38:	fc 09 17 10 	movne	r9,lr
80007a3c:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007a40:	06 9e       	mov	lr,r3
80007a42:	c2 a8       	rjmp	80007a96 <get_arg+0x2fa>
80007a44:	62 0a       	ld.w	r10,r1[0x0]
80007a46:	58 3a       	cp.w	r10,3
80007a48:	c1 e0       	breq	80007a84 <get_arg+0x2e8>
80007a4a:	e0 89 00 07 	brgt	80007a58 <get_arg+0x2bc>
80007a4e:	58 1a       	cp.w	r10,1
80007a50:	c1 a0       	breq	80007a84 <get_arg+0x2e8>
80007a52:	58 2a       	cp.w	r10,2
80007a54:	c1 81       	brne	80007a84 <get_arg+0x2e8>
80007a56:	c0 58       	rjmp	80007a60 <get_arg+0x2c4>
80007a58:	58 5a       	cp.w	r10,5
80007a5a:	c0 c0       	breq	80007a72 <get_arg+0x2d6>
80007a5c:	c0 b5       	brlt	80007a72 <get_arg+0x2d6>
80007a5e:	c1 38       	rjmp	80007a84 <get_arg+0x2e8>
80007a60:	6c 0a       	ld.w	r10,r6[0x0]
80007a62:	f4 cc ff f8 	sub	r12,r10,-8
80007a66:	8d 0c       	st.w	r6[0x0],r12
80007a68:	f4 e2 00 00 	ld.d	r2,r10[0]
80007a6c:	f0 e3 00 00 	st.d	r8[0],r2
80007a70:	c1 08       	rjmp	80007a90 <get_arg+0x2f4>
80007a72:	6c 0a       	ld.w	r10,r6[0x0]
80007a74:	f4 cc ff f8 	sub	r12,r10,-8
80007a78:	8d 0c       	st.w	r6[0x0],r12
80007a7a:	f4 e2 00 00 	ld.d	r2,r10[0]
80007a7e:	f0 e3 00 00 	st.d	r8[0],r2
80007a82:	c0 78       	rjmp	80007a90 <get_arg+0x2f4>
80007a84:	6c 0a       	ld.w	r10,r6[0x0]
80007a86:	f4 cc ff fc 	sub	r12,r10,-4
80007a8a:	8d 0c       	st.w	r6[0x0],r12
80007a8c:	74 0a       	ld.w	r10,r10[0x0]
80007a8e:	91 0a       	st.w	r8[0x0],r10
80007a90:	2f f5       	sub	r5,-1
80007a92:	2f 88       	sub	r8,-8
80007a94:	2f c1       	sub	r1,-4
80007a96:	12 35       	cp.w	r5,r9
80007a98:	fe 9a ff d6 	brle	80007a44 <get_arg+0x2a8>
80007a9c:	1c 93       	mov	r3,lr
80007a9e:	40 52       	lddsp	r2,sp[0x14]
80007aa0:	40 6e       	lddsp	lr,sp[0x18]
80007aa2:	85 05       	st.w	r2[0x0],r5
80007aa4:	9d 0b       	st.w	lr[0x0],r11
80007aa6:	40 4b       	lddsp	r11,sp[0x10]
80007aa8:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007aac:	2f 8d       	sub	sp,-32
80007aae:	d8 32       	popm	r0-r7,pc

80007ab0 <__sprint_r>:
80007ab0:	d4 21       	pushm	r4-r7,lr
80007ab2:	14 97       	mov	r7,r10
80007ab4:	74 28       	ld.w	r8,r10[0x8]
80007ab6:	58 08       	cp.w	r8,0
80007ab8:	c0 41       	brne	80007ac0 <__sprint_r+0x10>
80007aba:	95 18       	st.w	r10[0x4],r8
80007abc:	10 9c       	mov	r12,r8
80007abe:	d8 22       	popm	r4-r7,pc
80007ac0:	e0 a0 18 ba 	rcall	8000ac34 <__sfvwrite_r>
80007ac4:	30 08       	mov	r8,0
80007ac6:	8f 18       	st.w	r7[0x4],r8
80007ac8:	8f 28       	st.w	r7[0x8],r8
80007aca:	d8 22       	popm	r4-r7,pc

80007acc <_vfprintf_r>:
80007acc:	d4 31       	pushm	r0-r7,lr
80007ace:	fa cd 06 bc 	sub	sp,sp,1724
80007ad2:	51 09       	stdsp	sp[0x40],r9
80007ad4:	16 91       	mov	r1,r11
80007ad6:	14 97       	mov	r7,r10
80007ad8:	18 95       	mov	r5,r12
80007ada:	e0 a0 1a 1d 	rcall	8000af14 <_localeconv_r>
80007ade:	78 0c       	ld.w	r12,r12[0x0]
80007ae0:	50 cc       	stdsp	sp[0x30],r12
80007ae2:	58 05       	cp.w	r5,0
80007ae4:	c0 70       	breq	80007af2 <_vfprintf_r+0x26>
80007ae6:	6a 68       	ld.w	r8,r5[0x18]
80007ae8:	58 08       	cp.w	r8,0
80007aea:	c0 41       	brne	80007af2 <_vfprintf_r+0x26>
80007aec:	0a 9c       	mov	r12,r5
80007aee:	e0 a0 17 43 	rcall	8000a974 <__sinit>
80007af2:	fe c8 a1 5a 	sub	r8,pc,-24230
80007af6:	10 31       	cp.w	r1,r8
80007af8:	c0 31       	brne	80007afe <_vfprintf_r+0x32>
80007afa:	6a 01       	ld.w	r1,r5[0x0]
80007afc:	c0 c8       	rjmp	80007b14 <_vfprintf_r+0x48>
80007afe:	fe c8 a1 46 	sub	r8,pc,-24250
80007b02:	10 31       	cp.w	r1,r8
80007b04:	c0 31       	brne	80007b0a <_vfprintf_r+0x3e>
80007b06:	6a 11       	ld.w	r1,r5[0x4]
80007b08:	c0 68       	rjmp	80007b14 <_vfprintf_r+0x48>
80007b0a:	fe c8 a1 32 	sub	r8,pc,-24270
80007b0e:	10 31       	cp.w	r1,r8
80007b10:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007b14:	82 68       	ld.sh	r8,r1[0xc]
80007b16:	ed b8 00 03 	bld	r8,0x3
80007b1a:	c0 41       	brne	80007b22 <_vfprintf_r+0x56>
80007b1c:	62 48       	ld.w	r8,r1[0x10]
80007b1e:	58 08       	cp.w	r8,0
80007b20:	c0 71       	brne	80007b2e <_vfprintf_r+0x62>
80007b22:	02 9b       	mov	r11,r1
80007b24:	0a 9c       	mov	r12,r5
80007b26:	e0 a0 0f 5d 	rcall	800099e0 <__swsetup_r>
80007b2a:	e0 81 0f 54 	brne	800099d2 <_vfprintf_r+0x1f06>
80007b2e:	82 68       	ld.sh	r8,r1[0xc]
80007b30:	10 99       	mov	r9,r8
80007b32:	e2 19 00 1a 	andl	r9,0x1a,COH
80007b36:	58 a9       	cp.w	r9,10
80007b38:	c3 c1       	brne	80007bb0 <_vfprintf_r+0xe4>
80007b3a:	82 79       	ld.sh	r9,r1[0xe]
80007b3c:	30 0a       	mov	r10,0
80007b3e:	f4 09 19 00 	cp.h	r9,r10
80007b42:	c3 75       	brlt	80007bb0 <_vfprintf_r+0xe4>
80007b44:	a1 d8       	cbr	r8,0x1
80007b46:	fb 58 05 d0 	st.h	sp[1488],r8
80007b4a:	62 88       	ld.w	r8,r1[0x20]
80007b4c:	fb 48 05 e4 	st.w	sp[1508],r8
80007b50:	62 a8       	ld.w	r8,r1[0x28]
80007b52:	fb 48 05 ec 	st.w	sp[1516],r8
80007b56:	fa c8 ff bc 	sub	r8,sp,-68
80007b5a:	fb 48 05 d4 	st.w	sp[1492],r8
80007b5e:	fb 48 05 c4 	st.w	sp[1476],r8
80007b62:	e0 68 04 00 	mov	r8,1024
80007b66:	fb 48 05 d8 	st.w	sp[1496],r8
80007b6a:	fb 48 05 cc 	st.w	sp[1484],r8
80007b6e:	30 08       	mov	r8,0
80007b70:	fb 59 05 d2 	st.h	sp[1490],r9
80007b74:	0e 9a       	mov	r10,r7
80007b76:	41 09       	lddsp	r9,sp[0x40]
80007b78:	fa c7 fa 3c 	sub	r7,sp,-1476
80007b7c:	fb 48 05 dc 	st.w	sp[1500],r8
80007b80:	0a 9c       	mov	r12,r5
80007b82:	0e 9b       	mov	r11,r7
80007b84:	ca 4f       	rcall	80007acc <_vfprintf_r>
80007b86:	50 bc       	stdsp	sp[0x2c],r12
80007b88:	c0 95       	brlt	80007b9a <_vfprintf_r+0xce>
80007b8a:	0e 9b       	mov	r11,r7
80007b8c:	0a 9c       	mov	r12,r5
80007b8e:	e0 a0 16 1b 	rcall	8000a7c4 <_fflush_r>
80007b92:	40 be       	lddsp	lr,sp[0x2c]
80007b94:	f9 be 01 ff 	movne	lr,-1
80007b98:	50 be       	stdsp	sp[0x2c],lr
80007b9a:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007b9e:	ed b8 00 06 	bld	r8,0x6
80007ba2:	e0 81 0f 1a 	brne	800099d6 <_vfprintf_r+0x1f0a>
80007ba6:	82 68       	ld.sh	r8,r1[0xc]
80007ba8:	a7 a8       	sbr	r8,0x6
80007baa:	a2 68       	st.h	r1[0xc],r8
80007bac:	e0 8f 0f 15 	bral	800099d6 <_vfprintf_r+0x1f0a>
80007bb0:	30 08       	mov	r8,0
80007bb2:	fb 48 06 b4 	st.w	sp[1716],r8
80007bb6:	fb 48 06 90 	st.w	sp[1680],r8
80007bba:	fb 48 06 8c 	st.w	sp[1676],r8
80007bbe:	fb 48 06 b0 	st.w	sp[1712],r8
80007bc2:	30 08       	mov	r8,0
80007bc4:	30 09       	mov	r9,0
80007bc6:	50 a7       	stdsp	sp[0x28],r7
80007bc8:	50 78       	stdsp	sp[0x1c],r8
80007bca:	fa c3 f9 e0 	sub	r3,sp,-1568
80007bce:	3f f8       	mov	r8,-1
80007bd0:	50 59       	stdsp	sp[0x14],r9
80007bd2:	fb 43 06 88 	st.w	sp[1672],r3
80007bd6:	fb 48 05 44 	st.w	sp[1348],r8
80007bda:	12 9c       	mov	r12,r9
80007bdc:	50 69       	stdsp	sp[0x18],r9
80007bde:	50 d9       	stdsp	sp[0x34],r9
80007be0:	50 e9       	stdsp	sp[0x38],r9
80007be2:	50 b9       	stdsp	sp[0x2c],r9
80007be4:	12 97       	mov	r7,r9
80007be6:	0a 94       	mov	r4,r5
80007be8:	40 a2       	lddsp	r2,sp[0x28]
80007bea:	32 5a       	mov	r10,37
80007bec:	30 08       	mov	r8,0
80007bee:	c0 28       	rjmp	80007bf2 <_vfprintf_r+0x126>
80007bf0:	2f f2       	sub	r2,-1
80007bf2:	05 89       	ld.ub	r9,r2[0x0]
80007bf4:	f0 09 18 00 	cp.b	r9,r8
80007bf8:	5f 1b       	srne	r11
80007bfa:	f4 09 18 00 	cp.b	r9,r10
80007bfe:	5f 19       	srne	r9
80007c00:	f3 eb 00 0b 	and	r11,r9,r11
80007c04:	f0 0b 18 00 	cp.b	r11,r8
80007c08:	cf 41       	brne	80007bf0 <_vfprintf_r+0x124>
80007c0a:	40 ab       	lddsp	r11,sp[0x28]
80007c0c:	e4 0b 01 06 	sub	r6,r2,r11
80007c10:	c1 e0       	breq	80007c4c <_vfprintf_r+0x180>
80007c12:	fa f8 06 90 	ld.w	r8,sp[1680]
80007c16:	0c 08       	add	r8,r6
80007c18:	87 0b       	st.w	r3[0x0],r11
80007c1a:	fb 48 06 90 	st.w	sp[1680],r8
80007c1e:	87 16       	st.w	r3[0x4],r6
80007c20:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007c24:	2f f8       	sub	r8,-1
80007c26:	fb 48 06 8c 	st.w	sp[1676],r8
80007c2a:	58 78       	cp.w	r8,7
80007c2c:	e0 89 00 04 	brgt	80007c34 <_vfprintf_r+0x168>
80007c30:	2f 83       	sub	r3,-8
80007c32:	c0 a8       	rjmp	80007c46 <_vfprintf_r+0x17a>
80007c34:	fa ca f9 78 	sub	r10,sp,-1672
80007c38:	02 9b       	mov	r11,r1
80007c3a:	08 9c       	mov	r12,r4
80007c3c:	c3 af       	rcall	80007ab0 <__sprint_r>
80007c3e:	e0 81 0e c6 	brne	800099ca <_vfprintf_r+0x1efe>
80007c42:	fa c3 f9 e0 	sub	r3,sp,-1568
80007c46:	40 ba       	lddsp	r10,sp[0x2c]
80007c48:	0c 0a       	add	r10,r6
80007c4a:	50 ba       	stdsp	sp[0x2c],r10
80007c4c:	05 89       	ld.ub	r9,r2[0x0]
80007c4e:	30 08       	mov	r8,0
80007c50:	f0 09 18 00 	cp.b	r9,r8
80007c54:	e0 80 0e aa 	breq	800099a8 <_vfprintf_r+0x1edc>
80007c58:	30 09       	mov	r9,0
80007c5a:	fb 68 06 bb 	st.b	sp[1723],r8
80007c5e:	0e 96       	mov	r6,r7
80007c60:	e4 c8 ff ff 	sub	r8,r2,-1
80007c64:	3f fe       	mov	lr,-1
80007c66:	50 93       	stdsp	sp[0x24],r3
80007c68:	50 41       	stdsp	sp[0x10],r1
80007c6a:	0e 93       	mov	r3,r7
80007c6c:	04 91       	mov	r1,r2
80007c6e:	50 89       	stdsp	sp[0x20],r9
80007c70:	50 a8       	stdsp	sp[0x28],r8
80007c72:	50 2e       	stdsp	sp[0x8],lr
80007c74:	50 39       	stdsp	sp[0xc],r9
80007c76:	12 95       	mov	r5,r9
80007c78:	12 90       	mov	r0,r9
80007c7a:	10 97       	mov	r7,r8
80007c7c:	08 92       	mov	r2,r4
80007c7e:	c0 78       	rjmp	80007c8c <_vfprintf_r+0x1c0>
80007c80:	3f fc       	mov	r12,-1
80007c82:	08 97       	mov	r7,r4
80007c84:	50 2c       	stdsp	sp[0x8],r12
80007c86:	c0 38       	rjmp	80007c8c <_vfprintf_r+0x1c0>
80007c88:	30 0b       	mov	r11,0
80007c8a:	50 3b       	stdsp	sp[0xc],r11
80007c8c:	0f 38       	ld.ub	r8,r7++
80007c8e:	c0 28       	rjmp	80007c92 <_vfprintf_r+0x1c6>
80007c90:	12 90       	mov	r0,r9
80007c92:	f0 c9 00 20 	sub	r9,r8,32
80007c96:	e0 49 00 58 	cp.w	r9,88
80007c9a:	e0 8b 0a 30 	brhi	800090fa <_vfprintf_r+0x162e>
80007c9e:	fe ca a6 ae 	sub	r10,pc,-22866
80007ca2:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80007ca6:	50 a7       	stdsp	sp[0x28],r7
80007ca8:	50 80       	stdsp	sp[0x20],r0
80007caa:	0c 97       	mov	r7,r6
80007cac:	04 94       	mov	r4,r2
80007cae:	06 96       	mov	r6,r3
80007cb0:	02 92       	mov	r2,r1
80007cb2:	fe c9 a4 86 	sub	r9,pc,-23418
80007cb6:	40 93       	lddsp	r3,sp[0x24]
80007cb8:	10 90       	mov	r0,r8
80007cba:	40 41       	lddsp	r1,sp[0x10]
80007cbc:	50 d9       	stdsp	sp[0x34],r9
80007cbe:	e0 8f 08 8e 	bral	80008dda <_vfprintf_r+0x130e>
80007cc2:	30 08       	mov	r8,0
80007cc4:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80007cc8:	f0 09 18 00 	cp.b	r9,r8
80007ccc:	ce 01       	brne	80007c8c <_vfprintf_r+0x1c0>
80007cce:	32 08       	mov	r8,32
80007cd0:	c6 e8       	rjmp	80007dac <_vfprintf_r+0x2e0>
80007cd2:	a1 a5       	sbr	r5,0x0
80007cd4:	cd cb       	rjmp	80007c8c <_vfprintf_r+0x1c0>
80007cd6:	0f 89       	ld.ub	r9,r7[0x0]
80007cd8:	f2 c8 00 30 	sub	r8,r9,48
80007cdc:	58 98       	cp.w	r8,9
80007cde:	e0 8b 00 1d 	brhi	80007d18 <_vfprintf_r+0x24c>
80007ce2:	ee c8 ff ff 	sub	r8,r7,-1
80007ce6:	30 0b       	mov	r11,0
80007ce8:	23 09       	sub	r9,48
80007cea:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007cee:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80007cf2:	11 39       	ld.ub	r9,r8++
80007cf4:	f2 ca 00 30 	sub	r10,r9,48
80007cf8:	58 9a       	cp.w	r10,9
80007cfa:	fe 98 ff f7 	brls	80007ce8 <_vfprintf_r+0x21c>
80007cfe:	e0 49 00 24 	cp.w	r9,36
80007d02:	cc 31       	brne	80007c88 <_vfprintf_r+0x1bc>
80007d04:	e0 4b 00 20 	cp.w	r11,32
80007d08:	e0 89 0e 60 	brgt	800099c8 <_vfprintf_r+0x1efc>
80007d0c:	20 1b       	sub	r11,1
80007d0e:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007d12:	12 3b       	cp.w	r11,r9
80007d14:	c0 95       	brlt	80007d26 <_vfprintf_r+0x25a>
80007d16:	c1 08       	rjmp	80007d36 <_vfprintf_r+0x26a>
80007d18:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007d1c:	ec ca ff ff 	sub	r10,r6,-1
80007d20:	12 36       	cp.w	r6,r9
80007d22:	c1 f5       	brlt	80007d60 <_vfprintf_r+0x294>
80007d24:	c2 68       	rjmp	80007d70 <_vfprintf_r+0x2a4>
80007d26:	fa ce f9 44 	sub	lr,sp,-1724
80007d2a:	10 97       	mov	r7,r8
80007d2c:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007d30:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007d34:	c3 58       	rjmp	80007d9e <_vfprintf_r+0x2d2>
80007d36:	10 97       	mov	r7,r8
80007d38:	fa c8 f9 50 	sub	r8,sp,-1712
80007d3c:	1a d8       	st.w	--sp,r8
80007d3e:	fa c8 fa b8 	sub	r8,sp,-1352
80007d42:	1a d8       	st.w	--sp,r8
80007d44:	fa c8 fb b4 	sub	r8,sp,-1100
80007d48:	02 9a       	mov	r10,r1
80007d4a:	1a d8       	st.w	--sp,r8
80007d4c:	04 9c       	mov	r12,r2
80007d4e:	fa c8 f9 40 	sub	r8,sp,-1728
80007d52:	fa c9 ff b4 	sub	r9,sp,-76
80007d56:	fe b0 fd 23 	rcall	8000779c <get_arg>
80007d5a:	2f dd       	sub	sp,-12
80007d5c:	78 00       	ld.w	r0,r12[0x0]
80007d5e:	c2 08       	rjmp	80007d9e <_vfprintf_r+0x2d2>
80007d60:	fa cc f9 44 	sub	r12,sp,-1724
80007d64:	14 96       	mov	r6,r10
80007d66:	f8 03 00 38 	add	r8,r12,r3<<0x3
80007d6a:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007d6e:	c1 88       	rjmp	80007d9e <_vfprintf_r+0x2d2>
80007d70:	41 08       	lddsp	r8,sp[0x40]
80007d72:	59 f9       	cp.w	r9,31
80007d74:	e0 89 00 11 	brgt	80007d96 <_vfprintf_r+0x2ca>
80007d78:	f0 cb ff fc 	sub	r11,r8,-4
80007d7c:	51 0b       	stdsp	sp[0x40],r11
80007d7e:	70 00       	ld.w	r0,r8[0x0]
80007d80:	fa cb f9 44 	sub	r11,sp,-1724
80007d84:	f6 09 00 38 	add	r8,r11,r9<<0x3
80007d88:	f1 40 fd 88 	st.w	r8[-632],r0
80007d8c:	2f f9       	sub	r9,-1
80007d8e:	14 96       	mov	r6,r10
80007d90:	fb 49 06 b4 	st.w	sp[1716],r9
80007d94:	c0 58       	rjmp	80007d9e <_vfprintf_r+0x2d2>
80007d96:	70 00       	ld.w	r0,r8[0x0]
80007d98:	14 96       	mov	r6,r10
80007d9a:	2f c8       	sub	r8,-4
80007d9c:	51 08       	stdsp	sp[0x40],r8
80007d9e:	58 00       	cp.w	r0,0
80007da0:	fe 94 ff 76 	brge	80007c8c <_vfprintf_r+0x1c0>
80007da4:	5c 30       	neg	r0
80007da6:	a3 a5       	sbr	r5,0x2
80007da8:	c7 2b       	rjmp	80007c8c <_vfprintf_r+0x1c0>
80007daa:	32 b8       	mov	r8,43
80007dac:	fb 68 06 bb 	st.b	sp[1723],r8
80007db0:	c6 eb       	rjmp	80007c8c <_vfprintf_r+0x1c0>
80007db2:	0f 38       	ld.ub	r8,r7++
80007db4:	e0 48 00 2a 	cp.w	r8,42
80007db8:	c0 30       	breq	80007dbe <_vfprintf_r+0x2f2>
80007dba:	30 09       	mov	r9,0
80007dbc:	c7 98       	rjmp	80007eae <_vfprintf_r+0x3e2>
80007dbe:	0f 88       	ld.ub	r8,r7[0x0]
80007dc0:	f0 c9 00 30 	sub	r9,r8,48
80007dc4:	58 99       	cp.w	r9,9
80007dc6:	e0 8b 00 1f 	brhi	80007e04 <_vfprintf_r+0x338>
80007dca:	ee c4 ff ff 	sub	r4,r7,-1
80007dce:	30 0b       	mov	r11,0
80007dd0:	23 08       	sub	r8,48
80007dd2:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007dd6:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80007dda:	09 38       	ld.ub	r8,r4++
80007ddc:	f0 c9 00 30 	sub	r9,r8,48
80007de0:	58 99       	cp.w	r9,9
80007de2:	fe 98 ff f7 	brls	80007dd0 <_vfprintf_r+0x304>
80007de6:	e0 48 00 24 	cp.w	r8,36
80007dea:	fe 91 ff 4f 	brne	80007c88 <_vfprintf_r+0x1bc>
80007dee:	e0 4b 00 20 	cp.w	r11,32
80007df2:	e0 89 0d eb 	brgt	800099c8 <_vfprintf_r+0x1efc>
80007df6:	20 1b       	sub	r11,1
80007df8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007dfc:	10 3b       	cp.w	r11,r8
80007dfe:	c0 a5       	brlt	80007e12 <_vfprintf_r+0x346>
80007e00:	c1 18       	rjmp	80007e22 <_vfprintf_r+0x356>
80007e02:	d7 03       	nop
80007e04:	fa fa 06 b4 	ld.w	r10,sp[1716]
80007e08:	ec c9 ff ff 	sub	r9,r6,-1
80007e0c:	14 36       	cp.w	r6,r10
80007e0e:	c1 f5       	brlt	80007e4c <_vfprintf_r+0x380>
80007e10:	c2 88       	rjmp	80007e60 <_vfprintf_r+0x394>
80007e12:	fa ca f9 44 	sub	r10,sp,-1724
80007e16:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80007e1a:	f6 fb fd 88 	ld.w	r11,r11[-632]
80007e1e:	50 2b       	stdsp	sp[0x8],r11
80007e20:	c3 c8       	rjmp	80007e98 <_vfprintf_r+0x3cc>
80007e22:	fa c8 f9 50 	sub	r8,sp,-1712
80007e26:	1a d8       	st.w	--sp,r8
80007e28:	fa c8 fa b8 	sub	r8,sp,-1352
80007e2c:	1a d8       	st.w	--sp,r8
80007e2e:	fa c8 fb b4 	sub	r8,sp,-1100
80007e32:	02 9a       	mov	r10,r1
80007e34:	1a d8       	st.w	--sp,r8
80007e36:	04 9c       	mov	r12,r2
80007e38:	fa c8 f9 40 	sub	r8,sp,-1728
80007e3c:	fa c9 ff b4 	sub	r9,sp,-76
80007e40:	fe b0 fc ae 	rcall	8000779c <get_arg>
80007e44:	2f dd       	sub	sp,-12
80007e46:	78 0c       	ld.w	r12,r12[0x0]
80007e48:	50 2c       	stdsp	sp[0x8],r12
80007e4a:	c2 78       	rjmp	80007e98 <_vfprintf_r+0x3cc>
80007e4c:	12 96       	mov	r6,r9
80007e4e:	0e 94       	mov	r4,r7
80007e50:	fa c9 f9 44 	sub	r9,sp,-1724
80007e54:	f2 03 00 38 	add	r8,r9,r3<<0x3
80007e58:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007e5c:	50 28       	stdsp	sp[0x8],r8
80007e5e:	c1 d8       	rjmp	80007e98 <_vfprintf_r+0x3cc>
80007e60:	41 08       	lddsp	r8,sp[0x40]
80007e62:	59 fa       	cp.w	r10,31
80007e64:	e0 89 00 14 	brgt	80007e8c <_vfprintf_r+0x3c0>
80007e68:	f0 cb ff fc 	sub	r11,r8,-4
80007e6c:	70 08       	ld.w	r8,r8[0x0]
80007e6e:	51 0b       	stdsp	sp[0x40],r11
80007e70:	50 28       	stdsp	sp[0x8],r8
80007e72:	fa c6 f9 44 	sub	r6,sp,-1724
80007e76:	40 2e       	lddsp	lr,sp[0x8]
80007e78:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007e7c:	f1 4e fd 88 	st.w	r8[-632],lr
80007e80:	2f fa       	sub	r10,-1
80007e82:	0e 94       	mov	r4,r7
80007e84:	fb 4a 06 b4 	st.w	sp[1716],r10
80007e88:	12 96       	mov	r6,r9
80007e8a:	c0 78       	rjmp	80007e98 <_vfprintf_r+0x3cc>
80007e8c:	70 0c       	ld.w	r12,r8[0x0]
80007e8e:	0e 94       	mov	r4,r7
80007e90:	2f c8       	sub	r8,-4
80007e92:	50 2c       	stdsp	sp[0x8],r12
80007e94:	12 96       	mov	r6,r9
80007e96:	51 08       	stdsp	sp[0x40],r8
80007e98:	40 2b       	lddsp	r11,sp[0x8]
80007e9a:	58 0b       	cp.w	r11,0
80007e9c:	fe 95 fe f2 	brlt	80007c80 <_vfprintf_r+0x1b4>
80007ea0:	08 97       	mov	r7,r4
80007ea2:	cf 5a       	rjmp	80007c8c <_vfprintf_r+0x1c0>
80007ea4:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007ea8:	0f 38       	ld.ub	r8,r7++
80007eaa:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007eae:	f0 ca 00 30 	sub	r10,r8,48
80007eb2:	58 9a       	cp.w	r10,9
80007eb4:	fe 98 ff f8 	brls	80007ea4 <_vfprintf_r+0x3d8>
80007eb8:	3f fa       	mov	r10,-1
80007eba:	f2 0a 0c 49 	max	r9,r9,r10
80007ebe:	50 29       	stdsp	sp[0x8],r9
80007ec0:	ce 9a       	rjmp	80007c92 <_vfprintf_r+0x1c6>
80007ec2:	a7 b5       	sbr	r5,0x7
80007ec4:	ce 4a       	rjmp	80007c8c <_vfprintf_r+0x1c0>
80007ec6:	30 09       	mov	r9,0
80007ec8:	23 08       	sub	r8,48
80007eca:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007ece:	f0 09 00 19 	add	r9,r8,r9<<0x1
80007ed2:	0f 38       	ld.ub	r8,r7++
80007ed4:	f0 ca 00 30 	sub	r10,r8,48
80007ed8:	58 9a       	cp.w	r10,9
80007eda:	fe 98 ff f7 	brls	80007ec8 <_vfprintf_r+0x3fc>
80007ede:	e0 48 00 24 	cp.w	r8,36
80007ee2:	fe 91 fe d7 	brne	80007c90 <_vfprintf_r+0x1c4>
80007ee6:	e0 49 00 20 	cp.w	r9,32
80007eea:	e0 89 0d 6f 	brgt	800099c8 <_vfprintf_r+0x1efc>
80007eee:	f2 c3 00 01 	sub	r3,r9,1
80007ef2:	30 19       	mov	r9,1
80007ef4:	50 39       	stdsp	sp[0xc],r9
80007ef6:	cc ba       	rjmp	80007c8c <_vfprintf_r+0x1c0>
80007ef8:	a3 b5       	sbr	r5,0x3
80007efa:	cc 9a       	rjmp	80007c8c <_vfprintf_r+0x1c0>
80007efc:	a7 a5       	sbr	r5,0x6
80007efe:	cc 7a       	rjmp	80007c8c <_vfprintf_r+0x1c0>
80007f00:	0a 98       	mov	r8,r5
80007f02:	a5 b5       	sbr	r5,0x5
80007f04:	a5 a8       	sbr	r8,0x4
80007f06:	0f 89       	ld.ub	r9,r7[0x0]
80007f08:	36 ce       	mov	lr,108
80007f0a:	fc 09 18 00 	cp.b	r9,lr
80007f0e:	f7 b7 00 ff 	subeq	r7,-1
80007f12:	f0 05 17 10 	movne	r5,r8
80007f16:	cb ba       	rjmp	80007c8c <_vfprintf_r+0x1c0>
80007f18:	a5 b5       	sbr	r5,0x5
80007f1a:	cb 9a       	rjmp	80007c8c <_vfprintf_r+0x1c0>
80007f1c:	50 a7       	stdsp	sp[0x28],r7
80007f1e:	50 80       	stdsp	sp[0x20],r0
80007f20:	0c 97       	mov	r7,r6
80007f22:	10 90       	mov	r0,r8
80007f24:	06 96       	mov	r6,r3
80007f26:	04 94       	mov	r4,r2
80007f28:	40 93       	lddsp	r3,sp[0x24]
80007f2a:	02 92       	mov	r2,r1
80007f2c:	0e 99       	mov	r9,r7
80007f2e:	40 41       	lddsp	r1,sp[0x10]
80007f30:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007f34:	40 3c       	lddsp	r12,sp[0xc]
80007f36:	58 0c       	cp.w	r12,0
80007f38:	c1 d0       	breq	80007f72 <_vfprintf_r+0x4a6>
80007f3a:	10 36       	cp.w	r6,r8
80007f3c:	c0 64       	brge	80007f48 <_vfprintf_r+0x47c>
80007f3e:	fa cb f9 44 	sub	r11,sp,-1724
80007f42:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007f46:	c1 d8       	rjmp	80007f80 <_vfprintf_r+0x4b4>
80007f48:	fa c8 f9 50 	sub	r8,sp,-1712
80007f4c:	1a d8       	st.w	--sp,r8
80007f4e:	fa c8 fa b8 	sub	r8,sp,-1352
80007f52:	1a d8       	st.w	--sp,r8
80007f54:	fa c8 fb b4 	sub	r8,sp,-1100
80007f58:	1a d8       	st.w	--sp,r8
80007f5a:	fa c8 f9 40 	sub	r8,sp,-1728
80007f5e:	fa c9 ff b4 	sub	r9,sp,-76
80007f62:	04 9a       	mov	r10,r2
80007f64:	0c 9b       	mov	r11,r6
80007f66:	08 9c       	mov	r12,r4
80007f68:	fe b0 fc 1a 	rcall	8000779c <get_arg>
80007f6c:	2f dd       	sub	sp,-12
80007f6e:	19 b8       	ld.ub	r8,r12[0x3]
80007f70:	c2 28       	rjmp	80007fb4 <_vfprintf_r+0x4e8>
80007f72:	2f f7       	sub	r7,-1
80007f74:	10 39       	cp.w	r9,r8
80007f76:	c0 84       	brge	80007f86 <_vfprintf_r+0x4ba>
80007f78:	fa ca f9 44 	sub	r10,sp,-1724
80007f7c:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007f80:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80007f84:	c1 88       	rjmp	80007fb4 <_vfprintf_r+0x4e8>
80007f86:	41 09       	lddsp	r9,sp[0x40]
80007f88:	59 f8       	cp.w	r8,31
80007f8a:	e0 89 00 12 	brgt	80007fae <_vfprintf_r+0x4e2>
80007f8e:	f2 ca ff fc 	sub	r10,r9,-4
80007f92:	51 0a       	stdsp	sp[0x40],r10
80007f94:	72 09       	ld.w	r9,r9[0x0]
80007f96:	fa c6 f9 44 	sub	r6,sp,-1724
80007f9a:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007f9e:	2f f8       	sub	r8,-1
80007fa0:	f5 49 fd 88 	st.w	r10[-632],r9
80007fa4:	fb 48 06 b4 	st.w	sp[1716],r8
80007fa8:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80007fac:	c0 48       	rjmp	80007fb4 <_vfprintf_r+0x4e8>
80007fae:	13 b8       	ld.ub	r8,r9[0x3]
80007fb0:	2f c9       	sub	r9,-4
80007fb2:	51 09       	stdsp	sp[0x40],r9
80007fb4:	fb 68 06 60 	st.b	sp[1632],r8
80007fb8:	30 0e       	mov	lr,0
80007fba:	30 08       	mov	r8,0
80007fbc:	30 12       	mov	r2,1
80007fbe:	fb 68 06 bb 	st.b	sp[1723],r8
80007fc2:	50 2e       	stdsp	sp[0x8],lr
80007fc4:	e0 8f 08 ad 	bral	8000911e <_vfprintf_r+0x1652>
80007fc8:	50 a7       	stdsp	sp[0x28],r7
80007fca:	50 80       	stdsp	sp[0x20],r0
80007fcc:	0c 97       	mov	r7,r6
80007fce:	04 94       	mov	r4,r2
80007fd0:	06 96       	mov	r6,r3
80007fd2:	02 92       	mov	r2,r1
80007fd4:	40 93       	lddsp	r3,sp[0x24]
80007fd6:	10 90       	mov	r0,r8
80007fd8:	40 41       	lddsp	r1,sp[0x10]
80007fda:	a5 a5       	sbr	r5,0x4
80007fdc:	c0 a8       	rjmp	80007ff0 <_vfprintf_r+0x524>
80007fde:	50 a7       	stdsp	sp[0x28],r7
80007fe0:	50 80       	stdsp	sp[0x20],r0
80007fe2:	0c 97       	mov	r7,r6
80007fe4:	04 94       	mov	r4,r2
80007fe6:	06 96       	mov	r6,r3
80007fe8:	02 92       	mov	r2,r1
80007fea:	40 93       	lddsp	r3,sp[0x24]
80007fec:	10 90       	mov	r0,r8
80007fee:	40 41       	lddsp	r1,sp[0x10]
80007ff0:	ed b5 00 05 	bld	r5,0x5
80007ff4:	c5 11       	brne	80008096 <_vfprintf_r+0x5ca>
80007ff6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007ffa:	40 3c       	lddsp	r12,sp[0xc]
80007ffc:	58 0c       	cp.w	r12,0
80007ffe:	c1 e0       	breq	8000803a <_vfprintf_r+0x56e>
80008000:	10 36       	cp.w	r6,r8
80008002:	c0 64       	brge	8000800e <_vfprintf_r+0x542>
80008004:	fa cb f9 44 	sub	r11,sp,-1724
80008008:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000800c:	c2 08       	rjmp	8000804c <_vfprintf_r+0x580>
8000800e:	fa c8 f9 50 	sub	r8,sp,-1712
80008012:	1a d8       	st.w	--sp,r8
80008014:	fa c8 fa b8 	sub	r8,sp,-1352
80008018:	0c 9b       	mov	r11,r6
8000801a:	1a d8       	st.w	--sp,r8
8000801c:	fa c8 fb b4 	sub	r8,sp,-1100
80008020:	1a d8       	st.w	--sp,r8
80008022:	fa c9 ff b4 	sub	r9,sp,-76
80008026:	fa c8 f9 40 	sub	r8,sp,-1728
8000802a:	04 9a       	mov	r10,r2
8000802c:	08 9c       	mov	r12,r4
8000802e:	fe b0 fb b7 	rcall	8000779c <get_arg>
80008032:	2f dd       	sub	sp,-12
80008034:	78 1b       	ld.w	r11,r12[0x4]
80008036:	78 09       	ld.w	r9,r12[0x0]
80008038:	c2 b8       	rjmp	8000808e <_vfprintf_r+0x5c2>
8000803a:	ee ca ff ff 	sub	r10,r7,-1
8000803e:	10 37       	cp.w	r7,r8
80008040:	c0 b4       	brge	80008056 <_vfprintf_r+0x58a>
80008042:	fa c9 f9 44 	sub	r9,sp,-1724
80008046:	14 97       	mov	r7,r10
80008048:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000804c:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008050:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008054:	c1 d8       	rjmp	8000808e <_vfprintf_r+0x5c2>
80008056:	41 09       	lddsp	r9,sp[0x40]
80008058:	59 f8       	cp.w	r8,31
8000805a:	e0 89 00 14 	brgt	80008082 <_vfprintf_r+0x5b6>
8000805e:	f2 cb ff f8 	sub	r11,r9,-8
80008062:	51 0b       	stdsp	sp[0x40],r11
80008064:	fa c6 f9 44 	sub	r6,sp,-1724
80008068:	72 1b       	ld.w	r11,r9[0x4]
8000806a:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000806e:	72 09       	ld.w	r9,r9[0x0]
80008070:	f9 4b fd 8c 	st.w	r12[-628],r11
80008074:	f9 49 fd 88 	st.w	r12[-632],r9
80008078:	2f f8       	sub	r8,-1
8000807a:	14 97       	mov	r7,r10
8000807c:	fb 48 06 b4 	st.w	sp[1716],r8
80008080:	c0 78       	rjmp	8000808e <_vfprintf_r+0x5c2>
80008082:	f2 c8 ff f8 	sub	r8,r9,-8
80008086:	72 1b       	ld.w	r11,r9[0x4]
80008088:	14 97       	mov	r7,r10
8000808a:	51 08       	stdsp	sp[0x40],r8
8000808c:	72 09       	ld.w	r9,r9[0x0]
8000808e:	16 98       	mov	r8,r11
80008090:	fa e9 00 00 	st.d	sp[0],r8
80008094:	ca e8       	rjmp	800081f0 <_vfprintf_r+0x724>
80008096:	ed b5 00 04 	bld	r5,0x4
8000809a:	c1 71       	brne	800080c8 <_vfprintf_r+0x5fc>
8000809c:	fa f8 06 b4 	ld.w	r8,sp[1716]
800080a0:	40 3e       	lddsp	lr,sp[0xc]
800080a2:	58 0e       	cp.w	lr,0
800080a4:	c0 80       	breq	800080b4 <_vfprintf_r+0x5e8>
800080a6:	10 36       	cp.w	r6,r8
800080a8:	c6 94       	brge	8000817a <_vfprintf_r+0x6ae>
800080aa:	fa cc f9 44 	sub	r12,sp,-1724
800080ae:	f8 06 00 36 	add	r6,r12,r6<<0x3
800080b2:	c8 28       	rjmp	800081b6 <_vfprintf_r+0x6ea>
800080b4:	ee ca ff ff 	sub	r10,r7,-1
800080b8:	10 37       	cp.w	r7,r8
800080ba:	e0 84 00 81 	brge	800081bc <_vfprintf_r+0x6f0>
800080be:	fa cb f9 44 	sub	r11,sp,-1724
800080c2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800080c6:	c7 78       	rjmp	800081b4 <_vfprintf_r+0x6e8>
800080c8:	ed b5 00 06 	bld	r5,0x6
800080cc:	c4 b1       	brne	80008162 <_vfprintf_r+0x696>
800080ce:	fa f8 06 b4 	ld.w	r8,sp[1716]
800080d2:	40 3c       	lddsp	r12,sp[0xc]
800080d4:	58 0c       	cp.w	r12,0
800080d6:	c1 d0       	breq	80008110 <_vfprintf_r+0x644>
800080d8:	10 36       	cp.w	r6,r8
800080da:	c0 64       	brge	800080e6 <_vfprintf_r+0x61a>
800080dc:	fa cb f9 44 	sub	r11,sp,-1724
800080e0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800080e4:	c1 f8       	rjmp	80008122 <_vfprintf_r+0x656>
800080e6:	fa c8 f9 50 	sub	r8,sp,-1712
800080ea:	1a d8       	st.w	--sp,r8
800080ec:	fa c8 fa b8 	sub	r8,sp,-1352
800080f0:	1a d8       	st.w	--sp,r8
800080f2:	fa c8 fb b4 	sub	r8,sp,-1100
800080f6:	1a d8       	st.w	--sp,r8
800080f8:	fa c8 f9 40 	sub	r8,sp,-1728
800080fc:	fa c9 ff b4 	sub	r9,sp,-76
80008100:	04 9a       	mov	r10,r2
80008102:	0c 9b       	mov	r11,r6
80008104:	08 9c       	mov	r12,r4
80008106:	fe b0 fb 4b 	rcall	8000779c <get_arg>
8000810a:	2f dd       	sub	sp,-12
8000810c:	98 18       	ld.sh	r8,r12[0x2]
8000810e:	c2 68       	rjmp	8000815a <_vfprintf_r+0x68e>
80008110:	ee ca ff ff 	sub	r10,r7,-1
80008114:	10 37       	cp.w	r7,r8
80008116:	c0 94       	brge	80008128 <_vfprintf_r+0x65c>
80008118:	fa c9 f9 44 	sub	r9,sp,-1724
8000811c:	14 97       	mov	r7,r10
8000811e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008122:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008126:	c1 a8       	rjmp	8000815a <_vfprintf_r+0x68e>
80008128:	41 09       	lddsp	r9,sp[0x40]
8000812a:	59 f8       	cp.w	r8,31
8000812c:	e0 89 00 13 	brgt	80008152 <_vfprintf_r+0x686>
80008130:	f2 cb ff fc 	sub	r11,r9,-4
80008134:	51 0b       	stdsp	sp[0x40],r11
80008136:	72 09       	ld.w	r9,r9[0x0]
80008138:	fa c6 f9 44 	sub	r6,sp,-1724
8000813c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008140:	2f f8       	sub	r8,-1
80008142:	f7 49 fd 88 	st.w	r11[-632],r9
80008146:	fb 48 06 b4 	st.w	sp[1716],r8
8000814a:	14 97       	mov	r7,r10
8000814c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008150:	c0 58       	rjmp	8000815a <_vfprintf_r+0x68e>
80008152:	92 18       	ld.sh	r8,r9[0x2]
80008154:	14 97       	mov	r7,r10
80008156:	2f c9       	sub	r9,-4
80008158:	51 09       	stdsp	sp[0x40],r9
8000815a:	50 18       	stdsp	sp[0x4],r8
8000815c:	bf 58       	asr	r8,0x1f
8000815e:	50 08       	stdsp	sp[0x0],r8
80008160:	c4 88       	rjmp	800081f0 <_vfprintf_r+0x724>
80008162:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008166:	40 3c       	lddsp	r12,sp[0xc]
80008168:	58 0c       	cp.w	r12,0
8000816a:	c1 d0       	breq	800081a4 <_vfprintf_r+0x6d8>
8000816c:	10 36       	cp.w	r6,r8
8000816e:	c0 64       	brge	8000817a <_vfprintf_r+0x6ae>
80008170:	fa cb f9 44 	sub	r11,sp,-1724
80008174:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008178:	c1 f8       	rjmp	800081b6 <_vfprintf_r+0x6ea>
8000817a:	fa c8 f9 50 	sub	r8,sp,-1712
8000817e:	1a d8       	st.w	--sp,r8
80008180:	fa c8 fa b8 	sub	r8,sp,-1352
80008184:	0c 9b       	mov	r11,r6
80008186:	1a d8       	st.w	--sp,r8
80008188:	fa c8 fb b4 	sub	r8,sp,-1100
8000818c:	04 9a       	mov	r10,r2
8000818e:	1a d8       	st.w	--sp,r8
80008190:	08 9c       	mov	r12,r4
80008192:	fa c8 f9 40 	sub	r8,sp,-1728
80008196:	fa c9 ff b4 	sub	r9,sp,-76
8000819a:	fe b0 fb 01 	rcall	8000779c <get_arg>
8000819e:	2f dd       	sub	sp,-12
800081a0:	78 0b       	ld.w	r11,r12[0x0]
800081a2:	c2 48       	rjmp	800081ea <_vfprintf_r+0x71e>
800081a4:	ee ca ff ff 	sub	r10,r7,-1
800081a8:	10 37       	cp.w	r7,r8
800081aa:	c0 94       	brge	800081bc <_vfprintf_r+0x6f0>
800081ac:	fa c9 f9 44 	sub	r9,sp,-1724
800081b0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800081b4:	14 97       	mov	r7,r10
800081b6:	ec fb fd 88 	ld.w	r11,r6[-632]
800081ba:	c1 88       	rjmp	800081ea <_vfprintf_r+0x71e>
800081bc:	41 09       	lddsp	r9,sp[0x40]
800081be:	59 f8       	cp.w	r8,31
800081c0:	e0 89 00 11 	brgt	800081e2 <_vfprintf_r+0x716>
800081c4:	f2 cb ff fc 	sub	r11,r9,-4
800081c8:	51 0b       	stdsp	sp[0x40],r11
800081ca:	fa c6 f9 44 	sub	r6,sp,-1724
800081ce:	72 0b       	ld.w	r11,r9[0x0]
800081d0:	ec 08 00 39 	add	r9,r6,r8<<0x3
800081d4:	f3 4b fd 88 	st.w	r9[-632],r11
800081d8:	2f f8       	sub	r8,-1
800081da:	14 97       	mov	r7,r10
800081dc:	fb 48 06 b4 	st.w	sp[1716],r8
800081e0:	c0 58       	rjmp	800081ea <_vfprintf_r+0x71e>
800081e2:	72 0b       	ld.w	r11,r9[0x0]
800081e4:	14 97       	mov	r7,r10
800081e6:	2f c9       	sub	r9,-4
800081e8:	51 09       	stdsp	sp[0x40],r9
800081ea:	50 1b       	stdsp	sp[0x4],r11
800081ec:	bf 5b       	asr	r11,0x1f
800081ee:	50 0b       	stdsp	sp[0x0],r11
800081f0:	fa ea 00 00 	ld.d	r10,sp[0]
800081f4:	58 0a       	cp.w	r10,0
800081f6:	5c 2b       	cpc	r11
800081f8:	c0 e4       	brge	80008214 <_vfprintf_r+0x748>
800081fa:	30 08       	mov	r8,0
800081fc:	fa ea 00 00 	ld.d	r10,sp[0]
80008200:	30 09       	mov	r9,0
80008202:	f0 0a 01 0a 	sub	r10,r8,r10
80008206:	f2 0b 01 4b 	sbc	r11,r9,r11
8000820a:	32 d8       	mov	r8,45
8000820c:	fa eb 00 00 	st.d	sp[0],r10
80008210:	fb 68 06 bb 	st.b	sp[1723],r8
80008214:	30 18       	mov	r8,1
80008216:	e0 8f 06 fa 	bral	8000900a <_vfprintf_r+0x153e>
8000821a:	50 a7       	stdsp	sp[0x28],r7
8000821c:	50 80       	stdsp	sp[0x20],r0
8000821e:	0c 97       	mov	r7,r6
80008220:	04 94       	mov	r4,r2
80008222:	06 96       	mov	r6,r3
80008224:	02 92       	mov	r2,r1
80008226:	40 93       	lddsp	r3,sp[0x24]
80008228:	10 90       	mov	r0,r8
8000822a:	40 41       	lddsp	r1,sp[0x10]
8000822c:	0e 99       	mov	r9,r7
8000822e:	ed b5 00 03 	bld	r5,0x3
80008232:	c4 11       	brne	800082b4 <_vfprintf_r+0x7e8>
80008234:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008238:	40 3a       	lddsp	r10,sp[0xc]
8000823a:	58 0a       	cp.w	r10,0
8000823c:	c1 90       	breq	8000826e <_vfprintf_r+0x7a2>
8000823e:	10 36       	cp.w	r6,r8
80008240:	c6 45       	brlt	80008308 <_vfprintf_r+0x83c>
80008242:	fa c8 f9 50 	sub	r8,sp,-1712
80008246:	1a d8       	st.w	--sp,r8
80008248:	fa c8 fa b8 	sub	r8,sp,-1352
8000824c:	1a d8       	st.w	--sp,r8
8000824e:	fa c8 fb b4 	sub	r8,sp,-1100
80008252:	0c 9b       	mov	r11,r6
80008254:	1a d8       	st.w	--sp,r8
80008256:	04 9a       	mov	r10,r2
80008258:	fa c8 f9 40 	sub	r8,sp,-1728
8000825c:	fa c9 ff b4 	sub	r9,sp,-76
80008260:	08 9c       	mov	r12,r4
80008262:	fe b0 fa 9d 	rcall	8000779c <get_arg>
80008266:	2f dd       	sub	sp,-12
80008268:	78 16       	ld.w	r6,r12[0x4]
8000826a:	50 76       	stdsp	sp[0x1c],r6
8000826c:	c4 88       	rjmp	800082fc <_vfprintf_r+0x830>
8000826e:	2f f7       	sub	r7,-1
80008270:	10 39       	cp.w	r9,r8
80008272:	c0 c4       	brge	8000828a <_vfprintf_r+0x7be>
80008274:	fa ce f9 44 	sub	lr,sp,-1724
80008278:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000827c:	ec fc fd 8c 	ld.w	r12,r6[-628]
80008280:	50 7c       	stdsp	sp[0x1c],r12
80008282:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008286:	50 56       	stdsp	sp[0x14],r6
80008288:	c6 68       	rjmp	80008354 <_vfprintf_r+0x888>
8000828a:	41 09       	lddsp	r9,sp[0x40]
8000828c:	59 f8       	cp.w	r8,31
8000828e:	e0 89 00 10 	brgt	800082ae <_vfprintf_r+0x7e2>
80008292:	f2 ca ff f8 	sub	r10,r9,-8
80008296:	72 1b       	ld.w	r11,r9[0x4]
80008298:	51 0a       	stdsp	sp[0x40],r10
8000829a:	72 09       	ld.w	r9,r9[0x0]
8000829c:	fa ca f9 44 	sub	r10,sp,-1724
800082a0:	50 7b       	stdsp	sp[0x1c],r11
800082a2:	50 59       	stdsp	sp[0x14],r9
800082a4:	f4 08 00 39 	add	r9,r10,r8<<0x3
800082a8:	40 5b       	lddsp	r11,sp[0x14]
800082aa:	40 7a       	lddsp	r10,sp[0x1c]
800082ac:	c4 78       	rjmp	8000833a <_vfprintf_r+0x86e>
800082ae:	72 18       	ld.w	r8,r9[0x4]
800082b0:	50 78       	stdsp	sp[0x1c],r8
800082b2:	c4 c8       	rjmp	8000834a <_vfprintf_r+0x87e>
800082b4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800082b8:	40 3e       	lddsp	lr,sp[0xc]
800082ba:	58 0e       	cp.w	lr,0
800082bc:	c2 30       	breq	80008302 <_vfprintf_r+0x836>
800082be:	10 36       	cp.w	r6,r8
800082c0:	c0 94       	brge	800082d2 <_vfprintf_r+0x806>
800082c2:	fa cc f9 44 	sub	r12,sp,-1724
800082c6:	f8 06 00 36 	add	r6,r12,r6<<0x3
800082ca:	ec fb fd 8c 	ld.w	r11,r6[-628]
800082ce:	50 7b       	stdsp	sp[0x1c],r11
800082d0:	cd 9b       	rjmp	80008282 <_vfprintf_r+0x7b6>
800082d2:	fa c8 f9 50 	sub	r8,sp,-1712
800082d6:	1a d8       	st.w	--sp,r8
800082d8:	fa c8 fa b8 	sub	r8,sp,-1352
800082dc:	04 9a       	mov	r10,r2
800082de:	1a d8       	st.w	--sp,r8
800082e0:	fa c8 fb b4 	sub	r8,sp,-1100
800082e4:	0c 9b       	mov	r11,r6
800082e6:	1a d8       	st.w	--sp,r8
800082e8:	08 9c       	mov	r12,r4
800082ea:	fa c8 f9 40 	sub	r8,sp,-1728
800082ee:	fa c9 ff b4 	sub	r9,sp,-76
800082f2:	fe b0 fa 55 	rcall	8000779c <get_arg>
800082f6:	2f dd       	sub	sp,-12
800082f8:	78 1a       	ld.w	r10,r12[0x4]
800082fa:	50 7a       	stdsp	sp[0x1c],r10
800082fc:	78 0c       	ld.w	r12,r12[0x0]
800082fe:	50 5c       	stdsp	sp[0x14],r12
80008300:	c2 a8       	rjmp	80008354 <_vfprintf_r+0x888>
80008302:	2f f7       	sub	r7,-1
80008304:	10 39       	cp.w	r9,r8
80008306:	c0 94       	brge	80008318 <_vfprintf_r+0x84c>
80008308:	fa c9 f9 44 	sub	r9,sp,-1724
8000830c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008310:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80008314:	50 78       	stdsp	sp[0x1c],r8
80008316:	cb 6b       	rjmp	80008282 <_vfprintf_r+0x7b6>
80008318:	41 09       	lddsp	r9,sp[0x40]
8000831a:	59 f8       	cp.w	r8,31
8000831c:	e0 89 00 15 	brgt	80008346 <_vfprintf_r+0x87a>
80008320:	f2 ca ff f8 	sub	r10,r9,-8
80008324:	72 16       	ld.w	r6,r9[0x4]
80008326:	72 09       	ld.w	r9,r9[0x0]
80008328:	51 0a       	stdsp	sp[0x40],r10
8000832a:	50 59       	stdsp	sp[0x14],r9
8000832c:	fa ce f9 44 	sub	lr,sp,-1724
80008330:	50 76       	stdsp	sp[0x1c],r6
80008332:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008336:	40 5b       	lddsp	r11,sp[0x14]
80008338:	0c 9a       	mov	r10,r6
8000833a:	f2 eb fd 88 	st.d	r9[-632],r10
8000833e:	2f f8       	sub	r8,-1
80008340:	fb 48 06 b4 	st.w	sp[1716],r8
80008344:	c0 88       	rjmp	80008354 <_vfprintf_r+0x888>
80008346:	72 1c       	ld.w	r12,r9[0x4]
80008348:	50 7c       	stdsp	sp[0x1c],r12
8000834a:	f2 c8 ff f8 	sub	r8,r9,-8
8000834e:	51 08       	stdsp	sp[0x40],r8
80008350:	72 09       	ld.w	r9,r9[0x0]
80008352:	50 59       	stdsp	sp[0x14],r9
80008354:	40 5b       	lddsp	r11,sp[0x14]
80008356:	40 7a       	lddsp	r10,sp[0x1c]
80008358:	e0 a0 19 54 	rcall	8000b600 <__isinfd>
8000835c:	18 96       	mov	r6,r12
8000835e:	c1 70       	breq	8000838c <_vfprintf_r+0x8c0>
80008360:	30 08       	mov	r8,0
80008362:	30 09       	mov	r9,0
80008364:	40 5b       	lddsp	r11,sp[0x14]
80008366:	40 7a       	lddsp	r10,sp[0x1c]
80008368:	e0 a0 1d b4 	rcall	8000bed0 <__avr32_f64_cmp_lt>
8000836c:	c0 40       	breq	80008374 <_vfprintf_r+0x8a8>
8000836e:	32 d8       	mov	r8,45
80008370:	fb 68 06 bb 	st.b	sp[1723],r8
80008374:	fe c8 ab 34 	sub	r8,pc,-21708
80008378:	fe c6 ab 34 	sub	r6,pc,-21708
8000837c:	a7 d5       	cbr	r5,0x7
8000837e:	e0 40 00 47 	cp.w	r0,71
80008382:	f0 06 17 a0 	movle	r6,r8
80008386:	30 32       	mov	r2,3
80008388:	e0 8f 06 ce 	bral	80009124 <_vfprintf_r+0x1658>
8000838c:	40 5b       	lddsp	r11,sp[0x14]
8000838e:	40 7a       	lddsp	r10,sp[0x1c]
80008390:	e0 a0 19 4d 	rcall	8000b62a <__isnand>
80008394:	c0 e0       	breq	800083b0 <_vfprintf_r+0x8e4>
80008396:	50 26       	stdsp	sp[0x8],r6
80008398:	fe c8 ab 50 	sub	r8,pc,-21680
8000839c:	fe c6 ab 50 	sub	r6,pc,-21680
800083a0:	a7 d5       	cbr	r5,0x7
800083a2:	e0 40 00 47 	cp.w	r0,71
800083a6:	f0 06 17 a0 	movle	r6,r8
800083aa:	30 32       	mov	r2,3
800083ac:	e0 8f 06 c2 	bral	80009130 <_vfprintf_r+0x1664>
800083b0:	40 2a       	lddsp	r10,sp[0x8]
800083b2:	5b fa       	cp.w	r10,-1
800083b4:	c0 41       	brne	800083bc <_vfprintf_r+0x8f0>
800083b6:	30 69       	mov	r9,6
800083b8:	50 29       	stdsp	sp[0x8],r9
800083ba:	c1 18       	rjmp	800083dc <_vfprintf_r+0x910>
800083bc:	e0 40 00 47 	cp.w	r0,71
800083c0:	5f 09       	sreq	r9
800083c2:	e0 40 00 67 	cp.w	r0,103
800083c6:	5f 08       	sreq	r8
800083c8:	f3 e8 10 08 	or	r8,r9,r8
800083cc:	f8 08 18 00 	cp.b	r8,r12
800083d0:	c0 60       	breq	800083dc <_vfprintf_r+0x910>
800083d2:	40 28       	lddsp	r8,sp[0x8]
800083d4:	58 08       	cp.w	r8,0
800083d6:	f9 b8 00 01 	moveq	r8,1
800083da:	50 28       	stdsp	sp[0x8],r8
800083dc:	40 78       	lddsp	r8,sp[0x1c]
800083de:	40 59       	lddsp	r9,sp[0x14]
800083e0:	fa e9 06 94 	st.d	sp[1684],r8
800083e4:	a9 a5       	sbr	r5,0x8
800083e6:	fa f8 06 94 	ld.w	r8,sp[1684]
800083ea:	58 08       	cp.w	r8,0
800083ec:	c0 65       	brlt	800083f8 <_vfprintf_r+0x92c>
800083ee:	40 5e       	lddsp	lr,sp[0x14]
800083f0:	30 0c       	mov	r12,0
800083f2:	50 6e       	stdsp	sp[0x18],lr
800083f4:	50 9c       	stdsp	sp[0x24],r12
800083f6:	c0 78       	rjmp	80008404 <_vfprintf_r+0x938>
800083f8:	40 5b       	lddsp	r11,sp[0x14]
800083fa:	32 da       	mov	r10,45
800083fc:	ee 1b 80 00 	eorh	r11,0x8000
80008400:	50 9a       	stdsp	sp[0x24],r10
80008402:	50 6b       	stdsp	sp[0x18],r11
80008404:	e0 40 00 46 	cp.w	r0,70
80008408:	5f 09       	sreq	r9
8000840a:	e0 40 00 66 	cp.w	r0,102
8000840e:	5f 08       	sreq	r8
80008410:	f3 e8 10 08 	or	r8,r9,r8
80008414:	50 48       	stdsp	sp[0x10],r8
80008416:	c0 40       	breq	8000841e <_vfprintf_r+0x952>
80008418:	40 22       	lddsp	r2,sp[0x8]
8000841a:	30 39       	mov	r9,3
8000841c:	c1 08       	rjmp	8000843c <_vfprintf_r+0x970>
8000841e:	e0 40 00 45 	cp.w	r0,69
80008422:	5f 09       	sreq	r9
80008424:	e0 40 00 65 	cp.w	r0,101
80008428:	5f 08       	sreq	r8
8000842a:	40 22       	lddsp	r2,sp[0x8]
8000842c:	10 49       	or	r9,r8
8000842e:	2f f2       	sub	r2,-1
80008430:	40 46       	lddsp	r6,sp[0x10]
80008432:	ec 09 18 00 	cp.b	r9,r6
80008436:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000843a:	30 29       	mov	r9,2
8000843c:	fa c8 f9 5c 	sub	r8,sp,-1700
80008440:	1a d8       	st.w	--sp,r8
80008442:	fa c8 f9 54 	sub	r8,sp,-1708
80008446:	1a d8       	st.w	--sp,r8
80008448:	fa c8 f9 4c 	sub	r8,sp,-1716
8000844c:	08 9c       	mov	r12,r4
8000844e:	1a d8       	st.w	--sp,r8
80008450:	04 98       	mov	r8,r2
80008452:	40 9b       	lddsp	r11,sp[0x24]
80008454:	40 aa       	lddsp	r10,sp[0x28]
80008456:	e0 a0 0b c3 	rcall	80009bdc <_dtoa_r>
8000845a:	e0 40 00 47 	cp.w	r0,71
8000845e:	5f 19       	srne	r9
80008460:	e0 40 00 67 	cp.w	r0,103
80008464:	5f 18       	srne	r8
80008466:	18 96       	mov	r6,r12
80008468:	2f dd       	sub	sp,-12
8000846a:	f3 e8 00 08 	and	r8,r9,r8
8000846e:	c0 41       	brne	80008476 <_vfprintf_r+0x9aa>
80008470:	ed b5 00 00 	bld	r5,0x0
80008474:	c3 01       	brne	800084d4 <_vfprintf_r+0xa08>
80008476:	ec 02 00 0e 	add	lr,r6,r2
8000847a:	50 3e       	stdsp	sp[0xc],lr
8000847c:	40 4c       	lddsp	r12,sp[0x10]
8000847e:	58 0c       	cp.w	r12,0
80008480:	c1 50       	breq	800084aa <_vfprintf_r+0x9de>
80008482:	0d 89       	ld.ub	r9,r6[0x0]
80008484:	33 08       	mov	r8,48
80008486:	f0 09 18 00 	cp.b	r9,r8
8000848a:	c0 b1       	brne	800084a0 <_vfprintf_r+0x9d4>
8000848c:	30 08       	mov	r8,0
8000848e:	30 09       	mov	r9,0
80008490:	40 6b       	lddsp	r11,sp[0x18]
80008492:	40 7a       	lddsp	r10,sp[0x1c]
80008494:	e0 a0 1c d7 	rcall	8000be42 <__avr32_f64_cmp_eq>
80008498:	fb b2 00 01 	rsubeq	r2,1
8000849c:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
800084a0:	40 3b       	lddsp	r11,sp[0xc]
800084a2:	fa f8 06 ac 	ld.w	r8,sp[1708]
800084a6:	10 0b       	add	r11,r8
800084a8:	50 3b       	stdsp	sp[0xc],r11
800084aa:	40 6b       	lddsp	r11,sp[0x18]
800084ac:	30 08       	mov	r8,0
800084ae:	30 09       	mov	r9,0
800084b0:	40 7a       	lddsp	r10,sp[0x1c]
800084b2:	e0 a0 1c c8 	rcall	8000be42 <__avr32_f64_cmp_eq>
800084b6:	c0 90       	breq	800084c8 <_vfprintf_r+0x9fc>
800084b8:	40 3a       	lddsp	r10,sp[0xc]
800084ba:	fb 4a 06 a4 	st.w	sp[1700],r10
800084be:	c0 58       	rjmp	800084c8 <_vfprintf_r+0x9fc>
800084c0:	10 c9       	st.b	r8++,r9
800084c2:	fb 48 06 a4 	st.w	sp[1700],r8
800084c6:	c0 28       	rjmp	800084ca <_vfprintf_r+0x9fe>
800084c8:	33 09       	mov	r9,48
800084ca:	fa f8 06 a4 	ld.w	r8,sp[1700]
800084ce:	40 3e       	lddsp	lr,sp[0xc]
800084d0:	1c 38       	cp.w	r8,lr
800084d2:	cf 73       	brcs	800084c0 <_vfprintf_r+0x9f4>
800084d4:	e0 40 00 47 	cp.w	r0,71
800084d8:	5f 09       	sreq	r9
800084da:	e0 40 00 67 	cp.w	r0,103
800084de:	5f 08       	sreq	r8
800084e0:	f3 e8 10 08 	or	r8,r9,r8
800084e4:	fa f9 06 a4 	ld.w	r9,sp[1700]
800084e8:	0c 19       	sub	r9,r6
800084ea:	50 69       	stdsp	sp[0x18],r9
800084ec:	58 08       	cp.w	r8,0
800084ee:	c0 b0       	breq	80008504 <_vfprintf_r+0xa38>
800084f0:	fa f8 06 ac 	ld.w	r8,sp[1708]
800084f4:	5b d8       	cp.w	r8,-3
800084f6:	c0 55       	brlt	80008500 <_vfprintf_r+0xa34>
800084f8:	40 2c       	lddsp	r12,sp[0x8]
800084fa:	18 38       	cp.w	r8,r12
800084fc:	e0 8a 00 6a 	brle	800085d0 <_vfprintf_r+0xb04>
80008500:	20 20       	sub	r0,2
80008502:	c0 58       	rjmp	8000850c <_vfprintf_r+0xa40>
80008504:	e0 40 00 65 	cp.w	r0,101
80008508:	e0 89 00 46 	brgt	80008594 <_vfprintf_r+0xac8>
8000850c:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008510:	fb 60 06 9c 	st.b	sp[1692],r0
80008514:	20 1b       	sub	r11,1
80008516:	fb 4b 06 ac 	st.w	sp[1708],r11
8000851a:	c0 47       	brpl	80008522 <_vfprintf_r+0xa56>
8000851c:	5c 3b       	neg	r11
8000851e:	32 d8       	mov	r8,45
80008520:	c0 28       	rjmp	80008524 <_vfprintf_r+0xa58>
80008522:	32 b8       	mov	r8,43
80008524:	fb 68 06 9d 	st.b	sp[1693],r8
80008528:	58 9b       	cp.w	r11,9
8000852a:	e0 8a 00 1d 	brle	80008564 <_vfprintf_r+0xa98>
8000852e:	fa c9 fa 35 	sub	r9,sp,-1483
80008532:	30 aa       	mov	r10,10
80008534:	12 98       	mov	r8,r9
80008536:	0e 9c       	mov	r12,r7
80008538:	0c 92       	mov	r2,r6
8000853a:	f6 0a 0c 06 	divs	r6,r11,r10
8000853e:	0e 9b       	mov	r11,r7
80008540:	2d 0b       	sub	r11,-48
80008542:	10 fb       	st.b	--r8,r11
80008544:	0c 9b       	mov	r11,r6
80008546:	58 96       	cp.w	r6,9
80008548:	fe 99 ff f9 	brgt	8000853a <_vfprintf_r+0xa6e>
8000854c:	2d 0b       	sub	r11,-48
8000854e:	18 97       	mov	r7,r12
80008550:	04 96       	mov	r6,r2
80008552:	10 fb       	st.b	--r8,r11
80008554:	fa ca f9 62 	sub	r10,sp,-1694
80008558:	c0 38       	rjmp	8000855e <_vfprintf_r+0xa92>
8000855a:	11 3b       	ld.ub	r11,r8++
8000855c:	14 cb       	st.b	r10++,r11
8000855e:	12 38       	cp.w	r8,r9
80008560:	cf d3       	brcs	8000855a <_vfprintf_r+0xa8e>
80008562:	c0 98       	rjmp	80008574 <_vfprintf_r+0xaa8>
80008564:	2d 0b       	sub	r11,-48
80008566:	33 08       	mov	r8,48
80008568:	fb 6b 06 9f 	st.b	sp[1695],r11
8000856c:	fb 68 06 9e 	st.b	sp[1694],r8
80008570:	fa ca f9 60 	sub	r10,sp,-1696
80008574:	fa c8 f9 64 	sub	r8,sp,-1692
80008578:	f4 08 01 08 	sub	r8,r10,r8
8000857c:	50 e8       	stdsp	sp[0x38],r8
8000857e:	10 92       	mov	r2,r8
80008580:	40 6b       	lddsp	r11,sp[0x18]
80008582:	16 02       	add	r2,r11
80008584:	58 1b       	cp.w	r11,1
80008586:	e0 89 00 05 	brgt	80008590 <_vfprintf_r+0xac4>
8000858a:	ed b5 00 00 	bld	r5,0x0
8000858e:	c3 51       	brne	800085f8 <_vfprintf_r+0xb2c>
80008590:	2f f2       	sub	r2,-1
80008592:	c3 38       	rjmp	800085f8 <_vfprintf_r+0xb2c>
80008594:	e0 40 00 66 	cp.w	r0,102
80008598:	c1 c1       	brne	800085d0 <_vfprintf_r+0xb04>
8000859a:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000859e:	58 02       	cp.w	r2,0
800085a0:	e0 8a 00 0c 	brle	800085b8 <_vfprintf_r+0xaec>
800085a4:	40 2a       	lddsp	r10,sp[0x8]
800085a6:	58 0a       	cp.w	r10,0
800085a8:	c0 41       	brne	800085b0 <_vfprintf_r+0xae4>
800085aa:	ed b5 00 00 	bld	r5,0x0
800085ae:	c2 51       	brne	800085f8 <_vfprintf_r+0xb2c>
800085b0:	2f f2       	sub	r2,-1
800085b2:	40 29       	lddsp	r9,sp[0x8]
800085b4:	12 02       	add	r2,r9
800085b6:	c0 b8       	rjmp	800085cc <_vfprintf_r+0xb00>
800085b8:	40 28       	lddsp	r8,sp[0x8]
800085ba:	58 08       	cp.w	r8,0
800085bc:	c0 61       	brne	800085c8 <_vfprintf_r+0xafc>
800085be:	ed b5 00 00 	bld	r5,0x0
800085c2:	c0 30       	breq	800085c8 <_vfprintf_r+0xafc>
800085c4:	30 12       	mov	r2,1
800085c6:	c1 98       	rjmp	800085f8 <_vfprintf_r+0xb2c>
800085c8:	40 22       	lddsp	r2,sp[0x8]
800085ca:	2f e2       	sub	r2,-2
800085cc:	36 60       	mov	r0,102
800085ce:	c1 58       	rjmp	800085f8 <_vfprintf_r+0xb2c>
800085d0:	fa f2 06 ac 	ld.w	r2,sp[1708]
800085d4:	40 6e       	lddsp	lr,sp[0x18]
800085d6:	1c 32       	cp.w	r2,lr
800085d8:	c0 65       	brlt	800085e4 <_vfprintf_r+0xb18>
800085da:	ed b5 00 00 	bld	r5,0x0
800085de:	f7 b2 00 ff 	subeq	r2,-1
800085e2:	c0 a8       	rjmp	800085f6 <_vfprintf_r+0xb2a>
800085e4:	e4 08 11 02 	rsub	r8,r2,2
800085e8:	40 6c       	lddsp	r12,sp[0x18]
800085ea:	58 02       	cp.w	r2,0
800085ec:	f0 02 17 a0 	movle	r2,r8
800085f0:	f9 b2 09 01 	movgt	r2,1
800085f4:	18 02       	add	r2,r12
800085f6:	36 70       	mov	r0,103
800085f8:	40 9b       	lddsp	r11,sp[0x24]
800085fa:	58 0b       	cp.w	r11,0
800085fc:	e0 80 05 94 	breq	80009124 <_vfprintf_r+0x1658>
80008600:	32 d8       	mov	r8,45
80008602:	fb 68 06 bb 	st.b	sp[1723],r8
80008606:	e0 8f 05 93 	bral	8000912c <_vfprintf_r+0x1660>
8000860a:	50 a7       	stdsp	sp[0x28],r7
8000860c:	04 94       	mov	r4,r2
8000860e:	0c 97       	mov	r7,r6
80008610:	02 92       	mov	r2,r1
80008612:	06 96       	mov	r6,r3
80008614:	40 41       	lddsp	r1,sp[0x10]
80008616:	40 93       	lddsp	r3,sp[0x24]
80008618:	0e 99       	mov	r9,r7
8000861a:	ed b5 00 05 	bld	r5,0x5
8000861e:	c4 81       	brne	800086ae <_vfprintf_r+0xbe2>
80008620:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008624:	40 3e       	lddsp	lr,sp[0xc]
80008626:	58 0e       	cp.w	lr,0
80008628:	c1 d0       	breq	80008662 <_vfprintf_r+0xb96>
8000862a:	10 36       	cp.w	r6,r8
8000862c:	c0 64       	brge	80008638 <_vfprintf_r+0xb6c>
8000862e:	fa cc f9 44 	sub	r12,sp,-1724
80008632:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008636:	c1 d8       	rjmp	80008670 <_vfprintf_r+0xba4>
80008638:	fa c8 f9 50 	sub	r8,sp,-1712
8000863c:	1a d8       	st.w	--sp,r8
8000863e:	fa c8 fa b8 	sub	r8,sp,-1352
80008642:	04 9a       	mov	r10,r2
80008644:	1a d8       	st.w	--sp,r8
80008646:	fa c8 fb b4 	sub	r8,sp,-1100
8000864a:	0c 9b       	mov	r11,r6
8000864c:	1a d8       	st.w	--sp,r8
8000864e:	08 9c       	mov	r12,r4
80008650:	fa c8 f9 40 	sub	r8,sp,-1728
80008654:	fa c9 ff b4 	sub	r9,sp,-76
80008658:	fe b0 f8 a2 	rcall	8000779c <get_arg>
8000865c:	2f dd       	sub	sp,-12
8000865e:	78 0a       	ld.w	r10,r12[0x0]
80008660:	c2 08       	rjmp	800086a0 <_vfprintf_r+0xbd4>
80008662:	2f f7       	sub	r7,-1
80008664:	10 39       	cp.w	r9,r8
80008666:	c0 84       	brge	80008676 <_vfprintf_r+0xbaa>
80008668:	fa cb f9 44 	sub	r11,sp,-1724
8000866c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008670:	ec fa fd 88 	ld.w	r10,r6[-632]
80008674:	c1 68       	rjmp	800086a0 <_vfprintf_r+0xbd4>
80008676:	41 09       	lddsp	r9,sp[0x40]
80008678:	59 f8       	cp.w	r8,31
8000867a:	e0 89 00 10 	brgt	8000869a <_vfprintf_r+0xbce>
8000867e:	f2 ca ff fc 	sub	r10,r9,-4
80008682:	51 0a       	stdsp	sp[0x40],r10
80008684:	fa c6 f9 44 	sub	r6,sp,-1724
80008688:	72 0a       	ld.w	r10,r9[0x0]
8000868a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000868e:	f3 4a fd 88 	st.w	r9[-632],r10
80008692:	2f f8       	sub	r8,-1
80008694:	fb 48 06 b4 	st.w	sp[1716],r8
80008698:	c0 48       	rjmp	800086a0 <_vfprintf_r+0xbd4>
8000869a:	72 0a       	ld.w	r10,r9[0x0]
8000869c:	2f c9       	sub	r9,-4
8000869e:	51 09       	stdsp	sp[0x40],r9
800086a0:	40 be       	lddsp	lr,sp[0x2c]
800086a2:	1c 98       	mov	r8,lr
800086a4:	95 1e       	st.w	r10[0x4],lr
800086a6:	bf 58       	asr	r8,0x1f
800086a8:	95 08       	st.w	r10[0x0],r8
800086aa:	fe 9f fa 9f 	bral	80007be8 <_vfprintf_r+0x11c>
800086ae:	ed b5 00 04 	bld	r5,0x4
800086b2:	c4 80       	breq	80008742 <_vfprintf_r+0xc76>
800086b4:	e2 15 00 40 	andl	r5,0x40,COH
800086b8:	c4 50       	breq	80008742 <_vfprintf_r+0xc76>
800086ba:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086be:	40 3c       	lddsp	r12,sp[0xc]
800086c0:	58 0c       	cp.w	r12,0
800086c2:	c1 d0       	breq	800086fc <_vfprintf_r+0xc30>
800086c4:	10 36       	cp.w	r6,r8
800086c6:	c0 64       	brge	800086d2 <_vfprintf_r+0xc06>
800086c8:	fa cb f9 44 	sub	r11,sp,-1724
800086cc:	f6 06 00 36 	add	r6,r11,r6<<0x3
800086d0:	c1 d8       	rjmp	8000870a <_vfprintf_r+0xc3e>
800086d2:	fa c8 f9 50 	sub	r8,sp,-1712
800086d6:	1a d8       	st.w	--sp,r8
800086d8:	fa c8 fa b8 	sub	r8,sp,-1352
800086dc:	04 9a       	mov	r10,r2
800086de:	1a d8       	st.w	--sp,r8
800086e0:	fa c8 fb b4 	sub	r8,sp,-1100
800086e4:	0c 9b       	mov	r11,r6
800086e6:	1a d8       	st.w	--sp,r8
800086e8:	08 9c       	mov	r12,r4
800086ea:	fa c8 f9 40 	sub	r8,sp,-1728
800086ee:	fa c9 ff b4 	sub	r9,sp,-76
800086f2:	fe b0 f8 55 	rcall	8000779c <get_arg>
800086f6:	2f dd       	sub	sp,-12
800086f8:	78 0a       	ld.w	r10,r12[0x0]
800086fa:	c2 08       	rjmp	8000873a <_vfprintf_r+0xc6e>
800086fc:	2f f7       	sub	r7,-1
800086fe:	10 39       	cp.w	r9,r8
80008700:	c0 84       	brge	80008710 <_vfprintf_r+0xc44>
80008702:	fa ca f9 44 	sub	r10,sp,-1724
80008706:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000870a:	ec fa fd 88 	ld.w	r10,r6[-632]
8000870e:	c1 68       	rjmp	8000873a <_vfprintf_r+0xc6e>
80008710:	41 09       	lddsp	r9,sp[0x40]
80008712:	59 f8       	cp.w	r8,31
80008714:	e0 89 00 10 	brgt	80008734 <_vfprintf_r+0xc68>
80008718:	f2 ca ff fc 	sub	r10,r9,-4
8000871c:	51 0a       	stdsp	sp[0x40],r10
8000871e:	fa c6 f9 44 	sub	r6,sp,-1724
80008722:	72 0a       	ld.w	r10,r9[0x0]
80008724:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008728:	f3 4a fd 88 	st.w	r9[-632],r10
8000872c:	2f f8       	sub	r8,-1
8000872e:	fb 48 06 b4 	st.w	sp[1716],r8
80008732:	c0 48       	rjmp	8000873a <_vfprintf_r+0xc6e>
80008734:	72 0a       	ld.w	r10,r9[0x0]
80008736:	2f c9       	sub	r9,-4
80008738:	51 09       	stdsp	sp[0x40],r9
8000873a:	40 be       	lddsp	lr,sp[0x2c]
8000873c:	b4 0e       	st.h	r10[0x0],lr
8000873e:	fe 9f fa 55 	bral	80007be8 <_vfprintf_r+0x11c>
80008742:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008746:	40 3c       	lddsp	r12,sp[0xc]
80008748:	58 0c       	cp.w	r12,0
8000874a:	c1 d0       	breq	80008784 <_vfprintf_r+0xcb8>
8000874c:	10 36       	cp.w	r6,r8
8000874e:	c0 64       	brge	8000875a <_vfprintf_r+0xc8e>
80008750:	fa cb f9 44 	sub	r11,sp,-1724
80008754:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008758:	c1 d8       	rjmp	80008792 <_vfprintf_r+0xcc6>
8000875a:	fa c8 f9 50 	sub	r8,sp,-1712
8000875e:	1a d8       	st.w	--sp,r8
80008760:	fa c8 fa b8 	sub	r8,sp,-1352
80008764:	04 9a       	mov	r10,r2
80008766:	1a d8       	st.w	--sp,r8
80008768:	fa c8 fb b4 	sub	r8,sp,-1100
8000876c:	0c 9b       	mov	r11,r6
8000876e:	1a d8       	st.w	--sp,r8
80008770:	08 9c       	mov	r12,r4
80008772:	fa c8 f9 40 	sub	r8,sp,-1728
80008776:	fa c9 ff b4 	sub	r9,sp,-76
8000877a:	fe b0 f8 11 	rcall	8000779c <get_arg>
8000877e:	2f dd       	sub	sp,-12
80008780:	78 0a       	ld.w	r10,r12[0x0]
80008782:	c2 08       	rjmp	800087c2 <_vfprintf_r+0xcf6>
80008784:	2f f7       	sub	r7,-1
80008786:	10 39       	cp.w	r9,r8
80008788:	c0 84       	brge	80008798 <_vfprintf_r+0xccc>
8000878a:	fa ca f9 44 	sub	r10,sp,-1724
8000878e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008792:	ec fa fd 88 	ld.w	r10,r6[-632]
80008796:	c1 68       	rjmp	800087c2 <_vfprintf_r+0xcf6>
80008798:	41 09       	lddsp	r9,sp[0x40]
8000879a:	59 f8       	cp.w	r8,31
8000879c:	e0 89 00 10 	brgt	800087bc <_vfprintf_r+0xcf0>
800087a0:	f2 ca ff fc 	sub	r10,r9,-4
800087a4:	51 0a       	stdsp	sp[0x40],r10
800087a6:	fa c6 f9 44 	sub	r6,sp,-1724
800087aa:	72 0a       	ld.w	r10,r9[0x0]
800087ac:	ec 08 00 39 	add	r9,r6,r8<<0x3
800087b0:	f3 4a fd 88 	st.w	r9[-632],r10
800087b4:	2f f8       	sub	r8,-1
800087b6:	fb 48 06 b4 	st.w	sp[1716],r8
800087ba:	c0 48       	rjmp	800087c2 <_vfprintf_r+0xcf6>
800087bc:	72 0a       	ld.w	r10,r9[0x0]
800087be:	2f c9       	sub	r9,-4
800087c0:	51 09       	stdsp	sp[0x40],r9
800087c2:	40 be       	lddsp	lr,sp[0x2c]
800087c4:	95 0e       	st.w	r10[0x0],lr
800087c6:	fe 9f fa 11 	bral	80007be8 <_vfprintf_r+0x11c>
800087ca:	50 a7       	stdsp	sp[0x28],r7
800087cc:	50 80       	stdsp	sp[0x20],r0
800087ce:	0c 97       	mov	r7,r6
800087d0:	04 94       	mov	r4,r2
800087d2:	06 96       	mov	r6,r3
800087d4:	02 92       	mov	r2,r1
800087d6:	40 93       	lddsp	r3,sp[0x24]
800087d8:	10 90       	mov	r0,r8
800087da:	40 41       	lddsp	r1,sp[0x10]
800087dc:	a5 a5       	sbr	r5,0x4
800087de:	c0 a8       	rjmp	800087f2 <_vfprintf_r+0xd26>
800087e0:	50 a7       	stdsp	sp[0x28],r7
800087e2:	50 80       	stdsp	sp[0x20],r0
800087e4:	0c 97       	mov	r7,r6
800087e6:	04 94       	mov	r4,r2
800087e8:	06 96       	mov	r6,r3
800087ea:	02 92       	mov	r2,r1
800087ec:	40 93       	lddsp	r3,sp[0x24]
800087ee:	10 90       	mov	r0,r8
800087f0:	40 41       	lddsp	r1,sp[0x10]
800087f2:	ed b5 00 05 	bld	r5,0x5
800087f6:	c5 d1       	brne	800088b0 <_vfprintf_r+0xde4>
800087f8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800087fc:	40 3c       	lddsp	r12,sp[0xc]
800087fe:	58 0c       	cp.w	r12,0
80008800:	c2 60       	breq	8000884c <_vfprintf_r+0xd80>
80008802:	10 36       	cp.w	r6,r8
80008804:	c0 a4       	brge	80008818 <_vfprintf_r+0xd4c>
80008806:	fa cb f9 44 	sub	r11,sp,-1724
8000880a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000880e:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008812:	fa e9 00 00 	st.d	sp[0],r8
80008816:	c1 88       	rjmp	80008846 <_vfprintf_r+0xd7a>
80008818:	fa c8 f9 50 	sub	r8,sp,-1712
8000881c:	1a d8       	st.w	--sp,r8
8000881e:	fa c8 fa b8 	sub	r8,sp,-1352
80008822:	04 9a       	mov	r10,r2
80008824:	1a d8       	st.w	--sp,r8
80008826:	0c 9b       	mov	r11,r6
80008828:	fa c8 fb b4 	sub	r8,sp,-1100
8000882c:	08 9c       	mov	r12,r4
8000882e:	1a d8       	st.w	--sp,r8
80008830:	fa c8 f9 40 	sub	r8,sp,-1728
80008834:	fa c9 ff b4 	sub	r9,sp,-76
80008838:	fe b0 f7 b2 	rcall	8000779c <get_arg>
8000883c:	2f dd       	sub	sp,-12
8000883e:	f8 ea 00 00 	ld.d	r10,r12[0]
80008842:	fa eb 00 00 	st.d	sp[0],r10
80008846:	30 08       	mov	r8,0
80008848:	e0 8f 03 de 	bral	80009004 <_vfprintf_r+0x1538>
8000884c:	ee ca ff ff 	sub	r10,r7,-1
80008850:	10 37       	cp.w	r7,r8
80008852:	c0 b4       	brge	80008868 <_vfprintf_r+0xd9c>
80008854:	fa c9 f9 44 	sub	r9,sp,-1724
80008858:	14 97       	mov	r7,r10
8000885a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000885e:	ec ea fd 88 	ld.d	r10,r6[-632]
80008862:	fa eb 00 00 	st.d	sp[0],r10
80008866:	c1 88       	rjmp	80008896 <_vfprintf_r+0xdca>
80008868:	41 09       	lddsp	r9,sp[0x40]
8000886a:	59 f8       	cp.w	r8,31
8000886c:	e0 89 00 18 	brgt	8000889c <_vfprintf_r+0xdd0>
80008870:	f2 e6 00 00 	ld.d	r6,r9[0]
80008874:	f2 cb ff f8 	sub	r11,r9,-8
80008878:	fa e7 00 00 	st.d	sp[0],r6
8000887c:	51 0b       	stdsp	sp[0x40],r11
8000887e:	fa c6 f9 44 	sub	r6,sp,-1724
80008882:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008886:	fa e6 00 00 	ld.d	r6,sp[0]
8000888a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000888e:	2f f8       	sub	r8,-1
80008890:	14 97       	mov	r7,r10
80008892:	fb 48 06 b4 	st.w	sp[1716],r8
80008896:	40 38       	lddsp	r8,sp[0xc]
80008898:	e0 8f 03 b6 	bral	80009004 <_vfprintf_r+0x1538>
8000889c:	f2 e6 00 00 	ld.d	r6,r9[0]
800088a0:	40 38       	lddsp	r8,sp[0xc]
800088a2:	fa e7 00 00 	st.d	sp[0],r6
800088a6:	2f 89       	sub	r9,-8
800088a8:	14 97       	mov	r7,r10
800088aa:	51 09       	stdsp	sp[0x40],r9
800088ac:	e0 8f 03 ac 	bral	80009004 <_vfprintf_r+0x1538>
800088b0:	ed b5 00 04 	bld	r5,0x4
800088b4:	c1 61       	brne	800088e0 <_vfprintf_r+0xe14>
800088b6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800088ba:	40 3e       	lddsp	lr,sp[0xc]
800088bc:	58 0e       	cp.w	lr,0
800088be:	c0 80       	breq	800088ce <_vfprintf_r+0xe02>
800088c0:	10 36       	cp.w	r6,r8
800088c2:	c6 74       	brge	80008990 <_vfprintf_r+0xec4>
800088c4:	fa cc f9 44 	sub	r12,sp,-1724
800088c8:	f8 06 00 36 	add	r6,r12,r6<<0x3
800088cc:	c8 08       	rjmp	800089cc <_vfprintf_r+0xf00>
800088ce:	ee ca ff ff 	sub	r10,r7,-1
800088d2:	10 37       	cp.w	r7,r8
800088d4:	c7 f4       	brge	800089d2 <_vfprintf_r+0xf06>
800088d6:	fa cb f9 44 	sub	r11,sp,-1724
800088da:	f6 06 00 36 	add	r6,r11,r6<<0x3
800088de:	c7 68       	rjmp	800089ca <_vfprintf_r+0xefe>
800088e0:	ed b5 00 06 	bld	r5,0x6
800088e4:	c4 a1       	brne	80008978 <_vfprintf_r+0xeac>
800088e6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800088ea:	40 3c       	lddsp	r12,sp[0xc]
800088ec:	58 0c       	cp.w	r12,0
800088ee:	c1 d0       	breq	80008928 <_vfprintf_r+0xe5c>
800088f0:	10 36       	cp.w	r6,r8
800088f2:	c0 64       	brge	800088fe <_vfprintf_r+0xe32>
800088f4:	fa cb f9 44 	sub	r11,sp,-1724
800088f8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800088fc:	c1 f8       	rjmp	8000893a <_vfprintf_r+0xe6e>
800088fe:	fa c8 f9 50 	sub	r8,sp,-1712
80008902:	1a d8       	st.w	--sp,r8
80008904:	fa c8 fa b8 	sub	r8,sp,-1352
80008908:	1a d8       	st.w	--sp,r8
8000890a:	fa c8 fb b4 	sub	r8,sp,-1100
8000890e:	1a d8       	st.w	--sp,r8
80008910:	fa c8 f9 40 	sub	r8,sp,-1728
80008914:	fa c9 ff b4 	sub	r9,sp,-76
80008918:	04 9a       	mov	r10,r2
8000891a:	0c 9b       	mov	r11,r6
8000891c:	08 9c       	mov	r12,r4
8000891e:	fe b0 f7 3f 	rcall	8000779c <get_arg>
80008922:	2f dd       	sub	sp,-12
80008924:	98 18       	ld.sh	r8,r12[0x2]
80008926:	c2 68       	rjmp	80008972 <_vfprintf_r+0xea6>
80008928:	ee ca ff ff 	sub	r10,r7,-1
8000892c:	10 37       	cp.w	r7,r8
8000892e:	c0 94       	brge	80008940 <_vfprintf_r+0xe74>
80008930:	fa c9 f9 44 	sub	r9,sp,-1724
80008934:	14 97       	mov	r7,r10
80008936:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000893a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000893e:	c1 a8       	rjmp	80008972 <_vfprintf_r+0xea6>
80008940:	41 09       	lddsp	r9,sp[0x40]
80008942:	59 f8       	cp.w	r8,31
80008944:	e0 89 00 13 	brgt	8000896a <_vfprintf_r+0xe9e>
80008948:	f2 cb ff fc 	sub	r11,r9,-4
8000894c:	51 0b       	stdsp	sp[0x40],r11
8000894e:	72 09       	ld.w	r9,r9[0x0]
80008950:	fa c6 f9 44 	sub	r6,sp,-1724
80008954:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008958:	2f f8       	sub	r8,-1
8000895a:	f7 49 fd 88 	st.w	r11[-632],r9
8000895e:	fb 48 06 b4 	st.w	sp[1716],r8
80008962:	14 97       	mov	r7,r10
80008964:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008968:	c0 58       	rjmp	80008972 <_vfprintf_r+0xea6>
8000896a:	92 18       	ld.sh	r8,r9[0x2]
8000896c:	14 97       	mov	r7,r10
8000896e:	2f c9       	sub	r9,-4
80008970:	51 09       	stdsp	sp[0x40],r9
80008972:	5c 78       	castu.h	r8
80008974:	50 18       	stdsp	sp[0x4],r8
80008976:	c4 68       	rjmp	80008a02 <_vfprintf_r+0xf36>
80008978:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000897c:	40 3c       	lddsp	r12,sp[0xc]
8000897e:	58 0c       	cp.w	r12,0
80008980:	c1 d0       	breq	800089ba <_vfprintf_r+0xeee>
80008982:	10 36       	cp.w	r6,r8
80008984:	c0 64       	brge	80008990 <_vfprintf_r+0xec4>
80008986:	fa cb f9 44 	sub	r11,sp,-1724
8000898a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000898e:	c1 f8       	rjmp	800089cc <_vfprintf_r+0xf00>
80008990:	fa c8 f9 50 	sub	r8,sp,-1712
80008994:	1a d8       	st.w	--sp,r8
80008996:	fa c8 fa b8 	sub	r8,sp,-1352
8000899a:	0c 9b       	mov	r11,r6
8000899c:	1a d8       	st.w	--sp,r8
8000899e:	fa c8 fb b4 	sub	r8,sp,-1100
800089a2:	04 9a       	mov	r10,r2
800089a4:	1a d8       	st.w	--sp,r8
800089a6:	08 9c       	mov	r12,r4
800089a8:	fa c8 f9 40 	sub	r8,sp,-1728
800089ac:	fa c9 ff b4 	sub	r9,sp,-76
800089b0:	fe b0 f6 f6 	rcall	8000779c <get_arg>
800089b4:	2f dd       	sub	sp,-12
800089b6:	78 0b       	ld.w	r11,r12[0x0]
800089b8:	c2 48       	rjmp	80008a00 <_vfprintf_r+0xf34>
800089ba:	ee ca ff ff 	sub	r10,r7,-1
800089be:	10 37       	cp.w	r7,r8
800089c0:	c0 94       	brge	800089d2 <_vfprintf_r+0xf06>
800089c2:	fa c9 f9 44 	sub	r9,sp,-1724
800089c6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800089ca:	14 97       	mov	r7,r10
800089cc:	ec fb fd 88 	ld.w	r11,r6[-632]
800089d0:	c1 88       	rjmp	80008a00 <_vfprintf_r+0xf34>
800089d2:	41 09       	lddsp	r9,sp[0x40]
800089d4:	59 f8       	cp.w	r8,31
800089d6:	e0 89 00 11 	brgt	800089f8 <_vfprintf_r+0xf2c>
800089da:	f2 cb ff fc 	sub	r11,r9,-4
800089de:	51 0b       	stdsp	sp[0x40],r11
800089e0:	fa c6 f9 44 	sub	r6,sp,-1724
800089e4:	72 0b       	ld.w	r11,r9[0x0]
800089e6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800089ea:	f3 4b fd 88 	st.w	r9[-632],r11
800089ee:	2f f8       	sub	r8,-1
800089f0:	14 97       	mov	r7,r10
800089f2:	fb 48 06 b4 	st.w	sp[1716],r8
800089f6:	c0 58       	rjmp	80008a00 <_vfprintf_r+0xf34>
800089f8:	72 0b       	ld.w	r11,r9[0x0]
800089fa:	14 97       	mov	r7,r10
800089fc:	2f c9       	sub	r9,-4
800089fe:	51 09       	stdsp	sp[0x40],r9
80008a00:	50 1b       	stdsp	sp[0x4],r11
80008a02:	30 0e       	mov	lr,0
80008a04:	50 0e       	stdsp	sp[0x0],lr
80008a06:	1c 98       	mov	r8,lr
80008a08:	e0 8f 02 fe 	bral	80009004 <_vfprintf_r+0x1538>
80008a0c:	50 a7       	stdsp	sp[0x28],r7
80008a0e:	50 80       	stdsp	sp[0x20],r0
80008a10:	0c 97       	mov	r7,r6
80008a12:	04 94       	mov	r4,r2
80008a14:	06 96       	mov	r6,r3
80008a16:	02 92       	mov	r2,r1
80008a18:	40 93       	lddsp	r3,sp[0x24]
80008a1a:	40 41       	lddsp	r1,sp[0x10]
80008a1c:	0e 99       	mov	r9,r7
80008a1e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a22:	40 3c       	lddsp	r12,sp[0xc]
80008a24:	58 0c       	cp.w	r12,0
80008a26:	c1 d0       	breq	80008a60 <_vfprintf_r+0xf94>
80008a28:	10 36       	cp.w	r6,r8
80008a2a:	c0 64       	brge	80008a36 <_vfprintf_r+0xf6a>
80008a2c:	fa cb f9 44 	sub	r11,sp,-1724
80008a30:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a34:	c1 d8       	rjmp	80008a6e <_vfprintf_r+0xfa2>
80008a36:	fa c8 f9 50 	sub	r8,sp,-1712
80008a3a:	1a d8       	st.w	--sp,r8
80008a3c:	fa c8 fa b8 	sub	r8,sp,-1352
80008a40:	1a d8       	st.w	--sp,r8
80008a42:	fa c8 fb b4 	sub	r8,sp,-1100
80008a46:	1a d8       	st.w	--sp,r8
80008a48:	fa c9 ff b4 	sub	r9,sp,-76
80008a4c:	fa c8 f9 40 	sub	r8,sp,-1728
80008a50:	04 9a       	mov	r10,r2
80008a52:	0c 9b       	mov	r11,r6
80008a54:	08 9c       	mov	r12,r4
80008a56:	fe b0 f6 a3 	rcall	8000779c <get_arg>
80008a5a:	2f dd       	sub	sp,-12
80008a5c:	78 09       	ld.w	r9,r12[0x0]
80008a5e:	c2 18       	rjmp	80008aa0 <_vfprintf_r+0xfd4>
80008a60:	2f f7       	sub	r7,-1
80008a62:	10 39       	cp.w	r9,r8
80008a64:	c0 84       	brge	80008a74 <_vfprintf_r+0xfa8>
80008a66:	fa ca f9 44 	sub	r10,sp,-1724
80008a6a:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008a6e:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008a72:	c1 78       	rjmp	80008aa0 <_vfprintf_r+0xfd4>
80008a74:	41 09       	lddsp	r9,sp[0x40]
80008a76:	59 f8       	cp.w	r8,31
80008a78:	e0 89 00 10 	brgt	80008a98 <_vfprintf_r+0xfcc>
80008a7c:	f2 ca ff fc 	sub	r10,r9,-4
80008a80:	51 0a       	stdsp	sp[0x40],r10
80008a82:	fa c6 f9 44 	sub	r6,sp,-1724
80008a86:	72 09       	ld.w	r9,r9[0x0]
80008a88:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008a8c:	f5 49 fd 88 	st.w	r10[-632],r9
80008a90:	2f f8       	sub	r8,-1
80008a92:	fb 48 06 b4 	st.w	sp[1716],r8
80008a96:	c0 58       	rjmp	80008aa0 <_vfprintf_r+0xfd4>
80008a98:	f2 c8 ff fc 	sub	r8,r9,-4
80008a9c:	51 08       	stdsp	sp[0x40],r8
80008a9e:	72 09       	ld.w	r9,r9[0x0]
80008aa0:	33 08       	mov	r8,48
80008aa2:	fb 68 06 b8 	st.b	sp[1720],r8
80008aa6:	37 88       	mov	r8,120
80008aa8:	30 0e       	mov	lr,0
80008aaa:	fb 68 06 b9 	st.b	sp[1721],r8
80008aae:	fe cc b2 5e 	sub	r12,pc,-19874
80008ab2:	50 19       	stdsp	sp[0x4],r9
80008ab4:	a1 b5       	sbr	r5,0x1
80008ab6:	50 0e       	stdsp	sp[0x0],lr
80008ab8:	50 dc       	stdsp	sp[0x34],r12
80008aba:	30 28       	mov	r8,2
80008abc:	37 80       	mov	r0,120
80008abe:	e0 8f 02 a3 	bral	80009004 <_vfprintf_r+0x1538>
80008ac2:	50 a7       	stdsp	sp[0x28],r7
80008ac4:	50 80       	stdsp	sp[0x20],r0
80008ac6:	10 90       	mov	r0,r8
80008ac8:	30 08       	mov	r8,0
80008aca:	fb 68 06 bb 	st.b	sp[1723],r8
80008ace:	0c 97       	mov	r7,r6
80008ad0:	04 94       	mov	r4,r2
80008ad2:	06 96       	mov	r6,r3
80008ad4:	02 92       	mov	r2,r1
80008ad6:	40 93       	lddsp	r3,sp[0x24]
80008ad8:	40 41       	lddsp	r1,sp[0x10]
80008ada:	0e 99       	mov	r9,r7
80008adc:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ae0:	40 3b       	lddsp	r11,sp[0xc]
80008ae2:	58 0b       	cp.w	r11,0
80008ae4:	c1 d0       	breq	80008b1e <_vfprintf_r+0x1052>
80008ae6:	10 36       	cp.w	r6,r8
80008ae8:	c0 64       	brge	80008af4 <_vfprintf_r+0x1028>
80008aea:	fa ca f9 44 	sub	r10,sp,-1724
80008aee:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008af2:	c1 d8       	rjmp	80008b2c <_vfprintf_r+0x1060>
80008af4:	fa c8 f9 50 	sub	r8,sp,-1712
80008af8:	1a d8       	st.w	--sp,r8
80008afa:	fa c8 fa b8 	sub	r8,sp,-1352
80008afe:	1a d8       	st.w	--sp,r8
80008b00:	fa c8 fb b4 	sub	r8,sp,-1100
80008b04:	0c 9b       	mov	r11,r6
80008b06:	1a d8       	st.w	--sp,r8
80008b08:	04 9a       	mov	r10,r2
80008b0a:	fa c8 f9 40 	sub	r8,sp,-1728
80008b0e:	fa c9 ff b4 	sub	r9,sp,-76
80008b12:	08 9c       	mov	r12,r4
80008b14:	fe b0 f6 44 	rcall	8000779c <get_arg>
80008b18:	2f dd       	sub	sp,-12
80008b1a:	78 06       	ld.w	r6,r12[0x0]
80008b1c:	c2 08       	rjmp	80008b5c <_vfprintf_r+0x1090>
80008b1e:	2f f7       	sub	r7,-1
80008b20:	10 39       	cp.w	r9,r8
80008b22:	c0 84       	brge	80008b32 <_vfprintf_r+0x1066>
80008b24:	fa c9 f9 44 	sub	r9,sp,-1724
80008b28:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008b2c:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008b30:	c1 68       	rjmp	80008b5c <_vfprintf_r+0x1090>
80008b32:	41 09       	lddsp	r9,sp[0x40]
80008b34:	59 f8       	cp.w	r8,31
80008b36:	e0 89 00 10 	brgt	80008b56 <_vfprintf_r+0x108a>
80008b3a:	f2 ca ff fc 	sub	r10,r9,-4
80008b3e:	51 0a       	stdsp	sp[0x40],r10
80008b40:	72 06       	ld.w	r6,r9[0x0]
80008b42:	fa ce f9 44 	sub	lr,sp,-1724
80008b46:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008b4a:	f3 46 fd 88 	st.w	r9[-632],r6
80008b4e:	2f f8       	sub	r8,-1
80008b50:	fb 48 06 b4 	st.w	sp[1716],r8
80008b54:	c0 48       	rjmp	80008b5c <_vfprintf_r+0x1090>
80008b56:	72 06       	ld.w	r6,r9[0x0]
80008b58:	2f c9       	sub	r9,-4
80008b5a:	51 09       	stdsp	sp[0x40],r9
80008b5c:	40 2c       	lddsp	r12,sp[0x8]
80008b5e:	58 0c       	cp.w	r12,0
80008b60:	c1 05       	brlt	80008b80 <_vfprintf_r+0x10b4>
80008b62:	18 9a       	mov	r10,r12
80008b64:	30 0b       	mov	r11,0
80008b66:	0c 9c       	mov	r12,r6
80008b68:	e0 a0 12 38 	rcall	8000afd8 <memchr>
80008b6c:	e0 80 02 df 	breq	8000912a <_vfprintf_r+0x165e>
80008b70:	f8 06 01 02 	sub	r2,r12,r6
80008b74:	40 2b       	lddsp	r11,sp[0x8]
80008b76:	16 32       	cp.w	r2,r11
80008b78:	e0 89 02 d9 	brgt	8000912a <_vfprintf_r+0x165e>
80008b7c:	e0 8f 02 d4 	bral	80009124 <_vfprintf_r+0x1658>
80008b80:	30 0a       	mov	r10,0
80008b82:	0c 9c       	mov	r12,r6
80008b84:	50 2a       	stdsp	sp[0x8],r10
80008b86:	e0 a0 15 99 	rcall	8000b6b8 <strlen>
80008b8a:	18 92       	mov	r2,r12
80008b8c:	e0 8f 02 d2 	bral	80009130 <_vfprintf_r+0x1664>
80008b90:	50 a7       	stdsp	sp[0x28],r7
80008b92:	50 80       	stdsp	sp[0x20],r0
80008b94:	0c 97       	mov	r7,r6
80008b96:	04 94       	mov	r4,r2
80008b98:	06 96       	mov	r6,r3
80008b9a:	02 92       	mov	r2,r1
80008b9c:	40 93       	lddsp	r3,sp[0x24]
80008b9e:	10 90       	mov	r0,r8
80008ba0:	40 41       	lddsp	r1,sp[0x10]
80008ba2:	a5 a5       	sbr	r5,0x4
80008ba4:	c0 a8       	rjmp	80008bb8 <_vfprintf_r+0x10ec>
80008ba6:	50 a7       	stdsp	sp[0x28],r7
80008ba8:	50 80       	stdsp	sp[0x20],r0
80008baa:	0c 97       	mov	r7,r6
80008bac:	04 94       	mov	r4,r2
80008bae:	06 96       	mov	r6,r3
80008bb0:	02 92       	mov	r2,r1
80008bb2:	40 93       	lddsp	r3,sp[0x24]
80008bb4:	10 90       	mov	r0,r8
80008bb6:	40 41       	lddsp	r1,sp[0x10]
80008bb8:	ed b5 00 05 	bld	r5,0x5
80008bbc:	c5 61       	brne	80008c68 <_vfprintf_r+0x119c>
80008bbe:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008bc2:	40 39       	lddsp	r9,sp[0xc]
80008bc4:	58 09       	cp.w	r9,0
80008bc6:	c2 10       	breq	80008c08 <_vfprintf_r+0x113c>
80008bc8:	10 36       	cp.w	r6,r8
80008bca:	c0 74       	brge	80008bd8 <_vfprintf_r+0x110c>
80008bcc:	fa c8 f9 44 	sub	r8,sp,-1724
80008bd0:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008bd4:	c2 38       	rjmp	80008c1a <_vfprintf_r+0x114e>
80008bd6:	d7 03       	nop
80008bd8:	fa c8 f9 50 	sub	r8,sp,-1712
80008bdc:	1a d8       	st.w	--sp,r8
80008bde:	fa c8 fa b8 	sub	r8,sp,-1352
80008be2:	1a d8       	st.w	--sp,r8
80008be4:	fa c8 fb b4 	sub	r8,sp,-1100
80008be8:	1a d8       	st.w	--sp,r8
80008bea:	fa c8 f9 40 	sub	r8,sp,-1728
80008bee:	fa c9 ff b4 	sub	r9,sp,-76
80008bf2:	04 9a       	mov	r10,r2
80008bf4:	0c 9b       	mov	r11,r6
80008bf6:	08 9c       	mov	r12,r4
80008bf8:	fe b0 f5 d2 	rcall	8000779c <get_arg>
80008bfc:	2f dd       	sub	sp,-12
80008bfe:	f8 e8 00 00 	ld.d	r8,r12[0]
80008c02:	fa e9 00 00 	st.d	sp[0],r8
80008c06:	c2 e8       	rjmp	80008c62 <_vfprintf_r+0x1196>
80008c08:	ee ca ff ff 	sub	r10,r7,-1
80008c0c:	10 37       	cp.w	r7,r8
80008c0e:	c0 b4       	brge	80008c24 <_vfprintf_r+0x1158>
80008c10:	fa c8 f9 44 	sub	r8,sp,-1724
80008c14:	14 97       	mov	r7,r10
80008c16:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008c1a:	ec ea fd 88 	ld.d	r10,r6[-632]
80008c1e:	fa eb 00 00 	st.d	sp[0],r10
80008c22:	c2 08       	rjmp	80008c62 <_vfprintf_r+0x1196>
80008c24:	41 09       	lddsp	r9,sp[0x40]
80008c26:	59 f8       	cp.w	r8,31
80008c28:	e0 89 00 16 	brgt	80008c54 <_vfprintf_r+0x1188>
80008c2c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008c30:	f2 cb ff f8 	sub	r11,r9,-8
80008c34:	fa e7 00 00 	st.d	sp[0],r6
80008c38:	51 0b       	stdsp	sp[0x40],r11
80008c3a:	fa c6 f9 44 	sub	r6,sp,-1724
80008c3e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008c42:	fa e6 00 00 	ld.d	r6,sp[0]
80008c46:	f2 e7 fd 88 	st.d	r9[-632],r6
80008c4a:	2f f8       	sub	r8,-1
80008c4c:	14 97       	mov	r7,r10
80008c4e:	fb 48 06 b4 	st.w	sp[1716],r8
80008c52:	c0 88       	rjmp	80008c62 <_vfprintf_r+0x1196>
80008c54:	f2 e6 00 00 	ld.d	r6,r9[0]
80008c58:	2f 89       	sub	r9,-8
80008c5a:	fa e7 00 00 	st.d	sp[0],r6
80008c5e:	51 09       	stdsp	sp[0x40],r9
80008c60:	14 97       	mov	r7,r10
80008c62:	30 18       	mov	r8,1
80008c64:	e0 8f 01 d0 	bral	80009004 <_vfprintf_r+0x1538>
80008c68:	ed b5 00 04 	bld	r5,0x4
80008c6c:	c1 61       	brne	80008c98 <_vfprintf_r+0x11cc>
80008c6e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c72:	40 3e       	lddsp	lr,sp[0xc]
80008c74:	58 0e       	cp.w	lr,0
80008c76:	c0 80       	breq	80008c86 <_vfprintf_r+0x11ba>
80008c78:	10 36       	cp.w	r6,r8
80008c7a:	c6 74       	brge	80008d48 <_vfprintf_r+0x127c>
80008c7c:	fa cc f9 44 	sub	r12,sp,-1724
80008c80:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008c84:	c8 08       	rjmp	80008d84 <_vfprintf_r+0x12b8>
80008c86:	ee ca ff ff 	sub	r10,r7,-1
80008c8a:	10 37       	cp.w	r7,r8
80008c8c:	c7 f4       	brge	80008d8a <_vfprintf_r+0x12be>
80008c8e:	fa cb f9 44 	sub	r11,sp,-1724
80008c92:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c96:	c7 68       	rjmp	80008d82 <_vfprintf_r+0x12b6>
80008c98:	ed b5 00 06 	bld	r5,0x6
80008c9c:	c4 a1       	brne	80008d30 <_vfprintf_r+0x1264>
80008c9e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ca2:	40 3c       	lddsp	r12,sp[0xc]
80008ca4:	58 0c       	cp.w	r12,0
80008ca6:	c1 d0       	breq	80008ce0 <_vfprintf_r+0x1214>
80008ca8:	10 36       	cp.w	r6,r8
80008caa:	c0 64       	brge	80008cb6 <_vfprintf_r+0x11ea>
80008cac:	fa cb f9 44 	sub	r11,sp,-1724
80008cb0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008cb4:	c1 f8       	rjmp	80008cf2 <_vfprintf_r+0x1226>
80008cb6:	fa c8 f9 50 	sub	r8,sp,-1712
80008cba:	1a d8       	st.w	--sp,r8
80008cbc:	fa c8 fa b8 	sub	r8,sp,-1352
80008cc0:	1a d8       	st.w	--sp,r8
80008cc2:	fa c8 fb b4 	sub	r8,sp,-1100
80008cc6:	1a d8       	st.w	--sp,r8
80008cc8:	fa c8 f9 40 	sub	r8,sp,-1728
80008ccc:	fa c9 ff b4 	sub	r9,sp,-76
80008cd0:	04 9a       	mov	r10,r2
80008cd2:	0c 9b       	mov	r11,r6
80008cd4:	08 9c       	mov	r12,r4
80008cd6:	fe b0 f5 63 	rcall	8000779c <get_arg>
80008cda:	2f dd       	sub	sp,-12
80008cdc:	98 18       	ld.sh	r8,r12[0x2]
80008cde:	c2 68       	rjmp	80008d2a <_vfprintf_r+0x125e>
80008ce0:	ee ca ff ff 	sub	r10,r7,-1
80008ce4:	10 37       	cp.w	r7,r8
80008ce6:	c0 94       	brge	80008cf8 <_vfprintf_r+0x122c>
80008ce8:	fa c9 f9 44 	sub	r9,sp,-1724
80008cec:	14 97       	mov	r7,r10
80008cee:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008cf2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008cf6:	c1 a8       	rjmp	80008d2a <_vfprintf_r+0x125e>
80008cf8:	41 09       	lddsp	r9,sp[0x40]
80008cfa:	59 f8       	cp.w	r8,31
80008cfc:	e0 89 00 13 	brgt	80008d22 <_vfprintf_r+0x1256>
80008d00:	f2 cb ff fc 	sub	r11,r9,-4
80008d04:	51 0b       	stdsp	sp[0x40],r11
80008d06:	72 09       	ld.w	r9,r9[0x0]
80008d08:	fa c6 f9 44 	sub	r6,sp,-1724
80008d0c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008d10:	2f f8       	sub	r8,-1
80008d12:	f7 49 fd 88 	st.w	r11[-632],r9
80008d16:	fb 48 06 b4 	st.w	sp[1716],r8
80008d1a:	14 97       	mov	r7,r10
80008d1c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008d20:	c0 58       	rjmp	80008d2a <_vfprintf_r+0x125e>
80008d22:	92 18       	ld.sh	r8,r9[0x2]
80008d24:	14 97       	mov	r7,r10
80008d26:	2f c9       	sub	r9,-4
80008d28:	51 09       	stdsp	sp[0x40],r9
80008d2a:	5c 78       	castu.h	r8
80008d2c:	50 18       	stdsp	sp[0x4],r8
80008d2e:	c4 68       	rjmp	80008dba <_vfprintf_r+0x12ee>
80008d30:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d34:	40 3c       	lddsp	r12,sp[0xc]
80008d36:	58 0c       	cp.w	r12,0
80008d38:	c1 d0       	breq	80008d72 <_vfprintf_r+0x12a6>
80008d3a:	10 36       	cp.w	r6,r8
80008d3c:	c0 64       	brge	80008d48 <_vfprintf_r+0x127c>
80008d3e:	fa cb f9 44 	sub	r11,sp,-1724
80008d42:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d46:	c1 f8       	rjmp	80008d84 <_vfprintf_r+0x12b8>
80008d48:	fa c8 f9 50 	sub	r8,sp,-1712
80008d4c:	1a d8       	st.w	--sp,r8
80008d4e:	fa c8 fa b8 	sub	r8,sp,-1352
80008d52:	0c 9b       	mov	r11,r6
80008d54:	1a d8       	st.w	--sp,r8
80008d56:	fa c8 fb b4 	sub	r8,sp,-1100
80008d5a:	04 9a       	mov	r10,r2
80008d5c:	1a d8       	st.w	--sp,r8
80008d5e:	08 9c       	mov	r12,r4
80008d60:	fa c8 f9 40 	sub	r8,sp,-1728
80008d64:	fa c9 ff b4 	sub	r9,sp,-76
80008d68:	fe b0 f5 1a 	rcall	8000779c <get_arg>
80008d6c:	2f dd       	sub	sp,-12
80008d6e:	78 0b       	ld.w	r11,r12[0x0]
80008d70:	c2 48       	rjmp	80008db8 <_vfprintf_r+0x12ec>
80008d72:	ee ca ff ff 	sub	r10,r7,-1
80008d76:	10 37       	cp.w	r7,r8
80008d78:	c0 94       	brge	80008d8a <_vfprintf_r+0x12be>
80008d7a:	fa c9 f9 44 	sub	r9,sp,-1724
80008d7e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008d82:	14 97       	mov	r7,r10
80008d84:	ec fb fd 88 	ld.w	r11,r6[-632]
80008d88:	c1 88       	rjmp	80008db8 <_vfprintf_r+0x12ec>
80008d8a:	41 09       	lddsp	r9,sp[0x40]
80008d8c:	59 f8       	cp.w	r8,31
80008d8e:	e0 89 00 11 	brgt	80008db0 <_vfprintf_r+0x12e4>
80008d92:	f2 cb ff fc 	sub	r11,r9,-4
80008d96:	51 0b       	stdsp	sp[0x40],r11
80008d98:	fa c6 f9 44 	sub	r6,sp,-1724
80008d9c:	72 0b       	ld.w	r11,r9[0x0]
80008d9e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008da2:	f3 4b fd 88 	st.w	r9[-632],r11
80008da6:	2f f8       	sub	r8,-1
80008da8:	14 97       	mov	r7,r10
80008daa:	fb 48 06 b4 	st.w	sp[1716],r8
80008dae:	c0 58       	rjmp	80008db8 <_vfprintf_r+0x12ec>
80008db0:	72 0b       	ld.w	r11,r9[0x0]
80008db2:	14 97       	mov	r7,r10
80008db4:	2f c9       	sub	r9,-4
80008db6:	51 09       	stdsp	sp[0x40],r9
80008db8:	50 1b       	stdsp	sp[0x4],r11
80008dba:	30 0e       	mov	lr,0
80008dbc:	30 18       	mov	r8,1
80008dbe:	50 0e       	stdsp	sp[0x0],lr
80008dc0:	c2 29       	rjmp	80009004 <_vfprintf_r+0x1538>
80008dc2:	50 a7       	stdsp	sp[0x28],r7
80008dc4:	50 80       	stdsp	sp[0x20],r0
80008dc6:	0c 97       	mov	r7,r6
80008dc8:	04 94       	mov	r4,r2
80008dca:	06 96       	mov	r6,r3
80008dcc:	02 92       	mov	r2,r1
80008dce:	fe cc b5 7e 	sub	r12,pc,-19074
80008dd2:	40 93       	lddsp	r3,sp[0x24]
80008dd4:	10 90       	mov	r0,r8
80008dd6:	40 41       	lddsp	r1,sp[0x10]
80008dd8:	50 dc       	stdsp	sp[0x34],r12
80008dda:	ed b5 00 05 	bld	r5,0x5
80008dde:	c5 51       	brne	80008e88 <_vfprintf_r+0x13bc>
80008de0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008de4:	40 3b       	lddsp	r11,sp[0xc]
80008de6:	58 0b       	cp.w	r11,0
80008de8:	c2 20       	breq	80008e2c <_vfprintf_r+0x1360>
80008dea:	10 36       	cp.w	r6,r8
80008dec:	c0 a4       	brge	80008e00 <_vfprintf_r+0x1334>
80008dee:	fa ca f9 44 	sub	r10,sp,-1724
80008df2:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008df6:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008dfa:	fa e9 00 00 	st.d	sp[0],r8
80008dfe:	cf 28       	rjmp	80008fe2 <_vfprintf_r+0x1516>
80008e00:	fa c8 f9 50 	sub	r8,sp,-1712
80008e04:	1a d8       	st.w	--sp,r8
80008e06:	fa c8 fa b8 	sub	r8,sp,-1352
80008e0a:	04 9a       	mov	r10,r2
80008e0c:	1a d8       	st.w	--sp,r8
80008e0e:	0c 9b       	mov	r11,r6
80008e10:	fa c8 fb b4 	sub	r8,sp,-1100
80008e14:	08 9c       	mov	r12,r4
80008e16:	1a d8       	st.w	--sp,r8
80008e18:	fa c8 f9 40 	sub	r8,sp,-1728
80008e1c:	fa c9 ff b4 	sub	r9,sp,-76
80008e20:	fe b0 f4 be 	rcall	8000779c <get_arg>
80008e24:	2f dd       	sub	sp,-12
80008e26:	f8 ea 00 00 	ld.d	r10,r12[0]
80008e2a:	c0 c8       	rjmp	80008e42 <_vfprintf_r+0x1376>
80008e2c:	ee ca ff ff 	sub	r10,r7,-1
80008e30:	10 37       	cp.w	r7,r8
80008e32:	c0 b4       	brge	80008e48 <_vfprintf_r+0x137c>
80008e34:	fa c9 f9 44 	sub	r9,sp,-1724
80008e38:	14 97       	mov	r7,r10
80008e3a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008e3e:	ec ea fd 88 	ld.d	r10,r6[-632]
80008e42:	fa eb 00 00 	st.d	sp[0],r10
80008e46:	cc e8       	rjmp	80008fe2 <_vfprintf_r+0x1516>
80008e48:	41 09       	lddsp	r9,sp[0x40]
80008e4a:	59 f8       	cp.w	r8,31
80008e4c:	e0 89 00 16 	brgt	80008e78 <_vfprintf_r+0x13ac>
80008e50:	f2 e6 00 00 	ld.d	r6,r9[0]
80008e54:	f2 cb ff f8 	sub	r11,r9,-8
80008e58:	fa e7 00 00 	st.d	sp[0],r6
80008e5c:	51 0b       	stdsp	sp[0x40],r11
80008e5e:	fa c6 f9 44 	sub	r6,sp,-1724
80008e62:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008e66:	fa e6 00 00 	ld.d	r6,sp[0]
80008e6a:	f2 e7 fd 88 	st.d	r9[-632],r6
80008e6e:	2f f8       	sub	r8,-1
80008e70:	14 97       	mov	r7,r10
80008e72:	fb 48 06 b4 	st.w	sp[1716],r8
80008e76:	cb 68       	rjmp	80008fe2 <_vfprintf_r+0x1516>
80008e78:	f2 e6 00 00 	ld.d	r6,r9[0]
80008e7c:	2f 89       	sub	r9,-8
80008e7e:	fa e7 00 00 	st.d	sp[0],r6
80008e82:	51 09       	stdsp	sp[0x40],r9
80008e84:	14 97       	mov	r7,r10
80008e86:	ca e8       	rjmp	80008fe2 <_vfprintf_r+0x1516>
80008e88:	ed b5 00 04 	bld	r5,0x4
80008e8c:	c1 71       	brne	80008eba <_vfprintf_r+0x13ee>
80008e8e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e92:	40 3e       	lddsp	lr,sp[0xc]
80008e94:	58 0e       	cp.w	lr,0
80008e96:	c0 80       	breq	80008ea6 <_vfprintf_r+0x13da>
80008e98:	10 36       	cp.w	r6,r8
80008e9a:	c6 94       	brge	80008f6c <_vfprintf_r+0x14a0>
80008e9c:	fa cc f9 44 	sub	r12,sp,-1724
80008ea0:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008ea4:	c8 28       	rjmp	80008fa8 <_vfprintf_r+0x14dc>
80008ea6:	ee ca ff ff 	sub	r10,r7,-1
80008eaa:	10 37       	cp.w	r7,r8
80008eac:	e0 84 00 81 	brge	80008fae <_vfprintf_r+0x14e2>
80008eb0:	fa cb f9 44 	sub	r11,sp,-1724
80008eb4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008eb8:	c7 78       	rjmp	80008fa6 <_vfprintf_r+0x14da>
80008eba:	ed b5 00 06 	bld	r5,0x6
80008ebe:	c4 b1       	brne	80008f54 <_vfprintf_r+0x1488>
80008ec0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ec4:	40 3c       	lddsp	r12,sp[0xc]
80008ec6:	58 0c       	cp.w	r12,0
80008ec8:	c1 d0       	breq	80008f02 <_vfprintf_r+0x1436>
80008eca:	10 36       	cp.w	r6,r8
80008ecc:	c0 64       	brge	80008ed8 <_vfprintf_r+0x140c>
80008ece:	fa cb f9 44 	sub	r11,sp,-1724
80008ed2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008ed6:	c1 f8       	rjmp	80008f14 <_vfprintf_r+0x1448>
80008ed8:	fa c8 f9 50 	sub	r8,sp,-1712
80008edc:	1a d8       	st.w	--sp,r8
80008ede:	fa c8 fa b8 	sub	r8,sp,-1352
80008ee2:	1a d8       	st.w	--sp,r8
80008ee4:	fa c8 fb b4 	sub	r8,sp,-1100
80008ee8:	1a d8       	st.w	--sp,r8
80008eea:	fa c8 f9 40 	sub	r8,sp,-1728
80008eee:	fa c9 ff b4 	sub	r9,sp,-76
80008ef2:	04 9a       	mov	r10,r2
80008ef4:	0c 9b       	mov	r11,r6
80008ef6:	08 9c       	mov	r12,r4
80008ef8:	fe b0 f4 52 	rcall	8000779c <get_arg>
80008efc:	2f dd       	sub	sp,-12
80008efe:	98 18       	ld.sh	r8,r12[0x2]
80008f00:	c2 78       	rjmp	80008f4e <_vfprintf_r+0x1482>
80008f02:	ee ca ff ff 	sub	r10,r7,-1
80008f06:	10 37       	cp.w	r7,r8
80008f08:	c0 a4       	brge	80008f1c <_vfprintf_r+0x1450>
80008f0a:	fa c9 f9 44 	sub	r9,sp,-1724
80008f0e:	14 97       	mov	r7,r10
80008f10:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f14:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008f18:	c1 b8       	rjmp	80008f4e <_vfprintf_r+0x1482>
80008f1a:	d7 03       	nop
80008f1c:	41 09       	lddsp	r9,sp[0x40]
80008f1e:	59 f8       	cp.w	r8,31
80008f20:	e0 89 00 13 	brgt	80008f46 <_vfprintf_r+0x147a>
80008f24:	f2 cb ff fc 	sub	r11,r9,-4
80008f28:	51 0b       	stdsp	sp[0x40],r11
80008f2a:	72 09       	ld.w	r9,r9[0x0]
80008f2c:	fa c6 f9 44 	sub	r6,sp,-1724
80008f30:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008f34:	2f f8       	sub	r8,-1
80008f36:	f7 49 fd 88 	st.w	r11[-632],r9
80008f3a:	fb 48 06 b4 	st.w	sp[1716],r8
80008f3e:	14 97       	mov	r7,r10
80008f40:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008f44:	c0 58       	rjmp	80008f4e <_vfprintf_r+0x1482>
80008f46:	92 18       	ld.sh	r8,r9[0x2]
80008f48:	14 97       	mov	r7,r10
80008f4a:	2f c9       	sub	r9,-4
80008f4c:	51 09       	stdsp	sp[0x40],r9
80008f4e:	5c 78       	castu.h	r8
80008f50:	50 18       	stdsp	sp[0x4],r8
80008f52:	c4 68       	rjmp	80008fde <_vfprintf_r+0x1512>
80008f54:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f58:	40 3c       	lddsp	r12,sp[0xc]
80008f5a:	58 0c       	cp.w	r12,0
80008f5c:	c1 d0       	breq	80008f96 <_vfprintf_r+0x14ca>
80008f5e:	10 36       	cp.w	r6,r8
80008f60:	c0 64       	brge	80008f6c <_vfprintf_r+0x14a0>
80008f62:	fa cb f9 44 	sub	r11,sp,-1724
80008f66:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f6a:	c1 f8       	rjmp	80008fa8 <_vfprintf_r+0x14dc>
80008f6c:	fa c8 f9 50 	sub	r8,sp,-1712
80008f70:	1a d8       	st.w	--sp,r8
80008f72:	fa c8 fa b8 	sub	r8,sp,-1352
80008f76:	0c 9b       	mov	r11,r6
80008f78:	1a d8       	st.w	--sp,r8
80008f7a:	fa c8 fb b4 	sub	r8,sp,-1100
80008f7e:	04 9a       	mov	r10,r2
80008f80:	1a d8       	st.w	--sp,r8
80008f82:	08 9c       	mov	r12,r4
80008f84:	fa c8 f9 40 	sub	r8,sp,-1728
80008f88:	fa c9 ff b4 	sub	r9,sp,-76
80008f8c:	fe b0 f4 08 	rcall	8000779c <get_arg>
80008f90:	2f dd       	sub	sp,-12
80008f92:	78 0b       	ld.w	r11,r12[0x0]
80008f94:	c2 48       	rjmp	80008fdc <_vfprintf_r+0x1510>
80008f96:	ee ca ff ff 	sub	r10,r7,-1
80008f9a:	10 37       	cp.w	r7,r8
80008f9c:	c0 94       	brge	80008fae <_vfprintf_r+0x14e2>
80008f9e:	fa c9 f9 44 	sub	r9,sp,-1724
80008fa2:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008fa6:	14 97       	mov	r7,r10
80008fa8:	ec fb fd 88 	ld.w	r11,r6[-632]
80008fac:	c1 88       	rjmp	80008fdc <_vfprintf_r+0x1510>
80008fae:	41 09       	lddsp	r9,sp[0x40]
80008fb0:	59 f8       	cp.w	r8,31
80008fb2:	e0 89 00 11 	brgt	80008fd4 <_vfprintf_r+0x1508>
80008fb6:	f2 cb ff fc 	sub	r11,r9,-4
80008fba:	51 0b       	stdsp	sp[0x40],r11
80008fbc:	fa c6 f9 44 	sub	r6,sp,-1724
80008fc0:	72 0b       	ld.w	r11,r9[0x0]
80008fc2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008fc6:	f3 4b fd 88 	st.w	r9[-632],r11
80008fca:	2f f8       	sub	r8,-1
80008fcc:	14 97       	mov	r7,r10
80008fce:	fb 48 06 b4 	st.w	sp[1716],r8
80008fd2:	c0 58       	rjmp	80008fdc <_vfprintf_r+0x1510>
80008fd4:	72 0b       	ld.w	r11,r9[0x0]
80008fd6:	14 97       	mov	r7,r10
80008fd8:	2f c9       	sub	r9,-4
80008fda:	51 09       	stdsp	sp[0x40],r9
80008fdc:	50 1b       	stdsp	sp[0x4],r11
80008fde:	30 0e       	mov	lr,0
80008fe0:	50 0e       	stdsp	sp[0x0],lr
80008fe2:	40 08       	lddsp	r8,sp[0x0]
80008fe4:	40 1c       	lddsp	r12,sp[0x4]
80008fe6:	18 48       	or	r8,r12
80008fe8:	5f 19       	srne	r9
80008fea:	0a 98       	mov	r8,r5
80008fec:	eb e9 00 09 	and	r9,r5,r9
80008ff0:	a1 b8       	sbr	r8,0x1
80008ff2:	58 09       	cp.w	r9,0
80008ff4:	c0 70       	breq	80009002 <_vfprintf_r+0x1536>
80008ff6:	10 95       	mov	r5,r8
80008ff8:	fb 60 06 b9 	st.b	sp[1721],r0
80008ffc:	33 08       	mov	r8,48
80008ffe:	fb 68 06 b8 	st.b	sp[1720],r8
80009002:	30 28       	mov	r8,2
80009004:	30 09       	mov	r9,0
80009006:	fb 69 06 bb 	st.b	sp[1723],r9
8000900a:	0a 99       	mov	r9,r5
8000900c:	a7 d9       	cbr	r9,0x7
8000900e:	40 2b       	lddsp	r11,sp[0x8]
80009010:	40 16       	lddsp	r6,sp[0x4]
80009012:	58 0b       	cp.w	r11,0
80009014:	5f 1a       	srne	r10
80009016:	f2 05 17 40 	movge	r5,r9
8000901a:	fa c2 f9 78 	sub	r2,sp,-1672
8000901e:	40 09       	lddsp	r9,sp[0x0]
80009020:	0c 49       	or	r9,r6
80009022:	5f 19       	srne	r9
80009024:	f5 e9 10 09 	or	r9,r10,r9
80009028:	c5 c0       	breq	800090e0 <_vfprintf_r+0x1614>
8000902a:	30 19       	mov	r9,1
8000902c:	f2 08 18 00 	cp.b	r8,r9
80009030:	c0 60       	breq	8000903c <_vfprintf_r+0x1570>
80009032:	30 29       	mov	r9,2
80009034:	f2 08 18 00 	cp.b	r8,r9
80009038:	c0 41       	brne	80009040 <_vfprintf_r+0x1574>
8000903a:	c3 c8       	rjmp	800090b2 <_vfprintf_r+0x15e6>
8000903c:	04 96       	mov	r6,r2
8000903e:	c3 08       	rjmp	8000909e <_vfprintf_r+0x15d2>
80009040:	04 96       	mov	r6,r2
80009042:	fa e8 00 00 	ld.d	r8,sp[0]
80009046:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000904a:	2d 0a       	sub	r10,-48
8000904c:	0c fa       	st.b	--r6,r10
8000904e:	f0 0b 16 03 	lsr	r11,r8,0x3
80009052:	f2 0c 16 03 	lsr	r12,r9,0x3
80009056:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000905a:	18 99       	mov	r9,r12
8000905c:	16 98       	mov	r8,r11
8000905e:	58 08       	cp.w	r8,0
80009060:	5c 29       	cpc	r9
80009062:	cf 21       	brne	80009046 <_vfprintf_r+0x157a>
80009064:	fa e9 00 00 	st.d	sp[0],r8
80009068:	ed b5 00 00 	bld	r5,0x0
8000906c:	c4 51       	brne	800090f6 <_vfprintf_r+0x162a>
8000906e:	33 09       	mov	r9,48
80009070:	f2 0a 18 00 	cp.b	r10,r9
80009074:	c4 10       	breq	800090f6 <_vfprintf_r+0x162a>
80009076:	0c f9       	st.b	--r6,r9
80009078:	c3 f8       	rjmp	800090f6 <_vfprintf_r+0x162a>
8000907a:	fa ea 00 00 	ld.d	r10,sp[0]
8000907e:	30 a8       	mov	r8,10
80009080:	30 09       	mov	r9,0
80009082:	e0 a0 1a 19 	rcall	8000c4b4 <__avr32_umod64>
80009086:	30 a8       	mov	r8,10
80009088:	2d 0a       	sub	r10,-48
8000908a:	30 09       	mov	r9,0
8000908c:	ac 8a       	st.b	r6[0x0],r10
8000908e:	fa ea 00 00 	ld.d	r10,sp[0]
80009092:	e0 a0 18 df 	rcall	8000c250 <__avr32_udiv64>
80009096:	16 99       	mov	r9,r11
80009098:	14 98       	mov	r8,r10
8000909a:	fa e9 00 00 	st.d	sp[0],r8
8000909e:	20 16       	sub	r6,1
800090a0:	fa ea 00 00 	ld.d	r10,sp[0]
800090a4:	58 9a       	cp.w	r10,9
800090a6:	5c 2b       	cpc	r11
800090a8:	fe 9b ff e9 	brhi	8000907a <_vfprintf_r+0x15ae>
800090ac:	1b f8       	ld.ub	r8,sp[0x7]
800090ae:	2d 08       	sub	r8,-48
800090b0:	c2 08       	rjmp	800090f0 <_vfprintf_r+0x1624>
800090b2:	04 96       	mov	r6,r2
800090b4:	fa e8 00 00 	ld.d	r8,sp[0]
800090b8:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
800090bc:	40 de       	lddsp	lr,sp[0x34]
800090be:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
800090c2:	0c fa       	st.b	--r6,r10
800090c4:	f2 0b 16 04 	lsr	r11,r9,0x4
800090c8:	f0 0a 16 04 	lsr	r10,r8,0x4
800090cc:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
800090d0:	16 99       	mov	r9,r11
800090d2:	14 98       	mov	r8,r10
800090d4:	58 08       	cp.w	r8,0
800090d6:	5c 29       	cpc	r9
800090d8:	cf 01       	brne	800090b8 <_vfprintf_r+0x15ec>
800090da:	fa e9 00 00 	st.d	sp[0],r8
800090de:	c0 c8       	rjmp	800090f6 <_vfprintf_r+0x162a>
800090e0:	58 08       	cp.w	r8,0
800090e2:	c0 91       	brne	800090f4 <_vfprintf_r+0x1628>
800090e4:	ed b5 00 00 	bld	r5,0x0
800090e8:	c0 61       	brne	800090f4 <_vfprintf_r+0x1628>
800090ea:	fa c6 f9 79 	sub	r6,sp,-1671
800090ee:	33 08       	mov	r8,48
800090f0:	ac 88       	st.b	r6[0x0],r8
800090f2:	c0 28       	rjmp	800090f6 <_vfprintf_r+0x162a>
800090f4:	04 96       	mov	r6,r2
800090f6:	0c 12       	sub	r2,r6
800090f8:	c1 c8       	rjmp	80009130 <_vfprintf_r+0x1664>
800090fa:	50 a7       	stdsp	sp[0x28],r7
800090fc:	50 80       	stdsp	sp[0x20],r0
800090fe:	40 93       	lddsp	r3,sp[0x24]
80009100:	0c 97       	mov	r7,r6
80009102:	10 90       	mov	r0,r8
80009104:	04 94       	mov	r4,r2
80009106:	40 41       	lddsp	r1,sp[0x10]
80009108:	58 08       	cp.w	r8,0
8000910a:	e0 80 04 4f 	breq	800099a8 <_vfprintf_r+0x1edc>
8000910e:	fb 68 06 60 	st.b	sp[1632],r8
80009112:	30 0c       	mov	r12,0
80009114:	30 08       	mov	r8,0
80009116:	30 12       	mov	r2,1
80009118:	fb 68 06 bb 	st.b	sp[1723],r8
8000911c:	50 2c       	stdsp	sp[0x8],r12
8000911e:	fa c6 f9 a0 	sub	r6,sp,-1632
80009122:	c0 78       	rjmp	80009130 <_vfprintf_r+0x1664>
80009124:	30 0b       	mov	r11,0
80009126:	50 2b       	stdsp	sp[0x8],r11
80009128:	c0 48       	rjmp	80009130 <_vfprintf_r+0x1664>
8000912a:	40 22       	lddsp	r2,sp[0x8]
8000912c:	30 0a       	mov	r10,0
8000912e:	50 2a       	stdsp	sp[0x8],r10
80009130:	40 29       	lddsp	r9,sp[0x8]
80009132:	e4 09 0c 49 	max	r9,r2,r9
80009136:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000913a:	50 39       	stdsp	sp[0xc],r9
8000913c:	0a 9e       	mov	lr,r5
8000913e:	30 09       	mov	r9,0
80009140:	e2 1e 00 02 	andl	lr,0x2,COH
80009144:	f2 08 18 00 	cp.b	r8,r9
80009148:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000914c:	f7 b8 01 ff 	subne	r8,-1
80009150:	fb f8 1a 03 	st.wne	sp[0xc],r8
80009154:	0a 9b       	mov	r11,r5
80009156:	58 0e       	cp.w	lr,0
80009158:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000915c:	f7 bc 01 fe 	subne	r12,-2
80009160:	fb fc 1a 03 	st.wne	sp[0xc],r12
80009164:	e2 1b 00 84 	andl	r11,0x84,COH
80009168:	50 fe       	stdsp	sp[0x3c],lr
8000916a:	50 9b       	stdsp	sp[0x24],r11
8000916c:	c4 71       	brne	800091fa <_vfprintf_r+0x172e>
8000916e:	40 8a       	lddsp	r10,sp[0x20]
80009170:	40 39       	lddsp	r9,sp[0xc]
80009172:	12 1a       	sub	r10,r9
80009174:	50 4a       	stdsp	sp[0x10],r10
80009176:	58 0a       	cp.w	r10,0
80009178:	e0 89 00 20 	brgt	800091b8 <_vfprintf_r+0x16ec>
8000917c:	c3 f8       	rjmp	800091fa <_vfprintf_r+0x172e>
8000917e:	2f 09       	sub	r9,-16
80009180:	2f f8       	sub	r8,-1
80009182:	fe ce b9 1a 	sub	lr,pc,-18150
80009186:	31 0c       	mov	r12,16
80009188:	fb 49 06 90 	st.w	sp[1680],r9
8000918c:	87 0e       	st.w	r3[0x0],lr
8000918e:	87 1c       	st.w	r3[0x4],r12
80009190:	fb 48 06 8c 	st.w	sp[1676],r8
80009194:	58 78       	cp.w	r8,7
80009196:	e0 89 00 04 	brgt	8000919e <_vfprintf_r+0x16d2>
8000919a:	2f 83       	sub	r3,-8
8000919c:	c0 b8       	rjmp	800091b2 <_vfprintf_r+0x16e6>
8000919e:	fa ca f9 78 	sub	r10,sp,-1672
800091a2:	02 9b       	mov	r11,r1
800091a4:	08 9c       	mov	r12,r4
800091a6:	fe b0 f4 85 	rcall	80007ab0 <__sprint_r>
800091aa:	e0 81 04 10 	brne	800099ca <_vfprintf_r+0x1efe>
800091ae:	fa c3 f9 e0 	sub	r3,sp,-1568
800091b2:	40 4b       	lddsp	r11,sp[0x10]
800091b4:	21 0b       	sub	r11,16
800091b6:	50 4b       	stdsp	sp[0x10],r11
800091b8:	fa f9 06 90 	ld.w	r9,sp[1680]
800091bc:	fa f8 06 8c 	ld.w	r8,sp[1676]
800091c0:	fe ca b9 58 	sub	r10,pc,-18088
800091c4:	40 4e       	lddsp	lr,sp[0x10]
800091c6:	59 0e       	cp.w	lr,16
800091c8:	fe 99 ff db 	brgt	8000917e <_vfprintf_r+0x16b2>
800091cc:	1c 09       	add	r9,lr
800091ce:	2f f8       	sub	r8,-1
800091d0:	87 0a       	st.w	r3[0x0],r10
800091d2:	fb 49 06 90 	st.w	sp[1680],r9
800091d6:	87 1e       	st.w	r3[0x4],lr
800091d8:	fb 48 06 8c 	st.w	sp[1676],r8
800091dc:	58 78       	cp.w	r8,7
800091de:	e0 89 00 04 	brgt	800091e6 <_vfprintf_r+0x171a>
800091e2:	2f 83       	sub	r3,-8
800091e4:	c0 b8       	rjmp	800091fa <_vfprintf_r+0x172e>
800091e6:	fa ca f9 78 	sub	r10,sp,-1672
800091ea:	02 9b       	mov	r11,r1
800091ec:	08 9c       	mov	r12,r4
800091ee:	fe b0 f4 61 	rcall	80007ab0 <__sprint_r>
800091f2:	e0 81 03 ec 	brne	800099ca <_vfprintf_r+0x1efe>
800091f6:	fa c3 f9 e0 	sub	r3,sp,-1568
800091fa:	30 09       	mov	r9,0
800091fc:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009200:	f2 08 18 00 	cp.b	r8,r9
80009204:	c1 f0       	breq	80009242 <_vfprintf_r+0x1776>
80009206:	fa f8 06 90 	ld.w	r8,sp[1680]
8000920a:	fa c9 f9 45 	sub	r9,sp,-1723
8000920e:	2f f8       	sub	r8,-1
80009210:	87 09       	st.w	r3[0x0],r9
80009212:	fb 48 06 90 	st.w	sp[1680],r8
80009216:	30 19       	mov	r9,1
80009218:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000921c:	87 19       	st.w	r3[0x4],r9
8000921e:	2f f8       	sub	r8,-1
80009220:	fb 48 06 8c 	st.w	sp[1676],r8
80009224:	58 78       	cp.w	r8,7
80009226:	e0 89 00 04 	brgt	8000922e <_vfprintf_r+0x1762>
8000922a:	2f 83       	sub	r3,-8
8000922c:	c0 b8       	rjmp	80009242 <_vfprintf_r+0x1776>
8000922e:	fa ca f9 78 	sub	r10,sp,-1672
80009232:	02 9b       	mov	r11,r1
80009234:	08 9c       	mov	r12,r4
80009236:	fe b0 f4 3d 	rcall	80007ab0 <__sprint_r>
8000923a:	e0 81 03 c8 	brne	800099ca <_vfprintf_r+0x1efe>
8000923e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009242:	40 fc       	lddsp	r12,sp[0x3c]
80009244:	58 0c       	cp.w	r12,0
80009246:	c1 f0       	breq	80009284 <_vfprintf_r+0x17b8>
80009248:	fa f8 06 90 	ld.w	r8,sp[1680]
8000924c:	fa c9 f9 48 	sub	r9,sp,-1720
80009250:	2f e8       	sub	r8,-2
80009252:	87 09       	st.w	r3[0x0],r9
80009254:	fb 48 06 90 	st.w	sp[1680],r8
80009258:	30 29       	mov	r9,2
8000925a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000925e:	87 19       	st.w	r3[0x4],r9
80009260:	2f f8       	sub	r8,-1
80009262:	fb 48 06 8c 	st.w	sp[1676],r8
80009266:	58 78       	cp.w	r8,7
80009268:	e0 89 00 04 	brgt	80009270 <_vfprintf_r+0x17a4>
8000926c:	2f 83       	sub	r3,-8
8000926e:	c0 b8       	rjmp	80009284 <_vfprintf_r+0x17b8>
80009270:	fa ca f9 78 	sub	r10,sp,-1672
80009274:	02 9b       	mov	r11,r1
80009276:	08 9c       	mov	r12,r4
80009278:	fe b0 f4 1c 	rcall	80007ab0 <__sprint_r>
8000927c:	e0 81 03 a7 	brne	800099ca <_vfprintf_r+0x1efe>
80009280:	fa c3 f9 e0 	sub	r3,sp,-1568
80009284:	40 9b       	lddsp	r11,sp[0x24]
80009286:	e0 4b 00 80 	cp.w	r11,128
8000928a:	c4 71       	brne	80009318 <_vfprintf_r+0x184c>
8000928c:	40 8a       	lddsp	r10,sp[0x20]
8000928e:	40 39       	lddsp	r9,sp[0xc]
80009290:	12 1a       	sub	r10,r9
80009292:	50 4a       	stdsp	sp[0x10],r10
80009294:	58 0a       	cp.w	r10,0
80009296:	e0 89 00 20 	brgt	800092d6 <_vfprintf_r+0x180a>
8000929a:	c3 f8       	rjmp	80009318 <_vfprintf_r+0x184c>
8000929c:	2f 09       	sub	r9,-16
8000929e:	2f f8       	sub	r8,-1
800092a0:	fe ce ba 28 	sub	lr,pc,-17880
800092a4:	31 0c       	mov	r12,16
800092a6:	fb 49 06 90 	st.w	sp[1680],r9
800092aa:	87 0e       	st.w	r3[0x0],lr
800092ac:	87 1c       	st.w	r3[0x4],r12
800092ae:	fb 48 06 8c 	st.w	sp[1676],r8
800092b2:	58 78       	cp.w	r8,7
800092b4:	e0 89 00 04 	brgt	800092bc <_vfprintf_r+0x17f0>
800092b8:	2f 83       	sub	r3,-8
800092ba:	c0 b8       	rjmp	800092d0 <_vfprintf_r+0x1804>
800092bc:	fa ca f9 78 	sub	r10,sp,-1672
800092c0:	02 9b       	mov	r11,r1
800092c2:	08 9c       	mov	r12,r4
800092c4:	fe b0 f3 f6 	rcall	80007ab0 <__sprint_r>
800092c8:	e0 81 03 81 	brne	800099ca <_vfprintf_r+0x1efe>
800092cc:	fa c3 f9 e0 	sub	r3,sp,-1568
800092d0:	40 4b       	lddsp	r11,sp[0x10]
800092d2:	21 0b       	sub	r11,16
800092d4:	50 4b       	stdsp	sp[0x10],r11
800092d6:	fa f9 06 90 	ld.w	r9,sp[1680]
800092da:	fa f8 06 8c 	ld.w	r8,sp[1676]
800092de:	fe ca ba 66 	sub	r10,pc,-17818
800092e2:	40 4e       	lddsp	lr,sp[0x10]
800092e4:	59 0e       	cp.w	lr,16
800092e6:	fe 99 ff db 	brgt	8000929c <_vfprintf_r+0x17d0>
800092ea:	1c 09       	add	r9,lr
800092ec:	2f f8       	sub	r8,-1
800092ee:	87 0a       	st.w	r3[0x0],r10
800092f0:	fb 49 06 90 	st.w	sp[1680],r9
800092f4:	87 1e       	st.w	r3[0x4],lr
800092f6:	fb 48 06 8c 	st.w	sp[1676],r8
800092fa:	58 78       	cp.w	r8,7
800092fc:	e0 89 00 04 	brgt	80009304 <_vfprintf_r+0x1838>
80009300:	2f 83       	sub	r3,-8
80009302:	c0 b8       	rjmp	80009318 <_vfprintf_r+0x184c>
80009304:	fa ca f9 78 	sub	r10,sp,-1672
80009308:	02 9b       	mov	r11,r1
8000930a:	08 9c       	mov	r12,r4
8000930c:	fe b0 f3 d2 	rcall	80007ab0 <__sprint_r>
80009310:	e0 81 03 5d 	brne	800099ca <_vfprintf_r+0x1efe>
80009314:	fa c3 f9 e0 	sub	r3,sp,-1568
80009318:	40 2c       	lddsp	r12,sp[0x8]
8000931a:	04 1c       	sub	r12,r2
8000931c:	50 2c       	stdsp	sp[0x8],r12
8000931e:	58 0c       	cp.w	r12,0
80009320:	e0 89 00 20 	brgt	80009360 <_vfprintf_r+0x1894>
80009324:	c3 f8       	rjmp	800093a2 <_vfprintf_r+0x18d6>
80009326:	2f 09       	sub	r9,-16
80009328:	2f f8       	sub	r8,-1
8000932a:	fe cb ba b2 	sub	r11,pc,-17742
8000932e:	31 0a       	mov	r10,16
80009330:	fb 49 06 90 	st.w	sp[1680],r9
80009334:	87 0b       	st.w	r3[0x0],r11
80009336:	87 1a       	st.w	r3[0x4],r10
80009338:	fb 48 06 8c 	st.w	sp[1676],r8
8000933c:	58 78       	cp.w	r8,7
8000933e:	e0 89 00 04 	brgt	80009346 <_vfprintf_r+0x187a>
80009342:	2f 83       	sub	r3,-8
80009344:	c0 b8       	rjmp	8000935a <_vfprintf_r+0x188e>
80009346:	fa ca f9 78 	sub	r10,sp,-1672
8000934a:	02 9b       	mov	r11,r1
8000934c:	08 9c       	mov	r12,r4
8000934e:	fe b0 f3 b1 	rcall	80007ab0 <__sprint_r>
80009352:	e0 81 03 3c 	brne	800099ca <_vfprintf_r+0x1efe>
80009356:	fa c3 f9 e0 	sub	r3,sp,-1568
8000935a:	40 29       	lddsp	r9,sp[0x8]
8000935c:	21 09       	sub	r9,16
8000935e:	50 29       	stdsp	sp[0x8],r9
80009360:	fa f9 06 90 	ld.w	r9,sp[1680]
80009364:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009368:	fe ca ba f0 	sub	r10,pc,-17680
8000936c:	40 2e       	lddsp	lr,sp[0x8]
8000936e:	59 0e       	cp.w	lr,16
80009370:	fe 99 ff db 	brgt	80009326 <_vfprintf_r+0x185a>
80009374:	1c 09       	add	r9,lr
80009376:	2f f8       	sub	r8,-1
80009378:	87 0a       	st.w	r3[0x0],r10
8000937a:	fb 49 06 90 	st.w	sp[1680],r9
8000937e:	87 1e       	st.w	r3[0x4],lr
80009380:	fb 48 06 8c 	st.w	sp[1676],r8
80009384:	58 78       	cp.w	r8,7
80009386:	e0 89 00 04 	brgt	8000938e <_vfprintf_r+0x18c2>
8000938a:	2f 83       	sub	r3,-8
8000938c:	c0 b8       	rjmp	800093a2 <_vfprintf_r+0x18d6>
8000938e:	fa ca f9 78 	sub	r10,sp,-1672
80009392:	02 9b       	mov	r11,r1
80009394:	08 9c       	mov	r12,r4
80009396:	fe b0 f3 8d 	rcall	80007ab0 <__sprint_r>
8000939a:	e0 81 03 18 	brne	800099ca <_vfprintf_r+0x1efe>
8000939e:	fa c3 f9 e0 	sub	r3,sp,-1568
800093a2:	ed b5 00 08 	bld	r5,0x8
800093a6:	c0 b0       	breq	800093bc <_vfprintf_r+0x18f0>
800093a8:	fa f8 06 90 	ld.w	r8,sp[1680]
800093ac:	87 12       	st.w	r3[0x4],r2
800093ae:	87 06       	st.w	r3[0x0],r6
800093b0:	f0 02 00 02 	add	r2,r8,r2
800093b4:	fb 42 06 90 	st.w	sp[1680],r2
800093b8:	e0 8f 01 d4 	bral	80009760 <_vfprintf_r+0x1c94>
800093bc:	e0 40 00 65 	cp.w	r0,101
800093c0:	e0 8a 01 d6 	brle	8000976c <_vfprintf_r+0x1ca0>
800093c4:	30 08       	mov	r8,0
800093c6:	30 09       	mov	r9,0
800093c8:	40 5b       	lddsp	r11,sp[0x14]
800093ca:	40 7a       	lddsp	r10,sp[0x1c]
800093cc:	e0 a0 15 3b 	rcall	8000be42 <__avr32_f64_cmp_eq>
800093d0:	c7 90       	breq	800094c2 <_vfprintf_r+0x19f6>
800093d2:	fa f8 06 90 	ld.w	r8,sp[1680]
800093d6:	fe c9 bb 72 	sub	r9,pc,-17550
800093da:	2f f8       	sub	r8,-1
800093dc:	87 09       	st.w	r3[0x0],r9
800093de:	fb 48 06 90 	st.w	sp[1680],r8
800093e2:	30 19       	mov	r9,1
800093e4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800093e8:	87 19       	st.w	r3[0x4],r9
800093ea:	2f f8       	sub	r8,-1
800093ec:	fb 48 06 8c 	st.w	sp[1676],r8
800093f0:	58 78       	cp.w	r8,7
800093f2:	e0 89 00 05 	brgt	800093fc <_vfprintf_r+0x1930>
800093f6:	2f 83       	sub	r3,-8
800093f8:	c0 c8       	rjmp	80009410 <_vfprintf_r+0x1944>
800093fa:	d7 03       	nop
800093fc:	fa ca f9 78 	sub	r10,sp,-1672
80009400:	02 9b       	mov	r11,r1
80009402:	08 9c       	mov	r12,r4
80009404:	fe b0 f3 56 	rcall	80007ab0 <__sprint_r>
80009408:	e0 81 02 e1 	brne	800099ca <_vfprintf_r+0x1efe>
8000940c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009410:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009414:	40 6c       	lddsp	r12,sp[0x18]
80009416:	18 38       	cp.w	r8,r12
80009418:	c0 55       	brlt	80009422 <_vfprintf_r+0x1956>
8000941a:	ed b5 00 00 	bld	r5,0x0
8000941e:	e0 81 02 6b 	brne	800098f4 <_vfprintf_r+0x1e28>
80009422:	fa f8 06 90 	ld.w	r8,sp[1680]
80009426:	2f f8       	sub	r8,-1
80009428:	40 cb       	lddsp	r11,sp[0x30]
8000942a:	fb 48 06 90 	st.w	sp[1680],r8
8000942e:	30 19       	mov	r9,1
80009430:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009434:	87 0b       	st.w	r3[0x0],r11
80009436:	2f f8       	sub	r8,-1
80009438:	87 19       	st.w	r3[0x4],r9
8000943a:	fb 48 06 8c 	st.w	sp[1676],r8
8000943e:	58 78       	cp.w	r8,7
80009440:	e0 89 00 04 	brgt	80009448 <_vfprintf_r+0x197c>
80009444:	2f 83       	sub	r3,-8
80009446:	c0 b8       	rjmp	8000945c <_vfprintf_r+0x1990>
80009448:	fa ca f9 78 	sub	r10,sp,-1672
8000944c:	02 9b       	mov	r11,r1
8000944e:	08 9c       	mov	r12,r4
80009450:	fe b0 f3 30 	rcall	80007ab0 <__sprint_r>
80009454:	e0 81 02 bb 	brne	800099ca <_vfprintf_r+0x1efe>
80009458:	fa c3 f9 e0 	sub	r3,sp,-1568
8000945c:	40 66       	lddsp	r6,sp[0x18]
8000945e:	20 16       	sub	r6,1
80009460:	58 06       	cp.w	r6,0
80009462:	e0 89 00 1d 	brgt	8000949c <_vfprintf_r+0x19d0>
80009466:	e0 8f 02 47 	bral	800098f4 <_vfprintf_r+0x1e28>
8000946a:	2f 09       	sub	r9,-16
8000946c:	2f f8       	sub	r8,-1
8000946e:	fb 49 06 90 	st.w	sp[1680],r9
80009472:	87 02       	st.w	r3[0x0],r2
80009474:	87 10       	st.w	r3[0x4],r0
80009476:	fb 48 06 8c 	st.w	sp[1676],r8
8000947a:	58 78       	cp.w	r8,7
8000947c:	e0 89 00 04 	brgt	80009484 <_vfprintf_r+0x19b8>
80009480:	2f 83       	sub	r3,-8
80009482:	c0 b8       	rjmp	80009498 <_vfprintf_r+0x19cc>
80009484:	fa ca f9 78 	sub	r10,sp,-1672
80009488:	02 9b       	mov	r11,r1
8000948a:	08 9c       	mov	r12,r4
8000948c:	fe b0 f3 12 	rcall	80007ab0 <__sprint_r>
80009490:	e0 81 02 9d 	brne	800099ca <_vfprintf_r+0x1efe>
80009494:	fa c3 f9 e0 	sub	r3,sp,-1568
80009498:	21 06       	sub	r6,16
8000949a:	c0 48       	rjmp	800094a2 <_vfprintf_r+0x19d6>
8000949c:	fe c2 bc 24 	sub	r2,pc,-17372
800094a0:	31 00       	mov	r0,16
800094a2:	fa f9 06 90 	ld.w	r9,sp[1680]
800094a6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800094aa:	fe ca bc 32 	sub	r10,pc,-17358
800094ae:	59 06       	cp.w	r6,16
800094b0:	fe 99 ff dd 	brgt	8000946a <_vfprintf_r+0x199e>
800094b4:	0c 09       	add	r9,r6
800094b6:	87 0a       	st.w	r3[0x0],r10
800094b8:	fb 49 06 90 	st.w	sp[1680],r9
800094bc:	2f f8       	sub	r8,-1
800094be:	87 16       	st.w	r3[0x4],r6
800094c0:	c5 39       	rjmp	80009766 <_vfprintf_r+0x1c9a>
800094c2:	fa fa 06 ac 	ld.w	r10,sp[1708]
800094c6:	58 0a       	cp.w	r10,0
800094c8:	e0 89 00 92 	brgt	800095ec <_vfprintf_r+0x1b20>
800094cc:	fa f8 06 90 	ld.w	r8,sp[1680]
800094d0:	fe c9 bc 6c 	sub	r9,pc,-17300
800094d4:	2f f8       	sub	r8,-1
800094d6:	87 09       	st.w	r3[0x0],r9
800094d8:	fb 48 06 90 	st.w	sp[1680],r8
800094dc:	30 19       	mov	r9,1
800094de:	fa f8 06 8c 	ld.w	r8,sp[1676]
800094e2:	87 19       	st.w	r3[0x4],r9
800094e4:	2f f8       	sub	r8,-1
800094e6:	fb 48 06 8c 	st.w	sp[1676],r8
800094ea:	58 78       	cp.w	r8,7
800094ec:	e0 89 00 04 	brgt	800094f4 <_vfprintf_r+0x1a28>
800094f0:	2f 83       	sub	r3,-8
800094f2:	c0 b8       	rjmp	80009508 <_vfprintf_r+0x1a3c>
800094f4:	fa ca f9 78 	sub	r10,sp,-1672
800094f8:	02 9b       	mov	r11,r1
800094fa:	08 9c       	mov	r12,r4
800094fc:	fe b0 f2 da 	rcall	80007ab0 <__sprint_r>
80009500:	e0 81 02 65 	brne	800099ca <_vfprintf_r+0x1efe>
80009504:	fa c3 f9 e0 	sub	r3,sp,-1568
80009508:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000950c:	58 08       	cp.w	r8,0
8000950e:	c0 81       	brne	8000951e <_vfprintf_r+0x1a52>
80009510:	40 6a       	lddsp	r10,sp[0x18]
80009512:	58 0a       	cp.w	r10,0
80009514:	c0 51       	brne	8000951e <_vfprintf_r+0x1a52>
80009516:	ed b5 00 00 	bld	r5,0x0
8000951a:	e0 81 01 ed 	brne	800098f4 <_vfprintf_r+0x1e28>
8000951e:	40 c9       	lddsp	r9,sp[0x30]
80009520:	fa f8 06 90 	ld.w	r8,sp[1680]
80009524:	2f f8       	sub	r8,-1
80009526:	87 09       	st.w	r3[0x0],r9
80009528:	fb 48 06 90 	st.w	sp[1680],r8
8000952c:	30 19       	mov	r9,1
8000952e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009532:	87 19       	st.w	r3[0x4],r9
80009534:	2f f8       	sub	r8,-1
80009536:	fb 48 06 8c 	st.w	sp[1676],r8
8000953a:	58 78       	cp.w	r8,7
8000953c:	e0 89 00 04 	brgt	80009544 <_vfprintf_r+0x1a78>
80009540:	2f 83       	sub	r3,-8
80009542:	c0 b8       	rjmp	80009558 <_vfprintf_r+0x1a8c>
80009544:	fa ca f9 78 	sub	r10,sp,-1672
80009548:	02 9b       	mov	r11,r1
8000954a:	08 9c       	mov	r12,r4
8000954c:	fe b0 f2 b2 	rcall	80007ab0 <__sprint_r>
80009550:	e0 81 02 3d 	brne	800099ca <_vfprintf_r+0x1efe>
80009554:	fa c3 f9 e0 	sub	r3,sp,-1568
80009558:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000955c:	5c 32       	neg	r2
8000955e:	58 02       	cp.w	r2,0
80009560:	e0 89 00 1d 	brgt	8000959a <_vfprintf_r+0x1ace>
80009564:	c3 d8       	rjmp	800095de <_vfprintf_r+0x1b12>
80009566:	2f 09       	sub	r9,-16
80009568:	2f f8       	sub	r8,-1
8000956a:	31 0e       	mov	lr,16
8000956c:	fb 49 06 90 	st.w	sp[1680],r9
80009570:	87 00       	st.w	r3[0x0],r0
80009572:	87 1e       	st.w	r3[0x4],lr
80009574:	fb 48 06 8c 	st.w	sp[1676],r8
80009578:	58 78       	cp.w	r8,7
8000957a:	e0 89 00 04 	brgt	80009582 <_vfprintf_r+0x1ab6>
8000957e:	2f 83       	sub	r3,-8
80009580:	c0 b8       	rjmp	80009596 <_vfprintf_r+0x1aca>
80009582:	fa ca f9 78 	sub	r10,sp,-1672
80009586:	02 9b       	mov	r11,r1
80009588:	08 9c       	mov	r12,r4
8000958a:	fe b0 f2 93 	rcall	80007ab0 <__sprint_r>
8000958e:	e0 81 02 1e 	brne	800099ca <_vfprintf_r+0x1efe>
80009592:	fa c3 f9 e0 	sub	r3,sp,-1568
80009596:	21 02       	sub	r2,16
80009598:	c0 38       	rjmp	8000959e <_vfprintf_r+0x1ad2>
8000959a:	fe c0 bd 22 	sub	r0,pc,-17118
8000959e:	fa f9 06 90 	ld.w	r9,sp[1680]
800095a2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800095a6:	fe ca bd 2e 	sub	r10,pc,-17106
800095aa:	59 02       	cp.w	r2,16
800095ac:	fe 99 ff dd 	brgt	80009566 <_vfprintf_r+0x1a9a>
800095b0:	04 09       	add	r9,r2
800095b2:	2f f8       	sub	r8,-1
800095b4:	87 0a       	st.w	r3[0x0],r10
800095b6:	fb 49 06 90 	st.w	sp[1680],r9
800095ba:	87 12       	st.w	r3[0x4],r2
800095bc:	fb 48 06 8c 	st.w	sp[1676],r8
800095c0:	58 78       	cp.w	r8,7
800095c2:	e0 89 00 04 	brgt	800095ca <_vfprintf_r+0x1afe>
800095c6:	2f 83       	sub	r3,-8
800095c8:	c0 b8       	rjmp	800095de <_vfprintf_r+0x1b12>
800095ca:	fa ca f9 78 	sub	r10,sp,-1672
800095ce:	02 9b       	mov	r11,r1
800095d0:	08 9c       	mov	r12,r4
800095d2:	fe b0 f2 6f 	rcall	80007ab0 <__sprint_r>
800095d6:	e0 81 01 fa 	brne	800099ca <_vfprintf_r+0x1efe>
800095da:	fa c3 f9 e0 	sub	r3,sp,-1568
800095de:	40 6c       	lddsp	r12,sp[0x18]
800095e0:	fa f8 06 90 	ld.w	r8,sp[1680]
800095e4:	87 06       	st.w	r3[0x0],r6
800095e6:	87 1c       	st.w	r3[0x4],r12
800095e8:	18 08       	add	r8,r12
800095ea:	cb 98       	rjmp	8000975c <_vfprintf_r+0x1c90>
800095ec:	fa f9 06 90 	ld.w	r9,sp[1680]
800095f0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800095f4:	40 6b       	lddsp	r11,sp[0x18]
800095f6:	16 3a       	cp.w	r10,r11
800095f8:	c6 f5       	brlt	800096d6 <_vfprintf_r+0x1c0a>
800095fa:	16 09       	add	r9,r11
800095fc:	2f f8       	sub	r8,-1
800095fe:	87 06       	st.w	r3[0x0],r6
80009600:	fb 49 06 90 	st.w	sp[1680],r9
80009604:	87 1b       	st.w	r3[0x4],r11
80009606:	fb 48 06 8c 	st.w	sp[1676],r8
8000960a:	58 78       	cp.w	r8,7
8000960c:	e0 89 00 04 	brgt	80009614 <_vfprintf_r+0x1b48>
80009610:	2f 83       	sub	r3,-8
80009612:	c0 b8       	rjmp	80009628 <_vfprintf_r+0x1b5c>
80009614:	fa ca f9 78 	sub	r10,sp,-1672
80009618:	02 9b       	mov	r11,r1
8000961a:	08 9c       	mov	r12,r4
8000961c:	fe b0 f2 4a 	rcall	80007ab0 <__sprint_r>
80009620:	e0 81 01 d5 	brne	800099ca <_vfprintf_r+0x1efe>
80009624:	fa c3 f9 e0 	sub	r3,sp,-1568
80009628:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000962c:	40 6a       	lddsp	r10,sp[0x18]
8000962e:	14 16       	sub	r6,r10
80009630:	58 06       	cp.w	r6,0
80009632:	e0 89 00 1c 	brgt	8000966a <_vfprintf_r+0x1b9e>
80009636:	c3 d8       	rjmp	800096b0 <_vfprintf_r+0x1be4>
80009638:	2f 09       	sub	r9,-16
8000963a:	2f f8       	sub	r8,-1
8000963c:	fb 49 06 90 	st.w	sp[1680],r9
80009640:	87 02       	st.w	r3[0x0],r2
80009642:	87 10       	st.w	r3[0x4],r0
80009644:	fb 48 06 8c 	st.w	sp[1676],r8
80009648:	58 78       	cp.w	r8,7
8000964a:	e0 89 00 04 	brgt	80009652 <_vfprintf_r+0x1b86>
8000964e:	2f 83       	sub	r3,-8
80009650:	c0 b8       	rjmp	80009666 <_vfprintf_r+0x1b9a>
80009652:	fa ca f9 78 	sub	r10,sp,-1672
80009656:	02 9b       	mov	r11,r1
80009658:	08 9c       	mov	r12,r4
8000965a:	fe b0 f2 2b 	rcall	80007ab0 <__sprint_r>
8000965e:	e0 81 01 b6 	brne	800099ca <_vfprintf_r+0x1efe>
80009662:	fa c3 f9 e0 	sub	r3,sp,-1568
80009666:	21 06       	sub	r6,16
80009668:	c0 48       	rjmp	80009670 <_vfprintf_r+0x1ba4>
8000966a:	fe c2 bd f2 	sub	r2,pc,-16910
8000966e:	31 00       	mov	r0,16
80009670:	fa f9 06 90 	ld.w	r9,sp[1680]
80009674:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009678:	fe ca be 00 	sub	r10,pc,-16896
8000967c:	59 06       	cp.w	r6,16
8000967e:	fe 99 ff dd 	brgt	80009638 <_vfprintf_r+0x1b6c>
80009682:	0c 09       	add	r9,r6
80009684:	2f f8       	sub	r8,-1
80009686:	87 0a       	st.w	r3[0x0],r10
80009688:	fb 49 06 90 	st.w	sp[1680],r9
8000968c:	87 16       	st.w	r3[0x4],r6
8000968e:	fb 48 06 8c 	st.w	sp[1676],r8
80009692:	58 78       	cp.w	r8,7
80009694:	e0 89 00 04 	brgt	8000969c <_vfprintf_r+0x1bd0>
80009698:	2f 83       	sub	r3,-8
8000969a:	c0 b8       	rjmp	800096b0 <_vfprintf_r+0x1be4>
8000969c:	fa ca f9 78 	sub	r10,sp,-1672
800096a0:	02 9b       	mov	r11,r1
800096a2:	08 9c       	mov	r12,r4
800096a4:	fe b0 f2 06 	rcall	80007ab0 <__sprint_r>
800096a8:	e0 81 01 91 	brne	800099ca <_vfprintf_r+0x1efe>
800096ac:	fa c3 f9 e0 	sub	r3,sp,-1568
800096b0:	ed b5 00 00 	bld	r5,0x0
800096b4:	e0 81 01 20 	brne	800098f4 <_vfprintf_r+0x1e28>
800096b8:	40 c9       	lddsp	r9,sp[0x30]
800096ba:	fa f8 06 90 	ld.w	r8,sp[1680]
800096be:	2f f8       	sub	r8,-1
800096c0:	87 09       	st.w	r3[0x0],r9
800096c2:	fb 48 06 90 	st.w	sp[1680],r8
800096c6:	30 19       	mov	r9,1
800096c8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096cc:	87 19       	st.w	r3[0x4],r9
800096ce:	2f f8       	sub	r8,-1
800096d0:	fb 48 06 8c 	st.w	sp[1676],r8
800096d4:	c0 29       	rjmp	800098d8 <_vfprintf_r+0x1e0c>
800096d6:	14 09       	add	r9,r10
800096d8:	2f f8       	sub	r8,-1
800096da:	fb 49 06 90 	st.w	sp[1680],r9
800096de:	87 06       	st.w	r3[0x0],r6
800096e0:	87 1a       	st.w	r3[0x4],r10
800096e2:	fb 48 06 8c 	st.w	sp[1676],r8
800096e6:	58 78       	cp.w	r8,7
800096e8:	e0 89 00 04 	brgt	800096f0 <_vfprintf_r+0x1c24>
800096ec:	2f 83       	sub	r3,-8
800096ee:	c0 b8       	rjmp	80009704 <_vfprintf_r+0x1c38>
800096f0:	fa ca f9 78 	sub	r10,sp,-1672
800096f4:	02 9b       	mov	r11,r1
800096f6:	08 9c       	mov	r12,r4
800096f8:	fe b0 f1 dc 	rcall	80007ab0 <__sprint_r>
800096fc:	e0 81 01 67 	brne	800099ca <_vfprintf_r+0x1efe>
80009700:	fa c3 f9 e0 	sub	r3,sp,-1568
80009704:	40 c8       	lddsp	r8,sp[0x30]
80009706:	87 08       	st.w	r3[0x0],r8
80009708:	fa f8 06 90 	ld.w	r8,sp[1680]
8000970c:	2f f8       	sub	r8,-1
8000970e:	30 19       	mov	r9,1
80009710:	fb 48 06 90 	st.w	sp[1680],r8
80009714:	87 19       	st.w	r3[0x4],r9
80009716:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000971a:	2f f8       	sub	r8,-1
8000971c:	fb 48 06 8c 	st.w	sp[1676],r8
80009720:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009724:	58 78       	cp.w	r8,7
80009726:	e0 89 00 04 	brgt	8000972e <_vfprintf_r+0x1c62>
8000972a:	2f 83       	sub	r3,-8
8000972c:	c0 b8       	rjmp	80009742 <_vfprintf_r+0x1c76>
8000972e:	fa ca f9 78 	sub	r10,sp,-1672
80009732:	02 9b       	mov	r11,r1
80009734:	08 9c       	mov	r12,r4
80009736:	fe b0 f1 bd 	rcall	80007ab0 <__sprint_r>
8000973a:	e0 81 01 48 	brne	800099ca <_vfprintf_r+0x1efe>
8000973e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009742:	04 06       	add	r6,r2
80009744:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009748:	87 06       	st.w	r3[0x0],r6
8000974a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000974e:	40 66       	lddsp	r6,sp[0x18]
80009750:	40 6e       	lddsp	lr,sp[0x18]
80009752:	10 16       	sub	r6,r8
80009754:	f2 08 01 08 	sub	r8,r9,r8
80009758:	87 16       	st.w	r3[0x4],r6
8000975a:	1c 08       	add	r8,lr
8000975c:	fb 48 06 90 	st.w	sp[1680],r8
80009760:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009764:	2f f8       	sub	r8,-1
80009766:	fb 48 06 8c 	st.w	sp[1676],r8
8000976a:	cb 78       	rjmp	800098d8 <_vfprintf_r+0x1e0c>
8000976c:	40 6c       	lddsp	r12,sp[0x18]
8000976e:	58 1c       	cp.w	r12,1
80009770:	e0 89 00 06 	brgt	8000977c <_vfprintf_r+0x1cb0>
80009774:	ed b5 00 00 	bld	r5,0x0
80009778:	e0 81 00 85 	brne	80009882 <_vfprintf_r+0x1db6>
8000977c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009780:	2f f8       	sub	r8,-1
80009782:	30 19       	mov	r9,1
80009784:	fb 48 06 90 	st.w	sp[1680],r8
80009788:	87 06       	st.w	r3[0x0],r6
8000978a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000978e:	87 19       	st.w	r3[0x4],r9
80009790:	2f f8       	sub	r8,-1
80009792:	fb 48 06 8c 	st.w	sp[1676],r8
80009796:	58 78       	cp.w	r8,7
80009798:	e0 89 00 04 	brgt	800097a0 <_vfprintf_r+0x1cd4>
8000979c:	2f 83       	sub	r3,-8
8000979e:	c0 b8       	rjmp	800097b4 <_vfprintf_r+0x1ce8>
800097a0:	fa ca f9 78 	sub	r10,sp,-1672
800097a4:	02 9b       	mov	r11,r1
800097a6:	08 9c       	mov	r12,r4
800097a8:	fe b0 f1 84 	rcall	80007ab0 <__sprint_r>
800097ac:	e0 81 01 0f 	brne	800099ca <_vfprintf_r+0x1efe>
800097b0:	fa c3 f9 e0 	sub	r3,sp,-1568
800097b4:	fa f8 06 90 	ld.w	r8,sp[1680]
800097b8:	2f f8       	sub	r8,-1
800097ba:	40 cb       	lddsp	r11,sp[0x30]
800097bc:	fb 48 06 90 	st.w	sp[1680],r8
800097c0:	30 19       	mov	r9,1
800097c2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097c6:	87 0b       	st.w	r3[0x0],r11
800097c8:	2f f8       	sub	r8,-1
800097ca:	87 19       	st.w	r3[0x4],r9
800097cc:	fb 48 06 8c 	st.w	sp[1676],r8
800097d0:	58 78       	cp.w	r8,7
800097d2:	e0 89 00 05 	brgt	800097dc <_vfprintf_r+0x1d10>
800097d6:	2f 83       	sub	r3,-8
800097d8:	c0 c8       	rjmp	800097f0 <_vfprintf_r+0x1d24>
800097da:	d7 03       	nop
800097dc:	fa ca f9 78 	sub	r10,sp,-1672
800097e0:	02 9b       	mov	r11,r1
800097e2:	08 9c       	mov	r12,r4
800097e4:	fe b0 f1 66 	rcall	80007ab0 <__sprint_r>
800097e8:	e0 81 00 f1 	brne	800099ca <_vfprintf_r+0x1efe>
800097ec:	fa c3 f9 e0 	sub	r3,sp,-1568
800097f0:	30 08       	mov	r8,0
800097f2:	30 09       	mov	r9,0
800097f4:	40 5b       	lddsp	r11,sp[0x14]
800097f6:	40 7a       	lddsp	r10,sp[0x1c]
800097f8:	e0 a0 13 25 	rcall	8000be42 <__avr32_f64_cmp_eq>
800097fc:	40 68       	lddsp	r8,sp[0x18]
800097fe:	20 18       	sub	r8,1
80009800:	58 0c       	cp.w	r12,0
80009802:	c0 d1       	brne	8000981c <_vfprintf_r+0x1d50>
80009804:	2f f6       	sub	r6,-1
80009806:	87 18       	st.w	r3[0x4],r8
80009808:	87 06       	st.w	r3[0x0],r6
8000980a:	fa f6 06 90 	ld.w	r6,sp[1680]
8000980e:	10 06       	add	r6,r8
80009810:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009814:	fb 46 06 90 	st.w	sp[1680],r6
80009818:	2f f8       	sub	r8,-1
8000981a:	c3 18       	rjmp	8000987c <_vfprintf_r+0x1db0>
8000981c:	10 96       	mov	r6,r8
8000981e:	58 08       	cp.w	r8,0
80009820:	e0 89 00 1c 	brgt	80009858 <_vfprintf_r+0x1d8c>
80009824:	c4 b8       	rjmp	800098ba <_vfprintf_r+0x1dee>
80009826:	2f 09       	sub	r9,-16
80009828:	2f f8       	sub	r8,-1
8000982a:	fb 49 06 90 	st.w	sp[1680],r9
8000982e:	87 02       	st.w	r3[0x0],r2
80009830:	87 10       	st.w	r3[0x4],r0
80009832:	fb 48 06 8c 	st.w	sp[1676],r8
80009836:	58 78       	cp.w	r8,7
80009838:	e0 89 00 04 	brgt	80009840 <_vfprintf_r+0x1d74>
8000983c:	2f 83       	sub	r3,-8
8000983e:	c0 b8       	rjmp	80009854 <_vfprintf_r+0x1d88>
80009840:	fa ca f9 78 	sub	r10,sp,-1672
80009844:	02 9b       	mov	r11,r1
80009846:	08 9c       	mov	r12,r4
80009848:	fe b0 f1 34 	rcall	80007ab0 <__sprint_r>
8000984c:	e0 81 00 bf 	brne	800099ca <_vfprintf_r+0x1efe>
80009850:	fa c3 f9 e0 	sub	r3,sp,-1568
80009854:	21 06       	sub	r6,16
80009856:	c0 48       	rjmp	8000985e <_vfprintf_r+0x1d92>
80009858:	fe c2 bf e0 	sub	r2,pc,-16416
8000985c:	31 00       	mov	r0,16
8000985e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009862:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009866:	fe ca bf ee 	sub	r10,pc,-16402
8000986a:	59 06       	cp.w	r6,16
8000986c:	fe 99 ff dd 	brgt	80009826 <_vfprintf_r+0x1d5a>
80009870:	0c 09       	add	r9,r6
80009872:	87 0a       	st.w	r3[0x0],r10
80009874:	fb 49 06 90 	st.w	sp[1680],r9
80009878:	2f f8       	sub	r8,-1
8000987a:	87 16       	st.w	r3[0x4],r6
8000987c:	fb 48 06 8c 	st.w	sp[1676],r8
80009880:	c0 e8       	rjmp	8000989c <_vfprintf_r+0x1dd0>
80009882:	fa f8 06 90 	ld.w	r8,sp[1680]
80009886:	2f f8       	sub	r8,-1
80009888:	30 19       	mov	r9,1
8000988a:	fb 48 06 90 	st.w	sp[1680],r8
8000988e:	87 06       	st.w	r3[0x0],r6
80009890:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009894:	87 19       	st.w	r3[0x4],r9
80009896:	2f f8       	sub	r8,-1
80009898:	fb 48 06 8c 	st.w	sp[1676],r8
8000989c:	58 78       	cp.w	r8,7
8000989e:	e0 89 00 04 	brgt	800098a6 <_vfprintf_r+0x1dda>
800098a2:	2f 83       	sub	r3,-8
800098a4:	c0 b8       	rjmp	800098ba <_vfprintf_r+0x1dee>
800098a6:	fa ca f9 78 	sub	r10,sp,-1672
800098aa:	02 9b       	mov	r11,r1
800098ac:	08 9c       	mov	r12,r4
800098ae:	fe b0 f1 01 	rcall	80007ab0 <__sprint_r>
800098b2:	e0 81 00 8c 	brne	800099ca <_vfprintf_r+0x1efe>
800098b6:	fa c3 f9 e0 	sub	r3,sp,-1568
800098ba:	40 ea       	lddsp	r10,sp[0x38]
800098bc:	fa f8 06 90 	ld.w	r8,sp[1680]
800098c0:	14 08       	add	r8,r10
800098c2:	fa c9 f9 64 	sub	r9,sp,-1692
800098c6:	fb 48 06 90 	st.w	sp[1680],r8
800098ca:	87 1a       	st.w	r3[0x4],r10
800098cc:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098d0:	87 09       	st.w	r3[0x0],r9
800098d2:	2f f8       	sub	r8,-1
800098d4:	fb 48 06 8c 	st.w	sp[1676],r8
800098d8:	58 78       	cp.w	r8,7
800098da:	e0 89 00 04 	brgt	800098e2 <_vfprintf_r+0x1e16>
800098de:	2f 83       	sub	r3,-8
800098e0:	c0 a8       	rjmp	800098f4 <_vfprintf_r+0x1e28>
800098e2:	fa ca f9 78 	sub	r10,sp,-1672
800098e6:	02 9b       	mov	r11,r1
800098e8:	08 9c       	mov	r12,r4
800098ea:	fe b0 f0 e3 	rcall	80007ab0 <__sprint_r>
800098ee:	c6 e1       	brne	800099ca <_vfprintf_r+0x1efe>
800098f0:	fa c3 f9 e0 	sub	r3,sp,-1568
800098f4:	e2 15 00 04 	andl	r5,0x4,COH
800098f8:	c3 f0       	breq	80009976 <_vfprintf_r+0x1eaa>
800098fa:	40 86       	lddsp	r6,sp[0x20]
800098fc:	40 39       	lddsp	r9,sp[0xc]
800098fe:	12 16       	sub	r6,r9
80009900:	58 06       	cp.w	r6,0
80009902:	e0 89 00 1a 	brgt	80009936 <_vfprintf_r+0x1e6a>
80009906:	c3 88       	rjmp	80009976 <_vfprintf_r+0x1eaa>
80009908:	2f 09       	sub	r9,-16
8000990a:	2f f8       	sub	r8,-1
8000990c:	fb 49 06 90 	st.w	sp[1680],r9
80009910:	87 05       	st.w	r3[0x0],r5
80009912:	87 12       	st.w	r3[0x4],r2
80009914:	fb 48 06 8c 	st.w	sp[1676],r8
80009918:	58 78       	cp.w	r8,7
8000991a:	e0 89 00 04 	brgt	80009922 <_vfprintf_r+0x1e56>
8000991e:	2f 83       	sub	r3,-8
80009920:	c0 98       	rjmp	80009932 <_vfprintf_r+0x1e66>
80009922:	00 9a       	mov	r10,r0
80009924:	02 9b       	mov	r11,r1
80009926:	08 9c       	mov	r12,r4
80009928:	fe b0 f0 c4 	rcall	80007ab0 <__sprint_r>
8000992c:	c4 f1       	brne	800099ca <_vfprintf_r+0x1efe>
8000992e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009932:	21 06       	sub	r6,16
80009934:	c0 68       	rjmp	80009940 <_vfprintf_r+0x1e74>
80009936:	fe c5 c0 ce 	sub	r5,pc,-16178
8000993a:	31 02       	mov	r2,16
8000993c:	fa c0 f9 78 	sub	r0,sp,-1672
80009940:	fa f9 06 90 	ld.w	r9,sp[1680]
80009944:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009948:	fe ca c0 e0 	sub	r10,pc,-16160
8000994c:	59 06       	cp.w	r6,16
8000994e:	fe 99 ff dd 	brgt	80009908 <_vfprintf_r+0x1e3c>
80009952:	0c 09       	add	r9,r6
80009954:	2f f8       	sub	r8,-1
80009956:	87 0a       	st.w	r3[0x0],r10
80009958:	87 16       	st.w	r3[0x4],r6
8000995a:	fb 49 06 90 	st.w	sp[1680],r9
8000995e:	fb 48 06 8c 	st.w	sp[1676],r8
80009962:	58 78       	cp.w	r8,7
80009964:	e0 8a 00 09 	brle	80009976 <_vfprintf_r+0x1eaa>
80009968:	fa ca f9 78 	sub	r10,sp,-1672
8000996c:	02 9b       	mov	r11,r1
8000996e:	08 9c       	mov	r12,r4
80009970:	fe b0 f0 a0 	rcall	80007ab0 <__sprint_r>
80009974:	c2 b1       	brne	800099ca <_vfprintf_r+0x1efe>
80009976:	40 bc       	lddsp	r12,sp[0x2c]
80009978:	40 36       	lddsp	r6,sp[0xc]
8000997a:	40 8e       	lddsp	lr,sp[0x20]
8000997c:	ec 0e 0c 48 	max	r8,r6,lr
80009980:	10 0c       	add	r12,r8
80009982:	50 bc       	stdsp	sp[0x2c],r12
80009984:	fa f8 06 90 	ld.w	r8,sp[1680]
80009988:	58 08       	cp.w	r8,0
8000998a:	c0 80       	breq	8000999a <_vfprintf_r+0x1ece>
8000998c:	fa ca f9 78 	sub	r10,sp,-1672
80009990:	02 9b       	mov	r11,r1
80009992:	08 9c       	mov	r12,r4
80009994:	fe b0 f0 8e 	rcall	80007ab0 <__sprint_r>
80009998:	c1 91       	brne	800099ca <_vfprintf_r+0x1efe>
8000999a:	30 0b       	mov	r11,0
8000999c:	fa c3 f9 e0 	sub	r3,sp,-1568
800099a0:	fb 4b 06 8c 	st.w	sp[1676],r11
800099a4:	fe 9f f1 22 	bral	80007be8 <_vfprintf_r+0x11c>
800099a8:	08 95       	mov	r5,r4
800099aa:	fa f8 06 90 	ld.w	r8,sp[1680]
800099ae:	58 08       	cp.w	r8,0
800099b0:	c0 80       	breq	800099c0 <_vfprintf_r+0x1ef4>
800099b2:	08 9c       	mov	r12,r4
800099b4:	fa ca f9 78 	sub	r10,sp,-1672
800099b8:	02 9b       	mov	r11,r1
800099ba:	fe b0 f0 7b 	rcall	80007ab0 <__sprint_r>
800099be:	c0 61       	brne	800099ca <_vfprintf_r+0x1efe>
800099c0:	30 08       	mov	r8,0
800099c2:	fb 48 06 8c 	st.w	sp[1676],r8
800099c6:	c0 28       	rjmp	800099ca <_vfprintf_r+0x1efe>
800099c8:	40 41       	lddsp	r1,sp[0x10]
800099ca:	82 68       	ld.sh	r8,r1[0xc]
800099cc:	ed b8 00 06 	bld	r8,0x6
800099d0:	c0 31       	brne	800099d6 <_vfprintf_r+0x1f0a>
800099d2:	3f fa       	mov	r10,-1
800099d4:	50 ba       	stdsp	sp[0x2c],r10
800099d6:	40 bc       	lddsp	r12,sp[0x2c]
800099d8:	fe 3d f9 44 	sub	sp,-1724
800099dc:	d8 32       	popm	r0-r7,pc
800099de:	d7 03       	nop

800099e0 <__swsetup_r>:
800099e0:	d4 21       	pushm	r4-r7,lr
800099e2:	e0 68 0a 38 	mov	r8,2616
800099e6:	18 96       	mov	r6,r12
800099e8:	16 97       	mov	r7,r11
800099ea:	70 0c       	ld.w	r12,r8[0x0]
800099ec:	58 0c       	cp.w	r12,0
800099ee:	c0 60       	breq	800099fa <__swsetup_r+0x1a>
800099f0:	78 68       	ld.w	r8,r12[0x18]
800099f2:	58 08       	cp.w	r8,0
800099f4:	c0 31       	brne	800099fa <__swsetup_r+0x1a>
800099f6:	e0 a0 07 bf 	rcall	8000a974 <__sinit>
800099fa:	fe c8 c0 62 	sub	r8,pc,-16286
800099fe:	10 37       	cp.w	r7,r8
80009a00:	c0 61       	brne	80009a0c <__swsetup_r+0x2c>
80009a02:	e0 68 0a 38 	mov	r8,2616
80009a06:	70 08       	ld.w	r8,r8[0x0]
80009a08:	70 07       	ld.w	r7,r8[0x0]
80009a0a:	c1 28       	rjmp	80009a2e <__swsetup_r+0x4e>
80009a0c:	fe c8 c0 54 	sub	r8,pc,-16300
80009a10:	10 37       	cp.w	r7,r8
80009a12:	c0 61       	brne	80009a1e <__swsetup_r+0x3e>
80009a14:	e0 68 0a 38 	mov	r8,2616
80009a18:	70 08       	ld.w	r8,r8[0x0]
80009a1a:	70 17       	ld.w	r7,r8[0x4]
80009a1c:	c0 98       	rjmp	80009a2e <__swsetup_r+0x4e>
80009a1e:	fe c8 c0 46 	sub	r8,pc,-16314
80009a22:	10 37       	cp.w	r7,r8
80009a24:	c0 51       	brne	80009a2e <__swsetup_r+0x4e>
80009a26:	e0 68 0a 38 	mov	r8,2616
80009a2a:	70 08       	ld.w	r8,r8[0x0]
80009a2c:	70 27       	ld.w	r7,r8[0x8]
80009a2e:	8e 68       	ld.sh	r8,r7[0xc]
80009a30:	ed b8 00 03 	bld	r8,0x3
80009a34:	c1 e0       	breq	80009a70 <__swsetup_r+0x90>
80009a36:	ed b8 00 04 	bld	r8,0x4
80009a3a:	c3 e1       	brne	80009ab6 <__swsetup_r+0xd6>
80009a3c:	ed b8 00 02 	bld	r8,0x2
80009a40:	c1 51       	brne	80009a6a <__swsetup_r+0x8a>
80009a42:	6e db       	ld.w	r11,r7[0x34]
80009a44:	58 0b       	cp.w	r11,0
80009a46:	c0 a0       	breq	80009a5a <__swsetup_r+0x7a>
80009a48:	ee c8 ff bc 	sub	r8,r7,-68
80009a4c:	10 3b       	cp.w	r11,r8
80009a4e:	c0 40       	breq	80009a56 <__swsetup_r+0x76>
80009a50:	0c 9c       	mov	r12,r6
80009a52:	e0 a0 08 2b 	rcall	8000aaa8 <_free_r>
80009a56:	30 08       	mov	r8,0
80009a58:	8f d8       	st.w	r7[0x34],r8
80009a5a:	8e 68       	ld.sh	r8,r7[0xc]
80009a5c:	e0 18 ff db 	andl	r8,0xffdb
80009a60:	ae 68       	st.h	r7[0xc],r8
80009a62:	30 08       	mov	r8,0
80009a64:	8f 18       	st.w	r7[0x4],r8
80009a66:	6e 48       	ld.w	r8,r7[0x10]
80009a68:	8f 08       	st.w	r7[0x0],r8
80009a6a:	8e 68       	ld.sh	r8,r7[0xc]
80009a6c:	a3 b8       	sbr	r8,0x3
80009a6e:	ae 68       	st.h	r7[0xc],r8
80009a70:	6e 48       	ld.w	r8,r7[0x10]
80009a72:	58 08       	cp.w	r8,0
80009a74:	c0 b1       	brne	80009a8a <__swsetup_r+0xaa>
80009a76:	8e 68       	ld.sh	r8,r7[0xc]
80009a78:	e2 18 02 80 	andl	r8,0x280,COH
80009a7c:	e0 48 02 00 	cp.w	r8,512
80009a80:	c0 50       	breq	80009a8a <__swsetup_r+0xaa>
80009a82:	0c 9c       	mov	r12,r6
80009a84:	0e 9b       	mov	r11,r7
80009a86:	e0 a0 0a 4b 	rcall	8000af1c <__smakebuf_r>
80009a8a:	8e 69       	ld.sh	r9,r7[0xc]
80009a8c:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009a90:	c0 70       	breq	80009a9e <__swsetup_r+0xbe>
80009a92:	30 08       	mov	r8,0
80009a94:	8f 28       	st.w	r7[0x8],r8
80009a96:	6e 58       	ld.w	r8,r7[0x14]
80009a98:	5c 38       	neg	r8
80009a9a:	8f 68       	st.w	r7[0x18],r8
80009a9c:	c0 68       	rjmp	80009aa8 <__swsetup_r+0xc8>
80009a9e:	ed b9 00 01 	bld	r9,0x1
80009aa2:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009aa6:	8f 28       	st.w	r7[0x8],r8
80009aa8:	6e 48       	ld.w	r8,r7[0x10]
80009aaa:	58 08       	cp.w	r8,0
80009aac:	c0 61       	brne	80009ab8 <__swsetup_r+0xd8>
80009aae:	8e 68       	ld.sh	r8,r7[0xc]
80009ab0:	ed b8 00 07 	bld	r8,0x7
80009ab4:	c0 21       	brne	80009ab8 <__swsetup_r+0xd8>
80009ab6:	dc 2a       	popm	r4-r7,pc,r12=-1
80009ab8:	d8 2a       	popm	r4-r7,pc,r12=0
80009aba:	d7 03       	nop

80009abc <quorem>:
80009abc:	d4 31       	pushm	r0-r7,lr
80009abe:	20 2d       	sub	sp,8
80009ac0:	18 97       	mov	r7,r12
80009ac2:	78 48       	ld.w	r8,r12[0x10]
80009ac4:	76 46       	ld.w	r6,r11[0x10]
80009ac6:	0c 38       	cp.w	r8,r6
80009ac8:	c0 34       	brge	80009ace <quorem+0x12>
80009aca:	30 0c       	mov	r12,0
80009acc:	c8 58       	rjmp	80009bd6 <quorem+0x11a>
80009ace:	ec c2 ff fc 	sub	r2,r6,-4
80009ad2:	f6 c3 ff ec 	sub	r3,r11,-20
80009ad6:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80009ada:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009ade:	2f f9       	sub	r9,-1
80009ae0:	20 16       	sub	r6,1
80009ae2:	f8 09 0d 08 	divu	r8,r12,r9
80009ae6:	f6 02 00 22 	add	r2,r11,r2<<0x2
80009aea:	ee c4 ff ec 	sub	r4,r7,-20
80009aee:	10 95       	mov	r5,r8
80009af0:	58 08       	cp.w	r8,0
80009af2:	c4 10       	breq	80009b74 <quorem+0xb8>
80009af4:	30 09       	mov	r9,0
80009af6:	06 9a       	mov	r10,r3
80009af8:	08 98       	mov	r8,r4
80009afa:	12 91       	mov	r1,r9
80009afc:	50 0b       	stdsp	sp[0x0],r11
80009afe:	70 0e       	ld.w	lr,r8[0x0]
80009b00:	b1 8e       	lsr	lr,0x10
80009b02:	50 1e       	stdsp	sp[0x4],lr
80009b04:	15 0e       	ld.w	lr,r10++
80009b06:	fc 00 16 10 	lsr	r0,lr,0x10
80009b0a:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80009b0e:	ea 0e 03 41 	mac	r1,r5,lr
80009b12:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80009b16:	b1 81       	lsr	r1,0x10
80009b18:	40 1b       	lddsp	r11,sp[0x4]
80009b1a:	ea 00 02 40 	mul	r0,r5,r0
80009b1e:	e2 00 00 00 	add	r0,r1,r0
80009b22:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80009b26:	02 1b       	sub	r11,r1
80009b28:	50 1b       	stdsp	sp[0x4],r11
80009b2a:	70 0b       	ld.w	r11,r8[0x0]
80009b2c:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009b30:	02 09       	add	r9,r1
80009b32:	f2 0e 01 0e 	sub	lr,r9,lr
80009b36:	b0 1e       	st.h	r8[0x2],lr
80009b38:	fc 09 14 10 	asr	r9,lr,0x10
80009b3c:	40 1e       	lddsp	lr,sp[0x4]
80009b3e:	fc 09 00 09 	add	r9,lr,r9
80009b42:	b0 09       	st.h	r8[0x0],r9
80009b44:	e0 01 16 10 	lsr	r1,r0,0x10
80009b48:	2f c8       	sub	r8,-4
80009b4a:	b1 49       	asr	r9,0x10
80009b4c:	04 3a       	cp.w	r10,r2
80009b4e:	fe 98 ff d8 	brls	80009afe <quorem+0x42>
80009b52:	40 0b       	lddsp	r11,sp[0x0]
80009b54:	58 0c       	cp.w	r12,0
80009b56:	c0 f1       	brne	80009b74 <quorem+0xb8>
80009b58:	ec c8 ff fb 	sub	r8,r6,-5
80009b5c:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009b60:	c0 28       	rjmp	80009b64 <quorem+0xa8>
80009b62:	20 16       	sub	r6,1
80009b64:	20 48       	sub	r8,4
80009b66:	08 38       	cp.w	r8,r4
80009b68:	e0 88 00 05 	brls	80009b72 <quorem+0xb6>
80009b6c:	70 09       	ld.w	r9,r8[0x0]
80009b6e:	58 09       	cp.w	r9,0
80009b70:	cf 90       	breq	80009b62 <quorem+0xa6>
80009b72:	8f 46       	st.w	r7[0x10],r6
80009b74:	0e 9c       	mov	r12,r7
80009b76:	e0 a0 0a d2 	rcall	8000b11a <__mcmp>
80009b7a:	c2 d5       	brlt	80009bd4 <quorem+0x118>
80009b7c:	2f f5       	sub	r5,-1
80009b7e:	08 98       	mov	r8,r4
80009b80:	30 09       	mov	r9,0
80009b82:	07 0b       	ld.w	r11,r3++
80009b84:	f6 0a 16 10 	lsr	r10,r11,0x10
80009b88:	70 0c       	ld.w	r12,r8[0x0]
80009b8a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009b8e:	f8 0e 16 10 	lsr	lr,r12,0x10
80009b92:	14 1e       	sub	lr,r10
80009b94:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009b98:	16 1a       	sub	r10,r11
80009b9a:	12 0a       	add	r10,r9
80009b9c:	b0 1a       	st.h	r8[0x2],r10
80009b9e:	b1 4a       	asr	r10,0x10
80009ba0:	fc 0a 00 09 	add	r9,lr,r10
80009ba4:	b0 09       	st.h	r8[0x0],r9
80009ba6:	2f c8       	sub	r8,-4
80009ba8:	b1 49       	asr	r9,0x10
80009baa:	04 33       	cp.w	r3,r2
80009bac:	fe 98 ff eb 	brls	80009b82 <quorem+0xc6>
80009bb0:	ec c8 ff fb 	sub	r8,r6,-5
80009bb4:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80009bb8:	58 09       	cp.w	r9,0
80009bba:	c0 d1       	brne	80009bd4 <quorem+0x118>
80009bbc:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009bc0:	c0 28       	rjmp	80009bc4 <quorem+0x108>
80009bc2:	20 16       	sub	r6,1
80009bc4:	20 48       	sub	r8,4
80009bc6:	08 38       	cp.w	r8,r4
80009bc8:	e0 88 00 05 	brls	80009bd2 <quorem+0x116>
80009bcc:	70 09       	ld.w	r9,r8[0x0]
80009bce:	58 09       	cp.w	r9,0
80009bd0:	cf 90       	breq	80009bc2 <quorem+0x106>
80009bd2:	8f 46       	st.w	r7[0x10],r6
80009bd4:	0a 9c       	mov	r12,r5
80009bd6:	2f ed       	sub	sp,-8
80009bd8:	d8 32       	popm	r0-r7,pc
80009bda:	d7 03       	nop

80009bdc <_dtoa_r>:
80009bdc:	d4 31       	pushm	r0-r7,lr
80009bde:	21 ad       	sub	sp,104
80009be0:	fa c4 ff 74 	sub	r4,sp,-140
80009be4:	18 97       	mov	r7,r12
80009be6:	16 95       	mov	r5,r11
80009be8:	68 2c       	ld.w	r12,r4[0x8]
80009bea:	50 c9       	stdsp	sp[0x30],r9
80009bec:	68 16       	ld.w	r6,r4[0x4]
80009bee:	68 09       	ld.w	r9,r4[0x0]
80009bf0:	50 e8       	stdsp	sp[0x38],r8
80009bf2:	14 94       	mov	r4,r10
80009bf4:	51 2c       	stdsp	sp[0x48],r12
80009bf6:	fa e5 00 08 	st.d	sp[8],r4
80009bfa:	51 59       	stdsp	sp[0x54],r9
80009bfc:	6e 95       	ld.w	r5,r7[0x24]
80009bfe:	58 05       	cp.w	r5,0
80009c00:	c0 91       	brne	80009c12 <_dtoa_r+0x36>
80009c02:	31 0c       	mov	r12,16
80009c04:	fe b0 e8 f4 	rcall	80006dec <malloc>
80009c08:	99 35       	st.w	r12[0xc],r5
80009c0a:	8f 9c       	st.w	r7[0x24],r12
80009c0c:	99 15       	st.w	r12[0x4],r5
80009c0e:	99 25       	st.w	r12[0x8],r5
80009c10:	99 05       	st.w	r12[0x0],r5
80009c12:	6e 99       	ld.w	r9,r7[0x24]
80009c14:	72 08       	ld.w	r8,r9[0x0]
80009c16:	58 08       	cp.w	r8,0
80009c18:	c0 f0       	breq	80009c36 <_dtoa_r+0x5a>
80009c1a:	72 1a       	ld.w	r10,r9[0x4]
80009c1c:	91 1a       	st.w	r8[0x4],r10
80009c1e:	30 1a       	mov	r10,1
80009c20:	72 19       	ld.w	r9,r9[0x4]
80009c22:	f4 09 09 49 	lsl	r9,r10,r9
80009c26:	10 9b       	mov	r11,r8
80009c28:	91 29       	st.w	r8[0x8],r9
80009c2a:	0e 9c       	mov	r12,r7
80009c2c:	e0 a0 0a 90 	rcall	8000b14c <_Bfree>
80009c30:	6e 98       	ld.w	r8,r7[0x24]
80009c32:	30 09       	mov	r9,0
80009c34:	91 09       	st.w	r8[0x0],r9
80009c36:	40 28       	lddsp	r8,sp[0x8]
80009c38:	10 94       	mov	r4,r8
80009c3a:	58 08       	cp.w	r8,0
80009c3c:	c0 64       	brge	80009c48 <_dtoa_r+0x6c>
80009c3e:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009c42:	50 28       	stdsp	sp[0x8],r8
80009c44:	30 18       	mov	r8,1
80009c46:	c0 28       	rjmp	80009c4a <_dtoa_r+0x6e>
80009c48:	30 08       	mov	r8,0
80009c4a:	8d 08       	st.w	r6[0x0],r8
80009c4c:	fc 1c 7f f0 	movh	r12,0x7ff0
80009c50:	40 26       	lddsp	r6,sp[0x8]
80009c52:	0c 98       	mov	r8,r6
80009c54:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009c58:	18 38       	cp.w	r8,r12
80009c5a:	c2 01       	brne	80009c9a <_dtoa_r+0xbe>
80009c5c:	e0 68 27 0f 	mov	r8,9999
80009c60:	41 5b       	lddsp	r11,sp[0x54]
80009c62:	97 08       	st.w	r11[0x0],r8
80009c64:	40 3a       	lddsp	r10,sp[0xc]
80009c66:	58 0a       	cp.w	r10,0
80009c68:	c0 71       	brne	80009c76 <_dtoa_r+0x9a>
80009c6a:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009c6e:	c0 41       	brne	80009c76 <_dtoa_r+0x9a>
80009c70:	fe cc c2 e8 	sub	r12,pc,-15640
80009c74:	c0 38       	rjmp	80009c7a <_dtoa_r+0x9e>
80009c76:	fe cc c2 e2 	sub	r12,pc,-15646
80009c7a:	41 29       	lddsp	r9,sp[0x48]
80009c7c:	58 09       	cp.w	r9,0
80009c7e:	e0 80 05 9a 	breq	8000a7b2 <_dtoa_r+0xbd6>
80009c82:	f8 c8 ff fd 	sub	r8,r12,-3
80009c86:	f8 c9 ff f8 	sub	r9,r12,-8
80009c8a:	11 8b       	ld.ub	r11,r8[0x0]
80009c8c:	30 0a       	mov	r10,0
80009c8e:	41 25       	lddsp	r5,sp[0x48]
80009c90:	f4 0b 18 00 	cp.b	r11,r10
80009c94:	f2 08 17 10 	movne	r8,r9
80009c98:	c1 68       	rjmp	80009cc4 <_dtoa_r+0xe8>
80009c9a:	fa ea 00 08 	ld.d	r10,sp[8]
80009c9e:	30 08       	mov	r8,0
80009ca0:	fa eb 00 3c 	st.d	sp[60],r10
80009ca4:	30 09       	mov	r9,0
80009ca6:	e0 a0 10 ce 	rcall	8000be42 <__avr32_f64_cmp_eq>
80009caa:	c1 00       	breq	80009cca <_dtoa_r+0xee>
80009cac:	30 18       	mov	r8,1
80009cae:	41 5a       	lddsp	r10,sp[0x54]
80009cb0:	95 08       	st.w	r10[0x0],r8
80009cb2:	fe cc c4 4e 	sub	r12,pc,-15282
80009cb6:	41 29       	lddsp	r9,sp[0x48]
80009cb8:	f8 08 00 08 	add	r8,r12,r8
80009cbc:	58 09       	cp.w	r9,0
80009cbe:	e0 80 05 7a 	breq	8000a7b2 <_dtoa_r+0xbd6>
80009cc2:	12 95       	mov	r5,r9
80009cc4:	8b 08       	st.w	r5[0x0],r8
80009cc6:	e0 8f 05 76 	bral	8000a7b2 <_dtoa_r+0xbd6>
80009cca:	fa c8 ff 9c 	sub	r8,sp,-100
80009cce:	fa c9 ff a0 	sub	r9,sp,-96
80009cd2:	fa ea 00 3c 	ld.d	r10,sp[60]
80009cd6:	0e 9c       	mov	r12,r7
80009cd8:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80009cdc:	e0 a0 0a 8a 	rcall	8000b1f0 <__d2b>
80009ce0:	18 93       	mov	r3,r12
80009ce2:	58 05       	cp.w	r5,0
80009ce4:	c0 d0       	breq	80009cfe <_dtoa_r+0x122>
80009ce6:	fa ea 00 3c 	ld.d	r10,sp[60]
80009cea:	30 04       	mov	r4,0
80009cec:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80009cf0:	ea c5 03 ff 	sub	r5,r5,1023
80009cf4:	10 9b       	mov	r11,r8
80009cf6:	51 74       	stdsp	sp[0x5c],r4
80009cf8:	ea 1b 3f f0 	orh	r11,0x3ff0
80009cfc:	c2 58       	rjmp	80009d46 <_dtoa_r+0x16a>
80009cfe:	41 88       	lddsp	r8,sp[0x60]
80009d00:	41 9c       	lddsp	r12,sp[0x64]
80009d02:	10 0c       	add	r12,r8
80009d04:	f8 c5 fb ce 	sub	r5,r12,-1074
80009d08:	e0 45 00 20 	cp.w	r5,32
80009d0c:	e0 8a 00 0e 	brle	80009d28 <_dtoa_r+0x14c>
80009d10:	f8 cc fb ee 	sub	r12,r12,-1042
80009d14:	40 3b       	lddsp	r11,sp[0xc]
80009d16:	ea 08 11 40 	rsub	r8,r5,64
80009d1a:	f6 0c 0a 4c 	lsr	r12,r11,r12
80009d1e:	ec 08 09 46 	lsl	r6,r6,r8
80009d22:	0c 4c       	or	r12,r6
80009d24:	c0 78       	rjmp	80009d32 <_dtoa_r+0x156>
80009d26:	d7 03       	nop
80009d28:	ea 0c 11 20 	rsub	r12,r5,32
80009d2c:	40 3a       	lddsp	r10,sp[0xc]
80009d2e:	f4 0c 09 4c 	lsl	r12,r10,r12
80009d32:	e0 a0 10 14 	rcall	8000bd5a <__avr32_u32_to_f64>
80009d36:	fc 18 fe 10 	movh	r8,0xfe10
80009d3a:	30 19       	mov	r9,1
80009d3c:	ea c5 04 33 	sub	r5,r5,1075
80009d40:	f0 0b 00 0b 	add	r11,r8,r11
80009d44:	51 79       	stdsp	sp[0x5c],r9
80009d46:	30 08       	mov	r8,0
80009d48:	fc 19 3f f8 	movh	r9,0x3ff8
80009d4c:	e0 a0 0e 9c 	rcall	8000ba84 <__avr32_f64_sub>
80009d50:	e0 68 43 61 	mov	r8,17249
80009d54:	ea 18 63 6f 	orh	r8,0x636f
80009d58:	e0 69 87 a7 	mov	r9,34727
80009d5c:	ea 19 3f d2 	orh	r9,0x3fd2
80009d60:	e0 a0 0d a6 	rcall	8000b8ac <__avr32_f64_mul>
80009d64:	e0 68 c8 b3 	mov	r8,51379
80009d68:	ea 18 8b 60 	orh	r8,0x8b60
80009d6c:	e0 69 8a 28 	mov	r9,35368
80009d70:	ea 19 3f c6 	orh	r9,0x3fc6
80009d74:	e0 a0 0f 56 	rcall	8000bc20 <__avr32_f64_add>
80009d78:	0a 9c       	mov	r12,r5
80009d7a:	14 90       	mov	r0,r10
80009d7c:	16 91       	mov	r1,r11
80009d7e:	e0 a0 0f f2 	rcall	8000bd62 <__avr32_s32_to_f64>
80009d82:	e0 68 79 fb 	mov	r8,31227
80009d86:	ea 18 50 9f 	orh	r8,0x509f
80009d8a:	e0 69 44 13 	mov	r9,17427
80009d8e:	ea 19 3f d3 	orh	r9,0x3fd3
80009d92:	e0 a0 0d 8d 	rcall	8000b8ac <__avr32_f64_mul>
80009d96:	14 98       	mov	r8,r10
80009d98:	16 99       	mov	r9,r11
80009d9a:	00 9a       	mov	r10,r0
80009d9c:	02 9b       	mov	r11,r1
80009d9e:	e0 a0 0f 41 	rcall	8000bc20 <__avr32_f64_add>
80009da2:	14 90       	mov	r0,r10
80009da4:	16 91       	mov	r1,r11
80009da6:	e0 a0 0f c7 	rcall	8000bd34 <__avr32_f64_to_s32>
80009daa:	30 08       	mov	r8,0
80009dac:	18 96       	mov	r6,r12
80009dae:	30 09       	mov	r9,0
80009db0:	00 9a       	mov	r10,r0
80009db2:	02 9b       	mov	r11,r1
80009db4:	e0 a0 10 8e 	rcall	8000bed0 <__avr32_f64_cmp_lt>
80009db8:	c0 c0       	breq	80009dd0 <_dtoa_r+0x1f4>
80009dba:	0c 9c       	mov	r12,r6
80009dbc:	e0 a0 0f d3 	rcall	8000bd62 <__avr32_s32_to_f64>
80009dc0:	14 98       	mov	r8,r10
80009dc2:	16 99       	mov	r9,r11
80009dc4:	00 9a       	mov	r10,r0
80009dc6:	02 9b       	mov	r11,r1
80009dc8:	e0 a0 10 3d 	rcall	8000be42 <__avr32_f64_cmp_eq>
80009dcc:	f7 b6 00 01 	subeq	r6,1
80009dd0:	59 66       	cp.w	r6,22
80009dd2:	e0 88 00 05 	brls	80009ddc <_dtoa_r+0x200>
80009dd6:	30 18       	mov	r8,1
80009dd8:	51 48       	stdsp	sp[0x50],r8
80009dda:	c1 38       	rjmp	80009e00 <_dtoa_r+0x224>
80009ddc:	fe c8 c3 94 	sub	r8,pc,-15468
80009de0:	fa ea 00 3c 	ld.d	r10,sp[60]
80009de4:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
80009de8:	e0 a0 10 74 	rcall	8000bed0 <__avr32_f64_cmp_lt>
80009dec:	f9 b4 00 00 	moveq	r4,0
80009df0:	fb f4 0a 14 	st.weq	sp[0x50],r4
80009df4:	f7 b6 01 01 	subne	r6,1
80009df8:	f9 bc 01 00 	movne	r12,0
80009dfc:	fb fc 1a 14 	st.wne	sp[0x50],r12
80009e00:	41 90       	lddsp	r0,sp[0x64]
80009e02:	20 10       	sub	r0,1
80009e04:	0a 10       	sub	r0,r5
80009e06:	c0 46       	brmi	80009e0e <_dtoa_r+0x232>
80009e08:	50 40       	stdsp	sp[0x10],r0
80009e0a:	30 00       	mov	r0,0
80009e0c:	c0 48       	rjmp	80009e14 <_dtoa_r+0x238>
80009e0e:	30 0b       	mov	r11,0
80009e10:	5c 30       	neg	r0
80009e12:	50 4b       	stdsp	sp[0x10],r11
80009e14:	ec 02 11 00 	rsub	r2,r6,0
80009e18:	58 06       	cp.w	r6,0
80009e1a:	fb fa 40 04 	ld.wge	r10,sp[0x10]
80009e1e:	f5 d6 e4 0a 	addge	r10,r10,r6
80009e22:	fb fa 4a 04 	st.wge	sp[0x10],r10
80009e26:	fb f6 4a 11 	st.wge	sp[0x44],r6
80009e2a:	f9 b2 04 00 	movge	r2,0
80009e2e:	e1 d6 e5 10 	sublt	r0,r0,r6
80009e32:	f9 b9 05 00 	movlt	r9,0
80009e36:	fb f9 5a 11 	st.wlt	sp[0x44],r9
80009e3a:	40 c8       	lddsp	r8,sp[0x30]
80009e3c:	58 98       	cp.w	r8,9
80009e3e:	e0 8b 00 20 	brhi	80009e7e <_dtoa_r+0x2a2>
80009e42:	58 58       	cp.w	r8,5
80009e44:	f9 b4 0a 01 	movle	r4,1
80009e48:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80009e4c:	f7 b5 09 04 	subgt	r5,4
80009e50:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80009e54:	f9 b4 09 00 	movgt	r4,0
80009e58:	40 cc       	lddsp	r12,sp[0x30]
80009e5a:	58 3c       	cp.w	r12,3
80009e5c:	c2 d0       	breq	80009eb6 <_dtoa_r+0x2da>
80009e5e:	e0 89 00 05 	brgt	80009e68 <_dtoa_r+0x28c>
80009e62:	58 2c       	cp.w	r12,2
80009e64:	c1 01       	brne	80009e84 <_dtoa_r+0x2a8>
80009e66:	c1 88       	rjmp	80009e96 <_dtoa_r+0x2ba>
80009e68:	40 cb       	lddsp	r11,sp[0x30]
80009e6a:	58 4b       	cp.w	r11,4
80009e6c:	c0 60       	breq	80009e78 <_dtoa_r+0x29c>
80009e6e:	58 5b       	cp.w	r11,5
80009e70:	c0 a1       	brne	80009e84 <_dtoa_r+0x2a8>
80009e72:	30 1a       	mov	r10,1
80009e74:	50 da       	stdsp	sp[0x34],r10
80009e76:	c2 28       	rjmp	80009eba <_dtoa_r+0x2de>
80009e78:	30 19       	mov	r9,1
80009e7a:	50 d9       	stdsp	sp[0x34],r9
80009e7c:	c0 f8       	rjmp	80009e9a <_dtoa_r+0x2be>
80009e7e:	30 08       	mov	r8,0
80009e80:	30 14       	mov	r4,1
80009e82:	50 c8       	stdsp	sp[0x30],r8
80009e84:	3f f5       	mov	r5,-1
80009e86:	30 1c       	mov	r12,1
80009e88:	30 0b       	mov	r11,0
80009e8a:	50 95       	stdsp	sp[0x24],r5
80009e8c:	50 dc       	stdsp	sp[0x34],r12
80009e8e:	0a 91       	mov	r1,r5
80009e90:	31 28       	mov	r8,18
80009e92:	50 eb       	stdsp	sp[0x38],r11
80009e94:	c2 08       	rjmp	80009ed4 <_dtoa_r+0x2f8>
80009e96:	30 0a       	mov	r10,0
80009e98:	50 da       	stdsp	sp[0x34],r10
80009e9a:	40 e9       	lddsp	r9,sp[0x38]
80009e9c:	58 09       	cp.w	r9,0
80009e9e:	e0 89 00 07 	brgt	80009eac <_dtoa_r+0x2d0>
80009ea2:	30 18       	mov	r8,1
80009ea4:	50 98       	stdsp	sp[0x24],r8
80009ea6:	10 91       	mov	r1,r8
80009ea8:	50 e8       	stdsp	sp[0x38],r8
80009eaa:	c1 58       	rjmp	80009ed4 <_dtoa_r+0x2f8>
80009eac:	40 e5       	lddsp	r5,sp[0x38]
80009eae:	50 95       	stdsp	sp[0x24],r5
80009eb0:	0a 91       	mov	r1,r5
80009eb2:	0a 98       	mov	r8,r5
80009eb4:	c1 08       	rjmp	80009ed4 <_dtoa_r+0x2f8>
80009eb6:	30 0c       	mov	r12,0
80009eb8:	50 dc       	stdsp	sp[0x34],r12
80009eba:	40 eb       	lddsp	r11,sp[0x38]
80009ebc:	ec 0b 00 0b 	add	r11,r6,r11
80009ec0:	50 9b       	stdsp	sp[0x24],r11
80009ec2:	16 98       	mov	r8,r11
80009ec4:	2f f8       	sub	r8,-1
80009ec6:	58 08       	cp.w	r8,0
80009ec8:	e0 89 00 05 	brgt	80009ed2 <_dtoa_r+0x2f6>
80009ecc:	10 91       	mov	r1,r8
80009ece:	30 18       	mov	r8,1
80009ed0:	c0 28       	rjmp	80009ed4 <_dtoa_r+0x2f8>
80009ed2:	10 91       	mov	r1,r8
80009ed4:	30 09       	mov	r9,0
80009ed6:	6e 9a       	ld.w	r10,r7[0x24]
80009ed8:	95 19       	st.w	r10[0x4],r9
80009eda:	30 49       	mov	r9,4
80009edc:	c0 68       	rjmp	80009ee8 <_dtoa_r+0x30c>
80009ede:	d7 03       	nop
80009ee0:	6a 1a       	ld.w	r10,r5[0x4]
80009ee2:	a1 79       	lsl	r9,0x1
80009ee4:	2f fa       	sub	r10,-1
80009ee6:	8b 1a       	st.w	r5[0x4],r10
80009ee8:	6e 95       	ld.w	r5,r7[0x24]
80009eea:	f2 ca ff ec 	sub	r10,r9,-20
80009eee:	10 3a       	cp.w	r10,r8
80009ef0:	fe 98 ff f8 	brls	80009ee0 <_dtoa_r+0x304>
80009ef4:	6a 1b       	ld.w	r11,r5[0x4]
80009ef6:	0e 9c       	mov	r12,r7
80009ef8:	e0 a0 09 44 	rcall	8000b180 <_Balloc>
80009efc:	58 e1       	cp.w	r1,14
80009efe:	5f 88       	srls	r8
80009f00:	8b 0c       	st.w	r5[0x0],r12
80009f02:	f1 e4 00 04 	and	r4,r8,r4
80009f06:	6e 98       	ld.w	r8,r7[0x24]
80009f08:	70 08       	ld.w	r8,r8[0x0]
80009f0a:	50 88       	stdsp	sp[0x20],r8
80009f0c:	e0 80 01 82 	breq	8000a210 <_dtoa_r+0x634>
80009f10:	58 06       	cp.w	r6,0
80009f12:	e0 8a 00 43 	brle	80009f98 <_dtoa_r+0x3bc>
80009f16:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
80009f1a:	fe c8 c4 d2 	sub	r8,pc,-15150
80009f1e:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
80009f22:	fa e5 00 18 	st.d	sp[24],r4
80009f26:	ec 04 14 04 	asr	r4,r6,0x4
80009f2a:	ed b4 00 04 	bld	r4,0x4
80009f2e:	c0 30       	breq	80009f34 <_dtoa_r+0x358>
80009f30:	30 25       	mov	r5,2
80009f32:	c1 08       	rjmp	80009f52 <_dtoa_r+0x376>
80009f34:	fe c8 c4 24 	sub	r8,pc,-15324
80009f38:	f0 e8 00 20 	ld.d	r8,r8[32]
80009f3c:	fa ea 00 3c 	ld.d	r10,sp[60]
80009f40:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80009f44:	e0 a0 0f fa 	rcall	8000bf38 <__avr32_f64_div>
80009f48:	30 35       	mov	r5,3
80009f4a:	14 98       	mov	r8,r10
80009f4c:	16 99       	mov	r9,r11
80009f4e:	fa e9 00 08 	st.d	sp[8],r8
80009f52:	fe cc c4 42 	sub	r12,pc,-15294
80009f56:	50 a3       	stdsp	sp[0x28],r3
80009f58:	0c 93       	mov	r3,r6
80009f5a:	18 96       	mov	r6,r12
80009f5c:	c0 f8       	rjmp	80009f7a <_dtoa_r+0x39e>
80009f5e:	fa ea 00 18 	ld.d	r10,sp[24]
80009f62:	ed b4 00 00 	bld	r4,0x0
80009f66:	c0 81       	brne	80009f76 <_dtoa_r+0x39a>
80009f68:	ec e8 00 00 	ld.d	r8,r6[0]
80009f6c:	2f f5       	sub	r5,-1
80009f6e:	e0 a0 0c 9f 	rcall	8000b8ac <__avr32_f64_mul>
80009f72:	fa eb 00 18 	st.d	sp[24],r10
80009f76:	a1 54       	asr	r4,0x1
80009f78:	2f 86       	sub	r6,-8
80009f7a:	58 04       	cp.w	r4,0
80009f7c:	cf 11       	brne	80009f5e <_dtoa_r+0x382>
80009f7e:	fa e8 00 18 	ld.d	r8,sp[24]
80009f82:	fa ea 00 08 	ld.d	r10,sp[8]
80009f86:	06 96       	mov	r6,r3
80009f88:	e0 a0 0f d8 	rcall	8000bf38 <__avr32_f64_div>
80009f8c:	40 a3       	lddsp	r3,sp[0x28]
80009f8e:	14 98       	mov	r8,r10
80009f90:	16 99       	mov	r9,r11
80009f92:	fa e9 00 08 	st.d	sp[8],r8
80009f96:	c2 f8       	rjmp	80009ff4 <_dtoa_r+0x418>
80009f98:	ec 08 11 00 	rsub	r8,r6,0
80009f9c:	c0 31       	brne	80009fa2 <_dtoa_r+0x3c6>
80009f9e:	30 25       	mov	r5,2
80009fa0:	c2 a8       	rjmp	80009ff4 <_dtoa_r+0x418>
80009fa2:	fe cc c4 92 	sub	r12,pc,-15214
80009fa6:	f0 04 14 04 	asr	r4,r8,0x4
80009faa:	50 1c       	stdsp	sp[0x4],r12
80009fac:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009fb0:	fe c9 c5 68 	sub	r9,pc,-15000
80009fb4:	fa ea 00 3c 	ld.d	r10,sp[60]
80009fb8:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009fbc:	e0 a0 0c 78 	rcall	8000b8ac <__avr32_f64_mul>
80009fc0:	40 1c       	lddsp	r12,sp[0x4]
80009fc2:	50 63       	stdsp	sp[0x18],r3
80009fc4:	30 25       	mov	r5,2
80009fc6:	0c 93       	mov	r3,r6
80009fc8:	fa eb 00 08 	st.d	sp[8],r10
80009fcc:	18 96       	mov	r6,r12
80009fce:	c0 f8       	rjmp	80009fec <_dtoa_r+0x410>
80009fd0:	fa ea 00 08 	ld.d	r10,sp[8]
80009fd4:	ed b4 00 00 	bld	r4,0x0
80009fd8:	c0 81       	brne	80009fe8 <_dtoa_r+0x40c>
80009fda:	ec e8 00 00 	ld.d	r8,r6[0]
80009fde:	2f f5       	sub	r5,-1
80009fe0:	e0 a0 0c 66 	rcall	8000b8ac <__avr32_f64_mul>
80009fe4:	fa eb 00 08 	st.d	sp[8],r10
80009fe8:	a1 54       	asr	r4,0x1
80009fea:	2f 86       	sub	r6,-8
80009fec:	58 04       	cp.w	r4,0
80009fee:	cf 11       	brne	80009fd0 <_dtoa_r+0x3f4>
80009ff0:	06 96       	mov	r6,r3
80009ff2:	40 63       	lddsp	r3,sp[0x18]
80009ff4:	41 4a       	lddsp	r10,sp[0x50]
80009ff6:	58 0a       	cp.w	r10,0
80009ff8:	c2 a0       	breq	8000a04c <_dtoa_r+0x470>
80009ffa:	fa e8 00 08 	ld.d	r8,sp[8]
80009ffe:	58 01       	cp.w	r1,0
8000a000:	5f 94       	srgt	r4
8000a002:	fa e9 00 18 	st.d	sp[24],r8
8000a006:	30 08       	mov	r8,0
8000a008:	fc 19 3f f0 	movh	r9,0x3ff0
8000a00c:	fa ea 00 18 	ld.d	r10,sp[24]
8000a010:	e0 a0 0f 60 	rcall	8000bed0 <__avr32_f64_cmp_lt>
8000a014:	f9 bc 00 00 	moveq	r12,0
8000a018:	f9 bc 01 01 	movne	r12,1
8000a01c:	e9 ec 00 0c 	and	r12,r4,r12
8000a020:	c1 60       	breq	8000a04c <_dtoa_r+0x470>
8000a022:	40 98       	lddsp	r8,sp[0x24]
8000a024:	58 08       	cp.w	r8,0
8000a026:	e0 8a 00 f1 	brle	8000a208 <_dtoa_r+0x62c>
8000a02a:	30 08       	mov	r8,0
8000a02c:	fc 19 40 24 	movh	r9,0x4024
8000a030:	ec c4 00 01 	sub	r4,r6,1
8000a034:	fa ea 00 18 	ld.d	r10,sp[24]
8000a038:	2f f5       	sub	r5,-1
8000a03a:	50 64       	stdsp	sp[0x18],r4
8000a03c:	e0 a0 0c 38 	rcall	8000b8ac <__avr32_f64_mul>
8000a040:	40 94       	lddsp	r4,sp[0x24]
8000a042:	14 98       	mov	r8,r10
8000a044:	16 99       	mov	r9,r11
8000a046:	fa e9 00 08 	st.d	sp[8],r8
8000a04a:	c0 38       	rjmp	8000a050 <_dtoa_r+0x474>
8000a04c:	50 66       	stdsp	sp[0x18],r6
8000a04e:	02 94       	mov	r4,r1
8000a050:	0a 9c       	mov	r12,r5
8000a052:	e0 a0 0e 88 	rcall	8000bd62 <__avr32_s32_to_f64>
8000a056:	fa e8 00 08 	ld.d	r8,sp[8]
8000a05a:	e0 a0 0c 29 	rcall	8000b8ac <__avr32_f64_mul>
8000a05e:	30 08       	mov	r8,0
8000a060:	fc 19 40 1c 	movh	r9,0x401c
8000a064:	e0 a0 0d de 	rcall	8000bc20 <__avr32_f64_add>
8000a068:	14 98       	mov	r8,r10
8000a06a:	16 99       	mov	r9,r11
8000a06c:	fa e9 00 28 	st.d	sp[40],r8
8000a070:	fc 18 fc c0 	movh	r8,0xfcc0
8000a074:	40 a5       	lddsp	r5,sp[0x28]
8000a076:	10 05       	add	r5,r8
8000a078:	50 a5       	stdsp	sp[0x28],r5
8000a07a:	58 04       	cp.w	r4,0
8000a07c:	c2 11       	brne	8000a0be <_dtoa_r+0x4e2>
8000a07e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a082:	30 08       	mov	r8,0
8000a084:	fc 19 40 14 	movh	r9,0x4014
8000a088:	e0 a0 0c fe 	rcall	8000ba84 <__avr32_f64_sub>
8000a08c:	40 bc       	lddsp	r12,sp[0x2c]
8000a08e:	fa eb 00 08 	st.d	sp[8],r10
8000a092:	14 98       	mov	r8,r10
8000a094:	16 99       	mov	r9,r11
8000a096:	18 9a       	mov	r10,r12
8000a098:	0a 9b       	mov	r11,r5
8000a09a:	e0 a0 0f 1b 	rcall	8000bed0 <__avr32_f64_cmp_lt>
8000a09e:	e0 81 02 54 	brne	8000a546 <_dtoa_r+0x96a>
8000a0a2:	0a 98       	mov	r8,r5
8000a0a4:	40 b9       	lddsp	r9,sp[0x2c]
8000a0a6:	ee 18 80 00 	eorh	r8,0x8000
8000a0aa:	fa ea 00 08 	ld.d	r10,sp[8]
8000a0ae:	10 95       	mov	r5,r8
8000a0b0:	12 98       	mov	r8,r9
8000a0b2:	0a 99       	mov	r9,r5
8000a0b4:	e0 a0 0f 0e 	rcall	8000bed0 <__avr32_f64_cmp_lt>
8000a0b8:	e0 81 02 3e 	brne	8000a534 <_dtoa_r+0x958>
8000a0bc:	ca 68       	rjmp	8000a208 <_dtoa_r+0x62c>
8000a0be:	fe c9 c6 76 	sub	r9,pc,-14730
8000a0c2:	e8 c8 00 01 	sub	r8,r4,1
8000a0c6:	40 d5       	lddsp	r5,sp[0x34]
8000a0c8:	58 05       	cp.w	r5,0
8000a0ca:	c4 f0       	breq	8000a168 <_dtoa_r+0x58c>
8000a0cc:	30 0c       	mov	r12,0
8000a0ce:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a0d2:	51 3c       	stdsp	sp[0x4c],r12
8000a0d4:	30 0a       	mov	r10,0
8000a0d6:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a0da:	e0 a0 0f 2f 	rcall	8000bf38 <__avr32_f64_div>
8000a0de:	fa e8 00 28 	ld.d	r8,sp[40]
8000a0e2:	40 85       	lddsp	r5,sp[0x20]
8000a0e4:	e0 a0 0c d0 	rcall	8000ba84 <__avr32_f64_sub>
8000a0e8:	fa eb 00 28 	st.d	sp[40],r10
8000a0ec:	fa ea 00 08 	ld.d	r10,sp[8]
8000a0f0:	e0 a0 0e 22 	rcall	8000bd34 <__avr32_f64_to_s32>
8000a0f4:	51 6c       	stdsp	sp[0x58],r12
8000a0f6:	e0 a0 0e 36 	rcall	8000bd62 <__avr32_s32_to_f64>
8000a0fa:	14 98       	mov	r8,r10
8000a0fc:	16 99       	mov	r9,r11
8000a0fe:	fa ea 00 08 	ld.d	r10,sp[8]
8000a102:	e0 a0 0c c1 	rcall	8000ba84 <__avr32_f64_sub>
8000a106:	fa eb 00 08 	st.d	sp[8],r10
8000a10a:	41 68       	lddsp	r8,sp[0x58]
8000a10c:	2d 08       	sub	r8,-48
8000a10e:	0a c8       	st.b	r5++,r8
8000a110:	41 39       	lddsp	r9,sp[0x4c]
8000a112:	2f f9       	sub	r9,-1
8000a114:	51 39       	stdsp	sp[0x4c],r9
8000a116:	fa e8 00 28 	ld.d	r8,sp[40]
8000a11a:	e0 a0 0e db 	rcall	8000bed0 <__avr32_f64_cmp_lt>
8000a11e:	e0 81 03 39 	brne	8000a790 <_dtoa_r+0xbb4>
8000a122:	fa e8 00 08 	ld.d	r8,sp[8]
8000a126:	30 0a       	mov	r10,0
8000a128:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a12c:	e0 a0 0c ac 	rcall	8000ba84 <__avr32_f64_sub>
8000a130:	fa e8 00 28 	ld.d	r8,sp[40]
8000a134:	e0 a0 0e ce 	rcall	8000bed0 <__avr32_f64_cmp_lt>
8000a138:	fa ea 00 28 	ld.d	r10,sp[40]
8000a13c:	30 08       	mov	r8,0
8000a13e:	fc 19 40 24 	movh	r9,0x4024
8000a142:	e0 81 00 da 	brne	8000a2f6 <_dtoa_r+0x71a>
8000a146:	41 3c       	lddsp	r12,sp[0x4c]
8000a148:	08 3c       	cp.w	r12,r4
8000a14a:	c5 f4       	brge	8000a208 <_dtoa_r+0x62c>
8000a14c:	e0 a0 0b b0 	rcall	8000b8ac <__avr32_f64_mul>
8000a150:	30 08       	mov	r8,0
8000a152:	fa eb 00 28 	st.d	sp[40],r10
8000a156:	fc 19 40 24 	movh	r9,0x4024
8000a15a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a15e:	e0 a0 0b a7 	rcall	8000b8ac <__avr32_f64_mul>
8000a162:	fa eb 00 08 	st.d	sp[8],r10
8000a166:	cc 3b       	rjmp	8000a0ec <_dtoa_r+0x510>
8000a168:	40 85       	lddsp	r5,sp[0x20]
8000a16a:	08 05       	add	r5,r4
8000a16c:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a170:	51 35       	stdsp	sp[0x4c],r5
8000a172:	fa e8 00 28 	ld.d	r8,sp[40]
8000a176:	40 85       	lddsp	r5,sp[0x20]
8000a178:	e0 a0 0b 9a 	rcall	8000b8ac <__avr32_f64_mul>
8000a17c:	fa eb 00 28 	st.d	sp[40],r10
8000a180:	fa ea 00 08 	ld.d	r10,sp[8]
8000a184:	e0 a0 0d d8 	rcall	8000bd34 <__avr32_f64_to_s32>
8000a188:	51 6c       	stdsp	sp[0x58],r12
8000a18a:	e0 a0 0d ec 	rcall	8000bd62 <__avr32_s32_to_f64>
8000a18e:	14 98       	mov	r8,r10
8000a190:	16 99       	mov	r9,r11
8000a192:	fa ea 00 08 	ld.d	r10,sp[8]
8000a196:	e0 a0 0c 77 	rcall	8000ba84 <__avr32_f64_sub>
8000a19a:	fa eb 00 08 	st.d	sp[8],r10
8000a19e:	41 68       	lddsp	r8,sp[0x58]
8000a1a0:	2d 08       	sub	r8,-48
8000a1a2:	0a c8       	st.b	r5++,r8
8000a1a4:	41 3c       	lddsp	r12,sp[0x4c]
8000a1a6:	18 35       	cp.w	r5,r12
8000a1a8:	c2 81       	brne	8000a1f8 <_dtoa_r+0x61c>
8000a1aa:	30 08       	mov	r8,0
8000a1ac:	fc 19 3f e0 	movh	r9,0x3fe0
8000a1b0:	fa ea 00 28 	ld.d	r10,sp[40]
8000a1b4:	e0 a0 0d 36 	rcall	8000bc20 <__avr32_f64_add>
8000a1b8:	40 85       	lddsp	r5,sp[0x20]
8000a1ba:	fa e8 00 08 	ld.d	r8,sp[8]
8000a1be:	08 05       	add	r5,r4
8000a1c0:	e0 a0 0e 88 	rcall	8000bed0 <__avr32_f64_cmp_lt>
8000a1c4:	e0 81 00 99 	brne	8000a2f6 <_dtoa_r+0x71a>
8000a1c8:	fa e8 00 28 	ld.d	r8,sp[40]
8000a1cc:	30 0a       	mov	r10,0
8000a1ce:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a1d2:	e0 a0 0c 59 	rcall	8000ba84 <__avr32_f64_sub>
8000a1d6:	14 98       	mov	r8,r10
8000a1d8:	16 99       	mov	r9,r11
8000a1da:	fa ea 00 08 	ld.d	r10,sp[8]
8000a1de:	e0 a0 0e 79 	rcall	8000bed0 <__avr32_f64_cmp_lt>
8000a1e2:	c1 30       	breq	8000a208 <_dtoa_r+0x62c>
8000a1e4:	33 09       	mov	r9,48
8000a1e6:	0a 98       	mov	r8,r5
8000a1e8:	11 7a       	ld.ub	r10,--r8
8000a1ea:	f2 0a 18 00 	cp.b	r10,r9
8000a1ee:	e0 81 02 d1 	brne	8000a790 <_dtoa_r+0xbb4>
8000a1f2:	10 95       	mov	r5,r8
8000a1f4:	cf 9b       	rjmp	8000a1e6 <_dtoa_r+0x60a>
8000a1f6:	d7 03       	nop
8000a1f8:	30 08       	mov	r8,0
8000a1fa:	fc 19 40 24 	movh	r9,0x4024
8000a1fe:	e0 a0 0b 57 	rcall	8000b8ac <__avr32_f64_mul>
8000a202:	fa eb 00 08 	st.d	sp[8],r10
8000a206:	cb db       	rjmp	8000a180 <_dtoa_r+0x5a4>
8000a208:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a20c:	fa eb 00 08 	st.d	sp[8],r10
8000a210:	58 e6       	cp.w	r6,14
8000a212:	5f ab       	srle	r11
8000a214:	41 8a       	lddsp	r10,sp[0x60]
8000a216:	30 08       	mov	r8,0
8000a218:	f4 09 11 ff 	rsub	r9,r10,-1
8000a21c:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a220:	f0 09 18 00 	cp.b	r9,r8
8000a224:	e0 80 00 82 	breq	8000a328 <_dtoa_r+0x74c>
8000a228:	40 ea       	lddsp	r10,sp[0x38]
8000a22a:	58 01       	cp.w	r1,0
8000a22c:	5f a9       	srle	r9
8000a22e:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a232:	fe ca c7 ea 	sub	r10,pc,-14358
8000a236:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a23a:	fa e5 00 10 	st.d	sp[16],r4
8000a23e:	f0 09 18 00 	cp.b	r9,r8
8000a242:	c1 40       	breq	8000a26a <_dtoa_r+0x68e>
8000a244:	58 01       	cp.w	r1,0
8000a246:	e0 81 01 77 	brne	8000a534 <_dtoa_r+0x958>
8000a24a:	30 08       	mov	r8,0
8000a24c:	fc 19 40 14 	movh	r9,0x4014
8000a250:	08 9a       	mov	r10,r4
8000a252:	0a 9b       	mov	r11,r5
8000a254:	e0 a0 0b 2c 	rcall	8000b8ac <__avr32_f64_mul>
8000a258:	fa e8 00 08 	ld.d	r8,sp[8]
8000a25c:	e0 a0 0e 06 	rcall	8000be68 <__avr32_f64_cmp_ge>
8000a260:	e0 81 01 6a 	brne	8000a534 <_dtoa_r+0x958>
8000a264:	02 92       	mov	r2,r1
8000a266:	e0 8f 01 72 	bral	8000a54a <_dtoa_r+0x96e>
8000a26a:	40 85       	lddsp	r5,sp[0x20]
8000a26c:	30 14       	mov	r4,1
8000a26e:	fa e8 00 10 	ld.d	r8,sp[16]
8000a272:	fa ea 00 08 	ld.d	r10,sp[8]
8000a276:	e0 a0 0e 61 	rcall	8000bf38 <__avr32_f64_div>
8000a27a:	e0 a0 0d 5d 	rcall	8000bd34 <__avr32_f64_to_s32>
8000a27e:	18 92       	mov	r2,r12
8000a280:	e0 a0 0d 71 	rcall	8000bd62 <__avr32_s32_to_f64>
8000a284:	fa e8 00 10 	ld.d	r8,sp[16]
8000a288:	e0 a0 0b 12 	rcall	8000b8ac <__avr32_f64_mul>
8000a28c:	14 98       	mov	r8,r10
8000a28e:	16 99       	mov	r9,r11
8000a290:	fa ea 00 08 	ld.d	r10,sp[8]
8000a294:	e0 a0 0b f8 	rcall	8000ba84 <__avr32_f64_sub>
8000a298:	fa eb 00 08 	st.d	sp[8],r10
8000a29c:	e4 c8 ff d0 	sub	r8,r2,-48
8000a2a0:	0a c8       	st.b	r5++,r8
8000a2a2:	fc 19 40 24 	movh	r9,0x4024
8000a2a6:	30 08       	mov	r8,0
8000a2a8:	02 34       	cp.w	r4,r1
8000a2aa:	c3 31       	brne	8000a310 <_dtoa_r+0x734>
8000a2ac:	fa e8 00 08 	ld.d	r8,sp[8]
8000a2b0:	e0 a0 0c b8 	rcall	8000bc20 <__avr32_f64_add>
8000a2b4:	16 91       	mov	r1,r11
8000a2b6:	14 90       	mov	r0,r10
8000a2b8:	14 98       	mov	r8,r10
8000a2ba:	02 99       	mov	r9,r1
8000a2bc:	fa ea 00 10 	ld.d	r10,sp[16]
8000a2c0:	e0 a0 0e 08 	rcall	8000bed0 <__avr32_f64_cmp_lt>
8000a2c4:	c1 a1       	brne	8000a2f8 <_dtoa_r+0x71c>
8000a2c6:	fa e8 00 10 	ld.d	r8,sp[16]
8000a2ca:	00 9a       	mov	r10,r0
8000a2cc:	02 9b       	mov	r11,r1
8000a2ce:	e0 a0 0d ba 	rcall	8000be42 <__avr32_f64_cmp_eq>
8000a2d2:	e0 80 02 5e 	breq	8000a78e <_dtoa_r+0xbb2>
8000a2d6:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a2da:	c0 f1       	brne	8000a2f8 <_dtoa_r+0x71c>
8000a2dc:	e0 8f 02 59 	bral	8000a78e <_dtoa_r+0xbb2>
8000a2e0:	40 8a       	lddsp	r10,sp[0x20]
8000a2e2:	14 38       	cp.w	r8,r10
8000a2e4:	c0 30       	breq	8000a2ea <_dtoa_r+0x70e>
8000a2e6:	10 95       	mov	r5,r8
8000a2e8:	c0 98       	rjmp	8000a2fa <_dtoa_r+0x71e>
8000a2ea:	33 08       	mov	r8,48
8000a2ec:	40 89       	lddsp	r9,sp[0x20]
8000a2ee:	2f f6       	sub	r6,-1
8000a2f0:	b2 88       	st.b	r9[0x0],r8
8000a2f2:	40 88       	lddsp	r8,sp[0x20]
8000a2f4:	c0 88       	rjmp	8000a304 <_dtoa_r+0x728>
8000a2f6:	40 66       	lddsp	r6,sp[0x18]
8000a2f8:	33 99       	mov	r9,57
8000a2fa:	0a 98       	mov	r8,r5
8000a2fc:	11 7a       	ld.ub	r10,--r8
8000a2fe:	f2 0a 18 00 	cp.b	r10,r9
8000a302:	ce f0       	breq	8000a2e0 <_dtoa_r+0x704>
8000a304:	50 66       	stdsp	sp[0x18],r6
8000a306:	11 89       	ld.ub	r9,r8[0x0]
8000a308:	2f f9       	sub	r9,-1
8000a30a:	b0 89       	st.b	r8[0x0],r9
8000a30c:	e0 8f 02 42 	bral	8000a790 <_dtoa_r+0xbb4>
8000a310:	e0 a0 0a ce 	rcall	8000b8ac <__avr32_f64_mul>
8000a314:	2f f4       	sub	r4,-1
8000a316:	fa eb 00 08 	st.d	sp[8],r10
8000a31a:	30 08       	mov	r8,0
8000a31c:	30 09       	mov	r9,0
8000a31e:	e0 a0 0d 92 	rcall	8000be42 <__avr32_f64_cmp_eq>
8000a322:	ca 60       	breq	8000a26e <_dtoa_r+0x692>
8000a324:	e0 8f 02 35 	bral	8000a78e <_dtoa_r+0xbb2>
8000a328:	40 d8       	lddsp	r8,sp[0x34]
8000a32a:	58 08       	cp.w	r8,0
8000a32c:	c0 51       	brne	8000a336 <_dtoa_r+0x75a>
8000a32e:	04 98       	mov	r8,r2
8000a330:	00 95       	mov	r5,r0
8000a332:	40 d4       	lddsp	r4,sp[0x34]
8000a334:	c3 78       	rjmp	8000a3a2 <_dtoa_r+0x7c6>
8000a336:	40 c5       	lddsp	r5,sp[0x30]
8000a338:	58 15       	cp.w	r5,1
8000a33a:	e0 89 00 0f 	brgt	8000a358 <_dtoa_r+0x77c>
8000a33e:	41 74       	lddsp	r4,sp[0x5c]
8000a340:	58 04       	cp.w	r4,0
8000a342:	c0 40       	breq	8000a34a <_dtoa_r+0x76e>
8000a344:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a348:	c0 48       	rjmp	8000a350 <_dtoa_r+0x774>
8000a34a:	41 99       	lddsp	r9,sp[0x64]
8000a34c:	f2 09 11 36 	rsub	r9,r9,54
8000a350:	04 98       	mov	r8,r2
8000a352:	00 95       	mov	r5,r0
8000a354:	c1 c8       	rjmp	8000a38c <_dtoa_r+0x7b0>
8000a356:	d7 03       	nop
8000a358:	e2 c8 00 01 	sub	r8,r1,1
8000a35c:	58 01       	cp.w	r1,0
8000a35e:	e0 05 17 40 	movge	r5,r0
8000a362:	e2 09 17 40 	movge	r9,r1
8000a366:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a36a:	f9 b9 05 00 	movlt	r9,0
8000a36e:	10 32       	cp.w	r2,r8
8000a370:	e5 d8 e4 18 	subge	r8,r2,r8
8000a374:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a378:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a37c:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a380:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a384:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a388:	f9 b8 05 00 	movlt	r8,0
8000a38c:	40 4b       	lddsp	r11,sp[0x10]
8000a38e:	12 0b       	add	r11,r9
8000a390:	50 08       	stdsp	sp[0x0],r8
8000a392:	50 4b       	stdsp	sp[0x10],r11
8000a394:	12 00       	add	r0,r9
8000a396:	30 1b       	mov	r11,1
8000a398:	0e 9c       	mov	r12,r7
8000a39a:	e0 a0 08 a7 	rcall	8000b4e8 <__i2b>
8000a39e:	40 08       	lddsp	r8,sp[0x0]
8000a3a0:	18 94       	mov	r4,r12
8000a3a2:	40 4a       	lddsp	r10,sp[0x10]
8000a3a4:	58 05       	cp.w	r5,0
8000a3a6:	5f 99       	srgt	r9
8000a3a8:	58 0a       	cp.w	r10,0
8000a3aa:	5f 9a       	srgt	r10
8000a3ac:	f5 e9 00 09 	and	r9,r10,r9
8000a3b0:	c0 80       	breq	8000a3c0 <_dtoa_r+0x7e4>
8000a3b2:	40 4c       	lddsp	r12,sp[0x10]
8000a3b4:	f8 05 0d 49 	min	r9,r12,r5
8000a3b8:	12 1c       	sub	r12,r9
8000a3ba:	12 10       	sub	r0,r9
8000a3bc:	50 4c       	stdsp	sp[0x10],r12
8000a3be:	12 15       	sub	r5,r9
8000a3c0:	58 02       	cp.w	r2,0
8000a3c2:	e0 8a 00 27 	brle	8000a410 <_dtoa_r+0x834>
8000a3c6:	40 db       	lddsp	r11,sp[0x34]
8000a3c8:	58 0b       	cp.w	r11,0
8000a3ca:	c1 d0       	breq	8000a404 <_dtoa_r+0x828>
8000a3cc:	58 08       	cp.w	r8,0
8000a3ce:	e0 8a 00 17 	brle	8000a3fc <_dtoa_r+0x820>
8000a3d2:	10 9a       	mov	r10,r8
8000a3d4:	50 08       	stdsp	sp[0x0],r8
8000a3d6:	08 9b       	mov	r11,r4
8000a3d8:	0e 9c       	mov	r12,r7
8000a3da:	e0 a0 08 cd 	rcall	8000b574 <__pow5mult>
8000a3de:	06 9a       	mov	r10,r3
8000a3e0:	18 9b       	mov	r11,r12
8000a3e2:	18 94       	mov	r4,r12
8000a3e4:	0e 9c       	mov	r12,r7
8000a3e6:	e0 a0 08 01 	rcall	8000b3e8 <__multiply>
8000a3ea:	18 99       	mov	r9,r12
8000a3ec:	06 9b       	mov	r11,r3
8000a3ee:	50 19       	stdsp	sp[0x4],r9
8000a3f0:	0e 9c       	mov	r12,r7
8000a3f2:	e0 a0 06 ad 	rcall	8000b14c <_Bfree>
8000a3f6:	40 19       	lddsp	r9,sp[0x4]
8000a3f8:	40 08       	lddsp	r8,sp[0x0]
8000a3fa:	12 93       	mov	r3,r9
8000a3fc:	e4 08 01 0a 	sub	r10,r2,r8
8000a400:	c0 80       	breq	8000a410 <_dtoa_r+0x834>
8000a402:	c0 28       	rjmp	8000a406 <_dtoa_r+0x82a>
8000a404:	04 9a       	mov	r10,r2
8000a406:	06 9b       	mov	r11,r3
8000a408:	0e 9c       	mov	r12,r7
8000a40a:	e0 a0 08 b5 	rcall	8000b574 <__pow5mult>
8000a40e:	18 93       	mov	r3,r12
8000a410:	30 1b       	mov	r11,1
8000a412:	0e 9c       	mov	r12,r7
8000a414:	e0 a0 08 6a 	rcall	8000b4e8 <__i2b>
8000a418:	41 1a       	lddsp	r10,sp[0x44]
8000a41a:	18 92       	mov	r2,r12
8000a41c:	58 0a       	cp.w	r10,0
8000a41e:	e0 8a 00 07 	brle	8000a42c <_dtoa_r+0x850>
8000a422:	18 9b       	mov	r11,r12
8000a424:	0e 9c       	mov	r12,r7
8000a426:	e0 a0 08 a7 	rcall	8000b574 <__pow5mult>
8000a42a:	18 92       	mov	r2,r12
8000a42c:	40 c9       	lddsp	r9,sp[0x30]
8000a42e:	58 19       	cp.w	r9,1
8000a430:	e0 89 00 14 	brgt	8000a458 <_dtoa_r+0x87c>
8000a434:	40 38       	lddsp	r8,sp[0xc]
8000a436:	58 08       	cp.w	r8,0
8000a438:	c1 01       	brne	8000a458 <_dtoa_r+0x87c>
8000a43a:	40 29       	lddsp	r9,sp[0x8]
8000a43c:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a440:	c0 c1       	brne	8000a458 <_dtoa_r+0x87c>
8000a442:	12 98       	mov	r8,r9
8000a444:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a448:	c0 80       	breq	8000a458 <_dtoa_r+0x87c>
8000a44a:	40 4c       	lddsp	r12,sp[0x10]
8000a44c:	30 1b       	mov	r11,1
8000a44e:	2f fc       	sub	r12,-1
8000a450:	2f f0       	sub	r0,-1
8000a452:	50 4c       	stdsp	sp[0x10],r12
8000a454:	50 6b       	stdsp	sp[0x18],r11
8000a456:	c0 38       	rjmp	8000a45c <_dtoa_r+0x880>
8000a458:	30 0a       	mov	r10,0
8000a45a:	50 6a       	stdsp	sp[0x18],r10
8000a45c:	41 19       	lddsp	r9,sp[0x44]
8000a45e:	58 09       	cp.w	r9,0
8000a460:	c0 31       	brne	8000a466 <_dtoa_r+0x88a>
8000a462:	30 1c       	mov	r12,1
8000a464:	c0 98       	rjmp	8000a476 <_dtoa_r+0x89a>
8000a466:	64 48       	ld.w	r8,r2[0x10]
8000a468:	2f c8       	sub	r8,-4
8000a46a:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a46e:	e0 a0 05 df 	rcall	8000b02c <__hi0bits>
8000a472:	f8 0c 11 20 	rsub	r12,r12,32
8000a476:	40 4b       	lddsp	r11,sp[0x10]
8000a478:	f8 0b 00 08 	add	r8,r12,r11
8000a47c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a480:	c0 c0       	breq	8000a498 <_dtoa_r+0x8bc>
8000a482:	f0 08 11 20 	rsub	r8,r8,32
8000a486:	58 48       	cp.w	r8,4
8000a488:	e0 8a 00 06 	brle	8000a494 <_dtoa_r+0x8b8>
8000a48c:	20 48       	sub	r8,4
8000a48e:	10 0b       	add	r11,r8
8000a490:	50 4b       	stdsp	sp[0x10],r11
8000a492:	c0 78       	rjmp	8000a4a0 <_dtoa_r+0x8c4>
8000a494:	58 48       	cp.w	r8,4
8000a496:	c0 70       	breq	8000a4a4 <_dtoa_r+0x8c8>
8000a498:	40 4a       	lddsp	r10,sp[0x10]
8000a49a:	2e 48       	sub	r8,-28
8000a49c:	10 0a       	add	r10,r8
8000a49e:	50 4a       	stdsp	sp[0x10],r10
8000a4a0:	10 00       	add	r0,r8
8000a4a2:	10 05       	add	r5,r8
8000a4a4:	58 00       	cp.w	r0,0
8000a4a6:	e0 8a 00 08 	brle	8000a4b6 <_dtoa_r+0x8da>
8000a4aa:	06 9b       	mov	r11,r3
8000a4ac:	00 9a       	mov	r10,r0
8000a4ae:	0e 9c       	mov	r12,r7
8000a4b0:	e0 a0 07 58 	rcall	8000b360 <__lshift>
8000a4b4:	18 93       	mov	r3,r12
8000a4b6:	40 49       	lddsp	r9,sp[0x10]
8000a4b8:	58 09       	cp.w	r9,0
8000a4ba:	e0 8a 00 08 	brle	8000a4ca <_dtoa_r+0x8ee>
8000a4be:	04 9b       	mov	r11,r2
8000a4c0:	12 9a       	mov	r10,r9
8000a4c2:	0e 9c       	mov	r12,r7
8000a4c4:	e0 a0 07 4e 	rcall	8000b360 <__lshift>
8000a4c8:	18 92       	mov	r2,r12
8000a4ca:	41 48       	lddsp	r8,sp[0x50]
8000a4cc:	58 08       	cp.w	r8,0
8000a4ce:	c1 b0       	breq	8000a504 <_dtoa_r+0x928>
8000a4d0:	04 9b       	mov	r11,r2
8000a4d2:	06 9c       	mov	r12,r3
8000a4d4:	e0 a0 06 23 	rcall	8000b11a <__mcmp>
8000a4d8:	c1 64       	brge	8000a504 <_dtoa_r+0x928>
8000a4da:	06 9b       	mov	r11,r3
8000a4dc:	30 09       	mov	r9,0
8000a4de:	30 aa       	mov	r10,10
8000a4e0:	0e 9c       	mov	r12,r7
8000a4e2:	e0 a0 08 0b 	rcall	8000b4f8 <__multadd>
8000a4e6:	20 16       	sub	r6,1
8000a4e8:	18 93       	mov	r3,r12
8000a4ea:	40 dc       	lddsp	r12,sp[0x34]
8000a4ec:	58 0c       	cp.w	r12,0
8000a4ee:	c0 31       	brne	8000a4f4 <_dtoa_r+0x918>
8000a4f0:	40 91       	lddsp	r1,sp[0x24]
8000a4f2:	c0 98       	rjmp	8000a504 <_dtoa_r+0x928>
8000a4f4:	08 9b       	mov	r11,r4
8000a4f6:	40 91       	lddsp	r1,sp[0x24]
8000a4f8:	30 09       	mov	r9,0
8000a4fa:	30 aa       	mov	r10,10
8000a4fc:	0e 9c       	mov	r12,r7
8000a4fe:	e0 a0 07 fd 	rcall	8000b4f8 <__multadd>
8000a502:	18 94       	mov	r4,r12
8000a504:	58 01       	cp.w	r1,0
8000a506:	5f a9       	srle	r9
8000a508:	40 cb       	lddsp	r11,sp[0x30]
8000a50a:	58 2b       	cp.w	r11,2
8000a50c:	5f 98       	srgt	r8
8000a50e:	f3 e8 00 08 	and	r8,r9,r8
8000a512:	c2 50       	breq	8000a55c <_dtoa_r+0x980>
8000a514:	58 01       	cp.w	r1,0
8000a516:	c1 11       	brne	8000a538 <_dtoa_r+0x95c>
8000a518:	04 9b       	mov	r11,r2
8000a51a:	02 99       	mov	r9,r1
8000a51c:	30 5a       	mov	r10,5
8000a51e:	0e 9c       	mov	r12,r7
8000a520:	e0 a0 07 ec 	rcall	8000b4f8 <__multadd>
8000a524:	18 92       	mov	r2,r12
8000a526:	18 9b       	mov	r11,r12
8000a528:	06 9c       	mov	r12,r3
8000a52a:	e0 a0 05 f8 	rcall	8000b11a <__mcmp>
8000a52e:	e0 89 00 0f 	brgt	8000a54c <_dtoa_r+0x970>
8000a532:	c0 38       	rjmp	8000a538 <_dtoa_r+0x95c>
8000a534:	30 02       	mov	r2,0
8000a536:	04 94       	mov	r4,r2
8000a538:	40 ea       	lddsp	r10,sp[0x38]
8000a53a:	30 09       	mov	r9,0
8000a53c:	5c da       	com	r10
8000a53e:	40 85       	lddsp	r5,sp[0x20]
8000a540:	50 6a       	stdsp	sp[0x18],r10
8000a542:	50 49       	stdsp	sp[0x10],r9
8000a544:	c0 f9       	rjmp	8000a762 <_dtoa_r+0xb86>
8000a546:	08 92       	mov	r2,r4
8000a548:	40 66       	lddsp	r6,sp[0x18]
8000a54a:	04 94       	mov	r4,r2
8000a54c:	2f f6       	sub	r6,-1
8000a54e:	50 66       	stdsp	sp[0x18],r6
8000a550:	33 18       	mov	r8,49
8000a552:	40 85       	lddsp	r5,sp[0x20]
8000a554:	0a c8       	st.b	r5++,r8
8000a556:	30 08       	mov	r8,0
8000a558:	50 48       	stdsp	sp[0x10],r8
8000a55a:	c0 49       	rjmp	8000a762 <_dtoa_r+0xb86>
8000a55c:	40 dc       	lddsp	r12,sp[0x34]
8000a55e:	58 0c       	cp.w	r12,0
8000a560:	e0 80 00 b5 	breq	8000a6ca <_dtoa_r+0xaee>
8000a564:	58 05       	cp.w	r5,0
8000a566:	e0 8a 00 08 	brle	8000a576 <_dtoa_r+0x99a>
8000a56a:	08 9b       	mov	r11,r4
8000a56c:	0a 9a       	mov	r10,r5
8000a56e:	0e 9c       	mov	r12,r7
8000a570:	e0 a0 06 f8 	rcall	8000b360 <__lshift>
8000a574:	18 94       	mov	r4,r12
8000a576:	40 6b       	lddsp	r11,sp[0x18]
8000a578:	58 0b       	cp.w	r11,0
8000a57a:	c0 31       	brne	8000a580 <_dtoa_r+0x9a4>
8000a57c:	08 9c       	mov	r12,r4
8000a57e:	c1 38       	rjmp	8000a5a4 <_dtoa_r+0x9c8>
8000a580:	68 1b       	ld.w	r11,r4[0x4]
8000a582:	0e 9c       	mov	r12,r7
8000a584:	e0 a0 05 fe 	rcall	8000b180 <_Balloc>
8000a588:	68 4a       	ld.w	r10,r4[0x10]
8000a58a:	18 95       	mov	r5,r12
8000a58c:	e8 cb ff f4 	sub	r11,r4,-12
8000a590:	2f ea       	sub	r10,-2
8000a592:	2f 4c       	sub	r12,-12
8000a594:	a3 6a       	lsl	r10,0x2
8000a596:	fe b0 e6 4f 	rcall	80007234 <memcpy>
8000a59a:	0a 9b       	mov	r11,r5
8000a59c:	30 1a       	mov	r10,1
8000a59e:	0e 9c       	mov	r12,r7
8000a5a0:	e0 a0 06 e0 	rcall	8000b360 <__lshift>
8000a5a4:	50 44       	stdsp	sp[0x10],r4
8000a5a6:	40 3a       	lddsp	r10,sp[0xc]
8000a5a8:	30 19       	mov	r9,1
8000a5aa:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a5ae:	18 94       	mov	r4,r12
8000a5b0:	50 da       	stdsp	sp[0x34],r10
8000a5b2:	40 85       	lddsp	r5,sp[0x20]
8000a5b4:	50 99       	stdsp	sp[0x24],r9
8000a5b6:	50 26       	stdsp	sp[0x8],r6
8000a5b8:	50 e1       	stdsp	sp[0x38],r1
8000a5ba:	04 9b       	mov	r11,r2
8000a5bc:	06 9c       	mov	r12,r3
8000a5be:	fe b0 fa 7f 	rcall	80009abc <quorem>
8000a5c2:	40 4b       	lddsp	r11,sp[0x10]
8000a5c4:	f8 c0 ff d0 	sub	r0,r12,-48
8000a5c8:	06 9c       	mov	r12,r3
8000a5ca:	e0 a0 05 a8 	rcall	8000b11a <__mcmp>
8000a5ce:	08 9a       	mov	r10,r4
8000a5d0:	50 6c       	stdsp	sp[0x18],r12
8000a5d2:	04 9b       	mov	r11,r2
8000a5d4:	0e 9c       	mov	r12,r7
8000a5d6:	e0 a0 06 5d 	rcall	8000b290 <__mdiff>
8000a5da:	18 91       	mov	r1,r12
8000a5dc:	78 38       	ld.w	r8,r12[0xc]
8000a5de:	58 08       	cp.w	r8,0
8000a5e0:	c0 30       	breq	8000a5e6 <_dtoa_r+0xa0a>
8000a5e2:	30 16       	mov	r6,1
8000a5e4:	c0 68       	rjmp	8000a5f0 <_dtoa_r+0xa14>
8000a5e6:	18 9b       	mov	r11,r12
8000a5e8:	06 9c       	mov	r12,r3
8000a5ea:	e0 a0 05 98 	rcall	8000b11a <__mcmp>
8000a5ee:	18 96       	mov	r6,r12
8000a5f0:	0e 9c       	mov	r12,r7
8000a5f2:	02 9b       	mov	r11,r1
8000a5f4:	e0 a0 05 ac 	rcall	8000b14c <_Bfree>
8000a5f8:	40 cc       	lddsp	r12,sp[0x30]
8000a5fa:	ed ec 10 08 	or	r8,r6,r12
8000a5fe:	c0 d1       	brne	8000a618 <_dtoa_r+0xa3c>
8000a600:	40 db       	lddsp	r11,sp[0x34]
8000a602:	58 0b       	cp.w	r11,0
8000a604:	c0 a1       	brne	8000a618 <_dtoa_r+0xa3c>
8000a606:	40 26       	lddsp	r6,sp[0x8]
8000a608:	e0 40 00 39 	cp.w	r0,57
8000a60c:	c3 00       	breq	8000a66c <_dtoa_r+0xa90>
8000a60e:	40 6a       	lddsp	r10,sp[0x18]
8000a610:	58 0a       	cp.w	r10,0
8000a612:	e0 89 00 24 	brgt	8000a65a <_dtoa_r+0xa7e>
8000a616:	c2 f8       	rjmp	8000a674 <_dtoa_r+0xa98>
8000a618:	40 69       	lddsp	r9,sp[0x18]
8000a61a:	58 09       	cp.w	r9,0
8000a61c:	c0 85       	brlt	8000a62c <_dtoa_r+0xa50>
8000a61e:	12 98       	mov	r8,r9
8000a620:	40 cc       	lddsp	r12,sp[0x30]
8000a622:	18 48       	or	r8,r12
8000a624:	c1 d1       	brne	8000a65e <_dtoa_r+0xa82>
8000a626:	40 db       	lddsp	r11,sp[0x34]
8000a628:	58 0b       	cp.w	r11,0
8000a62a:	c1 a1       	brne	8000a65e <_dtoa_r+0xa82>
8000a62c:	0c 99       	mov	r9,r6
8000a62e:	40 26       	lddsp	r6,sp[0x8]
8000a630:	58 09       	cp.w	r9,0
8000a632:	e0 8a 00 21 	brle	8000a674 <_dtoa_r+0xa98>
8000a636:	06 9b       	mov	r11,r3
8000a638:	30 1a       	mov	r10,1
8000a63a:	0e 9c       	mov	r12,r7
8000a63c:	e0 a0 06 92 	rcall	8000b360 <__lshift>
8000a640:	04 9b       	mov	r11,r2
8000a642:	18 93       	mov	r3,r12
8000a644:	e0 a0 05 6b 	rcall	8000b11a <__mcmp>
8000a648:	e0 89 00 06 	brgt	8000a654 <_dtoa_r+0xa78>
8000a64c:	c1 41       	brne	8000a674 <_dtoa_r+0xa98>
8000a64e:	ed b0 00 00 	bld	r0,0x0
8000a652:	c1 11       	brne	8000a674 <_dtoa_r+0xa98>
8000a654:	e0 40 00 39 	cp.w	r0,57
8000a658:	c0 a0       	breq	8000a66c <_dtoa_r+0xa90>
8000a65a:	2f f0       	sub	r0,-1
8000a65c:	c0 c8       	rjmp	8000a674 <_dtoa_r+0xa98>
8000a65e:	58 06       	cp.w	r6,0
8000a660:	e0 8a 00 0c 	brle	8000a678 <_dtoa_r+0xa9c>
8000a664:	40 26       	lddsp	r6,sp[0x8]
8000a666:	e0 40 00 39 	cp.w	r0,57
8000a66a:	c0 41       	brne	8000a672 <_dtoa_r+0xa96>
8000a66c:	33 98       	mov	r8,57
8000a66e:	0a c8       	st.b	r5++,r8
8000a670:	c6 78       	rjmp	8000a73e <_dtoa_r+0xb62>
8000a672:	2f f0       	sub	r0,-1
8000a674:	0a c0       	st.b	r5++,r0
8000a676:	c7 58       	rjmp	8000a760 <_dtoa_r+0xb84>
8000a678:	0a c0       	st.b	r5++,r0
8000a67a:	40 9a       	lddsp	r10,sp[0x24]
8000a67c:	40 e9       	lddsp	r9,sp[0x38]
8000a67e:	12 3a       	cp.w	r10,r9
8000a680:	c4 30       	breq	8000a706 <_dtoa_r+0xb2a>
8000a682:	06 9b       	mov	r11,r3
8000a684:	30 09       	mov	r9,0
8000a686:	30 aa       	mov	r10,10
8000a688:	0e 9c       	mov	r12,r7
8000a68a:	e0 a0 07 37 	rcall	8000b4f8 <__multadd>
8000a68e:	40 48       	lddsp	r8,sp[0x10]
8000a690:	18 93       	mov	r3,r12
8000a692:	08 38       	cp.w	r8,r4
8000a694:	c0 91       	brne	8000a6a6 <_dtoa_r+0xaca>
8000a696:	10 9b       	mov	r11,r8
8000a698:	30 09       	mov	r9,0
8000a69a:	30 aa       	mov	r10,10
8000a69c:	0e 9c       	mov	r12,r7
8000a69e:	e0 a0 07 2d 	rcall	8000b4f8 <__multadd>
8000a6a2:	50 4c       	stdsp	sp[0x10],r12
8000a6a4:	c0 e8       	rjmp	8000a6c0 <_dtoa_r+0xae4>
8000a6a6:	40 4b       	lddsp	r11,sp[0x10]
8000a6a8:	30 09       	mov	r9,0
8000a6aa:	30 aa       	mov	r10,10
8000a6ac:	0e 9c       	mov	r12,r7
8000a6ae:	e0 a0 07 25 	rcall	8000b4f8 <__multadd>
8000a6b2:	08 9b       	mov	r11,r4
8000a6b4:	50 4c       	stdsp	sp[0x10],r12
8000a6b6:	30 09       	mov	r9,0
8000a6b8:	30 aa       	mov	r10,10
8000a6ba:	0e 9c       	mov	r12,r7
8000a6bc:	e0 a0 07 1e 	rcall	8000b4f8 <__multadd>
8000a6c0:	18 94       	mov	r4,r12
8000a6c2:	40 9c       	lddsp	r12,sp[0x24]
8000a6c4:	2f fc       	sub	r12,-1
8000a6c6:	50 9c       	stdsp	sp[0x24],r12
8000a6c8:	c7 9b       	rjmp	8000a5ba <_dtoa_r+0x9de>
8000a6ca:	30 18       	mov	r8,1
8000a6cc:	06 90       	mov	r0,r3
8000a6ce:	40 85       	lddsp	r5,sp[0x20]
8000a6d0:	08 93       	mov	r3,r4
8000a6d2:	0c 94       	mov	r4,r6
8000a6d4:	10 96       	mov	r6,r8
8000a6d6:	04 9b       	mov	r11,r2
8000a6d8:	00 9c       	mov	r12,r0
8000a6da:	fe b0 f9 f1 	rcall	80009abc <quorem>
8000a6de:	2d 0c       	sub	r12,-48
8000a6e0:	0a cc       	st.b	r5++,r12
8000a6e2:	02 36       	cp.w	r6,r1
8000a6e4:	c0 a4       	brge	8000a6f8 <_dtoa_r+0xb1c>
8000a6e6:	00 9b       	mov	r11,r0
8000a6e8:	30 09       	mov	r9,0
8000a6ea:	30 aa       	mov	r10,10
8000a6ec:	0e 9c       	mov	r12,r7
8000a6ee:	2f f6       	sub	r6,-1
8000a6f0:	e0 a0 07 04 	rcall	8000b4f8 <__multadd>
8000a6f4:	18 90       	mov	r0,r12
8000a6f6:	cf 0b       	rjmp	8000a6d6 <_dtoa_r+0xafa>
8000a6f8:	08 96       	mov	r6,r4
8000a6fa:	30 0b       	mov	r11,0
8000a6fc:	06 94       	mov	r4,r3
8000a6fe:	50 4b       	stdsp	sp[0x10],r11
8000a700:	00 93       	mov	r3,r0
8000a702:	18 90       	mov	r0,r12
8000a704:	c0 28       	rjmp	8000a708 <_dtoa_r+0xb2c>
8000a706:	40 26       	lddsp	r6,sp[0x8]
8000a708:	06 9b       	mov	r11,r3
8000a70a:	30 1a       	mov	r10,1
8000a70c:	0e 9c       	mov	r12,r7
8000a70e:	e0 a0 06 29 	rcall	8000b360 <__lshift>
8000a712:	04 9b       	mov	r11,r2
8000a714:	18 93       	mov	r3,r12
8000a716:	e0 a0 05 02 	rcall	8000b11a <__mcmp>
8000a71a:	e0 89 00 12 	brgt	8000a73e <_dtoa_r+0xb62>
8000a71e:	c1 b1       	brne	8000a754 <_dtoa_r+0xb78>
8000a720:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000a724:	c0 d1       	brne	8000a73e <_dtoa_r+0xb62>
8000a726:	c1 78       	rjmp	8000a754 <_dtoa_r+0xb78>
8000a728:	40 89       	lddsp	r9,sp[0x20]
8000a72a:	12 38       	cp.w	r8,r9
8000a72c:	c0 30       	breq	8000a732 <_dtoa_r+0xb56>
8000a72e:	10 95       	mov	r5,r8
8000a730:	c0 88       	rjmp	8000a740 <_dtoa_r+0xb64>
8000a732:	2f f6       	sub	r6,-1
8000a734:	50 66       	stdsp	sp[0x18],r6
8000a736:	33 18       	mov	r8,49
8000a738:	40 8c       	lddsp	r12,sp[0x20]
8000a73a:	b8 88       	st.b	r12[0x0],r8
8000a73c:	c1 38       	rjmp	8000a762 <_dtoa_r+0xb86>
8000a73e:	33 9a       	mov	r10,57
8000a740:	0a 98       	mov	r8,r5
8000a742:	11 79       	ld.ub	r9,--r8
8000a744:	f4 09 18 00 	cp.b	r9,r10
8000a748:	cf 00       	breq	8000a728 <_dtoa_r+0xb4c>
8000a74a:	2f f9       	sub	r9,-1
8000a74c:	b0 89       	st.b	r8[0x0],r9
8000a74e:	c0 98       	rjmp	8000a760 <_dtoa_r+0xb84>
8000a750:	10 95       	mov	r5,r8
8000a752:	c0 28       	rjmp	8000a756 <_dtoa_r+0xb7a>
8000a754:	33 09       	mov	r9,48
8000a756:	0a 98       	mov	r8,r5
8000a758:	11 7a       	ld.ub	r10,--r8
8000a75a:	f2 0a 18 00 	cp.b	r10,r9
8000a75e:	cf 90       	breq	8000a750 <_dtoa_r+0xb74>
8000a760:	50 66       	stdsp	sp[0x18],r6
8000a762:	04 9b       	mov	r11,r2
8000a764:	0e 9c       	mov	r12,r7
8000a766:	e0 a0 04 f3 	rcall	8000b14c <_Bfree>
8000a76a:	58 04       	cp.w	r4,0
8000a76c:	c1 20       	breq	8000a790 <_dtoa_r+0xbb4>
8000a76e:	40 4b       	lddsp	r11,sp[0x10]
8000a770:	08 3b       	cp.w	r11,r4
8000a772:	5f 19       	srne	r9
8000a774:	58 0b       	cp.w	r11,0
8000a776:	5f 18       	srne	r8
8000a778:	f3 e8 00 08 	and	r8,r9,r8
8000a77c:	c0 40       	breq	8000a784 <_dtoa_r+0xba8>
8000a77e:	0e 9c       	mov	r12,r7
8000a780:	e0 a0 04 e6 	rcall	8000b14c <_Bfree>
8000a784:	08 9b       	mov	r11,r4
8000a786:	0e 9c       	mov	r12,r7
8000a788:	e0 a0 04 e2 	rcall	8000b14c <_Bfree>
8000a78c:	c0 28       	rjmp	8000a790 <_dtoa_r+0xbb4>
8000a78e:	50 66       	stdsp	sp[0x18],r6
8000a790:	0e 9c       	mov	r12,r7
8000a792:	06 9b       	mov	r11,r3
8000a794:	e0 a0 04 dc 	rcall	8000b14c <_Bfree>
8000a798:	30 08       	mov	r8,0
8000a79a:	aa 88       	st.b	r5[0x0],r8
8000a79c:	40 68       	lddsp	r8,sp[0x18]
8000a79e:	41 5a       	lddsp	r10,sp[0x54]
8000a7a0:	2f f8       	sub	r8,-1
8000a7a2:	41 29       	lddsp	r9,sp[0x48]
8000a7a4:	95 08       	st.w	r10[0x0],r8
8000a7a6:	40 8c       	lddsp	r12,sp[0x20]
8000a7a8:	58 09       	cp.w	r9,0
8000a7aa:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000a7ae:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000a7b2:	2e 6d       	sub	sp,-104
8000a7b4:	d8 32       	popm	r0-r7,pc
8000a7b6:	d7 03       	nop

8000a7b8 <__errno>:
8000a7b8:	e0 68 0a 38 	mov	r8,2616
8000a7bc:	70 0c       	ld.w	r12,r8[0x0]
8000a7be:	2f 4c       	sub	r12,-12
8000a7c0:	5e fc       	retal	r12
8000a7c2:	d7 03       	nop

8000a7c4 <_fflush_r>:
8000a7c4:	d4 21       	pushm	r4-r7,lr
8000a7c6:	16 97       	mov	r7,r11
8000a7c8:	18 96       	mov	r6,r12
8000a7ca:	76 48       	ld.w	r8,r11[0x10]
8000a7cc:	58 08       	cp.w	r8,0
8000a7ce:	c7 f0       	breq	8000a8cc <_fflush_r+0x108>
8000a7d0:	58 0c       	cp.w	r12,0
8000a7d2:	c0 50       	breq	8000a7dc <_fflush_r+0x18>
8000a7d4:	78 68       	ld.w	r8,r12[0x18]
8000a7d6:	58 08       	cp.w	r8,0
8000a7d8:	c0 21       	brne	8000a7dc <_fflush_r+0x18>
8000a7da:	cc dc       	rcall	8000a974 <__sinit>
8000a7dc:	fe c8 ce 44 	sub	r8,pc,-12732
8000a7e0:	10 37       	cp.w	r7,r8
8000a7e2:	c0 31       	brne	8000a7e8 <_fflush_r+0x24>
8000a7e4:	6c 07       	ld.w	r7,r6[0x0]
8000a7e6:	c0 c8       	rjmp	8000a7fe <_fflush_r+0x3a>
8000a7e8:	fe c8 ce 30 	sub	r8,pc,-12752
8000a7ec:	10 37       	cp.w	r7,r8
8000a7ee:	c0 31       	brne	8000a7f4 <_fflush_r+0x30>
8000a7f0:	6c 17       	ld.w	r7,r6[0x4]
8000a7f2:	c0 68       	rjmp	8000a7fe <_fflush_r+0x3a>
8000a7f4:	fe c8 ce 1c 	sub	r8,pc,-12772
8000a7f8:	10 37       	cp.w	r7,r8
8000a7fa:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000a7fe:	8e 6a       	ld.sh	r10,r7[0xc]
8000a800:	14 98       	mov	r8,r10
8000a802:	ed ba 00 03 	bld	r10,0x3
8000a806:	c4 20       	breq	8000a88a <_fflush_r+0xc6>
8000a808:	ab ba       	sbr	r10,0xb
8000a80a:	ae 6a       	st.h	r7[0xc],r10
8000a80c:	6e 18       	ld.w	r8,r7[0x4]
8000a80e:	58 08       	cp.w	r8,0
8000a810:	e0 89 00 06 	brgt	8000a81c <_fflush_r+0x58>
8000a814:	6f 08       	ld.w	r8,r7[0x40]
8000a816:	58 08       	cp.w	r8,0
8000a818:	e0 8a 00 5a 	brle	8000a8cc <_fflush_r+0x108>
8000a81c:	6e b8       	ld.w	r8,r7[0x2c]
8000a81e:	58 08       	cp.w	r8,0
8000a820:	c5 60       	breq	8000a8cc <_fflush_r+0x108>
8000a822:	e2 1a 10 00 	andl	r10,0x1000,COH
8000a826:	c0 30       	breq	8000a82c <_fflush_r+0x68>
8000a828:	6f 55       	ld.w	r5,r7[0x54]
8000a82a:	c0 f8       	rjmp	8000a848 <_fflush_r+0x84>
8000a82c:	30 19       	mov	r9,1
8000a82e:	6e 8b       	ld.w	r11,r7[0x20]
8000a830:	0c 9c       	mov	r12,r6
8000a832:	5d 18       	icall	r8
8000a834:	18 95       	mov	r5,r12
8000a836:	5b fc       	cp.w	r12,-1
8000a838:	c0 81       	brne	8000a848 <_fflush_r+0x84>
8000a83a:	6c 38       	ld.w	r8,r6[0xc]
8000a83c:	59 d8       	cp.w	r8,29
8000a83e:	c4 70       	breq	8000a8cc <_fflush_r+0x108>
8000a840:	8e 68       	ld.sh	r8,r7[0xc]
8000a842:	a7 a8       	sbr	r8,0x6
8000a844:	ae 68       	st.h	r7[0xc],r8
8000a846:	d8 22       	popm	r4-r7,pc
8000a848:	8e 68       	ld.sh	r8,r7[0xc]
8000a84a:	ed b8 00 02 	bld	r8,0x2
8000a84e:	c0 91       	brne	8000a860 <_fflush_r+0x9c>
8000a850:	6e 18       	ld.w	r8,r7[0x4]
8000a852:	10 15       	sub	r5,r8
8000a854:	6e d8       	ld.w	r8,r7[0x34]
8000a856:	58 08       	cp.w	r8,0
8000a858:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000a85c:	eb d8 e1 15 	subne	r5,r5,r8
8000a860:	6e b8       	ld.w	r8,r7[0x2c]
8000a862:	0c 9c       	mov	r12,r6
8000a864:	30 09       	mov	r9,0
8000a866:	0a 9a       	mov	r10,r5
8000a868:	6e 8b       	ld.w	r11,r7[0x20]
8000a86a:	5d 18       	icall	r8
8000a86c:	8e 68       	ld.sh	r8,r7[0xc]
8000a86e:	0a 3c       	cp.w	r12,r5
8000a870:	c2 61       	brne	8000a8bc <_fflush_r+0xf8>
8000a872:	ab d8       	cbr	r8,0xb
8000a874:	30 0c       	mov	r12,0
8000a876:	6e 49       	ld.w	r9,r7[0x10]
8000a878:	ae 68       	st.h	r7[0xc],r8
8000a87a:	8f 1c       	st.w	r7[0x4],r12
8000a87c:	8f 09       	st.w	r7[0x0],r9
8000a87e:	ed b8 00 0c 	bld	r8,0xc
8000a882:	c2 51       	brne	8000a8cc <_fflush_r+0x108>
8000a884:	ef 45 00 54 	st.w	r7[84],r5
8000a888:	d8 22       	popm	r4-r7,pc
8000a88a:	6e 45       	ld.w	r5,r7[0x10]
8000a88c:	58 05       	cp.w	r5,0
8000a88e:	c1 f0       	breq	8000a8cc <_fflush_r+0x108>
8000a890:	6e 04       	ld.w	r4,r7[0x0]
8000a892:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000a896:	8f 05       	st.w	r7[0x0],r5
8000a898:	f9 b8 01 00 	movne	r8,0
8000a89c:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000a8a0:	0a 14       	sub	r4,r5
8000a8a2:	8f 28       	st.w	r7[0x8],r8
8000a8a4:	c1 18       	rjmp	8000a8c6 <_fflush_r+0x102>
8000a8a6:	08 99       	mov	r9,r4
8000a8a8:	0a 9a       	mov	r10,r5
8000a8aa:	6e a8       	ld.w	r8,r7[0x28]
8000a8ac:	6e 8b       	ld.w	r11,r7[0x20]
8000a8ae:	0c 9c       	mov	r12,r6
8000a8b0:	5d 18       	icall	r8
8000a8b2:	18 14       	sub	r4,r12
8000a8b4:	58 0c       	cp.w	r12,0
8000a8b6:	e0 89 00 07 	brgt	8000a8c4 <_fflush_r+0x100>
8000a8ba:	8e 68       	ld.sh	r8,r7[0xc]
8000a8bc:	a7 a8       	sbr	r8,0x6
8000a8be:	3f fc       	mov	r12,-1
8000a8c0:	ae 68       	st.h	r7[0xc],r8
8000a8c2:	d8 22       	popm	r4-r7,pc
8000a8c4:	18 05       	add	r5,r12
8000a8c6:	58 04       	cp.w	r4,0
8000a8c8:	fe 99 ff ef 	brgt	8000a8a6 <_fflush_r+0xe2>
8000a8cc:	d8 2a       	popm	r4-r7,pc,r12=0
8000a8ce:	d7 03       	nop

8000a8d0 <__sfp_lock_acquire>:
8000a8d0:	5e fc       	retal	r12

8000a8d2 <__sfp_lock_release>:
8000a8d2:	5e fc       	retal	r12

8000a8d4 <_cleanup_r>:
8000a8d4:	d4 01       	pushm	lr
8000a8d6:	fe cb f0 ae 	sub	r11,pc,-3922
8000a8da:	e0 a0 02 f7 	rcall	8000aec8 <_fwalk>
8000a8de:	d8 02       	popm	pc

8000a8e0 <__sfmoreglue>:
8000a8e0:	d4 21       	pushm	r4-r7,lr
8000a8e2:	16 95       	mov	r5,r11
8000a8e4:	f6 06 10 5c 	mul	r6,r11,92
8000a8e8:	ec cb ff f4 	sub	r11,r6,-12
8000a8ec:	fe b0 e2 88 	rcall	80006dfc <_malloc_r>
8000a8f0:	18 97       	mov	r7,r12
8000a8f2:	c0 90       	breq	8000a904 <__sfmoreglue+0x24>
8000a8f4:	99 15       	st.w	r12[0x4],r5
8000a8f6:	30 0b       	mov	r11,0
8000a8f8:	2f 4c       	sub	r12,-12
8000a8fa:	0c 9a       	mov	r10,r6
8000a8fc:	8f 2c       	st.w	r7[0x8],r12
8000a8fe:	8f 0b       	st.w	r7[0x0],r11
8000a900:	fe b0 e5 3e 	rcall	8000737c <memset>
8000a904:	0e 9c       	mov	r12,r7
8000a906:	d8 22       	popm	r4-r7,pc

8000a908 <__sfp>:
8000a908:	d4 21       	pushm	r4-r7,lr
8000a90a:	fe c8 cf 0e 	sub	r8,pc,-12530
8000a90e:	18 96       	mov	r6,r12
8000a910:	70 07       	ld.w	r7,r8[0x0]
8000a912:	6e 68       	ld.w	r8,r7[0x18]
8000a914:	58 08       	cp.w	r8,0
8000a916:	c0 31       	brne	8000a91c <__sfp+0x14>
8000a918:	0e 9c       	mov	r12,r7
8000a91a:	c2 dc       	rcall	8000a974 <__sinit>
8000a91c:	ee c7 ff 28 	sub	r7,r7,-216
8000a920:	30 05       	mov	r5,0
8000a922:	6e 2c       	ld.w	r12,r7[0x8]
8000a924:	6e 18       	ld.w	r8,r7[0x4]
8000a926:	c0 68       	rjmp	8000a932 <__sfp+0x2a>
8000a928:	98 69       	ld.sh	r9,r12[0xc]
8000a92a:	ea 09 19 00 	cp.h	r9,r5
8000a92e:	c1 10       	breq	8000a950 <__sfp+0x48>
8000a930:	2a 4c       	sub	r12,-92
8000a932:	20 18       	sub	r8,1
8000a934:	cf a7       	brpl	8000a928 <__sfp+0x20>
8000a936:	6e 08       	ld.w	r8,r7[0x0]
8000a938:	58 08       	cp.w	r8,0
8000a93a:	c0 61       	brne	8000a946 <__sfp+0x3e>
8000a93c:	30 4b       	mov	r11,4
8000a93e:	0c 9c       	mov	r12,r6
8000a940:	cd 0f       	rcall	8000a8e0 <__sfmoreglue>
8000a942:	8f 0c       	st.w	r7[0x0],r12
8000a944:	c0 30       	breq	8000a94a <__sfp+0x42>
8000a946:	6e 07       	ld.w	r7,r7[0x0]
8000a948:	ce db       	rjmp	8000a922 <__sfp+0x1a>
8000a94a:	30 c8       	mov	r8,12
8000a94c:	8d 38       	st.w	r6[0xc],r8
8000a94e:	d8 22       	popm	r4-r7,pc
8000a950:	30 08       	mov	r8,0
8000a952:	f9 48 00 4c 	st.w	r12[76],r8
8000a956:	99 08       	st.w	r12[0x0],r8
8000a958:	99 28       	st.w	r12[0x8],r8
8000a95a:	99 18       	st.w	r12[0x4],r8
8000a95c:	99 48       	st.w	r12[0x10],r8
8000a95e:	99 58       	st.w	r12[0x14],r8
8000a960:	99 68       	st.w	r12[0x18],r8
8000a962:	99 d8       	st.w	r12[0x34],r8
8000a964:	99 e8       	st.w	r12[0x38],r8
8000a966:	f9 48 00 48 	st.w	r12[72],r8
8000a96a:	3f f8       	mov	r8,-1
8000a96c:	b8 78       	st.h	r12[0xe],r8
8000a96e:	30 18       	mov	r8,1
8000a970:	b8 68       	st.h	r12[0xc],r8
8000a972:	d8 22       	popm	r4-r7,pc

8000a974 <__sinit>:
8000a974:	d4 21       	pushm	r4-r7,lr
8000a976:	18 96       	mov	r6,r12
8000a978:	78 67       	ld.w	r7,r12[0x18]
8000a97a:	58 07       	cp.w	r7,0
8000a97c:	c4 91       	brne	8000aa0e <__sinit+0x9a>
8000a97e:	fe c8 00 aa 	sub	r8,pc,170
8000a982:	30 15       	mov	r5,1
8000a984:	99 a8       	st.w	r12[0x28],r8
8000a986:	f9 47 00 d8 	st.w	r12[216],r7
8000a98a:	f9 47 00 dc 	st.w	r12[220],r7
8000a98e:	f9 47 00 e0 	st.w	r12[224],r7
8000a992:	99 65       	st.w	r12[0x18],r5
8000a994:	cb af       	rcall	8000a908 <__sfp>
8000a996:	8d 0c       	st.w	r6[0x0],r12
8000a998:	0c 9c       	mov	r12,r6
8000a99a:	cb 7f       	rcall	8000a908 <__sfp>
8000a99c:	8d 1c       	st.w	r6[0x4],r12
8000a99e:	0c 9c       	mov	r12,r6
8000a9a0:	cb 4f       	rcall	8000a908 <__sfp>
8000a9a2:	6c 09       	ld.w	r9,r6[0x0]
8000a9a4:	30 48       	mov	r8,4
8000a9a6:	93 07       	st.w	r9[0x0],r7
8000a9a8:	b2 68       	st.h	r9[0xc],r8
8000a9aa:	93 17       	st.w	r9[0x4],r7
8000a9ac:	93 27       	st.w	r9[0x8],r7
8000a9ae:	6c 18       	ld.w	r8,r6[0x4]
8000a9b0:	b2 77       	st.h	r9[0xe],r7
8000a9b2:	93 47       	st.w	r9[0x10],r7
8000a9b4:	93 57       	st.w	r9[0x14],r7
8000a9b6:	93 67       	st.w	r9[0x18],r7
8000a9b8:	93 89       	st.w	r9[0x20],r9
8000a9ba:	91 07       	st.w	r8[0x0],r7
8000a9bc:	91 17       	st.w	r8[0x4],r7
8000a9be:	91 27       	st.w	r8[0x8],r7
8000a9c0:	fe ce f3 24 	sub	lr,pc,-3292
8000a9c4:	fe cb f3 54 	sub	r11,pc,-3244
8000a9c8:	93 9e       	st.w	r9[0x24],lr
8000a9ca:	93 ab       	st.w	r9[0x28],r11
8000a9cc:	fe ca f3 7c 	sub	r10,pc,-3204
8000a9d0:	fe c4 f3 88 	sub	r4,pc,-3192
8000a9d4:	93 ba       	st.w	r9[0x2c],r10
8000a9d6:	93 c4       	st.w	r9[0x30],r4
8000a9d8:	30 99       	mov	r9,9
8000a9da:	b0 69       	st.h	r8[0xc],r9
8000a9dc:	b0 75       	st.h	r8[0xe],r5
8000a9de:	91 c4       	st.w	r8[0x30],r4
8000a9e0:	91 47       	st.w	r8[0x10],r7
8000a9e2:	91 57       	st.w	r8[0x14],r7
8000a9e4:	91 67       	st.w	r8[0x18],r7
8000a9e6:	91 88       	st.w	r8[0x20],r8
8000a9e8:	91 9e       	st.w	r8[0x24],lr
8000a9ea:	91 ab       	st.w	r8[0x28],r11
8000a9ec:	91 ba       	st.w	r8[0x2c],r10
8000a9ee:	8d 2c       	st.w	r6[0x8],r12
8000a9f0:	31 28       	mov	r8,18
8000a9f2:	99 07       	st.w	r12[0x0],r7
8000a9f4:	b8 68       	st.h	r12[0xc],r8
8000a9f6:	99 17       	st.w	r12[0x4],r7
8000a9f8:	99 27       	st.w	r12[0x8],r7
8000a9fa:	30 28       	mov	r8,2
8000a9fc:	b8 78       	st.h	r12[0xe],r8
8000a9fe:	99 c4       	st.w	r12[0x30],r4
8000aa00:	99 67       	st.w	r12[0x18],r7
8000aa02:	99 9e       	st.w	r12[0x24],lr
8000aa04:	99 ab       	st.w	r12[0x28],r11
8000aa06:	99 ba       	st.w	r12[0x2c],r10
8000aa08:	99 47       	st.w	r12[0x10],r7
8000aa0a:	99 57       	st.w	r12[0x14],r7
8000aa0c:	99 8c       	st.w	r12[0x20],r12
8000aa0e:	d8 22       	popm	r4-r7,pc

8000aa10 <_malloc_trim_r>:
8000aa10:	d4 21       	pushm	r4-r7,lr
8000aa12:	16 95       	mov	r5,r11
8000aa14:	18 97       	mov	r7,r12
8000aa16:	fe b0 d7 f1 	rcall	800059f8 <__malloc_lock>
8000aa1a:	e0 64 05 38 	mov	r4,1336
8000aa1e:	68 28       	ld.w	r8,r4[0x8]
8000aa20:	70 16       	ld.w	r6,r8[0x4]
8000aa22:	e0 16 ff fc 	andl	r6,0xfffc
8000aa26:	ec c8 ff 91 	sub	r8,r6,-111
8000aa2a:	f0 05 01 05 	sub	r5,r8,r5
8000aa2e:	e0 15 ff 80 	andl	r5,0xff80
8000aa32:	ea c5 00 80 	sub	r5,r5,128
8000aa36:	e0 45 00 7f 	cp.w	r5,127
8000aa3a:	e0 8a 00 25 	brle	8000aa84 <_malloc_trim_r+0x74>
8000aa3e:	30 0b       	mov	r11,0
8000aa40:	0e 9c       	mov	r12,r7
8000aa42:	fe b0 e6 05 	rcall	8000764c <_sbrk_r>
8000aa46:	68 28       	ld.w	r8,r4[0x8]
8000aa48:	0c 08       	add	r8,r6
8000aa4a:	10 3c       	cp.w	r12,r8
8000aa4c:	c1 c1       	brne	8000aa84 <_malloc_trim_r+0x74>
8000aa4e:	ea 0b 11 00 	rsub	r11,r5,0
8000aa52:	0e 9c       	mov	r12,r7
8000aa54:	fe b0 e5 fc 	rcall	8000764c <_sbrk_r>
8000aa58:	5b fc       	cp.w	r12,-1
8000aa5a:	c1 91       	brne	8000aa8c <_malloc_trim_r+0x7c>
8000aa5c:	30 0b       	mov	r11,0
8000aa5e:	0e 9c       	mov	r12,r7
8000aa60:	fe b0 e5 f6 	rcall	8000764c <_sbrk_r>
8000aa64:	68 28       	ld.w	r8,r4[0x8]
8000aa66:	f8 08 01 09 	sub	r9,r12,r8
8000aa6a:	58 f9       	cp.w	r9,15
8000aa6c:	e0 8a 00 0c 	brle	8000aa84 <_malloc_trim_r+0x74>
8000aa70:	a1 a9       	sbr	r9,0x0
8000aa72:	91 19       	st.w	r8[0x4],r9
8000aa74:	e0 68 09 44 	mov	r8,2372
8000aa78:	70 09       	ld.w	r9,r8[0x0]
8000aa7a:	e0 68 0d 50 	mov	r8,3408
8000aa7e:	f8 09 01 09 	sub	r9,r12,r9
8000aa82:	91 09       	st.w	r8[0x0],r9
8000aa84:	0e 9c       	mov	r12,r7
8000aa86:	fe b0 d7 bf 	rcall	80005a04 <__malloc_unlock>
8000aa8a:	d8 2a       	popm	r4-r7,pc,r12=0
8000aa8c:	68 28       	ld.w	r8,r4[0x8]
8000aa8e:	0a 16       	sub	r6,r5
8000aa90:	a1 a6       	sbr	r6,0x0
8000aa92:	91 16       	st.w	r8[0x4],r6
8000aa94:	e0 68 0d 50 	mov	r8,3408
8000aa98:	70 09       	ld.w	r9,r8[0x0]
8000aa9a:	0a 19       	sub	r9,r5
8000aa9c:	0e 9c       	mov	r12,r7
8000aa9e:	91 09       	st.w	r8[0x0],r9
8000aaa0:	fe b0 d7 b2 	rcall	80005a04 <__malloc_unlock>
8000aaa4:	da 2a       	popm	r4-r7,pc,r12=1
8000aaa6:	d7 03       	nop

8000aaa8 <_free_r>:
8000aaa8:	d4 21       	pushm	r4-r7,lr
8000aaaa:	16 96       	mov	r6,r11
8000aaac:	18 97       	mov	r7,r12
8000aaae:	58 0b       	cp.w	r11,0
8000aab0:	e0 80 00 c0 	breq	8000ac30 <_free_r+0x188>
8000aab4:	fe b0 d7 a2 	rcall	800059f8 <__malloc_lock>
8000aab8:	20 86       	sub	r6,8
8000aaba:	e0 6a 05 38 	mov	r10,1336
8000aabe:	6c 18       	ld.w	r8,r6[0x4]
8000aac0:	74 2e       	ld.w	lr,r10[0x8]
8000aac2:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000aac6:	a1 c8       	cbr	r8,0x0
8000aac8:	ec 08 00 09 	add	r9,r6,r8
8000aacc:	72 1b       	ld.w	r11,r9[0x4]
8000aace:	e0 1b ff fc 	andl	r11,0xfffc
8000aad2:	1c 39       	cp.w	r9,lr
8000aad4:	c1 e1       	brne	8000ab10 <_free_r+0x68>
8000aad6:	f6 08 00 08 	add	r8,r11,r8
8000aada:	58 0c       	cp.w	r12,0
8000aadc:	c0 81       	brne	8000aaec <_free_r+0x44>
8000aade:	6c 09       	ld.w	r9,r6[0x0]
8000aae0:	12 16       	sub	r6,r9
8000aae2:	12 08       	add	r8,r9
8000aae4:	6c 3b       	ld.w	r11,r6[0xc]
8000aae6:	6c 29       	ld.w	r9,r6[0x8]
8000aae8:	97 29       	st.w	r11[0x8],r9
8000aaea:	93 3b       	st.w	r9[0xc],r11
8000aaec:	10 99       	mov	r9,r8
8000aaee:	95 26       	st.w	r10[0x8],r6
8000aaf0:	a1 a9       	sbr	r9,0x0
8000aaf2:	8d 19       	st.w	r6[0x4],r9
8000aaf4:	e0 69 09 40 	mov	r9,2368
8000aaf8:	72 09       	ld.w	r9,r9[0x0]
8000aafa:	12 38       	cp.w	r8,r9
8000aafc:	c0 63       	brcs	8000ab08 <_free_r+0x60>
8000aafe:	e0 68 0d 4c 	mov	r8,3404
8000ab02:	0e 9c       	mov	r12,r7
8000ab04:	70 0b       	ld.w	r11,r8[0x0]
8000ab06:	c8 5f       	rcall	8000aa10 <_malloc_trim_r>
8000ab08:	0e 9c       	mov	r12,r7
8000ab0a:	fe b0 d7 7d 	rcall	80005a04 <__malloc_unlock>
8000ab0e:	d8 22       	popm	r4-r7,pc
8000ab10:	93 1b       	st.w	r9[0x4],r11
8000ab12:	58 0c       	cp.w	r12,0
8000ab14:	c0 30       	breq	8000ab1a <_free_r+0x72>
8000ab16:	30 0c       	mov	r12,0
8000ab18:	c1 08       	rjmp	8000ab38 <_free_r+0x90>
8000ab1a:	6c 0e       	ld.w	lr,r6[0x0]
8000ab1c:	f4 c5 ff f8 	sub	r5,r10,-8
8000ab20:	1c 16       	sub	r6,lr
8000ab22:	1c 08       	add	r8,lr
8000ab24:	6c 2e       	ld.w	lr,r6[0x8]
8000ab26:	0a 3e       	cp.w	lr,r5
8000ab28:	f9 bc 00 01 	moveq	r12,1
8000ab2c:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000ab30:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000ab34:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000ab38:	f2 0b 00 0e 	add	lr,r9,r11
8000ab3c:	7c 1e       	ld.w	lr,lr[0x4]
8000ab3e:	ed be 00 00 	bld	lr,0x0
8000ab42:	c1 40       	breq	8000ab6a <_free_r+0xc2>
8000ab44:	16 08       	add	r8,r11
8000ab46:	58 0c       	cp.w	r12,0
8000ab48:	c0 d1       	brne	8000ab62 <_free_r+0xba>
8000ab4a:	e0 6e 05 38 	mov	lr,1336
8000ab4e:	72 2b       	ld.w	r11,r9[0x8]
8000ab50:	2f 8e       	sub	lr,-8
8000ab52:	1c 3b       	cp.w	r11,lr
8000ab54:	c0 71       	brne	8000ab62 <_free_r+0xba>
8000ab56:	97 36       	st.w	r11[0xc],r6
8000ab58:	97 26       	st.w	r11[0x8],r6
8000ab5a:	8d 2b       	st.w	r6[0x8],r11
8000ab5c:	8d 3b       	st.w	r6[0xc],r11
8000ab5e:	30 1c       	mov	r12,1
8000ab60:	c0 58       	rjmp	8000ab6a <_free_r+0xc2>
8000ab62:	72 2b       	ld.w	r11,r9[0x8]
8000ab64:	72 39       	ld.w	r9,r9[0xc]
8000ab66:	93 2b       	st.w	r9[0x8],r11
8000ab68:	97 39       	st.w	r11[0xc],r9
8000ab6a:	10 99       	mov	r9,r8
8000ab6c:	ec 08 09 08 	st.w	r6[r8],r8
8000ab70:	a1 a9       	sbr	r9,0x0
8000ab72:	8d 19       	st.w	r6[0x4],r9
8000ab74:	58 0c       	cp.w	r12,0
8000ab76:	c5 a1       	brne	8000ac2a <_free_r+0x182>
8000ab78:	e0 48 01 ff 	cp.w	r8,511
8000ab7c:	e0 8b 00 13 	brhi	8000aba2 <_free_r+0xfa>
8000ab80:	a3 98       	lsr	r8,0x3
8000ab82:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000ab86:	72 2b       	ld.w	r11,r9[0x8]
8000ab88:	8d 39       	st.w	r6[0xc],r9
8000ab8a:	8d 2b       	st.w	r6[0x8],r11
8000ab8c:	97 36       	st.w	r11[0xc],r6
8000ab8e:	93 26       	st.w	r9[0x8],r6
8000ab90:	a3 48       	asr	r8,0x2
8000ab92:	74 19       	ld.w	r9,r10[0x4]
8000ab94:	30 1b       	mov	r11,1
8000ab96:	f6 08 09 48 	lsl	r8,r11,r8
8000ab9a:	f3 e8 10 08 	or	r8,r9,r8
8000ab9e:	95 18       	st.w	r10[0x4],r8
8000aba0:	c4 58       	rjmp	8000ac2a <_free_r+0x182>
8000aba2:	f0 0b 16 09 	lsr	r11,r8,0x9
8000aba6:	58 4b       	cp.w	r11,4
8000aba8:	e0 8b 00 06 	brhi	8000abb4 <_free_r+0x10c>
8000abac:	f0 0b 16 06 	lsr	r11,r8,0x6
8000abb0:	2c 8b       	sub	r11,-56
8000abb2:	c2 08       	rjmp	8000abf2 <_free_r+0x14a>
8000abb4:	59 4b       	cp.w	r11,20
8000abb6:	e0 8b 00 04 	brhi	8000abbe <_free_r+0x116>
8000abba:	2a 5b       	sub	r11,-91
8000abbc:	c1 b8       	rjmp	8000abf2 <_free_r+0x14a>
8000abbe:	e0 4b 00 54 	cp.w	r11,84
8000abc2:	e0 8b 00 06 	brhi	8000abce <_free_r+0x126>
8000abc6:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000abca:	29 2b       	sub	r11,-110
8000abcc:	c1 38       	rjmp	8000abf2 <_free_r+0x14a>
8000abce:	e0 4b 01 54 	cp.w	r11,340
8000abd2:	e0 8b 00 06 	brhi	8000abde <_free_r+0x136>
8000abd6:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000abda:	28 9b       	sub	r11,-119
8000abdc:	c0 b8       	rjmp	8000abf2 <_free_r+0x14a>
8000abde:	e0 4b 05 54 	cp.w	r11,1364
8000abe2:	e0 88 00 05 	brls	8000abec <_free_r+0x144>
8000abe6:	37 eb       	mov	r11,126
8000abe8:	c0 58       	rjmp	8000abf2 <_free_r+0x14a>
8000abea:	d7 03       	nop
8000abec:	f0 0b 16 12 	lsr	r11,r8,0x12
8000abf0:	28 4b       	sub	r11,-124
8000abf2:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000abf6:	78 29       	ld.w	r9,r12[0x8]
8000abf8:	18 39       	cp.w	r9,r12
8000abfa:	c0 e1       	brne	8000ac16 <_free_r+0x16e>
8000abfc:	74 18       	ld.w	r8,r10[0x4]
8000abfe:	a3 4b       	asr	r11,0x2
8000ac00:	30 1c       	mov	r12,1
8000ac02:	f8 0b 09 4b 	lsl	r11,r12,r11
8000ac06:	f1 eb 10 0b 	or	r11,r8,r11
8000ac0a:	12 98       	mov	r8,r9
8000ac0c:	95 1b       	st.w	r10[0x4],r11
8000ac0e:	c0 a8       	rjmp	8000ac22 <_free_r+0x17a>
8000ac10:	72 29       	ld.w	r9,r9[0x8]
8000ac12:	18 39       	cp.w	r9,r12
8000ac14:	c0 60       	breq	8000ac20 <_free_r+0x178>
8000ac16:	72 1a       	ld.w	r10,r9[0x4]
8000ac18:	e0 1a ff fc 	andl	r10,0xfffc
8000ac1c:	14 38       	cp.w	r8,r10
8000ac1e:	cf 93       	brcs	8000ac10 <_free_r+0x168>
8000ac20:	72 38       	ld.w	r8,r9[0xc]
8000ac22:	8d 38       	st.w	r6[0xc],r8
8000ac24:	8d 29       	st.w	r6[0x8],r9
8000ac26:	93 36       	st.w	r9[0xc],r6
8000ac28:	91 26       	st.w	r8[0x8],r6
8000ac2a:	0e 9c       	mov	r12,r7
8000ac2c:	fe b0 d6 ec 	rcall	80005a04 <__malloc_unlock>
8000ac30:	d8 22       	popm	r4-r7,pc
8000ac32:	d7 03       	nop

8000ac34 <__sfvwrite_r>:
8000ac34:	d4 31       	pushm	r0-r7,lr
8000ac36:	20 3d       	sub	sp,12
8000ac38:	14 94       	mov	r4,r10
8000ac3a:	18 95       	mov	r5,r12
8000ac3c:	16 97       	mov	r7,r11
8000ac3e:	74 28       	ld.w	r8,r10[0x8]
8000ac40:	58 08       	cp.w	r8,0
8000ac42:	e0 80 01 40 	breq	8000aec2 <__sfvwrite_r+0x28e>
8000ac46:	96 68       	ld.sh	r8,r11[0xc]
8000ac48:	ed b8 00 03 	bld	r8,0x3
8000ac4c:	c0 41       	brne	8000ac54 <__sfvwrite_r+0x20>
8000ac4e:	76 48       	ld.w	r8,r11[0x10]
8000ac50:	58 08       	cp.w	r8,0
8000ac52:	c0 c1       	brne	8000ac6a <__sfvwrite_r+0x36>
8000ac54:	0e 9b       	mov	r11,r7
8000ac56:	0a 9c       	mov	r12,r5
8000ac58:	fe b0 f6 c4 	rcall	800099e0 <__swsetup_r>
8000ac5c:	c0 70       	breq	8000ac6a <__sfvwrite_r+0x36>
8000ac5e:	8e 68       	ld.sh	r8,r7[0xc]
8000ac60:	a7 a8       	sbr	r8,0x6
8000ac62:	ae 68       	st.h	r7[0xc],r8
8000ac64:	30 98       	mov	r8,9
8000ac66:	8b 38       	st.w	r5[0xc],r8
8000ac68:	c2 b9       	rjmp	8000aebe <__sfvwrite_r+0x28a>
8000ac6a:	8e 63       	ld.sh	r3,r7[0xc]
8000ac6c:	68 00       	ld.w	r0,r4[0x0]
8000ac6e:	06 96       	mov	r6,r3
8000ac70:	e2 16 00 02 	andl	r6,0x2,COH
8000ac74:	c2 10       	breq	8000acb6 <__sfvwrite_r+0x82>
8000ac76:	30 03       	mov	r3,0
8000ac78:	e0 62 04 00 	mov	r2,1024
8000ac7c:	06 96       	mov	r6,r3
8000ac7e:	c0 48       	rjmp	8000ac86 <__sfvwrite_r+0x52>
8000ac80:	60 03       	ld.w	r3,r0[0x0]
8000ac82:	60 16       	ld.w	r6,r0[0x4]
8000ac84:	2f 80       	sub	r0,-8
8000ac86:	58 06       	cp.w	r6,0
8000ac88:	cf c0       	breq	8000ac80 <__sfvwrite_r+0x4c>
8000ac8a:	e0 46 04 00 	cp.w	r6,1024
8000ac8e:	ec 09 17 80 	movls	r9,r6
8000ac92:	e4 09 17 b0 	movhi	r9,r2
8000ac96:	06 9a       	mov	r10,r3
8000ac98:	6e a8       	ld.w	r8,r7[0x28]
8000ac9a:	6e 8b       	ld.w	r11,r7[0x20]
8000ac9c:	0a 9c       	mov	r12,r5
8000ac9e:	5d 18       	icall	r8
8000aca0:	18 16       	sub	r6,r12
8000aca2:	58 0c       	cp.w	r12,0
8000aca4:	e0 8a 01 0a 	brle	8000aeb8 <__sfvwrite_r+0x284>
8000aca8:	68 28       	ld.w	r8,r4[0x8]
8000acaa:	18 18       	sub	r8,r12
8000acac:	89 28       	st.w	r4[0x8],r8
8000acae:	e0 80 01 0a 	breq	8000aec2 <__sfvwrite_r+0x28e>
8000acb2:	18 03       	add	r3,r12
8000acb4:	ce 9b       	rjmp	8000ac86 <__sfvwrite_r+0x52>
8000acb6:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000acba:	c0 70       	breq	8000acc8 <__sfvwrite_r+0x94>
8000acbc:	50 06       	stdsp	sp[0x0],r6
8000acbe:	0c 93       	mov	r3,r6
8000acc0:	0c 91       	mov	r1,r6
8000acc2:	50 15       	stdsp	sp[0x4],r5
8000acc4:	08 92       	mov	r2,r4
8000acc6:	c9 c8       	rjmp	8000adfe <__sfvwrite_r+0x1ca>
8000acc8:	06 96       	mov	r6,r3
8000acca:	08 91       	mov	r1,r4
8000accc:	c0 48       	rjmp	8000acd4 <__sfvwrite_r+0xa0>
8000acce:	60 03       	ld.w	r3,r0[0x0]
8000acd0:	60 16       	ld.w	r6,r0[0x4]
8000acd2:	2f 80       	sub	r0,-8
8000acd4:	58 06       	cp.w	r6,0
8000acd6:	cf c0       	breq	8000acce <__sfvwrite_r+0x9a>
8000acd8:	8e 68       	ld.sh	r8,r7[0xc]
8000acda:	6e 24       	ld.w	r4,r7[0x8]
8000acdc:	10 99       	mov	r9,r8
8000acde:	e2 19 02 00 	andl	r9,0x200,COH
8000ace2:	c5 50       	breq	8000ad8c <__sfvwrite_r+0x158>
8000ace4:	08 36       	cp.w	r6,r4
8000ace6:	c4 43       	brcs	8000ad6e <__sfvwrite_r+0x13a>
8000ace8:	10 99       	mov	r9,r8
8000acea:	e2 19 04 80 	andl	r9,0x480,COH
8000acee:	c4 00       	breq	8000ad6e <__sfvwrite_r+0x13a>
8000acf0:	6e 4b       	ld.w	r11,r7[0x10]
8000acf2:	6e 09       	ld.w	r9,r7[0x0]
8000acf4:	16 19       	sub	r9,r11
8000acf6:	50 09       	stdsp	sp[0x0],r9
8000acf8:	6e 59       	ld.w	r9,r7[0x14]
8000acfa:	10 9c       	mov	r12,r8
8000acfc:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000ad00:	30 28       	mov	r8,2
8000ad02:	f4 08 0c 08 	divs	r8,r10,r8
8000ad06:	fa e9 00 04 	st.d	sp[4],r8
8000ad0a:	10 94       	mov	r4,r8
8000ad0c:	40 09       	lddsp	r9,sp[0x0]
8000ad0e:	e2 1c 04 00 	andl	r12,0x400,COH
8000ad12:	2f f9       	sub	r9,-1
8000ad14:	0c 09       	add	r9,r6
8000ad16:	12 38       	cp.w	r8,r9
8000ad18:	f2 04 17 30 	movlo	r4,r9
8000ad1c:	58 0c       	cp.w	r12,0
8000ad1e:	c1 10       	breq	8000ad40 <__sfvwrite_r+0x10c>
8000ad20:	08 9b       	mov	r11,r4
8000ad22:	0a 9c       	mov	r12,r5
8000ad24:	fe b0 e0 6c 	rcall	80006dfc <_malloc_r>
8000ad28:	18 92       	mov	r2,r12
8000ad2a:	c1 40       	breq	8000ad52 <__sfvwrite_r+0x11e>
8000ad2c:	40 0a       	lddsp	r10,sp[0x0]
8000ad2e:	6e 4b       	ld.w	r11,r7[0x10]
8000ad30:	fe b0 e2 82 	rcall	80007234 <memcpy>
8000ad34:	8e 68       	ld.sh	r8,r7[0xc]
8000ad36:	e0 18 fb 7f 	andl	r8,0xfb7f
8000ad3a:	a7 b8       	sbr	r8,0x7
8000ad3c:	ae 68       	st.h	r7[0xc],r8
8000ad3e:	c0 d8       	rjmp	8000ad58 <__sfvwrite_r+0x124>
8000ad40:	08 9a       	mov	r10,r4
8000ad42:	0a 9c       	mov	r12,r5
8000ad44:	fe b0 e3 24 	rcall	8000738c <_realloc_r>
8000ad48:	18 92       	mov	r2,r12
8000ad4a:	c0 71       	brne	8000ad58 <__sfvwrite_r+0x124>
8000ad4c:	6e 4b       	ld.w	r11,r7[0x10]
8000ad4e:	0a 9c       	mov	r12,r5
8000ad50:	ca ce       	rcall	8000aaa8 <_free_r>
8000ad52:	30 c8       	mov	r8,12
8000ad54:	8b 38       	st.w	r5[0xc],r8
8000ad56:	cb 18       	rjmp	8000aeb8 <__sfvwrite_r+0x284>
8000ad58:	40 0a       	lddsp	r10,sp[0x0]
8000ad5a:	40 09       	lddsp	r9,sp[0x0]
8000ad5c:	e8 0a 01 0a 	sub	r10,r4,r10
8000ad60:	e4 09 00 08 	add	r8,r2,r9
8000ad64:	8f 54       	st.w	r7[0x14],r4
8000ad66:	8f 2a       	st.w	r7[0x8],r10
8000ad68:	8f 08       	st.w	r7[0x0],r8
8000ad6a:	8f 42       	st.w	r7[0x10],r2
8000ad6c:	0c 94       	mov	r4,r6
8000ad6e:	08 36       	cp.w	r6,r4
8000ad70:	ec 04 17 30 	movlo	r4,r6
8000ad74:	06 9b       	mov	r11,r3
8000ad76:	08 9a       	mov	r10,r4
8000ad78:	6e 0c       	ld.w	r12,r7[0x0]
8000ad7a:	c3 ad       	rcall	8000afee <memmove>
8000ad7c:	6e 08       	ld.w	r8,r7[0x0]
8000ad7e:	08 08       	add	r8,r4
8000ad80:	8f 08       	st.w	r7[0x0],r8
8000ad82:	6e 28       	ld.w	r8,r7[0x8]
8000ad84:	08 18       	sub	r8,r4
8000ad86:	0c 94       	mov	r4,r6
8000ad88:	8f 28       	st.w	r7[0x8],r8
8000ad8a:	c2 e8       	rjmp	8000ade6 <__sfvwrite_r+0x1b2>
8000ad8c:	08 36       	cp.w	r6,r4
8000ad8e:	5f ba       	srhi	r10
8000ad90:	6e 0c       	ld.w	r12,r7[0x0]
8000ad92:	6e 48       	ld.w	r8,r7[0x10]
8000ad94:	10 3c       	cp.w	r12,r8
8000ad96:	5f b8       	srhi	r8
8000ad98:	f5 e8 00 08 	and	r8,r10,r8
8000ad9c:	f2 08 18 00 	cp.b	r8,r9
8000ada0:	c0 d0       	breq	8000adba <__sfvwrite_r+0x186>
8000ada2:	06 9b       	mov	r11,r3
8000ada4:	08 9a       	mov	r10,r4
8000ada6:	c2 4d       	rcall	8000afee <memmove>
8000ada8:	6e 08       	ld.w	r8,r7[0x0]
8000adaa:	08 08       	add	r8,r4
8000adac:	0e 9b       	mov	r11,r7
8000adae:	8f 08       	st.w	r7[0x0],r8
8000adb0:	0a 9c       	mov	r12,r5
8000adb2:	fe b0 fd 09 	rcall	8000a7c4 <_fflush_r>
8000adb6:	c1 80       	breq	8000ade6 <__sfvwrite_r+0x1b2>
8000adb8:	c8 08       	rjmp	8000aeb8 <__sfvwrite_r+0x284>
8000adba:	6e 59       	ld.w	r9,r7[0x14]
8000adbc:	12 36       	cp.w	r6,r9
8000adbe:	c0 a3       	brcs	8000add2 <__sfvwrite_r+0x19e>
8000adc0:	6e a8       	ld.w	r8,r7[0x28]
8000adc2:	06 9a       	mov	r10,r3
8000adc4:	6e 8b       	ld.w	r11,r7[0x20]
8000adc6:	0a 9c       	mov	r12,r5
8000adc8:	5d 18       	icall	r8
8000adca:	18 94       	mov	r4,r12
8000adcc:	e0 89 00 0d 	brgt	8000ade6 <__sfvwrite_r+0x1b2>
8000add0:	c7 48       	rjmp	8000aeb8 <__sfvwrite_r+0x284>
8000add2:	0c 9a       	mov	r10,r6
8000add4:	06 9b       	mov	r11,r3
8000add6:	c0 cd       	rcall	8000afee <memmove>
8000add8:	6e 08       	ld.w	r8,r7[0x0]
8000adda:	0c 08       	add	r8,r6
8000addc:	0c 94       	mov	r4,r6
8000adde:	8f 08       	st.w	r7[0x0],r8
8000ade0:	6e 28       	ld.w	r8,r7[0x8]
8000ade2:	0c 18       	sub	r8,r6
8000ade4:	8f 28       	st.w	r7[0x8],r8
8000ade6:	62 28       	ld.w	r8,r1[0x8]
8000ade8:	08 18       	sub	r8,r4
8000adea:	83 28       	st.w	r1[0x8],r8
8000adec:	c6 b0       	breq	8000aec2 <__sfvwrite_r+0x28e>
8000adee:	08 16       	sub	r6,r4
8000adf0:	08 03       	add	r3,r4
8000adf2:	c7 1b       	rjmp	8000acd4 <__sfvwrite_r+0xa0>
8000adf4:	60 03       	ld.w	r3,r0[0x0]
8000adf6:	60 11       	ld.w	r1,r0[0x4]
8000adf8:	30 08       	mov	r8,0
8000adfa:	2f 80       	sub	r0,-8
8000adfc:	50 08       	stdsp	sp[0x0],r8
8000adfe:	58 01       	cp.w	r1,0
8000ae00:	cf a0       	breq	8000adf4 <__sfvwrite_r+0x1c0>
8000ae02:	40 0a       	lddsp	r10,sp[0x0]
8000ae04:	58 0a       	cp.w	r10,0
8000ae06:	c1 41       	brne	8000ae2e <__sfvwrite_r+0x1fa>
8000ae08:	e2 c6 ff ff 	sub	r6,r1,-1
8000ae0c:	02 9a       	mov	r10,r1
8000ae0e:	30 ab       	mov	r11,10
8000ae10:	06 9c       	mov	r12,r3
8000ae12:	ce 3c       	rcall	8000afd8 <memchr>
8000ae14:	f8 c8 ff ff 	sub	r8,r12,-1
8000ae18:	58 0c       	cp.w	r12,0
8000ae1a:	f1 d3 e1 16 	subne	r6,r8,r3
8000ae1e:	f9 b9 01 01 	movne	r9,1
8000ae22:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000ae26:	f9 b8 00 01 	moveq	r8,1
8000ae2a:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000ae2e:	02 36       	cp.w	r6,r1
8000ae30:	ec 04 17 80 	movls	r4,r6
8000ae34:	e2 04 17 b0 	movhi	r4,r1
8000ae38:	6e 59       	ld.w	r9,r7[0x14]
8000ae3a:	6e 25       	ld.w	r5,r7[0x8]
8000ae3c:	f2 05 00 05 	add	r5,r9,r5
8000ae40:	0a 34       	cp.w	r4,r5
8000ae42:	5f 9a       	srgt	r10
8000ae44:	6e 0c       	ld.w	r12,r7[0x0]
8000ae46:	6e 48       	ld.w	r8,r7[0x10]
8000ae48:	10 3c       	cp.w	r12,r8
8000ae4a:	5f b8       	srhi	r8
8000ae4c:	f5 e8 00 08 	and	r8,r10,r8
8000ae50:	30 0a       	mov	r10,0
8000ae52:	f4 08 18 00 	cp.b	r8,r10
8000ae56:	c0 d0       	breq	8000ae70 <__sfvwrite_r+0x23c>
8000ae58:	06 9b       	mov	r11,r3
8000ae5a:	0a 9a       	mov	r10,r5
8000ae5c:	cc 9c       	rcall	8000afee <memmove>
8000ae5e:	6e 08       	ld.w	r8,r7[0x0]
8000ae60:	0a 08       	add	r8,r5
8000ae62:	0e 9b       	mov	r11,r7
8000ae64:	8f 08       	st.w	r7[0x0],r8
8000ae66:	40 1c       	lddsp	r12,sp[0x4]
8000ae68:	fe b0 fc ae 	rcall	8000a7c4 <_fflush_r>
8000ae6c:	c1 70       	breq	8000ae9a <__sfvwrite_r+0x266>
8000ae6e:	c2 58       	rjmp	8000aeb8 <__sfvwrite_r+0x284>
8000ae70:	12 34       	cp.w	r4,r9
8000ae72:	c0 a5       	brlt	8000ae86 <__sfvwrite_r+0x252>
8000ae74:	6e a8       	ld.w	r8,r7[0x28]
8000ae76:	06 9a       	mov	r10,r3
8000ae78:	6e 8b       	ld.w	r11,r7[0x20]
8000ae7a:	40 1c       	lddsp	r12,sp[0x4]
8000ae7c:	5d 18       	icall	r8
8000ae7e:	18 95       	mov	r5,r12
8000ae80:	e0 89 00 0d 	brgt	8000ae9a <__sfvwrite_r+0x266>
8000ae84:	c1 a8       	rjmp	8000aeb8 <__sfvwrite_r+0x284>
8000ae86:	08 9a       	mov	r10,r4
8000ae88:	06 9b       	mov	r11,r3
8000ae8a:	cb 2c       	rcall	8000afee <memmove>
8000ae8c:	6e 08       	ld.w	r8,r7[0x0]
8000ae8e:	08 08       	add	r8,r4
8000ae90:	08 95       	mov	r5,r4
8000ae92:	8f 08       	st.w	r7[0x0],r8
8000ae94:	6e 28       	ld.w	r8,r7[0x8]
8000ae96:	08 18       	sub	r8,r4
8000ae98:	8f 28       	st.w	r7[0x8],r8
8000ae9a:	0a 16       	sub	r6,r5
8000ae9c:	c0 71       	brne	8000aeaa <__sfvwrite_r+0x276>
8000ae9e:	0e 9b       	mov	r11,r7
8000aea0:	40 1c       	lddsp	r12,sp[0x4]
8000aea2:	fe b0 fc 91 	rcall	8000a7c4 <_fflush_r>
8000aea6:	c0 91       	brne	8000aeb8 <__sfvwrite_r+0x284>
8000aea8:	50 06       	stdsp	sp[0x0],r6
8000aeaa:	64 28       	ld.w	r8,r2[0x8]
8000aeac:	0a 18       	sub	r8,r5
8000aeae:	85 28       	st.w	r2[0x8],r8
8000aeb0:	c0 90       	breq	8000aec2 <__sfvwrite_r+0x28e>
8000aeb2:	0a 11       	sub	r1,r5
8000aeb4:	0a 03       	add	r3,r5
8000aeb6:	ca 4b       	rjmp	8000adfe <__sfvwrite_r+0x1ca>
8000aeb8:	8e 68       	ld.sh	r8,r7[0xc]
8000aeba:	a7 a8       	sbr	r8,0x6
8000aebc:	ae 68       	st.h	r7[0xc],r8
8000aebe:	3f fc       	mov	r12,-1
8000aec0:	c0 28       	rjmp	8000aec4 <__sfvwrite_r+0x290>
8000aec2:	30 0c       	mov	r12,0
8000aec4:	2f dd       	sub	sp,-12
8000aec6:	d8 32       	popm	r0-r7,pc

8000aec8 <_fwalk>:
8000aec8:	d4 31       	pushm	r0-r7,lr
8000aeca:	30 05       	mov	r5,0
8000aecc:	16 91       	mov	r1,r11
8000aece:	f8 c7 ff 28 	sub	r7,r12,-216
8000aed2:	0a 92       	mov	r2,r5
8000aed4:	fe b0 fc fe 	rcall	8000a8d0 <__sfp_lock_acquire>
8000aed8:	3f f3       	mov	r3,-1
8000aeda:	c1 68       	rjmp	8000af06 <_fwalk+0x3e>
8000aedc:	6e 26       	ld.w	r6,r7[0x8]
8000aede:	6e 14       	ld.w	r4,r7[0x4]
8000aee0:	2f 46       	sub	r6,-12
8000aee2:	c0 c8       	rjmp	8000aefa <_fwalk+0x32>
8000aee4:	8c 08       	ld.sh	r8,r6[0x0]
8000aee6:	e4 08 19 00 	cp.h	r8,r2
8000aeea:	c0 70       	breq	8000aef8 <_fwalk+0x30>
8000aeec:	8c 18       	ld.sh	r8,r6[0x2]
8000aeee:	e6 08 19 00 	cp.h	r8,r3
8000aef2:	c0 30       	breq	8000aef8 <_fwalk+0x30>
8000aef4:	5d 11       	icall	r1
8000aef6:	18 45       	or	r5,r12
8000aef8:	2a 46       	sub	r6,-92
8000aefa:	20 14       	sub	r4,1
8000aefc:	ec cc 00 0c 	sub	r12,r6,12
8000af00:	58 04       	cp.w	r4,0
8000af02:	cf 14       	brge	8000aee4 <_fwalk+0x1c>
8000af04:	6e 07       	ld.w	r7,r7[0x0]
8000af06:	58 07       	cp.w	r7,0
8000af08:	ce a1       	brne	8000aedc <_fwalk+0x14>
8000af0a:	fe b0 fc e4 	rcall	8000a8d2 <__sfp_lock_release>
8000af0e:	0a 9c       	mov	r12,r5
8000af10:	d8 32       	popm	r0-r7,pc
8000af12:	d7 03       	nop

8000af14 <_localeconv_r>:
8000af14:	fe cc d5 14 	sub	r12,pc,-10988
8000af18:	5e fc       	retal	r12
8000af1a:	d7 03       	nop

8000af1c <__smakebuf_r>:
8000af1c:	d4 21       	pushm	r4-r7,lr
8000af1e:	20 fd       	sub	sp,60
8000af20:	96 68       	ld.sh	r8,r11[0xc]
8000af22:	16 97       	mov	r7,r11
8000af24:	18 96       	mov	r6,r12
8000af26:	e2 18 00 02 	andl	r8,0x2,COH
8000af2a:	c3 d1       	brne	8000afa4 <__smakebuf_r+0x88>
8000af2c:	96 7b       	ld.sh	r11,r11[0xe]
8000af2e:	f0 0b 19 00 	cp.h	r11,r8
8000af32:	c0 55       	brlt	8000af3c <__smakebuf_r+0x20>
8000af34:	1a 9a       	mov	r10,sp
8000af36:	e0 a0 04 81 	rcall	8000b838 <_fstat_r>
8000af3a:	c0 f4       	brge	8000af58 <__smakebuf_r+0x3c>
8000af3c:	8e 65       	ld.sh	r5,r7[0xc]
8000af3e:	0a 98       	mov	r8,r5
8000af40:	ab b8       	sbr	r8,0xb
8000af42:	e2 15 00 80 	andl	r5,0x80,COH
8000af46:	ae 68       	st.h	r7[0xc],r8
8000af48:	30 04       	mov	r4,0
8000af4a:	e0 68 04 00 	mov	r8,1024
8000af4e:	f9 b5 01 40 	movne	r5,64
8000af52:	f0 05 17 00 	moveq	r5,r8
8000af56:	c1 c8       	rjmp	8000af8e <__smakebuf_r+0x72>
8000af58:	40 18       	lddsp	r8,sp[0x4]
8000af5a:	e2 18 f0 00 	andl	r8,0xf000,COH
8000af5e:	e0 48 20 00 	cp.w	r8,8192
8000af62:	5f 04       	sreq	r4
8000af64:	e0 48 80 00 	cp.w	r8,32768
8000af68:	c0 e1       	brne	8000af84 <__smakebuf_r+0x68>
8000af6a:	6e b9       	ld.w	r9,r7[0x2c]
8000af6c:	fe c8 f9 1c 	sub	r8,pc,-1764
8000af70:	10 39       	cp.w	r9,r8
8000af72:	c0 91       	brne	8000af84 <__smakebuf_r+0x68>
8000af74:	8e 68       	ld.sh	r8,r7[0xc]
8000af76:	e0 65 04 00 	mov	r5,1024
8000af7a:	ab a8       	sbr	r8,0xa
8000af7c:	ef 45 00 50 	st.w	r7[80],r5
8000af80:	ae 68       	st.h	r7[0xc],r8
8000af82:	c0 68       	rjmp	8000af8e <__smakebuf_r+0x72>
8000af84:	8e 68       	ld.sh	r8,r7[0xc]
8000af86:	e0 65 04 00 	mov	r5,1024
8000af8a:	ab b8       	sbr	r8,0xb
8000af8c:	ae 68       	st.h	r7[0xc],r8
8000af8e:	0a 9b       	mov	r11,r5
8000af90:	0c 9c       	mov	r12,r6
8000af92:	fe b0 df 35 	rcall	80006dfc <_malloc_r>
8000af96:	8e 68       	ld.sh	r8,r7[0xc]
8000af98:	c0 d1       	brne	8000afb2 <__smakebuf_r+0x96>
8000af9a:	ed b8 00 09 	bld	r8,0x9
8000af9e:	c1 b0       	breq	8000afd4 <__smakebuf_r+0xb8>
8000afa0:	a1 b8       	sbr	r8,0x1
8000afa2:	ae 68       	st.h	r7[0xc],r8
8000afa4:	ee c8 ff b9 	sub	r8,r7,-71
8000afa8:	8f 48       	st.w	r7[0x10],r8
8000afaa:	8f 08       	st.w	r7[0x0],r8
8000afac:	30 18       	mov	r8,1
8000afae:	8f 58       	st.w	r7[0x14],r8
8000afb0:	c1 28       	rjmp	8000afd4 <__smakebuf_r+0xb8>
8000afb2:	a7 b8       	sbr	r8,0x7
8000afb4:	8f 4c       	st.w	r7[0x10],r12
8000afb6:	ae 68       	st.h	r7[0xc],r8
8000afb8:	8f 55       	st.w	r7[0x14],r5
8000afba:	fe c8 06 e6 	sub	r8,pc,1766
8000afbe:	8f 0c       	st.w	r7[0x0],r12
8000afc0:	8d a8       	st.w	r6[0x28],r8
8000afc2:	58 04       	cp.w	r4,0
8000afc4:	c0 80       	breq	8000afd4 <__smakebuf_r+0xb8>
8000afc6:	8e 7c       	ld.sh	r12,r7[0xe]
8000afc8:	fe b0 e3 94 	rcall	800076f0 <isatty>
8000afcc:	c0 40       	breq	8000afd4 <__smakebuf_r+0xb8>
8000afce:	8e 68       	ld.sh	r8,r7[0xc]
8000afd0:	a1 a8       	sbr	r8,0x0
8000afd2:	ae 68       	st.h	r7[0xc],r8
8000afd4:	2f 1d       	sub	sp,-60
8000afd6:	d8 22       	popm	r4-r7,pc

8000afd8 <memchr>:
8000afd8:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000afdc:	c0 68       	rjmp	8000afe8 <memchr+0x10>
8000afde:	20 1a       	sub	r10,1
8000afe0:	19 88       	ld.ub	r8,r12[0x0]
8000afe2:	16 38       	cp.w	r8,r11
8000afe4:	5e 0c       	reteq	r12
8000afe6:	2f fc       	sub	r12,-1
8000afe8:	58 0a       	cp.w	r10,0
8000afea:	cf a1       	brne	8000afde <memchr+0x6>
8000afec:	5e fa       	retal	r10

8000afee <memmove>:
8000afee:	d4 01       	pushm	lr
8000aff0:	18 3b       	cp.w	r11,r12
8000aff2:	c1 92       	brcc	8000b024 <memmove+0x36>
8000aff4:	f6 0a 00 09 	add	r9,r11,r10
8000aff8:	12 3c       	cp.w	r12,r9
8000affa:	c1 52       	brcc	8000b024 <memmove+0x36>
8000affc:	f8 0a 00 0b 	add	r11,r12,r10
8000b000:	30 08       	mov	r8,0
8000b002:	c0 68       	rjmp	8000b00e <memmove+0x20>
8000b004:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b008:	20 1a       	sub	r10,1
8000b00a:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b00e:	20 18       	sub	r8,1
8000b010:	58 0a       	cp.w	r10,0
8000b012:	cf 91       	brne	8000b004 <memmove+0x16>
8000b014:	d8 02       	popm	pc
8000b016:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b01a:	20 1a       	sub	r10,1
8000b01c:	f8 08 0b 09 	st.b	r12[r8],r9
8000b020:	2f f8       	sub	r8,-1
8000b022:	c0 28       	rjmp	8000b026 <memmove+0x38>
8000b024:	30 08       	mov	r8,0
8000b026:	58 0a       	cp.w	r10,0
8000b028:	cf 71       	brne	8000b016 <memmove+0x28>
8000b02a:	d8 02       	popm	pc

8000b02c <__hi0bits>:
8000b02c:	18 98       	mov	r8,r12
8000b02e:	e0 1c 00 00 	andl	r12,0x0
8000b032:	f0 09 15 10 	lsl	r9,r8,0x10
8000b036:	58 0c       	cp.w	r12,0
8000b038:	f2 08 17 00 	moveq	r8,r9
8000b03c:	f9 bc 00 10 	moveq	r12,16
8000b040:	f9 bc 01 00 	movne	r12,0
8000b044:	10 9a       	mov	r10,r8
8000b046:	f0 09 15 08 	lsl	r9,r8,0x8
8000b04a:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b04e:	f7 bc 00 f8 	subeq	r12,-8
8000b052:	f2 08 17 00 	moveq	r8,r9
8000b056:	10 9a       	mov	r10,r8
8000b058:	f0 09 15 04 	lsl	r9,r8,0x4
8000b05c:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b060:	f7 bc 00 fc 	subeq	r12,-4
8000b064:	f2 08 17 00 	moveq	r8,r9
8000b068:	10 9a       	mov	r10,r8
8000b06a:	f0 09 15 02 	lsl	r9,r8,0x2
8000b06e:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b072:	f7 bc 00 fe 	subeq	r12,-2
8000b076:	f2 08 17 00 	moveq	r8,r9
8000b07a:	58 08       	cp.w	r8,0
8000b07c:	5e 5c       	retlt	r12
8000b07e:	ed b8 00 1e 	bld	r8,0x1e
8000b082:	f9 bc 01 20 	movne	r12,32
8000b086:	f7 bc 00 ff 	subeq	r12,-1
8000b08a:	5e fc       	retal	r12

8000b08c <__lo0bits>:
8000b08c:	18 99       	mov	r9,r12
8000b08e:	78 08       	ld.w	r8,r12[0x0]
8000b090:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b094:	c1 50       	breq	8000b0be <__lo0bits+0x32>
8000b096:	ed b8 00 00 	bld	r8,0x0
8000b09a:	c0 21       	brne	8000b09e <__lo0bits+0x12>
8000b09c:	5e fd       	retal	0
8000b09e:	10 9b       	mov	r11,r8
8000b0a0:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b0a4:	e2 1b 00 02 	andl	r11,0x2,COH
8000b0a8:	a3 88       	lsr	r8,0x2
8000b0aa:	58 0b       	cp.w	r11,0
8000b0ac:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b0b0:	f9 bc 01 01 	movne	r12,1
8000b0b4:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b0b8:	f9 bc 00 02 	moveq	r12,2
8000b0bc:	5e fc       	retal	r12
8000b0be:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b0c2:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b0c6:	58 0a       	cp.w	r10,0
8000b0c8:	f6 08 17 00 	moveq	r8,r11
8000b0cc:	f9 bc 00 10 	moveq	r12,16
8000b0d0:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b0d4:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b0d8:	58 0b       	cp.w	r11,0
8000b0da:	f7 bc 00 f8 	subeq	r12,-8
8000b0de:	f4 08 17 00 	moveq	r8,r10
8000b0e2:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b0e6:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b0ea:	58 0b       	cp.w	r11,0
8000b0ec:	f7 bc 00 fc 	subeq	r12,-4
8000b0f0:	f4 08 17 00 	moveq	r8,r10
8000b0f4:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b0f8:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b0fc:	58 0b       	cp.w	r11,0
8000b0fe:	f7 bc 00 fe 	subeq	r12,-2
8000b102:	f4 08 17 00 	moveq	r8,r10
8000b106:	ed b8 00 00 	bld	r8,0x0
8000b10a:	c0 60       	breq	8000b116 <__lo0bits+0x8a>
8000b10c:	a1 98       	lsr	r8,0x1
8000b10e:	c0 31       	brne	8000b114 <__lo0bits+0x88>
8000b110:	32 0c       	mov	r12,32
8000b112:	5e fc       	retal	r12
8000b114:	2f fc       	sub	r12,-1
8000b116:	93 08       	st.w	r9[0x0],r8
8000b118:	5e fc       	retal	r12

8000b11a <__mcmp>:
8000b11a:	d4 01       	pushm	lr
8000b11c:	18 98       	mov	r8,r12
8000b11e:	76 49       	ld.w	r9,r11[0x10]
8000b120:	78 4c       	ld.w	r12,r12[0x10]
8000b122:	12 1c       	sub	r12,r9
8000b124:	c1 31       	brne	8000b14a <__mcmp+0x30>
8000b126:	2f b9       	sub	r9,-5
8000b128:	a3 69       	lsl	r9,0x2
8000b12a:	12 0b       	add	r11,r9
8000b12c:	f0 09 00 09 	add	r9,r8,r9
8000b130:	2e c8       	sub	r8,-20
8000b132:	13 4e       	ld.w	lr,--r9
8000b134:	17 4a       	ld.w	r10,--r11
8000b136:	14 3e       	cp.w	lr,r10
8000b138:	c0 60       	breq	8000b144 <__mcmp+0x2a>
8000b13a:	f9 bc 03 ff 	movlo	r12,-1
8000b13e:	f9 bc 02 01 	movhs	r12,1
8000b142:	d8 02       	popm	pc
8000b144:	10 39       	cp.w	r9,r8
8000b146:	fe 9b ff f6 	brhi	8000b132 <__mcmp+0x18>
8000b14a:	d8 02       	popm	pc

8000b14c <_Bfree>:
8000b14c:	d4 21       	pushm	r4-r7,lr
8000b14e:	18 97       	mov	r7,r12
8000b150:	16 95       	mov	r5,r11
8000b152:	78 96       	ld.w	r6,r12[0x24]
8000b154:	58 06       	cp.w	r6,0
8000b156:	c0 91       	brne	8000b168 <_Bfree+0x1c>
8000b158:	31 0c       	mov	r12,16
8000b15a:	fe b0 de 49 	rcall	80006dec <malloc>
8000b15e:	99 36       	st.w	r12[0xc],r6
8000b160:	8f 9c       	st.w	r7[0x24],r12
8000b162:	99 16       	st.w	r12[0x4],r6
8000b164:	99 26       	st.w	r12[0x8],r6
8000b166:	99 06       	st.w	r12[0x0],r6
8000b168:	58 05       	cp.w	r5,0
8000b16a:	c0 90       	breq	8000b17c <_Bfree+0x30>
8000b16c:	6a 19       	ld.w	r9,r5[0x4]
8000b16e:	6e 98       	ld.w	r8,r7[0x24]
8000b170:	70 38       	ld.w	r8,r8[0xc]
8000b172:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b176:	8b 0a       	st.w	r5[0x0],r10
8000b178:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b17c:	d8 22       	popm	r4-r7,pc
8000b17e:	d7 03       	nop

8000b180 <_Balloc>:
8000b180:	d4 21       	pushm	r4-r7,lr
8000b182:	18 97       	mov	r7,r12
8000b184:	16 96       	mov	r6,r11
8000b186:	78 95       	ld.w	r5,r12[0x24]
8000b188:	58 05       	cp.w	r5,0
8000b18a:	c0 91       	brne	8000b19c <_Balloc+0x1c>
8000b18c:	31 0c       	mov	r12,16
8000b18e:	fe b0 de 2f 	rcall	80006dec <malloc>
8000b192:	99 35       	st.w	r12[0xc],r5
8000b194:	8f 9c       	st.w	r7[0x24],r12
8000b196:	99 15       	st.w	r12[0x4],r5
8000b198:	99 25       	st.w	r12[0x8],r5
8000b19a:	99 05       	st.w	r12[0x0],r5
8000b19c:	6e 95       	ld.w	r5,r7[0x24]
8000b19e:	6a 38       	ld.w	r8,r5[0xc]
8000b1a0:	58 08       	cp.w	r8,0
8000b1a2:	c0 b1       	brne	8000b1b8 <_Balloc+0x38>
8000b1a4:	31 0a       	mov	r10,16
8000b1a6:	30 4b       	mov	r11,4
8000b1a8:	0e 9c       	mov	r12,r7
8000b1aa:	e0 a0 02 a7 	rcall	8000b6f8 <_calloc_r>
8000b1ae:	8b 3c       	st.w	r5[0xc],r12
8000b1b0:	6e 98       	ld.w	r8,r7[0x24]
8000b1b2:	70 3c       	ld.w	r12,r8[0xc]
8000b1b4:	58 0c       	cp.w	r12,0
8000b1b6:	c1 b0       	breq	8000b1ec <_Balloc+0x6c>
8000b1b8:	6e 98       	ld.w	r8,r7[0x24]
8000b1ba:	70 38       	ld.w	r8,r8[0xc]
8000b1bc:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b1c0:	70 0c       	ld.w	r12,r8[0x0]
8000b1c2:	58 0c       	cp.w	r12,0
8000b1c4:	c0 40       	breq	8000b1cc <_Balloc+0x4c>
8000b1c6:	78 09       	ld.w	r9,r12[0x0]
8000b1c8:	91 09       	st.w	r8[0x0],r9
8000b1ca:	c0 e8       	rjmp	8000b1e6 <_Balloc+0x66>
8000b1cc:	0e 9c       	mov	r12,r7
8000b1ce:	30 17       	mov	r7,1
8000b1d0:	0e 9b       	mov	r11,r7
8000b1d2:	ee 06 09 47 	lsl	r7,r7,r6
8000b1d6:	ee ca ff fb 	sub	r10,r7,-5
8000b1da:	a3 6a       	lsl	r10,0x2
8000b1dc:	e0 a0 02 8e 	rcall	8000b6f8 <_calloc_r>
8000b1e0:	c0 60       	breq	8000b1ec <_Balloc+0x6c>
8000b1e2:	99 16       	st.w	r12[0x4],r6
8000b1e4:	99 27       	st.w	r12[0x8],r7
8000b1e6:	30 08       	mov	r8,0
8000b1e8:	99 38       	st.w	r12[0xc],r8
8000b1ea:	99 48       	st.w	r12[0x10],r8
8000b1ec:	d8 22       	popm	r4-r7,pc
8000b1ee:	d7 03       	nop

8000b1f0 <__d2b>:
8000b1f0:	d4 31       	pushm	r0-r7,lr
8000b1f2:	20 2d       	sub	sp,8
8000b1f4:	16 93       	mov	r3,r11
8000b1f6:	12 96       	mov	r6,r9
8000b1f8:	10 95       	mov	r5,r8
8000b1fa:	14 92       	mov	r2,r10
8000b1fc:	30 1b       	mov	r11,1
8000b1fe:	cc 1f       	rcall	8000b180 <_Balloc>
8000b200:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b204:	50 09       	stdsp	sp[0x0],r9
8000b206:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b20a:	b5 a9       	sbr	r9,0x14
8000b20c:	f0 01 16 14 	lsr	r1,r8,0x14
8000b210:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b214:	18 94       	mov	r4,r12
8000b216:	58 02       	cp.w	r2,0
8000b218:	c1 d0       	breq	8000b252 <__d2b+0x62>
8000b21a:	fa cc ff f8 	sub	r12,sp,-8
8000b21e:	18 d2       	st.w	--r12,r2
8000b220:	c3 6f       	rcall	8000b08c <__lo0bits>
8000b222:	40 18       	lddsp	r8,sp[0x4]
8000b224:	c0 d0       	breq	8000b23e <__d2b+0x4e>
8000b226:	40 09       	lddsp	r9,sp[0x0]
8000b228:	f8 0a 11 20 	rsub	r10,r12,32
8000b22c:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b230:	f5 e8 10 08 	or	r8,r10,r8
8000b234:	89 58       	st.w	r4[0x14],r8
8000b236:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b23a:	50 09       	stdsp	sp[0x0],r9
8000b23c:	c0 28       	rjmp	8000b240 <__d2b+0x50>
8000b23e:	89 58       	st.w	r4[0x14],r8
8000b240:	40 08       	lddsp	r8,sp[0x0]
8000b242:	58 08       	cp.w	r8,0
8000b244:	f9 b3 01 02 	movne	r3,2
8000b248:	f9 b3 00 01 	moveq	r3,1
8000b24c:	89 68       	st.w	r4[0x18],r8
8000b24e:	89 43       	st.w	r4[0x10],r3
8000b250:	c0 88       	rjmp	8000b260 <__d2b+0x70>
8000b252:	1a 9c       	mov	r12,sp
8000b254:	c1 cf       	rcall	8000b08c <__lo0bits>
8000b256:	30 13       	mov	r3,1
8000b258:	40 08       	lddsp	r8,sp[0x0]
8000b25a:	2e 0c       	sub	r12,-32
8000b25c:	89 43       	st.w	r4[0x10],r3
8000b25e:	89 58       	st.w	r4[0x14],r8
8000b260:	58 01       	cp.w	r1,0
8000b262:	c0 90       	breq	8000b274 <__d2b+0x84>
8000b264:	e2 c1 04 33 	sub	r1,r1,1075
8000b268:	18 01       	add	r1,r12
8000b26a:	8d 01       	st.w	r6[0x0],r1
8000b26c:	f8 0c 11 35 	rsub	r12,r12,53
8000b270:	8b 0c       	st.w	r5[0x0],r12
8000b272:	c0 c8       	rjmp	8000b28a <__d2b+0x9a>
8000b274:	e6 c8 ff fc 	sub	r8,r3,-4
8000b278:	f8 cc 04 32 	sub	r12,r12,1074
8000b27c:	a5 73       	lsl	r3,0x5
8000b27e:	8d 0c       	st.w	r6[0x0],r12
8000b280:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b284:	cd 4e       	rcall	8000b02c <__hi0bits>
8000b286:	18 13       	sub	r3,r12
8000b288:	8b 03       	st.w	r5[0x0],r3
8000b28a:	08 9c       	mov	r12,r4
8000b28c:	2f ed       	sub	sp,-8
8000b28e:	d8 32       	popm	r0-r7,pc

8000b290 <__mdiff>:
8000b290:	d4 31       	pushm	r0-r7,lr
8000b292:	74 48       	ld.w	r8,r10[0x10]
8000b294:	76 45       	ld.w	r5,r11[0x10]
8000b296:	16 97       	mov	r7,r11
8000b298:	14 96       	mov	r6,r10
8000b29a:	10 15       	sub	r5,r8
8000b29c:	c1 31       	brne	8000b2c2 <__mdiff+0x32>
8000b29e:	2f b8       	sub	r8,-5
8000b2a0:	ee ce ff ec 	sub	lr,r7,-20
8000b2a4:	a3 68       	lsl	r8,0x2
8000b2a6:	f4 08 00 0b 	add	r11,r10,r8
8000b2aa:	ee 08 00 08 	add	r8,r7,r8
8000b2ae:	11 4a       	ld.w	r10,--r8
8000b2b0:	17 49       	ld.w	r9,--r11
8000b2b2:	12 3a       	cp.w	r10,r9
8000b2b4:	c0 30       	breq	8000b2ba <__mdiff+0x2a>
8000b2b6:	c0 e2       	brcc	8000b2d2 <__mdiff+0x42>
8000b2b8:	c0 78       	rjmp	8000b2c6 <__mdiff+0x36>
8000b2ba:	1c 38       	cp.w	r8,lr
8000b2bc:	fe 9b ff f9 	brhi	8000b2ae <__mdiff+0x1e>
8000b2c0:	c4 98       	rjmp	8000b352 <__mdiff+0xc2>
8000b2c2:	58 05       	cp.w	r5,0
8000b2c4:	c0 64       	brge	8000b2d0 <__mdiff+0x40>
8000b2c6:	0e 98       	mov	r8,r7
8000b2c8:	30 15       	mov	r5,1
8000b2ca:	0c 97       	mov	r7,r6
8000b2cc:	10 96       	mov	r6,r8
8000b2ce:	c0 28       	rjmp	8000b2d2 <__mdiff+0x42>
8000b2d0:	30 05       	mov	r5,0
8000b2d2:	6e 1b       	ld.w	r11,r7[0x4]
8000b2d4:	c5 6f       	rcall	8000b180 <_Balloc>
8000b2d6:	6e 49       	ld.w	r9,r7[0x10]
8000b2d8:	6c 44       	ld.w	r4,r6[0x10]
8000b2da:	99 35       	st.w	r12[0xc],r5
8000b2dc:	2f b4       	sub	r4,-5
8000b2de:	f2 c5 ff fb 	sub	r5,r9,-5
8000b2e2:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b2e6:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b2ea:	2e c6       	sub	r6,-20
8000b2ec:	2e c7       	sub	r7,-20
8000b2ee:	f8 c8 ff ec 	sub	r8,r12,-20
8000b2f2:	30 0a       	mov	r10,0
8000b2f4:	0f 0e       	ld.w	lr,r7++
8000b2f6:	0d 0b       	ld.w	r11,r6++
8000b2f8:	fc 02 16 10 	lsr	r2,lr,0x10
8000b2fc:	f6 03 16 10 	lsr	r3,r11,0x10
8000b300:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b304:	e4 03 01 03 	sub	r3,r2,r3
8000b308:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b30c:	fc 0b 01 0b 	sub	r11,lr,r11
8000b310:	f6 0a 00 0a 	add	r10,r11,r10
8000b314:	b0 1a       	st.h	r8[0x2],r10
8000b316:	b1 4a       	asr	r10,0x10
8000b318:	e6 0a 00 0a 	add	r10,r3,r10
8000b31c:	b0 0a       	st.h	r8[0x0],r10
8000b31e:	2f c8       	sub	r8,-4
8000b320:	b1 4a       	asr	r10,0x10
8000b322:	08 36       	cp.w	r6,r4
8000b324:	ce 83       	brcs	8000b2f4 <__mdiff+0x64>
8000b326:	c0 d8       	rjmp	8000b340 <__mdiff+0xb0>
8000b328:	0f 0b       	ld.w	r11,r7++
8000b32a:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b32e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b332:	16 0a       	add	r10,r11
8000b334:	b0 1a       	st.h	r8[0x2],r10
8000b336:	b1 4a       	asr	r10,0x10
8000b338:	1c 0a       	add	r10,lr
8000b33a:	b0 0a       	st.h	r8[0x0],r10
8000b33c:	2f c8       	sub	r8,-4
8000b33e:	b1 4a       	asr	r10,0x10
8000b340:	0a 37       	cp.w	r7,r5
8000b342:	cf 33       	brcs	8000b328 <__mdiff+0x98>
8000b344:	c0 28       	rjmp	8000b348 <__mdiff+0xb8>
8000b346:	20 19       	sub	r9,1
8000b348:	11 4a       	ld.w	r10,--r8
8000b34a:	58 0a       	cp.w	r10,0
8000b34c:	cf d0       	breq	8000b346 <__mdiff+0xb6>
8000b34e:	99 49       	st.w	r12[0x10],r9
8000b350:	d8 32       	popm	r0-r7,pc
8000b352:	30 0b       	mov	r11,0
8000b354:	c1 6f       	rcall	8000b180 <_Balloc>
8000b356:	30 18       	mov	r8,1
8000b358:	99 48       	st.w	r12[0x10],r8
8000b35a:	30 08       	mov	r8,0
8000b35c:	99 58       	st.w	r12[0x14],r8
8000b35e:	d8 32       	popm	r0-r7,pc

8000b360 <__lshift>:
8000b360:	d4 31       	pushm	r0-r7,lr
8000b362:	16 97       	mov	r7,r11
8000b364:	76 46       	ld.w	r6,r11[0x10]
8000b366:	f4 02 14 05 	asr	r2,r10,0x5
8000b36a:	2f f6       	sub	r6,-1
8000b36c:	14 93       	mov	r3,r10
8000b36e:	18 94       	mov	r4,r12
8000b370:	04 06       	add	r6,r2
8000b372:	76 1b       	ld.w	r11,r11[0x4]
8000b374:	6e 28       	ld.w	r8,r7[0x8]
8000b376:	c0 38       	rjmp	8000b37c <__lshift+0x1c>
8000b378:	2f fb       	sub	r11,-1
8000b37a:	a1 78       	lsl	r8,0x1
8000b37c:	10 36       	cp.w	r6,r8
8000b37e:	fe 99 ff fd 	brgt	8000b378 <__lshift+0x18>
8000b382:	08 9c       	mov	r12,r4
8000b384:	cf ee       	rcall	8000b180 <_Balloc>
8000b386:	30 09       	mov	r9,0
8000b388:	18 95       	mov	r5,r12
8000b38a:	f8 c8 ff ec 	sub	r8,r12,-20
8000b38e:	12 9a       	mov	r10,r9
8000b390:	c0 38       	rjmp	8000b396 <__lshift+0x36>
8000b392:	10 aa       	st.w	r8++,r10
8000b394:	2f f9       	sub	r9,-1
8000b396:	04 39       	cp.w	r9,r2
8000b398:	cf d5       	brlt	8000b392 <__lshift+0x32>
8000b39a:	6e 4b       	ld.w	r11,r7[0x10]
8000b39c:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b3a0:	2f bb       	sub	r11,-5
8000b3a2:	ee c9 ff ec 	sub	r9,r7,-20
8000b3a6:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b3aa:	58 03       	cp.w	r3,0
8000b3ac:	c1 30       	breq	8000b3d2 <__lshift+0x72>
8000b3ae:	e6 0c 11 20 	rsub	r12,r3,32
8000b3b2:	30 0a       	mov	r10,0
8000b3b4:	72 02       	ld.w	r2,r9[0x0]
8000b3b6:	e4 03 09 42 	lsl	r2,r2,r3
8000b3ba:	04 4a       	or	r10,r2
8000b3bc:	10 aa       	st.w	r8++,r10
8000b3be:	13 0a       	ld.w	r10,r9++
8000b3c0:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b3c4:	16 39       	cp.w	r9,r11
8000b3c6:	cf 73       	brcs	8000b3b4 <__lshift+0x54>
8000b3c8:	91 0a       	st.w	r8[0x0],r10
8000b3ca:	58 0a       	cp.w	r10,0
8000b3cc:	c0 70       	breq	8000b3da <__lshift+0x7a>
8000b3ce:	2f f6       	sub	r6,-1
8000b3d0:	c0 58       	rjmp	8000b3da <__lshift+0x7a>
8000b3d2:	13 0a       	ld.w	r10,r9++
8000b3d4:	10 aa       	st.w	r8++,r10
8000b3d6:	16 39       	cp.w	r9,r11
8000b3d8:	cf d3       	brcs	8000b3d2 <__lshift+0x72>
8000b3da:	08 9c       	mov	r12,r4
8000b3dc:	20 16       	sub	r6,1
8000b3de:	0e 9b       	mov	r11,r7
8000b3e0:	8b 46       	st.w	r5[0x10],r6
8000b3e2:	cb 5e       	rcall	8000b14c <_Bfree>
8000b3e4:	0a 9c       	mov	r12,r5
8000b3e6:	d8 32       	popm	r0-r7,pc

8000b3e8 <__multiply>:
8000b3e8:	d4 31       	pushm	r0-r7,lr
8000b3ea:	20 2d       	sub	sp,8
8000b3ec:	76 49       	ld.w	r9,r11[0x10]
8000b3ee:	74 48       	ld.w	r8,r10[0x10]
8000b3f0:	16 96       	mov	r6,r11
8000b3f2:	14 95       	mov	r5,r10
8000b3f4:	10 39       	cp.w	r9,r8
8000b3f6:	ec 08 17 50 	movlt	r8,r6
8000b3fa:	ea 06 17 50 	movlt	r6,r5
8000b3fe:	f0 05 17 50 	movlt	r5,r8
8000b402:	6c 28       	ld.w	r8,r6[0x8]
8000b404:	76 43       	ld.w	r3,r11[0x10]
8000b406:	74 42       	ld.w	r2,r10[0x10]
8000b408:	76 1b       	ld.w	r11,r11[0x4]
8000b40a:	e4 03 00 07 	add	r7,r2,r3
8000b40e:	10 37       	cp.w	r7,r8
8000b410:	f7 bb 09 ff 	subgt	r11,-1
8000b414:	cb 6e       	rcall	8000b180 <_Balloc>
8000b416:	ee c4 ff fb 	sub	r4,r7,-5
8000b41a:	f8 c9 ff ec 	sub	r9,r12,-20
8000b41e:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b422:	30 0a       	mov	r10,0
8000b424:	12 98       	mov	r8,r9
8000b426:	c0 28       	rjmp	8000b42a <__multiply+0x42>
8000b428:	10 aa       	st.w	r8++,r10
8000b42a:	08 38       	cp.w	r8,r4
8000b42c:	cf e3       	brcs	8000b428 <__multiply+0x40>
8000b42e:	2f b3       	sub	r3,-5
8000b430:	2f b2       	sub	r2,-5
8000b432:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b436:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b43a:	ec cb ff ec 	sub	r11,r6,-20
8000b43e:	50 12       	stdsp	sp[0x4],r2
8000b440:	ea ca ff ec 	sub	r10,r5,-20
8000b444:	c4 48       	rjmp	8000b4cc <__multiply+0xe4>
8000b446:	94 95       	ld.uh	r5,r10[0x2]
8000b448:	58 05       	cp.w	r5,0
8000b44a:	c2 00       	breq	8000b48a <__multiply+0xa2>
8000b44c:	12 98       	mov	r8,r9
8000b44e:	16 96       	mov	r6,r11
8000b450:	30 0e       	mov	lr,0
8000b452:	50 09       	stdsp	sp[0x0],r9
8000b454:	0d 02       	ld.w	r2,r6++
8000b456:	e4 00 16 10 	lsr	r0,r2,0x10
8000b45a:	70 01       	ld.w	r1,r8[0x0]
8000b45c:	70 09       	ld.w	r9,r8[0x0]
8000b45e:	b1 81       	lsr	r1,0x10
8000b460:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b464:	e0 05 03 41 	mac	r1,r0,r5
8000b468:	ab 32       	mul	r2,r5
8000b46a:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b46e:	00 02       	add	r2,r0
8000b470:	e4 0e 00 0e 	add	lr,r2,lr
8000b474:	b0 1e       	st.h	r8[0x2],lr
8000b476:	b1 8e       	lsr	lr,0x10
8000b478:	1c 01       	add	r1,lr
8000b47a:	b0 01       	st.h	r8[0x0],r1
8000b47c:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b480:	2f c8       	sub	r8,-4
8000b482:	06 36       	cp.w	r6,r3
8000b484:	ce 83       	brcs	8000b454 <__multiply+0x6c>
8000b486:	40 09       	lddsp	r9,sp[0x0]
8000b488:	91 0e       	st.w	r8[0x0],lr
8000b48a:	94 86       	ld.uh	r6,r10[0x0]
8000b48c:	58 06       	cp.w	r6,0
8000b48e:	c1 d0       	breq	8000b4c8 <__multiply+0xe0>
8000b490:	72 02       	ld.w	r2,r9[0x0]
8000b492:	12 98       	mov	r8,r9
8000b494:	16 9e       	mov	lr,r11
8000b496:	30 05       	mov	r5,0
8000b498:	b0 12       	st.h	r8[0x2],r2
8000b49a:	1d 01       	ld.w	r1,lr++
8000b49c:	90 82       	ld.uh	r2,r8[0x0]
8000b49e:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b4a2:	ad 30       	mul	r0,r6
8000b4a4:	e0 02 00 02 	add	r2,r0,r2
8000b4a8:	e4 05 00 05 	add	r5,r2,r5
8000b4ac:	b0 05       	st.h	r8[0x0],r5
8000b4ae:	b1 85       	lsr	r5,0x10
8000b4b0:	b1 81       	lsr	r1,0x10
8000b4b2:	2f c8       	sub	r8,-4
8000b4b4:	ad 31       	mul	r1,r6
8000b4b6:	90 92       	ld.uh	r2,r8[0x2]
8000b4b8:	e2 02 00 02 	add	r2,r1,r2
8000b4bc:	0a 02       	add	r2,r5
8000b4be:	e4 05 16 10 	lsr	r5,r2,0x10
8000b4c2:	06 3e       	cp.w	lr,r3
8000b4c4:	ce a3       	brcs	8000b498 <__multiply+0xb0>
8000b4c6:	91 02       	st.w	r8[0x0],r2
8000b4c8:	2f ca       	sub	r10,-4
8000b4ca:	2f c9       	sub	r9,-4
8000b4cc:	40 18       	lddsp	r8,sp[0x4]
8000b4ce:	10 3a       	cp.w	r10,r8
8000b4d0:	cb b3       	brcs	8000b446 <__multiply+0x5e>
8000b4d2:	c0 28       	rjmp	8000b4d6 <__multiply+0xee>
8000b4d4:	20 17       	sub	r7,1
8000b4d6:	58 07       	cp.w	r7,0
8000b4d8:	e0 8a 00 05 	brle	8000b4e2 <__multiply+0xfa>
8000b4dc:	09 48       	ld.w	r8,--r4
8000b4de:	58 08       	cp.w	r8,0
8000b4e0:	cf a0       	breq	8000b4d4 <__multiply+0xec>
8000b4e2:	99 47       	st.w	r12[0x10],r7
8000b4e4:	2f ed       	sub	sp,-8
8000b4e6:	d8 32       	popm	r0-r7,pc

8000b4e8 <__i2b>:
8000b4e8:	d4 21       	pushm	r4-r7,lr
8000b4ea:	16 97       	mov	r7,r11
8000b4ec:	30 1b       	mov	r11,1
8000b4ee:	c4 9e       	rcall	8000b180 <_Balloc>
8000b4f0:	30 19       	mov	r9,1
8000b4f2:	99 57       	st.w	r12[0x14],r7
8000b4f4:	99 49       	st.w	r12[0x10],r9
8000b4f6:	d8 22       	popm	r4-r7,pc

8000b4f8 <__multadd>:
8000b4f8:	d4 31       	pushm	r0-r7,lr
8000b4fa:	30 08       	mov	r8,0
8000b4fc:	12 95       	mov	r5,r9
8000b4fe:	16 97       	mov	r7,r11
8000b500:	18 96       	mov	r6,r12
8000b502:	76 44       	ld.w	r4,r11[0x10]
8000b504:	f6 c9 ff ec 	sub	r9,r11,-20
8000b508:	72 0b       	ld.w	r11,r9[0x0]
8000b50a:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b50e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b512:	f4 0c 02 4c 	mul	r12,r10,r12
8000b516:	f4 0b 03 45 	mac	r5,r10,r11
8000b51a:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b51e:	b1 85       	lsr	r5,0x10
8000b520:	18 05       	add	r5,r12
8000b522:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b526:	f8 0b 00 0b 	add	r11,r12,r11
8000b52a:	12 ab       	st.w	r9++,r11
8000b52c:	2f f8       	sub	r8,-1
8000b52e:	b1 85       	lsr	r5,0x10
8000b530:	08 38       	cp.w	r8,r4
8000b532:	ce b5       	brlt	8000b508 <__multadd+0x10>
8000b534:	58 05       	cp.w	r5,0
8000b536:	c1 c0       	breq	8000b56e <__multadd+0x76>
8000b538:	6e 28       	ld.w	r8,r7[0x8]
8000b53a:	10 34       	cp.w	r4,r8
8000b53c:	c1 35       	brlt	8000b562 <__multadd+0x6a>
8000b53e:	6e 1b       	ld.w	r11,r7[0x4]
8000b540:	0c 9c       	mov	r12,r6
8000b542:	2f fb       	sub	r11,-1
8000b544:	c1 ee       	rcall	8000b180 <_Balloc>
8000b546:	6e 4a       	ld.w	r10,r7[0x10]
8000b548:	ee cb ff f4 	sub	r11,r7,-12
8000b54c:	18 93       	mov	r3,r12
8000b54e:	2f ea       	sub	r10,-2
8000b550:	2f 4c       	sub	r12,-12
8000b552:	a3 6a       	lsl	r10,0x2
8000b554:	fe b0 de 70 	rcall	80007234 <memcpy>
8000b558:	0e 9b       	mov	r11,r7
8000b55a:	0c 9c       	mov	r12,r6
8000b55c:	fe b0 fd f8 	rcall	8000b14c <_Bfree>
8000b560:	06 97       	mov	r7,r3
8000b562:	e8 c8 ff ff 	sub	r8,r4,-1
8000b566:	2f b4       	sub	r4,-5
8000b568:	8f 48       	st.w	r7[0x10],r8
8000b56a:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b56e:	0e 9c       	mov	r12,r7
8000b570:	d8 32       	popm	r0-r7,pc
8000b572:	d7 03       	nop

8000b574 <__pow5mult>:
8000b574:	d4 31       	pushm	r0-r7,lr
8000b576:	14 96       	mov	r6,r10
8000b578:	18 97       	mov	r7,r12
8000b57a:	16 94       	mov	r4,r11
8000b57c:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b580:	c0 90       	breq	8000b592 <__pow5mult+0x1e>
8000b582:	20 18       	sub	r8,1
8000b584:	fe c9 db 48 	sub	r9,pc,-9400
8000b588:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b58c:	30 09       	mov	r9,0
8000b58e:	cb 5f       	rcall	8000b4f8 <__multadd>
8000b590:	18 94       	mov	r4,r12
8000b592:	a3 46       	asr	r6,0x2
8000b594:	c3 40       	breq	8000b5fc <__pow5mult+0x88>
8000b596:	6e 95       	ld.w	r5,r7[0x24]
8000b598:	58 05       	cp.w	r5,0
8000b59a:	c0 91       	brne	8000b5ac <__pow5mult+0x38>
8000b59c:	31 0c       	mov	r12,16
8000b59e:	fe b0 dc 27 	rcall	80006dec <malloc>
8000b5a2:	99 35       	st.w	r12[0xc],r5
8000b5a4:	8f 9c       	st.w	r7[0x24],r12
8000b5a6:	99 15       	st.w	r12[0x4],r5
8000b5a8:	99 25       	st.w	r12[0x8],r5
8000b5aa:	99 05       	st.w	r12[0x0],r5
8000b5ac:	6e 93       	ld.w	r3,r7[0x24]
8000b5ae:	66 25       	ld.w	r5,r3[0x8]
8000b5b0:	58 05       	cp.w	r5,0
8000b5b2:	c0 c1       	brne	8000b5ca <__pow5mult+0x56>
8000b5b4:	e0 6b 02 71 	mov	r11,625
8000b5b8:	0e 9c       	mov	r12,r7
8000b5ba:	c9 7f       	rcall	8000b4e8 <__i2b>
8000b5bc:	87 2c       	st.w	r3[0x8],r12
8000b5be:	30 08       	mov	r8,0
8000b5c0:	18 95       	mov	r5,r12
8000b5c2:	99 08       	st.w	r12[0x0],r8
8000b5c4:	c0 38       	rjmp	8000b5ca <__pow5mult+0x56>
8000b5c6:	06 9c       	mov	r12,r3
8000b5c8:	18 95       	mov	r5,r12
8000b5ca:	ed b6 00 00 	bld	r6,0x0
8000b5ce:	c0 b1       	brne	8000b5e4 <__pow5mult+0x70>
8000b5d0:	08 9b       	mov	r11,r4
8000b5d2:	0a 9a       	mov	r10,r5
8000b5d4:	0e 9c       	mov	r12,r7
8000b5d6:	c0 9f       	rcall	8000b3e8 <__multiply>
8000b5d8:	08 9b       	mov	r11,r4
8000b5da:	18 93       	mov	r3,r12
8000b5dc:	0e 9c       	mov	r12,r7
8000b5de:	06 94       	mov	r4,r3
8000b5e0:	fe b0 fd b6 	rcall	8000b14c <_Bfree>
8000b5e4:	a1 56       	asr	r6,0x1
8000b5e6:	c0 b0       	breq	8000b5fc <__pow5mult+0x88>
8000b5e8:	6a 03       	ld.w	r3,r5[0x0]
8000b5ea:	58 03       	cp.w	r3,0
8000b5ec:	ce d1       	brne	8000b5c6 <__pow5mult+0x52>
8000b5ee:	0a 9a       	mov	r10,r5
8000b5f0:	0a 9b       	mov	r11,r5
8000b5f2:	0e 9c       	mov	r12,r7
8000b5f4:	cf ae       	rcall	8000b3e8 <__multiply>
8000b5f6:	8b 0c       	st.w	r5[0x0],r12
8000b5f8:	99 03       	st.w	r12[0x0],r3
8000b5fa:	ce 7b       	rjmp	8000b5c8 <__pow5mult+0x54>
8000b5fc:	08 9c       	mov	r12,r4
8000b5fe:	d8 32       	popm	r0-r7,pc

8000b600 <__isinfd>:
8000b600:	14 98       	mov	r8,r10
8000b602:	fc 19 7f f0 	movh	r9,0x7ff0
8000b606:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b60a:	f0 0b 11 00 	rsub	r11,r8,0
8000b60e:	f7 e8 10 08 	or	r8,r11,r8
8000b612:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000b616:	f2 08 01 08 	sub	r8,r9,r8
8000b61a:	f0 0c 11 00 	rsub	r12,r8,0
8000b61e:	f9 e8 10 08 	or	r8,r12,r8
8000b622:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000b626:	2f fc       	sub	r12,-1
8000b628:	5e fc       	retal	r12

8000b62a <__isnand>:
8000b62a:	14 98       	mov	r8,r10
8000b62c:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b630:	f0 0c 11 00 	rsub	r12,r8,0
8000b634:	10 4c       	or	r12,r8
8000b636:	fc 18 7f f0 	movh	r8,0x7ff0
8000b63a:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000b63e:	f0 0c 01 0c 	sub	r12,r8,r12
8000b642:	bf 9c       	lsr	r12,0x1f
8000b644:	5e fc       	retal	r12
8000b646:	d7 03       	nop

8000b648 <__sclose>:
8000b648:	d4 01       	pushm	lr
8000b64a:	96 7b       	ld.sh	r11,r11[0xe]
8000b64c:	c8 2c       	rcall	8000b750 <_close_r>
8000b64e:	d8 02       	popm	pc

8000b650 <__sseek>:
8000b650:	d4 21       	pushm	r4-r7,lr
8000b652:	16 97       	mov	r7,r11
8000b654:	96 7b       	ld.sh	r11,r11[0xe]
8000b656:	c0 3d       	rcall	8000b85c <_lseek_r>
8000b658:	8e 68       	ld.sh	r8,r7[0xc]
8000b65a:	10 99       	mov	r9,r8
8000b65c:	ad c8       	cbr	r8,0xc
8000b65e:	ad a9       	sbr	r9,0xc
8000b660:	5b fc       	cp.w	r12,-1
8000b662:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000b666:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000b66a:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000b66e:	d8 22       	popm	r4-r7,pc

8000b670 <__swrite>:
8000b670:	d4 21       	pushm	r4-r7,lr
8000b672:	96 68       	ld.sh	r8,r11[0xc]
8000b674:	16 97       	mov	r7,r11
8000b676:	14 95       	mov	r5,r10
8000b678:	12 94       	mov	r4,r9
8000b67a:	e2 18 01 00 	andl	r8,0x100,COH
8000b67e:	18 96       	mov	r6,r12
8000b680:	c0 50       	breq	8000b68a <__swrite+0x1a>
8000b682:	30 29       	mov	r9,2
8000b684:	30 0a       	mov	r10,0
8000b686:	96 7b       	ld.sh	r11,r11[0xe]
8000b688:	ce ac       	rcall	8000b85c <_lseek_r>
8000b68a:	8e 68       	ld.sh	r8,r7[0xc]
8000b68c:	ad c8       	cbr	r8,0xc
8000b68e:	08 99       	mov	r9,r4
8000b690:	0a 9a       	mov	r10,r5
8000b692:	8e 7b       	ld.sh	r11,r7[0xe]
8000b694:	0c 9c       	mov	r12,r6
8000b696:	ae 68       	st.h	r7[0xc],r8
8000b698:	c1 cc       	rcall	8000b6d0 <_write_r>
8000b69a:	d8 22       	popm	r4-r7,pc

8000b69c <__sread>:
8000b69c:	d4 21       	pushm	r4-r7,lr
8000b69e:	16 97       	mov	r7,r11
8000b6a0:	96 7b       	ld.sh	r11,r11[0xe]
8000b6a2:	cf 1c       	rcall	8000b884 <_read_r>
8000b6a4:	c0 65       	brlt	8000b6b0 <__sread+0x14>
8000b6a6:	6f 58       	ld.w	r8,r7[0x54]
8000b6a8:	18 08       	add	r8,r12
8000b6aa:	ef 48 00 54 	st.w	r7[84],r8
8000b6ae:	d8 22       	popm	r4-r7,pc
8000b6b0:	8e 68       	ld.sh	r8,r7[0xc]
8000b6b2:	ad c8       	cbr	r8,0xc
8000b6b4:	ae 68       	st.h	r7[0xc],r8
8000b6b6:	d8 22       	popm	r4-r7,pc

8000b6b8 <strlen>:
8000b6b8:	30 09       	mov	r9,0
8000b6ba:	18 98       	mov	r8,r12
8000b6bc:	c0 28       	rjmp	8000b6c0 <strlen+0x8>
8000b6be:	2f f8       	sub	r8,-1
8000b6c0:	11 8a       	ld.ub	r10,r8[0x0]
8000b6c2:	f2 0a 18 00 	cp.b	r10,r9
8000b6c6:	cf c1       	brne	8000b6be <strlen+0x6>
8000b6c8:	f0 0c 01 0c 	sub	r12,r8,r12
8000b6cc:	5e fc       	retal	r12
8000b6ce:	d7 03       	nop

8000b6d0 <_write_r>:
8000b6d0:	d4 21       	pushm	r4-r7,lr
8000b6d2:	16 98       	mov	r8,r11
8000b6d4:	18 97       	mov	r7,r12
8000b6d6:	10 9c       	mov	r12,r8
8000b6d8:	30 08       	mov	r8,0
8000b6da:	14 9b       	mov	r11,r10
8000b6dc:	e0 66 51 1c 	mov	r6,20764
8000b6e0:	12 9a       	mov	r10,r9
8000b6e2:	8d 08       	st.w	r6[0x0],r8
8000b6e4:	fe b0 d1 b6 	rcall	80005a50 <_write>
8000b6e8:	5b fc       	cp.w	r12,-1
8000b6ea:	c0 51       	brne	8000b6f4 <_write_r+0x24>
8000b6ec:	6c 08       	ld.w	r8,r6[0x0]
8000b6ee:	58 08       	cp.w	r8,0
8000b6f0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b6f4:	d8 22       	popm	r4-r7,pc
8000b6f6:	d7 03       	nop

8000b6f8 <_calloc_r>:
8000b6f8:	d4 21       	pushm	r4-r7,lr
8000b6fa:	f4 0b 02 4b 	mul	r11,r10,r11
8000b6fe:	fe b0 db 7f 	rcall	80006dfc <_malloc_r>
8000b702:	18 97       	mov	r7,r12
8000b704:	c2 30       	breq	8000b74a <_calloc_r+0x52>
8000b706:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000b70a:	e0 1a ff fc 	andl	r10,0xfffc
8000b70e:	20 4a       	sub	r10,4
8000b710:	e0 4a 00 24 	cp.w	r10,36
8000b714:	e0 8b 00 18 	brhi	8000b744 <_calloc_r+0x4c>
8000b718:	18 98       	mov	r8,r12
8000b71a:	59 3a       	cp.w	r10,19
8000b71c:	e0 88 00 0f 	brls	8000b73a <_calloc_r+0x42>
8000b720:	30 09       	mov	r9,0
8000b722:	10 a9       	st.w	r8++,r9
8000b724:	10 a9       	st.w	r8++,r9
8000b726:	59 ba       	cp.w	r10,27
8000b728:	e0 88 00 09 	brls	8000b73a <_calloc_r+0x42>
8000b72c:	10 a9       	st.w	r8++,r9
8000b72e:	10 a9       	st.w	r8++,r9
8000b730:	e0 4a 00 24 	cp.w	r10,36
8000b734:	c0 31       	brne	8000b73a <_calloc_r+0x42>
8000b736:	10 a9       	st.w	r8++,r9
8000b738:	10 a9       	st.w	r8++,r9
8000b73a:	30 09       	mov	r9,0
8000b73c:	10 a9       	st.w	r8++,r9
8000b73e:	91 19       	st.w	r8[0x4],r9
8000b740:	91 09       	st.w	r8[0x0],r9
8000b742:	c0 48       	rjmp	8000b74a <_calloc_r+0x52>
8000b744:	30 0b       	mov	r11,0
8000b746:	fe b0 de 1b 	rcall	8000737c <memset>
8000b74a:	0e 9c       	mov	r12,r7
8000b74c:	d8 22       	popm	r4-r7,pc
8000b74e:	d7 03       	nop

8000b750 <_close_r>:
8000b750:	d4 21       	pushm	r4-r7,lr
8000b752:	30 08       	mov	r8,0
8000b754:	18 97       	mov	r7,r12
8000b756:	e0 66 51 1c 	mov	r6,20764
8000b75a:	16 9c       	mov	r12,r11
8000b75c:	8d 08       	st.w	r6[0x0],r8
8000b75e:	fe b0 df b5 	rcall	800076c8 <_close>
8000b762:	5b fc       	cp.w	r12,-1
8000b764:	c0 51       	brne	8000b76e <_close_r+0x1e>
8000b766:	6c 08       	ld.w	r8,r6[0x0]
8000b768:	58 08       	cp.w	r8,0
8000b76a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b76e:	d8 22       	popm	r4-r7,pc

8000b770 <_fclose_r>:
8000b770:	d4 21       	pushm	r4-r7,lr
8000b772:	18 96       	mov	r6,r12
8000b774:	16 97       	mov	r7,r11
8000b776:	58 0b       	cp.w	r11,0
8000b778:	c0 31       	brne	8000b77e <_fclose_r+0xe>
8000b77a:	16 95       	mov	r5,r11
8000b77c:	c5 38       	rjmp	8000b822 <_fclose_r+0xb2>
8000b77e:	fe b0 f8 a9 	rcall	8000a8d0 <__sfp_lock_acquire>
8000b782:	58 06       	cp.w	r6,0
8000b784:	c0 70       	breq	8000b792 <_fclose_r+0x22>
8000b786:	6c 68       	ld.w	r8,r6[0x18]
8000b788:	58 08       	cp.w	r8,0
8000b78a:	c0 41       	brne	8000b792 <_fclose_r+0x22>
8000b78c:	0c 9c       	mov	r12,r6
8000b78e:	fe b0 f8 f3 	rcall	8000a974 <__sinit>
8000b792:	fe c8 dd fa 	sub	r8,pc,-8710
8000b796:	10 37       	cp.w	r7,r8
8000b798:	c0 31       	brne	8000b79e <_fclose_r+0x2e>
8000b79a:	6c 07       	ld.w	r7,r6[0x0]
8000b79c:	c0 c8       	rjmp	8000b7b4 <_fclose_r+0x44>
8000b79e:	fe c8 dd e6 	sub	r8,pc,-8730
8000b7a2:	10 37       	cp.w	r7,r8
8000b7a4:	c0 31       	brne	8000b7aa <_fclose_r+0x3a>
8000b7a6:	6c 17       	ld.w	r7,r6[0x4]
8000b7a8:	c0 68       	rjmp	8000b7b4 <_fclose_r+0x44>
8000b7aa:	fe c8 dd d2 	sub	r8,pc,-8750
8000b7ae:	10 37       	cp.w	r7,r8
8000b7b0:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b7b4:	8e 69       	ld.sh	r9,r7[0xc]
8000b7b6:	30 08       	mov	r8,0
8000b7b8:	f0 09 19 00 	cp.h	r9,r8
8000b7bc:	c0 51       	brne	8000b7c6 <_fclose_r+0x56>
8000b7be:	fe b0 f8 8a 	rcall	8000a8d2 <__sfp_lock_release>
8000b7c2:	30 05       	mov	r5,0
8000b7c4:	c2 f8       	rjmp	8000b822 <_fclose_r+0xb2>
8000b7c6:	0e 9b       	mov	r11,r7
8000b7c8:	0c 9c       	mov	r12,r6
8000b7ca:	fe b0 f7 fd 	rcall	8000a7c4 <_fflush_r>
8000b7ce:	6e c8       	ld.w	r8,r7[0x30]
8000b7d0:	18 95       	mov	r5,r12
8000b7d2:	58 08       	cp.w	r8,0
8000b7d4:	c0 60       	breq	8000b7e0 <_fclose_r+0x70>
8000b7d6:	6e 8b       	ld.w	r11,r7[0x20]
8000b7d8:	0c 9c       	mov	r12,r6
8000b7da:	5d 18       	icall	r8
8000b7dc:	f9 b5 05 ff 	movlt	r5,-1
8000b7e0:	8e 68       	ld.sh	r8,r7[0xc]
8000b7e2:	ed b8 00 07 	bld	r8,0x7
8000b7e6:	c0 51       	brne	8000b7f0 <_fclose_r+0x80>
8000b7e8:	6e 4b       	ld.w	r11,r7[0x10]
8000b7ea:	0c 9c       	mov	r12,r6
8000b7ec:	fe b0 f9 5e 	rcall	8000aaa8 <_free_r>
8000b7f0:	6e db       	ld.w	r11,r7[0x34]
8000b7f2:	58 0b       	cp.w	r11,0
8000b7f4:	c0 a0       	breq	8000b808 <_fclose_r+0x98>
8000b7f6:	ee c8 ff bc 	sub	r8,r7,-68
8000b7fa:	10 3b       	cp.w	r11,r8
8000b7fc:	c0 40       	breq	8000b804 <_fclose_r+0x94>
8000b7fe:	0c 9c       	mov	r12,r6
8000b800:	fe b0 f9 54 	rcall	8000aaa8 <_free_r>
8000b804:	30 08       	mov	r8,0
8000b806:	8f d8       	st.w	r7[0x34],r8
8000b808:	6f 2b       	ld.w	r11,r7[0x48]
8000b80a:	58 0b       	cp.w	r11,0
8000b80c:	c0 70       	breq	8000b81a <_fclose_r+0xaa>
8000b80e:	0c 9c       	mov	r12,r6
8000b810:	fe b0 f9 4c 	rcall	8000aaa8 <_free_r>
8000b814:	30 08       	mov	r8,0
8000b816:	ef 48 00 48 	st.w	r7[72],r8
8000b81a:	30 08       	mov	r8,0
8000b81c:	ae 68       	st.h	r7[0xc],r8
8000b81e:	fe b0 f8 5a 	rcall	8000a8d2 <__sfp_lock_release>
8000b822:	0a 9c       	mov	r12,r5
8000b824:	d8 22       	popm	r4-r7,pc
8000b826:	d7 03       	nop

8000b828 <fclose>:
8000b828:	d4 01       	pushm	lr
8000b82a:	e0 68 0a 38 	mov	r8,2616
8000b82e:	18 9b       	mov	r11,r12
8000b830:	70 0c       	ld.w	r12,r8[0x0]
8000b832:	c9 ff       	rcall	8000b770 <_fclose_r>
8000b834:	d8 02       	popm	pc
8000b836:	d7 03       	nop

8000b838 <_fstat_r>:
8000b838:	d4 21       	pushm	r4-r7,lr
8000b83a:	16 98       	mov	r8,r11
8000b83c:	18 97       	mov	r7,r12
8000b83e:	10 9c       	mov	r12,r8
8000b840:	30 08       	mov	r8,0
8000b842:	e0 66 51 1c 	mov	r6,20764
8000b846:	14 9b       	mov	r11,r10
8000b848:	8d 08       	st.w	r6[0x0],r8
8000b84a:	fe b0 df 67 	rcall	80007718 <_fstat>
8000b84e:	5b fc       	cp.w	r12,-1
8000b850:	c0 51       	brne	8000b85a <_fstat_r+0x22>
8000b852:	6c 08       	ld.w	r8,r6[0x0]
8000b854:	58 08       	cp.w	r8,0
8000b856:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b85a:	d8 22       	popm	r4-r7,pc

8000b85c <_lseek_r>:
8000b85c:	d4 21       	pushm	r4-r7,lr
8000b85e:	16 98       	mov	r8,r11
8000b860:	18 97       	mov	r7,r12
8000b862:	10 9c       	mov	r12,r8
8000b864:	30 08       	mov	r8,0
8000b866:	14 9b       	mov	r11,r10
8000b868:	e0 66 51 1c 	mov	r6,20764
8000b86c:	12 9a       	mov	r10,r9
8000b86e:	8d 08       	st.w	r6[0x0],r8
8000b870:	fe b0 df 36 	rcall	800076dc <_lseek>
8000b874:	5b fc       	cp.w	r12,-1
8000b876:	c0 51       	brne	8000b880 <_lseek_r+0x24>
8000b878:	6c 08       	ld.w	r8,r6[0x0]
8000b87a:	58 08       	cp.w	r8,0
8000b87c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b880:	d8 22       	popm	r4-r7,pc
8000b882:	d7 03       	nop

8000b884 <_read_r>:
8000b884:	d4 21       	pushm	r4-r7,lr
8000b886:	16 98       	mov	r8,r11
8000b888:	18 97       	mov	r7,r12
8000b88a:	10 9c       	mov	r12,r8
8000b88c:	30 08       	mov	r8,0
8000b88e:	14 9b       	mov	r11,r10
8000b890:	e0 66 51 1c 	mov	r6,20764
8000b894:	12 9a       	mov	r10,r9
8000b896:	8d 08       	st.w	r6[0x0],r8
8000b898:	fe b0 d0 bc 	rcall	80005a10 <_read>
8000b89c:	5b fc       	cp.w	r12,-1
8000b89e:	c0 51       	brne	8000b8a8 <_read_r+0x24>
8000b8a0:	6c 08       	ld.w	r8,r6[0x0]
8000b8a2:	58 08       	cp.w	r8,0
8000b8a4:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b8a8:	d8 22       	popm	r4-r7,pc
8000b8aa:	d7 03       	nop

8000b8ac <__avr32_f64_mul>:
8000b8ac:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b8b0:	e0 80 00 dc 	breq	8000ba68 <__avr32_f64_mul_op1_zero>
8000b8b4:	d4 21       	pushm	r4-r7,lr
8000b8b6:	f7 e9 20 0e 	eor	lr,r11,r9
8000b8ba:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b8be:	30 15       	mov	r5,1
8000b8c0:	c4 30       	breq	8000b946 <__avr32_f64_mul_op1_subnormal>
8000b8c2:	ab 6b       	lsl	r11,0xa
8000b8c4:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000b8c8:	ab 6a       	lsl	r10,0xa
8000b8ca:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000b8ce:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b8d2:	c5 c0       	breq	8000b98a <__avr32_f64_mul_op2_subnormal>
8000b8d4:	a1 78       	lsl	r8,0x1
8000b8d6:	5c f9       	rol	r9
8000b8d8:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b8dc:	e0 47 07 ff 	cp.w	r7,2047
8000b8e0:	c7 70       	breq	8000b9ce <__avr32_f64_mul_op_nan_or_inf>
8000b8e2:	e0 46 07 ff 	cp.w	r6,2047
8000b8e6:	c7 40       	breq	8000b9ce <__avr32_f64_mul_op_nan_or_inf>
8000b8e8:	ee 06 00 0c 	add	r12,r7,r6
8000b8ec:	e0 2c 03 fe 	sub	r12,1022
8000b8f0:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b8f4:	f4 09 07 44 	macu.d	r4,r10,r9
8000b8f8:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b8fc:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b900:	08 07       	add	r7,r4
8000b902:	f4 05 00 4a 	adc	r10,r10,r5
8000b906:	5c 0b       	acr	r11
8000b908:	ed bb 00 14 	bld	r11,0x14
8000b90c:	c0 50       	breq	8000b916 <__avr32_f64_mul+0x6a>
8000b90e:	a1 77       	lsl	r7,0x1
8000b910:	5c fa       	rol	r10
8000b912:	5c fb       	rol	r11
8000b914:	20 1c       	sub	r12,1
8000b916:	58 0c       	cp.w	r12,0
8000b918:	e0 8a 00 6f 	brle	8000b9f6 <__avr32_f64_mul_res_subnormal>
8000b91c:	e0 4c 07 ff 	cp.w	r12,2047
8000b920:	e0 84 00 9c 	brge	8000ba58 <__avr32_f64_mul_res_inf>
8000b924:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b928:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b92c:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b930:	ee 17 80 00 	eorh	r7,0x8000
8000b934:	f1 b7 04 20 	satu	r7,0x1
8000b938:	0e 0a       	add	r10,r7
8000b93a:	5c 0b       	acr	r11
8000b93c:	ed be 00 1f 	bld	lr,0x1f
8000b940:	ef bb 00 1f 	bst	r11,0x1f
8000b944:	d8 22       	popm	r4-r7,pc

8000b946 <__avr32_f64_mul_op1_subnormal>:
8000b946:	e4 1b 00 0f 	andh	r11,0xf
8000b94a:	f4 0c 12 00 	clz	r12,r10
8000b94e:	f6 06 12 00 	clz	r6,r11
8000b952:	f7 bc 03 e1 	sublo	r12,-31
8000b956:	f8 06 17 30 	movlo	r6,r12
8000b95a:	f7 b6 02 01 	subhs	r6,1
8000b95e:	e0 46 00 20 	cp.w	r6,32
8000b962:	c0 d4       	brge	8000b97c <__avr32_f64_mul_op1_subnormal+0x36>
8000b964:	ec 0c 11 20 	rsub	r12,r6,32
8000b968:	f6 06 09 4b 	lsl	r11,r11,r6
8000b96c:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b970:	18 4b       	or	r11,r12
8000b972:	f4 06 09 4a 	lsl	r10,r10,r6
8000b976:	20 b6       	sub	r6,11
8000b978:	0c 17       	sub	r7,r6
8000b97a:	ca ab       	rjmp	8000b8ce <__avr32_f64_mul+0x22>
8000b97c:	f4 06 09 4b 	lsl	r11,r10,r6
8000b980:	c6 40       	breq	8000ba48 <__avr32_f64_mul_res_zero>
8000b982:	30 0a       	mov	r10,0
8000b984:	20 b6       	sub	r6,11
8000b986:	0c 17       	sub	r7,r6
8000b988:	ca 3b       	rjmp	8000b8ce <__avr32_f64_mul+0x22>

8000b98a <__avr32_f64_mul_op2_subnormal>:
8000b98a:	e4 19 00 0f 	andh	r9,0xf
8000b98e:	f0 0c 12 00 	clz	r12,r8
8000b992:	f2 05 12 00 	clz	r5,r9
8000b996:	f7 bc 03 ea 	sublo	r12,-22
8000b99a:	f8 05 17 30 	movlo	r5,r12
8000b99e:	f7 b5 02 0a 	subhs	r5,10
8000b9a2:	e0 45 00 20 	cp.w	r5,32
8000b9a6:	c0 d4       	brge	8000b9c0 <__avr32_f64_mul_op2_subnormal+0x36>
8000b9a8:	ea 0c 11 20 	rsub	r12,r5,32
8000b9ac:	f2 05 09 49 	lsl	r9,r9,r5
8000b9b0:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000b9b4:	18 49       	or	r9,r12
8000b9b6:	f0 05 09 48 	lsl	r8,r8,r5
8000b9ba:	20 25       	sub	r5,2
8000b9bc:	0a 16       	sub	r6,r5
8000b9be:	c8 fb       	rjmp	8000b8dc <__avr32_f64_mul+0x30>
8000b9c0:	f0 05 09 49 	lsl	r9,r8,r5
8000b9c4:	c4 20       	breq	8000ba48 <__avr32_f64_mul_res_zero>
8000b9c6:	30 08       	mov	r8,0
8000b9c8:	20 25       	sub	r5,2
8000b9ca:	0a 16       	sub	r6,r5
8000b9cc:	c8 8b       	rjmp	8000b8dc <__avr32_f64_mul+0x30>

8000b9ce <__avr32_f64_mul_op_nan_or_inf>:
8000b9ce:	e4 19 00 0f 	andh	r9,0xf
8000b9d2:	e4 1b 00 0f 	andh	r11,0xf
8000b9d6:	14 4b       	or	r11,r10
8000b9d8:	10 49       	or	r9,r8
8000b9da:	e0 47 07 ff 	cp.w	r7,2047
8000b9de:	c0 91       	brne	8000b9f0 <__avr32_f64_mul_op1_not_naninf>
8000b9e0:	58 0b       	cp.w	r11,0
8000b9e2:	c3 81       	brne	8000ba52 <__avr32_f64_mul_res_nan>
8000b9e4:	e0 46 07 ff 	cp.w	r6,2047
8000b9e8:	c3 81       	brne	8000ba58 <__avr32_f64_mul_res_inf>
8000b9ea:	58 09       	cp.w	r9,0
8000b9ec:	c3 60       	breq	8000ba58 <__avr32_f64_mul_res_inf>
8000b9ee:	c3 28       	rjmp	8000ba52 <__avr32_f64_mul_res_nan>

8000b9f0 <__avr32_f64_mul_op1_not_naninf>:
8000b9f0:	58 09       	cp.w	r9,0
8000b9f2:	c3 30       	breq	8000ba58 <__avr32_f64_mul_res_inf>
8000b9f4:	c2 f8       	rjmp	8000ba52 <__avr32_f64_mul_res_nan>

8000b9f6 <__avr32_f64_mul_res_subnormal>:
8000b9f6:	5c 3c       	neg	r12
8000b9f8:	2f fc       	sub	r12,-1
8000b9fa:	f1 bc 04 c0 	satu	r12,0x6
8000b9fe:	e0 4c 00 20 	cp.w	r12,32
8000ba02:	c1 14       	brge	8000ba24 <__avr32_f64_mul_res_subnormal+0x2e>
8000ba04:	f8 08 11 20 	rsub	r8,r12,32
8000ba08:	0e 46       	or	r6,r7
8000ba0a:	ee 0c 0a 47 	lsr	r7,r7,r12
8000ba0e:	f4 08 09 49 	lsl	r9,r10,r8
8000ba12:	12 47       	or	r7,r9
8000ba14:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ba18:	f6 08 09 49 	lsl	r9,r11,r8
8000ba1c:	12 4a       	or	r10,r9
8000ba1e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000ba22:	c8 3b       	rjmp	8000b928 <__avr32_f64_mul+0x7c>
8000ba24:	f8 08 11 20 	rsub	r8,r12,32
8000ba28:	f9 b9 00 00 	moveq	r9,0
8000ba2c:	c0 30       	breq	8000ba32 <__avr32_f64_mul_res_subnormal+0x3c>
8000ba2e:	f6 08 09 49 	lsl	r9,r11,r8
8000ba32:	0e 46       	or	r6,r7
8000ba34:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000ba38:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ba3c:	f3 ea 10 07 	or	r7,r9,r10
8000ba40:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000ba44:	30 0b       	mov	r11,0
8000ba46:	c7 1b       	rjmp	8000b928 <__avr32_f64_mul+0x7c>

8000ba48 <__avr32_f64_mul_res_zero>:
8000ba48:	1c 9b       	mov	r11,lr
8000ba4a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000ba4e:	30 0a       	mov	r10,0
8000ba50:	d8 22       	popm	r4-r7,pc

8000ba52 <__avr32_f64_mul_res_nan>:
8000ba52:	3f fb       	mov	r11,-1
8000ba54:	3f fa       	mov	r10,-1
8000ba56:	d8 22       	popm	r4-r7,pc

8000ba58 <__avr32_f64_mul_res_inf>:
8000ba58:	f0 6b 00 00 	mov	r11,-1048576
8000ba5c:	ed be 00 1f 	bld	lr,0x1f
8000ba60:	ef bb 00 1f 	bst	r11,0x1f
8000ba64:	30 0a       	mov	r10,0
8000ba66:	d8 22       	popm	r4-r7,pc

8000ba68 <__avr32_f64_mul_op1_zero>:
8000ba68:	f7 e9 20 0b 	eor	r11,r11,r9
8000ba6c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000ba70:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000ba74:	e0 4c 07 ff 	cp.w	r12,2047
8000ba78:	5e 1c       	retne	r12
8000ba7a:	3f fa       	mov	r10,-1
8000ba7c:	3f fb       	mov	r11,-1
8000ba7e:	5e fc       	retal	r12

8000ba80 <__avr32_f64_sub_from_add>:
8000ba80:	ee 19 80 00 	eorh	r9,0x8000

8000ba84 <__avr32_f64_sub>:
8000ba84:	f7 e9 20 0c 	eor	r12,r11,r9
8000ba88:	e0 86 00 ca 	brmi	8000bc1c <__avr32_f64_add_from_sub>
8000ba8c:	eb cd 40 e0 	pushm	r5-r7,lr
8000ba90:	16 9c       	mov	r12,r11
8000ba92:	e6 1c 80 00 	andh	r12,0x8000,COH
8000ba96:	bf db       	cbr	r11,0x1f
8000ba98:	bf d9       	cbr	r9,0x1f
8000ba9a:	10 3a       	cp.w	r10,r8
8000ba9c:	f2 0b 13 00 	cpc	r11,r9
8000baa0:	c0 92       	brcc	8000bab2 <__avr32_f64_sub+0x2e>
8000baa2:	16 97       	mov	r7,r11
8000baa4:	12 9b       	mov	r11,r9
8000baa6:	0e 99       	mov	r9,r7
8000baa8:	14 97       	mov	r7,r10
8000baaa:	10 9a       	mov	r10,r8
8000baac:	0e 98       	mov	r8,r7
8000baae:	ee 1c 80 00 	eorh	r12,0x8000
8000bab2:	f6 07 16 14 	lsr	r7,r11,0x14
8000bab6:	ab 7b       	lsl	r11,0xb
8000bab8:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000babc:	ab 7a       	lsl	r10,0xb
8000babe:	bf bb       	sbr	r11,0x1f
8000bac0:	f2 06 16 14 	lsr	r6,r9,0x14
8000bac4:	c4 40       	breq	8000bb4c <__avr32_f64_sub_opL_subnormal>
8000bac6:	ab 79       	lsl	r9,0xb
8000bac8:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bacc:	ab 78       	lsl	r8,0xb
8000bace:	bf b9       	sbr	r9,0x1f

8000bad0 <__avr32_f64_sub_opL_subnormal_done>:
8000bad0:	e0 47 07 ff 	cp.w	r7,2047
8000bad4:	c4 f0       	breq	8000bb72 <__avr32_f64_sub_opH_nan_or_inf>
8000bad6:	0e 26       	rsub	r6,r7
8000bad8:	c1 20       	breq	8000bafc <__avr32_f64_sub_shift_done>
8000bada:	ec 05 11 20 	rsub	r5,r6,32
8000bade:	e0 46 00 20 	cp.w	r6,32
8000bae2:	c7 c2       	brcc	8000bbda <__avr32_f64_sub_longshift>
8000bae4:	f0 05 09 4e 	lsl	lr,r8,r5
8000bae8:	f2 05 09 45 	lsl	r5,r9,r5
8000baec:	f0 06 0a 48 	lsr	r8,r8,r6
8000baf0:	f2 06 0a 49 	lsr	r9,r9,r6
8000baf4:	0a 48       	or	r8,r5
8000baf6:	58 0e       	cp.w	lr,0
8000baf8:	5f 1e       	srne	lr
8000bafa:	1c 48       	or	r8,lr

8000bafc <__avr32_f64_sub_shift_done>:
8000bafc:	10 1a       	sub	r10,r8
8000bafe:	f6 09 01 4b 	sbc	r11,r11,r9
8000bb02:	f6 06 12 00 	clz	r6,r11
8000bb06:	c0 e0       	breq	8000bb22 <__avr32_f64_sub_longnormalize_done>
8000bb08:	c7 83       	brcs	8000bbf8 <__avr32_f64_sub_longnormalize>
8000bb0a:	ec 0e 11 20 	rsub	lr,r6,32
8000bb0e:	f6 06 09 4b 	lsl	r11,r11,r6
8000bb12:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bb16:	1c 4b       	or	r11,lr
8000bb18:	f4 06 09 4a 	lsl	r10,r10,r6
8000bb1c:	0c 17       	sub	r7,r6
8000bb1e:	e0 8a 00 39 	brle	8000bb90 <__avr32_f64_sub_subnormal_result>

8000bb22 <__avr32_f64_sub_longnormalize_done>:
8000bb22:	f4 09 15 15 	lsl	r9,r10,0x15
8000bb26:	ab 9a       	lsr	r10,0xb
8000bb28:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bb2c:	ab 9b       	lsr	r11,0xb
8000bb2e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bb32:	18 4b       	or	r11,r12

8000bb34 <__avr32_f64_sub_round>:
8000bb34:	fc 17 80 00 	movh	r7,0x8000
8000bb38:	ed ba 00 00 	bld	r10,0x0
8000bb3c:	f7 b7 01 ff 	subne	r7,-1
8000bb40:	0e 39       	cp.w	r9,r7
8000bb42:	5f 29       	srhs	r9
8000bb44:	12 0a       	add	r10,r9
8000bb46:	5c 0b       	acr	r11
8000bb48:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bb4c <__avr32_f64_sub_opL_subnormal>:
8000bb4c:	ab 79       	lsl	r9,0xb
8000bb4e:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bb52:	ab 78       	lsl	r8,0xb
8000bb54:	f3 e8 10 0e 	or	lr,r9,r8
8000bb58:	f9 b6 01 01 	movne	r6,1
8000bb5c:	ee 0e 11 00 	rsub	lr,r7,0
8000bb60:	f9 b7 00 01 	moveq	r7,1
8000bb64:	ef bb 00 1f 	bst	r11,0x1f
8000bb68:	f7 ea 10 0e 	or	lr,r11,r10
8000bb6c:	f9 b7 00 00 	moveq	r7,0
8000bb70:	cb 0b       	rjmp	8000bad0 <__avr32_f64_sub_opL_subnormal_done>

8000bb72 <__avr32_f64_sub_opH_nan_or_inf>:
8000bb72:	bf db       	cbr	r11,0x1f
8000bb74:	f7 ea 10 0e 	or	lr,r11,r10
8000bb78:	c0 81       	brne	8000bb88 <__avr32_f64_sub_return_nan>
8000bb7a:	e0 46 07 ff 	cp.w	r6,2047
8000bb7e:	c0 50       	breq	8000bb88 <__avr32_f64_sub_return_nan>
8000bb80:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000bb84:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bb88 <__avr32_f64_sub_return_nan>:
8000bb88:	3f fa       	mov	r10,-1
8000bb8a:	3f fb       	mov	r11,-1
8000bb8c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bb90 <__avr32_f64_sub_subnormal_result>:
8000bb90:	5c 37       	neg	r7
8000bb92:	2f f7       	sub	r7,-1
8000bb94:	f1 b7 04 c0 	satu	r7,0x6
8000bb98:	e0 47 00 20 	cp.w	r7,32
8000bb9c:	c1 14       	brge	8000bbbe <__avr32_f64_sub_subnormal_result+0x2e>
8000bb9e:	ee 08 11 20 	rsub	r8,r7,32
8000bba2:	f4 08 09 49 	lsl	r9,r10,r8
8000bba6:	5f 16       	srne	r6
8000bba8:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bbac:	0c 4a       	or	r10,r6
8000bbae:	f6 08 09 49 	lsl	r9,r11,r8
8000bbb2:	f5 e9 10 0a 	or	r10,r10,r9
8000bbb6:	f4 07 0a 4b 	lsr	r11,r10,r7
8000bbba:	30 07       	mov	r7,0
8000bbbc:	cb 3b       	rjmp	8000bb22 <__avr32_f64_sub_longnormalize_done>
8000bbbe:	ee 08 11 40 	rsub	r8,r7,64
8000bbc2:	f6 08 09 49 	lsl	r9,r11,r8
8000bbc6:	14 49       	or	r9,r10
8000bbc8:	5f 16       	srne	r6
8000bbca:	f6 07 0a 4a 	lsr	r10,r11,r7
8000bbce:	0c 4a       	or	r10,r6
8000bbd0:	30 0b       	mov	r11,0
8000bbd2:	30 07       	mov	r7,0
8000bbd4:	ca 7b       	rjmp	8000bb22 <__avr32_f64_sub_longnormalize_done>
8000bbd6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bbda <__avr32_f64_sub_longshift>:
8000bbda:	f1 b6 04 c0 	satu	r6,0x6
8000bbde:	f0 0e 17 00 	moveq	lr,r8
8000bbe2:	c0 40       	breq	8000bbea <__avr32_f64_sub_longshift+0x10>
8000bbe4:	f2 05 09 4e 	lsl	lr,r9,r5
8000bbe8:	10 4e       	or	lr,r8
8000bbea:	f2 06 0a 48 	lsr	r8,r9,r6
8000bbee:	30 09       	mov	r9,0
8000bbf0:	58 0e       	cp.w	lr,0
8000bbf2:	5f 1e       	srne	lr
8000bbf4:	1c 48       	or	r8,lr
8000bbf6:	c8 3b       	rjmp	8000bafc <__avr32_f64_sub_shift_done>

8000bbf8 <__avr32_f64_sub_longnormalize>:
8000bbf8:	f4 06 12 00 	clz	r6,r10
8000bbfc:	f9 b7 03 00 	movlo	r7,0
8000bc00:	f9 b6 03 00 	movlo	r6,0
8000bc04:	f9 bc 03 00 	movlo	r12,0
8000bc08:	f7 b6 02 e0 	subhs	r6,-32
8000bc0c:	f4 06 09 4b 	lsl	r11,r10,r6
8000bc10:	30 0a       	mov	r10,0
8000bc12:	0c 17       	sub	r7,r6
8000bc14:	fe 9a ff be 	brle	8000bb90 <__avr32_f64_sub_subnormal_result>
8000bc18:	c8 5b       	rjmp	8000bb22 <__avr32_f64_sub_longnormalize_done>
8000bc1a:	d7 03       	nop

8000bc1c <__avr32_f64_add_from_sub>:
8000bc1c:	ee 19 80 00 	eorh	r9,0x8000

8000bc20 <__avr32_f64_add>:
8000bc20:	f7 e9 20 0c 	eor	r12,r11,r9
8000bc24:	fe 96 ff 2e 	brmi	8000ba80 <__avr32_f64_sub_from_add>
8000bc28:	eb cd 40 e0 	pushm	r5-r7,lr
8000bc2c:	16 9c       	mov	r12,r11
8000bc2e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000bc32:	bf db       	cbr	r11,0x1f
8000bc34:	bf d9       	cbr	r9,0x1f
8000bc36:	12 3b       	cp.w	r11,r9
8000bc38:	c0 72       	brcc	8000bc46 <__avr32_f64_add+0x26>
8000bc3a:	16 97       	mov	r7,r11
8000bc3c:	12 9b       	mov	r11,r9
8000bc3e:	0e 99       	mov	r9,r7
8000bc40:	14 97       	mov	r7,r10
8000bc42:	10 9a       	mov	r10,r8
8000bc44:	0e 98       	mov	r8,r7
8000bc46:	30 0e       	mov	lr,0
8000bc48:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bc4c:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000bc50:	b5 ab       	sbr	r11,0x14
8000bc52:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bc56:	c6 20       	breq	8000bd1a <__avr32_f64_add_op2_subnormal>
8000bc58:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000bc5c:	b5 a9       	sbr	r9,0x14
8000bc5e:	e0 47 07 ff 	cp.w	r7,2047
8000bc62:	c2 80       	breq	8000bcb2 <__avr32_f64_add_opH_nan_or_inf>
8000bc64:	0e 26       	rsub	r6,r7
8000bc66:	c1 20       	breq	8000bc8a <__avr32_f64_add_shift_done>
8000bc68:	e0 46 00 36 	cp.w	r6,54
8000bc6c:	c1 52       	brcc	8000bc96 <__avr32_f64_add_res_of_done>
8000bc6e:	ec 05 11 20 	rsub	r5,r6,32
8000bc72:	e0 46 00 20 	cp.w	r6,32
8000bc76:	c3 52       	brcc	8000bce0 <__avr32_f64_add_longshift>
8000bc78:	f0 05 09 4e 	lsl	lr,r8,r5
8000bc7c:	f2 05 09 45 	lsl	r5,r9,r5
8000bc80:	f0 06 0a 48 	lsr	r8,r8,r6
8000bc84:	f2 06 0a 49 	lsr	r9,r9,r6
8000bc88:	0a 48       	or	r8,r5

8000bc8a <__avr32_f64_add_shift_done>:
8000bc8a:	10 0a       	add	r10,r8
8000bc8c:	f6 09 00 4b 	adc	r11,r11,r9
8000bc90:	ed bb 00 15 	bld	r11,0x15
8000bc94:	c3 40       	breq	8000bcfc <__avr32_f64_add_res_of>

8000bc96 <__avr32_f64_add_res_of_done>:
8000bc96:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bc9a:	18 4b       	or	r11,r12

8000bc9c <__avr32_f64_add_round>:
8000bc9c:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000bca0:	18 4e       	or	lr,r12
8000bca2:	ee 1e 80 00 	eorh	lr,0x8000
8000bca6:	f1 be 04 20 	satu	lr,0x1
8000bcaa:	1c 0a       	add	r10,lr
8000bcac:	5c 0b       	acr	r11
8000bcae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bcb2 <__avr32_f64_add_opH_nan_or_inf>:
8000bcb2:	b5 cb       	cbr	r11,0x14
8000bcb4:	f7 ea 10 0e 	or	lr,r11,r10
8000bcb8:	c1 01       	brne	8000bcd8 <__avr32_f64_add_return_nan>
8000bcba:	e0 46 07 ff 	cp.w	r6,2047
8000bcbe:	c0 30       	breq	8000bcc4 <__avr32_f64_add_opL_nan_or_inf>
8000bcc0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bcc4 <__avr32_f64_add_opL_nan_or_inf>:
8000bcc4:	b5 c9       	cbr	r9,0x14
8000bcc6:	f3 e8 10 0e 	or	lr,r9,r8
8000bcca:	c0 71       	brne	8000bcd8 <__avr32_f64_add_return_nan>
8000bccc:	30 0a       	mov	r10,0
8000bcce:	fc 1b 7f f0 	movh	r11,0x7ff0
8000bcd2:	18 4b       	or	r11,r12
8000bcd4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bcd8 <__avr32_f64_add_return_nan>:
8000bcd8:	3f fa       	mov	r10,-1
8000bcda:	3f fb       	mov	r11,-1
8000bcdc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bce0 <__avr32_f64_add_longshift>:
8000bce0:	f1 b6 04 c0 	satu	r6,0x6
8000bce4:	f0 0e 17 00 	moveq	lr,r8
8000bce8:	c0 60       	breq	8000bcf4 <__avr32_f64_add_longshift+0x14>
8000bcea:	f2 05 09 4e 	lsl	lr,r9,r5
8000bcee:	58 08       	cp.w	r8,0
8000bcf0:	5f 18       	srne	r8
8000bcf2:	10 4e       	or	lr,r8
8000bcf4:	f2 06 0a 48 	lsr	r8,r9,r6
8000bcf8:	30 09       	mov	r9,0
8000bcfa:	cc 8b       	rjmp	8000bc8a <__avr32_f64_add_shift_done>

8000bcfc <__avr32_f64_add_res_of>:
8000bcfc:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000bd00:	a1 9b       	lsr	r11,0x1
8000bd02:	5d 0a       	ror	r10
8000bd04:	5d 0e       	ror	lr
8000bd06:	2f f7       	sub	r7,-1
8000bd08:	e0 47 07 ff 	cp.w	r7,2047
8000bd0c:	f9 ba 00 00 	moveq	r10,0
8000bd10:	f9 bb 00 00 	moveq	r11,0
8000bd14:	f9 be 00 00 	moveq	lr,0
8000bd18:	cb fb       	rjmp	8000bc96 <__avr32_f64_add_res_of_done>

8000bd1a <__avr32_f64_add_op2_subnormal>:
8000bd1a:	30 16       	mov	r6,1
8000bd1c:	58 07       	cp.w	r7,0
8000bd1e:	ca 01       	brne	8000bc5e <__avr32_f64_add+0x3e>
8000bd20:	b5 cb       	cbr	r11,0x14
8000bd22:	10 0a       	add	r10,r8
8000bd24:	f6 09 00 4b 	adc	r11,r11,r9
8000bd28:	18 4b       	or	r11,r12
8000bd2a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000bd2e:	d7 03       	nop

8000bd30 <__avr32_f64_to_u32>:
8000bd30:	58 0b       	cp.w	r11,0
8000bd32:	5e 6d       	retmi	0

8000bd34 <__avr32_f64_to_s32>:
8000bd34:	f6 0c 15 01 	lsl	r12,r11,0x1
8000bd38:	b5 9c       	lsr	r12,0x15
8000bd3a:	e0 2c 03 ff 	sub	r12,1023
8000bd3e:	5e 3d       	retlo	0
8000bd40:	f8 0c 11 1f 	rsub	r12,r12,31
8000bd44:	16 99       	mov	r9,r11
8000bd46:	ab 7b       	lsl	r11,0xb
8000bd48:	bf bb       	sbr	r11,0x1f
8000bd4a:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bd4e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bd52:	a1 79       	lsl	r9,0x1
8000bd54:	5e 2b       	reths	r11
8000bd56:	5c 3b       	neg	r11
8000bd58:	5e fb       	retal	r11

8000bd5a <__avr32_u32_to_f64>:
8000bd5a:	f8 cb 00 00 	sub	r11,r12,0
8000bd5e:	30 0c       	mov	r12,0
8000bd60:	c0 38       	rjmp	8000bd66 <__avr32_s32_to_f64+0x4>

8000bd62 <__avr32_s32_to_f64>:
8000bd62:	18 9b       	mov	r11,r12
8000bd64:	5c 4b       	abs	r11
8000bd66:	30 0a       	mov	r10,0
8000bd68:	5e 0b       	reteq	r11
8000bd6a:	d4 01       	pushm	lr
8000bd6c:	e0 69 04 1e 	mov	r9,1054
8000bd70:	f6 08 12 00 	clz	r8,r11
8000bd74:	c1 70       	breq	8000bda2 <__avr32_s32_to_f64+0x40>
8000bd76:	c0 c3       	brcs	8000bd8e <__avr32_s32_to_f64+0x2c>
8000bd78:	f0 0e 11 20 	rsub	lr,r8,32
8000bd7c:	f6 08 09 4b 	lsl	r11,r11,r8
8000bd80:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bd84:	1c 4b       	or	r11,lr
8000bd86:	f4 08 09 4a 	lsl	r10,r10,r8
8000bd8a:	10 19       	sub	r9,r8
8000bd8c:	c0 b8       	rjmp	8000bda2 <__avr32_s32_to_f64+0x40>
8000bd8e:	f4 08 12 00 	clz	r8,r10
8000bd92:	f9 b8 03 00 	movlo	r8,0
8000bd96:	f7 b8 02 e0 	subhs	r8,-32
8000bd9a:	f4 08 09 4b 	lsl	r11,r10,r8
8000bd9e:	30 0a       	mov	r10,0
8000bda0:	10 19       	sub	r9,r8
8000bda2:	58 09       	cp.w	r9,0
8000bda4:	e0 89 00 30 	brgt	8000be04 <__avr32_s32_to_f64+0xa2>
8000bda8:	5c 39       	neg	r9
8000bdaa:	2f f9       	sub	r9,-1
8000bdac:	e0 49 00 36 	cp.w	r9,54
8000bdb0:	c0 43       	brcs	8000bdb8 <__avr32_s32_to_f64+0x56>
8000bdb2:	30 0b       	mov	r11,0
8000bdb4:	30 0a       	mov	r10,0
8000bdb6:	c2 68       	rjmp	8000be02 <__avr32_s32_to_f64+0xa0>
8000bdb8:	2f 69       	sub	r9,-10
8000bdba:	f2 08 11 20 	rsub	r8,r9,32
8000bdbe:	e0 49 00 20 	cp.w	r9,32
8000bdc2:	c0 b2       	brcc	8000bdd8 <__avr32_s32_to_f64+0x76>
8000bdc4:	f4 08 09 4e 	lsl	lr,r10,r8
8000bdc8:	f6 08 09 48 	lsl	r8,r11,r8
8000bdcc:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bdd0:	f6 09 0a 4b 	lsr	r11,r11,r9
8000bdd4:	10 4b       	or	r11,r8
8000bdd6:	c0 88       	rjmp	8000bde6 <__avr32_s32_to_f64+0x84>
8000bdd8:	f6 08 09 4e 	lsl	lr,r11,r8
8000bddc:	14 4e       	or	lr,r10
8000bdde:	16 9a       	mov	r10,r11
8000bde0:	30 0b       	mov	r11,0
8000bde2:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bde6:	ed ba 00 00 	bld	r10,0x0
8000bdea:	c0 92       	brcc	8000bdfc <__avr32_s32_to_f64+0x9a>
8000bdec:	1c 7e       	tst	lr,lr
8000bdee:	c0 41       	brne	8000bdf6 <__avr32_s32_to_f64+0x94>
8000bdf0:	ed ba 00 01 	bld	r10,0x1
8000bdf4:	c0 42       	brcc	8000bdfc <__avr32_s32_to_f64+0x9a>
8000bdf6:	2f fa       	sub	r10,-1
8000bdf8:	f7 bb 02 ff 	subhs	r11,-1
8000bdfc:	5c fc       	rol	r12
8000bdfe:	5d 0b       	ror	r11
8000be00:	5d 0a       	ror	r10
8000be02:	d8 02       	popm	pc
8000be04:	e0 68 03 ff 	mov	r8,1023
8000be08:	ed ba 00 0b 	bld	r10,0xb
8000be0c:	f7 b8 00 ff 	subeq	r8,-1
8000be10:	10 0a       	add	r10,r8
8000be12:	5c 0b       	acr	r11
8000be14:	f7 b9 03 fe 	sublo	r9,-2
8000be18:	e0 49 07 ff 	cp.w	r9,2047
8000be1c:	c0 55       	brlt	8000be26 <__avr32_s32_to_f64+0xc4>
8000be1e:	30 0a       	mov	r10,0
8000be20:	fc 1b ff e0 	movh	r11,0xffe0
8000be24:	c0 c8       	rjmp	8000be3c <__floatsidf_return_op1>
8000be26:	ed bb 00 1f 	bld	r11,0x1f
8000be2a:	f7 b9 01 01 	subne	r9,1
8000be2e:	ab 9a       	lsr	r10,0xb
8000be30:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000be34:	a1 7b       	lsl	r11,0x1
8000be36:	ab 9b       	lsr	r11,0xb
8000be38:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000be3c <__floatsidf_return_op1>:
8000be3c:	a1 7c       	lsl	r12,0x1
8000be3e:	5d 0b       	ror	r11
8000be40:	d8 02       	popm	pc

8000be42 <__avr32_f64_cmp_eq>:
8000be42:	10 3a       	cp.w	r10,r8
8000be44:	f2 0b 13 00 	cpc	r11,r9
8000be48:	c0 80       	breq	8000be58 <__avr32_f64_cmp_eq+0x16>
8000be4a:	a1 7b       	lsl	r11,0x1
8000be4c:	a1 79       	lsl	r9,0x1
8000be4e:	14 4b       	or	r11,r10
8000be50:	12 4b       	or	r11,r9
8000be52:	10 4b       	or	r11,r8
8000be54:	5e 0f       	reteq	1
8000be56:	5e fd       	retal	0
8000be58:	a1 7b       	lsl	r11,0x1
8000be5a:	fc 1c ff e0 	movh	r12,0xffe0
8000be5e:	58 0a       	cp.w	r10,0
8000be60:	f8 0b 13 00 	cpc	r11,r12
8000be64:	5e 8f       	retls	1
8000be66:	5e fd       	retal	0

8000be68 <__avr32_f64_cmp_ge>:
8000be68:	1a de       	st.w	--sp,lr
8000be6a:	1a d7       	st.w	--sp,r7
8000be6c:	a1 7b       	lsl	r11,0x1
8000be6e:	5f 3c       	srlo	r12
8000be70:	a1 79       	lsl	r9,0x1
8000be72:	5f 37       	srlo	r7
8000be74:	5c fc       	rol	r12
8000be76:	fc 1e ff e0 	movh	lr,0xffe0
8000be7a:	58 0a       	cp.w	r10,0
8000be7c:	fc 0b 13 00 	cpc	r11,lr
8000be80:	e0 8b 00 1d 	brhi	8000beba <__avr32_f64_cmp_ge+0x52>
8000be84:	58 08       	cp.w	r8,0
8000be86:	fc 09 13 00 	cpc	r9,lr
8000be8a:	e0 8b 00 18 	brhi	8000beba <__avr32_f64_cmp_ge+0x52>
8000be8e:	58 0b       	cp.w	r11,0
8000be90:	f5 ba 00 00 	subfeq	r10,0
8000be94:	c1 50       	breq	8000bebe <__avr32_f64_cmp_ge+0x56>
8000be96:	1b 07       	ld.w	r7,sp++
8000be98:	1b 0e       	ld.w	lr,sp++
8000be9a:	58 3c       	cp.w	r12,3
8000be9c:	c0 a0       	breq	8000beb0 <__avr32_f64_cmp_ge+0x48>
8000be9e:	58 1c       	cp.w	r12,1
8000bea0:	c0 33       	brcs	8000bea6 <__avr32_f64_cmp_ge+0x3e>
8000bea2:	5e 0f       	reteq	1
8000bea4:	5e 1d       	retne	0
8000bea6:	10 3a       	cp.w	r10,r8
8000bea8:	f2 0b 13 00 	cpc	r11,r9
8000beac:	5e 2f       	reths	1
8000beae:	5e 3d       	retlo	0
8000beb0:	14 38       	cp.w	r8,r10
8000beb2:	f6 09 13 00 	cpc	r9,r11
8000beb6:	5e 2f       	reths	1
8000beb8:	5e 3d       	retlo	0
8000beba:	1b 07       	ld.w	r7,sp++
8000bebc:	d8 0a       	popm	pc,r12=0
8000bebe:	58 17       	cp.w	r7,1
8000bec0:	5f 0c       	sreq	r12
8000bec2:	58 09       	cp.w	r9,0
8000bec4:	f5 b8 00 00 	subfeq	r8,0
8000bec8:	1b 07       	ld.w	r7,sp++
8000beca:	1b 0e       	ld.w	lr,sp++
8000becc:	5e 0f       	reteq	1
8000bece:	5e fc       	retal	r12

8000bed0 <__avr32_f64_cmp_lt>:
8000bed0:	1a de       	st.w	--sp,lr
8000bed2:	1a d7       	st.w	--sp,r7
8000bed4:	a1 7b       	lsl	r11,0x1
8000bed6:	5f 3c       	srlo	r12
8000bed8:	a1 79       	lsl	r9,0x1
8000beda:	5f 37       	srlo	r7
8000bedc:	5c fc       	rol	r12
8000bede:	fc 1e ff e0 	movh	lr,0xffe0
8000bee2:	58 0a       	cp.w	r10,0
8000bee4:	fc 0b 13 00 	cpc	r11,lr
8000bee8:	e0 8b 00 1d 	brhi	8000bf22 <__avr32_f64_cmp_lt+0x52>
8000beec:	58 08       	cp.w	r8,0
8000beee:	fc 09 13 00 	cpc	r9,lr
8000bef2:	e0 8b 00 18 	brhi	8000bf22 <__avr32_f64_cmp_lt+0x52>
8000bef6:	58 0b       	cp.w	r11,0
8000bef8:	f5 ba 00 00 	subfeq	r10,0
8000befc:	c1 50       	breq	8000bf26 <__avr32_f64_cmp_lt+0x56>
8000befe:	1b 07       	ld.w	r7,sp++
8000bf00:	1b 0e       	ld.w	lr,sp++
8000bf02:	58 3c       	cp.w	r12,3
8000bf04:	c0 a0       	breq	8000bf18 <__avr32_f64_cmp_lt+0x48>
8000bf06:	58 1c       	cp.w	r12,1
8000bf08:	c0 33       	brcs	8000bf0e <__avr32_f64_cmp_lt+0x3e>
8000bf0a:	5e 0d       	reteq	0
8000bf0c:	5e 1f       	retne	1
8000bf0e:	10 3a       	cp.w	r10,r8
8000bf10:	f2 0b 13 00 	cpc	r11,r9
8000bf14:	5e 2d       	reths	0
8000bf16:	5e 3f       	retlo	1
8000bf18:	14 38       	cp.w	r8,r10
8000bf1a:	f6 09 13 00 	cpc	r9,r11
8000bf1e:	5e 2d       	reths	0
8000bf20:	5e 3f       	retlo	1
8000bf22:	1b 07       	ld.w	r7,sp++
8000bf24:	d8 0a       	popm	pc,r12=0
8000bf26:	58 17       	cp.w	r7,1
8000bf28:	5f 1c       	srne	r12
8000bf2a:	58 09       	cp.w	r9,0
8000bf2c:	f5 b8 00 00 	subfeq	r8,0
8000bf30:	1b 07       	ld.w	r7,sp++
8000bf32:	1b 0e       	ld.w	lr,sp++
8000bf34:	5e 0d       	reteq	0
8000bf36:	5e fc       	retal	r12

8000bf38 <__avr32_f64_div>:
8000bf38:	eb cd 40 ff 	pushm	r0-r7,lr
8000bf3c:	f7 e9 20 0e 	eor	lr,r11,r9
8000bf40:	f6 07 16 14 	lsr	r7,r11,0x14
8000bf44:	a9 7b       	lsl	r11,0x9
8000bf46:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000bf4a:	a9 7a       	lsl	r10,0x9
8000bf4c:	bd bb       	sbr	r11,0x1d
8000bf4e:	e4 1b 3f ff 	andh	r11,0x3fff
8000bf52:	ab d7       	cbr	r7,0xb
8000bf54:	e0 80 00 cc 	breq	8000c0ec <__avr32_f64_div_round_subnormal+0x54>
8000bf58:	e0 47 07 ff 	cp.w	r7,2047
8000bf5c:	e0 84 00 b5 	brge	8000c0c6 <__avr32_f64_div_round_subnormal+0x2e>
8000bf60:	f2 06 16 14 	lsr	r6,r9,0x14
8000bf64:	a9 79       	lsl	r9,0x9
8000bf66:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000bf6a:	a9 78       	lsl	r8,0x9
8000bf6c:	bd b9       	sbr	r9,0x1d
8000bf6e:	e4 19 3f ff 	andh	r9,0x3fff
8000bf72:	ab d6       	cbr	r6,0xb
8000bf74:	e0 80 00 e2 	breq	8000c138 <__avr32_f64_div_round_subnormal+0xa0>
8000bf78:	e0 46 07 ff 	cp.w	r6,2047
8000bf7c:	e0 84 00 b2 	brge	8000c0e0 <__avr32_f64_div_round_subnormal+0x48>
8000bf80:	0c 17       	sub	r7,r6
8000bf82:	fe 37 fc 01 	sub	r7,-1023
8000bf86:	fc 1c 80 00 	movh	r12,0x8000
8000bf8a:	f8 03 16 01 	lsr	r3,r12,0x1
8000bf8e:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000bf92:	5c d4       	com	r4
8000bf94:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000bf98:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bf9c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bfa0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bfa4:	ea 03 15 02 	lsl	r3,r5,0x2
8000bfa8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bfac:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bfb0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bfb4:	ea 03 15 02 	lsl	r3,r5,0x2
8000bfb8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bfbc:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bfc0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bfc4:	ea 03 15 02 	lsl	r3,r5,0x2
8000bfc8:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bfcc:	e4 09 07 40 	macu.d	r0,r2,r9
8000bfd0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bfd4:	02 04       	add	r4,r1
8000bfd6:	5c 05       	acr	r5
8000bfd8:	a3 65       	lsl	r5,0x2
8000bfda:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000bfde:	a3 64       	lsl	r4,0x2
8000bfe0:	5c 34       	neg	r4
8000bfe2:	f8 05 01 45 	sbc	r5,r12,r5
8000bfe6:	e6 04 06 40 	mulu.d	r0,r3,r4
8000bfea:	e4 05 07 40 	macu.d	r0,r2,r5
8000bfee:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bff2:	02 04       	add	r4,r1
8000bff4:	5c 05       	acr	r5
8000bff6:	ea 03 15 02 	lsl	r3,r5,0x2
8000bffa:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000bffe:	e8 02 15 02 	lsl	r2,r4,0x2
8000c002:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c006:	e4 09 07 40 	macu.d	r0,r2,r9
8000c00a:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c00e:	02 04       	add	r4,r1
8000c010:	5c 05       	acr	r5
8000c012:	a3 65       	lsl	r5,0x2
8000c014:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c018:	a3 64       	lsl	r4,0x2
8000c01a:	5c 34       	neg	r4
8000c01c:	f8 05 01 45 	sbc	r5,r12,r5
8000c020:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c024:	e4 05 07 40 	macu.d	r0,r2,r5
8000c028:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c02c:	02 04       	add	r4,r1
8000c02e:	5c 05       	acr	r5
8000c030:	ea 03 15 02 	lsl	r3,r5,0x2
8000c034:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c038:	e8 02 15 02 	lsl	r2,r4,0x2
8000c03c:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c040:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c044:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c048:	02 02       	add	r2,r1
8000c04a:	5c 03       	acr	r3
8000c04c:	ed b3 00 1c 	bld	r3,0x1c
8000c050:	c0 90       	breq	8000c062 <__avr32_f64_div+0x12a>
8000c052:	a1 72       	lsl	r2,0x1
8000c054:	5c f3       	rol	r3
8000c056:	20 17       	sub	r7,1
8000c058:	a3 9a       	lsr	r10,0x3
8000c05a:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c05e:	a3 9b       	lsr	r11,0x3
8000c060:	c0 58       	rjmp	8000c06a <__avr32_f64_div+0x132>
8000c062:	a5 8a       	lsr	r10,0x4
8000c064:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c068:	a5 8b       	lsr	r11,0x4
8000c06a:	58 07       	cp.w	r7,0
8000c06c:	e0 8a 00 8b 	brle	8000c182 <__avr32_f64_div_res_subnormal>
8000c070:	e0 12 ff 00 	andl	r2,0xff00
8000c074:	e8 12 00 80 	orl	r2,0x80
8000c078:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c07c:	e4 09 07 40 	macu.d	r0,r2,r9
8000c080:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c084:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c088:	00 05       	add	r5,r0
8000c08a:	f0 01 00 48 	adc	r8,r8,r1
8000c08e:	5c 09       	acr	r9
8000c090:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c094:	58 04       	cp.w	r4,0
8000c096:	5c 25       	cpc	r5

8000c098 <__avr32_f64_div_round_subnormal>:
8000c098:	f4 08 13 00 	cpc	r8,r10
8000c09c:	f6 09 13 00 	cpc	r9,r11
8000c0a0:	5f 36       	srlo	r6
8000c0a2:	f8 06 17 00 	moveq	r6,r12
8000c0a6:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c0aa:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c0ae:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c0b2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c0b6:	ed be 00 1f 	bld	lr,0x1f
8000c0ba:	ef bb 00 1f 	bst	r11,0x1f
8000c0be:	0c 0a       	add	r10,r6
8000c0c0:	5c 0b       	acr	r11
8000c0c2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c0c6:	e4 1b 00 0f 	andh	r11,0xf
8000c0ca:	14 4b       	or	r11,r10
8000c0cc:	e0 81 00 a7 	brne	8000c21a <__avr32_f64_div_res_subnormal+0x98>
8000c0d0:	f2 06 16 14 	lsr	r6,r9,0x14
8000c0d4:	ab d6       	cbr	r6,0xb
8000c0d6:	e0 46 07 ff 	cp.w	r6,2047
8000c0da:	e0 81 00 a4 	brne	8000c222 <__avr32_f64_div_res_subnormal+0xa0>
8000c0de:	c9 e8       	rjmp	8000c21a <__avr32_f64_div_res_subnormal+0x98>
8000c0e0:	e4 19 00 0f 	andh	r9,0xf
8000c0e4:	10 49       	or	r9,r8
8000c0e6:	e0 81 00 9a 	brne	8000c21a <__avr32_f64_div_res_subnormal+0x98>
8000c0ea:	c9 28       	rjmp	8000c20e <__avr32_f64_div_res_subnormal+0x8c>
8000c0ec:	a3 7b       	lsl	r11,0x3
8000c0ee:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c0f2:	a3 7a       	lsl	r10,0x3
8000c0f4:	f5 eb 10 04 	or	r4,r10,r11
8000c0f8:	e0 80 00 a0 	breq	8000c238 <__avr32_f64_div_op1_zero>
8000c0fc:	f6 04 12 00 	clz	r4,r11
8000c100:	c1 70       	breq	8000c12e <__avr32_f64_div_round_subnormal+0x96>
8000c102:	c0 c3       	brcs	8000c11a <__avr32_f64_div_round_subnormal+0x82>
8000c104:	e8 05 11 20 	rsub	r5,r4,32
8000c108:	f6 04 09 4b 	lsl	r11,r11,r4
8000c10c:	f4 05 0a 45 	lsr	r5,r10,r5
8000c110:	0a 4b       	or	r11,r5
8000c112:	f4 04 09 4a 	lsl	r10,r10,r4
8000c116:	08 17       	sub	r7,r4
8000c118:	c0 b8       	rjmp	8000c12e <__avr32_f64_div_round_subnormal+0x96>
8000c11a:	f4 04 12 00 	clz	r4,r10
8000c11e:	f9 b4 03 00 	movlo	r4,0
8000c122:	f7 b4 02 e0 	subhs	r4,-32
8000c126:	f4 04 09 4b 	lsl	r11,r10,r4
8000c12a:	30 0a       	mov	r10,0
8000c12c:	08 17       	sub	r7,r4
8000c12e:	a3 8a       	lsr	r10,0x2
8000c130:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c134:	a3 8b       	lsr	r11,0x2
8000c136:	c1 1b       	rjmp	8000bf58 <__avr32_f64_div+0x20>
8000c138:	a3 79       	lsl	r9,0x3
8000c13a:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c13e:	a3 78       	lsl	r8,0x3
8000c140:	f3 e8 10 04 	or	r4,r9,r8
8000c144:	c6 f0       	breq	8000c222 <__avr32_f64_div_res_subnormal+0xa0>
8000c146:	f2 04 12 00 	clz	r4,r9
8000c14a:	c1 70       	breq	8000c178 <__avr32_f64_div_round_subnormal+0xe0>
8000c14c:	c0 c3       	brcs	8000c164 <__avr32_f64_div_round_subnormal+0xcc>
8000c14e:	e8 05 11 20 	rsub	r5,r4,32
8000c152:	f2 04 09 49 	lsl	r9,r9,r4
8000c156:	f0 05 0a 45 	lsr	r5,r8,r5
8000c15a:	0a 49       	or	r9,r5
8000c15c:	f0 04 09 48 	lsl	r8,r8,r4
8000c160:	08 16       	sub	r6,r4
8000c162:	c0 b8       	rjmp	8000c178 <__avr32_f64_div_round_subnormal+0xe0>
8000c164:	f0 04 12 00 	clz	r4,r8
8000c168:	f9 b4 03 00 	movlo	r4,0
8000c16c:	f7 b4 02 e0 	subhs	r4,-32
8000c170:	f0 04 09 49 	lsl	r9,r8,r4
8000c174:	30 08       	mov	r8,0
8000c176:	08 16       	sub	r6,r4
8000c178:	a3 88       	lsr	r8,0x2
8000c17a:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c17e:	a3 89       	lsr	r9,0x2
8000c180:	cf ca       	rjmp	8000bf78 <__avr32_f64_div+0x40>

8000c182 <__avr32_f64_div_res_subnormal>:
8000c182:	5c 37       	neg	r7
8000c184:	2f f7       	sub	r7,-1
8000c186:	f1 b7 04 c0 	satu	r7,0x6
8000c18a:	e0 47 00 20 	cp.w	r7,32
8000c18e:	c1 54       	brge	8000c1b8 <__avr32_f64_div_res_subnormal+0x36>
8000c190:	ee 06 11 20 	rsub	r6,r7,32
8000c194:	e4 07 0a 42 	lsr	r2,r2,r7
8000c198:	e6 06 09 4c 	lsl	r12,r3,r6
8000c19c:	18 42       	or	r2,r12
8000c19e:	e6 07 0a 43 	lsr	r3,r3,r7
8000c1a2:	f4 06 09 41 	lsl	r1,r10,r6
8000c1a6:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c1aa:	f6 06 09 4c 	lsl	r12,r11,r6
8000c1ae:	18 4a       	or	r10,r12
8000c1b0:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c1b4:	30 00       	mov	r0,0
8000c1b6:	c1 58       	rjmp	8000c1e0 <__avr32_f64_div_res_subnormal+0x5e>
8000c1b8:	ee 06 11 20 	rsub	r6,r7,32
8000c1bc:	f9 b0 00 00 	moveq	r0,0
8000c1c0:	f9 bc 00 00 	moveq	r12,0
8000c1c4:	c0 50       	breq	8000c1ce <__avr32_f64_div_res_subnormal+0x4c>
8000c1c6:	f4 06 09 40 	lsl	r0,r10,r6
8000c1ca:	f6 06 09 4c 	lsl	r12,r11,r6
8000c1ce:	e6 07 0a 42 	lsr	r2,r3,r7
8000c1d2:	30 03       	mov	r3,0
8000c1d4:	f4 07 0a 41 	lsr	r1,r10,r7
8000c1d8:	18 41       	or	r1,r12
8000c1da:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c1de:	30 0b       	mov	r11,0
8000c1e0:	e0 12 ff 00 	andl	r2,0xff00
8000c1e4:	e8 12 00 80 	orl	r2,0x80
8000c1e8:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c1ec:	e4 09 07 46 	macu.d	r6,r2,r9
8000c1f0:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c1f4:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c1f8:	0c 05       	add	r5,r6
8000c1fa:	f0 07 00 48 	adc	r8,r8,r7
8000c1fe:	5c 09       	acr	r9
8000c200:	30 07       	mov	r7,0
8000c202:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c206:	00 34       	cp.w	r4,r0
8000c208:	e2 05 13 00 	cpc	r5,r1
8000c20c:	c4 6b       	rjmp	8000c098 <__avr32_f64_div_round_subnormal>
8000c20e:	1c 9b       	mov	r11,lr
8000c210:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c214:	30 0a       	mov	r10,0
8000c216:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c21a:	3f fb       	mov	r11,-1
8000c21c:	30 0a       	mov	r10,0
8000c21e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c222:	f5 eb 10 04 	or	r4,r10,r11
8000c226:	c0 90       	breq	8000c238 <__avr32_f64_div_op1_zero>
8000c228:	1c 9b       	mov	r11,lr
8000c22a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c22e:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c232:	30 0a       	mov	r10,0
8000c234:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c238 <__avr32_f64_div_op1_zero>:
8000c238:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c23c:	ce f0       	breq	8000c21a <__avr32_f64_div_res_subnormal+0x98>
8000c23e:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c242:	e0 44 07 ff 	cp.w	r4,2047
8000c246:	ce 41       	brne	8000c20e <__avr32_f64_div_res_subnormal+0x8c>
8000c248:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c24c:	ce 10       	breq	8000c20e <__avr32_f64_div_res_subnormal+0x8c>
8000c24e:	ce 6b       	rjmp	8000c21a <__avr32_f64_div_res_subnormal+0x98>

8000c250 <__avr32_udiv64>:
8000c250:	d4 31       	pushm	r0-r7,lr
8000c252:	1a 97       	mov	r7,sp
8000c254:	20 3d       	sub	sp,12
8000c256:	10 9c       	mov	r12,r8
8000c258:	12 9e       	mov	lr,r9
8000c25a:	14 93       	mov	r3,r10
8000c25c:	58 09       	cp.w	r9,0
8000c25e:	e0 81 00 bd 	brne	8000c3d8 <__avr32_udiv64+0x188>
8000c262:	16 38       	cp.w	r8,r11
8000c264:	e0 88 00 40 	brls	8000c2e4 <__avr32_udiv64+0x94>
8000c268:	f0 08 12 00 	clz	r8,r8
8000c26c:	c0 d0       	breq	8000c286 <__avr32_udiv64+0x36>
8000c26e:	f6 08 09 4b 	lsl	r11,r11,r8
8000c272:	f0 09 11 20 	rsub	r9,r8,32
8000c276:	f8 08 09 4c 	lsl	r12,r12,r8
8000c27a:	f4 09 0a 49 	lsr	r9,r10,r9
8000c27e:	f4 08 09 43 	lsl	r3,r10,r8
8000c282:	f3 eb 10 0b 	or	r11,r9,r11
8000c286:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c28a:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c28e:	f6 0e 0d 00 	divu	r0,r11,lr
8000c292:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c296:	00 99       	mov	r9,r0
8000c298:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c29c:	e0 0a 02 48 	mul	r8,r0,r10
8000c2a0:	10 3b       	cp.w	r11,r8
8000c2a2:	c0 a2       	brcc	8000c2b6 <__avr32_udiv64+0x66>
8000c2a4:	20 19       	sub	r9,1
8000c2a6:	18 0b       	add	r11,r12
8000c2a8:	18 3b       	cp.w	r11,r12
8000c2aa:	c0 63       	brcs	8000c2b6 <__avr32_udiv64+0x66>
8000c2ac:	10 3b       	cp.w	r11,r8
8000c2ae:	f7 b9 03 01 	sublo	r9,1
8000c2b2:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c2b6:	f6 08 01 01 	sub	r1,r11,r8
8000c2ba:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c2be:	e2 0e 0d 00 	divu	r0,r1,lr
8000c2c2:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c2c6:	00 98       	mov	r8,r0
8000c2c8:	e0 0a 02 4a 	mul	r10,r0,r10
8000c2cc:	14 33       	cp.w	r3,r10
8000c2ce:	c0 82       	brcc	8000c2de <__avr32_udiv64+0x8e>
8000c2d0:	20 18       	sub	r8,1
8000c2d2:	18 03       	add	r3,r12
8000c2d4:	18 33       	cp.w	r3,r12
8000c2d6:	c0 43       	brcs	8000c2de <__avr32_udiv64+0x8e>
8000c2d8:	14 33       	cp.w	r3,r10
8000c2da:	f7 b8 03 01 	sublo	r8,1
8000c2de:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c2e2:	cd f8       	rjmp	8000c4a0 <__avr32_udiv64+0x250>
8000c2e4:	58 08       	cp.w	r8,0
8000c2e6:	c0 51       	brne	8000c2f0 <__avr32_udiv64+0xa0>
8000c2e8:	30 19       	mov	r9,1
8000c2ea:	f2 08 0d 08 	divu	r8,r9,r8
8000c2ee:	10 9c       	mov	r12,r8
8000c2f0:	f8 06 12 00 	clz	r6,r12
8000c2f4:	c0 41       	brne	8000c2fc <__avr32_udiv64+0xac>
8000c2f6:	18 1b       	sub	r11,r12
8000c2f8:	30 19       	mov	r9,1
8000c2fa:	c4 08       	rjmp	8000c37a <__avr32_udiv64+0x12a>
8000c2fc:	ec 01 11 20 	rsub	r1,r6,32
8000c300:	f4 01 0a 49 	lsr	r9,r10,r1
8000c304:	f8 06 09 4c 	lsl	r12,r12,r6
8000c308:	f6 06 09 48 	lsl	r8,r11,r6
8000c30c:	f6 01 0a 41 	lsr	r1,r11,r1
8000c310:	f3 e8 10 08 	or	r8,r9,r8
8000c314:	f8 03 16 10 	lsr	r3,r12,0x10
8000c318:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c31c:	e2 03 0d 00 	divu	r0,r1,r3
8000c320:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c324:	00 9e       	mov	lr,r0
8000c326:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c32a:	e0 05 02 49 	mul	r9,r0,r5
8000c32e:	12 3b       	cp.w	r11,r9
8000c330:	c0 a2       	brcc	8000c344 <__avr32_udiv64+0xf4>
8000c332:	20 1e       	sub	lr,1
8000c334:	18 0b       	add	r11,r12
8000c336:	18 3b       	cp.w	r11,r12
8000c338:	c0 63       	brcs	8000c344 <__avr32_udiv64+0xf4>
8000c33a:	12 3b       	cp.w	r11,r9
8000c33c:	f7 be 03 01 	sublo	lr,1
8000c340:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c344:	12 1b       	sub	r11,r9
8000c346:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c34a:	f6 03 0d 02 	divu	r2,r11,r3
8000c34e:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c352:	04 99       	mov	r9,r2
8000c354:	e4 05 02 4b 	mul	r11,r2,r5
8000c358:	16 38       	cp.w	r8,r11
8000c35a:	c0 a2       	brcc	8000c36e <__avr32_udiv64+0x11e>
8000c35c:	20 19       	sub	r9,1
8000c35e:	18 08       	add	r8,r12
8000c360:	18 38       	cp.w	r8,r12
8000c362:	c0 63       	brcs	8000c36e <__avr32_udiv64+0x11e>
8000c364:	16 38       	cp.w	r8,r11
8000c366:	f7 b9 03 01 	sublo	r9,1
8000c36a:	f1 dc e3 08 	addcs	r8,r8,r12
8000c36e:	f4 06 09 43 	lsl	r3,r10,r6
8000c372:	f0 0b 01 0b 	sub	r11,r8,r11
8000c376:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c37a:	f8 06 16 10 	lsr	r6,r12,0x10
8000c37e:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c382:	f6 06 0d 00 	divu	r0,r11,r6
8000c386:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c38a:	00 9a       	mov	r10,r0
8000c38c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c390:	e0 0e 02 48 	mul	r8,r0,lr
8000c394:	10 3b       	cp.w	r11,r8
8000c396:	c0 a2       	brcc	8000c3aa <__avr32_udiv64+0x15a>
8000c398:	20 1a       	sub	r10,1
8000c39a:	18 0b       	add	r11,r12
8000c39c:	18 3b       	cp.w	r11,r12
8000c39e:	c0 63       	brcs	8000c3aa <__avr32_udiv64+0x15a>
8000c3a0:	10 3b       	cp.w	r11,r8
8000c3a2:	f7 ba 03 01 	sublo	r10,1
8000c3a6:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c3aa:	f6 08 01 01 	sub	r1,r11,r8
8000c3ae:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c3b2:	e2 06 0d 00 	divu	r0,r1,r6
8000c3b6:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c3ba:	00 98       	mov	r8,r0
8000c3bc:	e0 0e 02 4b 	mul	r11,r0,lr
8000c3c0:	16 33       	cp.w	r3,r11
8000c3c2:	c0 82       	brcc	8000c3d2 <__avr32_udiv64+0x182>
8000c3c4:	20 18       	sub	r8,1
8000c3c6:	18 03       	add	r3,r12
8000c3c8:	18 33       	cp.w	r3,r12
8000c3ca:	c0 43       	brcs	8000c3d2 <__avr32_udiv64+0x182>
8000c3cc:	16 33       	cp.w	r3,r11
8000c3ce:	f7 b8 03 01 	sublo	r8,1
8000c3d2:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c3d6:	c6 98       	rjmp	8000c4a8 <__avr32_udiv64+0x258>
8000c3d8:	16 39       	cp.w	r9,r11
8000c3da:	e0 8b 00 65 	brhi	8000c4a4 <__avr32_udiv64+0x254>
8000c3de:	f2 09 12 00 	clz	r9,r9
8000c3e2:	c0 b1       	brne	8000c3f8 <__avr32_udiv64+0x1a8>
8000c3e4:	10 3a       	cp.w	r10,r8
8000c3e6:	5f 2a       	srhs	r10
8000c3e8:	1c 3b       	cp.w	r11,lr
8000c3ea:	5f b8       	srhi	r8
8000c3ec:	10 4a       	or	r10,r8
8000c3ee:	f2 0a 18 00 	cp.b	r10,r9
8000c3f2:	c5 90       	breq	8000c4a4 <__avr32_udiv64+0x254>
8000c3f4:	30 18       	mov	r8,1
8000c3f6:	c5 98       	rjmp	8000c4a8 <__avr32_udiv64+0x258>
8000c3f8:	f0 09 09 46 	lsl	r6,r8,r9
8000c3fc:	f2 03 11 20 	rsub	r3,r9,32
8000c400:	fc 09 09 4e 	lsl	lr,lr,r9
8000c404:	f0 03 0a 48 	lsr	r8,r8,r3
8000c408:	f6 09 09 4c 	lsl	r12,r11,r9
8000c40c:	f4 03 0a 42 	lsr	r2,r10,r3
8000c410:	ef 46 ff f4 	st.w	r7[-12],r6
8000c414:	f6 03 0a 43 	lsr	r3,r11,r3
8000c418:	18 42       	or	r2,r12
8000c41a:	f1 ee 10 0c 	or	r12,r8,lr
8000c41e:	f8 01 16 10 	lsr	r1,r12,0x10
8000c422:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c426:	e6 01 0d 04 	divu	r4,r3,r1
8000c42a:	e4 03 16 10 	lsr	r3,r2,0x10
8000c42e:	08 9e       	mov	lr,r4
8000c430:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c434:	e8 06 02 48 	mul	r8,r4,r6
8000c438:	10 33       	cp.w	r3,r8
8000c43a:	c0 a2       	brcc	8000c44e <__avr32_udiv64+0x1fe>
8000c43c:	20 1e       	sub	lr,1
8000c43e:	18 03       	add	r3,r12
8000c440:	18 33       	cp.w	r3,r12
8000c442:	c0 63       	brcs	8000c44e <__avr32_udiv64+0x1fe>
8000c444:	10 33       	cp.w	r3,r8
8000c446:	f7 be 03 01 	sublo	lr,1
8000c44a:	e7 dc e3 03 	addcs	r3,r3,r12
8000c44e:	10 13       	sub	r3,r8
8000c450:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c454:	e6 01 0d 00 	divu	r0,r3,r1
8000c458:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c45c:	00 98       	mov	r8,r0
8000c45e:	e0 06 02 46 	mul	r6,r0,r6
8000c462:	0c 3b       	cp.w	r11,r6
8000c464:	c0 a2       	brcc	8000c478 <__avr32_udiv64+0x228>
8000c466:	20 18       	sub	r8,1
8000c468:	18 0b       	add	r11,r12
8000c46a:	18 3b       	cp.w	r11,r12
8000c46c:	c0 63       	brcs	8000c478 <__avr32_udiv64+0x228>
8000c46e:	0c 3b       	cp.w	r11,r6
8000c470:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c474:	f7 b8 03 01 	sublo	r8,1
8000c478:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c47c:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c480:	0c 1b       	sub	r11,r6
8000c482:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c486:	06 95       	mov	r5,r3
8000c488:	16 35       	cp.w	r5,r11
8000c48a:	e0 8b 00 0a 	brhi	8000c49e <__avr32_udiv64+0x24e>
8000c48e:	5f 0b       	sreq	r11
8000c490:	f4 09 09 49 	lsl	r9,r10,r9
8000c494:	12 32       	cp.w	r2,r9
8000c496:	5f b9       	srhi	r9
8000c498:	f7 e9 00 09 	and	r9,r11,r9
8000c49c:	c0 60       	breq	8000c4a8 <__avr32_udiv64+0x258>
8000c49e:	20 18       	sub	r8,1
8000c4a0:	30 09       	mov	r9,0
8000c4a2:	c0 38       	rjmp	8000c4a8 <__avr32_udiv64+0x258>
8000c4a4:	30 09       	mov	r9,0
8000c4a6:	12 98       	mov	r8,r9
8000c4a8:	10 9a       	mov	r10,r8
8000c4aa:	12 93       	mov	r3,r9
8000c4ac:	10 92       	mov	r2,r8
8000c4ae:	12 9b       	mov	r11,r9
8000c4b0:	2f dd       	sub	sp,-12
8000c4b2:	d8 32       	popm	r0-r7,pc

8000c4b4 <__avr32_umod64>:
8000c4b4:	d4 31       	pushm	r0-r7,lr
8000c4b6:	1a 97       	mov	r7,sp
8000c4b8:	20 3d       	sub	sp,12
8000c4ba:	10 9c       	mov	r12,r8
8000c4bc:	12 95       	mov	r5,r9
8000c4be:	14 9e       	mov	lr,r10
8000c4c0:	16 91       	mov	r1,r11
8000c4c2:	16 96       	mov	r6,r11
8000c4c4:	58 09       	cp.w	r9,0
8000c4c6:	e0 81 00 81 	brne	8000c5c8 <__avr32_umod64+0x114>
8000c4ca:	16 38       	cp.w	r8,r11
8000c4cc:	e0 88 00 12 	brls	8000c4f0 <__avr32_umod64+0x3c>
8000c4d0:	f0 08 12 00 	clz	r8,r8
8000c4d4:	c4 e0       	breq	8000c570 <__avr32_umod64+0xbc>
8000c4d6:	f6 08 09 46 	lsl	r6,r11,r8
8000c4da:	f8 08 09 4c 	lsl	r12,r12,r8
8000c4de:	f0 0b 11 20 	rsub	r11,r8,32
8000c4e2:	f4 08 09 4e 	lsl	lr,r10,r8
8000c4e6:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c4ea:	f7 e6 10 06 	or	r6,r11,r6
8000c4ee:	c4 18       	rjmp	8000c570 <__avr32_umod64+0xbc>
8000c4f0:	58 08       	cp.w	r8,0
8000c4f2:	c0 51       	brne	8000c4fc <__avr32_umod64+0x48>
8000c4f4:	30 19       	mov	r9,1
8000c4f6:	f2 08 0d 08 	divu	r8,r9,r8
8000c4fa:	10 9c       	mov	r12,r8
8000c4fc:	f8 08 12 00 	clz	r8,r12
8000c500:	c0 31       	brne	8000c506 <__avr32_umod64+0x52>
8000c502:	18 16       	sub	r6,r12
8000c504:	c3 68       	rjmp	8000c570 <__avr32_umod64+0xbc>
8000c506:	f0 03 11 20 	rsub	r3,r8,32
8000c50a:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c50e:	f8 08 09 4c 	lsl	r12,r12,r8
8000c512:	ec 08 09 49 	lsl	r9,r6,r8
8000c516:	ec 03 0a 43 	lsr	r3,r6,r3
8000c51a:	f7 e9 10 09 	or	r9,r11,r9
8000c51e:	f8 05 16 10 	lsr	r5,r12,0x10
8000c522:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c526:	e6 05 0d 02 	divu	r2,r3,r5
8000c52a:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c52e:	ec 02 02 4b 	mul	r11,r6,r2
8000c532:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c536:	16 3e       	cp.w	lr,r11
8000c538:	c0 72       	brcc	8000c546 <__avr32_umod64+0x92>
8000c53a:	18 0e       	add	lr,r12
8000c53c:	18 3e       	cp.w	lr,r12
8000c53e:	c0 43       	brcs	8000c546 <__avr32_umod64+0x92>
8000c540:	16 3e       	cp.w	lr,r11
8000c542:	fd dc e3 0e 	addcs	lr,lr,r12
8000c546:	fc 0b 01 03 	sub	r3,lr,r11
8000c54a:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c54e:	e6 05 0d 02 	divu	r2,r3,r5
8000c552:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c556:	a5 36       	mul	r6,r2
8000c558:	0c 39       	cp.w	r9,r6
8000c55a:	c0 72       	brcc	8000c568 <__avr32_umod64+0xb4>
8000c55c:	18 09       	add	r9,r12
8000c55e:	18 39       	cp.w	r9,r12
8000c560:	c0 43       	brcs	8000c568 <__avr32_umod64+0xb4>
8000c562:	0c 39       	cp.w	r9,r6
8000c564:	f3 dc e3 09 	addcs	r9,r9,r12
8000c568:	f2 06 01 06 	sub	r6,r9,r6
8000c56c:	f4 08 09 4e 	lsl	lr,r10,r8
8000c570:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c574:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c578:	ec 0a 0d 02 	divu	r2,r6,r10
8000c57c:	fc 09 16 10 	lsr	r9,lr,0x10
8000c580:	ea 02 02 4b 	mul	r11,r5,r2
8000c584:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c588:	16 39       	cp.w	r9,r11
8000c58a:	c0 72       	brcc	8000c598 <__avr32_umod64+0xe4>
8000c58c:	18 09       	add	r9,r12
8000c58e:	18 39       	cp.w	r9,r12
8000c590:	c0 43       	brcs	8000c598 <__avr32_umod64+0xe4>
8000c592:	16 39       	cp.w	r9,r11
8000c594:	f3 dc e3 09 	addcs	r9,r9,r12
8000c598:	f2 0b 01 0b 	sub	r11,r9,r11
8000c59c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c5a0:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c5a4:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c5a8:	ea 0a 02 4a 	mul	r10,r5,r10
8000c5ac:	14 3e       	cp.w	lr,r10
8000c5ae:	c0 72       	brcc	8000c5bc <__avr32_umod64+0x108>
8000c5b0:	18 0e       	add	lr,r12
8000c5b2:	18 3e       	cp.w	lr,r12
8000c5b4:	c0 43       	brcs	8000c5bc <__avr32_umod64+0x108>
8000c5b6:	14 3e       	cp.w	lr,r10
8000c5b8:	fd dc e3 0e 	addcs	lr,lr,r12
8000c5bc:	fc 0a 01 0a 	sub	r10,lr,r10
8000c5c0:	30 0b       	mov	r11,0
8000c5c2:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c5c6:	c7 b8       	rjmp	8000c6bc <__avr32_umod64+0x208>
8000c5c8:	16 39       	cp.w	r9,r11
8000c5ca:	e0 8b 00 79 	brhi	8000c6bc <__avr32_umod64+0x208>
8000c5ce:	f2 09 12 00 	clz	r9,r9
8000c5d2:	c1 21       	brne	8000c5f6 <__avr32_umod64+0x142>
8000c5d4:	10 3a       	cp.w	r10,r8
8000c5d6:	5f 2b       	srhs	r11
8000c5d8:	0a 31       	cp.w	r1,r5
8000c5da:	5f ba       	srhi	r10
8000c5dc:	f7 ea 10 0a 	or	r10,r11,r10
8000c5e0:	f2 0a 18 00 	cp.b	r10,r9
8000c5e4:	c0 60       	breq	8000c5f0 <__avr32_umod64+0x13c>
8000c5e6:	fc 08 01 0c 	sub	r12,lr,r8
8000c5ea:	e2 05 01 46 	sbc	r6,r1,r5
8000c5ee:	18 9e       	mov	lr,r12
8000c5f0:	0c 9b       	mov	r11,r6
8000c5f2:	1c 9a       	mov	r10,lr
8000c5f4:	c6 48       	rjmp	8000c6bc <__avr32_umod64+0x208>
8000c5f6:	ea 09 09 4c 	lsl	r12,r5,r9
8000c5fa:	f2 06 11 20 	rsub	r6,r9,32
8000c5fe:	f6 09 09 4b 	lsl	r11,r11,r9
8000c602:	f0 09 09 42 	lsl	r2,r8,r9
8000c606:	ef 46 ff f4 	st.w	r7[-12],r6
8000c60a:	f0 06 0a 48 	lsr	r8,r8,r6
8000c60e:	18 48       	or	r8,r12
8000c610:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c614:	f4 09 09 43 	lsl	r3,r10,r9
8000c618:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c61c:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c620:	16 4a       	or	r10,r11
8000c622:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c626:	f8 0b 0d 04 	divu	r4,r12,r11
8000c62a:	f4 0c 16 10 	lsr	r12,r10,0x10
8000c62e:	08 91       	mov	r1,r4
8000c630:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000c634:	e8 0e 02 46 	mul	r6,r4,lr
8000c638:	0c 3c       	cp.w	r12,r6
8000c63a:	c0 a2       	brcc	8000c64e <__avr32_umod64+0x19a>
8000c63c:	20 11       	sub	r1,1
8000c63e:	10 0c       	add	r12,r8
8000c640:	10 3c       	cp.w	r12,r8
8000c642:	c0 63       	brcs	8000c64e <__avr32_umod64+0x19a>
8000c644:	0c 3c       	cp.w	r12,r6
8000c646:	f7 b1 03 01 	sublo	r1,1
8000c64a:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c64e:	0c 1c       	sub	r12,r6
8000c650:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c654:	f8 0b 0d 04 	divu	r4,r12,r11
8000c658:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c65c:	08 96       	mov	r6,r4
8000c65e:	e8 0e 02 4e 	mul	lr,r4,lr
8000c662:	1c 3b       	cp.w	r11,lr
8000c664:	c0 a2       	brcc	8000c678 <__avr32_umod64+0x1c4>
8000c666:	20 16       	sub	r6,1
8000c668:	10 0b       	add	r11,r8
8000c66a:	10 3b       	cp.w	r11,r8
8000c66c:	c0 63       	brcs	8000c678 <__avr32_umod64+0x1c4>
8000c66e:	1c 3b       	cp.w	r11,lr
8000c670:	f7 b6 03 01 	sublo	r6,1
8000c674:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c678:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c67c:	1c 1b       	sub	r11,lr
8000c67e:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c682:	00 9e       	mov	lr,r0
8000c684:	02 9c       	mov	r12,r1
8000c686:	16 3c       	cp.w	r12,r11
8000c688:	e0 8b 00 08 	brhi	8000c698 <__avr32_umod64+0x1e4>
8000c68c:	5f 06       	sreq	r6
8000c68e:	06 30       	cp.w	r0,r3
8000c690:	5f ba       	srhi	r10
8000c692:	ed ea 00 0a 	and	r10,r6,r10
8000c696:	c0 60       	breq	8000c6a2 <__avr32_umod64+0x1ee>
8000c698:	fc 02 01 04 	sub	r4,lr,r2
8000c69c:	f8 08 01 4c 	sbc	r12,r12,r8
8000c6a0:	08 9e       	mov	lr,r4
8000c6a2:	e6 0e 01 0a 	sub	r10,r3,lr
8000c6a6:	f6 0c 01 4c 	sbc	r12,r11,r12
8000c6aa:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000c6ae:	f8 09 0a 4b 	lsr	r11,r12,r9
8000c6b2:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c6b6:	f8 01 09 4c 	lsl	r12,r12,r1
8000c6ba:	18 4a       	or	r10,r12
8000c6bc:	2f dd       	sub	sp,-12
8000c6be:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000c800 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000c800:	c0 08       	rjmp	8000c800 <_evba>
	...

8000c804 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000c804:	c0 08       	rjmp	8000c804 <_handle_TLB_Multiple_Hit>
	...

8000c808 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000c808:	c0 08       	rjmp	8000c808 <_handle_Bus_Error_Data_Fetch>
	...

8000c80c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000c80c:	c0 08       	rjmp	8000c80c <_handle_Bus_Error_Instruction_Fetch>
	...

8000c810 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000c810:	c0 08       	rjmp	8000c810 <_handle_NMI>
	...

8000c814 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000c814:	c0 08       	rjmp	8000c814 <_handle_Instruction_Address>
	...

8000c818 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000c818:	c0 08       	rjmp	8000c818 <_handle_ITLB_Protection>
	...

8000c81c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000c81c:	c0 08       	rjmp	8000c81c <_handle_Breakpoint>
	...

8000c820 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000c820:	c0 08       	rjmp	8000c820 <_handle_Illegal_Opcode>
	...

8000c824 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000c824:	c0 08       	rjmp	8000c824 <_handle_Unimplemented_Instruction>
	...

8000c828 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000c828:	c0 08       	rjmp	8000c828 <_handle_Privilege_Violation>
	...

8000c82c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000c82c:	c0 08       	rjmp	8000c82c <_handle_Floating_Point>
	...

8000c830 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000c830:	c0 08       	rjmp	8000c830 <_handle_Coprocessor_Absent>
	...

8000c834 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000c834:	c0 08       	rjmp	8000c834 <_handle_Data_Address_Read>
	...

8000c838 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000c838:	c0 08       	rjmp	8000c838 <_handle_Data_Address_Write>
	...

8000c83c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000c83c:	c0 08       	rjmp	8000c83c <_handle_DTLB_Protection_Read>
	...

8000c840 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000c840:	c0 08       	rjmp	8000c840 <_handle_DTLB_Protection_Write>
	...

8000c844 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000c844:	c0 08       	rjmp	8000c844 <_handle_DTLB_Modified>
	...

8000c850 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000c850:	c0 08       	rjmp	8000c850 <_handle_ITLB_Miss>
	...

8000c860 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000c860:	c0 08       	rjmp	8000c860 <_handle_DTLB_Miss_Read>
	...

8000c870 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000c870:	c0 08       	rjmp	8000c870 <_handle_DTLB_Miss_Write>
	...

8000c900 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000c900:	fe cf 70 50 	sub	pc,pc,28752

8000c904 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000c904:	30 0c       	mov	r12,0
8000c906:	fe b0 c4 9b 	rcall	8000523c <_get_interrupt_handler>
8000c90a:	58 0c       	cp.w	r12,0
8000c90c:	f8 0f 17 10 	movne	pc,r12
8000c910:	d6 03       	rete

8000c912 <_int1>:
8000c912:	30 1c       	mov	r12,1
8000c914:	fe b0 c4 94 	rcall	8000523c <_get_interrupt_handler>
8000c918:	58 0c       	cp.w	r12,0
8000c91a:	f8 0f 17 10 	movne	pc,r12
8000c91e:	d6 03       	rete

8000c920 <_int2>:
8000c920:	30 2c       	mov	r12,2
8000c922:	fe b0 c4 8d 	rcall	8000523c <_get_interrupt_handler>
8000c926:	58 0c       	cp.w	r12,0
8000c928:	f8 0f 17 10 	movne	pc,r12
8000c92c:	d6 03       	rete

8000c92e <_int3>:
8000c92e:	30 3c       	mov	r12,3
8000c930:	fe b0 c4 86 	rcall	8000523c <_get_interrupt_handler>
8000c934:	58 0c       	cp.w	r12,0
8000c936:	f8 0f 17 10 	movne	pc,r12
8000c93a:	d6 03       	rete

8000c93c <ipr_val>:
8000c93c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000c94c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c95c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c96c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c97c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c98c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c99c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9fc:	d7 03 d7 03                                         ....
