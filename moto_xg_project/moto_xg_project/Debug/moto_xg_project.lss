
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00000024  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80000024  80000024  00000424  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000aef8  80000024  80000024  00000424  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000b000  8000b000  0000b400  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000011b0  8000b200  8000b200  0000b600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a40  00000004  8000c3b0  0000c804  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .balign       00000004  00000a44  8000cdf0  0000d244  2**0
                  ALLOC
  7 .bss          00004708  00000a48  8000cdf0  0000d248  2**2
                  ALLOC
  8 .comment      00000030  00000000  00000000  0000d244  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 000016e8  00000000  00000000  0000d278  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 000035b4  00000000  00000000  0000e960  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0002e038  00000000  00000000  00011f14  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 000075c5  00000000  00000000  0003ff4c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000d6e2  00000000  00000000  00047511  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00003d94  00000000  00000000  00054bf4  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00007fce  00000000  00000000  00058988  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000f66c  00000000  00000000  00060956  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 18 .debug_ranges 000017a0  00000000  00000000  0006ffc8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	c1 08       	rjmp	80000020 <program_start>
    rjmp    program_start
80000002:	c0 f8       	rjmp	80000020 <program_start>
	  rjmp    program_start
80000004:	c0 e8       	rjmp	80000020 <program_start>
	    rjmp    program_start
80000006:	c0 d8       	rjmp	80000020 <program_start>
	...

80000020 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000020:	fe cf c1 1c 	sub	pc,pc,-16100

Disassembly of section .text:

80000024 <DeviceManagement_brdcst_func>:
80000024:	19 a9       	ld.ub	r9,r12[0x2]
80000026:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80000028:	f0 09 18 00 	cp.b	r9,r8
8000002c:	c0 61       	brne	80000038 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000002e:	48 68       	lddpc	r8,80000044 <DeviceManagement_brdcst_func+0x20>
80000030:	70 09       	ld.w	r9,r8[0x0]
80000032:	a1 b9       	sbr	r9,0x1
80000034:	91 09       	st.w	r8[0x0],r9
80000036:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80000038:	48 38       	lddpc	r8,80000044 <DeviceManagement_brdcst_func+0x20>
8000003a:	70 09       	ld.w	r9,r8[0x0]
8000003c:	a1 d9       	cbr	r9,0x1
8000003e:	91 09       	st.w	r8[0x0],r9
80000040:	5e fc       	retal	r12
80000042:	00 00       	add	r0,r0
80000044:	00 00       	add	r0,r0
80000046:	0d a0       	ld.ub	r0,r6[0x2]

80000048 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80000048:	5e fc       	retal	r12

8000004a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000004a:	5e fc       	retal	r12

8000004c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000004c:	48 38       	lddpc	r8,80000058 <vApplicationIdleHook+0xc>
8000004e:	70 09       	ld.w	r9,r8[0x0]
80000050:	2f f9       	sub	r9,-1
80000052:	91 09       	st.w	r8[0x0],r9
	
}
80000054:	5e fc       	retal	r12
80000056:	00 00       	add	r0,r0
80000058:	00 00       	add	r0,r0
8000005a:	0a 60       	and	r0,r5

8000005c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000005c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000005e:	48 cc       	lddpc	r12,8000008c <app_init+0x30>
80000060:	f0 1f 00 0c 	mcall	80000090 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80000064:	48 cb       	lddpc	r11,80000094 <app_init+0x38>
80000066:	48 dc       	lddpc	r12,80000098 <app_init+0x3c>
80000068:	f0 1f 00 0d 	mcall	8000009c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000006c:	30 09       	mov	r9,0
8000006e:	1a d9       	st.w	--sp,r9
80000070:	1a d9       	st.w	--sp,r9
80000072:	1a d9       	st.w	--sp,r9
80000074:	30 18       	mov	r8,1
80000076:	e0 6a 01 80 	mov	r10,384
8000007a:	48 ab       	lddpc	r11,800000a0 <app_init+0x44>
8000007c:	48 ac       	lddpc	r12,800000a4 <app_init+0x48>
8000007e:	f0 1f 00 0b 	mcall	800000a8 <app_init+0x4c>
80000082:	48 b8       	lddpc	r8,800000ac <app_init+0x50>
80000084:	91 0c       	st.w	r8[0x0],r12
80000086:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  1
	,  NULL );
	
}
80000088:	d8 02       	popm	pc
8000008a:	00 00       	add	r0,r0
8000008c:	00 00       	add	r0,r0
8000008e:	00 04       	add	r4,r0
80000090:	80 00       	ld.sh	r0,r0[0x0]
80000092:	1e b4       	st.h	pc++,r4
80000094:	80 00       	ld.sh	r0,r0[0x0]
80000096:	00 b0       	st.h	r0++,r0
80000098:	80 00       	ld.sh	r0,r0[0x0]
8000009a:	00 c4       	st.b	r0++,r4
8000009c:	80 00       	ld.sh	r0,r0[0x0]
8000009e:	0a b4       	st.h	r5++,r4
800000a0:	80 00       	ld.sh	r0,r0[0x0]
800000a2:	b2 00       	st.h	r9[0x0],r0
800000a4:	80 00       	ld.sh	r0,r0[0x0]
800000a6:	07 f8       	ld.ub	r8,r3[0x7]
800000a8:	80 00       	ld.sh	r0,r0[0x0]
800000aa:	4e 44       	lddpc	r4,80000238 <ButtonConfig_brdcst_func+0x64>
800000ac:	00 00       	add	r0,r0
800000ae:	0a 54       	eor	r4,r5

800000b0 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
800000b0:	d4 01       	pushm	lr
  log("R");
800000b2:	48 3c       	lddpc	r12,800000bc <app_payload_tx_proc+0xc>
800000b4:	f0 1f 00 03 	mcall	800000c0 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
800000b8:	d8 02       	popm	pc
800000ba:	00 00       	add	r0,r0
800000bc:	80 00       	ld.sh	r0,r0[0x0]
800000be:	b2 08       	st.h	r9[0x0],r8
800000c0:	80 00       	ld.sh	r0,r0[0x0]
800000c2:	52 08       	stdsp	sp[0x80],r8

800000c4 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
800000c4:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
800000c6:	48 99       	lddpc	r9,800000e8 <app_payload_rx_proc+0x24>
800000c8:	13 88       	ld.ub	r8,r9[0x0]
800000ca:	2f f8       	sub	r8,-1
800000cc:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
800000ce:	30 39       	mov	r9,3
800000d0:	f2 08 18 00 	cp.b	r8,r9
800000d4:	c0 71       	brne	800000e2 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
800000d6:	30 09       	mov	r9,0
800000d8:	48 48       	lddpc	r8,800000e8 <app_payload_rx_proc+0x24>
800000da:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800000dc:	48 4c       	lddpc	r12,800000ec <app_payload_rx_proc+0x28>
800000de:	f0 1f 00 05 	mcall	800000f0 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
800000e2:	48 58       	lddpc	r8,800000f4 <app_payload_rx_proc+0x30>
800000e4:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
800000e6:	d8 02       	popm	pc
800000e8:	00 00       	add	r0,r0
800000ea:	0a 5e       	eor	lr,r5
800000ec:	80 00       	ld.sh	r0,r0[0x0]
800000ee:	b2 0c       	st.h	r9[0x0],r12
800000f0:	80 00       	ld.sh	r0,r0[0x0]
800000f2:	52 08       	stdsp	sp[0x80],r8
800000f4:	00 00       	add	r0,r0
800000f6:	0a 58       	eor	r8,r5

800000f8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800000f8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800000fa:	48 3c       	lddpc	r12,80000104 <FD_brdcst_func+0xc>
800000fc:	f0 1f 00 03 	mcall	80000108 <FD_brdcst_func+0x10>
	
}
80000100:	d8 02       	popm	pc
80000102:	00 00       	add	r0,r0
80000104:	80 00       	ld.sh	r0,r0[0x0]
80000106:	b2 18       	st.h	r9[0x2],r8
80000108:	80 00       	ld.sh	r0,r0[0x0]
8000010a:	52 08       	stdsp	sp[0x80],r8

8000010c <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
8000010c:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
8000010e:	48 3c       	lddpc	r12,80000118 <FD_reply_func+0xc>
80000110:	f0 1f 00 03 	mcall	8000011c <FD_reply_func+0x10>
	
	
}
80000114:	d8 02       	popm	pc
80000116:	00 00       	add	r0,r0
80000118:	80 00       	ld.sh	r0,r0[0x0]
8000011a:	b2 38       	st.h	r9[0x6],r8
8000011c:	80 00       	ld.sh	r0,r0[0x0]
8000011e:	52 08       	stdsp	sp[0x80],r8

80000120 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80000120:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80000122:	48 3c       	lddpc	r12,8000012c <FD_request_func+0xc>
80000124:	f0 1f 00 03 	mcall	80000130 <FD_request_func+0x10>
	
	
}
80000128:	d8 02       	popm	pc
8000012a:	00 00       	add	r0,r0
8000012c:	80 00       	ld.sh	r0,r0[0x0]
8000012e:	b2 54       	st.h	r9[0xa],r4
80000130:	80 00       	ld.sh	r0,r0[0x0]
80000132:	52 08       	stdsp	sp[0x80],r8

80000134 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80000134:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80000136:	48 3c       	lddpc	r12,80000140 <EnOB_brdcst_func+0xc>
80000138:	f0 1f 00 03 	mcall	80000144 <EnOB_brdcst_func+0x10>
}
8000013c:	d8 02       	popm	pc
8000013e:	00 00       	add	r0,r0
80000140:	80 00       	ld.sh	r0,r0[0x0]
80000142:	b2 70       	st.h	r9[0xe],r0
80000144:	80 00       	ld.sh	r0,r0[0x0]
80000146:	52 08       	stdsp	sp[0x80],r8

80000148 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80000148:	eb cd 40 80 	pushm	r7,lr
8000014c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000014e:	19 a9       	ld.ub	r9,r12[0x2]
80000150:	30 08       	mov	r8,0
80000152:	f0 09 18 00 	cp.b	r9,r8
80000156:	c1 91       	brne	80000188 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80000158:	19 b8       	ld.ub	r8,r12[0x3]
8000015a:	30 19       	mov	r9,1
8000015c:	f2 08 18 00 	cp.b	r8,r9
80000160:	c0 61       	brne	8000016c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80000162:	49 0c       	lddpc	r12,800001a0 <EnOB_reply_func+0x58>
80000164:	f0 1f 00 10 	mcall	800001a4 <EnOB_reply_func+0x5c>
80000168:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000016c:	58 08       	cp.w	r8,0
8000016e:	c0 61       	brne	8000017a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80000170:	48 ec       	lddpc	r12,800001a8 <EnOB_reply_func+0x60>
80000172:	f0 1f 00 0d 	mcall	800001a4 <EnOB_reply_func+0x5c>
80000176:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000017a:	1a d8       	st.w	--sp,r8
8000017c:	48 cc       	lddpc	r12,800001ac <EnOB_reply_func+0x64>
8000017e:	f0 1f 00 0a 	mcall	800001a4 <EnOB_reply_func+0x5c>
80000182:	2f fd       	sub	sp,-4
80000184:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80000188:	48 ac       	lddpc	r12,800001b0 <EnOB_reply_func+0x68>
8000018a:	f0 1f 00 07 	mcall	800001a4 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000018e:	0f a8       	ld.ub	r8,r7[0x2]
80000190:	1a d8       	st.w	--sp,r8
80000192:	48 9c       	lddpc	r12,800001b4 <EnOB_reply_func+0x6c>
80000194:	f0 1f 00 04 	mcall	800001a4 <EnOB_reply_func+0x5c>
80000198:	2f fd       	sub	sp,-4
8000019a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000019e:	00 00       	add	r0,r0
800001a0:	80 00       	ld.sh	r0,r0[0x0]
800001a2:	b2 88       	st.b	r9[0x0],r8
800001a4:	80 00       	ld.sh	r0,r0[0x0]
800001a6:	52 08       	stdsp	sp[0x80],r8
800001a8:	80 00       	ld.sh	r0,r0[0x0]
800001aa:	b2 a0       	st.b	r9[0x2],r0
800001ac:	80 00       	ld.sh	r0,r0[0x0]
800001ae:	b2 b4       	st.b	r9[0x3],r4
800001b0:	80 00       	ld.sh	r0,r0[0x0]
800001b2:	b2 cc       	st.b	r9[0x4],r12
800001b4:	80 00       	ld.sh	r0,r0[0x0]
800001b6:	b2 e8       	st.b	r9[0x6],r8

800001b8 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
800001b8:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
800001ba:	19 a9       	ld.ub	r9,r12[0x2]
800001bc:	31 18       	mov	r8,17
800001be:	f0 09 18 00 	cp.b	r9,r8
800001c2:	c0 41       	brne	800001ca <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
800001c4:	48 2c       	lddpc	r12,800001cc <SingleDetection_brdcst_func+0x14>
800001c6:	f0 1f 00 03 	mcall	800001d0 <SingleDetection_brdcst_func+0x18>
800001ca:	d8 02       	popm	pc
800001cc:	80 00       	ld.sh	r0,r0[0x0]
800001ce:	b3 00       	ld.d	r0,r9
800001d0:	80 00       	ld.sh	r0,r0[0x0]
800001d2:	52 08       	stdsp	sp[0x80],r8

800001d4 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800001d4:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800001d6:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800001da:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800001dc:	4a bc       	lddpc	r12,80000288 <ButtonConfig_brdcst_func+0xb4>
800001de:	f0 1f 00 2c 	mcall	8000028c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800001e2:	0f 88       	ld.ub	r8,r7[0x0]
800001e4:	1a d8       	st.w	--sp,r8
800001e6:	4a bc       	lddpc	r12,80000290 <ButtonConfig_brdcst_func+0xbc>
800001e8:	f0 1f 00 29 	mcall	8000028c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800001ec:	1a d5       	st.w	--sp,r5
800001ee:	4a ac       	lddpc	r12,80000294 <ButtonConfig_brdcst_func+0xc0>
800001f0:	f0 1f 00 27 	mcall	8000028c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800001f4:	0f a8       	ld.ub	r8,r7[0x2]
800001f6:	1a d8       	st.w	--sp,r8
800001f8:	4a 8c       	lddpc	r12,80000298 <ButtonConfig_brdcst_func+0xc4>
800001fa:	f0 1f 00 25 	mcall	8000028c <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800001fe:	2f dd       	sub	sp,-12
80000200:	58 05       	cp.w	r5,0
80000202:	c4 10       	breq	80000284 <ButtonConfig_brdcst_func+0xb0>
80000204:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80000206:	4a 64       	lddpc	r4,8000029c <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80000208:	4a 63       	lddpc	r3,800002a0 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000020a:	4a 72       	lddpc	r2,800002a4 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000020c:	4a 71       	lddpc	r1,800002a8 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000020e:	4a 80       	lddpc	r0,800002ac <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80000210:	0f b9       	ld.ub	r9,r7[0x3]
80000212:	0f c8       	ld.ub	r8,r7[0x4]
80000214:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80000218:	1a d8       	st.w	--sp,r8
8000021a:	1a d6       	st.w	--sp,r6
8000021c:	08 9c       	mov	r12,r4
8000021e:	f0 1f 00 1c 	mcall	8000028c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80000222:	0f d9       	ld.ub	r9,r7[0x5]
80000224:	0f e8       	ld.ub	r8,r7[0x6]
80000226:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000022a:	1a d8       	st.w	--sp,r8
8000022c:	1a d6       	st.w	--sp,r6
8000022e:	06 9c       	mov	r12,r3
80000230:	f0 1f 00 17 	mcall	8000028c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80000234:	0f f9       	ld.ub	r9,r7[0x7]
80000236:	ef 38 00 08 	ld.ub	r8,r7[8]
8000023a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000023e:	1a d8       	st.w	--sp,r8
80000240:	1a d6       	st.w	--sp,r6
80000242:	04 9c       	mov	r12,r2
80000244:	f0 1f 00 12 	mcall	8000028c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80000248:	ef 39 00 09 	ld.ub	r9,r7[9]
8000024c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80000250:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80000254:	1a d8       	st.w	--sp,r8
80000256:	1a d6       	st.w	--sp,r6
80000258:	02 9c       	mov	r12,r1
8000025a:	f0 1f 00 0d 	mcall	8000028c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000025e:	2f 8d       	sub	sp,-32
80000260:	ef 39 00 0b 	ld.ub	r9,r7[11]
80000264:	ef 38 00 0c 	ld.ub	r8,r7[12]
80000268:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000026c:	1a d8       	st.w	--sp,r8
8000026e:	1a d6       	st.w	--sp,r6
80000270:	00 9c       	mov	r12,r0
80000272:	f0 1f 00 07 	mcall	8000028c <ButtonConfig_brdcst_func+0xb8>
80000276:	2f f6       	sub	r6,-1
80000278:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000027a:	2f ed       	sub	sp,-8
8000027c:	ec 05 18 00 	cp.b	r5,r6
80000280:	fe 9b ff c8 	brhi	80000210 <ButtonConfig_brdcst_func+0x3c>
80000284:	d8 32       	popm	r0-r7,pc
80000286:	00 00       	add	r0,r0
80000288:	80 00       	ld.sh	r0,r0[0x0]
8000028a:	b3 14       	ld.d	r4,--r9
8000028c:	80 00       	ld.sh	r0,r0[0x0]
8000028e:	52 08       	stdsp	sp[0x80],r8
80000290:	80 00       	ld.sh	r0,r0[0x0]
80000292:	b3 34       	mul	r4,r9
80000294:	80 00       	ld.sh	r0,r0[0x0]
80000296:	b3 48       	asr	r8,0x12
80000298:	80 00       	ld.sh	r0,r0[0x0]
8000029a:	b3 60       	lsl	r0,0x12
8000029c:	80 00       	ld.sh	r0,r0[0x0]
8000029e:	b3 80       	lsr	r0,0x12
800002a0:	80 00       	ld.sh	r0,r0[0x0]
800002a2:	b3 a8       	sbr	r8,0x12
800002a4:	80 00       	ld.sh	r0,r0[0x0]
800002a6:	b3 d0       	cbr	r0,0x13
800002a8:	80 00       	ld.sh	r0,r0[0x0]
800002aa:	b3 f4       	*unknown*
800002ac:	80 00       	ld.sh	r0,r0[0x0]
800002ae:	b4 1c       	st.h	r10[0x2],r12

800002b0 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800002b0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800002b4:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800002b8:	0f 89       	ld.ub	r9,r7[0x0]
800002ba:	30 08       	mov	r8,0
800002bc:	f0 09 18 00 	cp.b	r9,r8
800002c0:	c0 c1       	brne	800002d8 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800002c2:	48 9c       	lddpc	r12,800002e4 <ButtonConfig_reply_func+0x34>
800002c4:	f0 1f 00 09 	mcall	800002e8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800002c8:	0f 98       	ld.ub	r8,r7[0x1]
800002ca:	1a d8       	st.w	--sp,r8
800002cc:	48 8c       	lddpc	r12,800002ec <ButtonConfig_reply_func+0x3c>
800002ce:	f0 1f 00 07 	mcall	800002e8 <ButtonConfig_reply_func+0x38>
800002d2:	2f fd       	sub	sp,-4
800002d4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800002d8:	48 6c       	lddpc	r12,800002f0 <ButtonConfig_reply_func+0x40>
800002da:	f0 1f 00 04 	mcall	800002e8 <ButtonConfig_reply_func+0x38>
800002de:	e3 cd 80 80 	ldm	sp++,r7,pc
800002e2:	00 00       	add	r0,r0
800002e4:	80 00       	ld.sh	r0,r0[0x0]
800002e6:	b4 40       	st.h	r10[0x8],r0
800002e8:	80 00       	ld.sh	r0,r0[0x0]
800002ea:	52 08       	stdsp	sp[0x80],r8
800002ec:	80 00       	ld.sh	r0,r0[0x0]
800002ee:	b3 34       	mul	r4,r9
800002f0:	80 00       	ld.sh	r0,r0[0x0]
800002f2:	b4 58       	st.h	r10[0xa],r8

800002f4 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800002f4:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800002f6:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
800002fa:	0d 88       	ld.ub	r8,r6[0x0]
800002fc:	32 49       	mov	r9,36
800002fe:	f2 08 18 00 	cp.b	r8,r9
80000302:	c2 91       	brne	80000354 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80000304:	4a 7c       	lddpc	r12,800003a0 <DataSession_brdcst_func+0xac>
80000306:	f0 1f 00 28 	mcall	800003a4 <DataSession_brdcst_func+0xb0>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
8000030a:	0d a5       	ld.ub	r5,r6[0x2]
8000030c:	0d b8       	ld.ub	r8,r6[0x3]
8000030e:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80000312:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80000314:	0d 98       	ld.ub	r8,r6[0x1]
80000316:	1a d8       	st.w	--sp,r8
80000318:	4a 4c       	lddpc	r12,800003a8 <DataSession_brdcst_func+0xb4>
8000031a:	f0 1f 00 23 	mcall	800003a4 <DataSession_brdcst_func+0xb0>
		log("\n\r paylaod_length: %d \n\r",data_length );
8000031e:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80000322:	1a d8       	st.w	--sp,r8
80000324:	4a 2c       	lddpc	r12,800003ac <DataSession_brdcst_func+0xb8>
80000326:	f0 1f 00 20 	mcall	800003a4 <DataSession_brdcst_func+0xb0>
		for(i=0; i<data_length; i++)
8000032a:	2f ed       	sub	sp,-8
8000032c:	58 05       	cp.w	r5,0
8000032e:	c3 70       	breq	8000039c <DataSession_brdcst_func+0xa8>
80000330:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80000332:	4a 04       	lddpc	r4,800003b0 <DataSession_brdcst_func+0xbc>
80000334:	ec 07 00 08 	add	r8,r6,r7
80000338:	11 c8       	ld.ub	r8,r8[0x4]
8000033a:	1a d8       	st.w	--sp,r8
8000033c:	1a d7       	st.w	--sp,r7
8000033e:	08 9c       	mov	r12,r4
80000340:	f0 1f 00 19 	mcall	800003a4 <DataSession_brdcst_func+0xb0>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80000344:	2f f7       	sub	r7,-1
80000346:	5c 57       	castu.b	r7
80000348:	2f ed       	sub	sp,-8
8000034a:	ee 05 19 00 	cp.h	r5,r7
8000034e:	fe 9b ff f3 	brhi	80000334 <DataSession_brdcst_func+0x40>
80000352:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("State: %X \n", ptr->State);
80000354:	1a d8       	st.w	--sp,r8
80000356:	49 8c       	lddpc	r12,800003b4 <DataSession_brdcst_func+0xc0>
80000358:	f0 1f 00 13 	mcall	800003a4 <DataSession_brdcst_func+0xb0>
		if (ptr->State == DATA_SESSION_TX_Suc)
8000035c:	0d 88       	ld.ub	r8,r6[0x0]
8000035e:	2f fd       	sub	sp,-4
80000360:	30 39       	mov	r9,3
80000362:	f2 08 18 00 	cp.b	r8,r9
80000366:	c0 51       	brne	80000370 <DataSession_brdcst_func+0x7c>
		{
			log("data transmit success\n");
80000368:	49 4c       	lddpc	r12,800003b8 <DataSession_brdcst_func+0xc4>
8000036a:	f0 1f 00 0f 	mcall	800003a4 <DataSession_brdcst_func+0xb0>
8000036e:	c0 88       	rjmp	8000037e <DataSession_brdcst_func+0x8a>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
80000370:	30 49       	mov	r9,4
80000372:	f2 08 18 00 	cp.b	r8,r9
80000376:	c0 41       	brne	8000037e <DataSession_brdcst_func+0x8a>
		{
			log("data transmit failure\n");
80000378:	49 1c       	lddpc	r12,800003bc <DataSession_brdcst_func+0xc8>
8000037a:	f0 1f 00 0b 	mcall	800003a4 <DataSession_brdcst_func+0xb0>
			//xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate send-failure!!!
		}
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
			
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
8000037e:	0d a7       	ld.ub	r7,r6[0x2]
80000380:	0d b8       	ld.ub	r8,r6[0x3]
80000382:	f1 e7 10 87 	or	r7,r8,r7<<0x8

		log("\n\r Session_ID: %x \n\r",Session_number );
80000386:	0d 98       	ld.ub	r8,r6[0x1]
80000388:	1a d8       	st.w	--sp,r8
8000038a:	48 8c       	lddpc	r12,800003a8 <DataSession_brdcst_func+0xb4>
8000038c:	f0 1f 00 06 	mcall	800003a4 <DataSession_brdcst_func+0xb0>
		log("\n\r paylaod_length: %d \n\r",data_length );
80000390:	5c 77       	castu.h	r7
80000392:	1a d7       	st.w	--sp,r7
80000394:	48 6c       	lddpc	r12,800003ac <DataSession_brdcst_func+0xb8>
80000396:	f0 1f 00 04 	mcall	800003a4 <DataSession_brdcst_func+0xb0>
8000039a:	2f ed       	sub	sp,-8
8000039c:	d8 22       	popm	r4-r7,pc
8000039e:	00 00       	add	r0,r0
800003a0:	80 00       	ld.sh	r0,r0[0x0]
800003a2:	b4 74       	st.h	r10[0xe],r4
800003a4:	80 00       	ld.sh	r0,r0[0x0]
800003a6:	52 08       	stdsp	sp[0x80],r8
800003a8:	80 00       	ld.sh	r0,r0[0x0]
800003aa:	b4 88       	st.b	r10[0x0],r8
800003ac:	80 00       	ld.sh	r0,r0[0x0]
800003ae:	b4 a0       	st.b	r10[0x2],r0
800003b0:	80 00       	ld.sh	r0,r0[0x0]
800003b2:	b4 bc       	st.b	r10[0x3],r12
800003b4:	80 00       	ld.sh	r0,r0[0x0]
800003b6:	b4 d4       	st.b	r10[0x5],r4
800003b8:	80 00       	ld.sh	r0,r0[0x0]
800003ba:	b4 e0       	st.b	r10[0x6],r0
800003bc:	80 00       	ld.sh	r0,r0[0x0]
800003be:	b4 f8       	st.b	r10[0x7],r8

800003c0 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
800003c0:	eb cd 40 80 	pushm	r7,lr
800003c4:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800003c6:	19 a9       	ld.ub	r9,r12[0x2]
800003c8:	30 08       	mov	r8,0
800003ca:	f0 09 18 00 	cp.b	r9,r8
800003ce:	c1 11       	brne	800003f0 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
800003d0:	49 3c       	lddpc	r12,8000041c <DataSession_reply_func+0x5c>
800003d2:	f0 1f 00 14 	mcall	80000420 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
800003d6:	0f b8       	ld.ub	r8,r7[0x3]
800003d8:	1a d8       	st.w	--sp,r8
800003da:	49 3c       	lddpc	r12,80000424 <DataSession_reply_func+0x64>
800003dc:	f0 1f 00 11 	mcall	80000420 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
800003e0:	0f c8       	ld.ub	r8,r7[0x4]
800003e2:	1a d8       	st.w	--sp,r8
800003e4:	49 1c       	lddpc	r12,80000428 <DataSession_reply_func+0x68>
800003e6:	f0 1f 00 0f 	mcall	80000420 <DataSession_reply_func+0x60>
800003ea:	2f ed       	sub	sp,-8
800003ec:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
800003f0:	48 fc       	lddpc	r12,8000042c <DataSession_reply_func+0x6c>
800003f2:	f0 1f 00 0c 	mcall	80000420 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
800003f6:	0f a8       	ld.ub	r8,r7[0x2]
800003f8:	1a d8       	st.w	--sp,r8
800003fa:	48 ec       	lddpc	r12,80000430 <DataSession_reply_func+0x70>
800003fc:	f0 1f 00 09 	mcall	80000420 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
80000400:	0f b8       	ld.ub	r8,r7[0x3]
80000402:	1a d8       	st.w	--sp,r8
80000404:	48 cc       	lddpc	r12,80000434 <DataSession_reply_func+0x74>
80000406:	f0 1f 00 07 	mcall	80000420 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
8000040a:	0f c8       	ld.ub	r8,r7[0x4]
8000040c:	1a d8       	st.w	--sp,r8
8000040e:	48 bc       	lddpc	r12,80000438 <DataSession_reply_func+0x78>
80000410:	f0 1f 00 04 	mcall	80000420 <DataSession_reply_func+0x60>
80000414:	2f dd       	sub	sp,-12
80000416:	e3 cd 80 80 	ldm	sp++,r7,pc
8000041a:	00 00       	add	r0,r0
8000041c:	80 00       	ld.sh	r0,r0[0x0]
8000041e:	b5 10       	ld.d	r0,--r10
80000420:	80 00       	ld.sh	r0,r0[0x0]
80000422:	52 08       	stdsp	sp[0x80],r8
80000424:	80 00       	ld.sh	r0,r0[0x0]
80000426:	b5 20       	st.d	r10++,r0
80000428:	80 00       	ld.sh	r0,r0[0x0]
8000042a:	b5 2c       	st.d	r10++,r12
8000042c:	80 00       	ld.sh	r0,r0[0x0]
8000042e:	b5 38       	mul	r8,r10
80000430:	80 00       	ld.sh	r0,r0[0x0]
80000432:	b5 48       	asr	r8,0x14
80000434:	80 00       	ld.sh	r0,r0[0x0]
80000436:	b5 58       	asr	r8,0x15
80000438:	80 00       	ld.sh	r0,r0[0x0]
8000043a:	b5 64       	lsl	r4,0x14

8000043c <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
8000043c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80000440:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80000444:	0f 98       	ld.ub	r8,r7[0x1]
80000446:	1a d8       	st.w	--sp,r8
80000448:	48 bc       	lddpc	r12,80000474 <CallControl_brdcst_func+0x38>
8000044a:	f0 1f 00 0c 	mcall	80000478 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000044e:	2f fd       	sub	sp,-4
80000450:	0f 99       	ld.ub	r9,r7[0x1]
80000452:	30 38       	mov	r8,3
80000454:	f0 09 18 00 	cp.b	r9,r8
80000458:	c0 41       	brne	80000460 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
8000045a:	30 09       	mov	r9,0
8000045c:	48 88       	lddpc	r8,8000047c <CallControl_brdcst_func+0x40>
8000045e:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
80000460:	0f 99       	ld.ub	r9,r7[0x1]
80000462:	30 48       	mov	r8,4
80000464:	f0 09 18 00 	cp.b	r9,r8
80000468:	c0 41       	brne	80000470 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
8000046a:	30 19       	mov	r9,1
8000046c:	48 48       	lddpc	r8,8000047c <CallControl_brdcst_func+0x40>
8000046e:	b0 89       	st.b	r8[0x0],r9
80000470:	e3 cd 80 80 	ldm	sp++,r7,pc
80000474:	80 00       	ld.sh	r0,r0[0x0]
80000476:	b5 70       	lsl	r0,0x15
80000478:	80 00       	ld.sh	r0,r0[0x0]
8000047a:	52 08       	stdsp	sp[0x80],r8
8000047c:	00 00       	add	r0,r0
8000047e:	0a 5a       	eor	r10,r5

80000480 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80000480:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80000484:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80000488:	0f 99       	ld.ub	r9,r7[0x1]
8000048a:	30 08       	mov	r8,0
8000048c:	f0 09 18 00 	cp.b	r9,r8
80000490:	c0 71       	brne	8000049e <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
80000492:	48 ac       	lddpc	r12,800004b8 <TransmitControl_brdcst_func+0x38>
80000494:	f0 1f 00 0a 	mcall	800004bc <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
80000498:	30 09       	mov	r9,0
8000049a:	48 a8       	lddpc	r8,800004c0 <TransmitControl_brdcst_func+0x40>
8000049c:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
8000049e:	0f 99       	ld.ub	r9,r7[0x1]
800004a0:	30 18       	mov	r8,1
800004a2:	f0 09 18 00 	cp.b	r9,r8
800004a6:	c0 71       	brne	800004b4 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800004a8:	48 7c       	lddpc	r12,800004c4 <TransmitControl_brdcst_func+0x44>
800004aa:	f0 1f 00 05 	mcall	800004bc <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800004ae:	30 19       	mov	r9,1
800004b0:	48 48       	lddpc	r8,800004c0 <TransmitControl_brdcst_func+0x40>
800004b2:	b0 89       	st.b	r8[0x0],r9
800004b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800004b8:	80 00       	ld.sh	r0,r0[0x0]
800004ba:	b5 88       	lsr	r8,0x14
800004bc:	80 00       	ld.sh	r0,r0[0x0]
800004be:	52 08       	stdsp	sp[0x80],r8
800004c0:	00 00       	add	r0,r0
800004c2:	0a 59       	eor	r9,r5
800004c4:	80 00       	ld.sh	r0,r0[0x0]
800004c6:	b5 a0       	sbr	r0,0x14

800004c8 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
800004c8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
800004cc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
800004d0:	0f 89       	ld.ub	r9,r7[0x0]
800004d2:	30 08       	mov	r8,0
800004d4:	f0 09 18 00 	cp.b	r9,r8
800004d8:	c1 61       	brne	80000504 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
800004da:	48 ec       	lddpc	r12,80000510 <TransmitControl_reply_func+0x48>
800004dc:	f0 1f 00 0e 	mcall	80000514 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
800004e0:	0f 98       	ld.ub	r8,r7[0x1]
800004e2:	1a d8       	st.w	--sp,r8
800004e4:	48 dc       	lddpc	r12,80000518 <TransmitControl_reply_func+0x50>
800004e6:	f0 1f 00 0c 	mcall	80000514 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
800004ea:	0f a8       	ld.ub	r8,r7[0x2]
800004ec:	1a d8       	st.w	--sp,r8
800004ee:	48 cc       	lddpc	r12,8000051c <TransmitControl_reply_func+0x54>
800004f0:	f0 1f 00 09 	mcall	80000514 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
800004f4:	0f b8       	ld.ub	r8,r7[0x3]
800004f6:	1a d8       	st.w	--sp,r8
800004f8:	48 ac       	lddpc	r12,80000520 <TransmitControl_reply_func+0x58>
800004fa:	f0 1f 00 07 	mcall	80000514 <TransmitControl_reply_func+0x4c>
800004fe:	2f dd       	sub	sp,-12
80000500:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80000504:	48 8c       	lddpc	r12,80000524 <TransmitControl_reply_func+0x5c>
80000506:	f0 1f 00 04 	mcall	80000514 <TransmitControl_reply_func+0x4c>
8000050a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000050e:	00 00       	add	r0,r0
80000510:	80 00       	ld.sh	r0,r0[0x0]
80000512:	b5 b4       	sbr	r4,0x15
80000514:	80 00       	ld.sh	r0,r0[0x0]
80000516:	52 08       	stdsp	sp[0x80],r8
80000518:	80 00       	ld.sh	r0,r0[0x0]
8000051a:	b5 d0       	cbr	r0,0x15
8000051c:	80 00       	ld.sh	r0,r0[0x0]
8000051e:	b5 e4       	*unknown*
80000520:	80 00       	ld.sh	r0,r0[0x0]
80000522:	b6 00       	st.h	r11[0x0],r0
80000524:	80 00       	ld.sh	r0,r0[0x0]
80000526:	b6 10       	st.h	r11[0x2],r0

80000528 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80000528:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000052a:	19 a9       	ld.ub	r9,r12[0x2]
8000052c:	30 08       	mov	r8,0
8000052e:	f0 09 18 00 	cp.b	r9,r8
80000532:	c0 51       	brne	8000053c <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80000534:	48 4c       	lddpc	r12,80000544 <AudioRoutingControl_reply_func+0x1c>
80000536:	f0 1f 00 05 	mcall	80000548 <AudioRoutingControl_reply_func+0x20>
8000053a:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
8000053c:	48 4c       	lddpc	r12,8000054c <AudioRoutingControl_reply_func+0x24>
8000053e:	f0 1f 00 03 	mcall	80000548 <AudioRoutingControl_reply_func+0x20>
80000542:	d8 02       	popm	pc
80000544:	80 00       	ld.sh	r0,r0[0x0]
80000546:	b6 28       	st.h	r11[0x4],r8
80000548:	80 00       	ld.sh	r0,r0[0x0]
8000054a:	52 08       	stdsp	sp[0x80],r8
8000054c:	80 00       	ld.sh	r0,r0[0x0]
8000054e:	b6 38       	st.h	r11[0x6],r8

80000550 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80000550:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80000554:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80000558:	0f 89       	ld.ub	r9,r7[0x0]
8000055a:	30 08       	mov	r8,0
8000055c:	f0 09 18 00 	cp.b	r9,r8
80000560:	c1 b1       	brne	80000596 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80000562:	0f b8       	ld.ub	r8,r7[0x3]
80000564:	31 09       	mov	r9,16
80000566:	f2 08 18 00 	cp.b	r8,r9
8000056a:	c0 f1       	brne	80000588 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
8000056c:	48 dc       	lddpc	r12,800005a0 <Volume_reply_func+0x50>
8000056e:	f0 1f 00 0e 	mcall	800005a4 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80000572:	0f 99       	ld.ub	r9,r7[0x1]
80000574:	0f a8       	ld.ub	r8,r7[0x2]
80000576:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000057a:	1a d8       	st.w	--sp,r8
8000057c:	48 bc       	lddpc	r12,800005a8 <Volume_reply_func+0x58>
8000057e:	f0 1f 00 0a 	mcall	800005a4 <Volume_reply_func+0x54>
80000582:	2f fd       	sub	sp,-4
80000584:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
80000588:	1a d8       	st.w	--sp,r8
8000058a:	48 9c       	lddpc	r12,800005ac <Volume_reply_func+0x5c>
8000058c:	f0 1f 00 06 	mcall	800005a4 <Volume_reply_func+0x54>
80000590:	2f fd       	sub	sp,-4
80000592:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
80000596:	48 7c       	lddpc	r12,800005b0 <Volume_reply_func+0x60>
80000598:	f0 1f 00 03 	mcall	800005a4 <Volume_reply_func+0x54>
8000059c:	e3 cd 80 80 	ldm	sp++,r7,pc
800005a0:	80 00       	ld.sh	r0,r0[0x0]
800005a2:	b6 4c       	st.h	r11[0x8],r12
800005a4:	80 00       	ld.sh	r0,r0[0x0]
800005a6:	52 08       	stdsp	sp[0x80],r8
800005a8:	80 00       	ld.sh	r0,r0[0x0]
800005aa:	b6 60       	st.h	r11[0xc],r0
800005ac:	80 00       	ld.sh	r0,r0[0x0]
800005ae:	b6 7c       	st.h	r11[0xe],r12
800005b0:	80 00       	ld.sh	r0,r0[0x0]
800005b2:	b6 94       	st.b	r11[0x1],r4

800005b4 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800005b4:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800005b6:	19 d9       	ld.ub	r9,r12[0x5]
800005b8:	30 08       	mov	r8,0
800005ba:	f0 09 18 00 	cp.b	r9,r8
800005be:	c0 81       	brne	800005ce <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
800005c0:	10 99       	mov	r9,r8
800005c2:	48 78       	lddpc	r8,800005dc <spk_brdcst_func+0x28>
800005c4:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
800005c6:	48 7c       	lddpc	r12,800005e0 <spk_brdcst_func+0x2c>
800005c8:	f0 1f 00 07 	mcall	800005e4 <spk_brdcst_func+0x30>
800005cc:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
800005ce:	30 19       	mov	r9,1
800005d0:	48 38       	lddpc	r8,800005dc <spk_brdcst_func+0x28>
800005d2:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
800005d4:	48 5c       	lddpc	r12,800005e8 <spk_brdcst_func+0x34>
800005d6:	f0 1f 00 04 	mcall	800005e4 <spk_brdcst_func+0x30>
800005da:	d8 02       	popm	pc
800005dc:	00 00       	add	r0,r0
800005de:	0a 48       	or	r8,r5
800005e0:	80 00       	ld.sh	r0,r0[0x0]
800005e2:	b6 ac       	st.b	r11[0x2],r12
800005e4:	80 00       	ld.sh	r0,r0[0x0]
800005e6:	52 08       	stdsp	sp[0x80],r8
800005e8:	80 00       	ld.sh	r0,r0[0x0]
800005ea:	b6 bc       	st.b	r11[0x3],r12

800005ec <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
800005ec:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800005ee:	19 a9       	ld.ub	r9,r12[0x2]
800005f0:	30 08       	mov	r8,0
800005f2:	f0 09 18 00 	cp.b	r9,r8
800005f6:	c0 f1       	brne	80000614 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
800005f8:	19 e9       	ld.ub	r9,r12[0x6]
800005fa:	f0 09 18 00 	cp.b	r9,r8
800005fe:	c0 40       	breq	80000606 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80000600:	30 19       	mov	r9,1
80000602:	48 98       	lddpc	r8,80000624 <spk_reply_func+0x38>
80000604:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80000606:	19 e8       	ld.ub	r8,r12[0x6]
80000608:	1a d8       	st.w	--sp,r8
8000060a:	48 8c       	lddpc	r12,80000628 <spk_reply_func+0x3c>
8000060c:	f0 1f 00 08 	mcall	8000062c <spk_reply_func+0x40>
80000610:	2f fd       	sub	sp,-4
80000612:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80000614:	30 09       	mov	r9,0
80000616:	48 48       	lddpc	r8,80000624 <spk_reply_func+0x38>
80000618:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000061a:	48 6c       	lddpc	r12,80000630 <spk_reply_func+0x44>
8000061c:	f0 1f 00 04 	mcall	8000062c <spk_reply_func+0x40>
80000620:	d8 02       	popm	pc
80000622:	00 00       	add	r0,r0
80000624:	00 00       	add	r0,r0
80000626:	0a 48       	or	r8,r5
80000628:	80 00       	ld.sh	r0,r0[0x0]
8000062a:	b6 c8       	st.b	r11[0x4],r8
8000062c:	80 00       	ld.sh	r0,r0[0x0]
8000062e:	52 08       	stdsp	sp[0x80],r8
80000630:	80 00       	ld.sh	r0,r0[0x0]
80000632:	b6 d8       	st.b	r11[0x5],r8

80000634 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80000634:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80000638:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
8000063c:	0f a9       	ld.ub	r9,r7[0x2]
8000063e:	30 08       	mov	r8,0
80000640:	f0 09 18 00 	cp.b	r9,r8
80000644:	c0 71       	brne	80000652 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
80000646:	48 dc       	lddpc	r12,80000678 <mic_brdcst_func+0x44>
80000648:	f0 1f 00 0d 	mcall	8000067c <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
8000064c:	30 09       	mov	r9,0
8000064e:	48 d8       	lddpc	r8,80000680 <mic_brdcst_func+0x4c>
80000650:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80000652:	0f a9       	ld.ub	r9,r7[0x2]
80000654:	31 18       	mov	r8,17
80000656:	f0 09 18 00 	cp.b	r9,r8
8000065a:	c0 d1       	brne	80000674 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
8000065c:	48 ac       	lddpc	r12,80000684 <mic_brdcst_func+0x50>
8000065e:	f0 1f 00 08 	mcall	8000067c <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
80000662:	48 89       	lddpc	r9,80000680 <mic_brdcst_func+0x4c>
80000664:	30 18       	mov	r8,1
80000666:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
80000668:	13 89       	ld.ub	r9,r9[0x0]
8000066a:	f0 09 18 00 	cp.b	r9,r8
8000066e:	c0 31       	brne	80000674 <mic_brdcst_func+0x40>
80000670:	48 68       	lddpc	r8,80000688 <mic_brdcst_func+0x54>
80000672:	11 88       	ld.ub	r8,r8[0x0]
80000674:	e3 cd 80 80 	ldm	sp++,r7,pc
80000678:	80 00       	ld.sh	r0,r0[0x0]
8000067a:	b6 e4       	st.b	r11[0x6],r4
8000067c:	80 00       	ld.sh	r0,r0[0x0]
8000067e:	52 08       	stdsp	sp[0x80],r8
80000680:	00 00       	add	r0,r0
80000682:	0a 5d       	eor	sp,r5
80000684:	80 00       	ld.sh	r0,r0[0x0]
80000686:	b6 f8       	st.b	r11[0x7],r8
80000688:	00 00       	add	r0,r0
8000068a:	0a 5a       	eor	r10,r5

8000068c <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
8000068c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80000690:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80000694:	49 ac       	lddpc	r12,800006fc <mic_reply_func+0x70>
80000696:	f0 1f 00 1b 	mcall	80000700 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
8000069a:	0f 89       	ld.ub	r9,r7[0x0]
8000069c:	30 08       	mov	r8,0
8000069e:	f0 09 18 00 	cp.b	r9,r8
800006a2:	c2 71       	brne	800006f0 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800006a4:	0f 98       	ld.ub	r8,r7[0x1]
800006a6:	30 29       	mov	r9,2
800006a8:	f2 08 18 00 	cp.b	r8,r9
800006ac:	c1 b1       	brne	800006e2 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800006ae:	49 6c       	lddpc	r12,80000704 <mic_reply_func+0x78>
800006b0:	f0 1f 00 14 	mcall	80000700 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800006b4:	0f a8       	ld.ub	r8,r7[0x2]
800006b6:	1a d8       	st.w	--sp,r8
800006b8:	49 4c       	lddpc	r12,80000708 <mic_reply_func+0x7c>
800006ba:	f0 1f 00 12 	mcall	80000700 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
800006be:	0f b8       	ld.ub	r8,r7[0x3]
800006c0:	1a d8       	st.w	--sp,r8
800006c2:	49 3c       	lddpc	r12,8000070c <mic_reply_func+0x80>
800006c4:	f0 1f 00 0f 	mcall	80000700 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
800006c8:	0f c8       	ld.ub	r8,r7[0x4]
800006ca:	1a d8       	st.w	--sp,r8
800006cc:	49 1c       	lddpc	r12,80000710 <mic_reply_func+0x84>
800006ce:	f0 1f 00 0d 	mcall	80000700 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
800006d2:	0f d8       	ld.ub	r8,r7[0x5]
800006d4:	1a d8       	st.w	--sp,r8
800006d6:	49 0c       	lddpc	r12,80000714 <mic_reply_func+0x88>
800006d8:	f0 1f 00 0a 	mcall	80000700 <mic_reply_func+0x74>
800006dc:	2f cd       	sub	sp,-16
800006de:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800006e2:	1a d8       	st.w	--sp,r8
800006e4:	48 dc       	lddpc	r12,80000718 <mic_reply_func+0x8c>
800006e6:	f0 1f 00 07 	mcall	80000700 <mic_reply_func+0x74>
800006ea:	2f fd       	sub	sp,-4
800006ec:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800006f0:	48 bc       	lddpc	r12,8000071c <mic_reply_func+0x90>
800006f2:	f0 1f 00 04 	mcall	80000700 <mic_reply_func+0x74>
800006f6:	e3 cd 80 80 	ldm	sp++,r7,pc
800006fa:	00 00       	add	r0,r0
800006fc:	80 00       	ld.sh	r0,r0[0x0]
800006fe:	b7 0c       	ld.d	r12,r11
80000700:	80 00       	ld.sh	r0,r0[0x0]
80000702:	52 08       	stdsp	sp[0x80],r8
80000704:	80 00       	ld.sh	r0,r0[0x0]
80000706:	b7 1c       	ld.d	r12,--r11
80000708:	80 00       	ld.sh	r0,r0[0x0]
8000070a:	b7 30       	mul	r0,r11
8000070c:	80 00       	ld.sh	r0,r0[0x0]
8000070e:	b7 44       	asr	r4,0x16
80000710:	80 00       	ld.sh	r0,r0[0x0]
80000712:	b7 60       	lsl	r0,0x16
80000714:	80 00       	ld.sh	r0,r0[0x0]
80000716:	b7 78       	lsl	r8,0x17
80000718:	80 00       	ld.sh	r0,r0[0x0]
8000071a:	b7 90       	lsr	r0,0x17
8000071c:	80 00       	ld.sh	r0,r0[0x0]
8000071e:	b7 a8       	sbr	r8,0x16

80000720 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80000720:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80000724:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80000728:	48 bc       	lddpc	r12,80000754 <dcm_brdcst_func+0x34>
8000072a:	f0 1f 00 0c 	mcall	80000758 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
8000072e:	0f 88       	ld.ub	r8,r7[0x0]
80000730:	1a d8       	st.w	--sp,r8
80000732:	48 bc       	lddpc	r12,8000075c <dcm_brdcst_func+0x3c>
80000734:	f0 1f 00 09 	mcall	80000758 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80000738:	0f a8       	ld.ub	r8,r7[0x2]
8000073a:	1a d8       	st.w	--sp,r8
8000073c:	48 9c       	lddpc	r12,80000760 <dcm_brdcst_func+0x40>
8000073e:	f0 1f 00 07 	mcall	80000758 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80000742:	0f 98       	ld.ub	r8,r7[0x1]
80000744:	1a d8       	st.w	--sp,r8
80000746:	48 8c       	lddpc	r12,80000764 <dcm_brdcst_func+0x44>
80000748:	f0 1f 00 04 	mcall	80000758 <dcm_brdcst_func+0x38>
8000074c:	2f dd       	sub	sp,-12
	
	
}
8000074e:	e3 cd 80 80 	ldm	sp++,r7,pc
80000752:	00 00       	add	r0,r0
80000754:	80 00       	ld.sh	r0,r0[0x0]
80000756:	b7 b8       	sbr	r8,0x17
80000758:	80 00       	ld.sh	r0,r0[0x0]
8000075a:	52 08       	stdsp	sp[0x80],r8
8000075c:	80 00       	ld.sh	r0,r0[0x0]
8000075e:	b7 cc       	cbr	r12,0x16
80000760:	80 00       	ld.sh	r0,r0[0x0]
80000762:	b7 e0       	*unknown*
80000764:	80 00       	ld.sh	r0,r0[0x0]
80000766:	b7 f8       	*unknown*

80000768 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80000768:	eb cd 40 80 	pushm	r7,lr
8000076c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000076e:	19 a9       	ld.ub	r9,r12[0x2]
80000770:	30 08       	mov	r8,0
80000772:	f0 09 18 00 	cp.b	r9,r8
80000776:	c1 b1       	brne	800007ac <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
80000778:	19 b8       	ld.ub	r8,r12[0x3]
8000077a:	30 19       	mov	r9,1
8000077c:	f2 08 18 00 	cp.b	r8,r9
80000780:	c0 51       	brne	8000078a <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
80000782:	48 ec       	lddpc	r12,800007b8 <dcm_reply_func+0x50>
80000784:	f0 1f 00 0e 	mcall	800007bc <dcm_reply_func+0x54>
80000788:	c0 a8       	rjmp	8000079c <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
8000078a:	58 08       	cp.w	r8,0
8000078c:	c0 51       	brne	80000796 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
8000078e:	48 dc       	lddpc	r12,800007c0 <dcm_reply_func+0x58>
80000790:	f0 1f 00 0b 	mcall	800007bc <dcm_reply_func+0x54>
80000794:	c0 48       	rjmp	8000079c <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
80000796:	48 cc       	lddpc	r12,800007c4 <dcm_reply_func+0x5c>
80000798:	f0 1f 00 09 	mcall	800007bc <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
8000079c:	0f d8       	ld.ub	r8,r7[0x5]
8000079e:	1a d8       	st.w	--sp,r8
800007a0:	48 ac       	lddpc	r12,800007c8 <dcm_reply_func+0x60>
800007a2:	f0 1f 00 07 	mcall	800007bc <dcm_reply_func+0x54>
800007a6:	2f fd       	sub	sp,-4
800007a8:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800007ac:	48 8c       	lddpc	r12,800007cc <dcm_reply_func+0x64>
800007ae:	f0 1f 00 04 	mcall	800007bc <dcm_reply_func+0x54>
800007b2:	e3 cd 80 80 	ldm	sp++,r7,pc
800007b6:	00 00       	add	r0,r0
800007b8:	80 00       	ld.sh	r0,r0[0x0]
800007ba:	b8 14       	st.h	r12[0x2],r4
800007bc:	80 00       	ld.sh	r0,r0[0x0]
800007be:	52 08       	stdsp	sp[0x80],r8
800007c0:	80 00       	ld.sh	r0,r0[0x0]
800007c2:	b8 28       	st.h	r12[0x4],r8
800007c4:	80 00       	ld.sh	r0,r0[0x0]
800007c6:	b8 3c       	st.h	r12[0x6],r12
800007c8:	80 00       	ld.sh	r0,r0[0x0]
800007ca:	b8 50       	st.h	r12[0xa],r0
800007cc:	80 00       	ld.sh	r0,r0[0x0]
800007ce:	b8 5c       	st.h	r12[0xa],r12

800007d0 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800007d0:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800007d2:	19 a9       	ld.ub	r9,r12[0x2]
800007d4:	30 08       	mov	r8,0
800007d6:	f0 09 18 00 	cp.b	r9,r8
800007da:	c0 51       	brne	800007e4 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
800007dc:	48 4c       	lddpc	r12,800007ec <ToneControl_reply_func+0x1c>
800007de:	f0 1f 00 05 	mcall	800007f0 <ToneControl_reply_func+0x20>
800007e2:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800007e4:	48 4c       	lddpc	r12,800007f4 <ToneControl_reply_func+0x24>
800007e6:	f0 1f 00 03 	mcall	800007f0 <ToneControl_reply_func+0x20>
800007ea:	d8 02       	popm	pc
800007ec:	80 00       	ld.sh	r0,r0[0x0]
800007ee:	b8 68       	st.h	r12[0xc],r8
800007f0:	80 00       	ld.sh	r0,r0[0x0]
800007f2:	52 08       	stdsp	sp[0x80],r8
800007f4:	80 00       	ld.sh	r0,r0[0x0]
800007f6:	b8 74       	st.h	r12[0xe],r4

800007f8 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;
extern volatile DateTime_t Current_time;
static __app_Thread_(app_cfg)
{
800007f8:	d4 31       	pushm	r0-r7,lr
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	
	 xLastWakeTime = xTaskGetTickCount();
800007fa:	f0 1f 00 1f 	mcall	80000874 <app_cfg+0x7c>
800007fe:	49 f8       	lddpc	r8,80000878 <app_cfg+0x80>
80000800:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80000802:	49 f6       	lddpc	r6,8000087c <app_cfg+0x84>
		{	
			connect_flag=1;	
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!

		}
		else if(connect_flag)
80000804:	49 f5       	lddpc	r5,80000880 <app_cfg+0x88>
		else
		{
			nop();
			nop();
			nop();
			xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
80000806:	30 62       	mov	r2,6
80000808:	30 13       	mov	r3,1
					//log("no find card...\n");
				//}
				nop();
				log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n", 
				Current_time.Year, Current_time.Month, Current_time.Day, 
				Current_time.Hour, Current_time.Minute, Current_time.Second);
8000080a:	49 f7       	lddpc	r7,80000884 <app_cfg+0x8c>
				//else
				//{
					//log("no find card...\n");
				//}
				nop();
				log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n", 
8000080c:	49 f1       	lddpc	r1,80000888 <app_cfg+0x90>
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
		{	
			connect_flag=1;	
8000080e:	30 10       	mov	r0,1
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80000810:	10 94       	mov	r4,r8
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80000812:	6c 08       	ld.w	r8,r6[0x0]
80000814:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80000818:	58 38       	cp.w	r8,3
8000081a:	c0 a1       	brne	8000082e <app_cfg+0x36>
8000081c:	0b 88       	ld.ub	r8,r5[0x0]
8000081e:	58 08       	cp.w	r8,0
80000820:	c0 71       	brne	8000082e <app_cfg+0x36>
		{	
			connect_flag=1;	
80000822:	aa 80       	st.b	r5[0x0],r0
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80000824:	30 cb       	mov	r11,12
80000826:	06 9c       	mov	r12,r3
80000828:	f0 1f 00 19 	mcall	8000088c <app_cfg+0x94>
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
8000082c:	c1 d8       	rjmp	80000866 <app_cfg+0x6e>
		{	
			connect_flag=1;	
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!

		}
		else if(connect_flag)
8000082e:	0b 88       	ld.ub	r8,r5[0x0]
80000830:	58 08       	cp.w	r8,0
80000832:	c1 30       	breq	80000858 <app_cfg+0x60>
				//}
				//else
				//{
					//log("no find card...\n");
				//}
				nop();
80000834:	d7 03       	nop
				log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n", 
				Current_time.Year, Current_time.Month, Current_time.Day, 
				Current_time.Hour, Current_time.Minute, Current_time.Second);
80000836:	0f de       	ld.ub	lr,r7[0x5]
80000838:	0f cc       	ld.ub	r12,r7[0x4]
8000083a:	0f bb       	ld.ub	r11,r7[0x3]
				//{
					//log("no find card...\n");
				//}
				nop();
				log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n", 
				Current_time.Year, Current_time.Month, Current_time.Day, 
8000083c:	0f aa       	ld.ub	r10,r7[0x2]
8000083e:	0f 99       	ld.ub	r9,r7[0x1]
80000840:	0f 88       	ld.ub	r8,r7[0x0]
				//else
				//{
					//log("no find card...\n");
				//}
				nop();
				log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n", 
80000842:	1a de       	st.w	--sp,lr
80000844:	1a dc       	st.w	--sp,r12
80000846:	1a db       	st.w	--sp,r11
80000848:	1a da       	st.w	--sp,r10
8000084a:	1a d9       	st.w	--sp,r9
8000084c:	1a d8       	st.w	--sp,r8
8000084e:	02 9c       	mov	r12,r1
80000850:	f0 1f 00 10 	mcall	80000890 <app_cfg+0x98>
80000854:	2f ad       	sub	sp,-24
80000856:	c0 88       	rjmp	80000866 <app_cfg+0x6e>
				Current_time.Hour, Current_time.Minute, Current_time.Second);
				
		}
		else
		{
			nop();
80000858:	d7 03       	nop
			nop();
8000085a:	d7 03       	nop
			nop();
8000085c:	d7 03       	nop
			xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
8000085e:	04 9b       	mov	r11,r2
80000860:	06 9c       	mov	r12,r3
80000862:	f0 1f 00 0b 	mcall	8000088c <app_cfg+0x94>
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80000866:	e0 6b 0f a0 	mov	r11,4000
8000086a:	08 9c       	mov	r12,r4
8000086c:	f0 1f 00 0a 	mcall	80000894 <app_cfg+0x9c>
	}
80000870:	cd 1b       	rjmp	80000812 <app_cfg+0x1a>
80000872:	00 00       	add	r0,r0
80000874:	80 00       	ld.sh	r0,r0[0x0]
80000876:	4b 34       	lddpc	r4,80000940 <xg_rtc_init+0x18>
80000878:	00 00       	add	r0,r0
8000087a:	0a 4c       	or	r12,r5
8000087c:	00 00       	add	r0,r0
8000087e:	0d a0       	ld.ub	r0,r6[0x2]
80000880:	00 00       	add	r0,r0
80000882:	0a 5c       	eor	r12,r5
80000884:	00 00       	add	r0,r0
80000886:	0d a4       	ld.ub	r4,r6[0x2]
80000888:	80 00       	ld.sh	r0,r0[0x0]
8000088a:	b8 80       	st.b	r12[0x0],r0
8000088c:	80 00       	ld.sh	r0,r0[0x0]
8000088e:	20 40       	sub	r0,4
80000890:	80 00       	ld.sh	r0,r0[0x0]
80000892:	52 08       	stdsp	sp[0x80],r8
80000894:	80 00       	ld.sh	r0,r0[0x0]
80000896:	4c e4       	lddpc	r4,800009cc <rtc_irq+0x24>

80000898 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80000898:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
8000089c:	19 c7       	ld.ub	r7,r12[0x4]
8000089e:	19 d8       	ld.ub	r8,r12[0x5]
800008a0:	f1 e7 10 87 	or	r7,r8,r7<<0x8
800008a4:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
800008a6:	48 dc       	lddpc	r12,800008d8 <Phyuserinput_brdcst_func+0x40>
800008a8:	f0 1f 00 0d 	mcall	800008dc <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
800008ac:	36 08       	mov	r8,96
800008ae:	f0 07 19 00 	cp.h	r7,r8
800008b2:	c1 11       	brne	800008d4 <Phyuserinput_brdcst_func+0x3c>
800008b4:	48 b8       	lddpc	r8,800008e0 <Phyuserinput_brdcst_func+0x48>
800008b6:	11 89       	ld.ub	r9,r8[0x0]
800008b8:	30 18       	mov	r8,1
800008ba:	f0 09 18 00 	cp.b	r9,r8
800008be:	c0 b1       	brne	800008d4 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, ACK_Received_Tone);//set tone to indicate the scan!!!
800008c0:	31 4b       	mov	r11,20
800008c2:	30 1c       	mov	r12,1
800008c4:	f0 1f 00 08 	mcall	800008e4 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(400*2 / portTICK_RATE_MS);//延迟400ms
800008c8:	e0 6c 03 20 	mov	r12,800
800008cc:	f0 1f 00 07 	mcall	800008e8 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		rfid_sendID_message();//send message		
800008d0:	f0 1f 00 07 	mcall	800008ec <Phyuserinput_brdcst_func+0x54>
800008d4:	e3 cd 80 80 	ldm	sp++,r7,pc
800008d8:	80 00       	ld.sh	r0,r0[0x0]
800008da:	b8 ac       	st.b	r12[0x2],r12
800008dc:	80 00       	ld.sh	r0,r0[0x0]
800008de:	52 08       	stdsp	sp[0x80],r8
800008e0:	00 00       	add	r0,r0
800008e2:	0a 5c       	eor	r12,r5
800008e4:	80 00       	ld.sh	r0,r0[0x0]
800008e6:	20 40       	sub	r0,4
800008e8:	80 00       	ld.sh	r0,r0[0x0]
800008ea:	4c 9c       	lddpc	r12,80000a0c <rtc_irq+0x64>
800008ec:	80 00       	ld.sh	r0,r0[0x0]
800008ee:	30 14       	mov	r4,1

800008f0 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800008f0:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800008f2:	19 e8       	ld.ub	r8,r12[0x6]
800008f4:	30 19       	mov	r9,1
800008f6:	f2 08 18 00 	cp.b	r8,r9
800008fa:	c0 61       	brne	80000906 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800008fc:	48 98       	lddpc	r8,80000920 <DeviceInitializationStatus_brdcst_func+0x30>
800008fe:	70 09       	ld.w	r9,r8[0x0]
80000900:	a1 a9       	sbr	r9,0x0
80000902:	91 09       	st.w	r8[0x0],r9
80000904:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
80000906:	30 29       	mov	r9,2
80000908:	f2 08 18 00 	cp.b	r8,r9
8000090c:	c0 80       	breq	8000091c <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
8000090e:	48 58       	lddpc	r8,80000920 <DeviceInitializationStatus_brdcst_func+0x30>
80000910:	70 09       	ld.w	r9,r8[0x0]
80000912:	e0 19 ff fc 	andl	r9,0xfffc
80000916:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80000918:	f0 1f 00 03 	mcall	80000924 <DeviceInitializationStatus_brdcst_func+0x34>
8000091c:	d8 02       	popm	pc
8000091e:	00 00       	add	r0,r0
80000920:	00 00       	add	r0,r0
80000922:	0d a0       	ld.ub	r0,r6[0x2]
80000924:	80 00       	ld.sh	r0,r0[0x0]
80000926:	1f 94       	ld.ub	r4,pc[0x1]

80000928 <xg_rtc_init>:
}



void xg_rtc_init(void)
{
80000928:	d4 01       	pushm	lr
	//{
		//return 3;
	//}
	  	
	  // Disable all interrupts. */
	  Disable_global_interrupt();
8000092a:	d3 03       	ssrf	0x10
	  
	  // Register the RTC interrupt handler to the interrupt controller.
	  INTC_register_interrupt(&rtc_irq, AVR32_RTC_IRQ, AVR32_INTC_INT0);
8000092c:	30 0a       	mov	r10,0
8000092e:	32 8b       	mov	r11,40
80000930:	49 5c       	lddpc	r12,80000984 <xg_rtc_init+0x5c>
80000932:	f0 1f 00 16 	mcall	80000988 <xg_rtc_init+0x60>

	  // Initialize the RTC
	  if (!rtc_init(&AVR32_RTC, RTC_OSC_RC, RTC_PSEL_RC_1_76HZ))
80000936:	30 fa       	mov	r10,15
80000938:	30 0b       	mov	r11,0
8000093a:	fe 7c 0d 00 	mov	r12,-62208
8000093e:	f0 1f 00 14 	mcall	8000098c <xg_rtc_init+0x64>
80000942:	c0 41       	brne	8000094a <xg_rtc_init+0x22>
	  //if (!rtc_init(&AVR32_RTC, RTC_OSC_32KHZ, RTC_PSEL_32KHZ_1HZ))
	  {
		  log("Error initializing the RTC\r\n");
80000944:	49 3c       	lddpc	r12,80000990 <xg_rtc_init+0x68>
80000946:	f0 1f 00 14 	mcall	80000994 <xg_rtc_init+0x6c>
	  }
	  // Set top value to 0 to generate an interrupt every seconds */
	  rtc_set_top_value(&AVR32_RTC, 0);
8000094a:	30 0b       	mov	r11,0
8000094c:	fe 7c 0d 00 	mov	r12,-62208
80000950:	f0 1f 00 12 	mcall	80000998 <xg_rtc_init+0x70>
	  // Enable the interrupts
	  rtc_enable_interrupt(&AVR32_RTC);
80000954:	fe 7c 0d 00 	mov	r12,-62208
80000958:	f0 1f 00 11 	mcall	8000099c <xg_rtc_init+0x74>
	  // Enable the RTC
	  rtc_enable(&AVR32_RTC);
8000095c:	fe 7c 0d 00 	mov	r12,-62208
80000960:	f0 1f 00 10 	mcall	800009a0 <xg_rtc_init+0x78>

	Current_time.Year		= 16;
80000964:	49 08       	lddpc	r8,800009a4 <xg_rtc_init+0x7c>
80000966:	31 09       	mov	r9,16
80000968:	b0 89       	st.b	r8[0x0],r9
	Current_time.Month		= 2;
8000096a:	30 29       	mov	r9,2
8000096c:	b0 99       	st.b	r8[0x1],r9
	Current_time.Day		= 29;
8000096e:	31 d9       	mov	r9,29
80000970:	b0 a9       	st.b	r8[0x2],r9
	Current_time.Hour		= 23;
80000972:	31 79       	mov	r9,23
80000974:	b0 b9       	st.b	r8[0x3],r9
	Current_time.Minute		= 59;
80000976:	33 b9       	mov	r9,59
80000978:	b0 c9       	st.b	r8[0x4],r9
	Current_time.Second		= 40;
8000097a:	32 89       	mov	r9,40
8000097c:	b0 d9       	st.b	r8[0x5],r9
	/*finished accessing the shared resource.Release the semaphore.*/
	//xSemaphoreGive(rtc_mutex);
	
	//sec = Current_time.Second;
	// Enable global interrupts
	Enable_global_interrupt();
8000097e:	d5 03       	csrf	0x10
	  
	//RTC_Test();	

}
80000980:	d8 02       	popm	pc
80000982:	00 00       	add	r0,r0
80000984:	80 00       	ld.sh	r0,r0[0x0]
80000986:	09 a8       	ld.ub	r8,r4[0x2]
80000988:	80 00       	ld.sh	r0,r0[0x0]
8000098a:	38 18       	mov	r8,-127
8000098c:	80 00       	ld.sh	r0,r0[0x0]
8000098e:	3a 14       	mov	r4,-95
80000990:	80 00       	ld.sh	r0,r0[0x0]
80000992:	b8 cc       	st.b	r12[0x4],r12
80000994:	80 00       	ld.sh	r0,r0[0x0]
80000996:	52 08       	stdsp	sp[0x80],r8
80000998:	80 00       	ld.sh	r0,r0[0x0]
8000099a:	39 d0       	mov	r0,-99
8000099c:	80 00       	ld.sh	r0,r0[0x0]
8000099e:	39 c8       	mov	r8,-100
800009a0:	80 00       	ld.sh	r0,r0[0x0]
800009a2:	39 a4       	mov	r4,-102
800009a4:	00 00       	add	r0,r0
800009a6:	0d a4       	ld.ub	r4,r6[0x2]

800009a8 <rtc_irq>:
/* RTC Interrupt  */
#pragma handler = AVR32_RTC_IRQ_GROUP, 1
__interrupt
#endif
void rtc_irq(void)
{
800009a8:	d4 01       	pushm	lr
	U8 T,K;
	U32 T16,K16;
	// Increment the minutes counter
	//sec++;
	
	Current_time.Second++;
800009aa:	4b 98       	lddpc	r8,80000a8c <rtc_irq+0xe4>
800009ac:	11 d9       	ld.ub	r9,r8[0x5]
800009ae:	2f f9       	sub	r9,-1
800009b0:	b0 d9       	st.b	r8[0x5],r9
	if(Current_time.Second>=60)
800009b2:	11 d9       	ld.ub	r9,r8[0x5]
800009b4:	33 b8       	mov	r8,59
800009b6:	f0 09 18 00 	cp.b	r9,r8
800009ba:	e0 88 00 5f 	brls	80000a78 <rtc_irq+0xd0>
	{
		Current_time.Second =0;
800009be:	4b 48       	lddpc	r8,80000a8c <rtc_irq+0xe4>
800009c0:	30 09       	mov	r9,0
800009c2:	b0 d9       	st.b	r8[0x5],r9
		Current_time.Minute++;
800009c4:	11 c9       	ld.ub	r9,r8[0x4]
800009c6:	2f f9       	sub	r9,-1
800009c8:	b0 c9       	st.b	r8[0x4],r9
		if(Current_time.Minute>=60)
800009ca:	11 c9       	ld.ub	r9,r8[0x4]
800009cc:	33 b8       	mov	r8,59
800009ce:	f0 09 18 00 	cp.b	r9,r8
800009d2:	e0 88 00 53 	brls	80000a78 <rtc_irq+0xd0>
		{
			Current_time.Minute=0;
800009d6:	4a e8       	lddpc	r8,80000a8c <rtc_irq+0xe4>
800009d8:	30 09       	mov	r9,0
800009da:	b0 c9       	st.b	r8[0x4],r9
			Current_time.Hour++;
800009dc:	11 b9       	ld.ub	r9,r8[0x3]
800009de:	2f f9       	sub	r9,-1
800009e0:	b0 b9       	st.b	r8[0x3],r9
			if (Current_time.Hour>=24)
800009e2:	11 b9       	ld.ub	r9,r8[0x3]
800009e4:	31 78       	mov	r8,23
800009e6:	f0 09 18 00 	cp.b	r9,r8
800009ea:	e0 88 00 47 	brls	80000a78 <rtc_irq+0xd0>
			{
				Current_time.Hour=0;
800009ee:	4a 88       	lddpc	r8,80000a8c <rtc_irq+0xe4>
800009f0:	30 09       	mov	r9,0
800009f2:	b0 b9       	st.b	r8[0x3],r9
				K16=(Current_time.Year&0x03)?365:366;				//判断当年是否为闰年,并获取当年的总天数（此算法时间起点为2000年）
800009f4:	11 88       	ld.ub	r8,r8[0x0]
800009f6:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800009fa:	e0 69 01 6e 	mov	r9,366
800009fe:	e0 6a 01 6d 	mov	r10,365
80000a02:	f4 08 17 10 	movne	r8,r10
80000a06:	f2 08 17 00 	moveq	r8,r9
				K16-=337;											//计算当年二月份天数
				//统计当月天数				
				K=(Current_time.Month==2)?K16:(((Current_time.Month+(Current_time.Month>>3))&0x01)+30);			
80000a0a:	4a 19       	lddpc	r9,80000a8c <rtc_irq+0xe4>
80000a0c:	13 9a       	ld.ub	r10,r9[0x1]
80000a0e:	30 29       	mov	r9,2
80000a10:	f2 0a 18 00 	cp.b	r10,r9
80000a14:	c0 b0       	breq	80000a2a <rtc_irq+0x82>
80000a16:	49 e8       	lddpc	r8,80000a8c <rtc_irq+0xe4>
80000a18:	11 99       	ld.ub	r9,r8[0x1]
80000a1a:	11 9a       	ld.ub	r10,r8[0x1]
80000a1c:	a3 9a       	lsr	r10,0x3
80000a1e:	12 0a       	add	r10,r9
80000a20:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80000a24:	2e 2a       	sub	r10,-30
80000a26:	5c 5a       	castu.b	r10
80000a28:	c0 58       	rjmp	80000a32 <rtc_irq+0x8a>
80000a2a:	f0 c8 01 51 	sub	r8,r8,337
80000a2e:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
				Current_time.Day++;
80000a32:	49 78       	lddpc	r8,80000a8c <rtc_irq+0xe4>
80000a34:	11 a9       	ld.ub	r9,r8[0x2]
80000a36:	2f f9       	sub	r9,-1
80000a38:	b0 a9       	st.b	r8[0x2],r9
				if(Current_time.Day>K)
80000a3a:	11 a8       	ld.ub	r8,r8[0x2]
80000a3c:	f0 0a 18 00 	cp.b	r10,r8
80000a40:	c1 c2       	brcc	80000a78 <rtc_irq+0xd0>
				{	
					Current_time.Day = 1;//重置到下月1号
80000a42:	49 38       	lddpc	r8,80000a8c <rtc_irq+0xe4>
80000a44:	30 19       	mov	r9,1
80000a46:	b0 a9       	st.b	r8[0x2],r9
					Current_time.Month++;
80000a48:	11 99       	ld.ub	r9,r8[0x1]
80000a4a:	2f f9       	sub	r9,-1
80000a4c:	b0 99       	st.b	r8[0x1],r9
					if(Current_time.Month>12)
80000a4e:	11 99       	ld.ub	r9,r8[0x1]
80000a50:	30 c8       	mov	r8,12
80000a52:	f0 09 18 00 	cp.b	r9,r8
80000a56:	e0 88 00 11 	brls	80000a78 <rtc_irq+0xd0>
					{
						Current_time.Month = 1;//重置到下一年的第一个月
80000a5a:	48 d8       	lddpc	r8,80000a8c <rtc_irq+0xe4>
80000a5c:	30 19       	mov	r9,1
80000a5e:	b0 99       	st.b	r8[0x1],r9
						Current_time.Year++;
80000a60:	11 89       	ld.ub	r9,r8[0x0]
80000a62:	2f f9       	sub	r9,-1
80000a64:	b0 89       	st.b	r8[0x0],r9
						if (Current_time.Year>150)Current_time.Year=0;//重置年份											
80000a66:	11 89       	ld.ub	r9,r8[0x0]
80000a68:	39 68       	mov	r8,-106
80000a6a:	f0 09 18 00 	cp.b	r9,r8
80000a6e:	e0 88 00 05 	brls	80000a78 <rtc_irq+0xd0>
80000a72:	30 09       	mov	r9,0
80000a74:	48 68       	lddpc	r8,80000a8c <rtc_irq+0xe4>
80000a76:	b0 89       	st.b	r8[0x0],r9
	}
	
	//Time_scale++;

	// clear the interrupt flag
	rtc_clear_interrupt(&AVR32_RTC);
80000a78:	fe 7c 0d 00 	mov	r12,-62208
80000a7c:	f0 1f 00 05 	mcall	80000a90 <rtc_irq+0xe8>

	// specify that an interrupt has been raised
	print_sec = 1;
80000a80:	30 19       	mov	r9,1
80000a82:	48 58       	lddpc	r8,80000a94 <rtc_irq+0xec>
80000a84:	91 09       	st.w	r8[0x0],r9
}
80000a86:	d4 02       	popm	lr
80000a88:	d6 03       	rete
80000a8a:	00 00       	add	r0,r0
80000a8c:	00 00       	add	r0,r0
80000a8e:	0d a4       	ld.ub	r4,r6[0x2]
80000a90:	80 00       	ld.sh	r0,r0[0x0]
80000a92:	39 f4       	mov	r4,-97
80000a94:	00 00       	add	r0,r0
80000a96:	04 f0       	st.b	--r2,r0

80000a98 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80000a98:	20 1c       	sub	r12,1
80000a9a:	5c 5c       	castu.b	r12
80000a9c:	31 18       	mov	r8,17
80000a9e:	f0 0c 18 00 	cp.b	r12,r8
80000aa2:	e0 88 00 03 	brls	80000aa8 <CalculateBurst+0x10>
80000aa6:	5e fd       	retal	0
80000aa8:	48 28       	lddpc	r8,80000ab0 <CalculateBurst+0x18>
80000aaa:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80000aae:	5e fc       	retal	r12
80000ab0:	80 00       	ld.sh	r0,r0[0x0]
80000ab2:	b8 ec       	st.b	r12[0x6],r12

80000ab4 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80000ab4:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
80000ab6:	48 98       	lddpc	r8,80000ad8 <payload_init+0x24>
80000ab8:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80000aba:	48 98       	lddpc	r8,80000adc <payload_init+0x28>
80000abc:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80000abe:	30 09       	mov	r9,0
80000ac0:	1a d9       	st.w	--sp,r9
80000ac2:	1a d9       	st.w	--sp,r9
80000ac4:	1a d9       	st.w	--sp,r9
80000ac6:	30 28       	mov	r8,2
80000ac8:	e0 6a 04 00 	mov	r10,1024
80000acc:	48 5b       	lddpc	r11,80000ae0 <payload_init+0x2c>
80000ace:	48 6c       	lddpc	r12,80000ae4 <payload_init+0x30>
80000ad0:	f0 1f 00 06 	mcall	80000ae8 <payload_init+0x34>
80000ad4:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
80000ad6:	d8 02       	popm	pc
80000ad8:	00 00       	add	r0,r0
80000ada:	0a 64       	and	r4,r5
80000adc:	00 00       	add	r0,r0
80000ade:	0a 68       	and	r8,r5
80000ae0:	80 00       	ld.sh	r0,r0[0x0]
80000ae2:	b9 34       	mul	r4,r12
80000ae4:	80 00       	ld.sh	r0,r0[0x0]
80000ae6:	0a ec       	st.h	--r5,r12
80000ae8:	80 00       	ld.sh	r0,r0[0x0]
80000aea:	4e 44       	lddpc	r4,80000c78 <phy_tx_func+0x48>

80000aec <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80000aec:	eb cd 40 f8 	pushm	r3-r7,lr
80000af0:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80000af2:	48 e8       	lddpc	r8,80000b28 <payload_rx_process+0x3c>
80000af4:	70 08       	ld.w	r8,r8[0x0]
80000af6:	58 08       	cp.w	r8,0
80000af8:	c0 71       	brne	80000b06 <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80000afa:	30 4b       	mov	r11,4
80000afc:	30 5c       	mov	r12,5
80000afe:	f0 1f 00 0c 	mcall	80000b2c <payload_rx_process+0x40>
80000b02:	48 a8       	lddpc	r8,80000b28 <payload_rx_process+0x3c>
80000b04:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80000b06:	48 96       	lddpc	r6,80000b28 <payload_rx_process+0x3c>
80000b08:	30 05       	mov	r5,0
80000b0a:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80000b0c:	48 93       	lddpc	r3,80000b30 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80000b0e:	6c 0c       	ld.w	r12,r6[0x0]
80000b10:	0a 99       	mov	r9,r5
80000b12:	08 9a       	mov	r10,r4
80000b14:	1a 9b       	mov	r11,sp
80000b16:	f0 1f 00 08 	mcall	80000b34 <payload_rx_process+0x48>
80000b1a:	58 1c       	cp.w	r12,1
80000b1c:	cf 91       	brne	80000b0e <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80000b1e:	66 08       	ld.w	r8,r3[0x0]
80000b20:	40 0c       	lddsp	r12,sp[0x0]
80000b22:	5d 18       	icall	r8
80000b24:	cf 5b       	rjmp	80000b0e <payload_rx_process+0x22>
80000b26:	00 00       	add	r0,r0
80000b28:	00 00       	add	r0,r0
80000b2a:	0a 98       	mov	r8,r5
80000b2c:	80 00       	ld.sh	r0,r0[0x0]
80000b2e:	47 28       	lddsp	r8,sp[0x1c8]
80000b30:	00 00       	add	r0,r0
80000b32:	0a 64       	and	r4,r5
80000b34:	80 00       	ld.sh	r0,r0[0x0]
80000b36:	44 1c       	lddsp	r12,sp[0x104]

80000b38 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80000b38:	d4 01       	pushm	lr
80000b3a:	20 2d       	sub	sp,8
80000b3c:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80000b3e:	30 09       	mov	r9,0
80000b40:	fa ca ff f8 	sub	r10,sp,-8
80000b44:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80000b46:	1a 9b       	mov	r11,sp
80000b48:	f0 1f 00 02 	mcall	80000b50 <set_idle_store_isr+0x18>
}
80000b4c:	2f ed       	sub	sp,-8
80000b4e:	d8 02       	popm	pc
80000b50:	80 00       	ld.sh	r0,r0[0x0]
80000b52:	45 d8       	lddsp	r8,sp[0x174]

80000b54 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80000b54:	d4 01       	pushm	lr
80000b56:	20 2d       	sub	sp,8
80000b58:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80000b5a:	58 0c       	cp.w	r12,0
80000b5c:	c1 10       	breq	80000b7e <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80000b5e:	30 08       	mov	r8,0
80000b60:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80000b62:	98 88       	ld.uh	r8,r12[0x0]
80000b64:	e2 18 f0 00 	andl	r8,0xf000,COH
80000b68:	e0 48 40 00 	cp.w	r8,16384
80000b6c:	c0 91       	brne	80000b7e <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80000b6e:	48 68       	lddpc	r8,80000b84 <phy_rx+0x30>
80000b70:	70 0c       	ld.w	r12,r8[0x0]
80000b72:	30 09       	mov	r9,0
80000b74:	fa ca ff fc 	sub	r10,sp,-4
80000b78:	1a 9b       	mov	r11,sp
80000b7a:	f0 1f 00 04 	mcall	80000b88 <phy_rx+0x34>
		}	

    }
		
 
}
80000b7e:	2f ed       	sub	sp,-8
80000b80:	d8 02       	popm	pc
80000b82:	00 00       	add	r0,r0
80000b84:	00 00       	add	r0,r0
80000b86:	0a b0       	st.h	r5++,r0
80000b88:	80 00       	ld.sh	r0,r0[0x0]
80000b8a:	45 d8       	lddsp	r8,sp[0x174]

80000b8c <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80000b8c:	eb cd 40 80 	pushm	r7,lr
80000b90:	20 1d       	sub	sp,4
80000b92:	fa c7 ff fc 	sub	r7,sp,-4
80000b96:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80000b98:	30 09       	mov	r9,0
80000b9a:	12 9a       	mov	r10,r9
80000b9c:	1a 9b       	mov	r11,sp
80000b9e:	f0 1f 00 03 	mcall	80000ba8 <set_idle_store+0x1c>
}
80000ba2:	2f fd       	sub	sp,-4
80000ba4:	e3 cd 80 80 	ldm	sp++,r7,pc
80000ba8:	80 00       	ld.sh	r0,r0[0x0]
80000baa:	46 28       	lddsp	r8,sp[0x188]

80000bac <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80000bac:	d4 01       	pushm	lr
80000bae:	20 1d       	sub	sp,4
80000bb0:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80000bb2:	98 88       	ld.uh	r8,r12[0x0]
80000bb4:	e2 18 f0 00 	andl	r8,0xf000,COH
80000bb8:	e0 48 40 00 	cp.w	r8,16384
80000bbc:	c0 d1       	brne	80000bd6 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80000bbe:	49 08       	lddpc	r8,80000bfc <phy_tx+0x50>
80000bc0:	70 08       	ld.w	r8,r8[0x0]
80000bc2:	58 08       	cp.w	r8,0
80000bc4:	c1 a0       	breq	80000bf8 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80000bc6:	48 e8       	lddpc	r8,80000bfc <phy_tx+0x50>
80000bc8:	70 0c       	ld.w	r12,r8[0x0]
80000bca:	30 09       	mov	r9,0
80000bcc:	12 9a       	mov	r10,r9
80000bce:	1a 9b       	mov	r11,sp
80000bd0:	f0 1f 00 0c 	mcall	80000c00 <phy_tx+0x54>
80000bd4:	c1 28       	rjmp	80000bf8 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80000bd6:	e0 48 10 00 	cp.w	r8,4096
80000bda:	5f 0a       	sreq	r10
80000bdc:	e0 48 20 00 	cp.w	r8,8192
80000be0:	5f 09       	sreq	r9
80000be2:	f5 e9 10 09 	or	r9,r10,r9
80000be6:	c0 71       	brne	80000bf4 <phy_tx+0x48>
80000be8:	e0 48 50 00 	cp.w	r8,20480
80000bec:	c0 40       	breq	80000bf4 <phy_tx+0x48>
80000bee:	e0 48 60 00 	cp.w	r8,24576
80000bf2:	c0 31       	brne	80000bf8 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80000bf4:	48 48       	lddpc	r8,80000c04 <phy_tx+0x58>
80000bf6:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80000bf8:	2f fd       	sub	sp,-4
80000bfa:	d8 02       	popm	pc
80000bfc:	00 00       	add	r0,r0
80000bfe:	0a d4       	st.w	--r5,r4
80000c00:	80 00       	ld.sh	r0,r0[0x0]
80000c02:	46 28       	lddsp	r8,sp[0x188]
80000c04:	00 00       	add	r0,r0
80000c06:	0a c4       	st.b	r5++,r4

80000c08 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80000c08:	d4 01       	pushm	lr
80000c0a:	20 2d       	sub	sp,8
	void * ptr = NULL;
80000c0c:	30 08       	mov	r8,0
80000c0e:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80000c10:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80000c12:	1a 9a       	mov	r10,sp
80000c14:	fa cb ff fc 	sub	r11,sp,-4
80000c18:	f0 1f 00 05 	mcall	80000c2c <get_idle_store_isr+0x24>
80000c1c:	58 1c       	cp.w	r12,1
80000c1e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80000c22:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80000c26:	2f ed       	sub	sp,-8
80000c28:	d8 02       	popm	pc
80000c2a:	00 00       	add	r0,r0
80000c2c:	80 00       	ld.sh	r0,r0[0x0]
80000c2e:	43 2c       	lddsp	r12,sp[0xc8]

80000c30 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80000c30:	eb cd 40 c0 	pushm	r6-r7,lr
80000c34:	20 1d       	sub	sp,4
80000c36:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80000c38:	4b a8       	lddpc	r8,80000d20 <phy_tx_func+0xf0>
80000c3a:	70 08       	ld.w	r8,r8[0x0]
80000c3c:	58 08       	cp.w	r8,0
80000c3e:	c6 60       	breq	80000d0a <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80000c40:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80000c42:	30 08       	mov	r8,0
80000c44:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80000c46:	4b 88       	lddpc	r8,80000d24 <phy_tx_func+0xf4>
80000c48:	70 08       	ld.w	r8,r8[0x0]
80000c4a:	58 18       	cp.w	r8,1
80000c4c:	c2 60       	breq	80000c98 <phy_tx_func+0x68>
80000c4e:	c0 43       	brcs	80000c56 <phy_tx_func+0x26>
80000c50:	58 28       	cp.w	r8,2
80000c52:	c5 c1       	brne	80000d0a <phy_tx_func+0xda>
80000c54:	c5 58       	rjmp	80000cfe <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80000c56:	4b 38       	lddpc	r8,80000d20 <phy_tx_func+0xf0>
80000c58:	70 0c       	ld.w	r12,r8[0x0]
80000c5a:	1a 9a       	mov	r10,sp
80000c5c:	4b 3b       	lddpc	r11,80000d28 <phy_tx_func+0xf8>
80000c5e:	f0 1f 00 34 	mcall	80000d2c <phy_tx_func+0xfc>
80000c62:	58 1c       	cp.w	r12,1
80000c64:	c1 41       	brne	80000c8c <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80000c66:	4b 18       	lddpc	r8,80000d28 <phy_tx_func+0xf8>
80000c68:	70 08       	ld.w	r8,r8[0x0]
80000c6a:	90 08       	ld.sh	r8,r8[0x0]
80000c6c:	10 9a       	mov	r10,r8
80000c6e:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80000c72:	4b 09       	lddpc	r9,80000d30 <phy_tx_func+0x100>
80000c74:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80000c76:	5c 78       	castu.h	r8
80000c78:	ea 18 ab cd 	orh	r8,0xabcd
80000c7c:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80000c7e:	30 19       	mov	r9,1
80000c80:	4a d8       	lddpc	r8,80000d34 <phy_tx_func+0x104>
80000c82:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80000c84:	30 19       	mov	r9,1
80000c86:	4a 88       	lddpc	r8,80000d24 <phy_tx_func+0xf4>
80000c88:	91 09       	st.w	r8[0x0],r9
80000c8a:	c4 08       	rjmp	80000d0a <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80000c8c:	e0 68 5a 5a 	mov	r8,23130
80000c90:	ea 18 ab cd 	orh	r8,0xabcd
80000c94:	8f 18       	st.w	r7[0x4],r8
80000c96:	c3 a8       	rjmp	80000d0a <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80000c98:	4a 7a       	lddpc	r10,80000d34 <phy_tx_func+0x104>
80000c9a:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80000c9c:	4a 39       	lddpc	r9,80000d28 <phy_tx_func+0xf8>
80000c9e:	72 09       	ld.w	r9,r9[0x0]
80000ca0:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80000ca4:	b1 69       	lsl	r9,0x10
80000ca6:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80000ca8:	2f f8       	sub	r8,-1
80000caa:	5c 58       	castu.b	r8
80000cac:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80000cae:	4a 1b       	lddpc	r11,80000d30 <phy_tx_func+0x100>
80000cb0:	96 0c       	ld.sh	r12,r11[0x0]
80000cb2:	20 2c       	sub	r12,2
80000cb4:	5c 8c       	casts.h	r12
80000cb6:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80000cba:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80000cbc:	30 0b       	mov	r11,0
80000cbe:	f6 0a 19 00 	cp.h	r10,r11
80000cc2:	e0 89 00 09 	brgt	80000cd4 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80000cc6:	e8 19 00 ba 	orl	r9,0xba
80000cca:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80000ccc:	30 09       	mov	r9,0
80000cce:	49 68       	lddpc	r8,80000d24 <phy_tx_func+0xf4>
80000cd0:	91 09       	st.w	r8[0x0],r9
80000cd2:	c1 c8       	rjmp	80000d0a <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80000cd4:	49 5a       	lddpc	r10,80000d28 <phy_tx_func+0xf8>
80000cd6:	74 0a       	ld.w	r10,r10[0x0]
80000cd8:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80000cdc:	14 49       	or	r9,r10
80000cde:	8f 19       	st.w	r7[0x4],r9
80000ce0:	2f f8       	sub	r8,-1
80000ce2:	49 59       	lddpc	r9,80000d34 <phy_tx_func+0x104>
80000ce4:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80000ce6:	20 2c       	sub	r12,2
80000ce8:	49 28       	lddpc	r8,80000d30 <phy_tx_func+0x100>
80000cea:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80000cec:	30 08       	mov	r8,0
80000cee:	f0 0c 19 00 	cp.h	r12,r8
80000cf2:	e0 89 00 0c 	brgt	80000d0a <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80000cf6:	30 29       	mov	r9,2
80000cf8:	48 b8       	lddpc	r8,80000d24 <phy_tx_func+0xf4>
80000cfa:	91 09       	st.w	r8[0x0],r9
80000cfc:	c0 78       	rjmp	80000d0a <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80000cfe:	fc 18 00 ba 	movh	r8,0xba
80000d02:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80000d04:	30 09       	mov	r9,0
80000d06:	48 88       	lddpc	r8,80000d24 <phy_tx_func+0xf4>
80000d08:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80000d0a:	e0 68 5a 5a 	mov	r8,23130
80000d0e:	ea 18 ab cd 	orh	r8,0xabcd
80000d12:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80000d14:	30 08       	mov	r8,0
80000d16:	8f 38       	st.w	r7[0xc],r8
}
80000d18:	2f fd       	sub	sp,-4
80000d1a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80000d1e:	00 00       	add	r0,r0
80000d20:	00 00       	add	r0,r0
80000d22:	0a d4       	st.w	--r5,r4
80000d24:	00 00       	add	r0,r0
80000d26:	0a 8c       	andn	r12,r5
80000d28:	00 00       	add	r0,r0
80000d2a:	0a e0       	st.h	--r5,r0
80000d2c:	80 00       	ld.sh	r0,r0[0x0]
80000d2e:	43 2c       	lddsp	r12,sp[0xc8]
80000d30:	00 00       	add	r0,r0
80000d32:	0a b4       	st.h	r5++,r4
80000d34:	00 00       	add	r0,r0
80000d36:	0a 70       	tst	r0,r5

80000d38 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80000d38:	d4 01       	pushm	lr
80000d3a:	20 1d       	sub	sp,4
	void * ptr = NULL;
80000d3c:	30 0a       	mov	r10,0
80000d3e:	fa cb ff fc 	sub	r11,sp,-4
80000d42:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80000d44:	14 99       	mov	r9,r10
80000d46:	1a 9b       	mov	r11,sp
80000d48:	f0 1f 00 05 	mcall	80000d5c <get_idle_store+0x24>
80000d4c:	58 1c       	cp.w	r12,1
80000d4e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80000d52:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80000d56:	2f fd       	sub	sp,-4
80000d58:	d8 02       	popm	pc
80000d5a:	00 00       	add	r0,r0
80000d5c:	80 00       	ld.sh	r0,r0[0x0]
80000d5e:	44 1c       	lddsp	r12,sp[0x104]

80000d60 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80000d60:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80000d62:	48 5b       	lddpc	r11,80000d74 <phy_init+0x14>
80000d64:	48 5c       	lddpc	r12,80000d78 <phy_init+0x18>
80000d66:	f0 1f 00 06 	mcall	80000d7c <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80000d6a:	f0 1f 00 06 	mcall	80000d80 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80000d6e:	f0 1f 00 06 	mcall	80000d84 <phy_init+0x24>
	
}
80000d72:	d8 02       	popm	pc
80000d74:	80 00       	ld.sh	r0,r0[0x0]
80000d76:	0c 30       	cp.w	r0,r6
80000d78:	80 00       	ld.sh	r0,r0[0x0]
80000d7a:	0d e8       	ld.ub	r8,r6[0x6]
80000d7c:	80 00       	ld.sh	r0,r0[0x0]
80000d7e:	1e 30       	cp.w	r0,pc
80000d80:	80 00       	ld.sh	r0,r0[0x0]
80000d82:	1e 44       	or	r4,pc
80000d84:	80 00       	ld.sh	r0,r0[0x0]
80000d86:	27 ec       	sub	r12,126

80000d88 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80000d88:	d4 01       	pushm	lr
80000d8a:	20 2d       	sub	sp,8
80000d8c:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80000d8e:	30 08       	mov	r8,0
80000d90:	50 18       	stdsp	sp[0x4],r8
	
	if(NULL == phy_payload_frame_rx)
80000d92:	48 f8       	lddpc	r8,80000dcc <payload_rx+0x44>
80000d94:	70 08       	ld.w	r8,r8[0x0]
80000d96:	58 08       	cp.w	r8,0
80000d98:	c0 71       	brne	80000da6 <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80000d9a:	30 4b       	mov	r11,4
80000d9c:	30 5c       	mov	r12,5
80000d9e:	f0 1f 00 0d 	mcall	80000dd0 <payload_rx+0x48>
80000da2:	48 b8       	lddpc	r8,80000dcc <payload_rx+0x44>
80000da4:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
80000da6:	48 a8       	lddpc	r8,80000dcc <payload_rx+0x44>
80000da8:	70 0c       	ld.w	r12,r8[0x0]
80000daa:	30 09       	mov	r9,0
80000dac:	fa ca ff fc 	sub	r10,sp,-4
80000db0:	1a 9b       	mov	r11,sp
80000db2:	f0 1f 00 09 	mcall	80000dd4 <payload_rx+0x4c>
80000db6:	c0 91       	brne	80000dc8 <payload_rx+0x40>
	{
		
		set_payload_idle_isr(payload);
80000db8:	48 88       	lddpc	r8,80000dd8 <payload_rx+0x50>
80000dba:	70 0c       	ld.w	r12,r8[0x0]
80000dbc:	40 0b       	lddsp	r11,sp[0x0]
80000dbe:	f0 1f 00 08 	mcall	80000ddc <payload_rx+0x54>
		logFromISR("mm");
80000dc2:	48 8c       	lddpc	r12,80000de0 <payload_rx+0x58>
80000dc4:	f0 1f 00 08 	mcall	80000de4 <payload_rx+0x5c>
	}
	else
	{
		//logFromISR("ss");
	}
}
80000dc8:	2f ed       	sub	sp,-8
80000dca:	d8 02       	popm	pc
80000dcc:	00 00       	add	r0,r0
80000dce:	0a 98       	mov	r8,r5
80000dd0:	80 00       	ld.sh	r0,r0[0x0]
80000dd2:	47 28       	lddsp	r8,sp[0x1c8]
80000dd4:	80 00       	ld.sh	r0,r0[0x0]
80000dd6:	45 d8       	lddsp	r8,sp[0x174]
80000dd8:	00 00       	add	r0,r0
80000dda:	0a a4       	st.w	r5++,r4
80000ddc:	80 00       	ld.sh	r0,r0[0x0]
80000dde:	0b 38       	ld.ub	r8,r5++
80000de0:	80 00       	ld.sh	r0,r0[0x0]
80000de2:	b9 40       	asr	r0,0x18
80000de4:	80 00       	ld.sh	r0,r0[0x0]
80000de6:	53 94       	stdsp	sp[0xe4],r4

80000de8 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80000de8:	eb cd 40 e0 	pushm	r5-r7,lr
80000dec:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80000dee:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80000df2:	70 08       	ld.w	r8,r8[0x0]
80000df4:	58 08       	cp.w	r8,0
80000df6:	e0 80 01 08 	breq	80001006 <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80000dfa:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80000dfc:	fe f8 0e 70 	ld.w	r8,pc[3696]
80000e00:	70 09       	ld.w	r9,r8[0x0]
80000e02:	2f f9       	sub	r9,-1
80000e04:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80000e06:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80000e0a:	70 08       	ld.w	r8,r8[0x0]
80000e0c:	58 18       	cp.w	r8,1
80000e0e:	e0 80 00 85 	breq	80000f18 <phy_rx_func+0x130>
80000e12:	c0 73       	brcs	80000e20 <phy_rx_func+0x38>
80000e14:	58 28       	cp.w	r8,2
80000e16:	c5 c0       	breq	80000ece <phy_rx_func+0xe6>
80000e18:	58 38       	cp.w	r8,3
80000e1a:	e0 81 00 f6 	brne	80001006 <phy_rx_func+0x21e>
80000e1e:	cd 58       	rjmp	80000fc8 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80000e20:	e0 6a 5a 5a 	mov	r10,23130
80000e24:	ea 1a ab cd 	orh	r10,0xabcd
80000e28:	14 36       	cp.w	r6,r10
80000e2a:	e0 80 00 ee 	breq	80001006 <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80000e2e:	ec 08 16 10 	lsr	r8,r6,0x10
80000e32:	e0 48 ab cd 	cp.w	r8,43981
80000e36:	e0 81 00 e8 	brne	80001006 <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80000e3a:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80000e3e:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80000e42:	20 28       	sub	r8,2
80000e44:	fe f9 0e 30 	ld.w	r9,pc[3632]
80000e48:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80000e4a:	30 09       	mov	r9,0
80000e4c:	f2 08 19 00 	cp.h	r8,r9
80000e50:	e0 8a 00 db 	brle	80001006 <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80000e54:	fe f8 0e 24 	ld.w	r8,pc[3620]
80000e58:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80000e5a:	fe f8 0e 22 	ld.w	r8,pc[3618]
80000e5e:	70 0c       	ld.w	r12,r8[0x0]
80000e60:	f0 1f 03 88 	mcall	80001c80 <phy_rx_func+0xe98>
80000e64:	fe f8 0e 20 	ld.w	r8,pc[3616]
80000e68:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80000e6a:	58 0c       	cp.w	r12,0
80000e6c:	e0 80 00 cd 	breq	80001006 <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80000e70:	fe f8 0e 08 	ld.w	r8,pc[3592]
80000e74:	90 09       	ld.sh	r9,r8[0x0]
80000e76:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80000e7a:	2f f9       	sub	r9,-1
80000e7c:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80000e7e:	fe fa 0e 06 	ld.w	r10,pc[3590]
80000e82:	74 0a       	ld.w	r10,r10[0x0]
80000e84:	fe fb 0d e8 	ld.w	r11,pc[3560]
80000e88:	76 0b       	ld.w	r11,r11[0x0]
80000e8a:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80000e8e:	2f f9       	sub	r9,-1
80000e90:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80000e92:	e2 16 0f 00 	andl	r6,0xf00,COH
80000e96:	e0 46 01 00 	cp.w	r6,256
80000e9a:	c0 c0       	breq	80000eb2 <phy_rx_func+0xca>
80000e9c:	e0 8b 00 05 	brhi	80000ea6 <phy_rx_func+0xbe>
80000ea0:	58 06       	cp.w	r6,0
80000ea2:	c0 80       	breq	80000eb2 <phy_rx_func+0xca>
80000ea4:	c0 c8       	rjmp	80000ebc <phy_rx_func+0xd4>
80000ea6:	e0 46 02 00 	cp.w	r6,512
80000eaa:	c0 40       	breq	80000eb2 <phy_rx_func+0xca>
80000eac:	e0 46 03 00 	cp.w	r6,768
80000eb0:	c0 61       	brne	80000ebc <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80000eb2:	30 29       	mov	r9,2
80000eb4:	fe f8 0d bc 	ld.w	r8,pc[3516]
80000eb8:	91 09       	st.w	r8[0x0],r9
80000eba:	ca 68       	rjmp	80001006 <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80000ebc:	fe f8 0d c0 	ld.w	r8,pc[3520]
80000ec0:	70 0c       	ld.w	r12,r8[0x0]
80000ec2:	fe f8 0d c2 	ld.w	r8,pc[3522]
80000ec6:	70 0b       	ld.w	r11,r8[0x0]
80000ec8:	f0 1f 03 70 	mcall	80001c88 <phy_rx_func+0xea0>
80000ecc:	c9 d8       	rjmp	80001006 <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80000ece:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80000ed2:	b1 86       	lsr	r6,0x10
80000ed4:	14 06       	add	r6,r10
80000ed6:	fe f8 0d b6 	ld.w	r8,pc[3510]
80000eda:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80000edc:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80000ee0:	90 09       	ld.sh	r9,r8[0x0]
80000ee2:	fe fb 0d a2 	ld.w	r11,pc[3490]
80000ee6:	76 0b       	ld.w	r11,r11[0x0]
80000ee8:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80000eec:	2f f9       	sub	r9,-1
80000eee:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80000ef0:	fe f9 0d 84 	ld.w	r9,pc[3460]
80000ef4:	92 08       	ld.sh	r8,r9[0x0]
80000ef6:	20 28       	sub	r8,2
80000ef8:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80000efa:	30 09       	mov	r9,0
80000efc:	f2 08 19 00 	cp.h	r8,r9
80000f00:	e0 8a 00 07 	brle	80000f0e <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80000f04:	30 19       	mov	r9,1
80000f06:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80000f0a:	91 09       	st.w	r8[0x0],r9
80000f0c:	c7 d8       	rjmp	80001006 <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80000f0e:	30 39       	mov	r9,3
80000f10:	fe f8 0d 60 	ld.w	r8,pc[3424]
80000f14:	91 09       	st.w	r8[0x0],r9
80000f16:	c7 88       	rjmp	80001006 <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80000f18:	ec 0a 14 10 	asr	r10,r6,0x10
80000f1c:	fe f8 0d 70 	ld.w	r8,pc[3440]
80000f20:	90 09       	ld.sh	r9,r8[0x0]
80000f22:	14 09       	add	r9,r10
80000f24:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80000f26:	fe f9 0d 52 	ld.w	r9,pc[3410]
80000f2a:	92 08       	ld.sh	r8,r9[0x0]
80000f2c:	fe fb 0d 58 	ld.w	r11,pc[3416]
80000f30:	76 0b       	ld.w	r11,r11[0x0]
80000f32:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80000f36:	2f f8       	sub	r8,-1
80000f38:	5c 88       	casts.h	r8
80000f3a:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80000f3c:	fe fa 0d 38 	ld.w	r10,pc[3384]
80000f40:	94 09       	ld.sh	r9,r10[0x0]
80000f42:	20 29       	sub	r9,2
80000f44:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80000f46:	30 0a       	mov	r10,0
80000f48:	f4 09 19 00 	cp.h	r9,r10
80000f4c:	e0 89 00 20 	brgt	80000f8c <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80000f50:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80000f54:	e0 46 00 ba 	cp.w	r6,186
80000f58:	c0 d1       	brne	80000f72 <phy_rx_func+0x18a>
80000f5a:	fe f8 0d 32 	ld.w	r8,pc[3378]
80000f5e:	90 09       	ld.sh	r9,r8[0x0]
80000f60:	f4 09 19 00 	cp.h	r9,r10
80000f64:	c0 71       	brne	80000f72 <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80000f66:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80000f6a:	70 0c       	ld.w	r12,r8[0x0]
80000f6c:	f0 1f 03 49 	mcall	80001c90 <phy_rx_func+0xea8>
80000f70:	c0 98       	rjmp	80000f82 <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80000f72:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80000f76:	70 0c       	ld.w	r12,r8[0x0]
80000f78:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80000f7c:	70 0b       	ld.w	r11,r8[0x0]
80000f7e:	f0 1f 03 43 	mcall	80001c88 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80000f82:	30 09       	mov	r9,0
80000f84:	fe f8 0c ec 	ld.w	r8,pc[3308]
80000f88:	91 09       	st.w	r8[0x0],r9
80000f8a:	c3 e8       	rjmp	80001006 <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80000f8c:	5c 86       	casts.h	r6
80000f8e:	fe f9 0c fe 	ld.w	r9,pc[3326]
80000f92:	92 0a       	ld.sh	r10,r9[0x0]
80000f94:	0c 0a       	add	r10,r6
80000f96:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80000f98:	fe f9 0c ec 	ld.w	r9,pc[3308]
80000f9c:	72 09       	ld.w	r9,r9[0x0]
80000f9e:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80000fa2:	2f f8       	sub	r8,-1
80000fa4:	fe f9 0c d4 	ld.w	r9,pc[3284]
80000fa8:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80000faa:	fe f9 0c ca 	ld.w	r9,pc[3274]
80000fae:	92 08       	ld.sh	r8,r9[0x0]
80000fb0:	20 28       	sub	r8,2
80000fb2:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80000fb4:	30 09       	mov	r9,0
80000fb6:	f2 08 19 00 	cp.h	r8,r9
80000fba:	e0 89 00 26 	brgt	80001006 <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80000fbe:	30 39       	mov	r9,3
80000fc0:	fe f8 0c b0 	ld.w	r8,pc[3248]
80000fc4:	91 09       	st.w	r8[0x0],r9
80000fc6:	c2 08       	rjmp	80001006 <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80000fc8:	e6 16 00 ff 	andh	r6,0xff,COH
80000fcc:	fc 19 00 ba 	movh	r9,0xba
80000fd0:	12 36       	cp.w	r6,r9
80000fd2:	c0 e1       	brne	80000fee <phy_rx_func+0x206>
80000fd4:	fe f8 0c b8 	ld.w	r8,pc[3256]
80000fd8:	90 09       	ld.sh	r9,r8[0x0]
80000fda:	30 08       	mov	r8,0
80000fdc:	f0 09 19 00 	cp.h	r9,r8
80000fe0:	c0 71       	brne	80000fee <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80000fe2:	fe f8 0c a2 	ld.w	r8,pc[3234]
80000fe6:	70 0c       	ld.w	r12,r8[0x0]
80000fe8:	f0 1f 03 2a 	mcall	80001c90 <phy_rx_func+0xea8>
80000fec:	c0 98       	rjmp	80000ffe <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80000fee:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80000ff2:	70 0c       	ld.w	r12,r8[0x0]
80000ff4:	fe f8 0c 90 	ld.w	r8,pc[3216]
80000ff8:	70 0b       	ld.w	r11,r8[0x0]
80000ffa:	f0 1f 03 24 	mcall	80001c88 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80000ffe:	30 09       	mov	r9,0
80001000:	fe f8 0c 70 	ld.w	r8,pc[3184]
80001004:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80001006:	fe f8 0c 8e 	ld.w	r8,pc[3214]
8000100a:	11 89       	ld.ub	r9,r8[0x0]
8000100c:	30 08       	mov	r8,0
8000100e:	f0 09 18 00 	cp.b	r9,r8
80001012:	c1 31       	brne	80001038 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80001014:	fe f6 0c 84 	ld.w	r6,pc[3204]
80001018:	6c 0c       	ld.w	r12,r6[0x0]
8000101a:	f0 1f 03 1a 	mcall	80001c80 <phy_rx_func+0xe98>
8000101e:	fe f8 0c 7e 	ld.w	r8,pc[3198]
80001022:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80001024:	6c 0c       	ld.w	r12,r6[0x0]
80001026:	f0 1f 03 17 	mcall	80001c80 <phy_rx_func+0xe98>
8000102a:	fe f8 0c 76 	ld.w	r8,pc[3190]
8000102e:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80001030:	30 19       	mov	r9,1
80001032:	fe f8 0c 62 	ld.w	r8,pc[3170]
80001036:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80001038:	fe f8 0c 6c 	ld.w	r8,pc[3180]
8000103c:	70 08       	ld.w	r8,r8[0x0]
8000103e:	58 28       	cp.w	r8,2
80001040:	e0 80 01 98 	breq	80001370 <phy_rx_func+0x588>
80001044:	e0 8b 00 06 	brhi	80001050 <phy_rx_func+0x268>
80001048:	58 08       	cp.w	r8,0
8000104a:	c0 b0       	breq	80001060 <phy_rx_func+0x278>
8000104c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80001050:	58 38       	cp.w	r8,3
80001052:	e0 80 05 c5 	breq	80001bdc <phy_rx_func+0xdf4>
80001056:	58 48       	cp.w	r8,4
80001058:	e0 81 06 05 	brne	80001c62 <phy_rx_func+0xe7a>
8000105c:	e0 8f 02 4b 	bral	800014f2 <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80001060:	6e 28       	ld.w	r8,r7[0x8]
80001062:	e0 6a 5a 5a 	mov	r10,23130
80001066:	ea 1a ab cd 	orh	r10,0xabcd
8000106a:	14 38       	cp.w	r8,r10
8000106c:	c0 71       	brne	8000107a <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
8000106e:	30 09       	mov	r9,0
80001070:	fe f8 0c 38 	ld.w	r8,pc[3128]
80001074:	91 09       	st.w	r8[0x0],r9
80001076:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
8000107a:	10 99       	mov	r9,r8
8000107c:	e0 19 00 00 	andl	r9,0x0
80001080:	fc 1a ab cd 	movh	r10,0xabcd
80001084:	14 39       	cp.w	r9,r10
80001086:	e0 81 05 ee 	brne	80001c62 <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
8000108a:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
8000108e:	fe f9 0c 1e 	ld.w	r9,pc[3102]
80001092:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80001094:	6e 29       	ld.w	r9,r7[0x8]
80001096:	e2 19 f0 00 	andl	r9,0xf000,COH
8000109a:	e0 49 c0 00 	cp.w	r9,49152
8000109e:	e0 81 00 ce 	brne	8000123a <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
800010a2:	30 1a       	mov	r10,1
800010a4:	fe f9 0c 0c 	ld.w	r9,pc[3084]
800010a8:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
800010aa:	fe f9 0b f6 	ld.w	r9,pc[3062]
800010ae:	72 09       	ld.w	r9,r9[0x0]
800010b0:	58 09       	cp.w	r9,0
800010b2:	c0 71       	brne	800010c0 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800010b4:	fe fc 0c 00 	ld.w	r12,pc[3072]
800010b8:	f0 1f 03 00 	mcall	80001cb8 <phy_rx_func+0xed0>
800010bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
800010c0:	ef 3a 00 0d 	ld.ub	r10,r7[13]
800010c4:	fe f9 0b f8 	ld.w	r9,pc[3064]
800010c8:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
800010ca:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800010ce:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
800010d2:	fe fa 0b ee 	ld.w	r10,pc[3054]
800010d6:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
800010d8:	13 89       	ld.ub	r9,r9[0x0]
800010da:	37 fa       	mov	r10,127
800010dc:	f4 09 18 00 	cp.b	r9,r10
800010e0:	c6 d0       	breq	800011ba <phy_rx_func+0x3d2>
800010e2:	e0 8b 00 0c 	brhi	800010fa <phy_rx_func+0x312>
800010e6:	31 2a       	mov	r10,18
800010e8:	f4 09 18 00 	cp.b	r9,r10
800010ec:	c4 20       	breq	80001170 <phy_rx_func+0x388>
800010ee:	31 3a       	mov	r10,19
800010f0:	f4 09 18 00 	cp.b	r9,r10
800010f4:	e0 81 00 83 	brne	800011fa <phy_rx_func+0x412>
800010f8:	c5 b8       	rjmp	800011ae <phy_rx_func+0x3c6>
800010fa:	2f 09       	sub	r9,-16
800010fc:	30 1a       	mov	r10,1
800010fe:	f4 09 18 00 	cp.b	r9,r10
80001102:	e0 8b 00 7c 	brhi	800011fa <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80001106:	ef 38 00 0e 	ld.ub	r8,r7[14]
8000110a:	e2 18 00 f0 	andl	r8,0xf0,COH
8000110e:	59 08       	cp.w	r8,16
80001110:	c0 71       	brne	8000111e <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
80001112:	30 19       	mov	r9,1
80001114:	fe f8 0b 94 	ld.w	r8,pc[2964]
80001118:	91 09       	st.w	r8[0x0],r9
8000111a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
8000111e:	e0 48 00 20 	cp.w	r8,32
80001122:	c2 11       	brne	80001164 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80001124:	30 a9       	mov	r9,10
80001126:	fe f8 0b 82 	ld.w	r8,pc[2946]
8000112a:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
8000112c:	fe f6 0b 98 	ld.w	r6,pc[2968]
80001130:	6c 08       	ld.w	r8,r6[0x0]
80001132:	f0 0a 11 ff 	rsub	r10,r8,-1
80001136:	fe f7 0b 6a 	ld.w	r7,pc[2922]
8000113a:	2f f8       	sub	r8,-1
8000113c:	6e 0c       	ld.w	r12,r7[0x0]
8000113e:	f4 ca fe 00 	sub	r10,r10,-512
80001142:	30 0b       	mov	r11,0
80001144:	10 0c       	add	r12,r8
80001146:	f0 1f 02 e1 	mcall	80001cc8 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
8000114a:	30 08       	mov	r8,0
8000114c:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
8000114e:	6e 0c       	ld.w	r12,r7[0x0]
80001150:	f0 1f 02 df 	mcall	80001ccc <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80001154:	fe f8 0b 44 	ld.w	r8,pc[2884]
80001158:	70 0c       	ld.w	r12,r8[0x0]
8000115a:	f0 1f 02 ca 	mcall	80001c80 <phy_rx_func+0xe98>
8000115e:	8f 0c       	st.w	r7[0x0],r12
80001160:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80001164:	30 09       	mov	r9,0
80001166:	fe f8 0b 42 	ld.w	r8,pc[2882]
8000116a:	91 09       	st.w	r8[0x0],r9
8000116c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80001170:	20 48       	sub	r8,4
80001172:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80001176:	93 08       	st.w	r9[0x0],r8
80001178:	58 08       	cp.w	r8,0
8000117a:	e0 80 05 74 	breq	80001c62 <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
8000117e:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80001182:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80001186:	fe f8 0b 4a 	ld.w	r8,pc[2890]
8000118a:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
8000118c:	8e 69       	ld.sh	r9,r7[0xc]
8000118e:	fe f8 0b 46 	ld.w	r8,pc[2886]
80001192:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80001194:	8e 79       	ld.sh	r9,r7[0xe]
80001196:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80001198:	f0 1f 02 d0 	mcall	80001cd8 <phy_rx_func+0xef0>
8000119c:	fe f8 0b 0c 	ld.w	r8,pc[2828]
800011a0:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
800011a2:	30 49       	mov	r9,4
800011a4:	fe f8 0b 00 	ld.w	r8,pc[2816]
800011a8:	91 09       	st.w	r8[0x0],r9
800011aa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
800011ae:	30 09       	mov	r9,0
800011b0:	fe f8 0a f8 	ld.w	r8,pc[2808]
800011b4:	91 09       	st.w	r8[0x0],r9
800011b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800011ba:	20 48       	sub	r8,4
800011bc:	fe f9 0a f0 	ld.w	r9,pc[2800]
800011c0:	93 08       	st.w	r9[0x0],r8
800011c2:	58 08       	cp.w	r8,0
800011c4:	e0 80 05 4f 	breq	80001c62 <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
800011c8:	fe f8 0b 14 	ld.w	r8,pc[2836]
800011cc:	70 09       	ld.w	r9,r8[0x0]
800011ce:	8e 7b       	ld.sh	r11,r7[0xe]
800011d0:	fe fa 0b 10 	ld.w	r10,pc[2832]
800011d4:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
800011d8:	2f f9       	sub	r9,-1
800011da:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
800011dc:	fe f8 0a e4 	ld.w	r8,pc[2788]
800011e0:	70 09       	ld.w	r9,r8[0x0]
800011e2:	20 29       	sub	r9,2
800011e4:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
800011e6:	30 29       	mov	r9,2
800011e8:	fe f8 0a c0 	ld.w	r8,pc[2752]
800011ec:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
800011ee:	30 39       	mov	r9,3
800011f0:	fe f8 0a b4 	ld.w	r8,pc[2740]
800011f4:	91 09       	st.w	r8[0x0],r9
800011f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
800011fa:	30 3a       	mov	r10,3
800011fc:	fe f9 0a ac 	ld.w	r9,pc[2732]
80001200:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
80001202:	6e 2a       	ld.w	r10,r7[0x8]
80001204:	fe f9 0a e0 	ld.w	r9,pc[2784]
80001208:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
8000120a:	6e 3a       	ld.w	r10,r7[0xc]
8000120c:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
8000120e:	59 48       	cp.w	r8,20
80001210:	c0 61       	brne	8000121c <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80001212:	31 89       	mov	r9,24
80001214:	fe f8 0a 98 	ld.w	r8,pc[2712]
80001218:	91 09       	st.w	r8[0x0],r9
8000121a:	c0 a8       	rjmp	8000122e <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
8000121c:	fe f8 0a 90 	ld.w	r8,pc[2704]
80001220:	70 08       	ld.w	r8,r8[0x0]
80001222:	59 08       	cp.w	r8,16
80001224:	c0 51       	brne	8000122e <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80001226:	31 09       	mov	r9,16
80001228:	fe f8 0a 84 	ld.w	r8,pc[2692]
8000122c:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000122e:	30 49       	mov	r9,4
80001230:	fe f8 0a 74 	ld.w	r8,pc[2676]
80001234:	91 09       	st.w	r8[0x0],r9
80001236:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
8000123a:	e0 49 10 00 	cp.w	r9,4096
8000123e:	5f 1a       	srne	r10
80001240:	e0 49 20 00 	cp.w	r9,8192
80001244:	5f 19       	srne	r9
80001246:	f5 e9 00 09 	and	r9,r10,r9
8000124a:	e0 81 05 0c 	brne	80001c62 <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
8000124e:	fe fa 0a 9a 	ld.w	r10,pc[2714]
80001252:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80001254:	fe fa 0a 98 	ld.w	r10,pc[2712]
80001258:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
8000125a:	fe fa 0a 62 	ld.w	r10,pc[2658]
8000125e:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
80001260:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80001264:	72 09       	ld.w	r9,r9[0x0]
80001266:	58 09       	cp.w	r9,0
80001268:	c0 71       	brne	80001276 <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
8000126a:	fe fc 0a 4a 	ld.w	r12,pc[2634]
8000126e:	f0 1f 02 93 	mcall	80001cb8 <phy_rx_func+0xed0>
80001272:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80001276:	6e 2a       	ld.w	r10,r7[0x8]
80001278:	e2 1a 0f 00 	andl	r10,0xf00,COH
8000127c:	58 1a       	cp.w	r10,1
8000127e:	e0 8b 00 4d 	brhi	80001318 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
80001282:	20 48       	sub	r8,4
80001284:	fe f9 0a 28 	ld.w	r9,pc[2600]
80001288:	93 08       	st.w	r9[0x0],r8
8000128a:	58 08       	cp.w	r8,0
8000128c:	e0 80 04 eb 	breq	80001c62 <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
80001290:	8e 68       	ld.sh	r8,r7[0xc]
80001292:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80001296:	fe f9 0a 5a 	ld.w	r9,pc[2650]
8000129a:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
8000129c:	30 09       	mov	r9,0
8000129e:	f2 08 19 00 	cp.h	r8,r9
800012a2:	c0 70       	breq	800012b0 <phy_rx_func+0x4c8>
800012a4:	30 19       	mov	r9,1
800012a6:	f2 08 19 00 	cp.h	r8,r9
800012aa:	e0 81 04 dc 	brne	80001c62 <phy_rx_func+0xe7a>
800012ae:	c2 68       	rjmp	800012fa <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800012b0:	fe f8 0a 44 	ld.w	r8,pc[2628]
800012b4:	70 0a       	ld.w	r10,r8[0x0]
800012b6:	fe f9 09 e6 	ld.w	r9,pc[2534]
800012ba:	72 09       	ld.w	r9,r9[0x0]
800012bc:	8e 7b       	ld.sh	r11,r7[0xe]
800012be:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800012c2:	70 09       	ld.w	r9,r8[0x0]
800012c4:	2f f9       	sub	r9,-1
800012c6:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800012c8:	e0 49 00 ff 	cp.w	r9,255
800012cc:	e0 88 00 11 	brls	800012ee <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
800012d0:	30 09       	mov	r9,0
800012d2:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
800012d4:	fe f7 09 c8 	ld.w	r7,pc[2504]
800012d8:	6e 0c       	ld.w	r12,r7[0x0]
800012da:	f0 1f 02 7d 	mcall	80001ccc <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
800012de:	fe f8 09 ba 	ld.w	r8,pc[2490]
800012e2:	70 0c       	ld.w	r12,r8[0x0]
800012e4:	f0 1f 02 67 	mcall	80001c80 <phy_rx_func+0xe98>
800012e8:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
800012ea:	e0 80 04 bc 	breq	80001c62 <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
800012ee:	30 29       	mov	r9,2
800012f0:	fe f8 09 b4 	ld.w	r8,pc[2484]
800012f4:	91 09       	st.w	r8[0x0],r9
800012f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800012fa:	8e 79       	ld.sh	r9,r7[0xe]
800012fc:	30 38       	mov	r8,3
800012fe:	f0 09 19 00 	cp.h	r9,r8
80001302:	c0 51       	brne	8000130c <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80001304:	30 19       	mov	r9,1
80001306:	fe f8 09 f2 	ld.w	r8,pc[2546]
8000130a:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
8000130c:	30 29       	mov	r9,2
8000130e:	fe f8 09 96 	ld.w	r8,pc[2454]
80001312:	91 09       	st.w	r8[0x0],r9
80001314:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80001318:	58 18       	cp.w	r8,1
8000131a:	e0 88 04 a4 	brls	80001c62 <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
8000131e:	fe f8 09 d6 	ld.w	r8,pc[2518]
80001322:	70 0a       	ld.w	r10,r8[0x0]
80001324:	6e 3b       	ld.w	r11,r7[0xc]
80001326:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000132a:	70 09       	ld.w	r9,r8[0x0]
8000132c:	2f f9       	sub	r9,-1
8000132e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80001330:	e0 49 00 ff 	cp.w	r9,255
80001334:	e0 88 00 11 	brls	80001356 <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80001338:	30 09       	mov	r9,0
8000133a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000133c:	fe f7 09 60 	ld.w	r7,pc[2400]
80001340:	6e 0c       	ld.w	r12,r7[0x0]
80001342:	f0 1f 02 63 	mcall	80001ccc <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80001346:	fe f8 09 52 	ld.w	r8,pc[2386]
8000134a:	70 0c       	ld.w	r12,r8[0x0]
8000134c:	f0 1f 02 4d 	mcall	80001c80 <phy_rx_func+0xe98>
80001350:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80001352:	e0 80 04 88 	breq	80001c62 <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80001356:	fe f9 09 56 	ld.w	r9,pc[2390]
8000135a:	72 08       	ld.w	r8,r9[0x0]
8000135c:	20 28       	sub	r8,2
8000135e:	93 08       	st.w	r9[0x0],r8
80001360:	e0 80 04 81 	breq	80001c62 <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80001364:	30 29       	mov	r9,2
80001366:	fe f8 09 3e 	ld.w	r8,pc[2366]
8000136a:	91 09       	st.w	r8[0x0],r9
8000136c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80001370:	fe f8 09 84 	ld.w	r8,pc[2436]
80001374:	70 0a       	ld.w	r10,r8[0x0]
80001376:	fe f9 09 26 	ld.w	r9,pc[2342]
8000137a:	72 09       	ld.w	r9,r9[0x0]
8000137c:	8e 4b       	ld.sh	r11,r7[0x8]
8000137e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
80001382:	70 09       	ld.w	r9,r8[0x0]
80001384:	2f f9       	sub	r9,-1
80001386:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80001388:	e0 49 00 ff 	cp.w	r9,255
8000138c:	e0 88 00 16 	brls	800013b8 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
80001390:	30 09       	mov	r9,0
80001392:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80001394:	fe f6 09 08 	ld.w	r6,pc[2312]
80001398:	6c 0c       	ld.w	r12,r6[0x0]
8000139a:	f0 1f 02 4d 	mcall	80001ccc <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000139e:	fe f8 08 fa 	ld.w	r8,pc[2298]
800013a2:	70 0c       	ld.w	r12,r8[0x0]
800013a4:	f0 1f 02 37 	mcall	80001c80 <phy_rx_func+0xe98>
800013a8:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800013aa:	c0 71       	brne	800013b8 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
800013ac:	30 09       	mov	r9,0
800013ae:	fe f8 08 f6 	ld.w	r8,pc[2294]
800013b2:	91 09       	st.w	r8[0x0],r9
800013b4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
800013b8:	fe f9 08 f4 	ld.w	r9,pc[2292]
800013bc:	72 08       	ld.w	r8,r9[0x0]
800013be:	20 28       	sub	r8,2
800013c0:	93 08       	st.w	r9[0x0],r8
800013c2:	c0 71       	brne	800013d0 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
800013c4:	30 09       	mov	r9,0
800013c6:	fe f8 08 de 	ld.w	r8,pc[2270]
800013ca:	91 09       	st.w	r8[0x0],r9
800013cc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
800013d0:	fe f8 09 24 	ld.w	r8,pc[2340]
800013d4:	70 0a       	ld.w	r10,r8[0x0]
800013d6:	fe f9 08 c6 	ld.w	r9,pc[2246]
800013da:	72 09       	ld.w	r9,r9[0x0]
800013dc:	8e 5b       	ld.sh	r11,r7[0xa]
800013de:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800013e2:	70 09       	ld.w	r9,r8[0x0]
800013e4:	2f f9       	sub	r9,-1
800013e6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800013e8:	e0 49 00 ff 	cp.w	r9,255
800013ec:	e0 88 00 16 	brls	80001418 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
800013f0:	30 09       	mov	r9,0
800013f2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800013f4:	fe f6 08 a8 	ld.w	r6,pc[2216]
800013f8:	6c 0c       	ld.w	r12,r6[0x0]
800013fa:	f0 1f 02 35 	mcall	80001ccc <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800013fe:	fe f8 08 9a 	ld.w	r8,pc[2202]
80001402:	70 0c       	ld.w	r12,r8[0x0]
80001404:	f0 1f 02 1f 	mcall	80001c80 <phy_rx_func+0xe98>
80001408:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000140a:	c0 71       	brne	80001418 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
8000140c:	30 09       	mov	r9,0
8000140e:	fe f8 08 96 	ld.w	r8,pc[2198]
80001412:	91 09       	st.w	r8[0x0],r9
80001414:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80001418:	fe f9 08 94 	ld.w	r9,pc[2196]
8000141c:	72 08       	ld.w	r8,r9[0x0]
8000141e:	20 28       	sub	r8,2
80001420:	93 08       	st.w	r9[0x0],r8
80001422:	c0 71       	brne	80001430 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80001424:	30 09       	mov	r9,0
80001426:	fe f8 08 7e 	ld.w	r8,pc[2174]
8000142a:	91 09       	st.w	r8[0x0],r9
8000142c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80001430:	fe f8 08 c4 	ld.w	r8,pc[2244]
80001434:	70 0a       	ld.w	r10,r8[0x0]
80001436:	fe f9 08 66 	ld.w	r9,pc[2150]
8000143a:	72 09       	ld.w	r9,r9[0x0]
8000143c:	8e 6b       	ld.sh	r11,r7[0xc]
8000143e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80001442:	70 09       	ld.w	r9,r8[0x0]
80001444:	2f f9       	sub	r9,-1
80001446:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80001448:	e0 49 00 ff 	cp.w	r9,255
8000144c:	e0 88 00 16 	brls	80001478 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80001450:	30 09       	mov	r9,0
80001452:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80001454:	fe f6 08 48 	ld.w	r6,pc[2120]
80001458:	6c 0c       	ld.w	r12,r6[0x0]
8000145a:	f0 1f 02 1d 	mcall	80001ccc <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000145e:	fe f8 08 3a 	ld.w	r8,pc[2106]
80001462:	70 0c       	ld.w	r12,r8[0x0]
80001464:	f0 1f 02 07 	mcall	80001c80 <phy_rx_func+0xe98>
80001468:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000146a:	c0 71       	brne	80001478 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
8000146c:	30 09       	mov	r9,0
8000146e:	fe f8 08 36 	ld.w	r8,pc[2102]
80001472:	91 09       	st.w	r8[0x0],r9
80001474:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80001478:	fe f9 08 34 	ld.w	r9,pc[2100]
8000147c:	72 08       	ld.w	r8,r9[0x0]
8000147e:	20 28       	sub	r8,2
80001480:	93 08       	st.w	r9[0x0],r8
80001482:	c0 71       	brne	80001490 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
80001484:	30 09       	mov	r9,0
80001486:	fe f8 08 1e 	ld.w	r8,pc[2078]
8000148a:	91 09       	st.w	r8[0x0],r9
8000148c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80001490:	fe f8 08 64 	ld.w	r8,pc[2148]
80001494:	70 0a       	ld.w	r10,r8[0x0]
80001496:	fe f9 08 06 	ld.w	r9,pc[2054]
8000149a:	72 09       	ld.w	r9,r9[0x0]
8000149c:	8e 7b       	ld.sh	r11,r7[0xe]
8000149e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800014a2:	70 09       	ld.w	r9,r8[0x0]
800014a4:	2f f9       	sub	r9,-1
800014a6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800014a8:	e0 49 00 ff 	cp.w	r9,255
800014ac:	e0 88 00 16 	brls	800014d8 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
800014b0:	30 09       	mov	r9,0
800014b2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800014b4:	fe f7 07 e8 	ld.w	r7,pc[2024]
800014b8:	6e 0c       	ld.w	r12,r7[0x0]
800014ba:	f0 1f 02 05 	mcall	80001ccc <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800014be:	fe f8 07 da 	ld.w	r8,pc[2010]
800014c2:	70 0c       	ld.w	r12,r8[0x0]
800014c4:	f0 1f 01 ef 	mcall	80001c80 <phy_rx_func+0xe98>
800014c8:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800014ca:	c0 71       	brne	800014d8 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
800014cc:	30 09       	mov	r9,0
800014ce:	fe f8 07 d6 	ld.w	r8,pc[2006]
800014d2:	91 09       	st.w	r8[0x0],r9
800014d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800014d8:	fe f9 07 d4 	ld.w	r9,pc[2004]
800014dc:	72 08       	ld.w	r8,r9[0x0]
800014de:	20 28       	sub	r8,2
800014e0:	93 08       	st.w	r9[0x0],r8
800014e2:	e0 81 03 c0 	brne	80001c62 <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
800014e6:	30 09       	mov	r9,0
800014e8:	fe f8 07 bc 	ld.w	r8,pc[1980]
800014ec:	91 09       	st.w	r8[0x0],r9
800014ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
800014f2:	fe f8 07 ca 	ld.w	r8,pc[1994]
800014f6:	11 89       	ld.ub	r9,r8[0x0]
800014f8:	31 28       	mov	r8,18
800014fa:	f0 09 18 00 	cp.b	r9,r8
800014fe:	e0 81 01 4c 	brne	80001796 <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
80001502:	ef 39 00 09 	ld.ub	r9,r7[9]
80001506:	fe f8 07 b6 	ld.w	r8,pc[1974]
8000150a:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
8000150c:	11 89       	ld.ub	r9,r8[0x0]
8000150e:	3f 28       	mov	r8,-14
80001510:	f0 09 18 00 	cp.b	r9,r8
80001514:	e0 81 01 3b 	brne	8000178a <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80001518:	30 19       	mov	r9,1
8000151a:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000151e:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80001520:	6e 29       	ld.w	r9,r7[0x8]
80001522:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80001526:	fe f8 07 86 	ld.w	r8,pc[1926]
8000152a:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
8000152c:	8e 59       	ld.sh	r9,r7[0xa]
8000152e:	fe f8 07 ce 	ld.w	r8,pc[1998]
80001532:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80001534:	8e 69       	ld.sh	r9,r7[0xc]
80001536:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80001538:	8e 79       	ld.sh	r9,r7[0xe]
8000153a:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
8000153c:	fe f8 07 88 	ld.w	r8,pc[1928]
80001540:	fe f9 07 60 	ld.w	r9,pc[1888]
80001544:	72 0a       	ld.w	r10,r9[0x0]
80001546:	70 09       	ld.w	r9,r8[0x0]
80001548:	ef 3b 00 0a 	ld.ub	r11,r7[10]
8000154c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80001550:	70 09       	ld.w	r9,r8[0x0]
80001552:	2f f9       	sub	r9,-1
80001554:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80001556:	e0 49 01 ff 	cp.w	r9,511
8000155a:	e0 88 00 16 	brls	80001586 <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
8000155e:	30 09       	mov	r9,0
80001560:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80001562:	fe f6 07 3e 	ld.w	r6,pc[1854]
80001566:	6c 0c       	ld.w	r12,r6[0x0]
80001568:	f0 1f 01 d9 	mcall	80001ccc <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000156c:	fe f8 07 2c 	ld.w	r8,pc[1836]
80001570:	70 0c       	ld.w	r12,r8[0x0]
80001572:	f0 1f 01 c4 	mcall	80001c80 <phy_rx_func+0xe98>
80001576:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80001578:	c0 71       	brne	80001586 <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
8000157a:	30 09       	mov	r9,0
8000157c:	fe f8 07 28 	ld.w	r8,pc[1832]
80001580:	91 09       	st.w	r8[0x0],r9
80001582:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80001586:	fe f9 07 26 	ld.w	r9,pc[1830]
8000158a:	72 08       	ld.w	r8,r9[0x0]
8000158c:	20 18       	sub	r8,1
8000158e:	93 08       	st.w	r9[0x0],r8
80001590:	c0 71       	brne	8000159e <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
80001592:	30 09       	mov	r9,0
80001594:	fe f8 07 10 	ld.w	r8,pc[1808]
80001598:	91 09       	st.w	r8[0x0],r9
8000159a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
8000159e:	fe f8 07 26 	ld.w	r8,pc[1830]
800015a2:	fe f9 06 fe 	ld.w	r9,pc[1790]
800015a6:	72 0a       	ld.w	r10,r9[0x0]
800015a8:	70 09       	ld.w	r9,r8[0x0]
800015aa:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800015ae:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800015b2:	70 09       	ld.w	r9,r8[0x0]
800015b4:	2f f9       	sub	r9,-1
800015b6:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800015b8:	e0 49 01 ff 	cp.w	r9,511
800015bc:	e0 88 00 16 	brls	800015e8 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
800015c0:	30 09       	mov	r9,0
800015c2:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800015c4:	fe f6 06 dc 	ld.w	r6,pc[1756]
800015c8:	6c 0c       	ld.w	r12,r6[0x0]
800015ca:	f0 1f 01 c1 	mcall	80001ccc <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800015ce:	fe f8 06 ca 	ld.w	r8,pc[1738]
800015d2:	70 0c       	ld.w	r12,r8[0x0]
800015d4:	f0 1f 01 ab 	mcall	80001c80 <phy_rx_func+0xe98>
800015d8:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800015da:	c0 71       	brne	800015e8 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
800015dc:	30 09       	mov	r9,0
800015de:	fe f8 06 c6 	ld.w	r8,pc[1734]
800015e2:	91 09       	st.w	r8[0x0],r9
800015e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800015e8:	fe f9 06 c4 	ld.w	r9,pc[1732]
800015ec:	72 08       	ld.w	r8,r9[0x0]
800015ee:	20 18       	sub	r8,1
800015f0:	93 08       	st.w	r9[0x0],r8
800015f2:	c0 71       	brne	80001600 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
800015f4:	30 09       	mov	r9,0
800015f6:	fe f8 06 ae 	ld.w	r8,pc[1710]
800015fa:	91 09       	st.w	r8[0x0],r9
800015fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80001600:	fe f8 06 c4 	ld.w	r8,pc[1732]
80001604:	fe f9 06 9c 	ld.w	r9,pc[1692]
80001608:	72 0a       	ld.w	r10,r9[0x0]
8000160a:	70 09       	ld.w	r9,r8[0x0]
8000160c:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80001610:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80001614:	70 09       	ld.w	r9,r8[0x0]
80001616:	2f f9       	sub	r9,-1
80001618:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000161a:	e0 49 01 ff 	cp.w	r9,511
8000161e:	e0 88 00 16 	brls	8000164a <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80001622:	30 09       	mov	r9,0
80001624:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80001626:	fe f6 06 7a 	ld.w	r6,pc[1658]
8000162a:	6c 0c       	ld.w	r12,r6[0x0]
8000162c:	f0 1f 01 a8 	mcall	80001ccc <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80001630:	fe f8 06 68 	ld.w	r8,pc[1640]
80001634:	70 0c       	ld.w	r12,r8[0x0]
80001636:	f0 1f 01 93 	mcall	80001c80 <phy_rx_func+0xe98>
8000163a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000163c:	c0 71       	brne	8000164a <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
8000163e:	30 09       	mov	r9,0
80001640:	fe f8 06 64 	ld.w	r8,pc[1636]
80001644:	91 09       	st.w	r8[0x0],r9
80001646:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000164a:	fe f9 06 62 	ld.w	r9,pc[1634]
8000164e:	72 08       	ld.w	r8,r9[0x0]
80001650:	20 18       	sub	r8,1
80001652:	93 08       	st.w	r9[0x0],r8
80001654:	c0 71       	brne	80001662 <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
80001656:	30 09       	mov	r9,0
80001658:	fe f8 06 4c 	ld.w	r8,pc[1612]
8000165c:	91 09       	st.w	r8[0x0],r9
8000165e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80001662:	fe f8 06 62 	ld.w	r8,pc[1634]
80001666:	fe f9 06 3a 	ld.w	r9,pc[1594]
8000166a:	72 0a       	ld.w	r10,r9[0x0]
8000166c:	70 09       	ld.w	r9,r8[0x0]
8000166e:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80001672:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80001676:	70 09       	ld.w	r9,r8[0x0]
80001678:	2f f9       	sub	r9,-1
8000167a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000167c:	e0 49 01 ff 	cp.w	r9,511
80001680:	e0 88 00 16 	brls	800016ac <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
80001684:	30 09       	mov	r9,0
80001686:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80001688:	fe f6 06 18 	ld.w	r6,pc[1560]
8000168c:	6c 0c       	ld.w	r12,r6[0x0]
8000168e:	f0 1f 01 90 	mcall	80001ccc <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80001692:	fe f8 06 06 	ld.w	r8,pc[1542]
80001696:	70 0c       	ld.w	r12,r8[0x0]
80001698:	f0 1f 01 7a 	mcall	80001c80 <phy_rx_func+0xe98>
8000169c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000169e:	c0 71       	brne	800016ac <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
800016a0:	30 09       	mov	r9,0
800016a2:	fe f8 06 02 	ld.w	r8,pc[1538]
800016a6:	91 09       	st.w	r8[0x0],r9
800016a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800016ac:	fe f9 06 00 	ld.w	r9,pc[1536]
800016b0:	72 08       	ld.w	r8,r9[0x0]
800016b2:	20 18       	sub	r8,1
800016b4:	93 08       	st.w	r9[0x0],r8
800016b6:	c0 71       	brne	800016c4 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
800016b8:	30 09       	mov	r9,0
800016ba:	fe f8 05 ea 	ld.w	r8,pc[1514]
800016be:	91 09       	st.w	r8[0x0],r9
800016c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
800016c4:	fe f8 06 00 	ld.w	r8,pc[1536]
800016c8:	fe f9 05 d8 	ld.w	r9,pc[1496]
800016cc:	72 0a       	ld.w	r10,r9[0x0]
800016ce:	70 09       	ld.w	r9,r8[0x0]
800016d0:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800016d4:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800016d8:	70 09       	ld.w	r9,r8[0x0]
800016da:	2f f9       	sub	r9,-1
800016dc:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800016de:	e0 49 01 ff 	cp.w	r9,511
800016e2:	e0 88 00 16 	brls	8000170e <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
800016e6:	30 09       	mov	r9,0
800016e8:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800016ea:	fe f6 05 b6 	ld.w	r6,pc[1462]
800016ee:	6c 0c       	ld.w	r12,r6[0x0]
800016f0:	f0 1f 01 77 	mcall	80001ccc <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800016f4:	fe f8 05 a4 	ld.w	r8,pc[1444]
800016f8:	70 0c       	ld.w	r12,r8[0x0]
800016fa:	f0 1f 01 62 	mcall	80001c80 <phy_rx_func+0xe98>
800016fe:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80001700:	c0 71       	brne	8000170e <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
80001702:	30 09       	mov	r9,0
80001704:	fe f8 05 a0 	ld.w	r8,pc[1440]
80001708:	91 09       	st.w	r8[0x0],r9
8000170a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000170e:	fe f9 05 9e 	ld.w	r9,pc[1438]
80001712:	72 08       	ld.w	r8,r9[0x0]
80001714:	20 18       	sub	r8,1
80001716:	93 08       	st.w	r9[0x0],r8
80001718:	c0 71       	brne	80001726 <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
8000171a:	30 09       	mov	r9,0
8000171c:	fe f8 05 88 	ld.w	r8,pc[1416]
80001720:	91 09       	st.w	r8[0x0],r9
80001722:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80001726:	fe f8 05 9e 	ld.w	r8,pc[1438]
8000172a:	fe f9 05 76 	ld.w	r9,pc[1398]
8000172e:	72 0a       	ld.w	r10,r9[0x0]
80001730:	70 09       	ld.w	r9,r8[0x0]
80001732:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80001736:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000173a:	70 09       	ld.w	r9,r8[0x0]
8000173c:	2f f9       	sub	r9,-1
8000173e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80001740:	e0 49 01 ff 	cp.w	r9,511
80001744:	e0 88 00 16 	brls	80001770 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80001748:	30 09       	mov	r9,0
8000174a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000174c:	fe f7 05 54 	ld.w	r7,pc[1364]
80001750:	6e 0c       	ld.w	r12,r7[0x0]
80001752:	f0 1f 01 5f 	mcall	80001ccc <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80001756:	fe f8 05 42 	ld.w	r8,pc[1346]
8000175a:	70 0c       	ld.w	r12,r8[0x0]
8000175c:	f0 1f 01 49 	mcall	80001c80 <phy_rx_func+0xe98>
80001760:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80001762:	c0 71       	brne	80001770 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
80001764:	30 09       	mov	r9,0
80001766:	fe f8 05 3e 	ld.w	r8,pc[1342]
8000176a:	91 09       	st.w	r8[0x0],r9
8000176c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80001770:	fe f9 05 3c 	ld.w	r9,pc[1340]
80001774:	72 08       	ld.w	r8,r9[0x0]
80001776:	20 18       	sub	r8,1
80001778:	93 08       	st.w	r9[0x0],r8
8000177a:	e0 81 02 74 	brne	80001c62 <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
8000177e:	30 09       	mov	r9,0
80001780:	fe f8 05 24 	ld.w	r8,pc[1316]
80001784:	91 09       	st.w	r8[0x0],r9
80001786:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
8000178a:	30 09       	mov	r9,0
8000178c:	fe f8 05 18 	ld.w	r8,pc[1304]
80001790:	91 09       	st.w	r8[0x0],r9
80001792:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80001796:	fe f8 05 26 	ld.w	r8,pc[1318]
8000179a:	11 89       	ld.ub	r9,r8[0x0]
8000179c:	3f 28       	mov	r8,-14
8000179e:	f0 09 18 00 	cp.b	r9,r8
800017a2:	c4 31       	brne	80001828 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
800017a4:	8e 49       	ld.sh	r9,r7[0x8]
800017a6:	fe f8 05 56 	ld.w	r8,pc[1366]
800017aa:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
800017ac:	fe f8 05 18 	ld.w	r8,pc[1304]
800017b0:	fe f9 04 f0 	ld.w	r9,pc[1264]
800017b4:	72 0a       	ld.w	r10,r9[0x0]
800017b6:	70 09       	ld.w	r9,r8[0x0]
800017b8:	ef 3b 00 08 	ld.ub	r11,r7[8]
800017bc:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800017c0:	70 09       	ld.w	r9,r8[0x0]
800017c2:	2f f9       	sub	r9,-1
800017c4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800017c6:	e0 49 01 ff 	cp.w	r9,511
800017ca:	e0 88 00 16 	brls	800017f6 <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
800017ce:	30 09       	mov	r9,0
800017d0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800017d2:	fe f7 04 ce 	ld.w	r7,pc[1230]
800017d6:	6e 0c       	ld.w	r12,r7[0x0]
800017d8:	f0 1f 01 3d 	mcall	80001ccc <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800017dc:	fe f8 04 bc 	ld.w	r8,pc[1212]
800017e0:	70 0c       	ld.w	r12,r8[0x0]
800017e2:	f0 1f 01 28 	mcall	80001c80 <phy_rx_func+0xe98>
800017e6:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800017e8:	c0 71       	brne	800017f6 <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
800017ea:	30 09       	mov	r9,0
800017ec:	fe f8 04 b8 	ld.w	r8,pc[1208]
800017f0:	91 09       	st.w	r8[0x0],r9
800017f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800017f6:	fe f9 04 b6 	ld.w	r9,pc[1206]
800017fa:	72 08       	ld.w	r8,r9[0x0]
800017fc:	20 18       	sub	r8,1
800017fe:	93 08       	st.w	r9[0x0],r8
80001800:	c0 71       	brne	8000180e <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
80001802:	30 09       	mov	r9,0
80001804:	fe f8 04 a0 	ld.w	r8,pc[1184]
80001808:	91 09       	st.w	r8[0x0],r9
8000180a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
8000180e:	20 18       	sub	r8,1
80001810:	fe f9 04 9c 	ld.w	r9,pc[1180]
80001814:	93 08       	st.w	r9[0x0],r8
80001816:	58 08       	cp.w	r8,0
80001818:	e0 81 02 25 	brne	80001c62 <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
8000181c:	30 09       	mov	r9,0
8000181e:	fe f8 04 86 	ld.w	r8,pc[1158]
80001822:	91 09       	st.w	r8[0x0],r9
80001824:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80001828:	fe f8 04 94 	ld.w	r8,pc[1172]
8000182c:	11 89       	ld.ub	r9,r8[0x0]
8000182e:	3f 38       	mov	r8,-13
80001830:	f0 09 18 00 	cp.b	r9,r8
80001834:	e0 81 01 0c 	brne	80001a4c <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80001838:	8e 49       	ld.sh	r9,r7[0x8]
8000183a:	fe f8 04 c2 	ld.w	r8,pc[1218]
8000183e:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80001840:	8e 59       	ld.sh	r9,r7[0xa]
80001842:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80001844:	8e 69       	ld.sh	r9,r7[0xc]
80001846:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80001848:	fe f8 04 7c 	ld.w	r8,pc[1148]
8000184c:	fe f9 04 54 	ld.w	r9,pc[1108]
80001850:	72 0a       	ld.w	r10,r9[0x0]
80001852:	70 09       	ld.w	r9,r8[0x0]
80001854:	ef 3b 00 08 	ld.ub	r11,r7[8]
80001858:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000185c:	70 09       	ld.w	r9,r8[0x0]
8000185e:	2f f9       	sub	r9,-1
80001860:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80001862:	e0 49 01 ff 	cp.w	r9,511
80001866:	e0 88 00 16 	brls	80001892 <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
8000186a:	30 09       	mov	r9,0
8000186c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000186e:	fe f6 04 32 	ld.w	r6,pc[1074]
80001872:	6c 0c       	ld.w	r12,r6[0x0]
80001874:	f0 1f 01 16 	mcall	80001ccc <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80001878:	fe f8 04 20 	ld.w	r8,pc[1056]
8000187c:	70 0c       	ld.w	r12,r8[0x0]
8000187e:	f0 1f 01 01 	mcall	80001c80 <phy_rx_func+0xe98>
80001882:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80001884:	c0 71       	brne	80001892 <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
80001886:	30 09       	mov	r9,0
80001888:	fe f8 04 1c 	ld.w	r8,pc[1052]
8000188c:	91 09       	st.w	r8[0x0],r9
8000188e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80001892:	fe f9 04 1a 	ld.w	r9,pc[1050]
80001896:	72 08       	ld.w	r8,r9[0x0]
80001898:	20 18       	sub	r8,1
8000189a:	93 08       	st.w	r9[0x0],r8
8000189c:	c0 71       	brne	800018aa <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
8000189e:	30 09       	mov	r9,0
800018a0:	fe f8 04 04 	ld.w	r8,pc[1028]
800018a4:	91 09       	st.w	r8[0x0],r9
800018a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
800018aa:	fe f8 04 1a 	ld.w	r8,pc[1050]
800018ae:	fe f9 03 f2 	ld.w	r9,pc[1010]
800018b2:	72 0a       	ld.w	r10,r9[0x0]
800018b4:	70 09       	ld.w	r9,r8[0x0]
800018b6:	ef 3b 00 09 	ld.ub	r11,r7[9]
800018ba:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800018be:	70 09       	ld.w	r9,r8[0x0]
800018c0:	2f f9       	sub	r9,-1
800018c2:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800018c4:	e0 49 01 ff 	cp.w	r9,511
800018c8:	e0 88 00 16 	brls	800018f4 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
800018cc:	30 09       	mov	r9,0
800018ce:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800018d0:	fe f6 03 d0 	ld.w	r6,pc[976]
800018d4:	6c 0c       	ld.w	r12,r6[0x0]
800018d6:	f0 1f 00 fe 	mcall	80001ccc <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800018da:	fe f8 03 be 	ld.w	r8,pc[958]
800018de:	70 0c       	ld.w	r12,r8[0x0]
800018e0:	f0 1f 00 e8 	mcall	80001c80 <phy_rx_func+0xe98>
800018e4:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800018e6:	c0 71       	brne	800018f4 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
800018e8:	30 09       	mov	r9,0
800018ea:	fe f8 03 ba 	ld.w	r8,pc[954]
800018ee:	91 09       	st.w	r8[0x0],r9
800018f0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800018f4:	fe f9 03 b8 	ld.w	r9,pc[952]
800018f8:	72 08       	ld.w	r8,r9[0x0]
800018fa:	20 18       	sub	r8,1
800018fc:	93 08       	st.w	r9[0x0],r8
800018fe:	c0 71       	brne	8000190c <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80001900:	30 09       	mov	r9,0
80001902:	fe f8 03 a2 	ld.w	r8,pc[930]
80001906:	91 09       	st.w	r8[0x0],r9
80001908:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
8000190c:	fe f8 03 b8 	ld.w	r8,pc[952]
80001910:	fe f9 03 90 	ld.w	r9,pc[912]
80001914:	72 0a       	ld.w	r10,r9[0x0]
80001916:	70 09       	ld.w	r9,r8[0x0]
80001918:	ef 3b 00 0a 	ld.ub	r11,r7[10]
8000191c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80001920:	70 09       	ld.w	r9,r8[0x0]
80001922:	2f f9       	sub	r9,-1
80001924:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80001926:	e0 49 01 ff 	cp.w	r9,511
8000192a:	e0 88 00 16 	brls	80001956 <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
8000192e:	30 09       	mov	r9,0
80001930:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80001932:	fe f6 03 6e 	ld.w	r6,pc[878]
80001936:	6c 0c       	ld.w	r12,r6[0x0]
80001938:	f0 1f 00 e5 	mcall	80001ccc <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000193c:	fe f8 03 5c 	ld.w	r8,pc[860]
80001940:	70 0c       	ld.w	r12,r8[0x0]
80001942:	f0 1f 00 d0 	mcall	80001c80 <phy_rx_func+0xe98>
80001946:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80001948:	c0 71       	brne	80001956 <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
8000194a:	30 09       	mov	r9,0
8000194c:	fe f8 03 58 	ld.w	r8,pc[856]
80001950:	91 09       	st.w	r8[0x0],r9
80001952:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80001956:	fe f9 03 56 	ld.w	r9,pc[854]
8000195a:	72 08       	ld.w	r8,r9[0x0]
8000195c:	20 18       	sub	r8,1
8000195e:	93 08       	st.w	r9[0x0],r8
80001960:	c0 71       	brne	8000196e <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
80001962:	30 09       	mov	r9,0
80001964:	fe f8 03 40 	ld.w	r8,pc[832]
80001968:	91 09       	st.w	r8[0x0],r9
8000196a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
8000196e:	fe f8 03 56 	ld.w	r8,pc[854]
80001972:	fe f9 03 2e 	ld.w	r9,pc[814]
80001976:	72 0a       	ld.w	r10,r9[0x0]
80001978:	70 09       	ld.w	r9,r8[0x0]
8000197a:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000197e:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80001982:	70 09       	ld.w	r9,r8[0x0]
80001984:	2f f9       	sub	r9,-1
80001986:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80001988:	e0 49 01 ff 	cp.w	r9,511
8000198c:	e0 88 00 16 	brls	800019b8 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80001990:	30 09       	mov	r9,0
80001992:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80001994:	fe f6 03 0c 	ld.w	r6,pc[780]
80001998:	6c 0c       	ld.w	r12,r6[0x0]
8000199a:	f0 1f 00 cd 	mcall	80001ccc <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000199e:	fe f8 02 fa 	ld.w	r8,pc[762]
800019a2:	70 0c       	ld.w	r12,r8[0x0]
800019a4:	f0 1f 00 b7 	mcall	80001c80 <phy_rx_func+0xe98>
800019a8:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800019aa:	c0 71       	brne	800019b8 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
800019ac:	30 09       	mov	r9,0
800019ae:	fe f8 02 f6 	ld.w	r8,pc[758]
800019b2:	91 09       	st.w	r8[0x0],r9
800019b4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800019b8:	fe f9 02 f4 	ld.w	r9,pc[756]
800019bc:	72 08       	ld.w	r8,r9[0x0]
800019be:	20 18       	sub	r8,1
800019c0:	93 08       	st.w	r9[0x0],r8
800019c2:	c0 71       	brne	800019d0 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
800019c4:	30 09       	mov	r9,0
800019c6:	fe f8 02 de 	ld.w	r8,pc[734]
800019ca:	91 09       	st.w	r8[0x0],r9
800019cc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
800019d0:	fe f8 02 f4 	ld.w	r8,pc[756]
800019d4:	fe f9 02 cc 	ld.w	r9,pc[716]
800019d8:	72 0a       	ld.w	r10,r9[0x0]
800019da:	70 09       	ld.w	r9,r8[0x0]
800019dc:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800019e0:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800019e4:	70 09       	ld.w	r9,r8[0x0]
800019e6:	2f f9       	sub	r9,-1
800019e8:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800019ea:	e0 49 01 ff 	cp.w	r9,511
800019ee:	e0 88 00 16 	brls	80001a1a <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
800019f2:	30 09       	mov	r9,0
800019f4:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800019f6:	fe f7 02 aa 	ld.w	r7,pc[682]
800019fa:	6e 0c       	ld.w	r12,r7[0x0]
800019fc:	f0 1f 00 b4 	mcall	80001ccc <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80001a00:	fe f8 02 98 	ld.w	r8,pc[664]
80001a04:	70 0c       	ld.w	r12,r8[0x0]
80001a06:	f0 1f 00 9f 	mcall	80001c80 <phy_rx_func+0xe98>
80001a0a:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80001a0c:	c0 71       	brne	80001a1a <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80001a0e:	30 09       	mov	r9,0
80001a10:	fe f8 02 94 	ld.w	r8,pc[660]
80001a14:	91 09       	st.w	r8[0x0],r9
80001a16:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80001a1a:	fe f9 02 92 	ld.w	r9,pc[658]
80001a1e:	72 08       	ld.w	r8,r9[0x0]
80001a20:	20 18       	sub	r8,1
80001a22:	93 08       	st.w	r9[0x0],r8
80001a24:	c0 71       	brne	80001a32 <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80001a26:	30 09       	mov	r9,0
80001a28:	fe f8 02 7c 	ld.w	r8,pc[636]
80001a2c:	91 09       	st.w	r8[0x0],r9
80001a2e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80001a32:	20 18       	sub	r8,1
80001a34:	fe f9 02 78 	ld.w	r9,pc[632]
80001a38:	93 08       	st.w	r9[0x0],r8
80001a3a:	58 08       	cp.w	r8,0
80001a3c:	e0 81 01 13 	brne	80001c62 <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80001a40:	30 09       	mov	r9,0
80001a42:	fe f8 02 62 	ld.w	r8,pc[610]
80001a46:	91 09       	st.w	r8[0x0],r9
80001a48:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80001a4c:	fe f8 02 70 	ld.w	r8,pc[624]
80001a50:	11 89       	ld.ub	r9,r8[0x0]
80001a52:	30 48       	mov	r8,4
80001a54:	f0 09 18 00 	cp.b	r9,r8
80001a58:	c0 80       	breq	80001a68 <phy_rx_func+0xc80>
80001a5a:	fe f8 02 62 	ld.w	r8,pc[610]
80001a5e:	11 89       	ld.ub	r9,r8[0x0]
80001a60:	30 38       	mov	r8,3
80001a62:	f0 09 18 00 	cp.b	r9,r8
80001a66:	c1 41       	brne	80001a8e <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80001a68:	6e 29       	ld.w	r9,r7[0x8]
80001a6a:	fe f8 02 7a 	ld.w	r8,pc[634]
80001a6e:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80001a70:	6e 39       	ld.w	r9,r7[0xc]
80001a72:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80001a74:	fe f9 02 38 	ld.w	r9,pc[568]
80001a78:	72 08       	ld.w	r8,r9[0x0]
80001a7a:	20 88       	sub	r8,8
80001a7c:	93 08       	st.w	r9[0x0],r8
80001a7e:	e0 81 00 f2 	brne	80001c62 <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80001a82:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80001a84:	fe f9 02 20 	ld.w	r9,pc[544]
80001a88:	93 08       	st.w	r9[0x0],r8
80001a8a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80001a8e:	fe f8 02 2e 	ld.w	r8,pc[558]
80001a92:	11 89       	ld.ub	r9,r8[0x0]
80001a94:	31 38       	mov	r8,19
80001a96:	f0 09 18 00 	cp.b	r9,r8
80001a9a:	e0 81 00 9c 	brne	80001bd2 <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80001a9e:	fe f8 02 62 	ld.w	r8,pc[610]
80001aa2:	11 88       	ld.ub	r8,r8[0x0]
80001aa4:	30 c9       	mov	r9,12
80001aa6:	f2 08 18 00 	cp.b	r8,r9
80001aaa:	e0 81 00 7b 	brne	80001ba0 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80001aae:	8e 49       	ld.sh	r9,r7[0x8]
80001ab0:	fe f8 02 54 	ld.w	r8,pc[596]
80001ab4:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80001ab8:	30 09       	mov	r9,0
80001aba:	fe f8 02 46 	ld.w	r8,pc[582]
80001abe:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80001ac0:	ef 39 00 0d 	ld.ub	r9,r7[13]
80001ac4:	3f 38       	mov	r8,-13
80001ac6:	f0 09 18 00 	cp.b	r9,r8
80001aca:	c6 61       	brne	80001b96 <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80001acc:	10 99       	mov	r9,r8
80001ace:	4f c8       	lddpc	r8,80001cbc <phy_rx_func+0xed4>
80001ad0:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80001ad2:	ef 39 00 0c 	ld.ub	r9,r7[12]
80001ad6:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80001ada:	4f 58       	lddpc	r8,80001cac <phy_rx_func+0xec4>
80001adc:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80001ade:	30 19       	mov	r9,1
80001ae0:	fe f8 02 0c 	ld.w	r8,pc[524]
80001ae4:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80001ae6:	8e 79       	ld.sh	r9,r7[0xe]
80001ae8:	fe f8 02 14 	ld.w	r8,pc[532]
80001aec:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80001aee:	4f 68       	lddpc	r8,80001cc4 <phy_rx_func+0xedc>
80001af0:	4e c9       	lddpc	r9,80001ca0 <phy_rx_func+0xeb8>
80001af2:	72 0a       	ld.w	r10,r9[0x0]
80001af4:	70 09       	ld.w	r9,r8[0x0]
80001af6:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80001afa:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80001afe:	70 09       	ld.w	r9,r8[0x0]
80001b00:	2f f9       	sub	r9,-1
80001b02:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80001b04:	e0 49 01 ff 	cp.w	r9,511
80001b08:	e0 88 00 13 	brls	80001b2e <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80001b0c:	30 09       	mov	r9,0
80001b0e:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80001b10:	4e 46       	lddpc	r6,80001ca0 <phy_rx_func+0xeb8>
80001b12:	6c 0c       	ld.w	r12,r6[0x0]
80001b14:	f0 1f 00 6e 	mcall	80001ccc <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80001b18:	4e 08       	lddpc	r8,80001c98 <phy_rx_func+0xeb0>
80001b1a:	70 0c       	ld.w	r12,r8[0x0]
80001b1c:	f0 1f 00 59 	mcall	80001c80 <phy_rx_func+0xe98>
80001b20:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80001b22:	c0 61       	brne	80001b2e <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80001b24:	30 09       	mov	r9,0
80001b26:	4e 08       	lddpc	r8,80001ca4 <phy_rx_func+0xebc>
80001b28:	91 09       	st.w	r8[0x0],r9
80001b2a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80001b2e:	4e 09       	lddpc	r9,80001cac <phy_rx_func+0xec4>
80001b30:	72 08       	ld.w	r8,r9[0x0]
80001b32:	20 18       	sub	r8,1
80001b34:	93 08       	st.w	r9[0x0],r8
80001b36:	c0 61       	brne	80001b42 <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80001b38:	30 09       	mov	r9,0
80001b3a:	4d b8       	lddpc	r8,80001ca4 <phy_rx_func+0xebc>
80001b3c:	91 09       	st.w	r8[0x0],r9
80001b3e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80001b42:	4e 18       	lddpc	r8,80001cc4 <phy_rx_func+0xedc>
80001b44:	4d 79       	lddpc	r9,80001ca0 <phy_rx_func+0xeb8>
80001b46:	72 0a       	ld.w	r10,r9[0x0]
80001b48:	70 09       	ld.w	r9,r8[0x0]
80001b4a:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80001b4e:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80001b52:	70 09       	ld.w	r9,r8[0x0]
80001b54:	2f f9       	sub	r9,-1
80001b56:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80001b58:	e0 49 01 ff 	cp.w	r9,511
80001b5c:	e0 88 00 13 	brls	80001b82 <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80001b60:	30 09       	mov	r9,0
80001b62:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80001b64:	4c f7       	lddpc	r7,80001ca0 <phy_rx_func+0xeb8>
80001b66:	6e 0c       	ld.w	r12,r7[0x0]
80001b68:	f0 1f 00 59 	mcall	80001ccc <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80001b6c:	4c b8       	lddpc	r8,80001c98 <phy_rx_func+0xeb0>
80001b6e:	70 0c       	ld.w	r12,r8[0x0]
80001b70:	f0 1f 00 44 	mcall	80001c80 <phy_rx_func+0xe98>
80001b74:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80001b76:	c0 61       	brne	80001b82 <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80001b78:	30 09       	mov	r9,0
80001b7a:	4c b8       	lddpc	r8,80001ca4 <phy_rx_func+0xebc>
80001b7c:	91 09       	st.w	r8[0x0],r9
80001b7e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80001b82:	4c b9       	lddpc	r9,80001cac <phy_rx_func+0xec4>
80001b84:	72 08       	ld.w	r8,r9[0x0]
80001b86:	20 18       	sub	r8,1
80001b88:	93 08       	st.w	r9[0x0],r8
80001b8a:	c6 c1       	brne	80001c62 <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80001b8c:	30 09       	mov	r9,0
80001b8e:	4c 68       	lddpc	r8,80001ca4 <phy_rx_func+0xebc>
80001b90:	91 09       	st.w	r8[0x0],r9
80001b92:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80001b96:	30 09       	mov	r9,0
80001b98:	4c 38       	lddpc	r8,80001ca4 <phy_rx_func+0xebc>
80001b9a:	91 09       	st.w	r8[0x0],r9
80001b9c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80001ba0:	8e 4a       	ld.sh	r10,r7[0x8]
80001ba2:	4d 99       	lddpc	r9,80001d04 <phy_rx_func+0xf1c>
80001ba4:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80001ba8:	4d 6a       	lddpc	r10,80001d00 <phy_rx_func+0xf18>
80001baa:	15 88       	ld.ub	r8,r10[0x0]
80001bac:	f0 cb ff ff 	sub	r11,r8,-1
80001bb0:	8e 5c       	ld.sh	r12,r7[0xa]
80001bb2:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80001bb6:	f0 cb ff fe 	sub	r11,r8,-2
80001bba:	8e 6c       	ld.sh	r12,r7[0xc]
80001bbc:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80001bc0:	f0 cb ff fd 	sub	r11,r8,-3
80001bc4:	8e 7c       	ld.sh	r12,r7[0xe]
80001bc6:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80001bca:	2f c8       	sub	r8,-4
80001bcc:	b4 88       	st.b	r10[0x0],r8
80001bce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80001bd2:	30 09       	mov	r9,0
80001bd4:	4b 48       	lddpc	r8,80001ca4 <phy_rx_func+0xebc>
80001bd6:	91 09       	st.w	r8[0x0],r9
80001bd8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80001bdc:	4c 08       	lddpc	r8,80001cdc <phy_rx_func+0xef4>
80001bde:	70 09       	ld.w	r9,r8[0x0]
80001be0:	8e 4b       	ld.sh	r11,r7[0x8]
80001be2:	4c 0a       	lddpc	r10,80001ce0 <phy_rx_func+0xef8>
80001be4:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80001be8:	2f f9       	sub	r9,-1
80001bea:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80001bec:	4b 58       	lddpc	r8,80001cc0 <phy_rx_func+0xed8>
80001bee:	70 09       	ld.w	r9,r8[0x0]
80001bf0:	20 29       	sub	r9,2
80001bf2:	91 09       	st.w	r8[0x0],r9
80001bf4:	70 08       	ld.w	r8,r8[0x0]
80001bf6:	58 08       	cp.w	r8,0
80001bf8:	c2 f1       	brne	80001c56 <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80001bfa:	30 09       	mov	r9,0
80001bfc:	4b 88       	lddpc	r8,80001cdc <phy_rx_func+0xef4>
80001bfe:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80001c00:	8e 59       	ld.sh	r9,r7[0xa]
80001c02:	fe 78 82 12 	mov	r8,-32238
80001c06:	f0 09 19 00 	cp.h	r9,r8
80001c0a:	c2 11       	brne	80001c4c <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80001c0c:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80001c10:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80001c14:	4a f8       	lddpc	r8,80001cd0 <phy_rx_func+0xee8>
80001c16:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80001c18:	8e 59       	ld.sh	r9,r7[0xa]
80001c1a:	4a f8       	lddpc	r8,80001cd4 <phy_rx_func+0xeec>
80001c1c:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80001c1e:	8e 69       	ld.sh	r9,r7[0xc]
80001c20:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80001c22:	f0 1f 00 2e 	mcall	80001cd8 <phy_rx_func+0xef0>
80001c26:	4a 18       	lddpc	r8,80001ca8 <phy_rx_func+0xec0>
80001c28:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80001c2a:	ef 39 00 0f 	ld.ub	r9,r7[15]
80001c2e:	31 38       	mov	r8,19
80001c30:	f0 09 18 00 	cp.b	r9,r8
80001c34:	c0 71       	brne	80001c42 <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80001c36:	10 99       	mov	r9,r8
80001c38:	4a 18       	lddpc	r8,80001cbc <phy_rx_func+0xed4>
80001c3a:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80001c3c:	30 09       	mov	r9,0
80001c3e:	49 c8       	lddpc	r8,80001cac <phy_rx_func+0xec4>
80001c40:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80001c42:	30 49       	mov	r9,4
80001c44:	49 88       	lddpc	r8,80001ca4 <phy_rx_func+0xebc>
80001c46:	91 09       	st.w	r8[0x0],r9
80001c48:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80001c4c:	30 09       	mov	r9,0
80001c4e:	49 68       	lddpc	r8,80001ca4 <phy_rx_func+0xebc>
80001c50:	91 09       	st.w	r8[0x0],r9
80001c52:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80001c56:	4a dc       	lddpc	r12,80001d08 <phy_rx_func+0xf20>
80001c58:	f0 1f 00 18 	mcall	80001cb8 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80001c5c:	30 09       	mov	r9,0
80001c5e:	49 28       	lddpc	r8,80001ca4 <phy_rx_func+0xebc>
80001c60:	91 09       	st.w	r8[0x0],r9
80001c62:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80001c66:	00 00       	add	r0,r0
80001c68:	00 00       	add	r0,r0
80001c6a:	0a b0       	st.h	r5++,r0
80001c6c:	00 00       	add	r0,r0
80001c6e:	0a cc       	st.b	r5++,r12
80001c70:	00 00       	add	r0,r0
80001c72:	0a a8       	st.w	r5++,r8
80001c74:	00 00       	add	r0,r0
80001c76:	0a 88       	andn	r8,r5
80001c78:	00 00       	add	r0,r0
80001c7a:	0a 78       	tst	r8,r5
80001c7c:	00 00       	add	r0,r0
80001c7e:	0a 9c       	mov	r12,r5
80001c80:	80 00       	ld.sh	r0,r0[0x0]
80001c82:	0c 08       	add	r8,r6
80001c84:	00 00       	add	r0,r0
80001c86:	0a d0       	st.w	--r5,r0
80001c88:	80 00       	ld.sh	r0,r0[0x0]
80001c8a:	0b 38       	ld.ub	r8,r5++
80001c8c:	00 00       	add	r0,r0
80001c8e:	0a ac       	st.w	r5++,r12
80001c90:	80 00       	ld.sh	r0,r0[0x0]
80001c92:	0b 54       	ld.sh	r4,--r5
80001c94:	00 00       	add	r0,r0
80001c96:	0a dc       	st.w	--r5,r12
80001c98:	00 00       	add	r0,r0
80001c9a:	0a a4       	st.w	r5++,r4
80001c9c:	00 00       	add	r0,r0
80001c9e:	0a c0       	st.b	r5++,r0
80001ca0:	00 00       	add	r0,r0
80001ca2:	0a 94       	mov	r4,r5
80001ca4:	00 00       	add	r0,r0
80001ca6:	0a e4       	st.h	--r5,r4
80001ca8:	00 00       	add	r0,r0
80001caa:	0a bc       	st.h	r5++,r12
80001cac:	00 00       	add	r0,r0
80001cae:	0a 84       	andn	r4,r5
80001cb0:	00 00       	add	r0,r0
80001cb2:	0a 5b       	eor	r11,r5
80001cb4:	80 00       	ld.sh	r0,r0[0x0]
80001cb6:	b9 44       	asr	r4,0x18
80001cb8:	80 00       	ld.sh	r0,r0[0x0]
80001cba:	53 94       	stdsp	sp[0xe4],r4
80001cbc:	00 00       	add	r0,r0
80001cbe:	0a 90       	mov	r0,r5
80001cc0:	00 00       	add	r0,r0
80001cc2:	0a 74       	tst	r4,r5
80001cc4:	00 00       	add	r0,r0
80001cc6:	0a d8       	st.w	--r5,r8
80001cc8:	80 00       	ld.sh	r0,r0[0x0]
80001cca:	5b d8       	cp.w	r8,-3
80001ccc:	80 00       	ld.sh	r0,r0[0x0]
80001cce:	0d 88       	ld.ub	r8,r6[0x0]
80001cd0:	00 00       	add	r0,r0
80001cd2:	0a 50       	eor	r0,r5
80001cd4:	00 00       	add	r0,r0
80001cd6:	1e b4       	st.h	pc++,r4
80001cd8:	80 00       	ld.sh	r0,r0[0x0]
80001cda:	0a 98       	mov	r8,r5
80001cdc:	00 00       	add	r0,r0
80001cde:	0a b8       	st.h	r5++,r8
80001ce0:	00 00       	add	r0,r0
80001ce2:	1d b8       	ld.ub	r8,lr[0x3]
80001ce4:	00 00       	add	r0,r0
80001ce6:	0a 7c       	tst	r12,r5
80001ce8:	00 00       	add	r0,r0
80001cea:	0a 58       	eor	r8,r5
80001cec:	00 00       	add	r0,r0
80001cee:	0a 49       	or	r9,r5
80001cf0:	00 00       	add	r0,r0
80001cf2:	0a 6c       	and	r12,r5
80001cf4:	00 00       	add	r0,r0
80001cf6:	0a a0       	st.w	r5++,r0
80001cf8:	00 00       	add	r0,r0
80001cfa:	0a 5f       	eor	pc,r5
80001cfc:	00 00       	add	r0,r0
80001cfe:	1d b0       	ld.ub	r0,lr[0x3]
80001d00:	00 00       	add	r0,r0
80001d02:	0a c8       	st.b	r5++,r8
80001d04:	00 00       	add	r0,r0
80001d06:	1e b8       	st.h	pc++,r8
80001d08:	80 00       	ld.sh	r0,r0[0x0]
80001d0a:	b9 5c       	asr	r12,0x19

80001d0c <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80001d0c:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80001d0e:	49 88       	lddpc	r8,80001d6c <pdca_int_handler+0x60>
80001d10:	11 89       	ld.ub	r9,r8[0x0]
80001d12:	ec 19 00 01 	eorl	r9,0x1
80001d16:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80001d18:	11 89       	ld.ub	r9,r8[0x0]
80001d1a:	a5 69       	lsl	r9,0x4
80001d1c:	2f c9       	sub	r9,-4
80001d1e:	49 5a       	lddpc	r10,80001d70 <pdca_int_handler+0x64>
80001d20:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80001d22:	fe 7a 00 40 	mov	r10,-65472
80001d26:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80001d28:	30 39       	mov	r9,3
80001d2a:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80001d2c:	11 8a       	ld.ub	r10,r8[0x0]
80001d2e:	a5 6a       	lsl	r10,0x4
80001d30:	2f ca       	sub	r10,-4
80001d32:	49 18       	lddpc	r8,80001d74 <pdca_int_handler+0x68>
80001d34:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80001d36:	fe 78 00 00 	mov	r8,-65536
80001d3a:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80001d3c:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80001d3e:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80001d40:	48 e8       	lddpc	r8,80001d78 <pdca_int_handler+0x6c>
80001d42:	70 08       	ld.w	r8,r8[0x0]
80001d44:	58 08       	cp.w	r8,0
80001d46:	c0 70       	breq	80001d54 <pdca_int_handler+0x48>
80001d48:	48 99       	lddpc	r9,80001d6c <pdca_int_handler+0x60>
80001d4a:	13 89       	ld.ub	r9,r9[0x0]
80001d4c:	a5 69       	lsl	r9,0x4
80001d4e:	48 ac       	lddpc	r12,80001d74 <pdca_int_handler+0x68>
80001d50:	12 0c       	add	r12,r9
80001d52:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80001d54:	48 a8       	lddpc	r8,80001d7c <pdca_int_handler+0x70>
80001d56:	70 08       	ld.w	r8,r8[0x0]
80001d58:	58 08       	cp.w	r8,0
80001d5a:	c0 70       	breq	80001d68 <pdca_int_handler+0x5c>
80001d5c:	48 49       	lddpc	r9,80001d6c <pdca_int_handler+0x60>
80001d5e:	13 89       	ld.ub	r9,r9[0x0]
80001d60:	a5 69       	lsl	r9,0x4
80001d62:	48 4c       	lddpc	r12,80001d70 <pdca_int_handler+0x64>
80001d64:	12 0c       	add	r12,r9
80001d66:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80001d68:	d4 02       	popm	lr
80001d6a:	d6 03       	rete
80001d6c:	00 00       	add	r0,r0
80001d6e:	50 d8       	stdsp	sp[0x34],r8
80001d70:	00 00       	add	r0,r0
80001d72:	51 00       	stdsp	sp[0x40],r0
80001d74:	00 00       	add	r0,r0
80001d76:	50 e0       	stdsp	sp[0x38],r0
80001d78:	00 00       	add	r0,r0
80001d7a:	0a e8       	st.h	--r5,r8
80001d7c:	00 00       	add	r0,r0
80001d7e:	0a ec       	st.h	--r5,r12

80001d80 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80001d80:	fe 78 10 00 	mov	r8,-61440
80001d84:	e0 69 0d c0 	mov	r9,3520
80001d88:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80001d8c:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80001d90:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80001d94:	fe 78 34 00 	mov	r8,-52224
80001d98:	e0 69 80 00 	mov	r9,32768
80001d9c:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80001d9e:	30 09       	mov	r9,0
80001da0:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80001da2:	e0 69 04 21 	mov	r9,1057
80001da6:	ea 19 3f 20 	orh	r9,0x3f20
80001daa:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80001dac:	e0 69 02 9f 	mov	r9,671
80001db0:	ea 19 01 00 	orh	r9,0x100
80001db4:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80001db6:	e0 6a 04 02 	mov	r10,1026
80001dba:	ea 1a 3f 20 	orh	r10,0x3f20
80001dbe:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80001dc0:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80001dc2:	5e fc       	retal	r12

80001dc4 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80001dc4:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80001dc6:	30 19       	mov	r9,1
80001dc8:	49 78       	lddpc	r8,80001e24 <local_start_PDC+0x60>
80001dca:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80001dcc:	fe 78 00 00 	mov	r8,-65536
80001dd0:	30 7b       	mov	r11,7
80001dd2:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80001dd4:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80001dd6:	49 59       	lddpc	r9,80001e28 <local_start_PDC+0x64>
80001dd8:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80001ddc:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80001dde:	30 3a       	mov	r10,3
80001de0:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80001de2:	30 1c       	mov	r12,1
80001de4:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80001de6:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80001de8:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80001dea:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80001dec:	30 2c       	mov	r12,2
80001dee:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80001df0:	48 f9       	lddpc	r9,80001e2c <local_start_PDC+0x68>
80001df2:	e0 68 5a 5a 	mov	r8,23130
80001df6:	ea 18 ab cd 	orh	r8,0xabcd
80001dfa:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80001dfc:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80001dfe:	30 0e       	mov	lr,0
80001e00:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80001e02:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80001e04:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80001e06:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80001e08:	fe 78 00 40 	mov	r8,-65472
80001e0c:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80001e0e:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80001e10:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80001e14:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80001e16:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80001e18:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80001e1a:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80001e1c:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80001e1e:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80001e20:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80001e22:	d8 02       	popm	pc
80001e24:	00 00       	add	r0,r0
80001e26:	50 d8       	stdsp	sp[0x34],r8
80001e28:	00 00       	add	r0,r0
80001e2a:	50 e0       	stdsp	sp[0x38],r0
80001e2c:	00 00       	add	r0,r0
80001e2e:	51 00       	stdsp	sp[0x40],r0

80001e30 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80001e30:	48 38       	lddpc	r8,80001e3c <register_rx_tx_func+0xc>
80001e32:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80001e34:	48 38       	lddpc	r8,80001e40 <register_rx_tx_func+0x10>
80001e36:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80001e38:	5e fc       	retal	r12
80001e3a:	00 00       	add	r0,r0
80001e3c:	00 00       	add	r0,r0
80001e3e:	0a e8       	st.h	--r5,r8
80001e40:	00 00       	add	r0,r0
80001e42:	0a ec       	st.h	--r5,r12

80001e44 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80001e44:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80001e46:	fe 78 10 00 	mov	r8,-61440
80001e4a:	30 29       	mov	r9,2
80001e4c:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80001e50:	f1 49 01 04 	st.w	r8[260],r9
	
	INTC_register_interrupt (
80001e54:	30 3a       	mov	r10,3
80001e56:	36 0b       	mov	r11,96
80001e58:	49 3c       	lddpc	r12,80001ea4 <ssc_init+0x60>
80001e5a:	f0 1f 00 14 	mcall	80001ea8 <ssc_init+0x64>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0
	, AVR32_INTC_INT3
	);
	
	Enable_global_interrupt();
80001e5e:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80001e60:	fe 79 10 00 	mov	r9,-61440
80001e64:	f2 f8 01 60 	ld.w	r8,r9[352]
80001e68:	e2 18 00 02 	andl	r8,0x2,COH
80001e6c:	cf c0       	breq	80001e64 <ssc_init+0x20>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80001e6e:	fe 79 10 00 	mov	r9,-61440
80001e72:	f2 f8 01 60 	ld.w	r8,r9[352]
80001e76:	e2 18 00 02 	andl	r8,0x2,COH
80001e7a:	cf c1       	brne	80001e72 <ssc_init+0x2e>
			
	Disable_global_interrupt(); // resume to before
80001e7c:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80001e7e:	f0 1f 00 0c 	mcall	80001eac <ssc_init+0x68>

    /*config the PDCA*/
    local_start_PDC();
80001e82:	f0 1f 00 0c 	mcall	80001eb0 <ssc_init+0x6c>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80001e86:	fe 79 00 00 	mov	r9,-65536
80001e8a:	30 18       	mov	r8,1
80001e8c:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80001e8e:	fe 7a 00 40 	mov	r10,-65472
80001e92:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80001e94:	e0 6b 01 01 	mov	r11,257
80001e98:	fe 7a 34 00 	mov	r10,-52224
80001e9c:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80001e9e:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80001ea0:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80001ea2:	d8 02       	popm	pc
80001ea4:	80 00       	ld.sh	r0,r0[0x0]
80001ea6:	1d 0c       	ld.w	r12,lr++
80001ea8:	80 00       	ld.sh	r0,r0[0x0]
80001eaa:	38 18       	mov	r8,-127
80001eac:	80 00       	ld.sh	r0,r0[0x0]
80001eae:	1d 80       	ld.ub	r0,lr[0x0]
80001eb0:	80 00       	ld.sh	r0,r0[0x0]
80001eb2:	1d c4       	ld.ub	r4,lr[0x4]

80001eb4 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80001eb4:	48 28       	lddpc	r8,80001ebc <xcmp_register_app_list+0x8>
80001eb6:	91 0c       	st.w	r8[0x0],r12
}
80001eb8:	5e fc       	retal	r12
80001eba:	00 00       	add	r0,r0
80001ebc:	00 00       	add	r0,r0
80001ebe:	51 20       	stdsp	sp[0x48],r0

80001ec0 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80001ec0:	eb cd 40 80 	pushm	r7,lr
80001ec4:	fa cd 01 00 	sub	sp,sp,256
80001ec8:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80001eca:	16 98       	mov	r8,r11
80001ecc:	2f 08       	sub	r8,-16
80001ece:	af a8       	sbr	r8,0xe
80001ed0:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80001ed2:	3f f8       	mov	r8,-1
80001ed4:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80001ed6:	30 b9       	mov	r9,11
80001ed8:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80001eda:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80001edc:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80001ede:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80001ee0:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80001ee2:	f6 ca ff fe 	sub	r10,r11,-2
80001ee6:	18 9b       	mov	r11,r12
80001ee8:	fa cc ff f0 	sub	r12,sp,-16
80001eec:	f0 1f 00 05 	mcall	80001f00 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80001ef0:	2f e7       	sub	r7,-2
80001ef2:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80001ef4:	1a 9c       	mov	r12,sp
80001ef6:	f0 1f 00 04 	mcall	80001f04 <xcmp_tx+0x44>
}
80001efa:	2c 0d       	sub	sp,-256
80001efc:	e3 cd 80 80 	ldm	sp++,r7,pc
80001f00:	80 00       	ld.sh	r0,r0[0x0]
80001f02:	5a 90       	cp.w	r0,-23
80001f04:	80 00       	ld.sh	r0,r0[0x0]
80001f06:	24 cc       	sub	r12,76

80001f08 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80001f08:	d4 21       	pushm	r4-r7,lr
80001f0a:	fa cd 00 d0 	sub	sp,sp,208
80001f0e:	18 94       	mov	r4,r12
80001f10:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80001f12:	e0 68 01 00 	mov	r8,256
80001f16:	f0 0b 19 00 	cp.h	r11,r8
80001f1a:	e0 8b 00 36 	brhi	80001f86 <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80001f1e:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80001f22:	e0 68 04 1d 	mov	r8,1053
80001f26:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80001f28:	30 18       	mov	r8,1
80001f2a:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80001f2c:	32 08       	mov	r8,32
80001f2e:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80001f30:	30 28       	mov	r8,2
80001f32:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80001f34:	30 48       	mov	r8,4
80001f36:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80001f38:	ea 1a 0c 00 	orh	r10,0xc00
80001f3c:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80001f3e:	30 4a       	mov	r10,4
80001f40:	1a 9b       	mov	r11,sp
80001f42:	fa cc ff f4 	sub	r12,sp,-12
80001f46:	f0 1f 00 12 	mcall	80001f8c <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80001f4a:	30 f8       	mov	r8,15
80001f4c:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80001f50:	3a 78       	mov	r8,-89
80001f52:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80001f56:	30 08       	mov	r8,0
80001f58:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80001f5c:	0e 9a       	mov	r10,r7
80001f5e:	5c 7a       	castu.h	r10
80001f60:	f4 08 16 08 	lsr	r8,r10,0x8
80001f64:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80001f68:	0e 96       	mov	r6,r7
80001f6a:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80001f6e:	08 9b       	mov	r11,r4
80001f70:	fa cc ff eb 	sub	r12,sp,-21
80001f74:	f0 1f 00 06 	mcall	80001f8c <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80001f78:	ee cb ff f3 	sub	r11,r7,-13
80001f7c:	5c 5b       	castu.b	r11
80001f7e:	fa cc ff fa 	sub	r12,sp,-6
80001f82:	f0 1f 00 04 	mcall	80001f90 <xcmp_data_session_req+0x88>
}
80001f86:	2c cd       	sub	sp,-208
80001f88:	d8 22       	popm	r4-r7,pc
80001f8a:	00 00       	add	r0,r0
80001f8c:	80 00       	ld.sh	r0,r0[0x0]
80001f8e:	5a 90       	cp.w	r0,-23
80001f90:	80 00       	ld.sh	r0,r0[0x0]
80001f92:	1e c0       	st.b	pc++,r0

80001f94 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80001f94:	d4 01       	pushm	lr
80001f96:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80001f9a:	fe 78 b4 00 	mov	r8,-19456
80001f9e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80001fa0:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80001fa4:	30 89       	mov	r9,8
80001fa6:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80001fa8:	30 19       	mov	r9,1
80001faa:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80001fac:	30 09       	mov	r9,0
80001fae:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80001fb0:	30 5a       	mov	r10,5
80001fb2:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80001fb4:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80001fb6:	30 7a       	mov	r10,7
80001fb8:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80001fba:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80001fbc:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80001fbe:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80001fc2:	30 9b       	mov	r11,9
80001fc4:	fa cc ff fe 	sub	r12,sp,-2
80001fc8:	f0 1f 00 02 	mcall	80001fd0 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80001fcc:	2c dd       	sub	sp,-204
80001fce:	d8 02       	popm	pc
80001fd0:	80 00       	ld.sh	r0,r0[0x0]
80001fd2:	1e c0       	st.b	pc++,r0

80001fd4 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80001fd4:	d4 01       	pushm	lr
80001fd6:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80001fda:	fe 78 80 00 	mov	r8,-32768
80001fde:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80001fe0:	30 38       	mov	r8,3
80001fe2:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80001fe4:	30 1b       	mov	r11,1
80001fe6:	fa cc ff fe 	sub	r12,sp,-2
80001fea:	f0 1f 00 03 	mcall	80001ff4 <xcmp_opcode_not_supported+0x20>
}
80001fee:	2c dd       	sub	sp,-204
80001ff0:	d8 02       	popm	pc
80001ff2:	00 00       	add	r0,r0
80001ff4:	80 00       	ld.sh	r0,r0[0x0]
80001ff6:	1e c0       	st.b	pc++,r0

80001ff8 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80001ff8:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80001ffa:	96 88       	ld.uh	r8,r11[0x0]
80001ffc:	e2 18 f0 00 	andl	r8,0xf000,COH
80002000:	e0 48 80 00 	cp.w	r8,32768
80002004:	c0 f0       	breq	80002022 <xcmp_exec_func+0x2a>
80002006:	e0 48 b0 00 	cp.w	r8,45056
8000200a:	c1 20       	breq	8000202e <xcmp_exec_func+0x36>
8000200c:	58 08       	cp.w	r8,0
8000200e:	c1 51       	brne	80002038 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80002010:	78 08       	ld.w	r8,r12[0x0]
80002012:	58 08       	cp.w	r8,0
80002014:	c0 40       	breq	8000201c <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80002016:	16 9c       	mov	r12,r11
80002018:	5d 18       	icall	r8
8000201a:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
8000201c:	f0 1f 00 08 	mcall	8000203c <xcmp_exec_func+0x44>
80002020:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80002022:	78 18       	ld.w	r8,r12[0x4]
80002024:	58 08       	cp.w	r8,0
80002026:	c0 90       	breq	80002038 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80002028:	16 9c       	mov	r12,r11
8000202a:	5d 18       	icall	r8
8000202c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
8000202e:	78 28       	ld.w	r8,r12[0x8]
80002030:	58 08       	cp.w	r8,0
80002032:	c0 30       	breq	80002038 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80002034:	16 9c       	mov	r12,r11
80002036:	5d 18       	icall	r8
80002038:	d8 02       	popm	pc
8000203a:	00 00       	add	r0,r0
8000203c:	80 00       	ld.sh	r0,r0[0x0]
8000203e:	1f d4       	ld.ub	r4,pc[0x5]

80002040 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80002040:	d4 01       	pushm	lr
80002042:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80002046:	e0 68 04 09 	mov	r8,1033
8000204a:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
8000204c:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80002050:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
80002052:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
80002056:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80002058:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
8000205a:	30 09       	mov	r9,0
8000205c:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
8000205e:	fb 69 00 08 	st.b	sp[8],r9
80002062:	fa c8 ff f7 	sub	r8,sp,-9
80002066:	b0 89       	st.b	r8[0x0],r9
80002068:	fa c8 ff f6 	sub	r8,sp,-10
8000206c:	b0 89       	st.b	r8[0x0],r9
8000206e:	fa c8 ff f5 	sub	r8,sp,-11
80002072:	b0 89       	st.b	r8[0x0],r9
80002074:	fa c8 ff f4 	sub	r8,sp,-12
80002078:	b0 89       	st.b	r8[0x0],r9
8000207a:	fa c8 ff f3 	sub	r8,sp,-13
8000207e:	b0 89       	st.b	r8[0x0],r9
80002080:	fa c8 ff f2 	sub	r8,sp,-14
80002084:	b0 89       	st.b	r8[0x0],r9
80002086:	fa c8 ff f1 	sub	r8,sp,-15
8000208a:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
8000208c:	30 cb       	mov	r11,12
8000208e:	fa cc ff fe 	sub	r12,sp,-2
80002092:	f0 1f 00 03 	mcall	8000209c <xcmp_IdleTestTone+0x5c>
}
80002096:	2c dd       	sub	sp,-204
80002098:	d8 02       	popm	pc
8000209a:	00 00       	add	r0,r0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	1e c0       	st.b	pc++,r0

800020a0 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
800020a0:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
800020a2:	48 dc       	lddpc	r12,800020d4 <xcmp_init+0x34>
800020a4:	f0 1f 00 0d 	mcall	800020d8 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
800020a8:	30 4b       	mov	r11,4
800020aa:	31 4c       	mov	r12,20
800020ac:	f0 1f 00 0c 	mcall	800020dc <xcmp_init+0x3c>
800020b0:	48 c8       	lddpc	r8,800020e0 <xcmp_init+0x40>
800020b2:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
800020b4:	30 09       	mov	r9,0
800020b6:	1a d9       	st.w	--sp,r9
800020b8:	1a d9       	st.w	--sp,r9
800020ba:	1a d9       	st.w	--sp,r9
800020bc:	30 38       	mov	r8,3
800020be:	e0 6a 01 80 	mov	r10,384
800020c2:	48 9b       	lddpc	r11,800020e4 <xcmp_init+0x44>
800020c4:	48 9c       	lddpc	r12,800020e8 <xcmp_init+0x48>
800020c6:	f0 1f 00 0a 	mcall	800020ec <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
800020ca:	f0 1f 00 0a 	mcall	800020f0 <xcmp_init+0x50>
800020ce:	2f dd       	sub	sp,-12
	
}
800020d0:	d8 02       	popm	pc
800020d2:	00 00       	add	r0,r0
800020d4:	80 00       	ld.sh	r0,r0[0x0]
800020d6:	21 f0       	sub	r0,31
800020d8:	80 00       	ld.sh	r0,r0[0x0]
800020da:	22 3c       	sub	r12,35
800020dc:	80 00       	ld.sh	r0,r0[0x0]
800020de:	47 28       	lddsp	r8,sp[0x1c8]
800020e0:	00 00       	add	r0,r0
800020e2:	0b 08       	ld.w	r8,r5++
800020e4:	80 00       	ld.sh	r0,r0[0x0]
800020e6:	b9 88       	lsr	r8,0x18
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	20 f4       	sub	r4,15
800020ec:	80 00       	ld.sh	r0,r0[0x0]
800020ee:	4e 44       	lddpc	r4,8000227c <xnl_init+0x8>
800020f0:	80 00       	ld.sh	r0,r0[0x0]
800020f2:	22 74       	sub	r4,39

800020f4 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
800020f4:	d4 31       	pushm	r0-r7,lr
800020f6:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800020f8:	4b 16       	lddpc	r6,800021bc <xcmp_rx_process+0xc8>
800020fa:	30 05       	mov	r5,0
800020fc:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800020fe:	4b 13       	lddpc	r3,800021c0 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80002100:	4b 12       	lddpc	r2,800021c4 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80002102:	4b 21       	lddpc	r1,800021c8 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80002104:	4b 20       	lddpc	r0,800021cc <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80002106:	6c 0c       	ld.w	r12,r6[0x0]
80002108:	0a 99       	mov	r9,r5
8000210a:	08 9a       	mov	r10,r4
8000210c:	1a 9b       	mov	r11,sp
8000210e:	f0 1f 00 31 	mcall	800021d0 <xcmp_rx_process+0xdc>
80002112:	58 1c       	cp.w	r12,1
80002114:	cf 91       	brne	80002106 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80002116:	40 0b       	lddsp	r11,sp[0x0]
80002118:	58 0b       	cp.w	r11,0
8000211a:	cf 60       	breq	80002106 <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
8000211c:	96 0a       	ld.sh	r10,r11[0x0]
8000211e:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80002122:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80002126:	59 c8       	cp.w	r8,28
80002128:	c1 e0       	breq	80002164 <xcmp_rx_process+0x70>
8000212a:	e0 89 00 07 	brgt	80002138 <xcmp_rx_process+0x44>
8000212e:	58 e8       	cp.w	r8,14
80002130:	c0 e0       	breq	8000214c <xcmp_rx_process+0x58>
80002132:	58 f8       	cp.w	r8,15
80002134:	c2 41       	brne	8000217c <xcmp_rx_process+0x88>
80002136:	c0 f8       	rjmp	80002154 <xcmp_rx_process+0x60>
80002138:	e0 48 01 09 	cp.w	r8,265
8000213c:	c1 80       	breq	8000216c <xcmp_rx_process+0x78>
8000213e:	e0 48 01 0a 	cp.w	r8,266
80002142:	c1 90       	breq	80002174 <xcmp_rx_process+0x80>
80002144:	e0 48 00 2c 	cp.w	r8,44
80002148:	c1 a1       	brne	8000217c <xcmp_rx_process+0x88>
8000214a:	c0 98       	rjmp	8000215c <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
8000214c:	4a 2c       	lddpc	r12,800021d4 <xcmp_rx_process+0xe0>
8000214e:	f0 1f 00 23 	mcall	800021d8 <xcmp_rx_process+0xe4>
					break;
80002152:	c2 f8       	rjmp	800021b0 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80002154:	4a 2c       	lddpc	r12,800021dc <xcmp_rx_process+0xe8>
80002156:	f0 1f 00 21 	mcall	800021d8 <xcmp_rx_process+0xe4>
					break;
8000215a:	c2 b8       	rjmp	800021b0 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
8000215c:	4a 1c       	lddpc	r12,800021e0 <xcmp_rx_process+0xec>
8000215e:	f0 1f 00 1f 	mcall	800021d8 <xcmp_rx_process+0xe4>
					break;
80002162:	c2 78       	rjmp	800021b0 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80002164:	04 9c       	mov	r12,r2
80002166:	f0 1f 00 1d 	mcall	800021d8 <xcmp_rx_process+0xe4>
						, ptr);
					break;
8000216a:	c2 38       	rjmp	800021b0 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000216c:	02 9c       	mov	r12,r1
8000216e:	f0 1f 00 1b 	mcall	800021d8 <xcmp_rx_process+0xe4>
					break;
80002172:	c1 f8       	rjmp	800021b0 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80002174:	00 9c       	mov	r12,r0
80002176:	f0 1f 00 19 	mcall	800021d8 <xcmp_rx_process+0xe4>
					break;
8000217a:	c1 b8       	rjmp	800021b0 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
8000217c:	12 98       	mov	r8,r9
8000217e:	e2 18 04 00 	andl	r8,0x400,COH
80002182:	c0 70       	breq	80002190 <xcmp_rx_process+0x9c>
80002184:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80002188:	e0 48 00 68 	cp.w	r8,104
8000218c:	e0 8a 00 08 	brle	8000219c <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80002190:	e2 19 f0 00 	andl	r9,0xf000,COH
80002194:	c0 e1       	brne	800021b0 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80002196:	f0 1f 00 14 	mcall	800021e4 <xcmp_rx_process+0xf0>
8000219a:	c0 b8       	rjmp	800021b0 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
8000219c:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800021a0:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800021a4:	49 19       	lddpc	r9,800021e8 <xcmp_rx_process+0xf4>
800021a6:	72 08       	ld.w	r8,r9[0x0]
800021a8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800021ac:	f0 1f 00 0b 	mcall	800021d8 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800021b0:	66 0c       	ld.w	r12,r3[0x0]
800021b2:	40 0b       	lddsp	r11,sp[0x0]
800021b4:	f0 1f 00 0e 	mcall	800021ec <xcmp_rx_process+0xf8>
800021b8:	ca 7b       	rjmp	80002106 <xcmp_rx_process+0x12>
800021ba:	00 00       	add	r0,r0
800021bc:	00 00       	add	r0,r0
800021be:	0b 08       	ld.w	r8,r5++
800021c0:	00 00       	add	r0,r0
800021c2:	0a 9c       	mov	r12,r5
800021c4:	00 00       	add	r0,r0
800021c6:	0b 18       	ld.sh	r8,r5++
800021c8:	00 00       	add	r0,r0
800021ca:	0b 0c       	ld.w	r12,r5++
800021cc:	00 00       	add	r0,r0
800021ce:	0a fc       	st.b	--r5,r12
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	44 1c       	lddsp	r12,sp[0x104]
800021d4:	00 00       	add	r0,r0
800021d6:	0b 30       	ld.ub	r0,r5++
800021d8:	80 00       	ld.sh	r0,r0[0x0]
800021da:	1f f8       	ld.ub	r8,pc[0x7]
800021dc:	00 00       	add	r0,r0
800021de:	0a f0       	st.b	--r5,r0
800021e0:	00 00       	add	r0,r0
800021e2:	0b 24       	ld.uh	r4,r5++
800021e4:	80 00       	ld.sh	r0,r0[0x0]
800021e6:	1f d4       	ld.ub	r4,pc[0x5]
800021e8:	00 00       	add	r0,r0
800021ea:	51 20       	stdsp	sp[0x48],r0
800021ec:	80 00       	ld.sh	r0,r0[0x0]
800021ee:	0b 8c       	ld.ub	r12,r5[0x0]

800021f0 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800021f0:	eb cd 40 90 	pushm	r4,r7,lr
800021f4:	20 1d       	sub	sp,4
800021f6:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800021fa:	48 c8       	lddpc	r8,80002228 <xcmp_rx+0x38>
800021fc:	70 0c       	ld.w	r12,r8[0x0]
800021fe:	f0 1f 00 0c 	mcall	8000222c <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80002202:	c1 00       	breq	80002222 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80002204:	fa c7 ff fc 	sub	r7,sp,-4
80002208:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
8000220a:	e0 6a 00 ca 	mov	r10,202
8000220e:	08 9b       	mov	r11,r4
80002210:	f0 1f 00 08 	mcall	80002230 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80002214:	48 88       	lddpc	r8,80002234 <xcmp_rx+0x44>
80002216:	70 0c       	ld.w	r12,r8[0x0]
80002218:	30 09       	mov	r9,0
8000221a:	12 9a       	mov	r10,r9
8000221c:	1a 9b       	mov	r11,sp
8000221e:	f0 1f 00 07 	mcall	80002238 <xcmp_rx+0x48>
	}	
}
80002222:	2f fd       	sub	sp,-4
80002224:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80002228:	00 00       	add	r0,r0
8000222a:	0a 9c       	mov	r12,r5
8000222c:	80 00       	ld.sh	r0,r0[0x0]
8000222e:	0d 38       	ld.ub	r8,r6++
80002230:	80 00       	ld.sh	r0,r0[0x0]
80002232:	5a 90       	cp.w	r0,-23
80002234:	00 00       	add	r0,r0
80002236:	0b 08       	ld.w	r8,r5++
80002238:	80 00       	ld.sh	r0,r0[0x0]
8000223a:	46 28       	lddsp	r8,sp[0x188]

8000223c <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
8000223c:	48 28       	lddpc	r8,80002244 <xnl_register_xcmp_func+0x8>
8000223e:	91 0c       	st.w	r8[0x0],r12
}
80002240:	5e fc       	retal	r12
80002242:	00 00       	add	r0,r0
80002244:	00 00       	add	r0,r0
80002246:	0b 5c       	ld.sh	r12,--r5

80002248 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80002248:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
8000224a:	48 88       	lddpc	r8,80002268 <xnl_get_msg_ack_func+0x20>
8000224c:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
8000224e:	98 49       	ld.sh	r9,r12[0x8]
80002250:	f0 09 19 00 	cp.h	r9,r8
80002254:	c0 81       	brne	80002264 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80002256:	48 68       	lddpc	r8,8000226c <xnl_get_msg_ack_func+0x24>
80002258:	70 0c       	ld.w	r12,r8[0x0]
8000225a:	30 09       	mov	r9,0
8000225c:	12 9a       	mov	r10,r9
8000225e:	12 9b       	mov	r11,r9
80002260:	f0 1f 00 04 	mcall	80002270 <xnl_get_msg_ack_func+0x28>
80002264:	d8 02       	popm	pc
80002266:	00 00       	add	r0,r0
80002268:	00 00       	add	r0,r0
8000226a:	0b 42       	ld.w	r2,--r5
8000226c:	00 00       	add	r0,r0
8000226e:	0b 3c       	ld.ub	r12,r5++
80002270:	80 00       	ld.sh	r0,r0[0x0]
80002272:	46 28       	lddsp	r8,sp[0x188]

80002274 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80002274:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
80002278:	30 09       	mov	r9,0
8000227a:	4b 78       	lddpc	r8,80002354 <xnl_init+0xe0>
8000227c:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
8000227e:	30 0b       	mov	r11,0
80002280:	30 1c       	mov	r12,1
80002282:	f0 1f 00 36 	mcall	80002358 <xnl_init+0xe4>
80002286:	4b 68       	lddpc	r8,8000235c <xnl_init+0xe8>
80002288:	91 0c       	st.w	r8[0x0],r12
8000228a:	70 08       	ld.w	r8,r8[0x0]
8000228c:	58 08       	cp.w	r8,0
8000228e:	c0 80       	breq	8000229e <xnl_init+0x2a>
80002290:	4b 38       	lddpc	r8,8000235c <xnl_init+0xe8>
80002292:	70 0c       	ld.w	r12,r8[0x0]
80002294:	30 09       	mov	r9,0
80002296:	12 9a       	mov	r10,r9
80002298:	12 9b       	mov	r11,r9
8000229a:	f0 1f 00 32 	mcall	80002360 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
8000229e:	30 4b       	mov	r11,4
800022a0:	31 4c       	mov	r12,20
800022a2:	f0 1f 00 2e 	mcall	80002358 <xnl_init+0xe4>
800022a6:	4b 08       	lddpc	r8,80002364 <xnl_init+0xf0>
800022a8:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800022aa:	30 4b       	mov	r11,4
800022ac:	31 ec       	mov	r12,30
800022ae:	f0 1f 00 2b 	mcall	80002358 <xnl_init+0xe4>
800022b2:	4a e8       	lddpc	r8,80002368 <xnl_init+0xf4>
800022b4:	91 0c       	st.w	r8[0x0],r12
800022b6:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800022b8:	10 96       	mov	r6,r8
800022ba:	4a d5       	lddpc	r5,8000236c <xnl_init+0xf8>
800022bc:	6c 0c       	ld.w	r12,r6[0x0]
800022be:	ea 07 00 0b 	add	r11,r5,r7
800022c2:	f0 1f 00 2c 	mcall	80002370 <xnl_init+0xfc>
800022c6:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
800022ca:	e0 47 1e 00 	cp.w	r7,7680
800022ce:	cf 71       	brne	800022bc <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800022d0:	30 4b       	mov	r11,4
800022d2:	31 4c       	mov	r12,20
800022d4:	f0 1f 00 21 	mcall	80002358 <xnl_init+0xe4>
800022d8:	4a 78       	lddpc	r8,80002374 <xnl_init+0x100>
800022da:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800022dc:	30 4b       	mov	r11,4
800022de:	30 ac       	mov	r12,10
800022e0:	f0 1f 00 1e 	mcall	80002358 <xnl_init+0xe4>
800022e4:	4a 58       	lddpc	r8,80002378 <xnl_init+0x104>
800022e6:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
800022e8:	30 4b       	mov	r11,4
800022ea:	30 ac       	mov	r12,10
800022ec:	f0 1f 00 1b 	mcall	80002358 <xnl_init+0xe4>
800022f0:	4a 38       	lddpc	r8,8000237c <xnl_init+0x108>
800022f2:	91 0c       	st.w	r8[0x0],r12
800022f4:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
800022f6:	10 96       	mov	r6,r8
800022f8:	4a 25       	lddpc	r5,80002380 <xnl_init+0x10c>
800022fa:	6c 0c       	ld.w	r12,r6[0x0]
800022fc:	ea 07 00 0b 	add	r11,r5,r7
80002300:	f0 1f 00 1c 	mcall	80002370 <xnl_init+0xfc>
80002304:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80002308:	e0 47 14 00 	cp.w	r7,5120
8000230c:	cf 71       	brne	800022fa <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000230e:	30 4b       	mov	r11,4
80002310:	30 5c       	mov	r12,5
80002312:	f0 1f 00 12 	mcall	80002358 <xnl_init+0xe4>
80002316:	49 c8       	lddpc	r8,80002384 <xnl_init+0x110>
80002318:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
8000231a:	30 07       	mov	r7,0
8000231c:	1a d7       	st.w	--sp,r7
8000231e:	1a d7       	st.w	--sp,r7
80002320:	1a d7       	st.w	--sp,r7
80002322:	30 38       	mov	r8,3
80002324:	0e 99       	mov	r9,r7
80002326:	e0 6a 02 00 	mov	r10,512
8000232a:	49 8b       	lddpc	r11,80002388 <xnl_init+0x114>
8000232c:	49 8c       	lddpc	r12,8000238c <xnl_init+0x118>
8000232e:	f0 1f 00 19 	mcall	80002390 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80002332:	1a d7       	st.w	--sp,r7
80002334:	1a d7       	st.w	--sp,r7
80002336:	1a d7       	st.w	--sp,r7
80002338:	30 38       	mov	r8,3
8000233a:	0e 99       	mov	r9,r7
8000233c:	e0 6a 03 20 	mov	r10,800
80002340:	49 5b       	lddpc	r11,80002394 <xnl_init+0x120>
80002342:	49 6c       	lddpc	r12,80002398 <xnl_init+0x124>
80002344:	f0 1f 00 13 	mcall	80002390 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80002348:	f0 1f 00 15 	mcall	8000239c <xnl_init+0x128>
8000234c:	2f ad       	sub	sp,-24
}
8000234e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002352:	00 00       	add	r0,r0
80002354:	00 00       	add	r0,r0
80002356:	0b 42       	ld.w	r2,--r5
80002358:	80 00       	ld.sh	r0,r0[0x0]
8000235a:	47 28       	lddsp	r8,sp[0x1c8]
8000235c:	00 00       	add	r0,r0
8000235e:	0b 3c       	ld.ub	r12,r5++
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	46 28       	lddsp	r8,sp[0x188]
80002364:	00 00       	add	r0,r0
80002366:	0b 50       	ld.sh	r0,--r5
80002368:	00 00       	add	r0,r0
8000236a:	0a 9c       	mov	r12,r5
8000236c:	00 00       	add	r0,r0
8000236e:	32 d2       	mov	r2,45
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	0b 8c       	ld.ub	r12,r5[0x0]
80002374:	00 00       	add	r0,r0
80002376:	0a d4       	st.w	--r5,r4
80002378:	00 00       	add	r0,r0
8000237a:	0a b0       	st.h	r5++,r0
8000237c:	00 00       	add	r0,r0
8000237e:	0a a4       	st.w	r5++,r4
80002380:	00 00       	add	r0,r0
80002382:	1e d2       	st.w	--pc,r2
80002384:	00 00       	add	r0,r0
80002386:	0a 98       	mov	r8,r5
80002388:	80 00       	ld.sh	r0,r0[0x0]
8000238a:	b9 90       	lsr	r0,0x19
8000238c:	80 00       	ld.sh	r0,r0[0x0]
8000238e:	23 a0       	sub	r0,58
80002390:	80 00       	ld.sh	r0,r0[0x0]
80002392:	4e 44       	lddpc	r4,80002520 <xnl_tx+0x54>
80002394:	80 00       	ld.sh	r0,r0[0x0]
80002396:	b2 00       	st.h	r9[0x0],r0
80002398:	80 00       	ld.sh	r0,r0[0x0]
8000239a:	24 00       	sub	r0,64
8000239c:	80 00       	ld.sh	r0,r0[0x0]
8000239e:	0d 60       	ld.uh	r0,--r6

800023a0 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
800023a0:	eb cd 40 fe 	pushm	r1-r7,lr
800023a4:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800023a6:	49 26       	lddpc	r6,800023ec <xnl_rx_process+0x4c>
800023a8:	30 05       	mov	r5,0
800023aa:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800023ac:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800023ae:	49 11       	lddpc	r1,800023f0 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800023b0:	49 12       	lddpc	r2,800023f4 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800023b2:	6c 0c       	ld.w	r12,r6[0x0]
800023b4:	0a 99       	mov	r9,r5
800023b6:	08 9a       	mov	r10,r4
800023b8:	1a 9b       	mov	r11,sp
800023ba:	f0 1f 00 10 	mcall	800023f8 <xnl_rx_process+0x58>
800023be:	58 1c       	cp.w	r12,1
800023c0:	cf 91       	brne	800023b2 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
800023c2:	40 0c       	lddsp	r12,sp[0x0]
800023c4:	58 0c       	cp.w	r12,0
800023c6:	cf 60       	breq	800023b2 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800023c8:	98 28       	ld.sh	r8,r12[0x4]
800023ca:	e6 08 19 00 	cp.h	r8,r3
800023ce:	e0 8b 00 0a 	brhi	800023e2 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800023d2:	5c 78       	castu.h	r8
800023d4:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
800023d8:	58 09       	cp.w	r9,0
800023da:	c0 40       	breq	800023e2 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
800023dc:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
800023e0:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800023e2:	62 0c       	ld.w	r12,r1[0x0]
800023e4:	40 0b       	lddsp	r11,sp[0x0]
800023e6:	f0 1f 00 06 	mcall	800023fc <xnl_rx_process+0x5c>
800023ea:	ce 4b       	rjmp	800023b2 <xnl_rx_process+0x12>
800023ec:	00 00       	add	r0,r0
800023ee:	0a b0       	st.h	r5++,r0
800023f0:	00 00       	add	r0,r0
800023f2:	0a 9c       	mov	r12,r5
800023f4:	00 00       	add	r0,r0
800023f6:	04 f4       	st.b	--r2,r4
800023f8:	80 00       	ld.sh	r0,r0[0x0]
800023fa:	44 1c       	lddsp	r12,sp[0x104]
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	0b 8c       	ld.ub	r12,r5[0x0]

80002400 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80002400:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80002402:	4a a6       	lddpc	r6,800024a8 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80002404:	4a a2       	lddpc	r2,800024ac <xnl_tx_process+0xac>
80002406:	4a b4       	lddpc	r4,800024b0 <xnl_tx_process+0xb0>
80002408:	30 07       	mov	r7,0
8000240a:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
8000240c:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000240e:	4a a5       	lddpc	r5,800024b4 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80002410:	4a a3       	lddpc	r3,800024b8 <xnl_tx_process+0xb8>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80002412:	6c 08       	ld.w	r8,r6[0x0]
80002414:	58 08       	cp.w	r8,0
80002416:	c0 40       	breq	8000241e <xnl_tx_process+0x1e>
80002418:	58 18       	cp.w	r8,1
8000241a:	cf d1       	brne	80002414 <xnl_tx_process+0x14>
8000241c:	c2 48       	rjmp	80002464 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000241e:	64 0c       	ld.w	r12,r2[0x0]
80002420:	0e 99       	mov	r9,r7
80002422:	02 9a       	mov	r10,r1
80002424:	08 9b       	mov	r11,r4
80002426:	f0 1f 00 26 	mcall	800024bc <xnl_tx_process+0xbc>
8000242a:	58 1c       	cp.w	r12,1
8000242c:	cf 31       	brne	80002412 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
8000242e:	68 0b       	ld.w	r11,r4[0x0]
80002430:	58 0b       	cp.w	r11,0
80002432:	cf 00       	breq	80002412 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80002434:	96 28       	ld.sh	r8,r11[0x4]
80002436:	e0 08 19 00 	cp.h	r8,r0
8000243a:	c0 71       	brne	80002448 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
8000243c:	4a 18       	lddpc	r8,800024c0 <xnl_tx_process+0xc0>
8000243e:	70 08       	ld.w	r8,r8[0x0]
80002440:	10 9c       	mov	r12,r8
80002442:	f0 1f 00 21 	mcall	800024c4 <xnl_tx_process+0xc4>
						break;
80002446:	ce 6b       	rjmp	80002412 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80002448:	16 9c       	mov	r12,r11
8000244a:	f0 1f 00 20 	mcall	800024c8 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000244e:	30 18       	mov	r8,1
80002450:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80002452:	66 0c       	ld.w	r12,r3[0x0]
80002454:	0e 99       	mov	r9,r7
80002456:	0e 9a       	mov	r10,r7
80002458:	0e 9b       	mov	r11,r7
8000245a:	f0 1f 00 19 	mcall	800024bc <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
8000245e:	30 18       	mov	r8,1
80002460:	8d 08       	st.w	r6[0x0],r8
80002462:	cd 8b       	rjmp	80002412 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80002464:	66 0c       	ld.w	r12,r3[0x0]
80002466:	0e 99       	mov	r9,r7
80002468:	36 4a       	mov	r10,100
8000246a:	0e 9b       	mov	r11,r7
8000246c:	f0 1f 00 14 	mcall	800024bc <xnl_tx_process+0xbc>
80002470:	58 1c       	cp.w	r12,1
80002472:	c0 81       	brne	80002482 <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
80002474:	49 38       	lddpc	r8,800024c0 <xnl_tx_process+0xc0>
80002476:	70 0c       	ld.w	r12,r8[0x0]
80002478:	68 0b       	ld.w	r11,r4[0x0]
8000247a:	f0 1f 00 13 	mcall	800024c4 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
8000247e:	8d 07       	st.w	r6[0x0],r7
80002480:	cc 9b       	rjmp	80002412 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80002482:	6a 08       	ld.w	r8,r5[0x0]
80002484:	58 38       	cp.w	r8,3
80002486:	e0 89 00 09 	brgt	80002498 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
8000248a:	68 0c       	ld.w	r12,r4[0x0]
8000248c:	f0 1f 00 0f 	mcall	800024c8 <xnl_tx_process+0xc8>
						xnl_send_times++;
80002490:	6a 08       	ld.w	r8,r5[0x0]
80002492:	2f f8       	sub	r8,-1
80002494:	8b 08       	st.w	r5[0x0],r8
80002496:	cb eb       	rjmp	80002412 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80002498:	48 a8       	lddpc	r8,800024c0 <xnl_tx_process+0xc0>
8000249a:	70 0c       	ld.w	r12,r8[0x0]
8000249c:	68 0b       	ld.w	r11,r4[0x0]
8000249e:	f0 1f 00 0a 	mcall	800024c4 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800024a2:	8d 07       	st.w	r6[0x0],r7
800024a4:	cb 7b       	rjmp	80002412 <xnl_tx_process+0x12>
800024a6:	00 00       	add	r0,r0
800024a8:	00 00       	add	r0,r0
800024aa:	0b 4c       	ld.w	r12,--r5
800024ac:	00 00       	add	r0,r0
800024ae:	0b 50       	ld.sh	r0,--r5
800024b0:	00 00       	add	r0,r0
800024b2:	0b 58       	ld.sh	r8,--r5
800024b4:	00 00       	add	r0,r0
800024b6:	0b 54       	ld.sh	r4,--r5
800024b8:	00 00       	add	r0,r0
800024ba:	0b 3c       	ld.ub	r12,r5++
800024bc:	80 00       	ld.sh	r0,r0[0x0]
800024be:	44 1c       	lddsp	r12,sp[0x104]
800024c0:	00 00       	add	r0,r0
800024c2:	0a 9c       	mov	r12,r5
800024c4:	80 00       	ld.sh	r0,r0[0x0]
800024c6:	0b 8c       	ld.ub	r12,r5[0x0]
800024c8:	80 00       	ld.sh	r0,r0[0x0]
800024ca:	0b ac       	ld.ub	r12,r5[0x2]

800024cc <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800024cc:	eb cd 40 c0 	pushm	r6-r7,lr
800024d0:	20 1d       	sub	sp,4
800024d2:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800024d4:	98 39       	ld.sh	r9,r12[0x6]
800024d6:	3f f8       	mov	r8,-1
800024d8:	f0 09 19 00 	cp.h	r9,r8
800024dc:	c0 a1       	brne	800024f0 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800024de:	4a e9       	lddpc	r9,80002594 <xnl_tx+0xc8>
800024e0:	13 88       	ld.ub	r8,r9[0x0]
800024e2:	2f f8       	sub	r8,-1
800024e4:	5c 58       	castu.b	r8
800024e6:	b2 88       	st.b	r9[0x0],r8
800024e8:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800024ec:	a9 a8       	sbr	r8,0x8
800024ee:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800024f0:	8c 49       	ld.sh	r9,r6[0x8]
800024f2:	3f f8       	mov	r8,-1
800024f4:	f0 09 19 00 	cp.h	r9,r8
800024f8:	c0 41       	brne	80002500 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800024fa:	4a 88       	lddpc	r8,80002598 <xnl_tx+0xcc>
800024fc:	90 18       	ld.sh	r8,r8[0x2]
800024fe:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80002500:	8c 59       	ld.sh	r9,r6[0xa]
80002502:	3f f8       	mov	r8,-1
80002504:	f0 09 19 00 	cp.h	r9,r8
80002508:	c0 41       	brne	80002510 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
8000250a:	4a 48       	lddpc	r8,80002598 <xnl_tx+0xcc>
8000250c:	90 28       	ld.sh	r8,r8[0x4]
8000250e:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80002510:	8c 69       	ld.sh	r9,r6[0xc]
80002512:	3f f8       	mov	r8,-1
80002514:	f0 09 19 00 	cp.h	r9,r8
80002518:	c0 e1       	brne	80002534 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
8000251a:	4a 08       	lddpc	r8,80002598 <xnl_tx+0xcc>
8000251c:	90 49       	ld.sh	r9,r8[0x8]
8000251e:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80002520:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80002522:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80002524:	90 49       	ld.sh	r9,r8[0x8]
80002526:	e0 19 ff 00 	andl	r9,0xff00
8000252a:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
8000252e:	f3 e8 10 08 	or	r8,r9,r8
80002532:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80002534:	0d 98       	ld.ub	r8,r6[0x1]
80002536:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80002538:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000253c:	10 0c       	add	r12,r8
8000253e:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80002540:	58 0c       	cp.w	r12,0
80002542:	e0 89 00 04 	brgt	8000254a <xnl_tx+0x7e>
80002546:	30 09       	mov	r9,0
80002548:	c0 d8       	rjmp	80002562 <xnl_tx+0x96>
8000254a:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
8000254e:	2f ec       	sub	r12,-2
80002550:	30 09       	mov	r9,0
80002552:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80002554:	15 1b       	ld.sh	r11,r10++
80002556:	f6 09 00 09 	add	r9,r11,r9
8000255a:	5c 89       	casts.h	r9
		indextohWord     += 1;
8000255c:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000255e:	18 38       	cp.w	r8,r12
80002560:	cf a1       	brne	80002554 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80002562:	5c 39       	neg	r9
80002564:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80002566:	48 e8       	lddpc	r8,8000259c <xnl_tx+0xd0>
80002568:	70 0c       	ld.w	r12,r8[0x0]
8000256a:	f0 1f 00 0e 	mcall	800025a0 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
8000256e:	c1 00       	breq	8000258e <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80002570:	fa c7 ff fc 	sub	r7,sp,-4
80002574:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80002576:	e0 6a 01 00 	mov	r10,256
8000257a:	0c 9b       	mov	r11,r6
8000257c:	f0 1f 00 0a 	mcall	800025a4 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80002580:	48 a8       	lddpc	r8,800025a8 <xnl_tx+0xdc>
80002582:	70 0c       	ld.w	r12,r8[0x0]
80002584:	30 09       	mov	r9,0
80002586:	12 9a       	mov	r10,r9
80002588:	1a 9b       	mov	r11,sp
8000258a:	f0 1f 00 09 	mcall	800025ac <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
8000258e:	2f fd       	sub	sp,-4
80002590:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002594:	00 00       	add	r0,r0
80002596:	0b 40       	ld.w	r0,--r5
80002598:	00 00       	add	r0,r0
8000259a:	0b 42       	ld.w	r2,--r5
8000259c:	00 00       	add	r0,r0
8000259e:	0a 9c       	mov	r12,r5
800025a0:	80 00       	ld.sh	r0,r0[0x0]
800025a2:	0d 38       	ld.ub	r8,r6++
800025a4:	80 00       	ld.sh	r0,r0[0x0]
800025a6:	5a 90       	cp.w	r0,-23
800025a8:	00 00       	add	r0,r0
800025aa:	0b 50       	ld.sh	r0,--r5
800025ac:	80 00       	ld.sh	r0,r0[0x0]
800025ae:	46 28       	lddsp	r8,sp[0x188]

800025b0 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800025b0:	eb cd 40 80 	pushm	r7,lr
800025b4:	fa cd 01 00 	sub	sp,sp,256
800025b8:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800025ba:	e0 68 40 0e 	mov	r8,16398
800025be:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800025c0:	3f f8       	mov	r8,-1
800025c2:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
800025c4:	30 c8       	mov	r8,12
800025c6:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
800025c8:	98 38       	ld.sh	r8,r12[0x6]
800025ca:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
800025cc:	98 58       	ld.sh	r8,r12[0xa]
800025ce:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
800025d0:	98 48       	ld.sh	r8,r12[0x8]
800025d2:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
800025d4:	98 68       	ld.sh	r8,r12[0xc]
800025d6:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
800025d8:	30 08       	mov	r8,0
800025da:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800025dc:	1a 9c       	mov	r12,sp
800025de:	f0 1f 00 0a 	mcall	80002604 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
800025e2:	fa cd 00 cc 	sub	sp,sp,204
800025e6:	e0 6a 00 ca 	mov	r10,202
800025ea:	ee cb ff f0 	sub	r11,r7,-16
800025ee:	1a 9c       	mov	r12,sp
800025f0:	f0 1f 00 06 	mcall	80002608 <xnl_data_msg_func+0x58>
800025f4:	48 68       	lddpc	r8,8000260c <xnl_data_msg_func+0x5c>
800025f6:	70 08       	ld.w	r8,r8[0x0]
800025f8:	5d 18       	icall	r8
800025fa:	fa cd ff 34 	sub	sp,sp,-204
}
800025fe:	2c 0d       	sub	sp,-256
80002600:	e3 cd 80 80 	ldm	sp++,r7,pc
80002604:	80 00       	ld.sh	r0,r0[0x0]
80002606:	24 cc       	sub	r12,76
80002608:	80 00       	ld.sh	r0,r0[0x0]
8000260a:	5a 90       	cp.w	r0,-23
8000260c:	00 00       	add	r0,r0
8000260e:	0b 5c       	ld.sh	r12,--r5

80002610 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80002610:	d4 21       	pushm	r4-r7,lr
80002612:	fa cd 01 00 	sub	sp,sp,256
80002616:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80002618:	4c 28       	lddpc	r8,80002720 <xnl_device_auth_reply_func+0x110>
8000261a:	11 88       	ld.ub	r8,r8[0x0]
8000261c:	58 08       	cp.w	r8,0
8000261e:	e0 81 00 7f 	brne	8000271c <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80002622:	4c 18       	lddpc	r8,80002724 <xnl_device_auth_reply_func+0x114>
80002624:	70 0c       	ld.w	r12,r8[0x0]
80002626:	30 09       	mov	r9,0
80002628:	12 9a       	mov	r10,r9
8000262a:	12 9b       	mov	r11,r9
8000262c:	f0 1f 00 3f 	mcall	80002728 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80002630:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80002634:	4b b8       	lddpc	r8,80002720 <xnl_device_auth_reply_func+0x110>
80002636:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80002638:	ef 39 00 12 	ld.ub	r9,r7[18]
8000263c:	ef 38 00 13 	ld.ub	r8,r7[19]
80002640:	b1 68       	lsl	r8,0x10
80002642:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80002646:	ef 38 00 15 	ld.ub	r8,r7[21]
8000264a:	f3 e8 10 08 	or	r8,r9,r8
8000264e:	ef 39 00 14 	ld.ub	r9,r7[20]
80002652:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80002656:	ef 3a 00 16 	ld.ub	r10,r7[22]
8000265a:	ef 38 00 17 	ld.ub	r8,r7[23]
8000265e:	b1 68       	lsl	r8,0x10
80002660:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80002664:	ef 38 00 19 	ld.ub	r8,r7[25]
80002668:	f5 e8 10 08 	or	r8,r10,r8
8000266c:	ef 3a 00 18 	ld.ub	r10,r7[24]
80002670:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80002674:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80002676:	e0 64 79 b9 	mov	r4,31161
8000267a:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
8000267e:	e0 65 45 07 	mov	r5,17671
80002682:	ea 15 8a bd 	orh	r5,0x8abd
80002686:	e0 66 f9 3d 	mov	r6,63805
8000268a:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
8000268e:	e0 6e b8 cf 	mov	lr,47311
80002692:	ea 1e 36 83 	orh	lr,0x3683
80002696:	e0 67 aa 1c 	mov	r7,43548
8000269a:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000269e:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800026a0:	f4 08 00 0c 	add	r12,r10,r8
800026a4:	f0 0b 15 04 	lsl	r11,r8,0x4
800026a8:	0a 0b       	add	r11,r5
800026aa:	f9 eb 20 0b 	eor	r11,r12,r11
800026ae:	f0 0c 16 05 	lsr	r12,r8,0x5
800026b2:	0c 0c       	add	r12,r6
800026b4:	18 5b       	eor	r11,r12
800026b6:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800026b8:	f2 0c 15 04 	lsl	r12,r9,0x4
800026bc:	1c 0c       	add	r12,lr
800026be:	f2 0b 16 05 	lsr	r11,r9,0x5
800026c2:	0e 0b       	add	r11,r7
800026c4:	f9 eb 20 0b 	eor	r11,r12,r11
800026c8:	f2 0a 00 0c 	add	r12,r9,r10
800026cc:	18 5b       	eor	r11,r12
800026ce:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
800026d0:	e0 6b 37 20 	mov	r11,14112
800026d4:	ea 1b c6 ef 	orh	r11,0xc6ef
800026d8:	16 3a       	cp.w	r10,r11
800026da:	ce 21       	brne	8000269e <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
800026dc:	e0 6a 40 1a 	mov	r10,16410
800026e0:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800026e2:	3f fa       	mov	r10,-1
800026e4:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
800026e6:	30 6b       	mov	r11,6
800026e8:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800026ea:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800026ec:	48 db       	lddpc	r11,80002720 <xnl_device_auth_reply_func+0x110>
800026ee:	96 1c       	ld.sh	r12,r11[0x2]
800026f0:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
800026f2:	96 2b       	ld.sh	r11,r11[0x4]
800026f4:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800026f6:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
800026f8:	30 ca       	mov	r10,12
800026fa:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
800026fc:	30 0a       	mov	r10,0
800026fe:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80002702:	30 7a       	mov	r10,7
80002704:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80002708:	30 2a       	mov	r10,2
8000270a:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000270e:	fa ca ff ec 	sub	r10,sp,-20
80002712:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80002714:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80002716:	1a 9c       	mov	r12,sp
80002718:	f0 1f 00 05 	mcall	8000272c <xnl_device_auth_reply_func+0x11c>
}
8000271c:	2c 0d       	sub	sp,-256
8000271e:	d8 22       	popm	r4-r7,pc
80002720:	00 00       	add	r0,r0
80002722:	0b 42       	ld.w	r2,--r5
80002724:	00 00       	add	r0,r0
80002726:	0b 3c       	ld.ub	r12,r5++
80002728:	80 00       	ld.sh	r0,r0[0x0]
8000272a:	46 28       	lddsp	r8,sp[0x188]
8000272c:	80 00       	ld.sh	r0,r0[0x0]
8000272e:	24 cc       	sub	r12,76

80002730 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80002730:	eb cd 40 80 	pushm	r7,lr
80002734:	fa cd 01 00 	sub	sp,sp,256
80002738:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
8000273a:	49 28       	lddpc	r8,80002780 <xnl_master_status_brdcst_func+0x50>
8000273c:	11 88       	ld.ub	r8,r8[0x0]
8000273e:	58 08       	cp.w	r8,0
80002740:	c1 c1       	brne	80002778 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80002742:	49 18       	lddpc	r8,80002784 <xnl_master_status_brdcst_func+0x54>
80002744:	70 0c       	ld.w	r12,r8[0x0]
80002746:	30 09       	mov	r9,0
80002748:	12 9a       	mov	r10,r9
8000274a:	12 9b       	mov	r11,r9
8000274c:	f0 1f 00 0f 	mcall	80002788 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80002750:	8e 58       	ld.sh	r8,r7[0xa]
80002752:	48 c9       	lddpc	r9,80002780 <xnl_master_status_brdcst_func+0x50>
80002754:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80002756:	e0 68 40 0e 	mov	r8,16398
8000275a:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000275c:	3f f8       	mov	r8,-1
8000275e:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80002760:	30 4a       	mov	r10,4
80002762:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80002764:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80002766:	92 19       	ld.sh	r9,r9[0x2]
80002768:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
8000276a:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000276c:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
8000276e:	30 08       	mov	r8,0
80002770:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80002772:	1a 9c       	mov	r12,sp
80002774:	f0 1f 00 06 	mcall	8000278c <xnl_master_status_brdcst_func+0x5c>
}
80002778:	2c 0d       	sub	sp,-256
8000277a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000277e:	00 00       	add	r0,r0
80002780:	00 00       	add	r0,r0
80002782:	0b 42       	ld.w	r2,--r5
80002784:	00 00       	add	r0,r0
80002786:	0b 3c       	ld.ub	r12,r5++
80002788:	80 00       	ld.sh	r0,r0[0x0]
8000278a:	46 28       	lddsp	r8,sp[0x188]
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	24 cc       	sub	r12,76

80002790 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80002790:	eb cd 40 80 	pushm	r7,lr
80002794:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80002796:	49 28       	lddpc	r8,800027dc <xnl_device_conn_reply_func+0x4c>
80002798:	70 0c       	ld.w	r12,r8[0x0]
8000279a:	30 09       	mov	r9,0
8000279c:	12 9a       	mov	r10,r9
8000279e:	12 9b       	mov	r11,r9
800027a0:	f0 1f 00 10 	mcall	800027e0 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800027a4:	ef 18 00 10 	ld.uh	r8,r7[16]
800027a8:	10 99       	mov	r9,r8
800027aa:	e2 19 ff 00 	andl	r9,0xff00,COH
800027ae:	e0 49 01 00 	cp.w	r9,256
800027b2:	c0 60       	breq	800027be <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800027b4:	0e 9c       	mov	r12,r7
800027b6:	f0 1f 00 0c 	mcall	800027e4 <xnl_device_conn_reply_func+0x54>
800027ba:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
800027be:	a9 68       	lsl	r8,0x8
800027c0:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800027c4:	48 98       	lddpc	r8,800027e8 <xnl_device_conn_reply_func+0x58>
800027c6:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
800027c8:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
800027cc:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
800027ce:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
800027d2:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
800027d4:	30 19       	mov	r9,1
800027d6:	b0 89       	st.b	r8[0x0],r9
800027d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800027dc:	00 00       	add	r0,r0
800027de:	0b 3c       	ld.ub	r12,r5++
800027e0:	80 00       	ld.sh	r0,r0[0x0]
800027e2:	46 28       	lddsp	r8,sp[0x188]
800027e4:	80 00       	ld.sh	r0,r0[0x0]
800027e6:	27 30       	sub	r0,115
800027e8:	00 00       	add	r0,r0
800027ea:	0b 42       	ld.w	r2,--r5

800027ec <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
800027ec:	d4 01       	pushm	lr
800027ee:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800027f2:	e0 68 40 0e 	mov	r8,16398
800027f6:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800027f8:	3f f8       	mov	r8,-1
800027fa:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
800027fc:	30 38       	mov	r8,3
800027fe:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80002800:	30 08       	mov	r8,0
80002802:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80002804:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80002806:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80002808:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
8000280a:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000280c:	1a 9c       	mov	r12,sp
8000280e:	f0 1f 00 03 	mcall	80002818 <xnl_send_device_master_query+0x2c>
}
80002812:	2c 0d       	sub	sp,-256
80002814:	d8 02       	popm	pc
80002816:	00 00       	add	r0,r0
80002818:	80 00       	ld.sh	r0,r0[0x0]
8000281a:	24 cc       	sub	r12,76

8000281c <RC522_SPI_SetSpeed>:
	SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
8000281c:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
8000281e:	48 78       	lddpc	r8,80002838 <RC522_SPI_SetSpeed+0x1c>
80002820:	70 09       	ld.w	r9,r8[0x0]
80002822:	72 ca       	ld.w	r10,r9[0x30]
80002824:	5c 7c       	castu.h	r12
80002826:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
8000282a:	f9 ea 10 0a 	or	r10,r12,r10
8000282e:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
80002830:	70 0c       	ld.w	r12,r8[0x0]
80002832:	f0 1f 00 03 	mcall	8000283c <RC522_SPI_SetSpeed+0x20>
		
	
}
80002836:	d8 02       	popm	pc
80002838:	00 00       	add	r0,r0
8000283a:	1d ac       	ld.ub	r12,lr[0x2]
8000283c:	80 00       	ld.sh	r0,r0[0x0]
8000283e:	3b 18       	mov	r8,-79

80002840 <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
80002840:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0400);//baudDiv=4
80002842:	e0 6c 04 00 	mov	r12,1024
80002846:	f0 1f 00 02 	mcall	8000284c <RC522_SPI_SetSpeedLow+0xc>
	
}
8000284a:	d8 02       	popm	pc
8000284c:	80 00       	ld.sh	r0,r0[0x0]
8000284e:	28 1c       	sub	r12,-127

80002850 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
80002850:	eb cd 40 c0 	pushm	r6-r7,lr
	U16 *Data ;

	//蹇椤昏锋芥ｅ父璇诲
	spi_selectChip(spi, DF_SPI_PCS_0);
80002854:	48 b7       	lddpc	r7,80002880 <RC522_ReadByte+0x30>
80002856:	30 0b       	mov	r11,0
80002858:	6e 0c       	ld.w	r12,r7[0x0]
8000285a:	f0 1f 00 0b 	mcall	80002884 <RC522_ReadByte+0x34>
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
8000285e:	e0 6b 00 ff 	mov	r11,255
80002862:	6e 0c       	ld.w	r12,r7[0x0]
80002864:	f0 1f 00 09 	mcall	80002888 <RC522_ReadByte+0x38>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
80002868:	30 06       	mov	r6,0
8000286a:	0c 9b       	mov	r11,r6
8000286c:	6e 0c       	ld.w	r12,r7[0x0]
8000286e:	f0 1f 00 08 	mcall	8000288c <RC522_ReadByte+0x3c>

	/*!< Return the shifted data */
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80002872:	0c 9b       	mov	r11,r6
80002874:	6e 0c       	ld.w	r12,r7[0x0]
80002876:	f0 1f 00 07 	mcall	80002890 <RC522_ReadByte+0x40>
	
	return (U8)(*Data);
	
}
8000287a:	0d 9c       	ld.ub	r12,r6[0x1]
8000287c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002880:	00 00       	add	r0,r0
80002882:	1d ac       	ld.ub	r12,lr[0x2]
80002884:	80 00       	ld.sh	r0,r0[0x0]
80002886:	3c 84       	mov	r4,-56
80002888:	80 00       	ld.sh	r0,r0[0x0]
8000288a:	3b 1e       	mov	lr,-79
8000288c:	80 00       	ld.sh	r0,r0[0x0]
8000288e:	3b 3a       	mov	r10,-77
80002890:	80 00       	ld.sh	r0,r0[0x0]
80002892:	3c 44       	mov	r4,-60

80002894 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
80002894:	eb cd 40 c0 	pushm	r6-r7,lr
80002898:	20 1d       	sub	sp,4
8000289a:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	spi_selectChip(spi, DF_SPI_PCS_0);
8000289c:	48 c7       	lddpc	r7,800028cc <RC522_WriteByte+0x38>
8000289e:	30 0b       	mov	r11,0
800028a0:	6e 0c       	ld.w	r12,r7[0x0]
800028a2:	f0 1f 00 0c 	mcall	800028d0 <RC522_WriteByte+0x3c>
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
800028a6:	1b 8b       	ld.ub	r11,sp[0x0]
800028a8:	6e 0c       	ld.w	r12,r7[0x0]
800028aa:	f0 1f 00 0b 	mcall	800028d4 <RC522_WriteByte+0x40>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
800028ae:	1a 9b       	mov	r11,sp
800028b0:	6e 0c       	ld.w	r12,r7[0x0]
800028b2:	f0 1f 00 0a 	mcall	800028d8 <RC522_WriteByte+0x44>
800028b6:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800028b8:	30 0b       	mov	r11,0
800028ba:	6e 0c       	ld.w	r12,r7[0x0]
800028bc:	f0 1f 00 08 	mcall	800028dc <RC522_WriteByte+0x48>
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
800028c0:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
800028c4:	2f fd       	sub	sp,-4
800028c6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800028ca:	00 00       	add	r0,r0
800028cc:	00 00       	add	r0,r0
800028ce:	1d ac       	ld.ub	r12,lr[0x2]
800028d0:	80 00       	ld.sh	r0,r0[0x0]
800028d2:	3c 84       	mov	r4,-56
800028d4:	80 00       	ld.sh	r0,r0[0x0]
800028d6:	3b 1e       	mov	lr,-79
800028d8:	80 00       	ld.sh	r0,r0[0x0]
800028da:	3b 3a       	mov	r10,-77
800028dc:	80 00       	ld.sh	r0,r0[0x0]
800028de:	3c 44       	mov	r4,-60

800028e0 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
800028e0:	eb cd 40 c0 	pushm	r6-r7,lr
800028e4:	18 96       	mov	r6,r12
800028e6:	16 97       	mov	r7,r11
	U8   ucAddr;

	CLR_SPI_CS;	
800028e8:	31 8c       	mov	r12,24
800028ea:	f0 1f 00 09 	mcall	8000290c <WriteRawRC+0x2c>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
800028ee:	ec 0c 15 01 	lsl	r12,r6,0x1
800028f2:	e2 1c 00 7e 	andl	r12,0x7e,COH
800028f6:	f0 1f 00 07 	mcall	80002910 <WriteRawRC+0x30>
	RC522_WriteByte(value);
800028fa:	0e 9c       	mov	r12,r7
800028fc:	f0 1f 00 05 	mcall	80002910 <WriteRawRC+0x30>
	
	SET_SPI_CS;
80002900:	31 8c       	mov	r12,24
80002902:	f0 1f 00 05 	mcall	80002914 <WriteRawRC+0x34>

}
80002906:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000290a:	00 00       	add	r0,r0
8000290c:	80 00       	ld.sh	r0,r0[0x0]
8000290e:	37 f8       	mov	r8,127
80002910:	80 00       	ld.sh	r0,r0[0x0]
80002912:	28 94       	sub	r4,-119
80002914:	80 00       	ld.sh	r0,r0[0x0]
80002916:	37 dc       	mov	r12,125

80002918 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
80002918:	d4 01       	pushm	lr

	SET_RC522RST;
8000291a:	31 9c       	mov	r12,25
8000291c:	f0 1f 00 1b 	mcall	80002988 <PcdReset+0x70>
	delay_ns(10);
80002920:	30 ac       	mov	r12,10
80002922:	f0 1f 00 1b 	mcall	8000298c <PcdReset+0x74>

	CLR_RC522RST;
80002926:	31 9c       	mov	r12,25
80002928:	f0 1f 00 1a 	mcall	80002990 <PcdReset+0x78>
	delay_ns(10);
8000292c:	30 ac       	mov	r12,10
8000292e:	f0 1f 00 18 	mcall	8000298c <PcdReset+0x74>

	SET_RC522RST;
80002932:	31 9c       	mov	r12,25
80002934:	f0 1f 00 15 	mcall	80002988 <PcdReset+0x70>
	delay_ns(10);
80002938:	30 ac       	mov	r12,10
8000293a:	f0 1f 00 15 	mcall	8000298c <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
8000293e:	30 fb       	mov	r11,15
80002940:	30 1c       	mov	r12,1
80002942:	f0 1f 00 15 	mcall	80002994 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80002946:	30 fb       	mov	r11,15
80002948:	30 1c       	mov	r12,1
8000294a:	f0 1f 00 13 	mcall	80002994 <PcdReset+0x7c>
	delay_ns(10);
8000294e:	30 ac       	mov	r12,10
80002950:	f0 1f 00 0f 	mcall	8000298c <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80002954:	33 db       	mov	r11,61
80002956:	31 1c       	mov	r12,17
80002958:	f0 1f 00 0f 	mcall	80002994 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
8000295c:	31 eb       	mov	r11,30
8000295e:	32 dc       	mov	r12,45
80002960:	f0 1f 00 0d 	mcall	80002994 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80002964:	30 0b       	mov	r11,0
80002966:	32 cc       	mov	r12,44
80002968:	f0 1f 00 0b 	mcall	80002994 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
8000296c:	e0 6b 00 8d 	mov	r11,141
80002970:	32 ac       	mov	r12,42
80002972:	f0 1f 00 09 	mcall	80002994 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
80002976:	33 eb       	mov	r11,62
80002978:	32 bc       	mov	r12,43
8000297a:	f0 1f 00 07 	mcall	80002994 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
8000297e:	34 0b       	mov	r11,64
80002980:	31 5c       	mov	r12,21
80002982:	f0 1f 00 05 	mcall	80002994 <PcdReset+0x7c>
	
	return MI_OK;
}
80002986:	d8 0a       	popm	pc,r12=0
80002988:	80 00       	ld.sh	r0,r0[0x0]
8000298a:	37 dc       	mov	r12,125
8000298c:	80 00       	ld.sh	r0,r0[0x0]
8000298e:	31 d8       	mov	r8,29
80002990:	80 00       	ld.sh	r0,r0[0x0]
80002992:	37 f8       	mov	r8,127
80002994:	80 00       	ld.sh	r0,r0[0x0]
80002996:	28 e0       	sub	r0,-114

80002998 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
80002998:	eb cd 40 80 	pushm	r7,lr
8000299c:	18 97       	mov	r7,r12
	U8   ucAddr;
	U8   ucResult=0;
	CLR_SPI_CS;	
8000299e:	31 8c       	mov	r12,24
800029a0:	f0 1f 00 0a 	mcall	800029c8 <ReadRawRC+0x30>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
800029a4:	ee 08 15 01 	lsl	r8,r7,0x1
800029a8:	10 9c       	mov	r12,r8
800029aa:	e2 1c 00 7e 	andl	r12,0x7e,COH
800029ae:	a7 bc       	sbr	r12,0x7
800029b0:	f0 1f 00 07 	mcall	800029cc <ReadRawRC+0x34>
	ucResult = RC522_ReadByte();
800029b4:	f0 1f 00 07 	mcall	800029d0 <ReadRawRC+0x38>
800029b8:	18 97       	mov	r7,r12
	
	SET_SPI_CS;
800029ba:	31 8c       	mov	r12,24
800029bc:	f0 1f 00 06 	mcall	800029d4 <ReadRawRC+0x3c>
	return ucResult;
}
800029c0:	0e 9c       	mov	r12,r7
800029c2:	e3 cd 80 80 	ldm	sp++,r7,pc
800029c6:	00 00       	add	r0,r0
800029c8:	80 00       	ld.sh	r0,r0[0x0]
800029ca:	37 f8       	mov	r8,127
800029cc:	80 00       	ld.sh	r0,r0[0x0]
800029ce:	28 94       	sub	r4,-119
800029d0:	80 00       	ld.sh	r0,r0[0x0]
800029d2:	28 50       	sub	r0,-123
800029d4:	80 00       	ld.sh	r0,r0[0x0]
800029d6:	37 dc       	mov	r12,125

800029d8 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
800029d8:	eb cd 40 c0 	pushm	r6-r7,lr
800029dc:	18 97       	mov	r7,r12
800029de:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
800029e0:	f0 1f 00 05 	mcall	800029f4 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
800029e4:	f9 e6 10 0b 	or	r11,r12,r6
800029e8:	5c 5b       	castu.b	r11
800029ea:	0e 9c       	mov	r12,r7
800029ec:	f0 1f 00 03 	mcall	800029f8 <SetBitMask+0x20>
}
800029f0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800029f4:	80 00       	ld.sh	r0,r0[0x0]
800029f6:	29 98       	sub	r8,-103
800029f8:	80 00       	ld.sh	r0,r0[0x0]
800029fa:	28 e0       	sub	r0,-114

800029fc <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
800029fc:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
800029fe:	31 4c       	mov	r12,20
80002a00:	f0 1f 00 05 	mcall	80002a14 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80002a04:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80002a08:	c0 51       	brne	80002a12 <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
80002a0a:	30 3b       	mov	r11,3
80002a0c:	31 4c       	mov	r12,20
80002a0e:	f0 1f 00 03 	mcall	80002a18 <PcdAntennaOn+0x1c>
80002a12:	d8 02       	popm	pc
80002a14:	80 00       	ld.sh	r0,r0[0x0]
80002a16:	29 98       	sub	r8,-103
80002a18:	80 00       	ld.sh	r0,r0[0x0]
80002a1a:	29 d8       	sub	r8,-99

80002a1c <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80002a1c:	eb cd 40 c0 	pushm	r6-r7,lr
80002a20:	18 97       	mov	r7,r12
80002a22:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80002a24:	f0 1f 00 06 	mcall	80002a3c <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80002a28:	5c d6       	com	r6
80002a2a:	f9 e6 00 06 	and	r6,r12,r6
80002a2e:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80002a32:	0e 9c       	mov	r12,r7
80002a34:	f0 1f 00 03 	mcall	80002a40 <ClearBitMask+0x24>
	
}
80002a38:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002a3c:	80 00       	ld.sh	r0,r0[0x0]
80002a3e:	29 98       	sub	r8,-103
80002a40:	80 00       	ld.sh	r0,r0[0x0]
80002a42:	28 e0       	sub	r0,-114

80002a44 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
80002a44:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
80002a46:	30 3b       	mov	r11,3
80002a48:	31 4c       	mov	r12,20
80002a4a:	f0 1f 00 02 	mcall	80002a50 <PcdAntennaOff+0xc>
}
80002a4e:	d8 02       	popm	pc
80002a50:	80 00       	ld.sh	r0,r0[0x0]
80002a52:	2a 1c       	sub	r12,-95

80002a54 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
80002a54:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
80002a56:	34 18       	mov	r8,65
80002a58:	f0 0c 18 00 	cp.b	r12,r8
80002a5c:	c0 20       	breq	80002a60 <M500PcdConfigISOType+0xc>
80002a5e:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80002a60:	30 8b       	mov	r11,8
80002a62:	16 9c       	mov	r12,r11
80002a64:	f0 1f 00 14 	mcall	80002ab4 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
80002a68:	33 db       	mov	r11,61
80002a6a:	31 1c       	mov	r12,17
80002a6c:	f0 1f 00 13 	mcall	80002ab8 <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80002a70:	e0 6b 00 86 	mov	r11,134
80002a74:	31 7c       	mov	r12,23
80002a76:	f0 1f 00 11 	mcall	80002ab8 <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
80002a7a:	37 fb       	mov	r11,127
80002a7c:	32 6c       	mov	r12,38
80002a7e:	f0 1f 00 0f 	mcall	80002ab8 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
80002a82:	31 eb       	mov	r11,30
80002a84:	32 dc       	mov	r12,45
80002a86:	f0 1f 00 0d 	mcall	80002ab8 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
80002a8a:	30 0b       	mov	r11,0
80002a8c:	32 cc       	mov	r12,44
80002a8e:	f0 1f 00 0b 	mcall	80002ab8 <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
80002a92:	e0 6b 00 8d 	mov	r11,141
80002a96:	32 ac       	mov	r12,42
80002a98:	f0 1f 00 08 	mcall	80002ab8 <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80002a9c:	33 eb       	mov	r11,62
80002a9e:	32 bc       	mov	r12,43
80002aa0:	f0 1f 00 06 	mcall	80002ab8 <M500PcdConfigISOType+0x64>
		delay_ns(1000);
80002aa4:	e0 6c 03 e8 	mov	r12,1000
80002aa8:	f0 1f 00 05 	mcall	80002abc <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80002aac:	f0 1f 00 05 	mcall	80002ac0 <M500PcdConfigISOType+0x6c>
80002ab0:	d8 0a       	popm	pc,r12=0
80002ab2:	00 00       	add	r0,r0
80002ab4:	80 00       	ld.sh	r0,r0[0x0]
80002ab6:	2a 1c       	sub	r12,-95
80002ab8:	80 00       	ld.sh	r0,r0[0x0]
80002aba:	28 e0       	sub	r0,-114
80002abc:	80 00       	ld.sh	r0,r0[0x0]
80002abe:	31 d8       	mov	r8,29
80002ac0:	80 00       	ld.sh	r0,r0[0x0]
80002ac2:	29 fc       	sub	r12,-97

80002ac4 <rc522_init>:


//mfrc522 init

void rc522_init()
{
80002ac4:	eb cd 40 c0 	pushm	r6-r7,lr
80002ac8:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80002aca:	4a 28       	lddpc	r8,80002b50 <rc522_init+0x8c>
80002acc:	1a 96       	mov	r6,sp
80002ace:	f0 ea 00 00 	ld.d	r10,r8[0]
80002ad2:	fa eb 00 00 	st.d	sp[0],r10
80002ad6:	f0 e8 00 08 	ld.d	r8,r8[8]
80002ada:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80002ade:	30 4b       	mov	r11,4
80002ae0:	49 dc       	lddpc	r12,80002b54 <rc522_init+0x90>
80002ae2:	f0 1f 00 1e 	mcall	80002b58 <rc522_init+0x94>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80002ae6:	31 9c       	mov	r12,25
80002ae8:	f0 1f 00 1d 	mcall	80002b5c <rc522_init+0x98>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80002aec:	31 9c       	mov	r12,25
80002aee:	f0 1f 00 1d 	mcall	80002b60 <rc522_init+0x9c>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
80002af2:	49 d7       	lddpc	r7,80002b64 <rc522_init+0xa0>
80002af4:	fe 7c 24 00 	mov	r12,-56320
80002af8:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80002afa:	1a 9b       	mov	r11,sp
80002afc:	f0 1f 00 1b 	mcall	80002b68 <rc522_init+0xa4>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80002b00:	30 09       	mov	r9,0
80002b02:	12 9a       	mov	r10,r9
80002b04:	12 9b       	mov	r11,r9
80002b06:	6e 0c       	ld.w	r12,r7[0x0]
80002b08:	f0 1f 00 19 	mcall	80002b6c <rc522_init+0xa8>

	// Enable SPI.
	spi_enable(spi);
80002b0c:	6e 0c       	ld.w	r12,r7[0x0]
80002b0e:	f0 1f 00 19 	mcall	80002b70 <rc522_init+0xac>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80002b12:	e0 6a 36 00 	mov	r10,13824
80002b16:	ea 1a 01 6e 	orh	r10,0x16e
80002b1a:	1a 9b       	mov	r11,sp
80002b1c:	6e 0c       	ld.w	r12,r7[0x0]
80002b1e:	f0 1f 00 16 	mcall	80002b74 <rc522_init+0xb0>
80002b22:	c0 50       	breq	80002b2c <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80002b24:	30 29       	mov	r9,2
80002b26:	49 58       	lddpc	r8,80002b78 <rc522_init+0xb4>
80002b28:	b0 89       	st.b	r8[0x0],r9
80002b2a:	c0 38       	rjmp	80002b30 <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80002b2c:	f0 1f 00 14 	mcall	80002b7c <rc522_init+0xb8>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80002b30:	f0 1f 00 14 	mcall	80002b80 <rc522_init+0xbc>
	
	PcdAntennaOff();
80002b34:	f0 1f 00 14 	mcall	80002b84 <rc522_init+0xc0>
	
	delay_ms(2); 
80002b38:	30 2c       	mov	r12,2
80002b3a:	f0 1f 00 14 	mcall	80002b88 <rc522_init+0xc4>
	
	PcdAntennaOn();
80002b3e:	f0 1f 00 14 	mcall	80002b8c <rc522_init+0xc8>
	
	M500PcdConfigISOType( 'A' );
80002b42:	34 1c       	mov	r12,65
80002b44:	f0 1f 00 13 	mcall	80002b90 <rc522_init+0xcc>
	

80002b48:	2f cd       	sub	sp,-16
80002b4a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002b4e:	00 00       	add	r0,r0
80002b50:	80 00       	ld.sh	r0,r0[0x0]
80002b52:	b9 c0       	cbr	r0,0x18
80002b54:	80 00       	ld.sh	r0,r0[0x0]
80002b56:	b9 98       	lsr	r8,0x19
80002b58:	80 00       	ld.sh	r0,r0[0x0]
80002b5a:	37 94       	mov	r4,121
80002b5c:	80 00       	ld.sh	r0,r0[0x0]
80002b5e:	37 c4       	mov	r4,124
80002b60:	80 00       	ld.sh	r0,r0[0x0]
80002b62:	37 dc       	mov	r12,125
80002b64:	00 00       	add	r0,r0
80002b66:	1d ac       	ld.ub	r12,lr[0x2]
80002b68:	80 00       	ld.sh	r0,r0[0x0]
80002b6a:	3a b4       	mov	r4,-85
80002b6c:	80 00       	ld.sh	r0,r0[0x0]
80002b6e:	3a ec       	mov	r12,-82
80002b70:	80 00       	ld.sh	r0,r0[0x0]
80002b72:	3b 18       	mov	r8,-79
80002b74:	80 00       	ld.sh	r0,r0[0x0]
80002b76:	3b 5c       	mov	r12,-75
80002b78:	00 00       	add	r0,r0
80002b7a:	0b 60       	ld.uh	r0,--r5
80002b7c:	80 00       	ld.sh	r0,r0[0x0]
80002b7e:	28 40       	sub	r0,-124
80002b80:	80 00       	ld.sh	r0,r0[0x0]
80002b82:	29 18       	sub	r8,-111
80002b84:	80 00       	ld.sh	r0,r0[0x0]
80002b86:	2a 44       	sub	r4,-92
80002b88:	80 00       	ld.sh	r0,r0[0x0]
80002b8a:	32 18       	mov	r8,33
80002b8c:	80 00       	ld.sh	r0,r0[0x0]
80002b8e:	29 fc       	sub	r12,-97
80002b90:	80 00       	ld.sh	r0,r0[0x0]
80002b92:	2a 54       	sub	r4,-91

80002b94 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80002b94:	d4 31       	pushm	r0-r7,lr
80002b96:	20 1d       	sub	sp,4
80002b98:	18 92       	mov	r2,r12
80002b9a:	16 95       	mov	r5,r11
80002b9c:	14 96       	mov	r6,r10
80002b9e:	50 09       	stdsp	sp[0x0],r9
80002ba0:	10 90       	mov	r0,r8
80002ba2:	f8 c8 00 0c 	sub	r8,r12,12
80002ba6:	5c 58       	castu.b	r8
80002ba8:	30 29       	mov	r9,2
80002baa:	f2 08 18 00 	cp.b	r8,r9
80002bae:	e0 88 00 05 	brls	80002bb8 <PcdComMF522+0x24>
80002bb2:	30 03       	mov	r3,0
80002bb4:	06 91       	mov	r1,r3
80002bb6:	c0 78       	rjmp	80002bc4 <PcdComMF522+0x30>
80002bb8:	4c f9       	lddpc	r9,80002cf4 <PcdComMF522+0x160>
80002bba:	f2 08 07 01 	ld.ub	r1,r9[r8]
80002bbe:	4c f9       	lddpc	r9,80002cf8 <PcdComMF522+0x164>
80002bc0:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80002bc4:	02 9b       	mov	r11,r1
80002bc6:	a7 bb       	sbr	r11,0x7
80002bc8:	30 2c       	mov	r12,2
80002bca:	f0 1f 00 4d 	mcall	80002cfc <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80002bce:	e0 6b 00 80 	mov	r11,128
80002bd2:	30 4c       	mov	r12,4
80002bd4:	f0 1f 00 4b 	mcall	80002d00 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80002bd8:	30 0b       	mov	r11,0
80002bda:	30 1c       	mov	r12,1
80002bdc:	f0 1f 00 48 	mcall	80002cfc <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80002be0:	e0 6b 00 80 	mov	r11,128
80002be4:	30 ac       	mov	r12,10
80002be6:	f0 1f 00 48 	mcall	80002d04 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80002bea:	58 06       	cp.w	r6,0
80002bec:	c0 c0       	breq	80002c04 <PcdComMF522+0x70>
80002bee:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80002bf0:	30 94       	mov	r4,9
80002bf2:	0f 3b       	ld.ub	r11,r7++
80002bf4:	08 9c       	mov	r12,r4
80002bf6:	f0 1f 00 42 	mcall	80002cfc <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80002bfa:	0e 98       	mov	r8,r7
80002bfc:	0a 18       	sub	r8,r5
80002bfe:	ec 08 19 00 	cp.h	r8,r6
80002c02:	cf 83       	brcs	80002bf2 <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80002c04:	04 9b       	mov	r11,r2
80002c06:	30 1c       	mov	r12,1
80002c08:	f0 1f 00 3d 	mcall	80002cfc <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80002c0c:	30 c8       	mov	r8,12
80002c0e:	f0 02 18 00 	cp.b	r2,r8
80002c12:	c0 61       	brne	80002c1e <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80002c14:	e0 6b 00 80 	mov	r11,128
80002c18:	30 dc       	mov	r12,13
80002c1a:	f0 1f 00 3b 	mcall	80002d04 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80002c1e:	30 4c       	mov	r12,4
80002c20:	f0 1f 00 3a 	mcall	80002d08 <PcdComMF522+0x174>
80002c24:	18 97       	mov	r7,r12
80002c26:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80002c2a:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80002c2c:	30 44       	mov	r4,4
80002c2e:	c0 88       	rjmp	80002c3e <PcdComMF522+0xaa>
80002c30:	08 9c       	mov	r12,r4
80002c32:	f0 1f 00 36 	mcall	80002d08 <PcdComMF522+0x174>
80002c36:	18 97       	mov	r7,r12
		i--;
80002c38:	20 16       	sub	r6,1
80002c3a:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80002c3c:	c0 a0       	breq	80002c50 <PcdComMF522+0xbc>
80002c3e:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80002c42:	c4 c1       	brne	80002cda <PcdComMF522+0x146>
80002c44:	ef e3 00 08 	and	r8,r7,r3
80002c48:	ea 08 18 00 	cp.b	r8,r5
80002c4c:	cf 20       	breq	80002c30 <PcdComMF522+0x9c>
80002c4e:	c4 68       	rjmp	80002cda <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80002c50:	e0 6b 00 80 	mov	r11,128
80002c54:	30 dc       	mov	r12,13
80002c56:	f0 1f 00 2b 	mcall	80002d00 <PcdComMF522+0x16c>
80002c5a:	30 27       	mov	r7,2
80002c5c:	c3 38       	rjmp	80002cc2 <PcdComMF522+0x12e>
80002c5e:	02 67       	and	r7,r1
80002c60:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80002c64:	30 c8       	mov	r8,12
80002c66:	f0 02 18 00 	cp.b	r2,r8
80002c6a:	c2 c1       	brne	80002cc2 <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80002c6c:	30 ac       	mov	r12,10
80002c6e:	f0 1f 00 27 	mcall	80002d08 <PcdComMF522+0x174>
80002c72:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80002c74:	30 cc       	mov	r12,12
80002c76:	f0 1f 00 25 	mcall	80002d08 <PcdComMF522+0x174>
80002c7a:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80002c7e:	c0 70       	breq	80002c8c <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80002c80:	08 98       	mov	r8,r4
80002c82:	20 18       	sub	r8,1
80002c84:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80002c88:	a0 8c       	st.b	r0[0x0],r12
80002c8a:	c0 48       	rjmp	80002c92 <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80002c8c:	e8 08 15 03 	lsl	r8,r4,0x3
80002c90:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80002c92:	58 04       	cp.w	r4,0
80002c94:	c0 61       	brne	80002ca0 <PcdComMF522+0x10c>
80002c96:	30 14       	mov	r4,1
80002c98:	40 05       	lddsp	r5,sp[0x0]
80002c9a:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80002c9c:	30 93       	mov	r3,9
80002c9e:	c0 98       	rjmp	80002cb0 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80002ca0:	31 28       	mov	r8,18
80002ca2:	f0 04 18 00 	cp.b	r4,r8
80002ca6:	f9 b4 0b 12 	movhi	r4,18
80002caa:	58 04       	cp.w	r4,0
80002cac:	cf 61       	brne	80002c98 <PcdComMF522+0x104>
80002cae:	c0 a8       	rjmp	80002cc2 <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80002cb0:	06 9c       	mov	r12,r3
80002cb2:	f0 1f 00 16 	mcall	80002d08 <PcdComMF522+0x174>
80002cb6:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80002cb8:	ec 05 01 08 	sub	r8,r6,r5
80002cbc:	e8 08 19 00 	cp.h	r8,r4
80002cc0:	cf 83       	brcs	80002cb0 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80002cc2:	e0 6b 00 80 	mov	r11,128
80002cc6:	30 cc       	mov	r12,12
80002cc8:	f0 1f 00 0f 	mcall	80002d04 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80002ccc:	30 0b       	mov	r11,0
80002cce:	30 1c       	mov	r12,1
80002cd0:	f0 1f 00 0b 	mcall	80002cfc <PcdComMF522+0x168>
	return status;
}
80002cd4:	0e 9c       	mov	r12,r7
80002cd6:	2f fd       	sub	sp,-4
80002cd8:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80002cda:	e0 6b 00 80 	mov	r11,128
80002cde:	30 dc       	mov	r12,13
80002ce0:	f0 1f 00 08 	mcall	80002d00 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80002ce4:	30 6c       	mov	r12,6
80002ce6:	f0 1f 00 09 	mcall	80002d08 <PcdComMF522+0x174>
80002cea:	e2 1c 00 1b 	andl	r12,0x1b,COH
80002cee:	cb 80       	breq	80002c5e <PcdComMF522+0xca>
80002cf0:	30 27       	mov	r7,2
80002cf2:	ce 8b       	rjmp	80002cc2 <PcdComMF522+0x12e>
80002cf4:	80 00       	ld.sh	r0,r0[0x0]
80002cf6:	b9 b8       	sbr	r8,0x19
80002cf8:	80 00       	ld.sh	r0,r0[0x0]
80002cfa:	b9 bc       	sbr	r12,0x19
80002cfc:	80 00       	ld.sh	r0,r0[0x0]
80002cfe:	28 e0       	sub	r0,-114
80002d00:	80 00       	ld.sh	r0,r0[0x0]
80002d02:	2a 1c       	sub	r12,-95
80002d04:	80 00       	ld.sh	r0,r0[0x0]
80002d06:	29 d8       	sub	r8,-99
80002d08:	80 00       	ld.sh	r0,r0[0x0]
80002d0a:	29 98       	sub	r8,-103

80002d0c <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80002d0c:	eb cd 40 c0 	pushm	r6-r7,lr
80002d10:	20 5d       	sub	sp,20
80002d12:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80002d14:	30 8b       	mov	r11,8
80002d16:	16 9c       	mov	r12,r11
80002d18:	f0 1f 00 1a 	mcall	80002d80 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80002d1c:	30 0b       	mov	r11,0
80002d1e:	30 dc       	mov	r12,13
80002d20:	f0 1f 00 19 	mcall	80002d84 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80002d24:	e0 6b 00 80 	mov	r11,128
80002d28:	30 ec       	mov	r12,14
80002d2a:	f0 1f 00 16 	mcall	80002d80 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80002d2e:	39 38       	mov	r8,-109
80002d30:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80002d32:	32 08       	mov	r8,32
80002d34:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80002d36:	1a 9b       	mov	r11,sp
80002d38:	fa c8 ff ed 	sub	r8,sp,-19
80002d3c:	1a 99       	mov	r9,sp
80002d3e:	30 2a       	mov	r10,2
80002d40:	30 cc       	mov	r12,12
80002d42:	f0 1f 00 12 	mcall	80002d88 <PcdAnticoll+0x7c>
80002d46:	18 97       	mov	r7,r12

	if (status == MI_OK)
80002d48:	c1 21       	brne	80002d6c <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80002d4a:	1b 89       	ld.ub	r9,sp[0x0]
80002d4c:	ac 89       	st.b	r6[0x0],r9
80002d4e:	1b 98       	ld.ub	r8,sp[0x1]
80002d50:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80002d52:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80002d54:	1b a8       	ld.ub	r8,sp[0x2]
80002d56:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80002d58:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80002d5c:	1b b9       	ld.ub	r9,sp[0x3]
80002d5e:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80002d60:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80002d62:	1b c9       	ld.ub	r9,sp[0x4]
80002d64:	f0 09 18 00 	cp.b	r9,r8
80002d68:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80002d6c:	e0 6b 00 80 	mov	r11,128
80002d70:	30 ec       	mov	r12,14
80002d72:	f0 1f 00 07 	mcall	80002d8c <PcdAnticoll+0x80>
	return status;
}
80002d76:	0e 9c       	mov	r12,r7
80002d78:	2f bd       	sub	sp,-20
80002d7a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002d7e:	00 00       	add	r0,r0
80002d80:	80 00       	ld.sh	r0,r0[0x0]
80002d82:	2a 1c       	sub	r12,-95
80002d84:	80 00       	ld.sh	r0,r0[0x0]
80002d86:	28 e0       	sub	r0,-114
80002d88:	80 00       	ld.sh	r0,r0[0x0]
80002d8a:	2b 94       	sub	r4,-71
80002d8c:	80 00       	ld.sh	r0,r0[0x0]
80002d8e:	29 d8       	sub	r8,-99

80002d90 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80002d90:	eb cd 40 c0 	pushm	r6-r7,lr
80002d94:	20 5d       	sub	sp,20
80002d96:	18 97       	mov	r7,r12
80002d98:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80002d9a:	30 8b       	mov	r11,8
80002d9c:	16 9c       	mov	r12,r11
80002d9e:	f0 1f 00 12 	mcall	80002de4 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80002da2:	30 7b       	mov	r11,7
80002da4:	30 dc       	mov	r12,13
80002da6:	f0 1f 00 11 	mcall	80002de8 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80002daa:	30 3b       	mov	r11,3
80002dac:	31 4c       	mov	r12,20
80002dae:	f0 1f 00 10 	mcall	80002dec <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80002db2:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80002db4:	1a 9b       	mov	r11,sp
80002db6:	fa c8 ff ed 	sub	r8,sp,-19
80002dba:	1a 99       	mov	r9,sp
80002dbc:	30 1a       	mov	r10,1
80002dbe:	30 cc       	mov	r12,12
80002dc0:	f0 1f 00 0c 	mcall	80002df0 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80002dc4:	c0 c1       	brne	80002ddc <PcdRequest+0x4c>
80002dc6:	31 08       	mov	r8,16
80002dc8:	fb 39 00 13 	ld.ub	r9,sp[19]
80002dcc:	f0 09 18 00 	cp.b	r9,r8
80002dd0:	c0 61       	brne	80002ddc <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80002dd2:	1b 88       	ld.ub	r8,sp[0x0]
80002dd4:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80002dd6:	1b 98       	ld.ub	r8,sp[0x1]
80002dd8:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80002dda:	c0 28       	rjmp	80002dde <PcdRequest+0x4e>
80002ddc:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80002dde:	2f bd       	sub	sp,-20
80002de0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002de4:	80 00       	ld.sh	r0,r0[0x0]
80002de6:	2a 1c       	sub	r12,-95
80002de8:	80 00       	ld.sh	r0,r0[0x0]
80002dea:	28 e0       	sub	r0,-114
80002dec:	80 00       	ld.sh	r0,r0[0x0]
80002dee:	29 d8       	sub	r8,-99
80002df0:	80 00       	ld.sh	r0,r0[0x0]
80002df2:	2b 94       	sub	r4,-71

80002df4 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80002df4:	eb cd 40 f8 	pushm	r3-r7,lr
80002df8:	18 95       	mov	r5,r12
80002dfa:	16 96       	mov	r6,r11
80002dfc:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80002dfe:	30 4b       	mov	r11,4
80002e00:	30 5c       	mov	r12,5
80002e02:	f0 1f 00 1c 	mcall	80002e70 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80002e06:	30 0b       	mov	r11,0
80002e08:	30 1c       	mov	r12,1
80002e0a:	f0 1f 00 1b 	mcall	80002e74 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80002e0e:	e0 6b 00 80 	mov	r11,128
80002e12:	30 ac       	mov	r12,10
80002e14:	f0 1f 00 19 	mcall	80002e78 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80002e18:	58 06       	cp.w	r6,0
80002e1a:	c0 c0       	breq	80002e32 <CalulateCRC+0x3e>
80002e1c:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80002e1e:	30 94       	mov	r4,9
80002e20:	0f 3b       	ld.ub	r11,r7++
80002e22:	08 9c       	mov	r12,r4
80002e24:	f0 1f 00 14 	mcall	80002e74 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80002e28:	0e 98       	mov	r8,r7
80002e2a:	0a 18       	sub	r8,r5
80002e2c:	ec 08 18 00 	cp.b	r8,r6
80002e30:	cf 83       	brcs	80002e20 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80002e32:	30 3b       	mov	r11,3
80002e34:	30 1c       	mov	r12,1
80002e36:	f0 1f 00 10 	mcall	80002e74 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80002e3a:	30 5c       	mov	r12,5
80002e3c:	f0 1f 00 10 	mcall	80002e7c <CalulateCRC+0x88>
80002e40:	e0 67 00 fe 	mov	r7,254
80002e44:	30 56       	mov	r6,5
80002e46:	c0 78       	rjmp	80002e54 <CalulateCRC+0x60>
80002e48:	0c 9c       	mov	r12,r6
80002e4a:	f0 1f 00 0d 	mcall	80002e7c <CalulateCRC+0x88>
		i--;
80002e4e:	20 17       	sub	r7,1
80002e50:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80002e52:	c0 40       	breq	80002e5a <CalulateCRC+0x66>
80002e54:	e2 1c 00 04 	andl	r12,0x4,COH
80002e58:	cf 80       	breq	80002e48 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80002e5a:	32 2c       	mov	r12,34
80002e5c:	f0 1f 00 08 	mcall	80002e7c <CalulateCRC+0x88>
80002e60:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80002e62:	32 1c       	mov	r12,33
80002e64:	f0 1f 00 06 	mcall	80002e7c <CalulateCRC+0x88>
80002e68:	a6 9c       	st.b	r3[0x1],r12
}
80002e6a:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002e6e:	00 00       	add	r0,r0
80002e70:	80 00       	ld.sh	r0,r0[0x0]
80002e72:	2a 1c       	sub	r12,-95
80002e74:	80 00       	ld.sh	r0,r0[0x0]
80002e76:	28 e0       	sub	r0,-114
80002e78:	80 00       	ld.sh	r0,r0[0x0]
80002e7a:	29 d8       	sub	r8,-99
80002e7c:	80 00       	ld.sh	r0,r0[0x0]
80002e7e:	29 98       	sub	r8,-103

80002e80 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80002e80:	eb cd 40 80 	pushm	r7,lr
80002e84:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80002e86:	39 38       	mov	r8,-109
80002e88:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80002e8a:	37 08       	mov	r8,112
80002e8c:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80002e8e:	30 08       	mov	r8,0
80002e90:	ba e8       	st.b	sp[0x6],r8
80002e92:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80002e96:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80002e9a:	19 89       	ld.ub	r9,r12[0x0]
80002e9c:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80002e9e:	19 3a       	ld.ub	r10,r12++
80002ea0:	1b e9       	ld.ub	r9,sp[0x6]
80002ea2:	f5 e9 20 09 	eor	r9,r10,r9
80002ea6:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80002ea8:	16 38       	cp.w	r8,r11
80002eaa:	cf 81       	brne	80002e9a <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80002eac:	1a 97       	mov	r7,sp
80002eae:	fa ca ff f9 	sub	r10,sp,-7
80002eb2:	30 7b       	mov	r11,7
80002eb4:	1a 9c       	mov	r12,sp
80002eb6:	f0 1f 00 0d 	mcall	80002ee8 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80002eba:	30 8b       	mov	r11,8
80002ebc:	16 9c       	mov	r12,r11
80002ebe:	f0 1f 00 0c 	mcall	80002eec <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80002ec2:	fa c8 ff ed 	sub	r8,sp,-19
80002ec6:	1a 99       	mov	r9,sp
80002ec8:	30 9a       	mov	r10,9
80002eca:	1a 9b       	mov	r11,sp
80002ecc:	30 cc       	mov	r12,12
80002ece:	f0 1f 00 09 	mcall	80002ef0 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80002ed2:	c0 71       	brne	80002ee0 <PcdSelect+0x60>
80002ed4:	31 88       	mov	r8,24
80002ed6:	fb 39 00 13 	ld.ub	r9,sp[19]
80002eda:	f0 09 18 00 	cp.b	r9,r8
80002ede:	c0 20       	breq	80002ee2 <PcdSelect+0x62>
80002ee0:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80002ee2:	2f bd       	sub	sp,-20
80002ee4:	e3 cd 80 80 	ldm	sp++,r7,pc
80002ee8:	80 00       	ld.sh	r0,r0[0x0]
80002eea:	2d f4       	sub	r4,-33
80002eec:	80 00       	ld.sh	r0,r0[0x0]
80002eee:	2a 1c       	sub	r12,-95
80002ef0:	80 00       	ld.sh	r0,r0[0x0]
80002ef2:	2b 94       	sub	r4,-71

80002ef4 <rfid_auto_reader>:
		
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80002ef4:	eb cd 40 c0 	pushm	r6-r7,lr
80002ef8:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80002efa:	f0 1f 00 37 	mcall	80002fd4 <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80002efe:	4b 7b       	lddpc	r11,80002fd8 <rfid_auto_reader+0xe4>
80002f00:	35 2c       	mov	r12,82
80002f02:	f0 1f 00 37 	mcall	80002fdc <rfid_auto_reader+0xe8>
80002f06:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80002f08:	c6 31       	brne	80002fce <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80002f0a:	4b 48       	lddpc	r8,80002fd8 <rfid_auto_reader+0xe4>
80002f0c:	11 88       	ld.ub	r8,r8[0x0]
80002f0e:	30 49       	mov	r9,4
80002f10:	f2 08 18 00 	cp.b	r8,r9
80002f14:	c0 b1       	brne	80002f2a <rfid_auto_reader+0x36>
80002f16:	4b 19       	lddpc	r9,80002fd8 <rfid_auto_reader+0xe4>
80002f18:	13 9a       	ld.ub	r10,r9[0x1]
80002f1a:	30 09       	mov	r9,0
80002f1c:	f2 0a 18 00 	cp.b	r10,r9
80002f20:	c0 51       	brne	80002f2a <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
80002f22:	4b 0c       	lddpc	r12,80002fe0 <rfid_auto_reader+0xec>
80002f24:	f0 1f 00 30 	mcall	80002fe4 <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80002f28:	c3 c8       	rjmp	80002fa0 <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80002f2a:	30 29       	mov	r9,2
80002f2c:	f2 08 18 00 	cp.b	r8,r9
80002f30:	c0 b1       	brne	80002f46 <rfid_auto_reader+0x52>
80002f32:	4a a9       	lddpc	r9,80002fd8 <rfid_auto_reader+0xe4>
80002f34:	13 9a       	ld.ub	r10,r9[0x1]
80002f36:	30 09       	mov	r9,0
80002f38:	f2 0a 18 00 	cp.b	r10,r9
80002f3c:	c0 51       	brne	80002f46 <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80002f3e:	4a bc       	lddpc	r12,80002fe8 <rfid_auto_reader+0xf4>
80002f40:	f0 1f 00 29 	mcall	80002fe4 <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80002f44:	c2 e8       	rjmp	80002fa0 <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80002f46:	34 49       	mov	r9,68
80002f48:	f2 08 18 00 	cp.b	r8,r9
80002f4c:	c0 b1       	brne	80002f62 <rfid_auto_reader+0x6e>
80002f4e:	4a 39       	lddpc	r9,80002fd8 <rfid_auto_reader+0xe4>
80002f50:	13 9a       	ld.ub	r10,r9[0x1]
80002f52:	30 09       	mov	r9,0
80002f54:	f2 0a 18 00 	cp.b	r10,r9
80002f58:	c0 51       	brne	80002f62 <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80002f5a:	4a 5c       	lddpc	r12,80002fec <rfid_auto_reader+0xf8>
80002f5c:	f0 1f 00 22 	mcall	80002fe4 <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80002f60:	c2 08       	rjmp	80002fa0 <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80002f62:	30 89       	mov	r9,8
80002f64:	f2 08 18 00 	cp.b	r8,r9
80002f68:	c0 b1       	brne	80002f7e <rfid_auto_reader+0x8a>
80002f6a:	49 c9       	lddpc	r9,80002fd8 <rfid_auto_reader+0xe4>
80002f6c:	13 9a       	ld.ub	r10,r9[0x1]
80002f6e:	30 09       	mov	r9,0
80002f70:	f2 0a 18 00 	cp.b	r10,r9
80002f74:	c0 51       	brne	80002f7e <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80002f76:	49 fc       	lddpc	r12,80002ff0 <rfid_auto_reader+0xfc>
80002f78:	f0 1f 00 1b 	mcall	80002fe4 <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80002f7c:	c1 28       	rjmp	80002fa0 <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80002f7e:	34 49       	mov	r9,68
80002f80:	f2 08 18 00 	cp.b	r8,r9
80002f84:	c0 b1       	brne	80002f9a <rfid_auto_reader+0xa6>
80002f86:	49 58       	lddpc	r8,80002fd8 <rfid_auto_reader+0xe4>
80002f88:	11 99       	ld.ub	r9,r8[0x1]
80002f8a:	30 38       	mov	r8,3
80002f8c:	f0 09 18 00 	cp.b	r9,r8
80002f90:	c0 51       	brne	80002f9a <rfid_auto_reader+0xa6>
		log("MF Desire\n");
80002f92:	49 9c       	lddpc	r12,80002ff4 <rfid_auto_reader+0x100>
80002f94:	f0 1f 00 14 	mcall	80002fe4 <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80002f98:	c0 48       	rjmp	80002fa0 <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80002f9a:	49 8c       	lddpc	r12,80002ff8 <rfid_auto_reader+0x104>
80002f9c:	f0 1f 00 12 	mcall	80002fe4 <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80002fa0:	49 7c       	lddpc	r12,80002ffc <rfid_auto_reader+0x108>
80002fa2:	f0 1f 00 18 	mcall	80003000 <rfid_auto_reader+0x10c>
80002fa6:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80002fa8:	c0 60       	breq	80002fb4 <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
80002faa:	37 8b       	mov	r11,120
80002fac:	30 1c       	mov	r12,1
80002fae:	f0 1f 00 16 	mcall	80003004 <rfid_auto_reader+0x110>
		return status;
80002fb2:	c0 e8       	rjmp	80002fce <rfid_auto_reader+0xda>
	}
	//continue;
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80002fb4:	49 2c       	lddpc	r12,80002ffc <rfid_auto_reader+0x108>
80002fb6:	f0 1f 00 15 	mcall	80003008 <rfid_auto_reader+0x114>
80002fba:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80002fbc:	c0 91       	brne	80002fce <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80002fbe:	30 4a       	mov	r10,4
80002fc0:	48 fb       	lddpc	r11,80002ffc <rfid_auto_reader+0x108>
80002fc2:	0c 9c       	mov	r12,r6
80002fc4:	f0 1f 00 12 	mcall	8000300c <rfid_auto_reader+0x118>
		log("select okay\n");
80002fc8:	49 2c       	lddpc	r12,80003010 <rfid_auto_reader+0x11c>
80002fca:	f0 1f 00 07 	mcall	80002fe4 <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
80002fce:	0e 9c       	mov	r12,r7
80002fd0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002fd4:	80 00       	ld.sh	r0,r0[0x0]
80002fd6:	29 18       	sub	r8,-111
80002fd8:	00 00       	add	r0,r0
80002fda:	51 34       	stdsp	sp[0x4c],r4
80002fdc:	80 00       	ld.sh	r0,r0[0x0]
80002fde:	2d 90       	sub	r0,-39
80002fe0:	80 00       	ld.sh	r0,r0[0x0]
80002fe2:	b9 d0       	cbr	r0,0x19
80002fe4:	80 00       	ld.sh	r0,r0[0x0]
80002fe6:	52 08       	stdsp	sp[0x80],r8
80002fe8:	80 00       	ld.sh	r0,r0[0x0]
80002fea:	b9 dc       	cbr	r12,0x19
80002fec:	80 00       	ld.sh	r0,r0[0x0]
80002fee:	b9 e8       	*unknown*
80002ff0:	80 00       	ld.sh	r0,r0[0x0]
80002ff2:	b9 f8       	*unknown*
80002ff4:	80 00       	ld.sh	r0,r0[0x0]
80002ff6:	ba 00       	st.h	sp[0x0],r0
80002ff8:	80 00       	ld.sh	r0,r0[0x0]
80002ffa:	ba 0c       	st.h	sp[0x0],r12
80002ffc:	00 00       	add	r0,r0
80002ffe:	51 38       	stdsp	sp[0x4c],r8
80003000:	80 00       	ld.sh	r0,r0[0x0]
80003002:	2d 0c       	sub	r12,-48
80003004:	80 00       	ld.sh	r0,r0[0x0]
80003006:	20 40       	sub	r0,4
80003008:	80 00       	ld.sh	r0,r0[0x0]
8000300a:	2e 80       	sub	r0,-24
8000300c:	80 00       	ld.sh	r0,r0[0x0]
8000300e:	5a 90       	cp.w	r0,-23
80003010:	80 00       	ld.sh	r0,r0[0x0]
80003012:	ba 18       	st.h	sp[0x2],r8

80003014 <rfid_sendID_message>:


U8 rfid_sendID_message()
{
80003014:	eb cd 40 e0 	pushm	r5-r7,lr
80003018:	21 ed       	sub	sp,120
	U8 temp =0;
	U8 destination = DEST;
	static U8 start_session = 0x80;
	Message_Header_t header;
	
	memset(data_buffer, 0x00, 16);
8000301a:	fa ca ff a4 	sub	r10,sp,-92
8000301e:	30 08       	mov	r8,0
80003020:	30 09       	mov	r9,0
80003022:	f4 e9 00 00 	st.d	r10[0],r8
80003026:	f4 e9 00 08 	st.d	r10[8],r8
	memset(SN, 0x00, 10);
8000302a:	fa cc ff 94 	sub	r12,sp,-108
8000302e:	f8 e9 00 00 	st.d	r12[0],r8
80003032:	30 0a       	mov	r10,0
80003034:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80003036:	fa e9 00 0c 	st.d	sp[12],r8
8000303a:	fa e9 00 14 	st.d	sp[20],r8
8000303e:	fa e9 00 1c 	st.d	sp[28],r8
80003042:	fa e9 00 24 	st.d	sp[36],r8
80003046:	fa e9 00 2c 	st.d	sp[44],r8
8000304a:	fa e9 00 34 	st.d	sp[52],r8
8000304e:	fa e9 00 3c 	st.d	sp[60],r8
80003052:	fa e9 00 44 	st.d	sp[68],r8
80003056:	fa e9 00 4c 	st.d	sp[76],r8
8000305a:	fa e9 00 54 	st.d	sp[84],r8

	return_err = rfid_auto_reader(SN);
8000305e:	f0 1f 00 3f 	mcall	80003158 <rfid_sendID_message+0x144>
80003062:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80003064:	c6 e1       	brne	80003140 <rfid_sendID_message+0x12c>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80003066:	fb 38 00 6f 	ld.ub	r8,sp[111]
8000306a:	1a d8       	st.w	--sp,r8
8000306c:	fb 38 00 72 	ld.ub	r8,sp[114]
80003070:	1a d8       	st.w	--sp,r8
80003072:	fb 38 00 75 	ld.ub	r8,sp[117]
80003076:	1a d8       	st.w	--sp,r8
80003078:	fb 38 00 78 	ld.ub	r8,sp[120]
8000307c:	1a d8       	st.w	--sp,r8
8000307e:	4b 8c       	lddpc	r12,8000315c <rfid_sendID_message+0x148>
80003080:	f0 1f 00 38 	mcall	80003160 <rfid_sendID_message+0x14c>
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
80003084:	37 7b       	mov	r11,119
80003086:	30 1c       	mov	r12,1
80003088:	f0 1f 00 37 	mcall	80003164 <rfid_sendID_message+0x150>
8000308c:	fa c9 ff 84 	sub	r9,sp,-124
80003090:	fa c8 ff 94 	sub	r8,sp,-108
80003094:	fa ca ff 92 	sub	r10,sp,-110
//}
	
}


U8 rfid_sendID_message()
80003098:	fa c5 ff 80 	sub	r5,sp,-128
8000309c:	2f cd       	sub	sp,-16
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer[i*4] = temp+0x30;
8000309e:	30 9e       	mov	lr,9
			 else 
				data_buffer[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer[i*4+1] = 0x00; 
800030a0:	30 06       	mov	r6,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
800030a2:	13 8b       	ld.ub	r11,r9[0x0]
800030a4:	f6 0c 16 04 	lsr	r12,r11,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer[i*4] = temp+0x30;
800030a8:	fc 0c 18 00 	cp.b	r12,lr
800030ac:	f7 bc 08 d0 	subls	r12,-48
800030b0:	f1 fc 8e 00 	st.bls	r8[0x0],r12
			 else 
				data_buffer[i*4] = ((temp - 0x0a)+0x61);
800030b4:	f7 bc 0b a9 	subhi	r12,-87
800030b8:	f1 fc be 00 	st.bhi	r8[0x0],r12
			
			 data_buffer[i*4+1] = 0x00; 
800030bc:	b0 96       	st.b	r8[0x1],r6
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
800030be:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer[i*4+2] = temp+0x30;
800030c2:	fc 0b 18 00 	cp.b	r11,lr
800030c6:	f7 bb 08 d0 	subls	r11,-48
800030ca:	f5 fb 8e 00 	st.bls	r10[0x0],r11
			 else
				data_buffer[i*4+2] = ((temp - 0x0a)+0x61);
800030ce:	f7 bb 0b a9 	subhi	r11,-87
800030d2:	f5 fb be 00 	st.bhi	r10[0x0],r11

		 
			 data_buffer[i*4+3] = 0x00; 
800030d6:	b0 b6       	st.b	r8[0x3],r6
800030d8:	2f f9       	sub	r9,-1
800030da:	2f c8       	sub	r8,-4
800030dc:	2f ca       	sub	r10,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
800030de:	0a 39       	cp.w	r9,r5
800030e0:	ce 11       	brne	800030a2 <rfid_sendID_message+0x8e>
			 data_buffer[i*4+3] = 0x00; 
		}
	
		header.length = (0x0008 + sizeof(data_buffer));
	
		if(start_session > 0x9f)start_session = 0x80;
800030e2:	4a 28       	lddpc	r8,80003168 <rfid_sendID_message+0x154>
800030e4:	11 89       	ld.ub	r9,r8[0x0]
800030e6:	39 f8       	mov	r8,-97
800030e8:	f0 09 18 00 	cp.b	r9,r8
800030ec:	e0 88 00 05 	brls	800030f6 <rfid_sendID_message+0xe2>
800030f0:	38 09       	mov	r9,-128
800030f2:	49 e8       	lddpc	r8,80003168 <rfid_sendID_message+0x154>
800030f4:	b0 89       	st.b	r8[0x0],r9
	
		header.session_id = (++start_session);
800030f6:	49 d8       	lddpc	r8,80003168 <rfid_sendID_message+0x154>
800030f8:	11 86       	ld.ub	r6,r8[0x0]
800030fa:	2f f6       	sub	r6,-1
800030fc:	b0 86       	st.b	r8[0x0],r6
	
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
800030fe:	30 5a       	mov	r10,5
80003100:	49 bb       	lddpc	r11,8000316c <rfid_sendID_message+0x158>
80003102:	fa cc ff f9 	sub	r12,sp,-7
80003106:	f0 1f 00 1b 	mcall	80003170 <rfid_sendID_message+0x15c>
		header.type = 0xe000;
	
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
8000310a:	31 88       	mov	r8,24
8000310c:	ba 18       	st.h	sp[0x2],r8
8000310e:	ba e6       	st.b	sp[0x6],r6
80003110:	fe 78 e0 00 	mov	r8,-8192
80003114:	ba 28       	st.h	sp[0x4],r8
80003116:	fa c6 ff f4 	sub	r6,sp,-12
8000311a:	30 aa       	mov	r10,10
8000311c:	fa cb ff fe 	sub	r11,sp,-2
80003120:	0c 9c       	mov	r12,r6
80003122:	f0 1f 00 14 	mcall	80003170 <rfid_sendID_message+0x15c>
		memcpy(&message[sizeof(Message_Header_t)], data_buffer, sizeof(data_buffer));//疯淇″瀹规版
80003126:	31 0a       	mov	r10,16
80003128:	fa cb ff a4 	sub	r11,sp,-92
8000312c:	fa cc ff ea 	sub	r12,sp,-22
80003130:	f0 1f 00 10 	mcall	80003170 <rfid_sendID_message+0x15c>
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(data_buffer)), destination);
80003134:	30 9a       	mov	r10,9
80003136:	31 ab       	mov	r11,26
80003138:	0c 9c       	mov	r12,r6
8000313a:	f0 1f 00 0f 	mcall	80003174 <rfid_sendID_message+0x160>
8000313e:	c0 88       	rjmp	8000314e <rfid_sendID_message+0x13a>
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate scan rfid failure!!!
80003140:	37 8b       	mov	r11,120
80003142:	30 1c       	mov	r12,1
80003144:	f0 1f 00 08 	mcall	80003164 <rfid_sendID_message+0x150>
		log("no card find...\n");
80003148:	48 cc       	lddpc	r12,80003178 <rfid_sendID_message+0x164>
8000314a:	f0 1f 00 06 	mcall	80003160 <rfid_sendID_message+0x14c>
	}
	
	return return_err;
	
}
8000314e:	0e 9c       	mov	r12,r7
80003150:	2e 2d       	sub	sp,-120
80003152:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003156:	00 00       	add	r0,r0
80003158:	80 00       	ld.sh	r0,r0[0x0]
8000315a:	2e f4       	sub	r4,-17
8000315c:	80 00       	ld.sh	r0,r0[0x0]
8000315e:	ba 28       	st.h	sp[0x4],r8
80003160:	80 00       	ld.sh	r0,r0[0x0]
80003162:	52 08       	stdsp	sp[0x80],r8
80003164:	80 00       	ld.sh	r0,r0[0x0]
80003166:	20 40       	sub	r0,4
80003168:	00 00       	add	r0,r0
8000316a:	05 30       	ld.ub	r0,r2++
8000316c:	00 00       	add	r0,r0
8000316e:	05 28       	ld.uh	r8,r2++
80003170:	80 00       	ld.sh	r0,r0[0x0]
80003172:	5a 90       	cp.w	r0,-23
80003174:	80 00       	ld.sh	r0,r0[0x0]
80003176:	1f 08       	ld.w	r8,pc++
80003178:	80 00       	ld.sh	r0,r0[0x0]
8000317a:	ba 44       	st.h	sp[0x8],r4

8000317c <rfid_init>:
U8 RFID[16];			//瀛RFID
U8 unsure_data[5]={0x04, 0x0d, 0x00, 0x0a, 0x00};


void rfid_init()
{
8000317c:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
8000317e:	f0 1f 00 02 	mcall	80003184 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		
}
80003182:	d8 02       	popm	pc
80003184:	80 00       	ld.sh	r0,r0[0x0]
80003186:	2a c4       	sub	r4,-84

80003188 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80003188:	fe 78 0c 00 	mov	r8,-62464
8000318c:	e0 69 03 07 	mov	r9,775
80003190:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80003192:	30 49       	mov	r9,4
80003194:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80003196:	71 59       	ld.w	r9,r8[0x54]
80003198:	e2 19 00 80 	andl	r9,0x80,COH
8000319c:	cf d0       	breq	80003196 <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
8000319e:	fe 78 0c 00 	mov	r8,-62464
800031a2:	30 59       	mov	r9,5
800031a4:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
800031a6:	e0 69 01 0d 	mov	r9,269
800031aa:	ea 19 10 07 	orh	r9,0x1007
800031ae:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800031b0:	71 59       	ld.w	r9,r8[0x54]
800031b2:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800031b6:	cf d0       	breq	800031b0 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
800031b8:	fe 78 0c 00 	mov	r8,-62464
800031bc:	fc 19 00 80 	movh	r9,0x80
800031c0:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
800031c2:	34 0a       	mov	r10,64
800031c4:	fe 69 14 00 	mov	r9,-125952
800031c8:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
800031ca:	30 69       	mov	r9,6
800031cc:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
800031ce:	30 19       	mov	r9,1
800031d0:	fe 68 10 00 	mov	r8,-126976
800031d4:	91 19       	st.w	r8[0x4],r9
	flashc_set_wait_state(1);
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
****/
}
800031d6:	5e fc       	retal	r12

800031d8 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
800031d8:	58 0c       	cp.w	r12,0
800031da:	5e 0c       	reteq	r12
800031dc:	30 08       	mov	r8,0
	{
		nop();
800031de:	d7 03       	nop
		nop();
800031e0:	d7 03       	nop
		nop();
800031e2:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
800031e4:	2f f8       	sub	r8,-1
800031e6:	10 3c       	cp.w	r12,r8
800031e8:	fe 9b ff fb 	brhi	800031de <delay_ns+0x6>
800031ec:	5e fc       	retal	r12
800031ee:	d7 03       	nop

800031f0 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
800031f0:	eb cd 40 e0 	pushm	r5-r7,lr
800031f4:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
800031f6:	58 0c       	cp.w	r12,0
800031f8:	c0 b0       	breq	8000320e <delay_us+0x1e>
800031fa:	30 07       	mov	r7,0
		delay_ns(1000);
800031fc:	e0 65 03 e8 	mov	r5,1000
80003200:	0a 9c       	mov	r12,r5
80003202:	f0 1f 00 05 	mcall	80003214 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
80003206:	2f f7       	sub	r7,-1
80003208:	0e 36       	cp.w	r6,r7
8000320a:	fe 9b ff fb 	brhi	80003200 <delay_us+0x10>
8000320e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003212:	00 00       	add	r0,r0
80003214:	80 00       	ld.sh	r0,r0[0x0]
80003216:	31 d8       	mov	r8,29

80003218 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
80003218:	eb cd 40 e0 	pushm	r5-r7,lr
8000321c:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
8000321e:	58 0c       	cp.w	r12,0
80003220:	c0 b0       	breq	80003236 <delay_ms+0x1e>
80003222:	30 07       	mov	r7,0
		delay_us(1000);
80003224:	e0 65 03 e8 	mov	r5,1000
80003228:	0a 9c       	mov	r12,r5
8000322a:	f0 1f 00 05 	mcall	8000323c <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
8000322e:	2f f7       	sub	r7,-1
80003230:	0e 36       	cp.w	r6,r7
80003232:	fe 9b ff fb 	brhi	80003228 <delay_ms+0x10>
80003236:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000323a:	00 00       	add	r0,r0
8000323c:	80 00       	ld.sh	r0,r0[0x0]
8000323e:	31 f0       	mov	r0,31

80003240 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80003240:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80003242:	30 3b       	mov	r11,3
80003244:	48 8c       	lddpc	r12,80003264 <local_start_timer+0x24>
80003246:	f0 1f 00 09 	mcall	80003268 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
8000324a:	fe 78 38 00 	mov	r8,-51200
8000324e:	e0 69 91 0d 	mov	r9,37133
80003252:	ea 19 00 52 	orh	r9,0x52
80003256:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80003258:	32 09       	mov	r9,32
8000325a:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
8000325c:	30 59       	mov	r9,5
8000325e:	91 09       	st.w	r8[0x0],r9
}
80003260:	d8 02       	popm	pc
80003262:	00 00       	add	r0,r0
80003264:	80 00       	ld.sh	r0,r0[0x0]
80003266:	ba 58       	st.h	sp[0xa],r8
80003268:	80 00       	ld.sh	r0,r0[0x0]
8000326a:	37 94       	mov	r4,121

8000326c <xg_flashc_init>:
	
}


void xg_flashc_init(void)
{
8000326c:	d4 01       	pushm	lr
	static U32 page_count_per_region =0;
	static U32 current_page_number =0;
	static U32 current_region_number =0;
	static U32 current_region_first_page_number =0;
	
	falsh_size = flashc_get_flash_size();
8000326e:	f0 1f 00 16 	mcall	800032c4 <xg_flashc_init+0x58>
80003272:	49 68       	lddpc	r8,800032c8 <xg_flashc_init+0x5c>
80003274:	91 0c       	st.w	r8[0x0],r12
	
	page_count = flashc_get_page_count();
80003276:	f0 1f 00 16 	mcall	800032cc <xg_flashc_init+0x60>
8000327a:	49 68       	lddpc	r8,800032d0 <xg_flashc_init+0x64>
8000327c:	91 0c       	st.w	r8[0x0],r12
	
	page_count_per_region =	flashc_get_page_count_per_region();
8000327e:	f0 1f 00 16 	mcall	800032d4 <xg_flashc_init+0x68>
80003282:	49 68       	lddpc	r8,800032d8 <xg_flashc_init+0x6c>
80003284:	91 0c       	st.w	r8[0x0],r12
	
	flashc_memset((void *)0x8004b000, 0x0000, 8, 6, true);
80003286:	30 19       	mov	r9,1
80003288:	30 6a       	mov	r10,6
8000328a:	30 0b       	mov	r11,0
8000328c:	e0 6c b0 00 	mov	r12,45056
80003290:	ea 1c 80 04 	orh	r12,0x8004
80003294:	f0 1f 00 12 	mcall	800032dc <xg_flashc_init+0x70>
	
	current_page_number = flashc_get_page_number();
80003298:	f0 1f 00 12 	mcall	800032e0 <xg_flashc_init+0x74>
8000329c:	49 28       	lddpc	r8,800032e4 <xg_flashc_init+0x78>
8000329e:	91 0c       	st.w	r8[0x0],r12
	
	current_region_number = flashc_get_page_region(current_page_number);
800032a0:	f0 1f 00 12 	mcall	800032e8 <xg_flashc_init+0x7c>
800032a4:	49 28       	lddpc	r8,800032ec <xg_flashc_init+0x80>
800032a6:	91 0c       	st.w	r8[0x0],r12
	
	current_region_first_page_number =flashc_get_region_first_page_number(current_region_number);
800032a8:	f0 1f 00 12 	mcall	800032f0 <xg_flashc_init+0x84>
800032ac:	49 28       	lddpc	r8,800032f4 <xg_flashc_init+0x88>
800032ae:	91 0c       	st.w	r8[0x0],r12
	
	
	flashc_memset((void *)0x80021001, 0x0000, 8, 6, true);
800032b0:	30 19       	mov	r9,1
800032b2:	30 6a       	mov	r10,6
800032b4:	30 0b       	mov	r11,0
800032b6:	e0 6c 10 01 	mov	r12,4097
800032ba:	ea 1c 80 02 	orh	r12,0x8002
800032be:	f0 1f 00 08 	mcall	800032dc <xg_flashc_init+0x70>
	//flashc_memcpy((void *)0x80021007,  &write_data, 8,  true);
	//
	////flash_rw_example(ch, flash_nvram_data);
	////flash_rw_example(ch, &temp_data);
	
800032c2:	d8 02       	popm	pc
800032c4:	80 00       	ld.sh	r0,r0[0x0]
800032c6:	32 f8       	mov	r8,47
800032c8:	00 00       	add	r0,r0
800032ca:	0b 6c       	ld.uh	r12,--r5
800032cc:	80 00       	ld.sh	r0,r0[0x0]
800032ce:	33 2c       	mov	r12,50
800032d0:	00 00       	add	r0,r0
800032d2:	0b 68       	ld.uh	r8,--r5
800032d4:	80 00       	ld.sh	r0,r0[0x0]
800032d6:	33 3c       	mov	r12,51
800032d8:	00 00       	add	r0,r0
800032da:	0b 74       	ld.ub	r4,--r5
800032dc:	80 00       	ld.sh	r0,r0[0x0]
800032de:	37 2c       	mov	r12,114
800032e0:	80 00       	ld.sh	r0,r0[0x0]
800032e2:	33 7c       	mov	r12,55
800032e4:	00 00       	add	r0,r0
800032e6:	0b 70       	ld.ub	r0,--r5
800032e8:	80 00       	ld.sh	r0,r0[0x0]
800032ea:	33 88       	mov	r8,56
800032ec:	00 00       	add	r0,r0
800032ee:	0b 64       	ld.uh	r4,--r5
800032f0:	80 00       	ld.sh	r0,r0[0x0]
800032f2:	33 4c       	mov	r12,52
800032f4:	00 00       	add	r0,r0
800032f6:	0b 78       	ld.ub	r8,--r5

800032f8 <flashc_get_flash_size>:
 */
//! @{


unsigned int flashc_get_flash_size(void)
{
800032f8:	d4 01       	pushm	lr
800032fa:	20 4d       	sub	sp,16
		256,
		384,
		512,
		768,
		1024,
	};
800032fc:	31 0a       	mov	r10,16
800032fe:	48 ab       	lddpc	r11,80003324 <flashc_get_flash_size+0x2c>
80003300:	1a 9c       	mov	r12,sp
80003302:	f0 1f 00 0a 	mcall	80003328 <flashc_get_flash_size+0x30>
	return ((unsigned int)FLASH_SIZE[(AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_FSZ_MASK)
80003306:	fe 68 14 00 	mov	r8,-125952
8000330a:	70 28       	ld.w	r8,r8[0x8]
8000330c:	f1 d8 c1 a3 	bfextu	r8,r8,0xd,0x3
80003310:	fa c9 ff f0 	sub	r9,sp,-16
80003314:	f2 08 00 18 	add	r8,r9,r8<<0x1
80003318:	f1 1c ff f0 	ld.uh	r12,r8[-16]
			>> AVR32_FLASHC_FSR_FSZ_OFFSET]) << 10;
#endif
}
8000331c:	ab 6c       	lsl	r12,0xa
8000331e:	2f cd       	sub	sp,-16
80003320:	d8 02       	popm	pc
80003322:	00 00       	add	r0,r0
80003324:	80 00       	ld.sh	r0,r0[0x0]
80003326:	ba 70       	st.h	sp[0xe],r0
80003328:	80 00       	ld.sh	r0,r0[0x0]
8000332a:	5a 90       	cp.w	r0,-23

8000332c <flashc_get_page_count>:


unsigned int flashc_get_page_count(void)
{
8000332c:	d4 01       	pushm	lr
	return flashc_get_flash_size() / AVR32_FLASHC_PAGE_SIZE;
8000332e:	f0 1f 00 03 	mcall	80003338 <flashc_get_page_count+0xc>
}
80003332:	a9 9c       	lsr	r12,0x9
80003334:	d8 02       	popm	pc
80003336:	00 00       	add	r0,r0
80003338:	80 00       	ld.sh	r0,r0[0x0]
8000333a:	32 f8       	mov	r8,47

8000333c <flashc_get_page_count_per_region>:


unsigned int flashc_get_page_count_per_region(void)
{
8000333c:	d4 01       	pushm	lr
	return flashc_get_page_count() / AVR32_FLASHC_REGIONS;
8000333e:	f0 1f 00 03 	mcall	80003348 <flashc_get_page_count_per_region+0xc>
}
80003342:	a5 8c       	lsr	r12,0x4
80003344:	d8 02       	popm	pc
80003346:	00 00       	add	r0,r0
80003348:	80 00       	ld.sh	r0,r0[0x0]
8000334a:	33 2c       	mov	r12,50

8000334c <flashc_get_region_first_page_number>:
			: flashc_get_page_number()) / flashc_get_page_count_per_region();
}


unsigned int flashc_get_region_first_page_number(unsigned int region)
{
8000334c:	eb cd 40 80 	pushm	r7,lr
80003350:	18 97       	mov	r7,r12
	return region * flashc_get_page_count_per_region();
80003352:	f0 1f 00 03 	mcall	8000335c <flashc_get_region_first_page_number+0x10>
}
80003356:	af 3c       	mul	r12,r7
80003358:	e3 cd 80 80 	ldm	sp++,r7,pc
8000335c:	80 00       	ld.sh	r0,r0[0x0]
8000335e:	33 3c       	mov	r12,51

80003360 <flashc_is_ready>:
//! @{


bool flashc_is_ready(void)
{
	return ((AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_FRDY_MASK) != 0);
80003360:	fe 68 14 00 	mov	r8,-125952
80003364:	70 2c       	ld.w	r12,r8[0x8]
}
80003366:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
8000336a:	5e fc       	retal	r12

8000336c <flashc_default_wait_until_ready>:


void flashc_default_wait_until_ready(void)
{
8000336c:	d4 01       	pushm	lr
	while (!flashc_is_ready());
8000336e:	f0 1f 00 03 	mcall	80003378 <flashc_default_wait_until_ready+0xc>
80003372:	cf e0       	breq	8000336e <flashc_default_wait_until_ready+0x2>
}
80003374:	d8 02       	popm	pc
80003376:	00 00       	add	r0,r0
80003378:	80 00       	ld.sh	r0,r0[0x0]
8000337a:	33 60       	mov	r0,54

8000337c <flashc_get_page_number>:
}


unsigned int flashc_get_page_number(void)
{
	return (AVR32_FLASHC.fcmd & AVR32_FLASHC_FCMD_PAGEN_MASK) >> AVR32_FLASHC_FCMD_PAGEN_OFFSET;
8000337c:	fe 68 14 00 	mov	r8,-125952
80003380:	70 1c       	ld.w	r12,r8[0x4]
}
80003382:	f9 dc c1 10 	bfextu	r12,r12,0x8,0x10
80003386:	5e fc       	retal	r12

80003388 <flashc_get_page_region>:
	return flashc_get_page_count() / AVR32_FLASHC_REGIONS;
}


unsigned int flashc_get_page_region(int page_number)
{
80003388:	eb cd 40 c0 	pushm	r6-r7,lr
	return ((page_number >= 0) ? page_number
8000338c:	58 0c       	cp.w	r12,0
8000338e:	c0 35       	brlt	80003394 <flashc_get_page_region+0xc>
80003390:	18 97       	mov	r7,r12
80003392:	c0 48       	rjmp	8000339a <flashc_get_page_region+0x12>
			: flashc_get_page_number()) / flashc_get_page_count_per_region();
80003394:	f0 1f 00 05 	mcall	800033a8 <flashc_get_page_region+0x20>
80003398:	18 97       	mov	r7,r12
}


unsigned int flashc_get_page_region(int page_number)
{
	return ((page_number >= 0) ? page_number
8000339a:	f0 1f 00 05 	mcall	800033ac <flashc_get_page_region+0x24>
8000339e:	ee 0c 0d 06 	divu	r6,r7,r12
			: flashc_get_page_number()) / flashc_get_page_count_per_region();
}
800033a2:	0c 9c       	mov	r12,r6
800033a4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800033a8:	80 00       	ld.sh	r0,r0[0x0]
800033aa:	33 7c       	mov	r12,55
800033ac:	80 00       	ld.sh	r0,r0[0x0]
800033ae:	33 3c       	mov	r12,51

800033b0 <flashc_issue_command>:
	return (AVR32_FLASHC.fcmd & AVR32_FLASHC_FCMD_PAGEN_MASK) >> AVR32_FLASHC_FCMD_PAGEN_OFFSET;
}


void flashc_issue_command(unsigned int command, int page_number)
{
800033b0:	eb cd 40 c0 	pushm	r6-r7,lr
800033b4:	18 96       	mov	r6,r12
800033b6:	16 97       	mov	r7,r11
	u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;

	flashc_wait_until_ready();
800033b8:	48 e8       	lddpc	r8,800033f0 <flashc_issue_command+0x40>
800033ba:	70 08       	ld.w	r8,r8[0x0]
800033bc:	5d 18       	icall	r8
	u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
800033be:	fe 68 14 00 	mov	r8,-125952
800033c2:	70 18       	ld.w	r8,r8[0x4]
	u_avr32_flashc_fcmd.FCMD.cmd = command;
800033c4:	f1 d6 d0 06 	bfins	r8,r6,0x0,0x6
	if (page_number >= 0) {
800033c8:	58 07       	cp.w	r7,0
800033ca:	c0 35       	brlt	800033d0 <flashc_issue_command+0x20>
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
800033cc:	f1 d7 d1 10 	bfins	r8,r7,0x8,0x10
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
800033d0:	3a 59       	mov	r9,-91
800033d2:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
800033d6:	fe 69 14 00 	mov	r9,-125952
800033da:	93 18       	st.w	r9[0x4],r8
 *          the driver's API which instead presents \ref flashc_is_lock_error
 *          and \ref flashc_is_programming_error.
 */
static unsigned int flashc_get_error_status(void)
{
	return AVR32_FLASHC.fsr & (AVR32_FLASHC_FSR_LOCKE_MASK |
800033dc:	72 29       	ld.w	r9,r9[0x8]
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
	flashc_error_status = flashc_get_error_status();
800033de:	e2 19 00 0c 	andl	r9,0xc,COH
800033e2:	48 58       	lddpc	r8,800033f4 <flashc_issue_command+0x44>
800033e4:	91 09       	st.w	r8[0x0],r9
	flashc_wait_until_ready();
800033e6:	48 38       	lddpc	r8,800033f0 <flashc_issue_command+0x40>
800033e8:	70 08       	ld.w	r8,r8[0x0]
800033ea:	5d 18       	icall	r8
}
800033ec:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800033f0:	00 00       	add	r0,r0
800033f2:	05 34       	ld.ub	r4,r2++
800033f4:	00 00       	add	r0,r0
800033f6:	0b 7c       	ld.ub	r12,--r5

800033f8 <flashc_clear_page_buffer>:
 */
//! @{


void flashc_clear_page_buffer(void)
{
800033f8:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_CPB, -1);
800033fa:	3f fb       	mov	r11,-1
800033fc:	30 3c       	mov	r12,3
800033fe:	f0 1f 00 02 	mcall	80003404 <flashc_clear_page_buffer+0xc>
}
80003402:	d8 02       	popm	pc
80003404:	80 00       	ld.sh	r0,r0[0x0]
80003406:	33 b0       	mov	r0,59

80003408 <flashc_is_page_erased>:


bool flashc_is_page_erased(void)
{
	return ((AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_QPRR_MASK) != 0);
80003408:	fe 68 14 00 	mov	r8,-125952
8000340c:	70 2c       	ld.w	r12,r8[0x8]
}
8000340e:	f9 dc c0 a1 	bfextu	r12,r12,0x5,0x1
80003412:	5e fc       	retal	r12

80003414 <flashc_quick_page_read>:


bool flashc_quick_page_read(int page_number)
{
80003414:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPR, page_number);
80003416:	18 9b       	mov	r11,r12
80003418:	30 cc       	mov	r12,12
8000341a:	f0 1f 00 03 	mcall	80003424 <flashc_quick_page_read+0x10>
	return flashc_is_page_erased();
8000341e:	f0 1f 00 03 	mcall	80003428 <flashc_quick_page_read+0x14>
}
80003422:	d8 02       	popm	pc
80003424:	80 00       	ld.sh	r0,r0[0x0]
80003426:	33 b0       	mov	r0,59
80003428:	80 00       	ld.sh	r0,r0[0x0]
8000342a:	34 08       	mov	r8,64

8000342c <flashc_erase_page>:


bool flashc_erase_page(int page_number, bool check)
{
8000342c:	eb cd 40 c0 	pushm	r6-r7,lr
80003430:	16 97       	mov	r7,r11
	bool page_erased = true;

	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EP, page_number);
80003432:	18 9b       	mov	r11,r12
80003434:	30 2c       	mov	r12,2
80003436:	f0 1f 00 09 	mcall	80003458 <flashc_erase_page+0x2c>
	if (check) {
8000343a:	58 07       	cp.w	r7,0
8000343c:	c0 31       	brne	80003442 <flashc_erase_page+0x16>
8000343e:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
		unsigned int error_status = flashc_error_status;
80003442:	48 77       	lddpc	r7,8000345c <flashc_erase_page+0x30>
80003444:	6e 06       	ld.w	r6,r7[0x0]
		page_erased = flashc_quick_page_read(-1);
80003446:	3f fc       	mov	r12,-1
80003448:	f0 1f 00 06 	mcall	80003460 <flashc_erase_page+0x34>
		flashc_error_status |= error_status;
8000344c:	6e 08       	ld.w	r8,r7[0x0]
8000344e:	f1 e6 10 06 	or	r6,r8,r6
80003452:	8f 06       	st.w	r7[0x0],r6
	}
	return page_erased;
}
80003454:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003458:	80 00       	ld.sh	r0,r0[0x0]
8000345a:	33 b0       	mov	r0,59
8000345c:	00 00       	add	r0,r0
8000345e:	0b 7c       	ld.ub	r12,--r5
80003460:	80 00       	ld.sh	r0,r0[0x0]
80003462:	34 14       	mov	r4,65

80003464 <flashc_write_page>:
	return all_pages_erased;
}


void flashc_write_page(int page_number)
{
80003464:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WP, page_number);
80003466:	18 9b       	mov	r11,r12
80003468:	30 1c       	mov	r12,1
8000346a:	f0 1f 00 02 	mcall	80003470 <flashc_write_page+0xc>
}
8000346e:	d8 02       	popm	pc
80003470:	80 00       	ld.sh	r0,r0[0x0]
80003472:	33 b0       	mov	r0,59

80003474 <flashc_quick_user_page_read>:


bool flashc_quick_user_page_read(void)
{
80003474:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPRUP, -1);
80003476:	3f fb       	mov	r11,-1
80003478:	30 fc       	mov	r12,15
8000347a:	f0 1f 00 03 	mcall	80003484 <flashc_quick_user_page_read+0x10>
	return flashc_is_page_erased();
8000347e:	f0 1f 00 03 	mcall	80003488 <flashc_quick_user_page_read+0x14>
}
80003482:	d8 02       	popm	pc
80003484:	80 00       	ld.sh	r0,r0[0x0]
80003486:	33 b0       	mov	r0,59
80003488:	80 00       	ld.sh	r0,r0[0x0]
8000348a:	34 08       	mov	r8,64

8000348c <flashc_erase_user_page>:


bool flashc_erase_user_page(bool check)
{
8000348c:	eb cd 40 80 	pushm	r7,lr
80003490:	18 97       	mov	r7,r12
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EUP, -1);
80003492:	3f fb       	mov	r11,-1
80003494:	30 ec       	mov	r12,14
80003496:	f0 1f 00 06 	mcall	800034ac <flashc_erase_user_page+0x20>
	return (check) ? flashc_quick_user_page_read() : true;
8000349a:	58 07       	cp.w	r7,0
8000349c:	c0 31       	brne	800034a2 <flashc_erase_user_page+0x16>
8000349e:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
800034a2:	f0 1f 00 04 	mcall	800034b0 <flashc_erase_user_page+0x24>
}
800034a6:	e3 cd 80 80 	ldm	sp++,r7,pc
800034aa:	00 00       	add	r0,r0
800034ac:	80 00       	ld.sh	r0,r0[0x0]
800034ae:	33 b0       	mov	r0,59
800034b0:	80 00       	ld.sh	r0,r0[0x0]
800034b2:	34 74       	mov	r4,71

800034b4 <flashc_write_user_page>:


void flashc_write_user_page(void)
{
800034b4:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WUP, -1);
800034b6:	3f fb       	mov	r11,-1
800034b8:	30 dc       	mov	r12,13
800034ba:	f0 1f 00 02 	mcall	800034c0 <flashc_write_user_page+0xc>
}
800034be:	d8 02       	popm	pc
800034c0:	80 00       	ld.sh	r0,r0[0x0]
800034c2:	33 b0       	mov	r0,59

800034c4 <flashc_memset64>:
	return flashc_memset64(dst, src | (uint64_t)src << 32, nbytes, erase);
}


volatile void *flashc_memset64(volatile void *dst, uint64_t src, size_t nbytes, bool erase)
{
800034c4:	d4 31       	pushm	r0-r7,lr
800034c6:	20 cd       	sub	sp,48
800034c8:	50 6c       	stdsp	sp[0x18],r12
800034ca:	14 94       	mov	r4,r10
800034cc:	16 95       	mov	r5,r11
800034ce:	12 96       	mov	r6,r9
800034d0:	50 38       	stdsp	sp[0xc],r8
	// Use aggregated pointers to have several alignments available for a same address.
	UnionCVPtr flash_array_end;
	UnionVPtr dest;
	Union64 source = {0};
800034d2:	30 08       	mov	r8,0
800034d4:	30 09       	mov	r9,0
800034d6:	fa e9 00 28 	st.d	sp[40],r8
	UnionVPtr tmp;
	unsigned int error_status = 0;
	unsigned int i;

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
800034da:	f0 1f 00 82 	mcall	800036e0 <flashc_memset64+0x21c>
800034de:	fc 18 80 00 	movh	r8,0x8000
800034e2:	f8 08 00 08 	add	r8,r12,r8
800034e6:	50 28       	stdsp	sp[0x8],r8
	dest.u8ptr = dst;
800034e8:	40 6b       	lddsp	r11,sp[0x18]
800034ea:	16 97       	mov	r7,r11
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
800034ec:	58 04       	cp.w	r4,0
800034ee:	5c 25       	cpc	r5
800034f0:	c1 80       	breq	80003520 <flashc_memset64+0x5c>
800034f2:	f6 c8 ff f9 	sub	r8,r11,-7
800034f6:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
		source.u8[i] = src;
800034fa:	fa c9 ff d0 	sub	r9,sp,-48
800034fe:	10 09       	add	r9,r8
80003500:	f3 64 ff f8 	st.b	r9[-8],r4
		src >>= 8;
80003504:	e8 0c 16 08 	lsr	r12,r4,0x8
80003508:	ea 0a 16 08 	lsr	r10,r5,0x8
8000350c:	f9 e5 11 89 	or	r9,r12,r5<<0x18
80003510:	14 95       	mov	r5,r10
80003512:	12 94       	mov	r4,r9

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
	dest.u8ptr = dst;
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
80003514:	20 18       	sub	r8,1
80003516:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
	unsigned int i;

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
	dest.u8ptr = dst;
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
8000351a:	58 04       	cp.w	r4,0
8000351c:	5c 25       	cpc	r5
8000351e:	ce e1       	brne	800034fa <flashc_memset64+0x36>
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
		source.u8[i] = src;
		src >>= 8;
	}
	dest_end.u8ptr = dest.u8ptr + nbytes;
80003520:	f6 06 00 06 	add	r6,r11,r6
80003524:	50 06       	stdsp	sp[0x0],r6

	// If destination is outside flash, go to next flash page if any.
	if (dest.u8ptr < AVR32_FLASH) {
80003526:	e0 6a ff ff 	mov	r10,65535
8000352a:	ea 1a 7f ff 	orh	r10,0x7fff
8000352e:	14 3b       	cp.w	r11,r10
80003530:	e0 8b 00 05 	brhi	8000353a <flashc_memset64+0x76>
		dest.u8ptr = AVR32_FLASH;
80003534:	fc 17 80 00 	movh	r7,0x8000
80003538:	c0 e8       	rjmp	80003554 <flashc_memset64+0x90>
	} else if (flash_array_end.u8ptr <= dest.u8ptr && dest.u8ptr < AVR32_FLASHC_USER_PAGE) {
8000353a:	40 29       	lddsp	r9,sp[0x8]
8000353c:	16 39       	cp.w	r9,r11
8000353e:	e0 8b 00 0b 	brhi	80003554 <flashc_memset64+0x90>
		dest.u8ptr = AVR32_FLASHC_USER_PAGE;
80003542:	fc 18 80 80 	movh	r8,0x8080
80003546:	e0 6a ff ff 	mov	r10,65535
8000354a:	ea 1a 80 7f 	orh	r10,0x807f
8000354e:	14 3b       	cp.w	r11,r10
80003550:	f0 07 17 80 	movls	r7,r8
	}

	// If end of destination is outside flash, move it to the end of the previous flash page if any.
	if (dest_end.u8ptr > AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE) {
80003554:	40 09       	lddsp	r9,sp[0x0]
80003556:	e0 68 02 00 	mov	r8,512
8000355a:	ea 18 80 80 	orh	r8,0x8080
8000355e:	10 39       	cp.w	r9,r8
80003560:	e0 88 00 04 	brls	80003568 <flashc_memset64+0xa4>
80003564:	50 08       	stdsp	sp[0x0],r8
80003566:	c0 c8       	rjmp	8000357e <flashc_memset64+0xba>
		dest_end.u8ptr = AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE;
	} else if (AVR32_FLASHC_USER_PAGE >= dest_end.u8ptr && dest_end.u8ptr > flash_array_end.u8ptr) {
80003568:	40 0a       	lddsp	r10,sp[0x0]
8000356a:	fc 19 80 80 	movh	r9,0x8080
8000356e:	12 3a       	cp.w	r10,r9
80003570:	e0 8b 00 07 	brhi	8000357e <flashc_memset64+0xba>
80003574:	40 28       	lddsp	r8,sp[0x8]
80003576:	10 3a       	cp.w	r10,r8
80003578:	f0 0a 17 b0 	movhi	r10,r8
8000357c:	50 0a       	stdsp	sp[0x0],r10
		dest_end.u8ptr = flash_array_end.u8ptr;
	}

	// Align each end of destination pointer with its natural boundary.
	dest_end.u16ptr = (uint16_t *)Align_down((uint32_t)dest_end.u8ptr, sizeof(uint16_t));
8000357e:	40 08       	lddsp	r8,sp[0x0]
	dest_end.u32ptr = (uint32_t *)Align_down((uint32_t)dest_end.u16ptr, sizeof(uint32_t));
	dest_end.u64ptr = (uint64_t *)Align_down((uint32_t)dest_end.u32ptr, sizeof(uint64_t));
80003580:	10 9b       	mov	r11,r8
80003582:	e0 1b ff f8 	andl	r11,0xfff8
80003586:	50 1b       	stdsp	sp[0x4],r11
		// Determine if the current destination page has an incomplete end.
		incomplete_flash_page_end = (Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) >=
				Align_down((uint32_t)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));

		// Use a flash double-word buffer to manage unaligned accesses.
		flash_dword.u64 = source.u64;
80003588:	fa e4 00 28 	ld.d	r4,sp[40]
8000358c:	30 03       	mov	r3,0

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;
8000358e:	4d 66       	lddpc	r6,800036e4 <flashc_memset64+0x220>
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
			*dest.u64ptr++ = source.u64;
		}

		// If the current destination page has an incomplete end...
		if (incomplete_flash_page_end) {
80003590:	10 9a       	mov	r10,r8
80003592:	e0 1a fe 00 	andl	r10,0xfe00
80003596:	50 4a       	stdsp	sp[0x10],r10
			// pages that have already been written to.
			{
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
80003598:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
8000359c:	50 58       	stdsp	sp[0x14],r8
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
8000359e:	40 08       	lddsp	r8,sp[0x0]
800035a0:	40 59       	lddsp	r9,sp[0x14]
800035a2:	12 18       	sub	r8,r9
800035a4:	2f 88       	sub	r8,-8
800035a6:	50 78       	stdsp	sp[0x1c],r8
	dest_end.u16ptr = (uint16_t *)Align_down((uint32_t)dest_end.u8ptr, sizeof(uint16_t));
	dest_end.u32ptr = (uint32_t *)Align_down((uint32_t)dest_end.u16ptr, sizeof(uint32_t));
	dest_end.u64ptr = (uint64_t *)Align_down((uint32_t)dest_end.u32ptr, sizeof(uint64_t));

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
800035a8:	c9 18       	rjmp	800036ca <flashc_memset64+0x206>
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
800035aa:	f0 1f 00 50 	mcall	800036e8 <flashc_memset64+0x224>
		error_status |= flashc_error_status;
800035ae:	6c 08       	ld.w	r8,r6[0x0]
800035b0:	10 43       	or	r3,r8

		// Determine where the source data will end in the current flash page.
		flash_page_source_end.u64ptr =
				(uint64_t *)min((uint32_t)dest_end.u64ptr,
800035b2:	04 9c       	mov	r12,r2
800035b4:	e0 1c fe 00 	andl	r12,0xfe00
800035b8:	f8 ce fe 00 	sub	lr,r12,-512
800035bc:	40 18       	lddsp	r8,sp[0x4]
800035be:	f0 0e 0d 4e 	min	lr,r8,lr
		// Determine if the current destination page has an incomplete end.
		incomplete_flash_page_end = (Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) >=
				Align_down((uint32_t)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));

		// Use a flash double-word buffer to manage unaligned accesses.
		flash_dword.u64 = source.u64;
800035c2:	fa e5 00 20 	st.d	sp[32],r4

		// If destination does not point to the beginning of the current flash page...
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
800035c6:	f1 d2 c0 09 	bfextu	r8,r2,0x0,0x9
800035ca:	c2 f0       	breq	80003628 <flashc_memset64+0x164>
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
800035cc:	18 98       	mov	r8,r12
					tmp.u64ptr < (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
800035ce:	18 90       	mov	r0,r12
800035d0:	04 91       	mov	r1,r2
800035d2:	e0 11 ff f8 	andl	r1,0xfff8
800035d6:	02 99       	mov	r9,r1
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
800035d8:	18 31       	cp.w	r1,r12
800035da:	e0 88 00 10 	brls	800035fa <flashc_memset64+0x136>
					tmp.u64ptr < (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
					tmp.u64ptr++) {
				*tmp.u64ptr = *tmp.u64ptr;
800035de:	f0 ea 00 00 	ld.d	r10,r8[0]
800035e2:	b1 2a       	st.d	r8++,r10
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
800035e4:	10 39       	cp.w	r9,r8
800035e6:	fe 9b ff fc 	brhi	800035de <flashc_memset64+0x11a>
800035ea:	e0 08 11 ff 	rsub	r8,r0,-1
800035ee:	02 08       	add	r8,r1
800035f0:	e0 18 ff f8 	andl	r8,0xfff8
800035f4:	2f 88       	sub	r8,-8
800035f6:	e0 08 00 08 	add	r8,r0,r8
					tmp.u64ptr++) {
				*tmp.u64ptr = *tmp.u64ptr;
			}

			// If destination is not 64-bit aligned...
			if (!Test_align((uint32_t)dest.u8ptr, sizeof(uint64_t))) {
800035fa:	e5 d2 c0 03 	bfextu	r2,r2,0x0,0x3
800035fe:	c1 50       	breq	80003628 <flashc_memset64+0x164>
80003600:	30 0a       	mov	r10,0
80003602:	f0 0a 00 0b 	add	r11,r8,r10
				// flash page data.
				// This is required by the hardware, even if page erase is not
				// requested, in order to be able to write successfully to erased parts
				// of flash pages that have already been written to.
				for (i = 0; i < Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)); i++) {
					flash_dword.u8[i] = *tmp.u8ptr++;
80003606:	17 8b       	ld.ub	r11,r11[0x0]
80003608:	fa c7 ff e0 	sub	r7,sp,-32
8000360c:	ee 0a 0b 0b 	st.b	r7[r10],r11
				// Fill the beginning of the flash double-word buffer with the current
				// flash page data.
				// This is required by the hardware, even if page erase is not
				// requested, in order to be able to write successfully to erased parts
				// of flash pages that have already been written to.
				for (i = 0; i < Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)); i++) {
80003610:	2f fa       	sub	r10,-1
80003612:	04 3a       	cp.w	r10,r2
80003614:	cf 71       	brne	80003602 <flashc_memset64+0x13e>
					flash_dword.u8[i] = *tmp.u8ptr++;
				}

				// Align the destination pointer with its 64-bit boundary.
				dest.u64ptr = (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
80003616:	12 97       	mov	r7,r9

				// If the current destination double-word is not the last one...
				if (dest.u64ptr < dest_end.u64ptr) {
80003618:	40 1b       	lddsp	r11,sp[0x4]
8000361a:	16 39       	cp.w	r9,r11
8000361c:	c0 62       	brcc	80003628 <flashc_memset64+0x164>
					// Write the flash double-word buffer to the page buffer and reinitialize it.
					*dest.u64ptr++ = flash_dword.u64;
8000361e:	fa e8 00 20 	ld.d	r8,sp[32]
80003622:	af 28       	st.d	r7++,r8
					flash_dword.u64 = source.u64;
80003624:	fa e5 00 20 	st.d	sp[32],r4
				}
			}
		}

		// Write the source data to the page buffer with 64-bit alignment.
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
80003628:	0e 99       	mov	r9,r7
8000362a:	0e 1e       	sub	lr,r7
8000362c:	a3 5e       	asr	lr,0x3
8000362e:	c0 80       	breq	8000363e <flashc_memset64+0x17a>
80003630:	0e 9a       	mov	r10,r7
80003632:	1c 98       	mov	r8,lr
			*dest.u64ptr++ = source.u64;
80003634:	b5 24       	st.d	r10++,r4
				}
			}
		}

		// Write the source data to the page buffer with 64-bit alignment.
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
80003636:	20 18       	sub	r8,1
80003638:	cf e1       	brne	80003634 <flashc_memset64+0x170>
8000363a:	f2 0e 00 37 	add	r7,r9,lr<<0x3
			*dest.u64ptr++ = source.u64;
		}

		// If the current destination page has an incomplete end...
		if (incomplete_flash_page_end) {
8000363e:	40 4a       	lddsp	r10,sp[0x10]
80003640:	14 3c       	cp.w	r12,r10
80003642:	c1 d3       	brcs	8000367c <flashc_memset64+0x1b8>
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			{
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;
80003644:	40 08       	lddsp	r8,sp[0x0]

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
80003646:	40 59       	lddsp	r9,sp[0x14]
80003648:	58 09       	cp.w	r9,0
8000364a:	c1 00       	breq	8000366a <flashc_memset64+0x1a6>
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
8000364c:	10 99       	mov	r9,r8
8000364e:	fa c8 ff e0 	sub	r8,sp,-32
80003652:	40 5b       	lddsp	r11,sp[0x14]
80003654:	16 08       	add	r8,r11
{
	return flashc_memset64(dst, src | (uint64_t)src << 32, nbytes, erase);
}


volatile void *flashc_memset64(volatile void *dst, uint64_t src, size_t nbytes, bool erase)
80003656:	fa cb ff d8 	sub	r11,sp,-40

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
						flash_dword.u8[i] = *tmp.u8ptr++;
8000365a:	13 3a       	ld.ub	r10,r9++
8000365c:	10 ca       	st.b	r8++,r10
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
8000365e:	16 38       	cp.w	r8,r11
80003660:	cf d1       	brne	8000365a <flashc_memset64+0x196>
80003662:	40 78       	lddsp	r8,sp[0x1c]
						flash_dword.u8[i] = *tmp.u8ptr++;

					// Write the flash double-word buffer to the page buffer.
					*dest.u64ptr++ = flash_dword.u64;
80003664:	fa ea 00 20 	ld.d	r10,sp[32]
80003668:	af 2a       	st.d	r7++,r10
				}

				// Fill the end of the page buffer with the current flash page data.
				for (; !Test_align((uint32_t)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++) {
8000366a:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
8000366e:	c0 70       	breq	8000367c <flashc_memset64+0x1b8>
					*tmp.u64ptr = *tmp.u64ptr;
80003670:	f0 ea 00 00 	ld.d	r10,r8[0]
80003674:	b1 2a       	st.d	r8++,r10
					// Write the flash double-word buffer to the page buffer.
					*dest.u64ptr++ = flash_dword.u64;
				}

				// Fill the end of the page buffer with the current flash page data.
				for (; !Test_align((uint32_t)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++) {
80003676:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
8000367a:	cf b1       	brne	80003670 <flashc_memset64+0x1ac>
				}
			}
		}

		// If the current flash page is in the flash array...
		if (dest.u8ptr <= AVR32_FLASHC_USER_PAGE) {
8000367c:	0e 92       	mov	r2,r7
8000367e:	fc 1a 80 80 	movh	r10,0x8080
80003682:	14 37       	cp.w	r7,r10
80003684:	e0 8b 00 17 	brhi	800036b2 <flashc_memset64+0x1ee>
			// Erase the current page if requested and write it from the page buffer.
			if (erase) {
80003688:	40 39       	lddsp	r9,sp[0xc]
8000368a:	58 09       	cp.w	r9,0
8000368c:	c0 70       	breq	8000369a <flashc_memset64+0x1d6>
				flashc_erase_page(-1, false);
8000368e:	30 0b       	mov	r11,0
80003690:	3f fc       	mov	r12,-1
80003692:	f0 1f 00 17 	mcall	800036ec <flashc_memset64+0x228>
				error_status |= flashc_error_status;
80003696:	6c 08       	ld.w	r8,r6[0x0]
80003698:	10 43       	or	r3,r8
			}
			flashc_write_page(-1);
8000369a:	3f fc       	mov	r12,-1
8000369c:	f0 1f 00 15 	mcall	800036f0 <flashc_memset64+0x22c>
			error_status |= flashc_error_status;
800036a0:	6c 08       	ld.w	r8,r6[0x0]
800036a2:	10 43       	or	r3,r8

			// If the end of the flash array is reached, go to the User page.
			if (dest.u8ptr >= flash_array_end.u8ptr) {
				dest.u8ptr = AVR32_FLASHC_USER_PAGE;
800036a4:	fc 18 80 80 	movh	r8,0x8080
800036a8:	40 2b       	lddsp	r11,sp[0x8]
800036aa:	04 3b       	cp.w	r11,r2
800036ac:	f0 07 17 80 	movls	r7,r8
800036b0:	c0 d8       	rjmp	800036ca <flashc_memset64+0x206>
			}
		} else {
			// Erase the User page if requested and write it from the page buffer.
			if (erase) {
800036b2:	40 3a       	lddsp	r10,sp[0xc]
800036b4:	58 0a       	cp.w	r10,0
800036b6:	c0 60       	breq	800036c2 <flashc_memset64+0x1fe>
				flashc_erase_user_page(false);
800036b8:	30 0c       	mov	r12,0
800036ba:	f0 1f 00 0f 	mcall	800036f4 <flashc_memset64+0x230>
				error_status |= flashc_error_status;
800036be:	6c 08       	ld.w	r8,r6[0x0]
800036c0:	10 43       	or	r3,r8
			}
			flashc_write_user_page();
800036c2:	f0 1f 00 0e 	mcall	800036f8 <flashc_memset64+0x234>
			error_status |= flashc_error_status;
800036c6:	6c 08       	ld.w	r8,r6[0x0]
800036c8:	10 43       	or	r3,r8
	dest_end.u16ptr = (uint16_t *)Align_down((uint32_t)dest_end.u8ptr, sizeof(uint16_t));
	dest_end.u32ptr = (uint32_t *)Align_down((uint32_t)dest_end.u16ptr, sizeof(uint32_t));
	dest_end.u64ptr = (uint64_t *)Align_down((uint32_t)dest_end.u32ptr, sizeof(uint64_t));

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
800036ca:	0e 92       	mov	r2,r7
800036cc:	40 09       	lddsp	r9,sp[0x0]
800036ce:	12 37       	cp.w	r7,r9
800036d0:	fe 93 ff 6d 	brlo	800035aa <flashc_memset64+0xe6>
			error_status |= flashc_error_status;
		}
	}

	// Update the FLASHC error status.
	flashc_error_status = error_status;
800036d4:	48 48       	lddpc	r8,800036e4 <flashc_memset64+0x220>
800036d6:	91 03       	st.w	r8[0x0],r3

	// Return the initial destination pointer as the standard memset function does.
	return dst;
}
800036d8:	40 6c       	lddsp	r12,sp[0x18]
800036da:	2f 4d       	sub	sp,-48
800036dc:	d8 32       	popm	r0-r7,pc
800036de:	00 00       	add	r0,r0
800036e0:	80 00       	ld.sh	r0,r0[0x0]
800036e2:	32 f8       	mov	r8,47
800036e4:	00 00       	add	r0,r0
800036e6:	0b 7c       	ld.ub	r12,--r5
800036e8:	80 00       	ld.sh	r0,r0[0x0]
800036ea:	33 f8       	mov	r8,63
800036ec:	80 00       	ld.sh	r0,r0[0x0]
800036ee:	34 2c       	mov	r12,66
800036f0:	80 00       	ld.sh	r0,r0[0x0]
800036f2:	34 64       	mov	r4,70
800036f4:	80 00       	ld.sh	r0,r0[0x0]
800036f6:	34 8c       	mov	r12,72
800036f8:	80 00       	ld.sh	r0,r0[0x0]
800036fa:	34 b4       	mov	r4,75

800036fc <flashc_memset32>:
	return flashc_memset32(dst, src | (uint32_t)src << 16, nbytes, erase);
}


volatile void *flashc_memset32(volatile void *dst, uint32_t src, size_t nbytes, bool erase)
{
800036fc:	d4 21       	pushm	r4-r7,lr
	return flashc_memset64(dst, src | (uint64_t)src << 32, nbytes, erase);
800036fe:	16 96       	mov	r6,r11
80003700:	30 08       	mov	r8,0
80003702:	10 97       	mov	r7,r8
80003704:	16 95       	mov	r5,r11
80003706:	10 94       	mov	r4,r8
80003708:	12 98       	mov	r8,r9
8000370a:	14 99       	mov	r9,r10
8000370c:	ef e6 10 0a 	or	r10,r7,r6
80003710:	0e 4b       	or	r11,r7
80003712:	f0 1f 00 02 	mcall	80003718 <flashc_memset32+0x1c>
}
80003716:	d8 22       	popm	r4-r7,pc
80003718:	80 00       	ld.sh	r0,r0[0x0]
8000371a:	34 c4       	mov	r4,76

8000371c <flashc_memset16>:
	return flashc_memset16(dst, src | (uint16_t)src << 8, nbytes, erase);
}


volatile void *flashc_memset16(volatile void *dst, uint16_t src, size_t nbytes, bool erase)
{
8000371c:	d4 01       	pushm	lr
	return flashc_memset32(dst, src | (uint32_t)src << 16, nbytes, erase);
8000371e:	f7 db d2 10 	bfins	r11,r11,0x10,0x10
80003722:	f0 1f 00 02 	mcall	80003728 <flashc_memset16+0xc>
}
80003726:	d8 02       	popm	pc
80003728:	80 00       	ld.sh	r0,r0[0x0]
8000372a:	36 fc       	mov	r12,111

8000372c <flashc_memset8>:
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WUP, -1);
}


volatile void *flashc_memset8(volatile void *dst, uint8_t src, size_t nbytes, bool erase)
{
8000372c:	d4 01       	pushm	lr
	return flashc_memset16(dst, src | (uint16_t)src << 8, nbytes, erase);
8000372e:	f7 eb 10 8b 	or	r11,r11,r11<<0x8
80003732:	5c 7b       	castu.h	r11
80003734:	f0 1f 00 02 	mcall	8000373c <flashc_memset8+0x10>
}
80003738:	d8 02       	popm	pc
8000373a:	00 00       	add	r0,r0
8000373c:	80 00       	ld.sh	r0,r0[0x0]
8000373e:	37 1c       	mov	r12,113

80003740 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80003740:	f8 08 16 05 	lsr	r8,r12,0x5
80003744:	a9 68       	lsl	r8,0x8
80003746:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
8000374a:	58 1b       	cp.w	r11,1
8000374c:	c0 d0       	breq	80003766 <gpio_enable_module_pin+0x26>
8000374e:	c0 63       	brcs	8000375a <gpio_enable_module_pin+0x1a>
80003750:	58 2b       	cp.w	r11,2
80003752:	c1 00       	breq	80003772 <gpio_enable_module_pin+0x32>
80003754:	58 3b       	cp.w	r11,3
80003756:	c1 40       	breq	8000377e <gpio_enable_module_pin+0x3e>
80003758:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000375a:	30 19       	mov	r9,1
8000375c:	f2 0c 09 49 	lsl	r9,r9,r12
80003760:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80003762:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80003764:	c1 28       	rjmp	80003788 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80003766:	30 19       	mov	r9,1
80003768:	f2 0c 09 49 	lsl	r9,r9,r12
8000376c:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000376e:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80003770:	c0 c8       	rjmp	80003788 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80003772:	30 19       	mov	r9,1
80003774:	f2 0c 09 49 	lsl	r9,r9,r12
80003778:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000377a:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000377c:	c0 68       	rjmp	80003788 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000377e:	30 19       	mov	r9,1
80003780:	f2 0c 09 49 	lsl	r9,r9,r12
80003784:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80003786:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80003788:	30 19       	mov	r9,1
8000378a:	f2 0c 09 4c 	lsl	r12,r9,r12
8000378e:	91 2c       	st.w	r8[0x8],r12
80003790:	5e fd       	retal	0
80003792:	d7 03       	nop

80003794 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80003794:	d4 21       	pushm	r4-r7,lr
80003796:	18 97       	mov	r7,r12
80003798:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000379a:	58 0b       	cp.w	r11,0
8000379c:	c0 31       	brne	800037a2 <gpio_enable_module+0xe>
8000379e:	30 05       	mov	r5,0
800037a0:	c0 d8       	rjmp	800037ba <gpio_enable_module+0x26>
800037a2:	30 06       	mov	r6,0
800037a4:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800037a6:	6e 1b       	ld.w	r11,r7[0x4]
800037a8:	6e 0c       	ld.w	r12,r7[0x0]
800037aa:	f0 1f 00 06 	mcall	800037c0 <gpio_enable_module+0x2c>
800037ae:	18 45       	or	r5,r12
		gpiomap++;
800037b0:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800037b2:	2f f6       	sub	r6,-1
800037b4:	0c 34       	cp.w	r4,r6
800037b6:	fe 9b ff f8 	brhi	800037a6 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
800037ba:	0a 9c       	mov	r12,r5
800037bc:	d8 22       	popm	r4-r7,pc
800037be:	00 00       	add	r0,r0
800037c0:	80 00       	ld.sh	r0,r0[0x0]
800037c2:	37 40       	mov	r0,116

800037c4 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800037c4:	f8 08 16 05 	lsr	r8,r12,0x5
800037c8:	a9 68       	lsl	r8,0x8
800037ca:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
800037ce:	30 19       	mov	r9,1
800037d0:	f2 0c 09 4c 	lsl	r12,r9,r12
800037d4:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
800037d8:	91 1c       	st.w	r8[0x4],r12
}
800037da:	5e fc       	retal	r12

800037dc <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800037dc:	f8 08 16 05 	lsr	r8,r12,0x5
800037e0:	a9 68       	lsl	r8,0x8
800037e2:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
800037e6:	30 19       	mov	r9,1
800037e8:	f2 0c 09 4c 	lsl	r12,r9,r12
800037ec:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
800037f0:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800037f4:	91 1c       	st.w	r8[0x4],r12
}
800037f6:	5e fc       	retal	r12

800037f8 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800037f8:	f8 08 16 05 	lsr	r8,r12,0x5
800037fc:	a9 68       	lsl	r8,0x8
800037fe:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80003802:	30 19       	mov	r9,1
80003804:	f2 0c 09 4c 	lsl	r12,r9,r12
80003808:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
8000380c:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80003810:	91 1c       	st.w	r8[0x4],r12
}
80003812:	5e fc       	retal	r12

80003814 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80003814:	c0 08       	rjmp	80003814 <_unhandled_interrupt>
80003816:	d7 03       	nop

80003818 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80003818:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
8000381c:	49 99       	lddpc	r9,80003880 <INTC_register_interrupt+0x68>
8000381e:	f2 08 00 39 	add	r9,r9,r8<<0x3
80003822:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80003826:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80003828:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
8000382c:	58 0a       	cp.w	r10,0
8000382e:	c0 91       	brne	80003840 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80003830:	49 59       	lddpc	r9,80003884 <INTC_register_interrupt+0x6c>
80003832:	49 6a       	lddpc	r10,80003888 <INTC_register_interrupt+0x70>
80003834:	12 1a       	sub	r10,r9
80003836:	fe 79 08 00 	mov	r9,-63488
8000383a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000383e:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80003840:	58 1a       	cp.w	r10,1
80003842:	c0 a1       	brne	80003856 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80003844:	49 09       	lddpc	r9,80003884 <INTC_register_interrupt+0x6c>
80003846:	49 2a       	lddpc	r10,8000388c <INTC_register_interrupt+0x74>
80003848:	12 1a       	sub	r10,r9
8000384a:	bf aa       	sbr	r10,0x1e
8000384c:	fe 79 08 00 	mov	r9,-63488
80003850:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80003854:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80003856:	58 2a       	cp.w	r10,2
80003858:	c0 a1       	brne	8000386c <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000385a:	48 b9       	lddpc	r9,80003884 <INTC_register_interrupt+0x6c>
8000385c:	48 da       	lddpc	r10,80003890 <INTC_register_interrupt+0x78>
8000385e:	12 1a       	sub	r10,r9
80003860:	bf ba       	sbr	r10,0x1f
80003862:	fe 79 08 00 	mov	r9,-63488
80003866:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000386a:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
8000386c:	48 69       	lddpc	r9,80003884 <INTC_register_interrupt+0x6c>
8000386e:	48 aa       	lddpc	r10,80003894 <INTC_register_interrupt+0x7c>
80003870:	12 1a       	sub	r10,r9
80003872:	ea 1a c0 00 	orh	r10,0xc000
80003876:	fe 79 08 00 	mov	r9,-63488
8000387a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000387e:	5e fc       	retal	r12
80003880:	80 00       	ld.sh	r0,r0[0x0]
80003882:	ba 80       	st.b	sp[0x0],r0
80003884:	80 00       	ld.sh	r0,r0[0x0]
80003886:	b0 00       	st.h	r8[0x0],r0
80003888:	80 00       	ld.sh	r0,r0[0x0]
8000388a:	b1 04       	ld.d	r4,r8
8000388c:	80 00       	ld.sh	r0,r0[0x0]
8000388e:	b1 12       	ld.d	r2,--r8
80003890:	80 00       	ld.sh	r0,r0[0x0]
80003892:	b1 20       	st.d	r8++,r0
80003894:	80 00       	ld.sh	r0,r0[0x0]
80003896:	b1 2e       	st.d	r8++,lr

80003898 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80003898:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000389a:	49 18       	lddpc	r8,800038dc <INTC_init_interrupts+0x44>
8000389c:	e3 b8 00 01 	mtsr	0x4,r8
800038a0:	49 0e       	lddpc	lr,800038e0 <INTC_init_interrupts+0x48>
800038a2:	30 07       	mov	r7,0
800038a4:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800038a6:	49 0c       	lddpc	r12,800038e4 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800038a8:	49 05       	lddpc	r5,800038e8 <INTC_init_interrupts+0x50>
800038aa:	10 15       	sub	r5,r8
800038ac:	fe 76 08 00 	mov	r6,-63488
800038b0:	c1 08       	rjmp	800038d0 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800038b2:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800038b4:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800038b6:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800038b8:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800038bc:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800038be:	10 3a       	cp.w	r10,r8
800038c0:	fe 9b ff fc 	brhi	800038b8 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800038c4:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800038c8:	2f f7       	sub	r7,-1
800038ca:	2f 8e       	sub	lr,-8
800038cc:	59 37       	cp.w	r7,19
800038ce:	c0 50       	breq	800038d8 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800038d0:	7c 08       	ld.w	r8,lr[0x0]
800038d2:	58 08       	cp.w	r8,0
800038d4:	ce f1       	brne	800038b2 <INTC_init_interrupts+0x1a>
800038d6:	cf 7b       	rjmp	800038c4 <INTC_init_interrupts+0x2c>
800038d8:	d8 22       	popm	r4-r7,pc
800038da:	00 00       	add	r0,r0
800038dc:	80 00       	ld.sh	r0,r0[0x0]
800038de:	b0 00       	st.h	r8[0x0],r0
800038e0:	80 00       	ld.sh	r0,r0[0x0]
800038e2:	ba 80       	st.b	sp[0x0],r0
800038e4:	80 00       	ld.sh	r0,r0[0x0]
800038e6:	38 14       	mov	r4,-127
800038e8:	80 00       	ld.sh	r0,r0[0x0]
800038ea:	b1 04       	ld.d	r4,r8

800038ec <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800038ec:	fe 78 08 00 	mov	r8,-63488
800038f0:	e0 69 00 83 	mov	r9,131
800038f4:	f2 0c 01 0c 	sub	r12,r9,r12
800038f8:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800038fc:	f2 ca ff c0 	sub	r10,r9,-64
80003900:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80003904:	58 08       	cp.w	r8,0
80003906:	c0 21       	brne	8000390a <_get_interrupt_handler+0x1e>
80003908:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000390a:	f0 08 12 00 	clz	r8,r8
8000390e:	48 5a       	lddpc	r10,80003920 <_get_interrupt_handler+0x34>
80003910:	f4 09 00 39 	add	r9,r10,r9<<0x3
80003914:	f0 08 11 1f 	rsub	r8,r8,31
80003918:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000391a:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000391e:	5e fc       	retal	r12
80003920:	80 00       	ld.sh	r0,r0[0x0]
80003922:	ba 80       	st.b	sp[0x0],r0

80003924 <pm_set_osc32_mode>:
 * \param mode 32-kHz oscillator mode (i.e. AVR32_PM_OSCCTRL32_MODE_x).
 */
static void pm_set_osc32_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
80003924:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.mode = mode;
80003926:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
8000392a:	99 c8       	st.w	r12[0x30],r8
}
8000392c:	5e fc       	retal	r12
8000392e:	d7 03       	nop

80003930 <pm_enable_osc32_crystal>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
}


void pm_enable_osc32_crystal(volatile avr32_pm_t *pm)
{
80003930:	d4 01       	pushm	lr
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
80003932:	30 1b       	mov	r11,1
80003934:	f0 1f 00 02 	mcall	8000393c <pm_enable_osc32_crystal+0xc>
}
80003938:	d8 02       	popm	pc
8000393a:	00 00       	add	r0,r0
8000393c:	80 00       	ld.sh	r0,r0[0x0]
8000393e:	39 24       	mov	r4,-110

80003940 <pm_enable_clk32_no_wait>:


void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
80003940:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.osc32en = 1;
80003942:	30 19       	mov	r9,1
80003944:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_pm_oscctrl32.OSCCTRL32.startup = startup;
80003948:	f1 db d2 03 	bfins	r8,r11,0x10,0x3
  // Write back
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
8000394c:	99 c8       	st.w	r12[0x30],r8
}
8000394e:	5e fc       	retal	r12

80003950 <pm_wait_for_clk32_ready>:


void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC32RDY_MASK));
80003950:	79 58       	ld.w	r8,r12[0x54]
80003952:	e2 18 02 00 	andl	r8,0x200,COH
80003956:	cf d0       	breq	80003950 <pm_wait_for_clk32_ready>
}
80003958:	5e fc       	retal	r12
8000395a:	d7 03       	nop

8000395c <pm_enable_clk32>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
}


void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup)
{
8000395c:	eb cd 40 80 	pushm	r7,lr
80003960:	18 97       	mov	r7,r12
  pm_enable_clk32_no_wait(pm, startup);
80003962:	f0 1f 00 04 	mcall	80003970 <pm_enable_clk32+0x14>
  pm_wait_for_clk32_ready(pm);
80003966:	0e 9c       	mov	r12,r7
80003968:	f0 1f 00 03 	mcall	80003974 <pm_enable_clk32+0x18>
}
8000396c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003970:	80 00       	ld.sh	r0,r0[0x0]
80003972:	39 40       	mov	r0,-108
80003974:	80 00       	ld.sh	r0,r0[0x0]
80003976:	39 50       	mov	r0,-107

80003978 <rtc_is_busy>:
#include "rtc.h"


int rtc_is_busy(volatile avr32_rtc_t *rtc)
{
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
80003978:	78 0c       	ld.w	r12,r12[0x0]
}
8000397a:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
8000397e:	5e fc       	retal	r12

80003980 <rtc_set_value>:
  return 1;
}


void rtc_set_value(volatile avr32_rtc_t *rtc, unsigned long val)
{
80003980:	eb cd 40 c0 	pushm	r6-r7,lr
80003984:	18 97       	mov	r7,r12
80003986:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
80003988:	0e 9c       	mov	r12,r7
8000398a:	f0 1f 00 06 	mcall	800039a0 <rtc_set_value+0x20>
8000398e:	cf d1       	brne	80003988 <rtc_set_value+0x8>
  // Set the new val value
  rtc->val = val;
80003990:	8f 16       	st.w	r7[0x4],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
80003992:	0e 9c       	mov	r12,r7
80003994:	f0 1f 00 03 	mcall	800039a0 <rtc_set_value+0x20>
80003998:	cf d1       	brne	80003992 <rtc_set_value+0x12>
}
8000399a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000399e:	00 00       	add	r0,r0
800039a0:	80 00       	ld.sh	r0,r0[0x0]
800039a2:	39 78       	mov	r8,-105

800039a4 <rtc_enable>:
  while (rtc_is_busy(rtc));
}


void rtc_enable(volatile avr32_rtc_t *rtc)
{
800039a4:	eb cd 40 80 	pushm	r7,lr
800039a8:	18 97       	mov	r7,r12
  // Wait until the rtc CTRL register is up-to-date
  while (rtc_is_busy(rtc));
800039aa:	0e 9c       	mov	r12,r7
800039ac:	f0 1f 00 06 	mcall	800039c4 <rtc_enable+0x20>
800039b0:	cf d1       	brne	800039aa <rtc_enable+0x6>
  // Enable the RTC
  rtc->ctrl |= AVR32_RTC_CTRL_EN_MASK;
800039b2:	6e 08       	ld.w	r8,r7[0x0]
800039b4:	a1 a8       	sbr	r8,0x0
800039b6:	8f 08       	st.w	r7[0x0],r8
  // Wait until write is done
  while (rtc_is_busy(rtc));
800039b8:	0e 9c       	mov	r12,r7
800039ba:	f0 1f 00 03 	mcall	800039c4 <rtc_enable+0x20>
800039be:	cf d1       	brne	800039b8 <rtc_enable+0x14>
}
800039c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800039c4:	80 00       	ld.sh	r0,r0[0x0]
800039c6:	39 78       	mov	r8,-105

800039c8 <rtc_enable_interrupt>:
}


void rtc_enable_interrupt(volatile avr32_rtc_t *rtc)
{
  rtc->ier = AVR32_RTC_IER_TOPI_MASK;
800039c8:	30 18       	mov	r8,1
800039ca:	99 48       	st.w	r12[0x10],r8
}
800039cc:	5e fc       	retal	r12
800039ce:	d7 03       	nop

800039d0 <rtc_set_top_value>:
  if (global_interrupt_enabled) cpu_irq_enable();
}


void rtc_set_top_value(volatile avr32_rtc_t *rtc, unsigned long top)
{
800039d0:	eb cd 40 c0 	pushm	r6-r7,lr
800039d4:	18 97       	mov	r7,r12
800039d6:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
800039d8:	0e 9c       	mov	r12,r7
800039da:	f0 1f 00 06 	mcall	800039f0 <rtc_set_top_value+0x20>
800039de:	cf d1       	brne	800039d8 <rtc_set_top_value+0x8>
  // Set the new val value
  rtc->top = top;
800039e0:	8f 26       	st.w	r7[0x8],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
800039e2:	0e 9c       	mov	r12,r7
800039e4:	f0 1f 00 03 	mcall	800039f0 <rtc_set_top_value+0x20>
800039e8:	cf d1       	brne	800039e2 <rtc_set_top_value+0x12>
}
800039ea:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800039ee:	00 00       	add	r0,r0
800039f0:	80 00       	ld.sh	r0,r0[0x0]
800039f2:	39 78       	mov	r8,-105

800039f4 <rtc_clear_interrupt>:
}


void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800039f4:	e1 b8 00 00 	mfsr	r8,0x0

  if (global_interrupt_enabled) cpu_irq_disable();
800039f8:	e6 18 00 01 	andh	r8,0x1,COH
800039fc:	c0 71       	brne	80003a0a <rtc_clear_interrupt+0x16>
800039fe:	d3 03       	ssrf	0x10
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
80003a00:	30 18       	mov	r8,1
80003a02:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80003a04:	78 78       	ld.w	r8,r12[0x1c]
  if (global_interrupt_enabled) cpu_irq_enable();
80003a06:	d5 03       	csrf	0x10
80003a08:	5e fc       	retal	r12
void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  if (global_interrupt_enabled) cpu_irq_disable();
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
80003a0a:	30 18       	mov	r8,1
80003a0c:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80003a0e:	78 78       	ld.w	r8,r12[0x1c]
80003a10:	5e fc       	retal	r12
80003a12:	d7 03       	nop

80003a14 <rtc_init>:
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
}


int rtc_init(volatile avr32_rtc_t *rtc, unsigned char osc_type, unsigned char psel)
{
80003a14:	eb cd 40 e0 	pushm	r5-r7,lr
80003a18:	18 97       	mov	r7,r12
80003a1a:	16 96       	mov	r6,r11
80003a1c:	14 95       	mov	r5,r10
  // If exit, it means that the configuration has not been set correctly
  if (osc_type > (1 << AVR32_RTC_CTRL_CLK32_SIZE) - 1 ||
80003a1e:	30 18       	mov	r8,1
80003a20:	f0 0b 18 00 	cp.b	r11,r8
80003a24:	5f b9       	srhi	r9
80003a26:	30 f8       	mov	r8,15
80003a28:	f0 0a 18 00 	cp.b	r10,r8
80003a2c:	5f b8       	srhi	r8
80003a2e:	f3 e8 10 08 	or	r8,r9,r8
80003a32:	c0 30       	breq	80003a38 <rtc_init+0x24>
80003a34:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
      psel > (1 << AVR32_RTC_CTRL_PSEL_SIZE) - 1)
    return 0;

  // If we use the 32-kHz oscillator, we have to enable it first
  if (osc_type == RTC_OSC_32KHZ)
80003a38:	30 18       	mov	r8,1
80003a3a:	f0 0b 18 00 	cp.b	r11,r8
80003a3e:	c0 a1       	brne	80003a52 <rtc_init+0x3e>
  {
    // Select the 32-kHz oscillator crystal
    pm_enable_osc32_crystal(&AVR32_PM);
80003a40:	fe 7c 0c 00 	mov	r12,-62464
80003a44:	f0 1f 00 0f 	mcall	80003a80 <rtc_init+0x6c>
    // Enable the 32-kHz clock and wait until the osc32 clock is ready.
    pm_enable_clk32(&AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC);
80003a48:	30 0b       	mov	r11,0
80003a4a:	fe 7c 0c 00 	mov	r12,-62464
80003a4e:	f0 1f 00 0e 	mcall	80003a84 <rtc_init+0x70>
  }

  // Wait until the rtc accepts writes to the CTRL register
  while (rtc_is_busy(rtc));
80003a52:	0e 9c       	mov	r12,r7
80003a54:	f0 1f 00 0d 	mcall	80003a88 <rtc_init+0x74>
80003a58:	cf d1       	brne	80003a52 <rtc_init+0x3e>

  // Set the new RTC configuration
  rtc->ctrl = osc_type << AVR32_RTC_CTRL_CLK32_OFFSET |
80003a5a:	a3 76       	lsl	r6,0x3
80003a5c:	b1 a6       	sbr	r6,0x10
80003a5e:	ed e5 10 85 	or	r5,r6,r5<<0x8
80003a62:	8f 05       	st.w	r7[0x0],r5
              psel << AVR32_RTC_CTRL_PSEL_OFFSET |
              AVR32_RTC_CTRL_CLKEN_MASK;

  // Wait until write is done
  while (rtc_is_busy(rtc));
80003a64:	0e 9c       	mov	r12,r7
80003a66:	f0 1f 00 09 	mcall	80003a88 <rtc_init+0x74>
80003a6a:	cf d1       	brne	80003a64 <rtc_init+0x50>

  // Set the counter value to 0
  rtc_set_value(rtc, 0x00000000);
80003a6c:	30 0b       	mov	r11,0
80003a6e:	0e 9c       	mov	r12,r7
80003a70:	f0 1f 00 07 	mcall	80003a8c <rtc_init+0x78>
  // Set the top value to 0xFFFFFFFF
  rtc_set_top_value(rtc, 0xFFFFFFFF);
80003a74:	3f fb       	mov	r11,-1
80003a76:	0e 9c       	mov	r12,r7
80003a78:	f0 1f 00 06 	mcall	80003a90 <rtc_init+0x7c>
80003a7c:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80003a80:	80 00       	ld.sh	r0,r0[0x0]
80003a82:	39 30       	mov	r0,-109
80003a84:	80 00       	ld.sh	r0,r0[0x0]
80003a86:	39 5c       	mov	r12,-107
80003a88:	80 00       	ld.sh	r0,r0[0x0]
80003a8a:	39 78       	mov	r8,-105
80003a8c:	80 00       	ld.sh	r0,r0[0x0]
80003a8e:	39 80       	mov	r0,-104
80003a90:	80 00       	ld.sh	r0,r0[0x0]
80003a92:	39 d0       	mov	r0,-99

80003a94 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80003a94:	f8 c8 00 01 	sub	r8,r12,1
80003a98:	f0 0b 00 0b 	add	r11,r8,r11
80003a9c:	f6 0c 0d 0a 	divu	r10,r11,r12
80003aa0:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80003aa2:	f4 c8 00 01 	sub	r8,r10,1
80003aa6:	e0 48 00 fe 	cp.w	r8,254
80003aaa:	e0 88 00 03 	brls	80003ab0 <getBaudDiv+0x1c>
80003aae:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80003ab0:	5c 8c       	casts.h	r12
}
80003ab2:	5e fc       	retal	r12

80003ab4 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80003ab4:	f7 39 00 0d 	ld.ub	r9,r11[13]
80003ab8:	30 18       	mov	r8,1
80003aba:	f0 09 18 00 	cp.b	r9,r8
80003abe:	e0 88 00 04 	brls	80003ac6 <spi_initMaster+0x12>
80003ac2:	30 2c       	mov	r12,2
80003ac4:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
80003ac6:	e0 68 00 80 	mov	r8,128
80003aca:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80003acc:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
80003ace:	30 19       	mov	r9,1
80003ad0:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80003ad4:	f7 39 00 0d 	ld.ub	r9,r11[13]
80003ad8:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80003adc:	30 09       	mov	r9,0
80003ade:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80003ae2:	30 fa       	mov	r10,15
80003ae4:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80003ae8:	99 18       	st.w	r12[0x4],r8
80003aea:	5e f9       	retal	r9

80003aec <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80003aec:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80003aee:	30 18       	mov	r8,1
80003af0:	f0 0b 18 00 	cp.b	r11,r8
80003af4:	5f be       	srhi	lr
80003af6:	f0 0a 18 00 	cp.b	r10,r8
80003afa:	5f b8       	srhi	r8
80003afc:	fd e8 10 08 	or	r8,lr,r8
80003b00:	c0 30       	breq	80003b06 <spi_selectionMode+0x1a>
80003b02:	30 2c       	mov	r12,2
80003b04:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80003b06:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80003b08:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80003b0c:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80003b10:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80003b14:	99 18       	st.w	r12[0x4],r8
80003b16:	d8 0a       	popm	pc,r12=0

80003b18 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80003b18:	30 18       	mov	r8,1
80003b1a:	99 08       	st.w	r12[0x0],r8
}
80003b1c:	5e fc       	retal	r12

80003b1e <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80003b1e:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80003b22:	c0 58       	rjmp	80003b2c <spi_write+0xe>
		if (!timeout--) {
80003b24:	58 08       	cp.w	r8,0
80003b26:	c0 21       	brne	80003b2a <spi_write+0xc>
80003b28:	5e ff       	retal	1
80003b2a:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80003b2c:	78 49       	ld.w	r9,r12[0x10]
80003b2e:	e2 19 00 02 	andl	r9,0x2,COH
80003b32:	cf 90       	breq	80003b24 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80003b34:	5c 7b       	castu.h	r11
80003b36:	99 3b       	st.w	r12[0xc],r11
80003b38:	5e fd       	retal	0

80003b3a <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80003b3a:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80003b3e:	c0 58       	rjmp	80003b48 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80003b40:	58 08       	cp.w	r8,0
80003b42:	c0 21       	brne	80003b46 <spi_read+0xc>
80003b44:	5e ff       	retal	1
80003b46:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80003b48:	78 49       	ld.w	r9,r12[0x10]
80003b4a:	e2 19 02 01 	andl	r9,0x201,COH
80003b4e:	e0 49 02 01 	cp.w	r9,513
80003b52:	cf 71       	brne	80003b40 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80003b54:	78 28       	ld.w	r8,r12[0x8]
80003b56:	b6 08       	st.h	r11[0x0],r8
80003b58:	5e fd       	retal	0
80003b5a:	d7 03       	nop

80003b5c <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80003b5c:	eb cd 40 f8 	pushm	r3-r7,lr
80003b60:	18 95       	mov	r5,r12
80003b62:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80003b64:	f7 36 00 0c 	ld.ub	r6,r11[12]
80003b68:	30 38       	mov	r8,3
80003b6a:	f0 06 18 00 	cp.b	r6,r8
80003b6e:	e0 8b 00 5e 	brhi	80003c2a <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
80003b72:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80003b76:	30 18       	mov	r8,1
80003b78:	f0 04 18 00 	cp.b	r4,r8
80003b7c:	e0 8b 00 57 	brhi	80003c2a <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80003b80:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80003b84:	30 78       	mov	r8,7
80003b86:	f0 03 18 00 	cp.b	r3,r8
80003b8a:	e0 88 00 50 	brls	80003c2a <spi_setupChipReg+0xce>
80003b8e:	31 08       	mov	r8,16
80003b90:	f0 03 18 00 	cp.b	r3,r8
80003b94:	e0 8b 00 4b 	brhi	80003c2a <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80003b98:	14 9b       	mov	r11,r10
80003b9a:	6e 1c       	ld.w	r12,r7[0x4]
80003b9c:	f0 1f 00 26 	mcall	80003c34 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
80003ba0:	c4 55       	brlt	80003c2a <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80003ba2:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80003ba4:	ec 09 16 01 	lsr	r9,r6,0x1
80003ba8:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80003bac:	ec 16 00 01 	eorl	r6,0x1
80003bb0:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80003bb4:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80003bb8:	20 83       	sub	r3,8
80003bba:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80003bbe:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80003bc2:	ef 39 00 09 	ld.ub	r9,r7[9]
80003bc6:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80003bca:	ef 39 00 0a 	ld.ub	r9,r7[10]
80003bce:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80003bd2:	0f 89       	ld.ub	r9,r7[0x0]
80003bd4:	30 1a       	mov	r10,1
80003bd6:	f4 09 18 00 	cp.b	r9,r10
80003bda:	c0 d0       	breq	80003bf4 <spi_setupChipReg+0x98>
80003bdc:	c0 a3       	brcs	80003bf0 <spi_setupChipReg+0x94>
80003bde:	30 2a       	mov	r10,2
80003be0:	f4 09 18 00 	cp.b	r9,r10
80003be4:	c0 a0       	breq	80003bf8 <spi_setupChipReg+0x9c>
80003be6:	30 3a       	mov	r10,3
80003be8:	f4 09 18 00 	cp.b	r9,r10
80003bec:	c1 f1       	brne	80003c2a <spi_setupChipReg+0xce>
80003bee:	c0 78       	rjmp	80003bfc <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80003bf0:	8b c8       	st.w	r5[0x30],r8
		break;
80003bf2:	c0 68       	rjmp	80003bfe <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80003bf4:	8b d8       	st.w	r5[0x34],r8
		break;
80003bf6:	c0 48       	rjmp	80003bfe <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80003bf8:	8b e8       	st.w	r5[0x38],r8
		break;
80003bfa:	c0 28       	rjmp	80003bfe <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80003bfc:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80003bfe:	48 f8       	lddpc	r8,80003c38 <spi_setupChipReg+0xdc>
80003c00:	70 08       	ld.w	r8,r8[0x0]
80003c02:	58 08       	cp.w	r8,0
80003c04:	c1 61       	brne	80003c30 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
80003c06:	30 0b       	mov	r11,0
80003c08:	30 1c       	mov	r12,1
80003c0a:	f0 1f 00 0d 	mcall	80003c3c <spi_setupChipReg+0xe0>
80003c0e:	48 b8       	lddpc	r8,80003c38 <spi_setupChipReg+0xdc>
80003c10:	91 0c       	st.w	r8[0x0],r12
80003c12:	58 0c       	cp.w	r12,0
80003c14:	c0 a0       	breq	80003c28 <spi_setupChipReg+0xcc>
80003c16:	30 09       	mov	r9,0
80003c18:	12 9a       	mov	r10,r9
80003c1a:	12 9b       	mov	r11,r9
80003c1c:	f0 1f 00 09 	mcall	80003c40 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80003c20:	48 68       	lddpc	r8,80003c38 <spi_setupChipReg+0xdc>
80003c22:	70 08       	ld.w	r8,r8[0x0]
80003c24:	58 08       	cp.w	r8,0
80003c26:	c0 51       	brne	80003c30 <spi_setupChipReg+0xd4>
80003c28:	c0 08       	rjmp	80003c28 <spi_setupChipReg+0xcc>
80003c2a:	30 2c       	mov	r12,2
80003c2c:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80003c30:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80003c34:	80 00       	ld.sh	r0,r0[0x0]
80003c36:	3a 94       	mov	r4,-87
80003c38:	00 00       	add	r0,r0
80003c3a:	51 3c       	stdsp	sp[0x4c],r12
80003c3c:	80 00       	ld.sh	r0,r0[0x0]
80003c3e:	47 28       	lddsp	r8,sp[0x1c8]
80003c40:	80 00       	ld.sh	r0,r0[0x0]
80003c42:	46 28       	lddsp	r8,sp[0x188]

80003c44 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80003c44:	d4 01       	pushm	lr
80003c46:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80003c4a:	c0 58       	rjmp	80003c54 <spi_unselectChip+0x10>
		if (!timeout--) {
80003c4c:	58 08       	cp.w	r8,0
80003c4e:	c0 21       	brne	80003c52 <spi_unselectChip+0xe>
80003c50:	da 0a       	popm	pc,r12=1
80003c52:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80003c54:	78 49       	ld.w	r9,r12[0x10]
80003c56:	e2 19 02 00 	andl	r9,0x200,COH
80003c5a:	cf 90       	breq	80003c4c <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80003c5c:	78 18       	ld.w	r8,r12[0x4]
80003c5e:	ea 18 00 0f 	orh	r8,0xf
80003c62:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80003c64:	fc 18 01 00 	movh	r8,0x100
80003c68:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80003c6a:	30 09       	mov	r9,0
80003c6c:	12 9a       	mov	r10,r9
80003c6e:	12 9b       	mov	r11,r9
80003c70:	48 38       	lddpc	r8,80003c7c <spi_unselectChip+0x38>
80003c72:	70 0c       	ld.w	r12,r8[0x0]
80003c74:	f0 1f 00 03 	mcall	80003c80 <spi_unselectChip+0x3c>
80003c78:	d8 0a       	popm	pc,r12=0
80003c7a:	00 00       	add	r0,r0
80003c7c:	00 00       	add	r0,r0
80003c7e:	51 3c       	stdsp	sp[0x4c],r12
80003c80:	80 00       	ld.sh	r0,r0[0x0]
80003c82:	46 28       	lddsp	r8,sp[0x188]

80003c84 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80003c84:	eb cd 40 f8 	pushm	r3-r7,lr
80003c88:	18 94       	mov	r4,r12
80003c8a:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80003c8c:	49 a6       	lddpc	r6,80003cf4 <spi_selectChip+0x70>
80003c8e:	30 07       	mov	r7,0
80003c90:	31 45       	mov	r5,20
80003c92:	0e 99       	mov	r9,r7
80003c94:	0a 9a       	mov	r10,r5
80003c96:	0e 9b       	mov	r11,r7
80003c98:	6c 0c       	ld.w	r12,r6[0x0]
80003c9a:	f0 1f 00 18 	mcall	80003cf8 <spi_selectChip+0x74>
80003c9e:	cf a0       	breq	80003c92 <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80003ca0:	68 18       	ld.w	r8,r4[0x4]
80003ca2:	ea 18 00 0f 	orh	r8,0xf
80003ca6:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80003ca8:	68 18       	ld.w	r8,r4[0x4]
80003caa:	e2 18 00 04 	andl	r8,0x4,COH
80003cae:	c1 10       	breq	80003cd0 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80003cb0:	30 e8       	mov	r8,14
80003cb2:	f0 03 18 00 	cp.b	r3,r8
80003cb6:	e0 8b 00 1c 	brhi	80003cee <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80003cba:	68 19       	ld.w	r9,r4[0x4]
80003cbc:	e6 08 15 10 	lsl	r8,r3,0x10
80003cc0:	ea 18 ff f0 	orh	r8,0xfff0
80003cc4:	e8 18 ff ff 	orl	r8,0xffff
80003cc8:	12 68       	and	r8,r9
80003cca:	89 18       	st.w	r4[0x4],r8
80003ccc:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80003cd0:	30 38       	mov	r8,3
80003cd2:	f0 03 18 00 	cp.b	r3,r8
80003cd6:	e0 8b 00 0c 	brhi	80003cee <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80003cda:	68 19       	ld.w	r9,r4[0x4]
80003cdc:	2f 03       	sub	r3,-16
80003cde:	30 18       	mov	r8,1
80003ce0:	f0 03 09 48 	lsl	r8,r8,r3
80003ce4:	5c d8       	com	r8
80003ce6:	12 68       	and	r8,r9
80003ce8:	89 18       	st.w	r4[0x4],r8
80003cea:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80003cee:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80003cf0:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80003cf4:	00 00       	add	r0,r0
80003cf6:	51 3c       	stdsp	sp[0x4c],r12
80003cf8:	80 00       	ld.sh	r0,r0[0x0]
80003cfa:	44 1c       	lddsp	r12,sp[0x104]

80003cfc <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80003cfc:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80003cfe:	f6 08 15 04 	lsl	r8,r11,0x4
80003d02:	14 38       	cp.w	r8,r10
80003d04:	f9 b8 08 10 	movls	r8,16
80003d08:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80003d0c:	f0 0b 02 4b 	mul	r11,r8,r11
80003d10:	f6 09 16 01 	lsr	r9,r11,0x1
80003d14:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80003d18:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80003d1c:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80003d20:	f2 cb 00 01 	sub	r11,r9,1
80003d24:	e0 4b ff fe 	cp.w	r11,65534
80003d28:	e0 88 00 03 	brls	80003d2e <usart_set_async_baudrate+0x32>
80003d2c:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80003d2e:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80003d30:	e8 6e 00 00 	mov	lr,524288
80003d34:	59 08       	cp.w	r8,16
80003d36:	fc 08 17 10 	movne	r8,lr
80003d3a:	f9 b8 00 00 	moveq	r8,0
80003d3e:	e4 1b ff f7 	andh	r11,0xfff7
80003d42:	e0 1b fe cf 	andl	r11,0xfecf
80003d46:	16 48       	or	r8,r11
80003d48:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80003d4a:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80003d4e:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80003d52:	99 89       	st.w	r12[0x20],r9
80003d54:	d8 0a       	popm	pc,r12=0

80003d56 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80003d56:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80003d58:	e2 18 00 02 	andl	r8,0x2,COH
80003d5c:	c0 31       	brne	80003d62 <usart_write_char+0xc>
80003d5e:	30 2c       	mov	r12,2
80003d60:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80003d62:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80003d66:	99 7b       	st.w	r12[0x1c],r11
80003d68:	5e fd       	retal	0
80003d6a:	d7 03       	nop

80003d6c <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80003d6c:	eb cd 40 e0 	pushm	r5-r7,lr
80003d70:	18 96       	mov	r6,r12
80003d72:	16 95       	mov	r5,r11
80003d74:	e0 67 27 0f 	mov	r7,9999
80003d78:	c0 68       	rjmp	80003d84 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80003d7a:	58 07       	cp.w	r7,0
80003d7c:	c0 31       	brne	80003d82 <usart_putchar+0x16>
80003d7e:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80003d82:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80003d84:	0a 9b       	mov	r11,r5
80003d86:	0c 9c       	mov	r12,r6
80003d88:	f0 1f 00 03 	mcall	80003d94 <usart_putchar+0x28>
80003d8c:	cf 71       	brne	80003d7a <usart_putchar+0xe>

  return USART_SUCCESS;
}
80003d8e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003d92:	00 00       	add	r0,r0
80003d94:	80 00       	ld.sh	r0,r0[0x0]
80003d96:	3d 56       	mov	r6,-43

80003d98 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80003d98:	78 58       	ld.w	r8,r12[0x14]
80003d9a:	e2 18 00 e0 	andl	r8,0xe0,COH
80003d9e:	c0 30       	breq	80003da4 <usart_read_char+0xc>
80003da0:	30 4c       	mov	r12,4
80003da2:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80003da4:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80003da6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003daa:	c0 31       	brne	80003db0 <usart_read_char+0x18>
80003dac:	30 3c       	mov	r12,3
80003dae:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80003db0:	78 68       	ld.w	r8,r12[0x18]
80003db2:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80003db6:	97 08       	st.w	r11[0x0],r8
80003db8:	5e fd       	retal	0
80003dba:	d7 03       	nop

80003dbc <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80003dbc:	eb cd 40 c0 	pushm	r6-r7,lr
80003dc0:	20 1d       	sub	sp,4
80003dc2:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80003dc4:	1a 97       	mov	r7,sp
80003dc6:	1a 9b       	mov	r11,sp
80003dc8:	0c 9c       	mov	r12,r6
80003dca:	f0 1f 00 07 	mcall	80003de4 <usart_getchar+0x28>
80003dce:	58 3c       	cp.w	r12,3
80003dd0:	cf b0       	breq	80003dc6 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80003dd2:	58 4c       	cp.w	r12,4
80003dd4:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80003dd8:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80003ddc:	2f fd       	sub	sp,-4
80003dde:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003de2:	00 00       	add	r0,r0
80003de4:	80 00       	ld.sh	r0,r0[0x0]
80003de6:	3d 98       	mov	r8,-39

80003de8 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80003de8:	eb cd 40 c0 	pushm	r6-r7,lr
80003dec:	18 96       	mov	r6,r12
80003dee:	16 97       	mov	r7,r11
  while (*string != '\0')
80003df0:	17 8b       	ld.ub	r11,r11[0x0]
80003df2:	58 0b       	cp.w	r11,0
80003df4:	c0 80       	breq	80003e04 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80003df6:	2f f7       	sub	r7,-1
80003df8:	0c 9c       	mov	r12,r6
80003dfa:	f0 1f 00 04 	mcall	80003e08 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80003dfe:	0f 8b       	ld.ub	r11,r7[0x0]
80003e00:	58 0b       	cp.w	r11,0
80003e02:	cf a1       	brne	80003df6 <usart_write_line+0xe>
80003e04:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003e08:	80 00       	ld.sh	r0,r0[0x0]
80003e0a:	3d 6c       	mov	r12,-42

80003e0c <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80003e0c:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80003e10:	e6 18 00 01 	andh	r8,0x1,COH
80003e14:	c0 71       	brne	80003e22 <usart_reset+0x16>
80003e16:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80003e18:	3f f8       	mov	r8,-1
80003e1a:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80003e1c:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80003e1e:	d5 03       	csrf	0x10
80003e20:	c0 48       	rjmp	80003e28 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80003e22:	3f f8       	mov	r8,-1
80003e24:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80003e26:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80003e28:	30 08       	mov	r8,0
80003e2a:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80003e2c:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80003e2e:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80003e30:	ea 68 61 0c 	mov	r8,680204
80003e34:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80003e36:	5e fc       	retal	r12

80003e38 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80003e38:	eb cd 40 e0 	pushm	r5-r7,lr
80003e3c:	18 96       	mov	r6,r12
80003e3e:	16 97       	mov	r7,r11
80003e40:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80003e42:	f0 1f 00 2f 	mcall	80003efc <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80003e46:	58 07       	cp.w	r7,0
80003e48:	c5 80       	breq	80003ef8 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80003e4a:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80003e4c:	30 49       	mov	r9,4
80003e4e:	f2 08 18 00 	cp.b	r8,r9
80003e52:	e0 88 00 53 	brls	80003ef8 <usart_init_rs232+0xc0>
80003e56:	30 99       	mov	r9,9
80003e58:	f2 08 18 00 	cp.b	r8,r9
80003e5c:	e0 8b 00 4e 	brhi	80003ef8 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80003e60:	0f d9       	ld.ub	r9,r7[0x5]
80003e62:	30 78       	mov	r8,7
80003e64:	f0 09 18 00 	cp.b	r9,r8
80003e68:	e0 8b 00 48 	brhi	80003ef8 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80003e6c:	8e 39       	ld.sh	r9,r7[0x6]
80003e6e:	e0 68 01 01 	mov	r8,257
80003e72:	f0 09 19 00 	cp.h	r9,r8
80003e76:	e0 8b 00 41 	brhi	80003ef8 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80003e7a:	ef 39 00 08 	ld.ub	r9,r7[8]
80003e7e:	30 38       	mov	r8,3
80003e80:	f0 09 18 00 	cp.b	r9,r8
80003e84:	e0 8b 00 3a 	brhi	80003ef8 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80003e88:	0a 9a       	mov	r10,r5
80003e8a:	6e 0b       	ld.w	r11,r7[0x0]
80003e8c:	0c 9c       	mov	r12,r6
80003e8e:	f0 1f 00 1d 	mcall	80003f00 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80003e92:	58 1c       	cp.w	r12,1
80003e94:	c3 20       	breq	80003ef8 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80003e96:	0f c8       	ld.ub	r8,r7[0x4]
80003e98:	30 99       	mov	r9,9
80003e9a:	f2 08 18 00 	cp.b	r8,r9
80003e9e:	c0 51       	brne	80003ea8 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80003ea0:	6c 18       	ld.w	r8,r6[0x4]
80003ea2:	b1 b8       	sbr	r8,0x11
80003ea4:	8d 18       	st.w	r6[0x4],r8
80003ea6:	c0 68       	rjmp	80003eb2 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80003ea8:	6c 19       	ld.w	r9,r6[0x4]
80003eaa:	20 58       	sub	r8,5
80003eac:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80003eb0:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80003eb2:	6c 19       	ld.w	r9,r6[0x4]
80003eb4:	ef 3a 00 08 	ld.ub	r10,r7[8]
80003eb8:	0f d8       	ld.ub	r8,r7[0x5]
80003eba:	a9 78       	lsl	r8,0x9
80003ebc:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80003ec0:	12 48       	or	r8,r9
80003ec2:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80003ec4:	8e 38       	ld.sh	r8,r7[0x6]
80003ec6:	30 29       	mov	r9,2
80003ec8:	f2 08 19 00 	cp.h	r8,r9
80003ecc:	e0 88 00 09 	brls	80003ede <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80003ed0:	6c 18       	ld.w	r8,r6[0x4]
80003ed2:	ad b8       	sbr	r8,0xd
80003ed4:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80003ed6:	8e b8       	ld.uh	r8,r7[0x6]
80003ed8:	20 28       	sub	r8,2
80003eda:	8d a8       	st.w	r6[0x28],r8
80003edc:	c0 68       	rjmp	80003ee8 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80003ede:	6c 19       	ld.w	r9,r6[0x4]
80003ee0:	5c 78       	castu.h	r8
80003ee2:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80003ee6:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80003ee8:	6c 18       	ld.w	r8,r6[0x4]
80003eea:	e0 18 ff f0 	andl	r8,0xfff0
80003eee:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80003ef0:	35 08       	mov	r8,80
80003ef2:	8d 08       	st.w	r6[0x0],r8
80003ef4:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80003ef8:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80003efc:	80 00       	ld.sh	r0,r0[0x0]
80003efe:	3e 0c       	mov	r12,-32
80003f00:	80 00       	ld.sh	r0,r0[0x0]
80003f02:	3c fc       	mov	r12,-49

80003f04 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80003f04:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80003f08:	fe c0 8f 08 	sub	r0,pc,-28920

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80003f0c:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80003f10:	d5 53       	csrf	0x15
  cp      r0, r1
80003f12:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80003f14:	e0 61 0a 48 	mov	r1,2632
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80003f18:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80003f1a:	c0 62       	brcc	80003f26 <idata_load_loop_end>
  cp      r0, r1
80003f1c:	48 92       	lddpc	r2,80003f40 <udata_clear_loop_end+0x4>

80003f1e <idata_load_loop>:
  brlo    idata_load_loop
80003f1e:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80003f20:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80003f22:	02 30       	cp.w	r0,r1
  cp      r0, r1
80003f24:	cf d3       	brcs	80003f1e <idata_load_loop>

80003f26 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80003f26:	e0 60 0a 48 	mov	r0,2632
  mov     r2, 0
  mov     r3, 0
80003f2a:	e0 61 51 50 	mov	r1,20816
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80003f2e:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80003f30:	c0 62       	brcc	80003f3c <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80003f32:	30 02       	mov	r2,0
80003f34:	30 03       	mov	r3,0

80003f36 <udata_clear_loop>:
80003f36:	a1 22       	st.d	r0++,r2
80003f38:	02 30       	cp.w	r0,r1
80003f3a:	cf e3       	brcs	80003f36 <udata_clear_loop>

80003f3c <udata_clear_loop_end>:
80003f3c:	fe cf e9 7c 	sub	pc,pc,-5764
80003f40:	80 00       	ld.sh	r0,r0[0x0]
80003f42:	c3 b0       	breq	80003fb8 <vListRemove+0xa>

80003f44 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80003f44:	f8 c8 ff f8 	sub	r8,r12,-8
80003f48:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80003f4a:	3f f9       	mov	r9,-1
80003f4c:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80003f4e:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80003f50:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80003f52:	30 08       	mov	r8,0
80003f54:	99 08       	st.w	r12[0x0],r8
}
80003f56:	5e fc       	retal	r12

80003f58 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80003f58:	30 08       	mov	r8,0
80003f5a:	99 48       	st.w	r12[0x10],r8
}
80003f5c:	5e fc       	retal	r12

80003f5e <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80003f5e:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80003f60:	70 19       	ld.w	r9,r8[0x4]
80003f62:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80003f64:	78 19       	ld.w	r9,r12[0x4]
80003f66:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80003f68:	70 19       	ld.w	r9,r8[0x4]
80003f6a:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80003f6c:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80003f6e:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80003f70:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80003f72:	78 08       	ld.w	r8,r12[0x0]
80003f74:	2f f8       	sub	r8,-1
80003f76:	99 08       	st.w	r12[0x0],r8
}
80003f78:	5e fc       	retal	r12

80003f7a <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80003f7a:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80003f7c:	5b fa       	cp.w	r10,-1
80003f7e:	c0 31       	brne	80003f84 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80003f80:	78 48       	ld.w	r8,r12[0x10]
80003f82:	c0 c8       	rjmp	80003f9a <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80003f84:	f8 c8 ff f8 	sub	r8,r12,-8
80003f88:	70 19       	ld.w	r9,r8[0x4]
80003f8a:	72 09       	ld.w	r9,r9[0x0]
80003f8c:	12 3a       	cp.w	r10,r9
80003f8e:	c0 63       	brcs	80003f9a <vListInsert+0x20>
80003f90:	70 18       	ld.w	r8,r8[0x4]
80003f92:	70 19       	ld.w	r9,r8[0x4]
80003f94:	72 09       	ld.w	r9,r9[0x0]
80003f96:	12 3a       	cp.w	r10,r9
80003f98:	cf c2       	brcc	80003f90 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80003f9a:	70 19       	ld.w	r9,r8[0x4]
80003f9c:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80003f9e:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80003fa0:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80003fa2:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80003fa4:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80003fa6:	78 08       	ld.w	r8,r12[0x0]
80003fa8:	2f f8       	sub	r8,-1
80003faa:	99 08       	st.w	r12[0x0],r8
}
80003fac:	5e fc       	retal	r12

80003fae <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80003fae:	78 18       	ld.w	r8,r12[0x4]
80003fb0:	78 29       	ld.w	r9,r12[0x8]
80003fb2:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80003fb4:	78 28       	ld.w	r8,r12[0x8]
80003fb6:	78 19       	ld.w	r9,r12[0x4]
80003fb8:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80003fba:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80003fbc:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80003fbe:	18 39       	cp.w	r9,r12
80003fc0:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80003fc4:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80003fc8:	30 09       	mov	r9,0
80003fca:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80003fcc:	70 09       	ld.w	r9,r8[0x0]
80003fce:	20 19       	sub	r9,1
80003fd0:	91 09       	st.w	r8[0x0],r9
}
80003fd2:	5e fc       	retal	r12

80003fd4 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80003fd4:	e0 68 08 08 	mov	r8,2056
80003fd8:	ea 18 08 08 	orh	r8,0x808
80003fdc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80003fde:	e0 68 09 09 	mov	r8,2313
80003fe2:	ea 18 09 09 	orh	r8,0x909
80003fe6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80003fe8:	e0 68 0a 0a 	mov	r8,2570
80003fec:	ea 18 0a 0a 	orh	r8,0xa0a
80003ff0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80003ff2:	e0 68 0b 0b 	mov	r8,2827
80003ff6:	ea 18 0b 0b 	orh	r8,0xb0b
80003ffa:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80003ffc:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80003ffe:	e0 68 be ef 	mov	r8,48879
80004002:	ea 18 de ad 	orh	r8,0xdead
80004006:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80004008:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
8000400a:	fc 18 00 40 	movh	r8,0x40
8000400e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80004010:	e0 68 00 ff 	mov	r8,255
80004014:	ea 18 ff 00 	orh	r8,0xff00
80004018:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
8000401a:	e0 68 01 01 	mov	r8,257
8000401e:	ea 18 01 01 	orh	r8,0x101
80004022:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80004024:	e0 68 02 02 	mov	r8,514
80004028:	ea 18 02 02 	orh	r8,0x202
8000402c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
8000402e:	e0 68 03 03 	mov	r8,771
80004032:	ea 18 03 03 	orh	r8,0x303
80004036:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80004038:	e0 68 04 04 	mov	r8,1028
8000403c:	ea 18 04 04 	orh	r8,0x404
80004040:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80004042:	e0 68 05 05 	mov	r8,1285
80004046:	ea 18 05 05 	orh	r8,0x505
8000404a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
8000404c:	e0 68 06 06 	mov	r8,1542
80004050:	ea 18 06 06 	orh	r8,0x606
80004054:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80004056:	e0 68 07 07 	mov	r8,1799
8000405a:	ea 18 07 07 	orh	r8,0x707
8000405e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80004060:	30 08       	mov	r8,0
80004062:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80004064:	5e fc       	retal	r12
80004066:	d7 03       	nop

80004068 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80004068:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
8000406a:	48 38       	lddpc	r8,80004074 <vPortEnterCritical+0xc>
8000406c:	70 09       	ld.w	r9,r8[0x0]
8000406e:	2f f9       	sub	r9,-1
80004070:	91 09       	st.w	r8[0x0],r9
}
80004072:	5e fc       	retal	r12
80004074:	00 00       	add	r0,r0
80004076:	05 38       	ld.ub	r8,r2++

80004078 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80004078:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
8000407a:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
8000407c:	30 0a       	mov	r10,0
8000407e:	14 9b       	mov	r11,r10
80004080:	49 2c       	lddpc	r12,800040c8 <xPortStartScheduler+0x50>
80004082:	f0 1f 00 13 	mcall	800040cc <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80004086:	e0 68 5d c0 	mov	r8,24000
8000408a:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
8000408e:	30 08       	mov	r8,0
80004090:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80004094:	e0 68 0c f8 	mov	r8,3320
80004098:	ea 18 00 00 	orh	r8,0x0
8000409c:	70 00       	ld.w	r0,r8[0x0]
8000409e:	60 0d       	ld.w	sp,r0[0x0]
800040a0:	1b 00       	ld.w	r0,sp++
800040a2:	e0 68 05 38 	mov	r8,1336
800040a6:	ea 18 00 00 	orh	r8,0x0
800040aa:	91 00       	st.w	r8[0x0],r0
800040ac:	e3 cd 00 ff 	ldm	sp++,r0-r7
800040b0:	2f ed       	sub	sp,-8
800040b2:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
800040b6:	fa f0 ff e0 	ld.w	r0,sp[-32]
800040ba:	e3 b0 00 00 	mtsr	0x0,r0
800040be:	fa f0 ff dc 	ld.w	r0,sp[-36]
800040c2:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
800040c6:	d8 0a       	popm	pc,r12=0
800040c8:	80 00       	ld.sh	r0,r0[0x0]
800040ca:	41 94       	lddsp	r4,sp[0x64]
800040cc:	80 00       	ld.sh	r0,r0[0x0]
800040ce:	38 18       	mov	r8,-127

800040d0 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
800040d0:	20 6d       	sub	sp,24
800040d2:	eb cd 00 ff 	pushm	r0-r7
800040d6:	fa c7 ff c0 	sub	r7,sp,-64
800040da:	ee f0 ff f8 	ld.w	r0,r7[-8]
800040de:	ef 40 ff e0 	st.w	r7[-32],r0
800040e2:	ee f0 ff fc 	ld.w	r0,r7[-4]
800040e6:	ef 40 ff e4 	st.w	r7[-28],r0
800040ea:	eb c7 5f 00 	stm	--r7,r8-r12,lr
800040ee:	e0 68 05 38 	mov	r8,1336
800040f2:	ea 18 00 00 	orh	r8,0x0
800040f6:	70 00       	ld.w	r0,r8[0x0]
800040f8:	1a d0       	st.w	--sp,r0
800040fa:	f0 1f 00 1a 	mcall	80004160 <LABEL_RET_SCALL_263+0x14>
800040fe:	e0 68 0c f8 	mov	r8,3320
80004102:	ea 18 00 00 	orh	r8,0x0
80004106:	70 00       	ld.w	r0,r8[0x0]
80004108:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
8000410a:	f0 1f 00 17 	mcall	80004164 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
8000410e:	e0 68 0c f8 	mov	r8,3320
80004112:	ea 18 00 00 	orh	r8,0x0
80004116:	70 00       	ld.w	r0,r8[0x0]
80004118:	60 0d       	ld.w	sp,r0[0x0]
8000411a:	1b 00       	ld.w	r0,sp++
8000411c:	e0 68 05 38 	mov	r8,1336
80004120:	ea 18 00 00 	orh	r8,0x0
80004124:	91 00       	st.w	r8[0x0],r0
80004126:	fa c7 ff d8 	sub	r7,sp,-40
8000412a:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
8000412e:	ee f0 ff e0 	ld.w	r0,r7[-32]
80004132:	e0 61 05 38 	mov	r1,1336
80004136:	ea 11 00 00 	orh	r1,0x0
8000413a:	62 02       	ld.w	r2,r1[0x0]
8000413c:	58 02       	cp.w	r2,0
8000413e:	c0 70       	breq	8000414c <LABEL_RET_SCALL_263>
80004140:	e4 c2 00 01 	sub	r2,r2,1
80004144:	83 02       	st.w	r1[0x0],r2
80004146:	58 02       	cp.w	r2,0
80004148:	c0 21       	brne	8000414c <LABEL_RET_SCALL_263>
8000414a:	b1 c0       	cbr	r0,0x10

8000414c <LABEL_RET_SCALL_263>:
8000414c:	ef 40 ff f8 	st.w	r7[-8],r0
80004150:	ee f0 ff e4 	ld.w	r0,r7[-28]
80004154:	ef 40 ff fc 	st.w	r7[-4],r0
80004158:	e3 cd 00 ff 	ldm	sp++,r0-r7
8000415c:	2f ad       	sub	sp,-24
8000415e:	d6 13       	rets
80004160:	80 00       	ld.sh	r0,r0[0x0]
80004162:	40 68       	lddsp	r8,sp[0x18]
80004164:	80 00       	ld.sh	r0,r0[0x0]
80004166:	47 ac       	lddsp	r12,sp[0x1e8]

80004168 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80004168:	e1 b8 00 43 	mfsr	r8,0x10c
8000416c:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80004170:	5e fc       	retal	r12
80004172:	d7 03       	nop

80004174 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80004174:	48 78       	lddpc	r8,80004190 <vPortExitCritical+0x1c>
80004176:	70 08       	ld.w	r8,r8[0x0]
80004178:	58 08       	cp.w	r8,0
8000417a:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
8000417c:	48 58       	lddpc	r8,80004190 <vPortExitCritical+0x1c>
8000417e:	70 09       	ld.w	r9,r8[0x0]
80004180:	20 19       	sub	r9,1
80004182:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80004184:	70 08       	ld.w	r8,r8[0x0]
80004186:	58 08       	cp.w	r8,0
80004188:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
8000418a:	d5 03       	csrf	0x10
8000418c:	5e fc       	retal	r12
8000418e:	00 00       	add	r0,r0
80004190:	00 00       	add	r0,r0
80004192:	05 38       	ld.ub	r8,r2++

80004194 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80004194:	eb cd 00 ff 	pushm	r0-r7
80004198:	e0 68 05 38 	mov	r8,1336
8000419c:	ea 18 00 00 	orh	r8,0x0
800041a0:	70 00       	ld.w	r0,r8[0x0]
800041a2:	1a d0       	st.w	--sp,r0
800041a4:	7a 90       	ld.w	r0,sp[0x24]
800041a6:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800041aa:	58 10       	cp.w	r0,1
800041ac:	e0 8b 00 08 	brhi	800041bc <LABEL_INT_SKIP_SAVE_CONTEXT_237>
800041b0:	e0 68 0c f8 	mov	r8,3320
800041b4:	ea 18 00 00 	orh	r8,0x0
800041b8:	70 00       	ld.w	r0,r8[0x0]
800041ba:	81 0d       	st.w	r0[0x0],sp

800041bc <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
800041bc:	f0 1f 00 12 	mcall	80004204 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
800041c0:	f0 1f 00 12 	mcall	80004208 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
800041c4:	f0 1f 00 12 	mcall	8000420c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
800041c8:	f0 1f 00 12 	mcall	80004210 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
800041cc:	7a 90       	ld.w	r0,sp[0x24]
800041ce:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800041d2:	58 10       	cp.w	r0,1
800041d4:	e0 8b 00 0e 	brhi	800041f0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
800041d8:	f0 1f 00 0c 	mcall	80004208 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
800041dc:	f0 1f 00 0e 	mcall	80004214 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
800041e0:	f0 1f 00 0c 	mcall	80004210 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
800041e4:	e0 68 0c f8 	mov	r8,3320
800041e8:	ea 18 00 00 	orh	r8,0x0
800041ec:	70 00       	ld.w	r0,r8[0x0]
800041ee:	60 0d       	ld.w	sp,r0[0x0]

800041f0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
800041f0:	1b 00       	ld.w	r0,sp++
800041f2:	e0 68 05 38 	mov	r8,1336
800041f6:	ea 18 00 00 	orh	r8,0x0
800041fa:	91 00       	st.w	r8[0x0],r0
800041fc:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004200:	d6 03       	rete
80004202:	00 00       	add	r0,r0
80004204:	80 00       	ld.sh	r0,r0[0x0]
80004206:	41 68       	lddsp	r8,sp[0x58]
80004208:	80 00       	ld.sh	r0,r0[0x0]
8000420a:	40 68       	lddsp	r8,sp[0x18]
8000420c:	80 00       	ld.sh	r0,r0[0x0]
8000420e:	49 b0       	lddpc	r0,80004278 <_write+0x8>
80004210:	80 00       	ld.sh	r0,r0[0x0]
80004212:	41 74       	lddsp	r4,sp[0x5c]
80004214:	80 00       	ld.sh	r0,r0[0x0]
80004216:	47 ac       	lddsp	r12,sp[0x1e8]

80004218 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80004218:	d4 01       	pushm	lr
	vTaskSuspendAll();
8000421a:	f0 1f 00 02 	mcall	80004220 <__malloc_lock+0x8>
}
8000421e:	d8 02       	popm	pc
80004220:	80 00       	ld.sh	r0,r0[0x0]
80004222:	47 9c       	lddsp	r12,sp[0x1e4]

80004224 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80004224:	d4 01       	pushm	lr
	xTaskResumeAll();
80004226:	f0 1f 00 02 	mcall	8000422c <__malloc_unlock+0x8>
}
8000422a:	d8 02       	popm	pc
8000422c:	80 00       	ld.sh	r0,r0[0x0]
8000422e:	4b 58       	lddpc	r8,80004300 <prvCopyDataFromQueue+0x4>

80004230 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80004230:	d4 21       	pushm	r4-r7,lr
80004232:	16 95       	mov	r5,r11
80004234:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80004236:	58 0c       	cp.w	r12,0
80004238:	c0 30       	breq	8000423e <_read+0xe>
8000423a:	3f f7       	mov	r7,-1
8000423c:	c1 48       	rjmp	80004264 <_read+0x34>
    return -1;

  for (; len > 0; --len)
8000423e:	58 0a       	cp.w	r10,0
80004240:	e0 89 00 04 	brgt	80004248 <_read+0x18>
80004244:	30 07       	mov	r7,0
80004246:	c0 f8       	rjmp	80004264 <_read+0x34>
80004248:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
8000424a:	48 84       	lddpc	r4,80004268 <_read+0x38>
8000424c:	68 0c       	ld.w	r12,r4[0x0]
8000424e:	f0 1f 00 08 	mcall	8000426c <_read+0x3c>
    if (c < 0)
80004252:	c0 95       	brlt	80004264 <_read+0x34>
      break;

    *ptr++ = c;
80004254:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80004258:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
8000425a:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
8000425e:	58 08       	cp.w	r8,0
80004260:	fe 99 ff f6 	brgt	8000424c <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80004264:	0e 9c       	mov	r12,r7
80004266:	d8 22       	popm	r4-r7,pc
80004268:	00 00       	add	r0,r0
8000426a:	51 40       	stdsp	sp[0x50],r0
8000426c:	80 00       	ld.sh	r0,r0[0x0]
8000426e:	3d bc       	mov	r12,-37

80004270 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80004270:	d4 21       	pushm	r4-r7,lr
80004272:	16 95       	mov	r5,r11
80004274:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80004276:	20 1c       	sub	r12,1
80004278:	58 2c       	cp.w	r12,2
8000427a:	e0 8b 00 12 	brhi	8000429e <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
8000427e:	58 0a       	cp.w	r10,0
80004280:	c0 31       	brne	80004286 <_write+0x16>
80004282:	30 07       	mov	r7,0
80004284:	c0 e8       	rjmp	800042a0 <_write+0x30>
80004286:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80004288:	48 74       	lddpc	r4,800042a4 <_write+0x34>
8000428a:	68 0c       	ld.w	r12,r4[0x0]
8000428c:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80004290:	f0 1f 00 06 	mcall	800042a8 <_write+0x38>
80004294:	c0 55       	brlt	8000429e <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80004296:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80004298:	0e 36       	cp.w	r6,r7
8000429a:	cf 81       	brne	8000428a <_write+0x1a>
8000429c:	c0 28       	rjmp	800042a0 <_write+0x30>
8000429e:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
800042a0:	0e 9c       	mov	r12,r7
800042a2:	d8 22       	popm	r4-r7,pc
800042a4:	00 00       	add	r0,r0
800042a6:	51 40       	stdsp	sp[0x50],r0
800042a8:	80 00       	ld.sh	r0,r0[0x0]
800042aa:	3d 6c       	mov	r12,-42

800042ac <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
800042ac:	eb cd 40 80 	pushm	r7,lr
800042b0:	18 97       	mov	r7,r12
	if( pv )
800042b2:	58 0c       	cp.w	r12,0
800042b4:	c0 80       	breq	800042c4 <vPortFree+0x18>
	{
		vTaskSuspendAll();
800042b6:	f0 1f 00 05 	mcall	800042c8 <vPortFree+0x1c>
		{
			free( pv );
800042ba:	0e 9c       	mov	r12,r7
800042bc:	f0 1f 00 04 	mcall	800042cc <vPortFree+0x20>
		}
		xTaskResumeAll();
800042c0:	f0 1f 00 04 	mcall	800042d0 <vPortFree+0x24>
800042c4:	e3 cd 80 80 	ldm	sp++,r7,pc
800042c8:	80 00       	ld.sh	r0,r0[0x0]
800042ca:	47 9c       	lddsp	r12,sp[0x1e4]
800042cc:	80 00       	ld.sh	r0,r0[0x0]
800042ce:	56 38       	stdsp	sp[0x18c],r8
800042d0:	80 00       	ld.sh	r0,r0[0x0]
800042d2:	4b 58       	lddpc	r8,800043a4 <prvUnlockQueue+0x28>

800042d4 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
800042d4:	eb cd 40 80 	pushm	r7,lr
800042d8:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
800042da:	f0 1f 00 06 	mcall	800042f0 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
800042de:	0e 9c       	mov	r12,r7
800042e0:	f0 1f 00 05 	mcall	800042f4 <pvPortMalloc+0x20>
800042e4:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
800042e6:	f0 1f 00 05 	mcall	800042f8 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
800042ea:	0e 9c       	mov	r12,r7
800042ec:	e3 cd 80 80 	ldm	sp++,r7,pc
800042f0:	80 00       	ld.sh	r0,r0[0x0]
800042f2:	47 9c       	lddsp	r12,sp[0x1e4]
800042f4:	80 00       	ld.sh	r0,r0[0x0]
800042f6:	56 48       	stdsp	sp[0x190],r8
800042f8:	80 00       	ld.sh	r0,r0[0x0]
800042fa:	4b 58       	lddpc	r8,800043cc <prvUnlockQueue+0x50>

800042fc <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
800042fc:	d4 01       	pushm	lr
800042fe:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80004300:	78 09       	ld.w	r9,r12[0x0]
80004302:	58 09       	cp.w	r9,0
80004304:	c1 10       	breq	80004326 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80004306:	78 3a       	ld.w	r10,r12[0xc]
80004308:	79 09       	ld.w	r9,r12[0x40]
8000430a:	f4 09 00 09 	add	r9,r10,r9
8000430e:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80004310:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80004312:	14 39       	cp.w	r9,r10
80004314:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80004318:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
8000431c:	79 0a       	ld.w	r10,r12[0x40]
8000431e:	78 3b       	ld.w	r11,r12[0xc]
80004320:	10 9c       	mov	r12,r8
80004322:	f0 1f 00 02 	mcall	80004328 <prvCopyDataFromQueue+0x2c>
80004326:	d8 02       	popm	pc
80004328:	80 00       	ld.sh	r0,r0[0x0]
8000432a:	5a 90       	cp.w	r0,-23

8000432c <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
8000432c:	eb cd 40 c0 	pushm	r6-r7,lr
80004330:	18 97       	mov	r7,r12
80004332:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80004334:	78 e8       	ld.w	r8,r12[0x38]
80004336:	58 08       	cp.w	r8,0
80004338:	c0 31       	brne	8000433e <xQueueReceiveFromISR+0x12>
8000433a:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
8000433e:	f0 1f 00 0e 	mcall	80004374 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80004342:	6e e8       	ld.w	r8,r7[0x38]
80004344:	20 18       	sub	r8,1
80004346:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80004348:	6f 18       	ld.w	r8,r7[0x44]
8000434a:	5b f8       	cp.w	r8,-1
8000434c:	c0 d1       	brne	80004366 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000434e:	6e 48       	ld.w	r8,r7[0x10]
80004350:	58 08       	cp.w	r8,0
80004352:	c0 f0       	breq	80004370 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80004354:	ee cc ff f0 	sub	r12,r7,-16
80004358:	f0 1f 00 08 	mcall	80004378 <xQueueReceiveFromISR+0x4c>
8000435c:	c0 a0       	breq	80004370 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
8000435e:	30 1c       	mov	r12,1
80004360:	8d 0c       	st.w	r6[0x0],r12
80004362:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80004366:	2f f8       	sub	r8,-1
80004368:	ef 48 00 44 	st.w	r7[68],r8
8000436c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80004370:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80004374:	80 00       	ld.sh	r0,r0[0x0]
80004376:	42 fc       	lddsp	r12,sp[0xbc]
80004378:	80 00       	ld.sh	r0,r0[0x0]
8000437a:	49 34       	lddpc	r4,800043c4 <prvUnlockQueue+0x48>

8000437c <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
8000437c:	eb cd 40 c0 	pushm	r6-r7,lr
80004380:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80004382:	f0 1f 00 23 	mcall	8000440c <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80004386:	6f 28       	ld.w	r8,r7[0x48]
80004388:	58 08       	cp.w	r8,0
8000438a:	e0 8a 00 18 	brle	800043ba <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000438e:	6e 98       	ld.w	r8,r7[0x24]
80004390:	58 08       	cp.w	r8,0
80004392:	c1 40       	breq	800043ba <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004394:	ee c6 ff dc 	sub	r6,r7,-36
80004398:	c0 48       	rjmp	800043a0 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000439a:	6e 98       	ld.w	r8,r7[0x24]
8000439c:	58 08       	cp.w	r8,0
8000439e:	c0 e0       	breq	800043ba <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800043a0:	0c 9c       	mov	r12,r6
800043a2:	f0 1f 00 1c 	mcall	80004410 <prvUnlockQueue+0x94>
800043a6:	c0 30       	breq	800043ac <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
800043a8:	f0 1f 00 1b 	mcall	80004414 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
800043ac:	6f 28       	ld.w	r8,r7[0x48]
800043ae:	20 18       	sub	r8,1
800043b0:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800043b4:	58 08       	cp.w	r8,0
800043b6:	fe 99 ff f2 	brgt	8000439a <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800043ba:	3f f8       	mov	r8,-1
800043bc:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
800043c0:	f0 1f 00 16 	mcall	80004418 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800043c4:	f0 1f 00 12 	mcall	8000440c <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800043c8:	6f 18       	ld.w	r8,r7[0x44]
800043ca:	58 08       	cp.w	r8,0
800043cc:	e0 8a 00 18 	brle	800043fc <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800043d0:	6e 48       	ld.w	r8,r7[0x10]
800043d2:	58 08       	cp.w	r8,0
800043d4:	c1 40       	breq	800043fc <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800043d6:	ee c6 ff f0 	sub	r6,r7,-16
800043da:	c0 48       	rjmp	800043e2 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800043dc:	6e 48       	ld.w	r8,r7[0x10]
800043de:	58 08       	cp.w	r8,0
800043e0:	c0 e0       	breq	800043fc <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800043e2:	0c 9c       	mov	r12,r6
800043e4:	f0 1f 00 0b 	mcall	80004410 <prvUnlockQueue+0x94>
800043e8:	c0 30       	breq	800043ee <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
800043ea:	f0 1f 00 0b 	mcall	80004414 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
800043ee:	6f 18       	ld.w	r8,r7[0x44]
800043f0:	20 18       	sub	r8,1
800043f2:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800043f6:	58 08       	cp.w	r8,0
800043f8:	fe 99 ff f2 	brgt	800043dc <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
800043fc:	3f f8       	mov	r8,-1
800043fe:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80004402:	f0 1f 00 06 	mcall	80004418 <prvUnlockQueue+0x9c>
}
80004406:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000440a:	00 00       	add	r0,r0
8000440c:	80 00       	ld.sh	r0,r0[0x0]
8000440e:	40 68       	lddsp	r8,sp[0x18]
80004410:	80 00       	ld.sh	r0,r0[0x0]
80004412:	49 34       	lddpc	r4,8000445c <xQueueGenericReceive+0x40>
80004414:	80 00       	ld.sh	r0,r0[0x0]
80004416:	48 40       	lddpc	r0,80004424 <xQueueGenericReceive+0x8>
80004418:	80 00       	ld.sh	r0,r0[0x0]
8000441a:	41 74       	lddsp	r4,sp[0x5c]

8000441c <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
8000441c:	d4 31       	pushm	r0-r7,lr
8000441e:	20 5d       	sub	sp,20
80004420:	18 97       	mov	r7,r12
80004422:	50 0b       	stdsp	sp[0x0],r11
80004424:	50 2a       	stdsp	sp[0x8],r10
80004426:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80004428:	f8 c2 ff dc 	sub	r2,r12,-36
8000442c:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000442e:	fa c4 ff f4 	sub	r4,sp,-12
80004432:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80004434:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80004436:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
8000443a:	f0 1f 00 3e 	mcall	80004530 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
8000443e:	6e e8       	ld.w	r8,r7[0x38]
80004440:	58 08       	cp.w	r8,0
80004442:	c2 a0       	breq	80004496 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80004444:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80004446:	40 0b       	lddsp	r11,sp[0x0]
80004448:	0e 9c       	mov	r12,r7
8000444a:	f0 1f 00 3b 	mcall	80004534 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
8000444e:	40 18       	lddsp	r8,sp[0x4]
80004450:	58 08       	cp.w	r8,0
80004452:	c1 51       	brne	8000447c <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80004454:	6e e8       	ld.w	r8,r7[0x38]
80004456:	20 18       	sub	r8,1
80004458:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000445a:	6e 08       	ld.w	r8,r7[0x0]
8000445c:	58 08       	cp.w	r8,0
8000445e:	c0 41       	brne	80004466 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80004460:	f0 1f 00 36 	mcall	80004538 <xQueueGenericReceive+0x11c>
80004464:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004466:	6e 48       	ld.w	r8,r7[0x10]
80004468:	58 08       	cp.w	r8,0
8000446a:	c1 20       	breq	8000448e <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
8000446c:	ee cc ff f0 	sub	r12,r7,-16
80004470:	f0 1f 00 33 	mcall	8000453c <xQueueGenericReceive+0x120>
80004474:	58 1c       	cp.w	r12,1
80004476:	c0 c1       	brne	8000448e <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80004478:	d7 33       	scall
8000447a:	c0 a8       	rjmp	8000448e <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
8000447c:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000447e:	6e 98       	ld.w	r8,r7[0x24]
80004480:	58 08       	cp.w	r8,0
80004482:	c0 60       	breq	8000448e <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004484:	04 9c       	mov	r12,r2
80004486:	f0 1f 00 2e 	mcall	8000453c <xQueueGenericReceive+0x120>
8000448a:	c0 20       	breq	8000448e <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
8000448c:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
8000448e:	f0 1f 00 2d 	mcall	80004540 <xQueueGenericReceive+0x124>
80004492:	30 1c       	mov	r12,1
				return pdPASS;
80004494:	c4 c8       	rjmp	8000452c <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80004496:	40 28       	lddsp	r8,sp[0x8]
80004498:	58 08       	cp.w	r8,0
8000449a:	c0 51       	brne	800044a4 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8000449c:	f0 1f 00 29 	mcall	80004540 <xQueueGenericReceive+0x124>
800044a0:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
800044a2:	c4 58       	rjmp	8000452c <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
800044a4:	58 05       	cp.w	r5,0
800044a6:	c0 51       	brne	800044b0 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800044a8:	08 9c       	mov	r12,r4
800044aa:	f0 1f 00 27 	mcall	80004544 <xQueueGenericReceive+0x128>
800044ae:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800044b0:	f0 1f 00 24 	mcall	80004540 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800044b4:	f0 1f 00 25 	mcall	80004548 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
800044b8:	f0 1f 00 1e 	mcall	80004530 <xQueueGenericReceive+0x114>
800044bc:	6f 18       	ld.w	r8,r7[0x44]
800044be:	5b f8       	cp.w	r8,-1
800044c0:	ef f1 0a 11 	st.weq	r7[0x44],r1
800044c4:	6f 28       	ld.w	r8,r7[0x48]
800044c6:	5b f8       	cp.w	r8,-1
800044c8:	ef f1 0a 12 	st.weq	r7[0x48],r1
800044cc:	f0 1f 00 1d 	mcall	80004540 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800044d0:	06 9b       	mov	r11,r3
800044d2:	08 9c       	mov	r12,r4
800044d4:	f0 1f 00 1e 	mcall	8000454c <xQueueGenericReceive+0x130>
800044d8:	c2 41       	brne	80004520 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800044da:	f0 1f 00 16 	mcall	80004530 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
800044de:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
800044e0:	f0 1f 00 18 	mcall	80004540 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
800044e4:	58 06       	cp.w	r6,0
800044e6:	c1 71       	brne	80004514 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800044e8:	6e 08       	ld.w	r8,r7[0x0]
800044ea:	58 08       	cp.w	r8,0
800044ec:	c0 81       	brne	800044fc <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
800044ee:	f0 1f 00 11 	mcall	80004530 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
800044f2:	6e 1c       	ld.w	r12,r7[0x4]
800044f4:	f0 1f 00 17 	mcall	80004550 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
800044f8:	f0 1f 00 12 	mcall	80004540 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800044fc:	40 2b       	lddsp	r11,sp[0x8]
800044fe:	04 9c       	mov	r12,r2
80004500:	f0 1f 00 15 	mcall	80004554 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80004504:	0e 9c       	mov	r12,r7
80004506:	f0 1f 00 15 	mcall	80004558 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
8000450a:	f0 1f 00 15 	mcall	8000455c <xQueueGenericReceive+0x140>
8000450e:	c9 61       	brne	8000443a <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80004510:	d7 33       	scall
80004512:	c9 4b       	rjmp	8000443a <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80004514:	0e 9c       	mov	r12,r7
80004516:	f0 1f 00 11 	mcall	80004558 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
8000451a:	f0 1f 00 11 	mcall	8000455c <xQueueGenericReceive+0x140>
8000451e:	c8 eb       	rjmp	8000443a <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80004520:	0e 9c       	mov	r12,r7
80004522:	f0 1f 00 0e 	mcall	80004558 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80004526:	f0 1f 00 0e 	mcall	8000455c <xQueueGenericReceive+0x140>
8000452a:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
8000452c:	2f bd       	sub	sp,-20
8000452e:	d8 32       	popm	r0-r7,pc
80004530:	80 00       	ld.sh	r0,r0[0x0]
80004532:	40 68       	lddsp	r8,sp[0x18]
80004534:	80 00       	ld.sh	r0,r0[0x0]
80004536:	42 fc       	lddsp	r12,sp[0xbc]
80004538:	80 00       	ld.sh	r0,r0[0x0]
8000453a:	48 4c       	lddpc	r12,80004548 <xQueueGenericReceive+0x12c>
8000453c:	80 00       	ld.sh	r0,r0[0x0]
8000453e:	49 34       	lddpc	r4,80004588 <prvCopyDataToQueue+0x28>
80004540:	80 00       	ld.sh	r0,r0[0x0]
80004542:	41 74       	lddsp	r4,sp[0x5c]
80004544:	80 00       	ld.sh	r0,r0[0x0]
80004546:	48 28       	lddpc	r8,8000454c <xQueueGenericReceive+0x130>
80004548:	80 00       	ld.sh	r0,r0[0x0]
8000454a:	47 9c       	lddsp	r12,sp[0x1e4]
8000454c:	80 00       	ld.sh	r0,r0[0x0]
8000454e:	4a c4       	lddpc	r4,800045fc <xQueueGenericSendFromISR+0x24>
80004550:	80 00       	ld.sh	r0,r0[0x0]
80004552:	48 b0       	lddpc	r0,8000457c <prvCopyDataToQueue+0x1c>
80004554:	80 00       	ld.sh	r0,r0[0x0]
80004556:	4d 64       	lddpc	r4,800046ac <xQueueGenericSend+0x84>
80004558:	80 00       	ld.sh	r0,r0[0x0]
8000455a:	43 7c       	lddsp	r12,sp[0xdc]
8000455c:	80 00       	ld.sh	r0,r0[0x0]
8000455e:	4b 58       	lddpc	r8,80004630 <xQueueGenericSend+0x8>

80004560 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80004560:	eb cd 40 80 	pushm	r7,lr
80004564:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80004566:	79 08       	ld.w	r8,r12[0x40]
80004568:	58 08       	cp.w	r8,0
8000456a:	c0 a1       	brne	8000457e <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000456c:	78 08       	ld.w	r8,r12[0x0]
8000456e:	58 08       	cp.w	r8,0
80004570:	c2 b1       	brne	800045c6 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80004572:	78 1c       	ld.w	r12,r12[0x4]
80004574:	f0 1f 00 17 	mcall	800045d0 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80004578:	30 08       	mov	r8,0
8000457a:	8f 18       	st.w	r7[0x4],r8
8000457c:	c2 58       	rjmp	800045c6 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
8000457e:	58 0a       	cp.w	r10,0
80004580:	c1 01       	brne	800045a0 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80004582:	10 9a       	mov	r10,r8
80004584:	78 2c       	ld.w	r12,r12[0x8]
80004586:	f0 1f 00 14 	mcall	800045d4 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
8000458a:	6e 29       	ld.w	r9,r7[0x8]
8000458c:	6f 08       	ld.w	r8,r7[0x40]
8000458e:	f2 08 00 08 	add	r8,r9,r8
80004592:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80004594:	6e 19       	ld.w	r9,r7[0x4]
80004596:	12 38       	cp.w	r8,r9
80004598:	c1 73       	brcs	800045c6 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
8000459a:	6e 08       	ld.w	r8,r7[0x0]
8000459c:	8f 28       	st.w	r7[0x8],r8
8000459e:	c1 48       	rjmp	800045c6 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800045a0:	10 9a       	mov	r10,r8
800045a2:	78 3c       	ld.w	r12,r12[0xc]
800045a4:	f0 1f 00 0c 	mcall	800045d4 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
800045a8:	6f 08       	ld.w	r8,r7[0x40]
800045aa:	6e 39       	ld.w	r9,r7[0xc]
800045ac:	f2 08 01 08 	sub	r8,r9,r8
800045b0:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800045b2:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800045b4:	12 38       	cp.w	r8,r9
800045b6:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
800045ba:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
800045be:	f3 d8 e3 19 	subcs	r9,r9,r8
800045c2:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800045c6:	6e e8       	ld.w	r8,r7[0x38]
800045c8:	2f f8       	sub	r8,-1
800045ca:	8f e8       	st.w	r7[0x38],r8
}
800045cc:	e3 cd 80 80 	ldm	sp++,r7,pc
800045d0:	80 00       	ld.sh	r0,r0[0x0]
800045d2:	48 58       	lddpc	r8,800045e4 <xQueueGenericSendFromISR+0xc>
800045d4:	80 00       	ld.sh	r0,r0[0x0]
800045d6:	5a 90       	cp.w	r0,-23

800045d8 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
800045d8:	eb cd 40 c0 	pushm	r6-r7,lr
800045dc:	18 97       	mov	r7,r12
800045de:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800045e0:	78 ec       	ld.w	r12,r12[0x38]
800045e2:	6e f8       	ld.w	r8,r7[0x3c]
800045e4:	10 3c       	cp.w	r12,r8
800045e6:	c0 33       	brcs	800045ec <xQueueGenericSendFromISR+0x14>
800045e8:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800045ec:	12 9a       	mov	r10,r9
800045ee:	0e 9c       	mov	r12,r7
800045f0:	f0 1f 00 0c 	mcall	80004620 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
800045f4:	6f 28       	ld.w	r8,r7[0x48]
800045f6:	5b f8       	cp.w	r8,-1
800045f8:	c0 d1       	brne	80004612 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800045fa:	6e 98       	ld.w	r8,r7[0x24]
800045fc:	58 08       	cp.w	r8,0
800045fe:	c0 f0       	breq	8000461c <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004600:	ee cc ff dc 	sub	r12,r7,-36
80004604:	f0 1f 00 08 	mcall	80004624 <xQueueGenericSendFromISR+0x4c>
80004608:	c0 a0       	breq	8000461c <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
8000460a:	30 1c       	mov	r12,1
8000460c:	8d 0c       	st.w	r6[0x0],r12
8000460e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80004612:	2f f8       	sub	r8,-1
80004614:	ef 48 00 48 	st.w	r7[72],r8
80004618:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000461c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80004620:	80 00       	ld.sh	r0,r0[0x0]
80004622:	45 60       	lddsp	r0,sp[0x158]
80004624:	80 00       	ld.sh	r0,r0[0x0]
80004626:	49 34       	lddpc	r4,80004670 <xQueueGenericSend+0x48>

80004628 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80004628:	d4 31       	pushm	r0-r7,lr
8000462a:	20 5d       	sub	sp,20
8000462c:	18 97       	mov	r7,r12
8000462e:	50 0b       	stdsp	sp[0x0],r11
80004630:	50 2a       	stdsp	sp[0x8],r10
80004632:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80004634:	f8 c0 ff f0 	sub	r0,r12,-16
80004638:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000463a:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
8000463e:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80004640:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80004644:	f0 1f 00 2f 	mcall	80004700 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80004648:	6e e9       	ld.w	r9,r7[0x38]
8000464a:	6e f8       	ld.w	r8,r7[0x3c]
8000464c:	10 39       	cp.w	r9,r8
8000464e:	c1 42       	brcc	80004676 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80004650:	40 1a       	lddsp	r10,sp[0x4]
80004652:	40 0b       	lddsp	r11,sp[0x0]
80004654:	0e 9c       	mov	r12,r7
80004656:	f0 1f 00 2c 	mcall	80004704 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000465a:	6e 98       	ld.w	r8,r7[0x24]
8000465c:	58 08       	cp.w	r8,0
8000465e:	c0 80       	breq	8000466e <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80004660:	ee cc ff dc 	sub	r12,r7,-36
80004664:	f0 1f 00 29 	mcall	80004708 <xQueueGenericSend+0xe0>
80004668:	58 1c       	cp.w	r12,1
8000466a:	c0 21       	brne	8000466e <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
8000466c:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
8000466e:	f0 1f 00 28 	mcall	8000470c <xQueueGenericSend+0xe4>
80004672:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80004674:	c4 38       	rjmp	800046fa <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80004676:	40 28       	lddsp	r8,sp[0x8]
80004678:	58 08       	cp.w	r8,0
8000467a:	c0 51       	brne	80004684 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8000467c:	f0 1f 00 24 	mcall	8000470c <xQueueGenericSend+0xe4>
80004680:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80004682:	c3 c8       	rjmp	800046fa <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80004684:	58 04       	cp.w	r4,0
80004686:	c0 51       	brne	80004690 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80004688:	06 9c       	mov	r12,r3
8000468a:	f0 1f 00 22 	mcall	80004710 <xQueueGenericSend+0xe8>
8000468e:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80004690:	f0 1f 00 1f 	mcall	8000470c <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80004694:	f0 1f 00 20 	mcall	80004714 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80004698:	f0 1f 00 1a 	mcall	80004700 <xQueueGenericSend+0xd8>
8000469c:	6f 18       	ld.w	r8,r7[0x44]
8000469e:	5b f8       	cp.w	r8,-1
800046a0:	ef f1 0a 11 	st.weq	r7[0x44],r1
800046a4:	6f 28       	ld.w	r8,r7[0x48]
800046a6:	5b f8       	cp.w	r8,-1
800046a8:	ef f1 0a 12 	st.weq	r7[0x48],r1
800046ac:	f0 1f 00 18 	mcall	8000470c <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800046b0:	04 9b       	mov	r11,r2
800046b2:	06 9c       	mov	r12,r3
800046b4:	f0 1f 00 19 	mcall	80004718 <xQueueGenericSend+0xf0>
800046b8:	c1 b1       	brne	800046ee <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800046ba:	f0 1f 00 12 	mcall	80004700 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800046be:	6e e5       	ld.w	r5,r7[0x38]
800046c0:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800046c2:	f0 1f 00 13 	mcall	8000470c <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800046c6:	0c 35       	cp.w	r5,r6
800046c8:	c0 d1       	brne	800046e2 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800046ca:	40 2b       	lddsp	r11,sp[0x8]
800046cc:	00 9c       	mov	r12,r0
800046ce:	f0 1f 00 14 	mcall	8000471c <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800046d2:	0e 9c       	mov	r12,r7
800046d4:	f0 1f 00 13 	mcall	80004720 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800046d8:	f0 1f 00 13 	mcall	80004724 <xQueueGenericSend+0xfc>
800046dc:	cb 41       	brne	80004644 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
800046de:	d7 33       	scall
800046e0:	cb 2b       	rjmp	80004644 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800046e2:	0e 9c       	mov	r12,r7
800046e4:	f0 1f 00 0f 	mcall	80004720 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800046e8:	f0 1f 00 0f 	mcall	80004724 <xQueueGenericSend+0xfc>
800046ec:	ca cb       	rjmp	80004644 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800046ee:	0e 9c       	mov	r12,r7
800046f0:	f0 1f 00 0c 	mcall	80004720 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800046f4:	f0 1f 00 0c 	mcall	80004724 <xQueueGenericSend+0xfc>
800046f8:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
800046fa:	2f bd       	sub	sp,-20
800046fc:	d8 32       	popm	r0-r7,pc
800046fe:	00 00       	add	r0,r0
80004700:	80 00       	ld.sh	r0,r0[0x0]
80004702:	40 68       	lddsp	r8,sp[0x18]
80004704:	80 00       	ld.sh	r0,r0[0x0]
80004706:	45 60       	lddsp	r0,sp[0x158]
80004708:	80 00       	ld.sh	r0,r0[0x0]
8000470a:	49 34       	lddpc	r4,80004754 <xQueueCreate+0x2c>
8000470c:	80 00       	ld.sh	r0,r0[0x0]
8000470e:	41 74       	lddsp	r4,sp[0x5c]
80004710:	80 00       	ld.sh	r0,r0[0x0]
80004712:	48 28       	lddpc	r8,80004718 <xQueueGenericSend+0xf0>
80004714:	80 00       	ld.sh	r0,r0[0x0]
80004716:	47 9c       	lddsp	r12,sp[0x1e4]
80004718:	80 00       	ld.sh	r0,r0[0x0]
8000471a:	4a c4       	lddpc	r4,800047c8 <vTaskSwitchContext+0x1c>
8000471c:	80 00       	ld.sh	r0,r0[0x0]
8000471e:	4d 64       	lddpc	r4,80004874 <vTaskPriorityDisinherit+0x1c>
80004720:	80 00       	ld.sh	r0,r0[0x0]
80004722:	43 7c       	lddsp	r12,sp[0xdc]
80004724:	80 00       	ld.sh	r0,r0[0x0]
80004726:	4b 58       	lddpc	r8,800047f8 <vTaskSwitchContext+0x4c>

80004728 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80004728:	d4 21       	pushm	r4-r7,lr
8000472a:	18 97       	mov	r7,r12
8000472c:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
8000472e:	58 0c       	cp.w	r12,0
80004730:	c2 f0       	breq	8000478e <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80004732:	34 cc       	mov	r12,76
80004734:	f0 1f 00 17 	mcall	80004790 <xQueueCreate+0x68>
80004738:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000473a:	c2 a0       	breq	8000478e <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
8000473c:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80004740:	e8 cc ff ff 	sub	r12,r4,-1
80004744:	f0 1f 00 13 	mcall	80004790 <xQueueCreate+0x68>
80004748:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000474a:	c1 e0       	breq	80004786 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
8000474c:	f8 04 00 04 	add	r4,r12,r4
80004750:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80004752:	30 08       	mov	r8,0
80004754:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80004756:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80004758:	ee c8 00 01 	sub	r8,r7,1
8000475c:	ad 38       	mul	r8,r6
8000475e:	10 0c       	add	r12,r8
80004760:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80004762:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80004764:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80004768:	3f f8       	mov	r8,-1
8000476a:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
8000476e:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80004772:	ea cc ff f0 	sub	r12,r5,-16
80004776:	f0 1f 00 08 	mcall	80004794 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000477a:	ea cc ff dc 	sub	r12,r5,-36
8000477e:	f0 1f 00 06 	mcall	80004794 <xQueueCreate+0x6c>
80004782:	0a 9c       	mov	r12,r5
80004784:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80004786:	0a 9c       	mov	r12,r5
80004788:	f0 1f 00 04 	mcall	80004798 <xQueueCreate+0x70>
8000478c:	d8 2a       	popm	r4-r7,pc,r12=0
8000478e:	d8 2a       	popm	r4-r7,pc,r12=0
80004790:	80 00       	ld.sh	r0,r0[0x0]
80004792:	42 d4       	lddsp	r4,sp[0xb4]
80004794:	80 00       	ld.sh	r0,r0[0x0]
80004796:	3f 44       	mov	r4,-12
80004798:	80 00       	ld.sh	r0,r0[0x0]
8000479a:	42 ac       	lddsp	r12,sp[0xa8]

8000479c <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
8000479c:	48 38       	lddpc	r8,800047a8 <vTaskSuspendAll+0xc>
8000479e:	70 09       	ld.w	r9,r8[0x0]
800047a0:	2f f9       	sub	r9,-1
800047a2:	91 09       	st.w	r8[0x0],r9
}
800047a4:	5e fc       	retal	r12
800047a6:	00 00       	add	r0,r0
800047a8:	00 00       	add	r0,r0
800047aa:	0d 28       	ld.uh	r8,r6++

800047ac <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800047ac:	49 a8       	lddpc	r8,80004814 <vTaskSwitchContext+0x68>
800047ae:	70 08       	ld.w	r8,r8[0x0]
800047b0:	58 08       	cp.w	r8,0
800047b2:	c0 b1       	brne	800047c8 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800047b4:	49 98       	lddpc	r8,80004818 <vTaskSwitchContext+0x6c>
800047b6:	70 08       	ld.w	r8,r8[0x0]
800047b8:	f0 08 00 28 	add	r8,r8,r8<<0x2
800047bc:	49 89       	lddpc	r9,8000481c <vTaskSwitchContext+0x70>
800047be:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800047c2:	58 08       	cp.w	r8,0
800047c4:	c0 60       	breq	800047d0 <vTaskSwitchContext+0x24>
800047c6:	c1 18       	rjmp	800047e8 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800047c8:	30 19       	mov	r9,1
800047ca:	49 68       	lddpc	r8,80004820 <vTaskSwitchContext+0x74>
800047cc:	91 09       	st.w	r8[0x0],r9
800047ce:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800047d0:	49 28       	lddpc	r8,80004818 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800047d2:	49 3a       	lddpc	r10,8000481c <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800047d4:	70 09       	ld.w	r9,r8[0x0]
800047d6:	20 19       	sub	r9,1
800047d8:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800047da:	70 09       	ld.w	r9,r8[0x0]
800047dc:	f2 09 00 29 	add	r9,r9,r9<<0x2
800047e0:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800047e4:	58 09       	cp.w	r9,0
800047e6:	cf 70       	breq	800047d4 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800047e8:	48 c8       	lddpc	r8,80004818 <vTaskSwitchContext+0x6c>
800047ea:	70 08       	ld.w	r8,r8[0x0]
800047ec:	f0 08 00 28 	add	r8,r8,r8<<0x2
800047f0:	48 b9       	lddpc	r9,8000481c <vTaskSwitchContext+0x70>
800047f2:	f2 08 00 28 	add	r8,r9,r8<<0x2
800047f6:	70 19       	ld.w	r9,r8[0x4]
800047f8:	72 19       	ld.w	r9,r9[0x4]
800047fa:	91 19       	st.w	r8[0x4],r9
800047fc:	f0 ca ff f8 	sub	r10,r8,-8
80004800:	14 39       	cp.w	r9,r10
80004802:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80004806:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000480a:	70 18       	ld.w	r8,r8[0x4]
8000480c:	70 39       	ld.w	r9,r8[0xc]
8000480e:	48 68       	lddpc	r8,80004824 <vTaskSwitchContext+0x78>
80004810:	91 09       	st.w	r8[0x0],r9
80004812:	5e fc       	retal	r12
80004814:	00 00       	add	r0,r0
80004816:	0d 28       	ld.uh	r8,r6++
80004818:	00 00       	add	r0,r0
8000481a:	0d 60       	ld.uh	r0,--r6
8000481c:	00 00       	add	r0,r0
8000481e:	0c 44       	or	r4,r6
80004820:	00 00       	add	r0,r0
80004822:	0d 48       	ld.w	r8,--r6
80004824:	00 00       	add	r0,r0
80004826:	0c f8       	st.b	--r6,r8

80004828 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80004828:	48 48       	lddpc	r8,80004838 <vTaskSetTimeOutState+0x10>
8000482a:	70 08       	ld.w	r8,r8[0x0]
8000482c:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
8000482e:	48 48       	lddpc	r8,8000483c <vTaskSetTimeOutState+0x14>
80004830:	70 08       	ld.w	r8,r8[0x0]
80004832:	99 18       	st.w	r12[0x4],r8
}
80004834:	5e fc       	retal	r12
80004836:	00 00       	add	r0,r0
80004838:	00 00       	add	r0,r0
8000483a:	0c 3c       	cp.w	r12,r6
8000483c:	00 00       	add	r0,r0
8000483e:	0d 24       	ld.uh	r4,r6++

80004840 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80004840:	30 19       	mov	r9,1
80004842:	48 28       	lddpc	r8,80004848 <vTaskMissedYield+0x8>
80004844:	91 09       	st.w	r8[0x0],r9
}
80004846:	5e fc       	retal	r12
80004848:	00 00       	add	r0,r0
8000484a:	0d 48       	ld.w	r8,--r6

8000484c <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
8000484c:	48 28       	lddpc	r8,80004854 <xTaskGetCurrentTaskHandle+0x8>
8000484e:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80004850:	5e fc       	retal	r12
80004852:	00 00       	add	r0,r0
80004854:	00 00       	add	r0,r0
80004856:	0c f8       	st.b	--r6,r8

80004858 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80004858:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
8000485c:	58 0c       	cp.w	r12,0
8000485e:	c1 f0       	breq	8000489c <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80004860:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80004862:	78 b9       	ld.w	r9,r12[0x2c]
80004864:	79 18       	ld.w	r8,r12[0x44]
80004866:	10 39       	cp.w	r9,r8
80004868:	c1 a0       	breq	8000489c <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000486a:	f8 c6 ff fc 	sub	r6,r12,-4
8000486e:	0c 9c       	mov	r12,r6
80004870:	f0 1f 00 0c 	mcall	800048a0 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80004874:	6f 1c       	ld.w	r12,r7[0x44]
80004876:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80004878:	f8 08 11 08 	rsub	r8,r12,8
8000487c:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
8000487e:	48 a8       	lddpc	r8,800048a4 <vTaskPriorityDisinherit+0x4c>
80004880:	70 08       	ld.w	r8,r8[0x0]
80004882:	10 3c       	cp.w	r12,r8
80004884:	e0 88 00 04 	brls	8000488c <vTaskPriorityDisinherit+0x34>
80004888:	48 78       	lddpc	r8,800048a4 <vTaskPriorityDisinherit+0x4c>
8000488a:	91 0c       	st.w	r8[0x0],r12
8000488c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80004890:	0c 9b       	mov	r11,r6
80004892:	48 68       	lddpc	r8,800048a8 <vTaskPriorityDisinherit+0x50>
80004894:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004898:	f0 1f 00 05 	mcall	800048ac <vTaskPriorityDisinherit+0x54>
8000489c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800048a0:	80 00       	ld.sh	r0,r0[0x0]
800048a2:	3f ae       	mov	lr,-6
800048a4:	00 00       	add	r0,r0
800048a6:	0d 60       	ld.uh	r0,--r6
800048a8:	00 00       	add	r0,r0
800048aa:	0c 44       	or	r4,r6
800048ac:	80 00       	ld.sh	r0,r0[0x0]
800048ae:	3f 5e       	mov	lr,-11

800048b0 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800048b0:	eb cd 40 c0 	pushm	r6-r7,lr
800048b4:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
800048b6:	49 b8       	lddpc	r8,80004920 <vTaskPriorityInherit+0x70>
800048b8:	70 08       	ld.w	r8,r8[0x0]
800048ba:	78 b9       	ld.w	r9,r12[0x2c]
800048bc:	70 b8       	ld.w	r8,r8[0x2c]
800048be:	10 39       	cp.w	r9,r8
800048c0:	c2 d2       	brcc	8000491a <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800048c2:	49 88       	lddpc	r8,80004920 <vTaskPriorityInherit+0x70>
800048c4:	70 08       	ld.w	r8,r8[0x0]
800048c6:	70 b8       	ld.w	r8,r8[0x2c]
800048c8:	f0 08 11 08 	rsub	r8,r8,8
800048cc:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800048ce:	f2 09 00 28 	add	r8,r9,r9<<0x2
800048d2:	49 59       	lddpc	r9,80004924 <vTaskPriorityInherit+0x74>
800048d4:	f2 08 00 28 	add	r8,r9,r8<<0x2
800048d8:	78 59       	ld.w	r9,r12[0x14]
800048da:	10 39       	cp.w	r9,r8
800048dc:	c1 b1       	brne	80004912 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800048de:	f8 c6 ff fc 	sub	r6,r12,-4
800048e2:	0c 9c       	mov	r12,r6
800048e4:	f0 1f 00 11 	mcall	80004928 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800048e8:	48 e8       	lddpc	r8,80004920 <vTaskPriorityInherit+0x70>
800048ea:	70 08       	ld.w	r8,r8[0x0]
800048ec:	70 bc       	ld.w	r12,r8[0x2c]
800048ee:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800048f0:	48 f8       	lddpc	r8,8000492c <vTaskPriorityInherit+0x7c>
800048f2:	70 08       	ld.w	r8,r8[0x0]
800048f4:	10 3c       	cp.w	r12,r8
800048f6:	e0 88 00 04 	brls	800048fe <vTaskPriorityInherit+0x4e>
800048fa:	48 d8       	lddpc	r8,8000492c <vTaskPriorityInherit+0x7c>
800048fc:	91 0c       	st.w	r8[0x0],r12
800048fe:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80004902:	0c 9b       	mov	r11,r6
80004904:	48 88       	lddpc	r8,80004924 <vTaskPriorityInherit+0x74>
80004906:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000490a:	f0 1f 00 0a 	mcall	80004930 <vTaskPriorityInherit+0x80>
8000490e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80004912:	48 48       	lddpc	r8,80004920 <vTaskPriorityInherit+0x70>
80004914:	70 08       	ld.w	r8,r8[0x0]
80004916:	70 b8       	ld.w	r8,r8[0x2c]
80004918:	99 b8       	st.w	r12[0x2c],r8
8000491a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000491e:	00 00       	add	r0,r0
80004920:	00 00       	add	r0,r0
80004922:	0c f8       	st.b	--r6,r8
80004924:	00 00       	add	r0,r0
80004926:	0c 44       	or	r4,r6
80004928:	80 00       	ld.sh	r0,r0[0x0]
8000492a:	3f ae       	mov	lr,-6
8000492c:	00 00       	add	r0,r0
8000492e:	0d 60       	ld.uh	r0,--r6
80004930:	80 00       	ld.sh	r0,r0[0x0]
80004932:	3f 5e       	mov	lr,-11

80004934 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80004934:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80004938:	78 38       	ld.w	r8,r12[0xc]
8000493a:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
8000493c:	ee c6 ff e8 	sub	r6,r7,-24
80004940:	0c 9c       	mov	r12,r6
80004942:	f0 1f 00 15 	mcall	80004994 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80004946:	49 58       	lddpc	r8,80004998 <xTaskRemoveFromEventList+0x64>
80004948:	70 08       	ld.w	r8,r8[0x0]
8000494a:	58 08       	cp.w	r8,0
8000494c:	c1 71       	brne	8000497a <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
8000494e:	ee c6 ff fc 	sub	r6,r7,-4
80004952:	0c 9c       	mov	r12,r6
80004954:	f0 1f 00 10 	mcall	80004994 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80004958:	6e bc       	ld.w	r12,r7[0x2c]
8000495a:	49 18       	lddpc	r8,8000499c <xTaskRemoveFromEventList+0x68>
8000495c:	70 08       	ld.w	r8,r8[0x0]
8000495e:	10 3c       	cp.w	r12,r8
80004960:	e0 88 00 04 	brls	80004968 <xTaskRemoveFromEventList+0x34>
80004964:	48 e8       	lddpc	r8,8000499c <xTaskRemoveFromEventList+0x68>
80004966:	91 0c       	st.w	r8[0x0],r12
80004968:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000496c:	0c 9b       	mov	r11,r6
8000496e:	48 d8       	lddpc	r8,800049a0 <xTaskRemoveFromEventList+0x6c>
80004970:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004974:	f0 1f 00 0c 	mcall	800049a4 <xTaskRemoveFromEventList+0x70>
80004978:	c0 58       	rjmp	80004982 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000497a:	0c 9b       	mov	r11,r6
8000497c:	48 bc       	lddpc	r12,800049a8 <xTaskRemoveFromEventList+0x74>
8000497e:	f0 1f 00 0a 	mcall	800049a4 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80004982:	48 b8       	lddpc	r8,800049ac <xTaskRemoveFromEventList+0x78>
80004984:	70 08       	ld.w	r8,r8[0x0]
80004986:	6e b9       	ld.w	r9,r7[0x2c]
80004988:	70 b8       	ld.w	r8,r8[0x2c]
8000498a:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
8000498c:	5f 2c       	srhs	r12
8000498e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004992:	00 00       	add	r0,r0
80004994:	80 00       	ld.sh	r0,r0[0x0]
80004996:	3f ae       	mov	lr,-6
80004998:	00 00       	add	r0,r0
8000499a:	0d 28       	ld.uh	r8,r6++
8000499c:	00 00       	add	r0,r0
8000499e:	0d 60       	ld.uh	r0,--r6
800049a0:	00 00       	add	r0,r0
800049a2:	0c 44       	or	r4,r6
800049a4:	80 00       	ld.sh	r0,r0[0x0]
800049a6:	3f 5e       	mov	lr,-11
800049a8:	00 00       	add	r0,r0
800049aa:	0c fc       	st.b	--r6,r12
800049ac:	00 00       	add	r0,r0
800049ae:	0c f8       	st.b	--r6,r8

800049b0 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800049b0:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800049b4:	4b 98       	lddpc	r8,80004a98 <vTaskIncrementTick+0xe8>
800049b6:	70 08       	ld.w	r8,r8[0x0]
800049b8:	58 08       	cp.w	r8,0
800049ba:	c6 91       	brne	80004a8c <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800049bc:	4b 88       	lddpc	r8,80004a9c <vTaskIncrementTick+0xec>
800049be:	70 09       	ld.w	r9,r8[0x0]
800049c0:	2f f9       	sub	r9,-1
800049c2:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800049c4:	70 08       	ld.w	r8,r8[0x0]
800049c6:	58 08       	cp.w	r8,0
800049c8:	c1 a1       	brne	800049fc <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800049ca:	4b 68       	lddpc	r8,80004aa0 <vTaskIncrementTick+0xf0>
800049cc:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800049ce:	4b 69       	lddpc	r9,80004aa4 <vTaskIncrementTick+0xf4>
800049d0:	72 0b       	ld.w	r11,r9[0x0]
800049d2:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800049d4:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800049d6:	4b 59       	lddpc	r9,80004aa8 <vTaskIncrementTick+0xf8>
800049d8:	72 0a       	ld.w	r10,r9[0x0]
800049da:	2f fa       	sub	r10,-1
800049dc:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800049de:	70 08       	ld.w	r8,r8[0x0]
800049e0:	70 08       	ld.w	r8,r8[0x0]
800049e2:	58 08       	cp.w	r8,0
800049e4:	c0 51       	brne	800049ee <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800049e6:	3f f9       	mov	r9,-1
800049e8:	4b 18       	lddpc	r8,80004aac <vTaskIncrementTick+0xfc>
800049ea:	91 09       	st.w	r8[0x0],r9
800049ec:	c0 88       	rjmp	800049fc <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800049ee:	4a d8       	lddpc	r8,80004aa0 <vTaskIncrementTick+0xf0>
800049f0:	70 08       	ld.w	r8,r8[0x0]
800049f2:	70 38       	ld.w	r8,r8[0xc]
800049f4:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800049f6:	70 19       	ld.w	r9,r8[0x4]
800049f8:	4a d8       	lddpc	r8,80004aac <vTaskIncrementTick+0xfc>
800049fa:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800049fc:	4a 88       	lddpc	r8,80004a9c <vTaskIncrementTick+0xec>
800049fe:	70 09       	ld.w	r9,r8[0x0]
80004a00:	4a b8       	lddpc	r8,80004aac <vTaskIncrementTick+0xfc>
80004a02:	70 08       	ld.w	r8,r8[0x0]
80004a04:	10 39       	cp.w	r9,r8
80004a06:	c4 73       	brcs	80004a94 <vTaskIncrementTick+0xe4>
80004a08:	4a 68       	lddpc	r8,80004aa0 <vTaskIncrementTick+0xf0>
80004a0a:	70 08       	ld.w	r8,r8[0x0]
80004a0c:	70 08       	ld.w	r8,r8[0x0]
80004a0e:	58 08       	cp.w	r8,0
80004a10:	c0 c0       	breq	80004a28 <vTaskIncrementTick+0x78>
80004a12:	4a 48       	lddpc	r8,80004aa0 <vTaskIncrementTick+0xf0>
80004a14:	70 08       	ld.w	r8,r8[0x0]
80004a16:	70 38       	ld.w	r8,r8[0xc]
80004a18:	70 37       	ld.w	r7,r8[0xc]
80004a1a:	6e 18       	ld.w	r8,r7[0x4]
80004a1c:	4a 09       	lddpc	r9,80004a9c <vTaskIncrementTick+0xec>
80004a1e:	72 09       	ld.w	r9,r9[0x0]
80004a20:	12 38       	cp.w	r8,r9
80004a22:	e0 88 00 14 	brls	80004a4a <vTaskIncrementTick+0x9a>
80004a26:	c0 e8       	rjmp	80004a42 <vTaskIncrementTick+0x92>
80004a28:	3f f9       	mov	r9,-1
80004a2a:	4a 18       	lddpc	r8,80004aac <vTaskIncrementTick+0xfc>
80004a2c:	91 09       	st.w	r8[0x0],r9
80004a2e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80004a32:	6a 08       	ld.w	r8,r5[0x0]
80004a34:	70 38       	ld.w	r8,r8[0xc]
80004a36:	70 37       	ld.w	r7,r8[0xc]
80004a38:	6e 18       	ld.w	r8,r7[0x4]
80004a3a:	64 09       	ld.w	r9,r2[0x0]
80004a3c:	12 38       	cp.w	r8,r9
80004a3e:	e0 88 00 0a 	brls	80004a52 <vTaskIncrementTick+0xa2>
80004a42:	49 b9       	lddpc	r9,80004aac <vTaskIncrementTick+0xfc>
80004a44:	93 08       	st.w	r9[0x0],r8
80004a46:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80004a4a:	49 a4       	lddpc	r4,80004ab0 <vTaskIncrementTick+0x100>
80004a4c:	49 a3       	lddpc	r3,80004ab4 <vTaskIncrementTick+0x104>
80004a4e:	49 55       	lddpc	r5,80004aa0 <vTaskIncrementTick+0xf0>
80004a50:	49 32       	lddpc	r2,80004a9c <vTaskIncrementTick+0xec>
80004a52:	ee c6 ff fc 	sub	r6,r7,-4
80004a56:	0c 9c       	mov	r12,r6
80004a58:	f0 1f 00 18 	mcall	80004ab8 <vTaskIncrementTick+0x108>
80004a5c:	6e a8       	ld.w	r8,r7[0x28]
80004a5e:	58 08       	cp.w	r8,0
80004a60:	c0 50       	breq	80004a6a <vTaskIncrementTick+0xba>
80004a62:	ee cc ff e8 	sub	r12,r7,-24
80004a66:	f0 1f 00 15 	mcall	80004ab8 <vTaskIncrementTick+0x108>
80004a6a:	6e bc       	ld.w	r12,r7[0x2c]
80004a6c:	68 08       	ld.w	r8,r4[0x0]
80004a6e:	10 3c       	cp.w	r12,r8
80004a70:	e9 fc ba 00 	st.whi	r4[0x0],r12
80004a74:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80004a78:	0c 9b       	mov	r11,r6
80004a7a:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80004a7e:	f0 1f 00 10 	mcall	80004abc <vTaskIncrementTick+0x10c>
80004a82:	6a 08       	ld.w	r8,r5[0x0]
80004a84:	70 08       	ld.w	r8,r8[0x0]
80004a86:	58 08       	cp.w	r8,0
80004a88:	cd 51       	brne	80004a32 <vTaskIncrementTick+0x82>
80004a8a:	cc fb       	rjmp	80004a28 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80004a8c:	48 d8       	lddpc	r8,80004ac0 <vTaskIncrementTick+0x110>
80004a8e:	70 09       	ld.w	r9,r8[0x0]
80004a90:	2f f9       	sub	r9,-1
80004a92:	91 09       	st.w	r8[0x0],r9
80004a94:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80004a98:	00 00       	add	r0,r0
80004a9a:	0d 28       	ld.uh	r8,r6++
80004a9c:	00 00       	add	r0,r0
80004a9e:	0d 24       	ld.uh	r4,r6++
80004aa0:	00 00       	add	r0,r0
80004aa2:	0c 30       	cp.w	r0,r6
80004aa4:	00 00       	add	r0,r0
80004aa6:	0c 40       	or	r0,r6
80004aa8:	00 00       	add	r0,r0
80004aaa:	0c 3c       	cp.w	r12,r6
80004aac:	00 00       	add	r0,r0
80004aae:	05 3c       	ld.ub	r12,r2++
80004ab0:	00 00       	add	r0,r0
80004ab2:	0d 60       	ld.uh	r0,--r6
80004ab4:	00 00       	add	r0,r0
80004ab6:	0c 44       	or	r4,r6
80004ab8:	80 00       	ld.sh	r0,r0[0x0]
80004aba:	3f ae       	mov	lr,-6
80004abc:	80 00       	ld.sh	r0,r0[0x0]
80004abe:	3f 5e       	mov	lr,-11
80004ac0:	00 00       	add	r0,r0
80004ac2:	0c 28       	rsub	r8,r6

80004ac4 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80004ac4:	eb cd 40 c0 	pushm	r6-r7,lr
80004ac8:	18 97       	mov	r7,r12
80004aca:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80004acc:	f0 1f 00 15 	mcall	80004b20 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80004ad0:	6c 08       	ld.w	r8,r6[0x0]
80004ad2:	5b f8       	cp.w	r8,-1
80004ad4:	c0 31       	brne	80004ada <xTaskCheckForTimeOut+0x16>
80004ad6:	30 07       	mov	r7,0
80004ad8:	c1 f8       	rjmp	80004b16 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80004ada:	49 39       	lddpc	r9,80004b24 <xTaskCheckForTimeOut+0x60>
80004adc:	72 09       	ld.w	r9,r9[0x0]
80004ade:	6e 0a       	ld.w	r10,r7[0x0]
80004ae0:	12 3a       	cp.w	r10,r9
80004ae2:	c0 70       	breq	80004af0 <xTaskCheckForTimeOut+0x2c>
80004ae4:	49 19       	lddpc	r9,80004b28 <xTaskCheckForTimeOut+0x64>
80004ae6:	72 09       	ld.w	r9,r9[0x0]
80004ae8:	6e 1a       	ld.w	r10,r7[0x4]
80004aea:	12 3a       	cp.w	r10,r9
80004aec:	e0 88 00 14 	brls	80004b14 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80004af0:	48 e9       	lddpc	r9,80004b28 <xTaskCheckForTimeOut+0x64>
80004af2:	72 0a       	ld.w	r10,r9[0x0]
80004af4:	6e 19       	ld.w	r9,r7[0x4]
80004af6:	12 1a       	sub	r10,r9
80004af8:	14 38       	cp.w	r8,r10
80004afa:	e0 88 00 0d 	brls	80004b14 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80004afe:	48 ba       	lddpc	r10,80004b28 <xTaskCheckForTimeOut+0x64>
80004b00:	74 0a       	ld.w	r10,r10[0x0]
80004b02:	14 19       	sub	r9,r10
80004b04:	f2 08 00 08 	add	r8,r9,r8
80004b08:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80004b0a:	0e 9c       	mov	r12,r7
80004b0c:	f0 1f 00 08 	mcall	80004b2c <xTaskCheckForTimeOut+0x68>
80004b10:	30 07       	mov	r7,0
80004b12:	c0 28       	rjmp	80004b16 <xTaskCheckForTimeOut+0x52>
80004b14:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80004b16:	f0 1f 00 07 	mcall	80004b30 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80004b1a:	0e 9c       	mov	r12,r7
80004b1c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004b20:	80 00       	ld.sh	r0,r0[0x0]
80004b22:	40 68       	lddsp	r8,sp[0x18]
80004b24:	00 00       	add	r0,r0
80004b26:	0c 3c       	cp.w	r12,r6
80004b28:	00 00       	add	r0,r0
80004b2a:	0d 24       	ld.uh	r4,r6++
80004b2c:	80 00       	ld.sh	r0,r0[0x0]
80004b2e:	48 28       	lddpc	r8,80004b34 <xTaskGetTickCount>
80004b30:	80 00       	ld.sh	r0,r0[0x0]
80004b32:	41 74       	lddsp	r4,sp[0x5c]

80004b34 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80004b34:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80004b38:	f0 1f 00 05 	mcall	80004b4c <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80004b3c:	48 58       	lddpc	r8,80004b50 <xTaskGetTickCount+0x1c>
80004b3e:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80004b40:	f0 1f 00 05 	mcall	80004b54 <xTaskGetTickCount+0x20>

	return xTicks;
}
80004b44:	0e 9c       	mov	r12,r7
80004b46:	e3 cd 80 80 	ldm	sp++,r7,pc
80004b4a:	00 00       	add	r0,r0
80004b4c:	80 00       	ld.sh	r0,r0[0x0]
80004b4e:	40 68       	lddsp	r8,sp[0x18]
80004b50:	00 00       	add	r0,r0
80004b52:	0d 24       	ld.uh	r4,r6++
80004b54:	80 00       	ld.sh	r0,r0[0x0]
80004b56:	41 74       	lddsp	r4,sp[0x5c]

80004b58 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80004b58:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80004b5c:	f0 1f 00 2c 	mcall	80004c0c <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80004b60:	4a c8       	lddpc	r8,80004c10 <xTaskResumeAll+0xb8>
80004b62:	70 09       	ld.w	r9,r8[0x0]
80004b64:	20 19       	sub	r9,1
80004b66:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80004b68:	70 08       	ld.w	r8,r8[0x0]
80004b6a:	58 08       	cp.w	r8,0
80004b6c:	c4 91       	brne	80004bfe <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80004b6e:	4a a8       	lddpc	r8,80004c14 <xTaskResumeAll+0xbc>
80004b70:	70 08       	ld.w	r8,r8[0x0]
80004b72:	58 08       	cp.w	r8,0
80004b74:	c4 50       	breq	80004bfe <xTaskResumeAll+0xa6>
80004b76:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80004b78:	4a 85       	lddpc	r5,80004c18 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80004b7a:	4a 93       	lddpc	r3,80004c1c <xTaskResumeAll+0xc4>
80004b7c:	4a 92       	lddpc	r2,80004c20 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80004b7e:	4a a1       	lddpc	r1,80004c24 <xTaskResumeAll+0xcc>
80004b80:	c1 e8       	rjmp	80004bbc <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80004b82:	6a 38       	ld.w	r8,r5[0xc]
80004b84:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80004b86:	ee cc ff e8 	sub	r12,r7,-24
80004b8a:	f0 1f 00 28 	mcall	80004c28 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80004b8e:	ee c6 ff fc 	sub	r6,r7,-4
80004b92:	0c 9c       	mov	r12,r6
80004b94:	f0 1f 00 25 	mcall	80004c28 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80004b98:	6e bc       	ld.w	r12,r7[0x2c]
80004b9a:	66 08       	ld.w	r8,r3[0x0]
80004b9c:	10 3c       	cp.w	r12,r8
80004b9e:	e7 fc ba 00 	st.whi	r3[0x0],r12
80004ba2:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80004ba6:	0c 9b       	mov	r11,r6
80004ba8:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80004bac:	f0 1f 00 20 	mcall	80004c2c <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80004bb0:	62 08       	ld.w	r8,r1[0x0]
80004bb2:	6e b9       	ld.w	r9,r7[0x2c]
80004bb4:	70 b8       	ld.w	r8,r8[0x2c]
80004bb6:	10 39       	cp.w	r9,r8
80004bb8:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80004bbc:	6a 08       	ld.w	r8,r5[0x0]
80004bbe:	58 08       	cp.w	r8,0
80004bc0:	ce 11       	brne	80004b82 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80004bc2:	49 c8       	lddpc	r8,80004c30 <xTaskResumeAll+0xd8>
80004bc4:	70 08       	ld.w	r8,r8[0x0]
80004bc6:	58 08       	cp.w	r8,0
80004bc8:	c0 f0       	breq	80004be6 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80004bca:	49 a8       	lddpc	r8,80004c30 <xTaskResumeAll+0xd8>
80004bcc:	70 08       	ld.w	r8,r8[0x0]
80004bce:	58 08       	cp.w	r8,0
80004bd0:	c1 10       	breq	80004bf2 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80004bd2:	49 87       	lddpc	r7,80004c30 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80004bd4:	f0 1f 00 18 	mcall	80004c34 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80004bd8:	6e 08       	ld.w	r8,r7[0x0]
80004bda:	20 18       	sub	r8,1
80004bdc:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80004bde:	6e 08       	ld.w	r8,r7[0x0]
80004be0:	58 08       	cp.w	r8,0
80004be2:	cf 91       	brne	80004bd4 <xTaskResumeAll+0x7c>
80004be4:	c0 78       	rjmp	80004bf2 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80004be6:	58 14       	cp.w	r4,1
80004be8:	c0 50       	breq	80004bf2 <xTaskResumeAll+0x9a>
80004bea:	49 48       	lddpc	r8,80004c38 <xTaskResumeAll+0xe0>
80004bec:	70 08       	ld.w	r8,r8[0x0]
80004bee:	58 18       	cp.w	r8,1
80004bf0:	c0 71       	brne	80004bfe <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80004bf2:	30 09       	mov	r9,0
80004bf4:	49 18       	lddpc	r8,80004c38 <xTaskResumeAll+0xe0>
80004bf6:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80004bf8:	d7 33       	scall
80004bfa:	30 17       	mov	r7,1
80004bfc:	c0 28       	rjmp	80004c00 <xTaskResumeAll+0xa8>
80004bfe:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80004c00:	f0 1f 00 0f 	mcall	80004c3c <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80004c04:	0e 9c       	mov	r12,r7
80004c06:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80004c0a:	00 00       	add	r0,r0
80004c0c:	80 00       	ld.sh	r0,r0[0x0]
80004c0e:	40 68       	lddsp	r8,sp[0x18]
80004c10:	00 00       	add	r0,r0
80004c12:	0d 28       	ld.uh	r8,r6++
80004c14:	00 00       	add	r0,r0
80004c16:	0d 44       	ld.w	r4,--r6
80004c18:	00 00       	add	r0,r0
80004c1a:	0c fc       	st.b	--r6,r12
80004c1c:	00 00       	add	r0,r0
80004c1e:	0d 60       	ld.uh	r0,--r6
80004c20:	00 00       	add	r0,r0
80004c22:	0c 44       	or	r4,r6
80004c24:	00 00       	add	r0,r0
80004c26:	0c f8       	st.b	--r6,r8
80004c28:	80 00       	ld.sh	r0,r0[0x0]
80004c2a:	3f ae       	mov	lr,-6
80004c2c:	80 00       	ld.sh	r0,r0[0x0]
80004c2e:	3f 5e       	mov	lr,-11
80004c30:	00 00       	add	r0,r0
80004c32:	0c 28       	rsub	r8,r6
80004c34:	80 00       	ld.sh	r0,r0[0x0]
80004c36:	49 b0       	lddpc	r0,80004ca0 <vTaskDelay+0x4>
80004c38:	00 00       	add	r0,r0
80004c3a:	0d 48       	ld.w	r8,--r6
80004c3c:	80 00       	ld.sh	r0,r0[0x0]
80004c3e:	41 74       	lddsp	r4,sp[0x5c]

80004c40 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80004c40:	eb cd 40 80 	pushm	r7,lr
80004c44:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80004c46:	49 08       	lddpc	r8,80004c84 <prvAddCurrentTaskToDelayedList+0x44>
80004c48:	70 08       	ld.w	r8,r8[0x0]
80004c4a:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80004c4c:	48 f8       	lddpc	r8,80004c88 <prvAddCurrentTaskToDelayedList+0x48>
80004c4e:	70 08       	ld.w	r8,r8[0x0]
80004c50:	10 3c       	cp.w	r12,r8
80004c52:	c0 a2       	brcc	80004c66 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80004c54:	48 c8       	lddpc	r8,80004c84 <prvAddCurrentTaskToDelayedList+0x44>
80004c56:	70 0b       	ld.w	r11,r8[0x0]
80004c58:	48 d8       	lddpc	r8,80004c8c <prvAddCurrentTaskToDelayedList+0x4c>
80004c5a:	70 0c       	ld.w	r12,r8[0x0]
80004c5c:	2f cb       	sub	r11,-4
80004c5e:	f0 1f 00 0d 	mcall	80004c90 <prvAddCurrentTaskToDelayedList+0x50>
80004c62:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80004c66:	48 88       	lddpc	r8,80004c84 <prvAddCurrentTaskToDelayedList+0x44>
80004c68:	70 0b       	ld.w	r11,r8[0x0]
80004c6a:	48 b8       	lddpc	r8,80004c94 <prvAddCurrentTaskToDelayedList+0x54>
80004c6c:	70 0c       	ld.w	r12,r8[0x0]
80004c6e:	2f cb       	sub	r11,-4
80004c70:	f0 1f 00 08 	mcall	80004c90 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80004c74:	48 98       	lddpc	r8,80004c98 <prvAddCurrentTaskToDelayedList+0x58>
80004c76:	70 08       	ld.w	r8,r8[0x0]
80004c78:	10 37       	cp.w	r7,r8
80004c7a:	c0 32       	brcc	80004c80 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80004c7c:	48 78       	lddpc	r8,80004c98 <prvAddCurrentTaskToDelayedList+0x58>
80004c7e:	91 07       	st.w	r8[0x0],r7
80004c80:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c84:	00 00       	add	r0,r0
80004c86:	0c f8       	st.b	--r6,r8
80004c88:	00 00       	add	r0,r0
80004c8a:	0d 24       	ld.uh	r4,r6++
80004c8c:	00 00       	add	r0,r0
80004c8e:	0c 40       	or	r0,r6
80004c90:	80 00       	ld.sh	r0,r0[0x0]
80004c92:	3f 7a       	mov	r10,-9
80004c94:	00 00       	add	r0,r0
80004c96:	0c 30       	cp.w	r0,r6
80004c98:	00 00       	add	r0,r0
80004c9a:	05 3c       	ld.ub	r12,r2++

80004c9c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80004c9c:	eb cd 40 c0 	pushm	r6-r7,lr
80004ca0:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80004ca2:	58 0c       	cp.w	r12,0
80004ca4:	c1 10       	breq	80004cc6 <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80004ca6:	f0 1f 00 0a 	mcall	80004ccc <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80004caa:	48 a8       	lddpc	r8,80004cd0 <vTaskDelay+0x34>
80004cac:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80004cae:	48 a8       	lddpc	r8,80004cd4 <vTaskDelay+0x38>
80004cb0:	70 0c       	ld.w	r12,r8[0x0]
80004cb2:	2f cc       	sub	r12,-4
80004cb4:	f0 1f 00 09 	mcall	80004cd8 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80004cb8:	ee 06 00 0c 	add	r12,r7,r6
80004cbc:	f0 1f 00 08 	mcall	80004cdc <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80004cc0:	f0 1f 00 08 	mcall	80004ce0 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80004cc4:	c0 21       	brne	80004cc8 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80004cc6:	d7 33       	scall
80004cc8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004ccc:	80 00       	ld.sh	r0,r0[0x0]
80004cce:	47 9c       	lddsp	r12,sp[0x1e4]
80004cd0:	00 00       	add	r0,r0
80004cd2:	0d 24       	ld.uh	r4,r6++
80004cd4:	00 00       	add	r0,r0
80004cd6:	0c f8       	st.b	--r6,r8
80004cd8:	80 00       	ld.sh	r0,r0[0x0]
80004cda:	3f ae       	mov	lr,-6
80004cdc:	80 00       	ld.sh	r0,r0[0x0]
80004cde:	4c 40       	lddpc	r0,80004dec <prvIdleTask+0x30>
80004ce0:	80 00       	ld.sh	r0,r0[0x0]
80004ce2:	4b 58       	lddpc	r8,80004db4 <vTaskPlaceOnEventList+0x50>

80004ce4 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80004ce4:	eb cd 40 c0 	pushm	r6-r7,lr
80004ce8:	18 96       	mov	r6,r12
80004cea:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80004cec:	f0 1f 00 18 	mcall	80004d4c <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80004cf0:	6c 08       	ld.w	r8,r6[0x0]
80004cf2:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80004cf4:	49 79       	lddpc	r9,80004d50 <vTaskDelayUntil+0x6c>
80004cf6:	72 09       	ld.w	r9,r9[0x0]
80004cf8:	12 38       	cp.w	r8,r9
80004cfa:	e0 88 00 0c 	brls	80004d12 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80004cfe:	0e 38       	cp.w	r8,r7
80004d00:	e0 88 00 22 	brls	80004d44 <vTaskDelayUntil+0x60>
80004d04:	49 38       	lddpc	r8,80004d50 <vTaskDelayUntil+0x6c>
80004d06:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80004d08:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80004d0a:	10 37       	cp.w	r7,r8
80004d0c:	e0 88 00 14 	brls	80004d34 <vTaskDelayUntil+0x50>
80004d10:	c0 a8       	rjmp	80004d24 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80004d12:	0e 38       	cp.w	r8,r7
80004d14:	e0 8b 00 16 	brhi	80004d40 <vTaskDelayUntil+0x5c>
80004d18:	48 e8       	lddpc	r8,80004d50 <vTaskDelayUntil+0x6c>
80004d1a:	70 08       	ld.w	r8,r8[0x0]
80004d1c:	10 37       	cp.w	r7,r8
80004d1e:	e0 8b 00 11 	brhi	80004d40 <vTaskDelayUntil+0x5c>
80004d22:	c1 18       	rjmp	80004d44 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80004d24:	48 c8       	lddpc	r8,80004d54 <vTaskDelayUntil+0x70>
80004d26:	70 0c       	ld.w	r12,r8[0x0]
80004d28:	2f cc       	sub	r12,-4
80004d2a:	f0 1f 00 0c 	mcall	80004d58 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80004d2e:	0e 9c       	mov	r12,r7
80004d30:	f0 1f 00 0b 	mcall	80004d5c <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80004d34:	f0 1f 00 0b 	mcall	80004d60 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80004d38:	c0 81       	brne	80004d48 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80004d3a:	d7 33       	scall
80004d3c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80004d40:	8d 07       	st.w	r6[0x0],r7
80004d42:	cf 1b       	rjmp	80004d24 <vTaskDelayUntil+0x40>
80004d44:	8d 07       	st.w	r6[0x0],r7
80004d46:	cf 7b       	rjmp	80004d34 <vTaskDelayUntil+0x50>
80004d48:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004d4c:	80 00       	ld.sh	r0,r0[0x0]
80004d4e:	47 9c       	lddsp	r12,sp[0x1e4]
80004d50:	00 00       	add	r0,r0
80004d52:	0d 24       	ld.uh	r4,r6++
80004d54:	00 00       	add	r0,r0
80004d56:	0c f8       	st.b	--r6,r8
80004d58:	80 00       	ld.sh	r0,r0[0x0]
80004d5a:	3f ae       	mov	lr,-6
80004d5c:	80 00       	ld.sh	r0,r0[0x0]
80004d5e:	4c 40       	lddpc	r0,80004e6c <xTaskGenericCreate+0x28>
80004d60:	80 00       	ld.sh	r0,r0[0x0]
80004d62:	4b 58       	lddpc	r8,80004e34 <prvIdleTask+0x78>

80004d64 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80004d64:	eb cd 40 c0 	pushm	r6-r7,lr
80004d68:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80004d6a:	48 e7       	lddpc	r7,80004da0 <vTaskPlaceOnEventList+0x3c>
80004d6c:	6e 0b       	ld.w	r11,r7[0x0]
80004d6e:	2e 8b       	sub	r11,-24
80004d70:	f0 1f 00 0d 	mcall	80004da4 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80004d74:	6e 0c       	ld.w	r12,r7[0x0]
80004d76:	2f cc       	sub	r12,-4
80004d78:	f0 1f 00 0c 	mcall	80004da8 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80004d7c:	5b f6       	cp.w	r6,-1
80004d7e:	c0 81       	brne	80004d8e <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80004d80:	6e 0b       	ld.w	r11,r7[0x0]
80004d82:	2f cb       	sub	r11,-4
80004d84:	48 ac       	lddpc	r12,80004dac <vTaskPlaceOnEventList+0x48>
80004d86:	f0 1f 00 0b 	mcall	80004db0 <vTaskPlaceOnEventList+0x4c>
80004d8a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80004d8e:	48 a8       	lddpc	r8,80004db4 <vTaskPlaceOnEventList+0x50>
80004d90:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80004d92:	ec 0c 00 0c 	add	r12,r6,r12
80004d96:	f0 1f 00 09 	mcall	80004db8 <vTaskPlaceOnEventList+0x54>
80004d9a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004d9e:	00 00       	add	r0,r0
80004da0:	00 00       	add	r0,r0
80004da2:	0c f8       	st.b	--r6,r8
80004da4:	80 00       	ld.sh	r0,r0[0x0]
80004da6:	3f 7a       	mov	r10,-9
80004da8:	80 00       	ld.sh	r0,r0[0x0]
80004daa:	3f ae       	mov	lr,-6
80004dac:	00 00       	add	r0,r0
80004dae:	0d 4c       	ld.w	r12,--r6
80004db0:	80 00       	ld.sh	r0,r0[0x0]
80004db2:	3f 5e       	mov	lr,-11
80004db4:	00 00       	add	r0,r0
80004db6:	0d 24       	ld.uh	r4,r6++
80004db8:	80 00       	ld.sh	r0,r0[0x0]
80004dba:	4c 40       	lddpc	r0,80004ec8 <xTaskGenericCreate+0x84>

80004dbc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80004dbc:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80004dc0:	49 67       	lddpc	r7,80004e18 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80004dc2:	49 74       	lddpc	r4,80004e1c <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80004dc4:	49 73       	lddpc	r3,80004e20 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80004dc6:	49 85       	lddpc	r5,80004e24 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80004dc8:	6e 08       	ld.w	r8,r7[0x0]
80004dca:	58 08       	cp.w	r8,0
80004dcc:	c1 e0       	breq	80004e08 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80004dce:	f0 1f 00 17 	mcall	80004e28 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80004dd2:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80004dd4:	f0 1f 00 16 	mcall	80004e2c <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80004dd8:	58 06       	cp.w	r6,0
80004dda:	c1 70       	breq	80004e08 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80004ddc:	f0 1f 00 15 	mcall	80004e30 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80004de0:	68 38       	ld.w	r8,r4[0xc]
80004de2:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80004de4:	ec cc ff fc 	sub	r12,r6,-4
80004de8:	f0 1f 00 13 	mcall	80004e34 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80004dec:	66 08       	ld.w	r8,r3[0x0]
80004dee:	20 18       	sub	r8,1
80004df0:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80004df2:	6e 08       	ld.w	r8,r7[0x0]
80004df4:	20 18       	sub	r8,1
80004df6:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80004df8:	f0 1f 00 10 	mcall	80004e38 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80004dfc:	6c cc       	ld.w	r12,r6[0x30]
80004dfe:	f0 1f 00 10 	mcall	80004e3c <prvIdleTask+0x80>
		vPortFree( pxTCB );
80004e02:	0c 9c       	mov	r12,r6
80004e04:	f0 1f 00 0e 	mcall	80004e3c <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80004e08:	6a 08       	ld.w	r8,r5[0x0]
80004e0a:	58 18       	cp.w	r8,1
80004e0c:	e0 88 00 03 	brls	80004e12 <prvIdleTask+0x56>
			{
				taskYIELD();
80004e10:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80004e12:	f0 1f 00 0c 	mcall	80004e40 <prvIdleTask+0x84>
		}
		#endif
	}
80004e16:	cd 9b       	rjmp	80004dc8 <prvIdleTask+0xc>
80004e18:	00 00       	add	r0,r0
80004e1a:	0c 38       	cp.w	r8,r6
80004e1c:	00 00       	add	r0,r0
80004e1e:	0c e4       	st.h	--r6,r4
80004e20:	00 00       	add	r0,r0
80004e22:	0d 44       	ld.w	r4,--r6
80004e24:	00 00       	add	r0,r0
80004e26:	0c 44       	or	r4,r6
80004e28:	80 00       	ld.sh	r0,r0[0x0]
80004e2a:	47 9c       	lddsp	r12,sp[0x1e4]
80004e2c:	80 00       	ld.sh	r0,r0[0x0]
80004e2e:	4b 58       	lddpc	r8,80004f00 <xTaskGenericCreate+0xbc>
80004e30:	80 00       	ld.sh	r0,r0[0x0]
80004e32:	40 68       	lddsp	r8,sp[0x18]
80004e34:	80 00       	ld.sh	r0,r0[0x0]
80004e36:	3f ae       	mov	lr,-6
80004e38:	80 00       	ld.sh	r0,r0[0x0]
80004e3a:	41 74       	lddsp	r4,sp[0x5c]
80004e3c:	80 00       	ld.sh	r0,r0[0x0]
80004e3e:	42 ac       	lddsp	r12,sp[0xa8]
80004e40:	80 00       	ld.sh	r0,r0[0x0]
80004e42:	00 4c       	or	r12,r0

80004e44 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80004e44:	d4 31       	pushm	r0-r7,lr
80004e46:	20 1d       	sub	sp,4
80004e48:	fa c4 ff d8 	sub	r4,sp,-40
80004e4c:	50 0c       	stdsp	sp[0x0],r12
80004e4e:	16 91       	mov	r1,r11
80004e50:	14 97       	mov	r7,r10
80004e52:	12 90       	mov	r0,r9
80004e54:	10 93       	mov	r3,r8
80004e56:	68 02       	ld.w	r2,r4[0x0]
80004e58:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80004e5a:	34 8c       	mov	r12,72
80004e5c:	f0 1f 00 5c 	mcall	80004fcc <xTaskGenericCreate+0x188>
80004e60:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80004e62:	c0 31       	brne	80004e68 <xTaskGenericCreate+0x24>
80004e64:	3f fc       	mov	r12,-1
80004e66:	ca f8       	rjmp	80004fc4 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80004e68:	58 06       	cp.w	r6,0
80004e6a:	e0 81 00 af 	brne	80004fc8 <xTaskGenericCreate+0x184>
80004e6e:	0e 9c       	mov	r12,r7
80004e70:	5c 7c       	castu.h	r12
80004e72:	a3 6c       	lsl	r12,0x2
80004e74:	f0 1f 00 56 	mcall	80004fcc <xTaskGenericCreate+0x188>
80004e78:	18 96       	mov	r6,r12
80004e7a:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80004e7c:	c0 61       	brne	80004e88 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80004e7e:	0a 9c       	mov	r12,r5
80004e80:	f0 1f 00 54 	mcall	80004fd0 <xTaskGenericCreate+0x18c>
80004e84:	3f fc       	mov	r12,-1
80004e86:	c9 f8       	rjmp	80004fc4 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80004e88:	5c 77       	castu.h	r7
80004e8a:	ee 0a 15 02 	lsl	r10,r7,0x2
80004e8e:	e0 6b 00 a5 	mov	r11,165
80004e92:	0c 9c       	mov	r12,r6
80004e94:	f0 1f 00 50 	mcall	80004fd4 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80004e98:	ee c6 00 01 	sub	r6,r7,1
80004e9c:	6a c8       	ld.w	r8,r5[0x30]
80004e9e:	f0 06 00 26 	add	r6,r8,r6<<0x2
80004ea2:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80004ea6:	31 0a       	mov	r10,16
80004ea8:	02 9b       	mov	r11,r1
80004eaa:	ea cc ff cc 	sub	r12,r5,-52
80004eae:	f0 1f 00 4b 	mcall	80004fd8 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80004eb2:	30 08       	mov	r8,0
80004eb4:	eb 68 00 43 	st.b	r5[67],r8
80004eb8:	58 73       	cp.w	r3,7
80004eba:	e6 07 17 80 	movls	r7,r3
80004ebe:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80004ec2:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80004ec4:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80004ec8:	ea c4 ff fc 	sub	r4,r5,-4
80004ecc:	08 9c       	mov	r12,r4
80004ece:	f0 1f 00 44 	mcall	80004fdc <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80004ed2:	ea cc ff e8 	sub	r12,r5,-24
80004ed6:	f0 1f 00 42 	mcall	80004fdc <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80004eda:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80004edc:	ee 07 11 08 	rsub	r7,r7,8
80004ee0:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80004ee2:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80004ee4:	00 9a       	mov	r10,r0
80004ee6:	40 0b       	lddsp	r11,sp[0x0]
80004ee8:	0c 9c       	mov	r12,r6
80004eea:	f0 1f 00 3e 	mcall	80004fe0 <xTaskGenericCreate+0x19c>
80004eee:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80004ef0:	58 02       	cp.w	r2,0
80004ef2:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80004ef6:	f0 1f 00 3c 	mcall	80004fe4 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80004efa:	4b c8       	lddpc	r8,80004fe8 <xTaskGenericCreate+0x1a4>
80004efc:	70 09       	ld.w	r9,r8[0x0]
80004efe:	2f f9       	sub	r9,-1
80004f00:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80004f02:	4b b8       	lddpc	r8,80004fec <xTaskGenericCreate+0x1a8>
80004f04:	70 08       	ld.w	r8,r8[0x0]
80004f06:	58 08       	cp.w	r8,0
80004f08:	c2 61       	brne	80004f54 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80004f0a:	4b 98       	lddpc	r8,80004fec <xTaskGenericCreate+0x1a8>
80004f0c:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80004f0e:	4b 78       	lddpc	r8,80004fe8 <xTaskGenericCreate+0x1a4>
80004f10:	70 08       	ld.w	r8,r8[0x0]
80004f12:	58 18       	cp.w	r8,1
80004f14:	c2 b1       	brne	80004f6a <xTaskGenericCreate+0x126>
80004f16:	4b 77       	lddpc	r7,80004ff0 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80004f18:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80004f1c:	0e 9c       	mov	r12,r7
80004f1e:	f0 1f 00 36 	mcall	80004ff4 <xTaskGenericCreate+0x1b0>
80004f22:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80004f24:	0c 37       	cp.w	r7,r6
80004f26:	cf b1       	brne	80004f1c <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80004f28:	4b 47       	lddpc	r7,80004ff8 <xTaskGenericCreate+0x1b4>
80004f2a:	0e 9c       	mov	r12,r7
80004f2c:	f0 1f 00 32 	mcall	80004ff4 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80004f30:	4b 36       	lddpc	r6,80004ffc <xTaskGenericCreate+0x1b8>
80004f32:	0c 9c       	mov	r12,r6
80004f34:	f0 1f 00 30 	mcall	80004ff4 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80004f38:	4b 2c       	lddpc	r12,80005000 <xTaskGenericCreate+0x1bc>
80004f3a:	f0 1f 00 2f 	mcall	80004ff4 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80004f3e:	4b 2c       	lddpc	r12,80005004 <xTaskGenericCreate+0x1c0>
80004f40:	f0 1f 00 2d 	mcall	80004ff4 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80004f44:	4b 1c       	lddpc	r12,80005008 <xTaskGenericCreate+0x1c4>
80004f46:	f0 1f 00 2c 	mcall	80004ff4 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80004f4a:	4b 18       	lddpc	r8,8000500c <xTaskGenericCreate+0x1c8>
80004f4c:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80004f4e:	4b 18       	lddpc	r8,80005010 <xTaskGenericCreate+0x1cc>
80004f50:	91 06       	st.w	r8[0x0],r6
80004f52:	c0 c8       	rjmp	80004f6a <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80004f54:	4b 08       	lddpc	r8,80005014 <xTaskGenericCreate+0x1d0>
80004f56:	70 08       	ld.w	r8,r8[0x0]
80004f58:	58 08       	cp.w	r8,0
80004f5a:	c0 81       	brne	80004f6a <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80004f5c:	4a 48       	lddpc	r8,80004fec <xTaskGenericCreate+0x1a8>
80004f5e:	70 08       	ld.w	r8,r8[0x0]
80004f60:	70 b8       	ld.w	r8,r8[0x2c]
80004f62:	10 33       	cp.w	r3,r8
80004f64:	c0 33       	brcs	80004f6a <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80004f66:	4a 28       	lddpc	r8,80004fec <xTaskGenericCreate+0x1a8>
80004f68:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80004f6a:	6a b8       	ld.w	r8,r5[0x2c]
80004f6c:	4a b9       	lddpc	r9,80005018 <xTaskGenericCreate+0x1d4>
80004f6e:	72 09       	ld.w	r9,r9[0x0]
80004f70:	12 38       	cp.w	r8,r9
80004f72:	e0 88 00 04 	brls	80004f7a <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80004f76:	4a 99       	lddpc	r9,80005018 <xTaskGenericCreate+0x1d4>
80004f78:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80004f7a:	4a 98       	lddpc	r8,8000501c <xTaskGenericCreate+0x1d8>
80004f7c:	70 09       	ld.w	r9,r8[0x0]
80004f7e:	2f f9       	sub	r9,-1
80004f80:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80004f82:	6a b8       	ld.w	r8,r5[0x2c]
80004f84:	4a 79       	lddpc	r9,80005020 <xTaskGenericCreate+0x1dc>
80004f86:	72 09       	ld.w	r9,r9[0x0]
80004f88:	12 38       	cp.w	r8,r9
80004f8a:	e0 88 00 04 	brls	80004f92 <xTaskGenericCreate+0x14e>
80004f8e:	4a 59       	lddpc	r9,80005020 <xTaskGenericCreate+0x1dc>
80004f90:	93 08       	st.w	r9[0x0],r8
80004f92:	6a bc       	ld.w	r12,r5[0x2c]
80004f94:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80004f98:	08 9b       	mov	r11,r4
80004f9a:	49 68       	lddpc	r8,80004ff0 <xTaskGenericCreate+0x1ac>
80004f9c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004fa0:	f0 1f 00 21 	mcall	80005024 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80004fa4:	f0 1f 00 21 	mcall	80005028 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80004fa8:	49 b8       	lddpc	r8,80005014 <xTaskGenericCreate+0x1d0>
80004faa:	70 08       	ld.w	r8,r8[0x0]
80004fac:	58 08       	cp.w	r8,0
80004fae:	c0 a0       	breq	80004fc2 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80004fb0:	48 f8       	lddpc	r8,80004fec <xTaskGenericCreate+0x1a8>
80004fb2:	70 08       	ld.w	r8,r8[0x0]
80004fb4:	70 b8       	ld.w	r8,r8[0x2c]
80004fb6:	10 33       	cp.w	r3,r8
80004fb8:	e0 88 00 05 	brls	80004fc2 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80004fbc:	d7 33       	scall
80004fbe:	30 1c       	mov	r12,1
80004fc0:	c0 28       	rjmp	80004fc4 <xTaskGenericCreate+0x180>
80004fc2:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80004fc4:	2f fd       	sub	sp,-4
80004fc6:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80004fc8:	99 c6       	st.w	r12[0x30],r6
80004fca:	c5 fb       	rjmp	80004e88 <xTaskGenericCreate+0x44>
80004fcc:	80 00       	ld.sh	r0,r0[0x0]
80004fce:	42 d4       	lddsp	r4,sp[0xb4]
80004fd0:	80 00       	ld.sh	r0,r0[0x0]
80004fd2:	42 ac       	lddsp	r12,sp[0xa8]
80004fd4:	80 00       	ld.sh	r0,r0[0x0]
80004fd6:	5b d8       	cp.w	r8,-3
80004fd8:	80 00       	ld.sh	r0,r0[0x0]
80004fda:	5f 04       	sreq	r4
80004fdc:	80 00       	ld.sh	r0,r0[0x0]
80004fde:	3f 58       	mov	r8,-11
80004fe0:	80 00       	ld.sh	r0,r0[0x0]
80004fe2:	3f d4       	mov	r4,-3
80004fe4:	80 00       	ld.sh	r0,r0[0x0]
80004fe6:	40 68       	lddsp	r8,sp[0x18]
80004fe8:	00 00       	add	r0,r0
80004fea:	0d 44       	ld.w	r4,--r6
80004fec:	00 00       	add	r0,r0
80004fee:	0c f8       	st.b	--r6,r8
80004ff0:	00 00       	add	r0,r0
80004ff2:	0c 44       	or	r4,r6
80004ff4:	80 00       	ld.sh	r0,r0[0x0]
80004ff6:	3f 44       	mov	r4,-12
80004ff8:	00 00       	add	r0,r0
80004ffa:	0d 10       	ld.sh	r0,r6++
80004ffc:	00 00       	add	r0,r0
80004ffe:	0d 2c       	ld.uh	r12,r6++
80005000:	00 00       	add	r0,r0
80005002:	0c fc       	st.b	--r6,r12
80005004:	00 00       	add	r0,r0
80005006:	0c e4       	st.h	--r6,r4
80005008:	00 00       	add	r0,r0
8000500a:	0d 4c       	ld.w	r12,--r6
8000500c:	00 00       	add	r0,r0
8000500e:	0c 30       	cp.w	r0,r6
80005010:	00 00       	add	r0,r0
80005012:	0c 40       	or	r0,r6
80005014:	00 00       	add	r0,r0
80005016:	0c 34       	cp.w	r4,r6
80005018:	00 00       	add	r0,r0
8000501a:	0c 2c       	rsub	r12,r6
8000501c:	00 00       	add	r0,r0
8000501e:	0d 40       	ld.w	r0,--r6
80005020:	00 00       	add	r0,r0
80005022:	0d 60       	ld.uh	r0,--r6
80005024:	80 00       	ld.sh	r0,r0[0x0]
80005026:	3f 5e       	mov	lr,-11
80005028:	80 00       	ld.sh	r0,r0[0x0]
8000502a:	41 74       	lddsp	r4,sp[0x5c]

8000502c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
8000502c:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
8000502e:	30 09       	mov	r9,0
80005030:	1a d9       	st.w	--sp,r9
80005032:	1a d9       	st.w	--sp,r9
80005034:	1a d9       	st.w	--sp,r9
80005036:	12 98       	mov	r8,r9
80005038:	e0 6a 01 00 	mov	r10,256
8000503c:	48 9b       	lddpc	r11,80005060 <vTaskStartScheduler+0x34>
8000503e:	48 ac       	lddpc	r12,80005064 <vTaskStartScheduler+0x38>
80005040:	f0 1f 00 0a 	mcall	80005068 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80005044:	2f dd       	sub	sp,-12
80005046:	58 1c       	cp.w	r12,1
80005048:	c0 a1       	brne	8000505c <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
8000504a:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
8000504c:	30 19       	mov	r9,1
8000504e:	48 88       	lddpc	r8,8000506c <vTaskStartScheduler+0x40>
80005050:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80005052:	30 09       	mov	r9,0
80005054:	48 78       	lddpc	r8,80005070 <vTaskStartScheduler+0x44>
80005056:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80005058:	f0 1f 00 07 	mcall	80005074 <vTaskStartScheduler+0x48>
8000505c:	d8 02       	popm	pc
8000505e:	00 00       	add	r0,r0
80005060:	80 00       	ld.sh	r0,r0[0x0]
80005062:	bb 18       	ld.d	r8,--sp
80005064:	80 00       	ld.sh	r0,r0[0x0]
80005066:	4d bc       	lddpc	r12,800051d0 <PrintDec+0xa2>
80005068:	80 00       	ld.sh	r0,r0[0x0]
8000506a:	4e 44       	lddpc	r4,800051f8 <PrintDec+0xca>
8000506c:	00 00       	add	r0,r0
8000506e:	0c 34       	cp.w	r4,r6
80005070:	00 00       	add	r0,r0
80005072:	0d 24       	ld.uh	r4,r6++
80005074:	80 00       	ld.sh	r0,r0[0x0]
80005076:	40 78       	lddsp	r8,sp[0x1c]

80005078 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80005078:	16 cc       	st.b	r11++,r12
	return str;
}
8000507a:	5e fb       	retal	r11

8000507c <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
8000507c:	eb cd 40 c0 	pushm	r6-r7,lr
80005080:	20 3d       	sub	sp,12
80005082:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80005084:	30 06       	mov	r6,0
80005086:	30 07       	mov	r7,0
80005088:	fa e7 00 00 	st.d	sp[0],r6
8000508c:	30 0c       	mov	r12,0
8000508e:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80005090:	58 08       	cp.w	r8,0
80005092:	c1 30       	breq	800050b8 <PrintHex+0x3c>
80005094:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80005096:	1a 9c       	mov	r12,sp
80005098:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
8000509c:	58 9e       	cp.w	lr,9
8000509e:	e0 8a 00 04 	brle	800050a6 <PrintHex+0x2a>
800050a2:	2c 9e       	sub	lr,-55
800050a4:	c0 48       	rjmp	800050ac <PrintHex+0x30>
800050a6:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
800050aa:	2d 0e       	sub	lr,-48
800050ac:	f8 09 0b 0e 	st.b	r12[r9],lr
800050b0:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
800050b2:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
800050b4:	cf 21       	brne	80005098 <PrintHex+0x1c>
800050b6:	c0 48       	rjmp	800050be <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
800050b8:	33 08       	mov	r8,48
800050ba:	ba 88       	st.b	sp[0x0],r8
800050bc:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
800050be:	f6 09 01 08 	sub	r8,r11,r9
800050c2:	58 08       	cp.w	r8,0
800050c4:	e0 8a 00 13 	brle	800050ea <PrintHex+0x6e>
	{
		char num = len - cnt;
800050c8:	12 1b       	sub	r11,r9
800050ca:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
800050ce:	18 9e       	mov	lr,r12
800050d0:	58 0c       	cp.w	r12,0
800050d2:	e0 8a 00 0c 	brle	800050ea <PrintHex+0x6e>
800050d6:	1a 9b       	mov	r11,sp
800050d8:	12 0b       	add	r11,r9
800050da:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
800050dc:	33 07       	mov	r7,48
800050de:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
800050e0:	2f f8       	sub	r8,-1
800050e2:	1c 38       	cp.w	r8,lr
800050e4:	cf d5       	brlt	800050de <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
800050e6:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
800050ea:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
800050ee:	f0 cb ff ff 	sub	r11,r8,-1
800050f2:	58 0b       	cp.w	r11,0
800050f4:	e0 8a 00 19 	brle	80005126 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
800050f8:	fa cb ff f4 	sub	r11,sp,-12
800050fc:	f6 09 00 09 	add	r9,r11,r9
80005100:	37 8b       	mov	r11,120
80005102:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80005106:	fa c9 ff f4 	sub	r9,sp,-12
8000510a:	10 09       	add	r9,r8
8000510c:	33 0b       	mov	r11,48
8000510e:	f3 6b ff f4 	st.b	r9[-12],r11
80005112:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80005116:	fa ce 00 01 	sub	lr,sp,1
8000511a:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
8000511c:	11 8b       	ld.ub	r11,r8[0x0]
8000511e:	12 cb       	st.b	r9++,r11
80005120:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80005122:	1c 38       	cp.w	r8,lr
80005124:	cf c1       	brne	8000511c <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80005126:	14 9c       	mov	r12,r10
80005128:	2f dd       	sub	sp,-12
8000512a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

8000512e <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
8000512e:	d4 21       	pushm	r4-r7,lr
80005130:	20 3d       	sub	sp,12
80005132:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80005134:	30 06       	mov	r6,0
80005136:	30 07       	mov	r7,0
80005138:	fa e7 00 00 	st.d	sp[0],r6
8000513c:	30 0c       	mov	r12,0
8000513e:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80005140:	58 08       	cp.w	r8,0
80005142:	c0 35       	brlt	80005148 <PrintDec+0x1a>
80005144:	14 97       	mov	r7,r10
80005146:	c0 58       	rjmp	80005150 <PrintDec+0x22>
	{
		*p++ = '-';
80005148:	14 97       	mov	r7,r10
8000514a:	32 d9       	mov	r9,45
8000514c:	0e c9       	st.b	r7++,r9
		i = -i;
8000514e:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80005150:	58 08       	cp.w	r8,0
80005152:	c0 51       	brne	8000515c <PrintDec+0x2e>
80005154:	33 08       	mov	r8,48
80005156:	ba 88       	st.b	sp[0x0],r8
80005158:	30 1e       	mov	lr,1
8000515a:	c2 f8       	rjmp	800051b8 <PrintDec+0x8a>
	
	int ten = i%10;
8000515c:	e0 65 66 67 	mov	r5,26215
80005160:	ea 15 66 66 	orh	r5,0x6666
80005164:	f0 05 04 44 	muls.d	r4,r8,r5
80005168:	ea 0c 14 02 	asr	r12,r5,0x2
8000516c:	f0 09 14 1f 	asr	r9,r8,0x1f
80005170:	f8 09 01 09 	sub	r9,r12,r9
80005174:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005178:	f0 09 01 19 	sub	r9,r8,r9<<0x1
8000517c:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
8000517e:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80005180:	e0 66 66 67 	mov	r6,26215
80005184:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80005188:	2d 09       	sub	r9,-48
8000518a:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
8000518e:	2f fe       	sub	lr,-1
		i /= 10;
80005190:	f0 06 04 44 	muls.d	r4,r8,r6
80005194:	ea 09 14 02 	asr	r9,r5,0x2
80005198:	bf 58       	asr	r8,0x1f
8000519a:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
8000519e:	f0 06 04 44 	muls.d	r4,r8,r6
800051a2:	ea 09 14 02 	asr	r9,r5,0x2
800051a6:	f0 05 14 1f 	asr	r5,r8,0x1f
800051aa:	0a 19       	sub	r9,r5
800051ac:	f2 09 00 29 	add	r9,r9,r9<<0x2
800051b0:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
800051b4:	58 08       	cp.w	r8,0
800051b6:	ce 91       	brne	80005188 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
800051b8:	f6 0e 01 08 	sub	r8,r11,lr
800051bc:	58 08       	cp.w	r8,0
800051be:	e0 89 00 06 	brgt	800051ca <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
800051c2:	58 0e       	cp.w	lr,0
800051c4:	e0 89 00 14 	brgt	800051ec <PrintDec+0xbe>
800051c8:	c1 d8       	rjmp	80005202 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
800051ca:	1c 1b       	sub	r11,lr
800051cc:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
800051ce:	16 9c       	mov	r12,r11
800051d0:	58 0b       	cp.w	r11,0
800051d2:	fe 9a ff f8 	brle	800051c2 <PrintDec+0x94>
800051d6:	1a 99       	mov	r9,sp
800051d8:	1c 09       	add	r9,lr
800051da:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
800051dc:	33 06       	mov	r6,48
800051de:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
800051e0:	2f f8       	sub	r8,-1
800051e2:	18 38       	cp.w	r8,r12
800051e4:	cf d5       	brlt	800051de <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
800051e6:	f6 0e 00 0e 	add	lr,r11,lr
800051ea:	ce cb       	rjmp	800051c2 <PrintDec+0x94>
800051ec:	fa c8 ff f4 	sub	r8,sp,-12
800051f0:	1c 08       	add	r8,lr
800051f2:	20 d8       	sub	r8,13
800051f4:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
800051f8:	11 89       	ld.ub	r9,r8[0x0]
800051fa:	0e c9       	st.b	r7++,r9
800051fc:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
800051fe:	16 38       	cp.w	r8,r11
80005200:	cf c1       	brne	800051f8 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80005202:	14 9c       	mov	r12,r10
80005204:	2f dd       	sub	sp,-12
80005206:	d8 22       	popm	r4-r7,pc

80005208 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80005208:	d4 31       	pushm	r0-r7,lr
8000520a:	fa cd 02 08 	sub	sp,sp,520
8000520e:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80005210:	e0 6a 01 00 	mov	r10,256
80005214:	30 0b       	mov	r11,0
80005216:	fa cc fe f8 	sub	r12,sp,-264
8000521a:	f0 1f 00 4e 	mcall	80005350 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
8000521e:	fa c4 fd d4 	sub	r4,sp,-556
80005222:	30 0a       	mov	r10,0
80005224:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005226:	fa c3 ff fc 	sub	r3,sp,-4
8000522a:	e0 61 01 00 	mov	r1,256
8000522e:	14 90       	mov	r0,r10
			
					if(*str == '%')
80005230:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80005232:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005236:	02 9a       	mov	r10,r1
80005238:	00 9b       	mov	r11,r0
8000523a:	06 9c       	mov	r12,r3
8000523c:	f0 1f 00 45 	mcall	80005350 <log+0x148>
			
					if(*str == '%')
80005240:	0f 88       	ld.ub	r8,r7[0x0]
80005242:	e4 08 18 00 	cp.b	r8,r2
80005246:	c5 71       	brne	800052f4 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80005248:	ee c8 ff ff 	sub	r8,r7,-1
8000524c:	11 89       	ld.ub	r9,r8[0x0]
8000524e:	4c 2a       	lddpc	r10,80005354 <log+0x14c>
80005250:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80005252:	23 09       	sub	r9,48
80005254:	30 9a       	mov	r10,9
80005256:	f4 09 18 00 	cp.b	r9,r10
8000525a:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
8000525e:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80005262:	f7 b9 08 30 	subls	r9,48
80005266:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
8000526a:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
8000526e:	0f 88       	ld.ub	r8,r7[0x0]
80005270:	22 58       	sub	r8,37
80005272:	e0 48 00 53 	cp.w	r8,83
80005276:	e0 8b 00 31 	brhi	800052d8 <log+0xd0>
8000527a:	4b 89       	lddpc	r9,80005358 <log+0x150>
8000527c:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80005280:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80005284:	06 9a       	mov	r10,r3
80005286:	40 0b       	lddsp	r11,sp[0x0]
80005288:	5c 5b       	castu.b	r11
8000528a:	68 0c       	ld.w	r12,r4[0x0]
8000528c:	f0 1f 00 34 	mcall	8000535c <log+0x154>
							break;
80005290:	c2 98       	rjmp	800052e2 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80005292:	4b 4c       	lddpc	r12,80005360 <log+0x158>
80005294:	f0 1f 00 34 	mcall	80005364 <log+0x15c>
80005298:	08 95       	mov	r5,r4
8000529a:	06 9c       	mov	r12,r3
							break;
8000529c:	c2 38       	rjmp	800052e2 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
8000529e:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
800052a2:	06 9a       	mov	r10,r3
800052a4:	40 0b       	lddsp	r11,sp[0x0]
800052a6:	5c 5b       	castu.b	r11
800052a8:	68 0c       	ld.w	r12,r4[0x0]
800052aa:	f0 1f 00 30 	mcall	80005368 <log+0x160>
800052ae:	06 9c       	mov	r12,r3
							break;
800052b0:	c1 98       	rjmp	800052e2 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
800052b2:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
800052b6:	06 9b       	mov	r11,r3
800052b8:	09 bc       	ld.ub	r12,r4[0x3]
800052ba:	f0 1f 00 2d 	mcall	8000536c <log+0x164>
800052be:	06 9c       	mov	r12,r3
							break;
800052c0:	c1 18       	rjmp	800052e2 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
800052c2:	e8 c5 ff fc 	sub	r5,r4,-4
800052c6:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
800052c8:	c0 d8       	rjmp	800052e2 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
800052ca:	06 9b       	mov	r11,r3
800052cc:	32 5c       	mov	r12,37
800052ce:	f0 1f 00 28 	mcall	8000536c <log+0x164>
800052d2:	08 95       	mov	r5,r4
800052d4:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
800052d6:	c0 68       	rjmp	800052e2 <log+0xda>
							
							default:
							log("I need relax.");
800052d8:	4a 6c       	lddpc	r12,80005370 <log+0x168>
800052da:	f0 1f 00 23 	mcall	80005364 <log+0x15c>
800052de:	08 95       	mov	r5,r4
800052e0:	06 9c       	mov	r12,r3
						}
						str++;
800052e2:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800052e4:	1a dc       	st.w	--sp,r12
800052e6:	1a d6       	st.w	--sp,r6
800052e8:	4a 3b       	lddpc	r11,80005374 <log+0x16c>
800052ea:	0c 9c       	mov	r12,r6
800052ec:	f0 1f 00 23 	mcall	80005378 <log+0x170>
800052f0:	2f ed       	sub	sp,-8
800052f2:	c0 a8       	rjmp	80005306 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800052f4:	2f f7       	sub	r7,-1
800052f6:	1a d8       	st.w	--sp,r8
800052f8:	1a d6       	st.w	--sp,r6
800052fa:	4a 1b       	lddpc	r11,8000537c <log+0x174>
800052fc:	0c 9c       	mov	r12,r6
800052fe:	f0 1f 00 1f 	mcall	80005378 <log+0x170>
80005302:	08 95       	mov	r5,r4
80005304:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80005306:	0f 89       	ld.ub	r9,r7[0x0]
80005308:	30 08       	mov	r8,0
8000530a:	f0 09 18 00 	cp.b	r9,r8
8000530e:	c0 30       	breq	80005314 <log+0x10c>
80005310:	0a 94       	mov	r4,r5
80005312:	c9 2b       	rjmp	80005236 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80005314:	fa c7 fe f8 	sub	r7,sp,-264
80005318:	1a d7       	st.w	--sp,r7
8000531a:	49 ab       	lddpc	r11,80005380 <log+0x178>
8000531c:	0e 9c       	mov	r12,r7
8000531e:	f0 1f 00 17 	mcall	80005378 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80005322:	5c 5c       	castu.b	r12
80005324:	f8 c6 ff ff 	sub	r6,r12,-1
80005328:	0c 9c       	mov	r12,r6
8000532a:	f0 1f 00 17 	mcall	80005384 <log+0x17c>
8000532e:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80005330:	0c 9a       	mov	r10,r6
80005332:	0e 9b       	mov	r11,r7
80005334:	f0 1f 00 15 	mcall	80005388 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80005338:	30 09       	mov	r9,0
8000533a:	30 5a       	mov	r10,5
8000533c:	fa cb fe f8 	sub	r11,sp,-264
80005340:	49 38       	lddpc	r8,8000538c <log+0x184>
80005342:	70 0c       	ld.w	r12,r8[0x0]
80005344:	f0 1f 00 13 	mcall	80005390 <log+0x188>
80005348:	2f fd       	sub	sp,-4
	
	
}
8000534a:	fe 3d fd f8 	sub	sp,-520
8000534e:	d8 32       	popm	r0-r7,pc
80005350:	80 00       	ld.sh	r0,r0[0x0]
80005352:	5b d8       	cp.w	r8,-3
80005354:	00 00       	add	r0,r0
80005356:	0d 64       	ld.uh	r4,--r6
80005358:	80 00       	ld.sh	r0,r0[0x0]
8000535a:	bb 20       	st.d	sp++,r0
8000535c:	80 00       	ld.sh	r0,r0[0x0]
8000535e:	51 2e       	stdsp	sp[0x48],lr
80005360:	80 00       	ld.sh	r0,r0[0x0]
80005362:	bd cc       	cbr	r12,0x1c
80005364:	80 00       	ld.sh	r0,r0[0x0]
80005366:	52 08       	stdsp	sp[0x80],r8
80005368:	80 00       	ld.sh	r0,r0[0x0]
8000536a:	50 7c       	stdsp	sp[0x1c],r12
8000536c:	80 00       	ld.sh	r0,r0[0x0]
8000536e:	50 78       	stdsp	sp[0x1c],r8
80005370:	80 00       	ld.sh	r0,r0[0x0]
80005372:	bd dc       	cbr	r12,0x1d
80005374:	80 00       	ld.sh	r0,r0[0x0]
80005376:	bd ec       	*unknown*
80005378:	80 00       	ld.sh	r0,r0[0x0]
8000537a:	5e c8       	retvs	r8
8000537c:	80 00       	ld.sh	r0,r0[0x0]
8000537e:	bd f4       	*unknown*
80005380:	80 00       	ld.sh	r0,r0[0x0]
80005382:	bd fc       	*unknown*
80005384:	80 00       	ld.sh	r0,r0[0x0]
80005386:	42 d4       	lddsp	r4,sp[0xb4]
80005388:	80 00       	ld.sh	r0,r0[0x0]
8000538a:	5a 90       	cp.w	r0,-23
8000538c:	00 00       	add	r0,r0
8000538e:	51 44       	stdsp	sp[0x50],r4
80005390:	80 00       	ld.sh	r0,r0[0x0]
80005392:	46 28       	lddsp	r8,sp[0x188]

80005394 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80005394:	d4 31       	pushm	r0-r7,lr
80005396:	fa cd 02 0c 	sub	sp,sp,524
8000539a:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
8000539c:	e0 6a 01 00 	mov	r10,256
800053a0:	30 0b       	mov	r11,0
800053a2:	fa cc fe f4 	sub	r12,sp,-268
800053a6:	f0 1f 00 4c 	mcall	800054d4 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
800053aa:	fa c4 fd d0 	sub	r4,sp,-560
800053ae:	30 0a       	mov	r10,0
800053b0:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800053b2:	fa c3 ff fc 	sub	r3,sp,-4
800053b6:	e0 61 01 00 	mov	r1,256
800053ba:	14 90       	mov	r0,r10
			
			if(*str == '%')
800053bc:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800053be:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800053c2:	02 9a       	mov	r10,r1
800053c4:	00 9b       	mov	r11,r0
800053c6:	06 9c       	mov	r12,r3
800053c8:	f0 1f 00 43 	mcall	800054d4 <logFromISR+0x140>
			
			if(*str == '%')
800053cc:	0f 88       	ld.ub	r8,r7[0x0]
800053ce:	e4 08 18 00 	cp.b	r8,r2
800053d2:	c5 11       	brne	80005474 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
800053d4:	ee c8 ff ff 	sub	r8,r7,-1
800053d8:	11 89       	ld.ub	r9,r8[0x0]
800053da:	4c 0a       	lddpc	r10,800054d8 <logFromISR+0x144>
800053dc:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
800053de:	23 09       	sub	r9,48
800053e0:	30 9a       	mov	r10,9
800053e2:	f4 09 18 00 	cp.b	r9,r10
800053e6:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
800053ea:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800053ee:	f7 b9 08 30 	subls	r9,48
800053f2:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
800053f6:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
800053fa:	0f 88       	ld.ub	r8,r7[0x0]
800053fc:	22 58       	sub	r8,37
800053fe:	e0 48 00 53 	cp.w	r8,83
80005402:	e0 8b 00 2b 	brhi	80005458 <logFromISR+0xc4>
80005406:	4b 69       	lddpc	r9,800054dc <logFromISR+0x148>
80005408:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
8000540c:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80005410:	06 9a       	mov	r10,r3
80005412:	40 0b       	lddsp	r11,sp[0x0]
80005414:	5c 5b       	castu.b	r11
80005416:	68 0c       	ld.w	r12,r4[0x0]
80005418:	f0 1f 00 32 	mcall	800054e0 <logFromISR+0x14c>
					break;
8000541c:	c2 38       	rjmp	80005462 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
8000541e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80005422:	06 9a       	mov	r10,r3
80005424:	40 0b       	lddsp	r11,sp[0x0]
80005426:	5c 5b       	castu.b	r11
80005428:	68 0c       	ld.w	r12,r4[0x0]
8000542a:	f0 1f 00 2f 	mcall	800054e4 <logFromISR+0x150>
8000542e:	06 9c       	mov	r12,r3
					break;
80005430:	c1 98       	rjmp	80005462 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80005432:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80005436:	06 9b       	mov	r11,r3
80005438:	09 bc       	ld.ub	r12,r4[0x3]
8000543a:	f0 1f 00 2c 	mcall	800054e8 <logFromISR+0x154>
8000543e:	06 9c       	mov	r12,r3
					break;
80005440:	c1 18       	rjmp	80005462 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80005442:	e8 c5 ff fc 	sub	r5,r4,-4
80005446:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80005448:	c0 d8       	rjmp	80005462 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
8000544a:	06 9b       	mov	r11,r3
8000544c:	32 5c       	mov	r12,37
8000544e:	f0 1f 00 27 	mcall	800054e8 <logFromISR+0x154>
80005452:	08 95       	mov	r5,r4
80005454:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80005456:	c0 68       	rjmp	80005462 <logFromISR+0xce>
					default:
					log("I need relax.");
80005458:	4a 5c       	lddpc	r12,800054ec <logFromISR+0x158>
8000545a:	f0 1f 00 26 	mcall	800054f0 <logFromISR+0x15c>
8000545e:	08 95       	mov	r5,r4
80005460:	06 9c       	mov	r12,r3
				}
				str++;
80005462:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80005464:	1a dc       	st.w	--sp,r12
80005466:	1a d6       	st.w	--sp,r6
80005468:	4a 3b       	lddpc	r11,800054f4 <logFromISR+0x160>
8000546a:	0c 9c       	mov	r12,r6
8000546c:	f0 1f 00 23 	mcall	800054f8 <logFromISR+0x164>
80005470:	2f ed       	sub	sp,-8
80005472:	c0 a8       	rjmp	80005486 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80005474:	2f f7       	sub	r7,-1
80005476:	1a d8       	st.w	--sp,r8
80005478:	1a d6       	st.w	--sp,r6
8000547a:	4a 1b       	lddpc	r11,800054fc <logFromISR+0x168>
8000547c:	0c 9c       	mov	r12,r6
8000547e:	f0 1f 00 1f 	mcall	800054f8 <logFromISR+0x164>
80005482:	08 95       	mov	r5,r4
80005484:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80005486:	0f 89       	ld.ub	r9,r7[0x0]
80005488:	30 08       	mov	r8,0
8000548a:	f0 09 18 00 	cp.b	r9,r8
8000548e:	c0 30       	breq	80005494 <logFromISR+0x100>
80005490:	0a 94       	mov	r4,r5
80005492:	c9 8b       	rjmp	800053c2 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80005494:	fa c7 fe f4 	sub	r7,sp,-268
80005498:	1a d7       	st.w	--sp,r7
8000549a:	49 ab       	lddpc	r11,80005500 <logFromISR+0x16c>
8000549c:	0e 9c       	mov	r12,r7
8000549e:	f0 1f 00 17 	mcall	800054f8 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
800054a2:	5c 5c       	castu.b	r12
800054a4:	f8 c6 ff ff 	sub	r6,r12,-1
800054a8:	0c 9c       	mov	r12,r6
800054aa:	f0 1f 00 17 	mcall	80005504 <logFromISR+0x170>
800054ae:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
800054b0:	0c 9a       	mov	r10,r6
800054b2:	0e 9b       	mov	r11,r7
800054b4:	f0 1f 00 15 	mcall	80005508 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800054b8:	30 09       	mov	r9,0
800054ba:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
800054bc:	fa ca fe f8 	sub	r10,sp,-264
800054c0:	fa cb fe f4 	sub	r11,sp,-268
800054c4:	49 28       	lddpc	r8,8000550c <logFromISR+0x178>
800054c6:	70 0c       	ld.w	r12,r8[0x0]
800054c8:	f0 1f 00 12 	mcall	80005510 <logFromISR+0x17c>
800054cc:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
800054ce:	fe 3d fd f4 	sub	sp,-524
800054d2:	d8 32       	popm	r0-r7,pc
800054d4:	80 00       	ld.sh	r0,r0[0x0]
800054d6:	5b d8       	cp.w	r8,-3
800054d8:	00 00       	add	r0,r0
800054da:	0d 65       	ld.uh	r5,--r6
800054dc:	80 00       	ld.sh	r0,r0[0x0]
800054de:	bc 70       	st.h	lr[0xe],r0
800054e0:	80 00       	ld.sh	r0,r0[0x0]
800054e2:	51 2e       	stdsp	sp[0x48],lr
800054e4:	80 00       	ld.sh	r0,r0[0x0]
800054e6:	50 7c       	stdsp	sp[0x1c],r12
800054e8:	80 00       	ld.sh	r0,r0[0x0]
800054ea:	50 78       	stdsp	sp[0x1c],r8
800054ec:	80 00       	ld.sh	r0,r0[0x0]
800054ee:	bd dc       	cbr	r12,0x1d
800054f0:	80 00       	ld.sh	r0,r0[0x0]
800054f2:	52 08       	stdsp	sp[0x80],r8
800054f4:	80 00       	ld.sh	r0,r0[0x0]
800054f6:	bd ec       	*unknown*
800054f8:	80 00       	ld.sh	r0,r0[0x0]
800054fa:	5e c8       	retvs	r8
800054fc:	80 00       	ld.sh	r0,r0[0x0]
800054fe:	bd f4       	*unknown*
80005500:	80 00       	ld.sh	r0,r0[0x0]
80005502:	bd fc       	*unknown*
80005504:	80 00       	ld.sh	r0,r0[0x0]
80005506:	42 d4       	lddsp	r4,sp[0xb4]
80005508:	80 00       	ld.sh	r0,r0[0x0]
8000550a:	5a 90       	cp.w	r0,-23
8000550c:	00 00       	add	r0,r0
8000550e:	51 44       	stdsp	sp[0x50],r4
80005510:	80 00       	ld.sh	r0,r0[0x0]
80005512:	45 d8       	lddsp	r8,sp[0x174]

80005514 <log_init>:
		
	return str;
}

void log_init(void)
{
80005514:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80005516:	30 2b       	mov	r11,2
80005518:	49 0c       	lddpc	r12,80005558 <log_init+0x44>
8000551a:	f0 1f 00 11 	mcall	8000555c <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
8000551e:	e0 6a 36 00 	mov	r10,13824
80005522:	ea 1a 01 6e 	orh	r10,0x16e
80005526:	48 fb       	lddpc	r11,80005560 <log_init+0x4c>
80005528:	fe 7c 18 00 	mov	r12,-59392
8000552c:	f0 1f 00 0e 	mcall	80005564 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80005530:	30 4b       	mov	r11,4
80005532:	33 2c       	mov	r12,50
80005534:	f0 1f 00 0d 	mcall	80005568 <log_init+0x54>
80005538:	48 d8       	lddpc	r8,8000556c <log_init+0x58>
8000553a:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
8000553c:	30 09       	mov	r9,0
8000553e:	1a d9       	st.w	--sp,r9
80005540:	1a d9       	st.w	--sp,r9
80005542:	1a d9       	st.w	--sp,r9
80005544:	30 28       	mov	r8,2
80005546:	e0 6a 01 80 	mov	r10,384
8000554a:	48 ab       	lddpc	r11,80005570 <log_init+0x5c>
8000554c:	48 ac       	lddpc	r12,80005574 <log_init+0x60>
8000554e:	f0 1f 00 0b 	mcall	80005578 <log_init+0x64>
80005552:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80005554:	d8 02       	popm	pc
80005556:	00 00       	add	r0,r0
80005558:	80 00       	ld.sh	r0,r0[0x0]
8000555a:	be 08       	st.h	pc[0x0],r8
8000555c:	80 00       	ld.sh	r0,r0[0x0]
8000555e:	37 94       	mov	r4,121
80005560:	80 00       	ld.sh	r0,r0[0x0]
80005562:	bd c0       	cbr	r0,0x1c
80005564:	80 00       	ld.sh	r0,r0[0x0]
80005566:	3e 38       	mov	r8,-29
80005568:	80 00       	ld.sh	r0,r0[0x0]
8000556a:	47 28       	lddsp	r8,sp[0x1c8]
8000556c:	00 00       	add	r0,r0
8000556e:	51 44       	stdsp	sp[0x50],r4
80005570:	80 00       	ld.sh	r0,r0[0x0]
80005572:	be 04       	st.h	pc[0x0],r4
80005574:	80 00       	ld.sh	r0,r0[0x0]
80005576:	55 7c       	stdsp	sp[0x15c],r12
80005578:	80 00       	ld.sh	r0,r0[0x0]
8000557a:	4e 44       	lddpc	r4,80005708 <_malloc_r+0xb0>

8000557c <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
8000557c:	eb cd 40 f8 	pushm	r3-r7,lr
80005580:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80005582:	48 c7       	lddpc	r7,800055b0 <task_log+0x34>
80005584:	30 05       	mov	r5,0
80005586:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80005588:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000558c:	0a 99       	mov	r9,r5
8000558e:	08 9a       	mov	r10,r4
80005590:	1a 9b       	mov	r11,sp
80005592:	6e 0c       	ld.w	r12,r7[0x0]
80005594:	f0 1f 00 08 	mcall	800055b4 <task_log+0x38>
80005598:	58 1c       	cp.w	r12,1
8000559a:	cf 91       	brne	8000558c <task_log+0x10>
		{
			if( NULL != str)
8000559c:	40 0b       	lddsp	r11,sp[0x0]
8000559e:	58 0b       	cp.w	r11,0
800055a0:	cf 60       	breq	8000558c <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
800055a2:	06 9c       	mov	r12,r3
800055a4:	f0 1f 00 05 	mcall	800055b8 <task_log+0x3c>
				vPortFree(str);
800055a8:	40 0c       	lddsp	r12,sp[0x0]
800055aa:	f0 1f 00 05 	mcall	800055bc <task_log+0x40>
800055ae:	ce fb       	rjmp	8000558c <task_log+0x10>
800055b0:	00 00       	add	r0,r0
800055b2:	51 44       	stdsp	sp[0x50],r4
800055b4:	80 00       	ld.sh	r0,r0[0x0]
800055b6:	44 1c       	lddsp	r12,sp[0x104]
800055b8:	80 00       	ld.sh	r0,r0[0x0]
800055ba:	3d e8       	mov	r8,-34
800055bc:	80 00       	ld.sh	r0,r0[0x0]
800055be:	42 ac       	lddsp	r12,sp[0xa8]

800055c0 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
800055c0:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
800055c2:	fe 78 10 00 	mov	r8,-61440
800055c6:	30 19       	mov	r9,1
800055c8:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
800055cc:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
800055d0:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
800055d4:	d3 03       	ssrf	0x10
	local_start_pll0();
800055d6:	f0 1f 00 0d 	mcall	80005608 <main+0x48>
		
	INTC_init_interrupts();
800055da:	f0 1f 00 0d 	mcall	8000560c <main+0x4c>
		
	log_init();
800055de:	f0 1f 00 0d 	mcall	80005610 <main+0x50>
	log("----start debug----");
800055e2:	48 dc       	lddpc	r12,80005614 <main+0x54>
800055e4:	f0 1f 00 0d 	mcall	80005618 <main+0x58>
	
	xg_flashc_init();
800055e8:	f0 1f 00 0d 	mcall	8000561c <main+0x5c>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
800055ec:	f0 1f 00 0d 	mcall	80005620 <main+0x60>
		
	app_init();
800055f0:	f0 1f 00 0d 	mcall	80005624 <main+0x64>
		
	xcmp_init();
800055f4:	f0 1f 00 0d 	mcall	80005628 <main+0x68>

	local_start_timer();
800055f8:	f0 1f 00 0d 	mcall	8000562c <main+0x6c>
	
	xg_rtc_init();
800055fc:	f0 1f 00 0d 	mcall	80005630 <main+0x70>
		
	vTaskStartScheduler();
80005600:	f0 1f 00 0d 	mcall	80005634 <main+0x74>
	return 0;
	
}
80005604:	d8 0a       	popm	pc,r12=0
80005606:	00 00       	add	r0,r0
80005608:	80 00       	ld.sh	r0,r0[0x0]
8000560a:	31 88       	mov	r8,24
8000560c:	80 00       	ld.sh	r0,r0[0x0]
8000560e:	38 98       	mov	r8,-119
80005610:	80 00       	ld.sh	r0,r0[0x0]
80005612:	55 14       	stdsp	sp[0x144],r4
80005614:	80 00       	ld.sh	r0,r0[0x0]
80005616:	be 18       	st.h	pc[0x2],r8
80005618:	80 00       	ld.sh	r0,r0[0x0]
8000561a:	52 08       	stdsp	sp[0x80],r8
8000561c:	80 00       	ld.sh	r0,r0[0x0]
8000561e:	32 6c       	mov	r12,38
80005620:	80 00       	ld.sh	r0,r0[0x0]
80005622:	31 7c       	mov	r12,23
80005624:	80 00       	ld.sh	r0,r0[0x0]
80005626:	00 5c       	eor	r12,r0
80005628:	80 00       	ld.sh	r0,r0[0x0]
8000562a:	20 a0       	sub	r0,10
8000562c:	80 00       	ld.sh	r0,r0[0x0]
8000562e:	32 40       	mov	r0,36
80005630:	80 00       	ld.sh	r0,r0[0x0]
80005632:	09 28       	ld.uh	r8,r4++
80005634:	80 00       	ld.sh	r0,r0[0x0]
80005636:	50 2c       	stdsp	sp[0x8],r12

80005638 <free>:
80005638:	d4 01       	pushm	lr
8000563a:	e0 68 0a 40 	mov	r8,2624
8000563e:	18 9b       	mov	r11,r12
80005640:	70 0c       	ld.w	r12,r8[0x0]
80005642:	e0 a0 1e 61 	rcall	80009304 <_free_r>
80005646:	d8 02       	popm	pc

80005648 <malloc>:
80005648:	d4 01       	pushm	lr
8000564a:	e0 68 0a 40 	mov	r8,2624
8000564e:	18 9b       	mov	r11,r12
80005650:	70 0c       	ld.w	r12,r8[0x0]
80005652:	c0 3c       	rcall	80005658 <_malloc_r>
80005654:	d8 02       	popm	pc
80005656:	d7 03       	nop

80005658 <_malloc_r>:
80005658:	d4 31       	pushm	r0-r7,lr
8000565a:	f6 c8 ff f5 	sub	r8,r11,-11
8000565e:	18 95       	mov	r5,r12
80005660:	10 97       	mov	r7,r8
80005662:	e0 17 ff f8 	andl	r7,0xfff8
80005666:	59 68       	cp.w	r8,22
80005668:	f9 b7 08 10 	movls	r7,16
8000566c:	16 37       	cp.w	r7,r11
8000566e:	5f 38       	srlo	r8
80005670:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80005674:	c0 50       	breq	8000567e <_malloc_r+0x26>
80005676:	30 c8       	mov	r8,12
80005678:	99 38       	st.w	r12[0xc],r8
8000567a:	e0 8f 01 fa 	bral	80005a6e <_malloc_r+0x416>
8000567e:	fe b0 f5 cd 	rcall	80004218 <__malloc_lock>
80005682:	e0 47 01 f7 	cp.w	r7,503
80005686:	e0 8b 00 1d 	brhi	800056c0 <_malloc_r+0x68>
8000568a:	ee 03 16 03 	lsr	r3,r7,0x3
8000568e:	e0 68 05 40 	mov	r8,1344
80005692:	f0 03 00 38 	add	r8,r8,r3<<0x3
80005696:	70 36       	ld.w	r6,r8[0xc]
80005698:	10 36       	cp.w	r6,r8
8000569a:	c0 61       	brne	800056a6 <_malloc_r+0x4e>
8000569c:	ec c8 ff f8 	sub	r8,r6,-8
800056a0:	70 36       	ld.w	r6,r8[0xc]
800056a2:	10 36       	cp.w	r6,r8
800056a4:	c0 c0       	breq	800056bc <_malloc_r+0x64>
800056a6:	6c 18       	ld.w	r8,r6[0x4]
800056a8:	e0 18 ff fc 	andl	r8,0xfffc
800056ac:	6c 3a       	ld.w	r10,r6[0xc]
800056ae:	ec 08 00 09 	add	r9,r6,r8
800056b2:	0a 9c       	mov	r12,r5
800056b4:	6c 28       	ld.w	r8,r6[0x8]
800056b6:	95 28       	st.w	r10[0x8],r8
800056b8:	91 3a       	st.w	r8[0xc],r10
800056ba:	c4 78       	rjmp	80005748 <_malloc_r+0xf0>
800056bc:	2f e3       	sub	r3,-2
800056be:	c4 d8       	rjmp	80005758 <_malloc_r+0x100>
800056c0:	ee 03 16 09 	lsr	r3,r7,0x9
800056c4:	c0 41       	brne	800056cc <_malloc_r+0x74>
800056c6:	ee 03 16 03 	lsr	r3,r7,0x3
800056ca:	c2 68       	rjmp	80005716 <_malloc_r+0xbe>
800056cc:	58 43       	cp.w	r3,4
800056ce:	e0 8b 00 06 	brhi	800056da <_malloc_r+0x82>
800056d2:	ee 03 16 06 	lsr	r3,r7,0x6
800056d6:	2c 83       	sub	r3,-56
800056d8:	c1 f8       	rjmp	80005716 <_malloc_r+0xbe>
800056da:	59 43       	cp.w	r3,20
800056dc:	e0 8b 00 04 	brhi	800056e4 <_malloc_r+0x8c>
800056e0:	2a 53       	sub	r3,-91
800056e2:	c1 a8       	rjmp	80005716 <_malloc_r+0xbe>
800056e4:	e0 43 00 54 	cp.w	r3,84
800056e8:	e0 8b 00 06 	brhi	800056f4 <_malloc_r+0x9c>
800056ec:	ee 03 16 0c 	lsr	r3,r7,0xc
800056f0:	29 23       	sub	r3,-110
800056f2:	c1 28       	rjmp	80005716 <_malloc_r+0xbe>
800056f4:	e0 43 01 54 	cp.w	r3,340
800056f8:	e0 8b 00 06 	brhi	80005704 <_malloc_r+0xac>
800056fc:	ee 03 16 0f 	lsr	r3,r7,0xf
80005700:	28 93       	sub	r3,-119
80005702:	c0 a8       	rjmp	80005716 <_malloc_r+0xbe>
80005704:	e0 43 05 54 	cp.w	r3,1364
80005708:	e0 88 00 04 	brls	80005710 <_malloc_r+0xb8>
8000570c:	37 e3       	mov	r3,126
8000570e:	c0 48       	rjmp	80005716 <_malloc_r+0xbe>
80005710:	ee 03 16 12 	lsr	r3,r7,0x12
80005714:	28 43       	sub	r3,-124
80005716:	e0 6a 05 40 	mov	r10,1344
8000571a:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000571e:	74 36       	ld.w	r6,r10[0xc]
80005720:	c1 98       	rjmp	80005752 <_malloc_r+0xfa>
80005722:	6c 19       	ld.w	r9,r6[0x4]
80005724:	e0 19 ff fc 	andl	r9,0xfffc
80005728:	f2 07 01 0b 	sub	r11,r9,r7
8000572c:	58 fb       	cp.w	r11,15
8000572e:	e0 8a 00 04 	brle	80005736 <_malloc_r+0xde>
80005732:	20 13       	sub	r3,1
80005734:	c1 18       	rjmp	80005756 <_malloc_r+0xfe>
80005736:	6c 38       	ld.w	r8,r6[0xc]
80005738:	58 0b       	cp.w	r11,0
8000573a:	c0 b5       	brlt	80005750 <_malloc_r+0xf8>
8000573c:	6c 2a       	ld.w	r10,r6[0x8]
8000573e:	ec 09 00 09 	add	r9,r6,r9
80005742:	0a 9c       	mov	r12,r5
80005744:	91 2a       	st.w	r8[0x8],r10
80005746:	95 38       	st.w	r10[0xc],r8
80005748:	72 18       	ld.w	r8,r9[0x4]
8000574a:	a1 a8       	sbr	r8,0x0
8000574c:	93 18       	st.w	r9[0x4],r8
8000574e:	cb c8       	rjmp	800058c6 <_malloc_r+0x26e>
80005750:	10 96       	mov	r6,r8
80005752:	14 36       	cp.w	r6,r10
80005754:	ce 71       	brne	80005722 <_malloc_r+0xca>
80005756:	2f f3       	sub	r3,-1
80005758:	e0 6a 05 40 	mov	r10,1344
8000575c:	f4 cc ff f8 	sub	r12,r10,-8
80005760:	78 26       	ld.w	r6,r12[0x8]
80005762:	18 36       	cp.w	r6,r12
80005764:	c6 c0       	breq	8000583c <_malloc_r+0x1e4>
80005766:	6c 19       	ld.w	r9,r6[0x4]
80005768:	e0 19 ff fc 	andl	r9,0xfffc
8000576c:	f2 07 01 08 	sub	r8,r9,r7
80005770:	58 f8       	cp.w	r8,15
80005772:	e0 89 00 8f 	brgt	80005890 <_malloc_r+0x238>
80005776:	99 3c       	st.w	r12[0xc],r12
80005778:	99 2c       	st.w	r12[0x8],r12
8000577a:	58 08       	cp.w	r8,0
8000577c:	c0 55       	brlt	80005786 <_malloc_r+0x12e>
8000577e:	ec 09 00 09 	add	r9,r6,r9
80005782:	0a 9c       	mov	r12,r5
80005784:	ce 2b       	rjmp	80005748 <_malloc_r+0xf0>
80005786:	e0 49 01 ff 	cp.w	r9,511
8000578a:	e0 8b 00 13 	brhi	800057b0 <_malloc_r+0x158>
8000578e:	a3 99       	lsr	r9,0x3
80005790:	f4 09 00 38 	add	r8,r10,r9<<0x3
80005794:	70 2b       	ld.w	r11,r8[0x8]
80005796:	8d 38       	st.w	r6[0xc],r8
80005798:	8d 2b       	st.w	r6[0x8],r11
8000579a:	97 36       	st.w	r11[0xc],r6
8000579c:	91 26       	st.w	r8[0x8],r6
8000579e:	a3 49       	asr	r9,0x2
800057a0:	74 18       	ld.w	r8,r10[0x4]
800057a2:	30 1b       	mov	r11,1
800057a4:	f6 09 09 49 	lsl	r9,r11,r9
800057a8:	f1 e9 10 09 	or	r9,r8,r9
800057ac:	95 19       	st.w	r10[0x4],r9
800057ae:	c4 78       	rjmp	8000583c <_malloc_r+0x1e4>
800057b0:	f2 0a 16 09 	lsr	r10,r9,0x9
800057b4:	58 4a       	cp.w	r10,4
800057b6:	e0 8b 00 07 	brhi	800057c4 <_malloc_r+0x16c>
800057ba:	f2 0a 16 06 	lsr	r10,r9,0x6
800057be:	2c 8a       	sub	r10,-56
800057c0:	c2 08       	rjmp	80005800 <_malloc_r+0x1a8>
800057c2:	d7 03       	nop
800057c4:	59 4a       	cp.w	r10,20
800057c6:	e0 8b 00 04 	brhi	800057ce <_malloc_r+0x176>
800057ca:	2a 5a       	sub	r10,-91
800057cc:	c1 a8       	rjmp	80005800 <_malloc_r+0x1a8>
800057ce:	e0 4a 00 54 	cp.w	r10,84
800057d2:	e0 8b 00 06 	brhi	800057de <_malloc_r+0x186>
800057d6:	f2 0a 16 0c 	lsr	r10,r9,0xc
800057da:	29 2a       	sub	r10,-110
800057dc:	c1 28       	rjmp	80005800 <_malloc_r+0x1a8>
800057de:	e0 4a 01 54 	cp.w	r10,340
800057e2:	e0 8b 00 06 	brhi	800057ee <_malloc_r+0x196>
800057e6:	f2 0a 16 0f 	lsr	r10,r9,0xf
800057ea:	28 9a       	sub	r10,-119
800057ec:	c0 a8       	rjmp	80005800 <_malloc_r+0x1a8>
800057ee:	e0 4a 05 54 	cp.w	r10,1364
800057f2:	e0 88 00 04 	brls	800057fa <_malloc_r+0x1a2>
800057f6:	37 ea       	mov	r10,126
800057f8:	c0 48       	rjmp	80005800 <_malloc_r+0x1a8>
800057fa:	f2 0a 16 12 	lsr	r10,r9,0x12
800057fe:	28 4a       	sub	r10,-124
80005800:	e0 6b 05 40 	mov	r11,1344
80005804:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80005808:	68 28       	ld.w	r8,r4[0x8]
8000580a:	08 38       	cp.w	r8,r4
8000580c:	c0 e1       	brne	80005828 <_malloc_r+0x1d0>
8000580e:	76 19       	ld.w	r9,r11[0x4]
80005810:	a3 4a       	asr	r10,0x2
80005812:	30 1e       	mov	lr,1
80005814:	fc 0a 09 4a 	lsl	r10,lr,r10
80005818:	f3 ea 10 0a 	or	r10,r9,r10
8000581c:	10 99       	mov	r9,r8
8000581e:	97 1a       	st.w	r11[0x4],r10
80005820:	c0 a8       	rjmp	80005834 <_malloc_r+0x1dc>
80005822:	70 28       	ld.w	r8,r8[0x8]
80005824:	08 38       	cp.w	r8,r4
80005826:	c0 60       	breq	80005832 <_malloc_r+0x1da>
80005828:	70 1a       	ld.w	r10,r8[0x4]
8000582a:	e0 1a ff fc 	andl	r10,0xfffc
8000582e:	14 39       	cp.w	r9,r10
80005830:	cf 93       	brcs	80005822 <_malloc_r+0x1ca>
80005832:	70 39       	ld.w	r9,r8[0xc]
80005834:	8d 39       	st.w	r6[0xc],r9
80005836:	8d 28       	st.w	r6[0x8],r8
80005838:	91 36       	st.w	r8[0xc],r6
8000583a:	93 26       	st.w	r9[0x8],r6
8000583c:	e6 08 14 02 	asr	r8,r3,0x2
80005840:	30 1b       	mov	r11,1
80005842:	e0 64 05 40 	mov	r4,1344
80005846:	f6 08 09 4b 	lsl	r11,r11,r8
8000584a:	68 18       	ld.w	r8,r4[0x4]
8000584c:	10 3b       	cp.w	r11,r8
8000584e:	e0 8b 00 6b 	brhi	80005924 <_malloc_r+0x2cc>
80005852:	f7 e8 00 09 	and	r9,r11,r8
80005856:	c0 b1       	brne	8000586c <_malloc_r+0x214>
80005858:	e0 13 ff fc 	andl	r3,0xfffc
8000585c:	a1 7b       	lsl	r11,0x1
8000585e:	2f c3       	sub	r3,-4
80005860:	c0 38       	rjmp	80005866 <_malloc_r+0x20e>
80005862:	2f c3       	sub	r3,-4
80005864:	a1 7b       	lsl	r11,0x1
80005866:	f7 e8 00 09 	and	r9,r11,r8
8000586a:	cf c0       	breq	80005862 <_malloc_r+0x20a>
8000586c:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80005870:	06 92       	mov	r2,r3
80005872:	1c 91       	mov	r1,lr
80005874:	62 36       	ld.w	r6,r1[0xc]
80005876:	c2 e8       	rjmp	800058d2 <_malloc_r+0x27a>
80005878:	6c 1a       	ld.w	r10,r6[0x4]
8000587a:	e0 1a ff fc 	andl	r10,0xfffc
8000587e:	f4 07 01 08 	sub	r8,r10,r7
80005882:	58 f8       	cp.w	r8,15
80005884:	e0 8a 00 15 	brle	800058ae <_malloc_r+0x256>
80005888:	6c 3a       	ld.w	r10,r6[0xc]
8000588a:	6c 29       	ld.w	r9,r6[0x8]
8000588c:	95 29       	st.w	r10[0x8],r9
8000588e:	93 3a       	st.w	r9[0xc],r10
80005890:	0e 99       	mov	r9,r7
80005892:	ec 07 00 07 	add	r7,r6,r7
80005896:	a1 a9       	sbr	r9,0x0
80005898:	99 37       	st.w	r12[0xc],r7
8000589a:	99 27       	st.w	r12[0x8],r7
8000589c:	8d 19       	st.w	r6[0x4],r9
8000589e:	ee 08 09 08 	st.w	r7[r8],r8
800058a2:	8f 2c       	st.w	r7[0x8],r12
800058a4:	8f 3c       	st.w	r7[0xc],r12
800058a6:	a1 a8       	sbr	r8,0x0
800058a8:	0a 9c       	mov	r12,r5
800058aa:	8f 18       	st.w	r7[0x4],r8
800058ac:	c0 d8       	rjmp	800058c6 <_malloc_r+0x26e>
800058ae:	6c 39       	ld.w	r9,r6[0xc]
800058b0:	58 08       	cp.w	r8,0
800058b2:	c0 f5       	brlt	800058d0 <_malloc_r+0x278>
800058b4:	ec 0a 00 0a 	add	r10,r6,r10
800058b8:	74 18       	ld.w	r8,r10[0x4]
800058ba:	a1 a8       	sbr	r8,0x0
800058bc:	0a 9c       	mov	r12,r5
800058be:	95 18       	st.w	r10[0x4],r8
800058c0:	6c 28       	ld.w	r8,r6[0x8]
800058c2:	93 28       	st.w	r9[0x8],r8
800058c4:	91 39       	st.w	r8[0xc],r9
800058c6:	fe b0 f4 af 	rcall	80004224 <__malloc_unlock>
800058ca:	ec cc ff f8 	sub	r12,r6,-8
800058ce:	d8 32       	popm	r0-r7,pc
800058d0:	12 96       	mov	r6,r9
800058d2:	02 36       	cp.w	r6,r1
800058d4:	cd 21       	brne	80005878 <_malloc_r+0x220>
800058d6:	2f f2       	sub	r2,-1
800058d8:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800058dc:	c0 30       	breq	800058e2 <_malloc_r+0x28a>
800058de:	2f 81       	sub	r1,-8
800058e0:	cc ab       	rjmp	80005874 <_malloc_r+0x21c>
800058e2:	1c 98       	mov	r8,lr
800058e4:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
800058e8:	c0 81       	brne	800058f8 <_malloc_r+0x2a0>
800058ea:	68 19       	ld.w	r9,r4[0x4]
800058ec:	f6 08 11 ff 	rsub	r8,r11,-1
800058f0:	f3 e8 00 08 	and	r8,r9,r8
800058f4:	89 18       	st.w	r4[0x4],r8
800058f6:	c0 78       	rjmp	80005904 <_malloc_r+0x2ac>
800058f8:	f0 c9 00 08 	sub	r9,r8,8
800058fc:	20 13       	sub	r3,1
800058fe:	70 08       	ld.w	r8,r8[0x0]
80005900:	12 38       	cp.w	r8,r9
80005902:	cf 10       	breq	800058e4 <_malloc_r+0x28c>
80005904:	a1 7b       	lsl	r11,0x1
80005906:	68 18       	ld.w	r8,r4[0x4]
80005908:	10 3b       	cp.w	r11,r8
8000590a:	e0 8b 00 0d 	brhi	80005924 <_malloc_r+0x2cc>
8000590e:	58 0b       	cp.w	r11,0
80005910:	c0 a0       	breq	80005924 <_malloc_r+0x2cc>
80005912:	04 93       	mov	r3,r2
80005914:	c0 38       	rjmp	8000591a <_malloc_r+0x2c2>
80005916:	2f c3       	sub	r3,-4
80005918:	a1 7b       	lsl	r11,0x1
8000591a:	f7 e8 00 09 	and	r9,r11,r8
8000591e:	ca 71       	brne	8000586c <_malloc_r+0x214>
80005920:	cf bb       	rjmp	80005916 <_malloc_r+0x2be>
80005922:	d7 03       	nop
80005924:	68 23       	ld.w	r3,r4[0x8]
80005926:	66 12       	ld.w	r2,r3[0x4]
80005928:	e0 12 ff fc 	andl	r2,0xfffc
8000592c:	0e 32       	cp.w	r2,r7
8000592e:	5f 39       	srlo	r9
80005930:	e4 07 01 08 	sub	r8,r2,r7
80005934:	58 f8       	cp.w	r8,15
80005936:	5f aa       	srle	r10
80005938:	f5 e9 10 09 	or	r9,r10,r9
8000593c:	e0 80 00 9a 	breq	80005a70 <_malloc_r+0x418>
80005940:	e0 68 0d 70 	mov	r8,3440
80005944:	70 01       	ld.w	r1,r8[0x0]
80005946:	e0 68 09 4c 	mov	r8,2380
8000594a:	2f 01       	sub	r1,-16
8000594c:	70 08       	ld.w	r8,r8[0x0]
8000594e:	0e 01       	add	r1,r7
80005950:	5b f8       	cp.w	r8,-1
80005952:	c0 40       	breq	8000595a <_malloc_r+0x302>
80005954:	28 11       	sub	r1,-127
80005956:	e0 11 ff 80 	andl	r1,0xff80
8000595a:	02 9b       	mov	r11,r1
8000595c:	0a 9c       	mov	r12,r5
8000595e:	e0 a0 02 a5 	rcall	80005ea8 <_sbrk_r>
80005962:	18 96       	mov	r6,r12
80005964:	5b fc       	cp.w	r12,-1
80005966:	c7 50       	breq	80005a50 <_malloc_r+0x3f8>
80005968:	e6 02 00 08 	add	r8,r3,r2
8000596c:	10 3c       	cp.w	r12,r8
8000596e:	c0 32       	brcc	80005974 <_malloc_r+0x31c>
80005970:	08 33       	cp.w	r3,r4
80005972:	c6 f1       	brne	80005a50 <_malloc_r+0x3f8>
80005974:	e0 6a 0d 74 	mov	r10,3444
80005978:	74 09       	ld.w	r9,r10[0x0]
8000597a:	e2 09 00 09 	add	r9,r1,r9
8000597e:	95 09       	st.w	r10[0x0],r9
80005980:	10 36       	cp.w	r6,r8
80005982:	c0 a1       	brne	80005996 <_malloc_r+0x33e>
80005984:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80005988:	c0 71       	brne	80005996 <_malloc_r+0x33e>
8000598a:	e2 02 00 02 	add	r2,r1,r2
8000598e:	68 28       	ld.w	r8,r4[0x8]
80005990:	a1 a2       	sbr	r2,0x0
80005992:	91 12       	st.w	r8[0x4],r2
80005994:	c4 f8       	rjmp	80005a32 <_malloc_r+0x3da>
80005996:	e0 6a 09 4c 	mov	r10,2380
8000599a:	74 0b       	ld.w	r11,r10[0x0]
8000599c:	5b fb       	cp.w	r11,-1
8000599e:	c0 31       	brne	800059a4 <_malloc_r+0x34c>
800059a0:	95 06       	st.w	r10[0x0],r6
800059a2:	c0 78       	rjmp	800059b0 <_malloc_r+0x358>
800059a4:	ec 09 00 09 	add	r9,r6,r9
800059a8:	e0 6a 0d 74 	mov	r10,3444
800059ac:	10 19       	sub	r9,r8
800059ae:	95 09       	st.w	r10[0x0],r9
800059b0:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
800059b4:	f0 09 11 08 	rsub	r9,r8,8
800059b8:	58 08       	cp.w	r8,0
800059ba:	f2 08 17 10 	movne	r8,r9
800059be:	ed d8 e1 06 	addne	r6,r6,r8
800059c2:	28 08       	sub	r8,-128
800059c4:	ec 01 00 01 	add	r1,r6,r1
800059c8:	0a 9c       	mov	r12,r5
800059ca:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800059ce:	f0 01 01 01 	sub	r1,r8,r1
800059d2:	02 9b       	mov	r11,r1
800059d4:	e0 a0 02 6a 	rcall	80005ea8 <_sbrk_r>
800059d8:	e0 68 0d 74 	mov	r8,3444
800059dc:	5b fc       	cp.w	r12,-1
800059de:	ec 0c 17 00 	moveq	r12,r6
800059e2:	f9 b1 00 00 	moveq	r1,0
800059e6:	70 09       	ld.w	r9,r8[0x0]
800059e8:	0c 1c       	sub	r12,r6
800059ea:	89 26       	st.w	r4[0x8],r6
800059ec:	02 0c       	add	r12,r1
800059ee:	12 01       	add	r1,r9
800059f0:	a1 ac       	sbr	r12,0x0
800059f2:	91 01       	st.w	r8[0x0],r1
800059f4:	8d 1c       	st.w	r6[0x4],r12
800059f6:	08 33       	cp.w	r3,r4
800059f8:	c1 d0       	breq	80005a32 <_malloc_r+0x3da>
800059fa:	58 f2       	cp.w	r2,15
800059fc:	e0 8b 00 05 	brhi	80005a06 <_malloc_r+0x3ae>
80005a00:	30 18       	mov	r8,1
80005a02:	8d 18       	st.w	r6[0x4],r8
80005a04:	c2 68       	rjmp	80005a50 <_malloc_r+0x3f8>
80005a06:	30 59       	mov	r9,5
80005a08:	20 c2       	sub	r2,12
80005a0a:	e0 12 ff f8 	andl	r2,0xfff8
80005a0e:	e6 02 00 08 	add	r8,r3,r2
80005a12:	91 29       	st.w	r8[0x8],r9
80005a14:	91 19       	st.w	r8[0x4],r9
80005a16:	66 18       	ld.w	r8,r3[0x4]
80005a18:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005a1c:	e5 e8 10 08 	or	r8,r2,r8
80005a20:	87 18       	st.w	r3[0x4],r8
80005a22:	58 f2       	cp.w	r2,15
80005a24:	e0 88 00 07 	brls	80005a32 <_malloc_r+0x3da>
80005a28:	e6 cb ff f8 	sub	r11,r3,-8
80005a2c:	0a 9c       	mov	r12,r5
80005a2e:	e0 a0 1c 6b 	rcall	80009304 <_free_r>
80005a32:	e0 69 0d 6c 	mov	r9,3436
80005a36:	72 0a       	ld.w	r10,r9[0x0]
80005a38:	e0 68 0d 74 	mov	r8,3444
80005a3c:	70 08       	ld.w	r8,r8[0x0]
80005a3e:	14 38       	cp.w	r8,r10
80005a40:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80005a44:	e0 69 0d 68 	mov	r9,3432
80005a48:	72 0a       	ld.w	r10,r9[0x0]
80005a4a:	14 38       	cp.w	r8,r10
80005a4c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80005a50:	68 28       	ld.w	r8,r4[0x8]
80005a52:	70 18       	ld.w	r8,r8[0x4]
80005a54:	e0 18 ff fc 	andl	r8,0xfffc
80005a58:	0e 38       	cp.w	r8,r7
80005a5a:	5f 39       	srlo	r9
80005a5c:	0e 18       	sub	r8,r7
80005a5e:	58 f8       	cp.w	r8,15
80005a60:	5f aa       	srle	r10
80005a62:	f5 e9 10 09 	or	r9,r10,r9
80005a66:	c0 50       	breq	80005a70 <_malloc_r+0x418>
80005a68:	0a 9c       	mov	r12,r5
80005a6a:	fe b0 f3 dd 	rcall	80004224 <__malloc_unlock>
80005a6e:	d8 3a       	popm	r0-r7,pc,r12=0
80005a70:	68 26       	ld.w	r6,r4[0x8]
80005a72:	a1 a8       	sbr	r8,0x0
80005a74:	0e 99       	mov	r9,r7
80005a76:	a1 a9       	sbr	r9,0x0
80005a78:	8d 19       	st.w	r6[0x4],r9
80005a7a:	ec 07 00 07 	add	r7,r6,r7
80005a7e:	0a 9c       	mov	r12,r5
80005a80:	89 27       	st.w	r4[0x8],r7
80005a82:	8f 18       	st.w	r7[0x4],r8
80005a84:	fe b0 f3 d0 	rcall	80004224 <__malloc_unlock>
80005a88:	ec cc ff f8 	sub	r12,r6,-8
80005a8c:	d8 32       	popm	r0-r7,pc
80005a8e:	d7 03       	nop

80005a90 <memcpy>:
80005a90:	58 8a       	cp.w	r10,8
80005a92:	c2 f5       	brlt	80005af0 <memcpy+0x60>
80005a94:	f9 eb 10 09 	or	r9,r12,r11
80005a98:	e2 19 00 03 	andl	r9,0x3,COH
80005a9c:	e0 81 00 97 	brne	80005bca <memcpy+0x13a>
80005aa0:	e0 4a 00 20 	cp.w	r10,32
80005aa4:	c3 b4       	brge	80005b1a <memcpy+0x8a>
80005aa6:	f4 08 14 02 	asr	r8,r10,0x2
80005aaa:	f0 09 11 08 	rsub	r9,r8,8
80005aae:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80005ab2:	76 69       	ld.w	r9,r11[0x18]
80005ab4:	99 69       	st.w	r12[0x18],r9
80005ab6:	76 59       	ld.w	r9,r11[0x14]
80005ab8:	99 59       	st.w	r12[0x14],r9
80005aba:	76 49       	ld.w	r9,r11[0x10]
80005abc:	99 49       	st.w	r12[0x10],r9
80005abe:	76 39       	ld.w	r9,r11[0xc]
80005ac0:	99 39       	st.w	r12[0xc],r9
80005ac2:	76 29       	ld.w	r9,r11[0x8]
80005ac4:	99 29       	st.w	r12[0x8],r9
80005ac6:	76 19       	ld.w	r9,r11[0x4]
80005ac8:	99 19       	st.w	r12[0x4],r9
80005aca:	76 09       	ld.w	r9,r11[0x0]
80005acc:	99 09       	st.w	r12[0x0],r9
80005ace:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80005ad2:	f8 08 00 28 	add	r8,r12,r8<<0x2
80005ad6:	e0 1a 00 03 	andl	r10,0x3
80005ada:	f4 0a 11 04 	rsub	r10,r10,4
80005ade:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80005ae2:	17 a9       	ld.ub	r9,r11[0x2]
80005ae4:	b0 a9       	st.b	r8[0x2],r9
80005ae6:	17 99       	ld.ub	r9,r11[0x1]
80005ae8:	b0 99       	st.b	r8[0x1],r9
80005aea:	17 89       	ld.ub	r9,r11[0x0]
80005aec:	b0 89       	st.b	r8[0x0],r9
80005aee:	5e fc       	retal	r12
80005af0:	f4 0a 11 09 	rsub	r10,r10,9
80005af4:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80005af8:	17 f9       	ld.ub	r9,r11[0x7]
80005afa:	b8 f9       	st.b	r12[0x7],r9
80005afc:	17 e9       	ld.ub	r9,r11[0x6]
80005afe:	b8 e9       	st.b	r12[0x6],r9
80005b00:	17 d9       	ld.ub	r9,r11[0x5]
80005b02:	b8 d9       	st.b	r12[0x5],r9
80005b04:	17 c9       	ld.ub	r9,r11[0x4]
80005b06:	b8 c9       	st.b	r12[0x4],r9
80005b08:	17 b9       	ld.ub	r9,r11[0x3]
80005b0a:	b8 b9       	st.b	r12[0x3],r9
80005b0c:	17 a9       	ld.ub	r9,r11[0x2]
80005b0e:	b8 a9       	st.b	r12[0x2],r9
80005b10:	17 99       	ld.ub	r9,r11[0x1]
80005b12:	b8 99       	st.b	r12[0x1],r9
80005b14:	17 89       	ld.ub	r9,r11[0x0]
80005b16:	b8 89       	st.b	r12[0x0],r9
80005b18:	5e fc       	retal	r12
80005b1a:	eb cd 40 c0 	pushm	r6-r7,lr
80005b1e:	18 99       	mov	r9,r12
80005b20:	22 0a       	sub	r10,32
80005b22:	b7 07       	ld.d	r6,r11++
80005b24:	b3 26       	st.d	r9++,r6
80005b26:	b7 07       	ld.d	r6,r11++
80005b28:	b3 26       	st.d	r9++,r6
80005b2a:	b7 07       	ld.d	r6,r11++
80005b2c:	b3 26       	st.d	r9++,r6
80005b2e:	b7 07       	ld.d	r6,r11++
80005b30:	b3 26       	st.d	r9++,r6
80005b32:	22 0a       	sub	r10,32
80005b34:	cf 74       	brge	80005b22 <memcpy+0x92>
80005b36:	2f 0a       	sub	r10,-16
80005b38:	c0 65       	brlt	80005b44 <memcpy+0xb4>
80005b3a:	b7 07       	ld.d	r6,r11++
80005b3c:	b3 26       	st.d	r9++,r6
80005b3e:	b7 07       	ld.d	r6,r11++
80005b40:	b3 26       	st.d	r9++,r6
80005b42:	21 0a       	sub	r10,16
80005b44:	5c 3a       	neg	r10
80005b46:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80005b4a:	d7 03       	nop
80005b4c:	d7 03       	nop
80005b4e:	f7 36 00 0e 	ld.ub	r6,r11[14]
80005b52:	f3 66 00 0e 	st.b	r9[14],r6
80005b56:	f7 36 00 0d 	ld.ub	r6,r11[13]
80005b5a:	f3 66 00 0d 	st.b	r9[13],r6
80005b5e:	f7 36 00 0c 	ld.ub	r6,r11[12]
80005b62:	f3 66 00 0c 	st.b	r9[12],r6
80005b66:	f7 36 00 0b 	ld.ub	r6,r11[11]
80005b6a:	f3 66 00 0b 	st.b	r9[11],r6
80005b6e:	f7 36 00 0a 	ld.ub	r6,r11[10]
80005b72:	f3 66 00 0a 	st.b	r9[10],r6
80005b76:	f7 36 00 09 	ld.ub	r6,r11[9]
80005b7a:	f3 66 00 09 	st.b	r9[9],r6
80005b7e:	f7 36 00 08 	ld.ub	r6,r11[8]
80005b82:	f3 66 00 08 	st.b	r9[8],r6
80005b86:	f7 36 00 07 	ld.ub	r6,r11[7]
80005b8a:	f3 66 00 07 	st.b	r9[7],r6
80005b8e:	f7 36 00 06 	ld.ub	r6,r11[6]
80005b92:	f3 66 00 06 	st.b	r9[6],r6
80005b96:	f7 36 00 05 	ld.ub	r6,r11[5]
80005b9a:	f3 66 00 05 	st.b	r9[5],r6
80005b9e:	f7 36 00 04 	ld.ub	r6,r11[4]
80005ba2:	f3 66 00 04 	st.b	r9[4],r6
80005ba6:	f7 36 00 03 	ld.ub	r6,r11[3]
80005baa:	f3 66 00 03 	st.b	r9[3],r6
80005bae:	f7 36 00 02 	ld.ub	r6,r11[2]
80005bb2:	f3 66 00 02 	st.b	r9[2],r6
80005bb6:	f7 36 00 01 	ld.ub	r6,r11[1]
80005bba:	f3 66 00 01 	st.b	r9[1],r6
80005bbe:	f7 36 00 00 	ld.ub	r6,r11[0]
80005bc2:	f3 66 00 00 	st.b	r9[0],r6
80005bc6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005bca:	20 1a       	sub	r10,1
80005bcc:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80005bd0:	f8 0a 0b 09 	st.b	r12[r10],r9
80005bd4:	cf b1       	brne	80005bca <memcpy+0x13a>
80005bd6:	5e fc       	retal	r12

80005bd8 <memset>:
80005bd8:	18 98       	mov	r8,r12
80005bda:	c0 38       	rjmp	80005be0 <memset+0x8>
80005bdc:	10 cb       	st.b	r8++,r11
80005bde:	20 1a       	sub	r10,1
80005be0:	58 0a       	cp.w	r10,0
80005be2:	cf d1       	brne	80005bdc <memset+0x4>
80005be4:	5e fc       	retal	r12
80005be6:	d7 03       	nop

80005be8 <_realloc_r>:
80005be8:	d4 31       	pushm	r0-r7,lr
80005bea:	20 1d       	sub	sp,4
80005bec:	16 94       	mov	r4,r11
80005bee:	18 92       	mov	r2,r12
80005bf0:	14 9b       	mov	r11,r10
80005bf2:	58 04       	cp.w	r4,0
80005bf4:	c0 51       	brne	80005bfe <_realloc_r+0x16>
80005bf6:	fe b0 fd 31 	rcall	80005658 <_malloc_r>
80005bfa:	18 95       	mov	r5,r12
80005bfc:	c5 39       	rjmp	80005ea2 <_realloc_r+0x2ba>
80005bfe:	50 0a       	stdsp	sp[0x0],r10
80005c00:	fe b0 f3 0c 	rcall	80004218 <__malloc_lock>
80005c04:	40 0b       	lddsp	r11,sp[0x0]
80005c06:	f6 c8 ff f5 	sub	r8,r11,-11
80005c0a:	e8 c1 00 08 	sub	r1,r4,8
80005c0e:	10 96       	mov	r6,r8
80005c10:	62 1c       	ld.w	r12,r1[0x4]
80005c12:	e0 16 ff f8 	andl	r6,0xfff8
80005c16:	59 68       	cp.w	r8,22
80005c18:	f9 b6 08 10 	movls	r6,16
80005c1c:	16 36       	cp.w	r6,r11
80005c1e:	5f 38       	srlo	r8
80005c20:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80005c24:	c0 50       	breq	80005c2e <_realloc_r+0x46>
80005c26:	30 c8       	mov	r8,12
80005c28:	30 05       	mov	r5,0
80005c2a:	85 38       	st.w	r2[0xc],r8
80005c2c:	c3 b9       	rjmp	80005ea2 <_realloc_r+0x2ba>
80005c2e:	18 90       	mov	r0,r12
80005c30:	e0 10 ff fc 	andl	r0,0xfffc
80005c34:	0c 30       	cp.w	r0,r6
80005c36:	e0 84 01 0b 	brge	80005e4c <_realloc_r+0x264>
80005c3a:	e0 68 05 40 	mov	r8,1344
80005c3e:	e2 00 00 09 	add	r9,r1,r0
80005c42:	70 25       	ld.w	r5,r8[0x8]
80005c44:	0a 39       	cp.w	r9,r5
80005c46:	c0 90       	breq	80005c58 <_realloc_r+0x70>
80005c48:	72 1a       	ld.w	r10,r9[0x4]
80005c4a:	a1 ca       	cbr	r10,0x0
80005c4c:	f2 0a 00 0a 	add	r10,r9,r10
80005c50:	74 1a       	ld.w	r10,r10[0x4]
80005c52:	ed ba 00 00 	bld	r10,0x0
80005c56:	c2 20       	breq	80005c9a <_realloc_r+0xb2>
80005c58:	72 1a       	ld.w	r10,r9[0x4]
80005c5a:	e0 1a ff fc 	andl	r10,0xfffc
80005c5e:	f4 00 00 03 	add	r3,r10,r0
80005c62:	0a 39       	cp.w	r9,r5
80005c64:	c1 31       	brne	80005c8a <_realloc_r+0xa2>
80005c66:	ec c7 ff f0 	sub	r7,r6,-16
80005c6a:	0e 33       	cp.w	r3,r7
80005c6c:	c1 95       	brlt	80005c9e <_realloc_r+0xb6>
80005c6e:	e2 06 00 09 	add	r9,r1,r6
80005c72:	0c 13       	sub	r3,r6
80005c74:	a1 a3       	sbr	r3,0x0
80005c76:	93 13       	st.w	r9[0x4],r3
80005c78:	91 29       	st.w	r8[0x8],r9
80005c7a:	04 9c       	mov	r12,r2
80005c7c:	62 18       	ld.w	r8,r1[0x4]
80005c7e:	08 95       	mov	r5,r4
80005c80:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005c84:	10 46       	or	r6,r8
80005c86:	83 16       	st.w	r1[0x4],r6
80005c88:	c0 b9       	rjmp	80005e9e <_realloc_r+0x2b6>
80005c8a:	0c 33       	cp.w	r3,r6
80005c8c:	c0 95       	brlt	80005c9e <_realloc_r+0xb6>
80005c8e:	72 28       	ld.w	r8,r9[0x8]
80005c90:	02 97       	mov	r7,r1
80005c92:	72 39       	ld.w	r9,r9[0xc]
80005c94:	93 28       	st.w	r9[0x8],r8
80005c96:	91 39       	st.w	r8[0xc],r9
80005c98:	cd c8       	rjmp	80005e50 <_realloc_r+0x268>
80005c9a:	30 0a       	mov	r10,0
80005c9c:	14 99       	mov	r9,r10
80005c9e:	ed bc 00 00 	bld	r12,0x0
80005ca2:	e0 80 00 95 	breq	80005dcc <_realloc_r+0x1e4>
80005ca6:	62 07       	ld.w	r7,r1[0x0]
80005ca8:	e2 07 01 07 	sub	r7,r1,r7
80005cac:	6e 1c       	ld.w	r12,r7[0x4]
80005cae:	e0 1c ff fc 	andl	r12,0xfffc
80005cb2:	58 09       	cp.w	r9,0
80005cb4:	c5 60       	breq	80005d60 <_realloc_r+0x178>
80005cb6:	f8 00 00 03 	add	r3,r12,r0
80005cba:	0a 39       	cp.w	r9,r5
80005cbc:	c4 81       	brne	80005d4c <_realloc_r+0x164>
80005cbe:	14 03       	add	r3,r10
80005cc0:	ec c9 ff f0 	sub	r9,r6,-16
80005cc4:	12 33       	cp.w	r3,r9
80005cc6:	c4 d5       	brlt	80005d60 <_realloc_r+0x178>
80005cc8:	6e 3a       	ld.w	r10,r7[0xc]
80005cca:	6e 29       	ld.w	r9,r7[0x8]
80005ccc:	95 29       	st.w	r10[0x8],r9
80005cce:	93 3a       	st.w	r9[0xc],r10
80005cd0:	ee c5 ff f8 	sub	r5,r7,-8
80005cd4:	e0 ca 00 04 	sub	r10,r0,4
80005cd8:	e0 4a 00 24 	cp.w	r10,36
80005cdc:	e0 8b 00 25 	brhi	80005d26 <_realloc_r+0x13e>
80005ce0:	0a 99       	mov	r9,r5
80005ce2:	59 3a       	cp.w	r10,19
80005ce4:	e0 88 00 1a 	brls	80005d18 <_realloc_r+0x130>
80005ce8:	09 09       	ld.w	r9,r4++
80005cea:	8b 09       	st.w	r5[0x0],r9
80005cec:	09 09       	ld.w	r9,r4++
80005cee:	8f 39       	st.w	r7[0xc],r9
80005cf0:	ee c9 ff f0 	sub	r9,r7,-16
80005cf4:	59 ba       	cp.w	r10,27
80005cf6:	e0 88 00 11 	brls	80005d18 <_realloc_r+0x130>
80005cfa:	09 0b       	ld.w	r11,r4++
80005cfc:	93 0b       	st.w	r9[0x0],r11
80005cfe:	09 09       	ld.w	r9,r4++
80005d00:	8f 59       	st.w	r7[0x14],r9
80005d02:	ee c9 ff e8 	sub	r9,r7,-24
80005d06:	e0 4a 00 24 	cp.w	r10,36
80005d0a:	c0 71       	brne	80005d18 <_realloc_r+0x130>
80005d0c:	09 0a       	ld.w	r10,r4++
80005d0e:	93 0a       	st.w	r9[0x0],r10
80005d10:	ee c9 ff e0 	sub	r9,r7,-32
80005d14:	09 0a       	ld.w	r10,r4++
80005d16:	8f 7a       	st.w	r7[0x1c],r10
80005d18:	09 0a       	ld.w	r10,r4++
80005d1a:	12 aa       	st.w	r9++,r10
80005d1c:	68 0a       	ld.w	r10,r4[0x0]
80005d1e:	93 0a       	st.w	r9[0x0],r10
80005d20:	68 1a       	ld.w	r10,r4[0x4]
80005d22:	93 1a       	st.w	r9[0x4],r10
80005d24:	c0 78       	rjmp	80005d32 <_realloc_r+0x14a>
80005d26:	50 08       	stdsp	sp[0x0],r8
80005d28:	08 9b       	mov	r11,r4
80005d2a:	0a 9c       	mov	r12,r5
80005d2c:	e0 a0 1d 8f 	rcall	8000984a <memmove>
80005d30:	40 08       	lddsp	r8,sp[0x0]
80005d32:	ee 06 00 09 	add	r9,r7,r6
80005d36:	0c 13       	sub	r3,r6
80005d38:	a1 a3       	sbr	r3,0x0
80005d3a:	93 13       	st.w	r9[0x4],r3
80005d3c:	91 29       	st.w	r8[0x8],r9
80005d3e:	04 9c       	mov	r12,r2
80005d40:	6e 18       	ld.w	r8,r7[0x4]
80005d42:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005d46:	10 46       	or	r6,r8
80005d48:	8f 16       	st.w	r7[0x4],r6
80005d4a:	ca a8       	rjmp	80005e9e <_realloc_r+0x2b6>
80005d4c:	14 03       	add	r3,r10
80005d4e:	0c 33       	cp.w	r3,r6
80005d50:	c0 85       	brlt	80005d60 <_realloc_r+0x178>
80005d52:	72 28       	ld.w	r8,r9[0x8]
80005d54:	72 39       	ld.w	r9,r9[0xc]
80005d56:	93 28       	st.w	r9[0x8],r8
80005d58:	91 39       	st.w	r8[0xc],r9
80005d5a:	6e 28       	ld.w	r8,r7[0x8]
80005d5c:	6e 39       	ld.w	r9,r7[0xc]
80005d5e:	c0 78       	rjmp	80005d6c <_realloc_r+0x184>
80005d60:	f8 00 00 03 	add	r3,r12,r0
80005d64:	0c 33       	cp.w	r3,r6
80005d66:	c3 35       	brlt	80005dcc <_realloc_r+0x1e4>
80005d68:	6e 39       	ld.w	r9,r7[0xc]
80005d6a:	6e 28       	ld.w	r8,r7[0x8]
80005d6c:	93 28       	st.w	r9[0x8],r8
80005d6e:	91 39       	st.w	r8[0xc],r9
80005d70:	e0 ca 00 04 	sub	r10,r0,4
80005d74:	ee cc ff f8 	sub	r12,r7,-8
80005d78:	e0 4a 00 24 	cp.w	r10,36
80005d7c:	e0 8b 00 24 	brhi	80005dc4 <_realloc_r+0x1dc>
80005d80:	59 3a       	cp.w	r10,19
80005d82:	e0 88 00 1a 	brls	80005db6 <_realloc_r+0x1ce>
80005d86:	09 08       	ld.w	r8,r4++
80005d88:	99 08       	st.w	r12[0x0],r8
80005d8a:	09 08       	ld.w	r8,r4++
80005d8c:	8f 38       	st.w	r7[0xc],r8
80005d8e:	ee cc ff f0 	sub	r12,r7,-16
80005d92:	59 ba       	cp.w	r10,27
80005d94:	e0 88 00 11 	brls	80005db6 <_realloc_r+0x1ce>
80005d98:	09 08       	ld.w	r8,r4++
80005d9a:	99 08       	st.w	r12[0x0],r8
80005d9c:	09 08       	ld.w	r8,r4++
80005d9e:	8f 58       	st.w	r7[0x14],r8
80005da0:	ee cc ff e8 	sub	r12,r7,-24
80005da4:	e0 4a 00 24 	cp.w	r10,36
80005da8:	c0 71       	brne	80005db6 <_realloc_r+0x1ce>
80005daa:	09 08       	ld.w	r8,r4++
80005dac:	99 08       	st.w	r12[0x0],r8
80005dae:	ee cc ff e0 	sub	r12,r7,-32
80005db2:	09 08       	ld.w	r8,r4++
80005db4:	8f 78       	st.w	r7[0x1c],r8
80005db6:	09 08       	ld.w	r8,r4++
80005db8:	18 a8       	st.w	r12++,r8
80005dba:	68 08       	ld.w	r8,r4[0x0]
80005dbc:	99 08       	st.w	r12[0x0],r8
80005dbe:	68 18       	ld.w	r8,r4[0x4]
80005dc0:	99 18       	st.w	r12[0x4],r8
80005dc2:	c4 78       	rjmp	80005e50 <_realloc_r+0x268>
80005dc4:	08 9b       	mov	r11,r4
80005dc6:	e0 a0 1d 42 	rcall	8000984a <memmove>
80005dca:	c4 38       	rjmp	80005e50 <_realloc_r+0x268>
80005dcc:	04 9c       	mov	r12,r2
80005dce:	fe b0 fc 45 	rcall	80005658 <_malloc_r>
80005dd2:	18 95       	mov	r5,r12
80005dd4:	c3 a0       	breq	80005e48 <_realloc_r+0x260>
80005dd6:	62 18       	ld.w	r8,r1[0x4]
80005dd8:	f8 c9 00 08 	sub	r9,r12,8
80005ddc:	a1 c8       	cbr	r8,0x0
80005dde:	e2 08 00 08 	add	r8,r1,r8
80005de2:	10 39       	cp.w	r9,r8
80005de4:	c0 71       	brne	80005df2 <_realloc_r+0x20a>
80005de6:	72 13       	ld.w	r3,r9[0x4]
80005de8:	02 97       	mov	r7,r1
80005dea:	e0 13 ff fc 	andl	r3,0xfffc
80005dee:	00 03       	add	r3,r0
80005df0:	c3 08       	rjmp	80005e50 <_realloc_r+0x268>
80005df2:	e0 ca 00 04 	sub	r10,r0,4
80005df6:	e0 4a 00 24 	cp.w	r10,36
80005dfa:	e0 8b 00 20 	brhi	80005e3a <_realloc_r+0x252>
80005dfe:	08 99       	mov	r9,r4
80005e00:	18 98       	mov	r8,r12
80005e02:	59 3a       	cp.w	r10,19
80005e04:	e0 88 00 14 	brls	80005e2c <_realloc_r+0x244>
80005e08:	13 0b       	ld.w	r11,r9++
80005e0a:	10 ab       	st.w	r8++,r11
80005e0c:	13 0b       	ld.w	r11,r9++
80005e0e:	10 ab       	st.w	r8++,r11
80005e10:	59 ba       	cp.w	r10,27
80005e12:	e0 88 00 0d 	brls	80005e2c <_realloc_r+0x244>
80005e16:	13 0b       	ld.w	r11,r9++
80005e18:	10 ab       	st.w	r8++,r11
80005e1a:	13 0b       	ld.w	r11,r9++
80005e1c:	10 ab       	st.w	r8++,r11
80005e1e:	e0 4a 00 24 	cp.w	r10,36
80005e22:	c0 51       	brne	80005e2c <_realloc_r+0x244>
80005e24:	13 0a       	ld.w	r10,r9++
80005e26:	10 aa       	st.w	r8++,r10
80005e28:	13 0a       	ld.w	r10,r9++
80005e2a:	10 aa       	st.w	r8++,r10
80005e2c:	13 0a       	ld.w	r10,r9++
80005e2e:	10 aa       	st.w	r8++,r10
80005e30:	72 0a       	ld.w	r10,r9[0x0]
80005e32:	91 0a       	st.w	r8[0x0],r10
80005e34:	72 19       	ld.w	r9,r9[0x4]
80005e36:	91 19       	st.w	r8[0x4],r9
80005e38:	c0 48       	rjmp	80005e40 <_realloc_r+0x258>
80005e3a:	08 9b       	mov	r11,r4
80005e3c:	e0 a0 1d 07 	rcall	8000984a <memmove>
80005e40:	08 9b       	mov	r11,r4
80005e42:	04 9c       	mov	r12,r2
80005e44:	e0 a0 1a 60 	rcall	80009304 <_free_r>
80005e48:	04 9c       	mov	r12,r2
80005e4a:	c2 a8       	rjmp	80005e9e <_realloc_r+0x2b6>
80005e4c:	00 93       	mov	r3,r0
80005e4e:	02 97       	mov	r7,r1
80005e50:	e6 06 01 09 	sub	r9,r3,r6
80005e54:	6e 18       	ld.w	r8,r7[0x4]
80005e56:	58 f9       	cp.w	r9,15
80005e58:	e0 88 00 16 	brls	80005e84 <_realloc_r+0x29c>
80005e5c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005e60:	ed e8 10 08 	or	r8,r6,r8
80005e64:	8f 18       	st.w	r7[0x4],r8
80005e66:	12 98       	mov	r8,r9
80005e68:	a1 a8       	sbr	r8,0x0
80005e6a:	ee 06 00 0b 	add	r11,r7,r6
80005e6e:	f6 09 00 09 	add	r9,r11,r9
80005e72:	97 18       	st.w	r11[0x4],r8
80005e74:	72 18       	ld.w	r8,r9[0x4]
80005e76:	a1 a8       	sbr	r8,0x0
80005e78:	2f 8b       	sub	r11,-8
80005e7a:	93 18       	st.w	r9[0x4],r8
80005e7c:	04 9c       	mov	r12,r2
80005e7e:	e0 a0 1a 43 	rcall	80009304 <_free_r>
80005e82:	c0 b8       	rjmp	80005e98 <_realloc_r+0x2b0>
80005e84:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005e88:	e7 e8 10 08 	or	r8,r3,r8
80005e8c:	8f 18       	st.w	r7[0x4],r8
80005e8e:	ee 03 00 03 	add	r3,r7,r3
80005e92:	66 18       	ld.w	r8,r3[0x4]
80005e94:	a1 a8       	sbr	r8,0x0
80005e96:	87 18       	st.w	r3[0x4],r8
80005e98:	04 9c       	mov	r12,r2
80005e9a:	ee c5 ff f8 	sub	r5,r7,-8
80005e9e:	fe b0 f1 c3 	rcall	80004224 <__malloc_unlock>
80005ea2:	0a 9c       	mov	r12,r5
80005ea4:	2f fd       	sub	sp,-4
80005ea6:	d8 32       	popm	r0-r7,pc

80005ea8 <_sbrk_r>:
80005ea8:	d4 21       	pushm	r4-r7,lr
80005eaa:	30 08       	mov	r8,0
80005eac:	18 97       	mov	r7,r12
80005eae:	e0 66 51 48 	mov	r6,20808
80005eb2:	16 9c       	mov	r12,r11
80005eb4:	8d 08       	st.w	r6[0x0],r8
80005eb6:	c8 5c       	rcall	80005fc0 <_sbrk>
80005eb8:	5b fc       	cp.w	r12,-1
80005eba:	c0 51       	brne	80005ec4 <_sbrk_r+0x1c>
80005ebc:	6c 08       	ld.w	r8,r6[0x0]
80005ebe:	58 08       	cp.w	r8,0
80005ec0:	ef f8 1a 03 	st.wne	r7[0xc],r8
80005ec4:	d8 22       	popm	r4-r7,pc
80005ec6:	d7 03       	nop

80005ec8 <sprintf>:
80005ec8:	d4 01       	pushm	lr
80005eca:	21 7d       	sub	sp,92
80005ecc:	e0 68 ff ff 	mov	r8,65535
80005ed0:	ea 18 7f ff 	orh	r8,0x7fff
80005ed4:	50 58       	stdsp	sp[0x14],r8
80005ed6:	50 28       	stdsp	sp[0x8],r8
80005ed8:	e0 68 02 08 	mov	r8,520
80005edc:	ba 68       	st.h	sp[0xc],r8
80005ede:	3f f8       	mov	r8,-1
80005ee0:	ba 78       	st.h	sp[0xe],r8
80005ee2:	e0 68 0a 40 	mov	r8,2624
80005ee6:	50 4c       	stdsp	sp[0x10],r12
80005ee8:	16 9a       	mov	r10,r11
80005eea:	50 0c       	stdsp	sp[0x0],r12
80005eec:	fa c9 ff a0 	sub	r9,sp,-96
80005ef0:	70 0c       	ld.w	r12,r8[0x0]
80005ef2:	1a 9b       	mov	r11,sp
80005ef4:	e0 a0 02 1a 	rcall	80006328 <_vfprintf_r>
80005ef8:	30 09       	mov	r9,0
80005efa:	40 08       	lddsp	r8,sp[0x0]
80005efc:	b0 89       	st.b	r8[0x0],r9
80005efe:	2e 9d       	sub	sp,-92
80005f00:	d8 02       	popm	pc
80005f02:	d7 03       	nop

80005f04 <strncpy>:
80005f04:	30 08       	mov	r8,0
80005f06:	10 3a       	cp.w	r10,r8
80005f08:	5e 0c       	reteq	r12
80005f0a:	f6 08 07 09 	ld.ub	r9,r11[r8]
80005f0e:	f8 08 0b 09 	st.b	r12[r8],r9
80005f12:	2f f8       	sub	r8,-1
80005f14:	58 09       	cp.w	r9,0
80005f16:	cf 81       	brne	80005f06 <strncpy+0x2>
80005f18:	10 3a       	cp.w	r10,r8
80005f1a:	5e 0c       	reteq	r12
80005f1c:	f8 08 0b 09 	st.b	r12[r8],r9
80005f20:	2f f8       	sub	r8,-1
80005f22:	cf bb       	rjmp	80005f18 <strncpy+0x14>

80005f24 <_close>:
80005f24:	30 28       	mov	r8,2
80005f26:	d6 73       	breakpoint
80005f28:	3f fc       	mov	r12,-1
80005f2a:	35 8b       	mov	r11,88
80005f2c:	58 0c       	cp.w	r12,0
80005f2e:	5e 4c       	retge	r12
80005f30:	e0 6a 51 48 	mov	r10,20808
80005f34:	95 0b       	st.w	r10[0x0],r11
80005f36:	5e fc       	retal	r12

80005f38 <_lseek>:
80005f38:	30 58       	mov	r8,5
80005f3a:	d6 73       	breakpoint
80005f3c:	3f fc       	mov	r12,-1
80005f3e:	35 8b       	mov	r11,88
80005f40:	58 0c       	cp.w	r12,0
80005f42:	5e 4c       	retge	r12
80005f44:	e0 6a 51 48 	mov	r10,20808
80005f48:	95 0b       	st.w	r10[0x0],r11
80005f4a:	5e fc       	retal	r12

80005f4c <isatty>:
80005f4c:	30 b8       	mov	r8,11
80005f4e:	d6 73       	breakpoint
80005f50:	3f fc       	mov	r12,-1
80005f52:	35 8b       	mov	r11,88
80005f54:	58 0c       	cp.w	r12,0
80005f56:	5e 4c       	retge	r12
80005f58:	e0 6a 51 48 	mov	r10,20808
80005f5c:	95 0b       	st.w	r10[0x0],r11
80005f5e:	5e fc       	retal	r12

80005f60 <_fstat_host>:
80005f60:	30 98       	mov	r8,9
80005f62:	d6 73       	breakpoint
80005f64:	3f fc       	mov	r12,-1
80005f66:	35 8b       	mov	r11,88
80005f68:	58 0c       	cp.w	r12,0
80005f6a:	5e 4c       	retge	r12
80005f6c:	e0 6a 51 48 	mov	r10,20808
80005f70:	95 0b       	st.w	r10[0x0],r11
80005f72:	5e fc       	retal	r12

80005f74 <_fstat>:
80005f74:	d4 21       	pushm	r4-r7,lr
80005f76:	21 0d       	sub	sp,64
80005f78:	16 97       	mov	r7,r11
80005f7a:	1a 9b       	mov	r11,sp
80005f7c:	cf 2f       	rcall	80005f60 <_fstat_host>
80005f7e:	c0 34       	brge	80005f84 <_fstat+0x10>
80005f80:	3f fc       	mov	r12,-1
80005f82:	c1 c8       	rjmp	80005fba <_fstat+0x46>
80005f84:	40 08       	lddsp	r8,sp[0x0]
80005f86:	ae 08       	st.h	r7[0x0],r8
80005f88:	40 18       	lddsp	r8,sp[0x4]
80005f8a:	ae 18       	st.h	r7[0x2],r8
80005f8c:	40 28       	lddsp	r8,sp[0x8]
80005f8e:	8f 18       	st.w	r7[0x4],r8
80005f90:	40 38       	lddsp	r8,sp[0xc]
80005f92:	ae 48       	st.h	r7[0x8],r8
80005f94:	40 48       	lddsp	r8,sp[0x10]
80005f96:	ae 58       	st.h	r7[0xa],r8
80005f98:	40 58       	lddsp	r8,sp[0x14]
80005f9a:	ae 68       	st.h	r7[0xc],r8
80005f9c:	40 68       	lddsp	r8,sp[0x18]
80005f9e:	ae 78       	st.h	r7[0xe],r8
80005fa0:	40 88       	lddsp	r8,sp[0x20]
80005fa2:	8f 48       	st.w	r7[0x10],r8
80005fa4:	40 a8       	lddsp	r8,sp[0x28]
80005fa6:	8f b8       	st.w	r7[0x2c],r8
80005fa8:	40 c8       	lddsp	r8,sp[0x30]
80005faa:	8f c8       	st.w	r7[0x30],r8
80005fac:	40 d8       	lddsp	r8,sp[0x34]
80005fae:	8f 58       	st.w	r7[0x14],r8
80005fb0:	40 e8       	lddsp	r8,sp[0x38]
80005fb2:	30 0c       	mov	r12,0
80005fb4:	8f 78       	st.w	r7[0x1c],r8
80005fb6:	40 f8       	lddsp	r8,sp[0x3c]
80005fb8:	8f 98       	st.w	r7[0x24],r8
80005fba:	2f 0d       	sub	sp,-64
80005fbc:	d8 22       	popm	r4-r7,pc
80005fbe:	d7 03       	nop

80005fc0 <_sbrk>:
80005fc0:	d4 01       	pushm	lr
80005fc2:	e0 68 0d 9c 	mov	r8,3484
80005fc6:	70 09       	ld.w	r9,r8[0x0]
80005fc8:	58 09       	cp.w	r9,0
80005fca:	c0 41       	brne	80005fd2 <_sbrk+0x12>
80005fcc:	e0 69 51 50 	mov	r9,20816
80005fd0:	91 09       	st.w	r8[0x0],r9
80005fd2:	e0 69 0d 9c 	mov	r9,3484
80005fd6:	e0 7a 70 00 	mov	r10,94208
80005fda:	72 08       	ld.w	r8,r9[0x0]
80005fdc:	f0 0c 00 0c 	add	r12,r8,r12
80005fe0:	14 3c       	cp.w	r12,r10
80005fe2:	e0 8b 00 04 	brhi	80005fea <_sbrk+0x2a>
80005fe6:	93 0c       	st.w	r9[0x0],r12
80005fe8:	c0 68       	rjmp	80005ff4 <_sbrk+0x34>
80005fea:	e0 a0 18 15 	rcall	80009014 <__errno>
80005fee:	30 c8       	mov	r8,12
80005ff0:	99 08       	st.w	r12[0x0],r8
80005ff2:	3f f8       	mov	r8,-1
80005ff4:	10 9c       	mov	r12,r8
80005ff6:	d8 02       	popm	pc

80005ff8 <get_arg>:
80005ff8:	d4 31       	pushm	r0-r7,lr
80005ffa:	20 8d       	sub	sp,32
80005ffc:	fa c4 ff bc 	sub	r4,sp,-68
80006000:	50 4b       	stdsp	sp[0x10],r11
80006002:	68 2e       	ld.w	lr,r4[0x8]
80006004:	50 58       	stdsp	sp[0x14],r8
80006006:	12 96       	mov	r6,r9
80006008:	7c 0b       	ld.w	r11,lr[0x0]
8000600a:	70 05       	ld.w	r5,r8[0x0]
8000600c:	50 6e       	stdsp	sp[0x18],lr
8000600e:	58 0b       	cp.w	r11,0
80006010:	f4 0b 17 00 	moveq	r11,r10
80006014:	68 03       	ld.w	r3,r4[0x0]
80006016:	68 11       	ld.w	r1,r4[0x4]
80006018:	40 49       	lddsp	r9,sp[0x10]
8000601a:	30 08       	mov	r8,0
8000601c:	c2 89       	rjmp	8000626c <get_arg+0x274>
8000601e:	2f fb       	sub	r11,-1
80006020:	32 5c       	mov	r12,37
80006022:	17 8a       	ld.ub	r10,r11[0x0]
80006024:	f8 0a 18 00 	cp.b	r10,r12
80006028:	5f 1e       	srne	lr
8000602a:	f0 0a 18 00 	cp.b	r10,r8
8000602e:	5f 1c       	srne	r12
80006030:	fd ec 00 0c 	and	r12,lr,r12
80006034:	f0 0c 18 00 	cp.b	r12,r8
80006038:	cf 31       	brne	8000601e <get_arg+0x26>
8000603a:	58 0a       	cp.w	r10,0
8000603c:	e0 80 01 25 	breq	80006286 <get_arg+0x28e>
80006040:	30 0c       	mov	r12,0
80006042:	3f fa       	mov	r10,-1
80006044:	18 90       	mov	r0,r12
80006046:	50 3a       	stdsp	sp[0xc],r10
80006048:	18 94       	mov	r4,r12
8000604a:	18 92       	mov	r2,r12
8000604c:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80006050:	16 97       	mov	r7,r11
80006052:	50 7c       	stdsp	sp[0x1c],r12
80006054:	fe cc 9f 54 	sub	r12,pc,-24748
80006058:	0f 3a       	ld.ub	r10,r7++
8000605a:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
8000605e:	40 7c       	lddsp	r12,sp[0x1c]
80006060:	1c 0c       	add	r12,lr
80006062:	fe ce a0 2a 	sub	lr,pc,-24534
80006066:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
8000606a:	20 1e       	sub	lr,1
8000606c:	50 0e       	stdsp	sp[0x0],lr
8000606e:	fe ce a0 a2 	sub	lr,pc,-24414
80006072:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80006076:	50 7c       	stdsp	sp[0x1c],r12
80006078:	40 0c       	lddsp	r12,sp[0x0]
8000607a:	58 7c       	cp.w	r12,7
8000607c:	e0 8b 00 f1 	brhi	8000625e <get_arg+0x266>
80006080:	fe ce a2 54 	sub	lr,pc,-23980
80006084:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80006088:	36 8b       	mov	r11,104
8000608a:	f6 0a 18 00 	cp.b	r10,r11
8000608e:	e0 80 00 e8 	breq	8000625e <get_arg+0x266>
80006092:	37 1b       	mov	r11,113
80006094:	f6 0a 18 00 	cp.b	r10,r11
80006098:	c0 70       	breq	800060a6 <get_arg+0xae>
8000609a:	34 cb       	mov	r11,76
8000609c:	f6 0a 18 00 	cp.b	r10,r11
800060a0:	c0 51       	brne	800060aa <get_arg+0xb2>
800060a2:	a3 b4       	sbr	r4,0x3
800060a4:	cd d8       	rjmp	8000625e <get_arg+0x266>
800060a6:	a5 b4       	sbr	r4,0x5
800060a8:	cd b8       	rjmp	8000625e <get_arg+0x266>
800060aa:	08 9a       	mov	r10,r4
800060ac:	0e 9b       	mov	r11,r7
800060ae:	a5 aa       	sbr	r10,0x4
800060b0:	17 3c       	ld.ub	r12,r11++
800060b2:	a5 b4       	sbr	r4,0x5
800060b4:	36 ce       	mov	lr,108
800060b6:	fc 0c 18 00 	cp.b	r12,lr
800060ba:	e0 80 00 d3 	breq	80006260 <get_arg+0x268>
800060be:	14 94       	mov	r4,r10
800060c0:	cc f8       	rjmp	8000625e <get_arg+0x266>
800060c2:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
800060c6:	36 7c       	mov	r12,103
800060c8:	f8 0a 18 00 	cp.b	r10,r12
800060cc:	e0 8b 00 27 	brhi	8000611a <get_arg+0x122>
800060d0:	36 5b       	mov	r11,101
800060d2:	f6 0a 18 00 	cp.b	r10,r11
800060d6:	c4 82       	brcc	80006166 <get_arg+0x16e>
800060d8:	34 fb       	mov	r11,79
800060da:	f6 0a 18 00 	cp.b	r10,r11
800060de:	c4 80       	breq	8000616e <get_arg+0x176>
800060e0:	e0 8b 00 0c 	brhi	800060f8 <get_arg+0x100>
800060e4:	34 5b       	mov	r11,69
800060e6:	f6 0a 18 00 	cp.b	r10,r11
800060ea:	c3 e0       	breq	80006166 <get_arg+0x16e>
800060ec:	34 7b       	mov	r11,71
800060ee:	f6 0a 18 00 	cp.b	r10,r11
800060f2:	c3 a0       	breq	80006166 <get_arg+0x16e>
800060f4:	34 4b       	mov	r11,68
800060f6:	c0 88       	rjmp	80006106 <get_arg+0x10e>
800060f8:	35 8b       	mov	r11,88
800060fa:	f6 0a 18 00 	cp.b	r10,r11
800060fe:	c2 c0       	breq	80006156 <get_arg+0x15e>
80006100:	e0 8b 00 07 	brhi	8000610e <get_arg+0x116>
80006104:	35 5b       	mov	r11,85
80006106:	f6 0a 18 00 	cp.b	r10,r11
8000610a:	c3 51       	brne	80006174 <get_arg+0x17c>
8000610c:	c3 18       	rjmp	8000616e <get_arg+0x176>
8000610e:	36 3b       	mov	r11,99
80006110:	f6 0a 18 00 	cp.b	r10,r11
80006114:	c2 f0       	breq	80006172 <get_arg+0x17a>
80006116:	36 4b       	mov	r11,100
80006118:	c0 e8       	rjmp	80006134 <get_arg+0x13c>
8000611a:	37 0b       	mov	r11,112
8000611c:	f6 0a 18 00 	cp.b	r10,r11
80006120:	c2 50       	breq	8000616a <get_arg+0x172>
80006122:	e0 8b 00 0d 	brhi	8000613c <get_arg+0x144>
80006126:	36 eb       	mov	r11,110
80006128:	f6 0a 18 00 	cp.b	r10,r11
8000612c:	c1 f0       	breq	8000616a <get_arg+0x172>
8000612e:	e0 8b 00 14 	brhi	80006156 <get_arg+0x15e>
80006132:	36 9b       	mov	r11,105
80006134:	f6 0a 18 00 	cp.b	r10,r11
80006138:	c1 e1       	brne	80006174 <get_arg+0x17c>
8000613a:	c0 e8       	rjmp	80006156 <get_arg+0x15e>
8000613c:	37 5b       	mov	r11,117
8000613e:	f6 0a 18 00 	cp.b	r10,r11
80006142:	c0 a0       	breq	80006156 <get_arg+0x15e>
80006144:	37 8b       	mov	r11,120
80006146:	f6 0a 18 00 	cp.b	r10,r11
8000614a:	c0 60       	breq	80006156 <get_arg+0x15e>
8000614c:	37 3b       	mov	r11,115
8000614e:	f6 0a 18 00 	cp.b	r10,r11
80006152:	c1 11       	brne	80006174 <get_arg+0x17c>
80006154:	c0 b8       	rjmp	8000616a <get_arg+0x172>
80006156:	ed b4 00 04 	bld	r4,0x4
8000615a:	c0 a0       	breq	8000616e <get_arg+0x176>
8000615c:	ed b4 00 05 	bld	r4,0x5
80006160:	c0 91       	brne	80006172 <get_arg+0x17a>
80006162:	30 20       	mov	r0,2
80006164:	c0 88       	rjmp	80006174 <get_arg+0x17c>
80006166:	30 40       	mov	r0,4
80006168:	c0 68       	rjmp	80006174 <get_arg+0x17c>
8000616a:	30 30       	mov	r0,3
8000616c:	c0 48       	rjmp	80006174 <get_arg+0x17c>
8000616e:	30 10       	mov	r0,1
80006170:	c0 28       	rjmp	80006174 <get_arg+0x17c>
80006172:	30 00       	mov	r0,0
80006174:	40 3b       	lddsp	r11,sp[0xc]
80006176:	5b fb       	cp.w	r11,-1
80006178:	c0 40       	breq	80006180 <get_arg+0x188>
8000617a:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000617e:	c7 08       	rjmp	8000625e <get_arg+0x266>
80006180:	58 60       	cp.w	r0,6
80006182:	e0 8b 00 6e 	brhi	8000625e <get_arg+0x266>
80006186:	6c 0a       	ld.w	r10,r6[0x0]
80006188:	ea cc ff ff 	sub	r12,r5,-1
8000618c:	fe ce a3 40 	sub	lr,pc,-23744
80006190:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80006194:	f4 cb ff f8 	sub	r11,r10,-8
80006198:	8d 0b       	st.w	r6[0x0],r11
8000619a:	f4 ea 00 00 	ld.d	r10,r10[0]
8000619e:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
800061a2:	c0 f8       	rjmp	800061c0 <get_arg+0x1c8>
800061a4:	f4 cb ff fc 	sub	r11,r10,-4
800061a8:	8d 0b       	st.w	r6[0x0],r11
800061aa:	74 0a       	ld.w	r10,r10[0x0]
800061ac:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800061b0:	c0 88       	rjmp	800061c0 <get_arg+0x1c8>
800061b2:	f4 cb ff f8 	sub	r11,r10,-8
800061b6:	8d 0b       	st.w	r6[0x0],r11
800061b8:	f4 ea 00 00 	ld.d	r10,r10[0]
800061bc:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
800061c0:	0e 9b       	mov	r11,r7
800061c2:	18 95       	mov	r5,r12
800061c4:	c4 e8       	rjmp	80006260 <get_arg+0x268>
800061c6:	62 0a       	ld.w	r10,r1[0x0]
800061c8:	5b fa       	cp.w	r10,-1
800061ca:	c0 b1       	brne	800061e0 <get_arg+0x1e8>
800061cc:	50 19       	stdsp	sp[0x4],r9
800061ce:	50 28       	stdsp	sp[0x8],r8
800061d0:	e0 6a 00 80 	mov	r10,128
800061d4:	30 0b       	mov	r11,0
800061d6:	02 9c       	mov	r12,r1
800061d8:	fe b0 fd 00 	rcall	80005bd8 <memset>
800061dc:	40 28       	lddsp	r8,sp[0x8]
800061de:	40 19       	lddsp	r9,sp[0x4]
800061e0:	e4 cc 00 01 	sub	r12,r2,1
800061e4:	0e 9b       	mov	r11,r7
800061e6:	50 3c       	stdsp	sp[0xc],r12
800061e8:	f2 0c 0c 49 	max	r9,r9,r12
800061ec:	c3 a8       	rjmp	80006260 <get_arg+0x268>
800061ee:	62 0a       	ld.w	r10,r1[0x0]
800061f0:	5b fa       	cp.w	r10,-1
800061f2:	c0 b1       	brne	80006208 <get_arg+0x210>
800061f4:	50 19       	stdsp	sp[0x4],r9
800061f6:	50 28       	stdsp	sp[0x8],r8
800061f8:	e0 6a 00 80 	mov	r10,128
800061fc:	30 0b       	mov	r11,0
800061fe:	02 9c       	mov	r12,r1
80006200:	fe b0 fc ec 	rcall	80005bd8 <memset>
80006204:	40 28       	lddsp	r8,sp[0x8]
80006206:	40 19       	lddsp	r9,sp[0x4]
80006208:	20 12       	sub	r2,1
8000620a:	30 0a       	mov	r10,0
8000620c:	0e 9b       	mov	r11,r7
8000620e:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80006212:	f2 02 0c 49 	max	r9,r9,r2
80006216:	c2 58       	rjmp	80006260 <get_arg+0x268>
80006218:	16 97       	mov	r7,r11
8000621a:	6c 0a       	ld.w	r10,r6[0x0]
8000621c:	f4 cb ff fc 	sub	r11,r10,-4
80006220:	8d 0b       	st.w	r6[0x0],r11
80006222:	74 0a       	ld.w	r10,r10[0x0]
80006224:	0e 9b       	mov	r11,r7
80006226:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000622a:	2f f5       	sub	r5,-1
8000622c:	c1 a8       	rjmp	80006260 <get_arg+0x268>
8000622e:	f4 c2 00 30 	sub	r2,r10,48
80006232:	c0 68       	rjmp	8000623e <get_arg+0x246>
80006234:	e4 02 00 22 	add	r2,r2,r2<<0x2
80006238:	2f f7       	sub	r7,-1
8000623a:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000623e:	0f 8a       	ld.ub	r10,r7[0x0]
80006240:	58 0a       	cp.w	r10,0
80006242:	c0 e0       	breq	8000625e <get_arg+0x266>
80006244:	23 0a       	sub	r10,48
80006246:	58 9a       	cp.w	r10,9
80006248:	fe 98 ff f6 	brls	80006234 <get_arg+0x23c>
8000624c:	c0 98       	rjmp	8000625e <get_arg+0x266>
8000624e:	2f f7       	sub	r7,-1
80006250:	0f 8a       	ld.ub	r10,r7[0x0]
80006252:	58 0a       	cp.w	r10,0
80006254:	c0 50       	breq	8000625e <get_arg+0x266>
80006256:	23 0a       	sub	r10,48
80006258:	58 9a       	cp.w	r10,9
8000625a:	fe 98 ff fa 	brls	8000624e <get_arg+0x256>
8000625e:	0e 9b       	mov	r11,r7
80006260:	40 7c       	lddsp	r12,sp[0x1c]
80006262:	30 ba       	mov	r10,11
80006264:	f4 0c 18 00 	cp.b	r12,r10
80006268:	fe 91 fe f2 	brne	8000604c <get_arg+0x54>
8000626c:	40 42       	lddsp	r2,sp[0x10]
8000626e:	17 8c       	ld.ub	r12,r11[0x0]
80006270:	0a 32       	cp.w	r2,r5
80006272:	5f 4a       	srge	r10
80006274:	f0 0c 18 00 	cp.b	r12,r8
80006278:	5f 1c       	srne	r12
8000627a:	f9 ea 00 0a 	and	r10,r12,r10
8000627e:	f0 0a 18 00 	cp.b	r10,r8
80006282:	fe 91 fe cf 	brne	80006020 <get_arg+0x28>
80006286:	30 08       	mov	r8,0
80006288:	40 4e       	lddsp	lr,sp[0x10]
8000628a:	17 8a       	ld.ub	r10,r11[0x0]
8000628c:	e2 05 00 21 	add	r1,r1,r5<<0x2
80006290:	f0 0a 18 00 	cp.b	r10,r8
80006294:	fc 09 17 10 	movne	r9,lr
80006298:	e6 05 00 38 	add	r8,r3,r5<<0x3
8000629c:	06 9e       	mov	lr,r3
8000629e:	c2 a8       	rjmp	800062f2 <get_arg+0x2fa>
800062a0:	62 0a       	ld.w	r10,r1[0x0]
800062a2:	58 3a       	cp.w	r10,3
800062a4:	c1 e0       	breq	800062e0 <get_arg+0x2e8>
800062a6:	e0 89 00 07 	brgt	800062b4 <get_arg+0x2bc>
800062aa:	58 1a       	cp.w	r10,1
800062ac:	c1 a0       	breq	800062e0 <get_arg+0x2e8>
800062ae:	58 2a       	cp.w	r10,2
800062b0:	c1 81       	brne	800062e0 <get_arg+0x2e8>
800062b2:	c0 58       	rjmp	800062bc <get_arg+0x2c4>
800062b4:	58 5a       	cp.w	r10,5
800062b6:	c0 c0       	breq	800062ce <get_arg+0x2d6>
800062b8:	c0 b5       	brlt	800062ce <get_arg+0x2d6>
800062ba:	c1 38       	rjmp	800062e0 <get_arg+0x2e8>
800062bc:	6c 0a       	ld.w	r10,r6[0x0]
800062be:	f4 cc ff f8 	sub	r12,r10,-8
800062c2:	8d 0c       	st.w	r6[0x0],r12
800062c4:	f4 e2 00 00 	ld.d	r2,r10[0]
800062c8:	f0 e3 00 00 	st.d	r8[0],r2
800062cc:	c1 08       	rjmp	800062ec <get_arg+0x2f4>
800062ce:	6c 0a       	ld.w	r10,r6[0x0]
800062d0:	f4 cc ff f8 	sub	r12,r10,-8
800062d4:	8d 0c       	st.w	r6[0x0],r12
800062d6:	f4 e2 00 00 	ld.d	r2,r10[0]
800062da:	f0 e3 00 00 	st.d	r8[0],r2
800062de:	c0 78       	rjmp	800062ec <get_arg+0x2f4>
800062e0:	6c 0a       	ld.w	r10,r6[0x0]
800062e2:	f4 cc ff fc 	sub	r12,r10,-4
800062e6:	8d 0c       	st.w	r6[0x0],r12
800062e8:	74 0a       	ld.w	r10,r10[0x0]
800062ea:	91 0a       	st.w	r8[0x0],r10
800062ec:	2f f5       	sub	r5,-1
800062ee:	2f 88       	sub	r8,-8
800062f0:	2f c1       	sub	r1,-4
800062f2:	12 35       	cp.w	r5,r9
800062f4:	fe 9a ff d6 	brle	800062a0 <get_arg+0x2a8>
800062f8:	1c 93       	mov	r3,lr
800062fa:	40 52       	lddsp	r2,sp[0x14]
800062fc:	40 6e       	lddsp	lr,sp[0x18]
800062fe:	85 05       	st.w	r2[0x0],r5
80006300:	9d 0b       	st.w	lr[0x0],r11
80006302:	40 4b       	lddsp	r11,sp[0x10]
80006304:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80006308:	2f 8d       	sub	sp,-32
8000630a:	d8 32       	popm	r0-r7,pc

8000630c <__sprint_r>:
8000630c:	d4 21       	pushm	r4-r7,lr
8000630e:	14 97       	mov	r7,r10
80006310:	74 28       	ld.w	r8,r10[0x8]
80006312:	58 08       	cp.w	r8,0
80006314:	c0 41       	brne	8000631c <__sprint_r+0x10>
80006316:	95 18       	st.w	r10[0x4],r8
80006318:	10 9c       	mov	r12,r8
8000631a:	d8 22       	popm	r4-r7,pc
8000631c:	e0 a0 18 ba 	rcall	80009490 <__sfvwrite_r>
80006320:	30 08       	mov	r8,0
80006322:	8f 18       	st.w	r7[0x4],r8
80006324:	8f 28       	st.w	r7[0x8],r8
80006326:	d8 22       	popm	r4-r7,pc

80006328 <_vfprintf_r>:
80006328:	d4 31       	pushm	r0-r7,lr
8000632a:	fa cd 06 bc 	sub	sp,sp,1724
8000632e:	51 09       	stdsp	sp[0x40],r9
80006330:	16 91       	mov	r1,r11
80006332:	14 97       	mov	r7,r10
80006334:	18 95       	mov	r5,r12
80006336:	e0 a0 1a 1d 	rcall	80009770 <_localeconv_r>
8000633a:	78 0c       	ld.w	r12,r12[0x0]
8000633c:	50 cc       	stdsp	sp[0x30],r12
8000633e:	58 05       	cp.w	r5,0
80006340:	c0 70       	breq	8000634e <_vfprintf_r+0x26>
80006342:	6a 68       	ld.w	r8,r5[0x18]
80006344:	58 08       	cp.w	r8,0
80006346:	c0 41       	brne	8000634e <_vfprintf_r+0x26>
80006348:	0a 9c       	mov	r12,r5
8000634a:	e0 a0 17 43 	rcall	800091d0 <__sinit>
8000634e:	fe c8 a1 3e 	sub	r8,pc,-24258
80006352:	10 31       	cp.w	r1,r8
80006354:	c0 31       	brne	8000635a <_vfprintf_r+0x32>
80006356:	6a 01       	ld.w	r1,r5[0x0]
80006358:	c0 c8       	rjmp	80006370 <_vfprintf_r+0x48>
8000635a:	fe c8 a1 2a 	sub	r8,pc,-24278
8000635e:	10 31       	cp.w	r1,r8
80006360:	c0 31       	brne	80006366 <_vfprintf_r+0x3e>
80006362:	6a 11       	ld.w	r1,r5[0x4]
80006364:	c0 68       	rjmp	80006370 <_vfprintf_r+0x48>
80006366:	fe c8 a1 16 	sub	r8,pc,-24298
8000636a:	10 31       	cp.w	r1,r8
8000636c:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80006370:	82 68       	ld.sh	r8,r1[0xc]
80006372:	ed b8 00 03 	bld	r8,0x3
80006376:	c0 41       	brne	8000637e <_vfprintf_r+0x56>
80006378:	62 48       	ld.w	r8,r1[0x10]
8000637a:	58 08       	cp.w	r8,0
8000637c:	c0 71       	brne	8000638a <_vfprintf_r+0x62>
8000637e:	02 9b       	mov	r11,r1
80006380:	0a 9c       	mov	r12,r5
80006382:	e0 a0 0f 5d 	rcall	8000823c <__swsetup_r>
80006386:	e0 81 0f 54 	brne	8000822e <_vfprintf_r+0x1f06>
8000638a:	82 68       	ld.sh	r8,r1[0xc]
8000638c:	10 99       	mov	r9,r8
8000638e:	e2 19 00 1a 	andl	r9,0x1a,COH
80006392:	58 a9       	cp.w	r9,10
80006394:	c3 c1       	brne	8000640c <_vfprintf_r+0xe4>
80006396:	82 79       	ld.sh	r9,r1[0xe]
80006398:	30 0a       	mov	r10,0
8000639a:	f4 09 19 00 	cp.h	r9,r10
8000639e:	c3 75       	brlt	8000640c <_vfprintf_r+0xe4>
800063a0:	a1 d8       	cbr	r8,0x1
800063a2:	fb 58 05 d0 	st.h	sp[1488],r8
800063a6:	62 88       	ld.w	r8,r1[0x20]
800063a8:	fb 48 05 e4 	st.w	sp[1508],r8
800063ac:	62 a8       	ld.w	r8,r1[0x28]
800063ae:	fb 48 05 ec 	st.w	sp[1516],r8
800063b2:	fa c8 ff bc 	sub	r8,sp,-68
800063b6:	fb 48 05 d4 	st.w	sp[1492],r8
800063ba:	fb 48 05 c4 	st.w	sp[1476],r8
800063be:	e0 68 04 00 	mov	r8,1024
800063c2:	fb 48 05 d8 	st.w	sp[1496],r8
800063c6:	fb 48 05 cc 	st.w	sp[1484],r8
800063ca:	30 08       	mov	r8,0
800063cc:	fb 59 05 d2 	st.h	sp[1490],r9
800063d0:	0e 9a       	mov	r10,r7
800063d2:	41 09       	lddsp	r9,sp[0x40]
800063d4:	fa c7 fa 3c 	sub	r7,sp,-1476
800063d8:	fb 48 05 dc 	st.w	sp[1500],r8
800063dc:	0a 9c       	mov	r12,r5
800063de:	0e 9b       	mov	r11,r7
800063e0:	ca 4f       	rcall	80006328 <_vfprintf_r>
800063e2:	50 bc       	stdsp	sp[0x2c],r12
800063e4:	c0 95       	brlt	800063f6 <_vfprintf_r+0xce>
800063e6:	0e 9b       	mov	r11,r7
800063e8:	0a 9c       	mov	r12,r5
800063ea:	e0 a0 16 1b 	rcall	80009020 <_fflush_r>
800063ee:	40 be       	lddsp	lr,sp[0x2c]
800063f0:	f9 be 01 ff 	movne	lr,-1
800063f4:	50 be       	stdsp	sp[0x2c],lr
800063f6:	fb 08 05 d0 	ld.sh	r8,sp[1488]
800063fa:	ed b8 00 06 	bld	r8,0x6
800063fe:	e0 81 0f 1a 	brne	80008232 <_vfprintf_r+0x1f0a>
80006402:	82 68       	ld.sh	r8,r1[0xc]
80006404:	a7 a8       	sbr	r8,0x6
80006406:	a2 68       	st.h	r1[0xc],r8
80006408:	e0 8f 0f 15 	bral	80008232 <_vfprintf_r+0x1f0a>
8000640c:	30 08       	mov	r8,0
8000640e:	fb 48 06 b4 	st.w	sp[1716],r8
80006412:	fb 48 06 90 	st.w	sp[1680],r8
80006416:	fb 48 06 8c 	st.w	sp[1676],r8
8000641a:	fb 48 06 b0 	st.w	sp[1712],r8
8000641e:	30 08       	mov	r8,0
80006420:	30 09       	mov	r9,0
80006422:	50 a7       	stdsp	sp[0x28],r7
80006424:	50 78       	stdsp	sp[0x1c],r8
80006426:	fa c3 f9 e0 	sub	r3,sp,-1568
8000642a:	3f f8       	mov	r8,-1
8000642c:	50 59       	stdsp	sp[0x14],r9
8000642e:	fb 43 06 88 	st.w	sp[1672],r3
80006432:	fb 48 05 44 	st.w	sp[1348],r8
80006436:	12 9c       	mov	r12,r9
80006438:	50 69       	stdsp	sp[0x18],r9
8000643a:	50 d9       	stdsp	sp[0x34],r9
8000643c:	50 e9       	stdsp	sp[0x38],r9
8000643e:	50 b9       	stdsp	sp[0x2c],r9
80006440:	12 97       	mov	r7,r9
80006442:	0a 94       	mov	r4,r5
80006444:	40 a2       	lddsp	r2,sp[0x28]
80006446:	32 5a       	mov	r10,37
80006448:	30 08       	mov	r8,0
8000644a:	c0 28       	rjmp	8000644e <_vfprintf_r+0x126>
8000644c:	2f f2       	sub	r2,-1
8000644e:	05 89       	ld.ub	r9,r2[0x0]
80006450:	f0 09 18 00 	cp.b	r9,r8
80006454:	5f 1b       	srne	r11
80006456:	f4 09 18 00 	cp.b	r9,r10
8000645a:	5f 19       	srne	r9
8000645c:	f3 eb 00 0b 	and	r11,r9,r11
80006460:	f0 0b 18 00 	cp.b	r11,r8
80006464:	cf 41       	brne	8000644c <_vfprintf_r+0x124>
80006466:	40 ab       	lddsp	r11,sp[0x28]
80006468:	e4 0b 01 06 	sub	r6,r2,r11
8000646c:	c1 e0       	breq	800064a8 <_vfprintf_r+0x180>
8000646e:	fa f8 06 90 	ld.w	r8,sp[1680]
80006472:	0c 08       	add	r8,r6
80006474:	87 0b       	st.w	r3[0x0],r11
80006476:	fb 48 06 90 	st.w	sp[1680],r8
8000647a:	87 16       	st.w	r3[0x4],r6
8000647c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80006480:	2f f8       	sub	r8,-1
80006482:	fb 48 06 8c 	st.w	sp[1676],r8
80006486:	58 78       	cp.w	r8,7
80006488:	e0 89 00 04 	brgt	80006490 <_vfprintf_r+0x168>
8000648c:	2f 83       	sub	r3,-8
8000648e:	c0 a8       	rjmp	800064a2 <_vfprintf_r+0x17a>
80006490:	fa ca f9 78 	sub	r10,sp,-1672
80006494:	02 9b       	mov	r11,r1
80006496:	08 9c       	mov	r12,r4
80006498:	c3 af       	rcall	8000630c <__sprint_r>
8000649a:	e0 81 0e c6 	brne	80008226 <_vfprintf_r+0x1efe>
8000649e:	fa c3 f9 e0 	sub	r3,sp,-1568
800064a2:	40 ba       	lddsp	r10,sp[0x2c]
800064a4:	0c 0a       	add	r10,r6
800064a6:	50 ba       	stdsp	sp[0x2c],r10
800064a8:	05 89       	ld.ub	r9,r2[0x0]
800064aa:	30 08       	mov	r8,0
800064ac:	f0 09 18 00 	cp.b	r9,r8
800064b0:	e0 80 0e aa 	breq	80008204 <_vfprintf_r+0x1edc>
800064b4:	30 09       	mov	r9,0
800064b6:	fb 68 06 bb 	st.b	sp[1723],r8
800064ba:	0e 96       	mov	r6,r7
800064bc:	e4 c8 ff ff 	sub	r8,r2,-1
800064c0:	3f fe       	mov	lr,-1
800064c2:	50 93       	stdsp	sp[0x24],r3
800064c4:	50 41       	stdsp	sp[0x10],r1
800064c6:	0e 93       	mov	r3,r7
800064c8:	04 91       	mov	r1,r2
800064ca:	50 89       	stdsp	sp[0x20],r9
800064cc:	50 a8       	stdsp	sp[0x28],r8
800064ce:	50 2e       	stdsp	sp[0x8],lr
800064d0:	50 39       	stdsp	sp[0xc],r9
800064d2:	12 95       	mov	r5,r9
800064d4:	12 90       	mov	r0,r9
800064d6:	10 97       	mov	r7,r8
800064d8:	08 92       	mov	r2,r4
800064da:	c0 78       	rjmp	800064e8 <_vfprintf_r+0x1c0>
800064dc:	3f fc       	mov	r12,-1
800064de:	08 97       	mov	r7,r4
800064e0:	50 2c       	stdsp	sp[0x8],r12
800064e2:	c0 38       	rjmp	800064e8 <_vfprintf_r+0x1c0>
800064e4:	30 0b       	mov	r11,0
800064e6:	50 3b       	stdsp	sp[0xc],r11
800064e8:	0f 38       	ld.ub	r8,r7++
800064ea:	c0 28       	rjmp	800064ee <_vfprintf_r+0x1c6>
800064ec:	12 90       	mov	r0,r9
800064ee:	f0 c9 00 20 	sub	r9,r8,32
800064f2:	e0 49 00 58 	cp.w	r9,88
800064f6:	e0 8b 0a 30 	brhi	80007956 <_vfprintf_r+0x162e>
800064fa:	fe ca a6 92 	sub	r10,pc,-22894
800064fe:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80006502:	50 a7       	stdsp	sp[0x28],r7
80006504:	50 80       	stdsp	sp[0x20],r0
80006506:	0c 97       	mov	r7,r6
80006508:	04 94       	mov	r4,r2
8000650a:	06 96       	mov	r6,r3
8000650c:	02 92       	mov	r2,r1
8000650e:	fe c9 a4 6a 	sub	r9,pc,-23446
80006512:	40 93       	lddsp	r3,sp[0x24]
80006514:	10 90       	mov	r0,r8
80006516:	40 41       	lddsp	r1,sp[0x10]
80006518:	50 d9       	stdsp	sp[0x34],r9
8000651a:	e0 8f 08 8e 	bral	80007636 <_vfprintf_r+0x130e>
8000651e:	30 08       	mov	r8,0
80006520:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80006524:	f0 09 18 00 	cp.b	r9,r8
80006528:	ce 01       	brne	800064e8 <_vfprintf_r+0x1c0>
8000652a:	32 08       	mov	r8,32
8000652c:	c6 e8       	rjmp	80006608 <_vfprintf_r+0x2e0>
8000652e:	a1 a5       	sbr	r5,0x0
80006530:	cd cb       	rjmp	800064e8 <_vfprintf_r+0x1c0>
80006532:	0f 89       	ld.ub	r9,r7[0x0]
80006534:	f2 c8 00 30 	sub	r8,r9,48
80006538:	58 98       	cp.w	r8,9
8000653a:	e0 8b 00 1d 	brhi	80006574 <_vfprintf_r+0x24c>
8000653e:	ee c8 ff ff 	sub	r8,r7,-1
80006542:	30 0b       	mov	r11,0
80006544:	23 09       	sub	r9,48
80006546:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000654a:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000654e:	11 39       	ld.ub	r9,r8++
80006550:	f2 ca 00 30 	sub	r10,r9,48
80006554:	58 9a       	cp.w	r10,9
80006556:	fe 98 ff f7 	brls	80006544 <_vfprintf_r+0x21c>
8000655a:	e0 49 00 24 	cp.w	r9,36
8000655e:	cc 31       	brne	800064e4 <_vfprintf_r+0x1bc>
80006560:	e0 4b 00 20 	cp.w	r11,32
80006564:	e0 89 0e 60 	brgt	80008224 <_vfprintf_r+0x1efc>
80006568:	20 1b       	sub	r11,1
8000656a:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000656e:	12 3b       	cp.w	r11,r9
80006570:	c0 95       	brlt	80006582 <_vfprintf_r+0x25a>
80006572:	c1 08       	rjmp	80006592 <_vfprintf_r+0x26a>
80006574:	fa f9 06 b4 	ld.w	r9,sp[1716]
80006578:	ec ca ff ff 	sub	r10,r6,-1
8000657c:	12 36       	cp.w	r6,r9
8000657e:	c1 f5       	brlt	800065bc <_vfprintf_r+0x294>
80006580:	c2 68       	rjmp	800065cc <_vfprintf_r+0x2a4>
80006582:	fa ce f9 44 	sub	lr,sp,-1724
80006586:	10 97       	mov	r7,r8
80006588:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
8000658c:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80006590:	c3 58       	rjmp	800065fa <_vfprintf_r+0x2d2>
80006592:	10 97       	mov	r7,r8
80006594:	fa c8 f9 50 	sub	r8,sp,-1712
80006598:	1a d8       	st.w	--sp,r8
8000659a:	fa c8 fa b8 	sub	r8,sp,-1352
8000659e:	1a d8       	st.w	--sp,r8
800065a0:	fa c8 fb b4 	sub	r8,sp,-1100
800065a4:	02 9a       	mov	r10,r1
800065a6:	1a d8       	st.w	--sp,r8
800065a8:	04 9c       	mov	r12,r2
800065aa:	fa c8 f9 40 	sub	r8,sp,-1728
800065ae:	fa c9 ff b4 	sub	r9,sp,-76
800065b2:	fe b0 fd 23 	rcall	80005ff8 <get_arg>
800065b6:	2f dd       	sub	sp,-12
800065b8:	78 00       	ld.w	r0,r12[0x0]
800065ba:	c2 08       	rjmp	800065fa <_vfprintf_r+0x2d2>
800065bc:	fa cc f9 44 	sub	r12,sp,-1724
800065c0:	14 96       	mov	r6,r10
800065c2:	f8 03 00 38 	add	r8,r12,r3<<0x3
800065c6:	f0 f0 fd 88 	ld.w	r0,r8[-632]
800065ca:	c1 88       	rjmp	800065fa <_vfprintf_r+0x2d2>
800065cc:	41 08       	lddsp	r8,sp[0x40]
800065ce:	59 f9       	cp.w	r9,31
800065d0:	e0 89 00 11 	brgt	800065f2 <_vfprintf_r+0x2ca>
800065d4:	f0 cb ff fc 	sub	r11,r8,-4
800065d8:	51 0b       	stdsp	sp[0x40],r11
800065da:	70 00       	ld.w	r0,r8[0x0]
800065dc:	fa cb f9 44 	sub	r11,sp,-1724
800065e0:	f6 09 00 38 	add	r8,r11,r9<<0x3
800065e4:	f1 40 fd 88 	st.w	r8[-632],r0
800065e8:	2f f9       	sub	r9,-1
800065ea:	14 96       	mov	r6,r10
800065ec:	fb 49 06 b4 	st.w	sp[1716],r9
800065f0:	c0 58       	rjmp	800065fa <_vfprintf_r+0x2d2>
800065f2:	70 00       	ld.w	r0,r8[0x0]
800065f4:	14 96       	mov	r6,r10
800065f6:	2f c8       	sub	r8,-4
800065f8:	51 08       	stdsp	sp[0x40],r8
800065fa:	58 00       	cp.w	r0,0
800065fc:	fe 94 ff 76 	brge	800064e8 <_vfprintf_r+0x1c0>
80006600:	5c 30       	neg	r0
80006602:	a3 a5       	sbr	r5,0x2
80006604:	c7 2b       	rjmp	800064e8 <_vfprintf_r+0x1c0>
80006606:	32 b8       	mov	r8,43
80006608:	fb 68 06 bb 	st.b	sp[1723],r8
8000660c:	c6 eb       	rjmp	800064e8 <_vfprintf_r+0x1c0>
8000660e:	0f 38       	ld.ub	r8,r7++
80006610:	e0 48 00 2a 	cp.w	r8,42
80006614:	c0 30       	breq	8000661a <_vfprintf_r+0x2f2>
80006616:	30 09       	mov	r9,0
80006618:	c7 98       	rjmp	8000670a <_vfprintf_r+0x3e2>
8000661a:	0f 88       	ld.ub	r8,r7[0x0]
8000661c:	f0 c9 00 30 	sub	r9,r8,48
80006620:	58 99       	cp.w	r9,9
80006622:	e0 8b 00 1f 	brhi	80006660 <_vfprintf_r+0x338>
80006626:	ee c4 ff ff 	sub	r4,r7,-1
8000662a:	30 0b       	mov	r11,0
8000662c:	23 08       	sub	r8,48
8000662e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80006632:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80006636:	09 38       	ld.ub	r8,r4++
80006638:	f0 c9 00 30 	sub	r9,r8,48
8000663c:	58 99       	cp.w	r9,9
8000663e:	fe 98 ff f7 	brls	8000662c <_vfprintf_r+0x304>
80006642:	e0 48 00 24 	cp.w	r8,36
80006646:	fe 91 ff 4f 	brne	800064e4 <_vfprintf_r+0x1bc>
8000664a:	e0 4b 00 20 	cp.w	r11,32
8000664e:	e0 89 0d eb 	brgt	80008224 <_vfprintf_r+0x1efc>
80006652:	20 1b       	sub	r11,1
80006654:	fa f8 06 b4 	ld.w	r8,sp[1716]
80006658:	10 3b       	cp.w	r11,r8
8000665a:	c0 a5       	brlt	8000666e <_vfprintf_r+0x346>
8000665c:	c1 18       	rjmp	8000667e <_vfprintf_r+0x356>
8000665e:	d7 03       	nop
80006660:	fa fa 06 b4 	ld.w	r10,sp[1716]
80006664:	ec c9 ff ff 	sub	r9,r6,-1
80006668:	14 36       	cp.w	r6,r10
8000666a:	c1 f5       	brlt	800066a8 <_vfprintf_r+0x380>
8000666c:	c2 88       	rjmp	800066bc <_vfprintf_r+0x394>
8000666e:	fa ca f9 44 	sub	r10,sp,-1724
80006672:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80006676:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000667a:	50 2b       	stdsp	sp[0x8],r11
8000667c:	c3 c8       	rjmp	800066f4 <_vfprintf_r+0x3cc>
8000667e:	fa c8 f9 50 	sub	r8,sp,-1712
80006682:	1a d8       	st.w	--sp,r8
80006684:	fa c8 fa b8 	sub	r8,sp,-1352
80006688:	1a d8       	st.w	--sp,r8
8000668a:	fa c8 fb b4 	sub	r8,sp,-1100
8000668e:	02 9a       	mov	r10,r1
80006690:	1a d8       	st.w	--sp,r8
80006692:	04 9c       	mov	r12,r2
80006694:	fa c8 f9 40 	sub	r8,sp,-1728
80006698:	fa c9 ff b4 	sub	r9,sp,-76
8000669c:	fe b0 fc ae 	rcall	80005ff8 <get_arg>
800066a0:	2f dd       	sub	sp,-12
800066a2:	78 0c       	ld.w	r12,r12[0x0]
800066a4:	50 2c       	stdsp	sp[0x8],r12
800066a6:	c2 78       	rjmp	800066f4 <_vfprintf_r+0x3cc>
800066a8:	12 96       	mov	r6,r9
800066aa:	0e 94       	mov	r4,r7
800066ac:	fa c9 f9 44 	sub	r9,sp,-1724
800066b0:	f2 03 00 38 	add	r8,r9,r3<<0x3
800066b4:	f0 f8 fd 88 	ld.w	r8,r8[-632]
800066b8:	50 28       	stdsp	sp[0x8],r8
800066ba:	c1 d8       	rjmp	800066f4 <_vfprintf_r+0x3cc>
800066bc:	41 08       	lddsp	r8,sp[0x40]
800066be:	59 fa       	cp.w	r10,31
800066c0:	e0 89 00 14 	brgt	800066e8 <_vfprintf_r+0x3c0>
800066c4:	f0 cb ff fc 	sub	r11,r8,-4
800066c8:	70 08       	ld.w	r8,r8[0x0]
800066ca:	51 0b       	stdsp	sp[0x40],r11
800066cc:	50 28       	stdsp	sp[0x8],r8
800066ce:	fa c6 f9 44 	sub	r6,sp,-1724
800066d2:	40 2e       	lddsp	lr,sp[0x8]
800066d4:	ec 0a 00 38 	add	r8,r6,r10<<0x3
800066d8:	f1 4e fd 88 	st.w	r8[-632],lr
800066dc:	2f fa       	sub	r10,-1
800066de:	0e 94       	mov	r4,r7
800066e0:	fb 4a 06 b4 	st.w	sp[1716],r10
800066e4:	12 96       	mov	r6,r9
800066e6:	c0 78       	rjmp	800066f4 <_vfprintf_r+0x3cc>
800066e8:	70 0c       	ld.w	r12,r8[0x0]
800066ea:	0e 94       	mov	r4,r7
800066ec:	2f c8       	sub	r8,-4
800066ee:	50 2c       	stdsp	sp[0x8],r12
800066f0:	12 96       	mov	r6,r9
800066f2:	51 08       	stdsp	sp[0x40],r8
800066f4:	40 2b       	lddsp	r11,sp[0x8]
800066f6:	58 0b       	cp.w	r11,0
800066f8:	fe 95 fe f2 	brlt	800064dc <_vfprintf_r+0x1b4>
800066fc:	08 97       	mov	r7,r4
800066fe:	cf 5a       	rjmp	800064e8 <_vfprintf_r+0x1c0>
80006700:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006704:	0f 38       	ld.ub	r8,r7++
80006706:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000670a:	f0 ca 00 30 	sub	r10,r8,48
8000670e:	58 9a       	cp.w	r10,9
80006710:	fe 98 ff f8 	brls	80006700 <_vfprintf_r+0x3d8>
80006714:	3f fa       	mov	r10,-1
80006716:	f2 0a 0c 49 	max	r9,r9,r10
8000671a:	50 29       	stdsp	sp[0x8],r9
8000671c:	ce 9a       	rjmp	800064ee <_vfprintf_r+0x1c6>
8000671e:	a7 b5       	sbr	r5,0x7
80006720:	ce 4a       	rjmp	800064e8 <_vfprintf_r+0x1c0>
80006722:	30 09       	mov	r9,0
80006724:	23 08       	sub	r8,48
80006726:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000672a:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000672e:	0f 38       	ld.ub	r8,r7++
80006730:	f0 ca 00 30 	sub	r10,r8,48
80006734:	58 9a       	cp.w	r10,9
80006736:	fe 98 ff f7 	brls	80006724 <_vfprintf_r+0x3fc>
8000673a:	e0 48 00 24 	cp.w	r8,36
8000673e:	fe 91 fe d7 	brne	800064ec <_vfprintf_r+0x1c4>
80006742:	e0 49 00 20 	cp.w	r9,32
80006746:	e0 89 0d 6f 	brgt	80008224 <_vfprintf_r+0x1efc>
8000674a:	f2 c3 00 01 	sub	r3,r9,1
8000674e:	30 19       	mov	r9,1
80006750:	50 39       	stdsp	sp[0xc],r9
80006752:	cc ba       	rjmp	800064e8 <_vfprintf_r+0x1c0>
80006754:	a3 b5       	sbr	r5,0x3
80006756:	cc 9a       	rjmp	800064e8 <_vfprintf_r+0x1c0>
80006758:	a7 a5       	sbr	r5,0x6
8000675a:	cc 7a       	rjmp	800064e8 <_vfprintf_r+0x1c0>
8000675c:	0a 98       	mov	r8,r5
8000675e:	a5 b5       	sbr	r5,0x5
80006760:	a5 a8       	sbr	r8,0x4
80006762:	0f 89       	ld.ub	r9,r7[0x0]
80006764:	36 ce       	mov	lr,108
80006766:	fc 09 18 00 	cp.b	r9,lr
8000676a:	f7 b7 00 ff 	subeq	r7,-1
8000676e:	f0 05 17 10 	movne	r5,r8
80006772:	cb ba       	rjmp	800064e8 <_vfprintf_r+0x1c0>
80006774:	a5 b5       	sbr	r5,0x5
80006776:	cb 9a       	rjmp	800064e8 <_vfprintf_r+0x1c0>
80006778:	50 a7       	stdsp	sp[0x28],r7
8000677a:	50 80       	stdsp	sp[0x20],r0
8000677c:	0c 97       	mov	r7,r6
8000677e:	10 90       	mov	r0,r8
80006780:	06 96       	mov	r6,r3
80006782:	04 94       	mov	r4,r2
80006784:	40 93       	lddsp	r3,sp[0x24]
80006786:	02 92       	mov	r2,r1
80006788:	0e 99       	mov	r9,r7
8000678a:	40 41       	lddsp	r1,sp[0x10]
8000678c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80006790:	40 3c       	lddsp	r12,sp[0xc]
80006792:	58 0c       	cp.w	r12,0
80006794:	c1 d0       	breq	800067ce <_vfprintf_r+0x4a6>
80006796:	10 36       	cp.w	r6,r8
80006798:	c0 64       	brge	800067a4 <_vfprintf_r+0x47c>
8000679a:	fa cb f9 44 	sub	r11,sp,-1724
8000679e:	f6 06 00 36 	add	r6,r11,r6<<0x3
800067a2:	c1 d8       	rjmp	800067dc <_vfprintf_r+0x4b4>
800067a4:	fa c8 f9 50 	sub	r8,sp,-1712
800067a8:	1a d8       	st.w	--sp,r8
800067aa:	fa c8 fa b8 	sub	r8,sp,-1352
800067ae:	1a d8       	st.w	--sp,r8
800067b0:	fa c8 fb b4 	sub	r8,sp,-1100
800067b4:	1a d8       	st.w	--sp,r8
800067b6:	fa c8 f9 40 	sub	r8,sp,-1728
800067ba:	fa c9 ff b4 	sub	r9,sp,-76
800067be:	04 9a       	mov	r10,r2
800067c0:	0c 9b       	mov	r11,r6
800067c2:	08 9c       	mov	r12,r4
800067c4:	fe b0 fc 1a 	rcall	80005ff8 <get_arg>
800067c8:	2f dd       	sub	sp,-12
800067ca:	19 b8       	ld.ub	r8,r12[0x3]
800067cc:	c2 28       	rjmp	80006810 <_vfprintf_r+0x4e8>
800067ce:	2f f7       	sub	r7,-1
800067d0:	10 39       	cp.w	r9,r8
800067d2:	c0 84       	brge	800067e2 <_vfprintf_r+0x4ba>
800067d4:	fa ca f9 44 	sub	r10,sp,-1724
800067d8:	f4 06 00 36 	add	r6,r10,r6<<0x3
800067dc:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
800067e0:	c1 88       	rjmp	80006810 <_vfprintf_r+0x4e8>
800067e2:	41 09       	lddsp	r9,sp[0x40]
800067e4:	59 f8       	cp.w	r8,31
800067e6:	e0 89 00 12 	brgt	8000680a <_vfprintf_r+0x4e2>
800067ea:	f2 ca ff fc 	sub	r10,r9,-4
800067ee:	51 0a       	stdsp	sp[0x40],r10
800067f0:	72 09       	ld.w	r9,r9[0x0]
800067f2:	fa c6 f9 44 	sub	r6,sp,-1724
800067f6:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800067fa:	2f f8       	sub	r8,-1
800067fc:	f5 49 fd 88 	st.w	r10[-632],r9
80006800:	fb 48 06 b4 	st.w	sp[1716],r8
80006804:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80006808:	c0 48       	rjmp	80006810 <_vfprintf_r+0x4e8>
8000680a:	13 b8       	ld.ub	r8,r9[0x3]
8000680c:	2f c9       	sub	r9,-4
8000680e:	51 09       	stdsp	sp[0x40],r9
80006810:	fb 68 06 60 	st.b	sp[1632],r8
80006814:	30 0e       	mov	lr,0
80006816:	30 08       	mov	r8,0
80006818:	30 12       	mov	r2,1
8000681a:	fb 68 06 bb 	st.b	sp[1723],r8
8000681e:	50 2e       	stdsp	sp[0x8],lr
80006820:	e0 8f 08 ad 	bral	8000797a <_vfprintf_r+0x1652>
80006824:	50 a7       	stdsp	sp[0x28],r7
80006826:	50 80       	stdsp	sp[0x20],r0
80006828:	0c 97       	mov	r7,r6
8000682a:	04 94       	mov	r4,r2
8000682c:	06 96       	mov	r6,r3
8000682e:	02 92       	mov	r2,r1
80006830:	40 93       	lddsp	r3,sp[0x24]
80006832:	10 90       	mov	r0,r8
80006834:	40 41       	lddsp	r1,sp[0x10]
80006836:	a5 a5       	sbr	r5,0x4
80006838:	c0 a8       	rjmp	8000684c <_vfprintf_r+0x524>
8000683a:	50 a7       	stdsp	sp[0x28],r7
8000683c:	50 80       	stdsp	sp[0x20],r0
8000683e:	0c 97       	mov	r7,r6
80006840:	04 94       	mov	r4,r2
80006842:	06 96       	mov	r6,r3
80006844:	02 92       	mov	r2,r1
80006846:	40 93       	lddsp	r3,sp[0x24]
80006848:	10 90       	mov	r0,r8
8000684a:	40 41       	lddsp	r1,sp[0x10]
8000684c:	ed b5 00 05 	bld	r5,0x5
80006850:	c5 11       	brne	800068f2 <_vfprintf_r+0x5ca>
80006852:	fa f8 06 b4 	ld.w	r8,sp[1716]
80006856:	40 3c       	lddsp	r12,sp[0xc]
80006858:	58 0c       	cp.w	r12,0
8000685a:	c1 e0       	breq	80006896 <_vfprintf_r+0x56e>
8000685c:	10 36       	cp.w	r6,r8
8000685e:	c0 64       	brge	8000686a <_vfprintf_r+0x542>
80006860:	fa cb f9 44 	sub	r11,sp,-1724
80006864:	f6 06 00 36 	add	r6,r11,r6<<0x3
80006868:	c2 08       	rjmp	800068a8 <_vfprintf_r+0x580>
8000686a:	fa c8 f9 50 	sub	r8,sp,-1712
8000686e:	1a d8       	st.w	--sp,r8
80006870:	fa c8 fa b8 	sub	r8,sp,-1352
80006874:	0c 9b       	mov	r11,r6
80006876:	1a d8       	st.w	--sp,r8
80006878:	fa c8 fb b4 	sub	r8,sp,-1100
8000687c:	1a d8       	st.w	--sp,r8
8000687e:	fa c9 ff b4 	sub	r9,sp,-76
80006882:	fa c8 f9 40 	sub	r8,sp,-1728
80006886:	04 9a       	mov	r10,r2
80006888:	08 9c       	mov	r12,r4
8000688a:	fe b0 fb b7 	rcall	80005ff8 <get_arg>
8000688e:	2f dd       	sub	sp,-12
80006890:	78 1b       	ld.w	r11,r12[0x4]
80006892:	78 09       	ld.w	r9,r12[0x0]
80006894:	c2 b8       	rjmp	800068ea <_vfprintf_r+0x5c2>
80006896:	ee ca ff ff 	sub	r10,r7,-1
8000689a:	10 37       	cp.w	r7,r8
8000689c:	c0 b4       	brge	800068b2 <_vfprintf_r+0x58a>
8000689e:	fa c9 f9 44 	sub	r9,sp,-1724
800068a2:	14 97       	mov	r7,r10
800068a4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800068a8:	ec fb fd 8c 	ld.w	r11,r6[-628]
800068ac:	ec f9 fd 88 	ld.w	r9,r6[-632]
800068b0:	c1 d8       	rjmp	800068ea <_vfprintf_r+0x5c2>
800068b2:	41 09       	lddsp	r9,sp[0x40]
800068b4:	59 f8       	cp.w	r8,31
800068b6:	e0 89 00 14 	brgt	800068de <_vfprintf_r+0x5b6>
800068ba:	f2 cb ff f8 	sub	r11,r9,-8
800068be:	51 0b       	stdsp	sp[0x40],r11
800068c0:	fa c6 f9 44 	sub	r6,sp,-1724
800068c4:	72 1b       	ld.w	r11,r9[0x4]
800068c6:	ec 08 00 3c 	add	r12,r6,r8<<0x3
800068ca:	72 09       	ld.w	r9,r9[0x0]
800068cc:	f9 4b fd 8c 	st.w	r12[-628],r11
800068d0:	f9 49 fd 88 	st.w	r12[-632],r9
800068d4:	2f f8       	sub	r8,-1
800068d6:	14 97       	mov	r7,r10
800068d8:	fb 48 06 b4 	st.w	sp[1716],r8
800068dc:	c0 78       	rjmp	800068ea <_vfprintf_r+0x5c2>
800068de:	f2 c8 ff f8 	sub	r8,r9,-8
800068e2:	72 1b       	ld.w	r11,r9[0x4]
800068e4:	14 97       	mov	r7,r10
800068e6:	51 08       	stdsp	sp[0x40],r8
800068e8:	72 09       	ld.w	r9,r9[0x0]
800068ea:	16 98       	mov	r8,r11
800068ec:	fa e9 00 00 	st.d	sp[0],r8
800068f0:	ca e8       	rjmp	80006a4c <_vfprintf_r+0x724>
800068f2:	ed b5 00 04 	bld	r5,0x4
800068f6:	c1 71       	brne	80006924 <_vfprintf_r+0x5fc>
800068f8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800068fc:	40 3e       	lddsp	lr,sp[0xc]
800068fe:	58 0e       	cp.w	lr,0
80006900:	c0 80       	breq	80006910 <_vfprintf_r+0x5e8>
80006902:	10 36       	cp.w	r6,r8
80006904:	c6 94       	brge	800069d6 <_vfprintf_r+0x6ae>
80006906:	fa cc f9 44 	sub	r12,sp,-1724
8000690a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000690e:	c8 28       	rjmp	80006a12 <_vfprintf_r+0x6ea>
80006910:	ee ca ff ff 	sub	r10,r7,-1
80006914:	10 37       	cp.w	r7,r8
80006916:	e0 84 00 81 	brge	80006a18 <_vfprintf_r+0x6f0>
8000691a:	fa cb f9 44 	sub	r11,sp,-1724
8000691e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80006922:	c7 78       	rjmp	80006a10 <_vfprintf_r+0x6e8>
80006924:	ed b5 00 06 	bld	r5,0x6
80006928:	c4 b1       	brne	800069be <_vfprintf_r+0x696>
8000692a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000692e:	40 3c       	lddsp	r12,sp[0xc]
80006930:	58 0c       	cp.w	r12,0
80006932:	c1 d0       	breq	8000696c <_vfprintf_r+0x644>
80006934:	10 36       	cp.w	r6,r8
80006936:	c0 64       	brge	80006942 <_vfprintf_r+0x61a>
80006938:	fa cb f9 44 	sub	r11,sp,-1724
8000693c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80006940:	c1 f8       	rjmp	8000697e <_vfprintf_r+0x656>
80006942:	fa c8 f9 50 	sub	r8,sp,-1712
80006946:	1a d8       	st.w	--sp,r8
80006948:	fa c8 fa b8 	sub	r8,sp,-1352
8000694c:	1a d8       	st.w	--sp,r8
8000694e:	fa c8 fb b4 	sub	r8,sp,-1100
80006952:	1a d8       	st.w	--sp,r8
80006954:	fa c8 f9 40 	sub	r8,sp,-1728
80006958:	fa c9 ff b4 	sub	r9,sp,-76
8000695c:	04 9a       	mov	r10,r2
8000695e:	0c 9b       	mov	r11,r6
80006960:	08 9c       	mov	r12,r4
80006962:	fe b0 fb 4b 	rcall	80005ff8 <get_arg>
80006966:	2f dd       	sub	sp,-12
80006968:	98 18       	ld.sh	r8,r12[0x2]
8000696a:	c2 68       	rjmp	800069b6 <_vfprintf_r+0x68e>
8000696c:	ee ca ff ff 	sub	r10,r7,-1
80006970:	10 37       	cp.w	r7,r8
80006972:	c0 94       	brge	80006984 <_vfprintf_r+0x65c>
80006974:	fa c9 f9 44 	sub	r9,sp,-1724
80006978:	14 97       	mov	r7,r10
8000697a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000697e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80006982:	c1 a8       	rjmp	800069b6 <_vfprintf_r+0x68e>
80006984:	41 09       	lddsp	r9,sp[0x40]
80006986:	59 f8       	cp.w	r8,31
80006988:	e0 89 00 13 	brgt	800069ae <_vfprintf_r+0x686>
8000698c:	f2 cb ff fc 	sub	r11,r9,-4
80006990:	51 0b       	stdsp	sp[0x40],r11
80006992:	72 09       	ld.w	r9,r9[0x0]
80006994:	fa c6 f9 44 	sub	r6,sp,-1724
80006998:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000699c:	2f f8       	sub	r8,-1
8000699e:	f7 49 fd 88 	st.w	r11[-632],r9
800069a2:	fb 48 06 b4 	st.w	sp[1716],r8
800069a6:	14 97       	mov	r7,r10
800069a8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800069ac:	c0 58       	rjmp	800069b6 <_vfprintf_r+0x68e>
800069ae:	92 18       	ld.sh	r8,r9[0x2]
800069b0:	14 97       	mov	r7,r10
800069b2:	2f c9       	sub	r9,-4
800069b4:	51 09       	stdsp	sp[0x40],r9
800069b6:	50 18       	stdsp	sp[0x4],r8
800069b8:	bf 58       	asr	r8,0x1f
800069ba:	50 08       	stdsp	sp[0x0],r8
800069bc:	c4 88       	rjmp	80006a4c <_vfprintf_r+0x724>
800069be:	fa f8 06 b4 	ld.w	r8,sp[1716]
800069c2:	40 3c       	lddsp	r12,sp[0xc]
800069c4:	58 0c       	cp.w	r12,0
800069c6:	c1 d0       	breq	80006a00 <_vfprintf_r+0x6d8>
800069c8:	10 36       	cp.w	r6,r8
800069ca:	c0 64       	brge	800069d6 <_vfprintf_r+0x6ae>
800069cc:	fa cb f9 44 	sub	r11,sp,-1724
800069d0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800069d4:	c1 f8       	rjmp	80006a12 <_vfprintf_r+0x6ea>
800069d6:	fa c8 f9 50 	sub	r8,sp,-1712
800069da:	1a d8       	st.w	--sp,r8
800069dc:	fa c8 fa b8 	sub	r8,sp,-1352
800069e0:	0c 9b       	mov	r11,r6
800069e2:	1a d8       	st.w	--sp,r8
800069e4:	fa c8 fb b4 	sub	r8,sp,-1100
800069e8:	04 9a       	mov	r10,r2
800069ea:	1a d8       	st.w	--sp,r8
800069ec:	08 9c       	mov	r12,r4
800069ee:	fa c8 f9 40 	sub	r8,sp,-1728
800069f2:	fa c9 ff b4 	sub	r9,sp,-76
800069f6:	fe b0 fb 01 	rcall	80005ff8 <get_arg>
800069fa:	2f dd       	sub	sp,-12
800069fc:	78 0b       	ld.w	r11,r12[0x0]
800069fe:	c2 48       	rjmp	80006a46 <_vfprintf_r+0x71e>
80006a00:	ee ca ff ff 	sub	r10,r7,-1
80006a04:	10 37       	cp.w	r7,r8
80006a06:	c0 94       	brge	80006a18 <_vfprintf_r+0x6f0>
80006a08:	fa c9 f9 44 	sub	r9,sp,-1724
80006a0c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80006a10:	14 97       	mov	r7,r10
80006a12:	ec fb fd 88 	ld.w	r11,r6[-632]
80006a16:	c1 88       	rjmp	80006a46 <_vfprintf_r+0x71e>
80006a18:	41 09       	lddsp	r9,sp[0x40]
80006a1a:	59 f8       	cp.w	r8,31
80006a1c:	e0 89 00 11 	brgt	80006a3e <_vfprintf_r+0x716>
80006a20:	f2 cb ff fc 	sub	r11,r9,-4
80006a24:	51 0b       	stdsp	sp[0x40],r11
80006a26:	fa c6 f9 44 	sub	r6,sp,-1724
80006a2a:	72 0b       	ld.w	r11,r9[0x0]
80006a2c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80006a30:	f3 4b fd 88 	st.w	r9[-632],r11
80006a34:	2f f8       	sub	r8,-1
80006a36:	14 97       	mov	r7,r10
80006a38:	fb 48 06 b4 	st.w	sp[1716],r8
80006a3c:	c0 58       	rjmp	80006a46 <_vfprintf_r+0x71e>
80006a3e:	72 0b       	ld.w	r11,r9[0x0]
80006a40:	14 97       	mov	r7,r10
80006a42:	2f c9       	sub	r9,-4
80006a44:	51 09       	stdsp	sp[0x40],r9
80006a46:	50 1b       	stdsp	sp[0x4],r11
80006a48:	bf 5b       	asr	r11,0x1f
80006a4a:	50 0b       	stdsp	sp[0x0],r11
80006a4c:	fa ea 00 00 	ld.d	r10,sp[0]
80006a50:	58 0a       	cp.w	r10,0
80006a52:	5c 2b       	cpc	r11
80006a54:	c0 e4       	brge	80006a70 <_vfprintf_r+0x748>
80006a56:	30 08       	mov	r8,0
80006a58:	fa ea 00 00 	ld.d	r10,sp[0]
80006a5c:	30 09       	mov	r9,0
80006a5e:	f0 0a 01 0a 	sub	r10,r8,r10
80006a62:	f2 0b 01 4b 	sbc	r11,r9,r11
80006a66:	32 d8       	mov	r8,45
80006a68:	fa eb 00 00 	st.d	sp[0],r10
80006a6c:	fb 68 06 bb 	st.b	sp[1723],r8
80006a70:	30 18       	mov	r8,1
80006a72:	e0 8f 06 fa 	bral	80007866 <_vfprintf_r+0x153e>
80006a76:	50 a7       	stdsp	sp[0x28],r7
80006a78:	50 80       	stdsp	sp[0x20],r0
80006a7a:	0c 97       	mov	r7,r6
80006a7c:	04 94       	mov	r4,r2
80006a7e:	06 96       	mov	r6,r3
80006a80:	02 92       	mov	r2,r1
80006a82:	40 93       	lddsp	r3,sp[0x24]
80006a84:	10 90       	mov	r0,r8
80006a86:	40 41       	lddsp	r1,sp[0x10]
80006a88:	0e 99       	mov	r9,r7
80006a8a:	ed b5 00 03 	bld	r5,0x3
80006a8e:	c4 11       	brne	80006b10 <_vfprintf_r+0x7e8>
80006a90:	fa f8 06 b4 	ld.w	r8,sp[1716]
80006a94:	40 3a       	lddsp	r10,sp[0xc]
80006a96:	58 0a       	cp.w	r10,0
80006a98:	c1 90       	breq	80006aca <_vfprintf_r+0x7a2>
80006a9a:	10 36       	cp.w	r6,r8
80006a9c:	c6 45       	brlt	80006b64 <_vfprintf_r+0x83c>
80006a9e:	fa c8 f9 50 	sub	r8,sp,-1712
80006aa2:	1a d8       	st.w	--sp,r8
80006aa4:	fa c8 fa b8 	sub	r8,sp,-1352
80006aa8:	1a d8       	st.w	--sp,r8
80006aaa:	fa c8 fb b4 	sub	r8,sp,-1100
80006aae:	0c 9b       	mov	r11,r6
80006ab0:	1a d8       	st.w	--sp,r8
80006ab2:	04 9a       	mov	r10,r2
80006ab4:	fa c8 f9 40 	sub	r8,sp,-1728
80006ab8:	fa c9 ff b4 	sub	r9,sp,-76
80006abc:	08 9c       	mov	r12,r4
80006abe:	fe b0 fa 9d 	rcall	80005ff8 <get_arg>
80006ac2:	2f dd       	sub	sp,-12
80006ac4:	78 16       	ld.w	r6,r12[0x4]
80006ac6:	50 76       	stdsp	sp[0x1c],r6
80006ac8:	c4 88       	rjmp	80006b58 <_vfprintf_r+0x830>
80006aca:	2f f7       	sub	r7,-1
80006acc:	10 39       	cp.w	r9,r8
80006ace:	c0 c4       	brge	80006ae6 <_vfprintf_r+0x7be>
80006ad0:	fa ce f9 44 	sub	lr,sp,-1724
80006ad4:	fc 06 00 36 	add	r6,lr,r6<<0x3
80006ad8:	ec fc fd 8c 	ld.w	r12,r6[-628]
80006adc:	50 7c       	stdsp	sp[0x1c],r12
80006ade:	ec f6 fd 88 	ld.w	r6,r6[-632]
80006ae2:	50 56       	stdsp	sp[0x14],r6
80006ae4:	c6 68       	rjmp	80006bb0 <_vfprintf_r+0x888>
80006ae6:	41 09       	lddsp	r9,sp[0x40]
80006ae8:	59 f8       	cp.w	r8,31
80006aea:	e0 89 00 10 	brgt	80006b0a <_vfprintf_r+0x7e2>
80006aee:	f2 ca ff f8 	sub	r10,r9,-8
80006af2:	72 1b       	ld.w	r11,r9[0x4]
80006af4:	51 0a       	stdsp	sp[0x40],r10
80006af6:	72 09       	ld.w	r9,r9[0x0]
80006af8:	fa ca f9 44 	sub	r10,sp,-1724
80006afc:	50 7b       	stdsp	sp[0x1c],r11
80006afe:	50 59       	stdsp	sp[0x14],r9
80006b00:	f4 08 00 39 	add	r9,r10,r8<<0x3
80006b04:	40 5b       	lddsp	r11,sp[0x14]
80006b06:	40 7a       	lddsp	r10,sp[0x1c]
80006b08:	c4 78       	rjmp	80006b96 <_vfprintf_r+0x86e>
80006b0a:	72 18       	ld.w	r8,r9[0x4]
80006b0c:	50 78       	stdsp	sp[0x1c],r8
80006b0e:	c4 c8       	rjmp	80006ba6 <_vfprintf_r+0x87e>
80006b10:	fa f8 06 b4 	ld.w	r8,sp[1716]
80006b14:	40 3e       	lddsp	lr,sp[0xc]
80006b16:	58 0e       	cp.w	lr,0
80006b18:	c2 30       	breq	80006b5e <_vfprintf_r+0x836>
80006b1a:	10 36       	cp.w	r6,r8
80006b1c:	c0 94       	brge	80006b2e <_vfprintf_r+0x806>
80006b1e:	fa cc f9 44 	sub	r12,sp,-1724
80006b22:	f8 06 00 36 	add	r6,r12,r6<<0x3
80006b26:	ec fb fd 8c 	ld.w	r11,r6[-628]
80006b2a:	50 7b       	stdsp	sp[0x1c],r11
80006b2c:	cd 9b       	rjmp	80006ade <_vfprintf_r+0x7b6>
80006b2e:	fa c8 f9 50 	sub	r8,sp,-1712
80006b32:	1a d8       	st.w	--sp,r8
80006b34:	fa c8 fa b8 	sub	r8,sp,-1352
80006b38:	04 9a       	mov	r10,r2
80006b3a:	1a d8       	st.w	--sp,r8
80006b3c:	fa c8 fb b4 	sub	r8,sp,-1100
80006b40:	0c 9b       	mov	r11,r6
80006b42:	1a d8       	st.w	--sp,r8
80006b44:	08 9c       	mov	r12,r4
80006b46:	fa c8 f9 40 	sub	r8,sp,-1728
80006b4a:	fa c9 ff b4 	sub	r9,sp,-76
80006b4e:	fe b0 fa 55 	rcall	80005ff8 <get_arg>
80006b52:	2f dd       	sub	sp,-12
80006b54:	78 1a       	ld.w	r10,r12[0x4]
80006b56:	50 7a       	stdsp	sp[0x1c],r10
80006b58:	78 0c       	ld.w	r12,r12[0x0]
80006b5a:	50 5c       	stdsp	sp[0x14],r12
80006b5c:	c2 a8       	rjmp	80006bb0 <_vfprintf_r+0x888>
80006b5e:	2f f7       	sub	r7,-1
80006b60:	10 39       	cp.w	r9,r8
80006b62:	c0 94       	brge	80006b74 <_vfprintf_r+0x84c>
80006b64:	fa c9 f9 44 	sub	r9,sp,-1724
80006b68:	f2 06 00 36 	add	r6,r9,r6<<0x3
80006b6c:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80006b70:	50 78       	stdsp	sp[0x1c],r8
80006b72:	cb 6b       	rjmp	80006ade <_vfprintf_r+0x7b6>
80006b74:	41 09       	lddsp	r9,sp[0x40]
80006b76:	59 f8       	cp.w	r8,31
80006b78:	e0 89 00 15 	brgt	80006ba2 <_vfprintf_r+0x87a>
80006b7c:	f2 ca ff f8 	sub	r10,r9,-8
80006b80:	72 16       	ld.w	r6,r9[0x4]
80006b82:	72 09       	ld.w	r9,r9[0x0]
80006b84:	51 0a       	stdsp	sp[0x40],r10
80006b86:	50 59       	stdsp	sp[0x14],r9
80006b88:	fa ce f9 44 	sub	lr,sp,-1724
80006b8c:	50 76       	stdsp	sp[0x1c],r6
80006b8e:	fc 08 00 39 	add	r9,lr,r8<<0x3
80006b92:	40 5b       	lddsp	r11,sp[0x14]
80006b94:	0c 9a       	mov	r10,r6
80006b96:	f2 eb fd 88 	st.d	r9[-632],r10
80006b9a:	2f f8       	sub	r8,-1
80006b9c:	fb 48 06 b4 	st.w	sp[1716],r8
80006ba0:	c0 88       	rjmp	80006bb0 <_vfprintf_r+0x888>
80006ba2:	72 1c       	ld.w	r12,r9[0x4]
80006ba4:	50 7c       	stdsp	sp[0x1c],r12
80006ba6:	f2 c8 ff f8 	sub	r8,r9,-8
80006baa:	51 08       	stdsp	sp[0x40],r8
80006bac:	72 09       	ld.w	r9,r9[0x0]
80006bae:	50 59       	stdsp	sp[0x14],r9
80006bb0:	40 5b       	lddsp	r11,sp[0x14]
80006bb2:	40 7a       	lddsp	r10,sp[0x1c]
80006bb4:	e0 a0 19 54 	rcall	80009e5c <__isinfd>
80006bb8:	18 96       	mov	r6,r12
80006bba:	c1 70       	breq	80006be8 <_vfprintf_r+0x8c0>
80006bbc:	30 08       	mov	r8,0
80006bbe:	30 09       	mov	r9,0
80006bc0:	40 5b       	lddsp	r11,sp[0x14]
80006bc2:	40 7a       	lddsp	r10,sp[0x1c]
80006bc4:	e0 a0 1d b4 	rcall	8000a72c <__avr32_f64_cmp_lt>
80006bc8:	c0 40       	breq	80006bd0 <_vfprintf_r+0x8a8>
80006bca:	32 d8       	mov	r8,45
80006bcc:	fb 68 06 bb 	st.b	sp[1723],r8
80006bd0:	fe c8 ab 18 	sub	r8,pc,-21736
80006bd4:	fe c6 ab 18 	sub	r6,pc,-21736
80006bd8:	a7 d5       	cbr	r5,0x7
80006bda:	e0 40 00 47 	cp.w	r0,71
80006bde:	f0 06 17 a0 	movle	r6,r8
80006be2:	30 32       	mov	r2,3
80006be4:	e0 8f 06 ce 	bral	80007980 <_vfprintf_r+0x1658>
80006be8:	40 5b       	lddsp	r11,sp[0x14]
80006bea:	40 7a       	lddsp	r10,sp[0x1c]
80006bec:	e0 a0 19 4d 	rcall	80009e86 <__isnand>
80006bf0:	c0 e0       	breq	80006c0c <_vfprintf_r+0x8e4>
80006bf2:	50 26       	stdsp	sp[0x8],r6
80006bf4:	fe c8 ab 34 	sub	r8,pc,-21708
80006bf8:	fe c6 ab 34 	sub	r6,pc,-21708
80006bfc:	a7 d5       	cbr	r5,0x7
80006bfe:	e0 40 00 47 	cp.w	r0,71
80006c02:	f0 06 17 a0 	movle	r6,r8
80006c06:	30 32       	mov	r2,3
80006c08:	e0 8f 06 c2 	bral	8000798c <_vfprintf_r+0x1664>
80006c0c:	40 2a       	lddsp	r10,sp[0x8]
80006c0e:	5b fa       	cp.w	r10,-1
80006c10:	c0 41       	brne	80006c18 <_vfprintf_r+0x8f0>
80006c12:	30 69       	mov	r9,6
80006c14:	50 29       	stdsp	sp[0x8],r9
80006c16:	c1 18       	rjmp	80006c38 <_vfprintf_r+0x910>
80006c18:	e0 40 00 47 	cp.w	r0,71
80006c1c:	5f 09       	sreq	r9
80006c1e:	e0 40 00 67 	cp.w	r0,103
80006c22:	5f 08       	sreq	r8
80006c24:	f3 e8 10 08 	or	r8,r9,r8
80006c28:	f8 08 18 00 	cp.b	r8,r12
80006c2c:	c0 60       	breq	80006c38 <_vfprintf_r+0x910>
80006c2e:	40 28       	lddsp	r8,sp[0x8]
80006c30:	58 08       	cp.w	r8,0
80006c32:	f9 b8 00 01 	moveq	r8,1
80006c36:	50 28       	stdsp	sp[0x8],r8
80006c38:	40 78       	lddsp	r8,sp[0x1c]
80006c3a:	40 59       	lddsp	r9,sp[0x14]
80006c3c:	fa e9 06 94 	st.d	sp[1684],r8
80006c40:	a9 a5       	sbr	r5,0x8
80006c42:	fa f8 06 94 	ld.w	r8,sp[1684]
80006c46:	58 08       	cp.w	r8,0
80006c48:	c0 65       	brlt	80006c54 <_vfprintf_r+0x92c>
80006c4a:	40 5e       	lddsp	lr,sp[0x14]
80006c4c:	30 0c       	mov	r12,0
80006c4e:	50 6e       	stdsp	sp[0x18],lr
80006c50:	50 9c       	stdsp	sp[0x24],r12
80006c52:	c0 78       	rjmp	80006c60 <_vfprintf_r+0x938>
80006c54:	40 5b       	lddsp	r11,sp[0x14]
80006c56:	32 da       	mov	r10,45
80006c58:	ee 1b 80 00 	eorh	r11,0x8000
80006c5c:	50 9a       	stdsp	sp[0x24],r10
80006c5e:	50 6b       	stdsp	sp[0x18],r11
80006c60:	e0 40 00 46 	cp.w	r0,70
80006c64:	5f 09       	sreq	r9
80006c66:	e0 40 00 66 	cp.w	r0,102
80006c6a:	5f 08       	sreq	r8
80006c6c:	f3 e8 10 08 	or	r8,r9,r8
80006c70:	50 48       	stdsp	sp[0x10],r8
80006c72:	c0 40       	breq	80006c7a <_vfprintf_r+0x952>
80006c74:	40 22       	lddsp	r2,sp[0x8]
80006c76:	30 39       	mov	r9,3
80006c78:	c1 08       	rjmp	80006c98 <_vfprintf_r+0x970>
80006c7a:	e0 40 00 45 	cp.w	r0,69
80006c7e:	5f 09       	sreq	r9
80006c80:	e0 40 00 65 	cp.w	r0,101
80006c84:	5f 08       	sreq	r8
80006c86:	40 22       	lddsp	r2,sp[0x8]
80006c88:	10 49       	or	r9,r8
80006c8a:	2f f2       	sub	r2,-1
80006c8c:	40 46       	lddsp	r6,sp[0x10]
80006c8e:	ec 09 18 00 	cp.b	r9,r6
80006c92:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80006c96:	30 29       	mov	r9,2
80006c98:	fa c8 f9 5c 	sub	r8,sp,-1700
80006c9c:	1a d8       	st.w	--sp,r8
80006c9e:	fa c8 f9 54 	sub	r8,sp,-1708
80006ca2:	1a d8       	st.w	--sp,r8
80006ca4:	fa c8 f9 4c 	sub	r8,sp,-1716
80006ca8:	08 9c       	mov	r12,r4
80006caa:	1a d8       	st.w	--sp,r8
80006cac:	04 98       	mov	r8,r2
80006cae:	40 9b       	lddsp	r11,sp[0x24]
80006cb0:	40 aa       	lddsp	r10,sp[0x28]
80006cb2:	e0 a0 0b c3 	rcall	80008438 <_dtoa_r>
80006cb6:	e0 40 00 47 	cp.w	r0,71
80006cba:	5f 19       	srne	r9
80006cbc:	e0 40 00 67 	cp.w	r0,103
80006cc0:	5f 18       	srne	r8
80006cc2:	18 96       	mov	r6,r12
80006cc4:	2f dd       	sub	sp,-12
80006cc6:	f3 e8 00 08 	and	r8,r9,r8
80006cca:	c0 41       	brne	80006cd2 <_vfprintf_r+0x9aa>
80006ccc:	ed b5 00 00 	bld	r5,0x0
80006cd0:	c3 01       	brne	80006d30 <_vfprintf_r+0xa08>
80006cd2:	ec 02 00 0e 	add	lr,r6,r2
80006cd6:	50 3e       	stdsp	sp[0xc],lr
80006cd8:	40 4c       	lddsp	r12,sp[0x10]
80006cda:	58 0c       	cp.w	r12,0
80006cdc:	c1 50       	breq	80006d06 <_vfprintf_r+0x9de>
80006cde:	0d 89       	ld.ub	r9,r6[0x0]
80006ce0:	33 08       	mov	r8,48
80006ce2:	f0 09 18 00 	cp.b	r9,r8
80006ce6:	c0 b1       	brne	80006cfc <_vfprintf_r+0x9d4>
80006ce8:	30 08       	mov	r8,0
80006cea:	30 09       	mov	r9,0
80006cec:	40 6b       	lddsp	r11,sp[0x18]
80006cee:	40 7a       	lddsp	r10,sp[0x1c]
80006cf0:	e0 a0 1c d7 	rcall	8000a69e <__avr32_f64_cmp_eq>
80006cf4:	fb b2 00 01 	rsubeq	r2,1
80006cf8:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80006cfc:	40 3b       	lddsp	r11,sp[0xc]
80006cfe:	fa f8 06 ac 	ld.w	r8,sp[1708]
80006d02:	10 0b       	add	r11,r8
80006d04:	50 3b       	stdsp	sp[0xc],r11
80006d06:	40 6b       	lddsp	r11,sp[0x18]
80006d08:	30 08       	mov	r8,0
80006d0a:	30 09       	mov	r9,0
80006d0c:	40 7a       	lddsp	r10,sp[0x1c]
80006d0e:	e0 a0 1c c8 	rcall	8000a69e <__avr32_f64_cmp_eq>
80006d12:	c0 90       	breq	80006d24 <_vfprintf_r+0x9fc>
80006d14:	40 3a       	lddsp	r10,sp[0xc]
80006d16:	fb 4a 06 a4 	st.w	sp[1700],r10
80006d1a:	c0 58       	rjmp	80006d24 <_vfprintf_r+0x9fc>
80006d1c:	10 c9       	st.b	r8++,r9
80006d1e:	fb 48 06 a4 	st.w	sp[1700],r8
80006d22:	c0 28       	rjmp	80006d26 <_vfprintf_r+0x9fe>
80006d24:	33 09       	mov	r9,48
80006d26:	fa f8 06 a4 	ld.w	r8,sp[1700]
80006d2a:	40 3e       	lddsp	lr,sp[0xc]
80006d2c:	1c 38       	cp.w	r8,lr
80006d2e:	cf 73       	brcs	80006d1c <_vfprintf_r+0x9f4>
80006d30:	e0 40 00 47 	cp.w	r0,71
80006d34:	5f 09       	sreq	r9
80006d36:	e0 40 00 67 	cp.w	r0,103
80006d3a:	5f 08       	sreq	r8
80006d3c:	f3 e8 10 08 	or	r8,r9,r8
80006d40:	fa f9 06 a4 	ld.w	r9,sp[1700]
80006d44:	0c 19       	sub	r9,r6
80006d46:	50 69       	stdsp	sp[0x18],r9
80006d48:	58 08       	cp.w	r8,0
80006d4a:	c0 b0       	breq	80006d60 <_vfprintf_r+0xa38>
80006d4c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80006d50:	5b d8       	cp.w	r8,-3
80006d52:	c0 55       	brlt	80006d5c <_vfprintf_r+0xa34>
80006d54:	40 2c       	lddsp	r12,sp[0x8]
80006d56:	18 38       	cp.w	r8,r12
80006d58:	e0 8a 00 6a 	brle	80006e2c <_vfprintf_r+0xb04>
80006d5c:	20 20       	sub	r0,2
80006d5e:	c0 58       	rjmp	80006d68 <_vfprintf_r+0xa40>
80006d60:	e0 40 00 65 	cp.w	r0,101
80006d64:	e0 89 00 46 	brgt	80006df0 <_vfprintf_r+0xac8>
80006d68:	fa fb 06 ac 	ld.w	r11,sp[1708]
80006d6c:	fb 60 06 9c 	st.b	sp[1692],r0
80006d70:	20 1b       	sub	r11,1
80006d72:	fb 4b 06 ac 	st.w	sp[1708],r11
80006d76:	c0 47       	brpl	80006d7e <_vfprintf_r+0xa56>
80006d78:	5c 3b       	neg	r11
80006d7a:	32 d8       	mov	r8,45
80006d7c:	c0 28       	rjmp	80006d80 <_vfprintf_r+0xa58>
80006d7e:	32 b8       	mov	r8,43
80006d80:	fb 68 06 9d 	st.b	sp[1693],r8
80006d84:	58 9b       	cp.w	r11,9
80006d86:	e0 8a 00 1d 	brle	80006dc0 <_vfprintf_r+0xa98>
80006d8a:	fa c9 fa 35 	sub	r9,sp,-1483
80006d8e:	30 aa       	mov	r10,10
80006d90:	12 98       	mov	r8,r9
80006d92:	0e 9c       	mov	r12,r7
80006d94:	0c 92       	mov	r2,r6
80006d96:	f6 0a 0c 06 	divs	r6,r11,r10
80006d9a:	0e 9b       	mov	r11,r7
80006d9c:	2d 0b       	sub	r11,-48
80006d9e:	10 fb       	st.b	--r8,r11
80006da0:	0c 9b       	mov	r11,r6
80006da2:	58 96       	cp.w	r6,9
80006da4:	fe 99 ff f9 	brgt	80006d96 <_vfprintf_r+0xa6e>
80006da8:	2d 0b       	sub	r11,-48
80006daa:	18 97       	mov	r7,r12
80006dac:	04 96       	mov	r6,r2
80006dae:	10 fb       	st.b	--r8,r11
80006db0:	fa ca f9 62 	sub	r10,sp,-1694
80006db4:	c0 38       	rjmp	80006dba <_vfprintf_r+0xa92>
80006db6:	11 3b       	ld.ub	r11,r8++
80006db8:	14 cb       	st.b	r10++,r11
80006dba:	12 38       	cp.w	r8,r9
80006dbc:	cf d3       	brcs	80006db6 <_vfprintf_r+0xa8e>
80006dbe:	c0 98       	rjmp	80006dd0 <_vfprintf_r+0xaa8>
80006dc0:	2d 0b       	sub	r11,-48
80006dc2:	33 08       	mov	r8,48
80006dc4:	fb 6b 06 9f 	st.b	sp[1695],r11
80006dc8:	fb 68 06 9e 	st.b	sp[1694],r8
80006dcc:	fa ca f9 60 	sub	r10,sp,-1696
80006dd0:	fa c8 f9 64 	sub	r8,sp,-1692
80006dd4:	f4 08 01 08 	sub	r8,r10,r8
80006dd8:	50 e8       	stdsp	sp[0x38],r8
80006dda:	10 92       	mov	r2,r8
80006ddc:	40 6b       	lddsp	r11,sp[0x18]
80006dde:	16 02       	add	r2,r11
80006de0:	58 1b       	cp.w	r11,1
80006de2:	e0 89 00 05 	brgt	80006dec <_vfprintf_r+0xac4>
80006de6:	ed b5 00 00 	bld	r5,0x0
80006dea:	c3 51       	brne	80006e54 <_vfprintf_r+0xb2c>
80006dec:	2f f2       	sub	r2,-1
80006dee:	c3 38       	rjmp	80006e54 <_vfprintf_r+0xb2c>
80006df0:	e0 40 00 66 	cp.w	r0,102
80006df4:	c1 c1       	brne	80006e2c <_vfprintf_r+0xb04>
80006df6:	fa f2 06 ac 	ld.w	r2,sp[1708]
80006dfa:	58 02       	cp.w	r2,0
80006dfc:	e0 8a 00 0c 	brle	80006e14 <_vfprintf_r+0xaec>
80006e00:	40 2a       	lddsp	r10,sp[0x8]
80006e02:	58 0a       	cp.w	r10,0
80006e04:	c0 41       	brne	80006e0c <_vfprintf_r+0xae4>
80006e06:	ed b5 00 00 	bld	r5,0x0
80006e0a:	c2 51       	brne	80006e54 <_vfprintf_r+0xb2c>
80006e0c:	2f f2       	sub	r2,-1
80006e0e:	40 29       	lddsp	r9,sp[0x8]
80006e10:	12 02       	add	r2,r9
80006e12:	c0 b8       	rjmp	80006e28 <_vfprintf_r+0xb00>
80006e14:	40 28       	lddsp	r8,sp[0x8]
80006e16:	58 08       	cp.w	r8,0
80006e18:	c0 61       	brne	80006e24 <_vfprintf_r+0xafc>
80006e1a:	ed b5 00 00 	bld	r5,0x0
80006e1e:	c0 30       	breq	80006e24 <_vfprintf_r+0xafc>
80006e20:	30 12       	mov	r2,1
80006e22:	c1 98       	rjmp	80006e54 <_vfprintf_r+0xb2c>
80006e24:	40 22       	lddsp	r2,sp[0x8]
80006e26:	2f e2       	sub	r2,-2
80006e28:	36 60       	mov	r0,102
80006e2a:	c1 58       	rjmp	80006e54 <_vfprintf_r+0xb2c>
80006e2c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80006e30:	40 6e       	lddsp	lr,sp[0x18]
80006e32:	1c 32       	cp.w	r2,lr
80006e34:	c0 65       	brlt	80006e40 <_vfprintf_r+0xb18>
80006e36:	ed b5 00 00 	bld	r5,0x0
80006e3a:	f7 b2 00 ff 	subeq	r2,-1
80006e3e:	c0 a8       	rjmp	80006e52 <_vfprintf_r+0xb2a>
80006e40:	e4 08 11 02 	rsub	r8,r2,2
80006e44:	40 6c       	lddsp	r12,sp[0x18]
80006e46:	58 02       	cp.w	r2,0
80006e48:	f0 02 17 a0 	movle	r2,r8
80006e4c:	f9 b2 09 01 	movgt	r2,1
80006e50:	18 02       	add	r2,r12
80006e52:	36 70       	mov	r0,103
80006e54:	40 9b       	lddsp	r11,sp[0x24]
80006e56:	58 0b       	cp.w	r11,0
80006e58:	e0 80 05 94 	breq	80007980 <_vfprintf_r+0x1658>
80006e5c:	32 d8       	mov	r8,45
80006e5e:	fb 68 06 bb 	st.b	sp[1723],r8
80006e62:	e0 8f 05 93 	bral	80007988 <_vfprintf_r+0x1660>
80006e66:	50 a7       	stdsp	sp[0x28],r7
80006e68:	04 94       	mov	r4,r2
80006e6a:	0c 97       	mov	r7,r6
80006e6c:	02 92       	mov	r2,r1
80006e6e:	06 96       	mov	r6,r3
80006e70:	40 41       	lddsp	r1,sp[0x10]
80006e72:	40 93       	lddsp	r3,sp[0x24]
80006e74:	0e 99       	mov	r9,r7
80006e76:	ed b5 00 05 	bld	r5,0x5
80006e7a:	c4 81       	brne	80006f0a <_vfprintf_r+0xbe2>
80006e7c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80006e80:	40 3e       	lddsp	lr,sp[0xc]
80006e82:	58 0e       	cp.w	lr,0
80006e84:	c1 d0       	breq	80006ebe <_vfprintf_r+0xb96>
80006e86:	10 36       	cp.w	r6,r8
80006e88:	c0 64       	brge	80006e94 <_vfprintf_r+0xb6c>
80006e8a:	fa cc f9 44 	sub	r12,sp,-1724
80006e8e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80006e92:	c1 d8       	rjmp	80006ecc <_vfprintf_r+0xba4>
80006e94:	fa c8 f9 50 	sub	r8,sp,-1712
80006e98:	1a d8       	st.w	--sp,r8
80006e9a:	fa c8 fa b8 	sub	r8,sp,-1352
80006e9e:	04 9a       	mov	r10,r2
80006ea0:	1a d8       	st.w	--sp,r8
80006ea2:	fa c8 fb b4 	sub	r8,sp,-1100
80006ea6:	0c 9b       	mov	r11,r6
80006ea8:	1a d8       	st.w	--sp,r8
80006eaa:	08 9c       	mov	r12,r4
80006eac:	fa c8 f9 40 	sub	r8,sp,-1728
80006eb0:	fa c9 ff b4 	sub	r9,sp,-76
80006eb4:	fe b0 f8 a2 	rcall	80005ff8 <get_arg>
80006eb8:	2f dd       	sub	sp,-12
80006eba:	78 0a       	ld.w	r10,r12[0x0]
80006ebc:	c2 08       	rjmp	80006efc <_vfprintf_r+0xbd4>
80006ebe:	2f f7       	sub	r7,-1
80006ec0:	10 39       	cp.w	r9,r8
80006ec2:	c0 84       	brge	80006ed2 <_vfprintf_r+0xbaa>
80006ec4:	fa cb f9 44 	sub	r11,sp,-1724
80006ec8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80006ecc:	ec fa fd 88 	ld.w	r10,r6[-632]
80006ed0:	c1 68       	rjmp	80006efc <_vfprintf_r+0xbd4>
80006ed2:	41 09       	lddsp	r9,sp[0x40]
80006ed4:	59 f8       	cp.w	r8,31
80006ed6:	e0 89 00 10 	brgt	80006ef6 <_vfprintf_r+0xbce>
80006eda:	f2 ca ff fc 	sub	r10,r9,-4
80006ede:	51 0a       	stdsp	sp[0x40],r10
80006ee0:	fa c6 f9 44 	sub	r6,sp,-1724
80006ee4:	72 0a       	ld.w	r10,r9[0x0]
80006ee6:	ec 08 00 39 	add	r9,r6,r8<<0x3
80006eea:	f3 4a fd 88 	st.w	r9[-632],r10
80006eee:	2f f8       	sub	r8,-1
80006ef0:	fb 48 06 b4 	st.w	sp[1716],r8
80006ef4:	c0 48       	rjmp	80006efc <_vfprintf_r+0xbd4>
80006ef6:	72 0a       	ld.w	r10,r9[0x0]
80006ef8:	2f c9       	sub	r9,-4
80006efa:	51 09       	stdsp	sp[0x40],r9
80006efc:	40 be       	lddsp	lr,sp[0x2c]
80006efe:	1c 98       	mov	r8,lr
80006f00:	95 1e       	st.w	r10[0x4],lr
80006f02:	bf 58       	asr	r8,0x1f
80006f04:	95 08       	st.w	r10[0x0],r8
80006f06:	fe 9f fa 9f 	bral	80006444 <_vfprintf_r+0x11c>
80006f0a:	ed b5 00 04 	bld	r5,0x4
80006f0e:	c4 80       	breq	80006f9e <_vfprintf_r+0xc76>
80006f10:	e2 15 00 40 	andl	r5,0x40,COH
80006f14:	c4 50       	breq	80006f9e <_vfprintf_r+0xc76>
80006f16:	fa f8 06 b4 	ld.w	r8,sp[1716]
80006f1a:	40 3c       	lddsp	r12,sp[0xc]
80006f1c:	58 0c       	cp.w	r12,0
80006f1e:	c1 d0       	breq	80006f58 <_vfprintf_r+0xc30>
80006f20:	10 36       	cp.w	r6,r8
80006f22:	c0 64       	brge	80006f2e <_vfprintf_r+0xc06>
80006f24:	fa cb f9 44 	sub	r11,sp,-1724
80006f28:	f6 06 00 36 	add	r6,r11,r6<<0x3
80006f2c:	c1 d8       	rjmp	80006f66 <_vfprintf_r+0xc3e>
80006f2e:	fa c8 f9 50 	sub	r8,sp,-1712
80006f32:	1a d8       	st.w	--sp,r8
80006f34:	fa c8 fa b8 	sub	r8,sp,-1352
80006f38:	04 9a       	mov	r10,r2
80006f3a:	1a d8       	st.w	--sp,r8
80006f3c:	fa c8 fb b4 	sub	r8,sp,-1100
80006f40:	0c 9b       	mov	r11,r6
80006f42:	1a d8       	st.w	--sp,r8
80006f44:	08 9c       	mov	r12,r4
80006f46:	fa c8 f9 40 	sub	r8,sp,-1728
80006f4a:	fa c9 ff b4 	sub	r9,sp,-76
80006f4e:	fe b0 f8 55 	rcall	80005ff8 <get_arg>
80006f52:	2f dd       	sub	sp,-12
80006f54:	78 0a       	ld.w	r10,r12[0x0]
80006f56:	c2 08       	rjmp	80006f96 <_vfprintf_r+0xc6e>
80006f58:	2f f7       	sub	r7,-1
80006f5a:	10 39       	cp.w	r9,r8
80006f5c:	c0 84       	brge	80006f6c <_vfprintf_r+0xc44>
80006f5e:	fa ca f9 44 	sub	r10,sp,-1724
80006f62:	f4 06 00 36 	add	r6,r10,r6<<0x3
80006f66:	ec fa fd 88 	ld.w	r10,r6[-632]
80006f6a:	c1 68       	rjmp	80006f96 <_vfprintf_r+0xc6e>
80006f6c:	41 09       	lddsp	r9,sp[0x40]
80006f6e:	59 f8       	cp.w	r8,31
80006f70:	e0 89 00 10 	brgt	80006f90 <_vfprintf_r+0xc68>
80006f74:	f2 ca ff fc 	sub	r10,r9,-4
80006f78:	51 0a       	stdsp	sp[0x40],r10
80006f7a:	fa c6 f9 44 	sub	r6,sp,-1724
80006f7e:	72 0a       	ld.w	r10,r9[0x0]
80006f80:	ec 08 00 39 	add	r9,r6,r8<<0x3
80006f84:	f3 4a fd 88 	st.w	r9[-632],r10
80006f88:	2f f8       	sub	r8,-1
80006f8a:	fb 48 06 b4 	st.w	sp[1716],r8
80006f8e:	c0 48       	rjmp	80006f96 <_vfprintf_r+0xc6e>
80006f90:	72 0a       	ld.w	r10,r9[0x0]
80006f92:	2f c9       	sub	r9,-4
80006f94:	51 09       	stdsp	sp[0x40],r9
80006f96:	40 be       	lddsp	lr,sp[0x2c]
80006f98:	b4 0e       	st.h	r10[0x0],lr
80006f9a:	fe 9f fa 55 	bral	80006444 <_vfprintf_r+0x11c>
80006f9e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80006fa2:	40 3c       	lddsp	r12,sp[0xc]
80006fa4:	58 0c       	cp.w	r12,0
80006fa6:	c1 d0       	breq	80006fe0 <_vfprintf_r+0xcb8>
80006fa8:	10 36       	cp.w	r6,r8
80006faa:	c0 64       	brge	80006fb6 <_vfprintf_r+0xc8e>
80006fac:	fa cb f9 44 	sub	r11,sp,-1724
80006fb0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80006fb4:	c1 d8       	rjmp	80006fee <_vfprintf_r+0xcc6>
80006fb6:	fa c8 f9 50 	sub	r8,sp,-1712
80006fba:	1a d8       	st.w	--sp,r8
80006fbc:	fa c8 fa b8 	sub	r8,sp,-1352
80006fc0:	04 9a       	mov	r10,r2
80006fc2:	1a d8       	st.w	--sp,r8
80006fc4:	fa c8 fb b4 	sub	r8,sp,-1100
80006fc8:	0c 9b       	mov	r11,r6
80006fca:	1a d8       	st.w	--sp,r8
80006fcc:	08 9c       	mov	r12,r4
80006fce:	fa c8 f9 40 	sub	r8,sp,-1728
80006fd2:	fa c9 ff b4 	sub	r9,sp,-76
80006fd6:	fe b0 f8 11 	rcall	80005ff8 <get_arg>
80006fda:	2f dd       	sub	sp,-12
80006fdc:	78 0a       	ld.w	r10,r12[0x0]
80006fde:	c2 08       	rjmp	8000701e <_vfprintf_r+0xcf6>
80006fe0:	2f f7       	sub	r7,-1
80006fe2:	10 39       	cp.w	r9,r8
80006fe4:	c0 84       	brge	80006ff4 <_vfprintf_r+0xccc>
80006fe6:	fa ca f9 44 	sub	r10,sp,-1724
80006fea:	f4 06 00 36 	add	r6,r10,r6<<0x3
80006fee:	ec fa fd 88 	ld.w	r10,r6[-632]
80006ff2:	c1 68       	rjmp	8000701e <_vfprintf_r+0xcf6>
80006ff4:	41 09       	lddsp	r9,sp[0x40]
80006ff6:	59 f8       	cp.w	r8,31
80006ff8:	e0 89 00 10 	brgt	80007018 <_vfprintf_r+0xcf0>
80006ffc:	f2 ca ff fc 	sub	r10,r9,-4
80007000:	51 0a       	stdsp	sp[0x40],r10
80007002:	fa c6 f9 44 	sub	r6,sp,-1724
80007006:	72 0a       	ld.w	r10,r9[0x0]
80007008:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000700c:	f3 4a fd 88 	st.w	r9[-632],r10
80007010:	2f f8       	sub	r8,-1
80007012:	fb 48 06 b4 	st.w	sp[1716],r8
80007016:	c0 48       	rjmp	8000701e <_vfprintf_r+0xcf6>
80007018:	72 0a       	ld.w	r10,r9[0x0]
8000701a:	2f c9       	sub	r9,-4
8000701c:	51 09       	stdsp	sp[0x40],r9
8000701e:	40 be       	lddsp	lr,sp[0x2c]
80007020:	95 0e       	st.w	r10[0x0],lr
80007022:	fe 9f fa 11 	bral	80006444 <_vfprintf_r+0x11c>
80007026:	50 a7       	stdsp	sp[0x28],r7
80007028:	50 80       	stdsp	sp[0x20],r0
8000702a:	0c 97       	mov	r7,r6
8000702c:	04 94       	mov	r4,r2
8000702e:	06 96       	mov	r6,r3
80007030:	02 92       	mov	r2,r1
80007032:	40 93       	lddsp	r3,sp[0x24]
80007034:	10 90       	mov	r0,r8
80007036:	40 41       	lddsp	r1,sp[0x10]
80007038:	a5 a5       	sbr	r5,0x4
8000703a:	c0 a8       	rjmp	8000704e <_vfprintf_r+0xd26>
8000703c:	50 a7       	stdsp	sp[0x28],r7
8000703e:	50 80       	stdsp	sp[0x20],r0
80007040:	0c 97       	mov	r7,r6
80007042:	04 94       	mov	r4,r2
80007044:	06 96       	mov	r6,r3
80007046:	02 92       	mov	r2,r1
80007048:	40 93       	lddsp	r3,sp[0x24]
8000704a:	10 90       	mov	r0,r8
8000704c:	40 41       	lddsp	r1,sp[0x10]
8000704e:	ed b5 00 05 	bld	r5,0x5
80007052:	c5 d1       	brne	8000710c <_vfprintf_r+0xde4>
80007054:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007058:	40 3c       	lddsp	r12,sp[0xc]
8000705a:	58 0c       	cp.w	r12,0
8000705c:	c2 60       	breq	800070a8 <_vfprintf_r+0xd80>
8000705e:	10 36       	cp.w	r6,r8
80007060:	c0 a4       	brge	80007074 <_vfprintf_r+0xd4c>
80007062:	fa cb f9 44 	sub	r11,sp,-1724
80007066:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000706a:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000706e:	fa e9 00 00 	st.d	sp[0],r8
80007072:	c1 88       	rjmp	800070a2 <_vfprintf_r+0xd7a>
80007074:	fa c8 f9 50 	sub	r8,sp,-1712
80007078:	1a d8       	st.w	--sp,r8
8000707a:	fa c8 fa b8 	sub	r8,sp,-1352
8000707e:	04 9a       	mov	r10,r2
80007080:	1a d8       	st.w	--sp,r8
80007082:	0c 9b       	mov	r11,r6
80007084:	fa c8 fb b4 	sub	r8,sp,-1100
80007088:	08 9c       	mov	r12,r4
8000708a:	1a d8       	st.w	--sp,r8
8000708c:	fa c8 f9 40 	sub	r8,sp,-1728
80007090:	fa c9 ff b4 	sub	r9,sp,-76
80007094:	fe b0 f7 b2 	rcall	80005ff8 <get_arg>
80007098:	2f dd       	sub	sp,-12
8000709a:	f8 ea 00 00 	ld.d	r10,r12[0]
8000709e:	fa eb 00 00 	st.d	sp[0],r10
800070a2:	30 08       	mov	r8,0
800070a4:	e0 8f 03 de 	bral	80007860 <_vfprintf_r+0x1538>
800070a8:	ee ca ff ff 	sub	r10,r7,-1
800070ac:	10 37       	cp.w	r7,r8
800070ae:	c0 b4       	brge	800070c4 <_vfprintf_r+0xd9c>
800070b0:	fa c9 f9 44 	sub	r9,sp,-1724
800070b4:	14 97       	mov	r7,r10
800070b6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800070ba:	ec ea fd 88 	ld.d	r10,r6[-632]
800070be:	fa eb 00 00 	st.d	sp[0],r10
800070c2:	c1 88       	rjmp	800070f2 <_vfprintf_r+0xdca>
800070c4:	41 09       	lddsp	r9,sp[0x40]
800070c6:	59 f8       	cp.w	r8,31
800070c8:	e0 89 00 18 	brgt	800070f8 <_vfprintf_r+0xdd0>
800070cc:	f2 e6 00 00 	ld.d	r6,r9[0]
800070d0:	f2 cb ff f8 	sub	r11,r9,-8
800070d4:	fa e7 00 00 	st.d	sp[0],r6
800070d8:	51 0b       	stdsp	sp[0x40],r11
800070da:	fa c6 f9 44 	sub	r6,sp,-1724
800070de:	ec 08 00 39 	add	r9,r6,r8<<0x3
800070e2:	fa e6 00 00 	ld.d	r6,sp[0]
800070e6:	f2 e7 fd 88 	st.d	r9[-632],r6
800070ea:	2f f8       	sub	r8,-1
800070ec:	14 97       	mov	r7,r10
800070ee:	fb 48 06 b4 	st.w	sp[1716],r8
800070f2:	40 38       	lddsp	r8,sp[0xc]
800070f4:	e0 8f 03 b6 	bral	80007860 <_vfprintf_r+0x1538>
800070f8:	f2 e6 00 00 	ld.d	r6,r9[0]
800070fc:	40 38       	lddsp	r8,sp[0xc]
800070fe:	fa e7 00 00 	st.d	sp[0],r6
80007102:	2f 89       	sub	r9,-8
80007104:	14 97       	mov	r7,r10
80007106:	51 09       	stdsp	sp[0x40],r9
80007108:	e0 8f 03 ac 	bral	80007860 <_vfprintf_r+0x1538>
8000710c:	ed b5 00 04 	bld	r5,0x4
80007110:	c1 61       	brne	8000713c <_vfprintf_r+0xe14>
80007112:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007116:	40 3e       	lddsp	lr,sp[0xc]
80007118:	58 0e       	cp.w	lr,0
8000711a:	c0 80       	breq	8000712a <_vfprintf_r+0xe02>
8000711c:	10 36       	cp.w	r6,r8
8000711e:	c6 74       	brge	800071ec <_vfprintf_r+0xec4>
80007120:	fa cc f9 44 	sub	r12,sp,-1724
80007124:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007128:	c8 08       	rjmp	80007228 <_vfprintf_r+0xf00>
8000712a:	ee ca ff ff 	sub	r10,r7,-1
8000712e:	10 37       	cp.w	r7,r8
80007130:	c7 f4       	brge	8000722e <_vfprintf_r+0xf06>
80007132:	fa cb f9 44 	sub	r11,sp,-1724
80007136:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000713a:	c7 68       	rjmp	80007226 <_vfprintf_r+0xefe>
8000713c:	ed b5 00 06 	bld	r5,0x6
80007140:	c4 a1       	brne	800071d4 <_vfprintf_r+0xeac>
80007142:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007146:	40 3c       	lddsp	r12,sp[0xc]
80007148:	58 0c       	cp.w	r12,0
8000714a:	c1 d0       	breq	80007184 <_vfprintf_r+0xe5c>
8000714c:	10 36       	cp.w	r6,r8
8000714e:	c0 64       	brge	8000715a <_vfprintf_r+0xe32>
80007150:	fa cb f9 44 	sub	r11,sp,-1724
80007154:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007158:	c1 f8       	rjmp	80007196 <_vfprintf_r+0xe6e>
8000715a:	fa c8 f9 50 	sub	r8,sp,-1712
8000715e:	1a d8       	st.w	--sp,r8
80007160:	fa c8 fa b8 	sub	r8,sp,-1352
80007164:	1a d8       	st.w	--sp,r8
80007166:	fa c8 fb b4 	sub	r8,sp,-1100
8000716a:	1a d8       	st.w	--sp,r8
8000716c:	fa c8 f9 40 	sub	r8,sp,-1728
80007170:	fa c9 ff b4 	sub	r9,sp,-76
80007174:	04 9a       	mov	r10,r2
80007176:	0c 9b       	mov	r11,r6
80007178:	08 9c       	mov	r12,r4
8000717a:	fe b0 f7 3f 	rcall	80005ff8 <get_arg>
8000717e:	2f dd       	sub	sp,-12
80007180:	98 18       	ld.sh	r8,r12[0x2]
80007182:	c2 68       	rjmp	800071ce <_vfprintf_r+0xea6>
80007184:	ee ca ff ff 	sub	r10,r7,-1
80007188:	10 37       	cp.w	r7,r8
8000718a:	c0 94       	brge	8000719c <_vfprintf_r+0xe74>
8000718c:	fa c9 f9 44 	sub	r9,sp,-1724
80007190:	14 97       	mov	r7,r10
80007192:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007196:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000719a:	c1 a8       	rjmp	800071ce <_vfprintf_r+0xea6>
8000719c:	41 09       	lddsp	r9,sp[0x40]
8000719e:	59 f8       	cp.w	r8,31
800071a0:	e0 89 00 13 	brgt	800071c6 <_vfprintf_r+0xe9e>
800071a4:	f2 cb ff fc 	sub	r11,r9,-4
800071a8:	51 0b       	stdsp	sp[0x40],r11
800071aa:	72 09       	ld.w	r9,r9[0x0]
800071ac:	fa c6 f9 44 	sub	r6,sp,-1724
800071b0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800071b4:	2f f8       	sub	r8,-1
800071b6:	f7 49 fd 88 	st.w	r11[-632],r9
800071ba:	fb 48 06 b4 	st.w	sp[1716],r8
800071be:	14 97       	mov	r7,r10
800071c0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800071c4:	c0 58       	rjmp	800071ce <_vfprintf_r+0xea6>
800071c6:	92 18       	ld.sh	r8,r9[0x2]
800071c8:	14 97       	mov	r7,r10
800071ca:	2f c9       	sub	r9,-4
800071cc:	51 09       	stdsp	sp[0x40],r9
800071ce:	5c 78       	castu.h	r8
800071d0:	50 18       	stdsp	sp[0x4],r8
800071d2:	c4 68       	rjmp	8000725e <_vfprintf_r+0xf36>
800071d4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800071d8:	40 3c       	lddsp	r12,sp[0xc]
800071da:	58 0c       	cp.w	r12,0
800071dc:	c1 d0       	breq	80007216 <_vfprintf_r+0xeee>
800071de:	10 36       	cp.w	r6,r8
800071e0:	c0 64       	brge	800071ec <_vfprintf_r+0xec4>
800071e2:	fa cb f9 44 	sub	r11,sp,-1724
800071e6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800071ea:	c1 f8       	rjmp	80007228 <_vfprintf_r+0xf00>
800071ec:	fa c8 f9 50 	sub	r8,sp,-1712
800071f0:	1a d8       	st.w	--sp,r8
800071f2:	fa c8 fa b8 	sub	r8,sp,-1352
800071f6:	0c 9b       	mov	r11,r6
800071f8:	1a d8       	st.w	--sp,r8
800071fa:	fa c8 fb b4 	sub	r8,sp,-1100
800071fe:	04 9a       	mov	r10,r2
80007200:	1a d8       	st.w	--sp,r8
80007202:	08 9c       	mov	r12,r4
80007204:	fa c8 f9 40 	sub	r8,sp,-1728
80007208:	fa c9 ff b4 	sub	r9,sp,-76
8000720c:	fe b0 f6 f6 	rcall	80005ff8 <get_arg>
80007210:	2f dd       	sub	sp,-12
80007212:	78 0b       	ld.w	r11,r12[0x0]
80007214:	c2 48       	rjmp	8000725c <_vfprintf_r+0xf34>
80007216:	ee ca ff ff 	sub	r10,r7,-1
8000721a:	10 37       	cp.w	r7,r8
8000721c:	c0 94       	brge	8000722e <_vfprintf_r+0xf06>
8000721e:	fa c9 f9 44 	sub	r9,sp,-1724
80007222:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007226:	14 97       	mov	r7,r10
80007228:	ec fb fd 88 	ld.w	r11,r6[-632]
8000722c:	c1 88       	rjmp	8000725c <_vfprintf_r+0xf34>
8000722e:	41 09       	lddsp	r9,sp[0x40]
80007230:	59 f8       	cp.w	r8,31
80007232:	e0 89 00 11 	brgt	80007254 <_vfprintf_r+0xf2c>
80007236:	f2 cb ff fc 	sub	r11,r9,-4
8000723a:	51 0b       	stdsp	sp[0x40],r11
8000723c:	fa c6 f9 44 	sub	r6,sp,-1724
80007240:	72 0b       	ld.w	r11,r9[0x0]
80007242:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007246:	f3 4b fd 88 	st.w	r9[-632],r11
8000724a:	2f f8       	sub	r8,-1
8000724c:	14 97       	mov	r7,r10
8000724e:	fb 48 06 b4 	st.w	sp[1716],r8
80007252:	c0 58       	rjmp	8000725c <_vfprintf_r+0xf34>
80007254:	72 0b       	ld.w	r11,r9[0x0]
80007256:	14 97       	mov	r7,r10
80007258:	2f c9       	sub	r9,-4
8000725a:	51 09       	stdsp	sp[0x40],r9
8000725c:	50 1b       	stdsp	sp[0x4],r11
8000725e:	30 0e       	mov	lr,0
80007260:	50 0e       	stdsp	sp[0x0],lr
80007262:	1c 98       	mov	r8,lr
80007264:	e0 8f 02 fe 	bral	80007860 <_vfprintf_r+0x1538>
80007268:	50 a7       	stdsp	sp[0x28],r7
8000726a:	50 80       	stdsp	sp[0x20],r0
8000726c:	0c 97       	mov	r7,r6
8000726e:	04 94       	mov	r4,r2
80007270:	06 96       	mov	r6,r3
80007272:	02 92       	mov	r2,r1
80007274:	40 93       	lddsp	r3,sp[0x24]
80007276:	40 41       	lddsp	r1,sp[0x10]
80007278:	0e 99       	mov	r9,r7
8000727a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000727e:	40 3c       	lddsp	r12,sp[0xc]
80007280:	58 0c       	cp.w	r12,0
80007282:	c1 d0       	breq	800072bc <_vfprintf_r+0xf94>
80007284:	10 36       	cp.w	r6,r8
80007286:	c0 64       	brge	80007292 <_vfprintf_r+0xf6a>
80007288:	fa cb f9 44 	sub	r11,sp,-1724
8000728c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007290:	c1 d8       	rjmp	800072ca <_vfprintf_r+0xfa2>
80007292:	fa c8 f9 50 	sub	r8,sp,-1712
80007296:	1a d8       	st.w	--sp,r8
80007298:	fa c8 fa b8 	sub	r8,sp,-1352
8000729c:	1a d8       	st.w	--sp,r8
8000729e:	fa c8 fb b4 	sub	r8,sp,-1100
800072a2:	1a d8       	st.w	--sp,r8
800072a4:	fa c9 ff b4 	sub	r9,sp,-76
800072a8:	fa c8 f9 40 	sub	r8,sp,-1728
800072ac:	04 9a       	mov	r10,r2
800072ae:	0c 9b       	mov	r11,r6
800072b0:	08 9c       	mov	r12,r4
800072b2:	fe b0 f6 a3 	rcall	80005ff8 <get_arg>
800072b6:	2f dd       	sub	sp,-12
800072b8:	78 09       	ld.w	r9,r12[0x0]
800072ba:	c2 18       	rjmp	800072fc <_vfprintf_r+0xfd4>
800072bc:	2f f7       	sub	r7,-1
800072be:	10 39       	cp.w	r9,r8
800072c0:	c0 84       	brge	800072d0 <_vfprintf_r+0xfa8>
800072c2:	fa ca f9 44 	sub	r10,sp,-1724
800072c6:	f4 06 00 36 	add	r6,r10,r6<<0x3
800072ca:	ec f9 fd 88 	ld.w	r9,r6[-632]
800072ce:	c1 78       	rjmp	800072fc <_vfprintf_r+0xfd4>
800072d0:	41 09       	lddsp	r9,sp[0x40]
800072d2:	59 f8       	cp.w	r8,31
800072d4:	e0 89 00 10 	brgt	800072f4 <_vfprintf_r+0xfcc>
800072d8:	f2 ca ff fc 	sub	r10,r9,-4
800072dc:	51 0a       	stdsp	sp[0x40],r10
800072de:	fa c6 f9 44 	sub	r6,sp,-1724
800072e2:	72 09       	ld.w	r9,r9[0x0]
800072e4:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800072e8:	f5 49 fd 88 	st.w	r10[-632],r9
800072ec:	2f f8       	sub	r8,-1
800072ee:	fb 48 06 b4 	st.w	sp[1716],r8
800072f2:	c0 58       	rjmp	800072fc <_vfprintf_r+0xfd4>
800072f4:	f2 c8 ff fc 	sub	r8,r9,-4
800072f8:	51 08       	stdsp	sp[0x40],r8
800072fa:	72 09       	ld.w	r9,r9[0x0]
800072fc:	33 08       	mov	r8,48
800072fe:	fb 68 06 b8 	st.b	sp[1720],r8
80007302:	37 88       	mov	r8,120
80007304:	30 0e       	mov	lr,0
80007306:	fb 68 06 b9 	st.b	sp[1721],r8
8000730a:	fe cc b2 42 	sub	r12,pc,-19902
8000730e:	50 19       	stdsp	sp[0x4],r9
80007310:	a1 b5       	sbr	r5,0x1
80007312:	50 0e       	stdsp	sp[0x0],lr
80007314:	50 dc       	stdsp	sp[0x34],r12
80007316:	30 28       	mov	r8,2
80007318:	37 80       	mov	r0,120
8000731a:	e0 8f 02 a3 	bral	80007860 <_vfprintf_r+0x1538>
8000731e:	50 a7       	stdsp	sp[0x28],r7
80007320:	50 80       	stdsp	sp[0x20],r0
80007322:	10 90       	mov	r0,r8
80007324:	30 08       	mov	r8,0
80007326:	fb 68 06 bb 	st.b	sp[1723],r8
8000732a:	0c 97       	mov	r7,r6
8000732c:	04 94       	mov	r4,r2
8000732e:	06 96       	mov	r6,r3
80007330:	02 92       	mov	r2,r1
80007332:	40 93       	lddsp	r3,sp[0x24]
80007334:	40 41       	lddsp	r1,sp[0x10]
80007336:	0e 99       	mov	r9,r7
80007338:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000733c:	40 3b       	lddsp	r11,sp[0xc]
8000733e:	58 0b       	cp.w	r11,0
80007340:	c1 d0       	breq	8000737a <_vfprintf_r+0x1052>
80007342:	10 36       	cp.w	r6,r8
80007344:	c0 64       	brge	80007350 <_vfprintf_r+0x1028>
80007346:	fa ca f9 44 	sub	r10,sp,-1724
8000734a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000734e:	c1 d8       	rjmp	80007388 <_vfprintf_r+0x1060>
80007350:	fa c8 f9 50 	sub	r8,sp,-1712
80007354:	1a d8       	st.w	--sp,r8
80007356:	fa c8 fa b8 	sub	r8,sp,-1352
8000735a:	1a d8       	st.w	--sp,r8
8000735c:	fa c8 fb b4 	sub	r8,sp,-1100
80007360:	0c 9b       	mov	r11,r6
80007362:	1a d8       	st.w	--sp,r8
80007364:	04 9a       	mov	r10,r2
80007366:	fa c8 f9 40 	sub	r8,sp,-1728
8000736a:	fa c9 ff b4 	sub	r9,sp,-76
8000736e:	08 9c       	mov	r12,r4
80007370:	fe b0 f6 44 	rcall	80005ff8 <get_arg>
80007374:	2f dd       	sub	sp,-12
80007376:	78 06       	ld.w	r6,r12[0x0]
80007378:	c2 08       	rjmp	800073b8 <_vfprintf_r+0x1090>
8000737a:	2f f7       	sub	r7,-1
8000737c:	10 39       	cp.w	r9,r8
8000737e:	c0 84       	brge	8000738e <_vfprintf_r+0x1066>
80007380:	fa c9 f9 44 	sub	r9,sp,-1724
80007384:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007388:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000738c:	c1 68       	rjmp	800073b8 <_vfprintf_r+0x1090>
8000738e:	41 09       	lddsp	r9,sp[0x40]
80007390:	59 f8       	cp.w	r8,31
80007392:	e0 89 00 10 	brgt	800073b2 <_vfprintf_r+0x108a>
80007396:	f2 ca ff fc 	sub	r10,r9,-4
8000739a:	51 0a       	stdsp	sp[0x40],r10
8000739c:	72 06       	ld.w	r6,r9[0x0]
8000739e:	fa ce f9 44 	sub	lr,sp,-1724
800073a2:	fc 08 00 39 	add	r9,lr,r8<<0x3
800073a6:	f3 46 fd 88 	st.w	r9[-632],r6
800073aa:	2f f8       	sub	r8,-1
800073ac:	fb 48 06 b4 	st.w	sp[1716],r8
800073b0:	c0 48       	rjmp	800073b8 <_vfprintf_r+0x1090>
800073b2:	72 06       	ld.w	r6,r9[0x0]
800073b4:	2f c9       	sub	r9,-4
800073b6:	51 09       	stdsp	sp[0x40],r9
800073b8:	40 2c       	lddsp	r12,sp[0x8]
800073ba:	58 0c       	cp.w	r12,0
800073bc:	c1 05       	brlt	800073dc <_vfprintf_r+0x10b4>
800073be:	18 9a       	mov	r10,r12
800073c0:	30 0b       	mov	r11,0
800073c2:	0c 9c       	mov	r12,r6
800073c4:	e0 a0 12 38 	rcall	80009834 <memchr>
800073c8:	e0 80 02 df 	breq	80007986 <_vfprintf_r+0x165e>
800073cc:	f8 06 01 02 	sub	r2,r12,r6
800073d0:	40 2b       	lddsp	r11,sp[0x8]
800073d2:	16 32       	cp.w	r2,r11
800073d4:	e0 89 02 d9 	brgt	80007986 <_vfprintf_r+0x165e>
800073d8:	e0 8f 02 d4 	bral	80007980 <_vfprintf_r+0x1658>
800073dc:	30 0a       	mov	r10,0
800073de:	0c 9c       	mov	r12,r6
800073e0:	50 2a       	stdsp	sp[0x8],r10
800073e2:	e0 a0 15 99 	rcall	80009f14 <strlen>
800073e6:	18 92       	mov	r2,r12
800073e8:	e0 8f 02 d2 	bral	8000798c <_vfprintf_r+0x1664>
800073ec:	50 a7       	stdsp	sp[0x28],r7
800073ee:	50 80       	stdsp	sp[0x20],r0
800073f0:	0c 97       	mov	r7,r6
800073f2:	04 94       	mov	r4,r2
800073f4:	06 96       	mov	r6,r3
800073f6:	02 92       	mov	r2,r1
800073f8:	40 93       	lddsp	r3,sp[0x24]
800073fa:	10 90       	mov	r0,r8
800073fc:	40 41       	lddsp	r1,sp[0x10]
800073fe:	a5 a5       	sbr	r5,0x4
80007400:	c0 a8       	rjmp	80007414 <_vfprintf_r+0x10ec>
80007402:	50 a7       	stdsp	sp[0x28],r7
80007404:	50 80       	stdsp	sp[0x20],r0
80007406:	0c 97       	mov	r7,r6
80007408:	04 94       	mov	r4,r2
8000740a:	06 96       	mov	r6,r3
8000740c:	02 92       	mov	r2,r1
8000740e:	40 93       	lddsp	r3,sp[0x24]
80007410:	10 90       	mov	r0,r8
80007412:	40 41       	lddsp	r1,sp[0x10]
80007414:	ed b5 00 05 	bld	r5,0x5
80007418:	c5 61       	brne	800074c4 <_vfprintf_r+0x119c>
8000741a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000741e:	40 39       	lddsp	r9,sp[0xc]
80007420:	58 09       	cp.w	r9,0
80007422:	c2 10       	breq	80007464 <_vfprintf_r+0x113c>
80007424:	10 36       	cp.w	r6,r8
80007426:	c0 74       	brge	80007434 <_vfprintf_r+0x110c>
80007428:	fa c8 f9 44 	sub	r8,sp,-1724
8000742c:	f0 06 00 36 	add	r6,r8,r6<<0x3
80007430:	c2 38       	rjmp	80007476 <_vfprintf_r+0x114e>
80007432:	d7 03       	nop
80007434:	fa c8 f9 50 	sub	r8,sp,-1712
80007438:	1a d8       	st.w	--sp,r8
8000743a:	fa c8 fa b8 	sub	r8,sp,-1352
8000743e:	1a d8       	st.w	--sp,r8
80007440:	fa c8 fb b4 	sub	r8,sp,-1100
80007444:	1a d8       	st.w	--sp,r8
80007446:	fa c8 f9 40 	sub	r8,sp,-1728
8000744a:	fa c9 ff b4 	sub	r9,sp,-76
8000744e:	04 9a       	mov	r10,r2
80007450:	0c 9b       	mov	r11,r6
80007452:	08 9c       	mov	r12,r4
80007454:	fe b0 f5 d2 	rcall	80005ff8 <get_arg>
80007458:	2f dd       	sub	sp,-12
8000745a:	f8 e8 00 00 	ld.d	r8,r12[0]
8000745e:	fa e9 00 00 	st.d	sp[0],r8
80007462:	c2 e8       	rjmp	800074be <_vfprintf_r+0x1196>
80007464:	ee ca ff ff 	sub	r10,r7,-1
80007468:	10 37       	cp.w	r7,r8
8000746a:	c0 b4       	brge	80007480 <_vfprintf_r+0x1158>
8000746c:	fa c8 f9 44 	sub	r8,sp,-1724
80007470:	14 97       	mov	r7,r10
80007472:	f0 06 00 36 	add	r6,r8,r6<<0x3
80007476:	ec ea fd 88 	ld.d	r10,r6[-632]
8000747a:	fa eb 00 00 	st.d	sp[0],r10
8000747e:	c2 08       	rjmp	800074be <_vfprintf_r+0x1196>
80007480:	41 09       	lddsp	r9,sp[0x40]
80007482:	59 f8       	cp.w	r8,31
80007484:	e0 89 00 16 	brgt	800074b0 <_vfprintf_r+0x1188>
80007488:	f2 e6 00 00 	ld.d	r6,r9[0]
8000748c:	f2 cb ff f8 	sub	r11,r9,-8
80007490:	fa e7 00 00 	st.d	sp[0],r6
80007494:	51 0b       	stdsp	sp[0x40],r11
80007496:	fa c6 f9 44 	sub	r6,sp,-1724
8000749a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000749e:	fa e6 00 00 	ld.d	r6,sp[0]
800074a2:	f2 e7 fd 88 	st.d	r9[-632],r6
800074a6:	2f f8       	sub	r8,-1
800074a8:	14 97       	mov	r7,r10
800074aa:	fb 48 06 b4 	st.w	sp[1716],r8
800074ae:	c0 88       	rjmp	800074be <_vfprintf_r+0x1196>
800074b0:	f2 e6 00 00 	ld.d	r6,r9[0]
800074b4:	2f 89       	sub	r9,-8
800074b6:	fa e7 00 00 	st.d	sp[0],r6
800074ba:	51 09       	stdsp	sp[0x40],r9
800074bc:	14 97       	mov	r7,r10
800074be:	30 18       	mov	r8,1
800074c0:	e0 8f 01 d0 	bral	80007860 <_vfprintf_r+0x1538>
800074c4:	ed b5 00 04 	bld	r5,0x4
800074c8:	c1 61       	brne	800074f4 <_vfprintf_r+0x11cc>
800074ca:	fa f8 06 b4 	ld.w	r8,sp[1716]
800074ce:	40 3e       	lddsp	lr,sp[0xc]
800074d0:	58 0e       	cp.w	lr,0
800074d2:	c0 80       	breq	800074e2 <_vfprintf_r+0x11ba>
800074d4:	10 36       	cp.w	r6,r8
800074d6:	c6 74       	brge	800075a4 <_vfprintf_r+0x127c>
800074d8:	fa cc f9 44 	sub	r12,sp,-1724
800074dc:	f8 06 00 36 	add	r6,r12,r6<<0x3
800074e0:	c8 08       	rjmp	800075e0 <_vfprintf_r+0x12b8>
800074e2:	ee ca ff ff 	sub	r10,r7,-1
800074e6:	10 37       	cp.w	r7,r8
800074e8:	c7 f4       	brge	800075e6 <_vfprintf_r+0x12be>
800074ea:	fa cb f9 44 	sub	r11,sp,-1724
800074ee:	f6 06 00 36 	add	r6,r11,r6<<0x3
800074f2:	c7 68       	rjmp	800075de <_vfprintf_r+0x12b6>
800074f4:	ed b5 00 06 	bld	r5,0x6
800074f8:	c4 a1       	brne	8000758c <_vfprintf_r+0x1264>
800074fa:	fa f8 06 b4 	ld.w	r8,sp[1716]
800074fe:	40 3c       	lddsp	r12,sp[0xc]
80007500:	58 0c       	cp.w	r12,0
80007502:	c1 d0       	breq	8000753c <_vfprintf_r+0x1214>
80007504:	10 36       	cp.w	r6,r8
80007506:	c0 64       	brge	80007512 <_vfprintf_r+0x11ea>
80007508:	fa cb f9 44 	sub	r11,sp,-1724
8000750c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007510:	c1 f8       	rjmp	8000754e <_vfprintf_r+0x1226>
80007512:	fa c8 f9 50 	sub	r8,sp,-1712
80007516:	1a d8       	st.w	--sp,r8
80007518:	fa c8 fa b8 	sub	r8,sp,-1352
8000751c:	1a d8       	st.w	--sp,r8
8000751e:	fa c8 fb b4 	sub	r8,sp,-1100
80007522:	1a d8       	st.w	--sp,r8
80007524:	fa c8 f9 40 	sub	r8,sp,-1728
80007528:	fa c9 ff b4 	sub	r9,sp,-76
8000752c:	04 9a       	mov	r10,r2
8000752e:	0c 9b       	mov	r11,r6
80007530:	08 9c       	mov	r12,r4
80007532:	fe b0 f5 63 	rcall	80005ff8 <get_arg>
80007536:	2f dd       	sub	sp,-12
80007538:	98 18       	ld.sh	r8,r12[0x2]
8000753a:	c2 68       	rjmp	80007586 <_vfprintf_r+0x125e>
8000753c:	ee ca ff ff 	sub	r10,r7,-1
80007540:	10 37       	cp.w	r7,r8
80007542:	c0 94       	brge	80007554 <_vfprintf_r+0x122c>
80007544:	fa c9 f9 44 	sub	r9,sp,-1724
80007548:	14 97       	mov	r7,r10
8000754a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000754e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007552:	c1 a8       	rjmp	80007586 <_vfprintf_r+0x125e>
80007554:	41 09       	lddsp	r9,sp[0x40]
80007556:	59 f8       	cp.w	r8,31
80007558:	e0 89 00 13 	brgt	8000757e <_vfprintf_r+0x1256>
8000755c:	f2 cb ff fc 	sub	r11,r9,-4
80007560:	51 0b       	stdsp	sp[0x40],r11
80007562:	72 09       	ld.w	r9,r9[0x0]
80007564:	fa c6 f9 44 	sub	r6,sp,-1724
80007568:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000756c:	2f f8       	sub	r8,-1
8000756e:	f7 49 fd 88 	st.w	r11[-632],r9
80007572:	fb 48 06 b4 	st.w	sp[1716],r8
80007576:	14 97       	mov	r7,r10
80007578:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000757c:	c0 58       	rjmp	80007586 <_vfprintf_r+0x125e>
8000757e:	92 18       	ld.sh	r8,r9[0x2]
80007580:	14 97       	mov	r7,r10
80007582:	2f c9       	sub	r9,-4
80007584:	51 09       	stdsp	sp[0x40],r9
80007586:	5c 78       	castu.h	r8
80007588:	50 18       	stdsp	sp[0x4],r8
8000758a:	c4 68       	rjmp	80007616 <_vfprintf_r+0x12ee>
8000758c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007590:	40 3c       	lddsp	r12,sp[0xc]
80007592:	58 0c       	cp.w	r12,0
80007594:	c1 d0       	breq	800075ce <_vfprintf_r+0x12a6>
80007596:	10 36       	cp.w	r6,r8
80007598:	c0 64       	brge	800075a4 <_vfprintf_r+0x127c>
8000759a:	fa cb f9 44 	sub	r11,sp,-1724
8000759e:	f6 06 00 36 	add	r6,r11,r6<<0x3
800075a2:	c1 f8       	rjmp	800075e0 <_vfprintf_r+0x12b8>
800075a4:	fa c8 f9 50 	sub	r8,sp,-1712
800075a8:	1a d8       	st.w	--sp,r8
800075aa:	fa c8 fa b8 	sub	r8,sp,-1352
800075ae:	0c 9b       	mov	r11,r6
800075b0:	1a d8       	st.w	--sp,r8
800075b2:	fa c8 fb b4 	sub	r8,sp,-1100
800075b6:	04 9a       	mov	r10,r2
800075b8:	1a d8       	st.w	--sp,r8
800075ba:	08 9c       	mov	r12,r4
800075bc:	fa c8 f9 40 	sub	r8,sp,-1728
800075c0:	fa c9 ff b4 	sub	r9,sp,-76
800075c4:	fe b0 f5 1a 	rcall	80005ff8 <get_arg>
800075c8:	2f dd       	sub	sp,-12
800075ca:	78 0b       	ld.w	r11,r12[0x0]
800075cc:	c2 48       	rjmp	80007614 <_vfprintf_r+0x12ec>
800075ce:	ee ca ff ff 	sub	r10,r7,-1
800075d2:	10 37       	cp.w	r7,r8
800075d4:	c0 94       	brge	800075e6 <_vfprintf_r+0x12be>
800075d6:	fa c9 f9 44 	sub	r9,sp,-1724
800075da:	f2 06 00 36 	add	r6,r9,r6<<0x3
800075de:	14 97       	mov	r7,r10
800075e0:	ec fb fd 88 	ld.w	r11,r6[-632]
800075e4:	c1 88       	rjmp	80007614 <_vfprintf_r+0x12ec>
800075e6:	41 09       	lddsp	r9,sp[0x40]
800075e8:	59 f8       	cp.w	r8,31
800075ea:	e0 89 00 11 	brgt	8000760c <_vfprintf_r+0x12e4>
800075ee:	f2 cb ff fc 	sub	r11,r9,-4
800075f2:	51 0b       	stdsp	sp[0x40],r11
800075f4:	fa c6 f9 44 	sub	r6,sp,-1724
800075f8:	72 0b       	ld.w	r11,r9[0x0]
800075fa:	ec 08 00 39 	add	r9,r6,r8<<0x3
800075fe:	f3 4b fd 88 	st.w	r9[-632],r11
80007602:	2f f8       	sub	r8,-1
80007604:	14 97       	mov	r7,r10
80007606:	fb 48 06 b4 	st.w	sp[1716],r8
8000760a:	c0 58       	rjmp	80007614 <_vfprintf_r+0x12ec>
8000760c:	72 0b       	ld.w	r11,r9[0x0]
8000760e:	14 97       	mov	r7,r10
80007610:	2f c9       	sub	r9,-4
80007612:	51 09       	stdsp	sp[0x40],r9
80007614:	50 1b       	stdsp	sp[0x4],r11
80007616:	30 0e       	mov	lr,0
80007618:	30 18       	mov	r8,1
8000761a:	50 0e       	stdsp	sp[0x0],lr
8000761c:	c2 29       	rjmp	80007860 <_vfprintf_r+0x1538>
8000761e:	50 a7       	stdsp	sp[0x28],r7
80007620:	50 80       	stdsp	sp[0x20],r0
80007622:	0c 97       	mov	r7,r6
80007624:	04 94       	mov	r4,r2
80007626:	06 96       	mov	r6,r3
80007628:	02 92       	mov	r2,r1
8000762a:	fe cc b5 62 	sub	r12,pc,-19102
8000762e:	40 93       	lddsp	r3,sp[0x24]
80007630:	10 90       	mov	r0,r8
80007632:	40 41       	lddsp	r1,sp[0x10]
80007634:	50 dc       	stdsp	sp[0x34],r12
80007636:	ed b5 00 05 	bld	r5,0x5
8000763a:	c5 51       	brne	800076e4 <_vfprintf_r+0x13bc>
8000763c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007640:	40 3b       	lddsp	r11,sp[0xc]
80007642:	58 0b       	cp.w	r11,0
80007644:	c2 20       	breq	80007688 <_vfprintf_r+0x1360>
80007646:	10 36       	cp.w	r6,r8
80007648:	c0 a4       	brge	8000765c <_vfprintf_r+0x1334>
8000764a:	fa ca f9 44 	sub	r10,sp,-1724
8000764e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007652:	ec e8 fd 88 	ld.d	r8,r6[-632]
80007656:	fa e9 00 00 	st.d	sp[0],r8
8000765a:	cf 28       	rjmp	8000783e <_vfprintf_r+0x1516>
8000765c:	fa c8 f9 50 	sub	r8,sp,-1712
80007660:	1a d8       	st.w	--sp,r8
80007662:	fa c8 fa b8 	sub	r8,sp,-1352
80007666:	04 9a       	mov	r10,r2
80007668:	1a d8       	st.w	--sp,r8
8000766a:	0c 9b       	mov	r11,r6
8000766c:	fa c8 fb b4 	sub	r8,sp,-1100
80007670:	08 9c       	mov	r12,r4
80007672:	1a d8       	st.w	--sp,r8
80007674:	fa c8 f9 40 	sub	r8,sp,-1728
80007678:	fa c9 ff b4 	sub	r9,sp,-76
8000767c:	fe b0 f4 be 	rcall	80005ff8 <get_arg>
80007680:	2f dd       	sub	sp,-12
80007682:	f8 ea 00 00 	ld.d	r10,r12[0]
80007686:	c0 c8       	rjmp	8000769e <_vfprintf_r+0x1376>
80007688:	ee ca ff ff 	sub	r10,r7,-1
8000768c:	10 37       	cp.w	r7,r8
8000768e:	c0 b4       	brge	800076a4 <_vfprintf_r+0x137c>
80007690:	fa c9 f9 44 	sub	r9,sp,-1724
80007694:	14 97       	mov	r7,r10
80007696:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000769a:	ec ea fd 88 	ld.d	r10,r6[-632]
8000769e:	fa eb 00 00 	st.d	sp[0],r10
800076a2:	cc e8       	rjmp	8000783e <_vfprintf_r+0x1516>
800076a4:	41 09       	lddsp	r9,sp[0x40]
800076a6:	59 f8       	cp.w	r8,31
800076a8:	e0 89 00 16 	brgt	800076d4 <_vfprintf_r+0x13ac>
800076ac:	f2 e6 00 00 	ld.d	r6,r9[0]
800076b0:	f2 cb ff f8 	sub	r11,r9,-8
800076b4:	fa e7 00 00 	st.d	sp[0],r6
800076b8:	51 0b       	stdsp	sp[0x40],r11
800076ba:	fa c6 f9 44 	sub	r6,sp,-1724
800076be:	ec 08 00 39 	add	r9,r6,r8<<0x3
800076c2:	fa e6 00 00 	ld.d	r6,sp[0]
800076c6:	f2 e7 fd 88 	st.d	r9[-632],r6
800076ca:	2f f8       	sub	r8,-1
800076cc:	14 97       	mov	r7,r10
800076ce:	fb 48 06 b4 	st.w	sp[1716],r8
800076d2:	cb 68       	rjmp	8000783e <_vfprintf_r+0x1516>
800076d4:	f2 e6 00 00 	ld.d	r6,r9[0]
800076d8:	2f 89       	sub	r9,-8
800076da:	fa e7 00 00 	st.d	sp[0],r6
800076de:	51 09       	stdsp	sp[0x40],r9
800076e0:	14 97       	mov	r7,r10
800076e2:	ca e8       	rjmp	8000783e <_vfprintf_r+0x1516>
800076e4:	ed b5 00 04 	bld	r5,0x4
800076e8:	c1 71       	brne	80007716 <_vfprintf_r+0x13ee>
800076ea:	fa f8 06 b4 	ld.w	r8,sp[1716]
800076ee:	40 3e       	lddsp	lr,sp[0xc]
800076f0:	58 0e       	cp.w	lr,0
800076f2:	c0 80       	breq	80007702 <_vfprintf_r+0x13da>
800076f4:	10 36       	cp.w	r6,r8
800076f6:	c6 94       	brge	800077c8 <_vfprintf_r+0x14a0>
800076f8:	fa cc f9 44 	sub	r12,sp,-1724
800076fc:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007700:	c8 28       	rjmp	80007804 <_vfprintf_r+0x14dc>
80007702:	ee ca ff ff 	sub	r10,r7,-1
80007706:	10 37       	cp.w	r7,r8
80007708:	e0 84 00 81 	brge	8000780a <_vfprintf_r+0x14e2>
8000770c:	fa cb f9 44 	sub	r11,sp,-1724
80007710:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007714:	c7 78       	rjmp	80007802 <_vfprintf_r+0x14da>
80007716:	ed b5 00 06 	bld	r5,0x6
8000771a:	c4 b1       	brne	800077b0 <_vfprintf_r+0x1488>
8000771c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007720:	40 3c       	lddsp	r12,sp[0xc]
80007722:	58 0c       	cp.w	r12,0
80007724:	c1 d0       	breq	8000775e <_vfprintf_r+0x1436>
80007726:	10 36       	cp.w	r6,r8
80007728:	c0 64       	brge	80007734 <_vfprintf_r+0x140c>
8000772a:	fa cb f9 44 	sub	r11,sp,-1724
8000772e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007732:	c1 f8       	rjmp	80007770 <_vfprintf_r+0x1448>
80007734:	fa c8 f9 50 	sub	r8,sp,-1712
80007738:	1a d8       	st.w	--sp,r8
8000773a:	fa c8 fa b8 	sub	r8,sp,-1352
8000773e:	1a d8       	st.w	--sp,r8
80007740:	fa c8 fb b4 	sub	r8,sp,-1100
80007744:	1a d8       	st.w	--sp,r8
80007746:	fa c8 f9 40 	sub	r8,sp,-1728
8000774a:	fa c9 ff b4 	sub	r9,sp,-76
8000774e:	04 9a       	mov	r10,r2
80007750:	0c 9b       	mov	r11,r6
80007752:	08 9c       	mov	r12,r4
80007754:	fe b0 f4 52 	rcall	80005ff8 <get_arg>
80007758:	2f dd       	sub	sp,-12
8000775a:	98 18       	ld.sh	r8,r12[0x2]
8000775c:	c2 78       	rjmp	800077aa <_vfprintf_r+0x1482>
8000775e:	ee ca ff ff 	sub	r10,r7,-1
80007762:	10 37       	cp.w	r7,r8
80007764:	c0 a4       	brge	80007778 <_vfprintf_r+0x1450>
80007766:	fa c9 f9 44 	sub	r9,sp,-1724
8000776a:	14 97       	mov	r7,r10
8000776c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007770:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007774:	c1 b8       	rjmp	800077aa <_vfprintf_r+0x1482>
80007776:	d7 03       	nop
80007778:	41 09       	lddsp	r9,sp[0x40]
8000777a:	59 f8       	cp.w	r8,31
8000777c:	e0 89 00 13 	brgt	800077a2 <_vfprintf_r+0x147a>
80007780:	f2 cb ff fc 	sub	r11,r9,-4
80007784:	51 0b       	stdsp	sp[0x40],r11
80007786:	72 09       	ld.w	r9,r9[0x0]
80007788:	fa c6 f9 44 	sub	r6,sp,-1724
8000778c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007790:	2f f8       	sub	r8,-1
80007792:	f7 49 fd 88 	st.w	r11[-632],r9
80007796:	fb 48 06 b4 	st.w	sp[1716],r8
8000779a:	14 97       	mov	r7,r10
8000779c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800077a0:	c0 58       	rjmp	800077aa <_vfprintf_r+0x1482>
800077a2:	92 18       	ld.sh	r8,r9[0x2]
800077a4:	14 97       	mov	r7,r10
800077a6:	2f c9       	sub	r9,-4
800077a8:	51 09       	stdsp	sp[0x40],r9
800077aa:	5c 78       	castu.h	r8
800077ac:	50 18       	stdsp	sp[0x4],r8
800077ae:	c4 68       	rjmp	8000783a <_vfprintf_r+0x1512>
800077b0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800077b4:	40 3c       	lddsp	r12,sp[0xc]
800077b6:	58 0c       	cp.w	r12,0
800077b8:	c1 d0       	breq	800077f2 <_vfprintf_r+0x14ca>
800077ba:	10 36       	cp.w	r6,r8
800077bc:	c0 64       	brge	800077c8 <_vfprintf_r+0x14a0>
800077be:	fa cb f9 44 	sub	r11,sp,-1724
800077c2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800077c6:	c1 f8       	rjmp	80007804 <_vfprintf_r+0x14dc>
800077c8:	fa c8 f9 50 	sub	r8,sp,-1712
800077cc:	1a d8       	st.w	--sp,r8
800077ce:	fa c8 fa b8 	sub	r8,sp,-1352
800077d2:	0c 9b       	mov	r11,r6
800077d4:	1a d8       	st.w	--sp,r8
800077d6:	fa c8 fb b4 	sub	r8,sp,-1100
800077da:	04 9a       	mov	r10,r2
800077dc:	1a d8       	st.w	--sp,r8
800077de:	08 9c       	mov	r12,r4
800077e0:	fa c8 f9 40 	sub	r8,sp,-1728
800077e4:	fa c9 ff b4 	sub	r9,sp,-76
800077e8:	fe b0 f4 08 	rcall	80005ff8 <get_arg>
800077ec:	2f dd       	sub	sp,-12
800077ee:	78 0b       	ld.w	r11,r12[0x0]
800077f0:	c2 48       	rjmp	80007838 <_vfprintf_r+0x1510>
800077f2:	ee ca ff ff 	sub	r10,r7,-1
800077f6:	10 37       	cp.w	r7,r8
800077f8:	c0 94       	brge	8000780a <_vfprintf_r+0x14e2>
800077fa:	fa c9 f9 44 	sub	r9,sp,-1724
800077fe:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007802:	14 97       	mov	r7,r10
80007804:	ec fb fd 88 	ld.w	r11,r6[-632]
80007808:	c1 88       	rjmp	80007838 <_vfprintf_r+0x1510>
8000780a:	41 09       	lddsp	r9,sp[0x40]
8000780c:	59 f8       	cp.w	r8,31
8000780e:	e0 89 00 11 	brgt	80007830 <_vfprintf_r+0x1508>
80007812:	f2 cb ff fc 	sub	r11,r9,-4
80007816:	51 0b       	stdsp	sp[0x40],r11
80007818:	fa c6 f9 44 	sub	r6,sp,-1724
8000781c:	72 0b       	ld.w	r11,r9[0x0]
8000781e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007822:	f3 4b fd 88 	st.w	r9[-632],r11
80007826:	2f f8       	sub	r8,-1
80007828:	14 97       	mov	r7,r10
8000782a:	fb 48 06 b4 	st.w	sp[1716],r8
8000782e:	c0 58       	rjmp	80007838 <_vfprintf_r+0x1510>
80007830:	72 0b       	ld.w	r11,r9[0x0]
80007832:	14 97       	mov	r7,r10
80007834:	2f c9       	sub	r9,-4
80007836:	51 09       	stdsp	sp[0x40],r9
80007838:	50 1b       	stdsp	sp[0x4],r11
8000783a:	30 0e       	mov	lr,0
8000783c:	50 0e       	stdsp	sp[0x0],lr
8000783e:	40 08       	lddsp	r8,sp[0x0]
80007840:	40 1c       	lddsp	r12,sp[0x4]
80007842:	18 48       	or	r8,r12
80007844:	5f 19       	srne	r9
80007846:	0a 98       	mov	r8,r5
80007848:	eb e9 00 09 	and	r9,r5,r9
8000784c:	a1 b8       	sbr	r8,0x1
8000784e:	58 09       	cp.w	r9,0
80007850:	c0 70       	breq	8000785e <_vfprintf_r+0x1536>
80007852:	10 95       	mov	r5,r8
80007854:	fb 60 06 b9 	st.b	sp[1721],r0
80007858:	33 08       	mov	r8,48
8000785a:	fb 68 06 b8 	st.b	sp[1720],r8
8000785e:	30 28       	mov	r8,2
80007860:	30 09       	mov	r9,0
80007862:	fb 69 06 bb 	st.b	sp[1723],r9
80007866:	0a 99       	mov	r9,r5
80007868:	a7 d9       	cbr	r9,0x7
8000786a:	40 2b       	lddsp	r11,sp[0x8]
8000786c:	40 16       	lddsp	r6,sp[0x4]
8000786e:	58 0b       	cp.w	r11,0
80007870:	5f 1a       	srne	r10
80007872:	f2 05 17 40 	movge	r5,r9
80007876:	fa c2 f9 78 	sub	r2,sp,-1672
8000787a:	40 09       	lddsp	r9,sp[0x0]
8000787c:	0c 49       	or	r9,r6
8000787e:	5f 19       	srne	r9
80007880:	f5 e9 10 09 	or	r9,r10,r9
80007884:	c5 c0       	breq	8000793c <_vfprintf_r+0x1614>
80007886:	30 19       	mov	r9,1
80007888:	f2 08 18 00 	cp.b	r8,r9
8000788c:	c0 60       	breq	80007898 <_vfprintf_r+0x1570>
8000788e:	30 29       	mov	r9,2
80007890:	f2 08 18 00 	cp.b	r8,r9
80007894:	c0 41       	brne	8000789c <_vfprintf_r+0x1574>
80007896:	c3 c8       	rjmp	8000790e <_vfprintf_r+0x15e6>
80007898:	04 96       	mov	r6,r2
8000789a:	c3 08       	rjmp	800078fa <_vfprintf_r+0x15d2>
8000789c:	04 96       	mov	r6,r2
8000789e:	fa e8 00 00 	ld.d	r8,sp[0]
800078a2:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800078a6:	2d 0a       	sub	r10,-48
800078a8:	0c fa       	st.b	--r6,r10
800078aa:	f0 0b 16 03 	lsr	r11,r8,0x3
800078ae:	f2 0c 16 03 	lsr	r12,r9,0x3
800078b2:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
800078b6:	18 99       	mov	r9,r12
800078b8:	16 98       	mov	r8,r11
800078ba:	58 08       	cp.w	r8,0
800078bc:	5c 29       	cpc	r9
800078be:	cf 21       	brne	800078a2 <_vfprintf_r+0x157a>
800078c0:	fa e9 00 00 	st.d	sp[0],r8
800078c4:	ed b5 00 00 	bld	r5,0x0
800078c8:	c4 51       	brne	80007952 <_vfprintf_r+0x162a>
800078ca:	33 09       	mov	r9,48
800078cc:	f2 0a 18 00 	cp.b	r10,r9
800078d0:	c4 10       	breq	80007952 <_vfprintf_r+0x162a>
800078d2:	0c f9       	st.b	--r6,r9
800078d4:	c3 f8       	rjmp	80007952 <_vfprintf_r+0x162a>
800078d6:	fa ea 00 00 	ld.d	r10,sp[0]
800078da:	30 a8       	mov	r8,10
800078dc:	30 09       	mov	r9,0
800078de:	e0 a0 1a 19 	rcall	8000ad10 <__avr32_umod64>
800078e2:	30 a8       	mov	r8,10
800078e4:	2d 0a       	sub	r10,-48
800078e6:	30 09       	mov	r9,0
800078e8:	ac 8a       	st.b	r6[0x0],r10
800078ea:	fa ea 00 00 	ld.d	r10,sp[0]
800078ee:	e0 a0 18 df 	rcall	8000aaac <__avr32_udiv64>
800078f2:	16 99       	mov	r9,r11
800078f4:	14 98       	mov	r8,r10
800078f6:	fa e9 00 00 	st.d	sp[0],r8
800078fa:	20 16       	sub	r6,1
800078fc:	fa ea 00 00 	ld.d	r10,sp[0]
80007900:	58 9a       	cp.w	r10,9
80007902:	5c 2b       	cpc	r11
80007904:	fe 9b ff e9 	brhi	800078d6 <_vfprintf_r+0x15ae>
80007908:	1b f8       	ld.ub	r8,sp[0x7]
8000790a:	2d 08       	sub	r8,-48
8000790c:	c2 08       	rjmp	8000794c <_vfprintf_r+0x1624>
8000790e:	04 96       	mov	r6,r2
80007910:	fa e8 00 00 	ld.d	r8,sp[0]
80007914:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80007918:	40 de       	lddsp	lr,sp[0x34]
8000791a:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000791e:	0c fa       	st.b	--r6,r10
80007920:	f2 0b 16 04 	lsr	r11,r9,0x4
80007924:	f0 0a 16 04 	lsr	r10,r8,0x4
80007928:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8000792c:	16 99       	mov	r9,r11
8000792e:	14 98       	mov	r8,r10
80007930:	58 08       	cp.w	r8,0
80007932:	5c 29       	cpc	r9
80007934:	cf 01       	brne	80007914 <_vfprintf_r+0x15ec>
80007936:	fa e9 00 00 	st.d	sp[0],r8
8000793a:	c0 c8       	rjmp	80007952 <_vfprintf_r+0x162a>
8000793c:	58 08       	cp.w	r8,0
8000793e:	c0 91       	brne	80007950 <_vfprintf_r+0x1628>
80007940:	ed b5 00 00 	bld	r5,0x0
80007944:	c0 61       	brne	80007950 <_vfprintf_r+0x1628>
80007946:	fa c6 f9 79 	sub	r6,sp,-1671
8000794a:	33 08       	mov	r8,48
8000794c:	ac 88       	st.b	r6[0x0],r8
8000794e:	c0 28       	rjmp	80007952 <_vfprintf_r+0x162a>
80007950:	04 96       	mov	r6,r2
80007952:	0c 12       	sub	r2,r6
80007954:	c1 c8       	rjmp	8000798c <_vfprintf_r+0x1664>
80007956:	50 a7       	stdsp	sp[0x28],r7
80007958:	50 80       	stdsp	sp[0x20],r0
8000795a:	40 93       	lddsp	r3,sp[0x24]
8000795c:	0c 97       	mov	r7,r6
8000795e:	10 90       	mov	r0,r8
80007960:	04 94       	mov	r4,r2
80007962:	40 41       	lddsp	r1,sp[0x10]
80007964:	58 08       	cp.w	r8,0
80007966:	e0 80 04 4f 	breq	80008204 <_vfprintf_r+0x1edc>
8000796a:	fb 68 06 60 	st.b	sp[1632],r8
8000796e:	30 0c       	mov	r12,0
80007970:	30 08       	mov	r8,0
80007972:	30 12       	mov	r2,1
80007974:	fb 68 06 bb 	st.b	sp[1723],r8
80007978:	50 2c       	stdsp	sp[0x8],r12
8000797a:	fa c6 f9 a0 	sub	r6,sp,-1632
8000797e:	c0 78       	rjmp	8000798c <_vfprintf_r+0x1664>
80007980:	30 0b       	mov	r11,0
80007982:	50 2b       	stdsp	sp[0x8],r11
80007984:	c0 48       	rjmp	8000798c <_vfprintf_r+0x1664>
80007986:	40 22       	lddsp	r2,sp[0x8]
80007988:	30 0a       	mov	r10,0
8000798a:	50 2a       	stdsp	sp[0x8],r10
8000798c:	40 29       	lddsp	r9,sp[0x8]
8000798e:	e4 09 0c 49 	max	r9,r2,r9
80007992:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80007996:	50 39       	stdsp	sp[0xc],r9
80007998:	0a 9e       	mov	lr,r5
8000799a:	30 09       	mov	r9,0
8000799c:	e2 1e 00 02 	andl	lr,0x2,COH
800079a0:	f2 08 18 00 	cp.b	r8,r9
800079a4:	fb f8 10 03 	ld.wne	r8,sp[0xc]
800079a8:	f7 b8 01 ff 	subne	r8,-1
800079ac:	fb f8 1a 03 	st.wne	sp[0xc],r8
800079b0:	0a 9b       	mov	r11,r5
800079b2:	58 0e       	cp.w	lr,0
800079b4:	fb fc 10 03 	ld.wne	r12,sp[0xc]
800079b8:	f7 bc 01 fe 	subne	r12,-2
800079bc:	fb fc 1a 03 	st.wne	sp[0xc],r12
800079c0:	e2 1b 00 84 	andl	r11,0x84,COH
800079c4:	50 fe       	stdsp	sp[0x3c],lr
800079c6:	50 9b       	stdsp	sp[0x24],r11
800079c8:	c4 71       	brne	80007a56 <_vfprintf_r+0x172e>
800079ca:	40 8a       	lddsp	r10,sp[0x20]
800079cc:	40 39       	lddsp	r9,sp[0xc]
800079ce:	12 1a       	sub	r10,r9
800079d0:	50 4a       	stdsp	sp[0x10],r10
800079d2:	58 0a       	cp.w	r10,0
800079d4:	e0 89 00 20 	brgt	80007a14 <_vfprintf_r+0x16ec>
800079d8:	c3 f8       	rjmp	80007a56 <_vfprintf_r+0x172e>
800079da:	2f 09       	sub	r9,-16
800079dc:	2f f8       	sub	r8,-1
800079de:	fe ce b8 fe 	sub	lr,pc,-18178
800079e2:	31 0c       	mov	r12,16
800079e4:	fb 49 06 90 	st.w	sp[1680],r9
800079e8:	87 0e       	st.w	r3[0x0],lr
800079ea:	87 1c       	st.w	r3[0x4],r12
800079ec:	fb 48 06 8c 	st.w	sp[1676],r8
800079f0:	58 78       	cp.w	r8,7
800079f2:	e0 89 00 04 	brgt	800079fa <_vfprintf_r+0x16d2>
800079f6:	2f 83       	sub	r3,-8
800079f8:	c0 b8       	rjmp	80007a0e <_vfprintf_r+0x16e6>
800079fa:	fa ca f9 78 	sub	r10,sp,-1672
800079fe:	02 9b       	mov	r11,r1
80007a00:	08 9c       	mov	r12,r4
80007a02:	fe b0 f4 85 	rcall	8000630c <__sprint_r>
80007a06:	e0 81 04 10 	brne	80008226 <_vfprintf_r+0x1efe>
80007a0a:	fa c3 f9 e0 	sub	r3,sp,-1568
80007a0e:	40 4b       	lddsp	r11,sp[0x10]
80007a10:	21 0b       	sub	r11,16
80007a12:	50 4b       	stdsp	sp[0x10],r11
80007a14:	fa f9 06 90 	ld.w	r9,sp[1680]
80007a18:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007a1c:	fe ca b9 3c 	sub	r10,pc,-18116
80007a20:	40 4e       	lddsp	lr,sp[0x10]
80007a22:	59 0e       	cp.w	lr,16
80007a24:	fe 99 ff db 	brgt	800079da <_vfprintf_r+0x16b2>
80007a28:	1c 09       	add	r9,lr
80007a2a:	2f f8       	sub	r8,-1
80007a2c:	87 0a       	st.w	r3[0x0],r10
80007a2e:	fb 49 06 90 	st.w	sp[1680],r9
80007a32:	87 1e       	st.w	r3[0x4],lr
80007a34:	fb 48 06 8c 	st.w	sp[1676],r8
80007a38:	58 78       	cp.w	r8,7
80007a3a:	e0 89 00 04 	brgt	80007a42 <_vfprintf_r+0x171a>
80007a3e:	2f 83       	sub	r3,-8
80007a40:	c0 b8       	rjmp	80007a56 <_vfprintf_r+0x172e>
80007a42:	fa ca f9 78 	sub	r10,sp,-1672
80007a46:	02 9b       	mov	r11,r1
80007a48:	08 9c       	mov	r12,r4
80007a4a:	fe b0 f4 61 	rcall	8000630c <__sprint_r>
80007a4e:	e0 81 03 ec 	brne	80008226 <_vfprintf_r+0x1efe>
80007a52:	fa c3 f9 e0 	sub	r3,sp,-1568
80007a56:	30 09       	mov	r9,0
80007a58:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80007a5c:	f2 08 18 00 	cp.b	r8,r9
80007a60:	c1 f0       	breq	80007a9e <_vfprintf_r+0x1776>
80007a62:	fa f8 06 90 	ld.w	r8,sp[1680]
80007a66:	fa c9 f9 45 	sub	r9,sp,-1723
80007a6a:	2f f8       	sub	r8,-1
80007a6c:	87 09       	st.w	r3[0x0],r9
80007a6e:	fb 48 06 90 	st.w	sp[1680],r8
80007a72:	30 19       	mov	r9,1
80007a74:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007a78:	87 19       	st.w	r3[0x4],r9
80007a7a:	2f f8       	sub	r8,-1
80007a7c:	fb 48 06 8c 	st.w	sp[1676],r8
80007a80:	58 78       	cp.w	r8,7
80007a82:	e0 89 00 04 	brgt	80007a8a <_vfprintf_r+0x1762>
80007a86:	2f 83       	sub	r3,-8
80007a88:	c0 b8       	rjmp	80007a9e <_vfprintf_r+0x1776>
80007a8a:	fa ca f9 78 	sub	r10,sp,-1672
80007a8e:	02 9b       	mov	r11,r1
80007a90:	08 9c       	mov	r12,r4
80007a92:	fe b0 f4 3d 	rcall	8000630c <__sprint_r>
80007a96:	e0 81 03 c8 	brne	80008226 <_vfprintf_r+0x1efe>
80007a9a:	fa c3 f9 e0 	sub	r3,sp,-1568
80007a9e:	40 fc       	lddsp	r12,sp[0x3c]
80007aa0:	58 0c       	cp.w	r12,0
80007aa2:	c1 f0       	breq	80007ae0 <_vfprintf_r+0x17b8>
80007aa4:	fa f8 06 90 	ld.w	r8,sp[1680]
80007aa8:	fa c9 f9 48 	sub	r9,sp,-1720
80007aac:	2f e8       	sub	r8,-2
80007aae:	87 09       	st.w	r3[0x0],r9
80007ab0:	fb 48 06 90 	st.w	sp[1680],r8
80007ab4:	30 29       	mov	r9,2
80007ab6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007aba:	87 19       	st.w	r3[0x4],r9
80007abc:	2f f8       	sub	r8,-1
80007abe:	fb 48 06 8c 	st.w	sp[1676],r8
80007ac2:	58 78       	cp.w	r8,7
80007ac4:	e0 89 00 04 	brgt	80007acc <_vfprintf_r+0x17a4>
80007ac8:	2f 83       	sub	r3,-8
80007aca:	c0 b8       	rjmp	80007ae0 <_vfprintf_r+0x17b8>
80007acc:	fa ca f9 78 	sub	r10,sp,-1672
80007ad0:	02 9b       	mov	r11,r1
80007ad2:	08 9c       	mov	r12,r4
80007ad4:	fe b0 f4 1c 	rcall	8000630c <__sprint_r>
80007ad8:	e0 81 03 a7 	brne	80008226 <_vfprintf_r+0x1efe>
80007adc:	fa c3 f9 e0 	sub	r3,sp,-1568
80007ae0:	40 9b       	lddsp	r11,sp[0x24]
80007ae2:	e0 4b 00 80 	cp.w	r11,128
80007ae6:	c4 71       	brne	80007b74 <_vfprintf_r+0x184c>
80007ae8:	40 8a       	lddsp	r10,sp[0x20]
80007aea:	40 39       	lddsp	r9,sp[0xc]
80007aec:	12 1a       	sub	r10,r9
80007aee:	50 4a       	stdsp	sp[0x10],r10
80007af0:	58 0a       	cp.w	r10,0
80007af2:	e0 89 00 20 	brgt	80007b32 <_vfprintf_r+0x180a>
80007af6:	c3 f8       	rjmp	80007b74 <_vfprintf_r+0x184c>
80007af8:	2f 09       	sub	r9,-16
80007afa:	2f f8       	sub	r8,-1
80007afc:	fe ce ba 0c 	sub	lr,pc,-17908
80007b00:	31 0c       	mov	r12,16
80007b02:	fb 49 06 90 	st.w	sp[1680],r9
80007b06:	87 0e       	st.w	r3[0x0],lr
80007b08:	87 1c       	st.w	r3[0x4],r12
80007b0a:	fb 48 06 8c 	st.w	sp[1676],r8
80007b0e:	58 78       	cp.w	r8,7
80007b10:	e0 89 00 04 	brgt	80007b18 <_vfprintf_r+0x17f0>
80007b14:	2f 83       	sub	r3,-8
80007b16:	c0 b8       	rjmp	80007b2c <_vfprintf_r+0x1804>
80007b18:	fa ca f9 78 	sub	r10,sp,-1672
80007b1c:	02 9b       	mov	r11,r1
80007b1e:	08 9c       	mov	r12,r4
80007b20:	fe b0 f3 f6 	rcall	8000630c <__sprint_r>
80007b24:	e0 81 03 81 	brne	80008226 <_vfprintf_r+0x1efe>
80007b28:	fa c3 f9 e0 	sub	r3,sp,-1568
80007b2c:	40 4b       	lddsp	r11,sp[0x10]
80007b2e:	21 0b       	sub	r11,16
80007b30:	50 4b       	stdsp	sp[0x10],r11
80007b32:	fa f9 06 90 	ld.w	r9,sp[1680]
80007b36:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007b3a:	fe ca ba 4a 	sub	r10,pc,-17846
80007b3e:	40 4e       	lddsp	lr,sp[0x10]
80007b40:	59 0e       	cp.w	lr,16
80007b42:	fe 99 ff db 	brgt	80007af8 <_vfprintf_r+0x17d0>
80007b46:	1c 09       	add	r9,lr
80007b48:	2f f8       	sub	r8,-1
80007b4a:	87 0a       	st.w	r3[0x0],r10
80007b4c:	fb 49 06 90 	st.w	sp[1680],r9
80007b50:	87 1e       	st.w	r3[0x4],lr
80007b52:	fb 48 06 8c 	st.w	sp[1676],r8
80007b56:	58 78       	cp.w	r8,7
80007b58:	e0 89 00 04 	brgt	80007b60 <_vfprintf_r+0x1838>
80007b5c:	2f 83       	sub	r3,-8
80007b5e:	c0 b8       	rjmp	80007b74 <_vfprintf_r+0x184c>
80007b60:	fa ca f9 78 	sub	r10,sp,-1672
80007b64:	02 9b       	mov	r11,r1
80007b66:	08 9c       	mov	r12,r4
80007b68:	fe b0 f3 d2 	rcall	8000630c <__sprint_r>
80007b6c:	e0 81 03 5d 	brne	80008226 <_vfprintf_r+0x1efe>
80007b70:	fa c3 f9 e0 	sub	r3,sp,-1568
80007b74:	40 2c       	lddsp	r12,sp[0x8]
80007b76:	04 1c       	sub	r12,r2
80007b78:	50 2c       	stdsp	sp[0x8],r12
80007b7a:	58 0c       	cp.w	r12,0
80007b7c:	e0 89 00 20 	brgt	80007bbc <_vfprintf_r+0x1894>
80007b80:	c3 f8       	rjmp	80007bfe <_vfprintf_r+0x18d6>
80007b82:	2f 09       	sub	r9,-16
80007b84:	2f f8       	sub	r8,-1
80007b86:	fe cb ba 96 	sub	r11,pc,-17770
80007b8a:	31 0a       	mov	r10,16
80007b8c:	fb 49 06 90 	st.w	sp[1680],r9
80007b90:	87 0b       	st.w	r3[0x0],r11
80007b92:	87 1a       	st.w	r3[0x4],r10
80007b94:	fb 48 06 8c 	st.w	sp[1676],r8
80007b98:	58 78       	cp.w	r8,7
80007b9a:	e0 89 00 04 	brgt	80007ba2 <_vfprintf_r+0x187a>
80007b9e:	2f 83       	sub	r3,-8
80007ba0:	c0 b8       	rjmp	80007bb6 <_vfprintf_r+0x188e>
80007ba2:	fa ca f9 78 	sub	r10,sp,-1672
80007ba6:	02 9b       	mov	r11,r1
80007ba8:	08 9c       	mov	r12,r4
80007baa:	fe b0 f3 b1 	rcall	8000630c <__sprint_r>
80007bae:	e0 81 03 3c 	brne	80008226 <_vfprintf_r+0x1efe>
80007bb2:	fa c3 f9 e0 	sub	r3,sp,-1568
80007bb6:	40 29       	lddsp	r9,sp[0x8]
80007bb8:	21 09       	sub	r9,16
80007bba:	50 29       	stdsp	sp[0x8],r9
80007bbc:	fa f9 06 90 	ld.w	r9,sp[1680]
80007bc0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007bc4:	fe ca ba d4 	sub	r10,pc,-17708
80007bc8:	40 2e       	lddsp	lr,sp[0x8]
80007bca:	59 0e       	cp.w	lr,16
80007bcc:	fe 99 ff db 	brgt	80007b82 <_vfprintf_r+0x185a>
80007bd0:	1c 09       	add	r9,lr
80007bd2:	2f f8       	sub	r8,-1
80007bd4:	87 0a       	st.w	r3[0x0],r10
80007bd6:	fb 49 06 90 	st.w	sp[1680],r9
80007bda:	87 1e       	st.w	r3[0x4],lr
80007bdc:	fb 48 06 8c 	st.w	sp[1676],r8
80007be0:	58 78       	cp.w	r8,7
80007be2:	e0 89 00 04 	brgt	80007bea <_vfprintf_r+0x18c2>
80007be6:	2f 83       	sub	r3,-8
80007be8:	c0 b8       	rjmp	80007bfe <_vfprintf_r+0x18d6>
80007bea:	fa ca f9 78 	sub	r10,sp,-1672
80007bee:	02 9b       	mov	r11,r1
80007bf0:	08 9c       	mov	r12,r4
80007bf2:	fe b0 f3 8d 	rcall	8000630c <__sprint_r>
80007bf6:	e0 81 03 18 	brne	80008226 <_vfprintf_r+0x1efe>
80007bfa:	fa c3 f9 e0 	sub	r3,sp,-1568
80007bfe:	ed b5 00 08 	bld	r5,0x8
80007c02:	c0 b0       	breq	80007c18 <_vfprintf_r+0x18f0>
80007c04:	fa f8 06 90 	ld.w	r8,sp[1680]
80007c08:	87 12       	st.w	r3[0x4],r2
80007c0a:	87 06       	st.w	r3[0x0],r6
80007c0c:	f0 02 00 02 	add	r2,r8,r2
80007c10:	fb 42 06 90 	st.w	sp[1680],r2
80007c14:	e0 8f 01 d4 	bral	80007fbc <_vfprintf_r+0x1c94>
80007c18:	e0 40 00 65 	cp.w	r0,101
80007c1c:	e0 8a 01 d6 	brle	80007fc8 <_vfprintf_r+0x1ca0>
80007c20:	30 08       	mov	r8,0
80007c22:	30 09       	mov	r9,0
80007c24:	40 5b       	lddsp	r11,sp[0x14]
80007c26:	40 7a       	lddsp	r10,sp[0x1c]
80007c28:	e0 a0 15 3b 	rcall	8000a69e <__avr32_f64_cmp_eq>
80007c2c:	c7 90       	breq	80007d1e <_vfprintf_r+0x19f6>
80007c2e:	fa f8 06 90 	ld.w	r8,sp[1680]
80007c32:	fe c9 bb 56 	sub	r9,pc,-17578
80007c36:	2f f8       	sub	r8,-1
80007c38:	87 09       	st.w	r3[0x0],r9
80007c3a:	fb 48 06 90 	st.w	sp[1680],r8
80007c3e:	30 19       	mov	r9,1
80007c40:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007c44:	87 19       	st.w	r3[0x4],r9
80007c46:	2f f8       	sub	r8,-1
80007c48:	fb 48 06 8c 	st.w	sp[1676],r8
80007c4c:	58 78       	cp.w	r8,7
80007c4e:	e0 89 00 05 	brgt	80007c58 <_vfprintf_r+0x1930>
80007c52:	2f 83       	sub	r3,-8
80007c54:	c0 c8       	rjmp	80007c6c <_vfprintf_r+0x1944>
80007c56:	d7 03       	nop
80007c58:	fa ca f9 78 	sub	r10,sp,-1672
80007c5c:	02 9b       	mov	r11,r1
80007c5e:	08 9c       	mov	r12,r4
80007c60:	fe b0 f3 56 	rcall	8000630c <__sprint_r>
80007c64:	e0 81 02 e1 	brne	80008226 <_vfprintf_r+0x1efe>
80007c68:	fa c3 f9 e0 	sub	r3,sp,-1568
80007c6c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007c70:	40 6c       	lddsp	r12,sp[0x18]
80007c72:	18 38       	cp.w	r8,r12
80007c74:	c0 55       	brlt	80007c7e <_vfprintf_r+0x1956>
80007c76:	ed b5 00 00 	bld	r5,0x0
80007c7a:	e0 81 02 6b 	brne	80008150 <_vfprintf_r+0x1e28>
80007c7e:	fa f8 06 90 	ld.w	r8,sp[1680]
80007c82:	2f f8       	sub	r8,-1
80007c84:	40 cb       	lddsp	r11,sp[0x30]
80007c86:	fb 48 06 90 	st.w	sp[1680],r8
80007c8a:	30 19       	mov	r9,1
80007c8c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007c90:	87 0b       	st.w	r3[0x0],r11
80007c92:	2f f8       	sub	r8,-1
80007c94:	87 19       	st.w	r3[0x4],r9
80007c96:	fb 48 06 8c 	st.w	sp[1676],r8
80007c9a:	58 78       	cp.w	r8,7
80007c9c:	e0 89 00 04 	brgt	80007ca4 <_vfprintf_r+0x197c>
80007ca0:	2f 83       	sub	r3,-8
80007ca2:	c0 b8       	rjmp	80007cb8 <_vfprintf_r+0x1990>
80007ca4:	fa ca f9 78 	sub	r10,sp,-1672
80007ca8:	02 9b       	mov	r11,r1
80007caa:	08 9c       	mov	r12,r4
80007cac:	fe b0 f3 30 	rcall	8000630c <__sprint_r>
80007cb0:	e0 81 02 bb 	brne	80008226 <_vfprintf_r+0x1efe>
80007cb4:	fa c3 f9 e0 	sub	r3,sp,-1568
80007cb8:	40 66       	lddsp	r6,sp[0x18]
80007cba:	20 16       	sub	r6,1
80007cbc:	58 06       	cp.w	r6,0
80007cbe:	e0 89 00 1d 	brgt	80007cf8 <_vfprintf_r+0x19d0>
80007cc2:	e0 8f 02 47 	bral	80008150 <_vfprintf_r+0x1e28>
80007cc6:	2f 09       	sub	r9,-16
80007cc8:	2f f8       	sub	r8,-1
80007cca:	fb 49 06 90 	st.w	sp[1680],r9
80007cce:	87 02       	st.w	r3[0x0],r2
80007cd0:	87 10       	st.w	r3[0x4],r0
80007cd2:	fb 48 06 8c 	st.w	sp[1676],r8
80007cd6:	58 78       	cp.w	r8,7
80007cd8:	e0 89 00 04 	brgt	80007ce0 <_vfprintf_r+0x19b8>
80007cdc:	2f 83       	sub	r3,-8
80007cde:	c0 b8       	rjmp	80007cf4 <_vfprintf_r+0x19cc>
80007ce0:	fa ca f9 78 	sub	r10,sp,-1672
80007ce4:	02 9b       	mov	r11,r1
80007ce6:	08 9c       	mov	r12,r4
80007ce8:	fe b0 f3 12 	rcall	8000630c <__sprint_r>
80007cec:	e0 81 02 9d 	brne	80008226 <_vfprintf_r+0x1efe>
80007cf0:	fa c3 f9 e0 	sub	r3,sp,-1568
80007cf4:	21 06       	sub	r6,16
80007cf6:	c0 48       	rjmp	80007cfe <_vfprintf_r+0x19d6>
80007cf8:	fe c2 bc 08 	sub	r2,pc,-17400
80007cfc:	31 00       	mov	r0,16
80007cfe:	fa f9 06 90 	ld.w	r9,sp[1680]
80007d02:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007d06:	fe ca bc 16 	sub	r10,pc,-17386
80007d0a:	59 06       	cp.w	r6,16
80007d0c:	fe 99 ff dd 	brgt	80007cc6 <_vfprintf_r+0x199e>
80007d10:	0c 09       	add	r9,r6
80007d12:	87 0a       	st.w	r3[0x0],r10
80007d14:	fb 49 06 90 	st.w	sp[1680],r9
80007d18:	2f f8       	sub	r8,-1
80007d1a:	87 16       	st.w	r3[0x4],r6
80007d1c:	c5 39       	rjmp	80007fc2 <_vfprintf_r+0x1c9a>
80007d1e:	fa fa 06 ac 	ld.w	r10,sp[1708]
80007d22:	58 0a       	cp.w	r10,0
80007d24:	e0 89 00 92 	brgt	80007e48 <_vfprintf_r+0x1b20>
80007d28:	fa f8 06 90 	ld.w	r8,sp[1680]
80007d2c:	fe c9 bc 50 	sub	r9,pc,-17328
80007d30:	2f f8       	sub	r8,-1
80007d32:	87 09       	st.w	r3[0x0],r9
80007d34:	fb 48 06 90 	st.w	sp[1680],r8
80007d38:	30 19       	mov	r9,1
80007d3a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007d3e:	87 19       	st.w	r3[0x4],r9
80007d40:	2f f8       	sub	r8,-1
80007d42:	fb 48 06 8c 	st.w	sp[1676],r8
80007d46:	58 78       	cp.w	r8,7
80007d48:	e0 89 00 04 	brgt	80007d50 <_vfprintf_r+0x1a28>
80007d4c:	2f 83       	sub	r3,-8
80007d4e:	c0 b8       	rjmp	80007d64 <_vfprintf_r+0x1a3c>
80007d50:	fa ca f9 78 	sub	r10,sp,-1672
80007d54:	02 9b       	mov	r11,r1
80007d56:	08 9c       	mov	r12,r4
80007d58:	fe b0 f2 da 	rcall	8000630c <__sprint_r>
80007d5c:	e0 81 02 65 	brne	80008226 <_vfprintf_r+0x1efe>
80007d60:	fa c3 f9 e0 	sub	r3,sp,-1568
80007d64:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007d68:	58 08       	cp.w	r8,0
80007d6a:	c0 81       	brne	80007d7a <_vfprintf_r+0x1a52>
80007d6c:	40 6a       	lddsp	r10,sp[0x18]
80007d6e:	58 0a       	cp.w	r10,0
80007d70:	c0 51       	brne	80007d7a <_vfprintf_r+0x1a52>
80007d72:	ed b5 00 00 	bld	r5,0x0
80007d76:	e0 81 01 ed 	brne	80008150 <_vfprintf_r+0x1e28>
80007d7a:	40 c9       	lddsp	r9,sp[0x30]
80007d7c:	fa f8 06 90 	ld.w	r8,sp[1680]
80007d80:	2f f8       	sub	r8,-1
80007d82:	87 09       	st.w	r3[0x0],r9
80007d84:	fb 48 06 90 	st.w	sp[1680],r8
80007d88:	30 19       	mov	r9,1
80007d8a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007d8e:	87 19       	st.w	r3[0x4],r9
80007d90:	2f f8       	sub	r8,-1
80007d92:	fb 48 06 8c 	st.w	sp[1676],r8
80007d96:	58 78       	cp.w	r8,7
80007d98:	e0 89 00 04 	brgt	80007da0 <_vfprintf_r+0x1a78>
80007d9c:	2f 83       	sub	r3,-8
80007d9e:	c0 b8       	rjmp	80007db4 <_vfprintf_r+0x1a8c>
80007da0:	fa ca f9 78 	sub	r10,sp,-1672
80007da4:	02 9b       	mov	r11,r1
80007da6:	08 9c       	mov	r12,r4
80007da8:	fe b0 f2 b2 	rcall	8000630c <__sprint_r>
80007dac:	e0 81 02 3d 	brne	80008226 <_vfprintf_r+0x1efe>
80007db0:	fa c3 f9 e0 	sub	r3,sp,-1568
80007db4:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007db8:	5c 32       	neg	r2
80007dba:	58 02       	cp.w	r2,0
80007dbc:	e0 89 00 1d 	brgt	80007df6 <_vfprintf_r+0x1ace>
80007dc0:	c3 d8       	rjmp	80007e3a <_vfprintf_r+0x1b12>
80007dc2:	2f 09       	sub	r9,-16
80007dc4:	2f f8       	sub	r8,-1
80007dc6:	31 0e       	mov	lr,16
80007dc8:	fb 49 06 90 	st.w	sp[1680],r9
80007dcc:	87 00       	st.w	r3[0x0],r0
80007dce:	87 1e       	st.w	r3[0x4],lr
80007dd0:	fb 48 06 8c 	st.w	sp[1676],r8
80007dd4:	58 78       	cp.w	r8,7
80007dd6:	e0 89 00 04 	brgt	80007dde <_vfprintf_r+0x1ab6>
80007dda:	2f 83       	sub	r3,-8
80007ddc:	c0 b8       	rjmp	80007df2 <_vfprintf_r+0x1aca>
80007dde:	fa ca f9 78 	sub	r10,sp,-1672
80007de2:	02 9b       	mov	r11,r1
80007de4:	08 9c       	mov	r12,r4
80007de6:	fe b0 f2 93 	rcall	8000630c <__sprint_r>
80007dea:	e0 81 02 1e 	brne	80008226 <_vfprintf_r+0x1efe>
80007dee:	fa c3 f9 e0 	sub	r3,sp,-1568
80007df2:	21 02       	sub	r2,16
80007df4:	c0 38       	rjmp	80007dfa <_vfprintf_r+0x1ad2>
80007df6:	fe c0 bd 06 	sub	r0,pc,-17146
80007dfa:	fa f9 06 90 	ld.w	r9,sp[1680]
80007dfe:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007e02:	fe ca bd 12 	sub	r10,pc,-17134
80007e06:	59 02       	cp.w	r2,16
80007e08:	fe 99 ff dd 	brgt	80007dc2 <_vfprintf_r+0x1a9a>
80007e0c:	04 09       	add	r9,r2
80007e0e:	2f f8       	sub	r8,-1
80007e10:	87 0a       	st.w	r3[0x0],r10
80007e12:	fb 49 06 90 	st.w	sp[1680],r9
80007e16:	87 12       	st.w	r3[0x4],r2
80007e18:	fb 48 06 8c 	st.w	sp[1676],r8
80007e1c:	58 78       	cp.w	r8,7
80007e1e:	e0 89 00 04 	brgt	80007e26 <_vfprintf_r+0x1afe>
80007e22:	2f 83       	sub	r3,-8
80007e24:	c0 b8       	rjmp	80007e3a <_vfprintf_r+0x1b12>
80007e26:	fa ca f9 78 	sub	r10,sp,-1672
80007e2a:	02 9b       	mov	r11,r1
80007e2c:	08 9c       	mov	r12,r4
80007e2e:	fe b0 f2 6f 	rcall	8000630c <__sprint_r>
80007e32:	e0 81 01 fa 	brne	80008226 <_vfprintf_r+0x1efe>
80007e36:	fa c3 f9 e0 	sub	r3,sp,-1568
80007e3a:	40 6c       	lddsp	r12,sp[0x18]
80007e3c:	fa f8 06 90 	ld.w	r8,sp[1680]
80007e40:	87 06       	st.w	r3[0x0],r6
80007e42:	87 1c       	st.w	r3[0x4],r12
80007e44:	18 08       	add	r8,r12
80007e46:	cb 98       	rjmp	80007fb8 <_vfprintf_r+0x1c90>
80007e48:	fa f9 06 90 	ld.w	r9,sp[1680]
80007e4c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007e50:	40 6b       	lddsp	r11,sp[0x18]
80007e52:	16 3a       	cp.w	r10,r11
80007e54:	c6 f5       	brlt	80007f32 <_vfprintf_r+0x1c0a>
80007e56:	16 09       	add	r9,r11
80007e58:	2f f8       	sub	r8,-1
80007e5a:	87 06       	st.w	r3[0x0],r6
80007e5c:	fb 49 06 90 	st.w	sp[1680],r9
80007e60:	87 1b       	st.w	r3[0x4],r11
80007e62:	fb 48 06 8c 	st.w	sp[1676],r8
80007e66:	58 78       	cp.w	r8,7
80007e68:	e0 89 00 04 	brgt	80007e70 <_vfprintf_r+0x1b48>
80007e6c:	2f 83       	sub	r3,-8
80007e6e:	c0 b8       	rjmp	80007e84 <_vfprintf_r+0x1b5c>
80007e70:	fa ca f9 78 	sub	r10,sp,-1672
80007e74:	02 9b       	mov	r11,r1
80007e76:	08 9c       	mov	r12,r4
80007e78:	fe b0 f2 4a 	rcall	8000630c <__sprint_r>
80007e7c:	e0 81 01 d5 	brne	80008226 <_vfprintf_r+0x1efe>
80007e80:	fa c3 f9 e0 	sub	r3,sp,-1568
80007e84:	fa f6 06 ac 	ld.w	r6,sp[1708]
80007e88:	40 6a       	lddsp	r10,sp[0x18]
80007e8a:	14 16       	sub	r6,r10
80007e8c:	58 06       	cp.w	r6,0
80007e8e:	e0 89 00 1c 	brgt	80007ec6 <_vfprintf_r+0x1b9e>
80007e92:	c3 d8       	rjmp	80007f0c <_vfprintf_r+0x1be4>
80007e94:	2f 09       	sub	r9,-16
80007e96:	2f f8       	sub	r8,-1
80007e98:	fb 49 06 90 	st.w	sp[1680],r9
80007e9c:	87 02       	st.w	r3[0x0],r2
80007e9e:	87 10       	st.w	r3[0x4],r0
80007ea0:	fb 48 06 8c 	st.w	sp[1676],r8
80007ea4:	58 78       	cp.w	r8,7
80007ea6:	e0 89 00 04 	brgt	80007eae <_vfprintf_r+0x1b86>
80007eaa:	2f 83       	sub	r3,-8
80007eac:	c0 b8       	rjmp	80007ec2 <_vfprintf_r+0x1b9a>
80007eae:	fa ca f9 78 	sub	r10,sp,-1672
80007eb2:	02 9b       	mov	r11,r1
80007eb4:	08 9c       	mov	r12,r4
80007eb6:	fe b0 f2 2b 	rcall	8000630c <__sprint_r>
80007eba:	e0 81 01 b6 	brne	80008226 <_vfprintf_r+0x1efe>
80007ebe:	fa c3 f9 e0 	sub	r3,sp,-1568
80007ec2:	21 06       	sub	r6,16
80007ec4:	c0 48       	rjmp	80007ecc <_vfprintf_r+0x1ba4>
80007ec6:	fe c2 bd d6 	sub	r2,pc,-16938
80007eca:	31 00       	mov	r0,16
80007ecc:	fa f9 06 90 	ld.w	r9,sp[1680]
80007ed0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007ed4:	fe ca bd e4 	sub	r10,pc,-16924
80007ed8:	59 06       	cp.w	r6,16
80007eda:	fe 99 ff dd 	brgt	80007e94 <_vfprintf_r+0x1b6c>
80007ede:	0c 09       	add	r9,r6
80007ee0:	2f f8       	sub	r8,-1
80007ee2:	87 0a       	st.w	r3[0x0],r10
80007ee4:	fb 49 06 90 	st.w	sp[1680],r9
80007ee8:	87 16       	st.w	r3[0x4],r6
80007eea:	fb 48 06 8c 	st.w	sp[1676],r8
80007eee:	58 78       	cp.w	r8,7
80007ef0:	e0 89 00 04 	brgt	80007ef8 <_vfprintf_r+0x1bd0>
80007ef4:	2f 83       	sub	r3,-8
80007ef6:	c0 b8       	rjmp	80007f0c <_vfprintf_r+0x1be4>
80007ef8:	fa ca f9 78 	sub	r10,sp,-1672
80007efc:	02 9b       	mov	r11,r1
80007efe:	08 9c       	mov	r12,r4
80007f00:	fe b0 f2 06 	rcall	8000630c <__sprint_r>
80007f04:	e0 81 01 91 	brne	80008226 <_vfprintf_r+0x1efe>
80007f08:	fa c3 f9 e0 	sub	r3,sp,-1568
80007f0c:	ed b5 00 00 	bld	r5,0x0
80007f10:	e0 81 01 20 	brne	80008150 <_vfprintf_r+0x1e28>
80007f14:	40 c9       	lddsp	r9,sp[0x30]
80007f16:	fa f8 06 90 	ld.w	r8,sp[1680]
80007f1a:	2f f8       	sub	r8,-1
80007f1c:	87 09       	st.w	r3[0x0],r9
80007f1e:	fb 48 06 90 	st.w	sp[1680],r8
80007f22:	30 19       	mov	r9,1
80007f24:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007f28:	87 19       	st.w	r3[0x4],r9
80007f2a:	2f f8       	sub	r8,-1
80007f2c:	fb 48 06 8c 	st.w	sp[1676],r8
80007f30:	c0 29       	rjmp	80008134 <_vfprintf_r+0x1e0c>
80007f32:	14 09       	add	r9,r10
80007f34:	2f f8       	sub	r8,-1
80007f36:	fb 49 06 90 	st.w	sp[1680],r9
80007f3a:	87 06       	st.w	r3[0x0],r6
80007f3c:	87 1a       	st.w	r3[0x4],r10
80007f3e:	fb 48 06 8c 	st.w	sp[1676],r8
80007f42:	58 78       	cp.w	r8,7
80007f44:	e0 89 00 04 	brgt	80007f4c <_vfprintf_r+0x1c24>
80007f48:	2f 83       	sub	r3,-8
80007f4a:	c0 b8       	rjmp	80007f60 <_vfprintf_r+0x1c38>
80007f4c:	fa ca f9 78 	sub	r10,sp,-1672
80007f50:	02 9b       	mov	r11,r1
80007f52:	08 9c       	mov	r12,r4
80007f54:	fe b0 f1 dc 	rcall	8000630c <__sprint_r>
80007f58:	e0 81 01 67 	brne	80008226 <_vfprintf_r+0x1efe>
80007f5c:	fa c3 f9 e0 	sub	r3,sp,-1568
80007f60:	40 c8       	lddsp	r8,sp[0x30]
80007f62:	87 08       	st.w	r3[0x0],r8
80007f64:	fa f8 06 90 	ld.w	r8,sp[1680]
80007f68:	2f f8       	sub	r8,-1
80007f6a:	30 19       	mov	r9,1
80007f6c:	fb 48 06 90 	st.w	sp[1680],r8
80007f70:	87 19       	st.w	r3[0x4],r9
80007f72:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007f76:	2f f8       	sub	r8,-1
80007f78:	fb 48 06 8c 	st.w	sp[1676],r8
80007f7c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007f80:	58 78       	cp.w	r8,7
80007f82:	e0 89 00 04 	brgt	80007f8a <_vfprintf_r+0x1c62>
80007f86:	2f 83       	sub	r3,-8
80007f88:	c0 b8       	rjmp	80007f9e <_vfprintf_r+0x1c76>
80007f8a:	fa ca f9 78 	sub	r10,sp,-1672
80007f8e:	02 9b       	mov	r11,r1
80007f90:	08 9c       	mov	r12,r4
80007f92:	fe b0 f1 bd 	rcall	8000630c <__sprint_r>
80007f96:	e0 81 01 48 	brne	80008226 <_vfprintf_r+0x1efe>
80007f9a:	fa c3 f9 e0 	sub	r3,sp,-1568
80007f9e:	04 06       	add	r6,r2
80007fa0:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007fa4:	87 06       	st.w	r3[0x0],r6
80007fa6:	fa f9 06 90 	ld.w	r9,sp[1680]
80007faa:	40 66       	lddsp	r6,sp[0x18]
80007fac:	40 6e       	lddsp	lr,sp[0x18]
80007fae:	10 16       	sub	r6,r8
80007fb0:	f2 08 01 08 	sub	r8,r9,r8
80007fb4:	87 16       	st.w	r3[0x4],r6
80007fb6:	1c 08       	add	r8,lr
80007fb8:	fb 48 06 90 	st.w	sp[1680],r8
80007fbc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007fc0:	2f f8       	sub	r8,-1
80007fc2:	fb 48 06 8c 	st.w	sp[1676],r8
80007fc6:	cb 78       	rjmp	80008134 <_vfprintf_r+0x1e0c>
80007fc8:	40 6c       	lddsp	r12,sp[0x18]
80007fca:	58 1c       	cp.w	r12,1
80007fcc:	e0 89 00 06 	brgt	80007fd8 <_vfprintf_r+0x1cb0>
80007fd0:	ed b5 00 00 	bld	r5,0x0
80007fd4:	e0 81 00 85 	brne	800080de <_vfprintf_r+0x1db6>
80007fd8:	fa f8 06 90 	ld.w	r8,sp[1680]
80007fdc:	2f f8       	sub	r8,-1
80007fde:	30 19       	mov	r9,1
80007fe0:	fb 48 06 90 	st.w	sp[1680],r8
80007fe4:	87 06       	st.w	r3[0x0],r6
80007fe6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007fea:	87 19       	st.w	r3[0x4],r9
80007fec:	2f f8       	sub	r8,-1
80007fee:	fb 48 06 8c 	st.w	sp[1676],r8
80007ff2:	58 78       	cp.w	r8,7
80007ff4:	e0 89 00 04 	brgt	80007ffc <_vfprintf_r+0x1cd4>
80007ff8:	2f 83       	sub	r3,-8
80007ffa:	c0 b8       	rjmp	80008010 <_vfprintf_r+0x1ce8>
80007ffc:	fa ca f9 78 	sub	r10,sp,-1672
80008000:	02 9b       	mov	r11,r1
80008002:	08 9c       	mov	r12,r4
80008004:	fe b0 f1 84 	rcall	8000630c <__sprint_r>
80008008:	e0 81 01 0f 	brne	80008226 <_vfprintf_r+0x1efe>
8000800c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008010:	fa f8 06 90 	ld.w	r8,sp[1680]
80008014:	2f f8       	sub	r8,-1
80008016:	40 cb       	lddsp	r11,sp[0x30]
80008018:	fb 48 06 90 	st.w	sp[1680],r8
8000801c:	30 19       	mov	r9,1
8000801e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008022:	87 0b       	st.w	r3[0x0],r11
80008024:	2f f8       	sub	r8,-1
80008026:	87 19       	st.w	r3[0x4],r9
80008028:	fb 48 06 8c 	st.w	sp[1676],r8
8000802c:	58 78       	cp.w	r8,7
8000802e:	e0 89 00 05 	brgt	80008038 <_vfprintf_r+0x1d10>
80008032:	2f 83       	sub	r3,-8
80008034:	c0 c8       	rjmp	8000804c <_vfprintf_r+0x1d24>
80008036:	d7 03       	nop
80008038:	fa ca f9 78 	sub	r10,sp,-1672
8000803c:	02 9b       	mov	r11,r1
8000803e:	08 9c       	mov	r12,r4
80008040:	fe b0 f1 66 	rcall	8000630c <__sprint_r>
80008044:	e0 81 00 f1 	brne	80008226 <_vfprintf_r+0x1efe>
80008048:	fa c3 f9 e0 	sub	r3,sp,-1568
8000804c:	30 08       	mov	r8,0
8000804e:	30 09       	mov	r9,0
80008050:	40 5b       	lddsp	r11,sp[0x14]
80008052:	40 7a       	lddsp	r10,sp[0x1c]
80008054:	e0 a0 13 25 	rcall	8000a69e <__avr32_f64_cmp_eq>
80008058:	40 68       	lddsp	r8,sp[0x18]
8000805a:	20 18       	sub	r8,1
8000805c:	58 0c       	cp.w	r12,0
8000805e:	c0 d1       	brne	80008078 <_vfprintf_r+0x1d50>
80008060:	2f f6       	sub	r6,-1
80008062:	87 18       	st.w	r3[0x4],r8
80008064:	87 06       	st.w	r3[0x0],r6
80008066:	fa f6 06 90 	ld.w	r6,sp[1680]
8000806a:	10 06       	add	r6,r8
8000806c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008070:	fb 46 06 90 	st.w	sp[1680],r6
80008074:	2f f8       	sub	r8,-1
80008076:	c3 18       	rjmp	800080d8 <_vfprintf_r+0x1db0>
80008078:	10 96       	mov	r6,r8
8000807a:	58 08       	cp.w	r8,0
8000807c:	e0 89 00 1c 	brgt	800080b4 <_vfprintf_r+0x1d8c>
80008080:	c4 b8       	rjmp	80008116 <_vfprintf_r+0x1dee>
80008082:	2f 09       	sub	r9,-16
80008084:	2f f8       	sub	r8,-1
80008086:	fb 49 06 90 	st.w	sp[1680],r9
8000808a:	87 02       	st.w	r3[0x0],r2
8000808c:	87 10       	st.w	r3[0x4],r0
8000808e:	fb 48 06 8c 	st.w	sp[1676],r8
80008092:	58 78       	cp.w	r8,7
80008094:	e0 89 00 04 	brgt	8000809c <_vfprintf_r+0x1d74>
80008098:	2f 83       	sub	r3,-8
8000809a:	c0 b8       	rjmp	800080b0 <_vfprintf_r+0x1d88>
8000809c:	fa ca f9 78 	sub	r10,sp,-1672
800080a0:	02 9b       	mov	r11,r1
800080a2:	08 9c       	mov	r12,r4
800080a4:	fe b0 f1 34 	rcall	8000630c <__sprint_r>
800080a8:	e0 81 00 bf 	brne	80008226 <_vfprintf_r+0x1efe>
800080ac:	fa c3 f9 e0 	sub	r3,sp,-1568
800080b0:	21 06       	sub	r6,16
800080b2:	c0 48       	rjmp	800080ba <_vfprintf_r+0x1d92>
800080b4:	fe c2 bf c4 	sub	r2,pc,-16444
800080b8:	31 00       	mov	r0,16
800080ba:	fa f9 06 90 	ld.w	r9,sp[1680]
800080be:	fa f8 06 8c 	ld.w	r8,sp[1676]
800080c2:	fe ca bf d2 	sub	r10,pc,-16430
800080c6:	59 06       	cp.w	r6,16
800080c8:	fe 99 ff dd 	brgt	80008082 <_vfprintf_r+0x1d5a>
800080cc:	0c 09       	add	r9,r6
800080ce:	87 0a       	st.w	r3[0x0],r10
800080d0:	fb 49 06 90 	st.w	sp[1680],r9
800080d4:	2f f8       	sub	r8,-1
800080d6:	87 16       	st.w	r3[0x4],r6
800080d8:	fb 48 06 8c 	st.w	sp[1676],r8
800080dc:	c0 e8       	rjmp	800080f8 <_vfprintf_r+0x1dd0>
800080de:	fa f8 06 90 	ld.w	r8,sp[1680]
800080e2:	2f f8       	sub	r8,-1
800080e4:	30 19       	mov	r9,1
800080e6:	fb 48 06 90 	st.w	sp[1680],r8
800080ea:	87 06       	st.w	r3[0x0],r6
800080ec:	fa f8 06 8c 	ld.w	r8,sp[1676]
800080f0:	87 19       	st.w	r3[0x4],r9
800080f2:	2f f8       	sub	r8,-1
800080f4:	fb 48 06 8c 	st.w	sp[1676],r8
800080f8:	58 78       	cp.w	r8,7
800080fa:	e0 89 00 04 	brgt	80008102 <_vfprintf_r+0x1dda>
800080fe:	2f 83       	sub	r3,-8
80008100:	c0 b8       	rjmp	80008116 <_vfprintf_r+0x1dee>
80008102:	fa ca f9 78 	sub	r10,sp,-1672
80008106:	02 9b       	mov	r11,r1
80008108:	08 9c       	mov	r12,r4
8000810a:	fe b0 f1 01 	rcall	8000630c <__sprint_r>
8000810e:	e0 81 00 8c 	brne	80008226 <_vfprintf_r+0x1efe>
80008112:	fa c3 f9 e0 	sub	r3,sp,-1568
80008116:	40 ea       	lddsp	r10,sp[0x38]
80008118:	fa f8 06 90 	ld.w	r8,sp[1680]
8000811c:	14 08       	add	r8,r10
8000811e:	fa c9 f9 64 	sub	r9,sp,-1692
80008122:	fb 48 06 90 	st.w	sp[1680],r8
80008126:	87 1a       	st.w	r3[0x4],r10
80008128:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000812c:	87 09       	st.w	r3[0x0],r9
8000812e:	2f f8       	sub	r8,-1
80008130:	fb 48 06 8c 	st.w	sp[1676],r8
80008134:	58 78       	cp.w	r8,7
80008136:	e0 89 00 04 	brgt	8000813e <_vfprintf_r+0x1e16>
8000813a:	2f 83       	sub	r3,-8
8000813c:	c0 a8       	rjmp	80008150 <_vfprintf_r+0x1e28>
8000813e:	fa ca f9 78 	sub	r10,sp,-1672
80008142:	02 9b       	mov	r11,r1
80008144:	08 9c       	mov	r12,r4
80008146:	fe b0 f0 e3 	rcall	8000630c <__sprint_r>
8000814a:	c6 e1       	brne	80008226 <_vfprintf_r+0x1efe>
8000814c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008150:	e2 15 00 04 	andl	r5,0x4,COH
80008154:	c3 f0       	breq	800081d2 <_vfprintf_r+0x1eaa>
80008156:	40 86       	lddsp	r6,sp[0x20]
80008158:	40 39       	lddsp	r9,sp[0xc]
8000815a:	12 16       	sub	r6,r9
8000815c:	58 06       	cp.w	r6,0
8000815e:	e0 89 00 1a 	brgt	80008192 <_vfprintf_r+0x1e6a>
80008162:	c3 88       	rjmp	800081d2 <_vfprintf_r+0x1eaa>
80008164:	2f 09       	sub	r9,-16
80008166:	2f f8       	sub	r8,-1
80008168:	fb 49 06 90 	st.w	sp[1680],r9
8000816c:	87 05       	st.w	r3[0x0],r5
8000816e:	87 12       	st.w	r3[0x4],r2
80008170:	fb 48 06 8c 	st.w	sp[1676],r8
80008174:	58 78       	cp.w	r8,7
80008176:	e0 89 00 04 	brgt	8000817e <_vfprintf_r+0x1e56>
8000817a:	2f 83       	sub	r3,-8
8000817c:	c0 98       	rjmp	8000818e <_vfprintf_r+0x1e66>
8000817e:	00 9a       	mov	r10,r0
80008180:	02 9b       	mov	r11,r1
80008182:	08 9c       	mov	r12,r4
80008184:	fe b0 f0 c4 	rcall	8000630c <__sprint_r>
80008188:	c4 f1       	brne	80008226 <_vfprintf_r+0x1efe>
8000818a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000818e:	21 06       	sub	r6,16
80008190:	c0 68       	rjmp	8000819c <_vfprintf_r+0x1e74>
80008192:	fe c5 c0 b2 	sub	r5,pc,-16206
80008196:	31 02       	mov	r2,16
80008198:	fa c0 f9 78 	sub	r0,sp,-1672
8000819c:	fa f9 06 90 	ld.w	r9,sp[1680]
800081a0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800081a4:	fe ca c0 c4 	sub	r10,pc,-16188
800081a8:	59 06       	cp.w	r6,16
800081aa:	fe 99 ff dd 	brgt	80008164 <_vfprintf_r+0x1e3c>
800081ae:	0c 09       	add	r9,r6
800081b0:	2f f8       	sub	r8,-1
800081b2:	87 0a       	st.w	r3[0x0],r10
800081b4:	87 16       	st.w	r3[0x4],r6
800081b6:	fb 49 06 90 	st.w	sp[1680],r9
800081ba:	fb 48 06 8c 	st.w	sp[1676],r8
800081be:	58 78       	cp.w	r8,7
800081c0:	e0 8a 00 09 	brle	800081d2 <_vfprintf_r+0x1eaa>
800081c4:	fa ca f9 78 	sub	r10,sp,-1672
800081c8:	02 9b       	mov	r11,r1
800081ca:	08 9c       	mov	r12,r4
800081cc:	fe b0 f0 a0 	rcall	8000630c <__sprint_r>
800081d0:	c2 b1       	brne	80008226 <_vfprintf_r+0x1efe>
800081d2:	40 bc       	lddsp	r12,sp[0x2c]
800081d4:	40 36       	lddsp	r6,sp[0xc]
800081d6:	40 8e       	lddsp	lr,sp[0x20]
800081d8:	ec 0e 0c 48 	max	r8,r6,lr
800081dc:	10 0c       	add	r12,r8
800081de:	50 bc       	stdsp	sp[0x2c],r12
800081e0:	fa f8 06 90 	ld.w	r8,sp[1680]
800081e4:	58 08       	cp.w	r8,0
800081e6:	c0 80       	breq	800081f6 <_vfprintf_r+0x1ece>
800081e8:	fa ca f9 78 	sub	r10,sp,-1672
800081ec:	02 9b       	mov	r11,r1
800081ee:	08 9c       	mov	r12,r4
800081f0:	fe b0 f0 8e 	rcall	8000630c <__sprint_r>
800081f4:	c1 91       	brne	80008226 <_vfprintf_r+0x1efe>
800081f6:	30 0b       	mov	r11,0
800081f8:	fa c3 f9 e0 	sub	r3,sp,-1568
800081fc:	fb 4b 06 8c 	st.w	sp[1676],r11
80008200:	fe 9f f1 22 	bral	80006444 <_vfprintf_r+0x11c>
80008204:	08 95       	mov	r5,r4
80008206:	fa f8 06 90 	ld.w	r8,sp[1680]
8000820a:	58 08       	cp.w	r8,0
8000820c:	c0 80       	breq	8000821c <_vfprintf_r+0x1ef4>
8000820e:	08 9c       	mov	r12,r4
80008210:	fa ca f9 78 	sub	r10,sp,-1672
80008214:	02 9b       	mov	r11,r1
80008216:	fe b0 f0 7b 	rcall	8000630c <__sprint_r>
8000821a:	c0 61       	brne	80008226 <_vfprintf_r+0x1efe>
8000821c:	30 08       	mov	r8,0
8000821e:	fb 48 06 8c 	st.w	sp[1676],r8
80008222:	c0 28       	rjmp	80008226 <_vfprintf_r+0x1efe>
80008224:	40 41       	lddsp	r1,sp[0x10]
80008226:	82 68       	ld.sh	r8,r1[0xc]
80008228:	ed b8 00 06 	bld	r8,0x6
8000822c:	c0 31       	brne	80008232 <_vfprintf_r+0x1f0a>
8000822e:	3f fa       	mov	r10,-1
80008230:	50 ba       	stdsp	sp[0x2c],r10
80008232:	40 bc       	lddsp	r12,sp[0x2c]
80008234:	fe 3d f9 44 	sub	sp,-1724
80008238:	d8 32       	popm	r0-r7,pc
8000823a:	d7 03       	nop

8000823c <__swsetup_r>:
8000823c:	d4 21       	pushm	r4-r7,lr
8000823e:	e0 68 0a 40 	mov	r8,2624
80008242:	18 96       	mov	r6,r12
80008244:	16 97       	mov	r7,r11
80008246:	70 0c       	ld.w	r12,r8[0x0]
80008248:	58 0c       	cp.w	r12,0
8000824a:	c0 60       	breq	80008256 <__swsetup_r+0x1a>
8000824c:	78 68       	ld.w	r8,r12[0x18]
8000824e:	58 08       	cp.w	r8,0
80008250:	c0 31       	brne	80008256 <__swsetup_r+0x1a>
80008252:	e0 a0 07 bf 	rcall	800091d0 <__sinit>
80008256:	fe c8 c0 46 	sub	r8,pc,-16314
8000825a:	10 37       	cp.w	r7,r8
8000825c:	c0 61       	brne	80008268 <__swsetup_r+0x2c>
8000825e:	e0 68 0a 40 	mov	r8,2624
80008262:	70 08       	ld.w	r8,r8[0x0]
80008264:	70 07       	ld.w	r7,r8[0x0]
80008266:	c1 28       	rjmp	8000828a <__swsetup_r+0x4e>
80008268:	fe c8 c0 38 	sub	r8,pc,-16328
8000826c:	10 37       	cp.w	r7,r8
8000826e:	c0 61       	brne	8000827a <__swsetup_r+0x3e>
80008270:	e0 68 0a 40 	mov	r8,2624
80008274:	70 08       	ld.w	r8,r8[0x0]
80008276:	70 17       	ld.w	r7,r8[0x4]
80008278:	c0 98       	rjmp	8000828a <__swsetup_r+0x4e>
8000827a:	fe c8 c0 2a 	sub	r8,pc,-16342
8000827e:	10 37       	cp.w	r7,r8
80008280:	c0 51       	brne	8000828a <__swsetup_r+0x4e>
80008282:	e0 68 0a 40 	mov	r8,2624
80008286:	70 08       	ld.w	r8,r8[0x0]
80008288:	70 27       	ld.w	r7,r8[0x8]
8000828a:	8e 68       	ld.sh	r8,r7[0xc]
8000828c:	ed b8 00 03 	bld	r8,0x3
80008290:	c1 e0       	breq	800082cc <__swsetup_r+0x90>
80008292:	ed b8 00 04 	bld	r8,0x4
80008296:	c3 e1       	brne	80008312 <__swsetup_r+0xd6>
80008298:	ed b8 00 02 	bld	r8,0x2
8000829c:	c1 51       	brne	800082c6 <__swsetup_r+0x8a>
8000829e:	6e db       	ld.w	r11,r7[0x34]
800082a0:	58 0b       	cp.w	r11,0
800082a2:	c0 a0       	breq	800082b6 <__swsetup_r+0x7a>
800082a4:	ee c8 ff bc 	sub	r8,r7,-68
800082a8:	10 3b       	cp.w	r11,r8
800082aa:	c0 40       	breq	800082b2 <__swsetup_r+0x76>
800082ac:	0c 9c       	mov	r12,r6
800082ae:	e0 a0 08 2b 	rcall	80009304 <_free_r>
800082b2:	30 08       	mov	r8,0
800082b4:	8f d8       	st.w	r7[0x34],r8
800082b6:	8e 68       	ld.sh	r8,r7[0xc]
800082b8:	e0 18 ff db 	andl	r8,0xffdb
800082bc:	ae 68       	st.h	r7[0xc],r8
800082be:	30 08       	mov	r8,0
800082c0:	8f 18       	st.w	r7[0x4],r8
800082c2:	6e 48       	ld.w	r8,r7[0x10]
800082c4:	8f 08       	st.w	r7[0x0],r8
800082c6:	8e 68       	ld.sh	r8,r7[0xc]
800082c8:	a3 b8       	sbr	r8,0x3
800082ca:	ae 68       	st.h	r7[0xc],r8
800082cc:	6e 48       	ld.w	r8,r7[0x10]
800082ce:	58 08       	cp.w	r8,0
800082d0:	c0 b1       	brne	800082e6 <__swsetup_r+0xaa>
800082d2:	8e 68       	ld.sh	r8,r7[0xc]
800082d4:	e2 18 02 80 	andl	r8,0x280,COH
800082d8:	e0 48 02 00 	cp.w	r8,512
800082dc:	c0 50       	breq	800082e6 <__swsetup_r+0xaa>
800082de:	0c 9c       	mov	r12,r6
800082e0:	0e 9b       	mov	r11,r7
800082e2:	e0 a0 0a 4b 	rcall	80009778 <__smakebuf_r>
800082e6:	8e 69       	ld.sh	r9,r7[0xc]
800082e8:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
800082ec:	c0 70       	breq	800082fa <__swsetup_r+0xbe>
800082ee:	30 08       	mov	r8,0
800082f0:	8f 28       	st.w	r7[0x8],r8
800082f2:	6e 58       	ld.w	r8,r7[0x14]
800082f4:	5c 38       	neg	r8
800082f6:	8f 68       	st.w	r7[0x18],r8
800082f8:	c0 68       	rjmp	80008304 <__swsetup_r+0xc8>
800082fa:	ed b9 00 01 	bld	r9,0x1
800082fe:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80008302:	8f 28       	st.w	r7[0x8],r8
80008304:	6e 48       	ld.w	r8,r7[0x10]
80008306:	58 08       	cp.w	r8,0
80008308:	c0 61       	brne	80008314 <__swsetup_r+0xd8>
8000830a:	8e 68       	ld.sh	r8,r7[0xc]
8000830c:	ed b8 00 07 	bld	r8,0x7
80008310:	c0 21       	brne	80008314 <__swsetup_r+0xd8>
80008312:	dc 2a       	popm	r4-r7,pc,r12=-1
80008314:	d8 2a       	popm	r4-r7,pc,r12=0
80008316:	d7 03       	nop

80008318 <quorem>:
80008318:	d4 31       	pushm	r0-r7,lr
8000831a:	20 2d       	sub	sp,8
8000831c:	18 97       	mov	r7,r12
8000831e:	78 48       	ld.w	r8,r12[0x10]
80008320:	76 46       	ld.w	r6,r11[0x10]
80008322:	0c 38       	cp.w	r8,r6
80008324:	c0 34       	brge	8000832a <quorem+0x12>
80008326:	30 0c       	mov	r12,0
80008328:	c8 58       	rjmp	80008432 <quorem+0x11a>
8000832a:	ec c2 ff fc 	sub	r2,r6,-4
8000832e:	f6 c3 ff ec 	sub	r3,r11,-20
80008332:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80008336:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000833a:	2f f9       	sub	r9,-1
8000833c:	20 16       	sub	r6,1
8000833e:	f8 09 0d 08 	divu	r8,r12,r9
80008342:	f6 02 00 22 	add	r2,r11,r2<<0x2
80008346:	ee c4 ff ec 	sub	r4,r7,-20
8000834a:	10 95       	mov	r5,r8
8000834c:	58 08       	cp.w	r8,0
8000834e:	c4 10       	breq	800083d0 <quorem+0xb8>
80008350:	30 09       	mov	r9,0
80008352:	06 9a       	mov	r10,r3
80008354:	08 98       	mov	r8,r4
80008356:	12 91       	mov	r1,r9
80008358:	50 0b       	stdsp	sp[0x0],r11
8000835a:	70 0e       	ld.w	lr,r8[0x0]
8000835c:	b1 8e       	lsr	lr,0x10
8000835e:	50 1e       	stdsp	sp[0x4],lr
80008360:	15 0e       	ld.w	lr,r10++
80008362:	fc 00 16 10 	lsr	r0,lr,0x10
80008366:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000836a:	ea 0e 03 41 	mac	r1,r5,lr
8000836e:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80008372:	b1 81       	lsr	r1,0x10
80008374:	40 1b       	lddsp	r11,sp[0x4]
80008376:	ea 00 02 40 	mul	r0,r5,r0
8000837a:	e2 00 00 00 	add	r0,r1,r0
8000837e:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80008382:	02 1b       	sub	r11,r1
80008384:	50 1b       	stdsp	sp[0x4],r11
80008386:	70 0b       	ld.w	r11,r8[0x0]
80008388:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000838c:	02 09       	add	r9,r1
8000838e:	f2 0e 01 0e 	sub	lr,r9,lr
80008392:	b0 1e       	st.h	r8[0x2],lr
80008394:	fc 09 14 10 	asr	r9,lr,0x10
80008398:	40 1e       	lddsp	lr,sp[0x4]
8000839a:	fc 09 00 09 	add	r9,lr,r9
8000839e:	b0 09       	st.h	r8[0x0],r9
800083a0:	e0 01 16 10 	lsr	r1,r0,0x10
800083a4:	2f c8       	sub	r8,-4
800083a6:	b1 49       	asr	r9,0x10
800083a8:	04 3a       	cp.w	r10,r2
800083aa:	fe 98 ff d8 	brls	8000835a <quorem+0x42>
800083ae:	40 0b       	lddsp	r11,sp[0x0]
800083b0:	58 0c       	cp.w	r12,0
800083b2:	c0 f1       	brne	800083d0 <quorem+0xb8>
800083b4:	ec c8 ff fb 	sub	r8,r6,-5
800083b8:	ee 08 00 28 	add	r8,r7,r8<<0x2
800083bc:	c0 28       	rjmp	800083c0 <quorem+0xa8>
800083be:	20 16       	sub	r6,1
800083c0:	20 48       	sub	r8,4
800083c2:	08 38       	cp.w	r8,r4
800083c4:	e0 88 00 05 	brls	800083ce <quorem+0xb6>
800083c8:	70 09       	ld.w	r9,r8[0x0]
800083ca:	58 09       	cp.w	r9,0
800083cc:	cf 90       	breq	800083be <quorem+0xa6>
800083ce:	8f 46       	st.w	r7[0x10],r6
800083d0:	0e 9c       	mov	r12,r7
800083d2:	e0 a0 0a d2 	rcall	80009976 <__mcmp>
800083d6:	c2 d5       	brlt	80008430 <quorem+0x118>
800083d8:	2f f5       	sub	r5,-1
800083da:	08 98       	mov	r8,r4
800083dc:	30 09       	mov	r9,0
800083de:	07 0b       	ld.w	r11,r3++
800083e0:	f6 0a 16 10 	lsr	r10,r11,0x10
800083e4:	70 0c       	ld.w	r12,r8[0x0]
800083e6:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
800083ea:	f8 0e 16 10 	lsr	lr,r12,0x10
800083ee:	14 1e       	sub	lr,r10
800083f0:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
800083f4:	16 1a       	sub	r10,r11
800083f6:	12 0a       	add	r10,r9
800083f8:	b0 1a       	st.h	r8[0x2],r10
800083fa:	b1 4a       	asr	r10,0x10
800083fc:	fc 0a 00 09 	add	r9,lr,r10
80008400:	b0 09       	st.h	r8[0x0],r9
80008402:	2f c8       	sub	r8,-4
80008404:	b1 49       	asr	r9,0x10
80008406:	04 33       	cp.w	r3,r2
80008408:	fe 98 ff eb 	brls	800083de <quorem+0xc6>
8000840c:	ec c8 ff fb 	sub	r8,r6,-5
80008410:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80008414:	58 09       	cp.w	r9,0
80008416:	c0 d1       	brne	80008430 <quorem+0x118>
80008418:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000841c:	c0 28       	rjmp	80008420 <quorem+0x108>
8000841e:	20 16       	sub	r6,1
80008420:	20 48       	sub	r8,4
80008422:	08 38       	cp.w	r8,r4
80008424:	e0 88 00 05 	brls	8000842e <quorem+0x116>
80008428:	70 09       	ld.w	r9,r8[0x0]
8000842a:	58 09       	cp.w	r9,0
8000842c:	cf 90       	breq	8000841e <quorem+0x106>
8000842e:	8f 46       	st.w	r7[0x10],r6
80008430:	0a 9c       	mov	r12,r5
80008432:	2f ed       	sub	sp,-8
80008434:	d8 32       	popm	r0-r7,pc
80008436:	d7 03       	nop

80008438 <_dtoa_r>:
80008438:	d4 31       	pushm	r0-r7,lr
8000843a:	21 ad       	sub	sp,104
8000843c:	fa c4 ff 74 	sub	r4,sp,-140
80008440:	18 97       	mov	r7,r12
80008442:	16 95       	mov	r5,r11
80008444:	68 2c       	ld.w	r12,r4[0x8]
80008446:	50 c9       	stdsp	sp[0x30],r9
80008448:	68 16       	ld.w	r6,r4[0x4]
8000844a:	68 09       	ld.w	r9,r4[0x0]
8000844c:	50 e8       	stdsp	sp[0x38],r8
8000844e:	14 94       	mov	r4,r10
80008450:	51 2c       	stdsp	sp[0x48],r12
80008452:	fa e5 00 08 	st.d	sp[8],r4
80008456:	51 59       	stdsp	sp[0x54],r9
80008458:	6e 95       	ld.w	r5,r7[0x24]
8000845a:	58 05       	cp.w	r5,0
8000845c:	c0 91       	brne	8000846e <_dtoa_r+0x36>
8000845e:	31 0c       	mov	r12,16
80008460:	fe b0 e8 f4 	rcall	80005648 <malloc>
80008464:	99 35       	st.w	r12[0xc],r5
80008466:	8f 9c       	st.w	r7[0x24],r12
80008468:	99 15       	st.w	r12[0x4],r5
8000846a:	99 25       	st.w	r12[0x8],r5
8000846c:	99 05       	st.w	r12[0x0],r5
8000846e:	6e 99       	ld.w	r9,r7[0x24]
80008470:	72 08       	ld.w	r8,r9[0x0]
80008472:	58 08       	cp.w	r8,0
80008474:	c0 f0       	breq	80008492 <_dtoa_r+0x5a>
80008476:	72 1a       	ld.w	r10,r9[0x4]
80008478:	91 1a       	st.w	r8[0x4],r10
8000847a:	30 1a       	mov	r10,1
8000847c:	72 19       	ld.w	r9,r9[0x4]
8000847e:	f4 09 09 49 	lsl	r9,r10,r9
80008482:	10 9b       	mov	r11,r8
80008484:	91 29       	st.w	r8[0x8],r9
80008486:	0e 9c       	mov	r12,r7
80008488:	e0 a0 0a 90 	rcall	800099a8 <_Bfree>
8000848c:	6e 98       	ld.w	r8,r7[0x24]
8000848e:	30 09       	mov	r9,0
80008490:	91 09       	st.w	r8[0x0],r9
80008492:	40 28       	lddsp	r8,sp[0x8]
80008494:	10 94       	mov	r4,r8
80008496:	58 08       	cp.w	r8,0
80008498:	c0 64       	brge	800084a4 <_dtoa_r+0x6c>
8000849a:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000849e:	50 28       	stdsp	sp[0x8],r8
800084a0:	30 18       	mov	r8,1
800084a2:	c0 28       	rjmp	800084a6 <_dtoa_r+0x6e>
800084a4:	30 08       	mov	r8,0
800084a6:	8d 08       	st.w	r6[0x0],r8
800084a8:	fc 1c 7f f0 	movh	r12,0x7ff0
800084ac:	40 26       	lddsp	r6,sp[0x8]
800084ae:	0c 98       	mov	r8,r6
800084b0:	e6 18 7f f0 	andh	r8,0x7ff0,COH
800084b4:	18 38       	cp.w	r8,r12
800084b6:	c2 01       	brne	800084f6 <_dtoa_r+0xbe>
800084b8:	e0 68 27 0f 	mov	r8,9999
800084bc:	41 5b       	lddsp	r11,sp[0x54]
800084be:	97 08       	st.w	r11[0x0],r8
800084c0:	40 3a       	lddsp	r10,sp[0xc]
800084c2:	58 0a       	cp.w	r10,0
800084c4:	c0 71       	brne	800084d2 <_dtoa_r+0x9a>
800084c6:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
800084ca:	c0 41       	brne	800084d2 <_dtoa_r+0x9a>
800084cc:	fe cc c2 cc 	sub	r12,pc,-15668
800084d0:	c0 38       	rjmp	800084d6 <_dtoa_r+0x9e>
800084d2:	fe cc c2 c6 	sub	r12,pc,-15674
800084d6:	41 29       	lddsp	r9,sp[0x48]
800084d8:	58 09       	cp.w	r9,0
800084da:	e0 80 05 9a 	breq	8000900e <_dtoa_r+0xbd6>
800084de:	f8 c8 ff fd 	sub	r8,r12,-3
800084e2:	f8 c9 ff f8 	sub	r9,r12,-8
800084e6:	11 8b       	ld.ub	r11,r8[0x0]
800084e8:	30 0a       	mov	r10,0
800084ea:	41 25       	lddsp	r5,sp[0x48]
800084ec:	f4 0b 18 00 	cp.b	r11,r10
800084f0:	f2 08 17 10 	movne	r8,r9
800084f4:	c1 68       	rjmp	80008520 <_dtoa_r+0xe8>
800084f6:	fa ea 00 08 	ld.d	r10,sp[8]
800084fa:	30 08       	mov	r8,0
800084fc:	fa eb 00 3c 	st.d	sp[60],r10
80008500:	30 09       	mov	r9,0
80008502:	e0 a0 10 ce 	rcall	8000a69e <__avr32_f64_cmp_eq>
80008506:	c1 00       	breq	80008526 <_dtoa_r+0xee>
80008508:	30 18       	mov	r8,1
8000850a:	41 5a       	lddsp	r10,sp[0x54]
8000850c:	95 08       	st.w	r10[0x0],r8
8000850e:	fe cc c4 32 	sub	r12,pc,-15310
80008512:	41 29       	lddsp	r9,sp[0x48]
80008514:	f8 08 00 08 	add	r8,r12,r8
80008518:	58 09       	cp.w	r9,0
8000851a:	e0 80 05 7a 	breq	8000900e <_dtoa_r+0xbd6>
8000851e:	12 95       	mov	r5,r9
80008520:	8b 08       	st.w	r5[0x0],r8
80008522:	e0 8f 05 76 	bral	8000900e <_dtoa_r+0xbd6>
80008526:	fa c8 ff 9c 	sub	r8,sp,-100
8000852a:	fa c9 ff a0 	sub	r9,sp,-96
8000852e:	fa ea 00 3c 	ld.d	r10,sp[60]
80008532:	0e 9c       	mov	r12,r7
80008534:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80008538:	e0 a0 0a 8a 	rcall	80009a4c <__d2b>
8000853c:	18 93       	mov	r3,r12
8000853e:	58 05       	cp.w	r5,0
80008540:	c0 d0       	breq	8000855a <_dtoa_r+0x122>
80008542:	fa ea 00 3c 	ld.d	r10,sp[60]
80008546:	30 04       	mov	r4,0
80008548:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000854c:	ea c5 03 ff 	sub	r5,r5,1023
80008550:	10 9b       	mov	r11,r8
80008552:	51 74       	stdsp	sp[0x5c],r4
80008554:	ea 1b 3f f0 	orh	r11,0x3ff0
80008558:	c2 58       	rjmp	800085a2 <_dtoa_r+0x16a>
8000855a:	41 88       	lddsp	r8,sp[0x60]
8000855c:	41 9c       	lddsp	r12,sp[0x64]
8000855e:	10 0c       	add	r12,r8
80008560:	f8 c5 fb ce 	sub	r5,r12,-1074
80008564:	e0 45 00 20 	cp.w	r5,32
80008568:	e0 8a 00 0e 	brle	80008584 <_dtoa_r+0x14c>
8000856c:	f8 cc fb ee 	sub	r12,r12,-1042
80008570:	40 3b       	lddsp	r11,sp[0xc]
80008572:	ea 08 11 40 	rsub	r8,r5,64
80008576:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000857a:	ec 08 09 46 	lsl	r6,r6,r8
8000857e:	0c 4c       	or	r12,r6
80008580:	c0 78       	rjmp	8000858e <_dtoa_r+0x156>
80008582:	d7 03       	nop
80008584:	ea 0c 11 20 	rsub	r12,r5,32
80008588:	40 3a       	lddsp	r10,sp[0xc]
8000858a:	f4 0c 09 4c 	lsl	r12,r10,r12
8000858e:	e0 a0 10 14 	rcall	8000a5b6 <__avr32_u32_to_f64>
80008592:	fc 18 fe 10 	movh	r8,0xfe10
80008596:	30 19       	mov	r9,1
80008598:	ea c5 04 33 	sub	r5,r5,1075
8000859c:	f0 0b 00 0b 	add	r11,r8,r11
800085a0:	51 79       	stdsp	sp[0x5c],r9
800085a2:	30 08       	mov	r8,0
800085a4:	fc 19 3f f8 	movh	r9,0x3ff8
800085a8:	e0 a0 0e 9c 	rcall	8000a2e0 <__avr32_f64_sub>
800085ac:	e0 68 43 61 	mov	r8,17249
800085b0:	ea 18 63 6f 	orh	r8,0x636f
800085b4:	e0 69 87 a7 	mov	r9,34727
800085b8:	ea 19 3f d2 	orh	r9,0x3fd2
800085bc:	e0 a0 0d a6 	rcall	8000a108 <__avr32_f64_mul>
800085c0:	e0 68 c8 b3 	mov	r8,51379
800085c4:	ea 18 8b 60 	orh	r8,0x8b60
800085c8:	e0 69 8a 28 	mov	r9,35368
800085cc:	ea 19 3f c6 	orh	r9,0x3fc6
800085d0:	e0 a0 0f 56 	rcall	8000a47c <__avr32_f64_add>
800085d4:	0a 9c       	mov	r12,r5
800085d6:	14 90       	mov	r0,r10
800085d8:	16 91       	mov	r1,r11
800085da:	e0 a0 0f f2 	rcall	8000a5be <__avr32_s32_to_f64>
800085de:	e0 68 79 fb 	mov	r8,31227
800085e2:	ea 18 50 9f 	orh	r8,0x509f
800085e6:	e0 69 44 13 	mov	r9,17427
800085ea:	ea 19 3f d3 	orh	r9,0x3fd3
800085ee:	e0 a0 0d 8d 	rcall	8000a108 <__avr32_f64_mul>
800085f2:	14 98       	mov	r8,r10
800085f4:	16 99       	mov	r9,r11
800085f6:	00 9a       	mov	r10,r0
800085f8:	02 9b       	mov	r11,r1
800085fa:	e0 a0 0f 41 	rcall	8000a47c <__avr32_f64_add>
800085fe:	14 90       	mov	r0,r10
80008600:	16 91       	mov	r1,r11
80008602:	e0 a0 0f c7 	rcall	8000a590 <__avr32_f64_to_s32>
80008606:	30 08       	mov	r8,0
80008608:	18 96       	mov	r6,r12
8000860a:	30 09       	mov	r9,0
8000860c:	00 9a       	mov	r10,r0
8000860e:	02 9b       	mov	r11,r1
80008610:	e0 a0 10 8e 	rcall	8000a72c <__avr32_f64_cmp_lt>
80008614:	c0 c0       	breq	8000862c <_dtoa_r+0x1f4>
80008616:	0c 9c       	mov	r12,r6
80008618:	e0 a0 0f d3 	rcall	8000a5be <__avr32_s32_to_f64>
8000861c:	14 98       	mov	r8,r10
8000861e:	16 99       	mov	r9,r11
80008620:	00 9a       	mov	r10,r0
80008622:	02 9b       	mov	r11,r1
80008624:	e0 a0 10 3d 	rcall	8000a69e <__avr32_f64_cmp_eq>
80008628:	f7 b6 00 01 	subeq	r6,1
8000862c:	59 66       	cp.w	r6,22
8000862e:	e0 88 00 05 	brls	80008638 <_dtoa_r+0x200>
80008632:	30 18       	mov	r8,1
80008634:	51 48       	stdsp	sp[0x50],r8
80008636:	c1 38       	rjmp	8000865c <_dtoa_r+0x224>
80008638:	fe c8 c3 78 	sub	r8,pc,-15496
8000863c:	fa ea 00 3c 	ld.d	r10,sp[60]
80008640:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
80008644:	e0 a0 10 74 	rcall	8000a72c <__avr32_f64_cmp_lt>
80008648:	f9 b4 00 00 	moveq	r4,0
8000864c:	fb f4 0a 14 	st.weq	sp[0x50],r4
80008650:	f7 b6 01 01 	subne	r6,1
80008654:	f9 bc 01 00 	movne	r12,0
80008658:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000865c:	41 90       	lddsp	r0,sp[0x64]
8000865e:	20 10       	sub	r0,1
80008660:	0a 10       	sub	r0,r5
80008662:	c0 46       	brmi	8000866a <_dtoa_r+0x232>
80008664:	50 40       	stdsp	sp[0x10],r0
80008666:	30 00       	mov	r0,0
80008668:	c0 48       	rjmp	80008670 <_dtoa_r+0x238>
8000866a:	30 0b       	mov	r11,0
8000866c:	5c 30       	neg	r0
8000866e:	50 4b       	stdsp	sp[0x10],r11
80008670:	ec 02 11 00 	rsub	r2,r6,0
80008674:	58 06       	cp.w	r6,0
80008676:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000867a:	f5 d6 e4 0a 	addge	r10,r10,r6
8000867e:	fb fa 4a 04 	st.wge	sp[0x10],r10
80008682:	fb f6 4a 11 	st.wge	sp[0x44],r6
80008686:	f9 b2 04 00 	movge	r2,0
8000868a:	e1 d6 e5 10 	sublt	r0,r0,r6
8000868e:	f9 b9 05 00 	movlt	r9,0
80008692:	fb f9 5a 11 	st.wlt	sp[0x44],r9
80008696:	40 c8       	lddsp	r8,sp[0x30]
80008698:	58 98       	cp.w	r8,9
8000869a:	e0 8b 00 20 	brhi	800086da <_dtoa_r+0x2a2>
8000869e:	58 58       	cp.w	r8,5
800086a0:	f9 b4 0a 01 	movle	r4,1
800086a4:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
800086a8:	f7 b5 09 04 	subgt	r5,4
800086ac:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
800086b0:	f9 b4 09 00 	movgt	r4,0
800086b4:	40 cc       	lddsp	r12,sp[0x30]
800086b6:	58 3c       	cp.w	r12,3
800086b8:	c2 d0       	breq	80008712 <_dtoa_r+0x2da>
800086ba:	e0 89 00 05 	brgt	800086c4 <_dtoa_r+0x28c>
800086be:	58 2c       	cp.w	r12,2
800086c0:	c1 01       	brne	800086e0 <_dtoa_r+0x2a8>
800086c2:	c1 88       	rjmp	800086f2 <_dtoa_r+0x2ba>
800086c4:	40 cb       	lddsp	r11,sp[0x30]
800086c6:	58 4b       	cp.w	r11,4
800086c8:	c0 60       	breq	800086d4 <_dtoa_r+0x29c>
800086ca:	58 5b       	cp.w	r11,5
800086cc:	c0 a1       	brne	800086e0 <_dtoa_r+0x2a8>
800086ce:	30 1a       	mov	r10,1
800086d0:	50 da       	stdsp	sp[0x34],r10
800086d2:	c2 28       	rjmp	80008716 <_dtoa_r+0x2de>
800086d4:	30 19       	mov	r9,1
800086d6:	50 d9       	stdsp	sp[0x34],r9
800086d8:	c0 f8       	rjmp	800086f6 <_dtoa_r+0x2be>
800086da:	30 08       	mov	r8,0
800086dc:	30 14       	mov	r4,1
800086de:	50 c8       	stdsp	sp[0x30],r8
800086e0:	3f f5       	mov	r5,-1
800086e2:	30 1c       	mov	r12,1
800086e4:	30 0b       	mov	r11,0
800086e6:	50 95       	stdsp	sp[0x24],r5
800086e8:	50 dc       	stdsp	sp[0x34],r12
800086ea:	0a 91       	mov	r1,r5
800086ec:	31 28       	mov	r8,18
800086ee:	50 eb       	stdsp	sp[0x38],r11
800086f0:	c2 08       	rjmp	80008730 <_dtoa_r+0x2f8>
800086f2:	30 0a       	mov	r10,0
800086f4:	50 da       	stdsp	sp[0x34],r10
800086f6:	40 e9       	lddsp	r9,sp[0x38]
800086f8:	58 09       	cp.w	r9,0
800086fa:	e0 89 00 07 	brgt	80008708 <_dtoa_r+0x2d0>
800086fe:	30 18       	mov	r8,1
80008700:	50 98       	stdsp	sp[0x24],r8
80008702:	10 91       	mov	r1,r8
80008704:	50 e8       	stdsp	sp[0x38],r8
80008706:	c1 58       	rjmp	80008730 <_dtoa_r+0x2f8>
80008708:	40 e5       	lddsp	r5,sp[0x38]
8000870a:	50 95       	stdsp	sp[0x24],r5
8000870c:	0a 91       	mov	r1,r5
8000870e:	0a 98       	mov	r8,r5
80008710:	c1 08       	rjmp	80008730 <_dtoa_r+0x2f8>
80008712:	30 0c       	mov	r12,0
80008714:	50 dc       	stdsp	sp[0x34],r12
80008716:	40 eb       	lddsp	r11,sp[0x38]
80008718:	ec 0b 00 0b 	add	r11,r6,r11
8000871c:	50 9b       	stdsp	sp[0x24],r11
8000871e:	16 98       	mov	r8,r11
80008720:	2f f8       	sub	r8,-1
80008722:	58 08       	cp.w	r8,0
80008724:	e0 89 00 05 	brgt	8000872e <_dtoa_r+0x2f6>
80008728:	10 91       	mov	r1,r8
8000872a:	30 18       	mov	r8,1
8000872c:	c0 28       	rjmp	80008730 <_dtoa_r+0x2f8>
8000872e:	10 91       	mov	r1,r8
80008730:	30 09       	mov	r9,0
80008732:	6e 9a       	ld.w	r10,r7[0x24]
80008734:	95 19       	st.w	r10[0x4],r9
80008736:	30 49       	mov	r9,4
80008738:	c0 68       	rjmp	80008744 <_dtoa_r+0x30c>
8000873a:	d7 03       	nop
8000873c:	6a 1a       	ld.w	r10,r5[0x4]
8000873e:	a1 79       	lsl	r9,0x1
80008740:	2f fa       	sub	r10,-1
80008742:	8b 1a       	st.w	r5[0x4],r10
80008744:	6e 95       	ld.w	r5,r7[0x24]
80008746:	f2 ca ff ec 	sub	r10,r9,-20
8000874a:	10 3a       	cp.w	r10,r8
8000874c:	fe 98 ff f8 	brls	8000873c <_dtoa_r+0x304>
80008750:	6a 1b       	ld.w	r11,r5[0x4]
80008752:	0e 9c       	mov	r12,r7
80008754:	e0 a0 09 44 	rcall	800099dc <_Balloc>
80008758:	58 e1       	cp.w	r1,14
8000875a:	5f 88       	srls	r8
8000875c:	8b 0c       	st.w	r5[0x0],r12
8000875e:	f1 e4 00 04 	and	r4,r8,r4
80008762:	6e 98       	ld.w	r8,r7[0x24]
80008764:	70 08       	ld.w	r8,r8[0x0]
80008766:	50 88       	stdsp	sp[0x20],r8
80008768:	e0 80 01 82 	breq	80008a6c <_dtoa_r+0x634>
8000876c:	58 06       	cp.w	r6,0
8000876e:	e0 8a 00 43 	brle	800087f4 <_dtoa_r+0x3bc>
80008772:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
80008776:	fe c8 c4 b6 	sub	r8,pc,-15178
8000877a:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000877e:	fa e5 00 18 	st.d	sp[24],r4
80008782:	ec 04 14 04 	asr	r4,r6,0x4
80008786:	ed b4 00 04 	bld	r4,0x4
8000878a:	c0 30       	breq	80008790 <_dtoa_r+0x358>
8000878c:	30 25       	mov	r5,2
8000878e:	c1 08       	rjmp	800087ae <_dtoa_r+0x376>
80008790:	fe c8 c4 08 	sub	r8,pc,-15352
80008794:	f0 e8 00 20 	ld.d	r8,r8[32]
80008798:	fa ea 00 3c 	ld.d	r10,sp[60]
8000879c:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
800087a0:	e0 a0 0f fa 	rcall	8000a794 <__avr32_f64_div>
800087a4:	30 35       	mov	r5,3
800087a6:	14 98       	mov	r8,r10
800087a8:	16 99       	mov	r9,r11
800087aa:	fa e9 00 08 	st.d	sp[8],r8
800087ae:	fe cc c4 26 	sub	r12,pc,-15322
800087b2:	50 a3       	stdsp	sp[0x28],r3
800087b4:	0c 93       	mov	r3,r6
800087b6:	18 96       	mov	r6,r12
800087b8:	c0 f8       	rjmp	800087d6 <_dtoa_r+0x39e>
800087ba:	fa ea 00 18 	ld.d	r10,sp[24]
800087be:	ed b4 00 00 	bld	r4,0x0
800087c2:	c0 81       	brne	800087d2 <_dtoa_r+0x39a>
800087c4:	ec e8 00 00 	ld.d	r8,r6[0]
800087c8:	2f f5       	sub	r5,-1
800087ca:	e0 a0 0c 9f 	rcall	8000a108 <__avr32_f64_mul>
800087ce:	fa eb 00 18 	st.d	sp[24],r10
800087d2:	a1 54       	asr	r4,0x1
800087d4:	2f 86       	sub	r6,-8
800087d6:	58 04       	cp.w	r4,0
800087d8:	cf 11       	brne	800087ba <_dtoa_r+0x382>
800087da:	fa e8 00 18 	ld.d	r8,sp[24]
800087de:	fa ea 00 08 	ld.d	r10,sp[8]
800087e2:	06 96       	mov	r6,r3
800087e4:	e0 a0 0f d8 	rcall	8000a794 <__avr32_f64_div>
800087e8:	40 a3       	lddsp	r3,sp[0x28]
800087ea:	14 98       	mov	r8,r10
800087ec:	16 99       	mov	r9,r11
800087ee:	fa e9 00 08 	st.d	sp[8],r8
800087f2:	c2 f8       	rjmp	80008850 <_dtoa_r+0x418>
800087f4:	ec 08 11 00 	rsub	r8,r6,0
800087f8:	c0 31       	brne	800087fe <_dtoa_r+0x3c6>
800087fa:	30 25       	mov	r5,2
800087fc:	c2 a8       	rjmp	80008850 <_dtoa_r+0x418>
800087fe:	fe cc c4 76 	sub	r12,pc,-15242
80008802:	f0 04 14 04 	asr	r4,r8,0x4
80008806:	50 1c       	stdsp	sp[0x4],r12
80008808:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000880c:	fe c9 c5 4c 	sub	r9,pc,-15028
80008810:	fa ea 00 3c 	ld.d	r10,sp[60]
80008814:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80008818:	e0 a0 0c 78 	rcall	8000a108 <__avr32_f64_mul>
8000881c:	40 1c       	lddsp	r12,sp[0x4]
8000881e:	50 63       	stdsp	sp[0x18],r3
80008820:	30 25       	mov	r5,2
80008822:	0c 93       	mov	r3,r6
80008824:	fa eb 00 08 	st.d	sp[8],r10
80008828:	18 96       	mov	r6,r12
8000882a:	c0 f8       	rjmp	80008848 <_dtoa_r+0x410>
8000882c:	fa ea 00 08 	ld.d	r10,sp[8]
80008830:	ed b4 00 00 	bld	r4,0x0
80008834:	c0 81       	brne	80008844 <_dtoa_r+0x40c>
80008836:	ec e8 00 00 	ld.d	r8,r6[0]
8000883a:	2f f5       	sub	r5,-1
8000883c:	e0 a0 0c 66 	rcall	8000a108 <__avr32_f64_mul>
80008840:	fa eb 00 08 	st.d	sp[8],r10
80008844:	a1 54       	asr	r4,0x1
80008846:	2f 86       	sub	r6,-8
80008848:	58 04       	cp.w	r4,0
8000884a:	cf 11       	brne	8000882c <_dtoa_r+0x3f4>
8000884c:	06 96       	mov	r6,r3
8000884e:	40 63       	lddsp	r3,sp[0x18]
80008850:	41 4a       	lddsp	r10,sp[0x50]
80008852:	58 0a       	cp.w	r10,0
80008854:	c2 a0       	breq	800088a8 <_dtoa_r+0x470>
80008856:	fa e8 00 08 	ld.d	r8,sp[8]
8000885a:	58 01       	cp.w	r1,0
8000885c:	5f 94       	srgt	r4
8000885e:	fa e9 00 18 	st.d	sp[24],r8
80008862:	30 08       	mov	r8,0
80008864:	fc 19 3f f0 	movh	r9,0x3ff0
80008868:	fa ea 00 18 	ld.d	r10,sp[24]
8000886c:	e0 a0 0f 60 	rcall	8000a72c <__avr32_f64_cmp_lt>
80008870:	f9 bc 00 00 	moveq	r12,0
80008874:	f9 bc 01 01 	movne	r12,1
80008878:	e9 ec 00 0c 	and	r12,r4,r12
8000887c:	c1 60       	breq	800088a8 <_dtoa_r+0x470>
8000887e:	40 98       	lddsp	r8,sp[0x24]
80008880:	58 08       	cp.w	r8,0
80008882:	e0 8a 00 f1 	brle	80008a64 <_dtoa_r+0x62c>
80008886:	30 08       	mov	r8,0
80008888:	fc 19 40 24 	movh	r9,0x4024
8000888c:	ec c4 00 01 	sub	r4,r6,1
80008890:	fa ea 00 18 	ld.d	r10,sp[24]
80008894:	2f f5       	sub	r5,-1
80008896:	50 64       	stdsp	sp[0x18],r4
80008898:	e0 a0 0c 38 	rcall	8000a108 <__avr32_f64_mul>
8000889c:	40 94       	lddsp	r4,sp[0x24]
8000889e:	14 98       	mov	r8,r10
800088a0:	16 99       	mov	r9,r11
800088a2:	fa e9 00 08 	st.d	sp[8],r8
800088a6:	c0 38       	rjmp	800088ac <_dtoa_r+0x474>
800088a8:	50 66       	stdsp	sp[0x18],r6
800088aa:	02 94       	mov	r4,r1
800088ac:	0a 9c       	mov	r12,r5
800088ae:	e0 a0 0e 88 	rcall	8000a5be <__avr32_s32_to_f64>
800088b2:	fa e8 00 08 	ld.d	r8,sp[8]
800088b6:	e0 a0 0c 29 	rcall	8000a108 <__avr32_f64_mul>
800088ba:	30 08       	mov	r8,0
800088bc:	fc 19 40 1c 	movh	r9,0x401c
800088c0:	e0 a0 0d de 	rcall	8000a47c <__avr32_f64_add>
800088c4:	14 98       	mov	r8,r10
800088c6:	16 99       	mov	r9,r11
800088c8:	fa e9 00 28 	st.d	sp[40],r8
800088cc:	fc 18 fc c0 	movh	r8,0xfcc0
800088d0:	40 a5       	lddsp	r5,sp[0x28]
800088d2:	10 05       	add	r5,r8
800088d4:	50 a5       	stdsp	sp[0x28],r5
800088d6:	58 04       	cp.w	r4,0
800088d8:	c2 11       	brne	8000891a <_dtoa_r+0x4e2>
800088da:	fa ea 00 08 	ld.d	r10,sp[8]
800088de:	30 08       	mov	r8,0
800088e0:	fc 19 40 14 	movh	r9,0x4014
800088e4:	e0 a0 0c fe 	rcall	8000a2e0 <__avr32_f64_sub>
800088e8:	40 bc       	lddsp	r12,sp[0x2c]
800088ea:	fa eb 00 08 	st.d	sp[8],r10
800088ee:	14 98       	mov	r8,r10
800088f0:	16 99       	mov	r9,r11
800088f2:	18 9a       	mov	r10,r12
800088f4:	0a 9b       	mov	r11,r5
800088f6:	e0 a0 0f 1b 	rcall	8000a72c <__avr32_f64_cmp_lt>
800088fa:	e0 81 02 54 	brne	80008da2 <_dtoa_r+0x96a>
800088fe:	0a 98       	mov	r8,r5
80008900:	40 b9       	lddsp	r9,sp[0x2c]
80008902:	ee 18 80 00 	eorh	r8,0x8000
80008906:	fa ea 00 08 	ld.d	r10,sp[8]
8000890a:	10 95       	mov	r5,r8
8000890c:	12 98       	mov	r8,r9
8000890e:	0a 99       	mov	r9,r5
80008910:	e0 a0 0f 0e 	rcall	8000a72c <__avr32_f64_cmp_lt>
80008914:	e0 81 02 3e 	brne	80008d90 <_dtoa_r+0x958>
80008918:	ca 68       	rjmp	80008a64 <_dtoa_r+0x62c>
8000891a:	fe c9 c6 5a 	sub	r9,pc,-14758
8000891e:	e8 c8 00 01 	sub	r8,r4,1
80008922:	40 d5       	lddsp	r5,sp[0x34]
80008924:	58 05       	cp.w	r5,0
80008926:	c4 f0       	breq	800089c4 <_dtoa_r+0x58c>
80008928:	30 0c       	mov	r12,0
8000892a:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000892e:	51 3c       	stdsp	sp[0x4c],r12
80008930:	30 0a       	mov	r10,0
80008932:	fc 1b 3f e0 	movh	r11,0x3fe0
80008936:	e0 a0 0f 2f 	rcall	8000a794 <__avr32_f64_div>
8000893a:	fa e8 00 28 	ld.d	r8,sp[40]
8000893e:	40 85       	lddsp	r5,sp[0x20]
80008940:	e0 a0 0c d0 	rcall	8000a2e0 <__avr32_f64_sub>
80008944:	fa eb 00 28 	st.d	sp[40],r10
80008948:	fa ea 00 08 	ld.d	r10,sp[8]
8000894c:	e0 a0 0e 22 	rcall	8000a590 <__avr32_f64_to_s32>
80008950:	51 6c       	stdsp	sp[0x58],r12
80008952:	e0 a0 0e 36 	rcall	8000a5be <__avr32_s32_to_f64>
80008956:	14 98       	mov	r8,r10
80008958:	16 99       	mov	r9,r11
8000895a:	fa ea 00 08 	ld.d	r10,sp[8]
8000895e:	e0 a0 0c c1 	rcall	8000a2e0 <__avr32_f64_sub>
80008962:	fa eb 00 08 	st.d	sp[8],r10
80008966:	41 68       	lddsp	r8,sp[0x58]
80008968:	2d 08       	sub	r8,-48
8000896a:	0a c8       	st.b	r5++,r8
8000896c:	41 39       	lddsp	r9,sp[0x4c]
8000896e:	2f f9       	sub	r9,-1
80008970:	51 39       	stdsp	sp[0x4c],r9
80008972:	fa e8 00 28 	ld.d	r8,sp[40]
80008976:	e0 a0 0e db 	rcall	8000a72c <__avr32_f64_cmp_lt>
8000897a:	e0 81 03 39 	brne	80008fec <_dtoa_r+0xbb4>
8000897e:	fa e8 00 08 	ld.d	r8,sp[8]
80008982:	30 0a       	mov	r10,0
80008984:	fc 1b 3f f0 	movh	r11,0x3ff0
80008988:	e0 a0 0c ac 	rcall	8000a2e0 <__avr32_f64_sub>
8000898c:	fa e8 00 28 	ld.d	r8,sp[40]
80008990:	e0 a0 0e ce 	rcall	8000a72c <__avr32_f64_cmp_lt>
80008994:	fa ea 00 28 	ld.d	r10,sp[40]
80008998:	30 08       	mov	r8,0
8000899a:	fc 19 40 24 	movh	r9,0x4024
8000899e:	e0 81 00 da 	brne	80008b52 <_dtoa_r+0x71a>
800089a2:	41 3c       	lddsp	r12,sp[0x4c]
800089a4:	08 3c       	cp.w	r12,r4
800089a6:	c5 f4       	brge	80008a64 <_dtoa_r+0x62c>
800089a8:	e0 a0 0b b0 	rcall	8000a108 <__avr32_f64_mul>
800089ac:	30 08       	mov	r8,0
800089ae:	fa eb 00 28 	st.d	sp[40],r10
800089b2:	fc 19 40 24 	movh	r9,0x4024
800089b6:	fa ea 00 08 	ld.d	r10,sp[8]
800089ba:	e0 a0 0b a7 	rcall	8000a108 <__avr32_f64_mul>
800089be:	fa eb 00 08 	st.d	sp[8],r10
800089c2:	cc 3b       	rjmp	80008948 <_dtoa_r+0x510>
800089c4:	40 85       	lddsp	r5,sp[0x20]
800089c6:	08 05       	add	r5,r4
800089c8:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
800089cc:	51 35       	stdsp	sp[0x4c],r5
800089ce:	fa e8 00 28 	ld.d	r8,sp[40]
800089d2:	40 85       	lddsp	r5,sp[0x20]
800089d4:	e0 a0 0b 9a 	rcall	8000a108 <__avr32_f64_mul>
800089d8:	fa eb 00 28 	st.d	sp[40],r10
800089dc:	fa ea 00 08 	ld.d	r10,sp[8]
800089e0:	e0 a0 0d d8 	rcall	8000a590 <__avr32_f64_to_s32>
800089e4:	51 6c       	stdsp	sp[0x58],r12
800089e6:	e0 a0 0d ec 	rcall	8000a5be <__avr32_s32_to_f64>
800089ea:	14 98       	mov	r8,r10
800089ec:	16 99       	mov	r9,r11
800089ee:	fa ea 00 08 	ld.d	r10,sp[8]
800089f2:	e0 a0 0c 77 	rcall	8000a2e0 <__avr32_f64_sub>
800089f6:	fa eb 00 08 	st.d	sp[8],r10
800089fa:	41 68       	lddsp	r8,sp[0x58]
800089fc:	2d 08       	sub	r8,-48
800089fe:	0a c8       	st.b	r5++,r8
80008a00:	41 3c       	lddsp	r12,sp[0x4c]
80008a02:	18 35       	cp.w	r5,r12
80008a04:	c2 81       	brne	80008a54 <_dtoa_r+0x61c>
80008a06:	30 08       	mov	r8,0
80008a08:	fc 19 3f e0 	movh	r9,0x3fe0
80008a0c:	fa ea 00 28 	ld.d	r10,sp[40]
80008a10:	e0 a0 0d 36 	rcall	8000a47c <__avr32_f64_add>
80008a14:	40 85       	lddsp	r5,sp[0x20]
80008a16:	fa e8 00 08 	ld.d	r8,sp[8]
80008a1a:	08 05       	add	r5,r4
80008a1c:	e0 a0 0e 88 	rcall	8000a72c <__avr32_f64_cmp_lt>
80008a20:	e0 81 00 99 	brne	80008b52 <_dtoa_r+0x71a>
80008a24:	fa e8 00 28 	ld.d	r8,sp[40]
80008a28:	30 0a       	mov	r10,0
80008a2a:	fc 1b 3f e0 	movh	r11,0x3fe0
80008a2e:	e0 a0 0c 59 	rcall	8000a2e0 <__avr32_f64_sub>
80008a32:	14 98       	mov	r8,r10
80008a34:	16 99       	mov	r9,r11
80008a36:	fa ea 00 08 	ld.d	r10,sp[8]
80008a3a:	e0 a0 0e 79 	rcall	8000a72c <__avr32_f64_cmp_lt>
80008a3e:	c1 30       	breq	80008a64 <_dtoa_r+0x62c>
80008a40:	33 09       	mov	r9,48
80008a42:	0a 98       	mov	r8,r5
80008a44:	11 7a       	ld.ub	r10,--r8
80008a46:	f2 0a 18 00 	cp.b	r10,r9
80008a4a:	e0 81 02 d1 	brne	80008fec <_dtoa_r+0xbb4>
80008a4e:	10 95       	mov	r5,r8
80008a50:	cf 9b       	rjmp	80008a42 <_dtoa_r+0x60a>
80008a52:	d7 03       	nop
80008a54:	30 08       	mov	r8,0
80008a56:	fc 19 40 24 	movh	r9,0x4024
80008a5a:	e0 a0 0b 57 	rcall	8000a108 <__avr32_f64_mul>
80008a5e:	fa eb 00 08 	st.d	sp[8],r10
80008a62:	cb db       	rjmp	800089dc <_dtoa_r+0x5a4>
80008a64:	fa ea 00 3c 	ld.d	r10,sp[60]
80008a68:	fa eb 00 08 	st.d	sp[8],r10
80008a6c:	58 e6       	cp.w	r6,14
80008a6e:	5f ab       	srle	r11
80008a70:	41 8a       	lddsp	r10,sp[0x60]
80008a72:	30 08       	mov	r8,0
80008a74:	f4 09 11 ff 	rsub	r9,r10,-1
80008a78:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
80008a7c:	f0 09 18 00 	cp.b	r9,r8
80008a80:	e0 80 00 82 	breq	80008b84 <_dtoa_r+0x74c>
80008a84:	40 ea       	lddsp	r10,sp[0x38]
80008a86:	58 01       	cp.w	r1,0
80008a88:	5f a9       	srle	r9
80008a8a:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
80008a8e:	fe ca c7 ce 	sub	r10,pc,-14386
80008a92:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
80008a96:	fa e5 00 10 	st.d	sp[16],r4
80008a9a:	f0 09 18 00 	cp.b	r9,r8
80008a9e:	c1 40       	breq	80008ac6 <_dtoa_r+0x68e>
80008aa0:	58 01       	cp.w	r1,0
80008aa2:	e0 81 01 77 	brne	80008d90 <_dtoa_r+0x958>
80008aa6:	30 08       	mov	r8,0
80008aa8:	fc 19 40 14 	movh	r9,0x4014
80008aac:	08 9a       	mov	r10,r4
80008aae:	0a 9b       	mov	r11,r5
80008ab0:	e0 a0 0b 2c 	rcall	8000a108 <__avr32_f64_mul>
80008ab4:	fa e8 00 08 	ld.d	r8,sp[8]
80008ab8:	e0 a0 0e 06 	rcall	8000a6c4 <__avr32_f64_cmp_ge>
80008abc:	e0 81 01 6a 	brne	80008d90 <_dtoa_r+0x958>
80008ac0:	02 92       	mov	r2,r1
80008ac2:	e0 8f 01 72 	bral	80008da6 <_dtoa_r+0x96e>
80008ac6:	40 85       	lddsp	r5,sp[0x20]
80008ac8:	30 14       	mov	r4,1
80008aca:	fa e8 00 10 	ld.d	r8,sp[16]
80008ace:	fa ea 00 08 	ld.d	r10,sp[8]
80008ad2:	e0 a0 0e 61 	rcall	8000a794 <__avr32_f64_div>
80008ad6:	e0 a0 0d 5d 	rcall	8000a590 <__avr32_f64_to_s32>
80008ada:	18 92       	mov	r2,r12
80008adc:	e0 a0 0d 71 	rcall	8000a5be <__avr32_s32_to_f64>
80008ae0:	fa e8 00 10 	ld.d	r8,sp[16]
80008ae4:	e0 a0 0b 12 	rcall	8000a108 <__avr32_f64_mul>
80008ae8:	14 98       	mov	r8,r10
80008aea:	16 99       	mov	r9,r11
80008aec:	fa ea 00 08 	ld.d	r10,sp[8]
80008af0:	e0 a0 0b f8 	rcall	8000a2e0 <__avr32_f64_sub>
80008af4:	fa eb 00 08 	st.d	sp[8],r10
80008af8:	e4 c8 ff d0 	sub	r8,r2,-48
80008afc:	0a c8       	st.b	r5++,r8
80008afe:	fc 19 40 24 	movh	r9,0x4024
80008b02:	30 08       	mov	r8,0
80008b04:	02 34       	cp.w	r4,r1
80008b06:	c3 31       	brne	80008b6c <_dtoa_r+0x734>
80008b08:	fa e8 00 08 	ld.d	r8,sp[8]
80008b0c:	e0 a0 0c b8 	rcall	8000a47c <__avr32_f64_add>
80008b10:	16 91       	mov	r1,r11
80008b12:	14 90       	mov	r0,r10
80008b14:	14 98       	mov	r8,r10
80008b16:	02 99       	mov	r9,r1
80008b18:	fa ea 00 10 	ld.d	r10,sp[16]
80008b1c:	e0 a0 0e 08 	rcall	8000a72c <__avr32_f64_cmp_lt>
80008b20:	c1 a1       	brne	80008b54 <_dtoa_r+0x71c>
80008b22:	fa e8 00 10 	ld.d	r8,sp[16]
80008b26:	00 9a       	mov	r10,r0
80008b28:	02 9b       	mov	r11,r1
80008b2a:	e0 a0 0d ba 	rcall	8000a69e <__avr32_f64_cmp_eq>
80008b2e:	e0 80 02 5e 	breq	80008fea <_dtoa_r+0xbb2>
80008b32:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
80008b36:	c0 f1       	brne	80008b54 <_dtoa_r+0x71c>
80008b38:	e0 8f 02 59 	bral	80008fea <_dtoa_r+0xbb2>
80008b3c:	40 8a       	lddsp	r10,sp[0x20]
80008b3e:	14 38       	cp.w	r8,r10
80008b40:	c0 30       	breq	80008b46 <_dtoa_r+0x70e>
80008b42:	10 95       	mov	r5,r8
80008b44:	c0 98       	rjmp	80008b56 <_dtoa_r+0x71e>
80008b46:	33 08       	mov	r8,48
80008b48:	40 89       	lddsp	r9,sp[0x20]
80008b4a:	2f f6       	sub	r6,-1
80008b4c:	b2 88       	st.b	r9[0x0],r8
80008b4e:	40 88       	lddsp	r8,sp[0x20]
80008b50:	c0 88       	rjmp	80008b60 <_dtoa_r+0x728>
80008b52:	40 66       	lddsp	r6,sp[0x18]
80008b54:	33 99       	mov	r9,57
80008b56:	0a 98       	mov	r8,r5
80008b58:	11 7a       	ld.ub	r10,--r8
80008b5a:	f2 0a 18 00 	cp.b	r10,r9
80008b5e:	ce f0       	breq	80008b3c <_dtoa_r+0x704>
80008b60:	50 66       	stdsp	sp[0x18],r6
80008b62:	11 89       	ld.ub	r9,r8[0x0]
80008b64:	2f f9       	sub	r9,-1
80008b66:	b0 89       	st.b	r8[0x0],r9
80008b68:	e0 8f 02 42 	bral	80008fec <_dtoa_r+0xbb4>
80008b6c:	e0 a0 0a ce 	rcall	8000a108 <__avr32_f64_mul>
80008b70:	2f f4       	sub	r4,-1
80008b72:	fa eb 00 08 	st.d	sp[8],r10
80008b76:	30 08       	mov	r8,0
80008b78:	30 09       	mov	r9,0
80008b7a:	e0 a0 0d 92 	rcall	8000a69e <__avr32_f64_cmp_eq>
80008b7e:	ca 60       	breq	80008aca <_dtoa_r+0x692>
80008b80:	e0 8f 02 35 	bral	80008fea <_dtoa_r+0xbb2>
80008b84:	40 d8       	lddsp	r8,sp[0x34]
80008b86:	58 08       	cp.w	r8,0
80008b88:	c0 51       	brne	80008b92 <_dtoa_r+0x75a>
80008b8a:	04 98       	mov	r8,r2
80008b8c:	00 95       	mov	r5,r0
80008b8e:	40 d4       	lddsp	r4,sp[0x34]
80008b90:	c3 78       	rjmp	80008bfe <_dtoa_r+0x7c6>
80008b92:	40 c5       	lddsp	r5,sp[0x30]
80008b94:	58 15       	cp.w	r5,1
80008b96:	e0 89 00 0f 	brgt	80008bb4 <_dtoa_r+0x77c>
80008b9a:	41 74       	lddsp	r4,sp[0x5c]
80008b9c:	58 04       	cp.w	r4,0
80008b9e:	c0 40       	breq	80008ba6 <_dtoa_r+0x76e>
80008ba0:	f4 c9 fb cd 	sub	r9,r10,-1075
80008ba4:	c0 48       	rjmp	80008bac <_dtoa_r+0x774>
80008ba6:	41 99       	lddsp	r9,sp[0x64]
80008ba8:	f2 09 11 36 	rsub	r9,r9,54
80008bac:	04 98       	mov	r8,r2
80008bae:	00 95       	mov	r5,r0
80008bb0:	c1 c8       	rjmp	80008be8 <_dtoa_r+0x7b0>
80008bb2:	d7 03       	nop
80008bb4:	e2 c8 00 01 	sub	r8,r1,1
80008bb8:	58 01       	cp.w	r1,0
80008bba:	e0 05 17 40 	movge	r5,r0
80008bbe:	e2 09 17 40 	movge	r9,r1
80008bc2:	e1 d1 e5 15 	sublt	r5,r0,r1
80008bc6:	f9 b9 05 00 	movlt	r9,0
80008bca:	10 32       	cp.w	r2,r8
80008bcc:	e5 d8 e4 18 	subge	r8,r2,r8
80008bd0:	f1 d2 e5 18 	sublt	r8,r8,r2
80008bd4:	e5 d8 e5 02 	addlt	r2,r2,r8
80008bd8:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
80008bdc:	f9 d8 e5 0c 	addlt	r12,r12,r8
80008be0:	fb fc 5a 11 	st.wlt	sp[0x44],r12
80008be4:	f9 b8 05 00 	movlt	r8,0
80008be8:	40 4b       	lddsp	r11,sp[0x10]
80008bea:	12 0b       	add	r11,r9
80008bec:	50 08       	stdsp	sp[0x0],r8
80008bee:	50 4b       	stdsp	sp[0x10],r11
80008bf0:	12 00       	add	r0,r9
80008bf2:	30 1b       	mov	r11,1
80008bf4:	0e 9c       	mov	r12,r7
80008bf6:	e0 a0 08 a7 	rcall	80009d44 <__i2b>
80008bfa:	40 08       	lddsp	r8,sp[0x0]
80008bfc:	18 94       	mov	r4,r12
80008bfe:	40 4a       	lddsp	r10,sp[0x10]
80008c00:	58 05       	cp.w	r5,0
80008c02:	5f 99       	srgt	r9
80008c04:	58 0a       	cp.w	r10,0
80008c06:	5f 9a       	srgt	r10
80008c08:	f5 e9 00 09 	and	r9,r10,r9
80008c0c:	c0 80       	breq	80008c1c <_dtoa_r+0x7e4>
80008c0e:	40 4c       	lddsp	r12,sp[0x10]
80008c10:	f8 05 0d 49 	min	r9,r12,r5
80008c14:	12 1c       	sub	r12,r9
80008c16:	12 10       	sub	r0,r9
80008c18:	50 4c       	stdsp	sp[0x10],r12
80008c1a:	12 15       	sub	r5,r9
80008c1c:	58 02       	cp.w	r2,0
80008c1e:	e0 8a 00 27 	brle	80008c6c <_dtoa_r+0x834>
80008c22:	40 db       	lddsp	r11,sp[0x34]
80008c24:	58 0b       	cp.w	r11,0
80008c26:	c1 d0       	breq	80008c60 <_dtoa_r+0x828>
80008c28:	58 08       	cp.w	r8,0
80008c2a:	e0 8a 00 17 	brle	80008c58 <_dtoa_r+0x820>
80008c2e:	10 9a       	mov	r10,r8
80008c30:	50 08       	stdsp	sp[0x0],r8
80008c32:	08 9b       	mov	r11,r4
80008c34:	0e 9c       	mov	r12,r7
80008c36:	e0 a0 08 cd 	rcall	80009dd0 <__pow5mult>
80008c3a:	06 9a       	mov	r10,r3
80008c3c:	18 9b       	mov	r11,r12
80008c3e:	18 94       	mov	r4,r12
80008c40:	0e 9c       	mov	r12,r7
80008c42:	e0 a0 08 01 	rcall	80009c44 <__multiply>
80008c46:	18 99       	mov	r9,r12
80008c48:	06 9b       	mov	r11,r3
80008c4a:	50 19       	stdsp	sp[0x4],r9
80008c4c:	0e 9c       	mov	r12,r7
80008c4e:	e0 a0 06 ad 	rcall	800099a8 <_Bfree>
80008c52:	40 19       	lddsp	r9,sp[0x4]
80008c54:	40 08       	lddsp	r8,sp[0x0]
80008c56:	12 93       	mov	r3,r9
80008c58:	e4 08 01 0a 	sub	r10,r2,r8
80008c5c:	c0 80       	breq	80008c6c <_dtoa_r+0x834>
80008c5e:	c0 28       	rjmp	80008c62 <_dtoa_r+0x82a>
80008c60:	04 9a       	mov	r10,r2
80008c62:	06 9b       	mov	r11,r3
80008c64:	0e 9c       	mov	r12,r7
80008c66:	e0 a0 08 b5 	rcall	80009dd0 <__pow5mult>
80008c6a:	18 93       	mov	r3,r12
80008c6c:	30 1b       	mov	r11,1
80008c6e:	0e 9c       	mov	r12,r7
80008c70:	e0 a0 08 6a 	rcall	80009d44 <__i2b>
80008c74:	41 1a       	lddsp	r10,sp[0x44]
80008c76:	18 92       	mov	r2,r12
80008c78:	58 0a       	cp.w	r10,0
80008c7a:	e0 8a 00 07 	brle	80008c88 <_dtoa_r+0x850>
80008c7e:	18 9b       	mov	r11,r12
80008c80:	0e 9c       	mov	r12,r7
80008c82:	e0 a0 08 a7 	rcall	80009dd0 <__pow5mult>
80008c86:	18 92       	mov	r2,r12
80008c88:	40 c9       	lddsp	r9,sp[0x30]
80008c8a:	58 19       	cp.w	r9,1
80008c8c:	e0 89 00 14 	brgt	80008cb4 <_dtoa_r+0x87c>
80008c90:	40 38       	lddsp	r8,sp[0xc]
80008c92:	58 08       	cp.w	r8,0
80008c94:	c1 01       	brne	80008cb4 <_dtoa_r+0x87c>
80008c96:	40 29       	lddsp	r9,sp[0x8]
80008c98:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
80008c9c:	c0 c1       	brne	80008cb4 <_dtoa_r+0x87c>
80008c9e:	12 98       	mov	r8,r9
80008ca0:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80008ca4:	c0 80       	breq	80008cb4 <_dtoa_r+0x87c>
80008ca6:	40 4c       	lddsp	r12,sp[0x10]
80008ca8:	30 1b       	mov	r11,1
80008caa:	2f fc       	sub	r12,-1
80008cac:	2f f0       	sub	r0,-1
80008cae:	50 4c       	stdsp	sp[0x10],r12
80008cb0:	50 6b       	stdsp	sp[0x18],r11
80008cb2:	c0 38       	rjmp	80008cb8 <_dtoa_r+0x880>
80008cb4:	30 0a       	mov	r10,0
80008cb6:	50 6a       	stdsp	sp[0x18],r10
80008cb8:	41 19       	lddsp	r9,sp[0x44]
80008cba:	58 09       	cp.w	r9,0
80008cbc:	c0 31       	brne	80008cc2 <_dtoa_r+0x88a>
80008cbe:	30 1c       	mov	r12,1
80008cc0:	c0 98       	rjmp	80008cd2 <_dtoa_r+0x89a>
80008cc2:	64 48       	ld.w	r8,r2[0x10]
80008cc4:	2f c8       	sub	r8,-4
80008cc6:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
80008cca:	e0 a0 05 df 	rcall	80009888 <__hi0bits>
80008cce:	f8 0c 11 20 	rsub	r12,r12,32
80008cd2:	40 4b       	lddsp	r11,sp[0x10]
80008cd4:	f8 0b 00 08 	add	r8,r12,r11
80008cd8:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80008cdc:	c0 c0       	breq	80008cf4 <_dtoa_r+0x8bc>
80008cde:	f0 08 11 20 	rsub	r8,r8,32
80008ce2:	58 48       	cp.w	r8,4
80008ce4:	e0 8a 00 06 	brle	80008cf0 <_dtoa_r+0x8b8>
80008ce8:	20 48       	sub	r8,4
80008cea:	10 0b       	add	r11,r8
80008cec:	50 4b       	stdsp	sp[0x10],r11
80008cee:	c0 78       	rjmp	80008cfc <_dtoa_r+0x8c4>
80008cf0:	58 48       	cp.w	r8,4
80008cf2:	c0 70       	breq	80008d00 <_dtoa_r+0x8c8>
80008cf4:	40 4a       	lddsp	r10,sp[0x10]
80008cf6:	2e 48       	sub	r8,-28
80008cf8:	10 0a       	add	r10,r8
80008cfa:	50 4a       	stdsp	sp[0x10],r10
80008cfc:	10 00       	add	r0,r8
80008cfe:	10 05       	add	r5,r8
80008d00:	58 00       	cp.w	r0,0
80008d02:	e0 8a 00 08 	brle	80008d12 <_dtoa_r+0x8da>
80008d06:	06 9b       	mov	r11,r3
80008d08:	00 9a       	mov	r10,r0
80008d0a:	0e 9c       	mov	r12,r7
80008d0c:	e0 a0 07 58 	rcall	80009bbc <__lshift>
80008d10:	18 93       	mov	r3,r12
80008d12:	40 49       	lddsp	r9,sp[0x10]
80008d14:	58 09       	cp.w	r9,0
80008d16:	e0 8a 00 08 	brle	80008d26 <_dtoa_r+0x8ee>
80008d1a:	04 9b       	mov	r11,r2
80008d1c:	12 9a       	mov	r10,r9
80008d1e:	0e 9c       	mov	r12,r7
80008d20:	e0 a0 07 4e 	rcall	80009bbc <__lshift>
80008d24:	18 92       	mov	r2,r12
80008d26:	41 48       	lddsp	r8,sp[0x50]
80008d28:	58 08       	cp.w	r8,0
80008d2a:	c1 b0       	breq	80008d60 <_dtoa_r+0x928>
80008d2c:	04 9b       	mov	r11,r2
80008d2e:	06 9c       	mov	r12,r3
80008d30:	e0 a0 06 23 	rcall	80009976 <__mcmp>
80008d34:	c1 64       	brge	80008d60 <_dtoa_r+0x928>
80008d36:	06 9b       	mov	r11,r3
80008d38:	30 09       	mov	r9,0
80008d3a:	30 aa       	mov	r10,10
80008d3c:	0e 9c       	mov	r12,r7
80008d3e:	e0 a0 08 0b 	rcall	80009d54 <__multadd>
80008d42:	20 16       	sub	r6,1
80008d44:	18 93       	mov	r3,r12
80008d46:	40 dc       	lddsp	r12,sp[0x34]
80008d48:	58 0c       	cp.w	r12,0
80008d4a:	c0 31       	brne	80008d50 <_dtoa_r+0x918>
80008d4c:	40 91       	lddsp	r1,sp[0x24]
80008d4e:	c0 98       	rjmp	80008d60 <_dtoa_r+0x928>
80008d50:	08 9b       	mov	r11,r4
80008d52:	40 91       	lddsp	r1,sp[0x24]
80008d54:	30 09       	mov	r9,0
80008d56:	30 aa       	mov	r10,10
80008d58:	0e 9c       	mov	r12,r7
80008d5a:	e0 a0 07 fd 	rcall	80009d54 <__multadd>
80008d5e:	18 94       	mov	r4,r12
80008d60:	58 01       	cp.w	r1,0
80008d62:	5f a9       	srle	r9
80008d64:	40 cb       	lddsp	r11,sp[0x30]
80008d66:	58 2b       	cp.w	r11,2
80008d68:	5f 98       	srgt	r8
80008d6a:	f3 e8 00 08 	and	r8,r9,r8
80008d6e:	c2 50       	breq	80008db8 <_dtoa_r+0x980>
80008d70:	58 01       	cp.w	r1,0
80008d72:	c1 11       	brne	80008d94 <_dtoa_r+0x95c>
80008d74:	04 9b       	mov	r11,r2
80008d76:	02 99       	mov	r9,r1
80008d78:	30 5a       	mov	r10,5
80008d7a:	0e 9c       	mov	r12,r7
80008d7c:	e0 a0 07 ec 	rcall	80009d54 <__multadd>
80008d80:	18 92       	mov	r2,r12
80008d82:	18 9b       	mov	r11,r12
80008d84:	06 9c       	mov	r12,r3
80008d86:	e0 a0 05 f8 	rcall	80009976 <__mcmp>
80008d8a:	e0 89 00 0f 	brgt	80008da8 <_dtoa_r+0x970>
80008d8e:	c0 38       	rjmp	80008d94 <_dtoa_r+0x95c>
80008d90:	30 02       	mov	r2,0
80008d92:	04 94       	mov	r4,r2
80008d94:	40 ea       	lddsp	r10,sp[0x38]
80008d96:	30 09       	mov	r9,0
80008d98:	5c da       	com	r10
80008d9a:	40 85       	lddsp	r5,sp[0x20]
80008d9c:	50 6a       	stdsp	sp[0x18],r10
80008d9e:	50 49       	stdsp	sp[0x10],r9
80008da0:	c0 f9       	rjmp	80008fbe <_dtoa_r+0xb86>
80008da2:	08 92       	mov	r2,r4
80008da4:	40 66       	lddsp	r6,sp[0x18]
80008da6:	04 94       	mov	r4,r2
80008da8:	2f f6       	sub	r6,-1
80008daa:	50 66       	stdsp	sp[0x18],r6
80008dac:	33 18       	mov	r8,49
80008dae:	40 85       	lddsp	r5,sp[0x20]
80008db0:	0a c8       	st.b	r5++,r8
80008db2:	30 08       	mov	r8,0
80008db4:	50 48       	stdsp	sp[0x10],r8
80008db6:	c0 49       	rjmp	80008fbe <_dtoa_r+0xb86>
80008db8:	40 dc       	lddsp	r12,sp[0x34]
80008dba:	58 0c       	cp.w	r12,0
80008dbc:	e0 80 00 b5 	breq	80008f26 <_dtoa_r+0xaee>
80008dc0:	58 05       	cp.w	r5,0
80008dc2:	e0 8a 00 08 	brle	80008dd2 <_dtoa_r+0x99a>
80008dc6:	08 9b       	mov	r11,r4
80008dc8:	0a 9a       	mov	r10,r5
80008dca:	0e 9c       	mov	r12,r7
80008dcc:	e0 a0 06 f8 	rcall	80009bbc <__lshift>
80008dd0:	18 94       	mov	r4,r12
80008dd2:	40 6b       	lddsp	r11,sp[0x18]
80008dd4:	58 0b       	cp.w	r11,0
80008dd6:	c0 31       	brne	80008ddc <_dtoa_r+0x9a4>
80008dd8:	08 9c       	mov	r12,r4
80008dda:	c1 38       	rjmp	80008e00 <_dtoa_r+0x9c8>
80008ddc:	68 1b       	ld.w	r11,r4[0x4]
80008dde:	0e 9c       	mov	r12,r7
80008de0:	e0 a0 05 fe 	rcall	800099dc <_Balloc>
80008de4:	68 4a       	ld.w	r10,r4[0x10]
80008de6:	18 95       	mov	r5,r12
80008de8:	e8 cb ff f4 	sub	r11,r4,-12
80008dec:	2f ea       	sub	r10,-2
80008dee:	2f 4c       	sub	r12,-12
80008df0:	a3 6a       	lsl	r10,0x2
80008df2:	fe b0 e6 4f 	rcall	80005a90 <memcpy>
80008df6:	0a 9b       	mov	r11,r5
80008df8:	30 1a       	mov	r10,1
80008dfa:	0e 9c       	mov	r12,r7
80008dfc:	e0 a0 06 e0 	rcall	80009bbc <__lshift>
80008e00:	50 44       	stdsp	sp[0x10],r4
80008e02:	40 3a       	lddsp	r10,sp[0xc]
80008e04:	30 19       	mov	r9,1
80008e06:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80008e0a:	18 94       	mov	r4,r12
80008e0c:	50 da       	stdsp	sp[0x34],r10
80008e0e:	40 85       	lddsp	r5,sp[0x20]
80008e10:	50 99       	stdsp	sp[0x24],r9
80008e12:	50 26       	stdsp	sp[0x8],r6
80008e14:	50 e1       	stdsp	sp[0x38],r1
80008e16:	04 9b       	mov	r11,r2
80008e18:	06 9c       	mov	r12,r3
80008e1a:	fe b0 fa 7f 	rcall	80008318 <quorem>
80008e1e:	40 4b       	lddsp	r11,sp[0x10]
80008e20:	f8 c0 ff d0 	sub	r0,r12,-48
80008e24:	06 9c       	mov	r12,r3
80008e26:	e0 a0 05 a8 	rcall	80009976 <__mcmp>
80008e2a:	08 9a       	mov	r10,r4
80008e2c:	50 6c       	stdsp	sp[0x18],r12
80008e2e:	04 9b       	mov	r11,r2
80008e30:	0e 9c       	mov	r12,r7
80008e32:	e0 a0 06 5d 	rcall	80009aec <__mdiff>
80008e36:	18 91       	mov	r1,r12
80008e38:	78 38       	ld.w	r8,r12[0xc]
80008e3a:	58 08       	cp.w	r8,0
80008e3c:	c0 30       	breq	80008e42 <_dtoa_r+0xa0a>
80008e3e:	30 16       	mov	r6,1
80008e40:	c0 68       	rjmp	80008e4c <_dtoa_r+0xa14>
80008e42:	18 9b       	mov	r11,r12
80008e44:	06 9c       	mov	r12,r3
80008e46:	e0 a0 05 98 	rcall	80009976 <__mcmp>
80008e4a:	18 96       	mov	r6,r12
80008e4c:	0e 9c       	mov	r12,r7
80008e4e:	02 9b       	mov	r11,r1
80008e50:	e0 a0 05 ac 	rcall	800099a8 <_Bfree>
80008e54:	40 cc       	lddsp	r12,sp[0x30]
80008e56:	ed ec 10 08 	or	r8,r6,r12
80008e5a:	c0 d1       	brne	80008e74 <_dtoa_r+0xa3c>
80008e5c:	40 db       	lddsp	r11,sp[0x34]
80008e5e:	58 0b       	cp.w	r11,0
80008e60:	c0 a1       	brne	80008e74 <_dtoa_r+0xa3c>
80008e62:	40 26       	lddsp	r6,sp[0x8]
80008e64:	e0 40 00 39 	cp.w	r0,57
80008e68:	c3 00       	breq	80008ec8 <_dtoa_r+0xa90>
80008e6a:	40 6a       	lddsp	r10,sp[0x18]
80008e6c:	58 0a       	cp.w	r10,0
80008e6e:	e0 89 00 24 	brgt	80008eb6 <_dtoa_r+0xa7e>
80008e72:	c2 f8       	rjmp	80008ed0 <_dtoa_r+0xa98>
80008e74:	40 69       	lddsp	r9,sp[0x18]
80008e76:	58 09       	cp.w	r9,0
80008e78:	c0 85       	brlt	80008e88 <_dtoa_r+0xa50>
80008e7a:	12 98       	mov	r8,r9
80008e7c:	40 cc       	lddsp	r12,sp[0x30]
80008e7e:	18 48       	or	r8,r12
80008e80:	c1 d1       	brne	80008eba <_dtoa_r+0xa82>
80008e82:	40 db       	lddsp	r11,sp[0x34]
80008e84:	58 0b       	cp.w	r11,0
80008e86:	c1 a1       	brne	80008eba <_dtoa_r+0xa82>
80008e88:	0c 99       	mov	r9,r6
80008e8a:	40 26       	lddsp	r6,sp[0x8]
80008e8c:	58 09       	cp.w	r9,0
80008e8e:	e0 8a 00 21 	brle	80008ed0 <_dtoa_r+0xa98>
80008e92:	06 9b       	mov	r11,r3
80008e94:	30 1a       	mov	r10,1
80008e96:	0e 9c       	mov	r12,r7
80008e98:	e0 a0 06 92 	rcall	80009bbc <__lshift>
80008e9c:	04 9b       	mov	r11,r2
80008e9e:	18 93       	mov	r3,r12
80008ea0:	e0 a0 05 6b 	rcall	80009976 <__mcmp>
80008ea4:	e0 89 00 06 	brgt	80008eb0 <_dtoa_r+0xa78>
80008ea8:	c1 41       	brne	80008ed0 <_dtoa_r+0xa98>
80008eaa:	ed b0 00 00 	bld	r0,0x0
80008eae:	c1 11       	brne	80008ed0 <_dtoa_r+0xa98>
80008eb0:	e0 40 00 39 	cp.w	r0,57
80008eb4:	c0 a0       	breq	80008ec8 <_dtoa_r+0xa90>
80008eb6:	2f f0       	sub	r0,-1
80008eb8:	c0 c8       	rjmp	80008ed0 <_dtoa_r+0xa98>
80008eba:	58 06       	cp.w	r6,0
80008ebc:	e0 8a 00 0c 	brle	80008ed4 <_dtoa_r+0xa9c>
80008ec0:	40 26       	lddsp	r6,sp[0x8]
80008ec2:	e0 40 00 39 	cp.w	r0,57
80008ec6:	c0 41       	brne	80008ece <_dtoa_r+0xa96>
80008ec8:	33 98       	mov	r8,57
80008eca:	0a c8       	st.b	r5++,r8
80008ecc:	c6 78       	rjmp	80008f9a <_dtoa_r+0xb62>
80008ece:	2f f0       	sub	r0,-1
80008ed0:	0a c0       	st.b	r5++,r0
80008ed2:	c7 58       	rjmp	80008fbc <_dtoa_r+0xb84>
80008ed4:	0a c0       	st.b	r5++,r0
80008ed6:	40 9a       	lddsp	r10,sp[0x24]
80008ed8:	40 e9       	lddsp	r9,sp[0x38]
80008eda:	12 3a       	cp.w	r10,r9
80008edc:	c4 30       	breq	80008f62 <_dtoa_r+0xb2a>
80008ede:	06 9b       	mov	r11,r3
80008ee0:	30 09       	mov	r9,0
80008ee2:	30 aa       	mov	r10,10
80008ee4:	0e 9c       	mov	r12,r7
80008ee6:	e0 a0 07 37 	rcall	80009d54 <__multadd>
80008eea:	40 48       	lddsp	r8,sp[0x10]
80008eec:	18 93       	mov	r3,r12
80008eee:	08 38       	cp.w	r8,r4
80008ef0:	c0 91       	brne	80008f02 <_dtoa_r+0xaca>
80008ef2:	10 9b       	mov	r11,r8
80008ef4:	30 09       	mov	r9,0
80008ef6:	30 aa       	mov	r10,10
80008ef8:	0e 9c       	mov	r12,r7
80008efa:	e0 a0 07 2d 	rcall	80009d54 <__multadd>
80008efe:	50 4c       	stdsp	sp[0x10],r12
80008f00:	c0 e8       	rjmp	80008f1c <_dtoa_r+0xae4>
80008f02:	40 4b       	lddsp	r11,sp[0x10]
80008f04:	30 09       	mov	r9,0
80008f06:	30 aa       	mov	r10,10
80008f08:	0e 9c       	mov	r12,r7
80008f0a:	e0 a0 07 25 	rcall	80009d54 <__multadd>
80008f0e:	08 9b       	mov	r11,r4
80008f10:	50 4c       	stdsp	sp[0x10],r12
80008f12:	30 09       	mov	r9,0
80008f14:	30 aa       	mov	r10,10
80008f16:	0e 9c       	mov	r12,r7
80008f18:	e0 a0 07 1e 	rcall	80009d54 <__multadd>
80008f1c:	18 94       	mov	r4,r12
80008f1e:	40 9c       	lddsp	r12,sp[0x24]
80008f20:	2f fc       	sub	r12,-1
80008f22:	50 9c       	stdsp	sp[0x24],r12
80008f24:	c7 9b       	rjmp	80008e16 <_dtoa_r+0x9de>
80008f26:	30 18       	mov	r8,1
80008f28:	06 90       	mov	r0,r3
80008f2a:	40 85       	lddsp	r5,sp[0x20]
80008f2c:	08 93       	mov	r3,r4
80008f2e:	0c 94       	mov	r4,r6
80008f30:	10 96       	mov	r6,r8
80008f32:	04 9b       	mov	r11,r2
80008f34:	00 9c       	mov	r12,r0
80008f36:	fe b0 f9 f1 	rcall	80008318 <quorem>
80008f3a:	2d 0c       	sub	r12,-48
80008f3c:	0a cc       	st.b	r5++,r12
80008f3e:	02 36       	cp.w	r6,r1
80008f40:	c0 a4       	brge	80008f54 <_dtoa_r+0xb1c>
80008f42:	00 9b       	mov	r11,r0
80008f44:	30 09       	mov	r9,0
80008f46:	30 aa       	mov	r10,10
80008f48:	0e 9c       	mov	r12,r7
80008f4a:	2f f6       	sub	r6,-1
80008f4c:	e0 a0 07 04 	rcall	80009d54 <__multadd>
80008f50:	18 90       	mov	r0,r12
80008f52:	cf 0b       	rjmp	80008f32 <_dtoa_r+0xafa>
80008f54:	08 96       	mov	r6,r4
80008f56:	30 0b       	mov	r11,0
80008f58:	06 94       	mov	r4,r3
80008f5a:	50 4b       	stdsp	sp[0x10],r11
80008f5c:	00 93       	mov	r3,r0
80008f5e:	18 90       	mov	r0,r12
80008f60:	c0 28       	rjmp	80008f64 <_dtoa_r+0xb2c>
80008f62:	40 26       	lddsp	r6,sp[0x8]
80008f64:	06 9b       	mov	r11,r3
80008f66:	30 1a       	mov	r10,1
80008f68:	0e 9c       	mov	r12,r7
80008f6a:	e0 a0 06 29 	rcall	80009bbc <__lshift>
80008f6e:	04 9b       	mov	r11,r2
80008f70:	18 93       	mov	r3,r12
80008f72:	e0 a0 05 02 	rcall	80009976 <__mcmp>
80008f76:	e0 89 00 12 	brgt	80008f9a <_dtoa_r+0xb62>
80008f7a:	c1 b1       	brne	80008fb0 <_dtoa_r+0xb78>
80008f7c:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
80008f80:	c0 d1       	brne	80008f9a <_dtoa_r+0xb62>
80008f82:	c1 78       	rjmp	80008fb0 <_dtoa_r+0xb78>
80008f84:	40 89       	lddsp	r9,sp[0x20]
80008f86:	12 38       	cp.w	r8,r9
80008f88:	c0 30       	breq	80008f8e <_dtoa_r+0xb56>
80008f8a:	10 95       	mov	r5,r8
80008f8c:	c0 88       	rjmp	80008f9c <_dtoa_r+0xb64>
80008f8e:	2f f6       	sub	r6,-1
80008f90:	50 66       	stdsp	sp[0x18],r6
80008f92:	33 18       	mov	r8,49
80008f94:	40 8c       	lddsp	r12,sp[0x20]
80008f96:	b8 88       	st.b	r12[0x0],r8
80008f98:	c1 38       	rjmp	80008fbe <_dtoa_r+0xb86>
80008f9a:	33 9a       	mov	r10,57
80008f9c:	0a 98       	mov	r8,r5
80008f9e:	11 79       	ld.ub	r9,--r8
80008fa0:	f4 09 18 00 	cp.b	r9,r10
80008fa4:	cf 00       	breq	80008f84 <_dtoa_r+0xb4c>
80008fa6:	2f f9       	sub	r9,-1
80008fa8:	b0 89       	st.b	r8[0x0],r9
80008faa:	c0 98       	rjmp	80008fbc <_dtoa_r+0xb84>
80008fac:	10 95       	mov	r5,r8
80008fae:	c0 28       	rjmp	80008fb2 <_dtoa_r+0xb7a>
80008fb0:	33 09       	mov	r9,48
80008fb2:	0a 98       	mov	r8,r5
80008fb4:	11 7a       	ld.ub	r10,--r8
80008fb6:	f2 0a 18 00 	cp.b	r10,r9
80008fba:	cf 90       	breq	80008fac <_dtoa_r+0xb74>
80008fbc:	50 66       	stdsp	sp[0x18],r6
80008fbe:	04 9b       	mov	r11,r2
80008fc0:	0e 9c       	mov	r12,r7
80008fc2:	e0 a0 04 f3 	rcall	800099a8 <_Bfree>
80008fc6:	58 04       	cp.w	r4,0
80008fc8:	c1 20       	breq	80008fec <_dtoa_r+0xbb4>
80008fca:	40 4b       	lddsp	r11,sp[0x10]
80008fcc:	08 3b       	cp.w	r11,r4
80008fce:	5f 19       	srne	r9
80008fd0:	58 0b       	cp.w	r11,0
80008fd2:	5f 18       	srne	r8
80008fd4:	f3 e8 00 08 	and	r8,r9,r8
80008fd8:	c0 40       	breq	80008fe0 <_dtoa_r+0xba8>
80008fda:	0e 9c       	mov	r12,r7
80008fdc:	e0 a0 04 e6 	rcall	800099a8 <_Bfree>
80008fe0:	08 9b       	mov	r11,r4
80008fe2:	0e 9c       	mov	r12,r7
80008fe4:	e0 a0 04 e2 	rcall	800099a8 <_Bfree>
80008fe8:	c0 28       	rjmp	80008fec <_dtoa_r+0xbb4>
80008fea:	50 66       	stdsp	sp[0x18],r6
80008fec:	0e 9c       	mov	r12,r7
80008fee:	06 9b       	mov	r11,r3
80008ff0:	e0 a0 04 dc 	rcall	800099a8 <_Bfree>
80008ff4:	30 08       	mov	r8,0
80008ff6:	aa 88       	st.b	r5[0x0],r8
80008ff8:	40 68       	lddsp	r8,sp[0x18]
80008ffa:	41 5a       	lddsp	r10,sp[0x54]
80008ffc:	2f f8       	sub	r8,-1
80008ffe:	41 29       	lddsp	r9,sp[0x48]
80009000:	95 08       	st.w	r10[0x0],r8
80009002:	40 8c       	lddsp	r12,sp[0x20]
80009004:	58 09       	cp.w	r9,0
80009006:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000900a:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000900e:	2e 6d       	sub	sp,-104
80009010:	d8 32       	popm	r0-r7,pc
80009012:	d7 03       	nop

80009014 <__errno>:
80009014:	e0 68 0a 40 	mov	r8,2624
80009018:	70 0c       	ld.w	r12,r8[0x0]
8000901a:	2f 4c       	sub	r12,-12
8000901c:	5e fc       	retal	r12
8000901e:	d7 03       	nop

80009020 <_fflush_r>:
80009020:	d4 21       	pushm	r4-r7,lr
80009022:	16 97       	mov	r7,r11
80009024:	18 96       	mov	r6,r12
80009026:	76 48       	ld.w	r8,r11[0x10]
80009028:	58 08       	cp.w	r8,0
8000902a:	c7 f0       	breq	80009128 <_fflush_r+0x108>
8000902c:	58 0c       	cp.w	r12,0
8000902e:	c0 50       	breq	80009038 <_fflush_r+0x18>
80009030:	78 68       	ld.w	r8,r12[0x18]
80009032:	58 08       	cp.w	r8,0
80009034:	c0 21       	brne	80009038 <_fflush_r+0x18>
80009036:	cc dc       	rcall	800091d0 <__sinit>
80009038:	fe c8 ce 28 	sub	r8,pc,-12760
8000903c:	10 37       	cp.w	r7,r8
8000903e:	c0 31       	brne	80009044 <_fflush_r+0x24>
80009040:	6c 07       	ld.w	r7,r6[0x0]
80009042:	c0 c8       	rjmp	8000905a <_fflush_r+0x3a>
80009044:	fe c8 ce 14 	sub	r8,pc,-12780
80009048:	10 37       	cp.w	r7,r8
8000904a:	c0 31       	brne	80009050 <_fflush_r+0x30>
8000904c:	6c 17       	ld.w	r7,r6[0x4]
8000904e:	c0 68       	rjmp	8000905a <_fflush_r+0x3a>
80009050:	fe c8 ce 00 	sub	r8,pc,-12800
80009054:	10 37       	cp.w	r7,r8
80009056:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000905a:	8e 6a       	ld.sh	r10,r7[0xc]
8000905c:	14 98       	mov	r8,r10
8000905e:	ed ba 00 03 	bld	r10,0x3
80009062:	c4 20       	breq	800090e6 <_fflush_r+0xc6>
80009064:	ab ba       	sbr	r10,0xb
80009066:	ae 6a       	st.h	r7[0xc],r10
80009068:	6e 18       	ld.w	r8,r7[0x4]
8000906a:	58 08       	cp.w	r8,0
8000906c:	e0 89 00 06 	brgt	80009078 <_fflush_r+0x58>
80009070:	6f 08       	ld.w	r8,r7[0x40]
80009072:	58 08       	cp.w	r8,0
80009074:	e0 8a 00 5a 	brle	80009128 <_fflush_r+0x108>
80009078:	6e b8       	ld.w	r8,r7[0x2c]
8000907a:	58 08       	cp.w	r8,0
8000907c:	c5 60       	breq	80009128 <_fflush_r+0x108>
8000907e:	e2 1a 10 00 	andl	r10,0x1000,COH
80009082:	c0 30       	breq	80009088 <_fflush_r+0x68>
80009084:	6f 55       	ld.w	r5,r7[0x54]
80009086:	c0 f8       	rjmp	800090a4 <_fflush_r+0x84>
80009088:	30 19       	mov	r9,1
8000908a:	6e 8b       	ld.w	r11,r7[0x20]
8000908c:	0c 9c       	mov	r12,r6
8000908e:	5d 18       	icall	r8
80009090:	18 95       	mov	r5,r12
80009092:	5b fc       	cp.w	r12,-1
80009094:	c0 81       	brne	800090a4 <_fflush_r+0x84>
80009096:	6c 38       	ld.w	r8,r6[0xc]
80009098:	59 d8       	cp.w	r8,29
8000909a:	c4 70       	breq	80009128 <_fflush_r+0x108>
8000909c:	8e 68       	ld.sh	r8,r7[0xc]
8000909e:	a7 a8       	sbr	r8,0x6
800090a0:	ae 68       	st.h	r7[0xc],r8
800090a2:	d8 22       	popm	r4-r7,pc
800090a4:	8e 68       	ld.sh	r8,r7[0xc]
800090a6:	ed b8 00 02 	bld	r8,0x2
800090aa:	c0 91       	brne	800090bc <_fflush_r+0x9c>
800090ac:	6e 18       	ld.w	r8,r7[0x4]
800090ae:	10 15       	sub	r5,r8
800090b0:	6e d8       	ld.w	r8,r7[0x34]
800090b2:	58 08       	cp.w	r8,0
800090b4:	ef f8 10 10 	ld.wne	r8,r7[0x40]
800090b8:	eb d8 e1 15 	subne	r5,r5,r8
800090bc:	6e b8       	ld.w	r8,r7[0x2c]
800090be:	0c 9c       	mov	r12,r6
800090c0:	30 09       	mov	r9,0
800090c2:	0a 9a       	mov	r10,r5
800090c4:	6e 8b       	ld.w	r11,r7[0x20]
800090c6:	5d 18       	icall	r8
800090c8:	8e 68       	ld.sh	r8,r7[0xc]
800090ca:	0a 3c       	cp.w	r12,r5
800090cc:	c2 61       	brne	80009118 <_fflush_r+0xf8>
800090ce:	ab d8       	cbr	r8,0xb
800090d0:	30 0c       	mov	r12,0
800090d2:	6e 49       	ld.w	r9,r7[0x10]
800090d4:	ae 68       	st.h	r7[0xc],r8
800090d6:	8f 1c       	st.w	r7[0x4],r12
800090d8:	8f 09       	st.w	r7[0x0],r9
800090da:	ed b8 00 0c 	bld	r8,0xc
800090de:	c2 51       	brne	80009128 <_fflush_r+0x108>
800090e0:	ef 45 00 54 	st.w	r7[84],r5
800090e4:	d8 22       	popm	r4-r7,pc
800090e6:	6e 45       	ld.w	r5,r7[0x10]
800090e8:	58 05       	cp.w	r5,0
800090ea:	c1 f0       	breq	80009128 <_fflush_r+0x108>
800090ec:	6e 04       	ld.w	r4,r7[0x0]
800090ee:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
800090f2:	8f 05       	st.w	r7[0x0],r5
800090f4:	f9 b8 01 00 	movne	r8,0
800090f8:	ef f8 00 05 	ld.weq	r8,r7[0x14]
800090fc:	0a 14       	sub	r4,r5
800090fe:	8f 28       	st.w	r7[0x8],r8
80009100:	c1 18       	rjmp	80009122 <_fflush_r+0x102>
80009102:	08 99       	mov	r9,r4
80009104:	0a 9a       	mov	r10,r5
80009106:	6e a8       	ld.w	r8,r7[0x28]
80009108:	6e 8b       	ld.w	r11,r7[0x20]
8000910a:	0c 9c       	mov	r12,r6
8000910c:	5d 18       	icall	r8
8000910e:	18 14       	sub	r4,r12
80009110:	58 0c       	cp.w	r12,0
80009112:	e0 89 00 07 	brgt	80009120 <_fflush_r+0x100>
80009116:	8e 68       	ld.sh	r8,r7[0xc]
80009118:	a7 a8       	sbr	r8,0x6
8000911a:	3f fc       	mov	r12,-1
8000911c:	ae 68       	st.h	r7[0xc],r8
8000911e:	d8 22       	popm	r4-r7,pc
80009120:	18 05       	add	r5,r12
80009122:	58 04       	cp.w	r4,0
80009124:	fe 99 ff ef 	brgt	80009102 <_fflush_r+0xe2>
80009128:	d8 2a       	popm	r4-r7,pc,r12=0
8000912a:	d7 03       	nop

8000912c <__sfp_lock_acquire>:
8000912c:	5e fc       	retal	r12

8000912e <__sfp_lock_release>:
8000912e:	5e fc       	retal	r12

80009130 <_cleanup_r>:
80009130:	d4 01       	pushm	lr
80009132:	fe cb f0 ae 	sub	r11,pc,-3922
80009136:	e0 a0 02 f7 	rcall	80009724 <_fwalk>
8000913a:	d8 02       	popm	pc

8000913c <__sfmoreglue>:
8000913c:	d4 21       	pushm	r4-r7,lr
8000913e:	16 95       	mov	r5,r11
80009140:	f6 06 10 5c 	mul	r6,r11,92
80009144:	ec cb ff f4 	sub	r11,r6,-12
80009148:	fe b0 e2 88 	rcall	80005658 <_malloc_r>
8000914c:	18 97       	mov	r7,r12
8000914e:	c0 90       	breq	80009160 <__sfmoreglue+0x24>
80009150:	99 15       	st.w	r12[0x4],r5
80009152:	30 0b       	mov	r11,0
80009154:	2f 4c       	sub	r12,-12
80009156:	0c 9a       	mov	r10,r6
80009158:	8f 2c       	st.w	r7[0x8],r12
8000915a:	8f 0b       	st.w	r7[0x0],r11
8000915c:	fe b0 e5 3e 	rcall	80005bd8 <memset>
80009160:	0e 9c       	mov	r12,r7
80009162:	d8 22       	popm	r4-r7,pc

80009164 <__sfp>:
80009164:	d4 21       	pushm	r4-r7,lr
80009166:	fe c8 ce f2 	sub	r8,pc,-12558
8000916a:	18 96       	mov	r6,r12
8000916c:	70 07       	ld.w	r7,r8[0x0]
8000916e:	6e 68       	ld.w	r8,r7[0x18]
80009170:	58 08       	cp.w	r8,0
80009172:	c0 31       	brne	80009178 <__sfp+0x14>
80009174:	0e 9c       	mov	r12,r7
80009176:	c2 dc       	rcall	800091d0 <__sinit>
80009178:	ee c7 ff 28 	sub	r7,r7,-216
8000917c:	30 05       	mov	r5,0
8000917e:	6e 2c       	ld.w	r12,r7[0x8]
80009180:	6e 18       	ld.w	r8,r7[0x4]
80009182:	c0 68       	rjmp	8000918e <__sfp+0x2a>
80009184:	98 69       	ld.sh	r9,r12[0xc]
80009186:	ea 09 19 00 	cp.h	r9,r5
8000918a:	c1 10       	breq	800091ac <__sfp+0x48>
8000918c:	2a 4c       	sub	r12,-92
8000918e:	20 18       	sub	r8,1
80009190:	cf a7       	brpl	80009184 <__sfp+0x20>
80009192:	6e 08       	ld.w	r8,r7[0x0]
80009194:	58 08       	cp.w	r8,0
80009196:	c0 61       	brne	800091a2 <__sfp+0x3e>
80009198:	30 4b       	mov	r11,4
8000919a:	0c 9c       	mov	r12,r6
8000919c:	cd 0f       	rcall	8000913c <__sfmoreglue>
8000919e:	8f 0c       	st.w	r7[0x0],r12
800091a0:	c0 30       	breq	800091a6 <__sfp+0x42>
800091a2:	6e 07       	ld.w	r7,r7[0x0]
800091a4:	ce db       	rjmp	8000917e <__sfp+0x1a>
800091a6:	30 c8       	mov	r8,12
800091a8:	8d 38       	st.w	r6[0xc],r8
800091aa:	d8 22       	popm	r4-r7,pc
800091ac:	30 08       	mov	r8,0
800091ae:	f9 48 00 4c 	st.w	r12[76],r8
800091b2:	99 08       	st.w	r12[0x0],r8
800091b4:	99 28       	st.w	r12[0x8],r8
800091b6:	99 18       	st.w	r12[0x4],r8
800091b8:	99 48       	st.w	r12[0x10],r8
800091ba:	99 58       	st.w	r12[0x14],r8
800091bc:	99 68       	st.w	r12[0x18],r8
800091be:	99 d8       	st.w	r12[0x34],r8
800091c0:	99 e8       	st.w	r12[0x38],r8
800091c2:	f9 48 00 48 	st.w	r12[72],r8
800091c6:	3f f8       	mov	r8,-1
800091c8:	b8 78       	st.h	r12[0xe],r8
800091ca:	30 18       	mov	r8,1
800091cc:	b8 68       	st.h	r12[0xc],r8
800091ce:	d8 22       	popm	r4-r7,pc

800091d0 <__sinit>:
800091d0:	d4 21       	pushm	r4-r7,lr
800091d2:	18 96       	mov	r6,r12
800091d4:	78 67       	ld.w	r7,r12[0x18]
800091d6:	58 07       	cp.w	r7,0
800091d8:	c4 91       	brne	8000926a <__sinit+0x9a>
800091da:	fe c8 00 aa 	sub	r8,pc,170
800091de:	30 15       	mov	r5,1
800091e0:	99 a8       	st.w	r12[0x28],r8
800091e2:	f9 47 00 d8 	st.w	r12[216],r7
800091e6:	f9 47 00 dc 	st.w	r12[220],r7
800091ea:	f9 47 00 e0 	st.w	r12[224],r7
800091ee:	99 65       	st.w	r12[0x18],r5
800091f0:	cb af       	rcall	80009164 <__sfp>
800091f2:	8d 0c       	st.w	r6[0x0],r12
800091f4:	0c 9c       	mov	r12,r6
800091f6:	cb 7f       	rcall	80009164 <__sfp>
800091f8:	8d 1c       	st.w	r6[0x4],r12
800091fa:	0c 9c       	mov	r12,r6
800091fc:	cb 4f       	rcall	80009164 <__sfp>
800091fe:	6c 09       	ld.w	r9,r6[0x0]
80009200:	30 48       	mov	r8,4
80009202:	93 07       	st.w	r9[0x0],r7
80009204:	b2 68       	st.h	r9[0xc],r8
80009206:	93 17       	st.w	r9[0x4],r7
80009208:	93 27       	st.w	r9[0x8],r7
8000920a:	6c 18       	ld.w	r8,r6[0x4]
8000920c:	b2 77       	st.h	r9[0xe],r7
8000920e:	93 47       	st.w	r9[0x10],r7
80009210:	93 57       	st.w	r9[0x14],r7
80009212:	93 67       	st.w	r9[0x18],r7
80009214:	93 89       	st.w	r9[0x20],r9
80009216:	91 07       	st.w	r8[0x0],r7
80009218:	91 17       	st.w	r8[0x4],r7
8000921a:	91 27       	st.w	r8[0x8],r7
8000921c:	fe ce f3 24 	sub	lr,pc,-3292
80009220:	fe cb f3 54 	sub	r11,pc,-3244
80009224:	93 9e       	st.w	r9[0x24],lr
80009226:	93 ab       	st.w	r9[0x28],r11
80009228:	fe ca f3 7c 	sub	r10,pc,-3204
8000922c:	fe c4 f3 88 	sub	r4,pc,-3192
80009230:	93 ba       	st.w	r9[0x2c],r10
80009232:	93 c4       	st.w	r9[0x30],r4
80009234:	30 99       	mov	r9,9
80009236:	b0 69       	st.h	r8[0xc],r9
80009238:	b0 75       	st.h	r8[0xe],r5
8000923a:	91 c4       	st.w	r8[0x30],r4
8000923c:	91 47       	st.w	r8[0x10],r7
8000923e:	91 57       	st.w	r8[0x14],r7
80009240:	91 67       	st.w	r8[0x18],r7
80009242:	91 88       	st.w	r8[0x20],r8
80009244:	91 9e       	st.w	r8[0x24],lr
80009246:	91 ab       	st.w	r8[0x28],r11
80009248:	91 ba       	st.w	r8[0x2c],r10
8000924a:	8d 2c       	st.w	r6[0x8],r12
8000924c:	31 28       	mov	r8,18
8000924e:	99 07       	st.w	r12[0x0],r7
80009250:	b8 68       	st.h	r12[0xc],r8
80009252:	99 17       	st.w	r12[0x4],r7
80009254:	99 27       	st.w	r12[0x8],r7
80009256:	30 28       	mov	r8,2
80009258:	b8 78       	st.h	r12[0xe],r8
8000925a:	99 c4       	st.w	r12[0x30],r4
8000925c:	99 67       	st.w	r12[0x18],r7
8000925e:	99 9e       	st.w	r12[0x24],lr
80009260:	99 ab       	st.w	r12[0x28],r11
80009262:	99 ba       	st.w	r12[0x2c],r10
80009264:	99 47       	st.w	r12[0x10],r7
80009266:	99 57       	st.w	r12[0x14],r7
80009268:	99 8c       	st.w	r12[0x20],r12
8000926a:	d8 22       	popm	r4-r7,pc

8000926c <_malloc_trim_r>:
8000926c:	d4 21       	pushm	r4-r7,lr
8000926e:	16 95       	mov	r5,r11
80009270:	18 97       	mov	r7,r12
80009272:	fe b0 d7 d3 	rcall	80004218 <__malloc_lock>
80009276:	e0 64 05 40 	mov	r4,1344
8000927a:	68 28       	ld.w	r8,r4[0x8]
8000927c:	70 16       	ld.w	r6,r8[0x4]
8000927e:	e0 16 ff fc 	andl	r6,0xfffc
80009282:	ec c8 ff 91 	sub	r8,r6,-111
80009286:	f0 05 01 05 	sub	r5,r8,r5
8000928a:	e0 15 ff 80 	andl	r5,0xff80
8000928e:	ea c5 00 80 	sub	r5,r5,128
80009292:	e0 45 00 7f 	cp.w	r5,127
80009296:	e0 8a 00 25 	brle	800092e0 <_malloc_trim_r+0x74>
8000929a:	30 0b       	mov	r11,0
8000929c:	0e 9c       	mov	r12,r7
8000929e:	fe b0 e6 05 	rcall	80005ea8 <_sbrk_r>
800092a2:	68 28       	ld.w	r8,r4[0x8]
800092a4:	0c 08       	add	r8,r6
800092a6:	10 3c       	cp.w	r12,r8
800092a8:	c1 c1       	brne	800092e0 <_malloc_trim_r+0x74>
800092aa:	ea 0b 11 00 	rsub	r11,r5,0
800092ae:	0e 9c       	mov	r12,r7
800092b0:	fe b0 e5 fc 	rcall	80005ea8 <_sbrk_r>
800092b4:	5b fc       	cp.w	r12,-1
800092b6:	c1 91       	brne	800092e8 <_malloc_trim_r+0x7c>
800092b8:	30 0b       	mov	r11,0
800092ba:	0e 9c       	mov	r12,r7
800092bc:	fe b0 e5 f6 	rcall	80005ea8 <_sbrk_r>
800092c0:	68 28       	ld.w	r8,r4[0x8]
800092c2:	f8 08 01 09 	sub	r9,r12,r8
800092c6:	58 f9       	cp.w	r9,15
800092c8:	e0 8a 00 0c 	brle	800092e0 <_malloc_trim_r+0x74>
800092cc:	a1 a9       	sbr	r9,0x0
800092ce:	91 19       	st.w	r8[0x4],r9
800092d0:	e0 68 09 4c 	mov	r8,2380
800092d4:	70 09       	ld.w	r9,r8[0x0]
800092d6:	e0 68 0d 74 	mov	r8,3444
800092da:	f8 09 01 09 	sub	r9,r12,r9
800092de:	91 09       	st.w	r8[0x0],r9
800092e0:	0e 9c       	mov	r12,r7
800092e2:	fe b0 d7 a1 	rcall	80004224 <__malloc_unlock>
800092e6:	d8 2a       	popm	r4-r7,pc,r12=0
800092e8:	68 28       	ld.w	r8,r4[0x8]
800092ea:	0a 16       	sub	r6,r5
800092ec:	a1 a6       	sbr	r6,0x0
800092ee:	91 16       	st.w	r8[0x4],r6
800092f0:	e0 68 0d 74 	mov	r8,3444
800092f4:	70 09       	ld.w	r9,r8[0x0]
800092f6:	0a 19       	sub	r9,r5
800092f8:	0e 9c       	mov	r12,r7
800092fa:	91 09       	st.w	r8[0x0],r9
800092fc:	fe b0 d7 94 	rcall	80004224 <__malloc_unlock>
80009300:	da 2a       	popm	r4-r7,pc,r12=1
80009302:	d7 03       	nop

80009304 <_free_r>:
80009304:	d4 21       	pushm	r4-r7,lr
80009306:	16 96       	mov	r6,r11
80009308:	18 97       	mov	r7,r12
8000930a:	58 0b       	cp.w	r11,0
8000930c:	e0 80 00 c0 	breq	8000948c <_free_r+0x188>
80009310:	fe b0 d7 84 	rcall	80004218 <__malloc_lock>
80009314:	20 86       	sub	r6,8
80009316:	e0 6a 05 40 	mov	r10,1344
8000931a:	6c 18       	ld.w	r8,r6[0x4]
8000931c:	74 2e       	ld.w	lr,r10[0x8]
8000931e:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80009322:	a1 c8       	cbr	r8,0x0
80009324:	ec 08 00 09 	add	r9,r6,r8
80009328:	72 1b       	ld.w	r11,r9[0x4]
8000932a:	e0 1b ff fc 	andl	r11,0xfffc
8000932e:	1c 39       	cp.w	r9,lr
80009330:	c1 e1       	brne	8000936c <_free_r+0x68>
80009332:	f6 08 00 08 	add	r8,r11,r8
80009336:	58 0c       	cp.w	r12,0
80009338:	c0 81       	brne	80009348 <_free_r+0x44>
8000933a:	6c 09       	ld.w	r9,r6[0x0]
8000933c:	12 16       	sub	r6,r9
8000933e:	12 08       	add	r8,r9
80009340:	6c 3b       	ld.w	r11,r6[0xc]
80009342:	6c 29       	ld.w	r9,r6[0x8]
80009344:	97 29       	st.w	r11[0x8],r9
80009346:	93 3b       	st.w	r9[0xc],r11
80009348:	10 99       	mov	r9,r8
8000934a:	95 26       	st.w	r10[0x8],r6
8000934c:	a1 a9       	sbr	r9,0x0
8000934e:	8d 19       	st.w	r6[0x4],r9
80009350:	e0 69 09 48 	mov	r9,2376
80009354:	72 09       	ld.w	r9,r9[0x0]
80009356:	12 38       	cp.w	r8,r9
80009358:	c0 63       	brcs	80009364 <_free_r+0x60>
8000935a:	e0 68 0d 70 	mov	r8,3440
8000935e:	0e 9c       	mov	r12,r7
80009360:	70 0b       	ld.w	r11,r8[0x0]
80009362:	c8 5f       	rcall	8000926c <_malloc_trim_r>
80009364:	0e 9c       	mov	r12,r7
80009366:	fe b0 d7 5f 	rcall	80004224 <__malloc_unlock>
8000936a:	d8 22       	popm	r4-r7,pc
8000936c:	93 1b       	st.w	r9[0x4],r11
8000936e:	58 0c       	cp.w	r12,0
80009370:	c0 30       	breq	80009376 <_free_r+0x72>
80009372:	30 0c       	mov	r12,0
80009374:	c1 08       	rjmp	80009394 <_free_r+0x90>
80009376:	6c 0e       	ld.w	lr,r6[0x0]
80009378:	f4 c5 ff f8 	sub	r5,r10,-8
8000937c:	1c 16       	sub	r6,lr
8000937e:	1c 08       	add	r8,lr
80009380:	6c 2e       	ld.w	lr,r6[0x8]
80009382:	0a 3e       	cp.w	lr,r5
80009384:	f9 bc 00 01 	moveq	r12,1
80009388:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000938c:	eb fe 1a 02 	st.wne	r5[0x8],lr
80009390:	fd f5 1a 03 	st.wne	lr[0xc],r5
80009394:	f2 0b 00 0e 	add	lr,r9,r11
80009398:	7c 1e       	ld.w	lr,lr[0x4]
8000939a:	ed be 00 00 	bld	lr,0x0
8000939e:	c1 40       	breq	800093c6 <_free_r+0xc2>
800093a0:	16 08       	add	r8,r11
800093a2:	58 0c       	cp.w	r12,0
800093a4:	c0 d1       	brne	800093be <_free_r+0xba>
800093a6:	e0 6e 05 40 	mov	lr,1344
800093aa:	72 2b       	ld.w	r11,r9[0x8]
800093ac:	2f 8e       	sub	lr,-8
800093ae:	1c 3b       	cp.w	r11,lr
800093b0:	c0 71       	brne	800093be <_free_r+0xba>
800093b2:	97 36       	st.w	r11[0xc],r6
800093b4:	97 26       	st.w	r11[0x8],r6
800093b6:	8d 2b       	st.w	r6[0x8],r11
800093b8:	8d 3b       	st.w	r6[0xc],r11
800093ba:	30 1c       	mov	r12,1
800093bc:	c0 58       	rjmp	800093c6 <_free_r+0xc2>
800093be:	72 2b       	ld.w	r11,r9[0x8]
800093c0:	72 39       	ld.w	r9,r9[0xc]
800093c2:	93 2b       	st.w	r9[0x8],r11
800093c4:	97 39       	st.w	r11[0xc],r9
800093c6:	10 99       	mov	r9,r8
800093c8:	ec 08 09 08 	st.w	r6[r8],r8
800093cc:	a1 a9       	sbr	r9,0x0
800093ce:	8d 19       	st.w	r6[0x4],r9
800093d0:	58 0c       	cp.w	r12,0
800093d2:	c5 a1       	brne	80009486 <_free_r+0x182>
800093d4:	e0 48 01 ff 	cp.w	r8,511
800093d8:	e0 8b 00 13 	brhi	800093fe <_free_r+0xfa>
800093dc:	a3 98       	lsr	r8,0x3
800093de:	f4 08 00 39 	add	r9,r10,r8<<0x3
800093e2:	72 2b       	ld.w	r11,r9[0x8]
800093e4:	8d 39       	st.w	r6[0xc],r9
800093e6:	8d 2b       	st.w	r6[0x8],r11
800093e8:	97 36       	st.w	r11[0xc],r6
800093ea:	93 26       	st.w	r9[0x8],r6
800093ec:	a3 48       	asr	r8,0x2
800093ee:	74 19       	ld.w	r9,r10[0x4]
800093f0:	30 1b       	mov	r11,1
800093f2:	f6 08 09 48 	lsl	r8,r11,r8
800093f6:	f3 e8 10 08 	or	r8,r9,r8
800093fa:	95 18       	st.w	r10[0x4],r8
800093fc:	c4 58       	rjmp	80009486 <_free_r+0x182>
800093fe:	f0 0b 16 09 	lsr	r11,r8,0x9
80009402:	58 4b       	cp.w	r11,4
80009404:	e0 8b 00 06 	brhi	80009410 <_free_r+0x10c>
80009408:	f0 0b 16 06 	lsr	r11,r8,0x6
8000940c:	2c 8b       	sub	r11,-56
8000940e:	c2 08       	rjmp	8000944e <_free_r+0x14a>
80009410:	59 4b       	cp.w	r11,20
80009412:	e0 8b 00 04 	brhi	8000941a <_free_r+0x116>
80009416:	2a 5b       	sub	r11,-91
80009418:	c1 b8       	rjmp	8000944e <_free_r+0x14a>
8000941a:	e0 4b 00 54 	cp.w	r11,84
8000941e:	e0 8b 00 06 	brhi	8000942a <_free_r+0x126>
80009422:	f0 0b 16 0c 	lsr	r11,r8,0xc
80009426:	29 2b       	sub	r11,-110
80009428:	c1 38       	rjmp	8000944e <_free_r+0x14a>
8000942a:	e0 4b 01 54 	cp.w	r11,340
8000942e:	e0 8b 00 06 	brhi	8000943a <_free_r+0x136>
80009432:	f0 0b 16 0f 	lsr	r11,r8,0xf
80009436:	28 9b       	sub	r11,-119
80009438:	c0 b8       	rjmp	8000944e <_free_r+0x14a>
8000943a:	e0 4b 05 54 	cp.w	r11,1364
8000943e:	e0 88 00 05 	brls	80009448 <_free_r+0x144>
80009442:	37 eb       	mov	r11,126
80009444:	c0 58       	rjmp	8000944e <_free_r+0x14a>
80009446:	d7 03       	nop
80009448:	f0 0b 16 12 	lsr	r11,r8,0x12
8000944c:	28 4b       	sub	r11,-124
8000944e:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
80009452:	78 29       	ld.w	r9,r12[0x8]
80009454:	18 39       	cp.w	r9,r12
80009456:	c0 e1       	brne	80009472 <_free_r+0x16e>
80009458:	74 18       	ld.w	r8,r10[0x4]
8000945a:	a3 4b       	asr	r11,0x2
8000945c:	30 1c       	mov	r12,1
8000945e:	f8 0b 09 4b 	lsl	r11,r12,r11
80009462:	f1 eb 10 0b 	or	r11,r8,r11
80009466:	12 98       	mov	r8,r9
80009468:	95 1b       	st.w	r10[0x4],r11
8000946a:	c0 a8       	rjmp	8000947e <_free_r+0x17a>
8000946c:	72 29       	ld.w	r9,r9[0x8]
8000946e:	18 39       	cp.w	r9,r12
80009470:	c0 60       	breq	8000947c <_free_r+0x178>
80009472:	72 1a       	ld.w	r10,r9[0x4]
80009474:	e0 1a ff fc 	andl	r10,0xfffc
80009478:	14 38       	cp.w	r8,r10
8000947a:	cf 93       	brcs	8000946c <_free_r+0x168>
8000947c:	72 38       	ld.w	r8,r9[0xc]
8000947e:	8d 38       	st.w	r6[0xc],r8
80009480:	8d 29       	st.w	r6[0x8],r9
80009482:	93 36       	st.w	r9[0xc],r6
80009484:	91 26       	st.w	r8[0x8],r6
80009486:	0e 9c       	mov	r12,r7
80009488:	fe b0 d6 ce 	rcall	80004224 <__malloc_unlock>
8000948c:	d8 22       	popm	r4-r7,pc
8000948e:	d7 03       	nop

80009490 <__sfvwrite_r>:
80009490:	d4 31       	pushm	r0-r7,lr
80009492:	20 3d       	sub	sp,12
80009494:	14 94       	mov	r4,r10
80009496:	18 95       	mov	r5,r12
80009498:	16 97       	mov	r7,r11
8000949a:	74 28       	ld.w	r8,r10[0x8]
8000949c:	58 08       	cp.w	r8,0
8000949e:	e0 80 01 40 	breq	8000971e <__sfvwrite_r+0x28e>
800094a2:	96 68       	ld.sh	r8,r11[0xc]
800094a4:	ed b8 00 03 	bld	r8,0x3
800094a8:	c0 41       	brne	800094b0 <__sfvwrite_r+0x20>
800094aa:	76 48       	ld.w	r8,r11[0x10]
800094ac:	58 08       	cp.w	r8,0
800094ae:	c0 c1       	brne	800094c6 <__sfvwrite_r+0x36>
800094b0:	0e 9b       	mov	r11,r7
800094b2:	0a 9c       	mov	r12,r5
800094b4:	fe b0 f6 c4 	rcall	8000823c <__swsetup_r>
800094b8:	c0 70       	breq	800094c6 <__sfvwrite_r+0x36>
800094ba:	8e 68       	ld.sh	r8,r7[0xc]
800094bc:	a7 a8       	sbr	r8,0x6
800094be:	ae 68       	st.h	r7[0xc],r8
800094c0:	30 98       	mov	r8,9
800094c2:	8b 38       	st.w	r5[0xc],r8
800094c4:	c2 b9       	rjmp	8000971a <__sfvwrite_r+0x28a>
800094c6:	8e 63       	ld.sh	r3,r7[0xc]
800094c8:	68 00       	ld.w	r0,r4[0x0]
800094ca:	06 96       	mov	r6,r3
800094cc:	e2 16 00 02 	andl	r6,0x2,COH
800094d0:	c2 10       	breq	80009512 <__sfvwrite_r+0x82>
800094d2:	30 03       	mov	r3,0
800094d4:	e0 62 04 00 	mov	r2,1024
800094d8:	06 96       	mov	r6,r3
800094da:	c0 48       	rjmp	800094e2 <__sfvwrite_r+0x52>
800094dc:	60 03       	ld.w	r3,r0[0x0]
800094de:	60 16       	ld.w	r6,r0[0x4]
800094e0:	2f 80       	sub	r0,-8
800094e2:	58 06       	cp.w	r6,0
800094e4:	cf c0       	breq	800094dc <__sfvwrite_r+0x4c>
800094e6:	e0 46 04 00 	cp.w	r6,1024
800094ea:	ec 09 17 80 	movls	r9,r6
800094ee:	e4 09 17 b0 	movhi	r9,r2
800094f2:	06 9a       	mov	r10,r3
800094f4:	6e a8       	ld.w	r8,r7[0x28]
800094f6:	6e 8b       	ld.w	r11,r7[0x20]
800094f8:	0a 9c       	mov	r12,r5
800094fa:	5d 18       	icall	r8
800094fc:	18 16       	sub	r6,r12
800094fe:	58 0c       	cp.w	r12,0
80009500:	e0 8a 01 0a 	brle	80009714 <__sfvwrite_r+0x284>
80009504:	68 28       	ld.w	r8,r4[0x8]
80009506:	18 18       	sub	r8,r12
80009508:	89 28       	st.w	r4[0x8],r8
8000950a:	e0 80 01 0a 	breq	8000971e <__sfvwrite_r+0x28e>
8000950e:	18 03       	add	r3,r12
80009510:	ce 9b       	rjmp	800094e2 <__sfvwrite_r+0x52>
80009512:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
80009516:	c0 70       	breq	80009524 <__sfvwrite_r+0x94>
80009518:	50 06       	stdsp	sp[0x0],r6
8000951a:	0c 93       	mov	r3,r6
8000951c:	0c 91       	mov	r1,r6
8000951e:	50 15       	stdsp	sp[0x4],r5
80009520:	08 92       	mov	r2,r4
80009522:	c9 c8       	rjmp	8000965a <__sfvwrite_r+0x1ca>
80009524:	06 96       	mov	r6,r3
80009526:	08 91       	mov	r1,r4
80009528:	c0 48       	rjmp	80009530 <__sfvwrite_r+0xa0>
8000952a:	60 03       	ld.w	r3,r0[0x0]
8000952c:	60 16       	ld.w	r6,r0[0x4]
8000952e:	2f 80       	sub	r0,-8
80009530:	58 06       	cp.w	r6,0
80009532:	cf c0       	breq	8000952a <__sfvwrite_r+0x9a>
80009534:	8e 68       	ld.sh	r8,r7[0xc]
80009536:	6e 24       	ld.w	r4,r7[0x8]
80009538:	10 99       	mov	r9,r8
8000953a:	e2 19 02 00 	andl	r9,0x200,COH
8000953e:	c5 50       	breq	800095e8 <__sfvwrite_r+0x158>
80009540:	08 36       	cp.w	r6,r4
80009542:	c4 43       	brcs	800095ca <__sfvwrite_r+0x13a>
80009544:	10 99       	mov	r9,r8
80009546:	e2 19 04 80 	andl	r9,0x480,COH
8000954a:	c4 00       	breq	800095ca <__sfvwrite_r+0x13a>
8000954c:	6e 4b       	ld.w	r11,r7[0x10]
8000954e:	6e 09       	ld.w	r9,r7[0x0]
80009550:	16 19       	sub	r9,r11
80009552:	50 09       	stdsp	sp[0x0],r9
80009554:	6e 59       	ld.w	r9,r7[0x14]
80009556:	10 9c       	mov	r12,r8
80009558:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000955c:	30 28       	mov	r8,2
8000955e:	f4 08 0c 08 	divs	r8,r10,r8
80009562:	fa e9 00 04 	st.d	sp[4],r8
80009566:	10 94       	mov	r4,r8
80009568:	40 09       	lddsp	r9,sp[0x0]
8000956a:	e2 1c 04 00 	andl	r12,0x400,COH
8000956e:	2f f9       	sub	r9,-1
80009570:	0c 09       	add	r9,r6
80009572:	12 38       	cp.w	r8,r9
80009574:	f2 04 17 30 	movlo	r4,r9
80009578:	58 0c       	cp.w	r12,0
8000957a:	c1 10       	breq	8000959c <__sfvwrite_r+0x10c>
8000957c:	08 9b       	mov	r11,r4
8000957e:	0a 9c       	mov	r12,r5
80009580:	fe b0 e0 6c 	rcall	80005658 <_malloc_r>
80009584:	18 92       	mov	r2,r12
80009586:	c1 40       	breq	800095ae <__sfvwrite_r+0x11e>
80009588:	40 0a       	lddsp	r10,sp[0x0]
8000958a:	6e 4b       	ld.w	r11,r7[0x10]
8000958c:	fe b0 e2 82 	rcall	80005a90 <memcpy>
80009590:	8e 68       	ld.sh	r8,r7[0xc]
80009592:	e0 18 fb 7f 	andl	r8,0xfb7f
80009596:	a7 b8       	sbr	r8,0x7
80009598:	ae 68       	st.h	r7[0xc],r8
8000959a:	c0 d8       	rjmp	800095b4 <__sfvwrite_r+0x124>
8000959c:	08 9a       	mov	r10,r4
8000959e:	0a 9c       	mov	r12,r5
800095a0:	fe b0 e3 24 	rcall	80005be8 <_realloc_r>
800095a4:	18 92       	mov	r2,r12
800095a6:	c0 71       	brne	800095b4 <__sfvwrite_r+0x124>
800095a8:	6e 4b       	ld.w	r11,r7[0x10]
800095aa:	0a 9c       	mov	r12,r5
800095ac:	ca ce       	rcall	80009304 <_free_r>
800095ae:	30 c8       	mov	r8,12
800095b0:	8b 38       	st.w	r5[0xc],r8
800095b2:	cb 18       	rjmp	80009714 <__sfvwrite_r+0x284>
800095b4:	40 0a       	lddsp	r10,sp[0x0]
800095b6:	40 09       	lddsp	r9,sp[0x0]
800095b8:	e8 0a 01 0a 	sub	r10,r4,r10
800095bc:	e4 09 00 08 	add	r8,r2,r9
800095c0:	8f 54       	st.w	r7[0x14],r4
800095c2:	8f 2a       	st.w	r7[0x8],r10
800095c4:	8f 08       	st.w	r7[0x0],r8
800095c6:	8f 42       	st.w	r7[0x10],r2
800095c8:	0c 94       	mov	r4,r6
800095ca:	08 36       	cp.w	r6,r4
800095cc:	ec 04 17 30 	movlo	r4,r6
800095d0:	06 9b       	mov	r11,r3
800095d2:	08 9a       	mov	r10,r4
800095d4:	6e 0c       	ld.w	r12,r7[0x0]
800095d6:	c3 ad       	rcall	8000984a <memmove>
800095d8:	6e 08       	ld.w	r8,r7[0x0]
800095da:	08 08       	add	r8,r4
800095dc:	8f 08       	st.w	r7[0x0],r8
800095de:	6e 28       	ld.w	r8,r7[0x8]
800095e0:	08 18       	sub	r8,r4
800095e2:	0c 94       	mov	r4,r6
800095e4:	8f 28       	st.w	r7[0x8],r8
800095e6:	c2 e8       	rjmp	80009642 <__sfvwrite_r+0x1b2>
800095e8:	08 36       	cp.w	r6,r4
800095ea:	5f ba       	srhi	r10
800095ec:	6e 0c       	ld.w	r12,r7[0x0]
800095ee:	6e 48       	ld.w	r8,r7[0x10]
800095f0:	10 3c       	cp.w	r12,r8
800095f2:	5f b8       	srhi	r8
800095f4:	f5 e8 00 08 	and	r8,r10,r8
800095f8:	f2 08 18 00 	cp.b	r8,r9
800095fc:	c0 d0       	breq	80009616 <__sfvwrite_r+0x186>
800095fe:	06 9b       	mov	r11,r3
80009600:	08 9a       	mov	r10,r4
80009602:	c2 4d       	rcall	8000984a <memmove>
80009604:	6e 08       	ld.w	r8,r7[0x0]
80009606:	08 08       	add	r8,r4
80009608:	0e 9b       	mov	r11,r7
8000960a:	8f 08       	st.w	r7[0x0],r8
8000960c:	0a 9c       	mov	r12,r5
8000960e:	fe b0 fd 09 	rcall	80009020 <_fflush_r>
80009612:	c1 80       	breq	80009642 <__sfvwrite_r+0x1b2>
80009614:	c8 08       	rjmp	80009714 <__sfvwrite_r+0x284>
80009616:	6e 59       	ld.w	r9,r7[0x14]
80009618:	12 36       	cp.w	r6,r9
8000961a:	c0 a3       	brcs	8000962e <__sfvwrite_r+0x19e>
8000961c:	6e a8       	ld.w	r8,r7[0x28]
8000961e:	06 9a       	mov	r10,r3
80009620:	6e 8b       	ld.w	r11,r7[0x20]
80009622:	0a 9c       	mov	r12,r5
80009624:	5d 18       	icall	r8
80009626:	18 94       	mov	r4,r12
80009628:	e0 89 00 0d 	brgt	80009642 <__sfvwrite_r+0x1b2>
8000962c:	c7 48       	rjmp	80009714 <__sfvwrite_r+0x284>
8000962e:	0c 9a       	mov	r10,r6
80009630:	06 9b       	mov	r11,r3
80009632:	c0 cd       	rcall	8000984a <memmove>
80009634:	6e 08       	ld.w	r8,r7[0x0]
80009636:	0c 08       	add	r8,r6
80009638:	0c 94       	mov	r4,r6
8000963a:	8f 08       	st.w	r7[0x0],r8
8000963c:	6e 28       	ld.w	r8,r7[0x8]
8000963e:	0c 18       	sub	r8,r6
80009640:	8f 28       	st.w	r7[0x8],r8
80009642:	62 28       	ld.w	r8,r1[0x8]
80009644:	08 18       	sub	r8,r4
80009646:	83 28       	st.w	r1[0x8],r8
80009648:	c6 b0       	breq	8000971e <__sfvwrite_r+0x28e>
8000964a:	08 16       	sub	r6,r4
8000964c:	08 03       	add	r3,r4
8000964e:	c7 1b       	rjmp	80009530 <__sfvwrite_r+0xa0>
80009650:	60 03       	ld.w	r3,r0[0x0]
80009652:	60 11       	ld.w	r1,r0[0x4]
80009654:	30 08       	mov	r8,0
80009656:	2f 80       	sub	r0,-8
80009658:	50 08       	stdsp	sp[0x0],r8
8000965a:	58 01       	cp.w	r1,0
8000965c:	cf a0       	breq	80009650 <__sfvwrite_r+0x1c0>
8000965e:	40 0a       	lddsp	r10,sp[0x0]
80009660:	58 0a       	cp.w	r10,0
80009662:	c1 41       	brne	8000968a <__sfvwrite_r+0x1fa>
80009664:	e2 c6 ff ff 	sub	r6,r1,-1
80009668:	02 9a       	mov	r10,r1
8000966a:	30 ab       	mov	r11,10
8000966c:	06 9c       	mov	r12,r3
8000966e:	ce 3c       	rcall	80009834 <memchr>
80009670:	f8 c8 ff ff 	sub	r8,r12,-1
80009674:	58 0c       	cp.w	r12,0
80009676:	f1 d3 e1 16 	subne	r6,r8,r3
8000967a:	f9 b9 01 01 	movne	r9,1
8000967e:	fb f9 1a 00 	st.wne	sp[0x0],r9
80009682:	f9 b8 00 01 	moveq	r8,1
80009686:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000968a:	02 36       	cp.w	r6,r1
8000968c:	ec 04 17 80 	movls	r4,r6
80009690:	e2 04 17 b0 	movhi	r4,r1
80009694:	6e 59       	ld.w	r9,r7[0x14]
80009696:	6e 25       	ld.w	r5,r7[0x8]
80009698:	f2 05 00 05 	add	r5,r9,r5
8000969c:	0a 34       	cp.w	r4,r5
8000969e:	5f 9a       	srgt	r10
800096a0:	6e 0c       	ld.w	r12,r7[0x0]
800096a2:	6e 48       	ld.w	r8,r7[0x10]
800096a4:	10 3c       	cp.w	r12,r8
800096a6:	5f b8       	srhi	r8
800096a8:	f5 e8 00 08 	and	r8,r10,r8
800096ac:	30 0a       	mov	r10,0
800096ae:	f4 08 18 00 	cp.b	r8,r10
800096b2:	c0 d0       	breq	800096cc <__sfvwrite_r+0x23c>
800096b4:	06 9b       	mov	r11,r3
800096b6:	0a 9a       	mov	r10,r5
800096b8:	cc 9c       	rcall	8000984a <memmove>
800096ba:	6e 08       	ld.w	r8,r7[0x0]
800096bc:	0a 08       	add	r8,r5
800096be:	0e 9b       	mov	r11,r7
800096c0:	8f 08       	st.w	r7[0x0],r8
800096c2:	40 1c       	lddsp	r12,sp[0x4]
800096c4:	fe b0 fc ae 	rcall	80009020 <_fflush_r>
800096c8:	c1 70       	breq	800096f6 <__sfvwrite_r+0x266>
800096ca:	c2 58       	rjmp	80009714 <__sfvwrite_r+0x284>
800096cc:	12 34       	cp.w	r4,r9
800096ce:	c0 a5       	brlt	800096e2 <__sfvwrite_r+0x252>
800096d0:	6e a8       	ld.w	r8,r7[0x28]
800096d2:	06 9a       	mov	r10,r3
800096d4:	6e 8b       	ld.w	r11,r7[0x20]
800096d6:	40 1c       	lddsp	r12,sp[0x4]
800096d8:	5d 18       	icall	r8
800096da:	18 95       	mov	r5,r12
800096dc:	e0 89 00 0d 	brgt	800096f6 <__sfvwrite_r+0x266>
800096e0:	c1 a8       	rjmp	80009714 <__sfvwrite_r+0x284>
800096e2:	08 9a       	mov	r10,r4
800096e4:	06 9b       	mov	r11,r3
800096e6:	cb 2c       	rcall	8000984a <memmove>
800096e8:	6e 08       	ld.w	r8,r7[0x0]
800096ea:	08 08       	add	r8,r4
800096ec:	08 95       	mov	r5,r4
800096ee:	8f 08       	st.w	r7[0x0],r8
800096f0:	6e 28       	ld.w	r8,r7[0x8]
800096f2:	08 18       	sub	r8,r4
800096f4:	8f 28       	st.w	r7[0x8],r8
800096f6:	0a 16       	sub	r6,r5
800096f8:	c0 71       	brne	80009706 <__sfvwrite_r+0x276>
800096fa:	0e 9b       	mov	r11,r7
800096fc:	40 1c       	lddsp	r12,sp[0x4]
800096fe:	fe b0 fc 91 	rcall	80009020 <_fflush_r>
80009702:	c0 91       	brne	80009714 <__sfvwrite_r+0x284>
80009704:	50 06       	stdsp	sp[0x0],r6
80009706:	64 28       	ld.w	r8,r2[0x8]
80009708:	0a 18       	sub	r8,r5
8000970a:	85 28       	st.w	r2[0x8],r8
8000970c:	c0 90       	breq	8000971e <__sfvwrite_r+0x28e>
8000970e:	0a 11       	sub	r1,r5
80009710:	0a 03       	add	r3,r5
80009712:	ca 4b       	rjmp	8000965a <__sfvwrite_r+0x1ca>
80009714:	8e 68       	ld.sh	r8,r7[0xc]
80009716:	a7 a8       	sbr	r8,0x6
80009718:	ae 68       	st.h	r7[0xc],r8
8000971a:	3f fc       	mov	r12,-1
8000971c:	c0 28       	rjmp	80009720 <__sfvwrite_r+0x290>
8000971e:	30 0c       	mov	r12,0
80009720:	2f dd       	sub	sp,-12
80009722:	d8 32       	popm	r0-r7,pc

80009724 <_fwalk>:
80009724:	d4 31       	pushm	r0-r7,lr
80009726:	30 05       	mov	r5,0
80009728:	16 91       	mov	r1,r11
8000972a:	f8 c7 ff 28 	sub	r7,r12,-216
8000972e:	0a 92       	mov	r2,r5
80009730:	fe b0 fc fe 	rcall	8000912c <__sfp_lock_acquire>
80009734:	3f f3       	mov	r3,-1
80009736:	c1 68       	rjmp	80009762 <_fwalk+0x3e>
80009738:	6e 26       	ld.w	r6,r7[0x8]
8000973a:	6e 14       	ld.w	r4,r7[0x4]
8000973c:	2f 46       	sub	r6,-12
8000973e:	c0 c8       	rjmp	80009756 <_fwalk+0x32>
80009740:	8c 08       	ld.sh	r8,r6[0x0]
80009742:	e4 08 19 00 	cp.h	r8,r2
80009746:	c0 70       	breq	80009754 <_fwalk+0x30>
80009748:	8c 18       	ld.sh	r8,r6[0x2]
8000974a:	e6 08 19 00 	cp.h	r8,r3
8000974e:	c0 30       	breq	80009754 <_fwalk+0x30>
80009750:	5d 11       	icall	r1
80009752:	18 45       	or	r5,r12
80009754:	2a 46       	sub	r6,-92
80009756:	20 14       	sub	r4,1
80009758:	ec cc 00 0c 	sub	r12,r6,12
8000975c:	58 04       	cp.w	r4,0
8000975e:	cf 14       	brge	80009740 <_fwalk+0x1c>
80009760:	6e 07       	ld.w	r7,r7[0x0]
80009762:	58 07       	cp.w	r7,0
80009764:	ce a1       	brne	80009738 <_fwalk+0x14>
80009766:	fe b0 fc e4 	rcall	8000912e <__sfp_lock_release>
8000976a:	0a 9c       	mov	r12,r5
8000976c:	d8 32       	popm	r0-r7,pc
8000976e:	d7 03       	nop

80009770 <_localeconv_r>:
80009770:	fe cc d4 f8 	sub	r12,pc,-11016
80009774:	5e fc       	retal	r12
80009776:	d7 03       	nop

80009778 <__smakebuf_r>:
80009778:	d4 21       	pushm	r4-r7,lr
8000977a:	20 fd       	sub	sp,60
8000977c:	96 68       	ld.sh	r8,r11[0xc]
8000977e:	16 97       	mov	r7,r11
80009780:	18 96       	mov	r6,r12
80009782:	e2 18 00 02 	andl	r8,0x2,COH
80009786:	c3 d1       	brne	80009800 <__smakebuf_r+0x88>
80009788:	96 7b       	ld.sh	r11,r11[0xe]
8000978a:	f0 0b 19 00 	cp.h	r11,r8
8000978e:	c0 55       	brlt	80009798 <__smakebuf_r+0x20>
80009790:	1a 9a       	mov	r10,sp
80009792:	e0 a0 04 81 	rcall	8000a094 <_fstat_r>
80009796:	c0 f4       	brge	800097b4 <__smakebuf_r+0x3c>
80009798:	8e 65       	ld.sh	r5,r7[0xc]
8000979a:	0a 98       	mov	r8,r5
8000979c:	ab b8       	sbr	r8,0xb
8000979e:	e2 15 00 80 	andl	r5,0x80,COH
800097a2:	ae 68       	st.h	r7[0xc],r8
800097a4:	30 04       	mov	r4,0
800097a6:	e0 68 04 00 	mov	r8,1024
800097aa:	f9 b5 01 40 	movne	r5,64
800097ae:	f0 05 17 00 	moveq	r5,r8
800097b2:	c1 c8       	rjmp	800097ea <__smakebuf_r+0x72>
800097b4:	40 18       	lddsp	r8,sp[0x4]
800097b6:	e2 18 f0 00 	andl	r8,0xf000,COH
800097ba:	e0 48 20 00 	cp.w	r8,8192
800097be:	5f 04       	sreq	r4
800097c0:	e0 48 80 00 	cp.w	r8,32768
800097c4:	c0 e1       	brne	800097e0 <__smakebuf_r+0x68>
800097c6:	6e b9       	ld.w	r9,r7[0x2c]
800097c8:	fe c8 f9 1c 	sub	r8,pc,-1764
800097cc:	10 39       	cp.w	r9,r8
800097ce:	c0 91       	brne	800097e0 <__smakebuf_r+0x68>
800097d0:	8e 68       	ld.sh	r8,r7[0xc]
800097d2:	e0 65 04 00 	mov	r5,1024
800097d6:	ab a8       	sbr	r8,0xa
800097d8:	ef 45 00 50 	st.w	r7[80],r5
800097dc:	ae 68       	st.h	r7[0xc],r8
800097de:	c0 68       	rjmp	800097ea <__smakebuf_r+0x72>
800097e0:	8e 68       	ld.sh	r8,r7[0xc]
800097e2:	e0 65 04 00 	mov	r5,1024
800097e6:	ab b8       	sbr	r8,0xb
800097e8:	ae 68       	st.h	r7[0xc],r8
800097ea:	0a 9b       	mov	r11,r5
800097ec:	0c 9c       	mov	r12,r6
800097ee:	fe b0 df 35 	rcall	80005658 <_malloc_r>
800097f2:	8e 68       	ld.sh	r8,r7[0xc]
800097f4:	c0 d1       	brne	8000980e <__smakebuf_r+0x96>
800097f6:	ed b8 00 09 	bld	r8,0x9
800097fa:	c1 b0       	breq	80009830 <__smakebuf_r+0xb8>
800097fc:	a1 b8       	sbr	r8,0x1
800097fe:	ae 68       	st.h	r7[0xc],r8
80009800:	ee c8 ff b9 	sub	r8,r7,-71
80009804:	8f 48       	st.w	r7[0x10],r8
80009806:	8f 08       	st.w	r7[0x0],r8
80009808:	30 18       	mov	r8,1
8000980a:	8f 58       	st.w	r7[0x14],r8
8000980c:	c1 28       	rjmp	80009830 <__smakebuf_r+0xb8>
8000980e:	a7 b8       	sbr	r8,0x7
80009810:	8f 4c       	st.w	r7[0x10],r12
80009812:	ae 68       	st.h	r7[0xc],r8
80009814:	8f 55       	st.w	r7[0x14],r5
80009816:	fe c8 06 e6 	sub	r8,pc,1766
8000981a:	8f 0c       	st.w	r7[0x0],r12
8000981c:	8d a8       	st.w	r6[0x28],r8
8000981e:	58 04       	cp.w	r4,0
80009820:	c0 80       	breq	80009830 <__smakebuf_r+0xb8>
80009822:	8e 7c       	ld.sh	r12,r7[0xe]
80009824:	fe b0 e3 94 	rcall	80005f4c <isatty>
80009828:	c0 40       	breq	80009830 <__smakebuf_r+0xb8>
8000982a:	8e 68       	ld.sh	r8,r7[0xc]
8000982c:	a1 a8       	sbr	r8,0x0
8000982e:	ae 68       	st.h	r7[0xc],r8
80009830:	2f 1d       	sub	sp,-60
80009832:	d8 22       	popm	r4-r7,pc

80009834 <memchr>:
80009834:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
80009838:	c0 68       	rjmp	80009844 <memchr+0x10>
8000983a:	20 1a       	sub	r10,1
8000983c:	19 88       	ld.ub	r8,r12[0x0]
8000983e:	16 38       	cp.w	r8,r11
80009840:	5e 0c       	reteq	r12
80009842:	2f fc       	sub	r12,-1
80009844:	58 0a       	cp.w	r10,0
80009846:	cf a1       	brne	8000983a <memchr+0x6>
80009848:	5e fa       	retal	r10

8000984a <memmove>:
8000984a:	d4 01       	pushm	lr
8000984c:	18 3b       	cp.w	r11,r12
8000984e:	c1 92       	brcc	80009880 <memmove+0x36>
80009850:	f6 0a 00 09 	add	r9,r11,r10
80009854:	12 3c       	cp.w	r12,r9
80009856:	c1 52       	brcc	80009880 <memmove+0x36>
80009858:	f8 0a 00 0b 	add	r11,r12,r10
8000985c:	30 08       	mov	r8,0
8000985e:	c0 68       	rjmp	8000986a <memmove+0x20>
80009860:	f2 08 07 0e 	ld.ub	lr,r9[r8]
80009864:	20 1a       	sub	r10,1
80009866:	f6 08 0b 0e 	st.b	r11[r8],lr
8000986a:	20 18       	sub	r8,1
8000986c:	58 0a       	cp.w	r10,0
8000986e:	cf 91       	brne	80009860 <memmove+0x16>
80009870:	d8 02       	popm	pc
80009872:	f6 08 07 09 	ld.ub	r9,r11[r8]
80009876:	20 1a       	sub	r10,1
80009878:	f8 08 0b 09 	st.b	r12[r8],r9
8000987c:	2f f8       	sub	r8,-1
8000987e:	c0 28       	rjmp	80009882 <memmove+0x38>
80009880:	30 08       	mov	r8,0
80009882:	58 0a       	cp.w	r10,0
80009884:	cf 71       	brne	80009872 <memmove+0x28>
80009886:	d8 02       	popm	pc

80009888 <__hi0bits>:
80009888:	18 98       	mov	r8,r12
8000988a:	e0 1c 00 00 	andl	r12,0x0
8000988e:	f0 09 15 10 	lsl	r9,r8,0x10
80009892:	58 0c       	cp.w	r12,0
80009894:	f2 08 17 00 	moveq	r8,r9
80009898:	f9 bc 00 10 	moveq	r12,16
8000989c:	f9 bc 01 00 	movne	r12,0
800098a0:	10 9a       	mov	r10,r8
800098a2:	f0 09 15 08 	lsl	r9,r8,0x8
800098a6:	e6 1a ff 00 	andh	r10,0xff00,COH
800098aa:	f7 bc 00 f8 	subeq	r12,-8
800098ae:	f2 08 17 00 	moveq	r8,r9
800098b2:	10 9a       	mov	r10,r8
800098b4:	f0 09 15 04 	lsl	r9,r8,0x4
800098b8:	e6 1a f0 00 	andh	r10,0xf000,COH
800098bc:	f7 bc 00 fc 	subeq	r12,-4
800098c0:	f2 08 17 00 	moveq	r8,r9
800098c4:	10 9a       	mov	r10,r8
800098c6:	f0 09 15 02 	lsl	r9,r8,0x2
800098ca:	e6 1a c0 00 	andh	r10,0xc000,COH
800098ce:	f7 bc 00 fe 	subeq	r12,-2
800098d2:	f2 08 17 00 	moveq	r8,r9
800098d6:	58 08       	cp.w	r8,0
800098d8:	5e 5c       	retlt	r12
800098da:	ed b8 00 1e 	bld	r8,0x1e
800098de:	f9 bc 01 20 	movne	r12,32
800098e2:	f7 bc 00 ff 	subeq	r12,-1
800098e6:	5e fc       	retal	r12

800098e8 <__lo0bits>:
800098e8:	18 99       	mov	r9,r12
800098ea:	78 08       	ld.w	r8,r12[0x0]
800098ec:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
800098f0:	c1 50       	breq	8000991a <__lo0bits+0x32>
800098f2:	ed b8 00 00 	bld	r8,0x0
800098f6:	c0 21       	brne	800098fa <__lo0bits+0x12>
800098f8:	5e fd       	retal	0
800098fa:	10 9b       	mov	r11,r8
800098fc:	f0 0a 16 01 	lsr	r10,r8,0x1
80009900:	e2 1b 00 02 	andl	r11,0x2,COH
80009904:	a3 88       	lsr	r8,0x2
80009906:	58 0b       	cp.w	r11,0
80009908:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000990c:	f9 bc 01 01 	movne	r12,1
80009910:	f3 f8 0a 00 	st.weq	r9[0x0],r8
80009914:	f9 bc 00 02 	moveq	r12,2
80009918:	5e fc       	retal	r12
8000991a:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000991e:	f0 0b 16 10 	lsr	r11,r8,0x10
80009922:	58 0a       	cp.w	r10,0
80009924:	f6 08 17 00 	moveq	r8,r11
80009928:	f9 bc 00 10 	moveq	r12,16
8000992c:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
80009930:	f0 0a 16 08 	lsr	r10,r8,0x8
80009934:	58 0b       	cp.w	r11,0
80009936:	f7 bc 00 f8 	subeq	r12,-8
8000993a:	f4 08 17 00 	moveq	r8,r10
8000993e:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
80009942:	f0 0a 16 04 	lsr	r10,r8,0x4
80009946:	58 0b       	cp.w	r11,0
80009948:	f7 bc 00 fc 	subeq	r12,-4
8000994c:	f4 08 17 00 	moveq	r8,r10
80009950:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
80009954:	f0 0a 16 02 	lsr	r10,r8,0x2
80009958:	58 0b       	cp.w	r11,0
8000995a:	f7 bc 00 fe 	subeq	r12,-2
8000995e:	f4 08 17 00 	moveq	r8,r10
80009962:	ed b8 00 00 	bld	r8,0x0
80009966:	c0 60       	breq	80009972 <__lo0bits+0x8a>
80009968:	a1 98       	lsr	r8,0x1
8000996a:	c0 31       	brne	80009970 <__lo0bits+0x88>
8000996c:	32 0c       	mov	r12,32
8000996e:	5e fc       	retal	r12
80009970:	2f fc       	sub	r12,-1
80009972:	93 08       	st.w	r9[0x0],r8
80009974:	5e fc       	retal	r12

80009976 <__mcmp>:
80009976:	d4 01       	pushm	lr
80009978:	18 98       	mov	r8,r12
8000997a:	76 49       	ld.w	r9,r11[0x10]
8000997c:	78 4c       	ld.w	r12,r12[0x10]
8000997e:	12 1c       	sub	r12,r9
80009980:	c1 31       	brne	800099a6 <__mcmp+0x30>
80009982:	2f b9       	sub	r9,-5
80009984:	a3 69       	lsl	r9,0x2
80009986:	12 0b       	add	r11,r9
80009988:	f0 09 00 09 	add	r9,r8,r9
8000998c:	2e c8       	sub	r8,-20
8000998e:	13 4e       	ld.w	lr,--r9
80009990:	17 4a       	ld.w	r10,--r11
80009992:	14 3e       	cp.w	lr,r10
80009994:	c0 60       	breq	800099a0 <__mcmp+0x2a>
80009996:	f9 bc 03 ff 	movlo	r12,-1
8000999a:	f9 bc 02 01 	movhs	r12,1
8000999e:	d8 02       	popm	pc
800099a0:	10 39       	cp.w	r9,r8
800099a2:	fe 9b ff f6 	brhi	8000998e <__mcmp+0x18>
800099a6:	d8 02       	popm	pc

800099a8 <_Bfree>:
800099a8:	d4 21       	pushm	r4-r7,lr
800099aa:	18 97       	mov	r7,r12
800099ac:	16 95       	mov	r5,r11
800099ae:	78 96       	ld.w	r6,r12[0x24]
800099b0:	58 06       	cp.w	r6,0
800099b2:	c0 91       	brne	800099c4 <_Bfree+0x1c>
800099b4:	31 0c       	mov	r12,16
800099b6:	fe b0 de 49 	rcall	80005648 <malloc>
800099ba:	99 36       	st.w	r12[0xc],r6
800099bc:	8f 9c       	st.w	r7[0x24],r12
800099be:	99 16       	st.w	r12[0x4],r6
800099c0:	99 26       	st.w	r12[0x8],r6
800099c2:	99 06       	st.w	r12[0x0],r6
800099c4:	58 05       	cp.w	r5,0
800099c6:	c0 90       	breq	800099d8 <_Bfree+0x30>
800099c8:	6a 19       	ld.w	r9,r5[0x4]
800099ca:	6e 98       	ld.w	r8,r7[0x24]
800099cc:	70 38       	ld.w	r8,r8[0xc]
800099ce:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
800099d2:	8b 0a       	st.w	r5[0x0],r10
800099d4:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
800099d8:	d8 22       	popm	r4-r7,pc
800099da:	d7 03       	nop

800099dc <_Balloc>:
800099dc:	d4 21       	pushm	r4-r7,lr
800099de:	18 97       	mov	r7,r12
800099e0:	16 96       	mov	r6,r11
800099e2:	78 95       	ld.w	r5,r12[0x24]
800099e4:	58 05       	cp.w	r5,0
800099e6:	c0 91       	brne	800099f8 <_Balloc+0x1c>
800099e8:	31 0c       	mov	r12,16
800099ea:	fe b0 de 2f 	rcall	80005648 <malloc>
800099ee:	99 35       	st.w	r12[0xc],r5
800099f0:	8f 9c       	st.w	r7[0x24],r12
800099f2:	99 15       	st.w	r12[0x4],r5
800099f4:	99 25       	st.w	r12[0x8],r5
800099f6:	99 05       	st.w	r12[0x0],r5
800099f8:	6e 95       	ld.w	r5,r7[0x24]
800099fa:	6a 38       	ld.w	r8,r5[0xc]
800099fc:	58 08       	cp.w	r8,0
800099fe:	c0 b1       	brne	80009a14 <_Balloc+0x38>
80009a00:	31 0a       	mov	r10,16
80009a02:	30 4b       	mov	r11,4
80009a04:	0e 9c       	mov	r12,r7
80009a06:	e0 a0 02 a7 	rcall	80009f54 <_calloc_r>
80009a0a:	8b 3c       	st.w	r5[0xc],r12
80009a0c:	6e 98       	ld.w	r8,r7[0x24]
80009a0e:	70 3c       	ld.w	r12,r8[0xc]
80009a10:	58 0c       	cp.w	r12,0
80009a12:	c1 b0       	breq	80009a48 <_Balloc+0x6c>
80009a14:	6e 98       	ld.w	r8,r7[0x24]
80009a16:	70 38       	ld.w	r8,r8[0xc]
80009a18:	f0 06 00 28 	add	r8,r8,r6<<0x2
80009a1c:	70 0c       	ld.w	r12,r8[0x0]
80009a1e:	58 0c       	cp.w	r12,0
80009a20:	c0 40       	breq	80009a28 <_Balloc+0x4c>
80009a22:	78 09       	ld.w	r9,r12[0x0]
80009a24:	91 09       	st.w	r8[0x0],r9
80009a26:	c0 e8       	rjmp	80009a42 <_Balloc+0x66>
80009a28:	0e 9c       	mov	r12,r7
80009a2a:	30 17       	mov	r7,1
80009a2c:	0e 9b       	mov	r11,r7
80009a2e:	ee 06 09 47 	lsl	r7,r7,r6
80009a32:	ee ca ff fb 	sub	r10,r7,-5
80009a36:	a3 6a       	lsl	r10,0x2
80009a38:	e0 a0 02 8e 	rcall	80009f54 <_calloc_r>
80009a3c:	c0 60       	breq	80009a48 <_Balloc+0x6c>
80009a3e:	99 16       	st.w	r12[0x4],r6
80009a40:	99 27       	st.w	r12[0x8],r7
80009a42:	30 08       	mov	r8,0
80009a44:	99 38       	st.w	r12[0xc],r8
80009a46:	99 48       	st.w	r12[0x10],r8
80009a48:	d8 22       	popm	r4-r7,pc
80009a4a:	d7 03       	nop

80009a4c <__d2b>:
80009a4c:	d4 31       	pushm	r0-r7,lr
80009a4e:	20 2d       	sub	sp,8
80009a50:	16 93       	mov	r3,r11
80009a52:	12 96       	mov	r6,r9
80009a54:	10 95       	mov	r5,r8
80009a56:	14 92       	mov	r2,r10
80009a58:	30 1b       	mov	r11,1
80009a5a:	cc 1f       	rcall	800099dc <_Balloc>
80009a5c:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
80009a60:	50 09       	stdsp	sp[0x0],r9
80009a62:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
80009a66:	b5 a9       	sbr	r9,0x14
80009a68:	f0 01 16 14 	lsr	r1,r8,0x14
80009a6c:	fb f9 1a 00 	st.wne	sp[0x0],r9
80009a70:	18 94       	mov	r4,r12
80009a72:	58 02       	cp.w	r2,0
80009a74:	c1 d0       	breq	80009aae <__d2b+0x62>
80009a76:	fa cc ff f8 	sub	r12,sp,-8
80009a7a:	18 d2       	st.w	--r12,r2
80009a7c:	c3 6f       	rcall	800098e8 <__lo0bits>
80009a7e:	40 18       	lddsp	r8,sp[0x4]
80009a80:	c0 d0       	breq	80009a9a <__d2b+0x4e>
80009a82:	40 09       	lddsp	r9,sp[0x0]
80009a84:	f8 0a 11 20 	rsub	r10,r12,32
80009a88:	f2 0a 09 4a 	lsl	r10,r9,r10
80009a8c:	f5 e8 10 08 	or	r8,r10,r8
80009a90:	89 58       	st.w	r4[0x14],r8
80009a92:	f2 0c 0a 49 	lsr	r9,r9,r12
80009a96:	50 09       	stdsp	sp[0x0],r9
80009a98:	c0 28       	rjmp	80009a9c <__d2b+0x50>
80009a9a:	89 58       	st.w	r4[0x14],r8
80009a9c:	40 08       	lddsp	r8,sp[0x0]
80009a9e:	58 08       	cp.w	r8,0
80009aa0:	f9 b3 01 02 	movne	r3,2
80009aa4:	f9 b3 00 01 	moveq	r3,1
80009aa8:	89 68       	st.w	r4[0x18],r8
80009aaa:	89 43       	st.w	r4[0x10],r3
80009aac:	c0 88       	rjmp	80009abc <__d2b+0x70>
80009aae:	1a 9c       	mov	r12,sp
80009ab0:	c1 cf       	rcall	800098e8 <__lo0bits>
80009ab2:	30 13       	mov	r3,1
80009ab4:	40 08       	lddsp	r8,sp[0x0]
80009ab6:	2e 0c       	sub	r12,-32
80009ab8:	89 43       	st.w	r4[0x10],r3
80009aba:	89 58       	st.w	r4[0x14],r8
80009abc:	58 01       	cp.w	r1,0
80009abe:	c0 90       	breq	80009ad0 <__d2b+0x84>
80009ac0:	e2 c1 04 33 	sub	r1,r1,1075
80009ac4:	18 01       	add	r1,r12
80009ac6:	8d 01       	st.w	r6[0x0],r1
80009ac8:	f8 0c 11 35 	rsub	r12,r12,53
80009acc:	8b 0c       	st.w	r5[0x0],r12
80009ace:	c0 c8       	rjmp	80009ae6 <__d2b+0x9a>
80009ad0:	e6 c8 ff fc 	sub	r8,r3,-4
80009ad4:	f8 cc 04 32 	sub	r12,r12,1074
80009ad8:	a5 73       	lsl	r3,0x5
80009ada:	8d 0c       	st.w	r6[0x0],r12
80009adc:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
80009ae0:	cd 4e       	rcall	80009888 <__hi0bits>
80009ae2:	18 13       	sub	r3,r12
80009ae4:	8b 03       	st.w	r5[0x0],r3
80009ae6:	08 9c       	mov	r12,r4
80009ae8:	2f ed       	sub	sp,-8
80009aea:	d8 32       	popm	r0-r7,pc

80009aec <__mdiff>:
80009aec:	d4 31       	pushm	r0-r7,lr
80009aee:	74 48       	ld.w	r8,r10[0x10]
80009af0:	76 45       	ld.w	r5,r11[0x10]
80009af2:	16 97       	mov	r7,r11
80009af4:	14 96       	mov	r6,r10
80009af6:	10 15       	sub	r5,r8
80009af8:	c1 31       	brne	80009b1e <__mdiff+0x32>
80009afa:	2f b8       	sub	r8,-5
80009afc:	ee ce ff ec 	sub	lr,r7,-20
80009b00:	a3 68       	lsl	r8,0x2
80009b02:	f4 08 00 0b 	add	r11,r10,r8
80009b06:	ee 08 00 08 	add	r8,r7,r8
80009b0a:	11 4a       	ld.w	r10,--r8
80009b0c:	17 49       	ld.w	r9,--r11
80009b0e:	12 3a       	cp.w	r10,r9
80009b10:	c0 30       	breq	80009b16 <__mdiff+0x2a>
80009b12:	c0 e2       	brcc	80009b2e <__mdiff+0x42>
80009b14:	c0 78       	rjmp	80009b22 <__mdiff+0x36>
80009b16:	1c 38       	cp.w	r8,lr
80009b18:	fe 9b ff f9 	brhi	80009b0a <__mdiff+0x1e>
80009b1c:	c4 98       	rjmp	80009bae <__mdiff+0xc2>
80009b1e:	58 05       	cp.w	r5,0
80009b20:	c0 64       	brge	80009b2c <__mdiff+0x40>
80009b22:	0e 98       	mov	r8,r7
80009b24:	30 15       	mov	r5,1
80009b26:	0c 97       	mov	r7,r6
80009b28:	10 96       	mov	r6,r8
80009b2a:	c0 28       	rjmp	80009b2e <__mdiff+0x42>
80009b2c:	30 05       	mov	r5,0
80009b2e:	6e 1b       	ld.w	r11,r7[0x4]
80009b30:	c5 6f       	rcall	800099dc <_Balloc>
80009b32:	6e 49       	ld.w	r9,r7[0x10]
80009b34:	6c 44       	ld.w	r4,r6[0x10]
80009b36:	99 35       	st.w	r12[0xc],r5
80009b38:	2f b4       	sub	r4,-5
80009b3a:	f2 c5 ff fb 	sub	r5,r9,-5
80009b3e:	ec 04 00 24 	add	r4,r6,r4<<0x2
80009b42:	ee 05 00 25 	add	r5,r7,r5<<0x2
80009b46:	2e c6       	sub	r6,-20
80009b48:	2e c7       	sub	r7,-20
80009b4a:	f8 c8 ff ec 	sub	r8,r12,-20
80009b4e:	30 0a       	mov	r10,0
80009b50:	0f 0e       	ld.w	lr,r7++
80009b52:	0d 0b       	ld.w	r11,r6++
80009b54:	fc 02 16 10 	lsr	r2,lr,0x10
80009b58:	f6 03 16 10 	lsr	r3,r11,0x10
80009b5c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80009b60:	e4 03 01 03 	sub	r3,r2,r3
80009b64:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009b68:	fc 0b 01 0b 	sub	r11,lr,r11
80009b6c:	f6 0a 00 0a 	add	r10,r11,r10
80009b70:	b0 1a       	st.h	r8[0x2],r10
80009b72:	b1 4a       	asr	r10,0x10
80009b74:	e6 0a 00 0a 	add	r10,r3,r10
80009b78:	b0 0a       	st.h	r8[0x0],r10
80009b7a:	2f c8       	sub	r8,-4
80009b7c:	b1 4a       	asr	r10,0x10
80009b7e:	08 36       	cp.w	r6,r4
80009b80:	ce 83       	brcs	80009b50 <__mdiff+0x64>
80009b82:	c0 d8       	rjmp	80009b9c <__mdiff+0xb0>
80009b84:	0f 0b       	ld.w	r11,r7++
80009b86:	f6 0e 16 10 	lsr	lr,r11,0x10
80009b8a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009b8e:	16 0a       	add	r10,r11
80009b90:	b0 1a       	st.h	r8[0x2],r10
80009b92:	b1 4a       	asr	r10,0x10
80009b94:	1c 0a       	add	r10,lr
80009b96:	b0 0a       	st.h	r8[0x0],r10
80009b98:	2f c8       	sub	r8,-4
80009b9a:	b1 4a       	asr	r10,0x10
80009b9c:	0a 37       	cp.w	r7,r5
80009b9e:	cf 33       	brcs	80009b84 <__mdiff+0x98>
80009ba0:	c0 28       	rjmp	80009ba4 <__mdiff+0xb8>
80009ba2:	20 19       	sub	r9,1
80009ba4:	11 4a       	ld.w	r10,--r8
80009ba6:	58 0a       	cp.w	r10,0
80009ba8:	cf d0       	breq	80009ba2 <__mdiff+0xb6>
80009baa:	99 49       	st.w	r12[0x10],r9
80009bac:	d8 32       	popm	r0-r7,pc
80009bae:	30 0b       	mov	r11,0
80009bb0:	c1 6f       	rcall	800099dc <_Balloc>
80009bb2:	30 18       	mov	r8,1
80009bb4:	99 48       	st.w	r12[0x10],r8
80009bb6:	30 08       	mov	r8,0
80009bb8:	99 58       	st.w	r12[0x14],r8
80009bba:	d8 32       	popm	r0-r7,pc

80009bbc <__lshift>:
80009bbc:	d4 31       	pushm	r0-r7,lr
80009bbe:	16 97       	mov	r7,r11
80009bc0:	76 46       	ld.w	r6,r11[0x10]
80009bc2:	f4 02 14 05 	asr	r2,r10,0x5
80009bc6:	2f f6       	sub	r6,-1
80009bc8:	14 93       	mov	r3,r10
80009bca:	18 94       	mov	r4,r12
80009bcc:	04 06       	add	r6,r2
80009bce:	76 1b       	ld.w	r11,r11[0x4]
80009bd0:	6e 28       	ld.w	r8,r7[0x8]
80009bd2:	c0 38       	rjmp	80009bd8 <__lshift+0x1c>
80009bd4:	2f fb       	sub	r11,-1
80009bd6:	a1 78       	lsl	r8,0x1
80009bd8:	10 36       	cp.w	r6,r8
80009bda:	fe 99 ff fd 	brgt	80009bd4 <__lshift+0x18>
80009bde:	08 9c       	mov	r12,r4
80009be0:	cf ee       	rcall	800099dc <_Balloc>
80009be2:	30 09       	mov	r9,0
80009be4:	18 95       	mov	r5,r12
80009be6:	f8 c8 ff ec 	sub	r8,r12,-20
80009bea:	12 9a       	mov	r10,r9
80009bec:	c0 38       	rjmp	80009bf2 <__lshift+0x36>
80009bee:	10 aa       	st.w	r8++,r10
80009bf0:	2f f9       	sub	r9,-1
80009bf2:	04 39       	cp.w	r9,r2
80009bf4:	cf d5       	brlt	80009bee <__lshift+0x32>
80009bf6:	6e 4b       	ld.w	r11,r7[0x10]
80009bf8:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
80009bfc:	2f bb       	sub	r11,-5
80009bfe:	ee c9 ff ec 	sub	r9,r7,-20
80009c02:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
80009c06:	58 03       	cp.w	r3,0
80009c08:	c1 30       	breq	80009c2e <__lshift+0x72>
80009c0a:	e6 0c 11 20 	rsub	r12,r3,32
80009c0e:	30 0a       	mov	r10,0
80009c10:	72 02       	ld.w	r2,r9[0x0]
80009c12:	e4 03 09 42 	lsl	r2,r2,r3
80009c16:	04 4a       	or	r10,r2
80009c18:	10 aa       	st.w	r8++,r10
80009c1a:	13 0a       	ld.w	r10,r9++
80009c1c:	f4 0c 0a 4a 	lsr	r10,r10,r12
80009c20:	16 39       	cp.w	r9,r11
80009c22:	cf 73       	brcs	80009c10 <__lshift+0x54>
80009c24:	91 0a       	st.w	r8[0x0],r10
80009c26:	58 0a       	cp.w	r10,0
80009c28:	c0 70       	breq	80009c36 <__lshift+0x7a>
80009c2a:	2f f6       	sub	r6,-1
80009c2c:	c0 58       	rjmp	80009c36 <__lshift+0x7a>
80009c2e:	13 0a       	ld.w	r10,r9++
80009c30:	10 aa       	st.w	r8++,r10
80009c32:	16 39       	cp.w	r9,r11
80009c34:	cf d3       	brcs	80009c2e <__lshift+0x72>
80009c36:	08 9c       	mov	r12,r4
80009c38:	20 16       	sub	r6,1
80009c3a:	0e 9b       	mov	r11,r7
80009c3c:	8b 46       	st.w	r5[0x10],r6
80009c3e:	cb 5e       	rcall	800099a8 <_Bfree>
80009c40:	0a 9c       	mov	r12,r5
80009c42:	d8 32       	popm	r0-r7,pc

80009c44 <__multiply>:
80009c44:	d4 31       	pushm	r0-r7,lr
80009c46:	20 2d       	sub	sp,8
80009c48:	76 49       	ld.w	r9,r11[0x10]
80009c4a:	74 48       	ld.w	r8,r10[0x10]
80009c4c:	16 96       	mov	r6,r11
80009c4e:	14 95       	mov	r5,r10
80009c50:	10 39       	cp.w	r9,r8
80009c52:	ec 08 17 50 	movlt	r8,r6
80009c56:	ea 06 17 50 	movlt	r6,r5
80009c5a:	f0 05 17 50 	movlt	r5,r8
80009c5e:	6c 28       	ld.w	r8,r6[0x8]
80009c60:	76 43       	ld.w	r3,r11[0x10]
80009c62:	74 42       	ld.w	r2,r10[0x10]
80009c64:	76 1b       	ld.w	r11,r11[0x4]
80009c66:	e4 03 00 07 	add	r7,r2,r3
80009c6a:	10 37       	cp.w	r7,r8
80009c6c:	f7 bb 09 ff 	subgt	r11,-1
80009c70:	cb 6e       	rcall	800099dc <_Balloc>
80009c72:	ee c4 ff fb 	sub	r4,r7,-5
80009c76:	f8 c9 ff ec 	sub	r9,r12,-20
80009c7a:	f8 04 00 24 	add	r4,r12,r4<<0x2
80009c7e:	30 0a       	mov	r10,0
80009c80:	12 98       	mov	r8,r9
80009c82:	c0 28       	rjmp	80009c86 <__multiply+0x42>
80009c84:	10 aa       	st.w	r8++,r10
80009c86:	08 38       	cp.w	r8,r4
80009c88:	cf e3       	brcs	80009c84 <__multiply+0x40>
80009c8a:	2f b3       	sub	r3,-5
80009c8c:	2f b2       	sub	r2,-5
80009c8e:	ec 03 00 23 	add	r3,r6,r3<<0x2
80009c92:	ea 02 00 22 	add	r2,r5,r2<<0x2
80009c96:	ec cb ff ec 	sub	r11,r6,-20
80009c9a:	50 12       	stdsp	sp[0x4],r2
80009c9c:	ea ca ff ec 	sub	r10,r5,-20
80009ca0:	c4 48       	rjmp	80009d28 <__multiply+0xe4>
80009ca2:	94 95       	ld.uh	r5,r10[0x2]
80009ca4:	58 05       	cp.w	r5,0
80009ca6:	c2 00       	breq	80009ce6 <__multiply+0xa2>
80009ca8:	12 98       	mov	r8,r9
80009caa:	16 96       	mov	r6,r11
80009cac:	30 0e       	mov	lr,0
80009cae:	50 09       	stdsp	sp[0x0],r9
80009cb0:	0d 02       	ld.w	r2,r6++
80009cb2:	e4 00 16 10 	lsr	r0,r2,0x10
80009cb6:	70 01       	ld.w	r1,r8[0x0]
80009cb8:	70 09       	ld.w	r9,r8[0x0]
80009cba:	b1 81       	lsr	r1,0x10
80009cbc:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
80009cc0:	e0 05 03 41 	mac	r1,r0,r5
80009cc4:	ab 32       	mul	r2,r5
80009cc6:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
80009cca:	00 02       	add	r2,r0
80009ccc:	e4 0e 00 0e 	add	lr,r2,lr
80009cd0:	b0 1e       	st.h	r8[0x2],lr
80009cd2:	b1 8e       	lsr	lr,0x10
80009cd4:	1c 01       	add	r1,lr
80009cd6:	b0 01       	st.h	r8[0x0],r1
80009cd8:	e2 0e 16 10 	lsr	lr,r1,0x10
80009cdc:	2f c8       	sub	r8,-4
80009cde:	06 36       	cp.w	r6,r3
80009ce0:	ce 83       	brcs	80009cb0 <__multiply+0x6c>
80009ce2:	40 09       	lddsp	r9,sp[0x0]
80009ce4:	91 0e       	st.w	r8[0x0],lr
80009ce6:	94 86       	ld.uh	r6,r10[0x0]
80009ce8:	58 06       	cp.w	r6,0
80009cea:	c1 d0       	breq	80009d24 <__multiply+0xe0>
80009cec:	72 02       	ld.w	r2,r9[0x0]
80009cee:	12 98       	mov	r8,r9
80009cf0:	16 9e       	mov	lr,r11
80009cf2:	30 05       	mov	r5,0
80009cf4:	b0 12       	st.h	r8[0x2],r2
80009cf6:	1d 01       	ld.w	r1,lr++
80009cf8:	90 82       	ld.uh	r2,r8[0x0]
80009cfa:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
80009cfe:	ad 30       	mul	r0,r6
80009d00:	e0 02 00 02 	add	r2,r0,r2
80009d04:	e4 05 00 05 	add	r5,r2,r5
80009d08:	b0 05       	st.h	r8[0x0],r5
80009d0a:	b1 85       	lsr	r5,0x10
80009d0c:	b1 81       	lsr	r1,0x10
80009d0e:	2f c8       	sub	r8,-4
80009d10:	ad 31       	mul	r1,r6
80009d12:	90 92       	ld.uh	r2,r8[0x2]
80009d14:	e2 02 00 02 	add	r2,r1,r2
80009d18:	0a 02       	add	r2,r5
80009d1a:	e4 05 16 10 	lsr	r5,r2,0x10
80009d1e:	06 3e       	cp.w	lr,r3
80009d20:	ce a3       	brcs	80009cf4 <__multiply+0xb0>
80009d22:	91 02       	st.w	r8[0x0],r2
80009d24:	2f ca       	sub	r10,-4
80009d26:	2f c9       	sub	r9,-4
80009d28:	40 18       	lddsp	r8,sp[0x4]
80009d2a:	10 3a       	cp.w	r10,r8
80009d2c:	cb b3       	brcs	80009ca2 <__multiply+0x5e>
80009d2e:	c0 28       	rjmp	80009d32 <__multiply+0xee>
80009d30:	20 17       	sub	r7,1
80009d32:	58 07       	cp.w	r7,0
80009d34:	e0 8a 00 05 	brle	80009d3e <__multiply+0xfa>
80009d38:	09 48       	ld.w	r8,--r4
80009d3a:	58 08       	cp.w	r8,0
80009d3c:	cf a0       	breq	80009d30 <__multiply+0xec>
80009d3e:	99 47       	st.w	r12[0x10],r7
80009d40:	2f ed       	sub	sp,-8
80009d42:	d8 32       	popm	r0-r7,pc

80009d44 <__i2b>:
80009d44:	d4 21       	pushm	r4-r7,lr
80009d46:	16 97       	mov	r7,r11
80009d48:	30 1b       	mov	r11,1
80009d4a:	c4 9e       	rcall	800099dc <_Balloc>
80009d4c:	30 19       	mov	r9,1
80009d4e:	99 57       	st.w	r12[0x14],r7
80009d50:	99 49       	st.w	r12[0x10],r9
80009d52:	d8 22       	popm	r4-r7,pc

80009d54 <__multadd>:
80009d54:	d4 31       	pushm	r0-r7,lr
80009d56:	30 08       	mov	r8,0
80009d58:	12 95       	mov	r5,r9
80009d5a:	16 97       	mov	r7,r11
80009d5c:	18 96       	mov	r6,r12
80009d5e:	76 44       	ld.w	r4,r11[0x10]
80009d60:	f6 c9 ff ec 	sub	r9,r11,-20
80009d64:	72 0b       	ld.w	r11,r9[0x0]
80009d66:	f6 0c 16 10 	lsr	r12,r11,0x10
80009d6a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009d6e:	f4 0c 02 4c 	mul	r12,r10,r12
80009d72:	f4 0b 03 45 	mac	r5,r10,r11
80009d76:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
80009d7a:	b1 85       	lsr	r5,0x10
80009d7c:	18 05       	add	r5,r12
80009d7e:	ea 0c 15 10 	lsl	r12,r5,0x10
80009d82:	f8 0b 00 0b 	add	r11,r12,r11
80009d86:	12 ab       	st.w	r9++,r11
80009d88:	2f f8       	sub	r8,-1
80009d8a:	b1 85       	lsr	r5,0x10
80009d8c:	08 38       	cp.w	r8,r4
80009d8e:	ce b5       	brlt	80009d64 <__multadd+0x10>
80009d90:	58 05       	cp.w	r5,0
80009d92:	c1 c0       	breq	80009dca <__multadd+0x76>
80009d94:	6e 28       	ld.w	r8,r7[0x8]
80009d96:	10 34       	cp.w	r4,r8
80009d98:	c1 35       	brlt	80009dbe <__multadd+0x6a>
80009d9a:	6e 1b       	ld.w	r11,r7[0x4]
80009d9c:	0c 9c       	mov	r12,r6
80009d9e:	2f fb       	sub	r11,-1
80009da0:	c1 ee       	rcall	800099dc <_Balloc>
80009da2:	6e 4a       	ld.w	r10,r7[0x10]
80009da4:	ee cb ff f4 	sub	r11,r7,-12
80009da8:	18 93       	mov	r3,r12
80009daa:	2f ea       	sub	r10,-2
80009dac:	2f 4c       	sub	r12,-12
80009dae:	a3 6a       	lsl	r10,0x2
80009db0:	fe b0 de 70 	rcall	80005a90 <memcpy>
80009db4:	0e 9b       	mov	r11,r7
80009db6:	0c 9c       	mov	r12,r6
80009db8:	fe b0 fd f8 	rcall	800099a8 <_Bfree>
80009dbc:	06 97       	mov	r7,r3
80009dbe:	e8 c8 ff ff 	sub	r8,r4,-1
80009dc2:	2f b4       	sub	r4,-5
80009dc4:	8f 48       	st.w	r7[0x10],r8
80009dc6:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
80009dca:	0e 9c       	mov	r12,r7
80009dcc:	d8 32       	popm	r0-r7,pc
80009dce:	d7 03       	nop

80009dd0 <__pow5mult>:
80009dd0:	d4 31       	pushm	r0-r7,lr
80009dd2:	14 96       	mov	r6,r10
80009dd4:	18 97       	mov	r7,r12
80009dd6:	16 94       	mov	r4,r11
80009dd8:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
80009ddc:	c0 90       	breq	80009dee <__pow5mult+0x1e>
80009dde:	20 18       	sub	r8,1
80009de0:	fe c9 db 2c 	sub	r9,pc,-9428
80009de4:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
80009de8:	30 09       	mov	r9,0
80009dea:	cb 5f       	rcall	80009d54 <__multadd>
80009dec:	18 94       	mov	r4,r12
80009dee:	a3 46       	asr	r6,0x2
80009df0:	c3 40       	breq	80009e58 <__pow5mult+0x88>
80009df2:	6e 95       	ld.w	r5,r7[0x24]
80009df4:	58 05       	cp.w	r5,0
80009df6:	c0 91       	brne	80009e08 <__pow5mult+0x38>
80009df8:	31 0c       	mov	r12,16
80009dfa:	fe b0 dc 27 	rcall	80005648 <malloc>
80009dfe:	99 35       	st.w	r12[0xc],r5
80009e00:	8f 9c       	st.w	r7[0x24],r12
80009e02:	99 15       	st.w	r12[0x4],r5
80009e04:	99 25       	st.w	r12[0x8],r5
80009e06:	99 05       	st.w	r12[0x0],r5
80009e08:	6e 93       	ld.w	r3,r7[0x24]
80009e0a:	66 25       	ld.w	r5,r3[0x8]
80009e0c:	58 05       	cp.w	r5,0
80009e0e:	c0 c1       	brne	80009e26 <__pow5mult+0x56>
80009e10:	e0 6b 02 71 	mov	r11,625
80009e14:	0e 9c       	mov	r12,r7
80009e16:	c9 7f       	rcall	80009d44 <__i2b>
80009e18:	87 2c       	st.w	r3[0x8],r12
80009e1a:	30 08       	mov	r8,0
80009e1c:	18 95       	mov	r5,r12
80009e1e:	99 08       	st.w	r12[0x0],r8
80009e20:	c0 38       	rjmp	80009e26 <__pow5mult+0x56>
80009e22:	06 9c       	mov	r12,r3
80009e24:	18 95       	mov	r5,r12
80009e26:	ed b6 00 00 	bld	r6,0x0
80009e2a:	c0 b1       	brne	80009e40 <__pow5mult+0x70>
80009e2c:	08 9b       	mov	r11,r4
80009e2e:	0a 9a       	mov	r10,r5
80009e30:	0e 9c       	mov	r12,r7
80009e32:	c0 9f       	rcall	80009c44 <__multiply>
80009e34:	08 9b       	mov	r11,r4
80009e36:	18 93       	mov	r3,r12
80009e38:	0e 9c       	mov	r12,r7
80009e3a:	06 94       	mov	r4,r3
80009e3c:	fe b0 fd b6 	rcall	800099a8 <_Bfree>
80009e40:	a1 56       	asr	r6,0x1
80009e42:	c0 b0       	breq	80009e58 <__pow5mult+0x88>
80009e44:	6a 03       	ld.w	r3,r5[0x0]
80009e46:	58 03       	cp.w	r3,0
80009e48:	ce d1       	brne	80009e22 <__pow5mult+0x52>
80009e4a:	0a 9a       	mov	r10,r5
80009e4c:	0a 9b       	mov	r11,r5
80009e4e:	0e 9c       	mov	r12,r7
80009e50:	cf ae       	rcall	80009c44 <__multiply>
80009e52:	8b 0c       	st.w	r5[0x0],r12
80009e54:	99 03       	st.w	r12[0x0],r3
80009e56:	ce 7b       	rjmp	80009e24 <__pow5mult+0x54>
80009e58:	08 9c       	mov	r12,r4
80009e5a:	d8 32       	popm	r0-r7,pc

80009e5c <__isinfd>:
80009e5c:	14 98       	mov	r8,r10
80009e5e:	fc 19 7f f0 	movh	r9,0x7ff0
80009e62:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
80009e66:	f0 0b 11 00 	rsub	r11,r8,0
80009e6a:	f7 e8 10 08 	or	r8,r11,r8
80009e6e:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
80009e72:	f2 08 01 08 	sub	r8,r9,r8
80009e76:	f0 0c 11 00 	rsub	r12,r8,0
80009e7a:	f9 e8 10 08 	or	r8,r12,r8
80009e7e:	f0 0c 14 1f 	asr	r12,r8,0x1f
80009e82:	2f fc       	sub	r12,-1
80009e84:	5e fc       	retal	r12

80009e86 <__isnand>:
80009e86:	14 98       	mov	r8,r10
80009e88:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
80009e8c:	f0 0c 11 00 	rsub	r12,r8,0
80009e90:	10 4c       	or	r12,r8
80009e92:	fc 18 7f f0 	movh	r8,0x7ff0
80009e96:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
80009e9a:	f0 0c 01 0c 	sub	r12,r8,r12
80009e9e:	bf 9c       	lsr	r12,0x1f
80009ea0:	5e fc       	retal	r12
80009ea2:	d7 03       	nop

80009ea4 <__sclose>:
80009ea4:	d4 01       	pushm	lr
80009ea6:	96 7b       	ld.sh	r11,r11[0xe]
80009ea8:	c8 2c       	rcall	80009fac <_close_r>
80009eaa:	d8 02       	popm	pc

80009eac <__sseek>:
80009eac:	d4 21       	pushm	r4-r7,lr
80009eae:	16 97       	mov	r7,r11
80009eb0:	96 7b       	ld.sh	r11,r11[0xe]
80009eb2:	c0 3d       	rcall	8000a0b8 <_lseek_r>
80009eb4:	8e 68       	ld.sh	r8,r7[0xc]
80009eb6:	10 99       	mov	r9,r8
80009eb8:	ad c8       	cbr	r8,0xc
80009eba:	ad a9       	sbr	r9,0xc
80009ebc:	5b fc       	cp.w	r12,-1
80009ebe:	ef f8 0c 06 	st.heq	r7[0xc],r8
80009ec2:	ef f9 1c 06 	st.hne	r7[0xc],r9
80009ec6:	ef fc 1a 15 	st.wne	r7[0x54],r12
80009eca:	d8 22       	popm	r4-r7,pc

80009ecc <__swrite>:
80009ecc:	d4 21       	pushm	r4-r7,lr
80009ece:	96 68       	ld.sh	r8,r11[0xc]
80009ed0:	16 97       	mov	r7,r11
80009ed2:	14 95       	mov	r5,r10
80009ed4:	12 94       	mov	r4,r9
80009ed6:	e2 18 01 00 	andl	r8,0x100,COH
80009eda:	18 96       	mov	r6,r12
80009edc:	c0 50       	breq	80009ee6 <__swrite+0x1a>
80009ede:	30 29       	mov	r9,2
80009ee0:	30 0a       	mov	r10,0
80009ee2:	96 7b       	ld.sh	r11,r11[0xe]
80009ee4:	ce ac       	rcall	8000a0b8 <_lseek_r>
80009ee6:	8e 68       	ld.sh	r8,r7[0xc]
80009ee8:	ad c8       	cbr	r8,0xc
80009eea:	08 99       	mov	r9,r4
80009eec:	0a 9a       	mov	r10,r5
80009eee:	8e 7b       	ld.sh	r11,r7[0xe]
80009ef0:	0c 9c       	mov	r12,r6
80009ef2:	ae 68       	st.h	r7[0xc],r8
80009ef4:	c1 cc       	rcall	80009f2c <_write_r>
80009ef6:	d8 22       	popm	r4-r7,pc

80009ef8 <__sread>:
80009ef8:	d4 21       	pushm	r4-r7,lr
80009efa:	16 97       	mov	r7,r11
80009efc:	96 7b       	ld.sh	r11,r11[0xe]
80009efe:	cf 1c       	rcall	8000a0e0 <_read_r>
80009f00:	c0 65       	brlt	80009f0c <__sread+0x14>
80009f02:	6f 58       	ld.w	r8,r7[0x54]
80009f04:	18 08       	add	r8,r12
80009f06:	ef 48 00 54 	st.w	r7[84],r8
80009f0a:	d8 22       	popm	r4-r7,pc
80009f0c:	8e 68       	ld.sh	r8,r7[0xc]
80009f0e:	ad c8       	cbr	r8,0xc
80009f10:	ae 68       	st.h	r7[0xc],r8
80009f12:	d8 22       	popm	r4-r7,pc

80009f14 <strlen>:
80009f14:	30 09       	mov	r9,0
80009f16:	18 98       	mov	r8,r12
80009f18:	c0 28       	rjmp	80009f1c <strlen+0x8>
80009f1a:	2f f8       	sub	r8,-1
80009f1c:	11 8a       	ld.ub	r10,r8[0x0]
80009f1e:	f2 0a 18 00 	cp.b	r10,r9
80009f22:	cf c1       	brne	80009f1a <strlen+0x6>
80009f24:	f0 0c 01 0c 	sub	r12,r8,r12
80009f28:	5e fc       	retal	r12
80009f2a:	d7 03       	nop

80009f2c <_write_r>:
80009f2c:	d4 21       	pushm	r4-r7,lr
80009f2e:	16 98       	mov	r8,r11
80009f30:	18 97       	mov	r7,r12
80009f32:	10 9c       	mov	r12,r8
80009f34:	30 08       	mov	r8,0
80009f36:	14 9b       	mov	r11,r10
80009f38:	e0 66 51 48 	mov	r6,20808
80009f3c:	12 9a       	mov	r10,r9
80009f3e:	8d 08       	st.w	r6[0x0],r8
80009f40:	fe b0 d1 98 	rcall	80004270 <_write>
80009f44:	5b fc       	cp.w	r12,-1
80009f46:	c0 51       	brne	80009f50 <_write_r+0x24>
80009f48:	6c 08       	ld.w	r8,r6[0x0]
80009f4a:	58 08       	cp.w	r8,0
80009f4c:	ef f8 1a 03 	st.wne	r7[0xc],r8
80009f50:	d8 22       	popm	r4-r7,pc
80009f52:	d7 03       	nop

80009f54 <_calloc_r>:
80009f54:	d4 21       	pushm	r4-r7,lr
80009f56:	f4 0b 02 4b 	mul	r11,r10,r11
80009f5a:	fe b0 db 7f 	rcall	80005658 <_malloc_r>
80009f5e:	18 97       	mov	r7,r12
80009f60:	c2 30       	breq	80009fa6 <_calloc_r+0x52>
80009f62:	f8 fa ff fc 	ld.w	r10,r12[-4]
80009f66:	e0 1a ff fc 	andl	r10,0xfffc
80009f6a:	20 4a       	sub	r10,4
80009f6c:	e0 4a 00 24 	cp.w	r10,36
80009f70:	e0 8b 00 18 	brhi	80009fa0 <_calloc_r+0x4c>
80009f74:	18 98       	mov	r8,r12
80009f76:	59 3a       	cp.w	r10,19
80009f78:	e0 88 00 0f 	brls	80009f96 <_calloc_r+0x42>
80009f7c:	30 09       	mov	r9,0
80009f7e:	10 a9       	st.w	r8++,r9
80009f80:	10 a9       	st.w	r8++,r9
80009f82:	59 ba       	cp.w	r10,27
80009f84:	e0 88 00 09 	brls	80009f96 <_calloc_r+0x42>
80009f88:	10 a9       	st.w	r8++,r9
80009f8a:	10 a9       	st.w	r8++,r9
80009f8c:	e0 4a 00 24 	cp.w	r10,36
80009f90:	c0 31       	brne	80009f96 <_calloc_r+0x42>
80009f92:	10 a9       	st.w	r8++,r9
80009f94:	10 a9       	st.w	r8++,r9
80009f96:	30 09       	mov	r9,0
80009f98:	10 a9       	st.w	r8++,r9
80009f9a:	91 19       	st.w	r8[0x4],r9
80009f9c:	91 09       	st.w	r8[0x0],r9
80009f9e:	c0 48       	rjmp	80009fa6 <_calloc_r+0x52>
80009fa0:	30 0b       	mov	r11,0
80009fa2:	fe b0 de 1b 	rcall	80005bd8 <memset>
80009fa6:	0e 9c       	mov	r12,r7
80009fa8:	d8 22       	popm	r4-r7,pc
80009faa:	d7 03       	nop

80009fac <_close_r>:
80009fac:	d4 21       	pushm	r4-r7,lr
80009fae:	30 08       	mov	r8,0
80009fb0:	18 97       	mov	r7,r12
80009fb2:	e0 66 51 48 	mov	r6,20808
80009fb6:	16 9c       	mov	r12,r11
80009fb8:	8d 08       	st.w	r6[0x0],r8
80009fba:	fe b0 df b5 	rcall	80005f24 <_close>
80009fbe:	5b fc       	cp.w	r12,-1
80009fc0:	c0 51       	brne	80009fca <_close_r+0x1e>
80009fc2:	6c 08       	ld.w	r8,r6[0x0]
80009fc4:	58 08       	cp.w	r8,0
80009fc6:	ef f8 1a 03 	st.wne	r7[0xc],r8
80009fca:	d8 22       	popm	r4-r7,pc

80009fcc <_fclose_r>:
80009fcc:	d4 21       	pushm	r4-r7,lr
80009fce:	18 96       	mov	r6,r12
80009fd0:	16 97       	mov	r7,r11
80009fd2:	58 0b       	cp.w	r11,0
80009fd4:	c0 31       	brne	80009fda <_fclose_r+0xe>
80009fd6:	16 95       	mov	r5,r11
80009fd8:	c5 38       	rjmp	8000a07e <_fclose_r+0xb2>
80009fda:	fe b0 f8 a9 	rcall	8000912c <__sfp_lock_acquire>
80009fde:	58 06       	cp.w	r6,0
80009fe0:	c0 70       	breq	80009fee <_fclose_r+0x22>
80009fe2:	6c 68       	ld.w	r8,r6[0x18]
80009fe4:	58 08       	cp.w	r8,0
80009fe6:	c0 41       	brne	80009fee <_fclose_r+0x22>
80009fe8:	0c 9c       	mov	r12,r6
80009fea:	fe b0 f8 f3 	rcall	800091d0 <__sinit>
80009fee:	fe c8 dd de 	sub	r8,pc,-8738
80009ff2:	10 37       	cp.w	r7,r8
80009ff4:	c0 31       	brne	80009ffa <_fclose_r+0x2e>
80009ff6:	6c 07       	ld.w	r7,r6[0x0]
80009ff8:	c0 c8       	rjmp	8000a010 <_fclose_r+0x44>
80009ffa:	fe c8 dd ca 	sub	r8,pc,-8758
80009ffe:	10 37       	cp.w	r7,r8
8000a000:	c0 31       	brne	8000a006 <_fclose_r+0x3a>
8000a002:	6c 17       	ld.w	r7,r6[0x4]
8000a004:	c0 68       	rjmp	8000a010 <_fclose_r+0x44>
8000a006:	fe c8 dd b6 	sub	r8,pc,-8778
8000a00a:	10 37       	cp.w	r7,r8
8000a00c:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000a010:	8e 69       	ld.sh	r9,r7[0xc]
8000a012:	30 08       	mov	r8,0
8000a014:	f0 09 19 00 	cp.h	r9,r8
8000a018:	c0 51       	brne	8000a022 <_fclose_r+0x56>
8000a01a:	fe b0 f8 8a 	rcall	8000912e <__sfp_lock_release>
8000a01e:	30 05       	mov	r5,0
8000a020:	c2 f8       	rjmp	8000a07e <_fclose_r+0xb2>
8000a022:	0e 9b       	mov	r11,r7
8000a024:	0c 9c       	mov	r12,r6
8000a026:	fe b0 f7 fd 	rcall	80009020 <_fflush_r>
8000a02a:	6e c8       	ld.w	r8,r7[0x30]
8000a02c:	18 95       	mov	r5,r12
8000a02e:	58 08       	cp.w	r8,0
8000a030:	c0 60       	breq	8000a03c <_fclose_r+0x70>
8000a032:	6e 8b       	ld.w	r11,r7[0x20]
8000a034:	0c 9c       	mov	r12,r6
8000a036:	5d 18       	icall	r8
8000a038:	f9 b5 05 ff 	movlt	r5,-1
8000a03c:	8e 68       	ld.sh	r8,r7[0xc]
8000a03e:	ed b8 00 07 	bld	r8,0x7
8000a042:	c0 51       	brne	8000a04c <_fclose_r+0x80>
8000a044:	6e 4b       	ld.w	r11,r7[0x10]
8000a046:	0c 9c       	mov	r12,r6
8000a048:	fe b0 f9 5e 	rcall	80009304 <_free_r>
8000a04c:	6e db       	ld.w	r11,r7[0x34]
8000a04e:	58 0b       	cp.w	r11,0
8000a050:	c0 a0       	breq	8000a064 <_fclose_r+0x98>
8000a052:	ee c8 ff bc 	sub	r8,r7,-68
8000a056:	10 3b       	cp.w	r11,r8
8000a058:	c0 40       	breq	8000a060 <_fclose_r+0x94>
8000a05a:	0c 9c       	mov	r12,r6
8000a05c:	fe b0 f9 54 	rcall	80009304 <_free_r>
8000a060:	30 08       	mov	r8,0
8000a062:	8f d8       	st.w	r7[0x34],r8
8000a064:	6f 2b       	ld.w	r11,r7[0x48]
8000a066:	58 0b       	cp.w	r11,0
8000a068:	c0 70       	breq	8000a076 <_fclose_r+0xaa>
8000a06a:	0c 9c       	mov	r12,r6
8000a06c:	fe b0 f9 4c 	rcall	80009304 <_free_r>
8000a070:	30 08       	mov	r8,0
8000a072:	ef 48 00 48 	st.w	r7[72],r8
8000a076:	30 08       	mov	r8,0
8000a078:	ae 68       	st.h	r7[0xc],r8
8000a07a:	fe b0 f8 5a 	rcall	8000912e <__sfp_lock_release>
8000a07e:	0a 9c       	mov	r12,r5
8000a080:	d8 22       	popm	r4-r7,pc
8000a082:	d7 03       	nop

8000a084 <fclose>:
8000a084:	d4 01       	pushm	lr
8000a086:	e0 68 0a 40 	mov	r8,2624
8000a08a:	18 9b       	mov	r11,r12
8000a08c:	70 0c       	ld.w	r12,r8[0x0]
8000a08e:	c9 ff       	rcall	80009fcc <_fclose_r>
8000a090:	d8 02       	popm	pc
8000a092:	d7 03       	nop

8000a094 <_fstat_r>:
8000a094:	d4 21       	pushm	r4-r7,lr
8000a096:	16 98       	mov	r8,r11
8000a098:	18 97       	mov	r7,r12
8000a09a:	10 9c       	mov	r12,r8
8000a09c:	30 08       	mov	r8,0
8000a09e:	e0 66 51 48 	mov	r6,20808
8000a0a2:	14 9b       	mov	r11,r10
8000a0a4:	8d 08       	st.w	r6[0x0],r8
8000a0a6:	fe b0 df 67 	rcall	80005f74 <_fstat>
8000a0aa:	5b fc       	cp.w	r12,-1
8000a0ac:	c0 51       	brne	8000a0b6 <_fstat_r+0x22>
8000a0ae:	6c 08       	ld.w	r8,r6[0x0]
8000a0b0:	58 08       	cp.w	r8,0
8000a0b2:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000a0b6:	d8 22       	popm	r4-r7,pc

8000a0b8 <_lseek_r>:
8000a0b8:	d4 21       	pushm	r4-r7,lr
8000a0ba:	16 98       	mov	r8,r11
8000a0bc:	18 97       	mov	r7,r12
8000a0be:	10 9c       	mov	r12,r8
8000a0c0:	30 08       	mov	r8,0
8000a0c2:	14 9b       	mov	r11,r10
8000a0c4:	e0 66 51 48 	mov	r6,20808
8000a0c8:	12 9a       	mov	r10,r9
8000a0ca:	8d 08       	st.w	r6[0x0],r8
8000a0cc:	fe b0 df 36 	rcall	80005f38 <_lseek>
8000a0d0:	5b fc       	cp.w	r12,-1
8000a0d2:	c0 51       	brne	8000a0dc <_lseek_r+0x24>
8000a0d4:	6c 08       	ld.w	r8,r6[0x0]
8000a0d6:	58 08       	cp.w	r8,0
8000a0d8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000a0dc:	d8 22       	popm	r4-r7,pc
8000a0de:	d7 03       	nop

8000a0e0 <_read_r>:
8000a0e0:	d4 21       	pushm	r4-r7,lr
8000a0e2:	16 98       	mov	r8,r11
8000a0e4:	18 97       	mov	r7,r12
8000a0e6:	10 9c       	mov	r12,r8
8000a0e8:	30 08       	mov	r8,0
8000a0ea:	14 9b       	mov	r11,r10
8000a0ec:	e0 66 51 48 	mov	r6,20808
8000a0f0:	12 9a       	mov	r10,r9
8000a0f2:	8d 08       	st.w	r6[0x0],r8
8000a0f4:	fe b0 d0 9e 	rcall	80004230 <_read>
8000a0f8:	5b fc       	cp.w	r12,-1
8000a0fa:	c0 51       	brne	8000a104 <_read_r+0x24>
8000a0fc:	6c 08       	ld.w	r8,r6[0x0]
8000a0fe:	58 08       	cp.w	r8,0
8000a100:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000a104:	d8 22       	popm	r4-r7,pc
8000a106:	d7 03       	nop

8000a108 <__avr32_f64_mul>:
8000a108:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000a10c:	e0 80 00 dc 	breq	8000a2c4 <__avr32_f64_mul_op1_zero>
8000a110:	d4 21       	pushm	r4-r7,lr
8000a112:	f7 e9 20 0e 	eor	lr,r11,r9
8000a116:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000a11a:	30 15       	mov	r5,1
8000a11c:	c4 30       	breq	8000a1a2 <__avr32_f64_mul_op1_subnormal>
8000a11e:	ab 6b       	lsl	r11,0xa
8000a120:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000a124:	ab 6a       	lsl	r10,0xa
8000a126:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000a12a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000a12e:	c5 c0       	breq	8000a1e6 <__avr32_f64_mul_op2_subnormal>
8000a130:	a1 78       	lsl	r8,0x1
8000a132:	5c f9       	rol	r9
8000a134:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000a138:	e0 47 07 ff 	cp.w	r7,2047
8000a13c:	c7 70       	breq	8000a22a <__avr32_f64_mul_op_nan_or_inf>
8000a13e:	e0 46 07 ff 	cp.w	r6,2047
8000a142:	c7 40       	breq	8000a22a <__avr32_f64_mul_op_nan_or_inf>
8000a144:	ee 06 00 0c 	add	r12,r7,r6
8000a148:	e0 2c 03 fe 	sub	r12,1022
8000a14c:	f6 08 06 44 	mulu.d	r4,r11,r8
8000a150:	f4 09 07 44 	macu.d	r4,r10,r9
8000a154:	f4 08 06 46 	mulu.d	r6,r10,r8
8000a158:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000a15c:	08 07       	add	r7,r4
8000a15e:	f4 05 00 4a 	adc	r10,r10,r5
8000a162:	5c 0b       	acr	r11
8000a164:	ed bb 00 14 	bld	r11,0x14
8000a168:	c0 50       	breq	8000a172 <__avr32_f64_mul+0x6a>
8000a16a:	a1 77       	lsl	r7,0x1
8000a16c:	5c fa       	rol	r10
8000a16e:	5c fb       	rol	r11
8000a170:	20 1c       	sub	r12,1
8000a172:	58 0c       	cp.w	r12,0
8000a174:	e0 8a 00 6f 	brle	8000a252 <__avr32_f64_mul_res_subnormal>
8000a178:	e0 4c 07 ff 	cp.w	r12,2047
8000a17c:	e0 84 00 9c 	brge	8000a2b4 <__avr32_f64_mul_res_inf>
8000a180:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000a184:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000a188:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000a18c:	ee 17 80 00 	eorh	r7,0x8000
8000a190:	f1 b7 04 20 	satu	r7,0x1
8000a194:	0e 0a       	add	r10,r7
8000a196:	5c 0b       	acr	r11
8000a198:	ed be 00 1f 	bld	lr,0x1f
8000a19c:	ef bb 00 1f 	bst	r11,0x1f
8000a1a0:	d8 22       	popm	r4-r7,pc

8000a1a2 <__avr32_f64_mul_op1_subnormal>:
8000a1a2:	e4 1b 00 0f 	andh	r11,0xf
8000a1a6:	f4 0c 12 00 	clz	r12,r10
8000a1aa:	f6 06 12 00 	clz	r6,r11
8000a1ae:	f7 bc 03 e1 	sublo	r12,-31
8000a1b2:	f8 06 17 30 	movlo	r6,r12
8000a1b6:	f7 b6 02 01 	subhs	r6,1
8000a1ba:	e0 46 00 20 	cp.w	r6,32
8000a1be:	c0 d4       	brge	8000a1d8 <__avr32_f64_mul_op1_subnormal+0x36>
8000a1c0:	ec 0c 11 20 	rsub	r12,r6,32
8000a1c4:	f6 06 09 4b 	lsl	r11,r11,r6
8000a1c8:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000a1cc:	18 4b       	or	r11,r12
8000a1ce:	f4 06 09 4a 	lsl	r10,r10,r6
8000a1d2:	20 b6       	sub	r6,11
8000a1d4:	0c 17       	sub	r7,r6
8000a1d6:	ca ab       	rjmp	8000a12a <__avr32_f64_mul+0x22>
8000a1d8:	f4 06 09 4b 	lsl	r11,r10,r6
8000a1dc:	c6 40       	breq	8000a2a4 <__avr32_f64_mul_res_zero>
8000a1de:	30 0a       	mov	r10,0
8000a1e0:	20 b6       	sub	r6,11
8000a1e2:	0c 17       	sub	r7,r6
8000a1e4:	ca 3b       	rjmp	8000a12a <__avr32_f64_mul+0x22>

8000a1e6 <__avr32_f64_mul_op2_subnormal>:
8000a1e6:	e4 19 00 0f 	andh	r9,0xf
8000a1ea:	f0 0c 12 00 	clz	r12,r8
8000a1ee:	f2 05 12 00 	clz	r5,r9
8000a1f2:	f7 bc 03 ea 	sublo	r12,-22
8000a1f6:	f8 05 17 30 	movlo	r5,r12
8000a1fa:	f7 b5 02 0a 	subhs	r5,10
8000a1fe:	e0 45 00 20 	cp.w	r5,32
8000a202:	c0 d4       	brge	8000a21c <__avr32_f64_mul_op2_subnormal+0x36>
8000a204:	ea 0c 11 20 	rsub	r12,r5,32
8000a208:	f2 05 09 49 	lsl	r9,r9,r5
8000a20c:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000a210:	18 49       	or	r9,r12
8000a212:	f0 05 09 48 	lsl	r8,r8,r5
8000a216:	20 25       	sub	r5,2
8000a218:	0a 16       	sub	r6,r5
8000a21a:	c8 fb       	rjmp	8000a138 <__avr32_f64_mul+0x30>
8000a21c:	f0 05 09 49 	lsl	r9,r8,r5
8000a220:	c4 20       	breq	8000a2a4 <__avr32_f64_mul_res_zero>
8000a222:	30 08       	mov	r8,0
8000a224:	20 25       	sub	r5,2
8000a226:	0a 16       	sub	r6,r5
8000a228:	c8 8b       	rjmp	8000a138 <__avr32_f64_mul+0x30>

8000a22a <__avr32_f64_mul_op_nan_or_inf>:
8000a22a:	e4 19 00 0f 	andh	r9,0xf
8000a22e:	e4 1b 00 0f 	andh	r11,0xf
8000a232:	14 4b       	or	r11,r10
8000a234:	10 49       	or	r9,r8
8000a236:	e0 47 07 ff 	cp.w	r7,2047
8000a23a:	c0 91       	brne	8000a24c <__avr32_f64_mul_op1_not_naninf>
8000a23c:	58 0b       	cp.w	r11,0
8000a23e:	c3 81       	brne	8000a2ae <__avr32_f64_mul_res_nan>
8000a240:	e0 46 07 ff 	cp.w	r6,2047
8000a244:	c3 81       	brne	8000a2b4 <__avr32_f64_mul_res_inf>
8000a246:	58 09       	cp.w	r9,0
8000a248:	c3 60       	breq	8000a2b4 <__avr32_f64_mul_res_inf>
8000a24a:	c3 28       	rjmp	8000a2ae <__avr32_f64_mul_res_nan>

8000a24c <__avr32_f64_mul_op1_not_naninf>:
8000a24c:	58 09       	cp.w	r9,0
8000a24e:	c3 30       	breq	8000a2b4 <__avr32_f64_mul_res_inf>
8000a250:	c2 f8       	rjmp	8000a2ae <__avr32_f64_mul_res_nan>

8000a252 <__avr32_f64_mul_res_subnormal>:
8000a252:	5c 3c       	neg	r12
8000a254:	2f fc       	sub	r12,-1
8000a256:	f1 bc 04 c0 	satu	r12,0x6
8000a25a:	e0 4c 00 20 	cp.w	r12,32
8000a25e:	c1 14       	brge	8000a280 <__avr32_f64_mul_res_subnormal+0x2e>
8000a260:	f8 08 11 20 	rsub	r8,r12,32
8000a264:	0e 46       	or	r6,r7
8000a266:	ee 0c 0a 47 	lsr	r7,r7,r12
8000a26a:	f4 08 09 49 	lsl	r9,r10,r8
8000a26e:	12 47       	or	r7,r9
8000a270:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000a274:	f6 08 09 49 	lsl	r9,r11,r8
8000a278:	12 4a       	or	r10,r9
8000a27a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000a27e:	c8 3b       	rjmp	8000a184 <__avr32_f64_mul+0x7c>
8000a280:	f8 08 11 20 	rsub	r8,r12,32
8000a284:	f9 b9 00 00 	moveq	r9,0
8000a288:	c0 30       	breq	8000a28e <__avr32_f64_mul_res_subnormal+0x3c>
8000a28a:	f6 08 09 49 	lsl	r9,r11,r8
8000a28e:	0e 46       	or	r6,r7
8000a290:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000a294:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000a298:	f3 ea 10 07 	or	r7,r9,r10
8000a29c:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000a2a0:	30 0b       	mov	r11,0
8000a2a2:	c7 1b       	rjmp	8000a184 <__avr32_f64_mul+0x7c>

8000a2a4 <__avr32_f64_mul_res_zero>:
8000a2a4:	1c 9b       	mov	r11,lr
8000a2a6:	e6 1b 80 00 	andh	r11,0x8000,COH
8000a2aa:	30 0a       	mov	r10,0
8000a2ac:	d8 22       	popm	r4-r7,pc

8000a2ae <__avr32_f64_mul_res_nan>:
8000a2ae:	3f fb       	mov	r11,-1
8000a2b0:	3f fa       	mov	r10,-1
8000a2b2:	d8 22       	popm	r4-r7,pc

8000a2b4 <__avr32_f64_mul_res_inf>:
8000a2b4:	f0 6b 00 00 	mov	r11,-1048576
8000a2b8:	ed be 00 1f 	bld	lr,0x1f
8000a2bc:	ef bb 00 1f 	bst	r11,0x1f
8000a2c0:	30 0a       	mov	r10,0
8000a2c2:	d8 22       	popm	r4-r7,pc

8000a2c4 <__avr32_f64_mul_op1_zero>:
8000a2c4:	f7 e9 20 0b 	eor	r11,r11,r9
8000a2c8:	e6 1b 80 00 	andh	r11,0x8000,COH
8000a2cc:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000a2d0:	e0 4c 07 ff 	cp.w	r12,2047
8000a2d4:	5e 1c       	retne	r12
8000a2d6:	3f fa       	mov	r10,-1
8000a2d8:	3f fb       	mov	r11,-1
8000a2da:	5e fc       	retal	r12

8000a2dc <__avr32_f64_sub_from_add>:
8000a2dc:	ee 19 80 00 	eorh	r9,0x8000

8000a2e0 <__avr32_f64_sub>:
8000a2e0:	f7 e9 20 0c 	eor	r12,r11,r9
8000a2e4:	e0 86 00 ca 	brmi	8000a478 <__avr32_f64_add_from_sub>
8000a2e8:	eb cd 40 e0 	pushm	r5-r7,lr
8000a2ec:	16 9c       	mov	r12,r11
8000a2ee:	e6 1c 80 00 	andh	r12,0x8000,COH
8000a2f2:	bf db       	cbr	r11,0x1f
8000a2f4:	bf d9       	cbr	r9,0x1f
8000a2f6:	10 3a       	cp.w	r10,r8
8000a2f8:	f2 0b 13 00 	cpc	r11,r9
8000a2fc:	c0 92       	brcc	8000a30e <__avr32_f64_sub+0x2e>
8000a2fe:	16 97       	mov	r7,r11
8000a300:	12 9b       	mov	r11,r9
8000a302:	0e 99       	mov	r9,r7
8000a304:	14 97       	mov	r7,r10
8000a306:	10 9a       	mov	r10,r8
8000a308:	0e 98       	mov	r8,r7
8000a30a:	ee 1c 80 00 	eorh	r12,0x8000
8000a30e:	f6 07 16 14 	lsr	r7,r11,0x14
8000a312:	ab 7b       	lsl	r11,0xb
8000a314:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000a318:	ab 7a       	lsl	r10,0xb
8000a31a:	bf bb       	sbr	r11,0x1f
8000a31c:	f2 06 16 14 	lsr	r6,r9,0x14
8000a320:	c4 40       	breq	8000a3a8 <__avr32_f64_sub_opL_subnormal>
8000a322:	ab 79       	lsl	r9,0xb
8000a324:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000a328:	ab 78       	lsl	r8,0xb
8000a32a:	bf b9       	sbr	r9,0x1f

8000a32c <__avr32_f64_sub_opL_subnormal_done>:
8000a32c:	e0 47 07 ff 	cp.w	r7,2047
8000a330:	c4 f0       	breq	8000a3ce <__avr32_f64_sub_opH_nan_or_inf>
8000a332:	0e 26       	rsub	r6,r7
8000a334:	c1 20       	breq	8000a358 <__avr32_f64_sub_shift_done>
8000a336:	ec 05 11 20 	rsub	r5,r6,32
8000a33a:	e0 46 00 20 	cp.w	r6,32
8000a33e:	c7 c2       	brcc	8000a436 <__avr32_f64_sub_longshift>
8000a340:	f0 05 09 4e 	lsl	lr,r8,r5
8000a344:	f2 05 09 45 	lsl	r5,r9,r5
8000a348:	f0 06 0a 48 	lsr	r8,r8,r6
8000a34c:	f2 06 0a 49 	lsr	r9,r9,r6
8000a350:	0a 48       	or	r8,r5
8000a352:	58 0e       	cp.w	lr,0
8000a354:	5f 1e       	srne	lr
8000a356:	1c 48       	or	r8,lr

8000a358 <__avr32_f64_sub_shift_done>:
8000a358:	10 1a       	sub	r10,r8
8000a35a:	f6 09 01 4b 	sbc	r11,r11,r9
8000a35e:	f6 06 12 00 	clz	r6,r11
8000a362:	c0 e0       	breq	8000a37e <__avr32_f64_sub_longnormalize_done>
8000a364:	c7 83       	brcs	8000a454 <__avr32_f64_sub_longnormalize>
8000a366:	ec 0e 11 20 	rsub	lr,r6,32
8000a36a:	f6 06 09 4b 	lsl	r11,r11,r6
8000a36e:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000a372:	1c 4b       	or	r11,lr
8000a374:	f4 06 09 4a 	lsl	r10,r10,r6
8000a378:	0c 17       	sub	r7,r6
8000a37a:	e0 8a 00 39 	brle	8000a3ec <__avr32_f64_sub_subnormal_result>

8000a37e <__avr32_f64_sub_longnormalize_done>:
8000a37e:	f4 09 15 15 	lsl	r9,r10,0x15
8000a382:	ab 9a       	lsr	r10,0xb
8000a384:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000a388:	ab 9b       	lsr	r11,0xb
8000a38a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000a38e:	18 4b       	or	r11,r12

8000a390 <__avr32_f64_sub_round>:
8000a390:	fc 17 80 00 	movh	r7,0x8000
8000a394:	ed ba 00 00 	bld	r10,0x0
8000a398:	f7 b7 01 ff 	subne	r7,-1
8000a39c:	0e 39       	cp.w	r9,r7
8000a39e:	5f 29       	srhs	r9
8000a3a0:	12 0a       	add	r10,r9
8000a3a2:	5c 0b       	acr	r11
8000a3a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000a3a8 <__avr32_f64_sub_opL_subnormal>:
8000a3a8:	ab 79       	lsl	r9,0xb
8000a3aa:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000a3ae:	ab 78       	lsl	r8,0xb
8000a3b0:	f3 e8 10 0e 	or	lr,r9,r8
8000a3b4:	f9 b6 01 01 	movne	r6,1
8000a3b8:	ee 0e 11 00 	rsub	lr,r7,0
8000a3bc:	f9 b7 00 01 	moveq	r7,1
8000a3c0:	ef bb 00 1f 	bst	r11,0x1f
8000a3c4:	f7 ea 10 0e 	or	lr,r11,r10
8000a3c8:	f9 b7 00 00 	moveq	r7,0
8000a3cc:	cb 0b       	rjmp	8000a32c <__avr32_f64_sub_opL_subnormal_done>

8000a3ce <__avr32_f64_sub_opH_nan_or_inf>:
8000a3ce:	bf db       	cbr	r11,0x1f
8000a3d0:	f7 ea 10 0e 	or	lr,r11,r10
8000a3d4:	c0 81       	brne	8000a3e4 <__avr32_f64_sub_return_nan>
8000a3d6:	e0 46 07 ff 	cp.w	r6,2047
8000a3da:	c0 50       	breq	8000a3e4 <__avr32_f64_sub_return_nan>
8000a3dc:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000a3e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000a3e4 <__avr32_f64_sub_return_nan>:
8000a3e4:	3f fa       	mov	r10,-1
8000a3e6:	3f fb       	mov	r11,-1
8000a3e8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000a3ec <__avr32_f64_sub_subnormal_result>:
8000a3ec:	5c 37       	neg	r7
8000a3ee:	2f f7       	sub	r7,-1
8000a3f0:	f1 b7 04 c0 	satu	r7,0x6
8000a3f4:	e0 47 00 20 	cp.w	r7,32
8000a3f8:	c1 14       	brge	8000a41a <__avr32_f64_sub_subnormal_result+0x2e>
8000a3fa:	ee 08 11 20 	rsub	r8,r7,32
8000a3fe:	f4 08 09 49 	lsl	r9,r10,r8
8000a402:	5f 16       	srne	r6
8000a404:	f4 07 0a 4a 	lsr	r10,r10,r7
8000a408:	0c 4a       	or	r10,r6
8000a40a:	f6 08 09 49 	lsl	r9,r11,r8
8000a40e:	f5 e9 10 0a 	or	r10,r10,r9
8000a412:	f4 07 0a 4b 	lsr	r11,r10,r7
8000a416:	30 07       	mov	r7,0
8000a418:	cb 3b       	rjmp	8000a37e <__avr32_f64_sub_longnormalize_done>
8000a41a:	ee 08 11 40 	rsub	r8,r7,64
8000a41e:	f6 08 09 49 	lsl	r9,r11,r8
8000a422:	14 49       	or	r9,r10
8000a424:	5f 16       	srne	r6
8000a426:	f6 07 0a 4a 	lsr	r10,r11,r7
8000a42a:	0c 4a       	or	r10,r6
8000a42c:	30 0b       	mov	r11,0
8000a42e:	30 07       	mov	r7,0
8000a430:	ca 7b       	rjmp	8000a37e <__avr32_f64_sub_longnormalize_done>
8000a432:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000a436 <__avr32_f64_sub_longshift>:
8000a436:	f1 b6 04 c0 	satu	r6,0x6
8000a43a:	f0 0e 17 00 	moveq	lr,r8
8000a43e:	c0 40       	breq	8000a446 <__avr32_f64_sub_longshift+0x10>
8000a440:	f2 05 09 4e 	lsl	lr,r9,r5
8000a444:	10 4e       	or	lr,r8
8000a446:	f2 06 0a 48 	lsr	r8,r9,r6
8000a44a:	30 09       	mov	r9,0
8000a44c:	58 0e       	cp.w	lr,0
8000a44e:	5f 1e       	srne	lr
8000a450:	1c 48       	or	r8,lr
8000a452:	c8 3b       	rjmp	8000a358 <__avr32_f64_sub_shift_done>

8000a454 <__avr32_f64_sub_longnormalize>:
8000a454:	f4 06 12 00 	clz	r6,r10
8000a458:	f9 b7 03 00 	movlo	r7,0
8000a45c:	f9 b6 03 00 	movlo	r6,0
8000a460:	f9 bc 03 00 	movlo	r12,0
8000a464:	f7 b6 02 e0 	subhs	r6,-32
8000a468:	f4 06 09 4b 	lsl	r11,r10,r6
8000a46c:	30 0a       	mov	r10,0
8000a46e:	0c 17       	sub	r7,r6
8000a470:	fe 9a ff be 	brle	8000a3ec <__avr32_f64_sub_subnormal_result>
8000a474:	c8 5b       	rjmp	8000a37e <__avr32_f64_sub_longnormalize_done>
8000a476:	d7 03       	nop

8000a478 <__avr32_f64_add_from_sub>:
8000a478:	ee 19 80 00 	eorh	r9,0x8000

8000a47c <__avr32_f64_add>:
8000a47c:	f7 e9 20 0c 	eor	r12,r11,r9
8000a480:	fe 96 ff 2e 	brmi	8000a2dc <__avr32_f64_sub_from_add>
8000a484:	eb cd 40 e0 	pushm	r5-r7,lr
8000a488:	16 9c       	mov	r12,r11
8000a48a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000a48e:	bf db       	cbr	r11,0x1f
8000a490:	bf d9       	cbr	r9,0x1f
8000a492:	12 3b       	cp.w	r11,r9
8000a494:	c0 72       	brcc	8000a4a2 <__avr32_f64_add+0x26>
8000a496:	16 97       	mov	r7,r11
8000a498:	12 9b       	mov	r11,r9
8000a49a:	0e 99       	mov	r9,r7
8000a49c:	14 97       	mov	r7,r10
8000a49e:	10 9a       	mov	r10,r8
8000a4a0:	0e 98       	mov	r8,r7
8000a4a2:	30 0e       	mov	lr,0
8000a4a4:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000a4a8:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000a4ac:	b5 ab       	sbr	r11,0x14
8000a4ae:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000a4b2:	c6 20       	breq	8000a576 <__avr32_f64_add_op2_subnormal>
8000a4b4:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000a4b8:	b5 a9       	sbr	r9,0x14
8000a4ba:	e0 47 07 ff 	cp.w	r7,2047
8000a4be:	c2 80       	breq	8000a50e <__avr32_f64_add_opH_nan_or_inf>
8000a4c0:	0e 26       	rsub	r6,r7
8000a4c2:	c1 20       	breq	8000a4e6 <__avr32_f64_add_shift_done>
8000a4c4:	e0 46 00 36 	cp.w	r6,54
8000a4c8:	c1 52       	brcc	8000a4f2 <__avr32_f64_add_res_of_done>
8000a4ca:	ec 05 11 20 	rsub	r5,r6,32
8000a4ce:	e0 46 00 20 	cp.w	r6,32
8000a4d2:	c3 52       	brcc	8000a53c <__avr32_f64_add_longshift>
8000a4d4:	f0 05 09 4e 	lsl	lr,r8,r5
8000a4d8:	f2 05 09 45 	lsl	r5,r9,r5
8000a4dc:	f0 06 0a 48 	lsr	r8,r8,r6
8000a4e0:	f2 06 0a 49 	lsr	r9,r9,r6
8000a4e4:	0a 48       	or	r8,r5

8000a4e6 <__avr32_f64_add_shift_done>:
8000a4e6:	10 0a       	add	r10,r8
8000a4e8:	f6 09 00 4b 	adc	r11,r11,r9
8000a4ec:	ed bb 00 15 	bld	r11,0x15
8000a4f0:	c3 40       	breq	8000a558 <__avr32_f64_add_res_of>

8000a4f2 <__avr32_f64_add_res_of_done>:
8000a4f2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000a4f6:	18 4b       	or	r11,r12

8000a4f8 <__avr32_f64_add_round>:
8000a4f8:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000a4fc:	18 4e       	or	lr,r12
8000a4fe:	ee 1e 80 00 	eorh	lr,0x8000
8000a502:	f1 be 04 20 	satu	lr,0x1
8000a506:	1c 0a       	add	r10,lr
8000a508:	5c 0b       	acr	r11
8000a50a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000a50e <__avr32_f64_add_opH_nan_or_inf>:
8000a50e:	b5 cb       	cbr	r11,0x14
8000a510:	f7 ea 10 0e 	or	lr,r11,r10
8000a514:	c1 01       	brne	8000a534 <__avr32_f64_add_return_nan>
8000a516:	e0 46 07 ff 	cp.w	r6,2047
8000a51a:	c0 30       	breq	8000a520 <__avr32_f64_add_opL_nan_or_inf>
8000a51c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000a520 <__avr32_f64_add_opL_nan_or_inf>:
8000a520:	b5 c9       	cbr	r9,0x14
8000a522:	f3 e8 10 0e 	or	lr,r9,r8
8000a526:	c0 71       	brne	8000a534 <__avr32_f64_add_return_nan>
8000a528:	30 0a       	mov	r10,0
8000a52a:	fc 1b 7f f0 	movh	r11,0x7ff0
8000a52e:	18 4b       	or	r11,r12
8000a530:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000a534 <__avr32_f64_add_return_nan>:
8000a534:	3f fa       	mov	r10,-1
8000a536:	3f fb       	mov	r11,-1
8000a538:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000a53c <__avr32_f64_add_longshift>:
8000a53c:	f1 b6 04 c0 	satu	r6,0x6
8000a540:	f0 0e 17 00 	moveq	lr,r8
8000a544:	c0 60       	breq	8000a550 <__avr32_f64_add_longshift+0x14>
8000a546:	f2 05 09 4e 	lsl	lr,r9,r5
8000a54a:	58 08       	cp.w	r8,0
8000a54c:	5f 18       	srne	r8
8000a54e:	10 4e       	or	lr,r8
8000a550:	f2 06 0a 48 	lsr	r8,r9,r6
8000a554:	30 09       	mov	r9,0
8000a556:	cc 8b       	rjmp	8000a4e6 <__avr32_f64_add_shift_done>

8000a558 <__avr32_f64_add_res_of>:
8000a558:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000a55c:	a1 9b       	lsr	r11,0x1
8000a55e:	5d 0a       	ror	r10
8000a560:	5d 0e       	ror	lr
8000a562:	2f f7       	sub	r7,-1
8000a564:	e0 47 07 ff 	cp.w	r7,2047
8000a568:	f9 ba 00 00 	moveq	r10,0
8000a56c:	f9 bb 00 00 	moveq	r11,0
8000a570:	f9 be 00 00 	moveq	lr,0
8000a574:	cb fb       	rjmp	8000a4f2 <__avr32_f64_add_res_of_done>

8000a576 <__avr32_f64_add_op2_subnormal>:
8000a576:	30 16       	mov	r6,1
8000a578:	58 07       	cp.w	r7,0
8000a57a:	ca 01       	brne	8000a4ba <__avr32_f64_add+0x3e>
8000a57c:	b5 cb       	cbr	r11,0x14
8000a57e:	10 0a       	add	r10,r8
8000a580:	f6 09 00 4b 	adc	r11,r11,r9
8000a584:	18 4b       	or	r11,r12
8000a586:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000a58a:	d7 03       	nop

8000a58c <__avr32_f64_to_u32>:
8000a58c:	58 0b       	cp.w	r11,0
8000a58e:	5e 6d       	retmi	0

8000a590 <__avr32_f64_to_s32>:
8000a590:	f6 0c 15 01 	lsl	r12,r11,0x1
8000a594:	b5 9c       	lsr	r12,0x15
8000a596:	e0 2c 03 ff 	sub	r12,1023
8000a59a:	5e 3d       	retlo	0
8000a59c:	f8 0c 11 1f 	rsub	r12,r12,31
8000a5a0:	16 99       	mov	r9,r11
8000a5a2:	ab 7b       	lsl	r11,0xb
8000a5a4:	bf bb       	sbr	r11,0x1f
8000a5a6:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000a5aa:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000a5ae:	a1 79       	lsl	r9,0x1
8000a5b0:	5e 2b       	reths	r11
8000a5b2:	5c 3b       	neg	r11
8000a5b4:	5e fb       	retal	r11

8000a5b6 <__avr32_u32_to_f64>:
8000a5b6:	f8 cb 00 00 	sub	r11,r12,0
8000a5ba:	30 0c       	mov	r12,0
8000a5bc:	c0 38       	rjmp	8000a5c2 <__avr32_s32_to_f64+0x4>

8000a5be <__avr32_s32_to_f64>:
8000a5be:	18 9b       	mov	r11,r12
8000a5c0:	5c 4b       	abs	r11
8000a5c2:	30 0a       	mov	r10,0
8000a5c4:	5e 0b       	reteq	r11
8000a5c6:	d4 01       	pushm	lr
8000a5c8:	e0 69 04 1e 	mov	r9,1054
8000a5cc:	f6 08 12 00 	clz	r8,r11
8000a5d0:	c1 70       	breq	8000a5fe <__avr32_s32_to_f64+0x40>
8000a5d2:	c0 c3       	brcs	8000a5ea <__avr32_s32_to_f64+0x2c>
8000a5d4:	f0 0e 11 20 	rsub	lr,r8,32
8000a5d8:	f6 08 09 4b 	lsl	r11,r11,r8
8000a5dc:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000a5e0:	1c 4b       	or	r11,lr
8000a5e2:	f4 08 09 4a 	lsl	r10,r10,r8
8000a5e6:	10 19       	sub	r9,r8
8000a5e8:	c0 b8       	rjmp	8000a5fe <__avr32_s32_to_f64+0x40>
8000a5ea:	f4 08 12 00 	clz	r8,r10
8000a5ee:	f9 b8 03 00 	movlo	r8,0
8000a5f2:	f7 b8 02 e0 	subhs	r8,-32
8000a5f6:	f4 08 09 4b 	lsl	r11,r10,r8
8000a5fa:	30 0a       	mov	r10,0
8000a5fc:	10 19       	sub	r9,r8
8000a5fe:	58 09       	cp.w	r9,0
8000a600:	e0 89 00 30 	brgt	8000a660 <__avr32_s32_to_f64+0xa2>
8000a604:	5c 39       	neg	r9
8000a606:	2f f9       	sub	r9,-1
8000a608:	e0 49 00 36 	cp.w	r9,54
8000a60c:	c0 43       	brcs	8000a614 <__avr32_s32_to_f64+0x56>
8000a60e:	30 0b       	mov	r11,0
8000a610:	30 0a       	mov	r10,0
8000a612:	c2 68       	rjmp	8000a65e <__avr32_s32_to_f64+0xa0>
8000a614:	2f 69       	sub	r9,-10
8000a616:	f2 08 11 20 	rsub	r8,r9,32
8000a61a:	e0 49 00 20 	cp.w	r9,32
8000a61e:	c0 b2       	brcc	8000a634 <__avr32_s32_to_f64+0x76>
8000a620:	f4 08 09 4e 	lsl	lr,r10,r8
8000a624:	f6 08 09 48 	lsl	r8,r11,r8
8000a628:	f4 09 0a 4a 	lsr	r10,r10,r9
8000a62c:	f6 09 0a 4b 	lsr	r11,r11,r9
8000a630:	10 4b       	or	r11,r8
8000a632:	c0 88       	rjmp	8000a642 <__avr32_s32_to_f64+0x84>
8000a634:	f6 08 09 4e 	lsl	lr,r11,r8
8000a638:	14 4e       	or	lr,r10
8000a63a:	16 9a       	mov	r10,r11
8000a63c:	30 0b       	mov	r11,0
8000a63e:	f4 09 0a 4a 	lsr	r10,r10,r9
8000a642:	ed ba 00 00 	bld	r10,0x0
8000a646:	c0 92       	brcc	8000a658 <__avr32_s32_to_f64+0x9a>
8000a648:	1c 7e       	tst	lr,lr
8000a64a:	c0 41       	brne	8000a652 <__avr32_s32_to_f64+0x94>
8000a64c:	ed ba 00 01 	bld	r10,0x1
8000a650:	c0 42       	brcc	8000a658 <__avr32_s32_to_f64+0x9a>
8000a652:	2f fa       	sub	r10,-1
8000a654:	f7 bb 02 ff 	subhs	r11,-1
8000a658:	5c fc       	rol	r12
8000a65a:	5d 0b       	ror	r11
8000a65c:	5d 0a       	ror	r10
8000a65e:	d8 02       	popm	pc
8000a660:	e0 68 03 ff 	mov	r8,1023
8000a664:	ed ba 00 0b 	bld	r10,0xb
8000a668:	f7 b8 00 ff 	subeq	r8,-1
8000a66c:	10 0a       	add	r10,r8
8000a66e:	5c 0b       	acr	r11
8000a670:	f7 b9 03 fe 	sublo	r9,-2
8000a674:	e0 49 07 ff 	cp.w	r9,2047
8000a678:	c0 55       	brlt	8000a682 <__avr32_s32_to_f64+0xc4>
8000a67a:	30 0a       	mov	r10,0
8000a67c:	fc 1b ff e0 	movh	r11,0xffe0
8000a680:	c0 c8       	rjmp	8000a698 <__floatsidf_return_op1>
8000a682:	ed bb 00 1f 	bld	r11,0x1f
8000a686:	f7 b9 01 01 	subne	r9,1
8000a68a:	ab 9a       	lsr	r10,0xb
8000a68c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000a690:	a1 7b       	lsl	r11,0x1
8000a692:	ab 9b       	lsr	r11,0xb
8000a694:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000a698 <__floatsidf_return_op1>:
8000a698:	a1 7c       	lsl	r12,0x1
8000a69a:	5d 0b       	ror	r11
8000a69c:	d8 02       	popm	pc

8000a69e <__avr32_f64_cmp_eq>:
8000a69e:	10 3a       	cp.w	r10,r8
8000a6a0:	f2 0b 13 00 	cpc	r11,r9
8000a6a4:	c0 80       	breq	8000a6b4 <__avr32_f64_cmp_eq+0x16>
8000a6a6:	a1 7b       	lsl	r11,0x1
8000a6a8:	a1 79       	lsl	r9,0x1
8000a6aa:	14 4b       	or	r11,r10
8000a6ac:	12 4b       	or	r11,r9
8000a6ae:	10 4b       	or	r11,r8
8000a6b0:	5e 0f       	reteq	1
8000a6b2:	5e fd       	retal	0
8000a6b4:	a1 7b       	lsl	r11,0x1
8000a6b6:	fc 1c ff e0 	movh	r12,0xffe0
8000a6ba:	58 0a       	cp.w	r10,0
8000a6bc:	f8 0b 13 00 	cpc	r11,r12
8000a6c0:	5e 8f       	retls	1
8000a6c2:	5e fd       	retal	0

8000a6c4 <__avr32_f64_cmp_ge>:
8000a6c4:	1a de       	st.w	--sp,lr
8000a6c6:	1a d7       	st.w	--sp,r7
8000a6c8:	a1 7b       	lsl	r11,0x1
8000a6ca:	5f 3c       	srlo	r12
8000a6cc:	a1 79       	lsl	r9,0x1
8000a6ce:	5f 37       	srlo	r7
8000a6d0:	5c fc       	rol	r12
8000a6d2:	fc 1e ff e0 	movh	lr,0xffe0
8000a6d6:	58 0a       	cp.w	r10,0
8000a6d8:	fc 0b 13 00 	cpc	r11,lr
8000a6dc:	e0 8b 00 1d 	brhi	8000a716 <__avr32_f64_cmp_ge+0x52>
8000a6e0:	58 08       	cp.w	r8,0
8000a6e2:	fc 09 13 00 	cpc	r9,lr
8000a6e6:	e0 8b 00 18 	brhi	8000a716 <__avr32_f64_cmp_ge+0x52>
8000a6ea:	58 0b       	cp.w	r11,0
8000a6ec:	f5 ba 00 00 	subfeq	r10,0
8000a6f0:	c1 50       	breq	8000a71a <__avr32_f64_cmp_ge+0x56>
8000a6f2:	1b 07       	ld.w	r7,sp++
8000a6f4:	1b 0e       	ld.w	lr,sp++
8000a6f6:	58 3c       	cp.w	r12,3
8000a6f8:	c0 a0       	breq	8000a70c <__avr32_f64_cmp_ge+0x48>
8000a6fa:	58 1c       	cp.w	r12,1
8000a6fc:	c0 33       	brcs	8000a702 <__avr32_f64_cmp_ge+0x3e>
8000a6fe:	5e 0f       	reteq	1
8000a700:	5e 1d       	retne	0
8000a702:	10 3a       	cp.w	r10,r8
8000a704:	f2 0b 13 00 	cpc	r11,r9
8000a708:	5e 2f       	reths	1
8000a70a:	5e 3d       	retlo	0
8000a70c:	14 38       	cp.w	r8,r10
8000a70e:	f6 09 13 00 	cpc	r9,r11
8000a712:	5e 2f       	reths	1
8000a714:	5e 3d       	retlo	0
8000a716:	1b 07       	ld.w	r7,sp++
8000a718:	d8 0a       	popm	pc,r12=0
8000a71a:	58 17       	cp.w	r7,1
8000a71c:	5f 0c       	sreq	r12
8000a71e:	58 09       	cp.w	r9,0
8000a720:	f5 b8 00 00 	subfeq	r8,0
8000a724:	1b 07       	ld.w	r7,sp++
8000a726:	1b 0e       	ld.w	lr,sp++
8000a728:	5e 0f       	reteq	1
8000a72a:	5e fc       	retal	r12

8000a72c <__avr32_f64_cmp_lt>:
8000a72c:	1a de       	st.w	--sp,lr
8000a72e:	1a d7       	st.w	--sp,r7
8000a730:	a1 7b       	lsl	r11,0x1
8000a732:	5f 3c       	srlo	r12
8000a734:	a1 79       	lsl	r9,0x1
8000a736:	5f 37       	srlo	r7
8000a738:	5c fc       	rol	r12
8000a73a:	fc 1e ff e0 	movh	lr,0xffe0
8000a73e:	58 0a       	cp.w	r10,0
8000a740:	fc 0b 13 00 	cpc	r11,lr
8000a744:	e0 8b 00 1d 	brhi	8000a77e <__avr32_f64_cmp_lt+0x52>
8000a748:	58 08       	cp.w	r8,0
8000a74a:	fc 09 13 00 	cpc	r9,lr
8000a74e:	e0 8b 00 18 	brhi	8000a77e <__avr32_f64_cmp_lt+0x52>
8000a752:	58 0b       	cp.w	r11,0
8000a754:	f5 ba 00 00 	subfeq	r10,0
8000a758:	c1 50       	breq	8000a782 <__avr32_f64_cmp_lt+0x56>
8000a75a:	1b 07       	ld.w	r7,sp++
8000a75c:	1b 0e       	ld.w	lr,sp++
8000a75e:	58 3c       	cp.w	r12,3
8000a760:	c0 a0       	breq	8000a774 <__avr32_f64_cmp_lt+0x48>
8000a762:	58 1c       	cp.w	r12,1
8000a764:	c0 33       	brcs	8000a76a <__avr32_f64_cmp_lt+0x3e>
8000a766:	5e 0d       	reteq	0
8000a768:	5e 1f       	retne	1
8000a76a:	10 3a       	cp.w	r10,r8
8000a76c:	f2 0b 13 00 	cpc	r11,r9
8000a770:	5e 2d       	reths	0
8000a772:	5e 3f       	retlo	1
8000a774:	14 38       	cp.w	r8,r10
8000a776:	f6 09 13 00 	cpc	r9,r11
8000a77a:	5e 2d       	reths	0
8000a77c:	5e 3f       	retlo	1
8000a77e:	1b 07       	ld.w	r7,sp++
8000a780:	d8 0a       	popm	pc,r12=0
8000a782:	58 17       	cp.w	r7,1
8000a784:	5f 1c       	srne	r12
8000a786:	58 09       	cp.w	r9,0
8000a788:	f5 b8 00 00 	subfeq	r8,0
8000a78c:	1b 07       	ld.w	r7,sp++
8000a78e:	1b 0e       	ld.w	lr,sp++
8000a790:	5e 0d       	reteq	0
8000a792:	5e fc       	retal	r12

8000a794 <__avr32_f64_div>:
8000a794:	eb cd 40 ff 	pushm	r0-r7,lr
8000a798:	f7 e9 20 0e 	eor	lr,r11,r9
8000a79c:	f6 07 16 14 	lsr	r7,r11,0x14
8000a7a0:	a9 7b       	lsl	r11,0x9
8000a7a2:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000a7a6:	a9 7a       	lsl	r10,0x9
8000a7a8:	bd bb       	sbr	r11,0x1d
8000a7aa:	e4 1b 3f ff 	andh	r11,0x3fff
8000a7ae:	ab d7       	cbr	r7,0xb
8000a7b0:	e0 80 00 cc 	breq	8000a948 <__avr32_f64_div_round_subnormal+0x54>
8000a7b4:	e0 47 07 ff 	cp.w	r7,2047
8000a7b8:	e0 84 00 b5 	brge	8000a922 <__avr32_f64_div_round_subnormal+0x2e>
8000a7bc:	f2 06 16 14 	lsr	r6,r9,0x14
8000a7c0:	a9 79       	lsl	r9,0x9
8000a7c2:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000a7c6:	a9 78       	lsl	r8,0x9
8000a7c8:	bd b9       	sbr	r9,0x1d
8000a7ca:	e4 19 3f ff 	andh	r9,0x3fff
8000a7ce:	ab d6       	cbr	r6,0xb
8000a7d0:	e0 80 00 e2 	breq	8000a994 <__avr32_f64_div_round_subnormal+0xa0>
8000a7d4:	e0 46 07 ff 	cp.w	r6,2047
8000a7d8:	e0 84 00 b2 	brge	8000a93c <__avr32_f64_div_round_subnormal+0x48>
8000a7dc:	0c 17       	sub	r7,r6
8000a7de:	fe 37 fc 01 	sub	r7,-1023
8000a7e2:	fc 1c 80 00 	movh	r12,0x8000
8000a7e6:	f8 03 16 01 	lsr	r3,r12,0x1
8000a7ea:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000a7ee:	5c d4       	com	r4
8000a7f0:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000a7f4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000a7f8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000a7fc:	e6 05 06 44 	mulu.d	r4,r3,r5
8000a800:	ea 03 15 02 	lsl	r3,r5,0x2
8000a804:	e6 09 06 44 	mulu.d	r4,r3,r9
8000a808:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000a80c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000a810:	ea 03 15 02 	lsl	r3,r5,0x2
8000a814:	e6 09 06 44 	mulu.d	r4,r3,r9
8000a818:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000a81c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000a820:	ea 03 15 02 	lsl	r3,r5,0x2
8000a824:	e6 08 06 40 	mulu.d	r0,r3,r8
8000a828:	e4 09 07 40 	macu.d	r0,r2,r9
8000a82c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000a830:	02 04       	add	r4,r1
8000a832:	5c 05       	acr	r5
8000a834:	a3 65       	lsl	r5,0x2
8000a836:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000a83a:	a3 64       	lsl	r4,0x2
8000a83c:	5c 34       	neg	r4
8000a83e:	f8 05 01 45 	sbc	r5,r12,r5
8000a842:	e6 04 06 40 	mulu.d	r0,r3,r4
8000a846:	e4 05 07 40 	macu.d	r0,r2,r5
8000a84a:	e6 05 06 44 	mulu.d	r4,r3,r5
8000a84e:	02 04       	add	r4,r1
8000a850:	5c 05       	acr	r5
8000a852:	ea 03 15 02 	lsl	r3,r5,0x2
8000a856:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000a85a:	e8 02 15 02 	lsl	r2,r4,0x2
8000a85e:	e6 08 06 40 	mulu.d	r0,r3,r8
8000a862:	e4 09 07 40 	macu.d	r0,r2,r9
8000a866:	e6 09 06 44 	mulu.d	r4,r3,r9
8000a86a:	02 04       	add	r4,r1
8000a86c:	5c 05       	acr	r5
8000a86e:	a3 65       	lsl	r5,0x2
8000a870:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000a874:	a3 64       	lsl	r4,0x2
8000a876:	5c 34       	neg	r4
8000a878:	f8 05 01 45 	sbc	r5,r12,r5
8000a87c:	e6 04 06 40 	mulu.d	r0,r3,r4
8000a880:	e4 05 07 40 	macu.d	r0,r2,r5
8000a884:	e6 05 06 44 	mulu.d	r4,r3,r5
8000a888:	02 04       	add	r4,r1
8000a88a:	5c 05       	acr	r5
8000a88c:	ea 03 15 02 	lsl	r3,r5,0x2
8000a890:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000a894:	e8 02 15 02 	lsl	r2,r4,0x2
8000a898:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000a89c:	e4 0b 07 40 	macu.d	r0,r2,r11
8000a8a0:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000a8a4:	02 02       	add	r2,r1
8000a8a6:	5c 03       	acr	r3
8000a8a8:	ed b3 00 1c 	bld	r3,0x1c
8000a8ac:	c0 90       	breq	8000a8be <__avr32_f64_div+0x12a>
8000a8ae:	a1 72       	lsl	r2,0x1
8000a8b0:	5c f3       	rol	r3
8000a8b2:	20 17       	sub	r7,1
8000a8b4:	a3 9a       	lsr	r10,0x3
8000a8b6:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000a8ba:	a3 9b       	lsr	r11,0x3
8000a8bc:	c0 58       	rjmp	8000a8c6 <__avr32_f64_div+0x132>
8000a8be:	a5 8a       	lsr	r10,0x4
8000a8c0:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000a8c4:	a5 8b       	lsr	r11,0x4
8000a8c6:	58 07       	cp.w	r7,0
8000a8c8:	e0 8a 00 8b 	brle	8000a9de <__avr32_f64_div_res_subnormal>
8000a8cc:	e0 12 ff 00 	andl	r2,0xff00
8000a8d0:	e8 12 00 80 	orl	r2,0x80
8000a8d4:	e6 08 06 40 	mulu.d	r0,r3,r8
8000a8d8:	e4 09 07 40 	macu.d	r0,r2,r9
8000a8dc:	e4 08 06 44 	mulu.d	r4,r2,r8
8000a8e0:	e6 09 06 48 	mulu.d	r8,r3,r9
8000a8e4:	00 05       	add	r5,r0
8000a8e6:	f0 01 00 48 	adc	r8,r8,r1
8000a8ea:	5c 09       	acr	r9
8000a8ec:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000a8f0:	58 04       	cp.w	r4,0
8000a8f2:	5c 25       	cpc	r5

8000a8f4 <__avr32_f64_div_round_subnormal>:
8000a8f4:	f4 08 13 00 	cpc	r8,r10
8000a8f8:	f6 09 13 00 	cpc	r9,r11
8000a8fc:	5f 36       	srlo	r6
8000a8fe:	f8 06 17 00 	moveq	r6,r12
8000a902:	e4 0a 16 08 	lsr	r10,r2,0x8
8000a906:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000a90a:	e6 0b 16 08 	lsr	r11,r3,0x8
8000a90e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000a912:	ed be 00 1f 	bld	lr,0x1f
8000a916:	ef bb 00 1f 	bst	r11,0x1f
8000a91a:	0c 0a       	add	r10,r6
8000a91c:	5c 0b       	acr	r11
8000a91e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000a922:	e4 1b 00 0f 	andh	r11,0xf
8000a926:	14 4b       	or	r11,r10
8000a928:	e0 81 00 a7 	brne	8000aa76 <__avr32_f64_div_res_subnormal+0x98>
8000a92c:	f2 06 16 14 	lsr	r6,r9,0x14
8000a930:	ab d6       	cbr	r6,0xb
8000a932:	e0 46 07 ff 	cp.w	r6,2047
8000a936:	e0 81 00 a4 	brne	8000aa7e <__avr32_f64_div_res_subnormal+0xa0>
8000a93a:	c9 e8       	rjmp	8000aa76 <__avr32_f64_div_res_subnormal+0x98>
8000a93c:	e4 19 00 0f 	andh	r9,0xf
8000a940:	10 49       	or	r9,r8
8000a942:	e0 81 00 9a 	brne	8000aa76 <__avr32_f64_div_res_subnormal+0x98>
8000a946:	c9 28       	rjmp	8000aa6a <__avr32_f64_div_res_subnormal+0x8c>
8000a948:	a3 7b       	lsl	r11,0x3
8000a94a:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000a94e:	a3 7a       	lsl	r10,0x3
8000a950:	f5 eb 10 04 	or	r4,r10,r11
8000a954:	e0 80 00 a0 	breq	8000aa94 <__avr32_f64_div_op1_zero>
8000a958:	f6 04 12 00 	clz	r4,r11
8000a95c:	c1 70       	breq	8000a98a <__avr32_f64_div_round_subnormal+0x96>
8000a95e:	c0 c3       	brcs	8000a976 <__avr32_f64_div_round_subnormal+0x82>
8000a960:	e8 05 11 20 	rsub	r5,r4,32
8000a964:	f6 04 09 4b 	lsl	r11,r11,r4
8000a968:	f4 05 0a 45 	lsr	r5,r10,r5
8000a96c:	0a 4b       	or	r11,r5
8000a96e:	f4 04 09 4a 	lsl	r10,r10,r4
8000a972:	08 17       	sub	r7,r4
8000a974:	c0 b8       	rjmp	8000a98a <__avr32_f64_div_round_subnormal+0x96>
8000a976:	f4 04 12 00 	clz	r4,r10
8000a97a:	f9 b4 03 00 	movlo	r4,0
8000a97e:	f7 b4 02 e0 	subhs	r4,-32
8000a982:	f4 04 09 4b 	lsl	r11,r10,r4
8000a986:	30 0a       	mov	r10,0
8000a988:	08 17       	sub	r7,r4
8000a98a:	a3 8a       	lsr	r10,0x2
8000a98c:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000a990:	a3 8b       	lsr	r11,0x2
8000a992:	c1 1b       	rjmp	8000a7b4 <__avr32_f64_div+0x20>
8000a994:	a3 79       	lsl	r9,0x3
8000a996:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000a99a:	a3 78       	lsl	r8,0x3
8000a99c:	f3 e8 10 04 	or	r4,r9,r8
8000a9a0:	c6 f0       	breq	8000aa7e <__avr32_f64_div_res_subnormal+0xa0>
8000a9a2:	f2 04 12 00 	clz	r4,r9
8000a9a6:	c1 70       	breq	8000a9d4 <__avr32_f64_div_round_subnormal+0xe0>
8000a9a8:	c0 c3       	brcs	8000a9c0 <__avr32_f64_div_round_subnormal+0xcc>
8000a9aa:	e8 05 11 20 	rsub	r5,r4,32
8000a9ae:	f2 04 09 49 	lsl	r9,r9,r4
8000a9b2:	f0 05 0a 45 	lsr	r5,r8,r5
8000a9b6:	0a 49       	or	r9,r5
8000a9b8:	f0 04 09 48 	lsl	r8,r8,r4
8000a9bc:	08 16       	sub	r6,r4
8000a9be:	c0 b8       	rjmp	8000a9d4 <__avr32_f64_div_round_subnormal+0xe0>
8000a9c0:	f0 04 12 00 	clz	r4,r8
8000a9c4:	f9 b4 03 00 	movlo	r4,0
8000a9c8:	f7 b4 02 e0 	subhs	r4,-32
8000a9cc:	f0 04 09 49 	lsl	r9,r8,r4
8000a9d0:	30 08       	mov	r8,0
8000a9d2:	08 16       	sub	r6,r4
8000a9d4:	a3 88       	lsr	r8,0x2
8000a9d6:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000a9da:	a3 89       	lsr	r9,0x2
8000a9dc:	cf ca       	rjmp	8000a7d4 <__avr32_f64_div+0x40>

8000a9de <__avr32_f64_div_res_subnormal>:
8000a9de:	5c 37       	neg	r7
8000a9e0:	2f f7       	sub	r7,-1
8000a9e2:	f1 b7 04 c0 	satu	r7,0x6
8000a9e6:	e0 47 00 20 	cp.w	r7,32
8000a9ea:	c1 54       	brge	8000aa14 <__avr32_f64_div_res_subnormal+0x36>
8000a9ec:	ee 06 11 20 	rsub	r6,r7,32
8000a9f0:	e4 07 0a 42 	lsr	r2,r2,r7
8000a9f4:	e6 06 09 4c 	lsl	r12,r3,r6
8000a9f8:	18 42       	or	r2,r12
8000a9fa:	e6 07 0a 43 	lsr	r3,r3,r7
8000a9fe:	f4 06 09 41 	lsl	r1,r10,r6
8000aa02:	f4 07 0a 4a 	lsr	r10,r10,r7
8000aa06:	f6 06 09 4c 	lsl	r12,r11,r6
8000aa0a:	18 4a       	or	r10,r12
8000aa0c:	f6 07 0a 4b 	lsr	r11,r11,r7
8000aa10:	30 00       	mov	r0,0
8000aa12:	c1 58       	rjmp	8000aa3c <__avr32_f64_div_res_subnormal+0x5e>
8000aa14:	ee 06 11 20 	rsub	r6,r7,32
8000aa18:	f9 b0 00 00 	moveq	r0,0
8000aa1c:	f9 bc 00 00 	moveq	r12,0
8000aa20:	c0 50       	breq	8000aa2a <__avr32_f64_div_res_subnormal+0x4c>
8000aa22:	f4 06 09 40 	lsl	r0,r10,r6
8000aa26:	f6 06 09 4c 	lsl	r12,r11,r6
8000aa2a:	e6 07 0a 42 	lsr	r2,r3,r7
8000aa2e:	30 03       	mov	r3,0
8000aa30:	f4 07 0a 41 	lsr	r1,r10,r7
8000aa34:	18 41       	or	r1,r12
8000aa36:	f6 07 0a 4a 	lsr	r10,r11,r7
8000aa3a:	30 0b       	mov	r11,0
8000aa3c:	e0 12 ff 00 	andl	r2,0xff00
8000aa40:	e8 12 00 80 	orl	r2,0x80
8000aa44:	e6 08 06 46 	mulu.d	r6,r3,r8
8000aa48:	e4 09 07 46 	macu.d	r6,r2,r9
8000aa4c:	e4 08 06 44 	mulu.d	r4,r2,r8
8000aa50:	e6 09 06 48 	mulu.d	r8,r3,r9
8000aa54:	0c 05       	add	r5,r6
8000aa56:	f0 07 00 48 	adc	r8,r8,r7
8000aa5a:	5c 09       	acr	r9
8000aa5c:	30 07       	mov	r7,0
8000aa5e:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000aa62:	00 34       	cp.w	r4,r0
8000aa64:	e2 05 13 00 	cpc	r5,r1
8000aa68:	c4 6b       	rjmp	8000a8f4 <__avr32_f64_div_round_subnormal>
8000aa6a:	1c 9b       	mov	r11,lr
8000aa6c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000aa70:	30 0a       	mov	r10,0
8000aa72:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000aa76:	3f fb       	mov	r11,-1
8000aa78:	30 0a       	mov	r10,0
8000aa7a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000aa7e:	f5 eb 10 04 	or	r4,r10,r11
8000aa82:	c0 90       	breq	8000aa94 <__avr32_f64_div_op1_zero>
8000aa84:	1c 9b       	mov	r11,lr
8000aa86:	e6 1b 80 00 	andh	r11,0x8000,COH
8000aa8a:	ea 1b 7f f0 	orh	r11,0x7ff0
8000aa8e:	30 0a       	mov	r10,0
8000aa90:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000aa94 <__avr32_f64_div_op1_zero>:
8000aa94:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000aa98:	ce f0       	breq	8000aa76 <__avr32_f64_div_res_subnormal+0x98>
8000aa9a:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000aa9e:	e0 44 07 ff 	cp.w	r4,2047
8000aaa2:	ce 41       	brne	8000aa6a <__avr32_f64_div_res_subnormal+0x8c>
8000aaa4:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000aaa8:	ce 10       	breq	8000aa6a <__avr32_f64_div_res_subnormal+0x8c>
8000aaaa:	ce 6b       	rjmp	8000aa76 <__avr32_f64_div_res_subnormal+0x98>

8000aaac <__avr32_udiv64>:
8000aaac:	d4 31       	pushm	r0-r7,lr
8000aaae:	1a 97       	mov	r7,sp
8000aab0:	20 3d       	sub	sp,12
8000aab2:	10 9c       	mov	r12,r8
8000aab4:	12 9e       	mov	lr,r9
8000aab6:	14 93       	mov	r3,r10
8000aab8:	58 09       	cp.w	r9,0
8000aaba:	e0 81 00 bd 	brne	8000ac34 <__avr32_udiv64+0x188>
8000aabe:	16 38       	cp.w	r8,r11
8000aac0:	e0 88 00 40 	brls	8000ab40 <__avr32_udiv64+0x94>
8000aac4:	f0 08 12 00 	clz	r8,r8
8000aac8:	c0 d0       	breq	8000aae2 <__avr32_udiv64+0x36>
8000aaca:	f6 08 09 4b 	lsl	r11,r11,r8
8000aace:	f0 09 11 20 	rsub	r9,r8,32
8000aad2:	f8 08 09 4c 	lsl	r12,r12,r8
8000aad6:	f4 09 0a 49 	lsr	r9,r10,r9
8000aada:	f4 08 09 43 	lsl	r3,r10,r8
8000aade:	f3 eb 10 0b 	or	r11,r9,r11
8000aae2:	f8 0e 16 10 	lsr	lr,r12,0x10
8000aae6:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000aaea:	f6 0e 0d 00 	divu	r0,r11,lr
8000aaee:	e6 0b 16 10 	lsr	r11,r3,0x10
8000aaf2:	00 99       	mov	r9,r0
8000aaf4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000aaf8:	e0 0a 02 48 	mul	r8,r0,r10
8000aafc:	10 3b       	cp.w	r11,r8
8000aafe:	c0 a2       	brcc	8000ab12 <__avr32_udiv64+0x66>
8000ab00:	20 19       	sub	r9,1
8000ab02:	18 0b       	add	r11,r12
8000ab04:	18 3b       	cp.w	r11,r12
8000ab06:	c0 63       	brcs	8000ab12 <__avr32_udiv64+0x66>
8000ab08:	10 3b       	cp.w	r11,r8
8000ab0a:	f7 b9 03 01 	sublo	r9,1
8000ab0e:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ab12:	f6 08 01 01 	sub	r1,r11,r8
8000ab16:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000ab1a:	e2 0e 0d 00 	divu	r0,r1,lr
8000ab1e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000ab22:	00 98       	mov	r8,r0
8000ab24:	e0 0a 02 4a 	mul	r10,r0,r10
8000ab28:	14 33       	cp.w	r3,r10
8000ab2a:	c0 82       	brcc	8000ab3a <__avr32_udiv64+0x8e>
8000ab2c:	20 18       	sub	r8,1
8000ab2e:	18 03       	add	r3,r12
8000ab30:	18 33       	cp.w	r3,r12
8000ab32:	c0 43       	brcs	8000ab3a <__avr32_udiv64+0x8e>
8000ab34:	14 33       	cp.w	r3,r10
8000ab36:	f7 b8 03 01 	sublo	r8,1
8000ab3a:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000ab3e:	cd f8       	rjmp	8000acfc <__avr32_udiv64+0x250>
8000ab40:	58 08       	cp.w	r8,0
8000ab42:	c0 51       	brne	8000ab4c <__avr32_udiv64+0xa0>
8000ab44:	30 19       	mov	r9,1
8000ab46:	f2 08 0d 08 	divu	r8,r9,r8
8000ab4a:	10 9c       	mov	r12,r8
8000ab4c:	f8 06 12 00 	clz	r6,r12
8000ab50:	c0 41       	brne	8000ab58 <__avr32_udiv64+0xac>
8000ab52:	18 1b       	sub	r11,r12
8000ab54:	30 19       	mov	r9,1
8000ab56:	c4 08       	rjmp	8000abd6 <__avr32_udiv64+0x12a>
8000ab58:	ec 01 11 20 	rsub	r1,r6,32
8000ab5c:	f4 01 0a 49 	lsr	r9,r10,r1
8000ab60:	f8 06 09 4c 	lsl	r12,r12,r6
8000ab64:	f6 06 09 48 	lsl	r8,r11,r6
8000ab68:	f6 01 0a 41 	lsr	r1,r11,r1
8000ab6c:	f3 e8 10 08 	or	r8,r9,r8
8000ab70:	f8 03 16 10 	lsr	r3,r12,0x10
8000ab74:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000ab78:	e2 03 0d 00 	divu	r0,r1,r3
8000ab7c:	f0 0b 16 10 	lsr	r11,r8,0x10
8000ab80:	00 9e       	mov	lr,r0
8000ab82:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000ab86:	e0 05 02 49 	mul	r9,r0,r5
8000ab8a:	12 3b       	cp.w	r11,r9
8000ab8c:	c0 a2       	brcc	8000aba0 <__avr32_udiv64+0xf4>
8000ab8e:	20 1e       	sub	lr,1
8000ab90:	18 0b       	add	r11,r12
8000ab92:	18 3b       	cp.w	r11,r12
8000ab94:	c0 63       	brcs	8000aba0 <__avr32_udiv64+0xf4>
8000ab96:	12 3b       	cp.w	r11,r9
8000ab98:	f7 be 03 01 	sublo	lr,1
8000ab9c:	f7 dc e3 0b 	addcs	r11,r11,r12
8000aba0:	12 1b       	sub	r11,r9
8000aba2:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000aba6:	f6 03 0d 02 	divu	r2,r11,r3
8000abaa:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000abae:	04 99       	mov	r9,r2
8000abb0:	e4 05 02 4b 	mul	r11,r2,r5
8000abb4:	16 38       	cp.w	r8,r11
8000abb6:	c0 a2       	brcc	8000abca <__avr32_udiv64+0x11e>
8000abb8:	20 19       	sub	r9,1
8000abba:	18 08       	add	r8,r12
8000abbc:	18 38       	cp.w	r8,r12
8000abbe:	c0 63       	brcs	8000abca <__avr32_udiv64+0x11e>
8000abc0:	16 38       	cp.w	r8,r11
8000abc2:	f7 b9 03 01 	sublo	r9,1
8000abc6:	f1 dc e3 08 	addcs	r8,r8,r12
8000abca:	f4 06 09 43 	lsl	r3,r10,r6
8000abce:	f0 0b 01 0b 	sub	r11,r8,r11
8000abd2:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000abd6:	f8 06 16 10 	lsr	r6,r12,0x10
8000abda:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000abde:	f6 06 0d 00 	divu	r0,r11,r6
8000abe2:	e6 0b 16 10 	lsr	r11,r3,0x10
8000abe6:	00 9a       	mov	r10,r0
8000abe8:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000abec:	e0 0e 02 48 	mul	r8,r0,lr
8000abf0:	10 3b       	cp.w	r11,r8
8000abf2:	c0 a2       	brcc	8000ac06 <__avr32_udiv64+0x15a>
8000abf4:	20 1a       	sub	r10,1
8000abf6:	18 0b       	add	r11,r12
8000abf8:	18 3b       	cp.w	r11,r12
8000abfa:	c0 63       	brcs	8000ac06 <__avr32_udiv64+0x15a>
8000abfc:	10 3b       	cp.w	r11,r8
8000abfe:	f7 ba 03 01 	sublo	r10,1
8000ac02:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ac06:	f6 08 01 01 	sub	r1,r11,r8
8000ac0a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000ac0e:	e2 06 0d 00 	divu	r0,r1,r6
8000ac12:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000ac16:	00 98       	mov	r8,r0
8000ac18:	e0 0e 02 4b 	mul	r11,r0,lr
8000ac1c:	16 33       	cp.w	r3,r11
8000ac1e:	c0 82       	brcc	8000ac2e <__avr32_udiv64+0x182>
8000ac20:	20 18       	sub	r8,1
8000ac22:	18 03       	add	r3,r12
8000ac24:	18 33       	cp.w	r3,r12
8000ac26:	c0 43       	brcs	8000ac2e <__avr32_udiv64+0x182>
8000ac28:	16 33       	cp.w	r3,r11
8000ac2a:	f7 b8 03 01 	sublo	r8,1
8000ac2e:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000ac32:	c6 98       	rjmp	8000ad04 <__avr32_udiv64+0x258>
8000ac34:	16 39       	cp.w	r9,r11
8000ac36:	e0 8b 00 65 	brhi	8000ad00 <__avr32_udiv64+0x254>
8000ac3a:	f2 09 12 00 	clz	r9,r9
8000ac3e:	c0 b1       	brne	8000ac54 <__avr32_udiv64+0x1a8>
8000ac40:	10 3a       	cp.w	r10,r8
8000ac42:	5f 2a       	srhs	r10
8000ac44:	1c 3b       	cp.w	r11,lr
8000ac46:	5f b8       	srhi	r8
8000ac48:	10 4a       	or	r10,r8
8000ac4a:	f2 0a 18 00 	cp.b	r10,r9
8000ac4e:	c5 90       	breq	8000ad00 <__avr32_udiv64+0x254>
8000ac50:	30 18       	mov	r8,1
8000ac52:	c5 98       	rjmp	8000ad04 <__avr32_udiv64+0x258>
8000ac54:	f0 09 09 46 	lsl	r6,r8,r9
8000ac58:	f2 03 11 20 	rsub	r3,r9,32
8000ac5c:	fc 09 09 4e 	lsl	lr,lr,r9
8000ac60:	f0 03 0a 48 	lsr	r8,r8,r3
8000ac64:	f6 09 09 4c 	lsl	r12,r11,r9
8000ac68:	f4 03 0a 42 	lsr	r2,r10,r3
8000ac6c:	ef 46 ff f4 	st.w	r7[-12],r6
8000ac70:	f6 03 0a 43 	lsr	r3,r11,r3
8000ac74:	18 42       	or	r2,r12
8000ac76:	f1 ee 10 0c 	or	r12,r8,lr
8000ac7a:	f8 01 16 10 	lsr	r1,r12,0x10
8000ac7e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000ac82:	e6 01 0d 04 	divu	r4,r3,r1
8000ac86:	e4 03 16 10 	lsr	r3,r2,0x10
8000ac8a:	08 9e       	mov	lr,r4
8000ac8c:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000ac90:	e8 06 02 48 	mul	r8,r4,r6
8000ac94:	10 33       	cp.w	r3,r8
8000ac96:	c0 a2       	brcc	8000acaa <__avr32_udiv64+0x1fe>
8000ac98:	20 1e       	sub	lr,1
8000ac9a:	18 03       	add	r3,r12
8000ac9c:	18 33       	cp.w	r3,r12
8000ac9e:	c0 63       	brcs	8000acaa <__avr32_udiv64+0x1fe>
8000aca0:	10 33       	cp.w	r3,r8
8000aca2:	f7 be 03 01 	sublo	lr,1
8000aca6:	e7 dc e3 03 	addcs	r3,r3,r12
8000acaa:	10 13       	sub	r3,r8
8000acac:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000acb0:	e6 01 0d 00 	divu	r0,r3,r1
8000acb4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000acb8:	00 98       	mov	r8,r0
8000acba:	e0 06 02 46 	mul	r6,r0,r6
8000acbe:	0c 3b       	cp.w	r11,r6
8000acc0:	c0 a2       	brcc	8000acd4 <__avr32_udiv64+0x228>
8000acc2:	20 18       	sub	r8,1
8000acc4:	18 0b       	add	r11,r12
8000acc6:	18 3b       	cp.w	r11,r12
8000acc8:	c0 63       	brcs	8000acd4 <__avr32_udiv64+0x228>
8000acca:	0c 3b       	cp.w	r11,r6
8000accc:	f7 dc e3 0b 	addcs	r11,r11,r12
8000acd0:	f7 b8 03 01 	sublo	r8,1
8000acd4:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000acd8:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000acdc:	0c 1b       	sub	r11,r6
8000acde:	f0 04 06 42 	mulu.d	r2,r8,r4
8000ace2:	06 95       	mov	r5,r3
8000ace4:	16 35       	cp.w	r5,r11
8000ace6:	e0 8b 00 0a 	brhi	8000acfa <__avr32_udiv64+0x24e>
8000acea:	5f 0b       	sreq	r11
8000acec:	f4 09 09 49 	lsl	r9,r10,r9
8000acf0:	12 32       	cp.w	r2,r9
8000acf2:	5f b9       	srhi	r9
8000acf4:	f7 e9 00 09 	and	r9,r11,r9
8000acf8:	c0 60       	breq	8000ad04 <__avr32_udiv64+0x258>
8000acfa:	20 18       	sub	r8,1
8000acfc:	30 09       	mov	r9,0
8000acfe:	c0 38       	rjmp	8000ad04 <__avr32_udiv64+0x258>
8000ad00:	30 09       	mov	r9,0
8000ad02:	12 98       	mov	r8,r9
8000ad04:	10 9a       	mov	r10,r8
8000ad06:	12 93       	mov	r3,r9
8000ad08:	10 92       	mov	r2,r8
8000ad0a:	12 9b       	mov	r11,r9
8000ad0c:	2f dd       	sub	sp,-12
8000ad0e:	d8 32       	popm	r0-r7,pc

8000ad10 <__avr32_umod64>:
8000ad10:	d4 31       	pushm	r0-r7,lr
8000ad12:	1a 97       	mov	r7,sp
8000ad14:	20 3d       	sub	sp,12
8000ad16:	10 9c       	mov	r12,r8
8000ad18:	12 95       	mov	r5,r9
8000ad1a:	14 9e       	mov	lr,r10
8000ad1c:	16 91       	mov	r1,r11
8000ad1e:	16 96       	mov	r6,r11
8000ad20:	58 09       	cp.w	r9,0
8000ad22:	e0 81 00 81 	brne	8000ae24 <__avr32_umod64+0x114>
8000ad26:	16 38       	cp.w	r8,r11
8000ad28:	e0 88 00 12 	brls	8000ad4c <__avr32_umod64+0x3c>
8000ad2c:	f0 08 12 00 	clz	r8,r8
8000ad30:	c4 e0       	breq	8000adcc <__avr32_umod64+0xbc>
8000ad32:	f6 08 09 46 	lsl	r6,r11,r8
8000ad36:	f8 08 09 4c 	lsl	r12,r12,r8
8000ad3a:	f0 0b 11 20 	rsub	r11,r8,32
8000ad3e:	f4 08 09 4e 	lsl	lr,r10,r8
8000ad42:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000ad46:	f7 e6 10 06 	or	r6,r11,r6
8000ad4a:	c4 18       	rjmp	8000adcc <__avr32_umod64+0xbc>
8000ad4c:	58 08       	cp.w	r8,0
8000ad4e:	c0 51       	brne	8000ad58 <__avr32_umod64+0x48>
8000ad50:	30 19       	mov	r9,1
8000ad52:	f2 08 0d 08 	divu	r8,r9,r8
8000ad56:	10 9c       	mov	r12,r8
8000ad58:	f8 08 12 00 	clz	r8,r12
8000ad5c:	c0 31       	brne	8000ad62 <__avr32_umod64+0x52>
8000ad5e:	18 16       	sub	r6,r12
8000ad60:	c3 68       	rjmp	8000adcc <__avr32_umod64+0xbc>
8000ad62:	f0 03 11 20 	rsub	r3,r8,32
8000ad66:	f4 03 0a 4b 	lsr	r11,r10,r3
8000ad6a:	f8 08 09 4c 	lsl	r12,r12,r8
8000ad6e:	ec 08 09 49 	lsl	r9,r6,r8
8000ad72:	ec 03 0a 43 	lsr	r3,r6,r3
8000ad76:	f7 e9 10 09 	or	r9,r11,r9
8000ad7a:	f8 05 16 10 	lsr	r5,r12,0x10
8000ad7e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000ad82:	e6 05 0d 02 	divu	r2,r3,r5
8000ad86:	f2 0e 16 10 	lsr	lr,r9,0x10
8000ad8a:	ec 02 02 4b 	mul	r11,r6,r2
8000ad8e:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000ad92:	16 3e       	cp.w	lr,r11
8000ad94:	c0 72       	brcc	8000ada2 <__avr32_umod64+0x92>
8000ad96:	18 0e       	add	lr,r12
8000ad98:	18 3e       	cp.w	lr,r12
8000ad9a:	c0 43       	brcs	8000ada2 <__avr32_umod64+0x92>
8000ad9c:	16 3e       	cp.w	lr,r11
8000ad9e:	fd dc e3 0e 	addcs	lr,lr,r12
8000ada2:	fc 0b 01 03 	sub	r3,lr,r11
8000ada6:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000adaa:	e6 05 0d 02 	divu	r2,r3,r5
8000adae:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000adb2:	a5 36       	mul	r6,r2
8000adb4:	0c 39       	cp.w	r9,r6
8000adb6:	c0 72       	brcc	8000adc4 <__avr32_umod64+0xb4>
8000adb8:	18 09       	add	r9,r12
8000adba:	18 39       	cp.w	r9,r12
8000adbc:	c0 43       	brcs	8000adc4 <__avr32_umod64+0xb4>
8000adbe:	0c 39       	cp.w	r9,r6
8000adc0:	f3 dc e3 09 	addcs	r9,r9,r12
8000adc4:	f2 06 01 06 	sub	r6,r9,r6
8000adc8:	f4 08 09 4e 	lsl	lr,r10,r8
8000adcc:	f8 0a 16 10 	lsr	r10,r12,0x10
8000add0:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000add4:	ec 0a 0d 02 	divu	r2,r6,r10
8000add8:	fc 09 16 10 	lsr	r9,lr,0x10
8000addc:	ea 02 02 4b 	mul	r11,r5,r2
8000ade0:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000ade4:	16 39       	cp.w	r9,r11
8000ade6:	c0 72       	brcc	8000adf4 <__avr32_umod64+0xe4>
8000ade8:	18 09       	add	r9,r12
8000adea:	18 39       	cp.w	r9,r12
8000adec:	c0 43       	brcs	8000adf4 <__avr32_umod64+0xe4>
8000adee:	16 39       	cp.w	r9,r11
8000adf0:	f3 dc e3 09 	addcs	r9,r9,r12
8000adf4:	f2 0b 01 0b 	sub	r11,r9,r11
8000adf8:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000adfc:	f6 0a 0d 0a 	divu	r10,r11,r10
8000ae00:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000ae04:	ea 0a 02 4a 	mul	r10,r5,r10
8000ae08:	14 3e       	cp.w	lr,r10
8000ae0a:	c0 72       	brcc	8000ae18 <__avr32_umod64+0x108>
8000ae0c:	18 0e       	add	lr,r12
8000ae0e:	18 3e       	cp.w	lr,r12
8000ae10:	c0 43       	brcs	8000ae18 <__avr32_umod64+0x108>
8000ae12:	14 3e       	cp.w	lr,r10
8000ae14:	fd dc e3 0e 	addcs	lr,lr,r12
8000ae18:	fc 0a 01 0a 	sub	r10,lr,r10
8000ae1c:	30 0b       	mov	r11,0
8000ae1e:	f4 08 0a 4a 	lsr	r10,r10,r8
8000ae22:	c7 b8       	rjmp	8000af18 <__avr32_umod64+0x208>
8000ae24:	16 39       	cp.w	r9,r11
8000ae26:	e0 8b 00 79 	brhi	8000af18 <__avr32_umod64+0x208>
8000ae2a:	f2 09 12 00 	clz	r9,r9
8000ae2e:	c1 21       	brne	8000ae52 <__avr32_umod64+0x142>
8000ae30:	10 3a       	cp.w	r10,r8
8000ae32:	5f 2b       	srhs	r11
8000ae34:	0a 31       	cp.w	r1,r5
8000ae36:	5f ba       	srhi	r10
8000ae38:	f7 ea 10 0a 	or	r10,r11,r10
8000ae3c:	f2 0a 18 00 	cp.b	r10,r9
8000ae40:	c0 60       	breq	8000ae4c <__avr32_umod64+0x13c>
8000ae42:	fc 08 01 0c 	sub	r12,lr,r8
8000ae46:	e2 05 01 46 	sbc	r6,r1,r5
8000ae4a:	18 9e       	mov	lr,r12
8000ae4c:	0c 9b       	mov	r11,r6
8000ae4e:	1c 9a       	mov	r10,lr
8000ae50:	c6 48       	rjmp	8000af18 <__avr32_umod64+0x208>
8000ae52:	ea 09 09 4c 	lsl	r12,r5,r9
8000ae56:	f2 06 11 20 	rsub	r6,r9,32
8000ae5a:	f6 09 09 4b 	lsl	r11,r11,r9
8000ae5e:	f0 09 09 42 	lsl	r2,r8,r9
8000ae62:	ef 46 ff f4 	st.w	r7[-12],r6
8000ae66:	f0 06 0a 48 	lsr	r8,r8,r6
8000ae6a:	18 48       	or	r8,r12
8000ae6c:	e2 06 0a 4c 	lsr	r12,r1,r6
8000ae70:	f4 09 09 43 	lsl	r3,r10,r9
8000ae74:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000ae78:	f4 06 0a 4a 	lsr	r10,r10,r6
8000ae7c:	16 4a       	or	r10,r11
8000ae7e:	f0 0b 16 10 	lsr	r11,r8,0x10
8000ae82:	f8 0b 0d 04 	divu	r4,r12,r11
8000ae86:	f4 0c 16 10 	lsr	r12,r10,0x10
8000ae8a:	08 91       	mov	r1,r4
8000ae8c:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000ae90:	e8 0e 02 46 	mul	r6,r4,lr
8000ae94:	0c 3c       	cp.w	r12,r6
8000ae96:	c0 a2       	brcc	8000aeaa <__avr32_umod64+0x19a>
8000ae98:	20 11       	sub	r1,1
8000ae9a:	10 0c       	add	r12,r8
8000ae9c:	10 3c       	cp.w	r12,r8
8000ae9e:	c0 63       	brcs	8000aeaa <__avr32_umod64+0x19a>
8000aea0:	0c 3c       	cp.w	r12,r6
8000aea2:	f7 b1 03 01 	sublo	r1,1
8000aea6:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000aeaa:	0c 1c       	sub	r12,r6
8000aeac:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000aeb0:	f8 0b 0d 04 	divu	r4,r12,r11
8000aeb4:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000aeb8:	08 96       	mov	r6,r4
8000aeba:	e8 0e 02 4e 	mul	lr,r4,lr
8000aebe:	1c 3b       	cp.w	r11,lr
8000aec0:	c0 a2       	brcc	8000aed4 <__avr32_umod64+0x1c4>
8000aec2:	20 16       	sub	r6,1
8000aec4:	10 0b       	add	r11,r8
8000aec6:	10 3b       	cp.w	r11,r8
8000aec8:	c0 63       	brcs	8000aed4 <__avr32_umod64+0x1c4>
8000aeca:	1c 3b       	cp.w	r11,lr
8000aecc:	f7 b6 03 01 	sublo	r6,1
8000aed0:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000aed4:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000aed8:	1c 1b       	sub	r11,lr
8000aeda:	e2 02 06 40 	mulu.d	r0,r1,r2
8000aede:	00 9e       	mov	lr,r0
8000aee0:	02 9c       	mov	r12,r1
8000aee2:	16 3c       	cp.w	r12,r11
8000aee4:	e0 8b 00 08 	brhi	8000aef4 <__avr32_umod64+0x1e4>
8000aee8:	5f 06       	sreq	r6
8000aeea:	06 30       	cp.w	r0,r3
8000aeec:	5f ba       	srhi	r10
8000aeee:	ed ea 00 0a 	and	r10,r6,r10
8000aef2:	c0 60       	breq	8000aefe <__avr32_umod64+0x1ee>
8000aef4:	fc 02 01 04 	sub	r4,lr,r2
8000aef8:	f8 08 01 4c 	sbc	r12,r12,r8
8000aefc:	08 9e       	mov	lr,r4
8000aefe:	e6 0e 01 0a 	sub	r10,r3,lr
8000af02:	f6 0c 01 4c 	sbc	r12,r11,r12
8000af06:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000af0a:	f8 09 0a 4b 	lsr	r11,r12,r9
8000af0e:	f4 09 0a 4a 	lsr	r10,r10,r9
8000af12:	f8 01 09 4c 	lsl	r12,r12,r1
8000af16:	18 4a       	or	r10,r12
8000af18:	2f dd       	sub	sp,-12
8000af1a:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000b000 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000b000:	c0 08       	rjmp	8000b000 <_evba>
	...

8000b004 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000b004:	c0 08       	rjmp	8000b004 <_handle_TLB_Multiple_Hit>
	...

8000b008 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000b008:	c0 08       	rjmp	8000b008 <_handle_Bus_Error_Data_Fetch>
	...

8000b00c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000b00c:	c0 08       	rjmp	8000b00c <_handle_Bus_Error_Instruction_Fetch>
	...

8000b010 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000b010:	c0 08       	rjmp	8000b010 <_handle_NMI>
	...

8000b014 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000b014:	c0 08       	rjmp	8000b014 <_handle_Instruction_Address>
	...

8000b018 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000b018:	c0 08       	rjmp	8000b018 <_handle_ITLB_Protection>
	...

8000b01c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000b01c:	c0 08       	rjmp	8000b01c <_handle_Breakpoint>
	...

8000b020 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000b020:	c0 08       	rjmp	8000b020 <_handle_Illegal_Opcode>
	...

8000b024 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000b024:	c0 08       	rjmp	8000b024 <_handle_Unimplemented_Instruction>
	...

8000b028 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000b028:	c0 08       	rjmp	8000b028 <_handle_Privilege_Violation>
	...

8000b02c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000b02c:	c0 08       	rjmp	8000b02c <_handle_Floating_Point>
	...

8000b030 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000b030:	c0 08       	rjmp	8000b030 <_handle_Coprocessor_Absent>
	...

8000b034 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000b034:	c0 08       	rjmp	8000b034 <_handle_Data_Address_Read>
	...

8000b038 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000b038:	c0 08       	rjmp	8000b038 <_handle_Data_Address_Write>
	...

8000b03c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000b03c:	c0 08       	rjmp	8000b03c <_handle_DTLB_Protection_Read>
	...

8000b040 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000b040:	c0 08       	rjmp	8000b040 <_handle_DTLB_Protection_Write>
	...

8000b044 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000b044:	c0 08       	rjmp	8000b044 <_handle_DTLB_Modified>
	...

8000b050 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000b050:	c0 08       	rjmp	8000b050 <_handle_ITLB_Miss>
	...

8000b060 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000b060:	c0 08       	rjmp	8000b060 <_handle_DTLB_Miss_Read>
	...

8000b070 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000b070:	c0 08       	rjmp	8000b070 <_handle_DTLB_Miss_Write>
	...

8000b100 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000b100:	fe cf 70 30 	sub	pc,pc,28720

8000b104 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000b104:	30 0c       	mov	r12,0
8000b106:	fe b0 c3 f3 	rcall	800038ec <_get_interrupt_handler>
8000b10a:	58 0c       	cp.w	r12,0
8000b10c:	f8 0f 17 10 	movne	pc,r12
8000b110:	d6 03       	rete

8000b112 <_int1>:
8000b112:	30 1c       	mov	r12,1
8000b114:	fe b0 c3 ec 	rcall	800038ec <_get_interrupt_handler>
8000b118:	58 0c       	cp.w	r12,0
8000b11a:	f8 0f 17 10 	movne	pc,r12
8000b11e:	d6 03       	rete

8000b120 <_int2>:
8000b120:	30 2c       	mov	r12,2
8000b122:	fe b0 c3 e5 	rcall	800038ec <_get_interrupt_handler>
8000b126:	58 0c       	cp.w	r12,0
8000b128:	f8 0f 17 10 	movne	pc,r12
8000b12c:	d6 03       	rete

8000b12e <_int3>:
8000b12e:	30 3c       	mov	r12,3
8000b130:	fe b0 c3 de 	rcall	800038ec <_get_interrupt_handler>
8000b134:	58 0c       	cp.w	r12,0
8000b136:	f8 0f 17 10 	movne	pc,r12
8000b13a:	d6 03       	rete

8000b13c <ipr_val>:
8000b13c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000b14c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b15c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b16c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b17c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b18c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b19c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b1ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b1bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b1cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b1dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b1ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000b1fc:	d7 03 d7 03                                         ....
