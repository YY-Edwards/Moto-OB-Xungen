
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000ac7c  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000ce00  8000ce00  0000d200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000012b8  8000d000  8000d000  0000d400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a3c  00000004  8000e2b8  0000e804  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00006fb0  00000a40  8000ecf4  0000f240  2**2
                  ALLOC
  7 .comment      00000030  00000000  00000000  0000f240  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00001688  00000000  00000000  0000f270  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 00003641  00000000  00000000  000108f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0002c4a0  00000000  00000000  00013f39  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 0000728c  00000000  00000000  000403d9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000d446  00000000  00000000  00047665  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00003d10  00000000  00000000  00054aac  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00007fb6  00000000  00000000  000587bc  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0000f385  00000000  00000000  00060772  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 17 .debug_ranges 00001750  00000000  00000000  0006faf8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c3 e4 	sub	pc,pc,-15388

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d a0       	ld.ub	r0,r6[0x2]

80002028 <Volume_brdcst_func>:
	//log("Attenuator_Number: %x \n",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("Audio_Parameter: %x \n", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 68       	and	r8,r5

8000203c <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
8000203c:	d4 01       	pushm	lr
  log("R");
8000203e:	48 3c       	lddpc	r12,80002048 <app_payload_tx_proc+0xc>
80002040:	f0 1f 00 03 	mcall	8000204c <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002044:	d8 02       	popm	pc
80002046:	00 00       	add	r0,r0
80002048:	80 00       	ld.sh	r0,r0[0x0]
8000204a:	d0 00       	acall	0x0
8000204c:	80 00       	ld.sh	r0,r0[0x0]
8000204e:	6f 78       	ld.w	r8,r7[0x5c]

80002050 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
80002050:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
80002052:	48 99       	lddpc	r9,80002074 <app_payload_rx_proc+0x24>
80002054:	13 88       	ld.ub	r8,r9[0x0]
80002056:	2f f8       	sub	r8,-1
80002058:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
8000205a:	30 39       	mov	r9,3
8000205c:	f2 08 18 00 	cp.b	r8,r9
80002060:	c0 71       	brne	8000206e <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
80002062:	30 09       	mov	r9,0
80002064:	48 48       	lddpc	r8,80002074 <app_payload_rx_proc+0x24>
80002066:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002068:	48 4c       	lddpc	r12,80002078 <app_payload_rx_proc+0x28>
8000206a:	f0 1f 00 05 	mcall	8000207c <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
8000206e:	48 58       	lddpc	r8,80002080 <app_payload_rx_proc+0x30>
80002070:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
80002072:	d8 02       	popm	pc
80002074:	00 00       	add	r0,r0
80002076:	0a 43       	or	r3,r5
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	d0 04       	*unknown*
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	6f 78       	ld.w	r8,r7[0x5c]
80002080:	00 00       	add	r0,r0
80002082:	0a 48       	or	r8,r5

80002084 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
80002084:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
80002086:	48 3c       	lddpc	r12,80002090 <FD_brdcst_func+0xc>
80002088:	f0 1f 00 03 	mcall	80002094 <FD_brdcst_func+0x10>
	
}
8000208c:	d8 02       	popm	pc
8000208e:	00 00       	add	r0,r0
80002090:	80 00       	ld.sh	r0,r0[0x0]
80002092:	d0 10       	acall	0x1
80002094:	80 00       	ld.sh	r0,r0[0x0]
80002096:	6f 78       	ld.w	r8,r7[0x5c]

80002098 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
80002098:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
8000209a:	48 3c       	lddpc	r12,800020a4 <FD_reply_func+0xc>
8000209c:	f0 1f 00 03 	mcall	800020a8 <FD_reply_func+0x10>
	
	
}
800020a0:	d8 02       	popm	pc
800020a2:	00 00       	add	r0,r0
800020a4:	80 00       	ld.sh	r0,r0[0x0]
800020a6:	d0 30       	acall	0x3
800020a8:	80 00       	ld.sh	r0,r0[0x0]
800020aa:	6f 78       	ld.w	r8,r7[0x5c]

800020ac <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020ac:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020ae:	48 3c       	lddpc	r12,800020b8 <FD_request_func+0xc>
800020b0:	f0 1f 00 03 	mcall	800020bc <FD_request_func+0x10>
	
	
}
800020b4:	d8 02       	popm	pc
800020b6:	00 00       	add	r0,r0
800020b8:	80 00       	ld.sh	r0,r0[0x0]
800020ba:	d0 4c       	*unknown*
800020bc:	80 00       	ld.sh	r0,r0[0x0]
800020be:	6f 78       	ld.w	r8,r7[0x5c]

800020c0 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020c0:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020c2:	48 3c       	lddpc	r12,800020cc <EnOB_brdcst_func+0xc>
800020c4:	f0 1f 00 03 	mcall	800020d0 <EnOB_brdcst_func+0x10>
}
800020c8:	d8 02       	popm	pc
800020ca:	00 00       	add	r0,r0
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	d0 68       	*unknown*
800020d0:	80 00       	ld.sh	r0,r0[0x0]
800020d2:	6f 78       	ld.w	r8,r7[0x5c]

800020d4 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020d4:	eb cd 40 80 	pushm	r7,lr
800020d8:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020da:	19 a9       	ld.ub	r9,r12[0x2]
800020dc:	30 08       	mov	r8,0
800020de:	f0 09 18 00 	cp.b	r9,r8
800020e2:	c1 91       	brne	80002114 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
800020e4:	19 b8       	ld.ub	r8,r12[0x3]
800020e6:	30 19       	mov	r9,1
800020e8:	f2 08 18 00 	cp.b	r8,r9
800020ec:	c0 61       	brne	800020f8 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
800020ee:	49 0c       	lddpc	r12,8000212c <EnOB_reply_func+0x58>
800020f0:	f0 1f 00 10 	mcall	80002130 <EnOB_reply_func+0x5c>
800020f4:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
800020f8:	58 08       	cp.w	r8,0
800020fa:	c0 61       	brne	80002106 <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
800020fc:	48 ec       	lddpc	r12,80002134 <EnOB_reply_func+0x60>
800020fe:	f0 1f 00 0d 	mcall	80002130 <EnOB_reply_func+0x5c>
80002102:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
80002106:	1a d8       	st.w	--sp,r8
80002108:	48 cc       	lddpc	r12,80002138 <EnOB_reply_func+0x64>
8000210a:	f0 1f 00 0a 	mcall	80002130 <EnOB_reply_func+0x5c>
8000210e:	2f fd       	sub	sp,-4
80002110:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002114:	48 ac       	lddpc	r12,8000213c <EnOB_reply_func+0x68>
80002116:	f0 1f 00 07 	mcall	80002130 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000211a:	0f a8       	ld.ub	r8,r7[0x2]
8000211c:	1a d8       	st.w	--sp,r8
8000211e:	48 9c       	lddpc	r12,80002140 <EnOB_reply_func+0x6c>
80002120:	f0 1f 00 04 	mcall	80002130 <EnOB_reply_func+0x5c>
80002124:	2f fd       	sub	sp,-4
80002126:	e3 cd 80 80 	ldm	sp++,r7,pc
8000212a:	00 00       	add	r0,r0
8000212c:	80 00       	ld.sh	r0,r0[0x0]
8000212e:	d0 80       	acall	0x8
80002130:	80 00       	ld.sh	r0,r0[0x0]
80002132:	6f 78       	ld.w	r8,r7[0x5c]
80002134:	80 00       	ld.sh	r0,r0[0x0]
80002136:	d0 98       	*unknown*
80002138:	80 00       	ld.sh	r0,r0[0x0]
8000213a:	d0 ac       	*unknown*
8000213c:	80 00       	ld.sh	r0,r0[0x0]
8000213e:	d0 c4       	*unknown*
80002140:	80 00       	ld.sh	r0,r0[0x0]
80002142:	d0 e0       	acall	0xe

80002144 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002144:	eb cd 40 80 	pushm	r7,lr
80002148:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000214a:	19 a9       	ld.ub	r9,r12[0x2]
8000214c:	31 18       	mov	r8,17
8000214e:	f0 09 18 00 	cp.b	r9,r8
80002152:	c0 91       	brne	80002164 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002154:	48 ac       	lddpc	r12,8000217c <SingleDetection_brdcst_func+0x38>
80002156:	f0 1f 00 0b 	mcall	80002180 <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
8000215a:	30 19       	mov	r9,1
8000215c:	48 a8       	lddpc	r8,80002184 <SingleDetection_brdcst_func+0x40>
8000215e:	b0 89       	st.b	r8[0x0],r9
80002160:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
80002164:	48 9c       	lddpc	r12,80002188 <SingleDetection_brdcst_func+0x44>
80002166:	f0 1f 00 07 	mcall	80002180 <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
8000216a:	0f a8       	ld.ub	r8,r7[0x2]
8000216c:	1a d8       	st.w	--sp,r8
8000216e:	48 8c       	lddpc	r12,8000218c <SingleDetection_brdcst_func+0x48>
80002170:	f0 1f 00 04 	mcall	80002180 <SingleDetection_brdcst_func+0x3c>
80002174:	2f fd       	sub	sp,-4
80002176:	e3 cd 80 80 	ldm	sp++,r7,pc
8000217a:	00 00       	add	r0,r0
8000217c:	80 00       	ld.sh	r0,r0[0x0]
8000217e:	d0 f8       	*unknown*
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	6f 78       	ld.w	r8,r7[0x5c]
80002184:	00 00       	add	r0,r0
80002186:	00 04       	add	r4,r0
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	d1 0c       	*unknown*
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	d1 1c       	*unknown*

80002190 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002190:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
80002192:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
80002196:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002198:	4a bc       	lddpc	r12,80002244 <ButtonConfig_brdcst_func+0xb4>
8000219a:	f0 1f 00 2c 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
8000219e:	0f 88       	ld.ub	r8,r7[0x0]
800021a0:	1a d8       	st.w	--sp,r8
800021a2:	4a bc       	lddpc	r12,8000224c <ButtonConfig_brdcst_func+0xbc>
800021a4:	f0 1f 00 29 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021a8:	1a d5       	st.w	--sp,r5
800021aa:	4a ac       	lddpc	r12,80002250 <ButtonConfig_brdcst_func+0xc0>
800021ac:	f0 1f 00 27 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021b0:	0f a8       	ld.ub	r8,r7[0x2]
800021b2:	1a d8       	st.w	--sp,r8
800021b4:	4a 8c       	lddpc	r12,80002254 <ButtonConfig_brdcst_func+0xc4>
800021b6:	f0 1f 00 25 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021ba:	2f dd       	sub	sp,-12
800021bc:	58 05       	cp.w	r5,0
800021be:	c4 10       	breq	80002240 <ButtonConfig_brdcst_func+0xb0>
800021c0:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021c2:	4a 64       	lddpc	r4,80002258 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021c4:	4a 63       	lddpc	r3,8000225c <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021c6:	4a 72       	lddpc	r2,80002260 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021c8:	4a 71       	lddpc	r1,80002264 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021ca:	4a 80       	lddpc	r0,80002268 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021cc:	0f b9       	ld.ub	r9,r7[0x3]
800021ce:	0f c8       	ld.ub	r8,r7[0x4]
800021d0:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021d4:	1a d8       	st.w	--sp,r8
800021d6:	1a d6       	st.w	--sp,r6
800021d8:	08 9c       	mov	r12,r4
800021da:	f0 1f 00 1c 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021de:	0f d9       	ld.ub	r9,r7[0x5]
800021e0:	0f e8       	ld.ub	r8,r7[0x6]
800021e2:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021e6:	1a d8       	st.w	--sp,r8
800021e8:	1a d6       	st.w	--sp,r6
800021ea:	06 9c       	mov	r12,r3
800021ec:	f0 1f 00 17 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021f0:	0f f9       	ld.ub	r9,r7[0x7]
800021f2:	ef 38 00 08 	ld.ub	r8,r7[8]
800021f6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021fa:	1a d8       	st.w	--sp,r8
800021fc:	1a d6       	st.w	--sp,r6
800021fe:	04 9c       	mov	r12,r2
80002200:	f0 1f 00 12 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002204:	ef 39 00 09 	ld.ub	r9,r7[9]
80002208:	ef 38 00 0a 	ld.ub	r8,r7[10]
8000220c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002210:	1a d8       	st.w	--sp,r8
80002212:	1a d6       	st.w	--sp,r6
80002214:	02 9c       	mov	r12,r1
80002216:	f0 1f 00 0d 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000221a:	2f 8d       	sub	sp,-32
8000221c:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002220:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002228:	1a d8       	st.w	--sp,r8
8000222a:	1a d6       	st.w	--sp,r6
8000222c:	00 9c       	mov	r12,r0
8000222e:	f0 1f 00 07 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
80002232:	2f f6       	sub	r6,-1
80002234:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
80002236:	2f ed       	sub	sp,-8
80002238:	ec 05 18 00 	cp.b	r5,r6
8000223c:	fe 9b ff c8 	brhi	800021cc <ButtonConfig_brdcst_func+0x3c>
80002240:	d8 32       	popm	r0-r7,pc
80002242:	00 00       	add	r0,r0
80002244:	80 00       	ld.sh	r0,r0[0x0]
80002246:	d1 30       	acall	0x13
80002248:	80 00       	ld.sh	r0,r0[0x0]
8000224a:	6f 78       	ld.w	r8,r7[0x5c]
8000224c:	80 00       	ld.sh	r0,r0[0x0]
8000224e:	d1 50       	acall	0x15
80002250:	80 00       	ld.sh	r0,r0[0x0]
80002252:	d1 64       	*unknown*
80002254:	80 00       	ld.sh	r0,r0[0x0]
80002256:	d1 7c       	*unknown*
80002258:	80 00       	ld.sh	r0,r0[0x0]
8000225a:	d1 9c       	*unknown*
8000225c:	80 00       	ld.sh	r0,r0[0x0]
8000225e:	d1 c4       	*unknown*
80002260:	80 00       	ld.sh	r0,r0[0x0]
80002262:	d1 ec       	*unknown*
80002264:	80 00       	ld.sh	r0,r0[0x0]
80002266:	d2 10       	acall	0x21
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	d2 38       	*unknown*

8000226c <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
8000226c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002270:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002274:	0f 89       	ld.ub	r9,r7[0x0]
80002276:	30 08       	mov	r8,0
80002278:	f0 09 18 00 	cp.b	r9,r8
8000227c:	c0 c1       	brne	80002294 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000227e:	48 9c       	lddpc	r12,800022a0 <ButtonConfig_reply_func+0x34>
80002280:	f0 1f 00 09 	mcall	800022a4 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002284:	0f 98       	ld.ub	r8,r7[0x1]
80002286:	1a d8       	st.w	--sp,r8
80002288:	48 8c       	lddpc	r12,800022a8 <ButtonConfig_reply_func+0x3c>
8000228a:	f0 1f 00 07 	mcall	800022a4 <ButtonConfig_reply_func+0x38>
8000228e:	2f fd       	sub	sp,-4
80002290:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002294:	48 6c       	lddpc	r12,800022ac <ButtonConfig_reply_func+0x40>
80002296:	f0 1f 00 04 	mcall	800022a4 <ButtonConfig_reply_func+0x38>
8000229a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000229e:	00 00       	add	r0,r0
800022a0:	80 00       	ld.sh	r0,r0[0x0]
800022a2:	d2 5c       	*unknown*
800022a4:	80 00       	ld.sh	r0,r0[0x0]
800022a6:	6f 78       	ld.w	r8,r7[0x5c]
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	d1 50       	acall	0x15
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	d2 74       	*unknown*

800022b0 <BatteryLevel_brdcst_func>:
	
}


void BatteryLevel_brdcst_func(xcmp_fragment_t * xcmp)
{
800022b0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	BatteryLevel_brdcast_t *ptr = (BatteryLevel_brdcast_t* )(xcmp->u8);
800022b4:	f8 c7 ff fe 	sub	r7,r12,-2
	if(ptr->State == Battery_Okay)
800022b8:	0f 89       	ld.ub	r9,r7[0x0]
800022ba:	30 08       	mov	r8,0
800022bc:	f0 09 18 00 	cp.b	r9,r8
800022c0:	c0 51       	brne	800022ca <BatteryLevel_brdcst_func+0x1a>
		log("\n Battery Okay\n");
800022c2:	48 7c       	lddpc	r12,800022dc <BatteryLevel_brdcst_func+0x2c>
800022c4:	f0 1f 00 07 	mcall	800022e0 <BatteryLevel_brdcst_func+0x30>
800022c8:	c0 48       	rjmp	800022d0 <BatteryLevel_brdcst_func+0x20>
	else
		log("\n Battery Low !!!\n");
800022ca:	48 7c       	lddpc	r12,800022e4 <BatteryLevel_brdcst_func+0x34>
800022cc:	f0 1f 00 05 	mcall	800022e0 <BatteryLevel_brdcst_func+0x30>
		
	//log("\n Battery charge: %X \n" , ptr->Charge);
	//log("\n Battery voltage: %X \n" , ptr->Voltage);
	
	Battery_Flag = ptr->State;
800022d0:	0f 89       	ld.ub	r9,r7[0x0]
800022d2:	48 68       	lddpc	r8,800022e8 <BatteryLevel_brdcst_func+0x38>
800022d4:	b0 89       	st.b	r8[0x0],r9

}
800022d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800022da:	00 00       	add	r0,r0
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	d2 90       	acall	0x29
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	6f 78       	ld.w	r8,r7[0x5c]
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	d2 a0       	acall	0x2a
800022e8:	00 00       	add	r0,r0
800022ea:	0a 41       	or	r1,r5

800022ec <ShutDown_brdcst_func>:
		log("ID:  %X \n", xcmp->u8[2]);
	}
	
}
void ShutDown_brdcst_func(xcmp_fragment_t * xcmp)
{
800022ec:	d4 01       	pushm	lr
	if (xcmp->u8[0] == Shut_Down_Device)
800022ee:	19 a8       	ld.ub	r8,r12[0x2]
800022f0:	30 19       	mov	r9,1
800022f2:	f2 08 18 00 	cp.b	r8,r9
800022f6:	c0 51       	brne	80002300 <ShutDown_brdcst_func+0x14>
	{
		log("Shut_Down_Device \n");
800022f8:	48 6c       	lddpc	r12,80002310 <ShutDown_brdcst_func+0x24>
800022fa:	f0 1f 00 07 	mcall	80002314 <ShutDown_brdcst_func+0x28>
800022fe:	d8 02       	popm	pc
		
	}
	else if(xcmp->u8[0] == Reset_Device)
80002300:	30 29       	mov	r9,2
80002302:	f2 08 18 00 	cp.b	r8,r9
80002306:	c0 41       	brne	8000230e <ShutDown_brdcst_func+0x22>
	{
		log("Reset_Device \n");
80002308:	48 4c       	lddpc	r12,80002318 <ShutDown_brdcst_func+0x2c>
8000230a:	f0 1f 00 03 	mcall	80002314 <ShutDown_brdcst_func+0x28>
8000230e:	d8 02       	popm	pc
80002310:	80 00       	ld.sh	r0,r0[0x0]
80002312:	d2 b4       	*unknown*
80002314:	80 00       	ld.sh	r0,r0[0x0]
80002316:	6f 78       	ld.w	r8,r7[0x5c]
80002318:	80 00       	ld.sh	r0,r0[0x0]
8000231a:	d2 c8       	*unknown*

8000231c <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
8000231c:	eb cd 40 80 	pushm	r7,lr
80002320:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002322:	19 a9       	ld.ub	r9,r12[0x2]
80002324:	30 08       	mov	r8,0
80002326:	f0 09 18 00 	cp.b	r9,r8
8000232a:	c0 61       	brne	80002336 <DataSession_reply_func+0x1a>
	{
		log("DATArep OK \n");
8000232c:	48 dc       	lddpc	r12,80002360 <DataSession_reply_func+0x44>
8000232e:	f0 1f 00 0e 	mcall	80002364 <DataSession_reply_func+0x48>
80002332:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("ID: %X \n", xcmp->u8[2]);
		
	}
	else
	{	
		log("DATArep error \n");
80002336:	48 dc       	lddpc	r12,80002368 <DataSession_reply_func+0x4c>
80002338:	f0 1f 00 0b 	mcall	80002364 <DataSession_reply_func+0x48>
		log("Result:  %X \n", xcmp->u8[0]);
8000233c:	0f a8       	ld.ub	r8,r7[0x2]
8000233e:	1a d8       	st.w	--sp,r8
80002340:	48 bc       	lddpc	r12,8000236c <DataSession_reply_func+0x50>
80002342:	f0 1f 00 09 	mcall	80002364 <DataSession_reply_func+0x48>
		log("Func:  %X \n", xcmp->u8[1]);
80002346:	0f b8       	ld.ub	r8,r7[0x3]
80002348:	1a d8       	st.w	--sp,r8
8000234a:	48 ac       	lddpc	r12,80002370 <DataSession_reply_func+0x54>
8000234c:	f0 1f 00 06 	mcall	80002364 <DataSession_reply_func+0x48>
		log("ID:  %X \n", xcmp->u8[2]);
80002350:	0f c8       	ld.ub	r8,r7[0x4]
80002352:	1a d8       	st.w	--sp,r8
80002354:	48 8c       	lddpc	r12,80002374 <DataSession_reply_func+0x58>
80002356:	f0 1f 00 04 	mcall	80002364 <DataSession_reply_func+0x48>
8000235a:	2f dd       	sub	sp,-12
8000235c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	d2 d8       	*unknown*
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	6f 78       	ld.w	r8,r7[0x5c]
80002368:	80 00       	ld.sh	r0,r0[0x0]
8000236a:	d2 e8       	*unknown*
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	d2 f8       	*unknown*
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	d3 08       	*unknown*
80002374:	80 00       	ld.sh	r0,r0[0x0]
80002376:	d3 14       	*unknown*

80002378 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002378:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
8000237c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002380:	0f 98       	ld.ub	r8,r7[0x1]
80002382:	1a d8       	st.w	--sp,r8
80002384:	48 bc       	lddpc	r12,800023b0 <CallControl_brdcst_func+0x38>
80002386:	f0 1f 00 0c 	mcall	800023b4 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000238a:	2f fd       	sub	sp,-4
8000238c:	0f 99       	ld.ub	r9,r7[0x1]
8000238e:	30 38       	mov	r8,3
80002390:	f0 09 18 00 	cp.b	r9,r8
80002394:	c0 41       	brne	8000239c <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
80002396:	30 09       	mov	r9,0
80002398:	48 88       	lddpc	r8,800023b8 <CallControl_brdcst_func+0x40>
8000239a:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
8000239c:	0f 99       	ld.ub	r9,r7[0x1]
8000239e:	30 48       	mov	r8,4
800023a0:	f0 09 18 00 	cp.b	r9,r8
800023a4:	c0 41       	brne	800023ac <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800023a6:	30 19       	mov	r9,1
800023a8:	48 48       	lddpc	r8,800023b8 <CallControl_brdcst_func+0x40>
800023aa:	b0 89       	st.b	r8[0x0],r9
800023ac:	e3 cd 80 80 	ldm	sp++,r7,pc
800023b0:	80 00       	ld.sh	r0,r0[0x0]
800023b2:	d3 20       	acall	0x32
800023b4:	80 00       	ld.sh	r0,r0[0x0]
800023b6:	6f 78       	ld.w	r8,r7[0x5c]
800023b8:	00 00       	add	r0,r0
800023ba:	0a 4a       	or	r10,r5

800023bc <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023bc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800023c0:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800023c4:	0f 99       	ld.ub	r9,r7[0x1]
800023c6:	30 08       	mov	r8,0
800023c8:	f0 09 18 00 	cp.b	r9,r8
800023cc:	c0 71       	brne	800023da <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800023ce:	48 ac       	lddpc	r12,800023f4 <TransmitControl_brdcst_func+0x38>
800023d0:	f0 1f 00 0a 	mcall	800023f8 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800023d4:	30 09       	mov	r9,0
800023d6:	48 a8       	lddpc	r8,800023fc <TransmitControl_brdcst_func+0x40>
800023d8:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800023da:	0f 99       	ld.ub	r9,r7[0x1]
800023dc:	30 18       	mov	r8,1
800023de:	f0 09 18 00 	cp.b	r9,r8
800023e2:	c0 71       	brne	800023f0 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800023e4:	48 7c       	lddpc	r12,80002400 <TransmitControl_brdcst_func+0x44>
800023e6:	f0 1f 00 05 	mcall	800023f8 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800023ea:	30 19       	mov	r9,1
800023ec:	48 48       	lddpc	r8,800023fc <TransmitControl_brdcst_func+0x40>
800023ee:	b0 89       	st.b	r8[0x0],r9
800023f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800023f4:	80 00       	ld.sh	r0,r0[0x0]
800023f6:	d3 38       	*unknown*
800023f8:	80 00       	ld.sh	r0,r0[0x0]
800023fa:	6f 78       	ld.w	r8,r7[0x5c]
800023fc:	00 00       	add	r0,r0
800023fe:	0a 49       	or	r9,r5
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	d3 50       	acall	0x35

80002404 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002404:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002408:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000240c:	0f 89       	ld.ub	r9,r7[0x0]
8000240e:	30 08       	mov	r8,0
80002410:	f0 09 18 00 	cp.b	r9,r8
80002414:	c1 61       	brne	80002440 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002416:	48 ec       	lddpc	r12,8000244c <TransmitControl_reply_func+0x48>
80002418:	f0 1f 00 0e 	mcall	80002450 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
8000241c:	0f 98       	ld.ub	r8,r7[0x1]
8000241e:	1a d8       	st.w	--sp,r8
80002420:	48 dc       	lddpc	r12,80002454 <TransmitControl_reply_func+0x50>
80002422:	f0 1f 00 0c 	mcall	80002450 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002426:	0f a8       	ld.ub	r8,r7[0x2]
80002428:	1a d8       	st.w	--sp,r8
8000242a:	48 cc       	lddpc	r12,80002458 <TransmitControl_reply_func+0x54>
8000242c:	f0 1f 00 09 	mcall	80002450 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002430:	0f b8       	ld.ub	r8,r7[0x3]
80002432:	1a d8       	st.w	--sp,r8
80002434:	48 ac       	lddpc	r12,8000245c <TransmitControl_reply_func+0x58>
80002436:	f0 1f 00 07 	mcall	80002450 <TransmitControl_reply_func+0x4c>
8000243a:	2f dd       	sub	sp,-12
8000243c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002440:	48 8c       	lddpc	r12,80002460 <TransmitControl_reply_func+0x5c>
80002442:	f0 1f 00 04 	mcall	80002450 <TransmitControl_reply_func+0x4c>
80002446:	e3 cd 80 80 	ldm	sp++,r7,pc
8000244a:	00 00       	add	r0,r0
8000244c:	80 00       	ld.sh	r0,r0[0x0]
8000244e:	d3 64       	*unknown*
80002450:	80 00       	ld.sh	r0,r0[0x0]
80002452:	6f 78       	ld.w	r8,r7[0x5c]
80002454:	80 00       	ld.sh	r0,r0[0x0]
80002456:	d3 80       	acall	0x38
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	d3 94       	*unknown*
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	d3 b0       	acall	0x3b
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	d3 c0       	acall	0x3c

80002464 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002464:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002466:	19 a9       	ld.ub	r9,r12[0x2]
80002468:	30 08       	mov	r8,0
8000246a:	f0 09 18 00 	cp.b	r9,r8
8000246e:	c0 51       	brne	80002478 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002470:	48 4c       	lddpc	r12,80002480 <AudioRoutingControl_reply_func+0x1c>
80002472:	f0 1f 00 05 	mcall	80002484 <AudioRoutingControl_reply_func+0x20>
80002476:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002478:	48 4c       	lddpc	r12,80002488 <AudioRoutingControl_reply_func+0x24>
8000247a:	f0 1f 00 03 	mcall	80002484 <AudioRoutingControl_reply_func+0x20>
8000247e:	d8 02       	popm	pc
80002480:	80 00       	ld.sh	r0,r0[0x0]
80002482:	d3 d8       	*unknown*
80002484:	80 00       	ld.sh	r0,r0[0x0]
80002486:	6f 78       	ld.w	r8,r7[0x5c]
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	d3 e8       	*unknown*

8000248c <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
8000248c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002490:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80002494:	0f 89       	ld.ub	r9,r7[0x0]
80002496:	30 08       	mov	r8,0
80002498:	f0 09 18 00 	cp.b	r9,r8
8000249c:	c1 b1       	brne	800024d2 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
8000249e:	0f b8       	ld.ub	r8,r7[0x3]
800024a0:	31 09       	mov	r9,16
800024a2:	f2 08 18 00 	cp.b	r8,r9
800024a6:	c0 f1       	brne	800024c4 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800024a8:	48 dc       	lddpc	r12,800024dc <Volume_reply_func+0x50>
800024aa:	f0 1f 00 0e 	mcall	800024e0 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800024ae:	0f 99       	ld.ub	r9,r7[0x1]
800024b0:	0f a8       	ld.ub	r8,r7[0x2]
800024b2:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800024b6:	1a d8       	st.w	--sp,r8
800024b8:	48 bc       	lddpc	r12,800024e4 <Volume_reply_func+0x58>
800024ba:	f0 1f 00 0a 	mcall	800024e0 <Volume_reply_func+0x54>
800024be:	2f fd       	sub	sp,-4
800024c0:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800024c4:	1a d8       	st.w	--sp,r8
800024c6:	48 9c       	lddpc	r12,800024e8 <Volume_reply_func+0x5c>
800024c8:	f0 1f 00 06 	mcall	800024e0 <Volume_reply_func+0x54>
800024cc:	2f fd       	sub	sp,-4
800024ce:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024d2:	48 7c       	lddpc	r12,800024ec <Volume_reply_func+0x60>
800024d4:	f0 1f 00 03 	mcall	800024e0 <Volume_reply_func+0x54>
800024d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800024dc:	80 00       	ld.sh	r0,r0[0x0]
800024de:	d3 fc       	*unknown*
800024e0:	80 00       	ld.sh	r0,r0[0x0]
800024e2:	6f 78       	ld.w	r8,r7[0x5c]
800024e4:	80 00       	ld.sh	r0,r0[0x0]
800024e6:	d4 10       	acall	0x41
800024e8:	80 00       	ld.sh	r0,r0[0x0]
800024ea:	d4 2c       	*unknown*
800024ec:	80 00       	ld.sh	r0,r0[0x0]
800024ee:	d4 44       	*unknown*

800024f0 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800024f0:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800024f2:	19 d9       	ld.ub	r9,r12[0x5]
800024f4:	30 08       	mov	r8,0
800024f6:	f0 09 18 00 	cp.b	r9,r8
800024fa:	c0 81       	brne	8000250a <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
800024fc:	10 99       	mov	r9,r8
800024fe:	48 78       	lddpc	r8,80002518 <spk_brdcst_func+0x28>
80002500:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
80002502:	48 7c       	lddpc	r12,8000251c <spk_brdcst_func+0x2c>
80002504:	f0 1f 00 07 	mcall	80002520 <spk_brdcst_func+0x30>
80002508:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
8000250a:	30 19       	mov	r9,1
8000250c:	48 38       	lddpc	r8,80002518 <spk_brdcst_func+0x28>
8000250e:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002510:	48 5c       	lddpc	r12,80002524 <spk_brdcst_func+0x34>
80002512:	f0 1f 00 04 	mcall	80002520 <spk_brdcst_func+0x30>
80002516:	d8 02       	popm	pc
80002518:	00 00       	add	r0,r0
8000251a:	0a 40       	or	r0,r5
8000251c:	80 00       	ld.sh	r0,r0[0x0]
8000251e:	d4 5c       	*unknown*
80002520:	80 00       	ld.sh	r0,r0[0x0]
80002522:	6f 78       	ld.w	r8,r7[0x5c]
80002524:	80 00       	ld.sh	r0,r0[0x0]
80002526:	d4 6c       	*unknown*

80002528 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002528:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000252a:	19 a9       	ld.ub	r9,r12[0x2]
8000252c:	30 08       	mov	r8,0
8000252e:	f0 09 18 00 	cp.b	r9,r8
80002532:	c0 f1       	brne	80002550 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002534:	19 e9       	ld.ub	r9,r12[0x6]
80002536:	f0 09 18 00 	cp.b	r9,r8
8000253a:	c0 40       	breq	80002542 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
8000253c:	30 19       	mov	r9,1
8000253e:	48 98       	lddpc	r8,80002560 <spk_reply_func+0x38>
80002540:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80002542:	19 e8       	ld.ub	r8,r12[0x6]
80002544:	1a d8       	st.w	--sp,r8
80002546:	48 8c       	lddpc	r12,80002564 <spk_reply_func+0x3c>
80002548:	f0 1f 00 08 	mcall	80002568 <spk_reply_func+0x40>
8000254c:	2f fd       	sub	sp,-4
8000254e:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002550:	30 09       	mov	r9,0
80002552:	48 48       	lddpc	r8,80002560 <spk_reply_func+0x38>
80002554:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
80002556:	48 6c       	lddpc	r12,8000256c <spk_reply_func+0x44>
80002558:	f0 1f 00 04 	mcall	80002568 <spk_reply_func+0x40>
8000255c:	d8 02       	popm	pc
8000255e:	00 00       	add	r0,r0
80002560:	00 00       	add	r0,r0
80002562:	0a 40       	or	r0,r5
80002564:	80 00       	ld.sh	r0,r0[0x0]
80002566:	d4 78       	*unknown*
80002568:	80 00       	ld.sh	r0,r0[0x0]
8000256a:	6f 78       	ld.w	r8,r7[0x5c]
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	d4 88       	*unknown*

80002570 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002570:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002574:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002578:	0f a9       	ld.ub	r9,r7[0x2]
8000257a:	30 08       	mov	r8,0
8000257c:	f0 09 18 00 	cp.b	r9,r8
80002580:	c0 71       	brne	8000258e <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
80002582:	48 dc       	lddpc	r12,800025b4 <mic_brdcst_func+0x44>
80002584:	f0 1f 00 0d 	mcall	800025b8 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002588:	30 09       	mov	r9,0
8000258a:	48 d8       	lddpc	r8,800025bc <mic_brdcst_func+0x4c>
8000258c:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
8000258e:	0f a9       	ld.ub	r9,r7[0x2]
80002590:	31 18       	mov	r8,17
80002592:	f0 09 18 00 	cp.b	r9,r8
80002596:	c0 d1       	brne	800025b0 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
80002598:	48 ac       	lddpc	r12,800025c0 <mic_brdcst_func+0x50>
8000259a:	f0 1f 00 08 	mcall	800025b8 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
8000259e:	48 89       	lddpc	r9,800025bc <mic_brdcst_func+0x4c>
800025a0:	30 18       	mov	r8,1
800025a2:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800025a4:	13 89       	ld.ub	r9,r9[0x0]
800025a6:	f0 09 18 00 	cp.b	r9,r8
800025aa:	c0 31       	brne	800025b0 <mic_brdcst_func+0x40>
800025ac:	48 68       	lddpc	r8,800025c4 <mic_brdcst_func+0x54>
800025ae:	11 88       	ld.ub	r8,r8[0x0]
800025b0:	e3 cd 80 80 	ldm	sp++,r7,pc
800025b4:	80 00       	ld.sh	r0,r0[0x0]
800025b6:	d4 94       	*unknown*
800025b8:	80 00       	ld.sh	r0,r0[0x0]
800025ba:	6f 78       	ld.w	r8,r7[0x5c]
800025bc:	00 00       	add	r0,r0
800025be:	0a 5c       	eor	r12,r5
800025c0:	80 00       	ld.sh	r0,r0[0x0]
800025c2:	d4 a8       	*unknown*
800025c4:	00 00       	add	r0,r0
800025c6:	0a 4a       	or	r10,r5

800025c8 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025c8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025cc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025d0:	49 ac       	lddpc	r12,80002638 <mic_reply_func+0x70>
800025d2:	f0 1f 00 1b 	mcall	8000263c <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025d6:	0f 89       	ld.ub	r9,r7[0x0]
800025d8:	30 08       	mov	r8,0
800025da:	f0 09 18 00 	cp.b	r9,r8
800025de:	c2 71       	brne	8000262c <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025e0:	0f 98       	ld.ub	r8,r7[0x1]
800025e2:	30 29       	mov	r9,2
800025e4:	f2 08 18 00 	cp.b	r8,r9
800025e8:	c1 b1       	brne	8000261e <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800025ea:	49 6c       	lddpc	r12,80002640 <mic_reply_func+0x78>
800025ec:	f0 1f 00 14 	mcall	8000263c <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800025f0:	0f a8       	ld.ub	r8,r7[0x2]
800025f2:	1a d8       	st.w	--sp,r8
800025f4:	49 4c       	lddpc	r12,80002644 <mic_reply_func+0x7c>
800025f6:	f0 1f 00 12 	mcall	8000263c <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
800025fa:	0f b8       	ld.ub	r8,r7[0x3]
800025fc:	1a d8       	st.w	--sp,r8
800025fe:	49 3c       	lddpc	r12,80002648 <mic_reply_func+0x80>
80002600:	f0 1f 00 0f 	mcall	8000263c <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002604:	0f c8       	ld.ub	r8,r7[0x4]
80002606:	1a d8       	st.w	--sp,r8
80002608:	49 1c       	lddpc	r12,8000264c <mic_reply_func+0x84>
8000260a:	f0 1f 00 0d 	mcall	8000263c <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
8000260e:	0f d8       	ld.ub	r8,r7[0x5]
80002610:	1a d8       	st.w	--sp,r8
80002612:	49 0c       	lddpc	r12,80002650 <mic_reply_func+0x88>
80002614:	f0 1f 00 0a 	mcall	8000263c <mic_reply_func+0x74>
80002618:	2f cd       	sub	sp,-16
8000261a:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
8000261e:	1a d8       	st.w	--sp,r8
80002620:	48 dc       	lddpc	r12,80002654 <mic_reply_func+0x8c>
80002622:	f0 1f 00 07 	mcall	8000263c <mic_reply_func+0x74>
80002626:	2f fd       	sub	sp,-4
80002628:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
8000262c:	48 bc       	lddpc	r12,80002658 <mic_reply_func+0x90>
8000262e:	f0 1f 00 04 	mcall	8000263c <mic_reply_func+0x74>
80002632:	e3 cd 80 80 	ldm	sp++,r7,pc
80002636:	00 00       	add	r0,r0
80002638:	80 00       	ld.sh	r0,r0[0x0]
8000263a:	d4 bc       	*unknown*
8000263c:	80 00       	ld.sh	r0,r0[0x0]
8000263e:	6f 78       	ld.w	r8,r7[0x5c]
80002640:	80 00       	ld.sh	r0,r0[0x0]
80002642:	d4 cc       	*unknown*
80002644:	80 00       	ld.sh	r0,r0[0x0]
80002646:	d4 e0       	acall	0x4e
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	d4 f4       	*unknown*
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	d5 10       	acall	0x51
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	d5 28       	*unknown*
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	d5 40       	acall	0x54
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	d5 58       	*unknown*

8000265c <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
8000265c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002660:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002664:	48 bc       	lddpc	r12,80002690 <dcm_brdcst_func+0x34>
80002666:	f0 1f 00 0c 	mcall	80002694 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
8000266a:	0f 88       	ld.ub	r8,r7[0x0]
8000266c:	1a d8       	st.w	--sp,r8
8000266e:	48 bc       	lddpc	r12,80002698 <dcm_brdcst_func+0x3c>
80002670:	f0 1f 00 09 	mcall	80002694 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002674:	0f a8       	ld.ub	r8,r7[0x2]
80002676:	1a d8       	st.w	--sp,r8
80002678:	48 9c       	lddpc	r12,8000269c <dcm_brdcst_func+0x40>
8000267a:	f0 1f 00 07 	mcall	80002694 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
8000267e:	0f 98       	ld.ub	r8,r7[0x1]
80002680:	1a d8       	st.w	--sp,r8
80002682:	48 8c       	lddpc	r12,800026a0 <dcm_brdcst_func+0x44>
80002684:	f0 1f 00 04 	mcall	80002694 <dcm_brdcst_func+0x38>
80002688:	2f dd       	sub	sp,-12
	
	
}
8000268a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000268e:	00 00       	add	r0,r0
80002690:	80 00       	ld.sh	r0,r0[0x0]
80002692:	d5 68       	*unknown*
80002694:	80 00       	ld.sh	r0,r0[0x0]
80002696:	6f 78       	ld.w	r8,r7[0x5c]
80002698:	80 00       	ld.sh	r0,r0[0x0]
8000269a:	d5 7c       	*unknown*
8000269c:	80 00       	ld.sh	r0,r0[0x0]
8000269e:	d5 90       	acall	0x59
800026a0:	80 00       	ld.sh	r0,r0[0x0]
800026a2:	d5 a8       	*unknown*

800026a4 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800026a4:	eb cd 40 80 	pushm	r7,lr
800026a8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800026aa:	19 a9       	ld.ub	r9,r12[0x2]
800026ac:	30 08       	mov	r8,0
800026ae:	f0 09 18 00 	cp.b	r9,r8
800026b2:	c1 b1       	brne	800026e8 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800026b4:	19 b8       	ld.ub	r8,r12[0x3]
800026b6:	30 19       	mov	r9,1
800026b8:	f2 08 18 00 	cp.b	r8,r9
800026bc:	c0 51       	brne	800026c6 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800026be:	48 ec       	lddpc	r12,800026f4 <dcm_reply_func+0x50>
800026c0:	f0 1f 00 0e 	mcall	800026f8 <dcm_reply_func+0x54>
800026c4:	c0 a8       	rjmp	800026d8 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800026c6:	58 08       	cp.w	r8,0
800026c8:	c0 51       	brne	800026d2 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026ca:	48 dc       	lddpc	r12,800026fc <dcm_reply_func+0x58>
800026cc:	f0 1f 00 0b 	mcall	800026f8 <dcm_reply_func+0x54>
800026d0:	c0 48       	rjmp	800026d8 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026d2:	48 cc       	lddpc	r12,80002700 <dcm_reply_func+0x5c>
800026d4:	f0 1f 00 09 	mcall	800026f8 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026d8:	0f d8       	ld.ub	r8,r7[0x5]
800026da:	1a d8       	st.w	--sp,r8
800026dc:	48 ac       	lddpc	r12,80002704 <dcm_reply_func+0x60>
800026de:	f0 1f 00 07 	mcall	800026f8 <dcm_reply_func+0x54>
800026e2:	2f fd       	sub	sp,-4
800026e4:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800026e8:	48 8c       	lddpc	r12,80002708 <dcm_reply_func+0x64>
800026ea:	f0 1f 00 04 	mcall	800026f8 <dcm_reply_func+0x54>
800026ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800026f2:	00 00       	add	r0,r0
800026f4:	80 00       	ld.sh	r0,r0[0x0]
800026f6:	d5 c4       	*unknown*
800026f8:	80 00       	ld.sh	r0,r0[0x0]
800026fa:	6f 78       	ld.w	r8,r7[0x5c]
800026fc:	80 00       	ld.sh	r0,r0[0x0]
800026fe:	d5 d8       	*unknown*
80002700:	80 00       	ld.sh	r0,r0[0x0]
80002702:	d5 ec       	*unknown*
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	d6 00       	acall	0x60
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	d6 0c       	*unknown*

8000270c <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
8000270c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000270e:	19 a9       	ld.ub	r9,r12[0x2]
80002710:	30 08       	mov	r8,0
80002712:	f0 09 18 00 	cp.b	r9,r8
80002716:	c0 51       	brne	80002720 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002718:	48 4c       	lddpc	r12,80002728 <ToneControl_reply_func+0x1c>
8000271a:	f0 1f 00 05 	mcall	8000272c <ToneControl_reply_func+0x20>
8000271e:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002720:	48 4c       	lddpc	r12,80002730 <ToneControl_reply_func+0x24>
80002722:	f0 1f 00 03 	mcall	8000272c <ToneControl_reply_func+0x20>
80002726:	d8 02       	popm	pc
80002728:	80 00       	ld.sh	r0,r0[0x0]
8000272a:	d6 18       	*unknown*
8000272c:	80 00       	ld.sh	r0,r0[0x0]
8000272e:	6f 78       	ld.w	r8,r7[0x5c]
80002730:	80 00       	ld.sh	r0,r0[0x0]
80002732:	d6 24       	*unknown*

80002734 <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
80002734:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
80002736:	49 1c       	lddpc	r12,80002778 <app_init+0x44>
80002738:	f0 1f 00 11 	mcall	8000277c <app_init+0x48>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
8000273c:	49 1b       	lddpc	r11,80002780 <app_init+0x4c>
8000273e:	49 2c       	lddpc	r12,80002784 <app_init+0x50>
80002740:	f0 1f 00 12 	mcall	80002788 <app_init+0x54>
	
	/* Create the mutex semaphore to guard a shared global_count.*/
	count_mutex = xSemaphoreCreateMutex();
80002744:	f0 1f 00 12 	mcall	8000278c <app_init+0x58>
80002748:	49 28       	lddpc	r8,80002790 <app_init+0x5c>
8000274a:	91 0c       	st.w	r8[0x0],r12
	if (count_mutex == NULL)
8000274c:	70 08       	ld.w	r8,r8[0x0]
8000274e:	58 08       	cp.w	r8,0
80002750:	c0 41       	brne	80002758 <app_init+0x24>
	{
		log("Create the count_mutex semaphore failure\n");
80002752:	49 1c       	lddpc	r12,80002794 <app_init+0x60>
80002754:	f0 1f 00 11 	mcall	80002798 <app_init+0x64>
	}
	
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002758:	30 09       	mov	r9,0
8000275a:	1a d9       	st.w	--sp,r9
8000275c:	1a d9       	st.w	--sp,r9
8000275e:	1a d9       	st.w	--sp,r9
80002760:	30 18       	mov	r8,1
80002762:	e0 6a 03 20 	mov	r10,800
80002766:	48 eb       	lddpc	r11,8000279c <app_init+0x68>
80002768:	48 ec       	lddpc	r12,800027a0 <app_init+0x6c>
8000276a:	f0 1f 00 0f 	mcall	800027a4 <app_init+0x70>
8000276e:	48 f8       	lddpc	r8,800027a8 <app_init+0x74>
80002770:	91 0c       	st.w	r8[0x0],r12
80002772:	2f dd       	sub	sp,-12
	,  800//1024//800//384
	,  NULL
	,  1
	,  NULL );
		
}
80002774:	d8 02       	popm	pc
80002776:	00 00       	add	r0,r0
80002778:	00 00       	add	r0,r0
8000277a:	00 08       	add	r8,r0
8000277c:	80 00       	ld.sh	r0,r0[0x0]
8000277e:	3e bc       	mov	r12,-21
80002780:	80 00       	ld.sh	r0,r0[0x0]
80002782:	20 3c       	sub	r12,3
80002784:	80 00       	ld.sh	r0,r0[0x0]
80002786:	20 50       	sub	r0,5
80002788:	80 00       	ld.sh	r0,r0[0x0]
8000278a:	2b 64       	sub	r4,-74
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	64 40       	ld.w	r0,r2[0x10]
80002790:	00 00       	add	r0,r0
80002792:	0a 60       	and	r0,r5
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	d6 30       	acall	0x63
80002798:	80 00       	ld.sh	r0,r0[0x0]
8000279a:	6f 78       	ld.w	r8,r7[0x5c]
8000279c:	80 00       	ld.sh	r0,r0[0x0]
8000279e:	d6 5c       	*unknown*
800027a0:	80 00       	ld.sh	r0,r0[0x0]
800027a2:	27 ac       	sub	r12,122
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	6b b4       	ld.w	r4,r5[0x6c]
800027a8:	00 00       	add	r0,r0
800027aa:	0a 58       	eor	r8,r5

800027ac <app_cfg>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
800027ac:	d4 31       	pushm	r0-r7,lr
800027ae:	20 1d       	sub	sp,4
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	Message_Protocol_t *m_buff = (Message_Protocol_t *) pvPortMalloc(sizeof(Message_Protocol_t));
800027b0:	31 ac       	mov	r12,26
800027b2:	f0 1f 00 47 	mcall	800028cc <app_cfg+0x120>
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	static xgflash_status_t status = XG_ERROR;
	xLastWakeTime = xTaskGetTickCount();
800027b6:	f0 1f 00 47 	mcall	800028d0 <app_cfg+0x124>
800027ba:	4c 78       	lddpc	r8,800028d4 <app_cfg+0x128>
800027bc:	91 0c       	st.w	r8[0x0],r12
	
	/* 'Give' the semaphore to unblock the task. */
	 if( xBinarySemaphore != NULL ){
800027be:	4c 78       	lddpc	r8,800028d8 <app_cfg+0x12c>
800027c0:	70 08       	ld.w	r8,r8[0x0]
800027c2:	58 08       	cp.w	r8,0
800027c4:	c0 80       	breq	800027d4 <app_cfg+0x28>
		xSemaphoreGive(xBinarySemaphore);
800027c6:	4c 58       	lddpc	r8,800028d8 <app_cfg+0x12c>
800027c8:	70 0c       	ld.w	r12,r8[0x0]
800027ca:	30 09       	mov	r9,0
800027cc:	12 9a       	mov	r10,r9
800027ce:	12 9b       	mov	r11,r9
800027d0:	f0 1f 00 43 	mcall	800028dc <app_cfg+0x130>
	 }
		
	for(;;)
	{
		switch(OB_State)
800027d4:	4c 36       	lddpc	r6,800028e0 <app_cfg+0x134>
						
					
					//if (xSemaphoreTake(xBinarySemaphore, (1000*2) / portTICK_RATE_MS) == pdPASS)
					{
					
						if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
800027d6:	4c 41       	lddpc	r1,800028e4 <app_cfg+0x138>
800027d8:	30 05       	mov	r5,0
800027da:	e0 67 0f a0 	mov	r7,4000
								{
									nop();
									nop();
									nop();
									log("wait message Ack\n");	
								} while (xSemaphoreTake(xBinarySemaphore, (5000*2) / portTICK_RATE_MS) == pdFALSE);
800027de:	4b f3       	lddpc	r3,800028d8 <app_cfg+0x12c>
								do 
								{
									nop();
									nop();
									nop();
									log("wait message Ack\n");	
800027e0:	4c 22       	lddpc	r2,800028e8 <app_cfg+0x13c>
		xSemaphoreGive(xBinarySemaphore);
	 }
		
	for(;;)
	{
		switch(OB_State)
800027e2:	6c 08       	ld.w	r8,r6[0x0]
800027e4:	58 08       	cp.w	r8,0
800027e6:	c0 40       	breq	800027ee <app_cfg+0x42>
800027e8:	58 38       	cp.w	r8,3
800027ea:	c6 b1       	brne	800028c0 <app_cfg+0x114>
800027ec:	c2 38       	rjmp	80002832 <app_cfg+0x86>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027ee:	4c 08       	lddpc	r8,800028ec <app_cfg+0x140>
800027f0:	70 08       	ld.w	r8,r8[0x0]
800027f2:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800027f6:	58 38       	cp.w	r8,3
800027f8:	c1 61       	brne	80002824 <app_cfg+0x78>
800027fa:	4b e8       	lddpc	r8,800028f0 <app_cfg+0x144>
800027fc:	11 88       	ld.ub	r8,r8[0x0]
800027fe:	58 08       	cp.w	r8,0
80002800:	c1 21       	brne	80002824 <app_cfg+0x78>
				{
					connect_flag=1;
80002802:	30 19       	mov	r9,1
80002804:	4b b8       	lddpc	r8,800028f0 <app_cfg+0x144>
80002806:	b0 89       	st.b	r8[0x0],r9
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002808:	30 cb       	mov	r11,12
8000280a:	30 1c       	mov	r12,1
8000280c:	f0 1f 00 3a 	mcall	800028f4 <app_cfg+0x148>
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002810:	30 cb       	mov	r11,12
80002812:	30 1c       	mov	r12,1
80002814:	f0 1f 00 38 	mcall	800028f4 <app_cfg+0x148>
					OB_State = OB_WAITINGAPPTASK;
80002818:	30 38       	mov	r8,3
8000281a:	8d 08       	st.w	r6[0x0],r8
					log("connect OB okay!\n");
8000281c:	4b 7c       	lddpc	r12,800028f8 <app_cfg+0x14c>
8000281e:	f0 1f 00 38 	mcall	800028fc <app_cfg+0x150>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002822:	c4 f8       	rjmp	800028c0 <app_cfg+0x114>
					OB_State = OB_WAITINGAPPTASK;
					log("connect OB okay!\n");
				}
				else
				{
					nop();
80002824:	d7 03       	nop
					nop();
80002826:	d7 03       	nop
					nop();
80002828:	d7 03       	nop
					log("connecting...\n");
8000282a:	4b 6c       	lddpc	r12,80002900 <app_cfg+0x154>
8000282c:	f0 1f 00 34 	mcall	800028fc <app_cfg+0x150>
80002830:	c4 88       	rjmp	800028c0 <app_cfg+0x114>
						
					
					//if (xSemaphoreTake(xBinarySemaphore, (1000*2) / portTICK_RATE_MS) == pdPASS)
					{
					
						if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
80002832:	62 0c       	ld.w	r12,r1[0x0]
80002834:	0a 99       	mov	r9,r5
80002836:	0e 9a       	mov	r10,r7
80002838:	1a 9b       	mov	r11,sp
8000283a:	f0 1f 00 33 	mcall	80002904 <app_cfg+0x158>
8000283e:	58 1c       	cp.w	r12,1
80002840:	c3 c1       	brne	800028b8 <app_cfg+0x10c>
						{
							if(data_ptr!=NULL){//resend message
80002842:	40 08       	lddsp	r8,sp[0x0]
80002844:	58 08       	cp.w	r8,0
80002846:	c3 90       	breq	800028b8 <app_cfg+0x10c>
							
								log("receive Okay!\n");	
80002848:	4b 0c       	lddpc	r12,80002908 <app_cfg+0x15c>
8000284a:	f0 1f 00 2d 	mcall	800028fc <app_cfg+0x150>
								xSemaphoreTake(count_mutex, portMAX_DELAY);
8000284e:	4b 08       	lddpc	r8,8000290c <app_cfg+0x160>
80002850:	70 0c       	ld.w	r12,r8[0x0]
80002852:	0a 99       	mov	r9,r5
80002854:	3f fa       	mov	r10,-1
80002856:	0a 9b       	mov	r11,r5
80002858:	f0 1f 00 2b 	mcall	80002904 <app_cfg+0x158>
								global_count--;
8000285c:	4a d4       	lddpc	r4,80002910 <app_cfg+0x164>
8000285e:	68 08       	ld.w	r8,r4[0x0]
80002860:	20 18       	sub	r8,1
80002862:	89 08       	st.w	r4[0x0],r8
								xSemaphoreGive(count_mutex);
80002864:	4a a8       	lddpc	r8,8000290c <app_cfg+0x160>
80002866:	70 0c       	ld.w	r12,r8[0x0]
80002868:	0a 99       	mov	r9,r5
8000286a:	0a 9a       	mov	r10,r5
8000286c:	0a 9b       	mov	r11,r5
8000286e:	f0 1f 00 1c 	mcall	800028dc <app_cfg+0x130>
								log("global_count:%d\n", global_count);	
80002872:	68 08       	ld.w	r8,r4[0x0]
80002874:	1a d8       	st.w	--sp,r8
80002876:	4a 8c       	lddpc	r12,80002914 <app_cfg+0x168>
80002878:	f0 1f 00 21 	mcall	800028fc <app_cfg+0x150>
8000287c:	2f fd       	sub	sp,-4
								{
									nop();
									nop();
									nop();
									log("wait message Ack\n");	
								} while (xSemaphoreTake(xBinarySemaphore, (5000*2) / portTICK_RATE_MS) == pdFALSE);
8000287e:	e0 64 27 10 	mov	r4,10000
								global_count--;
								xSemaphoreGive(count_mutex);
								log("global_count:%d\n", global_count);	
								do 
								{
									nop();
80002882:	d7 03       	nop
									nop();
80002884:	d7 03       	nop
									nop();
80002886:	d7 03       	nop
									log("wait message Ack\n");	
80002888:	04 9c       	mov	r12,r2
8000288a:	f0 1f 00 1d 	mcall	800028fc <app_cfg+0x150>
								} while (xSemaphoreTake(xBinarySemaphore, (5000*2) / portTICK_RATE_MS) == pdFALSE);
8000288e:	66 0c       	ld.w	r12,r3[0x0]
80002890:	0a 99       	mov	r9,r5
80002892:	08 9a       	mov	r10,r4
80002894:	0a 9b       	mov	r11,r5
80002896:	f0 1f 00 1c 	mcall	80002904 <app_cfg+0x158>
8000289a:	cf 40       	breq	80002882 <app_cfg+0xd6>
												
								xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);								
8000289c:	e0 6a 04 1a 	mov	r10,1050
800028a0:	31 ab       	mov	r11,26
800028a2:	40 0c       	lddsp	r12,sp[0x0]
800028a4:	f0 1f 00 1d 	mcall	80002918 <app_cfg+0x16c>
								set_message_store(data_ptr);
800028a8:	49 d8       	lddpc	r8,8000291c <app_cfg+0x170>
800028aa:	70 0c       	ld.w	r12,r8[0x0]
800028ac:	40 0b       	lddsp	r11,sp[0x0]
800028ae:	f0 1f 00 1d 	mcall	80002920 <app_cfg+0x174>
								log("send message\n");
800028b2:	49 dc       	lddpc	r12,80002924 <app_cfg+0x178>
800028b4:	f0 1f 00 12 	mcall	800028fc <app_cfg+0x150>
							}
						
						}
					}
										
					nop();
800028b8:	d7 03       	nop
					log("app task run!\n");
800028ba:	49 cc       	lddpc	r12,80002928 <app_cfg+0x17c>
800028bc:	f0 1f 00 10 	mcall	800028fc <app_cfg+0x150>
			break;
			default:
			break;
				
		} //End of switch on OB_State.
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800028c0:	0e 9b       	mov	r11,r7
800028c2:	48 5c       	lddpc	r12,800028d4 <app_cfg+0x128>
800028c4:	f0 1f 00 1a 	mcall	8000292c <app_cfg+0x180>
	}
800028c8:	c8 db       	rjmp	800027e2 <app_cfg+0x36>
800028ca:	00 00       	add	r0,r0
800028cc:	80 00       	ld.sh	r0,r0[0x0]
800028ce:	5f ec       	srqs	r12
800028d0:	80 00       	ld.sh	r0,r0[0x0]
800028d2:	68 a4       	ld.w	r4,r4[0x28]
800028d4:	00 00       	add	r0,r0
800028d6:	0a 54       	eor	r4,r5
800028d8:	00 00       	add	r0,r0
800028da:	0b 7c       	ld.ub	r12,--r5
800028dc:	80 00       	ld.sh	r0,r0[0x0]
800028de:	63 40       	ld.w	r0,r1[0x50]
800028e0:	00 00       	add	r0,r0
800028e2:	0a 44       	or	r4,r5
800028e4:	00 00       	add	r0,r0
800028e6:	0b 74       	ld.ub	r4,--r5
800028e8:	80 00       	ld.sh	r0,r0[0x0]
800028ea:	d6 ac       	*unknown*
800028ec:	00 00       	add	r0,r0
800028ee:	0d a0       	ld.ub	r0,r6[0x2]
800028f0:	00 00       	add	r0,r0
800028f2:	0a 42       	or	r2,r5
800028f4:	80 00       	ld.sh	r0,r0[0x0]
800028f6:	40 4c       	lddsp	r12,sp[0x10]
800028f8:	80 00       	ld.sh	r0,r0[0x0]
800028fa:	d6 64       	*unknown*
800028fc:	80 00       	ld.sh	r0,r0[0x0]
800028fe:	6f 78       	ld.w	r8,r7[0x5c]
80002900:	80 00       	ld.sh	r0,r0[0x0]
80002902:	d6 78       	*unknown*
80002904:	80 00       	ld.sh	r0,r0[0x0]
80002906:	61 34       	ld.w	r4,r0[0x4c]
80002908:	80 00       	ld.sh	r0,r0[0x0]
8000290a:	d6 88       	*unknown*
8000290c:	00 00       	add	r0,r0
8000290e:	0a 60       	and	r0,r5
80002910:	00 00       	add	r0,r0
80002912:	0a 50       	eor	r0,r5
80002914:	80 00       	ld.sh	r0,r0[0x0]
80002916:	d6 98       	*unknown*
80002918:	80 00       	ld.sh	r0,r0[0x0]
8000291a:	3f 10       	mov	r0,-15
8000291c:	00 00       	add	r0,r0
8000291e:	0b 78       	ld.ub	r8,--r5
80002920:	80 00       	ld.sh	r0,r0[0x0]
80002922:	2b e4       	sub	r4,-66
80002924:	80 00       	ld.sh	r0,r0[0x0]
80002926:	d6 c0       	acall	0x6c
80002928:	80 00       	ld.sh	r0,r0[0x0]
8000292a:	d6 d0       	acall	0x6d
8000292c:	80 00       	ld.sh	r0,r0[0x0]
8000292e:	6a 54       	ld.w	r4,r5[0x14]

80002930 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002930:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002934:	19 c7       	ld.ub	r7,r12[0x4]
80002936:	19 d8       	ld.ub	r8,r12[0x5]
80002938:	f1 e7 10 87 	or	r7,r8,r7<<0x8
8000293c:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
8000293e:	48 dc       	lddpc	r12,80002970 <Phyuserinput_brdcst_func+0x40>
80002940:	f0 1f 00 0d 	mcall	80002974 <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
80002944:	36 08       	mov	r8,96
80002946:	f0 07 19 00 	cp.h	r7,r8
8000294a:	c1 11       	brne	8000296c <Phyuserinput_brdcst_func+0x3c>
8000294c:	48 b8       	lddpc	r8,80002978 <Phyuserinput_brdcst_func+0x48>
8000294e:	11 89       	ld.ub	r9,r8[0x0]
80002950:	30 18       	mov	r8,1
80002952:	f0 09 18 00 	cp.b	r9,r8
80002956:	c0 b1       	brne	8000296c <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_9);//set tone to indicate the scan!!!
80002958:	34 5b       	mov	r11,69
8000295a:	30 1c       	mov	r12,1
8000295c:	f0 1f 00 08 	mcall	8000297c <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(1000*2 / portTICK_RATE_MS);//延迟1000ms
80002960:	e0 6c 07 d0 	mov	r12,2000
80002964:	f0 1f 00 07 	mcall	80002980 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		//rfid_sendID_message();//send message	
		scan_rfid_save_message();//scan and save message	
80002968:	f0 1f 00 07 	mcall	80002984 <Phyuserinput_brdcst_func+0x54>
8000296c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002970:	80 00       	ld.sh	r0,r0[0x0]
80002972:	d6 e0       	acall	0x6e
80002974:	80 00       	ld.sh	r0,r0[0x0]
80002976:	6f 78       	ld.w	r8,r7[0x5c]
80002978:	00 00       	add	r0,r0
8000297a:	0a 42       	or	r2,r5
8000297c:	80 00       	ld.sh	r0,r0[0x0]
8000297e:	40 4c       	lddsp	r12,sp[0x10]
80002980:	80 00       	ld.sh	r0,r0[0x0]
80002982:	6a 0c       	ld.w	r12,r5[0x0]
80002984:	80 00       	ld.sh	r0,r0[0x0]
80002986:	50 b0       	stdsp	sp[0x2c],r0

80002988 <DataSession_brdcst_func>:
	Battery_Flag = ptr->State;

}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002988:	d4 21       	pushm	r4-r7,lr
8000298a:	20 8d       	sub	sp,32
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
8000298c:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
80002990:	0d 88       	ld.ub	r8,r6[0x0]
80002992:	32 49       	mov	r9,36
80002994:	f2 08 18 00 	cp.b	r8,r9
80002998:	c2 a1       	brne	800029ec <DataSession_brdcst_func+0x64>
	{
		
		log("\n\r CSBK_RX OK \n\r");
8000299a:	4c ac       	lddpc	r12,80002ac0 <DataSession_brdcst_func+0x138>
8000299c:	f0 1f 00 4a 	mcall	80002ac4 <DataSession_brdcst_func+0x13c>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800029a0:	0d a5       	ld.ub	r5,r6[0x2]
800029a2:	0d b8       	ld.ub	r8,r6[0x3]
800029a4:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800029a8:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800029aa:	0d 98       	ld.ub	r8,r6[0x1]
800029ac:	1a d8       	st.w	--sp,r8
800029ae:	4c 7c       	lddpc	r12,80002ac8 <DataSession_brdcst_func+0x140>
800029b0:	f0 1f 00 45 	mcall	80002ac4 <DataSession_brdcst_func+0x13c>
		log("\n\r paylaod_length: %d \n\r",data_length );
800029b4:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800029b8:	1a d8       	st.w	--sp,r8
800029ba:	4c 5c       	lddpc	r12,80002acc <DataSession_brdcst_func+0x144>
800029bc:	f0 1f 00 42 	mcall	80002ac4 <DataSession_brdcst_func+0x13c>
		for(i=0; i<data_length; i++)
800029c0:	2f ed       	sub	sp,-8
800029c2:	58 05       	cp.w	r5,0
800029c4:	e0 80 00 7b 	breq	80002aba <DataSession_brdcst_func+0x132>
800029c8:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
800029ca:	4c 24       	lddpc	r4,80002ad0 <DataSession_brdcst_func+0x148>
800029cc:	ec 07 00 08 	add	r8,r6,r7
800029d0:	11 c8       	ld.ub	r8,r8[0x4]
800029d2:	1a d8       	st.w	--sp,r8
800029d4:	1a d7       	st.w	--sp,r7
800029d6:	08 9c       	mov	r12,r4
800029d8:	f0 1f 00 3b 	mcall	80002ac4 <DataSession_brdcst_func+0x13c>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
800029dc:	2f f7       	sub	r7,-1
800029de:	5c 57       	castu.b	r7
800029e0:	2f ed       	sub	sp,-8
800029e2:	ee 05 19 00 	cp.h	r5,r7
800029e6:	fe 9b ff f3 	brhi	800029cc <DataSession_brdcst_func+0x44>
800029ea:	c6 88       	rjmp	80002aba <DataSession_brdcst_func+0x132>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
800029ec:	1a d8       	st.w	--sp,r8
800029ee:	4b ac       	lddpc	r12,80002ad4 <DataSession_brdcst_func+0x14c>
800029f0:	f0 1f 00 35 	mcall	80002ac4 <DataSession_brdcst_func+0x13c>
		if (ptr->State == DATA_SESSION_TX_Suc)
800029f4:	0d 88       	ld.ub	r8,r6[0x0]
800029f6:	2f fd       	sub	sp,-4
800029f8:	30 39       	mov	r9,3
800029fa:	f2 08 18 00 	cp.b	r8,r9
800029fe:	c0 d1       	brne	80002a18 <DataSession_brdcst_func+0x90>
		{
			log("data transmit success\n");
80002a00:	4b 6c       	lddpc	r12,80002ad8 <DataSession_brdcst_func+0x150>
80002a02:	f0 1f 00 31 	mcall	80002ac4 <DataSession_brdcst_func+0x13c>
			vTaskDelay(1000*2 / portTICK_RATE_MS);//延迟1000ms
80002a06:	e0 6c 07 d0 	mov	r12,2000
80002a0a:	f0 1f 00 35 	mcall	80002adc <DataSession_brdcst_func+0x154>
			xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate connection success!!!
80002a0e:	37 7b       	mov	r11,119
80002a10:	30 1c       	mov	r12,1
80002a12:	f0 1f 00 34 	mcall	80002ae0 <DataSession_brdcst_func+0x158>
80002a16:	c4 b8       	rjmp	80002aac <DataSession_brdcst_func+0x124>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
80002a18:	30 49       	mov	r9,4
80002a1a:	f2 08 18 00 	cp.b	r8,r9
80002a1e:	c4 71       	brne	80002aac <DataSession_brdcst_func+0x124>
		{
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
80002a20:	31 aa       	mov	r10,26
80002a22:	ec cb ff fc 	sub	r11,r6,-4
80002a26:	fa cc ff fe 	sub	r12,sp,-2
80002a2a:	f0 1f 00 2f 	mcall	80002ae4 <DataSession_brdcst_func+0x15c>

			Message_Protocol_t * myptr = get_message_store();	
80002a2e:	4a f8       	lddpc	r8,80002ae8 <DataSession_brdcst_func+0x160>
80002a30:	70 0c       	ld.w	r12,r8[0x0]
80002a32:	f0 1f 00 2f 	mcall	80002aec <DataSession_brdcst_func+0x164>
80002a36:	50 7c       	stdsp	sp[0x1c],r12
			if(NULL != myptr)
80002a38:	c3 20       	breq	80002a9c <DataSession_brdcst_func+0x114>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
80002a3a:	31 aa       	mov	r10,26
80002a3c:	fa cb ff fe 	sub	r11,sp,-2
80002a40:	f0 1f 00 29 	mcall	80002ae4 <DataSession_brdcst_func+0x15c>
				//xQueueSend(xg_resend_queue, &myptr, 0);			
				if (xQueueSend(xg_resend_queue, &myptr, 0) != pdPASS)
80002a44:	4a b8       	lddpc	r8,80002af0 <DataSession_brdcst_func+0x168>
80002a46:	70 0c       	ld.w	r12,r8[0x0]
80002a48:	30 09       	mov	r9,0
80002a4a:	12 9a       	mov	r10,r9
80002a4c:	fa cb ff e4 	sub	r11,sp,-28
80002a50:	f0 1f 00 29 	mcall	80002af4 <DataSession_brdcst_func+0x16c>
80002a54:	58 1c       	cp.w	r12,1
80002a56:	c1 10       	breq	80002a78 <DataSession_brdcst_func+0xf0>
				{
					log("xg_resend_queue: full\n" );
80002a58:	4a 8c       	lddpc	r12,80002af8 <DataSession_brdcst_func+0x170>
80002a5a:	f0 1f 00 1b 	mcall	80002ac4 <DataSession_brdcst_func+0x13c>
					xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
80002a5e:	32 3b       	mov	r11,35
80002a60:	30 1c       	mov	r12,1
80002a62:	f0 1f 00 20 	mcall	80002ae0 <DataSession_brdcst_func+0x158>
					vTaskDelay(3000*2 / portTICK_RATE_MS);//延迟3000ms
80002a66:	e0 6c 17 70 	mov	r12,6000
80002a6a:	f0 1f 00 1d 	mcall	80002adc <DataSession_brdcst_func+0x154>
					xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
80002a6e:	32 3b       	mov	r11,35
80002a70:	30 0c       	mov	r12,0
80002a72:	f0 1f 00 1c 	mcall	80002ae0 <DataSession_brdcst_func+0x158>
80002a76:	c1 68       	rjmp	80002aa2 <DataSession_brdcst_func+0x11a>
				}
				else{
					
					xSemaphoreTake(count_mutex, portMAX_DELAY);
80002a78:	4a 17       	lddpc	r7,80002afc <DataSession_brdcst_func+0x174>
80002a7a:	6e 0c       	ld.w	r12,r7[0x0]
80002a7c:	30 09       	mov	r9,0
80002a7e:	3f fa       	mov	r10,-1
80002a80:	12 9b       	mov	r11,r9
80002a82:	f0 1f 00 20 	mcall	80002b00 <DataSession_brdcst_func+0x178>
					global_count++;
80002a86:	4a 08       	lddpc	r8,80002b04 <DataSession_brdcst_func+0x17c>
80002a88:	70 09       	ld.w	r9,r8[0x0]
80002a8a:	2f f9       	sub	r9,-1
80002a8c:	91 09       	st.w	r8[0x0],r9
					xSemaphoreGive(count_mutex);
80002a8e:	6e 0c       	ld.w	r12,r7[0x0]
80002a90:	30 09       	mov	r9,0
80002a92:	12 9a       	mov	r10,r9
80002a94:	12 9b       	mov	r11,r9
80002a96:	f0 1f 00 18 	mcall	80002af4 <DataSession_brdcst_func+0x16c>
80002a9a:	c0 48       	rjmp	80002aa2 <DataSession_brdcst_func+0x11a>
				}
			}
			else
			{
				log("myptr: err\n\r" );
80002a9c:	49 bc       	lddpc	r12,80002b08 <DataSession_brdcst_func+0x180>
80002a9e:	f0 1f 00 0a 	mcall	80002ac4 <DataSession_brdcst_func+0x13c>
			}
			xcmp_IdleTestTone(Tone_Start, MANDOWN_DISABLE_TONE);//set tone to indicate send-failure!!!
80002aa2:	e0 6b 00 b7 	mov	r11,183
80002aa6:	30 1c       	mov	r12,1
80002aa8:	f0 1f 00 0e 	mcall	80002ae0 <DataSession_brdcst_func+0x158>
		}
		
		/* 'Give' the semaphore to unblock the task. */
		xSemaphoreGive(xBinarySemaphore);
80002aac:	49 88       	lddpc	r8,80002b0c <DataSession_brdcst_func+0x184>
80002aae:	70 0c       	ld.w	r12,r8[0x0]
80002ab0:	30 09       	mov	r9,0
80002ab2:	12 9a       	mov	r10,r9
80002ab4:	12 9b       	mov	r11,r9
80002ab6:	f0 1f 00 10 	mcall	80002af4 <DataSession_brdcst_func+0x16c>
				//
		//}
		
	}
	
}
80002aba:	2f 8d       	sub	sp,-32
80002abc:	d8 22       	popm	r4-r7,pc
80002abe:	00 00       	add	r0,r0
80002ac0:	80 00       	ld.sh	r0,r0[0x0]
80002ac2:	d7 00       	acall	0x70
80002ac4:	80 00       	ld.sh	r0,r0[0x0]
80002ac6:	6f 78       	ld.w	r8,r7[0x5c]
80002ac8:	80 00       	ld.sh	r0,r0[0x0]
80002aca:	d7 14       	*unknown*
80002acc:	80 00       	ld.sh	r0,r0[0x0]
80002ace:	d7 2c       	*unknown*
80002ad0:	80 00       	ld.sh	r0,r0[0x0]
80002ad2:	d7 48       	*unknown*
80002ad4:	80 00       	ld.sh	r0,r0[0x0]
80002ad6:	d7 60       	acall	0x76
80002ad8:	80 00       	ld.sh	r0,r0[0x0]
80002ada:	d7 6c       	*unknown*
80002adc:	80 00       	ld.sh	r0,r0[0x0]
80002ade:	6a 0c       	ld.w	r12,r5[0x0]
80002ae0:	80 00       	ld.sh	r0,r0[0x0]
80002ae2:	40 4c       	lddsp	r12,sp[0x10]
80002ae4:	80 00       	ld.sh	r0,r0[0x0]
80002ae6:	77 f4       	ld.w	r4,r11[0x7c]
80002ae8:	00 00       	add	r0,r0
80002aea:	0b 78       	ld.ub	r8,--r5
80002aec:	80 00       	ld.sh	r0,r0[0x0]
80002aee:	2d 90       	sub	r0,-39
80002af0:	00 00       	add	r0,r0
80002af2:	0b 74       	ld.ub	r4,--r5
80002af4:	80 00       	ld.sh	r0,r0[0x0]
80002af6:	63 40       	ld.w	r0,r1[0x50]
80002af8:	80 00       	ld.sh	r0,r0[0x0]
80002afa:	d7 84       	*unknown*
80002afc:	00 00       	add	r0,r0
80002afe:	0a 60       	and	r0,r5
80002b00:	80 00       	ld.sh	r0,r0[0x0]
80002b02:	61 34       	ld.w	r4,r0[0x4c]
80002b04:	00 00       	add	r0,r0
80002b06:	0a 50       	eor	r0,r5
80002b08:	80 00       	ld.sh	r0,r0[0x0]
80002b0a:	d7 9c       	*unknown*
80002b0c:	00 00       	add	r0,r0
80002b0e:	0b 7c       	ld.ub	r12,--r5

80002b10 <DeviceInitializationStatus_brdcst_func>:
volatile U32 global_count =0;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002b10:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002b12:	19 e8       	ld.ub	r8,r12[0x6]
80002b14:	30 19       	mov	r9,1
80002b16:	f2 08 18 00 	cp.b	r8,r9
80002b1a:	c0 61       	brne	80002b26 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002b1c:	48 98       	lddpc	r8,80002b40 <DeviceInitializationStatus_brdcst_func+0x30>
80002b1e:	70 09       	ld.w	r9,r8[0x0]
80002b20:	a1 a9       	sbr	r9,0x0
80002b22:	91 09       	st.w	r8[0x0],r9
80002b24:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
80002b26:	30 29       	mov	r9,2
80002b28:	f2 08 18 00 	cp.b	r8,r9
80002b2c:	c0 80       	breq	80002b3c <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002b2e:	48 58       	lddpc	r8,80002b40 <DeviceInitializationStatus_brdcst_func+0x30>
80002b30:	70 09       	ld.w	r9,r8[0x0]
80002b32:	e0 19 ff fc 	andl	r9,0xfffc
80002b36:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002b38:	f0 1f 00 03 	mcall	80002b44 <DeviceInitializationStatus_brdcst_func+0x34>
80002b3c:	d8 02       	popm	pc
80002b3e:	00 00       	add	r0,r0
80002b40:	00 00       	add	r0,r0
80002b42:	0d a0       	ld.ub	r0,r6[0x2]
80002b44:	80 00       	ld.sh	r0,r0[0x0]
80002b46:	3f a0       	mov	r0,-6

80002b48 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002b48:	20 1c       	sub	r12,1
80002b4a:	5c 5c       	castu.b	r12
80002b4c:	31 18       	mov	r8,17
80002b4e:	f0 0c 18 00 	cp.b	r12,r8
80002b52:	e0 88 00 03 	brls	80002b58 <CalculateBurst+0x10>
80002b56:	5e fd       	retal	0
80002b58:	48 28       	lddpc	r8,80002b60 <CalculateBurst+0x18>
80002b5a:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002b5e:	5e fc       	retal	r12
80002b60:	80 00       	ld.sh	r0,r0[0x0]
80002b62:	d7 ac       	*unknown*

80002b64 <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
80002b64:	48 38       	lddpc	r8,80002b70 <payload_init+0xc>
80002b66:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002b68:	48 38       	lddpc	r8,80002b74 <payload_init+0x10>
80002b6a:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
80002b6c:	5e fc       	retal	r12
80002b6e:	00 00       	add	r0,r0
80002b70:	00 00       	add	r0,r0
80002b72:	0a 6c       	and	r12,r5
80002b74:	00 00       	add	r0,r0
80002b76:	0a 70       	tst	r0,r5

80002b78 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002b78:	d4 01       	pushm	lr
80002b7a:	20 2d       	sub	sp,8
80002b7c:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002b7e:	30 09       	mov	r9,0
80002b80:	fa ca ff f8 	sub	r10,sp,-8
80002b84:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002b86:	1a 9b       	mov	r11,sp
80002b88:	f0 1f 00 02 	mcall	80002b90 <set_idle_store_isr+0x18>
}
80002b8c:	2f ed       	sub	sp,-8
80002b8e:	d8 02       	popm	pc
80002b90:	80 00       	ld.sh	r0,r0[0x0]
80002b92:	62 f0       	ld.w	r0,r1[0x3c]

80002b94 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002b94:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
80002b96:	48 48       	lddpc	r8,80002ba4 <payload_rx+0x10>
80002b98:	70 08       	ld.w	r8,r8[0x0]
80002b9a:	18 9b       	mov	r11,r12
80002b9c:	10 9c       	mov	r12,r8
80002b9e:	f0 1f 00 03 	mcall	80002ba8 <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
80002ba2:	d8 02       	popm	pc
80002ba4:	00 00       	add	r0,r0
80002ba6:	0a a8       	st.w	r5++,r8
80002ba8:	80 00       	ld.sh	r0,r0[0x0]
80002baa:	2b 78       	sub	r8,-73

80002bac <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002bac:	d4 01       	pushm	lr
80002bae:	20 2d       	sub	sp,8
80002bb0:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002bb2:	58 0c       	cp.w	r12,0
80002bb4:	c1 10       	breq	80002bd6 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002bb6:	30 08       	mov	r8,0
80002bb8:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002bba:	98 88       	ld.uh	r8,r12[0x0]
80002bbc:	e2 18 f0 00 	andl	r8,0xf000,COH
80002bc0:	e0 48 40 00 	cp.w	r8,16384
80002bc4:	c0 91       	brne	80002bd6 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002bc6:	48 68       	lddpc	r8,80002bdc <phy_rx+0x30>
80002bc8:	70 0c       	ld.w	r12,r8[0x0]
80002bca:	30 09       	mov	r9,0
80002bcc:	fa ca ff fc 	sub	r10,sp,-4
80002bd0:	1a 9b       	mov	r11,sp
80002bd2:	f0 1f 00 04 	mcall	80002be0 <phy_rx+0x34>
		}	

    }
		
 
}
80002bd6:	2f ed       	sub	sp,-8
80002bd8:	d8 02       	popm	pc
80002bda:	00 00       	add	r0,r0
80002bdc:	00 00       	add	r0,r0
80002bde:	0a b4       	st.h	r5++,r4
80002be0:	80 00       	ld.sh	r0,r0[0x0]
80002be2:	62 f0       	ld.w	r0,r1[0x3c]

80002be4 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002be4:	eb cd 40 80 	pushm	r7,lr
80002be8:	20 1d       	sub	sp,4
80002bea:	fa c7 ff fc 	sub	r7,sp,-4
80002bee:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002bf0:	30 09       	mov	r9,0
80002bf2:	12 9a       	mov	r10,r9
80002bf4:	1a 9b       	mov	r11,sp
80002bf6:	f0 1f 00 03 	mcall	80002c00 <set_idle_store+0x1c>
}
80002bfa:	2f fd       	sub	sp,-4
80002bfc:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c00:	80 00       	ld.sh	r0,r0[0x0]
80002c02:	63 40       	ld.w	r0,r1[0x50]

80002c04 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002c04:	d4 01       	pushm	lr
80002c06:	20 1d       	sub	sp,4
80002c08:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002c0a:	98 88       	ld.uh	r8,r12[0x0]
80002c0c:	e2 18 f0 00 	andl	r8,0xf000,COH
80002c10:	e0 48 40 00 	cp.w	r8,16384
80002c14:	c0 d1       	brne	80002c2e <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002c16:	49 08       	lddpc	r8,80002c54 <phy_tx+0x50>
80002c18:	70 08       	ld.w	r8,r8[0x0]
80002c1a:	58 08       	cp.w	r8,0
80002c1c:	c1 a0       	breq	80002c50 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002c1e:	48 e8       	lddpc	r8,80002c54 <phy_tx+0x50>
80002c20:	70 0c       	ld.w	r12,r8[0x0]
80002c22:	30 09       	mov	r9,0
80002c24:	12 9a       	mov	r10,r9
80002c26:	1a 9b       	mov	r11,sp
80002c28:	f0 1f 00 0c 	mcall	80002c58 <phy_tx+0x54>
80002c2c:	c1 28       	rjmp	80002c50 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002c2e:	e0 48 10 00 	cp.w	r8,4096
80002c32:	5f 0a       	sreq	r10
80002c34:	e0 48 20 00 	cp.w	r8,8192
80002c38:	5f 09       	sreq	r9
80002c3a:	f5 e9 10 09 	or	r9,r10,r9
80002c3e:	c0 71       	brne	80002c4c <phy_tx+0x48>
80002c40:	e0 48 50 00 	cp.w	r8,20480
80002c44:	c0 40       	breq	80002c4c <phy_tx+0x48>
80002c46:	e0 48 60 00 	cp.w	r8,24576
80002c4a:	c0 31       	brne	80002c50 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002c4c:	48 48       	lddpc	r8,80002c5c <phy_tx+0x58>
80002c4e:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002c50:	2f fd       	sub	sp,-4
80002c52:	d8 02       	popm	pc
80002c54:	00 00       	add	r0,r0
80002c56:	0a d4       	st.w	--r5,r4
80002c58:	80 00       	ld.sh	r0,r0[0x0]
80002c5a:	63 40       	ld.w	r0,r1[0x50]
80002c5c:	00 00       	add	r0,r0
80002c5e:	0a c8       	st.b	r5++,r8

80002c60 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002c60:	d4 01       	pushm	lr
80002c62:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002c64:	30 08       	mov	r8,0
80002c66:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002c68:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002c6a:	1a 9a       	mov	r10,sp
80002c6c:	fa cb ff fc 	sub	r11,sp,-4
80002c70:	f0 1f 00 05 	mcall	80002c84 <get_idle_store_isr+0x24>
80002c74:	58 1c       	cp.w	r12,1
80002c76:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002c7a:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002c7e:	2f ed       	sub	sp,-8
80002c80:	d8 02       	popm	pc
80002c82:	00 00       	add	r0,r0
80002c84:	80 00       	ld.sh	r0,r0[0x0]
80002c86:	60 44       	ld.w	r4,r0[0x10]

80002c88 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002c88:	eb cd 40 c0 	pushm	r6-r7,lr
80002c8c:	20 1d       	sub	sp,4
80002c8e:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002c90:	4b a8       	lddpc	r8,80002d78 <phy_tx_func+0xf0>
80002c92:	70 08       	ld.w	r8,r8[0x0]
80002c94:	58 08       	cp.w	r8,0
80002c96:	c6 60       	breq	80002d62 <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002c98:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002c9a:	30 08       	mov	r8,0
80002c9c:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002c9e:	4b 88       	lddpc	r8,80002d7c <phy_tx_func+0xf4>
80002ca0:	70 08       	ld.w	r8,r8[0x0]
80002ca2:	58 18       	cp.w	r8,1
80002ca4:	c2 60       	breq	80002cf0 <phy_tx_func+0x68>
80002ca6:	c0 43       	brcs	80002cae <phy_tx_func+0x26>
80002ca8:	58 28       	cp.w	r8,2
80002caa:	c5 c1       	brne	80002d62 <phy_tx_func+0xda>
80002cac:	c5 58       	rjmp	80002d56 <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002cae:	4b 38       	lddpc	r8,80002d78 <phy_tx_func+0xf0>
80002cb0:	70 0c       	ld.w	r12,r8[0x0]
80002cb2:	1a 9a       	mov	r10,sp
80002cb4:	4b 3b       	lddpc	r11,80002d80 <phy_tx_func+0xf8>
80002cb6:	f0 1f 00 34 	mcall	80002d84 <phy_tx_func+0xfc>
80002cba:	58 1c       	cp.w	r12,1
80002cbc:	c1 41       	brne	80002ce4 <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002cbe:	4b 18       	lddpc	r8,80002d80 <phy_tx_func+0xf8>
80002cc0:	70 08       	ld.w	r8,r8[0x0]
80002cc2:	90 08       	ld.sh	r8,r8[0x0]
80002cc4:	10 9a       	mov	r10,r8
80002cc6:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002cca:	4b 09       	lddpc	r9,80002d88 <phy_tx_func+0x100>
80002ccc:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002cce:	5c 78       	castu.h	r8
80002cd0:	ea 18 ab cd 	orh	r8,0xabcd
80002cd4:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002cd6:	30 19       	mov	r9,1
80002cd8:	4a d8       	lddpc	r8,80002d8c <phy_tx_func+0x104>
80002cda:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002cdc:	30 19       	mov	r9,1
80002cde:	4a 88       	lddpc	r8,80002d7c <phy_tx_func+0xf4>
80002ce0:	91 09       	st.w	r8[0x0],r9
80002ce2:	c4 08       	rjmp	80002d62 <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002ce4:	e0 68 5a 5a 	mov	r8,23130
80002ce8:	ea 18 ab cd 	orh	r8,0xabcd
80002cec:	8f 18       	st.w	r7[0x4],r8
80002cee:	c3 a8       	rjmp	80002d62 <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002cf0:	4a 7a       	lddpc	r10,80002d8c <phy_tx_func+0x104>
80002cf2:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002cf4:	4a 39       	lddpc	r9,80002d80 <phy_tx_func+0xf8>
80002cf6:	72 09       	ld.w	r9,r9[0x0]
80002cf8:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002cfc:	b1 69       	lsl	r9,0x10
80002cfe:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002d00:	2f f8       	sub	r8,-1
80002d02:	5c 58       	castu.b	r8
80002d04:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002d06:	4a 1b       	lddpc	r11,80002d88 <phy_tx_func+0x100>
80002d08:	96 0c       	ld.sh	r12,r11[0x0]
80002d0a:	20 2c       	sub	r12,2
80002d0c:	5c 8c       	casts.h	r12
80002d0e:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002d12:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002d14:	30 0b       	mov	r11,0
80002d16:	f6 0a 19 00 	cp.h	r10,r11
80002d1a:	e0 89 00 09 	brgt	80002d2c <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002d1e:	e8 19 00 ba 	orl	r9,0xba
80002d22:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002d24:	30 09       	mov	r9,0
80002d26:	49 68       	lddpc	r8,80002d7c <phy_tx_func+0xf4>
80002d28:	91 09       	st.w	r8[0x0],r9
80002d2a:	c1 c8       	rjmp	80002d62 <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002d2c:	49 5a       	lddpc	r10,80002d80 <phy_tx_func+0xf8>
80002d2e:	74 0a       	ld.w	r10,r10[0x0]
80002d30:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002d34:	14 49       	or	r9,r10
80002d36:	8f 19       	st.w	r7[0x4],r9
80002d38:	2f f8       	sub	r8,-1
80002d3a:	49 59       	lddpc	r9,80002d8c <phy_tx_func+0x104>
80002d3c:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002d3e:	20 2c       	sub	r12,2
80002d40:	49 28       	lddpc	r8,80002d88 <phy_tx_func+0x100>
80002d42:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002d44:	30 08       	mov	r8,0
80002d46:	f0 0c 19 00 	cp.h	r12,r8
80002d4a:	e0 89 00 0c 	brgt	80002d62 <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002d4e:	30 29       	mov	r9,2
80002d50:	48 b8       	lddpc	r8,80002d7c <phy_tx_func+0xf4>
80002d52:	91 09       	st.w	r8[0x0],r9
80002d54:	c0 78       	rjmp	80002d62 <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002d56:	fc 18 00 ba 	movh	r8,0xba
80002d5a:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002d5c:	30 09       	mov	r9,0
80002d5e:	48 88       	lddpc	r8,80002d7c <phy_tx_func+0xf4>
80002d60:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002d62:	e0 68 5a 5a 	mov	r8,23130
80002d66:	ea 18 ab cd 	orh	r8,0xabcd
80002d6a:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002d6c:	30 08       	mov	r8,0
80002d6e:	8f 38       	st.w	r7[0xc],r8
}
80002d70:	2f fd       	sub	sp,-4
80002d72:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002d76:	00 00       	add	r0,r0
80002d78:	00 00       	add	r0,r0
80002d7a:	0a d4       	st.w	--r5,r4
80002d7c:	00 00       	add	r0,r0
80002d7e:	0a 94       	mov	r4,r5
80002d80:	00 00       	add	r0,r0
80002d82:	0a a0       	st.w	r5++,r0
80002d84:	80 00       	ld.sh	r0,r0[0x0]
80002d86:	60 44       	ld.w	r4,r0[0x10]
80002d88:	00 00       	add	r0,r0
80002d8a:	0a bc       	st.h	r5++,r12
80002d8c:	00 00       	add	r0,r0
80002d8e:	0a 74       	tst	r4,r5

80002d90 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002d90:	d4 01       	pushm	lr
80002d92:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002d94:	30 0a       	mov	r10,0
80002d96:	fa cb ff fc 	sub	r11,sp,-4
80002d9a:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002d9c:	14 99       	mov	r9,r10
80002d9e:	1a 9b       	mov	r11,sp
80002da0:	f0 1f 00 05 	mcall	80002db4 <get_idle_store+0x24>
80002da4:	58 1c       	cp.w	r12,1
80002da6:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002daa:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002dae:	2f fd       	sub	sp,-4
80002db0:	d8 02       	popm	pc
80002db2:	00 00       	add	r0,r0
80002db4:	80 00       	ld.sh	r0,r0[0x0]
80002db6:	61 34       	ld.w	r4,r0[0x4c]

80002db8 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002db8:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002dba:	48 5b       	lddpc	r11,80002dcc <phy_init+0x14>
80002dbc:	48 5c       	lddpc	r12,80002dd0 <phy_init+0x18>
80002dbe:	f0 1f 00 06 	mcall	80002dd4 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002dc2:	f0 1f 00 06 	mcall	80002dd8 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002dc6:	f0 1f 00 06 	mcall	80002ddc <phy_init+0x24>
	
}
80002dca:	d8 02       	popm	pc
80002dcc:	80 00       	ld.sh	r0,r0[0x0]
80002dce:	2c 88       	sub	r8,-56
80002dd0:	80 00       	ld.sh	r0,r0[0x0]
80002dd2:	2d e0       	sub	r0,-34
80002dd4:	80 00       	ld.sh	r0,r0[0x0]
80002dd6:	3e 34       	mov	r4,-29
80002dd8:	80 00       	ld.sh	r0,r0[0x0]
80002dda:	3e 48       	mov	r8,-28
80002ddc:	80 00       	ld.sh	r0,r0[0x0]
80002dde:	47 f8       	lddsp	r8,sp[0x1fc]

80002de0 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002de0:	eb cd 40 e0 	pushm	r5-r7,lr
80002de4:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002de6:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002dea:	70 08       	ld.w	r8,r8[0x0]
80002dec:	58 08       	cp.w	r8,0
80002dee:	e0 80 01 08 	breq	80002ffe <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002df2:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002df4:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002df8:	70 09       	ld.w	r9,r8[0x0]
80002dfa:	2f f9       	sub	r9,-1
80002dfc:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002dfe:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002e02:	70 08       	ld.w	r8,r8[0x0]
80002e04:	58 18       	cp.w	r8,1
80002e06:	e0 80 00 85 	breq	80002f10 <phy_rx_func+0x130>
80002e0a:	c0 73       	brcs	80002e18 <phy_rx_func+0x38>
80002e0c:	58 28       	cp.w	r8,2
80002e0e:	c5 c0       	breq	80002ec6 <phy_rx_func+0xe6>
80002e10:	58 38       	cp.w	r8,3
80002e12:	e0 81 00 f6 	brne	80002ffe <phy_rx_func+0x21e>
80002e16:	cd 58       	rjmp	80002fc0 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002e18:	e0 6a 5a 5a 	mov	r10,23130
80002e1c:	ea 1a ab cd 	orh	r10,0xabcd
80002e20:	14 36       	cp.w	r6,r10
80002e22:	e0 80 00 ee 	breq	80002ffe <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002e26:	ec 08 16 10 	lsr	r8,r6,0x10
80002e2a:	e0 48 ab cd 	cp.w	r8,43981
80002e2e:	e0 81 00 e8 	brne	80002ffe <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002e32:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002e36:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002e3a:	20 28       	sub	r8,2
80002e3c:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002e40:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002e42:	30 09       	mov	r9,0
80002e44:	f2 08 19 00 	cp.h	r8,r9
80002e48:	e0 8a 00 db 	brle	80002ffe <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002e4c:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002e50:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002e52:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002e56:	70 0c       	ld.w	r12,r8[0x0]
80002e58:	f0 1f 03 88 	mcall	80003c78 <phy_rx_func+0xe98>
80002e5c:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002e60:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002e62:	58 0c       	cp.w	r12,0
80002e64:	e0 80 00 cd 	breq	80002ffe <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002e68:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002e6c:	90 09       	ld.sh	r9,r8[0x0]
80002e6e:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002e72:	2f f9       	sub	r9,-1
80002e74:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002e76:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002e7a:	74 0a       	ld.w	r10,r10[0x0]
80002e7c:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002e80:	76 0b       	ld.w	r11,r11[0x0]
80002e82:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002e86:	2f f9       	sub	r9,-1
80002e88:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002e8a:	e2 16 0f 00 	andl	r6,0xf00,COH
80002e8e:	e0 46 01 00 	cp.w	r6,256
80002e92:	c0 c0       	breq	80002eaa <phy_rx_func+0xca>
80002e94:	e0 8b 00 05 	brhi	80002e9e <phy_rx_func+0xbe>
80002e98:	58 06       	cp.w	r6,0
80002e9a:	c0 80       	breq	80002eaa <phy_rx_func+0xca>
80002e9c:	c0 c8       	rjmp	80002eb4 <phy_rx_func+0xd4>
80002e9e:	e0 46 02 00 	cp.w	r6,512
80002ea2:	c0 40       	breq	80002eaa <phy_rx_func+0xca>
80002ea4:	e0 46 03 00 	cp.w	r6,768
80002ea8:	c0 61       	brne	80002eb4 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002eaa:	30 29       	mov	r9,2
80002eac:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002eb0:	91 09       	st.w	r8[0x0],r9
80002eb2:	ca 68       	rjmp	80002ffe <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002eb4:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002eb8:	70 0c       	ld.w	r12,r8[0x0]
80002eba:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002ebe:	70 0b       	ld.w	r11,r8[0x0]
80002ec0:	f0 1f 03 70 	mcall	80003c80 <phy_rx_func+0xea0>
80002ec4:	c9 d8       	rjmp	80002ffe <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002ec6:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002eca:	b1 86       	lsr	r6,0x10
80002ecc:	14 06       	add	r6,r10
80002ece:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002ed2:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002ed4:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002ed8:	90 09       	ld.sh	r9,r8[0x0]
80002eda:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002ede:	76 0b       	ld.w	r11,r11[0x0]
80002ee0:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002ee4:	2f f9       	sub	r9,-1
80002ee6:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002ee8:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002eec:	92 08       	ld.sh	r8,r9[0x0]
80002eee:	20 28       	sub	r8,2
80002ef0:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002ef2:	30 09       	mov	r9,0
80002ef4:	f2 08 19 00 	cp.h	r8,r9
80002ef8:	e0 8a 00 07 	brle	80002f06 <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002efc:	30 19       	mov	r9,1
80002efe:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002f02:	91 09       	st.w	r8[0x0],r9
80002f04:	c7 d8       	rjmp	80002ffe <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002f06:	30 39       	mov	r9,3
80002f08:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002f0c:	91 09       	st.w	r8[0x0],r9
80002f0e:	c7 88       	rjmp	80002ffe <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002f10:	ec 0a 14 10 	asr	r10,r6,0x10
80002f14:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002f18:	90 09       	ld.sh	r9,r8[0x0]
80002f1a:	14 09       	add	r9,r10
80002f1c:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002f1e:	fe f9 0d 52 	ld.w	r9,pc[3410]
80002f22:	92 08       	ld.sh	r8,r9[0x0]
80002f24:	fe fb 0d 58 	ld.w	r11,pc[3416]
80002f28:	76 0b       	ld.w	r11,r11[0x0]
80002f2a:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002f2e:	2f f8       	sub	r8,-1
80002f30:	5c 88       	casts.h	r8
80002f32:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002f34:	fe fa 0d 38 	ld.w	r10,pc[3384]
80002f38:	94 09       	ld.sh	r9,r10[0x0]
80002f3a:	20 29       	sub	r9,2
80002f3c:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80002f3e:	30 0a       	mov	r10,0
80002f40:	f4 09 19 00 	cp.h	r9,r10
80002f44:	e0 89 00 20 	brgt	80002f84 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80002f48:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80002f4c:	e0 46 00 ba 	cp.w	r6,186
80002f50:	c0 d1       	brne	80002f6a <phy_rx_func+0x18a>
80002f52:	fe f8 0d 32 	ld.w	r8,pc[3378]
80002f56:	90 09       	ld.sh	r9,r8[0x0]
80002f58:	f4 09 19 00 	cp.h	r9,r10
80002f5c:	c0 71       	brne	80002f6a <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80002f5e:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80002f62:	70 0c       	ld.w	r12,r8[0x0]
80002f64:	f0 1f 03 49 	mcall	80003c88 <phy_rx_func+0xea8>
80002f68:	c0 98       	rjmp	80002f7a <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80002f6a:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80002f6e:	70 0c       	ld.w	r12,r8[0x0]
80002f70:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80002f74:	70 0b       	ld.w	r11,r8[0x0]
80002f76:	f0 1f 03 43 	mcall	80003c80 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80002f7a:	30 09       	mov	r9,0
80002f7c:	fe f8 0c ec 	ld.w	r8,pc[3308]
80002f80:	91 09       	st.w	r8[0x0],r9
80002f82:	c3 e8       	rjmp	80002ffe <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80002f84:	5c 86       	casts.h	r6
80002f86:	fe f9 0c fe 	ld.w	r9,pc[3326]
80002f8a:	92 0a       	ld.sh	r10,r9[0x0]
80002f8c:	0c 0a       	add	r10,r6
80002f8e:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002f90:	fe f9 0c ec 	ld.w	r9,pc[3308]
80002f94:	72 09       	ld.w	r9,r9[0x0]
80002f96:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80002f9a:	2f f8       	sub	r8,-1
80002f9c:	fe f9 0c d4 	ld.w	r9,pc[3284]
80002fa0:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80002fa2:	fe f9 0c ca 	ld.w	r9,pc[3274]
80002fa6:	92 08       	ld.sh	r8,r9[0x0]
80002fa8:	20 28       	sub	r8,2
80002faa:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80002fac:	30 09       	mov	r9,0
80002fae:	f2 08 19 00 	cp.h	r8,r9
80002fb2:	e0 89 00 26 	brgt	80002ffe <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80002fb6:	30 39       	mov	r9,3
80002fb8:	fe f8 0c b0 	ld.w	r8,pc[3248]
80002fbc:	91 09       	st.w	r8[0x0],r9
80002fbe:	c2 08       	rjmp	80002ffe <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80002fc0:	e6 16 00 ff 	andh	r6,0xff,COH
80002fc4:	fc 19 00 ba 	movh	r9,0xba
80002fc8:	12 36       	cp.w	r6,r9
80002fca:	c0 e1       	brne	80002fe6 <phy_rx_func+0x206>
80002fcc:	fe f8 0c b8 	ld.w	r8,pc[3256]
80002fd0:	90 09       	ld.sh	r9,r8[0x0]
80002fd2:	30 08       	mov	r8,0
80002fd4:	f0 09 19 00 	cp.h	r9,r8
80002fd8:	c0 71       	brne	80002fe6 <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80002fda:	fe f8 0c a2 	ld.w	r8,pc[3234]
80002fde:	70 0c       	ld.w	r12,r8[0x0]
80002fe0:	f0 1f 03 2a 	mcall	80003c88 <phy_rx_func+0xea8>
80002fe4:	c0 98       	rjmp	80002ff6 <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80002fe6:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002fea:	70 0c       	ld.w	r12,r8[0x0]
80002fec:	fe f8 0c 90 	ld.w	r8,pc[3216]
80002ff0:	70 0b       	ld.w	r11,r8[0x0]
80002ff2:	f0 1f 03 24 	mcall	80003c80 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80002ff6:	30 09       	mov	r9,0
80002ff8:	fe f8 0c 70 	ld.w	r8,pc[3184]
80002ffc:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80002ffe:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80003002:	11 89       	ld.ub	r9,r8[0x0]
80003004:	30 08       	mov	r8,0
80003006:	f0 09 18 00 	cp.b	r9,r8
8000300a:	c1 31       	brne	80003030 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
8000300c:	fe f6 0c 84 	ld.w	r6,pc[3204]
80003010:	6c 0c       	ld.w	r12,r6[0x0]
80003012:	f0 1f 03 1a 	mcall	80003c78 <phy_rx_func+0xe98>
80003016:	fe f8 0c 7e 	ld.w	r8,pc[3198]
8000301a:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
8000301c:	6c 0c       	ld.w	r12,r6[0x0]
8000301e:	f0 1f 03 17 	mcall	80003c78 <phy_rx_func+0xe98>
80003022:	fe f8 0c 76 	ld.w	r8,pc[3190]
80003026:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80003028:	30 19       	mov	r9,1
8000302a:	fe f8 0c 62 	ld.w	r8,pc[3170]
8000302e:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80003030:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80003034:	70 08       	ld.w	r8,r8[0x0]
80003036:	58 28       	cp.w	r8,2
80003038:	e0 80 01 98 	breq	80003368 <phy_rx_func+0x588>
8000303c:	e0 8b 00 06 	brhi	80003048 <phy_rx_func+0x268>
80003040:	58 08       	cp.w	r8,0
80003042:	c0 b0       	breq	80003058 <phy_rx_func+0x278>
80003044:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003048:	58 38       	cp.w	r8,3
8000304a:	e0 80 05 c5 	breq	80003bd4 <phy_rx_func+0xdf4>
8000304e:	58 48       	cp.w	r8,4
80003050:	e0 81 06 05 	brne	80003c5a <phy_rx_func+0xe7a>
80003054:	e0 8f 02 4b 	bral	800034ea <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80003058:	6e 28       	ld.w	r8,r7[0x8]
8000305a:	e0 6a 5a 5a 	mov	r10,23130
8000305e:	ea 1a ab cd 	orh	r10,0xabcd
80003062:	14 38       	cp.w	r8,r10
80003064:	c0 71       	brne	80003072 <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
80003066:	30 09       	mov	r9,0
80003068:	fe f8 0c 38 	ld.w	r8,pc[3128]
8000306c:	91 09       	st.w	r8[0x0],r9
8000306e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80003072:	10 99       	mov	r9,r8
80003074:	e0 19 00 00 	andl	r9,0x0
80003078:	fc 1a ab cd 	movh	r10,0xabcd
8000307c:	14 39       	cp.w	r9,r10
8000307e:	e0 81 05 ee 	brne	80003c5a <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80003082:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80003086:	fe f9 0c 1e 	ld.w	r9,pc[3102]
8000308a:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
8000308c:	6e 29       	ld.w	r9,r7[0x8]
8000308e:	e2 19 f0 00 	andl	r9,0xf000,COH
80003092:	e0 49 c0 00 	cp.w	r9,49152
80003096:	e0 81 00 ce 	brne	80003232 <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
8000309a:	30 1a       	mov	r10,1
8000309c:	fe f9 0c 0c 	ld.w	r9,pc[3084]
800030a0:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
800030a2:	fe f9 0b f6 	ld.w	r9,pc[3062]
800030a6:	72 09       	ld.w	r9,r9[0x0]
800030a8:	58 09       	cp.w	r9,0
800030aa:	c0 71       	brne	800030b8 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800030ac:	fe fc 0c 00 	ld.w	r12,pc[3072]
800030b0:	f0 1f 03 00 	mcall	80003cb0 <phy_rx_func+0xed0>
800030b4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
800030b8:	ef 3a 00 0d 	ld.ub	r10,r7[13]
800030bc:	fe f9 0b f8 	ld.w	r9,pc[3064]
800030c0:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
800030c2:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800030c6:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
800030ca:	fe fa 0b ee 	ld.w	r10,pc[3054]
800030ce:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
800030d0:	13 89       	ld.ub	r9,r9[0x0]
800030d2:	37 fa       	mov	r10,127
800030d4:	f4 09 18 00 	cp.b	r9,r10
800030d8:	c6 d0       	breq	800031b2 <phy_rx_func+0x3d2>
800030da:	e0 8b 00 0c 	brhi	800030f2 <phy_rx_func+0x312>
800030de:	31 2a       	mov	r10,18
800030e0:	f4 09 18 00 	cp.b	r9,r10
800030e4:	c4 20       	breq	80003168 <phy_rx_func+0x388>
800030e6:	31 3a       	mov	r10,19
800030e8:	f4 09 18 00 	cp.b	r9,r10
800030ec:	e0 81 00 83 	brne	800031f2 <phy_rx_func+0x412>
800030f0:	c5 b8       	rjmp	800031a6 <phy_rx_func+0x3c6>
800030f2:	2f 09       	sub	r9,-16
800030f4:	30 1a       	mov	r10,1
800030f6:	f4 09 18 00 	cp.b	r9,r10
800030fa:	e0 8b 00 7c 	brhi	800031f2 <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
800030fe:	ef 38 00 0e 	ld.ub	r8,r7[14]
80003102:	e2 18 00 f0 	andl	r8,0xf0,COH
80003106:	59 08       	cp.w	r8,16
80003108:	c0 71       	brne	80003116 <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
8000310a:	30 19       	mov	r9,1
8000310c:	fe f8 0b 94 	ld.w	r8,pc[2964]
80003110:	91 09       	st.w	r8[0x0],r9
80003112:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80003116:	e0 48 00 20 	cp.w	r8,32
8000311a:	c2 11       	brne	8000315c <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
8000311c:	30 a9       	mov	r9,10
8000311e:	fe f8 0b 82 	ld.w	r8,pc[2946]
80003122:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003124:	fe f6 0b 98 	ld.w	r6,pc[2968]
80003128:	6c 08       	ld.w	r8,r6[0x0]
8000312a:	f0 0a 11 ff 	rsub	r10,r8,-1
8000312e:	fe f7 0b 6a 	ld.w	r7,pc[2922]
80003132:	2f f8       	sub	r8,-1
80003134:	6e 0c       	ld.w	r12,r7[0x0]
80003136:	f4 ca fe 00 	sub	r10,r10,-512
8000313a:	30 0b       	mov	r11,0
8000313c:	10 0c       	add	r12,r8
8000313e:	f0 1f 02 e1 	mcall	80003cc0 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80003142:	30 08       	mov	r8,0
80003144:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80003146:	6e 0c       	ld.w	r12,r7[0x0]
80003148:	f0 1f 02 df 	mcall	80003cc4 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000314c:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003150:	70 0c       	ld.w	r12,r8[0x0]
80003152:	f0 1f 02 ca 	mcall	80003c78 <phy_rx_func+0xe98>
80003156:	8f 0c       	st.w	r7[0x0],r12
80003158:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
8000315c:	30 09       	mov	r9,0
8000315e:	fe f8 0b 42 	ld.w	r8,pc[2882]
80003162:	91 09       	st.w	r8[0x0],r9
80003164:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003168:	20 48       	sub	r8,4
8000316a:	fe f9 0b 3a 	ld.w	r9,pc[2874]
8000316e:	93 08       	st.w	r9[0x0],r8
80003170:	58 08       	cp.w	r8,0
80003172:	e0 80 05 74 	breq	80003c5a <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003176:	ef 3c 00 0f 	ld.ub	r12,r7[15]
8000317a:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
8000317e:	fe f8 0b 4a 	ld.w	r8,pc[2890]
80003182:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003184:	8e 69       	ld.sh	r9,r7[0xc]
80003186:	fe f8 0b 46 	ld.w	r8,pc[2886]
8000318a:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
8000318c:	8e 79       	ld.sh	r9,r7[0xe]
8000318e:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003190:	f0 1f 02 d0 	mcall	80003cd0 <phy_rx_func+0xef0>
80003194:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80003198:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000319a:	30 49       	mov	r9,4
8000319c:	fe f8 0b 00 	ld.w	r8,pc[2816]
800031a0:	91 09       	st.w	r8[0x0],r9
800031a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
800031a6:	30 09       	mov	r9,0
800031a8:	fe f8 0a f8 	ld.w	r8,pc[2808]
800031ac:	91 09       	st.w	r8[0x0],r9
800031ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800031b2:	20 48       	sub	r8,4
800031b4:	fe f9 0a f0 	ld.w	r9,pc[2800]
800031b8:	93 08       	st.w	r9[0x0],r8
800031ba:	58 08       	cp.w	r8,0
800031bc:	e0 80 05 4f 	breq	80003c5a <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
800031c0:	fe f8 0b 14 	ld.w	r8,pc[2836]
800031c4:	70 09       	ld.w	r9,r8[0x0]
800031c6:	8e 7b       	ld.sh	r11,r7[0xe]
800031c8:	fe fa 0b 10 	ld.w	r10,pc[2832]
800031cc:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
800031d0:	2f f9       	sub	r9,-1
800031d2:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
800031d4:	fe f8 0a e4 	ld.w	r8,pc[2788]
800031d8:	70 09       	ld.w	r9,r8[0x0]
800031da:	20 29       	sub	r9,2
800031dc:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
800031de:	30 29       	mov	r9,2
800031e0:	fe f8 0a c0 	ld.w	r8,pc[2752]
800031e4:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
800031e6:	30 39       	mov	r9,3
800031e8:	fe f8 0a b4 	ld.w	r8,pc[2740]
800031ec:	91 09       	st.w	r8[0x0],r9
800031ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
800031f2:	30 3a       	mov	r10,3
800031f4:	fe f9 0a ac 	ld.w	r9,pc[2732]
800031f8:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
800031fa:	6e 2a       	ld.w	r10,r7[0x8]
800031fc:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003200:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003202:	6e 3a       	ld.w	r10,r7[0xc]
80003204:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
80003206:	59 48       	cp.w	r8,20
80003208:	c0 61       	brne	80003214 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
8000320a:	31 89       	mov	r9,24
8000320c:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003210:	91 09       	st.w	r8[0x0],r9
80003212:	c0 a8       	rjmp	80003226 <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003214:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003218:	70 08       	ld.w	r8,r8[0x0]
8000321a:	59 08       	cp.w	r8,16
8000321c:	c0 51       	brne	80003226 <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
8000321e:	31 09       	mov	r9,16
80003220:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003224:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003226:	30 49       	mov	r9,4
80003228:	fe f8 0a 74 	ld.w	r8,pc[2676]
8000322c:	91 09       	st.w	r8[0x0],r9
8000322e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80003232:	e0 49 10 00 	cp.w	r9,4096
80003236:	5f 1a       	srne	r10
80003238:	e0 49 20 00 	cp.w	r9,8192
8000323c:	5f 19       	srne	r9
8000323e:	f5 e9 00 09 	and	r9,r10,r9
80003242:	e0 81 05 0c 	brne	80003c5a <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
80003246:	fe fa 0a 9a 	ld.w	r10,pc[2714]
8000324a:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
8000324c:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003250:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
80003252:	fe fa 0a 62 	ld.w	r10,pc[2658]
80003256:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
80003258:	fe f9 0a 3c 	ld.w	r9,pc[2620]
8000325c:	72 09       	ld.w	r9,r9[0x0]
8000325e:	58 09       	cp.w	r9,0
80003260:	c0 71       	brne	8000326e <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003262:	fe fc 0a 4a 	ld.w	r12,pc[2634]
80003266:	f0 1f 02 93 	mcall	80003cb0 <phy_rx_func+0xed0>
8000326a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000326e:	6e 2a       	ld.w	r10,r7[0x8]
80003270:	e2 1a 0f 00 	andl	r10,0xf00,COH
80003274:	58 1a       	cp.w	r10,1
80003276:	e0 8b 00 4d 	brhi	80003310 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
8000327a:	20 48       	sub	r8,4
8000327c:	fe f9 0a 28 	ld.w	r9,pc[2600]
80003280:	93 08       	st.w	r9[0x0],r8
80003282:	58 08       	cp.w	r8,0
80003284:	e0 80 04 eb 	breq	80003c5a <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
80003288:	8e 68       	ld.sh	r8,r7[0xc]
8000328a:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000328e:	fe f9 0a 5a 	ld.w	r9,pc[2650]
80003292:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
80003294:	30 09       	mov	r9,0
80003296:	f2 08 19 00 	cp.h	r8,r9
8000329a:	c0 70       	breq	800032a8 <phy_rx_func+0x4c8>
8000329c:	30 19       	mov	r9,1
8000329e:	f2 08 19 00 	cp.h	r8,r9
800032a2:	e0 81 04 dc 	brne	80003c5a <phy_rx_func+0xe7a>
800032a6:	c2 68       	rjmp	800032f2 <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800032a8:	fe f8 0a 44 	ld.w	r8,pc[2628]
800032ac:	70 0a       	ld.w	r10,r8[0x0]
800032ae:	fe f9 09 e6 	ld.w	r9,pc[2534]
800032b2:	72 09       	ld.w	r9,r9[0x0]
800032b4:	8e 7b       	ld.sh	r11,r7[0xe]
800032b6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800032ba:	70 09       	ld.w	r9,r8[0x0]
800032bc:	2f f9       	sub	r9,-1
800032be:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800032c0:	e0 49 00 ff 	cp.w	r9,255
800032c4:	e0 88 00 11 	brls	800032e6 <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
800032c8:	30 09       	mov	r9,0
800032ca:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
800032cc:	fe f7 09 c8 	ld.w	r7,pc[2504]
800032d0:	6e 0c       	ld.w	r12,r7[0x0]
800032d2:	f0 1f 02 7d 	mcall	80003cc4 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
800032d6:	fe f8 09 ba 	ld.w	r8,pc[2490]
800032da:	70 0c       	ld.w	r12,r8[0x0]
800032dc:	f0 1f 02 67 	mcall	80003c78 <phy_rx_func+0xe98>
800032e0:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
800032e2:	e0 80 04 bc 	breq	80003c5a <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
800032e6:	30 29       	mov	r9,2
800032e8:	fe f8 09 b4 	ld.w	r8,pc[2484]
800032ec:	91 09       	st.w	r8[0x0],r9
800032ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800032f2:	8e 79       	ld.sh	r9,r7[0xe]
800032f4:	30 38       	mov	r8,3
800032f6:	f0 09 19 00 	cp.h	r9,r8
800032fa:	c0 51       	brne	80003304 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
800032fc:	30 19       	mov	r9,1
800032fe:	fe f8 09 f2 	ld.w	r8,pc[2546]
80003302:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
80003304:	30 29       	mov	r9,2
80003306:	fe f8 09 96 	ld.w	r8,pc[2454]
8000330a:	91 09       	st.w	r8[0x0],r9
8000330c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003310:	58 18       	cp.w	r8,1
80003312:	e0 88 04 a4 	brls	80003c5a <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003316:	fe f8 09 d6 	ld.w	r8,pc[2518]
8000331a:	70 0a       	ld.w	r10,r8[0x0]
8000331c:	6e 3b       	ld.w	r11,r7[0xc]
8000331e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003322:	70 09       	ld.w	r9,r8[0x0]
80003324:	2f f9       	sub	r9,-1
80003326:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003328:	e0 49 00 ff 	cp.w	r9,255
8000332c:	e0 88 00 11 	brls	8000334e <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003330:	30 09       	mov	r9,0
80003332:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003334:	fe f7 09 60 	ld.w	r7,pc[2400]
80003338:	6e 0c       	ld.w	r12,r7[0x0]
8000333a:	f0 1f 02 63 	mcall	80003cc4 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000333e:	fe f8 09 52 	ld.w	r8,pc[2386]
80003342:	70 0c       	ld.w	r12,r8[0x0]
80003344:	f0 1f 02 4d 	mcall	80003c78 <phy_rx_func+0xe98>
80003348:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
8000334a:	e0 80 04 88 	breq	80003c5a <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
8000334e:	fe f9 09 56 	ld.w	r9,pc[2390]
80003352:	72 08       	ld.w	r8,r9[0x0]
80003354:	20 28       	sub	r8,2
80003356:	93 08       	st.w	r9[0x0],r8
80003358:	e0 80 04 81 	breq	80003c5a <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
8000335c:	30 29       	mov	r9,2
8000335e:	fe f8 09 3e 	ld.w	r8,pc[2366]
80003362:	91 09       	st.w	r8[0x0],r9
80003364:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003368:	fe f8 09 84 	ld.w	r8,pc[2436]
8000336c:	70 0a       	ld.w	r10,r8[0x0]
8000336e:	fe f9 09 26 	ld.w	r9,pc[2342]
80003372:	72 09       	ld.w	r9,r9[0x0]
80003374:	8e 4b       	ld.sh	r11,r7[0x8]
80003376:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
8000337a:	70 09       	ld.w	r9,r8[0x0]
8000337c:	2f f9       	sub	r9,-1
8000337e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003380:	e0 49 00 ff 	cp.w	r9,255
80003384:	e0 88 00 16 	brls	800033b0 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
80003388:	30 09       	mov	r9,0
8000338a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000338c:	fe f6 09 08 	ld.w	r6,pc[2312]
80003390:	6c 0c       	ld.w	r12,r6[0x0]
80003392:	f0 1f 02 4d 	mcall	80003cc4 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003396:	fe f8 08 fa 	ld.w	r8,pc[2298]
8000339a:	70 0c       	ld.w	r12,r8[0x0]
8000339c:	f0 1f 02 37 	mcall	80003c78 <phy_rx_func+0xe98>
800033a0:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800033a2:	c0 71       	brne	800033b0 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
800033a4:	30 09       	mov	r9,0
800033a6:	fe f8 08 f6 	ld.w	r8,pc[2294]
800033aa:	91 09       	st.w	r8[0x0],r9
800033ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
800033b0:	fe f9 08 f4 	ld.w	r9,pc[2292]
800033b4:	72 08       	ld.w	r8,r9[0x0]
800033b6:	20 28       	sub	r8,2
800033b8:	93 08       	st.w	r9[0x0],r8
800033ba:	c0 71       	brne	800033c8 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
800033bc:	30 09       	mov	r9,0
800033be:	fe f8 08 de 	ld.w	r8,pc[2270]
800033c2:	91 09       	st.w	r8[0x0],r9
800033c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
800033c8:	fe f8 09 24 	ld.w	r8,pc[2340]
800033cc:	70 0a       	ld.w	r10,r8[0x0]
800033ce:	fe f9 08 c6 	ld.w	r9,pc[2246]
800033d2:	72 09       	ld.w	r9,r9[0x0]
800033d4:	8e 5b       	ld.sh	r11,r7[0xa]
800033d6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800033da:	70 09       	ld.w	r9,r8[0x0]
800033dc:	2f f9       	sub	r9,-1
800033de:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800033e0:	e0 49 00 ff 	cp.w	r9,255
800033e4:	e0 88 00 16 	brls	80003410 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
800033e8:	30 09       	mov	r9,0
800033ea:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800033ec:	fe f6 08 a8 	ld.w	r6,pc[2216]
800033f0:	6c 0c       	ld.w	r12,r6[0x0]
800033f2:	f0 1f 02 35 	mcall	80003cc4 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800033f6:	fe f8 08 9a 	ld.w	r8,pc[2202]
800033fa:	70 0c       	ld.w	r12,r8[0x0]
800033fc:	f0 1f 02 1f 	mcall	80003c78 <phy_rx_func+0xe98>
80003400:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003402:	c0 71       	brne	80003410 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003404:	30 09       	mov	r9,0
80003406:	fe f8 08 96 	ld.w	r8,pc[2198]
8000340a:	91 09       	st.w	r8[0x0],r9
8000340c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003410:	fe f9 08 94 	ld.w	r9,pc[2196]
80003414:	72 08       	ld.w	r8,r9[0x0]
80003416:	20 28       	sub	r8,2
80003418:	93 08       	st.w	r9[0x0],r8
8000341a:	c0 71       	brne	80003428 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
8000341c:	30 09       	mov	r9,0
8000341e:	fe f8 08 7e 	ld.w	r8,pc[2174]
80003422:	91 09       	st.w	r8[0x0],r9
80003424:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003428:	fe f8 08 c4 	ld.w	r8,pc[2244]
8000342c:	70 0a       	ld.w	r10,r8[0x0]
8000342e:	fe f9 08 66 	ld.w	r9,pc[2150]
80003432:	72 09       	ld.w	r9,r9[0x0]
80003434:	8e 6b       	ld.sh	r11,r7[0xc]
80003436:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000343a:	70 09       	ld.w	r9,r8[0x0]
8000343c:	2f f9       	sub	r9,-1
8000343e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003440:	e0 49 00 ff 	cp.w	r9,255
80003444:	e0 88 00 16 	brls	80003470 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003448:	30 09       	mov	r9,0
8000344a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000344c:	fe f6 08 48 	ld.w	r6,pc[2120]
80003450:	6c 0c       	ld.w	r12,r6[0x0]
80003452:	f0 1f 02 1d 	mcall	80003cc4 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003456:	fe f8 08 3a 	ld.w	r8,pc[2106]
8000345a:	70 0c       	ld.w	r12,r8[0x0]
8000345c:	f0 1f 02 07 	mcall	80003c78 <phy_rx_func+0xe98>
80003460:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003462:	c0 71       	brne	80003470 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
80003464:	30 09       	mov	r9,0
80003466:	fe f8 08 36 	ld.w	r8,pc[2102]
8000346a:	91 09       	st.w	r8[0x0],r9
8000346c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003470:	fe f9 08 34 	ld.w	r9,pc[2100]
80003474:	72 08       	ld.w	r8,r9[0x0]
80003476:	20 28       	sub	r8,2
80003478:	93 08       	st.w	r9[0x0],r8
8000347a:	c0 71       	brne	80003488 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
8000347c:	30 09       	mov	r9,0
8000347e:	fe f8 08 1e 	ld.w	r8,pc[2078]
80003482:	91 09       	st.w	r8[0x0],r9
80003484:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003488:	fe f8 08 64 	ld.w	r8,pc[2148]
8000348c:	70 0a       	ld.w	r10,r8[0x0]
8000348e:	fe f9 08 06 	ld.w	r9,pc[2054]
80003492:	72 09       	ld.w	r9,r9[0x0]
80003494:	8e 7b       	ld.sh	r11,r7[0xe]
80003496:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000349a:	70 09       	ld.w	r9,r8[0x0]
8000349c:	2f f9       	sub	r9,-1
8000349e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800034a0:	e0 49 00 ff 	cp.w	r9,255
800034a4:	e0 88 00 16 	brls	800034d0 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
800034a8:	30 09       	mov	r9,0
800034aa:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800034ac:	fe f7 07 e8 	ld.w	r7,pc[2024]
800034b0:	6e 0c       	ld.w	r12,r7[0x0]
800034b2:	f0 1f 02 05 	mcall	80003cc4 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800034b6:	fe f8 07 da 	ld.w	r8,pc[2010]
800034ba:	70 0c       	ld.w	r12,r8[0x0]
800034bc:	f0 1f 01 ef 	mcall	80003c78 <phy_rx_func+0xe98>
800034c0:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800034c2:	c0 71       	brne	800034d0 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
800034c4:	30 09       	mov	r9,0
800034c6:	fe f8 07 d6 	ld.w	r8,pc[2006]
800034ca:	91 09       	st.w	r8[0x0],r9
800034cc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800034d0:	fe f9 07 d4 	ld.w	r9,pc[2004]
800034d4:	72 08       	ld.w	r8,r9[0x0]
800034d6:	20 28       	sub	r8,2
800034d8:	93 08       	st.w	r9[0x0],r8
800034da:	e0 81 03 c0 	brne	80003c5a <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
800034de:	30 09       	mov	r9,0
800034e0:	fe f8 07 bc 	ld.w	r8,pc[1980]
800034e4:	91 09       	st.w	r8[0x0],r9
800034e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
800034ea:	fe f8 07 ca 	ld.w	r8,pc[1994]
800034ee:	11 89       	ld.ub	r9,r8[0x0]
800034f0:	31 28       	mov	r8,18
800034f2:	f0 09 18 00 	cp.b	r9,r8
800034f6:	e0 81 01 4c 	brne	8000378e <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
800034fa:	ef 39 00 09 	ld.ub	r9,r7[9]
800034fe:	fe f8 07 b6 	ld.w	r8,pc[1974]
80003502:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003504:	11 89       	ld.ub	r9,r8[0x0]
80003506:	3f 28       	mov	r8,-14
80003508:	f0 09 18 00 	cp.b	r9,r8
8000350c:	e0 81 01 3b 	brne	80003782 <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003510:	30 19       	mov	r9,1
80003512:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003516:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003518:	6e 29       	ld.w	r9,r7[0x8]
8000351a:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
8000351e:	fe f8 07 86 	ld.w	r8,pc[1926]
80003522:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003524:	8e 59       	ld.sh	r9,r7[0xa]
80003526:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000352a:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
8000352c:	8e 69       	ld.sh	r9,r7[0xc]
8000352e:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003530:	8e 79       	ld.sh	r9,r7[0xe]
80003532:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003534:	fe f8 07 88 	ld.w	r8,pc[1928]
80003538:	fe f9 07 60 	ld.w	r9,pc[1888]
8000353c:	72 0a       	ld.w	r10,r9[0x0]
8000353e:	70 09       	ld.w	r9,r8[0x0]
80003540:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003544:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003548:	70 09       	ld.w	r9,r8[0x0]
8000354a:	2f f9       	sub	r9,-1
8000354c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000354e:	e0 49 01 ff 	cp.w	r9,511
80003552:	e0 88 00 16 	brls	8000357e <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
80003556:	30 09       	mov	r9,0
80003558:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000355a:	fe f6 07 3e 	ld.w	r6,pc[1854]
8000355e:	6c 0c       	ld.w	r12,r6[0x0]
80003560:	f0 1f 01 d9 	mcall	80003cc4 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003564:	fe f8 07 2c 	ld.w	r8,pc[1836]
80003568:	70 0c       	ld.w	r12,r8[0x0]
8000356a:	f0 1f 01 c4 	mcall	80003c78 <phy_rx_func+0xe98>
8000356e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003570:	c0 71       	brne	8000357e <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
80003572:	30 09       	mov	r9,0
80003574:	fe f8 07 28 	ld.w	r8,pc[1832]
80003578:	91 09       	st.w	r8[0x0],r9
8000357a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000357e:	fe f9 07 26 	ld.w	r9,pc[1830]
80003582:	72 08       	ld.w	r8,r9[0x0]
80003584:	20 18       	sub	r8,1
80003586:	93 08       	st.w	r9[0x0],r8
80003588:	c0 71       	brne	80003596 <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
8000358a:	30 09       	mov	r9,0
8000358c:	fe f8 07 10 	ld.w	r8,pc[1808]
80003590:	91 09       	st.w	r8[0x0],r9
80003592:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003596:	fe f8 07 26 	ld.w	r8,pc[1830]
8000359a:	fe f9 06 fe 	ld.w	r9,pc[1790]
8000359e:	72 0a       	ld.w	r10,r9[0x0]
800035a0:	70 09       	ld.w	r9,r8[0x0]
800035a2:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800035a6:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800035aa:	70 09       	ld.w	r9,r8[0x0]
800035ac:	2f f9       	sub	r9,-1
800035ae:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035b0:	e0 49 01 ff 	cp.w	r9,511
800035b4:	e0 88 00 16 	brls	800035e0 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
800035b8:	30 09       	mov	r9,0
800035ba:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035bc:	fe f6 06 dc 	ld.w	r6,pc[1756]
800035c0:	6c 0c       	ld.w	r12,r6[0x0]
800035c2:	f0 1f 01 c1 	mcall	80003cc4 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800035c6:	fe f8 06 ca 	ld.w	r8,pc[1738]
800035ca:	70 0c       	ld.w	r12,r8[0x0]
800035cc:	f0 1f 01 ab 	mcall	80003c78 <phy_rx_func+0xe98>
800035d0:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035d2:	c0 71       	brne	800035e0 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
800035d4:	30 09       	mov	r9,0
800035d6:	fe f8 06 c6 	ld.w	r8,pc[1734]
800035da:	91 09       	st.w	r8[0x0],r9
800035dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035e0:	fe f9 06 c4 	ld.w	r9,pc[1732]
800035e4:	72 08       	ld.w	r8,r9[0x0]
800035e6:	20 18       	sub	r8,1
800035e8:	93 08       	st.w	r9[0x0],r8
800035ea:	c0 71       	brne	800035f8 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
800035ec:	30 09       	mov	r9,0
800035ee:	fe f8 06 ae 	ld.w	r8,pc[1710]
800035f2:	91 09       	st.w	r8[0x0],r9
800035f4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
800035f8:	fe f8 06 c4 	ld.w	r8,pc[1732]
800035fc:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003600:	72 0a       	ld.w	r10,r9[0x0]
80003602:	70 09       	ld.w	r9,r8[0x0]
80003604:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003608:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000360c:	70 09       	ld.w	r9,r8[0x0]
8000360e:	2f f9       	sub	r9,-1
80003610:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003612:	e0 49 01 ff 	cp.w	r9,511
80003616:	e0 88 00 16 	brls	80003642 <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
8000361a:	30 09       	mov	r9,0
8000361c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000361e:	fe f6 06 7a 	ld.w	r6,pc[1658]
80003622:	6c 0c       	ld.w	r12,r6[0x0]
80003624:	f0 1f 01 a8 	mcall	80003cc4 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003628:	fe f8 06 68 	ld.w	r8,pc[1640]
8000362c:	70 0c       	ld.w	r12,r8[0x0]
8000362e:	f0 1f 01 93 	mcall	80003c78 <phy_rx_func+0xe98>
80003632:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003634:	c0 71       	brne	80003642 <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80003636:	30 09       	mov	r9,0
80003638:	fe f8 06 64 	ld.w	r8,pc[1636]
8000363c:	91 09       	st.w	r8[0x0],r9
8000363e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003642:	fe f9 06 62 	ld.w	r9,pc[1634]
80003646:	72 08       	ld.w	r8,r9[0x0]
80003648:	20 18       	sub	r8,1
8000364a:	93 08       	st.w	r9[0x0],r8
8000364c:	c0 71       	brne	8000365a <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
8000364e:	30 09       	mov	r9,0
80003650:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003654:	91 09       	st.w	r8[0x0],r9
80003656:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
8000365a:	fe f8 06 62 	ld.w	r8,pc[1634]
8000365e:	fe f9 06 3a 	ld.w	r9,pc[1594]
80003662:	72 0a       	ld.w	r10,r9[0x0]
80003664:	70 09       	ld.w	r9,r8[0x0]
80003666:	ef 3b 00 0d 	ld.ub	r11,r7[13]
8000366a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000366e:	70 09       	ld.w	r9,r8[0x0]
80003670:	2f f9       	sub	r9,-1
80003672:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003674:	e0 49 01 ff 	cp.w	r9,511
80003678:	e0 88 00 16 	brls	800036a4 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
8000367c:	30 09       	mov	r9,0
8000367e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003680:	fe f6 06 18 	ld.w	r6,pc[1560]
80003684:	6c 0c       	ld.w	r12,r6[0x0]
80003686:	f0 1f 01 90 	mcall	80003cc4 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000368a:	fe f8 06 06 	ld.w	r8,pc[1542]
8000368e:	70 0c       	ld.w	r12,r8[0x0]
80003690:	f0 1f 01 7a 	mcall	80003c78 <phy_rx_func+0xe98>
80003694:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003696:	c0 71       	brne	800036a4 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80003698:	30 09       	mov	r9,0
8000369a:	fe f8 06 02 	ld.w	r8,pc[1538]
8000369e:	91 09       	st.w	r8[0x0],r9
800036a0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800036a4:	fe f9 06 00 	ld.w	r9,pc[1536]
800036a8:	72 08       	ld.w	r8,r9[0x0]
800036aa:	20 18       	sub	r8,1
800036ac:	93 08       	st.w	r9[0x0],r8
800036ae:	c0 71       	brne	800036bc <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
800036b0:	30 09       	mov	r9,0
800036b2:	fe f8 05 ea 	ld.w	r8,pc[1514]
800036b6:	91 09       	st.w	r8[0x0],r9
800036b8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
800036bc:	fe f8 06 00 	ld.w	r8,pc[1536]
800036c0:	fe f9 05 d8 	ld.w	r9,pc[1496]
800036c4:	72 0a       	ld.w	r10,r9[0x0]
800036c6:	70 09       	ld.w	r9,r8[0x0]
800036c8:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800036cc:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800036d0:	70 09       	ld.w	r9,r8[0x0]
800036d2:	2f f9       	sub	r9,-1
800036d4:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036d6:	e0 49 01 ff 	cp.w	r9,511
800036da:	e0 88 00 16 	brls	80003706 <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
800036de:	30 09       	mov	r9,0
800036e0:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800036e2:	fe f6 05 b6 	ld.w	r6,pc[1462]
800036e6:	6c 0c       	ld.w	r12,r6[0x0]
800036e8:	f0 1f 01 77 	mcall	80003cc4 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800036ec:	fe f8 05 a4 	ld.w	r8,pc[1444]
800036f0:	70 0c       	ld.w	r12,r8[0x0]
800036f2:	f0 1f 01 62 	mcall	80003c78 <phy_rx_func+0xe98>
800036f6:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800036f8:	c0 71       	brne	80003706 <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
800036fa:	30 09       	mov	r9,0
800036fc:	fe f8 05 a0 	ld.w	r8,pc[1440]
80003700:	91 09       	st.w	r8[0x0],r9
80003702:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003706:	fe f9 05 9e 	ld.w	r9,pc[1438]
8000370a:	72 08       	ld.w	r8,r9[0x0]
8000370c:	20 18       	sub	r8,1
8000370e:	93 08       	st.w	r9[0x0],r8
80003710:	c0 71       	brne	8000371e <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
80003712:	30 09       	mov	r9,0
80003714:	fe f8 05 88 	ld.w	r8,pc[1416]
80003718:	91 09       	st.w	r8[0x0],r9
8000371a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
8000371e:	fe f8 05 9e 	ld.w	r8,pc[1438]
80003722:	fe f9 05 76 	ld.w	r9,pc[1398]
80003726:	72 0a       	ld.w	r10,r9[0x0]
80003728:	70 09       	ld.w	r9,r8[0x0]
8000372a:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000372e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003732:	70 09       	ld.w	r9,r8[0x0]
80003734:	2f f9       	sub	r9,-1
80003736:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003738:	e0 49 01 ff 	cp.w	r9,511
8000373c:	e0 88 00 16 	brls	80003768 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003740:	30 09       	mov	r9,0
80003742:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003744:	fe f7 05 54 	ld.w	r7,pc[1364]
80003748:	6e 0c       	ld.w	r12,r7[0x0]
8000374a:	f0 1f 01 5f 	mcall	80003cc4 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000374e:	fe f8 05 42 	ld.w	r8,pc[1346]
80003752:	70 0c       	ld.w	r12,r8[0x0]
80003754:	f0 1f 01 49 	mcall	80003c78 <phy_rx_func+0xe98>
80003758:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000375a:	c0 71       	brne	80003768 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
8000375c:	30 09       	mov	r9,0
8000375e:	fe f8 05 3e 	ld.w	r8,pc[1342]
80003762:	91 09       	st.w	r8[0x0],r9
80003764:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003768:	fe f9 05 3c 	ld.w	r9,pc[1340]
8000376c:	72 08       	ld.w	r8,r9[0x0]
8000376e:	20 18       	sub	r8,1
80003770:	93 08       	st.w	r9[0x0],r8
80003772:	e0 81 02 74 	brne	80003c5a <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
80003776:	30 09       	mov	r9,0
80003778:	fe f8 05 24 	ld.w	r8,pc[1316]
8000377c:	91 09       	st.w	r8[0x0],r9
8000377e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003782:	30 09       	mov	r9,0
80003784:	fe f8 05 18 	ld.w	r8,pc[1304]
80003788:	91 09       	st.w	r8[0x0],r9
8000378a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
8000378e:	fe f8 05 26 	ld.w	r8,pc[1318]
80003792:	11 89       	ld.ub	r9,r8[0x0]
80003794:	3f 28       	mov	r8,-14
80003796:	f0 09 18 00 	cp.b	r9,r8
8000379a:	c4 31       	brne	80003820 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
8000379c:	8e 49       	ld.sh	r9,r7[0x8]
8000379e:	fe f8 05 56 	ld.w	r8,pc[1366]
800037a2:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
800037a4:	fe f8 05 18 	ld.w	r8,pc[1304]
800037a8:	fe f9 04 f0 	ld.w	r9,pc[1264]
800037ac:	72 0a       	ld.w	r10,r9[0x0]
800037ae:	70 09       	ld.w	r9,r8[0x0]
800037b0:	ef 3b 00 08 	ld.ub	r11,r7[8]
800037b4:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800037b8:	70 09       	ld.w	r9,r8[0x0]
800037ba:	2f f9       	sub	r9,-1
800037bc:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037be:	e0 49 01 ff 	cp.w	r9,511
800037c2:	e0 88 00 16 	brls	800037ee <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
800037c6:	30 09       	mov	r9,0
800037c8:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800037ca:	fe f7 04 ce 	ld.w	r7,pc[1230]
800037ce:	6e 0c       	ld.w	r12,r7[0x0]
800037d0:	f0 1f 01 3d 	mcall	80003cc4 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800037d4:	fe f8 04 bc 	ld.w	r8,pc[1212]
800037d8:	70 0c       	ld.w	r12,r8[0x0]
800037da:	f0 1f 01 28 	mcall	80003c78 <phy_rx_func+0xe98>
800037de:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800037e0:	c0 71       	brne	800037ee <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
800037e2:	30 09       	mov	r9,0
800037e4:	fe f8 04 b8 	ld.w	r8,pc[1208]
800037e8:	91 09       	st.w	r8[0x0],r9
800037ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800037ee:	fe f9 04 b6 	ld.w	r9,pc[1206]
800037f2:	72 08       	ld.w	r8,r9[0x0]
800037f4:	20 18       	sub	r8,1
800037f6:	93 08       	st.w	r9[0x0],r8
800037f8:	c0 71       	brne	80003806 <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
800037fa:	30 09       	mov	r9,0
800037fc:	fe f8 04 a0 	ld.w	r8,pc[1184]
80003800:	91 09       	st.w	r8[0x0],r9
80003802:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003806:	20 18       	sub	r8,1
80003808:	fe f9 04 9c 	ld.w	r9,pc[1180]
8000380c:	93 08       	st.w	r9[0x0],r8
8000380e:	58 08       	cp.w	r8,0
80003810:	e0 81 02 25 	brne	80003c5a <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80003814:	30 09       	mov	r9,0
80003816:	fe f8 04 86 	ld.w	r8,pc[1158]
8000381a:	91 09       	st.w	r8[0x0],r9
8000381c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003820:	fe f8 04 94 	ld.w	r8,pc[1172]
80003824:	11 89       	ld.ub	r9,r8[0x0]
80003826:	3f 38       	mov	r8,-13
80003828:	f0 09 18 00 	cp.b	r9,r8
8000382c:	e0 81 01 0c 	brne	80003a44 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003830:	8e 49       	ld.sh	r9,r7[0x8]
80003832:	fe f8 04 c2 	ld.w	r8,pc[1218]
80003836:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003838:	8e 59       	ld.sh	r9,r7[0xa]
8000383a:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
8000383c:	8e 69       	ld.sh	r9,r7[0xc]
8000383e:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003840:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003844:	fe f9 04 54 	ld.w	r9,pc[1108]
80003848:	72 0a       	ld.w	r10,r9[0x0]
8000384a:	70 09       	ld.w	r9,r8[0x0]
8000384c:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003850:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003854:	70 09       	ld.w	r9,r8[0x0]
80003856:	2f f9       	sub	r9,-1
80003858:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000385a:	e0 49 01 ff 	cp.w	r9,511
8000385e:	e0 88 00 16 	brls	8000388a <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
80003862:	30 09       	mov	r9,0
80003864:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003866:	fe f6 04 32 	ld.w	r6,pc[1074]
8000386a:	6c 0c       	ld.w	r12,r6[0x0]
8000386c:	f0 1f 01 16 	mcall	80003cc4 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003870:	fe f8 04 20 	ld.w	r8,pc[1056]
80003874:	70 0c       	ld.w	r12,r8[0x0]
80003876:	f0 1f 01 01 	mcall	80003c78 <phy_rx_func+0xe98>
8000387a:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000387c:	c0 71       	brne	8000388a <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
8000387e:	30 09       	mov	r9,0
80003880:	fe f8 04 1c 	ld.w	r8,pc[1052]
80003884:	91 09       	st.w	r8[0x0],r9
80003886:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000388a:	fe f9 04 1a 	ld.w	r9,pc[1050]
8000388e:	72 08       	ld.w	r8,r9[0x0]
80003890:	20 18       	sub	r8,1
80003892:	93 08       	st.w	r9[0x0],r8
80003894:	c0 71       	brne	800038a2 <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
80003896:	30 09       	mov	r9,0
80003898:	fe f8 04 04 	ld.w	r8,pc[1028]
8000389c:	91 09       	st.w	r8[0x0],r9
8000389e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
800038a2:	fe f8 04 1a 	ld.w	r8,pc[1050]
800038a6:	fe f9 03 f2 	ld.w	r9,pc[1010]
800038aa:	72 0a       	ld.w	r10,r9[0x0]
800038ac:	70 09       	ld.w	r9,r8[0x0]
800038ae:	ef 3b 00 09 	ld.ub	r11,r7[9]
800038b2:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800038b6:	70 09       	ld.w	r9,r8[0x0]
800038b8:	2f f9       	sub	r9,-1
800038ba:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038bc:	e0 49 01 ff 	cp.w	r9,511
800038c0:	e0 88 00 16 	brls	800038ec <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
800038c4:	30 09       	mov	r9,0
800038c6:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800038c8:	fe f6 03 d0 	ld.w	r6,pc[976]
800038cc:	6c 0c       	ld.w	r12,r6[0x0]
800038ce:	f0 1f 00 fe 	mcall	80003cc4 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800038d2:	fe f8 03 be 	ld.w	r8,pc[958]
800038d6:	70 0c       	ld.w	r12,r8[0x0]
800038d8:	f0 1f 00 e8 	mcall	80003c78 <phy_rx_func+0xe98>
800038dc:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038de:	c0 71       	brne	800038ec <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
800038e0:	30 09       	mov	r9,0
800038e2:	fe f8 03 ba 	ld.w	r8,pc[954]
800038e6:	91 09       	st.w	r8[0x0],r9
800038e8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038ec:	fe f9 03 b8 	ld.w	r9,pc[952]
800038f0:	72 08       	ld.w	r8,r9[0x0]
800038f2:	20 18       	sub	r8,1
800038f4:	93 08       	st.w	r9[0x0],r8
800038f6:	c0 71       	brne	80003904 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
800038f8:	30 09       	mov	r9,0
800038fa:	fe f8 03 a2 	ld.w	r8,pc[930]
800038fe:	91 09       	st.w	r8[0x0],r9
80003900:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003904:	fe f8 03 b8 	ld.w	r8,pc[952]
80003908:	fe f9 03 90 	ld.w	r9,pc[912]
8000390c:	72 0a       	ld.w	r10,r9[0x0]
8000390e:	70 09       	ld.w	r9,r8[0x0]
80003910:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003914:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003918:	70 09       	ld.w	r9,r8[0x0]
8000391a:	2f f9       	sub	r9,-1
8000391c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000391e:	e0 49 01 ff 	cp.w	r9,511
80003922:	e0 88 00 16 	brls	8000394e <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003926:	30 09       	mov	r9,0
80003928:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000392a:	fe f6 03 6e 	ld.w	r6,pc[878]
8000392e:	6c 0c       	ld.w	r12,r6[0x0]
80003930:	f0 1f 00 e5 	mcall	80003cc4 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003934:	fe f8 03 5c 	ld.w	r8,pc[860]
80003938:	70 0c       	ld.w	r12,r8[0x0]
8000393a:	f0 1f 00 d0 	mcall	80003c78 <phy_rx_func+0xe98>
8000393e:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003940:	c0 71       	brne	8000394e <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
80003942:	30 09       	mov	r9,0
80003944:	fe f8 03 58 	ld.w	r8,pc[856]
80003948:	91 09       	st.w	r8[0x0],r9
8000394a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000394e:	fe f9 03 56 	ld.w	r9,pc[854]
80003952:	72 08       	ld.w	r8,r9[0x0]
80003954:	20 18       	sub	r8,1
80003956:	93 08       	st.w	r9[0x0],r8
80003958:	c0 71       	brne	80003966 <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
8000395a:	30 09       	mov	r9,0
8000395c:	fe f8 03 40 	ld.w	r8,pc[832]
80003960:	91 09       	st.w	r8[0x0],r9
80003962:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003966:	fe f8 03 56 	ld.w	r8,pc[854]
8000396a:	fe f9 03 2e 	ld.w	r9,pc[814]
8000396e:	72 0a       	ld.w	r10,r9[0x0]
80003970:	70 09       	ld.w	r9,r8[0x0]
80003972:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003976:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000397a:	70 09       	ld.w	r9,r8[0x0]
8000397c:	2f f9       	sub	r9,-1
8000397e:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003980:	e0 49 01 ff 	cp.w	r9,511
80003984:	e0 88 00 16 	brls	800039b0 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003988:	30 09       	mov	r9,0
8000398a:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000398c:	fe f6 03 0c 	ld.w	r6,pc[780]
80003990:	6c 0c       	ld.w	r12,r6[0x0]
80003992:	f0 1f 00 cd 	mcall	80003cc4 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003996:	fe f8 02 fa 	ld.w	r8,pc[762]
8000399a:	70 0c       	ld.w	r12,r8[0x0]
8000399c:	f0 1f 00 b7 	mcall	80003c78 <phy_rx_func+0xe98>
800039a0:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800039a2:	c0 71       	brne	800039b0 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
800039a4:	30 09       	mov	r9,0
800039a6:	fe f8 02 f6 	ld.w	r8,pc[758]
800039aa:	91 09       	st.w	r8[0x0],r9
800039ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800039b0:	fe f9 02 f4 	ld.w	r9,pc[756]
800039b4:	72 08       	ld.w	r8,r9[0x0]
800039b6:	20 18       	sub	r8,1
800039b8:	93 08       	st.w	r9[0x0],r8
800039ba:	c0 71       	brne	800039c8 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
800039bc:	30 09       	mov	r9,0
800039be:	fe f8 02 de 	ld.w	r8,pc[734]
800039c2:	91 09       	st.w	r8[0x0],r9
800039c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
800039c8:	fe f8 02 f4 	ld.w	r8,pc[756]
800039cc:	fe f9 02 cc 	ld.w	r9,pc[716]
800039d0:	72 0a       	ld.w	r10,r9[0x0]
800039d2:	70 09       	ld.w	r9,r8[0x0]
800039d4:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800039d8:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800039dc:	70 09       	ld.w	r9,r8[0x0]
800039de:	2f f9       	sub	r9,-1
800039e0:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039e2:	e0 49 01 ff 	cp.w	r9,511
800039e6:	e0 88 00 16 	brls	80003a12 <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
800039ea:	30 09       	mov	r9,0
800039ec:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800039ee:	fe f7 02 aa 	ld.w	r7,pc[682]
800039f2:	6e 0c       	ld.w	r12,r7[0x0]
800039f4:	f0 1f 00 b4 	mcall	80003cc4 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800039f8:	fe f8 02 98 	ld.w	r8,pc[664]
800039fc:	70 0c       	ld.w	r12,r8[0x0]
800039fe:	f0 1f 00 9f 	mcall	80003c78 <phy_rx_func+0xe98>
80003a02:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003a04:	c0 71       	brne	80003a12 <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80003a06:	30 09       	mov	r9,0
80003a08:	fe f8 02 94 	ld.w	r8,pc[660]
80003a0c:	91 09       	st.w	r8[0x0],r9
80003a0e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003a12:	fe f9 02 92 	ld.w	r9,pc[658]
80003a16:	72 08       	ld.w	r8,r9[0x0]
80003a18:	20 18       	sub	r8,1
80003a1a:	93 08       	st.w	r9[0x0],r8
80003a1c:	c0 71       	brne	80003a2a <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003a1e:	30 09       	mov	r9,0
80003a20:	fe f8 02 7c 	ld.w	r8,pc[636]
80003a24:	91 09       	st.w	r8[0x0],r9
80003a26:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003a2a:	20 18       	sub	r8,1
80003a2c:	fe f9 02 78 	ld.w	r9,pc[632]
80003a30:	93 08       	st.w	r9[0x0],r8
80003a32:	58 08       	cp.w	r8,0
80003a34:	e0 81 01 13 	brne	80003c5a <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003a38:	30 09       	mov	r9,0
80003a3a:	fe f8 02 62 	ld.w	r8,pc[610]
80003a3e:	91 09       	st.w	r8[0x0],r9
80003a40:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003a44:	fe f8 02 70 	ld.w	r8,pc[624]
80003a48:	11 89       	ld.ub	r9,r8[0x0]
80003a4a:	30 48       	mov	r8,4
80003a4c:	f0 09 18 00 	cp.b	r9,r8
80003a50:	c0 80       	breq	80003a60 <phy_rx_func+0xc80>
80003a52:	fe f8 02 62 	ld.w	r8,pc[610]
80003a56:	11 89       	ld.ub	r9,r8[0x0]
80003a58:	30 38       	mov	r8,3
80003a5a:	f0 09 18 00 	cp.b	r9,r8
80003a5e:	c1 41       	brne	80003a86 <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003a60:	6e 29       	ld.w	r9,r7[0x8]
80003a62:	fe f8 02 7a 	ld.w	r8,pc[634]
80003a66:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003a68:	6e 39       	ld.w	r9,r7[0xc]
80003a6a:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003a6c:	fe f9 02 38 	ld.w	r9,pc[568]
80003a70:	72 08       	ld.w	r8,r9[0x0]
80003a72:	20 88       	sub	r8,8
80003a74:	93 08       	st.w	r9[0x0],r8
80003a76:	e0 81 00 f2 	brne	80003c5a <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003a7a:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003a7c:	fe f9 02 20 	ld.w	r9,pc[544]
80003a80:	93 08       	st.w	r9[0x0],r8
80003a82:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003a86:	fe f8 02 2e 	ld.w	r8,pc[558]
80003a8a:	11 89       	ld.ub	r9,r8[0x0]
80003a8c:	31 38       	mov	r8,19
80003a8e:	f0 09 18 00 	cp.b	r9,r8
80003a92:	e0 81 00 9c 	brne	80003bca <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80003a96:	fe f8 02 62 	ld.w	r8,pc[610]
80003a9a:	11 88       	ld.ub	r8,r8[0x0]
80003a9c:	30 c9       	mov	r9,12
80003a9e:	f2 08 18 00 	cp.b	r8,r9
80003aa2:	e0 81 00 7b 	brne	80003b98 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003aa6:	8e 49       	ld.sh	r9,r7[0x8]
80003aa8:	fe f8 02 54 	ld.w	r8,pc[596]
80003aac:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003ab0:	30 09       	mov	r9,0
80003ab2:	fe f8 02 46 	ld.w	r8,pc[582]
80003ab6:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003ab8:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003abc:	3f 38       	mov	r8,-13
80003abe:	f0 09 18 00 	cp.b	r9,r8
80003ac2:	c6 61       	brne	80003b8e <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003ac4:	10 99       	mov	r9,r8
80003ac6:	4f c8       	lddpc	r8,80003cb4 <phy_rx_func+0xed4>
80003ac8:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003aca:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003ace:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003ad2:	4f 58       	lddpc	r8,80003ca4 <phy_rx_func+0xec4>
80003ad4:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003ad6:	30 19       	mov	r9,1
80003ad8:	fe f8 02 0c 	ld.w	r8,pc[524]
80003adc:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003ade:	8e 79       	ld.sh	r9,r7[0xe]
80003ae0:	fe f8 02 14 	ld.w	r8,pc[532]
80003ae4:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003ae6:	4f 68       	lddpc	r8,80003cbc <phy_rx_func+0xedc>
80003ae8:	4e c9       	lddpc	r9,80003c98 <phy_rx_func+0xeb8>
80003aea:	72 0a       	ld.w	r10,r9[0x0]
80003aec:	70 09       	ld.w	r9,r8[0x0]
80003aee:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003af2:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003af6:	70 09       	ld.w	r9,r8[0x0]
80003af8:	2f f9       	sub	r9,-1
80003afa:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003afc:	e0 49 01 ff 	cp.w	r9,511
80003b00:	e0 88 00 13 	brls	80003b26 <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003b04:	30 09       	mov	r9,0
80003b06:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003b08:	4e 46       	lddpc	r6,80003c98 <phy_rx_func+0xeb8>
80003b0a:	6c 0c       	ld.w	r12,r6[0x0]
80003b0c:	f0 1f 00 6e 	mcall	80003cc4 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003b10:	4e 08       	lddpc	r8,80003c90 <phy_rx_func+0xeb0>
80003b12:	70 0c       	ld.w	r12,r8[0x0]
80003b14:	f0 1f 00 59 	mcall	80003c78 <phy_rx_func+0xe98>
80003b18:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003b1a:	c0 61       	brne	80003b26 <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003b1c:	30 09       	mov	r9,0
80003b1e:	4e 08       	lddpc	r8,80003c9c <phy_rx_func+0xebc>
80003b20:	91 09       	st.w	r8[0x0],r9
80003b22:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003b26:	4e 09       	lddpc	r9,80003ca4 <phy_rx_func+0xec4>
80003b28:	72 08       	ld.w	r8,r9[0x0]
80003b2a:	20 18       	sub	r8,1
80003b2c:	93 08       	st.w	r9[0x0],r8
80003b2e:	c0 61       	brne	80003b3a <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003b30:	30 09       	mov	r9,0
80003b32:	4d b8       	lddpc	r8,80003c9c <phy_rx_func+0xebc>
80003b34:	91 09       	st.w	r8[0x0],r9
80003b36:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003b3a:	4e 18       	lddpc	r8,80003cbc <phy_rx_func+0xedc>
80003b3c:	4d 79       	lddpc	r9,80003c98 <phy_rx_func+0xeb8>
80003b3e:	72 0a       	ld.w	r10,r9[0x0]
80003b40:	70 09       	ld.w	r9,r8[0x0]
80003b42:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003b46:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003b4a:	70 09       	ld.w	r9,r8[0x0]
80003b4c:	2f f9       	sub	r9,-1
80003b4e:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b50:	e0 49 01 ff 	cp.w	r9,511
80003b54:	e0 88 00 13 	brls	80003b7a <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003b58:	30 09       	mov	r9,0
80003b5a:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003b5c:	4c f7       	lddpc	r7,80003c98 <phy_rx_func+0xeb8>
80003b5e:	6e 0c       	ld.w	r12,r7[0x0]
80003b60:	f0 1f 00 59 	mcall	80003cc4 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003b64:	4c b8       	lddpc	r8,80003c90 <phy_rx_func+0xeb0>
80003b66:	70 0c       	ld.w	r12,r8[0x0]
80003b68:	f0 1f 00 44 	mcall	80003c78 <phy_rx_func+0xe98>
80003b6c:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003b6e:	c0 61       	brne	80003b7a <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003b70:	30 09       	mov	r9,0
80003b72:	4c b8       	lddpc	r8,80003c9c <phy_rx_func+0xebc>
80003b74:	91 09       	st.w	r8[0x0],r9
80003b76:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003b7a:	4c b9       	lddpc	r9,80003ca4 <phy_rx_func+0xec4>
80003b7c:	72 08       	ld.w	r8,r9[0x0]
80003b7e:	20 18       	sub	r8,1
80003b80:	93 08       	st.w	r9[0x0],r8
80003b82:	c6 c1       	brne	80003c5a <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003b84:	30 09       	mov	r9,0
80003b86:	4c 68       	lddpc	r8,80003c9c <phy_rx_func+0xebc>
80003b88:	91 09       	st.w	r8[0x0],r9
80003b8a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003b8e:	30 09       	mov	r9,0
80003b90:	4c 38       	lddpc	r8,80003c9c <phy_rx_func+0xebc>
80003b92:	91 09       	st.w	r8[0x0],r9
80003b94:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003b98:	8e 4a       	ld.sh	r10,r7[0x8]
80003b9a:	4d 99       	lddpc	r9,80003cfc <phy_rx_func+0xf1c>
80003b9c:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003ba0:	4d 6a       	lddpc	r10,80003cf8 <phy_rx_func+0xf18>
80003ba2:	15 88       	ld.ub	r8,r10[0x0]
80003ba4:	f0 cb ff ff 	sub	r11,r8,-1
80003ba8:	8e 5c       	ld.sh	r12,r7[0xa]
80003baa:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003bae:	f0 cb ff fe 	sub	r11,r8,-2
80003bb2:	8e 6c       	ld.sh	r12,r7[0xc]
80003bb4:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003bb8:	f0 cb ff fd 	sub	r11,r8,-3
80003bbc:	8e 7c       	ld.sh	r12,r7[0xe]
80003bbe:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003bc2:	2f c8       	sub	r8,-4
80003bc4:	b4 88       	st.b	r10[0x0],r8
80003bc6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003bca:	30 09       	mov	r9,0
80003bcc:	4b 48       	lddpc	r8,80003c9c <phy_rx_func+0xebc>
80003bce:	91 09       	st.w	r8[0x0],r9
80003bd0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003bd4:	4c 08       	lddpc	r8,80003cd4 <phy_rx_func+0xef4>
80003bd6:	70 09       	ld.w	r9,r8[0x0]
80003bd8:	8e 4b       	ld.sh	r11,r7[0x8]
80003bda:	4c 0a       	lddpc	r10,80003cd8 <phy_rx_func+0xef8>
80003bdc:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003be0:	2f f9       	sub	r9,-1
80003be2:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003be4:	4b 58       	lddpc	r8,80003cb8 <phy_rx_func+0xed8>
80003be6:	70 09       	ld.w	r9,r8[0x0]
80003be8:	20 29       	sub	r9,2
80003bea:	91 09       	st.w	r8[0x0],r9
80003bec:	70 08       	ld.w	r8,r8[0x0]
80003bee:	58 08       	cp.w	r8,0
80003bf0:	c2 f1       	brne	80003c4e <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003bf2:	30 09       	mov	r9,0
80003bf4:	4b 88       	lddpc	r8,80003cd4 <phy_rx_func+0xef4>
80003bf6:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003bf8:	8e 59       	ld.sh	r9,r7[0xa]
80003bfa:	fe 78 82 12 	mov	r8,-32238
80003bfe:	f0 09 19 00 	cp.h	r9,r8
80003c02:	c2 11       	brne	80003c44 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003c04:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003c08:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003c0c:	4a f8       	lddpc	r8,80003cc8 <phy_rx_func+0xee8>
80003c0e:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003c10:	8e 59       	ld.sh	r9,r7[0xa]
80003c12:	4a f8       	lddpc	r8,80003ccc <phy_rx_func+0xeec>
80003c14:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003c16:	8e 69       	ld.sh	r9,r7[0xc]
80003c18:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003c1a:	f0 1f 00 2e 	mcall	80003cd0 <phy_rx_func+0xef0>
80003c1e:	4a 18       	lddpc	r8,80003ca0 <phy_rx_func+0xec0>
80003c20:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003c22:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003c26:	31 38       	mov	r8,19
80003c28:	f0 09 18 00 	cp.b	r9,r8
80003c2c:	c0 71       	brne	80003c3a <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003c2e:	10 99       	mov	r9,r8
80003c30:	4a 18       	lddpc	r8,80003cb4 <phy_rx_func+0xed4>
80003c32:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003c34:	30 09       	mov	r9,0
80003c36:	49 c8       	lddpc	r8,80003ca4 <phy_rx_func+0xec4>
80003c38:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003c3a:	30 49       	mov	r9,4
80003c3c:	49 88       	lddpc	r8,80003c9c <phy_rx_func+0xebc>
80003c3e:	91 09       	st.w	r8[0x0],r9
80003c40:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003c44:	30 09       	mov	r9,0
80003c46:	49 68       	lddpc	r8,80003c9c <phy_rx_func+0xebc>
80003c48:	91 09       	st.w	r8[0x0],r9
80003c4a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003c4e:	4a dc       	lddpc	r12,80003d00 <phy_rx_func+0xf20>
80003c50:	f0 1f 00 18 	mcall	80003cb0 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003c54:	30 09       	mov	r9,0
80003c56:	49 28       	lddpc	r8,80003c9c <phy_rx_func+0xebc>
80003c58:	91 09       	st.w	r8[0x0],r9
80003c5a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003c5e:	00 00       	add	r0,r0
80003c60:	00 00       	add	r0,r0
80003c62:	0a b4       	st.h	r5++,r4
80003c64:	00 00       	add	r0,r0
80003c66:	0a cc       	st.b	r5++,r12
80003c68:	00 00       	add	r0,r0
80003c6a:	0a ac       	st.w	r5++,r12
80003c6c:	00 00       	add	r0,r0
80003c6e:	0a 8e       	andn	lr,r5
80003c70:	00 00       	add	r0,r0
80003c72:	0a 7c       	tst	r12,r5
80003c74:	00 00       	add	r0,r0
80003c76:	0a a4       	st.w	r5++,r4
80003c78:	80 00       	ld.sh	r0,r0[0x0]
80003c7a:	2c 60       	sub	r0,-58
80003c7c:	00 00       	add	r0,r0
80003c7e:	0a 9c       	mov	r12,r5
80003c80:	80 00       	ld.sh	r0,r0[0x0]
80003c82:	2b 78       	sub	r8,-73
80003c84:	00 00       	add	r0,r0
80003c86:	0a b0       	st.h	r5++,r0
80003c88:	80 00       	ld.sh	r0,r0[0x0]
80003c8a:	2b ac       	sub	r12,-70
80003c8c:	00 00       	add	r0,r0
80003c8e:	0a 8d       	andn	sp,r5
80003c90:	00 00       	add	r0,r0
80003c92:	0a a8       	st.w	r5++,r8
80003c94:	00 00       	add	r0,r0
80003c96:	0a b8       	st.h	r5++,r8
80003c98:	00 00       	add	r0,r0
80003c9a:	0a 90       	mov	r0,r5
80003c9c:	00 00       	add	r0,r0
80003c9e:	0a d8       	st.w	--r5,r8
80003ca0:	00 00       	add	r0,r0
80003ca2:	0a c0       	st.b	r5++,r0
80003ca4:	00 00       	add	r0,r0
80003ca6:	0a 78       	tst	r8,r5
80003ca8:	00 00       	add	r0,r0
80003caa:	0a 4c       	or	r12,r5
80003cac:	80 00       	ld.sh	r0,r0[0x0]
80003cae:	d7 f4       	*unknown*
80003cb0:	80 00       	ld.sh	r0,r0[0x0]
80003cb2:	71 04       	ld.w	r4,r8[0x40]
80003cb4:	00 00       	add	r0,r0
80003cb6:	0a 8c       	andn	r12,r5
80003cb8:	00 00       	add	r0,r0
80003cba:	0a e4       	st.h	--r5,r4
80003cbc:	00 00       	add	r0,r0
80003cbe:	0a c4       	st.b	r5++,r4
80003cc0:	80 00       	ld.sh	r0,r0[0x0]
80003cc2:	79 3c       	ld.w	r12,r12[0x4c]
80003cc4:	80 00       	ld.sh	r0,r0[0x0]
80003cc6:	2b 94       	sub	r4,-71
80003cc8:	00 00       	add	r0,r0
80003cca:	0a 5d       	eor	sp,r5
80003ccc:	00 00       	add	r0,r0
80003cce:	1e b4       	st.h	pc++,r4
80003cd0:	80 00       	ld.sh	r0,r0[0x0]
80003cd2:	2b 48       	sub	r8,-76
80003cd4:	00 00       	add	r0,r0
80003cd6:	0a 80       	andn	r0,r5
80003cd8:	00 00       	add	r0,r0
80003cda:	1d b8       	ld.ub	r8,lr[0x3]
80003cdc:	00 00       	add	r0,r0
80003cde:	0a 84       	andn	r4,r5
80003ce0:	00 00       	add	r0,r0
80003ce2:	0a 48       	or	r8,r5
80003ce4:	00 00       	add	r0,r0
80003ce6:	0a 4b       	or	r11,r5
80003ce8:	00 00       	add	r0,r0
80003cea:	0a dc       	st.w	--r5,r12
80003cec:	00 00       	add	r0,r0
80003cee:	0a 98       	mov	r8,r5
80003cf0:	00 00       	add	r0,r0
80003cf2:	0a 64       	and	r4,r5
80003cf4:	00 00       	add	r0,r0
80003cf6:	1d b0       	ld.ub	r0,lr[0x3]
80003cf8:	00 00       	add	r0,r0
80003cfa:	0a d0       	st.w	--r5,r0
80003cfc:	00 00       	add	r0,r0
80003cfe:	1e b8       	st.h	pc++,r8
80003d00:	80 00       	ld.sh	r0,r0[0x0]
80003d02:	d8 0c       	*unknown*

80003d04 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003d04:	d4 01       	pushm	lr
	//xHigherPriorityTaskWoken = pdFALSE;
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
80003d06:	49 a8       	lddpc	r8,80003d6c <pdca_int_handler+0x68>
80003d08:	70 09       	ld.w	r9,r8[0x0]
80003d0a:	2f f9       	sub	r9,-1
80003d0c:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003d0e:	49 98       	lddpc	r8,80003d70 <pdca_int_handler+0x6c>
80003d10:	11 89       	ld.ub	r9,r8[0x0]
80003d12:	ec 19 00 01 	eorl	r9,0x1
80003d16:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003d18:	11 89       	ld.ub	r9,r8[0x0]
80003d1a:	a5 69       	lsl	r9,0x4
80003d1c:	2f c9       	sub	r9,-4
80003d1e:	49 6a       	lddpc	r10,80003d74 <pdca_int_handler+0x70>
80003d20:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003d22:	fe 7a 00 40 	mov	r10,-65472
80003d26:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003d28:	30 39       	mov	r9,3
80003d2a:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003d2c:	11 8a       	ld.ub	r10,r8[0x0]
80003d2e:	a5 6a       	lsl	r10,0x4
80003d30:	2f ca       	sub	r10,-4
80003d32:	49 28       	lddpc	r8,80003d78 <pdca_int_handler+0x74>
80003d34:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003d36:	fe 78 00 00 	mov	r8,-65536
80003d3a:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003d3c:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003d3e:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003d40:	48 f8       	lddpc	r8,80003d7c <pdca_int_handler+0x78>
80003d42:	70 08       	ld.w	r8,r8[0x0]
80003d44:	58 08       	cp.w	r8,0
80003d46:	c0 70       	breq	80003d54 <pdca_int_handler+0x50>
80003d48:	48 a9       	lddpc	r9,80003d70 <pdca_int_handler+0x6c>
80003d4a:	13 89       	ld.ub	r9,r9[0x0]
80003d4c:	a5 69       	lsl	r9,0x4
80003d4e:	48 bc       	lddpc	r12,80003d78 <pdca_int_handler+0x74>
80003d50:	12 0c       	add	r12,r9
80003d52:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003d54:	48 b8       	lddpc	r8,80003d80 <pdca_int_handler+0x7c>
80003d56:	70 08       	ld.w	r8,r8[0x0]
80003d58:	58 08       	cp.w	r8,0
80003d5a:	c0 70       	breq	80003d68 <pdca_int_handler+0x64>
80003d5c:	48 59       	lddpc	r9,80003d70 <pdca_int_handler+0x6c>
80003d5e:	13 89       	ld.ub	r9,r9[0x0]
80003d60:	a5 69       	lsl	r9,0x4
80003d62:	48 5c       	lddpc	r12,80003d74 <pdca_int_handler+0x70>
80003d64:	12 0c       	add	r12,r9
80003d66:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003d68:	d4 02       	popm	lr
80003d6a:	d6 03       	rete
80003d6c:	00 00       	add	r0,r0
80003d6e:	0a ec       	st.h	--r5,r12
80003d70:	00 00       	add	r0,r0
80003d72:	50 d8       	stdsp	sp[0x34],r8
80003d74:	00 00       	add	r0,r0
80003d76:	51 00       	stdsp	sp[0x40],r0
80003d78:	00 00       	add	r0,r0
80003d7a:	50 e0       	stdsp	sp[0x38],r0
80003d7c:	00 00       	add	r0,r0
80003d7e:	0a e8       	st.h	--r5,r8
80003d80:	00 00       	add	r0,r0
80003d82:	0a f0       	st.b	--r5,r0

80003d84 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003d84:	fe 78 10 00 	mov	r8,-61440
80003d88:	e0 69 0d c0 	mov	r9,3520
80003d8c:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003d90:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003d94:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003d98:	fe 78 34 00 	mov	r8,-52224
80003d9c:	e0 69 80 00 	mov	r9,32768
80003da0:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003da2:	30 09       	mov	r9,0
80003da4:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003da6:	e0 69 04 21 	mov	r9,1057
80003daa:	ea 19 3f 20 	orh	r9,0x3f20
80003dae:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80003db0:	e0 69 02 9f 	mov	r9,671
80003db4:	ea 19 01 00 	orh	r9,0x100
80003db8:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80003dba:	e0 6a 04 02 	mov	r10,1026
80003dbe:	ea 1a 3f 20 	orh	r10,0x3f20
80003dc2:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80003dc4:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003dc6:	5e fc       	retal	r12

80003dc8 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003dc8:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003dca:	30 19       	mov	r9,1
80003dcc:	49 78       	lddpc	r8,80003e28 <local_start_PDC+0x60>
80003dce:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003dd0:	fe 78 00 00 	mov	r8,-65536
80003dd4:	30 7b       	mov	r11,7
80003dd6:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003dd8:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003dda:	49 59       	lddpc	r9,80003e2c <local_start_PDC+0x64>
80003ddc:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003de0:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003de2:	30 3a       	mov	r10,3
80003de4:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003de6:	30 1c       	mov	r12,1
80003de8:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003dea:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003dec:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003dee:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003df0:	30 2c       	mov	r12,2
80003df2:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003df4:	48 f9       	lddpc	r9,80003e30 <local_start_PDC+0x68>
80003df6:	e0 68 5a 5a 	mov	r8,23130
80003dfa:	ea 18 ab cd 	orh	r8,0xabcd
80003dfe:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003e00:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003e02:	30 0e       	mov	lr,0
80003e04:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003e06:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003e08:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003e0a:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003e0c:	fe 78 00 40 	mov	r8,-65472
80003e10:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003e12:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003e14:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003e18:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003e1a:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003e1c:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003e1e:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003e20:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003e22:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003e24:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003e26:	d8 02       	popm	pc
80003e28:	00 00       	add	r0,r0
80003e2a:	50 d8       	stdsp	sp[0x34],r8
80003e2c:	00 00       	add	r0,r0
80003e2e:	50 e0       	stdsp	sp[0x38],r0
80003e30:	00 00       	add	r0,r0
80003e32:	51 00       	stdsp	sp[0x40],r0

80003e34 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003e34:	48 38       	lddpc	r8,80003e40 <register_rx_tx_func+0xc>
80003e36:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003e38:	48 38       	lddpc	r8,80003e44 <register_rx_tx_func+0x10>
80003e3a:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003e3c:	5e fc       	retal	r12
80003e3e:	00 00       	add	r0,r0
80003e40:	00 00       	add	r0,r0
80003e42:	0a e8       	st.h	--r5,r8
80003e44:	00 00       	add	r0,r0
80003e46:	0a f0       	st.b	--r5,r0

80003e48 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003e48:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003e4a:	fe 78 10 00 	mov	r8,-61440
80003e4e:	30 29       	mov	r9,2
80003e50:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003e54:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80003e58:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
80003e5a:	30 3a       	mov	r10,3
80003e5c:	36 0b       	mov	r11,96
80003e5e:	49 4c       	lddpc	r12,80003eac <ssc_init+0x64>
80003e60:	f0 1f 00 14 	mcall	80003eb0 <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
80003e64:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003e66:	fe 79 10 00 	mov	r9,-61440
80003e6a:	f2 f8 01 60 	ld.w	r8,r9[352]
80003e6e:	e2 18 00 02 	andl	r8,0x2,COH
80003e72:	cf c0       	breq	80003e6a <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003e74:	fe 79 10 00 	mov	r9,-61440
80003e78:	f2 f8 01 60 	ld.w	r8,r9[352]
80003e7c:	e2 18 00 02 	andl	r8,0x2,COH
80003e80:	cf c1       	brne	80003e78 <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
80003e82:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80003e84:	f0 1f 00 0c 	mcall	80003eb4 <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
80003e88:	f0 1f 00 0c 	mcall	80003eb8 <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003e8c:	fe 79 00 00 	mov	r9,-65536
80003e90:	30 18       	mov	r8,1
80003e92:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003e94:	fe 7a 00 40 	mov	r10,-65472
80003e98:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003e9a:	e0 6b 01 01 	mov	r11,257
80003e9e:	fe 7a 34 00 	mov	r10,-52224
80003ea2:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80003ea4:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80003ea6:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80003ea8:	d8 02       	popm	pc
80003eaa:	00 00       	add	r0,r0
80003eac:	80 00       	ld.sh	r0,r0[0x0]
80003eae:	3d 04       	mov	r4,-48
80003eb0:	80 00       	ld.sh	r0,r0[0x0]
80003eb2:	55 50       	stdsp	sp[0x154],r0
80003eb4:	80 00       	ld.sh	r0,r0[0x0]
80003eb6:	3d 84       	mov	r4,-40
80003eb8:	80 00       	ld.sh	r0,r0[0x0]
80003eba:	3d c8       	mov	r8,-36

80003ebc <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003ebc:	48 28       	lddpc	r8,80003ec4 <xcmp_register_app_list+0x8>
80003ebe:	91 0c       	st.w	r8[0x0],r12
}
80003ec0:	5e fc       	retal	r12
80003ec2:	00 00       	add	r0,r0
80003ec4:	00 00       	add	r0,r0
80003ec6:	51 20       	stdsp	sp[0x48],r0

80003ec8 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003ec8:	eb cd 40 80 	pushm	r7,lr
80003ecc:	fa cd 01 00 	sub	sp,sp,256
80003ed0:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003ed2:	16 98       	mov	r8,r11
80003ed4:	2f 08       	sub	r8,-16
80003ed6:	af a8       	sbr	r8,0xe
80003ed8:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003eda:	3f f8       	mov	r8,-1
80003edc:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003ede:	30 b9       	mov	r9,11
80003ee0:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003ee2:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003ee4:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003ee6:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003ee8:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003eea:	f6 ca ff fe 	sub	r10,r11,-2
80003eee:	18 9b       	mov	r11,r12
80003ef0:	fa cc ff f0 	sub	r12,sp,-16
80003ef4:	f0 1f 00 05 	mcall	80003f08 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003ef8:	2f e7       	sub	r7,-2
80003efa:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003efc:	1a 9c       	mov	r12,sp
80003efe:	f0 1f 00 04 	mcall	80003f0c <xcmp_tx+0x44>
}
80003f02:	2c 0d       	sub	sp,-256
80003f04:	e3 cd 80 80 	ldm	sp++,r7,pc
80003f08:	80 00       	ld.sh	r0,r0[0x0]
80003f0a:	77 f4       	ld.w	r4,r11[0x7c]
80003f0c:	80 00       	ld.sh	r0,r0[0x0]
80003f0e:	44 d8       	lddsp	r8,sp[0x134]

80003f10 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U32 dest)
{
80003f10:	d4 21       	pushm	r4-r7,lr
80003f12:	fa cd 00 d0 	sub	sp,sp,208
80003f16:	18 94       	mov	r4,r12
80003f18:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003f1a:	e0 68 01 00 	mov	r8,256
80003f1e:	f0 0b 19 00 	cp.h	r11,r8
80003f22:	e0 8b 00 38 	brhi	80003f92 <xcmp_data_session_req+0x82>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003f26:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003f2a:	e0 68 04 1d 	mov	r8,1053
80003f2e:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003f30:	30 18       	mov	r8,1
80003f32:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80003f34:	32 08       	mov	r8,32
80003f36:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003f38:	30 28       	mov	r8,2
80003f3a:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003f3c:	30 48       	mov	r8,4
80003f3e:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80003f40:	f5 da c0 18 	bfextu	r10,r10,0x0,0x18
80003f44:	ea 1a 0c 00 	orh	r10,0xc00
80003f48:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80003f4a:	30 4a       	mov	r10,4
80003f4c:	1a 9b       	mov	r11,sp
80003f4e:	fa cc ff f4 	sub	r12,sp,-12
80003f52:	f0 1f 00 12 	mcall	80003f98 <xcmp_data_session_req+0x88>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80003f56:	30 f8       	mov	r8,15
80003f58:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80003f5c:	3a 78       	mov	r8,-89
80003f5e:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80003f62:	30 08       	mov	r8,0
80003f64:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80003f68:	0e 9a       	mov	r10,r7
80003f6a:	5c 7a       	castu.h	r10
80003f6c:	f4 08 16 08 	lsr	r8,r10,0x8
80003f70:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80003f74:	0e 96       	mov	r6,r7
80003f76:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80003f7a:	08 9b       	mov	r11,r4
80003f7c:	fa cc ff eb 	sub	r12,sp,-21
80003f80:	f0 1f 00 06 	mcall	80003f98 <xcmp_data_session_req+0x88>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80003f84:	ee cb ff f3 	sub	r11,r7,-13
80003f88:	5c 5b       	castu.b	r11
80003f8a:	fa cc ff fa 	sub	r12,sp,-6
80003f8e:	f0 1f 00 04 	mcall	80003f9c <xcmp_data_session_req+0x8c>
}
80003f92:	2c cd       	sub	sp,-208
80003f94:	d8 22       	popm	r4-r7,pc
80003f96:	00 00       	add	r0,r0
80003f98:	80 00       	ld.sh	r0,r0[0x0]
80003f9a:	77 f4       	ld.w	r4,r11[0x7c]
80003f9c:	80 00       	ld.sh	r0,r0[0x0]
80003f9e:	3e c8       	mov	r8,-20

80003fa0 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003fa0:	d4 01       	pushm	lr
80003fa2:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003fa6:	fe 78 b4 00 	mov	r8,-19456
80003faa:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003fac:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003fb0:	30 89       	mov	r9,8
80003fb2:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003fb4:	30 19       	mov	r9,1
80003fb6:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003fb8:	30 09       	mov	r9,0
80003fba:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003fbc:	30 5a       	mov	r10,5
80003fbe:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003fc0:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003fc2:	30 7a       	mov	r10,7
80003fc4:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003fc6:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003fc8:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003fca:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003fce:	30 9b       	mov	r11,9
80003fd0:	fa cc ff fe 	sub	r12,sp,-2
80003fd4:	f0 1f 00 02 	mcall	80003fdc <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003fd8:	2c dd       	sub	sp,-204
80003fda:	d8 02       	popm	pc
80003fdc:	80 00       	ld.sh	r0,r0[0x0]
80003fde:	3e c8       	mov	r8,-20

80003fe0 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003fe0:	d4 01       	pushm	lr
80003fe2:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003fe6:	fe 78 80 00 	mov	r8,-32768
80003fea:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003fec:	30 38       	mov	r8,3
80003fee:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80003ff0:	30 1b       	mov	r11,1
80003ff2:	fa cc ff fe 	sub	r12,sp,-2
80003ff6:	f0 1f 00 03 	mcall	80004000 <xcmp_opcode_not_supported+0x20>
}
80003ffa:	2c dd       	sub	sp,-204
80003ffc:	d8 02       	popm	pc
80003ffe:	00 00       	add	r0,r0
80004000:	80 00       	ld.sh	r0,r0[0x0]
80004002:	3e c8       	mov	r8,-20

80004004 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004004:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80004006:	96 88       	ld.uh	r8,r11[0x0]
80004008:	e2 18 f0 00 	andl	r8,0xf000,COH
8000400c:	e0 48 80 00 	cp.w	r8,32768
80004010:	c0 f0       	breq	8000402e <xcmp_exec_func+0x2a>
80004012:	e0 48 b0 00 	cp.w	r8,45056
80004016:	c1 20       	breq	8000403a <xcmp_exec_func+0x36>
80004018:	58 08       	cp.w	r8,0
8000401a:	c1 51       	brne	80004044 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
8000401c:	78 08       	ld.w	r8,r12[0x0]
8000401e:	58 08       	cp.w	r8,0
80004020:	c0 40       	breq	80004028 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80004022:	16 9c       	mov	r12,r11
80004024:	5d 18       	icall	r8
80004026:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004028:	f0 1f 00 08 	mcall	80004048 <xcmp_exec_func+0x44>
8000402c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
8000402e:	78 18       	ld.w	r8,r12[0x4]
80004030:	58 08       	cp.w	r8,0
80004032:	c0 90       	breq	80004044 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004034:	16 9c       	mov	r12,r11
80004036:	5d 18       	icall	r8
80004038:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
8000403a:	78 28       	ld.w	r8,r12[0x8]
8000403c:	58 08       	cp.w	r8,0
8000403e:	c0 30       	breq	80004044 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004040:	16 9c       	mov	r12,r11
80004042:	5d 18       	icall	r8
80004044:	d8 02       	popm	pc
80004046:	00 00       	add	r0,r0
80004048:	80 00       	ld.sh	r0,r0[0x0]
8000404a:	3f e0       	mov	r0,-2

8000404c <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
8000404c:	d4 01       	pushm	lr
8000404e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80004052:	e0 68 04 09 	mov	r8,1033
80004056:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004058:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
8000405c:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
8000405e:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
80004062:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80004064:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80004066:	30 09       	mov	r9,0
80004068:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
8000406a:	fb 69 00 08 	st.b	sp[8],r9
8000406e:	fa c8 ff f7 	sub	r8,sp,-9
80004072:	b0 89       	st.b	r8[0x0],r9
80004074:	fa c8 ff f6 	sub	r8,sp,-10
80004078:	b0 89       	st.b	r8[0x0],r9
8000407a:	fa c8 ff f5 	sub	r8,sp,-11
8000407e:	b0 89       	st.b	r8[0x0],r9
80004080:	fa c8 ff f4 	sub	r8,sp,-12
80004084:	b0 89       	st.b	r8[0x0],r9
80004086:	fa c8 ff f3 	sub	r8,sp,-13
8000408a:	b0 89       	st.b	r8[0x0],r9
8000408c:	fa c8 ff f2 	sub	r8,sp,-14
80004090:	b0 89       	st.b	r8[0x0],r9
80004092:	fa c8 ff f1 	sub	r8,sp,-15
80004096:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80004098:	30 cb       	mov	r11,12
8000409a:	fa cc ff fe 	sub	r12,sp,-2
8000409e:	f0 1f 00 03 	mcall	800040a8 <xcmp_IdleTestTone+0x5c>
}
800040a2:	2c dd       	sub	sp,-204
800040a4:	d8 02       	popm	pc
800040a6:	00 00       	add	r0,r0
800040a8:	80 00       	ld.sh	r0,r0[0x0]
800040aa:	3e c8       	mov	r8,-20

800040ac <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
800040ac:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
800040ae:	48 dc       	lddpc	r12,800040e0 <xcmp_init+0x34>
800040b0:	f0 1f 00 0d 	mcall	800040e4 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
800040b4:	30 4b       	mov	r11,4
800040b6:	31 4c       	mov	r12,20
800040b8:	f0 1f 00 0c 	mcall	800040e8 <xcmp_init+0x3c>
800040bc:	48 c8       	lddpc	r8,800040ec <xcmp_init+0x40>
800040be:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
800040c0:	30 09       	mov	r9,0
800040c2:	1a d9       	st.w	--sp,r9
800040c4:	1a d9       	st.w	--sp,r9
800040c6:	1a d9       	st.w	--sp,r9
800040c8:	30 38       	mov	r8,3
800040ca:	e0 6a 04 00 	mov	r10,1024
800040ce:	48 9b       	lddpc	r11,800040f0 <xcmp_init+0x44>
800040d0:	48 9c       	lddpc	r12,800040f4 <xcmp_init+0x48>
800040d2:	f0 1f 00 0a 	mcall	800040f8 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
800040d6:	f0 1f 00 0a 	mcall	800040fc <xcmp_init+0x50>
800040da:	2f dd       	sub	sp,-12
	
}
800040dc:	d8 02       	popm	pc
800040de:	00 00       	add	r0,r0
800040e0:	80 00       	ld.sh	r0,r0[0x0]
800040e2:	41 fc       	lddsp	r12,sp[0x7c]
800040e4:	80 00       	ld.sh	r0,r0[0x0]
800040e6:	42 48       	lddsp	r8,sp[0x90]
800040e8:	80 00       	ld.sh	r0,r0[0x0]
800040ea:	64 98       	ld.w	r8,r2[0x24]
800040ec:	00 00       	add	r0,r0
800040ee:	0b 0c       	ld.w	r12,r5++
800040f0:	80 00       	ld.sh	r0,r0[0x0]
800040f2:	d8 38       	*unknown*
800040f4:	80 00       	ld.sh	r0,r0[0x0]
800040f6:	41 00       	lddsp	r0,sp[0x40]
800040f8:	80 00       	ld.sh	r0,r0[0x0]
800040fa:	6b b4       	ld.w	r4,r5[0x6c]
800040fc:	80 00       	ld.sh	r0,r0[0x0]
800040fe:	42 80       	lddsp	r0,sp[0xa0]

80004100 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004100:	d4 31       	pushm	r0-r7,lr
80004102:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004104:	4b 16       	lddpc	r6,800041c8 <xcmp_rx_process+0xc8>
80004106:	30 05       	mov	r5,0
80004108:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
8000410a:	4b 13       	lddpc	r3,800041cc <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
8000410c:	4b 12       	lddpc	r2,800041d0 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000410e:	4b 21       	lddpc	r1,800041d4 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004110:	4b 20       	lddpc	r0,800041d8 <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004112:	6c 0c       	ld.w	r12,r6[0x0]
80004114:	0a 99       	mov	r9,r5
80004116:	08 9a       	mov	r10,r4
80004118:	1a 9b       	mov	r11,sp
8000411a:	f0 1f 00 31 	mcall	800041dc <xcmp_rx_process+0xdc>
8000411e:	58 1c       	cp.w	r12,1
80004120:	cf 91       	brne	80004112 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80004122:	40 0b       	lddsp	r11,sp[0x0]
80004124:	58 0b       	cp.w	r11,0
80004126:	cf 60       	breq	80004112 <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
80004128:	96 0a       	ld.sh	r10,r11[0x0]
8000412a:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000412e:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80004132:	59 c8       	cp.w	r8,28
80004134:	c1 e0       	breq	80004170 <xcmp_rx_process+0x70>
80004136:	e0 89 00 07 	brgt	80004144 <xcmp_rx_process+0x44>
8000413a:	58 e8       	cp.w	r8,14
8000413c:	c0 e0       	breq	80004158 <xcmp_rx_process+0x58>
8000413e:	58 f8       	cp.w	r8,15
80004140:	c2 41       	brne	80004188 <xcmp_rx_process+0x88>
80004142:	c0 f8       	rjmp	80004160 <xcmp_rx_process+0x60>
80004144:	e0 48 01 09 	cp.w	r8,265
80004148:	c1 80       	breq	80004178 <xcmp_rx_process+0x78>
8000414a:	e0 48 01 0a 	cp.w	r8,266
8000414e:	c1 90       	breq	80004180 <xcmp_rx_process+0x80>
80004150:	e0 48 00 2c 	cp.w	r8,44
80004154:	c1 a1       	brne	80004188 <xcmp_rx_process+0x88>
80004156:	c0 98       	rjmp	80004168 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004158:	4a 2c       	lddpc	r12,800041e0 <xcmp_rx_process+0xe0>
8000415a:	f0 1f 00 23 	mcall	800041e4 <xcmp_rx_process+0xe4>
					break;
8000415e:	c2 f8       	rjmp	800041bc <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004160:	4a 2c       	lddpc	r12,800041e8 <xcmp_rx_process+0xe8>
80004162:	f0 1f 00 21 	mcall	800041e4 <xcmp_rx_process+0xe4>
					break;
80004166:	c2 b8       	rjmp	800041bc <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004168:	4a 1c       	lddpc	r12,800041ec <xcmp_rx_process+0xec>
8000416a:	f0 1f 00 1f 	mcall	800041e4 <xcmp_rx_process+0xe4>
					break;
8000416e:	c2 78       	rjmp	800041bc <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004170:	04 9c       	mov	r12,r2
80004172:	f0 1f 00 1d 	mcall	800041e4 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80004176:	c2 38       	rjmp	800041bc <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004178:	02 9c       	mov	r12,r1
8000417a:	f0 1f 00 1b 	mcall	800041e4 <xcmp_rx_process+0xe4>
					break;
8000417e:	c1 f8       	rjmp	800041bc <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004180:	00 9c       	mov	r12,r0
80004182:	f0 1f 00 19 	mcall	800041e4 <xcmp_rx_process+0xe4>
					break;
80004186:	c1 b8       	rjmp	800041bc <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004188:	12 98       	mov	r8,r9
8000418a:	e2 18 04 00 	andl	r8,0x400,COH
8000418e:	c0 70       	breq	8000419c <xcmp_rx_process+0x9c>
80004190:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004194:	e0 48 00 68 	cp.w	r8,104
80004198:	e0 8a 00 08 	brle	800041a8 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
8000419c:	e2 19 f0 00 	andl	r9,0xf000,COH
800041a0:	c0 e1       	brne	800041bc <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
800041a2:	f0 1f 00 14 	mcall	800041f0 <xcmp_rx_process+0xf0>
800041a6:	c0 b8       	rjmp	800041bc <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800041a8:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800041ac:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800041b0:	49 19       	lddpc	r9,800041f4 <xcmp_rx_process+0xf4>
800041b2:	72 08       	ld.w	r8,r9[0x0]
800041b4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800041b8:	f0 1f 00 0b 	mcall	800041e4 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800041bc:	66 0c       	ld.w	r12,r3[0x0]
800041be:	40 0b       	lddsp	r11,sp[0x0]
800041c0:	f0 1f 00 0e 	mcall	800041f8 <xcmp_rx_process+0xf8>
800041c4:	ca 7b       	rjmp	80004112 <xcmp_rx_process+0x12>
800041c6:	00 00       	add	r0,r0
800041c8:	00 00       	add	r0,r0
800041ca:	0b 0c       	ld.w	r12,r5++
800041cc:	00 00       	add	r0,r0
800041ce:	0a a4       	st.w	r5++,r4
800041d0:	00 00       	add	r0,r0
800041d2:	0b 1c       	ld.sh	r12,r5++
800041d4:	00 00       	add	r0,r0
800041d6:	0b 10       	ld.sh	r0,r5++
800041d8:	00 00       	add	r0,r0
800041da:	0b 00       	ld.w	r0,r5++
800041dc:	80 00       	ld.sh	r0,r0[0x0]
800041de:	61 34       	ld.w	r4,r0[0x4c]
800041e0:	00 00       	add	r0,r0
800041e2:	0b 34       	ld.ub	r4,r5++
800041e4:	80 00       	ld.sh	r0,r0[0x0]
800041e6:	40 04       	lddsp	r4,sp[0x0]
800041e8:	00 00       	add	r0,r0
800041ea:	0a f4       	st.b	--r5,r4
800041ec:	00 00       	add	r0,r0
800041ee:	0b 28       	ld.uh	r8,r5++
800041f0:	80 00       	ld.sh	r0,r0[0x0]
800041f2:	3f e0       	mov	r0,-2
800041f4:	00 00       	add	r0,r0
800041f6:	51 20       	stdsp	sp[0x48],r0
800041f8:	80 00       	ld.sh	r0,r0[0x0]
800041fa:	2b e4       	sub	r4,-66

800041fc <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800041fc:	eb cd 40 90 	pushm	r4,r7,lr
80004200:	20 1d       	sub	sp,4
80004202:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004206:	48 c8       	lddpc	r8,80004234 <xcmp_rx+0x38>
80004208:	70 0c       	ld.w	r12,r8[0x0]
8000420a:	f0 1f 00 0c 	mcall	80004238 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000420e:	c1 00       	breq	8000422e <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004210:	fa c7 ff fc 	sub	r7,sp,-4
80004214:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004216:	e0 6a 00 ca 	mov	r10,202
8000421a:	08 9b       	mov	r11,r4
8000421c:	f0 1f 00 08 	mcall	8000423c <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004220:	48 88       	lddpc	r8,80004240 <xcmp_rx+0x44>
80004222:	70 0c       	ld.w	r12,r8[0x0]
80004224:	30 09       	mov	r9,0
80004226:	12 9a       	mov	r10,r9
80004228:	1a 9b       	mov	r11,sp
8000422a:	f0 1f 00 07 	mcall	80004244 <xcmp_rx+0x48>
	}	
}
8000422e:	2f fd       	sub	sp,-4
80004230:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004234:	00 00       	add	r0,r0
80004236:	0a a4       	st.w	r5++,r4
80004238:	80 00       	ld.sh	r0,r0[0x0]
8000423a:	2d 90       	sub	r0,-39
8000423c:	80 00       	ld.sh	r0,r0[0x0]
8000423e:	77 f4       	ld.w	r4,r11[0x7c]
80004240:	00 00       	add	r0,r0
80004242:	0b 0c       	ld.w	r12,r5++
80004244:	80 00       	ld.sh	r0,r0[0x0]
80004246:	63 40       	ld.w	r0,r1[0x50]

80004248 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004248:	48 28       	lddpc	r8,80004250 <xnl_register_xcmp_func+0x8>
8000424a:	91 0c       	st.w	r8[0x0],r12
}
8000424c:	5e fc       	retal	r12
8000424e:	00 00       	add	r0,r0
80004250:	00 00       	add	r0,r0
80004252:	0b 60       	ld.uh	r0,--r5

80004254 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004254:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004256:	48 88       	lddpc	r8,80004274 <xnl_get_msg_ack_func+0x20>
80004258:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
8000425a:	98 49       	ld.sh	r9,r12[0x8]
8000425c:	f0 09 19 00 	cp.h	r9,r8
80004260:	c0 81       	brne	80004270 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80004262:	48 68       	lddpc	r8,80004278 <xnl_get_msg_ack_func+0x24>
80004264:	70 0c       	ld.w	r12,r8[0x0]
80004266:	30 09       	mov	r9,0
80004268:	12 9a       	mov	r10,r9
8000426a:	12 9b       	mov	r11,r9
8000426c:	f0 1f 00 04 	mcall	8000427c <xnl_get_msg_ack_func+0x28>
80004270:	d8 02       	popm	pc
80004272:	00 00       	add	r0,r0
80004274:	00 00       	add	r0,r0
80004276:	0b 46       	ld.w	r6,--r5
80004278:	00 00       	add	r0,r0
8000427a:	0b 40       	ld.w	r0,--r5
8000427c:	80 00       	ld.sh	r0,r0[0x0]
8000427e:	63 40       	ld.w	r0,r1[0x50]

80004280 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004280:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
80004284:	30 09       	mov	r9,0
80004286:	4b 78       	lddpc	r8,80004360 <xnl_init+0xe0>
80004288:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
8000428a:	30 0b       	mov	r11,0
8000428c:	30 1c       	mov	r12,1
8000428e:	f0 1f 00 36 	mcall	80004364 <xnl_init+0xe4>
80004292:	4b 68       	lddpc	r8,80004368 <xnl_init+0xe8>
80004294:	91 0c       	st.w	r8[0x0],r12
80004296:	70 08       	ld.w	r8,r8[0x0]
80004298:	58 08       	cp.w	r8,0
8000429a:	c0 80       	breq	800042aa <xnl_init+0x2a>
8000429c:	4b 38       	lddpc	r8,80004368 <xnl_init+0xe8>
8000429e:	70 0c       	ld.w	r12,r8[0x0]
800042a0:	30 09       	mov	r9,0
800042a2:	12 9a       	mov	r10,r9
800042a4:	12 9b       	mov	r11,r9
800042a6:	f0 1f 00 32 	mcall	8000436c <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
800042aa:	30 4b       	mov	r11,4
800042ac:	31 4c       	mov	r12,20
800042ae:	f0 1f 00 2e 	mcall	80004364 <xnl_init+0xe4>
800042b2:	4b 08       	lddpc	r8,80004370 <xnl_init+0xf0>
800042b4:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800042b6:	30 4b       	mov	r11,4
800042b8:	31 ec       	mov	r12,30
800042ba:	f0 1f 00 2b 	mcall	80004364 <xnl_init+0xe4>
800042be:	4a e8       	lddpc	r8,80004374 <xnl_init+0xf4>
800042c0:	91 0c       	st.w	r8[0x0],r12
800042c2:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800042c4:	10 96       	mov	r6,r8
800042c6:	4a d5       	lddpc	r5,80004378 <xnl_init+0xf8>
800042c8:	6c 0c       	ld.w	r12,r6[0x0]
800042ca:	ea 07 00 0b 	add	r11,r5,r7
800042ce:	f0 1f 00 2c 	mcall	8000437c <xnl_init+0xfc>
800042d2:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
800042d6:	e0 47 1e 00 	cp.w	r7,7680
800042da:	cf 71       	brne	800042c8 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800042dc:	30 4b       	mov	r11,4
800042de:	31 4c       	mov	r12,20
800042e0:	f0 1f 00 21 	mcall	80004364 <xnl_init+0xe4>
800042e4:	4a 78       	lddpc	r8,80004380 <xnl_init+0x100>
800042e6:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800042e8:	30 4b       	mov	r11,4
800042ea:	30 ac       	mov	r12,10
800042ec:	f0 1f 00 1e 	mcall	80004364 <xnl_init+0xe4>
800042f0:	4a 58       	lddpc	r8,80004384 <xnl_init+0x104>
800042f2:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
800042f4:	30 4b       	mov	r11,4
800042f6:	30 ac       	mov	r12,10
800042f8:	f0 1f 00 1b 	mcall	80004364 <xnl_init+0xe4>
800042fc:	4a 38       	lddpc	r8,80004388 <xnl_init+0x108>
800042fe:	91 0c       	st.w	r8[0x0],r12
80004300:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80004302:	10 96       	mov	r6,r8
80004304:	4a 25       	lddpc	r5,8000438c <xnl_init+0x10c>
80004306:	6c 0c       	ld.w	r12,r6[0x0]
80004308:	ea 07 00 0b 	add	r11,r5,r7
8000430c:	f0 1f 00 1c 	mcall	8000437c <xnl_init+0xfc>
80004310:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004314:	e0 47 14 00 	cp.w	r7,5120
80004318:	cf 71       	brne	80004306 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000431a:	30 4b       	mov	r11,4
8000431c:	30 5c       	mov	r12,5
8000431e:	f0 1f 00 12 	mcall	80004364 <xnl_init+0xe4>
80004322:	49 c8       	lddpc	r8,80004390 <xnl_init+0x110>
80004324:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004326:	30 07       	mov	r7,0
80004328:	1a d7       	st.w	--sp,r7
8000432a:	1a d7       	st.w	--sp,r7
8000432c:	1a d7       	st.w	--sp,r7
8000432e:	30 38       	mov	r8,3
80004330:	0e 99       	mov	r9,r7
80004332:	e0 6a 00 dc 	mov	r10,220
80004336:	49 8b       	lddpc	r11,80004394 <xnl_init+0x114>
80004338:	49 8c       	lddpc	r12,80004398 <xnl_init+0x118>
8000433a:	f0 1f 00 19 	mcall	8000439c <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
8000433e:	1a d7       	st.w	--sp,r7
80004340:	1a d7       	st.w	--sp,r7
80004342:	1a d7       	st.w	--sp,r7
80004344:	30 38       	mov	r8,3
80004346:	0e 99       	mov	r9,r7
80004348:	e0 6a 00 82 	mov	r10,130
8000434c:	49 5b       	lddpc	r11,800043a0 <xnl_init+0x120>
8000434e:	49 6c       	lddpc	r12,800043a4 <xnl_init+0x124>
80004350:	f0 1f 00 13 	mcall	8000439c <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004354:	f0 1f 00 15 	mcall	800043a8 <xnl_init+0x128>
80004358:	2f ad       	sub	sp,-24
}
8000435a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000435e:	00 00       	add	r0,r0
80004360:	00 00       	add	r0,r0
80004362:	0b 46       	ld.w	r6,--r5
80004364:	80 00       	ld.sh	r0,r0[0x0]
80004366:	64 98       	ld.w	r8,r2[0x24]
80004368:	00 00       	add	r0,r0
8000436a:	0b 40       	ld.w	r0,--r5
8000436c:	80 00       	ld.sh	r0,r0[0x0]
8000436e:	63 40       	ld.w	r0,r1[0x50]
80004370:	00 00       	add	r0,r0
80004372:	0b 54       	ld.sh	r4,--r5
80004374:	00 00       	add	r0,r0
80004376:	0a a4       	st.w	r5++,r4
80004378:	00 00       	add	r0,r0
8000437a:	32 d2       	mov	r2,45
8000437c:	80 00       	ld.sh	r0,r0[0x0]
8000437e:	2b e4       	sub	r4,-66
80004380:	00 00       	add	r0,r0
80004382:	0a d4       	st.w	--r5,r4
80004384:	00 00       	add	r0,r0
80004386:	0a b4       	st.h	r5++,r4
80004388:	00 00       	add	r0,r0
8000438a:	0a a8       	st.w	r5++,r8
8000438c:	00 00       	add	r0,r0
8000438e:	1e d2       	st.w	--pc,r2
80004390:	00 00       	add	r0,r0
80004392:	0a e0       	st.h	--r5,r0
80004394:	80 00       	ld.sh	r0,r0[0x0]
80004396:	d8 40       	acall	0x84
80004398:	80 00       	ld.sh	r0,r0[0x0]
8000439a:	43 ac       	lddsp	r12,sp[0xe8]
8000439c:	80 00       	ld.sh	r0,r0[0x0]
8000439e:	6b b4       	ld.w	r4,r5[0x6c]
800043a0:	80 00       	ld.sh	r0,r0[0x0]
800043a2:	d8 48       	*unknown*
800043a4:	80 00       	ld.sh	r0,r0[0x0]
800043a6:	44 0c       	lddsp	r12,sp[0x100]
800043a8:	80 00       	ld.sh	r0,r0[0x0]
800043aa:	2d b8       	sub	r8,-37

800043ac <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
800043ac:	eb cd 40 fe 	pushm	r1-r7,lr
800043b0:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800043b2:	49 26       	lddpc	r6,800043f8 <xnl_rx_process+0x4c>
800043b4:	30 05       	mov	r5,0
800043b6:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800043b8:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800043ba:	49 11       	lddpc	r1,800043fc <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800043bc:	49 12       	lddpc	r2,80004400 <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800043be:	6c 0c       	ld.w	r12,r6[0x0]
800043c0:	0a 99       	mov	r9,r5
800043c2:	08 9a       	mov	r10,r4
800043c4:	1a 9b       	mov	r11,sp
800043c6:	f0 1f 00 10 	mcall	80004404 <xnl_rx_process+0x58>
800043ca:	58 1c       	cp.w	r12,1
800043cc:	cf 91       	brne	800043be <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
800043ce:	40 0c       	lddsp	r12,sp[0x0]
800043d0:	58 0c       	cp.w	r12,0
800043d2:	cf 60       	breq	800043be <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800043d4:	98 28       	ld.sh	r8,r12[0x4]
800043d6:	e6 08 19 00 	cp.h	r8,r3
800043da:	e0 8b 00 0a 	brhi	800043ee <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800043de:	5c 78       	castu.h	r8
800043e0:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
800043e4:	58 09       	cp.w	r9,0
800043e6:	c0 40       	breq	800043ee <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
800043e8:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
800043ec:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800043ee:	62 0c       	ld.w	r12,r1[0x0]
800043f0:	40 0b       	lddsp	r11,sp[0x0]
800043f2:	f0 1f 00 06 	mcall	80004408 <xnl_rx_process+0x5c>
800043f6:	ce 4b       	rjmp	800043be <xnl_rx_process+0x12>
800043f8:	00 00       	add	r0,r0
800043fa:	0a b4       	st.h	r5++,r4
800043fc:	00 00       	add	r0,r0
800043fe:	0a a4       	st.w	r5++,r4
80004400:	00 00       	add	r0,r0
80004402:	04 f4       	st.b	--r2,r4
80004404:	80 00       	ld.sh	r0,r0[0x0]
80004406:	61 34       	ld.w	r4,r0[0x4c]
80004408:	80 00       	ld.sh	r0,r0[0x0]
8000440a:	2b e4       	sub	r4,-66

8000440c <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
8000440c:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
8000440e:	4a a6       	lddpc	r6,800044b4 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004410:	4a a2       	lddpc	r2,800044b8 <xnl_tx_process+0xac>
80004412:	4a b4       	lddpc	r4,800044bc <xnl_tx_process+0xb0>
80004414:	30 07       	mov	r7,0
80004416:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004418:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000441a:	4a a5       	lddpc	r5,800044c0 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000441c:	4a a3       	lddpc	r3,800044c4 <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
8000441e:	6c 08       	ld.w	r8,r6[0x0]
80004420:	58 08       	cp.w	r8,0
80004422:	c0 40       	breq	8000442a <xnl_tx_process+0x1e>
80004424:	58 18       	cp.w	r8,1
80004426:	cf d1       	brne	80004420 <xnl_tx_process+0x14>
80004428:	c2 48       	rjmp	80004470 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000442a:	64 0c       	ld.w	r12,r2[0x0]
8000442c:	0e 99       	mov	r9,r7
8000442e:	02 9a       	mov	r10,r1
80004430:	08 9b       	mov	r11,r4
80004432:	f0 1f 00 26 	mcall	800044c8 <xnl_tx_process+0xbc>
80004436:	58 1c       	cp.w	r12,1
80004438:	cf 31       	brne	8000441e <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
8000443a:	68 0b       	ld.w	r11,r4[0x0]
8000443c:	58 0b       	cp.w	r11,0
8000443e:	cf 00       	breq	8000441e <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004440:	96 28       	ld.sh	r8,r11[0x4]
80004442:	e0 08 19 00 	cp.h	r8,r0
80004446:	c0 71       	brne	80004454 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004448:	4a 18       	lddpc	r8,800044cc <xnl_tx_process+0xc0>
8000444a:	70 08       	ld.w	r8,r8[0x0]
8000444c:	10 9c       	mov	r12,r8
8000444e:	f0 1f 00 21 	mcall	800044d0 <xnl_tx_process+0xc4>
						break;
80004452:	ce 6b       	rjmp	8000441e <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004454:	16 9c       	mov	r12,r11
80004456:	f0 1f 00 20 	mcall	800044d4 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000445a:	30 18       	mov	r8,1
8000445c:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000445e:	66 0c       	ld.w	r12,r3[0x0]
80004460:	0e 99       	mov	r9,r7
80004462:	0e 9a       	mov	r10,r7
80004464:	0e 9b       	mov	r11,r7
80004466:	f0 1f 00 19 	mcall	800044c8 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
8000446a:	30 18       	mov	r8,1
8000446c:	8d 08       	st.w	r6[0x0],r8
8000446e:	cd 8b       	rjmp	8000441e <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004470:	66 0c       	ld.w	r12,r3[0x0]
80004472:	0e 99       	mov	r9,r7
80004474:	36 4a       	mov	r10,100
80004476:	0e 9b       	mov	r11,r7
80004478:	f0 1f 00 14 	mcall	800044c8 <xnl_tx_process+0xbc>
8000447c:	58 1c       	cp.w	r12,1
8000447e:	c0 81       	brne	8000448e <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
80004480:	49 38       	lddpc	r8,800044cc <xnl_tx_process+0xc0>
80004482:	70 0c       	ld.w	r12,r8[0x0]
80004484:	68 0b       	ld.w	r11,r4[0x0]
80004486:	f0 1f 00 13 	mcall	800044d0 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
8000448a:	8d 07       	st.w	r6[0x0],r7
8000448c:	cc 9b       	rjmp	8000441e <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
8000448e:	6a 08       	ld.w	r8,r5[0x0]
80004490:	58 38       	cp.w	r8,3
80004492:	e0 89 00 09 	brgt	800044a4 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80004496:	68 0c       	ld.w	r12,r4[0x0]
80004498:	f0 1f 00 0f 	mcall	800044d4 <xnl_tx_process+0xc8>
						xnl_send_times++;
8000449c:	6a 08       	ld.w	r8,r5[0x0]
8000449e:	2f f8       	sub	r8,-1
800044a0:	8b 08       	st.w	r5[0x0],r8
800044a2:	cb eb       	rjmp	8000441e <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
800044a4:	48 a8       	lddpc	r8,800044cc <xnl_tx_process+0xc0>
800044a6:	70 0c       	ld.w	r12,r8[0x0]
800044a8:	68 0b       	ld.w	r11,r4[0x0]
800044aa:	f0 1f 00 0a 	mcall	800044d0 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800044ae:	8d 07       	st.w	r6[0x0],r7
800044b0:	cb 7b       	rjmp	8000441e <xnl_tx_process+0x12>
800044b2:	00 00       	add	r0,r0
800044b4:	00 00       	add	r0,r0
800044b6:	0b 50       	ld.sh	r0,--r5
800044b8:	00 00       	add	r0,r0
800044ba:	0b 54       	ld.sh	r4,--r5
800044bc:	00 00       	add	r0,r0
800044be:	0b 5c       	ld.sh	r12,--r5
800044c0:	00 00       	add	r0,r0
800044c2:	0b 58       	ld.sh	r8,--r5
800044c4:	00 00       	add	r0,r0
800044c6:	0b 40       	ld.w	r0,--r5
800044c8:	80 00       	ld.sh	r0,r0[0x0]
800044ca:	61 34       	ld.w	r4,r0[0x4c]
800044cc:	00 00       	add	r0,r0
800044ce:	0a a4       	st.w	r5++,r4
800044d0:	80 00       	ld.sh	r0,r0[0x0]
800044d2:	2b e4       	sub	r4,-66
800044d4:	80 00       	ld.sh	r0,r0[0x0]
800044d6:	2c 04       	sub	r4,-64

800044d8 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800044d8:	eb cd 40 c0 	pushm	r6-r7,lr
800044dc:	20 1d       	sub	sp,4
800044de:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800044e0:	98 39       	ld.sh	r9,r12[0x6]
800044e2:	3f f8       	mov	r8,-1
800044e4:	f0 09 19 00 	cp.h	r9,r8
800044e8:	c0 a1       	brne	800044fc <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800044ea:	4a e9       	lddpc	r9,800045a0 <xnl_tx+0xc8>
800044ec:	13 88       	ld.ub	r8,r9[0x0]
800044ee:	2f f8       	sub	r8,-1
800044f0:	5c 58       	castu.b	r8
800044f2:	b2 88       	st.b	r9[0x0],r8
800044f4:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800044f8:	a9 a8       	sbr	r8,0x8
800044fa:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800044fc:	8c 49       	ld.sh	r9,r6[0x8]
800044fe:	3f f8       	mov	r8,-1
80004500:	f0 09 19 00 	cp.h	r9,r8
80004504:	c0 41       	brne	8000450c <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004506:	4a 88       	lddpc	r8,800045a4 <xnl_tx+0xcc>
80004508:	90 18       	ld.sh	r8,r8[0x2]
8000450a:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
8000450c:	8c 59       	ld.sh	r9,r6[0xa]
8000450e:	3f f8       	mov	r8,-1
80004510:	f0 09 19 00 	cp.h	r9,r8
80004514:	c0 41       	brne	8000451c <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004516:	4a 48       	lddpc	r8,800045a4 <xnl_tx+0xcc>
80004518:	90 28       	ld.sh	r8,r8[0x4]
8000451a:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
8000451c:	8c 69       	ld.sh	r9,r6[0xc]
8000451e:	3f f8       	mov	r8,-1
80004520:	f0 09 19 00 	cp.h	r9,r8
80004524:	c0 e1       	brne	80004540 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004526:	4a 08       	lddpc	r8,800045a4 <xnl_tx+0xcc>
80004528:	90 49       	ld.sh	r9,r8[0x8]
8000452a:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
8000452c:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
8000452e:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004530:	90 49       	ld.sh	r9,r8[0x8]
80004532:	e0 19 ff 00 	andl	r9,0xff00
80004536:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
8000453a:	f3 e8 10 08 	or	r8,r9,r8
8000453e:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004540:	0d 98       	ld.ub	r8,r6[0x1]
80004542:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004544:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004548:	10 0c       	add	r12,r8
8000454a:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000454c:	58 0c       	cp.w	r12,0
8000454e:	e0 89 00 04 	brgt	80004556 <xnl_tx+0x7e>
80004552:	30 09       	mov	r9,0
80004554:	c0 d8       	rjmp	8000456e <xnl_tx+0x96>
80004556:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
8000455a:	2f ec       	sub	r12,-2
8000455c:	30 09       	mov	r9,0
8000455e:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004560:	15 1b       	ld.sh	r11,r10++
80004562:	f6 09 00 09 	add	r9,r11,r9
80004566:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004568:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000456a:	18 38       	cp.w	r8,r12
8000456c:	cf a1       	brne	80004560 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
8000456e:	5c 39       	neg	r9
80004570:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004572:	48 e8       	lddpc	r8,800045a8 <xnl_tx+0xd0>
80004574:	70 0c       	ld.w	r12,r8[0x0]
80004576:	f0 1f 00 0e 	mcall	800045ac <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
8000457a:	c1 00       	breq	8000459a <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000457c:	fa c7 ff fc 	sub	r7,sp,-4
80004580:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80004582:	e0 6a 01 00 	mov	r10,256
80004586:	0c 9b       	mov	r11,r6
80004588:	f0 1f 00 0a 	mcall	800045b0 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
8000458c:	48 a8       	lddpc	r8,800045b4 <xnl_tx+0xdc>
8000458e:	70 0c       	ld.w	r12,r8[0x0]
80004590:	30 09       	mov	r9,0
80004592:	12 9a       	mov	r10,r9
80004594:	1a 9b       	mov	r11,sp
80004596:	f0 1f 00 09 	mcall	800045b8 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
8000459a:	2f fd       	sub	sp,-4
8000459c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800045a0:	00 00       	add	r0,r0
800045a2:	0b 44       	ld.w	r4,--r5
800045a4:	00 00       	add	r0,r0
800045a6:	0b 46       	ld.w	r6,--r5
800045a8:	00 00       	add	r0,r0
800045aa:	0a a4       	st.w	r5++,r4
800045ac:	80 00       	ld.sh	r0,r0[0x0]
800045ae:	2d 90       	sub	r0,-39
800045b0:	80 00       	ld.sh	r0,r0[0x0]
800045b2:	77 f4       	ld.w	r4,r11[0x7c]
800045b4:	00 00       	add	r0,r0
800045b6:	0b 54       	ld.sh	r4,--r5
800045b8:	80 00       	ld.sh	r0,r0[0x0]
800045ba:	63 40       	ld.w	r0,r1[0x50]

800045bc <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800045bc:	eb cd 40 80 	pushm	r7,lr
800045c0:	fa cd 01 00 	sub	sp,sp,256
800045c4:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800045c6:	e0 68 40 0e 	mov	r8,16398
800045ca:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800045cc:	3f f8       	mov	r8,-1
800045ce:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
800045d0:	30 c8       	mov	r8,12
800045d2:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
800045d4:	98 38       	ld.sh	r8,r12[0x6]
800045d6:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
800045d8:	98 58       	ld.sh	r8,r12[0xa]
800045da:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
800045dc:	98 48       	ld.sh	r8,r12[0x8]
800045de:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
800045e0:	98 68       	ld.sh	r8,r12[0xc]
800045e2:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
800045e4:	30 08       	mov	r8,0
800045e6:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800045e8:	1a 9c       	mov	r12,sp
800045ea:	f0 1f 00 0a 	mcall	80004610 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
800045ee:	fa cd 00 cc 	sub	sp,sp,204
800045f2:	e0 6a 00 ca 	mov	r10,202
800045f6:	ee cb ff f0 	sub	r11,r7,-16
800045fa:	1a 9c       	mov	r12,sp
800045fc:	f0 1f 00 06 	mcall	80004614 <xnl_data_msg_func+0x58>
80004600:	48 68       	lddpc	r8,80004618 <xnl_data_msg_func+0x5c>
80004602:	70 08       	ld.w	r8,r8[0x0]
80004604:	5d 18       	icall	r8
80004606:	fa cd ff 34 	sub	sp,sp,-204
}
8000460a:	2c 0d       	sub	sp,-256
8000460c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004610:	80 00       	ld.sh	r0,r0[0x0]
80004612:	44 d8       	lddsp	r8,sp[0x134]
80004614:	80 00       	ld.sh	r0,r0[0x0]
80004616:	77 f4       	ld.w	r4,r11[0x7c]
80004618:	00 00       	add	r0,r0
8000461a:	0b 60       	ld.uh	r0,--r5

8000461c <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
8000461c:	d4 21       	pushm	r4-r7,lr
8000461e:	fa cd 01 00 	sub	sp,sp,256
80004622:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004624:	4c 28       	lddpc	r8,8000472c <xnl_device_auth_reply_func+0x110>
80004626:	11 88       	ld.ub	r8,r8[0x0]
80004628:	58 08       	cp.w	r8,0
8000462a:	e0 81 00 7f 	brne	80004728 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
8000462e:	4c 18       	lddpc	r8,80004730 <xnl_device_auth_reply_func+0x114>
80004630:	70 0c       	ld.w	r12,r8[0x0]
80004632:	30 09       	mov	r9,0
80004634:	12 9a       	mov	r10,r9
80004636:	12 9b       	mov	r11,r9
80004638:	f0 1f 00 3f 	mcall	80004734 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
8000463c:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004640:	4b b8       	lddpc	r8,8000472c <xnl_device_auth_reply_func+0x110>
80004642:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004644:	ef 39 00 12 	ld.ub	r9,r7[18]
80004648:	ef 38 00 13 	ld.ub	r8,r7[19]
8000464c:	b1 68       	lsl	r8,0x10
8000464e:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004652:	ef 38 00 15 	ld.ub	r8,r7[21]
80004656:	f3 e8 10 08 	or	r8,r9,r8
8000465a:	ef 39 00 14 	ld.ub	r9,r7[20]
8000465e:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004662:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004666:	ef 38 00 17 	ld.ub	r8,r7[23]
8000466a:	b1 68       	lsl	r8,0x10
8000466c:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004670:	ef 38 00 19 	ld.ub	r8,r7[25]
80004674:	f5 e8 10 08 	or	r8,r10,r8
80004678:	ef 3a 00 18 	ld.ub	r10,r7[24]
8000467c:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004680:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004682:	e0 64 79 b9 	mov	r4,31161
80004686:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
8000468a:	e0 65 45 07 	mov	r5,17671
8000468e:	ea 15 8a bd 	orh	r5,0x8abd
80004692:	e0 66 f9 3d 	mov	r6,63805
80004696:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
8000469a:	e0 6e b8 cf 	mov	lr,47311
8000469e:	ea 1e 36 83 	orh	lr,0x3683
800046a2:	e0 67 aa 1c 	mov	r7,43548
800046a6:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800046aa:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800046ac:	f4 08 00 0c 	add	r12,r10,r8
800046b0:	f0 0b 15 04 	lsl	r11,r8,0x4
800046b4:	0a 0b       	add	r11,r5
800046b6:	f9 eb 20 0b 	eor	r11,r12,r11
800046ba:	f0 0c 16 05 	lsr	r12,r8,0x5
800046be:	0c 0c       	add	r12,r6
800046c0:	18 5b       	eor	r11,r12
800046c2:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800046c4:	f2 0c 15 04 	lsl	r12,r9,0x4
800046c8:	1c 0c       	add	r12,lr
800046ca:	f2 0b 16 05 	lsr	r11,r9,0x5
800046ce:	0e 0b       	add	r11,r7
800046d0:	f9 eb 20 0b 	eor	r11,r12,r11
800046d4:	f2 0a 00 0c 	add	r12,r9,r10
800046d8:	18 5b       	eor	r11,r12
800046da:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
800046dc:	e0 6b 37 20 	mov	r11,14112
800046e0:	ea 1b c6 ef 	orh	r11,0xc6ef
800046e4:	16 3a       	cp.w	r10,r11
800046e6:	ce 21       	brne	800046aa <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
800046e8:	e0 6a 40 1a 	mov	r10,16410
800046ec:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800046ee:	3f fa       	mov	r10,-1
800046f0:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
800046f2:	30 6b       	mov	r11,6
800046f4:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800046f6:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800046f8:	48 db       	lddpc	r11,8000472c <xnl_device_auth_reply_func+0x110>
800046fa:	96 1c       	ld.sh	r12,r11[0x2]
800046fc:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
800046fe:	96 2b       	ld.sh	r11,r11[0x4]
80004700:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004702:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004704:	30 ca       	mov	r10,12
80004706:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004708:	30 0a       	mov	r10,0
8000470a:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
8000470e:	30 7a       	mov	r10,7
80004710:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004714:	30 2a       	mov	r10,2
80004716:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000471a:	fa ca ff ec 	sub	r10,sp,-20
8000471e:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004720:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004722:	1a 9c       	mov	r12,sp
80004724:	f0 1f 00 05 	mcall	80004738 <xnl_device_auth_reply_func+0x11c>
}
80004728:	2c 0d       	sub	sp,-256
8000472a:	d8 22       	popm	r4-r7,pc
8000472c:	00 00       	add	r0,r0
8000472e:	0b 46       	ld.w	r6,--r5
80004730:	00 00       	add	r0,r0
80004732:	0b 40       	ld.w	r0,--r5
80004734:	80 00       	ld.sh	r0,r0[0x0]
80004736:	63 40       	ld.w	r0,r1[0x50]
80004738:	80 00       	ld.sh	r0,r0[0x0]
8000473a:	44 d8       	lddsp	r8,sp[0x134]

8000473c <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
8000473c:	eb cd 40 80 	pushm	r7,lr
80004740:	fa cd 01 00 	sub	sp,sp,256
80004744:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004746:	49 28       	lddpc	r8,8000478c <xnl_master_status_brdcst_func+0x50>
80004748:	11 88       	ld.ub	r8,r8[0x0]
8000474a:	58 08       	cp.w	r8,0
8000474c:	c1 c1       	brne	80004784 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
8000474e:	49 18       	lddpc	r8,80004790 <xnl_master_status_brdcst_func+0x54>
80004750:	70 0c       	ld.w	r12,r8[0x0]
80004752:	30 09       	mov	r9,0
80004754:	12 9a       	mov	r10,r9
80004756:	12 9b       	mov	r11,r9
80004758:	f0 1f 00 0f 	mcall	80004794 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
8000475c:	8e 58       	ld.sh	r8,r7[0xa]
8000475e:	48 c9       	lddpc	r9,8000478c <xnl_master_status_brdcst_func+0x50>
80004760:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004762:	e0 68 40 0e 	mov	r8,16398
80004766:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004768:	3f f8       	mov	r8,-1
8000476a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
8000476c:	30 4a       	mov	r10,4
8000476e:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004770:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004772:	92 19       	ld.sh	r9,r9[0x2]
80004774:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004776:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004778:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
8000477a:	30 08       	mov	r8,0
8000477c:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
8000477e:	1a 9c       	mov	r12,sp
80004780:	f0 1f 00 06 	mcall	80004798 <xnl_master_status_brdcst_func+0x5c>
}
80004784:	2c 0d       	sub	sp,-256
80004786:	e3 cd 80 80 	ldm	sp++,r7,pc
8000478a:	00 00       	add	r0,r0
8000478c:	00 00       	add	r0,r0
8000478e:	0b 46       	ld.w	r6,--r5
80004790:	00 00       	add	r0,r0
80004792:	0b 40       	ld.w	r0,--r5
80004794:	80 00       	ld.sh	r0,r0[0x0]
80004796:	63 40       	ld.w	r0,r1[0x50]
80004798:	80 00       	ld.sh	r0,r0[0x0]
8000479a:	44 d8       	lddsp	r8,sp[0x134]

8000479c <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
8000479c:	eb cd 40 80 	pushm	r7,lr
800047a0:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
800047a2:	49 28       	lddpc	r8,800047e8 <xnl_device_conn_reply_func+0x4c>
800047a4:	70 0c       	ld.w	r12,r8[0x0]
800047a6:	30 09       	mov	r9,0
800047a8:	12 9a       	mov	r10,r9
800047aa:	12 9b       	mov	r11,r9
800047ac:	f0 1f 00 10 	mcall	800047ec <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800047b0:	ef 18 00 10 	ld.uh	r8,r7[16]
800047b4:	10 99       	mov	r9,r8
800047b6:	e2 19 ff 00 	andl	r9,0xff00,COH
800047ba:	e0 49 01 00 	cp.w	r9,256
800047be:	c0 60       	breq	800047ca <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800047c0:	0e 9c       	mov	r12,r7
800047c2:	f0 1f 00 0c 	mcall	800047f0 <xnl_device_conn_reply_func+0x54>
800047c6:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
800047ca:	a9 68       	lsl	r8,0x8
800047cc:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800047d0:	48 98       	lddpc	r8,800047f4 <xnl_device_conn_reply_func+0x58>
800047d2:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
800047d4:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
800047d8:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
800047da:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
800047de:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
800047e0:	30 19       	mov	r9,1
800047e2:	b0 89       	st.b	r8[0x0],r9
800047e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800047e8:	00 00       	add	r0,r0
800047ea:	0b 40       	ld.w	r0,--r5
800047ec:	80 00       	ld.sh	r0,r0[0x0]
800047ee:	63 40       	ld.w	r0,r1[0x50]
800047f0:	80 00       	ld.sh	r0,r0[0x0]
800047f2:	47 3c       	lddsp	r12,sp[0x1cc]
800047f4:	00 00       	add	r0,r0
800047f6:	0b 46       	ld.w	r6,--r5

800047f8 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
800047f8:	d4 01       	pushm	lr
800047fa:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800047fe:	e0 68 40 0e 	mov	r8,16398
80004802:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004804:	3f f8       	mov	r8,-1
80004806:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004808:	30 38       	mov	r8,3
8000480a:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
8000480c:	30 08       	mov	r8,0
8000480e:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004810:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004812:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004814:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004816:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004818:	1a 9c       	mov	r12,sp
8000481a:	f0 1f 00 03 	mcall	80004824 <xnl_send_device_master_query+0x2c>
}
8000481e:	2c 0d       	sub	sp,-256
80004820:	d8 02       	popm	pc
80004822:	00 00       	add	r0,r0
80004824:	80 00       	ld.sh	r0,r0[0x0]
80004826:	44 d8       	lddsp	r8,sp[0x134]

80004828 <RC522_SPI_SetSpeed>:
	//SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80004828:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
8000482a:	48 78       	lddpc	r8,80004844 <RC522_SPI_SetSpeed+0x1c>
8000482c:	70 09       	ld.w	r9,r8[0x0]
8000482e:	72 ca       	ld.w	r10,r9[0x30]
80004830:	5c 7c       	castu.h	r12
80004832:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80004836:	f9 ea 10 0a 	or	r10,r12,r10
8000483a:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
8000483c:	70 0c       	ld.w	r12,r8[0x0]
8000483e:	f0 1f 00 03 	mcall	80004848 <RC522_SPI_SetSpeed+0x20>
		
	
}
80004842:	d8 02       	popm	pc
80004844:	00 00       	add	r0,r0
80004846:	1d ac       	ld.ub	r12,lr[0x2]
80004848:	80 00       	ld.sh	r0,r0[0x0]
8000484a:	58 30       	cp.w	r0,3

8000484c <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
8000484c:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0A00);//baudDiv=4
8000484e:	e0 6c 0a 00 	mov	r12,2560
80004852:	f0 1f 00 02 	mcall	80004858 <RC522_SPI_SetSpeedLow+0xc>
	
}
80004856:	d8 02       	popm	pc
80004858:	80 00       	ld.sh	r0,r0[0x0]
8000485a:	48 28       	lddpc	r8,80004860 <RC522_ReadByte+0x4>

8000485c <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
8000485c:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
80004860:	48 76       	lddpc	r6,8000487c <RC522_ReadByte+0x20>
80004862:	e0 6b 00 ff 	mov	r11,255
80004866:	6c 0c       	ld.w	r12,r6[0x0]
80004868:	f0 1f 00 06 	mcall	80004880 <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
8000486c:	30 07       	mov	r7,0
8000486e:	0e 9b       	mov	r11,r7
80004870:	6c 0c       	ld.w	r12,r6[0x0]
80004872:	f0 1f 00 05 	mcall	80004884 <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
80004876:	0f 9c       	ld.ub	r12,r7[0x1]
80004878:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000487c:	00 00       	add	r0,r0
8000487e:	1d ac       	ld.ub	r12,lr[0x2]
80004880:	80 00       	ld.sh	r0,r0[0x0]
80004882:	58 36       	cp.w	r6,3
80004884:	80 00       	ld.sh	r0,r0[0x0]
80004886:	58 52       	cp.w	r2,5

80004888 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
80004888:	eb cd 40 80 	pushm	r7,lr
8000488c:	20 1d       	sub	sp,4
8000488e:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
80004890:	48 77       	lddpc	r7,800048ac <RC522_WriteByte+0x24>
80004892:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
80004896:	6e 0c       	ld.w	r12,r7[0x0]
80004898:	f0 1f 00 06 	mcall	800048b0 <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
8000489c:	1a 9b       	mov	r11,sp
8000489e:	6e 0c       	ld.w	r12,r7[0x0]
800048a0:	f0 1f 00 05 	mcall	800048b4 <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
800048a4:	5c 5c       	castu.b	r12
800048a6:	2f fd       	sub	sp,-4
800048a8:	e3 cd 80 80 	ldm	sp++,r7,pc
800048ac:	00 00       	add	r0,r0
800048ae:	1d ac       	ld.ub	r12,lr[0x2]
800048b0:	80 00       	ld.sh	r0,r0[0x0]
800048b2:	58 36       	cp.w	r6,3
800048b4:	80 00       	ld.sh	r0,r0[0x0]
800048b6:	58 52       	cp.w	r2,5

800048b8 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
800048b8:	eb cd 40 e0 	pushm	r5-r7,lr
800048bc:	18 96       	mov	r6,r12
800048be:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
800048c0:	48 a7       	lddpc	r7,800048e8 <WriteRawRC+0x30>
800048c2:	30 0b       	mov	r11,0
800048c4:	6e 0c       	ld.w	r12,r7[0x0]
800048c6:	f0 1f 00 0a 	mcall	800048ec <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
800048ca:	ec 0c 15 01 	lsl	r12,r6,0x1
800048ce:	e2 1c 00 7e 	andl	r12,0x7e,COH
800048d2:	f0 1f 00 08 	mcall	800048f0 <WriteRawRC+0x38>
	RC522_WriteByte(value);
800048d6:	0a 9c       	mov	r12,r5
800048d8:	f0 1f 00 06 	mcall	800048f0 <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800048dc:	30 0b       	mov	r11,0
800048de:	6e 0c       	ld.w	r12,r7[0x0]
800048e0:	f0 1f 00 05 	mcall	800048f4 <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
800048e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800048e8:	00 00       	add	r0,r0
800048ea:	1d ac       	ld.ub	r12,lr[0x2]
800048ec:	80 00       	ld.sh	r0,r0[0x0]
800048ee:	59 9c       	cp.w	r12,25
800048f0:	80 00       	ld.sh	r0,r0[0x0]
800048f2:	48 88       	lddpc	r8,80004910 <PcdReset+0x18>
800048f4:	80 00       	ld.sh	r0,r0[0x0]
800048f6:	59 5c       	cp.w	r12,21

800048f8 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
800048f8:	d4 01       	pushm	lr

	SET_RC522RST;
800048fa:	31 9c       	mov	r12,25
800048fc:	f0 1f 00 1b 	mcall	80004968 <PcdReset+0x70>
	delay_ns(10);
80004900:	30 ac       	mov	r12,10
80004902:	f0 1f 00 1b 	mcall	8000496c <PcdReset+0x74>

	CLR_RC522RST;
80004906:	31 9c       	mov	r12,25
80004908:	f0 1f 00 1a 	mcall	80004970 <PcdReset+0x78>
	delay_ns(10);
8000490c:	30 ac       	mov	r12,10
8000490e:	f0 1f 00 18 	mcall	8000496c <PcdReset+0x74>

	SET_RC522RST;
80004912:	31 9c       	mov	r12,25
80004914:	f0 1f 00 15 	mcall	80004968 <PcdReset+0x70>
	delay_ns(10);
80004918:	30 ac       	mov	r12,10
8000491a:	f0 1f 00 15 	mcall	8000496c <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
8000491e:	30 fb       	mov	r11,15
80004920:	30 1c       	mov	r12,1
80004922:	f0 1f 00 15 	mcall	80004974 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004926:	30 fb       	mov	r11,15
80004928:	30 1c       	mov	r12,1
8000492a:	f0 1f 00 13 	mcall	80004974 <PcdReset+0x7c>
	delay_ns(10);
8000492e:	30 ac       	mov	r12,10
80004930:	f0 1f 00 0f 	mcall	8000496c <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80004934:	33 db       	mov	r11,61
80004936:	31 1c       	mov	r12,17
80004938:	f0 1f 00 0f 	mcall	80004974 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
8000493c:	31 eb       	mov	r11,30
8000493e:	32 dc       	mov	r12,45
80004940:	f0 1f 00 0d 	mcall	80004974 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80004944:	30 0b       	mov	r11,0
80004946:	32 cc       	mov	r12,44
80004948:	f0 1f 00 0b 	mcall	80004974 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
8000494c:	e0 6b 00 8d 	mov	r11,141
80004950:	32 ac       	mov	r12,42
80004952:	f0 1f 00 09 	mcall	80004974 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
80004956:	33 eb       	mov	r11,62
80004958:	32 bc       	mov	r12,43
8000495a:	f0 1f 00 07 	mcall	80004974 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
8000495e:	34 0b       	mov	r11,64
80004960:	31 5c       	mov	r12,21
80004962:	f0 1f 00 05 	mcall	80004974 <PcdReset+0x7c>
	
	return MI_OK;
}
80004966:	d8 0a       	popm	pc,r12=0
80004968:	80 00       	ld.sh	r0,r0[0x0]
8000496a:	55 14       	stdsp	sp[0x144],r4
8000496c:	80 00       	ld.sh	r0,r0[0x0]
8000496e:	52 b4       	stdsp	sp[0xac],r4
80004970:	80 00       	ld.sh	r0,r0[0x0]
80004972:	55 30       	stdsp	sp[0x14c],r0
80004974:	80 00       	ld.sh	r0,r0[0x0]
80004976:	48 b8       	lddpc	r8,800049a0 <ReadRawRC+0x28>

80004978 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
80004978:	eb cd 40 c0 	pushm	r6-r7,lr
8000497c:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
8000497e:	48 c7       	lddpc	r7,800049ac <ReadRawRC+0x34>
80004980:	30 0b       	mov	r11,0
80004982:	6e 0c       	ld.w	r12,r7[0x0]
80004984:	f0 1f 00 0b 	mcall	800049b0 <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
80004988:	a1 76       	lsl	r6,0x1
8000498a:	0c 9c       	mov	r12,r6
8000498c:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004990:	a7 bc       	sbr	r12,0x7
80004992:	f0 1f 00 09 	mcall	800049b4 <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
80004996:	f0 1f 00 09 	mcall	800049b8 <ReadRawRC+0x40>
8000499a:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
8000499c:	30 0b       	mov	r11,0
8000499e:	6e 0c       	ld.w	r12,r7[0x0]
800049a0:	f0 1f 00 07 	mcall	800049bc <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
800049a4:	0c 9c       	mov	r12,r6
800049a6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800049aa:	00 00       	add	r0,r0
800049ac:	00 00       	add	r0,r0
800049ae:	1d ac       	ld.ub	r12,lr[0x2]
800049b0:	80 00       	ld.sh	r0,r0[0x0]
800049b2:	59 9c       	cp.w	r12,25
800049b4:	80 00       	ld.sh	r0,r0[0x0]
800049b6:	48 88       	lddpc	r8,800049d4 <Powerdown_RC522+0x4>
800049b8:	80 00       	ld.sh	r0,r0[0x0]
800049ba:	48 5c       	lddpc	r12,800049cc <Wait_Wakeup_RC522+0xc>
800049bc:	80 00       	ld.sh	r0,r0[0x0]
800049be:	59 5c       	cp.w	r12,21

800049c0 <Wait_Wakeup_RC522>:

/////////////////////////////////////////////////////////////////////
//    斤绛寰RC522
/////////////////////////////////////////////////////////////////////
void Wait_Wakeup_RC522(void)
{
800049c0:	d4 01       	pushm	lr
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	do 
	{
		tmp = ReadRawRC(reg);
800049c2:	30 1c       	mov	r12,1
800049c4:	f0 1f 00 02 	mcall	800049cc <Wait_Wakeup_RC522+0xc>
			
	//tmp = ReadRawRC(reg);
	//if((tmp & 0x10) == 0)
	//WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
	
}
800049c8:	d8 02       	popm	pc
800049ca:	00 00       	add	r0,r0
800049cc:	80 00       	ld.sh	r0,r0[0x0]
800049ce:	49 78       	lddpc	r8,80004a28 <SetBitMask+0xc>

800049d0 <Powerdown_RC522>:
/////////////////////////////////////////////////////////////////////
//    斤浣RC522杩ヨ蒋垫ā寮
//
/////////////////////////////////////////////////////////////////////
void Powerdown_RC522(U8 act)
{
800049d0:	eb cd 40 80 	pushm	r7,lr
800049d4:	18 97       	mov	r7,r12
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	tmp = ReadRawRC(reg);
800049d6:	30 1c       	mov	r12,1
800049d8:	f0 1f 00 0d 	mcall	80004a0c <Powerdown_RC522+0x3c>
	if(act == ENTER_POWERDOWN)//1
800049dc:	30 18       	mov	r8,1
800049de:	f0 07 18 00 	cp.b	r7,r8
800049e2:	c0 91       	brne	800049f4 <Powerdown_RC522+0x24>
		WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
800049e4:	18 9b       	mov	r11,r12
800049e6:	a5 ab       	sbr	r11,0x4
800049e8:	5c 5b       	castu.b	r11
800049ea:	30 1c       	mov	r12,1
800049ec:	f0 1f 00 09 	mcall	80004a10 <Powerdown_RC522+0x40>
800049f0:	e3 cd 80 80 	ldm	sp++,r7,pc
	else
	{
		WriteRawRC(reg,tmp | PCD_IDLE);  // wake up rc522
800049f4:	18 9b       	mov	r11,r12
800049f6:	30 1c       	mov	r12,1
800049f8:	f0 1f 00 06 	mcall	80004a10 <Powerdown_RC522+0x40>
		delay_ns(2);
800049fc:	30 2c       	mov	r12,2
800049fe:	f0 1f 00 06 	mcall	80004a14 <Powerdown_RC522+0x44>
		Wait_Wakeup_RC522();
80004a02:	f0 1f 00 06 	mcall	80004a18 <Powerdown_RC522+0x48>
80004a06:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a0a:	00 00       	add	r0,r0
80004a0c:	80 00       	ld.sh	r0,r0[0x0]
80004a0e:	49 78       	lddpc	r8,80004a68 <ClearBitMask+0x8>
80004a10:	80 00       	ld.sh	r0,r0[0x0]
80004a12:	48 b8       	lddpc	r8,80004a3c <SetBitMask+0x20>
80004a14:	80 00       	ld.sh	r0,r0[0x0]
80004a16:	52 b4       	stdsp	sp[0xac],r4
80004a18:	80 00       	ld.sh	r0,r0[0x0]
80004a1a:	49 c0       	lddpc	r0,80004a88 <PcdAntennaOff>

80004a1c <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80004a1c:	eb cd 40 c0 	pushm	r6-r7,lr
80004a20:	18 97       	mov	r7,r12
80004a22:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80004a24:	f0 1f 00 05 	mcall	80004a38 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80004a28:	f9 e6 10 0b 	or	r11,r12,r6
80004a2c:	5c 5b       	castu.b	r11
80004a2e:	0e 9c       	mov	r12,r7
80004a30:	f0 1f 00 03 	mcall	80004a3c <SetBitMask+0x20>
}
80004a34:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a38:	80 00       	ld.sh	r0,r0[0x0]
80004a3a:	49 78       	lddpc	r8,80004a94 <PcdAntennaOff+0xc>
80004a3c:	80 00       	ld.sh	r0,r0[0x0]
80004a3e:	48 b8       	lddpc	r8,80004a68 <ClearBitMask+0x8>

80004a40 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80004a40:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80004a42:	31 4c       	mov	r12,20
80004a44:	f0 1f 00 05 	mcall	80004a58 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80004a48:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80004a4c:	c0 51       	brne	80004a56 <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
80004a4e:	30 3b       	mov	r11,3
80004a50:	31 4c       	mov	r12,20
80004a52:	f0 1f 00 03 	mcall	80004a5c <PcdAntennaOn+0x1c>
80004a56:	d8 02       	popm	pc
80004a58:	80 00       	ld.sh	r0,r0[0x0]
80004a5a:	49 78       	lddpc	r8,80004ab4 <M500PcdConfigISOType+0x1c>
80004a5c:	80 00       	ld.sh	r0,r0[0x0]
80004a5e:	4a 1c       	lddpc	r12,80004ae0 <M500PcdConfigISOType+0x48>

80004a60 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80004a60:	eb cd 40 c0 	pushm	r6-r7,lr
80004a64:	18 97       	mov	r7,r12
80004a66:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80004a68:	f0 1f 00 06 	mcall	80004a80 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80004a6c:	5c d6       	com	r6
80004a6e:	f9 e6 00 06 	and	r6,r12,r6
80004a72:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80004a76:	0e 9c       	mov	r12,r7
80004a78:	f0 1f 00 03 	mcall	80004a84 <ClearBitMask+0x24>
	
}
80004a7c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a80:	80 00       	ld.sh	r0,r0[0x0]
80004a82:	49 78       	lddpc	r8,80004adc <M500PcdConfigISOType+0x44>
80004a84:	80 00       	ld.sh	r0,r0[0x0]
80004a86:	48 b8       	lddpc	r8,80004ab0 <M500PcdConfigISOType+0x18>

80004a88 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
80004a88:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
80004a8a:	30 3b       	mov	r11,3
80004a8c:	31 4c       	mov	r12,20
80004a8e:	f0 1f 00 02 	mcall	80004a94 <PcdAntennaOff+0xc>
}
80004a92:	d8 02       	popm	pc
80004a94:	80 00       	ld.sh	r0,r0[0x0]
80004a96:	4a 60       	lddpc	r0,80004b2c <rc522_init+0x24>

80004a98 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
80004a98:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
80004a9a:	34 18       	mov	r8,65
80004a9c:	f0 0c 18 00 	cp.b	r12,r8
80004aa0:	c0 20       	breq	80004aa4 <M500PcdConfigISOType+0xc>
80004aa2:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80004aa4:	30 8b       	mov	r11,8
80004aa6:	16 9c       	mov	r12,r11
80004aa8:	f0 1f 00 14 	mcall	80004af8 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
80004aac:	33 db       	mov	r11,61
80004aae:	31 1c       	mov	r12,17
80004ab0:	f0 1f 00 13 	mcall	80004afc <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80004ab4:	e0 6b 00 86 	mov	r11,134
80004ab8:	31 7c       	mov	r12,23
80004aba:	f0 1f 00 11 	mcall	80004afc <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
80004abe:	37 fb       	mov	r11,127
80004ac0:	32 6c       	mov	r12,38
80004ac2:	f0 1f 00 0f 	mcall	80004afc <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
80004ac6:	31 eb       	mov	r11,30
80004ac8:	32 dc       	mov	r12,45
80004aca:	f0 1f 00 0d 	mcall	80004afc <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
80004ace:	30 0b       	mov	r11,0
80004ad0:	32 cc       	mov	r12,44
80004ad2:	f0 1f 00 0b 	mcall	80004afc <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
80004ad6:	e0 6b 00 8d 	mov	r11,141
80004ada:	32 ac       	mov	r12,42
80004adc:	f0 1f 00 08 	mcall	80004afc <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80004ae0:	33 eb       	mov	r11,62
80004ae2:	32 bc       	mov	r12,43
80004ae4:	f0 1f 00 06 	mcall	80004afc <M500PcdConfigISOType+0x64>
		delay_ns(1000);
80004ae8:	e0 6c 03 e8 	mov	r12,1000
80004aec:	f0 1f 00 05 	mcall	80004b00 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80004af0:	f0 1f 00 05 	mcall	80004b04 <M500PcdConfigISOType+0x6c>
80004af4:	d8 0a       	popm	pc,r12=0
80004af6:	00 00       	add	r0,r0
80004af8:	80 00       	ld.sh	r0,r0[0x0]
80004afa:	4a 60       	lddpc	r0,80004b90 <rc522_init+0x88>
80004afc:	80 00       	ld.sh	r0,r0[0x0]
80004afe:	48 b8       	lddpc	r8,80004b28 <rc522_init+0x20>
80004b00:	80 00       	ld.sh	r0,r0[0x0]
80004b02:	52 b4       	stdsp	sp[0xac],r4
80004b04:	80 00       	ld.sh	r0,r0[0x0]
80004b06:	4a 40       	lddpc	r0,80004b94 <rc522_init+0x8c>

80004b08 <rc522_init>:


//mfrc522 init

void rc522_init()
{
80004b08:	eb cd 40 c0 	pushm	r6-r7,lr
80004b0c:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004b0e:	4a 38       	lddpc	r8,80004b98 <rc522_init+0x90>
80004b10:	1a 96       	mov	r6,sp
80004b12:	f0 ea 00 00 	ld.d	r10,r8[0]
80004b16:	fa eb 00 00 	st.d	sp[0],r10
80004b1a:	f0 e8 00 08 	ld.d	r8,r8[8]
80004b1e:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80004b22:	30 4b       	mov	r11,4
80004b24:	49 ec       	lddpc	r12,80004b9c <rc522_init+0x94>
80004b26:	f0 1f 00 1f 	mcall	80004ba0 <rc522_init+0x98>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80004b2a:	31 9c       	mov	r12,25
80004b2c:	f0 1f 00 1e 	mcall	80004ba4 <rc522_init+0x9c>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80004b30:	31 9c       	mov	r12,25
80004b32:	f0 1f 00 1e 	mcall	80004ba8 <rc522_init+0xa0>

	spi = &AVR32_SPI;
80004b36:	49 e7       	lddpc	r7,80004bac <rc522_init+0xa4>
80004b38:	fe 7c 24 00 	mov	r12,-56320
80004b3c:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80004b3e:	1a 9b       	mov	r11,sp
80004b40:	f0 1f 00 1c 	mcall	80004bb0 <rc522_init+0xa8>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80004b44:	30 09       	mov	r9,0
80004b46:	12 9a       	mov	r10,r9
80004b48:	12 9b       	mov	r11,r9
80004b4a:	6e 0c       	ld.w	r12,r7[0x0]
80004b4c:	f0 1f 00 1a 	mcall	80004bb4 <rc522_init+0xac>

	// Enable SPI.
	spi_enable(spi);
80004b50:	6e 0c       	ld.w	r12,r7[0x0]
80004b52:	f0 1f 00 1a 	mcall	80004bb8 <rc522_init+0xb0>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80004b56:	e0 6a 36 00 	mov	r10,13824
80004b5a:	ea 1a 01 6e 	orh	r10,0x16e
80004b5e:	1a 9b       	mov	r11,sp
80004b60:	6e 0c       	ld.w	r12,r7[0x0]
80004b62:	f0 1f 00 17 	mcall	80004bbc <rc522_init+0xb4>
80004b66:	c0 50       	breq	80004b70 <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80004b68:	30 29       	mov	r9,2
80004b6a:	49 68       	lddpc	r8,80004bc0 <rc522_init+0xb8>
80004b6c:	b0 89       	st.b	r8[0x0],r9
80004b6e:	c0 38       	rjmp	80004b74 <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80004b70:	f0 1f 00 15 	mcall	80004bc4 <rc522_init+0xbc>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80004b74:	f0 1f 00 15 	mcall	80004bc8 <rc522_init+0xc0>
	
	PcdAntennaOff();
80004b78:	f0 1f 00 15 	mcall	80004bcc <rc522_init+0xc4>
	
	delay_ms(2); 
80004b7c:	30 2c       	mov	r12,2
80004b7e:	f0 1f 00 15 	mcall	80004bd0 <rc522_init+0xc8>
	
	PcdAntennaOn();
80004b82:	f0 1f 00 15 	mcall	80004bd4 <rc522_init+0xcc>
	
	M500PcdConfigISOType( 'A' );
80004b86:	34 1c       	mov	r12,65
80004b88:	f0 1f 00 14 	mcall	80004bd8 <rc522_init+0xd0>
	
	Powerdown_RC522(ENTER_POWERDOWN);
80004b8c:	30 1c       	mov	r12,1
80004b8e:	f0 1f 00 14 	mcall	80004bdc <rc522_init+0xd4>
	//Powerdown_RC522(ENTER_POWERDOWN);
	
	//Powerdown_RC522(WAKEUP_RC522);
	

80004b92:	2f cd       	sub	sp,-16
80004b94:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004b98:	80 00       	ld.sh	r0,r0[0x0]
80004b9a:	d8 58       	*unknown*
80004b9c:	80 00       	ld.sh	r0,r0[0x0]
80004b9e:	d8 68       	*unknown*
80004ba0:	80 00       	ld.sh	r0,r0[0x0]
80004ba2:	54 cc       	stdsp	sp[0x130],r12
80004ba4:	80 00       	ld.sh	r0,r0[0x0]
80004ba6:	54 fc       	stdsp	sp[0x13c],r12
80004ba8:	80 00       	ld.sh	r0,r0[0x0]
80004baa:	55 14       	stdsp	sp[0x144],r4
80004bac:	00 00       	add	r0,r0
80004bae:	1d ac       	ld.ub	r12,lr[0x2]
80004bb0:	80 00       	ld.sh	r0,r0[0x0]
80004bb2:	57 cc       	stdsp	sp[0x1f0],r12
80004bb4:	80 00       	ld.sh	r0,r0[0x0]
80004bb6:	58 04       	cp.w	r4,0
80004bb8:	80 00       	ld.sh	r0,r0[0x0]
80004bba:	58 30       	cp.w	r0,3
80004bbc:	80 00       	ld.sh	r0,r0[0x0]
80004bbe:	58 74       	cp.w	r4,7
80004bc0:	00 00       	add	r0,r0
80004bc2:	0b 64       	ld.uh	r4,--r5
80004bc4:	80 00       	ld.sh	r0,r0[0x0]
80004bc6:	48 4c       	lddpc	r12,80004bd4 <rc522_init+0xcc>
80004bc8:	80 00       	ld.sh	r0,r0[0x0]
80004bca:	48 f8       	lddpc	r8,80004c04 <PcdComMF522+0x24>
80004bcc:	80 00       	ld.sh	r0,r0[0x0]
80004bce:	4a 88       	lddpc	r8,80004c6c <PcdComMF522+0x8c>
80004bd0:	80 00       	ld.sh	r0,r0[0x0]
80004bd2:	52 f4       	stdsp	sp[0xbc],r4
80004bd4:	80 00       	ld.sh	r0,r0[0x0]
80004bd6:	4a 40       	lddpc	r0,80004c64 <PcdComMF522+0x84>
80004bd8:	80 00       	ld.sh	r0,r0[0x0]
80004bda:	4a 98       	lddpc	r8,80004c7c <PcdComMF522+0x9c>
80004bdc:	80 00       	ld.sh	r0,r0[0x0]
80004bde:	49 d0       	lddpc	r0,80004c50 <PcdComMF522+0x70>

80004be0 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004be0:	d4 31       	pushm	r0-r7,lr
80004be2:	20 1d       	sub	sp,4
80004be4:	18 92       	mov	r2,r12
80004be6:	16 95       	mov	r5,r11
80004be8:	14 96       	mov	r6,r10
80004bea:	50 09       	stdsp	sp[0x0],r9
80004bec:	10 90       	mov	r0,r8
80004bee:	f8 c8 00 0c 	sub	r8,r12,12
80004bf2:	5c 58       	castu.b	r8
80004bf4:	30 29       	mov	r9,2
80004bf6:	f2 08 18 00 	cp.b	r8,r9
80004bfa:	e0 88 00 05 	brls	80004c04 <PcdComMF522+0x24>
80004bfe:	30 03       	mov	r3,0
80004c00:	06 91       	mov	r1,r3
80004c02:	c0 78       	rjmp	80004c10 <PcdComMF522+0x30>
80004c04:	4c f9       	lddpc	r9,80004d40 <PcdComMF522+0x160>
80004c06:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004c0a:	4c f9       	lddpc	r9,80004d44 <PcdComMF522+0x164>
80004c0c:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004c10:	02 9b       	mov	r11,r1
80004c12:	a7 bb       	sbr	r11,0x7
80004c14:	30 2c       	mov	r12,2
80004c16:	f0 1f 00 4d 	mcall	80004d48 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004c1a:	e0 6b 00 80 	mov	r11,128
80004c1e:	30 4c       	mov	r12,4
80004c20:	f0 1f 00 4b 	mcall	80004d4c <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004c24:	30 0b       	mov	r11,0
80004c26:	30 1c       	mov	r12,1
80004c28:	f0 1f 00 48 	mcall	80004d48 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004c2c:	e0 6b 00 80 	mov	r11,128
80004c30:	30 ac       	mov	r12,10
80004c32:	f0 1f 00 48 	mcall	80004d50 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004c36:	58 06       	cp.w	r6,0
80004c38:	c0 c0       	breq	80004c50 <PcdComMF522+0x70>
80004c3a:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004c3c:	30 94       	mov	r4,9
80004c3e:	0f 3b       	ld.ub	r11,r7++
80004c40:	08 9c       	mov	r12,r4
80004c42:	f0 1f 00 42 	mcall	80004d48 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004c46:	0e 98       	mov	r8,r7
80004c48:	0a 18       	sub	r8,r5
80004c4a:	ec 08 19 00 	cp.h	r8,r6
80004c4e:	cf 83       	brcs	80004c3e <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004c50:	04 9b       	mov	r11,r2
80004c52:	30 1c       	mov	r12,1
80004c54:	f0 1f 00 3d 	mcall	80004d48 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004c58:	30 c8       	mov	r8,12
80004c5a:	f0 02 18 00 	cp.b	r2,r8
80004c5e:	c0 61       	brne	80004c6a <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004c60:	e0 6b 00 80 	mov	r11,128
80004c64:	30 dc       	mov	r12,13
80004c66:	f0 1f 00 3b 	mcall	80004d50 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004c6a:	30 4c       	mov	r12,4
80004c6c:	f0 1f 00 3a 	mcall	80004d54 <PcdComMF522+0x174>
80004c70:	18 97       	mov	r7,r12
80004c72:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004c76:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004c78:	30 44       	mov	r4,4
80004c7a:	c0 88       	rjmp	80004c8a <PcdComMF522+0xaa>
80004c7c:	08 9c       	mov	r12,r4
80004c7e:	f0 1f 00 36 	mcall	80004d54 <PcdComMF522+0x174>
80004c82:	18 97       	mov	r7,r12
		i--;
80004c84:	20 16       	sub	r6,1
80004c86:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004c88:	c0 a0       	breq	80004c9c <PcdComMF522+0xbc>
80004c8a:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004c8e:	c4 c1       	brne	80004d26 <PcdComMF522+0x146>
80004c90:	ef e3 00 08 	and	r8,r7,r3
80004c94:	ea 08 18 00 	cp.b	r8,r5
80004c98:	cf 20       	breq	80004c7c <PcdComMF522+0x9c>
80004c9a:	c4 68       	rjmp	80004d26 <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004c9c:	e0 6b 00 80 	mov	r11,128
80004ca0:	30 dc       	mov	r12,13
80004ca2:	f0 1f 00 2b 	mcall	80004d4c <PcdComMF522+0x16c>
80004ca6:	30 27       	mov	r7,2
80004ca8:	c3 38       	rjmp	80004d0e <PcdComMF522+0x12e>
80004caa:	02 67       	and	r7,r1
80004cac:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004cb0:	30 c8       	mov	r8,12
80004cb2:	f0 02 18 00 	cp.b	r2,r8
80004cb6:	c2 c1       	brne	80004d0e <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004cb8:	30 ac       	mov	r12,10
80004cba:	f0 1f 00 27 	mcall	80004d54 <PcdComMF522+0x174>
80004cbe:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004cc0:	30 cc       	mov	r12,12
80004cc2:	f0 1f 00 25 	mcall	80004d54 <PcdComMF522+0x174>
80004cc6:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004cca:	c0 70       	breq	80004cd8 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004ccc:	08 98       	mov	r8,r4
80004cce:	20 18       	sub	r8,1
80004cd0:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004cd4:	a0 8c       	st.b	r0[0x0],r12
80004cd6:	c0 48       	rjmp	80004cde <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004cd8:	e8 08 15 03 	lsl	r8,r4,0x3
80004cdc:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004cde:	58 04       	cp.w	r4,0
80004ce0:	c0 61       	brne	80004cec <PcdComMF522+0x10c>
80004ce2:	30 14       	mov	r4,1
80004ce4:	40 05       	lddsp	r5,sp[0x0]
80004ce6:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004ce8:	30 93       	mov	r3,9
80004cea:	c0 98       	rjmp	80004cfc <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004cec:	31 28       	mov	r8,18
80004cee:	f0 04 18 00 	cp.b	r4,r8
80004cf2:	f9 b4 0b 12 	movhi	r4,18
80004cf6:	58 04       	cp.w	r4,0
80004cf8:	cf 61       	brne	80004ce4 <PcdComMF522+0x104>
80004cfa:	c0 a8       	rjmp	80004d0e <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004cfc:	06 9c       	mov	r12,r3
80004cfe:	f0 1f 00 16 	mcall	80004d54 <PcdComMF522+0x174>
80004d02:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004d04:	ec 05 01 08 	sub	r8,r6,r5
80004d08:	e8 08 19 00 	cp.h	r8,r4
80004d0c:	cf 83       	brcs	80004cfc <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004d0e:	e0 6b 00 80 	mov	r11,128
80004d12:	30 cc       	mov	r12,12
80004d14:	f0 1f 00 0f 	mcall	80004d50 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004d18:	30 0b       	mov	r11,0
80004d1a:	30 1c       	mov	r12,1
80004d1c:	f0 1f 00 0b 	mcall	80004d48 <PcdComMF522+0x168>
	return status;
}
80004d20:	0e 9c       	mov	r12,r7
80004d22:	2f fd       	sub	sp,-4
80004d24:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004d26:	e0 6b 00 80 	mov	r11,128
80004d2a:	30 dc       	mov	r12,13
80004d2c:	f0 1f 00 08 	mcall	80004d4c <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004d30:	30 6c       	mov	r12,6
80004d32:	f0 1f 00 09 	mcall	80004d54 <PcdComMF522+0x174>
80004d36:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004d3a:	cb 80       	breq	80004caa <PcdComMF522+0xca>
80004d3c:	30 27       	mov	r7,2
80004d3e:	ce 8b       	rjmp	80004d0e <PcdComMF522+0x12e>
80004d40:	80 00       	ld.sh	r0,r0[0x0]
80004d42:	d8 50       	acall	0x85
80004d44:	80 00       	ld.sh	r0,r0[0x0]
80004d46:	d8 54       	*unknown*
80004d48:	80 00       	ld.sh	r0,r0[0x0]
80004d4a:	48 b8       	lddpc	r8,80004d74 <PcdAnticoll+0x1c>
80004d4c:	80 00       	ld.sh	r0,r0[0x0]
80004d4e:	4a 60       	lddpc	r0,80004de4 <PcdRequest+0x8>
80004d50:	80 00       	ld.sh	r0,r0[0x0]
80004d52:	4a 1c       	lddpc	r12,80004dd4 <PcdAnticoll+0x7c>
80004d54:	80 00       	ld.sh	r0,r0[0x0]
80004d56:	49 78       	lddpc	r8,80004db0 <PcdAnticoll+0x58>

80004d58 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004d58:	eb cd 40 c0 	pushm	r6-r7,lr
80004d5c:	20 5d       	sub	sp,20
80004d5e:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004d60:	30 8b       	mov	r11,8
80004d62:	16 9c       	mov	r12,r11
80004d64:	f0 1f 00 1a 	mcall	80004dcc <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004d68:	30 0b       	mov	r11,0
80004d6a:	30 dc       	mov	r12,13
80004d6c:	f0 1f 00 19 	mcall	80004dd0 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004d70:	e0 6b 00 80 	mov	r11,128
80004d74:	30 ec       	mov	r12,14
80004d76:	f0 1f 00 16 	mcall	80004dcc <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004d7a:	39 38       	mov	r8,-109
80004d7c:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004d7e:	32 08       	mov	r8,32
80004d80:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004d82:	1a 9b       	mov	r11,sp
80004d84:	fa c8 ff ed 	sub	r8,sp,-19
80004d88:	1a 99       	mov	r9,sp
80004d8a:	30 2a       	mov	r10,2
80004d8c:	30 cc       	mov	r12,12
80004d8e:	f0 1f 00 12 	mcall	80004dd4 <PcdAnticoll+0x7c>
80004d92:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004d94:	c1 21       	brne	80004db8 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004d96:	1b 89       	ld.ub	r9,sp[0x0]
80004d98:	ac 89       	st.b	r6[0x0],r9
80004d9a:	1b 98       	ld.ub	r8,sp[0x1]
80004d9c:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004d9e:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004da0:	1b a8       	ld.ub	r8,sp[0x2]
80004da2:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004da4:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004da8:	1b b9       	ld.ub	r9,sp[0x3]
80004daa:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004dac:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004dae:	1b c9       	ld.ub	r9,sp[0x4]
80004db0:	f0 09 18 00 	cp.b	r9,r8
80004db4:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004db8:	e0 6b 00 80 	mov	r11,128
80004dbc:	30 ec       	mov	r12,14
80004dbe:	f0 1f 00 07 	mcall	80004dd8 <PcdAnticoll+0x80>
	return status;
}
80004dc2:	0e 9c       	mov	r12,r7
80004dc4:	2f bd       	sub	sp,-20
80004dc6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004dca:	00 00       	add	r0,r0
80004dcc:	80 00       	ld.sh	r0,r0[0x0]
80004dce:	4a 60       	lddpc	r0,80004e64 <CalulateCRC+0x24>
80004dd0:	80 00       	ld.sh	r0,r0[0x0]
80004dd2:	48 b8       	lddpc	r8,80004dfc <PcdRequest+0x20>
80004dd4:	80 00       	ld.sh	r0,r0[0x0]
80004dd6:	4b e0       	lddpc	r0,80004ecc <PcdSelect>
80004dd8:	80 00       	ld.sh	r0,r0[0x0]
80004dda:	4a 1c       	lddpc	r12,80004e5c <CalulateCRC+0x1c>

80004ddc <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004ddc:	eb cd 40 c0 	pushm	r6-r7,lr
80004de0:	20 5d       	sub	sp,20
80004de2:	18 97       	mov	r7,r12
80004de4:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004de6:	30 8b       	mov	r11,8
80004de8:	16 9c       	mov	r12,r11
80004dea:	f0 1f 00 12 	mcall	80004e30 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004dee:	30 7b       	mov	r11,7
80004df0:	30 dc       	mov	r12,13
80004df2:	f0 1f 00 11 	mcall	80004e34 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004df6:	30 3b       	mov	r11,3
80004df8:	31 4c       	mov	r12,20
80004dfa:	f0 1f 00 10 	mcall	80004e38 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004dfe:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004e00:	1a 9b       	mov	r11,sp
80004e02:	fa c8 ff ed 	sub	r8,sp,-19
80004e06:	1a 99       	mov	r9,sp
80004e08:	30 1a       	mov	r10,1
80004e0a:	30 cc       	mov	r12,12
80004e0c:	f0 1f 00 0c 	mcall	80004e3c <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004e10:	c0 c1       	brne	80004e28 <PcdRequest+0x4c>
80004e12:	31 08       	mov	r8,16
80004e14:	fb 39 00 13 	ld.ub	r9,sp[19]
80004e18:	f0 09 18 00 	cp.b	r9,r8
80004e1c:	c0 61       	brne	80004e28 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004e1e:	1b 88       	ld.ub	r8,sp[0x0]
80004e20:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004e22:	1b 98       	ld.ub	r8,sp[0x1]
80004e24:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004e26:	c0 28       	rjmp	80004e2a <PcdRequest+0x4e>
80004e28:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004e2a:	2f bd       	sub	sp,-20
80004e2c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004e30:	80 00       	ld.sh	r0,r0[0x0]
80004e32:	4a 60       	lddpc	r0,80004ec8 <CalulateCRC+0x88>
80004e34:	80 00       	ld.sh	r0,r0[0x0]
80004e36:	48 b8       	lddpc	r8,80004e60 <CalulateCRC+0x20>
80004e38:	80 00       	ld.sh	r0,r0[0x0]
80004e3a:	4a 1c       	lddpc	r12,80004ebc <CalulateCRC+0x7c>
80004e3c:	80 00       	ld.sh	r0,r0[0x0]
80004e3e:	4b e0       	lddpc	r0,80004f34 <PcdSelect+0x68>

80004e40 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004e40:	eb cd 40 f8 	pushm	r3-r7,lr
80004e44:	18 95       	mov	r5,r12
80004e46:	16 96       	mov	r6,r11
80004e48:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004e4a:	30 4b       	mov	r11,4
80004e4c:	30 5c       	mov	r12,5
80004e4e:	f0 1f 00 1c 	mcall	80004ebc <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004e52:	30 0b       	mov	r11,0
80004e54:	30 1c       	mov	r12,1
80004e56:	f0 1f 00 1b 	mcall	80004ec0 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004e5a:	e0 6b 00 80 	mov	r11,128
80004e5e:	30 ac       	mov	r12,10
80004e60:	f0 1f 00 19 	mcall	80004ec4 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004e64:	58 06       	cp.w	r6,0
80004e66:	c0 c0       	breq	80004e7e <CalulateCRC+0x3e>
80004e68:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004e6a:	30 94       	mov	r4,9
80004e6c:	0f 3b       	ld.ub	r11,r7++
80004e6e:	08 9c       	mov	r12,r4
80004e70:	f0 1f 00 14 	mcall	80004ec0 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004e74:	0e 98       	mov	r8,r7
80004e76:	0a 18       	sub	r8,r5
80004e78:	ec 08 18 00 	cp.b	r8,r6
80004e7c:	cf 83       	brcs	80004e6c <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004e7e:	30 3b       	mov	r11,3
80004e80:	30 1c       	mov	r12,1
80004e82:	f0 1f 00 10 	mcall	80004ec0 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004e86:	30 5c       	mov	r12,5
80004e88:	f0 1f 00 10 	mcall	80004ec8 <CalulateCRC+0x88>
80004e8c:	e0 67 00 fe 	mov	r7,254
80004e90:	30 56       	mov	r6,5
80004e92:	c0 78       	rjmp	80004ea0 <CalulateCRC+0x60>
80004e94:	0c 9c       	mov	r12,r6
80004e96:	f0 1f 00 0d 	mcall	80004ec8 <CalulateCRC+0x88>
		i--;
80004e9a:	20 17       	sub	r7,1
80004e9c:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004e9e:	c0 40       	breq	80004ea6 <CalulateCRC+0x66>
80004ea0:	e2 1c 00 04 	andl	r12,0x4,COH
80004ea4:	cf 80       	breq	80004e94 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004ea6:	32 2c       	mov	r12,34
80004ea8:	f0 1f 00 08 	mcall	80004ec8 <CalulateCRC+0x88>
80004eac:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004eae:	32 1c       	mov	r12,33
80004eb0:	f0 1f 00 06 	mcall	80004ec8 <CalulateCRC+0x88>
80004eb4:	a6 9c       	st.b	r3[0x1],r12
}
80004eb6:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004eba:	00 00       	add	r0,r0
80004ebc:	80 00       	ld.sh	r0,r0[0x0]
80004ebe:	4a 60       	lddpc	r0,80004f54 <rfid_auto_reader+0x14>
80004ec0:	80 00       	ld.sh	r0,r0[0x0]
80004ec2:	48 b8       	lddpc	r8,80004eec <PcdSelect+0x20>
80004ec4:	80 00       	ld.sh	r0,r0[0x0]
80004ec6:	4a 1c       	lddpc	r12,80004f48 <rfid_auto_reader+0x8>
80004ec8:	80 00       	ld.sh	r0,r0[0x0]
80004eca:	49 78       	lddpc	r8,80004f24 <PcdSelect+0x58>

80004ecc <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004ecc:	eb cd 40 80 	pushm	r7,lr
80004ed0:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004ed2:	39 38       	mov	r8,-109
80004ed4:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004ed6:	37 08       	mov	r8,112
80004ed8:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004eda:	30 08       	mov	r8,0
80004edc:	ba e8       	st.b	sp[0x6],r8
80004ede:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004ee2:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004ee6:	19 89       	ld.ub	r9,r12[0x0]
80004ee8:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004eea:	19 3a       	ld.ub	r10,r12++
80004eec:	1b e9       	ld.ub	r9,sp[0x6]
80004eee:	f5 e9 20 09 	eor	r9,r10,r9
80004ef2:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004ef4:	16 38       	cp.w	r8,r11
80004ef6:	cf 81       	brne	80004ee6 <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004ef8:	1a 97       	mov	r7,sp
80004efa:	fa ca ff f9 	sub	r10,sp,-7
80004efe:	30 7b       	mov	r11,7
80004f00:	1a 9c       	mov	r12,sp
80004f02:	f0 1f 00 0d 	mcall	80004f34 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004f06:	30 8b       	mov	r11,8
80004f08:	16 9c       	mov	r12,r11
80004f0a:	f0 1f 00 0c 	mcall	80004f38 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004f0e:	fa c8 ff ed 	sub	r8,sp,-19
80004f12:	1a 99       	mov	r9,sp
80004f14:	30 9a       	mov	r10,9
80004f16:	1a 9b       	mov	r11,sp
80004f18:	30 cc       	mov	r12,12
80004f1a:	f0 1f 00 09 	mcall	80004f3c <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80004f1e:	c0 71       	brne	80004f2c <PcdSelect+0x60>
80004f20:	31 88       	mov	r8,24
80004f22:	fb 39 00 13 	ld.ub	r9,sp[19]
80004f26:	f0 09 18 00 	cp.b	r9,r8
80004f2a:	c0 20       	breq	80004f2e <PcdSelect+0x62>
80004f2c:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80004f2e:	2f bd       	sub	sp,-20
80004f30:	e3 cd 80 80 	ldm	sp++,r7,pc
80004f34:	80 00       	ld.sh	r0,r0[0x0]
80004f36:	4e 40       	lddpc	r0,800050c4 <scan_rfid_save_message+0x14>
80004f38:	80 00       	ld.sh	r0,r0[0x0]
80004f3a:	4a 60       	lddpc	r0,80004fd0 <rfid_auto_reader+0x90>
80004f3c:	80 00       	ld.sh	r0,r0[0x0]
80004f3e:	4b e0       	lddpc	r0,80005034 <rfid_auto_reader+0xf4>

80004f40 <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80004f40:	eb cd 40 c0 	pushm	r6-r7,lr
80004f44:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80004f46:	f0 1f 00 37 	mcall	80005020 <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80004f4a:	4b 7b       	lddpc	r11,80005024 <rfid_auto_reader+0xe4>
80004f4c:	35 2c       	mov	r12,82
80004f4e:	f0 1f 00 37 	mcall	80005028 <rfid_auto_reader+0xe8>
80004f52:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80004f54:	c6 31       	brne	8000501a <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004f56:	4b 48       	lddpc	r8,80005024 <rfid_auto_reader+0xe4>
80004f58:	11 88       	ld.ub	r8,r8[0x0]
80004f5a:	30 49       	mov	r9,4
80004f5c:	f2 08 18 00 	cp.b	r8,r9
80004f60:	c0 b1       	brne	80004f76 <rfid_auto_reader+0x36>
80004f62:	4b 19       	lddpc	r9,80005024 <rfid_auto_reader+0xe4>
80004f64:	13 9a       	ld.ub	r10,r9[0x1]
80004f66:	30 09       	mov	r9,0
80004f68:	f2 0a 18 00 	cp.b	r10,r9
80004f6c:	c0 51       	brne	80004f76 <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
80004f6e:	4b 0c       	lddpc	r12,8000502c <rfid_auto_reader+0xec>
80004f70:	f0 1f 00 30 	mcall	80005030 <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004f74:	c3 c8       	rjmp	80004fec <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004f76:	30 29       	mov	r9,2
80004f78:	f2 08 18 00 	cp.b	r8,r9
80004f7c:	c0 b1       	brne	80004f92 <rfid_auto_reader+0x52>
80004f7e:	4a a9       	lddpc	r9,80005024 <rfid_auto_reader+0xe4>
80004f80:	13 9a       	ld.ub	r10,r9[0x1]
80004f82:	30 09       	mov	r9,0
80004f84:	f2 0a 18 00 	cp.b	r10,r9
80004f88:	c0 51       	brne	80004f92 <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80004f8a:	4a bc       	lddpc	r12,80005034 <rfid_auto_reader+0xf4>
80004f8c:	f0 1f 00 29 	mcall	80005030 <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004f90:	c2 e8       	rjmp	80004fec <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004f92:	34 49       	mov	r9,68
80004f94:	f2 08 18 00 	cp.b	r8,r9
80004f98:	c0 b1       	brne	80004fae <rfid_auto_reader+0x6e>
80004f9a:	4a 39       	lddpc	r9,80005024 <rfid_auto_reader+0xe4>
80004f9c:	13 9a       	ld.ub	r10,r9[0x1]
80004f9e:	30 09       	mov	r9,0
80004fa0:	f2 0a 18 00 	cp.b	r10,r9
80004fa4:	c0 51       	brne	80004fae <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80004fa6:	4a 5c       	lddpc	r12,80005038 <rfid_auto_reader+0xf8>
80004fa8:	f0 1f 00 22 	mcall	80005030 <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004fac:	c2 08       	rjmp	80004fec <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004fae:	30 89       	mov	r9,8
80004fb0:	f2 08 18 00 	cp.b	r8,r9
80004fb4:	c0 b1       	brne	80004fca <rfid_auto_reader+0x8a>
80004fb6:	49 c9       	lddpc	r9,80005024 <rfid_auto_reader+0xe4>
80004fb8:	13 9a       	ld.ub	r10,r9[0x1]
80004fba:	30 09       	mov	r9,0
80004fbc:	f2 0a 18 00 	cp.b	r10,r9
80004fc0:	c0 51       	brne	80004fca <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80004fc2:	49 fc       	lddpc	r12,8000503c <rfid_auto_reader+0xfc>
80004fc4:	f0 1f 00 1b 	mcall	80005030 <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004fc8:	c1 28       	rjmp	80004fec <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004fca:	34 49       	mov	r9,68
80004fcc:	f2 08 18 00 	cp.b	r8,r9
80004fd0:	c0 b1       	brne	80004fe6 <rfid_auto_reader+0xa6>
80004fd2:	49 58       	lddpc	r8,80005024 <rfid_auto_reader+0xe4>
80004fd4:	11 99       	ld.ub	r9,r8[0x1]
80004fd6:	30 38       	mov	r8,3
80004fd8:	f0 09 18 00 	cp.b	r9,r8
80004fdc:	c0 51       	brne	80004fe6 <rfid_auto_reader+0xa6>
		log("MF Desire\n");
80004fde:	49 9c       	lddpc	r12,80005040 <rfid_auto_reader+0x100>
80004fe0:	f0 1f 00 14 	mcall	80005030 <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004fe4:	c0 48       	rjmp	80004fec <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80004fe6:	49 8c       	lddpc	r12,80005044 <rfid_auto_reader+0x104>
80004fe8:	f0 1f 00 12 	mcall	80005030 <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80004fec:	49 7c       	lddpc	r12,80005048 <rfid_auto_reader+0x108>
80004fee:	f0 1f 00 18 	mcall	8000504c <rfid_auto_reader+0x10c>
80004ff2:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80004ff4:	c0 60       	breq	80005000 <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, Low_Battery_3);//set tone to noticy failure!!!
80004ff6:	34 fb       	mov	r11,79
80004ff8:	30 1c       	mov	r12,1
80004ffa:	f0 1f 00 16 	mcall	80005050 <rfid_auto_reader+0x110>
		return status;
80004ffe:	c0 e8       	rjmp	8000501a <rfid_auto_reader+0xda>
		//continue;
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80005000:	49 2c       	lddpc	r12,80005048 <rfid_auto_reader+0x108>
80005002:	f0 1f 00 15 	mcall	80005054 <rfid_auto_reader+0x114>
80005006:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80005008:	c0 91       	brne	8000501a <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
8000500a:	30 4a       	mov	r10,4
8000500c:	48 fb       	lddpc	r11,80005048 <rfid_auto_reader+0x108>
8000500e:	0c 9c       	mov	r12,r6
80005010:	f0 1f 00 12 	mcall	80005058 <rfid_auto_reader+0x118>
		log("select okay\n");
80005014:	49 2c       	lddpc	r12,8000505c <rfid_auto_reader+0x11c>
80005016:	f0 1f 00 07 	mcall	80005030 <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
8000501a:	0e 9c       	mov	r12,r7
8000501c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005020:	80 00       	ld.sh	r0,r0[0x0]
80005022:	48 f8       	lddpc	r8,8000505c <rfid_auto_reader+0x11c>
80005024:	00 00       	add	r0,r0
80005026:	51 34       	stdsp	sp[0x4c],r4
80005028:	80 00       	ld.sh	r0,r0[0x0]
8000502a:	4d dc       	lddpc	r12,8000519c <scan_rfid_save_message+0xec>
8000502c:	80 00       	ld.sh	r0,r0[0x0]
8000502e:	d8 88       	*unknown*
80005030:	80 00       	ld.sh	r0,r0[0x0]
80005032:	6f 78       	ld.w	r8,r7[0x5c]
80005034:	80 00       	ld.sh	r0,r0[0x0]
80005036:	d8 94       	*unknown*
80005038:	80 00       	ld.sh	r0,r0[0x0]
8000503a:	d8 a0       	acall	0x8a
8000503c:	80 00       	ld.sh	r0,r0[0x0]
8000503e:	d8 b0       	acall	0x8b
80005040:	80 00       	ld.sh	r0,r0[0x0]
80005042:	d8 b8       	*unknown*
80005044:	80 00       	ld.sh	r0,r0[0x0]
80005046:	d8 c4       	*unknown*
80005048:	00 00       	add	r0,r0
8000504a:	51 38       	stdsp	sp[0x4c],r8
8000504c:	80 00       	ld.sh	r0,r0[0x0]
8000504e:	4d 58       	lddpc	r8,800051a0 <scan_rfid_save_message+0xf0>
80005050:	80 00       	ld.sh	r0,r0[0x0]
80005052:	40 4c       	lddsp	r12,sp[0x10]
80005054:	80 00       	ld.sh	r0,r0[0x0]
80005056:	4e cc       	lddpc	r12,80005204 <scan_rfid_save_message+0x154>
80005058:	80 00       	ld.sh	r0,r0[0x0]
8000505a:	77 f4       	ld.w	r4,r11[0x7c]
8000505c:	80 00       	ld.sh	r0,r0[0x0]
8000505e:	d8 d0       	acall	0x8d

80005060 <scan_patrol>:
	return return_err;
	
}

U8 scan_patrol(char* SN)
{
80005060:	eb cd 40 80 	pushm	r7,lr
80005064:	18 97       	mov	r7,r12
	U8 return_err = MI_ERR;
	
	PcdReset();
80005066:	f0 1f 00 0d 	mcall	80005098 <scan_patrol+0x38>
	Powerdown_RC522(WAKEUP_RC522);
8000506a:	30 0c       	mov	r12,0
8000506c:	f0 1f 00 0c 	mcall	8000509c <scan_patrol+0x3c>
	return_err = rfid_auto_reader(SN);
80005070:	0e 9c       	mov	r12,r7
80005072:	f0 1f 00 0c 	mcall	800050a0 <scan_patrol+0x40>
80005076:	18 97       	mov	r7,r12
	Powerdown_RC522(ENTER_POWERDOWN);
80005078:	30 1c       	mov	r12,1
8000507a:	f0 1f 00 09 	mcall	8000509c <scan_patrol+0x3c>
	if(return_err == 0)
8000507e:	58 07       	cp.w	r7,0
80005080:	c0 51       	brne	8000508a <scan_patrol+0x2a>
		log("scan_patrol okay!\n");
80005082:	48 9c       	lddpc	r12,800050a4 <scan_patrol+0x44>
80005084:	f0 1f 00 09 	mcall	800050a8 <scan_patrol+0x48>
80005088:	c0 48       	rjmp	80005090 <scan_patrol+0x30>
	else
		log("scan_patrol err!\n");
8000508a:	48 9c       	lddpc	r12,800050ac <scan_patrol+0x4c>
8000508c:	f0 1f 00 07 	mcall	800050a8 <scan_patrol+0x48>
		
	return return_err;

}
80005090:	0e 9c       	mov	r12,r7
80005092:	e3 cd 80 80 	ldm	sp++,r7,pc
80005096:	00 00       	add	r0,r0
80005098:	80 00       	ld.sh	r0,r0[0x0]
8000509a:	48 f8       	lddpc	r8,800050d4 <scan_rfid_save_message+0x24>
8000509c:	80 00       	ld.sh	r0,r0[0x0]
8000509e:	49 d0       	lddpc	r0,80005110 <scan_rfid_save_message+0x60>
800050a0:	80 00       	ld.sh	r0,r0[0x0]
800050a2:	4f 40       	lddpc	r0,80005270 <scan_rfid_save_message+0x1c0>
800050a4:	80 00       	ld.sh	r0,r0[0x0]
800050a6:	d8 e0       	acall	0x8e
800050a8:	80 00       	ld.sh	r0,r0[0x0]
800050aa:	6f 78       	ld.w	r8,r7[0x5c]
800050ac:	80 00       	ld.sh	r0,r0[0x0]
800050ae:	d8 f4       	*unknown*

800050b0 <scan_rfid_save_message>:
U8 scan_rfid_save_message()
{
800050b0:	eb cd 40 e0 	pushm	r5-r7,lr
800050b4:	fa cd 00 8c 	sub	sp,sp,140
	U8 destination = DEST;
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	memset(SN, 0x00, 10);
800050b8:	4e 9c       	lddpc	r12,8000525c <scan_rfid_save_message+0x1ac>
800050ba:	30 08       	mov	r8,0
800050bc:	30 09       	mov	r9,0
800050be:	f8 e9 00 00 	st.d	r12[0],r8
800050c2:	30 0a       	mov	r10,0
800050c4:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
800050c6:	fa e9 00 3c 	st.d	sp[60],r8
800050ca:	fa e9 00 44 	st.d	sp[68],r8
800050ce:	fa e9 00 4c 	st.d	sp[76],r8
800050d2:	fa e9 00 54 	st.d	sp[84],r8
800050d6:	fa e9 00 5c 	st.d	sp[92],r8
800050da:	fa e9 00 64 	st.d	sp[100],r8
800050de:	fa e9 00 6c 	st.d	sp[108],r8
800050e2:	fa e9 00 74 	st.d	sp[116],r8
800050e6:	fa e9 00 7c 	st.d	sp[124],r8
800050ea:	fa e9 00 84 	st.d	sp[132],r8
	
	return_err = scan_patrol(SN);
800050ee:	f0 1f 00 5d 	mcall	80005260 <scan_rfid_save_message+0x1b0>
800050f2:	18 97       	mov	r7,r12
	
	if(return_err == 0){
800050f4:	e0 81 00 a8 	brne	80005244 <scan_rfid_save_message+0x194>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
800050f8:	4d 96       	lddpc	r6,8000525c <scan_rfid_save_message+0x1ac>
800050fa:	0d b8       	ld.ub	r8,r6[0x3]
800050fc:	1a d8       	st.w	--sp,r8
800050fe:	0d a8       	ld.ub	r8,r6[0x2]
80005100:	1a d8       	st.w	--sp,r8
80005102:	0d 98       	ld.ub	r8,r6[0x1]
80005104:	1a d8       	st.w	--sp,r8
80005106:	0d 88       	ld.ub	r8,r6[0x0]
80005108:	1a d8       	st.w	--sp,r8
8000510a:	4d 7c       	lddpc	r12,80005264 <scan_rfid_save_message+0x1b4>
8000510c:	f0 1f 00 57 	mcall	80005268 <scan_rfid_save_message+0x1b8>
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
80005110:	34 4b       	mov	r11,68
80005112:	30 1c       	mov	r12,1
80005114:	f0 1f 00 56 	mcall	8000526c <scan_rfid_save_message+0x1bc>
80005118:	fa c8 ff ce 	sub	r8,sp,-50
8000511c:	fa c9 ff cc 	sub	r9,sp,-52
		log("scan_patrol err!\n");
		
	return return_err;

}
U8 scan_rfid_save_message()
80005120:	ec c5 ff fc 	sub	r5,r6,-4
80005124:	2f cd       	sub	sp,-16
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80005126:	30 9e       	mov	lr,9
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
80005128:	30 0c       	mov	r12,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
8000512a:	0d 8a       	ld.ub	r10,r6[0x0]
8000512c:	f4 0b 16 04 	lsr	r11,r10,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80005130:	fc 0b 18 00 	cp.b	r11,lr
80005134:	f7 bb 08 d0 	subls	r11,-48
80005138:	f1 fb 8e 00 	st.bls	r8[0x0],r11
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
8000513c:	f7 bb 0b a9 	subhi	r11,-87
80005140:	f1 fb be 00 	st.bhi	r8[0x0],r11
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
80005144:	b0 9c       	st.b	r8[0x1],r12
			
			temp = (SN[i] & 0x0F);//瀛浣浣
80005146:	f5 da c0 04 	bfextu	r10,r10,0x0,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
8000514a:	fc 0a 18 00 	cp.b	r10,lr
8000514e:	f7 ba 08 d0 	subls	r10,-48
80005152:	f3 fa 8e 00 	st.bls	r9[0x0],r10
			else
			data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
80005156:	f7 ba 0b a9 	subhi	r10,-87
8000515a:	f3 fa be 00 	st.bhi	r9[0x0],r10

			data_buffer.RFID_ID[i*4+3] = 0x00;
8000515e:	b0 bc       	st.b	r8[0x3],r12
80005160:	2f f6       	sub	r6,-1
80005162:	2f c8       	sub	r8,-4
80005164:	2f c9       	sub	r9,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
80005166:	0a 36       	cp.w	r6,r5
80005168:	ce 11       	brne	8000512a <scan_rfid_save_message+0x7a>
		
		//memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
		
		header.length = (0x0008 + sizeof(Message_Data_t));
		
		if(start_session > 0x9f)start_session = 0x80;
8000516a:	4c 28       	lddpc	r8,80005270 <scan_rfid_save_message+0x1c0>
8000516c:	11 89       	ld.ub	r9,r8[0x0]
8000516e:	39 f8       	mov	r8,-97
80005170:	f0 09 18 00 	cp.b	r9,r8
80005174:	e0 88 00 05 	brls	8000517e <scan_rfid_save_message+0xce>
80005178:	38 09       	mov	r9,-128
8000517a:	4b e8       	lddpc	r8,80005270 <scan_rfid_save_message+0x1c0>
8000517c:	b0 89       	st.b	r8[0x0],r9
		
		header.session_id = (++start_session);
8000517e:	4b d8       	lddpc	r8,80005270 <scan_rfid_save_message+0x1c0>
80005180:	11 86       	ld.ub	r6,r8[0x0]
80005182:	2f f6       	sub	r6,-1
80005184:	b0 86       	st.b	r8[0x0],r6
		
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
80005186:	30 5a       	mov	r10,5
80005188:	4b bb       	lddpc	r11,80005274 <scan_rfid_save_message+0x1c4>
8000518a:	fa cc ff c9 	sub	r12,sp,-55
8000518e:	f0 1f 00 3b 	mcall	80005278 <scan_rfid_save_message+0x1c8>
		header.type = 0xe000;
		
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
80005192:	31 88       	mov	r8,24
80005194:	fb 58 00 32 	st.h	sp[50],r8
80005198:	fb 66 00 36 	st.b	sp[54],r6
8000519c:	fe 78 e0 00 	mov	r8,-8192
800051a0:	fb 58 00 34 	st.h	sp[52],r8
800051a4:	fa c6 ff c4 	sub	r6,sp,-60
800051a8:	30 aa       	mov	r10,10
800051aa:	fa cb ff ce 	sub	r11,sp,-50
800051ae:	0c 9c       	mov	r12,r6
800051b0:	f0 1f 00 32 	mcall	80005278 <scan_rfid_save_message+0x1c8>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
800051b4:	31 0a       	mov	r10,16
800051b6:	fa cb ff de 	sub	r11,sp,-34
800051ba:	fa cc ff ba 	sub	r12,sp,-70
800051be:	f0 1f 00 2f 	mcall	80005278 <scan_rfid_save_message+0x1c8>
		
		//xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
		Message_Protocol_t  xgmessage;
		memcpy(&xgmessage, message, sizeof(Message_Protocol_t));
800051c2:	31 aa       	mov	r10,26
800051c4:	0c 9b       	mov	r11,r6
800051c6:	fa cc ff fe 	sub	r12,sp,-2
800051ca:	f0 1f 00 2c 	mcall	80005278 <scan_rfid_save_message+0x1c8>

		Message_Protocol_t * myptr = get_message_store();
800051ce:	4a c8       	lddpc	r8,8000527c <scan_rfid_save_message+0x1cc>
800051d0:	70 0c       	ld.w	r12,r8[0x0]
800051d2:	f0 1f 00 2c 	mcall	80005280 <scan_rfid_save_message+0x1d0>
800051d6:	50 7c       	stdsp	sp[0x1c],r12
		if(NULL != myptr)
800051d8:	c3 20       	breq	8000523c <scan_rfid_save_message+0x18c>
		{
			memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));
800051da:	31 aa       	mov	r10,26
800051dc:	fa cb ff fe 	sub	r11,sp,-2
800051e0:	f0 1f 00 26 	mcall	80005278 <scan_rfid_save_message+0x1c8>
			if (xQueueSend(xg_resend_queue, &myptr, 0) != pdPASS)
800051e4:	4a 88       	lddpc	r8,80005284 <scan_rfid_save_message+0x1d4>
800051e6:	70 0c       	ld.w	r12,r8[0x0]
800051e8:	30 09       	mov	r9,0
800051ea:	12 9a       	mov	r10,r9
800051ec:	fa cb ff e4 	sub	r11,sp,-28
800051f0:	f0 1f 00 26 	mcall	80005288 <scan_rfid_save_message+0x1d8>
800051f4:	58 1c       	cp.w	r12,1
800051f6:	c1 10       	breq	80005218 <scan_rfid_save_message+0x168>
			{
				log("xg_resend_queue: full\n" );
800051f8:	4a 5c       	lddpc	r12,8000528c <scan_rfid_save_message+0x1dc>
800051fa:	f0 1f 00 1c 	mcall	80005268 <scan_rfid_save_message+0x1b8>
				xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
800051fe:	32 3b       	mov	r11,35
80005200:	30 1c       	mov	r12,1
80005202:	f0 1f 00 1b 	mcall	8000526c <scan_rfid_save_message+0x1bc>
				vTaskDelay(3000*2 / portTICK_RATE_MS);//寤惰3000ms
80005206:	e0 6c 17 70 	mov	r12,6000
8000520a:	f0 1f 00 22 	mcall	80005290 <scan_rfid_save_message+0x1e0>
				xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
8000520e:	32 3b       	mov	r11,35
80005210:	30 0c       	mov	r12,0
80005212:	f0 1f 00 17 	mcall	8000526c <scan_rfid_save_message+0x1bc>
80005216:	c1 e8       	rjmp	80005252 <scan_rfid_save_message+0x1a2>
			}
			else{
				
				xSemaphoreTake(count_mutex, portMAX_DELAY);
80005218:	49 f6       	lddpc	r6,80005294 <scan_rfid_save_message+0x1e4>
8000521a:	6c 0c       	ld.w	r12,r6[0x0]
8000521c:	30 09       	mov	r9,0
8000521e:	3f fa       	mov	r10,-1
80005220:	12 9b       	mov	r11,r9
80005222:	f0 1f 00 1e 	mcall	80005298 <scan_rfid_save_message+0x1e8>
				global_count++;
80005226:	49 e8       	lddpc	r8,8000529c <scan_rfid_save_message+0x1ec>
80005228:	70 09       	ld.w	r9,r8[0x0]
8000522a:	2f f9       	sub	r9,-1
8000522c:	91 09       	st.w	r8[0x0],r9
				xSemaphoreGive(count_mutex);
8000522e:	6c 0c       	ld.w	r12,r6[0x0]
80005230:	30 09       	mov	r9,0
80005232:	12 9a       	mov	r10,r9
80005234:	12 9b       	mov	r11,r9
80005236:	f0 1f 00 15 	mcall	80005288 <scan_rfid_save_message+0x1d8>
8000523a:	c0 c8       	rjmp	80005252 <scan_rfid_save_message+0x1a2>
			}

		}
		else
		{
			log("myptr: err\n\r" );
8000523c:	49 9c       	lddpc	r12,800052a0 <scan_rfid_save_message+0x1f0>
8000523e:	f0 1f 00 0b 	mcall	80005268 <scan_rfid_save_message+0x1b8>
80005242:	c0 88       	rjmp	80005252 <scan_rfid_save_message+0x1a2>
		}
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, Low_Battery_3);//set tone to indicate scan rfid failure!!!
80005244:	34 fb       	mov	r11,79
80005246:	30 1c       	mov	r12,1
80005248:	f0 1f 00 09 	mcall	8000526c <scan_rfid_save_message+0x1bc>
		log("no card find...\n");
8000524c:	49 6c       	lddpc	r12,800052a4 <scan_rfid_save_message+0x1f4>
8000524e:	f0 1f 00 07 	mcall	80005268 <scan_rfid_save_message+0x1b8>
	}
	
	return return_err;
	
}
80005252:	0e 9c       	mov	r12,r7
80005254:	2d dd       	sub	sp,-140
80005256:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000525a:	00 00       	add	r0,r0
8000525c:	00 00       	add	r0,r0
8000525e:	0b 68       	ld.uh	r8,--r5
80005260:	80 00       	ld.sh	r0,r0[0x0]
80005262:	50 60       	stdsp	sp[0x18],r0
80005264:	80 00       	ld.sh	r0,r0[0x0]
80005266:	d9 08       	*unknown*
80005268:	80 00       	ld.sh	r0,r0[0x0]
8000526a:	6f 78       	ld.w	r8,r7[0x5c]
8000526c:	80 00       	ld.sh	r0,r0[0x0]
8000526e:	40 4c       	lddsp	r12,sp[0x10]
80005270:	00 00       	add	r0,r0
80005272:	05 30       	ld.ub	r0,r2++
80005274:	00 00       	add	r0,r0
80005276:	05 28       	ld.uh	r8,r2++
80005278:	80 00       	ld.sh	r0,r0[0x0]
8000527a:	77 f4       	ld.w	r4,r11[0x7c]
8000527c:	00 00       	add	r0,r0
8000527e:	0b 78       	ld.ub	r8,--r5
80005280:	80 00       	ld.sh	r0,r0[0x0]
80005282:	2d 90       	sub	r0,-39
80005284:	00 00       	add	r0,r0
80005286:	0b 74       	ld.ub	r4,--r5
80005288:	80 00       	ld.sh	r0,r0[0x0]
8000528a:	63 40       	ld.w	r0,r1[0x50]
8000528c:	80 00       	ld.sh	r0,r0[0x0]
8000528e:	d7 84       	*unknown*
80005290:	80 00       	ld.sh	r0,r0[0x0]
80005292:	6a 0c       	ld.w	r12,r5[0x0]
80005294:	00 00       	add	r0,r0
80005296:	0a 60       	and	r0,r5
80005298:	80 00       	ld.sh	r0,r0[0x0]
8000529a:	61 34       	ld.w	r4,r0[0x4c]
8000529c:	00 00       	add	r0,r0
8000529e:	0a 50       	eor	r0,r5
800052a0:	80 00       	ld.sh	r0,r0[0x0]
800052a2:	d7 9c       	*unknown*
800052a4:	80 00       	ld.sh	r0,r0[0x0]
800052a6:	d9 24       	*unknown*

800052a8 <rfid_init>:
extern volatile U32 global_count;
extern volatile xSemaphoreHandle count_mutex;


void rfid_init()
{
800052a8:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
800052aa:	f0 1f 00 02 	mcall	800052b0 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		//
}
800052ae:	d8 02       	popm	pc
800052b0:	80 00       	ld.sh	r0,r0[0x0]
800052b2:	4b 08       	lddpc	r8,80005370 <local_start_pll0+0x28>

800052b4 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
800052b4:	58 0c       	cp.w	r12,0
800052b6:	5e 0c       	reteq	r12
800052b8:	30 08       	mov	r8,0
	{
		nop();
800052ba:	d7 03       	nop
		nop();
800052bc:	d7 03       	nop
		nop();
800052be:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
800052c0:	2f f8       	sub	r8,-1
800052c2:	10 3c       	cp.w	r12,r8
800052c4:	fe 9b ff fb 	brhi	800052ba <delay_ns+0x6>
800052c8:	5e fc       	retal	r12
800052ca:	d7 03       	nop

800052cc <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
800052cc:	eb cd 40 e0 	pushm	r5-r7,lr
800052d0:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
800052d2:	58 0c       	cp.w	r12,0
800052d4:	c0 b0       	breq	800052ea <delay_us+0x1e>
800052d6:	30 07       	mov	r7,0
		delay_ns(1000);
800052d8:	e0 65 03 e8 	mov	r5,1000
800052dc:	0a 9c       	mov	r12,r5
800052de:	f0 1f 00 05 	mcall	800052f0 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
800052e2:	2f f7       	sub	r7,-1
800052e4:	0e 36       	cp.w	r6,r7
800052e6:	fe 9b ff fb 	brhi	800052dc <delay_us+0x10>
800052ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800052ee:	00 00       	add	r0,r0
800052f0:	80 00       	ld.sh	r0,r0[0x0]
800052f2:	52 b4       	stdsp	sp[0xac],r4

800052f4 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
800052f4:	eb cd 40 e0 	pushm	r5-r7,lr
800052f8:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
800052fa:	58 0c       	cp.w	r12,0
800052fc:	c0 b0       	breq	80005312 <delay_ms+0x1e>
800052fe:	30 07       	mov	r7,0
		delay_us(1000);
80005300:	e0 65 03 e8 	mov	r5,1000
80005304:	0a 9c       	mov	r12,r5
80005306:	f0 1f 00 05 	mcall	80005318 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
8000530a:	2f f7       	sub	r7,-1
8000530c:	0e 36       	cp.w	r6,r7
8000530e:	fe 9b ff fb 	brhi	80005304 <delay_ms+0x10>
80005312:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005316:	00 00       	add	r0,r0
80005318:	80 00       	ld.sh	r0,r0[0x0]
8000531a:	52 cc       	stdsp	sp[0xb0],r12

8000531c <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
8000531c:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
8000531e:	30 3b       	mov	r11,3
80005320:	48 8c       	lddpc	r12,80005340 <local_start_timer+0x24>
80005322:	f0 1f 00 09 	mcall	80005344 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
80005326:	fe 78 38 00 	mov	r8,-51200
8000532a:	e0 69 91 0d 	mov	r9,37133
8000532e:	ea 19 00 52 	orh	r9,0x52
80005332:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005334:	32 09       	mov	r9,32
80005336:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005338:	30 59       	mov	r9,5
8000533a:	91 09       	st.w	r8[0x0],r9
}
8000533c:	d8 02       	popm	pc
8000533e:	00 00       	add	r0,r0
80005340:	80 00       	ld.sh	r0,r0[0x0]
80005342:	d9 38       	*unknown*
80005344:	80 00       	ld.sh	r0,r0[0x0]
80005346:	54 cc       	stdsp	sp[0x130],r12

80005348 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
80005348:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
8000534a:	30 3a       	mov	r10,3
8000534c:	e0 6b 1b 00 	mov	r11,6912
80005350:	ea 1b 00 b7 	orh	r11,0xb7
80005354:	fe 7c 0c 00 	mov	r12,-62464
80005358:	f0 1f 00 19 	mcall	800053bc <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
8000535c:	31 08       	mov	r8,16
8000535e:	1a d8       	st.w	--sp,r8
80005360:	30 08       	mov	r8,0
80005362:	30 19       	mov	r9,1
80005364:	30 7a       	mov	r10,7
80005366:	10 9b       	mov	r11,r8
80005368:	fe 7c 0c 00 	mov	r12,-62464
8000536c:	f0 1f 00 15 	mcall	800053c0 <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
80005370:	30 08       	mov	r8,0
80005372:	30 19       	mov	r9,1
80005374:	12 9a       	mov	r10,r9
80005376:	10 9b       	mov	r11,r8
80005378:	fe 7c 0c 00 	mov	r12,-62464
8000537c:	f0 1f 00 12 	mcall	800053c4 <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
80005380:	30 0b       	mov	r11,0
80005382:	fe 7c 0c 00 	mov	r12,-62464
80005386:	f0 1f 00 11 	mcall	800053c8 <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
8000538a:	fe 7c 0c 00 	mov	r12,-62464
8000538e:	f0 1f 00 10 	mcall	800053cc <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
80005392:	30 0a       	mov	r10,0
80005394:	1a da       	st.w	--sp,r10
80005396:	1a da       	st.w	--sp,r10
80005398:	14 98       	mov	r8,r10
8000539a:	14 99       	mov	r9,r10
8000539c:	30 1b       	mov	r11,1
8000539e:	fe 7c 0c 00 	mov	r12,-62464
800053a2:	f0 1f 00 0c 	mcall	800053d0 <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
800053a6:	30 1c       	mov	r12,1
800053a8:	f0 1f 00 0b 	mcall	800053d4 <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
800053ac:	30 2b       	mov	r11,2
800053ae:	fe 7c 0c 00 	mov	r12,-62464
800053b2:	f0 1f 00 0a 	mcall	800053d8 <local_start_pll0+0x90>
800053b6:	2f dd       	sub	sp,-12
/****/
}
800053b8:	d8 02       	popm	pc
800053ba:	00 00       	add	r0,r0
800053bc:	80 00       	ld.sh	r0,r0[0x0]
800053be:	57 80       	stdsp	sp[0x1e0],r0
800053c0:	80 00       	ld.sh	r0,r0[0x0]
800053c2:	57 22       	stdsp	sp[0x1c8],r2
800053c4:	80 00       	ld.sh	r0,r0[0x0]
800053c6:	57 44       	stdsp	sp[0x1d0],r4
800053c8:	80 00       	ld.sh	r0,r0[0x0]
800053ca:	57 5e       	stdsp	sp[0x1d4],lr
800053cc:	80 00       	ld.sh	r0,r0[0x0]
800053ce:	57 6c       	stdsp	sp[0x1d8],r12
800053d0:	80 00       	ld.sh	r0,r0[0x0]
800053d2:	56 dc       	stdsp	sp[0x1b4],r12
800053d4:	80 00       	ld.sh	r0,r0[0x0]
800053d6:	54 6c       	stdsp	sp[0x118],r12
800053d8:	80 00       	ld.sh	r0,r0[0x0]
800053da:	57 76       	stdsp	sp[0x1dc],r6

800053dc <xg_flashc_init>:
}


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
800053dc:	eb cd 40 e0 	pushm	r5-r7,lr
	//{
		//log("Create the xgflash_mutex semaphore failure\n");
	//}
	//
	/* Create the binary semaphore to Synchronize other threads.*/
	vSemaphoreCreateBinary(xBinarySemaphore);
800053e0:	30 0b       	mov	r11,0
800053e2:	30 1c       	mov	r12,1
800053e4:	f0 1f 00 19 	mcall	80005448 <xg_flashc_init+0x6c>
800053e8:	49 98       	lddpc	r8,8000544c <xg_flashc_init+0x70>
800053ea:	91 0c       	st.w	r8[0x0],r12
800053ec:	70 08       	ld.w	r8,r8[0x0]
800053ee:	58 08       	cp.w	r8,0
800053f0:	c0 80       	breq	80005400 <xg_flashc_init+0x24>
800053f2:	49 78       	lddpc	r8,8000544c <xg_flashc_init+0x70>
800053f4:	70 0c       	ld.w	r12,r8[0x0]
800053f6:	30 09       	mov	r9,0
800053f8:	12 9a       	mov	r10,r9
800053fa:	12 9b       	mov	r11,r9
800053fc:	f0 1f 00 15 	mcall	80005450 <xg_flashc_init+0x74>
	if (xBinarySemaphore == NULL)
80005400:	49 38       	lddpc	r8,8000544c <xg_flashc_init+0x70>
80005402:	70 08       	ld.w	r8,r8[0x0]
80005404:	58 08       	cp.w	r8,0
80005406:	c0 41       	brne	8000540e <xg_flashc_init+0x32>
	{
		log("Create the xBinarySemaphore failure\n");
80005408:	49 3c       	lddpc	r12,80005454 <xg_flashc_init+0x78>
8000540a:	f0 1f 00 14 	mcall	80005458 <xg_flashc_init+0x7c>
	//if (SendM_CountingSemaphore == NULL)
	//{
		//log("Create the SendM_Counting semaphore failure\n");
	//}
	//
	xg_resend_queue = xQueueCreate(300, sizeof(U32));
8000540e:	30 4b       	mov	r11,4
80005410:	e0 6c 01 2c 	mov	r12,300
80005414:	f0 1f 00 0d 	mcall	80005448 <xg_flashc_init+0x6c>
80005418:	49 18       	lddpc	r8,8000545c <xg_flashc_init+0x80>
8000541a:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
8000541c:	30 4b       	mov	r11,4
8000541e:	e0 6c 01 90 	mov	r12,400
80005422:	f0 1f 00 0a 	mcall	80005448 <xg_flashc_init+0x6c>
80005426:	48 f8       	lddpc	r8,80005460 <xg_flashc_init+0x84>
80005428:	91 0c       	st.w	r8[0x0],r12
8000542a:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
8000542c:	10 96       	mov	r6,r8
8000542e:	48 e5       	lddpc	r5,80005464 <xg_flashc_init+0x88>
80005430:	6c 0c       	ld.w	r12,r6[0x0]
80005432:	ea 07 00 0b 	add	r11,r5,r7
80005436:	f0 1f 00 0d 	mcall	80005468 <xg_flashc_init+0x8c>
8000543a:	2e 67       	sub	r7,-26
	//}
	//
	xg_resend_queue = xQueueCreate(300, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
8000543c:	e0 47 28 a0 	cp.w	r7,10400
80005440:	cf 81       	brne	80005430 <xg_flashc_init+0x54>
	//flashc_lock_all_regions(false);
	//xgflash_list_info_init();
	
	
	//create_xg_flash_test_task();
}
80005442:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005446:	00 00       	add	r0,r0
80005448:	80 00       	ld.sh	r0,r0[0x0]
8000544a:	64 98       	ld.w	r8,r2[0x24]
8000544c:	00 00       	add	r0,r0
8000544e:	0b 7c       	ld.ub	r12,--r5
80005450:	80 00       	ld.sh	r0,r0[0x0]
80005452:	63 40       	ld.w	r0,r1[0x50]
80005454:	80 00       	ld.sh	r0,r0[0x0]
80005456:	d9 50       	acall	0x95
80005458:	80 00       	ld.sh	r0,r0[0x0]
8000545a:	6f 78       	ld.w	r8,r7[0x5c]
8000545c:	00 00       	add	r0,r0
8000545e:	0b 74       	ld.ub	r4,--r5
80005460:	00 00       	add	r0,r0
80005462:	0b 78       	ld.ub	r8,--r5
80005464:	00 00       	add	r0,r0
80005466:	51 3c       	stdsp	sp[0x4c],r12
80005468:	80 00       	ld.sh	r0,r0[0x0]
8000546a:	2b e4       	sub	r4,-66

8000546c <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
8000546c:	fe 68 14 00 	mov	r8,-125952
80005470:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
80005472:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80005476:	91 09       	st.w	r8[0x0],r9
}
80005478:	5e fc       	retal	r12

8000547a <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000547a:	f8 08 16 05 	lsr	r8,r12,0x5
8000547e:	a9 68       	lsl	r8,0x8
80005480:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80005484:	58 1b       	cp.w	r11,1
80005486:	c0 d0       	breq	800054a0 <gpio_enable_module_pin+0x26>
80005488:	c0 63       	brcs	80005494 <gpio_enable_module_pin+0x1a>
8000548a:	58 2b       	cp.w	r11,2
8000548c:	c1 00       	breq	800054ac <gpio_enable_module_pin+0x32>
8000548e:	58 3b       	cp.w	r11,3
80005490:	c1 40       	breq	800054b8 <gpio_enable_module_pin+0x3e>
80005492:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005494:	30 19       	mov	r9,1
80005496:	f2 0c 09 49 	lsl	r9,r9,r12
8000549a:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000549c:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000549e:	c1 28       	rjmp	800054c2 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800054a0:	30 19       	mov	r9,1
800054a2:	f2 0c 09 49 	lsl	r9,r9,r12
800054a6:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800054a8:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800054aa:	c0 c8       	rjmp	800054c2 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800054ac:	30 19       	mov	r9,1
800054ae:	f2 0c 09 49 	lsl	r9,r9,r12
800054b2:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800054b4:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800054b6:	c0 68       	rjmp	800054c2 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800054b8:	30 19       	mov	r9,1
800054ba:	f2 0c 09 49 	lsl	r9,r9,r12
800054be:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800054c0:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800054c2:	30 19       	mov	r9,1
800054c4:	f2 0c 09 4c 	lsl	r12,r9,r12
800054c8:	91 2c       	st.w	r8[0x8],r12
800054ca:	5e fd       	retal	0

800054cc <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800054cc:	d4 21       	pushm	r4-r7,lr
800054ce:	18 97       	mov	r7,r12
800054d0:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800054d2:	58 0b       	cp.w	r11,0
800054d4:	c0 31       	brne	800054da <gpio_enable_module+0xe>
800054d6:	30 05       	mov	r5,0
800054d8:	c0 d8       	rjmp	800054f2 <gpio_enable_module+0x26>
800054da:	30 06       	mov	r6,0
800054dc:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800054de:	6e 1b       	ld.w	r11,r7[0x4]
800054e0:	6e 0c       	ld.w	r12,r7[0x0]
800054e2:	f0 1f 00 06 	mcall	800054f8 <gpio_enable_module+0x2c>
800054e6:	18 45       	or	r5,r12
		gpiomap++;
800054e8:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800054ea:	2f f6       	sub	r6,-1
800054ec:	0c 34       	cp.w	r4,r6
800054ee:	fe 9b ff f8 	brhi	800054de <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
800054f2:	0a 9c       	mov	r12,r5
800054f4:	d8 22       	popm	r4-r7,pc
800054f6:	00 00       	add	r0,r0
800054f8:	80 00       	ld.sh	r0,r0[0x0]
800054fa:	54 7a       	stdsp	sp[0x11c],r10

800054fc <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800054fc:	f8 08 16 05 	lsr	r8,r12,0x5
80005500:	a9 68       	lsl	r8,0x8
80005502:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80005506:	30 19       	mov	r9,1
80005508:	f2 0c 09 4c 	lsl	r12,r9,r12
8000550c:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80005510:	91 1c       	st.w	r8[0x4],r12
}
80005512:	5e fc       	retal	r12

80005514 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005514:	f8 08 16 05 	lsr	r8,r12,0x5
80005518:	a9 68       	lsl	r8,0x8
8000551a:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000551e:	30 19       	mov	r9,1
80005520:	f2 0c 09 4c 	lsl	r12,r9,r12
80005524:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80005528:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000552c:	91 1c       	st.w	r8[0x4],r12
}
8000552e:	5e fc       	retal	r12

80005530 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005530:	f8 08 16 05 	lsr	r8,r12,0x5
80005534:	a9 68       	lsl	r8,0x8
80005536:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
8000553a:	30 19       	mov	r9,1
8000553c:	f2 0c 09 4c 	lsl	r12,r9,r12
80005540:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80005544:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005548:	91 1c       	st.w	r8[0x4],r12
}
8000554a:	5e fc       	retal	r12

8000554c <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
8000554c:	c0 08       	rjmp	8000554c <_unhandled_interrupt>
8000554e:	d7 03       	nop

80005550 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005550:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005554:	49 99       	lddpc	r9,800055b8 <INTC_register_interrupt+0x68>
80005556:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000555a:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000555e:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80005560:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80005564:	58 0a       	cp.w	r10,0
80005566:	c0 91       	brne	80005578 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005568:	49 59       	lddpc	r9,800055bc <INTC_register_interrupt+0x6c>
8000556a:	49 6a       	lddpc	r10,800055c0 <INTC_register_interrupt+0x70>
8000556c:	12 1a       	sub	r10,r9
8000556e:	fe 79 08 00 	mov	r9,-63488
80005572:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005576:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005578:	58 1a       	cp.w	r10,1
8000557a:	c0 a1       	brne	8000558e <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000557c:	49 09       	lddpc	r9,800055bc <INTC_register_interrupt+0x6c>
8000557e:	49 2a       	lddpc	r10,800055c4 <INTC_register_interrupt+0x74>
80005580:	12 1a       	sub	r10,r9
80005582:	bf aa       	sbr	r10,0x1e
80005584:	fe 79 08 00 	mov	r9,-63488
80005588:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000558c:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000558e:	58 2a       	cp.w	r10,2
80005590:	c0 a1       	brne	800055a4 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80005592:	48 b9       	lddpc	r9,800055bc <INTC_register_interrupt+0x6c>
80005594:	48 da       	lddpc	r10,800055c8 <INTC_register_interrupt+0x78>
80005596:	12 1a       	sub	r10,r9
80005598:	bf ba       	sbr	r10,0x1f
8000559a:	fe 79 08 00 	mov	r9,-63488
8000559e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800055a2:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800055a4:	48 69       	lddpc	r9,800055bc <INTC_register_interrupt+0x6c>
800055a6:	48 aa       	lddpc	r10,800055cc <INTC_register_interrupt+0x7c>
800055a8:	12 1a       	sub	r10,r9
800055aa:	ea 1a c0 00 	orh	r10,0xc000
800055ae:	fe 79 08 00 	mov	r9,-63488
800055b2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800055b6:	5e fc       	retal	r12
800055b8:	80 00       	ld.sh	r0,r0[0x0]
800055ba:	d9 88       	*unknown*
800055bc:	80 00       	ld.sh	r0,r0[0x0]
800055be:	ce 00       	breq	8000557e <INTC_register_interrupt+0x2e>
800055c0:	80 00       	ld.sh	r0,r0[0x0]
800055c2:	cf 04       	brge	800055a2 <INTC_register_interrupt+0x52>
800055c4:	80 00       	ld.sh	r0,r0[0x0]
800055c6:	cf 12       	brcc	800055a8 <INTC_register_interrupt+0x58>
800055c8:	80 00       	ld.sh	r0,r0[0x0]
800055ca:	cf 20       	breq	800055ae <INTC_register_interrupt+0x5e>
800055cc:	80 00       	ld.sh	r0,r0[0x0]
800055ce:	cf 2e       	rcall	800053b2 <local_start_pll0+0x6a>

800055d0 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800055d0:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800055d2:	49 18       	lddpc	r8,80005614 <INTC_init_interrupts+0x44>
800055d4:	e3 b8 00 01 	mtsr	0x4,r8
800055d8:	49 0e       	lddpc	lr,80005618 <INTC_init_interrupts+0x48>
800055da:	30 07       	mov	r7,0
800055dc:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800055de:	49 0c       	lddpc	r12,8000561c <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800055e0:	49 05       	lddpc	r5,80005620 <INTC_init_interrupts+0x50>
800055e2:	10 15       	sub	r5,r8
800055e4:	fe 76 08 00 	mov	r6,-63488
800055e8:	c1 08       	rjmp	80005608 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800055ea:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800055ec:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800055ee:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800055f0:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800055f4:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800055f6:	10 3a       	cp.w	r10,r8
800055f8:	fe 9b ff fc 	brhi	800055f0 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800055fc:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80005600:	2f f7       	sub	r7,-1
80005602:	2f 8e       	sub	lr,-8
80005604:	59 37       	cp.w	r7,19
80005606:	c0 50       	breq	80005610 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005608:	7c 08       	ld.w	r8,lr[0x0]
8000560a:	58 08       	cp.w	r8,0
8000560c:	ce f1       	brne	800055ea <INTC_init_interrupts+0x1a>
8000560e:	cf 7b       	rjmp	800055fc <INTC_init_interrupts+0x2c>
80005610:	d8 22       	popm	r4-r7,pc
80005612:	00 00       	add	r0,r0
80005614:	80 00       	ld.sh	r0,r0[0x0]
80005616:	ce 00       	breq	800055d6 <INTC_init_interrupts+0x6>
80005618:	80 00       	ld.sh	r0,r0[0x0]
8000561a:	d9 88       	*unknown*
8000561c:	80 00       	ld.sh	r0,r0[0x0]
8000561e:	55 4c       	stdsp	sp[0x150],r12
80005620:	80 00       	ld.sh	r0,r0[0x0]
80005622:	cf 04       	brge	80005602 <INTC_init_interrupts+0x32>

80005624 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005624:	fe 78 08 00 	mov	r8,-63488
80005628:	e0 69 00 83 	mov	r9,131
8000562c:	f2 0c 01 0c 	sub	r12,r9,r12
80005630:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005634:	f2 ca ff c0 	sub	r10,r9,-64
80005638:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000563c:	58 08       	cp.w	r8,0
8000563e:	c0 21       	brne	80005642 <_get_interrupt_handler+0x1e>
80005640:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80005642:	f0 08 12 00 	clz	r8,r8
80005646:	48 5a       	lddpc	r10,80005658 <_get_interrupt_handler+0x34>
80005648:	f4 09 00 39 	add	r9,r10,r9<<0x3
8000564c:	f0 08 11 1f 	rsub	r8,r8,31
80005650:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005652:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80005656:	5e fc       	retal	r12
80005658:	80 00       	ld.sh	r0,r0[0x0]
8000565a:	d9 88       	*unknown*

8000565c <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
8000565c:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
8000565e:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80005662:	99 a8       	st.w	r12[0x28],r8
}
80005664:	5e fc       	retal	r12
80005666:	d7 03       	nop

80005668 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80005668:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
8000566a:	ec 5b bb 9f 	cp.w	r11,899999
8000566e:	e0 8b 00 04 	brhi	80005676 <pm_enable_osc0_crystal+0xe>
80005672:	30 4b       	mov	r11,4
80005674:	c1 38       	rjmp	8000569a <pm_enable_osc0_crystal+0x32>
80005676:	e0 68 c6 bf 	mov	r8,50879
8000567a:	ea 18 00 2d 	orh	r8,0x2d
8000567e:	10 3b       	cp.w	r11,r8
80005680:	e0 8b 00 04 	brhi	80005688 <pm_enable_osc0_crystal+0x20>
80005684:	30 5b       	mov	r11,5
80005686:	c0 a8       	rjmp	8000569a <pm_enable_osc0_crystal+0x32>
80005688:	e0 68 12 00 	mov	r8,4608
8000568c:	ea 18 00 7a 	orh	r8,0x7a
80005690:	10 3b       	cp.w	r11,r8
80005692:	f9 bb 03 06 	movlo	r11,6
80005696:	f9 bb 02 07 	movhs	r11,7
8000569a:	f0 1f 00 02 	mcall	800056a0 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
8000569e:	d8 02       	popm	pc
800056a0:	80 00       	ld.sh	r0,r0[0x0]
800056a2:	56 5c       	stdsp	sp[0x194],r12

800056a4 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800056a4:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
800056a6:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800056aa:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
800056ac:	78 08       	ld.w	r8,r12[0x0]
800056ae:	a3 a8       	sbr	r8,0x2
800056b0:	99 08       	st.w	r12[0x0],r8
}
800056b2:	5e fc       	retal	r12

800056b4 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800056b4:	79 58       	ld.w	r8,r12[0x54]
800056b6:	e2 18 00 80 	andl	r8,0x80,COH
800056ba:	cf d0       	breq	800056b4 <pm_wait_for_clk0_ready>
}
800056bc:	5e fc       	retal	r12
800056be:	d7 03       	nop

800056c0 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
800056c0:	eb cd 40 80 	pushm	r7,lr
800056c4:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
800056c6:	f0 1f 00 04 	mcall	800056d4 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
800056ca:	0e 9c       	mov	r12,r7
800056cc:	f0 1f 00 03 	mcall	800056d8 <pm_enable_clk0+0x18>
}
800056d0:	e3 cd 80 80 	ldm	sp++,r7,pc
800056d4:	80 00       	ld.sh	r0,r0[0x0]
800056d6:	56 a4       	stdsp	sp[0x1a8],r4
800056d8:	80 00       	ld.sh	r0,r0[0x0]
800056da:	56 b4       	stdsp	sp[0x1ac],r4

800056dc <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
800056dc:	eb cd 40 d0 	pushm	r4,r6-r7,lr
800056e0:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
800056e4:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
800056e6:	09 f7       	ld.ub	r7,r4[0x7]
800056e8:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
800056ec:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
800056f0:	09 b4       	ld.ub	r4,r4[0x3]
800056f2:	08 96       	mov	r6,r4
800056f4:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
800056f8:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
800056fc:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
80005700:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
80005704:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
80005708:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
8000570c:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
80005710:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
80005714:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
80005716:	79 58       	ld.w	r8,r12[0x54]
80005718:	e2 18 00 20 	andl	r8,0x20,COH
8000571c:	cf d0       	breq	80005716 <pm_cksel+0x3a>
}
8000571e:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

80005722 <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
80005722:	eb cd 40 80 	pushm	r7,lr
80005726:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
80005728:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
8000572a:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
8000572e:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
80005732:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
80005736:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
8000573a:	2f 8b       	sub	r11,-8
8000573c:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80005740:	e3 cd 80 80 	ldm	sp++,r7,pc

80005744 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80005744:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
80005746:	2f 8b       	sub	r11,-8
80005748:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
8000574c:	f5 e9 10 19 	or	r9,r10,r9<<0x1
80005750:	f3 e8 10 28 	or	r8,r9,r8<<0x2
80005754:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
80005758:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
8000575c:	d8 02       	popm	pc

8000575e <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
8000575e:	2f 8b       	sub	r11,-8
80005760:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
80005764:	a1 a8       	sbr	r8,0x0
80005766:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
8000576a:	5e fc       	retal	r12

8000576c <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
8000576c:	79 58       	ld.w	r8,r12[0x54]
8000576e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005772:	cf d0       	breq	8000576c <pm_wait_for_pll0_locked>
}
80005774:	5e fc       	retal	r12

80005776 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80005776:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80005778:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
8000577c:	99 08       	st.w	r12[0x0],r8
}
8000577e:	5e fc       	retal	r12

80005780 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80005780:	eb cd 40 c0 	pushm	r6-r7,lr
80005784:	18 97       	mov	r7,r12
80005786:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80005788:	f0 1f 00 06 	mcall	800057a0 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
8000578c:	0c 9b       	mov	r11,r6
8000578e:	0e 9c       	mov	r12,r7
80005790:	f0 1f 00 05 	mcall	800057a4 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80005794:	30 1b       	mov	r11,1
80005796:	0e 9c       	mov	r12,r7
80005798:	f0 1f 00 04 	mcall	800057a8 <pm_switch_to_osc0+0x28>
}
8000579c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800057a0:	80 00       	ld.sh	r0,r0[0x0]
800057a2:	56 68       	stdsp	sp[0x198],r8
800057a4:	80 00       	ld.sh	r0,r0[0x0]
800057a6:	56 c0       	stdsp	sp[0x1b0],r0
800057a8:	80 00       	ld.sh	r0,r0[0x0]
800057aa:	57 76       	stdsp	sp[0x1dc],r6

800057ac <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
800057ac:	f8 c8 00 01 	sub	r8,r12,1
800057b0:	f0 0b 00 0b 	add	r11,r8,r11
800057b4:	f6 0c 0d 0a 	divu	r10,r11,r12
800057b8:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
800057ba:	f4 c8 00 01 	sub	r8,r10,1
800057be:	e0 48 00 fe 	cp.w	r8,254
800057c2:	e0 88 00 03 	brls	800057c8 <getBaudDiv+0x1c>
800057c6:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
800057c8:	5c 8c       	casts.h	r12
}
800057ca:	5e fc       	retal	r12

800057cc <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800057cc:	f7 39 00 0d 	ld.ub	r9,r11[13]
800057d0:	30 18       	mov	r8,1
800057d2:	f0 09 18 00 	cp.b	r9,r8
800057d6:	e0 88 00 04 	brls	800057de <spi_initMaster+0x12>
800057da:	30 2c       	mov	r12,2
800057dc:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800057de:	e0 68 00 80 	mov	r8,128
800057e2:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
800057e4:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
800057e6:	30 19       	mov	r9,1
800057e8:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800057ec:	f7 39 00 0d 	ld.ub	r9,r11[13]
800057f0:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
800057f4:	30 09       	mov	r9,0
800057f6:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800057fa:	30 fa       	mov	r10,15
800057fc:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80005800:	99 18       	st.w	r12[0x4],r8
80005802:	5e f9       	retal	r9

80005804 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80005804:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80005806:	30 18       	mov	r8,1
80005808:	f0 0b 18 00 	cp.b	r11,r8
8000580c:	5f be       	srhi	lr
8000580e:	f0 0a 18 00 	cp.b	r10,r8
80005812:	5f b8       	srhi	r8
80005814:	fd e8 10 08 	or	r8,lr,r8
80005818:	c0 30       	breq	8000581e <spi_selectionMode+0x1a>
8000581a:	30 2c       	mov	r12,2
8000581c:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
8000581e:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80005820:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005824:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80005828:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
8000582c:	99 18       	st.w	r12[0x4],r8
8000582e:	d8 0a       	popm	pc,r12=0

80005830 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80005830:	30 18       	mov	r8,1
80005832:	99 08       	st.w	r12[0x0],r8
}
80005834:	5e fc       	retal	r12

80005836 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80005836:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000583a:	c0 58       	rjmp	80005844 <spi_write+0xe>
		if (!timeout--) {
8000583c:	58 08       	cp.w	r8,0
8000583e:	c0 21       	brne	80005842 <spi_write+0xc>
80005840:	5e ff       	retal	1
80005842:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005844:	78 49       	ld.w	r9,r12[0x10]
80005846:	e2 19 00 02 	andl	r9,0x2,COH
8000584a:	cf 90       	breq	8000583c <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
8000584c:	5c 7b       	castu.h	r11
8000584e:	99 3b       	st.w	r12[0xc],r11
80005850:	5e fd       	retal	0

80005852 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80005852:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005856:	c0 58       	rjmp	80005860 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80005858:	58 08       	cp.w	r8,0
8000585a:	c0 21       	brne	8000585e <spi_read+0xc>
8000585c:	5e ff       	retal	1
8000585e:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005860:	78 49       	ld.w	r9,r12[0x10]
80005862:	e2 19 02 01 	andl	r9,0x201,COH
80005866:	e0 49 02 01 	cp.w	r9,513
8000586a:	cf 71       	brne	80005858 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
8000586c:	78 28       	ld.w	r8,r12[0x8]
8000586e:	b6 08       	st.h	r11[0x0],r8
80005870:	5e fd       	retal	0
80005872:	d7 03       	nop

80005874 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80005874:	eb cd 40 f8 	pushm	r3-r7,lr
80005878:	18 95       	mov	r5,r12
8000587a:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000587c:	f7 36 00 0c 	ld.ub	r6,r11[12]
80005880:	30 38       	mov	r8,3
80005882:	f0 06 18 00 	cp.b	r6,r8
80005886:	e0 8b 00 5e 	brhi	80005942 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
8000588a:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000588e:	30 18       	mov	r8,1
80005890:	f0 04 18 00 	cp.b	r4,r8
80005894:	e0 8b 00 57 	brhi	80005942 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80005898:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000589c:	30 78       	mov	r8,7
8000589e:	f0 03 18 00 	cp.b	r3,r8
800058a2:	e0 88 00 50 	brls	80005942 <spi_setupChipReg+0xce>
800058a6:	31 08       	mov	r8,16
800058a8:	f0 03 18 00 	cp.b	r3,r8
800058ac:	e0 8b 00 4b 	brhi	80005942 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
800058b0:	14 9b       	mov	r11,r10
800058b2:	6e 1c       	ld.w	r12,r7[0x4]
800058b4:	f0 1f 00 26 	mcall	8000594c <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
800058b8:	c4 55       	brlt	80005942 <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
800058ba:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
800058bc:	ec 09 16 01 	lsr	r9,r6,0x1
800058c0:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800058c4:	ec 16 00 01 	eorl	r6,0x1
800058c8:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
800058cc:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800058d0:	20 83       	sub	r3,8
800058d2:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
800058d6:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
800058da:	ef 39 00 09 	ld.ub	r9,r7[9]
800058de:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
800058e2:	ef 39 00 0a 	ld.ub	r9,r7[10]
800058e6:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
800058ea:	0f 89       	ld.ub	r9,r7[0x0]
800058ec:	30 1a       	mov	r10,1
800058ee:	f4 09 18 00 	cp.b	r9,r10
800058f2:	c0 d0       	breq	8000590c <spi_setupChipReg+0x98>
800058f4:	c0 a3       	brcs	80005908 <spi_setupChipReg+0x94>
800058f6:	30 2a       	mov	r10,2
800058f8:	f4 09 18 00 	cp.b	r9,r10
800058fc:	c0 a0       	breq	80005910 <spi_setupChipReg+0x9c>
800058fe:	30 3a       	mov	r10,3
80005900:	f4 09 18 00 	cp.b	r9,r10
80005904:	c1 f1       	brne	80005942 <spi_setupChipReg+0xce>
80005906:	c0 78       	rjmp	80005914 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80005908:	8b c8       	st.w	r5[0x30],r8
		break;
8000590a:	c0 68       	rjmp	80005916 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
8000590c:	8b d8       	st.w	r5[0x34],r8
		break;
8000590e:	c0 48       	rjmp	80005916 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80005910:	8b e8       	st.w	r5[0x38],r8
		break;
80005912:	c0 28       	rjmp	80005916 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80005914:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80005916:	48 f8       	lddpc	r8,80005950 <spi_setupChipReg+0xdc>
80005918:	70 08       	ld.w	r8,r8[0x0]
8000591a:	58 08       	cp.w	r8,0
8000591c:	c1 61       	brne	80005948 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
8000591e:	30 0b       	mov	r11,0
80005920:	30 1c       	mov	r12,1
80005922:	f0 1f 00 0d 	mcall	80005954 <spi_setupChipReg+0xe0>
80005926:	48 b8       	lddpc	r8,80005950 <spi_setupChipReg+0xdc>
80005928:	91 0c       	st.w	r8[0x0],r12
8000592a:	58 0c       	cp.w	r12,0
8000592c:	c0 a0       	breq	80005940 <spi_setupChipReg+0xcc>
8000592e:	30 09       	mov	r9,0
80005930:	12 9a       	mov	r10,r9
80005932:	12 9b       	mov	r11,r9
80005934:	f0 1f 00 09 	mcall	80005958 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80005938:	48 68       	lddpc	r8,80005950 <spi_setupChipReg+0xdc>
8000593a:	70 08       	ld.w	r8,r8[0x0]
8000593c:	58 08       	cp.w	r8,0
8000593e:	c0 51       	brne	80005948 <spi_setupChipReg+0xd4>
80005940:	c0 08       	rjmp	80005940 <spi_setupChipReg+0xcc>
80005942:	30 2c       	mov	r12,2
80005944:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005948:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
8000594c:	80 00       	ld.sh	r0,r0[0x0]
8000594e:	57 ac       	stdsp	sp[0x1e8],r12
80005950:	00 00       	add	r0,r0
80005952:	79 e0       	ld.w	r0,r12[0x78]
80005954:	80 00       	ld.sh	r0,r0[0x0]
80005956:	64 98       	ld.w	r8,r2[0x24]
80005958:	80 00       	ld.sh	r0,r0[0x0]
8000595a:	63 40       	ld.w	r0,r1[0x50]

8000595c <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000595c:	d4 01       	pushm	lr
8000595e:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005962:	c0 58       	rjmp	8000596c <spi_unselectChip+0x10>
		if (!timeout--) {
80005964:	58 08       	cp.w	r8,0
80005966:	c0 21       	brne	8000596a <spi_unselectChip+0xe>
80005968:	da 0a       	popm	pc,r12=1
8000596a:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000596c:	78 49       	ld.w	r9,r12[0x10]
8000596e:	e2 19 02 00 	andl	r9,0x200,COH
80005972:	cf 90       	breq	80005964 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005974:	78 18       	ld.w	r8,r12[0x4]
80005976:	ea 18 00 0f 	orh	r8,0xf
8000597a:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
8000597c:	fc 18 01 00 	movh	r8,0x100
80005980:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80005982:	30 09       	mov	r9,0
80005984:	12 9a       	mov	r10,r9
80005986:	12 9b       	mov	r11,r9
80005988:	48 38       	lddpc	r8,80005994 <spi_unselectChip+0x38>
8000598a:	70 0c       	ld.w	r12,r8[0x0]
8000598c:	f0 1f 00 03 	mcall	80005998 <spi_unselectChip+0x3c>
80005990:	d8 0a       	popm	pc,r12=0
80005992:	00 00       	add	r0,r0
80005994:	00 00       	add	r0,r0
80005996:	79 e0       	ld.w	r0,r12[0x78]
80005998:	80 00       	ld.sh	r0,r0[0x0]
8000599a:	63 40       	ld.w	r0,r1[0x50]

8000599c <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000599c:	eb cd 40 f8 	pushm	r3-r7,lr
800059a0:	18 94       	mov	r4,r12
800059a2:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
800059a4:	49 a6       	lddpc	r6,80005a0c <spi_selectChip+0x70>
800059a6:	30 07       	mov	r7,0
800059a8:	31 45       	mov	r5,20
800059aa:	0e 99       	mov	r9,r7
800059ac:	0a 9a       	mov	r10,r5
800059ae:	0e 9b       	mov	r11,r7
800059b0:	6c 0c       	ld.w	r12,r6[0x0]
800059b2:	f0 1f 00 18 	mcall	80005a10 <spi_selectChip+0x74>
800059b6:	cf a0       	breq	800059aa <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800059b8:	68 18       	ld.w	r8,r4[0x4]
800059ba:	ea 18 00 0f 	orh	r8,0xf
800059be:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
800059c0:	68 18       	ld.w	r8,r4[0x4]
800059c2:	e2 18 00 04 	andl	r8,0x4,COH
800059c6:	c1 10       	breq	800059e8 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
800059c8:	30 e8       	mov	r8,14
800059ca:	f0 03 18 00 	cp.b	r3,r8
800059ce:	e0 8b 00 1c 	brhi	80005a06 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800059d2:	68 19       	ld.w	r9,r4[0x4]
800059d4:	e6 08 15 10 	lsl	r8,r3,0x10
800059d8:	ea 18 ff f0 	orh	r8,0xfff0
800059dc:	e8 18 ff ff 	orl	r8,0xffff
800059e0:	12 68       	and	r8,r9
800059e2:	89 18       	st.w	r4[0x4],r8
800059e4:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800059e8:	30 38       	mov	r8,3
800059ea:	f0 03 18 00 	cp.b	r3,r8
800059ee:	e0 8b 00 0c 	brhi	80005a06 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800059f2:	68 19       	ld.w	r9,r4[0x4]
800059f4:	2f 03       	sub	r3,-16
800059f6:	30 18       	mov	r8,1
800059f8:	f0 03 09 48 	lsl	r8,r8,r3
800059fc:	5c d8       	com	r8
800059fe:	12 68       	and	r8,r9
80005a00:	89 18       	st.w	r4[0x4],r8
80005a02:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005a06:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80005a08:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005a0c:	00 00       	add	r0,r0
80005a0e:	79 e0       	ld.w	r0,r12[0x78]
80005a10:	80 00       	ld.sh	r0,r0[0x0]
80005a12:	61 34       	ld.w	r4,r0[0x4c]

80005a14 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005a14:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005a16:	f6 08 15 04 	lsl	r8,r11,0x4
80005a1a:	14 38       	cp.w	r8,r10
80005a1c:	f9 b8 08 10 	movls	r8,16
80005a20:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005a24:	f0 0b 02 4b 	mul	r11,r8,r11
80005a28:	f6 09 16 01 	lsr	r9,r11,0x1
80005a2c:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80005a30:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005a34:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005a38:	f2 cb 00 01 	sub	r11,r9,1
80005a3c:	e0 4b ff fe 	cp.w	r11,65534
80005a40:	e0 88 00 03 	brls	80005a46 <usart_set_async_baudrate+0x32>
80005a44:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005a46:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005a48:	e8 6e 00 00 	mov	lr,524288
80005a4c:	59 08       	cp.w	r8,16
80005a4e:	fc 08 17 10 	movne	r8,lr
80005a52:	f9 b8 00 00 	moveq	r8,0
80005a56:	e4 1b ff f7 	andh	r11,0xfff7
80005a5a:	e0 1b fe cf 	andl	r11,0xfecf
80005a5e:	16 48       	or	r8,r11
80005a60:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005a62:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005a66:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005a6a:	99 89       	st.w	r12[0x20],r9
80005a6c:	d8 0a       	popm	pc,r12=0

80005a6e <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80005a6e:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005a70:	e2 18 00 02 	andl	r8,0x2,COH
80005a74:	c0 31       	brne	80005a7a <usart_write_char+0xc>
80005a76:	30 2c       	mov	r12,2
80005a78:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005a7a:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80005a7e:	99 7b       	st.w	r12[0x1c],r11
80005a80:	5e fd       	retal	0
80005a82:	d7 03       	nop

80005a84 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005a84:	eb cd 40 e0 	pushm	r5-r7,lr
80005a88:	18 96       	mov	r6,r12
80005a8a:	16 95       	mov	r5,r11
80005a8c:	e0 67 27 0f 	mov	r7,9999
80005a90:	c0 68       	rjmp	80005a9c <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80005a92:	58 07       	cp.w	r7,0
80005a94:	c0 31       	brne	80005a9a <usart_putchar+0x16>
80005a96:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80005a9a:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005a9c:	0a 9b       	mov	r11,r5
80005a9e:	0c 9c       	mov	r12,r6
80005aa0:	f0 1f 00 03 	mcall	80005aac <usart_putchar+0x28>
80005aa4:	cf 71       	brne	80005a92 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80005aa6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005aaa:	00 00       	add	r0,r0
80005aac:	80 00       	ld.sh	r0,r0[0x0]
80005aae:	5a 6e       	cp.w	lr,-26

80005ab0 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80005ab0:	78 58       	ld.w	r8,r12[0x14]
80005ab2:	e2 18 00 e0 	andl	r8,0xe0,COH
80005ab6:	c0 30       	breq	80005abc <usart_read_char+0xc>
80005ab8:	30 4c       	mov	r12,4
80005aba:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80005abc:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80005abe:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005ac2:	c0 31       	brne	80005ac8 <usart_read_char+0x18>
80005ac4:	30 3c       	mov	r12,3
80005ac6:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80005ac8:	78 68       	ld.w	r8,r12[0x18]
80005aca:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80005ace:	97 08       	st.w	r11[0x0],r8
80005ad0:	5e fd       	retal	0
80005ad2:	d7 03       	nop

80005ad4 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80005ad4:	eb cd 40 c0 	pushm	r6-r7,lr
80005ad8:	20 1d       	sub	sp,4
80005ada:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80005adc:	1a 97       	mov	r7,sp
80005ade:	1a 9b       	mov	r11,sp
80005ae0:	0c 9c       	mov	r12,r6
80005ae2:	f0 1f 00 07 	mcall	80005afc <usart_getchar+0x28>
80005ae6:	58 3c       	cp.w	r12,3
80005ae8:	cf b0       	breq	80005ade <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80005aea:	58 4c       	cp.w	r12,4
80005aec:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80005af0:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005af4:	2f fd       	sub	sp,-4
80005af6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005afa:	00 00       	add	r0,r0
80005afc:	80 00       	ld.sh	r0,r0[0x0]
80005afe:	5a b0       	cp.w	r0,-21

80005b00 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80005b00:	eb cd 40 c0 	pushm	r6-r7,lr
80005b04:	18 96       	mov	r6,r12
80005b06:	16 97       	mov	r7,r11
  while (*string != '\0')
80005b08:	17 8b       	ld.ub	r11,r11[0x0]
80005b0a:	58 0b       	cp.w	r11,0
80005b0c:	c0 80       	breq	80005b1c <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80005b0e:	2f f7       	sub	r7,-1
80005b10:	0c 9c       	mov	r12,r6
80005b12:	f0 1f 00 04 	mcall	80005b20 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005b16:	0f 8b       	ld.ub	r11,r7[0x0]
80005b18:	58 0b       	cp.w	r11,0
80005b1a:	cf a1       	brne	80005b0e <usart_write_line+0xe>
80005b1c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005b20:	80 00       	ld.sh	r0,r0[0x0]
80005b22:	5a 84       	cp.w	r4,-24

80005b24 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005b24:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005b28:	e6 18 00 01 	andh	r8,0x1,COH
80005b2c:	c0 71       	brne	80005b3a <usart_reset+0x16>
80005b2e:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005b30:	3f f8       	mov	r8,-1
80005b32:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005b34:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005b36:	d5 03       	csrf	0x10
80005b38:	c0 48       	rjmp	80005b40 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005b3a:	3f f8       	mov	r8,-1
80005b3c:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005b3e:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005b40:	30 08       	mov	r8,0
80005b42:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005b44:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005b46:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005b48:	ea 68 61 0c 	mov	r8,680204
80005b4c:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80005b4e:	5e fc       	retal	r12

80005b50 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005b50:	eb cd 40 e0 	pushm	r5-r7,lr
80005b54:	18 96       	mov	r6,r12
80005b56:	16 97       	mov	r7,r11
80005b58:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005b5a:	f0 1f 00 2f 	mcall	80005c14 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80005b5e:	58 07       	cp.w	r7,0
80005b60:	c5 80       	breq	80005c10 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005b62:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005b64:	30 49       	mov	r9,4
80005b66:	f2 08 18 00 	cp.b	r8,r9
80005b6a:	e0 88 00 53 	brls	80005c10 <usart_init_rs232+0xc0>
80005b6e:	30 99       	mov	r9,9
80005b70:	f2 08 18 00 	cp.b	r8,r9
80005b74:	e0 8b 00 4e 	brhi	80005c10 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005b78:	0f d9       	ld.ub	r9,r7[0x5]
80005b7a:	30 78       	mov	r8,7
80005b7c:	f0 09 18 00 	cp.b	r9,r8
80005b80:	e0 8b 00 48 	brhi	80005c10 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005b84:	8e 39       	ld.sh	r9,r7[0x6]
80005b86:	e0 68 01 01 	mov	r8,257
80005b8a:	f0 09 19 00 	cp.h	r9,r8
80005b8e:	e0 8b 00 41 	brhi	80005c10 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005b92:	ef 39 00 08 	ld.ub	r9,r7[8]
80005b96:	30 38       	mov	r8,3
80005b98:	f0 09 18 00 	cp.b	r9,r8
80005b9c:	e0 8b 00 3a 	brhi	80005c10 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005ba0:	0a 9a       	mov	r10,r5
80005ba2:	6e 0b       	ld.w	r11,r7[0x0]
80005ba4:	0c 9c       	mov	r12,r6
80005ba6:	f0 1f 00 1d 	mcall	80005c18 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005baa:	58 1c       	cp.w	r12,1
80005bac:	c3 20       	breq	80005c10 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80005bae:	0f c8       	ld.ub	r8,r7[0x4]
80005bb0:	30 99       	mov	r9,9
80005bb2:	f2 08 18 00 	cp.b	r8,r9
80005bb6:	c0 51       	brne	80005bc0 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005bb8:	6c 18       	ld.w	r8,r6[0x4]
80005bba:	b1 b8       	sbr	r8,0x11
80005bbc:	8d 18       	st.w	r6[0x4],r8
80005bbe:	c0 68       	rjmp	80005bca <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005bc0:	6c 19       	ld.w	r9,r6[0x4]
80005bc2:	20 58       	sub	r8,5
80005bc4:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005bc8:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005bca:	6c 19       	ld.w	r9,r6[0x4]
80005bcc:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005bd0:	0f d8       	ld.ub	r8,r7[0x5]
80005bd2:	a9 78       	lsl	r8,0x9
80005bd4:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005bd8:	12 48       	or	r8,r9
80005bda:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005bdc:	8e 38       	ld.sh	r8,r7[0x6]
80005bde:	30 29       	mov	r9,2
80005be0:	f2 08 19 00 	cp.h	r8,r9
80005be4:	e0 88 00 09 	brls	80005bf6 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005be8:	6c 18       	ld.w	r8,r6[0x4]
80005bea:	ad b8       	sbr	r8,0xd
80005bec:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005bee:	8e b8       	ld.uh	r8,r7[0x6]
80005bf0:	20 28       	sub	r8,2
80005bf2:	8d a8       	st.w	r6[0x28],r8
80005bf4:	c0 68       	rjmp	80005c00 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005bf6:	6c 19       	ld.w	r9,r6[0x4]
80005bf8:	5c 78       	castu.h	r8
80005bfa:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005bfe:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005c00:	6c 18       	ld.w	r8,r6[0x4]
80005c02:	e0 18 ff f0 	andl	r8,0xfff0
80005c06:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005c08:	35 08       	mov	r8,80
80005c0a:	8d 08       	st.w	r6[0x0],r8
80005c0c:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005c10:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005c14:	80 00       	ld.sh	r0,r0[0x0]
80005c16:	5b 24       	cp.w	r4,-14
80005c18:	80 00       	ld.sh	r0,r0[0x0]
80005c1a:	5a 14       	cp.w	r4,-31

80005c1c <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005c1c:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005c20:	fe c0 8e 20 	sub	r0,pc,-29152

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005c24:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005c28:	d5 53       	csrf	0x15
  cp      r0, r1
80005c2a:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005c2c:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005c30:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80005c32:	c0 62       	brcc	80005c3e <idata_load_loop_end>
  cp      r0, r1
80005c34:	48 92       	lddpc	r2,80005c58 <udata_clear_loop_end+0x4>

80005c36 <idata_load_loop>:
  brlo    idata_load_loop
80005c36:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005c38:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005c3a:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005c3c:	cf d3       	brcs	80005c36 <idata_load_loop>

80005c3e <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005c3e:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
80005c42:	e0 61 79 f0 	mov	r1,31216
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005c46:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005c48:	c0 62       	brcc	80005c54 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005c4a:	30 02       	mov	r2,0
80005c4c:	30 03       	mov	r3,0

80005c4e <udata_clear_loop>:
80005c4e:	a1 22       	st.d	r0++,r2
80005c50:	02 30       	cp.w	r0,r1
80005c52:	cf e3       	brcs	80005c4e <udata_clear_loop>

80005c54 <udata_clear_loop_end>:
80005c54:	fe cf e9 28 	sub	pc,pc,-5848
80005c58:	80 00       	ld.sh	r0,r0[0x0]
80005c5a:	e2 b8       	*unknown*

80005c5c <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005c5c:	f8 c8 ff f8 	sub	r8,r12,-8
80005c60:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005c62:	3f f9       	mov	r9,-1
80005c64:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005c66:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005c68:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005c6a:	30 08       	mov	r8,0
80005c6c:	99 08       	st.w	r12[0x0],r8
}
80005c6e:	5e fc       	retal	r12

80005c70 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005c70:	30 08       	mov	r8,0
80005c72:	99 48       	st.w	r12[0x10],r8
}
80005c74:	5e fc       	retal	r12

80005c76 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005c76:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005c78:	70 19       	ld.w	r9,r8[0x4]
80005c7a:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005c7c:	78 19       	ld.w	r9,r12[0x4]
80005c7e:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005c80:	70 19       	ld.w	r9,r8[0x4]
80005c82:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005c84:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005c86:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005c88:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005c8a:	78 08       	ld.w	r8,r12[0x0]
80005c8c:	2f f8       	sub	r8,-1
80005c8e:	99 08       	st.w	r12[0x0],r8
}
80005c90:	5e fc       	retal	r12

80005c92 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005c92:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005c94:	5b fa       	cp.w	r10,-1
80005c96:	c0 31       	brne	80005c9c <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005c98:	78 48       	ld.w	r8,r12[0x10]
80005c9a:	c0 c8       	rjmp	80005cb2 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005c9c:	f8 c8 ff f8 	sub	r8,r12,-8
80005ca0:	70 19       	ld.w	r9,r8[0x4]
80005ca2:	72 09       	ld.w	r9,r9[0x0]
80005ca4:	12 3a       	cp.w	r10,r9
80005ca6:	c0 63       	brcs	80005cb2 <vListInsert+0x20>
80005ca8:	70 18       	ld.w	r8,r8[0x4]
80005caa:	70 19       	ld.w	r9,r8[0x4]
80005cac:	72 09       	ld.w	r9,r9[0x0]
80005cae:	12 3a       	cp.w	r10,r9
80005cb0:	cf c2       	brcc	80005ca8 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005cb2:	70 19       	ld.w	r9,r8[0x4]
80005cb4:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005cb6:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005cb8:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005cba:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005cbc:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005cbe:	78 08       	ld.w	r8,r12[0x0]
80005cc0:	2f f8       	sub	r8,-1
80005cc2:	99 08       	st.w	r12[0x0],r8
}
80005cc4:	5e fc       	retal	r12

80005cc6 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005cc6:	78 18       	ld.w	r8,r12[0x4]
80005cc8:	78 29       	ld.w	r9,r12[0x8]
80005cca:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005ccc:	78 28       	ld.w	r8,r12[0x8]
80005cce:	78 19       	ld.w	r9,r12[0x4]
80005cd0:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005cd2:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005cd4:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005cd6:	18 39       	cp.w	r9,r12
80005cd8:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005cdc:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005ce0:	30 09       	mov	r9,0
80005ce2:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005ce4:	70 09       	ld.w	r9,r8[0x0]
80005ce6:	20 19       	sub	r9,1
80005ce8:	91 09       	st.w	r8[0x0],r9
}
80005cea:	5e fc       	retal	r12

80005cec <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005cec:	e0 68 08 08 	mov	r8,2056
80005cf0:	ea 18 08 08 	orh	r8,0x808
80005cf4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005cf6:	e0 68 09 09 	mov	r8,2313
80005cfa:	ea 18 09 09 	orh	r8,0x909
80005cfe:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005d00:	e0 68 0a 0a 	mov	r8,2570
80005d04:	ea 18 0a 0a 	orh	r8,0xa0a
80005d08:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005d0a:	e0 68 0b 0b 	mov	r8,2827
80005d0e:	ea 18 0b 0b 	orh	r8,0xb0b
80005d12:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005d14:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005d16:	e0 68 be ef 	mov	r8,48879
80005d1a:	ea 18 de ad 	orh	r8,0xdead
80005d1e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005d20:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005d22:	fc 18 00 40 	movh	r8,0x40
80005d26:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005d28:	e0 68 00 ff 	mov	r8,255
80005d2c:	ea 18 ff 00 	orh	r8,0xff00
80005d30:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005d32:	e0 68 01 01 	mov	r8,257
80005d36:	ea 18 01 01 	orh	r8,0x101
80005d3a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005d3c:	e0 68 02 02 	mov	r8,514
80005d40:	ea 18 02 02 	orh	r8,0x202
80005d44:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005d46:	e0 68 03 03 	mov	r8,771
80005d4a:	ea 18 03 03 	orh	r8,0x303
80005d4e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005d50:	e0 68 04 04 	mov	r8,1028
80005d54:	ea 18 04 04 	orh	r8,0x404
80005d58:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005d5a:	e0 68 05 05 	mov	r8,1285
80005d5e:	ea 18 05 05 	orh	r8,0x505
80005d62:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005d64:	e0 68 06 06 	mov	r8,1542
80005d68:	ea 18 06 06 	orh	r8,0x606
80005d6c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005d6e:	e0 68 07 07 	mov	r8,1799
80005d72:	ea 18 07 07 	orh	r8,0x707
80005d76:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005d78:	30 08       	mov	r8,0
80005d7a:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005d7c:	5e fc       	retal	r12
80005d7e:	d7 03       	nop

80005d80 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005d80:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005d82:	48 38       	lddpc	r8,80005d8c <vPortEnterCritical+0xc>
80005d84:	70 09       	ld.w	r9,r8[0x0]
80005d86:	2f f9       	sub	r9,-1
80005d88:	91 09       	st.w	r8[0x0],r9
}
80005d8a:	5e fc       	retal	r12
80005d8c:	00 00       	add	r0,r0
80005d8e:	05 34       	ld.ub	r4,r2++

80005d90 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005d90:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005d92:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005d94:	30 0a       	mov	r10,0
80005d96:	14 9b       	mov	r11,r10
80005d98:	49 2c       	lddpc	r12,80005de0 <xPortStartScheduler+0x50>
80005d9a:	f0 1f 00 13 	mcall	80005de4 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005d9e:	e0 68 5d c0 	mov	r8,24000
80005da2:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005da6:	30 08       	mov	r8,0
80005da8:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005dac:	e0 68 0c f8 	mov	r8,3320
80005db0:	ea 18 00 00 	orh	r8,0x0
80005db4:	70 00       	ld.w	r0,r8[0x0]
80005db6:	60 0d       	ld.w	sp,r0[0x0]
80005db8:	1b 00       	ld.w	r0,sp++
80005dba:	e0 68 05 34 	mov	r8,1332
80005dbe:	ea 18 00 00 	orh	r8,0x0
80005dc2:	91 00       	st.w	r8[0x0],r0
80005dc4:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005dc8:	2f ed       	sub	sp,-8
80005dca:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005dce:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005dd2:	e3 b0 00 00 	mtsr	0x0,r0
80005dd6:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005dda:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005dde:	d8 0a       	popm	pc,r12=0
80005de0:	80 00       	ld.sh	r0,r0[0x0]
80005de2:	5e ac       	retle	r12
80005de4:	80 00       	ld.sh	r0,r0[0x0]
80005de6:	55 50       	stdsp	sp[0x154],r0

80005de8 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005de8:	20 6d       	sub	sp,24
80005dea:	eb cd 00 ff 	pushm	r0-r7
80005dee:	fa c7 ff c0 	sub	r7,sp,-64
80005df2:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005df6:	ef 40 ff e0 	st.w	r7[-32],r0
80005dfa:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005dfe:	ef 40 ff e4 	st.w	r7[-28],r0
80005e02:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005e06:	e0 68 05 34 	mov	r8,1332
80005e0a:	ea 18 00 00 	orh	r8,0x0
80005e0e:	70 00       	ld.w	r0,r8[0x0]
80005e10:	1a d0       	st.w	--sp,r0
80005e12:	f0 1f 00 1a 	mcall	80005e78 <LABEL_RET_SCALL_263+0x14>
80005e16:	e0 68 0c f8 	mov	r8,3320
80005e1a:	ea 18 00 00 	orh	r8,0x0
80005e1e:	70 00       	ld.w	r0,r8[0x0]
80005e20:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005e22:	f0 1f 00 17 	mcall	80005e7c <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005e26:	e0 68 0c f8 	mov	r8,3320
80005e2a:	ea 18 00 00 	orh	r8,0x0
80005e2e:	70 00       	ld.w	r0,r8[0x0]
80005e30:	60 0d       	ld.w	sp,r0[0x0]
80005e32:	1b 00       	ld.w	r0,sp++
80005e34:	e0 68 05 34 	mov	r8,1332
80005e38:	ea 18 00 00 	orh	r8,0x0
80005e3c:	91 00       	st.w	r8[0x0],r0
80005e3e:	fa c7 ff d8 	sub	r7,sp,-40
80005e42:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005e46:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005e4a:	e0 61 05 34 	mov	r1,1332
80005e4e:	ea 11 00 00 	orh	r1,0x0
80005e52:	62 02       	ld.w	r2,r1[0x0]
80005e54:	58 02       	cp.w	r2,0
80005e56:	c0 70       	breq	80005e64 <LABEL_RET_SCALL_263>
80005e58:	e4 c2 00 01 	sub	r2,r2,1
80005e5c:	83 02       	st.w	r1[0x0],r2
80005e5e:	58 02       	cp.w	r2,0
80005e60:	c0 21       	brne	80005e64 <LABEL_RET_SCALL_263>
80005e62:	b1 c0       	cbr	r0,0x10

80005e64 <LABEL_RET_SCALL_263>:
80005e64:	ef 40 ff f8 	st.w	r7[-8],r0
80005e68:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005e6c:	ef 40 ff fc 	st.w	r7[-4],r0
80005e70:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005e74:	2f ad       	sub	sp,-24
80005e76:	d6 13       	rets
80005e78:	80 00       	ld.sh	r0,r0[0x0]
80005e7a:	5d 80       	*unknown*
80005e7c:	80 00       	ld.sh	r0,r0[0x0]
80005e7e:	65 1c       	ld.w	r12,r2[0x44]

80005e80 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005e80:	e1 b8 00 43 	mfsr	r8,0x10c
80005e84:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005e88:	5e fc       	retal	r12
80005e8a:	d7 03       	nop

80005e8c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005e8c:	48 78       	lddpc	r8,80005ea8 <vPortExitCritical+0x1c>
80005e8e:	70 08       	ld.w	r8,r8[0x0]
80005e90:	58 08       	cp.w	r8,0
80005e92:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005e94:	48 58       	lddpc	r8,80005ea8 <vPortExitCritical+0x1c>
80005e96:	70 09       	ld.w	r9,r8[0x0]
80005e98:	20 19       	sub	r9,1
80005e9a:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005e9c:	70 08       	ld.w	r8,r8[0x0]
80005e9e:	58 08       	cp.w	r8,0
80005ea0:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005ea2:	d5 03       	csrf	0x10
80005ea4:	5e fc       	retal	r12
80005ea6:	00 00       	add	r0,r0
80005ea8:	00 00       	add	r0,r0
80005eaa:	05 34       	ld.ub	r4,r2++

80005eac <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005eac:	eb cd 00 ff 	pushm	r0-r7
80005eb0:	e0 68 05 34 	mov	r8,1332
80005eb4:	ea 18 00 00 	orh	r8,0x0
80005eb8:	70 00       	ld.w	r0,r8[0x0]
80005eba:	1a d0       	st.w	--sp,r0
80005ebc:	7a 90       	ld.w	r0,sp[0x24]
80005ebe:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005ec2:	58 10       	cp.w	r0,1
80005ec4:	e0 8b 00 08 	brhi	80005ed4 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005ec8:	e0 68 0c f8 	mov	r8,3320
80005ecc:	ea 18 00 00 	orh	r8,0x0
80005ed0:	70 00       	ld.w	r0,r8[0x0]
80005ed2:	81 0d       	st.w	r0[0x0],sp

80005ed4 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005ed4:	f0 1f 00 12 	mcall	80005f1c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005ed8:	f0 1f 00 12 	mcall	80005f20 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005edc:	f0 1f 00 12 	mcall	80005f24 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005ee0:	f0 1f 00 12 	mcall	80005f28 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005ee4:	7a 90       	ld.w	r0,sp[0x24]
80005ee6:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005eea:	58 10       	cp.w	r0,1
80005eec:	e0 8b 00 0e 	brhi	80005f08 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005ef0:	f0 1f 00 0c 	mcall	80005f20 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005ef4:	f0 1f 00 0e 	mcall	80005f2c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005ef8:	f0 1f 00 0c 	mcall	80005f28 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005efc:	e0 68 0c f8 	mov	r8,3320
80005f00:	ea 18 00 00 	orh	r8,0x0
80005f04:	70 00       	ld.w	r0,r8[0x0]
80005f06:	60 0d       	ld.w	sp,r0[0x0]

80005f08 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005f08:	1b 00       	ld.w	r0,sp++
80005f0a:	e0 68 05 34 	mov	r8,1332
80005f0e:	ea 18 00 00 	orh	r8,0x0
80005f12:	91 00       	st.w	r8[0x0],r0
80005f14:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005f18:	d6 03       	rete
80005f1a:	00 00       	add	r0,r0
80005f1c:	80 00       	ld.sh	r0,r0[0x0]
80005f1e:	5e 80       	retls	r0
80005f20:	80 00       	ld.sh	r0,r0[0x0]
80005f22:	5d 80       	*unknown*
80005f24:	80 00       	ld.sh	r0,r0[0x0]
80005f26:	67 20       	ld.w	r0,r3[0x48]
80005f28:	80 00       	ld.sh	r0,r0[0x0]
80005f2a:	5e 8c       	retls	r12
80005f2c:	80 00       	ld.sh	r0,r0[0x0]
80005f2e:	65 1c       	ld.w	r12,r2[0x44]

80005f30 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005f30:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005f32:	f0 1f 00 02 	mcall	80005f38 <__malloc_lock+0x8>
}
80005f36:	d8 02       	popm	pc
80005f38:	80 00       	ld.sh	r0,r0[0x0]
80005f3a:	65 0c       	ld.w	r12,r2[0x40]

80005f3c <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005f3c:	d4 01       	pushm	lr
	xTaskResumeAll();
80005f3e:	f0 1f 00 02 	mcall	80005f44 <__malloc_unlock+0x8>
}
80005f42:	d8 02       	popm	pc
80005f44:	80 00       	ld.sh	r0,r0[0x0]
80005f46:	68 c8       	ld.w	r8,r4[0x30]

80005f48 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005f48:	d4 21       	pushm	r4-r7,lr
80005f4a:	16 95       	mov	r5,r11
80005f4c:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005f4e:	58 0c       	cp.w	r12,0
80005f50:	c0 30       	breq	80005f56 <_read+0xe>
80005f52:	3f f7       	mov	r7,-1
80005f54:	c1 48       	rjmp	80005f7c <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005f56:	58 0a       	cp.w	r10,0
80005f58:	e0 89 00 04 	brgt	80005f60 <_read+0x18>
80005f5c:	30 07       	mov	r7,0
80005f5e:	c0 f8       	rjmp	80005f7c <_read+0x34>
80005f60:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005f62:	48 84       	lddpc	r4,80005f80 <_read+0x38>
80005f64:	68 0c       	ld.w	r12,r4[0x0]
80005f66:	f0 1f 00 08 	mcall	80005f84 <_read+0x3c>
    if (c < 0)
80005f6a:	c0 95       	brlt	80005f7c <_read+0x34>
      break;

    *ptr++ = c;
80005f6c:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005f70:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005f72:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005f76:	58 08       	cp.w	r8,0
80005f78:	fe 99 ff f6 	brgt	80005f64 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005f7c:	0e 9c       	mov	r12,r7
80005f7e:	d8 22       	popm	r4-r7,pc
80005f80:	00 00       	add	r0,r0
80005f82:	79 e4       	ld.w	r4,r12[0x78]
80005f84:	80 00       	ld.sh	r0,r0[0x0]
80005f86:	5a d4       	cp.w	r4,-19

80005f88 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005f88:	d4 21       	pushm	r4-r7,lr
80005f8a:	16 95       	mov	r5,r11
80005f8c:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005f8e:	20 1c       	sub	r12,1
80005f90:	58 2c       	cp.w	r12,2
80005f92:	e0 8b 00 12 	brhi	80005fb6 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005f96:	58 0a       	cp.w	r10,0
80005f98:	c0 31       	brne	80005f9e <_write+0x16>
80005f9a:	30 07       	mov	r7,0
80005f9c:	c0 e8       	rjmp	80005fb8 <_write+0x30>
80005f9e:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005fa0:	48 74       	lddpc	r4,80005fbc <_write+0x34>
80005fa2:	68 0c       	ld.w	r12,r4[0x0]
80005fa4:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005fa8:	f0 1f 00 06 	mcall	80005fc0 <_write+0x38>
80005fac:	c0 55       	brlt	80005fb6 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005fae:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005fb0:	0e 36       	cp.w	r6,r7
80005fb2:	cf 81       	brne	80005fa2 <_write+0x1a>
80005fb4:	c0 28       	rjmp	80005fb8 <_write+0x30>
80005fb6:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005fb8:	0e 9c       	mov	r12,r7
80005fba:	d8 22       	popm	r4-r7,pc
80005fbc:	00 00       	add	r0,r0
80005fbe:	79 e4       	ld.w	r4,r12[0x78]
80005fc0:	80 00       	ld.sh	r0,r0[0x0]
80005fc2:	5a 84       	cp.w	r4,-24

80005fc4 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005fc4:	eb cd 40 80 	pushm	r7,lr
80005fc8:	18 97       	mov	r7,r12
	if( pv )
80005fca:	58 0c       	cp.w	r12,0
80005fcc:	c0 80       	breq	80005fdc <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005fce:	f0 1f 00 05 	mcall	80005fe0 <vPortFree+0x1c>
		{
			free( pv );
80005fd2:	0e 9c       	mov	r12,r7
80005fd4:	f0 1f 00 04 	mcall	80005fe4 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005fd8:	f0 1f 00 04 	mcall	80005fe8 <vPortFree+0x24>
80005fdc:	e3 cd 80 80 	ldm	sp++,r7,pc
80005fe0:	80 00       	ld.sh	r0,r0[0x0]
80005fe2:	65 0c       	ld.w	r12,r2[0x40]
80005fe4:	80 00       	ld.sh	r0,r0[0x0]
80005fe6:	73 9c       	ld.w	r12,r9[0x64]
80005fe8:	80 00       	ld.sh	r0,r0[0x0]
80005fea:	68 c8       	ld.w	r8,r4[0x30]

80005fec <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005fec:	eb cd 40 80 	pushm	r7,lr
80005ff0:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005ff2:	f0 1f 00 06 	mcall	80006008 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005ff6:	0e 9c       	mov	r12,r7
80005ff8:	f0 1f 00 05 	mcall	8000600c <pvPortMalloc+0x20>
80005ffc:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005ffe:	f0 1f 00 05 	mcall	80006010 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80006002:	0e 9c       	mov	r12,r7
80006004:	e3 cd 80 80 	ldm	sp++,r7,pc
80006008:	80 00       	ld.sh	r0,r0[0x0]
8000600a:	65 0c       	ld.w	r12,r2[0x40]
8000600c:	80 00       	ld.sh	r0,r0[0x0]
8000600e:	73 ac       	ld.w	r12,r9[0x68]
80006010:	80 00       	ld.sh	r0,r0[0x0]
80006012:	68 c8       	ld.w	r8,r4[0x30]

80006014 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80006014:	d4 01       	pushm	lr
80006016:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80006018:	78 09       	ld.w	r9,r12[0x0]
8000601a:	58 09       	cp.w	r9,0
8000601c:	c1 10       	breq	8000603e <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
8000601e:	78 3a       	ld.w	r10,r12[0xc]
80006020:	79 09       	ld.w	r9,r12[0x40]
80006022:	f4 09 00 09 	add	r9,r10,r9
80006026:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80006028:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
8000602a:	14 39       	cp.w	r9,r10
8000602c:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80006030:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80006034:	79 0a       	ld.w	r10,r12[0x40]
80006036:	78 3b       	ld.w	r11,r12[0xc]
80006038:	10 9c       	mov	r12,r8
8000603a:	f0 1f 00 02 	mcall	80006040 <prvCopyDataFromQueue+0x2c>
8000603e:	d8 02       	popm	pc
80006040:	80 00       	ld.sh	r0,r0[0x0]
80006042:	77 f4       	ld.w	r4,r11[0x7c]

80006044 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80006044:	eb cd 40 c0 	pushm	r6-r7,lr
80006048:	18 97       	mov	r7,r12
8000604a:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
8000604c:	78 e8       	ld.w	r8,r12[0x38]
8000604e:	58 08       	cp.w	r8,0
80006050:	c0 31       	brne	80006056 <xQueueReceiveFromISR+0x12>
80006052:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80006056:	f0 1f 00 0e 	mcall	8000608c <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
8000605a:	6e e8       	ld.w	r8,r7[0x38]
8000605c:	20 18       	sub	r8,1
8000605e:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80006060:	6f 18       	ld.w	r8,r7[0x44]
80006062:	5b f8       	cp.w	r8,-1
80006064:	c0 d1       	brne	8000607e <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006066:	6e 48       	ld.w	r8,r7[0x10]
80006068:	58 08       	cp.w	r8,0
8000606a:	c0 f0       	breq	80006088 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000606c:	ee cc ff f0 	sub	r12,r7,-16
80006070:	f0 1f 00 08 	mcall	80006090 <xQueueReceiveFromISR+0x4c>
80006074:	c0 a0       	breq	80006088 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80006076:	30 1c       	mov	r12,1
80006078:	8d 0c       	st.w	r6[0x0],r12
8000607a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
8000607e:	2f f8       	sub	r8,-1
80006080:	ef 48 00 44 	st.w	r7[68],r8
80006084:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006088:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000608c:	80 00       	ld.sh	r0,r0[0x0]
8000608e:	60 14       	ld.w	r4,r0[0x4]
80006090:	80 00       	ld.sh	r0,r0[0x0]
80006092:	66 a4       	ld.w	r4,r3[0x28]

80006094 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80006094:	eb cd 40 c0 	pushm	r6-r7,lr
80006098:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
8000609a:	f0 1f 00 23 	mcall	80006124 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000609e:	6f 28       	ld.w	r8,r7[0x48]
800060a0:	58 08       	cp.w	r8,0
800060a2:	e0 8a 00 18 	brle	800060d2 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800060a6:	6e 98       	ld.w	r8,r7[0x24]
800060a8:	58 08       	cp.w	r8,0
800060aa:	c1 40       	breq	800060d2 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800060ac:	ee c6 ff dc 	sub	r6,r7,-36
800060b0:	c0 48       	rjmp	800060b8 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800060b2:	6e 98       	ld.w	r8,r7[0x24]
800060b4:	58 08       	cp.w	r8,0
800060b6:	c0 e0       	breq	800060d2 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800060b8:	0c 9c       	mov	r12,r6
800060ba:	f0 1f 00 1c 	mcall	80006128 <prvUnlockQueue+0x94>
800060be:	c0 30       	breq	800060c4 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
800060c0:	f0 1f 00 1b 	mcall	8000612c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
800060c4:	6f 28       	ld.w	r8,r7[0x48]
800060c6:	20 18       	sub	r8,1
800060c8:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800060cc:	58 08       	cp.w	r8,0
800060ce:	fe 99 ff f2 	brgt	800060b2 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800060d2:	3f f8       	mov	r8,-1
800060d4:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
800060d8:	f0 1f 00 16 	mcall	80006130 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800060dc:	f0 1f 00 12 	mcall	80006124 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800060e0:	6f 18       	ld.w	r8,r7[0x44]
800060e2:	58 08       	cp.w	r8,0
800060e4:	e0 8a 00 18 	brle	80006114 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800060e8:	6e 48       	ld.w	r8,r7[0x10]
800060ea:	58 08       	cp.w	r8,0
800060ec:	c1 40       	breq	80006114 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800060ee:	ee c6 ff f0 	sub	r6,r7,-16
800060f2:	c0 48       	rjmp	800060fa <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800060f4:	6e 48       	ld.w	r8,r7[0x10]
800060f6:	58 08       	cp.w	r8,0
800060f8:	c0 e0       	breq	80006114 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800060fa:	0c 9c       	mov	r12,r6
800060fc:	f0 1f 00 0b 	mcall	80006128 <prvUnlockQueue+0x94>
80006100:	c0 30       	breq	80006106 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80006102:	f0 1f 00 0b 	mcall	8000612c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80006106:	6f 18       	ld.w	r8,r7[0x44]
80006108:	20 18       	sub	r8,1
8000610a:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000610e:	58 08       	cp.w	r8,0
80006110:	fe 99 ff f2 	brgt	800060f4 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80006114:	3f f8       	mov	r8,-1
80006116:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
8000611a:	f0 1f 00 06 	mcall	80006130 <prvUnlockQueue+0x9c>
}
8000611e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006122:	00 00       	add	r0,r0
80006124:	80 00       	ld.sh	r0,r0[0x0]
80006126:	5d 80       	*unknown*
80006128:	80 00       	ld.sh	r0,r0[0x0]
8000612a:	66 a4       	ld.w	r4,r3[0x28]
8000612c:	80 00       	ld.sh	r0,r0[0x0]
8000612e:	65 b0       	ld.w	r0,r2[0x6c]
80006130:	80 00       	ld.sh	r0,r0[0x0]
80006132:	5e 8c       	retls	r12

80006134 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80006134:	d4 31       	pushm	r0-r7,lr
80006136:	20 5d       	sub	sp,20
80006138:	18 97       	mov	r7,r12
8000613a:	50 0b       	stdsp	sp[0x0],r11
8000613c:	50 2a       	stdsp	sp[0x8],r10
8000613e:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006140:	f8 c2 ff dc 	sub	r2,r12,-36
80006144:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006146:	fa c4 ff f4 	sub	r4,sp,-12
8000614a:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
8000614c:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000614e:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80006152:	f0 1f 00 3e 	mcall	80006248 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80006156:	6e e8       	ld.w	r8,r7[0x38]
80006158:	58 08       	cp.w	r8,0
8000615a:	c2 a0       	breq	800061ae <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
8000615c:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
8000615e:	40 0b       	lddsp	r11,sp[0x0]
80006160:	0e 9c       	mov	r12,r7
80006162:	f0 1f 00 3b 	mcall	8000624c <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80006166:	40 18       	lddsp	r8,sp[0x4]
80006168:	58 08       	cp.w	r8,0
8000616a:	c1 51       	brne	80006194 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
8000616c:	6e e8       	ld.w	r8,r7[0x38]
8000616e:	20 18       	sub	r8,1
80006170:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006172:	6e 08       	ld.w	r8,r7[0x0]
80006174:	58 08       	cp.w	r8,0
80006176:	c0 41       	brne	8000617e <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80006178:	f0 1f 00 36 	mcall	80006250 <xQueueGenericReceive+0x11c>
8000617c:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000617e:	6e 48       	ld.w	r8,r7[0x10]
80006180:	58 08       	cp.w	r8,0
80006182:	c1 20       	breq	800061a6 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80006184:	ee cc ff f0 	sub	r12,r7,-16
80006188:	f0 1f 00 33 	mcall	80006254 <xQueueGenericReceive+0x120>
8000618c:	58 1c       	cp.w	r12,1
8000618e:	c0 c1       	brne	800061a6 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80006190:	d7 33       	scall
80006192:	c0 a8       	rjmp	800061a6 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80006194:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006196:	6e 98       	ld.w	r8,r7[0x24]
80006198:	58 08       	cp.w	r8,0
8000619a:	c0 60       	breq	800061a6 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000619c:	04 9c       	mov	r12,r2
8000619e:	f0 1f 00 2e 	mcall	80006254 <xQueueGenericReceive+0x120>
800061a2:	c0 20       	breq	800061a6 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
800061a4:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
800061a6:	f0 1f 00 2d 	mcall	80006258 <xQueueGenericReceive+0x124>
800061aa:	30 1c       	mov	r12,1
				return pdPASS;
800061ac:	c4 c8       	rjmp	80006244 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800061ae:	40 28       	lddsp	r8,sp[0x8]
800061b0:	58 08       	cp.w	r8,0
800061b2:	c0 51       	brne	800061bc <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800061b4:	f0 1f 00 29 	mcall	80006258 <xQueueGenericReceive+0x124>
800061b8:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
800061ba:	c4 58       	rjmp	80006244 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
800061bc:	58 05       	cp.w	r5,0
800061be:	c0 51       	brne	800061c8 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800061c0:	08 9c       	mov	r12,r4
800061c2:	f0 1f 00 27 	mcall	8000625c <xQueueGenericReceive+0x128>
800061c6:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800061c8:	f0 1f 00 24 	mcall	80006258 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800061cc:	f0 1f 00 25 	mcall	80006260 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
800061d0:	f0 1f 00 1e 	mcall	80006248 <xQueueGenericReceive+0x114>
800061d4:	6f 18       	ld.w	r8,r7[0x44]
800061d6:	5b f8       	cp.w	r8,-1
800061d8:	ef f1 0a 11 	st.weq	r7[0x44],r1
800061dc:	6f 28       	ld.w	r8,r7[0x48]
800061de:	5b f8       	cp.w	r8,-1
800061e0:	ef f1 0a 12 	st.weq	r7[0x48],r1
800061e4:	f0 1f 00 1d 	mcall	80006258 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800061e8:	06 9b       	mov	r11,r3
800061ea:	08 9c       	mov	r12,r4
800061ec:	f0 1f 00 1e 	mcall	80006264 <xQueueGenericReceive+0x130>
800061f0:	c2 41       	brne	80006238 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800061f2:	f0 1f 00 16 	mcall	80006248 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
800061f6:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
800061f8:	f0 1f 00 18 	mcall	80006258 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
800061fc:	58 06       	cp.w	r6,0
800061fe:	c1 71       	brne	8000622c <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006200:	6e 08       	ld.w	r8,r7[0x0]
80006202:	58 08       	cp.w	r8,0
80006204:	c0 81       	brne	80006214 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80006206:	f0 1f 00 11 	mcall	80006248 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
8000620a:	6e 1c       	ld.w	r12,r7[0x4]
8000620c:	f0 1f 00 17 	mcall	80006268 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80006210:	f0 1f 00 12 	mcall	80006258 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006214:	40 2b       	lddsp	r11,sp[0x8]
80006216:	04 9c       	mov	r12,r2
80006218:	f0 1f 00 15 	mcall	8000626c <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
8000621c:	0e 9c       	mov	r12,r7
8000621e:	f0 1f 00 15 	mcall	80006270 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80006222:	f0 1f 00 15 	mcall	80006274 <xQueueGenericReceive+0x140>
80006226:	c9 61       	brne	80006152 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80006228:	d7 33       	scall
8000622a:	c9 4b       	rjmp	80006152 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000622c:	0e 9c       	mov	r12,r7
8000622e:	f0 1f 00 11 	mcall	80006270 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80006232:	f0 1f 00 11 	mcall	80006274 <xQueueGenericReceive+0x140>
80006236:	c8 eb       	rjmp	80006152 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80006238:	0e 9c       	mov	r12,r7
8000623a:	f0 1f 00 0e 	mcall	80006270 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000623e:	f0 1f 00 0e 	mcall	80006274 <xQueueGenericReceive+0x140>
80006242:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80006244:	2f bd       	sub	sp,-20
80006246:	d8 32       	popm	r0-r7,pc
80006248:	80 00       	ld.sh	r0,r0[0x0]
8000624a:	5d 80       	*unknown*
8000624c:	80 00       	ld.sh	r0,r0[0x0]
8000624e:	60 14       	ld.w	r4,r0[0x4]
80006250:	80 00       	ld.sh	r0,r0[0x0]
80006252:	65 bc       	ld.w	r12,r2[0x6c]
80006254:	80 00       	ld.sh	r0,r0[0x0]
80006256:	66 a4       	ld.w	r4,r3[0x28]
80006258:	80 00       	ld.sh	r0,r0[0x0]
8000625a:	5e 8c       	retls	r12
8000625c:	80 00       	ld.sh	r0,r0[0x0]
8000625e:	65 98       	ld.w	r8,r2[0x64]
80006260:	80 00       	ld.sh	r0,r0[0x0]
80006262:	65 0c       	ld.w	r12,r2[0x40]
80006264:	80 00       	ld.sh	r0,r0[0x0]
80006266:	68 34       	ld.w	r4,r4[0xc]
80006268:	80 00       	ld.sh	r0,r0[0x0]
8000626a:	66 20       	ld.w	r0,r3[0x8]
8000626c:	80 00       	ld.sh	r0,r0[0x0]
8000626e:	6a d4       	ld.w	r4,r5[0x34]
80006270:	80 00       	ld.sh	r0,r0[0x0]
80006272:	60 94       	ld.w	r4,r0[0x24]
80006274:	80 00       	ld.sh	r0,r0[0x0]
80006276:	68 c8       	ld.w	r8,r4[0x30]

80006278 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80006278:	eb cd 40 80 	pushm	r7,lr
8000627c:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000627e:	79 08       	ld.w	r8,r12[0x40]
80006280:	58 08       	cp.w	r8,0
80006282:	c0 a1       	brne	80006296 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006284:	78 08       	ld.w	r8,r12[0x0]
80006286:	58 08       	cp.w	r8,0
80006288:	c2 b1       	brne	800062de <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
8000628a:	78 1c       	ld.w	r12,r12[0x4]
8000628c:	f0 1f 00 17 	mcall	800062e8 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80006290:	30 08       	mov	r8,0
80006292:	8f 18       	st.w	r7[0x4],r8
80006294:	c2 58       	rjmp	800062de <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80006296:	58 0a       	cp.w	r10,0
80006298:	c1 01       	brne	800062b8 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000629a:	10 9a       	mov	r10,r8
8000629c:	78 2c       	ld.w	r12,r12[0x8]
8000629e:	f0 1f 00 14 	mcall	800062ec <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
800062a2:	6e 29       	ld.w	r9,r7[0x8]
800062a4:	6f 08       	ld.w	r8,r7[0x40]
800062a6:	f2 08 00 08 	add	r8,r9,r8
800062aa:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
800062ac:	6e 19       	ld.w	r9,r7[0x4]
800062ae:	12 38       	cp.w	r8,r9
800062b0:	c1 73       	brcs	800062de <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
800062b2:	6e 08       	ld.w	r8,r7[0x0]
800062b4:	8f 28       	st.w	r7[0x8],r8
800062b6:	c1 48       	rjmp	800062de <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800062b8:	10 9a       	mov	r10,r8
800062ba:	78 3c       	ld.w	r12,r12[0xc]
800062bc:	f0 1f 00 0c 	mcall	800062ec <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
800062c0:	6f 08       	ld.w	r8,r7[0x40]
800062c2:	6e 39       	ld.w	r9,r7[0xc]
800062c4:	f2 08 01 08 	sub	r8,r9,r8
800062c8:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800062ca:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800062cc:	12 38       	cp.w	r8,r9
800062ce:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
800062d2:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
800062d6:	f3 d8 e3 19 	subcs	r9,r9,r8
800062da:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800062de:	6e e8       	ld.w	r8,r7[0x38]
800062e0:	2f f8       	sub	r8,-1
800062e2:	8f e8       	st.w	r7[0x38],r8
}
800062e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800062e8:	80 00       	ld.sh	r0,r0[0x0]
800062ea:	65 c8       	ld.w	r8,r2[0x70]
800062ec:	80 00       	ld.sh	r0,r0[0x0]
800062ee:	77 f4       	ld.w	r4,r11[0x7c]

800062f0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
800062f0:	eb cd 40 c0 	pushm	r6-r7,lr
800062f4:	18 97       	mov	r7,r12
800062f6:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800062f8:	78 ec       	ld.w	r12,r12[0x38]
800062fa:	6e f8       	ld.w	r8,r7[0x3c]
800062fc:	10 3c       	cp.w	r12,r8
800062fe:	c0 33       	brcs	80006304 <xQueueGenericSendFromISR+0x14>
80006300:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006304:	12 9a       	mov	r10,r9
80006306:	0e 9c       	mov	r12,r7
80006308:	f0 1f 00 0c 	mcall	80006338 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
8000630c:	6f 28       	ld.w	r8,r7[0x48]
8000630e:	5b f8       	cp.w	r8,-1
80006310:	c0 d1       	brne	8000632a <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006312:	6e 98       	ld.w	r8,r7[0x24]
80006314:	58 08       	cp.w	r8,0
80006316:	c0 f0       	breq	80006334 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006318:	ee cc ff dc 	sub	r12,r7,-36
8000631c:	f0 1f 00 08 	mcall	8000633c <xQueueGenericSendFromISR+0x4c>
80006320:	c0 a0       	breq	80006334 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80006322:	30 1c       	mov	r12,1
80006324:	8d 0c       	st.w	r6[0x0],r12
80006326:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
8000632a:	2f f8       	sub	r8,-1
8000632c:	ef 48 00 48 	st.w	r7[72],r8
80006330:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006334:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006338:	80 00       	ld.sh	r0,r0[0x0]
8000633a:	62 78       	ld.w	r8,r1[0x1c]
8000633c:	80 00       	ld.sh	r0,r0[0x0]
8000633e:	66 a4       	ld.w	r4,r3[0x28]

80006340 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80006340:	d4 31       	pushm	r0-r7,lr
80006342:	20 5d       	sub	sp,20
80006344:	18 97       	mov	r7,r12
80006346:	50 0b       	stdsp	sp[0x0],r11
80006348:	50 2a       	stdsp	sp[0x8],r10
8000634a:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000634c:	f8 c0 ff f0 	sub	r0,r12,-16
80006350:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006352:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80006356:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006358:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
8000635c:	f0 1f 00 2f 	mcall	80006418 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006360:	6e e9       	ld.w	r9,r7[0x38]
80006362:	6e f8       	ld.w	r8,r7[0x3c]
80006364:	10 39       	cp.w	r9,r8
80006366:	c1 42       	brcc	8000638e <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006368:	40 1a       	lddsp	r10,sp[0x4]
8000636a:	40 0b       	lddsp	r11,sp[0x0]
8000636c:	0e 9c       	mov	r12,r7
8000636e:	f0 1f 00 2c 	mcall	8000641c <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006372:	6e 98       	ld.w	r8,r7[0x24]
80006374:	58 08       	cp.w	r8,0
80006376:	c0 80       	breq	80006386 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80006378:	ee cc ff dc 	sub	r12,r7,-36
8000637c:	f0 1f 00 29 	mcall	80006420 <xQueueGenericSend+0xe0>
80006380:	58 1c       	cp.w	r12,1
80006382:	c0 21       	brne	80006386 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80006384:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80006386:	f0 1f 00 28 	mcall	80006424 <xQueueGenericSend+0xe4>
8000638a:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
8000638c:	c4 38       	rjmp	80006412 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000638e:	40 28       	lddsp	r8,sp[0x8]
80006390:	58 08       	cp.w	r8,0
80006392:	c0 51       	brne	8000639c <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006394:	f0 1f 00 24 	mcall	80006424 <xQueueGenericSend+0xe4>
80006398:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
8000639a:	c3 c8       	rjmp	80006412 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
8000639c:	58 04       	cp.w	r4,0
8000639e:	c0 51       	brne	800063a8 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800063a0:	06 9c       	mov	r12,r3
800063a2:	f0 1f 00 22 	mcall	80006428 <xQueueGenericSend+0xe8>
800063a6:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800063a8:	f0 1f 00 1f 	mcall	80006424 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800063ac:	f0 1f 00 20 	mcall	8000642c <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
800063b0:	f0 1f 00 1a 	mcall	80006418 <xQueueGenericSend+0xd8>
800063b4:	6f 18       	ld.w	r8,r7[0x44]
800063b6:	5b f8       	cp.w	r8,-1
800063b8:	ef f1 0a 11 	st.weq	r7[0x44],r1
800063bc:	6f 28       	ld.w	r8,r7[0x48]
800063be:	5b f8       	cp.w	r8,-1
800063c0:	ef f1 0a 12 	st.weq	r7[0x48],r1
800063c4:	f0 1f 00 18 	mcall	80006424 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800063c8:	04 9b       	mov	r11,r2
800063ca:	06 9c       	mov	r12,r3
800063cc:	f0 1f 00 19 	mcall	80006430 <xQueueGenericSend+0xf0>
800063d0:	c1 b1       	brne	80006406 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800063d2:	f0 1f 00 12 	mcall	80006418 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800063d6:	6e e5       	ld.w	r5,r7[0x38]
800063d8:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800063da:	f0 1f 00 13 	mcall	80006424 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800063de:	0c 35       	cp.w	r5,r6
800063e0:	c0 d1       	brne	800063fa <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800063e2:	40 2b       	lddsp	r11,sp[0x8]
800063e4:	00 9c       	mov	r12,r0
800063e6:	f0 1f 00 14 	mcall	80006434 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800063ea:	0e 9c       	mov	r12,r7
800063ec:	f0 1f 00 13 	mcall	80006438 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800063f0:	f0 1f 00 13 	mcall	8000643c <xQueueGenericSend+0xfc>
800063f4:	cb 41       	brne	8000635c <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
800063f6:	d7 33       	scall
800063f8:	cb 2b       	rjmp	8000635c <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800063fa:	0e 9c       	mov	r12,r7
800063fc:	f0 1f 00 0f 	mcall	80006438 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80006400:	f0 1f 00 0f 	mcall	8000643c <xQueueGenericSend+0xfc>
80006404:	ca cb       	rjmp	8000635c <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80006406:	0e 9c       	mov	r12,r7
80006408:	f0 1f 00 0c 	mcall	80006438 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
8000640c:	f0 1f 00 0c 	mcall	8000643c <xQueueGenericSend+0xfc>
80006410:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80006412:	2f bd       	sub	sp,-20
80006414:	d8 32       	popm	r0-r7,pc
80006416:	00 00       	add	r0,r0
80006418:	80 00       	ld.sh	r0,r0[0x0]
8000641a:	5d 80       	*unknown*
8000641c:	80 00       	ld.sh	r0,r0[0x0]
8000641e:	62 78       	ld.w	r8,r1[0x1c]
80006420:	80 00       	ld.sh	r0,r0[0x0]
80006422:	66 a4       	ld.w	r4,r3[0x28]
80006424:	80 00       	ld.sh	r0,r0[0x0]
80006426:	5e 8c       	retls	r12
80006428:	80 00       	ld.sh	r0,r0[0x0]
8000642a:	65 98       	ld.w	r8,r2[0x64]
8000642c:	80 00       	ld.sh	r0,r0[0x0]
8000642e:	65 0c       	ld.w	r12,r2[0x40]
80006430:	80 00       	ld.sh	r0,r0[0x0]
80006432:	68 34       	ld.w	r4,r4[0xc]
80006434:	80 00       	ld.sh	r0,r0[0x0]
80006436:	6a d4       	ld.w	r4,r5[0x34]
80006438:	80 00       	ld.sh	r0,r0[0x0]
8000643a:	60 94       	ld.w	r4,r0[0x24]
8000643c:	80 00       	ld.sh	r0,r0[0x0]
8000643e:	68 c8       	ld.w	r8,r4[0x30]

80006440 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80006440:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80006444:	34 cc       	mov	r12,76
80006446:	f0 1f 00 12 	mcall	8000648c <xQueueCreateMutex+0x4c>
8000644a:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
8000644c:	c1 d0       	breq	80006486 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
8000644e:	30 06       	mov	r6,0
80006450:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80006452:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80006454:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
80006456:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80006458:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
8000645a:	30 18       	mov	r8,1
8000645c:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
8000645e:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
80006462:	3f f8       	mov	r8,-1
80006464:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80006468:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000646c:	2f 0c       	sub	r12,-16
8000646e:	f0 1f 00 09 	mcall	80006490 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80006472:	ee cc ff dc 	sub	r12,r7,-36
80006476:	f0 1f 00 07 	mcall	80006490 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
8000647a:	0c 99       	mov	r9,r6
8000647c:	0c 9a       	mov	r10,r6
8000647e:	0c 9b       	mov	r11,r6
80006480:	0e 9c       	mov	r12,r7
80006482:	f0 1f 00 05 	mcall	80006494 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
80006486:	0e 9c       	mov	r12,r7
80006488:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000648c:	80 00       	ld.sh	r0,r0[0x0]
8000648e:	5f ec       	srqs	r12
80006490:	80 00       	ld.sh	r0,r0[0x0]
80006492:	5c 5c       	castu.b	r12
80006494:	80 00       	ld.sh	r0,r0[0x0]
80006496:	63 40       	ld.w	r0,r1[0x50]

80006498 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80006498:	d4 21       	pushm	r4-r7,lr
8000649a:	18 97       	mov	r7,r12
8000649c:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
8000649e:	58 0c       	cp.w	r12,0
800064a0:	c2 f0       	breq	800064fe <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800064a2:	34 cc       	mov	r12,76
800064a4:	f0 1f 00 17 	mcall	80006500 <xQueueCreate+0x68>
800064a8:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
800064aa:	c2 a0       	breq	800064fe <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
800064ac:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
800064b0:	e8 cc ff ff 	sub	r12,r4,-1
800064b4:	f0 1f 00 13 	mcall	80006500 <xQueueCreate+0x68>
800064b8:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
800064ba:	c1 e0       	breq	800064f6 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
800064bc:	f8 04 00 04 	add	r4,r12,r4
800064c0:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800064c2:	30 08       	mov	r8,0
800064c4:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
800064c6:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
800064c8:	ee c8 00 01 	sub	r8,r7,1
800064cc:	ad 38       	mul	r8,r6
800064ce:	10 0c       	add	r12,r8
800064d0:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
800064d2:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
800064d4:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
800064d8:	3f f8       	mov	r8,-1
800064da:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
800064de:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800064e2:	ea cc ff f0 	sub	r12,r5,-16
800064e6:	f0 1f 00 08 	mcall	80006504 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800064ea:	ea cc ff dc 	sub	r12,r5,-36
800064ee:	f0 1f 00 06 	mcall	80006504 <xQueueCreate+0x6c>
800064f2:	0a 9c       	mov	r12,r5
800064f4:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800064f6:	0a 9c       	mov	r12,r5
800064f8:	f0 1f 00 04 	mcall	80006508 <xQueueCreate+0x70>
800064fc:	d8 2a       	popm	r4-r7,pc,r12=0
800064fe:	d8 2a       	popm	r4-r7,pc,r12=0
80006500:	80 00       	ld.sh	r0,r0[0x0]
80006502:	5f ec       	srqs	r12
80006504:	80 00       	ld.sh	r0,r0[0x0]
80006506:	5c 5c       	castu.b	r12
80006508:	80 00       	ld.sh	r0,r0[0x0]
8000650a:	5f c4       	srvs	r4

8000650c <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
8000650c:	48 38       	lddpc	r8,80006518 <vTaskSuspendAll+0xc>
8000650e:	70 09       	ld.w	r9,r8[0x0]
80006510:	2f f9       	sub	r9,-1
80006512:	91 09       	st.w	r8[0x0],r9
}
80006514:	5e fc       	retal	r12
80006516:	00 00       	add	r0,r0
80006518:	00 00       	add	r0,r0
8000651a:	0d 28       	ld.uh	r8,r6++

8000651c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
8000651c:	49 a8       	lddpc	r8,80006584 <vTaskSwitchContext+0x68>
8000651e:	70 08       	ld.w	r8,r8[0x0]
80006520:	58 08       	cp.w	r8,0
80006522:	c0 b1       	brne	80006538 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006524:	49 98       	lddpc	r8,80006588 <vTaskSwitchContext+0x6c>
80006526:	70 08       	ld.w	r8,r8[0x0]
80006528:	f0 08 00 28 	add	r8,r8,r8<<0x2
8000652c:	49 89       	lddpc	r9,8000658c <vTaskSwitchContext+0x70>
8000652e:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80006532:	58 08       	cp.w	r8,0
80006534:	c0 60       	breq	80006540 <vTaskSwitchContext+0x24>
80006536:	c1 18       	rjmp	80006558 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80006538:	30 19       	mov	r9,1
8000653a:	49 68       	lddpc	r8,80006590 <vTaskSwitchContext+0x74>
8000653c:	91 09       	st.w	r8[0x0],r9
8000653e:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006540:	49 28       	lddpc	r8,80006588 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006542:	49 3a       	lddpc	r10,8000658c <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006544:	70 09       	ld.w	r9,r8[0x0]
80006546:	20 19       	sub	r9,1
80006548:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000654a:	70 09       	ld.w	r9,r8[0x0]
8000654c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006550:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80006554:	58 09       	cp.w	r9,0
80006556:	cf 70       	breq	80006544 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80006558:	48 c8       	lddpc	r8,80006588 <vTaskSwitchContext+0x6c>
8000655a:	70 08       	ld.w	r8,r8[0x0]
8000655c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006560:	48 b9       	lddpc	r9,8000658c <vTaskSwitchContext+0x70>
80006562:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006566:	70 19       	ld.w	r9,r8[0x4]
80006568:	72 19       	ld.w	r9,r9[0x4]
8000656a:	91 19       	st.w	r8[0x4],r9
8000656c:	f0 ca ff f8 	sub	r10,r8,-8
80006570:	14 39       	cp.w	r9,r10
80006572:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80006576:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000657a:	70 18       	ld.w	r8,r8[0x4]
8000657c:	70 39       	ld.w	r9,r8[0xc]
8000657e:	48 68       	lddpc	r8,80006594 <vTaskSwitchContext+0x78>
80006580:	91 09       	st.w	r8[0x0],r9
80006582:	5e fc       	retal	r12
80006584:	00 00       	add	r0,r0
80006586:	0d 28       	ld.uh	r8,r6++
80006588:	00 00       	add	r0,r0
8000658a:	0d 60       	ld.uh	r0,--r6
8000658c:	00 00       	add	r0,r0
8000658e:	0c 44       	or	r4,r6
80006590:	00 00       	add	r0,r0
80006592:	0d 48       	ld.w	r8,--r6
80006594:	00 00       	add	r0,r0
80006596:	0c f8       	st.b	--r6,r8

80006598 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80006598:	48 48       	lddpc	r8,800065a8 <vTaskSetTimeOutState+0x10>
8000659a:	70 08       	ld.w	r8,r8[0x0]
8000659c:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
8000659e:	48 48       	lddpc	r8,800065ac <vTaskSetTimeOutState+0x14>
800065a0:	70 08       	ld.w	r8,r8[0x0]
800065a2:	99 18       	st.w	r12[0x4],r8
}
800065a4:	5e fc       	retal	r12
800065a6:	00 00       	add	r0,r0
800065a8:	00 00       	add	r0,r0
800065aa:	0c 3c       	cp.w	r12,r6
800065ac:	00 00       	add	r0,r0
800065ae:	0d 24       	ld.uh	r4,r6++

800065b0 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
800065b0:	30 19       	mov	r9,1
800065b2:	48 28       	lddpc	r8,800065b8 <vTaskMissedYield+0x8>
800065b4:	91 09       	st.w	r8[0x0],r9
}
800065b6:	5e fc       	retal	r12
800065b8:	00 00       	add	r0,r0
800065ba:	0d 48       	ld.w	r8,--r6

800065bc <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
800065bc:	48 28       	lddpc	r8,800065c4 <xTaskGetCurrentTaskHandle+0x8>
800065be:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
800065c0:	5e fc       	retal	r12
800065c2:	00 00       	add	r0,r0
800065c4:	00 00       	add	r0,r0
800065c6:	0c f8       	st.b	--r6,r8

800065c8 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
800065c8:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
800065cc:	58 0c       	cp.w	r12,0
800065ce:	c1 f0       	breq	8000660c <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
800065d0:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
800065d2:	78 b9       	ld.w	r9,r12[0x2c]
800065d4:	79 18       	ld.w	r8,r12[0x44]
800065d6:	10 39       	cp.w	r9,r8
800065d8:	c1 a0       	breq	8000660c <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
800065da:	f8 c6 ff fc 	sub	r6,r12,-4
800065de:	0c 9c       	mov	r12,r6
800065e0:	f0 1f 00 0c 	mcall	80006610 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
800065e4:	6f 1c       	ld.w	r12,r7[0x44]
800065e6:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
800065e8:	f8 08 11 08 	rsub	r8,r12,8
800065ec:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
800065ee:	48 a8       	lddpc	r8,80006614 <vTaskPriorityDisinherit+0x4c>
800065f0:	70 08       	ld.w	r8,r8[0x0]
800065f2:	10 3c       	cp.w	r12,r8
800065f4:	e0 88 00 04 	brls	800065fc <vTaskPriorityDisinherit+0x34>
800065f8:	48 78       	lddpc	r8,80006614 <vTaskPriorityDisinherit+0x4c>
800065fa:	91 0c       	st.w	r8[0x0],r12
800065fc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006600:	0c 9b       	mov	r11,r6
80006602:	48 68       	lddpc	r8,80006618 <vTaskPriorityDisinherit+0x50>
80006604:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006608:	f0 1f 00 05 	mcall	8000661c <vTaskPriorityDisinherit+0x54>
8000660c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006610:	80 00       	ld.sh	r0,r0[0x0]
80006612:	5c c6       	swap.bh	r6
80006614:	00 00       	add	r0,r0
80006616:	0d 60       	ld.uh	r0,--r6
80006618:	00 00       	add	r0,r0
8000661a:	0c 44       	or	r4,r6
8000661c:	80 00       	ld.sh	r0,r0[0x0]
8000661e:	5c 76       	castu.h	r6

80006620 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80006620:	eb cd 40 c0 	pushm	r6-r7,lr
80006624:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80006626:	49 b8       	lddpc	r8,80006690 <vTaskPriorityInherit+0x70>
80006628:	70 08       	ld.w	r8,r8[0x0]
8000662a:	78 b9       	ld.w	r9,r12[0x2c]
8000662c:	70 b8       	ld.w	r8,r8[0x2c]
8000662e:	10 39       	cp.w	r9,r8
80006630:	c2 d2       	brcc	8000668a <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80006632:	49 88       	lddpc	r8,80006690 <vTaskPriorityInherit+0x70>
80006634:	70 08       	ld.w	r8,r8[0x0]
80006636:	70 b8       	ld.w	r8,r8[0x2c]
80006638:	f0 08 11 08 	rsub	r8,r8,8
8000663c:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
8000663e:	f2 09 00 28 	add	r8,r9,r9<<0x2
80006642:	49 59       	lddpc	r9,80006694 <vTaskPriorityInherit+0x74>
80006644:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006648:	78 59       	ld.w	r9,r12[0x14]
8000664a:	10 39       	cp.w	r9,r8
8000664c:	c1 b1       	brne	80006682 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
8000664e:	f8 c6 ff fc 	sub	r6,r12,-4
80006652:	0c 9c       	mov	r12,r6
80006654:	f0 1f 00 11 	mcall	80006698 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006658:	48 e8       	lddpc	r8,80006690 <vTaskPriorityInherit+0x70>
8000665a:	70 08       	ld.w	r8,r8[0x0]
8000665c:	70 bc       	ld.w	r12,r8[0x2c]
8000665e:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80006660:	48 f8       	lddpc	r8,8000669c <vTaskPriorityInherit+0x7c>
80006662:	70 08       	ld.w	r8,r8[0x0]
80006664:	10 3c       	cp.w	r12,r8
80006666:	e0 88 00 04 	brls	8000666e <vTaskPriorityInherit+0x4e>
8000666a:	48 d8       	lddpc	r8,8000669c <vTaskPriorityInherit+0x7c>
8000666c:	91 0c       	st.w	r8[0x0],r12
8000666e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006672:	0c 9b       	mov	r11,r6
80006674:	48 88       	lddpc	r8,80006694 <vTaskPriorityInherit+0x74>
80006676:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000667a:	f0 1f 00 0a 	mcall	800066a0 <vTaskPriorityInherit+0x80>
8000667e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006682:	48 48       	lddpc	r8,80006690 <vTaskPriorityInherit+0x70>
80006684:	70 08       	ld.w	r8,r8[0x0]
80006686:	70 b8       	ld.w	r8,r8[0x2c]
80006688:	99 b8       	st.w	r12[0x2c],r8
8000668a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000668e:	00 00       	add	r0,r0
80006690:	00 00       	add	r0,r0
80006692:	0c f8       	st.b	--r6,r8
80006694:	00 00       	add	r0,r0
80006696:	0c 44       	or	r4,r6
80006698:	80 00       	ld.sh	r0,r0[0x0]
8000669a:	5c c6       	swap.bh	r6
8000669c:	00 00       	add	r0,r0
8000669e:	0d 60       	ld.uh	r0,--r6
800066a0:	80 00       	ld.sh	r0,r0[0x0]
800066a2:	5c 76       	castu.h	r6

800066a4 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800066a4:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800066a8:	78 38       	ld.w	r8,r12[0xc]
800066aa:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800066ac:	ee c6 ff e8 	sub	r6,r7,-24
800066b0:	0c 9c       	mov	r12,r6
800066b2:	f0 1f 00 15 	mcall	80006704 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800066b6:	49 58       	lddpc	r8,80006708 <xTaskRemoveFromEventList+0x64>
800066b8:	70 08       	ld.w	r8,r8[0x0]
800066ba:	58 08       	cp.w	r8,0
800066bc:	c1 71       	brne	800066ea <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
800066be:	ee c6 ff fc 	sub	r6,r7,-4
800066c2:	0c 9c       	mov	r12,r6
800066c4:	f0 1f 00 10 	mcall	80006704 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
800066c8:	6e bc       	ld.w	r12,r7[0x2c]
800066ca:	49 18       	lddpc	r8,8000670c <xTaskRemoveFromEventList+0x68>
800066cc:	70 08       	ld.w	r8,r8[0x0]
800066ce:	10 3c       	cp.w	r12,r8
800066d0:	e0 88 00 04 	brls	800066d8 <xTaskRemoveFromEventList+0x34>
800066d4:	48 e8       	lddpc	r8,8000670c <xTaskRemoveFromEventList+0x68>
800066d6:	91 0c       	st.w	r8[0x0],r12
800066d8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800066dc:	0c 9b       	mov	r11,r6
800066de:	48 d8       	lddpc	r8,80006710 <xTaskRemoveFromEventList+0x6c>
800066e0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800066e4:	f0 1f 00 0c 	mcall	80006714 <xTaskRemoveFromEventList+0x70>
800066e8:	c0 58       	rjmp	800066f2 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800066ea:	0c 9b       	mov	r11,r6
800066ec:	48 bc       	lddpc	r12,80006718 <xTaskRemoveFromEventList+0x74>
800066ee:	f0 1f 00 0a 	mcall	80006714 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800066f2:	48 b8       	lddpc	r8,8000671c <xTaskRemoveFromEventList+0x78>
800066f4:	70 08       	ld.w	r8,r8[0x0]
800066f6:	6e b9       	ld.w	r9,r7[0x2c]
800066f8:	70 b8       	ld.w	r8,r8[0x2c]
800066fa:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
800066fc:	5f 2c       	srhs	r12
800066fe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006702:	00 00       	add	r0,r0
80006704:	80 00       	ld.sh	r0,r0[0x0]
80006706:	5c c6       	swap.bh	r6
80006708:	00 00       	add	r0,r0
8000670a:	0d 28       	ld.uh	r8,r6++
8000670c:	00 00       	add	r0,r0
8000670e:	0d 60       	ld.uh	r0,--r6
80006710:	00 00       	add	r0,r0
80006712:	0c 44       	or	r4,r6
80006714:	80 00       	ld.sh	r0,r0[0x0]
80006716:	5c 76       	castu.h	r6
80006718:	00 00       	add	r0,r0
8000671a:	0c fc       	st.b	--r6,r12
8000671c:	00 00       	add	r0,r0
8000671e:	0c f8       	st.b	--r6,r8

80006720 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80006720:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006724:	4b 98       	lddpc	r8,80006808 <vTaskIncrementTick+0xe8>
80006726:	70 08       	ld.w	r8,r8[0x0]
80006728:	58 08       	cp.w	r8,0
8000672a:	c6 91       	brne	800067fc <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
8000672c:	4b 88       	lddpc	r8,8000680c <vTaskIncrementTick+0xec>
8000672e:	70 09       	ld.w	r9,r8[0x0]
80006730:	2f f9       	sub	r9,-1
80006732:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80006734:	70 08       	ld.w	r8,r8[0x0]
80006736:	58 08       	cp.w	r8,0
80006738:	c1 a1       	brne	8000676c <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
8000673a:	4b 68       	lddpc	r8,80006810 <vTaskIncrementTick+0xf0>
8000673c:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
8000673e:	4b 69       	lddpc	r9,80006814 <vTaskIncrementTick+0xf4>
80006740:	72 0b       	ld.w	r11,r9[0x0]
80006742:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80006744:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80006746:	4b 59       	lddpc	r9,80006818 <vTaskIncrementTick+0xf8>
80006748:	72 0a       	ld.w	r10,r9[0x0]
8000674a:	2f fa       	sub	r10,-1
8000674c:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
8000674e:	70 08       	ld.w	r8,r8[0x0]
80006750:	70 08       	ld.w	r8,r8[0x0]
80006752:	58 08       	cp.w	r8,0
80006754:	c0 51       	brne	8000675e <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80006756:	3f f9       	mov	r9,-1
80006758:	4b 18       	lddpc	r8,8000681c <vTaskIncrementTick+0xfc>
8000675a:	91 09       	st.w	r8[0x0],r9
8000675c:	c0 88       	rjmp	8000676c <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
8000675e:	4a d8       	lddpc	r8,80006810 <vTaskIncrementTick+0xf0>
80006760:	70 08       	ld.w	r8,r8[0x0]
80006762:	70 38       	ld.w	r8,r8[0xc]
80006764:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80006766:	70 19       	ld.w	r9,r8[0x4]
80006768:	4a d8       	lddpc	r8,8000681c <vTaskIncrementTick+0xfc>
8000676a:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
8000676c:	4a 88       	lddpc	r8,8000680c <vTaskIncrementTick+0xec>
8000676e:	70 09       	ld.w	r9,r8[0x0]
80006770:	4a b8       	lddpc	r8,8000681c <vTaskIncrementTick+0xfc>
80006772:	70 08       	ld.w	r8,r8[0x0]
80006774:	10 39       	cp.w	r9,r8
80006776:	c4 73       	brcs	80006804 <vTaskIncrementTick+0xe4>
80006778:	4a 68       	lddpc	r8,80006810 <vTaskIncrementTick+0xf0>
8000677a:	70 08       	ld.w	r8,r8[0x0]
8000677c:	70 08       	ld.w	r8,r8[0x0]
8000677e:	58 08       	cp.w	r8,0
80006780:	c0 c0       	breq	80006798 <vTaskIncrementTick+0x78>
80006782:	4a 48       	lddpc	r8,80006810 <vTaskIncrementTick+0xf0>
80006784:	70 08       	ld.w	r8,r8[0x0]
80006786:	70 38       	ld.w	r8,r8[0xc]
80006788:	70 37       	ld.w	r7,r8[0xc]
8000678a:	6e 18       	ld.w	r8,r7[0x4]
8000678c:	4a 09       	lddpc	r9,8000680c <vTaskIncrementTick+0xec>
8000678e:	72 09       	ld.w	r9,r9[0x0]
80006790:	12 38       	cp.w	r8,r9
80006792:	e0 88 00 14 	brls	800067ba <vTaskIncrementTick+0x9a>
80006796:	c0 e8       	rjmp	800067b2 <vTaskIncrementTick+0x92>
80006798:	3f f9       	mov	r9,-1
8000679a:	4a 18       	lddpc	r8,8000681c <vTaskIncrementTick+0xfc>
8000679c:	91 09       	st.w	r8[0x0],r9
8000679e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800067a2:	6a 08       	ld.w	r8,r5[0x0]
800067a4:	70 38       	ld.w	r8,r8[0xc]
800067a6:	70 37       	ld.w	r7,r8[0xc]
800067a8:	6e 18       	ld.w	r8,r7[0x4]
800067aa:	64 09       	ld.w	r9,r2[0x0]
800067ac:	12 38       	cp.w	r8,r9
800067ae:	e0 88 00 0a 	brls	800067c2 <vTaskIncrementTick+0xa2>
800067b2:	49 b9       	lddpc	r9,8000681c <vTaskIncrementTick+0xfc>
800067b4:	93 08       	st.w	r9[0x0],r8
800067b6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800067ba:	49 a4       	lddpc	r4,80006820 <vTaskIncrementTick+0x100>
800067bc:	49 a3       	lddpc	r3,80006824 <vTaskIncrementTick+0x104>
800067be:	49 55       	lddpc	r5,80006810 <vTaskIncrementTick+0xf0>
800067c0:	49 32       	lddpc	r2,8000680c <vTaskIncrementTick+0xec>
800067c2:	ee c6 ff fc 	sub	r6,r7,-4
800067c6:	0c 9c       	mov	r12,r6
800067c8:	f0 1f 00 18 	mcall	80006828 <vTaskIncrementTick+0x108>
800067cc:	6e a8       	ld.w	r8,r7[0x28]
800067ce:	58 08       	cp.w	r8,0
800067d0:	c0 50       	breq	800067da <vTaskIncrementTick+0xba>
800067d2:	ee cc ff e8 	sub	r12,r7,-24
800067d6:	f0 1f 00 15 	mcall	80006828 <vTaskIncrementTick+0x108>
800067da:	6e bc       	ld.w	r12,r7[0x2c]
800067dc:	68 08       	ld.w	r8,r4[0x0]
800067de:	10 3c       	cp.w	r12,r8
800067e0:	e9 fc ba 00 	st.whi	r4[0x0],r12
800067e4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800067e8:	0c 9b       	mov	r11,r6
800067ea:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800067ee:	f0 1f 00 10 	mcall	8000682c <vTaskIncrementTick+0x10c>
800067f2:	6a 08       	ld.w	r8,r5[0x0]
800067f4:	70 08       	ld.w	r8,r8[0x0]
800067f6:	58 08       	cp.w	r8,0
800067f8:	cd 51       	brne	800067a2 <vTaskIncrementTick+0x82>
800067fa:	cc fb       	rjmp	80006798 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800067fc:	48 d8       	lddpc	r8,80006830 <vTaskIncrementTick+0x110>
800067fe:	70 09       	ld.w	r9,r8[0x0]
80006800:	2f f9       	sub	r9,-1
80006802:	91 09       	st.w	r8[0x0],r9
80006804:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006808:	00 00       	add	r0,r0
8000680a:	0d 28       	ld.uh	r8,r6++
8000680c:	00 00       	add	r0,r0
8000680e:	0d 24       	ld.uh	r4,r6++
80006810:	00 00       	add	r0,r0
80006812:	0c 30       	cp.w	r0,r6
80006814:	00 00       	add	r0,r0
80006816:	0c 40       	or	r0,r6
80006818:	00 00       	add	r0,r0
8000681a:	0c 3c       	cp.w	r12,r6
8000681c:	00 00       	add	r0,r0
8000681e:	05 38       	ld.ub	r8,r2++
80006820:	00 00       	add	r0,r0
80006822:	0d 60       	ld.uh	r0,--r6
80006824:	00 00       	add	r0,r0
80006826:	0c 44       	or	r4,r6
80006828:	80 00       	ld.sh	r0,r0[0x0]
8000682a:	5c c6       	swap.bh	r6
8000682c:	80 00       	ld.sh	r0,r0[0x0]
8000682e:	5c 76       	castu.h	r6
80006830:	00 00       	add	r0,r0
80006832:	0c 28       	rsub	r8,r6

80006834 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80006834:	eb cd 40 c0 	pushm	r6-r7,lr
80006838:	18 97       	mov	r7,r12
8000683a:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
8000683c:	f0 1f 00 15 	mcall	80006890 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80006840:	6c 08       	ld.w	r8,r6[0x0]
80006842:	5b f8       	cp.w	r8,-1
80006844:	c0 31       	brne	8000684a <xTaskCheckForTimeOut+0x16>
80006846:	30 07       	mov	r7,0
80006848:	c1 f8       	rjmp	80006886 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
8000684a:	49 39       	lddpc	r9,80006894 <xTaskCheckForTimeOut+0x60>
8000684c:	72 09       	ld.w	r9,r9[0x0]
8000684e:	6e 0a       	ld.w	r10,r7[0x0]
80006850:	12 3a       	cp.w	r10,r9
80006852:	c0 70       	breq	80006860 <xTaskCheckForTimeOut+0x2c>
80006854:	49 19       	lddpc	r9,80006898 <xTaskCheckForTimeOut+0x64>
80006856:	72 09       	ld.w	r9,r9[0x0]
80006858:	6e 1a       	ld.w	r10,r7[0x4]
8000685a:	12 3a       	cp.w	r10,r9
8000685c:	e0 88 00 14 	brls	80006884 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80006860:	48 e9       	lddpc	r9,80006898 <xTaskCheckForTimeOut+0x64>
80006862:	72 0a       	ld.w	r10,r9[0x0]
80006864:	6e 19       	ld.w	r9,r7[0x4]
80006866:	12 1a       	sub	r10,r9
80006868:	14 38       	cp.w	r8,r10
8000686a:	e0 88 00 0d 	brls	80006884 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
8000686e:	48 ba       	lddpc	r10,80006898 <xTaskCheckForTimeOut+0x64>
80006870:	74 0a       	ld.w	r10,r10[0x0]
80006872:	14 19       	sub	r9,r10
80006874:	f2 08 00 08 	add	r8,r9,r8
80006878:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000687a:	0e 9c       	mov	r12,r7
8000687c:	f0 1f 00 08 	mcall	8000689c <xTaskCheckForTimeOut+0x68>
80006880:	30 07       	mov	r7,0
80006882:	c0 28       	rjmp	80006886 <xTaskCheckForTimeOut+0x52>
80006884:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80006886:	f0 1f 00 07 	mcall	800068a0 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000688a:	0e 9c       	mov	r12,r7
8000688c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006890:	80 00       	ld.sh	r0,r0[0x0]
80006892:	5d 80       	*unknown*
80006894:	00 00       	add	r0,r0
80006896:	0c 3c       	cp.w	r12,r6
80006898:	00 00       	add	r0,r0
8000689a:	0d 24       	ld.uh	r4,r6++
8000689c:	80 00       	ld.sh	r0,r0[0x0]
8000689e:	65 98       	ld.w	r8,r2[0x64]
800068a0:	80 00       	ld.sh	r0,r0[0x0]
800068a2:	5e 8c       	retls	r12

800068a4 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
800068a4:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
800068a8:	f0 1f 00 05 	mcall	800068bc <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
800068ac:	48 58       	lddpc	r8,800068c0 <xTaskGetTickCount+0x1c>
800068ae:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
800068b0:	f0 1f 00 05 	mcall	800068c4 <xTaskGetTickCount+0x20>

	return xTicks;
}
800068b4:	0e 9c       	mov	r12,r7
800068b6:	e3 cd 80 80 	ldm	sp++,r7,pc
800068ba:	00 00       	add	r0,r0
800068bc:	80 00       	ld.sh	r0,r0[0x0]
800068be:	5d 80       	*unknown*
800068c0:	00 00       	add	r0,r0
800068c2:	0d 24       	ld.uh	r4,r6++
800068c4:	80 00       	ld.sh	r0,r0[0x0]
800068c6:	5e 8c       	retls	r12

800068c8 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800068c8:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800068cc:	f0 1f 00 2c 	mcall	8000697c <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
800068d0:	4a c8       	lddpc	r8,80006980 <xTaskResumeAll+0xb8>
800068d2:	70 09       	ld.w	r9,r8[0x0]
800068d4:	20 19       	sub	r9,1
800068d6:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800068d8:	70 08       	ld.w	r8,r8[0x0]
800068da:	58 08       	cp.w	r8,0
800068dc:	c4 91       	brne	8000696e <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800068de:	4a a8       	lddpc	r8,80006984 <xTaskResumeAll+0xbc>
800068e0:	70 08       	ld.w	r8,r8[0x0]
800068e2:	58 08       	cp.w	r8,0
800068e4:	c4 50       	breq	8000696e <xTaskResumeAll+0xa6>
800068e6:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800068e8:	4a 85       	lddpc	r5,80006988 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800068ea:	4a 93       	lddpc	r3,8000698c <xTaskResumeAll+0xc4>
800068ec:	4a 92       	lddpc	r2,80006990 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800068ee:	4a a1       	lddpc	r1,80006994 <xTaskResumeAll+0xcc>
800068f0:	c1 e8       	rjmp	8000692c <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800068f2:	6a 38       	ld.w	r8,r5[0xc]
800068f4:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
800068f6:	ee cc ff e8 	sub	r12,r7,-24
800068fa:	f0 1f 00 28 	mcall	80006998 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800068fe:	ee c6 ff fc 	sub	r6,r7,-4
80006902:	0c 9c       	mov	r12,r6
80006904:	f0 1f 00 25 	mcall	80006998 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80006908:	6e bc       	ld.w	r12,r7[0x2c]
8000690a:	66 08       	ld.w	r8,r3[0x0]
8000690c:	10 3c       	cp.w	r12,r8
8000690e:	e7 fc ba 00 	st.whi	r3[0x0],r12
80006912:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006916:	0c 9b       	mov	r11,r6
80006918:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
8000691c:	f0 1f 00 20 	mcall	8000699c <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006920:	62 08       	ld.w	r8,r1[0x0]
80006922:	6e b9       	ld.w	r9,r7[0x2c]
80006924:	70 b8       	ld.w	r8,r8[0x2c]
80006926:	10 39       	cp.w	r9,r8
80006928:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000692c:	6a 08       	ld.w	r8,r5[0x0]
8000692e:	58 08       	cp.w	r8,0
80006930:	ce 11       	brne	800068f2 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006932:	49 c8       	lddpc	r8,800069a0 <xTaskResumeAll+0xd8>
80006934:	70 08       	ld.w	r8,r8[0x0]
80006936:	58 08       	cp.w	r8,0
80006938:	c0 f0       	breq	80006956 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000693a:	49 a8       	lddpc	r8,800069a0 <xTaskResumeAll+0xd8>
8000693c:	70 08       	ld.w	r8,r8[0x0]
8000693e:	58 08       	cp.w	r8,0
80006940:	c1 10       	breq	80006962 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80006942:	49 87       	lddpc	r7,800069a0 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80006944:	f0 1f 00 18 	mcall	800069a4 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80006948:	6e 08       	ld.w	r8,r7[0x0]
8000694a:	20 18       	sub	r8,1
8000694c:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000694e:	6e 08       	ld.w	r8,r7[0x0]
80006950:	58 08       	cp.w	r8,0
80006952:	cf 91       	brne	80006944 <xTaskResumeAll+0x7c>
80006954:	c0 78       	rjmp	80006962 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80006956:	58 14       	cp.w	r4,1
80006958:	c0 50       	breq	80006962 <xTaskResumeAll+0x9a>
8000695a:	49 48       	lddpc	r8,800069a8 <xTaskResumeAll+0xe0>
8000695c:	70 08       	ld.w	r8,r8[0x0]
8000695e:	58 18       	cp.w	r8,1
80006960:	c0 71       	brne	8000696e <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80006962:	30 09       	mov	r9,0
80006964:	49 18       	lddpc	r8,800069a8 <xTaskResumeAll+0xe0>
80006966:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80006968:	d7 33       	scall
8000696a:	30 17       	mov	r7,1
8000696c:	c0 28       	rjmp	80006970 <xTaskResumeAll+0xa8>
8000696e:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80006970:	f0 1f 00 0f 	mcall	800069ac <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80006974:	0e 9c       	mov	r12,r7
80006976:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000697a:	00 00       	add	r0,r0
8000697c:	80 00       	ld.sh	r0,r0[0x0]
8000697e:	5d 80       	*unknown*
80006980:	00 00       	add	r0,r0
80006982:	0d 28       	ld.uh	r8,r6++
80006984:	00 00       	add	r0,r0
80006986:	0d 44       	ld.w	r4,--r6
80006988:	00 00       	add	r0,r0
8000698a:	0c fc       	st.b	--r6,r12
8000698c:	00 00       	add	r0,r0
8000698e:	0d 60       	ld.uh	r0,--r6
80006990:	00 00       	add	r0,r0
80006992:	0c 44       	or	r4,r6
80006994:	00 00       	add	r0,r0
80006996:	0c f8       	st.b	--r6,r8
80006998:	80 00       	ld.sh	r0,r0[0x0]
8000699a:	5c c6       	swap.bh	r6
8000699c:	80 00       	ld.sh	r0,r0[0x0]
8000699e:	5c 76       	castu.h	r6
800069a0:	00 00       	add	r0,r0
800069a2:	0c 28       	rsub	r8,r6
800069a4:	80 00       	ld.sh	r0,r0[0x0]
800069a6:	67 20       	ld.w	r0,r3[0x48]
800069a8:	00 00       	add	r0,r0
800069aa:	0d 48       	ld.w	r8,--r6
800069ac:	80 00       	ld.sh	r0,r0[0x0]
800069ae:	5e 8c       	retls	r12

800069b0 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
800069b0:	eb cd 40 80 	pushm	r7,lr
800069b4:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
800069b6:	49 08       	lddpc	r8,800069f4 <prvAddCurrentTaskToDelayedList+0x44>
800069b8:	70 08       	ld.w	r8,r8[0x0]
800069ba:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
800069bc:	48 f8       	lddpc	r8,800069f8 <prvAddCurrentTaskToDelayedList+0x48>
800069be:	70 08       	ld.w	r8,r8[0x0]
800069c0:	10 3c       	cp.w	r12,r8
800069c2:	c0 a2       	brcc	800069d6 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800069c4:	48 c8       	lddpc	r8,800069f4 <prvAddCurrentTaskToDelayedList+0x44>
800069c6:	70 0b       	ld.w	r11,r8[0x0]
800069c8:	48 d8       	lddpc	r8,800069fc <prvAddCurrentTaskToDelayedList+0x4c>
800069ca:	70 0c       	ld.w	r12,r8[0x0]
800069cc:	2f cb       	sub	r11,-4
800069ce:	f0 1f 00 0d 	mcall	80006a00 <prvAddCurrentTaskToDelayedList+0x50>
800069d2:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800069d6:	48 88       	lddpc	r8,800069f4 <prvAddCurrentTaskToDelayedList+0x44>
800069d8:	70 0b       	ld.w	r11,r8[0x0]
800069da:	48 b8       	lddpc	r8,80006a04 <prvAddCurrentTaskToDelayedList+0x54>
800069dc:	70 0c       	ld.w	r12,r8[0x0]
800069de:	2f cb       	sub	r11,-4
800069e0:	f0 1f 00 08 	mcall	80006a00 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
800069e4:	48 98       	lddpc	r8,80006a08 <prvAddCurrentTaskToDelayedList+0x58>
800069e6:	70 08       	ld.w	r8,r8[0x0]
800069e8:	10 37       	cp.w	r7,r8
800069ea:	c0 32       	brcc	800069f0 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
800069ec:	48 78       	lddpc	r8,80006a08 <prvAddCurrentTaskToDelayedList+0x58>
800069ee:	91 07       	st.w	r8[0x0],r7
800069f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800069f4:	00 00       	add	r0,r0
800069f6:	0c f8       	st.b	--r6,r8
800069f8:	00 00       	add	r0,r0
800069fa:	0d 24       	ld.uh	r4,r6++
800069fc:	00 00       	add	r0,r0
800069fe:	0c 40       	or	r0,r6
80006a00:	80 00       	ld.sh	r0,r0[0x0]
80006a02:	5c 92       	brev	r2
80006a04:	00 00       	add	r0,r0
80006a06:	0c 30       	cp.w	r0,r6
80006a08:	00 00       	add	r0,r0
80006a0a:	05 38       	ld.ub	r8,r2++

80006a0c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80006a0c:	eb cd 40 c0 	pushm	r6-r7,lr
80006a10:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80006a12:	58 0c       	cp.w	r12,0
80006a14:	c1 10       	breq	80006a36 <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80006a16:	f0 1f 00 0a 	mcall	80006a3c <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80006a1a:	48 a8       	lddpc	r8,80006a40 <vTaskDelay+0x34>
80006a1c:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a1e:	48 a8       	lddpc	r8,80006a44 <vTaskDelay+0x38>
80006a20:	70 0c       	ld.w	r12,r8[0x0]
80006a22:	2f cc       	sub	r12,-4
80006a24:	f0 1f 00 09 	mcall	80006a48 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006a28:	ee 06 00 0c 	add	r12,r7,r6
80006a2c:	f0 1f 00 08 	mcall	80006a4c <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80006a30:	f0 1f 00 08 	mcall	80006a50 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006a34:	c0 21       	brne	80006a38 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80006a36:	d7 33       	scall
80006a38:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006a3c:	80 00       	ld.sh	r0,r0[0x0]
80006a3e:	65 0c       	ld.w	r12,r2[0x40]
80006a40:	00 00       	add	r0,r0
80006a42:	0d 24       	ld.uh	r4,r6++
80006a44:	00 00       	add	r0,r0
80006a46:	0c f8       	st.b	--r6,r8
80006a48:	80 00       	ld.sh	r0,r0[0x0]
80006a4a:	5c c6       	swap.bh	r6
80006a4c:	80 00       	ld.sh	r0,r0[0x0]
80006a4e:	69 b0       	ld.w	r0,r4[0x6c]
80006a50:	80 00       	ld.sh	r0,r0[0x0]
80006a52:	68 c8       	ld.w	r8,r4[0x30]

80006a54 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80006a54:	eb cd 40 c0 	pushm	r6-r7,lr
80006a58:	18 96       	mov	r6,r12
80006a5a:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80006a5c:	f0 1f 00 18 	mcall	80006abc <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80006a60:	6c 08       	ld.w	r8,r6[0x0]
80006a62:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006a64:	49 79       	lddpc	r9,80006ac0 <vTaskDelayUntil+0x6c>
80006a66:	72 09       	ld.w	r9,r9[0x0]
80006a68:	12 38       	cp.w	r8,r9
80006a6a:	e0 88 00 0c 	brls	80006a82 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80006a6e:	0e 38       	cp.w	r8,r7
80006a70:	e0 88 00 22 	brls	80006ab4 <vTaskDelayUntil+0x60>
80006a74:	49 38       	lddpc	r8,80006ac0 <vTaskDelayUntil+0x6c>
80006a76:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006a78:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80006a7a:	10 37       	cp.w	r7,r8
80006a7c:	e0 88 00 14 	brls	80006aa4 <vTaskDelayUntil+0x50>
80006a80:	c0 a8       	rjmp	80006a94 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80006a82:	0e 38       	cp.w	r8,r7
80006a84:	e0 8b 00 16 	brhi	80006ab0 <vTaskDelayUntil+0x5c>
80006a88:	48 e8       	lddpc	r8,80006ac0 <vTaskDelayUntil+0x6c>
80006a8a:	70 08       	ld.w	r8,r8[0x0]
80006a8c:	10 37       	cp.w	r7,r8
80006a8e:	e0 8b 00 11 	brhi	80006ab0 <vTaskDelayUntil+0x5c>
80006a92:	c1 18       	rjmp	80006ab4 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a94:	48 c8       	lddpc	r8,80006ac4 <vTaskDelayUntil+0x70>
80006a96:	70 0c       	ld.w	r12,r8[0x0]
80006a98:	2f cc       	sub	r12,-4
80006a9a:	f0 1f 00 0c 	mcall	80006ac8 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006a9e:	0e 9c       	mov	r12,r7
80006aa0:	f0 1f 00 0b 	mcall	80006acc <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006aa4:	f0 1f 00 0b 	mcall	80006ad0 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006aa8:	c0 81       	brne	80006ab8 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80006aaa:	d7 33       	scall
80006aac:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006ab0:	8d 07       	st.w	r6[0x0],r7
80006ab2:	cf 1b       	rjmp	80006a94 <vTaskDelayUntil+0x40>
80006ab4:	8d 07       	st.w	r6[0x0],r7
80006ab6:	cf 7b       	rjmp	80006aa4 <vTaskDelayUntil+0x50>
80006ab8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006abc:	80 00       	ld.sh	r0,r0[0x0]
80006abe:	65 0c       	ld.w	r12,r2[0x40]
80006ac0:	00 00       	add	r0,r0
80006ac2:	0d 24       	ld.uh	r4,r6++
80006ac4:	00 00       	add	r0,r0
80006ac6:	0c f8       	st.b	--r6,r8
80006ac8:	80 00       	ld.sh	r0,r0[0x0]
80006aca:	5c c6       	swap.bh	r6
80006acc:	80 00       	ld.sh	r0,r0[0x0]
80006ace:	69 b0       	ld.w	r0,r4[0x6c]
80006ad0:	80 00       	ld.sh	r0,r0[0x0]
80006ad2:	68 c8       	ld.w	r8,r4[0x30]

80006ad4 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006ad4:	eb cd 40 c0 	pushm	r6-r7,lr
80006ad8:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006ada:	48 e7       	lddpc	r7,80006b10 <vTaskPlaceOnEventList+0x3c>
80006adc:	6e 0b       	ld.w	r11,r7[0x0]
80006ade:	2e 8b       	sub	r11,-24
80006ae0:	f0 1f 00 0d 	mcall	80006b14 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006ae4:	6e 0c       	ld.w	r12,r7[0x0]
80006ae6:	2f cc       	sub	r12,-4
80006ae8:	f0 1f 00 0c 	mcall	80006b18 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006aec:	5b f6       	cp.w	r6,-1
80006aee:	c0 81       	brne	80006afe <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006af0:	6e 0b       	ld.w	r11,r7[0x0]
80006af2:	2f cb       	sub	r11,-4
80006af4:	48 ac       	lddpc	r12,80006b1c <vTaskPlaceOnEventList+0x48>
80006af6:	f0 1f 00 0b 	mcall	80006b20 <vTaskPlaceOnEventList+0x4c>
80006afa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006afe:	48 a8       	lddpc	r8,80006b24 <vTaskPlaceOnEventList+0x50>
80006b00:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80006b02:	ec 0c 00 0c 	add	r12,r6,r12
80006b06:	f0 1f 00 09 	mcall	80006b28 <vTaskPlaceOnEventList+0x54>
80006b0a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006b0e:	00 00       	add	r0,r0
80006b10:	00 00       	add	r0,r0
80006b12:	0c f8       	st.b	--r6,r8
80006b14:	80 00       	ld.sh	r0,r0[0x0]
80006b16:	5c 92       	brev	r2
80006b18:	80 00       	ld.sh	r0,r0[0x0]
80006b1a:	5c c6       	swap.bh	r6
80006b1c:	00 00       	add	r0,r0
80006b1e:	0d 4c       	ld.w	r12,--r6
80006b20:	80 00       	ld.sh	r0,r0[0x0]
80006b22:	5c 76       	castu.h	r6
80006b24:	00 00       	add	r0,r0
80006b26:	0d 24       	ld.uh	r4,r6++
80006b28:	80 00       	ld.sh	r0,r0[0x0]
80006b2a:	69 b0       	ld.w	r0,r4[0x6c]

80006b2c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006b2c:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006b30:	49 67       	lddpc	r7,80006b88 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006b32:	49 74       	lddpc	r4,80006b8c <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006b34:	49 73       	lddpc	r3,80006b90 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006b36:	49 85       	lddpc	r5,80006b94 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006b38:	6e 08       	ld.w	r8,r7[0x0]
80006b3a:	58 08       	cp.w	r8,0
80006b3c:	c1 e0       	breq	80006b78 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80006b3e:	f0 1f 00 17 	mcall	80006b98 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006b42:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006b44:	f0 1f 00 16 	mcall	80006b9c <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006b48:	58 06       	cp.w	r6,0
80006b4a:	c1 70       	breq	80006b78 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006b4c:	f0 1f 00 15 	mcall	80006ba0 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006b50:	68 38       	ld.w	r8,r4[0xc]
80006b52:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006b54:	ec cc ff fc 	sub	r12,r6,-4
80006b58:	f0 1f 00 13 	mcall	80006ba4 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80006b5c:	66 08       	ld.w	r8,r3[0x0]
80006b5e:	20 18       	sub	r8,1
80006b60:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80006b62:	6e 08       	ld.w	r8,r7[0x0]
80006b64:	20 18       	sub	r8,1
80006b66:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006b68:	f0 1f 00 10 	mcall	80006ba8 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006b6c:	6c cc       	ld.w	r12,r6[0x30]
80006b6e:	f0 1f 00 10 	mcall	80006bac <prvIdleTask+0x80>
		vPortFree( pxTCB );
80006b72:	0c 9c       	mov	r12,r6
80006b74:	f0 1f 00 0e 	mcall	80006bac <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006b78:	6a 08       	ld.w	r8,r5[0x0]
80006b7a:	58 18       	cp.w	r8,1
80006b7c:	e0 88 00 03 	brls	80006b82 <prvIdleTask+0x56>
			{
				taskYIELD();
80006b80:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80006b82:	f0 1f 00 0c 	mcall	80006bb0 <prvIdleTask+0x84>
		}
		#endif
	}
80006b86:	cd 9b       	rjmp	80006b38 <prvIdleTask+0xc>
80006b88:	00 00       	add	r0,r0
80006b8a:	0c 38       	cp.w	r8,r6
80006b8c:	00 00       	add	r0,r0
80006b8e:	0c e4       	st.h	--r6,r4
80006b90:	00 00       	add	r0,r0
80006b92:	0d 44       	ld.w	r4,--r6
80006b94:	00 00       	add	r0,r0
80006b96:	0c 44       	or	r4,r6
80006b98:	80 00       	ld.sh	r0,r0[0x0]
80006b9a:	65 0c       	ld.w	r12,r2[0x40]
80006b9c:	80 00       	ld.sh	r0,r0[0x0]
80006b9e:	68 c8       	ld.w	r8,r4[0x30]
80006ba0:	80 00       	ld.sh	r0,r0[0x0]
80006ba2:	5d 80       	*unknown*
80006ba4:	80 00       	ld.sh	r0,r0[0x0]
80006ba6:	5c c6       	swap.bh	r6
80006ba8:	80 00       	ld.sh	r0,r0[0x0]
80006baa:	5e 8c       	retls	r12
80006bac:	80 00       	ld.sh	r0,r0[0x0]
80006bae:	5f c4       	srvs	r4
80006bb0:	80 00       	ld.sh	r0,r0[0x0]
80006bb2:	20 2c       	sub	r12,2

80006bb4 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006bb4:	d4 31       	pushm	r0-r7,lr
80006bb6:	20 1d       	sub	sp,4
80006bb8:	fa c4 ff d8 	sub	r4,sp,-40
80006bbc:	50 0c       	stdsp	sp[0x0],r12
80006bbe:	16 91       	mov	r1,r11
80006bc0:	14 97       	mov	r7,r10
80006bc2:	12 90       	mov	r0,r9
80006bc4:	10 93       	mov	r3,r8
80006bc6:	68 02       	ld.w	r2,r4[0x0]
80006bc8:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006bca:	34 8c       	mov	r12,72
80006bcc:	f0 1f 00 5c 	mcall	80006d3c <xTaskGenericCreate+0x188>
80006bd0:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80006bd2:	c0 31       	brne	80006bd8 <xTaskGenericCreate+0x24>
80006bd4:	3f fc       	mov	r12,-1
80006bd6:	ca f8       	rjmp	80006d34 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006bd8:	58 06       	cp.w	r6,0
80006bda:	e0 81 00 af 	brne	80006d38 <xTaskGenericCreate+0x184>
80006bde:	0e 9c       	mov	r12,r7
80006be0:	5c 7c       	castu.h	r12
80006be2:	a3 6c       	lsl	r12,0x2
80006be4:	f0 1f 00 56 	mcall	80006d3c <xTaskGenericCreate+0x188>
80006be8:	18 96       	mov	r6,r12
80006bea:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006bec:	c0 61       	brne	80006bf8 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006bee:	0a 9c       	mov	r12,r5
80006bf0:	f0 1f 00 54 	mcall	80006d40 <xTaskGenericCreate+0x18c>
80006bf4:	3f fc       	mov	r12,-1
80006bf6:	c9 f8       	rjmp	80006d34 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006bf8:	5c 77       	castu.h	r7
80006bfa:	ee 0a 15 02 	lsl	r10,r7,0x2
80006bfe:	e0 6b 00 a5 	mov	r11,165
80006c02:	0c 9c       	mov	r12,r6
80006c04:	f0 1f 00 50 	mcall	80006d44 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006c08:	ee c6 00 01 	sub	r6,r7,1
80006c0c:	6a c8       	ld.w	r8,r5[0x30]
80006c0e:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006c12:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006c16:	31 0a       	mov	r10,16
80006c18:	02 9b       	mov	r11,r1
80006c1a:	ea cc ff cc 	sub	r12,r5,-52
80006c1e:	f0 1f 00 4b 	mcall	80006d48 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006c22:	30 08       	mov	r8,0
80006c24:	eb 68 00 43 	st.b	r5[67],r8
80006c28:	58 73       	cp.w	r3,7
80006c2a:	e6 07 17 80 	movls	r7,r3
80006c2e:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006c32:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006c34:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006c38:	ea c4 ff fc 	sub	r4,r5,-4
80006c3c:	08 9c       	mov	r12,r4
80006c3e:	f0 1f 00 44 	mcall	80006d4c <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006c42:	ea cc ff e8 	sub	r12,r5,-24
80006c46:	f0 1f 00 42 	mcall	80006d4c <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006c4a:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006c4c:	ee 07 11 08 	rsub	r7,r7,8
80006c50:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006c52:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006c54:	00 9a       	mov	r10,r0
80006c56:	40 0b       	lddsp	r11,sp[0x0]
80006c58:	0c 9c       	mov	r12,r6
80006c5a:	f0 1f 00 3e 	mcall	80006d50 <xTaskGenericCreate+0x19c>
80006c5e:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006c60:	58 02       	cp.w	r2,0
80006c62:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006c66:	f0 1f 00 3c 	mcall	80006d54 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006c6a:	4b c8       	lddpc	r8,80006d58 <xTaskGenericCreate+0x1a4>
80006c6c:	70 09       	ld.w	r9,r8[0x0]
80006c6e:	2f f9       	sub	r9,-1
80006c70:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006c72:	4b b8       	lddpc	r8,80006d5c <xTaskGenericCreate+0x1a8>
80006c74:	70 08       	ld.w	r8,r8[0x0]
80006c76:	58 08       	cp.w	r8,0
80006c78:	c2 61       	brne	80006cc4 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006c7a:	4b 98       	lddpc	r8,80006d5c <xTaskGenericCreate+0x1a8>
80006c7c:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006c7e:	4b 78       	lddpc	r8,80006d58 <xTaskGenericCreate+0x1a4>
80006c80:	70 08       	ld.w	r8,r8[0x0]
80006c82:	58 18       	cp.w	r8,1
80006c84:	c2 b1       	brne	80006cda <xTaskGenericCreate+0x126>
80006c86:	4b 77       	lddpc	r7,80006d60 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006c88:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006c8c:	0e 9c       	mov	r12,r7
80006c8e:	f0 1f 00 36 	mcall	80006d64 <xTaskGenericCreate+0x1b0>
80006c92:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006c94:	0c 37       	cp.w	r7,r6
80006c96:	cf b1       	brne	80006c8c <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006c98:	4b 47       	lddpc	r7,80006d68 <xTaskGenericCreate+0x1b4>
80006c9a:	0e 9c       	mov	r12,r7
80006c9c:	f0 1f 00 32 	mcall	80006d64 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006ca0:	4b 36       	lddpc	r6,80006d6c <xTaskGenericCreate+0x1b8>
80006ca2:	0c 9c       	mov	r12,r6
80006ca4:	f0 1f 00 30 	mcall	80006d64 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006ca8:	4b 2c       	lddpc	r12,80006d70 <xTaskGenericCreate+0x1bc>
80006caa:	f0 1f 00 2f 	mcall	80006d64 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006cae:	4b 2c       	lddpc	r12,80006d74 <xTaskGenericCreate+0x1c0>
80006cb0:	f0 1f 00 2d 	mcall	80006d64 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006cb4:	4b 1c       	lddpc	r12,80006d78 <xTaskGenericCreate+0x1c4>
80006cb6:	f0 1f 00 2c 	mcall	80006d64 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006cba:	4b 18       	lddpc	r8,80006d7c <xTaskGenericCreate+0x1c8>
80006cbc:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006cbe:	4b 18       	lddpc	r8,80006d80 <xTaskGenericCreate+0x1cc>
80006cc0:	91 06       	st.w	r8[0x0],r6
80006cc2:	c0 c8       	rjmp	80006cda <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006cc4:	4b 08       	lddpc	r8,80006d84 <xTaskGenericCreate+0x1d0>
80006cc6:	70 08       	ld.w	r8,r8[0x0]
80006cc8:	58 08       	cp.w	r8,0
80006cca:	c0 81       	brne	80006cda <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006ccc:	4a 48       	lddpc	r8,80006d5c <xTaskGenericCreate+0x1a8>
80006cce:	70 08       	ld.w	r8,r8[0x0]
80006cd0:	70 b8       	ld.w	r8,r8[0x2c]
80006cd2:	10 33       	cp.w	r3,r8
80006cd4:	c0 33       	brcs	80006cda <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006cd6:	4a 28       	lddpc	r8,80006d5c <xTaskGenericCreate+0x1a8>
80006cd8:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006cda:	6a b8       	ld.w	r8,r5[0x2c]
80006cdc:	4a b9       	lddpc	r9,80006d88 <xTaskGenericCreate+0x1d4>
80006cde:	72 09       	ld.w	r9,r9[0x0]
80006ce0:	12 38       	cp.w	r8,r9
80006ce2:	e0 88 00 04 	brls	80006cea <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006ce6:	4a 99       	lddpc	r9,80006d88 <xTaskGenericCreate+0x1d4>
80006ce8:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006cea:	4a 98       	lddpc	r8,80006d8c <xTaskGenericCreate+0x1d8>
80006cec:	70 09       	ld.w	r9,r8[0x0]
80006cee:	2f f9       	sub	r9,-1
80006cf0:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006cf2:	6a b8       	ld.w	r8,r5[0x2c]
80006cf4:	4a 79       	lddpc	r9,80006d90 <xTaskGenericCreate+0x1dc>
80006cf6:	72 09       	ld.w	r9,r9[0x0]
80006cf8:	12 38       	cp.w	r8,r9
80006cfa:	e0 88 00 04 	brls	80006d02 <xTaskGenericCreate+0x14e>
80006cfe:	4a 59       	lddpc	r9,80006d90 <xTaskGenericCreate+0x1dc>
80006d00:	93 08       	st.w	r9[0x0],r8
80006d02:	6a bc       	ld.w	r12,r5[0x2c]
80006d04:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006d08:	08 9b       	mov	r11,r4
80006d0a:	49 68       	lddpc	r8,80006d60 <xTaskGenericCreate+0x1ac>
80006d0c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006d10:	f0 1f 00 21 	mcall	80006d94 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006d14:	f0 1f 00 21 	mcall	80006d98 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006d18:	49 b8       	lddpc	r8,80006d84 <xTaskGenericCreate+0x1d0>
80006d1a:	70 08       	ld.w	r8,r8[0x0]
80006d1c:	58 08       	cp.w	r8,0
80006d1e:	c0 a0       	breq	80006d32 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006d20:	48 f8       	lddpc	r8,80006d5c <xTaskGenericCreate+0x1a8>
80006d22:	70 08       	ld.w	r8,r8[0x0]
80006d24:	70 b8       	ld.w	r8,r8[0x2c]
80006d26:	10 33       	cp.w	r3,r8
80006d28:	e0 88 00 05 	brls	80006d32 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006d2c:	d7 33       	scall
80006d2e:	30 1c       	mov	r12,1
80006d30:	c0 28       	rjmp	80006d34 <xTaskGenericCreate+0x180>
80006d32:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006d34:	2f fd       	sub	sp,-4
80006d36:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006d38:	99 c6       	st.w	r12[0x30],r6
80006d3a:	c5 fb       	rjmp	80006bf8 <xTaskGenericCreate+0x44>
80006d3c:	80 00       	ld.sh	r0,r0[0x0]
80006d3e:	5f ec       	srqs	r12
80006d40:	80 00       	ld.sh	r0,r0[0x0]
80006d42:	5f c4       	srvs	r4
80006d44:	80 00       	ld.sh	r0,r0[0x0]
80006d46:	79 3c       	ld.w	r12,r12[0x4c]
80006d48:	80 00       	ld.sh	r0,r0[0x0]
80006d4a:	7c 68       	ld.w	r8,lr[0x18]
80006d4c:	80 00       	ld.sh	r0,r0[0x0]
80006d4e:	5c 70       	castu.h	r0
80006d50:	80 00       	ld.sh	r0,r0[0x0]
80006d52:	5c ec       	tnbz	r12
80006d54:	80 00       	ld.sh	r0,r0[0x0]
80006d56:	5d 80       	*unknown*
80006d58:	00 00       	add	r0,r0
80006d5a:	0d 44       	ld.w	r4,--r6
80006d5c:	00 00       	add	r0,r0
80006d5e:	0c f8       	st.b	--r6,r8
80006d60:	00 00       	add	r0,r0
80006d62:	0c 44       	or	r4,r6
80006d64:	80 00       	ld.sh	r0,r0[0x0]
80006d66:	5c 5c       	castu.b	r12
80006d68:	00 00       	add	r0,r0
80006d6a:	0d 10       	ld.sh	r0,r6++
80006d6c:	00 00       	add	r0,r0
80006d6e:	0d 2c       	ld.uh	r12,r6++
80006d70:	00 00       	add	r0,r0
80006d72:	0c fc       	st.b	--r6,r12
80006d74:	00 00       	add	r0,r0
80006d76:	0c e4       	st.h	--r6,r4
80006d78:	00 00       	add	r0,r0
80006d7a:	0d 4c       	ld.w	r12,--r6
80006d7c:	00 00       	add	r0,r0
80006d7e:	0c 30       	cp.w	r0,r6
80006d80:	00 00       	add	r0,r0
80006d82:	0c 40       	or	r0,r6
80006d84:	00 00       	add	r0,r0
80006d86:	0c 34       	cp.w	r4,r6
80006d88:	00 00       	add	r0,r0
80006d8a:	0c 2c       	rsub	r12,r6
80006d8c:	00 00       	add	r0,r0
80006d8e:	0d 40       	ld.w	r0,--r6
80006d90:	00 00       	add	r0,r0
80006d92:	0d 60       	ld.uh	r0,--r6
80006d94:	80 00       	ld.sh	r0,r0[0x0]
80006d96:	5c 76       	castu.h	r6
80006d98:	80 00       	ld.sh	r0,r0[0x0]
80006d9a:	5e 8c       	retls	r12

80006d9c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006d9c:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006d9e:	30 09       	mov	r9,0
80006da0:	1a d9       	st.w	--sp,r9
80006da2:	1a d9       	st.w	--sp,r9
80006da4:	1a d9       	st.w	--sp,r9
80006da6:	12 98       	mov	r8,r9
80006da8:	e0 6a 01 00 	mov	r10,256
80006dac:	48 9b       	lddpc	r11,80006dd0 <vTaskStartScheduler+0x34>
80006dae:	48 ac       	lddpc	r12,80006dd4 <vTaskStartScheduler+0x38>
80006db0:	f0 1f 00 0a 	mcall	80006dd8 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006db4:	2f dd       	sub	sp,-12
80006db6:	58 1c       	cp.w	r12,1
80006db8:	c0 a1       	brne	80006dcc <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006dba:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006dbc:	30 19       	mov	r9,1
80006dbe:	48 88       	lddpc	r8,80006ddc <vTaskStartScheduler+0x40>
80006dc0:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006dc2:	30 09       	mov	r9,0
80006dc4:	48 78       	lddpc	r8,80006de0 <vTaskStartScheduler+0x44>
80006dc6:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006dc8:	f0 1f 00 07 	mcall	80006de4 <vTaskStartScheduler+0x48>
80006dcc:	d8 02       	popm	pc
80006dce:	00 00       	add	r0,r0
80006dd0:	80 00       	ld.sh	r0,r0[0x0]
80006dd2:	da 20       	acall	0xa2
80006dd4:	80 00       	ld.sh	r0,r0[0x0]
80006dd6:	6b 2c       	ld.w	r12,r5[0x48]
80006dd8:	80 00       	ld.sh	r0,r0[0x0]
80006dda:	6b b4       	ld.w	r4,r5[0x6c]
80006ddc:	00 00       	add	r0,r0
80006dde:	0c 34       	cp.w	r4,r6
80006de0:	00 00       	add	r0,r0
80006de2:	0d 24       	ld.uh	r4,r6++
80006de4:	80 00       	ld.sh	r0,r0[0x0]
80006de6:	5d 90       	*unknown*

80006de8 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006de8:	16 cc       	st.b	r11++,r12
	return str;
}
80006dea:	5e fb       	retal	r11

80006dec <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006dec:	eb cd 40 c0 	pushm	r6-r7,lr
80006df0:	20 3d       	sub	sp,12
80006df2:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006df4:	30 06       	mov	r6,0
80006df6:	30 07       	mov	r7,0
80006df8:	fa e7 00 00 	st.d	sp[0],r6
80006dfc:	30 0c       	mov	r12,0
80006dfe:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006e00:	58 08       	cp.w	r8,0
80006e02:	c1 30       	breq	80006e28 <PrintHex+0x3c>
80006e04:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006e06:	1a 9c       	mov	r12,sp
80006e08:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006e0c:	58 9e       	cp.w	lr,9
80006e0e:	e0 8a 00 04 	brle	80006e16 <PrintHex+0x2a>
80006e12:	2c 9e       	sub	lr,-55
80006e14:	c0 48       	rjmp	80006e1c <PrintHex+0x30>
80006e16:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006e1a:	2d 0e       	sub	lr,-48
80006e1c:	f8 09 0b 0e 	st.b	r12[r9],lr
80006e20:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006e22:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006e24:	cf 21       	brne	80006e08 <PrintHex+0x1c>
80006e26:	c0 48       	rjmp	80006e2e <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006e28:	33 08       	mov	r8,48
80006e2a:	ba 88       	st.b	sp[0x0],r8
80006e2c:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006e2e:	f6 09 01 08 	sub	r8,r11,r9
80006e32:	58 08       	cp.w	r8,0
80006e34:	e0 8a 00 13 	brle	80006e5a <PrintHex+0x6e>
	{
		char num = len - cnt;
80006e38:	12 1b       	sub	r11,r9
80006e3a:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006e3e:	18 9e       	mov	lr,r12
80006e40:	58 0c       	cp.w	r12,0
80006e42:	e0 8a 00 0c 	brle	80006e5a <PrintHex+0x6e>
80006e46:	1a 9b       	mov	r11,sp
80006e48:	12 0b       	add	r11,r9
80006e4a:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006e4c:	33 07       	mov	r7,48
80006e4e:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006e50:	2f f8       	sub	r8,-1
80006e52:	1c 38       	cp.w	r8,lr
80006e54:	cf d5       	brlt	80006e4e <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006e56:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006e5a:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006e5e:	f0 cb ff ff 	sub	r11,r8,-1
80006e62:	58 0b       	cp.w	r11,0
80006e64:	e0 8a 00 19 	brle	80006e96 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006e68:	fa cb ff f4 	sub	r11,sp,-12
80006e6c:	f6 09 00 09 	add	r9,r11,r9
80006e70:	37 8b       	mov	r11,120
80006e72:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006e76:	fa c9 ff f4 	sub	r9,sp,-12
80006e7a:	10 09       	add	r9,r8
80006e7c:	33 0b       	mov	r11,48
80006e7e:	f3 6b ff f4 	st.b	r9[-12],r11
80006e82:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006e86:	fa ce 00 01 	sub	lr,sp,1
80006e8a:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006e8c:	11 8b       	ld.ub	r11,r8[0x0]
80006e8e:	12 cb       	st.b	r9++,r11
80006e90:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006e92:	1c 38       	cp.w	r8,lr
80006e94:	cf c1       	brne	80006e8c <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006e96:	14 9c       	mov	r12,r10
80006e98:	2f dd       	sub	sp,-12
80006e9a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006e9e <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006e9e:	d4 21       	pushm	r4-r7,lr
80006ea0:	20 3d       	sub	sp,12
80006ea2:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006ea4:	30 06       	mov	r6,0
80006ea6:	30 07       	mov	r7,0
80006ea8:	fa e7 00 00 	st.d	sp[0],r6
80006eac:	30 0c       	mov	r12,0
80006eae:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006eb0:	58 08       	cp.w	r8,0
80006eb2:	c0 35       	brlt	80006eb8 <PrintDec+0x1a>
80006eb4:	14 97       	mov	r7,r10
80006eb6:	c0 58       	rjmp	80006ec0 <PrintDec+0x22>
	{
		*p++ = '-';
80006eb8:	14 97       	mov	r7,r10
80006eba:	32 d9       	mov	r9,45
80006ebc:	0e c9       	st.b	r7++,r9
		i = -i;
80006ebe:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006ec0:	58 08       	cp.w	r8,0
80006ec2:	c0 51       	brne	80006ecc <PrintDec+0x2e>
80006ec4:	33 08       	mov	r8,48
80006ec6:	ba 88       	st.b	sp[0x0],r8
80006ec8:	30 1e       	mov	lr,1
80006eca:	c2 f8       	rjmp	80006f28 <PrintDec+0x8a>
	
	int ten = i%10;
80006ecc:	e0 65 66 67 	mov	r5,26215
80006ed0:	ea 15 66 66 	orh	r5,0x6666
80006ed4:	f0 05 04 44 	muls.d	r4,r8,r5
80006ed8:	ea 0c 14 02 	asr	r12,r5,0x2
80006edc:	f0 09 14 1f 	asr	r9,r8,0x1f
80006ee0:	f8 09 01 09 	sub	r9,r12,r9
80006ee4:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006ee8:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006eec:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006eee:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006ef0:	e0 66 66 67 	mov	r6,26215
80006ef4:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006ef8:	2d 09       	sub	r9,-48
80006efa:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006efe:	2f fe       	sub	lr,-1
		i /= 10;
80006f00:	f0 06 04 44 	muls.d	r4,r8,r6
80006f04:	ea 09 14 02 	asr	r9,r5,0x2
80006f08:	bf 58       	asr	r8,0x1f
80006f0a:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006f0e:	f0 06 04 44 	muls.d	r4,r8,r6
80006f12:	ea 09 14 02 	asr	r9,r5,0x2
80006f16:	f0 05 14 1f 	asr	r5,r8,0x1f
80006f1a:	0a 19       	sub	r9,r5
80006f1c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006f20:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006f24:	58 08       	cp.w	r8,0
80006f26:	ce 91       	brne	80006ef8 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006f28:	f6 0e 01 08 	sub	r8,r11,lr
80006f2c:	58 08       	cp.w	r8,0
80006f2e:	e0 89 00 06 	brgt	80006f3a <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006f32:	58 0e       	cp.w	lr,0
80006f34:	e0 89 00 14 	brgt	80006f5c <PrintDec+0xbe>
80006f38:	c1 d8       	rjmp	80006f72 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006f3a:	1c 1b       	sub	r11,lr
80006f3c:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006f3e:	16 9c       	mov	r12,r11
80006f40:	58 0b       	cp.w	r11,0
80006f42:	fe 9a ff f8 	brle	80006f32 <PrintDec+0x94>
80006f46:	1a 99       	mov	r9,sp
80006f48:	1c 09       	add	r9,lr
80006f4a:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006f4c:	33 06       	mov	r6,48
80006f4e:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006f50:	2f f8       	sub	r8,-1
80006f52:	18 38       	cp.w	r8,r12
80006f54:	cf d5       	brlt	80006f4e <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006f56:	f6 0e 00 0e 	add	lr,r11,lr
80006f5a:	ce cb       	rjmp	80006f32 <PrintDec+0x94>
80006f5c:	fa c8 ff f4 	sub	r8,sp,-12
80006f60:	1c 08       	add	r8,lr
80006f62:	20 d8       	sub	r8,13
80006f64:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006f68:	11 89       	ld.ub	r9,r8[0x0]
80006f6a:	0e c9       	st.b	r7++,r9
80006f6c:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006f6e:	16 38       	cp.w	r8,r11
80006f70:	cf c1       	brne	80006f68 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80006f72:	14 9c       	mov	r12,r10
80006f74:	2f dd       	sub	sp,-12
80006f76:	d8 22       	popm	r4-r7,pc

80006f78 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006f78:	d4 31       	pushm	r0-r7,lr
80006f7a:	fa cd 02 08 	sub	sp,sp,520
80006f7e:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006f80:	e0 6a 01 00 	mov	r10,256
80006f84:	30 0b       	mov	r11,0
80006f86:	fa cc fe f8 	sub	r12,sp,-264
80006f8a:	f0 1f 00 4e 	mcall	800070c0 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006f8e:	fa c4 fd d4 	sub	r4,sp,-556
80006f92:	30 0a       	mov	r10,0
80006f94:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006f96:	fa c3 ff fc 	sub	r3,sp,-4
80006f9a:	e0 61 01 00 	mov	r1,256
80006f9e:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006fa0:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006fa2:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006fa6:	02 9a       	mov	r10,r1
80006fa8:	00 9b       	mov	r11,r0
80006faa:	06 9c       	mov	r12,r3
80006fac:	f0 1f 00 45 	mcall	800070c0 <log+0x148>
			
					if(*str == '%')
80006fb0:	0f 88       	ld.ub	r8,r7[0x0]
80006fb2:	e4 08 18 00 	cp.b	r8,r2
80006fb6:	c5 71       	brne	80007064 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80006fb8:	ee c8 ff ff 	sub	r8,r7,-1
80006fbc:	11 89       	ld.ub	r9,r8[0x0]
80006fbe:	4c 2a       	lddpc	r10,800070c4 <log+0x14c>
80006fc0:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80006fc2:	23 09       	sub	r9,48
80006fc4:	30 9a       	mov	r10,9
80006fc6:	f4 09 18 00 	cp.b	r9,r10
80006fca:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80006fce:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006fd2:	f7 b9 08 30 	subls	r9,48
80006fd6:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80006fda:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80006fde:	0f 88       	ld.ub	r8,r7[0x0]
80006fe0:	22 58       	sub	r8,37
80006fe2:	e0 48 00 53 	cp.w	r8,83
80006fe6:	e0 8b 00 31 	brhi	80007048 <log+0xd0>
80006fea:	4b 89       	lddpc	r9,800070c8 <log+0x150>
80006fec:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006ff0:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006ff4:	06 9a       	mov	r10,r3
80006ff6:	40 0b       	lddsp	r11,sp[0x0]
80006ff8:	5c 5b       	castu.b	r11
80006ffa:	68 0c       	ld.w	r12,r4[0x0]
80006ffc:	f0 1f 00 34 	mcall	800070cc <log+0x154>
							break;
80007000:	c2 98       	rjmp	80007052 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80007002:	4b 4c       	lddpc	r12,800070d0 <log+0x158>
80007004:	f0 1f 00 34 	mcall	800070d4 <log+0x15c>
80007008:	08 95       	mov	r5,r4
8000700a:	06 9c       	mov	r12,r3
							break;
8000700c:	c2 38       	rjmp	80007052 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
8000700e:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80007012:	06 9a       	mov	r10,r3
80007014:	40 0b       	lddsp	r11,sp[0x0]
80007016:	5c 5b       	castu.b	r11
80007018:	68 0c       	ld.w	r12,r4[0x0]
8000701a:	f0 1f 00 30 	mcall	800070d8 <log+0x160>
8000701e:	06 9c       	mov	r12,r3
							break;
80007020:	c1 98       	rjmp	80007052 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80007022:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80007026:	06 9b       	mov	r11,r3
80007028:	09 bc       	ld.ub	r12,r4[0x3]
8000702a:	f0 1f 00 2d 	mcall	800070dc <log+0x164>
8000702e:	06 9c       	mov	r12,r3
							break;
80007030:	c1 18       	rjmp	80007052 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80007032:	e8 c5 ff fc 	sub	r5,r4,-4
80007036:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80007038:	c0 d8       	rjmp	80007052 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
8000703a:	06 9b       	mov	r11,r3
8000703c:	32 5c       	mov	r12,37
8000703e:	f0 1f 00 28 	mcall	800070dc <log+0x164>
80007042:	08 95       	mov	r5,r4
80007044:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80007046:	c0 68       	rjmp	80007052 <log+0xda>
							
							default:
							log("I need relax.");
80007048:	4a 6c       	lddpc	r12,800070e0 <log+0x168>
8000704a:	f0 1f 00 23 	mcall	800070d4 <log+0x15c>
8000704e:	08 95       	mov	r5,r4
80007050:	06 9c       	mov	r12,r3
						}
						str++;
80007052:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80007054:	1a dc       	st.w	--sp,r12
80007056:	1a d6       	st.w	--sp,r6
80007058:	4a 3b       	lddpc	r11,800070e4 <log+0x16c>
8000705a:	0c 9c       	mov	r12,r6
8000705c:	f0 1f 00 23 	mcall	800070e8 <log+0x170>
80007060:	2f ed       	sub	sp,-8
80007062:	c0 a8       	rjmp	80007076 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007064:	2f f7       	sub	r7,-1
80007066:	1a d8       	st.w	--sp,r8
80007068:	1a d6       	st.w	--sp,r6
8000706a:	4a 1b       	lddpc	r11,800070ec <log+0x174>
8000706c:	0c 9c       	mov	r12,r6
8000706e:	f0 1f 00 1f 	mcall	800070e8 <log+0x170>
80007072:	08 95       	mov	r5,r4
80007074:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80007076:	0f 89       	ld.ub	r9,r7[0x0]
80007078:	30 08       	mov	r8,0
8000707a:	f0 09 18 00 	cp.b	r9,r8
8000707e:	c0 30       	breq	80007084 <log+0x10c>
80007080:	0a 94       	mov	r4,r5
80007082:	c9 2b       	rjmp	80006fa6 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80007084:	fa c7 fe f8 	sub	r7,sp,-264
80007088:	1a d7       	st.w	--sp,r7
8000708a:	49 ab       	lddpc	r11,800070f0 <log+0x178>
8000708c:	0e 9c       	mov	r12,r7
8000708e:	f0 1f 00 17 	mcall	800070e8 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80007092:	5c 5c       	castu.b	r12
80007094:	f8 c6 ff ff 	sub	r6,r12,-1
80007098:	0c 9c       	mov	r12,r6
8000709a:	f0 1f 00 17 	mcall	800070f4 <log+0x17c>
8000709e:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
800070a0:	0c 9a       	mov	r10,r6
800070a2:	0e 9b       	mov	r11,r7
800070a4:	f0 1f 00 15 	mcall	800070f8 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
800070a8:	30 09       	mov	r9,0
800070aa:	30 5a       	mov	r10,5
800070ac:	fa cb fe f8 	sub	r11,sp,-264
800070b0:	49 38       	lddpc	r8,800070fc <log+0x184>
800070b2:	70 0c       	ld.w	r12,r8[0x0]
800070b4:	f0 1f 00 13 	mcall	80007100 <log+0x188>
800070b8:	2f fd       	sub	sp,-4
	
	
}
800070ba:	fe 3d fd f8 	sub	sp,-520
800070be:	d8 32       	popm	r0-r7,pc
800070c0:	80 00       	ld.sh	r0,r0[0x0]
800070c2:	79 3c       	ld.w	r12,r12[0x4c]
800070c4:	00 00       	add	r0,r0
800070c6:	0d 64       	ld.uh	r4,--r6
800070c8:	80 00       	ld.sh	r0,r0[0x0]
800070ca:	da 28       	*unknown*
800070cc:	80 00       	ld.sh	r0,r0[0x0]
800070ce:	6e 9e       	ld.w	lr,r7[0x24]
800070d0:	80 00       	ld.sh	r0,r0[0x0]
800070d2:	dc d4       	*unknown*
800070d4:	80 00       	ld.sh	r0,r0[0x0]
800070d6:	6f 78       	ld.w	r8,r7[0x5c]
800070d8:	80 00       	ld.sh	r0,r0[0x0]
800070da:	6d ec       	ld.w	r12,r6[0x78]
800070dc:	80 00       	ld.sh	r0,r0[0x0]
800070de:	6d e8       	ld.w	r8,r6[0x78]
800070e0:	80 00       	ld.sh	r0,r0[0x0]
800070e2:	dc e4       	*unknown*
800070e4:	80 00       	ld.sh	r0,r0[0x0]
800070e6:	dc f4       	*unknown*
800070e8:	80 00       	ld.sh	r0,r0[0x0]
800070ea:	7c 2c       	ld.w	r12,lr[0x8]
800070ec:	80 00       	ld.sh	r0,r0[0x0]
800070ee:	dc fc       	*unknown*
800070f0:	80 00       	ld.sh	r0,r0[0x0]
800070f2:	dd 04       	*unknown*
800070f4:	80 00       	ld.sh	r0,r0[0x0]
800070f6:	5f ec       	srqs	r12
800070f8:	80 00       	ld.sh	r0,r0[0x0]
800070fa:	77 f4       	ld.w	r4,r11[0x7c]
800070fc:	00 00       	add	r0,r0
800070fe:	79 e8       	ld.w	r8,r12[0x78]
80007100:	80 00       	ld.sh	r0,r0[0x0]
80007102:	63 40       	ld.w	r0,r1[0x50]

80007104 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80007104:	d4 31       	pushm	r0-r7,lr
80007106:	fa cd 02 0c 	sub	sp,sp,524
8000710a:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
8000710c:	e0 6a 01 00 	mov	r10,256
80007110:	30 0b       	mov	r11,0
80007112:	fa cc fe f4 	sub	r12,sp,-268
80007116:	f0 1f 00 4c 	mcall	80007244 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
8000711a:	fa c4 fd d0 	sub	r4,sp,-560
8000711e:	30 0a       	mov	r10,0
80007120:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007122:	fa c3 ff fc 	sub	r3,sp,-4
80007126:	e0 61 01 00 	mov	r1,256
8000712a:	14 90       	mov	r0,r10
			
			if(*str == '%')
8000712c:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000712e:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007132:	02 9a       	mov	r10,r1
80007134:	00 9b       	mov	r11,r0
80007136:	06 9c       	mov	r12,r3
80007138:	f0 1f 00 43 	mcall	80007244 <logFromISR+0x140>
			
			if(*str == '%')
8000713c:	0f 88       	ld.ub	r8,r7[0x0]
8000713e:	e4 08 18 00 	cp.b	r8,r2
80007142:	c5 11       	brne	800071e4 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80007144:	ee c8 ff ff 	sub	r8,r7,-1
80007148:	11 89       	ld.ub	r9,r8[0x0]
8000714a:	4c 0a       	lddpc	r10,80007248 <logFromISR+0x144>
8000714c:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
8000714e:	23 09       	sub	r9,48
80007150:	30 9a       	mov	r10,9
80007152:	f4 09 18 00 	cp.b	r9,r10
80007156:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
8000715a:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000715e:	f7 b9 08 30 	subls	r9,48
80007162:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80007166:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
8000716a:	0f 88       	ld.ub	r8,r7[0x0]
8000716c:	22 58       	sub	r8,37
8000716e:	e0 48 00 53 	cp.w	r8,83
80007172:	e0 8b 00 2b 	brhi	800071c8 <logFromISR+0xc4>
80007176:	4b 69       	lddpc	r9,8000724c <logFromISR+0x148>
80007178:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
8000717c:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80007180:	06 9a       	mov	r10,r3
80007182:	40 0b       	lddsp	r11,sp[0x0]
80007184:	5c 5b       	castu.b	r11
80007186:	68 0c       	ld.w	r12,r4[0x0]
80007188:	f0 1f 00 32 	mcall	80007250 <logFromISR+0x14c>
					break;
8000718c:	c2 38       	rjmp	800071d2 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
8000718e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80007192:	06 9a       	mov	r10,r3
80007194:	40 0b       	lddsp	r11,sp[0x0]
80007196:	5c 5b       	castu.b	r11
80007198:	68 0c       	ld.w	r12,r4[0x0]
8000719a:	f0 1f 00 2f 	mcall	80007254 <logFromISR+0x150>
8000719e:	06 9c       	mov	r12,r3
					break;
800071a0:	c1 98       	rjmp	800071d2 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
800071a2:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
800071a6:	06 9b       	mov	r11,r3
800071a8:	09 bc       	ld.ub	r12,r4[0x3]
800071aa:	f0 1f 00 2c 	mcall	80007258 <logFromISR+0x154>
800071ae:	06 9c       	mov	r12,r3
					break;
800071b0:	c1 18       	rjmp	800071d2 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
800071b2:	e8 c5 ff fc 	sub	r5,r4,-4
800071b6:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
800071b8:	c0 d8       	rjmp	800071d2 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
800071ba:	06 9b       	mov	r11,r3
800071bc:	32 5c       	mov	r12,37
800071be:	f0 1f 00 27 	mcall	80007258 <logFromISR+0x154>
800071c2:	08 95       	mov	r5,r4
800071c4:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
800071c6:	c0 68       	rjmp	800071d2 <logFromISR+0xce>
					default:
					log("I need relax.");
800071c8:	4a 5c       	lddpc	r12,8000725c <logFromISR+0x158>
800071ca:	f0 1f 00 26 	mcall	80007260 <logFromISR+0x15c>
800071ce:	08 95       	mov	r5,r4
800071d0:	06 9c       	mov	r12,r3
				}
				str++;
800071d2:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800071d4:	1a dc       	st.w	--sp,r12
800071d6:	1a d6       	st.w	--sp,r6
800071d8:	4a 3b       	lddpc	r11,80007264 <logFromISR+0x160>
800071da:	0c 9c       	mov	r12,r6
800071dc:	f0 1f 00 23 	mcall	80007268 <logFromISR+0x164>
800071e0:	2f ed       	sub	sp,-8
800071e2:	c0 a8       	rjmp	800071f6 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800071e4:	2f f7       	sub	r7,-1
800071e6:	1a d8       	st.w	--sp,r8
800071e8:	1a d6       	st.w	--sp,r6
800071ea:	4a 1b       	lddpc	r11,8000726c <logFromISR+0x168>
800071ec:	0c 9c       	mov	r12,r6
800071ee:	f0 1f 00 1f 	mcall	80007268 <logFromISR+0x164>
800071f2:	08 95       	mov	r5,r4
800071f4:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
800071f6:	0f 89       	ld.ub	r9,r7[0x0]
800071f8:	30 08       	mov	r8,0
800071fa:	f0 09 18 00 	cp.b	r9,r8
800071fe:	c0 30       	breq	80007204 <logFromISR+0x100>
80007200:	0a 94       	mov	r4,r5
80007202:	c9 8b       	rjmp	80007132 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80007204:	fa c7 fe f4 	sub	r7,sp,-268
80007208:	1a d7       	st.w	--sp,r7
8000720a:	49 ab       	lddpc	r11,80007270 <logFromISR+0x16c>
8000720c:	0e 9c       	mov	r12,r7
8000720e:	f0 1f 00 17 	mcall	80007268 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80007212:	5c 5c       	castu.b	r12
80007214:	f8 c6 ff ff 	sub	r6,r12,-1
80007218:	0c 9c       	mov	r12,r6
8000721a:	f0 1f 00 17 	mcall	80007274 <logFromISR+0x170>
8000721e:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80007220:	0c 9a       	mov	r10,r6
80007222:	0e 9b       	mov	r11,r7
80007224:	f0 1f 00 15 	mcall	80007278 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80007228:	30 09       	mov	r9,0
8000722a:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
8000722c:	fa ca fe f8 	sub	r10,sp,-264
80007230:	fa cb fe f4 	sub	r11,sp,-268
80007234:	49 28       	lddpc	r8,8000727c <logFromISR+0x178>
80007236:	70 0c       	ld.w	r12,r8[0x0]
80007238:	f0 1f 00 12 	mcall	80007280 <logFromISR+0x17c>
8000723c:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
8000723e:	fe 3d fd f4 	sub	sp,-524
80007242:	d8 32       	popm	r0-r7,pc
80007244:	80 00       	ld.sh	r0,r0[0x0]
80007246:	79 3c       	ld.w	r12,r12[0x4c]
80007248:	00 00       	add	r0,r0
8000724a:	0d 65       	ld.uh	r5,--r6
8000724c:	80 00       	ld.sh	r0,r0[0x0]
8000724e:	db 78       	*unknown*
80007250:	80 00       	ld.sh	r0,r0[0x0]
80007252:	6e 9e       	ld.w	lr,r7[0x24]
80007254:	80 00       	ld.sh	r0,r0[0x0]
80007256:	6d ec       	ld.w	r12,r6[0x78]
80007258:	80 00       	ld.sh	r0,r0[0x0]
8000725a:	6d e8       	ld.w	r8,r6[0x78]
8000725c:	80 00       	ld.sh	r0,r0[0x0]
8000725e:	dc e4       	*unknown*
80007260:	80 00       	ld.sh	r0,r0[0x0]
80007262:	6f 78       	ld.w	r8,r7[0x5c]
80007264:	80 00       	ld.sh	r0,r0[0x0]
80007266:	dc f4       	*unknown*
80007268:	80 00       	ld.sh	r0,r0[0x0]
8000726a:	7c 2c       	ld.w	r12,lr[0x8]
8000726c:	80 00       	ld.sh	r0,r0[0x0]
8000726e:	dc fc       	*unknown*
80007270:	80 00       	ld.sh	r0,r0[0x0]
80007272:	dd 04       	*unknown*
80007274:	80 00       	ld.sh	r0,r0[0x0]
80007276:	5f ec       	srqs	r12
80007278:	80 00       	ld.sh	r0,r0[0x0]
8000727a:	77 f4       	ld.w	r4,r11[0x7c]
8000727c:	00 00       	add	r0,r0
8000727e:	79 e8       	ld.w	r8,r12[0x78]
80007280:	80 00       	ld.sh	r0,r0[0x0]
80007282:	62 f0       	ld.w	r0,r1[0x3c]

80007284 <log_init>:
		
	return str;
}

void log_init(void)
{
80007284:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80007286:	30 2b       	mov	r11,2
80007288:	48 fc       	lddpc	r12,800072c4 <log_init+0x40>
8000728a:	f0 1f 00 10 	mcall	800072c8 <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
8000728e:	e0 6a 36 00 	mov	r10,13824
80007292:	ea 1a 01 6e 	orh	r10,0x16e
80007296:	48 eb       	lddpc	r11,800072cc <log_init+0x48>
80007298:	fe 7c 18 00 	mov	r12,-59392
8000729c:	f0 1f 00 0d 	mcall	800072d0 <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
800072a0:	30 4b       	mov	r11,4
800072a2:	33 2c       	mov	r12,50
800072a4:	f0 1f 00 0c 	mcall	800072d4 <log_init+0x50>
800072a8:	48 c8       	lddpc	r8,800072d8 <log_init+0x54>
800072aa:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
800072ac:	30 09       	mov	r9,0
800072ae:	1a d9       	st.w	--sp,r9
800072b0:	1a d9       	st.w	--sp,r9
800072b2:	1a d9       	st.w	--sp,r9
800072b4:	30 28       	mov	r8,2
800072b6:	36 4a       	mov	r10,100
800072b8:	48 9b       	lddpc	r11,800072dc <log_init+0x58>
800072ba:	48 ac       	lddpc	r12,800072e0 <log_init+0x5c>
800072bc:	f0 1f 00 0a 	mcall	800072e4 <log_init+0x60>
800072c0:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
800072c2:	d8 02       	popm	pc
800072c4:	80 00       	ld.sh	r0,r0[0x0]
800072c6:	dd 10       	acall	0xd1
800072c8:	80 00       	ld.sh	r0,r0[0x0]
800072ca:	54 cc       	stdsp	sp[0x130],r12
800072cc:	80 00       	ld.sh	r0,r0[0x0]
800072ce:	dc c8       	*unknown*
800072d0:	80 00       	ld.sh	r0,r0[0x0]
800072d2:	5b 50       	cp.w	r0,-11
800072d4:	80 00       	ld.sh	r0,r0[0x0]
800072d6:	64 98       	ld.w	r8,r2[0x24]
800072d8:	00 00       	add	r0,r0
800072da:	79 e8       	ld.w	r8,r12[0x78]
800072dc:	80 00       	ld.sh	r0,r0[0x0]
800072de:	dd 0c       	*unknown*
800072e0:	80 00       	ld.sh	r0,r0[0x0]
800072e2:	72 e8       	ld.w	r8,r9[0x38]
800072e4:	80 00       	ld.sh	r0,r0[0x0]
800072e6:	6b b4       	ld.w	r4,r5[0x6c]

800072e8 <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
800072e8:	eb cd 40 f8 	pushm	r3-r7,lr
800072ec:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800072ee:	48 c7       	lddpc	r7,8000731c <task_log+0x34>
800072f0:	30 05       	mov	r5,0
800072f2:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
800072f4:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800072f8:	0a 99       	mov	r9,r5
800072fa:	08 9a       	mov	r10,r4
800072fc:	1a 9b       	mov	r11,sp
800072fe:	6e 0c       	ld.w	r12,r7[0x0]
80007300:	f0 1f 00 08 	mcall	80007320 <task_log+0x38>
80007304:	58 1c       	cp.w	r12,1
80007306:	cf 91       	brne	800072f8 <task_log+0x10>
		{
			if( NULL != str)
80007308:	40 0b       	lddsp	r11,sp[0x0]
8000730a:	58 0b       	cp.w	r11,0
8000730c:	cf 60       	breq	800072f8 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
8000730e:	06 9c       	mov	r12,r3
80007310:	f0 1f 00 05 	mcall	80007324 <task_log+0x3c>
				vPortFree(str);
80007314:	40 0c       	lddsp	r12,sp[0x0]
80007316:	f0 1f 00 05 	mcall	80007328 <task_log+0x40>
8000731a:	ce fb       	rjmp	800072f8 <task_log+0x10>
8000731c:	00 00       	add	r0,r0
8000731e:	79 e8       	ld.w	r8,r12[0x78]
80007320:	80 00       	ld.sh	r0,r0[0x0]
80007322:	61 34       	ld.w	r4,r0[0x4c]
80007324:	80 00       	ld.sh	r0,r0[0x0]
80007326:	5b 00       	cp.w	r0,-16
80007328:	80 00       	ld.sh	r0,r0[0x0]
8000732a:	5f c4       	srvs	r4

8000732c <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
8000732c:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
8000732e:	fe 78 10 00 	mov	r8,-61440
80007332:	30 19       	mov	r9,1
80007334:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80007338:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
8000733c:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80007340:	d3 03       	ssrf	0x10
	local_start_pll0();
80007342:	f0 1f 00 0c 	mcall	80007370 <main+0x44>
		
	INTC_init_interrupts();
80007346:	f0 1f 00 0c 	mcall	80007374 <main+0x48>
		
	log_init();
8000734a:	f0 1f 00 0c 	mcall	80007378 <main+0x4c>
	log("----start debug----");
8000734e:	48 cc       	lddpc	r12,8000737c <main+0x50>
80007350:	f0 1f 00 0c 	mcall	80007380 <main+0x54>
	
	xg_flashc_init();
80007354:	f0 1f 00 0c 	mcall	80007384 <main+0x58>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
80007358:	f0 1f 00 0c 	mcall	80007388 <main+0x5c>
		
	app_init();
8000735c:	f0 1f 00 0c 	mcall	8000738c <main+0x60>
	
	//xg_rtc_init();
		
	xcmp_init();
80007360:	f0 1f 00 0c 	mcall	80007390 <main+0x64>

	local_start_timer();
80007364:	f0 1f 00 0c 	mcall	80007394 <main+0x68>
		
	vTaskStartScheduler();
80007368:	f0 1f 00 0c 	mcall	80007398 <main+0x6c>
	return 0;
	
}
8000736c:	d8 0a       	popm	pc,r12=0
8000736e:	00 00       	add	r0,r0
80007370:	80 00       	ld.sh	r0,r0[0x0]
80007372:	53 48       	stdsp	sp[0xd0],r8
80007374:	80 00       	ld.sh	r0,r0[0x0]
80007376:	55 d0       	stdsp	sp[0x174],r0
80007378:	80 00       	ld.sh	r0,r0[0x0]
8000737a:	72 84       	ld.w	r4,r9[0x20]
8000737c:	80 00       	ld.sh	r0,r0[0x0]
8000737e:	dd 20       	acall	0xd2
80007380:	80 00       	ld.sh	r0,r0[0x0]
80007382:	6f 78       	ld.w	r8,r7[0x5c]
80007384:	80 00       	ld.sh	r0,r0[0x0]
80007386:	53 dc       	stdsp	sp[0xf4],r12
80007388:	80 00       	ld.sh	r0,r0[0x0]
8000738a:	52 a8       	stdsp	sp[0xa8],r8
8000738c:	80 00       	ld.sh	r0,r0[0x0]
8000738e:	27 34       	sub	r4,115
80007390:	80 00       	ld.sh	r0,r0[0x0]
80007392:	40 ac       	lddsp	r12,sp[0x28]
80007394:	80 00       	ld.sh	r0,r0[0x0]
80007396:	53 1c       	stdsp	sp[0xc4],r12
80007398:	80 00       	ld.sh	r0,r0[0x0]
8000739a:	6d 9c       	ld.w	r12,r6[0x64]

8000739c <free>:
8000739c:	d4 01       	pushm	lr
8000739e:	e0 68 0a 3c 	mov	r8,2620
800073a2:	18 9b       	mov	r11,r12
800073a4:	70 0c       	ld.w	r12,r8[0x0]
800073a6:	e0 a0 1e 61 	rcall	8000b068 <_free_r>
800073aa:	d8 02       	popm	pc

800073ac <malloc>:
800073ac:	d4 01       	pushm	lr
800073ae:	e0 68 0a 3c 	mov	r8,2620
800073b2:	18 9b       	mov	r11,r12
800073b4:	70 0c       	ld.w	r12,r8[0x0]
800073b6:	c0 3c       	rcall	800073bc <_malloc_r>
800073b8:	d8 02       	popm	pc
800073ba:	d7 03       	nop

800073bc <_malloc_r>:
800073bc:	d4 31       	pushm	r0-r7,lr
800073be:	f6 c8 ff f5 	sub	r8,r11,-11
800073c2:	18 95       	mov	r5,r12
800073c4:	10 97       	mov	r7,r8
800073c6:	e0 17 ff f8 	andl	r7,0xfff8
800073ca:	59 68       	cp.w	r8,22
800073cc:	f9 b7 08 10 	movls	r7,16
800073d0:	16 37       	cp.w	r7,r11
800073d2:	5f 38       	srlo	r8
800073d4:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800073d8:	c0 50       	breq	800073e2 <_malloc_r+0x26>
800073da:	30 c8       	mov	r8,12
800073dc:	99 38       	st.w	r12[0xc],r8
800073de:	e0 8f 01 fa 	bral	800077d2 <_malloc_r+0x416>
800073e2:	fe b0 f5 a7 	rcall	80005f30 <__malloc_lock>
800073e6:	e0 47 01 f7 	cp.w	r7,503
800073ea:	e0 8b 00 1d 	brhi	80007424 <_malloc_r+0x68>
800073ee:	ee 03 16 03 	lsr	r3,r7,0x3
800073f2:	e0 68 05 3c 	mov	r8,1340
800073f6:	f0 03 00 38 	add	r8,r8,r3<<0x3
800073fa:	70 36       	ld.w	r6,r8[0xc]
800073fc:	10 36       	cp.w	r6,r8
800073fe:	c0 61       	brne	8000740a <_malloc_r+0x4e>
80007400:	ec c8 ff f8 	sub	r8,r6,-8
80007404:	70 36       	ld.w	r6,r8[0xc]
80007406:	10 36       	cp.w	r6,r8
80007408:	c0 c0       	breq	80007420 <_malloc_r+0x64>
8000740a:	6c 18       	ld.w	r8,r6[0x4]
8000740c:	e0 18 ff fc 	andl	r8,0xfffc
80007410:	6c 3a       	ld.w	r10,r6[0xc]
80007412:	ec 08 00 09 	add	r9,r6,r8
80007416:	0a 9c       	mov	r12,r5
80007418:	6c 28       	ld.w	r8,r6[0x8]
8000741a:	95 28       	st.w	r10[0x8],r8
8000741c:	91 3a       	st.w	r8[0xc],r10
8000741e:	c4 78       	rjmp	800074ac <_malloc_r+0xf0>
80007420:	2f e3       	sub	r3,-2
80007422:	c4 d8       	rjmp	800074bc <_malloc_r+0x100>
80007424:	ee 03 16 09 	lsr	r3,r7,0x9
80007428:	c0 41       	brne	80007430 <_malloc_r+0x74>
8000742a:	ee 03 16 03 	lsr	r3,r7,0x3
8000742e:	c2 68       	rjmp	8000747a <_malloc_r+0xbe>
80007430:	58 43       	cp.w	r3,4
80007432:	e0 8b 00 06 	brhi	8000743e <_malloc_r+0x82>
80007436:	ee 03 16 06 	lsr	r3,r7,0x6
8000743a:	2c 83       	sub	r3,-56
8000743c:	c1 f8       	rjmp	8000747a <_malloc_r+0xbe>
8000743e:	59 43       	cp.w	r3,20
80007440:	e0 8b 00 04 	brhi	80007448 <_malloc_r+0x8c>
80007444:	2a 53       	sub	r3,-91
80007446:	c1 a8       	rjmp	8000747a <_malloc_r+0xbe>
80007448:	e0 43 00 54 	cp.w	r3,84
8000744c:	e0 8b 00 06 	brhi	80007458 <_malloc_r+0x9c>
80007450:	ee 03 16 0c 	lsr	r3,r7,0xc
80007454:	29 23       	sub	r3,-110
80007456:	c1 28       	rjmp	8000747a <_malloc_r+0xbe>
80007458:	e0 43 01 54 	cp.w	r3,340
8000745c:	e0 8b 00 06 	brhi	80007468 <_malloc_r+0xac>
80007460:	ee 03 16 0f 	lsr	r3,r7,0xf
80007464:	28 93       	sub	r3,-119
80007466:	c0 a8       	rjmp	8000747a <_malloc_r+0xbe>
80007468:	e0 43 05 54 	cp.w	r3,1364
8000746c:	e0 88 00 04 	brls	80007474 <_malloc_r+0xb8>
80007470:	37 e3       	mov	r3,126
80007472:	c0 48       	rjmp	8000747a <_malloc_r+0xbe>
80007474:	ee 03 16 12 	lsr	r3,r7,0x12
80007478:	28 43       	sub	r3,-124
8000747a:	e0 6a 05 3c 	mov	r10,1340
8000747e:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80007482:	74 36       	ld.w	r6,r10[0xc]
80007484:	c1 98       	rjmp	800074b6 <_malloc_r+0xfa>
80007486:	6c 19       	ld.w	r9,r6[0x4]
80007488:	e0 19 ff fc 	andl	r9,0xfffc
8000748c:	f2 07 01 0b 	sub	r11,r9,r7
80007490:	58 fb       	cp.w	r11,15
80007492:	e0 8a 00 04 	brle	8000749a <_malloc_r+0xde>
80007496:	20 13       	sub	r3,1
80007498:	c1 18       	rjmp	800074ba <_malloc_r+0xfe>
8000749a:	6c 38       	ld.w	r8,r6[0xc]
8000749c:	58 0b       	cp.w	r11,0
8000749e:	c0 b5       	brlt	800074b4 <_malloc_r+0xf8>
800074a0:	6c 2a       	ld.w	r10,r6[0x8]
800074a2:	ec 09 00 09 	add	r9,r6,r9
800074a6:	0a 9c       	mov	r12,r5
800074a8:	91 2a       	st.w	r8[0x8],r10
800074aa:	95 38       	st.w	r10[0xc],r8
800074ac:	72 18       	ld.w	r8,r9[0x4]
800074ae:	a1 a8       	sbr	r8,0x0
800074b0:	93 18       	st.w	r9[0x4],r8
800074b2:	cb c8       	rjmp	8000762a <_malloc_r+0x26e>
800074b4:	10 96       	mov	r6,r8
800074b6:	14 36       	cp.w	r6,r10
800074b8:	ce 71       	brne	80007486 <_malloc_r+0xca>
800074ba:	2f f3       	sub	r3,-1
800074bc:	e0 6a 05 3c 	mov	r10,1340
800074c0:	f4 cc ff f8 	sub	r12,r10,-8
800074c4:	78 26       	ld.w	r6,r12[0x8]
800074c6:	18 36       	cp.w	r6,r12
800074c8:	c6 c0       	breq	800075a0 <_malloc_r+0x1e4>
800074ca:	6c 19       	ld.w	r9,r6[0x4]
800074cc:	e0 19 ff fc 	andl	r9,0xfffc
800074d0:	f2 07 01 08 	sub	r8,r9,r7
800074d4:	58 f8       	cp.w	r8,15
800074d6:	e0 89 00 8f 	brgt	800075f4 <_malloc_r+0x238>
800074da:	99 3c       	st.w	r12[0xc],r12
800074dc:	99 2c       	st.w	r12[0x8],r12
800074de:	58 08       	cp.w	r8,0
800074e0:	c0 55       	brlt	800074ea <_malloc_r+0x12e>
800074e2:	ec 09 00 09 	add	r9,r6,r9
800074e6:	0a 9c       	mov	r12,r5
800074e8:	ce 2b       	rjmp	800074ac <_malloc_r+0xf0>
800074ea:	e0 49 01 ff 	cp.w	r9,511
800074ee:	e0 8b 00 13 	brhi	80007514 <_malloc_r+0x158>
800074f2:	a3 99       	lsr	r9,0x3
800074f4:	f4 09 00 38 	add	r8,r10,r9<<0x3
800074f8:	70 2b       	ld.w	r11,r8[0x8]
800074fa:	8d 38       	st.w	r6[0xc],r8
800074fc:	8d 2b       	st.w	r6[0x8],r11
800074fe:	97 36       	st.w	r11[0xc],r6
80007500:	91 26       	st.w	r8[0x8],r6
80007502:	a3 49       	asr	r9,0x2
80007504:	74 18       	ld.w	r8,r10[0x4]
80007506:	30 1b       	mov	r11,1
80007508:	f6 09 09 49 	lsl	r9,r11,r9
8000750c:	f1 e9 10 09 	or	r9,r8,r9
80007510:	95 19       	st.w	r10[0x4],r9
80007512:	c4 78       	rjmp	800075a0 <_malloc_r+0x1e4>
80007514:	f2 0a 16 09 	lsr	r10,r9,0x9
80007518:	58 4a       	cp.w	r10,4
8000751a:	e0 8b 00 07 	brhi	80007528 <_malloc_r+0x16c>
8000751e:	f2 0a 16 06 	lsr	r10,r9,0x6
80007522:	2c 8a       	sub	r10,-56
80007524:	c2 08       	rjmp	80007564 <_malloc_r+0x1a8>
80007526:	d7 03       	nop
80007528:	59 4a       	cp.w	r10,20
8000752a:	e0 8b 00 04 	brhi	80007532 <_malloc_r+0x176>
8000752e:	2a 5a       	sub	r10,-91
80007530:	c1 a8       	rjmp	80007564 <_malloc_r+0x1a8>
80007532:	e0 4a 00 54 	cp.w	r10,84
80007536:	e0 8b 00 06 	brhi	80007542 <_malloc_r+0x186>
8000753a:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000753e:	29 2a       	sub	r10,-110
80007540:	c1 28       	rjmp	80007564 <_malloc_r+0x1a8>
80007542:	e0 4a 01 54 	cp.w	r10,340
80007546:	e0 8b 00 06 	brhi	80007552 <_malloc_r+0x196>
8000754a:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000754e:	28 9a       	sub	r10,-119
80007550:	c0 a8       	rjmp	80007564 <_malloc_r+0x1a8>
80007552:	e0 4a 05 54 	cp.w	r10,1364
80007556:	e0 88 00 04 	brls	8000755e <_malloc_r+0x1a2>
8000755a:	37 ea       	mov	r10,126
8000755c:	c0 48       	rjmp	80007564 <_malloc_r+0x1a8>
8000755e:	f2 0a 16 12 	lsr	r10,r9,0x12
80007562:	28 4a       	sub	r10,-124
80007564:	e0 6b 05 3c 	mov	r11,1340
80007568:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000756c:	68 28       	ld.w	r8,r4[0x8]
8000756e:	08 38       	cp.w	r8,r4
80007570:	c0 e1       	brne	8000758c <_malloc_r+0x1d0>
80007572:	76 19       	ld.w	r9,r11[0x4]
80007574:	a3 4a       	asr	r10,0x2
80007576:	30 1e       	mov	lr,1
80007578:	fc 0a 09 4a 	lsl	r10,lr,r10
8000757c:	f3 ea 10 0a 	or	r10,r9,r10
80007580:	10 99       	mov	r9,r8
80007582:	97 1a       	st.w	r11[0x4],r10
80007584:	c0 a8       	rjmp	80007598 <_malloc_r+0x1dc>
80007586:	70 28       	ld.w	r8,r8[0x8]
80007588:	08 38       	cp.w	r8,r4
8000758a:	c0 60       	breq	80007596 <_malloc_r+0x1da>
8000758c:	70 1a       	ld.w	r10,r8[0x4]
8000758e:	e0 1a ff fc 	andl	r10,0xfffc
80007592:	14 39       	cp.w	r9,r10
80007594:	cf 93       	brcs	80007586 <_malloc_r+0x1ca>
80007596:	70 39       	ld.w	r9,r8[0xc]
80007598:	8d 39       	st.w	r6[0xc],r9
8000759a:	8d 28       	st.w	r6[0x8],r8
8000759c:	91 36       	st.w	r8[0xc],r6
8000759e:	93 26       	st.w	r9[0x8],r6
800075a0:	e6 08 14 02 	asr	r8,r3,0x2
800075a4:	30 1b       	mov	r11,1
800075a6:	e0 64 05 3c 	mov	r4,1340
800075aa:	f6 08 09 4b 	lsl	r11,r11,r8
800075ae:	68 18       	ld.w	r8,r4[0x4]
800075b0:	10 3b       	cp.w	r11,r8
800075b2:	e0 8b 00 6b 	brhi	80007688 <_malloc_r+0x2cc>
800075b6:	f7 e8 00 09 	and	r9,r11,r8
800075ba:	c0 b1       	brne	800075d0 <_malloc_r+0x214>
800075bc:	e0 13 ff fc 	andl	r3,0xfffc
800075c0:	a1 7b       	lsl	r11,0x1
800075c2:	2f c3       	sub	r3,-4
800075c4:	c0 38       	rjmp	800075ca <_malloc_r+0x20e>
800075c6:	2f c3       	sub	r3,-4
800075c8:	a1 7b       	lsl	r11,0x1
800075ca:	f7 e8 00 09 	and	r9,r11,r8
800075ce:	cf c0       	breq	800075c6 <_malloc_r+0x20a>
800075d0:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800075d4:	06 92       	mov	r2,r3
800075d6:	1c 91       	mov	r1,lr
800075d8:	62 36       	ld.w	r6,r1[0xc]
800075da:	c2 e8       	rjmp	80007636 <_malloc_r+0x27a>
800075dc:	6c 1a       	ld.w	r10,r6[0x4]
800075de:	e0 1a ff fc 	andl	r10,0xfffc
800075e2:	f4 07 01 08 	sub	r8,r10,r7
800075e6:	58 f8       	cp.w	r8,15
800075e8:	e0 8a 00 15 	brle	80007612 <_malloc_r+0x256>
800075ec:	6c 3a       	ld.w	r10,r6[0xc]
800075ee:	6c 29       	ld.w	r9,r6[0x8]
800075f0:	95 29       	st.w	r10[0x8],r9
800075f2:	93 3a       	st.w	r9[0xc],r10
800075f4:	0e 99       	mov	r9,r7
800075f6:	ec 07 00 07 	add	r7,r6,r7
800075fa:	a1 a9       	sbr	r9,0x0
800075fc:	99 37       	st.w	r12[0xc],r7
800075fe:	99 27       	st.w	r12[0x8],r7
80007600:	8d 19       	st.w	r6[0x4],r9
80007602:	ee 08 09 08 	st.w	r7[r8],r8
80007606:	8f 2c       	st.w	r7[0x8],r12
80007608:	8f 3c       	st.w	r7[0xc],r12
8000760a:	a1 a8       	sbr	r8,0x0
8000760c:	0a 9c       	mov	r12,r5
8000760e:	8f 18       	st.w	r7[0x4],r8
80007610:	c0 d8       	rjmp	8000762a <_malloc_r+0x26e>
80007612:	6c 39       	ld.w	r9,r6[0xc]
80007614:	58 08       	cp.w	r8,0
80007616:	c0 f5       	brlt	80007634 <_malloc_r+0x278>
80007618:	ec 0a 00 0a 	add	r10,r6,r10
8000761c:	74 18       	ld.w	r8,r10[0x4]
8000761e:	a1 a8       	sbr	r8,0x0
80007620:	0a 9c       	mov	r12,r5
80007622:	95 18       	st.w	r10[0x4],r8
80007624:	6c 28       	ld.w	r8,r6[0x8]
80007626:	93 28       	st.w	r9[0x8],r8
80007628:	91 39       	st.w	r8[0xc],r9
8000762a:	fe b0 f4 89 	rcall	80005f3c <__malloc_unlock>
8000762e:	ec cc ff f8 	sub	r12,r6,-8
80007632:	d8 32       	popm	r0-r7,pc
80007634:	12 96       	mov	r6,r9
80007636:	02 36       	cp.w	r6,r1
80007638:	cd 21       	brne	800075dc <_malloc_r+0x220>
8000763a:	2f f2       	sub	r2,-1
8000763c:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80007640:	c0 30       	breq	80007646 <_malloc_r+0x28a>
80007642:	2f 81       	sub	r1,-8
80007644:	cc ab       	rjmp	800075d8 <_malloc_r+0x21c>
80007646:	1c 98       	mov	r8,lr
80007648:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
8000764c:	c0 81       	brne	8000765c <_malloc_r+0x2a0>
8000764e:	68 19       	ld.w	r9,r4[0x4]
80007650:	f6 08 11 ff 	rsub	r8,r11,-1
80007654:	f3 e8 00 08 	and	r8,r9,r8
80007658:	89 18       	st.w	r4[0x4],r8
8000765a:	c0 78       	rjmp	80007668 <_malloc_r+0x2ac>
8000765c:	f0 c9 00 08 	sub	r9,r8,8
80007660:	20 13       	sub	r3,1
80007662:	70 08       	ld.w	r8,r8[0x0]
80007664:	12 38       	cp.w	r8,r9
80007666:	cf 10       	breq	80007648 <_malloc_r+0x28c>
80007668:	a1 7b       	lsl	r11,0x1
8000766a:	68 18       	ld.w	r8,r4[0x4]
8000766c:	10 3b       	cp.w	r11,r8
8000766e:	e0 8b 00 0d 	brhi	80007688 <_malloc_r+0x2cc>
80007672:	58 0b       	cp.w	r11,0
80007674:	c0 a0       	breq	80007688 <_malloc_r+0x2cc>
80007676:	04 93       	mov	r3,r2
80007678:	c0 38       	rjmp	8000767e <_malloc_r+0x2c2>
8000767a:	2f c3       	sub	r3,-4
8000767c:	a1 7b       	lsl	r11,0x1
8000767e:	f7 e8 00 09 	and	r9,r11,r8
80007682:	ca 71       	brne	800075d0 <_malloc_r+0x214>
80007684:	cf bb       	rjmp	8000767a <_malloc_r+0x2be>
80007686:	d7 03       	nop
80007688:	68 23       	ld.w	r3,r4[0x8]
8000768a:	66 12       	ld.w	r2,r3[0x4]
8000768c:	e0 12 ff fc 	andl	r2,0xfffc
80007690:	0e 32       	cp.w	r2,r7
80007692:	5f 39       	srlo	r9
80007694:	e4 07 01 08 	sub	r8,r2,r7
80007698:	58 f8       	cp.w	r8,15
8000769a:	5f aa       	srle	r10
8000769c:	f5 e9 10 09 	or	r9,r10,r9
800076a0:	e0 80 00 9a 	breq	800077d4 <_malloc_r+0x418>
800076a4:	e0 68 0d 70 	mov	r8,3440
800076a8:	70 01       	ld.w	r1,r8[0x0]
800076aa:	e0 68 09 48 	mov	r8,2376
800076ae:	2f 01       	sub	r1,-16
800076b0:	70 08       	ld.w	r8,r8[0x0]
800076b2:	0e 01       	add	r1,r7
800076b4:	5b f8       	cp.w	r8,-1
800076b6:	c0 40       	breq	800076be <_malloc_r+0x302>
800076b8:	28 11       	sub	r1,-127
800076ba:	e0 11 ff 80 	andl	r1,0xff80
800076be:	02 9b       	mov	r11,r1
800076c0:	0a 9c       	mov	r12,r5
800076c2:	e0 a0 02 a5 	rcall	80007c0c <_sbrk_r>
800076c6:	18 96       	mov	r6,r12
800076c8:	5b fc       	cp.w	r12,-1
800076ca:	c7 50       	breq	800077b4 <_malloc_r+0x3f8>
800076cc:	e6 02 00 08 	add	r8,r3,r2
800076d0:	10 3c       	cp.w	r12,r8
800076d2:	c0 32       	brcc	800076d8 <_malloc_r+0x31c>
800076d4:	08 33       	cp.w	r3,r4
800076d6:	c6 f1       	brne	800077b4 <_malloc_r+0x3f8>
800076d8:	e0 6a 0d 74 	mov	r10,3444
800076dc:	74 09       	ld.w	r9,r10[0x0]
800076de:	e2 09 00 09 	add	r9,r1,r9
800076e2:	95 09       	st.w	r10[0x0],r9
800076e4:	10 36       	cp.w	r6,r8
800076e6:	c0 a1       	brne	800076fa <_malloc_r+0x33e>
800076e8:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800076ec:	c0 71       	brne	800076fa <_malloc_r+0x33e>
800076ee:	e2 02 00 02 	add	r2,r1,r2
800076f2:	68 28       	ld.w	r8,r4[0x8]
800076f4:	a1 a2       	sbr	r2,0x0
800076f6:	91 12       	st.w	r8[0x4],r2
800076f8:	c4 f8       	rjmp	80007796 <_malloc_r+0x3da>
800076fa:	e0 6a 09 48 	mov	r10,2376
800076fe:	74 0b       	ld.w	r11,r10[0x0]
80007700:	5b fb       	cp.w	r11,-1
80007702:	c0 31       	brne	80007708 <_malloc_r+0x34c>
80007704:	95 06       	st.w	r10[0x0],r6
80007706:	c0 78       	rjmp	80007714 <_malloc_r+0x358>
80007708:	ec 09 00 09 	add	r9,r6,r9
8000770c:	e0 6a 0d 74 	mov	r10,3444
80007710:	10 19       	sub	r9,r8
80007712:	95 09       	st.w	r10[0x0],r9
80007714:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80007718:	f0 09 11 08 	rsub	r9,r8,8
8000771c:	58 08       	cp.w	r8,0
8000771e:	f2 08 17 10 	movne	r8,r9
80007722:	ed d8 e1 06 	addne	r6,r6,r8
80007726:	28 08       	sub	r8,-128
80007728:	ec 01 00 01 	add	r1,r6,r1
8000772c:	0a 9c       	mov	r12,r5
8000772e:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80007732:	f0 01 01 01 	sub	r1,r8,r1
80007736:	02 9b       	mov	r11,r1
80007738:	e0 a0 02 6a 	rcall	80007c0c <_sbrk_r>
8000773c:	e0 68 0d 74 	mov	r8,3444
80007740:	5b fc       	cp.w	r12,-1
80007742:	ec 0c 17 00 	moveq	r12,r6
80007746:	f9 b1 00 00 	moveq	r1,0
8000774a:	70 09       	ld.w	r9,r8[0x0]
8000774c:	0c 1c       	sub	r12,r6
8000774e:	89 26       	st.w	r4[0x8],r6
80007750:	02 0c       	add	r12,r1
80007752:	12 01       	add	r1,r9
80007754:	a1 ac       	sbr	r12,0x0
80007756:	91 01       	st.w	r8[0x0],r1
80007758:	8d 1c       	st.w	r6[0x4],r12
8000775a:	08 33       	cp.w	r3,r4
8000775c:	c1 d0       	breq	80007796 <_malloc_r+0x3da>
8000775e:	58 f2       	cp.w	r2,15
80007760:	e0 8b 00 05 	brhi	8000776a <_malloc_r+0x3ae>
80007764:	30 18       	mov	r8,1
80007766:	8d 18       	st.w	r6[0x4],r8
80007768:	c2 68       	rjmp	800077b4 <_malloc_r+0x3f8>
8000776a:	30 59       	mov	r9,5
8000776c:	20 c2       	sub	r2,12
8000776e:	e0 12 ff f8 	andl	r2,0xfff8
80007772:	e6 02 00 08 	add	r8,r3,r2
80007776:	91 29       	st.w	r8[0x8],r9
80007778:	91 19       	st.w	r8[0x4],r9
8000777a:	66 18       	ld.w	r8,r3[0x4]
8000777c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007780:	e5 e8 10 08 	or	r8,r2,r8
80007784:	87 18       	st.w	r3[0x4],r8
80007786:	58 f2       	cp.w	r2,15
80007788:	e0 88 00 07 	brls	80007796 <_malloc_r+0x3da>
8000778c:	e6 cb ff f8 	sub	r11,r3,-8
80007790:	0a 9c       	mov	r12,r5
80007792:	e0 a0 1c 6b 	rcall	8000b068 <_free_r>
80007796:	e0 69 0d 6c 	mov	r9,3436
8000779a:	72 0a       	ld.w	r10,r9[0x0]
8000779c:	e0 68 0d 74 	mov	r8,3444
800077a0:	70 08       	ld.w	r8,r8[0x0]
800077a2:	14 38       	cp.w	r8,r10
800077a4:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800077a8:	e0 69 0d 68 	mov	r9,3432
800077ac:	72 0a       	ld.w	r10,r9[0x0]
800077ae:	14 38       	cp.w	r8,r10
800077b0:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800077b4:	68 28       	ld.w	r8,r4[0x8]
800077b6:	70 18       	ld.w	r8,r8[0x4]
800077b8:	e0 18 ff fc 	andl	r8,0xfffc
800077bc:	0e 38       	cp.w	r8,r7
800077be:	5f 39       	srlo	r9
800077c0:	0e 18       	sub	r8,r7
800077c2:	58 f8       	cp.w	r8,15
800077c4:	5f aa       	srle	r10
800077c6:	f5 e9 10 09 	or	r9,r10,r9
800077ca:	c0 50       	breq	800077d4 <_malloc_r+0x418>
800077cc:	0a 9c       	mov	r12,r5
800077ce:	fe b0 f3 b7 	rcall	80005f3c <__malloc_unlock>
800077d2:	d8 3a       	popm	r0-r7,pc,r12=0
800077d4:	68 26       	ld.w	r6,r4[0x8]
800077d6:	a1 a8       	sbr	r8,0x0
800077d8:	0e 99       	mov	r9,r7
800077da:	a1 a9       	sbr	r9,0x0
800077dc:	8d 19       	st.w	r6[0x4],r9
800077de:	ec 07 00 07 	add	r7,r6,r7
800077e2:	0a 9c       	mov	r12,r5
800077e4:	89 27       	st.w	r4[0x8],r7
800077e6:	8f 18       	st.w	r7[0x4],r8
800077e8:	fe b0 f3 aa 	rcall	80005f3c <__malloc_unlock>
800077ec:	ec cc ff f8 	sub	r12,r6,-8
800077f0:	d8 32       	popm	r0-r7,pc
800077f2:	d7 03       	nop

800077f4 <memcpy>:
800077f4:	58 8a       	cp.w	r10,8
800077f6:	c2 f5       	brlt	80007854 <memcpy+0x60>
800077f8:	f9 eb 10 09 	or	r9,r12,r11
800077fc:	e2 19 00 03 	andl	r9,0x3,COH
80007800:	e0 81 00 97 	brne	8000792e <memcpy+0x13a>
80007804:	e0 4a 00 20 	cp.w	r10,32
80007808:	c3 b4       	brge	8000787e <memcpy+0x8a>
8000780a:	f4 08 14 02 	asr	r8,r10,0x2
8000780e:	f0 09 11 08 	rsub	r9,r8,8
80007812:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80007816:	76 69       	ld.w	r9,r11[0x18]
80007818:	99 69       	st.w	r12[0x18],r9
8000781a:	76 59       	ld.w	r9,r11[0x14]
8000781c:	99 59       	st.w	r12[0x14],r9
8000781e:	76 49       	ld.w	r9,r11[0x10]
80007820:	99 49       	st.w	r12[0x10],r9
80007822:	76 39       	ld.w	r9,r11[0xc]
80007824:	99 39       	st.w	r12[0xc],r9
80007826:	76 29       	ld.w	r9,r11[0x8]
80007828:	99 29       	st.w	r12[0x8],r9
8000782a:	76 19       	ld.w	r9,r11[0x4]
8000782c:	99 19       	st.w	r12[0x4],r9
8000782e:	76 09       	ld.w	r9,r11[0x0]
80007830:	99 09       	st.w	r12[0x0],r9
80007832:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80007836:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000783a:	e0 1a 00 03 	andl	r10,0x3
8000783e:	f4 0a 11 04 	rsub	r10,r10,4
80007842:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007846:	17 a9       	ld.ub	r9,r11[0x2]
80007848:	b0 a9       	st.b	r8[0x2],r9
8000784a:	17 99       	ld.ub	r9,r11[0x1]
8000784c:	b0 99       	st.b	r8[0x1],r9
8000784e:	17 89       	ld.ub	r9,r11[0x0]
80007850:	b0 89       	st.b	r8[0x0],r9
80007852:	5e fc       	retal	r12
80007854:	f4 0a 11 09 	rsub	r10,r10,9
80007858:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000785c:	17 f9       	ld.ub	r9,r11[0x7]
8000785e:	b8 f9       	st.b	r12[0x7],r9
80007860:	17 e9       	ld.ub	r9,r11[0x6]
80007862:	b8 e9       	st.b	r12[0x6],r9
80007864:	17 d9       	ld.ub	r9,r11[0x5]
80007866:	b8 d9       	st.b	r12[0x5],r9
80007868:	17 c9       	ld.ub	r9,r11[0x4]
8000786a:	b8 c9       	st.b	r12[0x4],r9
8000786c:	17 b9       	ld.ub	r9,r11[0x3]
8000786e:	b8 b9       	st.b	r12[0x3],r9
80007870:	17 a9       	ld.ub	r9,r11[0x2]
80007872:	b8 a9       	st.b	r12[0x2],r9
80007874:	17 99       	ld.ub	r9,r11[0x1]
80007876:	b8 99       	st.b	r12[0x1],r9
80007878:	17 89       	ld.ub	r9,r11[0x0]
8000787a:	b8 89       	st.b	r12[0x0],r9
8000787c:	5e fc       	retal	r12
8000787e:	eb cd 40 c0 	pushm	r6-r7,lr
80007882:	18 99       	mov	r9,r12
80007884:	22 0a       	sub	r10,32
80007886:	b7 07       	ld.d	r6,r11++
80007888:	b3 26       	st.d	r9++,r6
8000788a:	b7 07       	ld.d	r6,r11++
8000788c:	b3 26       	st.d	r9++,r6
8000788e:	b7 07       	ld.d	r6,r11++
80007890:	b3 26       	st.d	r9++,r6
80007892:	b7 07       	ld.d	r6,r11++
80007894:	b3 26       	st.d	r9++,r6
80007896:	22 0a       	sub	r10,32
80007898:	cf 74       	brge	80007886 <memcpy+0x92>
8000789a:	2f 0a       	sub	r10,-16
8000789c:	c0 65       	brlt	800078a8 <memcpy+0xb4>
8000789e:	b7 07       	ld.d	r6,r11++
800078a0:	b3 26       	st.d	r9++,r6
800078a2:	b7 07       	ld.d	r6,r11++
800078a4:	b3 26       	st.d	r9++,r6
800078a6:	21 0a       	sub	r10,16
800078a8:	5c 3a       	neg	r10
800078aa:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800078ae:	d7 03       	nop
800078b0:	d7 03       	nop
800078b2:	f7 36 00 0e 	ld.ub	r6,r11[14]
800078b6:	f3 66 00 0e 	st.b	r9[14],r6
800078ba:	f7 36 00 0d 	ld.ub	r6,r11[13]
800078be:	f3 66 00 0d 	st.b	r9[13],r6
800078c2:	f7 36 00 0c 	ld.ub	r6,r11[12]
800078c6:	f3 66 00 0c 	st.b	r9[12],r6
800078ca:	f7 36 00 0b 	ld.ub	r6,r11[11]
800078ce:	f3 66 00 0b 	st.b	r9[11],r6
800078d2:	f7 36 00 0a 	ld.ub	r6,r11[10]
800078d6:	f3 66 00 0a 	st.b	r9[10],r6
800078da:	f7 36 00 09 	ld.ub	r6,r11[9]
800078de:	f3 66 00 09 	st.b	r9[9],r6
800078e2:	f7 36 00 08 	ld.ub	r6,r11[8]
800078e6:	f3 66 00 08 	st.b	r9[8],r6
800078ea:	f7 36 00 07 	ld.ub	r6,r11[7]
800078ee:	f3 66 00 07 	st.b	r9[7],r6
800078f2:	f7 36 00 06 	ld.ub	r6,r11[6]
800078f6:	f3 66 00 06 	st.b	r9[6],r6
800078fa:	f7 36 00 05 	ld.ub	r6,r11[5]
800078fe:	f3 66 00 05 	st.b	r9[5],r6
80007902:	f7 36 00 04 	ld.ub	r6,r11[4]
80007906:	f3 66 00 04 	st.b	r9[4],r6
8000790a:	f7 36 00 03 	ld.ub	r6,r11[3]
8000790e:	f3 66 00 03 	st.b	r9[3],r6
80007912:	f7 36 00 02 	ld.ub	r6,r11[2]
80007916:	f3 66 00 02 	st.b	r9[2],r6
8000791a:	f7 36 00 01 	ld.ub	r6,r11[1]
8000791e:	f3 66 00 01 	st.b	r9[1],r6
80007922:	f7 36 00 00 	ld.ub	r6,r11[0]
80007926:	f3 66 00 00 	st.b	r9[0],r6
8000792a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000792e:	20 1a       	sub	r10,1
80007930:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80007934:	f8 0a 0b 09 	st.b	r12[r10],r9
80007938:	cf b1       	brne	8000792e <memcpy+0x13a>
8000793a:	5e fc       	retal	r12

8000793c <memset>:
8000793c:	18 98       	mov	r8,r12
8000793e:	c0 38       	rjmp	80007944 <memset+0x8>
80007940:	10 cb       	st.b	r8++,r11
80007942:	20 1a       	sub	r10,1
80007944:	58 0a       	cp.w	r10,0
80007946:	cf d1       	brne	80007940 <memset+0x4>
80007948:	5e fc       	retal	r12
8000794a:	d7 03       	nop

8000794c <_realloc_r>:
8000794c:	d4 31       	pushm	r0-r7,lr
8000794e:	20 1d       	sub	sp,4
80007950:	16 94       	mov	r4,r11
80007952:	18 92       	mov	r2,r12
80007954:	14 9b       	mov	r11,r10
80007956:	58 04       	cp.w	r4,0
80007958:	c0 51       	brne	80007962 <_realloc_r+0x16>
8000795a:	fe b0 fd 31 	rcall	800073bc <_malloc_r>
8000795e:	18 95       	mov	r5,r12
80007960:	c5 39       	rjmp	80007c06 <_realloc_r+0x2ba>
80007962:	50 0a       	stdsp	sp[0x0],r10
80007964:	fe b0 f2 e6 	rcall	80005f30 <__malloc_lock>
80007968:	40 0b       	lddsp	r11,sp[0x0]
8000796a:	f6 c8 ff f5 	sub	r8,r11,-11
8000796e:	e8 c1 00 08 	sub	r1,r4,8
80007972:	10 96       	mov	r6,r8
80007974:	62 1c       	ld.w	r12,r1[0x4]
80007976:	e0 16 ff f8 	andl	r6,0xfff8
8000797a:	59 68       	cp.w	r8,22
8000797c:	f9 b6 08 10 	movls	r6,16
80007980:	16 36       	cp.w	r6,r11
80007982:	5f 38       	srlo	r8
80007984:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80007988:	c0 50       	breq	80007992 <_realloc_r+0x46>
8000798a:	30 c8       	mov	r8,12
8000798c:	30 05       	mov	r5,0
8000798e:	85 38       	st.w	r2[0xc],r8
80007990:	c3 b9       	rjmp	80007c06 <_realloc_r+0x2ba>
80007992:	18 90       	mov	r0,r12
80007994:	e0 10 ff fc 	andl	r0,0xfffc
80007998:	0c 30       	cp.w	r0,r6
8000799a:	e0 84 01 0b 	brge	80007bb0 <_realloc_r+0x264>
8000799e:	e0 68 05 3c 	mov	r8,1340
800079a2:	e2 00 00 09 	add	r9,r1,r0
800079a6:	70 25       	ld.w	r5,r8[0x8]
800079a8:	0a 39       	cp.w	r9,r5
800079aa:	c0 90       	breq	800079bc <_realloc_r+0x70>
800079ac:	72 1a       	ld.w	r10,r9[0x4]
800079ae:	a1 ca       	cbr	r10,0x0
800079b0:	f2 0a 00 0a 	add	r10,r9,r10
800079b4:	74 1a       	ld.w	r10,r10[0x4]
800079b6:	ed ba 00 00 	bld	r10,0x0
800079ba:	c2 20       	breq	800079fe <_realloc_r+0xb2>
800079bc:	72 1a       	ld.w	r10,r9[0x4]
800079be:	e0 1a ff fc 	andl	r10,0xfffc
800079c2:	f4 00 00 03 	add	r3,r10,r0
800079c6:	0a 39       	cp.w	r9,r5
800079c8:	c1 31       	brne	800079ee <_realloc_r+0xa2>
800079ca:	ec c7 ff f0 	sub	r7,r6,-16
800079ce:	0e 33       	cp.w	r3,r7
800079d0:	c1 95       	brlt	80007a02 <_realloc_r+0xb6>
800079d2:	e2 06 00 09 	add	r9,r1,r6
800079d6:	0c 13       	sub	r3,r6
800079d8:	a1 a3       	sbr	r3,0x0
800079da:	93 13       	st.w	r9[0x4],r3
800079dc:	91 29       	st.w	r8[0x8],r9
800079de:	04 9c       	mov	r12,r2
800079e0:	62 18       	ld.w	r8,r1[0x4]
800079e2:	08 95       	mov	r5,r4
800079e4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800079e8:	10 46       	or	r6,r8
800079ea:	83 16       	st.w	r1[0x4],r6
800079ec:	c0 b9       	rjmp	80007c02 <_realloc_r+0x2b6>
800079ee:	0c 33       	cp.w	r3,r6
800079f0:	c0 95       	brlt	80007a02 <_realloc_r+0xb6>
800079f2:	72 28       	ld.w	r8,r9[0x8]
800079f4:	02 97       	mov	r7,r1
800079f6:	72 39       	ld.w	r9,r9[0xc]
800079f8:	93 28       	st.w	r9[0x8],r8
800079fa:	91 39       	st.w	r8[0xc],r9
800079fc:	cd c8       	rjmp	80007bb4 <_realloc_r+0x268>
800079fe:	30 0a       	mov	r10,0
80007a00:	14 99       	mov	r9,r10
80007a02:	ed bc 00 00 	bld	r12,0x0
80007a06:	e0 80 00 95 	breq	80007b30 <_realloc_r+0x1e4>
80007a0a:	62 07       	ld.w	r7,r1[0x0]
80007a0c:	e2 07 01 07 	sub	r7,r1,r7
80007a10:	6e 1c       	ld.w	r12,r7[0x4]
80007a12:	e0 1c ff fc 	andl	r12,0xfffc
80007a16:	58 09       	cp.w	r9,0
80007a18:	c5 60       	breq	80007ac4 <_realloc_r+0x178>
80007a1a:	f8 00 00 03 	add	r3,r12,r0
80007a1e:	0a 39       	cp.w	r9,r5
80007a20:	c4 81       	brne	80007ab0 <_realloc_r+0x164>
80007a22:	14 03       	add	r3,r10
80007a24:	ec c9 ff f0 	sub	r9,r6,-16
80007a28:	12 33       	cp.w	r3,r9
80007a2a:	c4 d5       	brlt	80007ac4 <_realloc_r+0x178>
80007a2c:	6e 3a       	ld.w	r10,r7[0xc]
80007a2e:	6e 29       	ld.w	r9,r7[0x8]
80007a30:	95 29       	st.w	r10[0x8],r9
80007a32:	93 3a       	st.w	r9[0xc],r10
80007a34:	ee c5 ff f8 	sub	r5,r7,-8
80007a38:	e0 ca 00 04 	sub	r10,r0,4
80007a3c:	e0 4a 00 24 	cp.w	r10,36
80007a40:	e0 8b 00 25 	brhi	80007a8a <_realloc_r+0x13e>
80007a44:	0a 99       	mov	r9,r5
80007a46:	59 3a       	cp.w	r10,19
80007a48:	e0 88 00 1a 	brls	80007a7c <_realloc_r+0x130>
80007a4c:	09 09       	ld.w	r9,r4++
80007a4e:	8b 09       	st.w	r5[0x0],r9
80007a50:	09 09       	ld.w	r9,r4++
80007a52:	8f 39       	st.w	r7[0xc],r9
80007a54:	ee c9 ff f0 	sub	r9,r7,-16
80007a58:	59 ba       	cp.w	r10,27
80007a5a:	e0 88 00 11 	brls	80007a7c <_realloc_r+0x130>
80007a5e:	09 0b       	ld.w	r11,r4++
80007a60:	93 0b       	st.w	r9[0x0],r11
80007a62:	09 09       	ld.w	r9,r4++
80007a64:	8f 59       	st.w	r7[0x14],r9
80007a66:	ee c9 ff e8 	sub	r9,r7,-24
80007a6a:	e0 4a 00 24 	cp.w	r10,36
80007a6e:	c0 71       	brne	80007a7c <_realloc_r+0x130>
80007a70:	09 0a       	ld.w	r10,r4++
80007a72:	93 0a       	st.w	r9[0x0],r10
80007a74:	ee c9 ff e0 	sub	r9,r7,-32
80007a78:	09 0a       	ld.w	r10,r4++
80007a7a:	8f 7a       	st.w	r7[0x1c],r10
80007a7c:	09 0a       	ld.w	r10,r4++
80007a7e:	12 aa       	st.w	r9++,r10
80007a80:	68 0a       	ld.w	r10,r4[0x0]
80007a82:	93 0a       	st.w	r9[0x0],r10
80007a84:	68 1a       	ld.w	r10,r4[0x4]
80007a86:	93 1a       	st.w	r9[0x4],r10
80007a88:	c0 78       	rjmp	80007a96 <_realloc_r+0x14a>
80007a8a:	50 08       	stdsp	sp[0x0],r8
80007a8c:	08 9b       	mov	r11,r4
80007a8e:	0a 9c       	mov	r12,r5
80007a90:	e0 a0 1d 8f 	rcall	8000b5ae <memmove>
80007a94:	40 08       	lddsp	r8,sp[0x0]
80007a96:	ee 06 00 09 	add	r9,r7,r6
80007a9a:	0c 13       	sub	r3,r6
80007a9c:	a1 a3       	sbr	r3,0x0
80007a9e:	93 13       	st.w	r9[0x4],r3
80007aa0:	91 29       	st.w	r8[0x8],r9
80007aa2:	04 9c       	mov	r12,r2
80007aa4:	6e 18       	ld.w	r8,r7[0x4]
80007aa6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007aaa:	10 46       	or	r6,r8
80007aac:	8f 16       	st.w	r7[0x4],r6
80007aae:	ca a8       	rjmp	80007c02 <_realloc_r+0x2b6>
80007ab0:	14 03       	add	r3,r10
80007ab2:	0c 33       	cp.w	r3,r6
80007ab4:	c0 85       	brlt	80007ac4 <_realloc_r+0x178>
80007ab6:	72 28       	ld.w	r8,r9[0x8]
80007ab8:	72 39       	ld.w	r9,r9[0xc]
80007aba:	93 28       	st.w	r9[0x8],r8
80007abc:	91 39       	st.w	r8[0xc],r9
80007abe:	6e 28       	ld.w	r8,r7[0x8]
80007ac0:	6e 39       	ld.w	r9,r7[0xc]
80007ac2:	c0 78       	rjmp	80007ad0 <_realloc_r+0x184>
80007ac4:	f8 00 00 03 	add	r3,r12,r0
80007ac8:	0c 33       	cp.w	r3,r6
80007aca:	c3 35       	brlt	80007b30 <_realloc_r+0x1e4>
80007acc:	6e 39       	ld.w	r9,r7[0xc]
80007ace:	6e 28       	ld.w	r8,r7[0x8]
80007ad0:	93 28       	st.w	r9[0x8],r8
80007ad2:	91 39       	st.w	r8[0xc],r9
80007ad4:	e0 ca 00 04 	sub	r10,r0,4
80007ad8:	ee cc ff f8 	sub	r12,r7,-8
80007adc:	e0 4a 00 24 	cp.w	r10,36
80007ae0:	e0 8b 00 24 	brhi	80007b28 <_realloc_r+0x1dc>
80007ae4:	59 3a       	cp.w	r10,19
80007ae6:	e0 88 00 1a 	brls	80007b1a <_realloc_r+0x1ce>
80007aea:	09 08       	ld.w	r8,r4++
80007aec:	99 08       	st.w	r12[0x0],r8
80007aee:	09 08       	ld.w	r8,r4++
80007af0:	8f 38       	st.w	r7[0xc],r8
80007af2:	ee cc ff f0 	sub	r12,r7,-16
80007af6:	59 ba       	cp.w	r10,27
80007af8:	e0 88 00 11 	brls	80007b1a <_realloc_r+0x1ce>
80007afc:	09 08       	ld.w	r8,r4++
80007afe:	99 08       	st.w	r12[0x0],r8
80007b00:	09 08       	ld.w	r8,r4++
80007b02:	8f 58       	st.w	r7[0x14],r8
80007b04:	ee cc ff e8 	sub	r12,r7,-24
80007b08:	e0 4a 00 24 	cp.w	r10,36
80007b0c:	c0 71       	brne	80007b1a <_realloc_r+0x1ce>
80007b0e:	09 08       	ld.w	r8,r4++
80007b10:	99 08       	st.w	r12[0x0],r8
80007b12:	ee cc ff e0 	sub	r12,r7,-32
80007b16:	09 08       	ld.w	r8,r4++
80007b18:	8f 78       	st.w	r7[0x1c],r8
80007b1a:	09 08       	ld.w	r8,r4++
80007b1c:	18 a8       	st.w	r12++,r8
80007b1e:	68 08       	ld.w	r8,r4[0x0]
80007b20:	99 08       	st.w	r12[0x0],r8
80007b22:	68 18       	ld.w	r8,r4[0x4]
80007b24:	99 18       	st.w	r12[0x4],r8
80007b26:	c4 78       	rjmp	80007bb4 <_realloc_r+0x268>
80007b28:	08 9b       	mov	r11,r4
80007b2a:	e0 a0 1d 42 	rcall	8000b5ae <memmove>
80007b2e:	c4 38       	rjmp	80007bb4 <_realloc_r+0x268>
80007b30:	04 9c       	mov	r12,r2
80007b32:	fe b0 fc 45 	rcall	800073bc <_malloc_r>
80007b36:	18 95       	mov	r5,r12
80007b38:	c3 a0       	breq	80007bac <_realloc_r+0x260>
80007b3a:	62 18       	ld.w	r8,r1[0x4]
80007b3c:	f8 c9 00 08 	sub	r9,r12,8
80007b40:	a1 c8       	cbr	r8,0x0
80007b42:	e2 08 00 08 	add	r8,r1,r8
80007b46:	10 39       	cp.w	r9,r8
80007b48:	c0 71       	brne	80007b56 <_realloc_r+0x20a>
80007b4a:	72 13       	ld.w	r3,r9[0x4]
80007b4c:	02 97       	mov	r7,r1
80007b4e:	e0 13 ff fc 	andl	r3,0xfffc
80007b52:	00 03       	add	r3,r0
80007b54:	c3 08       	rjmp	80007bb4 <_realloc_r+0x268>
80007b56:	e0 ca 00 04 	sub	r10,r0,4
80007b5a:	e0 4a 00 24 	cp.w	r10,36
80007b5e:	e0 8b 00 20 	brhi	80007b9e <_realloc_r+0x252>
80007b62:	08 99       	mov	r9,r4
80007b64:	18 98       	mov	r8,r12
80007b66:	59 3a       	cp.w	r10,19
80007b68:	e0 88 00 14 	brls	80007b90 <_realloc_r+0x244>
80007b6c:	13 0b       	ld.w	r11,r9++
80007b6e:	10 ab       	st.w	r8++,r11
80007b70:	13 0b       	ld.w	r11,r9++
80007b72:	10 ab       	st.w	r8++,r11
80007b74:	59 ba       	cp.w	r10,27
80007b76:	e0 88 00 0d 	brls	80007b90 <_realloc_r+0x244>
80007b7a:	13 0b       	ld.w	r11,r9++
80007b7c:	10 ab       	st.w	r8++,r11
80007b7e:	13 0b       	ld.w	r11,r9++
80007b80:	10 ab       	st.w	r8++,r11
80007b82:	e0 4a 00 24 	cp.w	r10,36
80007b86:	c0 51       	brne	80007b90 <_realloc_r+0x244>
80007b88:	13 0a       	ld.w	r10,r9++
80007b8a:	10 aa       	st.w	r8++,r10
80007b8c:	13 0a       	ld.w	r10,r9++
80007b8e:	10 aa       	st.w	r8++,r10
80007b90:	13 0a       	ld.w	r10,r9++
80007b92:	10 aa       	st.w	r8++,r10
80007b94:	72 0a       	ld.w	r10,r9[0x0]
80007b96:	91 0a       	st.w	r8[0x0],r10
80007b98:	72 19       	ld.w	r9,r9[0x4]
80007b9a:	91 19       	st.w	r8[0x4],r9
80007b9c:	c0 48       	rjmp	80007ba4 <_realloc_r+0x258>
80007b9e:	08 9b       	mov	r11,r4
80007ba0:	e0 a0 1d 07 	rcall	8000b5ae <memmove>
80007ba4:	08 9b       	mov	r11,r4
80007ba6:	04 9c       	mov	r12,r2
80007ba8:	e0 a0 1a 60 	rcall	8000b068 <_free_r>
80007bac:	04 9c       	mov	r12,r2
80007bae:	c2 a8       	rjmp	80007c02 <_realloc_r+0x2b6>
80007bb0:	00 93       	mov	r3,r0
80007bb2:	02 97       	mov	r7,r1
80007bb4:	e6 06 01 09 	sub	r9,r3,r6
80007bb8:	6e 18       	ld.w	r8,r7[0x4]
80007bba:	58 f9       	cp.w	r9,15
80007bbc:	e0 88 00 16 	brls	80007be8 <_realloc_r+0x29c>
80007bc0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007bc4:	ed e8 10 08 	or	r8,r6,r8
80007bc8:	8f 18       	st.w	r7[0x4],r8
80007bca:	12 98       	mov	r8,r9
80007bcc:	a1 a8       	sbr	r8,0x0
80007bce:	ee 06 00 0b 	add	r11,r7,r6
80007bd2:	f6 09 00 09 	add	r9,r11,r9
80007bd6:	97 18       	st.w	r11[0x4],r8
80007bd8:	72 18       	ld.w	r8,r9[0x4]
80007bda:	a1 a8       	sbr	r8,0x0
80007bdc:	2f 8b       	sub	r11,-8
80007bde:	93 18       	st.w	r9[0x4],r8
80007be0:	04 9c       	mov	r12,r2
80007be2:	e0 a0 1a 43 	rcall	8000b068 <_free_r>
80007be6:	c0 b8       	rjmp	80007bfc <_realloc_r+0x2b0>
80007be8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007bec:	e7 e8 10 08 	or	r8,r3,r8
80007bf0:	8f 18       	st.w	r7[0x4],r8
80007bf2:	ee 03 00 03 	add	r3,r7,r3
80007bf6:	66 18       	ld.w	r8,r3[0x4]
80007bf8:	a1 a8       	sbr	r8,0x0
80007bfa:	87 18       	st.w	r3[0x4],r8
80007bfc:	04 9c       	mov	r12,r2
80007bfe:	ee c5 ff f8 	sub	r5,r7,-8
80007c02:	fe b0 f1 9d 	rcall	80005f3c <__malloc_unlock>
80007c06:	0a 9c       	mov	r12,r5
80007c08:	2f fd       	sub	sp,-4
80007c0a:	d8 32       	popm	r0-r7,pc

80007c0c <_sbrk_r>:
80007c0c:	d4 21       	pushm	r4-r7,lr
80007c0e:	30 08       	mov	r8,0
80007c10:	18 97       	mov	r7,r12
80007c12:	e0 66 79 ec 	mov	r6,31212
80007c16:	16 9c       	mov	r12,r11
80007c18:	8d 08       	st.w	r6[0x0],r8
80007c1a:	c8 5c       	rcall	80007d24 <_sbrk>
80007c1c:	5b fc       	cp.w	r12,-1
80007c1e:	c0 51       	brne	80007c28 <_sbrk_r+0x1c>
80007c20:	6c 08       	ld.w	r8,r6[0x0]
80007c22:	58 08       	cp.w	r8,0
80007c24:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007c28:	d8 22       	popm	r4-r7,pc
80007c2a:	d7 03       	nop

80007c2c <sprintf>:
80007c2c:	d4 01       	pushm	lr
80007c2e:	21 7d       	sub	sp,92
80007c30:	e0 68 ff ff 	mov	r8,65535
80007c34:	ea 18 7f ff 	orh	r8,0x7fff
80007c38:	50 58       	stdsp	sp[0x14],r8
80007c3a:	50 28       	stdsp	sp[0x8],r8
80007c3c:	e0 68 02 08 	mov	r8,520
80007c40:	ba 68       	st.h	sp[0xc],r8
80007c42:	3f f8       	mov	r8,-1
80007c44:	ba 78       	st.h	sp[0xe],r8
80007c46:	e0 68 0a 3c 	mov	r8,2620
80007c4a:	50 4c       	stdsp	sp[0x10],r12
80007c4c:	16 9a       	mov	r10,r11
80007c4e:	50 0c       	stdsp	sp[0x0],r12
80007c50:	fa c9 ff a0 	sub	r9,sp,-96
80007c54:	70 0c       	ld.w	r12,r8[0x0]
80007c56:	1a 9b       	mov	r11,sp
80007c58:	e0 a0 02 1a 	rcall	8000808c <_vfprintf_r>
80007c5c:	30 09       	mov	r9,0
80007c5e:	40 08       	lddsp	r8,sp[0x0]
80007c60:	b0 89       	st.b	r8[0x0],r9
80007c62:	2e 9d       	sub	sp,-92
80007c64:	d8 02       	popm	pc
80007c66:	d7 03       	nop

80007c68 <strncpy>:
80007c68:	30 08       	mov	r8,0
80007c6a:	10 3a       	cp.w	r10,r8
80007c6c:	5e 0c       	reteq	r12
80007c6e:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007c72:	f8 08 0b 09 	st.b	r12[r8],r9
80007c76:	2f f8       	sub	r8,-1
80007c78:	58 09       	cp.w	r9,0
80007c7a:	cf 81       	brne	80007c6a <strncpy+0x2>
80007c7c:	10 3a       	cp.w	r10,r8
80007c7e:	5e 0c       	reteq	r12
80007c80:	f8 08 0b 09 	st.b	r12[r8],r9
80007c84:	2f f8       	sub	r8,-1
80007c86:	cf bb       	rjmp	80007c7c <strncpy+0x14>

80007c88 <_close>:
80007c88:	30 28       	mov	r8,2
80007c8a:	d6 73       	breakpoint
80007c8c:	3f fc       	mov	r12,-1
80007c8e:	35 8b       	mov	r11,88
80007c90:	58 0c       	cp.w	r12,0
80007c92:	5e 4c       	retge	r12
80007c94:	e0 6a 79 ec 	mov	r10,31212
80007c98:	95 0b       	st.w	r10[0x0],r11
80007c9a:	5e fc       	retal	r12

80007c9c <_lseek>:
80007c9c:	30 58       	mov	r8,5
80007c9e:	d6 73       	breakpoint
80007ca0:	3f fc       	mov	r12,-1
80007ca2:	35 8b       	mov	r11,88
80007ca4:	58 0c       	cp.w	r12,0
80007ca6:	5e 4c       	retge	r12
80007ca8:	e0 6a 79 ec 	mov	r10,31212
80007cac:	95 0b       	st.w	r10[0x0],r11
80007cae:	5e fc       	retal	r12

80007cb0 <isatty>:
80007cb0:	30 b8       	mov	r8,11
80007cb2:	d6 73       	breakpoint
80007cb4:	3f fc       	mov	r12,-1
80007cb6:	35 8b       	mov	r11,88
80007cb8:	58 0c       	cp.w	r12,0
80007cba:	5e 4c       	retge	r12
80007cbc:	e0 6a 79 ec 	mov	r10,31212
80007cc0:	95 0b       	st.w	r10[0x0],r11
80007cc2:	5e fc       	retal	r12

80007cc4 <_fstat_host>:
80007cc4:	30 98       	mov	r8,9
80007cc6:	d6 73       	breakpoint
80007cc8:	3f fc       	mov	r12,-1
80007cca:	35 8b       	mov	r11,88
80007ccc:	58 0c       	cp.w	r12,0
80007cce:	5e 4c       	retge	r12
80007cd0:	e0 6a 79 ec 	mov	r10,31212
80007cd4:	95 0b       	st.w	r10[0x0],r11
80007cd6:	5e fc       	retal	r12

80007cd8 <_fstat>:
80007cd8:	d4 21       	pushm	r4-r7,lr
80007cda:	21 0d       	sub	sp,64
80007cdc:	16 97       	mov	r7,r11
80007cde:	1a 9b       	mov	r11,sp
80007ce0:	cf 2f       	rcall	80007cc4 <_fstat_host>
80007ce2:	c0 34       	brge	80007ce8 <_fstat+0x10>
80007ce4:	3f fc       	mov	r12,-1
80007ce6:	c1 c8       	rjmp	80007d1e <_fstat+0x46>
80007ce8:	40 08       	lddsp	r8,sp[0x0]
80007cea:	ae 08       	st.h	r7[0x0],r8
80007cec:	40 18       	lddsp	r8,sp[0x4]
80007cee:	ae 18       	st.h	r7[0x2],r8
80007cf0:	40 28       	lddsp	r8,sp[0x8]
80007cf2:	8f 18       	st.w	r7[0x4],r8
80007cf4:	40 38       	lddsp	r8,sp[0xc]
80007cf6:	ae 48       	st.h	r7[0x8],r8
80007cf8:	40 48       	lddsp	r8,sp[0x10]
80007cfa:	ae 58       	st.h	r7[0xa],r8
80007cfc:	40 58       	lddsp	r8,sp[0x14]
80007cfe:	ae 68       	st.h	r7[0xc],r8
80007d00:	40 68       	lddsp	r8,sp[0x18]
80007d02:	ae 78       	st.h	r7[0xe],r8
80007d04:	40 88       	lddsp	r8,sp[0x20]
80007d06:	8f 48       	st.w	r7[0x10],r8
80007d08:	40 a8       	lddsp	r8,sp[0x28]
80007d0a:	8f b8       	st.w	r7[0x2c],r8
80007d0c:	40 c8       	lddsp	r8,sp[0x30]
80007d0e:	8f c8       	st.w	r7[0x30],r8
80007d10:	40 d8       	lddsp	r8,sp[0x34]
80007d12:	8f 58       	st.w	r7[0x14],r8
80007d14:	40 e8       	lddsp	r8,sp[0x38]
80007d16:	30 0c       	mov	r12,0
80007d18:	8f 78       	st.w	r7[0x1c],r8
80007d1a:	40 f8       	lddsp	r8,sp[0x3c]
80007d1c:	8f 98       	st.w	r7[0x24],r8
80007d1e:	2f 0d       	sub	sp,-64
80007d20:	d8 22       	popm	r4-r7,pc
80007d22:	d7 03       	nop

80007d24 <_sbrk>:
80007d24:	d4 01       	pushm	lr
80007d26:	e0 68 0d 9c 	mov	r8,3484
80007d2a:	70 09       	ld.w	r9,r8[0x0]
80007d2c:	58 09       	cp.w	r9,0
80007d2e:	c0 41       	brne	80007d36 <_sbrk+0x12>
80007d30:	e0 69 79 f0 	mov	r9,31216
80007d34:	91 09       	st.w	r8[0x0],r9
80007d36:	e0 69 0d 9c 	mov	r9,3484
80007d3a:	e0 7a 70 00 	mov	r10,94208
80007d3e:	72 08       	ld.w	r8,r9[0x0]
80007d40:	f0 0c 00 0c 	add	r12,r8,r12
80007d44:	14 3c       	cp.w	r12,r10
80007d46:	e0 8b 00 04 	brhi	80007d4e <_sbrk+0x2a>
80007d4a:	93 0c       	st.w	r9[0x0],r12
80007d4c:	c0 68       	rjmp	80007d58 <_sbrk+0x34>
80007d4e:	e0 a0 18 15 	rcall	8000ad78 <__errno>
80007d52:	30 c8       	mov	r8,12
80007d54:	99 08       	st.w	r12[0x0],r8
80007d56:	3f f8       	mov	r8,-1
80007d58:	10 9c       	mov	r12,r8
80007d5a:	d8 02       	popm	pc

80007d5c <get_arg>:
80007d5c:	d4 31       	pushm	r0-r7,lr
80007d5e:	20 8d       	sub	sp,32
80007d60:	fa c4 ff bc 	sub	r4,sp,-68
80007d64:	50 4b       	stdsp	sp[0x10],r11
80007d66:	68 2e       	ld.w	lr,r4[0x8]
80007d68:	50 58       	stdsp	sp[0x14],r8
80007d6a:	12 96       	mov	r6,r9
80007d6c:	7c 0b       	ld.w	r11,lr[0x0]
80007d6e:	70 05       	ld.w	r5,r8[0x0]
80007d70:	50 6e       	stdsp	sp[0x18],lr
80007d72:	58 0b       	cp.w	r11,0
80007d74:	f4 0b 17 00 	moveq	r11,r10
80007d78:	68 03       	ld.w	r3,r4[0x0]
80007d7a:	68 11       	ld.w	r1,r4[0x4]
80007d7c:	40 49       	lddsp	r9,sp[0x10]
80007d7e:	30 08       	mov	r8,0
80007d80:	c2 89       	rjmp	80007fd0 <get_arg+0x274>
80007d82:	2f fb       	sub	r11,-1
80007d84:	32 5c       	mov	r12,37
80007d86:	17 8a       	ld.ub	r10,r11[0x0]
80007d88:	f8 0a 18 00 	cp.b	r10,r12
80007d8c:	5f 1e       	srne	lr
80007d8e:	f0 0a 18 00 	cp.b	r10,r8
80007d92:	5f 1c       	srne	r12
80007d94:	fd ec 00 0c 	and	r12,lr,r12
80007d98:	f0 0c 18 00 	cp.b	r12,r8
80007d9c:	cf 31       	brne	80007d82 <get_arg+0x26>
80007d9e:	58 0a       	cp.w	r10,0
80007da0:	e0 80 01 25 	breq	80007fea <get_arg+0x28e>
80007da4:	30 0c       	mov	r12,0
80007da6:	3f fa       	mov	r10,-1
80007da8:	18 90       	mov	r0,r12
80007daa:	50 3a       	stdsp	sp[0xc],r10
80007dac:	18 94       	mov	r4,r12
80007dae:	18 92       	mov	r2,r12
80007db0:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007db4:	16 97       	mov	r7,r11
80007db6:	50 7c       	stdsp	sp[0x1c],r12
80007db8:	fe cc 9d b0 	sub	r12,pc,-25168
80007dbc:	0f 3a       	ld.ub	r10,r7++
80007dbe:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007dc2:	40 7c       	lddsp	r12,sp[0x1c]
80007dc4:	1c 0c       	add	r12,lr
80007dc6:	fe ce 9e 86 	sub	lr,pc,-24954
80007dca:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007dce:	20 1e       	sub	lr,1
80007dd0:	50 0e       	stdsp	sp[0x0],lr
80007dd2:	fe ce 9e fe 	sub	lr,pc,-24834
80007dd6:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007dda:	50 7c       	stdsp	sp[0x1c],r12
80007ddc:	40 0c       	lddsp	r12,sp[0x0]
80007dde:	58 7c       	cp.w	r12,7
80007de0:	e0 8b 00 f1 	brhi	80007fc2 <get_arg+0x266>
80007de4:	fe ce a0 b0 	sub	lr,pc,-24400
80007de8:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007dec:	36 8b       	mov	r11,104
80007dee:	f6 0a 18 00 	cp.b	r10,r11
80007df2:	e0 80 00 e8 	breq	80007fc2 <get_arg+0x266>
80007df6:	37 1b       	mov	r11,113
80007df8:	f6 0a 18 00 	cp.b	r10,r11
80007dfc:	c0 70       	breq	80007e0a <get_arg+0xae>
80007dfe:	34 cb       	mov	r11,76
80007e00:	f6 0a 18 00 	cp.b	r10,r11
80007e04:	c0 51       	brne	80007e0e <get_arg+0xb2>
80007e06:	a3 b4       	sbr	r4,0x3
80007e08:	cd d8       	rjmp	80007fc2 <get_arg+0x266>
80007e0a:	a5 b4       	sbr	r4,0x5
80007e0c:	cd b8       	rjmp	80007fc2 <get_arg+0x266>
80007e0e:	08 9a       	mov	r10,r4
80007e10:	0e 9b       	mov	r11,r7
80007e12:	a5 aa       	sbr	r10,0x4
80007e14:	17 3c       	ld.ub	r12,r11++
80007e16:	a5 b4       	sbr	r4,0x5
80007e18:	36 ce       	mov	lr,108
80007e1a:	fc 0c 18 00 	cp.b	r12,lr
80007e1e:	e0 80 00 d3 	breq	80007fc4 <get_arg+0x268>
80007e22:	14 94       	mov	r4,r10
80007e24:	cc f8       	rjmp	80007fc2 <get_arg+0x266>
80007e26:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007e2a:	36 7c       	mov	r12,103
80007e2c:	f8 0a 18 00 	cp.b	r10,r12
80007e30:	e0 8b 00 27 	brhi	80007e7e <get_arg+0x122>
80007e34:	36 5b       	mov	r11,101
80007e36:	f6 0a 18 00 	cp.b	r10,r11
80007e3a:	c4 82       	brcc	80007eca <get_arg+0x16e>
80007e3c:	34 fb       	mov	r11,79
80007e3e:	f6 0a 18 00 	cp.b	r10,r11
80007e42:	c4 80       	breq	80007ed2 <get_arg+0x176>
80007e44:	e0 8b 00 0c 	brhi	80007e5c <get_arg+0x100>
80007e48:	34 5b       	mov	r11,69
80007e4a:	f6 0a 18 00 	cp.b	r10,r11
80007e4e:	c3 e0       	breq	80007eca <get_arg+0x16e>
80007e50:	34 7b       	mov	r11,71
80007e52:	f6 0a 18 00 	cp.b	r10,r11
80007e56:	c3 a0       	breq	80007eca <get_arg+0x16e>
80007e58:	34 4b       	mov	r11,68
80007e5a:	c0 88       	rjmp	80007e6a <get_arg+0x10e>
80007e5c:	35 8b       	mov	r11,88
80007e5e:	f6 0a 18 00 	cp.b	r10,r11
80007e62:	c2 c0       	breq	80007eba <get_arg+0x15e>
80007e64:	e0 8b 00 07 	brhi	80007e72 <get_arg+0x116>
80007e68:	35 5b       	mov	r11,85
80007e6a:	f6 0a 18 00 	cp.b	r10,r11
80007e6e:	c3 51       	brne	80007ed8 <get_arg+0x17c>
80007e70:	c3 18       	rjmp	80007ed2 <get_arg+0x176>
80007e72:	36 3b       	mov	r11,99
80007e74:	f6 0a 18 00 	cp.b	r10,r11
80007e78:	c2 f0       	breq	80007ed6 <get_arg+0x17a>
80007e7a:	36 4b       	mov	r11,100
80007e7c:	c0 e8       	rjmp	80007e98 <get_arg+0x13c>
80007e7e:	37 0b       	mov	r11,112
80007e80:	f6 0a 18 00 	cp.b	r10,r11
80007e84:	c2 50       	breq	80007ece <get_arg+0x172>
80007e86:	e0 8b 00 0d 	brhi	80007ea0 <get_arg+0x144>
80007e8a:	36 eb       	mov	r11,110
80007e8c:	f6 0a 18 00 	cp.b	r10,r11
80007e90:	c1 f0       	breq	80007ece <get_arg+0x172>
80007e92:	e0 8b 00 14 	brhi	80007eba <get_arg+0x15e>
80007e96:	36 9b       	mov	r11,105
80007e98:	f6 0a 18 00 	cp.b	r10,r11
80007e9c:	c1 e1       	brne	80007ed8 <get_arg+0x17c>
80007e9e:	c0 e8       	rjmp	80007eba <get_arg+0x15e>
80007ea0:	37 5b       	mov	r11,117
80007ea2:	f6 0a 18 00 	cp.b	r10,r11
80007ea6:	c0 a0       	breq	80007eba <get_arg+0x15e>
80007ea8:	37 8b       	mov	r11,120
80007eaa:	f6 0a 18 00 	cp.b	r10,r11
80007eae:	c0 60       	breq	80007eba <get_arg+0x15e>
80007eb0:	37 3b       	mov	r11,115
80007eb2:	f6 0a 18 00 	cp.b	r10,r11
80007eb6:	c1 11       	brne	80007ed8 <get_arg+0x17c>
80007eb8:	c0 b8       	rjmp	80007ece <get_arg+0x172>
80007eba:	ed b4 00 04 	bld	r4,0x4
80007ebe:	c0 a0       	breq	80007ed2 <get_arg+0x176>
80007ec0:	ed b4 00 05 	bld	r4,0x5
80007ec4:	c0 91       	brne	80007ed6 <get_arg+0x17a>
80007ec6:	30 20       	mov	r0,2
80007ec8:	c0 88       	rjmp	80007ed8 <get_arg+0x17c>
80007eca:	30 40       	mov	r0,4
80007ecc:	c0 68       	rjmp	80007ed8 <get_arg+0x17c>
80007ece:	30 30       	mov	r0,3
80007ed0:	c0 48       	rjmp	80007ed8 <get_arg+0x17c>
80007ed2:	30 10       	mov	r0,1
80007ed4:	c0 28       	rjmp	80007ed8 <get_arg+0x17c>
80007ed6:	30 00       	mov	r0,0
80007ed8:	40 3b       	lddsp	r11,sp[0xc]
80007eda:	5b fb       	cp.w	r11,-1
80007edc:	c0 40       	breq	80007ee4 <get_arg+0x188>
80007ede:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007ee2:	c7 08       	rjmp	80007fc2 <get_arg+0x266>
80007ee4:	58 60       	cp.w	r0,6
80007ee6:	e0 8b 00 6e 	brhi	80007fc2 <get_arg+0x266>
80007eea:	6c 0a       	ld.w	r10,r6[0x0]
80007eec:	ea cc ff ff 	sub	r12,r5,-1
80007ef0:	fe ce a1 9c 	sub	lr,pc,-24164
80007ef4:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007ef8:	f4 cb ff f8 	sub	r11,r10,-8
80007efc:	8d 0b       	st.w	r6[0x0],r11
80007efe:	f4 ea 00 00 	ld.d	r10,r10[0]
80007f02:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007f06:	c0 f8       	rjmp	80007f24 <get_arg+0x1c8>
80007f08:	f4 cb ff fc 	sub	r11,r10,-4
80007f0c:	8d 0b       	st.w	r6[0x0],r11
80007f0e:	74 0a       	ld.w	r10,r10[0x0]
80007f10:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007f14:	c0 88       	rjmp	80007f24 <get_arg+0x1c8>
80007f16:	f4 cb ff f8 	sub	r11,r10,-8
80007f1a:	8d 0b       	st.w	r6[0x0],r11
80007f1c:	f4 ea 00 00 	ld.d	r10,r10[0]
80007f20:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007f24:	0e 9b       	mov	r11,r7
80007f26:	18 95       	mov	r5,r12
80007f28:	c4 e8       	rjmp	80007fc4 <get_arg+0x268>
80007f2a:	62 0a       	ld.w	r10,r1[0x0]
80007f2c:	5b fa       	cp.w	r10,-1
80007f2e:	c0 b1       	brne	80007f44 <get_arg+0x1e8>
80007f30:	50 19       	stdsp	sp[0x4],r9
80007f32:	50 28       	stdsp	sp[0x8],r8
80007f34:	e0 6a 00 80 	mov	r10,128
80007f38:	30 0b       	mov	r11,0
80007f3a:	02 9c       	mov	r12,r1
80007f3c:	fe b0 fd 00 	rcall	8000793c <memset>
80007f40:	40 28       	lddsp	r8,sp[0x8]
80007f42:	40 19       	lddsp	r9,sp[0x4]
80007f44:	e4 cc 00 01 	sub	r12,r2,1
80007f48:	0e 9b       	mov	r11,r7
80007f4a:	50 3c       	stdsp	sp[0xc],r12
80007f4c:	f2 0c 0c 49 	max	r9,r9,r12
80007f50:	c3 a8       	rjmp	80007fc4 <get_arg+0x268>
80007f52:	62 0a       	ld.w	r10,r1[0x0]
80007f54:	5b fa       	cp.w	r10,-1
80007f56:	c0 b1       	brne	80007f6c <get_arg+0x210>
80007f58:	50 19       	stdsp	sp[0x4],r9
80007f5a:	50 28       	stdsp	sp[0x8],r8
80007f5c:	e0 6a 00 80 	mov	r10,128
80007f60:	30 0b       	mov	r11,0
80007f62:	02 9c       	mov	r12,r1
80007f64:	fe b0 fc ec 	rcall	8000793c <memset>
80007f68:	40 28       	lddsp	r8,sp[0x8]
80007f6a:	40 19       	lddsp	r9,sp[0x4]
80007f6c:	20 12       	sub	r2,1
80007f6e:	30 0a       	mov	r10,0
80007f70:	0e 9b       	mov	r11,r7
80007f72:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007f76:	f2 02 0c 49 	max	r9,r9,r2
80007f7a:	c2 58       	rjmp	80007fc4 <get_arg+0x268>
80007f7c:	16 97       	mov	r7,r11
80007f7e:	6c 0a       	ld.w	r10,r6[0x0]
80007f80:	f4 cb ff fc 	sub	r11,r10,-4
80007f84:	8d 0b       	st.w	r6[0x0],r11
80007f86:	74 0a       	ld.w	r10,r10[0x0]
80007f88:	0e 9b       	mov	r11,r7
80007f8a:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007f8e:	2f f5       	sub	r5,-1
80007f90:	c1 a8       	rjmp	80007fc4 <get_arg+0x268>
80007f92:	f4 c2 00 30 	sub	r2,r10,48
80007f96:	c0 68       	rjmp	80007fa2 <get_arg+0x246>
80007f98:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007f9c:	2f f7       	sub	r7,-1
80007f9e:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007fa2:	0f 8a       	ld.ub	r10,r7[0x0]
80007fa4:	58 0a       	cp.w	r10,0
80007fa6:	c0 e0       	breq	80007fc2 <get_arg+0x266>
80007fa8:	23 0a       	sub	r10,48
80007faa:	58 9a       	cp.w	r10,9
80007fac:	fe 98 ff f6 	brls	80007f98 <get_arg+0x23c>
80007fb0:	c0 98       	rjmp	80007fc2 <get_arg+0x266>
80007fb2:	2f f7       	sub	r7,-1
80007fb4:	0f 8a       	ld.ub	r10,r7[0x0]
80007fb6:	58 0a       	cp.w	r10,0
80007fb8:	c0 50       	breq	80007fc2 <get_arg+0x266>
80007fba:	23 0a       	sub	r10,48
80007fbc:	58 9a       	cp.w	r10,9
80007fbe:	fe 98 ff fa 	brls	80007fb2 <get_arg+0x256>
80007fc2:	0e 9b       	mov	r11,r7
80007fc4:	40 7c       	lddsp	r12,sp[0x1c]
80007fc6:	30 ba       	mov	r10,11
80007fc8:	f4 0c 18 00 	cp.b	r12,r10
80007fcc:	fe 91 fe f2 	brne	80007db0 <get_arg+0x54>
80007fd0:	40 42       	lddsp	r2,sp[0x10]
80007fd2:	17 8c       	ld.ub	r12,r11[0x0]
80007fd4:	0a 32       	cp.w	r2,r5
80007fd6:	5f 4a       	srge	r10
80007fd8:	f0 0c 18 00 	cp.b	r12,r8
80007fdc:	5f 1c       	srne	r12
80007fde:	f9 ea 00 0a 	and	r10,r12,r10
80007fe2:	f0 0a 18 00 	cp.b	r10,r8
80007fe6:	fe 91 fe cf 	brne	80007d84 <get_arg+0x28>
80007fea:	30 08       	mov	r8,0
80007fec:	40 4e       	lddsp	lr,sp[0x10]
80007fee:	17 8a       	ld.ub	r10,r11[0x0]
80007ff0:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007ff4:	f0 0a 18 00 	cp.b	r10,r8
80007ff8:	fc 09 17 10 	movne	r9,lr
80007ffc:	e6 05 00 38 	add	r8,r3,r5<<0x3
80008000:	06 9e       	mov	lr,r3
80008002:	c2 a8       	rjmp	80008056 <get_arg+0x2fa>
80008004:	62 0a       	ld.w	r10,r1[0x0]
80008006:	58 3a       	cp.w	r10,3
80008008:	c1 e0       	breq	80008044 <get_arg+0x2e8>
8000800a:	e0 89 00 07 	brgt	80008018 <get_arg+0x2bc>
8000800e:	58 1a       	cp.w	r10,1
80008010:	c1 a0       	breq	80008044 <get_arg+0x2e8>
80008012:	58 2a       	cp.w	r10,2
80008014:	c1 81       	brne	80008044 <get_arg+0x2e8>
80008016:	c0 58       	rjmp	80008020 <get_arg+0x2c4>
80008018:	58 5a       	cp.w	r10,5
8000801a:	c0 c0       	breq	80008032 <get_arg+0x2d6>
8000801c:	c0 b5       	brlt	80008032 <get_arg+0x2d6>
8000801e:	c1 38       	rjmp	80008044 <get_arg+0x2e8>
80008020:	6c 0a       	ld.w	r10,r6[0x0]
80008022:	f4 cc ff f8 	sub	r12,r10,-8
80008026:	8d 0c       	st.w	r6[0x0],r12
80008028:	f4 e2 00 00 	ld.d	r2,r10[0]
8000802c:	f0 e3 00 00 	st.d	r8[0],r2
80008030:	c1 08       	rjmp	80008050 <get_arg+0x2f4>
80008032:	6c 0a       	ld.w	r10,r6[0x0]
80008034:	f4 cc ff f8 	sub	r12,r10,-8
80008038:	8d 0c       	st.w	r6[0x0],r12
8000803a:	f4 e2 00 00 	ld.d	r2,r10[0]
8000803e:	f0 e3 00 00 	st.d	r8[0],r2
80008042:	c0 78       	rjmp	80008050 <get_arg+0x2f4>
80008044:	6c 0a       	ld.w	r10,r6[0x0]
80008046:	f4 cc ff fc 	sub	r12,r10,-4
8000804a:	8d 0c       	st.w	r6[0x0],r12
8000804c:	74 0a       	ld.w	r10,r10[0x0]
8000804e:	91 0a       	st.w	r8[0x0],r10
80008050:	2f f5       	sub	r5,-1
80008052:	2f 88       	sub	r8,-8
80008054:	2f c1       	sub	r1,-4
80008056:	12 35       	cp.w	r5,r9
80008058:	fe 9a ff d6 	brle	80008004 <get_arg+0x2a8>
8000805c:	1c 93       	mov	r3,lr
8000805e:	40 52       	lddsp	r2,sp[0x14]
80008060:	40 6e       	lddsp	lr,sp[0x18]
80008062:	85 05       	st.w	r2[0x0],r5
80008064:	9d 0b       	st.w	lr[0x0],r11
80008066:	40 4b       	lddsp	r11,sp[0x10]
80008068:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000806c:	2f 8d       	sub	sp,-32
8000806e:	d8 32       	popm	r0-r7,pc

80008070 <__sprint_r>:
80008070:	d4 21       	pushm	r4-r7,lr
80008072:	14 97       	mov	r7,r10
80008074:	74 28       	ld.w	r8,r10[0x8]
80008076:	58 08       	cp.w	r8,0
80008078:	c0 41       	brne	80008080 <__sprint_r+0x10>
8000807a:	95 18       	st.w	r10[0x4],r8
8000807c:	10 9c       	mov	r12,r8
8000807e:	d8 22       	popm	r4-r7,pc
80008080:	e0 a0 18 ba 	rcall	8000b1f4 <__sfvwrite_r>
80008084:	30 08       	mov	r8,0
80008086:	8f 18       	st.w	r7[0x4],r8
80008088:	8f 28       	st.w	r7[0x8],r8
8000808a:	d8 22       	popm	r4-r7,pc

8000808c <_vfprintf_r>:
8000808c:	d4 31       	pushm	r0-r7,lr
8000808e:	fa cd 06 bc 	sub	sp,sp,1724
80008092:	51 09       	stdsp	sp[0x40],r9
80008094:	16 91       	mov	r1,r11
80008096:	14 97       	mov	r7,r10
80008098:	18 95       	mov	r5,r12
8000809a:	e0 a0 1a 1d 	rcall	8000b4d4 <_localeconv_r>
8000809e:	78 0c       	ld.w	r12,r12[0x0]
800080a0:	50 cc       	stdsp	sp[0x30],r12
800080a2:	58 05       	cp.w	r5,0
800080a4:	c0 70       	breq	800080b2 <_vfprintf_r+0x26>
800080a6:	6a 68       	ld.w	r8,r5[0x18]
800080a8:	58 08       	cp.w	r8,0
800080aa:	c0 41       	brne	800080b2 <_vfprintf_r+0x26>
800080ac:	0a 9c       	mov	r12,r5
800080ae:	e0 a0 17 43 	rcall	8000af34 <__sinit>
800080b2:	fe c8 9f 9a 	sub	r8,pc,-24678
800080b6:	10 31       	cp.w	r1,r8
800080b8:	c0 31       	brne	800080be <_vfprintf_r+0x32>
800080ba:	6a 01       	ld.w	r1,r5[0x0]
800080bc:	c0 c8       	rjmp	800080d4 <_vfprintf_r+0x48>
800080be:	fe c8 9f 86 	sub	r8,pc,-24698
800080c2:	10 31       	cp.w	r1,r8
800080c4:	c0 31       	brne	800080ca <_vfprintf_r+0x3e>
800080c6:	6a 11       	ld.w	r1,r5[0x4]
800080c8:	c0 68       	rjmp	800080d4 <_vfprintf_r+0x48>
800080ca:	fe c8 9f 72 	sub	r8,pc,-24718
800080ce:	10 31       	cp.w	r1,r8
800080d0:	eb f1 00 02 	ld.weq	r1,r5[0x8]
800080d4:	82 68       	ld.sh	r8,r1[0xc]
800080d6:	ed b8 00 03 	bld	r8,0x3
800080da:	c0 41       	brne	800080e2 <_vfprintf_r+0x56>
800080dc:	62 48       	ld.w	r8,r1[0x10]
800080de:	58 08       	cp.w	r8,0
800080e0:	c0 71       	brne	800080ee <_vfprintf_r+0x62>
800080e2:	02 9b       	mov	r11,r1
800080e4:	0a 9c       	mov	r12,r5
800080e6:	e0 a0 0f 5d 	rcall	80009fa0 <__swsetup_r>
800080ea:	e0 81 0f 54 	brne	80009f92 <_vfprintf_r+0x1f06>
800080ee:	82 68       	ld.sh	r8,r1[0xc]
800080f0:	10 99       	mov	r9,r8
800080f2:	e2 19 00 1a 	andl	r9,0x1a,COH
800080f6:	58 a9       	cp.w	r9,10
800080f8:	c3 c1       	brne	80008170 <_vfprintf_r+0xe4>
800080fa:	82 79       	ld.sh	r9,r1[0xe]
800080fc:	30 0a       	mov	r10,0
800080fe:	f4 09 19 00 	cp.h	r9,r10
80008102:	c3 75       	brlt	80008170 <_vfprintf_r+0xe4>
80008104:	a1 d8       	cbr	r8,0x1
80008106:	fb 58 05 d0 	st.h	sp[1488],r8
8000810a:	62 88       	ld.w	r8,r1[0x20]
8000810c:	fb 48 05 e4 	st.w	sp[1508],r8
80008110:	62 a8       	ld.w	r8,r1[0x28]
80008112:	fb 48 05 ec 	st.w	sp[1516],r8
80008116:	fa c8 ff bc 	sub	r8,sp,-68
8000811a:	fb 48 05 d4 	st.w	sp[1492],r8
8000811e:	fb 48 05 c4 	st.w	sp[1476],r8
80008122:	e0 68 04 00 	mov	r8,1024
80008126:	fb 48 05 d8 	st.w	sp[1496],r8
8000812a:	fb 48 05 cc 	st.w	sp[1484],r8
8000812e:	30 08       	mov	r8,0
80008130:	fb 59 05 d2 	st.h	sp[1490],r9
80008134:	0e 9a       	mov	r10,r7
80008136:	41 09       	lddsp	r9,sp[0x40]
80008138:	fa c7 fa 3c 	sub	r7,sp,-1476
8000813c:	fb 48 05 dc 	st.w	sp[1500],r8
80008140:	0a 9c       	mov	r12,r5
80008142:	0e 9b       	mov	r11,r7
80008144:	ca 4f       	rcall	8000808c <_vfprintf_r>
80008146:	50 bc       	stdsp	sp[0x2c],r12
80008148:	c0 95       	brlt	8000815a <_vfprintf_r+0xce>
8000814a:	0e 9b       	mov	r11,r7
8000814c:	0a 9c       	mov	r12,r5
8000814e:	e0 a0 16 1b 	rcall	8000ad84 <_fflush_r>
80008152:	40 be       	lddsp	lr,sp[0x2c]
80008154:	f9 be 01 ff 	movne	lr,-1
80008158:	50 be       	stdsp	sp[0x2c],lr
8000815a:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000815e:	ed b8 00 06 	bld	r8,0x6
80008162:	e0 81 0f 1a 	brne	80009f96 <_vfprintf_r+0x1f0a>
80008166:	82 68       	ld.sh	r8,r1[0xc]
80008168:	a7 a8       	sbr	r8,0x6
8000816a:	a2 68       	st.h	r1[0xc],r8
8000816c:	e0 8f 0f 15 	bral	80009f96 <_vfprintf_r+0x1f0a>
80008170:	30 08       	mov	r8,0
80008172:	fb 48 06 b4 	st.w	sp[1716],r8
80008176:	fb 48 06 90 	st.w	sp[1680],r8
8000817a:	fb 48 06 8c 	st.w	sp[1676],r8
8000817e:	fb 48 06 b0 	st.w	sp[1712],r8
80008182:	30 08       	mov	r8,0
80008184:	30 09       	mov	r9,0
80008186:	50 a7       	stdsp	sp[0x28],r7
80008188:	50 78       	stdsp	sp[0x1c],r8
8000818a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000818e:	3f f8       	mov	r8,-1
80008190:	50 59       	stdsp	sp[0x14],r9
80008192:	fb 43 06 88 	st.w	sp[1672],r3
80008196:	fb 48 05 44 	st.w	sp[1348],r8
8000819a:	12 9c       	mov	r12,r9
8000819c:	50 69       	stdsp	sp[0x18],r9
8000819e:	50 d9       	stdsp	sp[0x34],r9
800081a0:	50 e9       	stdsp	sp[0x38],r9
800081a2:	50 b9       	stdsp	sp[0x2c],r9
800081a4:	12 97       	mov	r7,r9
800081a6:	0a 94       	mov	r4,r5
800081a8:	40 a2       	lddsp	r2,sp[0x28]
800081aa:	32 5a       	mov	r10,37
800081ac:	30 08       	mov	r8,0
800081ae:	c0 28       	rjmp	800081b2 <_vfprintf_r+0x126>
800081b0:	2f f2       	sub	r2,-1
800081b2:	05 89       	ld.ub	r9,r2[0x0]
800081b4:	f0 09 18 00 	cp.b	r9,r8
800081b8:	5f 1b       	srne	r11
800081ba:	f4 09 18 00 	cp.b	r9,r10
800081be:	5f 19       	srne	r9
800081c0:	f3 eb 00 0b 	and	r11,r9,r11
800081c4:	f0 0b 18 00 	cp.b	r11,r8
800081c8:	cf 41       	brne	800081b0 <_vfprintf_r+0x124>
800081ca:	40 ab       	lddsp	r11,sp[0x28]
800081cc:	e4 0b 01 06 	sub	r6,r2,r11
800081d0:	c1 e0       	breq	8000820c <_vfprintf_r+0x180>
800081d2:	fa f8 06 90 	ld.w	r8,sp[1680]
800081d6:	0c 08       	add	r8,r6
800081d8:	87 0b       	st.w	r3[0x0],r11
800081da:	fb 48 06 90 	st.w	sp[1680],r8
800081de:	87 16       	st.w	r3[0x4],r6
800081e0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800081e4:	2f f8       	sub	r8,-1
800081e6:	fb 48 06 8c 	st.w	sp[1676],r8
800081ea:	58 78       	cp.w	r8,7
800081ec:	e0 89 00 04 	brgt	800081f4 <_vfprintf_r+0x168>
800081f0:	2f 83       	sub	r3,-8
800081f2:	c0 a8       	rjmp	80008206 <_vfprintf_r+0x17a>
800081f4:	fa ca f9 78 	sub	r10,sp,-1672
800081f8:	02 9b       	mov	r11,r1
800081fa:	08 9c       	mov	r12,r4
800081fc:	c3 af       	rcall	80008070 <__sprint_r>
800081fe:	e0 81 0e c6 	brne	80009f8a <_vfprintf_r+0x1efe>
80008202:	fa c3 f9 e0 	sub	r3,sp,-1568
80008206:	40 ba       	lddsp	r10,sp[0x2c]
80008208:	0c 0a       	add	r10,r6
8000820a:	50 ba       	stdsp	sp[0x2c],r10
8000820c:	05 89       	ld.ub	r9,r2[0x0]
8000820e:	30 08       	mov	r8,0
80008210:	f0 09 18 00 	cp.b	r9,r8
80008214:	e0 80 0e aa 	breq	80009f68 <_vfprintf_r+0x1edc>
80008218:	30 09       	mov	r9,0
8000821a:	fb 68 06 bb 	st.b	sp[1723],r8
8000821e:	0e 96       	mov	r6,r7
80008220:	e4 c8 ff ff 	sub	r8,r2,-1
80008224:	3f fe       	mov	lr,-1
80008226:	50 93       	stdsp	sp[0x24],r3
80008228:	50 41       	stdsp	sp[0x10],r1
8000822a:	0e 93       	mov	r3,r7
8000822c:	04 91       	mov	r1,r2
8000822e:	50 89       	stdsp	sp[0x20],r9
80008230:	50 a8       	stdsp	sp[0x28],r8
80008232:	50 2e       	stdsp	sp[0x8],lr
80008234:	50 39       	stdsp	sp[0xc],r9
80008236:	12 95       	mov	r5,r9
80008238:	12 90       	mov	r0,r9
8000823a:	10 97       	mov	r7,r8
8000823c:	08 92       	mov	r2,r4
8000823e:	c0 78       	rjmp	8000824c <_vfprintf_r+0x1c0>
80008240:	3f fc       	mov	r12,-1
80008242:	08 97       	mov	r7,r4
80008244:	50 2c       	stdsp	sp[0x8],r12
80008246:	c0 38       	rjmp	8000824c <_vfprintf_r+0x1c0>
80008248:	30 0b       	mov	r11,0
8000824a:	50 3b       	stdsp	sp[0xc],r11
8000824c:	0f 38       	ld.ub	r8,r7++
8000824e:	c0 28       	rjmp	80008252 <_vfprintf_r+0x1c6>
80008250:	12 90       	mov	r0,r9
80008252:	f0 c9 00 20 	sub	r9,r8,32
80008256:	e0 49 00 58 	cp.w	r9,88
8000825a:	e0 8b 0a 30 	brhi	800096ba <_vfprintf_r+0x162e>
8000825e:	fe ca a4 ee 	sub	r10,pc,-23314
80008262:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80008266:	50 a7       	stdsp	sp[0x28],r7
80008268:	50 80       	stdsp	sp[0x20],r0
8000826a:	0c 97       	mov	r7,r6
8000826c:	04 94       	mov	r4,r2
8000826e:	06 96       	mov	r6,r3
80008270:	02 92       	mov	r2,r1
80008272:	fe c9 a2 c6 	sub	r9,pc,-23866
80008276:	40 93       	lddsp	r3,sp[0x24]
80008278:	10 90       	mov	r0,r8
8000827a:	40 41       	lddsp	r1,sp[0x10]
8000827c:	50 d9       	stdsp	sp[0x34],r9
8000827e:	e0 8f 08 8e 	bral	8000939a <_vfprintf_r+0x130e>
80008282:	30 08       	mov	r8,0
80008284:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80008288:	f0 09 18 00 	cp.b	r9,r8
8000828c:	ce 01       	brne	8000824c <_vfprintf_r+0x1c0>
8000828e:	32 08       	mov	r8,32
80008290:	c6 e8       	rjmp	8000836c <_vfprintf_r+0x2e0>
80008292:	a1 a5       	sbr	r5,0x0
80008294:	cd cb       	rjmp	8000824c <_vfprintf_r+0x1c0>
80008296:	0f 89       	ld.ub	r9,r7[0x0]
80008298:	f2 c8 00 30 	sub	r8,r9,48
8000829c:	58 98       	cp.w	r8,9
8000829e:	e0 8b 00 1d 	brhi	800082d8 <_vfprintf_r+0x24c>
800082a2:	ee c8 ff ff 	sub	r8,r7,-1
800082a6:	30 0b       	mov	r11,0
800082a8:	23 09       	sub	r9,48
800082aa:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800082ae:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
800082b2:	11 39       	ld.ub	r9,r8++
800082b4:	f2 ca 00 30 	sub	r10,r9,48
800082b8:	58 9a       	cp.w	r10,9
800082ba:	fe 98 ff f7 	brls	800082a8 <_vfprintf_r+0x21c>
800082be:	e0 49 00 24 	cp.w	r9,36
800082c2:	cc 31       	brne	80008248 <_vfprintf_r+0x1bc>
800082c4:	e0 4b 00 20 	cp.w	r11,32
800082c8:	e0 89 0e 60 	brgt	80009f88 <_vfprintf_r+0x1efc>
800082cc:	20 1b       	sub	r11,1
800082ce:	fa f9 06 b4 	ld.w	r9,sp[1716]
800082d2:	12 3b       	cp.w	r11,r9
800082d4:	c0 95       	brlt	800082e6 <_vfprintf_r+0x25a>
800082d6:	c1 08       	rjmp	800082f6 <_vfprintf_r+0x26a>
800082d8:	fa f9 06 b4 	ld.w	r9,sp[1716]
800082dc:	ec ca ff ff 	sub	r10,r6,-1
800082e0:	12 36       	cp.w	r6,r9
800082e2:	c1 f5       	brlt	80008320 <_vfprintf_r+0x294>
800082e4:	c2 68       	rjmp	80008330 <_vfprintf_r+0x2a4>
800082e6:	fa ce f9 44 	sub	lr,sp,-1724
800082ea:	10 97       	mov	r7,r8
800082ec:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
800082f0:	f6 f0 fd 88 	ld.w	r0,r11[-632]
800082f4:	c3 58       	rjmp	8000835e <_vfprintf_r+0x2d2>
800082f6:	10 97       	mov	r7,r8
800082f8:	fa c8 f9 50 	sub	r8,sp,-1712
800082fc:	1a d8       	st.w	--sp,r8
800082fe:	fa c8 fa b8 	sub	r8,sp,-1352
80008302:	1a d8       	st.w	--sp,r8
80008304:	fa c8 fb b4 	sub	r8,sp,-1100
80008308:	02 9a       	mov	r10,r1
8000830a:	1a d8       	st.w	--sp,r8
8000830c:	04 9c       	mov	r12,r2
8000830e:	fa c8 f9 40 	sub	r8,sp,-1728
80008312:	fa c9 ff b4 	sub	r9,sp,-76
80008316:	fe b0 fd 23 	rcall	80007d5c <get_arg>
8000831a:	2f dd       	sub	sp,-12
8000831c:	78 00       	ld.w	r0,r12[0x0]
8000831e:	c2 08       	rjmp	8000835e <_vfprintf_r+0x2d2>
80008320:	fa cc f9 44 	sub	r12,sp,-1724
80008324:	14 96       	mov	r6,r10
80008326:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000832a:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000832e:	c1 88       	rjmp	8000835e <_vfprintf_r+0x2d2>
80008330:	41 08       	lddsp	r8,sp[0x40]
80008332:	59 f9       	cp.w	r9,31
80008334:	e0 89 00 11 	brgt	80008356 <_vfprintf_r+0x2ca>
80008338:	f0 cb ff fc 	sub	r11,r8,-4
8000833c:	51 0b       	stdsp	sp[0x40],r11
8000833e:	70 00       	ld.w	r0,r8[0x0]
80008340:	fa cb f9 44 	sub	r11,sp,-1724
80008344:	f6 09 00 38 	add	r8,r11,r9<<0x3
80008348:	f1 40 fd 88 	st.w	r8[-632],r0
8000834c:	2f f9       	sub	r9,-1
8000834e:	14 96       	mov	r6,r10
80008350:	fb 49 06 b4 	st.w	sp[1716],r9
80008354:	c0 58       	rjmp	8000835e <_vfprintf_r+0x2d2>
80008356:	70 00       	ld.w	r0,r8[0x0]
80008358:	14 96       	mov	r6,r10
8000835a:	2f c8       	sub	r8,-4
8000835c:	51 08       	stdsp	sp[0x40],r8
8000835e:	58 00       	cp.w	r0,0
80008360:	fe 94 ff 76 	brge	8000824c <_vfprintf_r+0x1c0>
80008364:	5c 30       	neg	r0
80008366:	a3 a5       	sbr	r5,0x2
80008368:	c7 2b       	rjmp	8000824c <_vfprintf_r+0x1c0>
8000836a:	32 b8       	mov	r8,43
8000836c:	fb 68 06 bb 	st.b	sp[1723],r8
80008370:	c6 eb       	rjmp	8000824c <_vfprintf_r+0x1c0>
80008372:	0f 38       	ld.ub	r8,r7++
80008374:	e0 48 00 2a 	cp.w	r8,42
80008378:	c0 30       	breq	8000837e <_vfprintf_r+0x2f2>
8000837a:	30 09       	mov	r9,0
8000837c:	c7 98       	rjmp	8000846e <_vfprintf_r+0x3e2>
8000837e:	0f 88       	ld.ub	r8,r7[0x0]
80008380:	f0 c9 00 30 	sub	r9,r8,48
80008384:	58 99       	cp.w	r9,9
80008386:	e0 8b 00 1f 	brhi	800083c4 <_vfprintf_r+0x338>
8000838a:	ee c4 ff ff 	sub	r4,r7,-1
8000838e:	30 0b       	mov	r11,0
80008390:	23 08       	sub	r8,48
80008392:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008396:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000839a:	09 38       	ld.ub	r8,r4++
8000839c:	f0 c9 00 30 	sub	r9,r8,48
800083a0:	58 99       	cp.w	r9,9
800083a2:	fe 98 ff f7 	brls	80008390 <_vfprintf_r+0x304>
800083a6:	e0 48 00 24 	cp.w	r8,36
800083aa:	fe 91 ff 4f 	brne	80008248 <_vfprintf_r+0x1bc>
800083ae:	e0 4b 00 20 	cp.w	r11,32
800083b2:	e0 89 0d eb 	brgt	80009f88 <_vfprintf_r+0x1efc>
800083b6:	20 1b       	sub	r11,1
800083b8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800083bc:	10 3b       	cp.w	r11,r8
800083be:	c0 a5       	brlt	800083d2 <_vfprintf_r+0x346>
800083c0:	c1 18       	rjmp	800083e2 <_vfprintf_r+0x356>
800083c2:	d7 03       	nop
800083c4:	fa fa 06 b4 	ld.w	r10,sp[1716]
800083c8:	ec c9 ff ff 	sub	r9,r6,-1
800083cc:	14 36       	cp.w	r6,r10
800083ce:	c1 f5       	brlt	8000840c <_vfprintf_r+0x380>
800083d0:	c2 88       	rjmp	80008420 <_vfprintf_r+0x394>
800083d2:	fa ca f9 44 	sub	r10,sp,-1724
800083d6:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
800083da:	f6 fb fd 88 	ld.w	r11,r11[-632]
800083de:	50 2b       	stdsp	sp[0x8],r11
800083e0:	c3 c8       	rjmp	80008458 <_vfprintf_r+0x3cc>
800083e2:	fa c8 f9 50 	sub	r8,sp,-1712
800083e6:	1a d8       	st.w	--sp,r8
800083e8:	fa c8 fa b8 	sub	r8,sp,-1352
800083ec:	1a d8       	st.w	--sp,r8
800083ee:	fa c8 fb b4 	sub	r8,sp,-1100
800083f2:	02 9a       	mov	r10,r1
800083f4:	1a d8       	st.w	--sp,r8
800083f6:	04 9c       	mov	r12,r2
800083f8:	fa c8 f9 40 	sub	r8,sp,-1728
800083fc:	fa c9 ff b4 	sub	r9,sp,-76
80008400:	fe b0 fc ae 	rcall	80007d5c <get_arg>
80008404:	2f dd       	sub	sp,-12
80008406:	78 0c       	ld.w	r12,r12[0x0]
80008408:	50 2c       	stdsp	sp[0x8],r12
8000840a:	c2 78       	rjmp	80008458 <_vfprintf_r+0x3cc>
8000840c:	12 96       	mov	r6,r9
8000840e:	0e 94       	mov	r4,r7
80008410:	fa c9 f9 44 	sub	r9,sp,-1724
80008414:	f2 03 00 38 	add	r8,r9,r3<<0x3
80008418:	f0 f8 fd 88 	ld.w	r8,r8[-632]
8000841c:	50 28       	stdsp	sp[0x8],r8
8000841e:	c1 d8       	rjmp	80008458 <_vfprintf_r+0x3cc>
80008420:	41 08       	lddsp	r8,sp[0x40]
80008422:	59 fa       	cp.w	r10,31
80008424:	e0 89 00 14 	brgt	8000844c <_vfprintf_r+0x3c0>
80008428:	f0 cb ff fc 	sub	r11,r8,-4
8000842c:	70 08       	ld.w	r8,r8[0x0]
8000842e:	51 0b       	stdsp	sp[0x40],r11
80008430:	50 28       	stdsp	sp[0x8],r8
80008432:	fa c6 f9 44 	sub	r6,sp,-1724
80008436:	40 2e       	lddsp	lr,sp[0x8]
80008438:	ec 0a 00 38 	add	r8,r6,r10<<0x3
8000843c:	f1 4e fd 88 	st.w	r8[-632],lr
80008440:	2f fa       	sub	r10,-1
80008442:	0e 94       	mov	r4,r7
80008444:	fb 4a 06 b4 	st.w	sp[1716],r10
80008448:	12 96       	mov	r6,r9
8000844a:	c0 78       	rjmp	80008458 <_vfprintf_r+0x3cc>
8000844c:	70 0c       	ld.w	r12,r8[0x0]
8000844e:	0e 94       	mov	r4,r7
80008450:	2f c8       	sub	r8,-4
80008452:	50 2c       	stdsp	sp[0x8],r12
80008454:	12 96       	mov	r6,r9
80008456:	51 08       	stdsp	sp[0x40],r8
80008458:	40 2b       	lddsp	r11,sp[0x8]
8000845a:	58 0b       	cp.w	r11,0
8000845c:	fe 95 fe f2 	brlt	80008240 <_vfprintf_r+0x1b4>
80008460:	08 97       	mov	r7,r4
80008462:	cf 5a       	rjmp	8000824c <_vfprintf_r+0x1c0>
80008464:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008468:	0f 38       	ld.ub	r8,r7++
8000846a:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000846e:	f0 ca 00 30 	sub	r10,r8,48
80008472:	58 9a       	cp.w	r10,9
80008474:	fe 98 ff f8 	brls	80008464 <_vfprintf_r+0x3d8>
80008478:	3f fa       	mov	r10,-1
8000847a:	f2 0a 0c 49 	max	r9,r9,r10
8000847e:	50 29       	stdsp	sp[0x8],r9
80008480:	ce 9a       	rjmp	80008252 <_vfprintf_r+0x1c6>
80008482:	a7 b5       	sbr	r5,0x7
80008484:	ce 4a       	rjmp	8000824c <_vfprintf_r+0x1c0>
80008486:	30 09       	mov	r9,0
80008488:	23 08       	sub	r8,48
8000848a:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000848e:	f0 09 00 19 	add	r9,r8,r9<<0x1
80008492:	0f 38       	ld.ub	r8,r7++
80008494:	f0 ca 00 30 	sub	r10,r8,48
80008498:	58 9a       	cp.w	r10,9
8000849a:	fe 98 ff f7 	brls	80008488 <_vfprintf_r+0x3fc>
8000849e:	e0 48 00 24 	cp.w	r8,36
800084a2:	fe 91 fe d7 	brne	80008250 <_vfprintf_r+0x1c4>
800084a6:	e0 49 00 20 	cp.w	r9,32
800084aa:	e0 89 0d 6f 	brgt	80009f88 <_vfprintf_r+0x1efc>
800084ae:	f2 c3 00 01 	sub	r3,r9,1
800084b2:	30 19       	mov	r9,1
800084b4:	50 39       	stdsp	sp[0xc],r9
800084b6:	cc ba       	rjmp	8000824c <_vfprintf_r+0x1c0>
800084b8:	a3 b5       	sbr	r5,0x3
800084ba:	cc 9a       	rjmp	8000824c <_vfprintf_r+0x1c0>
800084bc:	a7 a5       	sbr	r5,0x6
800084be:	cc 7a       	rjmp	8000824c <_vfprintf_r+0x1c0>
800084c0:	0a 98       	mov	r8,r5
800084c2:	a5 b5       	sbr	r5,0x5
800084c4:	a5 a8       	sbr	r8,0x4
800084c6:	0f 89       	ld.ub	r9,r7[0x0]
800084c8:	36 ce       	mov	lr,108
800084ca:	fc 09 18 00 	cp.b	r9,lr
800084ce:	f7 b7 00 ff 	subeq	r7,-1
800084d2:	f0 05 17 10 	movne	r5,r8
800084d6:	cb ba       	rjmp	8000824c <_vfprintf_r+0x1c0>
800084d8:	a5 b5       	sbr	r5,0x5
800084da:	cb 9a       	rjmp	8000824c <_vfprintf_r+0x1c0>
800084dc:	50 a7       	stdsp	sp[0x28],r7
800084de:	50 80       	stdsp	sp[0x20],r0
800084e0:	0c 97       	mov	r7,r6
800084e2:	10 90       	mov	r0,r8
800084e4:	06 96       	mov	r6,r3
800084e6:	04 94       	mov	r4,r2
800084e8:	40 93       	lddsp	r3,sp[0x24]
800084ea:	02 92       	mov	r2,r1
800084ec:	0e 99       	mov	r9,r7
800084ee:	40 41       	lddsp	r1,sp[0x10]
800084f0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084f4:	40 3c       	lddsp	r12,sp[0xc]
800084f6:	58 0c       	cp.w	r12,0
800084f8:	c1 d0       	breq	80008532 <_vfprintf_r+0x4a6>
800084fa:	10 36       	cp.w	r6,r8
800084fc:	c0 64       	brge	80008508 <_vfprintf_r+0x47c>
800084fe:	fa cb f9 44 	sub	r11,sp,-1724
80008502:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008506:	c1 d8       	rjmp	80008540 <_vfprintf_r+0x4b4>
80008508:	fa c8 f9 50 	sub	r8,sp,-1712
8000850c:	1a d8       	st.w	--sp,r8
8000850e:	fa c8 fa b8 	sub	r8,sp,-1352
80008512:	1a d8       	st.w	--sp,r8
80008514:	fa c8 fb b4 	sub	r8,sp,-1100
80008518:	1a d8       	st.w	--sp,r8
8000851a:	fa c8 f9 40 	sub	r8,sp,-1728
8000851e:	fa c9 ff b4 	sub	r9,sp,-76
80008522:	04 9a       	mov	r10,r2
80008524:	0c 9b       	mov	r11,r6
80008526:	08 9c       	mov	r12,r4
80008528:	fe b0 fc 1a 	rcall	80007d5c <get_arg>
8000852c:	2f dd       	sub	sp,-12
8000852e:	19 b8       	ld.ub	r8,r12[0x3]
80008530:	c2 28       	rjmp	80008574 <_vfprintf_r+0x4e8>
80008532:	2f f7       	sub	r7,-1
80008534:	10 39       	cp.w	r9,r8
80008536:	c0 84       	brge	80008546 <_vfprintf_r+0x4ba>
80008538:	fa ca f9 44 	sub	r10,sp,-1724
8000853c:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008540:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80008544:	c1 88       	rjmp	80008574 <_vfprintf_r+0x4e8>
80008546:	41 09       	lddsp	r9,sp[0x40]
80008548:	59 f8       	cp.w	r8,31
8000854a:	e0 89 00 12 	brgt	8000856e <_vfprintf_r+0x4e2>
8000854e:	f2 ca ff fc 	sub	r10,r9,-4
80008552:	51 0a       	stdsp	sp[0x40],r10
80008554:	72 09       	ld.w	r9,r9[0x0]
80008556:	fa c6 f9 44 	sub	r6,sp,-1724
8000855a:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000855e:	2f f8       	sub	r8,-1
80008560:	f5 49 fd 88 	st.w	r10[-632],r9
80008564:	fb 48 06 b4 	st.w	sp[1716],r8
80008568:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000856c:	c0 48       	rjmp	80008574 <_vfprintf_r+0x4e8>
8000856e:	13 b8       	ld.ub	r8,r9[0x3]
80008570:	2f c9       	sub	r9,-4
80008572:	51 09       	stdsp	sp[0x40],r9
80008574:	fb 68 06 60 	st.b	sp[1632],r8
80008578:	30 0e       	mov	lr,0
8000857a:	30 08       	mov	r8,0
8000857c:	30 12       	mov	r2,1
8000857e:	fb 68 06 bb 	st.b	sp[1723],r8
80008582:	50 2e       	stdsp	sp[0x8],lr
80008584:	e0 8f 08 ad 	bral	800096de <_vfprintf_r+0x1652>
80008588:	50 a7       	stdsp	sp[0x28],r7
8000858a:	50 80       	stdsp	sp[0x20],r0
8000858c:	0c 97       	mov	r7,r6
8000858e:	04 94       	mov	r4,r2
80008590:	06 96       	mov	r6,r3
80008592:	02 92       	mov	r2,r1
80008594:	40 93       	lddsp	r3,sp[0x24]
80008596:	10 90       	mov	r0,r8
80008598:	40 41       	lddsp	r1,sp[0x10]
8000859a:	a5 a5       	sbr	r5,0x4
8000859c:	c0 a8       	rjmp	800085b0 <_vfprintf_r+0x524>
8000859e:	50 a7       	stdsp	sp[0x28],r7
800085a0:	50 80       	stdsp	sp[0x20],r0
800085a2:	0c 97       	mov	r7,r6
800085a4:	04 94       	mov	r4,r2
800085a6:	06 96       	mov	r6,r3
800085a8:	02 92       	mov	r2,r1
800085aa:	40 93       	lddsp	r3,sp[0x24]
800085ac:	10 90       	mov	r0,r8
800085ae:	40 41       	lddsp	r1,sp[0x10]
800085b0:	ed b5 00 05 	bld	r5,0x5
800085b4:	c5 11       	brne	80008656 <_vfprintf_r+0x5ca>
800085b6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800085ba:	40 3c       	lddsp	r12,sp[0xc]
800085bc:	58 0c       	cp.w	r12,0
800085be:	c1 e0       	breq	800085fa <_vfprintf_r+0x56e>
800085c0:	10 36       	cp.w	r6,r8
800085c2:	c0 64       	brge	800085ce <_vfprintf_r+0x542>
800085c4:	fa cb f9 44 	sub	r11,sp,-1724
800085c8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800085cc:	c2 08       	rjmp	8000860c <_vfprintf_r+0x580>
800085ce:	fa c8 f9 50 	sub	r8,sp,-1712
800085d2:	1a d8       	st.w	--sp,r8
800085d4:	fa c8 fa b8 	sub	r8,sp,-1352
800085d8:	0c 9b       	mov	r11,r6
800085da:	1a d8       	st.w	--sp,r8
800085dc:	fa c8 fb b4 	sub	r8,sp,-1100
800085e0:	1a d8       	st.w	--sp,r8
800085e2:	fa c9 ff b4 	sub	r9,sp,-76
800085e6:	fa c8 f9 40 	sub	r8,sp,-1728
800085ea:	04 9a       	mov	r10,r2
800085ec:	08 9c       	mov	r12,r4
800085ee:	fe b0 fb b7 	rcall	80007d5c <get_arg>
800085f2:	2f dd       	sub	sp,-12
800085f4:	78 1b       	ld.w	r11,r12[0x4]
800085f6:	78 09       	ld.w	r9,r12[0x0]
800085f8:	c2 b8       	rjmp	8000864e <_vfprintf_r+0x5c2>
800085fa:	ee ca ff ff 	sub	r10,r7,-1
800085fe:	10 37       	cp.w	r7,r8
80008600:	c0 b4       	brge	80008616 <_vfprintf_r+0x58a>
80008602:	fa c9 f9 44 	sub	r9,sp,-1724
80008606:	14 97       	mov	r7,r10
80008608:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000860c:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008610:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008614:	c1 d8       	rjmp	8000864e <_vfprintf_r+0x5c2>
80008616:	41 09       	lddsp	r9,sp[0x40]
80008618:	59 f8       	cp.w	r8,31
8000861a:	e0 89 00 14 	brgt	80008642 <_vfprintf_r+0x5b6>
8000861e:	f2 cb ff f8 	sub	r11,r9,-8
80008622:	51 0b       	stdsp	sp[0x40],r11
80008624:	fa c6 f9 44 	sub	r6,sp,-1724
80008628:	72 1b       	ld.w	r11,r9[0x4]
8000862a:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000862e:	72 09       	ld.w	r9,r9[0x0]
80008630:	f9 4b fd 8c 	st.w	r12[-628],r11
80008634:	f9 49 fd 88 	st.w	r12[-632],r9
80008638:	2f f8       	sub	r8,-1
8000863a:	14 97       	mov	r7,r10
8000863c:	fb 48 06 b4 	st.w	sp[1716],r8
80008640:	c0 78       	rjmp	8000864e <_vfprintf_r+0x5c2>
80008642:	f2 c8 ff f8 	sub	r8,r9,-8
80008646:	72 1b       	ld.w	r11,r9[0x4]
80008648:	14 97       	mov	r7,r10
8000864a:	51 08       	stdsp	sp[0x40],r8
8000864c:	72 09       	ld.w	r9,r9[0x0]
8000864e:	16 98       	mov	r8,r11
80008650:	fa e9 00 00 	st.d	sp[0],r8
80008654:	ca e8       	rjmp	800087b0 <_vfprintf_r+0x724>
80008656:	ed b5 00 04 	bld	r5,0x4
8000865a:	c1 71       	brne	80008688 <_vfprintf_r+0x5fc>
8000865c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008660:	40 3e       	lddsp	lr,sp[0xc]
80008662:	58 0e       	cp.w	lr,0
80008664:	c0 80       	breq	80008674 <_vfprintf_r+0x5e8>
80008666:	10 36       	cp.w	r6,r8
80008668:	c6 94       	brge	8000873a <_vfprintf_r+0x6ae>
8000866a:	fa cc f9 44 	sub	r12,sp,-1724
8000866e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008672:	c8 28       	rjmp	80008776 <_vfprintf_r+0x6ea>
80008674:	ee ca ff ff 	sub	r10,r7,-1
80008678:	10 37       	cp.w	r7,r8
8000867a:	e0 84 00 81 	brge	8000877c <_vfprintf_r+0x6f0>
8000867e:	fa cb f9 44 	sub	r11,sp,-1724
80008682:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008686:	c7 78       	rjmp	80008774 <_vfprintf_r+0x6e8>
80008688:	ed b5 00 06 	bld	r5,0x6
8000868c:	c4 b1       	brne	80008722 <_vfprintf_r+0x696>
8000868e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008692:	40 3c       	lddsp	r12,sp[0xc]
80008694:	58 0c       	cp.w	r12,0
80008696:	c1 d0       	breq	800086d0 <_vfprintf_r+0x644>
80008698:	10 36       	cp.w	r6,r8
8000869a:	c0 64       	brge	800086a6 <_vfprintf_r+0x61a>
8000869c:	fa cb f9 44 	sub	r11,sp,-1724
800086a0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800086a4:	c1 f8       	rjmp	800086e2 <_vfprintf_r+0x656>
800086a6:	fa c8 f9 50 	sub	r8,sp,-1712
800086aa:	1a d8       	st.w	--sp,r8
800086ac:	fa c8 fa b8 	sub	r8,sp,-1352
800086b0:	1a d8       	st.w	--sp,r8
800086b2:	fa c8 fb b4 	sub	r8,sp,-1100
800086b6:	1a d8       	st.w	--sp,r8
800086b8:	fa c8 f9 40 	sub	r8,sp,-1728
800086bc:	fa c9 ff b4 	sub	r9,sp,-76
800086c0:	04 9a       	mov	r10,r2
800086c2:	0c 9b       	mov	r11,r6
800086c4:	08 9c       	mov	r12,r4
800086c6:	fe b0 fb 4b 	rcall	80007d5c <get_arg>
800086ca:	2f dd       	sub	sp,-12
800086cc:	98 18       	ld.sh	r8,r12[0x2]
800086ce:	c2 68       	rjmp	8000871a <_vfprintf_r+0x68e>
800086d0:	ee ca ff ff 	sub	r10,r7,-1
800086d4:	10 37       	cp.w	r7,r8
800086d6:	c0 94       	brge	800086e8 <_vfprintf_r+0x65c>
800086d8:	fa c9 f9 44 	sub	r9,sp,-1724
800086dc:	14 97       	mov	r7,r10
800086de:	f2 06 00 36 	add	r6,r9,r6<<0x3
800086e2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800086e6:	c1 a8       	rjmp	8000871a <_vfprintf_r+0x68e>
800086e8:	41 09       	lddsp	r9,sp[0x40]
800086ea:	59 f8       	cp.w	r8,31
800086ec:	e0 89 00 13 	brgt	80008712 <_vfprintf_r+0x686>
800086f0:	f2 cb ff fc 	sub	r11,r9,-4
800086f4:	51 0b       	stdsp	sp[0x40],r11
800086f6:	72 09       	ld.w	r9,r9[0x0]
800086f8:	fa c6 f9 44 	sub	r6,sp,-1724
800086fc:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008700:	2f f8       	sub	r8,-1
80008702:	f7 49 fd 88 	st.w	r11[-632],r9
80008706:	fb 48 06 b4 	st.w	sp[1716],r8
8000870a:	14 97       	mov	r7,r10
8000870c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008710:	c0 58       	rjmp	8000871a <_vfprintf_r+0x68e>
80008712:	92 18       	ld.sh	r8,r9[0x2]
80008714:	14 97       	mov	r7,r10
80008716:	2f c9       	sub	r9,-4
80008718:	51 09       	stdsp	sp[0x40],r9
8000871a:	50 18       	stdsp	sp[0x4],r8
8000871c:	bf 58       	asr	r8,0x1f
8000871e:	50 08       	stdsp	sp[0x0],r8
80008720:	c4 88       	rjmp	800087b0 <_vfprintf_r+0x724>
80008722:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008726:	40 3c       	lddsp	r12,sp[0xc]
80008728:	58 0c       	cp.w	r12,0
8000872a:	c1 d0       	breq	80008764 <_vfprintf_r+0x6d8>
8000872c:	10 36       	cp.w	r6,r8
8000872e:	c0 64       	brge	8000873a <_vfprintf_r+0x6ae>
80008730:	fa cb f9 44 	sub	r11,sp,-1724
80008734:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008738:	c1 f8       	rjmp	80008776 <_vfprintf_r+0x6ea>
8000873a:	fa c8 f9 50 	sub	r8,sp,-1712
8000873e:	1a d8       	st.w	--sp,r8
80008740:	fa c8 fa b8 	sub	r8,sp,-1352
80008744:	0c 9b       	mov	r11,r6
80008746:	1a d8       	st.w	--sp,r8
80008748:	fa c8 fb b4 	sub	r8,sp,-1100
8000874c:	04 9a       	mov	r10,r2
8000874e:	1a d8       	st.w	--sp,r8
80008750:	08 9c       	mov	r12,r4
80008752:	fa c8 f9 40 	sub	r8,sp,-1728
80008756:	fa c9 ff b4 	sub	r9,sp,-76
8000875a:	fe b0 fb 01 	rcall	80007d5c <get_arg>
8000875e:	2f dd       	sub	sp,-12
80008760:	78 0b       	ld.w	r11,r12[0x0]
80008762:	c2 48       	rjmp	800087aa <_vfprintf_r+0x71e>
80008764:	ee ca ff ff 	sub	r10,r7,-1
80008768:	10 37       	cp.w	r7,r8
8000876a:	c0 94       	brge	8000877c <_vfprintf_r+0x6f0>
8000876c:	fa c9 f9 44 	sub	r9,sp,-1724
80008770:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008774:	14 97       	mov	r7,r10
80008776:	ec fb fd 88 	ld.w	r11,r6[-632]
8000877a:	c1 88       	rjmp	800087aa <_vfprintf_r+0x71e>
8000877c:	41 09       	lddsp	r9,sp[0x40]
8000877e:	59 f8       	cp.w	r8,31
80008780:	e0 89 00 11 	brgt	800087a2 <_vfprintf_r+0x716>
80008784:	f2 cb ff fc 	sub	r11,r9,-4
80008788:	51 0b       	stdsp	sp[0x40],r11
8000878a:	fa c6 f9 44 	sub	r6,sp,-1724
8000878e:	72 0b       	ld.w	r11,r9[0x0]
80008790:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008794:	f3 4b fd 88 	st.w	r9[-632],r11
80008798:	2f f8       	sub	r8,-1
8000879a:	14 97       	mov	r7,r10
8000879c:	fb 48 06 b4 	st.w	sp[1716],r8
800087a0:	c0 58       	rjmp	800087aa <_vfprintf_r+0x71e>
800087a2:	72 0b       	ld.w	r11,r9[0x0]
800087a4:	14 97       	mov	r7,r10
800087a6:	2f c9       	sub	r9,-4
800087a8:	51 09       	stdsp	sp[0x40],r9
800087aa:	50 1b       	stdsp	sp[0x4],r11
800087ac:	bf 5b       	asr	r11,0x1f
800087ae:	50 0b       	stdsp	sp[0x0],r11
800087b0:	fa ea 00 00 	ld.d	r10,sp[0]
800087b4:	58 0a       	cp.w	r10,0
800087b6:	5c 2b       	cpc	r11
800087b8:	c0 e4       	brge	800087d4 <_vfprintf_r+0x748>
800087ba:	30 08       	mov	r8,0
800087bc:	fa ea 00 00 	ld.d	r10,sp[0]
800087c0:	30 09       	mov	r9,0
800087c2:	f0 0a 01 0a 	sub	r10,r8,r10
800087c6:	f2 0b 01 4b 	sbc	r11,r9,r11
800087ca:	32 d8       	mov	r8,45
800087cc:	fa eb 00 00 	st.d	sp[0],r10
800087d0:	fb 68 06 bb 	st.b	sp[1723],r8
800087d4:	30 18       	mov	r8,1
800087d6:	e0 8f 06 fa 	bral	800095ca <_vfprintf_r+0x153e>
800087da:	50 a7       	stdsp	sp[0x28],r7
800087dc:	50 80       	stdsp	sp[0x20],r0
800087de:	0c 97       	mov	r7,r6
800087e0:	04 94       	mov	r4,r2
800087e2:	06 96       	mov	r6,r3
800087e4:	02 92       	mov	r2,r1
800087e6:	40 93       	lddsp	r3,sp[0x24]
800087e8:	10 90       	mov	r0,r8
800087ea:	40 41       	lddsp	r1,sp[0x10]
800087ec:	0e 99       	mov	r9,r7
800087ee:	ed b5 00 03 	bld	r5,0x3
800087f2:	c4 11       	brne	80008874 <_vfprintf_r+0x7e8>
800087f4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800087f8:	40 3a       	lddsp	r10,sp[0xc]
800087fa:	58 0a       	cp.w	r10,0
800087fc:	c1 90       	breq	8000882e <_vfprintf_r+0x7a2>
800087fe:	10 36       	cp.w	r6,r8
80008800:	c6 45       	brlt	800088c8 <_vfprintf_r+0x83c>
80008802:	fa c8 f9 50 	sub	r8,sp,-1712
80008806:	1a d8       	st.w	--sp,r8
80008808:	fa c8 fa b8 	sub	r8,sp,-1352
8000880c:	1a d8       	st.w	--sp,r8
8000880e:	fa c8 fb b4 	sub	r8,sp,-1100
80008812:	0c 9b       	mov	r11,r6
80008814:	1a d8       	st.w	--sp,r8
80008816:	04 9a       	mov	r10,r2
80008818:	fa c8 f9 40 	sub	r8,sp,-1728
8000881c:	fa c9 ff b4 	sub	r9,sp,-76
80008820:	08 9c       	mov	r12,r4
80008822:	fe b0 fa 9d 	rcall	80007d5c <get_arg>
80008826:	2f dd       	sub	sp,-12
80008828:	78 16       	ld.w	r6,r12[0x4]
8000882a:	50 76       	stdsp	sp[0x1c],r6
8000882c:	c4 88       	rjmp	800088bc <_vfprintf_r+0x830>
8000882e:	2f f7       	sub	r7,-1
80008830:	10 39       	cp.w	r9,r8
80008832:	c0 c4       	brge	8000884a <_vfprintf_r+0x7be>
80008834:	fa ce f9 44 	sub	lr,sp,-1724
80008838:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000883c:	ec fc fd 8c 	ld.w	r12,r6[-628]
80008840:	50 7c       	stdsp	sp[0x1c],r12
80008842:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008846:	50 56       	stdsp	sp[0x14],r6
80008848:	c6 68       	rjmp	80008914 <_vfprintf_r+0x888>
8000884a:	41 09       	lddsp	r9,sp[0x40]
8000884c:	59 f8       	cp.w	r8,31
8000884e:	e0 89 00 10 	brgt	8000886e <_vfprintf_r+0x7e2>
80008852:	f2 ca ff f8 	sub	r10,r9,-8
80008856:	72 1b       	ld.w	r11,r9[0x4]
80008858:	51 0a       	stdsp	sp[0x40],r10
8000885a:	72 09       	ld.w	r9,r9[0x0]
8000885c:	fa ca f9 44 	sub	r10,sp,-1724
80008860:	50 7b       	stdsp	sp[0x1c],r11
80008862:	50 59       	stdsp	sp[0x14],r9
80008864:	f4 08 00 39 	add	r9,r10,r8<<0x3
80008868:	40 5b       	lddsp	r11,sp[0x14]
8000886a:	40 7a       	lddsp	r10,sp[0x1c]
8000886c:	c4 78       	rjmp	800088fa <_vfprintf_r+0x86e>
8000886e:	72 18       	ld.w	r8,r9[0x4]
80008870:	50 78       	stdsp	sp[0x1c],r8
80008872:	c4 c8       	rjmp	8000890a <_vfprintf_r+0x87e>
80008874:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008878:	40 3e       	lddsp	lr,sp[0xc]
8000887a:	58 0e       	cp.w	lr,0
8000887c:	c2 30       	breq	800088c2 <_vfprintf_r+0x836>
8000887e:	10 36       	cp.w	r6,r8
80008880:	c0 94       	brge	80008892 <_vfprintf_r+0x806>
80008882:	fa cc f9 44 	sub	r12,sp,-1724
80008886:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000888a:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000888e:	50 7b       	stdsp	sp[0x1c],r11
80008890:	cd 9b       	rjmp	80008842 <_vfprintf_r+0x7b6>
80008892:	fa c8 f9 50 	sub	r8,sp,-1712
80008896:	1a d8       	st.w	--sp,r8
80008898:	fa c8 fa b8 	sub	r8,sp,-1352
8000889c:	04 9a       	mov	r10,r2
8000889e:	1a d8       	st.w	--sp,r8
800088a0:	fa c8 fb b4 	sub	r8,sp,-1100
800088a4:	0c 9b       	mov	r11,r6
800088a6:	1a d8       	st.w	--sp,r8
800088a8:	08 9c       	mov	r12,r4
800088aa:	fa c8 f9 40 	sub	r8,sp,-1728
800088ae:	fa c9 ff b4 	sub	r9,sp,-76
800088b2:	fe b0 fa 55 	rcall	80007d5c <get_arg>
800088b6:	2f dd       	sub	sp,-12
800088b8:	78 1a       	ld.w	r10,r12[0x4]
800088ba:	50 7a       	stdsp	sp[0x1c],r10
800088bc:	78 0c       	ld.w	r12,r12[0x0]
800088be:	50 5c       	stdsp	sp[0x14],r12
800088c0:	c2 a8       	rjmp	80008914 <_vfprintf_r+0x888>
800088c2:	2f f7       	sub	r7,-1
800088c4:	10 39       	cp.w	r9,r8
800088c6:	c0 94       	brge	800088d8 <_vfprintf_r+0x84c>
800088c8:	fa c9 f9 44 	sub	r9,sp,-1724
800088cc:	f2 06 00 36 	add	r6,r9,r6<<0x3
800088d0:	ec f8 fd 8c 	ld.w	r8,r6[-628]
800088d4:	50 78       	stdsp	sp[0x1c],r8
800088d6:	cb 6b       	rjmp	80008842 <_vfprintf_r+0x7b6>
800088d8:	41 09       	lddsp	r9,sp[0x40]
800088da:	59 f8       	cp.w	r8,31
800088dc:	e0 89 00 15 	brgt	80008906 <_vfprintf_r+0x87a>
800088e0:	f2 ca ff f8 	sub	r10,r9,-8
800088e4:	72 16       	ld.w	r6,r9[0x4]
800088e6:	72 09       	ld.w	r9,r9[0x0]
800088e8:	51 0a       	stdsp	sp[0x40],r10
800088ea:	50 59       	stdsp	sp[0x14],r9
800088ec:	fa ce f9 44 	sub	lr,sp,-1724
800088f0:	50 76       	stdsp	sp[0x1c],r6
800088f2:	fc 08 00 39 	add	r9,lr,r8<<0x3
800088f6:	40 5b       	lddsp	r11,sp[0x14]
800088f8:	0c 9a       	mov	r10,r6
800088fa:	f2 eb fd 88 	st.d	r9[-632],r10
800088fe:	2f f8       	sub	r8,-1
80008900:	fb 48 06 b4 	st.w	sp[1716],r8
80008904:	c0 88       	rjmp	80008914 <_vfprintf_r+0x888>
80008906:	72 1c       	ld.w	r12,r9[0x4]
80008908:	50 7c       	stdsp	sp[0x1c],r12
8000890a:	f2 c8 ff f8 	sub	r8,r9,-8
8000890e:	51 08       	stdsp	sp[0x40],r8
80008910:	72 09       	ld.w	r9,r9[0x0]
80008912:	50 59       	stdsp	sp[0x14],r9
80008914:	40 5b       	lddsp	r11,sp[0x14]
80008916:	40 7a       	lddsp	r10,sp[0x1c]
80008918:	e0 a0 19 54 	rcall	8000bbc0 <__isinfd>
8000891c:	18 96       	mov	r6,r12
8000891e:	c1 70       	breq	8000894c <_vfprintf_r+0x8c0>
80008920:	30 08       	mov	r8,0
80008922:	30 09       	mov	r9,0
80008924:	40 5b       	lddsp	r11,sp[0x14]
80008926:	40 7a       	lddsp	r10,sp[0x1c]
80008928:	e0 a0 1d b4 	rcall	8000c490 <__avr32_f64_cmp_lt>
8000892c:	c0 40       	breq	80008934 <_vfprintf_r+0x8a8>
8000892e:	32 d8       	mov	r8,45
80008930:	fb 68 06 bb 	st.b	sp[1723],r8
80008934:	fe c8 a9 74 	sub	r8,pc,-22156
80008938:	fe c6 a9 74 	sub	r6,pc,-22156
8000893c:	a7 d5       	cbr	r5,0x7
8000893e:	e0 40 00 47 	cp.w	r0,71
80008942:	f0 06 17 a0 	movle	r6,r8
80008946:	30 32       	mov	r2,3
80008948:	e0 8f 06 ce 	bral	800096e4 <_vfprintf_r+0x1658>
8000894c:	40 5b       	lddsp	r11,sp[0x14]
8000894e:	40 7a       	lddsp	r10,sp[0x1c]
80008950:	e0 a0 19 4d 	rcall	8000bbea <__isnand>
80008954:	c0 e0       	breq	80008970 <_vfprintf_r+0x8e4>
80008956:	50 26       	stdsp	sp[0x8],r6
80008958:	fe c8 a9 90 	sub	r8,pc,-22128
8000895c:	fe c6 a9 90 	sub	r6,pc,-22128
80008960:	a7 d5       	cbr	r5,0x7
80008962:	e0 40 00 47 	cp.w	r0,71
80008966:	f0 06 17 a0 	movle	r6,r8
8000896a:	30 32       	mov	r2,3
8000896c:	e0 8f 06 c2 	bral	800096f0 <_vfprintf_r+0x1664>
80008970:	40 2a       	lddsp	r10,sp[0x8]
80008972:	5b fa       	cp.w	r10,-1
80008974:	c0 41       	brne	8000897c <_vfprintf_r+0x8f0>
80008976:	30 69       	mov	r9,6
80008978:	50 29       	stdsp	sp[0x8],r9
8000897a:	c1 18       	rjmp	8000899c <_vfprintf_r+0x910>
8000897c:	e0 40 00 47 	cp.w	r0,71
80008980:	5f 09       	sreq	r9
80008982:	e0 40 00 67 	cp.w	r0,103
80008986:	5f 08       	sreq	r8
80008988:	f3 e8 10 08 	or	r8,r9,r8
8000898c:	f8 08 18 00 	cp.b	r8,r12
80008990:	c0 60       	breq	8000899c <_vfprintf_r+0x910>
80008992:	40 28       	lddsp	r8,sp[0x8]
80008994:	58 08       	cp.w	r8,0
80008996:	f9 b8 00 01 	moveq	r8,1
8000899a:	50 28       	stdsp	sp[0x8],r8
8000899c:	40 78       	lddsp	r8,sp[0x1c]
8000899e:	40 59       	lddsp	r9,sp[0x14]
800089a0:	fa e9 06 94 	st.d	sp[1684],r8
800089a4:	a9 a5       	sbr	r5,0x8
800089a6:	fa f8 06 94 	ld.w	r8,sp[1684]
800089aa:	58 08       	cp.w	r8,0
800089ac:	c0 65       	brlt	800089b8 <_vfprintf_r+0x92c>
800089ae:	40 5e       	lddsp	lr,sp[0x14]
800089b0:	30 0c       	mov	r12,0
800089b2:	50 6e       	stdsp	sp[0x18],lr
800089b4:	50 9c       	stdsp	sp[0x24],r12
800089b6:	c0 78       	rjmp	800089c4 <_vfprintf_r+0x938>
800089b8:	40 5b       	lddsp	r11,sp[0x14]
800089ba:	32 da       	mov	r10,45
800089bc:	ee 1b 80 00 	eorh	r11,0x8000
800089c0:	50 9a       	stdsp	sp[0x24],r10
800089c2:	50 6b       	stdsp	sp[0x18],r11
800089c4:	e0 40 00 46 	cp.w	r0,70
800089c8:	5f 09       	sreq	r9
800089ca:	e0 40 00 66 	cp.w	r0,102
800089ce:	5f 08       	sreq	r8
800089d0:	f3 e8 10 08 	or	r8,r9,r8
800089d4:	50 48       	stdsp	sp[0x10],r8
800089d6:	c0 40       	breq	800089de <_vfprintf_r+0x952>
800089d8:	40 22       	lddsp	r2,sp[0x8]
800089da:	30 39       	mov	r9,3
800089dc:	c1 08       	rjmp	800089fc <_vfprintf_r+0x970>
800089de:	e0 40 00 45 	cp.w	r0,69
800089e2:	5f 09       	sreq	r9
800089e4:	e0 40 00 65 	cp.w	r0,101
800089e8:	5f 08       	sreq	r8
800089ea:	40 22       	lddsp	r2,sp[0x8]
800089ec:	10 49       	or	r9,r8
800089ee:	2f f2       	sub	r2,-1
800089f0:	40 46       	lddsp	r6,sp[0x10]
800089f2:	ec 09 18 00 	cp.b	r9,r6
800089f6:	fb f2 00 02 	ld.weq	r2,sp[0x8]
800089fa:	30 29       	mov	r9,2
800089fc:	fa c8 f9 5c 	sub	r8,sp,-1700
80008a00:	1a d8       	st.w	--sp,r8
80008a02:	fa c8 f9 54 	sub	r8,sp,-1708
80008a06:	1a d8       	st.w	--sp,r8
80008a08:	fa c8 f9 4c 	sub	r8,sp,-1716
80008a0c:	08 9c       	mov	r12,r4
80008a0e:	1a d8       	st.w	--sp,r8
80008a10:	04 98       	mov	r8,r2
80008a12:	40 9b       	lddsp	r11,sp[0x24]
80008a14:	40 aa       	lddsp	r10,sp[0x28]
80008a16:	e0 a0 0b c3 	rcall	8000a19c <_dtoa_r>
80008a1a:	e0 40 00 47 	cp.w	r0,71
80008a1e:	5f 19       	srne	r9
80008a20:	e0 40 00 67 	cp.w	r0,103
80008a24:	5f 18       	srne	r8
80008a26:	18 96       	mov	r6,r12
80008a28:	2f dd       	sub	sp,-12
80008a2a:	f3 e8 00 08 	and	r8,r9,r8
80008a2e:	c0 41       	brne	80008a36 <_vfprintf_r+0x9aa>
80008a30:	ed b5 00 00 	bld	r5,0x0
80008a34:	c3 01       	brne	80008a94 <_vfprintf_r+0xa08>
80008a36:	ec 02 00 0e 	add	lr,r6,r2
80008a3a:	50 3e       	stdsp	sp[0xc],lr
80008a3c:	40 4c       	lddsp	r12,sp[0x10]
80008a3e:	58 0c       	cp.w	r12,0
80008a40:	c1 50       	breq	80008a6a <_vfprintf_r+0x9de>
80008a42:	0d 89       	ld.ub	r9,r6[0x0]
80008a44:	33 08       	mov	r8,48
80008a46:	f0 09 18 00 	cp.b	r9,r8
80008a4a:	c0 b1       	brne	80008a60 <_vfprintf_r+0x9d4>
80008a4c:	30 08       	mov	r8,0
80008a4e:	30 09       	mov	r9,0
80008a50:	40 6b       	lddsp	r11,sp[0x18]
80008a52:	40 7a       	lddsp	r10,sp[0x1c]
80008a54:	e0 a0 1c d7 	rcall	8000c402 <__avr32_f64_cmp_eq>
80008a58:	fb b2 00 01 	rsubeq	r2,1
80008a5c:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008a60:	40 3b       	lddsp	r11,sp[0xc]
80008a62:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008a66:	10 0b       	add	r11,r8
80008a68:	50 3b       	stdsp	sp[0xc],r11
80008a6a:	40 6b       	lddsp	r11,sp[0x18]
80008a6c:	30 08       	mov	r8,0
80008a6e:	30 09       	mov	r9,0
80008a70:	40 7a       	lddsp	r10,sp[0x1c]
80008a72:	e0 a0 1c c8 	rcall	8000c402 <__avr32_f64_cmp_eq>
80008a76:	c0 90       	breq	80008a88 <_vfprintf_r+0x9fc>
80008a78:	40 3a       	lddsp	r10,sp[0xc]
80008a7a:	fb 4a 06 a4 	st.w	sp[1700],r10
80008a7e:	c0 58       	rjmp	80008a88 <_vfprintf_r+0x9fc>
80008a80:	10 c9       	st.b	r8++,r9
80008a82:	fb 48 06 a4 	st.w	sp[1700],r8
80008a86:	c0 28       	rjmp	80008a8a <_vfprintf_r+0x9fe>
80008a88:	33 09       	mov	r9,48
80008a8a:	fa f8 06 a4 	ld.w	r8,sp[1700]
80008a8e:	40 3e       	lddsp	lr,sp[0xc]
80008a90:	1c 38       	cp.w	r8,lr
80008a92:	cf 73       	brcs	80008a80 <_vfprintf_r+0x9f4>
80008a94:	e0 40 00 47 	cp.w	r0,71
80008a98:	5f 09       	sreq	r9
80008a9a:	e0 40 00 67 	cp.w	r0,103
80008a9e:	5f 08       	sreq	r8
80008aa0:	f3 e8 10 08 	or	r8,r9,r8
80008aa4:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008aa8:	0c 19       	sub	r9,r6
80008aaa:	50 69       	stdsp	sp[0x18],r9
80008aac:	58 08       	cp.w	r8,0
80008aae:	c0 b0       	breq	80008ac4 <_vfprintf_r+0xa38>
80008ab0:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008ab4:	5b d8       	cp.w	r8,-3
80008ab6:	c0 55       	brlt	80008ac0 <_vfprintf_r+0xa34>
80008ab8:	40 2c       	lddsp	r12,sp[0x8]
80008aba:	18 38       	cp.w	r8,r12
80008abc:	e0 8a 00 6a 	brle	80008b90 <_vfprintf_r+0xb04>
80008ac0:	20 20       	sub	r0,2
80008ac2:	c0 58       	rjmp	80008acc <_vfprintf_r+0xa40>
80008ac4:	e0 40 00 65 	cp.w	r0,101
80008ac8:	e0 89 00 46 	brgt	80008b54 <_vfprintf_r+0xac8>
80008acc:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008ad0:	fb 60 06 9c 	st.b	sp[1692],r0
80008ad4:	20 1b       	sub	r11,1
80008ad6:	fb 4b 06 ac 	st.w	sp[1708],r11
80008ada:	c0 47       	brpl	80008ae2 <_vfprintf_r+0xa56>
80008adc:	5c 3b       	neg	r11
80008ade:	32 d8       	mov	r8,45
80008ae0:	c0 28       	rjmp	80008ae4 <_vfprintf_r+0xa58>
80008ae2:	32 b8       	mov	r8,43
80008ae4:	fb 68 06 9d 	st.b	sp[1693],r8
80008ae8:	58 9b       	cp.w	r11,9
80008aea:	e0 8a 00 1d 	brle	80008b24 <_vfprintf_r+0xa98>
80008aee:	fa c9 fa 35 	sub	r9,sp,-1483
80008af2:	30 aa       	mov	r10,10
80008af4:	12 98       	mov	r8,r9
80008af6:	0e 9c       	mov	r12,r7
80008af8:	0c 92       	mov	r2,r6
80008afa:	f6 0a 0c 06 	divs	r6,r11,r10
80008afe:	0e 9b       	mov	r11,r7
80008b00:	2d 0b       	sub	r11,-48
80008b02:	10 fb       	st.b	--r8,r11
80008b04:	0c 9b       	mov	r11,r6
80008b06:	58 96       	cp.w	r6,9
80008b08:	fe 99 ff f9 	brgt	80008afa <_vfprintf_r+0xa6e>
80008b0c:	2d 0b       	sub	r11,-48
80008b0e:	18 97       	mov	r7,r12
80008b10:	04 96       	mov	r6,r2
80008b12:	10 fb       	st.b	--r8,r11
80008b14:	fa ca f9 62 	sub	r10,sp,-1694
80008b18:	c0 38       	rjmp	80008b1e <_vfprintf_r+0xa92>
80008b1a:	11 3b       	ld.ub	r11,r8++
80008b1c:	14 cb       	st.b	r10++,r11
80008b1e:	12 38       	cp.w	r8,r9
80008b20:	cf d3       	brcs	80008b1a <_vfprintf_r+0xa8e>
80008b22:	c0 98       	rjmp	80008b34 <_vfprintf_r+0xaa8>
80008b24:	2d 0b       	sub	r11,-48
80008b26:	33 08       	mov	r8,48
80008b28:	fb 6b 06 9f 	st.b	sp[1695],r11
80008b2c:	fb 68 06 9e 	st.b	sp[1694],r8
80008b30:	fa ca f9 60 	sub	r10,sp,-1696
80008b34:	fa c8 f9 64 	sub	r8,sp,-1692
80008b38:	f4 08 01 08 	sub	r8,r10,r8
80008b3c:	50 e8       	stdsp	sp[0x38],r8
80008b3e:	10 92       	mov	r2,r8
80008b40:	40 6b       	lddsp	r11,sp[0x18]
80008b42:	16 02       	add	r2,r11
80008b44:	58 1b       	cp.w	r11,1
80008b46:	e0 89 00 05 	brgt	80008b50 <_vfprintf_r+0xac4>
80008b4a:	ed b5 00 00 	bld	r5,0x0
80008b4e:	c3 51       	brne	80008bb8 <_vfprintf_r+0xb2c>
80008b50:	2f f2       	sub	r2,-1
80008b52:	c3 38       	rjmp	80008bb8 <_vfprintf_r+0xb2c>
80008b54:	e0 40 00 66 	cp.w	r0,102
80008b58:	c1 c1       	brne	80008b90 <_vfprintf_r+0xb04>
80008b5a:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008b5e:	58 02       	cp.w	r2,0
80008b60:	e0 8a 00 0c 	brle	80008b78 <_vfprintf_r+0xaec>
80008b64:	40 2a       	lddsp	r10,sp[0x8]
80008b66:	58 0a       	cp.w	r10,0
80008b68:	c0 41       	brne	80008b70 <_vfprintf_r+0xae4>
80008b6a:	ed b5 00 00 	bld	r5,0x0
80008b6e:	c2 51       	brne	80008bb8 <_vfprintf_r+0xb2c>
80008b70:	2f f2       	sub	r2,-1
80008b72:	40 29       	lddsp	r9,sp[0x8]
80008b74:	12 02       	add	r2,r9
80008b76:	c0 b8       	rjmp	80008b8c <_vfprintf_r+0xb00>
80008b78:	40 28       	lddsp	r8,sp[0x8]
80008b7a:	58 08       	cp.w	r8,0
80008b7c:	c0 61       	brne	80008b88 <_vfprintf_r+0xafc>
80008b7e:	ed b5 00 00 	bld	r5,0x0
80008b82:	c0 30       	breq	80008b88 <_vfprintf_r+0xafc>
80008b84:	30 12       	mov	r2,1
80008b86:	c1 98       	rjmp	80008bb8 <_vfprintf_r+0xb2c>
80008b88:	40 22       	lddsp	r2,sp[0x8]
80008b8a:	2f e2       	sub	r2,-2
80008b8c:	36 60       	mov	r0,102
80008b8e:	c1 58       	rjmp	80008bb8 <_vfprintf_r+0xb2c>
80008b90:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008b94:	40 6e       	lddsp	lr,sp[0x18]
80008b96:	1c 32       	cp.w	r2,lr
80008b98:	c0 65       	brlt	80008ba4 <_vfprintf_r+0xb18>
80008b9a:	ed b5 00 00 	bld	r5,0x0
80008b9e:	f7 b2 00 ff 	subeq	r2,-1
80008ba2:	c0 a8       	rjmp	80008bb6 <_vfprintf_r+0xb2a>
80008ba4:	e4 08 11 02 	rsub	r8,r2,2
80008ba8:	40 6c       	lddsp	r12,sp[0x18]
80008baa:	58 02       	cp.w	r2,0
80008bac:	f0 02 17 a0 	movle	r2,r8
80008bb0:	f9 b2 09 01 	movgt	r2,1
80008bb4:	18 02       	add	r2,r12
80008bb6:	36 70       	mov	r0,103
80008bb8:	40 9b       	lddsp	r11,sp[0x24]
80008bba:	58 0b       	cp.w	r11,0
80008bbc:	e0 80 05 94 	breq	800096e4 <_vfprintf_r+0x1658>
80008bc0:	32 d8       	mov	r8,45
80008bc2:	fb 68 06 bb 	st.b	sp[1723],r8
80008bc6:	e0 8f 05 93 	bral	800096ec <_vfprintf_r+0x1660>
80008bca:	50 a7       	stdsp	sp[0x28],r7
80008bcc:	04 94       	mov	r4,r2
80008bce:	0c 97       	mov	r7,r6
80008bd0:	02 92       	mov	r2,r1
80008bd2:	06 96       	mov	r6,r3
80008bd4:	40 41       	lddsp	r1,sp[0x10]
80008bd6:	40 93       	lddsp	r3,sp[0x24]
80008bd8:	0e 99       	mov	r9,r7
80008bda:	ed b5 00 05 	bld	r5,0x5
80008bde:	c4 81       	brne	80008c6e <_vfprintf_r+0xbe2>
80008be0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008be4:	40 3e       	lddsp	lr,sp[0xc]
80008be6:	58 0e       	cp.w	lr,0
80008be8:	c1 d0       	breq	80008c22 <_vfprintf_r+0xb96>
80008bea:	10 36       	cp.w	r6,r8
80008bec:	c0 64       	brge	80008bf8 <_vfprintf_r+0xb6c>
80008bee:	fa cc f9 44 	sub	r12,sp,-1724
80008bf2:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008bf6:	c1 d8       	rjmp	80008c30 <_vfprintf_r+0xba4>
80008bf8:	fa c8 f9 50 	sub	r8,sp,-1712
80008bfc:	1a d8       	st.w	--sp,r8
80008bfe:	fa c8 fa b8 	sub	r8,sp,-1352
80008c02:	04 9a       	mov	r10,r2
80008c04:	1a d8       	st.w	--sp,r8
80008c06:	fa c8 fb b4 	sub	r8,sp,-1100
80008c0a:	0c 9b       	mov	r11,r6
80008c0c:	1a d8       	st.w	--sp,r8
80008c0e:	08 9c       	mov	r12,r4
80008c10:	fa c8 f9 40 	sub	r8,sp,-1728
80008c14:	fa c9 ff b4 	sub	r9,sp,-76
80008c18:	fe b0 f8 a2 	rcall	80007d5c <get_arg>
80008c1c:	2f dd       	sub	sp,-12
80008c1e:	78 0a       	ld.w	r10,r12[0x0]
80008c20:	c2 08       	rjmp	80008c60 <_vfprintf_r+0xbd4>
80008c22:	2f f7       	sub	r7,-1
80008c24:	10 39       	cp.w	r9,r8
80008c26:	c0 84       	brge	80008c36 <_vfprintf_r+0xbaa>
80008c28:	fa cb f9 44 	sub	r11,sp,-1724
80008c2c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c30:	ec fa fd 88 	ld.w	r10,r6[-632]
80008c34:	c1 68       	rjmp	80008c60 <_vfprintf_r+0xbd4>
80008c36:	41 09       	lddsp	r9,sp[0x40]
80008c38:	59 f8       	cp.w	r8,31
80008c3a:	e0 89 00 10 	brgt	80008c5a <_vfprintf_r+0xbce>
80008c3e:	f2 ca ff fc 	sub	r10,r9,-4
80008c42:	51 0a       	stdsp	sp[0x40],r10
80008c44:	fa c6 f9 44 	sub	r6,sp,-1724
80008c48:	72 0a       	ld.w	r10,r9[0x0]
80008c4a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008c4e:	f3 4a fd 88 	st.w	r9[-632],r10
80008c52:	2f f8       	sub	r8,-1
80008c54:	fb 48 06 b4 	st.w	sp[1716],r8
80008c58:	c0 48       	rjmp	80008c60 <_vfprintf_r+0xbd4>
80008c5a:	72 0a       	ld.w	r10,r9[0x0]
80008c5c:	2f c9       	sub	r9,-4
80008c5e:	51 09       	stdsp	sp[0x40],r9
80008c60:	40 be       	lddsp	lr,sp[0x2c]
80008c62:	1c 98       	mov	r8,lr
80008c64:	95 1e       	st.w	r10[0x4],lr
80008c66:	bf 58       	asr	r8,0x1f
80008c68:	95 08       	st.w	r10[0x0],r8
80008c6a:	fe 9f fa 9f 	bral	800081a8 <_vfprintf_r+0x11c>
80008c6e:	ed b5 00 04 	bld	r5,0x4
80008c72:	c4 80       	breq	80008d02 <_vfprintf_r+0xc76>
80008c74:	e2 15 00 40 	andl	r5,0x40,COH
80008c78:	c4 50       	breq	80008d02 <_vfprintf_r+0xc76>
80008c7a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c7e:	40 3c       	lddsp	r12,sp[0xc]
80008c80:	58 0c       	cp.w	r12,0
80008c82:	c1 d0       	breq	80008cbc <_vfprintf_r+0xc30>
80008c84:	10 36       	cp.w	r6,r8
80008c86:	c0 64       	brge	80008c92 <_vfprintf_r+0xc06>
80008c88:	fa cb f9 44 	sub	r11,sp,-1724
80008c8c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c90:	c1 d8       	rjmp	80008cca <_vfprintf_r+0xc3e>
80008c92:	fa c8 f9 50 	sub	r8,sp,-1712
80008c96:	1a d8       	st.w	--sp,r8
80008c98:	fa c8 fa b8 	sub	r8,sp,-1352
80008c9c:	04 9a       	mov	r10,r2
80008c9e:	1a d8       	st.w	--sp,r8
80008ca0:	fa c8 fb b4 	sub	r8,sp,-1100
80008ca4:	0c 9b       	mov	r11,r6
80008ca6:	1a d8       	st.w	--sp,r8
80008ca8:	08 9c       	mov	r12,r4
80008caa:	fa c8 f9 40 	sub	r8,sp,-1728
80008cae:	fa c9 ff b4 	sub	r9,sp,-76
80008cb2:	fe b0 f8 55 	rcall	80007d5c <get_arg>
80008cb6:	2f dd       	sub	sp,-12
80008cb8:	78 0a       	ld.w	r10,r12[0x0]
80008cba:	c2 08       	rjmp	80008cfa <_vfprintf_r+0xc6e>
80008cbc:	2f f7       	sub	r7,-1
80008cbe:	10 39       	cp.w	r9,r8
80008cc0:	c0 84       	brge	80008cd0 <_vfprintf_r+0xc44>
80008cc2:	fa ca f9 44 	sub	r10,sp,-1724
80008cc6:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008cca:	ec fa fd 88 	ld.w	r10,r6[-632]
80008cce:	c1 68       	rjmp	80008cfa <_vfprintf_r+0xc6e>
80008cd0:	41 09       	lddsp	r9,sp[0x40]
80008cd2:	59 f8       	cp.w	r8,31
80008cd4:	e0 89 00 10 	brgt	80008cf4 <_vfprintf_r+0xc68>
80008cd8:	f2 ca ff fc 	sub	r10,r9,-4
80008cdc:	51 0a       	stdsp	sp[0x40],r10
80008cde:	fa c6 f9 44 	sub	r6,sp,-1724
80008ce2:	72 0a       	ld.w	r10,r9[0x0]
80008ce4:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008ce8:	f3 4a fd 88 	st.w	r9[-632],r10
80008cec:	2f f8       	sub	r8,-1
80008cee:	fb 48 06 b4 	st.w	sp[1716],r8
80008cf2:	c0 48       	rjmp	80008cfa <_vfprintf_r+0xc6e>
80008cf4:	72 0a       	ld.w	r10,r9[0x0]
80008cf6:	2f c9       	sub	r9,-4
80008cf8:	51 09       	stdsp	sp[0x40],r9
80008cfa:	40 be       	lddsp	lr,sp[0x2c]
80008cfc:	b4 0e       	st.h	r10[0x0],lr
80008cfe:	fe 9f fa 55 	bral	800081a8 <_vfprintf_r+0x11c>
80008d02:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d06:	40 3c       	lddsp	r12,sp[0xc]
80008d08:	58 0c       	cp.w	r12,0
80008d0a:	c1 d0       	breq	80008d44 <_vfprintf_r+0xcb8>
80008d0c:	10 36       	cp.w	r6,r8
80008d0e:	c0 64       	brge	80008d1a <_vfprintf_r+0xc8e>
80008d10:	fa cb f9 44 	sub	r11,sp,-1724
80008d14:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d18:	c1 d8       	rjmp	80008d52 <_vfprintf_r+0xcc6>
80008d1a:	fa c8 f9 50 	sub	r8,sp,-1712
80008d1e:	1a d8       	st.w	--sp,r8
80008d20:	fa c8 fa b8 	sub	r8,sp,-1352
80008d24:	04 9a       	mov	r10,r2
80008d26:	1a d8       	st.w	--sp,r8
80008d28:	fa c8 fb b4 	sub	r8,sp,-1100
80008d2c:	0c 9b       	mov	r11,r6
80008d2e:	1a d8       	st.w	--sp,r8
80008d30:	08 9c       	mov	r12,r4
80008d32:	fa c8 f9 40 	sub	r8,sp,-1728
80008d36:	fa c9 ff b4 	sub	r9,sp,-76
80008d3a:	fe b0 f8 11 	rcall	80007d5c <get_arg>
80008d3e:	2f dd       	sub	sp,-12
80008d40:	78 0a       	ld.w	r10,r12[0x0]
80008d42:	c2 08       	rjmp	80008d82 <_vfprintf_r+0xcf6>
80008d44:	2f f7       	sub	r7,-1
80008d46:	10 39       	cp.w	r9,r8
80008d48:	c0 84       	brge	80008d58 <_vfprintf_r+0xccc>
80008d4a:	fa ca f9 44 	sub	r10,sp,-1724
80008d4e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008d52:	ec fa fd 88 	ld.w	r10,r6[-632]
80008d56:	c1 68       	rjmp	80008d82 <_vfprintf_r+0xcf6>
80008d58:	41 09       	lddsp	r9,sp[0x40]
80008d5a:	59 f8       	cp.w	r8,31
80008d5c:	e0 89 00 10 	brgt	80008d7c <_vfprintf_r+0xcf0>
80008d60:	f2 ca ff fc 	sub	r10,r9,-4
80008d64:	51 0a       	stdsp	sp[0x40],r10
80008d66:	fa c6 f9 44 	sub	r6,sp,-1724
80008d6a:	72 0a       	ld.w	r10,r9[0x0]
80008d6c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008d70:	f3 4a fd 88 	st.w	r9[-632],r10
80008d74:	2f f8       	sub	r8,-1
80008d76:	fb 48 06 b4 	st.w	sp[1716],r8
80008d7a:	c0 48       	rjmp	80008d82 <_vfprintf_r+0xcf6>
80008d7c:	72 0a       	ld.w	r10,r9[0x0]
80008d7e:	2f c9       	sub	r9,-4
80008d80:	51 09       	stdsp	sp[0x40],r9
80008d82:	40 be       	lddsp	lr,sp[0x2c]
80008d84:	95 0e       	st.w	r10[0x0],lr
80008d86:	fe 9f fa 11 	bral	800081a8 <_vfprintf_r+0x11c>
80008d8a:	50 a7       	stdsp	sp[0x28],r7
80008d8c:	50 80       	stdsp	sp[0x20],r0
80008d8e:	0c 97       	mov	r7,r6
80008d90:	04 94       	mov	r4,r2
80008d92:	06 96       	mov	r6,r3
80008d94:	02 92       	mov	r2,r1
80008d96:	40 93       	lddsp	r3,sp[0x24]
80008d98:	10 90       	mov	r0,r8
80008d9a:	40 41       	lddsp	r1,sp[0x10]
80008d9c:	a5 a5       	sbr	r5,0x4
80008d9e:	c0 a8       	rjmp	80008db2 <_vfprintf_r+0xd26>
80008da0:	50 a7       	stdsp	sp[0x28],r7
80008da2:	50 80       	stdsp	sp[0x20],r0
80008da4:	0c 97       	mov	r7,r6
80008da6:	04 94       	mov	r4,r2
80008da8:	06 96       	mov	r6,r3
80008daa:	02 92       	mov	r2,r1
80008dac:	40 93       	lddsp	r3,sp[0x24]
80008dae:	10 90       	mov	r0,r8
80008db0:	40 41       	lddsp	r1,sp[0x10]
80008db2:	ed b5 00 05 	bld	r5,0x5
80008db6:	c5 d1       	brne	80008e70 <_vfprintf_r+0xde4>
80008db8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008dbc:	40 3c       	lddsp	r12,sp[0xc]
80008dbe:	58 0c       	cp.w	r12,0
80008dc0:	c2 60       	breq	80008e0c <_vfprintf_r+0xd80>
80008dc2:	10 36       	cp.w	r6,r8
80008dc4:	c0 a4       	brge	80008dd8 <_vfprintf_r+0xd4c>
80008dc6:	fa cb f9 44 	sub	r11,sp,-1724
80008dca:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008dce:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008dd2:	fa e9 00 00 	st.d	sp[0],r8
80008dd6:	c1 88       	rjmp	80008e06 <_vfprintf_r+0xd7a>
80008dd8:	fa c8 f9 50 	sub	r8,sp,-1712
80008ddc:	1a d8       	st.w	--sp,r8
80008dde:	fa c8 fa b8 	sub	r8,sp,-1352
80008de2:	04 9a       	mov	r10,r2
80008de4:	1a d8       	st.w	--sp,r8
80008de6:	0c 9b       	mov	r11,r6
80008de8:	fa c8 fb b4 	sub	r8,sp,-1100
80008dec:	08 9c       	mov	r12,r4
80008dee:	1a d8       	st.w	--sp,r8
80008df0:	fa c8 f9 40 	sub	r8,sp,-1728
80008df4:	fa c9 ff b4 	sub	r9,sp,-76
80008df8:	fe b0 f7 b2 	rcall	80007d5c <get_arg>
80008dfc:	2f dd       	sub	sp,-12
80008dfe:	f8 ea 00 00 	ld.d	r10,r12[0]
80008e02:	fa eb 00 00 	st.d	sp[0],r10
80008e06:	30 08       	mov	r8,0
80008e08:	e0 8f 03 de 	bral	800095c4 <_vfprintf_r+0x1538>
80008e0c:	ee ca ff ff 	sub	r10,r7,-1
80008e10:	10 37       	cp.w	r7,r8
80008e12:	c0 b4       	brge	80008e28 <_vfprintf_r+0xd9c>
80008e14:	fa c9 f9 44 	sub	r9,sp,-1724
80008e18:	14 97       	mov	r7,r10
80008e1a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008e1e:	ec ea fd 88 	ld.d	r10,r6[-632]
80008e22:	fa eb 00 00 	st.d	sp[0],r10
80008e26:	c1 88       	rjmp	80008e56 <_vfprintf_r+0xdca>
80008e28:	41 09       	lddsp	r9,sp[0x40]
80008e2a:	59 f8       	cp.w	r8,31
80008e2c:	e0 89 00 18 	brgt	80008e5c <_vfprintf_r+0xdd0>
80008e30:	f2 e6 00 00 	ld.d	r6,r9[0]
80008e34:	f2 cb ff f8 	sub	r11,r9,-8
80008e38:	fa e7 00 00 	st.d	sp[0],r6
80008e3c:	51 0b       	stdsp	sp[0x40],r11
80008e3e:	fa c6 f9 44 	sub	r6,sp,-1724
80008e42:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008e46:	fa e6 00 00 	ld.d	r6,sp[0]
80008e4a:	f2 e7 fd 88 	st.d	r9[-632],r6
80008e4e:	2f f8       	sub	r8,-1
80008e50:	14 97       	mov	r7,r10
80008e52:	fb 48 06 b4 	st.w	sp[1716],r8
80008e56:	40 38       	lddsp	r8,sp[0xc]
80008e58:	e0 8f 03 b6 	bral	800095c4 <_vfprintf_r+0x1538>
80008e5c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008e60:	40 38       	lddsp	r8,sp[0xc]
80008e62:	fa e7 00 00 	st.d	sp[0],r6
80008e66:	2f 89       	sub	r9,-8
80008e68:	14 97       	mov	r7,r10
80008e6a:	51 09       	stdsp	sp[0x40],r9
80008e6c:	e0 8f 03 ac 	bral	800095c4 <_vfprintf_r+0x1538>
80008e70:	ed b5 00 04 	bld	r5,0x4
80008e74:	c1 61       	brne	80008ea0 <_vfprintf_r+0xe14>
80008e76:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e7a:	40 3e       	lddsp	lr,sp[0xc]
80008e7c:	58 0e       	cp.w	lr,0
80008e7e:	c0 80       	breq	80008e8e <_vfprintf_r+0xe02>
80008e80:	10 36       	cp.w	r6,r8
80008e82:	c6 74       	brge	80008f50 <_vfprintf_r+0xec4>
80008e84:	fa cc f9 44 	sub	r12,sp,-1724
80008e88:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008e8c:	c8 08       	rjmp	80008f8c <_vfprintf_r+0xf00>
80008e8e:	ee ca ff ff 	sub	r10,r7,-1
80008e92:	10 37       	cp.w	r7,r8
80008e94:	c7 f4       	brge	80008f92 <_vfprintf_r+0xf06>
80008e96:	fa cb f9 44 	sub	r11,sp,-1724
80008e9a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e9e:	c7 68       	rjmp	80008f8a <_vfprintf_r+0xefe>
80008ea0:	ed b5 00 06 	bld	r5,0x6
80008ea4:	c4 a1       	brne	80008f38 <_vfprintf_r+0xeac>
80008ea6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008eaa:	40 3c       	lddsp	r12,sp[0xc]
80008eac:	58 0c       	cp.w	r12,0
80008eae:	c1 d0       	breq	80008ee8 <_vfprintf_r+0xe5c>
80008eb0:	10 36       	cp.w	r6,r8
80008eb2:	c0 64       	brge	80008ebe <_vfprintf_r+0xe32>
80008eb4:	fa cb f9 44 	sub	r11,sp,-1724
80008eb8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008ebc:	c1 f8       	rjmp	80008efa <_vfprintf_r+0xe6e>
80008ebe:	fa c8 f9 50 	sub	r8,sp,-1712
80008ec2:	1a d8       	st.w	--sp,r8
80008ec4:	fa c8 fa b8 	sub	r8,sp,-1352
80008ec8:	1a d8       	st.w	--sp,r8
80008eca:	fa c8 fb b4 	sub	r8,sp,-1100
80008ece:	1a d8       	st.w	--sp,r8
80008ed0:	fa c8 f9 40 	sub	r8,sp,-1728
80008ed4:	fa c9 ff b4 	sub	r9,sp,-76
80008ed8:	04 9a       	mov	r10,r2
80008eda:	0c 9b       	mov	r11,r6
80008edc:	08 9c       	mov	r12,r4
80008ede:	fe b0 f7 3f 	rcall	80007d5c <get_arg>
80008ee2:	2f dd       	sub	sp,-12
80008ee4:	98 18       	ld.sh	r8,r12[0x2]
80008ee6:	c2 68       	rjmp	80008f32 <_vfprintf_r+0xea6>
80008ee8:	ee ca ff ff 	sub	r10,r7,-1
80008eec:	10 37       	cp.w	r7,r8
80008eee:	c0 94       	brge	80008f00 <_vfprintf_r+0xe74>
80008ef0:	fa c9 f9 44 	sub	r9,sp,-1724
80008ef4:	14 97       	mov	r7,r10
80008ef6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008efa:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008efe:	c1 a8       	rjmp	80008f32 <_vfprintf_r+0xea6>
80008f00:	41 09       	lddsp	r9,sp[0x40]
80008f02:	59 f8       	cp.w	r8,31
80008f04:	e0 89 00 13 	brgt	80008f2a <_vfprintf_r+0xe9e>
80008f08:	f2 cb ff fc 	sub	r11,r9,-4
80008f0c:	51 0b       	stdsp	sp[0x40],r11
80008f0e:	72 09       	ld.w	r9,r9[0x0]
80008f10:	fa c6 f9 44 	sub	r6,sp,-1724
80008f14:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008f18:	2f f8       	sub	r8,-1
80008f1a:	f7 49 fd 88 	st.w	r11[-632],r9
80008f1e:	fb 48 06 b4 	st.w	sp[1716],r8
80008f22:	14 97       	mov	r7,r10
80008f24:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008f28:	c0 58       	rjmp	80008f32 <_vfprintf_r+0xea6>
80008f2a:	92 18       	ld.sh	r8,r9[0x2]
80008f2c:	14 97       	mov	r7,r10
80008f2e:	2f c9       	sub	r9,-4
80008f30:	51 09       	stdsp	sp[0x40],r9
80008f32:	5c 78       	castu.h	r8
80008f34:	50 18       	stdsp	sp[0x4],r8
80008f36:	c4 68       	rjmp	80008fc2 <_vfprintf_r+0xf36>
80008f38:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f3c:	40 3c       	lddsp	r12,sp[0xc]
80008f3e:	58 0c       	cp.w	r12,0
80008f40:	c1 d0       	breq	80008f7a <_vfprintf_r+0xeee>
80008f42:	10 36       	cp.w	r6,r8
80008f44:	c0 64       	brge	80008f50 <_vfprintf_r+0xec4>
80008f46:	fa cb f9 44 	sub	r11,sp,-1724
80008f4a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f4e:	c1 f8       	rjmp	80008f8c <_vfprintf_r+0xf00>
80008f50:	fa c8 f9 50 	sub	r8,sp,-1712
80008f54:	1a d8       	st.w	--sp,r8
80008f56:	fa c8 fa b8 	sub	r8,sp,-1352
80008f5a:	0c 9b       	mov	r11,r6
80008f5c:	1a d8       	st.w	--sp,r8
80008f5e:	fa c8 fb b4 	sub	r8,sp,-1100
80008f62:	04 9a       	mov	r10,r2
80008f64:	1a d8       	st.w	--sp,r8
80008f66:	08 9c       	mov	r12,r4
80008f68:	fa c8 f9 40 	sub	r8,sp,-1728
80008f6c:	fa c9 ff b4 	sub	r9,sp,-76
80008f70:	fe b0 f6 f6 	rcall	80007d5c <get_arg>
80008f74:	2f dd       	sub	sp,-12
80008f76:	78 0b       	ld.w	r11,r12[0x0]
80008f78:	c2 48       	rjmp	80008fc0 <_vfprintf_r+0xf34>
80008f7a:	ee ca ff ff 	sub	r10,r7,-1
80008f7e:	10 37       	cp.w	r7,r8
80008f80:	c0 94       	brge	80008f92 <_vfprintf_r+0xf06>
80008f82:	fa c9 f9 44 	sub	r9,sp,-1724
80008f86:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f8a:	14 97       	mov	r7,r10
80008f8c:	ec fb fd 88 	ld.w	r11,r6[-632]
80008f90:	c1 88       	rjmp	80008fc0 <_vfprintf_r+0xf34>
80008f92:	41 09       	lddsp	r9,sp[0x40]
80008f94:	59 f8       	cp.w	r8,31
80008f96:	e0 89 00 11 	brgt	80008fb8 <_vfprintf_r+0xf2c>
80008f9a:	f2 cb ff fc 	sub	r11,r9,-4
80008f9e:	51 0b       	stdsp	sp[0x40],r11
80008fa0:	fa c6 f9 44 	sub	r6,sp,-1724
80008fa4:	72 0b       	ld.w	r11,r9[0x0]
80008fa6:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008faa:	f3 4b fd 88 	st.w	r9[-632],r11
80008fae:	2f f8       	sub	r8,-1
80008fb0:	14 97       	mov	r7,r10
80008fb2:	fb 48 06 b4 	st.w	sp[1716],r8
80008fb6:	c0 58       	rjmp	80008fc0 <_vfprintf_r+0xf34>
80008fb8:	72 0b       	ld.w	r11,r9[0x0]
80008fba:	14 97       	mov	r7,r10
80008fbc:	2f c9       	sub	r9,-4
80008fbe:	51 09       	stdsp	sp[0x40],r9
80008fc0:	50 1b       	stdsp	sp[0x4],r11
80008fc2:	30 0e       	mov	lr,0
80008fc4:	50 0e       	stdsp	sp[0x0],lr
80008fc6:	1c 98       	mov	r8,lr
80008fc8:	e0 8f 02 fe 	bral	800095c4 <_vfprintf_r+0x1538>
80008fcc:	50 a7       	stdsp	sp[0x28],r7
80008fce:	50 80       	stdsp	sp[0x20],r0
80008fd0:	0c 97       	mov	r7,r6
80008fd2:	04 94       	mov	r4,r2
80008fd4:	06 96       	mov	r6,r3
80008fd6:	02 92       	mov	r2,r1
80008fd8:	40 93       	lddsp	r3,sp[0x24]
80008fda:	40 41       	lddsp	r1,sp[0x10]
80008fdc:	0e 99       	mov	r9,r7
80008fde:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008fe2:	40 3c       	lddsp	r12,sp[0xc]
80008fe4:	58 0c       	cp.w	r12,0
80008fe6:	c1 d0       	breq	80009020 <_vfprintf_r+0xf94>
80008fe8:	10 36       	cp.w	r6,r8
80008fea:	c0 64       	brge	80008ff6 <_vfprintf_r+0xf6a>
80008fec:	fa cb f9 44 	sub	r11,sp,-1724
80008ff0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008ff4:	c1 d8       	rjmp	8000902e <_vfprintf_r+0xfa2>
80008ff6:	fa c8 f9 50 	sub	r8,sp,-1712
80008ffa:	1a d8       	st.w	--sp,r8
80008ffc:	fa c8 fa b8 	sub	r8,sp,-1352
80009000:	1a d8       	st.w	--sp,r8
80009002:	fa c8 fb b4 	sub	r8,sp,-1100
80009006:	1a d8       	st.w	--sp,r8
80009008:	fa c9 ff b4 	sub	r9,sp,-76
8000900c:	fa c8 f9 40 	sub	r8,sp,-1728
80009010:	04 9a       	mov	r10,r2
80009012:	0c 9b       	mov	r11,r6
80009014:	08 9c       	mov	r12,r4
80009016:	fe b0 f6 a3 	rcall	80007d5c <get_arg>
8000901a:	2f dd       	sub	sp,-12
8000901c:	78 09       	ld.w	r9,r12[0x0]
8000901e:	c2 18       	rjmp	80009060 <_vfprintf_r+0xfd4>
80009020:	2f f7       	sub	r7,-1
80009022:	10 39       	cp.w	r9,r8
80009024:	c0 84       	brge	80009034 <_vfprintf_r+0xfa8>
80009026:	fa ca f9 44 	sub	r10,sp,-1724
8000902a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000902e:	ec f9 fd 88 	ld.w	r9,r6[-632]
80009032:	c1 78       	rjmp	80009060 <_vfprintf_r+0xfd4>
80009034:	41 09       	lddsp	r9,sp[0x40]
80009036:	59 f8       	cp.w	r8,31
80009038:	e0 89 00 10 	brgt	80009058 <_vfprintf_r+0xfcc>
8000903c:	f2 ca ff fc 	sub	r10,r9,-4
80009040:	51 0a       	stdsp	sp[0x40],r10
80009042:	fa c6 f9 44 	sub	r6,sp,-1724
80009046:	72 09       	ld.w	r9,r9[0x0]
80009048:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000904c:	f5 49 fd 88 	st.w	r10[-632],r9
80009050:	2f f8       	sub	r8,-1
80009052:	fb 48 06 b4 	st.w	sp[1716],r8
80009056:	c0 58       	rjmp	80009060 <_vfprintf_r+0xfd4>
80009058:	f2 c8 ff fc 	sub	r8,r9,-4
8000905c:	51 08       	stdsp	sp[0x40],r8
8000905e:	72 09       	ld.w	r9,r9[0x0]
80009060:	33 08       	mov	r8,48
80009062:	fb 68 06 b8 	st.b	sp[1720],r8
80009066:	37 88       	mov	r8,120
80009068:	30 0e       	mov	lr,0
8000906a:	fb 68 06 b9 	st.b	sp[1721],r8
8000906e:	fe cc b0 9e 	sub	r12,pc,-20322
80009072:	50 19       	stdsp	sp[0x4],r9
80009074:	a1 b5       	sbr	r5,0x1
80009076:	50 0e       	stdsp	sp[0x0],lr
80009078:	50 dc       	stdsp	sp[0x34],r12
8000907a:	30 28       	mov	r8,2
8000907c:	37 80       	mov	r0,120
8000907e:	e0 8f 02 a3 	bral	800095c4 <_vfprintf_r+0x1538>
80009082:	50 a7       	stdsp	sp[0x28],r7
80009084:	50 80       	stdsp	sp[0x20],r0
80009086:	10 90       	mov	r0,r8
80009088:	30 08       	mov	r8,0
8000908a:	fb 68 06 bb 	st.b	sp[1723],r8
8000908e:	0c 97       	mov	r7,r6
80009090:	04 94       	mov	r4,r2
80009092:	06 96       	mov	r6,r3
80009094:	02 92       	mov	r2,r1
80009096:	40 93       	lddsp	r3,sp[0x24]
80009098:	40 41       	lddsp	r1,sp[0x10]
8000909a:	0e 99       	mov	r9,r7
8000909c:	fa f8 06 b4 	ld.w	r8,sp[1716]
800090a0:	40 3b       	lddsp	r11,sp[0xc]
800090a2:	58 0b       	cp.w	r11,0
800090a4:	c1 d0       	breq	800090de <_vfprintf_r+0x1052>
800090a6:	10 36       	cp.w	r6,r8
800090a8:	c0 64       	brge	800090b4 <_vfprintf_r+0x1028>
800090aa:	fa ca f9 44 	sub	r10,sp,-1724
800090ae:	f4 06 00 36 	add	r6,r10,r6<<0x3
800090b2:	c1 d8       	rjmp	800090ec <_vfprintf_r+0x1060>
800090b4:	fa c8 f9 50 	sub	r8,sp,-1712
800090b8:	1a d8       	st.w	--sp,r8
800090ba:	fa c8 fa b8 	sub	r8,sp,-1352
800090be:	1a d8       	st.w	--sp,r8
800090c0:	fa c8 fb b4 	sub	r8,sp,-1100
800090c4:	0c 9b       	mov	r11,r6
800090c6:	1a d8       	st.w	--sp,r8
800090c8:	04 9a       	mov	r10,r2
800090ca:	fa c8 f9 40 	sub	r8,sp,-1728
800090ce:	fa c9 ff b4 	sub	r9,sp,-76
800090d2:	08 9c       	mov	r12,r4
800090d4:	fe b0 f6 44 	rcall	80007d5c <get_arg>
800090d8:	2f dd       	sub	sp,-12
800090da:	78 06       	ld.w	r6,r12[0x0]
800090dc:	c2 08       	rjmp	8000911c <_vfprintf_r+0x1090>
800090de:	2f f7       	sub	r7,-1
800090e0:	10 39       	cp.w	r9,r8
800090e2:	c0 84       	brge	800090f2 <_vfprintf_r+0x1066>
800090e4:	fa c9 f9 44 	sub	r9,sp,-1724
800090e8:	f2 06 00 36 	add	r6,r9,r6<<0x3
800090ec:	ec f6 fd 88 	ld.w	r6,r6[-632]
800090f0:	c1 68       	rjmp	8000911c <_vfprintf_r+0x1090>
800090f2:	41 09       	lddsp	r9,sp[0x40]
800090f4:	59 f8       	cp.w	r8,31
800090f6:	e0 89 00 10 	brgt	80009116 <_vfprintf_r+0x108a>
800090fa:	f2 ca ff fc 	sub	r10,r9,-4
800090fe:	51 0a       	stdsp	sp[0x40],r10
80009100:	72 06       	ld.w	r6,r9[0x0]
80009102:	fa ce f9 44 	sub	lr,sp,-1724
80009106:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000910a:	f3 46 fd 88 	st.w	r9[-632],r6
8000910e:	2f f8       	sub	r8,-1
80009110:	fb 48 06 b4 	st.w	sp[1716],r8
80009114:	c0 48       	rjmp	8000911c <_vfprintf_r+0x1090>
80009116:	72 06       	ld.w	r6,r9[0x0]
80009118:	2f c9       	sub	r9,-4
8000911a:	51 09       	stdsp	sp[0x40],r9
8000911c:	40 2c       	lddsp	r12,sp[0x8]
8000911e:	58 0c       	cp.w	r12,0
80009120:	c1 05       	brlt	80009140 <_vfprintf_r+0x10b4>
80009122:	18 9a       	mov	r10,r12
80009124:	30 0b       	mov	r11,0
80009126:	0c 9c       	mov	r12,r6
80009128:	e0 a0 12 38 	rcall	8000b598 <memchr>
8000912c:	e0 80 02 df 	breq	800096ea <_vfprintf_r+0x165e>
80009130:	f8 06 01 02 	sub	r2,r12,r6
80009134:	40 2b       	lddsp	r11,sp[0x8]
80009136:	16 32       	cp.w	r2,r11
80009138:	e0 89 02 d9 	brgt	800096ea <_vfprintf_r+0x165e>
8000913c:	e0 8f 02 d4 	bral	800096e4 <_vfprintf_r+0x1658>
80009140:	30 0a       	mov	r10,0
80009142:	0c 9c       	mov	r12,r6
80009144:	50 2a       	stdsp	sp[0x8],r10
80009146:	e0 a0 15 99 	rcall	8000bc78 <strlen>
8000914a:	18 92       	mov	r2,r12
8000914c:	e0 8f 02 d2 	bral	800096f0 <_vfprintf_r+0x1664>
80009150:	50 a7       	stdsp	sp[0x28],r7
80009152:	50 80       	stdsp	sp[0x20],r0
80009154:	0c 97       	mov	r7,r6
80009156:	04 94       	mov	r4,r2
80009158:	06 96       	mov	r6,r3
8000915a:	02 92       	mov	r2,r1
8000915c:	40 93       	lddsp	r3,sp[0x24]
8000915e:	10 90       	mov	r0,r8
80009160:	40 41       	lddsp	r1,sp[0x10]
80009162:	a5 a5       	sbr	r5,0x4
80009164:	c0 a8       	rjmp	80009178 <_vfprintf_r+0x10ec>
80009166:	50 a7       	stdsp	sp[0x28],r7
80009168:	50 80       	stdsp	sp[0x20],r0
8000916a:	0c 97       	mov	r7,r6
8000916c:	04 94       	mov	r4,r2
8000916e:	06 96       	mov	r6,r3
80009170:	02 92       	mov	r2,r1
80009172:	40 93       	lddsp	r3,sp[0x24]
80009174:	10 90       	mov	r0,r8
80009176:	40 41       	lddsp	r1,sp[0x10]
80009178:	ed b5 00 05 	bld	r5,0x5
8000917c:	c5 61       	brne	80009228 <_vfprintf_r+0x119c>
8000917e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009182:	40 39       	lddsp	r9,sp[0xc]
80009184:	58 09       	cp.w	r9,0
80009186:	c2 10       	breq	800091c8 <_vfprintf_r+0x113c>
80009188:	10 36       	cp.w	r6,r8
8000918a:	c0 74       	brge	80009198 <_vfprintf_r+0x110c>
8000918c:	fa c8 f9 44 	sub	r8,sp,-1724
80009190:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009194:	c2 38       	rjmp	800091da <_vfprintf_r+0x114e>
80009196:	d7 03       	nop
80009198:	fa c8 f9 50 	sub	r8,sp,-1712
8000919c:	1a d8       	st.w	--sp,r8
8000919e:	fa c8 fa b8 	sub	r8,sp,-1352
800091a2:	1a d8       	st.w	--sp,r8
800091a4:	fa c8 fb b4 	sub	r8,sp,-1100
800091a8:	1a d8       	st.w	--sp,r8
800091aa:	fa c8 f9 40 	sub	r8,sp,-1728
800091ae:	fa c9 ff b4 	sub	r9,sp,-76
800091b2:	04 9a       	mov	r10,r2
800091b4:	0c 9b       	mov	r11,r6
800091b6:	08 9c       	mov	r12,r4
800091b8:	fe b0 f5 d2 	rcall	80007d5c <get_arg>
800091bc:	2f dd       	sub	sp,-12
800091be:	f8 e8 00 00 	ld.d	r8,r12[0]
800091c2:	fa e9 00 00 	st.d	sp[0],r8
800091c6:	c2 e8       	rjmp	80009222 <_vfprintf_r+0x1196>
800091c8:	ee ca ff ff 	sub	r10,r7,-1
800091cc:	10 37       	cp.w	r7,r8
800091ce:	c0 b4       	brge	800091e4 <_vfprintf_r+0x1158>
800091d0:	fa c8 f9 44 	sub	r8,sp,-1724
800091d4:	14 97       	mov	r7,r10
800091d6:	f0 06 00 36 	add	r6,r8,r6<<0x3
800091da:	ec ea fd 88 	ld.d	r10,r6[-632]
800091de:	fa eb 00 00 	st.d	sp[0],r10
800091e2:	c2 08       	rjmp	80009222 <_vfprintf_r+0x1196>
800091e4:	41 09       	lddsp	r9,sp[0x40]
800091e6:	59 f8       	cp.w	r8,31
800091e8:	e0 89 00 16 	brgt	80009214 <_vfprintf_r+0x1188>
800091ec:	f2 e6 00 00 	ld.d	r6,r9[0]
800091f0:	f2 cb ff f8 	sub	r11,r9,-8
800091f4:	fa e7 00 00 	st.d	sp[0],r6
800091f8:	51 0b       	stdsp	sp[0x40],r11
800091fa:	fa c6 f9 44 	sub	r6,sp,-1724
800091fe:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009202:	fa e6 00 00 	ld.d	r6,sp[0]
80009206:	f2 e7 fd 88 	st.d	r9[-632],r6
8000920a:	2f f8       	sub	r8,-1
8000920c:	14 97       	mov	r7,r10
8000920e:	fb 48 06 b4 	st.w	sp[1716],r8
80009212:	c0 88       	rjmp	80009222 <_vfprintf_r+0x1196>
80009214:	f2 e6 00 00 	ld.d	r6,r9[0]
80009218:	2f 89       	sub	r9,-8
8000921a:	fa e7 00 00 	st.d	sp[0],r6
8000921e:	51 09       	stdsp	sp[0x40],r9
80009220:	14 97       	mov	r7,r10
80009222:	30 18       	mov	r8,1
80009224:	e0 8f 01 d0 	bral	800095c4 <_vfprintf_r+0x1538>
80009228:	ed b5 00 04 	bld	r5,0x4
8000922c:	c1 61       	brne	80009258 <_vfprintf_r+0x11cc>
8000922e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009232:	40 3e       	lddsp	lr,sp[0xc]
80009234:	58 0e       	cp.w	lr,0
80009236:	c0 80       	breq	80009246 <_vfprintf_r+0x11ba>
80009238:	10 36       	cp.w	r6,r8
8000923a:	c6 74       	brge	80009308 <_vfprintf_r+0x127c>
8000923c:	fa cc f9 44 	sub	r12,sp,-1724
80009240:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009244:	c8 08       	rjmp	80009344 <_vfprintf_r+0x12b8>
80009246:	ee ca ff ff 	sub	r10,r7,-1
8000924a:	10 37       	cp.w	r7,r8
8000924c:	c7 f4       	brge	8000934a <_vfprintf_r+0x12be>
8000924e:	fa cb f9 44 	sub	r11,sp,-1724
80009252:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009256:	c7 68       	rjmp	80009342 <_vfprintf_r+0x12b6>
80009258:	ed b5 00 06 	bld	r5,0x6
8000925c:	c4 a1       	brne	800092f0 <_vfprintf_r+0x1264>
8000925e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009262:	40 3c       	lddsp	r12,sp[0xc]
80009264:	58 0c       	cp.w	r12,0
80009266:	c1 d0       	breq	800092a0 <_vfprintf_r+0x1214>
80009268:	10 36       	cp.w	r6,r8
8000926a:	c0 64       	brge	80009276 <_vfprintf_r+0x11ea>
8000926c:	fa cb f9 44 	sub	r11,sp,-1724
80009270:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009274:	c1 f8       	rjmp	800092b2 <_vfprintf_r+0x1226>
80009276:	fa c8 f9 50 	sub	r8,sp,-1712
8000927a:	1a d8       	st.w	--sp,r8
8000927c:	fa c8 fa b8 	sub	r8,sp,-1352
80009280:	1a d8       	st.w	--sp,r8
80009282:	fa c8 fb b4 	sub	r8,sp,-1100
80009286:	1a d8       	st.w	--sp,r8
80009288:	fa c8 f9 40 	sub	r8,sp,-1728
8000928c:	fa c9 ff b4 	sub	r9,sp,-76
80009290:	04 9a       	mov	r10,r2
80009292:	0c 9b       	mov	r11,r6
80009294:	08 9c       	mov	r12,r4
80009296:	fe b0 f5 63 	rcall	80007d5c <get_arg>
8000929a:	2f dd       	sub	sp,-12
8000929c:	98 18       	ld.sh	r8,r12[0x2]
8000929e:	c2 68       	rjmp	800092ea <_vfprintf_r+0x125e>
800092a0:	ee ca ff ff 	sub	r10,r7,-1
800092a4:	10 37       	cp.w	r7,r8
800092a6:	c0 94       	brge	800092b8 <_vfprintf_r+0x122c>
800092a8:	fa c9 f9 44 	sub	r9,sp,-1724
800092ac:	14 97       	mov	r7,r10
800092ae:	f2 06 00 36 	add	r6,r9,r6<<0x3
800092b2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800092b6:	c1 a8       	rjmp	800092ea <_vfprintf_r+0x125e>
800092b8:	41 09       	lddsp	r9,sp[0x40]
800092ba:	59 f8       	cp.w	r8,31
800092bc:	e0 89 00 13 	brgt	800092e2 <_vfprintf_r+0x1256>
800092c0:	f2 cb ff fc 	sub	r11,r9,-4
800092c4:	51 0b       	stdsp	sp[0x40],r11
800092c6:	72 09       	ld.w	r9,r9[0x0]
800092c8:	fa c6 f9 44 	sub	r6,sp,-1724
800092cc:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800092d0:	2f f8       	sub	r8,-1
800092d2:	f7 49 fd 88 	st.w	r11[-632],r9
800092d6:	fb 48 06 b4 	st.w	sp[1716],r8
800092da:	14 97       	mov	r7,r10
800092dc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800092e0:	c0 58       	rjmp	800092ea <_vfprintf_r+0x125e>
800092e2:	92 18       	ld.sh	r8,r9[0x2]
800092e4:	14 97       	mov	r7,r10
800092e6:	2f c9       	sub	r9,-4
800092e8:	51 09       	stdsp	sp[0x40],r9
800092ea:	5c 78       	castu.h	r8
800092ec:	50 18       	stdsp	sp[0x4],r8
800092ee:	c4 68       	rjmp	8000937a <_vfprintf_r+0x12ee>
800092f0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800092f4:	40 3c       	lddsp	r12,sp[0xc]
800092f6:	58 0c       	cp.w	r12,0
800092f8:	c1 d0       	breq	80009332 <_vfprintf_r+0x12a6>
800092fa:	10 36       	cp.w	r6,r8
800092fc:	c0 64       	brge	80009308 <_vfprintf_r+0x127c>
800092fe:	fa cb f9 44 	sub	r11,sp,-1724
80009302:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009306:	c1 f8       	rjmp	80009344 <_vfprintf_r+0x12b8>
80009308:	fa c8 f9 50 	sub	r8,sp,-1712
8000930c:	1a d8       	st.w	--sp,r8
8000930e:	fa c8 fa b8 	sub	r8,sp,-1352
80009312:	0c 9b       	mov	r11,r6
80009314:	1a d8       	st.w	--sp,r8
80009316:	fa c8 fb b4 	sub	r8,sp,-1100
8000931a:	04 9a       	mov	r10,r2
8000931c:	1a d8       	st.w	--sp,r8
8000931e:	08 9c       	mov	r12,r4
80009320:	fa c8 f9 40 	sub	r8,sp,-1728
80009324:	fa c9 ff b4 	sub	r9,sp,-76
80009328:	fe b0 f5 1a 	rcall	80007d5c <get_arg>
8000932c:	2f dd       	sub	sp,-12
8000932e:	78 0b       	ld.w	r11,r12[0x0]
80009330:	c2 48       	rjmp	80009378 <_vfprintf_r+0x12ec>
80009332:	ee ca ff ff 	sub	r10,r7,-1
80009336:	10 37       	cp.w	r7,r8
80009338:	c0 94       	brge	8000934a <_vfprintf_r+0x12be>
8000933a:	fa c9 f9 44 	sub	r9,sp,-1724
8000933e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009342:	14 97       	mov	r7,r10
80009344:	ec fb fd 88 	ld.w	r11,r6[-632]
80009348:	c1 88       	rjmp	80009378 <_vfprintf_r+0x12ec>
8000934a:	41 09       	lddsp	r9,sp[0x40]
8000934c:	59 f8       	cp.w	r8,31
8000934e:	e0 89 00 11 	brgt	80009370 <_vfprintf_r+0x12e4>
80009352:	f2 cb ff fc 	sub	r11,r9,-4
80009356:	51 0b       	stdsp	sp[0x40],r11
80009358:	fa c6 f9 44 	sub	r6,sp,-1724
8000935c:	72 0b       	ld.w	r11,r9[0x0]
8000935e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009362:	f3 4b fd 88 	st.w	r9[-632],r11
80009366:	2f f8       	sub	r8,-1
80009368:	14 97       	mov	r7,r10
8000936a:	fb 48 06 b4 	st.w	sp[1716],r8
8000936e:	c0 58       	rjmp	80009378 <_vfprintf_r+0x12ec>
80009370:	72 0b       	ld.w	r11,r9[0x0]
80009372:	14 97       	mov	r7,r10
80009374:	2f c9       	sub	r9,-4
80009376:	51 09       	stdsp	sp[0x40],r9
80009378:	50 1b       	stdsp	sp[0x4],r11
8000937a:	30 0e       	mov	lr,0
8000937c:	30 18       	mov	r8,1
8000937e:	50 0e       	stdsp	sp[0x0],lr
80009380:	c2 29       	rjmp	800095c4 <_vfprintf_r+0x1538>
80009382:	50 a7       	stdsp	sp[0x28],r7
80009384:	50 80       	stdsp	sp[0x20],r0
80009386:	0c 97       	mov	r7,r6
80009388:	04 94       	mov	r4,r2
8000938a:	06 96       	mov	r6,r3
8000938c:	02 92       	mov	r2,r1
8000938e:	fe cc b3 be 	sub	r12,pc,-19522
80009392:	40 93       	lddsp	r3,sp[0x24]
80009394:	10 90       	mov	r0,r8
80009396:	40 41       	lddsp	r1,sp[0x10]
80009398:	50 dc       	stdsp	sp[0x34],r12
8000939a:	ed b5 00 05 	bld	r5,0x5
8000939e:	c5 51       	brne	80009448 <_vfprintf_r+0x13bc>
800093a0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800093a4:	40 3b       	lddsp	r11,sp[0xc]
800093a6:	58 0b       	cp.w	r11,0
800093a8:	c2 20       	breq	800093ec <_vfprintf_r+0x1360>
800093aa:	10 36       	cp.w	r6,r8
800093ac:	c0 a4       	brge	800093c0 <_vfprintf_r+0x1334>
800093ae:	fa ca f9 44 	sub	r10,sp,-1724
800093b2:	f4 06 00 36 	add	r6,r10,r6<<0x3
800093b6:	ec e8 fd 88 	ld.d	r8,r6[-632]
800093ba:	fa e9 00 00 	st.d	sp[0],r8
800093be:	cf 28       	rjmp	800095a2 <_vfprintf_r+0x1516>
800093c0:	fa c8 f9 50 	sub	r8,sp,-1712
800093c4:	1a d8       	st.w	--sp,r8
800093c6:	fa c8 fa b8 	sub	r8,sp,-1352
800093ca:	04 9a       	mov	r10,r2
800093cc:	1a d8       	st.w	--sp,r8
800093ce:	0c 9b       	mov	r11,r6
800093d0:	fa c8 fb b4 	sub	r8,sp,-1100
800093d4:	08 9c       	mov	r12,r4
800093d6:	1a d8       	st.w	--sp,r8
800093d8:	fa c8 f9 40 	sub	r8,sp,-1728
800093dc:	fa c9 ff b4 	sub	r9,sp,-76
800093e0:	fe b0 f4 be 	rcall	80007d5c <get_arg>
800093e4:	2f dd       	sub	sp,-12
800093e6:	f8 ea 00 00 	ld.d	r10,r12[0]
800093ea:	c0 c8       	rjmp	80009402 <_vfprintf_r+0x1376>
800093ec:	ee ca ff ff 	sub	r10,r7,-1
800093f0:	10 37       	cp.w	r7,r8
800093f2:	c0 b4       	brge	80009408 <_vfprintf_r+0x137c>
800093f4:	fa c9 f9 44 	sub	r9,sp,-1724
800093f8:	14 97       	mov	r7,r10
800093fa:	f2 06 00 36 	add	r6,r9,r6<<0x3
800093fe:	ec ea fd 88 	ld.d	r10,r6[-632]
80009402:	fa eb 00 00 	st.d	sp[0],r10
80009406:	cc e8       	rjmp	800095a2 <_vfprintf_r+0x1516>
80009408:	41 09       	lddsp	r9,sp[0x40]
8000940a:	59 f8       	cp.w	r8,31
8000940c:	e0 89 00 16 	brgt	80009438 <_vfprintf_r+0x13ac>
80009410:	f2 e6 00 00 	ld.d	r6,r9[0]
80009414:	f2 cb ff f8 	sub	r11,r9,-8
80009418:	fa e7 00 00 	st.d	sp[0],r6
8000941c:	51 0b       	stdsp	sp[0x40],r11
8000941e:	fa c6 f9 44 	sub	r6,sp,-1724
80009422:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009426:	fa e6 00 00 	ld.d	r6,sp[0]
8000942a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000942e:	2f f8       	sub	r8,-1
80009430:	14 97       	mov	r7,r10
80009432:	fb 48 06 b4 	st.w	sp[1716],r8
80009436:	cb 68       	rjmp	800095a2 <_vfprintf_r+0x1516>
80009438:	f2 e6 00 00 	ld.d	r6,r9[0]
8000943c:	2f 89       	sub	r9,-8
8000943e:	fa e7 00 00 	st.d	sp[0],r6
80009442:	51 09       	stdsp	sp[0x40],r9
80009444:	14 97       	mov	r7,r10
80009446:	ca e8       	rjmp	800095a2 <_vfprintf_r+0x1516>
80009448:	ed b5 00 04 	bld	r5,0x4
8000944c:	c1 71       	brne	8000947a <_vfprintf_r+0x13ee>
8000944e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009452:	40 3e       	lddsp	lr,sp[0xc]
80009454:	58 0e       	cp.w	lr,0
80009456:	c0 80       	breq	80009466 <_vfprintf_r+0x13da>
80009458:	10 36       	cp.w	r6,r8
8000945a:	c6 94       	brge	8000952c <_vfprintf_r+0x14a0>
8000945c:	fa cc f9 44 	sub	r12,sp,-1724
80009460:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009464:	c8 28       	rjmp	80009568 <_vfprintf_r+0x14dc>
80009466:	ee ca ff ff 	sub	r10,r7,-1
8000946a:	10 37       	cp.w	r7,r8
8000946c:	e0 84 00 81 	brge	8000956e <_vfprintf_r+0x14e2>
80009470:	fa cb f9 44 	sub	r11,sp,-1724
80009474:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009478:	c7 78       	rjmp	80009566 <_vfprintf_r+0x14da>
8000947a:	ed b5 00 06 	bld	r5,0x6
8000947e:	c4 b1       	brne	80009514 <_vfprintf_r+0x1488>
80009480:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009484:	40 3c       	lddsp	r12,sp[0xc]
80009486:	58 0c       	cp.w	r12,0
80009488:	c1 d0       	breq	800094c2 <_vfprintf_r+0x1436>
8000948a:	10 36       	cp.w	r6,r8
8000948c:	c0 64       	brge	80009498 <_vfprintf_r+0x140c>
8000948e:	fa cb f9 44 	sub	r11,sp,-1724
80009492:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009496:	c1 f8       	rjmp	800094d4 <_vfprintf_r+0x1448>
80009498:	fa c8 f9 50 	sub	r8,sp,-1712
8000949c:	1a d8       	st.w	--sp,r8
8000949e:	fa c8 fa b8 	sub	r8,sp,-1352
800094a2:	1a d8       	st.w	--sp,r8
800094a4:	fa c8 fb b4 	sub	r8,sp,-1100
800094a8:	1a d8       	st.w	--sp,r8
800094aa:	fa c8 f9 40 	sub	r8,sp,-1728
800094ae:	fa c9 ff b4 	sub	r9,sp,-76
800094b2:	04 9a       	mov	r10,r2
800094b4:	0c 9b       	mov	r11,r6
800094b6:	08 9c       	mov	r12,r4
800094b8:	fe b0 f4 52 	rcall	80007d5c <get_arg>
800094bc:	2f dd       	sub	sp,-12
800094be:	98 18       	ld.sh	r8,r12[0x2]
800094c0:	c2 78       	rjmp	8000950e <_vfprintf_r+0x1482>
800094c2:	ee ca ff ff 	sub	r10,r7,-1
800094c6:	10 37       	cp.w	r7,r8
800094c8:	c0 a4       	brge	800094dc <_vfprintf_r+0x1450>
800094ca:	fa c9 f9 44 	sub	r9,sp,-1724
800094ce:	14 97       	mov	r7,r10
800094d0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800094d4:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800094d8:	c1 b8       	rjmp	8000950e <_vfprintf_r+0x1482>
800094da:	d7 03       	nop
800094dc:	41 09       	lddsp	r9,sp[0x40]
800094de:	59 f8       	cp.w	r8,31
800094e0:	e0 89 00 13 	brgt	80009506 <_vfprintf_r+0x147a>
800094e4:	f2 cb ff fc 	sub	r11,r9,-4
800094e8:	51 0b       	stdsp	sp[0x40],r11
800094ea:	72 09       	ld.w	r9,r9[0x0]
800094ec:	fa c6 f9 44 	sub	r6,sp,-1724
800094f0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800094f4:	2f f8       	sub	r8,-1
800094f6:	f7 49 fd 88 	st.w	r11[-632],r9
800094fa:	fb 48 06 b4 	st.w	sp[1716],r8
800094fe:	14 97       	mov	r7,r10
80009500:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009504:	c0 58       	rjmp	8000950e <_vfprintf_r+0x1482>
80009506:	92 18       	ld.sh	r8,r9[0x2]
80009508:	14 97       	mov	r7,r10
8000950a:	2f c9       	sub	r9,-4
8000950c:	51 09       	stdsp	sp[0x40],r9
8000950e:	5c 78       	castu.h	r8
80009510:	50 18       	stdsp	sp[0x4],r8
80009512:	c4 68       	rjmp	8000959e <_vfprintf_r+0x1512>
80009514:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009518:	40 3c       	lddsp	r12,sp[0xc]
8000951a:	58 0c       	cp.w	r12,0
8000951c:	c1 d0       	breq	80009556 <_vfprintf_r+0x14ca>
8000951e:	10 36       	cp.w	r6,r8
80009520:	c0 64       	brge	8000952c <_vfprintf_r+0x14a0>
80009522:	fa cb f9 44 	sub	r11,sp,-1724
80009526:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000952a:	c1 f8       	rjmp	80009568 <_vfprintf_r+0x14dc>
8000952c:	fa c8 f9 50 	sub	r8,sp,-1712
80009530:	1a d8       	st.w	--sp,r8
80009532:	fa c8 fa b8 	sub	r8,sp,-1352
80009536:	0c 9b       	mov	r11,r6
80009538:	1a d8       	st.w	--sp,r8
8000953a:	fa c8 fb b4 	sub	r8,sp,-1100
8000953e:	04 9a       	mov	r10,r2
80009540:	1a d8       	st.w	--sp,r8
80009542:	08 9c       	mov	r12,r4
80009544:	fa c8 f9 40 	sub	r8,sp,-1728
80009548:	fa c9 ff b4 	sub	r9,sp,-76
8000954c:	fe b0 f4 08 	rcall	80007d5c <get_arg>
80009550:	2f dd       	sub	sp,-12
80009552:	78 0b       	ld.w	r11,r12[0x0]
80009554:	c2 48       	rjmp	8000959c <_vfprintf_r+0x1510>
80009556:	ee ca ff ff 	sub	r10,r7,-1
8000955a:	10 37       	cp.w	r7,r8
8000955c:	c0 94       	brge	8000956e <_vfprintf_r+0x14e2>
8000955e:	fa c9 f9 44 	sub	r9,sp,-1724
80009562:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009566:	14 97       	mov	r7,r10
80009568:	ec fb fd 88 	ld.w	r11,r6[-632]
8000956c:	c1 88       	rjmp	8000959c <_vfprintf_r+0x1510>
8000956e:	41 09       	lddsp	r9,sp[0x40]
80009570:	59 f8       	cp.w	r8,31
80009572:	e0 89 00 11 	brgt	80009594 <_vfprintf_r+0x1508>
80009576:	f2 cb ff fc 	sub	r11,r9,-4
8000957a:	51 0b       	stdsp	sp[0x40],r11
8000957c:	fa c6 f9 44 	sub	r6,sp,-1724
80009580:	72 0b       	ld.w	r11,r9[0x0]
80009582:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009586:	f3 4b fd 88 	st.w	r9[-632],r11
8000958a:	2f f8       	sub	r8,-1
8000958c:	14 97       	mov	r7,r10
8000958e:	fb 48 06 b4 	st.w	sp[1716],r8
80009592:	c0 58       	rjmp	8000959c <_vfprintf_r+0x1510>
80009594:	72 0b       	ld.w	r11,r9[0x0]
80009596:	14 97       	mov	r7,r10
80009598:	2f c9       	sub	r9,-4
8000959a:	51 09       	stdsp	sp[0x40],r9
8000959c:	50 1b       	stdsp	sp[0x4],r11
8000959e:	30 0e       	mov	lr,0
800095a0:	50 0e       	stdsp	sp[0x0],lr
800095a2:	40 08       	lddsp	r8,sp[0x0]
800095a4:	40 1c       	lddsp	r12,sp[0x4]
800095a6:	18 48       	or	r8,r12
800095a8:	5f 19       	srne	r9
800095aa:	0a 98       	mov	r8,r5
800095ac:	eb e9 00 09 	and	r9,r5,r9
800095b0:	a1 b8       	sbr	r8,0x1
800095b2:	58 09       	cp.w	r9,0
800095b4:	c0 70       	breq	800095c2 <_vfprintf_r+0x1536>
800095b6:	10 95       	mov	r5,r8
800095b8:	fb 60 06 b9 	st.b	sp[1721],r0
800095bc:	33 08       	mov	r8,48
800095be:	fb 68 06 b8 	st.b	sp[1720],r8
800095c2:	30 28       	mov	r8,2
800095c4:	30 09       	mov	r9,0
800095c6:	fb 69 06 bb 	st.b	sp[1723],r9
800095ca:	0a 99       	mov	r9,r5
800095cc:	a7 d9       	cbr	r9,0x7
800095ce:	40 2b       	lddsp	r11,sp[0x8]
800095d0:	40 16       	lddsp	r6,sp[0x4]
800095d2:	58 0b       	cp.w	r11,0
800095d4:	5f 1a       	srne	r10
800095d6:	f2 05 17 40 	movge	r5,r9
800095da:	fa c2 f9 78 	sub	r2,sp,-1672
800095de:	40 09       	lddsp	r9,sp[0x0]
800095e0:	0c 49       	or	r9,r6
800095e2:	5f 19       	srne	r9
800095e4:	f5 e9 10 09 	or	r9,r10,r9
800095e8:	c5 c0       	breq	800096a0 <_vfprintf_r+0x1614>
800095ea:	30 19       	mov	r9,1
800095ec:	f2 08 18 00 	cp.b	r8,r9
800095f0:	c0 60       	breq	800095fc <_vfprintf_r+0x1570>
800095f2:	30 29       	mov	r9,2
800095f4:	f2 08 18 00 	cp.b	r8,r9
800095f8:	c0 41       	brne	80009600 <_vfprintf_r+0x1574>
800095fa:	c3 c8       	rjmp	80009672 <_vfprintf_r+0x15e6>
800095fc:	04 96       	mov	r6,r2
800095fe:	c3 08       	rjmp	8000965e <_vfprintf_r+0x15d2>
80009600:	04 96       	mov	r6,r2
80009602:	fa e8 00 00 	ld.d	r8,sp[0]
80009606:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000960a:	2d 0a       	sub	r10,-48
8000960c:	0c fa       	st.b	--r6,r10
8000960e:	f0 0b 16 03 	lsr	r11,r8,0x3
80009612:	f2 0c 16 03 	lsr	r12,r9,0x3
80009616:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000961a:	18 99       	mov	r9,r12
8000961c:	16 98       	mov	r8,r11
8000961e:	58 08       	cp.w	r8,0
80009620:	5c 29       	cpc	r9
80009622:	cf 21       	brne	80009606 <_vfprintf_r+0x157a>
80009624:	fa e9 00 00 	st.d	sp[0],r8
80009628:	ed b5 00 00 	bld	r5,0x0
8000962c:	c4 51       	brne	800096b6 <_vfprintf_r+0x162a>
8000962e:	33 09       	mov	r9,48
80009630:	f2 0a 18 00 	cp.b	r10,r9
80009634:	c4 10       	breq	800096b6 <_vfprintf_r+0x162a>
80009636:	0c f9       	st.b	--r6,r9
80009638:	c3 f8       	rjmp	800096b6 <_vfprintf_r+0x162a>
8000963a:	fa ea 00 00 	ld.d	r10,sp[0]
8000963e:	30 a8       	mov	r8,10
80009640:	30 09       	mov	r9,0
80009642:	e0 a0 1a 19 	rcall	8000ca74 <__avr32_umod64>
80009646:	30 a8       	mov	r8,10
80009648:	2d 0a       	sub	r10,-48
8000964a:	30 09       	mov	r9,0
8000964c:	ac 8a       	st.b	r6[0x0],r10
8000964e:	fa ea 00 00 	ld.d	r10,sp[0]
80009652:	e0 a0 18 df 	rcall	8000c810 <__avr32_udiv64>
80009656:	16 99       	mov	r9,r11
80009658:	14 98       	mov	r8,r10
8000965a:	fa e9 00 00 	st.d	sp[0],r8
8000965e:	20 16       	sub	r6,1
80009660:	fa ea 00 00 	ld.d	r10,sp[0]
80009664:	58 9a       	cp.w	r10,9
80009666:	5c 2b       	cpc	r11
80009668:	fe 9b ff e9 	brhi	8000963a <_vfprintf_r+0x15ae>
8000966c:	1b f8       	ld.ub	r8,sp[0x7]
8000966e:	2d 08       	sub	r8,-48
80009670:	c2 08       	rjmp	800096b0 <_vfprintf_r+0x1624>
80009672:	04 96       	mov	r6,r2
80009674:	fa e8 00 00 	ld.d	r8,sp[0]
80009678:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000967c:	40 de       	lddsp	lr,sp[0x34]
8000967e:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80009682:	0c fa       	st.b	--r6,r10
80009684:	f2 0b 16 04 	lsr	r11,r9,0x4
80009688:	f0 0a 16 04 	lsr	r10,r8,0x4
8000968c:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009690:	16 99       	mov	r9,r11
80009692:	14 98       	mov	r8,r10
80009694:	58 08       	cp.w	r8,0
80009696:	5c 29       	cpc	r9
80009698:	cf 01       	brne	80009678 <_vfprintf_r+0x15ec>
8000969a:	fa e9 00 00 	st.d	sp[0],r8
8000969e:	c0 c8       	rjmp	800096b6 <_vfprintf_r+0x162a>
800096a0:	58 08       	cp.w	r8,0
800096a2:	c0 91       	brne	800096b4 <_vfprintf_r+0x1628>
800096a4:	ed b5 00 00 	bld	r5,0x0
800096a8:	c0 61       	brne	800096b4 <_vfprintf_r+0x1628>
800096aa:	fa c6 f9 79 	sub	r6,sp,-1671
800096ae:	33 08       	mov	r8,48
800096b0:	ac 88       	st.b	r6[0x0],r8
800096b2:	c0 28       	rjmp	800096b6 <_vfprintf_r+0x162a>
800096b4:	04 96       	mov	r6,r2
800096b6:	0c 12       	sub	r2,r6
800096b8:	c1 c8       	rjmp	800096f0 <_vfprintf_r+0x1664>
800096ba:	50 a7       	stdsp	sp[0x28],r7
800096bc:	50 80       	stdsp	sp[0x20],r0
800096be:	40 93       	lddsp	r3,sp[0x24]
800096c0:	0c 97       	mov	r7,r6
800096c2:	10 90       	mov	r0,r8
800096c4:	04 94       	mov	r4,r2
800096c6:	40 41       	lddsp	r1,sp[0x10]
800096c8:	58 08       	cp.w	r8,0
800096ca:	e0 80 04 4f 	breq	80009f68 <_vfprintf_r+0x1edc>
800096ce:	fb 68 06 60 	st.b	sp[1632],r8
800096d2:	30 0c       	mov	r12,0
800096d4:	30 08       	mov	r8,0
800096d6:	30 12       	mov	r2,1
800096d8:	fb 68 06 bb 	st.b	sp[1723],r8
800096dc:	50 2c       	stdsp	sp[0x8],r12
800096de:	fa c6 f9 a0 	sub	r6,sp,-1632
800096e2:	c0 78       	rjmp	800096f0 <_vfprintf_r+0x1664>
800096e4:	30 0b       	mov	r11,0
800096e6:	50 2b       	stdsp	sp[0x8],r11
800096e8:	c0 48       	rjmp	800096f0 <_vfprintf_r+0x1664>
800096ea:	40 22       	lddsp	r2,sp[0x8]
800096ec:	30 0a       	mov	r10,0
800096ee:	50 2a       	stdsp	sp[0x8],r10
800096f0:	40 29       	lddsp	r9,sp[0x8]
800096f2:	e4 09 0c 49 	max	r9,r2,r9
800096f6:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800096fa:	50 39       	stdsp	sp[0xc],r9
800096fc:	0a 9e       	mov	lr,r5
800096fe:	30 09       	mov	r9,0
80009700:	e2 1e 00 02 	andl	lr,0x2,COH
80009704:	f2 08 18 00 	cp.b	r8,r9
80009708:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000970c:	f7 b8 01 ff 	subne	r8,-1
80009710:	fb f8 1a 03 	st.wne	sp[0xc],r8
80009714:	0a 9b       	mov	r11,r5
80009716:	58 0e       	cp.w	lr,0
80009718:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000971c:	f7 bc 01 fe 	subne	r12,-2
80009720:	fb fc 1a 03 	st.wne	sp[0xc],r12
80009724:	e2 1b 00 84 	andl	r11,0x84,COH
80009728:	50 fe       	stdsp	sp[0x3c],lr
8000972a:	50 9b       	stdsp	sp[0x24],r11
8000972c:	c4 71       	brne	800097ba <_vfprintf_r+0x172e>
8000972e:	40 8a       	lddsp	r10,sp[0x20]
80009730:	40 39       	lddsp	r9,sp[0xc]
80009732:	12 1a       	sub	r10,r9
80009734:	50 4a       	stdsp	sp[0x10],r10
80009736:	58 0a       	cp.w	r10,0
80009738:	e0 89 00 20 	brgt	80009778 <_vfprintf_r+0x16ec>
8000973c:	c3 f8       	rjmp	800097ba <_vfprintf_r+0x172e>
8000973e:	2f 09       	sub	r9,-16
80009740:	2f f8       	sub	r8,-1
80009742:	fe ce b7 5a 	sub	lr,pc,-18598
80009746:	31 0c       	mov	r12,16
80009748:	fb 49 06 90 	st.w	sp[1680],r9
8000974c:	87 0e       	st.w	r3[0x0],lr
8000974e:	87 1c       	st.w	r3[0x4],r12
80009750:	fb 48 06 8c 	st.w	sp[1676],r8
80009754:	58 78       	cp.w	r8,7
80009756:	e0 89 00 04 	brgt	8000975e <_vfprintf_r+0x16d2>
8000975a:	2f 83       	sub	r3,-8
8000975c:	c0 b8       	rjmp	80009772 <_vfprintf_r+0x16e6>
8000975e:	fa ca f9 78 	sub	r10,sp,-1672
80009762:	02 9b       	mov	r11,r1
80009764:	08 9c       	mov	r12,r4
80009766:	fe b0 f4 85 	rcall	80008070 <__sprint_r>
8000976a:	e0 81 04 10 	brne	80009f8a <_vfprintf_r+0x1efe>
8000976e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009772:	40 4b       	lddsp	r11,sp[0x10]
80009774:	21 0b       	sub	r11,16
80009776:	50 4b       	stdsp	sp[0x10],r11
80009778:	fa f9 06 90 	ld.w	r9,sp[1680]
8000977c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009780:	fe ca b7 98 	sub	r10,pc,-18536
80009784:	40 4e       	lddsp	lr,sp[0x10]
80009786:	59 0e       	cp.w	lr,16
80009788:	fe 99 ff db 	brgt	8000973e <_vfprintf_r+0x16b2>
8000978c:	1c 09       	add	r9,lr
8000978e:	2f f8       	sub	r8,-1
80009790:	87 0a       	st.w	r3[0x0],r10
80009792:	fb 49 06 90 	st.w	sp[1680],r9
80009796:	87 1e       	st.w	r3[0x4],lr
80009798:	fb 48 06 8c 	st.w	sp[1676],r8
8000979c:	58 78       	cp.w	r8,7
8000979e:	e0 89 00 04 	brgt	800097a6 <_vfprintf_r+0x171a>
800097a2:	2f 83       	sub	r3,-8
800097a4:	c0 b8       	rjmp	800097ba <_vfprintf_r+0x172e>
800097a6:	fa ca f9 78 	sub	r10,sp,-1672
800097aa:	02 9b       	mov	r11,r1
800097ac:	08 9c       	mov	r12,r4
800097ae:	fe b0 f4 61 	rcall	80008070 <__sprint_r>
800097b2:	e0 81 03 ec 	brne	80009f8a <_vfprintf_r+0x1efe>
800097b6:	fa c3 f9 e0 	sub	r3,sp,-1568
800097ba:	30 09       	mov	r9,0
800097bc:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800097c0:	f2 08 18 00 	cp.b	r8,r9
800097c4:	c1 f0       	breq	80009802 <_vfprintf_r+0x1776>
800097c6:	fa f8 06 90 	ld.w	r8,sp[1680]
800097ca:	fa c9 f9 45 	sub	r9,sp,-1723
800097ce:	2f f8       	sub	r8,-1
800097d0:	87 09       	st.w	r3[0x0],r9
800097d2:	fb 48 06 90 	st.w	sp[1680],r8
800097d6:	30 19       	mov	r9,1
800097d8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097dc:	87 19       	st.w	r3[0x4],r9
800097de:	2f f8       	sub	r8,-1
800097e0:	fb 48 06 8c 	st.w	sp[1676],r8
800097e4:	58 78       	cp.w	r8,7
800097e6:	e0 89 00 04 	brgt	800097ee <_vfprintf_r+0x1762>
800097ea:	2f 83       	sub	r3,-8
800097ec:	c0 b8       	rjmp	80009802 <_vfprintf_r+0x1776>
800097ee:	fa ca f9 78 	sub	r10,sp,-1672
800097f2:	02 9b       	mov	r11,r1
800097f4:	08 9c       	mov	r12,r4
800097f6:	fe b0 f4 3d 	rcall	80008070 <__sprint_r>
800097fa:	e0 81 03 c8 	brne	80009f8a <_vfprintf_r+0x1efe>
800097fe:	fa c3 f9 e0 	sub	r3,sp,-1568
80009802:	40 fc       	lddsp	r12,sp[0x3c]
80009804:	58 0c       	cp.w	r12,0
80009806:	c1 f0       	breq	80009844 <_vfprintf_r+0x17b8>
80009808:	fa f8 06 90 	ld.w	r8,sp[1680]
8000980c:	fa c9 f9 48 	sub	r9,sp,-1720
80009810:	2f e8       	sub	r8,-2
80009812:	87 09       	st.w	r3[0x0],r9
80009814:	fb 48 06 90 	st.w	sp[1680],r8
80009818:	30 29       	mov	r9,2
8000981a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000981e:	87 19       	st.w	r3[0x4],r9
80009820:	2f f8       	sub	r8,-1
80009822:	fb 48 06 8c 	st.w	sp[1676],r8
80009826:	58 78       	cp.w	r8,7
80009828:	e0 89 00 04 	brgt	80009830 <_vfprintf_r+0x17a4>
8000982c:	2f 83       	sub	r3,-8
8000982e:	c0 b8       	rjmp	80009844 <_vfprintf_r+0x17b8>
80009830:	fa ca f9 78 	sub	r10,sp,-1672
80009834:	02 9b       	mov	r11,r1
80009836:	08 9c       	mov	r12,r4
80009838:	fe b0 f4 1c 	rcall	80008070 <__sprint_r>
8000983c:	e0 81 03 a7 	brne	80009f8a <_vfprintf_r+0x1efe>
80009840:	fa c3 f9 e0 	sub	r3,sp,-1568
80009844:	40 9b       	lddsp	r11,sp[0x24]
80009846:	e0 4b 00 80 	cp.w	r11,128
8000984a:	c4 71       	brne	800098d8 <_vfprintf_r+0x184c>
8000984c:	40 8a       	lddsp	r10,sp[0x20]
8000984e:	40 39       	lddsp	r9,sp[0xc]
80009850:	12 1a       	sub	r10,r9
80009852:	50 4a       	stdsp	sp[0x10],r10
80009854:	58 0a       	cp.w	r10,0
80009856:	e0 89 00 20 	brgt	80009896 <_vfprintf_r+0x180a>
8000985a:	c3 f8       	rjmp	800098d8 <_vfprintf_r+0x184c>
8000985c:	2f 09       	sub	r9,-16
8000985e:	2f f8       	sub	r8,-1
80009860:	fe ce b8 68 	sub	lr,pc,-18328
80009864:	31 0c       	mov	r12,16
80009866:	fb 49 06 90 	st.w	sp[1680],r9
8000986a:	87 0e       	st.w	r3[0x0],lr
8000986c:	87 1c       	st.w	r3[0x4],r12
8000986e:	fb 48 06 8c 	st.w	sp[1676],r8
80009872:	58 78       	cp.w	r8,7
80009874:	e0 89 00 04 	brgt	8000987c <_vfprintf_r+0x17f0>
80009878:	2f 83       	sub	r3,-8
8000987a:	c0 b8       	rjmp	80009890 <_vfprintf_r+0x1804>
8000987c:	fa ca f9 78 	sub	r10,sp,-1672
80009880:	02 9b       	mov	r11,r1
80009882:	08 9c       	mov	r12,r4
80009884:	fe b0 f3 f6 	rcall	80008070 <__sprint_r>
80009888:	e0 81 03 81 	brne	80009f8a <_vfprintf_r+0x1efe>
8000988c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009890:	40 4b       	lddsp	r11,sp[0x10]
80009892:	21 0b       	sub	r11,16
80009894:	50 4b       	stdsp	sp[0x10],r11
80009896:	fa f9 06 90 	ld.w	r9,sp[1680]
8000989a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000989e:	fe ca b8 a6 	sub	r10,pc,-18266
800098a2:	40 4e       	lddsp	lr,sp[0x10]
800098a4:	59 0e       	cp.w	lr,16
800098a6:	fe 99 ff db 	brgt	8000985c <_vfprintf_r+0x17d0>
800098aa:	1c 09       	add	r9,lr
800098ac:	2f f8       	sub	r8,-1
800098ae:	87 0a       	st.w	r3[0x0],r10
800098b0:	fb 49 06 90 	st.w	sp[1680],r9
800098b4:	87 1e       	st.w	r3[0x4],lr
800098b6:	fb 48 06 8c 	st.w	sp[1676],r8
800098ba:	58 78       	cp.w	r8,7
800098bc:	e0 89 00 04 	brgt	800098c4 <_vfprintf_r+0x1838>
800098c0:	2f 83       	sub	r3,-8
800098c2:	c0 b8       	rjmp	800098d8 <_vfprintf_r+0x184c>
800098c4:	fa ca f9 78 	sub	r10,sp,-1672
800098c8:	02 9b       	mov	r11,r1
800098ca:	08 9c       	mov	r12,r4
800098cc:	fe b0 f3 d2 	rcall	80008070 <__sprint_r>
800098d0:	e0 81 03 5d 	brne	80009f8a <_vfprintf_r+0x1efe>
800098d4:	fa c3 f9 e0 	sub	r3,sp,-1568
800098d8:	40 2c       	lddsp	r12,sp[0x8]
800098da:	04 1c       	sub	r12,r2
800098dc:	50 2c       	stdsp	sp[0x8],r12
800098de:	58 0c       	cp.w	r12,0
800098e0:	e0 89 00 20 	brgt	80009920 <_vfprintf_r+0x1894>
800098e4:	c3 f8       	rjmp	80009962 <_vfprintf_r+0x18d6>
800098e6:	2f 09       	sub	r9,-16
800098e8:	2f f8       	sub	r8,-1
800098ea:	fe cb b8 f2 	sub	r11,pc,-18190
800098ee:	31 0a       	mov	r10,16
800098f0:	fb 49 06 90 	st.w	sp[1680],r9
800098f4:	87 0b       	st.w	r3[0x0],r11
800098f6:	87 1a       	st.w	r3[0x4],r10
800098f8:	fb 48 06 8c 	st.w	sp[1676],r8
800098fc:	58 78       	cp.w	r8,7
800098fe:	e0 89 00 04 	brgt	80009906 <_vfprintf_r+0x187a>
80009902:	2f 83       	sub	r3,-8
80009904:	c0 b8       	rjmp	8000991a <_vfprintf_r+0x188e>
80009906:	fa ca f9 78 	sub	r10,sp,-1672
8000990a:	02 9b       	mov	r11,r1
8000990c:	08 9c       	mov	r12,r4
8000990e:	fe b0 f3 b1 	rcall	80008070 <__sprint_r>
80009912:	e0 81 03 3c 	brne	80009f8a <_vfprintf_r+0x1efe>
80009916:	fa c3 f9 e0 	sub	r3,sp,-1568
8000991a:	40 29       	lddsp	r9,sp[0x8]
8000991c:	21 09       	sub	r9,16
8000991e:	50 29       	stdsp	sp[0x8],r9
80009920:	fa f9 06 90 	ld.w	r9,sp[1680]
80009924:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009928:	fe ca b9 30 	sub	r10,pc,-18128
8000992c:	40 2e       	lddsp	lr,sp[0x8]
8000992e:	59 0e       	cp.w	lr,16
80009930:	fe 99 ff db 	brgt	800098e6 <_vfprintf_r+0x185a>
80009934:	1c 09       	add	r9,lr
80009936:	2f f8       	sub	r8,-1
80009938:	87 0a       	st.w	r3[0x0],r10
8000993a:	fb 49 06 90 	st.w	sp[1680],r9
8000993e:	87 1e       	st.w	r3[0x4],lr
80009940:	fb 48 06 8c 	st.w	sp[1676],r8
80009944:	58 78       	cp.w	r8,7
80009946:	e0 89 00 04 	brgt	8000994e <_vfprintf_r+0x18c2>
8000994a:	2f 83       	sub	r3,-8
8000994c:	c0 b8       	rjmp	80009962 <_vfprintf_r+0x18d6>
8000994e:	fa ca f9 78 	sub	r10,sp,-1672
80009952:	02 9b       	mov	r11,r1
80009954:	08 9c       	mov	r12,r4
80009956:	fe b0 f3 8d 	rcall	80008070 <__sprint_r>
8000995a:	e0 81 03 18 	brne	80009f8a <_vfprintf_r+0x1efe>
8000995e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009962:	ed b5 00 08 	bld	r5,0x8
80009966:	c0 b0       	breq	8000997c <_vfprintf_r+0x18f0>
80009968:	fa f8 06 90 	ld.w	r8,sp[1680]
8000996c:	87 12       	st.w	r3[0x4],r2
8000996e:	87 06       	st.w	r3[0x0],r6
80009970:	f0 02 00 02 	add	r2,r8,r2
80009974:	fb 42 06 90 	st.w	sp[1680],r2
80009978:	e0 8f 01 d4 	bral	80009d20 <_vfprintf_r+0x1c94>
8000997c:	e0 40 00 65 	cp.w	r0,101
80009980:	e0 8a 01 d6 	brle	80009d2c <_vfprintf_r+0x1ca0>
80009984:	30 08       	mov	r8,0
80009986:	30 09       	mov	r9,0
80009988:	40 5b       	lddsp	r11,sp[0x14]
8000998a:	40 7a       	lddsp	r10,sp[0x1c]
8000998c:	e0 a0 15 3b 	rcall	8000c402 <__avr32_f64_cmp_eq>
80009990:	c7 90       	breq	80009a82 <_vfprintf_r+0x19f6>
80009992:	fa f8 06 90 	ld.w	r8,sp[1680]
80009996:	fe c9 b9 b2 	sub	r9,pc,-17998
8000999a:	2f f8       	sub	r8,-1
8000999c:	87 09       	st.w	r3[0x0],r9
8000999e:	fb 48 06 90 	st.w	sp[1680],r8
800099a2:	30 19       	mov	r9,1
800099a4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099a8:	87 19       	st.w	r3[0x4],r9
800099aa:	2f f8       	sub	r8,-1
800099ac:	fb 48 06 8c 	st.w	sp[1676],r8
800099b0:	58 78       	cp.w	r8,7
800099b2:	e0 89 00 05 	brgt	800099bc <_vfprintf_r+0x1930>
800099b6:	2f 83       	sub	r3,-8
800099b8:	c0 c8       	rjmp	800099d0 <_vfprintf_r+0x1944>
800099ba:	d7 03       	nop
800099bc:	fa ca f9 78 	sub	r10,sp,-1672
800099c0:	02 9b       	mov	r11,r1
800099c2:	08 9c       	mov	r12,r4
800099c4:	fe b0 f3 56 	rcall	80008070 <__sprint_r>
800099c8:	e0 81 02 e1 	brne	80009f8a <_vfprintf_r+0x1efe>
800099cc:	fa c3 f9 e0 	sub	r3,sp,-1568
800099d0:	fa f8 06 ac 	ld.w	r8,sp[1708]
800099d4:	40 6c       	lddsp	r12,sp[0x18]
800099d6:	18 38       	cp.w	r8,r12
800099d8:	c0 55       	brlt	800099e2 <_vfprintf_r+0x1956>
800099da:	ed b5 00 00 	bld	r5,0x0
800099de:	e0 81 02 6b 	brne	80009eb4 <_vfprintf_r+0x1e28>
800099e2:	fa f8 06 90 	ld.w	r8,sp[1680]
800099e6:	2f f8       	sub	r8,-1
800099e8:	40 cb       	lddsp	r11,sp[0x30]
800099ea:	fb 48 06 90 	st.w	sp[1680],r8
800099ee:	30 19       	mov	r9,1
800099f0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099f4:	87 0b       	st.w	r3[0x0],r11
800099f6:	2f f8       	sub	r8,-1
800099f8:	87 19       	st.w	r3[0x4],r9
800099fa:	fb 48 06 8c 	st.w	sp[1676],r8
800099fe:	58 78       	cp.w	r8,7
80009a00:	e0 89 00 04 	brgt	80009a08 <_vfprintf_r+0x197c>
80009a04:	2f 83       	sub	r3,-8
80009a06:	c0 b8       	rjmp	80009a1c <_vfprintf_r+0x1990>
80009a08:	fa ca f9 78 	sub	r10,sp,-1672
80009a0c:	02 9b       	mov	r11,r1
80009a0e:	08 9c       	mov	r12,r4
80009a10:	fe b0 f3 30 	rcall	80008070 <__sprint_r>
80009a14:	e0 81 02 bb 	brne	80009f8a <_vfprintf_r+0x1efe>
80009a18:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a1c:	40 66       	lddsp	r6,sp[0x18]
80009a1e:	20 16       	sub	r6,1
80009a20:	58 06       	cp.w	r6,0
80009a22:	e0 89 00 1d 	brgt	80009a5c <_vfprintf_r+0x19d0>
80009a26:	e0 8f 02 47 	bral	80009eb4 <_vfprintf_r+0x1e28>
80009a2a:	2f 09       	sub	r9,-16
80009a2c:	2f f8       	sub	r8,-1
80009a2e:	fb 49 06 90 	st.w	sp[1680],r9
80009a32:	87 02       	st.w	r3[0x0],r2
80009a34:	87 10       	st.w	r3[0x4],r0
80009a36:	fb 48 06 8c 	st.w	sp[1676],r8
80009a3a:	58 78       	cp.w	r8,7
80009a3c:	e0 89 00 04 	brgt	80009a44 <_vfprintf_r+0x19b8>
80009a40:	2f 83       	sub	r3,-8
80009a42:	c0 b8       	rjmp	80009a58 <_vfprintf_r+0x19cc>
80009a44:	fa ca f9 78 	sub	r10,sp,-1672
80009a48:	02 9b       	mov	r11,r1
80009a4a:	08 9c       	mov	r12,r4
80009a4c:	fe b0 f3 12 	rcall	80008070 <__sprint_r>
80009a50:	e0 81 02 9d 	brne	80009f8a <_vfprintf_r+0x1efe>
80009a54:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a58:	21 06       	sub	r6,16
80009a5a:	c0 48       	rjmp	80009a62 <_vfprintf_r+0x19d6>
80009a5c:	fe c2 ba 64 	sub	r2,pc,-17820
80009a60:	31 00       	mov	r0,16
80009a62:	fa f9 06 90 	ld.w	r9,sp[1680]
80009a66:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a6a:	fe ca ba 72 	sub	r10,pc,-17806
80009a6e:	59 06       	cp.w	r6,16
80009a70:	fe 99 ff dd 	brgt	80009a2a <_vfprintf_r+0x199e>
80009a74:	0c 09       	add	r9,r6
80009a76:	87 0a       	st.w	r3[0x0],r10
80009a78:	fb 49 06 90 	st.w	sp[1680],r9
80009a7c:	2f f8       	sub	r8,-1
80009a7e:	87 16       	st.w	r3[0x4],r6
80009a80:	c5 39       	rjmp	80009d26 <_vfprintf_r+0x1c9a>
80009a82:	fa fa 06 ac 	ld.w	r10,sp[1708]
80009a86:	58 0a       	cp.w	r10,0
80009a88:	e0 89 00 92 	brgt	80009bac <_vfprintf_r+0x1b20>
80009a8c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a90:	fe c9 ba ac 	sub	r9,pc,-17748
80009a94:	2f f8       	sub	r8,-1
80009a96:	87 09       	st.w	r3[0x0],r9
80009a98:	fb 48 06 90 	st.w	sp[1680],r8
80009a9c:	30 19       	mov	r9,1
80009a9e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009aa2:	87 19       	st.w	r3[0x4],r9
80009aa4:	2f f8       	sub	r8,-1
80009aa6:	fb 48 06 8c 	st.w	sp[1676],r8
80009aaa:	58 78       	cp.w	r8,7
80009aac:	e0 89 00 04 	brgt	80009ab4 <_vfprintf_r+0x1a28>
80009ab0:	2f 83       	sub	r3,-8
80009ab2:	c0 b8       	rjmp	80009ac8 <_vfprintf_r+0x1a3c>
80009ab4:	fa ca f9 78 	sub	r10,sp,-1672
80009ab8:	02 9b       	mov	r11,r1
80009aba:	08 9c       	mov	r12,r4
80009abc:	fe b0 f2 da 	rcall	80008070 <__sprint_r>
80009ac0:	e0 81 02 65 	brne	80009f8a <_vfprintf_r+0x1efe>
80009ac4:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ac8:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009acc:	58 08       	cp.w	r8,0
80009ace:	c0 81       	brne	80009ade <_vfprintf_r+0x1a52>
80009ad0:	40 6a       	lddsp	r10,sp[0x18]
80009ad2:	58 0a       	cp.w	r10,0
80009ad4:	c0 51       	brne	80009ade <_vfprintf_r+0x1a52>
80009ad6:	ed b5 00 00 	bld	r5,0x0
80009ada:	e0 81 01 ed 	brne	80009eb4 <_vfprintf_r+0x1e28>
80009ade:	40 c9       	lddsp	r9,sp[0x30]
80009ae0:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ae4:	2f f8       	sub	r8,-1
80009ae6:	87 09       	st.w	r3[0x0],r9
80009ae8:	fb 48 06 90 	st.w	sp[1680],r8
80009aec:	30 19       	mov	r9,1
80009aee:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009af2:	87 19       	st.w	r3[0x4],r9
80009af4:	2f f8       	sub	r8,-1
80009af6:	fb 48 06 8c 	st.w	sp[1676],r8
80009afa:	58 78       	cp.w	r8,7
80009afc:	e0 89 00 04 	brgt	80009b04 <_vfprintf_r+0x1a78>
80009b00:	2f 83       	sub	r3,-8
80009b02:	c0 b8       	rjmp	80009b18 <_vfprintf_r+0x1a8c>
80009b04:	fa ca f9 78 	sub	r10,sp,-1672
80009b08:	02 9b       	mov	r11,r1
80009b0a:	08 9c       	mov	r12,r4
80009b0c:	fe b0 f2 b2 	rcall	80008070 <__sprint_r>
80009b10:	e0 81 02 3d 	brne	80009f8a <_vfprintf_r+0x1efe>
80009b14:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b18:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009b1c:	5c 32       	neg	r2
80009b1e:	58 02       	cp.w	r2,0
80009b20:	e0 89 00 1d 	brgt	80009b5a <_vfprintf_r+0x1ace>
80009b24:	c3 d8       	rjmp	80009b9e <_vfprintf_r+0x1b12>
80009b26:	2f 09       	sub	r9,-16
80009b28:	2f f8       	sub	r8,-1
80009b2a:	31 0e       	mov	lr,16
80009b2c:	fb 49 06 90 	st.w	sp[1680],r9
80009b30:	87 00       	st.w	r3[0x0],r0
80009b32:	87 1e       	st.w	r3[0x4],lr
80009b34:	fb 48 06 8c 	st.w	sp[1676],r8
80009b38:	58 78       	cp.w	r8,7
80009b3a:	e0 89 00 04 	brgt	80009b42 <_vfprintf_r+0x1ab6>
80009b3e:	2f 83       	sub	r3,-8
80009b40:	c0 b8       	rjmp	80009b56 <_vfprintf_r+0x1aca>
80009b42:	fa ca f9 78 	sub	r10,sp,-1672
80009b46:	02 9b       	mov	r11,r1
80009b48:	08 9c       	mov	r12,r4
80009b4a:	fe b0 f2 93 	rcall	80008070 <__sprint_r>
80009b4e:	e0 81 02 1e 	brne	80009f8a <_vfprintf_r+0x1efe>
80009b52:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b56:	21 02       	sub	r2,16
80009b58:	c0 38       	rjmp	80009b5e <_vfprintf_r+0x1ad2>
80009b5a:	fe c0 bb 62 	sub	r0,pc,-17566
80009b5e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009b62:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b66:	fe ca bb 6e 	sub	r10,pc,-17554
80009b6a:	59 02       	cp.w	r2,16
80009b6c:	fe 99 ff dd 	brgt	80009b26 <_vfprintf_r+0x1a9a>
80009b70:	04 09       	add	r9,r2
80009b72:	2f f8       	sub	r8,-1
80009b74:	87 0a       	st.w	r3[0x0],r10
80009b76:	fb 49 06 90 	st.w	sp[1680],r9
80009b7a:	87 12       	st.w	r3[0x4],r2
80009b7c:	fb 48 06 8c 	st.w	sp[1676],r8
80009b80:	58 78       	cp.w	r8,7
80009b82:	e0 89 00 04 	brgt	80009b8a <_vfprintf_r+0x1afe>
80009b86:	2f 83       	sub	r3,-8
80009b88:	c0 b8       	rjmp	80009b9e <_vfprintf_r+0x1b12>
80009b8a:	fa ca f9 78 	sub	r10,sp,-1672
80009b8e:	02 9b       	mov	r11,r1
80009b90:	08 9c       	mov	r12,r4
80009b92:	fe b0 f2 6f 	rcall	80008070 <__sprint_r>
80009b96:	e0 81 01 fa 	brne	80009f8a <_vfprintf_r+0x1efe>
80009b9a:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b9e:	40 6c       	lddsp	r12,sp[0x18]
80009ba0:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ba4:	87 06       	st.w	r3[0x0],r6
80009ba6:	87 1c       	st.w	r3[0x4],r12
80009ba8:	18 08       	add	r8,r12
80009baa:	cb 98       	rjmp	80009d1c <_vfprintf_r+0x1c90>
80009bac:	fa f9 06 90 	ld.w	r9,sp[1680]
80009bb0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009bb4:	40 6b       	lddsp	r11,sp[0x18]
80009bb6:	16 3a       	cp.w	r10,r11
80009bb8:	c6 f5       	brlt	80009c96 <_vfprintf_r+0x1c0a>
80009bba:	16 09       	add	r9,r11
80009bbc:	2f f8       	sub	r8,-1
80009bbe:	87 06       	st.w	r3[0x0],r6
80009bc0:	fb 49 06 90 	st.w	sp[1680],r9
80009bc4:	87 1b       	st.w	r3[0x4],r11
80009bc6:	fb 48 06 8c 	st.w	sp[1676],r8
80009bca:	58 78       	cp.w	r8,7
80009bcc:	e0 89 00 04 	brgt	80009bd4 <_vfprintf_r+0x1b48>
80009bd0:	2f 83       	sub	r3,-8
80009bd2:	c0 b8       	rjmp	80009be8 <_vfprintf_r+0x1b5c>
80009bd4:	fa ca f9 78 	sub	r10,sp,-1672
80009bd8:	02 9b       	mov	r11,r1
80009bda:	08 9c       	mov	r12,r4
80009bdc:	fe b0 f2 4a 	rcall	80008070 <__sprint_r>
80009be0:	e0 81 01 d5 	brne	80009f8a <_vfprintf_r+0x1efe>
80009be4:	fa c3 f9 e0 	sub	r3,sp,-1568
80009be8:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009bec:	40 6a       	lddsp	r10,sp[0x18]
80009bee:	14 16       	sub	r6,r10
80009bf0:	58 06       	cp.w	r6,0
80009bf2:	e0 89 00 1c 	brgt	80009c2a <_vfprintf_r+0x1b9e>
80009bf6:	c3 d8       	rjmp	80009c70 <_vfprintf_r+0x1be4>
80009bf8:	2f 09       	sub	r9,-16
80009bfa:	2f f8       	sub	r8,-1
80009bfc:	fb 49 06 90 	st.w	sp[1680],r9
80009c00:	87 02       	st.w	r3[0x0],r2
80009c02:	87 10       	st.w	r3[0x4],r0
80009c04:	fb 48 06 8c 	st.w	sp[1676],r8
80009c08:	58 78       	cp.w	r8,7
80009c0a:	e0 89 00 04 	brgt	80009c12 <_vfprintf_r+0x1b86>
80009c0e:	2f 83       	sub	r3,-8
80009c10:	c0 b8       	rjmp	80009c26 <_vfprintf_r+0x1b9a>
80009c12:	fa ca f9 78 	sub	r10,sp,-1672
80009c16:	02 9b       	mov	r11,r1
80009c18:	08 9c       	mov	r12,r4
80009c1a:	fe b0 f2 2b 	rcall	80008070 <__sprint_r>
80009c1e:	e0 81 01 b6 	brne	80009f8a <_vfprintf_r+0x1efe>
80009c22:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c26:	21 06       	sub	r6,16
80009c28:	c0 48       	rjmp	80009c30 <_vfprintf_r+0x1ba4>
80009c2a:	fe c2 bc 32 	sub	r2,pc,-17358
80009c2e:	31 00       	mov	r0,16
80009c30:	fa f9 06 90 	ld.w	r9,sp[1680]
80009c34:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c38:	fe ca bc 40 	sub	r10,pc,-17344
80009c3c:	59 06       	cp.w	r6,16
80009c3e:	fe 99 ff dd 	brgt	80009bf8 <_vfprintf_r+0x1b6c>
80009c42:	0c 09       	add	r9,r6
80009c44:	2f f8       	sub	r8,-1
80009c46:	87 0a       	st.w	r3[0x0],r10
80009c48:	fb 49 06 90 	st.w	sp[1680],r9
80009c4c:	87 16       	st.w	r3[0x4],r6
80009c4e:	fb 48 06 8c 	st.w	sp[1676],r8
80009c52:	58 78       	cp.w	r8,7
80009c54:	e0 89 00 04 	brgt	80009c5c <_vfprintf_r+0x1bd0>
80009c58:	2f 83       	sub	r3,-8
80009c5a:	c0 b8       	rjmp	80009c70 <_vfprintf_r+0x1be4>
80009c5c:	fa ca f9 78 	sub	r10,sp,-1672
80009c60:	02 9b       	mov	r11,r1
80009c62:	08 9c       	mov	r12,r4
80009c64:	fe b0 f2 06 	rcall	80008070 <__sprint_r>
80009c68:	e0 81 01 91 	brne	80009f8a <_vfprintf_r+0x1efe>
80009c6c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c70:	ed b5 00 00 	bld	r5,0x0
80009c74:	e0 81 01 20 	brne	80009eb4 <_vfprintf_r+0x1e28>
80009c78:	40 c9       	lddsp	r9,sp[0x30]
80009c7a:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c7e:	2f f8       	sub	r8,-1
80009c80:	87 09       	st.w	r3[0x0],r9
80009c82:	fb 48 06 90 	st.w	sp[1680],r8
80009c86:	30 19       	mov	r9,1
80009c88:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c8c:	87 19       	st.w	r3[0x4],r9
80009c8e:	2f f8       	sub	r8,-1
80009c90:	fb 48 06 8c 	st.w	sp[1676],r8
80009c94:	c0 29       	rjmp	80009e98 <_vfprintf_r+0x1e0c>
80009c96:	14 09       	add	r9,r10
80009c98:	2f f8       	sub	r8,-1
80009c9a:	fb 49 06 90 	st.w	sp[1680],r9
80009c9e:	87 06       	st.w	r3[0x0],r6
80009ca0:	87 1a       	st.w	r3[0x4],r10
80009ca2:	fb 48 06 8c 	st.w	sp[1676],r8
80009ca6:	58 78       	cp.w	r8,7
80009ca8:	e0 89 00 04 	brgt	80009cb0 <_vfprintf_r+0x1c24>
80009cac:	2f 83       	sub	r3,-8
80009cae:	c0 b8       	rjmp	80009cc4 <_vfprintf_r+0x1c38>
80009cb0:	fa ca f9 78 	sub	r10,sp,-1672
80009cb4:	02 9b       	mov	r11,r1
80009cb6:	08 9c       	mov	r12,r4
80009cb8:	fe b0 f1 dc 	rcall	80008070 <__sprint_r>
80009cbc:	e0 81 01 67 	brne	80009f8a <_vfprintf_r+0x1efe>
80009cc0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009cc4:	40 c8       	lddsp	r8,sp[0x30]
80009cc6:	87 08       	st.w	r3[0x0],r8
80009cc8:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ccc:	2f f8       	sub	r8,-1
80009cce:	30 19       	mov	r9,1
80009cd0:	fb 48 06 90 	st.w	sp[1680],r8
80009cd4:	87 19       	st.w	r3[0x4],r9
80009cd6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009cda:	2f f8       	sub	r8,-1
80009cdc:	fb 48 06 8c 	st.w	sp[1676],r8
80009ce0:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009ce4:	58 78       	cp.w	r8,7
80009ce6:	e0 89 00 04 	brgt	80009cee <_vfprintf_r+0x1c62>
80009cea:	2f 83       	sub	r3,-8
80009cec:	c0 b8       	rjmp	80009d02 <_vfprintf_r+0x1c76>
80009cee:	fa ca f9 78 	sub	r10,sp,-1672
80009cf2:	02 9b       	mov	r11,r1
80009cf4:	08 9c       	mov	r12,r4
80009cf6:	fe b0 f1 bd 	rcall	80008070 <__sprint_r>
80009cfa:	e0 81 01 48 	brne	80009f8a <_vfprintf_r+0x1efe>
80009cfe:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d02:	04 06       	add	r6,r2
80009d04:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009d08:	87 06       	st.w	r3[0x0],r6
80009d0a:	fa f9 06 90 	ld.w	r9,sp[1680]
80009d0e:	40 66       	lddsp	r6,sp[0x18]
80009d10:	40 6e       	lddsp	lr,sp[0x18]
80009d12:	10 16       	sub	r6,r8
80009d14:	f2 08 01 08 	sub	r8,r9,r8
80009d18:	87 16       	st.w	r3[0x4],r6
80009d1a:	1c 08       	add	r8,lr
80009d1c:	fb 48 06 90 	st.w	sp[1680],r8
80009d20:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d24:	2f f8       	sub	r8,-1
80009d26:	fb 48 06 8c 	st.w	sp[1676],r8
80009d2a:	cb 78       	rjmp	80009e98 <_vfprintf_r+0x1e0c>
80009d2c:	40 6c       	lddsp	r12,sp[0x18]
80009d2e:	58 1c       	cp.w	r12,1
80009d30:	e0 89 00 06 	brgt	80009d3c <_vfprintf_r+0x1cb0>
80009d34:	ed b5 00 00 	bld	r5,0x0
80009d38:	e0 81 00 85 	brne	80009e42 <_vfprintf_r+0x1db6>
80009d3c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d40:	2f f8       	sub	r8,-1
80009d42:	30 19       	mov	r9,1
80009d44:	fb 48 06 90 	st.w	sp[1680],r8
80009d48:	87 06       	st.w	r3[0x0],r6
80009d4a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d4e:	87 19       	st.w	r3[0x4],r9
80009d50:	2f f8       	sub	r8,-1
80009d52:	fb 48 06 8c 	st.w	sp[1676],r8
80009d56:	58 78       	cp.w	r8,7
80009d58:	e0 89 00 04 	brgt	80009d60 <_vfprintf_r+0x1cd4>
80009d5c:	2f 83       	sub	r3,-8
80009d5e:	c0 b8       	rjmp	80009d74 <_vfprintf_r+0x1ce8>
80009d60:	fa ca f9 78 	sub	r10,sp,-1672
80009d64:	02 9b       	mov	r11,r1
80009d66:	08 9c       	mov	r12,r4
80009d68:	fe b0 f1 84 	rcall	80008070 <__sprint_r>
80009d6c:	e0 81 01 0f 	brne	80009f8a <_vfprintf_r+0x1efe>
80009d70:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d74:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d78:	2f f8       	sub	r8,-1
80009d7a:	40 cb       	lddsp	r11,sp[0x30]
80009d7c:	fb 48 06 90 	st.w	sp[1680],r8
80009d80:	30 19       	mov	r9,1
80009d82:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d86:	87 0b       	st.w	r3[0x0],r11
80009d88:	2f f8       	sub	r8,-1
80009d8a:	87 19       	st.w	r3[0x4],r9
80009d8c:	fb 48 06 8c 	st.w	sp[1676],r8
80009d90:	58 78       	cp.w	r8,7
80009d92:	e0 89 00 05 	brgt	80009d9c <_vfprintf_r+0x1d10>
80009d96:	2f 83       	sub	r3,-8
80009d98:	c0 c8       	rjmp	80009db0 <_vfprintf_r+0x1d24>
80009d9a:	d7 03       	nop
80009d9c:	fa ca f9 78 	sub	r10,sp,-1672
80009da0:	02 9b       	mov	r11,r1
80009da2:	08 9c       	mov	r12,r4
80009da4:	fe b0 f1 66 	rcall	80008070 <__sprint_r>
80009da8:	e0 81 00 f1 	brne	80009f8a <_vfprintf_r+0x1efe>
80009dac:	fa c3 f9 e0 	sub	r3,sp,-1568
80009db0:	30 08       	mov	r8,0
80009db2:	30 09       	mov	r9,0
80009db4:	40 5b       	lddsp	r11,sp[0x14]
80009db6:	40 7a       	lddsp	r10,sp[0x1c]
80009db8:	e0 a0 13 25 	rcall	8000c402 <__avr32_f64_cmp_eq>
80009dbc:	40 68       	lddsp	r8,sp[0x18]
80009dbe:	20 18       	sub	r8,1
80009dc0:	58 0c       	cp.w	r12,0
80009dc2:	c0 d1       	brne	80009ddc <_vfprintf_r+0x1d50>
80009dc4:	2f f6       	sub	r6,-1
80009dc6:	87 18       	st.w	r3[0x4],r8
80009dc8:	87 06       	st.w	r3[0x0],r6
80009dca:	fa f6 06 90 	ld.w	r6,sp[1680]
80009dce:	10 06       	add	r6,r8
80009dd0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009dd4:	fb 46 06 90 	st.w	sp[1680],r6
80009dd8:	2f f8       	sub	r8,-1
80009dda:	c3 18       	rjmp	80009e3c <_vfprintf_r+0x1db0>
80009ddc:	10 96       	mov	r6,r8
80009dde:	58 08       	cp.w	r8,0
80009de0:	e0 89 00 1c 	brgt	80009e18 <_vfprintf_r+0x1d8c>
80009de4:	c4 b8       	rjmp	80009e7a <_vfprintf_r+0x1dee>
80009de6:	2f 09       	sub	r9,-16
80009de8:	2f f8       	sub	r8,-1
80009dea:	fb 49 06 90 	st.w	sp[1680],r9
80009dee:	87 02       	st.w	r3[0x0],r2
80009df0:	87 10       	st.w	r3[0x4],r0
80009df2:	fb 48 06 8c 	st.w	sp[1676],r8
80009df6:	58 78       	cp.w	r8,7
80009df8:	e0 89 00 04 	brgt	80009e00 <_vfprintf_r+0x1d74>
80009dfc:	2f 83       	sub	r3,-8
80009dfe:	c0 b8       	rjmp	80009e14 <_vfprintf_r+0x1d88>
80009e00:	fa ca f9 78 	sub	r10,sp,-1672
80009e04:	02 9b       	mov	r11,r1
80009e06:	08 9c       	mov	r12,r4
80009e08:	fe b0 f1 34 	rcall	80008070 <__sprint_r>
80009e0c:	e0 81 00 bf 	brne	80009f8a <_vfprintf_r+0x1efe>
80009e10:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e14:	21 06       	sub	r6,16
80009e16:	c0 48       	rjmp	80009e1e <_vfprintf_r+0x1d92>
80009e18:	fe c2 be 20 	sub	r2,pc,-16864
80009e1c:	31 00       	mov	r0,16
80009e1e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009e22:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e26:	fe ca be 2e 	sub	r10,pc,-16850
80009e2a:	59 06       	cp.w	r6,16
80009e2c:	fe 99 ff dd 	brgt	80009de6 <_vfprintf_r+0x1d5a>
80009e30:	0c 09       	add	r9,r6
80009e32:	87 0a       	st.w	r3[0x0],r10
80009e34:	fb 49 06 90 	st.w	sp[1680],r9
80009e38:	2f f8       	sub	r8,-1
80009e3a:	87 16       	st.w	r3[0x4],r6
80009e3c:	fb 48 06 8c 	st.w	sp[1676],r8
80009e40:	c0 e8       	rjmp	80009e5c <_vfprintf_r+0x1dd0>
80009e42:	fa f8 06 90 	ld.w	r8,sp[1680]
80009e46:	2f f8       	sub	r8,-1
80009e48:	30 19       	mov	r9,1
80009e4a:	fb 48 06 90 	st.w	sp[1680],r8
80009e4e:	87 06       	st.w	r3[0x0],r6
80009e50:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e54:	87 19       	st.w	r3[0x4],r9
80009e56:	2f f8       	sub	r8,-1
80009e58:	fb 48 06 8c 	st.w	sp[1676],r8
80009e5c:	58 78       	cp.w	r8,7
80009e5e:	e0 89 00 04 	brgt	80009e66 <_vfprintf_r+0x1dda>
80009e62:	2f 83       	sub	r3,-8
80009e64:	c0 b8       	rjmp	80009e7a <_vfprintf_r+0x1dee>
80009e66:	fa ca f9 78 	sub	r10,sp,-1672
80009e6a:	02 9b       	mov	r11,r1
80009e6c:	08 9c       	mov	r12,r4
80009e6e:	fe b0 f1 01 	rcall	80008070 <__sprint_r>
80009e72:	e0 81 00 8c 	brne	80009f8a <_vfprintf_r+0x1efe>
80009e76:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e7a:	40 ea       	lddsp	r10,sp[0x38]
80009e7c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009e80:	14 08       	add	r8,r10
80009e82:	fa c9 f9 64 	sub	r9,sp,-1692
80009e86:	fb 48 06 90 	st.w	sp[1680],r8
80009e8a:	87 1a       	st.w	r3[0x4],r10
80009e8c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e90:	87 09       	st.w	r3[0x0],r9
80009e92:	2f f8       	sub	r8,-1
80009e94:	fb 48 06 8c 	st.w	sp[1676],r8
80009e98:	58 78       	cp.w	r8,7
80009e9a:	e0 89 00 04 	brgt	80009ea2 <_vfprintf_r+0x1e16>
80009e9e:	2f 83       	sub	r3,-8
80009ea0:	c0 a8       	rjmp	80009eb4 <_vfprintf_r+0x1e28>
80009ea2:	fa ca f9 78 	sub	r10,sp,-1672
80009ea6:	02 9b       	mov	r11,r1
80009ea8:	08 9c       	mov	r12,r4
80009eaa:	fe b0 f0 e3 	rcall	80008070 <__sprint_r>
80009eae:	c6 e1       	brne	80009f8a <_vfprintf_r+0x1efe>
80009eb0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009eb4:	e2 15 00 04 	andl	r5,0x4,COH
80009eb8:	c3 f0       	breq	80009f36 <_vfprintf_r+0x1eaa>
80009eba:	40 86       	lddsp	r6,sp[0x20]
80009ebc:	40 39       	lddsp	r9,sp[0xc]
80009ebe:	12 16       	sub	r6,r9
80009ec0:	58 06       	cp.w	r6,0
80009ec2:	e0 89 00 1a 	brgt	80009ef6 <_vfprintf_r+0x1e6a>
80009ec6:	c3 88       	rjmp	80009f36 <_vfprintf_r+0x1eaa>
80009ec8:	2f 09       	sub	r9,-16
80009eca:	2f f8       	sub	r8,-1
80009ecc:	fb 49 06 90 	st.w	sp[1680],r9
80009ed0:	87 05       	st.w	r3[0x0],r5
80009ed2:	87 12       	st.w	r3[0x4],r2
80009ed4:	fb 48 06 8c 	st.w	sp[1676],r8
80009ed8:	58 78       	cp.w	r8,7
80009eda:	e0 89 00 04 	brgt	80009ee2 <_vfprintf_r+0x1e56>
80009ede:	2f 83       	sub	r3,-8
80009ee0:	c0 98       	rjmp	80009ef2 <_vfprintf_r+0x1e66>
80009ee2:	00 9a       	mov	r10,r0
80009ee4:	02 9b       	mov	r11,r1
80009ee6:	08 9c       	mov	r12,r4
80009ee8:	fe b0 f0 c4 	rcall	80008070 <__sprint_r>
80009eec:	c4 f1       	brne	80009f8a <_vfprintf_r+0x1efe>
80009eee:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ef2:	21 06       	sub	r6,16
80009ef4:	c0 68       	rjmp	80009f00 <_vfprintf_r+0x1e74>
80009ef6:	fe c5 bf 0e 	sub	r5,pc,-16626
80009efa:	31 02       	mov	r2,16
80009efc:	fa c0 f9 78 	sub	r0,sp,-1672
80009f00:	fa f9 06 90 	ld.w	r9,sp[1680]
80009f04:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009f08:	fe ca bf 20 	sub	r10,pc,-16608
80009f0c:	59 06       	cp.w	r6,16
80009f0e:	fe 99 ff dd 	brgt	80009ec8 <_vfprintf_r+0x1e3c>
80009f12:	0c 09       	add	r9,r6
80009f14:	2f f8       	sub	r8,-1
80009f16:	87 0a       	st.w	r3[0x0],r10
80009f18:	87 16       	st.w	r3[0x4],r6
80009f1a:	fb 49 06 90 	st.w	sp[1680],r9
80009f1e:	fb 48 06 8c 	st.w	sp[1676],r8
80009f22:	58 78       	cp.w	r8,7
80009f24:	e0 8a 00 09 	brle	80009f36 <_vfprintf_r+0x1eaa>
80009f28:	fa ca f9 78 	sub	r10,sp,-1672
80009f2c:	02 9b       	mov	r11,r1
80009f2e:	08 9c       	mov	r12,r4
80009f30:	fe b0 f0 a0 	rcall	80008070 <__sprint_r>
80009f34:	c2 b1       	brne	80009f8a <_vfprintf_r+0x1efe>
80009f36:	40 bc       	lddsp	r12,sp[0x2c]
80009f38:	40 36       	lddsp	r6,sp[0xc]
80009f3a:	40 8e       	lddsp	lr,sp[0x20]
80009f3c:	ec 0e 0c 48 	max	r8,r6,lr
80009f40:	10 0c       	add	r12,r8
80009f42:	50 bc       	stdsp	sp[0x2c],r12
80009f44:	fa f8 06 90 	ld.w	r8,sp[1680]
80009f48:	58 08       	cp.w	r8,0
80009f4a:	c0 80       	breq	80009f5a <_vfprintf_r+0x1ece>
80009f4c:	fa ca f9 78 	sub	r10,sp,-1672
80009f50:	02 9b       	mov	r11,r1
80009f52:	08 9c       	mov	r12,r4
80009f54:	fe b0 f0 8e 	rcall	80008070 <__sprint_r>
80009f58:	c1 91       	brne	80009f8a <_vfprintf_r+0x1efe>
80009f5a:	30 0b       	mov	r11,0
80009f5c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f60:	fb 4b 06 8c 	st.w	sp[1676],r11
80009f64:	fe 9f f1 22 	bral	800081a8 <_vfprintf_r+0x11c>
80009f68:	08 95       	mov	r5,r4
80009f6a:	fa f8 06 90 	ld.w	r8,sp[1680]
80009f6e:	58 08       	cp.w	r8,0
80009f70:	c0 80       	breq	80009f80 <_vfprintf_r+0x1ef4>
80009f72:	08 9c       	mov	r12,r4
80009f74:	fa ca f9 78 	sub	r10,sp,-1672
80009f78:	02 9b       	mov	r11,r1
80009f7a:	fe b0 f0 7b 	rcall	80008070 <__sprint_r>
80009f7e:	c0 61       	brne	80009f8a <_vfprintf_r+0x1efe>
80009f80:	30 08       	mov	r8,0
80009f82:	fb 48 06 8c 	st.w	sp[1676],r8
80009f86:	c0 28       	rjmp	80009f8a <_vfprintf_r+0x1efe>
80009f88:	40 41       	lddsp	r1,sp[0x10]
80009f8a:	82 68       	ld.sh	r8,r1[0xc]
80009f8c:	ed b8 00 06 	bld	r8,0x6
80009f90:	c0 31       	brne	80009f96 <_vfprintf_r+0x1f0a>
80009f92:	3f fa       	mov	r10,-1
80009f94:	50 ba       	stdsp	sp[0x2c],r10
80009f96:	40 bc       	lddsp	r12,sp[0x2c]
80009f98:	fe 3d f9 44 	sub	sp,-1724
80009f9c:	d8 32       	popm	r0-r7,pc
80009f9e:	d7 03       	nop

80009fa0 <__swsetup_r>:
80009fa0:	d4 21       	pushm	r4-r7,lr
80009fa2:	e0 68 0a 3c 	mov	r8,2620
80009fa6:	18 96       	mov	r6,r12
80009fa8:	16 97       	mov	r7,r11
80009faa:	70 0c       	ld.w	r12,r8[0x0]
80009fac:	58 0c       	cp.w	r12,0
80009fae:	c0 60       	breq	80009fba <__swsetup_r+0x1a>
80009fb0:	78 68       	ld.w	r8,r12[0x18]
80009fb2:	58 08       	cp.w	r8,0
80009fb4:	c0 31       	brne	80009fba <__swsetup_r+0x1a>
80009fb6:	e0 a0 07 bf 	rcall	8000af34 <__sinit>
80009fba:	fe c8 be a2 	sub	r8,pc,-16734
80009fbe:	10 37       	cp.w	r7,r8
80009fc0:	c0 61       	brne	80009fcc <__swsetup_r+0x2c>
80009fc2:	e0 68 0a 3c 	mov	r8,2620
80009fc6:	70 08       	ld.w	r8,r8[0x0]
80009fc8:	70 07       	ld.w	r7,r8[0x0]
80009fca:	c1 28       	rjmp	80009fee <__swsetup_r+0x4e>
80009fcc:	fe c8 be 94 	sub	r8,pc,-16748
80009fd0:	10 37       	cp.w	r7,r8
80009fd2:	c0 61       	brne	80009fde <__swsetup_r+0x3e>
80009fd4:	e0 68 0a 3c 	mov	r8,2620
80009fd8:	70 08       	ld.w	r8,r8[0x0]
80009fda:	70 17       	ld.w	r7,r8[0x4]
80009fdc:	c0 98       	rjmp	80009fee <__swsetup_r+0x4e>
80009fde:	fe c8 be 86 	sub	r8,pc,-16762
80009fe2:	10 37       	cp.w	r7,r8
80009fe4:	c0 51       	brne	80009fee <__swsetup_r+0x4e>
80009fe6:	e0 68 0a 3c 	mov	r8,2620
80009fea:	70 08       	ld.w	r8,r8[0x0]
80009fec:	70 27       	ld.w	r7,r8[0x8]
80009fee:	8e 68       	ld.sh	r8,r7[0xc]
80009ff0:	ed b8 00 03 	bld	r8,0x3
80009ff4:	c1 e0       	breq	8000a030 <__swsetup_r+0x90>
80009ff6:	ed b8 00 04 	bld	r8,0x4
80009ffa:	c3 e1       	brne	8000a076 <__swsetup_r+0xd6>
80009ffc:	ed b8 00 02 	bld	r8,0x2
8000a000:	c1 51       	brne	8000a02a <__swsetup_r+0x8a>
8000a002:	6e db       	ld.w	r11,r7[0x34]
8000a004:	58 0b       	cp.w	r11,0
8000a006:	c0 a0       	breq	8000a01a <__swsetup_r+0x7a>
8000a008:	ee c8 ff bc 	sub	r8,r7,-68
8000a00c:	10 3b       	cp.w	r11,r8
8000a00e:	c0 40       	breq	8000a016 <__swsetup_r+0x76>
8000a010:	0c 9c       	mov	r12,r6
8000a012:	e0 a0 08 2b 	rcall	8000b068 <_free_r>
8000a016:	30 08       	mov	r8,0
8000a018:	8f d8       	st.w	r7[0x34],r8
8000a01a:	8e 68       	ld.sh	r8,r7[0xc]
8000a01c:	e0 18 ff db 	andl	r8,0xffdb
8000a020:	ae 68       	st.h	r7[0xc],r8
8000a022:	30 08       	mov	r8,0
8000a024:	8f 18       	st.w	r7[0x4],r8
8000a026:	6e 48       	ld.w	r8,r7[0x10]
8000a028:	8f 08       	st.w	r7[0x0],r8
8000a02a:	8e 68       	ld.sh	r8,r7[0xc]
8000a02c:	a3 b8       	sbr	r8,0x3
8000a02e:	ae 68       	st.h	r7[0xc],r8
8000a030:	6e 48       	ld.w	r8,r7[0x10]
8000a032:	58 08       	cp.w	r8,0
8000a034:	c0 b1       	brne	8000a04a <__swsetup_r+0xaa>
8000a036:	8e 68       	ld.sh	r8,r7[0xc]
8000a038:	e2 18 02 80 	andl	r8,0x280,COH
8000a03c:	e0 48 02 00 	cp.w	r8,512
8000a040:	c0 50       	breq	8000a04a <__swsetup_r+0xaa>
8000a042:	0c 9c       	mov	r12,r6
8000a044:	0e 9b       	mov	r11,r7
8000a046:	e0 a0 0a 4b 	rcall	8000b4dc <__smakebuf_r>
8000a04a:	8e 69       	ld.sh	r9,r7[0xc]
8000a04c:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000a050:	c0 70       	breq	8000a05e <__swsetup_r+0xbe>
8000a052:	30 08       	mov	r8,0
8000a054:	8f 28       	st.w	r7[0x8],r8
8000a056:	6e 58       	ld.w	r8,r7[0x14]
8000a058:	5c 38       	neg	r8
8000a05a:	8f 68       	st.w	r7[0x18],r8
8000a05c:	c0 68       	rjmp	8000a068 <__swsetup_r+0xc8>
8000a05e:	ed b9 00 01 	bld	r9,0x1
8000a062:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000a066:	8f 28       	st.w	r7[0x8],r8
8000a068:	6e 48       	ld.w	r8,r7[0x10]
8000a06a:	58 08       	cp.w	r8,0
8000a06c:	c0 61       	brne	8000a078 <__swsetup_r+0xd8>
8000a06e:	8e 68       	ld.sh	r8,r7[0xc]
8000a070:	ed b8 00 07 	bld	r8,0x7
8000a074:	c0 21       	brne	8000a078 <__swsetup_r+0xd8>
8000a076:	dc 2a       	popm	r4-r7,pc,r12=-1
8000a078:	d8 2a       	popm	r4-r7,pc,r12=0
8000a07a:	d7 03       	nop

8000a07c <quorem>:
8000a07c:	d4 31       	pushm	r0-r7,lr
8000a07e:	20 2d       	sub	sp,8
8000a080:	18 97       	mov	r7,r12
8000a082:	78 48       	ld.w	r8,r12[0x10]
8000a084:	76 46       	ld.w	r6,r11[0x10]
8000a086:	0c 38       	cp.w	r8,r6
8000a088:	c0 34       	brge	8000a08e <quorem+0x12>
8000a08a:	30 0c       	mov	r12,0
8000a08c:	c8 58       	rjmp	8000a196 <quorem+0x11a>
8000a08e:	ec c2 ff fc 	sub	r2,r6,-4
8000a092:	f6 c3 ff ec 	sub	r3,r11,-20
8000a096:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000a09a:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000a09e:	2f f9       	sub	r9,-1
8000a0a0:	20 16       	sub	r6,1
8000a0a2:	f8 09 0d 08 	divu	r8,r12,r9
8000a0a6:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000a0aa:	ee c4 ff ec 	sub	r4,r7,-20
8000a0ae:	10 95       	mov	r5,r8
8000a0b0:	58 08       	cp.w	r8,0
8000a0b2:	c4 10       	breq	8000a134 <quorem+0xb8>
8000a0b4:	30 09       	mov	r9,0
8000a0b6:	06 9a       	mov	r10,r3
8000a0b8:	08 98       	mov	r8,r4
8000a0ba:	12 91       	mov	r1,r9
8000a0bc:	50 0b       	stdsp	sp[0x0],r11
8000a0be:	70 0e       	ld.w	lr,r8[0x0]
8000a0c0:	b1 8e       	lsr	lr,0x10
8000a0c2:	50 1e       	stdsp	sp[0x4],lr
8000a0c4:	15 0e       	ld.w	lr,r10++
8000a0c6:	fc 00 16 10 	lsr	r0,lr,0x10
8000a0ca:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a0ce:	ea 0e 03 41 	mac	r1,r5,lr
8000a0d2:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000a0d6:	b1 81       	lsr	r1,0x10
8000a0d8:	40 1b       	lddsp	r11,sp[0x4]
8000a0da:	ea 00 02 40 	mul	r0,r5,r0
8000a0de:	e2 00 00 00 	add	r0,r1,r0
8000a0e2:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000a0e6:	02 1b       	sub	r11,r1
8000a0e8:	50 1b       	stdsp	sp[0x4],r11
8000a0ea:	70 0b       	ld.w	r11,r8[0x0]
8000a0ec:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000a0f0:	02 09       	add	r9,r1
8000a0f2:	f2 0e 01 0e 	sub	lr,r9,lr
8000a0f6:	b0 1e       	st.h	r8[0x2],lr
8000a0f8:	fc 09 14 10 	asr	r9,lr,0x10
8000a0fc:	40 1e       	lddsp	lr,sp[0x4]
8000a0fe:	fc 09 00 09 	add	r9,lr,r9
8000a102:	b0 09       	st.h	r8[0x0],r9
8000a104:	e0 01 16 10 	lsr	r1,r0,0x10
8000a108:	2f c8       	sub	r8,-4
8000a10a:	b1 49       	asr	r9,0x10
8000a10c:	04 3a       	cp.w	r10,r2
8000a10e:	fe 98 ff d8 	brls	8000a0be <quorem+0x42>
8000a112:	40 0b       	lddsp	r11,sp[0x0]
8000a114:	58 0c       	cp.w	r12,0
8000a116:	c0 f1       	brne	8000a134 <quorem+0xb8>
8000a118:	ec c8 ff fb 	sub	r8,r6,-5
8000a11c:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a120:	c0 28       	rjmp	8000a124 <quorem+0xa8>
8000a122:	20 16       	sub	r6,1
8000a124:	20 48       	sub	r8,4
8000a126:	08 38       	cp.w	r8,r4
8000a128:	e0 88 00 05 	brls	8000a132 <quorem+0xb6>
8000a12c:	70 09       	ld.w	r9,r8[0x0]
8000a12e:	58 09       	cp.w	r9,0
8000a130:	cf 90       	breq	8000a122 <quorem+0xa6>
8000a132:	8f 46       	st.w	r7[0x10],r6
8000a134:	0e 9c       	mov	r12,r7
8000a136:	e0 a0 0a d2 	rcall	8000b6da <__mcmp>
8000a13a:	c2 d5       	brlt	8000a194 <quorem+0x118>
8000a13c:	2f f5       	sub	r5,-1
8000a13e:	08 98       	mov	r8,r4
8000a140:	30 09       	mov	r9,0
8000a142:	07 0b       	ld.w	r11,r3++
8000a144:	f6 0a 16 10 	lsr	r10,r11,0x10
8000a148:	70 0c       	ld.w	r12,r8[0x0]
8000a14a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a14e:	f8 0e 16 10 	lsr	lr,r12,0x10
8000a152:	14 1e       	sub	lr,r10
8000a154:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000a158:	16 1a       	sub	r10,r11
8000a15a:	12 0a       	add	r10,r9
8000a15c:	b0 1a       	st.h	r8[0x2],r10
8000a15e:	b1 4a       	asr	r10,0x10
8000a160:	fc 0a 00 09 	add	r9,lr,r10
8000a164:	b0 09       	st.h	r8[0x0],r9
8000a166:	2f c8       	sub	r8,-4
8000a168:	b1 49       	asr	r9,0x10
8000a16a:	04 33       	cp.w	r3,r2
8000a16c:	fe 98 ff eb 	brls	8000a142 <quorem+0xc6>
8000a170:	ec c8 ff fb 	sub	r8,r6,-5
8000a174:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000a178:	58 09       	cp.w	r9,0
8000a17a:	c0 d1       	brne	8000a194 <quorem+0x118>
8000a17c:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a180:	c0 28       	rjmp	8000a184 <quorem+0x108>
8000a182:	20 16       	sub	r6,1
8000a184:	20 48       	sub	r8,4
8000a186:	08 38       	cp.w	r8,r4
8000a188:	e0 88 00 05 	brls	8000a192 <quorem+0x116>
8000a18c:	70 09       	ld.w	r9,r8[0x0]
8000a18e:	58 09       	cp.w	r9,0
8000a190:	cf 90       	breq	8000a182 <quorem+0x106>
8000a192:	8f 46       	st.w	r7[0x10],r6
8000a194:	0a 9c       	mov	r12,r5
8000a196:	2f ed       	sub	sp,-8
8000a198:	d8 32       	popm	r0-r7,pc
8000a19a:	d7 03       	nop

8000a19c <_dtoa_r>:
8000a19c:	d4 31       	pushm	r0-r7,lr
8000a19e:	21 ad       	sub	sp,104
8000a1a0:	fa c4 ff 74 	sub	r4,sp,-140
8000a1a4:	18 97       	mov	r7,r12
8000a1a6:	16 95       	mov	r5,r11
8000a1a8:	68 2c       	ld.w	r12,r4[0x8]
8000a1aa:	50 c9       	stdsp	sp[0x30],r9
8000a1ac:	68 16       	ld.w	r6,r4[0x4]
8000a1ae:	68 09       	ld.w	r9,r4[0x0]
8000a1b0:	50 e8       	stdsp	sp[0x38],r8
8000a1b2:	14 94       	mov	r4,r10
8000a1b4:	51 2c       	stdsp	sp[0x48],r12
8000a1b6:	fa e5 00 08 	st.d	sp[8],r4
8000a1ba:	51 59       	stdsp	sp[0x54],r9
8000a1bc:	6e 95       	ld.w	r5,r7[0x24]
8000a1be:	58 05       	cp.w	r5,0
8000a1c0:	c0 91       	brne	8000a1d2 <_dtoa_r+0x36>
8000a1c2:	31 0c       	mov	r12,16
8000a1c4:	fe b0 e8 f4 	rcall	800073ac <malloc>
8000a1c8:	99 35       	st.w	r12[0xc],r5
8000a1ca:	8f 9c       	st.w	r7[0x24],r12
8000a1cc:	99 15       	st.w	r12[0x4],r5
8000a1ce:	99 25       	st.w	r12[0x8],r5
8000a1d0:	99 05       	st.w	r12[0x0],r5
8000a1d2:	6e 99       	ld.w	r9,r7[0x24]
8000a1d4:	72 08       	ld.w	r8,r9[0x0]
8000a1d6:	58 08       	cp.w	r8,0
8000a1d8:	c0 f0       	breq	8000a1f6 <_dtoa_r+0x5a>
8000a1da:	72 1a       	ld.w	r10,r9[0x4]
8000a1dc:	91 1a       	st.w	r8[0x4],r10
8000a1de:	30 1a       	mov	r10,1
8000a1e0:	72 19       	ld.w	r9,r9[0x4]
8000a1e2:	f4 09 09 49 	lsl	r9,r10,r9
8000a1e6:	10 9b       	mov	r11,r8
8000a1e8:	91 29       	st.w	r8[0x8],r9
8000a1ea:	0e 9c       	mov	r12,r7
8000a1ec:	e0 a0 0a 90 	rcall	8000b70c <_Bfree>
8000a1f0:	6e 98       	ld.w	r8,r7[0x24]
8000a1f2:	30 09       	mov	r9,0
8000a1f4:	91 09       	st.w	r8[0x0],r9
8000a1f6:	40 28       	lddsp	r8,sp[0x8]
8000a1f8:	10 94       	mov	r4,r8
8000a1fa:	58 08       	cp.w	r8,0
8000a1fc:	c0 64       	brge	8000a208 <_dtoa_r+0x6c>
8000a1fe:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000a202:	50 28       	stdsp	sp[0x8],r8
8000a204:	30 18       	mov	r8,1
8000a206:	c0 28       	rjmp	8000a20a <_dtoa_r+0x6e>
8000a208:	30 08       	mov	r8,0
8000a20a:	8d 08       	st.w	r6[0x0],r8
8000a20c:	fc 1c 7f f0 	movh	r12,0x7ff0
8000a210:	40 26       	lddsp	r6,sp[0x8]
8000a212:	0c 98       	mov	r8,r6
8000a214:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a218:	18 38       	cp.w	r8,r12
8000a21a:	c2 01       	brne	8000a25a <_dtoa_r+0xbe>
8000a21c:	e0 68 27 0f 	mov	r8,9999
8000a220:	41 5b       	lddsp	r11,sp[0x54]
8000a222:	97 08       	st.w	r11[0x0],r8
8000a224:	40 3a       	lddsp	r10,sp[0xc]
8000a226:	58 0a       	cp.w	r10,0
8000a228:	c0 71       	brne	8000a236 <_dtoa_r+0x9a>
8000a22a:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000a22e:	c0 41       	brne	8000a236 <_dtoa_r+0x9a>
8000a230:	fe cc c1 28 	sub	r12,pc,-16088
8000a234:	c0 38       	rjmp	8000a23a <_dtoa_r+0x9e>
8000a236:	fe cc c1 22 	sub	r12,pc,-16094
8000a23a:	41 29       	lddsp	r9,sp[0x48]
8000a23c:	58 09       	cp.w	r9,0
8000a23e:	e0 80 05 9a 	breq	8000ad72 <_dtoa_r+0xbd6>
8000a242:	f8 c8 ff fd 	sub	r8,r12,-3
8000a246:	f8 c9 ff f8 	sub	r9,r12,-8
8000a24a:	11 8b       	ld.ub	r11,r8[0x0]
8000a24c:	30 0a       	mov	r10,0
8000a24e:	41 25       	lddsp	r5,sp[0x48]
8000a250:	f4 0b 18 00 	cp.b	r11,r10
8000a254:	f2 08 17 10 	movne	r8,r9
8000a258:	c1 68       	rjmp	8000a284 <_dtoa_r+0xe8>
8000a25a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a25e:	30 08       	mov	r8,0
8000a260:	fa eb 00 3c 	st.d	sp[60],r10
8000a264:	30 09       	mov	r9,0
8000a266:	e0 a0 10 ce 	rcall	8000c402 <__avr32_f64_cmp_eq>
8000a26a:	c1 00       	breq	8000a28a <_dtoa_r+0xee>
8000a26c:	30 18       	mov	r8,1
8000a26e:	41 5a       	lddsp	r10,sp[0x54]
8000a270:	95 08       	st.w	r10[0x0],r8
8000a272:	fe cc c2 8e 	sub	r12,pc,-15730
8000a276:	41 29       	lddsp	r9,sp[0x48]
8000a278:	f8 08 00 08 	add	r8,r12,r8
8000a27c:	58 09       	cp.w	r9,0
8000a27e:	e0 80 05 7a 	breq	8000ad72 <_dtoa_r+0xbd6>
8000a282:	12 95       	mov	r5,r9
8000a284:	8b 08       	st.w	r5[0x0],r8
8000a286:	e0 8f 05 76 	bral	8000ad72 <_dtoa_r+0xbd6>
8000a28a:	fa c8 ff 9c 	sub	r8,sp,-100
8000a28e:	fa c9 ff a0 	sub	r9,sp,-96
8000a292:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a296:	0e 9c       	mov	r12,r7
8000a298:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000a29c:	e0 a0 0a 8a 	rcall	8000b7b0 <__d2b>
8000a2a0:	18 93       	mov	r3,r12
8000a2a2:	58 05       	cp.w	r5,0
8000a2a4:	c0 d0       	breq	8000a2be <_dtoa_r+0x122>
8000a2a6:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a2aa:	30 04       	mov	r4,0
8000a2ac:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000a2b0:	ea c5 03 ff 	sub	r5,r5,1023
8000a2b4:	10 9b       	mov	r11,r8
8000a2b6:	51 74       	stdsp	sp[0x5c],r4
8000a2b8:	ea 1b 3f f0 	orh	r11,0x3ff0
8000a2bc:	c2 58       	rjmp	8000a306 <_dtoa_r+0x16a>
8000a2be:	41 88       	lddsp	r8,sp[0x60]
8000a2c0:	41 9c       	lddsp	r12,sp[0x64]
8000a2c2:	10 0c       	add	r12,r8
8000a2c4:	f8 c5 fb ce 	sub	r5,r12,-1074
8000a2c8:	e0 45 00 20 	cp.w	r5,32
8000a2cc:	e0 8a 00 0e 	brle	8000a2e8 <_dtoa_r+0x14c>
8000a2d0:	f8 cc fb ee 	sub	r12,r12,-1042
8000a2d4:	40 3b       	lddsp	r11,sp[0xc]
8000a2d6:	ea 08 11 40 	rsub	r8,r5,64
8000a2da:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000a2de:	ec 08 09 46 	lsl	r6,r6,r8
8000a2e2:	0c 4c       	or	r12,r6
8000a2e4:	c0 78       	rjmp	8000a2f2 <_dtoa_r+0x156>
8000a2e6:	d7 03       	nop
8000a2e8:	ea 0c 11 20 	rsub	r12,r5,32
8000a2ec:	40 3a       	lddsp	r10,sp[0xc]
8000a2ee:	f4 0c 09 4c 	lsl	r12,r10,r12
8000a2f2:	e0 a0 10 14 	rcall	8000c31a <__avr32_u32_to_f64>
8000a2f6:	fc 18 fe 10 	movh	r8,0xfe10
8000a2fa:	30 19       	mov	r9,1
8000a2fc:	ea c5 04 33 	sub	r5,r5,1075
8000a300:	f0 0b 00 0b 	add	r11,r8,r11
8000a304:	51 79       	stdsp	sp[0x5c],r9
8000a306:	30 08       	mov	r8,0
8000a308:	fc 19 3f f8 	movh	r9,0x3ff8
8000a30c:	e0 a0 0e 9c 	rcall	8000c044 <__avr32_f64_sub>
8000a310:	e0 68 43 61 	mov	r8,17249
8000a314:	ea 18 63 6f 	orh	r8,0x636f
8000a318:	e0 69 87 a7 	mov	r9,34727
8000a31c:	ea 19 3f d2 	orh	r9,0x3fd2
8000a320:	e0 a0 0d a6 	rcall	8000be6c <__avr32_f64_mul>
8000a324:	e0 68 c8 b3 	mov	r8,51379
8000a328:	ea 18 8b 60 	orh	r8,0x8b60
8000a32c:	e0 69 8a 28 	mov	r9,35368
8000a330:	ea 19 3f c6 	orh	r9,0x3fc6
8000a334:	e0 a0 0f 56 	rcall	8000c1e0 <__avr32_f64_add>
8000a338:	0a 9c       	mov	r12,r5
8000a33a:	14 90       	mov	r0,r10
8000a33c:	16 91       	mov	r1,r11
8000a33e:	e0 a0 0f f2 	rcall	8000c322 <__avr32_s32_to_f64>
8000a342:	e0 68 79 fb 	mov	r8,31227
8000a346:	ea 18 50 9f 	orh	r8,0x509f
8000a34a:	e0 69 44 13 	mov	r9,17427
8000a34e:	ea 19 3f d3 	orh	r9,0x3fd3
8000a352:	e0 a0 0d 8d 	rcall	8000be6c <__avr32_f64_mul>
8000a356:	14 98       	mov	r8,r10
8000a358:	16 99       	mov	r9,r11
8000a35a:	00 9a       	mov	r10,r0
8000a35c:	02 9b       	mov	r11,r1
8000a35e:	e0 a0 0f 41 	rcall	8000c1e0 <__avr32_f64_add>
8000a362:	14 90       	mov	r0,r10
8000a364:	16 91       	mov	r1,r11
8000a366:	e0 a0 0f c7 	rcall	8000c2f4 <__avr32_f64_to_s32>
8000a36a:	30 08       	mov	r8,0
8000a36c:	18 96       	mov	r6,r12
8000a36e:	30 09       	mov	r9,0
8000a370:	00 9a       	mov	r10,r0
8000a372:	02 9b       	mov	r11,r1
8000a374:	e0 a0 10 8e 	rcall	8000c490 <__avr32_f64_cmp_lt>
8000a378:	c0 c0       	breq	8000a390 <_dtoa_r+0x1f4>
8000a37a:	0c 9c       	mov	r12,r6
8000a37c:	e0 a0 0f d3 	rcall	8000c322 <__avr32_s32_to_f64>
8000a380:	14 98       	mov	r8,r10
8000a382:	16 99       	mov	r9,r11
8000a384:	00 9a       	mov	r10,r0
8000a386:	02 9b       	mov	r11,r1
8000a388:	e0 a0 10 3d 	rcall	8000c402 <__avr32_f64_cmp_eq>
8000a38c:	f7 b6 00 01 	subeq	r6,1
8000a390:	59 66       	cp.w	r6,22
8000a392:	e0 88 00 05 	brls	8000a39c <_dtoa_r+0x200>
8000a396:	30 18       	mov	r8,1
8000a398:	51 48       	stdsp	sp[0x50],r8
8000a39a:	c1 38       	rjmp	8000a3c0 <_dtoa_r+0x224>
8000a39c:	fe c8 c1 d4 	sub	r8,pc,-15916
8000a3a0:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a3a4:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a3a8:	e0 a0 10 74 	rcall	8000c490 <__avr32_f64_cmp_lt>
8000a3ac:	f9 b4 00 00 	moveq	r4,0
8000a3b0:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a3b4:	f7 b6 01 01 	subne	r6,1
8000a3b8:	f9 bc 01 00 	movne	r12,0
8000a3bc:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a3c0:	41 90       	lddsp	r0,sp[0x64]
8000a3c2:	20 10       	sub	r0,1
8000a3c4:	0a 10       	sub	r0,r5
8000a3c6:	c0 46       	brmi	8000a3ce <_dtoa_r+0x232>
8000a3c8:	50 40       	stdsp	sp[0x10],r0
8000a3ca:	30 00       	mov	r0,0
8000a3cc:	c0 48       	rjmp	8000a3d4 <_dtoa_r+0x238>
8000a3ce:	30 0b       	mov	r11,0
8000a3d0:	5c 30       	neg	r0
8000a3d2:	50 4b       	stdsp	sp[0x10],r11
8000a3d4:	ec 02 11 00 	rsub	r2,r6,0
8000a3d8:	58 06       	cp.w	r6,0
8000a3da:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a3de:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a3e2:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a3e6:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a3ea:	f9 b2 04 00 	movge	r2,0
8000a3ee:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a3f2:	f9 b9 05 00 	movlt	r9,0
8000a3f6:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a3fa:	40 c8       	lddsp	r8,sp[0x30]
8000a3fc:	58 98       	cp.w	r8,9
8000a3fe:	e0 8b 00 20 	brhi	8000a43e <_dtoa_r+0x2a2>
8000a402:	58 58       	cp.w	r8,5
8000a404:	f9 b4 0a 01 	movle	r4,1
8000a408:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a40c:	f7 b5 09 04 	subgt	r5,4
8000a410:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a414:	f9 b4 09 00 	movgt	r4,0
8000a418:	40 cc       	lddsp	r12,sp[0x30]
8000a41a:	58 3c       	cp.w	r12,3
8000a41c:	c2 d0       	breq	8000a476 <_dtoa_r+0x2da>
8000a41e:	e0 89 00 05 	brgt	8000a428 <_dtoa_r+0x28c>
8000a422:	58 2c       	cp.w	r12,2
8000a424:	c1 01       	brne	8000a444 <_dtoa_r+0x2a8>
8000a426:	c1 88       	rjmp	8000a456 <_dtoa_r+0x2ba>
8000a428:	40 cb       	lddsp	r11,sp[0x30]
8000a42a:	58 4b       	cp.w	r11,4
8000a42c:	c0 60       	breq	8000a438 <_dtoa_r+0x29c>
8000a42e:	58 5b       	cp.w	r11,5
8000a430:	c0 a1       	brne	8000a444 <_dtoa_r+0x2a8>
8000a432:	30 1a       	mov	r10,1
8000a434:	50 da       	stdsp	sp[0x34],r10
8000a436:	c2 28       	rjmp	8000a47a <_dtoa_r+0x2de>
8000a438:	30 19       	mov	r9,1
8000a43a:	50 d9       	stdsp	sp[0x34],r9
8000a43c:	c0 f8       	rjmp	8000a45a <_dtoa_r+0x2be>
8000a43e:	30 08       	mov	r8,0
8000a440:	30 14       	mov	r4,1
8000a442:	50 c8       	stdsp	sp[0x30],r8
8000a444:	3f f5       	mov	r5,-1
8000a446:	30 1c       	mov	r12,1
8000a448:	30 0b       	mov	r11,0
8000a44a:	50 95       	stdsp	sp[0x24],r5
8000a44c:	50 dc       	stdsp	sp[0x34],r12
8000a44e:	0a 91       	mov	r1,r5
8000a450:	31 28       	mov	r8,18
8000a452:	50 eb       	stdsp	sp[0x38],r11
8000a454:	c2 08       	rjmp	8000a494 <_dtoa_r+0x2f8>
8000a456:	30 0a       	mov	r10,0
8000a458:	50 da       	stdsp	sp[0x34],r10
8000a45a:	40 e9       	lddsp	r9,sp[0x38]
8000a45c:	58 09       	cp.w	r9,0
8000a45e:	e0 89 00 07 	brgt	8000a46c <_dtoa_r+0x2d0>
8000a462:	30 18       	mov	r8,1
8000a464:	50 98       	stdsp	sp[0x24],r8
8000a466:	10 91       	mov	r1,r8
8000a468:	50 e8       	stdsp	sp[0x38],r8
8000a46a:	c1 58       	rjmp	8000a494 <_dtoa_r+0x2f8>
8000a46c:	40 e5       	lddsp	r5,sp[0x38]
8000a46e:	50 95       	stdsp	sp[0x24],r5
8000a470:	0a 91       	mov	r1,r5
8000a472:	0a 98       	mov	r8,r5
8000a474:	c1 08       	rjmp	8000a494 <_dtoa_r+0x2f8>
8000a476:	30 0c       	mov	r12,0
8000a478:	50 dc       	stdsp	sp[0x34],r12
8000a47a:	40 eb       	lddsp	r11,sp[0x38]
8000a47c:	ec 0b 00 0b 	add	r11,r6,r11
8000a480:	50 9b       	stdsp	sp[0x24],r11
8000a482:	16 98       	mov	r8,r11
8000a484:	2f f8       	sub	r8,-1
8000a486:	58 08       	cp.w	r8,0
8000a488:	e0 89 00 05 	brgt	8000a492 <_dtoa_r+0x2f6>
8000a48c:	10 91       	mov	r1,r8
8000a48e:	30 18       	mov	r8,1
8000a490:	c0 28       	rjmp	8000a494 <_dtoa_r+0x2f8>
8000a492:	10 91       	mov	r1,r8
8000a494:	30 09       	mov	r9,0
8000a496:	6e 9a       	ld.w	r10,r7[0x24]
8000a498:	95 19       	st.w	r10[0x4],r9
8000a49a:	30 49       	mov	r9,4
8000a49c:	c0 68       	rjmp	8000a4a8 <_dtoa_r+0x30c>
8000a49e:	d7 03       	nop
8000a4a0:	6a 1a       	ld.w	r10,r5[0x4]
8000a4a2:	a1 79       	lsl	r9,0x1
8000a4a4:	2f fa       	sub	r10,-1
8000a4a6:	8b 1a       	st.w	r5[0x4],r10
8000a4a8:	6e 95       	ld.w	r5,r7[0x24]
8000a4aa:	f2 ca ff ec 	sub	r10,r9,-20
8000a4ae:	10 3a       	cp.w	r10,r8
8000a4b0:	fe 98 ff f8 	brls	8000a4a0 <_dtoa_r+0x304>
8000a4b4:	6a 1b       	ld.w	r11,r5[0x4]
8000a4b6:	0e 9c       	mov	r12,r7
8000a4b8:	e0 a0 09 44 	rcall	8000b740 <_Balloc>
8000a4bc:	58 e1       	cp.w	r1,14
8000a4be:	5f 88       	srls	r8
8000a4c0:	8b 0c       	st.w	r5[0x0],r12
8000a4c2:	f1 e4 00 04 	and	r4,r8,r4
8000a4c6:	6e 98       	ld.w	r8,r7[0x24]
8000a4c8:	70 08       	ld.w	r8,r8[0x0]
8000a4ca:	50 88       	stdsp	sp[0x20],r8
8000a4cc:	e0 80 01 82 	breq	8000a7d0 <_dtoa_r+0x634>
8000a4d0:	58 06       	cp.w	r6,0
8000a4d2:	e0 8a 00 43 	brle	8000a558 <_dtoa_r+0x3bc>
8000a4d6:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a4da:	fe c8 c3 12 	sub	r8,pc,-15598
8000a4de:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a4e2:	fa e5 00 18 	st.d	sp[24],r4
8000a4e6:	ec 04 14 04 	asr	r4,r6,0x4
8000a4ea:	ed b4 00 04 	bld	r4,0x4
8000a4ee:	c0 30       	breq	8000a4f4 <_dtoa_r+0x358>
8000a4f0:	30 25       	mov	r5,2
8000a4f2:	c1 08       	rjmp	8000a512 <_dtoa_r+0x376>
8000a4f4:	fe c8 c2 64 	sub	r8,pc,-15772
8000a4f8:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a4fc:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a500:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a504:	e0 a0 0f fa 	rcall	8000c4f8 <__avr32_f64_div>
8000a508:	30 35       	mov	r5,3
8000a50a:	14 98       	mov	r8,r10
8000a50c:	16 99       	mov	r9,r11
8000a50e:	fa e9 00 08 	st.d	sp[8],r8
8000a512:	fe cc c2 82 	sub	r12,pc,-15742
8000a516:	50 a3       	stdsp	sp[0x28],r3
8000a518:	0c 93       	mov	r3,r6
8000a51a:	18 96       	mov	r6,r12
8000a51c:	c0 f8       	rjmp	8000a53a <_dtoa_r+0x39e>
8000a51e:	fa ea 00 18 	ld.d	r10,sp[24]
8000a522:	ed b4 00 00 	bld	r4,0x0
8000a526:	c0 81       	brne	8000a536 <_dtoa_r+0x39a>
8000a528:	ec e8 00 00 	ld.d	r8,r6[0]
8000a52c:	2f f5       	sub	r5,-1
8000a52e:	e0 a0 0c 9f 	rcall	8000be6c <__avr32_f64_mul>
8000a532:	fa eb 00 18 	st.d	sp[24],r10
8000a536:	a1 54       	asr	r4,0x1
8000a538:	2f 86       	sub	r6,-8
8000a53a:	58 04       	cp.w	r4,0
8000a53c:	cf 11       	brne	8000a51e <_dtoa_r+0x382>
8000a53e:	fa e8 00 18 	ld.d	r8,sp[24]
8000a542:	fa ea 00 08 	ld.d	r10,sp[8]
8000a546:	06 96       	mov	r6,r3
8000a548:	e0 a0 0f d8 	rcall	8000c4f8 <__avr32_f64_div>
8000a54c:	40 a3       	lddsp	r3,sp[0x28]
8000a54e:	14 98       	mov	r8,r10
8000a550:	16 99       	mov	r9,r11
8000a552:	fa e9 00 08 	st.d	sp[8],r8
8000a556:	c2 f8       	rjmp	8000a5b4 <_dtoa_r+0x418>
8000a558:	ec 08 11 00 	rsub	r8,r6,0
8000a55c:	c0 31       	brne	8000a562 <_dtoa_r+0x3c6>
8000a55e:	30 25       	mov	r5,2
8000a560:	c2 a8       	rjmp	8000a5b4 <_dtoa_r+0x418>
8000a562:	fe cc c2 d2 	sub	r12,pc,-15662
8000a566:	f0 04 14 04 	asr	r4,r8,0x4
8000a56a:	50 1c       	stdsp	sp[0x4],r12
8000a56c:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a570:	fe c9 c3 a8 	sub	r9,pc,-15448
8000a574:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a578:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a57c:	e0 a0 0c 78 	rcall	8000be6c <__avr32_f64_mul>
8000a580:	40 1c       	lddsp	r12,sp[0x4]
8000a582:	50 63       	stdsp	sp[0x18],r3
8000a584:	30 25       	mov	r5,2
8000a586:	0c 93       	mov	r3,r6
8000a588:	fa eb 00 08 	st.d	sp[8],r10
8000a58c:	18 96       	mov	r6,r12
8000a58e:	c0 f8       	rjmp	8000a5ac <_dtoa_r+0x410>
8000a590:	fa ea 00 08 	ld.d	r10,sp[8]
8000a594:	ed b4 00 00 	bld	r4,0x0
8000a598:	c0 81       	brne	8000a5a8 <_dtoa_r+0x40c>
8000a59a:	ec e8 00 00 	ld.d	r8,r6[0]
8000a59e:	2f f5       	sub	r5,-1
8000a5a0:	e0 a0 0c 66 	rcall	8000be6c <__avr32_f64_mul>
8000a5a4:	fa eb 00 08 	st.d	sp[8],r10
8000a5a8:	a1 54       	asr	r4,0x1
8000a5aa:	2f 86       	sub	r6,-8
8000a5ac:	58 04       	cp.w	r4,0
8000a5ae:	cf 11       	brne	8000a590 <_dtoa_r+0x3f4>
8000a5b0:	06 96       	mov	r6,r3
8000a5b2:	40 63       	lddsp	r3,sp[0x18]
8000a5b4:	41 4a       	lddsp	r10,sp[0x50]
8000a5b6:	58 0a       	cp.w	r10,0
8000a5b8:	c2 a0       	breq	8000a60c <_dtoa_r+0x470>
8000a5ba:	fa e8 00 08 	ld.d	r8,sp[8]
8000a5be:	58 01       	cp.w	r1,0
8000a5c0:	5f 94       	srgt	r4
8000a5c2:	fa e9 00 18 	st.d	sp[24],r8
8000a5c6:	30 08       	mov	r8,0
8000a5c8:	fc 19 3f f0 	movh	r9,0x3ff0
8000a5cc:	fa ea 00 18 	ld.d	r10,sp[24]
8000a5d0:	e0 a0 0f 60 	rcall	8000c490 <__avr32_f64_cmp_lt>
8000a5d4:	f9 bc 00 00 	moveq	r12,0
8000a5d8:	f9 bc 01 01 	movne	r12,1
8000a5dc:	e9 ec 00 0c 	and	r12,r4,r12
8000a5e0:	c1 60       	breq	8000a60c <_dtoa_r+0x470>
8000a5e2:	40 98       	lddsp	r8,sp[0x24]
8000a5e4:	58 08       	cp.w	r8,0
8000a5e6:	e0 8a 00 f1 	brle	8000a7c8 <_dtoa_r+0x62c>
8000a5ea:	30 08       	mov	r8,0
8000a5ec:	fc 19 40 24 	movh	r9,0x4024
8000a5f0:	ec c4 00 01 	sub	r4,r6,1
8000a5f4:	fa ea 00 18 	ld.d	r10,sp[24]
8000a5f8:	2f f5       	sub	r5,-1
8000a5fa:	50 64       	stdsp	sp[0x18],r4
8000a5fc:	e0 a0 0c 38 	rcall	8000be6c <__avr32_f64_mul>
8000a600:	40 94       	lddsp	r4,sp[0x24]
8000a602:	14 98       	mov	r8,r10
8000a604:	16 99       	mov	r9,r11
8000a606:	fa e9 00 08 	st.d	sp[8],r8
8000a60a:	c0 38       	rjmp	8000a610 <_dtoa_r+0x474>
8000a60c:	50 66       	stdsp	sp[0x18],r6
8000a60e:	02 94       	mov	r4,r1
8000a610:	0a 9c       	mov	r12,r5
8000a612:	e0 a0 0e 88 	rcall	8000c322 <__avr32_s32_to_f64>
8000a616:	fa e8 00 08 	ld.d	r8,sp[8]
8000a61a:	e0 a0 0c 29 	rcall	8000be6c <__avr32_f64_mul>
8000a61e:	30 08       	mov	r8,0
8000a620:	fc 19 40 1c 	movh	r9,0x401c
8000a624:	e0 a0 0d de 	rcall	8000c1e0 <__avr32_f64_add>
8000a628:	14 98       	mov	r8,r10
8000a62a:	16 99       	mov	r9,r11
8000a62c:	fa e9 00 28 	st.d	sp[40],r8
8000a630:	fc 18 fc c0 	movh	r8,0xfcc0
8000a634:	40 a5       	lddsp	r5,sp[0x28]
8000a636:	10 05       	add	r5,r8
8000a638:	50 a5       	stdsp	sp[0x28],r5
8000a63a:	58 04       	cp.w	r4,0
8000a63c:	c2 11       	brne	8000a67e <_dtoa_r+0x4e2>
8000a63e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a642:	30 08       	mov	r8,0
8000a644:	fc 19 40 14 	movh	r9,0x4014
8000a648:	e0 a0 0c fe 	rcall	8000c044 <__avr32_f64_sub>
8000a64c:	40 bc       	lddsp	r12,sp[0x2c]
8000a64e:	fa eb 00 08 	st.d	sp[8],r10
8000a652:	14 98       	mov	r8,r10
8000a654:	16 99       	mov	r9,r11
8000a656:	18 9a       	mov	r10,r12
8000a658:	0a 9b       	mov	r11,r5
8000a65a:	e0 a0 0f 1b 	rcall	8000c490 <__avr32_f64_cmp_lt>
8000a65e:	e0 81 02 54 	brne	8000ab06 <_dtoa_r+0x96a>
8000a662:	0a 98       	mov	r8,r5
8000a664:	40 b9       	lddsp	r9,sp[0x2c]
8000a666:	ee 18 80 00 	eorh	r8,0x8000
8000a66a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a66e:	10 95       	mov	r5,r8
8000a670:	12 98       	mov	r8,r9
8000a672:	0a 99       	mov	r9,r5
8000a674:	e0 a0 0f 0e 	rcall	8000c490 <__avr32_f64_cmp_lt>
8000a678:	e0 81 02 3e 	brne	8000aaf4 <_dtoa_r+0x958>
8000a67c:	ca 68       	rjmp	8000a7c8 <_dtoa_r+0x62c>
8000a67e:	fe c9 c4 b6 	sub	r9,pc,-15178
8000a682:	e8 c8 00 01 	sub	r8,r4,1
8000a686:	40 d5       	lddsp	r5,sp[0x34]
8000a688:	58 05       	cp.w	r5,0
8000a68a:	c4 f0       	breq	8000a728 <_dtoa_r+0x58c>
8000a68c:	30 0c       	mov	r12,0
8000a68e:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a692:	51 3c       	stdsp	sp[0x4c],r12
8000a694:	30 0a       	mov	r10,0
8000a696:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a69a:	e0 a0 0f 2f 	rcall	8000c4f8 <__avr32_f64_div>
8000a69e:	fa e8 00 28 	ld.d	r8,sp[40]
8000a6a2:	40 85       	lddsp	r5,sp[0x20]
8000a6a4:	e0 a0 0c d0 	rcall	8000c044 <__avr32_f64_sub>
8000a6a8:	fa eb 00 28 	st.d	sp[40],r10
8000a6ac:	fa ea 00 08 	ld.d	r10,sp[8]
8000a6b0:	e0 a0 0e 22 	rcall	8000c2f4 <__avr32_f64_to_s32>
8000a6b4:	51 6c       	stdsp	sp[0x58],r12
8000a6b6:	e0 a0 0e 36 	rcall	8000c322 <__avr32_s32_to_f64>
8000a6ba:	14 98       	mov	r8,r10
8000a6bc:	16 99       	mov	r9,r11
8000a6be:	fa ea 00 08 	ld.d	r10,sp[8]
8000a6c2:	e0 a0 0c c1 	rcall	8000c044 <__avr32_f64_sub>
8000a6c6:	fa eb 00 08 	st.d	sp[8],r10
8000a6ca:	41 68       	lddsp	r8,sp[0x58]
8000a6cc:	2d 08       	sub	r8,-48
8000a6ce:	0a c8       	st.b	r5++,r8
8000a6d0:	41 39       	lddsp	r9,sp[0x4c]
8000a6d2:	2f f9       	sub	r9,-1
8000a6d4:	51 39       	stdsp	sp[0x4c],r9
8000a6d6:	fa e8 00 28 	ld.d	r8,sp[40]
8000a6da:	e0 a0 0e db 	rcall	8000c490 <__avr32_f64_cmp_lt>
8000a6de:	e0 81 03 39 	brne	8000ad50 <_dtoa_r+0xbb4>
8000a6e2:	fa e8 00 08 	ld.d	r8,sp[8]
8000a6e6:	30 0a       	mov	r10,0
8000a6e8:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a6ec:	e0 a0 0c ac 	rcall	8000c044 <__avr32_f64_sub>
8000a6f0:	fa e8 00 28 	ld.d	r8,sp[40]
8000a6f4:	e0 a0 0e ce 	rcall	8000c490 <__avr32_f64_cmp_lt>
8000a6f8:	fa ea 00 28 	ld.d	r10,sp[40]
8000a6fc:	30 08       	mov	r8,0
8000a6fe:	fc 19 40 24 	movh	r9,0x4024
8000a702:	e0 81 00 da 	brne	8000a8b6 <_dtoa_r+0x71a>
8000a706:	41 3c       	lddsp	r12,sp[0x4c]
8000a708:	08 3c       	cp.w	r12,r4
8000a70a:	c5 f4       	brge	8000a7c8 <_dtoa_r+0x62c>
8000a70c:	e0 a0 0b b0 	rcall	8000be6c <__avr32_f64_mul>
8000a710:	30 08       	mov	r8,0
8000a712:	fa eb 00 28 	st.d	sp[40],r10
8000a716:	fc 19 40 24 	movh	r9,0x4024
8000a71a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a71e:	e0 a0 0b a7 	rcall	8000be6c <__avr32_f64_mul>
8000a722:	fa eb 00 08 	st.d	sp[8],r10
8000a726:	cc 3b       	rjmp	8000a6ac <_dtoa_r+0x510>
8000a728:	40 85       	lddsp	r5,sp[0x20]
8000a72a:	08 05       	add	r5,r4
8000a72c:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a730:	51 35       	stdsp	sp[0x4c],r5
8000a732:	fa e8 00 28 	ld.d	r8,sp[40]
8000a736:	40 85       	lddsp	r5,sp[0x20]
8000a738:	e0 a0 0b 9a 	rcall	8000be6c <__avr32_f64_mul>
8000a73c:	fa eb 00 28 	st.d	sp[40],r10
8000a740:	fa ea 00 08 	ld.d	r10,sp[8]
8000a744:	e0 a0 0d d8 	rcall	8000c2f4 <__avr32_f64_to_s32>
8000a748:	51 6c       	stdsp	sp[0x58],r12
8000a74a:	e0 a0 0d ec 	rcall	8000c322 <__avr32_s32_to_f64>
8000a74e:	14 98       	mov	r8,r10
8000a750:	16 99       	mov	r9,r11
8000a752:	fa ea 00 08 	ld.d	r10,sp[8]
8000a756:	e0 a0 0c 77 	rcall	8000c044 <__avr32_f64_sub>
8000a75a:	fa eb 00 08 	st.d	sp[8],r10
8000a75e:	41 68       	lddsp	r8,sp[0x58]
8000a760:	2d 08       	sub	r8,-48
8000a762:	0a c8       	st.b	r5++,r8
8000a764:	41 3c       	lddsp	r12,sp[0x4c]
8000a766:	18 35       	cp.w	r5,r12
8000a768:	c2 81       	brne	8000a7b8 <_dtoa_r+0x61c>
8000a76a:	30 08       	mov	r8,0
8000a76c:	fc 19 3f e0 	movh	r9,0x3fe0
8000a770:	fa ea 00 28 	ld.d	r10,sp[40]
8000a774:	e0 a0 0d 36 	rcall	8000c1e0 <__avr32_f64_add>
8000a778:	40 85       	lddsp	r5,sp[0x20]
8000a77a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a77e:	08 05       	add	r5,r4
8000a780:	e0 a0 0e 88 	rcall	8000c490 <__avr32_f64_cmp_lt>
8000a784:	e0 81 00 99 	brne	8000a8b6 <_dtoa_r+0x71a>
8000a788:	fa e8 00 28 	ld.d	r8,sp[40]
8000a78c:	30 0a       	mov	r10,0
8000a78e:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a792:	e0 a0 0c 59 	rcall	8000c044 <__avr32_f64_sub>
8000a796:	14 98       	mov	r8,r10
8000a798:	16 99       	mov	r9,r11
8000a79a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a79e:	e0 a0 0e 79 	rcall	8000c490 <__avr32_f64_cmp_lt>
8000a7a2:	c1 30       	breq	8000a7c8 <_dtoa_r+0x62c>
8000a7a4:	33 09       	mov	r9,48
8000a7a6:	0a 98       	mov	r8,r5
8000a7a8:	11 7a       	ld.ub	r10,--r8
8000a7aa:	f2 0a 18 00 	cp.b	r10,r9
8000a7ae:	e0 81 02 d1 	brne	8000ad50 <_dtoa_r+0xbb4>
8000a7b2:	10 95       	mov	r5,r8
8000a7b4:	cf 9b       	rjmp	8000a7a6 <_dtoa_r+0x60a>
8000a7b6:	d7 03       	nop
8000a7b8:	30 08       	mov	r8,0
8000a7ba:	fc 19 40 24 	movh	r9,0x4024
8000a7be:	e0 a0 0b 57 	rcall	8000be6c <__avr32_f64_mul>
8000a7c2:	fa eb 00 08 	st.d	sp[8],r10
8000a7c6:	cb db       	rjmp	8000a740 <_dtoa_r+0x5a4>
8000a7c8:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a7cc:	fa eb 00 08 	st.d	sp[8],r10
8000a7d0:	58 e6       	cp.w	r6,14
8000a7d2:	5f ab       	srle	r11
8000a7d4:	41 8a       	lddsp	r10,sp[0x60]
8000a7d6:	30 08       	mov	r8,0
8000a7d8:	f4 09 11 ff 	rsub	r9,r10,-1
8000a7dc:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a7e0:	f0 09 18 00 	cp.b	r9,r8
8000a7e4:	e0 80 00 82 	breq	8000a8e8 <_dtoa_r+0x74c>
8000a7e8:	40 ea       	lddsp	r10,sp[0x38]
8000a7ea:	58 01       	cp.w	r1,0
8000a7ec:	5f a9       	srle	r9
8000a7ee:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a7f2:	fe ca c6 2a 	sub	r10,pc,-14806
8000a7f6:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a7fa:	fa e5 00 10 	st.d	sp[16],r4
8000a7fe:	f0 09 18 00 	cp.b	r9,r8
8000a802:	c1 40       	breq	8000a82a <_dtoa_r+0x68e>
8000a804:	58 01       	cp.w	r1,0
8000a806:	e0 81 01 77 	brne	8000aaf4 <_dtoa_r+0x958>
8000a80a:	30 08       	mov	r8,0
8000a80c:	fc 19 40 14 	movh	r9,0x4014
8000a810:	08 9a       	mov	r10,r4
8000a812:	0a 9b       	mov	r11,r5
8000a814:	e0 a0 0b 2c 	rcall	8000be6c <__avr32_f64_mul>
8000a818:	fa e8 00 08 	ld.d	r8,sp[8]
8000a81c:	e0 a0 0e 06 	rcall	8000c428 <__avr32_f64_cmp_ge>
8000a820:	e0 81 01 6a 	brne	8000aaf4 <_dtoa_r+0x958>
8000a824:	02 92       	mov	r2,r1
8000a826:	e0 8f 01 72 	bral	8000ab0a <_dtoa_r+0x96e>
8000a82a:	40 85       	lddsp	r5,sp[0x20]
8000a82c:	30 14       	mov	r4,1
8000a82e:	fa e8 00 10 	ld.d	r8,sp[16]
8000a832:	fa ea 00 08 	ld.d	r10,sp[8]
8000a836:	e0 a0 0e 61 	rcall	8000c4f8 <__avr32_f64_div>
8000a83a:	e0 a0 0d 5d 	rcall	8000c2f4 <__avr32_f64_to_s32>
8000a83e:	18 92       	mov	r2,r12
8000a840:	e0 a0 0d 71 	rcall	8000c322 <__avr32_s32_to_f64>
8000a844:	fa e8 00 10 	ld.d	r8,sp[16]
8000a848:	e0 a0 0b 12 	rcall	8000be6c <__avr32_f64_mul>
8000a84c:	14 98       	mov	r8,r10
8000a84e:	16 99       	mov	r9,r11
8000a850:	fa ea 00 08 	ld.d	r10,sp[8]
8000a854:	e0 a0 0b f8 	rcall	8000c044 <__avr32_f64_sub>
8000a858:	fa eb 00 08 	st.d	sp[8],r10
8000a85c:	e4 c8 ff d0 	sub	r8,r2,-48
8000a860:	0a c8       	st.b	r5++,r8
8000a862:	fc 19 40 24 	movh	r9,0x4024
8000a866:	30 08       	mov	r8,0
8000a868:	02 34       	cp.w	r4,r1
8000a86a:	c3 31       	brne	8000a8d0 <_dtoa_r+0x734>
8000a86c:	fa e8 00 08 	ld.d	r8,sp[8]
8000a870:	e0 a0 0c b8 	rcall	8000c1e0 <__avr32_f64_add>
8000a874:	16 91       	mov	r1,r11
8000a876:	14 90       	mov	r0,r10
8000a878:	14 98       	mov	r8,r10
8000a87a:	02 99       	mov	r9,r1
8000a87c:	fa ea 00 10 	ld.d	r10,sp[16]
8000a880:	e0 a0 0e 08 	rcall	8000c490 <__avr32_f64_cmp_lt>
8000a884:	c1 a1       	brne	8000a8b8 <_dtoa_r+0x71c>
8000a886:	fa e8 00 10 	ld.d	r8,sp[16]
8000a88a:	00 9a       	mov	r10,r0
8000a88c:	02 9b       	mov	r11,r1
8000a88e:	e0 a0 0d ba 	rcall	8000c402 <__avr32_f64_cmp_eq>
8000a892:	e0 80 02 5e 	breq	8000ad4e <_dtoa_r+0xbb2>
8000a896:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a89a:	c0 f1       	brne	8000a8b8 <_dtoa_r+0x71c>
8000a89c:	e0 8f 02 59 	bral	8000ad4e <_dtoa_r+0xbb2>
8000a8a0:	40 8a       	lddsp	r10,sp[0x20]
8000a8a2:	14 38       	cp.w	r8,r10
8000a8a4:	c0 30       	breq	8000a8aa <_dtoa_r+0x70e>
8000a8a6:	10 95       	mov	r5,r8
8000a8a8:	c0 98       	rjmp	8000a8ba <_dtoa_r+0x71e>
8000a8aa:	33 08       	mov	r8,48
8000a8ac:	40 89       	lddsp	r9,sp[0x20]
8000a8ae:	2f f6       	sub	r6,-1
8000a8b0:	b2 88       	st.b	r9[0x0],r8
8000a8b2:	40 88       	lddsp	r8,sp[0x20]
8000a8b4:	c0 88       	rjmp	8000a8c4 <_dtoa_r+0x728>
8000a8b6:	40 66       	lddsp	r6,sp[0x18]
8000a8b8:	33 99       	mov	r9,57
8000a8ba:	0a 98       	mov	r8,r5
8000a8bc:	11 7a       	ld.ub	r10,--r8
8000a8be:	f2 0a 18 00 	cp.b	r10,r9
8000a8c2:	ce f0       	breq	8000a8a0 <_dtoa_r+0x704>
8000a8c4:	50 66       	stdsp	sp[0x18],r6
8000a8c6:	11 89       	ld.ub	r9,r8[0x0]
8000a8c8:	2f f9       	sub	r9,-1
8000a8ca:	b0 89       	st.b	r8[0x0],r9
8000a8cc:	e0 8f 02 42 	bral	8000ad50 <_dtoa_r+0xbb4>
8000a8d0:	e0 a0 0a ce 	rcall	8000be6c <__avr32_f64_mul>
8000a8d4:	2f f4       	sub	r4,-1
8000a8d6:	fa eb 00 08 	st.d	sp[8],r10
8000a8da:	30 08       	mov	r8,0
8000a8dc:	30 09       	mov	r9,0
8000a8de:	e0 a0 0d 92 	rcall	8000c402 <__avr32_f64_cmp_eq>
8000a8e2:	ca 60       	breq	8000a82e <_dtoa_r+0x692>
8000a8e4:	e0 8f 02 35 	bral	8000ad4e <_dtoa_r+0xbb2>
8000a8e8:	40 d8       	lddsp	r8,sp[0x34]
8000a8ea:	58 08       	cp.w	r8,0
8000a8ec:	c0 51       	brne	8000a8f6 <_dtoa_r+0x75a>
8000a8ee:	04 98       	mov	r8,r2
8000a8f0:	00 95       	mov	r5,r0
8000a8f2:	40 d4       	lddsp	r4,sp[0x34]
8000a8f4:	c3 78       	rjmp	8000a962 <_dtoa_r+0x7c6>
8000a8f6:	40 c5       	lddsp	r5,sp[0x30]
8000a8f8:	58 15       	cp.w	r5,1
8000a8fa:	e0 89 00 0f 	brgt	8000a918 <_dtoa_r+0x77c>
8000a8fe:	41 74       	lddsp	r4,sp[0x5c]
8000a900:	58 04       	cp.w	r4,0
8000a902:	c0 40       	breq	8000a90a <_dtoa_r+0x76e>
8000a904:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a908:	c0 48       	rjmp	8000a910 <_dtoa_r+0x774>
8000a90a:	41 99       	lddsp	r9,sp[0x64]
8000a90c:	f2 09 11 36 	rsub	r9,r9,54
8000a910:	04 98       	mov	r8,r2
8000a912:	00 95       	mov	r5,r0
8000a914:	c1 c8       	rjmp	8000a94c <_dtoa_r+0x7b0>
8000a916:	d7 03       	nop
8000a918:	e2 c8 00 01 	sub	r8,r1,1
8000a91c:	58 01       	cp.w	r1,0
8000a91e:	e0 05 17 40 	movge	r5,r0
8000a922:	e2 09 17 40 	movge	r9,r1
8000a926:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a92a:	f9 b9 05 00 	movlt	r9,0
8000a92e:	10 32       	cp.w	r2,r8
8000a930:	e5 d8 e4 18 	subge	r8,r2,r8
8000a934:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a938:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a93c:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a940:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a944:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a948:	f9 b8 05 00 	movlt	r8,0
8000a94c:	40 4b       	lddsp	r11,sp[0x10]
8000a94e:	12 0b       	add	r11,r9
8000a950:	50 08       	stdsp	sp[0x0],r8
8000a952:	50 4b       	stdsp	sp[0x10],r11
8000a954:	12 00       	add	r0,r9
8000a956:	30 1b       	mov	r11,1
8000a958:	0e 9c       	mov	r12,r7
8000a95a:	e0 a0 08 a7 	rcall	8000baa8 <__i2b>
8000a95e:	40 08       	lddsp	r8,sp[0x0]
8000a960:	18 94       	mov	r4,r12
8000a962:	40 4a       	lddsp	r10,sp[0x10]
8000a964:	58 05       	cp.w	r5,0
8000a966:	5f 99       	srgt	r9
8000a968:	58 0a       	cp.w	r10,0
8000a96a:	5f 9a       	srgt	r10
8000a96c:	f5 e9 00 09 	and	r9,r10,r9
8000a970:	c0 80       	breq	8000a980 <_dtoa_r+0x7e4>
8000a972:	40 4c       	lddsp	r12,sp[0x10]
8000a974:	f8 05 0d 49 	min	r9,r12,r5
8000a978:	12 1c       	sub	r12,r9
8000a97a:	12 10       	sub	r0,r9
8000a97c:	50 4c       	stdsp	sp[0x10],r12
8000a97e:	12 15       	sub	r5,r9
8000a980:	58 02       	cp.w	r2,0
8000a982:	e0 8a 00 27 	brle	8000a9d0 <_dtoa_r+0x834>
8000a986:	40 db       	lddsp	r11,sp[0x34]
8000a988:	58 0b       	cp.w	r11,0
8000a98a:	c1 d0       	breq	8000a9c4 <_dtoa_r+0x828>
8000a98c:	58 08       	cp.w	r8,0
8000a98e:	e0 8a 00 17 	brle	8000a9bc <_dtoa_r+0x820>
8000a992:	10 9a       	mov	r10,r8
8000a994:	50 08       	stdsp	sp[0x0],r8
8000a996:	08 9b       	mov	r11,r4
8000a998:	0e 9c       	mov	r12,r7
8000a99a:	e0 a0 08 cd 	rcall	8000bb34 <__pow5mult>
8000a99e:	06 9a       	mov	r10,r3
8000a9a0:	18 9b       	mov	r11,r12
8000a9a2:	18 94       	mov	r4,r12
8000a9a4:	0e 9c       	mov	r12,r7
8000a9a6:	e0 a0 08 01 	rcall	8000b9a8 <__multiply>
8000a9aa:	18 99       	mov	r9,r12
8000a9ac:	06 9b       	mov	r11,r3
8000a9ae:	50 19       	stdsp	sp[0x4],r9
8000a9b0:	0e 9c       	mov	r12,r7
8000a9b2:	e0 a0 06 ad 	rcall	8000b70c <_Bfree>
8000a9b6:	40 19       	lddsp	r9,sp[0x4]
8000a9b8:	40 08       	lddsp	r8,sp[0x0]
8000a9ba:	12 93       	mov	r3,r9
8000a9bc:	e4 08 01 0a 	sub	r10,r2,r8
8000a9c0:	c0 80       	breq	8000a9d0 <_dtoa_r+0x834>
8000a9c2:	c0 28       	rjmp	8000a9c6 <_dtoa_r+0x82a>
8000a9c4:	04 9a       	mov	r10,r2
8000a9c6:	06 9b       	mov	r11,r3
8000a9c8:	0e 9c       	mov	r12,r7
8000a9ca:	e0 a0 08 b5 	rcall	8000bb34 <__pow5mult>
8000a9ce:	18 93       	mov	r3,r12
8000a9d0:	30 1b       	mov	r11,1
8000a9d2:	0e 9c       	mov	r12,r7
8000a9d4:	e0 a0 08 6a 	rcall	8000baa8 <__i2b>
8000a9d8:	41 1a       	lddsp	r10,sp[0x44]
8000a9da:	18 92       	mov	r2,r12
8000a9dc:	58 0a       	cp.w	r10,0
8000a9de:	e0 8a 00 07 	brle	8000a9ec <_dtoa_r+0x850>
8000a9e2:	18 9b       	mov	r11,r12
8000a9e4:	0e 9c       	mov	r12,r7
8000a9e6:	e0 a0 08 a7 	rcall	8000bb34 <__pow5mult>
8000a9ea:	18 92       	mov	r2,r12
8000a9ec:	40 c9       	lddsp	r9,sp[0x30]
8000a9ee:	58 19       	cp.w	r9,1
8000a9f0:	e0 89 00 14 	brgt	8000aa18 <_dtoa_r+0x87c>
8000a9f4:	40 38       	lddsp	r8,sp[0xc]
8000a9f6:	58 08       	cp.w	r8,0
8000a9f8:	c1 01       	brne	8000aa18 <_dtoa_r+0x87c>
8000a9fa:	40 29       	lddsp	r9,sp[0x8]
8000a9fc:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000aa00:	c0 c1       	brne	8000aa18 <_dtoa_r+0x87c>
8000aa02:	12 98       	mov	r8,r9
8000aa04:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000aa08:	c0 80       	breq	8000aa18 <_dtoa_r+0x87c>
8000aa0a:	40 4c       	lddsp	r12,sp[0x10]
8000aa0c:	30 1b       	mov	r11,1
8000aa0e:	2f fc       	sub	r12,-1
8000aa10:	2f f0       	sub	r0,-1
8000aa12:	50 4c       	stdsp	sp[0x10],r12
8000aa14:	50 6b       	stdsp	sp[0x18],r11
8000aa16:	c0 38       	rjmp	8000aa1c <_dtoa_r+0x880>
8000aa18:	30 0a       	mov	r10,0
8000aa1a:	50 6a       	stdsp	sp[0x18],r10
8000aa1c:	41 19       	lddsp	r9,sp[0x44]
8000aa1e:	58 09       	cp.w	r9,0
8000aa20:	c0 31       	brne	8000aa26 <_dtoa_r+0x88a>
8000aa22:	30 1c       	mov	r12,1
8000aa24:	c0 98       	rjmp	8000aa36 <_dtoa_r+0x89a>
8000aa26:	64 48       	ld.w	r8,r2[0x10]
8000aa28:	2f c8       	sub	r8,-4
8000aa2a:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000aa2e:	e0 a0 05 df 	rcall	8000b5ec <__hi0bits>
8000aa32:	f8 0c 11 20 	rsub	r12,r12,32
8000aa36:	40 4b       	lddsp	r11,sp[0x10]
8000aa38:	f8 0b 00 08 	add	r8,r12,r11
8000aa3c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000aa40:	c0 c0       	breq	8000aa58 <_dtoa_r+0x8bc>
8000aa42:	f0 08 11 20 	rsub	r8,r8,32
8000aa46:	58 48       	cp.w	r8,4
8000aa48:	e0 8a 00 06 	brle	8000aa54 <_dtoa_r+0x8b8>
8000aa4c:	20 48       	sub	r8,4
8000aa4e:	10 0b       	add	r11,r8
8000aa50:	50 4b       	stdsp	sp[0x10],r11
8000aa52:	c0 78       	rjmp	8000aa60 <_dtoa_r+0x8c4>
8000aa54:	58 48       	cp.w	r8,4
8000aa56:	c0 70       	breq	8000aa64 <_dtoa_r+0x8c8>
8000aa58:	40 4a       	lddsp	r10,sp[0x10]
8000aa5a:	2e 48       	sub	r8,-28
8000aa5c:	10 0a       	add	r10,r8
8000aa5e:	50 4a       	stdsp	sp[0x10],r10
8000aa60:	10 00       	add	r0,r8
8000aa62:	10 05       	add	r5,r8
8000aa64:	58 00       	cp.w	r0,0
8000aa66:	e0 8a 00 08 	brle	8000aa76 <_dtoa_r+0x8da>
8000aa6a:	06 9b       	mov	r11,r3
8000aa6c:	00 9a       	mov	r10,r0
8000aa6e:	0e 9c       	mov	r12,r7
8000aa70:	e0 a0 07 58 	rcall	8000b920 <__lshift>
8000aa74:	18 93       	mov	r3,r12
8000aa76:	40 49       	lddsp	r9,sp[0x10]
8000aa78:	58 09       	cp.w	r9,0
8000aa7a:	e0 8a 00 08 	brle	8000aa8a <_dtoa_r+0x8ee>
8000aa7e:	04 9b       	mov	r11,r2
8000aa80:	12 9a       	mov	r10,r9
8000aa82:	0e 9c       	mov	r12,r7
8000aa84:	e0 a0 07 4e 	rcall	8000b920 <__lshift>
8000aa88:	18 92       	mov	r2,r12
8000aa8a:	41 48       	lddsp	r8,sp[0x50]
8000aa8c:	58 08       	cp.w	r8,0
8000aa8e:	c1 b0       	breq	8000aac4 <_dtoa_r+0x928>
8000aa90:	04 9b       	mov	r11,r2
8000aa92:	06 9c       	mov	r12,r3
8000aa94:	e0 a0 06 23 	rcall	8000b6da <__mcmp>
8000aa98:	c1 64       	brge	8000aac4 <_dtoa_r+0x928>
8000aa9a:	06 9b       	mov	r11,r3
8000aa9c:	30 09       	mov	r9,0
8000aa9e:	30 aa       	mov	r10,10
8000aaa0:	0e 9c       	mov	r12,r7
8000aaa2:	e0 a0 08 0b 	rcall	8000bab8 <__multadd>
8000aaa6:	20 16       	sub	r6,1
8000aaa8:	18 93       	mov	r3,r12
8000aaaa:	40 dc       	lddsp	r12,sp[0x34]
8000aaac:	58 0c       	cp.w	r12,0
8000aaae:	c0 31       	brne	8000aab4 <_dtoa_r+0x918>
8000aab0:	40 91       	lddsp	r1,sp[0x24]
8000aab2:	c0 98       	rjmp	8000aac4 <_dtoa_r+0x928>
8000aab4:	08 9b       	mov	r11,r4
8000aab6:	40 91       	lddsp	r1,sp[0x24]
8000aab8:	30 09       	mov	r9,0
8000aaba:	30 aa       	mov	r10,10
8000aabc:	0e 9c       	mov	r12,r7
8000aabe:	e0 a0 07 fd 	rcall	8000bab8 <__multadd>
8000aac2:	18 94       	mov	r4,r12
8000aac4:	58 01       	cp.w	r1,0
8000aac6:	5f a9       	srle	r9
8000aac8:	40 cb       	lddsp	r11,sp[0x30]
8000aaca:	58 2b       	cp.w	r11,2
8000aacc:	5f 98       	srgt	r8
8000aace:	f3 e8 00 08 	and	r8,r9,r8
8000aad2:	c2 50       	breq	8000ab1c <_dtoa_r+0x980>
8000aad4:	58 01       	cp.w	r1,0
8000aad6:	c1 11       	brne	8000aaf8 <_dtoa_r+0x95c>
8000aad8:	04 9b       	mov	r11,r2
8000aada:	02 99       	mov	r9,r1
8000aadc:	30 5a       	mov	r10,5
8000aade:	0e 9c       	mov	r12,r7
8000aae0:	e0 a0 07 ec 	rcall	8000bab8 <__multadd>
8000aae4:	18 92       	mov	r2,r12
8000aae6:	18 9b       	mov	r11,r12
8000aae8:	06 9c       	mov	r12,r3
8000aaea:	e0 a0 05 f8 	rcall	8000b6da <__mcmp>
8000aaee:	e0 89 00 0f 	brgt	8000ab0c <_dtoa_r+0x970>
8000aaf2:	c0 38       	rjmp	8000aaf8 <_dtoa_r+0x95c>
8000aaf4:	30 02       	mov	r2,0
8000aaf6:	04 94       	mov	r4,r2
8000aaf8:	40 ea       	lddsp	r10,sp[0x38]
8000aafa:	30 09       	mov	r9,0
8000aafc:	5c da       	com	r10
8000aafe:	40 85       	lddsp	r5,sp[0x20]
8000ab00:	50 6a       	stdsp	sp[0x18],r10
8000ab02:	50 49       	stdsp	sp[0x10],r9
8000ab04:	c0 f9       	rjmp	8000ad22 <_dtoa_r+0xb86>
8000ab06:	08 92       	mov	r2,r4
8000ab08:	40 66       	lddsp	r6,sp[0x18]
8000ab0a:	04 94       	mov	r4,r2
8000ab0c:	2f f6       	sub	r6,-1
8000ab0e:	50 66       	stdsp	sp[0x18],r6
8000ab10:	33 18       	mov	r8,49
8000ab12:	40 85       	lddsp	r5,sp[0x20]
8000ab14:	0a c8       	st.b	r5++,r8
8000ab16:	30 08       	mov	r8,0
8000ab18:	50 48       	stdsp	sp[0x10],r8
8000ab1a:	c0 49       	rjmp	8000ad22 <_dtoa_r+0xb86>
8000ab1c:	40 dc       	lddsp	r12,sp[0x34]
8000ab1e:	58 0c       	cp.w	r12,0
8000ab20:	e0 80 00 b5 	breq	8000ac8a <_dtoa_r+0xaee>
8000ab24:	58 05       	cp.w	r5,0
8000ab26:	e0 8a 00 08 	brle	8000ab36 <_dtoa_r+0x99a>
8000ab2a:	08 9b       	mov	r11,r4
8000ab2c:	0a 9a       	mov	r10,r5
8000ab2e:	0e 9c       	mov	r12,r7
8000ab30:	e0 a0 06 f8 	rcall	8000b920 <__lshift>
8000ab34:	18 94       	mov	r4,r12
8000ab36:	40 6b       	lddsp	r11,sp[0x18]
8000ab38:	58 0b       	cp.w	r11,0
8000ab3a:	c0 31       	brne	8000ab40 <_dtoa_r+0x9a4>
8000ab3c:	08 9c       	mov	r12,r4
8000ab3e:	c1 38       	rjmp	8000ab64 <_dtoa_r+0x9c8>
8000ab40:	68 1b       	ld.w	r11,r4[0x4]
8000ab42:	0e 9c       	mov	r12,r7
8000ab44:	e0 a0 05 fe 	rcall	8000b740 <_Balloc>
8000ab48:	68 4a       	ld.w	r10,r4[0x10]
8000ab4a:	18 95       	mov	r5,r12
8000ab4c:	e8 cb ff f4 	sub	r11,r4,-12
8000ab50:	2f ea       	sub	r10,-2
8000ab52:	2f 4c       	sub	r12,-12
8000ab54:	a3 6a       	lsl	r10,0x2
8000ab56:	fe b0 e6 4f 	rcall	800077f4 <memcpy>
8000ab5a:	0a 9b       	mov	r11,r5
8000ab5c:	30 1a       	mov	r10,1
8000ab5e:	0e 9c       	mov	r12,r7
8000ab60:	e0 a0 06 e0 	rcall	8000b920 <__lshift>
8000ab64:	50 44       	stdsp	sp[0x10],r4
8000ab66:	40 3a       	lddsp	r10,sp[0xc]
8000ab68:	30 19       	mov	r9,1
8000ab6a:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000ab6e:	18 94       	mov	r4,r12
8000ab70:	50 da       	stdsp	sp[0x34],r10
8000ab72:	40 85       	lddsp	r5,sp[0x20]
8000ab74:	50 99       	stdsp	sp[0x24],r9
8000ab76:	50 26       	stdsp	sp[0x8],r6
8000ab78:	50 e1       	stdsp	sp[0x38],r1
8000ab7a:	04 9b       	mov	r11,r2
8000ab7c:	06 9c       	mov	r12,r3
8000ab7e:	fe b0 fa 7f 	rcall	8000a07c <quorem>
8000ab82:	40 4b       	lddsp	r11,sp[0x10]
8000ab84:	f8 c0 ff d0 	sub	r0,r12,-48
8000ab88:	06 9c       	mov	r12,r3
8000ab8a:	e0 a0 05 a8 	rcall	8000b6da <__mcmp>
8000ab8e:	08 9a       	mov	r10,r4
8000ab90:	50 6c       	stdsp	sp[0x18],r12
8000ab92:	04 9b       	mov	r11,r2
8000ab94:	0e 9c       	mov	r12,r7
8000ab96:	e0 a0 06 5d 	rcall	8000b850 <__mdiff>
8000ab9a:	18 91       	mov	r1,r12
8000ab9c:	78 38       	ld.w	r8,r12[0xc]
8000ab9e:	58 08       	cp.w	r8,0
8000aba0:	c0 30       	breq	8000aba6 <_dtoa_r+0xa0a>
8000aba2:	30 16       	mov	r6,1
8000aba4:	c0 68       	rjmp	8000abb0 <_dtoa_r+0xa14>
8000aba6:	18 9b       	mov	r11,r12
8000aba8:	06 9c       	mov	r12,r3
8000abaa:	e0 a0 05 98 	rcall	8000b6da <__mcmp>
8000abae:	18 96       	mov	r6,r12
8000abb0:	0e 9c       	mov	r12,r7
8000abb2:	02 9b       	mov	r11,r1
8000abb4:	e0 a0 05 ac 	rcall	8000b70c <_Bfree>
8000abb8:	40 cc       	lddsp	r12,sp[0x30]
8000abba:	ed ec 10 08 	or	r8,r6,r12
8000abbe:	c0 d1       	brne	8000abd8 <_dtoa_r+0xa3c>
8000abc0:	40 db       	lddsp	r11,sp[0x34]
8000abc2:	58 0b       	cp.w	r11,0
8000abc4:	c0 a1       	brne	8000abd8 <_dtoa_r+0xa3c>
8000abc6:	40 26       	lddsp	r6,sp[0x8]
8000abc8:	e0 40 00 39 	cp.w	r0,57
8000abcc:	c3 00       	breq	8000ac2c <_dtoa_r+0xa90>
8000abce:	40 6a       	lddsp	r10,sp[0x18]
8000abd0:	58 0a       	cp.w	r10,0
8000abd2:	e0 89 00 24 	brgt	8000ac1a <_dtoa_r+0xa7e>
8000abd6:	c2 f8       	rjmp	8000ac34 <_dtoa_r+0xa98>
8000abd8:	40 69       	lddsp	r9,sp[0x18]
8000abda:	58 09       	cp.w	r9,0
8000abdc:	c0 85       	brlt	8000abec <_dtoa_r+0xa50>
8000abde:	12 98       	mov	r8,r9
8000abe0:	40 cc       	lddsp	r12,sp[0x30]
8000abe2:	18 48       	or	r8,r12
8000abe4:	c1 d1       	brne	8000ac1e <_dtoa_r+0xa82>
8000abe6:	40 db       	lddsp	r11,sp[0x34]
8000abe8:	58 0b       	cp.w	r11,0
8000abea:	c1 a1       	brne	8000ac1e <_dtoa_r+0xa82>
8000abec:	0c 99       	mov	r9,r6
8000abee:	40 26       	lddsp	r6,sp[0x8]
8000abf0:	58 09       	cp.w	r9,0
8000abf2:	e0 8a 00 21 	brle	8000ac34 <_dtoa_r+0xa98>
8000abf6:	06 9b       	mov	r11,r3
8000abf8:	30 1a       	mov	r10,1
8000abfa:	0e 9c       	mov	r12,r7
8000abfc:	e0 a0 06 92 	rcall	8000b920 <__lshift>
8000ac00:	04 9b       	mov	r11,r2
8000ac02:	18 93       	mov	r3,r12
8000ac04:	e0 a0 05 6b 	rcall	8000b6da <__mcmp>
8000ac08:	e0 89 00 06 	brgt	8000ac14 <_dtoa_r+0xa78>
8000ac0c:	c1 41       	brne	8000ac34 <_dtoa_r+0xa98>
8000ac0e:	ed b0 00 00 	bld	r0,0x0
8000ac12:	c1 11       	brne	8000ac34 <_dtoa_r+0xa98>
8000ac14:	e0 40 00 39 	cp.w	r0,57
8000ac18:	c0 a0       	breq	8000ac2c <_dtoa_r+0xa90>
8000ac1a:	2f f0       	sub	r0,-1
8000ac1c:	c0 c8       	rjmp	8000ac34 <_dtoa_r+0xa98>
8000ac1e:	58 06       	cp.w	r6,0
8000ac20:	e0 8a 00 0c 	brle	8000ac38 <_dtoa_r+0xa9c>
8000ac24:	40 26       	lddsp	r6,sp[0x8]
8000ac26:	e0 40 00 39 	cp.w	r0,57
8000ac2a:	c0 41       	brne	8000ac32 <_dtoa_r+0xa96>
8000ac2c:	33 98       	mov	r8,57
8000ac2e:	0a c8       	st.b	r5++,r8
8000ac30:	c6 78       	rjmp	8000acfe <_dtoa_r+0xb62>
8000ac32:	2f f0       	sub	r0,-1
8000ac34:	0a c0       	st.b	r5++,r0
8000ac36:	c7 58       	rjmp	8000ad20 <_dtoa_r+0xb84>
8000ac38:	0a c0       	st.b	r5++,r0
8000ac3a:	40 9a       	lddsp	r10,sp[0x24]
8000ac3c:	40 e9       	lddsp	r9,sp[0x38]
8000ac3e:	12 3a       	cp.w	r10,r9
8000ac40:	c4 30       	breq	8000acc6 <_dtoa_r+0xb2a>
8000ac42:	06 9b       	mov	r11,r3
8000ac44:	30 09       	mov	r9,0
8000ac46:	30 aa       	mov	r10,10
8000ac48:	0e 9c       	mov	r12,r7
8000ac4a:	e0 a0 07 37 	rcall	8000bab8 <__multadd>
8000ac4e:	40 48       	lddsp	r8,sp[0x10]
8000ac50:	18 93       	mov	r3,r12
8000ac52:	08 38       	cp.w	r8,r4
8000ac54:	c0 91       	brne	8000ac66 <_dtoa_r+0xaca>
8000ac56:	10 9b       	mov	r11,r8
8000ac58:	30 09       	mov	r9,0
8000ac5a:	30 aa       	mov	r10,10
8000ac5c:	0e 9c       	mov	r12,r7
8000ac5e:	e0 a0 07 2d 	rcall	8000bab8 <__multadd>
8000ac62:	50 4c       	stdsp	sp[0x10],r12
8000ac64:	c0 e8       	rjmp	8000ac80 <_dtoa_r+0xae4>
8000ac66:	40 4b       	lddsp	r11,sp[0x10]
8000ac68:	30 09       	mov	r9,0
8000ac6a:	30 aa       	mov	r10,10
8000ac6c:	0e 9c       	mov	r12,r7
8000ac6e:	e0 a0 07 25 	rcall	8000bab8 <__multadd>
8000ac72:	08 9b       	mov	r11,r4
8000ac74:	50 4c       	stdsp	sp[0x10],r12
8000ac76:	30 09       	mov	r9,0
8000ac78:	30 aa       	mov	r10,10
8000ac7a:	0e 9c       	mov	r12,r7
8000ac7c:	e0 a0 07 1e 	rcall	8000bab8 <__multadd>
8000ac80:	18 94       	mov	r4,r12
8000ac82:	40 9c       	lddsp	r12,sp[0x24]
8000ac84:	2f fc       	sub	r12,-1
8000ac86:	50 9c       	stdsp	sp[0x24],r12
8000ac88:	c7 9b       	rjmp	8000ab7a <_dtoa_r+0x9de>
8000ac8a:	30 18       	mov	r8,1
8000ac8c:	06 90       	mov	r0,r3
8000ac8e:	40 85       	lddsp	r5,sp[0x20]
8000ac90:	08 93       	mov	r3,r4
8000ac92:	0c 94       	mov	r4,r6
8000ac94:	10 96       	mov	r6,r8
8000ac96:	04 9b       	mov	r11,r2
8000ac98:	00 9c       	mov	r12,r0
8000ac9a:	fe b0 f9 f1 	rcall	8000a07c <quorem>
8000ac9e:	2d 0c       	sub	r12,-48
8000aca0:	0a cc       	st.b	r5++,r12
8000aca2:	02 36       	cp.w	r6,r1
8000aca4:	c0 a4       	brge	8000acb8 <_dtoa_r+0xb1c>
8000aca6:	00 9b       	mov	r11,r0
8000aca8:	30 09       	mov	r9,0
8000acaa:	30 aa       	mov	r10,10
8000acac:	0e 9c       	mov	r12,r7
8000acae:	2f f6       	sub	r6,-1
8000acb0:	e0 a0 07 04 	rcall	8000bab8 <__multadd>
8000acb4:	18 90       	mov	r0,r12
8000acb6:	cf 0b       	rjmp	8000ac96 <_dtoa_r+0xafa>
8000acb8:	08 96       	mov	r6,r4
8000acba:	30 0b       	mov	r11,0
8000acbc:	06 94       	mov	r4,r3
8000acbe:	50 4b       	stdsp	sp[0x10],r11
8000acc0:	00 93       	mov	r3,r0
8000acc2:	18 90       	mov	r0,r12
8000acc4:	c0 28       	rjmp	8000acc8 <_dtoa_r+0xb2c>
8000acc6:	40 26       	lddsp	r6,sp[0x8]
8000acc8:	06 9b       	mov	r11,r3
8000acca:	30 1a       	mov	r10,1
8000accc:	0e 9c       	mov	r12,r7
8000acce:	e0 a0 06 29 	rcall	8000b920 <__lshift>
8000acd2:	04 9b       	mov	r11,r2
8000acd4:	18 93       	mov	r3,r12
8000acd6:	e0 a0 05 02 	rcall	8000b6da <__mcmp>
8000acda:	e0 89 00 12 	brgt	8000acfe <_dtoa_r+0xb62>
8000acde:	c1 b1       	brne	8000ad14 <_dtoa_r+0xb78>
8000ace0:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000ace4:	c0 d1       	brne	8000acfe <_dtoa_r+0xb62>
8000ace6:	c1 78       	rjmp	8000ad14 <_dtoa_r+0xb78>
8000ace8:	40 89       	lddsp	r9,sp[0x20]
8000acea:	12 38       	cp.w	r8,r9
8000acec:	c0 30       	breq	8000acf2 <_dtoa_r+0xb56>
8000acee:	10 95       	mov	r5,r8
8000acf0:	c0 88       	rjmp	8000ad00 <_dtoa_r+0xb64>
8000acf2:	2f f6       	sub	r6,-1
8000acf4:	50 66       	stdsp	sp[0x18],r6
8000acf6:	33 18       	mov	r8,49
8000acf8:	40 8c       	lddsp	r12,sp[0x20]
8000acfa:	b8 88       	st.b	r12[0x0],r8
8000acfc:	c1 38       	rjmp	8000ad22 <_dtoa_r+0xb86>
8000acfe:	33 9a       	mov	r10,57
8000ad00:	0a 98       	mov	r8,r5
8000ad02:	11 79       	ld.ub	r9,--r8
8000ad04:	f4 09 18 00 	cp.b	r9,r10
8000ad08:	cf 00       	breq	8000ace8 <_dtoa_r+0xb4c>
8000ad0a:	2f f9       	sub	r9,-1
8000ad0c:	b0 89       	st.b	r8[0x0],r9
8000ad0e:	c0 98       	rjmp	8000ad20 <_dtoa_r+0xb84>
8000ad10:	10 95       	mov	r5,r8
8000ad12:	c0 28       	rjmp	8000ad16 <_dtoa_r+0xb7a>
8000ad14:	33 09       	mov	r9,48
8000ad16:	0a 98       	mov	r8,r5
8000ad18:	11 7a       	ld.ub	r10,--r8
8000ad1a:	f2 0a 18 00 	cp.b	r10,r9
8000ad1e:	cf 90       	breq	8000ad10 <_dtoa_r+0xb74>
8000ad20:	50 66       	stdsp	sp[0x18],r6
8000ad22:	04 9b       	mov	r11,r2
8000ad24:	0e 9c       	mov	r12,r7
8000ad26:	e0 a0 04 f3 	rcall	8000b70c <_Bfree>
8000ad2a:	58 04       	cp.w	r4,0
8000ad2c:	c1 20       	breq	8000ad50 <_dtoa_r+0xbb4>
8000ad2e:	40 4b       	lddsp	r11,sp[0x10]
8000ad30:	08 3b       	cp.w	r11,r4
8000ad32:	5f 19       	srne	r9
8000ad34:	58 0b       	cp.w	r11,0
8000ad36:	5f 18       	srne	r8
8000ad38:	f3 e8 00 08 	and	r8,r9,r8
8000ad3c:	c0 40       	breq	8000ad44 <_dtoa_r+0xba8>
8000ad3e:	0e 9c       	mov	r12,r7
8000ad40:	e0 a0 04 e6 	rcall	8000b70c <_Bfree>
8000ad44:	08 9b       	mov	r11,r4
8000ad46:	0e 9c       	mov	r12,r7
8000ad48:	e0 a0 04 e2 	rcall	8000b70c <_Bfree>
8000ad4c:	c0 28       	rjmp	8000ad50 <_dtoa_r+0xbb4>
8000ad4e:	50 66       	stdsp	sp[0x18],r6
8000ad50:	0e 9c       	mov	r12,r7
8000ad52:	06 9b       	mov	r11,r3
8000ad54:	e0 a0 04 dc 	rcall	8000b70c <_Bfree>
8000ad58:	30 08       	mov	r8,0
8000ad5a:	aa 88       	st.b	r5[0x0],r8
8000ad5c:	40 68       	lddsp	r8,sp[0x18]
8000ad5e:	41 5a       	lddsp	r10,sp[0x54]
8000ad60:	2f f8       	sub	r8,-1
8000ad62:	41 29       	lddsp	r9,sp[0x48]
8000ad64:	95 08       	st.w	r10[0x0],r8
8000ad66:	40 8c       	lddsp	r12,sp[0x20]
8000ad68:	58 09       	cp.w	r9,0
8000ad6a:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000ad6e:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000ad72:	2e 6d       	sub	sp,-104
8000ad74:	d8 32       	popm	r0-r7,pc
8000ad76:	d7 03       	nop

8000ad78 <__errno>:
8000ad78:	e0 68 0a 3c 	mov	r8,2620
8000ad7c:	70 0c       	ld.w	r12,r8[0x0]
8000ad7e:	2f 4c       	sub	r12,-12
8000ad80:	5e fc       	retal	r12
8000ad82:	d7 03       	nop

8000ad84 <_fflush_r>:
8000ad84:	d4 21       	pushm	r4-r7,lr
8000ad86:	16 97       	mov	r7,r11
8000ad88:	18 96       	mov	r6,r12
8000ad8a:	76 48       	ld.w	r8,r11[0x10]
8000ad8c:	58 08       	cp.w	r8,0
8000ad8e:	c7 f0       	breq	8000ae8c <_fflush_r+0x108>
8000ad90:	58 0c       	cp.w	r12,0
8000ad92:	c0 50       	breq	8000ad9c <_fflush_r+0x18>
8000ad94:	78 68       	ld.w	r8,r12[0x18]
8000ad96:	58 08       	cp.w	r8,0
8000ad98:	c0 21       	brne	8000ad9c <_fflush_r+0x18>
8000ad9a:	cc dc       	rcall	8000af34 <__sinit>
8000ad9c:	fe c8 cc 84 	sub	r8,pc,-13180
8000ada0:	10 37       	cp.w	r7,r8
8000ada2:	c0 31       	brne	8000ada8 <_fflush_r+0x24>
8000ada4:	6c 07       	ld.w	r7,r6[0x0]
8000ada6:	c0 c8       	rjmp	8000adbe <_fflush_r+0x3a>
8000ada8:	fe c8 cc 70 	sub	r8,pc,-13200
8000adac:	10 37       	cp.w	r7,r8
8000adae:	c0 31       	brne	8000adb4 <_fflush_r+0x30>
8000adb0:	6c 17       	ld.w	r7,r6[0x4]
8000adb2:	c0 68       	rjmp	8000adbe <_fflush_r+0x3a>
8000adb4:	fe c8 cc 5c 	sub	r8,pc,-13220
8000adb8:	10 37       	cp.w	r7,r8
8000adba:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000adbe:	8e 6a       	ld.sh	r10,r7[0xc]
8000adc0:	14 98       	mov	r8,r10
8000adc2:	ed ba 00 03 	bld	r10,0x3
8000adc6:	c4 20       	breq	8000ae4a <_fflush_r+0xc6>
8000adc8:	ab ba       	sbr	r10,0xb
8000adca:	ae 6a       	st.h	r7[0xc],r10
8000adcc:	6e 18       	ld.w	r8,r7[0x4]
8000adce:	58 08       	cp.w	r8,0
8000add0:	e0 89 00 06 	brgt	8000addc <_fflush_r+0x58>
8000add4:	6f 08       	ld.w	r8,r7[0x40]
8000add6:	58 08       	cp.w	r8,0
8000add8:	e0 8a 00 5a 	brle	8000ae8c <_fflush_r+0x108>
8000addc:	6e b8       	ld.w	r8,r7[0x2c]
8000adde:	58 08       	cp.w	r8,0
8000ade0:	c5 60       	breq	8000ae8c <_fflush_r+0x108>
8000ade2:	e2 1a 10 00 	andl	r10,0x1000,COH
8000ade6:	c0 30       	breq	8000adec <_fflush_r+0x68>
8000ade8:	6f 55       	ld.w	r5,r7[0x54]
8000adea:	c0 f8       	rjmp	8000ae08 <_fflush_r+0x84>
8000adec:	30 19       	mov	r9,1
8000adee:	6e 8b       	ld.w	r11,r7[0x20]
8000adf0:	0c 9c       	mov	r12,r6
8000adf2:	5d 18       	icall	r8
8000adf4:	18 95       	mov	r5,r12
8000adf6:	5b fc       	cp.w	r12,-1
8000adf8:	c0 81       	brne	8000ae08 <_fflush_r+0x84>
8000adfa:	6c 38       	ld.w	r8,r6[0xc]
8000adfc:	59 d8       	cp.w	r8,29
8000adfe:	c4 70       	breq	8000ae8c <_fflush_r+0x108>
8000ae00:	8e 68       	ld.sh	r8,r7[0xc]
8000ae02:	a7 a8       	sbr	r8,0x6
8000ae04:	ae 68       	st.h	r7[0xc],r8
8000ae06:	d8 22       	popm	r4-r7,pc
8000ae08:	8e 68       	ld.sh	r8,r7[0xc]
8000ae0a:	ed b8 00 02 	bld	r8,0x2
8000ae0e:	c0 91       	brne	8000ae20 <_fflush_r+0x9c>
8000ae10:	6e 18       	ld.w	r8,r7[0x4]
8000ae12:	10 15       	sub	r5,r8
8000ae14:	6e d8       	ld.w	r8,r7[0x34]
8000ae16:	58 08       	cp.w	r8,0
8000ae18:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000ae1c:	eb d8 e1 15 	subne	r5,r5,r8
8000ae20:	6e b8       	ld.w	r8,r7[0x2c]
8000ae22:	0c 9c       	mov	r12,r6
8000ae24:	30 09       	mov	r9,0
8000ae26:	0a 9a       	mov	r10,r5
8000ae28:	6e 8b       	ld.w	r11,r7[0x20]
8000ae2a:	5d 18       	icall	r8
8000ae2c:	8e 68       	ld.sh	r8,r7[0xc]
8000ae2e:	0a 3c       	cp.w	r12,r5
8000ae30:	c2 61       	brne	8000ae7c <_fflush_r+0xf8>
8000ae32:	ab d8       	cbr	r8,0xb
8000ae34:	30 0c       	mov	r12,0
8000ae36:	6e 49       	ld.w	r9,r7[0x10]
8000ae38:	ae 68       	st.h	r7[0xc],r8
8000ae3a:	8f 1c       	st.w	r7[0x4],r12
8000ae3c:	8f 09       	st.w	r7[0x0],r9
8000ae3e:	ed b8 00 0c 	bld	r8,0xc
8000ae42:	c2 51       	brne	8000ae8c <_fflush_r+0x108>
8000ae44:	ef 45 00 54 	st.w	r7[84],r5
8000ae48:	d8 22       	popm	r4-r7,pc
8000ae4a:	6e 45       	ld.w	r5,r7[0x10]
8000ae4c:	58 05       	cp.w	r5,0
8000ae4e:	c1 f0       	breq	8000ae8c <_fflush_r+0x108>
8000ae50:	6e 04       	ld.w	r4,r7[0x0]
8000ae52:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000ae56:	8f 05       	st.w	r7[0x0],r5
8000ae58:	f9 b8 01 00 	movne	r8,0
8000ae5c:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000ae60:	0a 14       	sub	r4,r5
8000ae62:	8f 28       	st.w	r7[0x8],r8
8000ae64:	c1 18       	rjmp	8000ae86 <_fflush_r+0x102>
8000ae66:	08 99       	mov	r9,r4
8000ae68:	0a 9a       	mov	r10,r5
8000ae6a:	6e a8       	ld.w	r8,r7[0x28]
8000ae6c:	6e 8b       	ld.w	r11,r7[0x20]
8000ae6e:	0c 9c       	mov	r12,r6
8000ae70:	5d 18       	icall	r8
8000ae72:	18 14       	sub	r4,r12
8000ae74:	58 0c       	cp.w	r12,0
8000ae76:	e0 89 00 07 	brgt	8000ae84 <_fflush_r+0x100>
8000ae7a:	8e 68       	ld.sh	r8,r7[0xc]
8000ae7c:	a7 a8       	sbr	r8,0x6
8000ae7e:	3f fc       	mov	r12,-1
8000ae80:	ae 68       	st.h	r7[0xc],r8
8000ae82:	d8 22       	popm	r4-r7,pc
8000ae84:	18 05       	add	r5,r12
8000ae86:	58 04       	cp.w	r4,0
8000ae88:	fe 99 ff ef 	brgt	8000ae66 <_fflush_r+0xe2>
8000ae8c:	d8 2a       	popm	r4-r7,pc,r12=0
8000ae8e:	d7 03       	nop

8000ae90 <__sfp_lock_acquire>:
8000ae90:	5e fc       	retal	r12

8000ae92 <__sfp_lock_release>:
8000ae92:	5e fc       	retal	r12

8000ae94 <_cleanup_r>:
8000ae94:	d4 01       	pushm	lr
8000ae96:	fe cb f0 ae 	sub	r11,pc,-3922
8000ae9a:	e0 a0 02 f7 	rcall	8000b488 <_fwalk>
8000ae9e:	d8 02       	popm	pc

8000aea0 <__sfmoreglue>:
8000aea0:	d4 21       	pushm	r4-r7,lr
8000aea2:	16 95       	mov	r5,r11
8000aea4:	f6 06 10 5c 	mul	r6,r11,92
8000aea8:	ec cb ff f4 	sub	r11,r6,-12
8000aeac:	fe b0 e2 88 	rcall	800073bc <_malloc_r>
8000aeb0:	18 97       	mov	r7,r12
8000aeb2:	c0 90       	breq	8000aec4 <__sfmoreglue+0x24>
8000aeb4:	99 15       	st.w	r12[0x4],r5
8000aeb6:	30 0b       	mov	r11,0
8000aeb8:	2f 4c       	sub	r12,-12
8000aeba:	0c 9a       	mov	r10,r6
8000aebc:	8f 2c       	st.w	r7[0x8],r12
8000aebe:	8f 0b       	st.w	r7[0x0],r11
8000aec0:	fe b0 e5 3e 	rcall	8000793c <memset>
8000aec4:	0e 9c       	mov	r12,r7
8000aec6:	d8 22       	popm	r4-r7,pc

8000aec8 <__sfp>:
8000aec8:	d4 21       	pushm	r4-r7,lr
8000aeca:	fe c8 cd 4e 	sub	r8,pc,-12978
8000aece:	18 96       	mov	r6,r12
8000aed0:	70 07       	ld.w	r7,r8[0x0]
8000aed2:	6e 68       	ld.w	r8,r7[0x18]
8000aed4:	58 08       	cp.w	r8,0
8000aed6:	c0 31       	brne	8000aedc <__sfp+0x14>
8000aed8:	0e 9c       	mov	r12,r7
8000aeda:	c2 dc       	rcall	8000af34 <__sinit>
8000aedc:	ee c7 ff 28 	sub	r7,r7,-216
8000aee0:	30 05       	mov	r5,0
8000aee2:	6e 2c       	ld.w	r12,r7[0x8]
8000aee4:	6e 18       	ld.w	r8,r7[0x4]
8000aee6:	c0 68       	rjmp	8000aef2 <__sfp+0x2a>
8000aee8:	98 69       	ld.sh	r9,r12[0xc]
8000aeea:	ea 09 19 00 	cp.h	r9,r5
8000aeee:	c1 10       	breq	8000af10 <__sfp+0x48>
8000aef0:	2a 4c       	sub	r12,-92
8000aef2:	20 18       	sub	r8,1
8000aef4:	cf a7       	brpl	8000aee8 <__sfp+0x20>
8000aef6:	6e 08       	ld.w	r8,r7[0x0]
8000aef8:	58 08       	cp.w	r8,0
8000aefa:	c0 61       	brne	8000af06 <__sfp+0x3e>
8000aefc:	30 4b       	mov	r11,4
8000aefe:	0c 9c       	mov	r12,r6
8000af00:	cd 0f       	rcall	8000aea0 <__sfmoreglue>
8000af02:	8f 0c       	st.w	r7[0x0],r12
8000af04:	c0 30       	breq	8000af0a <__sfp+0x42>
8000af06:	6e 07       	ld.w	r7,r7[0x0]
8000af08:	ce db       	rjmp	8000aee2 <__sfp+0x1a>
8000af0a:	30 c8       	mov	r8,12
8000af0c:	8d 38       	st.w	r6[0xc],r8
8000af0e:	d8 22       	popm	r4-r7,pc
8000af10:	30 08       	mov	r8,0
8000af12:	f9 48 00 4c 	st.w	r12[76],r8
8000af16:	99 08       	st.w	r12[0x0],r8
8000af18:	99 28       	st.w	r12[0x8],r8
8000af1a:	99 18       	st.w	r12[0x4],r8
8000af1c:	99 48       	st.w	r12[0x10],r8
8000af1e:	99 58       	st.w	r12[0x14],r8
8000af20:	99 68       	st.w	r12[0x18],r8
8000af22:	99 d8       	st.w	r12[0x34],r8
8000af24:	99 e8       	st.w	r12[0x38],r8
8000af26:	f9 48 00 48 	st.w	r12[72],r8
8000af2a:	3f f8       	mov	r8,-1
8000af2c:	b8 78       	st.h	r12[0xe],r8
8000af2e:	30 18       	mov	r8,1
8000af30:	b8 68       	st.h	r12[0xc],r8
8000af32:	d8 22       	popm	r4-r7,pc

8000af34 <__sinit>:
8000af34:	d4 21       	pushm	r4-r7,lr
8000af36:	18 96       	mov	r6,r12
8000af38:	78 67       	ld.w	r7,r12[0x18]
8000af3a:	58 07       	cp.w	r7,0
8000af3c:	c4 91       	brne	8000afce <__sinit+0x9a>
8000af3e:	fe c8 00 aa 	sub	r8,pc,170
8000af42:	30 15       	mov	r5,1
8000af44:	99 a8       	st.w	r12[0x28],r8
8000af46:	f9 47 00 d8 	st.w	r12[216],r7
8000af4a:	f9 47 00 dc 	st.w	r12[220],r7
8000af4e:	f9 47 00 e0 	st.w	r12[224],r7
8000af52:	99 65       	st.w	r12[0x18],r5
8000af54:	cb af       	rcall	8000aec8 <__sfp>
8000af56:	8d 0c       	st.w	r6[0x0],r12
8000af58:	0c 9c       	mov	r12,r6
8000af5a:	cb 7f       	rcall	8000aec8 <__sfp>
8000af5c:	8d 1c       	st.w	r6[0x4],r12
8000af5e:	0c 9c       	mov	r12,r6
8000af60:	cb 4f       	rcall	8000aec8 <__sfp>
8000af62:	6c 09       	ld.w	r9,r6[0x0]
8000af64:	30 48       	mov	r8,4
8000af66:	93 07       	st.w	r9[0x0],r7
8000af68:	b2 68       	st.h	r9[0xc],r8
8000af6a:	93 17       	st.w	r9[0x4],r7
8000af6c:	93 27       	st.w	r9[0x8],r7
8000af6e:	6c 18       	ld.w	r8,r6[0x4]
8000af70:	b2 77       	st.h	r9[0xe],r7
8000af72:	93 47       	st.w	r9[0x10],r7
8000af74:	93 57       	st.w	r9[0x14],r7
8000af76:	93 67       	st.w	r9[0x18],r7
8000af78:	93 89       	st.w	r9[0x20],r9
8000af7a:	91 07       	st.w	r8[0x0],r7
8000af7c:	91 17       	st.w	r8[0x4],r7
8000af7e:	91 27       	st.w	r8[0x8],r7
8000af80:	fe ce f3 24 	sub	lr,pc,-3292
8000af84:	fe cb f3 54 	sub	r11,pc,-3244
8000af88:	93 9e       	st.w	r9[0x24],lr
8000af8a:	93 ab       	st.w	r9[0x28],r11
8000af8c:	fe ca f3 7c 	sub	r10,pc,-3204
8000af90:	fe c4 f3 88 	sub	r4,pc,-3192
8000af94:	93 ba       	st.w	r9[0x2c],r10
8000af96:	93 c4       	st.w	r9[0x30],r4
8000af98:	30 99       	mov	r9,9
8000af9a:	b0 69       	st.h	r8[0xc],r9
8000af9c:	b0 75       	st.h	r8[0xe],r5
8000af9e:	91 c4       	st.w	r8[0x30],r4
8000afa0:	91 47       	st.w	r8[0x10],r7
8000afa2:	91 57       	st.w	r8[0x14],r7
8000afa4:	91 67       	st.w	r8[0x18],r7
8000afa6:	91 88       	st.w	r8[0x20],r8
8000afa8:	91 9e       	st.w	r8[0x24],lr
8000afaa:	91 ab       	st.w	r8[0x28],r11
8000afac:	91 ba       	st.w	r8[0x2c],r10
8000afae:	8d 2c       	st.w	r6[0x8],r12
8000afb0:	31 28       	mov	r8,18
8000afb2:	99 07       	st.w	r12[0x0],r7
8000afb4:	b8 68       	st.h	r12[0xc],r8
8000afb6:	99 17       	st.w	r12[0x4],r7
8000afb8:	99 27       	st.w	r12[0x8],r7
8000afba:	30 28       	mov	r8,2
8000afbc:	b8 78       	st.h	r12[0xe],r8
8000afbe:	99 c4       	st.w	r12[0x30],r4
8000afc0:	99 67       	st.w	r12[0x18],r7
8000afc2:	99 9e       	st.w	r12[0x24],lr
8000afc4:	99 ab       	st.w	r12[0x28],r11
8000afc6:	99 ba       	st.w	r12[0x2c],r10
8000afc8:	99 47       	st.w	r12[0x10],r7
8000afca:	99 57       	st.w	r12[0x14],r7
8000afcc:	99 8c       	st.w	r12[0x20],r12
8000afce:	d8 22       	popm	r4-r7,pc

8000afd0 <_malloc_trim_r>:
8000afd0:	d4 21       	pushm	r4-r7,lr
8000afd2:	16 95       	mov	r5,r11
8000afd4:	18 97       	mov	r7,r12
8000afd6:	fe b0 d7 ad 	rcall	80005f30 <__malloc_lock>
8000afda:	e0 64 05 3c 	mov	r4,1340
8000afde:	68 28       	ld.w	r8,r4[0x8]
8000afe0:	70 16       	ld.w	r6,r8[0x4]
8000afe2:	e0 16 ff fc 	andl	r6,0xfffc
8000afe6:	ec c8 ff 91 	sub	r8,r6,-111
8000afea:	f0 05 01 05 	sub	r5,r8,r5
8000afee:	e0 15 ff 80 	andl	r5,0xff80
8000aff2:	ea c5 00 80 	sub	r5,r5,128
8000aff6:	e0 45 00 7f 	cp.w	r5,127
8000affa:	e0 8a 00 25 	brle	8000b044 <_malloc_trim_r+0x74>
8000affe:	30 0b       	mov	r11,0
8000b000:	0e 9c       	mov	r12,r7
8000b002:	fe b0 e6 05 	rcall	80007c0c <_sbrk_r>
8000b006:	68 28       	ld.w	r8,r4[0x8]
8000b008:	0c 08       	add	r8,r6
8000b00a:	10 3c       	cp.w	r12,r8
8000b00c:	c1 c1       	brne	8000b044 <_malloc_trim_r+0x74>
8000b00e:	ea 0b 11 00 	rsub	r11,r5,0
8000b012:	0e 9c       	mov	r12,r7
8000b014:	fe b0 e5 fc 	rcall	80007c0c <_sbrk_r>
8000b018:	5b fc       	cp.w	r12,-1
8000b01a:	c1 91       	brne	8000b04c <_malloc_trim_r+0x7c>
8000b01c:	30 0b       	mov	r11,0
8000b01e:	0e 9c       	mov	r12,r7
8000b020:	fe b0 e5 f6 	rcall	80007c0c <_sbrk_r>
8000b024:	68 28       	ld.w	r8,r4[0x8]
8000b026:	f8 08 01 09 	sub	r9,r12,r8
8000b02a:	58 f9       	cp.w	r9,15
8000b02c:	e0 8a 00 0c 	brle	8000b044 <_malloc_trim_r+0x74>
8000b030:	a1 a9       	sbr	r9,0x0
8000b032:	91 19       	st.w	r8[0x4],r9
8000b034:	e0 68 09 48 	mov	r8,2376
8000b038:	70 09       	ld.w	r9,r8[0x0]
8000b03a:	e0 68 0d 74 	mov	r8,3444
8000b03e:	f8 09 01 09 	sub	r9,r12,r9
8000b042:	91 09       	st.w	r8[0x0],r9
8000b044:	0e 9c       	mov	r12,r7
8000b046:	fe b0 d7 7b 	rcall	80005f3c <__malloc_unlock>
8000b04a:	d8 2a       	popm	r4-r7,pc,r12=0
8000b04c:	68 28       	ld.w	r8,r4[0x8]
8000b04e:	0a 16       	sub	r6,r5
8000b050:	a1 a6       	sbr	r6,0x0
8000b052:	91 16       	st.w	r8[0x4],r6
8000b054:	e0 68 0d 74 	mov	r8,3444
8000b058:	70 09       	ld.w	r9,r8[0x0]
8000b05a:	0a 19       	sub	r9,r5
8000b05c:	0e 9c       	mov	r12,r7
8000b05e:	91 09       	st.w	r8[0x0],r9
8000b060:	fe b0 d7 6e 	rcall	80005f3c <__malloc_unlock>
8000b064:	da 2a       	popm	r4-r7,pc,r12=1
8000b066:	d7 03       	nop

8000b068 <_free_r>:
8000b068:	d4 21       	pushm	r4-r7,lr
8000b06a:	16 96       	mov	r6,r11
8000b06c:	18 97       	mov	r7,r12
8000b06e:	58 0b       	cp.w	r11,0
8000b070:	e0 80 00 c0 	breq	8000b1f0 <_free_r+0x188>
8000b074:	fe b0 d7 5e 	rcall	80005f30 <__malloc_lock>
8000b078:	20 86       	sub	r6,8
8000b07a:	e0 6a 05 3c 	mov	r10,1340
8000b07e:	6c 18       	ld.w	r8,r6[0x4]
8000b080:	74 2e       	ld.w	lr,r10[0x8]
8000b082:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000b086:	a1 c8       	cbr	r8,0x0
8000b088:	ec 08 00 09 	add	r9,r6,r8
8000b08c:	72 1b       	ld.w	r11,r9[0x4]
8000b08e:	e0 1b ff fc 	andl	r11,0xfffc
8000b092:	1c 39       	cp.w	r9,lr
8000b094:	c1 e1       	brne	8000b0d0 <_free_r+0x68>
8000b096:	f6 08 00 08 	add	r8,r11,r8
8000b09a:	58 0c       	cp.w	r12,0
8000b09c:	c0 81       	brne	8000b0ac <_free_r+0x44>
8000b09e:	6c 09       	ld.w	r9,r6[0x0]
8000b0a0:	12 16       	sub	r6,r9
8000b0a2:	12 08       	add	r8,r9
8000b0a4:	6c 3b       	ld.w	r11,r6[0xc]
8000b0a6:	6c 29       	ld.w	r9,r6[0x8]
8000b0a8:	97 29       	st.w	r11[0x8],r9
8000b0aa:	93 3b       	st.w	r9[0xc],r11
8000b0ac:	10 99       	mov	r9,r8
8000b0ae:	95 26       	st.w	r10[0x8],r6
8000b0b0:	a1 a9       	sbr	r9,0x0
8000b0b2:	8d 19       	st.w	r6[0x4],r9
8000b0b4:	e0 69 09 44 	mov	r9,2372
8000b0b8:	72 09       	ld.w	r9,r9[0x0]
8000b0ba:	12 38       	cp.w	r8,r9
8000b0bc:	c0 63       	brcs	8000b0c8 <_free_r+0x60>
8000b0be:	e0 68 0d 70 	mov	r8,3440
8000b0c2:	0e 9c       	mov	r12,r7
8000b0c4:	70 0b       	ld.w	r11,r8[0x0]
8000b0c6:	c8 5f       	rcall	8000afd0 <_malloc_trim_r>
8000b0c8:	0e 9c       	mov	r12,r7
8000b0ca:	fe b0 d7 39 	rcall	80005f3c <__malloc_unlock>
8000b0ce:	d8 22       	popm	r4-r7,pc
8000b0d0:	93 1b       	st.w	r9[0x4],r11
8000b0d2:	58 0c       	cp.w	r12,0
8000b0d4:	c0 30       	breq	8000b0da <_free_r+0x72>
8000b0d6:	30 0c       	mov	r12,0
8000b0d8:	c1 08       	rjmp	8000b0f8 <_free_r+0x90>
8000b0da:	6c 0e       	ld.w	lr,r6[0x0]
8000b0dc:	f4 c5 ff f8 	sub	r5,r10,-8
8000b0e0:	1c 16       	sub	r6,lr
8000b0e2:	1c 08       	add	r8,lr
8000b0e4:	6c 2e       	ld.w	lr,r6[0x8]
8000b0e6:	0a 3e       	cp.w	lr,r5
8000b0e8:	f9 bc 00 01 	moveq	r12,1
8000b0ec:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000b0f0:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000b0f4:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000b0f8:	f2 0b 00 0e 	add	lr,r9,r11
8000b0fc:	7c 1e       	ld.w	lr,lr[0x4]
8000b0fe:	ed be 00 00 	bld	lr,0x0
8000b102:	c1 40       	breq	8000b12a <_free_r+0xc2>
8000b104:	16 08       	add	r8,r11
8000b106:	58 0c       	cp.w	r12,0
8000b108:	c0 d1       	brne	8000b122 <_free_r+0xba>
8000b10a:	e0 6e 05 3c 	mov	lr,1340
8000b10e:	72 2b       	ld.w	r11,r9[0x8]
8000b110:	2f 8e       	sub	lr,-8
8000b112:	1c 3b       	cp.w	r11,lr
8000b114:	c0 71       	brne	8000b122 <_free_r+0xba>
8000b116:	97 36       	st.w	r11[0xc],r6
8000b118:	97 26       	st.w	r11[0x8],r6
8000b11a:	8d 2b       	st.w	r6[0x8],r11
8000b11c:	8d 3b       	st.w	r6[0xc],r11
8000b11e:	30 1c       	mov	r12,1
8000b120:	c0 58       	rjmp	8000b12a <_free_r+0xc2>
8000b122:	72 2b       	ld.w	r11,r9[0x8]
8000b124:	72 39       	ld.w	r9,r9[0xc]
8000b126:	93 2b       	st.w	r9[0x8],r11
8000b128:	97 39       	st.w	r11[0xc],r9
8000b12a:	10 99       	mov	r9,r8
8000b12c:	ec 08 09 08 	st.w	r6[r8],r8
8000b130:	a1 a9       	sbr	r9,0x0
8000b132:	8d 19       	st.w	r6[0x4],r9
8000b134:	58 0c       	cp.w	r12,0
8000b136:	c5 a1       	brne	8000b1ea <_free_r+0x182>
8000b138:	e0 48 01 ff 	cp.w	r8,511
8000b13c:	e0 8b 00 13 	brhi	8000b162 <_free_r+0xfa>
8000b140:	a3 98       	lsr	r8,0x3
8000b142:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000b146:	72 2b       	ld.w	r11,r9[0x8]
8000b148:	8d 39       	st.w	r6[0xc],r9
8000b14a:	8d 2b       	st.w	r6[0x8],r11
8000b14c:	97 36       	st.w	r11[0xc],r6
8000b14e:	93 26       	st.w	r9[0x8],r6
8000b150:	a3 48       	asr	r8,0x2
8000b152:	74 19       	ld.w	r9,r10[0x4]
8000b154:	30 1b       	mov	r11,1
8000b156:	f6 08 09 48 	lsl	r8,r11,r8
8000b15a:	f3 e8 10 08 	or	r8,r9,r8
8000b15e:	95 18       	st.w	r10[0x4],r8
8000b160:	c4 58       	rjmp	8000b1ea <_free_r+0x182>
8000b162:	f0 0b 16 09 	lsr	r11,r8,0x9
8000b166:	58 4b       	cp.w	r11,4
8000b168:	e0 8b 00 06 	brhi	8000b174 <_free_r+0x10c>
8000b16c:	f0 0b 16 06 	lsr	r11,r8,0x6
8000b170:	2c 8b       	sub	r11,-56
8000b172:	c2 08       	rjmp	8000b1b2 <_free_r+0x14a>
8000b174:	59 4b       	cp.w	r11,20
8000b176:	e0 8b 00 04 	brhi	8000b17e <_free_r+0x116>
8000b17a:	2a 5b       	sub	r11,-91
8000b17c:	c1 b8       	rjmp	8000b1b2 <_free_r+0x14a>
8000b17e:	e0 4b 00 54 	cp.w	r11,84
8000b182:	e0 8b 00 06 	brhi	8000b18e <_free_r+0x126>
8000b186:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000b18a:	29 2b       	sub	r11,-110
8000b18c:	c1 38       	rjmp	8000b1b2 <_free_r+0x14a>
8000b18e:	e0 4b 01 54 	cp.w	r11,340
8000b192:	e0 8b 00 06 	brhi	8000b19e <_free_r+0x136>
8000b196:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000b19a:	28 9b       	sub	r11,-119
8000b19c:	c0 b8       	rjmp	8000b1b2 <_free_r+0x14a>
8000b19e:	e0 4b 05 54 	cp.w	r11,1364
8000b1a2:	e0 88 00 05 	brls	8000b1ac <_free_r+0x144>
8000b1a6:	37 eb       	mov	r11,126
8000b1a8:	c0 58       	rjmp	8000b1b2 <_free_r+0x14a>
8000b1aa:	d7 03       	nop
8000b1ac:	f0 0b 16 12 	lsr	r11,r8,0x12
8000b1b0:	28 4b       	sub	r11,-124
8000b1b2:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000b1b6:	78 29       	ld.w	r9,r12[0x8]
8000b1b8:	18 39       	cp.w	r9,r12
8000b1ba:	c0 e1       	brne	8000b1d6 <_free_r+0x16e>
8000b1bc:	74 18       	ld.w	r8,r10[0x4]
8000b1be:	a3 4b       	asr	r11,0x2
8000b1c0:	30 1c       	mov	r12,1
8000b1c2:	f8 0b 09 4b 	lsl	r11,r12,r11
8000b1c6:	f1 eb 10 0b 	or	r11,r8,r11
8000b1ca:	12 98       	mov	r8,r9
8000b1cc:	95 1b       	st.w	r10[0x4],r11
8000b1ce:	c0 a8       	rjmp	8000b1e2 <_free_r+0x17a>
8000b1d0:	72 29       	ld.w	r9,r9[0x8]
8000b1d2:	18 39       	cp.w	r9,r12
8000b1d4:	c0 60       	breq	8000b1e0 <_free_r+0x178>
8000b1d6:	72 1a       	ld.w	r10,r9[0x4]
8000b1d8:	e0 1a ff fc 	andl	r10,0xfffc
8000b1dc:	14 38       	cp.w	r8,r10
8000b1de:	cf 93       	brcs	8000b1d0 <_free_r+0x168>
8000b1e0:	72 38       	ld.w	r8,r9[0xc]
8000b1e2:	8d 38       	st.w	r6[0xc],r8
8000b1e4:	8d 29       	st.w	r6[0x8],r9
8000b1e6:	93 36       	st.w	r9[0xc],r6
8000b1e8:	91 26       	st.w	r8[0x8],r6
8000b1ea:	0e 9c       	mov	r12,r7
8000b1ec:	fe b0 d6 a8 	rcall	80005f3c <__malloc_unlock>
8000b1f0:	d8 22       	popm	r4-r7,pc
8000b1f2:	d7 03       	nop

8000b1f4 <__sfvwrite_r>:
8000b1f4:	d4 31       	pushm	r0-r7,lr
8000b1f6:	20 3d       	sub	sp,12
8000b1f8:	14 94       	mov	r4,r10
8000b1fa:	18 95       	mov	r5,r12
8000b1fc:	16 97       	mov	r7,r11
8000b1fe:	74 28       	ld.w	r8,r10[0x8]
8000b200:	58 08       	cp.w	r8,0
8000b202:	e0 80 01 40 	breq	8000b482 <__sfvwrite_r+0x28e>
8000b206:	96 68       	ld.sh	r8,r11[0xc]
8000b208:	ed b8 00 03 	bld	r8,0x3
8000b20c:	c0 41       	brne	8000b214 <__sfvwrite_r+0x20>
8000b20e:	76 48       	ld.w	r8,r11[0x10]
8000b210:	58 08       	cp.w	r8,0
8000b212:	c0 c1       	brne	8000b22a <__sfvwrite_r+0x36>
8000b214:	0e 9b       	mov	r11,r7
8000b216:	0a 9c       	mov	r12,r5
8000b218:	fe b0 f6 c4 	rcall	80009fa0 <__swsetup_r>
8000b21c:	c0 70       	breq	8000b22a <__sfvwrite_r+0x36>
8000b21e:	8e 68       	ld.sh	r8,r7[0xc]
8000b220:	a7 a8       	sbr	r8,0x6
8000b222:	ae 68       	st.h	r7[0xc],r8
8000b224:	30 98       	mov	r8,9
8000b226:	8b 38       	st.w	r5[0xc],r8
8000b228:	c2 b9       	rjmp	8000b47e <__sfvwrite_r+0x28a>
8000b22a:	8e 63       	ld.sh	r3,r7[0xc]
8000b22c:	68 00       	ld.w	r0,r4[0x0]
8000b22e:	06 96       	mov	r6,r3
8000b230:	e2 16 00 02 	andl	r6,0x2,COH
8000b234:	c2 10       	breq	8000b276 <__sfvwrite_r+0x82>
8000b236:	30 03       	mov	r3,0
8000b238:	e0 62 04 00 	mov	r2,1024
8000b23c:	06 96       	mov	r6,r3
8000b23e:	c0 48       	rjmp	8000b246 <__sfvwrite_r+0x52>
8000b240:	60 03       	ld.w	r3,r0[0x0]
8000b242:	60 16       	ld.w	r6,r0[0x4]
8000b244:	2f 80       	sub	r0,-8
8000b246:	58 06       	cp.w	r6,0
8000b248:	cf c0       	breq	8000b240 <__sfvwrite_r+0x4c>
8000b24a:	e0 46 04 00 	cp.w	r6,1024
8000b24e:	ec 09 17 80 	movls	r9,r6
8000b252:	e4 09 17 b0 	movhi	r9,r2
8000b256:	06 9a       	mov	r10,r3
8000b258:	6e a8       	ld.w	r8,r7[0x28]
8000b25a:	6e 8b       	ld.w	r11,r7[0x20]
8000b25c:	0a 9c       	mov	r12,r5
8000b25e:	5d 18       	icall	r8
8000b260:	18 16       	sub	r6,r12
8000b262:	58 0c       	cp.w	r12,0
8000b264:	e0 8a 01 0a 	brle	8000b478 <__sfvwrite_r+0x284>
8000b268:	68 28       	ld.w	r8,r4[0x8]
8000b26a:	18 18       	sub	r8,r12
8000b26c:	89 28       	st.w	r4[0x8],r8
8000b26e:	e0 80 01 0a 	breq	8000b482 <__sfvwrite_r+0x28e>
8000b272:	18 03       	add	r3,r12
8000b274:	ce 9b       	rjmp	8000b246 <__sfvwrite_r+0x52>
8000b276:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000b27a:	c0 70       	breq	8000b288 <__sfvwrite_r+0x94>
8000b27c:	50 06       	stdsp	sp[0x0],r6
8000b27e:	0c 93       	mov	r3,r6
8000b280:	0c 91       	mov	r1,r6
8000b282:	50 15       	stdsp	sp[0x4],r5
8000b284:	08 92       	mov	r2,r4
8000b286:	c9 c8       	rjmp	8000b3be <__sfvwrite_r+0x1ca>
8000b288:	06 96       	mov	r6,r3
8000b28a:	08 91       	mov	r1,r4
8000b28c:	c0 48       	rjmp	8000b294 <__sfvwrite_r+0xa0>
8000b28e:	60 03       	ld.w	r3,r0[0x0]
8000b290:	60 16       	ld.w	r6,r0[0x4]
8000b292:	2f 80       	sub	r0,-8
8000b294:	58 06       	cp.w	r6,0
8000b296:	cf c0       	breq	8000b28e <__sfvwrite_r+0x9a>
8000b298:	8e 68       	ld.sh	r8,r7[0xc]
8000b29a:	6e 24       	ld.w	r4,r7[0x8]
8000b29c:	10 99       	mov	r9,r8
8000b29e:	e2 19 02 00 	andl	r9,0x200,COH
8000b2a2:	c5 50       	breq	8000b34c <__sfvwrite_r+0x158>
8000b2a4:	08 36       	cp.w	r6,r4
8000b2a6:	c4 43       	brcs	8000b32e <__sfvwrite_r+0x13a>
8000b2a8:	10 99       	mov	r9,r8
8000b2aa:	e2 19 04 80 	andl	r9,0x480,COH
8000b2ae:	c4 00       	breq	8000b32e <__sfvwrite_r+0x13a>
8000b2b0:	6e 4b       	ld.w	r11,r7[0x10]
8000b2b2:	6e 09       	ld.w	r9,r7[0x0]
8000b2b4:	16 19       	sub	r9,r11
8000b2b6:	50 09       	stdsp	sp[0x0],r9
8000b2b8:	6e 59       	ld.w	r9,r7[0x14]
8000b2ba:	10 9c       	mov	r12,r8
8000b2bc:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000b2c0:	30 28       	mov	r8,2
8000b2c2:	f4 08 0c 08 	divs	r8,r10,r8
8000b2c6:	fa e9 00 04 	st.d	sp[4],r8
8000b2ca:	10 94       	mov	r4,r8
8000b2cc:	40 09       	lddsp	r9,sp[0x0]
8000b2ce:	e2 1c 04 00 	andl	r12,0x400,COH
8000b2d2:	2f f9       	sub	r9,-1
8000b2d4:	0c 09       	add	r9,r6
8000b2d6:	12 38       	cp.w	r8,r9
8000b2d8:	f2 04 17 30 	movlo	r4,r9
8000b2dc:	58 0c       	cp.w	r12,0
8000b2de:	c1 10       	breq	8000b300 <__sfvwrite_r+0x10c>
8000b2e0:	08 9b       	mov	r11,r4
8000b2e2:	0a 9c       	mov	r12,r5
8000b2e4:	fe b0 e0 6c 	rcall	800073bc <_malloc_r>
8000b2e8:	18 92       	mov	r2,r12
8000b2ea:	c1 40       	breq	8000b312 <__sfvwrite_r+0x11e>
8000b2ec:	40 0a       	lddsp	r10,sp[0x0]
8000b2ee:	6e 4b       	ld.w	r11,r7[0x10]
8000b2f0:	fe b0 e2 82 	rcall	800077f4 <memcpy>
8000b2f4:	8e 68       	ld.sh	r8,r7[0xc]
8000b2f6:	e0 18 fb 7f 	andl	r8,0xfb7f
8000b2fa:	a7 b8       	sbr	r8,0x7
8000b2fc:	ae 68       	st.h	r7[0xc],r8
8000b2fe:	c0 d8       	rjmp	8000b318 <__sfvwrite_r+0x124>
8000b300:	08 9a       	mov	r10,r4
8000b302:	0a 9c       	mov	r12,r5
8000b304:	fe b0 e3 24 	rcall	8000794c <_realloc_r>
8000b308:	18 92       	mov	r2,r12
8000b30a:	c0 71       	brne	8000b318 <__sfvwrite_r+0x124>
8000b30c:	6e 4b       	ld.w	r11,r7[0x10]
8000b30e:	0a 9c       	mov	r12,r5
8000b310:	ca ce       	rcall	8000b068 <_free_r>
8000b312:	30 c8       	mov	r8,12
8000b314:	8b 38       	st.w	r5[0xc],r8
8000b316:	cb 18       	rjmp	8000b478 <__sfvwrite_r+0x284>
8000b318:	40 0a       	lddsp	r10,sp[0x0]
8000b31a:	40 09       	lddsp	r9,sp[0x0]
8000b31c:	e8 0a 01 0a 	sub	r10,r4,r10
8000b320:	e4 09 00 08 	add	r8,r2,r9
8000b324:	8f 54       	st.w	r7[0x14],r4
8000b326:	8f 2a       	st.w	r7[0x8],r10
8000b328:	8f 08       	st.w	r7[0x0],r8
8000b32a:	8f 42       	st.w	r7[0x10],r2
8000b32c:	0c 94       	mov	r4,r6
8000b32e:	08 36       	cp.w	r6,r4
8000b330:	ec 04 17 30 	movlo	r4,r6
8000b334:	06 9b       	mov	r11,r3
8000b336:	08 9a       	mov	r10,r4
8000b338:	6e 0c       	ld.w	r12,r7[0x0]
8000b33a:	c3 ad       	rcall	8000b5ae <memmove>
8000b33c:	6e 08       	ld.w	r8,r7[0x0]
8000b33e:	08 08       	add	r8,r4
8000b340:	8f 08       	st.w	r7[0x0],r8
8000b342:	6e 28       	ld.w	r8,r7[0x8]
8000b344:	08 18       	sub	r8,r4
8000b346:	0c 94       	mov	r4,r6
8000b348:	8f 28       	st.w	r7[0x8],r8
8000b34a:	c2 e8       	rjmp	8000b3a6 <__sfvwrite_r+0x1b2>
8000b34c:	08 36       	cp.w	r6,r4
8000b34e:	5f ba       	srhi	r10
8000b350:	6e 0c       	ld.w	r12,r7[0x0]
8000b352:	6e 48       	ld.w	r8,r7[0x10]
8000b354:	10 3c       	cp.w	r12,r8
8000b356:	5f b8       	srhi	r8
8000b358:	f5 e8 00 08 	and	r8,r10,r8
8000b35c:	f2 08 18 00 	cp.b	r8,r9
8000b360:	c0 d0       	breq	8000b37a <__sfvwrite_r+0x186>
8000b362:	06 9b       	mov	r11,r3
8000b364:	08 9a       	mov	r10,r4
8000b366:	c2 4d       	rcall	8000b5ae <memmove>
8000b368:	6e 08       	ld.w	r8,r7[0x0]
8000b36a:	08 08       	add	r8,r4
8000b36c:	0e 9b       	mov	r11,r7
8000b36e:	8f 08       	st.w	r7[0x0],r8
8000b370:	0a 9c       	mov	r12,r5
8000b372:	fe b0 fd 09 	rcall	8000ad84 <_fflush_r>
8000b376:	c1 80       	breq	8000b3a6 <__sfvwrite_r+0x1b2>
8000b378:	c8 08       	rjmp	8000b478 <__sfvwrite_r+0x284>
8000b37a:	6e 59       	ld.w	r9,r7[0x14]
8000b37c:	12 36       	cp.w	r6,r9
8000b37e:	c0 a3       	brcs	8000b392 <__sfvwrite_r+0x19e>
8000b380:	6e a8       	ld.w	r8,r7[0x28]
8000b382:	06 9a       	mov	r10,r3
8000b384:	6e 8b       	ld.w	r11,r7[0x20]
8000b386:	0a 9c       	mov	r12,r5
8000b388:	5d 18       	icall	r8
8000b38a:	18 94       	mov	r4,r12
8000b38c:	e0 89 00 0d 	brgt	8000b3a6 <__sfvwrite_r+0x1b2>
8000b390:	c7 48       	rjmp	8000b478 <__sfvwrite_r+0x284>
8000b392:	0c 9a       	mov	r10,r6
8000b394:	06 9b       	mov	r11,r3
8000b396:	c0 cd       	rcall	8000b5ae <memmove>
8000b398:	6e 08       	ld.w	r8,r7[0x0]
8000b39a:	0c 08       	add	r8,r6
8000b39c:	0c 94       	mov	r4,r6
8000b39e:	8f 08       	st.w	r7[0x0],r8
8000b3a0:	6e 28       	ld.w	r8,r7[0x8]
8000b3a2:	0c 18       	sub	r8,r6
8000b3a4:	8f 28       	st.w	r7[0x8],r8
8000b3a6:	62 28       	ld.w	r8,r1[0x8]
8000b3a8:	08 18       	sub	r8,r4
8000b3aa:	83 28       	st.w	r1[0x8],r8
8000b3ac:	c6 b0       	breq	8000b482 <__sfvwrite_r+0x28e>
8000b3ae:	08 16       	sub	r6,r4
8000b3b0:	08 03       	add	r3,r4
8000b3b2:	c7 1b       	rjmp	8000b294 <__sfvwrite_r+0xa0>
8000b3b4:	60 03       	ld.w	r3,r0[0x0]
8000b3b6:	60 11       	ld.w	r1,r0[0x4]
8000b3b8:	30 08       	mov	r8,0
8000b3ba:	2f 80       	sub	r0,-8
8000b3bc:	50 08       	stdsp	sp[0x0],r8
8000b3be:	58 01       	cp.w	r1,0
8000b3c0:	cf a0       	breq	8000b3b4 <__sfvwrite_r+0x1c0>
8000b3c2:	40 0a       	lddsp	r10,sp[0x0]
8000b3c4:	58 0a       	cp.w	r10,0
8000b3c6:	c1 41       	brne	8000b3ee <__sfvwrite_r+0x1fa>
8000b3c8:	e2 c6 ff ff 	sub	r6,r1,-1
8000b3cc:	02 9a       	mov	r10,r1
8000b3ce:	30 ab       	mov	r11,10
8000b3d0:	06 9c       	mov	r12,r3
8000b3d2:	ce 3c       	rcall	8000b598 <memchr>
8000b3d4:	f8 c8 ff ff 	sub	r8,r12,-1
8000b3d8:	58 0c       	cp.w	r12,0
8000b3da:	f1 d3 e1 16 	subne	r6,r8,r3
8000b3de:	f9 b9 01 01 	movne	r9,1
8000b3e2:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b3e6:	f9 b8 00 01 	moveq	r8,1
8000b3ea:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b3ee:	02 36       	cp.w	r6,r1
8000b3f0:	ec 04 17 80 	movls	r4,r6
8000b3f4:	e2 04 17 b0 	movhi	r4,r1
8000b3f8:	6e 59       	ld.w	r9,r7[0x14]
8000b3fa:	6e 25       	ld.w	r5,r7[0x8]
8000b3fc:	f2 05 00 05 	add	r5,r9,r5
8000b400:	0a 34       	cp.w	r4,r5
8000b402:	5f 9a       	srgt	r10
8000b404:	6e 0c       	ld.w	r12,r7[0x0]
8000b406:	6e 48       	ld.w	r8,r7[0x10]
8000b408:	10 3c       	cp.w	r12,r8
8000b40a:	5f b8       	srhi	r8
8000b40c:	f5 e8 00 08 	and	r8,r10,r8
8000b410:	30 0a       	mov	r10,0
8000b412:	f4 08 18 00 	cp.b	r8,r10
8000b416:	c0 d0       	breq	8000b430 <__sfvwrite_r+0x23c>
8000b418:	06 9b       	mov	r11,r3
8000b41a:	0a 9a       	mov	r10,r5
8000b41c:	cc 9c       	rcall	8000b5ae <memmove>
8000b41e:	6e 08       	ld.w	r8,r7[0x0]
8000b420:	0a 08       	add	r8,r5
8000b422:	0e 9b       	mov	r11,r7
8000b424:	8f 08       	st.w	r7[0x0],r8
8000b426:	40 1c       	lddsp	r12,sp[0x4]
8000b428:	fe b0 fc ae 	rcall	8000ad84 <_fflush_r>
8000b42c:	c1 70       	breq	8000b45a <__sfvwrite_r+0x266>
8000b42e:	c2 58       	rjmp	8000b478 <__sfvwrite_r+0x284>
8000b430:	12 34       	cp.w	r4,r9
8000b432:	c0 a5       	brlt	8000b446 <__sfvwrite_r+0x252>
8000b434:	6e a8       	ld.w	r8,r7[0x28]
8000b436:	06 9a       	mov	r10,r3
8000b438:	6e 8b       	ld.w	r11,r7[0x20]
8000b43a:	40 1c       	lddsp	r12,sp[0x4]
8000b43c:	5d 18       	icall	r8
8000b43e:	18 95       	mov	r5,r12
8000b440:	e0 89 00 0d 	brgt	8000b45a <__sfvwrite_r+0x266>
8000b444:	c1 a8       	rjmp	8000b478 <__sfvwrite_r+0x284>
8000b446:	08 9a       	mov	r10,r4
8000b448:	06 9b       	mov	r11,r3
8000b44a:	cb 2c       	rcall	8000b5ae <memmove>
8000b44c:	6e 08       	ld.w	r8,r7[0x0]
8000b44e:	08 08       	add	r8,r4
8000b450:	08 95       	mov	r5,r4
8000b452:	8f 08       	st.w	r7[0x0],r8
8000b454:	6e 28       	ld.w	r8,r7[0x8]
8000b456:	08 18       	sub	r8,r4
8000b458:	8f 28       	st.w	r7[0x8],r8
8000b45a:	0a 16       	sub	r6,r5
8000b45c:	c0 71       	brne	8000b46a <__sfvwrite_r+0x276>
8000b45e:	0e 9b       	mov	r11,r7
8000b460:	40 1c       	lddsp	r12,sp[0x4]
8000b462:	fe b0 fc 91 	rcall	8000ad84 <_fflush_r>
8000b466:	c0 91       	brne	8000b478 <__sfvwrite_r+0x284>
8000b468:	50 06       	stdsp	sp[0x0],r6
8000b46a:	64 28       	ld.w	r8,r2[0x8]
8000b46c:	0a 18       	sub	r8,r5
8000b46e:	85 28       	st.w	r2[0x8],r8
8000b470:	c0 90       	breq	8000b482 <__sfvwrite_r+0x28e>
8000b472:	0a 11       	sub	r1,r5
8000b474:	0a 03       	add	r3,r5
8000b476:	ca 4b       	rjmp	8000b3be <__sfvwrite_r+0x1ca>
8000b478:	8e 68       	ld.sh	r8,r7[0xc]
8000b47a:	a7 a8       	sbr	r8,0x6
8000b47c:	ae 68       	st.h	r7[0xc],r8
8000b47e:	3f fc       	mov	r12,-1
8000b480:	c0 28       	rjmp	8000b484 <__sfvwrite_r+0x290>
8000b482:	30 0c       	mov	r12,0
8000b484:	2f dd       	sub	sp,-12
8000b486:	d8 32       	popm	r0-r7,pc

8000b488 <_fwalk>:
8000b488:	d4 31       	pushm	r0-r7,lr
8000b48a:	30 05       	mov	r5,0
8000b48c:	16 91       	mov	r1,r11
8000b48e:	f8 c7 ff 28 	sub	r7,r12,-216
8000b492:	0a 92       	mov	r2,r5
8000b494:	fe b0 fc fe 	rcall	8000ae90 <__sfp_lock_acquire>
8000b498:	3f f3       	mov	r3,-1
8000b49a:	c1 68       	rjmp	8000b4c6 <_fwalk+0x3e>
8000b49c:	6e 26       	ld.w	r6,r7[0x8]
8000b49e:	6e 14       	ld.w	r4,r7[0x4]
8000b4a0:	2f 46       	sub	r6,-12
8000b4a2:	c0 c8       	rjmp	8000b4ba <_fwalk+0x32>
8000b4a4:	8c 08       	ld.sh	r8,r6[0x0]
8000b4a6:	e4 08 19 00 	cp.h	r8,r2
8000b4aa:	c0 70       	breq	8000b4b8 <_fwalk+0x30>
8000b4ac:	8c 18       	ld.sh	r8,r6[0x2]
8000b4ae:	e6 08 19 00 	cp.h	r8,r3
8000b4b2:	c0 30       	breq	8000b4b8 <_fwalk+0x30>
8000b4b4:	5d 11       	icall	r1
8000b4b6:	18 45       	or	r5,r12
8000b4b8:	2a 46       	sub	r6,-92
8000b4ba:	20 14       	sub	r4,1
8000b4bc:	ec cc 00 0c 	sub	r12,r6,12
8000b4c0:	58 04       	cp.w	r4,0
8000b4c2:	cf 14       	brge	8000b4a4 <_fwalk+0x1c>
8000b4c4:	6e 07       	ld.w	r7,r7[0x0]
8000b4c6:	58 07       	cp.w	r7,0
8000b4c8:	ce a1       	brne	8000b49c <_fwalk+0x14>
8000b4ca:	fe b0 fc e4 	rcall	8000ae92 <__sfp_lock_release>
8000b4ce:	0a 9c       	mov	r12,r5
8000b4d0:	d8 32       	popm	r0-r7,pc
8000b4d2:	d7 03       	nop

8000b4d4 <_localeconv_r>:
8000b4d4:	fe cc d3 54 	sub	r12,pc,-11436
8000b4d8:	5e fc       	retal	r12
8000b4da:	d7 03       	nop

8000b4dc <__smakebuf_r>:
8000b4dc:	d4 21       	pushm	r4-r7,lr
8000b4de:	20 fd       	sub	sp,60
8000b4e0:	96 68       	ld.sh	r8,r11[0xc]
8000b4e2:	16 97       	mov	r7,r11
8000b4e4:	18 96       	mov	r6,r12
8000b4e6:	e2 18 00 02 	andl	r8,0x2,COH
8000b4ea:	c3 d1       	brne	8000b564 <__smakebuf_r+0x88>
8000b4ec:	96 7b       	ld.sh	r11,r11[0xe]
8000b4ee:	f0 0b 19 00 	cp.h	r11,r8
8000b4f2:	c0 55       	brlt	8000b4fc <__smakebuf_r+0x20>
8000b4f4:	1a 9a       	mov	r10,sp
8000b4f6:	e0 a0 04 81 	rcall	8000bdf8 <_fstat_r>
8000b4fa:	c0 f4       	brge	8000b518 <__smakebuf_r+0x3c>
8000b4fc:	8e 65       	ld.sh	r5,r7[0xc]
8000b4fe:	0a 98       	mov	r8,r5
8000b500:	ab b8       	sbr	r8,0xb
8000b502:	e2 15 00 80 	andl	r5,0x80,COH
8000b506:	ae 68       	st.h	r7[0xc],r8
8000b508:	30 04       	mov	r4,0
8000b50a:	e0 68 04 00 	mov	r8,1024
8000b50e:	f9 b5 01 40 	movne	r5,64
8000b512:	f0 05 17 00 	moveq	r5,r8
8000b516:	c1 c8       	rjmp	8000b54e <__smakebuf_r+0x72>
8000b518:	40 18       	lddsp	r8,sp[0x4]
8000b51a:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b51e:	e0 48 20 00 	cp.w	r8,8192
8000b522:	5f 04       	sreq	r4
8000b524:	e0 48 80 00 	cp.w	r8,32768
8000b528:	c0 e1       	brne	8000b544 <__smakebuf_r+0x68>
8000b52a:	6e b9       	ld.w	r9,r7[0x2c]
8000b52c:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b530:	10 39       	cp.w	r9,r8
8000b532:	c0 91       	brne	8000b544 <__smakebuf_r+0x68>
8000b534:	8e 68       	ld.sh	r8,r7[0xc]
8000b536:	e0 65 04 00 	mov	r5,1024
8000b53a:	ab a8       	sbr	r8,0xa
8000b53c:	ef 45 00 50 	st.w	r7[80],r5
8000b540:	ae 68       	st.h	r7[0xc],r8
8000b542:	c0 68       	rjmp	8000b54e <__smakebuf_r+0x72>
8000b544:	8e 68       	ld.sh	r8,r7[0xc]
8000b546:	e0 65 04 00 	mov	r5,1024
8000b54a:	ab b8       	sbr	r8,0xb
8000b54c:	ae 68       	st.h	r7[0xc],r8
8000b54e:	0a 9b       	mov	r11,r5
8000b550:	0c 9c       	mov	r12,r6
8000b552:	fe b0 df 35 	rcall	800073bc <_malloc_r>
8000b556:	8e 68       	ld.sh	r8,r7[0xc]
8000b558:	c0 d1       	brne	8000b572 <__smakebuf_r+0x96>
8000b55a:	ed b8 00 09 	bld	r8,0x9
8000b55e:	c1 b0       	breq	8000b594 <__smakebuf_r+0xb8>
8000b560:	a1 b8       	sbr	r8,0x1
8000b562:	ae 68       	st.h	r7[0xc],r8
8000b564:	ee c8 ff b9 	sub	r8,r7,-71
8000b568:	8f 48       	st.w	r7[0x10],r8
8000b56a:	8f 08       	st.w	r7[0x0],r8
8000b56c:	30 18       	mov	r8,1
8000b56e:	8f 58       	st.w	r7[0x14],r8
8000b570:	c1 28       	rjmp	8000b594 <__smakebuf_r+0xb8>
8000b572:	a7 b8       	sbr	r8,0x7
8000b574:	8f 4c       	st.w	r7[0x10],r12
8000b576:	ae 68       	st.h	r7[0xc],r8
8000b578:	8f 55       	st.w	r7[0x14],r5
8000b57a:	fe c8 06 e6 	sub	r8,pc,1766
8000b57e:	8f 0c       	st.w	r7[0x0],r12
8000b580:	8d a8       	st.w	r6[0x28],r8
8000b582:	58 04       	cp.w	r4,0
8000b584:	c0 80       	breq	8000b594 <__smakebuf_r+0xb8>
8000b586:	8e 7c       	ld.sh	r12,r7[0xe]
8000b588:	fe b0 e3 94 	rcall	80007cb0 <isatty>
8000b58c:	c0 40       	breq	8000b594 <__smakebuf_r+0xb8>
8000b58e:	8e 68       	ld.sh	r8,r7[0xc]
8000b590:	a1 a8       	sbr	r8,0x0
8000b592:	ae 68       	st.h	r7[0xc],r8
8000b594:	2f 1d       	sub	sp,-60
8000b596:	d8 22       	popm	r4-r7,pc

8000b598 <memchr>:
8000b598:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b59c:	c0 68       	rjmp	8000b5a8 <memchr+0x10>
8000b59e:	20 1a       	sub	r10,1
8000b5a0:	19 88       	ld.ub	r8,r12[0x0]
8000b5a2:	16 38       	cp.w	r8,r11
8000b5a4:	5e 0c       	reteq	r12
8000b5a6:	2f fc       	sub	r12,-1
8000b5a8:	58 0a       	cp.w	r10,0
8000b5aa:	cf a1       	brne	8000b59e <memchr+0x6>
8000b5ac:	5e fa       	retal	r10

8000b5ae <memmove>:
8000b5ae:	d4 01       	pushm	lr
8000b5b0:	18 3b       	cp.w	r11,r12
8000b5b2:	c1 92       	brcc	8000b5e4 <memmove+0x36>
8000b5b4:	f6 0a 00 09 	add	r9,r11,r10
8000b5b8:	12 3c       	cp.w	r12,r9
8000b5ba:	c1 52       	brcc	8000b5e4 <memmove+0x36>
8000b5bc:	f8 0a 00 0b 	add	r11,r12,r10
8000b5c0:	30 08       	mov	r8,0
8000b5c2:	c0 68       	rjmp	8000b5ce <memmove+0x20>
8000b5c4:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b5c8:	20 1a       	sub	r10,1
8000b5ca:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b5ce:	20 18       	sub	r8,1
8000b5d0:	58 0a       	cp.w	r10,0
8000b5d2:	cf 91       	brne	8000b5c4 <memmove+0x16>
8000b5d4:	d8 02       	popm	pc
8000b5d6:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b5da:	20 1a       	sub	r10,1
8000b5dc:	f8 08 0b 09 	st.b	r12[r8],r9
8000b5e0:	2f f8       	sub	r8,-1
8000b5e2:	c0 28       	rjmp	8000b5e6 <memmove+0x38>
8000b5e4:	30 08       	mov	r8,0
8000b5e6:	58 0a       	cp.w	r10,0
8000b5e8:	cf 71       	brne	8000b5d6 <memmove+0x28>
8000b5ea:	d8 02       	popm	pc

8000b5ec <__hi0bits>:
8000b5ec:	18 98       	mov	r8,r12
8000b5ee:	e0 1c 00 00 	andl	r12,0x0
8000b5f2:	f0 09 15 10 	lsl	r9,r8,0x10
8000b5f6:	58 0c       	cp.w	r12,0
8000b5f8:	f2 08 17 00 	moveq	r8,r9
8000b5fc:	f9 bc 00 10 	moveq	r12,16
8000b600:	f9 bc 01 00 	movne	r12,0
8000b604:	10 9a       	mov	r10,r8
8000b606:	f0 09 15 08 	lsl	r9,r8,0x8
8000b60a:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b60e:	f7 bc 00 f8 	subeq	r12,-8
8000b612:	f2 08 17 00 	moveq	r8,r9
8000b616:	10 9a       	mov	r10,r8
8000b618:	f0 09 15 04 	lsl	r9,r8,0x4
8000b61c:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b620:	f7 bc 00 fc 	subeq	r12,-4
8000b624:	f2 08 17 00 	moveq	r8,r9
8000b628:	10 9a       	mov	r10,r8
8000b62a:	f0 09 15 02 	lsl	r9,r8,0x2
8000b62e:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b632:	f7 bc 00 fe 	subeq	r12,-2
8000b636:	f2 08 17 00 	moveq	r8,r9
8000b63a:	58 08       	cp.w	r8,0
8000b63c:	5e 5c       	retlt	r12
8000b63e:	ed b8 00 1e 	bld	r8,0x1e
8000b642:	f9 bc 01 20 	movne	r12,32
8000b646:	f7 bc 00 ff 	subeq	r12,-1
8000b64a:	5e fc       	retal	r12

8000b64c <__lo0bits>:
8000b64c:	18 99       	mov	r9,r12
8000b64e:	78 08       	ld.w	r8,r12[0x0]
8000b650:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b654:	c1 50       	breq	8000b67e <__lo0bits+0x32>
8000b656:	ed b8 00 00 	bld	r8,0x0
8000b65a:	c0 21       	brne	8000b65e <__lo0bits+0x12>
8000b65c:	5e fd       	retal	0
8000b65e:	10 9b       	mov	r11,r8
8000b660:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b664:	e2 1b 00 02 	andl	r11,0x2,COH
8000b668:	a3 88       	lsr	r8,0x2
8000b66a:	58 0b       	cp.w	r11,0
8000b66c:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b670:	f9 bc 01 01 	movne	r12,1
8000b674:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b678:	f9 bc 00 02 	moveq	r12,2
8000b67c:	5e fc       	retal	r12
8000b67e:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b682:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b686:	58 0a       	cp.w	r10,0
8000b688:	f6 08 17 00 	moveq	r8,r11
8000b68c:	f9 bc 00 10 	moveq	r12,16
8000b690:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b694:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b698:	58 0b       	cp.w	r11,0
8000b69a:	f7 bc 00 f8 	subeq	r12,-8
8000b69e:	f4 08 17 00 	moveq	r8,r10
8000b6a2:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b6a6:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b6aa:	58 0b       	cp.w	r11,0
8000b6ac:	f7 bc 00 fc 	subeq	r12,-4
8000b6b0:	f4 08 17 00 	moveq	r8,r10
8000b6b4:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b6b8:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b6bc:	58 0b       	cp.w	r11,0
8000b6be:	f7 bc 00 fe 	subeq	r12,-2
8000b6c2:	f4 08 17 00 	moveq	r8,r10
8000b6c6:	ed b8 00 00 	bld	r8,0x0
8000b6ca:	c0 60       	breq	8000b6d6 <__lo0bits+0x8a>
8000b6cc:	a1 98       	lsr	r8,0x1
8000b6ce:	c0 31       	brne	8000b6d4 <__lo0bits+0x88>
8000b6d0:	32 0c       	mov	r12,32
8000b6d2:	5e fc       	retal	r12
8000b6d4:	2f fc       	sub	r12,-1
8000b6d6:	93 08       	st.w	r9[0x0],r8
8000b6d8:	5e fc       	retal	r12

8000b6da <__mcmp>:
8000b6da:	d4 01       	pushm	lr
8000b6dc:	18 98       	mov	r8,r12
8000b6de:	76 49       	ld.w	r9,r11[0x10]
8000b6e0:	78 4c       	ld.w	r12,r12[0x10]
8000b6e2:	12 1c       	sub	r12,r9
8000b6e4:	c1 31       	brne	8000b70a <__mcmp+0x30>
8000b6e6:	2f b9       	sub	r9,-5
8000b6e8:	a3 69       	lsl	r9,0x2
8000b6ea:	12 0b       	add	r11,r9
8000b6ec:	f0 09 00 09 	add	r9,r8,r9
8000b6f0:	2e c8       	sub	r8,-20
8000b6f2:	13 4e       	ld.w	lr,--r9
8000b6f4:	17 4a       	ld.w	r10,--r11
8000b6f6:	14 3e       	cp.w	lr,r10
8000b6f8:	c0 60       	breq	8000b704 <__mcmp+0x2a>
8000b6fa:	f9 bc 03 ff 	movlo	r12,-1
8000b6fe:	f9 bc 02 01 	movhs	r12,1
8000b702:	d8 02       	popm	pc
8000b704:	10 39       	cp.w	r9,r8
8000b706:	fe 9b ff f6 	brhi	8000b6f2 <__mcmp+0x18>
8000b70a:	d8 02       	popm	pc

8000b70c <_Bfree>:
8000b70c:	d4 21       	pushm	r4-r7,lr
8000b70e:	18 97       	mov	r7,r12
8000b710:	16 95       	mov	r5,r11
8000b712:	78 96       	ld.w	r6,r12[0x24]
8000b714:	58 06       	cp.w	r6,0
8000b716:	c0 91       	brne	8000b728 <_Bfree+0x1c>
8000b718:	31 0c       	mov	r12,16
8000b71a:	fe b0 de 49 	rcall	800073ac <malloc>
8000b71e:	99 36       	st.w	r12[0xc],r6
8000b720:	8f 9c       	st.w	r7[0x24],r12
8000b722:	99 16       	st.w	r12[0x4],r6
8000b724:	99 26       	st.w	r12[0x8],r6
8000b726:	99 06       	st.w	r12[0x0],r6
8000b728:	58 05       	cp.w	r5,0
8000b72a:	c0 90       	breq	8000b73c <_Bfree+0x30>
8000b72c:	6a 19       	ld.w	r9,r5[0x4]
8000b72e:	6e 98       	ld.w	r8,r7[0x24]
8000b730:	70 38       	ld.w	r8,r8[0xc]
8000b732:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b736:	8b 0a       	st.w	r5[0x0],r10
8000b738:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b73c:	d8 22       	popm	r4-r7,pc
8000b73e:	d7 03       	nop

8000b740 <_Balloc>:
8000b740:	d4 21       	pushm	r4-r7,lr
8000b742:	18 97       	mov	r7,r12
8000b744:	16 96       	mov	r6,r11
8000b746:	78 95       	ld.w	r5,r12[0x24]
8000b748:	58 05       	cp.w	r5,0
8000b74a:	c0 91       	brne	8000b75c <_Balloc+0x1c>
8000b74c:	31 0c       	mov	r12,16
8000b74e:	fe b0 de 2f 	rcall	800073ac <malloc>
8000b752:	99 35       	st.w	r12[0xc],r5
8000b754:	8f 9c       	st.w	r7[0x24],r12
8000b756:	99 15       	st.w	r12[0x4],r5
8000b758:	99 25       	st.w	r12[0x8],r5
8000b75a:	99 05       	st.w	r12[0x0],r5
8000b75c:	6e 95       	ld.w	r5,r7[0x24]
8000b75e:	6a 38       	ld.w	r8,r5[0xc]
8000b760:	58 08       	cp.w	r8,0
8000b762:	c0 b1       	brne	8000b778 <_Balloc+0x38>
8000b764:	31 0a       	mov	r10,16
8000b766:	30 4b       	mov	r11,4
8000b768:	0e 9c       	mov	r12,r7
8000b76a:	e0 a0 02 a7 	rcall	8000bcb8 <_calloc_r>
8000b76e:	8b 3c       	st.w	r5[0xc],r12
8000b770:	6e 98       	ld.w	r8,r7[0x24]
8000b772:	70 3c       	ld.w	r12,r8[0xc]
8000b774:	58 0c       	cp.w	r12,0
8000b776:	c1 b0       	breq	8000b7ac <_Balloc+0x6c>
8000b778:	6e 98       	ld.w	r8,r7[0x24]
8000b77a:	70 38       	ld.w	r8,r8[0xc]
8000b77c:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b780:	70 0c       	ld.w	r12,r8[0x0]
8000b782:	58 0c       	cp.w	r12,0
8000b784:	c0 40       	breq	8000b78c <_Balloc+0x4c>
8000b786:	78 09       	ld.w	r9,r12[0x0]
8000b788:	91 09       	st.w	r8[0x0],r9
8000b78a:	c0 e8       	rjmp	8000b7a6 <_Balloc+0x66>
8000b78c:	0e 9c       	mov	r12,r7
8000b78e:	30 17       	mov	r7,1
8000b790:	0e 9b       	mov	r11,r7
8000b792:	ee 06 09 47 	lsl	r7,r7,r6
8000b796:	ee ca ff fb 	sub	r10,r7,-5
8000b79a:	a3 6a       	lsl	r10,0x2
8000b79c:	e0 a0 02 8e 	rcall	8000bcb8 <_calloc_r>
8000b7a0:	c0 60       	breq	8000b7ac <_Balloc+0x6c>
8000b7a2:	99 16       	st.w	r12[0x4],r6
8000b7a4:	99 27       	st.w	r12[0x8],r7
8000b7a6:	30 08       	mov	r8,0
8000b7a8:	99 38       	st.w	r12[0xc],r8
8000b7aa:	99 48       	st.w	r12[0x10],r8
8000b7ac:	d8 22       	popm	r4-r7,pc
8000b7ae:	d7 03       	nop

8000b7b0 <__d2b>:
8000b7b0:	d4 31       	pushm	r0-r7,lr
8000b7b2:	20 2d       	sub	sp,8
8000b7b4:	16 93       	mov	r3,r11
8000b7b6:	12 96       	mov	r6,r9
8000b7b8:	10 95       	mov	r5,r8
8000b7ba:	14 92       	mov	r2,r10
8000b7bc:	30 1b       	mov	r11,1
8000b7be:	cc 1f       	rcall	8000b740 <_Balloc>
8000b7c0:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b7c4:	50 09       	stdsp	sp[0x0],r9
8000b7c6:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b7ca:	b5 a9       	sbr	r9,0x14
8000b7cc:	f0 01 16 14 	lsr	r1,r8,0x14
8000b7d0:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b7d4:	18 94       	mov	r4,r12
8000b7d6:	58 02       	cp.w	r2,0
8000b7d8:	c1 d0       	breq	8000b812 <__d2b+0x62>
8000b7da:	fa cc ff f8 	sub	r12,sp,-8
8000b7de:	18 d2       	st.w	--r12,r2
8000b7e0:	c3 6f       	rcall	8000b64c <__lo0bits>
8000b7e2:	40 18       	lddsp	r8,sp[0x4]
8000b7e4:	c0 d0       	breq	8000b7fe <__d2b+0x4e>
8000b7e6:	40 09       	lddsp	r9,sp[0x0]
8000b7e8:	f8 0a 11 20 	rsub	r10,r12,32
8000b7ec:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b7f0:	f5 e8 10 08 	or	r8,r10,r8
8000b7f4:	89 58       	st.w	r4[0x14],r8
8000b7f6:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b7fa:	50 09       	stdsp	sp[0x0],r9
8000b7fc:	c0 28       	rjmp	8000b800 <__d2b+0x50>
8000b7fe:	89 58       	st.w	r4[0x14],r8
8000b800:	40 08       	lddsp	r8,sp[0x0]
8000b802:	58 08       	cp.w	r8,0
8000b804:	f9 b3 01 02 	movne	r3,2
8000b808:	f9 b3 00 01 	moveq	r3,1
8000b80c:	89 68       	st.w	r4[0x18],r8
8000b80e:	89 43       	st.w	r4[0x10],r3
8000b810:	c0 88       	rjmp	8000b820 <__d2b+0x70>
8000b812:	1a 9c       	mov	r12,sp
8000b814:	c1 cf       	rcall	8000b64c <__lo0bits>
8000b816:	30 13       	mov	r3,1
8000b818:	40 08       	lddsp	r8,sp[0x0]
8000b81a:	2e 0c       	sub	r12,-32
8000b81c:	89 43       	st.w	r4[0x10],r3
8000b81e:	89 58       	st.w	r4[0x14],r8
8000b820:	58 01       	cp.w	r1,0
8000b822:	c0 90       	breq	8000b834 <__d2b+0x84>
8000b824:	e2 c1 04 33 	sub	r1,r1,1075
8000b828:	18 01       	add	r1,r12
8000b82a:	8d 01       	st.w	r6[0x0],r1
8000b82c:	f8 0c 11 35 	rsub	r12,r12,53
8000b830:	8b 0c       	st.w	r5[0x0],r12
8000b832:	c0 c8       	rjmp	8000b84a <__d2b+0x9a>
8000b834:	e6 c8 ff fc 	sub	r8,r3,-4
8000b838:	f8 cc 04 32 	sub	r12,r12,1074
8000b83c:	a5 73       	lsl	r3,0x5
8000b83e:	8d 0c       	st.w	r6[0x0],r12
8000b840:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b844:	cd 4e       	rcall	8000b5ec <__hi0bits>
8000b846:	18 13       	sub	r3,r12
8000b848:	8b 03       	st.w	r5[0x0],r3
8000b84a:	08 9c       	mov	r12,r4
8000b84c:	2f ed       	sub	sp,-8
8000b84e:	d8 32       	popm	r0-r7,pc

8000b850 <__mdiff>:
8000b850:	d4 31       	pushm	r0-r7,lr
8000b852:	74 48       	ld.w	r8,r10[0x10]
8000b854:	76 45       	ld.w	r5,r11[0x10]
8000b856:	16 97       	mov	r7,r11
8000b858:	14 96       	mov	r6,r10
8000b85a:	10 15       	sub	r5,r8
8000b85c:	c1 31       	brne	8000b882 <__mdiff+0x32>
8000b85e:	2f b8       	sub	r8,-5
8000b860:	ee ce ff ec 	sub	lr,r7,-20
8000b864:	a3 68       	lsl	r8,0x2
8000b866:	f4 08 00 0b 	add	r11,r10,r8
8000b86a:	ee 08 00 08 	add	r8,r7,r8
8000b86e:	11 4a       	ld.w	r10,--r8
8000b870:	17 49       	ld.w	r9,--r11
8000b872:	12 3a       	cp.w	r10,r9
8000b874:	c0 30       	breq	8000b87a <__mdiff+0x2a>
8000b876:	c0 e2       	brcc	8000b892 <__mdiff+0x42>
8000b878:	c0 78       	rjmp	8000b886 <__mdiff+0x36>
8000b87a:	1c 38       	cp.w	r8,lr
8000b87c:	fe 9b ff f9 	brhi	8000b86e <__mdiff+0x1e>
8000b880:	c4 98       	rjmp	8000b912 <__mdiff+0xc2>
8000b882:	58 05       	cp.w	r5,0
8000b884:	c0 64       	brge	8000b890 <__mdiff+0x40>
8000b886:	0e 98       	mov	r8,r7
8000b888:	30 15       	mov	r5,1
8000b88a:	0c 97       	mov	r7,r6
8000b88c:	10 96       	mov	r6,r8
8000b88e:	c0 28       	rjmp	8000b892 <__mdiff+0x42>
8000b890:	30 05       	mov	r5,0
8000b892:	6e 1b       	ld.w	r11,r7[0x4]
8000b894:	c5 6f       	rcall	8000b740 <_Balloc>
8000b896:	6e 49       	ld.w	r9,r7[0x10]
8000b898:	6c 44       	ld.w	r4,r6[0x10]
8000b89a:	99 35       	st.w	r12[0xc],r5
8000b89c:	2f b4       	sub	r4,-5
8000b89e:	f2 c5 ff fb 	sub	r5,r9,-5
8000b8a2:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b8a6:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b8aa:	2e c6       	sub	r6,-20
8000b8ac:	2e c7       	sub	r7,-20
8000b8ae:	f8 c8 ff ec 	sub	r8,r12,-20
8000b8b2:	30 0a       	mov	r10,0
8000b8b4:	0f 0e       	ld.w	lr,r7++
8000b8b6:	0d 0b       	ld.w	r11,r6++
8000b8b8:	fc 02 16 10 	lsr	r2,lr,0x10
8000b8bc:	f6 03 16 10 	lsr	r3,r11,0x10
8000b8c0:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b8c4:	e4 03 01 03 	sub	r3,r2,r3
8000b8c8:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b8cc:	fc 0b 01 0b 	sub	r11,lr,r11
8000b8d0:	f6 0a 00 0a 	add	r10,r11,r10
8000b8d4:	b0 1a       	st.h	r8[0x2],r10
8000b8d6:	b1 4a       	asr	r10,0x10
8000b8d8:	e6 0a 00 0a 	add	r10,r3,r10
8000b8dc:	b0 0a       	st.h	r8[0x0],r10
8000b8de:	2f c8       	sub	r8,-4
8000b8e0:	b1 4a       	asr	r10,0x10
8000b8e2:	08 36       	cp.w	r6,r4
8000b8e4:	ce 83       	brcs	8000b8b4 <__mdiff+0x64>
8000b8e6:	c0 d8       	rjmp	8000b900 <__mdiff+0xb0>
8000b8e8:	0f 0b       	ld.w	r11,r7++
8000b8ea:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b8ee:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b8f2:	16 0a       	add	r10,r11
8000b8f4:	b0 1a       	st.h	r8[0x2],r10
8000b8f6:	b1 4a       	asr	r10,0x10
8000b8f8:	1c 0a       	add	r10,lr
8000b8fa:	b0 0a       	st.h	r8[0x0],r10
8000b8fc:	2f c8       	sub	r8,-4
8000b8fe:	b1 4a       	asr	r10,0x10
8000b900:	0a 37       	cp.w	r7,r5
8000b902:	cf 33       	brcs	8000b8e8 <__mdiff+0x98>
8000b904:	c0 28       	rjmp	8000b908 <__mdiff+0xb8>
8000b906:	20 19       	sub	r9,1
8000b908:	11 4a       	ld.w	r10,--r8
8000b90a:	58 0a       	cp.w	r10,0
8000b90c:	cf d0       	breq	8000b906 <__mdiff+0xb6>
8000b90e:	99 49       	st.w	r12[0x10],r9
8000b910:	d8 32       	popm	r0-r7,pc
8000b912:	30 0b       	mov	r11,0
8000b914:	c1 6f       	rcall	8000b740 <_Balloc>
8000b916:	30 18       	mov	r8,1
8000b918:	99 48       	st.w	r12[0x10],r8
8000b91a:	30 08       	mov	r8,0
8000b91c:	99 58       	st.w	r12[0x14],r8
8000b91e:	d8 32       	popm	r0-r7,pc

8000b920 <__lshift>:
8000b920:	d4 31       	pushm	r0-r7,lr
8000b922:	16 97       	mov	r7,r11
8000b924:	76 46       	ld.w	r6,r11[0x10]
8000b926:	f4 02 14 05 	asr	r2,r10,0x5
8000b92a:	2f f6       	sub	r6,-1
8000b92c:	14 93       	mov	r3,r10
8000b92e:	18 94       	mov	r4,r12
8000b930:	04 06       	add	r6,r2
8000b932:	76 1b       	ld.w	r11,r11[0x4]
8000b934:	6e 28       	ld.w	r8,r7[0x8]
8000b936:	c0 38       	rjmp	8000b93c <__lshift+0x1c>
8000b938:	2f fb       	sub	r11,-1
8000b93a:	a1 78       	lsl	r8,0x1
8000b93c:	10 36       	cp.w	r6,r8
8000b93e:	fe 99 ff fd 	brgt	8000b938 <__lshift+0x18>
8000b942:	08 9c       	mov	r12,r4
8000b944:	cf ee       	rcall	8000b740 <_Balloc>
8000b946:	30 09       	mov	r9,0
8000b948:	18 95       	mov	r5,r12
8000b94a:	f8 c8 ff ec 	sub	r8,r12,-20
8000b94e:	12 9a       	mov	r10,r9
8000b950:	c0 38       	rjmp	8000b956 <__lshift+0x36>
8000b952:	10 aa       	st.w	r8++,r10
8000b954:	2f f9       	sub	r9,-1
8000b956:	04 39       	cp.w	r9,r2
8000b958:	cf d5       	brlt	8000b952 <__lshift+0x32>
8000b95a:	6e 4b       	ld.w	r11,r7[0x10]
8000b95c:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b960:	2f bb       	sub	r11,-5
8000b962:	ee c9 ff ec 	sub	r9,r7,-20
8000b966:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b96a:	58 03       	cp.w	r3,0
8000b96c:	c1 30       	breq	8000b992 <__lshift+0x72>
8000b96e:	e6 0c 11 20 	rsub	r12,r3,32
8000b972:	30 0a       	mov	r10,0
8000b974:	72 02       	ld.w	r2,r9[0x0]
8000b976:	e4 03 09 42 	lsl	r2,r2,r3
8000b97a:	04 4a       	or	r10,r2
8000b97c:	10 aa       	st.w	r8++,r10
8000b97e:	13 0a       	ld.w	r10,r9++
8000b980:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b984:	16 39       	cp.w	r9,r11
8000b986:	cf 73       	brcs	8000b974 <__lshift+0x54>
8000b988:	91 0a       	st.w	r8[0x0],r10
8000b98a:	58 0a       	cp.w	r10,0
8000b98c:	c0 70       	breq	8000b99a <__lshift+0x7a>
8000b98e:	2f f6       	sub	r6,-1
8000b990:	c0 58       	rjmp	8000b99a <__lshift+0x7a>
8000b992:	13 0a       	ld.w	r10,r9++
8000b994:	10 aa       	st.w	r8++,r10
8000b996:	16 39       	cp.w	r9,r11
8000b998:	cf d3       	brcs	8000b992 <__lshift+0x72>
8000b99a:	08 9c       	mov	r12,r4
8000b99c:	20 16       	sub	r6,1
8000b99e:	0e 9b       	mov	r11,r7
8000b9a0:	8b 46       	st.w	r5[0x10],r6
8000b9a2:	cb 5e       	rcall	8000b70c <_Bfree>
8000b9a4:	0a 9c       	mov	r12,r5
8000b9a6:	d8 32       	popm	r0-r7,pc

8000b9a8 <__multiply>:
8000b9a8:	d4 31       	pushm	r0-r7,lr
8000b9aa:	20 2d       	sub	sp,8
8000b9ac:	76 49       	ld.w	r9,r11[0x10]
8000b9ae:	74 48       	ld.w	r8,r10[0x10]
8000b9b0:	16 96       	mov	r6,r11
8000b9b2:	14 95       	mov	r5,r10
8000b9b4:	10 39       	cp.w	r9,r8
8000b9b6:	ec 08 17 50 	movlt	r8,r6
8000b9ba:	ea 06 17 50 	movlt	r6,r5
8000b9be:	f0 05 17 50 	movlt	r5,r8
8000b9c2:	6c 28       	ld.w	r8,r6[0x8]
8000b9c4:	76 43       	ld.w	r3,r11[0x10]
8000b9c6:	74 42       	ld.w	r2,r10[0x10]
8000b9c8:	76 1b       	ld.w	r11,r11[0x4]
8000b9ca:	e4 03 00 07 	add	r7,r2,r3
8000b9ce:	10 37       	cp.w	r7,r8
8000b9d0:	f7 bb 09 ff 	subgt	r11,-1
8000b9d4:	cb 6e       	rcall	8000b740 <_Balloc>
8000b9d6:	ee c4 ff fb 	sub	r4,r7,-5
8000b9da:	f8 c9 ff ec 	sub	r9,r12,-20
8000b9de:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b9e2:	30 0a       	mov	r10,0
8000b9e4:	12 98       	mov	r8,r9
8000b9e6:	c0 28       	rjmp	8000b9ea <__multiply+0x42>
8000b9e8:	10 aa       	st.w	r8++,r10
8000b9ea:	08 38       	cp.w	r8,r4
8000b9ec:	cf e3       	brcs	8000b9e8 <__multiply+0x40>
8000b9ee:	2f b3       	sub	r3,-5
8000b9f0:	2f b2       	sub	r2,-5
8000b9f2:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b9f6:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b9fa:	ec cb ff ec 	sub	r11,r6,-20
8000b9fe:	50 12       	stdsp	sp[0x4],r2
8000ba00:	ea ca ff ec 	sub	r10,r5,-20
8000ba04:	c4 48       	rjmp	8000ba8c <__multiply+0xe4>
8000ba06:	94 95       	ld.uh	r5,r10[0x2]
8000ba08:	58 05       	cp.w	r5,0
8000ba0a:	c2 00       	breq	8000ba4a <__multiply+0xa2>
8000ba0c:	12 98       	mov	r8,r9
8000ba0e:	16 96       	mov	r6,r11
8000ba10:	30 0e       	mov	lr,0
8000ba12:	50 09       	stdsp	sp[0x0],r9
8000ba14:	0d 02       	ld.w	r2,r6++
8000ba16:	e4 00 16 10 	lsr	r0,r2,0x10
8000ba1a:	70 01       	ld.w	r1,r8[0x0]
8000ba1c:	70 09       	ld.w	r9,r8[0x0]
8000ba1e:	b1 81       	lsr	r1,0x10
8000ba20:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000ba24:	e0 05 03 41 	mac	r1,r0,r5
8000ba28:	ab 32       	mul	r2,r5
8000ba2a:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000ba2e:	00 02       	add	r2,r0
8000ba30:	e4 0e 00 0e 	add	lr,r2,lr
8000ba34:	b0 1e       	st.h	r8[0x2],lr
8000ba36:	b1 8e       	lsr	lr,0x10
8000ba38:	1c 01       	add	r1,lr
8000ba3a:	b0 01       	st.h	r8[0x0],r1
8000ba3c:	e2 0e 16 10 	lsr	lr,r1,0x10
8000ba40:	2f c8       	sub	r8,-4
8000ba42:	06 36       	cp.w	r6,r3
8000ba44:	ce 83       	brcs	8000ba14 <__multiply+0x6c>
8000ba46:	40 09       	lddsp	r9,sp[0x0]
8000ba48:	91 0e       	st.w	r8[0x0],lr
8000ba4a:	94 86       	ld.uh	r6,r10[0x0]
8000ba4c:	58 06       	cp.w	r6,0
8000ba4e:	c1 d0       	breq	8000ba88 <__multiply+0xe0>
8000ba50:	72 02       	ld.w	r2,r9[0x0]
8000ba52:	12 98       	mov	r8,r9
8000ba54:	16 9e       	mov	lr,r11
8000ba56:	30 05       	mov	r5,0
8000ba58:	b0 12       	st.h	r8[0x2],r2
8000ba5a:	1d 01       	ld.w	r1,lr++
8000ba5c:	90 82       	ld.uh	r2,r8[0x0]
8000ba5e:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000ba62:	ad 30       	mul	r0,r6
8000ba64:	e0 02 00 02 	add	r2,r0,r2
8000ba68:	e4 05 00 05 	add	r5,r2,r5
8000ba6c:	b0 05       	st.h	r8[0x0],r5
8000ba6e:	b1 85       	lsr	r5,0x10
8000ba70:	b1 81       	lsr	r1,0x10
8000ba72:	2f c8       	sub	r8,-4
8000ba74:	ad 31       	mul	r1,r6
8000ba76:	90 92       	ld.uh	r2,r8[0x2]
8000ba78:	e2 02 00 02 	add	r2,r1,r2
8000ba7c:	0a 02       	add	r2,r5
8000ba7e:	e4 05 16 10 	lsr	r5,r2,0x10
8000ba82:	06 3e       	cp.w	lr,r3
8000ba84:	ce a3       	brcs	8000ba58 <__multiply+0xb0>
8000ba86:	91 02       	st.w	r8[0x0],r2
8000ba88:	2f ca       	sub	r10,-4
8000ba8a:	2f c9       	sub	r9,-4
8000ba8c:	40 18       	lddsp	r8,sp[0x4]
8000ba8e:	10 3a       	cp.w	r10,r8
8000ba90:	cb b3       	brcs	8000ba06 <__multiply+0x5e>
8000ba92:	c0 28       	rjmp	8000ba96 <__multiply+0xee>
8000ba94:	20 17       	sub	r7,1
8000ba96:	58 07       	cp.w	r7,0
8000ba98:	e0 8a 00 05 	brle	8000baa2 <__multiply+0xfa>
8000ba9c:	09 48       	ld.w	r8,--r4
8000ba9e:	58 08       	cp.w	r8,0
8000baa0:	cf a0       	breq	8000ba94 <__multiply+0xec>
8000baa2:	99 47       	st.w	r12[0x10],r7
8000baa4:	2f ed       	sub	sp,-8
8000baa6:	d8 32       	popm	r0-r7,pc

8000baa8 <__i2b>:
8000baa8:	d4 21       	pushm	r4-r7,lr
8000baaa:	16 97       	mov	r7,r11
8000baac:	30 1b       	mov	r11,1
8000baae:	c4 9e       	rcall	8000b740 <_Balloc>
8000bab0:	30 19       	mov	r9,1
8000bab2:	99 57       	st.w	r12[0x14],r7
8000bab4:	99 49       	st.w	r12[0x10],r9
8000bab6:	d8 22       	popm	r4-r7,pc

8000bab8 <__multadd>:
8000bab8:	d4 31       	pushm	r0-r7,lr
8000baba:	30 08       	mov	r8,0
8000babc:	12 95       	mov	r5,r9
8000babe:	16 97       	mov	r7,r11
8000bac0:	18 96       	mov	r6,r12
8000bac2:	76 44       	ld.w	r4,r11[0x10]
8000bac4:	f6 c9 ff ec 	sub	r9,r11,-20
8000bac8:	72 0b       	ld.w	r11,r9[0x0]
8000baca:	f6 0c 16 10 	lsr	r12,r11,0x10
8000bace:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000bad2:	f4 0c 02 4c 	mul	r12,r10,r12
8000bad6:	f4 0b 03 45 	mac	r5,r10,r11
8000bada:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000bade:	b1 85       	lsr	r5,0x10
8000bae0:	18 05       	add	r5,r12
8000bae2:	ea 0c 15 10 	lsl	r12,r5,0x10
8000bae6:	f8 0b 00 0b 	add	r11,r12,r11
8000baea:	12 ab       	st.w	r9++,r11
8000baec:	2f f8       	sub	r8,-1
8000baee:	b1 85       	lsr	r5,0x10
8000baf0:	08 38       	cp.w	r8,r4
8000baf2:	ce b5       	brlt	8000bac8 <__multadd+0x10>
8000baf4:	58 05       	cp.w	r5,0
8000baf6:	c1 c0       	breq	8000bb2e <__multadd+0x76>
8000baf8:	6e 28       	ld.w	r8,r7[0x8]
8000bafa:	10 34       	cp.w	r4,r8
8000bafc:	c1 35       	brlt	8000bb22 <__multadd+0x6a>
8000bafe:	6e 1b       	ld.w	r11,r7[0x4]
8000bb00:	0c 9c       	mov	r12,r6
8000bb02:	2f fb       	sub	r11,-1
8000bb04:	c1 ee       	rcall	8000b740 <_Balloc>
8000bb06:	6e 4a       	ld.w	r10,r7[0x10]
8000bb08:	ee cb ff f4 	sub	r11,r7,-12
8000bb0c:	18 93       	mov	r3,r12
8000bb0e:	2f ea       	sub	r10,-2
8000bb10:	2f 4c       	sub	r12,-12
8000bb12:	a3 6a       	lsl	r10,0x2
8000bb14:	fe b0 de 70 	rcall	800077f4 <memcpy>
8000bb18:	0e 9b       	mov	r11,r7
8000bb1a:	0c 9c       	mov	r12,r6
8000bb1c:	fe b0 fd f8 	rcall	8000b70c <_Bfree>
8000bb20:	06 97       	mov	r7,r3
8000bb22:	e8 c8 ff ff 	sub	r8,r4,-1
8000bb26:	2f b4       	sub	r4,-5
8000bb28:	8f 48       	st.w	r7[0x10],r8
8000bb2a:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000bb2e:	0e 9c       	mov	r12,r7
8000bb30:	d8 32       	popm	r0-r7,pc
8000bb32:	d7 03       	nop

8000bb34 <__pow5mult>:
8000bb34:	d4 31       	pushm	r0-r7,lr
8000bb36:	14 96       	mov	r6,r10
8000bb38:	18 97       	mov	r7,r12
8000bb3a:	16 94       	mov	r4,r11
8000bb3c:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000bb40:	c0 90       	breq	8000bb52 <__pow5mult+0x1e>
8000bb42:	20 18       	sub	r8,1
8000bb44:	fe c9 d9 88 	sub	r9,pc,-9848
8000bb48:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000bb4c:	30 09       	mov	r9,0
8000bb4e:	cb 5f       	rcall	8000bab8 <__multadd>
8000bb50:	18 94       	mov	r4,r12
8000bb52:	a3 46       	asr	r6,0x2
8000bb54:	c3 40       	breq	8000bbbc <__pow5mult+0x88>
8000bb56:	6e 95       	ld.w	r5,r7[0x24]
8000bb58:	58 05       	cp.w	r5,0
8000bb5a:	c0 91       	brne	8000bb6c <__pow5mult+0x38>
8000bb5c:	31 0c       	mov	r12,16
8000bb5e:	fe b0 dc 27 	rcall	800073ac <malloc>
8000bb62:	99 35       	st.w	r12[0xc],r5
8000bb64:	8f 9c       	st.w	r7[0x24],r12
8000bb66:	99 15       	st.w	r12[0x4],r5
8000bb68:	99 25       	st.w	r12[0x8],r5
8000bb6a:	99 05       	st.w	r12[0x0],r5
8000bb6c:	6e 93       	ld.w	r3,r7[0x24]
8000bb6e:	66 25       	ld.w	r5,r3[0x8]
8000bb70:	58 05       	cp.w	r5,0
8000bb72:	c0 c1       	brne	8000bb8a <__pow5mult+0x56>
8000bb74:	e0 6b 02 71 	mov	r11,625
8000bb78:	0e 9c       	mov	r12,r7
8000bb7a:	c9 7f       	rcall	8000baa8 <__i2b>
8000bb7c:	87 2c       	st.w	r3[0x8],r12
8000bb7e:	30 08       	mov	r8,0
8000bb80:	18 95       	mov	r5,r12
8000bb82:	99 08       	st.w	r12[0x0],r8
8000bb84:	c0 38       	rjmp	8000bb8a <__pow5mult+0x56>
8000bb86:	06 9c       	mov	r12,r3
8000bb88:	18 95       	mov	r5,r12
8000bb8a:	ed b6 00 00 	bld	r6,0x0
8000bb8e:	c0 b1       	brne	8000bba4 <__pow5mult+0x70>
8000bb90:	08 9b       	mov	r11,r4
8000bb92:	0a 9a       	mov	r10,r5
8000bb94:	0e 9c       	mov	r12,r7
8000bb96:	c0 9f       	rcall	8000b9a8 <__multiply>
8000bb98:	08 9b       	mov	r11,r4
8000bb9a:	18 93       	mov	r3,r12
8000bb9c:	0e 9c       	mov	r12,r7
8000bb9e:	06 94       	mov	r4,r3
8000bba0:	fe b0 fd b6 	rcall	8000b70c <_Bfree>
8000bba4:	a1 56       	asr	r6,0x1
8000bba6:	c0 b0       	breq	8000bbbc <__pow5mult+0x88>
8000bba8:	6a 03       	ld.w	r3,r5[0x0]
8000bbaa:	58 03       	cp.w	r3,0
8000bbac:	ce d1       	brne	8000bb86 <__pow5mult+0x52>
8000bbae:	0a 9a       	mov	r10,r5
8000bbb0:	0a 9b       	mov	r11,r5
8000bbb2:	0e 9c       	mov	r12,r7
8000bbb4:	cf ae       	rcall	8000b9a8 <__multiply>
8000bbb6:	8b 0c       	st.w	r5[0x0],r12
8000bbb8:	99 03       	st.w	r12[0x0],r3
8000bbba:	ce 7b       	rjmp	8000bb88 <__pow5mult+0x54>
8000bbbc:	08 9c       	mov	r12,r4
8000bbbe:	d8 32       	popm	r0-r7,pc

8000bbc0 <__isinfd>:
8000bbc0:	14 98       	mov	r8,r10
8000bbc2:	fc 19 7f f0 	movh	r9,0x7ff0
8000bbc6:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bbca:	f0 0b 11 00 	rsub	r11,r8,0
8000bbce:	f7 e8 10 08 	or	r8,r11,r8
8000bbd2:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000bbd6:	f2 08 01 08 	sub	r8,r9,r8
8000bbda:	f0 0c 11 00 	rsub	r12,r8,0
8000bbde:	f9 e8 10 08 	or	r8,r12,r8
8000bbe2:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000bbe6:	2f fc       	sub	r12,-1
8000bbe8:	5e fc       	retal	r12

8000bbea <__isnand>:
8000bbea:	14 98       	mov	r8,r10
8000bbec:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bbf0:	f0 0c 11 00 	rsub	r12,r8,0
8000bbf4:	10 4c       	or	r12,r8
8000bbf6:	fc 18 7f f0 	movh	r8,0x7ff0
8000bbfa:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000bbfe:	f0 0c 01 0c 	sub	r12,r8,r12
8000bc02:	bf 9c       	lsr	r12,0x1f
8000bc04:	5e fc       	retal	r12
8000bc06:	d7 03       	nop

8000bc08 <__sclose>:
8000bc08:	d4 01       	pushm	lr
8000bc0a:	96 7b       	ld.sh	r11,r11[0xe]
8000bc0c:	c8 2c       	rcall	8000bd10 <_close_r>
8000bc0e:	d8 02       	popm	pc

8000bc10 <__sseek>:
8000bc10:	d4 21       	pushm	r4-r7,lr
8000bc12:	16 97       	mov	r7,r11
8000bc14:	96 7b       	ld.sh	r11,r11[0xe]
8000bc16:	c0 3d       	rcall	8000be1c <_lseek_r>
8000bc18:	8e 68       	ld.sh	r8,r7[0xc]
8000bc1a:	10 99       	mov	r9,r8
8000bc1c:	ad c8       	cbr	r8,0xc
8000bc1e:	ad a9       	sbr	r9,0xc
8000bc20:	5b fc       	cp.w	r12,-1
8000bc22:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000bc26:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000bc2a:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000bc2e:	d8 22       	popm	r4-r7,pc

8000bc30 <__swrite>:
8000bc30:	d4 21       	pushm	r4-r7,lr
8000bc32:	96 68       	ld.sh	r8,r11[0xc]
8000bc34:	16 97       	mov	r7,r11
8000bc36:	14 95       	mov	r5,r10
8000bc38:	12 94       	mov	r4,r9
8000bc3a:	e2 18 01 00 	andl	r8,0x100,COH
8000bc3e:	18 96       	mov	r6,r12
8000bc40:	c0 50       	breq	8000bc4a <__swrite+0x1a>
8000bc42:	30 29       	mov	r9,2
8000bc44:	30 0a       	mov	r10,0
8000bc46:	96 7b       	ld.sh	r11,r11[0xe]
8000bc48:	ce ac       	rcall	8000be1c <_lseek_r>
8000bc4a:	8e 68       	ld.sh	r8,r7[0xc]
8000bc4c:	ad c8       	cbr	r8,0xc
8000bc4e:	08 99       	mov	r9,r4
8000bc50:	0a 9a       	mov	r10,r5
8000bc52:	8e 7b       	ld.sh	r11,r7[0xe]
8000bc54:	0c 9c       	mov	r12,r6
8000bc56:	ae 68       	st.h	r7[0xc],r8
8000bc58:	c1 cc       	rcall	8000bc90 <_write_r>
8000bc5a:	d8 22       	popm	r4-r7,pc

8000bc5c <__sread>:
8000bc5c:	d4 21       	pushm	r4-r7,lr
8000bc5e:	16 97       	mov	r7,r11
8000bc60:	96 7b       	ld.sh	r11,r11[0xe]
8000bc62:	cf 1c       	rcall	8000be44 <_read_r>
8000bc64:	c0 65       	brlt	8000bc70 <__sread+0x14>
8000bc66:	6f 58       	ld.w	r8,r7[0x54]
8000bc68:	18 08       	add	r8,r12
8000bc6a:	ef 48 00 54 	st.w	r7[84],r8
8000bc6e:	d8 22       	popm	r4-r7,pc
8000bc70:	8e 68       	ld.sh	r8,r7[0xc]
8000bc72:	ad c8       	cbr	r8,0xc
8000bc74:	ae 68       	st.h	r7[0xc],r8
8000bc76:	d8 22       	popm	r4-r7,pc

8000bc78 <strlen>:
8000bc78:	30 09       	mov	r9,0
8000bc7a:	18 98       	mov	r8,r12
8000bc7c:	c0 28       	rjmp	8000bc80 <strlen+0x8>
8000bc7e:	2f f8       	sub	r8,-1
8000bc80:	11 8a       	ld.ub	r10,r8[0x0]
8000bc82:	f2 0a 18 00 	cp.b	r10,r9
8000bc86:	cf c1       	brne	8000bc7e <strlen+0x6>
8000bc88:	f0 0c 01 0c 	sub	r12,r8,r12
8000bc8c:	5e fc       	retal	r12
8000bc8e:	d7 03       	nop

8000bc90 <_write_r>:
8000bc90:	d4 21       	pushm	r4-r7,lr
8000bc92:	16 98       	mov	r8,r11
8000bc94:	18 97       	mov	r7,r12
8000bc96:	10 9c       	mov	r12,r8
8000bc98:	30 08       	mov	r8,0
8000bc9a:	14 9b       	mov	r11,r10
8000bc9c:	e0 66 79 ec 	mov	r6,31212
8000bca0:	12 9a       	mov	r10,r9
8000bca2:	8d 08       	st.w	r6[0x0],r8
8000bca4:	fe b0 d1 72 	rcall	80005f88 <_write>
8000bca8:	5b fc       	cp.w	r12,-1
8000bcaa:	c0 51       	brne	8000bcb4 <_write_r+0x24>
8000bcac:	6c 08       	ld.w	r8,r6[0x0]
8000bcae:	58 08       	cp.w	r8,0
8000bcb0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bcb4:	d8 22       	popm	r4-r7,pc
8000bcb6:	d7 03       	nop

8000bcb8 <_calloc_r>:
8000bcb8:	d4 21       	pushm	r4-r7,lr
8000bcba:	f4 0b 02 4b 	mul	r11,r10,r11
8000bcbe:	fe b0 db 7f 	rcall	800073bc <_malloc_r>
8000bcc2:	18 97       	mov	r7,r12
8000bcc4:	c2 30       	breq	8000bd0a <_calloc_r+0x52>
8000bcc6:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000bcca:	e0 1a ff fc 	andl	r10,0xfffc
8000bcce:	20 4a       	sub	r10,4
8000bcd0:	e0 4a 00 24 	cp.w	r10,36
8000bcd4:	e0 8b 00 18 	brhi	8000bd04 <_calloc_r+0x4c>
8000bcd8:	18 98       	mov	r8,r12
8000bcda:	59 3a       	cp.w	r10,19
8000bcdc:	e0 88 00 0f 	brls	8000bcfa <_calloc_r+0x42>
8000bce0:	30 09       	mov	r9,0
8000bce2:	10 a9       	st.w	r8++,r9
8000bce4:	10 a9       	st.w	r8++,r9
8000bce6:	59 ba       	cp.w	r10,27
8000bce8:	e0 88 00 09 	brls	8000bcfa <_calloc_r+0x42>
8000bcec:	10 a9       	st.w	r8++,r9
8000bcee:	10 a9       	st.w	r8++,r9
8000bcf0:	e0 4a 00 24 	cp.w	r10,36
8000bcf4:	c0 31       	brne	8000bcfa <_calloc_r+0x42>
8000bcf6:	10 a9       	st.w	r8++,r9
8000bcf8:	10 a9       	st.w	r8++,r9
8000bcfa:	30 09       	mov	r9,0
8000bcfc:	10 a9       	st.w	r8++,r9
8000bcfe:	91 19       	st.w	r8[0x4],r9
8000bd00:	91 09       	st.w	r8[0x0],r9
8000bd02:	c0 48       	rjmp	8000bd0a <_calloc_r+0x52>
8000bd04:	30 0b       	mov	r11,0
8000bd06:	fe b0 de 1b 	rcall	8000793c <memset>
8000bd0a:	0e 9c       	mov	r12,r7
8000bd0c:	d8 22       	popm	r4-r7,pc
8000bd0e:	d7 03       	nop

8000bd10 <_close_r>:
8000bd10:	d4 21       	pushm	r4-r7,lr
8000bd12:	30 08       	mov	r8,0
8000bd14:	18 97       	mov	r7,r12
8000bd16:	e0 66 79 ec 	mov	r6,31212
8000bd1a:	16 9c       	mov	r12,r11
8000bd1c:	8d 08       	st.w	r6[0x0],r8
8000bd1e:	fe b0 df b5 	rcall	80007c88 <_close>
8000bd22:	5b fc       	cp.w	r12,-1
8000bd24:	c0 51       	brne	8000bd2e <_close_r+0x1e>
8000bd26:	6c 08       	ld.w	r8,r6[0x0]
8000bd28:	58 08       	cp.w	r8,0
8000bd2a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bd2e:	d8 22       	popm	r4-r7,pc

8000bd30 <_fclose_r>:
8000bd30:	d4 21       	pushm	r4-r7,lr
8000bd32:	18 96       	mov	r6,r12
8000bd34:	16 97       	mov	r7,r11
8000bd36:	58 0b       	cp.w	r11,0
8000bd38:	c0 31       	brne	8000bd3e <_fclose_r+0xe>
8000bd3a:	16 95       	mov	r5,r11
8000bd3c:	c5 38       	rjmp	8000bde2 <_fclose_r+0xb2>
8000bd3e:	fe b0 f8 a9 	rcall	8000ae90 <__sfp_lock_acquire>
8000bd42:	58 06       	cp.w	r6,0
8000bd44:	c0 70       	breq	8000bd52 <_fclose_r+0x22>
8000bd46:	6c 68       	ld.w	r8,r6[0x18]
8000bd48:	58 08       	cp.w	r8,0
8000bd4a:	c0 41       	brne	8000bd52 <_fclose_r+0x22>
8000bd4c:	0c 9c       	mov	r12,r6
8000bd4e:	fe b0 f8 f3 	rcall	8000af34 <__sinit>
8000bd52:	fe c8 dc 3a 	sub	r8,pc,-9158
8000bd56:	10 37       	cp.w	r7,r8
8000bd58:	c0 31       	brne	8000bd5e <_fclose_r+0x2e>
8000bd5a:	6c 07       	ld.w	r7,r6[0x0]
8000bd5c:	c0 c8       	rjmp	8000bd74 <_fclose_r+0x44>
8000bd5e:	fe c8 dc 26 	sub	r8,pc,-9178
8000bd62:	10 37       	cp.w	r7,r8
8000bd64:	c0 31       	brne	8000bd6a <_fclose_r+0x3a>
8000bd66:	6c 17       	ld.w	r7,r6[0x4]
8000bd68:	c0 68       	rjmp	8000bd74 <_fclose_r+0x44>
8000bd6a:	fe c8 dc 12 	sub	r8,pc,-9198
8000bd6e:	10 37       	cp.w	r7,r8
8000bd70:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000bd74:	8e 69       	ld.sh	r9,r7[0xc]
8000bd76:	30 08       	mov	r8,0
8000bd78:	f0 09 19 00 	cp.h	r9,r8
8000bd7c:	c0 51       	brne	8000bd86 <_fclose_r+0x56>
8000bd7e:	fe b0 f8 8a 	rcall	8000ae92 <__sfp_lock_release>
8000bd82:	30 05       	mov	r5,0
8000bd84:	c2 f8       	rjmp	8000bde2 <_fclose_r+0xb2>
8000bd86:	0e 9b       	mov	r11,r7
8000bd88:	0c 9c       	mov	r12,r6
8000bd8a:	fe b0 f7 fd 	rcall	8000ad84 <_fflush_r>
8000bd8e:	6e c8       	ld.w	r8,r7[0x30]
8000bd90:	18 95       	mov	r5,r12
8000bd92:	58 08       	cp.w	r8,0
8000bd94:	c0 60       	breq	8000bda0 <_fclose_r+0x70>
8000bd96:	6e 8b       	ld.w	r11,r7[0x20]
8000bd98:	0c 9c       	mov	r12,r6
8000bd9a:	5d 18       	icall	r8
8000bd9c:	f9 b5 05 ff 	movlt	r5,-1
8000bda0:	8e 68       	ld.sh	r8,r7[0xc]
8000bda2:	ed b8 00 07 	bld	r8,0x7
8000bda6:	c0 51       	brne	8000bdb0 <_fclose_r+0x80>
8000bda8:	6e 4b       	ld.w	r11,r7[0x10]
8000bdaa:	0c 9c       	mov	r12,r6
8000bdac:	fe b0 f9 5e 	rcall	8000b068 <_free_r>
8000bdb0:	6e db       	ld.w	r11,r7[0x34]
8000bdb2:	58 0b       	cp.w	r11,0
8000bdb4:	c0 a0       	breq	8000bdc8 <_fclose_r+0x98>
8000bdb6:	ee c8 ff bc 	sub	r8,r7,-68
8000bdba:	10 3b       	cp.w	r11,r8
8000bdbc:	c0 40       	breq	8000bdc4 <_fclose_r+0x94>
8000bdbe:	0c 9c       	mov	r12,r6
8000bdc0:	fe b0 f9 54 	rcall	8000b068 <_free_r>
8000bdc4:	30 08       	mov	r8,0
8000bdc6:	8f d8       	st.w	r7[0x34],r8
8000bdc8:	6f 2b       	ld.w	r11,r7[0x48]
8000bdca:	58 0b       	cp.w	r11,0
8000bdcc:	c0 70       	breq	8000bdda <_fclose_r+0xaa>
8000bdce:	0c 9c       	mov	r12,r6
8000bdd0:	fe b0 f9 4c 	rcall	8000b068 <_free_r>
8000bdd4:	30 08       	mov	r8,0
8000bdd6:	ef 48 00 48 	st.w	r7[72],r8
8000bdda:	30 08       	mov	r8,0
8000bddc:	ae 68       	st.h	r7[0xc],r8
8000bdde:	fe b0 f8 5a 	rcall	8000ae92 <__sfp_lock_release>
8000bde2:	0a 9c       	mov	r12,r5
8000bde4:	d8 22       	popm	r4-r7,pc
8000bde6:	d7 03       	nop

8000bde8 <fclose>:
8000bde8:	d4 01       	pushm	lr
8000bdea:	e0 68 0a 3c 	mov	r8,2620
8000bdee:	18 9b       	mov	r11,r12
8000bdf0:	70 0c       	ld.w	r12,r8[0x0]
8000bdf2:	c9 ff       	rcall	8000bd30 <_fclose_r>
8000bdf4:	d8 02       	popm	pc
8000bdf6:	d7 03       	nop

8000bdf8 <_fstat_r>:
8000bdf8:	d4 21       	pushm	r4-r7,lr
8000bdfa:	16 98       	mov	r8,r11
8000bdfc:	18 97       	mov	r7,r12
8000bdfe:	10 9c       	mov	r12,r8
8000be00:	30 08       	mov	r8,0
8000be02:	e0 66 79 ec 	mov	r6,31212
8000be06:	14 9b       	mov	r11,r10
8000be08:	8d 08       	st.w	r6[0x0],r8
8000be0a:	fe b0 df 67 	rcall	80007cd8 <_fstat>
8000be0e:	5b fc       	cp.w	r12,-1
8000be10:	c0 51       	brne	8000be1a <_fstat_r+0x22>
8000be12:	6c 08       	ld.w	r8,r6[0x0]
8000be14:	58 08       	cp.w	r8,0
8000be16:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000be1a:	d8 22       	popm	r4-r7,pc

8000be1c <_lseek_r>:
8000be1c:	d4 21       	pushm	r4-r7,lr
8000be1e:	16 98       	mov	r8,r11
8000be20:	18 97       	mov	r7,r12
8000be22:	10 9c       	mov	r12,r8
8000be24:	30 08       	mov	r8,0
8000be26:	14 9b       	mov	r11,r10
8000be28:	e0 66 79 ec 	mov	r6,31212
8000be2c:	12 9a       	mov	r10,r9
8000be2e:	8d 08       	st.w	r6[0x0],r8
8000be30:	fe b0 df 36 	rcall	80007c9c <_lseek>
8000be34:	5b fc       	cp.w	r12,-1
8000be36:	c0 51       	brne	8000be40 <_lseek_r+0x24>
8000be38:	6c 08       	ld.w	r8,r6[0x0]
8000be3a:	58 08       	cp.w	r8,0
8000be3c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000be40:	d8 22       	popm	r4-r7,pc
8000be42:	d7 03       	nop

8000be44 <_read_r>:
8000be44:	d4 21       	pushm	r4-r7,lr
8000be46:	16 98       	mov	r8,r11
8000be48:	18 97       	mov	r7,r12
8000be4a:	10 9c       	mov	r12,r8
8000be4c:	30 08       	mov	r8,0
8000be4e:	14 9b       	mov	r11,r10
8000be50:	e0 66 79 ec 	mov	r6,31212
8000be54:	12 9a       	mov	r10,r9
8000be56:	8d 08       	st.w	r6[0x0],r8
8000be58:	fe b0 d0 78 	rcall	80005f48 <_read>
8000be5c:	5b fc       	cp.w	r12,-1
8000be5e:	c0 51       	brne	8000be68 <_read_r+0x24>
8000be60:	6c 08       	ld.w	r8,r6[0x0]
8000be62:	58 08       	cp.w	r8,0
8000be64:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000be68:	d8 22       	popm	r4-r7,pc
8000be6a:	d7 03       	nop

8000be6c <__avr32_f64_mul>:
8000be6c:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000be70:	e0 80 00 dc 	breq	8000c028 <__avr32_f64_mul_op1_zero>
8000be74:	d4 21       	pushm	r4-r7,lr
8000be76:	f7 e9 20 0e 	eor	lr,r11,r9
8000be7a:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000be7e:	30 15       	mov	r5,1
8000be80:	c4 30       	breq	8000bf06 <__avr32_f64_mul_op1_subnormal>
8000be82:	ab 6b       	lsl	r11,0xa
8000be84:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000be88:	ab 6a       	lsl	r10,0xa
8000be8a:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000be8e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000be92:	c5 c0       	breq	8000bf4a <__avr32_f64_mul_op2_subnormal>
8000be94:	a1 78       	lsl	r8,0x1
8000be96:	5c f9       	rol	r9
8000be98:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000be9c:	e0 47 07 ff 	cp.w	r7,2047
8000bea0:	c7 70       	breq	8000bf8e <__avr32_f64_mul_op_nan_or_inf>
8000bea2:	e0 46 07 ff 	cp.w	r6,2047
8000bea6:	c7 40       	breq	8000bf8e <__avr32_f64_mul_op_nan_or_inf>
8000bea8:	ee 06 00 0c 	add	r12,r7,r6
8000beac:	e0 2c 03 fe 	sub	r12,1022
8000beb0:	f6 08 06 44 	mulu.d	r4,r11,r8
8000beb4:	f4 09 07 44 	macu.d	r4,r10,r9
8000beb8:	f4 08 06 46 	mulu.d	r6,r10,r8
8000bebc:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000bec0:	08 07       	add	r7,r4
8000bec2:	f4 05 00 4a 	adc	r10,r10,r5
8000bec6:	5c 0b       	acr	r11
8000bec8:	ed bb 00 14 	bld	r11,0x14
8000becc:	c0 50       	breq	8000bed6 <__avr32_f64_mul+0x6a>
8000bece:	a1 77       	lsl	r7,0x1
8000bed0:	5c fa       	rol	r10
8000bed2:	5c fb       	rol	r11
8000bed4:	20 1c       	sub	r12,1
8000bed6:	58 0c       	cp.w	r12,0
8000bed8:	e0 8a 00 6f 	brle	8000bfb6 <__avr32_f64_mul_res_subnormal>
8000bedc:	e0 4c 07 ff 	cp.w	r12,2047
8000bee0:	e0 84 00 9c 	brge	8000c018 <__avr32_f64_mul_res_inf>
8000bee4:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000bee8:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000beec:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000bef0:	ee 17 80 00 	eorh	r7,0x8000
8000bef4:	f1 b7 04 20 	satu	r7,0x1
8000bef8:	0e 0a       	add	r10,r7
8000befa:	5c 0b       	acr	r11
8000befc:	ed be 00 1f 	bld	lr,0x1f
8000bf00:	ef bb 00 1f 	bst	r11,0x1f
8000bf04:	d8 22       	popm	r4-r7,pc

8000bf06 <__avr32_f64_mul_op1_subnormal>:
8000bf06:	e4 1b 00 0f 	andh	r11,0xf
8000bf0a:	f4 0c 12 00 	clz	r12,r10
8000bf0e:	f6 06 12 00 	clz	r6,r11
8000bf12:	f7 bc 03 e1 	sublo	r12,-31
8000bf16:	f8 06 17 30 	movlo	r6,r12
8000bf1a:	f7 b6 02 01 	subhs	r6,1
8000bf1e:	e0 46 00 20 	cp.w	r6,32
8000bf22:	c0 d4       	brge	8000bf3c <__avr32_f64_mul_op1_subnormal+0x36>
8000bf24:	ec 0c 11 20 	rsub	r12,r6,32
8000bf28:	f6 06 09 4b 	lsl	r11,r11,r6
8000bf2c:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000bf30:	18 4b       	or	r11,r12
8000bf32:	f4 06 09 4a 	lsl	r10,r10,r6
8000bf36:	20 b6       	sub	r6,11
8000bf38:	0c 17       	sub	r7,r6
8000bf3a:	ca ab       	rjmp	8000be8e <__avr32_f64_mul+0x22>
8000bf3c:	f4 06 09 4b 	lsl	r11,r10,r6
8000bf40:	c6 40       	breq	8000c008 <__avr32_f64_mul_res_zero>
8000bf42:	30 0a       	mov	r10,0
8000bf44:	20 b6       	sub	r6,11
8000bf46:	0c 17       	sub	r7,r6
8000bf48:	ca 3b       	rjmp	8000be8e <__avr32_f64_mul+0x22>

8000bf4a <__avr32_f64_mul_op2_subnormal>:
8000bf4a:	e4 19 00 0f 	andh	r9,0xf
8000bf4e:	f0 0c 12 00 	clz	r12,r8
8000bf52:	f2 05 12 00 	clz	r5,r9
8000bf56:	f7 bc 03 ea 	sublo	r12,-22
8000bf5a:	f8 05 17 30 	movlo	r5,r12
8000bf5e:	f7 b5 02 0a 	subhs	r5,10
8000bf62:	e0 45 00 20 	cp.w	r5,32
8000bf66:	c0 d4       	brge	8000bf80 <__avr32_f64_mul_op2_subnormal+0x36>
8000bf68:	ea 0c 11 20 	rsub	r12,r5,32
8000bf6c:	f2 05 09 49 	lsl	r9,r9,r5
8000bf70:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000bf74:	18 49       	or	r9,r12
8000bf76:	f0 05 09 48 	lsl	r8,r8,r5
8000bf7a:	20 25       	sub	r5,2
8000bf7c:	0a 16       	sub	r6,r5
8000bf7e:	c8 fb       	rjmp	8000be9c <__avr32_f64_mul+0x30>
8000bf80:	f0 05 09 49 	lsl	r9,r8,r5
8000bf84:	c4 20       	breq	8000c008 <__avr32_f64_mul_res_zero>
8000bf86:	30 08       	mov	r8,0
8000bf88:	20 25       	sub	r5,2
8000bf8a:	0a 16       	sub	r6,r5
8000bf8c:	c8 8b       	rjmp	8000be9c <__avr32_f64_mul+0x30>

8000bf8e <__avr32_f64_mul_op_nan_or_inf>:
8000bf8e:	e4 19 00 0f 	andh	r9,0xf
8000bf92:	e4 1b 00 0f 	andh	r11,0xf
8000bf96:	14 4b       	or	r11,r10
8000bf98:	10 49       	or	r9,r8
8000bf9a:	e0 47 07 ff 	cp.w	r7,2047
8000bf9e:	c0 91       	brne	8000bfb0 <__avr32_f64_mul_op1_not_naninf>
8000bfa0:	58 0b       	cp.w	r11,0
8000bfa2:	c3 81       	brne	8000c012 <__avr32_f64_mul_res_nan>
8000bfa4:	e0 46 07 ff 	cp.w	r6,2047
8000bfa8:	c3 81       	brne	8000c018 <__avr32_f64_mul_res_inf>
8000bfaa:	58 09       	cp.w	r9,0
8000bfac:	c3 60       	breq	8000c018 <__avr32_f64_mul_res_inf>
8000bfae:	c3 28       	rjmp	8000c012 <__avr32_f64_mul_res_nan>

8000bfb0 <__avr32_f64_mul_op1_not_naninf>:
8000bfb0:	58 09       	cp.w	r9,0
8000bfb2:	c3 30       	breq	8000c018 <__avr32_f64_mul_res_inf>
8000bfb4:	c2 f8       	rjmp	8000c012 <__avr32_f64_mul_res_nan>

8000bfb6 <__avr32_f64_mul_res_subnormal>:
8000bfb6:	5c 3c       	neg	r12
8000bfb8:	2f fc       	sub	r12,-1
8000bfba:	f1 bc 04 c0 	satu	r12,0x6
8000bfbe:	e0 4c 00 20 	cp.w	r12,32
8000bfc2:	c1 14       	brge	8000bfe4 <__avr32_f64_mul_res_subnormal+0x2e>
8000bfc4:	f8 08 11 20 	rsub	r8,r12,32
8000bfc8:	0e 46       	or	r6,r7
8000bfca:	ee 0c 0a 47 	lsr	r7,r7,r12
8000bfce:	f4 08 09 49 	lsl	r9,r10,r8
8000bfd2:	12 47       	or	r7,r9
8000bfd4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bfd8:	f6 08 09 49 	lsl	r9,r11,r8
8000bfdc:	12 4a       	or	r10,r9
8000bfde:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bfe2:	c8 3b       	rjmp	8000bee8 <__avr32_f64_mul+0x7c>
8000bfe4:	f8 08 11 20 	rsub	r8,r12,32
8000bfe8:	f9 b9 00 00 	moveq	r9,0
8000bfec:	c0 30       	breq	8000bff2 <__avr32_f64_mul_res_subnormal+0x3c>
8000bfee:	f6 08 09 49 	lsl	r9,r11,r8
8000bff2:	0e 46       	or	r6,r7
8000bff4:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000bff8:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bffc:	f3 ea 10 07 	or	r7,r9,r10
8000c000:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000c004:	30 0b       	mov	r11,0
8000c006:	c7 1b       	rjmp	8000bee8 <__avr32_f64_mul+0x7c>

8000c008 <__avr32_f64_mul_res_zero>:
8000c008:	1c 9b       	mov	r11,lr
8000c00a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c00e:	30 0a       	mov	r10,0
8000c010:	d8 22       	popm	r4-r7,pc

8000c012 <__avr32_f64_mul_res_nan>:
8000c012:	3f fb       	mov	r11,-1
8000c014:	3f fa       	mov	r10,-1
8000c016:	d8 22       	popm	r4-r7,pc

8000c018 <__avr32_f64_mul_res_inf>:
8000c018:	f0 6b 00 00 	mov	r11,-1048576
8000c01c:	ed be 00 1f 	bld	lr,0x1f
8000c020:	ef bb 00 1f 	bst	r11,0x1f
8000c024:	30 0a       	mov	r10,0
8000c026:	d8 22       	popm	r4-r7,pc

8000c028 <__avr32_f64_mul_op1_zero>:
8000c028:	f7 e9 20 0b 	eor	r11,r11,r9
8000c02c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c030:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000c034:	e0 4c 07 ff 	cp.w	r12,2047
8000c038:	5e 1c       	retne	r12
8000c03a:	3f fa       	mov	r10,-1
8000c03c:	3f fb       	mov	r11,-1
8000c03e:	5e fc       	retal	r12

8000c040 <__avr32_f64_sub_from_add>:
8000c040:	ee 19 80 00 	eorh	r9,0x8000

8000c044 <__avr32_f64_sub>:
8000c044:	f7 e9 20 0c 	eor	r12,r11,r9
8000c048:	e0 86 00 ca 	brmi	8000c1dc <__avr32_f64_add_from_sub>
8000c04c:	eb cd 40 e0 	pushm	r5-r7,lr
8000c050:	16 9c       	mov	r12,r11
8000c052:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c056:	bf db       	cbr	r11,0x1f
8000c058:	bf d9       	cbr	r9,0x1f
8000c05a:	10 3a       	cp.w	r10,r8
8000c05c:	f2 0b 13 00 	cpc	r11,r9
8000c060:	c0 92       	brcc	8000c072 <__avr32_f64_sub+0x2e>
8000c062:	16 97       	mov	r7,r11
8000c064:	12 9b       	mov	r11,r9
8000c066:	0e 99       	mov	r9,r7
8000c068:	14 97       	mov	r7,r10
8000c06a:	10 9a       	mov	r10,r8
8000c06c:	0e 98       	mov	r8,r7
8000c06e:	ee 1c 80 00 	eorh	r12,0x8000
8000c072:	f6 07 16 14 	lsr	r7,r11,0x14
8000c076:	ab 7b       	lsl	r11,0xb
8000c078:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c07c:	ab 7a       	lsl	r10,0xb
8000c07e:	bf bb       	sbr	r11,0x1f
8000c080:	f2 06 16 14 	lsr	r6,r9,0x14
8000c084:	c4 40       	breq	8000c10c <__avr32_f64_sub_opL_subnormal>
8000c086:	ab 79       	lsl	r9,0xb
8000c088:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c08c:	ab 78       	lsl	r8,0xb
8000c08e:	bf b9       	sbr	r9,0x1f

8000c090 <__avr32_f64_sub_opL_subnormal_done>:
8000c090:	e0 47 07 ff 	cp.w	r7,2047
8000c094:	c4 f0       	breq	8000c132 <__avr32_f64_sub_opH_nan_or_inf>
8000c096:	0e 26       	rsub	r6,r7
8000c098:	c1 20       	breq	8000c0bc <__avr32_f64_sub_shift_done>
8000c09a:	ec 05 11 20 	rsub	r5,r6,32
8000c09e:	e0 46 00 20 	cp.w	r6,32
8000c0a2:	c7 c2       	brcc	8000c19a <__avr32_f64_sub_longshift>
8000c0a4:	f0 05 09 4e 	lsl	lr,r8,r5
8000c0a8:	f2 05 09 45 	lsl	r5,r9,r5
8000c0ac:	f0 06 0a 48 	lsr	r8,r8,r6
8000c0b0:	f2 06 0a 49 	lsr	r9,r9,r6
8000c0b4:	0a 48       	or	r8,r5
8000c0b6:	58 0e       	cp.w	lr,0
8000c0b8:	5f 1e       	srne	lr
8000c0ba:	1c 48       	or	r8,lr

8000c0bc <__avr32_f64_sub_shift_done>:
8000c0bc:	10 1a       	sub	r10,r8
8000c0be:	f6 09 01 4b 	sbc	r11,r11,r9
8000c0c2:	f6 06 12 00 	clz	r6,r11
8000c0c6:	c0 e0       	breq	8000c0e2 <__avr32_f64_sub_longnormalize_done>
8000c0c8:	c7 83       	brcs	8000c1b8 <__avr32_f64_sub_longnormalize>
8000c0ca:	ec 0e 11 20 	rsub	lr,r6,32
8000c0ce:	f6 06 09 4b 	lsl	r11,r11,r6
8000c0d2:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c0d6:	1c 4b       	or	r11,lr
8000c0d8:	f4 06 09 4a 	lsl	r10,r10,r6
8000c0dc:	0c 17       	sub	r7,r6
8000c0de:	e0 8a 00 39 	brle	8000c150 <__avr32_f64_sub_subnormal_result>

8000c0e2 <__avr32_f64_sub_longnormalize_done>:
8000c0e2:	f4 09 15 15 	lsl	r9,r10,0x15
8000c0e6:	ab 9a       	lsr	r10,0xb
8000c0e8:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c0ec:	ab 9b       	lsr	r11,0xb
8000c0ee:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c0f2:	18 4b       	or	r11,r12

8000c0f4 <__avr32_f64_sub_round>:
8000c0f4:	fc 17 80 00 	movh	r7,0x8000
8000c0f8:	ed ba 00 00 	bld	r10,0x0
8000c0fc:	f7 b7 01 ff 	subne	r7,-1
8000c100:	0e 39       	cp.w	r9,r7
8000c102:	5f 29       	srhs	r9
8000c104:	12 0a       	add	r10,r9
8000c106:	5c 0b       	acr	r11
8000c108:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c10c <__avr32_f64_sub_opL_subnormal>:
8000c10c:	ab 79       	lsl	r9,0xb
8000c10e:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c112:	ab 78       	lsl	r8,0xb
8000c114:	f3 e8 10 0e 	or	lr,r9,r8
8000c118:	f9 b6 01 01 	movne	r6,1
8000c11c:	ee 0e 11 00 	rsub	lr,r7,0
8000c120:	f9 b7 00 01 	moveq	r7,1
8000c124:	ef bb 00 1f 	bst	r11,0x1f
8000c128:	f7 ea 10 0e 	or	lr,r11,r10
8000c12c:	f9 b7 00 00 	moveq	r7,0
8000c130:	cb 0b       	rjmp	8000c090 <__avr32_f64_sub_opL_subnormal_done>

8000c132 <__avr32_f64_sub_opH_nan_or_inf>:
8000c132:	bf db       	cbr	r11,0x1f
8000c134:	f7 ea 10 0e 	or	lr,r11,r10
8000c138:	c0 81       	brne	8000c148 <__avr32_f64_sub_return_nan>
8000c13a:	e0 46 07 ff 	cp.w	r6,2047
8000c13e:	c0 50       	breq	8000c148 <__avr32_f64_sub_return_nan>
8000c140:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000c144:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c148 <__avr32_f64_sub_return_nan>:
8000c148:	3f fa       	mov	r10,-1
8000c14a:	3f fb       	mov	r11,-1
8000c14c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c150 <__avr32_f64_sub_subnormal_result>:
8000c150:	5c 37       	neg	r7
8000c152:	2f f7       	sub	r7,-1
8000c154:	f1 b7 04 c0 	satu	r7,0x6
8000c158:	e0 47 00 20 	cp.w	r7,32
8000c15c:	c1 14       	brge	8000c17e <__avr32_f64_sub_subnormal_result+0x2e>
8000c15e:	ee 08 11 20 	rsub	r8,r7,32
8000c162:	f4 08 09 49 	lsl	r9,r10,r8
8000c166:	5f 16       	srne	r6
8000c168:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c16c:	0c 4a       	or	r10,r6
8000c16e:	f6 08 09 49 	lsl	r9,r11,r8
8000c172:	f5 e9 10 0a 	or	r10,r10,r9
8000c176:	f4 07 0a 4b 	lsr	r11,r10,r7
8000c17a:	30 07       	mov	r7,0
8000c17c:	cb 3b       	rjmp	8000c0e2 <__avr32_f64_sub_longnormalize_done>
8000c17e:	ee 08 11 40 	rsub	r8,r7,64
8000c182:	f6 08 09 49 	lsl	r9,r11,r8
8000c186:	14 49       	or	r9,r10
8000c188:	5f 16       	srne	r6
8000c18a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c18e:	0c 4a       	or	r10,r6
8000c190:	30 0b       	mov	r11,0
8000c192:	30 07       	mov	r7,0
8000c194:	ca 7b       	rjmp	8000c0e2 <__avr32_f64_sub_longnormalize_done>
8000c196:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c19a <__avr32_f64_sub_longshift>:
8000c19a:	f1 b6 04 c0 	satu	r6,0x6
8000c19e:	f0 0e 17 00 	moveq	lr,r8
8000c1a2:	c0 40       	breq	8000c1aa <__avr32_f64_sub_longshift+0x10>
8000c1a4:	f2 05 09 4e 	lsl	lr,r9,r5
8000c1a8:	10 4e       	or	lr,r8
8000c1aa:	f2 06 0a 48 	lsr	r8,r9,r6
8000c1ae:	30 09       	mov	r9,0
8000c1b0:	58 0e       	cp.w	lr,0
8000c1b2:	5f 1e       	srne	lr
8000c1b4:	1c 48       	or	r8,lr
8000c1b6:	c8 3b       	rjmp	8000c0bc <__avr32_f64_sub_shift_done>

8000c1b8 <__avr32_f64_sub_longnormalize>:
8000c1b8:	f4 06 12 00 	clz	r6,r10
8000c1bc:	f9 b7 03 00 	movlo	r7,0
8000c1c0:	f9 b6 03 00 	movlo	r6,0
8000c1c4:	f9 bc 03 00 	movlo	r12,0
8000c1c8:	f7 b6 02 e0 	subhs	r6,-32
8000c1cc:	f4 06 09 4b 	lsl	r11,r10,r6
8000c1d0:	30 0a       	mov	r10,0
8000c1d2:	0c 17       	sub	r7,r6
8000c1d4:	fe 9a ff be 	brle	8000c150 <__avr32_f64_sub_subnormal_result>
8000c1d8:	c8 5b       	rjmp	8000c0e2 <__avr32_f64_sub_longnormalize_done>
8000c1da:	d7 03       	nop

8000c1dc <__avr32_f64_add_from_sub>:
8000c1dc:	ee 19 80 00 	eorh	r9,0x8000

8000c1e0 <__avr32_f64_add>:
8000c1e0:	f7 e9 20 0c 	eor	r12,r11,r9
8000c1e4:	fe 96 ff 2e 	brmi	8000c040 <__avr32_f64_sub_from_add>
8000c1e8:	eb cd 40 e0 	pushm	r5-r7,lr
8000c1ec:	16 9c       	mov	r12,r11
8000c1ee:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c1f2:	bf db       	cbr	r11,0x1f
8000c1f4:	bf d9       	cbr	r9,0x1f
8000c1f6:	12 3b       	cp.w	r11,r9
8000c1f8:	c0 72       	brcc	8000c206 <__avr32_f64_add+0x26>
8000c1fa:	16 97       	mov	r7,r11
8000c1fc:	12 9b       	mov	r11,r9
8000c1fe:	0e 99       	mov	r9,r7
8000c200:	14 97       	mov	r7,r10
8000c202:	10 9a       	mov	r10,r8
8000c204:	0e 98       	mov	r8,r7
8000c206:	30 0e       	mov	lr,0
8000c208:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c20c:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000c210:	b5 ab       	sbr	r11,0x14
8000c212:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c216:	c6 20       	breq	8000c2da <__avr32_f64_add_op2_subnormal>
8000c218:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000c21c:	b5 a9       	sbr	r9,0x14
8000c21e:	e0 47 07 ff 	cp.w	r7,2047
8000c222:	c2 80       	breq	8000c272 <__avr32_f64_add_opH_nan_or_inf>
8000c224:	0e 26       	rsub	r6,r7
8000c226:	c1 20       	breq	8000c24a <__avr32_f64_add_shift_done>
8000c228:	e0 46 00 36 	cp.w	r6,54
8000c22c:	c1 52       	brcc	8000c256 <__avr32_f64_add_res_of_done>
8000c22e:	ec 05 11 20 	rsub	r5,r6,32
8000c232:	e0 46 00 20 	cp.w	r6,32
8000c236:	c3 52       	brcc	8000c2a0 <__avr32_f64_add_longshift>
8000c238:	f0 05 09 4e 	lsl	lr,r8,r5
8000c23c:	f2 05 09 45 	lsl	r5,r9,r5
8000c240:	f0 06 0a 48 	lsr	r8,r8,r6
8000c244:	f2 06 0a 49 	lsr	r9,r9,r6
8000c248:	0a 48       	or	r8,r5

8000c24a <__avr32_f64_add_shift_done>:
8000c24a:	10 0a       	add	r10,r8
8000c24c:	f6 09 00 4b 	adc	r11,r11,r9
8000c250:	ed bb 00 15 	bld	r11,0x15
8000c254:	c3 40       	breq	8000c2bc <__avr32_f64_add_res_of>

8000c256 <__avr32_f64_add_res_of_done>:
8000c256:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c25a:	18 4b       	or	r11,r12

8000c25c <__avr32_f64_add_round>:
8000c25c:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c260:	18 4e       	or	lr,r12
8000c262:	ee 1e 80 00 	eorh	lr,0x8000
8000c266:	f1 be 04 20 	satu	lr,0x1
8000c26a:	1c 0a       	add	r10,lr
8000c26c:	5c 0b       	acr	r11
8000c26e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c272 <__avr32_f64_add_opH_nan_or_inf>:
8000c272:	b5 cb       	cbr	r11,0x14
8000c274:	f7 ea 10 0e 	or	lr,r11,r10
8000c278:	c1 01       	brne	8000c298 <__avr32_f64_add_return_nan>
8000c27a:	e0 46 07 ff 	cp.w	r6,2047
8000c27e:	c0 30       	breq	8000c284 <__avr32_f64_add_opL_nan_or_inf>
8000c280:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c284 <__avr32_f64_add_opL_nan_or_inf>:
8000c284:	b5 c9       	cbr	r9,0x14
8000c286:	f3 e8 10 0e 	or	lr,r9,r8
8000c28a:	c0 71       	brne	8000c298 <__avr32_f64_add_return_nan>
8000c28c:	30 0a       	mov	r10,0
8000c28e:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c292:	18 4b       	or	r11,r12
8000c294:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c298 <__avr32_f64_add_return_nan>:
8000c298:	3f fa       	mov	r10,-1
8000c29a:	3f fb       	mov	r11,-1
8000c29c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c2a0 <__avr32_f64_add_longshift>:
8000c2a0:	f1 b6 04 c0 	satu	r6,0x6
8000c2a4:	f0 0e 17 00 	moveq	lr,r8
8000c2a8:	c0 60       	breq	8000c2b4 <__avr32_f64_add_longshift+0x14>
8000c2aa:	f2 05 09 4e 	lsl	lr,r9,r5
8000c2ae:	58 08       	cp.w	r8,0
8000c2b0:	5f 18       	srne	r8
8000c2b2:	10 4e       	or	lr,r8
8000c2b4:	f2 06 0a 48 	lsr	r8,r9,r6
8000c2b8:	30 09       	mov	r9,0
8000c2ba:	cc 8b       	rjmp	8000c24a <__avr32_f64_add_shift_done>

8000c2bc <__avr32_f64_add_res_of>:
8000c2bc:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c2c0:	a1 9b       	lsr	r11,0x1
8000c2c2:	5d 0a       	ror	r10
8000c2c4:	5d 0e       	ror	lr
8000c2c6:	2f f7       	sub	r7,-1
8000c2c8:	e0 47 07 ff 	cp.w	r7,2047
8000c2cc:	f9 ba 00 00 	moveq	r10,0
8000c2d0:	f9 bb 00 00 	moveq	r11,0
8000c2d4:	f9 be 00 00 	moveq	lr,0
8000c2d8:	cb fb       	rjmp	8000c256 <__avr32_f64_add_res_of_done>

8000c2da <__avr32_f64_add_op2_subnormal>:
8000c2da:	30 16       	mov	r6,1
8000c2dc:	58 07       	cp.w	r7,0
8000c2de:	ca 01       	brne	8000c21e <__avr32_f64_add+0x3e>
8000c2e0:	b5 cb       	cbr	r11,0x14
8000c2e2:	10 0a       	add	r10,r8
8000c2e4:	f6 09 00 4b 	adc	r11,r11,r9
8000c2e8:	18 4b       	or	r11,r12
8000c2ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000c2ee:	d7 03       	nop

8000c2f0 <__avr32_f64_to_u32>:
8000c2f0:	58 0b       	cp.w	r11,0
8000c2f2:	5e 6d       	retmi	0

8000c2f4 <__avr32_f64_to_s32>:
8000c2f4:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c2f8:	b5 9c       	lsr	r12,0x15
8000c2fa:	e0 2c 03 ff 	sub	r12,1023
8000c2fe:	5e 3d       	retlo	0
8000c300:	f8 0c 11 1f 	rsub	r12,r12,31
8000c304:	16 99       	mov	r9,r11
8000c306:	ab 7b       	lsl	r11,0xb
8000c308:	bf bb       	sbr	r11,0x1f
8000c30a:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c30e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c312:	a1 79       	lsl	r9,0x1
8000c314:	5e 2b       	reths	r11
8000c316:	5c 3b       	neg	r11
8000c318:	5e fb       	retal	r11

8000c31a <__avr32_u32_to_f64>:
8000c31a:	f8 cb 00 00 	sub	r11,r12,0
8000c31e:	30 0c       	mov	r12,0
8000c320:	c0 38       	rjmp	8000c326 <__avr32_s32_to_f64+0x4>

8000c322 <__avr32_s32_to_f64>:
8000c322:	18 9b       	mov	r11,r12
8000c324:	5c 4b       	abs	r11
8000c326:	30 0a       	mov	r10,0
8000c328:	5e 0b       	reteq	r11
8000c32a:	d4 01       	pushm	lr
8000c32c:	e0 69 04 1e 	mov	r9,1054
8000c330:	f6 08 12 00 	clz	r8,r11
8000c334:	c1 70       	breq	8000c362 <__avr32_s32_to_f64+0x40>
8000c336:	c0 c3       	brcs	8000c34e <__avr32_s32_to_f64+0x2c>
8000c338:	f0 0e 11 20 	rsub	lr,r8,32
8000c33c:	f6 08 09 4b 	lsl	r11,r11,r8
8000c340:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c344:	1c 4b       	or	r11,lr
8000c346:	f4 08 09 4a 	lsl	r10,r10,r8
8000c34a:	10 19       	sub	r9,r8
8000c34c:	c0 b8       	rjmp	8000c362 <__avr32_s32_to_f64+0x40>
8000c34e:	f4 08 12 00 	clz	r8,r10
8000c352:	f9 b8 03 00 	movlo	r8,0
8000c356:	f7 b8 02 e0 	subhs	r8,-32
8000c35a:	f4 08 09 4b 	lsl	r11,r10,r8
8000c35e:	30 0a       	mov	r10,0
8000c360:	10 19       	sub	r9,r8
8000c362:	58 09       	cp.w	r9,0
8000c364:	e0 89 00 30 	brgt	8000c3c4 <__avr32_s32_to_f64+0xa2>
8000c368:	5c 39       	neg	r9
8000c36a:	2f f9       	sub	r9,-1
8000c36c:	e0 49 00 36 	cp.w	r9,54
8000c370:	c0 43       	brcs	8000c378 <__avr32_s32_to_f64+0x56>
8000c372:	30 0b       	mov	r11,0
8000c374:	30 0a       	mov	r10,0
8000c376:	c2 68       	rjmp	8000c3c2 <__avr32_s32_to_f64+0xa0>
8000c378:	2f 69       	sub	r9,-10
8000c37a:	f2 08 11 20 	rsub	r8,r9,32
8000c37e:	e0 49 00 20 	cp.w	r9,32
8000c382:	c0 b2       	brcc	8000c398 <__avr32_s32_to_f64+0x76>
8000c384:	f4 08 09 4e 	lsl	lr,r10,r8
8000c388:	f6 08 09 48 	lsl	r8,r11,r8
8000c38c:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c390:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c394:	10 4b       	or	r11,r8
8000c396:	c0 88       	rjmp	8000c3a6 <__avr32_s32_to_f64+0x84>
8000c398:	f6 08 09 4e 	lsl	lr,r11,r8
8000c39c:	14 4e       	or	lr,r10
8000c39e:	16 9a       	mov	r10,r11
8000c3a0:	30 0b       	mov	r11,0
8000c3a2:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c3a6:	ed ba 00 00 	bld	r10,0x0
8000c3aa:	c0 92       	brcc	8000c3bc <__avr32_s32_to_f64+0x9a>
8000c3ac:	1c 7e       	tst	lr,lr
8000c3ae:	c0 41       	brne	8000c3b6 <__avr32_s32_to_f64+0x94>
8000c3b0:	ed ba 00 01 	bld	r10,0x1
8000c3b4:	c0 42       	brcc	8000c3bc <__avr32_s32_to_f64+0x9a>
8000c3b6:	2f fa       	sub	r10,-1
8000c3b8:	f7 bb 02 ff 	subhs	r11,-1
8000c3bc:	5c fc       	rol	r12
8000c3be:	5d 0b       	ror	r11
8000c3c0:	5d 0a       	ror	r10
8000c3c2:	d8 02       	popm	pc
8000c3c4:	e0 68 03 ff 	mov	r8,1023
8000c3c8:	ed ba 00 0b 	bld	r10,0xb
8000c3cc:	f7 b8 00 ff 	subeq	r8,-1
8000c3d0:	10 0a       	add	r10,r8
8000c3d2:	5c 0b       	acr	r11
8000c3d4:	f7 b9 03 fe 	sublo	r9,-2
8000c3d8:	e0 49 07 ff 	cp.w	r9,2047
8000c3dc:	c0 55       	brlt	8000c3e6 <__avr32_s32_to_f64+0xc4>
8000c3de:	30 0a       	mov	r10,0
8000c3e0:	fc 1b ff e0 	movh	r11,0xffe0
8000c3e4:	c0 c8       	rjmp	8000c3fc <__floatsidf_return_op1>
8000c3e6:	ed bb 00 1f 	bld	r11,0x1f
8000c3ea:	f7 b9 01 01 	subne	r9,1
8000c3ee:	ab 9a       	lsr	r10,0xb
8000c3f0:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c3f4:	a1 7b       	lsl	r11,0x1
8000c3f6:	ab 9b       	lsr	r11,0xb
8000c3f8:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c3fc <__floatsidf_return_op1>:
8000c3fc:	a1 7c       	lsl	r12,0x1
8000c3fe:	5d 0b       	ror	r11
8000c400:	d8 02       	popm	pc

8000c402 <__avr32_f64_cmp_eq>:
8000c402:	10 3a       	cp.w	r10,r8
8000c404:	f2 0b 13 00 	cpc	r11,r9
8000c408:	c0 80       	breq	8000c418 <__avr32_f64_cmp_eq+0x16>
8000c40a:	a1 7b       	lsl	r11,0x1
8000c40c:	a1 79       	lsl	r9,0x1
8000c40e:	14 4b       	or	r11,r10
8000c410:	12 4b       	or	r11,r9
8000c412:	10 4b       	or	r11,r8
8000c414:	5e 0f       	reteq	1
8000c416:	5e fd       	retal	0
8000c418:	a1 7b       	lsl	r11,0x1
8000c41a:	fc 1c ff e0 	movh	r12,0xffe0
8000c41e:	58 0a       	cp.w	r10,0
8000c420:	f8 0b 13 00 	cpc	r11,r12
8000c424:	5e 8f       	retls	1
8000c426:	5e fd       	retal	0

8000c428 <__avr32_f64_cmp_ge>:
8000c428:	1a de       	st.w	--sp,lr
8000c42a:	1a d7       	st.w	--sp,r7
8000c42c:	a1 7b       	lsl	r11,0x1
8000c42e:	5f 3c       	srlo	r12
8000c430:	a1 79       	lsl	r9,0x1
8000c432:	5f 37       	srlo	r7
8000c434:	5c fc       	rol	r12
8000c436:	fc 1e ff e0 	movh	lr,0xffe0
8000c43a:	58 0a       	cp.w	r10,0
8000c43c:	fc 0b 13 00 	cpc	r11,lr
8000c440:	e0 8b 00 1d 	brhi	8000c47a <__avr32_f64_cmp_ge+0x52>
8000c444:	58 08       	cp.w	r8,0
8000c446:	fc 09 13 00 	cpc	r9,lr
8000c44a:	e0 8b 00 18 	brhi	8000c47a <__avr32_f64_cmp_ge+0x52>
8000c44e:	58 0b       	cp.w	r11,0
8000c450:	f5 ba 00 00 	subfeq	r10,0
8000c454:	c1 50       	breq	8000c47e <__avr32_f64_cmp_ge+0x56>
8000c456:	1b 07       	ld.w	r7,sp++
8000c458:	1b 0e       	ld.w	lr,sp++
8000c45a:	58 3c       	cp.w	r12,3
8000c45c:	c0 a0       	breq	8000c470 <__avr32_f64_cmp_ge+0x48>
8000c45e:	58 1c       	cp.w	r12,1
8000c460:	c0 33       	brcs	8000c466 <__avr32_f64_cmp_ge+0x3e>
8000c462:	5e 0f       	reteq	1
8000c464:	5e 1d       	retne	0
8000c466:	10 3a       	cp.w	r10,r8
8000c468:	f2 0b 13 00 	cpc	r11,r9
8000c46c:	5e 2f       	reths	1
8000c46e:	5e 3d       	retlo	0
8000c470:	14 38       	cp.w	r8,r10
8000c472:	f6 09 13 00 	cpc	r9,r11
8000c476:	5e 2f       	reths	1
8000c478:	5e 3d       	retlo	0
8000c47a:	1b 07       	ld.w	r7,sp++
8000c47c:	d8 0a       	popm	pc,r12=0
8000c47e:	58 17       	cp.w	r7,1
8000c480:	5f 0c       	sreq	r12
8000c482:	58 09       	cp.w	r9,0
8000c484:	f5 b8 00 00 	subfeq	r8,0
8000c488:	1b 07       	ld.w	r7,sp++
8000c48a:	1b 0e       	ld.w	lr,sp++
8000c48c:	5e 0f       	reteq	1
8000c48e:	5e fc       	retal	r12

8000c490 <__avr32_f64_cmp_lt>:
8000c490:	1a de       	st.w	--sp,lr
8000c492:	1a d7       	st.w	--sp,r7
8000c494:	a1 7b       	lsl	r11,0x1
8000c496:	5f 3c       	srlo	r12
8000c498:	a1 79       	lsl	r9,0x1
8000c49a:	5f 37       	srlo	r7
8000c49c:	5c fc       	rol	r12
8000c49e:	fc 1e ff e0 	movh	lr,0xffe0
8000c4a2:	58 0a       	cp.w	r10,0
8000c4a4:	fc 0b 13 00 	cpc	r11,lr
8000c4a8:	e0 8b 00 1d 	brhi	8000c4e2 <__avr32_f64_cmp_lt+0x52>
8000c4ac:	58 08       	cp.w	r8,0
8000c4ae:	fc 09 13 00 	cpc	r9,lr
8000c4b2:	e0 8b 00 18 	brhi	8000c4e2 <__avr32_f64_cmp_lt+0x52>
8000c4b6:	58 0b       	cp.w	r11,0
8000c4b8:	f5 ba 00 00 	subfeq	r10,0
8000c4bc:	c1 50       	breq	8000c4e6 <__avr32_f64_cmp_lt+0x56>
8000c4be:	1b 07       	ld.w	r7,sp++
8000c4c0:	1b 0e       	ld.w	lr,sp++
8000c4c2:	58 3c       	cp.w	r12,3
8000c4c4:	c0 a0       	breq	8000c4d8 <__avr32_f64_cmp_lt+0x48>
8000c4c6:	58 1c       	cp.w	r12,1
8000c4c8:	c0 33       	brcs	8000c4ce <__avr32_f64_cmp_lt+0x3e>
8000c4ca:	5e 0d       	reteq	0
8000c4cc:	5e 1f       	retne	1
8000c4ce:	10 3a       	cp.w	r10,r8
8000c4d0:	f2 0b 13 00 	cpc	r11,r9
8000c4d4:	5e 2d       	reths	0
8000c4d6:	5e 3f       	retlo	1
8000c4d8:	14 38       	cp.w	r8,r10
8000c4da:	f6 09 13 00 	cpc	r9,r11
8000c4de:	5e 2d       	reths	0
8000c4e0:	5e 3f       	retlo	1
8000c4e2:	1b 07       	ld.w	r7,sp++
8000c4e4:	d8 0a       	popm	pc,r12=0
8000c4e6:	58 17       	cp.w	r7,1
8000c4e8:	5f 1c       	srne	r12
8000c4ea:	58 09       	cp.w	r9,0
8000c4ec:	f5 b8 00 00 	subfeq	r8,0
8000c4f0:	1b 07       	ld.w	r7,sp++
8000c4f2:	1b 0e       	ld.w	lr,sp++
8000c4f4:	5e 0d       	reteq	0
8000c4f6:	5e fc       	retal	r12

8000c4f8 <__avr32_f64_div>:
8000c4f8:	eb cd 40 ff 	pushm	r0-r7,lr
8000c4fc:	f7 e9 20 0e 	eor	lr,r11,r9
8000c500:	f6 07 16 14 	lsr	r7,r11,0x14
8000c504:	a9 7b       	lsl	r11,0x9
8000c506:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c50a:	a9 7a       	lsl	r10,0x9
8000c50c:	bd bb       	sbr	r11,0x1d
8000c50e:	e4 1b 3f ff 	andh	r11,0x3fff
8000c512:	ab d7       	cbr	r7,0xb
8000c514:	e0 80 00 cc 	breq	8000c6ac <__avr32_f64_div_round_subnormal+0x54>
8000c518:	e0 47 07 ff 	cp.w	r7,2047
8000c51c:	e0 84 00 b5 	brge	8000c686 <__avr32_f64_div_round_subnormal+0x2e>
8000c520:	f2 06 16 14 	lsr	r6,r9,0x14
8000c524:	a9 79       	lsl	r9,0x9
8000c526:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c52a:	a9 78       	lsl	r8,0x9
8000c52c:	bd b9       	sbr	r9,0x1d
8000c52e:	e4 19 3f ff 	andh	r9,0x3fff
8000c532:	ab d6       	cbr	r6,0xb
8000c534:	e0 80 00 e2 	breq	8000c6f8 <__avr32_f64_div_round_subnormal+0xa0>
8000c538:	e0 46 07 ff 	cp.w	r6,2047
8000c53c:	e0 84 00 b2 	brge	8000c6a0 <__avr32_f64_div_round_subnormal+0x48>
8000c540:	0c 17       	sub	r7,r6
8000c542:	fe 37 fc 01 	sub	r7,-1023
8000c546:	fc 1c 80 00 	movh	r12,0x8000
8000c54a:	f8 03 16 01 	lsr	r3,r12,0x1
8000c54e:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c552:	5c d4       	com	r4
8000c554:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c558:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c55c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c560:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c564:	ea 03 15 02 	lsl	r3,r5,0x2
8000c568:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c56c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c570:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c574:	ea 03 15 02 	lsl	r3,r5,0x2
8000c578:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c57c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c580:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c584:	ea 03 15 02 	lsl	r3,r5,0x2
8000c588:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c58c:	e4 09 07 40 	macu.d	r0,r2,r9
8000c590:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c594:	02 04       	add	r4,r1
8000c596:	5c 05       	acr	r5
8000c598:	a3 65       	lsl	r5,0x2
8000c59a:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c59e:	a3 64       	lsl	r4,0x2
8000c5a0:	5c 34       	neg	r4
8000c5a2:	f8 05 01 45 	sbc	r5,r12,r5
8000c5a6:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c5aa:	e4 05 07 40 	macu.d	r0,r2,r5
8000c5ae:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c5b2:	02 04       	add	r4,r1
8000c5b4:	5c 05       	acr	r5
8000c5b6:	ea 03 15 02 	lsl	r3,r5,0x2
8000c5ba:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c5be:	e8 02 15 02 	lsl	r2,r4,0x2
8000c5c2:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c5c6:	e4 09 07 40 	macu.d	r0,r2,r9
8000c5ca:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c5ce:	02 04       	add	r4,r1
8000c5d0:	5c 05       	acr	r5
8000c5d2:	a3 65       	lsl	r5,0x2
8000c5d4:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c5d8:	a3 64       	lsl	r4,0x2
8000c5da:	5c 34       	neg	r4
8000c5dc:	f8 05 01 45 	sbc	r5,r12,r5
8000c5e0:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c5e4:	e4 05 07 40 	macu.d	r0,r2,r5
8000c5e8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c5ec:	02 04       	add	r4,r1
8000c5ee:	5c 05       	acr	r5
8000c5f0:	ea 03 15 02 	lsl	r3,r5,0x2
8000c5f4:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c5f8:	e8 02 15 02 	lsl	r2,r4,0x2
8000c5fc:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c600:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c604:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c608:	02 02       	add	r2,r1
8000c60a:	5c 03       	acr	r3
8000c60c:	ed b3 00 1c 	bld	r3,0x1c
8000c610:	c0 90       	breq	8000c622 <__avr32_f64_div+0x12a>
8000c612:	a1 72       	lsl	r2,0x1
8000c614:	5c f3       	rol	r3
8000c616:	20 17       	sub	r7,1
8000c618:	a3 9a       	lsr	r10,0x3
8000c61a:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c61e:	a3 9b       	lsr	r11,0x3
8000c620:	c0 58       	rjmp	8000c62a <__avr32_f64_div+0x132>
8000c622:	a5 8a       	lsr	r10,0x4
8000c624:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c628:	a5 8b       	lsr	r11,0x4
8000c62a:	58 07       	cp.w	r7,0
8000c62c:	e0 8a 00 8b 	brle	8000c742 <__avr32_f64_div_res_subnormal>
8000c630:	e0 12 ff 00 	andl	r2,0xff00
8000c634:	e8 12 00 80 	orl	r2,0x80
8000c638:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c63c:	e4 09 07 40 	macu.d	r0,r2,r9
8000c640:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c644:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c648:	00 05       	add	r5,r0
8000c64a:	f0 01 00 48 	adc	r8,r8,r1
8000c64e:	5c 09       	acr	r9
8000c650:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c654:	58 04       	cp.w	r4,0
8000c656:	5c 25       	cpc	r5

8000c658 <__avr32_f64_div_round_subnormal>:
8000c658:	f4 08 13 00 	cpc	r8,r10
8000c65c:	f6 09 13 00 	cpc	r9,r11
8000c660:	5f 36       	srlo	r6
8000c662:	f8 06 17 00 	moveq	r6,r12
8000c666:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c66a:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c66e:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c672:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c676:	ed be 00 1f 	bld	lr,0x1f
8000c67a:	ef bb 00 1f 	bst	r11,0x1f
8000c67e:	0c 0a       	add	r10,r6
8000c680:	5c 0b       	acr	r11
8000c682:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c686:	e4 1b 00 0f 	andh	r11,0xf
8000c68a:	14 4b       	or	r11,r10
8000c68c:	e0 81 00 a7 	brne	8000c7da <__avr32_f64_div_res_subnormal+0x98>
8000c690:	f2 06 16 14 	lsr	r6,r9,0x14
8000c694:	ab d6       	cbr	r6,0xb
8000c696:	e0 46 07 ff 	cp.w	r6,2047
8000c69a:	e0 81 00 a4 	brne	8000c7e2 <__avr32_f64_div_res_subnormal+0xa0>
8000c69e:	c9 e8       	rjmp	8000c7da <__avr32_f64_div_res_subnormal+0x98>
8000c6a0:	e4 19 00 0f 	andh	r9,0xf
8000c6a4:	10 49       	or	r9,r8
8000c6a6:	e0 81 00 9a 	brne	8000c7da <__avr32_f64_div_res_subnormal+0x98>
8000c6aa:	c9 28       	rjmp	8000c7ce <__avr32_f64_div_res_subnormal+0x8c>
8000c6ac:	a3 7b       	lsl	r11,0x3
8000c6ae:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c6b2:	a3 7a       	lsl	r10,0x3
8000c6b4:	f5 eb 10 04 	or	r4,r10,r11
8000c6b8:	e0 80 00 a0 	breq	8000c7f8 <__avr32_f64_div_op1_zero>
8000c6bc:	f6 04 12 00 	clz	r4,r11
8000c6c0:	c1 70       	breq	8000c6ee <__avr32_f64_div_round_subnormal+0x96>
8000c6c2:	c0 c3       	brcs	8000c6da <__avr32_f64_div_round_subnormal+0x82>
8000c6c4:	e8 05 11 20 	rsub	r5,r4,32
8000c6c8:	f6 04 09 4b 	lsl	r11,r11,r4
8000c6cc:	f4 05 0a 45 	lsr	r5,r10,r5
8000c6d0:	0a 4b       	or	r11,r5
8000c6d2:	f4 04 09 4a 	lsl	r10,r10,r4
8000c6d6:	08 17       	sub	r7,r4
8000c6d8:	c0 b8       	rjmp	8000c6ee <__avr32_f64_div_round_subnormal+0x96>
8000c6da:	f4 04 12 00 	clz	r4,r10
8000c6de:	f9 b4 03 00 	movlo	r4,0
8000c6e2:	f7 b4 02 e0 	subhs	r4,-32
8000c6e6:	f4 04 09 4b 	lsl	r11,r10,r4
8000c6ea:	30 0a       	mov	r10,0
8000c6ec:	08 17       	sub	r7,r4
8000c6ee:	a3 8a       	lsr	r10,0x2
8000c6f0:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c6f4:	a3 8b       	lsr	r11,0x2
8000c6f6:	c1 1b       	rjmp	8000c518 <__avr32_f64_div+0x20>
8000c6f8:	a3 79       	lsl	r9,0x3
8000c6fa:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c6fe:	a3 78       	lsl	r8,0x3
8000c700:	f3 e8 10 04 	or	r4,r9,r8
8000c704:	c6 f0       	breq	8000c7e2 <__avr32_f64_div_res_subnormal+0xa0>
8000c706:	f2 04 12 00 	clz	r4,r9
8000c70a:	c1 70       	breq	8000c738 <__avr32_f64_div_round_subnormal+0xe0>
8000c70c:	c0 c3       	brcs	8000c724 <__avr32_f64_div_round_subnormal+0xcc>
8000c70e:	e8 05 11 20 	rsub	r5,r4,32
8000c712:	f2 04 09 49 	lsl	r9,r9,r4
8000c716:	f0 05 0a 45 	lsr	r5,r8,r5
8000c71a:	0a 49       	or	r9,r5
8000c71c:	f0 04 09 48 	lsl	r8,r8,r4
8000c720:	08 16       	sub	r6,r4
8000c722:	c0 b8       	rjmp	8000c738 <__avr32_f64_div_round_subnormal+0xe0>
8000c724:	f0 04 12 00 	clz	r4,r8
8000c728:	f9 b4 03 00 	movlo	r4,0
8000c72c:	f7 b4 02 e0 	subhs	r4,-32
8000c730:	f0 04 09 49 	lsl	r9,r8,r4
8000c734:	30 08       	mov	r8,0
8000c736:	08 16       	sub	r6,r4
8000c738:	a3 88       	lsr	r8,0x2
8000c73a:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c73e:	a3 89       	lsr	r9,0x2
8000c740:	cf ca       	rjmp	8000c538 <__avr32_f64_div+0x40>

8000c742 <__avr32_f64_div_res_subnormal>:
8000c742:	5c 37       	neg	r7
8000c744:	2f f7       	sub	r7,-1
8000c746:	f1 b7 04 c0 	satu	r7,0x6
8000c74a:	e0 47 00 20 	cp.w	r7,32
8000c74e:	c1 54       	brge	8000c778 <__avr32_f64_div_res_subnormal+0x36>
8000c750:	ee 06 11 20 	rsub	r6,r7,32
8000c754:	e4 07 0a 42 	lsr	r2,r2,r7
8000c758:	e6 06 09 4c 	lsl	r12,r3,r6
8000c75c:	18 42       	or	r2,r12
8000c75e:	e6 07 0a 43 	lsr	r3,r3,r7
8000c762:	f4 06 09 41 	lsl	r1,r10,r6
8000c766:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c76a:	f6 06 09 4c 	lsl	r12,r11,r6
8000c76e:	18 4a       	or	r10,r12
8000c770:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c774:	30 00       	mov	r0,0
8000c776:	c1 58       	rjmp	8000c7a0 <__avr32_f64_div_res_subnormal+0x5e>
8000c778:	ee 06 11 20 	rsub	r6,r7,32
8000c77c:	f9 b0 00 00 	moveq	r0,0
8000c780:	f9 bc 00 00 	moveq	r12,0
8000c784:	c0 50       	breq	8000c78e <__avr32_f64_div_res_subnormal+0x4c>
8000c786:	f4 06 09 40 	lsl	r0,r10,r6
8000c78a:	f6 06 09 4c 	lsl	r12,r11,r6
8000c78e:	e6 07 0a 42 	lsr	r2,r3,r7
8000c792:	30 03       	mov	r3,0
8000c794:	f4 07 0a 41 	lsr	r1,r10,r7
8000c798:	18 41       	or	r1,r12
8000c79a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c79e:	30 0b       	mov	r11,0
8000c7a0:	e0 12 ff 00 	andl	r2,0xff00
8000c7a4:	e8 12 00 80 	orl	r2,0x80
8000c7a8:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c7ac:	e4 09 07 46 	macu.d	r6,r2,r9
8000c7b0:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c7b4:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c7b8:	0c 05       	add	r5,r6
8000c7ba:	f0 07 00 48 	adc	r8,r8,r7
8000c7be:	5c 09       	acr	r9
8000c7c0:	30 07       	mov	r7,0
8000c7c2:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c7c6:	00 34       	cp.w	r4,r0
8000c7c8:	e2 05 13 00 	cpc	r5,r1
8000c7cc:	c4 6b       	rjmp	8000c658 <__avr32_f64_div_round_subnormal>
8000c7ce:	1c 9b       	mov	r11,lr
8000c7d0:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c7d4:	30 0a       	mov	r10,0
8000c7d6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c7da:	3f fb       	mov	r11,-1
8000c7dc:	30 0a       	mov	r10,0
8000c7de:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c7e2:	f5 eb 10 04 	or	r4,r10,r11
8000c7e6:	c0 90       	breq	8000c7f8 <__avr32_f64_div_op1_zero>
8000c7e8:	1c 9b       	mov	r11,lr
8000c7ea:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c7ee:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c7f2:	30 0a       	mov	r10,0
8000c7f4:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c7f8 <__avr32_f64_div_op1_zero>:
8000c7f8:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c7fc:	ce f0       	breq	8000c7da <__avr32_f64_div_res_subnormal+0x98>
8000c7fe:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c802:	e0 44 07 ff 	cp.w	r4,2047
8000c806:	ce 41       	brne	8000c7ce <__avr32_f64_div_res_subnormal+0x8c>
8000c808:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c80c:	ce 10       	breq	8000c7ce <__avr32_f64_div_res_subnormal+0x8c>
8000c80e:	ce 6b       	rjmp	8000c7da <__avr32_f64_div_res_subnormal+0x98>

8000c810 <__avr32_udiv64>:
8000c810:	d4 31       	pushm	r0-r7,lr
8000c812:	1a 97       	mov	r7,sp
8000c814:	20 3d       	sub	sp,12
8000c816:	10 9c       	mov	r12,r8
8000c818:	12 9e       	mov	lr,r9
8000c81a:	14 93       	mov	r3,r10
8000c81c:	58 09       	cp.w	r9,0
8000c81e:	e0 81 00 bd 	brne	8000c998 <__avr32_udiv64+0x188>
8000c822:	16 38       	cp.w	r8,r11
8000c824:	e0 88 00 40 	brls	8000c8a4 <__avr32_udiv64+0x94>
8000c828:	f0 08 12 00 	clz	r8,r8
8000c82c:	c0 d0       	breq	8000c846 <__avr32_udiv64+0x36>
8000c82e:	f6 08 09 4b 	lsl	r11,r11,r8
8000c832:	f0 09 11 20 	rsub	r9,r8,32
8000c836:	f8 08 09 4c 	lsl	r12,r12,r8
8000c83a:	f4 09 0a 49 	lsr	r9,r10,r9
8000c83e:	f4 08 09 43 	lsl	r3,r10,r8
8000c842:	f3 eb 10 0b 	or	r11,r9,r11
8000c846:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c84a:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c84e:	f6 0e 0d 00 	divu	r0,r11,lr
8000c852:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c856:	00 99       	mov	r9,r0
8000c858:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c85c:	e0 0a 02 48 	mul	r8,r0,r10
8000c860:	10 3b       	cp.w	r11,r8
8000c862:	c0 a2       	brcc	8000c876 <__avr32_udiv64+0x66>
8000c864:	20 19       	sub	r9,1
8000c866:	18 0b       	add	r11,r12
8000c868:	18 3b       	cp.w	r11,r12
8000c86a:	c0 63       	brcs	8000c876 <__avr32_udiv64+0x66>
8000c86c:	10 3b       	cp.w	r11,r8
8000c86e:	f7 b9 03 01 	sublo	r9,1
8000c872:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c876:	f6 08 01 01 	sub	r1,r11,r8
8000c87a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c87e:	e2 0e 0d 00 	divu	r0,r1,lr
8000c882:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c886:	00 98       	mov	r8,r0
8000c888:	e0 0a 02 4a 	mul	r10,r0,r10
8000c88c:	14 33       	cp.w	r3,r10
8000c88e:	c0 82       	brcc	8000c89e <__avr32_udiv64+0x8e>
8000c890:	20 18       	sub	r8,1
8000c892:	18 03       	add	r3,r12
8000c894:	18 33       	cp.w	r3,r12
8000c896:	c0 43       	brcs	8000c89e <__avr32_udiv64+0x8e>
8000c898:	14 33       	cp.w	r3,r10
8000c89a:	f7 b8 03 01 	sublo	r8,1
8000c89e:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c8a2:	cd f8       	rjmp	8000ca60 <__avr32_udiv64+0x250>
8000c8a4:	58 08       	cp.w	r8,0
8000c8a6:	c0 51       	brne	8000c8b0 <__avr32_udiv64+0xa0>
8000c8a8:	30 19       	mov	r9,1
8000c8aa:	f2 08 0d 08 	divu	r8,r9,r8
8000c8ae:	10 9c       	mov	r12,r8
8000c8b0:	f8 06 12 00 	clz	r6,r12
8000c8b4:	c0 41       	brne	8000c8bc <__avr32_udiv64+0xac>
8000c8b6:	18 1b       	sub	r11,r12
8000c8b8:	30 19       	mov	r9,1
8000c8ba:	c4 08       	rjmp	8000c93a <__avr32_udiv64+0x12a>
8000c8bc:	ec 01 11 20 	rsub	r1,r6,32
8000c8c0:	f4 01 0a 49 	lsr	r9,r10,r1
8000c8c4:	f8 06 09 4c 	lsl	r12,r12,r6
8000c8c8:	f6 06 09 48 	lsl	r8,r11,r6
8000c8cc:	f6 01 0a 41 	lsr	r1,r11,r1
8000c8d0:	f3 e8 10 08 	or	r8,r9,r8
8000c8d4:	f8 03 16 10 	lsr	r3,r12,0x10
8000c8d8:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c8dc:	e2 03 0d 00 	divu	r0,r1,r3
8000c8e0:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c8e4:	00 9e       	mov	lr,r0
8000c8e6:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c8ea:	e0 05 02 49 	mul	r9,r0,r5
8000c8ee:	12 3b       	cp.w	r11,r9
8000c8f0:	c0 a2       	brcc	8000c904 <__avr32_udiv64+0xf4>
8000c8f2:	20 1e       	sub	lr,1
8000c8f4:	18 0b       	add	r11,r12
8000c8f6:	18 3b       	cp.w	r11,r12
8000c8f8:	c0 63       	brcs	8000c904 <__avr32_udiv64+0xf4>
8000c8fa:	12 3b       	cp.w	r11,r9
8000c8fc:	f7 be 03 01 	sublo	lr,1
8000c900:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c904:	12 1b       	sub	r11,r9
8000c906:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c90a:	f6 03 0d 02 	divu	r2,r11,r3
8000c90e:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c912:	04 99       	mov	r9,r2
8000c914:	e4 05 02 4b 	mul	r11,r2,r5
8000c918:	16 38       	cp.w	r8,r11
8000c91a:	c0 a2       	brcc	8000c92e <__avr32_udiv64+0x11e>
8000c91c:	20 19       	sub	r9,1
8000c91e:	18 08       	add	r8,r12
8000c920:	18 38       	cp.w	r8,r12
8000c922:	c0 63       	brcs	8000c92e <__avr32_udiv64+0x11e>
8000c924:	16 38       	cp.w	r8,r11
8000c926:	f7 b9 03 01 	sublo	r9,1
8000c92a:	f1 dc e3 08 	addcs	r8,r8,r12
8000c92e:	f4 06 09 43 	lsl	r3,r10,r6
8000c932:	f0 0b 01 0b 	sub	r11,r8,r11
8000c936:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c93a:	f8 06 16 10 	lsr	r6,r12,0x10
8000c93e:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c942:	f6 06 0d 00 	divu	r0,r11,r6
8000c946:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c94a:	00 9a       	mov	r10,r0
8000c94c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c950:	e0 0e 02 48 	mul	r8,r0,lr
8000c954:	10 3b       	cp.w	r11,r8
8000c956:	c0 a2       	brcc	8000c96a <__avr32_udiv64+0x15a>
8000c958:	20 1a       	sub	r10,1
8000c95a:	18 0b       	add	r11,r12
8000c95c:	18 3b       	cp.w	r11,r12
8000c95e:	c0 63       	brcs	8000c96a <__avr32_udiv64+0x15a>
8000c960:	10 3b       	cp.w	r11,r8
8000c962:	f7 ba 03 01 	sublo	r10,1
8000c966:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c96a:	f6 08 01 01 	sub	r1,r11,r8
8000c96e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c972:	e2 06 0d 00 	divu	r0,r1,r6
8000c976:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c97a:	00 98       	mov	r8,r0
8000c97c:	e0 0e 02 4b 	mul	r11,r0,lr
8000c980:	16 33       	cp.w	r3,r11
8000c982:	c0 82       	brcc	8000c992 <__avr32_udiv64+0x182>
8000c984:	20 18       	sub	r8,1
8000c986:	18 03       	add	r3,r12
8000c988:	18 33       	cp.w	r3,r12
8000c98a:	c0 43       	brcs	8000c992 <__avr32_udiv64+0x182>
8000c98c:	16 33       	cp.w	r3,r11
8000c98e:	f7 b8 03 01 	sublo	r8,1
8000c992:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c996:	c6 98       	rjmp	8000ca68 <__avr32_udiv64+0x258>
8000c998:	16 39       	cp.w	r9,r11
8000c99a:	e0 8b 00 65 	brhi	8000ca64 <__avr32_udiv64+0x254>
8000c99e:	f2 09 12 00 	clz	r9,r9
8000c9a2:	c0 b1       	brne	8000c9b8 <__avr32_udiv64+0x1a8>
8000c9a4:	10 3a       	cp.w	r10,r8
8000c9a6:	5f 2a       	srhs	r10
8000c9a8:	1c 3b       	cp.w	r11,lr
8000c9aa:	5f b8       	srhi	r8
8000c9ac:	10 4a       	or	r10,r8
8000c9ae:	f2 0a 18 00 	cp.b	r10,r9
8000c9b2:	c5 90       	breq	8000ca64 <__avr32_udiv64+0x254>
8000c9b4:	30 18       	mov	r8,1
8000c9b6:	c5 98       	rjmp	8000ca68 <__avr32_udiv64+0x258>
8000c9b8:	f0 09 09 46 	lsl	r6,r8,r9
8000c9bc:	f2 03 11 20 	rsub	r3,r9,32
8000c9c0:	fc 09 09 4e 	lsl	lr,lr,r9
8000c9c4:	f0 03 0a 48 	lsr	r8,r8,r3
8000c9c8:	f6 09 09 4c 	lsl	r12,r11,r9
8000c9cc:	f4 03 0a 42 	lsr	r2,r10,r3
8000c9d0:	ef 46 ff f4 	st.w	r7[-12],r6
8000c9d4:	f6 03 0a 43 	lsr	r3,r11,r3
8000c9d8:	18 42       	or	r2,r12
8000c9da:	f1 ee 10 0c 	or	r12,r8,lr
8000c9de:	f8 01 16 10 	lsr	r1,r12,0x10
8000c9e2:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c9e6:	e6 01 0d 04 	divu	r4,r3,r1
8000c9ea:	e4 03 16 10 	lsr	r3,r2,0x10
8000c9ee:	08 9e       	mov	lr,r4
8000c9f0:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c9f4:	e8 06 02 48 	mul	r8,r4,r6
8000c9f8:	10 33       	cp.w	r3,r8
8000c9fa:	c0 a2       	brcc	8000ca0e <__avr32_udiv64+0x1fe>
8000c9fc:	20 1e       	sub	lr,1
8000c9fe:	18 03       	add	r3,r12
8000ca00:	18 33       	cp.w	r3,r12
8000ca02:	c0 63       	brcs	8000ca0e <__avr32_udiv64+0x1fe>
8000ca04:	10 33       	cp.w	r3,r8
8000ca06:	f7 be 03 01 	sublo	lr,1
8000ca0a:	e7 dc e3 03 	addcs	r3,r3,r12
8000ca0e:	10 13       	sub	r3,r8
8000ca10:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000ca14:	e6 01 0d 00 	divu	r0,r3,r1
8000ca18:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000ca1c:	00 98       	mov	r8,r0
8000ca1e:	e0 06 02 46 	mul	r6,r0,r6
8000ca22:	0c 3b       	cp.w	r11,r6
8000ca24:	c0 a2       	brcc	8000ca38 <__avr32_udiv64+0x228>
8000ca26:	20 18       	sub	r8,1
8000ca28:	18 0b       	add	r11,r12
8000ca2a:	18 3b       	cp.w	r11,r12
8000ca2c:	c0 63       	brcs	8000ca38 <__avr32_udiv64+0x228>
8000ca2e:	0c 3b       	cp.w	r11,r6
8000ca30:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ca34:	f7 b8 03 01 	sublo	r8,1
8000ca38:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000ca3c:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000ca40:	0c 1b       	sub	r11,r6
8000ca42:	f0 04 06 42 	mulu.d	r2,r8,r4
8000ca46:	06 95       	mov	r5,r3
8000ca48:	16 35       	cp.w	r5,r11
8000ca4a:	e0 8b 00 0a 	brhi	8000ca5e <__avr32_udiv64+0x24e>
8000ca4e:	5f 0b       	sreq	r11
8000ca50:	f4 09 09 49 	lsl	r9,r10,r9
8000ca54:	12 32       	cp.w	r2,r9
8000ca56:	5f b9       	srhi	r9
8000ca58:	f7 e9 00 09 	and	r9,r11,r9
8000ca5c:	c0 60       	breq	8000ca68 <__avr32_udiv64+0x258>
8000ca5e:	20 18       	sub	r8,1
8000ca60:	30 09       	mov	r9,0
8000ca62:	c0 38       	rjmp	8000ca68 <__avr32_udiv64+0x258>
8000ca64:	30 09       	mov	r9,0
8000ca66:	12 98       	mov	r8,r9
8000ca68:	10 9a       	mov	r10,r8
8000ca6a:	12 93       	mov	r3,r9
8000ca6c:	10 92       	mov	r2,r8
8000ca6e:	12 9b       	mov	r11,r9
8000ca70:	2f dd       	sub	sp,-12
8000ca72:	d8 32       	popm	r0-r7,pc

8000ca74 <__avr32_umod64>:
8000ca74:	d4 31       	pushm	r0-r7,lr
8000ca76:	1a 97       	mov	r7,sp
8000ca78:	20 3d       	sub	sp,12
8000ca7a:	10 9c       	mov	r12,r8
8000ca7c:	12 95       	mov	r5,r9
8000ca7e:	14 9e       	mov	lr,r10
8000ca80:	16 91       	mov	r1,r11
8000ca82:	16 96       	mov	r6,r11
8000ca84:	58 09       	cp.w	r9,0
8000ca86:	e0 81 00 81 	brne	8000cb88 <__avr32_umod64+0x114>
8000ca8a:	16 38       	cp.w	r8,r11
8000ca8c:	e0 88 00 12 	brls	8000cab0 <__avr32_umod64+0x3c>
8000ca90:	f0 08 12 00 	clz	r8,r8
8000ca94:	c4 e0       	breq	8000cb30 <__avr32_umod64+0xbc>
8000ca96:	f6 08 09 46 	lsl	r6,r11,r8
8000ca9a:	f8 08 09 4c 	lsl	r12,r12,r8
8000ca9e:	f0 0b 11 20 	rsub	r11,r8,32
8000caa2:	f4 08 09 4e 	lsl	lr,r10,r8
8000caa6:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000caaa:	f7 e6 10 06 	or	r6,r11,r6
8000caae:	c4 18       	rjmp	8000cb30 <__avr32_umod64+0xbc>
8000cab0:	58 08       	cp.w	r8,0
8000cab2:	c0 51       	brne	8000cabc <__avr32_umod64+0x48>
8000cab4:	30 19       	mov	r9,1
8000cab6:	f2 08 0d 08 	divu	r8,r9,r8
8000caba:	10 9c       	mov	r12,r8
8000cabc:	f8 08 12 00 	clz	r8,r12
8000cac0:	c0 31       	brne	8000cac6 <__avr32_umod64+0x52>
8000cac2:	18 16       	sub	r6,r12
8000cac4:	c3 68       	rjmp	8000cb30 <__avr32_umod64+0xbc>
8000cac6:	f0 03 11 20 	rsub	r3,r8,32
8000caca:	f4 03 0a 4b 	lsr	r11,r10,r3
8000cace:	f8 08 09 4c 	lsl	r12,r12,r8
8000cad2:	ec 08 09 49 	lsl	r9,r6,r8
8000cad6:	ec 03 0a 43 	lsr	r3,r6,r3
8000cada:	f7 e9 10 09 	or	r9,r11,r9
8000cade:	f8 05 16 10 	lsr	r5,r12,0x10
8000cae2:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000cae6:	e6 05 0d 02 	divu	r2,r3,r5
8000caea:	f2 0e 16 10 	lsr	lr,r9,0x10
8000caee:	ec 02 02 4b 	mul	r11,r6,r2
8000caf2:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000caf6:	16 3e       	cp.w	lr,r11
8000caf8:	c0 72       	brcc	8000cb06 <__avr32_umod64+0x92>
8000cafa:	18 0e       	add	lr,r12
8000cafc:	18 3e       	cp.w	lr,r12
8000cafe:	c0 43       	brcs	8000cb06 <__avr32_umod64+0x92>
8000cb00:	16 3e       	cp.w	lr,r11
8000cb02:	fd dc e3 0e 	addcs	lr,lr,r12
8000cb06:	fc 0b 01 03 	sub	r3,lr,r11
8000cb0a:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000cb0e:	e6 05 0d 02 	divu	r2,r3,r5
8000cb12:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000cb16:	a5 36       	mul	r6,r2
8000cb18:	0c 39       	cp.w	r9,r6
8000cb1a:	c0 72       	brcc	8000cb28 <__avr32_umod64+0xb4>
8000cb1c:	18 09       	add	r9,r12
8000cb1e:	18 39       	cp.w	r9,r12
8000cb20:	c0 43       	brcs	8000cb28 <__avr32_umod64+0xb4>
8000cb22:	0c 39       	cp.w	r9,r6
8000cb24:	f3 dc e3 09 	addcs	r9,r9,r12
8000cb28:	f2 06 01 06 	sub	r6,r9,r6
8000cb2c:	f4 08 09 4e 	lsl	lr,r10,r8
8000cb30:	f8 0a 16 10 	lsr	r10,r12,0x10
8000cb34:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000cb38:	ec 0a 0d 02 	divu	r2,r6,r10
8000cb3c:	fc 09 16 10 	lsr	r9,lr,0x10
8000cb40:	ea 02 02 4b 	mul	r11,r5,r2
8000cb44:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000cb48:	16 39       	cp.w	r9,r11
8000cb4a:	c0 72       	brcc	8000cb58 <__avr32_umod64+0xe4>
8000cb4c:	18 09       	add	r9,r12
8000cb4e:	18 39       	cp.w	r9,r12
8000cb50:	c0 43       	brcs	8000cb58 <__avr32_umod64+0xe4>
8000cb52:	16 39       	cp.w	r9,r11
8000cb54:	f3 dc e3 09 	addcs	r9,r9,r12
8000cb58:	f2 0b 01 0b 	sub	r11,r9,r11
8000cb5c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000cb60:	f6 0a 0d 0a 	divu	r10,r11,r10
8000cb64:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000cb68:	ea 0a 02 4a 	mul	r10,r5,r10
8000cb6c:	14 3e       	cp.w	lr,r10
8000cb6e:	c0 72       	brcc	8000cb7c <__avr32_umod64+0x108>
8000cb70:	18 0e       	add	lr,r12
8000cb72:	18 3e       	cp.w	lr,r12
8000cb74:	c0 43       	brcs	8000cb7c <__avr32_umod64+0x108>
8000cb76:	14 3e       	cp.w	lr,r10
8000cb78:	fd dc e3 0e 	addcs	lr,lr,r12
8000cb7c:	fc 0a 01 0a 	sub	r10,lr,r10
8000cb80:	30 0b       	mov	r11,0
8000cb82:	f4 08 0a 4a 	lsr	r10,r10,r8
8000cb86:	c7 b8       	rjmp	8000cc7c <__avr32_umod64+0x208>
8000cb88:	16 39       	cp.w	r9,r11
8000cb8a:	e0 8b 00 79 	brhi	8000cc7c <__avr32_umod64+0x208>
8000cb8e:	f2 09 12 00 	clz	r9,r9
8000cb92:	c1 21       	brne	8000cbb6 <__avr32_umod64+0x142>
8000cb94:	10 3a       	cp.w	r10,r8
8000cb96:	5f 2b       	srhs	r11
8000cb98:	0a 31       	cp.w	r1,r5
8000cb9a:	5f ba       	srhi	r10
8000cb9c:	f7 ea 10 0a 	or	r10,r11,r10
8000cba0:	f2 0a 18 00 	cp.b	r10,r9
8000cba4:	c0 60       	breq	8000cbb0 <__avr32_umod64+0x13c>
8000cba6:	fc 08 01 0c 	sub	r12,lr,r8
8000cbaa:	e2 05 01 46 	sbc	r6,r1,r5
8000cbae:	18 9e       	mov	lr,r12
8000cbb0:	0c 9b       	mov	r11,r6
8000cbb2:	1c 9a       	mov	r10,lr
8000cbb4:	c6 48       	rjmp	8000cc7c <__avr32_umod64+0x208>
8000cbb6:	ea 09 09 4c 	lsl	r12,r5,r9
8000cbba:	f2 06 11 20 	rsub	r6,r9,32
8000cbbe:	f6 09 09 4b 	lsl	r11,r11,r9
8000cbc2:	f0 09 09 42 	lsl	r2,r8,r9
8000cbc6:	ef 46 ff f4 	st.w	r7[-12],r6
8000cbca:	f0 06 0a 48 	lsr	r8,r8,r6
8000cbce:	18 48       	or	r8,r12
8000cbd0:	e2 06 0a 4c 	lsr	r12,r1,r6
8000cbd4:	f4 09 09 43 	lsl	r3,r10,r9
8000cbd8:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000cbdc:	f4 06 0a 4a 	lsr	r10,r10,r6
8000cbe0:	16 4a       	or	r10,r11
8000cbe2:	f0 0b 16 10 	lsr	r11,r8,0x10
8000cbe6:	f8 0b 0d 04 	divu	r4,r12,r11
8000cbea:	f4 0c 16 10 	lsr	r12,r10,0x10
8000cbee:	08 91       	mov	r1,r4
8000cbf0:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000cbf4:	e8 0e 02 46 	mul	r6,r4,lr
8000cbf8:	0c 3c       	cp.w	r12,r6
8000cbfa:	c0 a2       	brcc	8000cc0e <__avr32_umod64+0x19a>
8000cbfc:	20 11       	sub	r1,1
8000cbfe:	10 0c       	add	r12,r8
8000cc00:	10 3c       	cp.w	r12,r8
8000cc02:	c0 63       	brcs	8000cc0e <__avr32_umod64+0x19a>
8000cc04:	0c 3c       	cp.w	r12,r6
8000cc06:	f7 b1 03 01 	sublo	r1,1
8000cc0a:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000cc0e:	0c 1c       	sub	r12,r6
8000cc10:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000cc14:	f8 0b 0d 04 	divu	r4,r12,r11
8000cc18:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000cc1c:	08 96       	mov	r6,r4
8000cc1e:	e8 0e 02 4e 	mul	lr,r4,lr
8000cc22:	1c 3b       	cp.w	r11,lr
8000cc24:	c0 a2       	brcc	8000cc38 <__avr32_umod64+0x1c4>
8000cc26:	20 16       	sub	r6,1
8000cc28:	10 0b       	add	r11,r8
8000cc2a:	10 3b       	cp.w	r11,r8
8000cc2c:	c0 63       	brcs	8000cc38 <__avr32_umod64+0x1c4>
8000cc2e:	1c 3b       	cp.w	r11,lr
8000cc30:	f7 b6 03 01 	sublo	r6,1
8000cc34:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000cc38:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000cc3c:	1c 1b       	sub	r11,lr
8000cc3e:	e2 02 06 40 	mulu.d	r0,r1,r2
8000cc42:	00 9e       	mov	lr,r0
8000cc44:	02 9c       	mov	r12,r1
8000cc46:	16 3c       	cp.w	r12,r11
8000cc48:	e0 8b 00 08 	brhi	8000cc58 <__avr32_umod64+0x1e4>
8000cc4c:	5f 06       	sreq	r6
8000cc4e:	06 30       	cp.w	r0,r3
8000cc50:	5f ba       	srhi	r10
8000cc52:	ed ea 00 0a 	and	r10,r6,r10
8000cc56:	c0 60       	breq	8000cc62 <__avr32_umod64+0x1ee>
8000cc58:	fc 02 01 04 	sub	r4,lr,r2
8000cc5c:	f8 08 01 4c 	sbc	r12,r12,r8
8000cc60:	08 9e       	mov	lr,r4
8000cc62:	e6 0e 01 0a 	sub	r10,r3,lr
8000cc66:	f6 0c 01 4c 	sbc	r12,r11,r12
8000cc6a:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000cc6e:	f8 09 0a 4b 	lsr	r11,r12,r9
8000cc72:	f4 09 0a 4a 	lsr	r10,r10,r9
8000cc76:	f8 01 09 4c 	lsl	r12,r12,r1
8000cc7a:	18 4a       	or	r10,r12
8000cc7c:	2f dd       	sub	sp,-12
8000cc7e:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000ce00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000ce00:	c0 08       	rjmp	8000ce00 <_evba>
	...

8000ce04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000ce04:	c0 08       	rjmp	8000ce04 <_handle_TLB_Multiple_Hit>
	...

8000ce08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000ce08:	c0 08       	rjmp	8000ce08 <_handle_Bus_Error_Data_Fetch>
	...

8000ce0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000ce0c:	c0 08       	rjmp	8000ce0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000ce10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000ce10:	c0 08       	rjmp	8000ce10 <_handle_NMI>
	...

8000ce14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000ce14:	c0 08       	rjmp	8000ce14 <_handle_Instruction_Address>
	...

8000ce18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000ce18:	c0 08       	rjmp	8000ce18 <_handle_ITLB_Protection>
	...

8000ce1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000ce1c:	c0 08       	rjmp	8000ce1c <_handle_Breakpoint>
	...

8000ce20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000ce20:	c0 08       	rjmp	8000ce20 <_handle_Illegal_Opcode>
	...

8000ce24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000ce24:	c0 08       	rjmp	8000ce24 <_handle_Unimplemented_Instruction>
	...

8000ce28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000ce28:	c0 08       	rjmp	8000ce28 <_handle_Privilege_Violation>
	...

8000ce2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000ce2c:	c0 08       	rjmp	8000ce2c <_handle_Floating_Point>
	...

8000ce30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000ce30:	c0 08       	rjmp	8000ce30 <_handle_Coprocessor_Absent>
	...

8000ce34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000ce34:	c0 08       	rjmp	8000ce34 <_handle_Data_Address_Read>
	...

8000ce38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000ce38:	c0 08       	rjmp	8000ce38 <_handle_Data_Address_Write>
	...

8000ce3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000ce3c:	c0 08       	rjmp	8000ce3c <_handle_DTLB_Protection_Read>
	...

8000ce40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000ce40:	c0 08       	rjmp	8000ce40 <_handle_DTLB_Protection_Write>
	...

8000ce44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000ce44:	c0 08       	rjmp	8000ce44 <_handle_DTLB_Modified>
	...

8000ce50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000ce50:	c0 08       	rjmp	8000ce50 <_handle_ITLB_Miss>
	...

8000ce60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000ce60:	c0 08       	rjmp	8000ce60 <_handle_DTLB_Miss_Read>
	...

8000ce70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000ce70:	c0 08       	rjmp	8000ce70 <_handle_DTLB_Miss_Write>
	...

8000cf00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000cf00:	fe cf 71 18 	sub	pc,pc,28952

8000cf04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000cf04:	30 0c       	mov	r12,0
8000cf06:	fe b0 c3 8f 	rcall	80005624 <_get_interrupt_handler>
8000cf0a:	58 0c       	cp.w	r12,0
8000cf0c:	f8 0f 17 10 	movne	pc,r12
8000cf10:	d6 03       	rete

8000cf12 <_int1>:
8000cf12:	30 1c       	mov	r12,1
8000cf14:	fe b0 c3 88 	rcall	80005624 <_get_interrupt_handler>
8000cf18:	58 0c       	cp.w	r12,0
8000cf1a:	f8 0f 17 10 	movne	pc,r12
8000cf1e:	d6 03       	rete

8000cf20 <_int2>:
8000cf20:	30 2c       	mov	r12,2
8000cf22:	fe b0 c3 81 	rcall	80005624 <_get_interrupt_handler>
8000cf26:	58 0c       	cp.w	r12,0
8000cf28:	f8 0f 17 10 	movne	pc,r12
8000cf2c:	d6 03       	rete

8000cf2e <_int3>:
8000cf2e:	30 3c       	mov	r12,3
8000cf30:	fe b0 c3 7a 	rcall	80005624 <_get_interrupt_handler>
8000cf34:	58 0c       	cp.w	r12,0
8000cf36:	f8 0f 17 10 	movne	pc,r12
8000cf3a:	d6 03       	rete

8000cf3c <ipr_val>:
8000cf3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000cf4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cffc:	d7 03 d7 03                                         ....
