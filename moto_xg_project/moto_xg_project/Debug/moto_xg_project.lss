
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000a6fc  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000c800  8000c800  0000cc00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001160  8000ca00  8000ca00  0000ce00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a40  00000004  8000db60  0000e004  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .balign       00000004  00000a44  8000e5a0  0000ea44  2**0
                  ALLOC
  7 .bss          000046d8  00000a48  8000e5a0  0000ea48  2**2
                  ALLOC
  8 .comment      00000030  00000000  00000000  0000ea44  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001300  00000000  00000000  0000ea78  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 00002919  00000000  00000000  0000fd78  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0002ab94  00000000  00000000  00012691  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00006e1c  00000000  00000000  0003d225  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0001698e  00000000  00000000  00044041  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00003274  00000000  00000000  0005a9d0  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    000073b8  00000000  00000000  0005dc44  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000dcf5  00000000  00000000  00064ffc  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_macinfo 0170ab63  00000000  00000000  00072cf1  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 19 .debug_ranges 000013d0  00000000  00000000  0177d858  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c8 dc 	sub	pc,pc,-14116

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d 94       	ld.ub	r4,r6[0x1]

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 64       	and	r4,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 18       	sub	r8,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	41 24       	lddsp	r4,sp[0x48]
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	21 24       	sub	r4,18
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	28 cc       	sub	r12,-116
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	29 6c       	sub	r12,-106
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	ca 00       	breq	80001fc2 <_trampoline+0x1fc2>
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	20 90       	sub	r0,9
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	66 1c       	ld.w	r12,r3[0x4]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 54       	eor	r4,r5

80002090 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
80002090:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
80002092:	f0 1f 00 1d 	mcall	80002104 <app_cfg+0x74>
80002096:	49 d8       	lddpc	r8,80002108 <app_cfg+0x78>
80002098:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
8000209a:	49 d7       	lddpc	r7,8000210c <app_cfg+0x7c>
		{	
			{
				xcmp_IdleTestTone();						
				if(isAudioRouting == 0)
8000209c:	49 d6       	lddpc	r6,80002110 <app_cfg+0x80>
					
				}
				else
				{
					isAudioRouting++;
					if(isAudioRouting == 5)xcmp_data_session_req(message, 12, 9);
8000209e:	49 e2       	lddpc	r2,80002114 <app_cfg+0x84>
800020a0:	30 91       	mov	r1,9
800020a2:	30 c0       	mov	r0,12
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020a4:	30 43       	mov	r3,4
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020a6:	30 24       	mov	r4,2
					//xcmp_enter_enhanced_OB_mode();
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020a8:	30 15       	mov	r5,1
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800020aa:	6e 08       	ld.w	r8,r7[0x0]
800020ac:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800020b0:	58 38       	cp.w	r8,3
800020b2:	c2 31       	brne	800020f8 <app_cfg+0x68>
		{	
			{
				xcmp_IdleTestTone();						
800020b4:	f0 1f 00 19 	mcall	80002118 <app_cfg+0x88>
				if(isAudioRouting == 0)
800020b8:	6c 08       	ld.w	r8,r6[0x0]
800020ba:	58 08       	cp.w	r8,0
800020bc:	c0 31       	brne	800020c2 <app_cfg+0x32>
					//xcmp_enter_enhanced_OB_mode();
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020be:	8d 05       	st.w	r6[0x0],r5
800020c0:	c1 c8       	rjmp	800020f8 <app_cfg+0x68>
				}
				else if(isAudioRouting == 1)
800020c2:	58 18       	cp.w	r8,1
800020c4:	c0 31       	brne	800020ca <app_cfg+0x3a>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020c6:	8d 04       	st.w	r6[0x0],r4
800020c8:	c1 88       	rjmp	800020f8 <app_cfg+0x68>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
800020ca:	58 28       	cp.w	r8,2
800020cc:	c0 91       	brne	800020de <app_cfg+0x4e>
				{				
					xcmp_data_session_req(message, 12, 9);
800020ce:	02 9a       	mov	r10,r1
800020d0:	00 9b       	mov	r11,r0
800020d2:	04 9c       	mov	r12,r2
800020d4:	f0 1f 00 12 	mcall	8000211c <app_cfg+0x8c>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020d8:	30 38       	mov	r8,3
800020da:	8d 08       	st.w	r6[0x0],r8
800020dc:	c0 e8       	rjmp	800020f8 <app_cfg+0x68>
					
				}
				else if(isAudioRouting == 3)
800020de:	58 38       	cp.w	r8,3
800020e0:	c0 31       	brne	800020e6 <app_cfg+0x56>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020e2:	8d 03       	st.w	r6[0x0],r3
800020e4:	c0 a8       	rjmp	800020f8 <app_cfg+0x68>
					
				}
				else
				{
					isAudioRouting++;
800020e6:	2f f8       	sub	r8,-1
800020e8:	8d 08       	st.w	r6[0x0],r8
					if(isAudioRouting == 5)xcmp_data_session_req(message, 12, 9);
800020ea:	58 58       	cp.w	r8,5
800020ec:	c0 61       	brne	800020f8 <app_cfg+0x68>
800020ee:	02 9a       	mov	r10,r1
800020f0:	00 9b       	mov	r11,r0
800020f2:	04 9c       	mov	r12,r2
800020f4:	f0 1f 00 0a 	mcall	8000211c <app_cfg+0x8c>
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020f8:	e0 6b 0f a0 	mov	r11,4000
800020fc:	48 3c       	lddpc	r12,80002108 <app_cfg+0x78>
800020fe:	f0 1f 00 09 	mcall	80002120 <app_cfg+0x90>
	}
80002102:	cd 4b       	rjmp	800020aa <app_cfg+0x1a>
80002104:	80 00       	ld.sh	r0,r0[0x0]
80002106:	63 54       	ld.w	r4,r1[0x54]
80002108:	00 00       	add	r0,r0
8000210a:	0a 4c       	or	r12,r5
8000210c:	00 00       	add	r0,r0
8000210e:	0d 94       	ld.ub	r4,r6[0x1]
80002110:	00 00       	add	r0,r0
80002112:	0a 60       	and	r0,r5
80002114:	00 00       	add	r0,r0
80002116:	00 04       	add	r4,r0
80002118:	80 00       	ld.sh	r0,r0[0x0]
8000211a:	42 ac       	lddsp	r12,sp[0xa8]
8000211c:	80 00       	ld.sh	r0,r0[0x0]
8000211e:	41 78       	lddsp	r8,sp[0x5c]
80002120:	80 00       	ld.sh	r0,r0[0x0]
80002122:	64 bc       	ld.w	r12,r2[0x2c]

80002124 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002124:	d4 01       	pushm	lr
  log("R");
80002126:	48 3c       	lddpc	r12,80002130 <app_payload_tx_proc+0xc>
80002128:	f0 1f 00 03 	mcall	80002134 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
8000212c:	d8 02       	popm	pc
8000212e:	00 00       	add	r0,r0
80002130:	80 00       	ld.sh	r0,r0[0x0]
80002132:	ca 08       	rjmp	80002272 <ButtonConfig_brdcst_func+0x5e>
80002134:	80 00       	ld.sh	r0,r0[0x0]
80002136:	69 e0       	ld.w	r0,r4[0x78]

80002138 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
80002138:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
8000213a:	48 3c       	lddpc	r12,80002144 <FD_brdcst_func+0xc>
8000213c:	f0 1f 00 03 	mcall	80002148 <FD_brdcst_func+0x10>
	
}
80002140:	d8 02       	popm	pc
80002142:	00 00       	add	r0,r0
80002144:	80 00       	ld.sh	r0,r0[0x0]
80002146:	ca 0c       	rcall	80002286 <ButtonConfig_brdcst_func+0x72>
80002148:	80 00       	ld.sh	r0,r0[0x0]
8000214a:	69 e0       	ld.w	r0,r4[0x78]

8000214c <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
8000214c:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
8000214e:	48 3c       	lddpc	r12,80002158 <FD_reply_func+0xc>
80002150:	f0 1f 00 03 	mcall	8000215c <FD_reply_func+0x10>
	
	
}
80002154:	d8 02       	popm	pc
80002156:	00 00       	add	r0,r0
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	ca 2c       	rcall	8000229e <ButtonConfig_brdcst_func+0x8a>
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	69 e0       	ld.w	r0,r4[0x78]

80002160 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002160:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002162:	48 3c       	lddpc	r12,8000216c <FD_request_func+0xc>
80002164:	f0 1f 00 03 	mcall	80002170 <FD_request_func+0x10>
	
	
}
80002168:	d8 02       	popm	pc
8000216a:	00 00       	add	r0,r0
8000216c:	80 00       	ld.sh	r0,r0[0x0]
8000216e:	ca 48       	rjmp	800022b6 <ButtonConfig_brdcst_func+0xa2>
80002170:	80 00       	ld.sh	r0,r0[0x0]
80002172:	69 e0       	ld.w	r0,r4[0x78]

80002174 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002174:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002176:	48 3c       	lddpc	r12,80002180 <EnOB_brdcst_func+0xc>
80002178:	f0 1f 00 03 	mcall	80002184 <EnOB_brdcst_func+0x10>
}
8000217c:	d8 02       	popm	pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	ca 64       	brge	800020ce <app_cfg+0x3e>
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	69 e0       	ld.w	r0,r4[0x78]

80002188 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002188:	eb cd 40 80 	pushm	r7,lr
8000218c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000218e:	19 a9       	ld.ub	r9,r12[0x2]
80002190:	30 08       	mov	r8,0
80002192:	f0 09 18 00 	cp.b	r9,r8
80002196:	c1 91       	brne	800021c8 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002198:	19 b8       	ld.ub	r8,r12[0x3]
8000219a:	30 19       	mov	r9,1
8000219c:	f2 08 18 00 	cp.b	r8,r9
800021a0:	c0 61       	brne	800021ac <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
800021a2:	49 0c       	lddpc	r12,800021e0 <EnOB_reply_func+0x58>
800021a4:	f0 1f 00 10 	mcall	800021e4 <EnOB_reply_func+0x5c>
800021a8:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
800021ac:	58 08       	cp.w	r8,0
800021ae:	c0 61       	brne	800021ba <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
800021b0:	48 ec       	lddpc	r12,800021e8 <EnOB_reply_func+0x60>
800021b2:	f0 1f 00 0d 	mcall	800021e4 <EnOB_reply_func+0x5c>
800021b6:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
800021ba:	1a d8       	st.w	--sp,r8
800021bc:	48 cc       	lddpc	r12,800021ec <EnOB_reply_func+0x64>
800021be:	f0 1f 00 0a 	mcall	800021e4 <EnOB_reply_func+0x5c>
800021c2:	2f fd       	sub	sp,-4
800021c4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
800021c8:	48 ac       	lddpc	r12,800021f0 <EnOB_reply_func+0x68>
800021ca:	f0 1f 00 07 	mcall	800021e4 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
800021ce:	0f a8       	ld.ub	r8,r7[0x2]
800021d0:	1a d8       	st.w	--sp,r8
800021d2:	48 9c       	lddpc	r12,800021f4 <EnOB_reply_func+0x6c>
800021d4:	f0 1f 00 04 	mcall	800021e4 <EnOB_reply_func+0x5c>
800021d8:	2f fd       	sub	sp,-4
800021da:	e3 cd 80 80 	ldm	sp++,r7,pc
800021de:	00 00       	add	r0,r0
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	ca 7c       	rcall	80002330 <Phyuserinput_brdcst_func+0x40>
800021e4:	80 00       	ld.sh	r0,r0[0x0]
800021e6:	69 e0       	ld.w	r0,r4[0x78]
800021e8:	80 00       	ld.sh	r0,r0[0x0]
800021ea:	ca 94       	brge	8000213c <FD_brdcst_func+0x4>
800021ec:	80 00       	ld.sh	r0,r0[0x0]
800021ee:	ca a8       	rjmp	80002342 <Phyuserinput_brdcst_func+0x52>
800021f0:	80 00       	ld.sh	r0,r0[0x0]
800021f2:	ca c0       	breq	8000214a <FD_brdcst_func+0x12>
800021f4:	80 00       	ld.sh	r0,r0[0x0]
800021f6:	ca dc       	rcall	80002350 <Phyuserinput_brdcst_func+0x60>

800021f8 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
800021f8:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
800021fa:	19 a9       	ld.ub	r9,r12[0x2]
800021fc:	31 18       	mov	r8,17
800021fe:	f0 09 18 00 	cp.b	r9,r8
80002202:	c0 41       	brne	8000220a <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002204:	48 2c       	lddpc	r12,8000220c <SingleDetection_brdcst_func+0x14>
80002206:	f0 1f 00 03 	mcall	80002210 <SingleDetection_brdcst_func+0x18>
8000220a:	d8 02       	popm	pc
8000220c:	80 00       	ld.sh	r0,r0[0x0]
8000220e:	ca f4       	brge	8000216c <FD_request_func+0xc>
80002210:	80 00       	ld.sh	r0,r0[0x0]
80002212:	69 e0       	ld.w	r0,r4[0x78]

80002214 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002214:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
80002216:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
8000221a:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
8000221c:	4a bc       	lddpc	r12,800022c8 <ButtonConfig_brdcst_func+0xb4>
8000221e:	f0 1f 00 2c 	mcall	800022cc <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
80002222:	0f 88       	ld.ub	r8,r7[0x0]
80002224:	1a d8       	st.w	--sp,r8
80002226:	4a bc       	lddpc	r12,800022d0 <ButtonConfig_brdcst_func+0xbc>
80002228:	f0 1f 00 29 	mcall	800022cc <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
8000222c:	1a d5       	st.w	--sp,r5
8000222e:	4a ac       	lddpc	r12,800022d4 <ButtonConfig_brdcst_func+0xc0>
80002230:	f0 1f 00 27 	mcall	800022cc <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002234:	0f a8       	ld.ub	r8,r7[0x2]
80002236:	1a d8       	st.w	--sp,r8
80002238:	4a 8c       	lddpc	r12,800022d8 <ButtonConfig_brdcst_func+0xc4>
8000223a:	f0 1f 00 25 	mcall	800022cc <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000223e:	2f dd       	sub	sp,-12
80002240:	58 05       	cp.w	r5,0
80002242:	c4 10       	breq	800022c4 <ButtonConfig_brdcst_func+0xb0>
80002244:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002246:	4a 64       	lddpc	r4,800022dc <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002248:	4a 63       	lddpc	r3,800022e0 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000224a:	4a 72       	lddpc	r2,800022e4 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000224c:	4a 71       	lddpc	r1,800022e8 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000224e:	4a 80       	lddpc	r0,800022ec <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002250:	0f b9       	ld.ub	r9,r7[0x3]
80002252:	0f c8       	ld.ub	r8,r7[0x4]
80002254:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002258:	1a d8       	st.w	--sp,r8
8000225a:	1a d6       	st.w	--sp,r6
8000225c:	08 9c       	mov	r12,r4
8000225e:	f0 1f 00 1c 	mcall	800022cc <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002262:	0f d9       	ld.ub	r9,r7[0x5]
80002264:	0f e8       	ld.ub	r8,r7[0x6]
80002266:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000226a:	1a d8       	st.w	--sp,r8
8000226c:	1a d6       	st.w	--sp,r6
8000226e:	06 9c       	mov	r12,r3
80002270:	f0 1f 00 17 	mcall	800022cc <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002274:	0f f9       	ld.ub	r9,r7[0x7]
80002276:	ef 38 00 08 	ld.ub	r8,r7[8]
8000227a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227e:	1a d8       	st.w	--sp,r8
80002280:	1a d6       	st.w	--sp,r6
80002282:	04 9c       	mov	r12,r2
80002284:	f0 1f 00 12 	mcall	800022cc <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002288:	ef 39 00 09 	ld.ub	r9,r7[9]
8000228c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002290:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002294:	1a d8       	st.w	--sp,r8
80002296:	1a d6       	st.w	--sp,r6
80002298:	02 9c       	mov	r12,r1
8000229a:	f0 1f 00 0d 	mcall	800022cc <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000229e:	2f 8d       	sub	sp,-32
800022a0:	ef 39 00 0b 	ld.ub	r9,r7[11]
800022a4:	ef 38 00 0c 	ld.ub	r8,r7[12]
800022a8:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022ac:	1a d8       	st.w	--sp,r8
800022ae:	1a d6       	st.w	--sp,r6
800022b0:	00 9c       	mov	r12,r0
800022b2:	f0 1f 00 07 	mcall	800022cc <ButtonConfig_brdcst_func+0xb8>
800022b6:	2f f6       	sub	r6,-1
800022b8:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
800022ba:	2f ed       	sub	sp,-8
800022bc:	ec 05 18 00 	cp.b	r5,r6
800022c0:	fe 9b ff c8 	brhi	80002250 <ButtonConfig_brdcst_func+0x3c>
800022c4:	d8 32       	popm	r0-r7,pc
800022c6:	00 00       	add	r0,r0
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	cb 08       	rjmp	8000242a <DataSession_brdcst_func+0x7e>
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	69 e0       	ld.w	r0,r4[0x78]
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	cb 28       	rjmp	80002436 <DataSession_brdcst_func+0x8a>
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	cb 3c       	rcall	8000243c <DataSession_brdcst_func+0x90>
800022d8:	80 00       	ld.sh	r0,r0[0x0]
800022da:	cb 54       	brge	80002244 <ButtonConfig_brdcst_func+0x30>
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	cb 74       	brge	8000224c <ButtonConfig_brdcst_func+0x38>
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	cb 9c       	rcall	80002454 <DataSession_brdcst_func+0xa8>
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	cb c4       	brge	8000225e <ButtonConfig_brdcst_func+0x4a>
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	cb e8       	rjmp	80002466 <DataSession_brdcst_func+0xba>
800022ec:	80 00       	ld.sh	r0,r0[0x0]
800022ee:	cc 10       	breq	80002270 <ButtonConfig_brdcst_func+0x5c>

800022f0 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800022f0:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
800022f4:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
800022f6:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800022f8:	19 c7       	ld.ub	r7,r12[0x4]
800022fa:	19 d8       	ld.ub	r8,r12[0x5]
800022fc:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
80002300:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
80002302:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
80002304:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
80002308:	49 0c       	lddpc	r12,80002348 <Phyuserinput_brdcst_func+0x58>
8000230a:	f0 1f 00 11 	mcall	8000234c <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
8000230e:	1a d6       	st.w	--sp,r6
80002310:	49 0c       	lddpc	r12,80002350 <Phyuserinput_brdcst_func+0x60>
80002312:	f0 1f 00 0f 	mcall	8000234c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
80002316:	1a d5       	st.w	--sp,r5
80002318:	48 fc       	lddpc	r12,80002354 <Phyuserinput_brdcst_func+0x64>
8000231a:	f0 1f 00 0d 	mcall	8000234c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
8000231e:	5c 77       	castu.h	r7
80002320:	1a d7       	st.w	--sp,r7
80002322:	48 ec       	lddpc	r12,80002358 <Phyuserinput_brdcst_func+0x68>
80002324:	f0 1f 00 0a 	mcall	8000234c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
80002328:	1a d4       	st.w	--sp,r4
8000232a:	48 dc       	lddpc	r12,8000235c <Phyuserinput_brdcst_func+0x6c>
8000232c:	f0 1f 00 08 	mcall	8000234c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
80002330:	1a d3       	st.w	--sp,r3
80002332:	48 cc       	lddpc	r12,80002360 <Phyuserinput_brdcst_func+0x70>
80002334:	f0 1f 00 06 	mcall	8000234c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
80002338:	1a d2       	st.w	--sp,r2
8000233a:	48 bc       	lddpc	r12,80002364 <Phyuserinput_brdcst_func+0x74>
8000233c:	f0 1f 00 04 	mcall	8000234c <Phyuserinput_brdcst_func+0x5c>
80002340:	2f ad       	sub	sp,-24
	
	
	
	
	
}
80002342:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002346:	00 00       	add	r0,r0
80002348:	80 00       	ld.sh	r0,r0[0x0]
8000234a:	cc 34       	brge	800022d0 <ButtonConfig_brdcst_func+0xbc>
8000234c:	80 00       	ld.sh	r0,r0[0x0]
8000234e:	69 e0       	ld.w	r0,r4[0x78]
80002350:	80 00       	ld.sh	r0,r0[0x0]
80002352:	cc 58       	rjmp	800024dc <DataSession_reply_func+0x50>
80002354:	80 00       	ld.sh	r0,r0[0x0]
80002356:	cc 70       	breq	800022e4 <ButtonConfig_brdcst_func+0xd0>
80002358:	80 00       	ld.sh	r0,r0[0x0]
8000235a:	cc 84       	brge	800022ea <ButtonConfig_brdcst_func+0xd6>
8000235c:	80 00       	ld.sh	r0,r0[0x0]
8000235e:	cc 98       	rjmp	800024f0 <DataSession_reply_func+0x64>
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	cc ac       	rcall	800024f6 <DataSession_reply_func+0x6a>
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	cc cc       	rcall	800024fe <DataSession_reply_func+0x72>

80002368 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002368:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
8000236c:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002370:	0f 89       	ld.ub	r9,r7[0x0]
80002372:	30 08       	mov	r8,0
80002374:	f0 09 18 00 	cp.b	r9,r8
80002378:	c0 c1       	brne	80002390 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000237a:	48 9c       	lddpc	r12,8000239c <ButtonConfig_reply_func+0x34>
8000237c:	f0 1f 00 09 	mcall	800023a0 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002380:	0f 98       	ld.ub	r8,r7[0x1]
80002382:	1a d8       	st.w	--sp,r8
80002384:	48 8c       	lddpc	r12,800023a4 <ButtonConfig_reply_func+0x3c>
80002386:	f0 1f 00 07 	mcall	800023a0 <ButtonConfig_reply_func+0x38>
8000238a:	2f fd       	sub	sp,-4
8000238c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002390:	48 6c       	lddpc	r12,800023a8 <ButtonConfig_reply_func+0x40>
80002392:	f0 1f 00 04 	mcall	800023a0 <ButtonConfig_reply_func+0x38>
80002396:	e3 cd 80 80 	ldm	sp++,r7,pc
8000239a:	00 00       	add	r0,r0
8000239c:	80 00       	ld.sh	r0,r0[0x0]
8000239e:	cc ec       	rcall	8000253a <CallControl_brdcst_func+0x32>
800023a0:	80 00       	ld.sh	r0,r0[0x0]
800023a2:	69 e0       	ld.w	r0,r4[0x78]
800023a4:	80 00       	ld.sh	r0,r0[0x0]
800023a6:	cb 28       	rjmp	8000250a <CallControl_brdcst_func+0x2>
800023a8:	80 00       	ld.sh	r0,r0[0x0]
800023aa:	cd 04       	brge	8000234a <Phyuserinput_brdcst_func+0x5a>

800023ac <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800023ac:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800023ae:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
800023b2:	0d 88       	ld.ub	r8,r6[0x0]
800023b4:	32 49       	mov	r9,36
800023b6:	f2 08 18 00 	cp.b	r8,r9
800023ba:	c2 91       	brne	8000240c <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800023bc:	4a dc       	lddpc	r12,80002470 <DataSession_brdcst_func+0xc4>
800023be:	f0 1f 00 2e 	mcall	80002474 <DataSession_brdcst_func+0xc8>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800023c2:	0d a5       	ld.ub	r5,r6[0x2]
800023c4:	0d b8       	ld.ub	r8,r6[0x3]
800023c6:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800023ca:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800023cc:	0d 98       	ld.ub	r8,r6[0x1]
800023ce:	1a d8       	st.w	--sp,r8
800023d0:	4a ac       	lddpc	r12,80002478 <DataSession_brdcst_func+0xcc>
800023d2:	f0 1f 00 29 	mcall	80002474 <DataSession_brdcst_func+0xc8>
		log("\n\r paylaod_length: %d \n\r",data_length );
800023d6:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800023da:	1a d8       	st.w	--sp,r8
800023dc:	4a 8c       	lddpc	r12,8000247c <DataSession_brdcst_func+0xd0>
800023de:	f0 1f 00 26 	mcall	80002474 <DataSession_brdcst_func+0xc8>
		for(i=0; i<data_length; i++)
800023e2:	2f ed       	sub	sp,-8
800023e4:	58 05       	cp.w	r5,0
800023e6:	c4 40       	breq	8000246e <DataSession_brdcst_func+0xc2>
800023e8:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
800023ea:	4a 64       	lddpc	r4,80002480 <DataSession_brdcst_func+0xd4>
800023ec:	ec 07 00 08 	add	r8,r6,r7
800023f0:	11 c8       	ld.ub	r8,r8[0x4]
800023f2:	1a d8       	st.w	--sp,r8
800023f4:	1a d7       	st.w	--sp,r7
800023f6:	08 9c       	mov	r12,r4
800023f8:	f0 1f 00 1f 	mcall	80002474 <DataSession_brdcst_func+0xc8>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
800023fc:	2f f7       	sub	r7,-1
800023fe:	5c 57       	castu.b	r7
80002400:	2f ed       	sub	sp,-8
80002402:	ee 05 19 00 	cp.h	r5,r7
80002406:	fe 9b ff f3 	brhi	800023ec <DataSession_brdcst_func+0x40>
8000240a:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("State: 0x %X \n", ptr->State);
8000240c:	1a d8       	st.w	--sp,r8
8000240e:	49 ec       	lddpc	r12,80002484 <DataSession_brdcst_func+0xd8>
80002410:	f0 1f 00 19 	mcall	80002474 <DataSession_brdcst_func+0xc8>
		if (ptr->State)
80002414:	2f fd       	sub	sp,-4
80002416:	0d 89       	ld.ub	r9,r6[0x0]
80002418:	30 08       	mov	r8,0
8000241a:	f0 09 18 00 	cp.b	r9,r8
8000241e:	c0 40       	breq	80002426 <DataSession_brdcst_func+0x7a>
		{
			log("data transmit success\n");
80002420:	49 ac       	lddpc	r12,80002488 <DataSession_brdcst_func+0xdc>
80002422:	f0 1f 00 15 	mcall	80002474 <DataSession_brdcst_func+0xc8>
		}
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
			
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002426:	0d a5       	ld.ub	r5,r6[0x2]
80002428:	0d b8       	ld.ub	r8,r6[0x3]
8000242a:	f1 e5 10 85 	or	r5,r8,r5<<0x8
8000242e:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002430:	0d 98       	ld.ub	r8,r6[0x1]
80002432:	1a d8       	st.w	--sp,r8
80002434:	49 1c       	lddpc	r12,80002478 <DataSession_brdcst_func+0xcc>
80002436:	f0 1f 00 10 	mcall	80002474 <DataSession_brdcst_func+0xc8>
		log("\n\r paylaod_length: %d \n\r",data_length );
8000243a:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000243e:	1a d8       	st.w	--sp,r8
80002440:	48 fc       	lddpc	r12,8000247c <DataSession_brdcst_func+0xd0>
80002442:	f0 1f 00 0d 	mcall	80002474 <DataSession_brdcst_func+0xc8>
		for(i=0; i<data_length; i++)
80002446:	2f ed       	sub	sp,-8
80002448:	58 05       	cp.w	r5,0
8000244a:	c1 20       	breq	8000246e <DataSession_brdcst_func+0xc2>
8000244c:	30 07       	mov	r7,0
		{
				
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
8000244e:	48 d4       	lddpc	r4,80002480 <DataSession_brdcst_func+0xd4>
80002450:	ec 07 00 08 	add	r8,r6,r7
80002454:	11 c8       	ld.ub	r8,r8[0x4]
80002456:	1a d8       	st.w	--sp,r8
80002458:	1a d7       	st.w	--sp,r7
8000245a:	08 9c       	mov	r12,r4
8000245c:	f0 1f 00 06 	mcall	80002474 <DataSession_brdcst_func+0xc8>
			
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002460:	2f f7       	sub	r7,-1
80002462:	5c 57       	castu.b	r7
80002464:	2f ed       	sub	sp,-8
80002466:	ee 05 19 00 	cp.h	r5,r7
8000246a:	fe 9b ff f3 	brhi	80002450 <DataSession_brdcst_func+0xa4>
8000246e:	d8 22       	popm	r4-r7,pc
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	cd 20       	breq	80002416 <DataSession_brdcst_func+0x6a>
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	69 e0       	ld.w	r0,r4[0x78]
80002478:	80 00       	ld.sh	r0,r0[0x0]
8000247a:	cd 34       	brge	80002420 <DataSession_brdcst_func+0x74>
8000247c:	80 00       	ld.sh	r0,r0[0x0]
8000247e:	cd 4c       	rcall	80002626 <Volume_reply_func+0x2>
80002480:	80 00       	ld.sh	r0,r0[0x0]
80002482:	cd 68       	rjmp	8000262e <Volume_reply_func+0xa>
80002484:	80 00       	ld.sh	r0,r0[0x0]
80002486:	cd 80       	breq	80002436 <DataSession_brdcst_func+0x8a>
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	cd 90       	breq	8000243c <DataSession_brdcst_func+0x90>

8000248c <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
8000248c:	eb cd 40 80 	pushm	r7,lr
80002490:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002492:	19 a9       	ld.ub	r9,r12[0x2]
80002494:	30 08       	mov	r8,0
80002496:	f0 09 18 00 	cp.b	r9,r8
8000249a:	c1 11       	brne	800024bc <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
8000249c:	49 3c       	lddpc	r12,800024e8 <DataSession_reply_func+0x5c>
8000249e:	f0 1f 00 14 	mcall	800024ec <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
800024a2:	0f b8       	ld.ub	r8,r7[0x3]
800024a4:	1a d8       	st.w	--sp,r8
800024a6:	49 3c       	lddpc	r12,800024f0 <DataSession_reply_func+0x64>
800024a8:	f0 1f 00 11 	mcall	800024ec <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
800024ac:	0f c8       	ld.ub	r8,r7[0x4]
800024ae:	1a d8       	st.w	--sp,r8
800024b0:	49 1c       	lddpc	r12,800024f4 <DataSession_reply_func+0x68>
800024b2:	f0 1f 00 0f 	mcall	800024ec <DataSession_reply_func+0x60>
800024b6:	2f ed       	sub	sp,-8
800024b8:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
800024bc:	48 fc       	lddpc	r12,800024f8 <DataSession_reply_func+0x6c>
800024be:	f0 1f 00 0c 	mcall	800024ec <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
800024c2:	0f a8       	ld.ub	r8,r7[0x2]
800024c4:	1a d8       	st.w	--sp,r8
800024c6:	48 ec       	lddpc	r12,800024fc <DataSession_reply_func+0x70>
800024c8:	f0 1f 00 09 	mcall	800024ec <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
800024cc:	0f b8       	ld.ub	r8,r7[0x3]
800024ce:	1a d8       	st.w	--sp,r8
800024d0:	48 cc       	lddpc	r12,80002500 <DataSession_reply_func+0x74>
800024d2:	f0 1f 00 07 	mcall	800024ec <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
800024d6:	0f c8       	ld.ub	r8,r7[0x4]
800024d8:	1a d8       	st.w	--sp,r8
800024da:	48 bc       	lddpc	r12,80002504 <DataSession_reply_func+0x78>
800024dc:	f0 1f 00 04 	mcall	800024ec <DataSession_reply_func+0x60>
800024e0:	2f dd       	sub	sp,-12
800024e2:	e3 cd 80 80 	ldm	sp++,r7,pc
800024e6:	00 00       	add	r0,r0
800024e8:	80 00       	ld.sh	r0,r0[0x0]
800024ea:	cd a8       	rjmp	8000269e <spk_brdcst_func+0x16>
800024ec:	80 00       	ld.sh	r0,r0[0x0]
800024ee:	69 e0       	ld.w	r0,r4[0x78]
800024f0:	80 00       	ld.sh	r0,r0[0x0]
800024f2:	cd b8       	rjmp	800026a8 <spk_brdcst_func+0x20>
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	cd c4       	brge	800024ae <DataSession_reply_func+0x22>
800024f8:	80 00       	ld.sh	r0,r0[0x0]
800024fa:	cd d0       	breq	800024b4 <DataSession_reply_func+0x28>
800024fc:	80 00       	ld.sh	r0,r0[0x0]
800024fe:	cd e0       	breq	800024ba <DataSession_reply_func+0x2e>
80002500:	80 00       	ld.sh	r0,r0[0x0]
80002502:	cd f0       	breq	800024c0 <DataSession_reply_func+0x34>
80002504:	80 00       	ld.sh	r0,r0[0x0]
80002506:	cd fc       	rcall	800026c4 <spk_reply_func+0x4>

80002508 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002508:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
8000250c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002510:	0f 98       	ld.ub	r8,r7[0x1]
80002512:	1a d8       	st.w	--sp,r8
80002514:	48 bc       	lddpc	r12,80002540 <CallControl_brdcst_func+0x38>
80002516:	f0 1f 00 0c 	mcall	80002544 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000251a:	2f fd       	sub	sp,-4
8000251c:	0f 99       	ld.ub	r9,r7[0x1]
8000251e:	30 38       	mov	r8,3
80002520:	f0 09 18 00 	cp.b	r9,r8
80002524:	c0 41       	brne	8000252c <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
80002526:	30 09       	mov	r9,0
80002528:	48 88       	lddpc	r8,80002548 <CallControl_brdcst_func+0x40>
8000252a:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
8000252c:	0f 99       	ld.ub	r9,r7[0x1]
8000252e:	30 48       	mov	r8,4
80002530:	f0 09 18 00 	cp.b	r9,r8
80002534:	c0 41       	brne	8000253c <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
80002536:	30 19       	mov	r9,1
80002538:	48 48       	lddpc	r8,80002548 <CallControl_brdcst_func+0x40>
8000253a:	b0 89       	st.b	r8[0x0],r9
8000253c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002540:	80 00       	ld.sh	r0,r0[0x0]
80002542:	ce 08       	rjmp	80002702 <spk_reply_func+0x42>
80002544:	80 00       	ld.sh	r0,r0[0x0]
80002546:	69 e0       	ld.w	r0,r4[0x78]
80002548:	00 00       	add	r0,r0
8000254a:	0a 52       	eor	r2,r5

8000254c <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
8000254c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002550:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002554:	0f 99       	ld.ub	r9,r7[0x1]
80002556:	30 08       	mov	r8,0
80002558:	f0 09 18 00 	cp.b	r9,r8
8000255c:	c0 71       	brne	8000256a <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
8000255e:	48 ac       	lddpc	r12,80002584 <TransmitControl_brdcst_func+0x38>
80002560:	f0 1f 00 0a 	mcall	80002588 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
80002564:	30 09       	mov	r9,0
80002566:	48 a8       	lddpc	r8,8000258c <TransmitControl_brdcst_func+0x40>
80002568:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
8000256a:	0f 99       	ld.ub	r9,r7[0x1]
8000256c:	30 18       	mov	r8,1
8000256e:	f0 09 18 00 	cp.b	r9,r8
80002572:	c0 71       	brne	80002580 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
80002574:	48 7c       	lddpc	r12,80002590 <TransmitControl_brdcst_func+0x44>
80002576:	f0 1f 00 05 	mcall	80002588 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
8000257a:	30 19       	mov	r9,1
8000257c:	48 48       	lddpc	r8,8000258c <TransmitControl_brdcst_func+0x40>
8000257e:	b0 89       	st.b	r8[0x0],r9
80002580:	e3 cd 80 80 	ldm	sp++,r7,pc
80002584:	80 00       	ld.sh	r0,r0[0x0]
80002586:	ce 20       	breq	8000254a <CallControl_brdcst_func+0x42>
80002588:	80 00       	ld.sh	r0,r0[0x0]
8000258a:	69 e0       	ld.w	r0,r4[0x78]
8000258c:	00 00       	add	r0,r0
8000258e:	0a 51       	eor	r1,r5
80002590:	80 00       	ld.sh	r0,r0[0x0]
80002592:	ce 38       	rjmp	80002758 <mic_brdcst_func+0x50>

80002594 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002594:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002598:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000259c:	0f 89       	ld.ub	r9,r7[0x0]
8000259e:	30 08       	mov	r8,0
800025a0:	f0 09 18 00 	cp.b	r9,r8
800025a4:	c1 61       	brne	800025d0 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
800025a6:	48 ec       	lddpc	r12,800025dc <TransmitControl_reply_func+0x48>
800025a8:	f0 1f 00 0e 	mcall	800025e0 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
800025ac:	0f 98       	ld.ub	r8,r7[0x1]
800025ae:	1a d8       	st.w	--sp,r8
800025b0:	48 dc       	lddpc	r12,800025e4 <TransmitControl_reply_func+0x50>
800025b2:	f0 1f 00 0c 	mcall	800025e0 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
800025b6:	0f a8       	ld.ub	r8,r7[0x2]
800025b8:	1a d8       	st.w	--sp,r8
800025ba:	48 cc       	lddpc	r12,800025e8 <TransmitControl_reply_func+0x54>
800025bc:	f0 1f 00 09 	mcall	800025e0 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
800025c0:	0f b8       	ld.ub	r8,r7[0x3]
800025c2:	1a d8       	st.w	--sp,r8
800025c4:	48 ac       	lddpc	r12,800025ec <TransmitControl_reply_func+0x58>
800025c6:	f0 1f 00 07 	mcall	800025e0 <TransmitControl_reply_func+0x4c>
800025ca:	2f dd       	sub	sp,-12
800025cc:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
800025d0:	48 8c       	lddpc	r12,800025f0 <TransmitControl_reply_func+0x5c>
800025d2:	f0 1f 00 04 	mcall	800025e0 <TransmitControl_reply_func+0x4c>
800025d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800025da:	00 00       	add	r0,r0
800025dc:	80 00       	ld.sh	r0,r0[0x0]
800025de:	ce 4c       	rcall	800027a6 <mic_reply_func+0x46>
800025e0:	80 00       	ld.sh	r0,r0[0x0]
800025e2:	69 e0       	ld.w	r0,r4[0x78]
800025e4:	80 00       	ld.sh	r0,r0[0x0]
800025e6:	ce 68       	rjmp	800027b2 <mic_reply_func+0x52>
800025e8:	80 00       	ld.sh	r0,r0[0x0]
800025ea:	ce 7c       	rcall	800027b8 <mic_reply_func+0x58>
800025ec:	80 00       	ld.sh	r0,r0[0x0]
800025ee:	ce 98       	rjmp	800027c0 <mic_reply_func+0x60>
800025f0:	80 00       	ld.sh	r0,r0[0x0]
800025f2:	ce a8       	rjmp	800027c6 <mic_reply_func+0x66>

800025f4 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
800025f4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800025f6:	19 a9       	ld.ub	r9,r12[0x2]
800025f8:	30 08       	mov	r8,0
800025fa:	f0 09 18 00 	cp.b	r9,r8
800025fe:	c0 71       	brne	8000260c <AudioRoutingControl_reply_func+0x18>
	{
		log("AudioRouting OK");
80002600:	48 5c       	lddpc	r12,80002614 <AudioRoutingControl_reply_func+0x20>
80002602:	f0 1f 00 06 	mcall	80002618 <AudioRoutingControl_reply_func+0x24>
		xcmp_IdleTestTone();//提示通道配置成功
80002606:	f0 1f 00 06 	mcall	8000261c <AudioRoutingControl_reply_func+0x28>
8000260a:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
8000260c:	48 5c       	lddpc	r12,80002620 <AudioRoutingControl_reply_func+0x2c>
8000260e:	f0 1f 00 03 	mcall	80002618 <AudioRoutingControl_reply_func+0x24>
80002612:	d8 02       	popm	pc
80002614:	80 00       	ld.sh	r0,r0[0x0]
80002616:	ce c0       	breq	800025ee <TransmitControl_reply_func+0x5a>
80002618:	80 00       	ld.sh	r0,r0[0x0]
8000261a:	69 e0       	ld.w	r0,r4[0x78]
8000261c:	80 00       	ld.sh	r0,r0[0x0]
8000261e:	42 ac       	lddsp	r12,sp[0xa8]
80002620:	80 00       	ld.sh	r0,r0[0x0]
80002622:	ce d0       	breq	800025fc <AudioRoutingControl_reply_func+0x8>

80002624 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002624:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002628:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000262c:	0f 89       	ld.ub	r9,r7[0x0]
8000262e:	30 08       	mov	r8,0
80002630:	f0 09 18 00 	cp.b	r9,r8
80002634:	c1 b1       	brne	8000266a <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002636:	0f b8       	ld.ub	r8,r7[0x3]
80002638:	31 09       	mov	r9,16
8000263a:	f2 08 18 00 	cp.b	r8,r9
8000263e:	c0 f1       	brne	8000265c <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002640:	48 dc       	lddpc	r12,80002674 <Volume_reply_func+0x50>
80002642:	f0 1f 00 0e 	mcall	80002678 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002646:	0f 99       	ld.ub	r9,r7[0x1]
80002648:	0f a8       	ld.ub	r8,r7[0x2]
8000264a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000264e:	1a d8       	st.w	--sp,r8
80002650:	48 bc       	lddpc	r12,8000267c <Volume_reply_func+0x58>
80002652:	f0 1f 00 0a 	mcall	80002678 <Volume_reply_func+0x54>
80002656:	2f fd       	sub	sp,-4
80002658:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
8000265c:	1a d8       	st.w	--sp,r8
8000265e:	48 9c       	lddpc	r12,80002680 <Volume_reply_func+0x5c>
80002660:	f0 1f 00 06 	mcall	80002678 <Volume_reply_func+0x54>
80002664:	2f fd       	sub	sp,-4
80002666:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
8000266a:	48 7c       	lddpc	r12,80002684 <Volume_reply_func+0x60>
8000266c:	f0 1f 00 03 	mcall	80002678 <Volume_reply_func+0x54>
80002670:	e3 cd 80 80 	ldm	sp++,r7,pc
80002674:	80 00       	ld.sh	r0,r0[0x0]
80002676:	ce e4       	brge	80002652 <Volume_reply_func+0x2e>
80002678:	80 00       	ld.sh	r0,r0[0x0]
8000267a:	69 e0       	ld.w	r0,r4[0x78]
8000267c:	80 00       	ld.sh	r0,r0[0x0]
8000267e:	ce f8       	rjmp	8000285c <dcm_reply_func+0x20>
80002680:	80 00       	ld.sh	r0,r0[0x0]
80002682:	cf 14       	brge	80002664 <Volume_reply_func+0x40>
80002684:	80 00       	ld.sh	r0,r0[0x0]
80002686:	cf 2c       	rcall	8000286a <dcm_reply_func+0x2e>

80002688 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002688:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
8000268a:	19 d9       	ld.ub	r9,r12[0x5]
8000268c:	30 08       	mov	r8,0
8000268e:	f0 09 18 00 	cp.b	r9,r8
80002692:	c0 81       	brne	800026a2 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002694:	10 99       	mov	r9,r8
80002696:	48 78       	lddpc	r8,800026b0 <spk_brdcst_func+0x28>
80002698:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
8000269a:	48 7c       	lddpc	r12,800026b4 <spk_brdcst_func+0x2c>
8000269c:	f0 1f 00 07 	mcall	800026b8 <spk_brdcst_func+0x30>
800026a0:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
800026a2:	30 19       	mov	r9,1
800026a4:	48 38       	lddpc	r8,800026b0 <spk_brdcst_func+0x28>
800026a6:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
800026a8:	48 5c       	lddpc	r12,800026bc <spk_brdcst_func+0x34>
800026aa:	f0 1f 00 04 	mcall	800026b8 <spk_brdcst_func+0x30>
800026ae:	d8 02       	popm	pc
800026b0:	00 00       	add	r0,r0
800026b2:	0a 48       	or	r8,r5
800026b4:	80 00       	ld.sh	r0,r0[0x0]
800026b6:	cf 44       	brge	8000269e <spk_brdcst_func+0x16>
800026b8:	80 00       	ld.sh	r0,r0[0x0]
800026ba:	69 e0       	ld.w	r0,r4[0x78]
800026bc:	80 00       	ld.sh	r0,r0[0x0]
800026be:	cf 54       	brge	800026a8 <spk_brdcst_func+0x20>

800026c0 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
800026c0:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800026c2:	19 a9       	ld.ub	r9,r12[0x2]
800026c4:	30 08       	mov	r8,0
800026c6:	f0 09 18 00 	cp.b	r9,r8
800026ca:	c0 f1       	brne	800026e8 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
800026cc:	19 e9       	ld.ub	r9,r12[0x6]
800026ce:	f0 09 18 00 	cp.b	r9,r8
800026d2:	c0 40       	breq	800026da <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
800026d4:	30 19       	mov	r9,1
800026d6:	48 98       	lddpc	r8,800026f8 <spk_reply_func+0x38>
800026d8:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
800026da:	19 e8       	ld.ub	r8,r12[0x6]
800026dc:	1a d8       	st.w	--sp,r8
800026de:	48 8c       	lddpc	r12,800026fc <spk_reply_func+0x3c>
800026e0:	f0 1f 00 08 	mcall	80002700 <spk_reply_func+0x40>
800026e4:	2f fd       	sub	sp,-4
800026e6:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
800026e8:	30 09       	mov	r9,0
800026ea:	48 48       	lddpc	r8,800026f8 <spk_reply_func+0x38>
800026ec:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
800026ee:	48 6c       	lddpc	r12,80002704 <spk_reply_func+0x44>
800026f0:	f0 1f 00 04 	mcall	80002700 <spk_reply_func+0x40>
800026f4:	d8 02       	popm	pc
800026f6:	00 00       	add	r0,r0
800026f8:	00 00       	add	r0,r0
800026fa:	0a 48       	or	r8,r5
800026fc:	80 00       	ld.sh	r0,r0[0x0]
800026fe:	cf 60       	breq	800026ea <spk_reply_func+0x2a>
80002700:	80 00       	ld.sh	r0,r0[0x0]
80002702:	69 e0       	ld.w	r0,r4[0x78]
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	cf 70       	breq	800026f4 <spk_reply_func+0x34>

80002708 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002708:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
8000270c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002710:	0f a9       	ld.ub	r9,r7[0x2]
80002712:	30 08       	mov	r8,0
80002714:	f0 09 18 00 	cp.b	r9,r8
80002718:	c0 71       	brne	80002726 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000271a:	48 dc       	lddpc	r12,8000274c <mic_brdcst_func+0x44>
8000271c:	f0 1f 00 0d 	mcall	80002750 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002720:	30 09       	mov	r9,0
80002722:	48 d8       	lddpc	r8,80002754 <mic_brdcst_func+0x4c>
80002724:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002726:	0f a9       	ld.ub	r9,r7[0x2]
80002728:	31 18       	mov	r8,17
8000272a:	f0 09 18 00 	cp.b	r9,r8
8000272e:	c0 d1       	brne	80002748 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
80002730:	48 ac       	lddpc	r12,80002758 <mic_brdcst_func+0x50>
80002732:	f0 1f 00 08 	mcall	80002750 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
80002736:	48 89       	lddpc	r9,80002754 <mic_brdcst_func+0x4c>
80002738:	30 18       	mov	r8,1
8000273a:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
8000273c:	13 89       	ld.ub	r9,r9[0x0]
8000273e:	f0 09 18 00 	cp.b	r9,r8
80002742:	c0 31       	brne	80002748 <mic_brdcst_func+0x40>
80002744:	48 68       	lddpc	r8,8000275c <mic_brdcst_func+0x54>
80002746:	11 88       	ld.ub	r8,r8[0x0]
80002748:	e3 cd 80 80 	ldm	sp++,r7,pc
8000274c:	80 00       	ld.sh	r0,r0[0x0]
8000274e:	cf 7c       	rcall	8000293c <DeviceInitializationStatus_brdcst_func+0x24>
80002750:	80 00       	ld.sh	r0,r0[0x0]
80002752:	69 e0       	ld.w	r0,r4[0x78]
80002754:	00 00       	add	r0,r0
80002756:	0a 5a       	eor	r10,r5
80002758:	80 00       	ld.sh	r0,r0[0x0]
8000275a:	cf 90       	breq	8000274c <mic_brdcst_func+0x44>
8000275c:	00 00       	add	r0,r0
8000275e:	0a 52       	eor	r2,r5

80002760 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002760:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002764:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002768:	49 ac       	lddpc	r12,800027d0 <mic_reply_func+0x70>
8000276a:	f0 1f 00 1b 	mcall	800027d4 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
8000276e:	0f 89       	ld.ub	r9,r7[0x0]
80002770:	30 08       	mov	r8,0
80002772:	f0 09 18 00 	cp.b	r9,r8
80002776:	c2 71       	brne	800027c4 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
80002778:	0f 98       	ld.ub	r8,r7[0x1]
8000277a:	30 29       	mov	r9,2
8000277c:	f2 08 18 00 	cp.b	r8,r9
80002780:	c1 b1       	brne	800027b6 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
80002782:	49 6c       	lddpc	r12,800027d8 <mic_reply_func+0x78>
80002784:	f0 1f 00 14 	mcall	800027d4 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002788:	0f a8       	ld.ub	r8,r7[0x2]
8000278a:	1a d8       	st.w	--sp,r8
8000278c:	49 4c       	lddpc	r12,800027dc <mic_reply_func+0x7c>
8000278e:	f0 1f 00 12 	mcall	800027d4 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002792:	0f b8       	ld.ub	r8,r7[0x3]
80002794:	1a d8       	st.w	--sp,r8
80002796:	49 3c       	lddpc	r12,800027e0 <mic_reply_func+0x80>
80002798:	f0 1f 00 0f 	mcall	800027d4 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000279c:	0f c8       	ld.ub	r8,r7[0x4]
8000279e:	1a d8       	st.w	--sp,r8
800027a0:	49 1c       	lddpc	r12,800027e4 <mic_reply_func+0x84>
800027a2:	f0 1f 00 0d 	mcall	800027d4 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
800027a6:	0f d8       	ld.ub	r8,r7[0x5]
800027a8:	1a d8       	st.w	--sp,r8
800027aa:	49 0c       	lddpc	r12,800027e8 <mic_reply_func+0x88>
800027ac:	f0 1f 00 0a 	mcall	800027d4 <mic_reply_func+0x74>
800027b0:	2f cd       	sub	sp,-16
800027b2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800027b6:	1a d8       	st.w	--sp,r8
800027b8:	48 dc       	lddpc	r12,800027ec <mic_reply_func+0x8c>
800027ba:	f0 1f 00 07 	mcall	800027d4 <mic_reply_func+0x74>
800027be:	2f fd       	sub	sp,-4
800027c0:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800027c4:	48 bc       	lddpc	r12,800027f0 <mic_reply_func+0x90>
800027c6:	f0 1f 00 04 	mcall	800027d4 <mic_reply_func+0x74>
800027ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800027ce:	00 00       	add	r0,r0
800027d0:	80 00       	ld.sh	r0,r0[0x0]
800027d2:	cf a4       	brge	800027c6 <mic_reply_func+0x66>
800027d4:	80 00       	ld.sh	r0,r0[0x0]
800027d6:	69 e0       	ld.w	r0,r4[0x78]
800027d8:	80 00       	ld.sh	r0,r0[0x0]
800027da:	cf b4       	brge	800027d0 <mic_reply_func+0x70>
800027dc:	80 00       	ld.sh	r0,r0[0x0]
800027de:	cf c8       	rjmp	800029d6 <payload_rx_process+0x32>
800027e0:	80 00       	ld.sh	r0,r0[0x0]
800027e2:	cf dc       	rcall	800029dc <payload_rx_process+0x38>
800027e4:	80 00       	ld.sh	r0,r0[0x0]
800027e6:	cf f8       	rjmp	800029e4 <payload_rx_process+0x40>
800027e8:	80 00       	ld.sh	r0,r0[0x0]
800027ea:	d0 10       	acall	0x1
800027ec:	80 00       	ld.sh	r0,r0[0x0]
800027ee:	d0 28       	*unknown*
800027f0:	80 00       	ld.sh	r0,r0[0x0]
800027f2:	d0 40       	acall	0x4

800027f4 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800027f4:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800027f8:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
800027fc:	48 bc       	lddpc	r12,80002828 <dcm_brdcst_func+0x34>
800027fe:	f0 1f 00 0c 	mcall	8000282c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002802:	0f 88       	ld.ub	r8,r7[0x0]
80002804:	1a d8       	st.w	--sp,r8
80002806:	48 bc       	lddpc	r12,80002830 <dcm_brdcst_func+0x3c>
80002808:	f0 1f 00 09 	mcall	8000282c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000280c:	0f a8       	ld.ub	r8,r7[0x2]
8000280e:	1a d8       	st.w	--sp,r8
80002810:	48 9c       	lddpc	r12,80002834 <dcm_brdcst_func+0x40>
80002812:	f0 1f 00 07 	mcall	8000282c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002816:	0f 98       	ld.ub	r8,r7[0x1]
80002818:	1a d8       	st.w	--sp,r8
8000281a:	48 8c       	lddpc	r12,80002838 <dcm_brdcst_func+0x44>
8000281c:	f0 1f 00 04 	mcall	8000282c <dcm_brdcst_func+0x38>
80002820:	2f dd       	sub	sp,-12
	
	
}
80002822:	e3 cd 80 80 	ldm	sp++,r7,pc
80002826:	00 00       	add	r0,r0
80002828:	80 00       	ld.sh	r0,r0[0x0]
8000282a:	d0 50       	acall	0x5
8000282c:	80 00       	ld.sh	r0,r0[0x0]
8000282e:	69 e0       	ld.w	r0,r4[0x78]
80002830:	80 00       	ld.sh	r0,r0[0x0]
80002832:	d0 64       	*unknown*
80002834:	80 00       	ld.sh	r0,r0[0x0]
80002836:	d0 78       	*unknown*
80002838:	80 00       	ld.sh	r0,r0[0x0]
8000283a:	d0 90       	acall	0x9

8000283c <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
8000283c:	eb cd 40 80 	pushm	r7,lr
80002840:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002842:	19 a9       	ld.ub	r9,r12[0x2]
80002844:	30 08       	mov	r8,0
80002846:	f0 09 18 00 	cp.b	r9,r8
8000284a:	c1 b1       	brne	80002880 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
8000284c:	19 b8       	ld.ub	r8,r12[0x3]
8000284e:	30 19       	mov	r9,1
80002850:	f2 08 18 00 	cp.b	r8,r9
80002854:	c0 51       	brne	8000285e <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
80002856:	48 ec       	lddpc	r12,8000288c <dcm_reply_func+0x50>
80002858:	f0 1f 00 0e 	mcall	80002890 <dcm_reply_func+0x54>
8000285c:	c0 a8       	rjmp	80002870 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
8000285e:	58 08       	cp.w	r8,0
80002860:	c0 51       	brne	8000286a <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
80002862:	48 dc       	lddpc	r12,80002894 <dcm_reply_func+0x58>
80002864:	f0 1f 00 0b 	mcall	80002890 <dcm_reply_func+0x54>
80002868:	c0 48       	rjmp	80002870 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
8000286a:	48 cc       	lddpc	r12,80002898 <dcm_reply_func+0x5c>
8000286c:	f0 1f 00 09 	mcall	80002890 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
80002870:	0f d8       	ld.ub	r8,r7[0x5]
80002872:	1a d8       	st.w	--sp,r8
80002874:	48 ac       	lddpc	r12,8000289c <dcm_reply_func+0x60>
80002876:	f0 1f 00 07 	mcall	80002890 <dcm_reply_func+0x54>
8000287a:	2f fd       	sub	sp,-4
8000287c:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002880:	48 8c       	lddpc	r12,800028a0 <dcm_reply_func+0x64>
80002882:	f0 1f 00 04 	mcall	80002890 <dcm_reply_func+0x54>
80002886:	e3 cd 80 80 	ldm	sp++,r7,pc
8000288a:	00 00       	add	r0,r0
8000288c:	80 00       	ld.sh	r0,r0[0x0]
8000288e:	d0 ac       	*unknown*
80002890:	80 00       	ld.sh	r0,r0[0x0]
80002892:	69 e0       	ld.w	r0,r4[0x78]
80002894:	80 00       	ld.sh	r0,r0[0x0]
80002896:	d0 c0       	acall	0xc
80002898:	80 00       	ld.sh	r0,r0[0x0]
8000289a:	d0 d4       	*unknown*
8000289c:	80 00       	ld.sh	r0,r0[0x0]
8000289e:	d0 e8       	*unknown*
800028a0:	80 00       	ld.sh	r0,r0[0x0]
800028a2:	d0 f4       	*unknown*

800028a4 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800028a4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800028a6:	19 a9       	ld.ub	r9,r12[0x2]
800028a8:	30 08       	mov	r8,0
800028aa:	f0 09 18 00 	cp.b	r9,r8
800028ae:	c0 51       	brne	800028b8 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
800028b0:	48 4c       	lddpc	r12,800028c0 <ToneControl_reply_func+0x1c>
800028b2:	f0 1f 00 05 	mcall	800028c4 <ToneControl_reply_func+0x20>
800028b6:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800028b8:	48 4c       	lddpc	r12,800028c8 <ToneControl_reply_func+0x24>
800028ba:	f0 1f 00 03 	mcall	800028c4 <ToneControl_reply_func+0x20>
800028be:	d8 02       	popm	pc
800028c0:	80 00       	ld.sh	r0,r0[0x0]
800028c2:	d1 00       	acall	0x10
800028c4:	80 00       	ld.sh	r0,r0[0x0]
800028c6:	69 e0       	ld.w	r0,r4[0x78]
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	d1 0c       	*unknown*

800028cc <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
800028cc:	eb cd 40 80 	pushm	r7,lr
800028d0:	18 97       	mov	r7,r12
	static  U8 times_counter = 0;
	
	times_counter++;
800028d2:	48 c9       	lddpc	r9,80002900 <app_payload_rx_proc+0x34>
800028d4:	13 88       	ld.ub	r8,r9[0x0]
800028d6:	2f f8       	sub	r8,-1
800028d8:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
800028da:	30 39       	mov	r9,3
800028dc:	f2 08 18 00 	cp.b	r8,r9
800028e0:	c0 71       	brne	800028ee <app_payload_rx_proc+0x22>
	{
		times_counter = 0 ;
800028e2:	30 09       	mov	r9,0
800028e4:	48 78       	lddpc	r8,80002900 <app_payload_rx_proc+0x34>
800028e6:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800028e8:	48 7c       	lddpc	r12,80002904 <app_payload_rx_proc+0x38>
800028ea:	f0 1f 00 08 	mcall	80002908 <app_payload_rx_proc+0x3c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
800028ee:	48 88       	lddpc	r8,8000290c <app_payload_rx_proc+0x40>
800028f0:	11 88       	ld.ub	r8,r8[0x0]
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
800028f2:	48 88       	lddpc	r8,80002910 <app_payload_rx_proc+0x44>
800028f4:	70 0c       	ld.w	r12,r8[0x0]
800028f6:	0e 9b       	mov	r11,r7
800028f8:	f0 1f 00 07 	mcall	80002914 <app_payload_rx_proc+0x48>

}
800028fc:	e3 cd 80 80 	ldm	sp++,r7,pc
80002900:	00 00       	add	r0,r0
80002902:	0a 59       	eor	r9,r5
80002904:	80 00       	ld.sh	r0,r0[0x0]
80002906:	d1 18       	*unknown*
80002908:	80 00       	ld.sh	r0,r0[0x0]
8000290a:	69 e0       	ld.w	r0,r4[0x78]
8000290c:	00 00       	add	r0,r0
8000290e:	0a 5b       	eor	r11,r5
80002910:	00 00       	add	r0,r0
80002912:	0a b0       	st.h	r5++,r0
80002914:	80 00       	ld.sh	r0,r0[0x0]
80002916:	2a 44       	sub	r4,-92

80002918 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002918:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
8000291a:	19 e8       	ld.ub	r8,r12[0x6]
8000291c:	30 19       	mov	r9,1
8000291e:	f2 08 18 00 	cp.b	r8,r9
80002922:	c0 61       	brne	8000292e <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002924:	48 98       	lddpc	r8,80002948 <DeviceInitializationStatus_brdcst_func+0x30>
80002926:	70 09       	ld.w	r9,r8[0x0]
80002928:	a1 a9       	sbr	r9,0x0
8000292a:	91 09       	st.w	r8[0x0],r9
8000292c:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
8000292e:	30 29       	mov	r9,2
80002930:	f2 08 18 00 	cp.b	r8,r9
80002934:	c0 80       	breq	80002944 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002936:	48 58       	lddpc	r8,80002948 <DeviceInitializationStatus_brdcst_func+0x30>
80002938:	70 09       	ld.w	r9,r8[0x0]
8000293a:	e0 19 ff fc 	andl	r9,0xfffc
8000293e:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002940:	f0 1f 00 03 	mcall	8000294c <DeviceInitializationStatus_brdcst_func+0x34>
80002944:	d8 02       	popm	pc
80002946:	00 00       	add	r0,r0
80002948:	00 00       	add	r0,r0
8000294a:	0d 94       	ld.ub	r4,r6[0x1]
8000294c:	80 00       	ld.sh	r0,r0[0x0]
8000294e:	42 00       	lddsp	r0,sp[0x80]

80002950 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002950:	20 1c       	sub	r12,1
80002952:	5c 5c       	castu.b	r12
80002954:	31 18       	mov	r8,17
80002956:	f0 0c 18 00 	cp.b	r12,r8
8000295a:	e0 88 00 03 	brls	80002960 <CalculateBurst+0x10>
8000295e:	5e fd       	retal	0
80002960:	48 28       	lddpc	r8,80002968 <CalculateBurst+0x18>
80002962:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002966:	5e fc       	retal	r12
80002968:	80 00       	ld.sh	r0,r0[0x0]
8000296a:	d1 2c       	*unknown*

8000296c <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
8000296c:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
8000296e:	48 98       	lddpc	r8,80002990 <payload_init+0x24>
80002970:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002972:	48 98       	lddpc	r8,80002994 <payload_init+0x28>
80002974:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80002976:	30 09       	mov	r9,0
80002978:	1a d9       	st.w	--sp,r9
8000297a:	1a d9       	st.w	--sp,r9
8000297c:	1a d9       	st.w	--sp,r9
8000297e:	30 28       	mov	r8,2
80002980:	e0 6a 04 00 	mov	r10,1024
80002984:	48 5b       	lddpc	r11,80002998 <payload_init+0x2c>
80002986:	48 6c       	lddpc	r12,8000299c <payload_init+0x30>
80002988:	f0 1f 00 06 	mcall	800029a0 <payload_init+0x34>
8000298c:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
8000298e:	d8 02       	popm	pc
80002990:	00 00       	add	r0,r0
80002992:	0a 68       	and	r8,r5
80002994:	00 00       	add	r0,r0
80002996:	0a 6c       	and	r12,r5
80002998:	80 00       	ld.sh	r0,r0[0x0]
8000299a:	d1 74       	*unknown*
8000299c:	80 00       	ld.sh	r0,r0[0x0]
8000299e:	29 a4       	sub	r4,-102
800029a0:	80 00       	ld.sh	r0,r0[0x0]
800029a2:	66 1c       	ld.w	r12,r3[0x4]

800029a4 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
800029a4:	eb cd 40 f8 	pushm	r3-r7,lr
800029a8:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
800029aa:	48 e8       	lddpc	r8,800029e0 <payload_rx_process+0x3c>
800029ac:	70 08       	ld.w	r8,r8[0x0]
800029ae:	58 08       	cp.w	r8,0
800029b0:	c0 71       	brne	800029be <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
800029b2:	30 4b       	mov	r11,4
800029b4:	30 5c       	mov	r12,5
800029b6:	f0 1f 00 0c 	mcall	800029e4 <payload_rx_process+0x40>
800029ba:	48 a8       	lddpc	r8,800029e0 <payload_rx_process+0x3c>
800029bc:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
800029be:	48 96       	lddpc	r6,800029e0 <payload_rx_process+0x3c>
800029c0:	30 05       	mov	r5,0
800029c2:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
800029c4:	48 93       	lddpc	r3,800029e8 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
800029c6:	6c 0c       	ld.w	r12,r6[0x0]
800029c8:	0a 99       	mov	r9,r5
800029ca:	08 9a       	mov	r10,r4
800029cc:	1a 9b       	mov	r11,sp
800029ce:	f0 1f 00 08 	mcall	800029ec <payload_rx_process+0x48>
800029d2:	58 1c       	cp.w	r12,1
800029d4:	cf 91       	brne	800029c6 <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
800029d6:	66 08       	ld.w	r8,r3[0x0]
800029d8:	40 0c       	lddsp	r12,sp[0x0]
800029da:	5d 18       	icall	r8
800029dc:	cf 5b       	rjmp	800029c6 <payload_rx_process+0x22>
800029de:	00 00       	add	r0,r0
800029e0:	00 00       	add	r0,r0
800029e2:	0a 80       	andn	r0,r5
800029e4:	80 00       	ld.sh	r0,r0[0x0]
800029e6:	5f 48       	srge	r8
800029e8:	00 00       	add	r0,r0
800029ea:	0a 68       	and	r8,r5
800029ec:	80 00       	ld.sh	r0,r0[0x0]
800029ee:	5c 3c       	neg	r12

800029f0 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
800029f0:	d4 01       	pushm	lr
800029f2:	20 2d       	sub	sp,8
800029f4:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800029f6:	30 09       	mov	r9,0
800029f8:	fa ca ff f8 	sub	r10,sp,-8
800029fc:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
800029fe:	1a 9b       	mov	r11,sp
80002a00:	f0 1f 00 02 	mcall	80002a08 <set_idle_store_isr+0x18>
}
80002a04:	2f ed       	sub	sp,-8
80002a06:	d8 02       	popm	pc
80002a08:	80 00       	ld.sh	r0,r0[0x0]
80002a0a:	5d f8       	*unknown*

80002a0c <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002a0c:	d4 01       	pushm	lr
80002a0e:	20 2d       	sub	sp,8
80002a10:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002a12:	58 0c       	cp.w	r12,0
80002a14:	c1 10       	breq	80002a36 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a16:	30 08       	mov	r8,0
80002a18:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002a1a:	98 88       	ld.uh	r8,r12[0x0]
80002a1c:	e2 18 f0 00 	andl	r8,0xf000,COH
80002a20:	e0 48 40 00 	cp.w	r8,16384
80002a24:	c0 91       	brne	80002a36 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002a26:	48 68       	lddpc	r8,80002a3c <phy_rx+0x30>
80002a28:	70 0c       	ld.w	r12,r8[0x0]
80002a2a:	30 09       	mov	r9,0
80002a2c:	fa ca ff fc 	sub	r10,sp,-4
80002a30:	1a 9b       	mov	r11,sp
80002a32:	f0 1f 00 04 	mcall	80002a40 <phy_rx+0x34>
		}	

    }
		
 
}
80002a36:	2f ed       	sub	sp,-8
80002a38:	d8 02       	popm	pc
80002a3a:	00 00       	add	r0,r0
80002a3c:	00 00       	add	r0,r0
80002a3e:	0a c4       	st.b	r5++,r4
80002a40:	80 00       	ld.sh	r0,r0[0x0]
80002a42:	5d f8       	*unknown*

80002a44 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002a44:	eb cd 40 80 	pushm	r7,lr
80002a48:	20 1d       	sub	sp,4
80002a4a:	fa c7 ff fc 	sub	r7,sp,-4
80002a4e:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002a50:	30 09       	mov	r9,0
80002a52:	12 9a       	mov	r10,r9
80002a54:	1a 9b       	mov	r11,sp
80002a56:	f0 1f 00 03 	mcall	80002a60 <set_idle_store+0x1c>
}
80002a5a:	2f fd       	sub	sp,-4
80002a5c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a60:	80 00       	ld.sh	r0,r0[0x0]
80002a62:	5e 48       	retge	r8

80002a64 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002a64:	d4 01       	pushm	lr
80002a66:	20 1d       	sub	sp,4
80002a68:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002a6a:	98 88       	ld.uh	r8,r12[0x0]
80002a6c:	e2 18 f0 00 	andl	r8,0xf000,COH
80002a70:	e0 48 40 00 	cp.w	r8,16384
80002a74:	c0 d1       	brne	80002a8e <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002a76:	49 08       	lddpc	r8,80002ab4 <phy_tx+0x50>
80002a78:	70 08       	ld.w	r8,r8[0x0]
80002a7a:	58 08       	cp.w	r8,0
80002a7c:	c1 a0       	breq	80002ab0 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002a7e:	48 e8       	lddpc	r8,80002ab4 <phy_tx+0x50>
80002a80:	70 0c       	ld.w	r12,r8[0x0]
80002a82:	30 09       	mov	r9,0
80002a84:	12 9a       	mov	r10,r9
80002a86:	1a 9b       	mov	r11,sp
80002a88:	f0 1f 00 0c 	mcall	80002ab8 <phy_tx+0x54>
80002a8c:	c1 28       	rjmp	80002ab0 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002a8e:	e0 48 10 00 	cp.w	r8,4096
80002a92:	5f 0a       	sreq	r10
80002a94:	e0 48 20 00 	cp.w	r8,8192
80002a98:	5f 09       	sreq	r9
80002a9a:	f5 e9 10 09 	or	r9,r10,r9
80002a9e:	c0 71       	brne	80002aac <phy_tx+0x48>
80002aa0:	e0 48 50 00 	cp.w	r8,20480
80002aa4:	c0 40       	breq	80002aac <phy_tx+0x48>
80002aa6:	e0 48 60 00 	cp.w	r8,24576
80002aaa:	c0 31       	brne	80002ab0 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002aac:	48 48       	lddpc	r8,80002abc <phy_tx+0x58>
80002aae:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002ab0:	2f fd       	sub	sp,-4
80002ab2:	d8 02       	popm	pc
80002ab4:	00 00       	add	r0,r0
80002ab6:	0a d8       	st.w	--r5,r8
80002ab8:	80 00       	ld.sh	r0,r0[0x0]
80002aba:	5e 48       	retge	r8
80002abc:	00 00       	add	r0,r0
80002abe:	0a b8       	st.h	r5++,r8

80002ac0 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002ac0:	d4 01       	pushm	lr
80002ac2:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002ac4:	30 08       	mov	r8,0
80002ac6:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002ac8:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002aca:	1a 9a       	mov	r10,sp
80002acc:	fa cb ff fc 	sub	r11,sp,-4
80002ad0:	f0 1f 00 05 	mcall	80002ae4 <get_idle_store_isr+0x24>
80002ad4:	58 1c       	cp.w	r12,1
80002ad6:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002ada:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002ade:	2f ed       	sub	sp,-8
80002ae0:	d8 02       	popm	pc
80002ae2:	00 00       	add	r0,r0
80002ae4:	80 00       	ld.sh	r0,r0[0x0]
80002ae6:	5b 4c       	cp.w	r12,-12

80002ae8 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002ae8:	eb cd 40 c0 	pushm	r6-r7,lr
80002aec:	20 1d       	sub	sp,4
80002aee:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002af0:	fe f8 04 70 	ld.w	r8,pc[1136]
80002af4:	70 08       	ld.w	r8,r8[0x0]
80002af6:	58 08       	cp.w	r8,0
80002af8:	c7 40       	breq	80002be0 <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002afa:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002afc:	30 08       	mov	r8,0
80002afe:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002b00:	fe f8 04 64 	ld.w	r8,pc[1124]
80002b04:	70 08       	ld.w	r8,r8[0x0]
80002b06:	58 18       	cp.w	r8,1
80002b08:	c2 90       	breq	80002b5a <phy_tx_func+0x72>
80002b0a:	c0 43       	brcs	80002b12 <phy_tx_func+0x2a>
80002b0c:	58 28       	cp.w	r8,2
80002b0e:	c6 91       	brne	80002be0 <phy_tx_func+0xf8>
80002b10:	c6 18       	rjmp	80002bd2 <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002b12:	fe f8 04 4e 	ld.w	r8,pc[1102]
80002b16:	70 0c       	ld.w	r12,r8[0x0]
80002b18:	1a 9a       	mov	r10,sp
80002b1a:	fe fb 04 4e 	ld.w	r11,pc[1102]
80002b1e:	f0 1f 01 14 	mcall	80002f6c <phy_tx_func+0x484>
80002b22:	58 1c       	cp.w	r12,1
80002b24:	c1 51       	brne	80002b4e <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002b26:	fe f8 04 42 	ld.w	r8,pc[1090]
80002b2a:	70 08       	ld.w	r8,r8[0x0]
80002b2c:	11 9a       	ld.ub	r10,r8[0x1]
80002b2e:	fe f9 04 42 	ld.w	r9,pc[1090]
80002b32:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002b34:	90 88       	ld.uh	r8,r8[0x0]
80002b36:	ea 18 ab cd 	orh	r8,0xabcd
80002b3a:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002b3c:	30 19       	mov	r9,1
80002b3e:	fe f8 04 36 	ld.w	r8,pc[1078]
80002b42:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002b44:	30 19       	mov	r9,1
80002b46:	fe f8 04 1e 	ld.w	r8,pc[1054]
80002b4a:	91 09       	st.w	r8[0x0],r9
80002b4c:	c4 a8       	rjmp	80002be0 <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002b4e:	e0 68 5a 5a 	mov	r8,23130
80002b52:	ea 18 ab cd 	orh	r8,0xabcd
80002b56:	8f 18       	st.w	r7[0x4],r8
80002b58:	c4 48       	rjmp	80002be0 <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002b5a:	fe f9 04 1a 	ld.w	r9,pc[1050]
80002b5e:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002b60:	fe fa 04 08 	ld.w	r10,pc[1032]
80002b64:	74 0a       	ld.w	r10,r10[0x0]
80002b66:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002b6a:	b1 6a       	lsl	r10,0x10
80002b6c:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002b6e:	2f f8       	sub	r8,-1
80002b70:	5c 58       	castu.b	r8
80002b72:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b74:	fe fa 03 fc 	ld.w	r10,pc[1020]
80002b78:	94 09       	ld.sh	r9,r10[0x0]
80002b7a:	20 29       	sub	r9,2
80002b7c:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b7e:	30 0a       	mov	r10,0
80002b80:	f4 09 19 00 	cp.h	r9,r10
80002b84:	e0 89 00 0b 	brgt	80002b9a <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002b88:	78 18       	ld.w	r8,r12[0x4]
80002b8a:	e8 18 00 ba 	orl	r8,0xba
80002b8e:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002b90:	30 09       	mov	r9,0
80002b92:	fe f8 03 d2 	ld.w	r8,pc[978]
80002b96:	91 09       	st.w	r8[0x0],r9
80002b98:	c2 48       	rjmp	80002be0 <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002b9a:	fe f9 03 ce 	ld.w	r9,pc[974]
80002b9e:	72 09       	ld.w	r9,r9[0x0]
80002ba0:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002ba4:	78 1a       	ld.w	r10,r12[0x4]
80002ba6:	f5 e9 10 09 	or	r9,r10,r9
80002baa:	99 19       	st.w	r12[0x4],r9
80002bac:	2f f8       	sub	r8,-1
80002bae:	fe f9 03 c6 	ld.w	r9,pc[966]
80002bb2:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002bb4:	fe f9 03 bc 	ld.w	r9,pc[956]
80002bb8:	92 08       	ld.sh	r8,r9[0x0]
80002bba:	20 28       	sub	r8,2
80002bbc:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002bbe:	30 09       	mov	r9,0
80002bc0:	f2 08 19 00 	cp.h	r8,r9
80002bc4:	e0 89 00 0e 	brgt	80002be0 <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002bc8:	30 29       	mov	r9,2
80002bca:	fe f8 03 9a 	ld.w	r8,pc[922]
80002bce:	91 09       	st.w	r8[0x0],r9
80002bd0:	c0 88       	rjmp	80002be0 <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002bd2:	fc 18 00 ba 	movh	r8,0xba
80002bd6:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002bd8:	30 09       	mov	r9,0
80002bda:	fe f8 03 8a 	ld.w	r8,pc[906]
80002bde:	91 09       	st.w	r8[0x0],r9
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_Media == TRUE))
80002be0:	fe f8 03 98 	ld.w	r8,pc[920]
80002be4:	11 89       	ld.ub	r9,r8[0x0]
80002be6:	30 18       	mov	r8,1
80002be8:	f0 09 18 00 	cp.b	r9,r8
80002bec:	e0 81 01 af 	brne	80002f4a <phy_tx_func+0x462>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80002bf0:	fe f8 03 8c 	ld.w	r8,pc[908]
80002bf4:	70 08       	ld.w	r8,r8[0x0]
80002bf6:	e0 48 05 b0 	cp.w	r8,1456
80002bfa:	f9 b8 02 00 	movhs	r8,0
80002bfe:	fe f9 03 7e 	ld.w	r9,pc[894]
80002c02:	93 08       	st.w	r9[0x0],r8
	  //AMBE_flag
		switch(AMBEpayload_tx_state)
80002c04:	fe f8 03 7c 	ld.w	r8,pc[892]
80002c08:	70 08       	ld.w	r8,r8[0x0]
80002c0a:	58 68       	cp.w	r8,6
80002c0c:	e0 8b 01 95 	brhi	80002f36 <phy_tx_func+0x44e>
80002c10:	fe f9 03 74 	ld.w	r9,pc[884]
80002c14:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80002c18:	fe f8 03 70 	ld.w	r8,pc[880]
80002c1c:	70 08       	ld.w	r8,r8[0x0]
80002c1e:	58 08       	cp.w	r8,0
80002c20:	c0 b0       	breq	80002c36 <phy_tx_func+0x14e>
80002c22:	fe f8 03 66 	ld.w	r8,pc[870]
80002c26:	70 08       	ld.w	r8,r8[0x0]
80002c28:	58 a8       	cp.w	r8,10
80002c2a:	c0 60       	breq	80002c36 <phy_tx_func+0x14e>
80002c2c:	fe f8 03 5c 	ld.w	r8,pc[860]
80002c30:	70 08       	ld.w	r8,r8[0x0]
80002c32:	58 18       	cp.w	r8,1
80002c34:	c0 a1       	brne	80002c48 <phy_tx_func+0x160>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002c36:	e0 68 5a 5a 	mov	r8,23130
80002c3a:	ea 18 ab cd 	orh	r8,0xabcd
80002c3e:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002c40:	30 08       	mov	r8,0
80002c42:	8f 38       	st.w	r7[0xc],r8
80002c44:	e0 8f 01 8a 	bral	80002f58 <phy_tx_func+0x470>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80002c48:	fe f8 03 40 	ld.w	r8,pc[832]
80002c4c:	70 08       	ld.w	r8,r8[0x0]
80002c4e:	58 38       	cp.w	r8,3
80002c50:	c0 91       	brne	80002c62 <phy_tx_func+0x17a>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80002c52:	fe f8 03 3a 	ld.w	r8,pc[826]
80002c56:	70 09       	ld.w	r9,r8[0x0]
80002c58:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80002c5a:	70 18       	ld.w	r8,r8[0x4]
80002c5c:	8f 38       	st.w	r7[0xc],r8
80002c5e:	e0 8f 01 7d 	bral	80002f58 <phy_tx_func+0x470>
				else//加密和解密的激励类型
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + soft decision value + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 4 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//解密数据
80002c62:	fe f8 03 26 	ld.w	r8,pc[806]
80002c66:	70 08       	ld.w	r8,r8[0x0]
80002c68:	58 28       	cp.w	r8,2
80002c6a:	c1 31       	brne	80002c90 <phy_tx_func+0x1a8>
					{
						//0xABCDCO32
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//50bytes
80002c6c:	e0 68 c0 32 	mov	r8,49202
80002c70:	ea 18 ab cd 	orh	r8,0xabcd
80002c74:	8f 28       	st.w	r7[0x8],r8
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
80002c76:	fe 78 84 7f 	mov	r8,-31617
80002c7a:	ae 68       	st.h	r7[0xc],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
80002c7c:	fe f8 03 14 	ld.w	r8,pc[788]
80002c80:	90 08       	ld.sh	r8,r8[0x0]
80002c82:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
80002c84:	30 39       	mov	r9,3
80002c86:	fe f8 02 fa 	ld.w	r8,pc[762]
80002c8a:	91 09       	st.w	r8[0x0],r9
80002c8c:	e0 8f 01 66 	bral	80002f58 <phy_tx_func+0x470>
					//assemble 2 items into 1 Command. Send it to Radio.
					else//加密数据
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80002c90:	e0 68 c0 0e 	mov	r8,49166
80002c94:	ea 18 ab cd 	orh	r8,0xabcd
80002c98:	8f 28       	st.w	r7[0x8],r8
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
80002c9a:	fe f8 02 fa 	ld.w	r8,pc[762]
80002c9e:	90 09       	ld.sh	r9,r8[0x0]
80002ca0:	ae 69       	st.h	r7[0xc],r9
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
80002ca2:	90 18       	ld.sh	r8,r8[0x2]
80002ca4:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
80002ca6:	30 19       	mov	r9,1
80002ca8:	fe f8 02 d8 	ld.w	r8,pc[728]
80002cac:	91 09       	st.w	r8[0x0],r9
80002cae:	e0 8f 01 55 	bral	80002f58 <phy_tx_func+0x470>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80002cb2:	fe 78 88 f2 	mov	r8,-30478
80002cb6:	ae 48       	st.h	r7[0x8],r8
				//A_index+=2;
				//
				//AMBEpayload_tx_state = AMBE_EN_LAST;
				
			
				switch (m_RxBurstType)//在发送函数中去做加密处理
80002cb8:	fe f8 02 d0 	ld.w	r8,pc[720]
80002cbc:	70 08       	ld.w	r8,r8[0x0]
80002cbe:	58 48       	cp.w	r8,4
80002cc0:	c0 60       	breq	80002ccc <phy_tx_func+0x1e4>
80002cc2:	c4 53       	brcs	80002d4c <phy_tx_func+0x264>
80002cc4:	58 98       	cp.w	r8,9
80002cc6:	e0 8b 00 43 	brhi	80002d4c <phy_tx_func+0x264>
80002cca:	c2 98       	rjmp	80002d1c <phy_tx_func+0x234>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80002ccc:	fe f8 02 cc 	ld.w	r8,pc[716]
80002cd0:	11 89       	ld.ub	r9,r8[0x0]
80002cd2:	30 18       	mov	r8,1
80002cd4:	f0 09 18 00 	cp.b	r9,r8
80002cd8:	c0 a1       	brne	80002cec <phy_tx_func+0x204>
							{	
								
								
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
80002cda:	fe f8 02 c2 	ld.w	r8,pc[706]
80002cde:	90 09       	ld.sh	r9,r8[0x0]
80002ce0:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = Public_AMBEkey[1];
80002ce2:	90 19       	ld.sh	r9,r8[0x2]
80002ce4:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = Public_AMBEkey[2];
80002ce6:	90 28       	ld.sh	r8,r8[0x4]
80002ce8:	ae 78       	st.h	r7[0xe],r8
80002cea:	c1 48       	rjmp	80002d12 <phy_tx_func+0x22a>
							{
								
								
						
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002cec:	fe f9 02 b4 	ld.w	r9,pc[692]
80002cf0:	92 0b       	ld.sh	r11,r9[0x0]
80002cf2:	fe f8 02 aa 	ld.w	r8,pc[682]
80002cf6:	90 0a       	ld.sh	r10,r8[0x0]
80002cf8:	f7 ea 20 0a 	eor	r10,r11,r10
80002cfc:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002cfe:	92 1b       	ld.sh	r11,r9[0x2]
80002d00:	90 1a       	ld.sh	r10,r8[0x2]
80002d02:	f7 ea 20 0a 	eor	r10,r11,r10
80002d06:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002d08:	92 29       	ld.sh	r9,r9[0x4]
80002d0a:	90 28       	ld.sh	r8,r8[0x4]
80002d0c:	f3 e8 20 08 	eor	r8,r9,r8
80002d10:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_EN_LAST;
80002d12:	30 29       	mov	r9,2
80002d14:	fe f8 02 6c 	ld.w	r8,pc[620]
80002d18:	91 09       	st.w	r8[0x0],r9
80002d1a:	c1 f9       	rjmp	80002f58 <phy_tx_func+0x470>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002d1c:	fe f9 02 84 	ld.w	r9,pc[644]
80002d20:	92 0b       	ld.sh	r11,r9[0x0]
80002d22:	fe f8 02 7a 	ld.w	r8,pc[634]
80002d26:	90 0a       	ld.sh	r10,r8[0x0]
80002d28:	f7 ea 20 0a 	eor	r10,r11,r10
80002d2c:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002d2e:	92 1b       	ld.sh	r11,r9[0x2]
80002d30:	90 1a       	ld.sh	r10,r8[0x2]
80002d32:	f7 ea 20 0a 	eor	r10,r11,r10
80002d36:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002d38:	92 29       	ld.sh	r9,r9[0x4]
80002d3a:	90 28       	ld.sh	r8,r8[0x4]
80002d3c:	f3 e8 20 08 	eor	r8,r9,r8
80002d40:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_EN_LAST;
80002d42:	30 29       	mov	r9,2
80002d44:	fe f8 02 3c 	ld.w	r8,pc[572]
80002d48:	91 09       	st.w	r8[0x0],r9
80002d4a:	c0 79       	rjmp	80002f58 <phy_tx_func+0x470>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002d4c:	e0 68 5a 5a 	mov	r8,23130
80002d50:	ea 18 ab cd 	orh	r8,0xabcd
80002d54:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002d56:	30 08       	mov	r8,0
80002d58:	8f 38       	st.w	r7[0xc],r8
							
							AMBEpayload_tx_state = AMBE_IDLE;
80002d5a:	fe f9 02 26 	ld.w	r9,pc[550]
80002d5e:	93 08       	st.w	r9[0x0],r8
80002d60:	cf c8       	rjmp	80002f58 <phy_tx_func+0x470>
						  1:VF1 of first Burst A after last Voice Header (49 bits).
						  2:Last 4 bits (bit 45 to bit 48) of every 49 bits AMBE Voice Frame. (72 bits@Super Frame).
					
					*/
					
					payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
80002d62:	fe f8 02 3e 	ld.w	r8,pc[574]
80002d66:	90 38       	ld.sh	r8,r8[0x6]
80002d68:	ae 48       	st.h	r7[0x8],r8
					
					
					//payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//需要补充Pad_bits位
					//A_index+=1;
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80002d6a:	e0 68 00 ba 	mov	r8,186
80002d6e:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80002d70:	30 08       	mov	r8,0
80002d72:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80002d74:	ae 78       	st.h	r7[0xe],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
80002d76:	30 09       	mov	r9,0
80002d78:	fe f8 02 08 	ld.w	r8,pc[520]
80002d7c:	91 09       	st.w	r8[0x0],r9
80002d7e:	ce d8       	rjmp	80002f58 <phy_tx_func+0x470>
				break;
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
80002d80:	fe f8 02 10 	ld.w	r8,pc[528]
80002d84:	90 18       	ld.sh	r8,r8[0x2]
80002d86:	ae 48       	st.h	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80002d88:	fe f8 02 0c 	ld.w	r8,pc[524]
80002d8c:	90 08       	ld.sh	r8,r8[0x0]
80002d8e:	ae 58       	st.h	r7[0xa],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
80002d90:	4f e8       	lddpc	r8,80002f88 <phy_tx_func+0x4a0>
80002d92:	70 08       	ld.w	r8,r8[0x0]
80002d94:	58 48       	cp.w	r8,4
80002d96:	c0 d1       	brne	80002db0 <phy_tx_func+0x2c8>
80002d98:	fe f8 02 00 	ld.w	r8,pc[512]
80002d9c:	11 89       	ld.ub	r9,r8[0x0]
80002d9e:	30 18       	mov	r8,1
80002da0:	f0 09 18 00 	cp.b	r9,r8
80002da4:	c0 61       	brne	80002db0 <phy_tx_func+0x2c8>
					{
						// Vocoder Bits Stream Parameter("E(bit8)" flag = 1)
						//0xF0(8+)x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0100));
80002da6:	4f c8       	lddpc	r8,80002f94 <phy_tx_func+0x4ac>
80002da8:	90 18       	ld.sh	r8,r8[0x2]
80002daa:	a9 a8       	sbr	r8,0x8
80002dac:	ae 68       	st.h	r7[0xc],r8
80002dae:	c0 48       	rjmp	80002db6 <phy_tx_func+0x2ce>
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
80002db0:	4f 98       	lddpc	r8,80002f94 <phy_tx_func+0x4ac>
80002db2:	90 18       	ld.sh	r8,r8[0x2]
80002db4:	ae 68       	st.h	r7[0xc],r8
					
					//0x9A13
					payload_tx_channel->word[3] = SDV_PAYLOAD;
80002db6:	fe 78 9a 13 	mov	r8,-26093
80002dba:	ae 78       	st.h	r7[0xe],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
80002dbc:	30 49       	mov	r9,4
80002dbe:	4f 18       	lddpc	r8,80002f80 <phy_tx_func+0x498>
80002dc0:	91 09       	st.w	r8[0x0],r9
80002dc2:	cc b8       	rjmp	80002f58 <phy_tx_func+0x470>
				break;
			
			case AMBE_DE_SECOND:
					//Post back soft decision value data

						payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80002dc4:	4f 88       	lddpc	r8,80002fa4 <phy_tx_func+0x4bc>
80002dc6:	70 0a       	ld.w	r10,r8[0x0]
80002dc8:	4f 89       	lddpc	r9,80002fa8 <phy_tx_func+0x4c0>
80002dca:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002dce:	ae 4a       	st.h	r7[0x8],r10
						payload_tx_channel->word[1] = Soft_Decision_Data[Soft_index+1] ;
80002dd0:	70 0a       	ld.w	r10,r8[0x0]
80002dd2:	2f fa       	sub	r10,-1
80002dd4:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002dd8:	ae 5a       	st.h	r7[0xa],r10
						payload_tx_channel->word[2] = Soft_Decision_Data[Soft_index+2] ;
80002dda:	70 0a       	ld.w	r10,r8[0x0]
80002ddc:	2f ea       	sub	r10,-2
80002dde:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002de2:	ae 6a       	st.h	r7[0xc],r10
						payload_tx_channel->word[3] = Soft_Decision_Data[Soft_index+3] ;
80002de4:	70 0a       	ld.w	r10,r8[0x0]
80002de6:	2f da       	sub	r10,-3
80002de8:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80002dec:	ae 79       	st.h	r7[0xe],r9
						Soft_index +=4;
80002dee:	70 09       	ld.w	r9,r8[0x0]
80002df0:	2f c9       	sub	r9,-4
80002df2:	91 09       	st.w	r8[0x0],r9
						
						if (Soft_index == 12)
80002df4:	58 c9       	cp.w	r9,12
80002df6:	c0 51       	brne	80002e00 <phy_tx_func+0x318>
						{
							AMBEpayload_tx_state = AMBE_DE_THIRD;
80002df8:	30 59       	mov	r9,5
80002dfa:	4e 28       	lddpc	r8,80002f80 <phy_tx_func+0x498>
80002dfc:	91 09       	st.w	r8[0x0],r9
80002dfe:	ca d8       	rjmp	80002f58 <phy_tx_func+0x470>
							//Soft_index = 0 ;
							
						}
						else
						AMBEpayload_tx_state = AMBE_DE_SECOND;
80002e00:	30 49       	mov	r9,4
80002e02:	4e 08       	lddpc	r8,80002f80 <phy_tx_func+0x498>
80002e04:	91 09       	st.w	r8[0x0],r9
80002e06:	ca 98       	rjmp	80002f58 <phy_tx_func+0x470>
				break;	
				
			case AMBE_DE_THIRD:
					
					//0x xxxx
					payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80002e08:	4e 78       	lddpc	r8,80002fa4 <phy_tx_func+0x4bc>
80002e0a:	70 0a       	ld.w	r10,r8[0x0]
80002e0c:	4e 79       	lddpc	r9,80002fa8 <phy_tx_func+0x4c0>
80002e0e:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80002e12:	ae 49       	st.h	r7[0x8],r9
					Soft_index = 0 ;//索引清零
80002e14:	30 09       	mov	r9,0
80002e16:	91 09       	st.w	r8[0x0],r9
					
					//0x8003 隔离符号？
					payload_tx_channel->word[1] = 0x8003;
80002e18:	fe 78 80 03 	mov	r8,-32765
80002e1c:	ae 58       	st.h	r7[0xa],r8
					//0x88F3
					payload_tx_channel->word[2] = DECODER_PAYLOAD;
80002e1e:	fe 78 88 f3 	mov	r8,-30477
80002e22:	ae 68       	st.h	r7[0xc],r8
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80002e24:	4d 98       	lddpc	r8,80002f88 <phy_tx_func+0x4a0>
80002e26:	70 08       	ld.w	r8,r8[0x0]
80002e28:	58 48       	cp.w	r8,4
80002e2a:	c0 60       	breq	80002e36 <phy_tx_func+0x34e>
80002e2c:	c2 83       	brcs	80002e7c <phy_tx_func+0x394>
80002e2e:	58 98       	cp.w	r8,9
80002e30:	e0 8b 00 26 	brhi	80002e7c <phy_tx_func+0x394>
80002e34:	c1 98       	rjmp	80002e66 <phy_tx_func+0x37e>
					{
						case VOICEBURST_A:
								if (VF_SN == 1)
80002e36:	4d 98       	lddpc	r8,80002f98 <phy_tx_func+0x4b0>
80002e38:	11 89       	ld.ub	r9,r8[0x0]
80002e3a:	30 18       	mov	r8,1
80002e3c:	f0 09 18 00 	cp.b	r9,r8
80002e40:	c0 81       	brne	80002e50 <phy_tx_func+0x368>
									//if(AMBEBurst_rawdata[0] == Public_AMBEkey[0])//0X1AC3
									{
										
									
										//Pick up public key
										AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
80002e42:	4d 88       	lddpc	r8,80002fa0 <phy_tx_func+0x4b8>
80002e44:	90 0a       	ld.sh	r10,r8[0x0]
80002e46:	4d a9       	lddpc	r9,80002fac <phy_tx_func+0x4c4>
80002e48:	b2 0a       	st.h	r9[0x0],r10
									
										//Post back data
										payload_tx_channel->word[3] = AMBEBurst_rawdata[0] ;
80002e4a:	90 08       	ld.sh	r8,r8[0x0]
80002e4c:	ae 78       	st.h	r7[0xe],r8
80002e4e:	c0 88       	rjmp	80002e5e <phy_tx_func+0x376>
								else//VF_SN==2/3
								{	
									//Decrypt AMBE data(XOR) 
									//Recover data

									payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002e50:	4d 78       	lddpc	r8,80002fac <phy_tx_func+0x4c4>
80002e52:	90 08       	ld.sh	r8,r8[0x0]
80002e54:	4d 39       	lddpc	r9,80002fa0 <phy_tx_func+0x4b8>
80002e56:	92 09       	ld.sh	r9,r9[0x0]
80002e58:	f3 e8 20 08 	eor	r8,r9,r8
80002e5c:	ae 78       	st.h	r7[0xe],r8
									
									//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								}
					
								AMBEpayload_tx_state = AMBE_DE_LAST;
80002e5e:	30 69       	mov	r9,6
80002e60:	4c 88       	lddpc	r8,80002f80 <phy_tx_func+0x498>
80002e62:	91 09       	st.w	r8[0x0],r9
80002e64:	c7 a8       	rjmp	80002f58 <phy_tx_func+0x470>
						
								//Encrypted AMBE data(XOR)
						
								//Decrypt AMBE data(XOR)
								//Recover data
								payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002e66:	4d 28       	lddpc	r8,80002fac <phy_tx_func+0x4c4>
80002e68:	90 08       	ld.sh	r8,r8[0x0]
80002e6a:	4c e9       	lddpc	r9,80002fa0 <phy_tx_func+0x4b8>
80002e6c:	92 09       	ld.sh	r9,r9[0x0]
80002e6e:	f3 e8 20 08 	eor	r8,r9,r8
80002e72:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								AMBEpayload_tx_state = AMBE_DE_LAST;
80002e74:	30 69       	mov	r9,6
80002e76:	4c 38       	lddpc	r8,80002f80 <phy_tx_func+0x498>
80002e78:	91 09       	st.w	r8[0x0],r9
80002e7a:	c6 f8       	rjmp	80002f58 <phy_tx_func+0x470>
				
							break;
						default://This shouldn't happen, but must check;
					
								payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e7c:	e0 68 5a 5a 	mov	r8,23130
80002e80:	ea 18 ab cd 	orh	r8,0xabcd
80002e84:	8f 28       	st.w	r7[0x8],r8
								payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002e86:	30 08       	mov	r8,0
80002e88:	8f 38       	st.w	r7[0xc],r8
								AMBEpayload_tx_state = AMBE_IDLE;
80002e8a:	4b e9       	lddpc	r9,80002f80 <phy_tx_func+0x498>
80002e8c:	93 08       	st.w	r9[0x0],r8
80002e8e:	c6 58       	rjmp	80002f58 <phy_tx_func+0x470>
		
					break;
				
			case AMBE_DE_LAST:
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80002e90:	4b e8       	lddpc	r8,80002f88 <phy_tx_func+0x4a0>
80002e92:	70 08       	ld.w	r8,r8[0x0]
80002e94:	58 48       	cp.w	r8,4
80002e96:	c0 60       	breq	80002ea2 <phy_tx_func+0x3ba>
80002e98:	c4 53       	brcs	80002f22 <phy_tx_func+0x43a>
80002e9a:	58 98       	cp.w	r8,9
80002e9c:	e0 8b 00 43 	brhi	80002f22 <phy_tx_func+0x43a>
80002ea0:	c2 d8       	rjmp	80002efa <phy_tx_func+0x412>
					{
						case VOICEBURST_A:
							if (VF_SN == 1)
80002ea2:	4b e8       	lddpc	r8,80002f98 <phy_tx_func+0x4b0>
80002ea4:	11 89       	ld.ub	r9,r8[0x0]
80002ea6:	30 18       	mov	r8,1
80002ea8:	f0 09 18 00 	cp.b	r9,r8
80002eac:	c1 31       	brne	80002ed2 <phy_tx_func+0x3ea>
								//if(AMBEBurst_rawdata[1] == Public_AMBEkey[1])//0X1840
								{
								
									//Pick up public key
							
									AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
80002eae:	4b d8       	lddpc	r8,80002fa0 <phy_tx_func+0x4b8>
80002eb0:	90 1a       	ld.sh	r10,r8[0x2]
80002eb2:	4b f9       	lddpc	r9,80002fac <phy_tx_func+0x4c4>
80002eb4:	b2 1a       	st.h	r9[0x2],r10
									AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
80002eb6:	90 2a       	ld.sh	r10,r8[0x4]
80002eb8:	b2 2a       	st.h	r9[0x4],r10
									AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
80002eba:	90 3a       	ld.sh	r10,r8[0x6]
80002ebc:	b2 3a       	st.h	r9[0x6],r10
							
									//Post back data
									payload_tx_channel->word[0] = AMBEBurst_rawdata[1] ;
80002ebe:	90 19       	ld.sh	r9,r8[0x2]
80002ec0:	ae 49       	st.h	r7[0x8],r9
									payload_tx_channel->word[1] = AMBEBurst_rawdata[2] ;
80002ec2:	90 29       	ld.sh	r9,r8[0x4]
80002ec4:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = AMBEBurst_rawdata[3] ;
80002ec6:	90 38       	ld.sh	r8,r8[0x6]
80002ec8:	ae 68       	st.h	r7[0xc],r8
									payload_tx_channel->word[3] = 0x00BA ;
80002eca:	e0 68 00 ba 	mov	r8,186
80002ece:	ae 78       	st.h	r7[0xe],r8
80002ed0:	c1 18       	rjmp	80002ef2 <phy_tx_func+0x40a>
							{
							
								//Decrypt AMBE data(XOR)
								//Recover data

									payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80002ed2:	4b 48       	lddpc	r8,80002fa0 <phy_tx_func+0x4b8>
80002ed4:	90 1a       	ld.sh	r10,r8[0x2]
80002ed6:	4b 69       	lddpc	r9,80002fac <phy_tx_func+0x4c4>
80002ed8:	92 1b       	ld.sh	r11,r9[0x2]
80002eda:	f7 ea 20 0a 	eor	r10,r11,r10
80002ede:	ae 4a       	st.h	r7[0x8],r10
									payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80002ee0:	90 2a       	ld.sh	r10,r8[0x4]
80002ee2:	92 29       	ld.sh	r9,r9[0x4]
80002ee4:	14 59       	eor	r9,r10
80002ee6:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80002ee8:	90 38       	ld.sh	r8,r8[0x6]
80002eea:	ae 68       	st.h	r7[0xc],r8
									
									//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
									//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
									//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
									
									payload_tx_channel->word[3] = 0x00BA ;
80002eec:	e0 68 00 ba 	mov	r8,186
80002ef0:	ae 78       	st.h	r7[0xe],r8
							
							
							}
						
							AMBEpayload_tx_state = AMBE_IDLE;
80002ef2:	30 09       	mov	r9,0
80002ef4:	4a 38       	lddpc	r8,80002f80 <phy_tx_func+0x498>
80002ef6:	91 09       	st.w	r8[0x0],r9
80002ef8:	c3 08       	rjmp	80002f58 <phy_tx_func+0x470>
						
							//Encrypted AMBE data(XOR)
						
							//Decrypt AMBE data(XOR)
							//Recover data
							payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80002efa:	4a a8       	lddpc	r8,80002fa0 <phy_tx_func+0x4b8>
80002efc:	90 1a       	ld.sh	r10,r8[0x2]
80002efe:	4a c9       	lddpc	r9,80002fac <phy_tx_func+0x4c4>
80002f00:	92 1b       	ld.sh	r11,r9[0x2]
80002f02:	f7 ea 20 0a 	eor	r10,r11,r10
80002f06:	ae 4a       	st.h	r7[0x8],r10
							payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80002f08:	90 2a       	ld.sh	r10,r8[0x4]
80002f0a:	92 29       	ld.sh	r9,r9[0x4]
80002f0c:	14 59       	eor	r9,r10
80002f0e:	ae 59       	st.h	r7[0xa],r9
							payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80002f10:	90 38       	ld.sh	r8,r8[0x6]
80002f12:	ae 68       	st.h	r7[0xc],r8
							
							//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
							//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
							//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
							
							payload_tx_channel->word[3] = 0x00BA ;
80002f14:	e0 68 00 ba 	mov	r8,186
80002f18:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_IDLE;
80002f1a:	30 09       	mov	r9,0
80002f1c:	49 98       	lddpc	r8,80002f80 <phy_tx_func+0x498>
80002f1e:	91 09       	st.w	r8[0x0],r9
80002f20:	c1 c8       	rjmp	80002f58 <phy_tx_func+0x470>
						
							break;
						default://This shouldn't happen, but must check;
						
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002f22:	e0 68 5a 5a 	mov	r8,23130
80002f26:	ea 18 ab cd 	orh	r8,0xabcd
80002f2a:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002f2c:	30 08       	mov	r8,0
80002f2e:	8f 38       	st.w	r7[0xc],r8
							AMBEpayload_tx_state = AMBE_IDLE;
80002f30:	49 49       	lddpc	r9,80002f80 <phy_tx_func+0x498>
80002f32:	93 08       	st.w	r9[0x0],r8
80002f34:	c1 28       	rjmp	80002f58 <phy_tx_func+0x470>

				break;
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002f36:	e0 68 5a 5a 	mov	r8,23130
80002f3a:	ea 18 ab cd 	orh	r8,0xabcd
80002f3e:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002f40:	30 08       	mov	r8,0
80002f42:	8f 38       	st.w	r7[0xc],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80002f44:	48 f9       	lddpc	r9,80002f80 <phy_tx_func+0x498>
80002f46:	93 08       	st.w	r9[0x0],r8
80002f48:	c0 88       	rjmp	80002f58 <phy_tx_func+0x470>

	}//end of Send-AMBE-data

	else
	{
		payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002f4a:	e0 68 5a 5a 	mov	r8,23130
80002f4e:	ea 18 ab cd 	orh	r8,0xabcd
80002f52:	8f 28       	st.w	r7[0x8],r8
		payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002f54:	30 08       	mov	r8,0
80002f56:	8f 38       	st.w	r7[0xc],r8
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80002f58:	2f fd       	sub	sp,-4
80002f5a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002f5e:	00 00       	add	r0,r0
80002f60:	00 00       	add	r0,r0
80002f62:	0a d8       	st.w	--r5,r8
80002f64:	00 00       	add	r0,r0
80002f66:	0a 94       	mov	r4,r5
80002f68:	00 00       	add	r0,r0
80002f6a:	0a ec       	st.h	--r5,r12
80002f6c:	80 00       	ld.sh	r0,r0[0x0]
80002f6e:	5b 4c       	cp.w	r12,-12
80002f70:	00 00       	add	r0,r0
80002f72:	0a be       	st.h	r5++,lr
80002f74:	00 00       	add	r0,r0
80002f76:	0a 74       	tst	r4,r5
80002f78:	00 00       	add	r0,r0
80002f7a:	0a 58       	eor	r8,r5
80002f7c:	00 00       	add	r0,r0
80002f7e:	0a e8       	st.h	--r5,r8
80002f80:	00 00       	add	r0,r0
80002f82:	0a 84       	andn	r4,r5
80002f84:	80 00       	ld.sh	r0,r0[0x0]
80002f86:	d1 80       	acall	0x18
80002f88:	00 00       	add	r0,r0
80002f8a:	0a dc       	st.w	--r5,r12
80002f8c:	00 00       	add	r0,r0
80002f8e:	0a 9c       	mov	r12,r5
80002f90:	00 00       	add	r0,r0
80002f92:	1d a4       	ld.ub	r4,lr[0x2]
80002f94:	00 00       	add	r0,r0
80002f96:	1e a0       	st.w	pc++,r0
80002f98:	00 00       	add	r0,r0
80002f9a:	0a 50       	eor	r0,r5
80002f9c:	80 00       	ld.sh	r0,r0[0x0]
80002f9e:	d1 22       	popm	r4-r7,r11
80002fa0:	00 00       	add	r0,r0
80002fa2:	1d 9c       	ld.ub	r12,lr[0x1]
80002fa4:	00 00       	add	r0,r0
80002fa6:	0a e0       	st.h	--r5,r0
80002fa8:	00 00       	add	r0,r0
80002faa:	1e a4       	st.w	pc++,r4
80002fac:	00 00       	add	r0,r0
80002fae:	1d a8       	ld.ub	r8,lr[0x2]

80002fb0 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002fb0:	d4 01       	pushm	lr
80002fb2:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002fb4:	30 0a       	mov	r10,0
80002fb6:	fa cb ff fc 	sub	r11,sp,-4
80002fba:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002fbc:	14 99       	mov	r9,r10
80002fbe:	1a 9b       	mov	r11,sp
80002fc0:	f0 1f 00 05 	mcall	80002fd4 <get_idle_store+0x24>
80002fc4:	58 1c       	cp.w	r12,1
80002fc6:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002fca:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002fce:	2f fd       	sub	sp,-4
80002fd0:	d8 02       	popm	pc
80002fd2:	00 00       	add	r0,r0
80002fd4:	80 00       	ld.sh	r0,r0[0x0]
80002fd6:	5c 3c       	neg	r12

80002fd8 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002fd8:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002fda:	48 5b       	lddpc	r11,80002fec <phy_init+0x14>
80002fdc:	48 5c       	lddpc	r12,80002ff0 <phy_init+0x18>
80002fde:	f0 1f 00 06 	mcall	80002ff4 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002fe2:	f0 1f 00 06 	mcall	80002ff8 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002fe6:	f0 1f 00 06 	mcall	80002ffc <phy_init+0x24>
	
}
80002fea:	d8 02       	popm	pc
80002fec:	80 00       	ld.sh	r0,r0[0x0]
80002fee:	2a e8       	sub	r8,-82
80002ff0:	80 00       	ld.sh	r0,r0[0x0]
80002ff2:	30 60       	mov	r0,6
80002ff4:	80 00       	ld.sh	r0,r0[0x0]
80002ff6:	40 a8       	lddsp	r8,sp[0x28]
80002ff8:	80 00       	ld.sh	r0,r0[0x0]
80002ffa:	40 bc       	lddsp	r12,sp[0x2c]
80002ffc:	80 00       	ld.sh	r0,r0[0x0]
80002ffe:	4a 58       	lddpc	r8,80003090 <phy_rx_func+0x30>

80003000 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80003000:	d4 01       	pushm	lr
80003002:	20 2d       	sub	sp,8
80003004:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003006:	30 08       	mov	r8,0
80003008:	50 18       	stdsp	sp[0x4],r8
	
	if(NULL == phy_payload_frame_rx)
8000300a:	48 f8       	lddpc	r8,80003044 <payload_rx+0x44>
8000300c:	70 08       	ld.w	r8,r8[0x0]
8000300e:	58 08       	cp.w	r8,0
80003010:	c0 71       	brne	8000301e <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80003012:	30 4b       	mov	r11,4
80003014:	30 5c       	mov	r12,5
80003016:	f0 1f 00 0d 	mcall	80003048 <payload_rx+0x48>
8000301a:	48 b8       	lddpc	r8,80003044 <payload_rx+0x44>
8000301c:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
8000301e:	48 a8       	lddpc	r8,80003044 <payload_rx+0x44>
80003020:	70 0c       	ld.w	r12,r8[0x0]
80003022:	30 09       	mov	r9,0
80003024:	fa ca ff fc 	sub	r10,sp,-4
80003028:	1a 9b       	mov	r11,sp
8000302a:	f0 1f 00 09 	mcall	8000304c <payload_rx+0x4c>
8000302e:	c0 91       	brne	80003040 <payload_rx+0x40>
	{
		
		set_payload_idle_isr(payload);
80003030:	48 88       	lddpc	r8,80003050 <payload_rx+0x50>
80003032:	70 0c       	ld.w	r12,r8[0x0]
80003034:	40 0b       	lddsp	r11,sp[0x0]
80003036:	f0 1f 00 08 	mcall	80003054 <payload_rx+0x54>
		logFromISR("mm");
8000303a:	48 8c       	lddpc	r12,80003058 <payload_rx+0x58>
8000303c:	f0 1f 00 08 	mcall	8000305c <payload_rx+0x5c>
	}
	else
	{
		//logFromISR("ss");
	}
}
80003040:	2f ed       	sub	sp,-8
80003042:	d8 02       	popm	pc
80003044:	00 00       	add	r0,r0
80003046:	0a 80       	andn	r0,r5
80003048:	80 00       	ld.sh	r0,r0[0x0]
8000304a:	5f 48       	srge	r8
8000304c:	80 00       	ld.sh	r0,r0[0x0]
8000304e:	5d f8       	*unknown*
80003050:	00 00       	add	r0,r0
80003052:	0a b0       	st.h	r5++,r0
80003054:	80 00       	ld.sh	r0,r0[0x0]
80003056:	29 f0       	sub	r0,-97
80003058:	80 00       	ld.sh	r0,r0[0x0]
8000305a:	d1 9c       	*unknown*
8000305c:	80 00       	ld.sh	r0,r0[0x0]
8000305e:	6b 6c       	ld.w	r12,r5[0x58]

80003060 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80003060:	eb cd 40 e0 	pushm	r5-r7,lr
80003064:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80003066:	fe f8 0e 7a 	ld.w	r8,pc[3706]
8000306a:	70 08       	ld.w	r8,r8[0x0]
8000306c:	58 08       	cp.w	r8,0
8000306e:	e0 80 01 08 	breq	8000327e <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80003072:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80003074:	fe f8 0e 70 	ld.w	r8,pc[3696]
80003078:	70 09       	ld.w	r9,r8[0x0]
8000307a:	2f f9       	sub	r9,-1
8000307c:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
8000307e:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80003082:	70 08       	ld.w	r8,r8[0x0]
80003084:	58 18       	cp.w	r8,1
80003086:	e0 80 00 85 	breq	80003190 <phy_rx_func+0x130>
8000308a:	c0 73       	brcs	80003098 <phy_rx_func+0x38>
8000308c:	58 28       	cp.w	r8,2
8000308e:	c5 c0       	breq	80003146 <phy_rx_func+0xe6>
80003090:	58 38       	cp.w	r8,3
80003092:	e0 81 00 f6 	brne	8000327e <phy_rx_func+0x21e>
80003096:	cd 58       	rjmp	80003240 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80003098:	e0 6a 5a 5a 	mov	r10,23130
8000309c:	ea 1a ab cd 	orh	r10,0xabcd
800030a0:	14 36       	cp.w	r6,r10
800030a2:	e0 80 00 ee 	breq	8000327e <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
800030a6:	ec 08 16 10 	lsr	r8,r6,0x10
800030aa:	e0 48 ab cd 	cp.w	r8,43981
800030ae:	e0 81 00 e8 	brne	8000327e <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
800030b2:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
800030b6:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
800030ba:	20 28       	sub	r8,2
800030bc:	fe f9 0e 30 	ld.w	r9,pc[3632]
800030c0:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
800030c2:	30 09       	mov	r9,0
800030c4:	f2 08 19 00 	cp.h	r8,r9
800030c8:	e0 8a 00 db 	brle	8000327e <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
800030cc:	fe f8 0e 24 	ld.w	r8,pc[3620]
800030d0:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
800030d2:	fe f8 0e 22 	ld.w	r8,pc[3618]
800030d6:	70 0c       	ld.w	r12,r8[0x0]
800030d8:	f0 1f 03 88 	mcall	80003ef8 <phy_rx_func+0xe98>
800030dc:	fe f8 0e 20 	ld.w	r8,pc[3616]
800030e0:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
800030e2:	58 0c       	cp.w	r12,0
800030e4:	e0 80 00 cd 	breq	8000327e <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
800030e8:	fe f8 0e 08 	ld.w	r8,pc[3592]
800030ec:	90 09       	ld.sh	r9,r8[0x0]
800030ee:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
800030f2:	2f f9       	sub	r9,-1
800030f4:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800030f6:	fe fa 0e 06 	ld.w	r10,pc[3590]
800030fa:	74 0a       	ld.w	r10,r10[0x0]
800030fc:	fe fb 0d e8 	ld.w	r11,pc[3560]
80003100:	76 0b       	ld.w	r11,r11[0x0]
80003102:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80003106:	2f f9       	sub	r9,-1
80003108:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
8000310a:	e2 16 0f 00 	andl	r6,0xf00,COH
8000310e:	e0 46 01 00 	cp.w	r6,256
80003112:	c0 c0       	breq	8000312a <phy_rx_func+0xca>
80003114:	e0 8b 00 05 	brhi	8000311e <phy_rx_func+0xbe>
80003118:	58 06       	cp.w	r6,0
8000311a:	c0 80       	breq	8000312a <phy_rx_func+0xca>
8000311c:	c0 c8       	rjmp	80003134 <phy_rx_func+0xd4>
8000311e:	e0 46 02 00 	cp.w	r6,512
80003122:	c0 40       	breq	8000312a <phy_rx_func+0xca>
80003124:	e0 46 03 00 	cp.w	r6,768
80003128:	c0 61       	brne	80003134 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
8000312a:	30 29       	mov	r9,2
8000312c:	fe f8 0d bc 	ld.w	r8,pc[3516]
80003130:	91 09       	st.w	r8[0x0],r9
80003132:	ca 68       	rjmp	8000327e <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80003134:	fe f8 0d c0 	ld.w	r8,pc[3520]
80003138:	70 0c       	ld.w	r12,r8[0x0]
8000313a:	fe f8 0d c2 	ld.w	r8,pc[3522]
8000313e:	70 0b       	ld.w	r11,r8[0x0]
80003140:	f0 1f 03 70 	mcall	80003f00 <phy_rx_func+0xea0>
80003144:	c9 d8       	rjmp	8000327e <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80003146:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
8000314a:	b1 86       	lsr	r6,0x10
8000314c:	14 06       	add	r6,r10
8000314e:	fe f8 0d b6 	ld.w	r8,pc[3510]
80003152:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003154:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80003158:	90 09       	ld.sh	r9,r8[0x0]
8000315a:	fe fb 0d a2 	ld.w	r11,pc[3490]
8000315e:	76 0b       	ld.w	r11,r11[0x0]
80003160:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80003164:	2f f9       	sub	r9,-1
80003166:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80003168:	fe f9 0d 84 	ld.w	r9,pc[3460]
8000316c:	92 08       	ld.sh	r8,r9[0x0]
8000316e:	20 28       	sub	r8,2
80003170:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80003172:	30 09       	mov	r9,0
80003174:	f2 08 19 00 	cp.h	r8,r9
80003178:	e0 8a 00 07 	brle	80003186 <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
8000317c:	30 19       	mov	r9,1
8000317e:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80003182:	91 09       	st.w	r8[0x0],r9
80003184:	c7 d8       	rjmp	8000327e <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80003186:	30 39       	mov	r9,3
80003188:	fe f8 0d 60 	ld.w	r8,pc[3424]
8000318c:	91 09       	st.w	r8[0x0],r9
8000318e:	c7 88       	rjmp	8000327e <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80003190:	ec 0a 14 10 	asr	r10,r6,0x10
80003194:	fe f8 0d 70 	ld.w	r8,pc[3440]
80003198:	90 09       	ld.sh	r9,r8[0x0]
8000319a:	14 09       	add	r9,r10
8000319c:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
8000319e:	fe f9 0d 52 	ld.w	r9,pc[3410]
800031a2:	92 08       	ld.sh	r8,r9[0x0]
800031a4:	fe fb 0d 58 	ld.w	r11,pc[3416]
800031a8:	76 0b       	ld.w	r11,r11[0x0]
800031aa:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
800031ae:	2f f8       	sub	r8,-1
800031b0:	5c 88       	casts.h	r8
800031b2:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
800031b4:	fe fa 0d 38 	ld.w	r10,pc[3384]
800031b8:	94 09       	ld.sh	r9,r10[0x0]
800031ba:	20 29       	sub	r9,2
800031bc:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
800031be:	30 0a       	mov	r10,0
800031c0:	f4 09 19 00 	cp.h	r9,r10
800031c4:	e0 89 00 20 	brgt	80003204 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
800031c8:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
800031cc:	e0 46 00 ba 	cp.w	r6,186
800031d0:	c0 d1       	brne	800031ea <phy_rx_func+0x18a>
800031d2:	fe f8 0d 32 	ld.w	r8,pc[3378]
800031d6:	90 09       	ld.sh	r9,r8[0x0]
800031d8:	f4 09 19 00 	cp.h	r9,r10
800031dc:	c0 71       	brne	800031ea <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
800031de:	fe f8 0d 1e 	ld.w	r8,pc[3358]
800031e2:	70 0c       	ld.w	r12,r8[0x0]
800031e4:	f0 1f 03 49 	mcall	80003f08 <phy_rx_func+0xea8>
800031e8:	c0 98       	rjmp	800031fa <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
800031ea:	fe f8 0d 0a 	ld.w	r8,pc[3338]
800031ee:	70 0c       	ld.w	r12,r8[0x0]
800031f0:	fe f8 0d 0c 	ld.w	r8,pc[3340]
800031f4:	70 0b       	ld.w	r11,r8[0x0]
800031f6:	f0 1f 03 43 	mcall	80003f00 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
800031fa:	30 09       	mov	r9,0
800031fc:	fe f8 0c ec 	ld.w	r8,pc[3308]
80003200:	91 09       	st.w	r8[0x0],r9
80003202:	c3 e8       	rjmp	8000327e <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80003204:	5c 86       	casts.h	r6
80003206:	fe f9 0c fe 	ld.w	r9,pc[3326]
8000320a:	92 0a       	ld.sh	r10,r9[0x0]
8000320c:	0c 0a       	add	r10,r6
8000320e:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003210:	fe f9 0c ec 	ld.w	r9,pc[3308]
80003214:	72 09       	ld.w	r9,r9[0x0]
80003216:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
8000321a:	2f f8       	sub	r8,-1
8000321c:	fe f9 0c d4 	ld.w	r9,pc[3284]
80003220:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80003222:	fe f9 0c ca 	ld.w	r9,pc[3274]
80003226:	92 08       	ld.sh	r8,r9[0x0]
80003228:	20 28       	sub	r8,2
8000322a:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
8000322c:	30 09       	mov	r9,0
8000322e:	f2 08 19 00 	cp.h	r8,r9
80003232:	e0 89 00 26 	brgt	8000327e <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80003236:	30 39       	mov	r9,3
80003238:	fe f8 0c b0 	ld.w	r8,pc[3248]
8000323c:	91 09       	st.w	r8[0x0],r9
8000323e:	c2 08       	rjmp	8000327e <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80003240:	e6 16 00 ff 	andh	r6,0xff,COH
80003244:	fc 19 00 ba 	movh	r9,0xba
80003248:	12 36       	cp.w	r6,r9
8000324a:	c0 e1       	brne	80003266 <phy_rx_func+0x206>
8000324c:	fe f8 0c b8 	ld.w	r8,pc[3256]
80003250:	90 09       	ld.sh	r9,r8[0x0]
80003252:	30 08       	mov	r8,0
80003254:	f0 09 19 00 	cp.h	r9,r8
80003258:	c0 71       	brne	80003266 <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
8000325a:	fe f8 0c a2 	ld.w	r8,pc[3234]
8000325e:	70 0c       	ld.w	r12,r8[0x0]
80003260:	f0 1f 03 2a 	mcall	80003f08 <phy_rx_func+0xea8>
80003264:	c0 98       	rjmp	80003276 <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80003266:	fe f8 0c 8e 	ld.w	r8,pc[3214]
8000326a:	70 0c       	ld.w	r12,r8[0x0]
8000326c:	fe f8 0c 90 	ld.w	r8,pc[3216]
80003270:	70 0b       	ld.w	r11,r8[0x0]
80003272:	f0 1f 03 24 	mcall	80003f00 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80003276:	30 09       	mov	r9,0
80003278:	fe f8 0c 70 	ld.w	r8,pc[3184]
8000327c:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
8000327e:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80003282:	11 89       	ld.ub	r9,r8[0x0]
80003284:	30 08       	mov	r8,0
80003286:	f0 09 18 00 	cp.b	r9,r8
8000328a:	c1 31       	brne	800032b0 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
8000328c:	fe f6 0c 84 	ld.w	r6,pc[3204]
80003290:	6c 0c       	ld.w	r12,r6[0x0]
80003292:	f0 1f 03 1a 	mcall	80003ef8 <phy_rx_func+0xe98>
80003296:	fe f8 0c 7e 	ld.w	r8,pc[3198]
8000329a:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
8000329c:	6c 0c       	ld.w	r12,r6[0x0]
8000329e:	f0 1f 03 17 	mcall	80003ef8 <phy_rx_func+0xe98>
800032a2:	fe f8 0c 76 	ld.w	r8,pc[3190]
800032a6:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
800032a8:	30 19       	mov	r9,1
800032aa:	fe f8 0c 62 	ld.w	r8,pc[3170]
800032ae:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
800032b0:	fe f8 0c 6c 	ld.w	r8,pc[3180]
800032b4:	70 08       	ld.w	r8,r8[0x0]
800032b6:	58 28       	cp.w	r8,2
800032b8:	e0 80 01 98 	breq	800035e8 <phy_rx_func+0x588>
800032bc:	e0 8b 00 06 	brhi	800032c8 <phy_rx_func+0x268>
800032c0:	58 08       	cp.w	r8,0
800032c2:	c0 b0       	breq	800032d8 <phy_rx_func+0x278>
800032c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800032c8:	58 38       	cp.w	r8,3
800032ca:	e0 80 05 c5 	breq	80003e54 <phy_rx_func+0xdf4>
800032ce:	58 48       	cp.w	r8,4
800032d0:	e0 81 06 05 	brne	80003eda <phy_rx_func+0xe7a>
800032d4:	e0 8f 02 4b 	bral	8000376a <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
800032d8:	6e 28       	ld.w	r8,r7[0x8]
800032da:	e0 6a 5a 5a 	mov	r10,23130
800032de:	ea 1a ab cd 	orh	r10,0xabcd
800032e2:	14 38       	cp.w	r8,r10
800032e4:	c0 71       	brne	800032f2 <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
800032e6:	30 09       	mov	r9,0
800032e8:	fe f8 0c 38 	ld.w	r8,pc[3128]
800032ec:	91 09       	st.w	r8[0x0],r9
800032ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
800032f2:	10 99       	mov	r9,r8
800032f4:	e0 19 00 00 	andl	r9,0x0
800032f8:	fc 1a ab cd 	movh	r10,0xabcd
800032fc:	14 39       	cp.w	r9,r10
800032fe:	e0 81 05 ee 	brne	80003eda <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80003302:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80003306:	fe f9 0c 1e 	ld.w	r9,pc[3102]
8000330a:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
8000330c:	6e 29       	ld.w	r9,r7[0x8]
8000330e:	e2 19 f0 00 	andl	r9,0xf000,COH
80003312:	e0 49 c0 00 	cp.w	r9,49152
80003316:	e0 81 00 ce 	brne	800034b2 <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
8000331a:	30 1a       	mov	r10,1
8000331c:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80003320:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
80003322:	fe f9 0b f6 	ld.w	r9,pc[3062]
80003326:	72 09       	ld.w	r9,r9[0x0]
80003328:	58 09       	cp.w	r9,0
8000332a:	c0 71       	brne	80003338 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
8000332c:	fe fc 0c 00 	ld.w	r12,pc[3072]
80003330:	f0 1f 03 00 	mcall	80003f30 <phy_rx_func+0xed0>
80003334:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80003338:	ef 3a 00 0d 	ld.ub	r10,r7[13]
8000333c:	fe f9 0b f8 	ld.w	r9,pc[3064]
80003340:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80003342:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003346:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
8000334a:	fe fa 0b ee 	ld.w	r10,pc[3054]
8000334e:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80003350:	13 89       	ld.ub	r9,r9[0x0]
80003352:	37 fa       	mov	r10,127
80003354:	f4 09 18 00 	cp.b	r9,r10
80003358:	c6 d0       	breq	80003432 <phy_rx_func+0x3d2>
8000335a:	e0 8b 00 0c 	brhi	80003372 <phy_rx_func+0x312>
8000335e:	31 2a       	mov	r10,18
80003360:	f4 09 18 00 	cp.b	r9,r10
80003364:	c4 20       	breq	800033e8 <phy_rx_func+0x388>
80003366:	31 3a       	mov	r10,19
80003368:	f4 09 18 00 	cp.b	r9,r10
8000336c:	e0 81 00 83 	brne	80003472 <phy_rx_func+0x412>
80003370:	c5 b8       	rjmp	80003426 <phy_rx_func+0x3c6>
80003372:	2f 09       	sub	r9,-16
80003374:	30 1a       	mov	r10,1
80003376:	f4 09 18 00 	cp.b	r9,r10
8000337a:	e0 8b 00 7c 	brhi	80003472 <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
8000337e:	ef 38 00 0e 	ld.ub	r8,r7[14]
80003382:	e2 18 00 f0 	andl	r8,0xf0,COH
80003386:	59 08       	cp.w	r8,16
80003388:	c0 71       	brne	80003396 <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
8000338a:	30 19       	mov	r9,1
8000338c:	fe f8 0b 94 	ld.w	r8,pc[2964]
80003390:	91 09       	st.w	r8[0x0],r9
80003392:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80003396:	e0 48 00 20 	cp.w	r8,32
8000339a:	c2 11       	brne	800033dc <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
8000339c:	30 a9       	mov	r9,10
8000339e:	fe f8 0b 82 	ld.w	r8,pc[2946]
800033a2:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
800033a4:	fe f6 0b 98 	ld.w	r6,pc[2968]
800033a8:	6c 08       	ld.w	r8,r6[0x0]
800033aa:	f0 0a 11 ff 	rsub	r10,r8,-1
800033ae:	fe f7 0b 6a 	ld.w	r7,pc[2922]
800033b2:	2f f8       	sub	r8,-1
800033b4:	6e 0c       	ld.w	r12,r7[0x0]
800033b6:	f4 ca fe 00 	sub	r10,r10,-512
800033ba:	30 0b       	mov	r11,0
800033bc:	10 0c       	add	r12,r8
800033be:	f0 1f 02 e1 	mcall	80003f40 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
800033c2:	30 08       	mov	r8,0
800033c4:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
800033c6:	6e 0c       	ld.w	r12,r7[0x0]
800033c8:	f0 1f 02 df 	mcall	80003f44 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800033cc:	fe f8 0b 44 	ld.w	r8,pc[2884]
800033d0:	70 0c       	ld.w	r12,r8[0x0]
800033d2:	f0 1f 02 ca 	mcall	80003ef8 <phy_rx_func+0xe98>
800033d6:	8f 0c       	st.w	r7[0x0],r12
800033d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
800033dc:	30 09       	mov	r9,0
800033de:	fe f8 0b 42 	ld.w	r8,pc[2882]
800033e2:	91 09       	st.w	r8[0x0],r9
800033e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800033e8:	20 48       	sub	r8,4
800033ea:	fe f9 0b 3a 	ld.w	r9,pc[2874]
800033ee:	93 08       	st.w	r9[0x0],r8
800033f0:	58 08       	cp.w	r8,0
800033f2:	e0 80 05 74 	breq	80003eda <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
800033f6:	ef 3c 00 0f 	ld.ub	r12,r7[15]
800033fa:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
800033fe:	fe f8 0b 4a 	ld.w	r8,pc[2890]
80003402:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003404:	8e 69       	ld.sh	r9,r7[0xc]
80003406:	fe f8 0b 46 	ld.w	r8,pc[2886]
8000340a:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
8000340c:	8e 79       	ld.sh	r9,r7[0xe]
8000340e:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003410:	f0 1f 02 d0 	mcall	80003f50 <phy_rx_func+0xef0>
80003414:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80003418:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000341a:	30 49       	mov	r9,4
8000341c:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003420:	91 09       	st.w	r8[0x0],r9
80003422:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80003426:	30 09       	mov	r9,0
80003428:	fe f8 0a f8 	ld.w	r8,pc[2808]
8000342c:	91 09       	st.w	r8[0x0],r9
8000342e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003432:	20 48       	sub	r8,4
80003434:	fe f9 0a f0 	ld.w	r9,pc[2800]
80003438:	93 08       	st.w	r9[0x0],r8
8000343a:	58 08       	cp.w	r8,0
8000343c:	e0 80 05 4f 	breq	80003eda <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003440:	fe f8 0b 14 	ld.w	r8,pc[2836]
80003444:	70 09       	ld.w	r9,r8[0x0]
80003446:	8e 7b       	ld.sh	r11,r7[0xe]
80003448:	fe fa 0b 10 	ld.w	r10,pc[2832]
8000344c:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003450:	2f f9       	sub	r9,-1
80003452:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003454:	fe f8 0a e4 	ld.w	r8,pc[2788]
80003458:	70 09       	ld.w	r9,r8[0x0]
8000345a:	20 29       	sub	r9,2
8000345c:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
8000345e:	30 29       	mov	r9,2
80003460:	fe f8 0a c0 	ld.w	r8,pc[2752]
80003464:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003466:	30 39       	mov	r9,3
80003468:	fe f8 0a b4 	ld.w	r8,pc[2740]
8000346c:	91 09       	st.w	r8[0x0],r9
8000346e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003472:	30 3a       	mov	r10,3
80003474:	fe f9 0a ac 	ld.w	r9,pc[2732]
80003478:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
8000347a:	6e 2a       	ld.w	r10,r7[0x8]
8000347c:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003480:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003482:	6e 3a       	ld.w	r10,r7[0xc]
80003484:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
80003486:	59 48       	cp.w	r8,20
80003488:	c0 61       	brne	80003494 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
8000348a:	31 89       	mov	r9,24
8000348c:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003490:	91 09       	st.w	r8[0x0],r9
80003492:	c0 a8       	rjmp	800034a6 <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003494:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003498:	70 08       	ld.w	r8,r8[0x0]
8000349a:	59 08       	cp.w	r8,16
8000349c:	c0 51       	brne	800034a6 <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
8000349e:	31 09       	mov	r9,16
800034a0:	fe f8 0a 84 	ld.w	r8,pc[2692]
800034a4:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
800034a6:	30 49       	mov	r9,4
800034a8:	fe f8 0a 74 	ld.w	r8,pc[2676]
800034ac:	91 09       	st.w	r8[0x0],r9
800034ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
800034b2:	e0 49 10 00 	cp.w	r9,4096
800034b6:	5f 1a       	srne	r10
800034b8:	e0 49 20 00 	cp.w	r9,8192
800034bc:	5f 19       	srne	r9
800034be:	f5 e9 00 09 	and	r9,r10,r9
800034c2:	e0 81 05 0c 	brne	80003eda <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
800034c6:	fe fa 0a 9a 	ld.w	r10,pc[2714]
800034ca:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
800034cc:	fe fa 0a 98 	ld.w	r10,pc[2712]
800034d0:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
800034d2:	fe fa 0a 62 	ld.w	r10,pc[2658]
800034d6:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
800034d8:	fe f9 0a 3c 	ld.w	r9,pc[2620]
800034dc:	72 09       	ld.w	r9,r9[0x0]
800034de:	58 09       	cp.w	r9,0
800034e0:	c0 71       	brne	800034ee <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800034e2:	fe fc 0a 4a 	ld.w	r12,pc[2634]
800034e6:	f0 1f 02 93 	mcall	80003f30 <phy_rx_func+0xed0>
800034ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800034ee:	6e 2a       	ld.w	r10,r7[0x8]
800034f0:	e2 1a 0f 00 	andl	r10,0xf00,COH
800034f4:	58 1a       	cp.w	r10,1
800034f6:	e0 8b 00 4d 	brhi	80003590 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
800034fa:	20 48       	sub	r8,4
800034fc:	fe f9 0a 28 	ld.w	r9,pc[2600]
80003500:	93 08       	st.w	r9[0x0],r8
80003502:	58 08       	cp.w	r8,0
80003504:	e0 80 04 eb 	breq	80003eda <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
80003508:	8e 68       	ld.sh	r8,r7[0xc]
8000350a:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000350e:	fe f9 0a 5a 	ld.w	r9,pc[2650]
80003512:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
80003514:	30 09       	mov	r9,0
80003516:	f2 08 19 00 	cp.h	r8,r9
8000351a:	c0 70       	breq	80003528 <phy_rx_func+0x4c8>
8000351c:	30 19       	mov	r9,1
8000351e:	f2 08 19 00 	cp.h	r8,r9
80003522:	e0 81 04 dc 	brne	80003eda <phy_rx_func+0xe7a>
80003526:	c2 68       	rjmp	80003572 <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003528:	fe f8 0a 44 	ld.w	r8,pc[2628]
8000352c:	70 0a       	ld.w	r10,r8[0x0]
8000352e:	fe f9 09 e6 	ld.w	r9,pc[2534]
80003532:	72 09       	ld.w	r9,r9[0x0]
80003534:	8e 7b       	ld.sh	r11,r7[0xe]
80003536:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
8000353a:	70 09       	ld.w	r9,r8[0x0]
8000353c:	2f f9       	sub	r9,-1
8000353e:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003540:	e0 49 00 ff 	cp.w	r9,255
80003544:	e0 88 00 11 	brls	80003566 <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
80003548:	30 09       	mov	r9,0
8000354a:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
8000354c:	fe f7 09 c8 	ld.w	r7,pc[2504]
80003550:	6e 0c       	ld.w	r12,r7[0x0]
80003552:	f0 1f 02 7d 	mcall	80003f44 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
80003556:	fe f8 09 ba 	ld.w	r8,pc[2490]
8000355a:	70 0c       	ld.w	r12,r8[0x0]
8000355c:	f0 1f 02 67 	mcall	80003ef8 <phy_rx_func+0xe98>
80003560:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
80003562:	e0 80 04 bc 	breq	80003eda <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
80003566:	30 29       	mov	r9,2
80003568:	fe f8 09 b4 	ld.w	r8,pc[2484]
8000356c:	91 09       	st.w	r8[0x0],r9
8000356e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003572:	8e 79       	ld.sh	r9,r7[0xe]
80003574:	30 38       	mov	r8,3
80003576:	f0 09 19 00 	cp.h	r9,r8
8000357a:	c0 51       	brne	80003584 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
8000357c:	30 19       	mov	r9,1
8000357e:	fe f8 09 f2 	ld.w	r8,pc[2546]
80003582:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
80003584:	30 29       	mov	r9,2
80003586:	fe f8 09 96 	ld.w	r8,pc[2454]
8000358a:	91 09       	st.w	r8[0x0],r9
8000358c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003590:	58 18       	cp.w	r8,1
80003592:	e0 88 04 a4 	brls	80003eda <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003596:	fe f8 09 d6 	ld.w	r8,pc[2518]
8000359a:	70 0a       	ld.w	r10,r8[0x0]
8000359c:	6e 3b       	ld.w	r11,r7[0xc]
8000359e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800035a2:	70 09       	ld.w	r9,r8[0x0]
800035a4:	2f f9       	sub	r9,-1
800035a6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800035a8:	e0 49 00 ff 	cp.w	r9,255
800035ac:	e0 88 00 11 	brls	800035ce <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
800035b0:	30 09       	mov	r9,0
800035b2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800035b4:	fe f7 09 60 	ld.w	r7,pc[2400]
800035b8:	6e 0c       	ld.w	r12,r7[0x0]
800035ba:	f0 1f 02 63 	mcall	80003f44 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800035be:	fe f8 09 52 	ld.w	r8,pc[2386]
800035c2:	70 0c       	ld.w	r12,r8[0x0]
800035c4:	f0 1f 02 4d 	mcall	80003ef8 <phy_rx_func+0xe98>
800035c8:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800035ca:	e0 80 04 88 	breq	80003eda <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
800035ce:	fe f9 09 56 	ld.w	r9,pc[2390]
800035d2:	72 08       	ld.w	r8,r9[0x0]
800035d4:	20 28       	sub	r8,2
800035d6:	93 08       	st.w	r9[0x0],r8
800035d8:	e0 80 04 81 	breq	80003eda <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
800035dc:	30 29       	mov	r9,2
800035de:	fe f8 09 3e 	ld.w	r8,pc[2366]
800035e2:	91 09       	st.w	r8[0x0],r9
800035e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
800035e8:	fe f8 09 84 	ld.w	r8,pc[2436]
800035ec:	70 0a       	ld.w	r10,r8[0x0]
800035ee:	fe f9 09 26 	ld.w	r9,pc[2342]
800035f2:	72 09       	ld.w	r9,r9[0x0]
800035f4:	8e 4b       	ld.sh	r11,r7[0x8]
800035f6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
800035fa:	70 09       	ld.w	r9,r8[0x0]
800035fc:	2f f9       	sub	r9,-1
800035fe:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003600:	e0 49 00 ff 	cp.w	r9,255
80003604:	e0 88 00 16 	brls	80003630 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
80003608:	30 09       	mov	r9,0
8000360a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000360c:	fe f6 09 08 	ld.w	r6,pc[2312]
80003610:	6c 0c       	ld.w	r12,r6[0x0]
80003612:	f0 1f 02 4d 	mcall	80003f44 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003616:	fe f8 08 fa 	ld.w	r8,pc[2298]
8000361a:	70 0c       	ld.w	r12,r8[0x0]
8000361c:	f0 1f 02 37 	mcall	80003ef8 <phy_rx_func+0xe98>
80003620:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003622:	c0 71       	brne	80003630 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
80003624:	30 09       	mov	r9,0
80003626:	fe f8 08 f6 	ld.w	r8,pc[2294]
8000362a:	91 09       	st.w	r8[0x0],r9
8000362c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
80003630:	fe f9 08 f4 	ld.w	r9,pc[2292]
80003634:	72 08       	ld.w	r8,r9[0x0]
80003636:	20 28       	sub	r8,2
80003638:	93 08       	st.w	r9[0x0],r8
8000363a:	c0 71       	brne	80003648 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
8000363c:	30 09       	mov	r9,0
8000363e:	fe f8 08 de 	ld.w	r8,pc[2270]
80003642:	91 09       	st.w	r8[0x0],r9
80003644:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003648:	fe f8 09 24 	ld.w	r8,pc[2340]
8000364c:	70 0a       	ld.w	r10,r8[0x0]
8000364e:	fe f9 08 c6 	ld.w	r9,pc[2246]
80003652:	72 09       	ld.w	r9,r9[0x0]
80003654:	8e 5b       	ld.sh	r11,r7[0xa]
80003656:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000365a:	70 09       	ld.w	r9,r8[0x0]
8000365c:	2f f9       	sub	r9,-1
8000365e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003660:	e0 49 00 ff 	cp.w	r9,255
80003664:	e0 88 00 16 	brls	80003690 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003668:	30 09       	mov	r9,0
8000366a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000366c:	fe f6 08 a8 	ld.w	r6,pc[2216]
80003670:	6c 0c       	ld.w	r12,r6[0x0]
80003672:	f0 1f 02 35 	mcall	80003f44 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003676:	fe f8 08 9a 	ld.w	r8,pc[2202]
8000367a:	70 0c       	ld.w	r12,r8[0x0]
8000367c:	f0 1f 02 1f 	mcall	80003ef8 <phy_rx_func+0xe98>
80003680:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003682:	c0 71       	brne	80003690 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003684:	30 09       	mov	r9,0
80003686:	fe f8 08 96 	ld.w	r8,pc[2198]
8000368a:	91 09       	st.w	r8[0x0],r9
8000368c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003690:	fe f9 08 94 	ld.w	r9,pc[2196]
80003694:	72 08       	ld.w	r8,r9[0x0]
80003696:	20 28       	sub	r8,2
80003698:	93 08       	st.w	r9[0x0],r8
8000369a:	c0 71       	brne	800036a8 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
8000369c:	30 09       	mov	r9,0
8000369e:	fe f8 08 7e 	ld.w	r8,pc[2174]
800036a2:	91 09       	st.w	r8[0x0],r9
800036a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
800036a8:	fe f8 08 c4 	ld.w	r8,pc[2244]
800036ac:	70 0a       	ld.w	r10,r8[0x0]
800036ae:	fe f9 08 66 	ld.w	r9,pc[2150]
800036b2:	72 09       	ld.w	r9,r9[0x0]
800036b4:	8e 6b       	ld.sh	r11,r7[0xc]
800036b6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800036ba:	70 09       	ld.w	r9,r8[0x0]
800036bc:	2f f9       	sub	r9,-1
800036be:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800036c0:	e0 49 00 ff 	cp.w	r9,255
800036c4:	e0 88 00 16 	brls	800036f0 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
800036c8:	30 09       	mov	r9,0
800036ca:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800036cc:	fe f6 08 48 	ld.w	r6,pc[2120]
800036d0:	6c 0c       	ld.w	r12,r6[0x0]
800036d2:	f0 1f 02 1d 	mcall	80003f44 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800036d6:	fe f8 08 3a 	ld.w	r8,pc[2106]
800036da:	70 0c       	ld.w	r12,r8[0x0]
800036dc:	f0 1f 02 07 	mcall	80003ef8 <phy_rx_func+0xe98>
800036e0:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800036e2:	c0 71       	brne	800036f0 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
800036e4:	30 09       	mov	r9,0
800036e6:	fe f8 08 36 	ld.w	r8,pc[2102]
800036ea:	91 09       	st.w	r8[0x0],r9
800036ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800036f0:	fe f9 08 34 	ld.w	r9,pc[2100]
800036f4:	72 08       	ld.w	r8,r9[0x0]
800036f6:	20 28       	sub	r8,2
800036f8:	93 08       	st.w	r9[0x0],r8
800036fa:	c0 71       	brne	80003708 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
800036fc:	30 09       	mov	r9,0
800036fe:	fe f8 08 1e 	ld.w	r8,pc[2078]
80003702:	91 09       	st.w	r8[0x0],r9
80003704:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003708:	fe f8 08 64 	ld.w	r8,pc[2148]
8000370c:	70 0a       	ld.w	r10,r8[0x0]
8000370e:	fe f9 08 06 	ld.w	r9,pc[2054]
80003712:	72 09       	ld.w	r9,r9[0x0]
80003714:	8e 7b       	ld.sh	r11,r7[0xe]
80003716:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000371a:	70 09       	ld.w	r9,r8[0x0]
8000371c:	2f f9       	sub	r9,-1
8000371e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003720:	e0 49 00 ff 	cp.w	r9,255
80003724:	e0 88 00 16 	brls	80003750 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
80003728:	30 09       	mov	r9,0
8000372a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000372c:	fe f7 07 e8 	ld.w	r7,pc[2024]
80003730:	6e 0c       	ld.w	r12,r7[0x0]
80003732:	f0 1f 02 05 	mcall	80003f44 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003736:	fe f8 07 da 	ld.w	r8,pc[2010]
8000373a:	70 0c       	ld.w	r12,r8[0x0]
8000373c:	f0 1f 01 ef 	mcall	80003ef8 <phy_rx_func+0xe98>
80003740:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003742:	c0 71       	brne	80003750 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
80003744:	30 09       	mov	r9,0
80003746:	fe f8 07 d6 	ld.w	r8,pc[2006]
8000374a:	91 09       	st.w	r8[0x0],r9
8000374c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003750:	fe f9 07 d4 	ld.w	r9,pc[2004]
80003754:	72 08       	ld.w	r8,r9[0x0]
80003756:	20 28       	sub	r8,2
80003758:	93 08       	st.w	r9[0x0],r8
8000375a:	e0 81 03 c0 	brne	80003eda <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
8000375e:	30 09       	mov	r9,0
80003760:	fe f8 07 bc 	ld.w	r8,pc[1980]
80003764:	91 09       	st.w	r8[0x0],r9
80003766:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
8000376a:	fe f8 07 ca 	ld.w	r8,pc[1994]
8000376e:	11 89       	ld.ub	r9,r8[0x0]
80003770:	31 28       	mov	r8,18
80003772:	f0 09 18 00 	cp.b	r9,r8
80003776:	e0 81 01 4c 	brne	80003a0e <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
8000377a:	ef 39 00 09 	ld.ub	r9,r7[9]
8000377e:	fe f8 07 b6 	ld.w	r8,pc[1974]
80003782:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003784:	11 89       	ld.ub	r9,r8[0x0]
80003786:	3f 28       	mov	r8,-14
80003788:	f0 09 18 00 	cp.b	r9,r8
8000378c:	e0 81 01 3b 	brne	80003a02 <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003790:	30 19       	mov	r9,1
80003792:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003796:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003798:	6e 29       	ld.w	r9,r7[0x8]
8000379a:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
8000379e:	fe f8 07 86 	ld.w	r8,pc[1926]
800037a2:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
800037a4:	8e 59       	ld.sh	r9,r7[0xa]
800037a6:	fe f8 07 ce 	ld.w	r8,pc[1998]
800037aa:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
800037ac:	8e 69       	ld.sh	r9,r7[0xc]
800037ae:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
800037b0:	8e 79       	ld.sh	r9,r7[0xe]
800037b2:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
800037b4:	fe f8 07 88 	ld.w	r8,pc[1928]
800037b8:	fe f9 07 60 	ld.w	r9,pc[1888]
800037bc:	72 0a       	ld.w	r10,r9[0x0]
800037be:	70 09       	ld.w	r9,r8[0x0]
800037c0:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800037c4:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800037c8:	70 09       	ld.w	r9,r8[0x0]
800037ca:	2f f9       	sub	r9,-1
800037cc:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037ce:	e0 49 01 ff 	cp.w	r9,511
800037d2:	e0 88 00 16 	brls	800037fe <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
800037d6:	30 09       	mov	r9,0
800037d8:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800037da:	fe f6 07 3e 	ld.w	r6,pc[1854]
800037de:	6c 0c       	ld.w	r12,r6[0x0]
800037e0:	f0 1f 01 d9 	mcall	80003f44 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800037e4:	fe f8 07 2c 	ld.w	r8,pc[1836]
800037e8:	70 0c       	ld.w	r12,r8[0x0]
800037ea:	f0 1f 01 c4 	mcall	80003ef8 <phy_rx_func+0xe98>
800037ee:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800037f0:	c0 71       	brne	800037fe <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
800037f2:	30 09       	mov	r9,0
800037f4:	fe f8 07 28 	ld.w	r8,pc[1832]
800037f8:	91 09       	st.w	r8[0x0],r9
800037fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800037fe:	fe f9 07 26 	ld.w	r9,pc[1830]
80003802:	72 08       	ld.w	r8,r9[0x0]
80003804:	20 18       	sub	r8,1
80003806:	93 08       	st.w	r9[0x0],r8
80003808:	c0 71       	brne	80003816 <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
8000380a:	30 09       	mov	r9,0
8000380c:	fe f8 07 10 	ld.w	r8,pc[1808]
80003810:	91 09       	st.w	r8[0x0],r9
80003812:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003816:	fe f8 07 26 	ld.w	r8,pc[1830]
8000381a:	fe f9 06 fe 	ld.w	r9,pc[1790]
8000381e:	72 0a       	ld.w	r10,r9[0x0]
80003820:	70 09       	ld.w	r9,r8[0x0]
80003822:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003826:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000382a:	70 09       	ld.w	r9,r8[0x0]
8000382c:	2f f9       	sub	r9,-1
8000382e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003830:	e0 49 01 ff 	cp.w	r9,511
80003834:	e0 88 00 16 	brls	80003860 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
80003838:	30 09       	mov	r9,0
8000383a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000383c:	fe f6 06 dc 	ld.w	r6,pc[1756]
80003840:	6c 0c       	ld.w	r12,r6[0x0]
80003842:	f0 1f 01 c1 	mcall	80003f44 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003846:	fe f8 06 ca 	ld.w	r8,pc[1738]
8000384a:	70 0c       	ld.w	r12,r8[0x0]
8000384c:	f0 1f 01 ab 	mcall	80003ef8 <phy_rx_func+0xe98>
80003850:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003852:	c0 71       	brne	80003860 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
80003854:	30 09       	mov	r9,0
80003856:	fe f8 06 c6 	ld.w	r8,pc[1734]
8000385a:	91 09       	st.w	r8[0x0],r9
8000385c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003860:	fe f9 06 c4 	ld.w	r9,pc[1732]
80003864:	72 08       	ld.w	r8,r9[0x0]
80003866:	20 18       	sub	r8,1
80003868:	93 08       	st.w	r9[0x0],r8
8000386a:	c0 71       	brne	80003878 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
8000386c:	30 09       	mov	r9,0
8000386e:	fe f8 06 ae 	ld.w	r8,pc[1710]
80003872:	91 09       	st.w	r8[0x0],r9
80003874:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003878:	fe f8 06 c4 	ld.w	r8,pc[1732]
8000387c:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003880:	72 0a       	ld.w	r10,r9[0x0]
80003882:	70 09       	ld.w	r9,r8[0x0]
80003884:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003888:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000388c:	70 09       	ld.w	r9,r8[0x0]
8000388e:	2f f9       	sub	r9,-1
80003890:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003892:	e0 49 01 ff 	cp.w	r9,511
80003896:	e0 88 00 16 	brls	800038c2 <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
8000389a:	30 09       	mov	r9,0
8000389c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000389e:	fe f6 06 7a 	ld.w	r6,pc[1658]
800038a2:	6c 0c       	ld.w	r12,r6[0x0]
800038a4:	f0 1f 01 a8 	mcall	80003f44 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800038a8:	fe f8 06 68 	ld.w	r8,pc[1640]
800038ac:	70 0c       	ld.w	r12,r8[0x0]
800038ae:	f0 1f 01 93 	mcall	80003ef8 <phy_rx_func+0xe98>
800038b2:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800038b4:	c0 71       	brne	800038c2 <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
800038b6:	30 09       	mov	r9,0
800038b8:	fe f8 06 64 	ld.w	r8,pc[1636]
800038bc:	91 09       	st.w	r8[0x0],r9
800038be:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800038c2:	fe f9 06 62 	ld.w	r9,pc[1634]
800038c6:	72 08       	ld.w	r8,r9[0x0]
800038c8:	20 18       	sub	r8,1
800038ca:	93 08       	st.w	r9[0x0],r8
800038cc:	c0 71       	brne	800038da <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
800038ce:	30 09       	mov	r9,0
800038d0:	fe f8 06 4c 	ld.w	r8,pc[1612]
800038d4:	91 09       	st.w	r8[0x0],r9
800038d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
800038da:	fe f8 06 62 	ld.w	r8,pc[1634]
800038de:	fe f9 06 3a 	ld.w	r9,pc[1594]
800038e2:	72 0a       	ld.w	r10,r9[0x0]
800038e4:	70 09       	ld.w	r9,r8[0x0]
800038e6:	ef 3b 00 0d 	ld.ub	r11,r7[13]
800038ea:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800038ee:	70 09       	ld.w	r9,r8[0x0]
800038f0:	2f f9       	sub	r9,-1
800038f2:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038f4:	e0 49 01 ff 	cp.w	r9,511
800038f8:	e0 88 00 16 	brls	80003924 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
800038fc:	30 09       	mov	r9,0
800038fe:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003900:	fe f6 06 18 	ld.w	r6,pc[1560]
80003904:	6c 0c       	ld.w	r12,r6[0x0]
80003906:	f0 1f 01 90 	mcall	80003f44 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000390a:	fe f8 06 06 	ld.w	r8,pc[1542]
8000390e:	70 0c       	ld.w	r12,r8[0x0]
80003910:	f0 1f 01 7a 	mcall	80003ef8 <phy_rx_func+0xe98>
80003914:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003916:	c0 71       	brne	80003924 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80003918:	30 09       	mov	r9,0
8000391a:	fe f8 06 02 	ld.w	r8,pc[1538]
8000391e:	91 09       	st.w	r8[0x0],r9
80003920:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003924:	fe f9 06 00 	ld.w	r9,pc[1536]
80003928:	72 08       	ld.w	r8,r9[0x0]
8000392a:	20 18       	sub	r8,1
8000392c:	93 08       	st.w	r9[0x0],r8
8000392e:	c0 71       	brne	8000393c <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
80003930:	30 09       	mov	r9,0
80003932:	fe f8 05 ea 	ld.w	r8,pc[1514]
80003936:	91 09       	st.w	r8[0x0],r9
80003938:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
8000393c:	fe f8 06 00 	ld.w	r8,pc[1536]
80003940:	fe f9 05 d8 	ld.w	r9,pc[1496]
80003944:	72 0a       	ld.w	r10,r9[0x0]
80003946:	70 09       	ld.w	r9,r8[0x0]
80003948:	ef 3b 00 0e 	ld.ub	r11,r7[14]
8000394c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003950:	70 09       	ld.w	r9,r8[0x0]
80003952:	2f f9       	sub	r9,-1
80003954:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003956:	e0 49 01 ff 	cp.w	r9,511
8000395a:	e0 88 00 16 	brls	80003986 <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
8000395e:	30 09       	mov	r9,0
80003960:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003962:	fe f6 05 b6 	ld.w	r6,pc[1462]
80003966:	6c 0c       	ld.w	r12,r6[0x0]
80003968:	f0 1f 01 77 	mcall	80003f44 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000396c:	fe f8 05 a4 	ld.w	r8,pc[1444]
80003970:	70 0c       	ld.w	r12,r8[0x0]
80003972:	f0 1f 01 62 	mcall	80003ef8 <phy_rx_func+0xe98>
80003976:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003978:	c0 71       	brne	80003986 <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
8000397a:	30 09       	mov	r9,0
8000397c:	fe f8 05 a0 	ld.w	r8,pc[1440]
80003980:	91 09       	st.w	r8[0x0],r9
80003982:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003986:	fe f9 05 9e 	ld.w	r9,pc[1438]
8000398a:	72 08       	ld.w	r8,r9[0x0]
8000398c:	20 18       	sub	r8,1
8000398e:	93 08       	st.w	r9[0x0],r8
80003990:	c0 71       	brne	8000399e <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
80003992:	30 09       	mov	r9,0
80003994:	fe f8 05 88 	ld.w	r8,pc[1416]
80003998:	91 09       	st.w	r8[0x0],r9
8000399a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
8000399e:	fe f8 05 9e 	ld.w	r8,pc[1438]
800039a2:	fe f9 05 76 	ld.w	r9,pc[1398]
800039a6:	72 0a       	ld.w	r10,r9[0x0]
800039a8:	70 09       	ld.w	r9,r8[0x0]
800039aa:	ef 3b 00 0f 	ld.ub	r11,r7[15]
800039ae:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800039b2:	70 09       	ld.w	r9,r8[0x0]
800039b4:	2f f9       	sub	r9,-1
800039b6:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039b8:	e0 49 01 ff 	cp.w	r9,511
800039bc:	e0 88 00 16 	brls	800039e8 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
800039c0:	30 09       	mov	r9,0
800039c2:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800039c4:	fe f7 05 54 	ld.w	r7,pc[1364]
800039c8:	6e 0c       	ld.w	r12,r7[0x0]
800039ca:	f0 1f 01 5f 	mcall	80003f44 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800039ce:	fe f8 05 42 	ld.w	r8,pc[1346]
800039d2:	70 0c       	ld.w	r12,r8[0x0]
800039d4:	f0 1f 01 49 	mcall	80003ef8 <phy_rx_func+0xe98>
800039d8:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
800039da:	c0 71       	brne	800039e8 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
800039dc:	30 09       	mov	r9,0
800039de:	fe f8 05 3e 	ld.w	r8,pc[1342]
800039e2:	91 09       	st.w	r8[0x0],r9
800039e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800039e8:	fe f9 05 3c 	ld.w	r9,pc[1340]
800039ec:	72 08       	ld.w	r8,r9[0x0]
800039ee:	20 18       	sub	r8,1
800039f0:	93 08       	st.w	r9[0x0],r8
800039f2:	e0 81 02 74 	brne	80003eda <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
800039f6:	30 09       	mov	r9,0
800039f8:	fe f8 05 24 	ld.w	r8,pc[1316]
800039fc:	91 09       	st.w	r8[0x0],r9
800039fe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003a02:	30 09       	mov	r9,0
80003a04:	fe f8 05 18 	ld.w	r8,pc[1304]
80003a08:	91 09       	st.w	r8[0x0],r9
80003a0a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003a0e:	fe f8 05 26 	ld.w	r8,pc[1318]
80003a12:	11 89       	ld.ub	r9,r8[0x0]
80003a14:	3f 28       	mov	r8,-14
80003a16:	f0 09 18 00 	cp.b	r9,r8
80003a1a:	c4 31       	brne	80003aa0 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003a1c:	8e 49       	ld.sh	r9,r7[0x8]
80003a1e:	fe f8 05 56 	ld.w	r8,pc[1366]
80003a22:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003a24:	fe f8 05 18 	ld.w	r8,pc[1304]
80003a28:	fe f9 04 f0 	ld.w	r9,pc[1264]
80003a2c:	72 0a       	ld.w	r10,r9[0x0]
80003a2e:	70 09       	ld.w	r9,r8[0x0]
80003a30:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003a34:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003a38:	70 09       	ld.w	r9,r8[0x0]
80003a3a:	2f f9       	sub	r9,-1
80003a3c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a3e:	e0 49 01 ff 	cp.w	r9,511
80003a42:	e0 88 00 16 	brls	80003a6e <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003a46:	30 09       	mov	r9,0
80003a48:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003a4a:	fe f7 04 ce 	ld.w	r7,pc[1230]
80003a4e:	6e 0c       	ld.w	r12,r7[0x0]
80003a50:	f0 1f 01 3d 	mcall	80003f44 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003a54:	fe f8 04 bc 	ld.w	r8,pc[1212]
80003a58:	70 0c       	ld.w	r12,r8[0x0]
80003a5a:	f0 1f 01 28 	mcall	80003ef8 <phy_rx_func+0xe98>
80003a5e:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003a60:	c0 71       	brne	80003a6e <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
80003a62:	30 09       	mov	r9,0
80003a64:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003a68:	91 09       	st.w	r8[0x0],r9
80003a6a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003a6e:	fe f9 04 b6 	ld.w	r9,pc[1206]
80003a72:	72 08       	ld.w	r8,r9[0x0]
80003a74:	20 18       	sub	r8,1
80003a76:	93 08       	st.w	r9[0x0],r8
80003a78:	c0 71       	brne	80003a86 <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
80003a7a:	30 09       	mov	r9,0
80003a7c:	fe f8 04 a0 	ld.w	r8,pc[1184]
80003a80:	91 09       	st.w	r8[0x0],r9
80003a82:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003a86:	20 18       	sub	r8,1
80003a88:	fe f9 04 9c 	ld.w	r9,pc[1180]
80003a8c:	93 08       	st.w	r9[0x0],r8
80003a8e:	58 08       	cp.w	r8,0
80003a90:	e0 81 02 25 	brne	80003eda <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80003a94:	30 09       	mov	r9,0
80003a96:	fe f8 04 86 	ld.w	r8,pc[1158]
80003a9a:	91 09       	st.w	r8[0x0],r9
80003a9c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003aa0:	fe f8 04 94 	ld.w	r8,pc[1172]
80003aa4:	11 89       	ld.ub	r9,r8[0x0]
80003aa6:	3f 38       	mov	r8,-13
80003aa8:	f0 09 18 00 	cp.b	r9,r8
80003aac:	e0 81 01 0c 	brne	80003cc4 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003ab0:	8e 49       	ld.sh	r9,r7[0x8]
80003ab2:	fe f8 04 c2 	ld.w	r8,pc[1218]
80003ab6:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003ab8:	8e 59       	ld.sh	r9,r7[0xa]
80003aba:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003abc:	8e 69       	ld.sh	r9,r7[0xc]
80003abe:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003ac0:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003ac4:	fe f9 04 54 	ld.w	r9,pc[1108]
80003ac8:	72 0a       	ld.w	r10,r9[0x0]
80003aca:	70 09       	ld.w	r9,r8[0x0]
80003acc:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003ad0:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003ad4:	70 09       	ld.w	r9,r8[0x0]
80003ad6:	2f f9       	sub	r9,-1
80003ad8:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ada:	e0 49 01 ff 	cp.w	r9,511
80003ade:	e0 88 00 16 	brls	80003b0a <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
80003ae2:	30 09       	mov	r9,0
80003ae4:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003ae6:	fe f6 04 32 	ld.w	r6,pc[1074]
80003aea:	6c 0c       	ld.w	r12,r6[0x0]
80003aec:	f0 1f 01 16 	mcall	80003f44 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003af0:	fe f8 04 20 	ld.w	r8,pc[1056]
80003af4:	70 0c       	ld.w	r12,r8[0x0]
80003af6:	f0 1f 01 01 	mcall	80003ef8 <phy_rx_func+0xe98>
80003afa:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003afc:	c0 71       	brne	80003b0a <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
80003afe:	30 09       	mov	r9,0
80003b00:	fe f8 04 1c 	ld.w	r8,pc[1052]
80003b04:	91 09       	st.w	r8[0x0],r9
80003b06:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003b0a:	fe f9 04 1a 	ld.w	r9,pc[1050]
80003b0e:	72 08       	ld.w	r8,r9[0x0]
80003b10:	20 18       	sub	r8,1
80003b12:	93 08       	st.w	r9[0x0],r8
80003b14:	c0 71       	brne	80003b22 <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
80003b16:	30 09       	mov	r9,0
80003b18:	fe f8 04 04 	ld.w	r8,pc[1028]
80003b1c:	91 09       	st.w	r8[0x0],r9
80003b1e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80003b22:	fe f8 04 1a 	ld.w	r8,pc[1050]
80003b26:	fe f9 03 f2 	ld.w	r9,pc[1010]
80003b2a:	72 0a       	ld.w	r10,r9[0x0]
80003b2c:	70 09       	ld.w	r9,r8[0x0]
80003b2e:	ef 3b 00 09 	ld.ub	r11,r7[9]
80003b32:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003b36:	70 09       	ld.w	r9,r8[0x0]
80003b38:	2f f9       	sub	r9,-1
80003b3a:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b3c:	e0 49 01 ff 	cp.w	r9,511
80003b40:	e0 88 00 16 	brls	80003b6c <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
80003b44:	30 09       	mov	r9,0
80003b46:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003b48:	fe f6 03 d0 	ld.w	r6,pc[976]
80003b4c:	6c 0c       	ld.w	r12,r6[0x0]
80003b4e:	f0 1f 00 fe 	mcall	80003f44 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003b52:	fe f8 03 be 	ld.w	r8,pc[958]
80003b56:	70 0c       	ld.w	r12,r8[0x0]
80003b58:	f0 1f 00 e8 	mcall	80003ef8 <phy_rx_func+0xe98>
80003b5c:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003b5e:	c0 71       	brne	80003b6c <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
80003b60:	30 09       	mov	r9,0
80003b62:	fe f8 03 ba 	ld.w	r8,pc[954]
80003b66:	91 09       	st.w	r8[0x0],r9
80003b68:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003b6c:	fe f9 03 b8 	ld.w	r9,pc[952]
80003b70:	72 08       	ld.w	r8,r9[0x0]
80003b72:	20 18       	sub	r8,1
80003b74:	93 08       	st.w	r9[0x0],r8
80003b76:	c0 71       	brne	80003b84 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80003b78:	30 09       	mov	r9,0
80003b7a:	fe f8 03 a2 	ld.w	r8,pc[930]
80003b7e:	91 09       	st.w	r8[0x0],r9
80003b80:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003b84:	fe f8 03 b8 	ld.w	r8,pc[952]
80003b88:	fe f9 03 90 	ld.w	r9,pc[912]
80003b8c:	72 0a       	ld.w	r10,r9[0x0]
80003b8e:	70 09       	ld.w	r9,r8[0x0]
80003b90:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003b94:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003b98:	70 09       	ld.w	r9,r8[0x0]
80003b9a:	2f f9       	sub	r9,-1
80003b9c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b9e:	e0 49 01 ff 	cp.w	r9,511
80003ba2:	e0 88 00 16 	brls	80003bce <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003ba6:	30 09       	mov	r9,0
80003ba8:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003baa:	fe f6 03 6e 	ld.w	r6,pc[878]
80003bae:	6c 0c       	ld.w	r12,r6[0x0]
80003bb0:	f0 1f 00 e5 	mcall	80003f44 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003bb4:	fe f8 03 5c 	ld.w	r8,pc[860]
80003bb8:	70 0c       	ld.w	r12,r8[0x0]
80003bba:	f0 1f 00 d0 	mcall	80003ef8 <phy_rx_func+0xe98>
80003bbe:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003bc0:	c0 71       	brne	80003bce <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
80003bc2:	30 09       	mov	r9,0
80003bc4:	fe f8 03 58 	ld.w	r8,pc[856]
80003bc8:	91 09       	st.w	r8[0x0],r9
80003bca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003bce:	fe f9 03 56 	ld.w	r9,pc[854]
80003bd2:	72 08       	ld.w	r8,r9[0x0]
80003bd4:	20 18       	sub	r8,1
80003bd6:	93 08       	st.w	r9[0x0],r8
80003bd8:	c0 71       	brne	80003be6 <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
80003bda:	30 09       	mov	r9,0
80003bdc:	fe f8 03 40 	ld.w	r8,pc[832]
80003be0:	91 09       	st.w	r8[0x0],r9
80003be2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003be6:	fe f8 03 56 	ld.w	r8,pc[854]
80003bea:	fe f9 03 2e 	ld.w	r9,pc[814]
80003bee:	72 0a       	ld.w	r10,r9[0x0]
80003bf0:	70 09       	ld.w	r9,r8[0x0]
80003bf2:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003bf6:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003bfa:	70 09       	ld.w	r9,r8[0x0]
80003bfc:	2f f9       	sub	r9,-1
80003bfe:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c00:	e0 49 01 ff 	cp.w	r9,511
80003c04:	e0 88 00 16 	brls	80003c30 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003c08:	30 09       	mov	r9,0
80003c0a:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003c0c:	fe f6 03 0c 	ld.w	r6,pc[780]
80003c10:	6c 0c       	ld.w	r12,r6[0x0]
80003c12:	f0 1f 00 cd 	mcall	80003f44 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003c16:	fe f8 02 fa 	ld.w	r8,pc[762]
80003c1a:	70 0c       	ld.w	r12,r8[0x0]
80003c1c:	f0 1f 00 b7 	mcall	80003ef8 <phy_rx_func+0xe98>
80003c20:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003c22:	c0 71       	brne	80003c30 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
80003c24:	30 09       	mov	r9,0
80003c26:	fe f8 02 f6 	ld.w	r8,pc[758]
80003c2a:	91 09       	st.w	r8[0x0],r9
80003c2c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003c30:	fe f9 02 f4 	ld.w	r9,pc[756]
80003c34:	72 08       	ld.w	r8,r9[0x0]
80003c36:	20 18       	sub	r8,1
80003c38:	93 08       	st.w	r9[0x0],r8
80003c3a:	c0 71       	brne	80003c48 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
80003c3c:	30 09       	mov	r9,0
80003c3e:	fe f8 02 de 	ld.w	r8,pc[734]
80003c42:	91 09       	st.w	r8[0x0],r9
80003c44:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003c48:	fe f8 02 f4 	ld.w	r8,pc[756]
80003c4c:	fe f9 02 cc 	ld.w	r9,pc[716]
80003c50:	72 0a       	ld.w	r10,r9[0x0]
80003c52:	70 09       	ld.w	r9,r8[0x0]
80003c54:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003c58:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003c5c:	70 09       	ld.w	r9,r8[0x0]
80003c5e:	2f f9       	sub	r9,-1
80003c60:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c62:	e0 49 01 ff 	cp.w	r9,511
80003c66:	e0 88 00 16 	brls	80003c92 <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
80003c6a:	30 09       	mov	r9,0
80003c6c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003c6e:	fe f7 02 aa 	ld.w	r7,pc[682]
80003c72:	6e 0c       	ld.w	r12,r7[0x0]
80003c74:	f0 1f 00 b4 	mcall	80003f44 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003c78:	fe f8 02 98 	ld.w	r8,pc[664]
80003c7c:	70 0c       	ld.w	r12,r8[0x0]
80003c7e:	f0 1f 00 9f 	mcall	80003ef8 <phy_rx_func+0xe98>
80003c82:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003c84:	c0 71       	brne	80003c92 <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80003c86:	30 09       	mov	r9,0
80003c88:	fe f8 02 94 	ld.w	r8,pc[660]
80003c8c:	91 09       	st.w	r8[0x0],r9
80003c8e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003c92:	fe f9 02 92 	ld.w	r9,pc[658]
80003c96:	72 08       	ld.w	r8,r9[0x0]
80003c98:	20 18       	sub	r8,1
80003c9a:	93 08       	st.w	r9[0x0],r8
80003c9c:	c0 71       	brne	80003caa <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003c9e:	30 09       	mov	r9,0
80003ca0:	fe f8 02 7c 	ld.w	r8,pc[636]
80003ca4:	91 09       	st.w	r8[0x0],r9
80003ca6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003caa:	20 18       	sub	r8,1
80003cac:	fe f9 02 78 	ld.w	r9,pc[632]
80003cb0:	93 08       	st.w	r9[0x0],r8
80003cb2:	58 08       	cp.w	r8,0
80003cb4:	e0 81 01 13 	brne	80003eda <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003cb8:	30 09       	mov	r9,0
80003cba:	fe f8 02 62 	ld.w	r8,pc[610]
80003cbe:	91 09       	st.w	r8[0x0],r9
80003cc0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003cc4:	fe f8 02 70 	ld.w	r8,pc[624]
80003cc8:	11 89       	ld.ub	r9,r8[0x0]
80003cca:	30 48       	mov	r8,4
80003ccc:	f0 09 18 00 	cp.b	r9,r8
80003cd0:	c0 80       	breq	80003ce0 <phy_rx_func+0xc80>
80003cd2:	fe f8 02 62 	ld.w	r8,pc[610]
80003cd6:	11 89       	ld.ub	r9,r8[0x0]
80003cd8:	30 38       	mov	r8,3
80003cda:	f0 09 18 00 	cp.b	r9,r8
80003cde:	c1 41       	brne	80003d06 <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003ce0:	6e 29       	ld.w	r9,r7[0x8]
80003ce2:	fe f8 02 7a 	ld.w	r8,pc[634]
80003ce6:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003ce8:	6e 39       	ld.w	r9,r7[0xc]
80003cea:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003cec:	fe f9 02 38 	ld.w	r9,pc[568]
80003cf0:	72 08       	ld.w	r8,r9[0x0]
80003cf2:	20 88       	sub	r8,8
80003cf4:	93 08       	st.w	r9[0x0],r8
80003cf6:	e0 81 00 f2 	brne	80003eda <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003cfa:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003cfc:	fe f9 02 20 	ld.w	r9,pc[544]
80003d00:	93 08       	st.w	r9[0x0],r8
80003d02:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003d06:	fe f8 02 2e 	ld.w	r8,pc[558]
80003d0a:	11 89       	ld.ub	r9,r8[0x0]
80003d0c:	31 38       	mov	r8,19
80003d0e:	f0 09 18 00 	cp.b	r9,r8
80003d12:	e0 81 00 9c 	brne	80003e4a <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80003d16:	fe f8 02 62 	ld.w	r8,pc[610]
80003d1a:	11 88       	ld.ub	r8,r8[0x0]
80003d1c:	30 c9       	mov	r9,12
80003d1e:	f2 08 18 00 	cp.b	r8,r9
80003d22:	e0 81 00 7b 	brne	80003e18 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003d26:	8e 49       	ld.sh	r9,r7[0x8]
80003d28:	fe f8 02 54 	ld.w	r8,pc[596]
80003d2c:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003d30:	30 09       	mov	r9,0
80003d32:	fe f8 02 46 	ld.w	r8,pc[582]
80003d36:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003d38:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003d3c:	3f 38       	mov	r8,-13
80003d3e:	f0 09 18 00 	cp.b	r9,r8
80003d42:	c6 61       	brne	80003e0e <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003d44:	10 99       	mov	r9,r8
80003d46:	4f c8       	lddpc	r8,80003f34 <phy_rx_func+0xed4>
80003d48:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003d4a:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003d4e:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003d52:	4f 58       	lddpc	r8,80003f24 <phy_rx_func+0xec4>
80003d54:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003d56:	30 19       	mov	r9,1
80003d58:	fe f8 02 0c 	ld.w	r8,pc[524]
80003d5c:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003d5e:	8e 79       	ld.sh	r9,r7[0xe]
80003d60:	fe f8 02 14 	ld.w	r8,pc[532]
80003d64:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003d66:	4f 68       	lddpc	r8,80003f3c <phy_rx_func+0xedc>
80003d68:	4e c9       	lddpc	r9,80003f18 <phy_rx_func+0xeb8>
80003d6a:	72 0a       	ld.w	r10,r9[0x0]
80003d6c:	70 09       	ld.w	r9,r8[0x0]
80003d6e:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003d72:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003d76:	70 09       	ld.w	r9,r8[0x0]
80003d78:	2f f9       	sub	r9,-1
80003d7a:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d7c:	e0 49 01 ff 	cp.w	r9,511
80003d80:	e0 88 00 13 	brls	80003da6 <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003d84:	30 09       	mov	r9,0
80003d86:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003d88:	4e 46       	lddpc	r6,80003f18 <phy_rx_func+0xeb8>
80003d8a:	6c 0c       	ld.w	r12,r6[0x0]
80003d8c:	f0 1f 00 6e 	mcall	80003f44 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003d90:	4e 08       	lddpc	r8,80003f10 <phy_rx_func+0xeb0>
80003d92:	70 0c       	ld.w	r12,r8[0x0]
80003d94:	f0 1f 00 59 	mcall	80003ef8 <phy_rx_func+0xe98>
80003d98:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003d9a:	c0 61       	brne	80003da6 <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003d9c:	30 09       	mov	r9,0
80003d9e:	4e 08       	lddpc	r8,80003f1c <phy_rx_func+0xebc>
80003da0:	91 09       	st.w	r8[0x0],r9
80003da2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003da6:	4e 09       	lddpc	r9,80003f24 <phy_rx_func+0xec4>
80003da8:	72 08       	ld.w	r8,r9[0x0]
80003daa:	20 18       	sub	r8,1
80003dac:	93 08       	st.w	r9[0x0],r8
80003dae:	c0 61       	brne	80003dba <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003db0:	30 09       	mov	r9,0
80003db2:	4d b8       	lddpc	r8,80003f1c <phy_rx_func+0xebc>
80003db4:	91 09       	st.w	r8[0x0],r9
80003db6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003dba:	4e 18       	lddpc	r8,80003f3c <phy_rx_func+0xedc>
80003dbc:	4d 79       	lddpc	r9,80003f18 <phy_rx_func+0xeb8>
80003dbe:	72 0a       	ld.w	r10,r9[0x0]
80003dc0:	70 09       	ld.w	r9,r8[0x0]
80003dc2:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003dc6:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003dca:	70 09       	ld.w	r9,r8[0x0]
80003dcc:	2f f9       	sub	r9,-1
80003dce:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003dd0:	e0 49 01 ff 	cp.w	r9,511
80003dd4:	e0 88 00 13 	brls	80003dfa <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003dd8:	30 09       	mov	r9,0
80003dda:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003ddc:	4c f7       	lddpc	r7,80003f18 <phy_rx_func+0xeb8>
80003dde:	6e 0c       	ld.w	r12,r7[0x0]
80003de0:	f0 1f 00 59 	mcall	80003f44 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003de4:	4c b8       	lddpc	r8,80003f10 <phy_rx_func+0xeb0>
80003de6:	70 0c       	ld.w	r12,r8[0x0]
80003de8:	f0 1f 00 44 	mcall	80003ef8 <phy_rx_func+0xe98>
80003dec:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003dee:	c0 61       	brne	80003dfa <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003df0:	30 09       	mov	r9,0
80003df2:	4c b8       	lddpc	r8,80003f1c <phy_rx_func+0xebc>
80003df4:	91 09       	st.w	r8[0x0],r9
80003df6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003dfa:	4c b9       	lddpc	r9,80003f24 <phy_rx_func+0xec4>
80003dfc:	72 08       	ld.w	r8,r9[0x0]
80003dfe:	20 18       	sub	r8,1
80003e00:	93 08       	st.w	r9[0x0],r8
80003e02:	c6 c1       	brne	80003eda <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003e04:	30 09       	mov	r9,0
80003e06:	4c 68       	lddpc	r8,80003f1c <phy_rx_func+0xebc>
80003e08:	91 09       	st.w	r8[0x0],r9
80003e0a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003e0e:	30 09       	mov	r9,0
80003e10:	4c 38       	lddpc	r8,80003f1c <phy_rx_func+0xebc>
80003e12:	91 09       	st.w	r8[0x0],r9
80003e14:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003e18:	8e 4a       	ld.sh	r10,r7[0x8]
80003e1a:	4d 99       	lddpc	r9,80003f7c <phy_rx_func+0xf1c>
80003e1c:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003e20:	4d 6a       	lddpc	r10,80003f78 <phy_rx_func+0xf18>
80003e22:	15 88       	ld.ub	r8,r10[0x0]
80003e24:	f0 cb ff ff 	sub	r11,r8,-1
80003e28:	8e 5c       	ld.sh	r12,r7[0xa]
80003e2a:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003e2e:	f0 cb ff fe 	sub	r11,r8,-2
80003e32:	8e 6c       	ld.sh	r12,r7[0xc]
80003e34:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003e38:	f0 cb ff fd 	sub	r11,r8,-3
80003e3c:	8e 7c       	ld.sh	r12,r7[0xe]
80003e3e:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003e42:	2f c8       	sub	r8,-4
80003e44:	b4 88       	st.b	r10[0x0],r8
80003e46:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003e4a:	30 09       	mov	r9,0
80003e4c:	4b 48       	lddpc	r8,80003f1c <phy_rx_func+0xebc>
80003e4e:	91 09       	st.w	r8[0x0],r9
80003e50:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003e54:	4c 08       	lddpc	r8,80003f54 <phy_rx_func+0xef4>
80003e56:	70 09       	ld.w	r9,r8[0x0]
80003e58:	8e 4b       	ld.sh	r11,r7[0x8]
80003e5a:	4c 0a       	lddpc	r10,80003f58 <phy_rx_func+0xef8>
80003e5c:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003e60:	2f f9       	sub	r9,-1
80003e62:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003e64:	4b 58       	lddpc	r8,80003f38 <phy_rx_func+0xed8>
80003e66:	70 09       	ld.w	r9,r8[0x0]
80003e68:	20 29       	sub	r9,2
80003e6a:	91 09       	st.w	r8[0x0],r9
80003e6c:	70 08       	ld.w	r8,r8[0x0]
80003e6e:	58 08       	cp.w	r8,0
80003e70:	c2 f1       	brne	80003ece <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003e72:	30 09       	mov	r9,0
80003e74:	4b 88       	lddpc	r8,80003f54 <phy_rx_func+0xef4>
80003e76:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003e78:	8e 59       	ld.sh	r9,r7[0xa]
80003e7a:	fe 78 82 12 	mov	r8,-32238
80003e7e:	f0 09 19 00 	cp.h	r9,r8
80003e82:	c2 11       	brne	80003ec4 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003e84:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003e88:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003e8c:	4a f8       	lddpc	r8,80003f48 <phy_rx_func+0xee8>
80003e8e:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003e90:	8e 59       	ld.sh	r9,r7[0xa]
80003e92:	4a f8       	lddpc	r8,80003f4c <phy_rx_func+0xeec>
80003e94:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003e96:	8e 69       	ld.sh	r9,r7[0xc]
80003e98:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003e9a:	f0 1f 00 2e 	mcall	80003f50 <phy_rx_func+0xef0>
80003e9e:	4a 18       	lddpc	r8,80003f20 <phy_rx_func+0xec0>
80003ea0:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003ea2:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003ea6:	31 38       	mov	r8,19
80003ea8:	f0 09 18 00 	cp.b	r9,r8
80003eac:	c0 71       	brne	80003eba <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003eae:	10 99       	mov	r9,r8
80003eb0:	4a 18       	lddpc	r8,80003f34 <phy_rx_func+0xed4>
80003eb2:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003eb4:	30 09       	mov	r9,0
80003eb6:	49 c8       	lddpc	r8,80003f24 <phy_rx_func+0xec4>
80003eb8:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003eba:	30 49       	mov	r9,4
80003ebc:	49 88       	lddpc	r8,80003f1c <phy_rx_func+0xebc>
80003ebe:	91 09       	st.w	r8[0x0],r9
80003ec0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003ec4:	30 09       	mov	r9,0
80003ec6:	49 68       	lddpc	r8,80003f1c <phy_rx_func+0xebc>
80003ec8:	91 09       	st.w	r8[0x0],r9
80003eca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003ece:	4a dc       	lddpc	r12,80003f80 <phy_rx_func+0xf20>
80003ed0:	f0 1f 00 18 	mcall	80003f30 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003ed4:	30 09       	mov	r9,0
80003ed6:	49 28       	lddpc	r8,80003f1c <phy_rx_func+0xebc>
80003ed8:	91 09       	st.w	r8[0x0],r9
80003eda:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003ede:	00 00       	add	r0,r0
80003ee0:	00 00       	add	r0,r0
80003ee2:	0a c4       	st.b	r5++,r4
80003ee4:	00 00       	add	r0,r0
80003ee6:	0a d0       	st.w	--r5,r0
80003ee8:	00 00       	add	r0,r0
80003eea:	0a b4       	st.h	r5++,r4
80003eec:	00 00       	add	r0,r0
80003eee:	0a 8c       	andn	r12,r5
80003ef0:	00 00       	add	r0,r0
80003ef2:	0a 7c       	tst	r12,r5
80003ef4:	00 00       	add	r0,r0
80003ef6:	0a a8       	st.w	r5++,r8
80003ef8:	80 00       	ld.sh	r0,r0[0x0]
80003efa:	2a c0       	sub	r0,-84
80003efc:	00 00       	add	r0,r0
80003efe:	0a d4       	st.w	--r5,r4
80003f00:	80 00       	ld.sh	r0,r0[0x0]
80003f02:	29 f0       	sub	r0,-97
80003f04:	00 00       	add	r0,r0
80003f06:	0a bc       	st.h	r5++,r12
80003f08:	80 00       	ld.sh	r0,r0[0x0]
80003f0a:	2a 0c       	sub	r12,-96
80003f0c:	00 00       	add	r0,r0
80003f0e:	0a 99       	mov	r9,r5
80003f10:	00 00       	add	r0,r0
80003f12:	0a b0       	st.h	r5++,r0
80003f14:	00 00       	add	r0,r0
80003f16:	0a c8       	st.b	r5++,r8
80003f18:	00 00       	add	r0,r0
80003f1a:	0a e4       	st.h	--r5,r4
80003f1c:	00 00       	add	r0,r0
80003f1e:	0a a4       	st.w	r5++,r4
80003f20:	00 00       	add	r0,r0
80003f22:	0a dc       	st.w	--r5,r12
80003f24:	00 00       	add	r0,r0
80003f26:	0a 88       	andn	r8,r5
80003f28:	00 00       	add	r0,r0
80003f2a:	0a 58       	eor	r8,r5
80003f2c:	80 00       	ld.sh	r0,r0[0x0]
80003f2e:	d1 a0       	acall	0x1a
80003f30:	80 00       	ld.sh	r0,r0[0x0]
80003f32:	6b 6c       	ld.w	r12,r5[0x58]
80003f34:	00 00       	add	r0,r0
80003f36:	0a 98       	mov	r8,r5
80003f38:	00 00       	add	r0,r0
80003f3a:	0a 78       	tst	r8,r5
80003f3c:	00 00       	add	r0,r0
80003f3e:	0a 90       	mov	r0,r5
80003f40:	80 00       	ld.sh	r0,r0[0x0]
80003f42:	73 bc       	ld.w	r12,r9[0x6c]
80003f44:	80 00       	ld.sh	r0,r0[0x0]
80003f46:	30 00       	mov	r0,0
80003f48:	00 00       	add	r0,r0
80003f4a:	0a 50       	eor	r0,r5
80003f4c:	00 00       	add	r0,r0
80003f4e:	1e a0       	st.w	pc++,r0
80003f50:	80 00       	ld.sh	r0,r0[0x0]
80003f52:	29 50       	sub	r0,-107
80003f54:	00 00       	add	r0,r0
80003f56:	0a c0       	st.b	r5++,r0
80003f58:	00 00       	add	r0,r0
80003f5a:	1d a4       	ld.ub	r4,lr[0x2]
80003f5c:	00 00       	add	r0,r0
80003f5e:	0a 9c       	mov	r12,r5
80003f60:	00 00       	add	r0,r0
80003f62:	0a 5b       	eor	r11,r5
80003f64:	00 00       	add	r0,r0
80003f66:	0a 49       	or	r9,r5
80003f68:	00 00       	add	r0,r0
80003f6a:	0a 70       	tst	r0,r5
80003f6c:	00 00       	add	r0,r0
80003f6e:	0a ac       	st.w	r5++,r12
80003f70:	00 00       	add	r0,r0
80003f72:	0a 5c       	eor	r12,r5
80003f74:	00 00       	add	r0,r0
80003f76:	1d 9c       	ld.ub	r12,lr[0x1]
80003f78:	00 00       	add	r0,r0
80003f7a:	0a cc       	st.b	r5++,r12
80003f7c:	00 00       	add	r0,r0
80003f7e:	1e a4       	st.w	pc++,r4
80003f80:	80 00       	ld.sh	r0,r0[0x0]
80003f82:	d1 b8       	*unknown*

80003f84 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003f84:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003f86:	49 88       	lddpc	r8,80003fe4 <pdca_int_handler+0x60>
80003f88:	11 89       	ld.ub	r9,r8[0x0]
80003f8a:	ec 19 00 01 	eorl	r9,0x1
80003f8e:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003f90:	11 89       	ld.ub	r9,r8[0x0]
80003f92:	a5 69       	lsl	r9,0x4
80003f94:	2f c9       	sub	r9,-4
80003f96:	49 5a       	lddpc	r10,80003fe8 <pdca_int_handler+0x64>
80003f98:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003f9a:	fe 7a 00 40 	mov	r10,-65472
80003f9e:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003fa0:	30 39       	mov	r9,3
80003fa2:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003fa4:	11 8a       	ld.ub	r10,r8[0x0]
80003fa6:	a5 6a       	lsl	r10,0x4
80003fa8:	2f ca       	sub	r10,-4
80003faa:	49 18       	lddpc	r8,80003fec <pdca_int_handler+0x68>
80003fac:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003fae:	fe 78 00 00 	mov	r8,-65536
80003fb2:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003fb4:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003fb6:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003fb8:	48 e8       	lddpc	r8,80003ff0 <pdca_int_handler+0x6c>
80003fba:	70 08       	ld.w	r8,r8[0x0]
80003fbc:	58 08       	cp.w	r8,0
80003fbe:	c0 70       	breq	80003fcc <pdca_int_handler+0x48>
80003fc0:	48 99       	lddpc	r9,80003fe4 <pdca_int_handler+0x60>
80003fc2:	13 89       	ld.ub	r9,r9[0x0]
80003fc4:	a5 69       	lsl	r9,0x4
80003fc6:	48 ac       	lddpc	r12,80003fec <pdca_int_handler+0x68>
80003fc8:	12 0c       	add	r12,r9
80003fca:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003fcc:	48 a8       	lddpc	r8,80003ff4 <pdca_int_handler+0x70>
80003fce:	70 08       	ld.w	r8,r8[0x0]
80003fd0:	58 08       	cp.w	r8,0
80003fd2:	c0 70       	breq	80003fe0 <pdca_int_handler+0x5c>
80003fd4:	48 49       	lddpc	r9,80003fe4 <pdca_int_handler+0x60>
80003fd6:	13 89       	ld.ub	r9,r9[0x0]
80003fd8:	a5 69       	lsl	r9,0x4
80003fda:	48 4c       	lddpc	r12,80003fe8 <pdca_int_handler+0x64>
80003fdc:	12 0c       	add	r12,r9
80003fde:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003fe0:	d4 02       	popm	lr
80003fe2:	d6 03       	rete
80003fe4:	00 00       	add	r0,r0
80003fe6:	50 c4       	stdsp	sp[0x30],r4
80003fe8:	00 00       	add	r0,r0
80003fea:	50 ec       	stdsp	sp[0x38],r12
80003fec:	00 00       	add	r0,r0
80003fee:	50 cc       	stdsp	sp[0x30],r12
80003ff0:	00 00       	add	r0,r0
80003ff2:	0a f0       	st.b	--r5,r0
80003ff4:	00 00       	add	r0,r0
80003ff6:	0a f4       	st.b	--r5,r4

80003ff8 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003ff8:	fe 78 10 00 	mov	r8,-61440
80003ffc:	e0 69 0d c0 	mov	r9,3520
80004000:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80004004:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80004008:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
8000400c:	fe 78 34 00 	mov	r8,-52224
80004010:	e0 69 80 00 	mov	r9,32768
80004014:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80004016:	30 09       	mov	r9,0
80004018:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
8000401a:	e0 69 04 21 	mov	r9,1057
8000401e:	ea 19 3f 20 	orh	r9,0x3f20
80004022:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80004024:	e0 69 02 9f 	mov	r9,671
80004028:	ea 19 01 00 	orh	r9,0x100
8000402c:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
8000402e:	e0 6a 04 02 	mov	r10,1026
80004032:	ea 1a 3f 20 	orh	r10,0x3f20
80004036:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80004038:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
8000403a:	5e fc       	retal	r12

8000403c <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
8000403c:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
8000403e:	30 19       	mov	r9,1
80004040:	49 78       	lddpc	r8,8000409c <local_start_PDC+0x60>
80004042:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80004044:	fe 78 00 00 	mov	r8,-65536
80004048:	30 7b       	mov	r11,7
8000404a:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
8000404c:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
8000404e:	49 59       	lddpc	r9,800040a0 <local_start_PDC+0x64>
80004050:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80004054:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80004056:	30 3a       	mov	r10,3
80004058:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
8000405a:	30 1c       	mov	r12,1
8000405c:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
8000405e:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80004060:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004062:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004064:	30 2c       	mov	r12,2
80004066:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80004068:	48 f9       	lddpc	r9,800040a4 <local_start_PDC+0x68>
8000406a:	e0 68 5a 5a 	mov	r8,23130
8000406e:	ea 18 ab cd 	orh	r8,0xabcd
80004072:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80004074:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80004076:	30 0e       	mov	lr,0
80004078:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
8000407a:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
8000407c:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
8000407e:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80004080:	fe 78 00 40 	mov	r8,-65472
80004084:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80004086:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80004088:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
8000408c:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
8000408e:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80004090:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80004092:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80004094:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004096:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004098:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
8000409a:	d8 02       	popm	pc
8000409c:	00 00       	add	r0,r0
8000409e:	50 c4       	stdsp	sp[0x30],r4
800040a0:	00 00       	add	r0,r0
800040a2:	50 cc       	stdsp	sp[0x30],r12
800040a4:	00 00       	add	r0,r0
800040a6:	50 ec       	stdsp	sp[0x38],r12

800040a8 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
800040a8:	48 38       	lddpc	r8,800040b4 <register_rx_tx_func+0xc>
800040aa:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
800040ac:	48 38       	lddpc	r8,800040b8 <register_rx_tx_func+0x10>
800040ae:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
800040b0:	5e fc       	retal	r12
800040b2:	00 00       	add	r0,r0
800040b4:	00 00       	add	r0,r0
800040b6:	0a f0       	st.b	--r5,r0
800040b8:	00 00       	add	r0,r0
800040ba:	0a f4       	st.b	--r5,r4

800040bc <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
800040bc:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
800040be:	fe 78 10 00 	mov	r8,-61440
800040c2:	30 29       	mov	r9,2
800040c4:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
800040c8:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
800040cc:	10 99       	mov	r9,r8
800040ce:	f2 f8 01 60 	ld.w	r8,r9[352]
800040d2:	e2 18 00 02 	andl	r8,0x2,COH
800040d6:	cf c0       	breq	800040ce <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
800040d8:	fe 79 10 00 	mov	r9,-61440
800040dc:	f2 f8 01 60 	ld.w	r8,r9[352]
800040e0:	e2 18 00 02 	andl	r8,0x2,COH
800040e4:	cf c1       	brne	800040dc <ssc_init+0x20>
				
    INTC_register_interrupt (
800040e6:	30 3a       	mov	r10,3
800040e8:	36 0b       	mov	r11,96
800040ea:	48 bc       	lddpc	r12,80004114 <ssc_init+0x58>
800040ec:	f0 1f 00 0b 	mcall	80004118 <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
800040f0:	f0 1f 00 0b 	mcall	8000411c <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
800040f4:	f0 1f 00 0b 	mcall	80004120 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800040f8:	fe 79 00 00 	mov	r9,-65536
800040fc:	30 18       	mov	r8,1
800040fe:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004100:	fe 7a 00 40 	mov	r10,-65472
80004104:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80004106:	e0 6b 01 01 	mov	r11,257
8000410a:	fe 7a 34 00 	mov	r10,-52224
8000410e:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80004110:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80004112:	d8 02       	popm	pc
80004114:	80 00       	ld.sh	r0,r0[0x0]
80004116:	3f 84       	mov	r4,-8
80004118:	80 00       	ld.sh	r0,r0[0x0]
8000411a:	4f ac       	lddpc	r12,80004300 <xcmp_IdleTestTone+0x54>
8000411c:	80 00       	ld.sh	r0,r0[0x0]
8000411e:	3f f8       	mov	r8,-1
80004120:	80 00       	ld.sh	r0,r0[0x0]
80004122:	40 3c       	lddsp	r12,sp[0xc]

80004124 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80004124:	48 28       	lddpc	r8,8000412c <xcmp_register_app_list+0x8>
80004126:	91 0c       	st.w	r8[0x0],r12
}
80004128:	5e fc       	retal	r12
8000412a:	00 00       	add	r0,r0
8000412c:	00 00       	add	r0,r0
8000412e:	51 0c       	stdsp	sp[0x40],r12

80004130 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80004130:	eb cd 40 80 	pushm	r7,lr
80004134:	fa cd 01 00 	sub	sp,sp,256
80004138:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
8000413a:	16 98       	mov	r8,r11
8000413c:	2f 08       	sub	r8,-16
8000413e:	af a8       	sbr	r8,0xe
80004140:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80004142:	3f f8       	mov	r8,-1
80004144:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80004146:	30 b9       	mov	r9,11
80004148:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
8000414a:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
8000414c:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
8000414e:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004150:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80004152:	f6 ca ff fe 	sub	r10,r11,-2
80004156:	18 9b       	mov	r11,r12
80004158:	fa cc ff f0 	sub	r12,sp,-16
8000415c:	f0 1f 00 05 	mcall	80004170 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80004160:	2f e7       	sub	r7,-2
80004162:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80004164:	1a 9c       	mov	r12,sp
80004166:	f0 1f 00 04 	mcall	80004174 <xcmp_tx+0x44>
}
8000416a:	2c 0d       	sub	sp,-256
8000416c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004170:	80 00       	ld.sh	r0,r0[0x0]
80004172:	72 74       	ld.w	r4,r9[0x1c]
80004174:	80 00       	ld.sh	r0,r0[0x0]
80004176:	47 38       	lddsp	r8,sp[0x1cc]

80004178 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80004178:	eb cd 40 e0 	pushm	r5-r7,lr
8000417c:	fa cd 00 d0 	sub	sp,sp,208
80004180:	18 95       	mov	r5,r12
80004182:	16 96       	mov	r6,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 20)return -1;
80004184:	31 48       	mov	r8,20
80004186:	f0 0b 19 00 	cp.h	r11,r8
8000418a:	e0 8b 00 33 	brhi	800041f0 <xcmp_data_session_req+0x78>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
8000418e:	fa c7 ff f8 	sub	r7,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80004192:	e0 68 04 1d 	mov	r8,1053
80004196:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 20)return -1;
	
	ptr->Function = Single_Data_Uint;
80004198:	30 18       	mov	r8,1
8000419a:	ae 88       	st.b	r7[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
8000419c:	32 08       	mov	r8,32
8000419e:	ae 98       	st.b	r7[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
800041a0:	30 28       	mov	r8,2
800041a2:	ae a8       	st.b	r7[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
800041a4:	30 48       	mov	r8,4
800041a6:	ae b8       	st.b	r7[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
800041a8:	ea 1a 0c 00 	orh	r10,0xc00
800041ac:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
800041ae:	30 4a       	mov	r10,4
800041b0:	1a 9b       	mov	r11,sp
800041b2:	fa cc ff f4 	sub	r12,sp,-12
800041b6:	f0 1f 00 11 	mcall	800041f8 <xcmp_data_session_req+0x80>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
800041ba:	30 f8       	mov	r8,15
800041bc:	ef 68 00 08 	st.b	r7[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
800041c0:	3a 78       	mov	r8,-89
800041c2:	ef 68 00 09 	st.b	r7[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
800041c6:	30 08       	mov	r8,0
800041c8:	ef 68 00 0a 	st.b	r7[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
800041cc:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
800041d0:	f4 08 16 08 	lsr	r8,r10,0x8
800041d4:	ef 68 00 0b 	st.b	r7[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
800041d8:	ef 66 00 0c 	st.b	r7[12],r6
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
800041dc:	0a 9b       	mov	r11,r5
800041de:	fa cc ff eb 	sub	r12,sp,-21
800041e2:	f0 1f 00 06 	mcall	800041f8 <xcmp_data_session_req+0x80>
	
	xcmp_tx( &xcmp_farme, sizeof(DataSession_req_t) - 7);
800041e6:	31 ab       	mov	r11,26
800041e8:	fa cc ff fa 	sub	r12,sp,-6
800041ec:	f0 1f 00 04 	mcall	800041fc <xcmp_data_session_req+0x84>
}
800041f0:	2c cd       	sub	sp,-208
800041f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800041f6:	00 00       	add	r0,r0
800041f8:	80 00       	ld.sh	r0,r0[0x0]
800041fa:	72 74       	ld.w	r4,r9[0x1c]
800041fc:	80 00       	ld.sh	r0,r0[0x0]
800041fe:	41 30       	lddsp	r0,sp[0x4c]

80004200 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80004200:	d4 01       	pushm	lr
80004202:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80004206:	fe 78 b4 00 	mov	r8,-19456
8000420a:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
8000420c:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80004210:	30 89       	mov	r9,8
80004212:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80004214:	30 19       	mov	r9,1
80004216:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80004218:	30 09       	mov	r9,0
8000421a:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
8000421c:	30 5a       	mov	r10,5
8000421e:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80004220:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80004222:	30 7a       	mov	r10,7
80004224:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80004226:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80004228:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
8000422a:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
8000422e:	30 9b       	mov	r11,9
80004230:	fa cc ff fe 	sub	r12,sp,-2
80004234:	f0 1f 00 02 	mcall	8000423c <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80004238:	2c dd       	sub	sp,-204
8000423a:	d8 02       	popm	pc
8000423c:	80 00       	ld.sh	r0,r0[0x0]
8000423e:	41 30       	lddsp	r0,sp[0x4c]

80004240 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80004240:	d4 01       	pushm	lr
80004242:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80004246:	fe 78 80 00 	mov	r8,-32768
8000424a:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
8000424c:	30 38       	mov	r8,3
8000424e:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80004250:	30 1b       	mov	r11,1
80004252:	fa cc ff fe 	sub	r12,sp,-2
80004256:	f0 1f 00 03 	mcall	80004260 <xcmp_opcode_not_supported+0x20>
}
8000425a:	2c dd       	sub	sp,-204
8000425c:	d8 02       	popm	pc
8000425e:	00 00       	add	r0,r0
80004260:	80 00       	ld.sh	r0,r0[0x0]
80004262:	41 30       	lddsp	r0,sp[0x4c]

80004264 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004264:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80004266:	96 88       	ld.uh	r8,r11[0x0]
80004268:	e2 18 f0 00 	andl	r8,0xf000,COH
8000426c:	e0 48 80 00 	cp.w	r8,32768
80004270:	c0 f0       	breq	8000428e <xcmp_exec_func+0x2a>
80004272:	e0 48 b0 00 	cp.w	r8,45056
80004276:	c1 20       	breq	8000429a <xcmp_exec_func+0x36>
80004278:	58 08       	cp.w	r8,0
8000427a:	c1 51       	brne	800042a4 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
8000427c:	78 08       	ld.w	r8,r12[0x0]
8000427e:	58 08       	cp.w	r8,0
80004280:	c0 40       	breq	80004288 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80004282:	16 9c       	mov	r12,r11
80004284:	5d 18       	icall	r8
80004286:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004288:	f0 1f 00 08 	mcall	800042a8 <xcmp_exec_func+0x44>
8000428c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
8000428e:	78 18       	ld.w	r8,r12[0x4]
80004290:	58 08       	cp.w	r8,0
80004292:	c0 90       	breq	800042a4 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004294:	16 9c       	mov	r12,r11
80004296:	5d 18       	icall	r8
80004298:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
8000429a:	78 28       	ld.w	r8,r12[0x8]
8000429c:	58 08       	cp.w	r8,0
8000429e:	c0 30       	breq	800042a4 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
800042a0:	16 9c       	mov	r12,r11
800042a2:	5d 18       	icall	r8
800042a4:	d8 02       	popm	pc
800042a6:	00 00       	add	r0,r0
800042a8:	80 00       	ld.sh	r0,r0[0x0]
800042aa:	42 40       	lddsp	r0,sp[0x90]

800042ac <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
800042ac:	d4 01       	pushm	lr
800042ae:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
800042b2:	e0 68 04 09 	mov	r8,1033
800042b6:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
800042b8:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
800042bc:	30 19       	mov	r9,1
800042be:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
800042c0:	30 09       	mov	r9,0
800042c2:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
800042c4:	30 ca       	mov	r10,12
800042c6:	b0 aa       	st.b	r8[0x2],r10
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
800042c8:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
800042ca:	fb 69 00 08 	st.b	sp[8],r9
800042ce:	fa c8 ff f7 	sub	r8,sp,-9
800042d2:	b0 89       	st.b	r8[0x0],r9
800042d4:	fa c8 ff f6 	sub	r8,sp,-10
800042d8:	b0 89       	st.b	r8[0x0],r9
800042da:	fa c8 ff f5 	sub	r8,sp,-11
800042de:	b0 89       	st.b	r8[0x0],r9
800042e0:	fa c8 ff f4 	sub	r8,sp,-12
800042e4:	b0 89       	st.b	r8[0x0],r9
800042e6:	fa c8 ff f3 	sub	r8,sp,-13
800042ea:	b0 89       	st.b	r8[0x0],r9
800042ec:	fa c8 ff f2 	sub	r8,sp,-14
800042f0:	b0 89       	st.b	r8[0x0],r9
800042f2:	fa c8 ff f1 	sub	r8,sp,-15
800042f6:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
800042f8:	30 cb       	mov	r11,12
800042fa:	fa cc ff fe 	sub	r12,sp,-2
800042fe:	f0 1f 00 03 	mcall	80004308 <xcmp_IdleTestTone+0x5c>
}
80004302:	2c dd       	sub	sp,-204
80004304:	d8 02       	popm	pc
80004306:	00 00       	add	r0,r0
80004308:	80 00       	ld.sh	r0,r0[0x0]
8000430a:	41 30       	lddsp	r0,sp[0x4c]

8000430c <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
8000430c:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
8000430e:	48 dc       	lddpc	r12,80004340 <xcmp_init+0x34>
80004310:	f0 1f 00 0d 	mcall	80004344 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004314:	30 4b       	mov	r11,4
80004316:	31 4c       	mov	r12,20
80004318:	f0 1f 00 0c 	mcall	80004348 <xcmp_init+0x3c>
8000431c:	48 c8       	lddpc	r8,8000434c <xcmp_init+0x40>
8000431e:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80004320:	30 09       	mov	r9,0
80004322:	1a d9       	st.w	--sp,r9
80004324:	1a d9       	st.w	--sp,r9
80004326:	1a d9       	st.w	--sp,r9
80004328:	30 38       	mov	r8,3
8000432a:	e0 6a 01 80 	mov	r10,384
8000432e:	48 9b       	lddpc	r11,80004350 <xcmp_init+0x44>
80004330:	48 9c       	lddpc	r12,80004354 <xcmp_init+0x48>
80004332:	f0 1f 00 0a 	mcall	80004358 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80004336:	f0 1f 00 0a 	mcall	8000435c <xcmp_init+0x50>
8000433a:	2f dd       	sub	sp,-12
	
}
8000433c:	d8 02       	popm	pc
8000433e:	00 00       	add	r0,r0
80004340:	80 00       	ld.sh	r0,r0[0x0]
80004342:	44 5c       	lddsp	r12,sp[0x114]
80004344:	80 00       	ld.sh	r0,r0[0x0]
80004346:	44 a8       	lddsp	r8,sp[0x128]
80004348:	80 00       	ld.sh	r0,r0[0x0]
8000434a:	5f 48       	srge	r8
8000434c:	00 00       	add	r0,r0
8000434e:	0b 10       	ld.sh	r0,r5++
80004350:	80 00       	ld.sh	r0,r0[0x0]
80004352:	d1 e4       	*unknown*
80004354:	80 00       	ld.sh	r0,r0[0x0]
80004356:	43 60       	lddsp	r0,sp[0xd8]
80004358:	80 00       	ld.sh	r0,r0[0x0]
8000435a:	66 1c       	ld.w	r12,r3[0x4]
8000435c:	80 00       	ld.sh	r0,r0[0x0]
8000435e:	44 e0       	lddsp	r0,sp[0x138]

80004360 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004360:	d4 31       	pushm	r0-r7,lr
80004362:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004364:	4b 16       	lddpc	r6,80004428 <xcmp_rx_process+0xc8>
80004366:	30 05       	mov	r5,0
80004368:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
8000436a:	4b 13       	lddpc	r3,8000442c <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
8000436c:	4b 12       	lddpc	r2,80004430 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000436e:	4b 21       	lddpc	r1,80004434 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004370:	4b 20       	lddpc	r0,80004438 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004372:	6c 0c       	ld.w	r12,r6[0x0]
80004374:	0a 99       	mov	r9,r5
80004376:	08 9a       	mov	r10,r4
80004378:	1a 9b       	mov	r11,sp
8000437a:	f0 1f 00 31 	mcall	8000443c <xcmp_rx_process+0xdc>
8000437e:	58 1c       	cp.w	r12,1
80004380:	cf 91       	brne	80004372 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80004382:	40 0b       	lddsp	r11,sp[0x0]
80004384:	58 0b       	cp.w	r11,0
80004386:	cf 60       	breq	80004372 <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80004388:	96 0a       	ld.sh	r10,r11[0x0]
8000438a:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000438e:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80004392:	59 c8       	cp.w	r8,28
80004394:	c1 e0       	breq	800043d0 <xcmp_rx_process+0x70>
80004396:	e0 89 00 07 	brgt	800043a4 <xcmp_rx_process+0x44>
8000439a:	58 e8       	cp.w	r8,14
8000439c:	c0 e0       	breq	800043b8 <xcmp_rx_process+0x58>
8000439e:	58 f8       	cp.w	r8,15
800043a0:	c2 41       	brne	800043e8 <xcmp_rx_process+0x88>
800043a2:	c0 f8       	rjmp	800043c0 <xcmp_rx_process+0x60>
800043a4:	e0 48 01 09 	cp.w	r8,265
800043a8:	c1 80       	breq	800043d8 <xcmp_rx_process+0x78>
800043aa:	e0 48 01 0a 	cp.w	r8,266
800043ae:	c1 90       	breq	800043e0 <xcmp_rx_process+0x80>
800043b0:	e0 48 00 2c 	cp.w	r8,44
800043b4:	c1 a1       	brne	800043e8 <xcmp_rx_process+0x88>
800043b6:	c0 98       	rjmp	800043c8 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
800043b8:	4a 2c       	lddpc	r12,80004440 <xcmp_rx_process+0xe0>
800043ba:	f0 1f 00 23 	mcall	80004444 <xcmp_rx_process+0xe4>
					break;
800043be:	c2 f8       	rjmp	8000441c <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
800043c0:	4a 2c       	lddpc	r12,80004448 <xcmp_rx_process+0xe8>
800043c2:	f0 1f 00 21 	mcall	80004444 <xcmp_rx_process+0xe4>
					break;
800043c6:	c2 b8       	rjmp	8000441c <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
800043c8:	4a 1c       	lddpc	r12,8000444c <xcmp_rx_process+0xec>
800043ca:	f0 1f 00 1f 	mcall	80004444 <xcmp_rx_process+0xe4>
					break;
800043ce:	c2 78       	rjmp	8000441c <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800043d0:	04 9c       	mov	r12,r2
800043d2:	f0 1f 00 1d 	mcall	80004444 <xcmp_rx_process+0xe4>
						, ptr);
					break;
800043d6:	c2 38       	rjmp	8000441c <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800043d8:	02 9c       	mov	r12,r1
800043da:	f0 1f 00 1b 	mcall	80004444 <xcmp_rx_process+0xe4>
					break;
800043de:	c1 f8       	rjmp	8000441c <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800043e0:	00 9c       	mov	r12,r0
800043e2:	f0 1f 00 19 	mcall	80004444 <xcmp_rx_process+0xe4>
					break;
800043e6:	c1 b8       	rjmp	8000441c <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
800043e8:	12 98       	mov	r8,r9
800043ea:	e2 18 04 00 	andl	r8,0x400,COH
800043ee:	c0 70       	breq	800043fc <xcmp_rx_process+0x9c>
800043f0:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800043f4:	e0 48 00 68 	cp.w	r8,104
800043f8:	e0 8a 00 08 	brle	80004408 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
800043fc:	e2 19 f0 00 	andl	r9,0xf000,COH
80004400:	c0 e1       	brne	8000441c <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80004402:	f0 1f 00 14 	mcall	80004450 <xcmp_rx_process+0xf0>
80004406:	c0 b8       	rjmp	8000441c <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004408:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
8000440c:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80004410:	49 19       	lddpc	r9,80004454 <xcmp_rx_process+0xf4>
80004412:	72 08       	ld.w	r8,r9[0x0]
80004414:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004418:	f0 1f 00 0b 	mcall	80004444 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
8000441c:	66 0c       	ld.w	r12,r3[0x0]
8000441e:	40 0b       	lddsp	r11,sp[0x0]
80004420:	f0 1f 00 0e 	mcall	80004458 <xcmp_rx_process+0xf8>
80004424:	ca 7b       	rjmp	80004372 <xcmp_rx_process+0x12>
80004426:	00 00       	add	r0,r0
80004428:	00 00       	add	r0,r0
8000442a:	0b 10       	ld.sh	r0,r5++
8000442c:	00 00       	add	r0,r0
8000442e:	0a a8       	st.w	r5++,r8
80004430:	00 00       	add	r0,r0
80004432:	0b 20       	ld.uh	r0,r5++
80004434:	00 00       	add	r0,r0
80004436:	0b 14       	ld.sh	r4,r5++
80004438:	00 00       	add	r0,r0
8000443a:	0b 04       	ld.w	r4,r5++
8000443c:	80 00       	ld.sh	r0,r0[0x0]
8000443e:	5c 3c       	neg	r12
80004440:	00 00       	add	r0,r0
80004442:	0b 38       	ld.ub	r8,r5++
80004444:	80 00       	ld.sh	r0,r0[0x0]
80004446:	42 64       	lddsp	r4,sp[0x98]
80004448:	00 00       	add	r0,r0
8000444a:	0a f8       	st.b	--r5,r8
8000444c:	00 00       	add	r0,r0
8000444e:	0b 2c       	ld.uh	r12,r5++
80004450:	80 00       	ld.sh	r0,r0[0x0]
80004452:	42 40       	lddsp	r0,sp[0x90]
80004454:	00 00       	add	r0,r0
80004456:	51 0c       	stdsp	sp[0x40],r12
80004458:	80 00       	ld.sh	r0,r0[0x0]
8000445a:	2a 44       	sub	r4,-92

8000445c <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
8000445c:	eb cd 40 90 	pushm	r4,r7,lr
80004460:	20 1d       	sub	sp,4
80004462:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004466:	48 c8       	lddpc	r8,80004494 <xcmp_rx+0x38>
80004468:	70 0c       	ld.w	r12,r8[0x0]
8000446a:	f0 1f 00 0c 	mcall	80004498 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000446e:	c1 00       	breq	8000448e <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004470:	fa c7 ff fc 	sub	r7,sp,-4
80004474:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004476:	e0 6a 00 ca 	mov	r10,202
8000447a:	08 9b       	mov	r11,r4
8000447c:	f0 1f 00 08 	mcall	8000449c <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004480:	48 88       	lddpc	r8,800044a0 <xcmp_rx+0x44>
80004482:	70 0c       	ld.w	r12,r8[0x0]
80004484:	30 09       	mov	r9,0
80004486:	12 9a       	mov	r10,r9
80004488:	1a 9b       	mov	r11,sp
8000448a:	f0 1f 00 07 	mcall	800044a4 <xcmp_rx+0x48>
	}	
}
8000448e:	2f fd       	sub	sp,-4
80004490:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004494:	00 00       	add	r0,r0
80004496:	0a a8       	st.w	r5++,r8
80004498:	80 00       	ld.sh	r0,r0[0x0]
8000449a:	2f b0       	sub	r0,-5
8000449c:	80 00       	ld.sh	r0,r0[0x0]
8000449e:	72 74       	ld.w	r4,r9[0x1c]
800044a0:	00 00       	add	r0,r0
800044a2:	0b 10       	ld.sh	r0,r5++
800044a4:	80 00       	ld.sh	r0,r0[0x0]
800044a6:	5e 48       	retge	r8

800044a8 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
800044a8:	48 28       	lddpc	r8,800044b0 <xnl_register_xcmp_func+0x8>
800044aa:	91 0c       	st.w	r8[0x0],r12
}
800044ac:	5e fc       	retal	r12
800044ae:	00 00       	add	r0,r0
800044b0:	00 00       	add	r0,r0
800044b2:	0b 68       	ld.uh	r8,--r5

800044b4 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
800044b4:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
800044b6:	48 88       	lddpc	r8,800044d4 <xnl_get_msg_ack_func+0x20>
800044b8:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
800044ba:	98 49       	ld.sh	r9,r12[0x8]
800044bc:	f0 09 19 00 	cp.h	r9,r8
800044c0:	c0 81       	brne	800044d0 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
800044c2:	48 68       	lddpc	r8,800044d8 <xnl_get_msg_ack_func+0x24>
800044c4:	70 0c       	ld.w	r12,r8[0x0]
800044c6:	30 09       	mov	r9,0
800044c8:	12 9a       	mov	r10,r9
800044ca:	12 9b       	mov	r11,r9
800044cc:	f0 1f 00 04 	mcall	800044dc <xnl_get_msg_ack_func+0x28>
800044d0:	d8 02       	popm	pc
800044d2:	00 00       	add	r0,r0
800044d4:	00 00       	add	r0,r0
800044d6:	0b 48       	ld.w	r8,--r5
800044d8:	00 00       	add	r0,r0
800044da:	0b 44       	ld.w	r4,--r5
800044dc:	80 00       	ld.sh	r0,r0[0x0]
800044de:	5e 48       	retge	r8

800044e0 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800044e0:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
800044e4:	30 09       	mov	r9,0
800044e6:	4b 78       	lddpc	r8,800045c0 <xnl_init+0xe0>
800044e8:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800044ea:	30 0b       	mov	r11,0
800044ec:	30 1c       	mov	r12,1
800044ee:	f0 1f 00 36 	mcall	800045c4 <xnl_init+0xe4>
800044f2:	4b 68       	lddpc	r8,800045c8 <xnl_init+0xe8>
800044f4:	91 0c       	st.w	r8[0x0],r12
800044f6:	70 08       	ld.w	r8,r8[0x0]
800044f8:	58 08       	cp.w	r8,0
800044fa:	c0 80       	breq	8000450a <xnl_init+0x2a>
800044fc:	4b 38       	lddpc	r8,800045c8 <xnl_init+0xe8>
800044fe:	70 0c       	ld.w	r12,r8[0x0]
80004500:	30 09       	mov	r9,0
80004502:	12 9a       	mov	r10,r9
80004504:	12 9b       	mov	r11,r9
80004506:	f0 1f 00 32 	mcall	800045cc <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
8000450a:	30 4b       	mov	r11,4
8000450c:	31 4c       	mov	r12,20
8000450e:	f0 1f 00 2e 	mcall	800045c4 <xnl_init+0xe4>
80004512:	4b 08       	lddpc	r8,800045d0 <xnl_init+0xf0>
80004514:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80004516:	30 4b       	mov	r11,4
80004518:	31 ec       	mov	r12,30
8000451a:	f0 1f 00 2b 	mcall	800045c4 <xnl_init+0xe4>
8000451e:	4a e8       	lddpc	r8,800045d4 <xnl_init+0xf4>
80004520:	91 0c       	st.w	r8[0x0],r12
80004522:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004524:	10 96       	mov	r6,r8
80004526:	4a d5       	lddpc	r5,800045d8 <xnl_init+0xf8>
80004528:	6c 0c       	ld.w	r12,r6[0x0]
8000452a:	ea 07 00 0b 	add	r11,r5,r7
8000452e:	f0 1f 00 2c 	mcall	800045dc <xnl_init+0xfc>
80004532:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004536:	e0 47 1e 00 	cp.w	r7,7680
8000453a:	cf 71       	brne	80004528 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000453c:	30 4b       	mov	r11,4
8000453e:	31 4c       	mov	r12,20
80004540:	f0 1f 00 21 	mcall	800045c4 <xnl_init+0xe4>
80004544:	4a 78       	lddpc	r8,800045e0 <xnl_init+0x100>
80004546:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004548:	30 4b       	mov	r11,4
8000454a:	30 ac       	mov	r12,10
8000454c:	f0 1f 00 1e 	mcall	800045c4 <xnl_init+0xe4>
80004550:	4a 58       	lddpc	r8,800045e4 <xnl_init+0x104>
80004552:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004554:	30 4b       	mov	r11,4
80004556:	30 ac       	mov	r12,10
80004558:	f0 1f 00 1b 	mcall	800045c4 <xnl_init+0xe4>
8000455c:	4a 38       	lddpc	r8,800045e8 <xnl_init+0x108>
8000455e:	91 0c       	st.w	r8[0x0],r12
80004560:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80004562:	10 96       	mov	r6,r8
80004564:	4a 25       	lddpc	r5,800045ec <xnl_init+0x10c>
80004566:	6c 0c       	ld.w	r12,r6[0x0]
80004568:	ea 07 00 0b 	add	r11,r5,r7
8000456c:	f0 1f 00 1c 	mcall	800045dc <xnl_init+0xfc>
80004570:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004574:	e0 47 14 00 	cp.w	r7,5120
80004578:	cf 71       	brne	80004566 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000457a:	30 4b       	mov	r11,4
8000457c:	30 5c       	mov	r12,5
8000457e:	f0 1f 00 12 	mcall	800045c4 <xnl_init+0xe4>
80004582:	49 c8       	lddpc	r8,800045f0 <xnl_init+0x110>
80004584:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004586:	30 07       	mov	r7,0
80004588:	1a d7       	st.w	--sp,r7
8000458a:	1a d7       	st.w	--sp,r7
8000458c:	1a d7       	st.w	--sp,r7
8000458e:	30 38       	mov	r8,3
80004590:	0e 99       	mov	r9,r7
80004592:	e0 6a 02 00 	mov	r10,512
80004596:	49 8b       	lddpc	r11,800045f4 <xnl_init+0x114>
80004598:	49 8c       	lddpc	r12,800045f8 <xnl_init+0x118>
8000459a:	f0 1f 00 19 	mcall	800045fc <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
8000459e:	1a d7       	st.w	--sp,r7
800045a0:	1a d7       	st.w	--sp,r7
800045a2:	1a d7       	st.w	--sp,r7
800045a4:	30 38       	mov	r8,3
800045a6:	0e 99       	mov	r9,r7
800045a8:	e0 6a 03 20 	mov	r10,800
800045ac:	49 5b       	lddpc	r11,80004600 <xnl_init+0x120>
800045ae:	49 6c       	lddpc	r12,80004604 <xnl_init+0x124>
800045b0:	f0 1f 00 13 	mcall	800045fc <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
800045b4:	f0 1f 00 15 	mcall	80004608 <xnl_init+0x128>
800045b8:	2f ad       	sub	sp,-24
}
800045ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800045be:	00 00       	add	r0,r0
800045c0:	00 00       	add	r0,r0
800045c2:	0b 48       	ld.w	r8,--r5
800045c4:	80 00       	ld.sh	r0,r0[0x0]
800045c6:	5f 48       	srge	r8
800045c8:	00 00       	add	r0,r0
800045ca:	0b 44       	ld.w	r4,--r5
800045cc:	80 00       	ld.sh	r0,r0[0x0]
800045ce:	5e 48       	retge	r8
800045d0:	00 00       	add	r0,r0
800045d2:	0b 54       	ld.sh	r4,--r5
800045d4:	00 00       	add	r0,r0
800045d6:	0a a8       	st.w	r5++,r8
800045d8:	00 00       	add	r0,r0
800045da:	32 be       	mov	lr,43
800045dc:	80 00       	ld.sh	r0,r0[0x0]
800045de:	2a 44       	sub	r4,-92
800045e0:	00 00       	add	r0,r0
800045e2:	0a d8       	st.w	--r5,r8
800045e4:	00 00       	add	r0,r0
800045e6:	0a c4       	st.b	r5++,r4
800045e8:	00 00       	add	r0,r0
800045ea:	0a b0       	st.h	r5++,r0
800045ec:	00 00       	add	r0,r0
800045ee:	1e be       	st.h	pc++,lr
800045f0:	00 00       	add	r0,r0
800045f2:	0a 80       	andn	r0,r5
800045f4:	80 00       	ld.sh	r0,r0[0x0]
800045f6:	d1 ec       	*unknown*
800045f8:	80 00       	ld.sh	r0,r0[0x0]
800045fa:	46 0c       	lddsp	r12,sp[0x180]
800045fc:	80 00       	ld.sh	r0,r0[0x0]
800045fe:	66 1c       	ld.w	r12,r3[0x4]
80004600:	80 00       	ld.sh	r0,r0[0x0]
80004602:	ca 00       	breq	80004542 <xnl_init+0x62>
80004604:	80 00       	ld.sh	r0,r0[0x0]
80004606:	46 6c       	lddsp	r12,sp[0x198]
80004608:	80 00       	ld.sh	r0,r0[0x0]
8000460a:	2f d8       	sub	r8,-3

8000460c <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
8000460c:	eb cd 40 fe 	pushm	r1-r7,lr
80004610:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004612:	49 26       	lddpc	r6,80004658 <xnl_rx_process+0x4c>
80004614:	30 05       	mov	r5,0
80004616:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004618:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000461a:	49 11       	lddpc	r1,8000465c <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000461c:	49 12       	lddpc	r2,80004660 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000461e:	6c 0c       	ld.w	r12,r6[0x0]
80004620:	0a 99       	mov	r9,r5
80004622:	08 9a       	mov	r10,r4
80004624:	1a 9b       	mov	r11,sp
80004626:	f0 1f 00 10 	mcall	80004664 <xnl_rx_process+0x58>
8000462a:	58 1c       	cp.w	r12,1
8000462c:	cf 91       	brne	8000461e <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
8000462e:	40 0c       	lddsp	r12,sp[0x0]
80004630:	58 0c       	cp.w	r12,0
80004632:	cf 60       	breq	8000461e <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004634:	98 28       	ld.sh	r8,r12[0x4]
80004636:	e6 08 19 00 	cp.h	r8,r3
8000463a:	e0 8b 00 0a 	brhi	8000464e <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000463e:	5c 78       	castu.h	r8
80004640:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004644:	58 09       	cp.w	r9,0
80004646:	c0 40       	breq	8000464e <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004648:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
8000464c:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000464e:	62 0c       	ld.w	r12,r1[0x0]
80004650:	40 0b       	lddsp	r11,sp[0x0]
80004652:	f0 1f 00 06 	mcall	80004668 <xnl_rx_process+0x5c>
80004656:	ce 4b       	rjmp	8000461e <xnl_rx_process+0x12>
80004658:	00 00       	add	r0,r0
8000465a:	0a c4       	st.b	r5++,r4
8000465c:	00 00       	add	r0,r0
8000465e:	0a a8       	st.w	r5++,r8
80004660:	00 00       	add	r0,r0
80004662:	05 04       	ld.w	r4,r2++
80004664:	80 00       	ld.sh	r0,r0[0x0]
80004666:	5c 3c       	neg	r12
80004668:	80 00       	ld.sh	r0,r0[0x0]
8000466a:	2a 44       	sub	r4,-92

8000466c <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
8000466c:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000466e:	4a a6       	lddpc	r6,80004714 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004670:	4a a2       	lddpc	r2,80004718 <xnl_tx_process+0xac>
80004672:	4a b4       	lddpc	r4,8000471c <xnl_tx_process+0xb0>
80004674:	30 07       	mov	r7,0
80004676:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004678:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000467a:	4a a5       	lddpc	r5,80004720 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000467c:	4a a3       	lddpc	r3,80004724 <xnl_tx_process+0xb8>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000467e:	6c 08       	ld.w	r8,r6[0x0]
80004680:	58 08       	cp.w	r8,0
80004682:	c0 40       	breq	8000468a <xnl_tx_process+0x1e>
80004684:	58 18       	cp.w	r8,1
80004686:	cf d1       	brne	80004680 <xnl_tx_process+0x14>
80004688:	c2 48       	rjmp	800046d0 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000468a:	64 0c       	ld.w	r12,r2[0x0]
8000468c:	0e 99       	mov	r9,r7
8000468e:	02 9a       	mov	r10,r1
80004690:	08 9b       	mov	r11,r4
80004692:	f0 1f 00 26 	mcall	80004728 <xnl_tx_process+0xbc>
80004696:	58 1c       	cp.w	r12,1
80004698:	cf 31       	brne	8000467e <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
8000469a:	68 0b       	ld.w	r11,r4[0x0]
8000469c:	58 0b       	cp.w	r11,0
8000469e:	cf 00       	breq	8000467e <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800046a0:	96 28       	ld.sh	r8,r11[0x4]
800046a2:	e0 08 19 00 	cp.h	r8,r0
800046a6:	c0 71       	brne	800046b4 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
800046a8:	4a 18       	lddpc	r8,8000472c <xnl_tx_process+0xc0>
800046aa:	70 08       	ld.w	r8,r8[0x0]
800046ac:	10 9c       	mov	r12,r8
800046ae:	f0 1f 00 21 	mcall	80004730 <xnl_tx_process+0xc4>
						break;
800046b2:	ce 6b       	rjmp	8000467e <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
800046b4:	16 9c       	mov	r12,r11
800046b6:	f0 1f 00 20 	mcall	80004734 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
800046ba:	30 18       	mov	r8,1
800046bc:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800046be:	66 0c       	ld.w	r12,r3[0x0]
800046c0:	0e 99       	mov	r9,r7
800046c2:	0e 9a       	mov	r10,r7
800046c4:	0e 9b       	mov	r11,r7
800046c6:	f0 1f 00 19 	mcall	80004728 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
800046ca:	30 18       	mov	r8,1
800046cc:	8d 08       	st.w	r6[0x0],r8
800046ce:	cd 8b       	rjmp	8000467e <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800046d0:	66 0c       	ld.w	r12,r3[0x0]
800046d2:	0e 99       	mov	r9,r7
800046d4:	36 4a       	mov	r10,100
800046d6:	0e 9b       	mov	r11,r7
800046d8:	f0 1f 00 14 	mcall	80004728 <xnl_tx_process+0xbc>
800046dc:	58 1c       	cp.w	r12,1
800046de:	c0 81       	brne	800046ee <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
800046e0:	49 38       	lddpc	r8,8000472c <xnl_tx_process+0xc0>
800046e2:	70 0c       	ld.w	r12,r8[0x0]
800046e4:	68 0b       	ld.w	r11,r4[0x0]
800046e6:	f0 1f 00 13 	mcall	80004730 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800046ea:	8d 07       	st.w	r6[0x0],r7
800046ec:	cc 9b       	rjmp	8000467e <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800046ee:	6a 08       	ld.w	r8,r5[0x0]
800046f0:	58 38       	cp.w	r8,3
800046f2:	e0 89 00 09 	brgt	80004704 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
800046f6:	68 0c       	ld.w	r12,r4[0x0]
800046f8:	f0 1f 00 0f 	mcall	80004734 <xnl_tx_process+0xc8>
						xnl_send_times++;
800046fc:	6a 08       	ld.w	r8,r5[0x0]
800046fe:	2f f8       	sub	r8,-1
80004700:	8b 08       	st.w	r5[0x0],r8
80004702:	cb eb       	rjmp	8000467e <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004704:	48 a8       	lddpc	r8,8000472c <xnl_tx_process+0xc0>
80004706:	70 0c       	ld.w	r12,r8[0x0]
80004708:	68 0b       	ld.w	r11,r4[0x0]
8000470a:	f0 1f 00 0a 	mcall	80004730 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
8000470e:	8d 07       	st.w	r6[0x0],r7
80004710:	cb 7b       	rjmp	8000467e <xnl_tx_process+0x12>
80004712:	00 00       	add	r0,r0
80004714:	00 00       	add	r0,r0
80004716:	0b 64       	ld.uh	r4,--r5
80004718:	00 00       	add	r0,r0
8000471a:	0b 54       	ld.sh	r4,--r5
8000471c:	00 00       	add	r0,r0
8000471e:	0b 5c       	ld.sh	r12,--r5
80004720:	00 00       	add	r0,r0
80004722:	0b 58       	ld.sh	r8,--r5
80004724:	00 00       	add	r0,r0
80004726:	0b 44       	ld.w	r4,--r5
80004728:	80 00       	ld.sh	r0,r0[0x0]
8000472a:	5c 3c       	neg	r12
8000472c:	00 00       	add	r0,r0
8000472e:	0a a8       	st.w	r5++,r8
80004730:	80 00       	ld.sh	r0,r0[0x0]
80004732:	2a 44       	sub	r4,-92
80004734:	80 00       	ld.sh	r0,r0[0x0]
80004736:	2a 64       	sub	r4,-90

80004738 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004738:	eb cd 40 c0 	pushm	r6-r7,lr
8000473c:	20 1d       	sub	sp,4
8000473e:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004740:	98 39       	ld.sh	r9,r12[0x6]
80004742:	3f f8       	mov	r8,-1
80004744:	f0 09 19 00 	cp.h	r9,r8
80004748:	c0 a1       	brne	8000475c <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
8000474a:	4a e9       	lddpc	r9,80004800 <xnl_tx+0xc8>
8000474c:	13 88       	ld.ub	r8,r9[0x0]
8000474e:	2f f8       	sub	r8,-1
80004750:	5c 58       	castu.b	r8
80004752:	b2 88       	st.b	r9[0x0],r8
80004754:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004758:	a9 a8       	sbr	r8,0x8
8000475a:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
8000475c:	8c 49       	ld.sh	r9,r6[0x8]
8000475e:	3f f8       	mov	r8,-1
80004760:	f0 09 19 00 	cp.h	r9,r8
80004764:	c0 41       	brne	8000476c <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004766:	4a 88       	lddpc	r8,80004804 <xnl_tx+0xcc>
80004768:	90 18       	ld.sh	r8,r8[0x2]
8000476a:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
8000476c:	8c 59       	ld.sh	r9,r6[0xa]
8000476e:	3f f8       	mov	r8,-1
80004770:	f0 09 19 00 	cp.h	r9,r8
80004774:	c0 41       	brne	8000477c <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004776:	4a 48       	lddpc	r8,80004804 <xnl_tx+0xcc>
80004778:	90 28       	ld.sh	r8,r8[0x4]
8000477a:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
8000477c:	8c 69       	ld.sh	r9,r6[0xc]
8000477e:	3f f8       	mov	r8,-1
80004780:	f0 09 19 00 	cp.h	r9,r8
80004784:	c0 e1       	brne	800047a0 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004786:	4a 08       	lddpc	r8,80004804 <xnl_tx+0xcc>
80004788:	90 49       	ld.sh	r9,r8[0x8]
8000478a:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
8000478c:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
8000478e:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004790:	90 49       	ld.sh	r9,r8[0x8]
80004792:	e0 19 ff 00 	andl	r9,0xff00
80004796:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
8000479a:	f3 e8 10 08 	or	r8,r9,r8
8000479e:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
800047a0:	0d 98       	ld.ub	r8,r6[0x1]
800047a2:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
800047a4:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
800047a8:	10 0c       	add	r12,r8
800047aa:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800047ac:	58 0c       	cp.w	r12,0
800047ae:	e0 89 00 04 	brgt	800047b6 <xnl_tx+0x7e>
800047b2:	30 09       	mov	r9,0
800047b4:	c0 d8       	rjmp	800047ce <xnl_tx+0x96>
800047b6:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
800047ba:	2f ec       	sub	r12,-2
800047bc:	30 09       	mov	r9,0
800047be:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
800047c0:	15 1b       	ld.sh	r11,r10++
800047c2:	f6 09 00 09 	add	r9,r11,r9
800047c6:	5c 89       	casts.h	r9
		indextohWord     += 1;
800047c8:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800047ca:	18 38       	cp.w	r8,r12
800047cc:	cf a1       	brne	800047c0 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
800047ce:	5c 39       	neg	r9
800047d0:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800047d2:	48 e8       	lddpc	r8,80004808 <xnl_tx+0xd0>
800047d4:	70 0c       	ld.w	r12,r8[0x0]
800047d6:	f0 1f 00 0e 	mcall	8000480c <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800047da:	c1 00       	breq	800047fa <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800047dc:	fa c7 ff fc 	sub	r7,sp,-4
800047e0:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
800047e2:	e0 6a 01 00 	mov	r10,256
800047e6:	0c 9b       	mov	r11,r6
800047e8:	f0 1f 00 0a 	mcall	80004810 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
800047ec:	48 a8       	lddpc	r8,80004814 <xnl_tx+0xdc>
800047ee:	70 0c       	ld.w	r12,r8[0x0]
800047f0:	30 09       	mov	r9,0
800047f2:	12 9a       	mov	r10,r9
800047f4:	1a 9b       	mov	r11,sp
800047f6:	f0 1f 00 09 	mcall	80004818 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
800047fa:	2f fd       	sub	sp,-4
800047fc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004800:	00 00       	add	r0,r0
80004802:	0b 60       	ld.uh	r0,--r5
80004804:	00 00       	add	r0,r0
80004806:	0b 48       	ld.w	r8,--r5
80004808:	00 00       	add	r0,r0
8000480a:	0a a8       	st.w	r5++,r8
8000480c:	80 00       	ld.sh	r0,r0[0x0]
8000480e:	2f b0       	sub	r0,-5
80004810:	80 00       	ld.sh	r0,r0[0x0]
80004812:	72 74       	ld.w	r4,r9[0x1c]
80004814:	00 00       	add	r0,r0
80004816:	0b 54       	ld.sh	r4,--r5
80004818:	80 00       	ld.sh	r0,r0[0x0]
8000481a:	5e 48       	retge	r8

8000481c <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
8000481c:	eb cd 40 80 	pushm	r7,lr
80004820:	fa cd 01 00 	sub	sp,sp,256
80004824:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004826:	e0 68 40 0e 	mov	r8,16398
8000482a:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000482c:	3f f8       	mov	r8,-1
8000482e:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004830:	30 c8       	mov	r8,12
80004832:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004834:	98 38       	ld.sh	r8,r12[0x6]
80004836:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004838:	98 58       	ld.sh	r8,r12[0xa]
8000483a:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
8000483c:	98 48       	ld.sh	r8,r12[0x8]
8000483e:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004840:	98 68       	ld.sh	r8,r12[0xc]
80004842:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004844:	30 08       	mov	r8,0
80004846:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004848:	1a 9c       	mov	r12,sp
8000484a:	f0 1f 00 0a 	mcall	80004870 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
8000484e:	fa cd 00 cc 	sub	sp,sp,204
80004852:	e0 6a 00 ca 	mov	r10,202
80004856:	ee cb ff f0 	sub	r11,r7,-16
8000485a:	1a 9c       	mov	r12,sp
8000485c:	f0 1f 00 06 	mcall	80004874 <xnl_data_msg_func+0x58>
80004860:	48 68       	lddpc	r8,80004878 <xnl_data_msg_func+0x5c>
80004862:	70 08       	ld.w	r8,r8[0x0]
80004864:	5d 18       	icall	r8
80004866:	fa cd ff 34 	sub	sp,sp,-204
}
8000486a:	2c 0d       	sub	sp,-256
8000486c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004870:	80 00       	ld.sh	r0,r0[0x0]
80004872:	47 38       	lddsp	r8,sp[0x1cc]
80004874:	80 00       	ld.sh	r0,r0[0x0]
80004876:	72 74       	ld.w	r4,r9[0x1c]
80004878:	00 00       	add	r0,r0
8000487a:	0b 68       	ld.uh	r8,--r5

8000487c <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
8000487c:	d4 21       	pushm	r4-r7,lr
8000487e:	fa cd 01 00 	sub	sp,sp,256
80004882:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004884:	4c 28       	lddpc	r8,8000498c <xnl_device_auth_reply_func+0x110>
80004886:	11 88       	ld.ub	r8,r8[0x0]
80004888:	58 08       	cp.w	r8,0
8000488a:	c7 e1       	brne	80004986 <xnl_device_auth_reply_func+0x10a>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
8000488c:	4c 18       	lddpc	r8,80004990 <xnl_device_auth_reply_func+0x114>
8000488e:	70 0c       	ld.w	r12,r8[0x0]
80004890:	30 09       	mov	r9,0
80004892:	12 9a       	mov	r10,r9
80004894:	12 9b       	mov	r11,r9
80004896:	f0 1f 00 40 	mcall	80004994 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
8000489a:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
8000489e:	4b c8       	lddpc	r8,8000498c <xnl_device_auth_reply_func+0x110>
800048a0:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
800048a2:	ef 39 00 12 	ld.ub	r9,r7[18]
800048a6:	ef 38 00 13 	ld.ub	r8,r7[19]
800048aa:	b1 68       	lsl	r8,0x10
800048ac:	f1 e9 11 89 	or	r9,r8,r9<<0x18
800048b0:	ef 38 00 15 	ld.ub	r8,r7[21]
800048b4:	f3 e8 10 08 	or	r8,r9,r8
800048b8:	ef 39 00 14 	ld.ub	r9,r7[20]
800048bc:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
800048c0:	ef 3a 00 16 	ld.ub	r10,r7[22]
800048c4:	ef 38 00 17 	ld.ub	r8,r7[23]
800048c8:	b1 68       	lsl	r8,0x10
800048ca:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
800048ce:	ef 38 00 19 	ld.ub	r8,r7[25]
800048d2:	f5 e8 10 08 	or	r8,r10,r8
800048d6:	ef 3a 00 18 	ld.ub	r10,r7[24]
800048da:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800048de:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800048e0:	e0 64 79 b9 	mov	r4,31161
800048e4:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800048e8:	e0 65 45 07 	mov	r5,17671
800048ec:	ea 15 8a bd 	orh	r5,0x8abd
800048f0:	e0 66 f9 3d 	mov	r6,63805
800048f4:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800048f8:	e0 6e b8 cf 	mov	lr,47311
800048fc:	ea 1e 36 83 	orh	lr,0x3683
80004900:	e0 67 aa 1c 	mov	r7,43548
80004904:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004908:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
8000490a:	f4 08 00 0c 	add	r12,r10,r8
8000490e:	f0 0b 15 04 	lsl	r11,r8,0x4
80004912:	0a 0b       	add	r11,r5
80004914:	f9 eb 20 0b 	eor	r11,r12,r11
80004918:	f0 0c 16 05 	lsr	r12,r8,0x5
8000491c:	0c 0c       	add	r12,r6
8000491e:	18 5b       	eor	r11,r12
80004920:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004922:	f2 0c 15 04 	lsl	r12,r9,0x4
80004926:	1c 0c       	add	r12,lr
80004928:	f2 0b 16 05 	lsr	r11,r9,0x5
8000492c:	0e 0b       	add	r11,r7
8000492e:	f9 eb 20 0b 	eor	r11,r12,r11
80004932:	f2 0a 00 0c 	add	r12,r9,r10
80004936:	18 5b       	eor	r11,r12
80004938:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
8000493a:	e0 6b 37 20 	mov	r11,14112
8000493e:	ea 1b c6 ef 	orh	r11,0xc6ef
80004942:	16 3a       	cp.w	r10,r11
80004944:	ce 21       	brne	80004908 <xnl_device_auth_reply_func+0x8c>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004946:	e0 6a 40 1a 	mov	r10,16410
8000494a:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000494c:	3f fa       	mov	r10,-1
8000494e:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004950:	30 6b       	mov	r11,6
80004952:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004954:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004956:	48 eb       	lddpc	r11,8000498c <xnl_device_auth_reply_func+0x110>
80004958:	96 1c       	ld.sh	r12,r11[0x2]
8000495a:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
8000495c:	96 2b       	ld.sh	r11,r11[0x4]
8000495e:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004960:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004962:	30 ca       	mov	r10,12
80004964:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004966:	30 0a       	mov	r10,0
80004968:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
8000496c:	30 7a       	mov	r10,7
8000496e:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004972:	30 2a       	mov	r10,2
80004974:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004978:	fa ca ff ec 	sub	r10,sp,-20
8000497c:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000497e:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004980:	1a 9c       	mov	r12,sp
80004982:	f0 1f 00 06 	mcall	80004998 <xnl_device_auth_reply_func+0x11c>
}
80004986:	2c 0d       	sub	sp,-256
80004988:	d8 22       	popm	r4-r7,pc
8000498a:	00 00       	add	r0,r0
8000498c:	00 00       	add	r0,r0
8000498e:	0b 48       	ld.w	r8,--r5
80004990:	00 00       	add	r0,r0
80004992:	0b 44       	ld.w	r4,--r5
80004994:	80 00       	ld.sh	r0,r0[0x0]
80004996:	5e 48       	retge	r8
80004998:	80 00       	ld.sh	r0,r0[0x0]
8000499a:	47 38       	lddsp	r8,sp[0x1cc]

8000499c <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
8000499c:	eb cd 40 80 	pushm	r7,lr
800049a0:	fa cd 01 00 	sub	sp,sp,256
800049a4:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
800049a6:	49 28       	lddpc	r8,800049ec <xnl_master_status_brdcst_func+0x50>
800049a8:	11 88       	ld.ub	r8,r8[0x0]
800049aa:	58 08       	cp.w	r8,0
800049ac:	c1 c1       	brne	800049e4 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
800049ae:	49 18       	lddpc	r8,800049f0 <xnl_master_status_brdcst_func+0x54>
800049b0:	70 0c       	ld.w	r12,r8[0x0]
800049b2:	30 09       	mov	r9,0
800049b4:	12 9a       	mov	r10,r9
800049b6:	12 9b       	mov	r11,r9
800049b8:	f0 1f 00 0f 	mcall	800049f4 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
800049bc:	8e 58       	ld.sh	r8,r7[0xa]
800049be:	48 c9       	lddpc	r9,800049ec <xnl_master_status_brdcst_func+0x50>
800049c0:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800049c2:	e0 68 40 0e 	mov	r8,16398
800049c6:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800049c8:	3f f8       	mov	r8,-1
800049ca:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
800049cc:	30 4a       	mov	r10,4
800049ce:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800049d0:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800049d2:	92 19       	ld.sh	r9,r9[0x2]
800049d4:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
800049d6:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800049d8:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800049da:	30 08       	mov	r8,0
800049dc:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800049de:	1a 9c       	mov	r12,sp
800049e0:	f0 1f 00 06 	mcall	800049f8 <xnl_master_status_brdcst_func+0x5c>
}
800049e4:	2c 0d       	sub	sp,-256
800049e6:	e3 cd 80 80 	ldm	sp++,r7,pc
800049ea:	00 00       	add	r0,r0
800049ec:	00 00       	add	r0,r0
800049ee:	0b 48       	ld.w	r8,--r5
800049f0:	00 00       	add	r0,r0
800049f2:	0b 44       	ld.w	r4,--r5
800049f4:	80 00       	ld.sh	r0,r0[0x0]
800049f6:	5e 48       	retge	r8
800049f8:	80 00       	ld.sh	r0,r0[0x0]
800049fa:	47 38       	lddsp	r8,sp[0x1cc]

800049fc <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
800049fc:	eb cd 40 80 	pushm	r7,lr
80004a00:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80004a02:	49 28       	lddpc	r8,80004a48 <xnl_device_conn_reply_func+0x4c>
80004a04:	70 0c       	ld.w	r12,r8[0x0]
80004a06:	30 09       	mov	r9,0
80004a08:	12 9a       	mov	r10,r9
80004a0a:	12 9b       	mov	r11,r9
80004a0c:	f0 1f 00 10 	mcall	80004a4c <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80004a10:	ef 18 00 10 	ld.uh	r8,r7[16]
80004a14:	10 99       	mov	r9,r8
80004a16:	e2 19 ff 00 	andl	r9,0xff00,COH
80004a1a:	e0 49 01 00 	cp.w	r9,256
80004a1e:	c0 60       	breq	80004a2a <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80004a20:	0e 9c       	mov	r12,r7
80004a22:	f0 1f 00 0c 	mcall	80004a50 <xnl_device_conn_reply_func+0x54>
80004a26:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004a2a:	a9 68       	lsl	r8,0x8
80004a2c:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004a30:	48 98       	lddpc	r8,80004a54 <xnl_device_conn_reply_func+0x58>
80004a32:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004a34:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004a38:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004a3a:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004a3e:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004a40:	30 19       	mov	r9,1
80004a42:	b0 89       	st.b	r8[0x0],r9
80004a44:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a48:	00 00       	add	r0,r0
80004a4a:	0b 44       	ld.w	r4,--r5
80004a4c:	80 00       	ld.sh	r0,r0[0x0]
80004a4e:	5e 48       	retge	r8
80004a50:	80 00       	ld.sh	r0,r0[0x0]
80004a52:	49 9c       	lddpc	r12,80004ab4 <delay_us+0x14>
80004a54:	00 00       	add	r0,r0
80004a56:	0b 48       	ld.w	r8,--r5

80004a58 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
80004a58:	d4 01       	pushm	lr
80004a5a:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004a5e:	e0 68 40 0e 	mov	r8,16398
80004a62:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004a64:	3f f8       	mov	r8,-1
80004a66:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004a68:	30 38       	mov	r8,3
80004a6a:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004a6c:	30 08       	mov	r8,0
80004a6e:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004a70:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004a72:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004a74:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004a76:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004a78:	1a 9c       	mov	r12,sp
80004a7a:	f0 1f 00 03 	mcall	80004a84 <xnl_send_device_master_query+0x2c>
}
80004a7e:	2c 0d       	sub	sp,-256
80004a80:	d8 02       	popm	pc
80004a82:	00 00       	add	r0,r0
80004a84:	80 00       	ld.sh	r0,r0[0x0]
80004a86:	47 38       	lddsp	r8,sp[0x1cc]

80004a88 <delay_ns>:
U8 rc522_init_failure =0;

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80004a88:	58 0c       	cp.w	r12,0
80004a8a:	5e 0c       	reteq	r12
80004a8c:	30 08       	mov	r8,0
	{
		nop();
80004a8e:	d7 03       	nop
		nop();
80004a90:	d7 03       	nop
		nop();
80004a92:	d7 03       	nop
U8 rc522_init_failure =0;

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80004a94:	2f f8       	sub	r8,-1
80004a96:	10 3c       	cp.w	r12,r8
80004a98:	fe 9b ff fb 	brhi	80004a8e <delay_ns+0x6>
80004a9c:	5e fc       	retal	r12
80004a9e:	d7 03       	nop

80004aa0 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
80004aa0:	eb cd 40 e0 	pushm	r5-r7,lr
80004aa4:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
80004aa6:	58 0c       	cp.w	r12,0
80004aa8:	c0 b0       	breq	80004abe <delay_us+0x1e>
80004aaa:	30 07       	mov	r7,0
		delay_ns(1000);
80004aac:	e0 65 03 e8 	mov	r5,1000
80004ab0:	0a 9c       	mov	r12,r5
80004ab2:	f0 1f 00 05 	mcall	80004ac4 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
80004ab6:	2f f7       	sub	r7,-1
80004ab8:	0e 36       	cp.w	r6,r7
80004aba:	fe 9b ff fb 	brhi	80004ab0 <delay_us+0x10>
80004abe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004ac2:	00 00       	add	r0,r0
80004ac4:	80 00       	ld.sh	r0,r0[0x0]
80004ac6:	4a 88       	lddpc	r8,80004b64 <PcdReset+0x30>

80004ac8 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
80004ac8:	eb cd 40 e0 	pushm	r5-r7,lr
80004acc:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
80004ace:	58 0c       	cp.w	r12,0
80004ad0:	c0 b0       	breq	80004ae6 <delay_ms+0x1e>
80004ad2:	30 07       	mov	r7,0
		delay_us(1000);
80004ad4:	e0 65 03 e8 	mov	r5,1000
80004ad8:	0a 9c       	mov	r12,r5
80004ada:	f0 1f 00 05 	mcall	80004aec <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
80004ade:	2f f7       	sub	r7,-1
80004ae0:	0e 36       	cp.w	r6,r7
80004ae2:	fe 9b ff fb 	brhi	80004ad8 <delay_ms+0x10>
80004ae6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004aea:	00 00       	add	r0,r0
80004aec:	80 00       	ld.sh	r0,r0[0x0]
80004aee:	4a a0       	lddpc	r0,80004b94 <PcdReset+0x60>

80004af0 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
80004af0:	eb cd 40 e0 	pushm	r5-r7,lr
80004af4:	18 95       	mov	r5,r12
80004af6:	16 96       	mov	r6,r11
	U8   ucAddr;

	CLR_SPI_CS;
80004af8:	48 b7       	lddpc	r7,80004b24 <WriteRawRC+0x34>
80004afa:	30 0b       	mov	r11,0
80004afc:	6e 0c       	ld.w	r12,r7[0x0]
80004afe:	f0 1f 00 0b 	mcall	80004b28 <WriteRawRC+0x38>
	
	ucAddr = ((Address<<1)&0x7E);
	spi_write_byte(ucAddr);
80004b02:	ea 0b 15 01 	lsl	r11,r5,0x1
80004b06:	e2 1b 00 7e 	andl	r11,0x7e,COH
80004b0a:	6e 0c       	ld.w	r12,r7[0x0]
80004b0c:	f0 1f 00 08 	mcall	80004b2c <WriteRawRC+0x3c>
	spi_write_byte(value);
80004b10:	0c 9b       	mov	r11,r6
80004b12:	6e 0c       	ld.w	r12,r7[0x0]
80004b14:	f0 1f 00 06 	mcall	80004b2c <WriteRawRC+0x3c>
	
	SET_SPI_CS;
80004b18:	30 0b       	mov	r11,0
80004b1a:	6e 0c       	ld.w	r12,r7[0x0]
80004b1c:	f0 1f 00 05 	mcall	80004b30 <WriteRawRC+0x40>

}
80004b20:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004b24:	00 00       	add	r0,r0
80004b26:	1d 98       	ld.ub	r8,lr[0x1]
80004b28:	80 00       	ld.sh	r0,r0[0x0]
80004b2a:	52 a8       	stdsp	sp[0xa8],r8
80004b2c:	80 00       	ld.sh	r0,r0[0x0]
80004b2e:	51 42       	stdsp	sp[0x50],r2
80004b30:	80 00       	ld.sh	r0,r0[0x0]
80004b32:	52 68       	stdsp	sp[0x98],r8

80004b34 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
80004b34:	d4 01       	pushm	lr

	SET_RC522RST;
80004b36:	31 9c       	mov	r12,25
80004b38:	f0 1f 00 1b 	mcall	80004ba4 <PcdReset+0x70>
	delay_ns(10);
80004b3c:	30 ac       	mov	r12,10
80004b3e:	f0 1f 00 1b 	mcall	80004ba8 <PcdReset+0x74>

	CLR_RC522RST;
80004b42:	31 9c       	mov	r12,25
80004b44:	f0 1f 00 1a 	mcall	80004bac <PcdReset+0x78>
	delay_ns(10);
80004b48:	30 ac       	mov	r12,10
80004b4a:	f0 1f 00 18 	mcall	80004ba8 <PcdReset+0x74>

	SET_RC522RST;
80004b4e:	31 9c       	mov	r12,25
80004b50:	f0 1f 00 15 	mcall	80004ba4 <PcdReset+0x70>
	delay_ns(10);
80004b54:	30 ac       	mov	r12,10
80004b56:	f0 1f 00 15 	mcall	80004ba8 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004b5a:	30 fb       	mov	r11,15
80004b5c:	30 1c       	mov	r12,1
80004b5e:	f0 1f 00 15 	mcall	80004bb0 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004b62:	30 fb       	mov	r11,15
80004b64:	30 1c       	mov	r12,1
80004b66:	f0 1f 00 13 	mcall	80004bb0 <PcdReset+0x7c>
	delay_ns(10);
80004b6a:	30 ac       	mov	r12,10
80004b6c:	f0 1f 00 0f 	mcall	80004ba8 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80004b70:	33 db       	mov	r11,61
80004b72:	31 1c       	mov	r12,17
80004b74:	f0 1f 00 0f 	mcall	80004bb0 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
80004b78:	31 eb       	mov	r11,30
80004b7a:	32 dc       	mov	r12,45
80004b7c:	f0 1f 00 0d 	mcall	80004bb0 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80004b80:	30 0b       	mov	r11,0
80004b82:	32 cc       	mov	r12,44
80004b84:	f0 1f 00 0b 	mcall	80004bb0 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
80004b88:	e0 6b 00 8d 	mov	r11,141
80004b8c:	32 ac       	mov	r12,42
80004b8e:	f0 1f 00 09 	mcall	80004bb0 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
80004b92:	33 eb       	mov	r11,62
80004b94:	32 bc       	mov	r12,43
80004b96:	f0 1f 00 07 	mcall	80004bb0 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
80004b9a:	34 0b       	mov	r11,64
80004b9c:	31 5c       	mov	r12,21
80004b9e:	f0 1f 00 05 	mcall	80004bb0 <PcdReset+0x7c>
	
	return MI_OK;
}
80004ba2:	d8 0a       	popm	pc,r12=0
80004ba4:	80 00       	ld.sh	r0,r0[0x0]
80004ba6:	4f 70       	lddpc	r0,80004d80 <rc522_init+0x88>
80004ba8:	80 00       	ld.sh	r0,r0[0x0]
80004baa:	4a 88       	lddpc	r8,80004c48 <PcdAntennaOn+0x18>
80004bac:	80 00       	ld.sh	r0,r0[0x0]
80004bae:	4f 8c       	lddpc	r12,80004d8c <rc522_init+0x94>
80004bb0:	80 00       	ld.sh	r0,r0[0x0]
80004bb2:	4a f0       	lddpc	r0,80004c6c <ClearBitMask+0x1c>

80004bb4 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
80004bb4:	eb cd 40 e0 	pushm	r5-r7,lr
80004bb8:	20 1d       	sub	sp,4
80004bba:	18 95       	mov	r5,r12
	U8   ucAddr;
	U8   ucResult=0;
80004bbc:	fa c7 ff fc 	sub	r7,sp,-4
80004bc0:	30 08       	mov	r8,0
80004bc2:	0e f8       	st.b	--r7,r8
	CLR_SPI_CS;
80004bc4:	48 d6       	lddpc	r6,80004bf8 <ReadRawRC+0x44>
80004bc6:	30 0b       	mov	r11,0
80004bc8:	6c 0c       	ld.w	r12,r6[0x0]
80004bca:	f0 1f 00 0d 	mcall	80004bfc <ReadRawRC+0x48>
	
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	spi_write_byte(ucAddr);
80004bce:	a1 75       	lsl	r5,0x1
80004bd0:	0a 9b       	mov	r11,r5
80004bd2:	e2 1b 00 7e 	andl	r11,0x7e,COH
80004bd6:	a7 bb       	sbr	r11,0x7
80004bd8:	6c 0c       	ld.w	r12,r6[0x0]
80004bda:	f0 1f 00 0a 	mcall	80004c00 <ReadRawRC+0x4c>
	spi_read_byte(&ucResult);
80004bde:	0e 9b       	mov	r11,r7
80004be0:	6c 0c       	ld.w	r12,r6[0x0]
80004be2:	f0 1f 00 09 	mcall	80004c04 <ReadRawRC+0x50>
	
	SET_SPI_CS;
80004be6:	30 0b       	mov	r11,0
80004be8:	6c 0c       	ld.w	r12,r6[0x0]
80004bea:	f0 1f 00 08 	mcall	80004c08 <ReadRawRC+0x54>
	return ucResult;
}
80004bee:	1b bc       	ld.ub	r12,sp[0x3]
80004bf0:	2f fd       	sub	sp,-4
80004bf2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004bf6:	00 00       	add	r0,r0
80004bf8:	00 00       	add	r0,r0
80004bfa:	1d 98       	ld.ub	r8,lr[0x1]
80004bfc:	80 00       	ld.sh	r0,r0[0x0]
80004bfe:	52 a8       	stdsp	sp[0xa8],r8
80004c00:	80 00       	ld.sh	r0,r0[0x0]
80004c02:	51 42       	stdsp	sp[0x50],r2
80004c04:	80 00       	ld.sh	r0,r0[0x0]
80004c06:	51 5e       	stdsp	sp[0x54],lr
80004c08:	80 00       	ld.sh	r0,r0[0x0]
80004c0a:	52 68       	stdsp	sp[0x98],r8

80004c0c <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80004c0c:	eb cd 40 c0 	pushm	r6-r7,lr
80004c10:	18 97       	mov	r7,r12
80004c12:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80004c14:	f0 1f 00 05 	mcall	80004c28 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80004c18:	f9 e6 10 0b 	or	r11,r12,r6
80004c1c:	5c 5b       	castu.b	r11
80004c1e:	0e 9c       	mov	r12,r7
80004c20:	f0 1f 00 03 	mcall	80004c2c <SetBitMask+0x20>
}
80004c24:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c28:	80 00       	ld.sh	r0,r0[0x0]
80004c2a:	4b b4       	lddpc	r4,80004d14 <rc522_init+0x1c>
80004c2c:	80 00       	ld.sh	r0,r0[0x0]
80004c2e:	4a f0       	lddpc	r0,80004ce8 <M500PcdConfigISOType+0x60>

80004c30 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80004c30:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80004c32:	31 4c       	mov	r12,20
80004c34:	f0 1f 00 05 	mcall	80004c48 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80004c38:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80004c3c:	c0 51       	brne	80004c46 <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
80004c3e:	30 3b       	mov	r11,3
80004c40:	31 4c       	mov	r12,20
80004c42:	f0 1f 00 03 	mcall	80004c4c <PcdAntennaOn+0x1c>
80004c46:	d8 02       	popm	pc
80004c48:	80 00       	ld.sh	r0,r0[0x0]
80004c4a:	4b b4       	lddpc	r4,80004d34 <rc522_init+0x3c>
80004c4c:	80 00       	ld.sh	r0,r0[0x0]
80004c4e:	4c 0c       	lddpc	r12,80004d4c <rc522_init+0x54>

80004c50 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80004c50:	eb cd 40 c0 	pushm	r6-r7,lr
80004c54:	18 97       	mov	r7,r12
80004c56:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80004c58:	f0 1f 00 06 	mcall	80004c70 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80004c5c:	5c d6       	com	r6
80004c5e:	f9 e6 00 06 	and	r6,r12,r6
80004c62:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80004c66:	0e 9c       	mov	r12,r7
80004c68:	f0 1f 00 03 	mcall	80004c74 <ClearBitMask+0x24>
	
}
80004c6c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c70:	80 00       	ld.sh	r0,r0[0x0]
80004c72:	4b b4       	lddpc	r4,80004d5c <rc522_init+0x64>
80004c74:	80 00       	ld.sh	r0,r0[0x0]
80004c76:	4a f0       	lddpc	r0,80004d30 <rc522_init+0x38>

80004c78 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
80004c78:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
80004c7a:	30 3b       	mov	r11,3
80004c7c:	31 4c       	mov	r12,20
80004c7e:	f0 1f 00 02 	mcall	80004c84 <PcdAntennaOff+0xc>
}
80004c82:	d8 02       	popm	pc
80004c84:	80 00       	ld.sh	r0,r0[0x0]
80004c86:	4c 50       	lddpc	r0,80004d98 <rc522_init+0xa0>

80004c88 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
80004c88:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
80004c8a:	34 18       	mov	r8,65
80004c8c:	f0 0c 18 00 	cp.b	r12,r8
80004c90:	c0 20       	breq	80004c94 <M500PcdConfigISOType+0xc>
80004c92:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80004c94:	30 8b       	mov	r11,8
80004c96:	16 9c       	mov	r12,r11
80004c98:	f0 1f 00 14 	mcall	80004ce8 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
80004c9c:	33 db       	mov	r11,61
80004c9e:	31 1c       	mov	r12,17
80004ca0:	f0 1f 00 13 	mcall	80004cec <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80004ca4:	e0 6b 00 86 	mov	r11,134
80004ca8:	31 7c       	mov	r12,23
80004caa:	f0 1f 00 11 	mcall	80004cec <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
80004cae:	37 fb       	mov	r11,127
80004cb0:	32 6c       	mov	r12,38
80004cb2:	f0 1f 00 0f 	mcall	80004cec <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
80004cb6:	31 eb       	mov	r11,30
80004cb8:	32 dc       	mov	r12,45
80004cba:	f0 1f 00 0d 	mcall	80004cec <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
80004cbe:	30 0b       	mov	r11,0
80004cc0:	32 cc       	mov	r12,44
80004cc2:	f0 1f 00 0b 	mcall	80004cec <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
80004cc6:	e0 6b 00 8d 	mov	r11,141
80004cca:	32 ac       	mov	r12,42
80004ccc:	f0 1f 00 08 	mcall	80004cec <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80004cd0:	33 eb       	mov	r11,62
80004cd2:	32 bc       	mov	r12,43
80004cd4:	f0 1f 00 06 	mcall	80004cec <M500PcdConfigISOType+0x64>
		delay_ns(1000);
80004cd8:	e0 6c 03 e8 	mov	r12,1000
80004cdc:	f0 1f 00 05 	mcall	80004cf0 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80004ce0:	f0 1f 00 05 	mcall	80004cf4 <M500PcdConfigISOType+0x6c>
80004ce4:	d8 0a       	popm	pc,r12=0
80004ce6:	00 00       	add	r0,r0
80004ce8:	80 00       	ld.sh	r0,r0[0x0]
80004cea:	4c 50       	lddpc	r0,80004dfc <local_start_pll0+0x34>
80004cec:	80 00       	ld.sh	r0,r0[0x0]
80004cee:	4a f0       	lddpc	r0,80004da8 <rc522_init+0xb0>
80004cf0:	80 00       	ld.sh	r0,r0[0x0]
80004cf2:	4a 88       	lddpc	r8,80004d90 <rc522_init+0x98>
80004cf4:	80 00       	ld.sh	r0,r0[0x0]
80004cf6:	4c 30       	lddpc	r0,80004e00 <local_start_pll0+0x38>

80004cf8 <rc522_init>:




void rc522_init()
{
80004cf8:	eb cd 40 c0 	pushm	r6-r7,lr
80004cfc:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004cfe:	49 f8       	lddpc	r8,80004d78 <rc522_init+0x80>
80004d00:	1a 96       	mov	r6,sp
80004d02:	f0 ea 00 00 	ld.d	r10,r8[0]
80004d06:	fa eb 00 00 	st.d	sp[0],r10
80004d0a:	f0 e8 00 08 	ld.d	r8,r8[8]
80004d0e:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80004d12:	30 4b       	mov	r11,4
80004d14:	49 ac       	lddpc	r12,80004d7c <rc522_init+0x84>
80004d16:	f0 1f 00 1b 	mcall	80004d80 <rc522_init+0x88>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80004d1a:	31 9c       	mov	r12,25
80004d1c:	f0 1f 00 1a 	mcall	80004d84 <rc522_init+0x8c>
	//gpio_set_gpio_pin(AVR32_PIN_PA25);

	spi = &AVR32_SPI;
80004d20:	49 a7       	lddpc	r7,80004d88 <rc522_init+0x90>
80004d22:	fe 7c 24 00 	mov	r12,-56320
80004d26:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80004d28:	1a 9b       	mov	r11,sp
80004d2a:	f0 1f 00 19 	mcall	80004d8c <rc522_init+0x94>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80004d2e:	30 09       	mov	r9,0
80004d30:	12 9a       	mov	r10,r9
80004d32:	12 9b       	mov	r11,r9
80004d34:	6e 0c       	ld.w	r12,r7[0x0]
80004d36:	f0 1f 00 17 	mcall	80004d90 <rc522_init+0x98>

	// Enable SPI.
	spi_enable(spi);
80004d3a:	6e 0c       	ld.w	r12,r7[0x0]
80004d3c:	f0 1f 00 16 	mcall	80004d94 <rc522_init+0x9c>

	// Initialize RC522 with SPI clock Osc0.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80004d40:	e0 6a 36 00 	mov	r10,13824
80004d44:	ea 1a 01 6e 	orh	r10,0x16e
80004d48:	1a 9b       	mov	r11,sp
80004d4a:	6e 0c       	ld.w	r12,r7[0x0]
80004d4c:	f0 1f 00 13 	mcall	80004d98 <rc522_init+0xa0>
80004d50:	c0 40       	breq	80004d58 <rc522_init+0x60>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80004d52:	30 29       	mov	r9,2
80004d54:	49 28       	lddpc	r8,80004d9c <rc522_init+0xa4>
80004d56:	b0 89       	st.b	r8[0x0],r9
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80004d58:	f0 1f 00 12 	mcall	80004da0 <rc522_init+0xa8>
	
	PcdAntennaOff();
80004d5c:	f0 1f 00 12 	mcall	80004da4 <rc522_init+0xac>
	
	delay_ms(2); 
80004d60:	30 2c       	mov	r12,2
80004d62:	f0 1f 00 12 	mcall	80004da8 <rc522_init+0xb0>
	
	PcdAntennaOn();
80004d66:	f0 1f 00 12 	mcall	80004dac <rc522_init+0xb4>
	
	M500PcdConfigISOType( 'A' );
80004d6a:	34 1c       	mov	r12,65
80004d6c:	f0 1f 00 11 	mcall	80004db0 <rc522_init+0xb8>
	

80004d70:	2f cd       	sub	sp,-16
80004d72:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004d76:	00 00       	add	r0,r0
80004d78:	80 00       	ld.sh	r0,r0[0x0]
80004d7a:	d2 14       	*unknown*
80004d7c:	80 00       	ld.sh	r0,r0[0x0]
80004d7e:	d1 f4       	*unknown*
80004d80:	80 00       	ld.sh	r0,r0[0x0]
80004d82:	4f 28       	lddpc	r8,80004f48 <gpio_enable_module+0x20>
80004d84:	80 00       	ld.sh	r0,r0[0x0]
80004d86:	4f 58       	lddpc	r8,80004f58 <gpio_enable_gpio_pin>
80004d88:	00 00       	add	r0,r0
80004d8a:	1d 98       	ld.ub	r8,lr[0x1]
80004d8c:	80 00       	ld.sh	r0,r0[0x0]
80004d8e:	50 d8       	stdsp	sp[0x34],r8
80004d90:	80 00       	ld.sh	r0,r0[0x0]
80004d92:	51 10       	stdsp	sp[0x44],r0
80004d94:	80 00       	ld.sh	r0,r0[0x0]
80004d96:	51 3c       	stdsp	sp[0x4c],r12
80004d98:	80 00       	ld.sh	r0,r0[0x0]
80004d9a:	51 80       	stdsp	sp[0x60],r0
80004d9c:	00 00       	add	r0,r0
80004d9e:	0b 6c       	ld.uh	r12,--r5
80004da0:	80 00       	ld.sh	r0,r0[0x0]
80004da2:	4b 34       	lddpc	r4,80004e6c <tc_init+0x18>
80004da4:	80 00       	ld.sh	r0,r0[0x0]
80004da6:	4c 78       	lddpc	r8,80004ec0 <_tc_interrupt+0xc>
80004da8:	80 00       	ld.sh	r0,r0[0x0]
80004daa:	4a c8       	lddpc	r8,80004e58 <tc_init+0x4>
80004dac:	80 00       	ld.sh	r0,r0[0x0]
80004dae:	4c 30       	lddpc	r0,80004eb8 <_tc_interrupt+0x4>
80004db0:	80 00       	ld.sh	r0,r0[0x0]
80004db2:	4c 88       	lddpc	r8,80004ed0 <_tc_interrupt+0x1c>

80004db4 <rfid_init>:

#include "RFID.h"


void rfid_init()
{
80004db4:	d4 01       	pushm	lr
	
	tc_init();//ㄥ跺200msㄥ诲
80004db6:	f0 1f 00 03 	mcall	80004dc0 <rfid_init+0xc>
	
	rc522_init();
80004dba:	f0 1f 00 03 	mcall	80004dc4 <rfid_init+0x10>
	
	
	
	
	
80004dbe:	d8 02       	popm	pc
80004dc0:	80 00       	ld.sh	r0,r0[0x0]
80004dc2:	4e 54       	lddpc	r4,80004f54 <gpio_enable_module+0x2c>
80004dc4:	80 00       	ld.sh	r0,r0[0x0]
80004dc6:	4c f8       	lddpc	r8,80004f00 <gpio_enable_module_pin+0x2c>

80004dc8 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80004dc8:	fe 78 0c 00 	mov	r8,-62464
80004dcc:	e0 69 03 07 	mov	r9,775
80004dd0:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80004dd2:	30 49       	mov	r9,4
80004dd4:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80004dd6:	71 59       	ld.w	r9,r8[0x54]
80004dd8:	e2 19 00 80 	andl	r9,0x80,COH
80004ddc:	cf d0       	breq	80004dd6 <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80004dde:	fe 78 0c 00 	mov	r8,-62464
80004de2:	30 59       	mov	r9,5
80004de4:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80004de6:	e0 69 01 0d 	mov	r9,269
80004dea:	ea 19 10 07 	orh	r9,0x1007
80004dee:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80004df0:	71 59       	ld.w	r9,r8[0x54]
80004df2:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004df6:	cf d0       	breq	80004df0 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80004df8:	fe 78 0c 00 	mov	r8,-62464
80004dfc:	fc 19 00 80 	movh	r9,0x80
80004e00:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80004e02:	34 0a       	mov	r10,64
80004e04:	fe 69 14 00 	mov	r9,-125952
80004e08:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80004e0a:	30 69       	mov	r9,6
80004e0c:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80004e0e:	30 19       	mov	r9,1
80004e10:	fe 68 10 00 	mov	r8,-126976
80004e14:	91 19       	st.w	r8[0x4],r9
}
80004e16:	5e fc       	retal	r12

80004e18 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80004e18:	fe 78 10 00 	mov	r8,-61440
80004e1c:	fc 19 00 10 	movh	r9,0x10
80004e20:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
80004e22:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80004e24:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
80004e26:	30 39       	mov	r9,3
80004e28:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80004e2c:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80004e30:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
80004e34:	fe 78 38 00 	mov	r8,-51200
80004e38:	30 49       	mov	r9,4
80004e3a:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
80004e3e:	e0 69 91 0d 	mov	r9,37133
80004e42:	ea 19 00 52 	orh	r9,0x52
80004e46:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80004e48:	32 09       	mov	r9,32
80004e4a:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004e4c:	30 59       	mov	r9,5
80004e4e:	91 09       	st.w	r8[0x0],r9
}
80004e50:	5e fc       	retal	r12
80004e52:	d7 03       	nop

80004e54 <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
80004e54:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
80004e56:	30 2a       	mov	r10,2
80004e58:	e0 6b 01 c1 	mov	r11,449
80004e5c:	48 ec       	lddpc	r12,80004e94 <tc_init+0x40>
80004e5e:	f0 1f 00 0f 	mcall	80004e98 <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
80004e62:	48 fb       	lddpc	r11,80004e9c <tc_init+0x48>
80004e64:	fe 7c 38 00 	mov	r12,-51200
80004e68:	f0 1f 00 0e 	mcall	80004ea0 <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 2000));//200ms
80004e6c:	e0 6a 05 dc 	mov	r10,1500
80004e70:	30 1b       	mov	r11,1
80004e72:	fe 7c 38 00 	mov	r12,-51200
80004e76:	f0 1f 00 0c 	mcall	80004ea4 <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
80004e7a:	48 ca       	lddpc	r10,80004ea8 <tc_init+0x54>
80004e7c:	30 1b       	mov	r11,1
80004e7e:	fe 7c 38 00 	mov	r12,-51200
80004e82:	f0 1f 00 0b 	mcall	80004eac <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
80004e86:	30 1b       	mov	r11,1
80004e88:	fe 7c 38 00 	mov	r12,-51200
80004e8c:	f0 1f 00 09 	mcall	80004eb0 <tc_init+0x5c>
80004e90:	d8 02       	popm	pc
80004e92:	00 00       	add	r0,r0
80004e94:	80 00       	ld.sh	r0,r0[0x0]
80004e96:	4e b4       	lddpc	r4,80005040 <INTC_init_interrupts+0x14>
80004e98:	80 00       	ld.sh	r0,r0[0x0]
80004e9a:	4f ac       	lddpc	r12,80005080 <_get_interrupt_handler>
80004e9c:	80 00       	ld.sh	r0,r0[0x0]
80004e9e:	d2 28       	*unknown*
80004ea0:	80 00       	ld.sh	r0,r0[0x0]
80004ea2:	53 20       	stdsp	sp[0xc8],r0
80004ea4:	80 00       	ld.sh	r0,r0[0x0]
80004ea6:	53 e0       	stdsp	sp[0xf8],r0
80004ea8:	80 00       	ld.sh	r0,r0[0x0]
80004eaa:	d2 24       	*unknown*
80004eac:	80 00       	ld.sh	r0,r0[0x0]
80004eae:	54 14       	stdsp	sp[0x104],r4
80004eb0:	80 00       	ld.sh	r0,r0[0x0]
80004eb2:	53 bc       	stdsp	sp[0xec],r12

80004eb4 <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
80004eb4:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
80004eb6:	48 68       	lddpc	r8,80004ecc <_tc_interrupt+0x18>
80004eb8:	70 09       	ld.w	r9,r8[0x0]
80004eba:	2f f9       	sub	r9,-1
80004ebc:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
80004ebe:	30 1b       	mov	r11,1
80004ec0:	fe 7c 38 00 	mov	r12,-51200
80004ec4:	f0 1f 00 03 	mcall	80004ed0 <_tc_interrupt+0x1c>
	
}
80004ec8:	d4 02       	popm	lr
80004eca:	d6 03       	rete
80004ecc:	00 00       	add	r0,r0
80004ece:	0b 70       	ld.ub	r0,--r5
80004ed0:	80 00       	ld.sh	r0,r0[0x0]
80004ed2:	53 ce       	stdsp	sp[0xf0],lr

80004ed4 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004ed4:	f8 08 16 05 	lsr	r8,r12,0x5
80004ed8:	a9 68       	lsl	r8,0x8
80004eda:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80004ede:	58 1b       	cp.w	r11,1
80004ee0:	c0 d0       	breq	80004efa <gpio_enable_module_pin+0x26>
80004ee2:	c0 63       	brcs	80004eee <gpio_enable_module_pin+0x1a>
80004ee4:	58 2b       	cp.w	r11,2
80004ee6:	c1 00       	breq	80004f06 <gpio_enable_module_pin+0x32>
80004ee8:	58 3b       	cp.w	r11,3
80004eea:	c1 40       	breq	80004f12 <gpio_enable_module_pin+0x3e>
80004eec:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80004eee:	30 19       	mov	r9,1
80004ef0:	f2 0c 09 49 	lsl	r9,r9,r12
80004ef4:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80004ef6:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004ef8:	c1 28       	rjmp	80004f1c <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80004efa:	30 19       	mov	r9,1
80004efc:	f2 0c 09 49 	lsl	r9,r9,r12
80004f00:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80004f02:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004f04:	c0 c8       	rjmp	80004f1c <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80004f06:	30 19       	mov	r9,1
80004f08:	f2 0c 09 49 	lsl	r9,r9,r12
80004f0c:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80004f0e:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004f10:	c0 68       	rjmp	80004f1c <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80004f12:	30 19       	mov	r9,1
80004f14:	f2 0c 09 49 	lsl	r9,r9,r12
80004f18:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80004f1a:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80004f1c:	30 19       	mov	r9,1
80004f1e:	f2 0c 09 4c 	lsl	r12,r9,r12
80004f22:	91 2c       	st.w	r8[0x8],r12
80004f24:	5e fd       	retal	0
80004f26:	d7 03       	nop

80004f28 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80004f28:	d4 21       	pushm	r4-r7,lr
80004f2a:	18 97       	mov	r7,r12
80004f2c:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80004f2e:	58 0b       	cp.w	r11,0
80004f30:	c0 31       	brne	80004f36 <gpio_enable_module+0xe>
80004f32:	30 05       	mov	r5,0
80004f34:	c0 d8       	rjmp	80004f4e <gpio_enable_module+0x26>
80004f36:	30 06       	mov	r6,0
80004f38:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80004f3a:	6e 1b       	ld.w	r11,r7[0x4]
80004f3c:	6e 0c       	ld.w	r12,r7[0x0]
80004f3e:	f0 1f 00 06 	mcall	80004f54 <gpio_enable_module+0x2c>
80004f42:	18 45       	or	r5,r12
		gpiomap++;
80004f44:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80004f46:	2f f6       	sub	r6,-1
80004f48:	0c 34       	cp.w	r4,r6
80004f4a:	fe 9b ff f8 	brhi	80004f3a <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80004f4e:	0a 9c       	mov	r12,r5
80004f50:	d8 22       	popm	r4-r7,pc
80004f52:	00 00       	add	r0,r0
80004f54:	80 00       	ld.sh	r0,r0[0x0]
80004f56:	4e d4       	lddpc	r4,80005108 <spi_initMaster+0x30>

80004f58 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004f58:	f8 08 16 05 	lsr	r8,r12,0x5
80004f5c:	a9 68       	lsl	r8,0x8
80004f5e:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80004f62:	30 19       	mov	r9,1
80004f64:	f2 0c 09 4c 	lsl	r12,r9,r12
80004f68:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80004f6c:	91 1c       	st.w	r8[0x4],r12
}
80004f6e:	5e fc       	retal	r12

80004f70 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004f70:	f8 08 16 05 	lsr	r8,r12,0x5
80004f74:	a9 68       	lsl	r8,0x8
80004f76:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80004f7a:	30 19       	mov	r9,1
80004f7c:	f2 0c 09 4c 	lsl	r12,r9,r12
80004f80:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80004f84:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80004f88:	91 1c       	st.w	r8[0x4],r12
}
80004f8a:	5e fc       	retal	r12

80004f8c <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004f8c:	f8 08 16 05 	lsr	r8,r12,0x5
80004f90:	a9 68       	lsl	r8,0x8
80004f92:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80004f96:	30 19       	mov	r9,1
80004f98:	f2 0c 09 4c 	lsl	r12,r9,r12
80004f9c:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80004fa0:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80004fa4:	91 1c       	st.w	r8[0x4],r12
}
80004fa6:	5e fc       	retal	r12

80004fa8 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80004fa8:	c0 08       	rjmp	80004fa8 <_unhandled_interrupt>
80004faa:	d7 03       	nop

80004fac <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80004fac:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004fb0:	49 99       	lddpc	r9,80005014 <INTC_register_interrupt+0x68>
80004fb2:	f2 08 00 39 	add	r9,r9,r8<<0x3
80004fb6:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80004fba:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80004fbc:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004fc0:	58 0a       	cp.w	r10,0
80004fc2:	c0 91       	brne	80004fd4 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004fc4:	49 59       	lddpc	r9,80005018 <INTC_register_interrupt+0x6c>
80004fc6:	49 6a       	lddpc	r10,8000501c <INTC_register_interrupt+0x70>
80004fc8:	12 1a       	sub	r10,r9
80004fca:	fe 79 08 00 	mov	r9,-63488
80004fce:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004fd2:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80004fd4:	58 1a       	cp.w	r10,1
80004fd6:	c0 a1       	brne	80004fea <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80004fd8:	49 09       	lddpc	r9,80005018 <INTC_register_interrupt+0x6c>
80004fda:	49 2a       	lddpc	r10,80005020 <INTC_register_interrupt+0x74>
80004fdc:	12 1a       	sub	r10,r9
80004fde:	bf aa       	sbr	r10,0x1e
80004fe0:	fe 79 08 00 	mov	r9,-63488
80004fe4:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004fe8:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80004fea:	58 2a       	cp.w	r10,2
80004fec:	c0 a1       	brne	80005000 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80004fee:	48 b9       	lddpc	r9,80005018 <INTC_register_interrupt+0x6c>
80004ff0:	48 da       	lddpc	r10,80005024 <INTC_register_interrupt+0x78>
80004ff2:	12 1a       	sub	r10,r9
80004ff4:	bf ba       	sbr	r10,0x1f
80004ff6:	fe 79 08 00 	mov	r9,-63488
80004ffa:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004ffe:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80005000:	48 69       	lddpc	r9,80005018 <INTC_register_interrupt+0x6c>
80005002:	48 aa       	lddpc	r10,80005028 <INTC_register_interrupt+0x7c>
80005004:	12 1a       	sub	r10,r9
80005006:	ea 1a c0 00 	orh	r10,0xc000
8000500a:	fe 79 08 00 	mov	r9,-63488
8000500e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005012:	5e fc       	retal	r12
80005014:	80 00       	ld.sh	r0,r0[0x0]
80005016:	d2 30       	acall	0x23
80005018:	80 00       	ld.sh	r0,r0[0x0]
8000501a:	c8 00       	breq	80004f1a <gpio_enable_module_pin+0x46>
8000501c:	80 00       	ld.sh	r0,r0[0x0]
8000501e:	c9 04       	brge	80004f3e <gpio_enable_module+0x16>
80005020:	80 00       	ld.sh	r0,r0[0x0]
80005022:	c9 12       	brcc	80004f44 <gpio_enable_module+0x1c>
80005024:	80 00       	ld.sh	r0,r0[0x0]
80005026:	c9 20       	breq	80004f4a <gpio_enable_module+0x22>
80005028:	80 00       	ld.sh	r0,r0[0x0]
8000502a:	c9 2e       	rcall	80004d4e <rc522_init+0x56>

8000502c <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
8000502c:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000502e:	49 18       	lddpc	r8,80005070 <INTC_init_interrupts+0x44>
80005030:	e3 b8 00 01 	mtsr	0x4,r8
80005034:	49 0e       	lddpc	lr,80005074 <INTC_init_interrupts+0x48>
80005036:	30 07       	mov	r7,0
80005038:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000503a:	49 0c       	lddpc	r12,80005078 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000503c:	49 05       	lddpc	r5,8000507c <INTC_init_interrupts+0x50>
8000503e:	10 15       	sub	r5,r8
80005040:	fe 76 08 00 	mov	r6,-63488
80005044:	c1 08       	rjmp	80005064 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005046:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80005048:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000504a:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000504c:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80005050:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005052:	10 3a       	cp.w	r10,r8
80005054:	fe 9b ff fc 	brhi	8000504c <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005058:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
8000505c:	2f f7       	sub	r7,-1
8000505e:	2f 8e       	sub	lr,-8
80005060:	59 37       	cp.w	r7,19
80005062:	c0 50       	breq	8000506c <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005064:	7c 08       	ld.w	r8,lr[0x0]
80005066:	58 08       	cp.w	r8,0
80005068:	ce f1       	brne	80005046 <INTC_init_interrupts+0x1a>
8000506a:	cf 7b       	rjmp	80005058 <INTC_init_interrupts+0x2c>
8000506c:	d8 22       	popm	r4-r7,pc
8000506e:	00 00       	add	r0,r0
80005070:	80 00       	ld.sh	r0,r0[0x0]
80005072:	c8 00       	breq	80004f72 <gpio_set_gpio_pin+0x2>
80005074:	80 00       	ld.sh	r0,r0[0x0]
80005076:	d2 30       	acall	0x23
80005078:	80 00       	ld.sh	r0,r0[0x0]
8000507a:	4f a8       	lddpc	r8,80005260 <spi_setupChipReg+0xe0>
8000507c:	80 00       	ld.sh	r0,r0[0x0]
8000507e:	c9 04       	brge	80004f9e <gpio_clr_gpio_pin+0x12>

80005080 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005080:	fe 78 08 00 	mov	r8,-63488
80005084:	e0 69 00 83 	mov	r9,131
80005088:	f2 0c 01 0c 	sub	r12,r9,r12
8000508c:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005090:	f2 ca ff c0 	sub	r10,r9,-64
80005094:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005098:	58 08       	cp.w	r8,0
8000509a:	c0 21       	brne	8000509e <_get_interrupt_handler+0x1e>
8000509c:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000509e:	f0 08 12 00 	clz	r8,r8
800050a2:	48 5a       	lddpc	r10,800050b4 <_get_interrupt_handler+0x34>
800050a4:	f4 09 00 39 	add	r9,r10,r9<<0x3
800050a8:	f0 08 11 1f 	rsub	r8,r8,31
800050ac:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800050ae:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800050b2:	5e fc       	retal	r12
800050b4:	80 00       	ld.sh	r0,r0[0x0]
800050b6:	d2 30       	acall	0x23

800050b8 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
800050b8:	f8 c8 00 01 	sub	r8,r12,1
800050bc:	f0 0b 00 0b 	add	r11,r8,r11
800050c0:	f6 0c 0d 0a 	divu	r10,r11,r12
800050c4:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
800050c6:	f4 c8 00 01 	sub	r8,r10,1
800050ca:	e0 48 00 fe 	cp.w	r8,254
800050ce:	e0 88 00 03 	brls	800050d4 <getBaudDiv+0x1c>
800050d2:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
800050d4:	5c 8c       	casts.h	r12
}
800050d6:	5e fc       	retal	r12

800050d8 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800050d8:	f7 39 00 0d 	ld.ub	r9,r11[13]
800050dc:	30 18       	mov	r8,1
800050de:	f0 09 18 00 	cp.b	r9,r8
800050e2:	e0 88 00 04 	brls	800050ea <spi_initMaster+0x12>
800050e6:	30 2c       	mov	r12,2
800050e8:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800050ea:	e0 68 00 80 	mov	r8,128
800050ee:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
800050f0:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
800050f2:	30 19       	mov	r9,1
800050f4:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800050f8:	f7 39 00 0d 	ld.ub	r9,r11[13]
800050fc:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80005100:	30 09       	mov	r9,0
80005102:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80005106:	30 fa       	mov	r10,15
80005108:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
8000510c:	99 18       	st.w	r12[0x4],r8
8000510e:	5e f9       	retal	r9

80005110 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80005110:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80005112:	30 18       	mov	r8,1
80005114:	f0 0b 18 00 	cp.b	r11,r8
80005118:	5f be       	srhi	lr
8000511a:	f0 0a 18 00 	cp.b	r10,r8
8000511e:	5f b8       	srhi	r8
80005120:	fd e8 10 08 	or	r8,lr,r8
80005124:	c0 30       	breq	8000512a <spi_selectionMode+0x1a>
80005126:	30 2c       	mov	r12,2
80005128:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
8000512a:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
8000512c:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005130:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80005134:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80005138:	99 18       	st.w	r12[0x4],r8
8000513a:	d8 0a       	popm	pc,r12=0

8000513c <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
8000513c:	30 18       	mov	r8,1
8000513e:	99 08       	st.w	r12[0x0],r8
}
80005140:	5e fc       	retal	r12

80005142 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80005142:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005146:	c0 58       	rjmp	80005150 <spi_write+0xe>
		if (!timeout--) {
80005148:	58 08       	cp.w	r8,0
8000514a:	c0 21       	brne	8000514e <spi_write+0xc>
8000514c:	5e ff       	retal	1
8000514e:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005150:	78 49       	ld.w	r9,r12[0x10]
80005152:	e2 19 00 02 	andl	r9,0x2,COH
80005156:	cf 90       	breq	80005148 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005158:	5c 7b       	castu.h	r11
8000515a:	99 3b       	st.w	r12[0xc],r11
8000515c:	5e fd       	retal	0

8000515e <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
8000515e:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005162:	c0 58       	rjmp	8000516c <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80005164:	58 08       	cp.w	r8,0
80005166:	c0 21       	brne	8000516a <spi_read+0xc>
80005168:	5e ff       	retal	1
8000516a:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
8000516c:	78 49       	ld.w	r9,r12[0x10]
8000516e:	e2 19 02 01 	andl	r9,0x201,COH
80005172:	e0 49 02 01 	cp.w	r9,513
80005176:	cf 71       	brne	80005164 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005178:	78 28       	ld.w	r8,r12[0x8]
8000517a:	b6 08       	st.h	r11[0x0],r8
8000517c:	5e fd       	retal	0
8000517e:	d7 03       	nop

80005180 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80005180:	eb cd 40 f8 	pushm	r3-r7,lr
80005184:	18 95       	mov	r5,r12
80005186:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005188:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000518c:	30 38       	mov	r8,3
8000518e:	f0 06 18 00 	cp.b	r6,r8
80005192:	e0 8b 00 5e 	brhi	8000524e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
80005196:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000519a:	30 18       	mov	r8,1
8000519c:	f0 04 18 00 	cp.b	r4,r8
800051a0:	e0 8b 00 57 	brhi	8000524e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
800051a4:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800051a8:	30 78       	mov	r8,7
800051aa:	f0 03 18 00 	cp.b	r3,r8
800051ae:	e0 88 00 50 	brls	8000524e <spi_setupChipReg+0xce>
800051b2:	31 08       	mov	r8,16
800051b4:	f0 03 18 00 	cp.b	r3,r8
800051b8:	e0 8b 00 4b 	brhi	8000524e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
800051bc:	14 9b       	mov	r11,r10
800051be:	6e 1c       	ld.w	r12,r7[0x4]
800051c0:	f0 1f 00 26 	mcall	80005258 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
800051c4:	c4 55       	brlt	8000524e <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
800051c6:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
800051c8:	ec 09 16 01 	lsr	r9,r6,0x1
800051cc:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800051d0:	ec 16 00 01 	eorl	r6,0x1
800051d4:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
800051d8:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800051dc:	20 83       	sub	r3,8
800051de:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
800051e2:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
800051e6:	ef 39 00 09 	ld.ub	r9,r7[9]
800051ea:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
800051ee:	ef 39 00 0a 	ld.ub	r9,r7[10]
800051f2:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
800051f6:	0f 89       	ld.ub	r9,r7[0x0]
800051f8:	30 1a       	mov	r10,1
800051fa:	f4 09 18 00 	cp.b	r9,r10
800051fe:	c0 d0       	breq	80005218 <spi_setupChipReg+0x98>
80005200:	c0 a3       	brcs	80005214 <spi_setupChipReg+0x94>
80005202:	30 2a       	mov	r10,2
80005204:	f4 09 18 00 	cp.b	r9,r10
80005208:	c0 a0       	breq	8000521c <spi_setupChipReg+0x9c>
8000520a:	30 3a       	mov	r10,3
8000520c:	f4 09 18 00 	cp.b	r9,r10
80005210:	c1 f1       	brne	8000524e <spi_setupChipReg+0xce>
80005212:	c0 78       	rjmp	80005220 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80005214:	8b c8       	st.w	r5[0x30],r8
		break;
80005216:	c0 68       	rjmp	80005222 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80005218:	8b d8       	st.w	r5[0x34],r8
		break;
8000521a:	c0 48       	rjmp	80005222 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
8000521c:	8b e8       	st.w	r5[0x38],r8
		break;
8000521e:	c0 28       	rjmp	80005222 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80005220:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80005222:	48 f8       	lddpc	r8,8000525c <spi_setupChipReg+0xdc>
80005224:	70 08       	ld.w	r8,r8[0x0]
80005226:	58 08       	cp.w	r8,0
80005228:	c1 61       	brne	80005254 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
8000522a:	30 0b       	mov	r11,0
8000522c:	30 1c       	mov	r12,1
8000522e:	f0 1f 00 0d 	mcall	80005260 <spi_setupChipReg+0xe0>
80005232:	48 b8       	lddpc	r8,8000525c <spi_setupChipReg+0xdc>
80005234:	91 0c       	st.w	r8[0x0],r12
80005236:	58 0c       	cp.w	r12,0
80005238:	c0 a0       	breq	8000524c <spi_setupChipReg+0xcc>
8000523a:	30 09       	mov	r9,0
8000523c:	12 9a       	mov	r10,r9
8000523e:	12 9b       	mov	r11,r9
80005240:	f0 1f 00 09 	mcall	80005264 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80005244:	48 68       	lddpc	r8,8000525c <spi_setupChipReg+0xdc>
80005246:	70 08       	ld.w	r8,r8[0x0]
80005248:	58 08       	cp.w	r8,0
8000524a:	c0 51       	brne	80005254 <spi_setupChipReg+0xd4>
8000524c:	c0 08       	rjmp	8000524c <spi_setupChipReg+0xcc>
8000524e:	30 2c       	mov	r12,2
80005250:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005254:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005258:	80 00       	ld.sh	r0,r0[0x0]
8000525a:	50 b8       	stdsp	sp[0x2c],r8
8000525c:	00 00       	add	r0,r0
8000525e:	51 10       	stdsp	sp[0x44],r0
80005260:	80 00       	ld.sh	r0,r0[0x0]
80005262:	5f 48       	srge	r8
80005264:	80 00       	ld.sh	r0,r0[0x0]
80005266:	5e 48       	retge	r8

80005268 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005268:	d4 01       	pushm	lr
8000526a:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000526e:	c0 58       	rjmp	80005278 <spi_unselectChip+0x10>
		if (!timeout--) {
80005270:	58 08       	cp.w	r8,0
80005272:	c0 21       	brne	80005276 <spi_unselectChip+0xe>
80005274:	da 0a       	popm	pc,r12=1
80005276:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005278:	78 49       	ld.w	r9,r12[0x10]
8000527a:	e2 19 02 00 	andl	r9,0x200,COH
8000527e:	cf 90       	breq	80005270 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005280:	78 18       	ld.w	r8,r12[0x4]
80005282:	ea 18 00 0f 	orh	r8,0xf
80005286:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80005288:	fc 18 01 00 	movh	r8,0x100
8000528c:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
8000528e:	30 09       	mov	r9,0
80005290:	12 9a       	mov	r10,r9
80005292:	12 9b       	mov	r11,r9
80005294:	48 38       	lddpc	r8,800052a0 <spi_unselectChip+0x38>
80005296:	70 0c       	ld.w	r12,r8[0x0]
80005298:	f0 1f 00 03 	mcall	800052a4 <spi_unselectChip+0x3c>
8000529c:	d8 0a       	popm	pc,r12=0
8000529e:	00 00       	add	r0,r0
800052a0:	00 00       	add	r0,r0
800052a2:	51 10       	stdsp	sp[0x44],r0
800052a4:	80 00       	ld.sh	r0,r0[0x0]
800052a6:	5e 48       	retge	r8

800052a8 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800052a8:	eb cd 40 f8 	pushm	r3-r7,lr
800052ac:	18 94       	mov	r4,r12
800052ae:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
800052b0:	49 a6       	lddpc	r6,80005318 <spi_selectChip+0x70>
800052b2:	30 07       	mov	r7,0
800052b4:	31 45       	mov	r5,20
800052b6:	0e 99       	mov	r9,r7
800052b8:	0a 9a       	mov	r10,r5
800052ba:	0e 9b       	mov	r11,r7
800052bc:	6c 0c       	ld.w	r12,r6[0x0]
800052be:	f0 1f 00 18 	mcall	8000531c <spi_selectChip+0x74>
800052c2:	cf a0       	breq	800052b6 <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800052c4:	68 18       	ld.w	r8,r4[0x4]
800052c6:	ea 18 00 0f 	orh	r8,0xf
800052ca:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
800052cc:	68 18       	ld.w	r8,r4[0x4]
800052ce:	e2 18 00 04 	andl	r8,0x4,COH
800052d2:	c1 10       	breq	800052f4 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
800052d4:	30 e8       	mov	r8,14
800052d6:	f0 03 18 00 	cp.b	r3,r8
800052da:	e0 8b 00 1c 	brhi	80005312 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800052de:	68 19       	ld.w	r9,r4[0x4]
800052e0:	e6 08 15 10 	lsl	r8,r3,0x10
800052e4:	ea 18 ff f0 	orh	r8,0xfff0
800052e8:	e8 18 ff ff 	orl	r8,0xffff
800052ec:	12 68       	and	r8,r9
800052ee:	89 18       	st.w	r4[0x4],r8
800052f0:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800052f4:	30 38       	mov	r8,3
800052f6:	f0 03 18 00 	cp.b	r3,r8
800052fa:	e0 8b 00 0c 	brhi	80005312 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800052fe:	68 19       	ld.w	r9,r4[0x4]
80005300:	2f 03       	sub	r3,-16
80005302:	30 18       	mov	r8,1
80005304:	f0 03 09 48 	lsl	r8,r8,r3
80005308:	5c d8       	com	r8
8000530a:	12 68       	and	r8,r9
8000530c:	89 18       	st.w	r4[0x4],r8
8000530e:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005312:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80005314:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005318:	00 00       	add	r0,r0
8000531a:	51 10       	stdsp	sp[0x44],r0
8000531c:	80 00       	ld.sh	r0,r0[0x0]
8000531e:	5c 3c       	neg	r12

80005320 <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80005320:	76 09       	ld.w	r9,r11[0x0]
80005322:	58 29       	cp.w	r9,2
80005324:	e0 88 00 03 	brls	8000532a <tc_init_waveform+0xa>
80005328:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
8000532a:	76 18       	ld.w	r8,r11[0x4]
8000532c:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80005330:	af ba       	sbr	r10,0xf
80005332:	10 9b       	mov	r11,r8
80005334:	e6 1b c0 00 	andh	r11,0xc000,COH
80005338:	16 4a       	or	r10,r11
8000533a:	10 9b       	mov	r11,r8
8000533c:	e6 1b 30 00 	andh	r11,0x3000,COH
80005340:	16 4a       	or	r10,r11
80005342:	10 9b       	mov	r11,r8
80005344:	e6 1b 0c 00 	andh	r11,0xc00,COH
80005348:	16 4a       	or	r10,r11
8000534a:	10 9b       	mov	r11,r8
8000534c:	e6 1b 03 00 	andh	r11,0x300,COH
80005350:	16 4a       	or	r10,r11
80005352:	10 9b       	mov	r11,r8
80005354:	e6 1b 00 c0 	andh	r11,0xc0,COH
80005358:	16 4a       	or	r10,r11
8000535a:	10 9b       	mov	r11,r8
8000535c:	e6 1b 00 30 	andh	r11,0x30,COH
80005360:	16 4a       	or	r10,r11
80005362:	10 9b       	mov	r11,r8
80005364:	e6 1b 00 0c 	andh	r11,0xc,COH
80005368:	16 4a       	or	r10,r11
8000536a:	10 9b       	mov	r11,r8
8000536c:	e6 1b 00 03 	andh	r11,0x3,COH
80005370:	16 4a       	or	r10,r11
80005372:	10 9b       	mov	r11,r8
80005374:	e2 1b 60 00 	andl	r11,0x6000,COH
80005378:	16 4a       	or	r10,r11
8000537a:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
8000537e:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
80005382:	10 9b       	mov	r11,r8
80005384:	e2 1b 0c 00 	andl	r11,0xc00,COH
80005388:	16 4a       	or	r10,r11
8000538a:	10 9b       	mov	r11,r8
8000538c:	e2 1b 03 00 	andl	r11,0x300,COH
80005390:	16 4a       	or	r10,r11
80005392:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
80005396:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
8000539a:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
8000539e:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
800053a2:	10 9b       	mov	r11,r8
800053a4:	e2 1b 00 30 	andl	r11,0x30,COH
800053a8:	16 4a       	or	r10,r11
800053aa:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
800053ae:	f5 e8 10 38 	or	r8,r10,r8<<0x3
800053b2:	a5 69       	lsl	r9,0x4
800053b4:	2f f9       	sub	r9,-1
800053b6:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
800053ba:	5e fd       	retal	0

800053bc <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800053bc:	58 2b       	cp.w	r11,2
800053be:	e0 88 00 03 	brls	800053c4 <tc_start+0x8>
800053c2:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800053c4:	a7 6b       	lsl	r11,0x6
800053c6:	16 0c       	add	r12,r11
800053c8:	30 58       	mov	r8,5
800053ca:	99 08       	st.w	r12[0x0],r8
800053cc:	5e fd       	retal	0

800053ce <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800053ce:	58 2b       	cp.w	r11,2
800053d0:	e0 88 00 03 	brls	800053d6 <tc_read_sr+0x8>
800053d4:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
800053d6:	a7 6b       	lsl	r11,0x6
800053d8:	2e 0b       	sub	r11,-32
800053da:	16 0c       	add	r12,r11
800053dc:	78 0c       	ld.w	r12,r12[0x0]
}
800053de:	5e fc       	retal	r12

800053e0 <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800053e0:	58 2b       	cp.w	r11,2
800053e2:	e0 88 00 03 	brls	800053e8 <tc_write_rc+0x8>
800053e6:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
800053e8:	f6 08 15 04 	lsl	r8,r11,0x4
800053ec:	2f f8       	sub	r8,-1
800053ee:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
800053f2:	e2 18 80 00 	andl	r8,0x8000,COH
800053f6:	c0 c0       	breq	8000540e <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
800053f8:	a7 6b       	lsl	r11,0x6
800053fa:	16 0c       	add	r12,r11
800053fc:	2e 4c       	sub	r12,-28
800053fe:	78 08       	ld.w	r8,r12[0x0]
80005400:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80005404:	e0 18 00 00 	andl	r8,0x0
80005408:	f3 e8 10 08 	or	r8,r9,r8
8000540c:	99 08       	st.w	r12[0x0],r8

  return value;
8000540e:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
80005412:	5e fc       	retal	r12

80005414 <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80005414:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80005418:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
8000541c:	58 2b       	cp.w	r11,2
8000541e:	e0 88 00 04 	brls	80005426 <tc_configure_interrupts+0x12>
80005422:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
80005426:	ee 19 00 01 	eorh	r9,0x1
8000542a:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
8000542e:	74 08       	ld.w	r8,r10[0x0]
80005430:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
80005434:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
80005438:	a7 6e       	lsl	lr,0x6
8000543a:	fd e7 10 7e 	or	lr,lr,r7<<0x7
8000543e:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
80005442:	0e 4e       	or	lr,r7
80005444:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
80005448:	fd e7 10 5e 	or	lr,lr,r7<<0x5
8000544c:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
80005450:	fd e7 10 4e 	or	lr,lr,r7<<0x4
80005454:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
80005458:	fd e7 10 3e 	or	lr,lr,r7<<0x3
8000545c:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
80005460:	fd e7 10 2e 	or	lr,lr,r7<<0x2
80005464:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80005468:	fd e8 10 18 	or	r8,lr,r8<<0x1
8000546c:	f6 0e 15 06 	lsl	lr,r11,0x6
80005470:	f8 0e 00 0e 	add	lr,r12,lr
80005474:	2d ce       	sub	lr,-36
80005476:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80005478:	58 09       	cp.w	r9,0
8000547a:	c0 20       	breq	8000547e <tc_configure_interrupts+0x6a>
8000547c:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
8000547e:	74 08       	ld.w	r8,r10[0x0]
80005480:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80005484:	e0 65 00 80 	mov	r5,128
80005488:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
8000548c:	74 08       	ld.w	r8,r10[0x0]
8000548e:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80005492:	f9 b4 00 40 	moveq	r4,64
80005496:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
8000549a:	74 08       	ld.w	r8,r10[0x0]
8000549c:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
800054a0:	f9 b3 00 20 	moveq	r3,32
800054a4:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
800054a8:	74 08       	ld.w	r8,r10[0x0]
800054aa:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
800054ae:	f9 b2 00 10 	moveq	r2,16
800054b2:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
800054b6:	74 08       	ld.w	r8,r10[0x0]
800054b8:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
800054bc:	f9 b6 00 08 	moveq	r6,8
800054c0:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
800054c4:	74 08       	ld.w	r8,r10[0x0]
800054c6:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
800054ca:	f9 b7 00 04 	moveq	r7,4
800054ce:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
800054d2:	74 08       	ld.w	r8,r10[0x0]
800054d4:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
800054d8:	f9 be 00 02 	moveq	lr,2
800054dc:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
800054e0:	74 08       	ld.w	r8,r10[0x0]
800054e2:	ec 18 00 01 	eorl	r8,0x1
800054e6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800054ea:	eb e8 10 08 	or	r8,r5,r8
800054ee:	08 48       	or	r8,r4
800054f0:	06 48       	or	r8,r3
800054f2:	04 48       	or	r8,r2
800054f4:	0c 48       	or	r8,r6
800054f6:	0e 48       	or	r8,r7
800054f8:	1c 48       	or	r8,lr
800054fa:	f6 0a 15 06 	lsl	r10,r11,0x6
800054fe:	f8 0a 00 0a 	add	r10,r12,r10
80005502:	2d 8a       	sub	r10,-40
80005504:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80005506:	a7 6b       	lsl	r11,0x6
80005508:	2e 0b       	sub	r11,-32
8000550a:	16 0c       	add	r12,r11
8000550c:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
8000550e:	58 09       	cp.w	r9,0
80005510:	c0 31       	brne	80005516 <tc_configure_interrupts+0x102>
80005512:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80005516:	d5 03       	csrf	0x10
80005518:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

8000551c <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
8000551c:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
8000551e:	f6 08 15 04 	lsl	r8,r11,0x4
80005522:	14 38       	cp.w	r8,r10
80005524:	f9 b8 08 10 	movls	r8,16
80005528:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
8000552c:	f0 0b 02 4b 	mul	r11,r8,r11
80005530:	f6 09 16 01 	lsr	r9,r11,0x1
80005534:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80005538:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
8000553c:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005540:	f2 cb 00 01 	sub	r11,r9,1
80005544:	e0 4b ff fe 	cp.w	r11,65534
80005548:	e0 88 00 03 	brls	8000554e <usart_set_async_baudrate+0x32>
8000554c:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
8000554e:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005550:	e8 6e 00 00 	mov	lr,524288
80005554:	59 08       	cp.w	r8,16
80005556:	fc 08 17 10 	movne	r8,lr
8000555a:	f9 b8 00 00 	moveq	r8,0
8000555e:	e4 1b ff f7 	andh	r11,0xfff7
80005562:	e0 1b fe cf 	andl	r11,0xfecf
80005566:	16 48       	or	r8,r11
80005568:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
8000556a:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
8000556e:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005572:	99 89       	st.w	r12[0x20],r9
80005574:	d8 0a       	popm	pc,r12=0

80005576 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80005576:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005578:	e2 18 00 02 	andl	r8,0x2,COH
8000557c:	c0 31       	brne	80005582 <usart_write_char+0xc>
8000557e:	30 2c       	mov	r12,2
80005580:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005582:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80005586:	99 7b       	st.w	r12[0x1c],r11
80005588:	5e fd       	retal	0
8000558a:	d7 03       	nop

8000558c <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
8000558c:	eb cd 40 e0 	pushm	r5-r7,lr
80005590:	18 96       	mov	r6,r12
80005592:	16 95       	mov	r5,r11
80005594:	e0 67 27 0f 	mov	r7,9999
80005598:	c0 68       	rjmp	800055a4 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
8000559a:	58 07       	cp.w	r7,0
8000559c:	c0 31       	brne	800055a2 <usart_putchar+0x16>
8000559e:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
800055a2:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
800055a4:	0a 9b       	mov	r11,r5
800055a6:	0c 9c       	mov	r12,r6
800055a8:	f0 1f 00 03 	mcall	800055b4 <usart_putchar+0x28>
800055ac:	cf 71       	brne	8000559a <usart_putchar+0xe>

  return USART_SUCCESS;
}
800055ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800055b2:	00 00       	add	r0,r0
800055b4:	80 00       	ld.sh	r0,r0[0x0]
800055b6:	55 76       	stdsp	sp[0x15c],r6

800055b8 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
800055b8:	78 58       	ld.w	r8,r12[0x14]
800055ba:	e2 18 00 e0 	andl	r8,0xe0,COH
800055be:	c0 30       	breq	800055c4 <usart_read_char+0xc>
800055c0:	30 4c       	mov	r12,4
800055c2:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
800055c4:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
800055c6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800055ca:	c0 31       	brne	800055d0 <usart_read_char+0x18>
800055cc:	30 3c       	mov	r12,3
800055ce:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
800055d0:	78 68       	ld.w	r8,r12[0x18]
800055d2:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800055d6:	97 08       	st.w	r11[0x0],r8
800055d8:	5e fd       	retal	0
800055da:	d7 03       	nop

800055dc <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
800055dc:	eb cd 40 c0 	pushm	r6-r7,lr
800055e0:	20 1d       	sub	sp,4
800055e2:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
800055e4:	1a 97       	mov	r7,sp
800055e6:	1a 9b       	mov	r11,sp
800055e8:	0c 9c       	mov	r12,r6
800055ea:	f0 1f 00 07 	mcall	80005604 <usart_getchar+0x28>
800055ee:	58 3c       	cp.w	r12,3
800055f0:	cf b0       	breq	800055e6 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
800055f2:	58 4c       	cp.w	r12,4
800055f4:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
800055f8:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
800055fc:	2f fd       	sub	sp,-4
800055fe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005602:	00 00       	add	r0,r0
80005604:	80 00       	ld.sh	r0,r0[0x0]
80005606:	55 b8       	stdsp	sp[0x16c],r8

80005608 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80005608:	eb cd 40 c0 	pushm	r6-r7,lr
8000560c:	18 96       	mov	r6,r12
8000560e:	16 97       	mov	r7,r11
  while (*string != '\0')
80005610:	17 8b       	ld.ub	r11,r11[0x0]
80005612:	58 0b       	cp.w	r11,0
80005614:	c0 80       	breq	80005624 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80005616:	2f f7       	sub	r7,-1
80005618:	0c 9c       	mov	r12,r6
8000561a:	f0 1f 00 04 	mcall	80005628 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
8000561e:	0f 8b       	ld.ub	r11,r7[0x0]
80005620:	58 0b       	cp.w	r11,0
80005622:	cf a1       	brne	80005616 <usart_write_line+0xe>
80005624:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005628:	80 00       	ld.sh	r0,r0[0x0]
8000562a:	55 8c       	stdsp	sp[0x160],r12

8000562c <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
8000562c:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005630:	e6 18 00 01 	andh	r8,0x1,COH
80005634:	c0 71       	brne	80005642 <usart_reset+0x16>
80005636:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005638:	3f f8       	mov	r8,-1
8000563a:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000563c:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
8000563e:	d5 03       	csrf	0x10
80005640:	c0 48       	rjmp	80005648 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005642:	3f f8       	mov	r8,-1
80005644:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005646:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005648:	30 08       	mov	r8,0
8000564a:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
8000564c:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
8000564e:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005650:	ea 68 61 0c 	mov	r8,680204
80005654:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80005656:	5e fc       	retal	r12

80005658 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005658:	eb cd 40 e0 	pushm	r5-r7,lr
8000565c:	18 96       	mov	r6,r12
8000565e:	16 97       	mov	r7,r11
80005660:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005662:	f0 1f 00 2f 	mcall	8000571c <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80005666:	58 07       	cp.w	r7,0
80005668:	c5 80       	breq	80005718 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
8000566a:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000566c:	30 49       	mov	r9,4
8000566e:	f2 08 18 00 	cp.b	r8,r9
80005672:	e0 88 00 53 	brls	80005718 <usart_init_rs232+0xc0>
80005676:	30 99       	mov	r9,9
80005678:	f2 08 18 00 	cp.b	r8,r9
8000567c:	e0 8b 00 4e 	brhi	80005718 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005680:	0f d9       	ld.ub	r9,r7[0x5]
80005682:	30 78       	mov	r8,7
80005684:	f0 09 18 00 	cp.b	r9,r8
80005688:	e0 8b 00 48 	brhi	80005718 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
8000568c:	8e 39       	ld.sh	r9,r7[0x6]
8000568e:	e0 68 01 01 	mov	r8,257
80005692:	f0 09 19 00 	cp.h	r9,r8
80005696:	e0 8b 00 41 	brhi	80005718 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
8000569a:	ef 39 00 08 	ld.ub	r9,r7[8]
8000569e:	30 38       	mov	r8,3
800056a0:	f0 09 18 00 	cp.b	r9,r8
800056a4:	e0 8b 00 3a 	brhi	80005718 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
800056a8:	0a 9a       	mov	r10,r5
800056aa:	6e 0b       	ld.w	r11,r7[0x0]
800056ac:	0c 9c       	mov	r12,r6
800056ae:	f0 1f 00 1d 	mcall	80005720 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800056b2:	58 1c       	cp.w	r12,1
800056b4:	c3 20       	breq	80005718 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
800056b6:	0f c8       	ld.ub	r8,r7[0x4]
800056b8:	30 99       	mov	r9,9
800056ba:	f2 08 18 00 	cp.b	r8,r9
800056be:	c0 51       	brne	800056c8 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
800056c0:	6c 18       	ld.w	r8,r6[0x4]
800056c2:	b1 b8       	sbr	r8,0x11
800056c4:	8d 18       	st.w	r6[0x4],r8
800056c6:	c0 68       	rjmp	800056d2 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
800056c8:	6c 19       	ld.w	r9,r6[0x4]
800056ca:	20 58       	sub	r8,5
800056cc:	f3 e8 10 68 	or	r8,r9,r8<<0x6
800056d0:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800056d2:	6c 19       	ld.w	r9,r6[0x4]
800056d4:	ef 3a 00 08 	ld.ub	r10,r7[8]
800056d8:	0f d8       	ld.ub	r8,r7[0x5]
800056da:	a9 78       	lsl	r8,0x9
800056dc:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
800056e0:	12 48       	or	r8,r9
800056e2:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
800056e4:	8e 38       	ld.sh	r8,r7[0x6]
800056e6:	30 29       	mov	r9,2
800056e8:	f2 08 19 00 	cp.h	r8,r9
800056ec:	e0 88 00 09 	brls	800056fe <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
800056f0:	6c 18       	ld.w	r8,r6[0x4]
800056f2:	ad b8       	sbr	r8,0xd
800056f4:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
800056f6:	8e b8       	ld.uh	r8,r7[0x6]
800056f8:	20 28       	sub	r8,2
800056fa:	8d a8       	st.w	r6[0x28],r8
800056fc:	c0 68       	rjmp	80005708 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
800056fe:	6c 19       	ld.w	r9,r6[0x4]
80005700:	5c 78       	castu.h	r8
80005702:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005706:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005708:	6c 18       	ld.w	r8,r6[0x4]
8000570a:	e0 18 ff f0 	andl	r8,0xfff0
8000570e:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005710:	35 08       	mov	r8,80
80005712:	8d 08       	st.w	r6[0x0],r8
80005714:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005718:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
8000571c:	80 00       	ld.sh	r0,r0[0x0]
8000571e:	56 2c       	stdsp	sp[0x188],r12
80005720:	80 00       	ld.sh	r0,r0[0x0]
80005722:	55 1c       	stdsp	sp[0x144],r12

80005724 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005724:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005728:	fe c0 8f 28 	sub	r0,pc,-28888

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
8000572c:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005730:	d5 53       	csrf	0x15
  cp      r0, r1
80005732:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005734:	e0 61 0a 48 	mov	r1,2632
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005738:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
8000573a:	c0 62       	brcc	80005746 <idata_load_loop_end>
  cp      r0, r1
8000573c:	48 92       	lddpc	r2,80005760 <udata_clear_loop_end+0x4>

8000573e <idata_load_loop>:
  brlo    idata_load_loop
8000573e:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005740:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005742:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005744:	cf d3       	brcs	8000573e <idata_load_loop>

80005746 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005746:	e0 60 0a 48 	mov	r0,2632
  mov     r2, 0
  mov     r3, 0
8000574a:	e0 61 51 20 	mov	r1,20768
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
8000574e:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005750:	c0 62       	brcc	8000575c <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005752:	30 02       	mov	r2,0
80005754:	30 03       	mov	r3,0

80005756 <udata_clear_loop>:
80005756:	a1 22       	st.d	r0++,r2
80005758:	02 30       	cp.w	r0,r1
8000575a:	cf e3       	brcs	80005756 <udata_clear_loop>

8000575c <udata_clear_loop_end>:
8000575c:	fe cf e9 c4 	sub	pc,pc,-5692
80005760:	80 00       	ld.sh	r0,r0[0x0]
80005762:	db 60       	acall	0xb6

80005764 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005764:	f8 c8 ff f8 	sub	r8,r12,-8
80005768:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
8000576a:	3f f9       	mov	r9,-1
8000576c:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
8000576e:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005770:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005772:	30 08       	mov	r8,0
80005774:	99 08       	st.w	r12[0x0],r8
}
80005776:	5e fc       	retal	r12

80005778 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005778:	30 08       	mov	r8,0
8000577a:	99 48       	st.w	r12[0x10],r8
}
8000577c:	5e fc       	retal	r12

8000577e <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
8000577e:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005780:	70 19       	ld.w	r9,r8[0x4]
80005782:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005784:	78 19       	ld.w	r9,r12[0x4]
80005786:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005788:	70 19       	ld.w	r9,r8[0x4]
8000578a:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
8000578c:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
8000578e:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005790:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005792:	78 08       	ld.w	r8,r12[0x0]
80005794:	2f f8       	sub	r8,-1
80005796:	99 08       	st.w	r12[0x0],r8
}
80005798:	5e fc       	retal	r12

8000579a <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
8000579a:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
8000579c:	5b fa       	cp.w	r10,-1
8000579e:	c0 31       	brne	800057a4 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
800057a0:	78 48       	ld.w	r8,r12[0x10]
800057a2:	c0 c8       	rjmp	800057ba <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
800057a4:	f8 c8 ff f8 	sub	r8,r12,-8
800057a8:	70 19       	ld.w	r9,r8[0x4]
800057aa:	72 09       	ld.w	r9,r9[0x0]
800057ac:	12 3a       	cp.w	r10,r9
800057ae:	c0 63       	brcs	800057ba <vListInsert+0x20>
800057b0:	70 18       	ld.w	r8,r8[0x4]
800057b2:	70 19       	ld.w	r9,r8[0x4]
800057b4:	72 09       	ld.w	r9,r9[0x0]
800057b6:	12 3a       	cp.w	r10,r9
800057b8:	cf c2       	brcc	800057b0 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
800057ba:	70 19       	ld.w	r9,r8[0x4]
800057bc:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800057be:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
800057c0:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
800057c2:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800057c4:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800057c6:	78 08       	ld.w	r8,r12[0x0]
800057c8:	2f f8       	sub	r8,-1
800057ca:	99 08       	st.w	r12[0x0],r8
}
800057cc:	5e fc       	retal	r12

800057ce <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
800057ce:	78 18       	ld.w	r8,r12[0x4]
800057d0:	78 29       	ld.w	r9,r12[0x8]
800057d2:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
800057d4:	78 28       	ld.w	r8,r12[0x8]
800057d6:	78 19       	ld.w	r9,r12[0x4]
800057d8:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
800057da:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
800057dc:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
800057de:	18 39       	cp.w	r9,r12
800057e0:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
800057e4:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
800057e8:	30 09       	mov	r9,0
800057ea:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
800057ec:	70 09       	ld.w	r9,r8[0x0]
800057ee:	20 19       	sub	r9,1
800057f0:	91 09       	st.w	r8[0x0],r9
}
800057f2:	5e fc       	retal	r12

800057f4 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
800057f4:	e0 68 08 08 	mov	r8,2056
800057f8:	ea 18 08 08 	orh	r8,0x808
800057fc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
800057fe:	e0 68 09 09 	mov	r8,2313
80005802:	ea 18 09 09 	orh	r8,0x909
80005806:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005808:	e0 68 0a 0a 	mov	r8,2570
8000580c:	ea 18 0a 0a 	orh	r8,0xa0a
80005810:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005812:	e0 68 0b 0b 	mov	r8,2827
80005816:	ea 18 0b 0b 	orh	r8,0xb0b
8000581a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
8000581c:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
8000581e:	e0 68 be ef 	mov	r8,48879
80005822:	ea 18 de ad 	orh	r8,0xdead
80005826:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005828:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
8000582a:	fc 18 00 40 	movh	r8,0x40
8000582e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005830:	e0 68 00 ff 	mov	r8,255
80005834:	ea 18 ff 00 	orh	r8,0xff00
80005838:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
8000583a:	e0 68 01 01 	mov	r8,257
8000583e:	ea 18 01 01 	orh	r8,0x101
80005842:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005844:	e0 68 02 02 	mov	r8,514
80005848:	ea 18 02 02 	orh	r8,0x202
8000584c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
8000584e:	e0 68 03 03 	mov	r8,771
80005852:	ea 18 03 03 	orh	r8,0x303
80005856:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005858:	e0 68 04 04 	mov	r8,1028
8000585c:	ea 18 04 04 	orh	r8,0x404
80005860:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005862:	e0 68 05 05 	mov	r8,1285
80005866:	ea 18 05 05 	orh	r8,0x505
8000586a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
8000586c:	e0 68 06 06 	mov	r8,1542
80005870:	ea 18 06 06 	orh	r8,0x606
80005874:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005876:	e0 68 07 07 	mov	r8,1799
8000587a:	ea 18 07 07 	orh	r8,0x707
8000587e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005880:	30 08       	mov	r8,0
80005882:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005884:	5e fc       	retal	r12
80005886:	d7 03       	nop

80005888 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005888:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
8000588a:	48 38       	lddpc	r8,80005894 <vPortEnterCritical+0xc>
8000588c:	70 09       	ld.w	r9,r8[0x0]
8000588e:	2f f9       	sub	r9,-1
80005890:	91 09       	st.w	r8[0x0],r9
}
80005892:	5e fc       	retal	r12
80005894:	00 00       	add	r0,r0
80005896:	05 38       	ld.ub	r8,r2++

80005898 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005898:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
8000589a:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
8000589c:	30 0a       	mov	r10,0
8000589e:	14 9b       	mov	r11,r10
800058a0:	49 2c       	lddpc	r12,800058e8 <xPortStartScheduler+0x50>
800058a2:	f0 1f 00 13 	mcall	800058ec <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
800058a6:	e0 68 5d c0 	mov	r8,24000
800058aa:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
800058ae:	30 08       	mov	r8,0
800058b0:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
800058b4:	e0 68 0c ec 	mov	r8,3308
800058b8:	ea 18 00 00 	orh	r8,0x0
800058bc:	70 00       	ld.w	r0,r8[0x0]
800058be:	60 0d       	ld.w	sp,r0[0x0]
800058c0:	1b 00       	ld.w	r0,sp++
800058c2:	e0 68 05 38 	mov	r8,1336
800058c6:	ea 18 00 00 	orh	r8,0x0
800058ca:	91 00       	st.w	r8[0x0],r0
800058cc:	e3 cd 00 ff 	ldm	sp++,r0-r7
800058d0:	2f ed       	sub	sp,-8
800058d2:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
800058d6:	fa f0 ff e0 	ld.w	r0,sp[-32]
800058da:	e3 b0 00 00 	mtsr	0x0,r0
800058de:	fa f0 ff dc 	ld.w	r0,sp[-36]
800058e2:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
800058e6:	d8 0a       	popm	pc,r12=0
800058e8:	80 00       	ld.sh	r0,r0[0x0]
800058ea:	59 b4       	cp.w	r4,27
800058ec:	80 00       	ld.sh	r0,r0[0x0]
800058ee:	4f ac       	lddpc	r12,80005ad4 <vPortFree+0x8>

800058f0 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
800058f0:	20 6d       	sub	sp,24
800058f2:	eb cd 00 ff 	pushm	r0-r7
800058f6:	fa c7 ff c0 	sub	r7,sp,-64
800058fa:	ee f0 ff f8 	ld.w	r0,r7[-8]
800058fe:	ef 40 ff e0 	st.w	r7[-32],r0
80005902:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005906:	ef 40 ff e4 	st.w	r7[-28],r0
8000590a:	eb c7 5f 00 	stm	--r7,r8-r12,lr
8000590e:	e0 68 05 38 	mov	r8,1336
80005912:	ea 18 00 00 	orh	r8,0x0
80005916:	70 00       	ld.w	r0,r8[0x0]
80005918:	1a d0       	st.w	--sp,r0
8000591a:	f0 1f 00 1a 	mcall	80005980 <LABEL_RET_SCALL_263+0x14>
8000591e:	e0 68 0c ec 	mov	r8,3308
80005922:	ea 18 00 00 	orh	r8,0x0
80005926:	70 00       	ld.w	r0,r8[0x0]
80005928:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
8000592a:	f0 1f 00 17 	mcall	80005984 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
8000592e:	e0 68 0c ec 	mov	r8,3308
80005932:	ea 18 00 00 	orh	r8,0x0
80005936:	70 00       	ld.w	r0,r8[0x0]
80005938:	60 0d       	ld.w	sp,r0[0x0]
8000593a:	1b 00       	ld.w	r0,sp++
8000593c:	e0 68 05 38 	mov	r8,1336
80005940:	ea 18 00 00 	orh	r8,0x0
80005944:	91 00       	st.w	r8[0x0],r0
80005946:	fa c7 ff d8 	sub	r7,sp,-40
8000594a:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
8000594e:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005952:	e0 61 05 38 	mov	r1,1336
80005956:	ea 11 00 00 	orh	r1,0x0
8000595a:	62 02       	ld.w	r2,r1[0x0]
8000595c:	58 02       	cp.w	r2,0
8000595e:	c0 70       	breq	8000596c <LABEL_RET_SCALL_263>
80005960:	e4 c2 00 01 	sub	r2,r2,1
80005964:	83 02       	st.w	r1[0x0],r2
80005966:	58 02       	cp.w	r2,0
80005968:	c0 21       	brne	8000596c <LABEL_RET_SCALL_263>
8000596a:	b1 c0       	cbr	r0,0x10

8000596c <LABEL_RET_SCALL_263>:
8000596c:	ef 40 ff f8 	st.w	r7[-8],r0
80005970:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005974:	ef 40 ff fc 	st.w	r7[-4],r0
80005978:	e3 cd 00 ff 	ldm	sp++,r0-r7
8000597c:	2f ad       	sub	sp,-24
8000597e:	d6 13       	rets
80005980:	80 00       	ld.sh	r0,r0[0x0]
80005982:	58 88       	cp.w	r8,8
80005984:	80 00       	ld.sh	r0,r0[0x0]
80005986:	5f cc       	srvs	r12

80005988 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005988:	e1 b8 00 43 	mfsr	r8,0x10c
8000598c:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005990:	5e fc       	retal	r12
80005992:	d7 03       	nop

80005994 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005994:	48 78       	lddpc	r8,800059b0 <vPortExitCritical+0x1c>
80005996:	70 08       	ld.w	r8,r8[0x0]
80005998:	58 08       	cp.w	r8,0
8000599a:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
8000599c:	48 58       	lddpc	r8,800059b0 <vPortExitCritical+0x1c>
8000599e:	70 09       	ld.w	r9,r8[0x0]
800059a0:	20 19       	sub	r9,1
800059a2:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
800059a4:	70 08       	ld.w	r8,r8[0x0]
800059a6:	58 08       	cp.w	r8,0
800059a8:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
800059aa:	d5 03       	csrf	0x10
800059ac:	5e fc       	retal	r12
800059ae:	00 00       	add	r0,r0
800059b0:	00 00       	add	r0,r0
800059b2:	05 38       	ld.ub	r8,r2++

800059b4 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
800059b4:	eb cd 00 ff 	pushm	r0-r7
800059b8:	e0 68 05 38 	mov	r8,1336
800059bc:	ea 18 00 00 	orh	r8,0x0
800059c0:	70 00       	ld.w	r0,r8[0x0]
800059c2:	1a d0       	st.w	--sp,r0
800059c4:	7a 90       	ld.w	r0,sp[0x24]
800059c6:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800059ca:	58 10       	cp.w	r0,1
800059cc:	e0 8b 00 08 	brhi	800059dc <LABEL_INT_SKIP_SAVE_CONTEXT_237>
800059d0:	e0 68 0c ec 	mov	r8,3308
800059d4:	ea 18 00 00 	orh	r8,0x0
800059d8:	70 00       	ld.w	r0,r8[0x0]
800059da:	81 0d       	st.w	r0[0x0],sp

800059dc <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
800059dc:	f0 1f 00 12 	mcall	80005a24 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
800059e0:	f0 1f 00 12 	mcall	80005a28 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
800059e4:	f0 1f 00 12 	mcall	80005a2c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
800059e8:	f0 1f 00 12 	mcall	80005a30 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
800059ec:	7a 90       	ld.w	r0,sp[0x24]
800059ee:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800059f2:	58 10       	cp.w	r0,1
800059f4:	e0 8b 00 0e 	brhi	80005a10 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
800059f8:	f0 1f 00 0c 	mcall	80005a28 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
800059fc:	f0 1f 00 0e 	mcall	80005a34 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005a00:	f0 1f 00 0c 	mcall	80005a30 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005a04:	e0 68 0c ec 	mov	r8,3308
80005a08:	ea 18 00 00 	orh	r8,0x0
80005a0c:	70 00       	ld.w	r0,r8[0x0]
80005a0e:	60 0d       	ld.w	sp,r0[0x0]

80005a10 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005a10:	1b 00       	ld.w	r0,sp++
80005a12:	e0 68 05 38 	mov	r8,1336
80005a16:	ea 18 00 00 	orh	r8,0x0
80005a1a:	91 00       	st.w	r8[0x0],r0
80005a1c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005a20:	d6 03       	rete
80005a22:	00 00       	add	r0,r0
80005a24:	80 00       	ld.sh	r0,r0[0x0]
80005a26:	59 88       	cp.w	r8,24
80005a28:	80 00       	ld.sh	r0,r0[0x0]
80005a2a:	58 88       	cp.w	r8,8
80005a2c:	80 00       	ld.sh	r0,r0[0x0]
80005a2e:	61 d0       	ld.w	r0,r0[0x74]
80005a30:	80 00       	ld.sh	r0,r0[0x0]
80005a32:	59 94       	cp.w	r4,25
80005a34:	80 00       	ld.sh	r0,r0[0x0]
80005a36:	5f cc       	srvs	r12

80005a38 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005a38:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005a3a:	f0 1f 00 02 	mcall	80005a40 <__malloc_lock+0x8>
}
80005a3e:	d8 02       	popm	pc
80005a40:	80 00       	ld.sh	r0,r0[0x0]
80005a42:	5f bc       	srhi	r12

80005a44 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005a44:	d4 01       	pushm	lr
	xTaskResumeAll();
80005a46:	f0 1f 00 02 	mcall	80005a4c <__malloc_unlock+0x8>
}
80005a4a:	d8 02       	popm	pc
80005a4c:	80 00       	ld.sh	r0,r0[0x0]
80005a4e:	63 78       	ld.w	r8,r1[0x5c]

80005a50 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005a50:	d4 21       	pushm	r4-r7,lr
80005a52:	16 95       	mov	r5,r11
80005a54:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005a56:	58 0c       	cp.w	r12,0
80005a58:	c0 30       	breq	80005a5e <_read+0xe>
80005a5a:	3f f7       	mov	r7,-1
80005a5c:	c1 48       	rjmp	80005a84 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005a5e:	58 0a       	cp.w	r10,0
80005a60:	e0 89 00 04 	brgt	80005a68 <_read+0x18>
80005a64:	30 07       	mov	r7,0
80005a66:	c0 f8       	rjmp	80005a84 <_read+0x34>
80005a68:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005a6a:	48 84       	lddpc	r4,80005a88 <_read+0x38>
80005a6c:	68 0c       	ld.w	r12,r4[0x0]
80005a6e:	f0 1f 00 08 	mcall	80005a8c <_read+0x3c>
    if (c < 0)
80005a72:	c0 95       	brlt	80005a84 <_read+0x34>
      break;

    *ptr++ = c;
80005a74:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005a78:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005a7a:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005a7e:	58 08       	cp.w	r8,0
80005a80:	fe 99 ff f6 	brgt	80005a6c <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005a84:	0e 9c       	mov	r12,r7
80005a86:	d8 22       	popm	r4-r7,pc
80005a88:	00 00       	add	r0,r0
80005a8a:	51 14       	stdsp	sp[0x44],r4
80005a8c:	80 00       	ld.sh	r0,r0[0x0]
80005a8e:	55 dc       	stdsp	sp[0x174],r12

80005a90 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005a90:	d4 21       	pushm	r4-r7,lr
80005a92:	16 95       	mov	r5,r11
80005a94:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005a96:	20 1c       	sub	r12,1
80005a98:	58 2c       	cp.w	r12,2
80005a9a:	e0 8b 00 12 	brhi	80005abe <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005a9e:	58 0a       	cp.w	r10,0
80005aa0:	c0 31       	brne	80005aa6 <_write+0x16>
80005aa2:	30 07       	mov	r7,0
80005aa4:	c0 e8       	rjmp	80005ac0 <_write+0x30>
80005aa6:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005aa8:	48 74       	lddpc	r4,80005ac4 <_write+0x34>
80005aaa:	68 0c       	ld.w	r12,r4[0x0]
80005aac:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005ab0:	f0 1f 00 06 	mcall	80005ac8 <_write+0x38>
80005ab4:	c0 55       	brlt	80005abe <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005ab6:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005ab8:	0e 36       	cp.w	r6,r7
80005aba:	cf 81       	brne	80005aaa <_write+0x1a>
80005abc:	c0 28       	rjmp	80005ac0 <_write+0x30>
80005abe:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005ac0:	0e 9c       	mov	r12,r7
80005ac2:	d8 22       	popm	r4-r7,pc
80005ac4:	00 00       	add	r0,r0
80005ac6:	51 14       	stdsp	sp[0x44],r4
80005ac8:	80 00       	ld.sh	r0,r0[0x0]
80005aca:	55 8c       	stdsp	sp[0x160],r12

80005acc <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005acc:	eb cd 40 80 	pushm	r7,lr
80005ad0:	18 97       	mov	r7,r12
	if( pv )
80005ad2:	58 0c       	cp.w	r12,0
80005ad4:	c0 80       	breq	80005ae4 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005ad6:	f0 1f 00 05 	mcall	80005ae8 <vPortFree+0x1c>
		{
			free( pv );
80005ada:	0e 9c       	mov	r12,r7
80005adc:	f0 1f 00 04 	mcall	80005aec <vPortFree+0x20>
		}
		xTaskResumeAll();
80005ae0:	f0 1f 00 04 	mcall	80005af0 <vPortFree+0x24>
80005ae4:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ae8:	80 00       	ld.sh	r0,r0[0x0]
80005aea:	5f bc       	srhi	r12
80005aec:	80 00       	ld.sh	r0,r0[0x0]
80005aee:	6e 1c       	ld.w	r12,r7[0x4]
80005af0:	80 00       	ld.sh	r0,r0[0x0]
80005af2:	63 78       	ld.w	r8,r1[0x5c]

80005af4 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005af4:	eb cd 40 80 	pushm	r7,lr
80005af8:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005afa:	f0 1f 00 06 	mcall	80005b10 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005afe:	0e 9c       	mov	r12,r7
80005b00:	f0 1f 00 05 	mcall	80005b14 <pvPortMalloc+0x20>
80005b04:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005b06:	f0 1f 00 05 	mcall	80005b18 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005b0a:	0e 9c       	mov	r12,r7
80005b0c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005b10:	80 00       	ld.sh	r0,r0[0x0]
80005b12:	5f bc       	srhi	r12
80005b14:	80 00       	ld.sh	r0,r0[0x0]
80005b16:	6e 2c       	ld.w	r12,r7[0x8]
80005b18:	80 00       	ld.sh	r0,r0[0x0]
80005b1a:	63 78       	ld.w	r8,r1[0x5c]

80005b1c <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005b1c:	d4 01       	pushm	lr
80005b1e:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005b20:	78 09       	ld.w	r9,r12[0x0]
80005b22:	58 09       	cp.w	r9,0
80005b24:	c1 10       	breq	80005b46 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005b26:	78 3a       	ld.w	r10,r12[0xc]
80005b28:	79 09       	ld.w	r9,r12[0x40]
80005b2a:	f4 09 00 09 	add	r9,r10,r9
80005b2e:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005b30:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005b32:	14 39       	cp.w	r9,r10
80005b34:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005b38:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005b3c:	79 0a       	ld.w	r10,r12[0x40]
80005b3e:	78 3b       	ld.w	r11,r12[0xc]
80005b40:	10 9c       	mov	r12,r8
80005b42:	f0 1f 00 02 	mcall	80005b48 <prvCopyDataFromQueue+0x2c>
80005b46:	d8 02       	popm	pc
80005b48:	80 00       	ld.sh	r0,r0[0x0]
80005b4a:	72 74       	ld.w	r4,r9[0x1c]

80005b4c <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005b4c:	eb cd 40 c0 	pushm	r6-r7,lr
80005b50:	18 97       	mov	r7,r12
80005b52:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005b54:	78 e8       	ld.w	r8,r12[0x38]
80005b56:	58 08       	cp.w	r8,0
80005b58:	c0 31       	brne	80005b5e <xQueueReceiveFromISR+0x12>
80005b5a:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005b5e:	f0 1f 00 0e 	mcall	80005b94 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80005b62:	6e e8       	ld.w	r8,r7[0x38]
80005b64:	20 18       	sub	r8,1
80005b66:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80005b68:	6f 18       	ld.w	r8,r7[0x44]
80005b6a:	5b f8       	cp.w	r8,-1
80005b6c:	c0 d1       	brne	80005b86 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005b6e:	6e 48       	ld.w	r8,r7[0x10]
80005b70:	58 08       	cp.w	r8,0
80005b72:	c0 f0       	breq	80005b90 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005b74:	ee cc ff f0 	sub	r12,r7,-16
80005b78:	f0 1f 00 08 	mcall	80005b98 <xQueueReceiveFromISR+0x4c>
80005b7c:	c0 a0       	breq	80005b90 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80005b7e:	30 1c       	mov	r12,1
80005b80:	8d 0c       	st.w	r6[0x0],r12
80005b82:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80005b86:	2f f8       	sub	r8,-1
80005b88:	ef 48 00 44 	st.w	r7[68],r8
80005b8c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005b90:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005b94:	80 00       	ld.sh	r0,r0[0x0]
80005b96:	5b 1c       	cp.w	r12,-15
80005b98:	80 00       	ld.sh	r0,r0[0x0]
80005b9a:	61 54       	ld.w	r4,r0[0x54]

80005b9c <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005b9c:	eb cd 40 c0 	pushm	r6-r7,lr
80005ba0:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005ba2:	f0 1f 00 23 	mcall	80005c2c <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005ba6:	6f 28       	ld.w	r8,r7[0x48]
80005ba8:	58 08       	cp.w	r8,0
80005baa:	e0 8a 00 18 	brle	80005bda <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005bae:	6e 98       	ld.w	r8,r7[0x24]
80005bb0:	58 08       	cp.w	r8,0
80005bb2:	c1 40       	breq	80005bda <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005bb4:	ee c6 ff dc 	sub	r6,r7,-36
80005bb8:	c0 48       	rjmp	80005bc0 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005bba:	6e 98       	ld.w	r8,r7[0x24]
80005bbc:	58 08       	cp.w	r8,0
80005bbe:	c0 e0       	breq	80005bda <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005bc0:	0c 9c       	mov	r12,r6
80005bc2:	f0 1f 00 1c 	mcall	80005c30 <prvUnlockQueue+0x94>
80005bc6:	c0 30       	breq	80005bcc <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005bc8:	f0 1f 00 1b 	mcall	80005c34 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005bcc:	6f 28       	ld.w	r8,r7[0x48]
80005bce:	20 18       	sub	r8,1
80005bd0:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005bd4:	58 08       	cp.w	r8,0
80005bd6:	fe 99 ff f2 	brgt	80005bba <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005bda:	3f f8       	mov	r8,-1
80005bdc:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005be0:	f0 1f 00 16 	mcall	80005c38 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005be4:	f0 1f 00 12 	mcall	80005c2c <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005be8:	6f 18       	ld.w	r8,r7[0x44]
80005bea:	58 08       	cp.w	r8,0
80005bec:	e0 8a 00 18 	brle	80005c1c <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005bf0:	6e 48       	ld.w	r8,r7[0x10]
80005bf2:	58 08       	cp.w	r8,0
80005bf4:	c1 40       	breq	80005c1c <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005bf6:	ee c6 ff f0 	sub	r6,r7,-16
80005bfa:	c0 48       	rjmp	80005c02 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005bfc:	6e 48       	ld.w	r8,r7[0x10]
80005bfe:	58 08       	cp.w	r8,0
80005c00:	c0 e0       	breq	80005c1c <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005c02:	0c 9c       	mov	r12,r6
80005c04:	f0 1f 00 0b 	mcall	80005c30 <prvUnlockQueue+0x94>
80005c08:	c0 30       	breq	80005c0e <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80005c0a:	f0 1f 00 0b 	mcall	80005c34 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005c0e:	6f 18       	ld.w	r8,r7[0x44]
80005c10:	20 18       	sub	r8,1
80005c12:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005c16:	58 08       	cp.w	r8,0
80005c18:	fe 99 ff f2 	brgt	80005bfc <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005c1c:	3f f8       	mov	r8,-1
80005c1e:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80005c22:	f0 1f 00 06 	mcall	80005c38 <prvUnlockQueue+0x9c>
}
80005c26:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005c2a:	00 00       	add	r0,r0
80005c2c:	80 00       	ld.sh	r0,r0[0x0]
80005c2e:	58 88       	cp.w	r8,8
80005c30:	80 00       	ld.sh	r0,r0[0x0]
80005c32:	61 54       	ld.w	r4,r0[0x54]
80005c34:	80 00       	ld.sh	r0,r0[0x0]
80005c36:	60 60       	ld.w	r0,r0[0x18]
80005c38:	80 00       	ld.sh	r0,r0[0x0]
80005c3a:	59 94       	cp.w	r4,25

80005c3c <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005c3c:	d4 31       	pushm	r0-r7,lr
80005c3e:	20 5d       	sub	sp,20
80005c40:	18 97       	mov	r7,r12
80005c42:	50 0b       	stdsp	sp[0x0],r11
80005c44:	50 2a       	stdsp	sp[0x8],r10
80005c46:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005c48:	f8 c2 ff dc 	sub	r2,r12,-36
80005c4c:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005c4e:	fa c4 ff f4 	sub	r4,sp,-12
80005c52:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005c54:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005c56:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80005c5a:	f0 1f 00 3e 	mcall	80005d50 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005c5e:	6e e8       	ld.w	r8,r7[0x38]
80005c60:	58 08       	cp.w	r8,0
80005c62:	c2 a0       	breq	80005cb6 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80005c64:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80005c66:	40 0b       	lddsp	r11,sp[0x0]
80005c68:	0e 9c       	mov	r12,r7
80005c6a:	f0 1f 00 3b 	mcall	80005d54 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80005c6e:	40 18       	lddsp	r8,sp[0x4]
80005c70:	58 08       	cp.w	r8,0
80005c72:	c1 51       	brne	80005c9c <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80005c74:	6e e8       	ld.w	r8,r7[0x38]
80005c76:	20 18       	sub	r8,1
80005c78:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005c7a:	6e 08       	ld.w	r8,r7[0x0]
80005c7c:	58 08       	cp.w	r8,0
80005c7e:	c0 41       	brne	80005c86 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80005c80:	f0 1f 00 36 	mcall	80005d58 <xQueueGenericReceive+0x11c>
80005c84:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005c86:	6e 48       	ld.w	r8,r7[0x10]
80005c88:	58 08       	cp.w	r8,0
80005c8a:	c1 20       	breq	80005cae <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80005c8c:	ee cc ff f0 	sub	r12,r7,-16
80005c90:	f0 1f 00 33 	mcall	80005d5c <xQueueGenericReceive+0x120>
80005c94:	58 1c       	cp.w	r12,1
80005c96:	c0 c1       	brne	80005cae <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80005c98:	d7 33       	scall
80005c9a:	c0 a8       	rjmp	80005cae <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80005c9c:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005c9e:	6e 98       	ld.w	r8,r7[0x24]
80005ca0:	58 08       	cp.w	r8,0
80005ca2:	c0 60       	breq	80005cae <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005ca4:	04 9c       	mov	r12,r2
80005ca6:	f0 1f 00 2e 	mcall	80005d5c <xQueueGenericReceive+0x120>
80005caa:	c0 20       	breq	80005cae <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80005cac:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80005cae:	f0 1f 00 2d 	mcall	80005d60 <xQueueGenericReceive+0x124>
80005cb2:	30 1c       	mov	r12,1
				return pdPASS;
80005cb4:	c4 c8       	rjmp	80005d4c <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005cb6:	40 28       	lddsp	r8,sp[0x8]
80005cb8:	58 08       	cp.w	r8,0
80005cba:	c0 51       	brne	80005cc4 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005cbc:	f0 1f 00 29 	mcall	80005d60 <xQueueGenericReceive+0x124>
80005cc0:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80005cc2:	c4 58       	rjmp	80005d4c <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80005cc4:	58 05       	cp.w	r5,0
80005cc6:	c0 51       	brne	80005cd0 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005cc8:	08 9c       	mov	r12,r4
80005cca:	f0 1f 00 27 	mcall	80005d64 <xQueueGenericReceive+0x128>
80005cce:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005cd0:	f0 1f 00 24 	mcall	80005d60 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005cd4:	f0 1f 00 25 	mcall	80005d68 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005cd8:	f0 1f 00 1e 	mcall	80005d50 <xQueueGenericReceive+0x114>
80005cdc:	6f 18       	ld.w	r8,r7[0x44]
80005cde:	5b f8       	cp.w	r8,-1
80005ce0:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005ce4:	6f 28       	ld.w	r8,r7[0x48]
80005ce6:	5b f8       	cp.w	r8,-1
80005ce8:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005cec:	f0 1f 00 1d 	mcall	80005d60 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005cf0:	06 9b       	mov	r11,r3
80005cf2:	08 9c       	mov	r12,r4
80005cf4:	f0 1f 00 1e 	mcall	80005d6c <xQueueGenericReceive+0x130>
80005cf8:	c2 41       	brne	80005d40 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005cfa:	f0 1f 00 16 	mcall	80005d50 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005cfe:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80005d00:	f0 1f 00 18 	mcall	80005d60 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80005d04:	58 06       	cp.w	r6,0
80005d06:	c1 71       	brne	80005d34 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005d08:	6e 08       	ld.w	r8,r7[0x0]
80005d0a:	58 08       	cp.w	r8,0
80005d0c:	c0 81       	brne	80005d1c <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80005d0e:	f0 1f 00 11 	mcall	80005d50 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80005d12:	6e 1c       	ld.w	r12,r7[0x4]
80005d14:	f0 1f 00 17 	mcall	80005d70 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80005d18:	f0 1f 00 12 	mcall	80005d60 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005d1c:	40 2b       	lddsp	r11,sp[0x8]
80005d1e:	04 9c       	mov	r12,r2
80005d20:	f0 1f 00 15 	mcall	80005d74 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80005d24:	0e 9c       	mov	r12,r7
80005d26:	f0 1f 00 15 	mcall	80005d78 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80005d2a:	f0 1f 00 15 	mcall	80005d7c <xQueueGenericReceive+0x140>
80005d2e:	c9 61       	brne	80005c5a <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80005d30:	d7 33       	scall
80005d32:	c9 4b       	rjmp	80005c5a <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005d34:	0e 9c       	mov	r12,r7
80005d36:	f0 1f 00 11 	mcall	80005d78 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80005d3a:	f0 1f 00 11 	mcall	80005d7c <xQueueGenericReceive+0x140>
80005d3e:	c8 eb       	rjmp	80005c5a <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80005d40:	0e 9c       	mov	r12,r7
80005d42:	f0 1f 00 0e 	mcall	80005d78 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80005d46:	f0 1f 00 0e 	mcall	80005d7c <xQueueGenericReceive+0x140>
80005d4a:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80005d4c:	2f bd       	sub	sp,-20
80005d4e:	d8 32       	popm	r0-r7,pc
80005d50:	80 00       	ld.sh	r0,r0[0x0]
80005d52:	58 88       	cp.w	r8,8
80005d54:	80 00       	ld.sh	r0,r0[0x0]
80005d56:	5b 1c       	cp.w	r12,-15
80005d58:	80 00       	ld.sh	r0,r0[0x0]
80005d5a:	60 6c       	ld.w	r12,r0[0x18]
80005d5c:	80 00       	ld.sh	r0,r0[0x0]
80005d5e:	61 54       	ld.w	r4,r0[0x54]
80005d60:	80 00       	ld.sh	r0,r0[0x0]
80005d62:	59 94       	cp.w	r4,25
80005d64:	80 00       	ld.sh	r0,r0[0x0]
80005d66:	60 48       	ld.w	r8,r0[0x10]
80005d68:	80 00       	ld.sh	r0,r0[0x0]
80005d6a:	5f bc       	srhi	r12
80005d6c:	80 00       	ld.sh	r0,r0[0x0]
80005d6e:	62 e4       	ld.w	r4,r1[0x38]
80005d70:	80 00       	ld.sh	r0,r0[0x0]
80005d72:	60 d0       	ld.w	r0,r0[0x34]
80005d74:	80 00       	ld.sh	r0,r0[0x0]
80005d76:	65 3c       	ld.w	r12,r2[0x4c]
80005d78:	80 00       	ld.sh	r0,r0[0x0]
80005d7a:	5b 9c       	cp.w	r12,-7
80005d7c:	80 00       	ld.sh	r0,r0[0x0]
80005d7e:	63 78       	ld.w	r8,r1[0x5c]

80005d80 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80005d80:	eb cd 40 80 	pushm	r7,lr
80005d84:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80005d86:	79 08       	ld.w	r8,r12[0x40]
80005d88:	58 08       	cp.w	r8,0
80005d8a:	c0 a1       	brne	80005d9e <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005d8c:	78 08       	ld.w	r8,r12[0x0]
80005d8e:	58 08       	cp.w	r8,0
80005d90:	c2 b1       	brne	80005de6 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80005d92:	78 1c       	ld.w	r12,r12[0x4]
80005d94:	f0 1f 00 17 	mcall	80005df0 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80005d98:	30 08       	mov	r8,0
80005d9a:	8f 18       	st.w	r7[0x4],r8
80005d9c:	c2 58       	rjmp	80005de6 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80005d9e:	58 0a       	cp.w	r10,0
80005da0:	c1 01       	brne	80005dc0 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005da2:	10 9a       	mov	r10,r8
80005da4:	78 2c       	ld.w	r12,r12[0x8]
80005da6:	f0 1f 00 14 	mcall	80005df4 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80005daa:	6e 29       	ld.w	r9,r7[0x8]
80005dac:	6f 08       	ld.w	r8,r7[0x40]
80005dae:	f2 08 00 08 	add	r8,r9,r8
80005db2:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80005db4:	6e 19       	ld.w	r9,r7[0x4]
80005db6:	12 38       	cp.w	r8,r9
80005db8:	c1 73       	brcs	80005de6 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80005dba:	6e 08       	ld.w	r8,r7[0x0]
80005dbc:	8f 28       	st.w	r7[0x8],r8
80005dbe:	c1 48       	rjmp	80005de6 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005dc0:	10 9a       	mov	r10,r8
80005dc2:	78 3c       	ld.w	r12,r12[0xc]
80005dc4:	f0 1f 00 0c 	mcall	80005df4 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005dc8:	6f 08       	ld.w	r8,r7[0x40]
80005dca:	6e 39       	ld.w	r9,r7[0xc]
80005dcc:	f2 08 01 08 	sub	r8,r9,r8
80005dd0:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80005dd2:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80005dd4:	12 38       	cp.w	r8,r9
80005dd6:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80005dda:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80005dde:	f3 d8 e3 19 	subcs	r9,r9,r8
80005de2:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80005de6:	6e e8       	ld.w	r8,r7[0x38]
80005de8:	2f f8       	sub	r8,-1
80005dea:	8f e8       	st.w	r7[0x38],r8
}
80005dec:	e3 cd 80 80 	ldm	sp++,r7,pc
80005df0:	80 00       	ld.sh	r0,r0[0x0]
80005df2:	60 78       	ld.w	r8,r0[0x1c]
80005df4:	80 00       	ld.sh	r0,r0[0x0]
80005df6:	72 74       	ld.w	r4,r9[0x1c]

80005df8 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80005df8:	eb cd 40 c0 	pushm	r6-r7,lr
80005dfc:	18 97       	mov	r7,r12
80005dfe:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005e00:	78 ec       	ld.w	r12,r12[0x38]
80005e02:	6e f8       	ld.w	r8,r7[0x3c]
80005e04:	10 3c       	cp.w	r12,r8
80005e06:	c0 33       	brcs	80005e0c <xQueueGenericSendFromISR+0x14>
80005e08:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005e0c:	12 9a       	mov	r10,r9
80005e0e:	0e 9c       	mov	r12,r7
80005e10:	f0 1f 00 0c 	mcall	80005e40 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80005e14:	6f 28       	ld.w	r8,r7[0x48]
80005e16:	5b f8       	cp.w	r8,-1
80005e18:	c0 d1       	brne	80005e32 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005e1a:	6e 98       	ld.w	r8,r7[0x24]
80005e1c:	58 08       	cp.w	r8,0
80005e1e:	c0 f0       	breq	80005e3c <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005e20:	ee cc ff dc 	sub	r12,r7,-36
80005e24:	f0 1f 00 08 	mcall	80005e44 <xQueueGenericSendFromISR+0x4c>
80005e28:	c0 a0       	breq	80005e3c <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80005e2a:	30 1c       	mov	r12,1
80005e2c:	8d 0c       	st.w	r6[0x0],r12
80005e2e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80005e32:	2f f8       	sub	r8,-1
80005e34:	ef 48 00 48 	st.w	r7[72],r8
80005e38:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005e3c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005e40:	80 00       	ld.sh	r0,r0[0x0]
80005e42:	5d 80       	*unknown*
80005e44:	80 00       	ld.sh	r0,r0[0x0]
80005e46:	61 54       	ld.w	r4,r0[0x54]

80005e48 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80005e48:	d4 31       	pushm	r0-r7,lr
80005e4a:	20 5d       	sub	sp,20
80005e4c:	18 97       	mov	r7,r12
80005e4e:	50 0b       	stdsp	sp[0x0],r11
80005e50:	50 2a       	stdsp	sp[0x8],r10
80005e52:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005e54:	f8 c0 ff f0 	sub	r0,r12,-16
80005e58:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005e5a:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005e5e:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005e60:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80005e64:	f0 1f 00 2f 	mcall	80005f20 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005e68:	6e e9       	ld.w	r9,r7[0x38]
80005e6a:	6e f8       	ld.w	r8,r7[0x3c]
80005e6c:	10 39       	cp.w	r9,r8
80005e6e:	c1 42       	brcc	80005e96 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005e70:	40 1a       	lddsp	r10,sp[0x4]
80005e72:	40 0b       	lddsp	r11,sp[0x0]
80005e74:	0e 9c       	mov	r12,r7
80005e76:	f0 1f 00 2c 	mcall	80005f24 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005e7a:	6e 98       	ld.w	r8,r7[0x24]
80005e7c:	58 08       	cp.w	r8,0
80005e7e:	c0 80       	breq	80005e8e <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80005e80:	ee cc ff dc 	sub	r12,r7,-36
80005e84:	f0 1f 00 29 	mcall	80005f28 <xQueueGenericSend+0xe0>
80005e88:	58 1c       	cp.w	r12,1
80005e8a:	c0 21       	brne	80005e8e <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80005e8c:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80005e8e:	f0 1f 00 28 	mcall	80005f2c <xQueueGenericSend+0xe4>
80005e92:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80005e94:	c4 38       	rjmp	80005f1a <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005e96:	40 28       	lddsp	r8,sp[0x8]
80005e98:	58 08       	cp.w	r8,0
80005e9a:	c0 51       	brne	80005ea4 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005e9c:	f0 1f 00 24 	mcall	80005f2c <xQueueGenericSend+0xe4>
80005ea0:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80005ea2:	c3 c8       	rjmp	80005f1a <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80005ea4:	58 04       	cp.w	r4,0
80005ea6:	c0 51       	brne	80005eb0 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005ea8:	06 9c       	mov	r12,r3
80005eaa:	f0 1f 00 22 	mcall	80005f30 <xQueueGenericSend+0xe8>
80005eae:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005eb0:	f0 1f 00 1f 	mcall	80005f2c <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005eb4:	f0 1f 00 20 	mcall	80005f34 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80005eb8:	f0 1f 00 1a 	mcall	80005f20 <xQueueGenericSend+0xd8>
80005ebc:	6f 18       	ld.w	r8,r7[0x44]
80005ebe:	5b f8       	cp.w	r8,-1
80005ec0:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005ec4:	6f 28       	ld.w	r8,r7[0x48]
80005ec6:	5b f8       	cp.w	r8,-1
80005ec8:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005ecc:	f0 1f 00 18 	mcall	80005f2c <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005ed0:	04 9b       	mov	r11,r2
80005ed2:	06 9c       	mov	r12,r3
80005ed4:	f0 1f 00 19 	mcall	80005f38 <xQueueGenericSend+0xf0>
80005ed8:	c1 b1       	brne	80005f0e <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005eda:	f0 1f 00 12 	mcall	80005f20 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005ede:	6e e5       	ld.w	r5,r7[0x38]
80005ee0:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80005ee2:	f0 1f 00 13 	mcall	80005f2c <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80005ee6:	0c 35       	cp.w	r5,r6
80005ee8:	c0 d1       	brne	80005f02 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005eea:	40 2b       	lddsp	r11,sp[0x8]
80005eec:	00 9c       	mov	r12,r0
80005eee:	f0 1f 00 14 	mcall	80005f3c <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80005ef2:	0e 9c       	mov	r12,r7
80005ef4:	f0 1f 00 13 	mcall	80005f40 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80005ef8:	f0 1f 00 13 	mcall	80005f44 <xQueueGenericSend+0xfc>
80005efc:	cb 41       	brne	80005e64 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80005efe:	d7 33       	scall
80005f00:	cb 2b       	rjmp	80005e64 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005f02:	0e 9c       	mov	r12,r7
80005f04:	f0 1f 00 0f 	mcall	80005f40 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80005f08:	f0 1f 00 0f 	mcall	80005f44 <xQueueGenericSend+0xfc>
80005f0c:	ca cb       	rjmp	80005e64 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80005f0e:	0e 9c       	mov	r12,r7
80005f10:	f0 1f 00 0c 	mcall	80005f40 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80005f14:	f0 1f 00 0c 	mcall	80005f44 <xQueueGenericSend+0xfc>
80005f18:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80005f1a:	2f bd       	sub	sp,-20
80005f1c:	d8 32       	popm	r0-r7,pc
80005f1e:	00 00       	add	r0,r0
80005f20:	80 00       	ld.sh	r0,r0[0x0]
80005f22:	58 88       	cp.w	r8,8
80005f24:	80 00       	ld.sh	r0,r0[0x0]
80005f26:	5d 80       	*unknown*
80005f28:	80 00       	ld.sh	r0,r0[0x0]
80005f2a:	61 54       	ld.w	r4,r0[0x54]
80005f2c:	80 00       	ld.sh	r0,r0[0x0]
80005f2e:	59 94       	cp.w	r4,25
80005f30:	80 00       	ld.sh	r0,r0[0x0]
80005f32:	60 48       	ld.w	r8,r0[0x10]
80005f34:	80 00       	ld.sh	r0,r0[0x0]
80005f36:	5f bc       	srhi	r12
80005f38:	80 00       	ld.sh	r0,r0[0x0]
80005f3a:	62 e4       	ld.w	r4,r1[0x38]
80005f3c:	80 00       	ld.sh	r0,r0[0x0]
80005f3e:	65 3c       	ld.w	r12,r2[0x4c]
80005f40:	80 00       	ld.sh	r0,r0[0x0]
80005f42:	5b 9c       	cp.w	r12,-7
80005f44:	80 00       	ld.sh	r0,r0[0x0]
80005f46:	63 78       	ld.w	r8,r1[0x5c]

80005f48 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80005f48:	d4 21       	pushm	r4-r7,lr
80005f4a:	18 97       	mov	r7,r12
80005f4c:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80005f4e:	58 0c       	cp.w	r12,0
80005f50:	c2 f0       	breq	80005fae <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005f52:	34 cc       	mov	r12,76
80005f54:	f0 1f 00 17 	mcall	80005fb0 <xQueueCreate+0x68>
80005f58:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80005f5a:	c2 a0       	breq	80005fae <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80005f5c:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80005f60:	e8 cc ff ff 	sub	r12,r4,-1
80005f64:	f0 1f 00 13 	mcall	80005fb0 <xQueueCreate+0x68>
80005f68:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80005f6a:	c1 e0       	breq	80005fa6 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80005f6c:	f8 04 00 04 	add	r4,r12,r4
80005f70:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005f72:	30 08       	mov	r8,0
80005f74:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80005f76:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80005f78:	ee c8 00 01 	sub	r8,r7,1
80005f7c:	ad 38       	mul	r8,r6
80005f7e:	10 0c       	add	r12,r8
80005f80:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80005f82:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80005f84:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80005f88:	3f f8       	mov	r8,-1
80005f8a:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80005f8e:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005f92:	ea cc ff f0 	sub	r12,r5,-16
80005f96:	f0 1f 00 08 	mcall	80005fb4 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005f9a:	ea cc ff dc 	sub	r12,r5,-36
80005f9e:	f0 1f 00 06 	mcall	80005fb4 <xQueueCreate+0x6c>
80005fa2:	0a 9c       	mov	r12,r5
80005fa4:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80005fa6:	0a 9c       	mov	r12,r5
80005fa8:	f0 1f 00 04 	mcall	80005fb8 <xQueueCreate+0x70>
80005fac:	d8 2a       	popm	r4-r7,pc,r12=0
80005fae:	d8 2a       	popm	r4-r7,pc,r12=0
80005fb0:	80 00       	ld.sh	r0,r0[0x0]
80005fb2:	5a f4       	cp.w	r4,-17
80005fb4:	80 00       	ld.sh	r0,r0[0x0]
80005fb6:	57 64       	stdsp	sp[0x1d8],r4
80005fb8:	80 00       	ld.sh	r0,r0[0x0]
80005fba:	5a cc       	cp.w	r12,-20

80005fbc <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80005fbc:	48 38       	lddpc	r8,80005fc8 <vTaskSuspendAll+0xc>
80005fbe:	70 09       	ld.w	r9,r8[0x0]
80005fc0:	2f f9       	sub	r9,-1
80005fc2:	91 09       	st.w	r8[0x0],r9
}
80005fc4:	5e fc       	retal	r12
80005fc6:	00 00       	add	r0,r0
80005fc8:	00 00       	add	r0,r0
80005fca:	0d 1c       	ld.sh	r12,r6++

80005fcc <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80005fcc:	49 a8       	lddpc	r8,80006034 <vTaskSwitchContext+0x68>
80005fce:	70 08       	ld.w	r8,r8[0x0]
80005fd0:	58 08       	cp.w	r8,0
80005fd2:	c0 b1       	brne	80005fe8 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005fd4:	49 98       	lddpc	r8,80006038 <vTaskSwitchContext+0x6c>
80005fd6:	70 08       	ld.w	r8,r8[0x0]
80005fd8:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005fdc:	49 89       	lddpc	r9,8000603c <vTaskSwitchContext+0x70>
80005fde:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80005fe2:	58 08       	cp.w	r8,0
80005fe4:	c0 60       	breq	80005ff0 <vTaskSwitchContext+0x24>
80005fe6:	c1 18       	rjmp	80006008 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005fe8:	30 19       	mov	r9,1
80005fea:	49 68       	lddpc	r8,80006040 <vTaskSwitchContext+0x74>
80005fec:	91 09       	st.w	r8[0x0],r9
80005fee:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005ff0:	49 28       	lddpc	r8,80006038 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005ff2:	49 3a       	lddpc	r10,8000603c <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005ff4:	70 09       	ld.w	r9,r8[0x0]
80005ff6:	20 19       	sub	r9,1
80005ff8:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005ffa:	70 09       	ld.w	r9,r8[0x0]
80005ffc:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006000:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80006004:	58 09       	cp.w	r9,0
80006006:	cf 70       	breq	80005ff4 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80006008:	48 c8       	lddpc	r8,80006038 <vTaskSwitchContext+0x6c>
8000600a:	70 08       	ld.w	r8,r8[0x0]
8000600c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006010:	48 b9       	lddpc	r9,8000603c <vTaskSwitchContext+0x70>
80006012:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006016:	70 19       	ld.w	r9,r8[0x4]
80006018:	72 19       	ld.w	r9,r9[0x4]
8000601a:	91 19       	st.w	r8[0x4],r9
8000601c:	f0 ca ff f8 	sub	r10,r8,-8
80006020:	14 39       	cp.w	r9,r10
80006022:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80006026:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000602a:	70 18       	ld.w	r8,r8[0x4]
8000602c:	70 39       	ld.w	r9,r8[0xc]
8000602e:	48 68       	lddpc	r8,80006044 <vTaskSwitchContext+0x78>
80006030:	91 09       	st.w	r8[0x0],r9
80006032:	5e fc       	retal	r12
80006034:	00 00       	add	r0,r0
80006036:	0d 1c       	ld.sh	r12,r6++
80006038:	00 00       	add	r0,r0
8000603a:	0d 54       	ld.sh	r4,--r6
8000603c:	00 00       	add	r0,r0
8000603e:	0c 38       	cp.w	r8,r6
80006040:	00 00       	add	r0,r0
80006042:	0d 3c       	ld.ub	r12,r6++
80006044:	00 00       	add	r0,r0
80006046:	0c ec       	st.h	--r6,r12

80006048 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80006048:	48 48       	lddpc	r8,80006058 <vTaskSetTimeOutState+0x10>
8000604a:	70 08       	ld.w	r8,r8[0x0]
8000604c:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
8000604e:	48 48       	lddpc	r8,8000605c <vTaskSetTimeOutState+0x14>
80006050:	70 08       	ld.w	r8,r8[0x0]
80006052:	99 18       	st.w	r12[0x4],r8
}
80006054:	5e fc       	retal	r12
80006056:	00 00       	add	r0,r0
80006058:	00 00       	add	r0,r0
8000605a:	0c 30       	cp.w	r0,r6
8000605c:	00 00       	add	r0,r0
8000605e:	0d 18       	ld.sh	r8,r6++

80006060 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80006060:	30 19       	mov	r9,1
80006062:	48 28       	lddpc	r8,80006068 <vTaskMissedYield+0x8>
80006064:	91 09       	st.w	r8[0x0],r9
}
80006066:	5e fc       	retal	r12
80006068:	00 00       	add	r0,r0
8000606a:	0d 3c       	ld.ub	r12,r6++

8000606c <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
8000606c:	48 28       	lddpc	r8,80006074 <xTaskGetCurrentTaskHandle+0x8>
8000606e:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006070:	5e fc       	retal	r12
80006072:	00 00       	add	r0,r0
80006074:	00 00       	add	r0,r0
80006076:	0c ec       	st.h	--r6,r12

80006078 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80006078:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
8000607c:	58 0c       	cp.w	r12,0
8000607e:	c1 f0       	breq	800060bc <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80006080:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80006082:	78 b9       	ld.w	r9,r12[0x2c]
80006084:	79 18       	ld.w	r8,r12[0x44]
80006086:	10 39       	cp.w	r9,r8
80006088:	c1 a0       	breq	800060bc <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000608a:	f8 c6 ff fc 	sub	r6,r12,-4
8000608e:	0c 9c       	mov	r12,r6
80006090:	f0 1f 00 0c 	mcall	800060c0 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80006094:	6f 1c       	ld.w	r12,r7[0x44]
80006096:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80006098:	f8 08 11 08 	rsub	r8,r12,8
8000609c:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
8000609e:	48 a8       	lddpc	r8,800060c4 <vTaskPriorityDisinherit+0x4c>
800060a0:	70 08       	ld.w	r8,r8[0x0]
800060a2:	10 3c       	cp.w	r12,r8
800060a4:	e0 88 00 04 	brls	800060ac <vTaskPriorityDisinherit+0x34>
800060a8:	48 78       	lddpc	r8,800060c4 <vTaskPriorityDisinherit+0x4c>
800060aa:	91 0c       	st.w	r8[0x0],r12
800060ac:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800060b0:	0c 9b       	mov	r11,r6
800060b2:	48 68       	lddpc	r8,800060c8 <vTaskPriorityDisinherit+0x50>
800060b4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800060b8:	f0 1f 00 05 	mcall	800060cc <vTaskPriorityDisinherit+0x54>
800060bc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800060c0:	80 00       	ld.sh	r0,r0[0x0]
800060c2:	57 ce       	stdsp	sp[0x1f0],lr
800060c4:	00 00       	add	r0,r0
800060c6:	0d 54       	ld.sh	r4,--r6
800060c8:	00 00       	add	r0,r0
800060ca:	0c 38       	cp.w	r8,r6
800060cc:	80 00       	ld.sh	r0,r0[0x0]
800060ce:	57 7e       	stdsp	sp[0x1dc],lr

800060d0 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800060d0:	eb cd 40 c0 	pushm	r6-r7,lr
800060d4:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
800060d6:	49 b8       	lddpc	r8,80006140 <vTaskPriorityInherit+0x70>
800060d8:	70 08       	ld.w	r8,r8[0x0]
800060da:	78 b9       	ld.w	r9,r12[0x2c]
800060dc:	70 b8       	ld.w	r8,r8[0x2c]
800060de:	10 39       	cp.w	r9,r8
800060e0:	c2 d2       	brcc	8000613a <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800060e2:	49 88       	lddpc	r8,80006140 <vTaskPriorityInherit+0x70>
800060e4:	70 08       	ld.w	r8,r8[0x0]
800060e6:	70 b8       	ld.w	r8,r8[0x2c]
800060e8:	f0 08 11 08 	rsub	r8,r8,8
800060ec:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800060ee:	f2 09 00 28 	add	r8,r9,r9<<0x2
800060f2:	49 59       	lddpc	r9,80006144 <vTaskPriorityInherit+0x74>
800060f4:	f2 08 00 28 	add	r8,r9,r8<<0x2
800060f8:	78 59       	ld.w	r9,r12[0x14]
800060fa:	10 39       	cp.w	r9,r8
800060fc:	c1 b1       	brne	80006132 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800060fe:	f8 c6 ff fc 	sub	r6,r12,-4
80006102:	0c 9c       	mov	r12,r6
80006104:	f0 1f 00 11 	mcall	80006148 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006108:	48 e8       	lddpc	r8,80006140 <vTaskPriorityInherit+0x70>
8000610a:	70 08       	ld.w	r8,r8[0x0]
8000610c:	70 bc       	ld.w	r12,r8[0x2c]
8000610e:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80006110:	48 f8       	lddpc	r8,8000614c <vTaskPriorityInherit+0x7c>
80006112:	70 08       	ld.w	r8,r8[0x0]
80006114:	10 3c       	cp.w	r12,r8
80006116:	e0 88 00 04 	brls	8000611e <vTaskPriorityInherit+0x4e>
8000611a:	48 d8       	lddpc	r8,8000614c <vTaskPriorityInherit+0x7c>
8000611c:	91 0c       	st.w	r8[0x0],r12
8000611e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006122:	0c 9b       	mov	r11,r6
80006124:	48 88       	lddpc	r8,80006144 <vTaskPriorityInherit+0x74>
80006126:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000612a:	f0 1f 00 0a 	mcall	80006150 <vTaskPriorityInherit+0x80>
8000612e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006132:	48 48       	lddpc	r8,80006140 <vTaskPriorityInherit+0x70>
80006134:	70 08       	ld.w	r8,r8[0x0]
80006136:	70 b8       	ld.w	r8,r8[0x2c]
80006138:	99 b8       	st.w	r12[0x2c],r8
8000613a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000613e:	00 00       	add	r0,r0
80006140:	00 00       	add	r0,r0
80006142:	0c ec       	st.h	--r6,r12
80006144:	00 00       	add	r0,r0
80006146:	0c 38       	cp.w	r8,r6
80006148:	80 00       	ld.sh	r0,r0[0x0]
8000614a:	57 ce       	stdsp	sp[0x1f0],lr
8000614c:	00 00       	add	r0,r0
8000614e:	0d 54       	ld.sh	r4,--r6
80006150:	80 00       	ld.sh	r0,r0[0x0]
80006152:	57 7e       	stdsp	sp[0x1dc],lr

80006154 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80006154:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80006158:	78 38       	ld.w	r8,r12[0xc]
8000615a:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
8000615c:	ee c6 ff e8 	sub	r6,r7,-24
80006160:	0c 9c       	mov	r12,r6
80006162:	f0 1f 00 15 	mcall	800061b4 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006166:	49 58       	lddpc	r8,800061b8 <xTaskRemoveFromEventList+0x64>
80006168:	70 08       	ld.w	r8,r8[0x0]
8000616a:	58 08       	cp.w	r8,0
8000616c:	c1 71       	brne	8000619a <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
8000616e:	ee c6 ff fc 	sub	r6,r7,-4
80006172:	0c 9c       	mov	r12,r6
80006174:	f0 1f 00 10 	mcall	800061b4 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80006178:	6e bc       	ld.w	r12,r7[0x2c]
8000617a:	49 18       	lddpc	r8,800061bc <xTaskRemoveFromEventList+0x68>
8000617c:	70 08       	ld.w	r8,r8[0x0]
8000617e:	10 3c       	cp.w	r12,r8
80006180:	e0 88 00 04 	brls	80006188 <xTaskRemoveFromEventList+0x34>
80006184:	48 e8       	lddpc	r8,800061bc <xTaskRemoveFromEventList+0x68>
80006186:	91 0c       	st.w	r8[0x0],r12
80006188:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000618c:	0c 9b       	mov	r11,r6
8000618e:	48 d8       	lddpc	r8,800061c0 <xTaskRemoveFromEventList+0x6c>
80006190:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006194:	f0 1f 00 0c 	mcall	800061c4 <xTaskRemoveFromEventList+0x70>
80006198:	c0 58       	rjmp	800061a2 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000619a:	0c 9b       	mov	r11,r6
8000619c:	48 bc       	lddpc	r12,800061c8 <xTaskRemoveFromEventList+0x74>
8000619e:	f0 1f 00 0a 	mcall	800061c4 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800061a2:	48 b8       	lddpc	r8,800061cc <xTaskRemoveFromEventList+0x78>
800061a4:	70 08       	ld.w	r8,r8[0x0]
800061a6:	6e b9       	ld.w	r9,r7[0x2c]
800061a8:	70 b8       	ld.w	r8,r8[0x2c]
800061aa:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
800061ac:	5f 2c       	srhs	r12
800061ae:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800061b2:	00 00       	add	r0,r0
800061b4:	80 00       	ld.sh	r0,r0[0x0]
800061b6:	57 ce       	stdsp	sp[0x1f0],lr
800061b8:	00 00       	add	r0,r0
800061ba:	0d 1c       	ld.sh	r12,r6++
800061bc:	00 00       	add	r0,r0
800061be:	0d 54       	ld.sh	r4,--r6
800061c0:	00 00       	add	r0,r0
800061c2:	0c 38       	cp.w	r8,r6
800061c4:	80 00       	ld.sh	r0,r0[0x0]
800061c6:	57 7e       	stdsp	sp[0x1dc],lr
800061c8:	00 00       	add	r0,r0
800061ca:	0c f0       	st.b	--r6,r0
800061cc:	00 00       	add	r0,r0
800061ce:	0c ec       	st.h	--r6,r12

800061d0 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800061d0:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800061d4:	4b 98       	lddpc	r8,800062b8 <vTaskIncrementTick+0xe8>
800061d6:	70 08       	ld.w	r8,r8[0x0]
800061d8:	58 08       	cp.w	r8,0
800061da:	c6 91       	brne	800062ac <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800061dc:	4b 88       	lddpc	r8,800062bc <vTaskIncrementTick+0xec>
800061de:	70 09       	ld.w	r9,r8[0x0]
800061e0:	2f f9       	sub	r9,-1
800061e2:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800061e4:	70 08       	ld.w	r8,r8[0x0]
800061e6:	58 08       	cp.w	r8,0
800061e8:	c1 a1       	brne	8000621c <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800061ea:	4b 68       	lddpc	r8,800062c0 <vTaskIncrementTick+0xf0>
800061ec:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800061ee:	4b 69       	lddpc	r9,800062c4 <vTaskIncrementTick+0xf4>
800061f0:	72 0b       	ld.w	r11,r9[0x0]
800061f2:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800061f4:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800061f6:	4b 59       	lddpc	r9,800062c8 <vTaskIncrementTick+0xf8>
800061f8:	72 0a       	ld.w	r10,r9[0x0]
800061fa:	2f fa       	sub	r10,-1
800061fc:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800061fe:	70 08       	ld.w	r8,r8[0x0]
80006200:	70 08       	ld.w	r8,r8[0x0]
80006202:	58 08       	cp.w	r8,0
80006204:	c0 51       	brne	8000620e <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80006206:	3f f9       	mov	r9,-1
80006208:	4b 18       	lddpc	r8,800062cc <vTaskIncrementTick+0xfc>
8000620a:	91 09       	st.w	r8[0x0],r9
8000620c:	c0 88       	rjmp	8000621c <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
8000620e:	4a d8       	lddpc	r8,800062c0 <vTaskIncrementTick+0xf0>
80006210:	70 08       	ld.w	r8,r8[0x0]
80006212:	70 38       	ld.w	r8,r8[0xc]
80006214:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80006216:	70 19       	ld.w	r9,r8[0x4]
80006218:	4a d8       	lddpc	r8,800062cc <vTaskIncrementTick+0xfc>
8000621a:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
8000621c:	4a 88       	lddpc	r8,800062bc <vTaskIncrementTick+0xec>
8000621e:	70 09       	ld.w	r9,r8[0x0]
80006220:	4a b8       	lddpc	r8,800062cc <vTaskIncrementTick+0xfc>
80006222:	70 08       	ld.w	r8,r8[0x0]
80006224:	10 39       	cp.w	r9,r8
80006226:	c4 73       	brcs	800062b4 <vTaskIncrementTick+0xe4>
80006228:	4a 68       	lddpc	r8,800062c0 <vTaskIncrementTick+0xf0>
8000622a:	70 08       	ld.w	r8,r8[0x0]
8000622c:	70 08       	ld.w	r8,r8[0x0]
8000622e:	58 08       	cp.w	r8,0
80006230:	c0 c0       	breq	80006248 <vTaskIncrementTick+0x78>
80006232:	4a 48       	lddpc	r8,800062c0 <vTaskIncrementTick+0xf0>
80006234:	70 08       	ld.w	r8,r8[0x0]
80006236:	70 38       	ld.w	r8,r8[0xc]
80006238:	70 37       	ld.w	r7,r8[0xc]
8000623a:	6e 18       	ld.w	r8,r7[0x4]
8000623c:	4a 09       	lddpc	r9,800062bc <vTaskIncrementTick+0xec>
8000623e:	72 09       	ld.w	r9,r9[0x0]
80006240:	12 38       	cp.w	r8,r9
80006242:	e0 88 00 14 	brls	8000626a <vTaskIncrementTick+0x9a>
80006246:	c0 e8       	rjmp	80006262 <vTaskIncrementTick+0x92>
80006248:	3f f9       	mov	r9,-1
8000624a:	4a 18       	lddpc	r8,800062cc <vTaskIncrementTick+0xfc>
8000624c:	91 09       	st.w	r8[0x0],r9
8000624e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006252:	6a 08       	ld.w	r8,r5[0x0]
80006254:	70 38       	ld.w	r8,r8[0xc]
80006256:	70 37       	ld.w	r7,r8[0xc]
80006258:	6e 18       	ld.w	r8,r7[0x4]
8000625a:	64 09       	ld.w	r9,r2[0x0]
8000625c:	12 38       	cp.w	r8,r9
8000625e:	e0 88 00 0a 	brls	80006272 <vTaskIncrementTick+0xa2>
80006262:	49 b9       	lddpc	r9,800062cc <vTaskIncrementTick+0xfc>
80006264:	93 08       	st.w	r9[0x0],r8
80006266:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000626a:	49 a4       	lddpc	r4,800062d0 <vTaskIncrementTick+0x100>
8000626c:	49 a3       	lddpc	r3,800062d4 <vTaskIncrementTick+0x104>
8000626e:	49 55       	lddpc	r5,800062c0 <vTaskIncrementTick+0xf0>
80006270:	49 32       	lddpc	r2,800062bc <vTaskIncrementTick+0xec>
80006272:	ee c6 ff fc 	sub	r6,r7,-4
80006276:	0c 9c       	mov	r12,r6
80006278:	f0 1f 00 18 	mcall	800062d8 <vTaskIncrementTick+0x108>
8000627c:	6e a8       	ld.w	r8,r7[0x28]
8000627e:	58 08       	cp.w	r8,0
80006280:	c0 50       	breq	8000628a <vTaskIncrementTick+0xba>
80006282:	ee cc ff e8 	sub	r12,r7,-24
80006286:	f0 1f 00 15 	mcall	800062d8 <vTaskIncrementTick+0x108>
8000628a:	6e bc       	ld.w	r12,r7[0x2c]
8000628c:	68 08       	ld.w	r8,r4[0x0]
8000628e:	10 3c       	cp.w	r12,r8
80006290:	e9 fc ba 00 	st.whi	r4[0x0],r12
80006294:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006298:	0c 9b       	mov	r11,r6
8000629a:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
8000629e:	f0 1f 00 10 	mcall	800062dc <vTaskIncrementTick+0x10c>
800062a2:	6a 08       	ld.w	r8,r5[0x0]
800062a4:	70 08       	ld.w	r8,r8[0x0]
800062a6:	58 08       	cp.w	r8,0
800062a8:	cd 51       	brne	80006252 <vTaskIncrementTick+0x82>
800062aa:	cc fb       	rjmp	80006248 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800062ac:	48 d8       	lddpc	r8,800062e0 <vTaskIncrementTick+0x110>
800062ae:	70 09       	ld.w	r9,r8[0x0]
800062b0:	2f f9       	sub	r9,-1
800062b2:	91 09       	st.w	r8[0x0],r9
800062b4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800062b8:	00 00       	add	r0,r0
800062ba:	0d 1c       	ld.sh	r12,r6++
800062bc:	00 00       	add	r0,r0
800062be:	0d 18       	ld.sh	r8,r6++
800062c0:	00 00       	add	r0,r0
800062c2:	0c 24       	rsub	r4,r6
800062c4:	00 00       	add	r0,r0
800062c6:	0c 34       	cp.w	r4,r6
800062c8:	00 00       	add	r0,r0
800062ca:	0c 30       	cp.w	r0,r6
800062cc:	00 00       	add	r0,r0
800062ce:	05 3c       	ld.ub	r12,r2++
800062d0:	00 00       	add	r0,r0
800062d2:	0d 54       	ld.sh	r4,--r6
800062d4:	00 00       	add	r0,r0
800062d6:	0c 38       	cp.w	r8,r6
800062d8:	80 00       	ld.sh	r0,r0[0x0]
800062da:	57 ce       	stdsp	sp[0x1f0],lr
800062dc:	80 00       	ld.sh	r0,r0[0x0]
800062de:	57 7e       	stdsp	sp[0x1dc],lr
800062e0:	00 00       	add	r0,r0
800062e2:	0c 1c       	sub	r12,r6

800062e4 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800062e4:	eb cd 40 c0 	pushm	r6-r7,lr
800062e8:	18 97       	mov	r7,r12
800062ea:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800062ec:	f0 1f 00 15 	mcall	80006340 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800062f0:	6c 08       	ld.w	r8,r6[0x0]
800062f2:	5b f8       	cp.w	r8,-1
800062f4:	c0 31       	brne	800062fa <xTaskCheckForTimeOut+0x16>
800062f6:	30 07       	mov	r7,0
800062f8:	c1 f8       	rjmp	80006336 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800062fa:	49 39       	lddpc	r9,80006344 <xTaskCheckForTimeOut+0x60>
800062fc:	72 09       	ld.w	r9,r9[0x0]
800062fe:	6e 0a       	ld.w	r10,r7[0x0]
80006300:	12 3a       	cp.w	r10,r9
80006302:	c0 70       	breq	80006310 <xTaskCheckForTimeOut+0x2c>
80006304:	49 19       	lddpc	r9,80006348 <xTaskCheckForTimeOut+0x64>
80006306:	72 09       	ld.w	r9,r9[0x0]
80006308:	6e 1a       	ld.w	r10,r7[0x4]
8000630a:	12 3a       	cp.w	r10,r9
8000630c:	e0 88 00 14 	brls	80006334 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80006310:	48 e9       	lddpc	r9,80006348 <xTaskCheckForTimeOut+0x64>
80006312:	72 0a       	ld.w	r10,r9[0x0]
80006314:	6e 19       	ld.w	r9,r7[0x4]
80006316:	12 1a       	sub	r10,r9
80006318:	14 38       	cp.w	r8,r10
8000631a:	e0 88 00 0d 	brls	80006334 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
8000631e:	48 ba       	lddpc	r10,80006348 <xTaskCheckForTimeOut+0x64>
80006320:	74 0a       	ld.w	r10,r10[0x0]
80006322:	14 19       	sub	r9,r10
80006324:	f2 08 00 08 	add	r8,r9,r8
80006328:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000632a:	0e 9c       	mov	r12,r7
8000632c:	f0 1f 00 08 	mcall	8000634c <xTaskCheckForTimeOut+0x68>
80006330:	30 07       	mov	r7,0
80006332:	c0 28       	rjmp	80006336 <xTaskCheckForTimeOut+0x52>
80006334:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80006336:	f0 1f 00 07 	mcall	80006350 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000633a:	0e 9c       	mov	r12,r7
8000633c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006340:	80 00       	ld.sh	r0,r0[0x0]
80006342:	58 88       	cp.w	r8,8
80006344:	00 00       	add	r0,r0
80006346:	0c 30       	cp.w	r0,r6
80006348:	00 00       	add	r0,r0
8000634a:	0d 18       	ld.sh	r8,r6++
8000634c:	80 00       	ld.sh	r0,r0[0x0]
8000634e:	60 48       	ld.w	r8,r0[0x10]
80006350:	80 00       	ld.sh	r0,r0[0x0]
80006352:	59 94       	cp.w	r4,25

80006354 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80006354:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80006358:	f0 1f 00 05 	mcall	8000636c <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
8000635c:	48 58       	lddpc	r8,80006370 <xTaskGetTickCount+0x1c>
8000635e:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80006360:	f0 1f 00 05 	mcall	80006374 <xTaskGetTickCount+0x20>

	return xTicks;
}
80006364:	0e 9c       	mov	r12,r7
80006366:	e3 cd 80 80 	ldm	sp++,r7,pc
8000636a:	00 00       	add	r0,r0
8000636c:	80 00       	ld.sh	r0,r0[0x0]
8000636e:	58 88       	cp.w	r8,8
80006370:	00 00       	add	r0,r0
80006372:	0d 18       	ld.sh	r8,r6++
80006374:	80 00       	ld.sh	r0,r0[0x0]
80006376:	59 94       	cp.w	r4,25

80006378 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80006378:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
8000637c:	f0 1f 00 2c 	mcall	8000642c <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006380:	4a c8       	lddpc	r8,80006430 <xTaskResumeAll+0xb8>
80006382:	70 09       	ld.w	r9,r8[0x0]
80006384:	20 19       	sub	r9,1
80006386:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006388:	70 08       	ld.w	r8,r8[0x0]
8000638a:	58 08       	cp.w	r8,0
8000638c:	c4 91       	brne	8000641e <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
8000638e:	4a a8       	lddpc	r8,80006434 <xTaskResumeAll+0xbc>
80006390:	70 08       	ld.w	r8,r8[0x0]
80006392:	58 08       	cp.w	r8,0
80006394:	c4 50       	breq	8000641e <xTaskResumeAll+0xa6>
80006396:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006398:	4a 85       	lddpc	r5,80006438 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
8000639a:	4a 93       	lddpc	r3,8000643c <xTaskResumeAll+0xc4>
8000639c:	4a 92       	lddpc	r2,80006440 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000639e:	4a a1       	lddpc	r1,80006444 <xTaskResumeAll+0xcc>
800063a0:	c1 e8       	rjmp	800063dc <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800063a2:	6a 38       	ld.w	r8,r5[0xc]
800063a4:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
800063a6:	ee cc ff e8 	sub	r12,r7,-24
800063aa:	f0 1f 00 28 	mcall	80006448 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800063ae:	ee c6 ff fc 	sub	r6,r7,-4
800063b2:	0c 9c       	mov	r12,r6
800063b4:	f0 1f 00 25 	mcall	80006448 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800063b8:	6e bc       	ld.w	r12,r7[0x2c]
800063ba:	66 08       	ld.w	r8,r3[0x0]
800063bc:	10 3c       	cp.w	r12,r8
800063be:	e7 fc ba 00 	st.whi	r3[0x0],r12
800063c2:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800063c6:	0c 9b       	mov	r11,r6
800063c8:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800063cc:	f0 1f 00 20 	mcall	8000644c <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800063d0:	62 08       	ld.w	r8,r1[0x0]
800063d2:	6e b9       	ld.w	r9,r7[0x2c]
800063d4:	70 b8       	ld.w	r8,r8[0x2c]
800063d6:	10 39       	cp.w	r9,r8
800063d8:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800063dc:	6a 08       	ld.w	r8,r5[0x0]
800063de:	58 08       	cp.w	r8,0
800063e0:	ce 11       	brne	800063a2 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800063e2:	49 c8       	lddpc	r8,80006450 <xTaskResumeAll+0xd8>
800063e4:	70 08       	ld.w	r8,r8[0x0]
800063e6:	58 08       	cp.w	r8,0
800063e8:	c0 f0       	breq	80006406 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800063ea:	49 a8       	lddpc	r8,80006450 <xTaskResumeAll+0xd8>
800063ec:	70 08       	ld.w	r8,r8[0x0]
800063ee:	58 08       	cp.w	r8,0
800063f0:	c1 10       	breq	80006412 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800063f2:	49 87       	lddpc	r7,80006450 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800063f4:	f0 1f 00 18 	mcall	80006454 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800063f8:	6e 08       	ld.w	r8,r7[0x0]
800063fa:	20 18       	sub	r8,1
800063fc:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800063fe:	6e 08       	ld.w	r8,r7[0x0]
80006400:	58 08       	cp.w	r8,0
80006402:	cf 91       	brne	800063f4 <xTaskResumeAll+0x7c>
80006404:	c0 78       	rjmp	80006412 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80006406:	58 14       	cp.w	r4,1
80006408:	c0 50       	breq	80006412 <xTaskResumeAll+0x9a>
8000640a:	49 48       	lddpc	r8,80006458 <xTaskResumeAll+0xe0>
8000640c:	70 08       	ld.w	r8,r8[0x0]
8000640e:	58 18       	cp.w	r8,1
80006410:	c0 71       	brne	8000641e <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80006412:	30 09       	mov	r9,0
80006414:	49 18       	lddpc	r8,80006458 <xTaskResumeAll+0xe0>
80006416:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80006418:	d7 33       	scall
8000641a:	30 17       	mov	r7,1
8000641c:	c0 28       	rjmp	80006420 <xTaskResumeAll+0xa8>
8000641e:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80006420:	f0 1f 00 0f 	mcall	8000645c <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80006424:	0e 9c       	mov	r12,r7
80006426:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000642a:	00 00       	add	r0,r0
8000642c:	80 00       	ld.sh	r0,r0[0x0]
8000642e:	58 88       	cp.w	r8,8
80006430:	00 00       	add	r0,r0
80006432:	0d 1c       	ld.sh	r12,r6++
80006434:	00 00       	add	r0,r0
80006436:	0d 38       	ld.ub	r8,r6++
80006438:	00 00       	add	r0,r0
8000643a:	0c f0       	st.b	--r6,r0
8000643c:	00 00       	add	r0,r0
8000643e:	0d 54       	ld.sh	r4,--r6
80006440:	00 00       	add	r0,r0
80006442:	0c 38       	cp.w	r8,r6
80006444:	00 00       	add	r0,r0
80006446:	0c ec       	st.h	--r6,r12
80006448:	80 00       	ld.sh	r0,r0[0x0]
8000644a:	57 ce       	stdsp	sp[0x1f0],lr
8000644c:	80 00       	ld.sh	r0,r0[0x0]
8000644e:	57 7e       	stdsp	sp[0x1dc],lr
80006450:	00 00       	add	r0,r0
80006452:	0c 1c       	sub	r12,r6
80006454:	80 00       	ld.sh	r0,r0[0x0]
80006456:	61 d0       	ld.w	r0,r0[0x74]
80006458:	00 00       	add	r0,r0
8000645a:	0d 3c       	ld.ub	r12,r6++
8000645c:	80 00       	ld.sh	r0,r0[0x0]
8000645e:	59 94       	cp.w	r4,25

80006460 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006460:	eb cd 40 80 	pushm	r7,lr
80006464:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80006466:	49 08       	lddpc	r8,800064a4 <prvAddCurrentTaskToDelayedList+0x44>
80006468:	70 08       	ld.w	r8,r8[0x0]
8000646a:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
8000646c:	48 f8       	lddpc	r8,800064a8 <prvAddCurrentTaskToDelayedList+0x48>
8000646e:	70 08       	ld.w	r8,r8[0x0]
80006470:	10 3c       	cp.w	r12,r8
80006472:	c0 a2       	brcc	80006486 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006474:	48 c8       	lddpc	r8,800064a4 <prvAddCurrentTaskToDelayedList+0x44>
80006476:	70 0b       	ld.w	r11,r8[0x0]
80006478:	48 d8       	lddpc	r8,800064ac <prvAddCurrentTaskToDelayedList+0x4c>
8000647a:	70 0c       	ld.w	r12,r8[0x0]
8000647c:	2f cb       	sub	r11,-4
8000647e:	f0 1f 00 0d 	mcall	800064b0 <prvAddCurrentTaskToDelayedList+0x50>
80006482:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006486:	48 88       	lddpc	r8,800064a4 <prvAddCurrentTaskToDelayedList+0x44>
80006488:	70 0b       	ld.w	r11,r8[0x0]
8000648a:	48 b8       	lddpc	r8,800064b4 <prvAddCurrentTaskToDelayedList+0x54>
8000648c:	70 0c       	ld.w	r12,r8[0x0]
8000648e:	2f cb       	sub	r11,-4
80006490:	f0 1f 00 08 	mcall	800064b0 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006494:	48 98       	lddpc	r8,800064b8 <prvAddCurrentTaskToDelayedList+0x58>
80006496:	70 08       	ld.w	r8,r8[0x0]
80006498:	10 37       	cp.w	r7,r8
8000649a:	c0 32       	brcc	800064a0 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
8000649c:	48 78       	lddpc	r8,800064b8 <prvAddCurrentTaskToDelayedList+0x58>
8000649e:	91 07       	st.w	r8[0x0],r7
800064a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800064a4:	00 00       	add	r0,r0
800064a6:	0c ec       	st.h	--r6,r12
800064a8:	00 00       	add	r0,r0
800064aa:	0d 18       	ld.sh	r8,r6++
800064ac:	00 00       	add	r0,r0
800064ae:	0c 34       	cp.w	r4,r6
800064b0:	80 00       	ld.sh	r0,r0[0x0]
800064b2:	57 9a       	stdsp	sp[0x1e4],r10
800064b4:	00 00       	add	r0,r0
800064b6:	0c 24       	rsub	r4,r6
800064b8:	00 00       	add	r0,r0
800064ba:	05 3c       	ld.ub	r12,r2++

800064bc <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
800064bc:	eb cd 40 c0 	pushm	r6-r7,lr
800064c0:	18 96       	mov	r6,r12
800064c2:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
800064c4:	f0 1f 00 18 	mcall	80006524 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
800064c8:	6c 08       	ld.w	r8,r6[0x0]
800064ca:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
800064cc:	49 79       	lddpc	r9,80006528 <vTaskDelayUntil+0x6c>
800064ce:	72 09       	ld.w	r9,r9[0x0]
800064d0:	12 38       	cp.w	r8,r9
800064d2:	e0 88 00 0c 	brls	800064ea <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
800064d6:	0e 38       	cp.w	r8,r7
800064d8:	e0 88 00 22 	brls	8000651c <vTaskDelayUntil+0x60>
800064dc:	49 38       	lddpc	r8,80006528 <vTaskDelayUntil+0x6c>
800064de:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800064e0:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
800064e2:	10 37       	cp.w	r7,r8
800064e4:	e0 88 00 14 	brls	8000650c <vTaskDelayUntil+0x50>
800064e8:	c0 a8       	rjmp	800064fc <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
800064ea:	0e 38       	cp.w	r8,r7
800064ec:	e0 8b 00 16 	brhi	80006518 <vTaskDelayUntil+0x5c>
800064f0:	48 e8       	lddpc	r8,80006528 <vTaskDelayUntil+0x6c>
800064f2:	70 08       	ld.w	r8,r8[0x0]
800064f4:	10 37       	cp.w	r7,r8
800064f6:	e0 8b 00 11 	brhi	80006518 <vTaskDelayUntil+0x5c>
800064fa:	c1 18       	rjmp	8000651c <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800064fc:	48 c8       	lddpc	r8,8000652c <vTaskDelayUntil+0x70>
800064fe:	70 0c       	ld.w	r12,r8[0x0]
80006500:	2f cc       	sub	r12,-4
80006502:	f0 1f 00 0c 	mcall	80006530 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006506:	0e 9c       	mov	r12,r7
80006508:	f0 1f 00 0b 	mcall	80006534 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
8000650c:	f0 1f 00 0b 	mcall	80006538 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006510:	c0 81       	brne	80006520 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80006512:	d7 33       	scall
80006514:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006518:	8d 07       	st.w	r6[0x0],r7
8000651a:	cf 1b       	rjmp	800064fc <vTaskDelayUntil+0x40>
8000651c:	8d 07       	st.w	r6[0x0],r7
8000651e:	cf 7b       	rjmp	8000650c <vTaskDelayUntil+0x50>
80006520:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006524:	80 00       	ld.sh	r0,r0[0x0]
80006526:	5f bc       	srhi	r12
80006528:	00 00       	add	r0,r0
8000652a:	0d 18       	ld.sh	r8,r6++
8000652c:	00 00       	add	r0,r0
8000652e:	0c ec       	st.h	--r6,r12
80006530:	80 00       	ld.sh	r0,r0[0x0]
80006532:	57 ce       	stdsp	sp[0x1f0],lr
80006534:	80 00       	ld.sh	r0,r0[0x0]
80006536:	64 60       	ld.w	r0,r2[0x18]
80006538:	80 00       	ld.sh	r0,r0[0x0]
8000653a:	63 78       	ld.w	r8,r1[0x5c]

8000653c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
8000653c:	eb cd 40 c0 	pushm	r6-r7,lr
80006540:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006542:	48 e7       	lddpc	r7,80006578 <vTaskPlaceOnEventList+0x3c>
80006544:	6e 0b       	ld.w	r11,r7[0x0]
80006546:	2e 8b       	sub	r11,-24
80006548:	f0 1f 00 0d 	mcall	8000657c <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000654c:	6e 0c       	ld.w	r12,r7[0x0]
8000654e:	2f cc       	sub	r12,-4
80006550:	f0 1f 00 0c 	mcall	80006580 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006554:	5b f6       	cp.w	r6,-1
80006556:	c0 81       	brne	80006566 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006558:	6e 0b       	ld.w	r11,r7[0x0]
8000655a:	2f cb       	sub	r11,-4
8000655c:	48 ac       	lddpc	r12,80006584 <vTaskPlaceOnEventList+0x48>
8000655e:	f0 1f 00 0b 	mcall	80006588 <vTaskPlaceOnEventList+0x4c>
80006562:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006566:	48 a8       	lddpc	r8,8000658c <vTaskPlaceOnEventList+0x50>
80006568:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
8000656a:	ec 0c 00 0c 	add	r12,r6,r12
8000656e:	f0 1f 00 09 	mcall	80006590 <vTaskPlaceOnEventList+0x54>
80006572:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006576:	00 00       	add	r0,r0
80006578:	00 00       	add	r0,r0
8000657a:	0c ec       	st.h	--r6,r12
8000657c:	80 00       	ld.sh	r0,r0[0x0]
8000657e:	57 9a       	stdsp	sp[0x1e4],r10
80006580:	80 00       	ld.sh	r0,r0[0x0]
80006582:	57 ce       	stdsp	sp[0x1f0],lr
80006584:	00 00       	add	r0,r0
80006586:	0d 40       	ld.w	r0,--r6
80006588:	80 00       	ld.sh	r0,r0[0x0]
8000658a:	57 7e       	stdsp	sp[0x1dc],lr
8000658c:	00 00       	add	r0,r0
8000658e:	0d 18       	ld.sh	r8,r6++
80006590:	80 00       	ld.sh	r0,r0[0x0]
80006592:	64 60       	ld.w	r0,r2[0x18]

80006594 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006594:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006598:	49 67       	lddpc	r7,800065f0 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000659a:	49 74       	lddpc	r4,800065f4 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
8000659c:	49 73       	lddpc	r3,800065f8 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
8000659e:	49 85       	lddpc	r5,800065fc <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800065a0:	6e 08       	ld.w	r8,r7[0x0]
800065a2:	58 08       	cp.w	r8,0
800065a4:	c1 e0       	breq	800065e0 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
800065a6:	f0 1f 00 17 	mcall	80006600 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800065aa:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
800065ac:	f0 1f 00 16 	mcall	80006604 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
800065b0:	58 06       	cp.w	r6,0
800065b2:	c1 70       	breq	800065e0 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
800065b4:	f0 1f 00 15 	mcall	80006608 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
800065b8:	68 38       	ld.w	r8,r4[0xc]
800065ba:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
800065bc:	ec cc ff fc 	sub	r12,r6,-4
800065c0:	f0 1f 00 13 	mcall	8000660c <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
800065c4:	66 08       	ld.w	r8,r3[0x0]
800065c6:	20 18       	sub	r8,1
800065c8:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
800065ca:	6e 08       	ld.w	r8,r7[0x0]
800065cc:	20 18       	sub	r8,1
800065ce:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
800065d0:	f0 1f 00 10 	mcall	80006610 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
800065d4:	6c cc       	ld.w	r12,r6[0x30]
800065d6:	f0 1f 00 10 	mcall	80006614 <prvIdleTask+0x80>
		vPortFree( pxTCB );
800065da:	0c 9c       	mov	r12,r6
800065dc:	f0 1f 00 0e 	mcall	80006614 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800065e0:	6a 08       	ld.w	r8,r5[0x0]
800065e2:	58 18       	cp.w	r8,1
800065e4:	e0 88 00 03 	brls	800065ea <prvIdleTask+0x56>
			{
				taskYIELD();
800065e8:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
800065ea:	f0 1f 00 0c 	mcall	80006618 <prvIdleTask+0x84>
		}
		#endif
	}
800065ee:	cd 9b       	rjmp	800065a0 <prvIdleTask+0xc>
800065f0:	00 00       	add	r0,r0
800065f2:	0c 2c       	rsub	r12,r6
800065f4:	00 00       	add	r0,r0
800065f6:	0c d8       	st.w	--r6,r8
800065f8:	00 00       	add	r0,r0
800065fa:	0d 38       	ld.ub	r8,r6++
800065fc:	00 00       	add	r0,r0
800065fe:	0c 38       	cp.w	r8,r6
80006600:	80 00       	ld.sh	r0,r0[0x0]
80006602:	5f bc       	srhi	r12
80006604:	80 00       	ld.sh	r0,r0[0x0]
80006606:	63 78       	ld.w	r8,r1[0x5c]
80006608:	80 00       	ld.sh	r0,r0[0x0]
8000660a:	58 88       	cp.w	r8,8
8000660c:	80 00       	ld.sh	r0,r0[0x0]
8000660e:	57 ce       	stdsp	sp[0x1f0],lr
80006610:	80 00       	ld.sh	r0,r0[0x0]
80006612:	59 94       	cp.w	r4,25
80006614:	80 00       	ld.sh	r0,r0[0x0]
80006616:	5a cc       	cp.w	r12,-20
80006618:	80 00       	ld.sh	r0,r0[0x0]
8000661a:	20 2c       	sub	r12,2

8000661c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
8000661c:	d4 31       	pushm	r0-r7,lr
8000661e:	20 1d       	sub	sp,4
80006620:	fa c4 ff d8 	sub	r4,sp,-40
80006624:	50 0c       	stdsp	sp[0x0],r12
80006626:	16 91       	mov	r1,r11
80006628:	14 97       	mov	r7,r10
8000662a:	12 90       	mov	r0,r9
8000662c:	10 93       	mov	r3,r8
8000662e:	68 02       	ld.w	r2,r4[0x0]
80006630:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006632:	34 8c       	mov	r12,72
80006634:	f0 1f 00 5c 	mcall	800067a4 <xTaskGenericCreate+0x188>
80006638:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
8000663a:	c0 31       	brne	80006640 <xTaskGenericCreate+0x24>
8000663c:	3f fc       	mov	r12,-1
8000663e:	ca f8       	rjmp	8000679c <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006640:	58 06       	cp.w	r6,0
80006642:	e0 81 00 af 	brne	800067a0 <xTaskGenericCreate+0x184>
80006646:	0e 9c       	mov	r12,r7
80006648:	5c 7c       	castu.h	r12
8000664a:	a3 6c       	lsl	r12,0x2
8000664c:	f0 1f 00 56 	mcall	800067a4 <xTaskGenericCreate+0x188>
80006650:	18 96       	mov	r6,r12
80006652:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006654:	c0 61       	brne	80006660 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006656:	0a 9c       	mov	r12,r5
80006658:	f0 1f 00 54 	mcall	800067a8 <xTaskGenericCreate+0x18c>
8000665c:	3f fc       	mov	r12,-1
8000665e:	c9 f8       	rjmp	8000679c <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006660:	5c 77       	castu.h	r7
80006662:	ee 0a 15 02 	lsl	r10,r7,0x2
80006666:	e0 6b 00 a5 	mov	r11,165
8000666a:	0c 9c       	mov	r12,r6
8000666c:	f0 1f 00 50 	mcall	800067ac <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006670:	ee c6 00 01 	sub	r6,r7,1
80006674:	6a c8       	ld.w	r8,r5[0x30]
80006676:	f0 06 00 26 	add	r6,r8,r6<<0x2
8000667a:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
8000667e:	31 0a       	mov	r10,16
80006680:	02 9b       	mov	r11,r1
80006682:	ea cc ff cc 	sub	r12,r5,-52
80006686:	f0 1f 00 4b 	mcall	800067b0 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
8000668a:	30 08       	mov	r8,0
8000668c:	eb 68 00 43 	st.b	r5[67],r8
80006690:	58 73       	cp.w	r3,7
80006692:	e6 07 17 80 	movls	r7,r3
80006696:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
8000669a:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
8000669c:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
800066a0:	ea c4 ff fc 	sub	r4,r5,-4
800066a4:	08 9c       	mov	r12,r4
800066a6:	f0 1f 00 44 	mcall	800067b4 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
800066aa:	ea cc ff e8 	sub	r12,r5,-24
800066ae:	f0 1f 00 42 	mcall	800067b4 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
800066b2:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
800066b4:	ee 07 11 08 	rsub	r7,r7,8
800066b8:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
800066ba:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
800066bc:	00 9a       	mov	r10,r0
800066be:	40 0b       	lddsp	r11,sp[0x0]
800066c0:	0c 9c       	mov	r12,r6
800066c2:	f0 1f 00 3e 	mcall	800067b8 <xTaskGenericCreate+0x19c>
800066c6:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
800066c8:	58 02       	cp.w	r2,0
800066ca:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
800066ce:	f0 1f 00 3c 	mcall	800067bc <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
800066d2:	4b c8       	lddpc	r8,800067c0 <xTaskGenericCreate+0x1a4>
800066d4:	70 09       	ld.w	r9,r8[0x0]
800066d6:	2f f9       	sub	r9,-1
800066d8:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
800066da:	4b b8       	lddpc	r8,800067c4 <xTaskGenericCreate+0x1a8>
800066dc:	70 08       	ld.w	r8,r8[0x0]
800066de:	58 08       	cp.w	r8,0
800066e0:	c2 61       	brne	8000672c <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
800066e2:	4b 98       	lddpc	r8,800067c4 <xTaskGenericCreate+0x1a8>
800066e4:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
800066e6:	4b 78       	lddpc	r8,800067c0 <xTaskGenericCreate+0x1a4>
800066e8:	70 08       	ld.w	r8,r8[0x0]
800066ea:	58 18       	cp.w	r8,1
800066ec:	c2 b1       	brne	80006742 <xTaskGenericCreate+0x126>
800066ee:	4b 77       	lddpc	r7,800067c8 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
800066f0:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
800066f4:	0e 9c       	mov	r12,r7
800066f6:	f0 1f 00 36 	mcall	800067cc <xTaskGenericCreate+0x1b0>
800066fa:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
800066fc:	0c 37       	cp.w	r7,r6
800066fe:	cf b1       	brne	800066f4 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006700:	4b 47       	lddpc	r7,800067d0 <xTaskGenericCreate+0x1b4>
80006702:	0e 9c       	mov	r12,r7
80006704:	f0 1f 00 32 	mcall	800067cc <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006708:	4b 36       	lddpc	r6,800067d4 <xTaskGenericCreate+0x1b8>
8000670a:	0c 9c       	mov	r12,r6
8000670c:	f0 1f 00 30 	mcall	800067cc <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006710:	4b 2c       	lddpc	r12,800067d8 <xTaskGenericCreate+0x1bc>
80006712:	f0 1f 00 2f 	mcall	800067cc <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006716:	4b 2c       	lddpc	r12,800067dc <xTaskGenericCreate+0x1c0>
80006718:	f0 1f 00 2d 	mcall	800067cc <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
8000671c:	4b 1c       	lddpc	r12,800067e0 <xTaskGenericCreate+0x1c4>
8000671e:	f0 1f 00 2c 	mcall	800067cc <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006722:	4b 18       	lddpc	r8,800067e4 <xTaskGenericCreate+0x1c8>
80006724:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006726:	4b 18       	lddpc	r8,800067e8 <xTaskGenericCreate+0x1cc>
80006728:	91 06       	st.w	r8[0x0],r6
8000672a:	c0 c8       	rjmp	80006742 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
8000672c:	4b 08       	lddpc	r8,800067ec <xTaskGenericCreate+0x1d0>
8000672e:	70 08       	ld.w	r8,r8[0x0]
80006730:	58 08       	cp.w	r8,0
80006732:	c0 81       	brne	80006742 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006734:	4a 48       	lddpc	r8,800067c4 <xTaskGenericCreate+0x1a8>
80006736:	70 08       	ld.w	r8,r8[0x0]
80006738:	70 b8       	ld.w	r8,r8[0x2c]
8000673a:	10 33       	cp.w	r3,r8
8000673c:	c0 33       	brcs	80006742 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
8000673e:	4a 28       	lddpc	r8,800067c4 <xTaskGenericCreate+0x1a8>
80006740:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006742:	6a b8       	ld.w	r8,r5[0x2c]
80006744:	4a b9       	lddpc	r9,800067f0 <xTaskGenericCreate+0x1d4>
80006746:	72 09       	ld.w	r9,r9[0x0]
80006748:	12 38       	cp.w	r8,r9
8000674a:	e0 88 00 04 	brls	80006752 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
8000674e:	4a 99       	lddpc	r9,800067f0 <xTaskGenericCreate+0x1d4>
80006750:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006752:	4a 98       	lddpc	r8,800067f4 <xTaskGenericCreate+0x1d8>
80006754:	70 09       	ld.w	r9,r8[0x0]
80006756:	2f f9       	sub	r9,-1
80006758:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
8000675a:	6a b8       	ld.w	r8,r5[0x2c]
8000675c:	4a 79       	lddpc	r9,800067f8 <xTaskGenericCreate+0x1dc>
8000675e:	72 09       	ld.w	r9,r9[0x0]
80006760:	12 38       	cp.w	r8,r9
80006762:	e0 88 00 04 	brls	8000676a <xTaskGenericCreate+0x14e>
80006766:	4a 59       	lddpc	r9,800067f8 <xTaskGenericCreate+0x1dc>
80006768:	93 08       	st.w	r9[0x0],r8
8000676a:	6a bc       	ld.w	r12,r5[0x2c]
8000676c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006770:	08 9b       	mov	r11,r4
80006772:	49 68       	lddpc	r8,800067c8 <xTaskGenericCreate+0x1ac>
80006774:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006778:	f0 1f 00 21 	mcall	800067fc <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
8000677c:	f0 1f 00 21 	mcall	80006800 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006780:	49 b8       	lddpc	r8,800067ec <xTaskGenericCreate+0x1d0>
80006782:	70 08       	ld.w	r8,r8[0x0]
80006784:	58 08       	cp.w	r8,0
80006786:	c0 a0       	breq	8000679a <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006788:	48 f8       	lddpc	r8,800067c4 <xTaskGenericCreate+0x1a8>
8000678a:	70 08       	ld.w	r8,r8[0x0]
8000678c:	70 b8       	ld.w	r8,r8[0x2c]
8000678e:	10 33       	cp.w	r3,r8
80006790:	e0 88 00 05 	brls	8000679a <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006794:	d7 33       	scall
80006796:	30 1c       	mov	r12,1
80006798:	c0 28       	rjmp	8000679c <xTaskGenericCreate+0x180>
8000679a:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
8000679c:	2f fd       	sub	sp,-4
8000679e:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800067a0:	99 c6       	st.w	r12[0x30],r6
800067a2:	c5 fb       	rjmp	80006660 <xTaskGenericCreate+0x44>
800067a4:	80 00       	ld.sh	r0,r0[0x0]
800067a6:	5a f4       	cp.w	r4,-17
800067a8:	80 00       	ld.sh	r0,r0[0x0]
800067aa:	5a cc       	cp.w	r12,-20
800067ac:	80 00       	ld.sh	r0,r0[0x0]
800067ae:	73 bc       	ld.w	r12,r9[0x6c]
800067b0:	80 00       	ld.sh	r0,r0[0x0]
800067b2:	76 e8       	ld.w	r8,r11[0x38]
800067b4:	80 00       	ld.sh	r0,r0[0x0]
800067b6:	57 78       	stdsp	sp[0x1dc],r8
800067b8:	80 00       	ld.sh	r0,r0[0x0]
800067ba:	57 f4       	stdsp	sp[0x1fc],r4
800067bc:	80 00       	ld.sh	r0,r0[0x0]
800067be:	58 88       	cp.w	r8,8
800067c0:	00 00       	add	r0,r0
800067c2:	0d 38       	ld.ub	r8,r6++
800067c4:	00 00       	add	r0,r0
800067c6:	0c ec       	st.h	--r6,r12
800067c8:	00 00       	add	r0,r0
800067ca:	0c 38       	cp.w	r8,r6
800067cc:	80 00       	ld.sh	r0,r0[0x0]
800067ce:	57 64       	stdsp	sp[0x1d8],r4
800067d0:	00 00       	add	r0,r0
800067d2:	0d 04       	ld.w	r4,r6++
800067d4:	00 00       	add	r0,r0
800067d6:	0d 20       	ld.uh	r0,r6++
800067d8:	00 00       	add	r0,r0
800067da:	0c f0       	st.b	--r6,r0
800067dc:	00 00       	add	r0,r0
800067de:	0c d8       	st.w	--r6,r8
800067e0:	00 00       	add	r0,r0
800067e2:	0d 40       	ld.w	r0,--r6
800067e4:	00 00       	add	r0,r0
800067e6:	0c 24       	rsub	r4,r6
800067e8:	00 00       	add	r0,r0
800067ea:	0c 34       	cp.w	r4,r6
800067ec:	00 00       	add	r0,r0
800067ee:	0c 28       	rsub	r8,r6
800067f0:	00 00       	add	r0,r0
800067f2:	0c 20       	rsub	r0,r6
800067f4:	00 00       	add	r0,r0
800067f6:	0d 34       	ld.ub	r4,r6++
800067f8:	00 00       	add	r0,r0
800067fa:	0d 54       	ld.sh	r4,--r6
800067fc:	80 00       	ld.sh	r0,r0[0x0]
800067fe:	57 7e       	stdsp	sp[0x1dc],lr
80006800:	80 00       	ld.sh	r0,r0[0x0]
80006802:	59 94       	cp.w	r4,25

80006804 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006804:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006806:	30 09       	mov	r9,0
80006808:	1a d9       	st.w	--sp,r9
8000680a:	1a d9       	st.w	--sp,r9
8000680c:	1a d9       	st.w	--sp,r9
8000680e:	12 98       	mov	r8,r9
80006810:	e0 6a 01 00 	mov	r10,256
80006814:	48 9b       	lddpc	r11,80006838 <vTaskStartScheduler+0x34>
80006816:	48 ac       	lddpc	r12,8000683c <vTaskStartScheduler+0x38>
80006818:	f0 1f 00 0a 	mcall	80006840 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
8000681c:	2f dd       	sub	sp,-12
8000681e:	58 1c       	cp.w	r12,1
80006820:	c0 a1       	brne	80006834 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006822:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006824:	30 19       	mov	r9,1
80006826:	48 88       	lddpc	r8,80006844 <vTaskStartScheduler+0x40>
80006828:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
8000682a:	30 09       	mov	r9,0
8000682c:	48 78       	lddpc	r8,80006848 <vTaskStartScheduler+0x44>
8000682e:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006830:	f0 1f 00 07 	mcall	8000684c <vTaskStartScheduler+0x48>
80006834:	d8 02       	popm	pc
80006836:	00 00       	add	r0,r0
80006838:	80 00       	ld.sh	r0,r0[0x0]
8000683a:	d2 c8       	*unknown*
8000683c:	80 00       	ld.sh	r0,r0[0x0]
8000683e:	65 94       	ld.w	r4,r2[0x64]
80006840:	80 00       	ld.sh	r0,r0[0x0]
80006842:	66 1c       	ld.w	r12,r3[0x4]
80006844:	00 00       	add	r0,r0
80006846:	0c 28       	rsub	r8,r6
80006848:	00 00       	add	r0,r0
8000684a:	0d 18       	ld.sh	r8,r6++
8000684c:	80 00       	ld.sh	r0,r0[0x0]
8000684e:	58 98       	cp.w	r8,9

80006850 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006850:	16 cc       	st.b	r11++,r12
	return str;
}
80006852:	5e fb       	retal	r11

80006854 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006854:	eb cd 40 c0 	pushm	r6-r7,lr
80006858:	20 3d       	sub	sp,12
8000685a:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
8000685c:	30 06       	mov	r6,0
8000685e:	30 07       	mov	r7,0
80006860:	fa e7 00 00 	st.d	sp[0],r6
80006864:	30 0c       	mov	r12,0
80006866:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006868:	58 08       	cp.w	r8,0
8000686a:	c1 30       	breq	80006890 <PrintHex+0x3c>
8000686c:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
8000686e:	1a 9c       	mov	r12,sp
80006870:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006874:	58 9e       	cp.w	lr,9
80006876:	e0 8a 00 04 	brle	8000687e <PrintHex+0x2a>
8000687a:	2c 9e       	sub	lr,-55
8000687c:	c0 48       	rjmp	80006884 <PrintHex+0x30>
8000687e:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006882:	2d 0e       	sub	lr,-48
80006884:	f8 09 0b 0e 	st.b	r12[r9],lr
80006888:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
8000688a:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
8000688c:	cf 21       	brne	80006870 <PrintHex+0x1c>
8000688e:	c0 48       	rjmp	80006896 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006890:	33 08       	mov	r8,48
80006892:	ba 88       	st.b	sp[0x0],r8
80006894:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006896:	f6 09 01 08 	sub	r8,r11,r9
8000689a:	58 08       	cp.w	r8,0
8000689c:	e0 8a 00 13 	brle	800068c2 <PrintHex+0x6e>
	{
		char num = len - cnt;
800068a0:	12 1b       	sub	r11,r9
800068a2:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
800068a6:	18 9e       	mov	lr,r12
800068a8:	58 0c       	cp.w	r12,0
800068aa:	e0 8a 00 0c 	brle	800068c2 <PrintHex+0x6e>
800068ae:	1a 9b       	mov	r11,sp
800068b0:	12 0b       	add	r11,r9
800068b2:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
800068b4:	33 07       	mov	r7,48
800068b6:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
800068b8:	2f f8       	sub	r8,-1
800068ba:	1c 38       	cp.w	r8,lr
800068bc:	cf d5       	brlt	800068b6 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
800068be:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
800068c2:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
800068c6:	f0 cb ff ff 	sub	r11,r8,-1
800068ca:	58 0b       	cp.w	r11,0
800068cc:	e0 8a 00 19 	brle	800068fe <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
800068d0:	fa cb ff f4 	sub	r11,sp,-12
800068d4:	f6 09 00 09 	add	r9,r11,r9
800068d8:	37 8b       	mov	r11,120
800068da:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
800068de:	fa c9 ff f4 	sub	r9,sp,-12
800068e2:	10 09       	add	r9,r8
800068e4:	33 0b       	mov	r11,48
800068e6:	f3 6b ff f4 	st.b	r9[-12],r11
800068ea:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
800068ee:	fa ce 00 01 	sub	lr,sp,1
800068f2:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
800068f4:	11 8b       	ld.ub	r11,r8[0x0]
800068f6:	12 cb       	st.b	r9++,r11
800068f8:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
800068fa:	1c 38       	cp.w	r8,lr
800068fc:	cf c1       	brne	800068f4 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
800068fe:	14 9c       	mov	r12,r10
80006900:	2f dd       	sub	sp,-12
80006902:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006906 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006906:	d4 21       	pushm	r4-r7,lr
80006908:	20 3d       	sub	sp,12
8000690a:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
8000690c:	30 06       	mov	r6,0
8000690e:	30 07       	mov	r7,0
80006910:	fa e7 00 00 	st.d	sp[0],r6
80006914:	30 0c       	mov	r12,0
80006916:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006918:	58 08       	cp.w	r8,0
8000691a:	c0 35       	brlt	80006920 <PrintDec+0x1a>
8000691c:	14 97       	mov	r7,r10
8000691e:	c0 58       	rjmp	80006928 <PrintDec+0x22>
	{
		*p++ = '-';
80006920:	14 97       	mov	r7,r10
80006922:	32 d9       	mov	r9,45
80006924:	0e c9       	st.b	r7++,r9
		i = -i;
80006926:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006928:	58 08       	cp.w	r8,0
8000692a:	c0 51       	brne	80006934 <PrintDec+0x2e>
8000692c:	33 08       	mov	r8,48
8000692e:	ba 88       	st.b	sp[0x0],r8
80006930:	30 1e       	mov	lr,1
80006932:	c2 f8       	rjmp	80006990 <PrintDec+0x8a>
	
	int ten = i%10;
80006934:	e0 65 66 67 	mov	r5,26215
80006938:	ea 15 66 66 	orh	r5,0x6666
8000693c:	f0 05 04 44 	muls.d	r4,r8,r5
80006940:	ea 0c 14 02 	asr	r12,r5,0x2
80006944:	f0 09 14 1f 	asr	r9,r8,0x1f
80006948:	f8 09 01 09 	sub	r9,r12,r9
8000694c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006950:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006954:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006956:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006958:	e0 66 66 67 	mov	r6,26215
8000695c:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006960:	2d 09       	sub	r9,-48
80006962:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006966:	2f fe       	sub	lr,-1
		i /= 10;
80006968:	f0 06 04 44 	muls.d	r4,r8,r6
8000696c:	ea 09 14 02 	asr	r9,r5,0x2
80006970:	bf 58       	asr	r8,0x1f
80006972:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006976:	f0 06 04 44 	muls.d	r4,r8,r6
8000697a:	ea 09 14 02 	asr	r9,r5,0x2
8000697e:	f0 05 14 1f 	asr	r5,r8,0x1f
80006982:	0a 19       	sub	r9,r5
80006984:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006988:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
8000698c:	58 08       	cp.w	r8,0
8000698e:	ce 91       	brne	80006960 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006990:	f6 0e 01 08 	sub	r8,r11,lr
80006994:	58 08       	cp.w	r8,0
80006996:	e0 89 00 06 	brgt	800069a2 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000699a:	58 0e       	cp.w	lr,0
8000699c:	e0 89 00 14 	brgt	800069c4 <PrintDec+0xbe>
800069a0:	c1 d8       	rjmp	800069da <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
800069a2:	1c 1b       	sub	r11,lr
800069a4:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
800069a6:	16 9c       	mov	r12,r11
800069a8:	58 0b       	cp.w	r11,0
800069aa:	fe 9a ff f8 	brle	8000699a <PrintDec+0x94>
800069ae:	1a 99       	mov	r9,sp
800069b0:	1c 09       	add	r9,lr
800069b2:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
800069b4:	33 06       	mov	r6,48
800069b6:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
800069b8:	2f f8       	sub	r8,-1
800069ba:	18 38       	cp.w	r8,r12
800069bc:	cf d5       	brlt	800069b6 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
800069be:	f6 0e 00 0e 	add	lr,r11,lr
800069c2:	ce cb       	rjmp	8000699a <PrintDec+0x94>
800069c4:	fa c8 ff f4 	sub	r8,sp,-12
800069c8:	1c 08       	add	r8,lr
800069ca:	20 d8       	sub	r8,13
800069cc:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
800069d0:	11 89       	ld.ub	r9,r8[0x0]
800069d2:	0e c9       	st.b	r7++,r9
800069d4:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
800069d6:	16 38       	cp.w	r8,r11
800069d8:	cf c1       	brne	800069d0 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
800069da:	14 9c       	mov	r12,r10
800069dc:	2f dd       	sub	sp,-12
800069de:	d8 22       	popm	r4-r7,pc

800069e0 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
800069e0:	d4 31       	pushm	r0-r7,lr
800069e2:	fa cd 02 08 	sub	sp,sp,520
800069e6:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
800069e8:	e0 6a 01 00 	mov	r10,256
800069ec:	30 0b       	mov	r11,0
800069ee:	fa cc fe f8 	sub	r12,sp,-264
800069f2:	f0 1f 00 4e 	mcall	80006b28 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
800069f6:	fa c4 fd d4 	sub	r4,sp,-556
800069fa:	30 0a       	mov	r10,0
800069fc:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800069fe:	fa c3 ff fc 	sub	r3,sp,-4
80006a02:	e0 61 01 00 	mov	r1,256
80006a06:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006a08:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006a0a:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006a0e:	02 9a       	mov	r10,r1
80006a10:	00 9b       	mov	r11,r0
80006a12:	06 9c       	mov	r12,r3
80006a14:	f0 1f 00 45 	mcall	80006b28 <log+0x148>
			
					if(*str == '%')
80006a18:	0f 88       	ld.ub	r8,r7[0x0]
80006a1a:	e4 08 18 00 	cp.b	r8,r2
80006a1e:	c5 71       	brne	80006acc <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80006a20:	ee c8 ff ff 	sub	r8,r7,-1
80006a24:	11 89       	ld.ub	r9,r8[0x0]
80006a26:	4c 2a       	lddpc	r10,80006b2c <log+0x14c>
80006a28:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80006a2a:	23 09       	sub	r9,48
80006a2c:	30 9a       	mov	r10,9
80006a2e:	f4 09 18 00 	cp.b	r9,r10
80006a32:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80006a36:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006a3a:	f7 b9 08 30 	subls	r9,48
80006a3e:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80006a42:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80006a46:	0f 88       	ld.ub	r8,r7[0x0]
80006a48:	22 58       	sub	r8,37
80006a4a:	e0 48 00 53 	cp.w	r8,83
80006a4e:	e0 8b 00 31 	brhi	80006ab0 <log+0xd0>
80006a52:	4b 89       	lddpc	r9,80006b30 <log+0x150>
80006a54:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006a58:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006a5c:	06 9a       	mov	r10,r3
80006a5e:	40 0b       	lddsp	r11,sp[0x0]
80006a60:	5c 5b       	castu.b	r11
80006a62:	68 0c       	ld.w	r12,r4[0x0]
80006a64:	f0 1f 00 34 	mcall	80006b34 <log+0x154>
							break;
80006a68:	c2 98       	rjmp	80006aba <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006a6a:	4b 4c       	lddpc	r12,80006b38 <log+0x158>
80006a6c:	f0 1f 00 34 	mcall	80006b3c <log+0x15c>
80006a70:	08 95       	mov	r5,r4
80006a72:	06 9c       	mov	r12,r3
							break;
80006a74:	c2 38       	rjmp	80006aba <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80006a76:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006a7a:	06 9a       	mov	r10,r3
80006a7c:	40 0b       	lddsp	r11,sp[0x0]
80006a7e:	5c 5b       	castu.b	r11
80006a80:	68 0c       	ld.w	r12,r4[0x0]
80006a82:	f0 1f 00 30 	mcall	80006b40 <log+0x160>
80006a86:	06 9c       	mov	r12,r3
							break;
80006a88:	c1 98       	rjmp	80006aba <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006a8a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006a8e:	06 9b       	mov	r11,r3
80006a90:	09 bc       	ld.ub	r12,r4[0x3]
80006a92:	f0 1f 00 2d 	mcall	80006b44 <log+0x164>
80006a96:	06 9c       	mov	r12,r3
							break;
80006a98:	c1 18       	rjmp	80006aba <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006a9a:	e8 c5 ff fc 	sub	r5,r4,-4
80006a9e:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006aa0:	c0 d8       	rjmp	80006aba <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006aa2:	06 9b       	mov	r11,r3
80006aa4:	32 5c       	mov	r12,37
80006aa6:	f0 1f 00 28 	mcall	80006b44 <log+0x164>
80006aaa:	08 95       	mov	r5,r4
80006aac:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80006aae:	c0 68       	rjmp	80006aba <log+0xda>
							
							default:
							log("I need relax.");
80006ab0:	4a 6c       	lddpc	r12,80006b48 <log+0x168>
80006ab2:	f0 1f 00 23 	mcall	80006b3c <log+0x15c>
80006ab6:	08 95       	mov	r5,r4
80006ab8:	06 9c       	mov	r12,r3
						}
						str++;
80006aba:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006abc:	1a dc       	st.w	--sp,r12
80006abe:	1a d6       	st.w	--sp,r6
80006ac0:	4a 3b       	lddpc	r11,80006b4c <log+0x16c>
80006ac2:	0c 9c       	mov	r12,r6
80006ac4:	f0 1f 00 23 	mcall	80006b50 <log+0x170>
80006ac8:	2f ed       	sub	sp,-8
80006aca:	c0 a8       	rjmp	80006ade <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006acc:	2f f7       	sub	r7,-1
80006ace:	1a d8       	st.w	--sp,r8
80006ad0:	1a d6       	st.w	--sp,r6
80006ad2:	4a 1b       	lddpc	r11,80006b54 <log+0x174>
80006ad4:	0c 9c       	mov	r12,r6
80006ad6:	f0 1f 00 1f 	mcall	80006b50 <log+0x170>
80006ada:	08 95       	mov	r5,r4
80006adc:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80006ade:	0f 89       	ld.ub	r9,r7[0x0]
80006ae0:	30 08       	mov	r8,0
80006ae2:	f0 09 18 00 	cp.b	r9,r8
80006ae6:	c0 30       	breq	80006aec <log+0x10c>
80006ae8:	0a 94       	mov	r4,r5
80006aea:	c9 2b       	rjmp	80006a0e <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006aec:	fa c7 fe f8 	sub	r7,sp,-264
80006af0:	1a d7       	st.w	--sp,r7
80006af2:	49 ab       	lddpc	r11,80006b58 <log+0x178>
80006af4:	0e 9c       	mov	r12,r7
80006af6:	f0 1f 00 17 	mcall	80006b50 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80006afa:	5c 5c       	castu.b	r12
80006afc:	f8 c6 ff ff 	sub	r6,r12,-1
80006b00:	0c 9c       	mov	r12,r6
80006b02:	f0 1f 00 17 	mcall	80006b5c <log+0x17c>
80006b06:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80006b08:	0c 9a       	mov	r10,r6
80006b0a:	0e 9b       	mov	r11,r7
80006b0c:	f0 1f 00 15 	mcall	80006b60 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80006b10:	30 09       	mov	r9,0
80006b12:	30 5a       	mov	r10,5
80006b14:	fa cb fe f8 	sub	r11,sp,-264
80006b18:	49 38       	lddpc	r8,80006b64 <log+0x184>
80006b1a:	70 0c       	ld.w	r12,r8[0x0]
80006b1c:	f0 1f 00 13 	mcall	80006b68 <log+0x188>
80006b20:	2f fd       	sub	sp,-4
	
	
}
80006b22:	fe 3d fd f8 	sub	sp,-520
80006b26:	d8 32       	popm	r0-r7,pc
80006b28:	80 00       	ld.sh	r0,r0[0x0]
80006b2a:	73 bc       	ld.w	r12,r9[0x6c]
80006b2c:	00 00       	add	r0,r0
80006b2e:	0d 58       	ld.sh	r8,--r6
80006b30:	80 00       	ld.sh	r0,r0[0x0]
80006b32:	d2 d0       	acall	0x2d
80006b34:	80 00       	ld.sh	r0,r0[0x0]
80006b36:	69 06       	ld.w	r6,r4[0x40]
80006b38:	80 00       	ld.sh	r0,r0[0x0]
80006b3a:	d5 7c       	*unknown*
80006b3c:	80 00       	ld.sh	r0,r0[0x0]
80006b3e:	69 e0       	ld.w	r0,r4[0x78]
80006b40:	80 00       	ld.sh	r0,r0[0x0]
80006b42:	68 54       	ld.w	r4,r4[0x14]
80006b44:	80 00       	ld.sh	r0,r0[0x0]
80006b46:	68 50       	ld.w	r0,r4[0x14]
80006b48:	80 00       	ld.sh	r0,r0[0x0]
80006b4a:	d5 8c       	*unknown*
80006b4c:	80 00       	ld.sh	r0,r0[0x0]
80006b4e:	d5 9c       	*unknown*
80006b50:	80 00       	ld.sh	r0,r0[0x0]
80006b52:	76 ac       	ld.w	r12,r11[0x28]
80006b54:	80 00       	ld.sh	r0,r0[0x0]
80006b56:	d5 a4       	*unknown*
80006b58:	80 00       	ld.sh	r0,r0[0x0]
80006b5a:	d5 ac       	*unknown*
80006b5c:	80 00       	ld.sh	r0,r0[0x0]
80006b5e:	5a f4       	cp.w	r4,-17
80006b60:	80 00       	ld.sh	r0,r0[0x0]
80006b62:	72 74       	ld.w	r4,r9[0x1c]
80006b64:	00 00       	add	r0,r0
80006b66:	51 18       	stdsp	sp[0x44],r8
80006b68:	80 00       	ld.sh	r0,r0[0x0]
80006b6a:	5e 48       	retge	r8

80006b6c <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006b6c:	d4 31       	pushm	r0-r7,lr
80006b6e:	fa cd 02 0c 	sub	sp,sp,524
80006b72:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006b74:	e0 6a 01 00 	mov	r10,256
80006b78:	30 0b       	mov	r11,0
80006b7a:	fa cc fe f4 	sub	r12,sp,-268
80006b7e:	f0 1f 00 4c 	mcall	80006cac <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80006b82:	fa c4 fd d0 	sub	r4,sp,-560
80006b86:	30 0a       	mov	r10,0
80006b88:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006b8a:	fa c3 ff fc 	sub	r3,sp,-4
80006b8e:	e0 61 01 00 	mov	r1,256
80006b92:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006b94:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006b96:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006b9a:	02 9a       	mov	r10,r1
80006b9c:	00 9b       	mov	r11,r0
80006b9e:	06 9c       	mov	r12,r3
80006ba0:	f0 1f 00 43 	mcall	80006cac <logFromISR+0x140>
			
			if(*str == '%')
80006ba4:	0f 88       	ld.ub	r8,r7[0x0]
80006ba6:	e4 08 18 00 	cp.b	r8,r2
80006baa:	c5 11       	brne	80006c4c <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80006bac:	ee c8 ff ff 	sub	r8,r7,-1
80006bb0:	11 89       	ld.ub	r9,r8[0x0]
80006bb2:	4c 0a       	lddpc	r10,80006cb0 <logFromISR+0x144>
80006bb4:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80006bb6:	23 09       	sub	r9,48
80006bb8:	30 9a       	mov	r10,9
80006bba:	f4 09 18 00 	cp.b	r9,r10
80006bbe:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80006bc2:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006bc6:	f7 b9 08 30 	subls	r9,48
80006bca:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80006bce:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80006bd2:	0f 88       	ld.ub	r8,r7[0x0]
80006bd4:	22 58       	sub	r8,37
80006bd6:	e0 48 00 53 	cp.w	r8,83
80006bda:	e0 8b 00 2b 	brhi	80006c30 <logFromISR+0xc4>
80006bde:	4b 69       	lddpc	r9,80006cb4 <logFromISR+0x148>
80006be0:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006be4:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006be8:	06 9a       	mov	r10,r3
80006bea:	40 0b       	lddsp	r11,sp[0x0]
80006bec:	5c 5b       	castu.b	r11
80006bee:	68 0c       	ld.w	r12,r4[0x0]
80006bf0:	f0 1f 00 32 	mcall	80006cb8 <logFromISR+0x14c>
					break;
80006bf4:	c2 38       	rjmp	80006c3a <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80006bf6:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80006bfa:	06 9a       	mov	r10,r3
80006bfc:	40 0b       	lddsp	r11,sp[0x0]
80006bfe:	5c 5b       	castu.b	r11
80006c00:	68 0c       	ld.w	r12,r4[0x0]
80006c02:	f0 1f 00 2f 	mcall	80006cbc <logFromISR+0x150>
80006c06:	06 9c       	mov	r12,r3
					break;
80006c08:	c1 98       	rjmp	80006c3a <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80006c0a:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80006c0e:	06 9b       	mov	r11,r3
80006c10:	09 bc       	ld.ub	r12,r4[0x3]
80006c12:	f0 1f 00 2c 	mcall	80006cc0 <logFromISR+0x154>
80006c16:	06 9c       	mov	r12,r3
					break;
80006c18:	c1 18       	rjmp	80006c3a <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80006c1a:	e8 c5 ff fc 	sub	r5,r4,-4
80006c1e:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80006c20:	c0 d8       	rjmp	80006c3a <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80006c22:	06 9b       	mov	r11,r3
80006c24:	32 5c       	mov	r12,37
80006c26:	f0 1f 00 27 	mcall	80006cc0 <logFromISR+0x154>
80006c2a:	08 95       	mov	r5,r4
80006c2c:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80006c2e:	c0 68       	rjmp	80006c3a <logFromISR+0xce>
					default:
					log("I need relax.");
80006c30:	4a 5c       	lddpc	r12,80006cc4 <logFromISR+0x158>
80006c32:	f0 1f 00 26 	mcall	80006cc8 <logFromISR+0x15c>
80006c36:	08 95       	mov	r5,r4
80006c38:	06 9c       	mov	r12,r3
				}
				str++;
80006c3a:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006c3c:	1a dc       	st.w	--sp,r12
80006c3e:	1a d6       	st.w	--sp,r6
80006c40:	4a 3b       	lddpc	r11,80006ccc <logFromISR+0x160>
80006c42:	0c 9c       	mov	r12,r6
80006c44:	f0 1f 00 23 	mcall	80006cd0 <logFromISR+0x164>
80006c48:	2f ed       	sub	sp,-8
80006c4a:	c0 a8       	rjmp	80006c5e <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006c4c:	2f f7       	sub	r7,-1
80006c4e:	1a d8       	st.w	--sp,r8
80006c50:	1a d6       	st.w	--sp,r6
80006c52:	4a 1b       	lddpc	r11,80006cd4 <logFromISR+0x168>
80006c54:	0c 9c       	mov	r12,r6
80006c56:	f0 1f 00 1f 	mcall	80006cd0 <logFromISR+0x164>
80006c5a:	08 95       	mov	r5,r4
80006c5c:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80006c5e:	0f 89       	ld.ub	r9,r7[0x0]
80006c60:	30 08       	mov	r8,0
80006c62:	f0 09 18 00 	cp.b	r9,r8
80006c66:	c0 30       	breq	80006c6c <logFromISR+0x100>
80006c68:	0a 94       	mov	r4,r5
80006c6a:	c9 8b       	rjmp	80006b9a <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80006c6c:	fa c7 fe f4 	sub	r7,sp,-268
80006c70:	1a d7       	st.w	--sp,r7
80006c72:	49 ab       	lddpc	r11,80006cd8 <logFromISR+0x16c>
80006c74:	0e 9c       	mov	r12,r7
80006c76:	f0 1f 00 17 	mcall	80006cd0 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80006c7a:	5c 5c       	castu.b	r12
80006c7c:	f8 c6 ff ff 	sub	r6,r12,-1
80006c80:	0c 9c       	mov	r12,r6
80006c82:	f0 1f 00 17 	mcall	80006cdc <logFromISR+0x170>
80006c86:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80006c88:	0c 9a       	mov	r10,r6
80006c8a:	0e 9b       	mov	r11,r7
80006c8c:	f0 1f 00 15 	mcall	80006ce0 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006c90:	30 09       	mov	r9,0
80006c92:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80006c94:	fa ca fe f8 	sub	r10,sp,-264
80006c98:	fa cb fe f4 	sub	r11,sp,-268
80006c9c:	49 28       	lddpc	r8,80006ce4 <logFromISR+0x178>
80006c9e:	70 0c       	ld.w	r12,r8[0x0]
80006ca0:	f0 1f 00 12 	mcall	80006ce8 <logFromISR+0x17c>
80006ca4:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80006ca6:	fe 3d fd f4 	sub	sp,-524
80006caa:	d8 32       	popm	r0-r7,pc
80006cac:	80 00       	ld.sh	r0,r0[0x0]
80006cae:	73 bc       	ld.w	r12,r9[0x6c]
80006cb0:	00 00       	add	r0,r0
80006cb2:	0d 59       	ld.sh	r9,--r6
80006cb4:	80 00       	ld.sh	r0,r0[0x0]
80006cb6:	d4 20       	acall	0x42
80006cb8:	80 00       	ld.sh	r0,r0[0x0]
80006cba:	69 06       	ld.w	r6,r4[0x40]
80006cbc:	80 00       	ld.sh	r0,r0[0x0]
80006cbe:	68 54       	ld.w	r4,r4[0x14]
80006cc0:	80 00       	ld.sh	r0,r0[0x0]
80006cc2:	68 50       	ld.w	r0,r4[0x14]
80006cc4:	80 00       	ld.sh	r0,r0[0x0]
80006cc6:	d5 8c       	*unknown*
80006cc8:	80 00       	ld.sh	r0,r0[0x0]
80006cca:	69 e0       	ld.w	r0,r4[0x78]
80006ccc:	80 00       	ld.sh	r0,r0[0x0]
80006cce:	d5 9c       	*unknown*
80006cd0:	80 00       	ld.sh	r0,r0[0x0]
80006cd2:	76 ac       	ld.w	r12,r11[0x28]
80006cd4:	80 00       	ld.sh	r0,r0[0x0]
80006cd6:	d5 a4       	*unknown*
80006cd8:	80 00       	ld.sh	r0,r0[0x0]
80006cda:	d5 ac       	*unknown*
80006cdc:	80 00       	ld.sh	r0,r0[0x0]
80006cde:	5a f4       	cp.w	r4,-17
80006ce0:	80 00       	ld.sh	r0,r0[0x0]
80006ce2:	72 74       	ld.w	r4,r9[0x1c]
80006ce4:	00 00       	add	r0,r0
80006ce6:	51 18       	stdsp	sp[0x44],r8
80006ce8:	80 00       	ld.sh	r0,r0[0x0]
80006cea:	5d f8       	*unknown*

80006cec <log_init>:
		
	return str;
}

void log_init(void)
{
80006cec:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80006cee:	30 2b       	mov	r11,2
80006cf0:	49 0c       	lddpc	r12,80006d30 <log_init+0x44>
80006cf2:	f0 1f 00 11 	mcall	80006d34 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80006cf6:	e0 6a 36 00 	mov	r10,13824
80006cfa:	ea 1a 01 6e 	orh	r10,0x16e
80006cfe:	48 fb       	lddpc	r11,80006d38 <log_init+0x4c>
80006d00:	fe 7c 18 00 	mov	r12,-59392
80006d04:	f0 1f 00 0e 	mcall	80006d3c <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80006d08:	30 4b       	mov	r11,4
80006d0a:	33 2c       	mov	r12,50
80006d0c:	f0 1f 00 0d 	mcall	80006d40 <log_init+0x54>
80006d10:	48 d8       	lddpc	r8,80006d44 <log_init+0x58>
80006d12:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80006d14:	30 09       	mov	r9,0
80006d16:	1a d9       	st.w	--sp,r9
80006d18:	1a d9       	st.w	--sp,r9
80006d1a:	1a d9       	st.w	--sp,r9
80006d1c:	30 28       	mov	r8,2
80006d1e:	e0 6a 01 80 	mov	r10,384
80006d22:	48 ab       	lddpc	r11,80006d48 <log_init+0x5c>
80006d24:	48 ac       	lddpc	r12,80006d4c <log_init+0x60>
80006d26:	f0 1f 00 0b 	mcall	80006d50 <log_init+0x64>
80006d2a:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80006d2c:	d8 02       	popm	pc
80006d2e:	00 00       	add	r0,r0
80006d30:	80 00       	ld.sh	r0,r0[0x0]
80006d32:	d5 b8       	*unknown*
80006d34:	80 00       	ld.sh	r0,r0[0x0]
80006d36:	4f 28       	lddpc	r8,80006efc <_malloc_r+0xc0>
80006d38:	80 00       	ld.sh	r0,r0[0x0]
80006d3a:	d5 70       	acall	0x57
80006d3c:	80 00       	ld.sh	r0,r0[0x0]
80006d3e:	56 58       	stdsp	sp[0x194],r8
80006d40:	80 00       	ld.sh	r0,r0[0x0]
80006d42:	5f 48       	srge	r8
80006d44:	00 00       	add	r0,r0
80006d46:	51 18       	stdsp	sp[0x44],r8
80006d48:	80 00       	ld.sh	r0,r0[0x0]
80006d4a:	d5 b4       	*unknown*
80006d4c:	80 00       	ld.sh	r0,r0[0x0]
80006d4e:	6d 54       	ld.w	r4,r6[0x54]
80006d50:	80 00       	ld.sh	r0,r0[0x0]
80006d52:	66 1c       	ld.w	r12,r3[0x4]

80006d54 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80006d54:	eb cd 40 f8 	pushm	r3-r7,lr
80006d58:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006d5a:	48 c7       	lddpc	r7,80006d88 <task_log+0x34>
80006d5c:	30 05       	mov	r5,0
80006d5e:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80006d60:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006d64:	0a 99       	mov	r9,r5
80006d66:	08 9a       	mov	r10,r4
80006d68:	1a 9b       	mov	r11,sp
80006d6a:	6e 0c       	ld.w	r12,r7[0x0]
80006d6c:	f0 1f 00 08 	mcall	80006d8c <task_log+0x38>
80006d70:	58 1c       	cp.w	r12,1
80006d72:	cf 91       	brne	80006d64 <task_log+0x10>
		{
			if( NULL != str)
80006d74:	40 0b       	lddsp	r11,sp[0x0]
80006d76:	58 0b       	cp.w	r11,0
80006d78:	cf 60       	breq	80006d64 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80006d7a:	06 9c       	mov	r12,r3
80006d7c:	f0 1f 00 05 	mcall	80006d90 <task_log+0x3c>
				vPortFree(str);
80006d80:	40 0c       	lddsp	r12,sp[0x0]
80006d82:	f0 1f 00 05 	mcall	80006d94 <task_log+0x40>
80006d86:	ce fb       	rjmp	80006d64 <task_log+0x10>
80006d88:	00 00       	add	r0,r0
80006d8a:	51 18       	stdsp	sp[0x44],r8
80006d8c:	80 00       	ld.sh	r0,r0[0x0]
80006d8e:	5c 3c       	neg	r12
80006d90:	80 00       	ld.sh	r0,r0[0x0]
80006d92:	56 08       	stdsp	sp[0x180],r8
80006d94:	80 00       	ld.sh	r0,r0[0x0]
80006d96:	5a cc       	cp.w	r12,-20

80006d98 <main>:
#include "rtc.h"
#include "app.h"


int main (void)
{
80006d98:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80006d9a:	fe 78 10 00 	mov	r8,-61440
80006d9e:	30 19       	mov	r9,1
80006da0:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80006da4:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80006da8:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80006dac:	d3 03       	ssrf	0x10
	local_start_pll0();
80006dae:	f0 1f 00 12 	mcall	80006df4 <main+0x5c>
		
	INTC_init_interrupts();
80006db2:	f0 1f 00 12 	mcall	80006df8 <main+0x60>
		
	log_init();
80006db6:	f0 1f 00 12 	mcall	80006dfc <main+0x64>
	log("----start debug----");
80006dba:	49 2c       	lddpc	r12,80006e00 <main+0x68>
80006dbc:	f0 1f 00 12 	mcall	80006e04 <main+0x6c>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
80006dc0:	f0 1f 00 12 	mcall	80006e08 <main+0x70>
		
	app_init();
80006dc4:	f0 1f 00 12 	mcall	80006e0c <main+0x74>
		
	xcmp_init();
80006dc8:	f0 1f 00 12 	mcall	80006e10 <main+0x78>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80006dcc:	fe 79 10 00 	mov	r9,-61440
80006dd0:	f2 f8 01 60 	ld.w	r8,r9[352]
80006dd4:	e2 18 00 02 	andl	r8,0x2,COH
80006dd8:	cf c0       	breq	80006dd0 <main+0x38>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80006dda:	fe 79 10 00 	mov	r9,-61440
80006dde:	f2 f8 01 60 	ld.w	r8,r9[352]
80006de2:	e2 18 00 02 	andl	r8,0x2,COH
80006de6:	cf c1       	brne	80006dde <main+0x46>
	local_start_timer();
80006de8:	f0 1f 00 0b 	mcall	80006e14 <main+0x7c>
		
	Enable_global_interrupt();
80006dec:	d5 03       	csrf	0x10
		
	vTaskStartScheduler();
80006dee:	f0 1f 00 0b 	mcall	80006e18 <main+0x80>
	return 0;
	
}
80006df2:	d8 0a       	popm	pc,r12=0
80006df4:	80 00       	ld.sh	r0,r0[0x0]
80006df6:	4d c8       	lddpc	r8,80006f64 <_malloc_r+0x128>
80006df8:	80 00       	ld.sh	r0,r0[0x0]
80006dfa:	50 2c       	stdsp	sp[0x8],r12
80006dfc:	80 00       	ld.sh	r0,r0[0x0]
80006dfe:	6c ec       	ld.w	r12,r6[0x38]
80006e00:	80 00       	ld.sh	r0,r0[0x0]
80006e02:	d5 c8       	*unknown*
80006e04:	80 00       	ld.sh	r0,r0[0x0]
80006e06:	69 e0       	ld.w	r0,r4[0x78]
80006e08:	80 00       	ld.sh	r0,r0[0x0]
80006e0a:	4d b4       	lddpc	r4,80006f74 <_malloc_r+0x138>
80006e0c:	80 00       	ld.sh	r0,r0[0x0]
80006e0e:	20 3c       	sub	r12,3
80006e10:	80 00       	ld.sh	r0,r0[0x0]
80006e12:	43 0c       	lddsp	r12,sp[0xc0]
80006e14:	80 00       	ld.sh	r0,r0[0x0]
80006e16:	4e 18       	lddpc	r8,80006f98 <_malloc_r+0x15c>
80006e18:	80 00       	ld.sh	r0,r0[0x0]
80006e1a:	68 04       	ld.w	r4,r4[0x0]

80006e1c <free>:
80006e1c:	d4 01       	pushm	lr
80006e1e:	e0 68 0a 40 	mov	r8,2624
80006e22:	18 9b       	mov	r11,r12
80006e24:	70 0c       	ld.w	r12,r8[0x0]
80006e26:	e0 a0 1e 61 	rcall	8000aae8 <_free_r>
80006e2a:	d8 02       	popm	pc

80006e2c <malloc>:
80006e2c:	d4 01       	pushm	lr
80006e2e:	e0 68 0a 40 	mov	r8,2624
80006e32:	18 9b       	mov	r11,r12
80006e34:	70 0c       	ld.w	r12,r8[0x0]
80006e36:	c0 3c       	rcall	80006e3c <_malloc_r>
80006e38:	d8 02       	popm	pc
80006e3a:	d7 03       	nop

80006e3c <_malloc_r>:
80006e3c:	d4 31       	pushm	r0-r7,lr
80006e3e:	f6 c8 ff f5 	sub	r8,r11,-11
80006e42:	18 95       	mov	r5,r12
80006e44:	10 97       	mov	r7,r8
80006e46:	e0 17 ff f8 	andl	r7,0xfff8
80006e4a:	59 68       	cp.w	r8,22
80006e4c:	f9 b7 08 10 	movls	r7,16
80006e50:	16 37       	cp.w	r7,r11
80006e52:	5f 38       	srlo	r8
80006e54:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80006e58:	c0 50       	breq	80006e62 <_malloc_r+0x26>
80006e5a:	30 c8       	mov	r8,12
80006e5c:	99 38       	st.w	r12[0xc],r8
80006e5e:	e0 8f 01 fa 	bral	80007252 <_malloc_r+0x416>
80006e62:	fe b0 f5 eb 	rcall	80005a38 <__malloc_lock>
80006e66:	e0 47 01 f7 	cp.w	r7,503
80006e6a:	e0 8b 00 1d 	brhi	80006ea4 <_malloc_r+0x68>
80006e6e:	ee 03 16 03 	lsr	r3,r7,0x3
80006e72:	e0 68 05 40 	mov	r8,1344
80006e76:	f0 03 00 38 	add	r8,r8,r3<<0x3
80006e7a:	70 36       	ld.w	r6,r8[0xc]
80006e7c:	10 36       	cp.w	r6,r8
80006e7e:	c0 61       	brne	80006e8a <_malloc_r+0x4e>
80006e80:	ec c8 ff f8 	sub	r8,r6,-8
80006e84:	70 36       	ld.w	r6,r8[0xc]
80006e86:	10 36       	cp.w	r6,r8
80006e88:	c0 c0       	breq	80006ea0 <_malloc_r+0x64>
80006e8a:	6c 18       	ld.w	r8,r6[0x4]
80006e8c:	e0 18 ff fc 	andl	r8,0xfffc
80006e90:	6c 3a       	ld.w	r10,r6[0xc]
80006e92:	ec 08 00 09 	add	r9,r6,r8
80006e96:	0a 9c       	mov	r12,r5
80006e98:	6c 28       	ld.w	r8,r6[0x8]
80006e9a:	95 28       	st.w	r10[0x8],r8
80006e9c:	91 3a       	st.w	r8[0xc],r10
80006e9e:	c4 78       	rjmp	80006f2c <_malloc_r+0xf0>
80006ea0:	2f e3       	sub	r3,-2
80006ea2:	c4 d8       	rjmp	80006f3c <_malloc_r+0x100>
80006ea4:	ee 03 16 09 	lsr	r3,r7,0x9
80006ea8:	c0 41       	brne	80006eb0 <_malloc_r+0x74>
80006eaa:	ee 03 16 03 	lsr	r3,r7,0x3
80006eae:	c2 68       	rjmp	80006efa <_malloc_r+0xbe>
80006eb0:	58 43       	cp.w	r3,4
80006eb2:	e0 8b 00 06 	brhi	80006ebe <_malloc_r+0x82>
80006eb6:	ee 03 16 06 	lsr	r3,r7,0x6
80006eba:	2c 83       	sub	r3,-56
80006ebc:	c1 f8       	rjmp	80006efa <_malloc_r+0xbe>
80006ebe:	59 43       	cp.w	r3,20
80006ec0:	e0 8b 00 04 	brhi	80006ec8 <_malloc_r+0x8c>
80006ec4:	2a 53       	sub	r3,-91
80006ec6:	c1 a8       	rjmp	80006efa <_malloc_r+0xbe>
80006ec8:	e0 43 00 54 	cp.w	r3,84
80006ecc:	e0 8b 00 06 	brhi	80006ed8 <_malloc_r+0x9c>
80006ed0:	ee 03 16 0c 	lsr	r3,r7,0xc
80006ed4:	29 23       	sub	r3,-110
80006ed6:	c1 28       	rjmp	80006efa <_malloc_r+0xbe>
80006ed8:	e0 43 01 54 	cp.w	r3,340
80006edc:	e0 8b 00 06 	brhi	80006ee8 <_malloc_r+0xac>
80006ee0:	ee 03 16 0f 	lsr	r3,r7,0xf
80006ee4:	28 93       	sub	r3,-119
80006ee6:	c0 a8       	rjmp	80006efa <_malloc_r+0xbe>
80006ee8:	e0 43 05 54 	cp.w	r3,1364
80006eec:	e0 88 00 04 	brls	80006ef4 <_malloc_r+0xb8>
80006ef0:	37 e3       	mov	r3,126
80006ef2:	c0 48       	rjmp	80006efa <_malloc_r+0xbe>
80006ef4:	ee 03 16 12 	lsr	r3,r7,0x12
80006ef8:	28 43       	sub	r3,-124
80006efa:	e0 6a 05 40 	mov	r10,1344
80006efe:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80006f02:	74 36       	ld.w	r6,r10[0xc]
80006f04:	c1 98       	rjmp	80006f36 <_malloc_r+0xfa>
80006f06:	6c 19       	ld.w	r9,r6[0x4]
80006f08:	e0 19 ff fc 	andl	r9,0xfffc
80006f0c:	f2 07 01 0b 	sub	r11,r9,r7
80006f10:	58 fb       	cp.w	r11,15
80006f12:	e0 8a 00 04 	brle	80006f1a <_malloc_r+0xde>
80006f16:	20 13       	sub	r3,1
80006f18:	c1 18       	rjmp	80006f3a <_malloc_r+0xfe>
80006f1a:	6c 38       	ld.w	r8,r6[0xc]
80006f1c:	58 0b       	cp.w	r11,0
80006f1e:	c0 b5       	brlt	80006f34 <_malloc_r+0xf8>
80006f20:	6c 2a       	ld.w	r10,r6[0x8]
80006f22:	ec 09 00 09 	add	r9,r6,r9
80006f26:	0a 9c       	mov	r12,r5
80006f28:	91 2a       	st.w	r8[0x8],r10
80006f2a:	95 38       	st.w	r10[0xc],r8
80006f2c:	72 18       	ld.w	r8,r9[0x4]
80006f2e:	a1 a8       	sbr	r8,0x0
80006f30:	93 18       	st.w	r9[0x4],r8
80006f32:	cb c8       	rjmp	800070aa <_malloc_r+0x26e>
80006f34:	10 96       	mov	r6,r8
80006f36:	14 36       	cp.w	r6,r10
80006f38:	ce 71       	brne	80006f06 <_malloc_r+0xca>
80006f3a:	2f f3       	sub	r3,-1
80006f3c:	e0 6a 05 40 	mov	r10,1344
80006f40:	f4 cc ff f8 	sub	r12,r10,-8
80006f44:	78 26       	ld.w	r6,r12[0x8]
80006f46:	18 36       	cp.w	r6,r12
80006f48:	c6 c0       	breq	80007020 <_malloc_r+0x1e4>
80006f4a:	6c 19       	ld.w	r9,r6[0x4]
80006f4c:	e0 19 ff fc 	andl	r9,0xfffc
80006f50:	f2 07 01 08 	sub	r8,r9,r7
80006f54:	58 f8       	cp.w	r8,15
80006f56:	e0 89 00 8f 	brgt	80007074 <_malloc_r+0x238>
80006f5a:	99 3c       	st.w	r12[0xc],r12
80006f5c:	99 2c       	st.w	r12[0x8],r12
80006f5e:	58 08       	cp.w	r8,0
80006f60:	c0 55       	brlt	80006f6a <_malloc_r+0x12e>
80006f62:	ec 09 00 09 	add	r9,r6,r9
80006f66:	0a 9c       	mov	r12,r5
80006f68:	ce 2b       	rjmp	80006f2c <_malloc_r+0xf0>
80006f6a:	e0 49 01 ff 	cp.w	r9,511
80006f6e:	e0 8b 00 13 	brhi	80006f94 <_malloc_r+0x158>
80006f72:	a3 99       	lsr	r9,0x3
80006f74:	f4 09 00 38 	add	r8,r10,r9<<0x3
80006f78:	70 2b       	ld.w	r11,r8[0x8]
80006f7a:	8d 38       	st.w	r6[0xc],r8
80006f7c:	8d 2b       	st.w	r6[0x8],r11
80006f7e:	97 36       	st.w	r11[0xc],r6
80006f80:	91 26       	st.w	r8[0x8],r6
80006f82:	a3 49       	asr	r9,0x2
80006f84:	74 18       	ld.w	r8,r10[0x4]
80006f86:	30 1b       	mov	r11,1
80006f88:	f6 09 09 49 	lsl	r9,r11,r9
80006f8c:	f1 e9 10 09 	or	r9,r8,r9
80006f90:	95 19       	st.w	r10[0x4],r9
80006f92:	c4 78       	rjmp	80007020 <_malloc_r+0x1e4>
80006f94:	f2 0a 16 09 	lsr	r10,r9,0x9
80006f98:	58 4a       	cp.w	r10,4
80006f9a:	e0 8b 00 07 	brhi	80006fa8 <_malloc_r+0x16c>
80006f9e:	f2 0a 16 06 	lsr	r10,r9,0x6
80006fa2:	2c 8a       	sub	r10,-56
80006fa4:	c2 08       	rjmp	80006fe4 <_malloc_r+0x1a8>
80006fa6:	d7 03       	nop
80006fa8:	59 4a       	cp.w	r10,20
80006faa:	e0 8b 00 04 	brhi	80006fb2 <_malloc_r+0x176>
80006fae:	2a 5a       	sub	r10,-91
80006fb0:	c1 a8       	rjmp	80006fe4 <_malloc_r+0x1a8>
80006fb2:	e0 4a 00 54 	cp.w	r10,84
80006fb6:	e0 8b 00 06 	brhi	80006fc2 <_malloc_r+0x186>
80006fba:	f2 0a 16 0c 	lsr	r10,r9,0xc
80006fbe:	29 2a       	sub	r10,-110
80006fc0:	c1 28       	rjmp	80006fe4 <_malloc_r+0x1a8>
80006fc2:	e0 4a 01 54 	cp.w	r10,340
80006fc6:	e0 8b 00 06 	brhi	80006fd2 <_malloc_r+0x196>
80006fca:	f2 0a 16 0f 	lsr	r10,r9,0xf
80006fce:	28 9a       	sub	r10,-119
80006fd0:	c0 a8       	rjmp	80006fe4 <_malloc_r+0x1a8>
80006fd2:	e0 4a 05 54 	cp.w	r10,1364
80006fd6:	e0 88 00 04 	brls	80006fde <_malloc_r+0x1a2>
80006fda:	37 ea       	mov	r10,126
80006fdc:	c0 48       	rjmp	80006fe4 <_malloc_r+0x1a8>
80006fde:	f2 0a 16 12 	lsr	r10,r9,0x12
80006fe2:	28 4a       	sub	r10,-124
80006fe4:	e0 6b 05 40 	mov	r11,1344
80006fe8:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80006fec:	68 28       	ld.w	r8,r4[0x8]
80006fee:	08 38       	cp.w	r8,r4
80006ff0:	c0 e1       	brne	8000700c <_malloc_r+0x1d0>
80006ff2:	76 19       	ld.w	r9,r11[0x4]
80006ff4:	a3 4a       	asr	r10,0x2
80006ff6:	30 1e       	mov	lr,1
80006ff8:	fc 0a 09 4a 	lsl	r10,lr,r10
80006ffc:	f3 ea 10 0a 	or	r10,r9,r10
80007000:	10 99       	mov	r9,r8
80007002:	97 1a       	st.w	r11[0x4],r10
80007004:	c0 a8       	rjmp	80007018 <_malloc_r+0x1dc>
80007006:	70 28       	ld.w	r8,r8[0x8]
80007008:	08 38       	cp.w	r8,r4
8000700a:	c0 60       	breq	80007016 <_malloc_r+0x1da>
8000700c:	70 1a       	ld.w	r10,r8[0x4]
8000700e:	e0 1a ff fc 	andl	r10,0xfffc
80007012:	14 39       	cp.w	r9,r10
80007014:	cf 93       	brcs	80007006 <_malloc_r+0x1ca>
80007016:	70 39       	ld.w	r9,r8[0xc]
80007018:	8d 39       	st.w	r6[0xc],r9
8000701a:	8d 28       	st.w	r6[0x8],r8
8000701c:	91 36       	st.w	r8[0xc],r6
8000701e:	93 26       	st.w	r9[0x8],r6
80007020:	e6 08 14 02 	asr	r8,r3,0x2
80007024:	30 1b       	mov	r11,1
80007026:	e0 64 05 40 	mov	r4,1344
8000702a:	f6 08 09 4b 	lsl	r11,r11,r8
8000702e:	68 18       	ld.w	r8,r4[0x4]
80007030:	10 3b       	cp.w	r11,r8
80007032:	e0 8b 00 6b 	brhi	80007108 <_malloc_r+0x2cc>
80007036:	f7 e8 00 09 	and	r9,r11,r8
8000703a:	c0 b1       	brne	80007050 <_malloc_r+0x214>
8000703c:	e0 13 ff fc 	andl	r3,0xfffc
80007040:	a1 7b       	lsl	r11,0x1
80007042:	2f c3       	sub	r3,-4
80007044:	c0 38       	rjmp	8000704a <_malloc_r+0x20e>
80007046:	2f c3       	sub	r3,-4
80007048:	a1 7b       	lsl	r11,0x1
8000704a:	f7 e8 00 09 	and	r9,r11,r8
8000704e:	cf c0       	breq	80007046 <_malloc_r+0x20a>
80007050:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80007054:	06 92       	mov	r2,r3
80007056:	1c 91       	mov	r1,lr
80007058:	62 36       	ld.w	r6,r1[0xc]
8000705a:	c2 e8       	rjmp	800070b6 <_malloc_r+0x27a>
8000705c:	6c 1a       	ld.w	r10,r6[0x4]
8000705e:	e0 1a ff fc 	andl	r10,0xfffc
80007062:	f4 07 01 08 	sub	r8,r10,r7
80007066:	58 f8       	cp.w	r8,15
80007068:	e0 8a 00 15 	brle	80007092 <_malloc_r+0x256>
8000706c:	6c 3a       	ld.w	r10,r6[0xc]
8000706e:	6c 29       	ld.w	r9,r6[0x8]
80007070:	95 29       	st.w	r10[0x8],r9
80007072:	93 3a       	st.w	r9[0xc],r10
80007074:	0e 99       	mov	r9,r7
80007076:	ec 07 00 07 	add	r7,r6,r7
8000707a:	a1 a9       	sbr	r9,0x0
8000707c:	99 37       	st.w	r12[0xc],r7
8000707e:	99 27       	st.w	r12[0x8],r7
80007080:	8d 19       	st.w	r6[0x4],r9
80007082:	ee 08 09 08 	st.w	r7[r8],r8
80007086:	8f 2c       	st.w	r7[0x8],r12
80007088:	8f 3c       	st.w	r7[0xc],r12
8000708a:	a1 a8       	sbr	r8,0x0
8000708c:	0a 9c       	mov	r12,r5
8000708e:	8f 18       	st.w	r7[0x4],r8
80007090:	c0 d8       	rjmp	800070aa <_malloc_r+0x26e>
80007092:	6c 39       	ld.w	r9,r6[0xc]
80007094:	58 08       	cp.w	r8,0
80007096:	c0 f5       	brlt	800070b4 <_malloc_r+0x278>
80007098:	ec 0a 00 0a 	add	r10,r6,r10
8000709c:	74 18       	ld.w	r8,r10[0x4]
8000709e:	a1 a8       	sbr	r8,0x0
800070a0:	0a 9c       	mov	r12,r5
800070a2:	95 18       	st.w	r10[0x4],r8
800070a4:	6c 28       	ld.w	r8,r6[0x8]
800070a6:	93 28       	st.w	r9[0x8],r8
800070a8:	91 39       	st.w	r8[0xc],r9
800070aa:	fe b0 f4 cd 	rcall	80005a44 <__malloc_unlock>
800070ae:	ec cc ff f8 	sub	r12,r6,-8
800070b2:	d8 32       	popm	r0-r7,pc
800070b4:	12 96       	mov	r6,r9
800070b6:	02 36       	cp.w	r6,r1
800070b8:	cd 21       	brne	8000705c <_malloc_r+0x220>
800070ba:	2f f2       	sub	r2,-1
800070bc:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800070c0:	c0 30       	breq	800070c6 <_malloc_r+0x28a>
800070c2:	2f 81       	sub	r1,-8
800070c4:	cc ab       	rjmp	80007058 <_malloc_r+0x21c>
800070c6:	1c 98       	mov	r8,lr
800070c8:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
800070cc:	c0 81       	brne	800070dc <_malloc_r+0x2a0>
800070ce:	68 19       	ld.w	r9,r4[0x4]
800070d0:	f6 08 11 ff 	rsub	r8,r11,-1
800070d4:	f3 e8 00 08 	and	r8,r9,r8
800070d8:	89 18       	st.w	r4[0x4],r8
800070da:	c0 78       	rjmp	800070e8 <_malloc_r+0x2ac>
800070dc:	f0 c9 00 08 	sub	r9,r8,8
800070e0:	20 13       	sub	r3,1
800070e2:	70 08       	ld.w	r8,r8[0x0]
800070e4:	12 38       	cp.w	r8,r9
800070e6:	cf 10       	breq	800070c8 <_malloc_r+0x28c>
800070e8:	a1 7b       	lsl	r11,0x1
800070ea:	68 18       	ld.w	r8,r4[0x4]
800070ec:	10 3b       	cp.w	r11,r8
800070ee:	e0 8b 00 0d 	brhi	80007108 <_malloc_r+0x2cc>
800070f2:	58 0b       	cp.w	r11,0
800070f4:	c0 a0       	breq	80007108 <_malloc_r+0x2cc>
800070f6:	04 93       	mov	r3,r2
800070f8:	c0 38       	rjmp	800070fe <_malloc_r+0x2c2>
800070fa:	2f c3       	sub	r3,-4
800070fc:	a1 7b       	lsl	r11,0x1
800070fe:	f7 e8 00 09 	and	r9,r11,r8
80007102:	ca 71       	brne	80007050 <_malloc_r+0x214>
80007104:	cf bb       	rjmp	800070fa <_malloc_r+0x2be>
80007106:	d7 03       	nop
80007108:	68 23       	ld.w	r3,r4[0x8]
8000710a:	66 12       	ld.w	r2,r3[0x4]
8000710c:	e0 12 ff fc 	andl	r2,0xfffc
80007110:	0e 32       	cp.w	r2,r7
80007112:	5f 39       	srlo	r9
80007114:	e4 07 01 08 	sub	r8,r2,r7
80007118:	58 f8       	cp.w	r8,15
8000711a:	5f aa       	srle	r10
8000711c:	f5 e9 10 09 	or	r9,r10,r9
80007120:	e0 80 00 9a 	breq	80007254 <_malloc_r+0x418>
80007124:	e0 68 0d 64 	mov	r8,3428
80007128:	70 01       	ld.w	r1,r8[0x0]
8000712a:	e0 68 09 4c 	mov	r8,2380
8000712e:	2f 01       	sub	r1,-16
80007130:	70 08       	ld.w	r8,r8[0x0]
80007132:	0e 01       	add	r1,r7
80007134:	5b f8       	cp.w	r8,-1
80007136:	c0 40       	breq	8000713e <_malloc_r+0x302>
80007138:	28 11       	sub	r1,-127
8000713a:	e0 11 ff 80 	andl	r1,0xff80
8000713e:	02 9b       	mov	r11,r1
80007140:	0a 9c       	mov	r12,r5
80007142:	e0 a0 02 a5 	rcall	8000768c <_sbrk_r>
80007146:	18 96       	mov	r6,r12
80007148:	5b fc       	cp.w	r12,-1
8000714a:	c7 50       	breq	80007234 <_malloc_r+0x3f8>
8000714c:	e6 02 00 08 	add	r8,r3,r2
80007150:	10 3c       	cp.w	r12,r8
80007152:	c0 32       	brcc	80007158 <_malloc_r+0x31c>
80007154:	08 33       	cp.w	r3,r4
80007156:	c6 f1       	brne	80007234 <_malloc_r+0x3f8>
80007158:	e0 6a 0d 68 	mov	r10,3432
8000715c:	74 09       	ld.w	r9,r10[0x0]
8000715e:	e2 09 00 09 	add	r9,r1,r9
80007162:	95 09       	st.w	r10[0x0],r9
80007164:	10 36       	cp.w	r6,r8
80007166:	c0 a1       	brne	8000717a <_malloc_r+0x33e>
80007168:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000716c:	c0 71       	brne	8000717a <_malloc_r+0x33e>
8000716e:	e2 02 00 02 	add	r2,r1,r2
80007172:	68 28       	ld.w	r8,r4[0x8]
80007174:	a1 a2       	sbr	r2,0x0
80007176:	91 12       	st.w	r8[0x4],r2
80007178:	c4 f8       	rjmp	80007216 <_malloc_r+0x3da>
8000717a:	e0 6a 09 4c 	mov	r10,2380
8000717e:	74 0b       	ld.w	r11,r10[0x0]
80007180:	5b fb       	cp.w	r11,-1
80007182:	c0 31       	brne	80007188 <_malloc_r+0x34c>
80007184:	95 06       	st.w	r10[0x0],r6
80007186:	c0 78       	rjmp	80007194 <_malloc_r+0x358>
80007188:	ec 09 00 09 	add	r9,r6,r9
8000718c:	e0 6a 0d 68 	mov	r10,3432
80007190:	10 19       	sub	r9,r8
80007192:	95 09       	st.w	r10[0x0],r9
80007194:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80007198:	f0 09 11 08 	rsub	r9,r8,8
8000719c:	58 08       	cp.w	r8,0
8000719e:	f2 08 17 10 	movne	r8,r9
800071a2:	ed d8 e1 06 	addne	r6,r6,r8
800071a6:	28 08       	sub	r8,-128
800071a8:	ec 01 00 01 	add	r1,r6,r1
800071ac:	0a 9c       	mov	r12,r5
800071ae:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800071b2:	f0 01 01 01 	sub	r1,r8,r1
800071b6:	02 9b       	mov	r11,r1
800071b8:	e0 a0 02 6a 	rcall	8000768c <_sbrk_r>
800071bc:	e0 68 0d 68 	mov	r8,3432
800071c0:	5b fc       	cp.w	r12,-1
800071c2:	ec 0c 17 00 	moveq	r12,r6
800071c6:	f9 b1 00 00 	moveq	r1,0
800071ca:	70 09       	ld.w	r9,r8[0x0]
800071cc:	0c 1c       	sub	r12,r6
800071ce:	89 26       	st.w	r4[0x8],r6
800071d0:	02 0c       	add	r12,r1
800071d2:	12 01       	add	r1,r9
800071d4:	a1 ac       	sbr	r12,0x0
800071d6:	91 01       	st.w	r8[0x0],r1
800071d8:	8d 1c       	st.w	r6[0x4],r12
800071da:	08 33       	cp.w	r3,r4
800071dc:	c1 d0       	breq	80007216 <_malloc_r+0x3da>
800071de:	58 f2       	cp.w	r2,15
800071e0:	e0 8b 00 05 	brhi	800071ea <_malloc_r+0x3ae>
800071e4:	30 18       	mov	r8,1
800071e6:	8d 18       	st.w	r6[0x4],r8
800071e8:	c2 68       	rjmp	80007234 <_malloc_r+0x3f8>
800071ea:	30 59       	mov	r9,5
800071ec:	20 c2       	sub	r2,12
800071ee:	e0 12 ff f8 	andl	r2,0xfff8
800071f2:	e6 02 00 08 	add	r8,r3,r2
800071f6:	91 29       	st.w	r8[0x8],r9
800071f8:	91 19       	st.w	r8[0x4],r9
800071fa:	66 18       	ld.w	r8,r3[0x4]
800071fc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007200:	e5 e8 10 08 	or	r8,r2,r8
80007204:	87 18       	st.w	r3[0x4],r8
80007206:	58 f2       	cp.w	r2,15
80007208:	e0 88 00 07 	brls	80007216 <_malloc_r+0x3da>
8000720c:	e6 cb ff f8 	sub	r11,r3,-8
80007210:	0a 9c       	mov	r12,r5
80007212:	e0 a0 1c 6b 	rcall	8000aae8 <_free_r>
80007216:	e0 69 0d 60 	mov	r9,3424
8000721a:	72 0a       	ld.w	r10,r9[0x0]
8000721c:	e0 68 0d 68 	mov	r8,3432
80007220:	70 08       	ld.w	r8,r8[0x0]
80007222:	14 38       	cp.w	r8,r10
80007224:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007228:	e0 69 0d 5c 	mov	r9,3420
8000722c:	72 0a       	ld.w	r10,r9[0x0]
8000722e:	14 38       	cp.w	r8,r10
80007230:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007234:	68 28       	ld.w	r8,r4[0x8]
80007236:	70 18       	ld.w	r8,r8[0x4]
80007238:	e0 18 ff fc 	andl	r8,0xfffc
8000723c:	0e 38       	cp.w	r8,r7
8000723e:	5f 39       	srlo	r9
80007240:	0e 18       	sub	r8,r7
80007242:	58 f8       	cp.w	r8,15
80007244:	5f aa       	srle	r10
80007246:	f5 e9 10 09 	or	r9,r10,r9
8000724a:	c0 50       	breq	80007254 <_malloc_r+0x418>
8000724c:	0a 9c       	mov	r12,r5
8000724e:	fe b0 f3 fb 	rcall	80005a44 <__malloc_unlock>
80007252:	d8 3a       	popm	r0-r7,pc,r12=0
80007254:	68 26       	ld.w	r6,r4[0x8]
80007256:	a1 a8       	sbr	r8,0x0
80007258:	0e 99       	mov	r9,r7
8000725a:	a1 a9       	sbr	r9,0x0
8000725c:	8d 19       	st.w	r6[0x4],r9
8000725e:	ec 07 00 07 	add	r7,r6,r7
80007262:	0a 9c       	mov	r12,r5
80007264:	89 27       	st.w	r4[0x8],r7
80007266:	8f 18       	st.w	r7[0x4],r8
80007268:	fe b0 f3 ee 	rcall	80005a44 <__malloc_unlock>
8000726c:	ec cc ff f8 	sub	r12,r6,-8
80007270:	d8 32       	popm	r0-r7,pc
80007272:	d7 03       	nop

80007274 <memcpy>:
80007274:	58 8a       	cp.w	r10,8
80007276:	c2 f5       	brlt	800072d4 <memcpy+0x60>
80007278:	f9 eb 10 09 	or	r9,r12,r11
8000727c:	e2 19 00 03 	andl	r9,0x3,COH
80007280:	e0 81 00 97 	brne	800073ae <memcpy+0x13a>
80007284:	e0 4a 00 20 	cp.w	r10,32
80007288:	c3 b4       	brge	800072fe <memcpy+0x8a>
8000728a:	f4 08 14 02 	asr	r8,r10,0x2
8000728e:	f0 09 11 08 	rsub	r9,r8,8
80007292:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80007296:	76 69       	ld.w	r9,r11[0x18]
80007298:	99 69       	st.w	r12[0x18],r9
8000729a:	76 59       	ld.w	r9,r11[0x14]
8000729c:	99 59       	st.w	r12[0x14],r9
8000729e:	76 49       	ld.w	r9,r11[0x10]
800072a0:	99 49       	st.w	r12[0x10],r9
800072a2:	76 39       	ld.w	r9,r11[0xc]
800072a4:	99 39       	st.w	r12[0xc],r9
800072a6:	76 29       	ld.w	r9,r11[0x8]
800072a8:	99 29       	st.w	r12[0x8],r9
800072aa:	76 19       	ld.w	r9,r11[0x4]
800072ac:	99 19       	st.w	r12[0x4],r9
800072ae:	76 09       	ld.w	r9,r11[0x0]
800072b0:	99 09       	st.w	r12[0x0],r9
800072b2:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800072b6:	f8 08 00 28 	add	r8,r12,r8<<0x2
800072ba:	e0 1a 00 03 	andl	r10,0x3
800072be:	f4 0a 11 04 	rsub	r10,r10,4
800072c2:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800072c6:	17 a9       	ld.ub	r9,r11[0x2]
800072c8:	b0 a9       	st.b	r8[0x2],r9
800072ca:	17 99       	ld.ub	r9,r11[0x1]
800072cc:	b0 99       	st.b	r8[0x1],r9
800072ce:	17 89       	ld.ub	r9,r11[0x0]
800072d0:	b0 89       	st.b	r8[0x0],r9
800072d2:	5e fc       	retal	r12
800072d4:	f4 0a 11 09 	rsub	r10,r10,9
800072d8:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800072dc:	17 f9       	ld.ub	r9,r11[0x7]
800072de:	b8 f9       	st.b	r12[0x7],r9
800072e0:	17 e9       	ld.ub	r9,r11[0x6]
800072e2:	b8 e9       	st.b	r12[0x6],r9
800072e4:	17 d9       	ld.ub	r9,r11[0x5]
800072e6:	b8 d9       	st.b	r12[0x5],r9
800072e8:	17 c9       	ld.ub	r9,r11[0x4]
800072ea:	b8 c9       	st.b	r12[0x4],r9
800072ec:	17 b9       	ld.ub	r9,r11[0x3]
800072ee:	b8 b9       	st.b	r12[0x3],r9
800072f0:	17 a9       	ld.ub	r9,r11[0x2]
800072f2:	b8 a9       	st.b	r12[0x2],r9
800072f4:	17 99       	ld.ub	r9,r11[0x1]
800072f6:	b8 99       	st.b	r12[0x1],r9
800072f8:	17 89       	ld.ub	r9,r11[0x0]
800072fa:	b8 89       	st.b	r12[0x0],r9
800072fc:	5e fc       	retal	r12
800072fe:	eb cd 40 c0 	pushm	r6-r7,lr
80007302:	18 99       	mov	r9,r12
80007304:	22 0a       	sub	r10,32
80007306:	b7 07       	ld.d	r6,r11++
80007308:	b3 26       	st.d	r9++,r6
8000730a:	b7 07       	ld.d	r6,r11++
8000730c:	b3 26       	st.d	r9++,r6
8000730e:	b7 07       	ld.d	r6,r11++
80007310:	b3 26       	st.d	r9++,r6
80007312:	b7 07       	ld.d	r6,r11++
80007314:	b3 26       	st.d	r9++,r6
80007316:	22 0a       	sub	r10,32
80007318:	cf 74       	brge	80007306 <memcpy+0x92>
8000731a:	2f 0a       	sub	r10,-16
8000731c:	c0 65       	brlt	80007328 <memcpy+0xb4>
8000731e:	b7 07       	ld.d	r6,r11++
80007320:	b3 26       	st.d	r9++,r6
80007322:	b7 07       	ld.d	r6,r11++
80007324:	b3 26       	st.d	r9++,r6
80007326:	21 0a       	sub	r10,16
80007328:	5c 3a       	neg	r10
8000732a:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000732e:	d7 03       	nop
80007330:	d7 03       	nop
80007332:	f7 36 00 0e 	ld.ub	r6,r11[14]
80007336:	f3 66 00 0e 	st.b	r9[14],r6
8000733a:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000733e:	f3 66 00 0d 	st.b	r9[13],r6
80007342:	f7 36 00 0c 	ld.ub	r6,r11[12]
80007346:	f3 66 00 0c 	st.b	r9[12],r6
8000734a:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000734e:	f3 66 00 0b 	st.b	r9[11],r6
80007352:	f7 36 00 0a 	ld.ub	r6,r11[10]
80007356:	f3 66 00 0a 	st.b	r9[10],r6
8000735a:	f7 36 00 09 	ld.ub	r6,r11[9]
8000735e:	f3 66 00 09 	st.b	r9[9],r6
80007362:	f7 36 00 08 	ld.ub	r6,r11[8]
80007366:	f3 66 00 08 	st.b	r9[8],r6
8000736a:	f7 36 00 07 	ld.ub	r6,r11[7]
8000736e:	f3 66 00 07 	st.b	r9[7],r6
80007372:	f7 36 00 06 	ld.ub	r6,r11[6]
80007376:	f3 66 00 06 	st.b	r9[6],r6
8000737a:	f7 36 00 05 	ld.ub	r6,r11[5]
8000737e:	f3 66 00 05 	st.b	r9[5],r6
80007382:	f7 36 00 04 	ld.ub	r6,r11[4]
80007386:	f3 66 00 04 	st.b	r9[4],r6
8000738a:	f7 36 00 03 	ld.ub	r6,r11[3]
8000738e:	f3 66 00 03 	st.b	r9[3],r6
80007392:	f7 36 00 02 	ld.ub	r6,r11[2]
80007396:	f3 66 00 02 	st.b	r9[2],r6
8000739a:	f7 36 00 01 	ld.ub	r6,r11[1]
8000739e:	f3 66 00 01 	st.b	r9[1],r6
800073a2:	f7 36 00 00 	ld.ub	r6,r11[0]
800073a6:	f3 66 00 00 	st.b	r9[0],r6
800073aa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800073ae:	20 1a       	sub	r10,1
800073b0:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800073b4:	f8 0a 0b 09 	st.b	r12[r10],r9
800073b8:	cf b1       	brne	800073ae <memcpy+0x13a>
800073ba:	5e fc       	retal	r12

800073bc <memset>:
800073bc:	18 98       	mov	r8,r12
800073be:	c0 38       	rjmp	800073c4 <memset+0x8>
800073c0:	10 cb       	st.b	r8++,r11
800073c2:	20 1a       	sub	r10,1
800073c4:	58 0a       	cp.w	r10,0
800073c6:	cf d1       	brne	800073c0 <memset+0x4>
800073c8:	5e fc       	retal	r12
800073ca:	d7 03       	nop

800073cc <_realloc_r>:
800073cc:	d4 31       	pushm	r0-r7,lr
800073ce:	20 1d       	sub	sp,4
800073d0:	16 94       	mov	r4,r11
800073d2:	18 92       	mov	r2,r12
800073d4:	14 9b       	mov	r11,r10
800073d6:	58 04       	cp.w	r4,0
800073d8:	c0 51       	brne	800073e2 <_realloc_r+0x16>
800073da:	fe b0 fd 31 	rcall	80006e3c <_malloc_r>
800073de:	18 95       	mov	r5,r12
800073e0:	c5 39       	rjmp	80007686 <_realloc_r+0x2ba>
800073e2:	50 0a       	stdsp	sp[0x0],r10
800073e4:	fe b0 f3 2a 	rcall	80005a38 <__malloc_lock>
800073e8:	40 0b       	lddsp	r11,sp[0x0]
800073ea:	f6 c8 ff f5 	sub	r8,r11,-11
800073ee:	e8 c1 00 08 	sub	r1,r4,8
800073f2:	10 96       	mov	r6,r8
800073f4:	62 1c       	ld.w	r12,r1[0x4]
800073f6:	e0 16 ff f8 	andl	r6,0xfff8
800073fa:	59 68       	cp.w	r8,22
800073fc:	f9 b6 08 10 	movls	r6,16
80007400:	16 36       	cp.w	r6,r11
80007402:	5f 38       	srlo	r8
80007404:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80007408:	c0 50       	breq	80007412 <_realloc_r+0x46>
8000740a:	30 c8       	mov	r8,12
8000740c:	30 05       	mov	r5,0
8000740e:	85 38       	st.w	r2[0xc],r8
80007410:	c3 b9       	rjmp	80007686 <_realloc_r+0x2ba>
80007412:	18 90       	mov	r0,r12
80007414:	e0 10 ff fc 	andl	r0,0xfffc
80007418:	0c 30       	cp.w	r0,r6
8000741a:	e0 84 01 0b 	brge	80007630 <_realloc_r+0x264>
8000741e:	e0 68 05 40 	mov	r8,1344
80007422:	e2 00 00 09 	add	r9,r1,r0
80007426:	70 25       	ld.w	r5,r8[0x8]
80007428:	0a 39       	cp.w	r9,r5
8000742a:	c0 90       	breq	8000743c <_realloc_r+0x70>
8000742c:	72 1a       	ld.w	r10,r9[0x4]
8000742e:	a1 ca       	cbr	r10,0x0
80007430:	f2 0a 00 0a 	add	r10,r9,r10
80007434:	74 1a       	ld.w	r10,r10[0x4]
80007436:	ed ba 00 00 	bld	r10,0x0
8000743a:	c2 20       	breq	8000747e <_realloc_r+0xb2>
8000743c:	72 1a       	ld.w	r10,r9[0x4]
8000743e:	e0 1a ff fc 	andl	r10,0xfffc
80007442:	f4 00 00 03 	add	r3,r10,r0
80007446:	0a 39       	cp.w	r9,r5
80007448:	c1 31       	brne	8000746e <_realloc_r+0xa2>
8000744a:	ec c7 ff f0 	sub	r7,r6,-16
8000744e:	0e 33       	cp.w	r3,r7
80007450:	c1 95       	brlt	80007482 <_realloc_r+0xb6>
80007452:	e2 06 00 09 	add	r9,r1,r6
80007456:	0c 13       	sub	r3,r6
80007458:	a1 a3       	sbr	r3,0x0
8000745a:	93 13       	st.w	r9[0x4],r3
8000745c:	91 29       	st.w	r8[0x8],r9
8000745e:	04 9c       	mov	r12,r2
80007460:	62 18       	ld.w	r8,r1[0x4]
80007462:	08 95       	mov	r5,r4
80007464:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007468:	10 46       	or	r6,r8
8000746a:	83 16       	st.w	r1[0x4],r6
8000746c:	c0 b9       	rjmp	80007682 <_realloc_r+0x2b6>
8000746e:	0c 33       	cp.w	r3,r6
80007470:	c0 95       	brlt	80007482 <_realloc_r+0xb6>
80007472:	72 28       	ld.w	r8,r9[0x8]
80007474:	02 97       	mov	r7,r1
80007476:	72 39       	ld.w	r9,r9[0xc]
80007478:	93 28       	st.w	r9[0x8],r8
8000747a:	91 39       	st.w	r8[0xc],r9
8000747c:	cd c8       	rjmp	80007634 <_realloc_r+0x268>
8000747e:	30 0a       	mov	r10,0
80007480:	14 99       	mov	r9,r10
80007482:	ed bc 00 00 	bld	r12,0x0
80007486:	e0 80 00 95 	breq	800075b0 <_realloc_r+0x1e4>
8000748a:	62 07       	ld.w	r7,r1[0x0]
8000748c:	e2 07 01 07 	sub	r7,r1,r7
80007490:	6e 1c       	ld.w	r12,r7[0x4]
80007492:	e0 1c ff fc 	andl	r12,0xfffc
80007496:	58 09       	cp.w	r9,0
80007498:	c5 60       	breq	80007544 <_realloc_r+0x178>
8000749a:	f8 00 00 03 	add	r3,r12,r0
8000749e:	0a 39       	cp.w	r9,r5
800074a0:	c4 81       	brne	80007530 <_realloc_r+0x164>
800074a2:	14 03       	add	r3,r10
800074a4:	ec c9 ff f0 	sub	r9,r6,-16
800074a8:	12 33       	cp.w	r3,r9
800074aa:	c4 d5       	brlt	80007544 <_realloc_r+0x178>
800074ac:	6e 3a       	ld.w	r10,r7[0xc]
800074ae:	6e 29       	ld.w	r9,r7[0x8]
800074b0:	95 29       	st.w	r10[0x8],r9
800074b2:	93 3a       	st.w	r9[0xc],r10
800074b4:	ee c5 ff f8 	sub	r5,r7,-8
800074b8:	e0 ca 00 04 	sub	r10,r0,4
800074bc:	e0 4a 00 24 	cp.w	r10,36
800074c0:	e0 8b 00 25 	brhi	8000750a <_realloc_r+0x13e>
800074c4:	0a 99       	mov	r9,r5
800074c6:	59 3a       	cp.w	r10,19
800074c8:	e0 88 00 1a 	brls	800074fc <_realloc_r+0x130>
800074cc:	09 09       	ld.w	r9,r4++
800074ce:	8b 09       	st.w	r5[0x0],r9
800074d0:	09 09       	ld.w	r9,r4++
800074d2:	8f 39       	st.w	r7[0xc],r9
800074d4:	ee c9 ff f0 	sub	r9,r7,-16
800074d8:	59 ba       	cp.w	r10,27
800074da:	e0 88 00 11 	brls	800074fc <_realloc_r+0x130>
800074de:	09 0b       	ld.w	r11,r4++
800074e0:	93 0b       	st.w	r9[0x0],r11
800074e2:	09 09       	ld.w	r9,r4++
800074e4:	8f 59       	st.w	r7[0x14],r9
800074e6:	ee c9 ff e8 	sub	r9,r7,-24
800074ea:	e0 4a 00 24 	cp.w	r10,36
800074ee:	c0 71       	brne	800074fc <_realloc_r+0x130>
800074f0:	09 0a       	ld.w	r10,r4++
800074f2:	93 0a       	st.w	r9[0x0],r10
800074f4:	ee c9 ff e0 	sub	r9,r7,-32
800074f8:	09 0a       	ld.w	r10,r4++
800074fa:	8f 7a       	st.w	r7[0x1c],r10
800074fc:	09 0a       	ld.w	r10,r4++
800074fe:	12 aa       	st.w	r9++,r10
80007500:	68 0a       	ld.w	r10,r4[0x0]
80007502:	93 0a       	st.w	r9[0x0],r10
80007504:	68 1a       	ld.w	r10,r4[0x4]
80007506:	93 1a       	st.w	r9[0x4],r10
80007508:	c0 78       	rjmp	80007516 <_realloc_r+0x14a>
8000750a:	50 08       	stdsp	sp[0x0],r8
8000750c:	08 9b       	mov	r11,r4
8000750e:	0a 9c       	mov	r12,r5
80007510:	e0 a0 1d 8f 	rcall	8000b02e <memmove>
80007514:	40 08       	lddsp	r8,sp[0x0]
80007516:	ee 06 00 09 	add	r9,r7,r6
8000751a:	0c 13       	sub	r3,r6
8000751c:	a1 a3       	sbr	r3,0x0
8000751e:	93 13       	st.w	r9[0x4],r3
80007520:	91 29       	st.w	r8[0x8],r9
80007522:	04 9c       	mov	r12,r2
80007524:	6e 18       	ld.w	r8,r7[0x4]
80007526:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000752a:	10 46       	or	r6,r8
8000752c:	8f 16       	st.w	r7[0x4],r6
8000752e:	ca a8       	rjmp	80007682 <_realloc_r+0x2b6>
80007530:	14 03       	add	r3,r10
80007532:	0c 33       	cp.w	r3,r6
80007534:	c0 85       	brlt	80007544 <_realloc_r+0x178>
80007536:	72 28       	ld.w	r8,r9[0x8]
80007538:	72 39       	ld.w	r9,r9[0xc]
8000753a:	93 28       	st.w	r9[0x8],r8
8000753c:	91 39       	st.w	r8[0xc],r9
8000753e:	6e 28       	ld.w	r8,r7[0x8]
80007540:	6e 39       	ld.w	r9,r7[0xc]
80007542:	c0 78       	rjmp	80007550 <_realloc_r+0x184>
80007544:	f8 00 00 03 	add	r3,r12,r0
80007548:	0c 33       	cp.w	r3,r6
8000754a:	c3 35       	brlt	800075b0 <_realloc_r+0x1e4>
8000754c:	6e 39       	ld.w	r9,r7[0xc]
8000754e:	6e 28       	ld.w	r8,r7[0x8]
80007550:	93 28       	st.w	r9[0x8],r8
80007552:	91 39       	st.w	r8[0xc],r9
80007554:	e0 ca 00 04 	sub	r10,r0,4
80007558:	ee cc ff f8 	sub	r12,r7,-8
8000755c:	e0 4a 00 24 	cp.w	r10,36
80007560:	e0 8b 00 24 	brhi	800075a8 <_realloc_r+0x1dc>
80007564:	59 3a       	cp.w	r10,19
80007566:	e0 88 00 1a 	brls	8000759a <_realloc_r+0x1ce>
8000756a:	09 08       	ld.w	r8,r4++
8000756c:	99 08       	st.w	r12[0x0],r8
8000756e:	09 08       	ld.w	r8,r4++
80007570:	8f 38       	st.w	r7[0xc],r8
80007572:	ee cc ff f0 	sub	r12,r7,-16
80007576:	59 ba       	cp.w	r10,27
80007578:	e0 88 00 11 	brls	8000759a <_realloc_r+0x1ce>
8000757c:	09 08       	ld.w	r8,r4++
8000757e:	99 08       	st.w	r12[0x0],r8
80007580:	09 08       	ld.w	r8,r4++
80007582:	8f 58       	st.w	r7[0x14],r8
80007584:	ee cc ff e8 	sub	r12,r7,-24
80007588:	e0 4a 00 24 	cp.w	r10,36
8000758c:	c0 71       	brne	8000759a <_realloc_r+0x1ce>
8000758e:	09 08       	ld.w	r8,r4++
80007590:	99 08       	st.w	r12[0x0],r8
80007592:	ee cc ff e0 	sub	r12,r7,-32
80007596:	09 08       	ld.w	r8,r4++
80007598:	8f 78       	st.w	r7[0x1c],r8
8000759a:	09 08       	ld.w	r8,r4++
8000759c:	18 a8       	st.w	r12++,r8
8000759e:	68 08       	ld.w	r8,r4[0x0]
800075a0:	99 08       	st.w	r12[0x0],r8
800075a2:	68 18       	ld.w	r8,r4[0x4]
800075a4:	99 18       	st.w	r12[0x4],r8
800075a6:	c4 78       	rjmp	80007634 <_realloc_r+0x268>
800075a8:	08 9b       	mov	r11,r4
800075aa:	e0 a0 1d 42 	rcall	8000b02e <memmove>
800075ae:	c4 38       	rjmp	80007634 <_realloc_r+0x268>
800075b0:	04 9c       	mov	r12,r2
800075b2:	fe b0 fc 45 	rcall	80006e3c <_malloc_r>
800075b6:	18 95       	mov	r5,r12
800075b8:	c3 a0       	breq	8000762c <_realloc_r+0x260>
800075ba:	62 18       	ld.w	r8,r1[0x4]
800075bc:	f8 c9 00 08 	sub	r9,r12,8
800075c0:	a1 c8       	cbr	r8,0x0
800075c2:	e2 08 00 08 	add	r8,r1,r8
800075c6:	10 39       	cp.w	r9,r8
800075c8:	c0 71       	brne	800075d6 <_realloc_r+0x20a>
800075ca:	72 13       	ld.w	r3,r9[0x4]
800075cc:	02 97       	mov	r7,r1
800075ce:	e0 13 ff fc 	andl	r3,0xfffc
800075d2:	00 03       	add	r3,r0
800075d4:	c3 08       	rjmp	80007634 <_realloc_r+0x268>
800075d6:	e0 ca 00 04 	sub	r10,r0,4
800075da:	e0 4a 00 24 	cp.w	r10,36
800075de:	e0 8b 00 20 	brhi	8000761e <_realloc_r+0x252>
800075e2:	08 99       	mov	r9,r4
800075e4:	18 98       	mov	r8,r12
800075e6:	59 3a       	cp.w	r10,19
800075e8:	e0 88 00 14 	brls	80007610 <_realloc_r+0x244>
800075ec:	13 0b       	ld.w	r11,r9++
800075ee:	10 ab       	st.w	r8++,r11
800075f0:	13 0b       	ld.w	r11,r9++
800075f2:	10 ab       	st.w	r8++,r11
800075f4:	59 ba       	cp.w	r10,27
800075f6:	e0 88 00 0d 	brls	80007610 <_realloc_r+0x244>
800075fa:	13 0b       	ld.w	r11,r9++
800075fc:	10 ab       	st.w	r8++,r11
800075fe:	13 0b       	ld.w	r11,r9++
80007600:	10 ab       	st.w	r8++,r11
80007602:	e0 4a 00 24 	cp.w	r10,36
80007606:	c0 51       	brne	80007610 <_realloc_r+0x244>
80007608:	13 0a       	ld.w	r10,r9++
8000760a:	10 aa       	st.w	r8++,r10
8000760c:	13 0a       	ld.w	r10,r9++
8000760e:	10 aa       	st.w	r8++,r10
80007610:	13 0a       	ld.w	r10,r9++
80007612:	10 aa       	st.w	r8++,r10
80007614:	72 0a       	ld.w	r10,r9[0x0]
80007616:	91 0a       	st.w	r8[0x0],r10
80007618:	72 19       	ld.w	r9,r9[0x4]
8000761a:	91 19       	st.w	r8[0x4],r9
8000761c:	c0 48       	rjmp	80007624 <_realloc_r+0x258>
8000761e:	08 9b       	mov	r11,r4
80007620:	e0 a0 1d 07 	rcall	8000b02e <memmove>
80007624:	08 9b       	mov	r11,r4
80007626:	04 9c       	mov	r12,r2
80007628:	e0 a0 1a 60 	rcall	8000aae8 <_free_r>
8000762c:	04 9c       	mov	r12,r2
8000762e:	c2 a8       	rjmp	80007682 <_realloc_r+0x2b6>
80007630:	00 93       	mov	r3,r0
80007632:	02 97       	mov	r7,r1
80007634:	e6 06 01 09 	sub	r9,r3,r6
80007638:	6e 18       	ld.w	r8,r7[0x4]
8000763a:	58 f9       	cp.w	r9,15
8000763c:	e0 88 00 16 	brls	80007668 <_realloc_r+0x29c>
80007640:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007644:	ed e8 10 08 	or	r8,r6,r8
80007648:	8f 18       	st.w	r7[0x4],r8
8000764a:	12 98       	mov	r8,r9
8000764c:	a1 a8       	sbr	r8,0x0
8000764e:	ee 06 00 0b 	add	r11,r7,r6
80007652:	f6 09 00 09 	add	r9,r11,r9
80007656:	97 18       	st.w	r11[0x4],r8
80007658:	72 18       	ld.w	r8,r9[0x4]
8000765a:	a1 a8       	sbr	r8,0x0
8000765c:	2f 8b       	sub	r11,-8
8000765e:	93 18       	st.w	r9[0x4],r8
80007660:	04 9c       	mov	r12,r2
80007662:	e0 a0 1a 43 	rcall	8000aae8 <_free_r>
80007666:	c0 b8       	rjmp	8000767c <_realloc_r+0x2b0>
80007668:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000766c:	e7 e8 10 08 	or	r8,r3,r8
80007670:	8f 18       	st.w	r7[0x4],r8
80007672:	ee 03 00 03 	add	r3,r7,r3
80007676:	66 18       	ld.w	r8,r3[0x4]
80007678:	a1 a8       	sbr	r8,0x0
8000767a:	87 18       	st.w	r3[0x4],r8
8000767c:	04 9c       	mov	r12,r2
8000767e:	ee c5 ff f8 	sub	r5,r7,-8
80007682:	fe b0 f1 e1 	rcall	80005a44 <__malloc_unlock>
80007686:	0a 9c       	mov	r12,r5
80007688:	2f fd       	sub	sp,-4
8000768a:	d8 32       	popm	r0-r7,pc

8000768c <_sbrk_r>:
8000768c:	d4 21       	pushm	r4-r7,lr
8000768e:	30 08       	mov	r8,0
80007690:	18 97       	mov	r7,r12
80007692:	e0 66 51 1c 	mov	r6,20764
80007696:	16 9c       	mov	r12,r11
80007698:	8d 08       	st.w	r6[0x0],r8
8000769a:	c8 5c       	rcall	800077a4 <_sbrk>
8000769c:	5b fc       	cp.w	r12,-1
8000769e:	c0 51       	brne	800076a8 <_sbrk_r+0x1c>
800076a0:	6c 08       	ld.w	r8,r6[0x0]
800076a2:	58 08       	cp.w	r8,0
800076a4:	ef f8 1a 03 	st.wne	r7[0xc],r8
800076a8:	d8 22       	popm	r4-r7,pc
800076aa:	d7 03       	nop

800076ac <sprintf>:
800076ac:	d4 01       	pushm	lr
800076ae:	21 7d       	sub	sp,92
800076b0:	e0 68 ff ff 	mov	r8,65535
800076b4:	ea 18 7f ff 	orh	r8,0x7fff
800076b8:	50 58       	stdsp	sp[0x14],r8
800076ba:	50 28       	stdsp	sp[0x8],r8
800076bc:	e0 68 02 08 	mov	r8,520
800076c0:	ba 68       	st.h	sp[0xc],r8
800076c2:	3f f8       	mov	r8,-1
800076c4:	ba 78       	st.h	sp[0xe],r8
800076c6:	e0 68 0a 40 	mov	r8,2624
800076ca:	50 4c       	stdsp	sp[0x10],r12
800076cc:	16 9a       	mov	r10,r11
800076ce:	50 0c       	stdsp	sp[0x0],r12
800076d0:	fa c9 ff a0 	sub	r9,sp,-96
800076d4:	70 0c       	ld.w	r12,r8[0x0]
800076d6:	1a 9b       	mov	r11,sp
800076d8:	e0 a0 02 1a 	rcall	80007b0c <_vfprintf_r>
800076dc:	30 09       	mov	r9,0
800076de:	40 08       	lddsp	r8,sp[0x0]
800076e0:	b0 89       	st.b	r8[0x0],r9
800076e2:	2e 9d       	sub	sp,-92
800076e4:	d8 02       	popm	pc
800076e6:	d7 03       	nop

800076e8 <strncpy>:
800076e8:	30 08       	mov	r8,0
800076ea:	10 3a       	cp.w	r10,r8
800076ec:	5e 0c       	reteq	r12
800076ee:	f6 08 07 09 	ld.ub	r9,r11[r8]
800076f2:	f8 08 0b 09 	st.b	r12[r8],r9
800076f6:	2f f8       	sub	r8,-1
800076f8:	58 09       	cp.w	r9,0
800076fa:	cf 81       	brne	800076ea <strncpy+0x2>
800076fc:	10 3a       	cp.w	r10,r8
800076fe:	5e 0c       	reteq	r12
80007700:	f8 08 0b 09 	st.b	r12[r8],r9
80007704:	2f f8       	sub	r8,-1
80007706:	cf bb       	rjmp	800076fc <strncpy+0x14>

80007708 <_close>:
80007708:	30 28       	mov	r8,2
8000770a:	d6 73       	breakpoint
8000770c:	3f fc       	mov	r12,-1
8000770e:	35 8b       	mov	r11,88
80007710:	58 0c       	cp.w	r12,0
80007712:	5e 4c       	retge	r12
80007714:	e0 6a 51 1c 	mov	r10,20764
80007718:	95 0b       	st.w	r10[0x0],r11
8000771a:	5e fc       	retal	r12

8000771c <_lseek>:
8000771c:	30 58       	mov	r8,5
8000771e:	d6 73       	breakpoint
80007720:	3f fc       	mov	r12,-1
80007722:	35 8b       	mov	r11,88
80007724:	58 0c       	cp.w	r12,0
80007726:	5e 4c       	retge	r12
80007728:	e0 6a 51 1c 	mov	r10,20764
8000772c:	95 0b       	st.w	r10[0x0],r11
8000772e:	5e fc       	retal	r12

80007730 <isatty>:
80007730:	30 b8       	mov	r8,11
80007732:	d6 73       	breakpoint
80007734:	3f fc       	mov	r12,-1
80007736:	35 8b       	mov	r11,88
80007738:	58 0c       	cp.w	r12,0
8000773a:	5e 4c       	retge	r12
8000773c:	e0 6a 51 1c 	mov	r10,20764
80007740:	95 0b       	st.w	r10[0x0],r11
80007742:	5e fc       	retal	r12

80007744 <_fstat_host>:
80007744:	30 98       	mov	r8,9
80007746:	d6 73       	breakpoint
80007748:	3f fc       	mov	r12,-1
8000774a:	35 8b       	mov	r11,88
8000774c:	58 0c       	cp.w	r12,0
8000774e:	5e 4c       	retge	r12
80007750:	e0 6a 51 1c 	mov	r10,20764
80007754:	95 0b       	st.w	r10[0x0],r11
80007756:	5e fc       	retal	r12

80007758 <_fstat>:
80007758:	d4 21       	pushm	r4-r7,lr
8000775a:	21 0d       	sub	sp,64
8000775c:	16 97       	mov	r7,r11
8000775e:	1a 9b       	mov	r11,sp
80007760:	cf 2f       	rcall	80007744 <_fstat_host>
80007762:	c0 34       	brge	80007768 <_fstat+0x10>
80007764:	3f fc       	mov	r12,-1
80007766:	c1 c8       	rjmp	8000779e <_fstat+0x46>
80007768:	40 08       	lddsp	r8,sp[0x0]
8000776a:	ae 08       	st.h	r7[0x0],r8
8000776c:	40 18       	lddsp	r8,sp[0x4]
8000776e:	ae 18       	st.h	r7[0x2],r8
80007770:	40 28       	lddsp	r8,sp[0x8]
80007772:	8f 18       	st.w	r7[0x4],r8
80007774:	40 38       	lddsp	r8,sp[0xc]
80007776:	ae 48       	st.h	r7[0x8],r8
80007778:	40 48       	lddsp	r8,sp[0x10]
8000777a:	ae 58       	st.h	r7[0xa],r8
8000777c:	40 58       	lddsp	r8,sp[0x14]
8000777e:	ae 68       	st.h	r7[0xc],r8
80007780:	40 68       	lddsp	r8,sp[0x18]
80007782:	ae 78       	st.h	r7[0xe],r8
80007784:	40 88       	lddsp	r8,sp[0x20]
80007786:	8f 48       	st.w	r7[0x10],r8
80007788:	40 a8       	lddsp	r8,sp[0x28]
8000778a:	8f b8       	st.w	r7[0x2c],r8
8000778c:	40 c8       	lddsp	r8,sp[0x30]
8000778e:	8f c8       	st.w	r7[0x30],r8
80007790:	40 d8       	lddsp	r8,sp[0x34]
80007792:	8f 58       	st.w	r7[0x14],r8
80007794:	40 e8       	lddsp	r8,sp[0x38]
80007796:	30 0c       	mov	r12,0
80007798:	8f 78       	st.w	r7[0x1c],r8
8000779a:	40 f8       	lddsp	r8,sp[0x3c]
8000779c:	8f 98       	st.w	r7[0x24],r8
8000779e:	2f 0d       	sub	sp,-64
800077a0:	d8 22       	popm	r4-r7,pc
800077a2:	d7 03       	nop

800077a4 <_sbrk>:
800077a4:	d4 01       	pushm	lr
800077a6:	e0 68 0d 90 	mov	r8,3472
800077aa:	70 09       	ld.w	r9,r8[0x0]
800077ac:	58 09       	cp.w	r9,0
800077ae:	c0 41       	brne	800077b6 <_sbrk+0x12>
800077b0:	e0 69 51 20 	mov	r9,20768
800077b4:	91 09       	st.w	r8[0x0],r9
800077b6:	e0 69 0d 90 	mov	r9,3472
800077ba:	e0 7a 70 00 	mov	r10,94208
800077be:	72 08       	ld.w	r8,r9[0x0]
800077c0:	f0 0c 00 0c 	add	r12,r8,r12
800077c4:	14 3c       	cp.w	r12,r10
800077c6:	e0 8b 00 04 	brhi	800077ce <_sbrk+0x2a>
800077ca:	93 0c       	st.w	r9[0x0],r12
800077cc:	c0 68       	rjmp	800077d8 <_sbrk+0x34>
800077ce:	e0 a0 18 15 	rcall	8000a7f8 <__errno>
800077d2:	30 c8       	mov	r8,12
800077d4:	99 08       	st.w	r12[0x0],r8
800077d6:	3f f8       	mov	r8,-1
800077d8:	10 9c       	mov	r12,r8
800077da:	d8 02       	popm	pc

800077dc <get_arg>:
800077dc:	d4 31       	pushm	r0-r7,lr
800077de:	20 8d       	sub	sp,32
800077e0:	fa c4 ff bc 	sub	r4,sp,-68
800077e4:	50 4b       	stdsp	sp[0x10],r11
800077e6:	68 2e       	ld.w	lr,r4[0x8]
800077e8:	50 58       	stdsp	sp[0x14],r8
800077ea:	12 96       	mov	r6,r9
800077ec:	7c 0b       	ld.w	r11,lr[0x0]
800077ee:	70 05       	ld.w	r5,r8[0x0]
800077f0:	50 6e       	stdsp	sp[0x18],lr
800077f2:	58 0b       	cp.w	r11,0
800077f4:	f4 0b 17 00 	moveq	r11,r10
800077f8:	68 03       	ld.w	r3,r4[0x0]
800077fa:	68 11       	ld.w	r1,r4[0x4]
800077fc:	40 49       	lddsp	r9,sp[0x10]
800077fe:	30 08       	mov	r8,0
80007800:	c2 89       	rjmp	80007a50 <get_arg+0x274>
80007802:	2f fb       	sub	r11,-1
80007804:	32 5c       	mov	r12,37
80007806:	17 8a       	ld.ub	r10,r11[0x0]
80007808:	f8 0a 18 00 	cp.b	r10,r12
8000780c:	5f 1e       	srne	lr
8000780e:	f0 0a 18 00 	cp.b	r10,r8
80007812:	5f 1c       	srne	r12
80007814:	fd ec 00 0c 	and	r12,lr,r12
80007818:	f0 0c 18 00 	cp.b	r12,r8
8000781c:	cf 31       	brne	80007802 <get_arg+0x26>
8000781e:	58 0a       	cp.w	r10,0
80007820:	e0 80 01 25 	breq	80007a6a <get_arg+0x28e>
80007824:	30 0c       	mov	r12,0
80007826:	3f fa       	mov	r10,-1
80007828:	18 90       	mov	r0,r12
8000782a:	50 3a       	stdsp	sp[0xc],r10
8000782c:	18 94       	mov	r4,r12
8000782e:	18 92       	mov	r2,r12
80007830:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007834:	16 97       	mov	r7,r11
80007836:	50 7c       	stdsp	sp[0x1c],r12
80007838:	fe cc 9f 88 	sub	r12,pc,-24696
8000783c:	0f 3a       	ld.ub	r10,r7++
8000783e:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007842:	40 7c       	lddsp	r12,sp[0x1c]
80007844:	1c 0c       	add	r12,lr
80007846:	fe ce a0 5e 	sub	lr,pc,-24482
8000784a:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
8000784e:	20 1e       	sub	lr,1
80007850:	50 0e       	stdsp	sp[0x0],lr
80007852:	fe ce a0 d6 	sub	lr,pc,-24362
80007856:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8000785a:	50 7c       	stdsp	sp[0x1c],r12
8000785c:	40 0c       	lddsp	r12,sp[0x0]
8000785e:	58 7c       	cp.w	r12,7
80007860:	e0 8b 00 f1 	brhi	80007a42 <get_arg+0x266>
80007864:	fe ce a2 88 	sub	lr,pc,-23928
80007868:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
8000786c:	36 8b       	mov	r11,104
8000786e:	f6 0a 18 00 	cp.b	r10,r11
80007872:	e0 80 00 e8 	breq	80007a42 <get_arg+0x266>
80007876:	37 1b       	mov	r11,113
80007878:	f6 0a 18 00 	cp.b	r10,r11
8000787c:	c0 70       	breq	8000788a <get_arg+0xae>
8000787e:	34 cb       	mov	r11,76
80007880:	f6 0a 18 00 	cp.b	r10,r11
80007884:	c0 51       	brne	8000788e <get_arg+0xb2>
80007886:	a3 b4       	sbr	r4,0x3
80007888:	cd d8       	rjmp	80007a42 <get_arg+0x266>
8000788a:	a5 b4       	sbr	r4,0x5
8000788c:	cd b8       	rjmp	80007a42 <get_arg+0x266>
8000788e:	08 9a       	mov	r10,r4
80007890:	0e 9b       	mov	r11,r7
80007892:	a5 aa       	sbr	r10,0x4
80007894:	17 3c       	ld.ub	r12,r11++
80007896:	a5 b4       	sbr	r4,0x5
80007898:	36 ce       	mov	lr,108
8000789a:	fc 0c 18 00 	cp.b	r12,lr
8000789e:	e0 80 00 d3 	breq	80007a44 <get_arg+0x268>
800078a2:	14 94       	mov	r4,r10
800078a4:	cc f8       	rjmp	80007a42 <get_arg+0x266>
800078a6:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
800078aa:	36 7c       	mov	r12,103
800078ac:	f8 0a 18 00 	cp.b	r10,r12
800078b0:	e0 8b 00 27 	brhi	800078fe <get_arg+0x122>
800078b4:	36 5b       	mov	r11,101
800078b6:	f6 0a 18 00 	cp.b	r10,r11
800078ba:	c4 82       	brcc	8000794a <get_arg+0x16e>
800078bc:	34 fb       	mov	r11,79
800078be:	f6 0a 18 00 	cp.b	r10,r11
800078c2:	c4 80       	breq	80007952 <get_arg+0x176>
800078c4:	e0 8b 00 0c 	brhi	800078dc <get_arg+0x100>
800078c8:	34 5b       	mov	r11,69
800078ca:	f6 0a 18 00 	cp.b	r10,r11
800078ce:	c3 e0       	breq	8000794a <get_arg+0x16e>
800078d0:	34 7b       	mov	r11,71
800078d2:	f6 0a 18 00 	cp.b	r10,r11
800078d6:	c3 a0       	breq	8000794a <get_arg+0x16e>
800078d8:	34 4b       	mov	r11,68
800078da:	c0 88       	rjmp	800078ea <get_arg+0x10e>
800078dc:	35 8b       	mov	r11,88
800078de:	f6 0a 18 00 	cp.b	r10,r11
800078e2:	c2 c0       	breq	8000793a <get_arg+0x15e>
800078e4:	e0 8b 00 07 	brhi	800078f2 <get_arg+0x116>
800078e8:	35 5b       	mov	r11,85
800078ea:	f6 0a 18 00 	cp.b	r10,r11
800078ee:	c3 51       	brne	80007958 <get_arg+0x17c>
800078f0:	c3 18       	rjmp	80007952 <get_arg+0x176>
800078f2:	36 3b       	mov	r11,99
800078f4:	f6 0a 18 00 	cp.b	r10,r11
800078f8:	c2 f0       	breq	80007956 <get_arg+0x17a>
800078fa:	36 4b       	mov	r11,100
800078fc:	c0 e8       	rjmp	80007918 <get_arg+0x13c>
800078fe:	37 0b       	mov	r11,112
80007900:	f6 0a 18 00 	cp.b	r10,r11
80007904:	c2 50       	breq	8000794e <get_arg+0x172>
80007906:	e0 8b 00 0d 	brhi	80007920 <get_arg+0x144>
8000790a:	36 eb       	mov	r11,110
8000790c:	f6 0a 18 00 	cp.b	r10,r11
80007910:	c1 f0       	breq	8000794e <get_arg+0x172>
80007912:	e0 8b 00 14 	brhi	8000793a <get_arg+0x15e>
80007916:	36 9b       	mov	r11,105
80007918:	f6 0a 18 00 	cp.b	r10,r11
8000791c:	c1 e1       	brne	80007958 <get_arg+0x17c>
8000791e:	c0 e8       	rjmp	8000793a <get_arg+0x15e>
80007920:	37 5b       	mov	r11,117
80007922:	f6 0a 18 00 	cp.b	r10,r11
80007926:	c0 a0       	breq	8000793a <get_arg+0x15e>
80007928:	37 8b       	mov	r11,120
8000792a:	f6 0a 18 00 	cp.b	r10,r11
8000792e:	c0 60       	breq	8000793a <get_arg+0x15e>
80007930:	37 3b       	mov	r11,115
80007932:	f6 0a 18 00 	cp.b	r10,r11
80007936:	c1 11       	brne	80007958 <get_arg+0x17c>
80007938:	c0 b8       	rjmp	8000794e <get_arg+0x172>
8000793a:	ed b4 00 04 	bld	r4,0x4
8000793e:	c0 a0       	breq	80007952 <get_arg+0x176>
80007940:	ed b4 00 05 	bld	r4,0x5
80007944:	c0 91       	brne	80007956 <get_arg+0x17a>
80007946:	30 20       	mov	r0,2
80007948:	c0 88       	rjmp	80007958 <get_arg+0x17c>
8000794a:	30 40       	mov	r0,4
8000794c:	c0 68       	rjmp	80007958 <get_arg+0x17c>
8000794e:	30 30       	mov	r0,3
80007950:	c0 48       	rjmp	80007958 <get_arg+0x17c>
80007952:	30 10       	mov	r0,1
80007954:	c0 28       	rjmp	80007958 <get_arg+0x17c>
80007956:	30 00       	mov	r0,0
80007958:	40 3b       	lddsp	r11,sp[0xc]
8000795a:	5b fb       	cp.w	r11,-1
8000795c:	c0 40       	breq	80007964 <get_arg+0x188>
8000795e:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007962:	c7 08       	rjmp	80007a42 <get_arg+0x266>
80007964:	58 60       	cp.w	r0,6
80007966:	e0 8b 00 6e 	brhi	80007a42 <get_arg+0x266>
8000796a:	6c 0a       	ld.w	r10,r6[0x0]
8000796c:	ea cc ff ff 	sub	r12,r5,-1
80007970:	fe ce a3 74 	sub	lr,pc,-23692
80007974:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007978:	f4 cb ff f8 	sub	r11,r10,-8
8000797c:	8d 0b       	st.w	r6[0x0],r11
8000797e:	f4 ea 00 00 	ld.d	r10,r10[0]
80007982:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007986:	c0 f8       	rjmp	800079a4 <get_arg+0x1c8>
80007988:	f4 cb ff fc 	sub	r11,r10,-4
8000798c:	8d 0b       	st.w	r6[0x0],r11
8000798e:	74 0a       	ld.w	r10,r10[0x0]
80007990:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007994:	c0 88       	rjmp	800079a4 <get_arg+0x1c8>
80007996:	f4 cb ff f8 	sub	r11,r10,-8
8000799a:	8d 0b       	st.w	r6[0x0],r11
8000799c:	f4 ea 00 00 	ld.d	r10,r10[0]
800079a0:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
800079a4:	0e 9b       	mov	r11,r7
800079a6:	18 95       	mov	r5,r12
800079a8:	c4 e8       	rjmp	80007a44 <get_arg+0x268>
800079aa:	62 0a       	ld.w	r10,r1[0x0]
800079ac:	5b fa       	cp.w	r10,-1
800079ae:	c0 b1       	brne	800079c4 <get_arg+0x1e8>
800079b0:	50 19       	stdsp	sp[0x4],r9
800079b2:	50 28       	stdsp	sp[0x8],r8
800079b4:	e0 6a 00 80 	mov	r10,128
800079b8:	30 0b       	mov	r11,0
800079ba:	02 9c       	mov	r12,r1
800079bc:	fe b0 fd 00 	rcall	800073bc <memset>
800079c0:	40 28       	lddsp	r8,sp[0x8]
800079c2:	40 19       	lddsp	r9,sp[0x4]
800079c4:	e4 cc 00 01 	sub	r12,r2,1
800079c8:	0e 9b       	mov	r11,r7
800079ca:	50 3c       	stdsp	sp[0xc],r12
800079cc:	f2 0c 0c 49 	max	r9,r9,r12
800079d0:	c3 a8       	rjmp	80007a44 <get_arg+0x268>
800079d2:	62 0a       	ld.w	r10,r1[0x0]
800079d4:	5b fa       	cp.w	r10,-1
800079d6:	c0 b1       	brne	800079ec <get_arg+0x210>
800079d8:	50 19       	stdsp	sp[0x4],r9
800079da:	50 28       	stdsp	sp[0x8],r8
800079dc:	e0 6a 00 80 	mov	r10,128
800079e0:	30 0b       	mov	r11,0
800079e2:	02 9c       	mov	r12,r1
800079e4:	fe b0 fc ec 	rcall	800073bc <memset>
800079e8:	40 28       	lddsp	r8,sp[0x8]
800079ea:	40 19       	lddsp	r9,sp[0x4]
800079ec:	20 12       	sub	r2,1
800079ee:	30 0a       	mov	r10,0
800079f0:	0e 9b       	mov	r11,r7
800079f2:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
800079f6:	f2 02 0c 49 	max	r9,r9,r2
800079fa:	c2 58       	rjmp	80007a44 <get_arg+0x268>
800079fc:	16 97       	mov	r7,r11
800079fe:	6c 0a       	ld.w	r10,r6[0x0]
80007a00:	f4 cb ff fc 	sub	r11,r10,-4
80007a04:	8d 0b       	st.w	r6[0x0],r11
80007a06:	74 0a       	ld.w	r10,r10[0x0]
80007a08:	0e 9b       	mov	r11,r7
80007a0a:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007a0e:	2f f5       	sub	r5,-1
80007a10:	c1 a8       	rjmp	80007a44 <get_arg+0x268>
80007a12:	f4 c2 00 30 	sub	r2,r10,48
80007a16:	c0 68       	rjmp	80007a22 <get_arg+0x246>
80007a18:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007a1c:	2f f7       	sub	r7,-1
80007a1e:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007a22:	0f 8a       	ld.ub	r10,r7[0x0]
80007a24:	58 0a       	cp.w	r10,0
80007a26:	c0 e0       	breq	80007a42 <get_arg+0x266>
80007a28:	23 0a       	sub	r10,48
80007a2a:	58 9a       	cp.w	r10,9
80007a2c:	fe 98 ff f6 	brls	80007a18 <get_arg+0x23c>
80007a30:	c0 98       	rjmp	80007a42 <get_arg+0x266>
80007a32:	2f f7       	sub	r7,-1
80007a34:	0f 8a       	ld.ub	r10,r7[0x0]
80007a36:	58 0a       	cp.w	r10,0
80007a38:	c0 50       	breq	80007a42 <get_arg+0x266>
80007a3a:	23 0a       	sub	r10,48
80007a3c:	58 9a       	cp.w	r10,9
80007a3e:	fe 98 ff fa 	brls	80007a32 <get_arg+0x256>
80007a42:	0e 9b       	mov	r11,r7
80007a44:	40 7c       	lddsp	r12,sp[0x1c]
80007a46:	30 ba       	mov	r10,11
80007a48:	f4 0c 18 00 	cp.b	r12,r10
80007a4c:	fe 91 fe f2 	brne	80007830 <get_arg+0x54>
80007a50:	40 42       	lddsp	r2,sp[0x10]
80007a52:	17 8c       	ld.ub	r12,r11[0x0]
80007a54:	0a 32       	cp.w	r2,r5
80007a56:	5f 4a       	srge	r10
80007a58:	f0 0c 18 00 	cp.b	r12,r8
80007a5c:	5f 1c       	srne	r12
80007a5e:	f9 ea 00 0a 	and	r10,r12,r10
80007a62:	f0 0a 18 00 	cp.b	r10,r8
80007a66:	fe 91 fe cf 	brne	80007804 <get_arg+0x28>
80007a6a:	30 08       	mov	r8,0
80007a6c:	40 4e       	lddsp	lr,sp[0x10]
80007a6e:	17 8a       	ld.ub	r10,r11[0x0]
80007a70:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007a74:	f0 0a 18 00 	cp.b	r10,r8
80007a78:	fc 09 17 10 	movne	r9,lr
80007a7c:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007a80:	06 9e       	mov	lr,r3
80007a82:	c2 a8       	rjmp	80007ad6 <get_arg+0x2fa>
80007a84:	62 0a       	ld.w	r10,r1[0x0]
80007a86:	58 3a       	cp.w	r10,3
80007a88:	c1 e0       	breq	80007ac4 <get_arg+0x2e8>
80007a8a:	e0 89 00 07 	brgt	80007a98 <get_arg+0x2bc>
80007a8e:	58 1a       	cp.w	r10,1
80007a90:	c1 a0       	breq	80007ac4 <get_arg+0x2e8>
80007a92:	58 2a       	cp.w	r10,2
80007a94:	c1 81       	brne	80007ac4 <get_arg+0x2e8>
80007a96:	c0 58       	rjmp	80007aa0 <get_arg+0x2c4>
80007a98:	58 5a       	cp.w	r10,5
80007a9a:	c0 c0       	breq	80007ab2 <get_arg+0x2d6>
80007a9c:	c0 b5       	brlt	80007ab2 <get_arg+0x2d6>
80007a9e:	c1 38       	rjmp	80007ac4 <get_arg+0x2e8>
80007aa0:	6c 0a       	ld.w	r10,r6[0x0]
80007aa2:	f4 cc ff f8 	sub	r12,r10,-8
80007aa6:	8d 0c       	st.w	r6[0x0],r12
80007aa8:	f4 e2 00 00 	ld.d	r2,r10[0]
80007aac:	f0 e3 00 00 	st.d	r8[0],r2
80007ab0:	c1 08       	rjmp	80007ad0 <get_arg+0x2f4>
80007ab2:	6c 0a       	ld.w	r10,r6[0x0]
80007ab4:	f4 cc ff f8 	sub	r12,r10,-8
80007ab8:	8d 0c       	st.w	r6[0x0],r12
80007aba:	f4 e2 00 00 	ld.d	r2,r10[0]
80007abe:	f0 e3 00 00 	st.d	r8[0],r2
80007ac2:	c0 78       	rjmp	80007ad0 <get_arg+0x2f4>
80007ac4:	6c 0a       	ld.w	r10,r6[0x0]
80007ac6:	f4 cc ff fc 	sub	r12,r10,-4
80007aca:	8d 0c       	st.w	r6[0x0],r12
80007acc:	74 0a       	ld.w	r10,r10[0x0]
80007ace:	91 0a       	st.w	r8[0x0],r10
80007ad0:	2f f5       	sub	r5,-1
80007ad2:	2f 88       	sub	r8,-8
80007ad4:	2f c1       	sub	r1,-4
80007ad6:	12 35       	cp.w	r5,r9
80007ad8:	fe 9a ff d6 	brle	80007a84 <get_arg+0x2a8>
80007adc:	1c 93       	mov	r3,lr
80007ade:	40 52       	lddsp	r2,sp[0x14]
80007ae0:	40 6e       	lddsp	lr,sp[0x18]
80007ae2:	85 05       	st.w	r2[0x0],r5
80007ae4:	9d 0b       	st.w	lr[0x0],r11
80007ae6:	40 4b       	lddsp	r11,sp[0x10]
80007ae8:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007aec:	2f 8d       	sub	sp,-32
80007aee:	d8 32       	popm	r0-r7,pc

80007af0 <__sprint_r>:
80007af0:	d4 21       	pushm	r4-r7,lr
80007af2:	14 97       	mov	r7,r10
80007af4:	74 28       	ld.w	r8,r10[0x8]
80007af6:	58 08       	cp.w	r8,0
80007af8:	c0 41       	brne	80007b00 <__sprint_r+0x10>
80007afa:	95 18       	st.w	r10[0x4],r8
80007afc:	10 9c       	mov	r12,r8
80007afe:	d8 22       	popm	r4-r7,pc
80007b00:	e0 a0 18 ba 	rcall	8000ac74 <__sfvwrite_r>
80007b04:	30 08       	mov	r8,0
80007b06:	8f 18       	st.w	r7[0x4],r8
80007b08:	8f 28       	st.w	r7[0x8],r8
80007b0a:	d8 22       	popm	r4-r7,pc

80007b0c <_vfprintf_r>:
80007b0c:	d4 31       	pushm	r0-r7,lr
80007b0e:	fa cd 06 bc 	sub	sp,sp,1724
80007b12:	51 09       	stdsp	sp[0x40],r9
80007b14:	16 91       	mov	r1,r11
80007b16:	14 97       	mov	r7,r10
80007b18:	18 95       	mov	r5,r12
80007b1a:	e0 a0 1a 1d 	rcall	8000af54 <_localeconv_r>
80007b1e:	78 0c       	ld.w	r12,r12[0x0]
80007b20:	50 cc       	stdsp	sp[0x30],r12
80007b22:	58 05       	cp.w	r5,0
80007b24:	c0 70       	breq	80007b32 <_vfprintf_r+0x26>
80007b26:	6a 68       	ld.w	r8,r5[0x18]
80007b28:	58 08       	cp.w	r8,0
80007b2a:	c0 41       	brne	80007b32 <_vfprintf_r+0x26>
80007b2c:	0a 9c       	mov	r12,r5
80007b2e:	e0 a0 17 43 	rcall	8000a9b4 <__sinit>
80007b32:	fe c8 a1 72 	sub	r8,pc,-24206
80007b36:	10 31       	cp.w	r1,r8
80007b38:	c0 31       	brne	80007b3e <_vfprintf_r+0x32>
80007b3a:	6a 01       	ld.w	r1,r5[0x0]
80007b3c:	c0 c8       	rjmp	80007b54 <_vfprintf_r+0x48>
80007b3e:	fe c8 a1 5e 	sub	r8,pc,-24226
80007b42:	10 31       	cp.w	r1,r8
80007b44:	c0 31       	brne	80007b4a <_vfprintf_r+0x3e>
80007b46:	6a 11       	ld.w	r1,r5[0x4]
80007b48:	c0 68       	rjmp	80007b54 <_vfprintf_r+0x48>
80007b4a:	fe c8 a1 4a 	sub	r8,pc,-24246
80007b4e:	10 31       	cp.w	r1,r8
80007b50:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007b54:	82 68       	ld.sh	r8,r1[0xc]
80007b56:	ed b8 00 03 	bld	r8,0x3
80007b5a:	c0 41       	brne	80007b62 <_vfprintf_r+0x56>
80007b5c:	62 48       	ld.w	r8,r1[0x10]
80007b5e:	58 08       	cp.w	r8,0
80007b60:	c0 71       	brne	80007b6e <_vfprintf_r+0x62>
80007b62:	02 9b       	mov	r11,r1
80007b64:	0a 9c       	mov	r12,r5
80007b66:	e0 a0 0f 5d 	rcall	80009a20 <__swsetup_r>
80007b6a:	e0 81 0f 54 	brne	80009a12 <_vfprintf_r+0x1f06>
80007b6e:	82 68       	ld.sh	r8,r1[0xc]
80007b70:	10 99       	mov	r9,r8
80007b72:	e2 19 00 1a 	andl	r9,0x1a,COH
80007b76:	58 a9       	cp.w	r9,10
80007b78:	c3 c1       	brne	80007bf0 <_vfprintf_r+0xe4>
80007b7a:	82 79       	ld.sh	r9,r1[0xe]
80007b7c:	30 0a       	mov	r10,0
80007b7e:	f4 09 19 00 	cp.h	r9,r10
80007b82:	c3 75       	brlt	80007bf0 <_vfprintf_r+0xe4>
80007b84:	a1 d8       	cbr	r8,0x1
80007b86:	fb 58 05 d0 	st.h	sp[1488],r8
80007b8a:	62 88       	ld.w	r8,r1[0x20]
80007b8c:	fb 48 05 e4 	st.w	sp[1508],r8
80007b90:	62 a8       	ld.w	r8,r1[0x28]
80007b92:	fb 48 05 ec 	st.w	sp[1516],r8
80007b96:	fa c8 ff bc 	sub	r8,sp,-68
80007b9a:	fb 48 05 d4 	st.w	sp[1492],r8
80007b9e:	fb 48 05 c4 	st.w	sp[1476],r8
80007ba2:	e0 68 04 00 	mov	r8,1024
80007ba6:	fb 48 05 d8 	st.w	sp[1496],r8
80007baa:	fb 48 05 cc 	st.w	sp[1484],r8
80007bae:	30 08       	mov	r8,0
80007bb0:	fb 59 05 d2 	st.h	sp[1490],r9
80007bb4:	0e 9a       	mov	r10,r7
80007bb6:	41 09       	lddsp	r9,sp[0x40]
80007bb8:	fa c7 fa 3c 	sub	r7,sp,-1476
80007bbc:	fb 48 05 dc 	st.w	sp[1500],r8
80007bc0:	0a 9c       	mov	r12,r5
80007bc2:	0e 9b       	mov	r11,r7
80007bc4:	ca 4f       	rcall	80007b0c <_vfprintf_r>
80007bc6:	50 bc       	stdsp	sp[0x2c],r12
80007bc8:	c0 95       	brlt	80007bda <_vfprintf_r+0xce>
80007bca:	0e 9b       	mov	r11,r7
80007bcc:	0a 9c       	mov	r12,r5
80007bce:	e0 a0 16 1b 	rcall	8000a804 <_fflush_r>
80007bd2:	40 be       	lddsp	lr,sp[0x2c]
80007bd4:	f9 be 01 ff 	movne	lr,-1
80007bd8:	50 be       	stdsp	sp[0x2c],lr
80007bda:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007bde:	ed b8 00 06 	bld	r8,0x6
80007be2:	e0 81 0f 1a 	brne	80009a16 <_vfprintf_r+0x1f0a>
80007be6:	82 68       	ld.sh	r8,r1[0xc]
80007be8:	a7 a8       	sbr	r8,0x6
80007bea:	a2 68       	st.h	r1[0xc],r8
80007bec:	e0 8f 0f 15 	bral	80009a16 <_vfprintf_r+0x1f0a>
80007bf0:	30 08       	mov	r8,0
80007bf2:	fb 48 06 b4 	st.w	sp[1716],r8
80007bf6:	fb 48 06 90 	st.w	sp[1680],r8
80007bfa:	fb 48 06 8c 	st.w	sp[1676],r8
80007bfe:	fb 48 06 b0 	st.w	sp[1712],r8
80007c02:	30 08       	mov	r8,0
80007c04:	30 09       	mov	r9,0
80007c06:	50 a7       	stdsp	sp[0x28],r7
80007c08:	50 78       	stdsp	sp[0x1c],r8
80007c0a:	fa c3 f9 e0 	sub	r3,sp,-1568
80007c0e:	3f f8       	mov	r8,-1
80007c10:	50 59       	stdsp	sp[0x14],r9
80007c12:	fb 43 06 88 	st.w	sp[1672],r3
80007c16:	fb 48 05 44 	st.w	sp[1348],r8
80007c1a:	12 9c       	mov	r12,r9
80007c1c:	50 69       	stdsp	sp[0x18],r9
80007c1e:	50 d9       	stdsp	sp[0x34],r9
80007c20:	50 e9       	stdsp	sp[0x38],r9
80007c22:	50 b9       	stdsp	sp[0x2c],r9
80007c24:	12 97       	mov	r7,r9
80007c26:	0a 94       	mov	r4,r5
80007c28:	40 a2       	lddsp	r2,sp[0x28]
80007c2a:	32 5a       	mov	r10,37
80007c2c:	30 08       	mov	r8,0
80007c2e:	c0 28       	rjmp	80007c32 <_vfprintf_r+0x126>
80007c30:	2f f2       	sub	r2,-1
80007c32:	05 89       	ld.ub	r9,r2[0x0]
80007c34:	f0 09 18 00 	cp.b	r9,r8
80007c38:	5f 1b       	srne	r11
80007c3a:	f4 09 18 00 	cp.b	r9,r10
80007c3e:	5f 19       	srne	r9
80007c40:	f3 eb 00 0b 	and	r11,r9,r11
80007c44:	f0 0b 18 00 	cp.b	r11,r8
80007c48:	cf 41       	brne	80007c30 <_vfprintf_r+0x124>
80007c4a:	40 ab       	lddsp	r11,sp[0x28]
80007c4c:	e4 0b 01 06 	sub	r6,r2,r11
80007c50:	c1 e0       	breq	80007c8c <_vfprintf_r+0x180>
80007c52:	fa f8 06 90 	ld.w	r8,sp[1680]
80007c56:	0c 08       	add	r8,r6
80007c58:	87 0b       	st.w	r3[0x0],r11
80007c5a:	fb 48 06 90 	st.w	sp[1680],r8
80007c5e:	87 16       	st.w	r3[0x4],r6
80007c60:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007c64:	2f f8       	sub	r8,-1
80007c66:	fb 48 06 8c 	st.w	sp[1676],r8
80007c6a:	58 78       	cp.w	r8,7
80007c6c:	e0 89 00 04 	brgt	80007c74 <_vfprintf_r+0x168>
80007c70:	2f 83       	sub	r3,-8
80007c72:	c0 a8       	rjmp	80007c86 <_vfprintf_r+0x17a>
80007c74:	fa ca f9 78 	sub	r10,sp,-1672
80007c78:	02 9b       	mov	r11,r1
80007c7a:	08 9c       	mov	r12,r4
80007c7c:	c3 af       	rcall	80007af0 <__sprint_r>
80007c7e:	e0 81 0e c6 	brne	80009a0a <_vfprintf_r+0x1efe>
80007c82:	fa c3 f9 e0 	sub	r3,sp,-1568
80007c86:	40 ba       	lddsp	r10,sp[0x2c]
80007c88:	0c 0a       	add	r10,r6
80007c8a:	50 ba       	stdsp	sp[0x2c],r10
80007c8c:	05 89       	ld.ub	r9,r2[0x0]
80007c8e:	30 08       	mov	r8,0
80007c90:	f0 09 18 00 	cp.b	r9,r8
80007c94:	e0 80 0e aa 	breq	800099e8 <_vfprintf_r+0x1edc>
80007c98:	30 09       	mov	r9,0
80007c9a:	fb 68 06 bb 	st.b	sp[1723],r8
80007c9e:	0e 96       	mov	r6,r7
80007ca0:	e4 c8 ff ff 	sub	r8,r2,-1
80007ca4:	3f fe       	mov	lr,-1
80007ca6:	50 93       	stdsp	sp[0x24],r3
80007ca8:	50 41       	stdsp	sp[0x10],r1
80007caa:	0e 93       	mov	r3,r7
80007cac:	04 91       	mov	r1,r2
80007cae:	50 89       	stdsp	sp[0x20],r9
80007cb0:	50 a8       	stdsp	sp[0x28],r8
80007cb2:	50 2e       	stdsp	sp[0x8],lr
80007cb4:	50 39       	stdsp	sp[0xc],r9
80007cb6:	12 95       	mov	r5,r9
80007cb8:	12 90       	mov	r0,r9
80007cba:	10 97       	mov	r7,r8
80007cbc:	08 92       	mov	r2,r4
80007cbe:	c0 78       	rjmp	80007ccc <_vfprintf_r+0x1c0>
80007cc0:	3f fc       	mov	r12,-1
80007cc2:	08 97       	mov	r7,r4
80007cc4:	50 2c       	stdsp	sp[0x8],r12
80007cc6:	c0 38       	rjmp	80007ccc <_vfprintf_r+0x1c0>
80007cc8:	30 0b       	mov	r11,0
80007cca:	50 3b       	stdsp	sp[0xc],r11
80007ccc:	0f 38       	ld.ub	r8,r7++
80007cce:	c0 28       	rjmp	80007cd2 <_vfprintf_r+0x1c6>
80007cd0:	12 90       	mov	r0,r9
80007cd2:	f0 c9 00 20 	sub	r9,r8,32
80007cd6:	e0 49 00 58 	cp.w	r9,88
80007cda:	e0 8b 0a 30 	brhi	8000913a <_vfprintf_r+0x162e>
80007cde:	fe ca a6 c6 	sub	r10,pc,-22842
80007ce2:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80007ce6:	50 a7       	stdsp	sp[0x28],r7
80007ce8:	50 80       	stdsp	sp[0x20],r0
80007cea:	0c 97       	mov	r7,r6
80007cec:	04 94       	mov	r4,r2
80007cee:	06 96       	mov	r6,r3
80007cf0:	02 92       	mov	r2,r1
80007cf2:	fe c9 a4 9e 	sub	r9,pc,-23394
80007cf6:	40 93       	lddsp	r3,sp[0x24]
80007cf8:	10 90       	mov	r0,r8
80007cfa:	40 41       	lddsp	r1,sp[0x10]
80007cfc:	50 d9       	stdsp	sp[0x34],r9
80007cfe:	e0 8f 08 8e 	bral	80008e1a <_vfprintf_r+0x130e>
80007d02:	30 08       	mov	r8,0
80007d04:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80007d08:	f0 09 18 00 	cp.b	r9,r8
80007d0c:	ce 01       	brne	80007ccc <_vfprintf_r+0x1c0>
80007d0e:	32 08       	mov	r8,32
80007d10:	c6 e8       	rjmp	80007dec <_vfprintf_r+0x2e0>
80007d12:	a1 a5       	sbr	r5,0x0
80007d14:	cd cb       	rjmp	80007ccc <_vfprintf_r+0x1c0>
80007d16:	0f 89       	ld.ub	r9,r7[0x0]
80007d18:	f2 c8 00 30 	sub	r8,r9,48
80007d1c:	58 98       	cp.w	r8,9
80007d1e:	e0 8b 00 1d 	brhi	80007d58 <_vfprintf_r+0x24c>
80007d22:	ee c8 ff ff 	sub	r8,r7,-1
80007d26:	30 0b       	mov	r11,0
80007d28:	23 09       	sub	r9,48
80007d2a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007d2e:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80007d32:	11 39       	ld.ub	r9,r8++
80007d34:	f2 ca 00 30 	sub	r10,r9,48
80007d38:	58 9a       	cp.w	r10,9
80007d3a:	fe 98 ff f7 	brls	80007d28 <_vfprintf_r+0x21c>
80007d3e:	e0 49 00 24 	cp.w	r9,36
80007d42:	cc 31       	brne	80007cc8 <_vfprintf_r+0x1bc>
80007d44:	e0 4b 00 20 	cp.w	r11,32
80007d48:	e0 89 0e 60 	brgt	80009a08 <_vfprintf_r+0x1efc>
80007d4c:	20 1b       	sub	r11,1
80007d4e:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007d52:	12 3b       	cp.w	r11,r9
80007d54:	c0 95       	brlt	80007d66 <_vfprintf_r+0x25a>
80007d56:	c1 08       	rjmp	80007d76 <_vfprintf_r+0x26a>
80007d58:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007d5c:	ec ca ff ff 	sub	r10,r6,-1
80007d60:	12 36       	cp.w	r6,r9
80007d62:	c1 f5       	brlt	80007da0 <_vfprintf_r+0x294>
80007d64:	c2 68       	rjmp	80007db0 <_vfprintf_r+0x2a4>
80007d66:	fa ce f9 44 	sub	lr,sp,-1724
80007d6a:	10 97       	mov	r7,r8
80007d6c:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007d70:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007d74:	c3 58       	rjmp	80007dde <_vfprintf_r+0x2d2>
80007d76:	10 97       	mov	r7,r8
80007d78:	fa c8 f9 50 	sub	r8,sp,-1712
80007d7c:	1a d8       	st.w	--sp,r8
80007d7e:	fa c8 fa b8 	sub	r8,sp,-1352
80007d82:	1a d8       	st.w	--sp,r8
80007d84:	fa c8 fb b4 	sub	r8,sp,-1100
80007d88:	02 9a       	mov	r10,r1
80007d8a:	1a d8       	st.w	--sp,r8
80007d8c:	04 9c       	mov	r12,r2
80007d8e:	fa c8 f9 40 	sub	r8,sp,-1728
80007d92:	fa c9 ff b4 	sub	r9,sp,-76
80007d96:	fe b0 fd 23 	rcall	800077dc <get_arg>
80007d9a:	2f dd       	sub	sp,-12
80007d9c:	78 00       	ld.w	r0,r12[0x0]
80007d9e:	c2 08       	rjmp	80007dde <_vfprintf_r+0x2d2>
80007da0:	fa cc f9 44 	sub	r12,sp,-1724
80007da4:	14 96       	mov	r6,r10
80007da6:	f8 03 00 38 	add	r8,r12,r3<<0x3
80007daa:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007dae:	c1 88       	rjmp	80007dde <_vfprintf_r+0x2d2>
80007db0:	41 08       	lddsp	r8,sp[0x40]
80007db2:	59 f9       	cp.w	r9,31
80007db4:	e0 89 00 11 	brgt	80007dd6 <_vfprintf_r+0x2ca>
80007db8:	f0 cb ff fc 	sub	r11,r8,-4
80007dbc:	51 0b       	stdsp	sp[0x40],r11
80007dbe:	70 00       	ld.w	r0,r8[0x0]
80007dc0:	fa cb f9 44 	sub	r11,sp,-1724
80007dc4:	f6 09 00 38 	add	r8,r11,r9<<0x3
80007dc8:	f1 40 fd 88 	st.w	r8[-632],r0
80007dcc:	2f f9       	sub	r9,-1
80007dce:	14 96       	mov	r6,r10
80007dd0:	fb 49 06 b4 	st.w	sp[1716],r9
80007dd4:	c0 58       	rjmp	80007dde <_vfprintf_r+0x2d2>
80007dd6:	70 00       	ld.w	r0,r8[0x0]
80007dd8:	14 96       	mov	r6,r10
80007dda:	2f c8       	sub	r8,-4
80007ddc:	51 08       	stdsp	sp[0x40],r8
80007dde:	58 00       	cp.w	r0,0
80007de0:	fe 94 ff 76 	brge	80007ccc <_vfprintf_r+0x1c0>
80007de4:	5c 30       	neg	r0
80007de6:	a3 a5       	sbr	r5,0x2
80007de8:	c7 2b       	rjmp	80007ccc <_vfprintf_r+0x1c0>
80007dea:	32 b8       	mov	r8,43
80007dec:	fb 68 06 bb 	st.b	sp[1723],r8
80007df0:	c6 eb       	rjmp	80007ccc <_vfprintf_r+0x1c0>
80007df2:	0f 38       	ld.ub	r8,r7++
80007df4:	e0 48 00 2a 	cp.w	r8,42
80007df8:	c0 30       	breq	80007dfe <_vfprintf_r+0x2f2>
80007dfa:	30 09       	mov	r9,0
80007dfc:	c7 98       	rjmp	80007eee <_vfprintf_r+0x3e2>
80007dfe:	0f 88       	ld.ub	r8,r7[0x0]
80007e00:	f0 c9 00 30 	sub	r9,r8,48
80007e04:	58 99       	cp.w	r9,9
80007e06:	e0 8b 00 1f 	brhi	80007e44 <_vfprintf_r+0x338>
80007e0a:	ee c4 ff ff 	sub	r4,r7,-1
80007e0e:	30 0b       	mov	r11,0
80007e10:	23 08       	sub	r8,48
80007e12:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007e16:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80007e1a:	09 38       	ld.ub	r8,r4++
80007e1c:	f0 c9 00 30 	sub	r9,r8,48
80007e20:	58 99       	cp.w	r9,9
80007e22:	fe 98 ff f7 	brls	80007e10 <_vfprintf_r+0x304>
80007e26:	e0 48 00 24 	cp.w	r8,36
80007e2a:	fe 91 ff 4f 	brne	80007cc8 <_vfprintf_r+0x1bc>
80007e2e:	e0 4b 00 20 	cp.w	r11,32
80007e32:	e0 89 0d eb 	brgt	80009a08 <_vfprintf_r+0x1efc>
80007e36:	20 1b       	sub	r11,1
80007e38:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007e3c:	10 3b       	cp.w	r11,r8
80007e3e:	c0 a5       	brlt	80007e52 <_vfprintf_r+0x346>
80007e40:	c1 18       	rjmp	80007e62 <_vfprintf_r+0x356>
80007e42:	d7 03       	nop
80007e44:	fa fa 06 b4 	ld.w	r10,sp[1716]
80007e48:	ec c9 ff ff 	sub	r9,r6,-1
80007e4c:	14 36       	cp.w	r6,r10
80007e4e:	c1 f5       	brlt	80007e8c <_vfprintf_r+0x380>
80007e50:	c2 88       	rjmp	80007ea0 <_vfprintf_r+0x394>
80007e52:	fa ca f9 44 	sub	r10,sp,-1724
80007e56:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80007e5a:	f6 fb fd 88 	ld.w	r11,r11[-632]
80007e5e:	50 2b       	stdsp	sp[0x8],r11
80007e60:	c3 c8       	rjmp	80007ed8 <_vfprintf_r+0x3cc>
80007e62:	fa c8 f9 50 	sub	r8,sp,-1712
80007e66:	1a d8       	st.w	--sp,r8
80007e68:	fa c8 fa b8 	sub	r8,sp,-1352
80007e6c:	1a d8       	st.w	--sp,r8
80007e6e:	fa c8 fb b4 	sub	r8,sp,-1100
80007e72:	02 9a       	mov	r10,r1
80007e74:	1a d8       	st.w	--sp,r8
80007e76:	04 9c       	mov	r12,r2
80007e78:	fa c8 f9 40 	sub	r8,sp,-1728
80007e7c:	fa c9 ff b4 	sub	r9,sp,-76
80007e80:	fe b0 fc ae 	rcall	800077dc <get_arg>
80007e84:	2f dd       	sub	sp,-12
80007e86:	78 0c       	ld.w	r12,r12[0x0]
80007e88:	50 2c       	stdsp	sp[0x8],r12
80007e8a:	c2 78       	rjmp	80007ed8 <_vfprintf_r+0x3cc>
80007e8c:	12 96       	mov	r6,r9
80007e8e:	0e 94       	mov	r4,r7
80007e90:	fa c9 f9 44 	sub	r9,sp,-1724
80007e94:	f2 03 00 38 	add	r8,r9,r3<<0x3
80007e98:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007e9c:	50 28       	stdsp	sp[0x8],r8
80007e9e:	c1 d8       	rjmp	80007ed8 <_vfprintf_r+0x3cc>
80007ea0:	41 08       	lddsp	r8,sp[0x40]
80007ea2:	59 fa       	cp.w	r10,31
80007ea4:	e0 89 00 14 	brgt	80007ecc <_vfprintf_r+0x3c0>
80007ea8:	f0 cb ff fc 	sub	r11,r8,-4
80007eac:	70 08       	ld.w	r8,r8[0x0]
80007eae:	51 0b       	stdsp	sp[0x40],r11
80007eb0:	50 28       	stdsp	sp[0x8],r8
80007eb2:	fa c6 f9 44 	sub	r6,sp,-1724
80007eb6:	40 2e       	lddsp	lr,sp[0x8]
80007eb8:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007ebc:	f1 4e fd 88 	st.w	r8[-632],lr
80007ec0:	2f fa       	sub	r10,-1
80007ec2:	0e 94       	mov	r4,r7
80007ec4:	fb 4a 06 b4 	st.w	sp[1716],r10
80007ec8:	12 96       	mov	r6,r9
80007eca:	c0 78       	rjmp	80007ed8 <_vfprintf_r+0x3cc>
80007ecc:	70 0c       	ld.w	r12,r8[0x0]
80007ece:	0e 94       	mov	r4,r7
80007ed0:	2f c8       	sub	r8,-4
80007ed2:	50 2c       	stdsp	sp[0x8],r12
80007ed4:	12 96       	mov	r6,r9
80007ed6:	51 08       	stdsp	sp[0x40],r8
80007ed8:	40 2b       	lddsp	r11,sp[0x8]
80007eda:	58 0b       	cp.w	r11,0
80007edc:	fe 95 fe f2 	brlt	80007cc0 <_vfprintf_r+0x1b4>
80007ee0:	08 97       	mov	r7,r4
80007ee2:	cf 5a       	rjmp	80007ccc <_vfprintf_r+0x1c0>
80007ee4:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007ee8:	0f 38       	ld.ub	r8,r7++
80007eea:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007eee:	f0 ca 00 30 	sub	r10,r8,48
80007ef2:	58 9a       	cp.w	r10,9
80007ef4:	fe 98 ff f8 	brls	80007ee4 <_vfprintf_r+0x3d8>
80007ef8:	3f fa       	mov	r10,-1
80007efa:	f2 0a 0c 49 	max	r9,r9,r10
80007efe:	50 29       	stdsp	sp[0x8],r9
80007f00:	ce 9a       	rjmp	80007cd2 <_vfprintf_r+0x1c6>
80007f02:	a7 b5       	sbr	r5,0x7
80007f04:	ce 4a       	rjmp	80007ccc <_vfprintf_r+0x1c0>
80007f06:	30 09       	mov	r9,0
80007f08:	23 08       	sub	r8,48
80007f0a:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007f0e:	f0 09 00 19 	add	r9,r8,r9<<0x1
80007f12:	0f 38       	ld.ub	r8,r7++
80007f14:	f0 ca 00 30 	sub	r10,r8,48
80007f18:	58 9a       	cp.w	r10,9
80007f1a:	fe 98 ff f7 	brls	80007f08 <_vfprintf_r+0x3fc>
80007f1e:	e0 48 00 24 	cp.w	r8,36
80007f22:	fe 91 fe d7 	brne	80007cd0 <_vfprintf_r+0x1c4>
80007f26:	e0 49 00 20 	cp.w	r9,32
80007f2a:	e0 89 0d 6f 	brgt	80009a08 <_vfprintf_r+0x1efc>
80007f2e:	f2 c3 00 01 	sub	r3,r9,1
80007f32:	30 19       	mov	r9,1
80007f34:	50 39       	stdsp	sp[0xc],r9
80007f36:	cc ba       	rjmp	80007ccc <_vfprintf_r+0x1c0>
80007f38:	a3 b5       	sbr	r5,0x3
80007f3a:	cc 9a       	rjmp	80007ccc <_vfprintf_r+0x1c0>
80007f3c:	a7 a5       	sbr	r5,0x6
80007f3e:	cc 7a       	rjmp	80007ccc <_vfprintf_r+0x1c0>
80007f40:	0a 98       	mov	r8,r5
80007f42:	a5 b5       	sbr	r5,0x5
80007f44:	a5 a8       	sbr	r8,0x4
80007f46:	0f 89       	ld.ub	r9,r7[0x0]
80007f48:	36 ce       	mov	lr,108
80007f4a:	fc 09 18 00 	cp.b	r9,lr
80007f4e:	f7 b7 00 ff 	subeq	r7,-1
80007f52:	f0 05 17 10 	movne	r5,r8
80007f56:	cb ba       	rjmp	80007ccc <_vfprintf_r+0x1c0>
80007f58:	a5 b5       	sbr	r5,0x5
80007f5a:	cb 9a       	rjmp	80007ccc <_vfprintf_r+0x1c0>
80007f5c:	50 a7       	stdsp	sp[0x28],r7
80007f5e:	50 80       	stdsp	sp[0x20],r0
80007f60:	0c 97       	mov	r7,r6
80007f62:	10 90       	mov	r0,r8
80007f64:	06 96       	mov	r6,r3
80007f66:	04 94       	mov	r4,r2
80007f68:	40 93       	lddsp	r3,sp[0x24]
80007f6a:	02 92       	mov	r2,r1
80007f6c:	0e 99       	mov	r9,r7
80007f6e:	40 41       	lddsp	r1,sp[0x10]
80007f70:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007f74:	40 3c       	lddsp	r12,sp[0xc]
80007f76:	58 0c       	cp.w	r12,0
80007f78:	c1 d0       	breq	80007fb2 <_vfprintf_r+0x4a6>
80007f7a:	10 36       	cp.w	r6,r8
80007f7c:	c0 64       	brge	80007f88 <_vfprintf_r+0x47c>
80007f7e:	fa cb f9 44 	sub	r11,sp,-1724
80007f82:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007f86:	c1 d8       	rjmp	80007fc0 <_vfprintf_r+0x4b4>
80007f88:	fa c8 f9 50 	sub	r8,sp,-1712
80007f8c:	1a d8       	st.w	--sp,r8
80007f8e:	fa c8 fa b8 	sub	r8,sp,-1352
80007f92:	1a d8       	st.w	--sp,r8
80007f94:	fa c8 fb b4 	sub	r8,sp,-1100
80007f98:	1a d8       	st.w	--sp,r8
80007f9a:	fa c8 f9 40 	sub	r8,sp,-1728
80007f9e:	fa c9 ff b4 	sub	r9,sp,-76
80007fa2:	04 9a       	mov	r10,r2
80007fa4:	0c 9b       	mov	r11,r6
80007fa6:	08 9c       	mov	r12,r4
80007fa8:	fe b0 fc 1a 	rcall	800077dc <get_arg>
80007fac:	2f dd       	sub	sp,-12
80007fae:	19 b8       	ld.ub	r8,r12[0x3]
80007fb0:	c2 28       	rjmp	80007ff4 <_vfprintf_r+0x4e8>
80007fb2:	2f f7       	sub	r7,-1
80007fb4:	10 39       	cp.w	r9,r8
80007fb6:	c0 84       	brge	80007fc6 <_vfprintf_r+0x4ba>
80007fb8:	fa ca f9 44 	sub	r10,sp,-1724
80007fbc:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007fc0:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80007fc4:	c1 88       	rjmp	80007ff4 <_vfprintf_r+0x4e8>
80007fc6:	41 09       	lddsp	r9,sp[0x40]
80007fc8:	59 f8       	cp.w	r8,31
80007fca:	e0 89 00 12 	brgt	80007fee <_vfprintf_r+0x4e2>
80007fce:	f2 ca ff fc 	sub	r10,r9,-4
80007fd2:	51 0a       	stdsp	sp[0x40],r10
80007fd4:	72 09       	ld.w	r9,r9[0x0]
80007fd6:	fa c6 f9 44 	sub	r6,sp,-1724
80007fda:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007fde:	2f f8       	sub	r8,-1
80007fe0:	f5 49 fd 88 	st.w	r10[-632],r9
80007fe4:	fb 48 06 b4 	st.w	sp[1716],r8
80007fe8:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80007fec:	c0 48       	rjmp	80007ff4 <_vfprintf_r+0x4e8>
80007fee:	13 b8       	ld.ub	r8,r9[0x3]
80007ff0:	2f c9       	sub	r9,-4
80007ff2:	51 09       	stdsp	sp[0x40],r9
80007ff4:	fb 68 06 60 	st.b	sp[1632],r8
80007ff8:	30 0e       	mov	lr,0
80007ffa:	30 08       	mov	r8,0
80007ffc:	30 12       	mov	r2,1
80007ffe:	fb 68 06 bb 	st.b	sp[1723],r8
80008002:	50 2e       	stdsp	sp[0x8],lr
80008004:	e0 8f 08 ad 	bral	8000915e <_vfprintf_r+0x1652>
80008008:	50 a7       	stdsp	sp[0x28],r7
8000800a:	50 80       	stdsp	sp[0x20],r0
8000800c:	0c 97       	mov	r7,r6
8000800e:	04 94       	mov	r4,r2
80008010:	06 96       	mov	r6,r3
80008012:	02 92       	mov	r2,r1
80008014:	40 93       	lddsp	r3,sp[0x24]
80008016:	10 90       	mov	r0,r8
80008018:	40 41       	lddsp	r1,sp[0x10]
8000801a:	a5 a5       	sbr	r5,0x4
8000801c:	c0 a8       	rjmp	80008030 <_vfprintf_r+0x524>
8000801e:	50 a7       	stdsp	sp[0x28],r7
80008020:	50 80       	stdsp	sp[0x20],r0
80008022:	0c 97       	mov	r7,r6
80008024:	04 94       	mov	r4,r2
80008026:	06 96       	mov	r6,r3
80008028:	02 92       	mov	r2,r1
8000802a:	40 93       	lddsp	r3,sp[0x24]
8000802c:	10 90       	mov	r0,r8
8000802e:	40 41       	lddsp	r1,sp[0x10]
80008030:	ed b5 00 05 	bld	r5,0x5
80008034:	c5 11       	brne	800080d6 <_vfprintf_r+0x5ca>
80008036:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000803a:	40 3c       	lddsp	r12,sp[0xc]
8000803c:	58 0c       	cp.w	r12,0
8000803e:	c1 e0       	breq	8000807a <_vfprintf_r+0x56e>
80008040:	10 36       	cp.w	r6,r8
80008042:	c0 64       	brge	8000804e <_vfprintf_r+0x542>
80008044:	fa cb f9 44 	sub	r11,sp,-1724
80008048:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000804c:	c2 08       	rjmp	8000808c <_vfprintf_r+0x580>
8000804e:	fa c8 f9 50 	sub	r8,sp,-1712
80008052:	1a d8       	st.w	--sp,r8
80008054:	fa c8 fa b8 	sub	r8,sp,-1352
80008058:	0c 9b       	mov	r11,r6
8000805a:	1a d8       	st.w	--sp,r8
8000805c:	fa c8 fb b4 	sub	r8,sp,-1100
80008060:	1a d8       	st.w	--sp,r8
80008062:	fa c9 ff b4 	sub	r9,sp,-76
80008066:	fa c8 f9 40 	sub	r8,sp,-1728
8000806a:	04 9a       	mov	r10,r2
8000806c:	08 9c       	mov	r12,r4
8000806e:	fe b0 fb b7 	rcall	800077dc <get_arg>
80008072:	2f dd       	sub	sp,-12
80008074:	78 1b       	ld.w	r11,r12[0x4]
80008076:	78 09       	ld.w	r9,r12[0x0]
80008078:	c2 b8       	rjmp	800080ce <_vfprintf_r+0x5c2>
8000807a:	ee ca ff ff 	sub	r10,r7,-1
8000807e:	10 37       	cp.w	r7,r8
80008080:	c0 b4       	brge	80008096 <_vfprintf_r+0x58a>
80008082:	fa c9 f9 44 	sub	r9,sp,-1724
80008086:	14 97       	mov	r7,r10
80008088:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000808c:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008090:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008094:	c1 d8       	rjmp	800080ce <_vfprintf_r+0x5c2>
80008096:	41 09       	lddsp	r9,sp[0x40]
80008098:	59 f8       	cp.w	r8,31
8000809a:	e0 89 00 14 	brgt	800080c2 <_vfprintf_r+0x5b6>
8000809e:	f2 cb ff f8 	sub	r11,r9,-8
800080a2:	51 0b       	stdsp	sp[0x40],r11
800080a4:	fa c6 f9 44 	sub	r6,sp,-1724
800080a8:	72 1b       	ld.w	r11,r9[0x4]
800080aa:	ec 08 00 3c 	add	r12,r6,r8<<0x3
800080ae:	72 09       	ld.w	r9,r9[0x0]
800080b0:	f9 4b fd 8c 	st.w	r12[-628],r11
800080b4:	f9 49 fd 88 	st.w	r12[-632],r9
800080b8:	2f f8       	sub	r8,-1
800080ba:	14 97       	mov	r7,r10
800080bc:	fb 48 06 b4 	st.w	sp[1716],r8
800080c0:	c0 78       	rjmp	800080ce <_vfprintf_r+0x5c2>
800080c2:	f2 c8 ff f8 	sub	r8,r9,-8
800080c6:	72 1b       	ld.w	r11,r9[0x4]
800080c8:	14 97       	mov	r7,r10
800080ca:	51 08       	stdsp	sp[0x40],r8
800080cc:	72 09       	ld.w	r9,r9[0x0]
800080ce:	16 98       	mov	r8,r11
800080d0:	fa e9 00 00 	st.d	sp[0],r8
800080d4:	ca e8       	rjmp	80008230 <_vfprintf_r+0x724>
800080d6:	ed b5 00 04 	bld	r5,0x4
800080da:	c1 71       	brne	80008108 <_vfprintf_r+0x5fc>
800080dc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800080e0:	40 3e       	lddsp	lr,sp[0xc]
800080e2:	58 0e       	cp.w	lr,0
800080e4:	c0 80       	breq	800080f4 <_vfprintf_r+0x5e8>
800080e6:	10 36       	cp.w	r6,r8
800080e8:	c6 94       	brge	800081ba <_vfprintf_r+0x6ae>
800080ea:	fa cc f9 44 	sub	r12,sp,-1724
800080ee:	f8 06 00 36 	add	r6,r12,r6<<0x3
800080f2:	c8 28       	rjmp	800081f6 <_vfprintf_r+0x6ea>
800080f4:	ee ca ff ff 	sub	r10,r7,-1
800080f8:	10 37       	cp.w	r7,r8
800080fa:	e0 84 00 81 	brge	800081fc <_vfprintf_r+0x6f0>
800080fe:	fa cb f9 44 	sub	r11,sp,-1724
80008102:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008106:	c7 78       	rjmp	800081f4 <_vfprintf_r+0x6e8>
80008108:	ed b5 00 06 	bld	r5,0x6
8000810c:	c4 b1       	brne	800081a2 <_vfprintf_r+0x696>
8000810e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008112:	40 3c       	lddsp	r12,sp[0xc]
80008114:	58 0c       	cp.w	r12,0
80008116:	c1 d0       	breq	80008150 <_vfprintf_r+0x644>
80008118:	10 36       	cp.w	r6,r8
8000811a:	c0 64       	brge	80008126 <_vfprintf_r+0x61a>
8000811c:	fa cb f9 44 	sub	r11,sp,-1724
80008120:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008124:	c1 f8       	rjmp	80008162 <_vfprintf_r+0x656>
80008126:	fa c8 f9 50 	sub	r8,sp,-1712
8000812a:	1a d8       	st.w	--sp,r8
8000812c:	fa c8 fa b8 	sub	r8,sp,-1352
80008130:	1a d8       	st.w	--sp,r8
80008132:	fa c8 fb b4 	sub	r8,sp,-1100
80008136:	1a d8       	st.w	--sp,r8
80008138:	fa c8 f9 40 	sub	r8,sp,-1728
8000813c:	fa c9 ff b4 	sub	r9,sp,-76
80008140:	04 9a       	mov	r10,r2
80008142:	0c 9b       	mov	r11,r6
80008144:	08 9c       	mov	r12,r4
80008146:	fe b0 fb 4b 	rcall	800077dc <get_arg>
8000814a:	2f dd       	sub	sp,-12
8000814c:	98 18       	ld.sh	r8,r12[0x2]
8000814e:	c2 68       	rjmp	8000819a <_vfprintf_r+0x68e>
80008150:	ee ca ff ff 	sub	r10,r7,-1
80008154:	10 37       	cp.w	r7,r8
80008156:	c0 94       	brge	80008168 <_vfprintf_r+0x65c>
80008158:	fa c9 f9 44 	sub	r9,sp,-1724
8000815c:	14 97       	mov	r7,r10
8000815e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008162:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008166:	c1 a8       	rjmp	8000819a <_vfprintf_r+0x68e>
80008168:	41 09       	lddsp	r9,sp[0x40]
8000816a:	59 f8       	cp.w	r8,31
8000816c:	e0 89 00 13 	brgt	80008192 <_vfprintf_r+0x686>
80008170:	f2 cb ff fc 	sub	r11,r9,-4
80008174:	51 0b       	stdsp	sp[0x40],r11
80008176:	72 09       	ld.w	r9,r9[0x0]
80008178:	fa c6 f9 44 	sub	r6,sp,-1724
8000817c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008180:	2f f8       	sub	r8,-1
80008182:	f7 49 fd 88 	st.w	r11[-632],r9
80008186:	fb 48 06 b4 	st.w	sp[1716],r8
8000818a:	14 97       	mov	r7,r10
8000818c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008190:	c0 58       	rjmp	8000819a <_vfprintf_r+0x68e>
80008192:	92 18       	ld.sh	r8,r9[0x2]
80008194:	14 97       	mov	r7,r10
80008196:	2f c9       	sub	r9,-4
80008198:	51 09       	stdsp	sp[0x40],r9
8000819a:	50 18       	stdsp	sp[0x4],r8
8000819c:	bf 58       	asr	r8,0x1f
8000819e:	50 08       	stdsp	sp[0x0],r8
800081a0:	c4 88       	rjmp	80008230 <_vfprintf_r+0x724>
800081a2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800081a6:	40 3c       	lddsp	r12,sp[0xc]
800081a8:	58 0c       	cp.w	r12,0
800081aa:	c1 d0       	breq	800081e4 <_vfprintf_r+0x6d8>
800081ac:	10 36       	cp.w	r6,r8
800081ae:	c0 64       	brge	800081ba <_vfprintf_r+0x6ae>
800081b0:	fa cb f9 44 	sub	r11,sp,-1724
800081b4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800081b8:	c1 f8       	rjmp	800081f6 <_vfprintf_r+0x6ea>
800081ba:	fa c8 f9 50 	sub	r8,sp,-1712
800081be:	1a d8       	st.w	--sp,r8
800081c0:	fa c8 fa b8 	sub	r8,sp,-1352
800081c4:	0c 9b       	mov	r11,r6
800081c6:	1a d8       	st.w	--sp,r8
800081c8:	fa c8 fb b4 	sub	r8,sp,-1100
800081cc:	04 9a       	mov	r10,r2
800081ce:	1a d8       	st.w	--sp,r8
800081d0:	08 9c       	mov	r12,r4
800081d2:	fa c8 f9 40 	sub	r8,sp,-1728
800081d6:	fa c9 ff b4 	sub	r9,sp,-76
800081da:	fe b0 fb 01 	rcall	800077dc <get_arg>
800081de:	2f dd       	sub	sp,-12
800081e0:	78 0b       	ld.w	r11,r12[0x0]
800081e2:	c2 48       	rjmp	8000822a <_vfprintf_r+0x71e>
800081e4:	ee ca ff ff 	sub	r10,r7,-1
800081e8:	10 37       	cp.w	r7,r8
800081ea:	c0 94       	brge	800081fc <_vfprintf_r+0x6f0>
800081ec:	fa c9 f9 44 	sub	r9,sp,-1724
800081f0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800081f4:	14 97       	mov	r7,r10
800081f6:	ec fb fd 88 	ld.w	r11,r6[-632]
800081fa:	c1 88       	rjmp	8000822a <_vfprintf_r+0x71e>
800081fc:	41 09       	lddsp	r9,sp[0x40]
800081fe:	59 f8       	cp.w	r8,31
80008200:	e0 89 00 11 	brgt	80008222 <_vfprintf_r+0x716>
80008204:	f2 cb ff fc 	sub	r11,r9,-4
80008208:	51 0b       	stdsp	sp[0x40],r11
8000820a:	fa c6 f9 44 	sub	r6,sp,-1724
8000820e:	72 0b       	ld.w	r11,r9[0x0]
80008210:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008214:	f3 4b fd 88 	st.w	r9[-632],r11
80008218:	2f f8       	sub	r8,-1
8000821a:	14 97       	mov	r7,r10
8000821c:	fb 48 06 b4 	st.w	sp[1716],r8
80008220:	c0 58       	rjmp	8000822a <_vfprintf_r+0x71e>
80008222:	72 0b       	ld.w	r11,r9[0x0]
80008224:	14 97       	mov	r7,r10
80008226:	2f c9       	sub	r9,-4
80008228:	51 09       	stdsp	sp[0x40],r9
8000822a:	50 1b       	stdsp	sp[0x4],r11
8000822c:	bf 5b       	asr	r11,0x1f
8000822e:	50 0b       	stdsp	sp[0x0],r11
80008230:	fa ea 00 00 	ld.d	r10,sp[0]
80008234:	58 0a       	cp.w	r10,0
80008236:	5c 2b       	cpc	r11
80008238:	c0 e4       	brge	80008254 <_vfprintf_r+0x748>
8000823a:	30 08       	mov	r8,0
8000823c:	fa ea 00 00 	ld.d	r10,sp[0]
80008240:	30 09       	mov	r9,0
80008242:	f0 0a 01 0a 	sub	r10,r8,r10
80008246:	f2 0b 01 4b 	sbc	r11,r9,r11
8000824a:	32 d8       	mov	r8,45
8000824c:	fa eb 00 00 	st.d	sp[0],r10
80008250:	fb 68 06 bb 	st.b	sp[1723],r8
80008254:	30 18       	mov	r8,1
80008256:	e0 8f 06 fa 	bral	8000904a <_vfprintf_r+0x153e>
8000825a:	50 a7       	stdsp	sp[0x28],r7
8000825c:	50 80       	stdsp	sp[0x20],r0
8000825e:	0c 97       	mov	r7,r6
80008260:	04 94       	mov	r4,r2
80008262:	06 96       	mov	r6,r3
80008264:	02 92       	mov	r2,r1
80008266:	40 93       	lddsp	r3,sp[0x24]
80008268:	10 90       	mov	r0,r8
8000826a:	40 41       	lddsp	r1,sp[0x10]
8000826c:	0e 99       	mov	r9,r7
8000826e:	ed b5 00 03 	bld	r5,0x3
80008272:	c4 11       	brne	800082f4 <_vfprintf_r+0x7e8>
80008274:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008278:	40 3a       	lddsp	r10,sp[0xc]
8000827a:	58 0a       	cp.w	r10,0
8000827c:	c1 90       	breq	800082ae <_vfprintf_r+0x7a2>
8000827e:	10 36       	cp.w	r6,r8
80008280:	c6 45       	brlt	80008348 <_vfprintf_r+0x83c>
80008282:	fa c8 f9 50 	sub	r8,sp,-1712
80008286:	1a d8       	st.w	--sp,r8
80008288:	fa c8 fa b8 	sub	r8,sp,-1352
8000828c:	1a d8       	st.w	--sp,r8
8000828e:	fa c8 fb b4 	sub	r8,sp,-1100
80008292:	0c 9b       	mov	r11,r6
80008294:	1a d8       	st.w	--sp,r8
80008296:	04 9a       	mov	r10,r2
80008298:	fa c8 f9 40 	sub	r8,sp,-1728
8000829c:	fa c9 ff b4 	sub	r9,sp,-76
800082a0:	08 9c       	mov	r12,r4
800082a2:	fe b0 fa 9d 	rcall	800077dc <get_arg>
800082a6:	2f dd       	sub	sp,-12
800082a8:	78 16       	ld.w	r6,r12[0x4]
800082aa:	50 76       	stdsp	sp[0x1c],r6
800082ac:	c4 88       	rjmp	8000833c <_vfprintf_r+0x830>
800082ae:	2f f7       	sub	r7,-1
800082b0:	10 39       	cp.w	r9,r8
800082b2:	c0 c4       	brge	800082ca <_vfprintf_r+0x7be>
800082b4:	fa ce f9 44 	sub	lr,sp,-1724
800082b8:	fc 06 00 36 	add	r6,lr,r6<<0x3
800082bc:	ec fc fd 8c 	ld.w	r12,r6[-628]
800082c0:	50 7c       	stdsp	sp[0x1c],r12
800082c2:	ec f6 fd 88 	ld.w	r6,r6[-632]
800082c6:	50 56       	stdsp	sp[0x14],r6
800082c8:	c6 68       	rjmp	80008394 <_vfprintf_r+0x888>
800082ca:	41 09       	lddsp	r9,sp[0x40]
800082cc:	59 f8       	cp.w	r8,31
800082ce:	e0 89 00 10 	brgt	800082ee <_vfprintf_r+0x7e2>
800082d2:	f2 ca ff f8 	sub	r10,r9,-8
800082d6:	72 1b       	ld.w	r11,r9[0x4]
800082d8:	51 0a       	stdsp	sp[0x40],r10
800082da:	72 09       	ld.w	r9,r9[0x0]
800082dc:	fa ca f9 44 	sub	r10,sp,-1724
800082e0:	50 7b       	stdsp	sp[0x1c],r11
800082e2:	50 59       	stdsp	sp[0x14],r9
800082e4:	f4 08 00 39 	add	r9,r10,r8<<0x3
800082e8:	40 5b       	lddsp	r11,sp[0x14]
800082ea:	40 7a       	lddsp	r10,sp[0x1c]
800082ec:	c4 78       	rjmp	8000837a <_vfprintf_r+0x86e>
800082ee:	72 18       	ld.w	r8,r9[0x4]
800082f0:	50 78       	stdsp	sp[0x1c],r8
800082f2:	c4 c8       	rjmp	8000838a <_vfprintf_r+0x87e>
800082f4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800082f8:	40 3e       	lddsp	lr,sp[0xc]
800082fa:	58 0e       	cp.w	lr,0
800082fc:	c2 30       	breq	80008342 <_vfprintf_r+0x836>
800082fe:	10 36       	cp.w	r6,r8
80008300:	c0 94       	brge	80008312 <_vfprintf_r+0x806>
80008302:	fa cc f9 44 	sub	r12,sp,-1724
80008306:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000830a:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000830e:	50 7b       	stdsp	sp[0x1c],r11
80008310:	cd 9b       	rjmp	800082c2 <_vfprintf_r+0x7b6>
80008312:	fa c8 f9 50 	sub	r8,sp,-1712
80008316:	1a d8       	st.w	--sp,r8
80008318:	fa c8 fa b8 	sub	r8,sp,-1352
8000831c:	04 9a       	mov	r10,r2
8000831e:	1a d8       	st.w	--sp,r8
80008320:	fa c8 fb b4 	sub	r8,sp,-1100
80008324:	0c 9b       	mov	r11,r6
80008326:	1a d8       	st.w	--sp,r8
80008328:	08 9c       	mov	r12,r4
8000832a:	fa c8 f9 40 	sub	r8,sp,-1728
8000832e:	fa c9 ff b4 	sub	r9,sp,-76
80008332:	fe b0 fa 55 	rcall	800077dc <get_arg>
80008336:	2f dd       	sub	sp,-12
80008338:	78 1a       	ld.w	r10,r12[0x4]
8000833a:	50 7a       	stdsp	sp[0x1c],r10
8000833c:	78 0c       	ld.w	r12,r12[0x0]
8000833e:	50 5c       	stdsp	sp[0x14],r12
80008340:	c2 a8       	rjmp	80008394 <_vfprintf_r+0x888>
80008342:	2f f7       	sub	r7,-1
80008344:	10 39       	cp.w	r9,r8
80008346:	c0 94       	brge	80008358 <_vfprintf_r+0x84c>
80008348:	fa c9 f9 44 	sub	r9,sp,-1724
8000834c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008350:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80008354:	50 78       	stdsp	sp[0x1c],r8
80008356:	cb 6b       	rjmp	800082c2 <_vfprintf_r+0x7b6>
80008358:	41 09       	lddsp	r9,sp[0x40]
8000835a:	59 f8       	cp.w	r8,31
8000835c:	e0 89 00 15 	brgt	80008386 <_vfprintf_r+0x87a>
80008360:	f2 ca ff f8 	sub	r10,r9,-8
80008364:	72 16       	ld.w	r6,r9[0x4]
80008366:	72 09       	ld.w	r9,r9[0x0]
80008368:	51 0a       	stdsp	sp[0x40],r10
8000836a:	50 59       	stdsp	sp[0x14],r9
8000836c:	fa ce f9 44 	sub	lr,sp,-1724
80008370:	50 76       	stdsp	sp[0x1c],r6
80008372:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008376:	40 5b       	lddsp	r11,sp[0x14]
80008378:	0c 9a       	mov	r10,r6
8000837a:	f2 eb fd 88 	st.d	r9[-632],r10
8000837e:	2f f8       	sub	r8,-1
80008380:	fb 48 06 b4 	st.w	sp[1716],r8
80008384:	c0 88       	rjmp	80008394 <_vfprintf_r+0x888>
80008386:	72 1c       	ld.w	r12,r9[0x4]
80008388:	50 7c       	stdsp	sp[0x1c],r12
8000838a:	f2 c8 ff f8 	sub	r8,r9,-8
8000838e:	51 08       	stdsp	sp[0x40],r8
80008390:	72 09       	ld.w	r9,r9[0x0]
80008392:	50 59       	stdsp	sp[0x14],r9
80008394:	40 5b       	lddsp	r11,sp[0x14]
80008396:	40 7a       	lddsp	r10,sp[0x1c]
80008398:	e0 a0 19 54 	rcall	8000b640 <__isinfd>
8000839c:	18 96       	mov	r6,r12
8000839e:	c1 70       	breq	800083cc <_vfprintf_r+0x8c0>
800083a0:	30 08       	mov	r8,0
800083a2:	30 09       	mov	r9,0
800083a4:	40 5b       	lddsp	r11,sp[0x14]
800083a6:	40 7a       	lddsp	r10,sp[0x1c]
800083a8:	e0 a0 1d b4 	rcall	8000bf10 <__avr32_f64_cmp_lt>
800083ac:	c0 40       	breq	800083b4 <_vfprintf_r+0x8a8>
800083ae:	32 d8       	mov	r8,45
800083b0:	fb 68 06 bb 	st.b	sp[1723],r8
800083b4:	fe c8 ab 4c 	sub	r8,pc,-21684
800083b8:	fe c6 ab 4c 	sub	r6,pc,-21684
800083bc:	a7 d5       	cbr	r5,0x7
800083be:	e0 40 00 47 	cp.w	r0,71
800083c2:	f0 06 17 a0 	movle	r6,r8
800083c6:	30 32       	mov	r2,3
800083c8:	e0 8f 06 ce 	bral	80009164 <_vfprintf_r+0x1658>
800083cc:	40 5b       	lddsp	r11,sp[0x14]
800083ce:	40 7a       	lddsp	r10,sp[0x1c]
800083d0:	e0 a0 19 4d 	rcall	8000b66a <__isnand>
800083d4:	c0 e0       	breq	800083f0 <_vfprintf_r+0x8e4>
800083d6:	50 26       	stdsp	sp[0x8],r6
800083d8:	fe c8 ab 68 	sub	r8,pc,-21656
800083dc:	fe c6 ab 68 	sub	r6,pc,-21656
800083e0:	a7 d5       	cbr	r5,0x7
800083e2:	e0 40 00 47 	cp.w	r0,71
800083e6:	f0 06 17 a0 	movle	r6,r8
800083ea:	30 32       	mov	r2,3
800083ec:	e0 8f 06 c2 	bral	80009170 <_vfprintf_r+0x1664>
800083f0:	40 2a       	lddsp	r10,sp[0x8]
800083f2:	5b fa       	cp.w	r10,-1
800083f4:	c0 41       	brne	800083fc <_vfprintf_r+0x8f0>
800083f6:	30 69       	mov	r9,6
800083f8:	50 29       	stdsp	sp[0x8],r9
800083fa:	c1 18       	rjmp	8000841c <_vfprintf_r+0x910>
800083fc:	e0 40 00 47 	cp.w	r0,71
80008400:	5f 09       	sreq	r9
80008402:	e0 40 00 67 	cp.w	r0,103
80008406:	5f 08       	sreq	r8
80008408:	f3 e8 10 08 	or	r8,r9,r8
8000840c:	f8 08 18 00 	cp.b	r8,r12
80008410:	c0 60       	breq	8000841c <_vfprintf_r+0x910>
80008412:	40 28       	lddsp	r8,sp[0x8]
80008414:	58 08       	cp.w	r8,0
80008416:	f9 b8 00 01 	moveq	r8,1
8000841a:	50 28       	stdsp	sp[0x8],r8
8000841c:	40 78       	lddsp	r8,sp[0x1c]
8000841e:	40 59       	lddsp	r9,sp[0x14]
80008420:	fa e9 06 94 	st.d	sp[1684],r8
80008424:	a9 a5       	sbr	r5,0x8
80008426:	fa f8 06 94 	ld.w	r8,sp[1684]
8000842a:	58 08       	cp.w	r8,0
8000842c:	c0 65       	brlt	80008438 <_vfprintf_r+0x92c>
8000842e:	40 5e       	lddsp	lr,sp[0x14]
80008430:	30 0c       	mov	r12,0
80008432:	50 6e       	stdsp	sp[0x18],lr
80008434:	50 9c       	stdsp	sp[0x24],r12
80008436:	c0 78       	rjmp	80008444 <_vfprintf_r+0x938>
80008438:	40 5b       	lddsp	r11,sp[0x14]
8000843a:	32 da       	mov	r10,45
8000843c:	ee 1b 80 00 	eorh	r11,0x8000
80008440:	50 9a       	stdsp	sp[0x24],r10
80008442:	50 6b       	stdsp	sp[0x18],r11
80008444:	e0 40 00 46 	cp.w	r0,70
80008448:	5f 09       	sreq	r9
8000844a:	e0 40 00 66 	cp.w	r0,102
8000844e:	5f 08       	sreq	r8
80008450:	f3 e8 10 08 	or	r8,r9,r8
80008454:	50 48       	stdsp	sp[0x10],r8
80008456:	c0 40       	breq	8000845e <_vfprintf_r+0x952>
80008458:	40 22       	lddsp	r2,sp[0x8]
8000845a:	30 39       	mov	r9,3
8000845c:	c1 08       	rjmp	8000847c <_vfprintf_r+0x970>
8000845e:	e0 40 00 45 	cp.w	r0,69
80008462:	5f 09       	sreq	r9
80008464:	e0 40 00 65 	cp.w	r0,101
80008468:	5f 08       	sreq	r8
8000846a:	40 22       	lddsp	r2,sp[0x8]
8000846c:	10 49       	or	r9,r8
8000846e:	2f f2       	sub	r2,-1
80008470:	40 46       	lddsp	r6,sp[0x10]
80008472:	ec 09 18 00 	cp.b	r9,r6
80008476:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000847a:	30 29       	mov	r9,2
8000847c:	fa c8 f9 5c 	sub	r8,sp,-1700
80008480:	1a d8       	st.w	--sp,r8
80008482:	fa c8 f9 54 	sub	r8,sp,-1708
80008486:	1a d8       	st.w	--sp,r8
80008488:	fa c8 f9 4c 	sub	r8,sp,-1716
8000848c:	08 9c       	mov	r12,r4
8000848e:	1a d8       	st.w	--sp,r8
80008490:	04 98       	mov	r8,r2
80008492:	40 9b       	lddsp	r11,sp[0x24]
80008494:	40 aa       	lddsp	r10,sp[0x28]
80008496:	e0 a0 0b c3 	rcall	80009c1c <_dtoa_r>
8000849a:	e0 40 00 47 	cp.w	r0,71
8000849e:	5f 19       	srne	r9
800084a0:	e0 40 00 67 	cp.w	r0,103
800084a4:	5f 18       	srne	r8
800084a6:	18 96       	mov	r6,r12
800084a8:	2f dd       	sub	sp,-12
800084aa:	f3 e8 00 08 	and	r8,r9,r8
800084ae:	c0 41       	brne	800084b6 <_vfprintf_r+0x9aa>
800084b0:	ed b5 00 00 	bld	r5,0x0
800084b4:	c3 01       	brne	80008514 <_vfprintf_r+0xa08>
800084b6:	ec 02 00 0e 	add	lr,r6,r2
800084ba:	50 3e       	stdsp	sp[0xc],lr
800084bc:	40 4c       	lddsp	r12,sp[0x10]
800084be:	58 0c       	cp.w	r12,0
800084c0:	c1 50       	breq	800084ea <_vfprintf_r+0x9de>
800084c2:	0d 89       	ld.ub	r9,r6[0x0]
800084c4:	33 08       	mov	r8,48
800084c6:	f0 09 18 00 	cp.b	r9,r8
800084ca:	c0 b1       	brne	800084e0 <_vfprintf_r+0x9d4>
800084cc:	30 08       	mov	r8,0
800084ce:	30 09       	mov	r9,0
800084d0:	40 6b       	lddsp	r11,sp[0x18]
800084d2:	40 7a       	lddsp	r10,sp[0x1c]
800084d4:	e0 a0 1c d7 	rcall	8000be82 <__avr32_f64_cmp_eq>
800084d8:	fb b2 00 01 	rsubeq	r2,1
800084dc:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
800084e0:	40 3b       	lddsp	r11,sp[0xc]
800084e2:	fa f8 06 ac 	ld.w	r8,sp[1708]
800084e6:	10 0b       	add	r11,r8
800084e8:	50 3b       	stdsp	sp[0xc],r11
800084ea:	40 6b       	lddsp	r11,sp[0x18]
800084ec:	30 08       	mov	r8,0
800084ee:	30 09       	mov	r9,0
800084f0:	40 7a       	lddsp	r10,sp[0x1c]
800084f2:	e0 a0 1c c8 	rcall	8000be82 <__avr32_f64_cmp_eq>
800084f6:	c0 90       	breq	80008508 <_vfprintf_r+0x9fc>
800084f8:	40 3a       	lddsp	r10,sp[0xc]
800084fa:	fb 4a 06 a4 	st.w	sp[1700],r10
800084fe:	c0 58       	rjmp	80008508 <_vfprintf_r+0x9fc>
80008500:	10 c9       	st.b	r8++,r9
80008502:	fb 48 06 a4 	st.w	sp[1700],r8
80008506:	c0 28       	rjmp	8000850a <_vfprintf_r+0x9fe>
80008508:	33 09       	mov	r9,48
8000850a:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000850e:	40 3e       	lddsp	lr,sp[0xc]
80008510:	1c 38       	cp.w	r8,lr
80008512:	cf 73       	brcs	80008500 <_vfprintf_r+0x9f4>
80008514:	e0 40 00 47 	cp.w	r0,71
80008518:	5f 09       	sreq	r9
8000851a:	e0 40 00 67 	cp.w	r0,103
8000851e:	5f 08       	sreq	r8
80008520:	f3 e8 10 08 	or	r8,r9,r8
80008524:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008528:	0c 19       	sub	r9,r6
8000852a:	50 69       	stdsp	sp[0x18],r9
8000852c:	58 08       	cp.w	r8,0
8000852e:	c0 b0       	breq	80008544 <_vfprintf_r+0xa38>
80008530:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008534:	5b d8       	cp.w	r8,-3
80008536:	c0 55       	brlt	80008540 <_vfprintf_r+0xa34>
80008538:	40 2c       	lddsp	r12,sp[0x8]
8000853a:	18 38       	cp.w	r8,r12
8000853c:	e0 8a 00 6a 	brle	80008610 <_vfprintf_r+0xb04>
80008540:	20 20       	sub	r0,2
80008542:	c0 58       	rjmp	8000854c <_vfprintf_r+0xa40>
80008544:	e0 40 00 65 	cp.w	r0,101
80008548:	e0 89 00 46 	brgt	800085d4 <_vfprintf_r+0xac8>
8000854c:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008550:	fb 60 06 9c 	st.b	sp[1692],r0
80008554:	20 1b       	sub	r11,1
80008556:	fb 4b 06 ac 	st.w	sp[1708],r11
8000855a:	c0 47       	brpl	80008562 <_vfprintf_r+0xa56>
8000855c:	5c 3b       	neg	r11
8000855e:	32 d8       	mov	r8,45
80008560:	c0 28       	rjmp	80008564 <_vfprintf_r+0xa58>
80008562:	32 b8       	mov	r8,43
80008564:	fb 68 06 9d 	st.b	sp[1693],r8
80008568:	58 9b       	cp.w	r11,9
8000856a:	e0 8a 00 1d 	brle	800085a4 <_vfprintf_r+0xa98>
8000856e:	fa c9 fa 35 	sub	r9,sp,-1483
80008572:	30 aa       	mov	r10,10
80008574:	12 98       	mov	r8,r9
80008576:	0e 9c       	mov	r12,r7
80008578:	0c 92       	mov	r2,r6
8000857a:	f6 0a 0c 06 	divs	r6,r11,r10
8000857e:	0e 9b       	mov	r11,r7
80008580:	2d 0b       	sub	r11,-48
80008582:	10 fb       	st.b	--r8,r11
80008584:	0c 9b       	mov	r11,r6
80008586:	58 96       	cp.w	r6,9
80008588:	fe 99 ff f9 	brgt	8000857a <_vfprintf_r+0xa6e>
8000858c:	2d 0b       	sub	r11,-48
8000858e:	18 97       	mov	r7,r12
80008590:	04 96       	mov	r6,r2
80008592:	10 fb       	st.b	--r8,r11
80008594:	fa ca f9 62 	sub	r10,sp,-1694
80008598:	c0 38       	rjmp	8000859e <_vfprintf_r+0xa92>
8000859a:	11 3b       	ld.ub	r11,r8++
8000859c:	14 cb       	st.b	r10++,r11
8000859e:	12 38       	cp.w	r8,r9
800085a0:	cf d3       	brcs	8000859a <_vfprintf_r+0xa8e>
800085a2:	c0 98       	rjmp	800085b4 <_vfprintf_r+0xaa8>
800085a4:	2d 0b       	sub	r11,-48
800085a6:	33 08       	mov	r8,48
800085a8:	fb 6b 06 9f 	st.b	sp[1695],r11
800085ac:	fb 68 06 9e 	st.b	sp[1694],r8
800085b0:	fa ca f9 60 	sub	r10,sp,-1696
800085b4:	fa c8 f9 64 	sub	r8,sp,-1692
800085b8:	f4 08 01 08 	sub	r8,r10,r8
800085bc:	50 e8       	stdsp	sp[0x38],r8
800085be:	10 92       	mov	r2,r8
800085c0:	40 6b       	lddsp	r11,sp[0x18]
800085c2:	16 02       	add	r2,r11
800085c4:	58 1b       	cp.w	r11,1
800085c6:	e0 89 00 05 	brgt	800085d0 <_vfprintf_r+0xac4>
800085ca:	ed b5 00 00 	bld	r5,0x0
800085ce:	c3 51       	brne	80008638 <_vfprintf_r+0xb2c>
800085d0:	2f f2       	sub	r2,-1
800085d2:	c3 38       	rjmp	80008638 <_vfprintf_r+0xb2c>
800085d4:	e0 40 00 66 	cp.w	r0,102
800085d8:	c1 c1       	brne	80008610 <_vfprintf_r+0xb04>
800085da:	fa f2 06 ac 	ld.w	r2,sp[1708]
800085de:	58 02       	cp.w	r2,0
800085e0:	e0 8a 00 0c 	brle	800085f8 <_vfprintf_r+0xaec>
800085e4:	40 2a       	lddsp	r10,sp[0x8]
800085e6:	58 0a       	cp.w	r10,0
800085e8:	c0 41       	brne	800085f0 <_vfprintf_r+0xae4>
800085ea:	ed b5 00 00 	bld	r5,0x0
800085ee:	c2 51       	brne	80008638 <_vfprintf_r+0xb2c>
800085f0:	2f f2       	sub	r2,-1
800085f2:	40 29       	lddsp	r9,sp[0x8]
800085f4:	12 02       	add	r2,r9
800085f6:	c0 b8       	rjmp	8000860c <_vfprintf_r+0xb00>
800085f8:	40 28       	lddsp	r8,sp[0x8]
800085fa:	58 08       	cp.w	r8,0
800085fc:	c0 61       	brne	80008608 <_vfprintf_r+0xafc>
800085fe:	ed b5 00 00 	bld	r5,0x0
80008602:	c0 30       	breq	80008608 <_vfprintf_r+0xafc>
80008604:	30 12       	mov	r2,1
80008606:	c1 98       	rjmp	80008638 <_vfprintf_r+0xb2c>
80008608:	40 22       	lddsp	r2,sp[0x8]
8000860a:	2f e2       	sub	r2,-2
8000860c:	36 60       	mov	r0,102
8000860e:	c1 58       	rjmp	80008638 <_vfprintf_r+0xb2c>
80008610:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008614:	40 6e       	lddsp	lr,sp[0x18]
80008616:	1c 32       	cp.w	r2,lr
80008618:	c0 65       	brlt	80008624 <_vfprintf_r+0xb18>
8000861a:	ed b5 00 00 	bld	r5,0x0
8000861e:	f7 b2 00 ff 	subeq	r2,-1
80008622:	c0 a8       	rjmp	80008636 <_vfprintf_r+0xb2a>
80008624:	e4 08 11 02 	rsub	r8,r2,2
80008628:	40 6c       	lddsp	r12,sp[0x18]
8000862a:	58 02       	cp.w	r2,0
8000862c:	f0 02 17 a0 	movle	r2,r8
80008630:	f9 b2 09 01 	movgt	r2,1
80008634:	18 02       	add	r2,r12
80008636:	36 70       	mov	r0,103
80008638:	40 9b       	lddsp	r11,sp[0x24]
8000863a:	58 0b       	cp.w	r11,0
8000863c:	e0 80 05 94 	breq	80009164 <_vfprintf_r+0x1658>
80008640:	32 d8       	mov	r8,45
80008642:	fb 68 06 bb 	st.b	sp[1723],r8
80008646:	e0 8f 05 93 	bral	8000916c <_vfprintf_r+0x1660>
8000864a:	50 a7       	stdsp	sp[0x28],r7
8000864c:	04 94       	mov	r4,r2
8000864e:	0c 97       	mov	r7,r6
80008650:	02 92       	mov	r2,r1
80008652:	06 96       	mov	r6,r3
80008654:	40 41       	lddsp	r1,sp[0x10]
80008656:	40 93       	lddsp	r3,sp[0x24]
80008658:	0e 99       	mov	r9,r7
8000865a:	ed b5 00 05 	bld	r5,0x5
8000865e:	c4 81       	brne	800086ee <_vfprintf_r+0xbe2>
80008660:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008664:	40 3e       	lddsp	lr,sp[0xc]
80008666:	58 0e       	cp.w	lr,0
80008668:	c1 d0       	breq	800086a2 <_vfprintf_r+0xb96>
8000866a:	10 36       	cp.w	r6,r8
8000866c:	c0 64       	brge	80008678 <_vfprintf_r+0xb6c>
8000866e:	fa cc f9 44 	sub	r12,sp,-1724
80008672:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008676:	c1 d8       	rjmp	800086b0 <_vfprintf_r+0xba4>
80008678:	fa c8 f9 50 	sub	r8,sp,-1712
8000867c:	1a d8       	st.w	--sp,r8
8000867e:	fa c8 fa b8 	sub	r8,sp,-1352
80008682:	04 9a       	mov	r10,r2
80008684:	1a d8       	st.w	--sp,r8
80008686:	fa c8 fb b4 	sub	r8,sp,-1100
8000868a:	0c 9b       	mov	r11,r6
8000868c:	1a d8       	st.w	--sp,r8
8000868e:	08 9c       	mov	r12,r4
80008690:	fa c8 f9 40 	sub	r8,sp,-1728
80008694:	fa c9 ff b4 	sub	r9,sp,-76
80008698:	fe b0 f8 a2 	rcall	800077dc <get_arg>
8000869c:	2f dd       	sub	sp,-12
8000869e:	78 0a       	ld.w	r10,r12[0x0]
800086a0:	c2 08       	rjmp	800086e0 <_vfprintf_r+0xbd4>
800086a2:	2f f7       	sub	r7,-1
800086a4:	10 39       	cp.w	r9,r8
800086a6:	c0 84       	brge	800086b6 <_vfprintf_r+0xbaa>
800086a8:	fa cb f9 44 	sub	r11,sp,-1724
800086ac:	f6 06 00 36 	add	r6,r11,r6<<0x3
800086b0:	ec fa fd 88 	ld.w	r10,r6[-632]
800086b4:	c1 68       	rjmp	800086e0 <_vfprintf_r+0xbd4>
800086b6:	41 09       	lddsp	r9,sp[0x40]
800086b8:	59 f8       	cp.w	r8,31
800086ba:	e0 89 00 10 	brgt	800086da <_vfprintf_r+0xbce>
800086be:	f2 ca ff fc 	sub	r10,r9,-4
800086c2:	51 0a       	stdsp	sp[0x40],r10
800086c4:	fa c6 f9 44 	sub	r6,sp,-1724
800086c8:	72 0a       	ld.w	r10,r9[0x0]
800086ca:	ec 08 00 39 	add	r9,r6,r8<<0x3
800086ce:	f3 4a fd 88 	st.w	r9[-632],r10
800086d2:	2f f8       	sub	r8,-1
800086d4:	fb 48 06 b4 	st.w	sp[1716],r8
800086d8:	c0 48       	rjmp	800086e0 <_vfprintf_r+0xbd4>
800086da:	72 0a       	ld.w	r10,r9[0x0]
800086dc:	2f c9       	sub	r9,-4
800086de:	51 09       	stdsp	sp[0x40],r9
800086e0:	40 be       	lddsp	lr,sp[0x2c]
800086e2:	1c 98       	mov	r8,lr
800086e4:	95 1e       	st.w	r10[0x4],lr
800086e6:	bf 58       	asr	r8,0x1f
800086e8:	95 08       	st.w	r10[0x0],r8
800086ea:	fe 9f fa 9f 	bral	80007c28 <_vfprintf_r+0x11c>
800086ee:	ed b5 00 04 	bld	r5,0x4
800086f2:	c4 80       	breq	80008782 <_vfprintf_r+0xc76>
800086f4:	e2 15 00 40 	andl	r5,0x40,COH
800086f8:	c4 50       	breq	80008782 <_vfprintf_r+0xc76>
800086fa:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086fe:	40 3c       	lddsp	r12,sp[0xc]
80008700:	58 0c       	cp.w	r12,0
80008702:	c1 d0       	breq	8000873c <_vfprintf_r+0xc30>
80008704:	10 36       	cp.w	r6,r8
80008706:	c0 64       	brge	80008712 <_vfprintf_r+0xc06>
80008708:	fa cb f9 44 	sub	r11,sp,-1724
8000870c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008710:	c1 d8       	rjmp	8000874a <_vfprintf_r+0xc3e>
80008712:	fa c8 f9 50 	sub	r8,sp,-1712
80008716:	1a d8       	st.w	--sp,r8
80008718:	fa c8 fa b8 	sub	r8,sp,-1352
8000871c:	04 9a       	mov	r10,r2
8000871e:	1a d8       	st.w	--sp,r8
80008720:	fa c8 fb b4 	sub	r8,sp,-1100
80008724:	0c 9b       	mov	r11,r6
80008726:	1a d8       	st.w	--sp,r8
80008728:	08 9c       	mov	r12,r4
8000872a:	fa c8 f9 40 	sub	r8,sp,-1728
8000872e:	fa c9 ff b4 	sub	r9,sp,-76
80008732:	fe b0 f8 55 	rcall	800077dc <get_arg>
80008736:	2f dd       	sub	sp,-12
80008738:	78 0a       	ld.w	r10,r12[0x0]
8000873a:	c2 08       	rjmp	8000877a <_vfprintf_r+0xc6e>
8000873c:	2f f7       	sub	r7,-1
8000873e:	10 39       	cp.w	r9,r8
80008740:	c0 84       	brge	80008750 <_vfprintf_r+0xc44>
80008742:	fa ca f9 44 	sub	r10,sp,-1724
80008746:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000874a:	ec fa fd 88 	ld.w	r10,r6[-632]
8000874e:	c1 68       	rjmp	8000877a <_vfprintf_r+0xc6e>
80008750:	41 09       	lddsp	r9,sp[0x40]
80008752:	59 f8       	cp.w	r8,31
80008754:	e0 89 00 10 	brgt	80008774 <_vfprintf_r+0xc68>
80008758:	f2 ca ff fc 	sub	r10,r9,-4
8000875c:	51 0a       	stdsp	sp[0x40],r10
8000875e:	fa c6 f9 44 	sub	r6,sp,-1724
80008762:	72 0a       	ld.w	r10,r9[0x0]
80008764:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008768:	f3 4a fd 88 	st.w	r9[-632],r10
8000876c:	2f f8       	sub	r8,-1
8000876e:	fb 48 06 b4 	st.w	sp[1716],r8
80008772:	c0 48       	rjmp	8000877a <_vfprintf_r+0xc6e>
80008774:	72 0a       	ld.w	r10,r9[0x0]
80008776:	2f c9       	sub	r9,-4
80008778:	51 09       	stdsp	sp[0x40],r9
8000877a:	40 be       	lddsp	lr,sp[0x2c]
8000877c:	b4 0e       	st.h	r10[0x0],lr
8000877e:	fe 9f fa 55 	bral	80007c28 <_vfprintf_r+0x11c>
80008782:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008786:	40 3c       	lddsp	r12,sp[0xc]
80008788:	58 0c       	cp.w	r12,0
8000878a:	c1 d0       	breq	800087c4 <_vfprintf_r+0xcb8>
8000878c:	10 36       	cp.w	r6,r8
8000878e:	c0 64       	brge	8000879a <_vfprintf_r+0xc8e>
80008790:	fa cb f9 44 	sub	r11,sp,-1724
80008794:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008798:	c1 d8       	rjmp	800087d2 <_vfprintf_r+0xcc6>
8000879a:	fa c8 f9 50 	sub	r8,sp,-1712
8000879e:	1a d8       	st.w	--sp,r8
800087a0:	fa c8 fa b8 	sub	r8,sp,-1352
800087a4:	04 9a       	mov	r10,r2
800087a6:	1a d8       	st.w	--sp,r8
800087a8:	fa c8 fb b4 	sub	r8,sp,-1100
800087ac:	0c 9b       	mov	r11,r6
800087ae:	1a d8       	st.w	--sp,r8
800087b0:	08 9c       	mov	r12,r4
800087b2:	fa c8 f9 40 	sub	r8,sp,-1728
800087b6:	fa c9 ff b4 	sub	r9,sp,-76
800087ba:	fe b0 f8 11 	rcall	800077dc <get_arg>
800087be:	2f dd       	sub	sp,-12
800087c0:	78 0a       	ld.w	r10,r12[0x0]
800087c2:	c2 08       	rjmp	80008802 <_vfprintf_r+0xcf6>
800087c4:	2f f7       	sub	r7,-1
800087c6:	10 39       	cp.w	r9,r8
800087c8:	c0 84       	brge	800087d8 <_vfprintf_r+0xccc>
800087ca:	fa ca f9 44 	sub	r10,sp,-1724
800087ce:	f4 06 00 36 	add	r6,r10,r6<<0x3
800087d2:	ec fa fd 88 	ld.w	r10,r6[-632]
800087d6:	c1 68       	rjmp	80008802 <_vfprintf_r+0xcf6>
800087d8:	41 09       	lddsp	r9,sp[0x40]
800087da:	59 f8       	cp.w	r8,31
800087dc:	e0 89 00 10 	brgt	800087fc <_vfprintf_r+0xcf0>
800087e0:	f2 ca ff fc 	sub	r10,r9,-4
800087e4:	51 0a       	stdsp	sp[0x40],r10
800087e6:	fa c6 f9 44 	sub	r6,sp,-1724
800087ea:	72 0a       	ld.w	r10,r9[0x0]
800087ec:	ec 08 00 39 	add	r9,r6,r8<<0x3
800087f0:	f3 4a fd 88 	st.w	r9[-632],r10
800087f4:	2f f8       	sub	r8,-1
800087f6:	fb 48 06 b4 	st.w	sp[1716],r8
800087fa:	c0 48       	rjmp	80008802 <_vfprintf_r+0xcf6>
800087fc:	72 0a       	ld.w	r10,r9[0x0]
800087fe:	2f c9       	sub	r9,-4
80008800:	51 09       	stdsp	sp[0x40],r9
80008802:	40 be       	lddsp	lr,sp[0x2c]
80008804:	95 0e       	st.w	r10[0x0],lr
80008806:	fe 9f fa 11 	bral	80007c28 <_vfprintf_r+0x11c>
8000880a:	50 a7       	stdsp	sp[0x28],r7
8000880c:	50 80       	stdsp	sp[0x20],r0
8000880e:	0c 97       	mov	r7,r6
80008810:	04 94       	mov	r4,r2
80008812:	06 96       	mov	r6,r3
80008814:	02 92       	mov	r2,r1
80008816:	40 93       	lddsp	r3,sp[0x24]
80008818:	10 90       	mov	r0,r8
8000881a:	40 41       	lddsp	r1,sp[0x10]
8000881c:	a5 a5       	sbr	r5,0x4
8000881e:	c0 a8       	rjmp	80008832 <_vfprintf_r+0xd26>
80008820:	50 a7       	stdsp	sp[0x28],r7
80008822:	50 80       	stdsp	sp[0x20],r0
80008824:	0c 97       	mov	r7,r6
80008826:	04 94       	mov	r4,r2
80008828:	06 96       	mov	r6,r3
8000882a:	02 92       	mov	r2,r1
8000882c:	40 93       	lddsp	r3,sp[0x24]
8000882e:	10 90       	mov	r0,r8
80008830:	40 41       	lddsp	r1,sp[0x10]
80008832:	ed b5 00 05 	bld	r5,0x5
80008836:	c5 d1       	brne	800088f0 <_vfprintf_r+0xde4>
80008838:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000883c:	40 3c       	lddsp	r12,sp[0xc]
8000883e:	58 0c       	cp.w	r12,0
80008840:	c2 60       	breq	8000888c <_vfprintf_r+0xd80>
80008842:	10 36       	cp.w	r6,r8
80008844:	c0 a4       	brge	80008858 <_vfprintf_r+0xd4c>
80008846:	fa cb f9 44 	sub	r11,sp,-1724
8000884a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000884e:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008852:	fa e9 00 00 	st.d	sp[0],r8
80008856:	c1 88       	rjmp	80008886 <_vfprintf_r+0xd7a>
80008858:	fa c8 f9 50 	sub	r8,sp,-1712
8000885c:	1a d8       	st.w	--sp,r8
8000885e:	fa c8 fa b8 	sub	r8,sp,-1352
80008862:	04 9a       	mov	r10,r2
80008864:	1a d8       	st.w	--sp,r8
80008866:	0c 9b       	mov	r11,r6
80008868:	fa c8 fb b4 	sub	r8,sp,-1100
8000886c:	08 9c       	mov	r12,r4
8000886e:	1a d8       	st.w	--sp,r8
80008870:	fa c8 f9 40 	sub	r8,sp,-1728
80008874:	fa c9 ff b4 	sub	r9,sp,-76
80008878:	fe b0 f7 b2 	rcall	800077dc <get_arg>
8000887c:	2f dd       	sub	sp,-12
8000887e:	f8 ea 00 00 	ld.d	r10,r12[0]
80008882:	fa eb 00 00 	st.d	sp[0],r10
80008886:	30 08       	mov	r8,0
80008888:	e0 8f 03 de 	bral	80009044 <_vfprintf_r+0x1538>
8000888c:	ee ca ff ff 	sub	r10,r7,-1
80008890:	10 37       	cp.w	r7,r8
80008892:	c0 b4       	brge	800088a8 <_vfprintf_r+0xd9c>
80008894:	fa c9 f9 44 	sub	r9,sp,-1724
80008898:	14 97       	mov	r7,r10
8000889a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000889e:	ec ea fd 88 	ld.d	r10,r6[-632]
800088a2:	fa eb 00 00 	st.d	sp[0],r10
800088a6:	c1 88       	rjmp	800088d6 <_vfprintf_r+0xdca>
800088a8:	41 09       	lddsp	r9,sp[0x40]
800088aa:	59 f8       	cp.w	r8,31
800088ac:	e0 89 00 18 	brgt	800088dc <_vfprintf_r+0xdd0>
800088b0:	f2 e6 00 00 	ld.d	r6,r9[0]
800088b4:	f2 cb ff f8 	sub	r11,r9,-8
800088b8:	fa e7 00 00 	st.d	sp[0],r6
800088bc:	51 0b       	stdsp	sp[0x40],r11
800088be:	fa c6 f9 44 	sub	r6,sp,-1724
800088c2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800088c6:	fa e6 00 00 	ld.d	r6,sp[0]
800088ca:	f2 e7 fd 88 	st.d	r9[-632],r6
800088ce:	2f f8       	sub	r8,-1
800088d0:	14 97       	mov	r7,r10
800088d2:	fb 48 06 b4 	st.w	sp[1716],r8
800088d6:	40 38       	lddsp	r8,sp[0xc]
800088d8:	e0 8f 03 b6 	bral	80009044 <_vfprintf_r+0x1538>
800088dc:	f2 e6 00 00 	ld.d	r6,r9[0]
800088e0:	40 38       	lddsp	r8,sp[0xc]
800088e2:	fa e7 00 00 	st.d	sp[0],r6
800088e6:	2f 89       	sub	r9,-8
800088e8:	14 97       	mov	r7,r10
800088ea:	51 09       	stdsp	sp[0x40],r9
800088ec:	e0 8f 03 ac 	bral	80009044 <_vfprintf_r+0x1538>
800088f0:	ed b5 00 04 	bld	r5,0x4
800088f4:	c1 61       	brne	80008920 <_vfprintf_r+0xe14>
800088f6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800088fa:	40 3e       	lddsp	lr,sp[0xc]
800088fc:	58 0e       	cp.w	lr,0
800088fe:	c0 80       	breq	8000890e <_vfprintf_r+0xe02>
80008900:	10 36       	cp.w	r6,r8
80008902:	c6 74       	brge	800089d0 <_vfprintf_r+0xec4>
80008904:	fa cc f9 44 	sub	r12,sp,-1724
80008908:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000890c:	c8 08       	rjmp	80008a0c <_vfprintf_r+0xf00>
8000890e:	ee ca ff ff 	sub	r10,r7,-1
80008912:	10 37       	cp.w	r7,r8
80008914:	c7 f4       	brge	80008a12 <_vfprintf_r+0xf06>
80008916:	fa cb f9 44 	sub	r11,sp,-1724
8000891a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000891e:	c7 68       	rjmp	80008a0a <_vfprintf_r+0xefe>
80008920:	ed b5 00 06 	bld	r5,0x6
80008924:	c4 a1       	brne	800089b8 <_vfprintf_r+0xeac>
80008926:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000892a:	40 3c       	lddsp	r12,sp[0xc]
8000892c:	58 0c       	cp.w	r12,0
8000892e:	c1 d0       	breq	80008968 <_vfprintf_r+0xe5c>
80008930:	10 36       	cp.w	r6,r8
80008932:	c0 64       	brge	8000893e <_vfprintf_r+0xe32>
80008934:	fa cb f9 44 	sub	r11,sp,-1724
80008938:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000893c:	c1 f8       	rjmp	8000897a <_vfprintf_r+0xe6e>
8000893e:	fa c8 f9 50 	sub	r8,sp,-1712
80008942:	1a d8       	st.w	--sp,r8
80008944:	fa c8 fa b8 	sub	r8,sp,-1352
80008948:	1a d8       	st.w	--sp,r8
8000894a:	fa c8 fb b4 	sub	r8,sp,-1100
8000894e:	1a d8       	st.w	--sp,r8
80008950:	fa c8 f9 40 	sub	r8,sp,-1728
80008954:	fa c9 ff b4 	sub	r9,sp,-76
80008958:	04 9a       	mov	r10,r2
8000895a:	0c 9b       	mov	r11,r6
8000895c:	08 9c       	mov	r12,r4
8000895e:	fe b0 f7 3f 	rcall	800077dc <get_arg>
80008962:	2f dd       	sub	sp,-12
80008964:	98 18       	ld.sh	r8,r12[0x2]
80008966:	c2 68       	rjmp	800089b2 <_vfprintf_r+0xea6>
80008968:	ee ca ff ff 	sub	r10,r7,-1
8000896c:	10 37       	cp.w	r7,r8
8000896e:	c0 94       	brge	80008980 <_vfprintf_r+0xe74>
80008970:	fa c9 f9 44 	sub	r9,sp,-1724
80008974:	14 97       	mov	r7,r10
80008976:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000897a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000897e:	c1 a8       	rjmp	800089b2 <_vfprintf_r+0xea6>
80008980:	41 09       	lddsp	r9,sp[0x40]
80008982:	59 f8       	cp.w	r8,31
80008984:	e0 89 00 13 	brgt	800089aa <_vfprintf_r+0xe9e>
80008988:	f2 cb ff fc 	sub	r11,r9,-4
8000898c:	51 0b       	stdsp	sp[0x40],r11
8000898e:	72 09       	ld.w	r9,r9[0x0]
80008990:	fa c6 f9 44 	sub	r6,sp,-1724
80008994:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008998:	2f f8       	sub	r8,-1
8000899a:	f7 49 fd 88 	st.w	r11[-632],r9
8000899e:	fb 48 06 b4 	st.w	sp[1716],r8
800089a2:	14 97       	mov	r7,r10
800089a4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800089a8:	c0 58       	rjmp	800089b2 <_vfprintf_r+0xea6>
800089aa:	92 18       	ld.sh	r8,r9[0x2]
800089ac:	14 97       	mov	r7,r10
800089ae:	2f c9       	sub	r9,-4
800089b0:	51 09       	stdsp	sp[0x40],r9
800089b2:	5c 78       	castu.h	r8
800089b4:	50 18       	stdsp	sp[0x4],r8
800089b6:	c4 68       	rjmp	80008a42 <_vfprintf_r+0xf36>
800089b8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800089bc:	40 3c       	lddsp	r12,sp[0xc]
800089be:	58 0c       	cp.w	r12,0
800089c0:	c1 d0       	breq	800089fa <_vfprintf_r+0xeee>
800089c2:	10 36       	cp.w	r6,r8
800089c4:	c0 64       	brge	800089d0 <_vfprintf_r+0xec4>
800089c6:	fa cb f9 44 	sub	r11,sp,-1724
800089ca:	f6 06 00 36 	add	r6,r11,r6<<0x3
800089ce:	c1 f8       	rjmp	80008a0c <_vfprintf_r+0xf00>
800089d0:	fa c8 f9 50 	sub	r8,sp,-1712
800089d4:	1a d8       	st.w	--sp,r8
800089d6:	fa c8 fa b8 	sub	r8,sp,-1352
800089da:	0c 9b       	mov	r11,r6
800089dc:	1a d8       	st.w	--sp,r8
800089de:	fa c8 fb b4 	sub	r8,sp,-1100
800089e2:	04 9a       	mov	r10,r2
800089e4:	1a d8       	st.w	--sp,r8
800089e6:	08 9c       	mov	r12,r4
800089e8:	fa c8 f9 40 	sub	r8,sp,-1728
800089ec:	fa c9 ff b4 	sub	r9,sp,-76
800089f0:	fe b0 f6 f6 	rcall	800077dc <get_arg>
800089f4:	2f dd       	sub	sp,-12
800089f6:	78 0b       	ld.w	r11,r12[0x0]
800089f8:	c2 48       	rjmp	80008a40 <_vfprintf_r+0xf34>
800089fa:	ee ca ff ff 	sub	r10,r7,-1
800089fe:	10 37       	cp.w	r7,r8
80008a00:	c0 94       	brge	80008a12 <_vfprintf_r+0xf06>
80008a02:	fa c9 f9 44 	sub	r9,sp,-1724
80008a06:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008a0a:	14 97       	mov	r7,r10
80008a0c:	ec fb fd 88 	ld.w	r11,r6[-632]
80008a10:	c1 88       	rjmp	80008a40 <_vfprintf_r+0xf34>
80008a12:	41 09       	lddsp	r9,sp[0x40]
80008a14:	59 f8       	cp.w	r8,31
80008a16:	e0 89 00 11 	brgt	80008a38 <_vfprintf_r+0xf2c>
80008a1a:	f2 cb ff fc 	sub	r11,r9,-4
80008a1e:	51 0b       	stdsp	sp[0x40],r11
80008a20:	fa c6 f9 44 	sub	r6,sp,-1724
80008a24:	72 0b       	ld.w	r11,r9[0x0]
80008a26:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008a2a:	f3 4b fd 88 	st.w	r9[-632],r11
80008a2e:	2f f8       	sub	r8,-1
80008a30:	14 97       	mov	r7,r10
80008a32:	fb 48 06 b4 	st.w	sp[1716],r8
80008a36:	c0 58       	rjmp	80008a40 <_vfprintf_r+0xf34>
80008a38:	72 0b       	ld.w	r11,r9[0x0]
80008a3a:	14 97       	mov	r7,r10
80008a3c:	2f c9       	sub	r9,-4
80008a3e:	51 09       	stdsp	sp[0x40],r9
80008a40:	50 1b       	stdsp	sp[0x4],r11
80008a42:	30 0e       	mov	lr,0
80008a44:	50 0e       	stdsp	sp[0x0],lr
80008a46:	1c 98       	mov	r8,lr
80008a48:	e0 8f 02 fe 	bral	80009044 <_vfprintf_r+0x1538>
80008a4c:	50 a7       	stdsp	sp[0x28],r7
80008a4e:	50 80       	stdsp	sp[0x20],r0
80008a50:	0c 97       	mov	r7,r6
80008a52:	04 94       	mov	r4,r2
80008a54:	06 96       	mov	r6,r3
80008a56:	02 92       	mov	r2,r1
80008a58:	40 93       	lddsp	r3,sp[0x24]
80008a5a:	40 41       	lddsp	r1,sp[0x10]
80008a5c:	0e 99       	mov	r9,r7
80008a5e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a62:	40 3c       	lddsp	r12,sp[0xc]
80008a64:	58 0c       	cp.w	r12,0
80008a66:	c1 d0       	breq	80008aa0 <_vfprintf_r+0xf94>
80008a68:	10 36       	cp.w	r6,r8
80008a6a:	c0 64       	brge	80008a76 <_vfprintf_r+0xf6a>
80008a6c:	fa cb f9 44 	sub	r11,sp,-1724
80008a70:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a74:	c1 d8       	rjmp	80008aae <_vfprintf_r+0xfa2>
80008a76:	fa c8 f9 50 	sub	r8,sp,-1712
80008a7a:	1a d8       	st.w	--sp,r8
80008a7c:	fa c8 fa b8 	sub	r8,sp,-1352
80008a80:	1a d8       	st.w	--sp,r8
80008a82:	fa c8 fb b4 	sub	r8,sp,-1100
80008a86:	1a d8       	st.w	--sp,r8
80008a88:	fa c9 ff b4 	sub	r9,sp,-76
80008a8c:	fa c8 f9 40 	sub	r8,sp,-1728
80008a90:	04 9a       	mov	r10,r2
80008a92:	0c 9b       	mov	r11,r6
80008a94:	08 9c       	mov	r12,r4
80008a96:	fe b0 f6 a3 	rcall	800077dc <get_arg>
80008a9a:	2f dd       	sub	sp,-12
80008a9c:	78 09       	ld.w	r9,r12[0x0]
80008a9e:	c2 18       	rjmp	80008ae0 <_vfprintf_r+0xfd4>
80008aa0:	2f f7       	sub	r7,-1
80008aa2:	10 39       	cp.w	r9,r8
80008aa4:	c0 84       	brge	80008ab4 <_vfprintf_r+0xfa8>
80008aa6:	fa ca f9 44 	sub	r10,sp,-1724
80008aaa:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008aae:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008ab2:	c1 78       	rjmp	80008ae0 <_vfprintf_r+0xfd4>
80008ab4:	41 09       	lddsp	r9,sp[0x40]
80008ab6:	59 f8       	cp.w	r8,31
80008ab8:	e0 89 00 10 	brgt	80008ad8 <_vfprintf_r+0xfcc>
80008abc:	f2 ca ff fc 	sub	r10,r9,-4
80008ac0:	51 0a       	stdsp	sp[0x40],r10
80008ac2:	fa c6 f9 44 	sub	r6,sp,-1724
80008ac6:	72 09       	ld.w	r9,r9[0x0]
80008ac8:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008acc:	f5 49 fd 88 	st.w	r10[-632],r9
80008ad0:	2f f8       	sub	r8,-1
80008ad2:	fb 48 06 b4 	st.w	sp[1716],r8
80008ad6:	c0 58       	rjmp	80008ae0 <_vfprintf_r+0xfd4>
80008ad8:	f2 c8 ff fc 	sub	r8,r9,-4
80008adc:	51 08       	stdsp	sp[0x40],r8
80008ade:	72 09       	ld.w	r9,r9[0x0]
80008ae0:	33 08       	mov	r8,48
80008ae2:	fb 68 06 b8 	st.b	sp[1720],r8
80008ae6:	37 88       	mov	r8,120
80008ae8:	30 0e       	mov	lr,0
80008aea:	fb 68 06 b9 	st.b	sp[1721],r8
80008aee:	fe cc b2 76 	sub	r12,pc,-19850
80008af2:	50 19       	stdsp	sp[0x4],r9
80008af4:	a1 b5       	sbr	r5,0x1
80008af6:	50 0e       	stdsp	sp[0x0],lr
80008af8:	50 dc       	stdsp	sp[0x34],r12
80008afa:	30 28       	mov	r8,2
80008afc:	37 80       	mov	r0,120
80008afe:	e0 8f 02 a3 	bral	80009044 <_vfprintf_r+0x1538>
80008b02:	50 a7       	stdsp	sp[0x28],r7
80008b04:	50 80       	stdsp	sp[0x20],r0
80008b06:	10 90       	mov	r0,r8
80008b08:	30 08       	mov	r8,0
80008b0a:	fb 68 06 bb 	st.b	sp[1723],r8
80008b0e:	0c 97       	mov	r7,r6
80008b10:	04 94       	mov	r4,r2
80008b12:	06 96       	mov	r6,r3
80008b14:	02 92       	mov	r2,r1
80008b16:	40 93       	lddsp	r3,sp[0x24]
80008b18:	40 41       	lddsp	r1,sp[0x10]
80008b1a:	0e 99       	mov	r9,r7
80008b1c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b20:	40 3b       	lddsp	r11,sp[0xc]
80008b22:	58 0b       	cp.w	r11,0
80008b24:	c1 d0       	breq	80008b5e <_vfprintf_r+0x1052>
80008b26:	10 36       	cp.w	r6,r8
80008b28:	c0 64       	brge	80008b34 <_vfprintf_r+0x1028>
80008b2a:	fa ca f9 44 	sub	r10,sp,-1724
80008b2e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008b32:	c1 d8       	rjmp	80008b6c <_vfprintf_r+0x1060>
80008b34:	fa c8 f9 50 	sub	r8,sp,-1712
80008b38:	1a d8       	st.w	--sp,r8
80008b3a:	fa c8 fa b8 	sub	r8,sp,-1352
80008b3e:	1a d8       	st.w	--sp,r8
80008b40:	fa c8 fb b4 	sub	r8,sp,-1100
80008b44:	0c 9b       	mov	r11,r6
80008b46:	1a d8       	st.w	--sp,r8
80008b48:	04 9a       	mov	r10,r2
80008b4a:	fa c8 f9 40 	sub	r8,sp,-1728
80008b4e:	fa c9 ff b4 	sub	r9,sp,-76
80008b52:	08 9c       	mov	r12,r4
80008b54:	fe b0 f6 44 	rcall	800077dc <get_arg>
80008b58:	2f dd       	sub	sp,-12
80008b5a:	78 06       	ld.w	r6,r12[0x0]
80008b5c:	c2 08       	rjmp	80008b9c <_vfprintf_r+0x1090>
80008b5e:	2f f7       	sub	r7,-1
80008b60:	10 39       	cp.w	r9,r8
80008b62:	c0 84       	brge	80008b72 <_vfprintf_r+0x1066>
80008b64:	fa c9 f9 44 	sub	r9,sp,-1724
80008b68:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008b6c:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008b70:	c1 68       	rjmp	80008b9c <_vfprintf_r+0x1090>
80008b72:	41 09       	lddsp	r9,sp[0x40]
80008b74:	59 f8       	cp.w	r8,31
80008b76:	e0 89 00 10 	brgt	80008b96 <_vfprintf_r+0x108a>
80008b7a:	f2 ca ff fc 	sub	r10,r9,-4
80008b7e:	51 0a       	stdsp	sp[0x40],r10
80008b80:	72 06       	ld.w	r6,r9[0x0]
80008b82:	fa ce f9 44 	sub	lr,sp,-1724
80008b86:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008b8a:	f3 46 fd 88 	st.w	r9[-632],r6
80008b8e:	2f f8       	sub	r8,-1
80008b90:	fb 48 06 b4 	st.w	sp[1716],r8
80008b94:	c0 48       	rjmp	80008b9c <_vfprintf_r+0x1090>
80008b96:	72 06       	ld.w	r6,r9[0x0]
80008b98:	2f c9       	sub	r9,-4
80008b9a:	51 09       	stdsp	sp[0x40],r9
80008b9c:	40 2c       	lddsp	r12,sp[0x8]
80008b9e:	58 0c       	cp.w	r12,0
80008ba0:	c1 05       	brlt	80008bc0 <_vfprintf_r+0x10b4>
80008ba2:	18 9a       	mov	r10,r12
80008ba4:	30 0b       	mov	r11,0
80008ba6:	0c 9c       	mov	r12,r6
80008ba8:	e0 a0 12 38 	rcall	8000b018 <memchr>
80008bac:	e0 80 02 df 	breq	8000916a <_vfprintf_r+0x165e>
80008bb0:	f8 06 01 02 	sub	r2,r12,r6
80008bb4:	40 2b       	lddsp	r11,sp[0x8]
80008bb6:	16 32       	cp.w	r2,r11
80008bb8:	e0 89 02 d9 	brgt	8000916a <_vfprintf_r+0x165e>
80008bbc:	e0 8f 02 d4 	bral	80009164 <_vfprintf_r+0x1658>
80008bc0:	30 0a       	mov	r10,0
80008bc2:	0c 9c       	mov	r12,r6
80008bc4:	50 2a       	stdsp	sp[0x8],r10
80008bc6:	e0 a0 15 99 	rcall	8000b6f8 <strlen>
80008bca:	18 92       	mov	r2,r12
80008bcc:	e0 8f 02 d2 	bral	80009170 <_vfprintf_r+0x1664>
80008bd0:	50 a7       	stdsp	sp[0x28],r7
80008bd2:	50 80       	stdsp	sp[0x20],r0
80008bd4:	0c 97       	mov	r7,r6
80008bd6:	04 94       	mov	r4,r2
80008bd8:	06 96       	mov	r6,r3
80008bda:	02 92       	mov	r2,r1
80008bdc:	40 93       	lddsp	r3,sp[0x24]
80008bde:	10 90       	mov	r0,r8
80008be0:	40 41       	lddsp	r1,sp[0x10]
80008be2:	a5 a5       	sbr	r5,0x4
80008be4:	c0 a8       	rjmp	80008bf8 <_vfprintf_r+0x10ec>
80008be6:	50 a7       	stdsp	sp[0x28],r7
80008be8:	50 80       	stdsp	sp[0x20],r0
80008bea:	0c 97       	mov	r7,r6
80008bec:	04 94       	mov	r4,r2
80008bee:	06 96       	mov	r6,r3
80008bf0:	02 92       	mov	r2,r1
80008bf2:	40 93       	lddsp	r3,sp[0x24]
80008bf4:	10 90       	mov	r0,r8
80008bf6:	40 41       	lddsp	r1,sp[0x10]
80008bf8:	ed b5 00 05 	bld	r5,0x5
80008bfc:	c5 61       	brne	80008ca8 <_vfprintf_r+0x119c>
80008bfe:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c02:	40 39       	lddsp	r9,sp[0xc]
80008c04:	58 09       	cp.w	r9,0
80008c06:	c2 10       	breq	80008c48 <_vfprintf_r+0x113c>
80008c08:	10 36       	cp.w	r6,r8
80008c0a:	c0 74       	brge	80008c18 <_vfprintf_r+0x110c>
80008c0c:	fa c8 f9 44 	sub	r8,sp,-1724
80008c10:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008c14:	c2 38       	rjmp	80008c5a <_vfprintf_r+0x114e>
80008c16:	d7 03       	nop
80008c18:	fa c8 f9 50 	sub	r8,sp,-1712
80008c1c:	1a d8       	st.w	--sp,r8
80008c1e:	fa c8 fa b8 	sub	r8,sp,-1352
80008c22:	1a d8       	st.w	--sp,r8
80008c24:	fa c8 fb b4 	sub	r8,sp,-1100
80008c28:	1a d8       	st.w	--sp,r8
80008c2a:	fa c8 f9 40 	sub	r8,sp,-1728
80008c2e:	fa c9 ff b4 	sub	r9,sp,-76
80008c32:	04 9a       	mov	r10,r2
80008c34:	0c 9b       	mov	r11,r6
80008c36:	08 9c       	mov	r12,r4
80008c38:	fe b0 f5 d2 	rcall	800077dc <get_arg>
80008c3c:	2f dd       	sub	sp,-12
80008c3e:	f8 e8 00 00 	ld.d	r8,r12[0]
80008c42:	fa e9 00 00 	st.d	sp[0],r8
80008c46:	c2 e8       	rjmp	80008ca2 <_vfprintf_r+0x1196>
80008c48:	ee ca ff ff 	sub	r10,r7,-1
80008c4c:	10 37       	cp.w	r7,r8
80008c4e:	c0 b4       	brge	80008c64 <_vfprintf_r+0x1158>
80008c50:	fa c8 f9 44 	sub	r8,sp,-1724
80008c54:	14 97       	mov	r7,r10
80008c56:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008c5a:	ec ea fd 88 	ld.d	r10,r6[-632]
80008c5e:	fa eb 00 00 	st.d	sp[0],r10
80008c62:	c2 08       	rjmp	80008ca2 <_vfprintf_r+0x1196>
80008c64:	41 09       	lddsp	r9,sp[0x40]
80008c66:	59 f8       	cp.w	r8,31
80008c68:	e0 89 00 16 	brgt	80008c94 <_vfprintf_r+0x1188>
80008c6c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008c70:	f2 cb ff f8 	sub	r11,r9,-8
80008c74:	fa e7 00 00 	st.d	sp[0],r6
80008c78:	51 0b       	stdsp	sp[0x40],r11
80008c7a:	fa c6 f9 44 	sub	r6,sp,-1724
80008c7e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008c82:	fa e6 00 00 	ld.d	r6,sp[0]
80008c86:	f2 e7 fd 88 	st.d	r9[-632],r6
80008c8a:	2f f8       	sub	r8,-1
80008c8c:	14 97       	mov	r7,r10
80008c8e:	fb 48 06 b4 	st.w	sp[1716],r8
80008c92:	c0 88       	rjmp	80008ca2 <_vfprintf_r+0x1196>
80008c94:	f2 e6 00 00 	ld.d	r6,r9[0]
80008c98:	2f 89       	sub	r9,-8
80008c9a:	fa e7 00 00 	st.d	sp[0],r6
80008c9e:	51 09       	stdsp	sp[0x40],r9
80008ca0:	14 97       	mov	r7,r10
80008ca2:	30 18       	mov	r8,1
80008ca4:	e0 8f 01 d0 	bral	80009044 <_vfprintf_r+0x1538>
80008ca8:	ed b5 00 04 	bld	r5,0x4
80008cac:	c1 61       	brne	80008cd8 <_vfprintf_r+0x11cc>
80008cae:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008cb2:	40 3e       	lddsp	lr,sp[0xc]
80008cb4:	58 0e       	cp.w	lr,0
80008cb6:	c0 80       	breq	80008cc6 <_vfprintf_r+0x11ba>
80008cb8:	10 36       	cp.w	r6,r8
80008cba:	c6 74       	brge	80008d88 <_vfprintf_r+0x127c>
80008cbc:	fa cc f9 44 	sub	r12,sp,-1724
80008cc0:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008cc4:	c8 08       	rjmp	80008dc4 <_vfprintf_r+0x12b8>
80008cc6:	ee ca ff ff 	sub	r10,r7,-1
80008cca:	10 37       	cp.w	r7,r8
80008ccc:	c7 f4       	brge	80008dca <_vfprintf_r+0x12be>
80008cce:	fa cb f9 44 	sub	r11,sp,-1724
80008cd2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008cd6:	c7 68       	rjmp	80008dc2 <_vfprintf_r+0x12b6>
80008cd8:	ed b5 00 06 	bld	r5,0x6
80008cdc:	c4 a1       	brne	80008d70 <_vfprintf_r+0x1264>
80008cde:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ce2:	40 3c       	lddsp	r12,sp[0xc]
80008ce4:	58 0c       	cp.w	r12,0
80008ce6:	c1 d0       	breq	80008d20 <_vfprintf_r+0x1214>
80008ce8:	10 36       	cp.w	r6,r8
80008cea:	c0 64       	brge	80008cf6 <_vfprintf_r+0x11ea>
80008cec:	fa cb f9 44 	sub	r11,sp,-1724
80008cf0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008cf4:	c1 f8       	rjmp	80008d32 <_vfprintf_r+0x1226>
80008cf6:	fa c8 f9 50 	sub	r8,sp,-1712
80008cfa:	1a d8       	st.w	--sp,r8
80008cfc:	fa c8 fa b8 	sub	r8,sp,-1352
80008d00:	1a d8       	st.w	--sp,r8
80008d02:	fa c8 fb b4 	sub	r8,sp,-1100
80008d06:	1a d8       	st.w	--sp,r8
80008d08:	fa c8 f9 40 	sub	r8,sp,-1728
80008d0c:	fa c9 ff b4 	sub	r9,sp,-76
80008d10:	04 9a       	mov	r10,r2
80008d12:	0c 9b       	mov	r11,r6
80008d14:	08 9c       	mov	r12,r4
80008d16:	fe b0 f5 63 	rcall	800077dc <get_arg>
80008d1a:	2f dd       	sub	sp,-12
80008d1c:	98 18       	ld.sh	r8,r12[0x2]
80008d1e:	c2 68       	rjmp	80008d6a <_vfprintf_r+0x125e>
80008d20:	ee ca ff ff 	sub	r10,r7,-1
80008d24:	10 37       	cp.w	r7,r8
80008d26:	c0 94       	brge	80008d38 <_vfprintf_r+0x122c>
80008d28:	fa c9 f9 44 	sub	r9,sp,-1724
80008d2c:	14 97       	mov	r7,r10
80008d2e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008d32:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008d36:	c1 a8       	rjmp	80008d6a <_vfprintf_r+0x125e>
80008d38:	41 09       	lddsp	r9,sp[0x40]
80008d3a:	59 f8       	cp.w	r8,31
80008d3c:	e0 89 00 13 	brgt	80008d62 <_vfprintf_r+0x1256>
80008d40:	f2 cb ff fc 	sub	r11,r9,-4
80008d44:	51 0b       	stdsp	sp[0x40],r11
80008d46:	72 09       	ld.w	r9,r9[0x0]
80008d48:	fa c6 f9 44 	sub	r6,sp,-1724
80008d4c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008d50:	2f f8       	sub	r8,-1
80008d52:	f7 49 fd 88 	st.w	r11[-632],r9
80008d56:	fb 48 06 b4 	st.w	sp[1716],r8
80008d5a:	14 97       	mov	r7,r10
80008d5c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008d60:	c0 58       	rjmp	80008d6a <_vfprintf_r+0x125e>
80008d62:	92 18       	ld.sh	r8,r9[0x2]
80008d64:	14 97       	mov	r7,r10
80008d66:	2f c9       	sub	r9,-4
80008d68:	51 09       	stdsp	sp[0x40],r9
80008d6a:	5c 78       	castu.h	r8
80008d6c:	50 18       	stdsp	sp[0x4],r8
80008d6e:	c4 68       	rjmp	80008dfa <_vfprintf_r+0x12ee>
80008d70:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d74:	40 3c       	lddsp	r12,sp[0xc]
80008d76:	58 0c       	cp.w	r12,0
80008d78:	c1 d0       	breq	80008db2 <_vfprintf_r+0x12a6>
80008d7a:	10 36       	cp.w	r6,r8
80008d7c:	c0 64       	brge	80008d88 <_vfprintf_r+0x127c>
80008d7e:	fa cb f9 44 	sub	r11,sp,-1724
80008d82:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d86:	c1 f8       	rjmp	80008dc4 <_vfprintf_r+0x12b8>
80008d88:	fa c8 f9 50 	sub	r8,sp,-1712
80008d8c:	1a d8       	st.w	--sp,r8
80008d8e:	fa c8 fa b8 	sub	r8,sp,-1352
80008d92:	0c 9b       	mov	r11,r6
80008d94:	1a d8       	st.w	--sp,r8
80008d96:	fa c8 fb b4 	sub	r8,sp,-1100
80008d9a:	04 9a       	mov	r10,r2
80008d9c:	1a d8       	st.w	--sp,r8
80008d9e:	08 9c       	mov	r12,r4
80008da0:	fa c8 f9 40 	sub	r8,sp,-1728
80008da4:	fa c9 ff b4 	sub	r9,sp,-76
80008da8:	fe b0 f5 1a 	rcall	800077dc <get_arg>
80008dac:	2f dd       	sub	sp,-12
80008dae:	78 0b       	ld.w	r11,r12[0x0]
80008db0:	c2 48       	rjmp	80008df8 <_vfprintf_r+0x12ec>
80008db2:	ee ca ff ff 	sub	r10,r7,-1
80008db6:	10 37       	cp.w	r7,r8
80008db8:	c0 94       	brge	80008dca <_vfprintf_r+0x12be>
80008dba:	fa c9 f9 44 	sub	r9,sp,-1724
80008dbe:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008dc2:	14 97       	mov	r7,r10
80008dc4:	ec fb fd 88 	ld.w	r11,r6[-632]
80008dc8:	c1 88       	rjmp	80008df8 <_vfprintf_r+0x12ec>
80008dca:	41 09       	lddsp	r9,sp[0x40]
80008dcc:	59 f8       	cp.w	r8,31
80008dce:	e0 89 00 11 	brgt	80008df0 <_vfprintf_r+0x12e4>
80008dd2:	f2 cb ff fc 	sub	r11,r9,-4
80008dd6:	51 0b       	stdsp	sp[0x40],r11
80008dd8:	fa c6 f9 44 	sub	r6,sp,-1724
80008ddc:	72 0b       	ld.w	r11,r9[0x0]
80008dde:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008de2:	f3 4b fd 88 	st.w	r9[-632],r11
80008de6:	2f f8       	sub	r8,-1
80008de8:	14 97       	mov	r7,r10
80008dea:	fb 48 06 b4 	st.w	sp[1716],r8
80008dee:	c0 58       	rjmp	80008df8 <_vfprintf_r+0x12ec>
80008df0:	72 0b       	ld.w	r11,r9[0x0]
80008df2:	14 97       	mov	r7,r10
80008df4:	2f c9       	sub	r9,-4
80008df6:	51 09       	stdsp	sp[0x40],r9
80008df8:	50 1b       	stdsp	sp[0x4],r11
80008dfa:	30 0e       	mov	lr,0
80008dfc:	30 18       	mov	r8,1
80008dfe:	50 0e       	stdsp	sp[0x0],lr
80008e00:	c2 29       	rjmp	80009044 <_vfprintf_r+0x1538>
80008e02:	50 a7       	stdsp	sp[0x28],r7
80008e04:	50 80       	stdsp	sp[0x20],r0
80008e06:	0c 97       	mov	r7,r6
80008e08:	04 94       	mov	r4,r2
80008e0a:	06 96       	mov	r6,r3
80008e0c:	02 92       	mov	r2,r1
80008e0e:	fe cc b5 96 	sub	r12,pc,-19050
80008e12:	40 93       	lddsp	r3,sp[0x24]
80008e14:	10 90       	mov	r0,r8
80008e16:	40 41       	lddsp	r1,sp[0x10]
80008e18:	50 dc       	stdsp	sp[0x34],r12
80008e1a:	ed b5 00 05 	bld	r5,0x5
80008e1e:	c5 51       	brne	80008ec8 <_vfprintf_r+0x13bc>
80008e20:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e24:	40 3b       	lddsp	r11,sp[0xc]
80008e26:	58 0b       	cp.w	r11,0
80008e28:	c2 20       	breq	80008e6c <_vfprintf_r+0x1360>
80008e2a:	10 36       	cp.w	r6,r8
80008e2c:	c0 a4       	brge	80008e40 <_vfprintf_r+0x1334>
80008e2e:	fa ca f9 44 	sub	r10,sp,-1724
80008e32:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008e36:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008e3a:	fa e9 00 00 	st.d	sp[0],r8
80008e3e:	cf 28       	rjmp	80009022 <_vfprintf_r+0x1516>
80008e40:	fa c8 f9 50 	sub	r8,sp,-1712
80008e44:	1a d8       	st.w	--sp,r8
80008e46:	fa c8 fa b8 	sub	r8,sp,-1352
80008e4a:	04 9a       	mov	r10,r2
80008e4c:	1a d8       	st.w	--sp,r8
80008e4e:	0c 9b       	mov	r11,r6
80008e50:	fa c8 fb b4 	sub	r8,sp,-1100
80008e54:	08 9c       	mov	r12,r4
80008e56:	1a d8       	st.w	--sp,r8
80008e58:	fa c8 f9 40 	sub	r8,sp,-1728
80008e5c:	fa c9 ff b4 	sub	r9,sp,-76
80008e60:	fe b0 f4 be 	rcall	800077dc <get_arg>
80008e64:	2f dd       	sub	sp,-12
80008e66:	f8 ea 00 00 	ld.d	r10,r12[0]
80008e6a:	c0 c8       	rjmp	80008e82 <_vfprintf_r+0x1376>
80008e6c:	ee ca ff ff 	sub	r10,r7,-1
80008e70:	10 37       	cp.w	r7,r8
80008e72:	c0 b4       	brge	80008e88 <_vfprintf_r+0x137c>
80008e74:	fa c9 f9 44 	sub	r9,sp,-1724
80008e78:	14 97       	mov	r7,r10
80008e7a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008e7e:	ec ea fd 88 	ld.d	r10,r6[-632]
80008e82:	fa eb 00 00 	st.d	sp[0],r10
80008e86:	cc e8       	rjmp	80009022 <_vfprintf_r+0x1516>
80008e88:	41 09       	lddsp	r9,sp[0x40]
80008e8a:	59 f8       	cp.w	r8,31
80008e8c:	e0 89 00 16 	brgt	80008eb8 <_vfprintf_r+0x13ac>
80008e90:	f2 e6 00 00 	ld.d	r6,r9[0]
80008e94:	f2 cb ff f8 	sub	r11,r9,-8
80008e98:	fa e7 00 00 	st.d	sp[0],r6
80008e9c:	51 0b       	stdsp	sp[0x40],r11
80008e9e:	fa c6 f9 44 	sub	r6,sp,-1724
80008ea2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008ea6:	fa e6 00 00 	ld.d	r6,sp[0]
80008eaa:	f2 e7 fd 88 	st.d	r9[-632],r6
80008eae:	2f f8       	sub	r8,-1
80008eb0:	14 97       	mov	r7,r10
80008eb2:	fb 48 06 b4 	st.w	sp[1716],r8
80008eb6:	cb 68       	rjmp	80009022 <_vfprintf_r+0x1516>
80008eb8:	f2 e6 00 00 	ld.d	r6,r9[0]
80008ebc:	2f 89       	sub	r9,-8
80008ebe:	fa e7 00 00 	st.d	sp[0],r6
80008ec2:	51 09       	stdsp	sp[0x40],r9
80008ec4:	14 97       	mov	r7,r10
80008ec6:	ca e8       	rjmp	80009022 <_vfprintf_r+0x1516>
80008ec8:	ed b5 00 04 	bld	r5,0x4
80008ecc:	c1 71       	brne	80008efa <_vfprintf_r+0x13ee>
80008ece:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ed2:	40 3e       	lddsp	lr,sp[0xc]
80008ed4:	58 0e       	cp.w	lr,0
80008ed6:	c0 80       	breq	80008ee6 <_vfprintf_r+0x13da>
80008ed8:	10 36       	cp.w	r6,r8
80008eda:	c6 94       	brge	80008fac <_vfprintf_r+0x14a0>
80008edc:	fa cc f9 44 	sub	r12,sp,-1724
80008ee0:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008ee4:	c8 28       	rjmp	80008fe8 <_vfprintf_r+0x14dc>
80008ee6:	ee ca ff ff 	sub	r10,r7,-1
80008eea:	10 37       	cp.w	r7,r8
80008eec:	e0 84 00 81 	brge	80008fee <_vfprintf_r+0x14e2>
80008ef0:	fa cb f9 44 	sub	r11,sp,-1724
80008ef4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008ef8:	c7 78       	rjmp	80008fe6 <_vfprintf_r+0x14da>
80008efa:	ed b5 00 06 	bld	r5,0x6
80008efe:	c4 b1       	brne	80008f94 <_vfprintf_r+0x1488>
80008f00:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f04:	40 3c       	lddsp	r12,sp[0xc]
80008f06:	58 0c       	cp.w	r12,0
80008f08:	c1 d0       	breq	80008f42 <_vfprintf_r+0x1436>
80008f0a:	10 36       	cp.w	r6,r8
80008f0c:	c0 64       	brge	80008f18 <_vfprintf_r+0x140c>
80008f0e:	fa cb f9 44 	sub	r11,sp,-1724
80008f12:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f16:	c1 f8       	rjmp	80008f54 <_vfprintf_r+0x1448>
80008f18:	fa c8 f9 50 	sub	r8,sp,-1712
80008f1c:	1a d8       	st.w	--sp,r8
80008f1e:	fa c8 fa b8 	sub	r8,sp,-1352
80008f22:	1a d8       	st.w	--sp,r8
80008f24:	fa c8 fb b4 	sub	r8,sp,-1100
80008f28:	1a d8       	st.w	--sp,r8
80008f2a:	fa c8 f9 40 	sub	r8,sp,-1728
80008f2e:	fa c9 ff b4 	sub	r9,sp,-76
80008f32:	04 9a       	mov	r10,r2
80008f34:	0c 9b       	mov	r11,r6
80008f36:	08 9c       	mov	r12,r4
80008f38:	fe b0 f4 52 	rcall	800077dc <get_arg>
80008f3c:	2f dd       	sub	sp,-12
80008f3e:	98 18       	ld.sh	r8,r12[0x2]
80008f40:	c2 78       	rjmp	80008f8e <_vfprintf_r+0x1482>
80008f42:	ee ca ff ff 	sub	r10,r7,-1
80008f46:	10 37       	cp.w	r7,r8
80008f48:	c0 a4       	brge	80008f5c <_vfprintf_r+0x1450>
80008f4a:	fa c9 f9 44 	sub	r9,sp,-1724
80008f4e:	14 97       	mov	r7,r10
80008f50:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f54:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008f58:	c1 b8       	rjmp	80008f8e <_vfprintf_r+0x1482>
80008f5a:	d7 03       	nop
80008f5c:	41 09       	lddsp	r9,sp[0x40]
80008f5e:	59 f8       	cp.w	r8,31
80008f60:	e0 89 00 13 	brgt	80008f86 <_vfprintf_r+0x147a>
80008f64:	f2 cb ff fc 	sub	r11,r9,-4
80008f68:	51 0b       	stdsp	sp[0x40],r11
80008f6a:	72 09       	ld.w	r9,r9[0x0]
80008f6c:	fa c6 f9 44 	sub	r6,sp,-1724
80008f70:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008f74:	2f f8       	sub	r8,-1
80008f76:	f7 49 fd 88 	st.w	r11[-632],r9
80008f7a:	fb 48 06 b4 	st.w	sp[1716],r8
80008f7e:	14 97       	mov	r7,r10
80008f80:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008f84:	c0 58       	rjmp	80008f8e <_vfprintf_r+0x1482>
80008f86:	92 18       	ld.sh	r8,r9[0x2]
80008f88:	14 97       	mov	r7,r10
80008f8a:	2f c9       	sub	r9,-4
80008f8c:	51 09       	stdsp	sp[0x40],r9
80008f8e:	5c 78       	castu.h	r8
80008f90:	50 18       	stdsp	sp[0x4],r8
80008f92:	c4 68       	rjmp	8000901e <_vfprintf_r+0x1512>
80008f94:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f98:	40 3c       	lddsp	r12,sp[0xc]
80008f9a:	58 0c       	cp.w	r12,0
80008f9c:	c1 d0       	breq	80008fd6 <_vfprintf_r+0x14ca>
80008f9e:	10 36       	cp.w	r6,r8
80008fa0:	c0 64       	brge	80008fac <_vfprintf_r+0x14a0>
80008fa2:	fa cb f9 44 	sub	r11,sp,-1724
80008fa6:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008faa:	c1 f8       	rjmp	80008fe8 <_vfprintf_r+0x14dc>
80008fac:	fa c8 f9 50 	sub	r8,sp,-1712
80008fb0:	1a d8       	st.w	--sp,r8
80008fb2:	fa c8 fa b8 	sub	r8,sp,-1352
80008fb6:	0c 9b       	mov	r11,r6
80008fb8:	1a d8       	st.w	--sp,r8
80008fba:	fa c8 fb b4 	sub	r8,sp,-1100
80008fbe:	04 9a       	mov	r10,r2
80008fc0:	1a d8       	st.w	--sp,r8
80008fc2:	08 9c       	mov	r12,r4
80008fc4:	fa c8 f9 40 	sub	r8,sp,-1728
80008fc8:	fa c9 ff b4 	sub	r9,sp,-76
80008fcc:	fe b0 f4 08 	rcall	800077dc <get_arg>
80008fd0:	2f dd       	sub	sp,-12
80008fd2:	78 0b       	ld.w	r11,r12[0x0]
80008fd4:	c2 48       	rjmp	8000901c <_vfprintf_r+0x1510>
80008fd6:	ee ca ff ff 	sub	r10,r7,-1
80008fda:	10 37       	cp.w	r7,r8
80008fdc:	c0 94       	brge	80008fee <_vfprintf_r+0x14e2>
80008fde:	fa c9 f9 44 	sub	r9,sp,-1724
80008fe2:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008fe6:	14 97       	mov	r7,r10
80008fe8:	ec fb fd 88 	ld.w	r11,r6[-632]
80008fec:	c1 88       	rjmp	8000901c <_vfprintf_r+0x1510>
80008fee:	41 09       	lddsp	r9,sp[0x40]
80008ff0:	59 f8       	cp.w	r8,31
80008ff2:	e0 89 00 11 	brgt	80009014 <_vfprintf_r+0x1508>
80008ff6:	f2 cb ff fc 	sub	r11,r9,-4
80008ffa:	51 0b       	stdsp	sp[0x40],r11
80008ffc:	fa c6 f9 44 	sub	r6,sp,-1724
80009000:	72 0b       	ld.w	r11,r9[0x0]
80009002:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009006:	f3 4b fd 88 	st.w	r9[-632],r11
8000900a:	2f f8       	sub	r8,-1
8000900c:	14 97       	mov	r7,r10
8000900e:	fb 48 06 b4 	st.w	sp[1716],r8
80009012:	c0 58       	rjmp	8000901c <_vfprintf_r+0x1510>
80009014:	72 0b       	ld.w	r11,r9[0x0]
80009016:	14 97       	mov	r7,r10
80009018:	2f c9       	sub	r9,-4
8000901a:	51 09       	stdsp	sp[0x40],r9
8000901c:	50 1b       	stdsp	sp[0x4],r11
8000901e:	30 0e       	mov	lr,0
80009020:	50 0e       	stdsp	sp[0x0],lr
80009022:	40 08       	lddsp	r8,sp[0x0]
80009024:	40 1c       	lddsp	r12,sp[0x4]
80009026:	18 48       	or	r8,r12
80009028:	5f 19       	srne	r9
8000902a:	0a 98       	mov	r8,r5
8000902c:	eb e9 00 09 	and	r9,r5,r9
80009030:	a1 b8       	sbr	r8,0x1
80009032:	58 09       	cp.w	r9,0
80009034:	c0 70       	breq	80009042 <_vfprintf_r+0x1536>
80009036:	10 95       	mov	r5,r8
80009038:	fb 60 06 b9 	st.b	sp[1721],r0
8000903c:	33 08       	mov	r8,48
8000903e:	fb 68 06 b8 	st.b	sp[1720],r8
80009042:	30 28       	mov	r8,2
80009044:	30 09       	mov	r9,0
80009046:	fb 69 06 bb 	st.b	sp[1723],r9
8000904a:	0a 99       	mov	r9,r5
8000904c:	a7 d9       	cbr	r9,0x7
8000904e:	40 2b       	lddsp	r11,sp[0x8]
80009050:	40 16       	lddsp	r6,sp[0x4]
80009052:	58 0b       	cp.w	r11,0
80009054:	5f 1a       	srne	r10
80009056:	f2 05 17 40 	movge	r5,r9
8000905a:	fa c2 f9 78 	sub	r2,sp,-1672
8000905e:	40 09       	lddsp	r9,sp[0x0]
80009060:	0c 49       	or	r9,r6
80009062:	5f 19       	srne	r9
80009064:	f5 e9 10 09 	or	r9,r10,r9
80009068:	c5 c0       	breq	80009120 <_vfprintf_r+0x1614>
8000906a:	30 19       	mov	r9,1
8000906c:	f2 08 18 00 	cp.b	r8,r9
80009070:	c0 60       	breq	8000907c <_vfprintf_r+0x1570>
80009072:	30 29       	mov	r9,2
80009074:	f2 08 18 00 	cp.b	r8,r9
80009078:	c0 41       	brne	80009080 <_vfprintf_r+0x1574>
8000907a:	c3 c8       	rjmp	800090f2 <_vfprintf_r+0x15e6>
8000907c:	04 96       	mov	r6,r2
8000907e:	c3 08       	rjmp	800090de <_vfprintf_r+0x15d2>
80009080:	04 96       	mov	r6,r2
80009082:	fa e8 00 00 	ld.d	r8,sp[0]
80009086:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000908a:	2d 0a       	sub	r10,-48
8000908c:	0c fa       	st.b	--r6,r10
8000908e:	f0 0b 16 03 	lsr	r11,r8,0x3
80009092:	f2 0c 16 03 	lsr	r12,r9,0x3
80009096:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000909a:	18 99       	mov	r9,r12
8000909c:	16 98       	mov	r8,r11
8000909e:	58 08       	cp.w	r8,0
800090a0:	5c 29       	cpc	r9
800090a2:	cf 21       	brne	80009086 <_vfprintf_r+0x157a>
800090a4:	fa e9 00 00 	st.d	sp[0],r8
800090a8:	ed b5 00 00 	bld	r5,0x0
800090ac:	c4 51       	brne	80009136 <_vfprintf_r+0x162a>
800090ae:	33 09       	mov	r9,48
800090b0:	f2 0a 18 00 	cp.b	r10,r9
800090b4:	c4 10       	breq	80009136 <_vfprintf_r+0x162a>
800090b6:	0c f9       	st.b	--r6,r9
800090b8:	c3 f8       	rjmp	80009136 <_vfprintf_r+0x162a>
800090ba:	fa ea 00 00 	ld.d	r10,sp[0]
800090be:	30 a8       	mov	r8,10
800090c0:	30 09       	mov	r9,0
800090c2:	e0 a0 1a 19 	rcall	8000c4f4 <__avr32_umod64>
800090c6:	30 a8       	mov	r8,10
800090c8:	2d 0a       	sub	r10,-48
800090ca:	30 09       	mov	r9,0
800090cc:	ac 8a       	st.b	r6[0x0],r10
800090ce:	fa ea 00 00 	ld.d	r10,sp[0]
800090d2:	e0 a0 18 df 	rcall	8000c290 <__avr32_udiv64>
800090d6:	16 99       	mov	r9,r11
800090d8:	14 98       	mov	r8,r10
800090da:	fa e9 00 00 	st.d	sp[0],r8
800090de:	20 16       	sub	r6,1
800090e0:	fa ea 00 00 	ld.d	r10,sp[0]
800090e4:	58 9a       	cp.w	r10,9
800090e6:	5c 2b       	cpc	r11
800090e8:	fe 9b ff e9 	brhi	800090ba <_vfprintf_r+0x15ae>
800090ec:	1b f8       	ld.ub	r8,sp[0x7]
800090ee:	2d 08       	sub	r8,-48
800090f0:	c2 08       	rjmp	80009130 <_vfprintf_r+0x1624>
800090f2:	04 96       	mov	r6,r2
800090f4:	fa e8 00 00 	ld.d	r8,sp[0]
800090f8:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
800090fc:	40 de       	lddsp	lr,sp[0x34]
800090fe:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80009102:	0c fa       	st.b	--r6,r10
80009104:	f2 0b 16 04 	lsr	r11,r9,0x4
80009108:	f0 0a 16 04 	lsr	r10,r8,0x4
8000910c:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009110:	16 99       	mov	r9,r11
80009112:	14 98       	mov	r8,r10
80009114:	58 08       	cp.w	r8,0
80009116:	5c 29       	cpc	r9
80009118:	cf 01       	brne	800090f8 <_vfprintf_r+0x15ec>
8000911a:	fa e9 00 00 	st.d	sp[0],r8
8000911e:	c0 c8       	rjmp	80009136 <_vfprintf_r+0x162a>
80009120:	58 08       	cp.w	r8,0
80009122:	c0 91       	brne	80009134 <_vfprintf_r+0x1628>
80009124:	ed b5 00 00 	bld	r5,0x0
80009128:	c0 61       	brne	80009134 <_vfprintf_r+0x1628>
8000912a:	fa c6 f9 79 	sub	r6,sp,-1671
8000912e:	33 08       	mov	r8,48
80009130:	ac 88       	st.b	r6[0x0],r8
80009132:	c0 28       	rjmp	80009136 <_vfprintf_r+0x162a>
80009134:	04 96       	mov	r6,r2
80009136:	0c 12       	sub	r2,r6
80009138:	c1 c8       	rjmp	80009170 <_vfprintf_r+0x1664>
8000913a:	50 a7       	stdsp	sp[0x28],r7
8000913c:	50 80       	stdsp	sp[0x20],r0
8000913e:	40 93       	lddsp	r3,sp[0x24]
80009140:	0c 97       	mov	r7,r6
80009142:	10 90       	mov	r0,r8
80009144:	04 94       	mov	r4,r2
80009146:	40 41       	lddsp	r1,sp[0x10]
80009148:	58 08       	cp.w	r8,0
8000914a:	e0 80 04 4f 	breq	800099e8 <_vfprintf_r+0x1edc>
8000914e:	fb 68 06 60 	st.b	sp[1632],r8
80009152:	30 0c       	mov	r12,0
80009154:	30 08       	mov	r8,0
80009156:	30 12       	mov	r2,1
80009158:	fb 68 06 bb 	st.b	sp[1723],r8
8000915c:	50 2c       	stdsp	sp[0x8],r12
8000915e:	fa c6 f9 a0 	sub	r6,sp,-1632
80009162:	c0 78       	rjmp	80009170 <_vfprintf_r+0x1664>
80009164:	30 0b       	mov	r11,0
80009166:	50 2b       	stdsp	sp[0x8],r11
80009168:	c0 48       	rjmp	80009170 <_vfprintf_r+0x1664>
8000916a:	40 22       	lddsp	r2,sp[0x8]
8000916c:	30 0a       	mov	r10,0
8000916e:	50 2a       	stdsp	sp[0x8],r10
80009170:	40 29       	lddsp	r9,sp[0x8]
80009172:	e4 09 0c 49 	max	r9,r2,r9
80009176:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000917a:	50 39       	stdsp	sp[0xc],r9
8000917c:	0a 9e       	mov	lr,r5
8000917e:	30 09       	mov	r9,0
80009180:	e2 1e 00 02 	andl	lr,0x2,COH
80009184:	f2 08 18 00 	cp.b	r8,r9
80009188:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000918c:	f7 b8 01 ff 	subne	r8,-1
80009190:	fb f8 1a 03 	st.wne	sp[0xc],r8
80009194:	0a 9b       	mov	r11,r5
80009196:	58 0e       	cp.w	lr,0
80009198:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000919c:	f7 bc 01 fe 	subne	r12,-2
800091a0:	fb fc 1a 03 	st.wne	sp[0xc],r12
800091a4:	e2 1b 00 84 	andl	r11,0x84,COH
800091a8:	50 fe       	stdsp	sp[0x3c],lr
800091aa:	50 9b       	stdsp	sp[0x24],r11
800091ac:	c4 71       	brne	8000923a <_vfprintf_r+0x172e>
800091ae:	40 8a       	lddsp	r10,sp[0x20]
800091b0:	40 39       	lddsp	r9,sp[0xc]
800091b2:	12 1a       	sub	r10,r9
800091b4:	50 4a       	stdsp	sp[0x10],r10
800091b6:	58 0a       	cp.w	r10,0
800091b8:	e0 89 00 20 	brgt	800091f8 <_vfprintf_r+0x16ec>
800091bc:	c3 f8       	rjmp	8000923a <_vfprintf_r+0x172e>
800091be:	2f 09       	sub	r9,-16
800091c0:	2f f8       	sub	r8,-1
800091c2:	fe ce b9 32 	sub	lr,pc,-18126
800091c6:	31 0c       	mov	r12,16
800091c8:	fb 49 06 90 	st.w	sp[1680],r9
800091cc:	87 0e       	st.w	r3[0x0],lr
800091ce:	87 1c       	st.w	r3[0x4],r12
800091d0:	fb 48 06 8c 	st.w	sp[1676],r8
800091d4:	58 78       	cp.w	r8,7
800091d6:	e0 89 00 04 	brgt	800091de <_vfprintf_r+0x16d2>
800091da:	2f 83       	sub	r3,-8
800091dc:	c0 b8       	rjmp	800091f2 <_vfprintf_r+0x16e6>
800091de:	fa ca f9 78 	sub	r10,sp,-1672
800091e2:	02 9b       	mov	r11,r1
800091e4:	08 9c       	mov	r12,r4
800091e6:	fe b0 f4 85 	rcall	80007af0 <__sprint_r>
800091ea:	e0 81 04 10 	brne	80009a0a <_vfprintf_r+0x1efe>
800091ee:	fa c3 f9 e0 	sub	r3,sp,-1568
800091f2:	40 4b       	lddsp	r11,sp[0x10]
800091f4:	21 0b       	sub	r11,16
800091f6:	50 4b       	stdsp	sp[0x10],r11
800091f8:	fa f9 06 90 	ld.w	r9,sp[1680]
800091fc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009200:	fe ca b9 70 	sub	r10,pc,-18064
80009204:	40 4e       	lddsp	lr,sp[0x10]
80009206:	59 0e       	cp.w	lr,16
80009208:	fe 99 ff db 	brgt	800091be <_vfprintf_r+0x16b2>
8000920c:	1c 09       	add	r9,lr
8000920e:	2f f8       	sub	r8,-1
80009210:	87 0a       	st.w	r3[0x0],r10
80009212:	fb 49 06 90 	st.w	sp[1680],r9
80009216:	87 1e       	st.w	r3[0x4],lr
80009218:	fb 48 06 8c 	st.w	sp[1676],r8
8000921c:	58 78       	cp.w	r8,7
8000921e:	e0 89 00 04 	brgt	80009226 <_vfprintf_r+0x171a>
80009222:	2f 83       	sub	r3,-8
80009224:	c0 b8       	rjmp	8000923a <_vfprintf_r+0x172e>
80009226:	fa ca f9 78 	sub	r10,sp,-1672
8000922a:	02 9b       	mov	r11,r1
8000922c:	08 9c       	mov	r12,r4
8000922e:	fe b0 f4 61 	rcall	80007af0 <__sprint_r>
80009232:	e0 81 03 ec 	brne	80009a0a <_vfprintf_r+0x1efe>
80009236:	fa c3 f9 e0 	sub	r3,sp,-1568
8000923a:	30 09       	mov	r9,0
8000923c:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009240:	f2 08 18 00 	cp.b	r8,r9
80009244:	c1 f0       	breq	80009282 <_vfprintf_r+0x1776>
80009246:	fa f8 06 90 	ld.w	r8,sp[1680]
8000924a:	fa c9 f9 45 	sub	r9,sp,-1723
8000924e:	2f f8       	sub	r8,-1
80009250:	87 09       	st.w	r3[0x0],r9
80009252:	fb 48 06 90 	st.w	sp[1680],r8
80009256:	30 19       	mov	r9,1
80009258:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000925c:	87 19       	st.w	r3[0x4],r9
8000925e:	2f f8       	sub	r8,-1
80009260:	fb 48 06 8c 	st.w	sp[1676],r8
80009264:	58 78       	cp.w	r8,7
80009266:	e0 89 00 04 	brgt	8000926e <_vfprintf_r+0x1762>
8000926a:	2f 83       	sub	r3,-8
8000926c:	c0 b8       	rjmp	80009282 <_vfprintf_r+0x1776>
8000926e:	fa ca f9 78 	sub	r10,sp,-1672
80009272:	02 9b       	mov	r11,r1
80009274:	08 9c       	mov	r12,r4
80009276:	fe b0 f4 3d 	rcall	80007af0 <__sprint_r>
8000927a:	e0 81 03 c8 	brne	80009a0a <_vfprintf_r+0x1efe>
8000927e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009282:	40 fc       	lddsp	r12,sp[0x3c]
80009284:	58 0c       	cp.w	r12,0
80009286:	c1 f0       	breq	800092c4 <_vfprintf_r+0x17b8>
80009288:	fa f8 06 90 	ld.w	r8,sp[1680]
8000928c:	fa c9 f9 48 	sub	r9,sp,-1720
80009290:	2f e8       	sub	r8,-2
80009292:	87 09       	st.w	r3[0x0],r9
80009294:	fb 48 06 90 	st.w	sp[1680],r8
80009298:	30 29       	mov	r9,2
8000929a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000929e:	87 19       	st.w	r3[0x4],r9
800092a0:	2f f8       	sub	r8,-1
800092a2:	fb 48 06 8c 	st.w	sp[1676],r8
800092a6:	58 78       	cp.w	r8,7
800092a8:	e0 89 00 04 	brgt	800092b0 <_vfprintf_r+0x17a4>
800092ac:	2f 83       	sub	r3,-8
800092ae:	c0 b8       	rjmp	800092c4 <_vfprintf_r+0x17b8>
800092b0:	fa ca f9 78 	sub	r10,sp,-1672
800092b4:	02 9b       	mov	r11,r1
800092b6:	08 9c       	mov	r12,r4
800092b8:	fe b0 f4 1c 	rcall	80007af0 <__sprint_r>
800092bc:	e0 81 03 a7 	brne	80009a0a <_vfprintf_r+0x1efe>
800092c0:	fa c3 f9 e0 	sub	r3,sp,-1568
800092c4:	40 9b       	lddsp	r11,sp[0x24]
800092c6:	e0 4b 00 80 	cp.w	r11,128
800092ca:	c4 71       	brne	80009358 <_vfprintf_r+0x184c>
800092cc:	40 8a       	lddsp	r10,sp[0x20]
800092ce:	40 39       	lddsp	r9,sp[0xc]
800092d0:	12 1a       	sub	r10,r9
800092d2:	50 4a       	stdsp	sp[0x10],r10
800092d4:	58 0a       	cp.w	r10,0
800092d6:	e0 89 00 20 	brgt	80009316 <_vfprintf_r+0x180a>
800092da:	c3 f8       	rjmp	80009358 <_vfprintf_r+0x184c>
800092dc:	2f 09       	sub	r9,-16
800092de:	2f f8       	sub	r8,-1
800092e0:	fe ce ba 40 	sub	lr,pc,-17856
800092e4:	31 0c       	mov	r12,16
800092e6:	fb 49 06 90 	st.w	sp[1680],r9
800092ea:	87 0e       	st.w	r3[0x0],lr
800092ec:	87 1c       	st.w	r3[0x4],r12
800092ee:	fb 48 06 8c 	st.w	sp[1676],r8
800092f2:	58 78       	cp.w	r8,7
800092f4:	e0 89 00 04 	brgt	800092fc <_vfprintf_r+0x17f0>
800092f8:	2f 83       	sub	r3,-8
800092fa:	c0 b8       	rjmp	80009310 <_vfprintf_r+0x1804>
800092fc:	fa ca f9 78 	sub	r10,sp,-1672
80009300:	02 9b       	mov	r11,r1
80009302:	08 9c       	mov	r12,r4
80009304:	fe b0 f3 f6 	rcall	80007af0 <__sprint_r>
80009308:	e0 81 03 81 	brne	80009a0a <_vfprintf_r+0x1efe>
8000930c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009310:	40 4b       	lddsp	r11,sp[0x10]
80009312:	21 0b       	sub	r11,16
80009314:	50 4b       	stdsp	sp[0x10],r11
80009316:	fa f9 06 90 	ld.w	r9,sp[1680]
8000931a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000931e:	fe ca ba 7e 	sub	r10,pc,-17794
80009322:	40 4e       	lddsp	lr,sp[0x10]
80009324:	59 0e       	cp.w	lr,16
80009326:	fe 99 ff db 	brgt	800092dc <_vfprintf_r+0x17d0>
8000932a:	1c 09       	add	r9,lr
8000932c:	2f f8       	sub	r8,-1
8000932e:	87 0a       	st.w	r3[0x0],r10
80009330:	fb 49 06 90 	st.w	sp[1680],r9
80009334:	87 1e       	st.w	r3[0x4],lr
80009336:	fb 48 06 8c 	st.w	sp[1676],r8
8000933a:	58 78       	cp.w	r8,7
8000933c:	e0 89 00 04 	brgt	80009344 <_vfprintf_r+0x1838>
80009340:	2f 83       	sub	r3,-8
80009342:	c0 b8       	rjmp	80009358 <_vfprintf_r+0x184c>
80009344:	fa ca f9 78 	sub	r10,sp,-1672
80009348:	02 9b       	mov	r11,r1
8000934a:	08 9c       	mov	r12,r4
8000934c:	fe b0 f3 d2 	rcall	80007af0 <__sprint_r>
80009350:	e0 81 03 5d 	brne	80009a0a <_vfprintf_r+0x1efe>
80009354:	fa c3 f9 e0 	sub	r3,sp,-1568
80009358:	40 2c       	lddsp	r12,sp[0x8]
8000935a:	04 1c       	sub	r12,r2
8000935c:	50 2c       	stdsp	sp[0x8],r12
8000935e:	58 0c       	cp.w	r12,0
80009360:	e0 89 00 20 	brgt	800093a0 <_vfprintf_r+0x1894>
80009364:	c3 f8       	rjmp	800093e2 <_vfprintf_r+0x18d6>
80009366:	2f 09       	sub	r9,-16
80009368:	2f f8       	sub	r8,-1
8000936a:	fe cb ba ca 	sub	r11,pc,-17718
8000936e:	31 0a       	mov	r10,16
80009370:	fb 49 06 90 	st.w	sp[1680],r9
80009374:	87 0b       	st.w	r3[0x0],r11
80009376:	87 1a       	st.w	r3[0x4],r10
80009378:	fb 48 06 8c 	st.w	sp[1676],r8
8000937c:	58 78       	cp.w	r8,7
8000937e:	e0 89 00 04 	brgt	80009386 <_vfprintf_r+0x187a>
80009382:	2f 83       	sub	r3,-8
80009384:	c0 b8       	rjmp	8000939a <_vfprintf_r+0x188e>
80009386:	fa ca f9 78 	sub	r10,sp,-1672
8000938a:	02 9b       	mov	r11,r1
8000938c:	08 9c       	mov	r12,r4
8000938e:	fe b0 f3 b1 	rcall	80007af0 <__sprint_r>
80009392:	e0 81 03 3c 	brne	80009a0a <_vfprintf_r+0x1efe>
80009396:	fa c3 f9 e0 	sub	r3,sp,-1568
8000939a:	40 29       	lddsp	r9,sp[0x8]
8000939c:	21 09       	sub	r9,16
8000939e:	50 29       	stdsp	sp[0x8],r9
800093a0:	fa f9 06 90 	ld.w	r9,sp[1680]
800093a4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800093a8:	fe ca bb 08 	sub	r10,pc,-17656
800093ac:	40 2e       	lddsp	lr,sp[0x8]
800093ae:	59 0e       	cp.w	lr,16
800093b0:	fe 99 ff db 	brgt	80009366 <_vfprintf_r+0x185a>
800093b4:	1c 09       	add	r9,lr
800093b6:	2f f8       	sub	r8,-1
800093b8:	87 0a       	st.w	r3[0x0],r10
800093ba:	fb 49 06 90 	st.w	sp[1680],r9
800093be:	87 1e       	st.w	r3[0x4],lr
800093c0:	fb 48 06 8c 	st.w	sp[1676],r8
800093c4:	58 78       	cp.w	r8,7
800093c6:	e0 89 00 04 	brgt	800093ce <_vfprintf_r+0x18c2>
800093ca:	2f 83       	sub	r3,-8
800093cc:	c0 b8       	rjmp	800093e2 <_vfprintf_r+0x18d6>
800093ce:	fa ca f9 78 	sub	r10,sp,-1672
800093d2:	02 9b       	mov	r11,r1
800093d4:	08 9c       	mov	r12,r4
800093d6:	fe b0 f3 8d 	rcall	80007af0 <__sprint_r>
800093da:	e0 81 03 18 	brne	80009a0a <_vfprintf_r+0x1efe>
800093de:	fa c3 f9 e0 	sub	r3,sp,-1568
800093e2:	ed b5 00 08 	bld	r5,0x8
800093e6:	c0 b0       	breq	800093fc <_vfprintf_r+0x18f0>
800093e8:	fa f8 06 90 	ld.w	r8,sp[1680]
800093ec:	87 12       	st.w	r3[0x4],r2
800093ee:	87 06       	st.w	r3[0x0],r6
800093f0:	f0 02 00 02 	add	r2,r8,r2
800093f4:	fb 42 06 90 	st.w	sp[1680],r2
800093f8:	e0 8f 01 d4 	bral	800097a0 <_vfprintf_r+0x1c94>
800093fc:	e0 40 00 65 	cp.w	r0,101
80009400:	e0 8a 01 d6 	brle	800097ac <_vfprintf_r+0x1ca0>
80009404:	30 08       	mov	r8,0
80009406:	30 09       	mov	r9,0
80009408:	40 5b       	lddsp	r11,sp[0x14]
8000940a:	40 7a       	lddsp	r10,sp[0x1c]
8000940c:	e0 a0 15 3b 	rcall	8000be82 <__avr32_f64_cmp_eq>
80009410:	c7 90       	breq	80009502 <_vfprintf_r+0x19f6>
80009412:	fa f8 06 90 	ld.w	r8,sp[1680]
80009416:	fe c9 bb 8a 	sub	r9,pc,-17526
8000941a:	2f f8       	sub	r8,-1
8000941c:	87 09       	st.w	r3[0x0],r9
8000941e:	fb 48 06 90 	st.w	sp[1680],r8
80009422:	30 19       	mov	r9,1
80009424:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009428:	87 19       	st.w	r3[0x4],r9
8000942a:	2f f8       	sub	r8,-1
8000942c:	fb 48 06 8c 	st.w	sp[1676],r8
80009430:	58 78       	cp.w	r8,7
80009432:	e0 89 00 05 	brgt	8000943c <_vfprintf_r+0x1930>
80009436:	2f 83       	sub	r3,-8
80009438:	c0 c8       	rjmp	80009450 <_vfprintf_r+0x1944>
8000943a:	d7 03       	nop
8000943c:	fa ca f9 78 	sub	r10,sp,-1672
80009440:	02 9b       	mov	r11,r1
80009442:	08 9c       	mov	r12,r4
80009444:	fe b0 f3 56 	rcall	80007af0 <__sprint_r>
80009448:	e0 81 02 e1 	brne	80009a0a <_vfprintf_r+0x1efe>
8000944c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009450:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009454:	40 6c       	lddsp	r12,sp[0x18]
80009456:	18 38       	cp.w	r8,r12
80009458:	c0 55       	brlt	80009462 <_vfprintf_r+0x1956>
8000945a:	ed b5 00 00 	bld	r5,0x0
8000945e:	e0 81 02 6b 	brne	80009934 <_vfprintf_r+0x1e28>
80009462:	fa f8 06 90 	ld.w	r8,sp[1680]
80009466:	2f f8       	sub	r8,-1
80009468:	40 cb       	lddsp	r11,sp[0x30]
8000946a:	fb 48 06 90 	st.w	sp[1680],r8
8000946e:	30 19       	mov	r9,1
80009470:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009474:	87 0b       	st.w	r3[0x0],r11
80009476:	2f f8       	sub	r8,-1
80009478:	87 19       	st.w	r3[0x4],r9
8000947a:	fb 48 06 8c 	st.w	sp[1676],r8
8000947e:	58 78       	cp.w	r8,7
80009480:	e0 89 00 04 	brgt	80009488 <_vfprintf_r+0x197c>
80009484:	2f 83       	sub	r3,-8
80009486:	c0 b8       	rjmp	8000949c <_vfprintf_r+0x1990>
80009488:	fa ca f9 78 	sub	r10,sp,-1672
8000948c:	02 9b       	mov	r11,r1
8000948e:	08 9c       	mov	r12,r4
80009490:	fe b0 f3 30 	rcall	80007af0 <__sprint_r>
80009494:	e0 81 02 bb 	brne	80009a0a <_vfprintf_r+0x1efe>
80009498:	fa c3 f9 e0 	sub	r3,sp,-1568
8000949c:	40 66       	lddsp	r6,sp[0x18]
8000949e:	20 16       	sub	r6,1
800094a0:	58 06       	cp.w	r6,0
800094a2:	e0 89 00 1d 	brgt	800094dc <_vfprintf_r+0x19d0>
800094a6:	e0 8f 02 47 	bral	80009934 <_vfprintf_r+0x1e28>
800094aa:	2f 09       	sub	r9,-16
800094ac:	2f f8       	sub	r8,-1
800094ae:	fb 49 06 90 	st.w	sp[1680],r9
800094b2:	87 02       	st.w	r3[0x0],r2
800094b4:	87 10       	st.w	r3[0x4],r0
800094b6:	fb 48 06 8c 	st.w	sp[1676],r8
800094ba:	58 78       	cp.w	r8,7
800094bc:	e0 89 00 04 	brgt	800094c4 <_vfprintf_r+0x19b8>
800094c0:	2f 83       	sub	r3,-8
800094c2:	c0 b8       	rjmp	800094d8 <_vfprintf_r+0x19cc>
800094c4:	fa ca f9 78 	sub	r10,sp,-1672
800094c8:	02 9b       	mov	r11,r1
800094ca:	08 9c       	mov	r12,r4
800094cc:	fe b0 f3 12 	rcall	80007af0 <__sprint_r>
800094d0:	e0 81 02 9d 	brne	80009a0a <_vfprintf_r+0x1efe>
800094d4:	fa c3 f9 e0 	sub	r3,sp,-1568
800094d8:	21 06       	sub	r6,16
800094da:	c0 48       	rjmp	800094e2 <_vfprintf_r+0x19d6>
800094dc:	fe c2 bc 3c 	sub	r2,pc,-17348
800094e0:	31 00       	mov	r0,16
800094e2:	fa f9 06 90 	ld.w	r9,sp[1680]
800094e6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800094ea:	fe ca bc 4a 	sub	r10,pc,-17334
800094ee:	59 06       	cp.w	r6,16
800094f0:	fe 99 ff dd 	brgt	800094aa <_vfprintf_r+0x199e>
800094f4:	0c 09       	add	r9,r6
800094f6:	87 0a       	st.w	r3[0x0],r10
800094f8:	fb 49 06 90 	st.w	sp[1680],r9
800094fc:	2f f8       	sub	r8,-1
800094fe:	87 16       	st.w	r3[0x4],r6
80009500:	c5 39       	rjmp	800097a6 <_vfprintf_r+0x1c9a>
80009502:	fa fa 06 ac 	ld.w	r10,sp[1708]
80009506:	58 0a       	cp.w	r10,0
80009508:	e0 89 00 92 	brgt	8000962c <_vfprintf_r+0x1b20>
8000950c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009510:	fe c9 bc 84 	sub	r9,pc,-17276
80009514:	2f f8       	sub	r8,-1
80009516:	87 09       	st.w	r3[0x0],r9
80009518:	fb 48 06 90 	st.w	sp[1680],r8
8000951c:	30 19       	mov	r9,1
8000951e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009522:	87 19       	st.w	r3[0x4],r9
80009524:	2f f8       	sub	r8,-1
80009526:	fb 48 06 8c 	st.w	sp[1676],r8
8000952a:	58 78       	cp.w	r8,7
8000952c:	e0 89 00 04 	brgt	80009534 <_vfprintf_r+0x1a28>
80009530:	2f 83       	sub	r3,-8
80009532:	c0 b8       	rjmp	80009548 <_vfprintf_r+0x1a3c>
80009534:	fa ca f9 78 	sub	r10,sp,-1672
80009538:	02 9b       	mov	r11,r1
8000953a:	08 9c       	mov	r12,r4
8000953c:	fe b0 f2 da 	rcall	80007af0 <__sprint_r>
80009540:	e0 81 02 65 	brne	80009a0a <_vfprintf_r+0x1efe>
80009544:	fa c3 f9 e0 	sub	r3,sp,-1568
80009548:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000954c:	58 08       	cp.w	r8,0
8000954e:	c0 81       	brne	8000955e <_vfprintf_r+0x1a52>
80009550:	40 6a       	lddsp	r10,sp[0x18]
80009552:	58 0a       	cp.w	r10,0
80009554:	c0 51       	brne	8000955e <_vfprintf_r+0x1a52>
80009556:	ed b5 00 00 	bld	r5,0x0
8000955a:	e0 81 01 ed 	brne	80009934 <_vfprintf_r+0x1e28>
8000955e:	40 c9       	lddsp	r9,sp[0x30]
80009560:	fa f8 06 90 	ld.w	r8,sp[1680]
80009564:	2f f8       	sub	r8,-1
80009566:	87 09       	st.w	r3[0x0],r9
80009568:	fb 48 06 90 	st.w	sp[1680],r8
8000956c:	30 19       	mov	r9,1
8000956e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009572:	87 19       	st.w	r3[0x4],r9
80009574:	2f f8       	sub	r8,-1
80009576:	fb 48 06 8c 	st.w	sp[1676],r8
8000957a:	58 78       	cp.w	r8,7
8000957c:	e0 89 00 04 	brgt	80009584 <_vfprintf_r+0x1a78>
80009580:	2f 83       	sub	r3,-8
80009582:	c0 b8       	rjmp	80009598 <_vfprintf_r+0x1a8c>
80009584:	fa ca f9 78 	sub	r10,sp,-1672
80009588:	02 9b       	mov	r11,r1
8000958a:	08 9c       	mov	r12,r4
8000958c:	fe b0 f2 b2 	rcall	80007af0 <__sprint_r>
80009590:	e0 81 02 3d 	brne	80009a0a <_vfprintf_r+0x1efe>
80009594:	fa c3 f9 e0 	sub	r3,sp,-1568
80009598:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000959c:	5c 32       	neg	r2
8000959e:	58 02       	cp.w	r2,0
800095a0:	e0 89 00 1d 	brgt	800095da <_vfprintf_r+0x1ace>
800095a4:	c3 d8       	rjmp	8000961e <_vfprintf_r+0x1b12>
800095a6:	2f 09       	sub	r9,-16
800095a8:	2f f8       	sub	r8,-1
800095aa:	31 0e       	mov	lr,16
800095ac:	fb 49 06 90 	st.w	sp[1680],r9
800095b0:	87 00       	st.w	r3[0x0],r0
800095b2:	87 1e       	st.w	r3[0x4],lr
800095b4:	fb 48 06 8c 	st.w	sp[1676],r8
800095b8:	58 78       	cp.w	r8,7
800095ba:	e0 89 00 04 	brgt	800095c2 <_vfprintf_r+0x1ab6>
800095be:	2f 83       	sub	r3,-8
800095c0:	c0 b8       	rjmp	800095d6 <_vfprintf_r+0x1aca>
800095c2:	fa ca f9 78 	sub	r10,sp,-1672
800095c6:	02 9b       	mov	r11,r1
800095c8:	08 9c       	mov	r12,r4
800095ca:	fe b0 f2 93 	rcall	80007af0 <__sprint_r>
800095ce:	e0 81 02 1e 	brne	80009a0a <_vfprintf_r+0x1efe>
800095d2:	fa c3 f9 e0 	sub	r3,sp,-1568
800095d6:	21 02       	sub	r2,16
800095d8:	c0 38       	rjmp	800095de <_vfprintf_r+0x1ad2>
800095da:	fe c0 bd 3a 	sub	r0,pc,-17094
800095de:	fa f9 06 90 	ld.w	r9,sp[1680]
800095e2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800095e6:	fe ca bd 46 	sub	r10,pc,-17082
800095ea:	59 02       	cp.w	r2,16
800095ec:	fe 99 ff dd 	brgt	800095a6 <_vfprintf_r+0x1a9a>
800095f0:	04 09       	add	r9,r2
800095f2:	2f f8       	sub	r8,-1
800095f4:	87 0a       	st.w	r3[0x0],r10
800095f6:	fb 49 06 90 	st.w	sp[1680],r9
800095fa:	87 12       	st.w	r3[0x4],r2
800095fc:	fb 48 06 8c 	st.w	sp[1676],r8
80009600:	58 78       	cp.w	r8,7
80009602:	e0 89 00 04 	brgt	8000960a <_vfprintf_r+0x1afe>
80009606:	2f 83       	sub	r3,-8
80009608:	c0 b8       	rjmp	8000961e <_vfprintf_r+0x1b12>
8000960a:	fa ca f9 78 	sub	r10,sp,-1672
8000960e:	02 9b       	mov	r11,r1
80009610:	08 9c       	mov	r12,r4
80009612:	fe b0 f2 6f 	rcall	80007af0 <__sprint_r>
80009616:	e0 81 01 fa 	brne	80009a0a <_vfprintf_r+0x1efe>
8000961a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000961e:	40 6c       	lddsp	r12,sp[0x18]
80009620:	fa f8 06 90 	ld.w	r8,sp[1680]
80009624:	87 06       	st.w	r3[0x0],r6
80009626:	87 1c       	st.w	r3[0x4],r12
80009628:	18 08       	add	r8,r12
8000962a:	cb 98       	rjmp	8000979c <_vfprintf_r+0x1c90>
8000962c:	fa f9 06 90 	ld.w	r9,sp[1680]
80009630:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009634:	40 6b       	lddsp	r11,sp[0x18]
80009636:	16 3a       	cp.w	r10,r11
80009638:	c6 f5       	brlt	80009716 <_vfprintf_r+0x1c0a>
8000963a:	16 09       	add	r9,r11
8000963c:	2f f8       	sub	r8,-1
8000963e:	87 06       	st.w	r3[0x0],r6
80009640:	fb 49 06 90 	st.w	sp[1680],r9
80009644:	87 1b       	st.w	r3[0x4],r11
80009646:	fb 48 06 8c 	st.w	sp[1676],r8
8000964a:	58 78       	cp.w	r8,7
8000964c:	e0 89 00 04 	brgt	80009654 <_vfprintf_r+0x1b48>
80009650:	2f 83       	sub	r3,-8
80009652:	c0 b8       	rjmp	80009668 <_vfprintf_r+0x1b5c>
80009654:	fa ca f9 78 	sub	r10,sp,-1672
80009658:	02 9b       	mov	r11,r1
8000965a:	08 9c       	mov	r12,r4
8000965c:	fe b0 f2 4a 	rcall	80007af0 <__sprint_r>
80009660:	e0 81 01 d5 	brne	80009a0a <_vfprintf_r+0x1efe>
80009664:	fa c3 f9 e0 	sub	r3,sp,-1568
80009668:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000966c:	40 6a       	lddsp	r10,sp[0x18]
8000966e:	14 16       	sub	r6,r10
80009670:	58 06       	cp.w	r6,0
80009672:	e0 89 00 1c 	brgt	800096aa <_vfprintf_r+0x1b9e>
80009676:	c3 d8       	rjmp	800096f0 <_vfprintf_r+0x1be4>
80009678:	2f 09       	sub	r9,-16
8000967a:	2f f8       	sub	r8,-1
8000967c:	fb 49 06 90 	st.w	sp[1680],r9
80009680:	87 02       	st.w	r3[0x0],r2
80009682:	87 10       	st.w	r3[0x4],r0
80009684:	fb 48 06 8c 	st.w	sp[1676],r8
80009688:	58 78       	cp.w	r8,7
8000968a:	e0 89 00 04 	brgt	80009692 <_vfprintf_r+0x1b86>
8000968e:	2f 83       	sub	r3,-8
80009690:	c0 b8       	rjmp	800096a6 <_vfprintf_r+0x1b9a>
80009692:	fa ca f9 78 	sub	r10,sp,-1672
80009696:	02 9b       	mov	r11,r1
80009698:	08 9c       	mov	r12,r4
8000969a:	fe b0 f2 2b 	rcall	80007af0 <__sprint_r>
8000969e:	e0 81 01 b6 	brne	80009a0a <_vfprintf_r+0x1efe>
800096a2:	fa c3 f9 e0 	sub	r3,sp,-1568
800096a6:	21 06       	sub	r6,16
800096a8:	c0 48       	rjmp	800096b0 <_vfprintf_r+0x1ba4>
800096aa:	fe c2 be 0a 	sub	r2,pc,-16886
800096ae:	31 00       	mov	r0,16
800096b0:	fa f9 06 90 	ld.w	r9,sp[1680]
800096b4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096b8:	fe ca be 18 	sub	r10,pc,-16872
800096bc:	59 06       	cp.w	r6,16
800096be:	fe 99 ff dd 	brgt	80009678 <_vfprintf_r+0x1b6c>
800096c2:	0c 09       	add	r9,r6
800096c4:	2f f8       	sub	r8,-1
800096c6:	87 0a       	st.w	r3[0x0],r10
800096c8:	fb 49 06 90 	st.w	sp[1680],r9
800096cc:	87 16       	st.w	r3[0x4],r6
800096ce:	fb 48 06 8c 	st.w	sp[1676],r8
800096d2:	58 78       	cp.w	r8,7
800096d4:	e0 89 00 04 	brgt	800096dc <_vfprintf_r+0x1bd0>
800096d8:	2f 83       	sub	r3,-8
800096da:	c0 b8       	rjmp	800096f0 <_vfprintf_r+0x1be4>
800096dc:	fa ca f9 78 	sub	r10,sp,-1672
800096e0:	02 9b       	mov	r11,r1
800096e2:	08 9c       	mov	r12,r4
800096e4:	fe b0 f2 06 	rcall	80007af0 <__sprint_r>
800096e8:	e0 81 01 91 	brne	80009a0a <_vfprintf_r+0x1efe>
800096ec:	fa c3 f9 e0 	sub	r3,sp,-1568
800096f0:	ed b5 00 00 	bld	r5,0x0
800096f4:	e0 81 01 20 	brne	80009934 <_vfprintf_r+0x1e28>
800096f8:	40 c9       	lddsp	r9,sp[0x30]
800096fa:	fa f8 06 90 	ld.w	r8,sp[1680]
800096fe:	2f f8       	sub	r8,-1
80009700:	87 09       	st.w	r3[0x0],r9
80009702:	fb 48 06 90 	st.w	sp[1680],r8
80009706:	30 19       	mov	r9,1
80009708:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000970c:	87 19       	st.w	r3[0x4],r9
8000970e:	2f f8       	sub	r8,-1
80009710:	fb 48 06 8c 	st.w	sp[1676],r8
80009714:	c0 29       	rjmp	80009918 <_vfprintf_r+0x1e0c>
80009716:	14 09       	add	r9,r10
80009718:	2f f8       	sub	r8,-1
8000971a:	fb 49 06 90 	st.w	sp[1680],r9
8000971e:	87 06       	st.w	r3[0x0],r6
80009720:	87 1a       	st.w	r3[0x4],r10
80009722:	fb 48 06 8c 	st.w	sp[1676],r8
80009726:	58 78       	cp.w	r8,7
80009728:	e0 89 00 04 	brgt	80009730 <_vfprintf_r+0x1c24>
8000972c:	2f 83       	sub	r3,-8
8000972e:	c0 b8       	rjmp	80009744 <_vfprintf_r+0x1c38>
80009730:	fa ca f9 78 	sub	r10,sp,-1672
80009734:	02 9b       	mov	r11,r1
80009736:	08 9c       	mov	r12,r4
80009738:	fe b0 f1 dc 	rcall	80007af0 <__sprint_r>
8000973c:	e0 81 01 67 	brne	80009a0a <_vfprintf_r+0x1efe>
80009740:	fa c3 f9 e0 	sub	r3,sp,-1568
80009744:	40 c8       	lddsp	r8,sp[0x30]
80009746:	87 08       	st.w	r3[0x0],r8
80009748:	fa f8 06 90 	ld.w	r8,sp[1680]
8000974c:	2f f8       	sub	r8,-1
8000974e:	30 19       	mov	r9,1
80009750:	fb 48 06 90 	st.w	sp[1680],r8
80009754:	87 19       	st.w	r3[0x4],r9
80009756:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000975a:	2f f8       	sub	r8,-1
8000975c:	fb 48 06 8c 	st.w	sp[1676],r8
80009760:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009764:	58 78       	cp.w	r8,7
80009766:	e0 89 00 04 	brgt	8000976e <_vfprintf_r+0x1c62>
8000976a:	2f 83       	sub	r3,-8
8000976c:	c0 b8       	rjmp	80009782 <_vfprintf_r+0x1c76>
8000976e:	fa ca f9 78 	sub	r10,sp,-1672
80009772:	02 9b       	mov	r11,r1
80009774:	08 9c       	mov	r12,r4
80009776:	fe b0 f1 bd 	rcall	80007af0 <__sprint_r>
8000977a:	e0 81 01 48 	brne	80009a0a <_vfprintf_r+0x1efe>
8000977e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009782:	04 06       	add	r6,r2
80009784:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009788:	87 06       	st.w	r3[0x0],r6
8000978a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000978e:	40 66       	lddsp	r6,sp[0x18]
80009790:	40 6e       	lddsp	lr,sp[0x18]
80009792:	10 16       	sub	r6,r8
80009794:	f2 08 01 08 	sub	r8,r9,r8
80009798:	87 16       	st.w	r3[0x4],r6
8000979a:	1c 08       	add	r8,lr
8000979c:	fb 48 06 90 	st.w	sp[1680],r8
800097a0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097a4:	2f f8       	sub	r8,-1
800097a6:	fb 48 06 8c 	st.w	sp[1676],r8
800097aa:	cb 78       	rjmp	80009918 <_vfprintf_r+0x1e0c>
800097ac:	40 6c       	lddsp	r12,sp[0x18]
800097ae:	58 1c       	cp.w	r12,1
800097b0:	e0 89 00 06 	brgt	800097bc <_vfprintf_r+0x1cb0>
800097b4:	ed b5 00 00 	bld	r5,0x0
800097b8:	e0 81 00 85 	brne	800098c2 <_vfprintf_r+0x1db6>
800097bc:	fa f8 06 90 	ld.w	r8,sp[1680]
800097c0:	2f f8       	sub	r8,-1
800097c2:	30 19       	mov	r9,1
800097c4:	fb 48 06 90 	st.w	sp[1680],r8
800097c8:	87 06       	st.w	r3[0x0],r6
800097ca:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097ce:	87 19       	st.w	r3[0x4],r9
800097d0:	2f f8       	sub	r8,-1
800097d2:	fb 48 06 8c 	st.w	sp[1676],r8
800097d6:	58 78       	cp.w	r8,7
800097d8:	e0 89 00 04 	brgt	800097e0 <_vfprintf_r+0x1cd4>
800097dc:	2f 83       	sub	r3,-8
800097de:	c0 b8       	rjmp	800097f4 <_vfprintf_r+0x1ce8>
800097e0:	fa ca f9 78 	sub	r10,sp,-1672
800097e4:	02 9b       	mov	r11,r1
800097e6:	08 9c       	mov	r12,r4
800097e8:	fe b0 f1 84 	rcall	80007af0 <__sprint_r>
800097ec:	e0 81 01 0f 	brne	80009a0a <_vfprintf_r+0x1efe>
800097f0:	fa c3 f9 e0 	sub	r3,sp,-1568
800097f4:	fa f8 06 90 	ld.w	r8,sp[1680]
800097f8:	2f f8       	sub	r8,-1
800097fa:	40 cb       	lddsp	r11,sp[0x30]
800097fc:	fb 48 06 90 	st.w	sp[1680],r8
80009800:	30 19       	mov	r9,1
80009802:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009806:	87 0b       	st.w	r3[0x0],r11
80009808:	2f f8       	sub	r8,-1
8000980a:	87 19       	st.w	r3[0x4],r9
8000980c:	fb 48 06 8c 	st.w	sp[1676],r8
80009810:	58 78       	cp.w	r8,7
80009812:	e0 89 00 05 	brgt	8000981c <_vfprintf_r+0x1d10>
80009816:	2f 83       	sub	r3,-8
80009818:	c0 c8       	rjmp	80009830 <_vfprintf_r+0x1d24>
8000981a:	d7 03       	nop
8000981c:	fa ca f9 78 	sub	r10,sp,-1672
80009820:	02 9b       	mov	r11,r1
80009822:	08 9c       	mov	r12,r4
80009824:	fe b0 f1 66 	rcall	80007af0 <__sprint_r>
80009828:	e0 81 00 f1 	brne	80009a0a <_vfprintf_r+0x1efe>
8000982c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009830:	30 08       	mov	r8,0
80009832:	30 09       	mov	r9,0
80009834:	40 5b       	lddsp	r11,sp[0x14]
80009836:	40 7a       	lddsp	r10,sp[0x1c]
80009838:	e0 a0 13 25 	rcall	8000be82 <__avr32_f64_cmp_eq>
8000983c:	40 68       	lddsp	r8,sp[0x18]
8000983e:	20 18       	sub	r8,1
80009840:	58 0c       	cp.w	r12,0
80009842:	c0 d1       	brne	8000985c <_vfprintf_r+0x1d50>
80009844:	2f f6       	sub	r6,-1
80009846:	87 18       	st.w	r3[0x4],r8
80009848:	87 06       	st.w	r3[0x0],r6
8000984a:	fa f6 06 90 	ld.w	r6,sp[1680]
8000984e:	10 06       	add	r6,r8
80009850:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009854:	fb 46 06 90 	st.w	sp[1680],r6
80009858:	2f f8       	sub	r8,-1
8000985a:	c3 18       	rjmp	800098bc <_vfprintf_r+0x1db0>
8000985c:	10 96       	mov	r6,r8
8000985e:	58 08       	cp.w	r8,0
80009860:	e0 89 00 1c 	brgt	80009898 <_vfprintf_r+0x1d8c>
80009864:	c4 b8       	rjmp	800098fa <_vfprintf_r+0x1dee>
80009866:	2f 09       	sub	r9,-16
80009868:	2f f8       	sub	r8,-1
8000986a:	fb 49 06 90 	st.w	sp[1680],r9
8000986e:	87 02       	st.w	r3[0x0],r2
80009870:	87 10       	st.w	r3[0x4],r0
80009872:	fb 48 06 8c 	st.w	sp[1676],r8
80009876:	58 78       	cp.w	r8,7
80009878:	e0 89 00 04 	brgt	80009880 <_vfprintf_r+0x1d74>
8000987c:	2f 83       	sub	r3,-8
8000987e:	c0 b8       	rjmp	80009894 <_vfprintf_r+0x1d88>
80009880:	fa ca f9 78 	sub	r10,sp,-1672
80009884:	02 9b       	mov	r11,r1
80009886:	08 9c       	mov	r12,r4
80009888:	fe b0 f1 34 	rcall	80007af0 <__sprint_r>
8000988c:	e0 81 00 bf 	brne	80009a0a <_vfprintf_r+0x1efe>
80009890:	fa c3 f9 e0 	sub	r3,sp,-1568
80009894:	21 06       	sub	r6,16
80009896:	c0 48       	rjmp	8000989e <_vfprintf_r+0x1d92>
80009898:	fe c2 bf f8 	sub	r2,pc,-16392
8000989c:	31 00       	mov	r0,16
8000989e:	fa f9 06 90 	ld.w	r9,sp[1680]
800098a2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098a6:	fe ca c0 06 	sub	r10,pc,-16378
800098aa:	59 06       	cp.w	r6,16
800098ac:	fe 99 ff dd 	brgt	80009866 <_vfprintf_r+0x1d5a>
800098b0:	0c 09       	add	r9,r6
800098b2:	87 0a       	st.w	r3[0x0],r10
800098b4:	fb 49 06 90 	st.w	sp[1680],r9
800098b8:	2f f8       	sub	r8,-1
800098ba:	87 16       	st.w	r3[0x4],r6
800098bc:	fb 48 06 8c 	st.w	sp[1676],r8
800098c0:	c0 e8       	rjmp	800098dc <_vfprintf_r+0x1dd0>
800098c2:	fa f8 06 90 	ld.w	r8,sp[1680]
800098c6:	2f f8       	sub	r8,-1
800098c8:	30 19       	mov	r9,1
800098ca:	fb 48 06 90 	st.w	sp[1680],r8
800098ce:	87 06       	st.w	r3[0x0],r6
800098d0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098d4:	87 19       	st.w	r3[0x4],r9
800098d6:	2f f8       	sub	r8,-1
800098d8:	fb 48 06 8c 	st.w	sp[1676],r8
800098dc:	58 78       	cp.w	r8,7
800098de:	e0 89 00 04 	brgt	800098e6 <_vfprintf_r+0x1dda>
800098e2:	2f 83       	sub	r3,-8
800098e4:	c0 b8       	rjmp	800098fa <_vfprintf_r+0x1dee>
800098e6:	fa ca f9 78 	sub	r10,sp,-1672
800098ea:	02 9b       	mov	r11,r1
800098ec:	08 9c       	mov	r12,r4
800098ee:	fe b0 f1 01 	rcall	80007af0 <__sprint_r>
800098f2:	e0 81 00 8c 	brne	80009a0a <_vfprintf_r+0x1efe>
800098f6:	fa c3 f9 e0 	sub	r3,sp,-1568
800098fa:	40 ea       	lddsp	r10,sp[0x38]
800098fc:	fa f8 06 90 	ld.w	r8,sp[1680]
80009900:	14 08       	add	r8,r10
80009902:	fa c9 f9 64 	sub	r9,sp,-1692
80009906:	fb 48 06 90 	st.w	sp[1680],r8
8000990a:	87 1a       	st.w	r3[0x4],r10
8000990c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009910:	87 09       	st.w	r3[0x0],r9
80009912:	2f f8       	sub	r8,-1
80009914:	fb 48 06 8c 	st.w	sp[1676],r8
80009918:	58 78       	cp.w	r8,7
8000991a:	e0 89 00 04 	brgt	80009922 <_vfprintf_r+0x1e16>
8000991e:	2f 83       	sub	r3,-8
80009920:	c0 a8       	rjmp	80009934 <_vfprintf_r+0x1e28>
80009922:	fa ca f9 78 	sub	r10,sp,-1672
80009926:	02 9b       	mov	r11,r1
80009928:	08 9c       	mov	r12,r4
8000992a:	fe b0 f0 e3 	rcall	80007af0 <__sprint_r>
8000992e:	c6 e1       	brne	80009a0a <_vfprintf_r+0x1efe>
80009930:	fa c3 f9 e0 	sub	r3,sp,-1568
80009934:	e2 15 00 04 	andl	r5,0x4,COH
80009938:	c3 f0       	breq	800099b6 <_vfprintf_r+0x1eaa>
8000993a:	40 86       	lddsp	r6,sp[0x20]
8000993c:	40 39       	lddsp	r9,sp[0xc]
8000993e:	12 16       	sub	r6,r9
80009940:	58 06       	cp.w	r6,0
80009942:	e0 89 00 1a 	brgt	80009976 <_vfprintf_r+0x1e6a>
80009946:	c3 88       	rjmp	800099b6 <_vfprintf_r+0x1eaa>
80009948:	2f 09       	sub	r9,-16
8000994a:	2f f8       	sub	r8,-1
8000994c:	fb 49 06 90 	st.w	sp[1680],r9
80009950:	87 05       	st.w	r3[0x0],r5
80009952:	87 12       	st.w	r3[0x4],r2
80009954:	fb 48 06 8c 	st.w	sp[1676],r8
80009958:	58 78       	cp.w	r8,7
8000995a:	e0 89 00 04 	brgt	80009962 <_vfprintf_r+0x1e56>
8000995e:	2f 83       	sub	r3,-8
80009960:	c0 98       	rjmp	80009972 <_vfprintf_r+0x1e66>
80009962:	00 9a       	mov	r10,r0
80009964:	02 9b       	mov	r11,r1
80009966:	08 9c       	mov	r12,r4
80009968:	fe b0 f0 c4 	rcall	80007af0 <__sprint_r>
8000996c:	c4 f1       	brne	80009a0a <_vfprintf_r+0x1efe>
8000996e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009972:	21 06       	sub	r6,16
80009974:	c0 68       	rjmp	80009980 <_vfprintf_r+0x1e74>
80009976:	fe c5 c0 e6 	sub	r5,pc,-16154
8000997a:	31 02       	mov	r2,16
8000997c:	fa c0 f9 78 	sub	r0,sp,-1672
80009980:	fa f9 06 90 	ld.w	r9,sp[1680]
80009984:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009988:	fe ca c0 f8 	sub	r10,pc,-16136
8000998c:	59 06       	cp.w	r6,16
8000998e:	fe 99 ff dd 	brgt	80009948 <_vfprintf_r+0x1e3c>
80009992:	0c 09       	add	r9,r6
80009994:	2f f8       	sub	r8,-1
80009996:	87 0a       	st.w	r3[0x0],r10
80009998:	87 16       	st.w	r3[0x4],r6
8000999a:	fb 49 06 90 	st.w	sp[1680],r9
8000999e:	fb 48 06 8c 	st.w	sp[1676],r8
800099a2:	58 78       	cp.w	r8,7
800099a4:	e0 8a 00 09 	brle	800099b6 <_vfprintf_r+0x1eaa>
800099a8:	fa ca f9 78 	sub	r10,sp,-1672
800099ac:	02 9b       	mov	r11,r1
800099ae:	08 9c       	mov	r12,r4
800099b0:	fe b0 f0 a0 	rcall	80007af0 <__sprint_r>
800099b4:	c2 b1       	brne	80009a0a <_vfprintf_r+0x1efe>
800099b6:	40 bc       	lddsp	r12,sp[0x2c]
800099b8:	40 36       	lddsp	r6,sp[0xc]
800099ba:	40 8e       	lddsp	lr,sp[0x20]
800099bc:	ec 0e 0c 48 	max	r8,r6,lr
800099c0:	10 0c       	add	r12,r8
800099c2:	50 bc       	stdsp	sp[0x2c],r12
800099c4:	fa f8 06 90 	ld.w	r8,sp[1680]
800099c8:	58 08       	cp.w	r8,0
800099ca:	c0 80       	breq	800099da <_vfprintf_r+0x1ece>
800099cc:	fa ca f9 78 	sub	r10,sp,-1672
800099d0:	02 9b       	mov	r11,r1
800099d2:	08 9c       	mov	r12,r4
800099d4:	fe b0 f0 8e 	rcall	80007af0 <__sprint_r>
800099d8:	c1 91       	brne	80009a0a <_vfprintf_r+0x1efe>
800099da:	30 0b       	mov	r11,0
800099dc:	fa c3 f9 e0 	sub	r3,sp,-1568
800099e0:	fb 4b 06 8c 	st.w	sp[1676],r11
800099e4:	fe 9f f1 22 	bral	80007c28 <_vfprintf_r+0x11c>
800099e8:	08 95       	mov	r5,r4
800099ea:	fa f8 06 90 	ld.w	r8,sp[1680]
800099ee:	58 08       	cp.w	r8,0
800099f0:	c0 80       	breq	80009a00 <_vfprintf_r+0x1ef4>
800099f2:	08 9c       	mov	r12,r4
800099f4:	fa ca f9 78 	sub	r10,sp,-1672
800099f8:	02 9b       	mov	r11,r1
800099fa:	fe b0 f0 7b 	rcall	80007af0 <__sprint_r>
800099fe:	c0 61       	brne	80009a0a <_vfprintf_r+0x1efe>
80009a00:	30 08       	mov	r8,0
80009a02:	fb 48 06 8c 	st.w	sp[1676],r8
80009a06:	c0 28       	rjmp	80009a0a <_vfprintf_r+0x1efe>
80009a08:	40 41       	lddsp	r1,sp[0x10]
80009a0a:	82 68       	ld.sh	r8,r1[0xc]
80009a0c:	ed b8 00 06 	bld	r8,0x6
80009a10:	c0 31       	brne	80009a16 <_vfprintf_r+0x1f0a>
80009a12:	3f fa       	mov	r10,-1
80009a14:	50 ba       	stdsp	sp[0x2c],r10
80009a16:	40 bc       	lddsp	r12,sp[0x2c]
80009a18:	fe 3d f9 44 	sub	sp,-1724
80009a1c:	d8 32       	popm	r0-r7,pc
80009a1e:	d7 03       	nop

80009a20 <__swsetup_r>:
80009a20:	d4 21       	pushm	r4-r7,lr
80009a22:	e0 68 0a 40 	mov	r8,2624
80009a26:	18 96       	mov	r6,r12
80009a28:	16 97       	mov	r7,r11
80009a2a:	70 0c       	ld.w	r12,r8[0x0]
80009a2c:	58 0c       	cp.w	r12,0
80009a2e:	c0 60       	breq	80009a3a <__swsetup_r+0x1a>
80009a30:	78 68       	ld.w	r8,r12[0x18]
80009a32:	58 08       	cp.w	r8,0
80009a34:	c0 31       	brne	80009a3a <__swsetup_r+0x1a>
80009a36:	e0 a0 07 bf 	rcall	8000a9b4 <__sinit>
80009a3a:	fe c8 c0 7a 	sub	r8,pc,-16262
80009a3e:	10 37       	cp.w	r7,r8
80009a40:	c0 61       	brne	80009a4c <__swsetup_r+0x2c>
80009a42:	e0 68 0a 40 	mov	r8,2624
80009a46:	70 08       	ld.w	r8,r8[0x0]
80009a48:	70 07       	ld.w	r7,r8[0x0]
80009a4a:	c1 28       	rjmp	80009a6e <__swsetup_r+0x4e>
80009a4c:	fe c8 c0 6c 	sub	r8,pc,-16276
80009a50:	10 37       	cp.w	r7,r8
80009a52:	c0 61       	brne	80009a5e <__swsetup_r+0x3e>
80009a54:	e0 68 0a 40 	mov	r8,2624
80009a58:	70 08       	ld.w	r8,r8[0x0]
80009a5a:	70 17       	ld.w	r7,r8[0x4]
80009a5c:	c0 98       	rjmp	80009a6e <__swsetup_r+0x4e>
80009a5e:	fe c8 c0 5e 	sub	r8,pc,-16290
80009a62:	10 37       	cp.w	r7,r8
80009a64:	c0 51       	brne	80009a6e <__swsetup_r+0x4e>
80009a66:	e0 68 0a 40 	mov	r8,2624
80009a6a:	70 08       	ld.w	r8,r8[0x0]
80009a6c:	70 27       	ld.w	r7,r8[0x8]
80009a6e:	8e 68       	ld.sh	r8,r7[0xc]
80009a70:	ed b8 00 03 	bld	r8,0x3
80009a74:	c1 e0       	breq	80009ab0 <__swsetup_r+0x90>
80009a76:	ed b8 00 04 	bld	r8,0x4
80009a7a:	c3 e1       	brne	80009af6 <__swsetup_r+0xd6>
80009a7c:	ed b8 00 02 	bld	r8,0x2
80009a80:	c1 51       	brne	80009aaa <__swsetup_r+0x8a>
80009a82:	6e db       	ld.w	r11,r7[0x34]
80009a84:	58 0b       	cp.w	r11,0
80009a86:	c0 a0       	breq	80009a9a <__swsetup_r+0x7a>
80009a88:	ee c8 ff bc 	sub	r8,r7,-68
80009a8c:	10 3b       	cp.w	r11,r8
80009a8e:	c0 40       	breq	80009a96 <__swsetup_r+0x76>
80009a90:	0c 9c       	mov	r12,r6
80009a92:	e0 a0 08 2b 	rcall	8000aae8 <_free_r>
80009a96:	30 08       	mov	r8,0
80009a98:	8f d8       	st.w	r7[0x34],r8
80009a9a:	8e 68       	ld.sh	r8,r7[0xc]
80009a9c:	e0 18 ff db 	andl	r8,0xffdb
80009aa0:	ae 68       	st.h	r7[0xc],r8
80009aa2:	30 08       	mov	r8,0
80009aa4:	8f 18       	st.w	r7[0x4],r8
80009aa6:	6e 48       	ld.w	r8,r7[0x10]
80009aa8:	8f 08       	st.w	r7[0x0],r8
80009aaa:	8e 68       	ld.sh	r8,r7[0xc]
80009aac:	a3 b8       	sbr	r8,0x3
80009aae:	ae 68       	st.h	r7[0xc],r8
80009ab0:	6e 48       	ld.w	r8,r7[0x10]
80009ab2:	58 08       	cp.w	r8,0
80009ab4:	c0 b1       	brne	80009aca <__swsetup_r+0xaa>
80009ab6:	8e 68       	ld.sh	r8,r7[0xc]
80009ab8:	e2 18 02 80 	andl	r8,0x280,COH
80009abc:	e0 48 02 00 	cp.w	r8,512
80009ac0:	c0 50       	breq	80009aca <__swsetup_r+0xaa>
80009ac2:	0c 9c       	mov	r12,r6
80009ac4:	0e 9b       	mov	r11,r7
80009ac6:	e0 a0 0a 4b 	rcall	8000af5c <__smakebuf_r>
80009aca:	8e 69       	ld.sh	r9,r7[0xc]
80009acc:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009ad0:	c0 70       	breq	80009ade <__swsetup_r+0xbe>
80009ad2:	30 08       	mov	r8,0
80009ad4:	8f 28       	st.w	r7[0x8],r8
80009ad6:	6e 58       	ld.w	r8,r7[0x14]
80009ad8:	5c 38       	neg	r8
80009ada:	8f 68       	st.w	r7[0x18],r8
80009adc:	c0 68       	rjmp	80009ae8 <__swsetup_r+0xc8>
80009ade:	ed b9 00 01 	bld	r9,0x1
80009ae2:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009ae6:	8f 28       	st.w	r7[0x8],r8
80009ae8:	6e 48       	ld.w	r8,r7[0x10]
80009aea:	58 08       	cp.w	r8,0
80009aec:	c0 61       	brne	80009af8 <__swsetup_r+0xd8>
80009aee:	8e 68       	ld.sh	r8,r7[0xc]
80009af0:	ed b8 00 07 	bld	r8,0x7
80009af4:	c0 21       	brne	80009af8 <__swsetup_r+0xd8>
80009af6:	dc 2a       	popm	r4-r7,pc,r12=-1
80009af8:	d8 2a       	popm	r4-r7,pc,r12=0
80009afa:	d7 03       	nop

80009afc <quorem>:
80009afc:	d4 31       	pushm	r0-r7,lr
80009afe:	20 2d       	sub	sp,8
80009b00:	18 97       	mov	r7,r12
80009b02:	78 48       	ld.w	r8,r12[0x10]
80009b04:	76 46       	ld.w	r6,r11[0x10]
80009b06:	0c 38       	cp.w	r8,r6
80009b08:	c0 34       	brge	80009b0e <quorem+0x12>
80009b0a:	30 0c       	mov	r12,0
80009b0c:	c8 58       	rjmp	80009c16 <quorem+0x11a>
80009b0e:	ec c2 ff fc 	sub	r2,r6,-4
80009b12:	f6 c3 ff ec 	sub	r3,r11,-20
80009b16:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80009b1a:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009b1e:	2f f9       	sub	r9,-1
80009b20:	20 16       	sub	r6,1
80009b22:	f8 09 0d 08 	divu	r8,r12,r9
80009b26:	f6 02 00 22 	add	r2,r11,r2<<0x2
80009b2a:	ee c4 ff ec 	sub	r4,r7,-20
80009b2e:	10 95       	mov	r5,r8
80009b30:	58 08       	cp.w	r8,0
80009b32:	c4 10       	breq	80009bb4 <quorem+0xb8>
80009b34:	30 09       	mov	r9,0
80009b36:	06 9a       	mov	r10,r3
80009b38:	08 98       	mov	r8,r4
80009b3a:	12 91       	mov	r1,r9
80009b3c:	50 0b       	stdsp	sp[0x0],r11
80009b3e:	70 0e       	ld.w	lr,r8[0x0]
80009b40:	b1 8e       	lsr	lr,0x10
80009b42:	50 1e       	stdsp	sp[0x4],lr
80009b44:	15 0e       	ld.w	lr,r10++
80009b46:	fc 00 16 10 	lsr	r0,lr,0x10
80009b4a:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80009b4e:	ea 0e 03 41 	mac	r1,r5,lr
80009b52:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80009b56:	b1 81       	lsr	r1,0x10
80009b58:	40 1b       	lddsp	r11,sp[0x4]
80009b5a:	ea 00 02 40 	mul	r0,r5,r0
80009b5e:	e2 00 00 00 	add	r0,r1,r0
80009b62:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80009b66:	02 1b       	sub	r11,r1
80009b68:	50 1b       	stdsp	sp[0x4],r11
80009b6a:	70 0b       	ld.w	r11,r8[0x0]
80009b6c:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009b70:	02 09       	add	r9,r1
80009b72:	f2 0e 01 0e 	sub	lr,r9,lr
80009b76:	b0 1e       	st.h	r8[0x2],lr
80009b78:	fc 09 14 10 	asr	r9,lr,0x10
80009b7c:	40 1e       	lddsp	lr,sp[0x4]
80009b7e:	fc 09 00 09 	add	r9,lr,r9
80009b82:	b0 09       	st.h	r8[0x0],r9
80009b84:	e0 01 16 10 	lsr	r1,r0,0x10
80009b88:	2f c8       	sub	r8,-4
80009b8a:	b1 49       	asr	r9,0x10
80009b8c:	04 3a       	cp.w	r10,r2
80009b8e:	fe 98 ff d8 	brls	80009b3e <quorem+0x42>
80009b92:	40 0b       	lddsp	r11,sp[0x0]
80009b94:	58 0c       	cp.w	r12,0
80009b96:	c0 f1       	brne	80009bb4 <quorem+0xb8>
80009b98:	ec c8 ff fb 	sub	r8,r6,-5
80009b9c:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009ba0:	c0 28       	rjmp	80009ba4 <quorem+0xa8>
80009ba2:	20 16       	sub	r6,1
80009ba4:	20 48       	sub	r8,4
80009ba6:	08 38       	cp.w	r8,r4
80009ba8:	e0 88 00 05 	brls	80009bb2 <quorem+0xb6>
80009bac:	70 09       	ld.w	r9,r8[0x0]
80009bae:	58 09       	cp.w	r9,0
80009bb0:	cf 90       	breq	80009ba2 <quorem+0xa6>
80009bb2:	8f 46       	st.w	r7[0x10],r6
80009bb4:	0e 9c       	mov	r12,r7
80009bb6:	e0 a0 0a d2 	rcall	8000b15a <__mcmp>
80009bba:	c2 d5       	brlt	80009c14 <quorem+0x118>
80009bbc:	2f f5       	sub	r5,-1
80009bbe:	08 98       	mov	r8,r4
80009bc0:	30 09       	mov	r9,0
80009bc2:	07 0b       	ld.w	r11,r3++
80009bc4:	f6 0a 16 10 	lsr	r10,r11,0x10
80009bc8:	70 0c       	ld.w	r12,r8[0x0]
80009bca:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009bce:	f8 0e 16 10 	lsr	lr,r12,0x10
80009bd2:	14 1e       	sub	lr,r10
80009bd4:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009bd8:	16 1a       	sub	r10,r11
80009bda:	12 0a       	add	r10,r9
80009bdc:	b0 1a       	st.h	r8[0x2],r10
80009bde:	b1 4a       	asr	r10,0x10
80009be0:	fc 0a 00 09 	add	r9,lr,r10
80009be4:	b0 09       	st.h	r8[0x0],r9
80009be6:	2f c8       	sub	r8,-4
80009be8:	b1 49       	asr	r9,0x10
80009bea:	04 33       	cp.w	r3,r2
80009bec:	fe 98 ff eb 	brls	80009bc2 <quorem+0xc6>
80009bf0:	ec c8 ff fb 	sub	r8,r6,-5
80009bf4:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80009bf8:	58 09       	cp.w	r9,0
80009bfa:	c0 d1       	brne	80009c14 <quorem+0x118>
80009bfc:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009c00:	c0 28       	rjmp	80009c04 <quorem+0x108>
80009c02:	20 16       	sub	r6,1
80009c04:	20 48       	sub	r8,4
80009c06:	08 38       	cp.w	r8,r4
80009c08:	e0 88 00 05 	brls	80009c12 <quorem+0x116>
80009c0c:	70 09       	ld.w	r9,r8[0x0]
80009c0e:	58 09       	cp.w	r9,0
80009c10:	cf 90       	breq	80009c02 <quorem+0x106>
80009c12:	8f 46       	st.w	r7[0x10],r6
80009c14:	0a 9c       	mov	r12,r5
80009c16:	2f ed       	sub	sp,-8
80009c18:	d8 32       	popm	r0-r7,pc
80009c1a:	d7 03       	nop

80009c1c <_dtoa_r>:
80009c1c:	d4 31       	pushm	r0-r7,lr
80009c1e:	21 ad       	sub	sp,104
80009c20:	fa c4 ff 74 	sub	r4,sp,-140
80009c24:	18 97       	mov	r7,r12
80009c26:	16 95       	mov	r5,r11
80009c28:	68 2c       	ld.w	r12,r4[0x8]
80009c2a:	50 c9       	stdsp	sp[0x30],r9
80009c2c:	68 16       	ld.w	r6,r4[0x4]
80009c2e:	68 09       	ld.w	r9,r4[0x0]
80009c30:	50 e8       	stdsp	sp[0x38],r8
80009c32:	14 94       	mov	r4,r10
80009c34:	51 2c       	stdsp	sp[0x48],r12
80009c36:	fa e5 00 08 	st.d	sp[8],r4
80009c3a:	51 59       	stdsp	sp[0x54],r9
80009c3c:	6e 95       	ld.w	r5,r7[0x24]
80009c3e:	58 05       	cp.w	r5,0
80009c40:	c0 91       	brne	80009c52 <_dtoa_r+0x36>
80009c42:	31 0c       	mov	r12,16
80009c44:	fe b0 e8 f4 	rcall	80006e2c <malloc>
80009c48:	99 35       	st.w	r12[0xc],r5
80009c4a:	8f 9c       	st.w	r7[0x24],r12
80009c4c:	99 15       	st.w	r12[0x4],r5
80009c4e:	99 25       	st.w	r12[0x8],r5
80009c50:	99 05       	st.w	r12[0x0],r5
80009c52:	6e 99       	ld.w	r9,r7[0x24]
80009c54:	72 08       	ld.w	r8,r9[0x0]
80009c56:	58 08       	cp.w	r8,0
80009c58:	c0 f0       	breq	80009c76 <_dtoa_r+0x5a>
80009c5a:	72 1a       	ld.w	r10,r9[0x4]
80009c5c:	91 1a       	st.w	r8[0x4],r10
80009c5e:	30 1a       	mov	r10,1
80009c60:	72 19       	ld.w	r9,r9[0x4]
80009c62:	f4 09 09 49 	lsl	r9,r10,r9
80009c66:	10 9b       	mov	r11,r8
80009c68:	91 29       	st.w	r8[0x8],r9
80009c6a:	0e 9c       	mov	r12,r7
80009c6c:	e0 a0 0a 90 	rcall	8000b18c <_Bfree>
80009c70:	6e 98       	ld.w	r8,r7[0x24]
80009c72:	30 09       	mov	r9,0
80009c74:	91 09       	st.w	r8[0x0],r9
80009c76:	40 28       	lddsp	r8,sp[0x8]
80009c78:	10 94       	mov	r4,r8
80009c7a:	58 08       	cp.w	r8,0
80009c7c:	c0 64       	brge	80009c88 <_dtoa_r+0x6c>
80009c7e:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009c82:	50 28       	stdsp	sp[0x8],r8
80009c84:	30 18       	mov	r8,1
80009c86:	c0 28       	rjmp	80009c8a <_dtoa_r+0x6e>
80009c88:	30 08       	mov	r8,0
80009c8a:	8d 08       	st.w	r6[0x0],r8
80009c8c:	fc 1c 7f f0 	movh	r12,0x7ff0
80009c90:	40 26       	lddsp	r6,sp[0x8]
80009c92:	0c 98       	mov	r8,r6
80009c94:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009c98:	18 38       	cp.w	r8,r12
80009c9a:	c2 01       	brne	80009cda <_dtoa_r+0xbe>
80009c9c:	e0 68 27 0f 	mov	r8,9999
80009ca0:	41 5b       	lddsp	r11,sp[0x54]
80009ca2:	97 08       	st.w	r11[0x0],r8
80009ca4:	40 3a       	lddsp	r10,sp[0xc]
80009ca6:	58 0a       	cp.w	r10,0
80009ca8:	c0 71       	brne	80009cb6 <_dtoa_r+0x9a>
80009caa:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009cae:	c0 41       	brne	80009cb6 <_dtoa_r+0x9a>
80009cb0:	fe cc c3 00 	sub	r12,pc,-15616
80009cb4:	c0 38       	rjmp	80009cba <_dtoa_r+0x9e>
80009cb6:	fe cc c2 fa 	sub	r12,pc,-15622
80009cba:	41 29       	lddsp	r9,sp[0x48]
80009cbc:	58 09       	cp.w	r9,0
80009cbe:	e0 80 05 9a 	breq	8000a7f2 <_dtoa_r+0xbd6>
80009cc2:	f8 c8 ff fd 	sub	r8,r12,-3
80009cc6:	f8 c9 ff f8 	sub	r9,r12,-8
80009cca:	11 8b       	ld.ub	r11,r8[0x0]
80009ccc:	30 0a       	mov	r10,0
80009cce:	41 25       	lddsp	r5,sp[0x48]
80009cd0:	f4 0b 18 00 	cp.b	r11,r10
80009cd4:	f2 08 17 10 	movne	r8,r9
80009cd8:	c1 68       	rjmp	80009d04 <_dtoa_r+0xe8>
80009cda:	fa ea 00 08 	ld.d	r10,sp[8]
80009cde:	30 08       	mov	r8,0
80009ce0:	fa eb 00 3c 	st.d	sp[60],r10
80009ce4:	30 09       	mov	r9,0
80009ce6:	e0 a0 10 ce 	rcall	8000be82 <__avr32_f64_cmp_eq>
80009cea:	c1 00       	breq	80009d0a <_dtoa_r+0xee>
80009cec:	30 18       	mov	r8,1
80009cee:	41 5a       	lddsp	r10,sp[0x54]
80009cf0:	95 08       	st.w	r10[0x0],r8
80009cf2:	fe cc c4 66 	sub	r12,pc,-15258
80009cf6:	41 29       	lddsp	r9,sp[0x48]
80009cf8:	f8 08 00 08 	add	r8,r12,r8
80009cfc:	58 09       	cp.w	r9,0
80009cfe:	e0 80 05 7a 	breq	8000a7f2 <_dtoa_r+0xbd6>
80009d02:	12 95       	mov	r5,r9
80009d04:	8b 08       	st.w	r5[0x0],r8
80009d06:	e0 8f 05 76 	bral	8000a7f2 <_dtoa_r+0xbd6>
80009d0a:	fa c8 ff 9c 	sub	r8,sp,-100
80009d0e:	fa c9 ff a0 	sub	r9,sp,-96
80009d12:	fa ea 00 3c 	ld.d	r10,sp[60]
80009d16:	0e 9c       	mov	r12,r7
80009d18:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80009d1c:	e0 a0 0a 8a 	rcall	8000b230 <__d2b>
80009d20:	18 93       	mov	r3,r12
80009d22:	58 05       	cp.w	r5,0
80009d24:	c0 d0       	breq	80009d3e <_dtoa_r+0x122>
80009d26:	fa ea 00 3c 	ld.d	r10,sp[60]
80009d2a:	30 04       	mov	r4,0
80009d2c:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80009d30:	ea c5 03 ff 	sub	r5,r5,1023
80009d34:	10 9b       	mov	r11,r8
80009d36:	51 74       	stdsp	sp[0x5c],r4
80009d38:	ea 1b 3f f0 	orh	r11,0x3ff0
80009d3c:	c2 58       	rjmp	80009d86 <_dtoa_r+0x16a>
80009d3e:	41 88       	lddsp	r8,sp[0x60]
80009d40:	41 9c       	lddsp	r12,sp[0x64]
80009d42:	10 0c       	add	r12,r8
80009d44:	f8 c5 fb ce 	sub	r5,r12,-1074
80009d48:	e0 45 00 20 	cp.w	r5,32
80009d4c:	e0 8a 00 0e 	brle	80009d68 <_dtoa_r+0x14c>
80009d50:	f8 cc fb ee 	sub	r12,r12,-1042
80009d54:	40 3b       	lddsp	r11,sp[0xc]
80009d56:	ea 08 11 40 	rsub	r8,r5,64
80009d5a:	f6 0c 0a 4c 	lsr	r12,r11,r12
80009d5e:	ec 08 09 46 	lsl	r6,r6,r8
80009d62:	0c 4c       	or	r12,r6
80009d64:	c0 78       	rjmp	80009d72 <_dtoa_r+0x156>
80009d66:	d7 03       	nop
80009d68:	ea 0c 11 20 	rsub	r12,r5,32
80009d6c:	40 3a       	lddsp	r10,sp[0xc]
80009d6e:	f4 0c 09 4c 	lsl	r12,r10,r12
80009d72:	e0 a0 10 14 	rcall	8000bd9a <__avr32_u32_to_f64>
80009d76:	fc 18 fe 10 	movh	r8,0xfe10
80009d7a:	30 19       	mov	r9,1
80009d7c:	ea c5 04 33 	sub	r5,r5,1075
80009d80:	f0 0b 00 0b 	add	r11,r8,r11
80009d84:	51 79       	stdsp	sp[0x5c],r9
80009d86:	30 08       	mov	r8,0
80009d88:	fc 19 3f f8 	movh	r9,0x3ff8
80009d8c:	e0 a0 0e 9c 	rcall	8000bac4 <__avr32_f64_sub>
80009d90:	e0 68 43 61 	mov	r8,17249
80009d94:	ea 18 63 6f 	orh	r8,0x636f
80009d98:	e0 69 87 a7 	mov	r9,34727
80009d9c:	ea 19 3f d2 	orh	r9,0x3fd2
80009da0:	e0 a0 0d a6 	rcall	8000b8ec <__avr32_f64_mul>
80009da4:	e0 68 c8 b3 	mov	r8,51379
80009da8:	ea 18 8b 60 	orh	r8,0x8b60
80009dac:	e0 69 8a 28 	mov	r9,35368
80009db0:	ea 19 3f c6 	orh	r9,0x3fc6
80009db4:	e0 a0 0f 56 	rcall	8000bc60 <__avr32_f64_add>
80009db8:	0a 9c       	mov	r12,r5
80009dba:	14 90       	mov	r0,r10
80009dbc:	16 91       	mov	r1,r11
80009dbe:	e0 a0 0f f2 	rcall	8000bda2 <__avr32_s32_to_f64>
80009dc2:	e0 68 79 fb 	mov	r8,31227
80009dc6:	ea 18 50 9f 	orh	r8,0x509f
80009dca:	e0 69 44 13 	mov	r9,17427
80009dce:	ea 19 3f d3 	orh	r9,0x3fd3
80009dd2:	e0 a0 0d 8d 	rcall	8000b8ec <__avr32_f64_mul>
80009dd6:	14 98       	mov	r8,r10
80009dd8:	16 99       	mov	r9,r11
80009dda:	00 9a       	mov	r10,r0
80009ddc:	02 9b       	mov	r11,r1
80009dde:	e0 a0 0f 41 	rcall	8000bc60 <__avr32_f64_add>
80009de2:	14 90       	mov	r0,r10
80009de4:	16 91       	mov	r1,r11
80009de6:	e0 a0 0f c7 	rcall	8000bd74 <__avr32_f64_to_s32>
80009dea:	30 08       	mov	r8,0
80009dec:	18 96       	mov	r6,r12
80009dee:	30 09       	mov	r9,0
80009df0:	00 9a       	mov	r10,r0
80009df2:	02 9b       	mov	r11,r1
80009df4:	e0 a0 10 8e 	rcall	8000bf10 <__avr32_f64_cmp_lt>
80009df8:	c0 c0       	breq	80009e10 <_dtoa_r+0x1f4>
80009dfa:	0c 9c       	mov	r12,r6
80009dfc:	e0 a0 0f d3 	rcall	8000bda2 <__avr32_s32_to_f64>
80009e00:	14 98       	mov	r8,r10
80009e02:	16 99       	mov	r9,r11
80009e04:	00 9a       	mov	r10,r0
80009e06:	02 9b       	mov	r11,r1
80009e08:	e0 a0 10 3d 	rcall	8000be82 <__avr32_f64_cmp_eq>
80009e0c:	f7 b6 00 01 	subeq	r6,1
80009e10:	59 66       	cp.w	r6,22
80009e12:	e0 88 00 05 	brls	80009e1c <_dtoa_r+0x200>
80009e16:	30 18       	mov	r8,1
80009e18:	51 48       	stdsp	sp[0x50],r8
80009e1a:	c1 38       	rjmp	80009e40 <_dtoa_r+0x224>
80009e1c:	fe c8 c3 ac 	sub	r8,pc,-15444
80009e20:	fa ea 00 3c 	ld.d	r10,sp[60]
80009e24:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
80009e28:	e0 a0 10 74 	rcall	8000bf10 <__avr32_f64_cmp_lt>
80009e2c:	f9 b4 00 00 	moveq	r4,0
80009e30:	fb f4 0a 14 	st.weq	sp[0x50],r4
80009e34:	f7 b6 01 01 	subne	r6,1
80009e38:	f9 bc 01 00 	movne	r12,0
80009e3c:	fb fc 1a 14 	st.wne	sp[0x50],r12
80009e40:	41 90       	lddsp	r0,sp[0x64]
80009e42:	20 10       	sub	r0,1
80009e44:	0a 10       	sub	r0,r5
80009e46:	c0 46       	brmi	80009e4e <_dtoa_r+0x232>
80009e48:	50 40       	stdsp	sp[0x10],r0
80009e4a:	30 00       	mov	r0,0
80009e4c:	c0 48       	rjmp	80009e54 <_dtoa_r+0x238>
80009e4e:	30 0b       	mov	r11,0
80009e50:	5c 30       	neg	r0
80009e52:	50 4b       	stdsp	sp[0x10],r11
80009e54:	ec 02 11 00 	rsub	r2,r6,0
80009e58:	58 06       	cp.w	r6,0
80009e5a:	fb fa 40 04 	ld.wge	r10,sp[0x10]
80009e5e:	f5 d6 e4 0a 	addge	r10,r10,r6
80009e62:	fb fa 4a 04 	st.wge	sp[0x10],r10
80009e66:	fb f6 4a 11 	st.wge	sp[0x44],r6
80009e6a:	f9 b2 04 00 	movge	r2,0
80009e6e:	e1 d6 e5 10 	sublt	r0,r0,r6
80009e72:	f9 b9 05 00 	movlt	r9,0
80009e76:	fb f9 5a 11 	st.wlt	sp[0x44],r9
80009e7a:	40 c8       	lddsp	r8,sp[0x30]
80009e7c:	58 98       	cp.w	r8,9
80009e7e:	e0 8b 00 20 	brhi	80009ebe <_dtoa_r+0x2a2>
80009e82:	58 58       	cp.w	r8,5
80009e84:	f9 b4 0a 01 	movle	r4,1
80009e88:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80009e8c:	f7 b5 09 04 	subgt	r5,4
80009e90:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80009e94:	f9 b4 09 00 	movgt	r4,0
80009e98:	40 cc       	lddsp	r12,sp[0x30]
80009e9a:	58 3c       	cp.w	r12,3
80009e9c:	c2 d0       	breq	80009ef6 <_dtoa_r+0x2da>
80009e9e:	e0 89 00 05 	brgt	80009ea8 <_dtoa_r+0x28c>
80009ea2:	58 2c       	cp.w	r12,2
80009ea4:	c1 01       	brne	80009ec4 <_dtoa_r+0x2a8>
80009ea6:	c1 88       	rjmp	80009ed6 <_dtoa_r+0x2ba>
80009ea8:	40 cb       	lddsp	r11,sp[0x30]
80009eaa:	58 4b       	cp.w	r11,4
80009eac:	c0 60       	breq	80009eb8 <_dtoa_r+0x29c>
80009eae:	58 5b       	cp.w	r11,5
80009eb0:	c0 a1       	brne	80009ec4 <_dtoa_r+0x2a8>
80009eb2:	30 1a       	mov	r10,1
80009eb4:	50 da       	stdsp	sp[0x34],r10
80009eb6:	c2 28       	rjmp	80009efa <_dtoa_r+0x2de>
80009eb8:	30 19       	mov	r9,1
80009eba:	50 d9       	stdsp	sp[0x34],r9
80009ebc:	c0 f8       	rjmp	80009eda <_dtoa_r+0x2be>
80009ebe:	30 08       	mov	r8,0
80009ec0:	30 14       	mov	r4,1
80009ec2:	50 c8       	stdsp	sp[0x30],r8
80009ec4:	3f f5       	mov	r5,-1
80009ec6:	30 1c       	mov	r12,1
80009ec8:	30 0b       	mov	r11,0
80009eca:	50 95       	stdsp	sp[0x24],r5
80009ecc:	50 dc       	stdsp	sp[0x34],r12
80009ece:	0a 91       	mov	r1,r5
80009ed0:	31 28       	mov	r8,18
80009ed2:	50 eb       	stdsp	sp[0x38],r11
80009ed4:	c2 08       	rjmp	80009f14 <_dtoa_r+0x2f8>
80009ed6:	30 0a       	mov	r10,0
80009ed8:	50 da       	stdsp	sp[0x34],r10
80009eda:	40 e9       	lddsp	r9,sp[0x38]
80009edc:	58 09       	cp.w	r9,0
80009ede:	e0 89 00 07 	brgt	80009eec <_dtoa_r+0x2d0>
80009ee2:	30 18       	mov	r8,1
80009ee4:	50 98       	stdsp	sp[0x24],r8
80009ee6:	10 91       	mov	r1,r8
80009ee8:	50 e8       	stdsp	sp[0x38],r8
80009eea:	c1 58       	rjmp	80009f14 <_dtoa_r+0x2f8>
80009eec:	40 e5       	lddsp	r5,sp[0x38]
80009eee:	50 95       	stdsp	sp[0x24],r5
80009ef0:	0a 91       	mov	r1,r5
80009ef2:	0a 98       	mov	r8,r5
80009ef4:	c1 08       	rjmp	80009f14 <_dtoa_r+0x2f8>
80009ef6:	30 0c       	mov	r12,0
80009ef8:	50 dc       	stdsp	sp[0x34],r12
80009efa:	40 eb       	lddsp	r11,sp[0x38]
80009efc:	ec 0b 00 0b 	add	r11,r6,r11
80009f00:	50 9b       	stdsp	sp[0x24],r11
80009f02:	16 98       	mov	r8,r11
80009f04:	2f f8       	sub	r8,-1
80009f06:	58 08       	cp.w	r8,0
80009f08:	e0 89 00 05 	brgt	80009f12 <_dtoa_r+0x2f6>
80009f0c:	10 91       	mov	r1,r8
80009f0e:	30 18       	mov	r8,1
80009f10:	c0 28       	rjmp	80009f14 <_dtoa_r+0x2f8>
80009f12:	10 91       	mov	r1,r8
80009f14:	30 09       	mov	r9,0
80009f16:	6e 9a       	ld.w	r10,r7[0x24]
80009f18:	95 19       	st.w	r10[0x4],r9
80009f1a:	30 49       	mov	r9,4
80009f1c:	c0 68       	rjmp	80009f28 <_dtoa_r+0x30c>
80009f1e:	d7 03       	nop
80009f20:	6a 1a       	ld.w	r10,r5[0x4]
80009f22:	a1 79       	lsl	r9,0x1
80009f24:	2f fa       	sub	r10,-1
80009f26:	8b 1a       	st.w	r5[0x4],r10
80009f28:	6e 95       	ld.w	r5,r7[0x24]
80009f2a:	f2 ca ff ec 	sub	r10,r9,-20
80009f2e:	10 3a       	cp.w	r10,r8
80009f30:	fe 98 ff f8 	brls	80009f20 <_dtoa_r+0x304>
80009f34:	6a 1b       	ld.w	r11,r5[0x4]
80009f36:	0e 9c       	mov	r12,r7
80009f38:	e0 a0 09 44 	rcall	8000b1c0 <_Balloc>
80009f3c:	58 e1       	cp.w	r1,14
80009f3e:	5f 88       	srls	r8
80009f40:	8b 0c       	st.w	r5[0x0],r12
80009f42:	f1 e4 00 04 	and	r4,r8,r4
80009f46:	6e 98       	ld.w	r8,r7[0x24]
80009f48:	70 08       	ld.w	r8,r8[0x0]
80009f4a:	50 88       	stdsp	sp[0x20],r8
80009f4c:	e0 80 01 82 	breq	8000a250 <_dtoa_r+0x634>
80009f50:	58 06       	cp.w	r6,0
80009f52:	e0 8a 00 43 	brle	80009fd8 <_dtoa_r+0x3bc>
80009f56:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
80009f5a:	fe c8 c4 ea 	sub	r8,pc,-15126
80009f5e:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
80009f62:	fa e5 00 18 	st.d	sp[24],r4
80009f66:	ec 04 14 04 	asr	r4,r6,0x4
80009f6a:	ed b4 00 04 	bld	r4,0x4
80009f6e:	c0 30       	breq	80009f74 <_dtoa_r+0x358>
80009f70:	30 25       	mov	r5,2
80009f72:	c1 08       	rjmp	80009f92 <_dtoa_r+0x376>
80009f74:	fe c8 c4 3c 	sub	r8,pc,-15300
80009f78:	f0 e8 00 20 	ld.d	r8,r8[32]
80009f7c:	fa ea 00 3c 	ld.d	r10,sp[60]
80009f80:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80009f84:	e0 a0 0f fa 	rcall	8000bf78 <__avr32_f64_div>
80009f88:	30 35       	mov	r5,3
80009f8a:	14 98       	mov	r8,r10
80009f8c:	16 99       	mov	r9,r11
80009f8e:	fa e9 00 08 	st.d	sp[8],r8
80009f92:	fe cc c4 5a 	sub	r12,pc,-15270
80009f96:	50 a3       	stdsp	sp[0x28],r3
80009f98:	0c 93       	mov	r3,r6
80009f9a:	18 96       	mov	r6,r12
80009f9c:	c0 f8       	rjmp	80009fba <_dtoa_r+0x39e>
80009f9e:	fa ea 00 18 	ld.d	r10,sp[24]
80009fa2:	ed b4 00 00 	bld	r4,0x0
80009fa6:	c0 81       	brne	80009fb6 <_dtoa_r+0x39a>
80009fa8:	ec e8 00 00 	ld.d	r8,r6[0]
80009fac:	2f f5       	sub	r5,-1
80009fae:	e0 a0 0c 9f 	rcall	8000b8ec <__avr32_f64_mul>
80009fb2:	fa eb 00 18 	st.d	sp[24],r10
80009fb6:	a1 54       	asr	r4,0x1
80009fb8:	2f 86       	sub	r6,-8
80009fba:	58 04       	cp.w	r4,0
80009fbc:	cf 11       	brne	80009f9e <_dtoa_r+0x382>
80009fbe:	fa e8 00 18 	ld.d	r8,sp[24]
80009fc2:	fa ea 00 08 	ld.d	r10,sp[8]
80009fc6:	06 96       	mov	r6,r3
80009fc8:	e0 a0 0f d8 	rcall	8000bf78 <__avr32_f64_div>
80009fcc:	40 a3       	lddsp	r3,sp[0x28]
80009fce:	14 98       	mov	r8,r10
80009fd0:	16 99       	mov	r9,r11
80009fd2:	fa e9 00 08 	st.d	sp[8],r8
80009fd6:	c2 f8       	rjmp	8000a034 <_dtoa_r+0x418>
80009fd8:	ec 08 11 00 	rsub	r8,r6,0
80009fdc:	c0 31       	brne	80009fe2 <_dtoa_r+0x3c6>
80009fde:	30 25       	mov	r5,2
80009fe0:	c2 a8       	rjmp	8000a034 <_dtoa_r+0x418>
80009fe2:	fe cc c4 aa 	sub	r12,pc,-15190
80009fe6:	f0 04 14 04 	asr	r4,r8,0x4
80009fea:	50 1c       	stdsp	sp[0x4],r12
80009fec:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009ff0:	fe c9 c5 80 	sub	r9,pc,-14976
80009ff4:	fa ea 00 3c 	ld.d	r10,sp[60]
80009ff8:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009ffc:	e0 a0 0c 78 	rcall	8000b8ec <__avr32_f64_mul>
8000a000:	40 1c       	lddsp	r12,sp[0x4]
8000a002:	50 63       	stdsp	sp[0x18],r3
8000a004:	30 25       	mov	r5,2
8000a006:	0c 93       	mov	r3,r6
8000a008:	fa eb 00 08 	st.d	sp[8],r10
8000a00c:	18 96       	mov	r6,r12
8000a00e:	c0 f8       	rjmp	8000a02c <_dtoa_r+0x410>
8000a010:	fa ea 00 08 	ld.d	r10,sp[8]
8000a014:	ed b4 00 00 	bld	r4,0x0
8000a018:	c0 81       	brne	8000a028 <_dtoa_r+0x40c>
8000a01a:	ec e8 00 00 	ld.d	r8,r6[0]
8000a01e:	2f f5       	sub	r5,-1
8000a020:	e0 a0 0c 66 	rcall	8000b8ec <__avr32_f64_mul>
8000a024:	fa eb 00 08 	st.d	sp[8],r10
8000a028:	a1 54       	asr	r4,0x1
8000a02a:	2f 86       	sub	r6,-8
8000a02c:	58 04       	cp.w	r4,0
8000a02e:	cf 11       	brne	8000a010 <_dtoa_r+0x3f4>
8000a030:	06 96       	mov	r6,r3
8000a032:	40 63       	lddsp	r3,sp[0x18]
8000a034:	41 4a       	lddsp	r10,sp[0x50]
8000a036:	58 0a       	cp.w	r10,0
8000a038:	c2 a0       	breq	8000a08c <_dtoa_r+0x470>
8000a03a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a03e:	58 01       	cp.w	r1,0
8000a040:	5f 94       	srgt	r4
8000a042:	fa e9 00 18 	st.d	sp[24],r8
8000a046:	30 08       	mov	r8,0
8000a048:	fc 19 3f f0 	movh	r9,0x3ff0
8000a04c:	fa ea 00 18 	ld.d	r10,sp[24]
8000a050:	e0 a0 0f 60 	rcall	8000bf10 <__avr32_f64_cmp_lt>
8000a054:	f9 bc 00 00 	moveq	r12,0
8000a058:	f9 bc 01 01 	movne	r12,1
8000a05c:	e9 ec 00 0c 	and	r12,r4,r12
8000a060:	c1 60       	breq	8000a08c <_dtoa_r+0x470>
8000a062:	40 98       	lddsp	r8,sp[0x24]
8000a064:	58 08       	cp.w	r8,0
8000a066:	e0 8a 00 f1 	brle	8000a248 <_dtoa_r+0x62c>
8000a06a:	30 08       	mov	r8,0
8000a06c:	fc 19 40 24 	movh	r9,0x4024
8000a070:	ec c4 00 01 	sub	r4,r6,1
8000a074:	fa ea 00 18 	ld.d	r10,sp[24]
8000a078:	2f f5       	sub	r5,-1
8000a07a:	50 64       	stdsp	sp[0x18],r4
8000a07c:	e0 a0 0c 38 	rcall	8000b8ec <__avr32_f64_mul>
8000a080:	40 94       	lddsp	r4,sp[0x24]
8000a082:	14 98       	mov	r8,r10
8000a084:	16 99       	mov	r9,r11
8000a086:	fa e9 00 08 	st.d	sp[8],r8
8000a08a:	c0 38       	rjmp	8000a090 <_dtoa_r+0x474>
8000a08c:	50 66       	stdsp	sp[0x18],r6
8000a08e:	02 94       	mov	r4,r1
8000a090:	0a 9c       	mov	r12,r5
8000a092:	e0 a0 0e 88 	rcall	8000bda2 <__avr32_s32_to_f64>
8000a096:	fa e8 00 08 	ld.d	r8,sp[8]
8000a09a:	e0 a0 0c 29 	rcall	8000b8ec <__avr32_f64_mul>
8000a09e:	30 08       	mov	r8,0
8000a0a0:	fc 19 40 1c 	movh	r9,0x401c
8000a0a4:	e0 a0 0d de 	rcall	8000bc60 <__avr32_f64_add>
8000a0a8:	14 98       	mov	r8,r10
8000a0aa:	16 99       	mov	r9,r11
8000a0ac:	fa e9 00 28 	st.d	sp[40],r8
8000a0b0:	fc 18 fc c0 	movh	r8,0xfcc0
8000a0b4:	40 a5       	lddsp	r5,sp[0x28]
8000a0b6:	10 05       	add	r5,r8
8000a0b8:	50 a5       	stdsp	sp[0x28],r5
8000a0ba:	58 04       	cp.w	r4,0
8000a0bc:	c2 11       	brne	8000a0fe <_dtoa_r+0x4e2>
8000a0be:	fa ea 00 08 	ld.d	r10,sp[8]
8000a0c2:	30 08       	mov	r8,0
8000a0c4:	fc 19 40 14 	movh	r9,0x4014
8000a0c8:	e0 a0 0c fe 	rcall	8000bac4 <__avr32_f64_sub>
8000a0cc:	40 bc       	lddsp	r12,sp[0x2c]
8000a0ce:	fa eb 00 08 	st.d	sp[8],r10
8000a0d2:	14 98       	mov	r8,r10
8000a0d4:	16 99       	mov	r9,r11
8000a0d6:	18 9a       	mov	r10,r12
8000a0d8:	0a 9b       	mov	r11,r5
8000a0da:	e0 a0 0f 1b 	rcall	8000bf10 <__avr32_f64_cmp_lt>
8000a0de:	e0 81 02 54 	brne	8000a586 <_dtoa_r+0x96a>
8000a0e2:	0a 98       	mov	r8,r5
8000a0e4:	40 b9       	lddsp	r9,sp[0x2c]
8000a0e6:	ee 18 80 00 	eorh	r8,0x8000
8000a0ea:	fa ea 00 08 	ld.d	r10,sp[8]
8000a0ee:	10 95       	mov	r5,r8
8000a0f0:	12 98       	mov	r8,r9
8000a0f2:	0a 99       	mov	r9,r5
8000a0f4:	e0 a0 0f 0e 	rcall	8000bf10 <__avr32_f64_cmp_lt>
8000a0f8:	e0 81 02 3e 	brne	8000a574 <_dtoa_r+0x958>
8000a0fc:	ca 68       	rjmp	8000a248 <_dtoa_r+0x62c>
8000a0fe:	fe c9 c6 8e 	sub	r9,pc,-14706
8000a102:	e8 c8 00 01 	sub	r8,r4,1
8000a106:	40 d5       	lddsp	r5,sp[0x34]
8000a108:	58 05       	cp.w	r5,0
8000a10a:	c4 f0       	breq	8000a1a8 <_dtoa_r+0x58c>
8000a10c:	30 0c       	mov	r12,0
8000a10e:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a112:	51 3c       	stdsp	sp[0x4c],r12
8000a114:	30 0a       	mov	r10,0
8000a116:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a11a:	e0 a0 0f 2f 	rcall	8000bf78 <__avr32_f64_div>
8000a11e:	fa e8 00 28 	ld.d	r8,sp[40]
8000a122:	40 85       	lddsp	r5,sp[0x20]
8000a124:	e0 a0 0c d0 	rcall	8000bac4 <__avr32_f64_sub>
8000a128:	fa eb 00 28 	st.d	sp[40],r10
8000a12c:	fa ea 00 08 	ld.d	r10,sp[8]
8000a130:	e0 a0 0e 22 	rcall	8000bd74 <__avr32_f64_to_s32>
8000a134:	51 6c       	stdsp	sp[0x58],r12
8000a136:	e0 a0 0e 36 	rcall	8000bda2 <__avr32_s32_to_f64>
8000a13a:	14 98       	mov	r8,r10
8000a13c:	16 99       	mov	r9,r11
8000a13e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a142:	e0 a0 0c c1 	rcall	8000bac4 <__avr32_f64_sub>
8000a146:	fa eb 00 08 	st.d	sp[8],r10
8000a14a:	41 68       	lddsp	r8,sp[0x58]
8000a14c:	2d 08       	sub	r8,-48
8000a14e:	0a c8       	st.b	r5++,r8
8000a150:	41 39       	lddsp	r9,sp[0x4c]
8000a152:	2f f9       	sub	r9,-1
8000a154:	51 39       	stdsp	sp[0x4c],r9
8000a156:	fa e8 00 28 	ld.d	r8,sp[40]
8000a15a:	e0 a0 0e db 	rcall	8000bf10 <__avr32_f64_cmp_lt>
8000a15e:	e0 81 03 39 	brne	8000a7d0 <_dtoa_r+0xbb4>
8000a162:	fa e8 00 08 	ld.d	r8,sp[8]
8000a166:	30 0a       	mov	r10,0
8000a168:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a16c:	e0 a0 0c ac 	rcall	8000bac4 <__avr32_f64_sub>
8000a170:	fa e8 00 28 	ld.d	r8,sp[40]
8000a174:	e0 a0 0e ce 	rcall	8000bf10 <__avr32_f64_cmp_lt>
8000a178:	fa ea 00 28 	ld.d	r10,sp[40]
8000a17c:	30 08       	mov	r8,0
8000a17e:	fc 19 40 24 	movh	r9,0x4024
8000a182:	e0 81 00 da 	brne	8000a336 <_dtoa_r+0x71a>
8000a186:	41 3c       	lddsp	r12,sp[0x4c]
8000a188:	08 3c       	cp.w	r12,r4
8000a18a:	c5 f4       	brge	8000a248 <_dtoa_r+0x62c>
8000a18c:	e0 a0 0b b0 	rcall	8000b8ec <__avr32_f64_mul>
8000a190:	30 08       	mov	r8,0
8000a192:	fa eb 00 28 	st.d	sp[40],r10
8000a196:	fc 19 40 24 	movh	r9,0x4024
8000a19a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a19e:	e0 a0 0b a7 	rcall	8000b8ec <__avr32_f64_mul>
8000a1a2:	fa eb 00 08 	st.d	sp[8],r10
8000a1a6:	cc 3b       	rjmp	8000a12c <_dtoa_r+0x510>
8000a1a8:	40 85       	lddsp	r5,sp[0x20]
8000a1aa:	08 05       	add	r5,r4
8000a1ac:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a1b0:	51 35       	stdsp	sp[0x4c],r5
8000a1b2:	fa e8 00 28 	ld.d	r8,sp[40]
8000a1b6:	40 85       	lddsp	r5,sp[0x20]
8000a1b8:	e0 a0 0b 9a 	rcall	8000b8ec <__avr32_f64_mul>
8000a1bc:	fa eb 00 28 	st.d	sp[40],r10
8000a1c0:	fa ea 00 08 	ld.d	r10,sp[8]
8000a1c4:	e0 a0 0d d8 	rcall	8000bd74 <__avr32_f64_to_s32>
8000a1c8:	51 6c       	stdsp	sp[0x58],r12
8000a1ca:	e0 a0 0d ec 	rcall	8000bda2 <__avr32_s32_to_f64>
8000a1ce:	14 98       	mov	r8,r10
8000a1d0:	16 99       	mov	r9,r11
8000a1d2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a1d6:	e0 a0 0c 77 	rcall	8000bac4 <__avr32_f64_sub>
8000a1da:	fa eb 00 08 	st.d	sp[8],r10
8000a1de:	41 68       	lddsp	r8,sp[0x58]
8000a1e0:	2d 08       	sub	r8,-48
8000a1e2:	0a c8       	st.b	r5++,r8
8000a1e4:	41 3c       	lddsp	r12,sp[0x4c]
8000a1e6:	18 35       	cp.w	r5,r12
8000a1e8:	c2 81       	brne	8000a238 <_dtoa_r+0x61c>
8000a1ea:	30 08       	mov	r8,0
8000a1ec:	fc 19 3f e0 	movh	r9,0x3fe0
8000a1f0:	fa ea 00 28 	ld.d	r10,sp[40]
8000a1f4:	e0 a0 0d 36 	rcall	8000bc60 <__avr32_f64_add>
8000a1f8:	40 85       	lddsp	r5,sp[0x20]
8000a1fa:	fa e8 00 08 	ld.d	r8,sp[8]
8000a1fe:	08 05       	add	r5,r4
8000a200:	e0 a0 0e 88 	rcall	8000bf10 <__avr32_f64_cmp_lt>
8000a204:	e0 81 00 99 	brne	8000a336 <_dtoa_r+0x71a>
8000a208:	fa e8 00 28 	ld.d	r8,sp[40]
8000a20c:	30 0a       	mov	r10,0
8000a20e:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a212:	e0 a0 0c 59 	rcall	8000bac4 <__avr32_f64_sub>
8000a216:	14 98       	mov	r8,r10
8000a218:	16 99       	mov	r9,r11
8000a21a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a21e:	e0 a0 0e 79 	rcall	8000bf10 <__avr32_f64_cmp_lt>
8000a222:	c1 30       	breq	8000a248 <_dtoa_r+0x62c>
8000a224:	33 09       	mov	r9,48
8000a226:	0a 98       	mov	r8,r5
8000a228:	11 7a       	ld.ub	r10,--r8
8000a22a:	f2 0a 18 00 	cp.b	r10,r9
8000a22e:	e0 81 02 d1 	brne	8000a7d0 <_dtoa_r+0xbb4>
8000a232:	10 95       	mov	r5,r8
8000a234:	cf 9b       	rjmp	8000a226 <_dtoa_r+0x60a>
8000a236:	d7 03       	nop
8000a238:	30 08       	mov	r8,0
8000a23a:	fc 19 40 24 	movh	r9,0x4024
8000a23e:	e0 a0 0b 57 	rcall	8000b8ec <__avr32_f64_mul>
8000a242:	fa eb 00 08 	st.d	sp[8],r10
8000a246:	cb db       	rjmp	8000a1c0 <_dtoa_r+0x5a4>
8000a248:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a24c:	fa eb 00 08 	st.d	sp[8],r10
8000a250:	58 e6       	cp.w	r6,14
8000a252:	5f ab       	srle	r11
8000a254:	41 8a       	lddsp	r10,sp[0x60]
8000a256:	30 08       	mov	r8,0
8000a258:	f4 09 11 ff 	rsub	r9,r10,-1
8000a25c:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a260:	f0 09 18 00 	cp.b	r9,r8
8000a264:	e0 80 00 82 	breq	8000a368 <_dtoa_r+0x74c>
8000a268:	40 ea       	lddsp	r10,sp[0x38]
8000a26a:	58 01       	cp.w	r1,0
8000a26c:	5f a9       	srle	r9
8000a26e:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a272:	fe ca c8 02 	sub	r10,pc,-14334
8000a276:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a27a:	fa e5 00 10 	st.d	sp[16],r4
8000a27e:	f0 09 18 00 	cp.b	r9,r8
8000a282:	c1 40       	breq	8000a2aa <_dtoa_r+0x68e>
8000a284:	58 01       	cp.w	r1,0
8000a286:	e0 81 01 77 	brne	8000a574 <_dtoa_r+0x958>
8000a28a:	30 08       	mov	r8,0
8000a28c:	fc 19 40 14 	movh	r9,0x4014
8000a290:	08 9a       	mov	r10,r4
8000a292:	0a 9b       	mov	r11,r5
8000a294:	e0 a0 0b 2c 	rcall	8000b8ec <__avr32_f64_mul>
8000a298:	fa e8 00 08 	ld.d	r8,sp[8]
8000a29c:	e0 a0 0e 06 	rcall	8000bea8 <__avr32_f64_cmp_ge>
8000a2a0:	e0 81 01 6a 	brne	8000a574 <_dtoa_r+0x958>
8000a2a4:	02 92       	mov	r2,r1
8000a2a6:	e0 8f 01 72 	bral	8000a58a <_dtoa_r+0x96e>
8000a2aa:	40 85       	lddsp	r5,sp[0x20]
8000a2ac:	30 14       	mov	r4,1
8000a2ae:	fa e8 00 10 	ld.d	r8,sp[16]
8000a2b2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a2b6:	e0 a0 0e 61 	rcall	8000bf78 <__avr32_f64_div>
8000a2ba:	e0 a0 0d 5d 	rcall	8000bd74 <__avr32_f64_to_s32>
8000a2be:	18 92       	mov	r2,r12
8000a2c0:	e0 a0 0d 71 	rcall	8000bda2 <__avr32_s32_to_f64>
8000a2c4:	fa e8 00 10 	ld.d	r8,sp[16]
8000a2c8:	e0 a0 0b 12 	rcall	8000b8ec <__avr32_f64_mul>
8000a2cc:	14 98       	mov	r8,r10
8000a2ce:	16 99       	mov	r9,r11
8000a2d0:	fa ea 00 08 	ld.d	r10,sp[8]
8000a2d4:	e0 a0 0b f8 	rcall	8000bac4 <__avr32_f64_sub>
8000a2d8:	fa eb 00 08 	st.d	sp[8],r10
8000a2dc:	e4 c8 ff d0 	sub	r8,r2,-48
8000a2e0:	0a c8       	st.b	r5++,r8
8000a2e2:	fc 19 40 24 	movh	r9,0x4024
8000a2e6:	30 08       	mov	r8,0
8000a2e8:	02 34       	cp.w	r4,r1
8000a2ea:	c3 31       	brne	8000a350 <_dtoa_r+0x734>
8000a2ec:	fa e8 00 08 	ld.d	r8,sp[8]
8000a2f0:	e0 a0 0c b8 	rcall	8000bc60 <__avr32_f64_add>
8000a2f4:	16 91       	mov	r1,r11
8000a2f6:	14 90       	mov	r0,r10
8000a2f8:	14 98       	mov	r8,r10
8000a2fa:	02 99       	mov	r9,r1
8000a2fc:	fa ea 00 10 	ld.d	r10,sp[16]
8000a300:	e0 a0 0e 08 	rcall	8000bf10 <__avr32_f64_cmp_lt>
8000a304:	c1 a1       	brne	8000a338 <_dtoa_r+0x71c>
8000a306:	fa e8 00 10 	ld.d	r8,sp[16]
8000a30a:	00 9a       	mov	r10,r0
8000a30c:	02 9b       	mov	r11,r1
8000a30e:	e0 a0 0d ba 	rcall	8000be82 <__avr32_f64_cmp_eq>
8000a312:	e0 80 02 5e 	breq	8000a7ce <_dtoa_r+0xbb2>
8000a316:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a31a:	c0 f1       	brne	8000a338 <_dtoa_r+0x71c>
8000a31c:	e0 8f 02 59 	bral	8000a7ce <_dtoa_r+0xbb2>
8000a320:	40 8a       	lddsp	r10,sp[0x20]
8000a322:	14 38       	cp.w	r8,r10
8000a324:	c0 30       	breq	8000a32a <_dtoa_r+0x70e>
8000a326:	10 95       	mov	r5,r8
8000a328:	c0 98       	rjmp	8000a33a <_dtoa_r+0x71e>
8000a32a:	33 08       	mov	r8,48
8000a32c:	40 89       	lddsp	r9,sp[0x20]
8000a32e:	2f f6       	sub	r6,-1
8000a330:	b2 88       	st.b	r9[0x0],r8
8000a332:	40 88       	lddsp	r8,sp[0x20]
8000a334:	c0 88       	rjmp	8000a344 <_dtoa_r+0x728>
8000a336:	40 66       	lddsp	r6,sp[0x18]
8000a338:	33 99       	mov	r9,57
8000a33a:	0a 98       	mov	r8,r5
8000a33c:	11 7a       	ld.ub	r10,--r8
8000a33e:	f2 0a 18 00 	cp.b	r10,r9
8000a342:	ce f0       	breq	8000a320 <_dtoa_r+0x704>
8000a344:	50 66       	stdsp	sp[0x18],r6
8000a346:	11 89       	ld.ub	r9,r8[0x0]
8000a348:	2f f9       	sub	r9,-1
8000a34a:	b0 89       	st.b	r8[0x0],r9
8000a34c:	e0 8f 02 42 	bral	8000a7d0 <_dtoa_r+0xbb4>
8000a350:	e0 a0 0a ce 	rcall	8000b8ec <__avr32_f64_mul>
8000a354:	2f f4       	sub	r4,-1
8000a356:	fa eb 00 08 	st.d	sp[8],r10
8000a35a:	30 08       	mov	r8,0
8000a35c:	30 09       	mov	r9,0
8000a35e:	e0 a0 0d 92 	rcall	8000be82 <__avr32_f64_cmp_eq>
8000a362:	ca 60       	breq	8000a2ae <_dtoa_r+0x692>
8000a364:	e0 8f 02 35 	bral	8000a7ce <_dtoa_r+0xbb2>
8000a368:	40 d8       	lddsp	r8,sp[0x34]
8000a36a:	58 08       	cp.w	r8,0
8000a36c:	c0 51       	brne	8000a376 <_dtoa_r+0x75a>
8000a36e:	04 98       	mov	r8,r2
8000a370:	00 95       	mov	r5,r0
8000a372:	40 d4       	lddsp	r4,sp[0x34]
8000a374:	c3 78       	rjmp	8000a3e2 <_dtoa_r+0x7c6>
8000a376:	40 c5       	lddsp	r5,sp[0x30]
8000a378:	58 15       	cp.w	r5,1
8000a37a:	e0 89 00 0f 	brgt	8000a398 <_dtoa_r+0x77c>
8000a37e:	41 74       	lddsp	r4,sp[0x5c]
8000a380:	58 04       	cp.w	r4,0
8000a382:	c0 40       	breq	8000a38a <_dtoa_r+0x76e>
8000a384:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a388:	c0 48       	rjmp	8000a390 <_dtoa_r+0x774>
8000a38a:	41 99       	lddsp	r9,sp[0x64]
8000a38c:	f2 09 11 36 	rsub	r9,r9,54
8000a390:	04 98       	mov	r8,r2
8000a392:	00 95       	mov	r5,r0
8000a394:	c1 c8       	rjmp	8000a3cc <_dtoa_r+0x7b0>
8000a396:	d7 03       	nop
8000a398:	e2 c8 00 01 	sub	r8,r1,1
8000a39c:	58 01       	cp.w	r1,0
8000a39e:	e0 05 17 40 	movge	r5,r0
8000a3a2:	e2 09 17 40 	movge	r9,r1
8000a3a6:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a3aa:	f9 b9 05 00 	movlt	r9,0
8000a3ae:	10 32       	cp.w	r2,r8
8000a3b0:	e5 d8 e4 18 	subge	r8,r2,r8
8000a3b4:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a3b8:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a3bc:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a3c0:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a3c4:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a3c8:	f9 b8 05 00 	movlt	r8,0
8000a3cc:	40 4b       	lddsp	r11,sp[0x10]
8000a3ce:	12 0b       	add	r11,r9
8000a3d0:	50 08       	stdsp	sp[0x0],r8
8000a3d2:	50 4b       	stdsp	sp[0x10],r11
8000a3d4:	12 00       	add	r0,r9
8000a3d6:	30 1b       	mov	r11,1
8000a3d8:	0e 9c       	mov	r12,r7
8000a3da:	e0 a0 08 a7 	rcall	8000b528 <__i2b>
8000a3de:	40 08       	lddsp	r8,sp[0x0]
8000a3e0:	18 94       	mov	r4,r12
8000a3e2:	40 4a       	lddsp	r10,sp[0x10]
8000a3e4:	58 05       	cp.w	r5,0
8000a3e6:	5f 99       	srgt	r9
8000a3e8:	58 0a       	cp.w	r10,0
8000a3ea:	5f 9a       	srgt	r10
8000a3ec:	f5 e9 00 09 	and	r9,r10,r9
8000a3f0:	c0 80       	breq	8000a400 <_dtoa_r+0x7e4>
8000a3f2:	40 4c       	lddsp	r12,sp[0x10]
8000a3f4:	f8 05 0d 49 	min	r9,r12,r5
8000a3f8:	12 1c       	sub	r12,r9
8000a3fa:	12 10       	sub	r0,r9
8000a3fc:	50 4c       	stdsp	sp[0x10],r12
8000a3fe:	12 15       	sub	r5,r9
8000a400:	58 02       	cp.w	r2,0
8000a402:	e0 8a 00 27 	brle	8000a450 <_dtoa_r+0x834>
8000a406:	40 db       	lddsp	r11,sp[0x34]
8000a408:	58 0b       	cp.w	r11,0
8000a40a:	c1 d0       	breq	8000a444 <_dtoa_r+0x828>
8000a40c:	58 08       	cp.w	r8,0
8000a40e:	e0 8a 00 17 	brle	8000a43c <_dtoa_r+0x820>
8000a412:	10 9a       	mov	r10,r8
8000a414:	50 08       	stdsp	sp[0x0],r8
8000a416:	08 9b       	mov	r11,r4
8000a418:	0e 9c       	mov	r12,r7
8000a41a:	e0 a0 08 cd 	rcall	8000b5b4 <__pow5mult>
8000a41e:	06 9a       	mov	r10,r3
8000a420:	18 9b       	mov	r11,r12
8000a422:	18 94       	mov	r4,r12
8000a424:	0e 9c       	mov	r12,r7
8000a426:	e0 a0 08 01 	rcall	8000b428 <__multiply>
8000a42a:	18 99       	mov	r9,r12
8000a42c:	06 9b       	mov	r11,r3
8000a42e:	50 19       	stdsp	sp[0x4],r9
8000a430:	0e 9c       	mov	r12,r7
8000a432:	e0 a0 06 ad 	rcall	8000b18c <_Bfree>
8000a436:	40 19       	lddsp	r9,sp[0x4]
8000a438:	40 08       	lddsp	r8,sp[0x0]
8000a43a:	12 93       	mov	r3,r9
8000a43c:	e4 08 01 0a 	sub	r10,r2,r8
8000a440:	c0 80       	breq	8000a450 <_dtoa_r+0x834>
8000a442:	c0 28       	rjmp	8000a446 <_dtoa_r+0x82a>
8000a444:	04 9a       	mov	r10,r2
8000a446:	06 9b       	mov	r11,r3
8000a448:	0e 9c       	mov	r12,r7
8000a44a:	e0 a0 08 b5 	rcall	8000b5b4 <__pow5mult>
8000a44e:	18 93       	mov	r3,r12
8000a450:	30 1b       	mov	r11,1
8000a452:	0e 9c       	mov	r12,r7
8000a454:	e0 a0 08 6a 	rcall	8000b528 <__i2b>
8000a458:	41 1a       	lddsp	r10,sp[0x44]
8000a45a:	18 92       	mov	r2,r12
8000a45c:	58 0a       	cp.w	r10,0
8000a45e:	e0 8a 00 07 	brle	8000a46c <_dtoa_r+0x850>
8000a462:	18 9b       	mov	r11,r12
8000a464:	0e 9c       	mov	r12,r7
8000a466:	e0 a0 08 a7 	rcall	8000b5b4 <__pow5mult>
8000a46a:	18 92       	mov	r2,r12
8000a46c:	40 c9       	lddsp	r9,sp[0x30]
8000a46e:	58 19       	cp.w	r9,1
8000a470:	e0 89 00 14 	brgt	8000a498 <_dtoa_r+0x87c>
8000a474:	40 38       	lddsp	r8,sp[0xc]
8000a476:	58 08       	cp.w	r8,0
8000a478:	c1 01       	brne	8000a498 <_dtoa_r+0x87c>
8000a47a:	40 29       	lddsp	r9,sp[0x8]
8000a47c:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a480:	c0 c1       	brne	8000a498 <_dtoa_r+0x87c>
8000a482:	12 98       	mov	r8,r9
8000a484:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a488:	c0 80       	breq	8000a498 <_dtoa_r+0x87c>
8000a48a:	40 4c       	lddsp	r12,sp[0x10]
8000a48c:	30 1b       	mov	r11,1
8000a48e:	2f fc       	sub	r12,-1
8000a490:	2f f0       	sub	r0,-1
8000a492:	50 4c       	stdsp	sp[0x10],r12
8000a494:	50 6b       	stdsp	sp[0x18],r11
8000a496:	c0 38       	rjmp	8000a49c <_dtoa_r+0x880>
8000a498:	30 0a       	mov	r10,0
8000a49a:	50 6a       	stdsp	sp[0x18],r10
8000a49c:	41 19       	lddsp	r9,sp[0x44]
8000a49e:	58 09       	cp.w	r9,0
8000a4a0:	c0 31       	brne	8000a4a6 <_dtoa_r+0x88a>
8000a4a2:	30 1c       	mov	r12,1
8000a4a4:	c0 98       	rjmp	8000a4b6 <_dtoa_r+0x89a>
8000a4a6:	64 48       	ld.w	r8,r2[0x10]
8000a4a8:	2f c8       	sub	r8,-4
8000a4aa:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a4ae:	e0 a0 05 df 	rcall	8000b06c <__hi0bits>
8000a4b2:	f8 0c 11 20 	rsub	r12,r12,32
8000a4b6:	40 4b       	lddsp	r11,sp[0x10]
8000a4b8:	f8 0b 00 08 	add	r8,r12,r11
8000a4bc:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a4c0:	c0 c0       	breq	8000a4d8 <_dtoa_r+0x8bc>
8000a4c2:	f0 08 11 20 	rsub	r8,r8,32
8000a4c6:	58 48       	cp.w	r8,4
8000a4c8:	e0 8a 00 06 	brle	8000a4d4 <_dtoa_r+0x8b8>
8000a4cc:	20 48       	sub	r8,4
8000a4ce:	10 0b       	add	r11,r8
8000a4d0:	50 4b       	stdsp	sp[0x10],r11
8000a4d2:	c0 78       	rjmp	8000a4e0 <_dtoa_r+0x8c4>
8000a4d4:	58 48       	cp.w	r8,4
8000a4d6:	c0 70       	breq	8000a4e4 <_dtoa_r+0x8c8>
8000a4d8:	40 4a       	lddsp	r10,sp[0x10]
8000a4da:	2e 48       	sub	r8,-28
8000a4dc:	10 0a       	add	r10,r8
8000a4de:	50 4a       	stdsp	sp[0x10],r10
8000a4e0:	10 00       	add	r0,r8
8000a4e2:	10 05       	add	r5,r8
8000a4e4:	58 00       	cp.w	r0,0
8000a4e6:	e0 8a 00 08 	brle	8000a4f6 <_dtoa_r+0x8da>
8000a4ea:	06 9b       	mov	r11,r3
8000a4ec:	00 9a       	mov	r10,r0
8000a4ee:	0e 9c       	mov	r12,r7
8000a4f0:	e0 a0 07 58 	rcall	8000b3a0 <__lshift>
8000a4f4:	18 93       	mov	r3,r12
8000a4f6:	40 49       	lddsp	r9,sp[0x10]
8000a4f8:	58 09       	cp.w	r9,0
8000a4fa:	e0 8a 00 08 	brle	8000a50a <_dtoa_r+0x8ee>
8000a4fe:	04 9b       	mov	r11,r2
8000a500:	12 9a       	mov	r10,r9
8000a502:	0e 9c       	mov	r12,r7
8000a504:	e0 a0 07 4e 	rcall	8000b3a0 <__lshift>
8000a508:	18 92       	mov	r2,r12
8000a50a:	41 48       	lddsp	r8,sp[0x50]
8000a50c:	58 08       	cp.w	r8,0
8000a50e:	c1 b0       	breq	8000a544 <_dtoa_r+0x928>
8000a510:	04 9b       	mov	r11,r2
8000a512:	06 9c       	mov	r12,r3
8000a514:	e0 a0 06 23 	rcall	8000b15a <__mcmp>
8000a518:	c1 64       	brge	8000a544 <_dtoa_r+0x928>
8000a51a:	06 9b       	mov	r11,r3
8000a51c:	30 09       	mov	r9,0
8000a51e:	30 aa       	mov	r10,10
8000a520:	0e 9c       	mov	r12,r7
8000a522:	e0 a0 08 0b 	rcall	8000b538 <__multadd>
8000a526:	20 16       	sub	r6,1
8000a528:	18 93       	mov	r3,r12
8000a52a:	40 dc       	lddsp	r12,sp[0x34]
8000a52c:	58 0c       	cp.w	r12,0
8000a52e:	c0 31       	brne	8000a534 <_dtoa_r+0x918>
8000a530:	40 91       	lddsp	r1,sp[0x24]
8000a532:	c0 98       	rjmp	8000a544 <_dtoa_r+0x928>
8000a534:	08 9b       	mov	r11,r4
8000a536:	40 91       	lddsp	r1,sp[0x24]
8000a538:	30 09       	mov	r9,0
8000a53a:	30 aa       	mov	r10,10
8000a53c:	0e 9c       	mov	r12,r7
8000a53e:	e0 a0 07 fd 	rcall	8000b538 <__multadd>
8000a542:	18 94       	mov	r4,r12
8000a544:	58 01       	cp.w	r1,0
8000a546:	5f a9       	srle	r9
8000a548:	40 cb       	lddsp	r11,sp[0x30]
8000a54a:	58 2b       	cp.w	r11,2
8000a54c:	5f 98       	srgt	r8
8000a54e:	f3 e8 00 08 	and	r8,r9,r8
8000a552:	c2 50       	breq	8000a59c <_dtoa_r+0x980>
8000a554:	58 01       	cp.w	r1,0
8000a556:	c1 11       	brne	8000a578 <_dtoa_r+0x95c>
8000a558:	04 9b       	mov	r11,r2
8000a55a:	02 99       	mov	r9,r1
8000a55c:	30 5a       	mov	r10,5
8000a55e:	0e 9c       	mov	r12,r7
8000a560:	e0 a0 07 ec 	rcall	8000b538 <__multadd>
8000a564:	18 92       	mov	r2,r12
8000a566:	18 9b       	mov	r11,r12
8000a568:	06 9c       	mov	r12,r3
8000a56a:	e0 a0 05 f8 	rcall	8000b15a <__mcmp>
8000a56e:	e0 89 00 0f 	brgt	8000a58c <_dtoa_r+0x970>
8000a572:	c0 38       	rjmp	8000a578 <_dtoa_r+0x95c>
8000a574:	30 02       	mov	r2,0
8000a576:	04 94       	mov	r4,r2
8000a578:	40 ea       	lddsp	r10,sp[0x38]
8000a57a:	30 09       	mov	r9,0
8000a57c:	5c da       	com	r10
8000a57e:	40 85       	lddsp	r5,sp[0x20]
8000a580:	50 6a       	stdsp	sp[0x18],r10
8000a582:	50 49       	stdsp	sp[0x10],r9
8000a584:	c0 f9       	rjmp	8000a7a2 <_dtoa_r+0xb86>
8000a586:	08 92       	mov	r2,r4
8000a588:	40 66       	lddsp	r6,sp[0x18]
8000a58a:	04 94       	mov	r4,r2
8000a58c:	2f f6       	sub	r6,-1
8000a58e:	50 66       	stdsp	sp[0x18],r6
8000a590:	33 18       	mov	r8,49
8000a592:	40 85       	lddsp	r5,sp[0x20]
8000a594:	0a c8       	st.b	r5++,r8
8000a596:	30 08       	mov	r8,0
8000a598:	50 48       	stdsp	sp[0x10],r8
8000a59a:	c0 49       	rjmp	8000a7a2 <_dtoa_r+0xb86>
8000a59c:	40 dc       	lddsp	r12,sp[0x34]
8000a59e:	58 0c       	cp.w	r12,0
8000a5a0:	e0 80 00 b5 	breq	8000a70a <_dtoa_r+0xaee>
8000a5a4:	58 05       	cp.w	r5,0
8000a5a6:	e0 8a 00 08 	brle	8000a5b6 <_dtoa_r+0x99a>
8000a5aa:	08 9b       	mov	r11,r4
8000a5ac:	0a 9a       	mov	r10,r5
8000a5ae:	0e 9c       	mov	r12,r7
8000a5b0:	e0 a0 06 f8 	rcall	8000b3a0 <__lshift>
8000a5b4:	18 94       	mov	r4,r12
8000a5b6:	40 6b       	lddsp	r11,sp[0x18]
8000a5b8:	58 0b       	cp.w	r11,0
8000a5ba:	c0 31       	brne	8000a5c0 <_dtoa_r+0x9a4>
8000a5bc:	08 9c       	mov	r12,r4
8000a5be:	c1 38       	rjmp	8000a5e4 <_dtoa_r+0x9c8>
8000a5c0:	68 1b       	ld.w	r11,r4[0x4]
8000a5c2:	0e 9c       	mov	r12,r7
8000a5c4:	e0 a0 05 fe 	rcall	8000b1c0 <_Balloc>
8000a5c8:	68 4a       	ld.w	r10,r4[0x10]
8000a5ca:	18 95       	mov	r5,r12
8000a5cc:	e8 cb ff f4 	sub	r11,r4,-12
8000a5d0:	2f ea       	sub	r10,-2
8000a5d2:	2f 4c       	sub	r12,-12
8000a5d4:	a3 6a       	lsl	r10,0x2
8000a5d6:	fe b0 e6 4f 	rcall	80007274 <memcpy>
8000a5da:	0a 9b       	mov	r11,r5
8000a5dc:	30 1a       	mov	r10,1
8000a5de:	0e 9c       	mov	r12,r7
8000a5e0:	e0 a0 06 e0 	rcall	8000b3a0 <__lshift>
8000a5e4:	50 44       	stdsp	sp[0x10],r4
8000a5e6:	40 3a       	lddsp	r10,sp[0xc]
8000a5e8:	30 19       	mov	r9,1
8000a5ea:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a5ee:	18 94       	mov	r4,r12
8000a5f0:	50 da       	stdsp	sp[0x34],r10
8000a5f2:	40 85       	lddsp	r5,sp[0x20]
8000a5f4:	50 99       	stdsp	sp[0x24],r9
8000a5f6:	50 26       	stdsp	sp[0x8],r6
8000a5f8:	50 e1       	stdsp	sp[0x38],r1
8000a5fa:	04 9b       	mov	r11,r2
8000a5fc:	06 9c       	mov	r12,r3
8000a5fe:	fe b0 fa 7f 	rcall	80009afc <quorem>
8000a602:	40 4b       	lddsp	r11,sp[0x10]
8000a604:	f8 c0 ff d0 	sub	r0,r12,-48
8000a608:	06 9c       	mov	r12,r3
8000a60a:	e0 a0 05 a8 	rcall	8000b15a <__mcmp>
8000a60e:	08 9a       	mov	r10,r4
8000a610:	50 6c       	stdsp	sp[0x18],r12
8000a612:	04 9b       	mov	r11,r2
8000a614:	0e 9c       	mov	r12,r7
8000a616:	e0 a0 06 5d 	rcall	8000b2d0 <__mdiff>
8000a61a:	18 91       	mov	r1,r12
8000a61c:	78 38       	ld.w	r8,r12[0xc]
8000a61e:	58 08       	cp.w	r8,0
8000a620:	c0 30       	breq	8000a626 <_dtoa_r+0xa0a>
8000a622:	30 16       	mov	r6,1
8000a624:	c0 68       	rjmp	8000a630 <_dtoa_r+0xa14>
8000a626:	18 9b       	mov	r11,r12
8000a628:	06 9c       	mov	r12,r3
8000a62a:	e0 a0 05 98 	rcall	8000b15a <__mcmp>
8000a62e:	18 96       	mov	r6,r12
8000a630:	0e 9c       	mov	r12,r7
8000a632:	02 9b       	mov	r11,r1
8000a634:	e0 a0 05 ac 	rcall	8000b18c <_Bfree>
8000a638:	40 cc       	lddsp	r12,sp[0x30]
8000a63a:	ed ec 10 08 	or	r8,r6,r12
8000a63e:	c0 d1       	brne	8000a658 <_dtoa_r+0xa3c>
8000a640:	40 db       	lddsp	r11,sp[0x34]
8000a642:	58 0b       	cp.w	r11,0
8000a644:	c0 a1       	brne	8000a658 <_dtoa_r+0xa3c>
8000a646:	40 26       	lddsp	r6,sp[0x8]
8000a648:	e0 40 00 39 	cp.w	r0,57
8000a64c:	c3 00       	breq	8000a6ac <_dtoa_r+0xa90>
8000a64e:	40 6a       	lddsp	r10,sp[0x18]
8000a650:	58 0a       	cp.w	r10,0
8000a652:	e0 89 00 24 	brgt	8000a69a <_dtoa_r+0xa7e>
8000a656:	c2 f8       	rjmp	8000a6b4 <_dtoa_r+0xa98>
8000a658:	40 69       	lddsp	r9,sp[0x18]
8000a65a:	58 09       	cp.w	r9,0
8000a65c:	c0 85       	brlt	8000a66c <_dtoa_r+0xa50>
8000a65e:	12 98       	mov	r8,r9
8000a660:	40 cc       	lddsp	r12,sp[0x30]
8000a662:	18 48       	or	r8,r12
8000a664:	c1 d1       	brne	8000a69e <_dtoa_r+0xa82>
8000a666:	40 db       	lddsp	r11,sp[0x34]
8000a668:	58 0b       	cp.w	r11,0
8000a66a:	c1 a1       	brne	8000a69e <_dtoa_r+0xa82>
8000a66c:	0c 99       	mov	r9,r6
8000a66e:	40 26       	lddsp	r6,sp[0x8]
8000a670:	58 09       	cp.w	r9,0
8000a672:	e0 8a 00 21 	brle	8000a6b4 <_dtoa_r+0xa98>
8000a676:	06 9b       	mov	r11,r3
8000a678:	30 1a       	mov	r10,1
8000a67a:	0e 9c       	mov	r12,r7
8000a67c:	e0 a0 06 92 	rcall	8000b3a0 <__lshift>
8000a680:	04 9b       	mov	r11,r2
8000a682:	18 93       	mov	r3,r12
8000a684:	e0 a0 05 6b 	rcall	8000b15a <__mcmp>
8000a688:	e0 89 00 06 	brgt	8000a694 <_dtoa_r+0xa78>
8000a68c:	c1 41       	brne	8000a6b4 <_dtoa_r+0xa98>
8000a68e:	ed b0 00 00 	bld	r0,0x0
8000a692:	c1 11       	brne	8000a6b4 <_dtoa_r+0xa98>
8000a694:	e0 40 00 39 	cp.w	r0,57
8000a698:	c0 a0       	breq	8000a6ac <_dtoa_r+0xa90>
8000a69a:	2f f0       	sub	r0,-1
8000a69c:	c0 c8       	rjmp	8000a6b4 <_dtoa_r+0xa98>
8000a69e:	58 06       	cp.w	r6,0
8000a6a0:	e0 8a 00 0c 	brle	8000a6b8 <_dtoa_r+0xa9c>
8000a6a4:	40 26       	lddsp	r6,sp[0x8]
8000a6a6:	e0 40 00 39 	cp.w	r0,57
8000a6aa:	c0 41       	brne	8000a6b2 <_dtoa_r+0xa96>
8000a6ac:	33 98       	mov	r8,57
8000a6ae:	0a c8       	st.b	r5++,r8
8000a6b0:	c6 78       	rjmp	8000a77e <_dtoa_r+0xb62>
8000a6b2:	2f f0       	sub	r0,-1
8000a6b4:	0a c0       	st.b	r5++,r0
8000a6b6:	c7 58       	rjmp	8000a7a0 <_dtoa_r+0xb84>
8000a6b8:	0a c0       	st.b	r5++,r0
8000a6ba:	40 9a       	lddsp	r10,sp[0x24]
8000a6bc:	40 e9       	lddsp	r9,sp[0x38]
8000a6be:	12 3a       	cp.w	r10,r9
8000a6c0:	c4 30       	breq	8000a746 <_dtoa_r+0xb2a>
8000a6c2:	06 9b       	mov	r11,r3
8000a6c4:	30 09       	mov	r9,0
8000a6c6:	30 aa       	mov	r10,10
8000a6c8:	0e 9c       	mov	r12,r7
8000a6ca:	e0 a0 07 37 	rcall	8000b538 <__multadd>
8000a6ce:	40 48       	lddsp	r8,sp[0x10]
8000a6d0:	18 93       	mov	r3,r12
8000a6d2:	08 38       	cp.w	r8,r4
8000a6d4:	c0 91       	brne	8000a6e6 <_dtoa_r+0xaca>
8000a6d6:	10 9b       	mov	r11,r8
8000a6d8:	30 09       	mov	r9,0
8000a6da:	30 aa       	mov	r10,10
8000a6dc:	0e 9c       	mov	r12,r7
8000a6de:	e0 a0 07 2d 	rcall	8000b538 <__multadd>
8000a6e2:	50 4c       	stdsp	sp[0x10],r12
8000a6e4:	c0 e8       	rjmp	8000a700 <_dtoa_r+0xae4>
8000a6e6:	40 4b       	lddsp	r11,sp[0x10]
8000a6e8:	30 09       	mov	r9,0
8000a6ea:	30 aa       	mov	r10,10
8000a6ec:	0e 9c       	mov	r12,r7
8000a6ee:	e0 a0 07 25 	rcall	8000b538 <__multadd>
8000a6f2:	08 9b       	mov	r11,r4
8000a6f4:	50 4c       	stdsp	sp[0x10],r12
8000a6f6:	30 09       	mov	r9,0
8000a6f8:	30 aa       	mov	r10,10
8000a6fa:	0e 9c       	mov	r12,r7
8000a6fc:	e0 a0 07 1e 	rcall	8000b538 <__multadd>
8000a700:	18 94       	mov	r4,r12
8000a702:	40 9c       	lddsp	r12,sp[0x24]
8000a704:	2f fc       	sub	r12,-1
8000a706:	50 9c       	stdsp	sp[0x24],r12
8000a708:	c7 9b       	rjmp	8000a5fa <_dtoa_r+0x9de>
8000a70a:	30 18       	mov	r8,1
8000a70c:	06 90       	mov	r0,r3
8000a70e:	40 85       	lddsp	r5,sp[0x20]
8000a710:	08 93       	mov	r3,r4
8000a712:	0c 94       	mov	r4,r6
8000a714:	10 96       	mov	r6,r8
8000a716:	04 9b       	mov	r11,r2
8000a718:	00 9c       	mov	r12,r0
8000a71a:	fe b0 f9 f1 	rcall	80009afc <quorem>
8000a71e:	2d 0c       	sub	r12,-48
8000a720:	0a cc       	st.b	r5++,r12
8000a722:	02 36       	cp.w	r6,r1
8000a724:	c0 a4       	brge	8000a738 <_dtoa_r+0xb1c>
8000a726:	00 9b       	mov	r11,r0
8000a728:	30 09       	mov	r9,0
8000a72a:	30 aa       	mov	r10,10
8000a72c:	0e 9c       	mov	r12,r7
8000a72e:	2f f6       	sub	r6,-1
8000a730:	e0 a0 07 04 	rcall	8000b538 <__multadd>
8000a734:	18 90       	mov	r0,r12
8000a736:	cf 0b       	rjmp	8000a716 <_dtoa_r+0xafa>
8000a738:	08 96       	mov	r6,r4
8000a73a:	30 0b       	mov	r11,0
8000a73c:	06 94       	mov	r4,r3
8000a73e:	50 4b       	stdsp	sp[0x10],r11
8000a740:	00 93       	mov	r3,r0
8000a742:	18 90       	mov	r0,r12
8000a744:	c0 28       	rjmp	8000a748 <_dtoa_r+0xb2c>
8000a746:	40 26       	lddsp	r6,sp[0x8]
8000a748:	06 9b       	mov	r11,r3
8000a74a:	30 1a       	mov	r10,1
8000a74c:	0e 9c       	mov	r12,r7
8000a74e:	e0 a0 06 29 	rcall	8000b3a0 <__lshift>
8000a752:	04 9b       	mov	r11,r2
8000a754:	18 93       	mov	r3,r12
8000a756:	e0 a0 05 02 	rcall	8000b15a <__mcmp>
8000a75a:	e0 89 00 12 	brgt	8000a77e <_dtoa_r+0xb62>
8000a75e:	c1 b1       	brne	8000a794 <_dtoa_r+0xb78>
8000a760:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000a764:	c0 d1       	brne	8000a77e <_dtoa_r+0xb62>
8000a766:	c1 78       	rjmp	8000a794 <_dtoa_r+0xb78>
8000a768:	40 89       	lddsp	r9,sp[0x20]
8000a76a:	12 38       	cp.w	r8,r9
8000a76c:	c0 30       	breq	8000a772 <_dtoa_r+0xb56>
8000a76e:	10 95       	mov	r5,r8
8000a770:	c0 88       	rjmp	8000a780 <_dtoa_r+0xb64>
8000a772:	2f f6       	sub	r6,-1
8000a774:	50 66       	stdsp	sp[0x18],r6
8000a776:	33 18       	mov	r8,49
8000a778:	40 8c       	lddsp	r12,sp[0x20]
8000a77a:	b8 88       	st.b	r12[0x0],r8
8000a77c:	c1 38       	rjmp	8000a7a2 <_dtoa_r+0xb86>
8000a77e:	33 9a       	mov	r10,57
8000a780:	0a 98       	mov	r8,r5
8000a782:	11 79       	ld.ub	r9,--r8
8000a784:	f4 09 18 00 	cp.b	r9,r10
8000a788:	cf 00       	breq	8000a768 <_dtoa_r+0xb4c>
8000a78a:	2f f9       	sub	r9,-1
8000a78c:	b0 89       	st.b	r8[0x0],r9
8000a78e:	c0 98       	rjmp	8000a7a0 <_dtoa_r+0xb84>
8000a790:	10 95       	mov	r5,r8
8000a792:	c0 28       	rjmp	8000a796 <_dtoa_r+0xb7a>
8000a794:	33 09       	mov	r9,48
8000a796:	0a 98       	mov	r8,r5
8000a798:	11 7a       	ld.ub	r10,--r8
8000a79a:	f2 0a 18 00 	cp.b	r10,r9
8000a79e:	cf 90       	breq	8000a790 <_dtoa_r+0xb74>
8000a7a0:	50 66       	stdsp	sp[0x18],r6
8000a7a2:	04 9b       	mov	r11,r2
8000a7a4:	0e 9c       	mov	r12,r7
8000a7a6:	e0 a0 04 f3 	rcall	8000b18c <_Bfree>
8000a7aa:	58 04       	cp.w	r4,0
8000a7ac:	c1 20       	breq	8000a7d0 <_dtoa_r+0xbb4>
8000a7ae:	40 4b       	lddsp	r11,sp[0x10]
8000a7b0:	08 3b       	cp.w	r11,r4
8000a7b2:	5f 19       	srne	r9
8000a7b4:	58 0b       	cp.w	r11,0
8000a7b6:	5f 18       	srne	r8
8000a7b8:	f3 e8 00 08 	and	r8,r9,r8
8000a7bc:	c0 40       	breq	8000a7c4 <_dtoa_r+0xba8>
8000a7be:	0e 9c       	mov	r12,r7
8000a7c0:	e0 a0 04 e6 	rcall	8000b18c <_Bfree>
8000a7c4:	08 9b       	mov	r11,r4
8000a7c6:	0e 9c       	mov	r12,r7
8000a7c8:	e0 a0 04 e2 	rcall	8000b18c <_Bfree>
8000a7cc:	c0 28       	rjmp	8000a7d0 <_dtoa_r+0xbb4>
8000a7ce:	50 66       	stdsp	sp[0x18],r6
8000a7d0:	0e 9c       	mov	r12,r7
8000a7d2:	06 9b       	mov	r11,r3
8000a7d4:	e0 a0 04 dc 	rcall	8000b18c <_Bfree>
8000a7d8:	30 08       	mov	r8,0
8000a7da:	aa 88       	st.b	r5[0x0],r8
8000a7dc:	40 68       	lddsp	r8,sp[0x18]
8000a7de:	41 5a       	lddsp	r10,sp[0x54]
8000a7e0:	2f f8       	sub	r8,-1
8000a7e2:	41 29       	lddsp	r9,sp[0x48]
8000a7e4:	95 08       	st.w	r10[0x0],r8
8000a7e6:	40 8c       	lddsp	r12,sp[0x20]
8000a7e8:	58 09       	cp.w	r9,0
8000a7ea:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000a7ee:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000a7f2:	2e 6d       	sub	sp,-104
8000a7f4:	d8 32       	popm	r0-r7,pc
8000a7f6:	d7 03       	nop

8000a7f8 <__errno>:
8000a7f8:	e0 68 0a 40 	mov	r8,2624
8000a7fc:	70 0c       	ld.w	r12,r8[0x0]
8000a7fe:	2f 4c       	sub	r12,-12
8000a800:	5e fc       	retal	r12
8000a802:	d7 03       	nop

8000a804 <_fflush_r>:
8000a804:	d4 21       	pushm	r4-r7,lr
8000a806:	16 97       	mov	r7,r11
8000a808:	18 96       	mov	r6,r12
8000a80a:	76 48       	ld.w	r8,r11[0x10]
8000a80c:	58 08       	cp.w	r8,0
8000a80e:	c7 f0       	breq	8000a90c <_fflush_r+0x108>
8000a810:	58 0c       	cp.w	r12,0
8000a812:	c0 50       	breq	8000a81c <_fflush_r+0x18>
8000a814:	78 68       	ld.w	r8,r12[0x18]
8000a816:	58 08       	cp.w	r8,0
8000a818:	c0 21       	brne	8000a81c <_fflush_r+0x18>
8000a81a:	cc dc       	rcall	8000a9b4 <__sinit>
8000a81c:	fe c8 ce 5c 	sub	r8,pc,-12708
8000a820:	10 37       	cp.w	r7,r8
8000a822:	c0 31       	brne	8000a828 <_fflush_r+0x24>
8000a824:	6c 07       	ld.w	r7,r6[0x0]
8000a826:	c0 c8       	rjmp	8000a83e <_fflush_r+0x3a>
8000a828:	fe c8 ce 48 	sub	r8,pc,-12728
8000a82c:	10 37       	cp.w	r7,r8
8000a82e:	c0 31       	brne	8000a834 <_fflush_r+0x30>
8000a830:	6c 17       	ld.w	r7,r6[0x4]
8000a832:	c0 68       	rjmp	8000a83e <_fflush_r+0x3a>
8000a834:	fe c8 ce 34 	sub	r8,pc,-12748
8000a838:	10 37       	cp.w	r7,r8
8000a83a:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000a83e:	8e 6a       	ld.sh	r10,r7[0xc]
8000a840:	14 98       	mov	r8,r10
8000a842:	ed ba 00 03 	bld	r10,0x3
8000a846:	c4 20       	breq	8000a8ca <_fflush_r+0xc6>
8000a848:	ab ba       	sbr	r10,0xb
8000a84a:	ae 6a       	st.h	r7[0xc],r10
8000a84c:	6e 18       	ld.w	r8,r7[0x4]
8000a84e:	58 08       	cp.w	r8,0
8000a850:	e0 89 00 06 	brgt	8000a85c <_fflush_r+0x58>
8000a854:	6f 08       	ld.w	r8,r7[0x40]
8000a856:	58 08       	cp.w	r8,0
8000a858:	e0 8a 00 5a 	brle	8000a90c <_fflush_r+0x108>
8000a85c:	6e b8       	ld.w	r8,r7[0x2c]
8000a85e:	58 08       	cp.w	r8,0
8000a860:	c5 60       	breq	8000a90c <_fflush_r+0x108>
8000a862:	e2 1a 10 00 	andl	r10,0x1000,COH
8000a866:	c0 30       	breq	8000a86c <_fflush_r+0x68>
8000a868:	6f 55       	ld.w	r5,r7[0x54]
8000a86a:	c0 f8       	rjmp	8000a888 <_fflush_r+0x84>
8000a86c:	30 19       	mov	r9,1
8000a86e:	6e 8b       	ld.w	r11,r7[0x20]
8000a870:	0c 9c       	mov	r12,r6
8000a872:	5d 18       	icall	r8
8000a874:	18 95       	mov	r5,r12
8000a876:	5b fc       	cp.w	r12,-1
8000a878:	c0 81       	brne	8000a888 <_fflush_r+0x84>
8000a87a:	6c 38       	ld.w	r8,r6[0xc]
8000a87c:	59 d8       	cp.w	r8,29
8000a87e:	c4 70       	breq	8000a90c <_fflush_r+0x108>
8000a880:	8e 68       	ld.sh	r8,r7[0xc]
8000a882:	a7 a8       	sbr	r8,0x6
8000a884:	ae 68       	st.h	r7[0xc],r8
8000a886:	d8 22       	popm	r4-r7,pc
8000a888:	8e 68       	ld.sh	r8,r7[0xc]
8000a88a:	ed b8 00 02 	bld	r8,0x2
8000a88e:	c0 91       	brne	8000a8a0 <_fflush_r+0x9c>
8000a890:	6e 18       	ld.w	r8,r7[0x4]
8000a892:	10 15       	sub	r5,r8
8000a894:	6e d8       	ld.w	r8,r7[0x34]
8000a896:	58 08       	cp.w	r8,0
8000a898:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000a89c:	eb d8 e1 15 	subne	r5,r5,r8
8000a8a0:	6e b8       	ld.w	r8,r7[0x2c]
8000a8a2:	0c 9c       	mov	r12,r6
8000a8a4:	30 09       	mov	r9,0
8000a8a6:	0a 9a       	mov	r10,r5
8000a8a8:	6e 8b       	ld.w	r11,r7[0x20]
8000a8aa:	5d 18       	icall	r8
8000a8ac:	8e 68       	ld.sh	r8,r7[0xc]
8000a8ae:	0a 3c       	cp.w	r12,r5
8000a8b0:	c2 61       	brne	8000a8fc <_fflush_r+0xf8>
8000a8b2:	ab d8       	cbr	r8,0xb
8000a8b4:	30 0c       	mov	r12,0
8000a8b6:	6e 49       	ld.w	r9,r7[0x10]
8000a8b8:	ae 68       	st.h	r7[0xc],r8
8000a8ba:	8f 1c       	st.w	r7[0x4],r12
8000a8bc:	8f 09       	st.w	r7[0x0],r9
8000a8be:	ed b8 00 0c 	bld	r8,0xc
8000a8c2:	c2 51       	brne	8000a90c <_fflush_r+0x108>
8000a8c4:	ef 45 00 54 	st.w	r7[84],r5
8000a8c8:	d8 22       	popm	r4-r7,pc
8000a8ca:	6e 45       	ld.w	r5,r7[0x10]
8000a8cc:	58 05       	cp.w	r5,0
8000a8ce:	c1 f0       	breq	8000a90c <_fflush_r+0x108>
8000a8d0:	6e 04       	ld.w	r4,r7[0x0]
8000a8d2:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000a8d6:	8f 05       	st.w	r7[0x0],r5
8000a8d8:	f9 b8 01 00 	movne	r8,0
8000a8dc:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000a8e0:	0a 14       	sub	r4,r5
8000a8e2:	8f 28       	st.w	r7[0x8],r8
8000a8e4:	c1 18       	rjmp	8000a906 <_fflush_r+0x102>
8000a8e6:	08 99       	mov	r9,r4
8000a8e8:	0a 9a       	mov	r10,r5
8000a8ea:	6e a8       	ld.w	r8,r7[0x28]
8000a8ec:	6e 8b       	ld.w	r11,r7[0x20]
8000a8ee:	0c 9c       	mov	r12,r6
8000a8f0:	5d 18       	icall	r8
8000a8f2:	18 14       	sub	r4,r12
8000a8f4:	58 0c       	cp.w	r12,0
8000a8f6:	e0 89 00 07 	brgt	8000a904 <_fflush_r+0x100>
8000a8fa:	8e 68       	ld.sh	r8,r7[0xc]
8000a8fc:	a7 a8       	sbr	r8,0x6
8000a8fe:	3f fc       	mov	r12,-1
8000a900:	ae 68       	st.h	r7[0xc],r8
8000a902:	d8 22       	popm	r4-r7,pc
8000a904:	18 05       	add	r5,r12
8000a906:	58 04       	cp.w	r4,0
8000a908:	fe 99 ff ef 	brgt	8000a8e6 <_fflush_r+0xe2>
8000a90c:	d8 2a       	popm	r4-r7,pc,r12=0
8000a90e:	d7 03       	nop

8000a910 <__sfp_lock_acquire>:
8000a910:	5e fc       	retal	r12

8000a912 <__sfp_lock_release>:
8000a912:	5e fc       	retal	r12

8000a914 <_cleanup_r>:
8000a914:	d4 01       	pushm	lr
8000a916:	fe cb f0 ae 	sub	r11,pc,-3922
8000a91a:	e0 a0 02 f7 	rcall	8000af08 <_fwalk>
8000a91e:	d8 02       	popm	pc

8000a920 <__sfmoreglue>:
8000a920:	d4 21       	pushm	r4-r7,lr
8000a922:	16 95       	mov	r5,r11
8000a924:	f6 06 10 5c 	mul	r6,r11,92
8000a928:	ec cb ff f4 	sub	r11,r6,-12
8000a92c:	fe b0 e2 88 	rcall	80006e3c <_malloc_r>
8000a930:	18 97       	mov	r7,r12
8000a932:	c0 90       	breq	8000a944 <__sfmoreglue+0x24>
8000a934:	99 15       	st.w	r12[0x4],r5
8000a936:	30 0b       	mov	r11,0
8000a938:	2f 4c       	sub	r12,-12
8000a93a:	0c 9a       	mov	r10,r6
8000a93c:	8f 2c       	st.w	r7[0x8],r12
8000a93e:	8f 0b       	st.w	r7[0x0],r11
8000a940:	fe b0 e5 3e 	rcall	800073bc <memset>
8000a944:	0e 9c       	mov	r12,r7
8000a946:	d8 22       	popm	r4-r7,pc

8000a948 <__sfp>:
8000a948:	d4 21       	pushm	r4-r7,lr
8000a94a:	fe c8 cf 26 	sub	r8,pc,-12506
8000a94e:	18 96       	mov	r6,r12
8000a950:	70 07       	ld.w	r7,r8[0x0]
8000a952:	6e 68       	ld.w	r8,r7[0x18]
8000a954:	58 08       	cp.w	r8,0
8000a956:	c0 31       	brne	8000a95c <__sfp+0x14>
8000a958:	0e 9c       	mov	r12,r7
8000a95a:	c2 dc       	rcall	8000a9b4 <__sinit>
8000a95c:	ee c7 ff 28 	sub	r7,r7,-216
8000a960:	30 05       	mov	r5,0
8000a962:	6e 2c       	ld.w	r12,r7[0x8]
8000a964:	6e 18       	ld.w	r8,r7[0x4]
8000a966:	c0 68       	rjmp	8000a972 <__sfp+0x2a>
8000a968:	98 69       	ld.sh	r9,r12[0xc]
8000a96a:	ea 09 19 00 	cp.h	r9,r5
8000a96e:	c1 10       	breq	8000a990 <__sfp+0x48>
8000a970:	2a 4c       	sub	r12,-92
8000a972:	20 18       	sub	r8,1
8000a974:	cf a7       	brpl	8000a968 <__sfp+0x20>
8000a976:	6e 08       	ld.w	r8,r7[0x0]
8000a978:	58 08       	cp.w	r8,0
8000a97a:	c0 61       	brne	8000a986 <__sfp+0x3e>
8000a97c:	30 4b       	mov	r11,4
8000a97e:	0c 9c       	mov	r12,r6
8000a980:	cd 0f       	rcall	8000a920 <__sfmoreglue>
8000a982:	8f 0c       	st.w	r7[0x0],r12
8000a984:	c0 30       	breq	8000a98a <__sfp+0x42>
8000a986:	6e 07       	ld.w	r7,r7[0x0]
8000a988:	ce db       	rjmp	8000a962 <__sfp+0x1a>
8000a98a:	30 c8       	mov	r8,12
8000a98c:	8d 38       	st.w	r6[0xc],r8
8000a98e:	d8 22       	popm	r4-r7,pc
8000a990:	30 08       	mov	r8,0
8000a992:	f9 48 00 4c 	st.w	r12[76],r8
8000a996:	99 08       	st.w	r12[0x0],r8
8000a998:	99 28       	st.w	r12[0x8],r8
8000a99a:	99 18       	st.w	r12[0x4],r8
8000a99c:	99 48       	st.w	r12[0x10],r8
8000a99e:	99 58       	st.w	r12[0x14],r8
8000a9a0:	99 68       	st.w	r12[0x18],r8
8000a9a2:	99 d8       	st.w	r12[0x34],r8
8000a9a4:	99 e8       	st.w	r12[0x38],r8
8000a9a6:	f9 48 00 48 	st.w	r12[72],r8
8000a9aa:	3f f8       	mov	r8,-1
8000a9ac:	b8 78       	st.h	r12[0xe],r8
8000a9ae:	30 18       	mov	r8,1
8000a9b0:	b8 68       	st.h	r12[0xc],r8
8000a9b2:	d8 22       	popm	r4-r7,pc

8000a9b4 <__sinit>:
8000a9b4:	d4 21       	pushm	r4-r7,lr
8000a9b6:	18 96       	mov	r6,r12
8000a9b8:	78 67       	ld.w	r7,r12[0x18]
8000a9ba:	58 07       	cp.w	r7,0
8000a9bc:	c4 91       	brne	8000aa4e <__sinit+0x9a>
8000a9be:	fe c8 00 aa 	sub	r8,pc,170
8000a9c2:	30 15       	mov	r5,1
8000a9c4:	99 a8       	st.w	r12[0x28],r8
8000a9c6:	f9 47 00 d8 	st.w	r12[216],r7
8000a9ca:	f9 47 00 dc 	st.w	r12[220],r7
8000a9ce:	f9 47 00 e0 	st.w	r12[224],r7
8000a9d2:	99 65       	st.w	r12[0x18],r5
8000a9d4:	cb af       	rcall	8000a948 <__sfp>
8000a9d6:	8d 0c       	st.w	r6[0x0],r12
8000a9d8:	0c 9c       	mov	r12,r6
8000a9da:	cb 7f       	rcall	8000a948 <__sfp>
8000a9dc:	8d 1c       	st.w	r6[0x4],r12
8000a9de:	0c 9c       	mov	r12,r6
8000a9e0:	cb 4f       	rcall	8000a948 <__sfp>
8000a9e2:	6c 09       	ld.w	r9,r6[0x0]
8000a9e4:	30 48       	mov	r8,4
8000a9e6:	93 07       	st.w	r9[0x0],r7
8000a9e8:	b2 68       	st.h	r9[0xc],r8
8000a9ea:	93 17       	st.w	r9[0x4],r7
8000a9ec:	93 27       	st.w	r9[0x8],r7
8000a9ee:	6c 18       	ld.w	r8,r6[0x4]
8000a9f0:	b2 77       	st.h	r9[0xe],r7
8000a9f2:	93 47       	st.w	r9[0x10],r7
8000a9f4:	93 57       	st.w	r9[0x14],r7
8000a9f6:	93 67       	st.w	r9[0x18],r7
8000a9f8:	93 89       	st.w	r9[0x20],r9
8000a9fa:	91 07       	st.w	r8[0x0],r7
8000a9fc:	91 17       	st.w	r8[0x4],r7
8000a9fe:	91 27       	st.w	r8[0x8],r7
8000aa00:	fe ce f3 24 	sub	lr,pc,-3292
8000aa04:	fe cb f3 54 	sub	r11,pc,-3244
8000aa08:	93 9e       	st.w	r9[0x24],lr
8000aa0a:	93 ab       	st.w	r9[0x28],r11
8000aa0c:	fe ca f3 7c 	sub	r10,pc,-3204
8000aa10:	fe c4 f3 88 	sub	r4,pc,-3192
8000aa14:	93 ba       	st.w	r9[0x2c],r10
8000aa16:	93 c4       	st.w	r9[0x30],r4
8000aa18:	30 99       	mov	r9,9
8000aa1a:	b0 69       	st.h	r8[0xc],r9
8000aa1c:	b0 75       	st.h	r8[0xe],r5
8000aa1e:	91 c4       	st.w	r8[0x30],r4
8000aa20:	91 47       	st.w	r8[0x10],r7
8000aa22:	91 57       	st.w	r8[0x14],r7
8000aa24:	91 67       	st.w	r8[0x18],r7
8000aa26:	91 88       	st.w	r8[0x20],r8
8000aa28:	91 9e       	st.w	r8[0x24],lr
8000aa2a:	91 ab       	st.w	r8[0x28],r11
8000aa2c:	91 ba       	st.w	r8[0x2c],r10
8000aa2e:	8d 2c       	st.w	r6[0x8],r12
8000aa30:	31 28       	mov	r8,18
8000aa32:	99 07       	st.w	r12[0x0],r7
8000aa34:	b8 68       	st.h	r12[0xc],r8
8000aa36:	99 17       	st.w	r12[0x4],r7
8000aa38:	99 27       	st.w	r12[0x8],r7
8000aa3a:	30 28       	mov	r8,2
8000aa3c:	b8 78       	st.h	r12[0xe],r8
8000aa3e:	99 c4       	st.w	r12[0x30],r4
8000aa40:	99 67       	st.w	r12[0x18],r7
8000aa42:	99 9e       	st.w	r12[0x24],lr
8000aa44:	99 ab       	st.w	r12[0x28],r11
8000aa46:	99 ba       	st.w	r12[0x2c],r10
8000aa48:	99 47       	st.w	r12[0x10],r7
8000aa4a:	99 57       	st.w	r12[0x14],r7
8000aa4c:	99 8c       	st.w	r12[0x20],r12
8000aa4e:	d8 22       	popm	r4-r7,pc

8000aa50 <_malloc_trim_r>:
8000aa50:	d4 21       	pushm	r4-r7,lr
8000aa52:	16 95       	mov	r5,r11
8000aa54:	18 97       	mov	r7,r12
8000aa56:	fe b0 d7 f1 	rcall	80005a38 <__malloc_lock>
8000aa5a:	e0 64 05 40 	mov	r4,1344
8000aa5e:	68 28       	ld.w	r8,r4[0x8]
8000aa60:	70 16       	ld.w	r6,r8[0x4]
8000aa62:	e0 16 ff fc 	andl	r6,0xfffc
8000aa66:	ec c8 ff 91 	sub	r8,r6,-111
8000aa6a:	f0 05 01 05 	sub	r5,r8,r5
8000aa6e:	e0 15 ff 80 	andl	r5,0xff80
8000aa72:	ea c5 00 80 	sub	r5,r5,128
8000aa76:	e0 45 00 7f 	cp.w	r5,127
8000aa7a:	e0 8a 00 25 	brle	8000aac4 <_malloc_trim_r+0x74>
8000aa7e:	30 0b       	mov	r11,0
8000aa80:	0e 9c       	mov	r12,r7
8000aa82:	fe b0 e6 05 	rcall	8000768c <_sbrk_r>
8000aa86:	68 28       	ld.w	r8,r4[0x8]
8000aa88:	0c 08       	add	r8,r6
8000aa8a:	10 3c       	cp.w	r12,r8
8000aa8c:	c1 c1       	brne	8000aac4 <_malloc_trim_r+0x74>
8000aa8e:	ea 0b 11 00 	rsub	r11,r5,0
8000aa92:	0e 9c       	mov	r12,r7
8000aa94:	fe b0 e5 fc 	rcall	8000768c <_sbrk_r>
8000aa98:	5b fc       	cp.w	r12,-1
8000aa9a:	c1 91       	brne	8000aacc <_malloc_trim_r+0x7c>
8000aa9c:	30 0b       	mov	r11,0
8000aa9e:	0e 9c       	mov	r12,r7
8000aaa0:	fe b0 e5 f6 	rcall	8000768c <_sbrk_r>
8000aaa4:	68 28       	ld.w	r8,r4[0x8]
8000aaa6:	f8 08 01 09 	sub	r9,r12,r8
8000aaaa:	58 f9       	cp.w	r9,15
8000aaac:	e0 8a 00 0c 	brle	8000aac4 <_malloc_trim_r+0x74>
8000aab0:	a1 a9       	sbr	r9,0x0
8000aab2:	91 19       	st.w	r8[0x4],r9
8000aab4:	e0 68 09 4c 	mov	r8,2380
8000aab8:	70 09       	ld.w	r9,r8[0x0]
8000aaba:	e0 68 0d 68 	mov	r8,3432
8000aabe:	f8 09 01 09 	sub	r9,r12,r9
8000aac2:	91 09       	st.w	r8[0x0],r9
8000aac4:	0e 9c       	mov	r12,r7
8000aac6:	fe b0 d7 bf 	rcall	80005a44 <__malloc_unlock>
8000aaca:	d8 2a       	popm	r4-r7,pc,r12=0
8000aacc:	68 28       	ld.w	r8,r4[0x8]
8000aace:	0a 16       	sub	r6,r5
8000aad0:	a1 a6       	sbr	r6,0x0
8000aad2:	91 16       	st.w	r8[0x4],r6
8000aad4:	e0 68 0d 68 	mov	r8,3432
8000aad8:	70 09       	ld.w	r9,r8[0x0]
8000aada:	0a 19       	sub	r9,r5
8000aadc:	0e 9c       	mov	r12,r7
8000aade:	91 09       	st.w	r8[0x0],r9
8000aae0:	fe b0 d7 b2 	rcall	80005a44 <__malloc_unlock>
8000aae4:	da 2a       	popm	r4-r7,pc,r12=1
8000aae6:	d7 03       	nop

8000aae8 <_free_r>:
8000aae8:	d4 21       	pushm	r4-r7,lr
8000aaea:	16 96       	mov	r6,r11
8000aaec:	18 97       	mov	r7,r12
8000aaee:	58 0b       	cp.w	r11,0
8000aaf0:	e0 80 00 c0 	breq	8000ac70 <_free_r+0x188>
8000aaf4:	fe b0 d7 a2 	rcall	80005a38 <__malloc_lock>
8000aaf8:	20 86       	sub	r6,8
8000aafa:	e0 6a 05 40 	mov	r10,1344
8000aafe:	6c 18       	ld.w	r8,r6[0x4]
8000ab00:	74 2e       	ld.w	lr,r10[0x8]
8000ab02:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000ab06:	a1 c8       	cbr	r8,0x0
8000ab08:	ec 08 00 09 	add	r9,r6,r8
8000ab0c:	72 1b       	ld.w	r11,r9[0x4]
8000ab0e:	e0 1b ff fc 	andl	r11,0xfffc
8000ab12:	1c 39       	cp.w	r9,lr
8000ab14:	c1 e1       	brne	8000ab50 <_free_r+0x68>
8000ab16:	f6 08 00 08 	add	r8,r11,r8
8000ab1a:	58 0c       	cp.w	r12,0
8000ab1c:	c0 81       	brne	8000ab2c <_free_r+0x44>
8000ab1e:	6c 09       	ld.w	r9,r6[0x0]
8000ab20:	12 16       	sub	r6,r9
8000ab22:	12 08       	add	r8,r9
8000ab24:	6c 3b       	ld.w	r11,r6[0xc]
8000ab26:	6c 29       	ld.w	r9,r6[0x8]
8000ab28:	97 29       	st.w	r11[0x8],r9
8000ab2a:	93 3b       	st.w	r9[0xc],r11
8000ab2c:	10 99       	mov	r9,r8
8000ab2e:	95 26       	st.w	r10[0x8],r6
8000ab30:	a1 a9       	sbr	r9,0x0
8000ab32:	8d 19       	st.w	r6[0x4],r9
8000ab34:	e0 69 09 48 	mov	r9,2376
8000ab38:	72 09       	ld.w	r9,r9[0x0]
8000ab3a:	12 38       	cp.w	r8,r9
8000ab3c:	c0 63       	brcs	8000ab48 <_free_r+0x60>
8000ab3e:	e0 68 0d 64 	mov	r8,3428
8000ab42:	0e 9c       	mov	r12,r7
8000ab44:	70 0b       	ld.w	r11,r8[0x0]
8000ab46:	c8 5f       	rcall	8000aa50 <_malloc_trim_r>
8000ab48:	0e 9c       	mov	r12,r7
8000ab4a:	fe b0 d7 7d 	rcall	80005a44 <__malloc_unlock>
8000ab4e:	d8 22       	popm	r4-r7,pc
8000ab50:	93 1b       	st.w	r9[0x4],r11
8000ab52:	58 0c       	cp.w	r12,0
8000ab54:	c0 30       	breq	8000ab5a <_free_r+0x72>
8000ab56:	30 0c       	mov	r12,0
8000ab58:	c1 08       	rjmp	8000ab78 <_free_r+0x90>
8000ab5a:	6c 0e       	ld.w	lr,r6[0x0]
8000ab5c:	f4 c5 ff f8 	sub	r5,r10,-8
8000ab60:	1c 16       	sub	r6,lr
8000ab62:	1c 08       	add	r8,lr
8000ab64:	6c 2e       	ld.w	lr,r6[0x8]
8000ab66:	0a 3e       	cp.w	lr,r5
8000ab68:	f9 bc 00 01 	moveq	r12,1
8000ab6c:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000ab70:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000ab74:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000ab78:	f2 0b 00 0e 	add	lr,r9,r11
8000ab7c:	7c 1e       	ld.w	lr,lr[0x4]
8000ab7e:	ed be 00 00 	bld	lr,0x0
8000ab82:	c1 40       	breq	8000abaa <_free_r+0xc2>
8000ab84:	16 08       	add	r8,r11
8000ab86:	58 0c       	cp.w	r12,0
8000ab88:	c0 d1       	brne	8000aba2 <_free_r+0xba>
8000ab8a:	e0 6e 05 40 	mov	lr,1344
8000ab8e:	72 2b       	ld.w	r11,r9[0x8]
8000ab90:	2f 8e       	sub	lr,-8
8000ab92:	1c 3b       	cp.w	r11,lr
8000ab94:	c0 71       	brne	8000aba2 <_free_r+0xba>
8000ab96:	97 36       	st.w	r11[0xc],r6
8000ab98:	97 26       	st.w	r11[0x8],r6
8000ab9a:	8d 2b       	st.w	r6[0x8],r11
8000ab9c:	8d 3b       	st.w	r6[0xc],r11
8000ab9e:	30 1c       	mov	r12,1
8000aba0:	c0 58       	rjmp	8000abaa <_free_r+0xc2>
8000aba2:	72 2b       	ld.w	r11,r9[0x8]
8000aba4:	72 39       	ld.w	r9,r9[0xc]
8000aba6:	93 2b       	st.w	r9[0x8],r11
8000aba8:	97 39       	st.w	r11[0xc],r9
8000abaa:	10 99       	mov	r9,r8
8000abac:	ec 08 09 08 	st.w	r6[r8],r8
8000abb0:	a1 a9       	sbr	r9,0x0
8000abb2:	8d 19       	st.w	r6[0x4],r9
8000abb4:	58 0c       	cp.w	r12,0
8000abb6:	c5 a1       	brne	8000ac6a <_free_r+0x182>
8000abb8:	e0 48 01 ff 	cp.w	r8,511
8000abbc:	e0 8b 00 13 	brhi	8000abe2 <_free_r+0xfa>
8000abc0:	a3 98       	lsr	r8,0x3
8000abc2:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000abc6:	72 2b       	ld.w	r11,r9[0x8]
8000abc8:	8d 39       	st.w	r6[0xc],r9
8000abca:	8d 2b       	st.w	r6[0x8],r11
8000abcc:	97 36       	st.w	r11[0xc],r6
8000abce:	93 26       	st.w	r9[0x8],r6
8000abd0:	a3 48       	asr	r8,0x2
8000abd2:	74 19       	ld.w	r9,r10[0x4]
8000abd4:	30 1b       	mov	r11,1
8000abd6:	f6 08 09 48 	lsl	r8,r11,r8
8000abda:	f3 e8 10 08 	or	r8,r9,r8
8000abde:	95 18       	st.w	r10[0x4],r8
8000abe0:	c4 58       	rjmp	8000ac6a <_free_r+0x182>
8000abe2:	f0 0b 16 09 	lsr	r11,r8,0x9
8000abe6:	58 4b       	cp.w	r11,4
8000abe8:	e0 8b 00 06 	brhi	8000abf4 <_free_r+0x10c>
8000abec:	f0 0b 16 06 	lsr	r11,r8,0x6
8000abf0:	2c 8b       	sub	r11,-56
8000abf2:	c2 08       	rjmp	8000ac32 <_free_r+0x14a>
8000abf4:	59 4b       	cp.w	r11,20
8000abf6:	e0 8b 00 04 	brhi	8000abfe <_free_r+0x116>
8000abfa:	2a 5b       	sub	r11,-91
8000abfc:	c1 b8       	rjmp	8000ac32 <_free_r+0x14a>
8000abfe:	e0 4b 00 54 	cp.w	r11,84
8000ac02:	e0 8b 00 06 	brhi	8000ac0e <_free_r+0x126>
8000ac06:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000ac0a:	29 2b       	sub	r11,-110
8000ac0c:	c1 38       	rjmp	8000ac32 <_free_r+0x14a>
8000ac0e:	e0 4b 01 54 	cp.w	r11,340
8000ac12:	e0 8b 00 06 	brhi	8000ac1e <_free_r+0x136>
8000ac16:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000ac1a:	28 9b       	sub	r11,-119
8000ac1c:	c0 b8       	rjmp	8000ac32 <_free_r+0x14a>
8000ac1e:	e0 4b 05 54 	cp.w	r11,1364
8000ac22:	e0 88 00 05 	brls	8000ac2c <_free_r+0x144>
8000ac26:	37 eb       	mov	r11,126
8000ac28:	c0 58       	rjmp	8000ac32 <_free_r+0x14a>
8000ac2a:	d7 03       	nop
8000ac2c:	f0 0b 16 12 	lsr	r11,r8,0x12
8000ac30:	28 4b       	sub	r11,-124
8000ac32:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000ac36:	78 29       	ld.w	r9,r12[0x8]
8000ac38:	18 39       	cp.w	r9,r12
8000ac3a:	c0 e1       	brne	8000ac56 <_free_r+0x16e>
8000ac3c:	74 18       	ld.w	r8,r10[0x4]
8000ac3e:	a3 4b       	asr	r11,0x2
8000ac40:	30 1c       	mov	r12,1
8000ac42:	f8 0b 09 4b 	lsl	r11,r12,r11
8000ac46:	f1 eb 10 0b 	or	r11,r8,r11
8000ac4a:	12 98       	mov	r8,r9
8000ac4c:	95 1b       	st.w	r10[0x4],r11
8000ac4e:	c0 a8       	rjmp	8000ac62 <_free_r+0x17a>
8000ac50:	72 29       	ld.w	r9,r9[0x8]
8000ac52:	18 39       	cp.w	r9,r12
8000ac54:	c0 60       	breq	8000ac60 <_free_r+0x178>
8000ac56:	72 1a       	ld.w	r10,r9[0x4]
8000ac58:	e0 1a ff fc 	andl	r10,0xfffc
8000ac5c:	14 38       	cp.w	r8,r10
8000ac5e:	cf 93       	brcs	8000ac50 <_free_r+0x168>
8000ac60:	72 38       	ld.w	r8,r9[0xc]
8000ac62:	8d 38       	st.w	r6[0xc],r8
8000ac64:	8d 29       	st.w	r6[0x8],r9
8000ac66:	93 36       	st.w	r9[0xc],r6
8000ac68:	91 26       	st.w	r8[0x8],r6
8000ac6a:	0e 9c       	mov	r12,r7
8000ac6c:	fe b0 d6 ec 	rcall	80005a44 <__malloc_unlock>
8000ac70:	d8 22       	popm	r4-r7,pc
8000ac72:	d7 03       	nop

8000ac74 <__sfvwrite_r>:
8000ac74:	d4 31       	pushm	r0-r7,lr
8000ac76:	20 3d       	sub	sp,12
8000ac78:	14 94       	mov	r4,r10
8000ac7a:	18 95       	mov	r5,r12
8000ac7c:	16 97       	mov	r7,r11
8000ac7e:	74 28       	ld.w	r8,r10[0x8]
8000ac80:	58 08       	cp.w	r8,0
8000ac82:	e0 80 01 40 	breq	8000af02 <__sfvwrite_r+0x28e>
8000ac86:	96 68       	ld.sh	r8,r11[0xc]
8000ac88:	ed b8 00 03 	bld	r8,0x3
8000ac8c:	c0 41       	brne	8000ac94 <__sfvwrite_r+0x20>
8000ac8e:	76 48       	ld.w	r8,r11[0x10]
8000ac90:	58 08       	cp.w	r8,0
8000ac92:	c0 c1       	brne	8000acaa <__sfvwrite_r+0x36>
8000ac94:	0e 9b       	mov	r11,r7
8000ac96:	0a 9c       	mov	r12,r5
8000ac98:	fe b0 f6 c4 	rcall	80009a20 <__swsetup_r>
8000ac9c:	c0 70       	breq	8000acaa <__sfvwrite_r+0x36>
8000ac9e:	8e 68       	ld.sh	r8,r7[0xc]
8000aca0:	a7 a8       	sbr	r8,0x6
8000aca2:	ae 68       	st.h	r7[0xc],r8
8000aca4:	30 98       	mov	r8,9
8000aca6:	8b 38       	st.w	r5[0xc],r8
8000aca8:	c2 b9       	rjmp	8000aefe <__sfvwrite_r+0x28a>
8000acaa:	8e 63       	ld.sh	r3,r7[0xc]
8000acac:	68 00       	ld.w	r0,r4[0x0]
8000acae:	06 96       	mov	r6,r3
8000acb0:	e2 16 00 02 	andl	r6,0x2,COH
8000acb4:	c2 10       	breq	8000acf6 <__sfvwrite_r+0x82>
8000acb6:	30 03       	mov	r3,0
8000acb8:	e0 62 04 00 	mov	r2,1024
8000acbc:	06 96       	mov	r6,r3
8000acbe:	c0 48       	rjmp	8000acc6 <__sfvwrite_r+0x52>
8000acc0:	60 03       	ld.w	r3,r0[0x0]
8000acc2:	60 16       	ld.w	r6,r0[0x4]
8000acc4:	2f 80       	sub	r0,-8
8000acc6:	58 06       	cp.w	r6,0
8000acc8:	cf c0       	breq	8000acc0 <__sfvwrite_r+0x4c>
8000acca:	e0 46 04 00 	cp.w	r6,1024
8000acce:	ec 09 17 80 	movls	r9,r6
8000acd2:	e4 09 17 b0 	movhi	r9,r2
8000acd6:	06 9a       	mov	r10,r3
8000acd8:	6e a8       	ld.w	r8,r7[0x28]
8000acda:	6e 8b       	ld.w	r11,r7[0x20]
8000acdc:	0a 9c       	mov	r12,r5
8000acde:	5d 18       	icall	r8
8000ace0:	18 16       	sub	r6,r12
8000ace2:	58 0c       	cp.w	r12,0
8000ace4:	e0 8a 01 0a 	brle	8000aef8 <__sfvwrite_r+0x284>
8000ace8:	68 28       	ld.w	r8,r4[0x8]
8000acea:	18 18       	sub	r8,r12
8000acec:	89 28       	st.w	r4[0x8],r8
8000acee:	e0 80 01 0a 	breq	8000af02 <__sfvwrite_r+0x28e>
8000acf2:	18 03       	add	r3,r12
8000acf4:	ce 9b       	rjmp	8000acc6 <__sfvwrite_r+0x52>
8000acf6:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000acfa:	c0 70       	breq	8000ad08 <__sfvwrite_r+0x94>
8000acfc:	50 06       	stdsp	sp[0x0],r6
8000acfe:	0c 93       	mov	r3,r6
8000ad00:	0c 91       	mov	r1,r6
8000ad02:	50 15       	stdsp	sp[0x4],r5
8000ad04:	08 92       	mov	r2,r4
8000ad06:	c9 c8       	rjmp	8000ae3e <__sfvwrite_r+0x1ca>
8000ad08:	06 96       	mov	r6,r3
8000ad0a:	08 91       	mov	r1,r4
8000ad0c:	c0 48       	rjmp	8000ad14 <__sfvwrite_r+0xa0>
8000ad0e:	60 03       	ld.w	r3,r0[0x0]
8000ad10:	60 16       	ld.w	r6,r0[0x4]
8000ad12:	2f 80       	sub	r0,-8
8000ad14:	58 06       	cp.w	r6,0
8000ad16:	cf c0       	breq	8000ad0e <__sfvwrite_r+0x9a>
8000ad18:	8e 68       	ld.sh	r8,r7[0xc]
8000ad1a:	6e 24       	ld.w	r4,r7[0x8]
8000ad1c:	10 99       	mov	r9,r8
8000ad1e:	e2 19 02 00 	andl	r9,0x200,COH
8000ad22:	c5 50       	breq	8000adcc <__sfvwrite_r+0x158>
8000ad24:	08 36       	cp.w	r6,r4
8000ad26:	c4 43       	brcs	8000adae <__sfvwrite_r+0x13a>
8000ad28:	10 99       	mov	r9,r8
8000ad2a:	e2 19 04 80 	andl	r9,0x480,COH
8000ad2e:	c4 00       	breq	8000adae <__sfvwrite_r+0x13a>
8000ad30:	6e 4b       	ld.w	r11,r7[0x10]
8000ad32:	6e 09       	ld.w	r9,r7[0x0]
8000ad34:	16 19       	sub	r9,r11
8000ad36:	50 09       	stdsp	sp[0x0],r9
8000ad38:	6e 59       	ld.w	r9,r7[0x14]
8000ad3a:	10 9c       	mov	r12,r8
8000ad3c:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000ad40:	30 28       	mov	r8,2
8000ad42:	f4 08 0c 08 	divs	r8,r10,r8
8000ad46:	fa e9 00 04 	st.d	sp[4],r8
8000ad4a:	10 94       	mov	r4,r8
8000ad4c:	40 09       	lddsp	r9,sp[0x0]
8000ad4e:	e2 1c 04 00 	andl	r12,0x400,COH
8000ad52:	2f f9       	sub	r9,-1
8000ad54:	0c 09       	add	r9,r6
8000ad56:	12 38       	cp.w	r8,r9
8000ad58:	f2 04 17 30 	movlo	r4,r9
8000ad5c:	58 0c       	cp.w	r12,0
8000ad5e:	c1 10       	breq	8000ad80 <__sfvwrite_r+0x10c>
8000ad60:	08 9b       	mov	r11,r4
8000ad62:	0a 9c       	mov	r12,r5
8000ad64:	fe b0 e0 6c 	rcall	80006e3c <_malloc_r>
8000ad68:	18 92       	mov	r2,r12
8000ad6a:	c1 40       	breq	8000ad92 <__sfvwrite_r+0x11e>
8000ad6c:	40 0a       	lddsp	r10,sp[0x0]
8000ad6e:	6e 4b       	ld.w	r11,r7[0x10]
8000ad70:	fe b0 e2 82 	rcall	80007274 <memcpy>
8000ad74:	8e 68       	ld.sh	r8,r7[0xc]
8000ad76:	e0 18 fb 7f 	andl	r8,0xfb7f
8000ad7a:	a7 b8       	sbr	r8,0x7
8000ad7c:	ae 68       	st.h	r7[0xc],r8
8000ad7e:	c0 d8       	rjmp	8000ad98 <__sfvwrite_r+0x124>
8000ad80:	08 9a       	mov	r10,r4
8000ad82:	0a 9c       	mov	r12,r5
8000ad84:	fe b0 e3 24 	rcall	800073cc <_realloc_r>
8000ad88:	18 92       	mov	r2,r12
8000ad8a:	c0 71       	brne	8000ad98 <__sfvwrite_r+0x124>
8000ad8c:	6e 4b       	ld.w	r11,r7[0x10]
8000ad8e:	0a 9c       	mov	r12,r5
8000ad90:	ca ce       	rcall	8000aae8 <_free_r>
8000ad92:	30 c8       	mov	r8,12
8000ad94:	8b 38       	st.w	r5[0xc],r8
8000ad96:	cb 18       	rjmp	8000aef8 <__sfvwrite_r+0x284>
8000ad98:	40 0a       	lddsp	r10,sp[0x0]
8000ad9a:	40 09       	lddsp	r9,sp[0x0]
8000ad9c:	e8 0a 01 0a 	sub	r10,r4,r10
8000ada0:	e4 09 00 08 	add	r8,r2,r9
8000ada4:	8f 54       	st.w	r7[0x14],r4
8000ada6:	8f 2a       	st.w	r7[0x8],r10
8000ada8:	8f 08       	st.w	r7[0x0],r8
8000adaa:	8f 42       	st.w	r7[0x10],r2
8000adac:	0c 94       	mov	r4,r6
8000adae:	08 36       	cp.w	r6,r4
8000adb0:	ec 04 17 30 	movlo	r4,r6
8000adb4:	06 9b       	mov	r11,r3
8000adb6:	08 9a       	mov	r10,r4
8000adb8:	6e 0c       	ld.w	r12,r7[0x0]
8000adba:	c3 ad       	rcall	8000b02e <memmove>
8000adbc:	6e 08       	ld.w	r8,r7[0x0]
8000adbe:	08 08       	add	r8,r4
8000adc0:	8f 08       	st.w	r7[0x0],r8
8000adc2:	6e 28       	ld.w	r8,r7[0x8]
8000adc4:	08 18       	sub	r8,r4
8000adc6:	0c 94       	mov	r4,r6
8000adc8:	8f 28       	st.w	r7[0x8],r8
8000adca:	c2 e8       	rjmp	8000ae26 <__sfvwrite_r+0x1b2>
8000adcc:	08 36       	cp.w	r6,r4
8000adce:	5f ba       	srhi	r10
8000add0:	6e 0c       	ld.w	r12,r7[0x0]
8000add2:	6e 48       	ld.w	r8,r7[0x10]
8000add4:	10 3c       	cp.w	r12,r8
8000add6:	5f b8       	srhi	r8
8000add8:	f5 e8 00 08 	and	r8,r10,r8
8000addc:	f2 08 18 00 	cp.b	r8,r9
8000ade0:	c0 d0       	breq	8000adfa <__sfvwrite_r+0x186>
8000ade2:	06 9b       	mov	r11,r3
8000ade4:	08 9a       	mov	r10,r4
8000ade6:	c2 4d       	rcall	8000b02e <memmove>
8000ade8:	6e 08       	ld.w	r8,r7[0x0]
8000adea:	08 08       	add	r8,r4
8000adec:	0e 9b       	mov	r11,r7
8000adee:	8f 08       	st.w	r7[0x0],r8
8000adf0:	0a 9c       	mov	r12,r5
8000adf2:	fe b0 fd 09 	rcall	8000a804 <_fflush_r>
8000adf6:	c1 80       	breq	8000ae26 <__sfvwrite_r+0x1b2>
8000adf8:	c8 08       	rjmp	8000aef8 <__sfvwrite_r+0x284>
8000adfa:	6e 59       	ld.w	r9,r7[0x14]
8000adfc:	12 36       	cp.w	r6,r9
8000adfe:	c0 a3       	brcs	8000ae12 <__sfvwrite_r+0x19e>
8000ae00:	6e a8       	ld.w	r8,r7[0x28]
8000ae02:	06 9a       	mov	r10,r3
8000ae04:	6e 8b       	ld.w	r11,r7[0x20]
8000ae06:	0a 9c       	mov	r12,r5
8000ae08:	5d 18       	icall	r8
8000ae0a:	18 94       	mov	r4,r12
8000ae0c:	e0 89 00 0d 	brgt	8000ae26 <__sfvwrite_r+0x1b2>
8000ae10:	c7 48       	rjmp	8000aef8 <__sfvwrite_r+0x284>
8000ae12:	0c 9a       	mov	r10,r6
8000ae14:	06 9b       	mov	r11,r3
8000ae16:	c0 cd       	rcall	8000b02e <memmove>
8000ae18:	6e 08       	ld.w	r8,r7[0x0]
8000ae1a:	0c 08       	add	r8,r6
8000ae1c:	0c 94       	mov	r4,r6
8000ae1e:	8f 08       	st.w	r7[0x0],r8
8000ae20:	6e 28       	ld.w	r8,r7[0x8]
8000ae22:	0c 18       	sub	r8,r6
8000ae24:	8f 28       	st.w	r7[0x8],r8
8000ae26:	62 28       	ld.w	r8,r1[0x8]
8000ae28:	08 18       	sub	r8,r4
8000ae2a:	83 28       	st.w	r1[0x8],r8
8000ae2c:	c6 b0       	breq	8000af02 <__sfvwrite_r+0x28e>
8000ae2e:	08 16       	sub	r6,r4
8000ae30:	08 03       	add	r3,r4
8000ae32:	c7 1b       	rjmp	8000ad14 <__sfvwrite_r+0xa0>
8000ae34:	60 03       	ld.w	r3,r0[0x0]
8000ae36:	60 11       	ld.w	r1,r0[0x4]
8000ae38:	30 08       	mov	r8,0
8000ae3a:	2f 80       	sub	r0,-8
8000ae3c:	50 08       	stdsp	sp[0x0],r8
8000ae3e:	58 01       	cp.w	r1,0
8000ae40:	cf a0       	breq	8000ae34 <__sfvwrite_r+0x1c0>
8000ae42:	40 0a       	lddsp	r10,sp[0x0]
8000ae44:	58 0a       	cp.w	r10,0
8000ae46:	c1 41       	brne	8000ae6e <__sfvwrite_r+0x1fa>
8000ae48:	e2 c6 ff ff 	sub	r6,r1,-1
8000ae4c:	02 9a       	mov	r10,r1
8000ae4e:	30 ab       	mov	r11,10
8000ae50:	06 9c       	mov	r12,r3
8000ae52:	ce 3c       	rcall	8000b018 <memchr>
8000ae54:	f8 c8 ff ff 	sub	r8,r12,-1
8000ae58:	58 0c       	cp.w	r12,0
8000ae5a:	f1 d3 e1 16 	subne	r6,r8,r3
8000ae5e:	f9 b9 01 01 	movne	r9,1
8000ae62:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000ae66:	f9 b8 00 01 	moveq	r8,1
8000ae6a:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000ae6e:	02 36       	cp.w	r6,r1
8000ae70:	ec 04 17 80 	movls	r4,r6
8000ae74:	e2 04 17 b0 	movhi	r4,r1
8000ae78:	6e 59       	ld.w	r9,r7[0x14]
8000ae7a:	6e 25       	ld.w	r5,r7[0x8]
8000ae7c:	f2 05 00 05 	add	r5,r9,r5
8000ae80:	0a 34       	cp.w	r4,r5
8000ae82:	5f 9a       	srgt	r10
8000ae84:	6e 0c       	ld.w	r12,r7[0x0]
8000ae86:	6e 48       	ld.w	r8,r7[0x10]
8000ae88:	10 3c       	cp.w	r12,r8
8000ae8a:	5f b8       	srhi	r8
8000ae8c:	f5 e8 00 08 	and	r8,r10,r8
8000ae90:	30 0a       	mov	r10,0
8000ae92:	f4 08 18 00 	cp.b	r8,r10
8000ae96:	c0 d0       	breq	8000aeb0 <__sfvwrite_r+0x23c>
8000ae98:	06 9b       	mov	r11,r3
8000ae9a:	0a 9a       	mov	r10,r5
8000ae9c:	cc 9c       	rcall	8000b02e <memmove>
8000ae9e:	6e 08       	ld.w	r8,r7[0x0]
8000aea0:	0a 08       	add	r8,r5
8000aea2:	0e 9b       	mov	r11,r7
8000aea4:	8f 08       	st.w	r7[0x0],r8
8000aea6:	40 1c       	lddsp	r12,sp[0x4]
8000aea8:	fe b0 fc ae 	rcall	8000a804 <_fflush_r>
8000aeac:	c1 70       	breq	8000aeda <__sfvwrite_r+0x266>
8000aeae:	c2 58       	rjmp	8000aef8 <__sfvwrite_r+0x284>
8000aeb0:	12 34       	cp.w	r4,r9
8000aeb2:	c0 a5       	brlt	8000aec6 <__sfvwrite_r+0x252>
8000aeb4:	6e a8       	ld.w	r8,r7[0x28]
8000aeb6:	06 9a       	mov	r10,r3
8000aeb8:	6e 8b       	ld.w	r11,r7[0x20]
8000aeba:	40 1c       	lddsp	r12,sp[0x4]
8000aebc:	5d 18       	icall	r8
8000aebe:	18 95       	mov	r5,r12
8000aec0:	e0 89 00 0d 	brgt	8000aeda <__sfvwrite_r+0x266>
8000aec4:	c1 a8       	rjmp	8000aef8 <__sfvwrite_r+0x284>
8000aec6:	08 9a       	mov	r10,r4
8000aec8:	06 9b       	mov	r11,r3
8000aeca:	cb 2c       	rcall	8000b02e <memmove>
8000aecc:	6e 08       	ld.w	r8,r7[0x0]
8000aece:	08 08       	add	r8,r4
8000aed0:	08 95       	mov	r5,r4
8000aed2:	8f 08       	st.w	r7[0x0],r8
8000aed4:	6e 28       	ld.w	r8,r7[0x8]
8000aed6:	08 18       	sub	r8,r4
8000aed8:	8f 28       	st.w	r7[0x8],r8
8000aeda:	0a 16       	sub	r6,r5
8000aedc:	c0 71       	brne	8000aeea <__sfvwrite_r+0x276>
8000aede:	0e 9b       	mov	r11,r7
8000aee0:	40 1c       	lddsp	r12,sp[0x4]
8000aee2:	fe b0 fc 91 	rcall	8000a804 <_fflush_r>
8000aee6:	c0 91       	brne	8000aef8 <__sfvwrite_r+0x284>
8000aee8:	50 06       	stdsp	sp[0x0],r6
8000aeea:	64 28       	ld.w	r8,r2[0x8]
8000aeec:	0a 18       	sub	r8,r5
8000aeee:	85 28       	st.w	r2[0x8],r8
8000aef0:	c0 90       	breq	8000af02 <__sfvwrite_r+0x28e>
8000aef2:	0a 11       	sub	r1,r5
8000aef4:	0a 03       	add	r3,r5
8000aef6:	ca 4b       	rjmp	8000ae3e <__sfvwrite_r+0x1ca>
8000aef8:	8e 68       	ld.sh	r8,r7[0xc]
8000aefa:	a7 a8       	sbr	r8,0x6
8000aefc:	ae 68       	st.h	r7[0xc],r8
8000aefe:	3f fc       	mov	r12,-1
8000af00:	c0 28       	rjmp	8000af04 <__sfvwrite_r+0x290>
8000af02:	30 0c       	mov	r12,0
8000af04:	2f dd       	sub	sp,-12
8000af06:	d8 32       	popm	r0-r7,pc

8000af08 <_fwalk>:
8000af08:	d4 31       	pushm	r0-r7,lr
8000af0a:	30 05       	mov	r5,0
8000af0c:	16 91       	mov	r1,r11
8000af0e:	f8 c7 ff 28 	sub	r7,r12,-216
8000af12:	0a 92       	mov	r2,r5
8000af14:	fe b0 fc fe 	rcall	8000a910 <__sfp_lock_acquire>
8000af18:	3f f3       	mov	r3,-1
8000af1a:	c1 68       	rjmp	8000af46 <_fwalk+0x3e>
8000af1c:	6e 26       	ld.w	r6,r7[0x8]
8000af1e:	6e 14       	ld.w	r4,r7[0x4]
8000af20:	2f 46       	sub	r6,-12
8000af22:	c0 c8       	rjmp	8000af3a <_fwalk+0x32>
8000af24:	8c 08       	ld.sh	r8,r6[0x0]
8000af26:	e4 08 19 00 	cp.h	r8,r2
8000af2a:	c0 70       	breq	8000af38 <_fwalk+0x30>
8000af2c:	8c 18       	ld.sh	r8,r6[0x2]
8000af2e:	e6 08 19 00 	cp.h	r8,r3
8000af32:	c0 30       	breq	8000af38 <_fwalk+0x30>
8000af34:	5d 11       	icall	r1
8000af36:	18 45       	or	r5,r12
8000af38:	2a 46       	sub	r6,-92
8000af3a:	20 14       	sub	r4,1
8000af3c:	ec cc 00 0c 	sub	r12,r6,12
8000af40:	58 04       	cp.w	r4,0
8000af42:	cf 14       	brge	8000af24 <_fwalk+0x1c>
8000af44:	6e 07       	ld.w	r7,r7[0x0]
8000af46:	58 07       	cp.w	r7,0
8000af48:	ce a1       	brne	8000af1c <_fwalk+0x14>
8000af4a:	fe b0 fc e4 	rcall	8000a912 <__sfp_lock_release>
8000af4e:	0a 9c       	mov	r12,r5
8000af50:	d8 32       	popm	r0-r7,pc
8000af52:	d7 03       	nop

8000af54 <_localeconv_r>:
8000af54:	fe cc d5 2c 	sub	r12,pc,-10964
8000af58:	5e fc       	retal	r12
8000af5a:	d7 03       	nop

8000af5c <__smakebuf_r>:
8000af5c:	d4 21       	pushm	r4-r7,lr
8000af5e:	20 fd       	sub	sp,60
8000af60:	96 68       	ld.sh	r8,r11[0xc]
8000af62:	16 97       	mov	r7,r11
8000af64:	18 96       	mov	r6,r12
8000af66:	e2 18 00 02 	andl	r8,0x2,COH
8000af6a:	c3 d1       	brne	8000afe4 <__smakebuf_r+0x88>
8000af6c:	96 7b       	ld.sh	r11,r11[0xe]
8000af6e:	f0 0b 19 00 	cp.h	r11,r8
8000af72:	c0 55       	brlt	8000af7c <__smakebuf_r+0x20>
8000af74:	1a 9a       	mov	r10,sp
8000af76:	e0 a0 04 81 	rcall	8000b878 <_fstat_r>
8000af7a:	c0 f4       	brge	8000af98 <__smakebuf_r+0x3c>
8000af7c:	8e 65       	ld.sh	r5,r7[0xc]
8000af7e:	0a 98       	mov	r8,r5
8000af80:	ab b8       	sbr	r8,0xb
8000af82:	e2 15 00 80 	andl	r5,0x80,COH
8000af86:	ae 68       	st.h	r7[0xc],r8
8000af88:	30 04       	mov	r4,0
8000af8a:	e0 68 04 00 	mov	r8,1024
8000af8e:	f9 b5 01 40 	movne	r5,64
8000af92:	f0 05 17 00 	moveq	r5,r8
8000af96:	c1 c8       	rjmp	8000afce <__smakebuf_r+0x72>
8000af98:	40 18       	lddsp	r8,sp[0x4]
8000af9a:	e2 18 f0 00 	andl	r8,0xf000,COH
8000af9e:	e0 48 20 00 	cp.w	r8,8192
8000afa2:	5f 04       	sreq	r4
8000afa4:	e0 48 80 00 	cp.w	r8,32768
8000afa8:	c0 e1       	brne	8000afc4 <__smakebuf_r+0x68>
8000afaa:	6e b9       	ld.w	r9,r7[0x2c]
8000afac:	fe c8 f9 1c 	sub	r8,pc,-1764
8000afb0:	10 39       	cp.w	r9,r8
8000afb2:	c0 91       	brne	8000afc4 <__smakebuf_r+0x68>
8000afb4:	8e 68       	ld.sh	r8,r7[0xc]
8000afb6:	e0 65 04 00 	mov	r5,1024
8000afba:	ab a8       	sbr	r8,0xa
8000afbc:	ef 45 00 50 	st.w	r7[80],r5
8000afc0:	ae 68       	st.h	r7[0xc],r8
8000afc2:	c0 68       	rjmp	8000afce <__smakebuf_r+0x72>
8000afc4:	8e 68       	ld.sh	r8,r7[0xc]
8000afc6:	e0 65 04 00 	mov	r5,1024
8000afca:	ab b8       	sbr	r8,0xb
8000afcc:	ae 68       	st.h	r7[0xc],r8
8000afce:	0a 9b       	mov	r11,r5
8000afd0:	0c 9c       	mov	r12,r6
8000afd2:	fe b0 df 35 	rcall	80006e3c <_malloc_r>
8000afd6:	8e 68       	ld.sh	r8,r7[0xc]
8000afd8:	c0 d1       	brne	8000aff2 <__smakebuf_r+0x96>
8000afda:	ed b8 00 09 	bld	r8,0x9
8000afde:	c1 b0       	breq	8000b014 <__smakebuf_r+0xb8>
8000afe0:	a1 b8       	sbr	r8,0x1
8000afe2:	ae 68       	st.h	r7[0xc],r8
8000afe4:	ee c8 ff b9 	sub	r8,r7,-71
8000afe8:	8f 48       	st.w	r7[0x10],r8
8000afea:	8f 08       	st.w	r7[0x0],r8
8000afec:	30 18       	mov	r8,1
8000afee:	8f 58       	st.w	r7[0x14],r8
8000aff0:	c1 28       	rjmp	8000b014 <__smakebuf_r+0xb8>
8000aff2:	a7 b8       	sbr	r8,0x7
8000aff4:	8f 4c       	st.w	r7[0x10],r12
8000aff6:	ae 68       	st.h	r7[0xc],r8
8000aff8:	8f 55       	st.w	r7[0x14],r5
8000affa:	fe c8 06 e6 	sub	r8,pc,1766
8000affe:	8f 0c       	st.w	r7[0x0],r12
8000b000:	8d a8       	st.w	r6[0x28],r8
8000b002:	58 04       	cp.w	r4,0
8000b004:	c0 80       	breq	8000b014 <__smakebuf_r+0xb8>
8000b006:	8e 7c       	ld.sh	r12,r7[0xe]
8000b008:	fe b0 e3 94 	rcall	80007730 <isatty>
8000b00c:	c0 40       	breq	8000b014 <__smakebuf_r+0xb8>
8000b00e:	8e 68       	ld.sh	r8,r7[0xc]
8000b010:	a1 a8       	sbr	r8,0x0
8000b012:	ae 68       	st.h	r7[0xc],r8
8000b014:	2f 1d       	sub	sp,-60
8000b016:	d8 22       	popm	r4-r7,pc

8000b018 <memchr>:
8000b018:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b01c:	c0 68       	rjmp	8000b028 <memchr+0x10>
8000b01e:	20 1a       	sub	r10,1
8000b020:	19 88       	ld.ub	r8,r12[0x0]
8000b022:	16 38       	cp.w	r8,r11
8000b024:	5e 0c       	reteq	r12
8000b026:	2f fc       	sub	r12,-1
8000b028:	58 0a       	cp.w	r10,0
8000b02a:	cf a1       	brne	8000b01e <memchr+0x6>
8000b02c:	5e fa       	retal	r10

8000b02e <memmove>:
8000b02e:	d4 01       	pushm	lr
8000b030:	18 3b       	cp.w	r11,r12
8000b032:	c1 92       	brcc	8000b064 <memmove+0x36>
8000b034:	f6 0a 00 09 	add	r9,r11,r10
8000b038:	12 3c       	cp.w	r12,r9
8000b03a:	c1 52       	brcc	8000b064 <memmove+0x36>
8000b03c:	f8 0a 00 0b 	add	r11,r12,r10
8000b040:	30 08       	mov	r8,0
8000b042:	c0 68       	rjmp	8000b04e <memmove+0x20>
8000b044:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b048:	20 1a       	sub	r10,1
8000b04a:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b04e:	20 18       	sub	r8,1
8000b050:	58 0a       	cp.w	r10,0
8000b052:	cf 91       	brne	8000b044 <memmove+0x16>
8000b054:	d8 02       	popm	pc
8000b056:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b05a:	20 1a       	sub	r10,1
8000b05c:	f8 08 0b 09 	st.b	r12[r8],r9
8000b060:	2f f8       	sub	r8,-1
8000b062:	c0 28       	rjmp	8000b066 <memmove+0x38>
8000b064:	30 08       	mov	r8,0
8000b066:	58 0a       	cp.w	r10,0
8000b068:	cf 71       	brne	8000b056 <memmove+0x28>
8000b06a:	d8 02       	popm	pc

8000b06c <__hi0bits>:
8000b06c:	18 98       	mov	r8,r12
8000b06e:	e0 1c 00 00 	andl	r12,0x0
8000b072:	f0 09 15 10 	lsl	r9,r8,0x10
8000b076:	58 0c       	cp.w	r12,0
8000b078:	f2 08 17 00 	moveq	r8,r9
8000b07c:	f9 bc 00 10 	moveq	r12,16
8000b080:	f9 bc 01 00 	movne	r12,0
8000b084:	10 9a       	mov	r10,r8
8000b086:	f0 09 15 08 	lsl	r9,r8,0x8
8000b08a:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b08e:	f7 bc 00 f8 	subeq	r12,-8
8000b092:	f2 08 17 00 	moveq	r8,r9
8000b096:	10 9a       	mov	r10,r8
8000b098:	f0 09 15 04 	lsl	r9,r8,0x4
8000b09c:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b0a0:	f7 bc 00 fc 	subeq	r12,-4
8000b0a4:	f2 08 17 00 	moveq	r8,r9
8000b0a8:	10 9a       	mov	r10,r8
8000b0aa:	f0 09 15 02 	lsl	r9,r8,0x2
8000b0ae:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b0b2:	f7 bc 00 fe 	subeq	r12,-2
8000b0b6:	f2 08 17 00 	moveq	r8,r9
8000b0ba:	58 08       	cp.w	r8,0
8000b0bc:	5e 5c       	retlt	r12
8000b0be:	ed b8 00 1e 	bld	r8,0x1e
8000b0c2:	f9 bc 01 20 	movne	r12,32
8000b0c6:	f7 bc 00 ff 	subeq	r12,-1
8000b0ca:	5e fc       	retal	r12

8000b0cc <__lo0bits>:
8000b0cc:	18 99       	mov	r9,r12
8000b0ce:	78 08       	ld.w	r8,r12[0x0]
8000b0d0:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b0d4:	c1 50       	breq	8000b0fe <__lo0bits+0x32>
8000b0d6:	ed b8 00 00 	bld	r8,0x0
8000b0da:	c0 21       	brne	8000b0de <__lo0bits+0x12>
8000b0dc:	5e fd       	retal	0
8000b0de:	10 9b       	mov	r11,r8
8000b0e0:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b0e4:	e2 1b 00 02 	andl	r11,0x2,COH
8000b0e8:	a3 88       	lsr	r8,0x2
8000b0ea:	58 0b       	cp.w	r11,0
8000b0ec:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b0f0:	f9 bc 01 01 	movne	r12,1
8000b0f4:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b0f8:	f9 bc 00 02 	moveq	r12,2
8000b0fc:	5e fc       	retal	r12
8000b0fe:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b102:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b106:	58 0a       	cp.w	r10,0
8000b108:	f6 08 17 00 	moveq	r8,r11
8000b10c:	f9 bc 00 10 	moveq	r12,16
8000b110:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b114:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b118:	58 0b       	cp.w	r11,0
8000b11a:	f7 bc 00 f8 	subeq	r12,-8
8000b11e:	f4 08 17 00 	moveq	r8,r10
8000b122:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b126:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b12a:	58 0b       	cp.w	r11,0
8000b12c:	f7 bc 00 fc 	subeq	r12,-4
8000b130:	f4 08 17 00 	moveq	r8,r10
8000b134:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b138:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b13c:	58 0b       	cp.w	r11,0
8000b13e:	f7 bc 00 fe 	subeq	r12,-2
8000b142:	f4 08 17 00 	moveq	r8,r10
8000b146:	ed b8 00 00 	bld	r8,0x0
8000b14a:	c0 60       	breq	8000b156 <__lo0bits+0x8a>
8000b14c:	a1 98       	lsr	r8,0x1
8000b14e:	c0 31       	brne	8000b154 <__lo0bits+0x88>
8000b150:	32 0c       	mov	r12,32
8000b152:	5e fc       	retal	r12
8000b154:	2f fc       	sub	r12,-1
8000b156:	93 08       	st.w	r9[0x0],r8
8000b158:	5e fc       	retal	r12

8000b15a <__mcmp>:
8000b15a:	d4 01       	pushm	lr
8000b15c:	18 98       	mov	r8,r12
8000b15e:	76 49       	ld.w	r9,r11[0x10]
8000b160:	78 4c       	ld.w	r12,r12[0x10]
8000b162:	12 1c       	sub	r12,r9
8000b164:	c1 31       	brne	8000b18a <__mcmp+0x30>
8000b166:	2f b9       	sub	r9,-5
8000b168:	a3 69       	lsl	r9,0x2
8000b16a:	12 0b       	add	r11,r9
8000b16c:	f0 09 00 09 	add	r9,r8,r9
8000b170:	2e c8       	sub	r8,-20
8000b172:	13 4e       	ld.w	lr,--r9
8000b174:	17 4a       	ld.w	r10,--r11
8000b176:	14 3e       	cp.w	lr,r10
8000b178:	c0 60       	breq	8000b184 <__mcmp+0x2a>
8000b17a:	f9 bc 03 ff 	movlo	r12,-1
8000b17e:	f9 bc 02 01 	movhs	r12,1
8000b182:	d8 02       	popm	pc
8000b184:	10 39       	cp.w	r9,r8
8000b186:	fe 9b ff f6 	brhi	8000b172 <__mcmp+0x18>
8000b18a:	d8 02       	popm	pc

8000b18c <_Bfree>:
8000b18c:	d4 21       	pushm	r4-r7,lr
8000b18e:	18 97       	mov	r7,r12
8000b190:	16 95       	mov	r5,r11
8000b192:	78 96       	ld.w	r6,r12[0x24]
8000b194:	58 06       	cp.w	r6,0
8000b196:	c0 91       	brne	8000b1a8 <_Bfree+0x1c>
8000b198:	31 0c       	mov	r12,16
8000b19a:	fe b0 de 49 	rcall	80006e2c <malloc>
8000b19e:	99 36       	st.w	r12[0xc],r6
8000b1a0:	8f 9c       	st.w	r7[0x24],r12
8000b1a2:	99 16       	st.w	r12[0x4],r6
8000b1a4:	99 26       	st.w	r12[0x8],r6
8000b1a6:	99 06       	st.w	r12[0x0],r6
8000b1a8:	58 05       	cp.w	r5,0
8000b1aa:	c0 90       	breq	8000b1bc <_Bfree+0x30>
8000b1ac:	6a 19       	ld.w	r9,r5[0x4]
8000b1ae:	6e 98       	ld.w	r8,r7[0x24]
8000b1b0:	70 38       	ld.w	r8,r8[0xc]
8000b1b2:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b1b6:	8b 0a       	st.w	r5[0x0],r10
8000b1b8:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b1bc:	d8 22       	popm	r4-r7,pc
8000b1be:	d7 03       	nop

8000b1c0 <_Balloc>:
8000b1c0:	d4 21       	pushm	r4-r7,lr
8000b1c2:	18 97       	mov	r7,r12
8000b1c4:	16 96       	mov	r6,r11
8000b1c6:	78 95       	ld.w	r5,r12[0x24]
8000b1c8:	58 05       	cp.w	r5,0
8000b1ca:	c0 91       	brne	8000b1dc <_Balloc+0x1c>
8000b1cc:	31 0c       	mov	r12,16
8000b1ce:	fe b0 de 2f 	rcall	80006e2c <malloc>
8000b1d2:	99 35       	st.w	r12[0xc],r5
8000b1d4:	8f 9c       	st.w	r7[0x24],r12
8000b1d6:	99 15       	st.w	r12[0x4],r5
8000b1d8:	99 25       	st.w	r12[0x8],r5
8000b1da:	99 05       	st.w	r12[0x0],r5
8000b1dc:	6e 95       	ld.w	r5,r7[0x24]
8000b1de:	6a 38       	ld.w	r8,r5[0xc]
8000b1e0:	58 08       	cp.w	r8,0
8000b1e2:	c0 b1       	brne	8000b1f8 <_Balloc+0x38>
8000b1e4:	31 0a       	mov	r10,16
8000b1e6:	30 4b       	mov	r11,4
8000b1e8:	0e 9c       	mov	r12,r7
8000b1ea:	e0 a0 02 a7 	rcall	8000b738 <_calloc_r>
8000b1ee:	8b 3c       	st.w	r5[0xc],r12
8000b1f0:	6e 98       	ld.w	r8,r7[0x24]
8000b1f2:	70 3c       	ld.w	r12,r8[0xc]
8000b1f4:	58 0c       	cp.w	r12,0
8000b1f6:	c1 b0       	breq	8000b22c <_Balloc+0x6c>
8000b1f8:	6e 98       	ld.w	r8,r7[0x24]
8000b1fa:	70 38       	ld.w	r8,r8[0xc]
8000b1fc:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b200:	70 0c       	ld.w	r12,r8[0x0]
8000b202:	58 0c       	cp.w	r12,0
8000b204:	c0 40       	breq	8000b20c <_Balloc+0x4c>
8000b206:	78 09       	ld.w	r9,r12[0x0]
8000b208:	91 09       	st.w	r8[0x0],r9
8000b20a:	c0 e8       	rjmp	8000b226 <_Balloc+0x66>
8000b20c:	0e 9c       	mov	r12,r7
8000b20e:	30 17       	mov	r7,1
8000b210:	0e 9b       	mov	r11,r7
8000b212:	ee 06 09 47 	lsl	r7,r7,r6
8000b216:	ee ca ff fb 	sub	r10,r7,-5
8000b21a:	a3 6a       	lsl	r10,0x2
8000b21c:	e0 a0 02 8e 	rcall	8000b738 <_calloc_r>
8000b220:	c0 60       	breq	8000b22c <_Balloc+0x6c>
8000b222:	99 16       	st.w	r12[0x4],r6
8000b224:	99 27       	st.w	r12[0x8],r7
8000b226:	30 08       	mov	r8,0
8000b228:	99 38       	st.w	r12[0xc],r8
8000b22a:	99 48       	st.w	r12[0x10],r8
8000b22c:	d8 22       	popm	r4-r7,pc
8000b22e:	d7 03       	nop

8000b230 <__d2b>:
8000b230:	d4 31       	pushm	r0-r7,lr
8000b232:	20 2d       	sub	sp,8
8000b234:	16 93       	mov	r3,r11
8000b236:	12 96       	mov	r6,r9
8000b238:	10 95       	mov	r5,r8
8000b23a:	14 92       	mov	r2,r10
8000b23c:	30 1b       	mov	r11,1
8000b23e:	cc 1f       	rcall	8000b1c0 <_Balloc>
8000b240:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b244:	50 09       	stdsp	sp[0x0],r9
8000b246:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b24a:	b5 a9       	sbr	r9,0x14
8000b24c:	f0 01 16 14 	lsr	r1,r8,0x14
8000b250:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b254:	18 94       	mov	r4,r12
8000b256:	58 02       	cp.w	r2,0
8000b258:	c1 d0       	breq	8000b292 <__d2b+0x62>
8000b25a:	fa cc ff f8 	sub	r12,sp,-8
8000b25e:	18 d2       	st.w	--r12,r2
8000b260:	c3 6f       	rcall	8000b0cc <__lo0bits>
8000b262:	40 18       	lddsp	r8,sp[0x4]
8000b264:	c0 d0       	breq	8000b27e <__d2b+0x4e>
8000b266:	40 09       	lddsp	r9,sp[0x0]
8000b268:	f8 0a 11 20 	rsub	r10,r12,32
8000b26c:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b270:	f5 e8 10 08 	or	r8,r10,r8
8000b274:	89 58       	st.w	r4[0x14],r8
8000b276:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b27a:	50 09       	stdsp	sp[0x0],r9
8000b27c:	c0 28       	rjmp	8000b280 <__d2b+0x50>
8000b27e:	89 58       	st.w	r4[0x14],r8
8000b280:	40 08       	lddsp	r8,sp[0x0]
8000b282:	58 08       	cp.w	r8,0
8000b284:	f9 b3 01 02 	movne	r3,2
8000b288:	f9 b3 00 01 	moveq	r3,1
8000b28c:	89 68       	st.w	r4[0x18],r8
8000b28e:	89 43       	st.w	r4[0x10],r3
8000b290:	c0 88       	rjmp	8000b2a0 <__d2b+0x70>
8000b292:	1a 9c       	mov	r12,sp
8000b294:	c1 cf       	rcall	8000b0cc <__lo0bits>
8000b296:	30 13       	mov	r3,1
8000b298:	40 08       	lddsp	r8,sp[0x0]
8000b29a:	2e 0c       	sub	r12,-32
8000b29c:	89 43       	st.w	r4[0x10],r3
8000b29e:	89 58       	st.w	r4[0x14],r8
8000b2a0:	58 01       	cp.w	r1,0
8000b2a2:	c0 90       	breq	8000b2b4 <__d2b+0x84>
8000b2a4:	e2 c1 04 33 	sub	r1,r1,1075
8000b2a8:	18 01       	add	r1,r12
8000b2aa:	8d 01       	st.w	r6[0x0],r1
8000b2ac:	f8 0c 11 35 	rsub	r12,r12,53
8000b2b0:	8b 0c       	st.w	r5[0x0],r12
8000b2b2:	c0 c8       	rjmp	8000b2ca <__d2b+0x9a>
8000b2b4:	e6 c8 ff fc 	sub	r8,r3,-4
8000b2b8:	f8 cc 04 32 	sub	r12,r12,1074
8000b2bc:	a5 73       	lsl	r3,0x5
8000b2be:	8d 0c       	st.w	r6[0x0],r12
8000b2c0:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b2c4:	cd 4e       	rcall	8000b06c <__hi0bits>
8000b2c6:	18 13       	sub	r3,r12
8000b2c8:	8b 03       	st.w	r5[0x0],r3
8000b2ca:	08 9c       	mov	r12,r4
8000b2cc:	2f ed       	sub	sp,-8
8000b2ce:	d8 32       	popm	r0-r7,pc

8000b2d0 <__mdiff>:
8000b2d0:	d4 31       	pushm	r0-r7,lr
8000b2d2:	74 48       	ld.w	r8,r10[0x10]
8000b2d4:	76 45       	ld.w	r5,r11[0x10]
8000b2d6:	16 97       	mov	r7,r11
8000b2d8:	14 96       	mov	r6,r10
8000b2da:	10 15       	sub	r5,r8
8000b2dc:	c1 31       	brne	8000b302 <__mdiff+0x32>
8000b2de:	2f b8       	sub	r8,-5
8000b2e0:	ee ce ff ec 	sub	lr,r7,-20
8000b2e4:	a3 68       	lsl	r8,0x2
8000b2e6:	f4 08 00 0b 	add	r11,r10,r8
8000b2ea:	ee 08 00 08 	add	r8,r7,r8
8000b2ee:	11 4a       	ld.w	r10,--r8
8000b2f0:	17 49       	ld.w	r9,--r11
8000b2f2:	12 3a       	cp.w	r10,r9
8000b2f4:	c0 30       	breq	8000b2fa <__mdiff+0x2a>
8000b2f6:	c0 e2       	brcc	8000b312 <__mdiff+0x42>
8000b2f8:	c0 78       	rjmp	8000b306 <__mdiff+0x36>
8000b2fa:	1c 38       	cp.w	r8,lr
8000b2fc:	fe 9b ff f9 	brhi	8000b2ee <__mdiff+0x1e>
8000b300:	c4 98       	rjmp	8000b392 <__mdiff+0xc2>
8000b302:	58 05       	cp.w	r5,0
8000b304:	c0 64       	brge	8000b310 <__mdiff+0x40>
8000b306:	0e 98       	mov	r8,r7
8000b308:	30 15       	mov	r5,1
8000b30a:	0c 97       	mov	r7,r6
8000b30c:	10 96       	mov	r6,r8
8000b30e:	c0 28       	rjmp	8000b312 <__mdiff+0x42>
8000b310:	30 05       	mov	r5,0
8000b312:	6e 1b       	ld.w	r11,r7[0x4]
8000b314:	c5 6f       	rcall	8000b1c0 <_Balloc>
8000b316:	6e 49       	ld.w	r9,r7[0x10]
8000b318:	6c 44       	ld.w	r4,r6[0x10]
8000b31a:	99 35       	st.w	r12[0xc],r5
8000b31c:	2f b4       	sub	r4,-5
8000b31e:	f2 c5 ff fb 	sub	r5,r9,-5
8000b322:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b326:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b32a:	2e c6       	sub	r6,-20
8000b32c:	2e c7       	sub	r7,-20
8000b32e:	f8 c8 ff ec 	sub	r8,r12,-20
8000b332:	30 0a       	mov	r10,0
8000b334:	0f 0e       	ld.w	lr,r7++
8000b336:	0d 0b       	ld.w	r11,r6++
8000b338:	fc 02 16 10 	lsr	r2,lr,0x10
8000b33c:	f6 03 16 10 	lsr	r3,r11,0x10
8000b340:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b344:	e4 03 01 03 	sub	r3,r2,r3
8000b348:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b34c:	fc 0b 01 0b 	sub	r11,lr,r11
8000b350:	f6 0a 00 0a 	add	r10,r11,r10
8000b354:	b0 1a       	st.h	r8[0x2],r10
8000b356:	b1 4a       	asr	r10,0x10
8000b358:	e6 0a 00 0a 	add	r10,r3,r10
8000b35c:	b0 0a       	st.h	r8[0x0],r10
8000b35e:	2f c8       	sub	r8,-4
8000b360:	b1 4a       	asr	r10,0x10
8000b362:	08 36       	cp.w	r6,r4
8000b364:	ce 83       	brcs	8000b334 <__mdiff+0x64>
8000b366:	c0 d8       	rjmp	8000b380 <__mdiff+0xb0>
8000b368:	0f 0b       	ld.w	r11,r7++
8000b36a:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b36e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b372:	16 0a       	add	r10,r11
8000b374:	b0 1a       	st.h	r8[0x2],r10
8000b376:	b1 4a       	asr	r10,0x10
8000b378:	1c 0a       	add	r10,lr
8000b37a:	b0 0a       	st.h	r8[0x0],r10
8000b37c:	2f c8       	sub	r8,-4
8000b37e:	b1 4a       	asr	r10,0x10
8000b380:	0a 37       	cp.w	r7,r5
8000b382:	cf 33       	brcs	8000b368 <__mdiff+0x98>
8000b384:	c0 28       	rjmp	8000b388 <__mdiff+0xb8>
8000b386:	20 19       	sub	r9,1
8000b388:	11 4a       	ld.w	r10,--r8
8000b38a:	58 0a       	cp.w	r10,0
8000b38c:	cf d0       	breq	8000b386 <__mdiff+0xb6>
8000b38e:	99 49       	st.w	r12[0x10],r9
8000b390:	d8 32       	popm	r0-r7,pc
8000b392:	30 0b       	mov	r11,0
8000b394:	c1 6f       	rcall	8000b1c0 <_Balloc>
8000b396:	30 18       	mov	r8,1
8000b398:	99 48       	st.w	r12[0x10],r8
8000b39a:	30 08       	mov	r8,0
8000b39c:	99 58       	st.w	r12[0x14],r8
8000b39e:	d8 32       	popm	r0-r7,pc

8000b3a0 <__lshift>:
8000b3a0:	d4 31       	pushm	r0-r7,lr
8000b3a2:	16 97       	mov	r7,r11
8000b3a4:	76 46       	ld.w	r6,r11[0x10]
8000b3a6:	f4 02 14 05 	asr	r2,r10,0x5
8000b3aa:	2f f6       	sub	r6,-1
8000b3ac:	14 93       	mov	r3,r10
8000b3ae:	18 94       	mov	r4,r12
8000b3b0:	04 06       	add	r6,r2
8000b3b2:	76 1b       	ld.w	r11,r11[0x4]
8000b3b4:	6e 28       	ld.w	r8,r7[0x8]
8000b3b6:	c0 38       	rjmp	8000b3bc <__lshift+0x1c>
8000b3b8:	2f fb       	sub	r11,-1
8000b3ba:	a1 78       	lsl	r8,0x1
8000b3bc:	10 36       	cp.w	r6,r8
8000b3be:	fe 99 ff fd 	brgt	8000b3b8 <__lshift+0x18>
8000b3c2:	08 9c       	mov	r12,r4
8000b3c4:	cf ee       	rcall	8000b1c0 <_Balloc>
8000b3c6:	30 09       	mov	r9,0
8000b3c8:	18 95       	mov	r5,r12
8000b3ca:	f8 c8 ff ec 	sub	r8,r12,-20
8000b3ce:	12 9a       	mov	r10,r9
8000b3d0:	c0 38       	rjmp	8000b3d6 <__lshift+0x36>
8000b3d2:	10 aa       	st.w	r8++,r10
8000b3d4:	2f f9       	sub	r9,-1
8000b3d6:	04 39       	cp.w	r9,r2
8000b3d8:	cf d5       	brlt	8000b3d2 <__lshift+0x32>
8000b3da:	6e 4b       	ld.w	r11,r7[0x10]
8000b3dc:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b3e0:	2f bb       	sub	r11,-5
8000b3e2:	ee c9 ff ec 	sub	r9,r7,-20
8000b3e6:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b3ea:	58 03       	cp.w	r3,0
8000b3ec:	c1 30       	breq	8000b412 <__lshift+0x72>
8000b3ee:	e6 0c 11 20 	rsub	r12,r3,32
8000b3f2:	30 0a       	mov	r10,0
8000b3f4:	72 02       	ld.w	r2,r9[0x0]
8000b3f6:	e4 03 09 42 	lsl	r2,r2,r3
8000b3fa:	04 4a       	or	r10,r2
8000b3fc:	10 aa       	st.w	r8++,r10
8000b3fe:	13 0a       	ld.w	r10,r9++
8000b400:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b404:	16 39       	cp.w	r9,r11
8000b406:	cf 73       	brcs	8000b3f4 <__lshift+0x54>
8000b408:	91 0a       	st.w	r8[0x0],r10
8000b40a:	58 0a       	cp.w	r10,0
8000b40c:	c0 70       	breq	8000b41a <__lshift+0x7a>
8000b40e:	2f f6       	sub	r6,-1
8000b410:	c0 58       	rjmp	8000b41a <__lshift+0x7a>
8000b412:	13 0a       	ld.w	r10,r9++
8000b414:	10 aa       	st.w	r8++,r10
8000b416:	16 39       	cp.w	r9,r11
8000b418:	cf d3       	brcs	8000b412 <__lshift+0x72>
8000b41a:	08 9c       	mov	r12,r4
8000b41c:	20 16       	sub	r6,1
8000b41e:	0e 9b       	mov	r11,r7
8000b420:	8b 46       	st.w	r5[0x10],r6
8000b422:	cb 5e       	rcall	8000b18c <_Bfree>
8000b424:	0a 9c       	mov	r12,r5
8000b426:	d8 32       	popm	r0-r7,pc

8000b428 <__multiply>:
8000b428:	d4 31       	pushm	r0-r7,lr
8000b42a:	20 2d       	sub	sp,8
8000b42c:	76 49       	ld.w	r9,r11[0x10]
8000b42e:	74 48       	ld.w	r8,r10[0x10]
8000b430:	16 96       	mov	r6,r11
8000b432:	14 95       	mov	r5,r10
8000b434:	10 39       	cp.w	r9,r8
8000b436:	ec 08 17 50 	movlt	r8,r6
8000b43a:	ea 06 17 50 	movlt	r6,r5
8000b43e:	f0 05 17 50 	movlt	r5,r8
8000b442:	6c 28       	ld.w	r8,r6[0x8]
8000b444:	76 43       	ld.w	r3,r11[0x10]
8000b446:	74 42       	ld.w	r2,r10[0x10]
8000b448:	76 1b       	ld.w	r11,r11[0x4]
8000b44a:	e4 03 00 07 	add	r7,r2,r3
8000b44e:	10 37       	cp.w	r7,r8
8000b450:	f7 bb 09 ff 	subgt	r11,-1
8000b454:	cb 6e       	rcall	8000b1c0 <_Balloc>
8000b456:	ee c4 ff fb 	sub	r4,r7,-5
8000b45a:	f8 c9 ff ec 	sub	r9,r12,-20
8000b45e:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b462:	30 0a       	mov	r10,0
8000b464:	12 98       	mov	r8,r9
8000b466:	c0 28       	rjmp	8000b46a <__multiply+0x42>
8000b468:	10 aa       	st.w	r8++,r10
8000b46a:	08 38       	cp.w	r8,r4
8000b46c:	cf e3       	brcs	8000b468 <__multiply+0x40>
8000b46e:	2f b3       	sub	r3,-5
8000b470:	2f b2       	sub	r2,-5
8000b472:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b476:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b47a:	ec cb ff ec 	sub	r11,r6,-20
8000b47e:	50 12       	stdsp	sp[0x4],r2
8000b480:	ea ca ff ec 	sub	r10,r5,-20
8000b484:	c4 48       	rjmp	8000b50c <__multiply+0xe4>
8000b486:	94 95       	ld.uh	r5,r10[0x2]
8000b488:	58 05       	cp.w	r5,0
8000b48a:	c2 00       	breq	8000b4ca <__multiply+0xa2>
8000b48c:	12 98       	mov	r8,r9
8000b48e:	16 96       	mov	r6,r11
8000b490:	30 0e       	mov	lr,0
8000b492:	50 09       	stdsp	sp[0x0],r9
8000b494:	0d 02       	ld.w	r2,r6++
8000b496:	e4 00 16 10 	lsr	r0,r2,0x10
8000b49a:	70 01       	ld.w	r1,r8[0x0]
8000b49c:	70 09       	ld.w	r9,r8[0x0]
8000b49e:	b1 81       	lsr	r1,0x10
8000b4a0:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b4a4:	e0 05 03 41 	mac	r1,r0,r5
8000b4a8:	ab 32       	mul	r2,r5
8000b4aa:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b4ae:	00 02       	add	r2,r0
8000b4b0:	e4 0e 00 0e 	add	lr,r2,lr
8000b4b4:	b0 1e       	st.h	r8[0x2],lr
8000b4b6:	b1 8e       	lsr	lr,0x10
8000b4b8:	1c 01       	add	r1,lr
8000b4ba:	b0 01       	st.h	r8[0x0],r1
8000b4bc:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b4c0:	2f c8       	sub	r8,-4
8000b4c2:	06 36       	cp.w	r6,r3
8000b4c4:	ce 83       	brcs	8000b494 <__multiply+0x6c>
8000b4c6:	40 09       	lddsp	r9,sp[0x0]
8000b4c8:	91 0e       	st.w	r8[0x0],lr
8000b4ca:	94 86       	ld.uh	r6,r10[0x0]
8000b4cc:	58 06       	cp.w	r6,0
8000b4ce:	c1 d0       	breq	8000b508 <__multiply+0xe0>
8000b4d0:	72 02       	ld.w	r2,r9[0x0]
8000b4d2:	12 98       	mov	r8,r9
8000b4d4:	16 9e       	mov	lr,r11
8000b4d6:	30 05       	mov	r5,0
8000b4d8:	b0 12       	st.h	r8[0x2],r2
8000b4da:	1d 01       	ld.w	r1,lr++
8000b4dc:	90 82       	ld.uh	r2,r8[0x0]
8000b4de:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b4e2:	ad 30       	mul	r0,r6
8000b4e4:	e0 02 00 02 	add	r2,r0,r2
8000b4e8:	e4 05 00 05 	add	r5,r2,r5
8000b4ec:	b0 05       	st.h	r8[0x0],r5
8000b4ee:	b1 85       	lsr	r5,0x10
8000b4f0:	b1 81       	lsr	r1,0x10
8000b4f2:	2f c8       	sub	r8,-4
8000b4f4:	ad 31       	mul	r1,r6
8000b4f6:	90 92       	ld.uh	r2,r8[0x2]
8000b4f8:	e2 02 00 02 	add	r2,r1,r2
8000b4fc:	0a 02       	add	r2,r5
8000b4fe:	e4 05 16 10 	lsr	r5,r2,0x10
8000b502:	06 3e       	cp.w	lr,r3
8000b504:	ce a3       	brcs	8000b4d8 <__multiply+0xb0>
8000b506:	91 02       	st.w	r8[0x0],r2
8000b508:	2f ca       	sub	r10,-4
8000b50a:	2f c9       	sub	r9,-4
8000b50c:	40 18       	lddsp	r8,sp[0x4]
8000b50e:	10 3a       	cp.w	r10,r8
8000b510:	cb b3       	brcs	8000b486 <__multiply+0x5e>
8000b512:	c0 28       	rjmp	8000b516 <__multiply+0xee>
8000b514:	20 17       	sub	r7,1
8000b516:	58 07       	cp.w	r7,0
8000b518:	e0 8a 00 05 	brle	8000b522 <__multiply+0xfa>
8000b51c:	09 48       	ld.w	r8,--r4
8000b51e:	58 08       	cp.w	r8,0
8000b520:	cf a0       	breq	8000b514 <__multiply+0xec>
8000b522:	99 47       	st.w	r12[0x10],r7
8000b524:	2f ed       	sub	sp,-8
8000b526:	d8 32       	popm	r0-r7,pc

8000b528 <__i2b>:
8000b528:	d4 21       	pushm	r4-r7,lr
8000b52a:	16 97       	mov	r7,r11
8000b52c:	30 1b       	mov	r11,1
8000b52e:	c4 9e       	rcall	8000b1c0 <_Balloc>
8000b530:	30 19       	mov	r9,1
8000b532:	99 57       	st.w	r12[0x14],r7
8000b534:	99 49       	st.w	r12[0x10],r9
8000b536:	d8 22       	popm	r4-r7,pc

8000b538 <__multadd>:
8000b538:	d4 31       	pushm	r0-r7,lr
8000b53a:	30 08       	mov	r8,0
8000b53c:	12 95       	mov	r5,r9
8000b53e:	16 97       	mov	r7,r11
8000b540:	18 96       	mov	r6,r12
8000b542:	76 44       	ld.w	r4,r11[0x10]
8000b544:	f6 c9 ff ec 	sub	r9,r11,-20
8000b548:	72 0b       	ld.w	r11,r9[0x0]
8000b54a:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b54e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b552:	f4 0c 02 4c 	mul	r12,r10,r12
8000b556:	f4 0b 03 45 	mac	r5,r10,r11
8000b55a:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b55e:	b1 85       	lsr	r5,0x10
8000b560:	18 05       	add	r5,r12
8000b562:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b566:	f8 0b 00 0b 	add	r11,r12,r11
8000b56a:	12 ab       	st.w	r9++,r11
8000b56c:	2f f8       	sub	r8,-1
8000b56e:	b1 85       	lsr	r5,0x10
8000b570:	08 38       	cp.w	r8,r4
8000b572:	ce b5       	brlt	8000b548 <__multadd+0x10>
8000b574:	58 05       	cp.w	r5,0
8000b576:	c1 c0       	breq	8000b5ae <__multadd+0x76>
8000b578:	6e 28       	ld.w	r8,r7[0x8]
8000b57a:	10 34       	cp.w	r4,r8
8000b57c:	c1 35       	brlt	8000b5a2 <__multadd+0x6a>
8000b57e:	6e 1b       	ld.w	r11,r7[0x4]
8000b580:	0c 9c       	mov	r12,r6
8000b582:	2f fb       	sub	r11,-1
8000b584:	c1 ee       	rcall	8000b1c0 <_Balloc>
8000b586:	6e 4a       	ld.w	r10,r7[0x10]
8000b588:	ee cb ff f4 	sub	r11,r7,-12
8000b58c:	18 93       	mov	r3,r12
8000b58e:	2f ea       	sub	r10,-2
8000b590:	2f 4c       	sub	r12,-12
8000b592:	a3 6a       	lsl	r10,0x2
8000b594:	fe b0 de 70 	rcall	80007274 <memcpy>
8000b598:	0e 9b       	mov	r11,r7
8000b59a:	0c 9c       	mov	r12,r6
8000b59c:	fe b0 fd f8 	rcall	8000b18c <_Bfree>
8000b5a0:	06 97       	mov	r7,r3
8000b5a2:	e8 c8 ff ff 	sub	r8,r4,-1
8000b5a6:	2f b4       	sub	r4,-5
8000b5a8:	8f 48       	st.w	r7[0x10],r8
8000b5aa:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b5ae:	0e 9c       	mov	r12,r7
8000b5b0:	d8 32       	popm	r0-r7,pc
8000b5b2:	d7 03       	nop

8000b5b4 <__pow5mult>:
8000b5b4:	d4 31       	pushm	r0-r7,lr
8000b5b6:	14 96       	mov	r6,r10
8000b5b8:	18 97       	mov	r7,r12
8000b5ba:	16 94       	mov	r4,r11
8000b5bc:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b5c0:	c0 90       	breq	8000b5d2 <__pow5mult+0x1e>
8000b5c2:	20 18       	sub	r8,1
8000b5c4:	fe c9 db 60 	sub	r9,pc,-9376
8000b5c8:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b5cc:	30 09       	mov	r9,0
8000b5ce:	cb 5f       	rcall	8000b538 <__multadd>
8000b5d0:	18 94       	mov	r4,r12
8000b5d2:	a3 46       	asr	r6,0x2
8000b5d4:	c3 40       	breq	8000b63c <__pow5mult+0x88>
8000b5d6:	6e 95       	ld.w	r5,r7[0x24]
8000b5d8:	58 05       	cp.w	r5,0
8000b5da:	c0 91       	brne	8000b5ec <__pow5mult+0x38>
8000b5dc:	31 0c       	mov	r12,16
8000b5de:	fe b0 dc 27 	rcall	80006e2c <malloc>
8000b5e2:	99 35       	st.w	r12[0xc],r5
8000b5e4:	8f 9c       	st.w	r7[0x24],r12
8000b5e6:	99 15       	st.w	r12[0x4],r5
8000b5e8:	99 25       	st.w	r12[0x8],r5
8000b5ea:	99 05       	st.w	r12[0x0],r5
8000b5ec:	6e 93       	ld.w	r3,r7[0x24]
8000b5ee:	66 25       	ld.w	r5,r3[0x8]
8000b5f0:	58 05       	cp.w	r5,0
8000b5f2:	c0 c1       	brne	8000b60a <__pow5mult+0x56>
8000b5f4:	e0 6b 02 71 	mov	r11,625
8000b5f8:	0e 9c       	mov	r12,r7
8000b5fa:	c9 7f       	rcall	8000b528 <__i2b>
8000b5fc:	87 2c       	st.w	r3[0x8],r12
8000b5fe:	30 08       	mov	r8,0
8000b600:	18 95       	mov	r5,r12
8000b602:	99 08       	st.w	r12[0x0],r8
8000b604:	c0 38       	rjmp	8000b60a <__pow5mult+0x56>
8000b606:	06 9c       	mov	r12,r3
8000b608:	18 95       	mov	r5,r12
8000b60a:	ed b6 00 00 	bld	r6,0x0
8000b60e:	c0 b1       	brne	8000b624 <__pow5mult+0x70>
8000b610:	08 9b       	mov	r11,r4
8000b612:	0a 9a       	mov	r10,r5
8000b614:	0e 9c       	mov	r12,r7
8000b616:	c0 9f       	rcall	8000b428 <__multiply>
8000b618:	08 9b       	mov	r11,r4
8000b61a:	18 93       	mov	r3,r12
8000b61c:	0e 9c       	mov	r12,r7
8000b61e:	06 94       	mov	r4,r3
8000b620:	fe b0 fd b6 	rcall	8000b18c <_Bfree>
8000b624:	a1 56       	asr	r6,0x1
8000b626:	c0 b0       	breq	8000b63c <__pow5mult+0x88>
8000b628:	6a 03       	ld.w	r3,r5[0x0]
8000b62a:	58 03       	cp.w	r3,0
8000b62c:	ce d1       	brne	8000b606 <__pow5mult+0x52>
8000b62e:	0a 9a       	mov	r10,r5
8000b630:	0a 9b       	mov	r11,r5
8000b632:	0e 9c       	mov	r12,r7
8000b634:	cf ae       	rcall	8000b428 <__multiply>
8000b636:	8b 0c       	st.w	r5[0x0],r12
8000b638:	99 03       	st.w	r12[0x0],r3
8000b63a:	ce 7b       	rjmp	8000b608 <__pow5mult+0x54>
8000b63c:	08 9c       	mov	r12,r4
8000b63e:	d8 32       	popm	r0-r7,pc

8000b640 <__isinfd>:
8000b640:	14 98       	mov	r8,r10
8000b642:	fc 19 7f f0 	movh	r9,0x7ff0
8000b646:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b64a:	f0 0b 11 00 	rsub	r11,r8,0
8000b64e:	f7 e8 10 08 	or	r8,r11,r8
8000b652:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000b656:	f2 08 01 08 	sub	r8,r9,r8
8000b65a:	f0 0c 11 00 	rsub	r12,r8,0
8000b65e:	f9 e8 10 08 	or	r8,r12,r8
8000b662:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000b666:	2f fc       	sub	r12,-1
8000b668:	5e fc       	retal	r12

8000b66a <__isnand>:
8000b66a:	14 98       	mov	r8,r10
8000b66c:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b670:	f0 0c 11 00 	rsub	r12,r8,0
8000b674:	10 4c       	or	r12,r8
8000b676:	fc 18 7f f0 	movh	r8,0x7ff0
8000b67a:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000b67e:	f0 0c 01 0c 	sub	r12,r8,r12
8000b682:	bf 9c       	lsr	r12,0x1f
8000b684:	5e fc       	retal	r12
8000b686:	d7 03       	nop

8000b688 <__sclose>:
8000b688:	d4 01       	pushm	lr
8000b68a:	96 7b       	ld.sh	r11,r11[0xe]
8000b68c:	c8 2c       	rcall	8000b790 <_close_r>
8000b68e:	d8 02       	popm	pc

8000b690 <__sseek>:
8000b690:	d4 21       	pushm	r4-r7,lr
8000b692:	16 97       	mov	r7,r11
8000b694:	96 7b       	ld.sh	r11,r11[0xe]
8000b696:	c0 3d       	rcall	8000b89c <_lseek_r>
8000b698:	8e 68       	ld.sh	r8,r7[0xc]
8000b69a:	10 99       	mov	r9,r8
8000b69c:	ad c8       	cbr	r8,0xc
8000b69e:	ad a9       	sbr	r9,0xc
8000b6a0:	5b fc       	cp.w	r12,-1
8000b6a2:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000b6a6:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000b6aa:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000b6ae:	d8 22       	popm	r4-r7,pc

8000b6b0 <__swrite>:
8000b6b0:	d4 21       	pushm	r4-r7,lr
8000b6b2:	96 68       	ld.sh	r8,r11[0xc]
8000b6b4:	16 97       	mov	r7,r11
8000b6b6:	14 95       	mov	r5,r10
8000b6b8:	12 94       	mov	r4,r9
8000b6ba:	e2 18 01 00 	andl	r8,0x100,COH
8000b6be:	18 96       	mov	r6,r12
8000b6c0:	c0 50       	breq	8000b6ca <__swrite+0x1a>
8000b6c2:	30 29       	mov	r9,2
8000b6c4:	30 0a       	mov	r10,0
8000b6c6:	96 7b       	ld.sh	r11,r11[0xe]
8000b6c8:	ce ac       	rcall	8000b89c <_lseek_r>
8000b6ca:	8e 68       	ld.sh	r8,r7[0xc]
8000b6cc:	ad c8       	cbr	r8,0xc
8000b6ce:	08 99       	mov	r9,r4
8000b6d0:	0a 9a       	mov	r10,r5
8000b6d2:	8e 7b       	ld.sh	r11,r7[0xe]
8000b6d4:	0c 9c       	mov	r12,r6
8000b6d6:	ae 68       	st.h	r7[0xc],r8
8000b6d8:	c1 cc       	rcall	8000b710 <_write_r>
8000b6da:	d8 22       	popm	r4-r7,pc

8000b6dc <__sread>:
8000b6dc:	d4 21       	pushm	r4-r7,lr
8000b6de:	16 97       	mov	r7,r11
8000b6e0:	96 7b       	ld.sh	r11,r11[0xe]
8000b6e2:	cf 1c       	rcall	8000b8c4 <_read_r>
8000b6e4:	c0 65       	brlt	8000b6f0 <__sread+0x14>
8000b6e6:	6f 58       	ld.w	r8,r7[0x54]
8000b6e8:	18 08       	add	r8,r12
8000b6ea:	ef 48 00 54 	st.w	r7[84],r8
8000b6ee:	d8 22       	popm	r4-r7,pc
8000b6f0:	8e 68       	ld.sh	r8,r7[0xc]
8000b6f2:	ad c8       	cbr	r8,0xc
8000b6f4:	ae 68       	st.h	r7[0xc],r8
8000b6f6:	d8 22       	popm	r4-r7,pc

8000b6f8 <strlen>:
8000b6f8:	30 09       	mov	r9,0
8000b6fa:	18 98       	mov	r8,r12
8000b6fc:	c0 28       	rjmp	8000b700 <strlen+0x8>
8000b6fe:	2f f8       	sub	r8,-1
8000b700:	11 8a       	ld.ub	r10,r8[0x0]
8000b702:	f2 0a 18 00 	cp.b	r10,r9
8000b706:	cf c1       	brne	8000b6fe <strlen+0x6>
8000b708:	f0 0c 01 0c 	sub	r12,r8,r12
8000b70c:	5e fc       	retal	r12
8000b70e:	d7 03       	nop

8000b710 <_write_r>:
8000b710:	d4 21       	pushm	r4-r7,lr
8000b712:	16 98       	mov	r8,r11
8000b714:	18 97       	mov	r7,r12
8000b716:	10 9c       	mov	r12,r8
8000b718:	30 08       	mov	r8,0
8000b71a:	14 9b       	mov	r11,r10
8000b71c:	e0 66 51 1c 	mov	r6,20764
8000b720:	12 9a       	mov	r10,r9
8000b722:	8d 08       	st.w	r6[0x0],r8
8000b724:	fe b0 d1 b6 	rcall	80005a90 <_write>
8000b728:	5b fc       	cp.w	r12,-1
8000b72a:	c0 51       	brne	8000b734 <_write_r+0x24>
8000b72c:	6c 08       	ld.w	r8,r6[0x0]
8000b72e:	58 08       	cp.w	r8,0
8000b730:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b734:	d8 22       	popm	r4-r7,pc
8000b736:	d7 03       	nop

8000b738 <_calloc_r>:
8000b738:	d4 21       	pushm	r4-r7,lr
8000b73a:	f4 0b 02 4b 	mul	r11,r10,r11
8000b73e:	fe b0 db 7f 	rcall	80006e3c <_malloc_r>
8000b742:	18 97       	mov	r7,r12
8000b744:	c2 30       	breq	8000b78a <_calloc_r+0x52>
8000b746:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000b74a:	e0 1a ff fc 	andl	r10,0xfffc
8000b74e:	20 4a       	sub	r10,4
8000b750:	e0 4a 00 24 	cp.w	r10,36
8000b754:	e0 8b 00 18 	brhi	8000b784 <_calloc_r+0x4c>
8000b758:	18 98       	mov	r8,r12
8000b75a:	59 3a       	cp.w	r10,19
8000b75c:	e0 88 00 0f 	brls	8000b77a <_calloc_r+0x42>
8000b760:	30 09       	mov	r9,0
8000b762:	10 a9       	st.w	r8++,r9
8000b764:	10 a9       	st.w	r8++,r9
8000b766:	59 ba       	cp.w	r10,27
8000b768:	e0 88 00 09 	brls	8000b77a <_calloc_r+0x42>
8000b76c:	10 a9       	st.w	r8++,r9
8000b76e:	10 a9       	st.w	r8++,r9
8000b770:	e0 4a 00 24 	cp.w	r10,36
8000b774:	c0 31       	brne	8000b77a <_calloc_r+0x42>
8000b776:	10 a9       	st.w	r8++,r9
8000b778:	10 a9       	st.w	r8++,r9
8000b77a:	30 09       	mov	r9,0
8000b77c:	10 a9       	st.w	r8++,r9
8000b77e:	91 19       	st.w	r8[0x4],r9
8000b780:	91 09       	st.w	r8[0x0],r9
8000b782:	c0 48       	rjmp	8000b78a <_calloc_r+0x52>
8000b784:	30 0b       	mov	r11,0
8000b786:	fe b0 de 1b 	rcall	800073bc <memset>
8000b78a:	0e 9c       	mov	r12,r7
8000b78c:	d8 22       	popm	r4-r7,pc
8000b78e:	d7 03       	nop

8000b790 <_close_r>:
8000b790:	d4 21       	pushm	r4-r7,lr
8000b792:	30 08       	mov	r8,0
8000b794:	18 97       	mov	r7,r12
8000b796:	e0 66 51 1c 	mov	r6,20764
8000b79a:	16 9c       	mov	r12,r11
8000b79c:	8d 08       	st.w	r6[0x0],r8
8000b79e:	fe b0 df b5 	rcall	80007708 <_close>
8000b7a2:	5b fc       	cp.w	r12,-1
8000b7a4:	c0 51       	brne	8000b7ae <_close_r+0x1e>
8000b7a6:	6c 08       	ld.w	r8,r6[0x0]
8000b7a8:	58 08       	cp.w	r8,0
8000b7aa:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b7ae:	d8 22       	popm	r4-r7,pc

8000b7b0 <_fclose_r>:
8000b7b0:	d4 21       	pushm	r4-r7,lr
8000b7b2:	18 96       	mov	r6,r12
8000b7b4:	16 97       	mov	r7,r11
8000b7b6:	58 0b       	cp.w	r11,0
8000b7b8:	c0 31       	brne	8000b7be <_fclose_r+0xe>
8000b7ba:	16 95       	mov	r5,r11
8000b7bc:	c5 38       	rjmp	8000b862 <_fclose_r+0xb2>
8000b7be:	fe b0 f8 a9 	rcall	8000a910 <__sfp_lock_acquire>
8000b7c2:	58 06       	cp.w	r6,0
8000b7c4:	c0 70       	breq	8000b7d2 <_fclose_r+0x22>
8000b7c6:	6c 68       	ld.w	r8,r6[0x18]
8000b7c8:	58 08       	cp.w	r8,0
8000b7ca:	c0 41       	brne	8000b7d2 <_fclose_r+0x22>
8000b7cc:	0c 9c       	mov	r12,r6
8000b7ce:	fe b0 f8 f3 	rcall	8000a9b4 <__sinit>
8000b7d2:	fe c8 de 12 	sub	r8,pc,-8686
8000b7d6:	10 37       	cp.w	r7,r8
8000b7d8:	c0 31       	brne	8000b7de <_fclose_r+0x2e>
8000b7da:	6c 07       	ld.w	r7,r6[0x0]
8000b7dc:	c0 c8       	rjmp	8000b7f4 <_fclose_r+0x44>
8000b7de:	fe c8 dd fe 	sub	r8,pc,-8706
8000b7e2:	10 37       	cp.w	r7,r8
8000b7e4:	c0 31       	brne	8000b7ea <_fclose_r+0x3a>
8000b7e6:	6c 17       	ld.w	r7,r6[0x4]
8000b7e8:	c0 68       	rjmp	8000b7f4 <_fclose_r+0x44>
8000b7ea:	fe c8 dd ea 	sub	r8,pc,-8726
8000b7ee:	10 37       	cp.w	r7,r8
8000b7f0:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b7f4:	8e 69       	ld.sh	r9,r7[0xc]
8000b7f6:	30 08       	mov	r8,0
8000b7f8:	f0 09 19 00 	cp.h	r9,r8
8000b7fc:	c0 51       	brne	8000b806 <_fclose_r+0x56>
8000b7fe:	fe b0 f8 8a 	rcall	8000a912 <__sfp_lock_release>
8000b802:	30 05       	mov	r5,0
8000b804:	c2 f8       	rjmp	8000b862 <_fclose_r+0xb2>
8000b806:	0e 9b       	mov	r11,r7
8000b808:	0c 9c       	mov	r12,r6
8000b80a:	fe b0 f7 fd 	rcall	8000a804 <_fflush_r>
8000b80e:	6e c8       	ld.w	r8,r7[0x30]
8000b810:	18 95       	mov	r5,r12
8000b812:	58 08       	cp.w	r8,0
8000b814:	c0 60       	breq	8000b820 <_fclose_r+0x70>
8000b816:	6e 8b       	ld.w	r11,r7[0x20]
8000b818:	0c 9c       	mov	r12,r6
8000b81a:	5d 18       	icall	r8
8000b81c:	f9 b5 05 ff 	movlt	r5,-1
8000b820:	8e 68       	ld.sh	r8,r7[0xc]
8000b822:	ed b8 00 07 	bld	r8,0x7
8000b826:	c0 51       	brne	8000b830 <_fclose_r+0x80>
8000b828:	6e 4b       	ld.w	r11,r7[0x10]
8000b82a:	0c 9c       	mov	r12,r6
8000b82c:	fe b0 f9 5e 	rcall	8000aae8 <_free_r>
8000b830:	6e db       	ld.w	r11,r7[0x34]
8000b832:	58 0b       	cp.w	r11,0
8000b834:	c0 a0       	breq	8000b848 <_fclose_r+0x98>
8000b836:	ee c8 ff bc 	sub	r8,r7,-68
8000b83a:	10 3b       	cp.w	r11,r8
8000b83c:	c0 40       	breq	8000b844 <_fclose_r+0x94>
8000b83e:	0c 9c       	mov	r12,r6
8000b840:	fe b0 f9 54 	rcall	8000aae8 <_free_r>
8000b844:	30 08       	mov	r8,0
8000b846:	8f d8       	st.w	r7[0x34],r8
8000b848:	6f 2b       	ld.w	r11,r7[0x48]
8000b84a:	58 0b       	cp.w	r11,0
8000b84c:	c0 70       	breq	8000b85a <_fclose_r+0xaa>
8000b84e:	0c 9c       	mov	r12,r6
8000b850:	fe b0 f9 4c 	rcall	8000aae8 <_free_r>
8000b854:	30 08       	mov	r8,0
8000b856:	ef 48 00 48 	st.w	r7[72],r8
8000b85a:	30 08       	mov	r8,0
8000b85c:	ae 68       	st.h	r7[0xc],r8
8000b85e:	fe b0 f8 5a 	rcall	8000a912 <__sfp_lock_release>
8000b862:	0a 9c       	mov	r12,r5
8000b864:	d8 22       	popm	r4-r7,pc
8000b866:	d7 03       	nop

8000b868 <fclose>:
8000b868:	d4 01       	pushm	lr
8000b86a:	e0 68 0a 40 	mov	r8,2624
8000b86e:	18 9b       	mov	r11,r12
8000b870:	70 0c       	ld.w	r12,r8[0x0]
8000b872:	c9 ff       	rcall	8000b7b0 <_fclose_r>
8000b874:	d8 02       	popm	pc
8000b876:	d7 03       	nop

8000b878 <_fstat_r>:
8000b878:	d4 21       	pushm	r4-r7,lr
8000b87a:	16 98       	mov	r8,r11
8000b87c:	18 97       	mov	r7,r12
8000b87e:	10 9c       	mov	r12,r8
8000b880:	30 08       	mov	r8,0
8000b882:	e0 66 51 1c 	mov	r6,20764
8000b886:	14 9b       	mov	r11,r10
8000b888:	8d 08       	st.w	r6[0x0],r8
8000b88a:	fe b0 df 67 	rcall	80007758 <_fstat>
8000b88e:	5b fc       	cp.w	r12,-1
8000b890:	c0 51       	brne	8000b89a <_fstat_r+0x22>
8000b892:	6c 08       	ld.w	r8,r6[0x0]
8000b894:	58 08       	cp.w	r8,0
8000b896:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b89a:	d8 22       	popm	r4-r7,pc

8000b89c <_lseek_r>:
8000b89c:	d4 21       	pushm	r4-r7,lr
8000b89e:	16 98       	mov	r8,r11
8000b8a0:	18 97       	mov	r7,r12
8000b8a2:	10 9c       	mov	r12,r8
8000b8a4:	30 08       	mov	r8,0
8000b8a6:	14 9b       	mov	r11,r10
8000b8a8:	e0 66 51 1c 	mov	r6,20764
8000b8ac:	12 9a       	mov	r10,r9
8000b8ae:	8d 08       	st.w	r6[0x0],r8
8000b8b0:	fe b0 df 36 	rcall	8000771c <_lseek>
8000b8b4:	5b fc       	cp.w	r12,-1
8000b8b6:	c0 51       	brne	8000b8c0 <_lseek_r+0x24>
8000b8b8:	6c 08       	ld.w	r8,r6[0x0]
8000b8ba:	58 08       	cp.w	r8,0
8000b8bc:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b8c0:	d8 22       	popm	r4-r7,pc
8000b8c2:	d7 03       	nop

8000b8c4 <_read_r>:
8000b8c4:	d4 21       	pushm	r4-r7,lr
8000b8c6:	16 98       	mov	r8,r11
8000b8c8:	18 97       	mov	r7,r12
8000b8ca:	10 9c       	mov	r12,r8
8000b8cc:	30 08       	mov	r8,0
8000b8ce:	14 9b       	mov	r11,r10
8000b8d0:	e0 66 51 1c 	mov	r6,20764
8000b8d4:	12 9a       	mov	r10,r9
8000b8d6:	8d 08       	st.w	r6[0x0],r8
8000b8d8:	fe b0 d0 bc 	rcall	80005a50 <_read>
8000b8dc:	5b fc       	cp.w	r12,-1
8000b8de:	c0 51       	brne	8000b8e8 <_read_r+0x24>
8000b8e0:	6c 08       	ld.w	r8,r6[0x0]
8000b8e2:	58 08       	cp.w	r8,0
8000b8e4:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b8e8:	d8 22       	popm	r4-r7,pc
8000b8ea:	d7 03       	nop

8000b8ec <__avr32_f64_mul>:
8000b8ec:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b8f0:	e0 80 00 dc 	breq	8000baa8 <__avr32_f64_mul_op1_zero>
8000b8f4:	d4 21       	pushm	r4-r7,lr
8000b8f6:	f7 e9 20 0e 	eor	lr,r11,r9
8000b8fa:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b8fe:	30 15       	mov	r5,1
8000b900:	c4 30       	breq	8000b986 <__avr32_f64_mul_op1_subnormal>
8000b902:	ab 6b       	lsl	r11,0xa
8000b904:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000b908:	ab 6a       	lsl	r10,0xa
8000b90a:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000b90e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b912:	c5 c0       	breq	8000b9ca <__avr32_f64_mul_op2_subnormal>
8000b914:	a1 78       	lsl	r8,0x1
8000b916:	5c f9       	rol	r9
8000b918:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b91c:	e0 47 07 ff 	cp.w	r7,2047
8000b920:	c7 70       	breq	8000ba0e <__avr32_f64_mul_op_nan_or_inf>
8000b922:	e0 46 07 ff 	cp.w	r6,2047
8000b926:	c7 40       	breq	8000ba0e <__avr32_f64_mul_op_nan_or_inf>
8000b928:	ee 06 00 0c 	add	r12,r7,r6
8000b92c:	e0 2c 03 fe 	sub	r12,1022
8000b930:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b934:	f4 09 07 44 	macu.d	r4,r10,r9
8000b938:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b93c:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b940:	08 07       	add	r7,r4
8000b942:	f4 05 00 4a 	adc	r10,r10,r5
8000b946:	5c 0b       	acr	r11
8000b948:	ed bb 00 14 	bld	r11,0x14
8000b94c:	c0 50       	breq	8000b956 <__avr32_f64_mul+0x6a>
8000b94e:	a1 77       	lsl	r7,0x1
8000b950:	5c fa       	rol	r10
8000b952:	5c fb       	rol	r11
8000b954:	20 1c       	sub	r12,1
8000b956:	58 0c       	cp.w	r12,0
8000b958:	e0 8a 00 6f 	brle	8000ba36 <__avr32_f64_mul_res_subnormal>
8000b95c:	e0 4c 07 ff 	cp.w	r12,2047
8000b960:	e0 84 00 9c 	brge	8000ba98 <__avr32_f64_mul_res_inf>
8000b964:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b968:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b96c:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b970:	ee 17 80 00 	eorh	r7,0x8000
8000b974:	f1 b7 04 20 	satu	r7,0x1
8000b978:	0e 0a       	add	r10,r7
8000b97a:	5c 0b       	acr	r11
8000b97c:	ed be 00 1f 	bld	lr,0x1f
8000b980:	ef bb 00 1f 	bst	r11,0x1f
8000b984:	d8 22       	popm	r4-r7,pc

8000b986 <__avr32_f64_mul_op1_subnormal>:
8000b986:	e4 1b 00 0f 	andh	r11,0xf
8000b98a:	f4 0c 12 00 	clz	r12,r10
8000b98e:	f6 06 12 00 	clz	r6,r11
8000b992:	f7 bc 03 e1 	sublo	r12,-31
8000b996:	f8 06 17 30 	movlo	r6,r12
8000b99a:	f7 b6 02 01 	subhs	r6,1
8000b99e:	e0 46 00 20 	cp.w	r6,32
8000b9a2:	c0 d4       	brge	8000b9bc <__avr32_f64_mul_op1_subnormal+0x36>
8000b9a4:	ec 0c 11 20 	rsub	r12,r6,32
8000b9a8:	f6 06 09 4b 	lsl	r11,r11,r6
8000b9ac:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b9b0:	18 4b       	or	r11,r12
8000b9b2:	f4 06 09 4a 	lsl	r10,r10,r6
8000b9b6:	20 b6       	sub	r6,11
8000b9b8:	0c 17       	sub	r7,r6
8000b9ba:	ca ab       	rjmp	8000b90e <__avr32_f64_mul+0x22>
8000b9bc:	f4 06 09 4b 	lsl	r11,r10,r6
8000b9c0:	c6 40       	breq	8000ba88 <__avr32_f64_mul_res_zero>
8000b9c2:	30 0a       	mov	r10,0
8000b9c4:	20 b6       	sub	r6,11
8000b9c6:	0c 17       	sub	r7,r6
8000b9c8:	ca 3b       	rjmp	8000b90e <__avr32_f64_mul+0x22>

8000b9ca <__avr32_f64_mul_op2_subnormal>:
8000b9ca:	e4 19 00 0f 	andh	r9,0xf
8000b9ce:	f0 0c 12 00 	clz	r12,r8
8000b9d2:	f2 05 12 00 	clz	r5,r9
8000b9d6:	f7 bc 03 ea 	sublo	r12,-22
8000b9da:	f8 05 17 30 	movlo	r5,r12
8000b9de:	f7 b5 02 0a 	subhs	r5,10
8000b9e2:	e0 45 00 20 	cp.w	r5,32
8000b9e6:	c0 d4       	brge	8000ba00 <__avr32_f64_mul_op2_subnormal+0x36>
8000b9e8:	ea 0c 11 20 	rsub	r12,r5,32
8000b9ec:	f2 05 09 49 	lsl	r9,r9,r5
8000b9f0:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000b9f4:	18 49       	or	r9,r12
8000b9f6:	f0 05 09 48 	lsl	r8,r8,r5
8000b9fa:	20 25       	sub	r5,2
8000b9fc:	0a 16       	sub	r6,r5
8000b9fe:	c8 fb       	rjmp	8000b91c <__avr32_f64_mul+0x30>
8000ba00:	f0 05 09 49 	lsl	r9,r8,r5
8000ba04:	c4 20       	breq	8000ba88 <__avr32_f64_mul_res_zero>
8000ba06:	30 08       	mov	r8,0
8000ba08:	20 25       	sub	r5,2
8000ba0a:	0a 16       	sub	r6,r5
8000ba0c:	c8 8b       	rjmp	8000b91c <__avr32_f64_mul+0x30>

8000ba0e <__avr32_f64_mul_op_nan_or_inf>:
8000ba0e:	e4 19 00 0f 	andh	r9,0xf
8000ba12:	e4 1b 00 0f 	andh	r11,0xf
8000ba16:	14 4b       	or	r11,r10
8000ba18:	10 49       	or	r9,r8
8000ba1a:	e0 47 07 ff 	cp.w	r7,2047
8000ba1e:	c0 91       	brne	8000ba30 <__avr32_f64_mul_op1_not_naninf>
8000ba20:	58 0b       	cp.w	r11,0
8000ba22:	c3 81       	brne	8000ba92 <__avr32_f64_mul_res_nan>
8000ba24:	e0 46 07 ff 	cp.w	r6,2047
8000ba28:	c3 81       	brne	8000ba98 <__avr32_f64_mul_res_inf>
8000ba2a:	58 09       	cp.w	r9,0
8000ba2c:	c3 60       	breq	8000ba98 <__avr32_f64_mul_res_inf>
8000ba2e:	c3 28       	rjmp	8000ba92 <__avr32_f64_mul_res_nan>

8000ba30 <__avr32_f64_mul_op1_not_naninf>:
8000ba30:	58 09       	cp.w	r9,0
8000ba32:	c3 30       	breq	8000ba98 <__avr32_f64_mul_res_inf>
8000ba34:	c2 f8       	rjmp	8000ba92 <__avr32_f64_mul_res_nan>

8000ba36 <__avr32_f64_mul_res_subnormal>:
8000ba36:	5c 3c       	neg	r12
8000ba38:	2f fc       	sub	r12,-1
8000ba3a:	f1 bc 04 c0 	satu	r12,0x6
8000ba3e:	e0 4c 00 20 	cp.w	r12,32
8000ba42:	c1 14       	brge	8000ba64 <__avr32_f64_mul_res_subnormal+0x2e>
8000ba44:	f8 08 11 20 	rsub	r8,r12,32
8000ba48:	0e 46       	or	r6,r7
8000ba4a:	ee 0c 0a 47 	lsr	r7,r7,r12
8000ba4e:	f4 08 09 49 	lsl	r9,r10,r8
8000ba52:	12 47       	or	r7,r9
8000ba54:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ba58:	f6 08 09 49 	lsl	r9,r11,r8
8000ba5c:	12 4a       	or	r10,r9
8000ba5e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000ba62:	c8 3b       	rjmp	8000b968 <__avr32_f64_mul+0x7c>
8000ba64:	f8 08 11 20 	rsub	r8,r12,32
8000ba68:	f9 b9 00 00 	moveq	r9,0
8000ba6c:	c0 30       	breq	8000ba72 <__avr32_f64_mul_res_subnormal+0x3c>
8000ba6e:	f6 08 09 49 	lsl	r9,r11,r8
8000ba72:	0e 46       	or	r6,r7
8000ba74:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000ba78:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ba7c:	f3 ea 10 07 	or	r7,r9,r10
8000ba80:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000ba84:	30 0b       	mov	r11,0
8000ba86:	c7 1b       	rjmp	8000b968 <__avr32_f64_mul+0x7c>

8000ba88 <__avr32_f64_mul_res_zero>:
8000ba88:	1c 9b       	mov	r11,lr
8000ba8a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000ba8e:	30 0a       	mov	r10,0
8000ba90:	d8 22       	popm	r4-r7,pc

8000ba92 <__avr32_f64_mul_res_nan>:
8000ba92:	3f fb       	mov	r11,-1
8000ba94:	3f fa       	mov	r10,-1
8000ba96:	d8 22       	popm	r4-r7,pc

8000ba98 <__avr32_f64_mul_res_inf>:
8000ba98:	f0 6b 00 00 	mov	r11,-1048576
8000ba9c:	ed be 00 1f 	bld	lr,0x1f
8000baa0:	ef bb 00 1f 	bst	r11,0x1f
8000baa4:	30 0a       	mov	r10,0
8000baa6:	d8 22       	popm	r4-r7,pc

8000baa8 <__avr32_f64_mul_op1_zero>:
8000baa8:	f7 e9 20 0b 	eor	r11,r11,r9
8000baac:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bab0:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000bab4:	e0 4c 07 ff 	cp.w	r12,2047
8000bab8:	5e 1c       	retne	r12
8000baba:	3f fa       	mov	r10,-1
8000babc:	3f fb       	mov	r11,-1
8000babe:	5e fc       	retal	r12

8000bac0 <__avr32_f64_sub_from_add>:
8000bac0:	ee 19 80 00 	eorh	r9,0x8000

8000bac4 <__avr32_f64_sub>:
8000bac4:	f7 e9 20 0c 	eor	r12,r11,r9
8000bac8:	e0 86 00 ca 	brmi	8000bc5c <__avr32_f64_add_from_sub>
8000bacc:	eb cd 40 e0 	pushm	r5-r7,lr
8000bad0:	16 9c       	mov	r12,r11
8000bad2:	e6 1c 80 00 	andh	r12,0x8000,COH
8000bad6:	bf db       	cbr	r11,0x1f
8000bad8:	bf d9       	cbr	r9,0x1f
8000bada:	10 3a       	cp.w	r10,r8
8000badc:	f2 0b 13 00 	cpc	r11,r9
8000bae0:	c0 92       	brcc	8000baf2 <__avr32_f64_sub+0x2e>
8000bae2:	16 97       	mov	r7,r11
8000bae4:	12 9b       	mov	r11,r9
8000bae6:	0e 99       	mov	r9,r7
8000bae8:	14 97       	mov	r7,r10
8000baea:	10 9a       	mov	r10,r8
8000baec:	0e 98       	mov	r8,r7
8000baee:	ee 1c 80 00 	eorh	r12,0x8000
8000baf2:	f6 07 16 14 	lsr	r7,r11,0x14
8000baf6:	ab 7b       	lsl	r11,0xb
8000baf8:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bafc:	ab 7a       	lsl	r10,0xb
8000bafe:	bf bb       	sbr	r11,0x1f
8000bb00:	f2 06 16 14 	lsr	r6,r9,0x14
8000bb04:	c4 40       	breq	8000bb8c <__avr32_f64_sub_opL_subnormal>
8000bb06:	ab 79       	lsl	r9,0xb
8000bb08:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bb0c:	ab 78       	lsl	r8,0xb
8000bb0e:	bf b9       	sbr	r9,0x1f

8000bb10 <__avr32_f64_sub_opL_subnormal_done>:
8000bb10:	e0 47 07 ff 	cp.w	r7,2047
8000bb14:	c4 f0       	breq	8000bbb2 <__avr32_f64_sub_opH_nan_or_inf>
8000bb16:	0e 26       	rsub	r6,r7
8000bb18:	c1 20       	breq	8000bb3c <__avr32_f64_sub_shift_done>
8000bb1a:	ec 05 11 20 	rsub	r5,r6,32
8000bb1e:	e0 46 00 20 	cp.w	r6,32
8000bb22:	c7 c2       	brcc	8000bc1a <__avr32_f64_sub_longshift>
8000bb24:	f0 05 09 4e 	lsl	lr,r8,r5
8000bb28:	f2 05 09 45 	lsl	r5,r9,r5
8000bb2c:	f0 06 0a 48 	lsr	r8,r8,r6
8000bb30:	f2 06 0a 49 	lsr	r9,r9,r6
8000bb34:	0a 48       	or	r8,r5
8000bb36:	58 0e       	cp.w	lr,0
8000bb38:	5f 1e       	srne	lr
8000bb3a:	1c 48       	or	r8,lr

8000bb3c <__avr32_f64_sub_shift_done>:
8000bb3c:	10 1a       	sub	r10,r8
8000bb3e:	f6 09 01 4b 	sbc	r11,r11,r9
8000bb42:	f6 06 12 00 	clz	r6,r11
8000bb46:	c0 e0       	breq	8000bb62 <__avr32_f64_sub_longnormalize_done>
8000bb48:	c7 83       	brcs	8000bc38 <__avr32_f64_sub_longnormalize>
8000bb4a:	ec 0e 11 20 	rsub	lr,r6,32
8000bb4e:	f6 06 09 4b 	lsl	r11,r11,r6
8000bb52:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bb56:	1c 4b       	or	r11,lr
8000bb58:	f4 06 09 4a 	lsl	r10,r10,r6
8000bb5c:	0c 17       	sub	r7,r6
8000bb5e:	e0 8a 00 39 	brle	8000bbd0 <__avr32_f64_sub_subnormal_result>

8000bb62 <__avr32_f64_sub_longnormalize_done>:
8000bb62:	f4 09 15 15 	lsl	r9,r10,0x15
8000bb66:	ab 9a       	lsr	r10,0xb
8000bb68:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bb6c:	ab 9b       	lsr	r11,0xb
8000bb6e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bb72:	18 4b       	or	r11,r12

8000bb74 <__avr32_f64_sub_round>:
8000bb74:	fc 17 80 00 	movh	r7,0x8000
8000bb78:	ed ba 00 00 	bld	r10,0x0
8000bb7c:	f7 b7 01 ff 	subne	r7,-1
8000bb80:	0e 39       	cp.w	r9,r7
8000bb82:	5f 29       	srhs	r9
8000bb84:	12 0a       	add	r10,r9
8000bb86:	5c 0b       	acr	r11
8000bb88:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bb8c <__avr32_f64_sub_opL_subnormal>:
8000bb8c:	ab 79       	lsl	r9,0xb
8000bb8e:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bb92:	ab 78       	lsl	r8,0xb
8000bb94:	f3 e8 10 0e 	or	lr,r9,r8
8000bb98:	f9 b6 01 01 	movne	r6,1
8000bb9c:	ee 0e 11 00 	rsub	lr,r7,0
8000bba0:	f9 b7 00 01 	moveq	r7,1
8000bba4:	ef bb 00 1f 	bst	r11,0x1f
8000bba8:	f7 ea 10 0e 	or	lr,r11,r10
8000bbac:	f9 b7 00 00 	moveq	r7,0
8000bbb0:	cb 0b       	rjmp	8000bb10 <__avr32_f64_sub_opL_subnormal_done>

8000bbb2 <__avr32_f64_sub_opH_nan_or_inf>:
8000bbb2:	bf db       	cbr	r11,0x1f
8000bbb4:	f7 ea 10 0e 	or	lr,r11,r10
8000bbb8:	c0 81       	brne	8000bbc8 <__avr32_f64_sub_return_nan>
8000bbba:	e0 46 07 ff 	cp.w	r6,2047
8000bbbe:	c0 50       	breq	8000bbc8 <__avr32_f64_sub_return_nan>
8000bbc0:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000bbc4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bbc8 <__avr32_f64_sub_return_nan>:
8000bbc8:	3f fa       	mov	r10,-1
8000bbca:	3f fb       	mov	r11,-1
8000bbcc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bbd0 <__avr32_f64_sub_subnormal_result>:
8000bbd0:	5c 37       	neg	r7
8000bbd2:	2f f7       	sub	r7,-1
8000bbd4:	f1 b7 04 c0 	satu	r7,0x6
8000bbd8:	e0 47 00 20 	cp.w	r7,32
8000bbdc:	c1 14       	brge	8000bbfe <__avr32_f64_sub_subnormal_result+0x2e>
8000bbde:	ee 08 11 20 	rsub	r8,r7,32
8000bbe2:	f4 08 09 49 	lsl	r9,r10,r8
8000bbe6:	5f 16       	srne	r6
8000bbe8:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bbec:	0c 4a       	or	r10,r6
8000bbee:	f6 08 09 49 	lsl	r9,r11,r8
8000bbf2:	f5 e9 10 0a 	or	r10,r10,r9
8000bbf6:	f4 07 0a 4b 	lsr	r11,r10,r7
8000bbfa:	30 07       	mov	r7,0
8000bbfc:	cb 3b       	rjmp	8000bb62 <__avr32_f64_sub_longnormalize_done>
8000bbfe:	ee 08 11 40 	rsub	r8,r7,64
8000bc02:	f6 08 09 49 	lsl	r9,r11,r8
8000bc06:	14 49       	or	r9,r10
8000bc08:	5f 16       	srne	r6
8000bc0a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000bc0e:	0c 4a       	or	r10,r6
8000bc10:	30 0b       	mov	r11,0
8000bc12:	30 07       	mov	r7,0
8000bc14:	ca 7b       	rjmp	8000bb62 <__avr32_f64_sub_longnormalize_done>
8000bc16:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bc1a <__avr32_f64_sub_longshift>:
8000bc1a:	f1 b6 04 c0 	satu	r6,0x6
8000bc1e:	f0 0e 17 00 	moveq	lr,r8
8000bc22:	c0 40       	breq	8000bc2a <__avr32_f64_sub_longshift+0x10>
8000bc24:	f2 05 09 4e 	lsl	lr,r9,r5
8000bc28:	10 4e       	or	lr,r8
8000bc2a:	f2 06 0a 48 	lsr	r8,r9,r6
8000bc2e:	30 09       	mov	r9,0
8000bc30:	58 0e       	cp.w	lr,0
8000bc32:	5f 1e       	srne	lr
8000bc34:	1c 48       	or	r8,lr
8000bc36:	c8 3b       	rjmp	8000bb3c <__avr32_f64_sub_shift_done>

8000bc38 <__avr32_f64_sub_longnormalize>:
8000bc38:	f4 06 12 00 	clz	r6,r10
8000bc3c:	f9 b7 03 00 	movlo	r7,0
8000bc40:	f9 b6 03 00 	movlo	r6,0
8000bc44:	f9 bc 03 00 	movlo	r12,0
8000bc48:	f7 b6 02 e0 	subhs	r6,-32
8000bc4c:	f4 06 09 4b 	lsl	r11,r10,r6
8000bc50:	30 0a       	mov	r10,0
8000bc52:	0c 17       	sub	r7,r6
8000bc54:	fe 9a ff be 	brle	8000bbd0 <__avr32_f64_sub_subnormal_result>
8000bc58:	c8 5b       	rjmp	8000bb62 <__avr32_f64_sub_longnormalize_done>
8000bc5a:	d7 03       	nop

8000bc5c <__avr32_f64_add_from_sub>:
8000bc5c:	ee 19 80 00 	eorh	r9,0x8000

8000bc60 <__avr32_f64_add>:
8000bc60:	f7 e9 20 0c 	eor	r12,r11,r9
8000bc64:	fe 96 ff 2e 	brmi	8000bac0 <__avr32_f64_sub_from_add>
8000bc68:	eb cd 40 e0 	pushm	r5-r7,lr
8000bc6c:	16 9c       	mov	r12,r11
8000bc6e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000bc72:	bf db       	cbr	r11,0x1f
8000bc74:	bf d9       	cbr	r9,0x1f
8000bc76:	12 3b       	cp.w	r11,r9
8000bc78:	c0 72       	brcc	8000bc86 <__avr32_f64_add+0x26>
8000bc7a:	16 97       	mov	r7,r11
8000bc7c:	12 9b       	mov	r11,r9
8000bc7e:	0e 99       	mov	r9,r7
8000bc80:	14 97       	mov	r7,r10
8000bc82:	10 9a       	mov	r10,r8
8000bc84:	0e 98       	mov	r8,r7
8000bc86:	30 0e       	mov	lr,0
8000bc88:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bc8c:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000bc90:	b5 ab       	sbr	r11,0x14
8000bc92:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bc96:	c6 20       	breq	8000bd5a <__avr32_f64_add_op2_subnormal>
8000bc98:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000bc9c:	b5 a9       	sbr	r9,0x14
8000bc9e:	e0 47 07 ff 	cp.w	r7,2047
8000bca2:	c2 80       	breq	8000bcf2 <__avr32_f64_add_opH_nan_or_inf>
8000bca4:	0e 26       	rsub	r6,r7
8000bca6:	c1 20       	breq	8000bcca <__avr32_f64_add_shift_done>
8000bca8:	e0 46 00 36 	cp.w	r6,54
8000bcac:	c1 52       	brcc	8000bcd6 <__avr32_f64_add_res_of_done>
8000bcae:	ec 05 11 20 	rsub	r5,r6,32
8000bcb2:	e0 46 00 20 	cp.w	r6,32
8000bcb6:	c3 52       	brcc	8000bd20 <__avr32_f64_add_longshift>
8000bcb8:	f0 05 09 4e 	lsl	lr,r8,r5
8000bcbc:	f2 05 09 45 	lsl	r5,r9,r5
8000bcc0:	f0 06 0a 48 	lsr	r8,r8,r6
8000bcc4:	f2 06 0a 49 	lsr	r9,r9,r6
8000bcc8:	0a 48       	or	r8,r5

8000bcca <__avr32_f64_add_shift_done>:
8000bcca:	10 0a       	add	r10,r8
8000bccc:	f6 09 00 4b 	adc	r11,r11,r9
8000bcd0:	ed bb 00 15 	bld	r11,0x15
8000bcd4:	c3 40       	breq	8000bd3c <__avr32_f64_add_res_of>

8000bcd6 <__avr32_f64_add_res_of_done>:
8000bcd6:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bcda:	18 4b       	or	r11,r12

8000bcdc <__avr32_f64_add_round>:
8000bcdc:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000bce0:	18 4e       	or	lr,r12
8000bce2:	ee 1e 80 00 	eorh	lr,0x8000
8000bce6:	f1 be 04 20 	satu	lr,0x1
8000bcea:	1c 0a       	add	r10,lr
8000bcec:	5c 0b       	acr	r11
8000bcee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bcf2 <__avr32_f64_add_opH_nan_or_inf>:
8000bcf2:	b5 cb       	cbr	r11,0x14
8000bcf4:	f7 ea 10 0e 	or	lr,r11,r10
8000bcf8:	c1 01       	brne	8000bd18 <__avr32_f64_add_return_nan>
8000bcfa:	e0 46 07 ff 	cp.w	r6,2047
8000bcfe:	c0 30       	breq	8000bd04 <__avr32_f64_add_opL_nan_or_inf>
8000bd00:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bd04 <__avr32_f64_add_opL_nan_or_inf>:
8000bd04:	b5 c9       	cbr	r9,0x14
8000bd06:	f3 e8 10 0e 	or	lr,r9,r8
8000bd0a:	c0 71       	brne	8000bd18 <__avr32_f64_add_return_nan>
8000bd0c:	30 0a       	mov	r10,0
8000bd0e:	fc 1b 7f f0 	movh	r11,0x7ff0
8000bd12:	18 4b       	or	r11,r12
8000bd14:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bd18 <__avr32_f64_add_return_nan>:
8000bd18:	3f fa       	mov	r10,-1
8000bd1a:	3f fb       	mov	r11,-1
8000bd1c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bd20 <__avr32_f64_add_longshift>:
8000bd20:	f1 b6 04 c0 	satu	r6,0x6
8000bd24:	f0 0e 17 00 	moveq	lr,r8
8000bd28:	c0 60       	breq	8000bd34 <__avr32_f64_add_longshift+0x14>
8000bd2a:	f2 05 09 4e 	lsl	lr,r9,r5
8000bd2e:	58 08       	cp.w	r8,0
8000bd30:	5f 18       	srne	r8
8000bd32:	10 4e       	or	lr,r8
8000bd34:	f2 06 0a 48 	lsr	r8,r9,r6
8000bd38:	30 09       	mov	r9,0
8000bd3a:	cc 8b       	rjmp	8000bcca <__avr32_f64_add_shift_done>

8000bd3c <__avr32_f64_add_res_of>:
8000bd3c:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000bd40:	a1 9b       	lsr	r11,0x1
8000bd42:	5d 0a       	ror	r10
8000bd44:	5d 0e       	ror	lr
8000bd46:	2f f7       	sub	r7,-1
8000bd48:	e0 47 07 ff 	cp.w	r7,2047
8000bd4c:	f9 ba 00 00 	moveq	r10,0
8000bd50:	f9 bb 00 00 	moveq	r11,0
8000bd54:	f9 be 00 00 	moveq	lr,0
8000bd58:	cb fb       	rjmp	8000bcd6 <__avr32_f64_add_res_of_done>

8000bd5a <__avr32_f64_add_op2_subnormal>:
8000bd5a:	30 16       	mov	r6,1
8000bd5c:	58 07       	cp.w	r7,0
8000bd5e:	ca 01       	brne	8000bc9e <__avr32_f64_add+0x3e>
8000bd60:	b5 cb       	cbr	r11,0x14
8000bd62:	10 0a       	add	r10,r8
8000bd64:	f6 09 00 4b 	adc	r11,r11,r9
8000bd68:	18 4b       	or	r11,r12
8000bd6a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000bd6e:	d7 03       	nop

8000bd70 <__avr32_f64_to_u32>:
8000bd70:	58 0b       	cp.w	r11,0
8000bd72:	5e 6d       	retmi	0

8000bd74 <__avr32_f64_to_s32>:
8000bd74:	f6 0c 15 01 	lsl	r12,r11,0x1
8000bd78:	b5 9c       	lsr	r12,0x15
8000bd7a:	e0 2c 03 ff 	sub	r12,1023
8000bd7e:	5e 3d       	retlo	0
8000bd80:	f8 0c 11 1f 	rsub	r12,r12,31
8000bd84:	16 99       	mov	r9,r11
8000bd86:	ab 7b       	lsl	r11,0xb
8000bd88:	bf bb       	sbr	r11,0x1f
8000bd8a:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bd8e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bd92:	a1 79       	lsl	r9,0x1
8000bd94:	5e 2b       	reths	r11
8000bd96:	5c 3b       	neg	r11
8000bd98:	5e fb       	retal	r11

8000bd9a <__avr32_u32_to_f64>:
8000bd9a:	f8 cb 00 00 	sub	r11,r12,0
8000bd9e:	30 0c       	mov	r12,0
8000bda0:	c0 38       	rjmp	8000bda6 <__avr32_s32_to_f64+0x4>

8000bda2 <__avr32_s32_to_f64>:
8000bda2:	18 9b       	mov	r11,r12
8000bda4:	5c 4b       	abs	r11
8000bda6:	30 0a       	mov	r10,0
8000bda8:	5e 0b       	reteq	r11
8000bdaa:	d4 01       	pushm	lr
8000bdac:	e0 69 04 1e 	mov	r9,1054
8000bdb0:	f6 08 12 00 	clz	r8,r11
8000bdb4:	c1 70       	breq	8000bde2 <__avr32_s32_to_f64+0x40>
8000bdb6:	c0 c3       	brcs	8000bdce <__avr32_s32_to_f64+0x2c>
8000bdb8:	f0 0e 11 20 	rsub	lr,r8,32
8000bdbc:	f6 08 09 4b 	lsl	r11,r11,r8
8000bdc0:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bdc4:	1c 4b       	or	r11,lr
8000bdc6:	f4 08 09 4a 	lsl	r10,r10,r8
8000bdca:	10 19       	sub	r9,r8
8000bdcc:	c0 b8       	rjmp	8000bde2 <__avr32_s32_to_f64+0x40>
8000bdce:	f4 08 12 00 	clz	r8,r10
8000bdd2:	f9 b8 03 00 	movlo	r8,0
8000bdd6:	f7 b8 02 e0 	subhs	r8,-32
8000bdda:	f4 08 09 4b 	lsl	r11,r10,r8
8000bdde:	30 0a       	mov	r10,0
8000bde0:	10 19       	sub	r9,r8
8000bde2:	58 09       	cp.w	r9,0
8000bde4:	e0 89 00 30 	brgt	8000be44 <__avr32_s32_to_f64+0xa2>
8000bde8:	5c 39       	neg	r9
8000bdea:	2f f9       	sub	r9,-1
8000bdec:	e0 49 00 36 	cp.w	r9,54
8000bdf0:	c0 43       	brcs	8000bdf8 <__avr32_s32_to_f64+0x56>
8000bdf2:	30 0b       	mov	r11,0
8000bdf4:	30 0a       	mov	r10,0
8000bdf6:	c2 68       	rjmp	8000be42 <__avr32_s32_to_f64+0xa0>
8000bdf8:	2f 69       	sub	r9,-10
8000bdfa:	f2 08 11 20 	rsub	r8,r9,32
8000bdfe:	e0 49 00 20 	cp.w	r9,32
8000be02:	c0 b2       	brcc	8000be18 <__avr32_s32_to_f64+0x76>
8000be04:	f4 08 09 4e 	lsl	lr,r10,r8
8000be08:	f6 08 09 48 	lsl	r8,r11,r8
8000be0c:	f4 09 0a 4a 	lsr	r10,r10,r9
8000be10:	f6 09 0a 4b 	lsr	r11,r11,r9
8000be14:	10 4b       	or	r11,r8
8000be16:	c0 88       	rjmp	8000be26 <__avr32_s32_to_f64+0x84>
8000be18:	f6 08 09 4e 	lsl	lr,r11,r8
8000be1c:	14 4e       	or	lr,r10
8000be1e:	16 9a       	mov	r10,r11
8000be20:	30 0b       	mov	r11,0
8000be22:	f4 09 0a 4a 	lsr	r10,r10,r9
8000be26:	ed ba 00 00 	bld	r10,0x0
8000be2a:	c0 92       	brcc	8000be3c <__avr32_s32_to_f64+0x9a>
8000be2c:	1c 7e       	tst	lr,lr
8000be2e:	c0 41       	brne	8000be36 <__avr32_s32_to_f64+0x94>
8000be30:	ed ba 00 01 	bld	r10,0x1
8000be34:	c0 42       	brcc	8000be3c <__avr32_s32_to_f64+0x9a>
8000be36:	2f fa       	sub	r10,-1
8000be38:	f7 bb 02 ff 	subhs	r11,-1
8000be3c:	5c fc       	rol	r12
8000be3e:	5d 0b       	ror	r11
8000be40:	5d 0a       	ror	r10
8000be42:	d8 02       	popm	pc
8000be44:	e0 68 03 ff 	mov	r8,1023
8000be48:	ed ba 00 0b 	bld	r10,0xb
8000be4c:	f7 b8 00 ff 	subeq	r8,-1
8000be50:	10 0a       	add	r10,r8
8000be52:	5c 0b       	acr	r11
8000be54:	f7 b9 03 fe 	sublo	r9,-2
8000be58:	e0 49 07 ff 	cp.w	r9,2047
8000be5c:	c0 55       	brlt	8000be66 <__avr32_s32_to_f64+0xc4>
8000be5e:	30 0a       	mov	r10,0
8000be60:	fc 1b ff e0 	movh	r11,0xffe0
8000be64:	c0 c8       	rjmp	8000be7c <__floatsidf_return_op1>
8000be66:	ed bb 00 1f 	bld	r11,0x1f
8000be6a:	f7 b9 01 01 	subne	r9,1
8000be6e:	ab 9a       	lsr	r10,0xb
8000be70:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000be74:	a1 7b       	lsl	r11,0x1
8000be76:	ab 9b       	lsr	r11,0xb
8000be78:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000be7c <__floatsidf_return_op1>:
8000be7c:	a1 7c       	lsl	r12,0x1
8000be7e:	5d 0b       	ror	r11
8000be80:	d8 02       	popm	pc

8000be82 <__avr32_f64_cmp_eq>:
8000be82:	10 3a       	cp.w	r10,r8
8000be84:	f2 0b 13 00 	cpc	r11,r9
8000be88:	c0 80       	breq	8000be98 <__avr32_f64_cmp_eq+0x16>
8000be8a:	a1 7b       	lsl	r11,0x1
8000be8c:	a1 79       	lsl	r9,0x1
8000be8e:	14 4b       	or	r11,r10
8000be90:	12 4b       	or	r11,r9
8000be92:	10 4b       	or	r11,r8
8000be94:	5e 0f       	reteq	1
8000be96:	5e fd       	retal	0
8000be98:	a1 7b       	lsl	r11,0x1
8000be9a:	fc 1c ff e0 	movh	r12,0xffe0
8000be9e:	58 0a       	cp.w	r10,0
8000bea0:	f8 0b 13 00 	cpc	r11,r12
8000bea4:	5e 8f       	retls	1
8000bea6:	5e fd       	retal	0

8000bea8 <__avr32_f64_cmp_ge>:
8000bea8:	1a de       	st.w	--sp,lr
8000beaa:	1a d7       	st.w	--sp,r7
8000beac:	a1 7b       	lsl	r11,0x1
8000beae:	5f 3c       	srlo	r12
8000beb0:	a1 79       	lsl	r9,0x1
8000beb2:	5f 37       	srlo	r7
8000beb4:	5c fc       	rol	r12
8000beb6:	fc 1e ff e0 	movh	lr,0xffe0
8000beba:	58 0a       	cp.w	r10,0
8000bebc:	fc 0b 13 00 	cpc	r11,lr
8000bec0:	e0 8b 00 1d 	brhi	8000befa <__avr32_f64_cmp_ge+0x52>
8000bec4:	58 08       	cp.w	r8,0
8000bec6:	fc 09 13 00 	cpc	r9,lr
8000beca:	e0 8b 00 18 	brhi	8000befa <__avr32_f64_cmp_ge+0x52>
8000bece:	58 0b       	cp.w	r11,0
8000bed0:	f5 ba 00 00 	subfeq	r10,0
8000bed4:	c1 50       	breq	8000befe <__avr32_f64_cmp_ge+0x56>
8000bed6:	1b 07       	ld.w	r7,sp++
8000bed8:	1b 0e       	ld.w	lr,sp++
8000beda:	58 3c       	cp.w	r12,3
8000bedc:	c0 a0       	breq	8000bef0 <__avr32_f64_cmp_ge+0x48>
8000bede:	58 1c       	cp.w	r12,1
8000bee0:	c0 33       	brcs	8000bee6 <__avr32_f64_cmp_ge+0x3e>
8000bee2:	5e 0f       	reteq	1
8000bee4:	5e 1d       	retne	0
8000bee6:	10 3a       	cp.w	r10,r8
8000bee8:	f2 0b 13 00 	cpc	r11,r9
8000beec:	5e 2f       	reths	1
8000beee:	5e 3d       	retlo	0
8000bef0:	14 38       	cp.w	r8,r10
8000bef2:	f6 09 13 00 	cpc	r9,r11
8000bef6:	5e 2f       	reths	1
8000bef8:	5e 3d       	retlo	0
8000befa:	1b 07       	ld.w	r7,sp++
8000befc:	d8 0a       	popm	pc,r12=0
8000befe:	58 17       	cp.w	r7,1
8000bf00:	5f 0c       	sreq	r12
8000bf02:	58 09       	cp.w	r9,0
8000bf04:	f5 b8 00 00 	subfeq	r8,0
8000bf08:	1b 07       	ld.w	r7,sp++
8000bf0a:	1b 0e       	ld.w	lr,sp++
8000bf0c:	5e 0f       	reteq	1
8000bf0e:	5e fc       	retal	r12

8000bf10 <__avr32_f64_cmp_lt>:
8000bf10:	1a de       	st.w	--sp,lr
8000bf12:	1a d7       	st.w	--sp,r7
8000bf14:	a1 7b       	lsl	r11,0x1
8000bf16:	5f 3c       	srlo	r12
8000bf18:	a1 79       	lsl	r9,0x1
8000bf1a:	5f 37       	srlo	r7
8000bf1c:	5c fc       	rol	r12
8000bf1e:	fc 1e ff e0 	movh	lr,0xffe0
8000bf22:	58 0a       	cp.w	r10,0
8000bf24:	fc 0b 13 00 	cpc	r11,lr
8000bf28:	e0 8b 00 1d 	brhi	8000bf62 <__avr32_f64_cmp_lt+0x52>
8000bf2c:	58 08       	cp.w	r8,0
8000bf2e:	fc 09 13 00 	cpc	r9,lr
8000bf32:	e0 8b 00 18 	brhi	8000bf62 <__avr32_f64_cmp_lt+0x52>
8000bf36:	58 0b       	cp.w	r11,0
8000bf38:	f5 ba 00 00 	subfeq	r10,0
8000bf3c:	c1 50       	breq	8000bf66 <__avr32_f64_cmp_lt+0x56>
8000bf3e:	1b 07       	ld.w	r7,sp++
8000bf40:	1b 0e       	ld.w	lr,sp++
8000bf42:	58 3c       	cp.w	r12,3
8000bf44:	c0 a0       	breq	8000bf58 <__avr32_f64_cmp_lt+0x48>
8000bf46:	58 1c       	cp.w	r12,1
8000bf48:	c0 33       	brcs	8000bf4e <__avr32_f64_cmp_lt+0x3e>
8000bf4a:	5e 0d       	reteq	0
8000bf4c:	5e 1f       	retne	1
8000bf4e:	10 3a       	cp.w	r10,r8
8000bf50:	f2 0b 13 00 	cpc	r11,r9
8000bf54:	5e 2d       	reths	0
8000bf56:	5e 3f       	retlo	1
8000bf58:	14 38       	cp.w	r8,r10
8000bf5a:	f6 09 13 00 	cpc	r9,r11
8000bf5e:	5e 2d       	reths	0
8000bf60:	5e 3f       	retlo	1
8000bf62:	1b 07       	ld.w	r7,sp++
8000bf64:	d8 0a       	popm	pc,r12=0
8000bf66:	58 17       	cp.w	r7,1
8000bf68:	5f 1c       	srne	r12
8000bf6a:	58 09       	cp.w	r9,0
8000bf6c:	f5 b8 00 00 	subfeq	r8,0
8000bf70:	1b 07       	ld.w	r7,sp++
8000bf72:	1b 0e       	ld.w	lr,sp++
8000bf74:	5e 0d       	reteq	0
8000bf76:	5e fc       	retal	r12

8000bf78 <__avr32_f64_div>:
8000bf78:	eb cd 40 ff 	pushm	r0-r7,lr
8000bf7c:	f7 e9 20 0e 	eor	lr,r11,r9
8000bf80:	f6 07 16 14 	lsr	r7,r11,0x14
8000bf84:	a9 7b       	lsl	r11,0x9
8000bf86:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000bf8a:	a9 7a       	lsl	r10,0x9
8000bf8c:	bd bb       	sbr	r11,0x1d
8000bf8e:	e4 1b 3f ff 	andh	r11,0x3fff
8000bf92:	ab d7       	cbr	r7,0xb
8000bf94:	e0 80 00 cc 	breq	8000c12c <__avr32_f64_div_round_subnormal+0x54>
8000bf98:	e0 47 07 ff 	cp.w	r7,2047
8000bf9c:	e0 84 00 b5 	brge	8000c106 <__avr32_f64_div_round_subnormal+0x2e>
8000bfa0:	f2 06 16 14 	lsr	r6,r9,0x14
8000bfa4:	a9 79       	lsl	r9,0x9
8000bfa6:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000bfaa:	a9 78       	lsl	r8,0x9
8000bfac:	bd b9       	sbr	r9,0x1d
8000bfae:	e4 19 3f ff 	andh	r9,0x3fff
8000bfb2:	ab d6       	cbr	r6,0xb
8000bfb4:	e0 80 00 e2 	breq	8000c178 <__avr32_f64_div_round_subnormal+0xa0>
8000bfb8:	e0 46 07 ff 	cp.w	r6,2047
8000bfbc:	e0 84 00 b2 	brge	8000c120 <__avr32_f64_div_round_subnormal+0x48>
8000bfc0:	0c 17       	sub	r7,r6
8000bfc2:	fe 37 fc 01 	sub	r7,-1023
8000bfc6:	fc 1c 80 00 	movh	r12,0x8000
8000bfca:	f8 03 16 01 	lsr	r3,r12,0x1
8000bfce:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000bfd2:	5c d4       	com	r4
8000bfd4:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000bfd8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bfdc:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bfe0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bfe4:	ea 03 15 02 	lsl	r3,r5,0x2
8000bfe8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bfec:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bff0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bff4:	ea 03 15 02 	lsl	r3,r5,0x2
8000bff8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bffc:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c000:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c004:	ea 03 15 02 	lsl	r3,r5,0x2
8000c008:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c00c:	e4 09 07 40 	macu.d	r0,r2,r9
8000c010:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c014:	02 04       	add	r4,r1
8000c016:	5c 05       	acr	r5
8000c018:	a3 65       	lsl	r5,0x2
8000c01a:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c01e:	a3 64       	lsl	r4,0x2
8000c020:	5c 34       	neg	r4
8000c022:	f8 05 01 45 	sbc	r5,r12,r5
8000c026:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c02a:	e4 05 07 40 	macu.d	r0,r2,r5
8000c02e:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c032:	02 04       	add	r4,r1
8000c034:	5c 05       	acr	r5
8000c036:	ea 03 15 02 	lsl	r3,r5,0x2
8000c03a:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c03e:	e8 02 15 02 	lsl	r2,r4,0x2
8000c042:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c046:	e4 09 07 40 	macu.d	r0,r2,r9
8000c04a:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c04e:	02 04       	add	r4,r1
8000c050:	5c 05       	acr	r5
8000c052:	a3 65       	lsl	r5,0x2
8000c054:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c058:	a3 64       	lsl	r4,0x2
8000c05a:	5c 34       	neg	r4
8000c05c:	f8 05 01 45 	sbc	r5,r12,r5
8000c060:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c064:	e4 05 07 40 	macu.d	r0,r2,r5
8000c068:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c06c:	02 04       	add	r4,r1
8000c06e:	5c 05       	acr	r5
8000c070:	ea 03 15 02 	lsl	r3,r5,0x2
8000c074:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c078:	e8 02 15 02 	lsl	r2,r4,0x2
8000c07c:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c080:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c084:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c088:	02 02       	add	r2,r1
8000c08a:	5c 03       	acr	r3
8000c08c:	ed b3 00 1c 	bld	r3,0x1c
8000c090:	c0 90       	breq	8000c0a2 <__avr32_f64_div+0x12a>
8000c092:	a1 72       	lsl	r2,0x1
8000c094:	5c f3       	rol	r3
8000c096:	20 17       	sub	r7,1
8000c098:	a3 9a       	lsr	r10,0x3
8000c09a:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c09e:	a3 9b       	lsr	r11,0x3
8000c0a0:	c0 58       	rjmp	8000c0aa <__avr32_f64_div+0x132>
8000c0a2:	a5 8a       	lsr	r10,0x4
8000c0a4:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c0a8:	a5 8b       	lsr	r11,0x4
8000c0aa:	58 07       	cp.w	r7,0
8000c0ac:	e0 8a 00 8b 	brle	8000c1c2 <__avr32_f64_div_res_subnormal>
8000c0b0:	e0 12 ff 00 	andl	r2,0xff00
8000c0b4:	e8 12 00 80 	orl	r2,0x80
8000c0b8:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c0bc:	e4 09 07 40 	macu.d	r0,r2,r9
8000c0c0:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c0c4:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c0c8:	00 05       	add	r5,r0
8000c0ca:	f0 01 00 48 	adc	r8,r8,r1
8000c0ce:	5c 09       	acr	r9
8000c0d0:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c0d4:	58 04       	cp.w	r4,0
8000c0d6:	5c 25       	cpc	r5

8000c0d8 <__avr32_f64_div_round_subnormal>:
8000c0d8:	f4 08 13 00 	cpc	r8,r10
8000c0dc:	f6 09 13 00 	cpc	r9,r11
8000c0e0:	5f 36       	srlo	r6
8000c0e2:	f8 06 17 00 	moveq	r6,r12
8000c0e6:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c0ea:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c0ee:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c0f2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c0f6:	ed be 00 1f 	bld	lr,0x1f
8000c0fa:	ef bb 00 1f 	bst	r11,0x1f
8000c0fe:	0c 0a       	add	r10,r6
8000c100:	5c 0b       	acr	r11
8000c102:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c106:	e4 1b 00 0f 	andh	r11,0xf
8000c10a:	14 4b       	or	r11,r10
8000c10c:	e0 81 00 a7 	brne	8000c25a <__avr32_f64_div_res_subnormal+0x98>
8000c110:	f2 06 16 14 	lsr	r6,r9,0x14
8000c114:	ab d6       	cbr	r6,0xb
8000c116:	e0 46 07 ff 	cp.w	r6,2047
8000c11a:	e0 81 00 a4 	brne	8000c262 <__avr32_f64_div_res_subnormal+0xa0>
8000c11e:	c9 e8       	rjmp	8000c25a <__avr32_f64_div_res_subnormal+0x98>
8000c120:	e4 19 00 0f 	andh	r9,0xf
8000c124:	10 49       	or	r9,r8
8000c126:	e0 81 00 9a 	brne	8000c25a <__avr32_f64_div_res_subnormal+0x98>
8000c12a:	c9 28       	rjmp	8000c24e <__avr32_f64_div_res_subnormal+0x8c>
8000c12c:	a3 7b       	lsl	r11,0x3
8000c12e:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c132:	a3 7a       	lsl	r10,0x3
8000c134:	f5 eb 10 04 	or	r4,r10,r11
8000c138:	e0 80 00 a0 	breq	8000c278 <__avr32_f64_div_op1_zero>
8000c13c:	f6 04 12 00 	clz	r4,r11
8000c140:	c1 70       	breq	8000c16e <__avr32_f64_div_round_subnormal+0x96>
8000c142:	c0 c3       	brcs	8000c15a <__avr32_f64_div_round_subnormal+0x82>
8000c144:	e8 05 11 20 	rsub	r5,r4,32
8000c148:	f6 04 09 4b 	lsl	r11,r11,r4
8000c14c:	f4 05 0a 45 	lsr	r5,r10,r5
8000c150:	0a 4b       	or	r11,r5
8000c152:	f4 04 09 4a 	lsl	r10,r10,r4
8000c156:	08 17       	sub	r7,r4
8000c158:	c0 b8       	rjmp	8000c16e <__avr32_f64_div_round_subnormal+0x96>
8000c15a:	f4 04 12 00 	clz	r4,r10
8000c15e:	f9 b4 03 00 	movlo	r4,0
8000c162:	f7 b4 02 e0 	subhs	r4,-32
8000c166:	f4 04 09 4b 	lsl	r11,r10,r4
8000c16a:	30 0a       	mov	r10,0
8000c16c:	08 17       	sub	r7,r4
8000c16e:	a3 8a       	lsr	r10,0x2
8000c170:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c174:	a3 8b       	lsr	r11,0x2
8000c176:	c1 1b       	rjmp	8000bf98 <__avr32_f64_div+0x20>
8000c178:	a3 79       	lsl	r9,0x3
8000c17a:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c17e:	a3 78       	lsl	r8,0x3
8000c180:	f3 e8 10 04 	or	r4,r9,r8
8000c184:	c6 f0       	breq	8000c262 <__avr32_f64_div_res_subnormal+0xa0>
8000c186:	f2 04 12 00 	clz	r4,r9
8000c18a:	c1 70       	breq	8000c1b8 <__avr32_f64_div_round_subnormal+0xe0>
8000c18c:	c0 c3       	brcs	8000c1a4 <__avr32_f64_div_round_subnormal+0xcc>
8000c18e:	e8 05 11 20 	rsub	r5,r4,32
8000c192:	f2 04 09 49 	lsl	r9,r9,r4
8000c196:	f0 05 0a 45 	lsr	r5,r8,r5
8000c19a:	0a 49       	or	r9,r5
8000c19c:	f0 04 09 48 	lsl	r8,r8,r4
8000c1a0:	08 16       	sub	r6,r4
8000c1a2:	c0 b8       	rjmp	8000c1b8 <__avr32_f64_div_round_subnormal+0xe0>
8000c1a4:	f0 04 12 00 	clz	r4,r8
8000c1a8:	f9 b4 03 00 	movlo	r4,0
8000c1ac:	f7 b4 02 e0 	subhs	r4,-32
8000c1b0:	f0 04 09 49 	lsl	r9,r8,r4
8000c1b4:	30 08       	mov	r8,0
8000c1b6:	08 16       	sub	r6,r4
8000c1b8:	a3 88       	lsr	r8,0x2
8000c1ba:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c1be:	a3 89       	lsr	r9,0x2
8000c1c0:	cf ca       	rjmp	8000bfb8 <__avr32_f64_div+0x40>

8000c1c2 <__avr32_f64_div_res_subnormal>:
8000c1c2:	5c 37       	neg	r7
8000c1c4:	2f f7       	sub	r7,-1
8000c1c6:	f1 b7 04 c0 	satu	r7,0x6
8000c1ca:	e0 47 00 20 	cp.w	r7,32
8000c1ce:	c1 54       	brge	8000c1f8 <__avr32_f64_div_res_subnormal+0x36>
8000c1d0:	ee 06 11 20 	rsub	r6,r7,32
8000c1d4:	e4 07 0a 42 	lsr	r2,r2,r7
8000c1d8:	e6 06 09 4c 	lsl	r12,r3,r6
8000c1dc:	18 42       	or	r2,r12
8000c1de:	e6 07 0a 43 	lsr	r3,r3,r7
8000c1e2:	f4 06 09 41 	lsl	r1,r10,r6
8000c1e6:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c1ea:	f6 06 09 4c 	lsl	r12,r11,r6
8000c1ee:	18 4a       	or	r10,r12
8000c1f0:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c1f4:	30 00       	mov	r0,0
8000c1f6:	c1 58       	rjmp	8000c220 <__avr32_f64_div_res_subnormal+0x5e>
8000c1f8:	ee 06 11 20 	rsub	r6,r7,32
8000c1fc:	f9 b0 00 00 	moveq	r0,0
8000c200:	f9 bc 00 00 	moveq	r12,0
8000c204:	c0 50       	breq	8000c20e <__avr32_f64_div_res_subnormal+0x4c>
8000c206:	f4 06 09 40 	lsl	r0,r10,r6
8000c20a:	f6 06 09 4c 	lsl	r12,r11,r6
8000c20e:	e6 07 0a 42 	lsr	r2,r3,r7
8000c212:	30 03       	mov	r3,0
8000c214:	f4 07 0a 41 	lsr	r1,r10,r7
8000c218:	18 41       	or	r1,r12
8000c21a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c21e:	30 0b       	mov	r11,0
8000c220:	e0 12 ff 00 	andl	r2,0xff00
8000c224:	e8 12 00 80 	orl	r2,0x80
8000c228:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c22c:	e4 09 07 46 	macu.d	r6,r2,r9
8000c230:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c234:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c238:	0c 05       	add	r5,r6
8000c23a:	f0 07 00 48 	adc	r8,r8,r7
8000c23e:	5c 09       	acr	r9
8000c240:	30 07       	mov	r7,0
8000c242:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c246:	00 34       	cp.w	r4,r0
8000c248:	e2 05 13 00 	cpc	r5,r1
8000c24c:	c4 6b       	rjmp	8000c0d8 <__avr32_f64_div_round_subnormal>
8000c24e:	1c 9b       	mov	r11,lr
8000c250:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c254:	30 0a       	mov	r10,0
8000c256:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c25a:	3f fb       	mov	r11,-1
8000c25c:	30 0a       	mov	r10,0
8000c25e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c262:	f5 eb 10 04 	or	r4,r10,r11
8000c266:	c0 90       	breq	8000c278 <__avr32_f64_div_op1_zero>
8000c268:	1c 9b       	mov	r11,lr
8000c26a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c26e:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c272:	30 0a       	mov	r10,0
8000c274:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c278 <__avr32_f64_div_op1_zero>:
8000c278:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c27c:	ce f0       	breq	8000c25a <__avr32_f64_div_res_subnormal+0x98>
8000c27e:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c282:	e0 44 07 ff 	cp.w	r4,2047
8000c286:	ce 41       	brne	8000c24e <__avr32_f64_div_res_subnormal+0x8c>
8000c288:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c28c:	ce 10       	breq	8000c24e <__avr32_f64_div_res_subnormal+0x8c>
8000c28e:	ce 6b       	rjmp	8000c25a <__avr32_f64_div_res_subnormal+0x98>

8000c290 <__avr32_udiv64>:
8000c290:	d4 31       	pushm	r0-r7,lr
8000c292:	1a 97       	mov	r7,sp
8000c294:	20 3d       	sub	sp,12
8000c296:	10 9c       	mov	r12,r8
8000c298:	12 9e       	mov	lr,r9
8000c29a:	14 93       	mov	r3,r10
8000c29c:	58 09       	cp.w	r9,0
8000c29e:	e0 81 00 bd 	brne	8000c418 <__avr32_udiv64+0x188>
8000c2a2:	16 38       	cp.w	r8,r11
8000c2a4:	e0 88 00 40 	brls	8000c324 <__avr32_udiv64+0x94>
8000c2a8:	f0 08 12 00 	clz	r8,r8
8000c2ac:	c0 d0       	breq	8000c2c6 <__avr32_udiv64+0x36>
8000c2ae:	f6 08 09 4b 	lsl	r11,r11,r8
8000c2b2:	f0 09 11 20 	rsub	r9,r8,32
8000c2b6:	f8 08 09 4c 	lsl	r12,r12,r8
8000c2ba:	f4 09 0a 49 	lsr	r9,r10,r9
8000c2be:	f4 08 09 43 	lsl	r3,r10,r8
8000c2c2:	f3 eb 10 0b 	or	r11,r9,r11
8000c2c6:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c2ca:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c2ce:	f6 0e 0d 00 	divu	r0,r11,lr
8000c2d2:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c2d6:	00 99       	mov	r9,r0
8000c2d8:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c2dc:	e0 0a 02 48 	mul	r8,r0,r10
8000c2e0:	10 3b       	cp.w	r11,r8
8000c2e2:	c0 a2       	brcc	8000c2f6 <__avr32_udiv64+0x66>
8000c2e4:	20 19       	sub	r9,1
8000c2e6:	18 0b       	add	r11,r12
8000c2e8:	18 3b       	cp.w	r11,r12
8000c2ea:	c0 63       	brcs	8000c2f6 <__avr32_udiv64+0x66>
8000c2ec:	10 3b       	cp.w	r11,r8
8000c2ee:	f7 b9 03 01 	sublo	r9,1
8000c2f2:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c2f6:	f6 08 01 01 	sub	r1,r11,r8
8000c2fa:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c2fe:	e2 0e 0d 00 	divu	r0,r1,lr
8000c302:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c306:	00 98       	mov	r8,r0
8000c308:	e0 0a 02 4a 	mul	r10,r0,r10
8000c30c:	14 33       	cp.w	r3,r10
8000c30e:	c0 82       	brcc	8000c31e <__avr32_udiv64+0x8e>
8000c310:	20 18       	sub	r8,1
8000c312:	18 03       	add	r3,r12
8000c314:	18 33       	cp.w	r3,r12
8000c316:	c0 43       	brcs	8000c31e <__avr32_udiv64+0x8e>
8000c318:	14 33       	cp.w	r3,r10
8000c31a:	f7 b8 03 01 	sublo	r8,1
8000c31e:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c322:	cd f8       	rjmp	8000c4e0 <__avr32_udiv64+0x250>
8000c324:	58 08       	cp.w	r8,0
8000c326:	c0 51       	brne	8000c330 <__avr32_udiv64+0xa0>
8000c328:	30 19       	mov	r9,1
8000c32a:	f2 08 0d 08 	divu	r8,r9,r8
8000c32e:	10 9c       	mov	r12,r8
8000c330:	f8 06 12 00 	clz	r6,r12
8000c334:	c0 41       	brne	8000c33c <__avr32_udiv64+0xac>
8000c336:	18 1b       	sub	r11,r12
8000c338:	30 19       	mov	r9,1
8000c33a:	c4 08       	rjmp	8000c3ba <__avr32_udiv64+0x12a>
8000c33c:	ec 01 11 20 	rsub	r1,r6,32
8000c340:	f4 01 0a 49 	lsr	r9,r10,r1
8000c344:	f8 06 09 4c 	lsl	r12,r12,r6
8000c348:	f6 06 09 48 	lsl	r8,r11,r6
8000c34c:	f6 01 0a 41 	lsr	r1,r11,r1
8000c350:	f3 e8 10 08 	or	r8,r9,r8
8000c354:	f8 03 16 10 	lsr	r3,r12,0x10
8000c358:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c35c:	e2 03 0d 00 	divu	r0,r1,r3
8000c360:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c364:	00 9e       	mov	lr,r0
8000c366:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c36a:	e0 05 02 49 	mul	r9,r0,r5
8000c36e:	12 3b       	cp.w	r11,r9
8000c370:	c0 a2       	brcc	8000c384 <__avr32_udiv64+0xf4>
8000c372:	20 1e       	sub	lr,1
8000c374:	18 0b       	add	r11,r12
8000c376:	18 3b       	cp.w	r11,r12
8000c378:	c0 63       	brcs	8000c384 <__avr32_udiv64+0xf4>
8000c37a:	12 3b       	cp.w	r11,r9
8000c37c:	f7 be 03 01 	sublo	lr,1
8000c380:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c384:	12 1b       	sub	r11,r9
8000c386:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c38a:	f6 03 0d 02 	divu	r2,r11,r3
8000c38e:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c392:	04 99       	mov	r9,r2
8000c394:	e4 05 02 4b 	mul	r11,r2,r5
8000c398:	16 38       	cp.w	r8,r11
8000c39a:	c0 a2       	brcc	8000c3ae <__avr32_udiv64+0x11e>
8000c39c:	20 19       	sub	r9,1
8000c39e:	18 08       	add	r8,r12
8000c3a0:	18 38       	cp.w	r8,r12
8000c3a2:	c0 63       	brcs	8000c3ae <__avr32_udiv64+0x11e>
8000c3a4:	16 38       	cp.w	r8,r11
8000c3a6:	f7 b9 03 01 	sublo	r9,1
8000c3aa:	f1 dc e3 08 	addcs	r8,r8,r12
8000c3ae:	f4 06 09 43 	lsl	r3,r10,r6
8000c3b2:	f0 0b 01 0b 	sub	r11,r8,r11
8000c3b6:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c3ba:	f8 06 16 10 	lsr	r6,r12,0x10
8000c3be:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c3c2:	f6 06 0d 00 	divu	r0,r11,r6
8000c3c6:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c3ca:	00 9a       	mov	r10,r0
8000c3cc:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c3d0:	e0 0e 02 48 	mul	r8,r0,lr
8000c3d4:	10 3b       	cp.w	r11,r8
8000c3d6:	c0 a2       	brcc	8000c3ea <__avr32_udiv64+0x15a>
8000c3d8:	20 1a       	sub	r10,1
8000c3da:	18 0b       	add	r11,r12
8000c3dc:	18 3b       	cp.w	r11,r12
8000c3de:	c0 63       	brcs	8000c3ea <__avr32_udiv64+0x15a>
8000c3e0:	10 3b       	cp.w	r11,r8
8000c3e2:	f7 ba 03 01 	sublo	r10,1
8000c3e6:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c3ea:	f6 08 01 01 	sub	r1,r11,r8
8000c3ee:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c3f2:	e2 06 0d 00 	divu	r0,r1,r6
8000c3f6:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c3fa:	00 98       	mov	r8,r0
8000c3fc:	e0 0e 02 4b 	mul	r11,r0,lr
8000c400:	16 33       	cp.w	r3,r11
8000c402:	c0 82       	brcc	8000c412 <__avr32_udiv64+0x182>
8000c404:	20 18       	sub	r8,1
8000c406:	18 03       	add	r3,r12
8000c408:	18 33       	cp.w	r3,r12
8000c40a:	c0 43       	brcs	8000c412 <__avr32_udiv64+0x182>
8000c40c:	16 33       	cp.w	r3,r11
8000c40e:	f7 b8 03 01 	sublo	r8,1
8000c412:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c416:	c6 98       	rjmp	8000c4e8 <__avr32_udiv64+0x258>
8000c418:	16 39       	cp.w	r9,r11
8000c41a:	e0 8b 00 65 	brhi	8000c4e4 <__avr32_udiv64+0x254>
8000c41e:	f2 09 12 00 	clz	r9,r9
8000c422:	c0 b1       	brne	8000c438 <__avr32_udiv64+0x1a8>
8000c424:	10 3a       	cp.w	r10,r8
8000c426:	5f 2a       	srhs	r10
8000c428:	1c 3b       	cp.w	r11,lr
8000c42a:	5f b8       	srhi	r8
8000c42c:	10 4a       	or	r10,r8
8000c42e:	f2 0a 18 00 	cp.b	r10,r9
8000c432:	c5 90       	breq	8000c4e4 <__avr32_udiv64+0x254>
8000c434:	30 18       	mov	r8,1
8000c436:	c5 98       	rjmp	8000c4e8 <__avr32_udiv64+0x258>
8000c438:	f0 09 09 46 	lsl	r6,r8,r9
8000c43c:	f2 03 11 20 	rsub	r3,r9,32
8000c440:	fc 09 09 4e 	lsl	lr,lr,r9
8000c444:	f0 03 0a 48 	lsr	r8,r8,r3
8000c448:	f6 09 09 4c 	lsl	r12,r11,r9
8000c44c:	f4 03 0a 42 	lsr	r2,r10,r3
8000c450:	ef 46 ff f4 	st.w	r7[-12],r6
8000c454:	f6 03 0a 43 	lsr	r3,r11,r3
8000c458:	18 42       	or	r2,r12
8000c45a:	f1 ee 10 0c 	or	r12,r8,lr
8000c45e:	f8 01 16 10 	lsr	r1,r12,0x10
8000c462:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c466:	e6 01 0d 04 	divu	r4,r3,r1
8000c46a:	e4 03 16 10 	lsr	r3,r2,0x10
8000c46e:	08 9e       	mov	lr,r4
8000c470:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c474:	e8 06 02 48 	mul	r8,r4,r6
8000c478:	10 33       	cp.w	r3,r8
8000c47a:	c0 a2       	brcc	8000c48e <__avr32_udiv64+0x1fe>
8000c47c:	20 1e       	sub	lr,1
8000c47e:	18 03       	add	r3,r12
8000c480:	18 33       	cp.w	r3,r12
8000c482:	c0 63       	brcs	8000c48e <__avr32_udiv64+0x1fe>
8000c484:	10 33       	cp.w	r3,r8
8000c486:	f7 be 03 01 	sublo	lr,1
8000c48a:	e7 dc e3 03 	addcs	r3,r3,r12
8000c48e:	10 13       	sub	r3,r8
8000c490:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c494:	e6 01 0d 00 	divu	r0,r3,r1
8000c498:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c49c:	00 98       	mov	r8,r0
8000c49e:	e0 06 02 46 	mul	r6,r0,r6
8000c4a2:	0c 3b       	cp.w	r11,r6
8000c4a4:	c0 a2       	brcc	8000c4b8 <__avr32_udiv64+0x228>
8000c4a6:	20 18       	sub	r8,1
8000c4a8:	18 0b       	add	r11,r12
8000c4aa:	18 3b       	cp.w	r11,r12
8000c4ac:	c0 63       	brcs	8000c4b8 <__avr32_udiv64+0x228>
8000c4ae:	0c 3b       	cp.w	r11,r6
8000c4b0:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c4b4:	f7 b8 03 01 	sublo	r8,1
8000c4b8:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c4bc:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c4c0:	0c 1b       	sub	r11,r6
8000c4c2:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c4c6:	06 95       	mov	r5,r3
8000c4c8:	16 35       	cp.w	r5,r11
8000c4ca:	e0 8b 00 0a 	brhi	8000c4de <__avr32_udiv64+0x24e>
8000c4ce:	5f 0b       	sreq	r11
8000c4d0:	f4 09 09 49 	lsl	r9,r10,r9
8000c4d4:	12 32       	cp.w	r2,r9
8000c4d6:	5f b9       	srhi	r9
8000c4d8:	f7 e9 00 09 	and	r9,r11,r9
8000c4dc:	c0 60       	breq	8000c4e8 <__avr32_udiv64+0x258>
8000c4de:	20 18       	sub	r8,1
8000c4e0:	30 09       	mov	r9,0
8000c4e2:	c0 38       	rjmp	8000c4e8 <__avr32_udiv64+0x258>
8000c4e4:	30 09       	mov	r9,0
8000c4e6:	12 98       	mov	r8,r9
8000c4e8:	10 9a       	mov	r10,r8
8000c4ea:	12 93       	mov	r3,r9
8000c4ec:	10 92       	mov	r2,r8
8000c4ee:	12 9b       	mov	r11,r9
8000c4f0:	2f dd       	sub	sp,-12
8000c4f2:	d8 32       	popm	r0-r7,pc

8000c4f4 <__avr32_umod64>:
8000c4f4:	d4 31       	pushm	r0-r7,lr
8000c4f6:	1a 97       	mov	r7,sp
8000c4f8:	20 3d       	sub	sp,12
8000c4fa:	10 9c       	mov	r12,r8
8000c4fc:	12 95       	mov	r5,r9
8000c4fe:	14 9e       	mov	lr,r10
8000c500:	16 91       	mov	r1,r11
8000c502:	16 96       	mov	r6,r11
8000c504:	58 09       	cp.w	r9,0
8000c506:	e0 81 00 81 	brne	8000c608 <__avr32_umod64+0x114>
8000c50a:	16 38       	cp.w	r8,r11
8000c50c:	e0 88 00 12 	brls	8000c530 <__avr32_umod64+0x3c>
8000c510:	f0 08 12 00 	clz	r8,r8
8000c514:	c4 e0       	breq	8000c5b0 <__avr32_umod64+0xbc>
8000c516:	f6 08 09 46 	lsl	r6,r11,r8
8000c51a:	f8 08 09 4c 	lsl	r12,r12,r8
8000c51e:	f0 0b 11 20 	rsub	r11,r8,32
8000c522:	f4 08 09 4e 	lsl	lr,r10,r8
8000c526:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c52a:	f7 e6 10 06 	or	r6,r11,r6
8000c52e:	c4 18       	rjmp	8000c5b0 <__avr32_umod64+0xbc>
8000c530:	58 08       	cp.w	r8,0
8000c532:	c0 51       	brne	8000c53c <__avr32_umod64+0x48>
8000c534:	30 19       	mov	r9,1
8000c536:	f2 08 0d 08 	divu	r8,r9,r8
8000c53a:	10 9c       	mov	r12,r8
8000c53c:	f8 08 12 00 	clz	r8,r12
8000c540:	c0 31       	brne	8000c546 <__avr32_umod64+0x52>
8000c542:	18 16       	sub	r6,r12
8000c544:	c3 68       	rjmp	8000c5b0 <__avr32_umod64+0xbc>
8000c546:	f0 03 11 20 	rsub	r3,r8,32
8000c54a:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c54e:	f8 08 09 4c 	lsl	r12,r12,r8
8000c552:	ec 08 09 49 	lsl	r9,r6,r8
8000c556:	ec 03 0a 43 	lsr	r3,r6,r3
8000c55a:	f7 e9 10 09 	or	r9,r11,r9
8000c55e:	f8 05 16 10 	lsr	r5,r12,0x10
8000c562:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c566:	e6 05 0d 02 	divu	r2,r3,r5
8000c56a:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c56e:	ec 02 02 4b 	mul	r11,r6,r2
8000c572:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c576:	16 3e       	cp.w	lr,r11
8000c578:	c0 72       	brcc	8000c586 <__avr32_umod64+0x92>
8000c57a:	18 0e       	add	lr,r12
8000c57c:	18 3e       	cp.w	lr,r12
8000c57e:	c0 43       	brcs	8000c586 <__avr32_umod64+0x92>
8000c580:	16 3e       	cp.w	lr,r11
8000c582:	fd dc e3 0e 	addcs	lr,lr,r12
8000c586:	fc 0b 01 03 	sub	r3,lr,r11
8000c58a:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c58e:	e6 05 0d 02 	divu	r2,r3,r5
8000c592:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c596:	a5 36       	mul	r6,r2
8000c598:	0c 39       	cp.w	r9,r6
8000c59a:	c0 72       	brcc	8000c5a8 <__avr32_umod64+0xb4>
8000c59c:	18 09       	add	r9,r12
8000c59e:	18 39       	cp.w	r9,r12
8000c5a0:	c0 43       	brcs	8000c5a8 <__avr32_umod64+0xb4>
8000c5a2:	0c 39       	cp.w	r9,r6
8000c5a4:	f3 dc e3 09 	addcs	r9,r9,r12
8000c5a8:	f2 06 01 06 	sub	r6,r9,r6
8000c5ac:	f4 08 09 4e 	lsl	lr,r10,r8
8000c5b0:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c5b4:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c5b8:	ec 0a 0d 02 	divu	r2,r6,r10
8000c5bc:	fc 09 16 10 	lsr	r9,lr,0x10
8000c5c0:	ea 02 02 4b 	mul	r11,r5,r2
8000c5c4:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c5c8:	16 39       	cp.w	r9,r11
8000c5ca:	c0 72       	brcc	8000c5d8 <__avr32_umod64+0xe4>
8000c5cc:	18 09       	add	r9,r12
8000c5ce:	18 39       	cp.w	r9,r12
8000c5d0:	c0 43       	brcs	8000c5d8 <__avr32_umod64+0xe4>
8000c5d2:	16 39       	cp.w	r9,r11
8000c5d4:	f3 dc e3 09 	addcs	r9,r9,r12
8000c5d8:	f2 0b 01 0b 	sub	r11,r9,r11
8000c5dc:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c5e0:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c5e4:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c5e8:	ea 0a 02 4a 	mul	r10,r5,r10
8000c5ec:	14 3e       	cp.w	lr,r10
8000c5ee:	c0 72       	brcc	8000c5fc <__avr32_umod64+0x108>
8000c5f0:	18 0e       	add	lr,r12
8000c5f2:	18 3e       	cp.w	lr,r12
8000c5f4:	c0 43       	brcs	8000c5fc <__avr32_umod64+0x108>
8000c5f6:	14 3e       	cp.w	lr,r10
8000c5f8:	fd dc e3 0e 	addcs	lr,lr,r12
8000c5fc:	fc 0a 01 0a 	sub	r10,lr,r10
8000c600:	30 0b       	mov	r11,0
8000c602:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c606:	c7 b8       	rjmp	8000c6fc <__avr32_umod64+0x208>
8000c608:	16 39       	cp.w	r9,r11
8000c60a:	e0 8b 00 79 	brhi	8000c6fc <__avr32_umod64+0x208>
8000c60e:	f2 09 12 00 	clz	r9,r9
8000c612:	c1 21       	brne	8000c636 <__avr32_umod64+0x142>
8000c614:	10 3a       	cp.w	r10,r8
8000c616:	5f 2b       	srhs	r11
8000c618:	0a 31       	cp.w	r1,r5
8000c61a:	5f ba       	srhi	r10
8000c61c:	f7 ea 10 0a 	or	r10,r11,r10
8000c620:	f2 0a 18 00 	cp.b	r10,r9
8000c624:	c0 60       	breq	8000c630 <__avr32_umod64+0x13c>
8000c626:	fc 08 01 0c 	sub	r12,lr,r8
8000c62a:	e2 05 01 46 	sbc	r6,r1,r5
8000c62e:	18 9e       	mov	lr,r12
8000c630:	0c 9b       	mov	r11,r6
8000c632:	1c 9a       	mov	r10,lr
8000c634:	c6 48       	rjmp	8000c6fc <__avr32_umod64+0x208>
8000c636:	ea 09 09 4c 	lsl	r12,r5,r9
8000c63a:	f2 06 11 20 	rsub	r6,r9,32
8000c63e:	f6 09 09 4b 	lsl	r11,r11,r9
8000c642:	f0 09 09 42 	lsl	r2,r8,r9
8000c646:	ef 46 ff f4 	st.w	r7[-12],r6
8000c64a:	f0 06 0a 48 	lsr	r8,r8,r6
8000c64e:	18 48       	or	r8,r12
8000c650:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c654:	f4 09 09 43 	lsl	r3,r10,r9
8000c658:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c65c:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c660:	16 4a       	or	r10,r11
8000c662:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c666:	f8 0b 0d 04 	divu	r4,r12,r11
8000c66a:	f4 0c 16 10 	lsr	r12,r10,0x10
8000c66e:	08 91       	mov	r1,r4
8000c670:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000c674:	e8 0e 02 46 	mul	r6,r4,lr
8000c678:	0c 3c       	cp.w	r12,r6
8000c67a:	c0 a2       	brcc	8000c68e <__avr32_umod64+0x19a>
8000c67c:	20 11       	sub	r1,1
8000c67e:	10 0c       	add	r12,r8
8000c680:	10 3c       	cp.w	r12,r8
8000c682:	c0 63       	brcs	8000c68e <__avr32_umod64+0x19a>
8000c684:	0c 3c       	cp.w	r12,r6
8000c686:	f7 b1 03 01 	sublo	r1,1
8000c68a:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c68e:	0c 1c       	sub	r12,r6
8000c690:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c694:	f8 0b 0d 04 	divu	r4,r12,r11
8000c698:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c69c:	08 96       	mov	r6,r4
8000c69e:	e8 0e 02 4e 	mul	lr,r4,lr
8000c6a2:	1c 3b       	cp.w	r11,lr
8000c6a4:	c0 a2       	brcc	8000c6b8 <__avr32_umod64+0x1c4>
8000c6a6:	20 16       	sub	r6,1
8000c6a8:	10 0b       	add	r11,r8
8000c6aa:	10 3b       	cp.w	r11,r8
8000c6ac:	c0 63       	brcs	8000c6b8 <__avr32_umod64+0x1c4>
8000c6ae:	1c 3b       	cp.w	r11,lr
8000c6b0:	f7 b6 03 01 	sublo	r6,1
8000c6b4:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c6b8:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c6bc:	1c 1b       	sub	r11,lr
8000c6be:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c6c2:	00 9e       	mov	lr,r0
8000c6c4:	02 9c       	mov	r12,r1
8000c6c6:	16 3c       	cp.w	r12,r11
8000c6c8:	e0 8b 00 08 	brhi	8000c6d8 <__avr32_umod64+0x1e4>
8000c6cc:	5f 06       	sreq	r6
8000c6ce:	06 30       	cp.w	r0,r3
8000c6d0:	5f ba       	srhi	r10
8000c6d2:	ed ea 00 0a 	and	r10,r6,r10
8000c6d6:	c0 60       	breq	8000c6e2 <__avr32_umod64+0x1ee>
8000c6d8:	fc 02 01 04 	sub	r4,lr,r2
8000c6dc:	f8 08 01 4c 	sbc	r12,r12,r8
8000c6e0:	08 9e       	mov	lr,r4
8000c6e2:	e6 0e 01 0a 	sub	r10,r3,lr
8000c6e6:	f6 0c 01 4c 	sbc	r12,r11,r12
8000c6ea:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000c6ee:	f8 09 0a 4b 	lsr	r11,r12,r9
8000c6f2:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c6f6:	f8 01 09 4c 	lsl	r12,r12,r1
8000c6fa:	18 4a       	or	r10,r12
8000c6fc:	2f dd       	sub	sp,-12
8000c6fe:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000c800 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000c800:	c0 08       	rjmp	8000c800 <_evba>
	...

8000c804 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000c804:	c0 08       	rjmp	8000c804 <_handle_TLB_Multiple_Hit>
	...

8000c808 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000c808:	c0 08       	rjmp	8000c808 <_handle_Bus_Error_Data_Fetch>
	...

8000c80c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000c80c:	c0 08       	rjmp	8000c80c <_handle_Bus_Error_Instruction_Fetch>
	...

8000c810 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000c810:	c0 08       	rjmp	8000c810 <_handle_NMI>
	...

8000c814 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000c814:	c0 08       	rjmp	8000c814 <_handle_Instruction_Address>
	...

8000c818 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000c818:	c0 08       	rjmp	8000c818 <_handle_ITLB_Protection>
	...

8000c81c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000c81c:	c0 08       	rjmp	8000c81c <_handle_Breakpoint>
	...

8000c820 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000c820:	c0 08       	rjmp	8000c820 <_handle_Illegal_Opcode>
	...

8000c824 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000c824:	c0 08       	rjmp	8000c824 <_handle_Unimplemented_Instruction>
	...

8000c828 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000c828:	c0 08       	rjmp	8000c828 <_handle_Privilege_Violation>
	...

8000c82c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000c82c:	c0 08       	rjmp	8000c82c <_handle_Floating_Point>
	...

8000c830 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000c830:	c0 08       	rjmp	8000c830 <_handle_Coprocessor_Absent>
	...

8000c834 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000c834:	c0 08       	rjmp	8000c834 <_handle_Data_Address_Read>
	...

8000c838 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000c838:	c0 08       	rjmp	8000c838 <_handle_Data_Address_Write>
	...

8000c83c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000c83c:	c0 08       	rjmp	8000c83c <_handle_DTLB_Protection_Read>
	...

8000c840 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000c840:	c0 08       	rjmp	8000c840 <_handle_DTLB_Protection_Write>
	...

8000c844 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000c844:	c0 08       	rjmp	8000c844 <_handle_DTLB_Modified>
	...

8000c850 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000c850:	c0 08       	rjmp	8000c850 <_handle_ITLB_Miss>
	...

8000c860 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000c860:	c0 08       	rjmp	8000c860 <_handle_DTLB_Miss_Read>
	...

8000c870 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000c870:	c0 08       	rjmp	8000c870 <_handle_DTLB_Miss_Write>
	...

8000c900 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000c900:	fe cf 70 10 	sub	pc,pc,28688

8000c904 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000c904:	30 0c       	mov	r12,0
8000c906:	fe b0 c3 bd 	rcall	80005080 <_get_interrupt_handler>
8000c90a:	58 0c       	cp.w	r12,0
8000c90c:	f8 0f 17 10 	movne	pc,r12
8000c910:	d6 03       	rete

8000c912 <_int1>:
8000c912:	30 1c       	mov	r12,1
8000c914:	fe b0 c3 b6 	rcall	80005080 <_get_interrupt_handler>
8000c918:	58 0c       	cp.w	r12,0
8000c91a:	f8 0f 17 10 	movne	pc,r12
8000c91e:	d6 03       	rete

8000c920 <_int2>:
8000c920:	30 2c       	mov	r12,2
8000c922:	fe b0 c3 af 	rcall	80005080 <_get_interrupt_handler>
8000c926:	58 0c       	cp.w	r12,0
8000c928:	f8 0f 17 10 	movne	pc,r12
8000c92c:	d6 03       	rete

8000c92e <_int3>:
8000c92e:	30 3c       	mov	r12,3
8000c930:	fe b0 c3 a8 	rcall	80005080 <_get_interrupt_handler>
8000c934:	58 0c       	cp.w	r12,0
8000c936:	f8 0f 17 10 	movne	pc,r12
8000c93a:	d6 03       	rete

8000c93c <ipr_val>:
8000c93c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000c94c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c95c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c96c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c97c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c98c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c99c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9fc:	d7 03 d7 03                                         ....
