
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000acdc  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000ce00  8000ce00  0000d200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000012a0  8000d000  8000d000  0000d400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a3c  00000004  8000e2a0  0000e804  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00004980  00000a40  8000ecdc  0000f240  2**2
                  ALLOC
  7 .comment      00000030  00000000  00000000  0000f240  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00001720  00000000  00000000  0000f270  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 0000371f  00000000  00000000  00010990  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0002dc0b  00000000  00000000  000140af  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 000076e9  00000000  00000000  00041cba  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000d8a3  00000000  00000000  000493a3  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00003e68  00000000  00000000  00056c48  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00008072  00000000  00000000  0005aab0  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0000f756  00000000  00000000  00062b22  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 17 .debug_ranges 000017f0  00000000  00000000  00072278  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c3 8c 	sub	pc,pc,-15476

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d 8c       	ld.ub	r12,r6[0x0]

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 5c       	eor	r12,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384//1024//800//384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 04       	add	r4,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	3e b8       	mov	r8,-21
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 90       	sub	r0,9
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	20 a4       	sub	r4,10
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	2b 54       	sub	r4,-75
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	d0 00       	acall	0x0
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	27 0c       	sub	r12,112
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	6c 0c       	ld.w	r12,r6[0x0]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 4c       	or	r12,r5

80002090 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002090:	d4 01       	pushm	lr
  log("R");
80002092:	48 3c       	lddpc	r12,8000209c <app_payload_tx_proc+0xc>
80002094:	f0 1f 00 03 	mcall	800020a0 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002098:	d8 02       	popm	pc
8000209a:	00 00       	add	r0,r0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	d0 08       	*unknown*
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	6f d0       	ld.w	r0,r7[0x74]

800020a4 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
800020a4:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
800020a6:	48 99       	lddpc	r9,800020c8 <app_payload_rx_proc+0x24>
800020a8:	13 88       	ld.ub	r8,r9[0x0]
800020aa:	2f f8       	sub	r8,-1
800020ac:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
800020ae:	30 39       	mov	r9,3
800020b0:	f2 08 18 00 	cp.b	r8,r9
800020b4:	c0 71       	brne	800020c2 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
800020b6:	30 09       	mov	r9,0
800020b8:	48 48       	lddpc	r8,800020c8 <app_payload_rx_proc+0x24>
800020ba:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800020bc:	48 4c       	lddpc	r12,800020cc <app_payload_rx_proc+0x28>
800020be:	f0 1f 00 05 	mcall	800020d0 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
800020c2:	48 58       	lddpc	r8,800020d4 <app_payload_rx_proc+0x30>
800020c4:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
800020c6:	d8 02       	popm	pc
800020c8:	00 00       	add	r0,r0
800020ca:	0a 57       	eor	r7,r5
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	d0 0c       	*unknown*
800020d0:	80 00       	ld.sh	r0,r0[0x0]
800020d2:	6f d0       	ld.w	r0,r7[0x74]
800020d4:	00 00       	add	r0,r0
800020d6:	0a 50       	eor	r0,r5

800020d8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020da:	48 3c       	lddpc	r12,800020e4 <FD_brdcst_func+0xc>
800020dc:	f0 1f 00 03 	mcall	800020e8 <FD_brdcst_func+0x10>
	
}
800020e0:	d8 02       	popm	pc
800020e2:	00 00       	add	r0,r0
800020e4:	80 00       	ld.sh	r0,r0[0x0]
800020e6:	d0 18       	*unknown*
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	6f d0       	ld.w	r0,r7[0x74]

800020ec <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020ec:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ee:	48 3c       	lddpc	r12,800020f8 <FD_reply_func+0xc>
800020f0:	f0 1f 00 03 	mcall	800020fc <FD_reply_func+0x10>
	
	
}
800020f4:	d8 02       	popm	pc
800020f6:	00 00       	add	r0,r0
800020f8:	80 00       	ld.sh	r0,r0[0x0]
800020fa:	d0 38       	*unknown*
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	6f d0       	ld.w	r0,r7[0x74]

80002100 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002100:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002102:	48 3c       	lddpc	r12,8000210c <FD_request_func+0xc>
80002104:	f0 1f 00 03 	mcall	80002110 <FD_request_func+0x10>
	
	
}
80002108:	d8 02       	popm	pc
8000210a:	00 00       	add	r0,r0
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	d0 54       	*unknown*
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	6f d0       	ld.w	r0,r7[0x74]

80002114 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002114:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002116:	48 3c       	lddpc	r12,80002120 <EnOB_brdcst_func+0xc>
80002118:	f0 1f 00 03 	mcall	80002124 <EnOB_brdcst_func+0x10>
}
8000211c:	d8 02       	popm	pc
8000211e:	00 00       	add	r0,r0
80002120:	80 00       	ld.sh	r0,r0[0x0]
80002122:	d0 70       	acall	0x7
80002124:	80 00       	ld.sh	r0,r0[0x0]
80002126:	6f d0       	ld.w	r0,r7[0x74]

80002128 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002128:	eb cd 40 80 	pushm	r7,lr
8000212c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000212e:	19 a9       	ld.ub	r9,r12[0x2]
80002130:	30 08       	mov	r8,0
80002132:	f0 09 18 00 	cp.b	r9,r8
80002136:	c1 91       	brne	80002168 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002138:	19 b8       	ld.ub	r8,r12[0x3]
8000213a:	30 19       	mov	r9,1
8000213c:	f2 08 18 00 	cp.b	r8,r9
80002140:	c0 61       	brne	8000214c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002142:	49 0c       	lddpc	r12,80002180 <EnOB_reply_func+0x58>
80002144:	f0 1f 00 10 	mcall	80002184 <EnOB_reply_func+0x5c>
80002148:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000214c:	58 08       	cp.w	r8,0
8000214e:	c0 61       	brne	8000215a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002150:	48 ec       	lddpc	r12,80002188 <EnOB_reply_func+0x60>
80002152:	f0 1f 00 0d 	mcall	80002184 <EnOB_reply_func+0x5c>
80002156:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000215a:	1a d8       	st.w	--sp,r8
8000215c:	48 cc       	lddpc	r12,8000218c <EnOB_reply_func+0x64>
8000215e:	f0 1f 00 0a 	mcall	80002184 <EnOB_reply_func+0x5c>
80002162:	2f fd       	sub	sp,-4
80002164:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002168:	48 ac       	lddpc	r12,80002190 <EnOB_reply_func+0x68>
8000216a:	f0 1f 00 07 	mcall	80002184 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000216e:	0f a8       	ld.ub	r8,r7[0x2]
80002170:	1a d8       	st.w	--sp,r8
80002172:	48 9c       	lddpc	r12,80002194 <EnOB_reply_func+0x6c>
80002174:	f0 1f 00 04 	mcall	80002184 <EnOB_reply_func+0x5c>
80002178:	2f fd       	sub	sp,-4
8000217a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	d0 88       	*unknown*
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	6f d0       	ld.w	r0,r7[0x74]
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	d0 a0       	acall	0xa
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	d0 b4       	*unknown*
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	d0 cc       	*unknown*
80002194:	80 00       	ld.sh	r0,r0[0x0]
80002196:	d0 e8       	*unknown*

80002198 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002198:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
8000219a:	19 a9       	ld.ub	r9,r12[0x2]
8000219c:	31 18       	mov	r8,17
8000219e:	f0 09 18 00 	cp.b	r9,r8
800021a2:	c0 41       	brne	800021aa <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021a4:	48 2c       	lddpc	r12,800021ac <SingleDetection_brdcst_func+0x14>
800021a6:	f0 1f 00 03 	mcall	800021b0 <SingleDetection_brdcst_func+0x18>
800021aa:	d8 02       	popm	pc
800021ac:	80 00       	ld.sh	r0,r0[0x0]
800021ae:	d1 00       	acall	0x10
800021b0:	80 00       	ld.sh	r0,r0[0x0]
800021b2:	6f d0       	ld.w	r0,r7[0x74]

800021b4 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021b4:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021b6:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021ba:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021bc:	4a bc       	lddpc	r12,80002268 <ButtonConfig_brdcst_func+0xb4>
800021be:	f0 1f 00 2c 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021c2:	0f 88       	ld.ub	r8,r7[0x0]
800021c4:	1a d8       	st.w	--sp,r8
800021c6:	4a bc       	lddpc	r12,80002270 <ButtonConfig_brdcst_func+0xbc>
800021c8:	f0 1f 00 29 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021cc:	1a d5       	st.w	--sp,r5
800021ce:	4a ac       	lddpc	r12,80002274 <ButtonConfig_brdcst_func+0xc0>
800021d0:	f0 1f 00 27 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021d4:	0f a8       	ld.ub	r8,r7[0x2]
800021d6:	1a d8       	st.w	--sp,r8
800021d8:	4a 8c       	lddpc	r12,80002278 <ButtonConfig_brdcst_func+0xc4>
800021da:	f0 1f 00 25 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021de:	2f dd       	sub	sp,-12
800021e0:	58 05       	cp.w	r5,0
800021e2:	c4 10       	breq	80002264 <ButtonConfig_brdcst_func+0xb0>
800021e4:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021e6:	4a 64       	lddpc	r4,8000227c <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021e8:	4a 63       	lddpc	r3,80002280 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021ea:	4a 72       	lddpc	r2,80002284 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021ec:	4a 71       	lddpc	r1,80002288 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021ee:	4a 80       	lddpc	r0,8000228c <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021f0:	0f b9       	ld.ub	r9,r7[0x3]
800021f2:	0f c8       	ld.ub	r8,r7[0x4]
800021f4:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021f8:	1a d8       	st.w	--sp,r8
800021fa:	1a d6       	st.w	--sp,r6
800021fc:	08 9c       	mov	r12,r4
800021fe:	f0 1f 00 1c 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002202:	0f d9       	ld.ub	r9,r7[0x5]
80002204:	0f e8       	ld.ub	r8,r7[0x6]
80002206:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000220a:	1a d8       	st.w	--sp,r8
8000220c:	1a d6       	st.w	--sp,r6
8000220e:	06 9c       	mov	r12,r3
80002210:	f0 1f 00 17 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002214:	0f f9       	ld.ub	r9,r7[0x7]
80002216:	ef 38 00 08 	ld.ub	r8,r7[8]
8000221a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000221e:	1a d8       	st.w	--sp,r8
80002220:	1a d6       	st.w	--sp,r6
80002222:	04 9c       	mov	r12,r2
80002224:	f0 1f 00 12 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002228:	ef 39 00 09 	ld.ub	r9,r7[9]
8000222c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002230:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002234:	1a d8       	st.w	--sp,r8
80002236:	1a d6       	st.w	--sp,r6
80002238:	02 9c       	mov	r12,r1
8000223a:	f0 1f 00 0d 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000223e:	2f 8d       	sub	sp,-32
80002240:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002244:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002248:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000224c:	1a d8       	st.w	--sp,r8
8000224e:	1a d6       	st.w	--sp,r6
80002250:	00 9c       	mov	r12,r0
80002252:	f0 1f 00 07 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
80002256:	2f f6       	sub	r6,-1
80002258:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000225a:	2f ed       	sub	sp,-8
8000225c:	ec 05 18 00 	cp.b	r5,r6
80002260:	fe 9b ff c8 	brhi	800021f0 <ButtonConfig_brdcst_func+0x3c>
80002264:	d8 32       	popm	r0-r7,pc
80002266:	00 00       	add	r0,r0
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	d1 14       	*unknown*
8000226c:	80 00       	ld.sh	r0,r0[0x0]
8000226e:	6f d0       	ld.w	r0,r7[0x74]
80002270:	80 00       	ld.sh	r0,r0[0x0]
80002272:	d1 34       	*unknown*
80002274:	80 00       	ld.sh	r0,r0[0x0]
80002276:	d1 48       	*unknown*
80002278:	80 00       	ld.sh	r0,r0[0x0]
8000227a:	d1 60       	acall	0x16
8000227c:	80 00       	ld.sh	r0,r0[0x0]
8000227e:	d1 80       	acall	0x18
80002280:	80 00       	ld.sh	r0,r0[0x0]
80002282:	d1 a8       	*unknown*
80002284:	80 00       	ld.sh	r0,r0[0x0]
80002286:	d1 d0       	acall	0x1d
80002288:	80 00       	ld.sh	r0,r0[0x0]
8000228a:	d1 f4       	*unknown*
8000228c:	80 00       	ld.sh	r0,r0[0x0]
8000228e:	d2 1c       	*unknown*

80002290 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002290:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002294:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002298:	0f 89       	ld.ub	r9,r7[0x0]
8000229a:	30 08       	mov	r8,0
8000229c:	f0 09 18 00 	cp.b	r9,r8
800022a0:	c0 c1       	brne	800022b8 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022a2:	48 9c       	lddpc	r12,800022c4 <ButtonConfig_reply_func+0x34>
800022a4:	f0 1f 00 09 	mcall	800022c8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022a8:	0f 98       	ld.ub	r8,r7[0x1]
800022aa:	1a d8       	st.w	--sp,r8
800022ac:	48 8c       	lddpc	r12,800022cc <ButtonConfig_reply_func+0x3c>
800022ae:	f0 1f 00 07 	mcall	800022c8 <ButtonConfig_reply_func+0x38>
800022b2:	2f fd       	sub	sp,-4
800022b4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022b8:	48 6c       	lddpc	r12,800022d0 <ButtonConfig_reply_func+0x40>
800022ba:	f0 1f 00 04 	mcall	800022c8 <ButtonConfig_reply_func+0x38>
800022be:	e3 cd 80 80 	ldm	sp++,r7,pc
800022c2:	00 00       	add	r0,r0
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	d2 40       	acall	0x24
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	6f d0       	ld.w	r0,r7[0x74]
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	d1 34       	*unknown*
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	d2 58       	*unknown*

800022d4 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
800022d4:	eb cd 40 80 	pushm	r7,lr
800022d8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800022da:	19 a9       	ld.ub	r9,r12[0x2]
800022dc:	30 08       	mov	r8,0
800022de:	f0 09 18 00 	cp.b	r9,r8
800022e2:	c1 11       	brne	80002304 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
800022e4:	49 3c       	lddpc	r12,80002330 <DataSession_reply_func+0x5c>
800022e6:	f0 1f 00 14 	mcall	80002334 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
800022ea:	0f b8       	ld.ub	r8,r7[0x3]
800022ec:	1a d8       	st.w	--sp,r8
800022ee:	49 3c       	lddpc	r12,80002338 <DataSession_reply_func+0x64>
800022f0:	f0 1f 00 11 	mcall	80002334 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
800022f4:	0f c8       	ld.ub	r8,r7[0x4]
800022f6:	1a d8       	st.w	--sp,r8
800022f8:	49 1c       	lddpc	r12,8000233c <DataSession_reply_func+0x68>
800022fa:	f0 1f 00 0f 	mcall	80002334 <DataSession_reply_func+0x60>
800022fe:	2f ed       	sub	sp,-8
80002300:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
80002304:	48 fc       	lddpc	r12,80002340 <DataSession_reply_func+0x6c>
80002306:	f0 1f 00 0c 	mcall	80002334 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
8000230a:	0f a8       	ld.ub	r8,r7[0x2]
8000230c:	1a d8       	st.w	--sp,r8
8000230e:	48 ec       	lddpc	r12,80002344 <DataSession_reply_func+0x70>
80002310:	f0 1f 00 09 	mcall	80002334 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
80002314:	0f b8       	ld.ub	r8,r7[0x3]
80002316:	1a d8       	st.w	--sp,r8
80002318:	48 cc       	lddpc	r12,80002348 <DataSession_reply_func+0x74>
8000231a:	f0 1f 00 07 	mcall	80002334 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
8000231e:	0f c8       	ld.ub	r8,r7[0x4]
80002320:	1a d8       	st.w	--sp,r8
80002322:	48 bc       	lddpc	r12,8000234c <DataSession_reply_func+0x78>
80002324:	f0 1f 00 04 	mcall	80002334 <DataSession_reply_func+0x60>
80002328:	2f dd       	sub	sp,-12
8000232a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000232e:	00 00       	add	r0,r0
80002330:	80 00       	ld.sh	r0,r0[0x0]
80002332:	d2 74       	*unknown*
80002334:	80 00       	ld.sh	r0,r0[0x0]
80002336:	6f d0       	ld.w	r0,r7[0x74]
80002338:	80 00       	ld.sh	r0,r0[0x0]
8000233a:	d2 84       	*unknown*
8000233c:	80 00       	ld.sh	r0,r0[0x0]
8000233e:	d2 90       	acall	0x29
80002340:	80 00       	ld.sh	r0,r0[0x0]
80002342:	d2 9c       	*unknown*
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	d2 ac       	*unknown*
80002348:	80 00       	ld.sh	r0,r0[0x0]
8000234a:	d2 bc       	*unknown*
8000234c:	80 00       	ld.sh	r0,r0[0x0]
8000234e:	d2 c8       	*unknown*

80002350 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002350:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002354:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002358:	0f 98       	ld.ub	r8,r7[0x1]
8000235a:	1a d8       	st.w	--sp,r8
8000235c:	48 bc       	lddpc	r12,80002388 <CallControl_brdcst_func+0x38>
8000235e:	f0 1f 00 0c 	mcall	8000238c <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
80002362:	2f fd       	sub	sp,-4
80002364:	0f 99       	ld.ub	r9,r7[0x1]
80002366:	30 38       	mov	r8,3
80002368:	f0 09 18 00 	cp.b	r9,r8
8000236c:	c0 41       	brne	80002374 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
8000236e:	30 09       	mov	r9,0
80002370:	48 88       	lddpc	r8,80002390 <CallControl_brdcst_func+0x40>
80002372:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
80002374:	0f 99       	ld.ub	r9,r7[0x1]
80002376:	30 48       	mov	r8,4
80002378:	f0 09 18 00 	cp.b	r9,r8
8000237c:	c0 41       	brne	80002384 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
8000237e:	30 19       	mov	r9,1
80002380:	48 48       	lddpc	r8,80002390 <CallControl_brdcst_func+0x40>
80002382:	b0 89       	st.b	r8[0x0],r9
80002384:	e3 cd 80 80 	ldm	sp++,r7,pc
80002388:	80 00       	ld.sh	r0,r0[0x0]
8000238a:	d2 d4       	*unknown*
8000238c:	80 00       	ld.sh	r0,r0[0x0]
8000238e:	6f d0       	ld.w	r0,r7[0x74]
80002390:	00 00       	add	r0,r0
80002392:	0a 52       	eor	r2,r5

80002394 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002394:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002398:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
8000239c:	0f 99       	ld.ub	r9,r7[0x1]
8000239e:	30 08       	mov	r8,0
800023a0:	f0 09 18 00 	cp.b	r9,r8
800023a4:	c0 71       	brne	800023b2 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800023a6:	48 ac       	lddpc	r12,800023cc <TransmitControl_brdcst_func+0x38>
800023a8:	f0 1f 00 0a 	mcall	800023d0 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800023ac:	30 09       	mov	r9,0
800023ae:	48 a8       	lddpc	r8,800023d4 <TransmitControl_brdcst_func+0x40>
800023b0:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800023b2:	0f 99       	ld.ub	r9,r7[0x1]
800023b4:	30 18       	mov	r8,1
800023b6:	f0 09 18 00 	cp.b	r9,r8
800023ba:	c0 71       	brne	800023c8 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800023bc:	48 7c       	lddpc	r12,800023d8 <TransmitControl_brdcst_func+0x44>
800023be:	f0 1f 00 05 	mcall	800023d0 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800023c2:	30 19       	mov	r9,1
800023c4:	48 48       	lddpc	r8,800023d4 <TransmitControl_brdcst_func+0x40>
800023c6:	b0 89       	st.b	r8[0x0],r9
800023c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800023cc:	80 00       	ld.sh	r0,r0[0x0]
800023ce:	d2 ec       	*unknown*
800023d0:	80 00       	ld.sh	r0,r0[0x0]
800023d2:	6f d0       	ld.w	r0,r7[0x74]
800023d4:	00 00       	add	r0,r0
800023d6:	0a 51       	eor	r1,r5
800023d8:	80 00       	ld.sh	r0,r0[0x0]
800023da:	d3 04       	*unknown*

800023dc <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
800023dc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
800023e0:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
800023e4:	0f 89       	ld.ub	r9,r7[0x0]
800023e6:	30 08       	mov	r8,0
800023e8:	f0 09 18 00 	cp.b	r9,r8
800023ec:	c1 61       	brne	80002418 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
800023ee:	48 ec       	lddpc	r12,80002424 <TransmitControl_reply_func+0x48>
800023f0:	f0 1f 00 0e 	mcall	80002428 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
800023f4:	0f 98       	ld.ub	r8,r7[0x1]
800023f6:	1a d8       	st.w	--sp,r8
800023f8:	48 dc       	lddpc	r12,8000242c <TransmitControl_reply_func+0x50>
800023fa:	f0 1f 00 0c 	mcall	80002428 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
800023fe:	0f a8       	ld.ub	r8,r7[0x2]
80002400:	1a d8       	st.w	--sp,r8
80002402:	48 cc       	lddpc	r12,80002430 <TransmitControl_reply_func+0x54>
80002404:	f0 1f 00 09 	mcall	80002428 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002408:	0f b8       	ld.ub	r8,r7[0x3]
8000240a:	1a d8       	st.w	--sp,r8
8000240c:	48 ac       	lddpc	r12,80002434 <TransmitControl_reply_func+0x58>
8000240e:	f0 1f 00 07 	mcall	80002428 <TransmitControl_reply_func+0x4c>
80002412:	2f dd       	sub	sp,-12
80002414:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002418:	48 8c       	lddpc	r12,80002438 <TransmitControl_reply_func+0x5c>
8000241a:	f0 1f 00 04 	mcall	80002428 <TransmitControl_reply_func+0x4c>
8000241e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002422:	00 00       	add	r0,r0
80002424:	80 00       	ld.sh	r0,r0[0x0]
80002426:	d3 18       	*unknown*
80002428:	80 00       	ld.sh	r0,r0[0x0]
8000242a:	6f d0       	ld.w	r0,r7[0x74]
8000242c:	80 00       	ld.sh	r0,r0[0x0]
8000242e:	d3 34       	*unknown*
80002430:	80 00       	ld.sh	r0,r0[0x0]
80002432:	d3 48       	*unknown*
80002434:	80 00       	ld.sh	r0,r0[0x0]
80002436:	d3 64       	*unknown*
80002438:	80 00       	ld.sh	r0,r0[0x0]
8000243a:	d3 74       	*unknown*

8000243c <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
8000243c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000243e:	19 a9       	ld.ub	r9,r12[0x2]
80002440:	30 08       	mov	r8,0
80002442:	f0 09 18 00 	cp.b	r9,r8
80002446:	c0 51       	brne	80002450 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002448:	48 4c       	lddpc	r12,80002458 <AudioRoutingControl_reply_func+0x1c>
8000244a:	f0 1f 00 05 	mcall	8000245c <AudioRoutingControl_reply_func+0x20>
8000244e:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002450:	48 4c       	lddpc	r12,80002460 <AudioRoutingControl_reply_func+0x24>
80002452:	f0 1f 00 03 	mcall	8000245c <AudioRoutingControl_reply_func+0x20>
80002456:	d8 02       	popm	pc
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	d3 8c       	*unknown*
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	6f d0       	ld.w	r0,r7[0x74]
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	d3 9c       	*unknown*

80002464 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002464:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002468:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000246c:	0f 89       	ld.ub	r9,r7[0x0]
8000246e:	30 08       	mov	r8,0
80002470:	f0 09 18 00 	cp.b	r9,r8
80002474:	c1 b1       	brne	800024aa <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002476:	0f b8       	ld.ub	r8,r7[0x3]
80002478:	31 09       	mov	r9,16
8000247a:	f2 08 18 00 	cp.b	r8,r9
8000247e:	c0 f1       	brne	8000249c <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002480:	48 dc       	lddpc	r12,800024b4 <Volume_reply_func+0x50>
80002482:	f0 1f 00 0e 	mcall	800024b8 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002486:	0f 99       	ld.ub	r9,r7[0x1]
80002488:	0f a8       	ld.ub	r8,r7[0x2]
8000248a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000248e:	1a d8       	st.w	--sp,r8
80002490:	48 bc       	lddpc	r12,800024bc <Volume_reply_func+0x58>
80002492:	f0 1f 00 0a 	mcall	800024b8 <Volume_reply_func+0x54>
80002496:	2f fd       	sub	sp,-4
80002498:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
8000249c:	1a d8       	st.w	--sp,r8
8000249e:	48 9c       	lddpc	r12,800024c0 <Volume_reply_func+0x5c>
800024a0:	f0 1f 00 06 	mcall	800024b8 <Volume_reply_func+0x54>
800024a4:	2f fd       	sub	sp,-4
800024a6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024aa:	48 7c       	lddpc	r12,800024c4 <Volume_reply_func+0x60>
800024ac:	f0 1f 00 03 	mcall	800024b8 <Volume_reply_func+0x54>
800024b0:	e3 cd 80 80 	ldm	sp++,r7,pc
800024b4:	80 00       	ld.sh	r0,r0[0x0]
800024b6:	d3 b0       	acall	0x3b
800024b8:	80 00       	ld.sh	r0,r0[0x0]
800024ba:	6f d0       	ld.w	r0,r7[0x74]
800024bc:	80 00       	ld.sh	r0,r0[0x0]
800024be:	d3 c4       	*unknown*
800024c0:	80 00       	ld.sh	r0,r0[0x0]
800024c2:	d3 e0       	acall	0x3e
800024c4:	80 00       	ld.sh	r0,r0[0x0]
800024c6:	d3 f8       	*unknown*

800024c8 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800024c8:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800024ca:	19 d9       	ld.ub	r9,r12[0x5]
800024cc:	30 08       	mov	r8,0
800024ce:	f0 09 18 00 	cp.b	r9,r8
800024d2:	c0 81       	brne	800024e2 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
800024d4:	10 99       	mov	r9,r8
800024d6:	48 78       	lddpc	r8,800024f0 <spk_brdcst_func+0x28>
800024d8:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
800024da:	48 7c       	lddpc	r12,800024f4 <spk_brdcst_func+0x2c>
800024dc:	f0 1f 00 07 	mcall	800024f8 <spk_brdcst_func+0x30>
800024e0:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
800024e2:	30 19       	mov	r9,1
800024e4:	48 38       	lddpc	r8,800024f0 <spk_brdcst_func+0x28>
800024e6:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
800024e8:	48 5c       	lddpc	r12,800024fc <spk_brdcst_func+0x34>
800024ea:	f0 1f 00 04 	mcall	800024f8 <spk_brdcst_func+0x30>
800024ee:	d8 02       	popm	pc
800024f0:	00 00       	add	r0,r0
800024f2:	0a 40       	or	r0,r5
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	d4 10       	acall	0x41
800024f8:	80 00       	ld.sh	r0,r0[0x0]
800024fa:	6f d0       	ld.w	r0,r7[0x74]
800024fc:	80 00       	ld.sh	r0,r0[0x0]
800024fe:	d4 20       	acall	0x42

80002500 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002500:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002502:	19 a9       	ld.ub	r9,r12[0x2]
80002504:	30 08       	mov	r8,0
80002506:	f0 09 18 00 	cp.b	r9,r8
8000250a:	c0 f1       	brne	80002528 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
8000250c:	19 e9       	ld.ub	r9,r12[0x6]
8000250e:	f0 09 18 00 	cp.b	r9,r8
80002512:	c0 40       	breq	8000251a <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002514:	30 19       	mov	r9,1
80002516:	48 98       	lddpc	r8,80002538 <spk_reply_func+0x38>
80002518:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000251a:	19 e8       	ld.ub	r8,r12[0x6]
8000251c:	1a d8       	st.w	--sp,r8
8000251e:	48 8c       	lddpc	r12,8000253c <spk_reply_func+0x3c>
80002520:	f0 1f 00 08 	mcall	80002540 <spk_reply_func+0x40>
80002524:	2f fd       	sub	sp,-4
80002526:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002528:	30 09       	mov	r9,0
8000252a:	48 48       	lddpc	r8,80002538 <spk_reply_func+0x38>
8000252c:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000252e:	48 6c       	lddpc	r12,80002544 <spk_reply_func+0x44>
80002530:	f0 1f 00 04 	mcall	80002540 <spk_reply_func+0x40>
80002534:	d8 02       	popm	pc
80002536:	00 00       	add	r0,r0
80002538:	00 00       	add	r0,r0
8000253a:	0a 40       	or	r0,r5
8000253c:	80 00       	ld.sh	r0,r0[0x0]
8000253e:	d4 2c       	*unknown*
80002540:	80 00       	ld.sh	r0,r0[0x0]
80002542:	6f d0       	ld.w	r0,r7[0x74]
80002544:	80 00       	ld.sh	r0,r0[0x0]
80002546:	d4 3c       	*unknown*

80002548 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002548:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
8000254c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002550:	0f a9       	ld.ub	r9,r7[0x2]
80002552:	30 08       	mov	r8,0
80002554:	f0 09 18 00 	cp.b	r9,r8
80002558:	c0 71       	brne	80002566 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000255a:	48 dc       	lddpc	r12,8000258c <mic_brdcst_func+0x44>
8000255c:	f0 1f 00 0d 	mcall	80002590 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002560:	30 09       	mov	r9,0
80002562:	48 d8       	lddpc	r8,80002594 <mic_brdcst_func+0x4c>
80002564:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002566:	0f a9       	ld.ub	r9,r7[0x2]
80002568:	31 18       	mov	r8,17
8000256a:	f0 09 18 00 	cp.b	r9,r8
8000256e:	c0 d1       	brne	80002588 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
80002570:	48 ac       	lddpc	r12,80002598 <mic_brdcst_func+0x50>
80002572:	f0 1f 00 08 	mcall	80002590 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
80002576:	48 89       	lddpc	r9,80002594 <mic_brdcst_func+0x4c>
80002578:	30 18       	mov	r8,1
8000257a:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
8000257c:	13 89       	ld.ub	r9,r9[0x0]
8000257e:	f0 09 18 00 	cp.b	r9,r8
80002582:	c0 31       	brne	80002588 <mic_brdcst_func+0x40>
80002584:	48 68       	lddpc	r8,8000259c <mic_brdcst_func+0x54>
80002586:	11 88       	ld.ub	r8,r8[0x0]
80002588:	e3 cd 80 80 	ldm	sp++,r7,pc
8000258c:	80 00       	ld.sh	r0,r0[0x0]
8000258e:	d4 48       	*unknown*
80002590:	80 00       	ld.sh	r0,r0[0x0]
80002592:	6f d0       	ld.w	r0,r7[0x74]
80002594:	00 00       	add	r0,r0
80002596:	0a 56       	eor	r6,r5
80002598:	80 00       	ld.sh	r0,r0[0x0]
8000259a:	d4 5c       	*unknown*
8000259c:	00 00       	add	r0,r0
8000259e:	0a 52       	eor	r2,r5

800025a0 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025a0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025a4:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025a8:	49 ac       	lddpc	r12,80002610 <mic_reply_func+0x70>
800025aa:	f0 1f 00 1b 	mcall	80002614 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025ae:	0f 89       	ld.ub	r9,r7[0x0]
800025b0:	30 08       	mov	r8,0
800025b2:	f0 09 18 00 	cp.b	r9,r8
800025b6:	c2 71       	brne	80002604 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025b8:	0f 98       	ld.ub	r8,r7[0x1]
800025ba:	30 29       	mov	r9,2
800025bc:	f2 08 18 00 	cp.b	r8,r9
800025c0:	c1 b1       	brne	800025f6 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800025c2:	49 6c       	lddpc	r12,80002618 <mic_reply_func+0x78>
800025c4:	f0 1f 00 14 	mcall	80002614 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800025c8:	0f a8       	ld.ub	r8,r7[0x2]
800025ca:	1a d8       	st.w	--sp,r8
800025cc:	49 4c       	lddpc	r12,8000261c <mic_reply_func+0x7c>
800025ce:	f0 1f 00 12 	mcall	80002614 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
800025d2:	0f b8       	ld.ub	r8,r7[0x3]
800025d4:	1a d8       	st.w	--sp,r8
800025d6:	49 3c       	lddpc	r12,80002620 <mic_reply_func+0x80>
800025d8:	f0 1f 00 0f 	mcall	80002614 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
800025dc:	0f c8       	ld.ub	r8,r7[0x4]
800025de:	1a d8       	st.w	--sp,r8
800025e0:	49 1c       	lddpc	r12,80002624 <mic_reply_func+0x84>
800025e2:	f0 1f 00 0d 	mcall	80002614 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
800025e6:	0f d8       	ld.ub	r8,r7[0x5]
800025e8:	1a d8       	st.w	--sp,r8
800025ea:	49 0c       	lddpc	r12,80002628 <mic_reply_func+0x88>
800025ec:	f0 1f 00 0a 	mcall	80002614 <mic_reply_func+0x74>
800025f0:	2f cd       	sub	sp,-16
800025f2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800025f6:	1a d8       	st.w	--sp,r8
800025f8:	48 dc       	lddpc	r12,8000262c <mic_reply_func+0x8c>
800025fa:	f0 1f 00 07 	mcall	80002614 <mic_reply_func+0x74>
800025fe:	2f fd       	sub	sp,-4
80002600:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002604:	48 bc       	lddpc	r12,80002630 <mic_reply_func+0x90>
80002606:	f0 1f 00 04 	mcall	80002614 <mic_reply_func+0x74>
8000260a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000260e:	00 00       	add	r0,r0
80002610:	80 00       	ld.sh	r0,r0[0x0]
80002612:	d4 70       	acall	0x47
80002614:	80 00       	ld.sh	r0,r0[0x0]
80002616:	6f d0       	ld.w	r0,r7[0x74]
80002618:	80 00       	ld.sh	r0,r0[0x0]
8000261a:	d4 80       	acall	0x48
8000261c:	80 00       	ld.sh	r0,r0[0x0]
8000261e:	d4 94       	*unknown*
80002620:	80 00       	ld.sh	r0,r0[0x0]
80002622:	d4 a8       	*unknown*
80002624:	80 00       	ld.sh	r0,r0[0x0]
80002626:	d4 c4       	*unknown*
80002628:	80 00       	ld.sh	r0,r0[0x0]
8000262a:	d4 dc       	*unknown*
8000262c:	80 00       	ld.sh	r0,r0[0x0]
8000262e:	d4 f4       	*unknown*
80002630:	80 00       	ld.sh	r0,r0[0x0]
80002632:	d5 0c       	*unknown*

80002634 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002634:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002638:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
8000263c:	48 bc       	lddpc	r12,80002668 <dcm_brdcst_func+0x34>
8000263e:	f0 1f 00 0c 	mcall	8000266c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002642:	0f 88       	ld.ub	r8,r7[0x0]
80002644:	1a d8       	st.w	--sp,r8
80002646:	48 bc       	lddpc	r12,80002670 <dcm_brdcst_func+0x3c>
80002648:	f0 1f 00 09 	mcall	8000266c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000264c:	0f a8       	ld.ub	r8,r7[0x2]
8000264e:	1a d8       	st.w	--sp,r8
80002650:	48 9c       	lddpc	r12,80002674 <dcm_brdcst_func+0x40>
80002652:	f0 1f 00 07 	mcall	8000266c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002656:	0f 98       	ld.ub	r8,r7[0x1]
80002658:	1a d8       	st.w	--sp,r8
8000265a:	48 8c       	lddpc	r12,80002678 <dcm_brdcst_func+0x44>
8000265c:	f0 1f 00 04 	mcall	8000266c <dcm_brdcst_func+0x38>
80002660:	2f dd       	sub	sp,-12
	
	
}
80002662:	e3 cd 80 80 	ldm	sp++,r7,pc
80002666:	00 00       	add	r0,r0
80002668:	80 00       	ld.sh	r0,r0[0x0]
8000266a:	d5 1c       	*unknown*
8000266c:	80 00       	ld.sh	r0,r0[0x0]
8000266e:	6f d0       	ld.w	r0,r7[0x74]
80002670:	80 00       	ld.sh	r0,r0[0x0]
80002672:	d5 30       	acall	0x53
80002674:	80 00       	ld.sh	r0,r0[0x0]
80002676:	d5 44       	*unknown*
80002678:	80 00       	ld.sh	r0,r0[0x0]
8000267a:	d5 5c       	*unknown*

8000267c <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
8000267c:	eb cd 40 80 	pushm	r7,lr
80002680:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002682:	19 a9       	ld.ub	r9,r12[0x2]
80002684:	30 08       	mov	r8,0
80002686:	f0 09 18 00 	cp.b	r9,r8
8000268a:	c1 b1       	brne	800026c0 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
8000268c:	19 b8       	ld.ub	r8,r12[0x3]
8000268e:	30 19       	mov	r9,1
80002690:	f2 08 18 00 	cp.b	r8,r9
80002694:	c0 51       	brne	8000269e <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
80002696:	48 ec       	lddpc	r12,800026cc <dcm_reply_func+0x50>
80002698:	f0 1f 00 0e 	mcall	800026d0 <dcm_reply_func+0x54>
8000269c:	c0 a8       	rjmp	800026b0 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
8000269e:	58 08       	cp.w	r8,0
800026a0:	c0 51       	brne	800026aa <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026a2:	48 dc       	lddpc	r12,800026d4 <dcm_reply_func+0x58>
800026a4:	f0 1f 00 0b 	mcall	800026d0 <dcm_reply_func+0x54>
800026a8:	c0 48       	rjmp	800026b0 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026aa:	48 cc       	lddpc	r12,800026d8 <dcm_reply_func+0x5c>
800026ac:	f0 1f 00 09 	mcall	800026d0 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026b0:	0f d8       	ld.ub	r8,r7[0x5]
800026b2:	1a d8       	st.w	--sp,r8
800026b4:	48 ac       	lddpc	r12,800026dc <dcm_reply_func+0x60>
800026b6:	f0 1f 00 07 	mcall	800026d0 <dcm_reply_func+0x54>
800026ba:	2f fd       	sub	sp,-4
800026bc:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800026c0:	48 8c       	lddpc	r12,800026e0 <dcm_reply_func+0x64>
800026c2:	f0 1f 00 04 	mcall	800026d0 <dcm_reply_func+0x54>
800026c6:	e3 cd 80 80 	ldm	sp++,r7,pc
800026ca:	00 00       	add	r0,r0
800026cc:	80 00       	ld.sh	r0,r0[0x0]
800026ce:	d5 78       	*unknown*
800026d0:	80 00       	ld.sh	r0,r0[0x0]
800026d2:	6f d0       	ld.w	r0,r7[0x74]
800026d4:	80 00       	ld.sh	r0,r0[0x0]
800026d6:	d5 8c       	*unknown*
800026d8:	80 00       	ld.sh	r0,r0[0x0]
800026da:	d5 a0       	acall	0x5a
800026dc:	80 00       	ld.sh	r0,r0[0x0]
800026de:	d5 b4       	*unknown*
800026e0:	80 00       	ld.sh	r0,r0[0x0]
800026e2:	d5 c0       	acall	0x5c

800026e4 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800026e4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800026e6:	19 a9       	ld.ub	r9,r12[0x2]
800026e8:	30 08       	mov	r8,0
800026ea:	f0 09 18 00 	cp.b	r9,r8
800026ee:	c0 51       	brne	800026f8 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
800026f0:	48 4c       	lddpc	r12,80002700 <ToneControl_reply_func+0x1c>
800026f2:	f0 1f 00 05 	mcall	80002704 <ToneControl_reply_func+0x20>
800026f6:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800026f8:	48 4c       	lddpc	r12,80002708 <ToneControl_reply_func+0x24>
800026fa:	f0 1f 00 03 	mcall	80002704 <ToneControl_reply_func+0x20>
800026fe:	d8 02       	popm	pc
80002700:	80 00       	ld.sh	r0,r0[0x0]
80002702:	d5 cc       	*unknown*
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	6f d0       	ld.w	r0,r7[0x74]
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	d5 d8       	*unknown*

8000270c <app_cfg>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
8000270c:	d4 31       	pushm	r0-r7,lr
8000270e:	20 1d       	sub	sp,4
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	static const uint8_t test_data[8] = {0x11, 0x23, 0x33, 0x67, 0x89, 0xAB, 0xCD, 0xEF};
	
	 xLastWakeTime = xTaskGetTickCount();
80002710:	f0 1f 00 24 	mcall	800027a0 <app_cfg+0x94>
80002714:	4a 48       	lddpc	r8,800027a4 <app_cfg+0x98>
80002716:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002718:	4a 46       	lddpc	r6,800027a8 <app_cfg+0x9c>
		{	
			connect_flag=1;	
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
			//vTaskResume(save_handle);
		}
		else if(connect_flag)
8000271a:	4a 57       	lddpc	r7,800027ac <app_cfg+0xa0>
		{
				if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
8000271c:	4a 54       	lddpc	r4,800027b0 <app_cfg+0xa4>
8000271e:	30 02       	mov	r2,0
80002720:	e0 65 0f a0 	mov	r5,4000
				{
					if(data_ptr!=NULL){//Resend message
						
						Message_Protocol_t *ptr = (Message_Protocol_t* )data_ptr;
						//xgflash_message_save(data_ptr, sizeof(Message_Protocol_t), TRUE);
						log("receive data : %d", ptr->data.XG_Time.Second);
80002724:	4a 41       	lddpc	r1,800027b4 <app_cfg+0xa8>
						xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);
80002726:	30 90       	mov	r0,9
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002728:	6c 08       	ld.w	r8,r6[0x0]
8000272a:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000272e:	58 38       	cp.w	r8,3
80002730:	c0 b1       	brne	80002746 <app_cfg+0x3a>
80002732:	0f 88       	ld.ub	r8,r7[0x0]
80002734:	58 08       	cp.w	r8,0
80002736:	c0 81       	brne	80002746 <app_cfg+0x3a>
		{	
			connect_flag=1;	
80002738:	30 18       	mov	r8,1
8000273a:	ae 88       	st.b	r7[0x0],r8
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
8000273c:	30 cb       	mov	r11,12
8000273e:	30 1c       	mov	r12,1
80002740:	f0 1f 00 1e 	mcall	800027b8 <app_cfg+0xac>
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002744:	c2 58       	rjmp	8000278e <app_cfg+0x82>
		{	
			connect_flag=1;	
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
			//vTaskResume(save_handle);
		}
		else if(connect_flag)
80002746:	0f 88       	ld.ub	r8,r7[0x0]
80002748:	58 08       	cp.w	r8,0
8000274a:	c1 f0       	breq	80002788 <app_cfg+0x7c>
		{
				if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
8000274c:	68 0c       	ld.w	r12,r4[0x0]
8000274e:	04 99       	mov	r9,r2
80002750:	0a 9a       	mov	r10,r5
80002752:	1a 9b       	mov	r11,sp
80002754:	f0 1f 00 1a 	mcall	800027bc <app_cfg+0xb0>
80002758:	58 1c       	cp.w	r12,1
8000275a:	c1 51       	brne	80002784 <app_cfg+0x78>
				{
					if(data_ptr!=NULL){//Resend message
8000275c:	40 08       	lddsp	r8,sp[0x0]
8000275e:	58 08       	cp.w	r8,0
80002760:	c1 20       	breq	80002784 <app_cfg+0x78>
						
						Message_Protocol_t *ptr = (Message_Protocol_t* )data_ptr;
						//xgflash_message_save(data_ptr, sizeof(Message_Protocol_t), TRUE);
						log("receive data : %d", ptr->data.XG_Time.Second);
80002762:	f1 38 00 1f 	ld.ub	r8,r8[31]
80002766:	1a d8       	st.w	--sp,r8
80002768:	02 9c       	mov	r12,r1
8000276a:	f0 1f 00 16 	mcall	800027c0 <app_cfg+0xb4>
						xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);
8000276e:	00 9a       	mov	r10,r0
80002770:	32 0b       	mov	r11,32
80002772:	40 1c       	lddsp	r12,sp[0x4]
80002774:	f0 1f 00 14 	mcall	800027c4 <app_cfg+0xb8>
						set_message_store(data_ptr);
80002778:	49 48       	lddpc	r8,800027c8 <app_cfg+0xbc>
8000277a:	70 0c       	ld.w	r12,r8[0x0]
8000277c:	40 1b       	lddsp	r11,sp[0x4]
8000277e:	f0 1f 00 14 	mcall	800027cc <app_cfg+0xc0>
80002782:	2f fd       	sub	sp,-4
				//}
				//else
				//{
					//log("no find card...\n");
				//}
				nop();
80002784:	d7 03       	nop
80002786:	c0 48       	rjmp	8000278e <app_cfg+0x82>
				//Current_time.Hour, Current_time.Minute, Current_time.Second);
				
		}
		else
		{
			nop();
80002788:	d7 03       	nop
			nop();
8000278a:	d7 03       	nop
			nop();
8000278c:	d7 03       	nop
			//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		log("app pthread run...\n");	
8000278e:	49 1c       	lddpc	r12,800027d0 <app_cfg+0xc4>
80002790:	f0 1f 00 0c 	mcall	800027c0 <app_cfg+0xb4>
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002794:	0a 9b       	mov	r11,r5
80002796:	48 4c       	lddpc	r12,800027a4 <app_cfg+0x98>
80002798:	f0 1f 00 0f 	mcall	800027d4 <app_cfg+0xc8>
	}
8000279c:	cc 6b       	rjmp	80002728 <app_cfg+0x1c>
8000279e:	00 00       	add	r0,r0
800027a0:	80 00       	ld.sh	r0,r0[0x0]
800027a2:	68 fc       	ld.w	r12,r4[0x3c]
800027a4:	00 00       	add	r0,r0
800027a6:	0a 44       	or	r4,r5
800027a8:	00 00       	add	r0,r0
800027aa:	0d 8c       	ld.ub	r12,r6[0x0]
800027ac:	00 00       	add	r0,r0
800027ae:	0a 55       	eor	r5,r5
800027b0:	00 00       	add	r0,r0
800027b2:	0b 60       	ld.uh	r0,--r5
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	d5 e4       	*unknown*
800027b8:	80 00       	ld.sh	r0,r0[0x0]
800027ba:	40 44       	lddsp	r4,sp[0x10]
800027bc:	80 00       	ld.sh	r0,r0[0x0]
800027be:	61 8c       	ld.w	r12,r0[0x60]
800027c0:	80 00       	ld.sh	r0,r0[0x0]
800027c2:	6f d0       	ld.w	r0,r7[0x74]
800027c4:	80 00       	ld.sh	r0,r0[0x0]
800027c6:	3f 0c       	mov	r12,-16
800027c8:	00 00       	add	r0,r0
800027ca:	0b 68       	ld.uh	r8,--r5
800027cc:	80 00       	ld.sh	r0,r0[0x0]
800027ce:	2b d4       	sub	r4,-67
800027d0:	80 00       	ld.sh	r0,r0[0x0]
800027d2:	d5 f8       	*unknown*
800027d4:	80 00       	ld.sh	r0,r0[0x0]
800027d6:	6a ac       	ld.w	r12,r5[0x28]

800027d8 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800027d8:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800027dc:	19 c7       	ld.ub	r7,r12[0x4]
800027de:	19 d8       	ld.ub	r8,r12[0x5]
800027e0:	f1 e7 10 87 	or	r7,r8,r7<<0x8
800027e4:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
800027e6:	48 dc       	lddpc	r12,80002818 <Phyuserinput_brdcst_func+0x40>
800027e8:	f0 1f 00 0d 	mcall	8000281c <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
800027ec:	36 08       	mov	r8,96
800027ee:	f0 07 19 00 	cp.h	r7,r8
800027f2:	c1 11       	brne	80002814 <Phyuserinput_brdcst_func+0x3c>
800027f4:	48 b8       	lddpc	r8,80002820 <Phyuserinput_brdcst_func+0x48>
800027f6:	11 89       	ld.ub	r9,r8[0x0]
800027f8:	30 18       	mov	r8,1
800027fa:	f0 09 18 00 	cp.b	r9,r8
800027fe:	c0 b1       	brne	80002814 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, ACK_Received_Tone);//set tone to indicate the scan!!!
80002800:	31 4b       	mov	r11,20
80002802:	30 1c       	mov	r12,1
80002804:	f0 1f 00 08 	mcall	80002824 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(400*2 / portTICK_RATE_MS);//延迟400ms
80002808:	e0 6c 03 20 	mov	r12,800
8000280c:	f0 1f 00 07 	mcall	80002828 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		rfid_sendID_message();//send message		
80002810:	f0 1f 00 07 	mcall	8000282c <Phyuserinput_brdcst_func+0x54>
80002814:	e3 cd 80 80 	ldm	sp++,r7,pc
80002818:	80 00       	ld.sh	r0,r0[0x0]
8000281a:	d6 0c       	*unknown*
8000281c:	80 00       	ld.sh	r0,r0[0x0]
8000281e:	6f d0       	ld.w	r0,r7[0x74]
80002820:	00 00       	add	r0,r0
80002822:	0a 55       	eor	r5,r5
80002824:	80 00       	ld.sh	r0,r0[0x0]
80002826:	40 44       	lddsp	r4,sp[0x10]
80002828:	80 00       	ld.sh	r0,r0[0x0]
8000282a:	6a 64       	ld.w	r4,r5[0x18]
8000282c:	80 00       	ld.sh	r0,r0[0x0]
8000282e:	50 18       	stdsp	sp[0x4],r8

80002830 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002830:	d4 31       	pushm	r0-r7,lr
80002832:	20 9d       	sub	sp,36
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002834:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
80002838:	0d 88       	ld.ub	r8,r6[0x0]
8000283a:	32 49       	mov	r9,36
8000283c:	f2 08 18 00 	cp.b	r8,r9
80002840:	c2 91       	brne	80002892 <DataSession_brdcst_func+0x62>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002842:	4c 4c       	lddpc	r12,80002950 <DataSession_brdcst_func+0x120>
80002844:	f0 1f 00 44 	mcall	80002954 <DataSession_brdcst_func+0x124>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002848:	0d a5       	ld.ub	r5,r6[0x2]
8000284a:	0d b8       	ld.ub	r8,r6[0x3]
8000284c:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002850:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002852:	0d 98       	ld.ub	r8,r6[0x1]
80002854:	1a d8       	st.w	--sp,r8
80002856:	4c 1c       	lddpc	r12,80002958 <DataSession_brdcst_func+0x128>
80002858:	f0 1f 00 3f 	mcall	80002954 <DataSession_brdcst_func+0x124>
		log("\n\r paylaod_length: %d \n\r",data_length );
8000285c:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002860:	1a d8       	st.w	--sp,r8
80002862:	4b fc       	lddpc	r12,8000295c <DataSession_brdcst_func+0x12c>
80002864:	f0 1f 00 3c 	mcall	80002954 <DataSession_brdcst_func+0x124>
		for(i=0; i<data_length; i++)
80002868:	2f ed       	sub	sp,-8
8000286a:	58 05       	cp.w	r5,0
8000286c:	c7 00       	breq	8000294c <DataSession_brdcst_func+0x11c>
8000286e:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002870:	4b c4       	lddpc	r4,80002960 <DataSession_brdcst_func+0x130>
80002872:	ec 07 00 08 	add	r8,r6,r7
80002876:	11 c8       	ld.ub	r8,r8[0x4]
80002878:	1a d8       	st.w	--sp,r8
8000287a:	1a d7       	st.w	--sp,r7
8000287c:	08 9c       	mov	r12,r4
8000287e:	f0 1f 00 36 	mcall	80002954 <DataSession_brdcst_func+0x124>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002882:	2f f7       	sub	r7,-1
80002884:	5c 57       	castu.b	r7
80002886:	2f ed       	sub	sp,-8
80002888:	ee 05 19 00 	cp.h	r5,r7
8000288c:	fe 9b ff f3 	brhi	80002872 <DataSession_brdcst_func+0x42>
80002890:	c5 e8       	rjmp	8000294c <DataSession_brdcst_func+0x11c>
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002892:	0d a7       	ld.ub	r7,r6[0x2]
80002894:	0d b5       	ld.ub	r5,r6[0x3]
		log("State: %X \n", ptr->State);
80002896:	1a d8       	st.w	--sp,r8
80002898:	4b 3c       	lddpc	r12,80002964 <DataSession_brdcst_func+0x134>
8000289a:	f0 1f 00 2f 	mcall	80002954 <DataSession_brdcst_func+0x124>
		if (ptr->State == DATA_SESSION_TX_Suc)
8000289e:	0d 88       	ld.ub	r8,r6[0x0]
800028a0:	2f fd       	sub	sp,-4
800028a2:	30 39       	mov	r9,3
800028a4:	f2 08 18 00 	cp.b	r8,r9
800028a8:	c0 51       	brne	800028b2 <DataSession_brdcst_func+0x82>
		{
			log("data transmit success\n");
800028aa:	4b 0c       	lddpc	r12,80002968 <DataSession_brdcst_func+0x138>
800028ac:	f0 1f 00 2a 	mcall	80002954 <DataSession_brdcst_func+0x124>
800028b0:	c4 78       	rjmp	8000293e <DataSession_brdcst_func+0x10e>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
800028b2:	30 49       	mov	r9,4
800028b4:	f2 08 18 00 	cp.b	r8,r9
800028b8:	c4 31       	brne	8000293e <DataSession_brdcst_func+0x10e>
		{
			//Message_Protocol_t  *xgmessage = (Message_Protocol_t  *)ptr->DataPayload.DataPayload;
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
800028ba:	32 0a       	mov	r10,32
800028bc:	ec cb ff fc 	sub	r11,r6,-4
800028c0:	1a 9c       	mov	r12,sp
800028c2:	f0 1f 00 2b 	mcall	8000296c <DataSession_brdcst_func+0x13c>
800028c6:	fb 36 00 1f 	ld.ub	r6,sp[31]
800028ca:	fb 34 00 1e 	ld.ub	r4,sp[30]
800028ce:	fb 33 00 1d 	ld.ub	r3,sp[29]
800028d2:	fb 32 00 1c 	ld.ub	r2,sp[28]
800028d6:	fb 31 00 1b 	ld.ub	r1,sp[27]
800028da:	fb 30 00 1a 	ld.ub	r0,sp[26]
			log("data transmit failure\n");
800028de:	4a 5c       	lddpc	r12,80002970 <DataSession_brdcst_func+0x140>
800028e0:	f0 1f 00 1d 	mcall	80002954 <DataSession_brdcst_func+0x124>
			log("xgmessage.XG_Time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
800028e4:	1a d6       	st.w	--sp,r6
800028e6:	1a d4       	st.w	--sp,r4
800028e8:	1a d3       	st.w	--sp,r3
800028ea:	1a d2       	st.w	--sp,r2
800028ec:	1a d1       	st.w	--sp,r1
800028ee:	1a d0       	st.w	--sp,r0
800028f0:	4a 1c       	lddpc	r12,80002974 <DataSession_brdcst_func+0x144>
800028f2:	f0 1f 00 19 	mcall	80002954 <DataSession_brdcst_func+0x124>
			xgmessage.data.XG_Time.Year, xgmessage.data.XG_Time.Month, xgmessage.data.XG_Time.Day,
			xgmessage.data.XG_Time.Hour, xgmessage.data.XG_Time.Minute, xgmessage.data.XG_Time.Second);

			//return_value = xgflash_message_save(&xgmessage, sizeof(Message_Protocol_t), TRUE);

			Message_Protocol_t * myptr = get_message_store();	
800028f6:	4a 18       	lddpc	r8,80002978 <DataSession_brdcst_func+0x148>
800028f8:	70 0c       	ld.w	r12,r8[0x0]
800028fa:	f0 1f 00 21 	mcall	8000297c <DataSession_brdcst_func+0x14c>
800028fe:	50 ec       	stdsp	sp[0x38],r12
			if(NULL != myptr)
80002900:	2f ad       	sub	sp,-24
80002902:	58 0c       	cp.w	r12,0
80002904:	c1 a0       	breq	80002938 <DataSession_brdcst_func+0x108>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
80002906:	fb 66 00 1f 	st.b	sp[31],r6
8000290a:	fb 64 00 1e 	st.b	sp[30],r4
8000290e:	fb 63 00 1d 	st.b	sp[29],r3
80002912:	fb 62 00 1c 	st.b	sp[28],r2
80002916:	fb 61 00 1b 	st.b	sp[27],r1
8000291a:	fb 60 00 1a 	st.b	sp[26],r0
8000291e:	32 0a       	mov	r10,32
80002920:	1a 9b       	mov	r11,sp
80002922:	f0 1f 00 13 	mcall	8000296c <DataSession_brdcst_func+0x13c>
				xQueueSend(xg_resend_queue, &myptr, 0);
80002926:	49 78       	lddpc	r8,80002980 <DataSession_brdcst_func+0x150>
80002928:	70 0c       	ld.w	r12,r8[0x0]
8000292a:	30 09       	mov	r9,0
8000292c:	12 9a       	mov	r10,r9
8000292e:	fa cb ff e0 	sub	r11,sp,-32
80002932:	f0 1f 00 15 	mcall	80002984 <DataSession_brdcst_func+0x154>
80002936:	c0 48       	rjmp	8000293e <DataSession_brdcst_func+0x10e>
			}
			else
			{
				log("myptr: err\n\r" );
80002938:	49 4c       	lddpc	r12,80002988 <DataSession_brdcst_func+0x158>
8000293a:	f0 1f 00 07 	mcall	80002954 <DataSession_brdcst_func+0x124>
			}
			//xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate send-failure!!!
		}
		//log("Session_ID: %x \n\r",Session_number );
		log("paylaod_length: %d \n\r",data_length );
8000293e:	eb e7 10 87 	or	r7,r5,r7<<0x8
80002942:	1a d7       	st.w	--sp,r7
80002944:	49 2c       	lddpc	r12,8000298c <DataSession_brdcst_func+0x15c>
80002946:	f0 1f 00 04 	mcall	80002954 <DataSession_brdcst_func+0x124>
8000294a:	2f fd       	sub	sp,-4
				//
		//}
		
	}
	
}
8000294c:	2f 7d       	sub	sp,-36
8000294e:	d8 32       	popm	r0-r7,pc
80002950:	80 00       	ld.sh	r0,r0[0x0]
80002952:	d6 2c       	*unknown*
80002954:	80 00       	ld.sh	r0,r0[0x0]
80002956:	6f d0       	ld.w	r0,r7[0x74]
80002958:	80 00       	ld.sh	r0,r0[0x0]
8000295a:	d6 40       	acall	0x64
8000295c:	80 00       	ld.sh	r0,r0[0x0]
8000295e:	d6 58       	*unknown*
80002960:	80 00       	ld.sh	r0,r0[0x0]
80002962:	d6 74       	*unknown*
80002964:	80 00       	ld.sh	r0,r0[0x0]
80002966:	d6 8c       	*unknown*
80002968:	80 00       	ld.sh	r0,r0[0x0]
8000296a:	d6 98       	*unknown*
8000296c:	80 00       	ld.sh	r0,r0[0x0]
8000296e:	78 54       	ld.w	r4,r12[0x14]
80002970:	80 00       	ld.sh	r0,r0[0x0]
80002972:	d6 b0       	acall	0x6b
80002974:	80 00       	ld.sh	r0,r0[0x0]
80002976:	d6 c8       	*unknown*
80002978:	00 00       	add	r0,r0
8000297a:	0b 68       	ld.uh	r8,--r5
8000297c:	80 00       	ld.sh	r0,r0[0x0]
8000297e:	2d 80       	sub	r0,-40
80002980:	00 00       	add	r0,r0
80002982:	0b 60       	ld.uh	r0,--r5
80002984:	80 00       	ld.sh	r0,r0[0x0]
80002986:	63 98       	ld.w	r8,r1[0x64]
80002988:	80 00       	ld.sh	r0,r0[0x0]
8000298a:	d6 fc       	*unknown*
8000298c:	80 00       	ld.sh	r0,r0[0x0]
8000298e:	d7 0c       	*unknown*

80002990 <DeviceInitializationStatus_brdcst_func>:
extern volatile xQueueHandle xg_resend_queue ;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002990:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002992:	19 e8       	ld.ub	r8,r12[0x6]
80002994:	30 19       	mov	r9,1
80002996:	f2 08 18 00 	cp.b	r8,r9
8000299a:	c0 61       	brne	800029a6 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
8000299c:	48 98       	lddpc	r8,800029c0 <DeviceInitializationStatus_brdcst_func+0x30>
8000299e:	70 09       	ld.w	r9,r8[0x0]
800029a0:	a1 a9       	sbr	r9,0x0
800029a2:	91 09       	st.w	r8[0x0],r9
800029a4:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800029a6:	30 29       	mov	r9,2
800029a8:	f2 08 18 00 	cp.b	r8,r9
800029ac:	c0 80       	breq	800029bc <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800029ae:	48 58       	lddpc	r8,800029c0 <DeviceInitializationStatus_brdcst_func+0x30>
800029b0:	70 09       	ld.w	r9,r8[0x0]
800029b2:	e0 19 ff fc 	andl	r9,0xfffc
800029b6:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800029b8:	f0 1f 00 03 	mcall	800029c4 <DeviceInitializationStatus_brdcst_func+0x34>
800029bc:	d8 02       	popm	pc
800029be:	00 00       	add	r0,r0
800029c0:	00 00       	add	r0,r0
800029c2:	0d 8c       	ld.ub	r12,r6[0x0]
800029c4:	80 00       	ld.sh	r0,r0[0x0]
800029c6:	3f 98       	mov	r8,-7

800029c8 <xg_rtc_init>:
}



void xg_rtc_init(void)
{
800029c8:	d4 01       	pushm	lr
	//{
		//return 3;
	//}
	  	
	  // Disable all interrupts. */
	  Disable_global_interrupt();
800029ca:	d3 03       	ssrf	0x10
	  
	  // Register the RTC interrupt handler to the interrupt controller.
	  INTC_register_interrupt(&rtc_irq, AVR32_RTC_IRQ, AVR32_INTC_INT0);
800029cc:	30 0a       	mov	r10,0
800029ce:	32 8b       	mov	r11,40
800029d0:	49 5c       	lddpc	r12,80002a24 <xg_rtc_init+0x5c>
800029d2:	f0 1f 00 16 	mcall	80002a28 <xg_rtc_init+0x60>

	  // Initialize the RTC
	  if (!rtc_init(&AVR32_RTC, RTC_OSC_RC, RTC_PSEL_RC_1_76HZ))
800029d6:	30 fa       	mov	r10,15
800029d8:	30 0b       	mov	r11,0
800029da:	fe 7c 0d 00 	mov	r12,-62208
800029de:	f0 1f 00 14 	mcall	80002a2c <xg_rtc_init+0x64>
800029e2:	c0 41       	brne	800029ea <xg_rtc_init+0x22>
	  //if (!rtc_init(&AVR32_RTC, RTC_OSC_32KHZ, RTC_PSEL_32KHZ_1HZ))
	  {
		  log("Error initializing the RTC\r\n");
800029e4:	49 3c       	lddpc	r12,80002a30 <xg_rtc_init+0x68>
800029e6:	f0 1f 00 14 	mcall	80002a34 <xg_rtc_init+0x6c>
	  }
	  // Set top value to 0 to generate an interrupt every seconds */
	  rtc_set_top_value(&AVR32_RTC, 0);
800029ea:	30 0b       	mov	r11,0
800029ec:	fe 7c 0d 00 	mov	r12,-62208
800029f0:	f0 1f 00 12 	mcall	80002a38 <xg_rtc_init+0x70>
	  // Enable the interrupts
	  rtc_enable_interrupt(&AVR32_RTC);
800029f4:	fe 7c 0d 00 	mov	r12,-62208
800029f8:	f0 1f 00 11 	mcall	80002a3c <xg_rtc_init+0x74>
	  // Enable the RTC
	  rtc_enable(&AVR32_RTC);
800029fc:	fe 7c 0d 00 	mov	r12,-62208
80002a00:	f0 1f 00 10 	mcall	80002a40 <xg_rtc_init+0x78>

	Current_time.Year		= 16;
80002a04:	49 08       	lddpc	r8,80002a44 <xg_rtc_init+0x7c>
80002a06:	31 09       	mov	r9,16
80002a08:	b0 89       	st.b	r8[0x0],r9
	Current_time.Month		= 2;
80002a0a:	30 29       	mov	r9,2
80002a0c:	b0 99       	st.b	r8[0x1],r9
	Current_time.Day		= 29;
80002a0e:	31 d9       	mov	r9,29
80002a10:	b0 a9       	st.b	r8[0x2],r9
	Current_time.Hour		= 23;
80002a12:	31 79       	mov	r9,23
80002a14:	b0 b9       	st.b	r8[0x3],r9
	Current_time.Minute		= 59;
80002a16:	33 b9       	mov	r9,59
80002a18:	b0 c9       	st.b	r8[0x4],r9
	Current_time.Second		= 40;
80002a1a:	32 89       	mov	r9,40
80002a1c:	b0 d9       	st.b	r8[0x5],r9
	/*finished accessing the shared resource.Release the semaphore.*/
	//xSemaphoreGive(rtc_mutex);
	
	//sec = Current_time.Second;
	// Enable global interrupts
	Enable_global_interrupt();
80002a1e:	d5 03       	csrf	0x10
	  
	//RTC_Test();	

}
80002a20:	d8 02       	popm	pc
80002a22:	00 00       	add	r0,r0
80002a24:	80 00       	ld.sh	r0,r0[0x0]
80002a26:	2a 48       	sub	r8,-92
80002a28:	80 00       	ld.sh	r0,r0[0x0]
80002a2a:	54 38       	stdsp	sp[0x10c],r8
80002a2c:	80 00       	ld.sh	r0,r0[0x0]
80002a2e:	57 84       	stdsp	sp[0x1e0],r4
80002a30:	80 00       	ld.sh	r0,r0[0x0]
80002a32:	d7 24       	*unknown*
80002a34:	80 00       	ld.sh	r0,r0[0x0]
80002a36:	6f d0       	ld.w	r0,r7[0x74]
80002a38:	80 00       	ld.sh	r0,r0[0x0]
80002a3a:	57 40       	stdsp	sp[0x1d0],r0
80002a3c:	80 00       	ld.sh	r0,r0[0x0]
80002a3e:	57 38       	stdsp	sp[0x1cc],r8
80002a40:	80 00       	ld.sh	r0,r0[0x0]
80002a42:	57 14       	stdsp	sp[0x1c4],r4
80002a44:	00 00       	add	r0,r0
80002a46:	0d 90       	ld.ub	r0,r6[0x1]

80002a48 <rtc_irq>:
/* RTC Interrupt  */
#pragma handler = AVR32_RTC_IRQ_GROUP, 1
__interrupt
#endif
void rtc_irq(void)
{
80002a48:	d4 01       	pushm	lr
	U8 T,K;
	U32 T16,K16;
	// Increment the minutes counter
	//sec++;
	
	Current_time.Second++;
80002a4a:	4b 98       	lddpc	r8,80002b2c <rtc_irq+0xe4>
80002a4c:	11 d9       	ld.ub	r9,r8[0x5]
80002a4e:	2f f9       	sub	r9,-1
80002a50:	b0 d9       	st.b	r8[0x5],r9
	if(Current_time.Second>=60)
80002a52:	11 d9       	ld.ub	r9,r8[0x5]
80002a54:	33 b8       	mov	r8,59
80002a56:	f0 09 18 00 	cp.b	r9,r8
80002a5a:	e0 88 00 5f 	brls	80002b18 <rtc_irq+0xd0>
	{
		Current_time.Second =0;
80002a5e:	4b 48       	lddpc	r8,80002b2c <rtc_irq+0xe4>
80002a60:	30 09       	mov	r9,0
80002a62:	b0 d9       	st.b	r8[0x5],r9
		Current_time.Minute++;
80002a64:	11 c9       	ld.ub	r9,r8[0x4]
80002a66:	2f f9       	sub	r9,-1
80002a68:	b0 c9       	st.b	r8[0x4],r9
		if(Current_time.Minute>=60)
80002a6a:	11 c9       	ld.ub	r9,r8[0x4]
80002a6c:	33 b8       	mov	r8,59
80002a6e:	f0 09 18 00 	cp.b	r9,r8
80002a72:	e0 88 00 53 	brls	80002b18 <rtc_irq+0xd0>
		{
			Current_time.Minute=0;
80002a76:	4a e8       	lddpc	r8,80002b2c <rtc_irq+0xe4>
80002a78:	30 09       	mov	r9,0
80002a7a:	b0 c9       	st.b	r8[0x4],r9
			Current_time.Hour++;
80002a7c:	11 b9       	ld.ub	r9,r8[0x3]
80002a7e:	2f f9       	sub	r9,-1
80002a80:	b0 b9       	st.b	r8[0x3],r9
			if (Current_time.Hour>=24)
80002a82:	11 b9       	ld.ub	r9,r8[0x3]
80002a84:	31 78       	mov	r8,23
80002a86:	f0 09 18 00 	cp.b	r9,r8
80002a8a:	e0 88 00 47 	brls	80002b18 <rtc_irq+0xd0>
			{
				Current_time.Hour=0;
80002a8e:	4a 88       	lddpc	r8,80002b2c <rtc_irq+0xe4>
80002a90:	30 09       	mov	r9,0
80002a92:	b0 b9       	st.b	r8[0x3],r9
				K16=(Current_time.Year&0x03)?365:366;				//判断当年是否为闰年,并获取当年的总天数（此算法时间起点为2000年）
80002a94:	11 88       	ld.ub	r8,r8[0x0]
80002a96:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80002a9a:	e0 69 01 6e 	mov	r9,366
80002a9e:	e0 6a 01 6d 	mov	r10,365
80002aa2:	f4 08 17 10 	movne	r8,r10
80002aa6:	f2 08 17 00 	moveq	r8,r9
				K16-=337;											//计算当年二月份天数
				//统计当月天数				
				K=(Current_time.Month==2)?K16:(((Current_time.Month+(Current_time.Month>>3))&0x01)+30);			
80002aaa:	4a 19       	lddpc	r9,80002b2c <rtc_irq+0xe4>
80002aac:	13 9a       	ld.ub	r10,r9[0x1]
80002aae:	30 29       	mov	r9,2
80002ab0:	f2 0a 18 00 	cp.b	r10,r9
80002ab4:	c0 b0       	breq	80002aca <rtc_irq+0x82>
80002ab6:	49 e8       	lddpc	r8,80002b2c <rtc_irq+0xe4>
80002ab8:	11 99       	ld.ub	r9,r8[0x1]
80002aba:	11 9a       	ld.ub	r10,r8[0x1]
80002abc:	a3 9a       	lsr	r10,0x3
80002abe:	12 0a       	add	r10,r9
80002ac0:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80002ac4:	2e 2a       	sub	r10,-30
80002ac6:	5c 5a       	castu.b	r10
80002ac8:	c0 58       	rjmp	80002ad2 <rtc_irq+0x8a>
80002aca:	f0 c8 01 51 	sub	r8,r8,337
80002ace:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
				Current_time.Day++;
80002ad2:	49 78       	lddpc	r8,80002b2c <rtc_irq+0xe4>
80002ad4:	11 a9       	ld.ub	r9,r8[0x2]
80002ad6:	2f f9       	sub	r9,-1
80002ad8:	b0 a9       	st.b	r8[0x2],r9
				if(Current_time.Day>K)
80002ada:	11 a8       	ld.ub	r8,r8[0x2]
80002adc:	f0 0a 18 00 	cp.b	r10,r8
80002ae0:	c1 c2       	brcc	80002b18 <rtc_irq+0xd0>
				{	
					Current_time.Day = 1;//重置到下月1号
80002ae2:	49 38       	lddpc	r8,80002b2c <rtc_irq+0xe4>
80002ae4:	30 19       	mov	r9,1
80002ae6:	b0 a9       	st.b	r8[0x2],r9
					Current_time.Month++;
80002ae8:	11 99       	ld.ub	r9,r8[0x1]
80002aea:	2f f9       	sub	r9,-1
80002aec:	b0 99       	st.b	r8[0x1],r9
					if(Current_time.Month>12)
80002aee:	11 99       	ld.ub	r9,r8[0x1]
80002af0:	30 c8       	mov	r8,12
80002af2:	f0 09 18 00 	cp.b	r9,r8
80002af6:	e0 88 00 11 	brls	80002b18 <rtc_irq+0xd0>
					{
						Current_time.Month = 1;//重置到下一年的第一个月
80002afa:	48 d8       	lddpc	r8,80002b2c <rtc_irq+0xe4>
80002afc:	30 19       	mov	r9,1
80002afe:	b0 99       	st.b	r8[0x1],r9
						Current_time.Year++;
80002b00:	11 89       	ld.ub	r9,r8[0x0]
80002b02:	2f f9       	sub	r9,-1
80002b04:	b0 89       	st.b	r8[0x0],r9
						if (Current_time.Year>150)Current_time.Year=0;//重置年份											
80002b06:	11 89       	ld.ub	r9,r8[0x0]
80002b08:	39 68       	mov	r8,-106
80002b0a:	f0 09 18 00 	cp.b	r9,r8
80002b0e:	e0 88 00 05 	brls	80002b18 <rtc_irq+0xd0>
80002b12:	30 09       	mov	r9,0
80002b14:	48 68       	lddpc	r8,80002b2c <rtc_irq+0xe4>
80002b16:	b0 89       	st.b	r8[0x0],r9
	}
	
	//Time_scale++;

	// clear the interrupt flag
	rtc_clear_interrupt(&AVR32_RTC);
80002b18:	fe 7c 0d 00 	mov	r12,-62208
80002b1c:	f0 1f 00 05 	mcall	80002b30 <rtc_irq+0xe8>

	// specify that an interrupt has been raised
	print_sec = 1;
80002b20:	30 19       	mov	r9,1
80002b22:	48 58       	lddpc	r8,80002b34 <rtc_irq+0xec>
80002b24:	91 09       	st.w	r8[0x0],r9
}
80002b26:	d4 02       	popm	lr
80002b28:	d6 03       	rete
80002b2a:	00 00       	add	r0,r0
80002b2c:	00 00       	add	r0,r0
80002b2e:	0d 90       	ld.ub	r0,r6[0x1]
80002b30:	80 00       	ld.sh	r0,r0[0x0]
80002b32:	57 64       	stdsp	sp[0x1d8],r4
80002b34:	00 00       	add	r0,r0
80002b36:	04 f0       	st.b	--r2,r0

80002b38 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002b38:	20 1c       	sub	r12,1
80002b3a:	5c 5c       	castu.b	r12
80002b3c:	31 18       	mov	r8,17
80002b3e:	f0 0c 18 00 	cp.b	r12,r8
80002b42:	e0 88 00 03 	brls	80002b48 <CalculateBurst+0x10>
80002b46:	5e fd       	retal	0
80002b48:	48 28       	lddpc	r8,80002b50 <CalculateBurst+0x18>
80002b4a:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002b4e:	5e fc       	retal	r12
80002b50:	80 00       	ld.sh	r0,r0[0x0]
80002b52:	d7 44       	*unknown*

80002b54 <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
80002b54:	48 38       	lddpc	r8,80002b60 <payload_init+0xc>
80002b56:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002b58:	48 38       	lddpc	r8,80002b64 <payload_init+0x10>
80002b5a:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
80002b5c:	5e fc       	retal	r12
80002b5e:	00 00       	add	r0,r0
80002b60:	00 00       	add	r0,r0
80002b62:	0a 60       	and	r0,r5
80002b64:	00 00       	add	r0,r0
80002b66:	0a 64       	and	r4,r5

80002b68 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002b68:	d4 01       	pushm	lr
80002b6a:	20 2d       	sub	sp,8
80002b6c:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002b6e:	30 09       	mov	r9,0
80002b70:	fa ca ff f8 	sub	r10,sp,-8
80002b74:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002b76:	1a 9b       	mov	r11,sp
80002b78:	f0 1f 00 02 	mcall	80002b80 <set_idle_store_isr+0x18>
}
80002b7c:	2f ed       	sub	sp,-8
80002b7e:	d8 02       	popm	pc
80002b80:	80 00       	ld.sh	r0,r0[0x0]
80002b82:	63 48       	ld.w	r8,r1[0x50]

80002b84 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002b84:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
80002b86:	48 48       	lddpc	r8,80002b94 <payload_rx+0x10>
80002b88:	70 08       	ld.w	r8,r8[0x0]
80002b8a:	18 9b       	mov	r11,r12
80002b8c:	10 9c       	mov	r12,r8
80002b8e:	f0 1f 00 03 	mcall	80002b98 <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
80002b92:	d8 02       	popm	pc
80002b94:	00 00       	add	r0,r0
80002b96:	0a 9c       	mov	r12,r5
80002b98:	80 00       	ld.sh	r0,r0[0x0]
80002b9a:	2b 68       	sub	r8,-74

80002b9c <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002b9c:	d4 01       	pushm	lr
80002b9e:	20 2d       	sub	sp,8
80002ba0:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002ba2:	58 0c       	cp.w	r12,0
80002ba4:	c1 10       	breq	80002bc6 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002ba6:	30 08       	mov	r8,0
80002ba8:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002baa:	98 88       	ld.uh	r8,r12[0x0]
80002bac:	e2 18 f0 00 	andl	r8,0xf000,COH
80002bb0:	e0 48 40 00 	cp.w	r8,16384
80002bb4:	c0 91       	brne	80002bc6 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002bb6:	48 68       	lddpc	r8,80002bcc <phy_rx+0x30>
80002bb8:	70 0c       	ld.w	r12,r8[0x0]
80002bba:	30 09       	mov	r9,0
80002bbc:	fa ca ff fc 	sub	r10,sp,-4
80002bc0:	1a 9b       	mov	r11,sp
80002bc2:	f0 1f 00 04 	mcall	80002bd0 <phy_rx+0x34>
		}	

    }
		
 
}
80002bc6:	2f ed       	sub	sp,-8
80002bc8:	d8 02       	popm	pc
80002bca:	00 00       	add	r0,r0
80002bcc:	00 00       	add	r0,r0
80002bce:	0a a8       	st.w	r5++,r8
80002bd0:	80 00       	ld.sh	r0,r0[0x0]
80002bd2:	63 48       	ld.w	r8,r1[0x50]

80002bd4 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002bd4:	eb cd 40 80 	pushm	r7,lr
80002bd8:	20 1d       	sub	sp,4
80002bda:	fa c7 ff fc 	sub	r7,sp,-4
80002bde:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002be0:	30 09       	mov	r9,0
80002be2:	12 9a       	mov	r10,r9
80002be4:	1a 9b       	mov	r11,sp
80002be6:	f0 1f 00 03 	mcall	80002bf0 <set_idle_store+0x1c>
}
80002bea:	2f fd       	sub	sp,-4
80002bec:	e3 cd 80 80 	ldm	sp++,r7,pc
80002bf0:	80 00       	ld.sh	r0,r0[0x0]
80002bf2:	63 98       	ld.w	r8,r1[0x64]

80002bf4 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002bf4:	d4 01       	pushm	lr
80002bf6:	20 1d       	sub	sp,4
80002bf8:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002bfa:	98 88       	ld.uh	r8,r12[0x0]
80002bfc:	e2 18 f0 00 	andl	r8,0xf000,COH
80002c00:	e0 48 40 00 	cp.w	r8,16384
80002c04:	c0 d1       	brne	80002c1e <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002c06:	49 08       	lddpc	r8,80002c44 <phy_tx+0x50>
80002c08:	70 08       	ld.w	r8,r8[0x0]
80002c0a:	58 08       	cp.w	r8,0
80002c0c:	c1 a0       	breq	80002c40 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002c0e:	48 e8       	lddpc	r8,80002c44 <phy_tx+0x50>
80002c10:	70 0c       	ld.w	r12,r8[0x0]
80002c12:	30 09       	mov	r9,0
80002c14:	12 9a       	mov	r10,r9
80002c16:	1a 9b       	mov	r11,sp
80002c18:	f0 1f 00 0c 	mcall	80002c48 <phy_tx+0x54>
80002c1c:	c1 28       	rjmp	80002c40 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002c1e:	e0 48 10 00 	cp.w	r8,4096
80002c22:	5f 0a       	sreq	r10
80002c24:	e0 48 20 00 	cp.w	r8,8192
80002c28:	5f 09       	sreq	r9
80002c2a:	f5 e9 10 09 	or	r9,r10,r9
80002c2e:	c0 71       	brne	80002c3c <phy_tx+0x48>
80002c30:	e0 48 50 00 	cp.w	r8,20480
80002c34:	c0 40       	breq	80002c3c <phy_tx+0x48>
80002c36:	e0 48 60 00 	cp.w	r8,24576
80002c3a:	c0 31       	brne	80002c40 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002c3c:	48 48       	lddpc	r8,80002c4c <phy_tx+0x58>
80002c3e:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002c40:	2f fd       	sub	sp,-4
80002c42:	d8 02       	popm	pc
80002c44:	00 00       	add	r0,r0
80002c46:	0a c8       	st.b	r5++,r8
80002c48:	80 00       	ld.sh	r0,r0[0x0]
80002c4a:	63 98       	ld.w	r8,r1[0x64]
80002c4c:	00 00       	add	r0,r0
80002c4e:	0a bc       	st.h	r5++,r12

80002c50 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002c50:	d4 01       	pushm	lr
80002c52:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002c54:	30 08       	mov	r8,0
80002c56:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002c58:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002c5a:	1a 9a       	mov	r10,sp
80002c5c:	fa cb ff fc 	sub	r11,sp,-4
80002c60:	f0 1f 00 05 	mcall	80002c74 <get_idle_store_isr+0x24>
80002c64:	58 1c       	cp.w	r12,1
80002c66:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002c6a:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002c6e:	2f ed       	sub	sp,-8
80002c70:	d8 02       	popm	pc
80002c72:	00 00       	add	r0,r0
80002c74:	80 00       	ld.sh	r0,r0[0x0]
80002c76:	60 9c       	ld.w	r12,r0[0x24]

80002c78 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002c78:	eb cd 40 c0 	pushm	r6-r7,lr
80002c7c:	20 1d       	sub	sp,4
80002c7e:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002c80:	4b a8       	lddpc	r8,80002d68 <phy_tx_func+0xf0>
80002c82:	70 08       	ld.w	r8,r8[0x0]
80002c84:	58 08       	cp.w	r8,0
80002c86:	c6 60       	breq	80002d52 <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002c88:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002c8a:	30 08       	mov	r8,0
80002c8c:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002c8e:	4b 88       	lddpc	r8,80002d6c <phy_tx_func+0xf4>
80002c90:	70 08       	ld.w	r8,r8[0x0]
80002c92:	58 18       	cp.w	r8,1
80002c94:	c2 60       	breq	80002ce0 <phy_tx_func+0x68>
80002c96:	c0 43       	brcs	80002c9e <phy_tx_func+0x26>
80002c98:	58 28       	cp.w	r8,2
80002c9a:	c5 c1       	brne	80002d52 <phy_tx_func+0xda>
80002c9c:	c5 58       	rjmp	80002d46 <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002c9e:	4b 38       	lddpc	r8,80002d68 <phy_tx_func+0xf0>
80002ca0:	70 0c       	ld.w	r12,r8[0x0]
80002ca2:	1a 9a       	mov	r10,sp
80002ca4:	4b 3b       	lddpc	r11,80002d70 <phy_tx_func+0xf8>
80002ca6:	f0 1f 00 34 	mcall	80002d74 <phy_tx_func+0xfc>
80002caa:	58 1c       	cp.w	r12,1
80002cac:	c1 41       	brne	80002cd4 <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002cae:	4b 18       	lddpc	r8,80002d70 <phy_tx_func+0xf8>
80002cb0:	70 08       	ld.w	r8,r8[0x0]
80002cb2:	90 08       	ld.sh	r8,r8[0x0]
80002cb4:	10 9a       	mov	r10,r8
80002cb6:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002cba:	4b 09       	lddpc	r9,80002d78 <phy_tx_func+0x100>
80002cbc:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002cbe:	5c 78       	castu.h	r8
80002cc0:	ea 18 ab cd 	orh	r8,0xabcd
80002cc4:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002cc6:	30 19       	mov	r9,1
80002cc8:	4a d8       	lddpc	r8,80002d7c <phy_tx_func+0x104>
80002cca:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002ccc:	30 19       	mov	r9,1
80002cce:	4a 88       	lddpc	r8,80002d6c <phy_tx_func+0xf4>
80002cd0:	91 09       	st.w	r8[0x0],r9
80002cd2:	c4 08       	rjmp	80002d52 <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002cd4:	e0 68 5a 5a 	mov	r8,23130
80002cd8:	ea 18 ab cd 	orh	r8,0xabcd
80002cdc:	8f 18       	st.w	r7[0x4],r8
80002cde:	c3 a8       	rjmp	80002d52 <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002ce0:	4a 7a       	lddpc	r10,80002d7c <phy_tx_func+0x104>
80002ce2:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002ce4:	4a 39       	lddpc	r9,80002d70 <phy_tx_func+0xf8>
80002ce6:	72 09       	ld.w	r9,r9[0x0]
80002ce8:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002cec:	b1 69       	lsl	r9,0x10
80002cee:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002cf0:	2f f8       	sub	r8,-1
80002cf2:	5c 58       	castu.b	r8
80002cf4:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002cf6:	4a 1b       	lddpc	r11,80002d78 <phy_tx_func+0x100>
80002cf8:	96 0c       	ld.sh	r12,r11[0x0]
80002cfa:	20 2c       	sub	r12,2
80002cfc:	5c 8c       	casts.h	r12
80002cfe:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002d02:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002d04:	30 0b       	mov	r11,0
80002d06:	f6 0a 19 00 	cp.h	r10,r11
80002d0a:	e0 89 00 09 	brgt	80002d1c <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002d0e:	e8 19 00 ba 	orl	r9,0xba
80002d12:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002d14:	30 09       	mov	r9,0
80002d16:	49 68       	lddpc	r8,80002d6c <phy_tx_func+0xf4>
80002d18:	91 09       	st.w	r8[0x0],r9
80002d1a:	c1 c8       	rjmp	80002d52 <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002d1c:	49 5a       	lddpc	r10,80002d70 <phy_tx_func+0xf8>
80002d1e:	74 0a       	ld.w	r10,r10[0x0]
80002d20:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002d24:	14 49       	or	r9,r10
80002d26:	8f 19       	st.w	r7[0x4],r9
80002d28:	2f f8       	sub	r8,-1
80002d2a:	49 59       	lddpc	r9,80002d7c <phy_tx_func+0x104>
80002d2c:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002d2e:	20 2c       	sub	r12,2
80002d30:	49 28       	lddpc	r8,80002d78 <phy_tx_func+0x100>
80002d32:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002d34:	30 08       	mov	r8,0
80002d36:	f0 0c 19 00 	cp.h	r12,r8
80002d3a:	e0 89 00 0c 	brgt	80002d52 <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002d3e:	30 29       	mov	r9,2
80002d40:	48 b8       	lddpc	r8,80002d6c <phy_tx_func+0xf4>
80002d42:	91 09       	st.w	r8[0x0],r9
80002d44:	c0 78       	rjmp	80002d52 <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002d46:	fc 18 00 ba 	movh	r8,0xba
80002d4a:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002d4c:	30 09       	mov	r9,0
80002d4e:	48 88       	lddpc	r8,80002d6c <phy_tx_func+0xf4>
80002d50:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002d52:	e0 68 5a 5a 	mov	r8,23130
80002d56:	ea 18 ab cd 	orh	r8,0xabcd
80002d5a:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002d5c:	30 08       	mov	r8,0
80002d5e:	8f 38       	st.w	r7[0xc],r8
}
80002d60:	2f fd       	sub	sp,-4
80002d62:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002d66:	00 00       	add	r0,r0
80002d68:	00 00       	add	r0,r0
80002d6a:	0a c8       	st.b	r5++,r8
80002d6c:	00 00       	add	r0,r0
80002d6e:	0a 88       	andn	r8,r5
80002d70:	00 00       	add	r0,r0
80002d72:	0a 94       	mov	r4,r5
80002d74:	80 00       	ld.sh	r0,r0[0x0]
80002d76:	60 9c       	ld.w	r12,r0[0x24]
80002d78:	00 00       	add	r0,r0
80002d7a:	0a b0       	st.h	r5++,r0
80002d7c:	00 00       	add	r0,r0
80002d7e:	0a 68       	and	r8,r5

80002d80 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002d80:	d4 01       	pushm	lr
80002d82:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002d84:	30 0a       	mov	r10,0
80002d86:	fa cb ff fc 	sub	r11,sp,-4
80002d8a:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002d8c:	14 99       	mov	r9,r10
80002d8e:	1a 9b       	mov	r11,sp
80002d90:	f0 1f 00 05 	mcall	80002da4 <get_idle_store+0x24>
80002d94:	58 1c       	cp.w	r12,1
80002d96:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002d9a:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002d9e:	2f fd       	sub	sp,-4
80002da0:	d8 02       	popm	pc
80002da2:	00 00       	add	r0,r0
80002da4:	80 00       	ld.sh	r0,r0[0x0]
80002da6:	61 8c       	ld.w	r12,r0[0x60]

80002da8 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002da8:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002daa:	48 5b       	lddpc	r11,80002dbc <phy_init+0x14>
80002dac:	48 5c       	lddpc	r12,80002dc0 <phy_init+0x18>
80002dae:	f0 1f 00 06 	mcall	80002dc4 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002db2:	f0 1f 00 06 	mcall	80002dc8 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002db6:	f0 1f 00 06 	mcall	80002dcc <phy_init+0x24>
	
}
80002dba:	d8 02       	popm	pc
80002dbc:	80 00       	ld.sh	r0,r0[0x0]
80002dbe:	2c 78       	sub	r8,-57
80002dc0:	80 00       	ld.sh	r0,r0[0x0]
80002dc2:	2d d0       	sub	r0,-35
80002dc4:	80 00       	ld.sh	r0,r0[0x0]
80002dc6:	3e 30       	mov	r0,-29
80002dc8:	80 00       	ld.sh	r0,r0[0x0]
80002dca:	3e 44       	mov	r4,-28
80002dcc:	80 00       	ld.sh	r0,r0[0x0]
80002dce:	47 f0       	lddsp	r0,sp[0x1fc]

80002dd0 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002dd0:	eb cd 40 e0 	pushm	r5-r7,lr
80002dd4:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002dd6:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002dda:	70 08       	ld.w	r8,r8[0x0]
80002ddc:	58 08       	cp.w	r8,0
80002dde:	e0 80 01 08 	breq	80002fee <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002de2:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002de4:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002de8:	70 09       	ld.w	r9,r8[0x0]
80002dea:	2f f9       	sub	r9,-1
80002dec:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002dee:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002df2:	70 08       	ld.w	r8,r8[0x0]
80002df4:	58 18       	cp.w	r8,1
80002df6:	e0 80 00 85 	breq	80002f00 <phy_rx_func+0x130>
80002dfa:	c0 73       	brcs	80002e08 <phy_rx_func+0x38>
80002dfc:	58 28       	cp.w	r8,2
80002dfe:	c5 c0       	breq	80002eb6 <phy_rx_func+0xe6>
80002e00:	58 38       	cp.w	r8,3
80002e02:	e0 81 00 f6 	brne	80002fee <phy_rx_func+0x21e>
80002e06:	cd 58       	rjmp	80002fb0 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002e08:	e0 6a 5a 5a 	mov	r10,23130
80002e0c:	ea 1a ab cd 	orh	r10,0xabcd
80002e10:	14 36       	cp.w	r6,r10
80002e12:	e0 80 00 ee 	breq	80002fee <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002e16:	ec 08 16 10 	lsr	r8,r6,0x10
80002e1a:	e0 48 ab cd 	cp.w	r8,43981
80002e1e:	e0 81 00 e8 	brne	80002fee <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002e22:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002e26:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002e2a:	20 28       	sub	r8,2
80002e2c:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002e30:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002e32:	30 09       	mov	r9,0
80002e34:	f2 08 19 00 	cp.h	r8,r9
80002e38:	e0 8a 00 db 	brle	80002fee <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002e3c:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002e40:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002e42:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002e46:	70 0c       	ld.w	r12,r8[0x0]
80002e48:	f0 1f 03 88 	mcall	80003c68 <phy_rx_func+0xe98>
80002e4c:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002e50:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002e52:	58 0c       	cp.w	r12,0
80002e54:	e0 80 00 cd 	breq	80002fee <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002e58:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002e5c:	90 09       	ld.sh	r9,r8[0x0]
80002e5e:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002e62:	2f f9       	sub	r9,-1
80002e64:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002e66:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002e6a:	74 0a       	ld.w	r10,r10[0x0]
80002e6c:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002e70:	76 0b       	ld.w	r11,r11[0x0]
80002e72:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002e76:	2f f9       	sub	r9,-1
80002e78:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002e7a:	e2 16 0f 00 	andl	r6,0xf00,COH
80002e7e:	e0 46 01 00 	cp.w	r6,256
80002e82:	c0 c0       	breq	80002e9a <phy_rx_func+0xca>
80002e84:	e0 8b 00 05 	brhi	80002e8e <phy_rx_func+0xbe>
80002e88:	58 06       	cp.w	r6,0
80002e8a:	c0 80       	breq	80002e9a <phy_rx_func+0xca>
80002e8c:	c0 c8       	rjmp	80002ea4 <phy_rx_func+0xd4>
80002e8e:	e0 46 02 00 	cp.w	r6,512
80002e92:	c0 40       	breq	80002e9a <phy_rx_func+0xca>
80002e94:	e0 46 03 00 	cp.w	r6,768
80002e98:	c0 61       	brne	80002ea4 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002e9a:	30 29       	mov	r9,2
80002e9c:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002ea0:	91 09       	st.w	r8[0x0],r9
80002ea2:	ca 68       	rjmp	80002fee <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002ea4:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002ea8:	70 0c       	ld.w	r12,r8[0x0]
80002eaa:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002eae:	70 0b       	ld.w	r11,r8[0x0]
80002eb0:	f0 1f 03 70 	mcall	80003c70 <phy_rx_func+0xea0>
80002eb4:	c9 d8       	rjmp	80002fee <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002eb6:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002eba:	b1 86       	lsr	r6,0x10
80002ebc:	14 06       	add	r6,r10
80002ebe:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002ec2:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002ec4:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002ec8:	90 09       	ld.sh	r9,r8[0x0]
80002eca:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002ece:	76 0b       	ld.w	r11,r11[0x0]
80002ed0:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002ed4:	2f f9       	sub	r9,-1
80002ed6:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002ed8:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002edc:	92 08       	ld.sh	r8,r9[0x0]
80002ede:	20 28       	sub	r8,2
80002ee0:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002ee2:	30 09       	mov	r9,0
80002ee4:	f2 08 19 00 	cp.h	r8,r9
80002ee8:	e0 8a 00 07 	brle	80002ef6 <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002eec:	30 19       	mov	r9,1
80002eee:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002ef2:	91 09       	st.w	r8[0x0],r9
80002ef4:	c7 d8       	rjmp	80002fee <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002ef6:	30 39       	mov	r9,3
80002ef8:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002efc:	91 09       	st.w	r8[0x0],r9
80002efe:	c7 88       	rjmp	80002fee <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002f00:	ec 0a 14 10 	asr	r10,r6,0x10
80002f04:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002f08:	90 09       	ld.sh	r9,r8[0x0]
80002f0a:	14 09       	add	r9,r10
80002f0c:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002f0e:	fe f9 0d 52 	ld.w	r9,pc[3410]
80002f12:	92 08       	ld.sh	r8,r9[0x0]
80002f14:	fe fb 0d 58 	ld.w	r11,pc[3416]
80002f18:	76 0b       	ld.w	r11,r11[0x0]
80002f1a:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002f1e:	2f f8       	sub	r8,-1
80002f20:	5c 88       	casts.h	r8
80002f22:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002f24:	fe fa 0d 38 	ld.w	r10,pc[3384]
80002f28:	94 09       	ld.sh	r9,r10[0x0]
80002f2a:	20 29       	sub	r9,2
80002f2c:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80002f2e:	30 0a       	mov	r10,0
80002f30:	f4 09 19 00 	cp.h	r9,r10
80002f34:	e0 89 00 20 	brgt	80002f74 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80002f38:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80002f3c:	e0 46 00 ba 	cp.w	r6,186
80002f40:	c0 d1       	brne	80002f5a <phy_rx_func+0x18a>
80002f42:	fe f8 0d 32 	ld.w	r8,pc[3378]
80002f46:	90 09       	ld.sh	r9,r8[0x0]
80002f48:	f4 09 19 00 	cp.h	r9,r10
80002f4c:	c0 71       	brne	80002f5a <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80002f4e:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80002f52:	70 0c       	ld.w	r12,r8[0x0]
80002f54:	f0 1f 03 49 	mcall	80003c78 <phy_rx_func+0xea8>
80002f58:	c0 98       	rjmp	80002f6a <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80002f5a:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80002f5e:	70 0c       	ld.w	r12,r8[0x0]
80002f60:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80002f64:	70 0b       	ld.w	r11,r8[0x0]
80002f66:	f0 1f 03 43 	mcall	80003c70 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80002f6a:	30 09       	mov	r9,0
80002f6c:	fe f8 0c ec 	ld.w	r8,pc[3308]
80002f70:	91 09       	st.w	r8[0x0],r9
80002f72:	c3 e8       	rjmp	80002fee <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80002f74:	5c 86       	casts.h	r6
80002f76:	fe f9 0c fe 	ld.w	r9,pc[3326]
80002f7a:	92 0a       	ld.sh	r10,r9[0x0]
80002f7c:	0c 0a       	add	r10,r6
80002f7e:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002f80:	fe f9 0c ec 	ld.w	r9,pc[3308]
80002f84:	72 09       	ld.w	r9,r9[0x0]
80002f86:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80002f8a:	2f f8       	sub	r8,-1
80002f8c:	fe f9 0c d4 	ld.w	r9,pc[3284]
80002f90:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80002f92:	fe f9 0c ca 	ld.w	r9,pc[3274]
80002f96:	92 08       	ld.sh	r8,r9[0x0]
80002f98:	20 28       	sub	r8,2
80002f9a:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80002f9c:	30 09       	mov	r9,0
80002f9e:	f2 08 19 00 	cp.h	r8,r9
80002fa2:	e0 89 00 26 	brgt	80002fee <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80002fa6:	30 39       	mov	r9,3
80002fa8:	fe f8 0c b0 	ld.w	r8,pc[3248]
80002fac:	91 09       	st.w	r8[0x0],r9
80002fae:	c2 08       	rjmp	80002fee <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80002fb0:	e6 16 00 ff 	andh	r6,0xff,COH
80002fb4:	fc 19 00 ba 	movh	r9,0xba
80002fb8:	12 36       	cp.w	r6,r9
80002fba:	c0 e1       	brne	80002fd6 <phy_rx_func+0x206>
80002fbc:	fe f8 0c b8 	ld.w	r8,pc[3256]
80002fc0:	90 09       	ld.sh	r9,r8[0x0]
80002fc2:	30 08       	mov	r8,0
80002fc4:	f0 09 19 00 	cp.h	r9,r8
80002fc8:	c0 71       	brne	80002fd6 <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80002fca:	fe f8 0c a2 	ld.w	r8,pc[3234]
80002fce:	70 0c       	ld.w	r12,r8[0x0]
80002fd0:	f0 1f 03 2a 	mcall	80003c78 <phy_rx_func+0xea8>
80002fd4:	c0 98       	rjmp	80002fe6 <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80002fd6:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002fda:	70 0c       	ld.w	r12,r8[0x0]
80002fdc:	fe f8 0c 90 	ld.w	r8,pc[3216]
80002fe0:	70 0b       	ld.w	r11,r8[0x0]
80002fe2:	f0 1f 03 24 	mcall	80003c70 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80002fe6:	30 09       	mov	r9,0
80002fe8:	fe f8 0c 70 	ld.w	r8,pc[3184]
80002fec:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80002fee:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002ff2:	11 89       	ld.ub	r9,r8[0x0]
80002ff4:	30 08       	mov	r8,0
80002ff6:	f0 09 18 00 	cp.b	r9,r8
80002ffa:	c1 31       	brne	80003020 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80002ffc:	fe f6 0c 84 	ld.w	r6,pc[3204]
80003000:	6c 0c       	ld.w	r12,r6[0x0]
80003002:	f0 1f 03 1a 	mcall	80003c68 <phy_rx_func+0xe98>
80003006:	fe f8 0c 7e 	ld.w	r8,pc[3198]
8000300a:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
8000300c:	6c 0c       	ld.w	r12,r6[0x0]
8000300e:	f0 1f 03 17 	mcall	80003c68 <phy_rx_func+0xe98>
80003012:	fe f8 0c 76 	ld.w	r8,pc[3190]
80003016:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80003018:	30 19       	mov	r9,1
8000301a:	fe f8 0c 62 	ld.w	r8,pc[3170]
8000301e:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80003020:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80003024:	70 08       	ld.w	r8,r8[0x0]
80003026:	58 28       	cp.w	r8,2
80003028:	e0 80 01 98 	breq	80003358 <phy_rx_func+0x588>
8000302c:	e0 8b 00 06 	brhi	80003038 <phy_rx_func+0x268>
80003030:	58 08       	cp.w	r8,0
80003032:	c0 b0       	breq	80003048 <phy_rx_func+0x278>
80003034:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003038:	58 38       	cp.w	r8,3
8000303a:	e0 80 05 c5 	breq	80003bc4 <phy_rx_func+0xdf4>
8000303e:	58 48       	cp.w	r8,4
80003040:	e0 81 06 05 	brne	80003c4a <phy_rx_func+0xe7a>
80003044:	e0 8f 02 4b 	bral	800034da <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80003048:	6e 28       	ld.w	r8,r7[0x8]
8000304a:	e0 6a 5a 5a 	mov	r10,23130
8000304e:	ea 1a ab cd 	orh	r10,0xabcd
80003052:	14 38       	cp.w	r8,r10
80003054:	c0 71       	brne	80003062 <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
80003056:	30 09       	mov	r9,0
80003058:	fe f8 0c 38 	ld.w	r8,pc[3128]
8000305c:	91 09       	st.w	r8[0x0],r9
8000305e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80003062:	10 99       	mov	r9,r8
80003064:	e0 19 00 00 	andl	r9,0x0
80003068:	fc 1a ab cd 	movh	r10,0xabcd
8000306c:	14 39       	cp.w	r9,r10
8000306e:	e0 81 05 ee 	brne	80003c4a <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80003072:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80003076:	fe f9 0c 1e 	ld.w	r9,pc[3102]
8000307a:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
8000307c:	6e 29       	ld.w	r9,r7[0x8]
8000307e:	e2 19 f0 00 	andl	r9,0xf000,COH
80003082:	e0 49 c0 00 	cp.w	r9,49152
80003086:	e0 81 00 ce 	brne	80003222 <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
8000308a:	30 1a       	mov	r10,1
8000308c:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80003090:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
80003092:	fe f9 0b f6 	ld.w	r9,pc[3062]
80003096:	72 09       	ld.w	r9,r9[0x0]
80003098:	58 09       	cp.w	r9,0
8000309a:	c0 71       	brne	800030a8 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
8000309c:	fe fc 0c 00 	ld.w	r12,pc[3072]
800030a0:	f0 1f 03 00 	mcall	80003ca0 <phy_rx_func+0xed0>
800030a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
800030a8:	ef 3a 00 0d 	ld.ub	r10,r7[13]
800030ac:	fe f9 0b f8 	ld.w	r9,pc[3064]
800030b0:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
800030b2:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800030b6:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
800030ba:	fe fa 0b ee 	ld.w	r10,pc[3054]
800030be:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
800030c0:	13 89       	ld.ub	r9,r9[0x0]
800030c2:	37 fa       	mov	r10,127
800030c4:	f4 09 18 00 	cp.b	r9,r10
800030c8:	c6 d0       	breq	800031a2 <phy_rx_func+0x3d2>
800030ca:	e0 8b 00 0c 	brhi	800030e2 <phy_rx_func+0x312>
800030ce:	31 2a       	mov	r10,18
800030d0:	f4 09 18 00 	cp.b	r9,r10
800030d4:	c4 20       	breq	80003158 <phy_rx_func+0x388>
800030d6:	31 3a       	mov	r10,19
800030d8:	f4 09 18 00 	cp.b	r9,r10
800030dc:	e0 81 00 83 	brne	800031e2 <phy_rx_func+0x412>
800030e0:	c5 b8       	rjmp	80003196 <phy_rx_func+0x3c6>
800030e2:	2f 09       	sub	r9,-16
800030e4:	30 1a       	mov	r10,1
800030e6:	f4 09 18 00 	cp.b	r9,r10
800030ea:	e0 8b 00 7c 	brhi	800031e2 <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
800030ee:	ef 38 00 0e 	ld.ub	r8,r7[14]
800030f2:	e2 18 00 f0 	andl	r8,0xf0,COH
800030f6:	59 08       	cp.w	r8,16
800030f8:	c0 71       	brne	80003106 <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
800030fa:	30 19       	mov	r9,1
800030fc:	fe f8 0b 94 	ld.w	r8,pc[2964]
80003100:	91 09       	st.w	r8[0x0],r9
80003102:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80003106:	e0 48 00 20 	cp.w	r8,32
8000310a:	c2 11       	brne	8000314c <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
8000310c:	30 a9       	mov	r9,10
8000310e:	fe f8 0b 82 	ld.w	r8,pc[2946]
80003112:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003114:	fe f6 0b 98 	ld.w	r6,pc[2968]
80003118:	6c 08       	ld.w	r8,r6[0x0]
8000311a:	f0 0a 11 ff 	rsub	r10,r8,-1
8000311e:	fe f7 0b 6a 	ld.w	r7,pc[2922]
80003122:	2f f8       	sub	r8,-1
80003124:	6e 0c       	ld.w	r12,r7[0x0]
80003126:	f4 ca fe 00 	sub	r10,r10,-512
8000312a:	30 0b       	mov	r11,0
8000312c:	10 0c       	add	r12,r8
8000312e:	f0 1f 02 e1 	mcall	80003cb0 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80003132:	30 08       	mov	r8,0
80003134:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80003136:	6e 0c       	ld.w	r12,r7[0x0]
80003138:	f0 1f 02 df 	mcall	80003cb4 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000313c:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003140:	70 0c       	ld.w	r12,r8[0x0]
80003142:	f0 1f 02 ca 	mcall	80003c68 <phy_rx_func+0xe98>
80003146:	8f 0c       	st.w	r7[0x0],r12
80003148:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
8000314c:	30 09       	mov	r9,0
8000314e:	fe f8 0b 42 	ld.w	r8,pc[2882]
80003152:	91 09       	st.w	r8[0x0],r9
80003154:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003158:	20 48       	sub	r8,4
8000315a:	fe f9 0b 3a 	ld.w	r9,pc[2874]
8000315e:	93 08       	st.w	r9[0x0],r8
80003160:	58 08       	cp.w	r8,0
80003162:	e0 80 05 74 	breq	80003c4a <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003166:	ef 3c 00 0f 	ld.ub	r12,r7[15]
8000316a:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
8000316e:	fe f8 0b 4a 	ld.w	r8,pc[2890]
80003172:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003174:	8e 69       	ld.sh	r9,r7[0xc]
80003176:	fe f8 0b 46 	ld.w	r8,pc[2886]
8000317a:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
8000317c:	8e 79       	ld.sh	r9,r7[0xe]
8000317e:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003180:	f0 1f 02 d0 	mcall	80003cc0 <phy_rx_func+0xef0>
80003184:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80003188:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000318a:	30 49       	mov	r9,4
8000318c:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003190:	91 09       	st.w	r8[0x0],r9
80003192:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80003196:	30 09       	mov	r9,0
80003198:	fe f8 0a f8 	ld.w	r8,pc[2808]
8000319c:	91 09       	st.w	r8[0x0],r9
8000319e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800031a2:	20 48       	sub	r8,4
800031a4:	fe f9 0a f0 	ld.w	r9,pc[2800]
800031a8:	93 08       	st.w	r9[0x0],r8
800031aa:	58 08       	cp.w	r8,0
800031ac:	e0 80 05 4f 	breq	80003c4a <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
800031b0:	fe f8 0b 14 	ld.w	r8,pc[2836]
800031b4:	70 09       	ld.w	r9,r8[0x0]
800031b6:	8e 7b       	ld.sh	r11,r7[0xe]
800031b8:	fe fa 0b 10 	ld.w	r10,pc[2832]
800031bc:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
800031c0:	2f f9       	sub	r9,-1
800031c2:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
800031c4:	fe f8 0a e4 	ld.w	r8,pc[2788]
800031c8:	70 09       	ld.w	r9,r8[0x0]
800031ca:	20 29       	sub	r9,2
800031cc:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
800031ce:	30 29       	mov	r9,2
800031d0:	fe f8 0a c0 	ld.w	r8,pc[2752]
800031d4:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
800031d6:	30 39       	mov	r9,3
800031d8:	fe f8 0a b4 	ld.w	r8,pc[2740]
800031dc:	91 09       	st.w	r8[0x0],r9
800031de:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
800031e2:	30 3a       	mov	r10,3
800031e4:	fe f9 0a ac 	ld.w	r9,pc[2732]
800031e8:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
800031ea:	6e 2a       	ld.w	r10,r7[0x8]
800031ec:	fe f9 0a e0 	ld.w	r9,pc[2784]
800031f0:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
800031f2:	6e 3a       	ld.w	r10,r7[0xc]
800031f4:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
800031f6:	59 48       	cp.w	r8,20
800031f8:	c0 61       	brne	80003204 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
800031fa:	31 89       	mov	r9,24
800031fc:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003200:	91 09       	st.w	r8[0x0],r9
80003202:	c0 a8       	rjmp	80003216 <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003204:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003208:	70 08       	ld.w	r8,r8[0x0]
8000320a:	59 08       	cp.w	r8,16
8000320c:	c0 51       	brne	80003216 <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
8000320e:	31 09       	mov	r9,16
80003210:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003214:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003216:	30 49       	mov	r9,4
80003218:	fe f8 0a 74 	ld.w	r8,pc[2676]
8000321c:	91 09       	st.w	r8[0x0],r9
8000321e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80003222:	e0 49 10 00 	cp.w	r9,4096
80003226:	5f 1a       	srne	r10
80003228:	e0 49 20 00 	cp.w	r9,8192
8000322c:	5f 19       	srne	r9
8000322e:	f5 e9 00 09 	and	r9,r10,r9
80003232:	e0 81 05 0c 	brne	80003c4a <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
80003236:	fe fa 0a 9a 	ld.w	r10,pc[2714]
8000323a:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
8000323c:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003240:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
80003242:	fe fa 0a 62 	ld.w	r10,pc[2658]
80003246:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
80003248:	fe f9 0a 3c 	ld.w	r9,pc[2620]
8000324c:	72 09       	ld.w	r9,r9[0x0]
8000324e:	58 09       	cp.w	r9,0
80003250:	c0 71       	brne	8000325e <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003252:	fe fc 0a 4a 	ld.w	r12,pc[2634]
80003256:	f0 1f 02 93 	mcall	80003ca0 <phy_rx_func+0xed0>
8000325a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000325e:	6e 2a       	ld.w	r10,r7[0x8]
80003260:	e2 1a 0f 00 	andl	r10,0xf00,COH
80003264:	58 1a       	cp.w	r10,1
80003266:	e0 8b 00 4d 	brhi	80003300 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
8000326a:	20 48       	sub	r8,4
8000326c:	fe f9 0a 28 	ld.w	r9,pc[2600]
80003270:	93 08       	st.w	r9[0x0],r8
80003272:	58 08       	cp.w	r8,0
80003274:	e0 80 04 eb 	breq	80003c4a <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
80003278:	8e 68       	ld.sh	r8,r7[0xc]
8000327a:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000327e:	fe f9 0a 5a 	ld.w	r9,pc[2650]
80003282:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
80003284:	30 09       	mov	r9,0
80003286:	f2 08 19 00 	cp.h	r8,r9
8000328a:	c0 70       	breq	80003298 <phy_rx_func+0x4c8>
8000328c:	30 19       	mov	r9,1
8000328e:	f2 08 19 00 	cp.h	r8,r9
80003292:	e0 81 04 dc 	brne	80003c4a <phy_rx_func+0xe7a>
80003296:	c2 68       	rjmp	800032e2 <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003298:	fe f8 0a 44 	ld.w	r8,pc[2628]
8000329c:	70 0a       	ld.w	r10,r8[0x0]
8000329e:	fe f9 09 e6 	ld.w	r9,pc[2534]
800032a2:	72 09       	ld.w	r9,r9[0x0]
800032a4:	8e 7b       	ld.sh	r11,r7[0xe]
800032a6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800032aa:	70 09       	ld.w	r9,r8[0x0]
800032ac:	2f f9       	sub	r9,-1
800032ae:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800032b0:	e0 49 00 ff 	cp.w	r9,255
800032b4:	e0 88 00 11 	brls	800032d6 <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
800032b8:	30 09       	mov	r9,0
800032ba:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
800032bc:	fe f7 09 c8 	ld.w	r7,pc[2504]
800032c0:	6e 0c       	ld.w	r12,r7[0x0]
800032c2:	f0 1f 02 7d 	mcall	80003cb4 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
800032c6:	fe f8 09 ba 	ld.w	r8,pc[2490]
800032ca:	70 0c       	ld.w	r12,r8[0x0]
800032cc:	f0 1f 02 67 	mcall	80003c68 <phy_rx_func+0xe98>
800032d0:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
800032d2:	e0 80 04 bc 	breq	80003c4a <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
800032d6:	30 29       	mov	r9,2
800032d8:	fe f8 09 b4 	ld.w	r8,pc[2484]
800032dc:	91 09       	st.w	r8[0x0],r9
800032de:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800032e2:	8e 79       	ld.sh	r9,r7[0xe]
800032e4:	30 38       	mov	r8,3
800032e6:	f0 09 19 00 	cp.h	r9,r8
800032ea:	c0 51       	brne	800032f4 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
800032ec:	30 19       	mov	r9,1
800032ee:	fe f8 09 f2 	ld.w	r8,pc[2546]
800032f2:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
800032f4:	30 29       	mov	r9,2
800032f6:	fe f8 09 96 	ld.w	r8,pc[2454]
800032fa:	91 09       	st.w	r8[0x0],r9
800032fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003300:	58 18       	cp.w	r8,1
80003302:	e0 88 04 a4 	brls	80003c4a <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003306:	fe f8 09 d6 	ld.w	r8,pc[2518]
8000330a:	70 0a       	ld.w	r10,r8[0x0]
8000330c:	6e 3b       	ld.w	r11,r7[0xc]
8000330e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003312:	70 09       	ld.w	r9,r8[0x0]
80003314:	2f f9       	sub	r9,-1
80003316:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003318:	e0 49 00 ff 	cp.w	r9,255
8000331c:	e0 88 00 11 	brls	8000333e <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003320:	30 09       	mov	r9,0
80003322:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003324:	fe f7 09 60 	ld.w	r7,pc[2400]
80003328:	6e 0c       	ld.w	r12,r7[0x0]
8000332a:	f0 1f 02 63 	mcall	80003cb4 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000332e:	fe f8 09 52 	ld.w	r8,pc[2386]
80003332:	70 0c       	ld.w	r12,r8[0x0]
80003334:	f0 1f 02 4d 	mcall	80003c68 <phy_rx_func+0xe98>
80003338:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
8000333a:	e0 80 04 88 	breq	80003c4a <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
8000333e:	fe f9 09 56 	ld.w	r9,pc[2390]
80003342:	72 08       	ld.w	r8,r9[0x0]
80003344:	20 28       	sub	r8,2
80003346:	93 08       	st.w	r9[0x0],r8
80003348:	e0 80 04 81 	breq	80003c4a <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
8000334c:	30 29       	mov	r9,2
8000334e:	fe f8 09 3e 	ld.w	r8,pc[2366]
80003352:	91 09       	st.w	r8[0x0],r9
80003354:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003358:	fe f8 09 84 	ld.w	r8,pc[2436]
8000335c:	70 0a       	ld.w	r10,r8[0x0]
8000335e:	fe f9 09 26 	ld.w	r9,pc[2342]
80003362:	72 09       	ld.w	r9,r9[0x0]
80003364:	8e 4b       	ld.sh	r11,r7[0x8]
80003366:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
8000336a:	70 09       	ld.w	r9,r8[0x0]
8000336c:	2f f9       	sub	r9,-1
8000336e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003370:	e0 49 00 ff 	cp.w	r9,255
80003374:	e0 88 00 16 	brls	800033a0 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
80003378:	30 09       	mov	r9,0
8000337a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000337c:	fe f6 09 08 	ld.w	r6,pc[2312]
80003380:	6c 0c       	ld.w	r12,r6[0x0]
80003382:	f0 1f 02 4d 	mcall	80003cb4 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003386:	fe f8 08 fa 	ld.w	r8,pc[2298]
8000338a:	70 0c       	ld.w	r12,r8[0x0]
8000338c:	f0 1f 02 37 	mcall	80003c68 <phy_rx_func+0xe98>
80003390:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003392:	c0 71       	brne	800033a0 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
80003394:	30 09       	mov	r9,0
80003396:	fe f8 08 f6 	ld.w	r8,pc[2294]
8000339a:	91 09       	st.w	r8[0x0],r9
8000339c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
800033a0:	fe f9 08 f4 	ld.w	r9,pc[2292]
800033a4:	72 08       	ld.w	r8,r9[0x0]
800033a6:	20 28       	sub	r8,2
800033a8:	93 08       	st.w	r9[0x0],r8
800033aa:	c0 71       	brne	800033b8 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
800033ac:	30 09       	mov	r9,0
800033ae:	fe f8 08 de 	ld.w	r8,pc[2270]
800033b2:	91 09       	st.w	r8[0x0],r9
800033b4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
800033b8:	fe f8 09 24 	ld.w	r8,pc[2340]
800033bc:	70 0a       	ld.w	r10,r8[0x0]
800033be:	fe f9 08 c6 	ld.w	r9,pc[2246]
800033c2:	72 09       	ld.w	r9,r9[0x0]
800033c4:	8e 5b       	ld.sh	r11,r7[0xa]
800033c6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800033ca:	70 09       	ld.w	r9,r8[0x0]
800033cc:	2f f9       	sub	r9,-1
800033ce:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800033d0:	e0 49 00 ff 	cp.w	r9,255
800033d4:	e0 88 00 16 	brls	80003400 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
800033d8:	30 09       	mov	r9,0
800033da:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800033dc:	fe f6 08 a8 	ld.w	r6,pc[2216]
800033e0:	6c 0c       	ld.w	r12,r6[0x0]
800033e2:	f0 1f 02 35 	mcall	80003cb4 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800033e6:	fe f8 08 9a 	ld.w	r8,pc[2202]
800033ea:	70 0c       	ld.w	r12,r8[0x0]
800033ec:	f0 1f 02 1f 	mcall	80003c68 <phy_rx_func+0xe98>
800033f0:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800033f2:	c0 71       	brne	80003400 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
800033f4:	30 09       	mov	r9,0
800033f6:	fe f8 08 96 	ld.w	r8,pc[2198]
800033fa:	91 09       	st.w	r8[0x0],r9
800033fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003400:	fe f9 08 94 	ld.w	r9,pc[2196]
80003404:	72 08       	ld.w	r8,r9[0x0]
80003406:	20 28       	sub	r8,2
80003408:	93 08       	st.w	r9[0x0],r8
8000340a:	c0 71       	brne	80003418 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
8000340c:	30 09       	mov	r9,0
8000340e:	fe f8 08 7e 	ld.w	r8,pc[2174]
80003412:	91 09       	st.w	r8[0x0],r9
80003414:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003418:	fe f8 08 c4 	ld.w	r8,pc[2244]
8000341c:	70 0a       	ld.w	r10,r8[0x0]
8000341e:	fe f9 08 66 	ld.w	r9,pc[2150]
80003422:	72 09       	ld.w	r9,r9[0x0]
80003424:	8e 6b       	ld.sh	r11,r7[0xc]
80003426:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000342a:	70 09       	ld.w	r9,r8[0x0]
8000342c:	2f f9       	sub	r9,-1
8000342e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003430:	e0 49 00 ff 	cp.w	r9,255
80003434:	e0 88 00 16 	brls	80003460 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003438:	30 09       	mov	r9,0
8000343a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000343c:	fe f6 08 48 	ld.w	r6,pc[2120]
80003440:	6c 0c       	ld.w	r12,r6[0x0]
80003442:	f0 1f 02 1d 	mcall	80003cb4 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003446:	fe f8 08 3a 	ld.w	r8,pc[2106]
8000344a:	70 0c       	ld.w	r12,r8[0x0]
8000344c:	f0 1f 02 07 	mcall	80003c68 <phy_rx_func+0xe98>
80003450:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003452:	c0 71       	brne	80003460 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
80003454:	30 09       	mov	r9,0
80003456:	fe f8 08 36 	ld.w	r8,pc[2102]
8000345a:	91 09       	st.w	r8[0x0],r9
8000345c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003460:	fe f9 08 34 	ld.w	r9,pc[2100]
80003464:	72 08       	ld.w	r8,r9[0x0]
80003466:	20 28       	sub	r8,2
80003468:	93 08       	st.w	r9[0x0],r8
8000346a:	c0 71       	brne	80003478 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
8000346c:	30 09       	mov	r9,0
8000346e:	fe f8 08 1e 	ld.w	r8,pc[2078]
80003472:	91 09       	st.w	r8[0x0],r9
80003474:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003478:	fe f8 08 64 	ld.w	r8,pc[2148]
8000347c:	70 0a       	ld.w	r10,r8[0x0]
8000347e:	fe f9 08 06 	ld.w	r9,pc[2054]
80003482:	72 09       	ld.w	r9,r9[0x0]
80003484:	8e 7b       	ld.sh	r11,r7[0xe]
80003486:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000348a:	70 09       	ld.w	r9,r8[0x0]
8000348c:	2f f9       	sub	r9,-1
8000348e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003490:	e0 49 00 ff 	cp.w	r9,255
80003494:	e0 88 00 16 	brls	800034c0 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
80003498:	30 09       	mov	r9,0
8000349a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000349c:	fe f7 07 e8 	ld.w	r7,pc[2024]
800034a0:	6e 0c       	ld.w	r12,r7[0x0]
800034a2:	f0 1f 02 05 	mcall	80003cb4 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800034a6:	fe f8 07 da 	ld.w	r8,pc[2010]
800034aa:	70 0c       	ld.w	r12,r8[0x0]
800034ac:	f0 1f 01 ef 	mcall	80003c68 <phy_rx_func+0xe98>
800034b0:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800034b2:	c0 71       	brne	800034c0 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
800034b4:	30 09       	mov	r9,0
800034b6:	fe f8 07 d6 	ld.w	r8,pc[2006]
800034ba:	91 09       	st.w	r8[0x0],r9
800034bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800034c0:	fe f9 07 d4 	ld.w	r9,pc[2004]
800034c4:	72 08       	ld.w	r8,r9[0x0]
800034c6:	20 28       	sub	r8,2
800034c8:	93 08       	st.w	r9[0x0],r8
800034ca:	e0 81 03 c0 	brne	80003c4a <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
800034ce:	30 09       	mov	r9,0
800034d0:	fe f8 07 bc 	ld.w	r8,pc[1980]
800034d4:	91 09       	st.w	r8[0x0],r9
800034d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
800034da:	fe f8 07 ca 	ld.w	r8,pc[1994]
800034de:	11 89       	ld.ub	r9,r8[0x0]
800034e0:	31 28       	mov	r8,18
800034e2:	f0 09 18 00 	cp.b	r9,r8
800034e6:	e0 81 01 4c 	brne	8000377e <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
800034ea:	ef 39 00 09 	ld.ub	r9,r7[9]
800034ee:	fe f8 07 b6 	ld.w	r8,pc[1974]
800034f2:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
800034f4:	11 89       	ld.ub	r9,r8[0x0]
800034f6:	3f 28       	mov	r8,-14
800034f8:	f0 09 18 00 	cp.b	r9,r8
800034fc:	e0 81 01 3b 	brne	80003772 <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003500:	30 19       	mov	r9,1
80003502:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003506:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003508:	6e 29       	ld.w	r9,r7[0x8]
8000350a:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
8000350e:	fe f8 07 86 	ld.w	r8,pc[1926]
80003512:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003514:	8e 59       	ld.sh	r9,r7[0xa]
80003516:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000351a:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
8000351c:	8e 69       	ld.sh	r9,r7[0xc]
8000351e:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003520:	8e 79       	ld.sh	r9,r7[0xe]
80003522:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003524:	fe f8 07 88 	ld.w	r8,pc[1928]
80003528:	fe f9 07 60 	ld.w	r9,pc[1888]
8000352c:	72 0a       	ld.w	r10,r9[0x0]
8000352e:	70 09       	ld.w	r9,r8[0x0]
80003530:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003534:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003538:	70 09       	ld.w	r9,r8[0x0]
8000353a:	2f f9       	sub	r9,-1
8000353c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000353e:	e0 49 01 ff 	cp.w	r9,511
80003542:	e0 88 00 16 	brls	8000356e <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
80003546:	30 09       	mov	r9,0
80003548:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000354a:	fe f6 07 3e 	ld.w	r6,pc[1854]
8000354e:	6c 0c       	ld.w	r12,r6[0x0]
80003550:	f0 1f 01 d9 	mcall	80003cb4 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003554:	fe f8 07 2c 	ld.w	r8,pc[1836]
80003558:	70 0c       	ld.w	r12,r8[0x0]
8000355a:	f0 1f 01 c4 	mcall	80003c68 <phy_rx_func+0xe98>
8000355e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003560:	c0 71       	brne	8000356e <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
80003562:	30 09       	mov	r9,0
80003564:	fe f8 07 28 	ld.w	r8,pc[1832]
80003568:	91 09       	st.w	r8[0x0],r9
8000356a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000356e:	fe f9 07 26 	ld.w	r9,pc[1830]
80003572:	72 08       	ld.w	r8,r9[0x0]
80003574:	20 18       	sub	r8,1
80003576:	93 08       	st.w	r9[0x0],r8
80003578:	c0 71       	brne	80003586 <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
8000357a:	30 09       	mov	r9,0
8000357c:	fe f8 07 10 	ld.w	r8,pc[1808]
80003580:	91 09       	st.w	r8[0x0],r9
80003582:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003586:	fe f8 07 26 	ld.w	r8,pc[1830]
8000358a:	fe f9 06 fe 	ld.w	r9,pc[1790]
8000358e:	72 0a       	ld.w	r10,r9[0x0]
80003590:	70 09       	ld.w	r9,r8[0x0]
80003592:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003596:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000359a:	70 09       	ld.w	r9,r8[0x0]
8000359c:	2f f9       	sub	r9,-1
8000359e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035a0:	e0 49 01 ff 	cp.w	r9,511
800035a4:	e0 88 00 16 	brls	800035d0 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
800035a8:	30 09       	mov	r9,0
800035aa:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035ac:	fe f6 06 dc 	ld.w	r6,pc[1756]
800035b0:	6c 0c       	ld.w	r12,r6[0x0]
800035b2:	f0 1f 01 c1 	mcall	80003cb4 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800035b6:	fe f8 06 ca 	ld.w	r8,pc[1738]
800035ba:	70 0c       	ld.w	r12,r8[0x0]
800035bc:	f0 1f 01 ab 	mcall	80003c68 <phy_rx_func+0xe98>
800035c0:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035c2:	c0 71       	brne	800035d0 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
800035c4:	30 09       	mov	r9,0
800035c6:	fe f8 06 c6 	ld.w	r8,pc[1734]
800035ca:	91 09       	st.w	r8[0x0],r9
800035cc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035d0:	fe f9 06 c4 	ld.w	r9,pc[1732]
800035d4:	72 08       	ld.w	r8,r9[0x0]
800035d6:	20 18       	sub	r8,1
800035d8:	93 08       	st.w	r9[0x0],r8
800035da:	c0 71       	brne	800035e8 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
800035dc:	30 09       	mov	r9,0
800035de:	fe f8 06 ae 	ld.w	r8,pc[1710]
800035e2:	91 09       	st.w	r8[0x0],r9
800035e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
800035e8:	fe f8 06 c4 	ld.w	r8,pc[1732]
800035ec:	fe f9 06 9c 	ld.w	r9,pc[1692]
800035f0:	72 0a       	ld.w	r10,r9[0x0]
800035f2:	70 09       	ld.w	r9,r8[0x0]
800035f4:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800035f8:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800035fc:	70 09       	ld.w	r9,r8[0x0]
800035fe:	2f f9       	sub	r9,-1
80003600:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003602:	e0 49 01 ff 	cp.w	r9,511
80003606:	e0 88 00 16 	brls	80003632 <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
8000360a:	30 09       	mov	r9,0
8000360c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000360e:	fe f6 06 7a 	ld.w	r6,pc[1658]
80003612:	6c 0c       	ld.w	r12,r6[0x0]
80003614:	f0 1f 01 a8 	mcall	80003cb4 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003618:	fe f8 06 68 	ld.w	r8,pc[1640]
8000361c:	70 0c       	ld.w	r12,r8[0x0]
8000361e:	f0 1f 01 93 	mcall	80003c68 <phy_rx_func+0xe98>
80003622:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003624:	c0 71       	brne	80003632 <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80003626:	30 09       	mov	r9,0
80003628:	fe f8 06 64 	ld.w	r8,pc[1636]
8000362c:	91 09       	st.w	r8[0x0],r9
8000362e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003632:	fe f9 06 62 	ld.w	r9,pc[1634]
80003636:	72 08       	ld.w	r8,r9[0x0]
80003638:	20 18       	sub	r8,1
8000363a:	93 08       	st.w	r9[0x0],r8
8000363c:	c0 71       	brne	8000364a <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
8000363e:	30 09       	mov	r9,0
80003640:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003644:	91 09       	st.w	r8[0x0],r9
80003646:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
8000364a:	fe f8 06 62 	ld.w	r8,pc[1634]
8000364e:	fe f9 06 3a 	ld.w	r9,pc[1594]
80003652:	72 0a       	ld.w	r10,r9[0x0]
80003654:	70 09       	ld.w	r9,r8[0x0]
80003656:	ef 3b 00 0d 	ld.ub	r11,r7[13]
8000365a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000365e:	70 09       	ld.w	r9,r8[0x0]
80003660:	2f f9       	sub	r9,-1
80003662:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003664:	e0 49 01 ff 	cp.w	r9,511
80003668:	e0 88 00 16 	brls	80003694 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
8000366c:	30 09       	mov	r9,0
8000366e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003670:	fe f6 06 18 	ld.w	r6,pc[1560]
80003674:	6c 0c       	ld.w	r12,r6[0x0]
80003676:	f0 1f 01 90 	mcall	80003cb4 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000367a:	fe f8 06 06 	ld.w	r8,pc[1542]
8000367e:	70 0c       	ld.w	r12,r8[0x0]
80003680:	f0 1f 01 7a 	mcall	80003c68 <phy_rx_func+0xe98>
80003684:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003686:	c0 71       	brne	80003694 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80003688:	30 09       	mov	r9,0
8000368a:	fe f8 06 02 	ld.w	r8,pc[1538]
8000368e:	91 09       	st.w	r8[0x0],r9
80003690:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003694:	fe f9 06 00 	ld.w	r9,pc[1536]
80003698:	72 08       	ld.w	r8,r9[0x0]
8000369a:	20 18       	sub	r8,1
8000369c:	93 08       	st.w	r9[0x0],r8
8000369e:	c0 71       	brne	800036ac <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
800036a0:	30 09       	mov	r9,0
800036a2:	fe f8 05 ea 	ld.w	r8,pc[1514]
800036a6:	91 09       	st.w	r8[0x0],r9
800036a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
800036ac:	fe f8 06 00 	ld.w	r8,pc[1536]
800036b0:	fe f9 05 d8 	ld.w	r9,pc[1496]
800036b4:	72 0a       	ld.w	r10,r9[0x0]
800036b6:	70 09       	ld.w	r9,r8[0x0]
800036b8:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800036bc:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800036c0:	70 09       	ld.w	r9,r8[0x0]
800036c2:	2f f9       	sub	r9,-1
800036c4:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036c6:	e0 49 01 ff 	cp.w	r9,511
800036ca:	e0 88 00 16 	brls	800036f6 <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
800036ce:	30 09       	mov	r9,0
800036d0:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800036d2:	fe f6 05 b6 	ld.w	r6,pc[1462]
800036d6:	6c 0c       	ld.w	r12,r6[0x0]
800036d8:	f0 1f 01 77 	mcall	80003cb4 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800036dc:	fe f8 05 a4 	ld.w	r8,pc[1444]
800036e0:	70 0c       	ld.w	r12,r8[0x0]
800036e2:	f0 1f 01 62 	mcall	80003c68 <phy_rx_func+0xe98>
800036e6:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800036e8:	c0 71       	brne	800036f6 <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
800036ea:	30 09       	mov	r9,0
800036ec:	fe f8 05 a0 	ld.w	r8,pc[1440]
800036f0:	91 09       	st.w	r8[0x0],r9
800036f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800036f6:	fe f9 05 9e 	ld.w	r9,pc[1438]
800036fa:	72 08       	ld.w	r8,r9[0x0]
800036fc:	20 18       	sub	r8,1
800036fe:	93 08       	st.w	r9[0x0],r8
80003700:	c0 71       	brne	8000370e <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
80003702:	30 09       	mov	r9,0
80003704:	fe f8 05 88 	ld.w	r8,pc[1416]
80003708:	91 09       	st.w	r8[0x0],r9
8000370a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
8000370e:	fe f8 05 9e 	ld.w	r8,pc[1438]
80003712:	fe f9 05 76 	ld.w	r9,pc[1398]
80003716:	72 0a       	ld.w	r10,r9[0x0]
80003718:	70 09       	ld.w	r9,r8[0x0]
8000371a:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000371e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003722:	70 09       	ld.w	r9,r8[0x0]
80003724:	2f f9       	sub	r9,-1
80003726:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003728:	e0 49 01 ff 	cp.w	r9,511
8000372c:	e0 88 00 16 	brls	80003758 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003730:	30 09       	mov	r9,0
80003732:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003734:	fe f7 05 54 	ld.w	r7,pc[1364]
80003738:	6e 0c       	ld.w	r12,r7[0x0]
8000373a:	f0 1f 01 5f 	mcall	80003cb4 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000373e:	fe f8 05 42 	ld.w	r8,pc[1346]
80003742:	70 0c       	ld.w	r12,r8[0x0]
80003744:	f0 1f 01 49 	mcall	80003c68 <phy_rx_func+0xe98>
80003748:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000374a:	c0 71       	brne	80003758 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
8000374c:	30 09       	mov	r9,0
8000374e:	fe f8 05 3e 	ld.w	r8,pc[1342]
80003752:	91 09       	st.w	r8[0x0],r9
80003754:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003758:	fe f9 05 3c 	ld.w	r9,pc[1340]
8000375c:	72 08       	ld.w	r8,r9[0x0]
8000375e:	20 18       	sub	r8,1
80003760:	93 08       	st.w	r9[0x0],r8
80003762:	e0 81 02 74 	brne	80003c4a <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
80003766:	30 09       	mov	r9,0
80003768:	fe f8 05 24 	ld.w	r8,pc[1316]
8000376c:	91 09       	st.w	r8[0x0],r9
8000376e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003772:	30 09       	mov	r9,0
80003774:	fe f8 05 18 	ld.w	r8,pc[1304]
80003778:	91 09       	st.w	r8[0x0],r9
8000377a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
8000377e:	fe f8 05 26 	ld.w	r8,pc[1318]
80003782:	11 89       	ld.ub	r9,r8[0x0]
80003784:	3f 28       	mov	r8,-14
80003786:	f0 09 18 00 	cp.b	r9,r8
8000378a:	c4 31       	brne	80003810 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
8000378c:	8e 49       	ld.sh	r9,r7[0x8]
8000378e:	fe f8 05 56 	ld.w	r8,pc[1366]
80003792:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003794:	fe f8 05 18 	ld.w	r8,pc[1304]
80003798:	fe f9 04 f0 	ld.w	r9,pc[1264]
8000379c:	72 0a       	ld.w	r10,r9[0x0]
8000379e:	70 09       	ld.w	r9,r8[0x0]
800037a0:	ef 3b 00 08 	ld.ub	r11,r7[8]
800037a4:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800037a8:	70 09       	ld.w	r9,r8[0x0]
800037aa:	2f f9       	sub	r9,-1
800037ac:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037ae:	e0 49 01 ff 	cp.w	r9,511
800037b2:	e0 88 00 16 	brls	800037de <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
800037b6:	30 09       	mov	r9,0
800037b8:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800037ba:	fe f7 04 ce 	ld.w	r7,pc[1230]
800037be:	6e 0c       	ld.w	r12,r7[0x0]
800037c0:	f0 1f 01 3d 	mcall	80003cb4 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800037c4:	fe f8 04 bc 	ld.w	r8,pc[1212]
800037c8:	70 0c       	ld.w	r12,r8[0x0]
800037ca:	f0 1f 01 28 	mcall	80003c68 <phy_rx_func+0xe98>
800037ce:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800037d0:	c0 71       	brne	800037de <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
800037d2:	30 09       	mov	r9,0
800037d4:	fe f8 04 b8 	ld.w	r8,pc[1208]
800037d8:	91 09       	st.w	r8[0x0],r9
800037da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800037de:	fe f9 04 b6 	ld.w	r9,pc[1206]
800037e2:	72 08       	ld.w	r8,r9[0x0]
800037e4:	20 18       	sub	r8,1
800037e6:	93 08       	st.w	r9[0x0],r8
800037e8:	c0 71       	brne	800037f6 <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
800037ea:	30 09       	mov	r9,0
800037ec:	fe f8 04 a0 	ld.w	r8,pc[1184]
800037f0:	91 09       	st.w	r8[0x0],r9
800037f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
800037f6:	20 18       	sub	r8,1
800037f8:	fe f9 04 9c 	ld.w	r9,pc[1180]
800037fc:	93 08       	st.w	r9[0x0],r8
800037fe:	58 08       	cp.w	r8,0
80003800:	e0 81 02 25 	brne	80003c4a <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80003804:	30 09       	mov	r9,0
80003806:	fe f8 04 86 	ld.w	r8,pc[1158]
8000380a:	91 09       	st.w	r8[0x0],r9
8000380c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003810:	fe f8 04 94 	ld.w	r8,pc[1172]
80003814:	11 89       	ld.ub	r9,r8[0x0]
80003816:	3f 38       	mov	r8,-13
80003818:	f0 09 18 00 	cp.b	r9,r8
8000381c:	e0 81 01 0c 	brne	80003a34 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003820:	8e 49       	ld.sh	r9,r7[0x8]
80003822:	fe f8 04 c2 	ld.w	r8,pc[1218]
80003826:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003828:	8e 59       	ld.sh	r9,r7[0xa]
8000382a:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
8000382c:	8e 69       	ld.sh	r9,r7[0xc]
8000382e:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003830:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003834:	fe f9 04 54 	ld.w	r9,pc[1108]
80003838:	72 0a       	ld.w	r10,r9[0x0]
8000383a:	70 09       	ld.w	r9,r8[0x0]
8000383c:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003840:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003844:	70 09       	ld.w	r9,r8[0x0]
80003846:	2f f9       	sub	r9,-1
80003848:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000384a:	e0 49 01 ff 	cp.w	r9,511
8000384e:	e0 88 00 16 	brls	8000387a <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
80003852:	30 09       	mov	r9,0
80003854:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003856:	fe f6 04 32 	ld.w	r6,pc[1074]
8000385a:	6c 0c       	ld.w	r12,r6[0x0]
8000385c:	f0 1f 01 16 	mcall	80003cb4 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003860:	fe f8 04 20 	ld.w	r8,pc[1056]
80003864:	70 0c       	ld.w	r12,r8[0x0]
80003866:	f0 1f 01 01 	mcall	80003c68 <phy_rx_func+0xe98>
8000386a:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000386c:	c0 71       	brne	8000387a <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
8000386e:	30 09       	mov	r9,0
80003870:	fe f8 04 1c 	ld.w	r8,pc[1052]
80003874:	91 09       	st.w	r8[0x0],r9
80003876:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000387a:	fe f9 04 1a 	ld.w	r9,pc[1050]
8000387e:	72 08       	ld.w	r8,r9[0x0]
80003880:	20 18       	sub	r8,1
80003882:	93 08       	st.w	r9[0x0],r8
80003884:	c0 71       	brne	80003892 <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
80003886:	30 09       	mov	r9,0
80003888:	fe f8 04 04 	ld.w	r8,pc[1028]
8000388c:	91 09       	st.w	r8[0x0],r9
8000388e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80003892:	fe f8 04 1a 	ld.w	r8,pc[1050]
80003896:	fe f9 03 f2 	ld.w	r9,pc[1010]
8000389a:	72 0a       	ld.w	r10,r9[0x0]
8000389c:	70 09       	ld.w	r9,r8[0x0]
8000389e:	ef 3b 00 09 	ld.ub	r11,r7[9]
800038a2:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800038a6:	70 09       	ld.w	r9,r8[0x0]
800038a8:	2f f9       	sub	r9,-1
800038aa:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038ac:	e0 49 01 ff 	cp.w	r9,511
800038b0:	e0 88 00 16 	brls	800038dc <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
800038b4:	30 09       	mov	r9,0
800038b6:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800038b8:	fe f6 03 d0 	ld.w	r6,pc[976]
800038bc:	6c 0c       	ld.w	r12,r6[0x0]
800038be:	f0 1f 00 fe 	mcall	80003cb4 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800038c2:	fe f8 03 be 	ld.w	r8,pc[958]
800038c6:	70 0c       	ld.w	r12,r8[0x0]
800038c8:	f0 1f 00 e8 	mcall	80003c68 <phy_rx_func+0xe98>
800038cc:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038ce:	c0 71       	brne	800038dc <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
800038d0:	30 09       	mov	r9,0
800038d2:	fe f8 03 ba 	ld.w	r8,pc[954]
800038d6:	91 09       	st.w	r8[0x0],r9
800038d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038dc:	fe f9 03 b8 	ld.w	r9,pc[952]
800038e0:	72 08       	ld.w	r8,r9[0x0]
800038e2:	20 18       	sub	r8,1
800038e4:	93 08       	st.w	r9[0x0],r8
800038e6:	c0 71       	brne	800038f4 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
800038e8:	30 09       	mov	r9,0
800038ea:	fe f8 03 a2 	ld.w	r8,pc[930]
800038ee:	91 09       	st.w	r8[0x0],r9
800038f0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
800038f4:	fe f8 03 b8 	ld.w	r8,pc[952]
800038f8:	fe f9 03 90 	ld.w	r9,pc[912]
800038fc:	72 0a       	ld.w	r10,r9[0x0]
800038fe:	70 09       	ld.w	r9,r8[0x0]
80003900:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003904:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003908:	70 09       	ld.w	r9,r8[0x0]
8000390a:	2f f9       	sub	r9,-1
8000390c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000390e:	e0 49 01 ff 	cp.w	r9,511
80003912:	e0 88 00 16 	brls	8000393e <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003916:	30 09       	mov	r9,0
80003918:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000391a:	fe f6 03 6e 	ld.w	r6,pc[878]
8000391e:	6c 0c       	ld.w	r12,r6[0x0]
80003920:	f0 1f 00 e5 	mcall	80003cb4 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003924:	fe f8 03 5c 	ld.w	r8,pc[860]
80003928:	70 0c       	ld.w	r12,r8[0x0]
8000392a:	f0 1f 00 d0 	mcall	80003c68 <phy_rx_func+0xe98>
8000392e:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003930:	c0 71       	brne	8000393e <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
80003932:	30 09       	mov	r9,0
80003934:	fe f8 03 58 	ld.w	r8,pc[856]
80003938:	91 09       	st.w	r8[0x0],r9
8000393a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000393e:	fe f9 03 56 	ld.w	r9,pc[854]
80003942:	72 08       	ld.w	r8,r9[0x0]
80003944:	20 18       	sub	r8,1
80003946:	93 08       	st.w	r9[0x0],r8
80003948:	c0 71       	brne	80003956 <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
8000394a:	30 09       	mov	r9,0
8000394c:	fe f8 03 40 	ld.w	r8,pc[832]
80003950:	91 09       	st.w	r8[0x0],r9
80003952:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003956:	fe f8 03 56 	ld.w	r8,pc[854]
8000395a:	fe f9 03 2e 	ld.w	r9,pc[814]
8000395e:	72 0a       	ld.w	r10,r9[0x0]
80003960:	70 09       	ld.w	r9,r8[0x0]
80003962:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003966:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000396a:	70 09       	ld.w	r9,r8[0x0]
8000396c:	2f f9       	sub	r9,-1
8000396e:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003970:	e0 49 01 ff 	cp.w	r9,511
80003974:	e0 88 00 16 	brls	800039a0 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003978:	30 09       	mov	r9,0
8000397a:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000397c:	fe f6 03 0c 	ld.w	r6,pc[780]
80003980:	6c 0c       	ld.w	r12,r6[0x0]
80003982:	f0 1f 00 cd 	mcall	80003cb4 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003986:	fe f8 02 fa 	ld.w	r8,pc[762]
8000398a:	70 0c       	ld.w	r12,r8[0x0]
8000398c:	f0 1f 00 b7 	mcall	80003c68 <phy_rx_func+0xe98>
80003990:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003992:	c0 71       	brne	800039a0 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
80003994:	30 09       	mov	r9,0
80003996:	fe f8 02 f6 	ld.w	r8,pc[758]
8000399a:	91 09       	st.w	r8[0x0],r9
8000399c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800039a0:	fe f9 02 f4 	ld.w	r9,pc[756]
800039a4:	72 08       	ld.w	r8,r9[0x0]
800039a6:	20 18       	sub	r8,1
800039a8:	93 08       	st.w	r9[0x0],r8
800039aa:	c0 71       	brne	800039b8 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
800039ac:	30 09       	mov	r9,0
800039ae:	fe f8 02 de 	ld.w	r8,pc[734]
800039b2:	91 09       	st.w	r8[0x0],r9
800039b4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
800039b8:	fe f8 02 f4 	ld.w	r8,pc[756]
800039bc:	fe f9 02 cc 	ld.w	r9,pc[716]
800039c0:	72 0a       	ld.w	r10,r9[0x0]
800039c2:	70 09       	ld.w	r9,r8[0x0]
800039c4:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800039c8:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800039cc:	70 09       	ld.w	r9,r8[0x0]
800039ce:	2f f9       	sub	r9,-1
800039d0:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039d2:	e0 49 01 ff 	cp.w	r9,511
800039d6:	e0 88 00 16 	brls	80003a02 <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
800039da:	30 09       	mov	r9,0
800039dc:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800039de:	fe f7 02 aa 	ld.w	r7,pc[682]
800039e2:	6e 0c       	ld.w	r12,r7[0x0]
800039e4:	f0 1f 00 b4 	mcall	80003cb4 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800039e8:	fe f8 02 98 	ld.w	r8,pc[664]
800039ec:	70 0c       	ld.w	r12,r8[0x0]
800039ee:	f0 1f 00 9f 	mcall	80003c68 <phy_rx_func+0xe98>
800039f2:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800039f4:	c0 71       	brne	80003a02 <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
800039f6:	30 09       	mov	r9,0
800039f8:	fe f8 02 94 	ld.w	r8,pc[660]
800039fc:	91 09       	st.w	r8[0x0],r9
800039fe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003a02:	fe f9 02 92 	ld.w	r9,pc[658]
80003a06:	72 08       	ld.w	r8,r9[0x0]
80003a08:	20 18       	sub	r8,1
80003a0a:	93 08       	st.w	r9[0x0],r8
80003a0c:	c0 71       	brne	80003a1a <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003a0e:	30 09       	mov	r9,0
80003a10:	fe f8 02 7c 	ld.w	r8,pc[636]
80003a14:	91 09       	st.w	r8[0x0],r9
80003a16:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003a1a:	20 18       	sub	r8,1
80003a1c:	fe f9 02 78 	ld.w	r9,pc[632]
80003a20:	93 08       	st.w	r9[0x0],r8
80003a22:	58 08       	cp.w	r8,0
80003a24:	e0 81 01 13 	brne	80003c4a <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003a28:	30 09       	mov	r9,0
80003a2a:	fe f8 02 62 	ld.w	r8,pc[610]
80003a2e:	91 09       	st.w	r8[0x0],r9
80003a30:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003a34:	fe f8 02 70 	ld.w	r8,pc[624]
80003a38:	11 89       	ld.ub	r9,r8[0x0]
80003a3a:	30 48       	mov	r8,4
80003a3c:	f0 09 18 00 	cp.b	r9,r8
80003a40:	c0 80       	breq	80003a50 <phy_rx_func+0xc80>
80003a42:	fe f8 02 62 	ld.w	r8,pc[610]
80003a46:	11 89       	ld.ub	r9,r8[0x0]
80003a48:	30 38       	mov	r8,3
80003a4a:	f0 09 18 00 	cp.b	r9,r8
80003a4e:	c1 41       	brne	80003a76 <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003a50:	6e 29       	ld.w	r9,r7[0x8]
80003a52:	fe f8 02 7a 	ld.w	r8,pc[634]
80003a56:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003a58:	6e 39       	ld.w	r9,r7[0xc]
80003a5a:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003a5c:	fe f9 02 38 	ld.w	r9,pc[568]
80003a60:	72 08       	ld.w	r8,r9[0x0]
80003a62:	20 88       	sub	r8,8
80003a64:	93 08       	st.w	r9[0x0],r8
80003a66:	e0 81 00 f2 	brne	80003c4a <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003a6a:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003a6c:	fe f9 02 20 	ld.w	r9,pc[544]
80003a70:	93 08       	st.w	r9[0x0],r8
80003a72:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003a76:	fe f8 02 2e 	ld.w	r8,pc[558]
80003a7a:	11 89       	ld.ub	r9,r8[0x0]
80003a7c:	31 38       	mov	r8,19
80003a7e:	f0 09 18 00 	cp.b	r9,r8
80003a82:	e0 81 00 9c 	brne	80003bba <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80003a86:	fe f8 02 62 	ld.w	r8,pc[610]
80003a8a:	11 88       	ld.ub	r8,r8[0x0]
80003a8c:	30 c9       	mov	r9,12
80003a8e:	f2 08 18 00 	cp.b	r8,r9
80003a92:	e0 81 00 7b 	brne	80003b88 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003a96:	8e 49       	ld.sh	r9,r7[0x8]
80003a98:	fe f8 02 54 	ld.w	r8,pc[596]
80003a9c:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003aa0:	30 09       	mov	r9,0
80003aa2:	fe f8 02 46 	ld.w	r8,pc[582]
80003aa6:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003aa8:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003aac:	3f 38       	mov	r8,-13
80003aae:	f0 09 18 00 	cp.b	r9,r8
80003ab2:	c6 61       	brne	80003b7e <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003ab4:	10 99       	mov	r9,r8
80003ab6:	4f c8       	lddpc	r8,80003ca4 <phy_rx_func+0xed4>
80003ab8:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003aba:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003abe:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003ac2:	4f 58       	lddpc	r8,80003c94 <phy_rx_func+0xec4>
80003ac4:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003ac6:	30 19       	mov	r9,1
80003ac8:	fe f8 02 0c 	ld.w	r8,pc[524]
80003acc:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003ace:	8e 79       	ld.sh	r9,r7[0xe]
80003ad0:	fe f8 02 14 	ld.w	r8,pc[532]
80003ad4:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003ad6:	4f 68       	lddpc	r8,80003cac <phy_rx_func+0xedc>
80003ad8:	4e c9       	lddpc	r9,80003c88 <phy_rx_func+0xeb8>
80003ada:	72 0a       	ld.w	r10,r9[0x0]
80003adc:	70 09       	ld.w	r9,r8[0x0]
80003ade:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003ae2:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003ae6:	70 09       	ld.w	r9,r8[0x0]
80003ae8:	2f f9       	sub	r9,-1
80003aea:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003aec:	e0 49 01 ff 	cp.w	r9,511
80003af0:	e0 88 00 13 	brls	80003b16 <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003af4:	30 09       	mov	r9,0
80003af6:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003af8:	4e 46       	lddpc	r6,80003c88 <phy_rx_func+0xeb8>
80003afa:	6c 0c       	ld.w	r12,r6[0x0]
80003afc:	f0 1f 00 6e 	mcall	80003cb4 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003b00:	4e 08       	lddpc	r8,80003c80 <phy_rx_func+0xeb0>
80003b02:	70 0c       	ld.w	r12,r8[0x0]
80003b04:	f0 1f 00 59 	mcall	80003c68 <phy_rx_func+0xe98>
80003b08:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003b0a:	c0 61       	brne	80003b16 <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003b0c:	30 09       	mov	r9,0
80003b0e:	4e 08       	lddpc	r8,80003c8c <phy_rx_func+0xebc>
80003b10:	91 09       	st.w	r8[0x0],r9
80003b12:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003b16:	4e 09       	lddpc	r9,80003c94 <phy_rx_func+0xec4>
80003b18:	72 08       	ld.w	r8,r9[0x0]
80003b1a:	20 18       	sub	r8,1
80003b1c:	93 08       	st.w	r9[0x0],r8
80003b1e:	c0 61       	brne	80003b2a <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003b20:	30 09       	mov	r9,0
80003b22:	4d b8       	lddpc	r8,80003c8c <phy_rx_func+0xebc>
80003b24:	91 09       	st.w	r8[0x0],r9
80003b26:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003b2a:	4e 18       	lddpc	r8,80003cac <phy_rx_func+0xedc>
80003b2c:	4d 79       	lddpc	r9,80003c88 <phy_rx_func+0xeb8>
80003b2e:	72 0a       	ld.w	r10,r9[0x0]
80003b30:	70 09       	ld.w	r9,r8[0x0]
80003b32:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003b36:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003b3a:	70 09       	ld.w	r9,r8[0x0]
80003b3c:	2f f9       	sub	r9,-1
80003b3e:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b40:	e0 49 01 ff 	cp.w	r9,511
80003b44:	e0 88 00 13 	brls	80003b6a <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003b48:	30 09       	mov	r9,0
80003b4a:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003b4c:	4c f7       	lddpc	r7,80003c88 <phy_rx_func+0xeb8>
80003b4e:	6e 0c       	ld.w	r12,r7[0x0]
80003b50:	f0 1f 00 59 	mcall	80003cb4 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003b54:	4c b8       	lddpc	r8,80003c80 <phy_rx_func+0xeb0>
80003b56:	70 0c       	ld.w	r12,r8[0x0]
80003b58:	f0 1f 00 44 	mcall	80003c68 <phy_rx_func+0xe98>
80003b5c:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003b5e:	c0 61       	brne	80003b6a <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003b60:	30 09       	mov	r9,0
80003b62:	4c b8       	lddpc	r8,80003c8c <phy_rx_func+0xebc>
80003b64:	91 09       	st.w	r8[0x0],r9
80003b66:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003b6a:	4c b9       	lddpc	r9,80003c94 <phy_rx_func+0xec4>
80003b6c:	72 08       	ld.w	r8,r9[0x0]
80003b6e:	20 18       	sub	r8,1
80003b70:	93 08       	st.w	r9[0x0],r8
80003b72:	c6 c1       	brne	80003c4a <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003b74:	30 09       	mov	r9,0
80003b76:	4c 68       	lddpc	r8,80003c8c <phy_rx_func+0xebc>
80003b78:	91 09       	st.w	r8[0x0],r9
80003b7a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003b7e:	30 09       	mov	r9,0
80003b80:	4c 38       	lddpc	r8,80003c8c <phy_rx_func+0xebc>
80003b82:	91 09       	st.w	r8[0x0],r9
80003b84:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003b88:	8e 4a       	ld.sh	r10,r7[0x8]
80003b8a:	4d 99       	lddpc	r9,80003cec <phy_rx_func+0xf1c>
80003b8c:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003b90:	4d 6a       	lddpc	r10,80003ce8 <phy_rx_func+0xf18>
80003b92:	15 88       	ld.ub	r8,r10[0x0]
80003b94:	f0 cb ff ff 	sub	r11,r8,-1
80003b98:	8e 5c       	ld.sh	r12,r7[0xa]
80003b9a:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003b9e:	f0 cb ff fe 	sub	r11,r8,-2
80003ba2:	8e 6c       	ld.sh	r12,r7[0xc]
80003ba4:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003ba8:	f0 cb ff fd 	sub	r11,r8,-3
80003bac:	8e 7c       	ld.sh	r12,r7[0xe]
80003bae:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003bb2:	2f c8       	sub	r8,-4
80003bb4:	b4 88       	st.b	r10[0x0],r8
80003bb6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003bba:	30 09       	mov	r9,0
80003bbc:	4b 48       	lddpc	r8,80003c8c <phy_rx_func+0xebc>
80003bbe:	91 09       	st.w	r8[0x0],r9
80003bc0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003bc4:	4c 08       	lddpc	r8,80003cc4 <phy_rx_func+0xef4>
80003bc6:	70 09       	ld.w	r9,r8[0x0]
80003bc8:	8e 4b       	ld.sh	r11,r7[0x8]
80003bca:	4c 0a       	lddpc	r10,80003cc8 <phy_rx_func+0xef8>
80003bcc:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003bd0:	2f f9       	sub	r9,-1
80003bd2:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003bd4:	4b 58       	lddpc	r8,80003ca8 <phy_rx_func+0xed8>
80003bd6:	70 09       	ld.w	r9,r8[0x0]
80003bd8:	20 29       	sub	r9,2
80003bda:	91 09       	st.w	r8[0x0],r9
80003bdc:	70 08       	ld.w	r8,r8[0x0]
80003bde:	58 08       	cp.w	r8,0
80003be0:	c2 f1       	brne	80003c3e <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003be2:	30 09       	mov	r9,0
80003be4:	4b 88       	lddpc	r8,80003cc4 <phy_rx_func+0xef4>
80003be6:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003be8:	8e 59       	ld.sh	r9,r7[0xa]
80003bea:	fe 78 82 12 	mov	r8,-32238
80003bee:	f0 09 19 00 	cp.h	r9,r8
80003bf2:	c2 11       	brne	80003c34 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003bf4:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003bf8:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003bfc:	4a f8       	lddpc	r8,80003cb8 <phy_rx_func+0xee8>
80003bfe:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003c00:	8e 59       	ld.sh	r9,r7[0xa]
80003c02:	4a f8       	lddpc	r8,80003cbc <phy_rx_func+0xeec>
80003c04:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003c06:	8e 69       	ld.sh	r9,r7[0xc]
80003c08:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003c0a:	f0 1f 00 2e 	mcall	80003cc0 <phy_rx_func+0xef0>
80003c0e:	4a 18       	lddpc	r8,80003c90 <phy_rx_func+0xec0>
80003c10:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003c12:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003c16:	31 38       	mov	r8,19
80003c18:	f0 09 18 00 	cp.b	r9,r8
80003c1c:	c0 71       	brne	80003c2a <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003c1e:	10 99       	mov	r9,r8
80003c20:	4a 18       	lddpc	r8,80003ca4 <phy_rx_func+0xed4>
80003c22:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003c24:	30 09       	mov	r9,0
80003c26:	49 c8       	lddpc	r8,80003c94 <phy_rx_func+0xec4>
80003c28:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003c2a:	30 49       	mov	r9,4
80003c2c:	49 88       	lddpc	r8,80003c8c <phy_rx_func+0xebc>
80003c2e:	91 09       	st.w	r8[0x0],r9
80003c30:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003c34:	30 09       	mov	r9,0
80003c36:	49 68       	lddpc	r8,80003c8c <phy_rx_func+0xebc>
80003c38:	91 09       	st.w	r8[0x0],r9
80003c3a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003c3e:	4a dc       	lddpc	r12,80003cf0 <phy_rx_func+0xf20>
80003c40:	f0 1f 00 18 	mcall	80003ca0 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003c44:	30 09       	mov	r9,0
80003c46:	49 28       	lddpc	r8,80003c8c <phy_rx_func+0xebc>
80003c48:	91 09       	st.w	r8[0x0],r9
80003c4a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003c4e:	00 00       	add	r0,r0
80003c50:	00 00       	add	r0,r0
80003c52:	0a a8       	st.w	r5++,r8
80003c54:	00 00       	add	r0,r0
80003c56:	0a c0       	st.b	r5++,r0
80003c58:	00 00       	add	r0,r0
80003c5a:	0a a0       	st.w	r5++,r0
80003c5c:	00 00       	add	r0,r0
80003c5e:	0a 82       	andn	r2,r5
80003c60:	00 00       	add	r0,r0
80003c62:	0a 70       	tst	r0,r5
80003c64:	00 00       	add	r0,r0
80003c66:	0a 98       	mov	r8,r5
80003c68:	80 00       	ld.sh	r0,r0[0x0]
80003c6a:	2c 50       	sub	r0,-59
80003c6c:	00 00       	add	r0,r0
80003c6e:	0a 90       	mov	r0,r5
80003c70:	80 00       	ld.sh	r0,r0[0x0]
80003c72:	2b 68       	sub	r8,-74
80003c74:	00 00       	add	r0,r0
80003c76:	0a a4       	st.w	r5++,r4
80003c78:	80 00       	ld.sh	r0,r0[0x0]
80003c7a:	2b 9c       	sub	r12,-71
80003c7c:	00 00       	add	r0,r0
80003c7e:	0a 81       	andn	r1,r5
80003c80:	00 00       	add	r0,r0
80003c82:	0a 9c       	mov	r12,r5
80003c84:	00 00       	add	r0,r0
80003c86:	0a ac       	st.w	r5++,r12
80003c88:	00 00       	add	r0,r0
80003c8a:	0a 84       	andn	r4,r5
80003c8c:	00 00       	add	r0,r0
80003c8e:	0a cc       	st.b	r5++,r12
80003c90:	00 00       	add	r0,r0
80003c92:	0a b4       	st.h	r5++,r4
80003c94:	00 00       	add	r0,r0
80003c96:	0a 6c       	and	r12,r5
80003c98:	00 00       	add	r0,r0
80003c9a:	0a 54       	eor	r4,r5
80003c9c:	80 00       	ld.sh	r0,r0[0x0]
80003c9e:	d7 8c       	*unknown*
80003ca0:	80 00       	ld.sh	r0,r0[0x0]
80003ca2:	71 5c       	ld.w	r12,r8[0x54]
80003ca4:	00 00       	add	r0,r0
80003ca6:	0a 80       	andn	r0,r5
80003ca8:	00 00       	add	r0,r0
80003caa:	0a d8       	st.w	--r5,r8
80003cac:	00 00       	add	r0,r0
80003cae:	0a b8       	st.h	r5++,r8
80003cb0:	80 00       	ld.sh	r0,r0[0x0]
80003cb2:	79 9c       	ld.w	r12,r12[0x64]
80003cb4:	80 00       	ld.sh	r0,r0[0x0]
80003cb6:	2b 84       	sub	r4,-72
80003cb8:	00 00       	add	r0,r0
80003cba:	0a 48       	or	r8,r5
80003cbc:	00 00       	add	r0,r0
80003cbe:	21 20       	sub	r0,18
80003cc0:	80 00       	ld.sh	r0,r0[0x0]
80003cc2:	2b 38       	sub	r8,-77
80003cc4:	00 00       	add	r0,r0
80003cc6:	0a 74       	tst	r4,r5
80003cc8:	00 00       	add	r0,r0
80003cca:	20 24       	sub	r4,2
80003ccc:	00 00       	add	r0,r0
80003cce:	0a 78       	tst	r8,r5
80003cd0:	00 00       	add	r0,r0
80003cd2:	0a 50       	eor	r0,r5
80003cd4:	00 00       	add	r0,r0
80003cd6:	0a 53       	eor	r3,r5
80003cd8:	00 00       	add	r0,r0
80003cda:	0a d0       	st.w	--r5,r0
80003cdc:	00 00       	add	r0,r0
80003cde:	0a 8c       	andn	r12,r5
80003ce0:	00 00       	add	r0,r0
80003ce2:	0a 58       	eor	r8,r5
80003ce4:	00 00       	add	r0,r0
80003ce6:	20 1c       	sub	r12,1
80003ce8:	00 00       	add	r0,r0
80003cea:	0a c4       	st.b	r5++,r4
80003cec:	00 00       	add	r0,r0
80003cee:	21 24       	sub	r4,18
80003cf0:	80 00       	ld.sh	r0,r0[0x0]
80003cf2:	d7 a4       	*unknown*

80003cf4 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003cf4:	d4 01       	pushm	lr
    
	static portBASE_TYPE xHigherPriorityTaskWoken;
	xHigherPriorityTaskWoken = pdFALSE;
80003cf6:	30 09       	mov	r9,0
80003cf8:	49 b8       	lddpc	r8,80003d64 <pdca_int_handler+0x70>
80003cfa:	91 09       	st.w	r8[0x0],r9
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
80003cfc:	49 b8       	lddpc	r8,80003d68 <pdca_int_handler+0x74>
80003cfe:	70 09       	ld.w	r9,r8[0x0]
80003d00:	2f f9       	sub	r9,-1
80003d02:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003d04:	49 a8       	lddpc	r8,80003d6c <pdca_int_handler+0x78>
80003d06:	11 89       	ld.ub	r9,r8[0x0]
80003d08:	ec 19 00 01 	eorl	r9,0x1
80003d0c:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003d0e:	11 89       	ld.ub	r9,r8[0x0]
80003d10:	a5 69       	lsl	r9,0x4
80003d12:	2f c9       	sub	r9,-4
80003d14:	49 7a       	lddpc	r10,80003d70 <pdca_int_handler+0x7c>
80003d16:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003d18:	fe 7a 00 40 	mov	r10,-65472
80003d1c:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003d1e:	30 39       	mov	r9,3
80003d20:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003d22:	11 8a       	ld.ub	r10,r8[0x0]
80003d24:	a5 6a       	lsl	r10,0x4
80003d26:	2f ca       	sub	r10,-4
80003d28:	49 38       	lddpc	r8,80003d74 <pdca_int_handler+0x80>
80003d2a:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003d2c:	fe 78 00 00 	mov	r8,-65536
80003d30:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003d32:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003d34:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003d36:	49 18       	lddpc	r8,80003d78 <pdca_int_handler+0x84>
80003d38:	70 08       	ld.w	r8,r8[0x0]
80003d3a:	58 08       	cp.w	r8,0
80003d3c:	c0 70       	breq	80003d4a <pdca_int_handler+0x56>
80003d3e:	48 c9       	lddpc	r9,80003d6c <pdca_int_handler+0x78>
80003d40:	13 89       	ld.ub	r9,r9[0x0]
80003d42:	a5 69       	lsl	r9,0x4
80003d44:	48 cc       	lddpc	r12,80003d74 <pdca_int_handler+0x80>
80003d46:	12 0c       	add	r12,r9
80003d48:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003d4a:	48 d8       	lddpc	r8,80003d7c <pdca_int_handler+0x88>
80003d4c:	70 08       	ld.w	r8,r8[0x0]
80003d4e:	58 08       	cp.w	r8,0
80003d50:	c0 70       	breq	80003d5e <pdca_int_handler+0x6a>
80003d52:	48 79       	lddpc	r9,80003d6c <pdca_int_handler+0x78>
80003d54:	13 89       	ld.ub	r9,r9[0x0]
80003d56:	a5 69       	lsl	r9,0x4
80003d58:	48 6c       	lddpc	r12,80003d70 <pdca_int_handler+0x7c>
80003d5a:	12 0c       	add	r12,r9
80003d5c:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003d5e:	d4 02       	popm	lr
80003d60:	d6 03       	rete
80003d62:	00 00       	add	r0,r0
80003d64:	00 00       	add	r0,r0
80003d66:	0a e0       	st.h	--r5,r0
80003d68:	00 00       	add	r0,r0
80003d6a:	0a e4       	st.h	--r5,r4
80003d6c:	00 00       	add	r0,r0
80003d6e:	53 44       	stdsp	sp[0xd0],r4
80003d70:	00 00       	add	r0,r0
80003d72:	53 6c       	stdsp	sp[0xd8],r12
80003d74:	00 00       	add	r0,r0
80003d76:	53 4c       	stdsp	sp[0xd0],r12
80003d78:	00 00       	add	r0,r0
80003d7a:	0a dc       	st.w	--r5,r12
80003d7c:	00 00       	add	r0,r0
80003d7e:	0a e8       	st.h	--r5,r8

80003d80 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003d80:	fe 78 10 00 	mov	r8,-61440
80003d84:	e0 69 0d c0 	mov	r9,3520
80003d88:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003d8c:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003d90:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003d94:	fe 78 34 00 	mov	r8,-52224
80003d98:	e0 69 80 00 	mov	r9,32768
80003d9c:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003d9e:	30 09       	mov	r9,0
80003da0:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003da2:	e0 69 04 21 	mov	r9,1057
80003da6:	ea 19 3f 20 	orh	r9,0x3f20
80003daa:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80003dac:	e0 69 02 9f 	mov	r9,671
80003db0:	ea 19 01 00 	orh	r9,0x100
80003db4:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80003db6:	e0 6a 04 02 	mov	r10,1026
80003dba:	ea 1a 3f 20 	orh	r10,0x3f20
80003dbe:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80003dc0:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003dc2:	5e fc       	retal	r12

80003dc4 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003dc4:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003dc6:	30 19       	mov	r9,1
80003dc8:	49 78       	lddpc	r8,80003e24 <local_start_PDC+0x60>
80003dca:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003dcc:	fe 78 00 00 	mov	r8,-65536
80003dd0:	30 7b       	mov	r11,7
80003dd2:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003dd4:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003dd6:	49 59       	lddpc	r9,80003e28 <local_start_PDC+0x64>
80003dd8:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003ddc:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003dde:	30 3a       	mov	r10,3
80003de0:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003de2:	30 1c       	mov	r12,1
80003de4:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003de6:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003de8:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003dea:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003dec:	30 2c       	mov	r12,2
80003dee:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003df0:	48 f9       	lddpc	r9,80003e2c <local_start_PDC+0x68>
80003df2:	e0 68 5a 5a 	mov	r8,23130
80003df6:	ea 18 ab cd 	orh	r8,0xabcd
80003dfa:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003dfc:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003dfe:	30 0e       	mov	lr,0
80003e00:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003e02:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003e04:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003e06:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003e08:	fe 78 00 40 	mov	r8,-65472
80003e0c:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003e0e:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003e10:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003e14:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003e16:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003e18:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003e1a:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003e1c:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003e1e:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003e20:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003e22:	d8 02       	popm	pc
80003e24:	00 00       	add	r0,r0
80003e26:	53 44       	stdsp	sp[0xd0],r4
80003e28:	00 00       	add	r0,r0
80003e2a:	53 4c       	stdsp	sp[0xd0],r12
80003e2c:	00 00       	add	r0,r0
80003e2e:	53 6c       	stdsp	sp[0xd8],r12

80003e30 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003e30:	48 38       	lddpc	r8,80003e3c <register_rx_tx_func+0xc>
80003e32:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003e34:	48 38       	lddpc	r8,80003e40 <register_rx_tx_func+0x10>
80003e36:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003e38:	5e fc       	retal	r12
80003e3a:	00 00       	add	r0,r0
80003e3c:	00 00       	add	r0,r0
80003e3e:	0a dc       	st.w	--r5,r12
80003e40:	00 00       	add	r0,r0
80003e42:	0a e8       	st.h	--r5,r8

80003e44 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003e44:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003e46:	fe 78 10 00 	mov	r8,-61440
80003e4a:	30 29       	mov	r9,2
80003e4c:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003e50:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80003e54:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
80003e56:	30 3a       	mov	r10,3
80003e58:	36 0b       	mov	r11,96
80003e5a:	49 4c       	lddpc	r12,80003ea8 <ssc_init+0x64>
80003e5c:	f0 1f 00 14 	mcall	80003eac <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
80003e60:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003e62:	fe 79 10 00 	mov	r9,-61440
80003e66:	f2 f8 01 60 	ld.w	r8,r9[352]
80003e6a:	e2 18 00 02 	andl	r8,0x2,COH
80003e6e:	cf c0       	breq	80003e66 <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003e70:	fe 79 10 00 	mov	r9,-61440
80003e74:	f2 f8 01 60 	ld.w	r8,r9[352]
80003e78:	e2 18 00 02 	andl	r8,0x2,COH
80003e7c:	cf c1       	brne	80003e74 <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
80003e7e:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80003e80:	f0 1f 00 0c 	mcall	80003eb0 <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
80003e84:	f0 1f 00 0c 	mcall	80003eb4 <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003e88:	fe 79 00 00 	mov	r9,-65536
80003e8c:	30 18       	mov	r8,1
80003e8e:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003e90:	fe 7a 00 40 	mov	r10,-65472
80003e94:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003e96:	e0 6b 01 01 	mov	r11,257
80003e9a:	fe 7a 34 00 	mov	r10,-52224
80003e9e:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80003ea0:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80003ea2:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80003ea4:	d8 02       	popm	pc
80003ea6:	00 00       	add	r0,r0
80003ea8:	80 00       	ld.sh	r0,r0[0x0]
80003eaa:	3c f4       	mov	r4,-49
80003eac:	80 00       	ld.sh	r0,r0[0x0]
80003eae:	54 38       	stdsp	sp[0x10c],r8
80003eb0:	80 00       	ld.sh	r0,r0[0x0]
80003eb2:	3d 80       	mov	r0,-40
80003eb4:	80 00       	ld.sh	r0,r0[0x0]
80003eb6:	3d c4       	mov	r4,-36

80003eb8 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003eb8:	48 28       	lddpc	r8,80003ec0 <xcmp_register_app_list+0x8>
80003eba:	91 0c       	st.w	r8[0x0],r12
}
80003ebc:	5e fc       	retal	r12
80003ebe:	00 00       	add	r0,r0
80003ec0:	00 00       	add	r0,r0
80003ec2:	53 8c       	stdsp	sp[0xe0],r12

80003ec4 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003ec4:	eb cd 40 80 	pushm	r7,lr
80003ec8:	fa cd 01 00 	sub	sp,sp,256
80003ecc:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003ece:	16 98       	mov	r8,r11
80003ed0:	2f 08       	sub	r8,-16
80003ed2:	af a8       	sbr	r8,0xe
80003ed4:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003ed6:	3f f8       	mov	r8,-1
80003ed8:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003eda:	30 b9       	mov	r9,11
80003edc:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003ede:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003ee0:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003ee2:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003ee4:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003ee6:	f6 ca ff fe 	sub	r10,r11,-2
80003eea:	18 9b       	mov	r11,r12
80003eec:	fa cc ff f0 	sub	r12,sp,-16
80003ef0:	f0 1f 00 05 	mcall	80003f04 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003ef4:	2f e7       	sub	r7,-2
80003ef6:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003ef8:	1a 9c       	mov	r12,sp
80003efa:	f0 1f 00 04 	mcall	80003f08 <xcmp_tx+0x44>
}
80003efe:	2c 0d       	sub	sp,-256
80003f00:	e3 cd 80 80 	ldm	sp++,r7,pc
80003f04:	80 00       	ld.sh	r0,r0[0x0]
80003f06:	78 54       	ld.w	r4,r12[0x14]
80003f08:	80 00       	ld.sh	r0,r0[0x0]
80003f0a:	44 d0       	lddsp	r0,sp[0x134]

80003f0c <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80003f0c:	d4 21       	pushm	r4-r7,lr
80003f0e:	fa cd 00 d0 	sub	sp,sp,208
80003f12:	18 94       	mov	r4,r12
80003f14:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003f16:	e0 68 01 00 	mov	r8,256
80003f1a:	f0 0b 19 00 	cp.h	r11,r8
80003f1e:	e0 8b 00 36 	brhi	80003f8a <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003f22:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003f26:	e0 68 04 1d 	mov	r8,1053
80003f2a:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003f2c:	30 18       	mov	r8,1
80003f2e:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80003f30:	32 08       	mov	r8,32
80003f32:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003f34:	30 28       	mov	r8,2
80003f36:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003f38:	30 48       	mov	r8,4
80003f3a:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80003f3c:	ea 1a 0c 00 	orh	r10,0xc00
80003f40:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80003f42:	30 4a       	mov	r10,4
80003f44:	1a 9b       	mov	r11,sp
80003f46:	fa cc ff f4 	sub	r12,sp,-12
80003f4a:	f0 1f 00 12 	mcall	80003f90 <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80003f4e:	30 f8       	mov	r8,15
80003f50:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80003f54:	3a 78       	mov	r8,-89
80003f56:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80003f5a:	30 08       	mov	r8,0
80003f5c:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80003f60:	0e 9a       	mov	r10,r7
80003f62:	5c 7a       	castu.h	r10
80003f64:	f4 08 16 08 	lsr	r8,r10,0x8
80003f68:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80003f6c:	0e 96       	mov	r6,r7
80003f6e:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80003f72:	08 9b       	mov	r11,r4
80003f74:	fa cc ff eb 	sub	r12,sp,-21
80003f78:	f0 1f 00 06 	mcall	80003f90 <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80003f7c:	ee cb ff f3 	sub	r11,r7,-13
80003f80:	5c 5b       	castu.b	r11
80003f82:	fa cc ff fa 	sub	r12,sp,-6
80003f86:	f0 1f 00 04 	mcall	80003f94 <xcmp_data_session_req+0x88>
}
80003f8a:	2c cd       	sub	sp,-208
80003f8c:	d8 22       	popm	r4-r7,pc
80003f8e:	00 00       	add	r0,r0
80003f90:	80 00       	ld.sh	r0,r0[0x0]
80003f92:	78 54       	ld.w	r4,r12[0x14]
80003f94:	80 00       	ld.sh	r0,r0[0x0]
80003f96:	3e c4       	mov	r4,-20

80003f98 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003f98:	d4 01       	pushm	lr
80003f9a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003f9e:	fe 78 b4 00 	mov	r8,-19456
80003fa2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003fa4:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003fa8:	30 89       	mov	r9,8
80003faa:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003fac:	30 19       	mov	r9,1
80003fae:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003fb0:	30 09       	mov	r9,0
80003fb2:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003fb4:	30 5a       	mov	r10,5
80003fb6:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003fb8:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003fba:	30 7a       	mov	r10,7
80003fbc:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003fbe:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003fc0:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003fc2:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003fc6:	30 9b       	mov	r11,9
80003fc8:	fa cc ff fe 	sub	r12,sp,-2
80003fcc:	f0 1f 00 02 	mcall	80003fd4 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003fd0:	2c dd       	sub	sp,-204
80003fd2:	d8 02       	popm	pc
80003fd4:	80 00       	ld.sh	r0,r0[0x0]
80003fd6:	3e c4       	mov	r4,-20

80003fd8 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003fd8:	d4 01       	pushm	lr
80003fda:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003fde:	fe 78 80 00 	mov	r8,-32768
80003fe2:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003fe4:	30 38       	mov	r8,3
80003fe6:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80003fe8:	30 1b       	mov	r11,1
80003fea:	fa cc ff fe 	sub	r12,sp,-2
80003fee:	f0 1f 00 03 	mcall	80003ff8 <xcmp_opcode_not_supported+0x20>
}
80003ff2:	2c dd       	sub	sp,-204
80003ff4:	d8 02       	popm	pc
80003ff6:	00 00       	add	r0,r0
80003ff8:	80 00       	ld.sh	r0,r0[0x0]
80003ffa:	3e c4       	mov	r4,-20

80003ffc <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80003ffc:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80003ffe:	96 88       	ld.uh	r8,r11[0x0]
80004000:	e2 18 f0 00 	andl	r8,0xf000,COH
80004004:	e0 48 80 00 	cp.w	r8,32768
80004008:	c0 f0       	breq	80004026 <xcmp_exec_func+0x2a>
8000400a:	e0 48 b0 00 	cp.w	r8,45056
8000400e:	c1 20       	breq	80004032 <xcmp_exec_func+0x36>
80004010:	58 08       	cp.w	r8,0
80004012:	c1 51       	brne	8000403c <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80004014:	78 08       	ld.w	r8,r12[0x0]
80004016:	58 08       	cp.w	r8,0
80004018:	c0 40       	breq	80004020 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
8000401a:	16 9c       	mov	r12,r11
8000401c:	5d 18       	icall	r8
8000401e:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004020:	f0 1f 00 08 	mcall	80004040 <xcmp_exec_func+0x44>
80004024:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80004026:	78 18       	ld.w	r8,r12[0x4]
80004028:	58 08       	cp.w	r8,0
8000402a:	c0 90       	breq	8000403c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
8000402c:	16 9c       	mov	r12,r11
8000402e:	5d 18       	icall	r8
80004030:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80004032:	78 28       	ld.w	r8,r12[0x8]
80004034:	58 08       	cp.w	r8,0
80004036:	c0 30       	breq	8000403c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004038:	16 9c       	mov	r12,r11
8000403a:	5d 18       	icall	r8
8000403c:	d8 02       	popm	pc
8000403e:	00 00       	add	r0,r0
80004040:	80 00       	ld.sh	r0,r0[0x0]
80004042:	3f d8       	mov	r8,-3

80004044 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80004044:	d4 01       	pushm	lr
80004046:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
8000404a:	e0 68 04 09 	mov	r8,1033
8000404e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004050:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80004054:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
80004056:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
8000405a:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
8000405c:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
8000405e:	30 09       	mov	r9,0
80004060:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80004062:	fb 69 00 08 	st.b	sp[8],r9
80004066:	fa c8 ff f7 	sub	r8,sp,-9
8000406a:	b0 89       	st.b	r8[0x0],r9
8000406c:	fa c8 ff f6 	sub	r8,sp,-10
80004070:	b0 89       	st.b	r8[0x0],r9
80004072:	fa c8 ff f5 	sub	r8,sp,-11
80004076:	b0 89       	st.b	r8[0x0],r9
80004078:	fa c8 ff f4 	sub	r8,sp,-12
8000407c:	b0 89       	st.b	r8[0x0],r9
8000407e:	fa c8 ff f3 	sub	r8,sp,-13
80004082:	b0 89       	st.b	r8[0x0],r9
80004084:	fa c8 ff f2 	sub	r8,sp,-14
80004088:	b0 89       	st.b	r8[0x0],r9
8000408a:	fa c8 ff f1 	sub	r8,sp,-15
8000408e:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80004090:	30 cb       	mov	r11,12
80004092:	fa cc ff fe 	sub	r12,sp,-2
80004096:	f0 1f 00 03 	mcall	800040a0 <xcmp_IdleTestTone+0x5c>
}
8000409a:	2c dd       	sub	sp,-204
8000409c:	d8 02       	popm	pc
8000409e:	00 00       	add	r0,r0
800040a0:	80 00       	ld.sh	r0,r0[0x0]
800040a2:	3e c4       	mov	r4,-20

800040a4 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
800040a4:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
800040a6:	48 dc       	lddpc	r12,800040d8 <xcmp_init+0x34>
800040a8:	f0 1f 00 0d 	mcall	800040dc <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
800040ac:	30 4b       	mov	r11,4
800040ae:	31 4c       	mov	r12,20
800040b0:	f0 1f 00 0c 	mcall	800040e0 <xcmp_init+0x3c>
800040b4:	48 c8       	lddpc	r8,800040e4 <xcmp_init+0x40>
800040b6:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
800040b8:	30 09       	mov	r9,0
800040ba:	1a d9       	st.w	--sp,r9
800040bc:	1a d9       	st.w	--sp,r9
800040be:	1a d9       	st.w	--sp,r9
800040c0:	30 38       	mov	r8,3
800040c2:	e0 6a 04 00 	mov	r10,1024
800040c6:	48 9b       	lddpc	r11,800040e8 <xcmp_init+0x44>
800040c8:	48 9c       	lddpc	r12,800040ec <xcmp_init+0x48>
800040ca:	f0 1f 00 0a 	mcall	800040f0 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
800040ce:	f0 1f 00 0a 	mcall	800040f4 <xcmp_init+0x50>
800040d2:	2f dd       	sub	sp,-12
	
}
800040d4:	d8 02       	popm	pc
800040d6:	00 00       	add	r0,r0
800040d8:	80 00       	ld.sh	r0,r0[0x0]
800040da:	41 f4       	lddsp	r4,sp[0x7c]
800040dc:	80 00       	ld.sh	r0,r0[0x0]
800040de:	42 40       	lddsp	r0,sp[0x90]
800040e0:	80 00       	ld.sh	r0,r0[0x0]
800040e2:	64 f0       	ld.w	r0,r2[0x3c]
800040e4:	00 00       	add	r0,r0
800040e6:	0b 04       	ld.w	r4,r5++
800040e8:	80 00       	ld.sh	r0,r0[0x0]
800040ea:	d7 d0       	acall	0x7d
800040ec:	80 00       	ld.sh	r0,r0[0x0]
800040ee:	40 f8       	lddsp	r8,sp[0x3c]
800040f0:	80 00       	ld.sh	r0,r0[0x0]
800040f2:	6c 0c       	ld.w	r12,r6[0x0]
800040f4:	80 00       	ld.sh	r0,r0[0x0]
800040f6:	42 78       	lddsp	r8,sp[0x9c]

800040f8 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
800040f8:	d4 31       	pushm	r0-r7,lr
800040fa:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800040fc:	4b 16       	lddpc	r6,800041c0 <xcmp_rx_process+0xc8>
800040fe:	30 05       	mov	r5,0
80004100:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004102:	4b 13       	lddpc	r3,800041c4 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004104:	4b 12       	lddpc	r2,800041c8 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004106:	4b 21       	lddpc	r1,800041cc <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004108:	4b 20       	lddpc	r0,800041d0 <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000410a:	6c 0c       	ld.w	r12,r6[0x0]
8000410c:	0a 99       	mov	r9,r5
8000410e:	08 9a       	mov	r10,r4
80004110:	1a 9b       	mov	r11,sp
80004112:	f0 1f 00 31 	mcall	800041d4 <xcmp_rx_process+0xdc>
80004116:	58 1c       	cp.w	r12,1
80004118:	cf 91       	brne	8000410a <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
8000411a:	40 0b       	lddsp	r11,sp[0x0]
8000411c:	58 0b       	cp.w	r11,0
8000411e:	cf 60       	breq	8000410a <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
80004120:	96 0a       	ld.sh	r10,r11[0x0]
80004122:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004126:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
8000412a:	59 c8       	cp.w	r8,28
8000412c:	c1 e0       	breq	80004168 <xcmp_rx_process+0x70>
8000412e:	e0 89 00 07 	brgt	8000413c <xcmp_rx_process+0x44>
80004132:	58 e8       	cp.w	r8,14
80004134:	c0 e0       	breq	80004150 <xcmp_rx_process+0x58>
80004136:	58 f8       	cp.w	r8,15
80004138:	c2 41       	brne	80004180 <xcmp_rx_process+0x88>
8000413a:	c0 f8       	rjmp	80004158 <xcmp_rx_process+0x60>
8000413c:	e0 48 01 09 	cp.w	r8,265
80004140:	c1 80       	breq	80004170 <xcmp_rx_process+0x78>
80004142:	e0 48 01 0a 	cp.w	r8,266
80004146:	c1 90       	breq	80004178 <xcmp_rx_process+0x80>
80004148:	e0 48 00 2c 	cp.w	r8,44
8000414c:	c1 a1       	brne	80004180 <xcmp_rx_process+0x88>
8000414e:	c0 98       	rjmp	80004160 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004150:	4a 2c       	lddpc	r12,800041d8 <xcmp_rx_process+0xe0>
80004152:	f0 1f 00 23 	mcall	800041dc <xcmp_rx_process+0xe4>
					break;
80004156:	c2 f8       	rjmp	800041b4 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004158:	4a 2c       	lddpc	r12,800041e0 <xcmp_rx_process+0xe8>
8000415a:	f0 1f 00 21 	mcall	800041dc <xcmp_rx_process+0xe4>
					break;
8000415e:	c2 b8       	rjmp	800041b4 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004160:	4a 1c       	lddpc	r12,800041e4 <xcmp_rx_process+0xec>
80004162:	f0 1f 00 1f 	mcall	800041dc <xcmp_rx_process+0xe4>
					break;
80004166:	c2 78       	rjmp	800041b4 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004168:	04 9c       	mov	r12,r2
8000416a:	f0 1f 00 1d 	mcall	800041dc <xcmp_rx_process+0xe4>
						, ptr);
					break;
8000416e:	c2 38       	rjmp	800041b4 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004170:	02 9c       	mov	r12,r1
80004172:	f0 1f 00 1b 	mcall	800041dc <xcmp_rx_process+0xe4>
					break;
80004176:	c1 f8       	rjmp	800041b4 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004178:	00 9c       	mov	r12,r0
8000417a:	f0 1f 00 19 	mcall	800041dc <xcmp_rx_process+0xe4>
					break;
8000417e:	c1 b8       	rjmp	800041b4 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004180:	12 98       	mov	r8,r9
80004182:	e2 18 04 00 	andl	r8,0x400,COH
80004186:	c0 70       	breq	80004194 <xcmp_rx_process+0x9c>
80004188:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000418c:	e0 48 00 68 	cp.w	r8,104
80004190:	e0 8a 00 08 	brle	800041a0 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004194:	e2 19 f0 00 	andl	r9,0xf000,COH
80004198:	c0 e1       	brne	800041b4 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
8000419a:	f0 1f 00 14 	mcall	800041e8 <xcmp_rx_process+0xf0>
8000419e:	c0 b8       	rjmp	800041b4 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800041a0:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800041a4:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800041a8:	49 19       	lddpc	r9,800041ec <xcmp_rx_process+0xf4>
800041aa:	72 08       	ld.w	r8,r9[0x0]
800041ac:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800041b0:	f0 1f 00 0b 	mcall	800041dc <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800041b4:	66 0c       	ld.w	r12,r3[0x0]
800041b6:	40 0b       	lddsp	r11,sp[0x0]
800041b8:	f0 1f 00 0e 	mcall	800041f0 <xcmp_rx_process+0xf8>
800041bc:	ca 7b       	rjmp	8000410a <xcmp_rx_process+0x12>
800041be:	00 00       	add	r0,r0
800041c0:	00 00       	add	r0,r0
800041c2:	0b 04       	ld.w	r4,r5++
800041c4:	00 00       	add	r0,r0
800041c6:	0a 98       	mov	r8,r5
800041c8:	00 00       	add	r0,r0
800041ca:	0b 14       	ld.sh	r4,r5++
800041cc:	00 00       	add	r0,r0
800041ce:	0b 08       	ld.w	r8,r5++
800041d0:	00 00       	add	r0,r0
800041d2:	0a f8       	st.b	--r5,r8
800041d4:	80 00       	ld.sh	r0,r0[0x0]
800041d6:	61 8c       	ld.w	r12,r0[0x60]
800041d8:	00 00       	add	r0,r0
800041da:	0b 2c       	ld.uh	r12,r5++
800041dc:	80 00       	ld.sh	r0,r0[0x0]
800041de:	3f fc       	mov	r12,-1
800041e0:	00 00       	add	r0,r0
800041e2:	0a ec       	st.h	--r5,r12
800041e4:	00 00       	add	r0,r0
800041e6:	0b 20       	ld.uh	r0,r5++
800041e8:	80 00       	ld.sh	r0,r0[0x0]
800041ea:	3f d8       	mov	r8,-3
800041ec:	00 00       	add	r0,r0
800041ee:	53 8c       	stdsp	sp[0xe0],r12
800041f0:	80 00       	ld.sh	r0,r0[0x0]
800041f2:	2b d4       	sub	r4,-67

800041f4 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800041f4:	eb cd 40 90 	pushm	r4,r7,lr
800041f8:	20 1d       	sub	sp,4
800041fa:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800041fe:	48 c8       	lddpc	r8,8000422c <xcmp_rx+0x38>
80004200:	70 0c       	ld.w	r12,r8[0x0]
80004202:	f0 1f 00 0c 	mcall	80004230 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80004206:	c1 00       	breq	80004226 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004208:	fa c7 ff fc 	sub	r7,sp,-4
8000420c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
8000420e:	e0 6a 00 ca 	mov	r10,202
80004212:	08 9b       	mov	r11,r4
80004214:	f0 1f 00 08 	mcall	80004234 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004218:	48 88       	lddpc	r8,80004238 <xcmp_rx+0x44>
8000421a:	70 0c       	ld.w	r12,r8[0x0]
8000421c:	30 09       	mov	r9,0
8000421e:	12 9a       	mov	r10,r9
80004220:	1a 9b       	mov	r11,sp
80004222:	f0 1f 00 07 	mcall	8000423c <xcmp_rx+0x48>
	}	
}
80004226:	2f fd       	sub	sp,-4
80004228:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
8000422c:	00 00       	add	r0,r0
8000422e:	0a 98       	mov	r8,r5
80004230:	80 00       	ld.sh	r0,r0[0x0]
80004232:	2d 80       	sub	r0,-40
80004234:	80 00       	ld.sh	r0,r0[0x0]
80004236:	78 54       	ld.w	r4,r12[0x14]
80004238:	00 00       	add	r0,r0
8000423a:	0b 04       	ld.w	r4,r5++
8000423c:	80 00       	ld.sh	r0,r0[0x0]
8000423e:	63 98       	ld.w	r8,r1[0x64]

80004240 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004240:	48 28       	lddpc	r8,80004248 <xnl_register_xcmp_func+0x8>
80004242:	91 0c       	st.w	r8[0x0],r12
}
80004244:	5e fc       	retal	r12
80004246:	00 00       	add	r0,r0
80004248:	00 00       	add	r0,r0
8000424a:	0b 58       	ld.sh	r8,--r5

8000424c <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
8000424c:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
8000424e:	48 88       	lddpc	r8,8000426c <xnl_get_msg_ack_func+0x20>
80004250:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004252:	98 49       	ld.sh	r9,r12[0x8]
80004254:	f0 09 19 00 	cp.h	r9,r8
80004258:	c0 81       	brne	80004268 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
8000425a:	48 68       	lddpc	r8,80004270 <xnl_get_msg_ack_func+0x24>
8000425c:	70 0c       	ld.w	r12,r8[0x0]
8000425e:	30 09       	mov	r9,0
80004260:	12 9a       	mov	r10,r9
80004262:	12 9b       	mov	r11,r9
80004264:	f0 1f 00 04 	mcall	80004274 <xnl_get_msg_ack_func+0x28>
80004268:	d8 02       	popm	pc
8000426a:	00 00       	add	r0,r0
8000426c:	00 00       	add	r0,r0
8000426e:	0b 3e       	ld.ub	lr,r5++
80004270:	00 00       	add	r0,r0
80004272:	0b 38       	ld.ub	r8,r5++
80004274:	80 00       	ld.sh	r0,r0[0x0]
80004276:	63 98       	ld.w	r8,r1[0x64]

80004278 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004278:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
8000427c:	30 09       	mov	r9,0
8000427e:	4b 78       	lddpc	r8,80004358 <xnl_init+0xe0>
80004280:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004282:	30 0b       	mov	r11,0
80004284:	30 1c       	mov	r12,1
80004286:	f0 1f 00 36 	mcall	8000435c <xnl_init+0xe4>
8000428a:	4b 68       	lddpc	r8,80004360 <xnl_init+0xe8>
8000428c:	91 0c       	st.w	r8[0x0],r12
8000428e:	70 08       	ld.w	r8,r8[0x0]
80004290:	58 08       	cp.w	r8,0
80004292:	c0 80       	breq	800042a2 <xnl_init+0x2a>
80004294:	4b 38       	lddpc	r8,80004360 <xnl_init+0xe8>
80004296:	70 0c       	ld.w	r12,r8[0x0]
80004298:	30 09       	mov	r9,0
8000429a:	12 9a       	mov	r10,r9
8000429c:	12 9b       	mov	r11,r9
8000429e:	f0 1f 00 32 	mcall	80004364 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
800042a2:	30 4b       	mov	r11,4
800042a4:	31 4c       	mov	r12,20
800042a6:	f0 1f 00 2e 	mcall	8000435c <xnl_init+0xe4>
800042aa:	4b 08       	lddpc	r8,80004368 <xnl_init+0xf0>
800042ac:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800042ae:	30 4b       	mov	r11,4
800042b0:	31 ec       	mov	r12,30
800042b2:	f0 1f 00 2b 	mcall	8000435c <xnl_init+0xe4>
800042b6:	4a e8       	lddpc	r8,8000436c <xnl_init+0xf4>
800042b8:	91 0c       	st.w	r8[0x0],r12
800042ba:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800042bc:	10 96       	mov	r6,r8
800042be:	4a d5       	lddpc	r5,80004370 <xnl_init+0xf8>
800042c0:	6c 0c       	ld.w	r12,r6[0x0]
800042c2:	ea 07 00 0b 	add	r11,r5,r7
800042c6:	f0 1f 00 2c 	mcall	80004374 <xnl_init+0xfc>
800042ca:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
800042ce:	e0 47 1e 00 	cp.w	r7,7680
800042d2:	cf 71       	brne	800042c0 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800042d4:	30 4b       	mov	r11,4
800042d6:	31 4c       	mov	r12,20
800042d8:	f0 1f 00 21 	mcall	8000435c <xnl_init+0xe4>
800042dc:	4a 78       	lddpc	r8,80004378 <xnl_init+0x100>
800042de:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800042e0:	30 4b       	mov	r11,4
800042e2:	30 ac       	mov	r12,10
800042e4:	f0 1f 00 1e 	mcall	8000435c <xnl_init+0xe4>
800042e8:	4a 58       	lddpc	r8,8000437c <xnl_init+0x104>
800042ea:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
800042ec:	30 4b       	mov	r11,4
800042ee:	30 ac       	mov	r12,10
800042f0:	f0 1f 00 1b 	mcall	8000435c <xnl_init+0xe4>
800042f4:	4a 38       	lddpc	r8,80004380 <xnl_init+0x108>
800042f6:	91 0c       	st.w	r8[0x0],r12
800042f8:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
800042fa:	10 96       	mov	r6,r8
800042fc:	4a 25       	lddpc	r5,80004384 <xnl_init+0x10c>
800042fe:	6c 0c       	ld.w	r12,r6[0x0]
80004300:	ea 07 00 0b 	add	r11,r5,r7
80004304:	f0 1f 00 1c 	mcall	80004374 <xnl_init+0xfc>
80004308:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
8000430c:	e0 47 14 00 	cp.w	r7,5120
80004310:	cf 71       	brne	800042fe <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004312:	30 4b       	mov	r11,4
80004314:	30 5c       	mov	r12,5
80004316:	f0 1f 00 12 	mcall	8000435c <xnl_init+0xe4>
8000431a:	49 c8       	lddpc	r8,80004388 <xnl_init+0x110>
8000431c:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
8000431e:	30 07       	mov	r7,0
80004320:	1a d7       	st.w	--sp,r7
80004322:	1a d7       	st.w	--sp,r7
80004324:	1a d7       	st.w	--sp,r7
80004326:	30 38       	mov	r8,3
80004328:	0e 99       	mov	r9,r7
8000432a:	e0 6a 00 dc 	mov	r10,220
8000432e:	49 8b       	lddpc	r11,8000438c <xnl_init+0x114>
80004330:	49 8c       	lddpc	r12,80004390 <xnl_init+0x118>
80004332:	f0 1f 00 19 	mcall	80004394 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004336:	1a d7       	st.w	--sp,r7
80004338:	1a d7       	st.w	--sp,r7
8000433a:	1a d7       	st.w	--sp,r7
8000433c:	30 38       	mov	r8,3
8000433e:	0e 99       	mov	r9,r7
80004340:	e0 6a 00 82 	mov	r10,130
80004344:	49 5b       	lddpc	r11,80004398 <xnl_init+0x120>
80004346:	49 6c       	lddpc	r12,8000439c <xnl_init+0x124>
80004348:	f0 1f 00 13 	mcall	80004394 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
8000434c:	f0 1f 00 15 	mcall	800043a0 <xnl_init+0x128>
80004350:	2f ad       	sub	sp,-24
}
80004352:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004356:	00 00       	add	r0,r0
80004358:	00 00       	add	r0,r0
8000435a:	0b 3e       	ld.ub	lr,r5++
8000435c:	80 00       	ld.sh	r0,r0[0x0]
8000435e:	64 f0       	ld.w	r0,r2[0x3c]
80004360:	00 00       	add	r0,r0
80004362:	0b 38       	ld.ub	r8,r5++
80004364:	80 00       	ld.sh	r0,r0[0x0]
80004366:	63 98       	ld.w	r8,r1[0x64]
80004368:	00 00       	add	r0,r0
8000436a:	0b 4c       	ld.w	r12,--r5
8000436c:	00 00       	add	r0,r0
8000436e:	0a 98       	mov	r8,r5
80004370:	00 00       	add	r0,r0
80004372:	35 3e       	mov	lr,83
80004374:	80 00       	ld.sh	r0,r0[0x0]
80004376:	2b d4       	sub	r4,-67
80004378:	00 00       	add	r0,r0
8000437a:	0a c8       	st.b	r5++,r8
8000437c:	00 00       	add	r0,r0
8000437e:	0a a8       	st.w	r5++,r8
80004380:	00 00       	add	r0,r0
80004382:	0a 9c       	mov	r12,r5
80004384:	00 00       	add	r0,r0
80004386:	21 3e       	sub	lr,19
80004388:	00 00       	add	r0,r0
8000438a:	0a d4       	st.w	--r5,r4
8000438c:	80 00       	ld.sh	r0,r0[0x0]
8000438e:	d7 d8       	*unknown*
80004390:	80 00       	ld.sh	r0,r0[0x0]
80004392:	43 a4       	lddsp	r4,sp[0xe8]
80004394:	80 00       	ld.sh	r0,r0[0x0]
80004396:	6c 0c       	ld.w	r12,r6[0x0]
80004398:	80 00       	ld.sh	r0,r0[0x0]
8000439a:	d7 e0       	acall	0x7e
8000439c:	80 00       	ld.sh	r0,r0[0x0]
8000439e:	44 04       	lddsp	r4,sp[0x100]
800043a0:	80 00       	ld.sh	r0,r0[0x0]
800043a2:	2d a8       	sub	r8,-38

800043a4 <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
800043a4:	eb cd 40 fe 	pushm	r1-r7,lr
800043a8:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800043aa:	49 26       	lddpc	r6,800043f0 <xnl_rx_process+0x4c>
800043ac:	30 05       	mov	r5,0
800043ae:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800043b0:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800043b2:	49 11       	lddpc	r1,800043f4 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800043b4:	49 12       	lddpc	r2,800043f8 <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800043b6:	6c 0c       	ld.w	r12,r6[0x0]
800043b8:	0a 99       	mov	r9,r5
800043ba:	08 9a       	mov	r10,r4
800043bc:	1a 9b       	mov	r11,sp
800043be:	f0 1f 00 10 	mcall	800043fc <xnl_rx_process+0x58>
800043c2:	58 1c       	cp.w	r12,1
800043c4:	cf 91       	brne	800043b6 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
800043c6:	40 0c       	lddsp	r12,sp[0x0]
800043c8:	58 0c       	cp.w	r12,0
800043ca:	cf 60       	breq	800043b6 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800043cc:	98 28       	ld.sh	r8,r12[0x4]
800043ce:	e6 08 19 00 	cp.h	r8,r3
800043d2:	e0 8b 00 0a 	brhi	800043e6 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800043d6:	5c 78       	castu.h	r8
800043d8:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
800043dc:	58 09       	cp.w	r9,0
800043de:	c0 40       	breq	800043e6 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
800043e0:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
800043e4:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800043e6:	62 0c       	ld.w	r12,r1[0x0]
800043e8:	40 0b       	lddsp	r11,sp[0x0]
800043ea:	f0 1f 00 06 	mcall	80004400 <xnl_rx_process+0x5c>
800043ee:	ce 4b       	rjmp	800043b6 <xnl_rx_process+0x12>
800043f0:	00 00       	add	r0,r0
800043f2:	0a a8       	st.w	r5++,r8
800043f4:	00 00       	add	r0,r0
800043f6:	0a 98       	mov	r8,r5
800043f8:	00 00       	add	r0,r0
800043fa:	04 f4       	st.b	--r2,r4
800043fc:	80 00       	ld.sh	r0,r0[0x0]
800043fe:	61 8c       	ld.w	r12,r0[0x60]
80004400:	80 00       	ld.sh	r0,r0[0x0]
80004402:	2b d4       	sub	r4,-67

80004404 <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
80004404:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004406:	4a a6       	lddpc	r6,800044ac <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004408:	4a a2       	lddpc	r2,800044b0 <xnl_tx_process+0xac>
8000440a:	4a b4       	lddpc	r4,800044b4 <xnl_tx_process+0xb0>
8000440c:	30 07       	mov	r7,0
8000440e:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004410:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004412:	4a a5       	lddpc	r5,800044b8 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004414:	4a a3       	lddpc	r3,800044bc <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004416:	6c 08       	ld.w	r8,r6[0x0]
80004418:	58 08       	cp.w	r8,0
8000441a:	c0 40       	breq	80004422 <xnl_tx_process+0x1e>
8000441c:	58 18       	cp.w	r8,1
8000441e:	cf d1       	brne	80004418 <xnl_tx_process+0x14>
80004420:	c2 48       	rjmp	80004468 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004422:	64 0c       	ld.w	r12,r2[0x0]
80004424:	0e 99       	mov	r9,r7
80004426:	02 9a       	mov	r10,r1
80004428:	08 9b       	mov	r11,r4
8000442a:	f0 1f 00 26 	mcall	800044c0 <xnl_tx_process+0xbc>
8000442e:	58 1c       	cp.w	r12,1
80004430:	cf 31       	brne	80004416 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004432:	68 0b       	ld.w	r11,r4[0x0]
80004434:	58 0b       	cp.w	r11,0
80004436:	cf 00       	breq	80004416 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004438:	96 28       	ld.sh	r8,r11[0x4]
8000443a:	e0 08 19 00 	cp.h	r8,r0
8000443e:	c0 71       	brne	8000444c <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004440:	4a 18       	lddpc	r8,800044c4 <xnl_tx_process+0xc0>
80004442:	70 08       	ld.w	r8,r8[0x0]
80004444:	10 9c       	mov	r12,r8
80004446:	f0 1f 00 21 	mcall	800044c8 <xnl_tx_process+0xc4>
						break;
8000444a:	ce 6b       	rjmp	80004416 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
8000444c:	16 9c       	mov	r12,r11
8000444e:	f0 1f 00 20 	mcall	800044cc <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004452:	30 18       	mov	r8,1
80004454:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004456:	66 0c       	ld.w	r12,r3[0x0]
80004458:	0e 99       	mov	r9,r7
8000445a:	0e 9a       	mov	r10,r7
8000445c:	0e 9b       	mov	r11,r7
8000445e:	f0 1f 00 19 	mcall	800044c0 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
80004462:	30 18       	mov	r8,1
80004464:	8d 08       	st.w	r6[0x0],r8
80004466:	cd 8b       	rjmp	80004416 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004468:	66 0c       	ld.w	r12,r3[0x0]
8000446a:	0e 99       	mov	r9,r7
8000446c:	36 4a       	mov	r10,100
8000446e:	0e 9b       	mov	r11,r7
80004470:	f0 1f 00 14 	mcall	800044c0 <xnl_tx_process+0xbc>
80004474:	58 1c       	cp.w	r12,1
80004476:	c0 81       	brne	80004486 <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
80004478:	49 38       	lddpc	r8,800044c4 <xnl_tx_process+0xc0>
8000447a:	70 0c       	ld.w	r12,r8[0x0]
8000447c:	68 0b       	ld.w	r11,r4[0x0]
8000447e:	f0 1f 00 13 	mcall	800044c8 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80004482:	8d 07       	st.w	r6[0x0],r7
80004484:	cc 9b       	rjmp	80004416 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004486:	6a 08       	ld.w	r8,r5[0x0]
80004488:	58 38       	cp.w	r8,3
8000448a:	e0 89 00 09 	brgt	8000449c <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
8000448e:	68 0c       	ld.w	r12,r4[0x0]
80004490:	f0 1f 00 0f 	mcall	800044cc <xnl_tx_process+0xc8>
						xnl_send_times++;
80004494:	6a 08       	ld.w	r8,r5[0x0]
80004496:	2f f8       	sub	r8,-1
80004498:	8b 08       	st.w	r5[0x0],r8
8000449a:	cb eb       	rjmp	80004416 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
8000449c:	48 a8       	lddpc	r8,800044c4 <xnl_tx_process+0xc0>
8000449e:	70 0c       	ld.w	r12,r8[0x0]
800044a0:	68 0b       	ld.w	r11,r4[0x0]
800044a2:	f0 1f 00 0a 	mcall	800044c8 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800044a6:	8d 07       	st.w	r6[0x0],r7
800044a8:	cb 7b       	rjmp	80004416 <xnl_tx_process+0x12>
800044aa:	00 00       	add	r0,r0
800044ac:	00 00       	add	r0,r0
800044ae:	0b 48       	ld.w	r8,--r5
800044b0:	00 00       	add	r0,r0
800044b2:	0b 4c       	ld.w	r12,--r5
800044b4:	00 00       	add	r0,r0
800044b6:	0b 54       	ld.sh	r4,--r5
800044b8:	00 00       	add	r0,r0
800044ba:	0b 50       	ld.sh	r0,--r5
800044bc:	00 00       	add	r0,r0
800044be:	0b 38       	ld.ub	r8,r5++
800044c0:	80 00       	ld.sh	r0,r0[0x0]
800044c2:	61 8c       	ld.w	r12,r0[0x60]
800044c4:	00 00       	add	r0,r0
800044c6:	0a 98       	mov	r8,r5
800044c8:	80 00       	ld.sh	r0,r0[0x0]
800044ca:	2b d4       	sub	r4,-67
800044cc:	80 00       	ld.sh	r0,r0[0x0]
800044ce:	2b f4       	sub	r4,-65

800044d0 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800044d0:	eb cd 40 c0 	pushm	r6-r7,lr
800044d4:	20 1d       	sub	sp,4
800044d6:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800044d8:	98 39       	ld.sh	r9,r12[0x6]
800044da:	3f f8       	mov	r8,-1
800044dc:	f0 09 19 00 	cp.h	r9,r8
800044e0:	c0 a1       	brne	800044f4 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800044e2:	4a e9       	lddpc	r9,80004598 <xnl_tx+0xc8>
800044e4:	13 88       	ld.ub	r8,r9[0x0]
800044e6:	2f f8       	sub	r8,-1
800044e8:	5c 58       	castu.b	r8
800044ea:	b2 88       	st.b	r9[0x0],r8
800044ec:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800044f0:	a9 a8       	sbr	r8,0x8
800044f2:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800044f4:	8c 49       	ld.sh	r9,r6[0x8]
800044f6:	3f f8       	mov	r8,-1
800044f8:	f0 09 19 00 	cp.h	r9,r8
800044fc:	c0 41       	brne	80004504 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800044fe:	4a 88       	lddpc	r8,8000459c <xnl_tx+0xcc>
80004500:	90 18       	ld.sh	r8,r8[0x2]
80004502:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004504:	8c 59       	ld.sh	r9,r6[0xa]
80004506:	3f f8       	mov	r8,-1
80004508:	f0 09 19 00 	cp.h	r9,r8
8000450c:	c0 41       	brne	80004514 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
8000450e:	4a 48       	lddpc	r8,8000459c <xnl_tx+0xcc>
80004510:	90 28       	ld.sh	r8,r8[0x4]
80004512:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004514:	8c 69       	ld.sh	r9,r6[0xc]
80004516:	3f f8       	mov	r8,-1
80004518:	f0 09 19 00 	cp.h	r9,r8
8000451c:	c0 e1       	brne	80004538 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
8000451e:	4a 08       	lddpc	r8,8000459c <xnl_tx+0xcc>
80004520:	90 49       	ld.sh	r9,r8[0x8]
80004522:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004524:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004526:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004528:	90 49       	ld.sh	r9,r8[0x8]
8000452a:	e0 19 ff 00 	andl	r9,0xff00
8000452e:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004532:	f3 e8 10 08 	or	r8,r9,r8
80004536:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004538:	0d 98       	ld.ub	r8,r6[0x1]
8000453a:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
8000453c:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004540:	10 0c       	add	r12,r8
80004542:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004544:	58 0c       	cp.w	r12,0
80004546:	e0 89 00 04 	brgt	8000454e <xnl_tx+0x7e>
8000454a:	30 09       	mov	r9,0
8000454c:	c0 d8       	rjmp	80004566 <xnl_tx+0x96>
8000454e:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004552:	2f ec       	sub	r12,-2
80004554:	30 09       	mov	r9,0
80004556:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004558:	15 1b       	ld.sh	r11,r10++
8000455a:	f6 09 00 09 	add	r9,r11,r9
8000455e:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004560:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004562:	18 38       	cp.w	r8,r12
80004564:	cf a1       	brne	80004558 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004566:	5c 39       	neg	r9
80004568:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000456a:	48 e8       	lddpc	r8,800045a0 <xnl_tx+0xd0>
8000456c:	70 0c       	ld.w	r12,r8[0x0]
8000456e:	f0 1f 00 0e 	mcall	800045a4 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004572:	c1 00       	breq	80004592 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004574:	fa c7 ff fc 	sub	r7,sp,-4
80004578:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
8000457a:	e0 6a 01 00 	mov	r10,256
8000457e:	0c 9b       	mov	r11,r6
80004580:	f0 1f 00 0a 	mcall	800045a8 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004584:	48 a8       	lddpc	r8,800045ac <xnl_tx+0xdc>
80004586:	70 0c       	ld.w	r12,r8[0x0]
80004588:	30 09       	mov	r9,0
8000458a:	12 9a       	mov	r10,r9
8000458c:	1a 9b       	mov	r11,sp
8000458e:	f0 1f 00 09 	mcall	800045b0 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004592:	2f fd       	sub	sp,-4
80004594:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004598:	00 00       	add	r0,r0
8000459a:	0b 3c       	ld.ub	r12,r5++
8000459c:	00 00       	add	r0,r0
8000459e:	0b 3e       	ld.ub	lr,r5++
800045a0:	00 00       	add	r0,r0
800045a2:	0a 98       	mov	r8,r5
800045a4:	80 00       	ld.sh	r0,r0[0x0]
800045a6:	2d 80       	sub	r0,-40
800045a8:	80 00       	ld.sh	r0,r0[0x0]
800045aa:	78 54       	ld.w	r4,r12[0x14]
800045ac:	00 00       	add	r0,r0
800045ae:	0b 4c       	ld.w	r12,--r5
800045b0:	80 00       	ld.sh	r0,r0[0x0]
800045b2:	63 98       	ld.w	r8,r1[0x64]

800045b4 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800045b4:	eb cd 40 80 	pushm	r7,lr
800045b8:	fa cd 01 00 	sub	sp,sp,256
800045bc:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800045be:	e0 68 40 0e 	mov	r8,16398
800045c2:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800045c4:	3f f8       	mov	r8,-1
800045c6:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
800045c8:	30 c8       	mov	r8,12
800045ca:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
800045cc:	98 38       	ld.sh	r8,r12[0x6]
800045ce:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
800045d0:	98 58       	ld.sh	r8,r12[0xa]
800045d2:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
800045d4:	98 48       	ld.sh	r8,r12[0x8]
800045d6:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
800045d8:	98 68       	ld.sh	r8,r12[0xc]
800045da:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
800045dc:	30 08       	mov	r8,0
800045de:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800045e0:	1a 9c       	mov	r12,sp
800045e2:	f0 1f 00 0a 	mcall	80004608 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
800045e6:	fa cd 00 cc 	sub	sp,sp,204
800045ea:	e0 6a 00 ca 	mov	r10,202
800045ee:	ee cb ff f0 	sub	r11,r7,-16
800045f2:	1a 9c       	mov	r12,sp
800045f4:	f0 1f 00 06 	mcall	8000460c <xnl_data_msg_func+0x58>
800045f8:	48 68       	lddpc	r8,80004610 <xnl_data_msg_func+0x5c>
800045fa:	70 08       	ld.w	r8,r8[0x0]
800045fc:	5d 18       	icall	r8
800045fe:	fa cd ff 34 	sub	sp,sp,-204
}
80004602:	2c 0d       	sub	sp,-256
80004604:	e3 cd 80 80 	ldm	sp++,r7,pc
80004608:	80 00       	ld.sh	r0,r0[0x0]
8000460a:	44 d0       	lddsp	r0,sp[0x134]
8000460c:	80 00       	ld.sh	r0,r0[0x0]
8000460e:	78 54       	ld.w	r4,r12[0x14]
80004610:	00 00       	add	r0,r0
80004612:	0b 58       	ld.sh	r8,--r5

80004614 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004614:	d4 21       	pushm	r4-r7,lr
80004616:	fa cd 01 00 	sub	sp,sp,256
8000461a:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
8000461c:	4c 28       	lddpc	r8,80004724 <xnl_device_auth_reply_func+0x110>
8000461e:	11 88       	ld.ub	r8,r8[0x0]
80004620:	58 08       	cp.w	r8,0
80004622:	e0 81 00 7f 	brne	80004720 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004626:	4c 18       	lddpc	r8,80004728 <xnl_device_auth_reply_func+0x114>
80004628:	70 0c       	ld.w	r12,r8[0x0]
8000462a:	30 09       	mov	r9,0
8000462c:	12 9a       	mov	r10,r9
8000462e:	12 9b       	mov	r11,r9
80004630:	f0 1f 00 3f 	mcall	8000472c <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004634:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004638:	4b b8       	lddpc	r8,80004724 <xnl_device_auth_reply_func+0x110>
8000463a:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
8000463c:	ef 39 00 12 	ld.ub	r9,r7[18]
80004640:	ef 38 00 13 	ld.ub	r8,r7[19]
80004644:	b1 68       	lsl	r8,0x10
80004646:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000464a:	ef 38 00 15 	ld.ub	r8,r7[21]
8000464e:	f3 e8 10 08 	or	r8,r9,r8
80004652:	ef 39 00 14 	ld.ub	r9,r7[20]
80004656:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
8000465a:	ef 3a 00 16 	ld.ub	r10,r7[22]
8000465e:	ef 38 00 17 	ld.ub	r8,r7[23]
80004662:	b1 68       	lsl	r8,0x10
80004664:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004668:	ef 38 00 19 	ld.ub	r8,r7[25]
8000466c:	f5 e8 10 08 	or	r8,r10,r8
80004670:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004674:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004678:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000467a:	e0 64 79 b9 	mov	r4,31161
8000467e:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004682:	e0 65 45 07 	mov	r5,17671
80004686:	ea 15 8a bd 	orh	r5,0x8abd
8000468a:	e0 66 f9 3d 	mov	r6,63805
8000468e:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004692:	e0 6e b8 cf 	mov	lr,47311
80004696:	ea 1e 36 83 	orh	lr,0x3683
8000469a:	e0 67 aa 1c 	mov	r7,43548
8000469e:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800046a2:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800046a4:	f4 08 00 0c 	add	r12,r10,r8
800046a8:	f0 0b 15 04 	lsl	r11,r8,0x4
800046ac:	0a 0b       	add	r11,r5
800046ae:	f9 eb 20 0b 	eor	r11,r12,r11
800046b2:	f0 0c 16 05 	lsr	r12,r8,0x5
800046b6:	0c 0c       	add	r12,r6
800046b8:	18 5b       	eor	r11,r12
800046ba:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800046bc:	f2 0c 15 04 	lsl	r12,r9,0x4
800046c0:	1c 0c       	add	r12,lr
800046c2:	f2 0b 16 05 	lsr	r11,r9,0x5
800046c6:	0e 0b       	add	r11,r7
800046c8:	f9 eb 20 0b 	eor	r11,r12,r11
800046cc:	f2 0a 00 0c 	add	r12,r9,r10
800046d0:	18 5b       	eor	r11,r12
800046d2:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
800046d4:	e0 6b 37 20 	mov	r11,14112
800046d8:	ea 1b c6 ef 	orh	r11,0xc6ef
800046dc:	16 3a       	cp.w	r10,r11
800046de:	ce 21       	brne	800046a2 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
800046e0:	e0 6a 40 1a 	mov	r10,16410
800046e4:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800046e6:	3f fa       	mov	r10,-1
800046e8:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
800046ea:	30 6b       	mov	r11,6
800046ec:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800046ee:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800046f0:	48 db       	lddpc	r11,80004724 <xnl_device_auth_reply_func+0x110>
800046f2:	96 1c       	ld.sh	r12,r11[0x2]
800046f4:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
800046f6:	96 2b       	ld.sh	r11,r11[0x4]
800046f8:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800046fa:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
800046fc:	30 ca       	mov	r10,12
800046fe:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004700:	30 0a       	mov	r10,0
80004702:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004706:	30 7a       	mov	r10,7
80004708:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
8000470c:	30 2a       	mov	r10,2
8000470e:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004712:	fa ca ff ec 	sub	r10,sp,-20
80004716:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004718:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000471a:	1a 9c       	mov	r12,sp
8000471c:	f0 1f 00 05 	mcall	80004730 <xnl_device_auth_reply_func+0x11c>
}
80004720:	2c 0d       	sub	sp,-256
80004722:	d8 22       	popm	r4-r7,pc
80004724:	00 00       	add	r0,r0
80004726:	0b 3e       	ld.ub	lr,r5++
80004728:	00 00       	add	r0,r0
8000472a:	0b 38       	ld.ub	r8,r5++
8000472c:	80 00       	ld.sh	r0,r0[0x0]
8000472e:	63 98       	ld.w	r8,r1[0x64]
80004730:	80 00       	ld.sh	r0,r0[0x0]
80004732:	44 d0       	lddsp	r0,sp[0x134]

80004734 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004734:	eb cd 40 80 	pushm	r7,lr
80004738:	fa cd 01 00 	sub	sp,sp,256
8000473c:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
8000473e:	49 28       	lddpc	r8,80004784 <xnl_master_status_brdcst_func+0x50>
80004740:	11 88       	ld.ub	r8,r8[0x0]
80004742:	58 08       	cp.w	r8,0
80004744:	c1 c1       	brne	8000477c <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004746:	49 18       	lddpc	r8,80004788 <xnl_master_status_brdcst_func+0x54>
80004748:	70 0c       	ld.w	r12,r8[0x0]
8000474a:	30 09       	mov	r9,0
8000474c:	12 9a       	mov	r10,r9
8000474e:	12 9b       	mov	r11,r9
80004750:	f0 1f 00 0f 	mcall	8000478c <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004754:	8e 58       	ld.sh	r8,r7[0xa]
80004756:	48 c9       	lddpc	r9,80004784 <xnl_master_status_brdcst_func+0x50>
80004758:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000475a:	e0 68 40 0e 	mov	r8,16398
8000475e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004760:	3f f8       	mov	r8,-1
80004762:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004764:	30 4a       	mov	r10,4
80004766:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004768:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000476a:	92 19       	ld.sh	r9,r9[0x2]
8000476c:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
8000476e:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004770:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80004772:	30 08       	mov	r8,0
80004774:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80004776:	1a 9c       	mov	r12,sp
80004778:	f0 1f 00 06 	mcall	80004790 <xnl_master_status_brdcst_func+0x5c>
}
8000477c:	2c 0d       	sub	sp,-256
8000477e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004782:	00 00       	add	r0,r0
80004784:	00 00       	add	r0,r0
80004786:	0b 3e       	ld.ub	lr,r5++
80004788:	00 00       	add	r0,r0
8000478a:	0b 38       	ld.ub	r8,r5++
8000478c:	80 00       	ld.sh	r0,r0[0x0]
8000478e:	63 98       	ld.w	r8,r1[0x64]
80004790:	80 00       	ld.sh	r0,r0[0x0]
80004792:	44 d0       	lddsp	r0,sp[0x134]

80004794 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004794:	eb cd 40 80 	pushm	r7,lr
80004798:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
8000479a:	49 28       	lddpc	r8,800047e0 <xnl_device_conn_reply_func+0x4c>
8000479c:	70 0c       	ld.w	r12,r8[0x0]
8000479e:	30 09       	mov	r9,0
800047a0:	12 9a       	mov	r10,r9
800047a2:	12 9b       	mov	r11,r9
800047a4:	f0 1f 00 10 	mcall	800047e4 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800047a8:	ef 18 00 10 	ld.uh	r8,r7[16]
800047ac:	10 99       	mov	r9,r8
800047ae:	e2 19 ff 00 	andl	r9,0xff00,COH
800047b2:	e0 49 01 00 	cp.w	r9,256
800047b6:	c0 60       	breq	800047c2 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800047b8:	0e 9c       	mov	r12,r7
800047ba:	f0 1f 00 0c 	mcall	800047e8 <xnl_device_conn_reply_func+0x54>
800047be:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
800047c2:	a9 68       	lsl	r8,0x8
800047c4:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800047c8:	48 98       	lddpc	r8,800047ec <xnl_device_conn_reply_func+0x58>
800047ca:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
800047cc:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
800047d0:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
800047d2:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
800047d6:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
800047d8:	30 19       	mov	r9,1
800047da:	b0 89       	st.b	r8[0x0],r9
800047dc:	e3 cd 80 80 	ldm	sp++,r7,pc
800047e0:	00 00       	add	r0,r0
800047e2:	0b 38       	ld.ub	r8,r5++
800047e4:	80 00       	ld.sh	r0,r0[0x0]
800047e6:	63 98       	ld.w	r8,r1[0x64]
800047e8:	80 00       	ld.sh	r0,r0[0x0]
800047ea:	47 34       	lddsp	r4,sp[0x1cc]
800047ec:	00 00       	add	r0,r0
800047ee:	0b 3e       	ld.ub	lr,r5++

800047f0 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
800047f0:	d4 01       	pushm	lr
800047f2:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800047f6:	e0 68 40 0e 	mov	r8,16398
800047fa:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800047fc:	3f f8       	mov	r8,-1
800047fe:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004800:	30 38       	mov	r8,3
80004802:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004804:	30 08       	mov	r8,0
80004806:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004808:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
8000480a:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
8000480c:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
8000480e:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004810:	1a 9c       	mov	r12,sp
80004812:	f0 1f 00 03 	mcall	8000481c <xnl_send_device_master_query+0x2c>
}
80004816:	2c 0d       	sub	sp,-256
80004818:	d8 02       	popm	pc
8000481a:	00 00       	add	r0,r0
8000481c:	80 00       	ld.sh	r0,r0[0x0]
8000481e:	44 d0       	lddsp	r0,sp[0x134]

80004820 <RC522_SPI_SetSpeed>:
	SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80004820:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
80004822:	48 78       	lddpc	r8,8000483c <RC522_SPI_SetSpeed+0x1c>
80004824:	70 09       	ld.w	r9,r8[0x0]
80004826:	72 ca       	ld.w	r10,r9[0x30]
80004828:	5c 7c       	castu.h	r12
8000482a:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
8000482e:	f9 ea 10 0a 	or	r10,r12,r10
80004832:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
80004834:	70 0c       	ld.w	r12,r8[0x0]
80004836:	f0 1f 00 03 	mcall	80004840 <RC522_SPI_SetSpeed+0x20>
		
	
}
8000483a:	d8 02       	popm	pc
8000483c:	00 00       	add	r0,r0
8000483e:	20 18       	sub	r8,1
80004840:	80 00       	ld.sh	r0,r0[0x0]
80004842:	58 88       	cp.w	r8,8

80004844 <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
80004844:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0400);//baudDiv=4
80004846:	e0 6c 04 00 	mov	r12,1024
8000484a:	f0 1f 00 02 	mcall	80004850 <RC522_SPI_SetSpeedLow+0xc>
	
}
8000484e:	d8 02       	popm	pc
80004850:	80 00       	ld.sh	r0,r0[0x0]
80004852:	48 20       	lddpc	r0,80004858 <RC522_ReadByte+0x4>

80004854 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
80004854:	eb cd 40 c0 	pushm	r6-r7,lr
	U16 *Data ;

	//蹇椤昏锋芥ｅ父璇诲
	spi_selectChip(spi, DF_SPI_PCS_0);
80004858:	48 b7       	lddpc	r7,80004884 <RC522_ReadByte+0x30>
8000485a:	30 0b       	mov	r11,0
8000485c:	6e 0c       	ld.w	r12,r7[0x0]
8000485e:	f0 1f 00 0b 	mcall	80004888 <RC522_ReadByte+0x34>
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
80004862:	e0 6b 00 ff 	mov	r11,255
80004866:	6e 0c       	ld.w	r12,r7[0x0]
80004868:	f0 1f 00 09 	mcall	8000488c <RC522_ReadByte+0x38>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
8000486c:	30 06       	mov	r6,0
8000486e:	0c 9b       	mov	r11,r6
80004870:	6e 0c       	ld.w	r12,r7[0x0]
80004872:	f0 1f 00 08 	mcall	80004890 <RC522_ReadByte+0x3c>

	/*!< Return the shifted data */
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004876:	0c 9b       	mov	r11,r6
80004878:	6e 0c       	ld.w	r12,r7[0x0]
8000487a:	f0 1f 00 07 	mcall	80004894 <RC522_ReadByte+0x40>
	
	return (U8)(*Data);
	
}
8000487e:	0d 9c       	ld.ub	r12,r6[0x1]
80004880:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004884:	00 00       	add	r0,r0
80004886:	20 18       	sub	r8,1
80004888:	80 00       	ld.sh	r0,r0[0x0]
8000488a:	59 f4       	cp.w	r4,31
8000488c:	80 00       	ld.sh	r0,r0[0x0]
8000488e:	58 8e       	cp.w	lr,8
80004890:	80 00       	ld.sh	r0,r0[0x0]
80004892:	58 aa       	cp.w	r10,10
80004894:	80 00       	ld.sh	r0,r0[0x0]
80004896:	59 b4       	cp.w	r4,27

80004898 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
80004898:	eb cd 40 c0 	pushm	r6-r7,lr
8000489c:	20 1d       	sub	sp,4
8000489e:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	spi_selectChip(spi, DF_SPI_PCS_0);
800048a0:	48 c7       	lddpc	r7,800048d0 <RC522_WriteByte+0x38>
800048a2:	30 0b       	mov	r11,0
800048a4:	6e 0c       	ld.w	r12,r7[0x0]
800048a6:	f0 1f 00 0c 	mcall	800048d4 <RC522_WriteByte+0x3c>
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
800048aa:	1b 8b       	ld.ub	r11,sp[0x0]
800048ac:	6e 0c       	ld.w	r12,r7[0x0]
800048ae:	f0 1f 00 0b 	mcall	800048d8 <RC522_WriteByte+0x40>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
800048b2:	1a 9b       	mov	r11,sp
800048b4:	6e 0c       	ld.w	r12,r7[0x0]
800048b6:	f0 1f 00 0a 	mcall	800048dc <RC522_WriteByte+0x44>
800048ba:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800048bc:	30 0b       	mov	r11,0
800048be:	6e 0c       	ld.w	r12,r7[0x0]
800048c0:	f0 1f 00 08 	mcall	800048e0 <RC522_WriteByte+0x48>
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
800048c4:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
800048c8:	2f fd       	sub	sp,-4
800048ca:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800048ce:	00 00       	add	r0,r0
800048d0:	00 00       	add	r0,r0
800048d2:	20 18       	sub	r8,1
800048d4:	80 00       	ld.sh	r0,r0[0x0]
800048d6:	59 f4       	cp.w	r4,31
800048d8:	80 00       	ld.sh	r0,r0[0x0]
800048da:	58 8e       	cp.w	lr,8
800048dc:	80 00       	ld.sh	r0,r0[0x0]
800048de:	58 aa       	cp.w	r10,10
800048e0:	80 00       	ld.sh	r0,r0[0x0]
800048e2:	59 b4       	cp.w	r4,27

800048e4 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
800048e4:	eb cd 40 c0 	pushm	r6-r7,lr
800048e8:	18 96       	mov	r6,r12
800048ea:	16 97       	mov	r7,r11
	U8   ucAddr;

	CLR_SPI_CS;	
800048ec:	31 8c       	mov	r12,24
800048ee:	f0 1f 00 09 	mcall	80004910 <WriteRawRC+0x2c>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
800048f2:	ec 0c 15 01 	lsl	r12,r6,0x1
800048f6:	e2 1c 00 7e 	andl	r12,0x7e,COH
800048fa:	f0 1f 00 07 	mcall	80004914 <WriteRawRC+0x30>
	RC522_WriteByte(value);
800048fe:	0e 9c       	mov	r12,r7
80004900:	f0 1f 00 05 	mcall	80004914 <WriteRawRC+0x30>
	
	SET_SPI_CS;
80004904:	31 8c       	mov	r12,24
80004906:	f0 1f 00 05 	mcall	80004918 <WriteRawRC+0x34>

}
8000490a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000490e:	00 00       	add	r0,r0
80004910:	80 00       	ld.sh	r0,r0[0x0]
80004912:	54 18       	stdsp	sp[0x104],r8
80004914:	80 00       	ld.sh	r0,r0[0x0]
80004916:	48 98       	lddpc	r8,80004938 <PcdReset+0x1c>
80004918:	80 00       	ld.sh	r0,r0[0x0]
8000491a:	53 fc       	stdsp	sp[0xfc],r12

8000491c <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
8000491c:	d4 01       	pushm	lr

	SET_RC522RST;
8000491e:	31 9c       	mov	r12,25
80004920:	f0 1f 00 1b 	mcall	8000498c <PcdReset+0x70>
	delay_ns(10);
80004924:	30 ac       	mov	r12,10
80004926:	f0 1f 00 1b 	mcall	80004990 <PcdReset+0x74>

	CLR_RC522RST;
8000492a:	31 9c       	mov	r12,25
8000492c:	f0 1f 00 1a 	mcall	80004994 <PcdReset+0x78>
	delay_ns(10);
80004930:	30 ac       	mov	r12,10
80004932:	f0 1f 00 18 	mcall	80004990 <PcdReset+0x74>

	SET_RC522RST;
80004936:	31 9c       	mov	r12,25
80004938:	f0 1f 00 15 	mcall	8000498c <PcdReset+0x70>
	delay_ns(10);
8000493c:	30 ac       	mov	r12,10
8000493e:	f0 1f 00 15 	mcall	80004990 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004942:	30 fb       	mov	r11,15
80004944:	30 1c       	mov	r12,1
80004946:	f0 1f 00 15 	mcall	80004998 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
8000494a:	30 fb       	mov	r11,15
8000494c:	30 1c       	mov	r12,1
8000494e:	f0 1f 00 13 	mcall	80004998 <PcdReset+0x7c>
	delay_ns(10);
80004952:	30 ac       	mov	r12,10
80004954:	f0 1f 00 0f 	mcall	80004990 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80004958:	33 db       	mov	r11,61
8000495a:	31 1c       	mov	r12,17
8000495c:	f0 1f 00 0f 	mcall	80004998 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
80004960:	31 eb       	mov	r11,30
80004962:	32 dc       	mov	r12,45
80004964:	f0 1f 00 0d 	mcall	80004998 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80004968:	30 0b       	mov	r11,0
8000496a:	32 cc       	mov	r12,44
8000496c:	f0 1f 00 0b 	mcall	80004998 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
80004970:	e0 6b 00 8d 	mov	r11,141
80004974:	32 ac       	mov	r12,42
80004976:	f0 1f 00 09 	mcall	80004998 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
8000497a:	33 eb       	mov	r11,62
8000497c:	32 bc       	mov	r12,43
8000497e:	f0 1f 00 07 	mcall	80004998 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
80004982:	34 0b       	mov	r11,64
80004984:	31 5c       	mov	r12,21
80004986:	f0 1f 00 05 	mcall	80004998 <PcdReset+0x7c>
	
	return MI_OK;
}
8000498a:	d8 0a       	popm	pc,r12=0
8000498c:	80 00       	ld.sh	r0,r0[0x0]
8000498e:	53 fc       	stdsp	sp[0xfc],r12
80004990:	80 00       	ld.sh	r0,r0[0x0]
80004992:	51 94       	stdsp	sp[0x64],r4
80004994:	80 00       	ld.sh	r0,r0[0x0]
80004996:	54 18       	stdsp	sp[0x104],r8
80004998:	80 00       	ld.sh	r0,r0[0x0]
8000499a:	48 e4       	lddpc	r4,800049d0 <ReadRawRC+0x34>

8000499c <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
8000499c:	eb cd 40 80 	pushm	r7,lr
800049a0:	18 97       	mov	r7,r12
	U8   ucAddr;
	U8   ucResult=0;
	CLR_SPI_CS;	
800049a2:	31 8c       	mov	r12,24
800049a4:	f0 1f 00 0a 	mcall	800049cc <ReadRawRC+0x30>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
800049a8:	ee 08 15 01 	lsl	r8,r7,0x1
800049ac:	10 9c       	mov	r12,r8
800049ae:	e2 1c 00 7e 	andl	r12,0x7e,COH
800049b2:	a7 bc       	sbr	r12,0x7
800049b4:	f0 1f 00 07 	mcall	800049d0 <ReadRawRC+0x34>
	ucResult = RC522_ReadByte();
800049b8:	f0 1f 00 07 	mcall	800049d4 <ReadRawRC+0x38>
800049bc:	18 97       	mov	r7,r12
	
	SET_SPI_CS;
800049be:	31 8c       	mov	r12,24
800049c0:	f0 1f 00 06 	mcall	800049d8 <ReadRawRC+0x3c>
	return ucResult;
}
800049c4:	0e 9c       	mov	r12,r7
800049c6:	e3 cd 80 80 	ldm	sp++,r7,pc
800049ca:	00 00       	add	r0,r0
800049cc:	80 00       	ld.sh	r0,r0[0x0]
800049ce:	54 18       	stdsp	sp[0x104],r8
800049d0:	80 00       	ld.sh	r0,r0[0x0]
800049d2:	48 98       	lddpc	r8,800049f4 <SetBitMask+0x18>
800049d4:	80 00       	ld.sh	r0,r0[0x0]
800049d6:	48 54       	lddpc	r4,800049e8 <SetBitMask+0xc>
800049d8:	80 00       	ld.sh	r0,r0[0x0]
800049da:	53 fc       	stdsp	sp[0xfc],r12

800049dc <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
800049dc:	eb cd 40 c0 	pushm	r6-r7,lr
800049e0:	18 97       	mov	r7,r12
800049e2:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
800049e4:	f0 1f 00 05 	mcall	800049f8 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
800049e8:	f9 e6 10 0b 	or	r11,r12,r6
800049ec:	5c 5b       	castu.b	r11
800049ee:	0e 9c       	mov	r12,r7
800049f0:	f0 1f 00 03 	mcall	800049fc <SetBitMask+0x20>
}
800049f4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800049f8:	80 00       	ld.sh	r0,r0[0x0]
800049fa:	49 9c       	lddpc	r12,80004a5c <M500PcdConfigISOType+0x4>
800049fc:	80 00       	ld.sh	r0,r0[0x0]
800049fe:	48 e4       	lddpc	r4,80004a34 <ClearBitMask+0x14>

80004a00 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80004a00:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80004a02:	31 4c       	mov	r12,20
80004a04:	f0 1f 00 05 	mcall	80004a18 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80004a08:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80004a0c:	c0 51       	brne	80004a16 <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
80004a0e:	30 3b       	mov	r11,3
80004a10:	31 4c       	mov	r12,20
80004a12:	f0 1f 00 03 	mcall	80004a1c <PcdAntennaOn+0x1c>
80004a16:	d8 02       	popm	pc
80004a18:	80 00       	ld.sh	r0,r0[0x0]
80004a1a:	49 9c       	lddpc	r12,80004a7c <M500PcdConfigISOType+0x24>
80004a1c:	80 00       	ld.sh	r0,r0[0x0]
80004a1e:	49 dc       	lddpc	r12,80004a90 <M500PcdConfigISOType+0x38>

80004a20 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80004a20:	eb cd 40 c0 	pushm	r6-r7,lr
80004a24:	18 97       	mov	r7,r12
80004a26:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80004a28:	f0 1f 00 06 	mcall	80004a40 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80004a2c:	5c d6       	com	r6
80004a2e:	f9 e6 00 06 	and	r6,r12,r6
80004a32:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80004a36:	0e 9c       	mov	r12,r7
80004a38:	f0 1f 00 03 	mcall	80004a44 <ClearBitMask+0x24>
	
}
80004a3c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a40:	80 00       	ld.sh	r0,r0[0x0]
80004a42:	49 9c       	lddpc	r12,80004aa4 <M500PcdConfigISOType+0x4c>
80004a44:	80 00       	ld.sh	r0,r0[0x0]
80004a46:	48 e4       	lddpc	r4,80004a7c <M500PcdConfigISOType+0x24>

80004a48 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
80004a48:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
80004a4a:	30 3b       	mov	r11,3
80004a4c:	31 4c       	mov	r12,20
80004a4e:	f0 1f 00 02 	mcall	80004a54 <PcdAntennaOff+0xc>
}
80004a52:	d8 02       	popm	pc
80004a54:	80 00       	ld.sh	r0,r0[0x0]
80004a56:	4a 20       	lddpc	r0,80004adc <rc522_init+0x14>

80004a58 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
80004a58:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
80004a5a:	34 18       	mov	r8,65
80004a5c:	f0 0c 18 00 	cp.b	r12,r8
80004a60:	c0 20       	breq	80004a64 <M500PcdConfigISOType+0xc>
80004a62:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80004a64:	30 8b       	mov	r11,8
80004a66:	16 9c       	mov	r12,r11
80004a68:	f0 1f 00 14 	mcall	80004ab8 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
80004a6c:	33 db       	mov	r11,61
80004a6e:	31 1c       	mov	r12,17
80004a70:	f0 1f 00 13 	mcall	80004abc <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80004a74:	e0 6b 00 86 	mov	r11,134
80004a78:	31 7c       	mov	r12,23
80004a7a:	f0 1f 00 11 	mcall	80004abc <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
80004a7e:	37 fb       	mov	r11,127
80004a80:	32 6c       	mov	r12,38
80004a82:	f0 1f 00 0f 	mcall	80004abc <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
80004a86:	31 eb       	mov	r11,30
80004a88:	32 dc       	mov	r12,45
80004a8a:	f0 1f 00 0d 	mcall	80004abc <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
80004a8e:	30 0b       	mov	r11,0
80004a90:	32 cc       	mov	r12,44
80004a92:	f0 1f 00 0b 	mcall	80004abc <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
80004a96:	e0 6b 00 8d 	mov	r11,141
80004a9a:	32 ac       	mov	r12,42
80004a9c:	f0 1f 00 08 	mcall	80004abc <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80004aa0:	33 eb       	mov	r11,62
80004aa2:	32 bc       	mov	r12,43
80004aa4:	f0 1f 00 06 	mcall	80004abc <M500PcdConfigISOType+0x64>
		delay_ns(1000);
80004aa8:	e0 6c 03 e8 	mov	r12,1000
80004aac:	f0 1f 00 05 	mcall	80004ac0 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80004ab0:	f0 1f 00 05 	mcall	80004ac4 <M500PcdConfigISOType+0x6c>
80004ab4:	d8 0a       	popm	pc,r12=0
80004ab6:	00 00       	add	r0,r0
80004ab8:	80 00       	ld.sh	r0,r0[0x0]
80004aba:	4a 20       	lddpc	r0,80004b40 <rc522_init+0x78>
80004abc:	80 00       	ld.sh	r0,r0[0x0]
80004abe:	48 e4       	lddpc	r4,80004af4 <rc522_init+0x2c>
80004ac0:	80 00       	ld.sh	r0,r0[0x0]
80004ac2:	51 94       	stdsp	sp[0x64],r4
80004ac4:	80 00       	ld.sh	r0,r0[0x0]
80004ac6:	4a 00       	lddpc	r0,80004b44 <rc522_init+0x7c>

80004ac8 <rc522_init>:


//mfrc522 init

void rc522_init()
{
80004ac8:	eb cd 40 c0 	pushm	r6-r7,lr
80004acc:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004ace:	4a 28       	lddpc	r8,80004b54 <rc522_init+0x8c>
80004ad0:	1a 96       	mov	r6,sp
80004ad2:	f0 ea 00 00 	ld.d	r10,r8[0]
80004ad6:	fa eb 00 00 	st.d	sp[0],r10
80004ada:	f0 e8 00 08 	ld.d	r8,r8[8]
80004ade:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80004ae2:	30 4b       	mov	r11,4
80004ae4:	49 dc       	lddpc	r12,80004b58 <rc522_init+0x90>
80004ae6:	f0 1f 00 1e 	mcall	80004b5c <rc522_init+0x94>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80004aea:	31 9c       	mov	r12,25
80004aec:	f0 1f 00 1d 	mcall	80004b60 <rc522_init+0x98>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80004af0:	31 9c       	mov	r12,25
80004af2:	f0 1f 00 1d 	mcall	80004b64 <rc522_init+0x9c>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
80004af6:	49 d7       	lddpc	r7,80004b68 <rc522_init+0xa0>
80004af8:	fe 7c 24 00 	mov	r12,-56320
80004afc:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80004afe:	1a 9b       	mov	r11,sp
80004b00:	f0 1f 00 1b 	mcall	80004b6c <rc522_init+0xa4>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80004b04:	30 09       	mov	r9,0
80004b06:	12 9a       	mov	r10,r9
80004b08:	12 9b       	mov	r11,r9
80004b0a:	6e 0c       	ld.w	r12,r7[0x0]
80004b0c:	f0 1f 00 19 	mcall	80004b70 <rc522_init+0xa8>

	// Enable SPI.
	spi_enable(spi);
80004b10:	6e 0c       	ld.w	r12,r7[0x0]
80004b12:	f0 1f 00 19 	mcall	80004b74 <rc522_init+0xac>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80004b16:	e0 6a 36 00 	mov	r10,13824
80004b1a:	ea 1a 01 6e 	orh	r10,0x16e
80004b1e:	1a 9b       	mov	r11,sp
80004b20:	6e 0c       	ld.w	r12,r7[0x0]
80004b22:	f0 1f 00 16 	mcall	80004b78 <rc522_init+0xb0>
80004b26:	c0 50       	breq	80004b30 <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80004b28:	30 29       	mov	r9,2
80004b2a:	49 58       	lddpc	r8,80004b7c <rc522_init+0xb4>
80004b2c:	b0 89       	st.b	r8[0x0],r9
80004b2e:	c0 38       	rjmp	80004b34 <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80004b30:	f0 1f 00 14 	mcall	80004b80 <rc522_init+0xb8>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80004b34:	f0 1f 00 14 	mcall	80004b84 <rc522_init+0xbc>
	
	PcdAntennaOff();
80004b38:	f0 1f 00 14 	mcall	80004b88 <rc522_init+0xc0>
	
	delay_ms(2); 
80004b3c:	30 2c       	mov	r12,2
80004b3e:	f0 1f 00 14 	mcall	80004b8c <rc522_init+0xc4>
	
	PcdAntennaOn();
80004b42:	f0 1f 00 14 	mcall	80004b90 <rc522_init+0xc8>
	
	M500PcdConfigISOType( 'A' );
80004b46:	34 1c       	mov	r12,65
80004b48:	f0 1f 00 13 	mcall	80004b94 <rc522_init+0xcc>
	

80004b4c:	2f cd       	sub	sp,-16
80004b4e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004b52:	00 00       	add	r0,r0
80004b54:	80 00       	ld.sh	r0,r0[0x0]
80004b56:	d7 e8       	*unknown*
80004b58:	80 00       	ld.sh	r0,r0[0x0]
80004b5a:	d8 00       	acall	0x80
80004b5c:	80 00       	ld.sh	r0,r0[0x0]
80004b5e:	53 b4       	stdsp	sp[0xec],r4
80004b60:	80 00       	ld.sh	r0,r0[0x0]
80004b62:	53 e4       	stdsp	sp[0xf8],r4
80004b64:	80 00       	ld.sh	r0,r0[0x0]
80004b66:	53 fc       	stdsp	sp[0xfc],r12
80004b68:	00 00       	add	r0,r0
80004b6a:	20 18       	sub	r8,1
80004b6c:	80 00       	ld.sh	r0,r0[0x0]
80004b6e:	58 24       	cp.w	r4,2
80004b70:	80 00       	ld.sh	r0,r0[0x0]
80004b72:	58 5c       	cp.w	r12,5
80004b74:	80 00       	ld.sh	r0,r0[0x0]
80004b76:	58 88       	cp.w	r8,8
80004b78:	80 00       	ld.sh	r0,r0[0x0]
80004b7a:	58 cc       	cp.w	r12,12
80004b7c:	00 00       	add	r0,r0
80004b7e:	0b 5c       	ld.sh	r12,--r5
80004b80:	80 00       	ld.sh	r0,r0[0x0]
80004b82:	48 44       	lddpc	r4,80004b90 <rc522_init+0xc8>
80004b84:	80 00       	ld.sh	r0,r0[0x0]
80004b86:	49 1c       	lddpc	r12,80004bc8 <PcdComMF522+0x30>
80004b88:	80 00       	ld.sh	r0,r0[0x0]
80004b8a:	4a 48       	lddpc	r8,80004c18 <PcdComMF522+0x80>
80004b8c:	80 00       	ld.sh	r0,r0[0x0]
80004b8e:	51 d4       	stdsp	sp[0x74],r4
80004b90:	80 00       	ld.sh	r0,r0[0x0]
80004b92:	4a 00       	lddpc	r0,80004c10 <PcdComMF522+0x78>
80004b94:	80 00       	ld.sh	r0,r0[0x0]
80004b96:	4a 58       	lddpc	r8,80004c28 <PcdComMF522+0x90>

80004b98 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004b98:	d4 31       	pushm	r0-r7,lr
80004b9a:	20 1d       	sub	sp,4
80004b9c:	18 92       	mov	r2,r12
80004b9e:	16 95       	mov	r5,r11
80004ba0:	14 96       	mov	r6,r10
80004ba2:	50 09       	stdsp	sp[0x0],r9
80004ba4:	10 90       	mov	r0,r8
80004ba6:	f8 c8 00 0c 	sub	r8,r12,12
80004baa:	5c 58       	castu.b	r8
80004bac:	30 29       	mov	r9,2
80004bae:	f2 08 18 00 	cp.b	r8,r9
80004bb2:	e0 88 00 05 	brls	80004bbc <PcdComMF522+0x24>
80004bb6:	30 03       	mov	r3,0
80004bb8:	06 91       	mov	r1,r3
80004bba:	c0 78       	rjmp	80004bc8 <PcdComMF522+0x30>
80004bbc:	4c f9       	lddpc	r9,80004cf8 <PcdComMF522+0x160>
80004bbe:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004bc2:	4c f9       	lddpc	r9,80004cfc <PcdComMF522+0x164>
80004bc4:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004bc8:	02 9b       	mov	r11,r1
80004bca:	a7 bb       	sbr	r11,0x7
80004bcc:	30 2c       	mov	r12,2
80004bce:	f0 1f 00 4d 	mcall	80004d00 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004bd2:	e0 6b 00 80 	mov	r11,128
80004bd6:	30 4c       	mov	r12,4
80004bd8:	f0 1f 00 4b 	mcall	80004d04 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004bdc:	30 0b       	mov	r11,0
80004bde:	30 1c       	mov	r12,1
80004be0:	f0 1f 00 48 	mcall	80004d00 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004be4:	e0 6b 00 80 	mov	r11,128
80004be8:	30 ac       	mov	r12,10
80004bea:	f0 1f 00 48 	mcall	80004d08 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004bee:	58 06       	cp.w	r6,0
80004bf0:	c0 c0       	breq	80004c08 <PcdComMF522+0x70>
80004bf2:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004bf4:	30 94       	mov	r4,9
80004bf6:	0f 3b       	ld.ub	r11,r7++
80004bf8:	08 9c       	mov	r12,r4
80004bfa:	f0 1f 00 42 	mcall	80004d00 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004bfe:	0e 98       	mov	r8,r7
80004c00:	0a 18       	sub	r8,r5
80004c02:	ec 08 19 00 	cp.h	r8,r6
80004c06:	cf 83       	brcs	80004bf6 <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004c08:	04 9b       	mov	r11,r2
80004c0a:	30 1c       	mov	r12,1
80004c0c:	f0 1f 00 3d 	mcall	80004d00 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004c10:	30 c8       	mov	r8,12
80004c12:	f0 02 18 00 	cp.b	r2,r8
80004c16:	c0 61       	brne	80004c22 <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004c18:	e0 6b 00 80 	mov	r11,128
80004c1c:	30 dc       	mov	r12,13
80004c1e:	f0 1f 00 3b 	mcall	80004d08 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004c22:	30 4c       	mov	r12,4
80004c24:	f0 1f 00 3a 	mcall	80004d0c <PcdComMF522+0x174>
80004c28:	18 97       	mov	r7,r12
80004c2a:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004c2e:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004c30:	30 44       	mov	r4,4
80004c32:	c0 88       	rjmp	80004c42 <PcdComMF522+0xaa>
80004c34:	08 9c       	mov	r12,r4
80004c36:	f0 1f 00 36 	mcall	80004d0c <PcdComMF522+0x174>
80004c3a:	18 97       	mov	r7,r12
		i--;
80004c3c:	20 16       	sub	r6,1
80004c3e:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004c40:	c0 a0       	breq	80004c54 <PcdComMF522+0xbc>
80004c42:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004c46:	c4 c1       	brne	80004cde <PcdComMF522+0x146>
80004c48:	ef e3 00 08 	and	r8,r7,r3
80004c4c:	ea 08 18 00 	cp.b	r8,r5
80004c50:	cf 20       	breq	80004c34 <PcdComMF522+0x9c>
80004c52:	c4 68       	rjmp	80004cde <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004c54:	e0 6b 00 80 	mov	r11,128
80004c58:	30 dc       	mov	r12,13
80004c5a:	f0 1f 00 2b 	mcall	80004d04 <PcdComMF522+0x16c>
80004c5e:	30 27       	mov	r7,2
80004c60:	c3 38       	rjmp	80004cc6 <PcdComMF522+0x12e>
80004c62:	02 67       	and	r7,r1
80004c64:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004c68:	30 c8       	mov	r8,12
80004c6a:	f0 02 18 00 	cp.b	r2,r8
80004c6e:	c2 c1       	brne	80004cc6 <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004c70:	30 ac       	mov	r12,10
80004c72:	f0 1f 00 27 	mcall	80004d0c <PcdComMF522+0x174>
80004c76:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004c78:	30 cc       	mov	r12,12
80004c7a:	f0 1f 00 25 	mcall	80004d0c <PcdComMF522+0x174>
80004c7e:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004c82:	c0 70       	breq	80004c90 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004c84:	08 98       	mov	r8,r4
80004c86:	20 18       	sub	r8,1
80004c88:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004c8c:	a0 8c       	st.b	r0[0x0],r12
80004c8e:	c0 48       	rjmp	80004c96 <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004c90:	e8 08 15 03 	lsl	r8,r4,0x3
80004c94:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004c96:	58 04       	cp.w	r4,0
80004c98:	c0 61       	brne	80004ca4 <PcdComMF522+0x10c>
80004c9a:	30 14       	mov	r4,1
80004c9c:	40 05       	lddsp	r5,sp[0x0]
80004c9e:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004ca0:	30 93       	mov	r3,9
80004ca2:	c0 98       	rjmp	80004cb4 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004ca4:	31 28       	mov	r8,18
80004ca6:	f0 04 18 00 	cp.b	r4,r8
80004caa:	f9 b4 0b 12 	movhi	r4,18
80004cae:	58 04       	cp.w	r4,0
80004cb0:	cf 61       	brne	80004c9c <PcdComMF522+0x104>
80004cb2:	c0 a8       	rjmp	80004cc6 <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004cb4:	06 9c       	mov	r12,r3
80004cb6:	f0 1f 00 16 	mcall	80004d0c <PcdComMF522+0x174>
80004cba:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004cbc:	ec 05 01 08 	sub	r8,r6,r5
80004cc0:	e8 08 19 00 	cp.h	r8,r4
80004cc4:	cf 83       	brcs	80004cb4 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004cc6:	e0 6b 00 80 	mov	r11,128
80004cca:	30 cc       	mov	r12,12
80004ccc:	f0 1f 00 0f 	mcall	80004d08 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004cd0:	30 0b       	mov	r11,0
80004cd2:	30 1c       	mov	r12,1
80004cd4:	f0 1f 00 0b 	mcall	80004d00 <PcdComMF522+0x168>
	return status;
}
80004cd8:	0e 9c       	mov	r12,r7
80004cda:	2f fd       	sub	sp,-4
80004cdc:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004cde:	e0 6b 00 80 	mov	r11,128
80004ce2:	30 dc       	mov	r12,13
80004ce4:	f0 1f 00 08 	mcall	80004d04 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004ce8:	30 6c       	mov	r12,6
80004cea:	f0 1f 00 09 	mcall	80004d0c <PcdComMF522+0x174>
80004cee:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004cf2:	cb 80       	breq	80004c62 <PcdComMF522+0xca>
80004cf4:	30 27       	mov	r7,2
80004cf6:	ce 8b       	rjmp	80004cc6 <PcdComMF522+0x12e>
80004cf8:	80 00       	ld.sh	r0,r0[0x0]
80004cfa:	d7 f8       	*unknown*
80004cfc:	80 00       	ld.sh	r0,r0[0x0]
80004cfe:	d7 fc       	*unknown*
80004d00:	80 00       	ld.sh	r0,r0[0x0]
80004d02:	48 e4       	lddpc	r4,80004d38 <PcdAnticoll+0x28>
80004d04:	80 00       	ld.sh	r0,r0[0x0]
80004d06:	4a 20       	lddpc	r0,80004d8c <PcdAnticoll+0x7c>
80004d08:	80 00       	ld.sh	r0,r0[0x0]
80004d0a:	49 dc       	lddpc	r12,80004d7c <PcdAnticoll+0x6c>
80004d0c:	80 00       	ld.sh	r0,r0[0x0]
80004d0e:	49 9c       	lddpc	r12,80004d70 <PcdAnticoll+0x60>

80004d10 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004d10:	eb cd 40 c0 	pushm	r6-r7,lr
80004d14:	20 5d       	sub	sp,20
80004d16:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004d18:	30 8b       	mov	r11,8
80004d1a:	16 9c       	mov	r12,r11
80004d1c:	f0 1f 00 1a 	mcall	80004d84 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004d20:	30 0b       	mov	r11,0
80004d22:	30 dc       	mov	r12,13
80004d24:	f0 1f 00 19 	mcall	80004d88 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004d28:	e0 6b 00 80 	mov	r11,128
80004d2c:	30 ec       	mov	r12,14
80004d2e:	f0 1f 00 16 	mcall	80004d84 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004d32:	39 38       	mov	r8,-109
80004d34:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004d36:	32 08       	mov	r8,32
80004d38:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004d3a:	1a 9b       	mov	r11,sp
80004d3c:	fa c8 ff ed 	sub	r8,sp,-19
80004d40:	1a 99       	mov	r9,sp
80004d42:	30 2a       	mov	r10,2
80004d44:	30 cc       	mov	r12,12
80004d46:	f0 1f 00 12 	mcall	80004d8c <PcdAnticoll+0x7c>
80004d4a:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004d4c:	c1 21       	brne	80004d70 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004d4e:	1b 89       	ld.ub	r9,sp[0x0]
80004d50:	ac 89       	st.b	r6[0x0],r9
80004d52:	1b 98       	ld.ub	r8,sp[0x1]
80004d54:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004d56:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004d58:	1b a8       	ld.ub	r8,sp[0x2]
80004d5a:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004d5c:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004d60:	1b b9       	ld.ub	r9,sp[0x3]
80004d62:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004d64:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004d66:	1b c9       	ld.ub	r9,sp[0x4]
80004d68:	f0 09 18 00 	cp.b	r9,r8
80004d6c:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004d70:	e0 6b 00 80 	mov	r11,128
80004d74:	30 ec       	mov	r12,14
80004d76:	f0 1f 00 07 	mcall	80004d90 <PcdAnticoll+0x80>
	return status;
}
80004d7a:	0e 9c       	mov	r12,r7
80004d7c:	2f bd       	sub	sp,-20
80004d7e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004d82:	00 00       	add	r0,r0
80004d84:	80 00       	ld.sh	r0,r0[0x0]
80004d86:	4a 20       	lddpc	r0,80004e0c <CalulateCRC+0x14>
80004d88:	80 00       	ld.sh	r0,r0[0x0]
80004d8a:	48 e4       	lddpc	r4,80004dc0 <PcdRequest+0x2c>
80004d8c:	80 00       	ld.sh	r0,r0[0x0]
80004d8e:	4b 98       	lddpc	r8,80004e70 <CalulateCRC+0x78>
80004d90:	80 00       	ld.sh	r0,r0[0x0]
80004d92:	49 dc       	lddpc	r12,80004e04 <CalulateCRC+0xc>

80004d94 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004d94:	eb cd 40 c0 	pushm	r6-r7,lr
80004d98:	20 5d       	sub	sp,20
80004d9a:	18 97       	mov	r7,r12
80004d9c:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004d9e:	30 8b       	mov	r11,8
80004da0:	16 9c       	mov	r12,r11
80004da2:	f0 1f 00 12 	mcall	80004de8 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004da6:	30 7b       	mov	r11,7
80004da8:	30 dc       	mov	r12,13
80004daa:	f0 1f 00 11 	mcall	80004dec <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004dae:	30 3b       	mov	r11,3
80004db0:	31 4c       	mov	r12,20
80004db2:	f0 1f 00 10 	mcall	80004df0 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004db6:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004db8:	1a 9b       	mov	r11,sp
80004dba:	fa c8 ff ed 	sub	r8,sp,-19
80004dbe:	1a 99       	mov	r9,sp
80004dc0:	30 1a       	mov	r10,1
80004dc2:	30 cc       	mov	r12,12
80004dc4:	f0 1f 00 0c 	mcall	80004df4 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004dc8:	c0 c1       	brne	80004de0 <PcdRequest+0x4c>
80004dca:	31 08       	mov	r8,16
80004dcc:	fb 39 00 13 	ld.ub	r9,sp[19]
80004dd0:	f0 09 18 00 	cp.b	r9,r8
80004dd4:	c0 61       	brne	80004de0 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004dd6:	1b 88       	ld.ub	r8,sp[0x0]
80004dd8:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004dda:	1b 98       	ld.ub	r8,sp[0x1]
80004ddc:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004dde:	c0 28       	rjmp	80004de2 <PcdRequest+0x4e>
80004de0:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004de2:	2f bd       	sub	sp,-20
80004de4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004de8:	80 00       	ld.sh	r0,r0[0x0]
80004dea:	4a 20       	lddpc	r0,80004e70 <CalulateCRC+0x78>
80004dec:	80 00       	ld.sh	r0,r0[0x0]
80004dee:	48 e4       	lddpc	r4,80004e24 <CalulateCRC+0x2c>
80004df0:	80 00       	ld.sh	r0,r0[0x0]
80004df2:	49 dc       	lddpc	r12,80004e64 <CalulateCRC+0x6c>
80004df4:	80 00       	ld.sh	r0,r0[0x0]
80004df6:	4b 98       	lddpc	r8,80004ed8 <PcdSelect+0x54>

80004df8 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004df8:	eb cd 40 f8 	pushm	r3-r7,lr
80004dfc:	18 95       	mov	r5,r12
80004dfe:	16 96       	mov	r6,r11
80004e00:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004e02:	30 4b       	mov	r11,4
80004e04:	30 5c       	mov	r12,5
80004e06:	f0 1f 00 1c 	mcall	80004e74 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004e0a:	30 0b       	mov	r11,0
80004e0c:	30 1c       	mov	r12,1
80004e0e:	f0 1f 00 1b 	mcall	80004e78 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004e12:	e0 6b 00 80 	mov	r11,128
80004e16:	30 ac       	mov	r12,10
80004e18:	f0 1f 00 19 	mcall	80004e7c <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004e1c:	58 06       	cp.w	r6,0
80004e1e:	c0 c0       	breq	80004e36 <CalulateCRC+0x3e>
80004e20:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004e22:	30 94       	mov	r4,9
80004e24:	0f 3b       	ld.ub	r11,r7++
80004e26:	08 9c       	mov	r12,r4
80004e28:	f0 1f 00 14 	mcall	80004e78 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004e2c:	0e 98       	mov	r8,r7
80004e2e:	0a 18       	sub	r8,r5
80004e30:	ec 08 18 00 	cp.b	r8,r6
80004e34:	cf 83       	brcs	80004e24 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004e36:	30 3b       	mov	r11,3
80004e38:	30 1c       	mov	r12,1
80004e3a:	f0 1f 00 10 	mcall	80004e78 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004e3e:	30 5c       	mov	r12,5
80004e40:	f0 1f 00 10 	mcall	80004e80 <CalulateCRC+0x88>
80004e44:	e0 67 00 fe 	mov	r7,254
80004e48:	30 56       	mov	r6,5
80004e4a:	c0 78       	rjmp	80004e58 <CalulateCRC+0x60>
80004e4c:	0c 9c       	mov	r12,r6
80004e4e:	f0 1f 00 0d 	mcall	80004e80 <CalulateCRC+0x88>
		i--;
80004e52:	20 17       	sub	r7,1
80004e54:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004e56:	c0 40       	breq	80004e5e <CalulateCRC+0x66>
80004e58:	e2 1c 00 04 	andl	r12,0x4,COH
80004e5c:	cf 80       	breq	80004e4c <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004e5e:	32 2c       	mov	r12,34
80004e60:	f0 1f 00 08 	mcall	80004e80 <CalulateCRC+0x88>
80004e64:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004e66:	32 1c       	mov	r12,33
80004e68:	f0 1f 00 06 	mcall	80004e80 <CalulateCRC+0x88>
80004e6c:	a6 9c       	st.b	r3[0x1],r12
}
80004e6e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004e72:	00 00       	add	r0,r0
80004e74:	80 00       	ld.sh	r0,r0[0x0]
80004e76:	4a 20       	lddpc	r0,80004efc <rfid_auto_reader+0x4>
80004e78:	80 00       	ld.sh	r0,r0[0x0]
80004e7a:	48 e4       	lddpc	r4,80004eb0 <PcdSelect+0x2c>
80004e7c:	80 00       	ld.sh	r0,r0[0x0]
80004e7e:	49 dc       	lddpc	r12,80004ef0 <PcdSelect+0x6c>
80004e80:	80 00       	ld.sh	r0,r0[0x0]
80004e82:	49 9c       	lddpc	r12,80004ee4 <PcdSelect+0x60>

80004e84 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004e84:	eb cd 40 80 	pushm	r7,lr
80004e88:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004e8a:	39 38       	mov	r8,-109
80004e8c:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004e8e:	37 08       	mov	r8,112
80004e90:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004e92:	30 08       	mov	r8,0
80004e94:	ba e8       	st.b	sp[0x6],r8
80004e96:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004e9a:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004e9e:	19 89       	ld.ub	r9,r12[0x0]
80004ea0:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004ea2:	19 3a       	ld.ub	r10,r12++
80004ea4:	1b e9       	ld.ub	r9,sp[0x6]
80004ea6:	f5 e9 20 09 	eor	r9,r10,r9
80004eaa:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004eac:	16 38       	cp.w	r8,r11
80004eae:	cf 81       	brne	80004e9e <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004eb0:	1a 97       	mov	r7,sp
80004eb2:	fa ca ff f9 	sub	r10,sp,-7
80004eb6:	30 7b       	mov	r11,7
80004eb8:	1a 9c       	mov	r12,sp
80004eba:	f0 1f 00 0d 	mcall	80004eec <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004ebe:	30 8b       	mov	r11,8
80004ec0:	16 9c       	mov	r12,r11
80004ec2:	f0 1f 00 0c 	mcall	80004ef0 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004ec6:	fa c8 ff ed 	sub	r8,sp,-19
80004eca:	1a 99       	mov	r9,sp
80004ecc:	30 9a       	mov	r10,9
80004ece:	1a 9b       	mov	r11,sp
80004ed0:	30 cc       	mov	r12,12
80004ed2:	f0 1f 00 09 	mcall	80004ef4 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80004ed6:	c0 71       	brne	80004ee4 <PcdSelect+0x60>
80004ed8:	31 88       	mov	r8,24
80004eda:	fb 39 00 13 	ld.ub	r9,sp[19]
80004ede:	f0 09 18 00 	cp.b	r9,r8
80004ee2:	c0 20       	breq	80004ee6 <PcdSelect+0x62>
80004ee4:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80004ee6:	2f bd       	sub	sp,-20
80004ee8:	e3 cd 80 80 	ldm	sp++,r7,pc
80004eec:	80 00       	ld.sh	r0,r0[0x0]
80004eee:	4d f8       	lddpc	r8,80005068 <rfid_sendID_message+0x50>
80004ef0:	80 00       	ld.sh	r0,r0[0x0]
80004ef2:	4a 20       	lddpc	r0,80004f78 <rfid_auto_reader+0x80>
80004ef4:	80 00       	ld.sh	r0,r0[0x0]
80004ef6:	4b 98       	lddpc	r8,80004fd8 <rfid_auto_reader+0xe0>

80004ef8 <rfid_auto_reader>:
		
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80004ef8:	eb cd 40 c0 	pushm	r6-r7,lr
80004efc:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80004efe:	f0 1f 00 37 	mcall	80004fd8 <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80004f02:	4b 7b       	lddpc	r11,80004fdc <rfid_auto_reader+0xe4>
80004f04:	35 2c       	mov	r12,82
80004f06:	f0 1f 00 37 	mcall	80004fe0 <rfid_auto_reader+0xe8>
80004f0a:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80004f0c:	c6 31       	brne	80004fd2 <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004f0e:	4b 48       	lddpc	r8,80004fdc <rfid_auto_reader+0xe4>
80004f10:	11 88       	ld.ub	r8,r8[0x0]
80004f12:	30 49       	mov	r9,4
80004f14:	f2 08 18 00 	cp.b	r8,r9
80004f18:	c0 b1       	brne	80004f2e <rfid_auto_reader+0x36>
80004f1a:	4b 19       	lddpc	r9,80004fdc <rfid_auto_reader+0xe4>
80004f1c:	13 9a       	ld.ub	r10,r9[0x1]
80004f1e:	30 09       	mov	r9,0
80004f20:	f2 0a 18 00 	cp.b	r10,r9
80004f24:	c0 51       	brne	80004f2e <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
80004f26:	4b 0c       	lddpc	r12,80004fe4 <rfid_auto_reader+0xec>
80004f28:	f0 1f 00 30 	mcall	80004fe8 <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004f2c:	c3 c8       	rjmp	80004fa4 <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004f2e:	30 29       	mov	r9,2
80004f30:	f2 08 18 00 	cp.b	r8,r9
80004f34:	c0 b1       	brne	80004f4a <rfid_auto_reader+0x52>
80004f36:	4a a9       	lddpc	r9,80004fdc <rfid_auto_reader+0xe4>
80004f38:	13 9a       	ld.ub	r10,r9[0x1]
80004f3a:	30 09       	mov	r9,0
80004f3c:	f2 0a 18 00 	cp.b	r10,r9
80004f40:	c0 51       	brne	80004f4a <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80004f42:	4a bc       	lddpc	r12,80004fec <rfid_auto_reader+0xf4>
80004f44:	f0 1f 00 29 	mcall	80004fe8 <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004f48:	c2 e8       	rjmp	80004fa4 <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004f4a:	34 49       	mov	r9,68
80004f4c:	f2 08 18 00 	cp.b	r8,r9
80004f50:	c0 b1       	brne	80004f66 <rfid_auto_reader+0x6e>
80004f52:	4a 39       	lddpc	r9,80004fdc <rfid_auto_reader+0xe4>
80004f54:	13 9a       	ld.ub	r10,r9[0x1]
80004f56:	30 09       	mov	r9,0
80004f58:	f2 0a 18 00 	cp.b	r10,r9
80004f5c:	c0 51       	brne	80004f66 <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80004f5e:	4a 5c       	lddpc	r12,80004ff0 <rfid_auto_reader+0xf8>
80004f60:	f0 1f 00 22 	mcall	80004fe8 <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004f64:	c2 08       	rjmp	80004fa4 <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004f66:	30 89       	mov	r9,8
80004f68:	f2 08 18 00 	cp.b	r8,r9
80004f6c:	c0 b1       	brne	80004f82 <rfid_auto_reader+0x8a>
80004f6e:	49 c9       	lddpc	r9,80004fdc <rfid_auto_reader+0xe4>
80004f70:	13 9a       	ld.ub	r10,r9[0x1]
80004f72:	30 09       	mov	r9,0
80004f74:	f2 0a 18 00 	cp.b	r10,r9
80004f78:	c0 51       	brne	80004f82 <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80004f7a:	49 fc       	lddpc	r12,80004ff4 <rfid_auto_reader+0xfc>
80004f7c:	f0 1f 00 1b 	mcall	80004fe8 <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004f80:	c1 28       	rjmp	80004fa4 <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004f82:	34 49       	mov	r9,68
80004f84:	f2 08 18 00 	cp.b	r8,r9
80004f88:	c0 b1       	brne	80004f9e <rfid_auto_reader+0xa6>
80004f8a:	49 58       	lddpc	r8,80004fdc <rfid_auto_reader+0xe4>
80004f8c:	11 99       	ld.ub	r9,r8[0x1]
80004f8e:	30 38       	mov	r8,3
80004f90:	f0 09 18 00 	cp.b	r9,r8
80004f94:	c0 51       	brne	80004f9e <rfid_auto_reader+0xa6>
		log("MF Desire\n");
80004f96:	49 9c       	lddpc	r12,80004ff8 <rfid_auto_reader+0x100>
80004f98:	f0 1f 00 14 	mcall	80004fe8 <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004f9c:	c0 48       	rjmp	80004fa4 <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80004f9e:	49 8c       	lddpc	r12,80004ffc <rfid_auto_reader+0x104>
80004fa0:	f0 1f 00 12 	mcall	80004fe8 <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80004fa4:	49 7c       	lddpc	r12,80005000 <rfid_auto_reader+0x108>
80004fa6:	f0 1f 00 18 	mcall	80005004 <rfid_auto_reader+0x10c>
80004faa:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80004fac:	c0 60       	breq	80004fb8 <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
80004fae:	37 8b       	mov	r11,120
80004fb0:	30 1c       	mov	r12,1
80004fb2:	f0 1f 00 16 	mcall	80005008 <rfid_auto_reader+0x110>
		return status;
80004fb6:	c0 e8       	rjmp	80004fd2 <rfid_auto_reader+0xda>
	}
	//continue;
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80004fb8:	49 2c       	lddpc	r12,80005000 <rfid_auto_reader+0x108>
80004fba:	f0 1f 00 15 	mcall	8000500c <rfid_auto_reader+0x114>
80004fbe:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80004fc0:	c0 91       	brne	80004fd2 <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80004fc2:	30 4a       	mov	r10,4
80004fc4:	48 fb       	lddpc	r11,80005000 <rfid_auto_reader+0x108>
80004fc6:	0c 9c       	mov	r12,r6
80004fc8:	f0 1f 00 12 	mcall	80005010 <rfid_auto_reader+0x118>
		log("select okay\n");
80004fcc:	49 2c       	lddpc	r12,80005014 <rfid_auto_reader+0x11c>
80004fce:	f0 1f 00 07 	mcall	80004fe8 <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
80004fd2:	0e 9c       	mov	r12,r7
80004fd4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004fd8:	80 00       	ld.sh	r0,r0[0x0]
80004fda:	49 1c       	lddpc	r12,8000501c <rfid_sendID_message+0x4>
80004fdc:	00 00       	add	r0,r0
80004fde:	53 a0       	stdsp	sp[0xe8],r0
80004fe0:	80 00       	ld.sh	r0,r0[0x0]
80004fe2:	4d 94       	lddpc	r4,80005144 <rfid_sendID_message+0x12c>
80004fe4:	80 00       	ld.sh	r0,r0[0x0]
80004fe6:	d8 20       	acall	0x82
80004fe8:	80 00       	ld.sh	r0,r0[0x0]
80004fea:	6f d0       	ld.w	r0,r7[0x74]
80004fec:	80 00       	ld.sh	r0,r0[0x0]
80004fee:	d8 2c       	*unknown*
80004ff0:	80 00       	ld.sh	r0,r0[0x0]
80004ff2:	d8 38       	*unknown*
80004ff4:	80 00       	ld.sh	r0,r0[0x0]
80004ff6:	d8 48       	*unknown*
80004ff8:	80 00       	ld.sh	r0,r0[0x0]
80004ffa:	d8 50       	acall	0x85
80004ffc:	80 00       	ld.sh	r0,r0[0x0]
80004ffe:	d8 5c       	*unknown*
80005000:	00 00       	add	r0,r0
80005002:	53 a4       	stdsp	sp[0xe8],r4
80005004:	80 00       	ld.sh	r0,r0[0x0]
80005006:	4d 10       	lddpc	r0,80005148 <rfid_sendID_message+0x130>
80005008:	80 00       	ld.sh	r0,r0[0x0]
8000500a:	40 44       	lddsp	r4,sp[0x10]
8000500c:	80 00       	ld.sh	r0,r0[0x0]
8000500e:	4e 84       	lddpc	r4,800051ac <delay_us>
80005010:	80 00       	ld.sh	r0,r0[0x0]
80005012:	78 54       	ld.w	r4,r12[0x14]
80005014:	80 00       	ld.sh	r0,r0[0x0]
80005016:	d8 68       	*unknown*

80005018 <rfid_sendID_message>:

extern volatile DateTime_t Current_time;
U8 rfid_sendID_message()
{
80005018:	eb cd 40 e0 	pushm	r5-r7,lr
8000501c:	21 fd       	sub	sp,124
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	//memset(data_buffer, 0x00, 16);
	memset(SN, 0x00, 10);
8000501e:	fa cc ff 90 	sub	r12,sp,-112
80005022:	30 08       	mov	r8,0
80005024:	30 09       	mov	r9,0
80005026:	f8 e9 00 00 	st.d	r12[0],r8
8000502a:	30 0a       	mov	r10,0
8000502c:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
8000502e:	fa e9 00 20 	st.d	sp[32],r8
80005032:	fa e9 00 28 	st.d	sp[40],r8
80005036:	fa e9 00 30 	st.d	sp[48],r8
8000503a:	fa e9 00 38 	st.d	sp[56],r8
8000503e:	fa e9 00 40 	st.d	sp[64],r8
80005042:	fa e9 00 48 	st.d	sp[72],r8
80005046:	fa e9 00 50 	st.d	sp[80],r8
8000504a:	fa e9 00 58 	st.d	sp[88],r8
8000504e:	fa e9 00 60 	st.d	sp[96],r8
80005052:	fa e9 00 68 	st.d	sp[104],r8

	return_err = rfid_auto_reader(SN);
80005056:	f0 1f 00 43 	mcall	80005160 <rfid_sendID_message+0x148>
8000505a:	18 97       	mov	r7,r12
	
	if(return_err == 0){
8000505c:	c7 61       	brne	80005148 <rfid_sendID_message+0x130>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
8000505e:	fb 38 00 73 	ld.ub	r8,sp[115]
80005062:	1a d8       	st.w	--sp,r8
80005064:	fb 38 00 76 	ld.ub	r8,sp[118]
80005068:	1a d8       	st.w	--sp,r8
8000506a:	fb 38 00 79 	ld.ub	r8,sp[121]
8000506e:	1a d8       	st.w	--sp,r8
80005070:	fb 38 00 7c 	ld.ub	r8,sp[124]
80005074:	1a d8       	st.w	--sp,r8
80005076:	4b cc       	lddpc	r12,80005164 <rfid_sendID_message+0x14c>
80005078:	f0 1f 00 3c 	mcall	80005168 <rfid_sendID_message+0x150>
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
8000507c:	37 7b       	mov	r11,119
8000507e:	30 1c       	mov	r12,1
80005080:	f0 1f 00 3b 	mcall	8000516c <rfid_sendID_message+0x154>
80005084:	fa c9 ff 80 	sub	r9,sp,-128
80005088:	fa c8 ff f0 	sub	r8,sp,-16
8000508c:	fa ca ff ee 	sub	r10,sp,-18
//}
	
}

extern volatile DateTime_t Current_time;
U8 rfid_sendID_message()
80005090:	fa c5 ff 7c 	sub	r5,sp,-132
80005094:	10 9d       	mov	sp,r8
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80005096:	30 9e       	mov	lr,9
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80005098:	30 06       	mov	r6,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
8000509a:	13 8b       	ld.ub	r11,r9[0x0]
8000509c:	f6 0c 16 04 	lsr	r12,r11,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
800050a0:	fc 0c 18 00 	cp.b	r12,lr
800050a4:	f7 bc 08 d0 	subls	r12,-48
800050a8:	f1 fc 8e 00 	st.bls	r8[0x0],r12
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
800050ac:	f7 bc 0b a9 	subhi	r12,-87
800050b0:	f1 fc be 00 	st.bhi	r8[0x0],r12
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
800050b4:	b0 96       	st.b	r8[0x1],r6
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
800050b6:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
800050ba:	fc 0b 18 00 	cp.b	r11,lr
800050be:	f7 bb 08 d0 	subls	r11,-48
800050c2:	f5 fb 8e 00 	st.bls	r10[0x0],r11
			 else
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
800050c6:	f7 bb 0b a9 	subhi	r11,-87
800050ca:	f5 fb be 00 	st.bhi	r10[0x0],r11

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
800050ce:	b0 b6       	st.b	r8[0x3],r6
800050d0:	2f f9       	sub	r9,-1
800050d2:	2f c8       	sub	r8,-4
800050d4:	2f ca       	sub	r10,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
800050d6:	0a 39       	cp.w	r9,r5
800050d8:	ce 11       	brne	8000509a <rfid_sendID_message+0x82>
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
		}
		
		memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
800050da:	30 6a       	mov	r10,6
800050dc:	4a 5b       	lddpc	r11,80005170 <rfid_sendID_message+0x158>
800050de:	fa cc ff f0 	sub	r12,sp,-16
800050e2:	f0 1f 00 25 	mcall	80005174 <rfid_sendID_message+0x15c>
	
		header.length = (0x0008 + sizeof(Message_Data_t));
	
		if(start_session > 0x9f)start_session = 0x80;
800050e6:	4a 58       	lddpc	r8,80005178 <rfid_sendID_message+0x160>
800050e8:	11 89       	ld.ub	r9,r8[0x0]
800050ea:	39 f8       	mov	r8,-97
800050ec:	f0 09 18 00 	cp.b	r9,r8
800050f0:	e0 88 00 05 	brls	800050fa <rfid_sendID_message+0xe2>
800050f4:	38 09       	mov	r9,-128
800050f6:	4a 18       	lddpc	r8,80005178 <rfid_sendID_message+0x160>
800050f8:	b0 89       	st.b	r8[0x0],r9
	
		header.session_id = (++start_session);
800050fa:	4a 08       	lddpc	r8,80005178 <rfid_sendID_message+0x160>
800050fc:	11 86       	ld.ub	r6,r8[0x0]
800050fe:	2f f6       	sub	r6,-1
80005100:	b0 86       	st.b	r8[0x0],r6
	
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
80005102:	30 5a       	mov	r10,5
80005104:	49 eb       	lddpc	r11,8000517c <rfid_sendID_message+0x164>
80005106:	fa cc ff e5 	sub	r12,sp,-27
8000510a:	f0 1f 00 1b 	mcall	80005174 <rfid_sendID_message+0x15c>
		header.type = 0xe000;
	
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
8000510e:	31 e8       	mov	r8,30
80005110:	fb 58 00 16 	st.h	sp[22],r8
80005114:	fb 66 00 1a 	st.b	sp[26],r6
80005118:	fe 78 e0 00 	mov	r8,-8192
8000511c:	fb 58 00 18 	st.h	sp[24],r8
80005120:	fa c6 ff e0 	sub	r6,sp,-32
80005124:	30 aa       	mov	r10,10
80005126:	fa cb ff ea 	sub	r11,sp,-22
8000512a:	0c 9c       	mov	r12,r6
8000512c:	f0 1f 00 12 	mcall	80005174 <rfid_sendID_message+0x15c>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
80005130:	31 6a       	mov	r10,22
80005132:	1a 9b       	mov	r11,sp
80005134:	fa cc ff d6 	sub	r12,sp,-42
80005138:	f0 1f 00 0f 	mcall	80005174 <rfid_sendID_message+0x15c>
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
8000513c:	30 9a       	mov	r10,9
8000513e:	32 0b       	mov	r11,32
80005140:	0c 9c       	mov	r12,r6
80005142:	f0 1f 00 10 	mcall	80005180 <rfid_sendID_message+0x168>
80005146:	c0 88       	rjmp	80005156 <rfid_sendID_message+0x13e>
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate scan rfid failure!!!
80005148:	37 8b       	mov	r11,120
8000514a:	30 1c       	mov	r12,1
8000514c:	f0 1f 00 08 	mcall	8000516c <rfid_sendID_message+0x154>
		log("no card find...\n");
80005150:	48 dc       	lddpc	r12,80005184 <rfid_sendID_message+0x16c>
80005152:	f0 1f 00 06 	mcall	80005168 <rfid_sendID_message+0x150>
	}
	
	return return_err;
	
}
80005156:	0e 9c       	mov	r12,r7
80005158:	2e 1d       	sub	sp,-124
8000515a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000515e:	00 00       	add	r0,r0
80005160:	80 00       	ld.sh	r0,r0[0x0]
80005162:	4e f8       	lddpc	r8,8000531c <xg_flashc_init+0x60>
80005164:	80 00       	ld.sh	r0,r0[0x0]
80005166:	d8 78       	*unknown*
80005168:	80 00       	ld.sh	r0,r0[0x0]
8000516a:	6f d0       	ld.w	r0,r7[0x74]
8000516c:	80 00       	ld.sh	r0,r0[0x0]
8000516e:	40 44       	lddsp	r4,sp[0x10]
80005170:	00 00       	add	r0,r0
80005172:	0d 90       	ld.ub	r0,r6[0x1]
80005174:	80 00       	ld.sh	r0,r0[0x0]
80005176:	78 54       	ld.w	r4,r12[0x14]
80005178:	00 00       	add	r0,r0
8000517a:	05 30       	ld.ub	r0,r2++
8000517c:	00 00       	add	r0,r0
8000517e:	05 28       	ld.uh	r8,r2++
80005180:	80 00       	ld.sh	r0,r0[0x0]
80005182:	3f 0c       	mov	r12,-16
80005184:	80 00       	ld.sh	r0,r0[0x0]
80005186:	d8 94       	*unknown*

80005188 <rfid_init>:
U8 RFID[16];			//瀛RFID
U8 unsure_data[5]={0x04, 0x0d, 0x00, 0x0a, 0x00};


void rfid_init()
{
80005188:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
8000518a:	f0 1f 00 02 	mcall	80005190 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		
}
8000518e:	d8 02       	popm	pc
80005190:	80 00       	ld.sh	r0,r0[0x0]
80005192:	4a c8       	lddpc	r8,80005240 <local_start_pll0+0x18>

80005194 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005194:	58 0c       	cp.w	r12,0
80005196:	5e 0c       	reteq	r12
80005198:	30 08       	mov	r8,0
	{
		nop();
8000519a:	d7 03       	nop
		nop();
8000519c:	d7 03       	nop
		nop();
8000519e:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
800051a0:	2f f8       	sub	r8,-1
800051a2:	10 3c       	cp.w	r12,r8
800051a4:	fe 9b ff fb 	brhi	8000519a <delay_ns+0x6>
800051a8:	5e fc       	retal	r12
800051aa:	d7 03       	nop

800051ac <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
800051ac:	eb cd 40 e0 	pushm	r5-r7,lr
800051b0:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
800051b2:	58 0c       	cp.w	r12,0
800051b4:	c0 b0       	breq	800051ca <delay_us+0x1e>
800051b6:	30 07       	mov	r7,0
		delay_ns(1000);
800051b8:	e0 65 03 e8 	mov	r5,1000
800051bc:	0a 9c       	mov	r12,r5
800051be:	f0 1f 00 05 	mcall	800051d0 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
800051c2:	2f f7       	sub	r7,-1
800051c4:	0e 36       	cp.w	r6,r7
800051c6:	fe 9b ff fb 	brhi	800051bc <delay_us+0x10>
800051ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800051ce:	00 00       	add	r0,r0
800051d0:	80 00       	ld.sh	r0,r0[0x0]
800051d2:	51 94       	stdsp	sp[0x64],r4

800051d4 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
800051d4:	eb cd 40 e0 	pushm	r5-r7,lr
800051d8:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
800051da:	58 0c       	cp.w	r12,0
800051dc:	c0 b0       	breq	800051f2 <delay_ms+0x1e>
800051de:	30 07       	mov	r7,0
		delay_us(1000);
800051e0:	e0 65 03 e8 	mov	r5,1000
800051e4:	0a 9c       	mov	r12,r5
800051e6:	f0 1f 00 05 	mcall	800051f8 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
800051ea:	2f f7       	sub	r7,-1
800051ec:	0e 36       	cp.w	r6,r7
800051ee:	fe 9b ff fb 	brhi	800051e4 <delay_ms+0x10>
800051f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800051f6:	00 00       	add	r0,r0
800051f8:	80 00       	ld.sh	r0,r0[0x0]
800051fa:	51 ac       	stdsp	sp[0x68],r12

800051fc <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
800051fc:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
800051fe:	30 3b       	mov	r11,3
80005200:	48 8c       	lddpc	r12,80005220 <local_start_timer+0x24>
80005202:	f0 1f 00 09 	mcall	80005224 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
80005206:	fe 78 38 00 	mov	r8,-51200
8000520a:	e0 69 91 0d 	mov	r9,37133
8000520e:	ea 19 00 52 	orh	r9,0x52
80005212:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005214:	32 09       	mov	r9,32
80005216:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005218:	30 59       	mov	r9,5
8000521a:	91 09       	st.w	r8[0x0],r9
}
8000521c:	d8 02       	popm	pc
8000521e:	00 00       	add	r0,r0
80005220:	80 00       	ld.sh	r0,r0[0x0]
80005222:	d8 a8       	*unknown*
80005224:	80 00       	ld.sh	r0,r0[0x0]
80005226:	53 b4       	stdsp	sp[0xec],r4

80005228 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
80005228:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
8000522a:	30 3a       	mov	r10,3
8000522c:	e0 6b 1b 00 	mov	r11,6912
80005230:	ea 1b 00 b7 	orh	r11,0xb7
80005234:	fe 7c 0c 00 	mov	r12,-62464
80005238:	f0 1f 00 19 	mcall	8000529c <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
8000523c:	31 08       	mov	r8,16
8000523e:	1a d8       	st.w	--sp,r8
80005240:	30 08       	mov	r8,0
80005242:	30 19       	mov	r9,1
80005244:	30 7a       	mov	r10,7
80005246:	10 9b       	mov	r11,r8
80005248:	fe 7c 0c 00 	mov	r12,-62464
8000524c:	f0 1f 00 15 	mcall	800052a0 <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
80005250:	30 08       	mov	r8,0
80005252:	30 19       	mov	r9,1
80005254:	12 9a       	mov	r10,r9
80005256:	10 9b       	mov	r11,r8
80005258:	fe 7c 0c 00 	mov	r12,-62464
8000525c:	f0 1f 00 12 	mcall	800052a4 <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
80005260:	30 0b       	mov	r11,0
80005262:	fe 7c 0c 00 	mov	r12,-62464
80005266:	f0 1f 00 11 	mcall	800052a8 <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
8000526a:	fe 7c 0c 00 	mov	r12,-62464
8000526e:	f0 1f 00 10 	mcall	800052ac <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
80005272:	30 0a       	mov	r10,0
80005274:	1a da       	st.w	--sp,r10
80005276:	1a da       	st.w	--sp,r10
80005278:	14 98       	mov	r8,r10
8000527a:	14 99       	mov	r9,r10
8000527c:	30 1b       	mov	r11,1
8000527e:	fe 7c 0c 00 	mov	r12,-62464
80005282:	f0 1f 00 0c 	mcall	800052b0 <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
80005286:	30 1c       	mov	r12,1
80005288:	f0 1f 00 0b 	mcall	800052b4 <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
8000528c:	30 2b       	mov	r11,2
8000528e:	fe 7c 0c 00 	mov	r12,-62464
80005292:	f0 1f 00 0a 	mcall	800052b8 <local_start_pll0+0x90>
80005296:	2f dd       	sub	sp,-12
/****/
}
80005298:	d8 02       	popm	pc
8000529a:	00 00       	add	r0,r0
8000529c:	80 00       	ld.sh	r0,r0[0x0]
8000529e:	56 bc       	stdsp	sp[0x1ac],r12
800052a0:	80 00       	ld.sh	r0,r0[0x0]
800052a2:	56 5e       	stdsp	sp[0x194],lr
800052a4:	80 00       	ld.sh	r0,r0[0x0]
800052a6:	56 80       	stdsp	sp[0x1a0],r0
800052a8:	80 00       	ld.sh	r0,r0[0x0]
800052aa:	56 9a       	stdsp	sp[0x1a4],r10
800052ac:	80 00       	ld.sh	r0,r0[0x0]
800052ae:	56 a8       	stdsp	sp[0x1a8],r8
800052b0:	80 00       	ld.sh	r0,r0[0x0]
800052b2:	56 18       	stdsp	sp[0x184],r8
800052b4:	80 00       	ld.sh	r0,r0[0x0]
800052b6:	53 54       	stdsp	sp[0xd4],r4
800052b8:	80 00       	ld.sh	r0,r0[0x0]
800052ba:	56 b2       	stdsp	sp[0x1ac],r2

800052bc <xg_flashc_init>:
	//
}

//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
800052bc:	eb cd 40 e0 	pushm	r5-r7,lr
	
	/* Create the mutex semaphore to guard a shared xgflash.*/
	xgflash_mutex = xSemaphoreCreateMutex();
800052c0:	f0 1f 00 1a 	mcall	80005328 <xg_flashc_init+0x6c>
800052c4:	49 a8       	lddpc	r8,8000532c <xg_flashc_init+0x70>
800052c6:	91 0c       	st.w	r8[0x0],r12
	if (xgflash_mutex == NULL)
800052c8:	70 08       	ld.w	r8,r8[0x0]
800052ca:	58 08       	cp.w	r8,0
800052cc:	c0 41       	brne	800052d4 <xg_flashc_init+0x18>
	{
		log("Create the xgflash_mutex semaphore failure\n");
800052ce:	49 9c       	lddpc	r12,80005330 <xg_flashc_init+0x74>
800052d0:	f0 1f 00 19 	mcall	80005334 <xg_flashc_init+0x78>
	}
	
	/* Create the binary semaphore to Synchronize other threads.*/
	vSemaphoreCreateBinary(xBinarySemaphore);
800052d4:	30 0b       	mov	r11,0
800052d6:	30 1c       	mov	r12,1
800052d8:	f0 1f 00 18 	mcall	80005338 <xg_flashc_init+0x7c>
800052dc:	49 88       	lddpc	r8,8000533c <xg_flashc_init+0x80>
800052de:	91 0c       	st.w	r8[0x0],r12
800052e0:	70 08       	ld.w	r8,r8[0x0]
800052e2:	58 08       	cp.w	r8,0
800052e4:	c0 80       	breq	800052f4 <xg_flashc_init+0x38>
800052e6:	49 68       	lddpc	r8,8000533c <xg_flashc_init+0x80>
800052e8:	70 0c       	ld.w	r12,r8[0x0]
800052ea:	30 09       	mov	r9,0
800052ec:	12 9a       	mov	r10,r9
800052ee:	12 9b       	mov	r11,r9
800052f0:	f0 1f 00 14 	mcall	80005340 <xg_flashc_init+0x84>
	
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
800052f4:	30 4b       	mov	r11,4
800052f6:	31 4c       	mov	r12,20
800052f8:	f0 1f 00 10 	mcall	80005338 <xg_flashc_init+0x7c>
800052fc:	49 28       	lddpc	r8,80005344 <xg_flashc_init+0x88>
800052fe:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
80005300:	30 4b       	mov	r11,4
80005302:	31 4c       	mov	r12,20
80005304:	f0 1f 00 0d 	mcall	80005338 <xg_flashc_init+0x7c>
80005308:	49 08       	lddpc	r8,80005348 <xg_flashc_init+0x8c>
8000530a:	91 0c       	st.w	r8[0x0],r12
8000530c:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
8000530e:	10 96       	mov	r6,r8
80005310:	48 f5       	lddpc	r5,8000534c <xg_flashc_init+0x90>
80005312:	6c 0c       	ld.w	r12,r6[0x0]
80005314:	ea 07 00 0b 	add	r11,r5,r7
80005318:	f0 1f 00 0e 	mcall	80005350 <xg_flashc_init+0x94>
8000531c:	2e 07       	sub	r7,-32
	
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
8000531e:	e0 47 02 80 	cp.w	r7,640
80005322:	cf 81       	brne	80005312 <xg_flashc_init+0x56>
	////flash_rw_example(ch, flash_nvram_data);
	////flash_rw_example(ch, &temp_data);
	
	#endif
	
}
80005324:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005328:	80 00       	ld.sh	r0,r0[0x0]
8000532a:	64 98       	ld.w	r8,r2[0x24]
8000532c:	00 00       	add	r0,r0
8000532e:	0b 64       	ld.uh	r4,--r5
80005330:	80 00       	ld.sh	r0,r0[0x0]
80005332:	d8 c0       	acall	0x8c
80005334:	80 00       	ld.sh	r0,r0[0x0]
80005336:	6f d0       	ld.w	r0,r7[0x74]
80005338:	80 00       	ld.sh	r0,r0[0x0]
8000533a:	64 f0       	ld.w	r0,r2[0x3c]
8000533c:	00 00       	add	r0,r0
8000533e:	53 a8       	stdsp	sp[0xe8],r8
80005340:	80 00       	ld.sh	r0,r0[0x0]
80005342:	63 98       	ld.w	r8,r1[0x64]
80005344:	00 00       	add	r0,r0
80005346:	0b 60       	ld.uh	r0,--r5
80005348:	00 00       	add	r0,r0
8000534a:	0b 68       	ld.uh	r8,--r5
8000534c:	00 00       	add	r0,r0
8000534e:	0d 96       	ld.ub	r6,r6[0x1]
80005350:	80 00       	ld.sh	r0,r0[0x0]
80005352:	2b d4       	sub	r4,-67

80005354 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
80005354:	fe 68 14 00 	mov	r8,-125952
80005358:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
8000535a:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
8000535e:	91 09       	st.w	r8[0x0],r9
}
80005360:	5e fc       	retal	r12

80005362 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005362:	f8 08 16 05 	lsr	r8,r12,0x5
80005366:	a9 68       	lsl	r8,0x8
80005368:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
8000536c:	58 1b       	cp.w	r11,1
8000536e:	c0 d0       	breq	80005388 <gpio_enable_module_pin+0x26>
80005370:	c0 63       	brcs	8000537c <gpio_enable_module_pin+0x1a>
80005372:	58 2b       	cp.w	r11,2
80005374:	c1 00       	breq	80005394 <gpio_enable_module_pin+0x32>
80005376:	58 3b       	cp.w	r11,3
80005378:	c1 40       	breq	800053a0 <gpio_enable_module_pin+0x3e>
8000537a:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000537c:	30 19       	mov	r9,1
8000537e:	f2 0c 09 49 	lsl	r9,r9,r12
80005382:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005384:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005386:	c1 28       	rjmp	800053aa <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005388:	30 19       	mov	r9,1
8000538a:	f2 0c 09 49 	lsl	r9,r9,r12
8000538e:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005390:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005392:	c0 c8       	rjmp	800053aa <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005394:	30 19       	mov	r9,1
80005396:	f2 0c 09 49 	lsl	r9,r9,r12
8000539a:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000539c:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000539e:	c0 68       	rjmp	800053aa <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800053a0:	30 19       	mov	r9,1
800053a2:	f2 0c 09 49 	lsl	r9,r9,r12
800053a6:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800053a8:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800053aa:	30 19       	mov	r9,1
800053ac:	f2 0c 09 4c 	lsl	r12,r9,r12
800053b0:	91 2c       	st.w	r8[0x8],r12
800053b2:	5e fd       	retal	0

800053b4 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800053b4:	d4 21       	pushm	r4-r7,lr
800053b6:	18 97       	mov	r7,r12
800053b8:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800053ba:	58 0b       	cp.w	r11,0
800053bc:	c0 31       	brne	800053c2 <gpio_enable_module+0xe>
800053be:	30 05       	mov	r5,0
800053c0:	c0 d8       	rjmp	800053da <gpio_enable_module+0x26>
800053c2:	30 06       	mov	r6,0
800053c4:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800053c6:	6e 1b       	ld.w	r11,r7[0x4]
800053c8:	6e 0c       	ld.w	r12,r7[0x0]
800053ca:	f0 1f 00 06 	mcall	800053e0 <gpio_enable_module+0x2c>
800053ce:	18 45       	or	r5,r12
		gpiomap++;
800053d0:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800053d2:	2f f6       	sub	r6,-1
800053d4:	0c 34       	cp.w	r4,r6
800053d6:	fe 9b ff f8 	brhi	800053c6 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
800053da:	0a 9c       	mov	r12,r5
800053dc:	d8 22       	popm	r4-r7,pc
800053de:	00 00       	add	r0,r0
800053e0:	80 00       	ld.sh	r0,r0[0x0]
800053e2:	53 62       	stdsp	sp[0xd8],r2

800053e4 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800053e4:	f8 08 16 05 	lsr	r8,r12,0x5
800053e8:	a9 68       	lsl	r8,0x8
800053ea:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
800053ee:	30 19       	mov	r9,1
800053f0:	f2 0c 09 4c 	lsl	r12,r9,r12
800053f4:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
800053f8:	91 1c       	st.w	r8[0x4],r12
}
800053fa:	5e fc       	retal	r12

800053fc <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800053fc:	f8 08 16 05 	lsr	r8,r12,0x5
80005400:	a9 68       	lsl	r8,0x8
80005402:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80005406:	30 19       	mov	r9,1
80005408:	f2 0c 09 4c 	lsl	r12,r9,r12
8000540c:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80005410:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005414:	91 1c       	st.w	r8[0x4],r12
}
80005416:	5e fc       	retal	r12

80005418 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005418:	f8 08 16 05 	lsr	r8,r12,0x5
8000541c:	a9 68       	lsl	r8,0x8
8000541e:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80005422:	30 19       	mov	r9,1
80005424:	f2 0c 09 4c 	lsl	r12,r9,r12
80005428:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
8000542c:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005430:	91 1c       	st.w	r8[0x4],r12
}
80005432:	5e fc       	retal	r12

80005434 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80005434:	c0 08       	rjmp	80005434 <_unhandled_interrupt>
80005436:	d7 03       	nop

80005438 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005438:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
8000543c:	49 99       	lddpc	r9,800054a0 <INTC_register_interrupt+0x68>
8000543e:	f2 08 00 39 	add	r9,r9,r8<<0x3
80005442:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80005446:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80005448:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
8000544c:	58 0a       	cp.w	r10,0
8000544e:	c0 91       	brne	80005460 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005450:	49 59       	lddpc	r9,800054a4 <INTC_register_interrupt+0x6c>
80005452:	49 6a       	lddpc	r10,800054a8 <INTC_register_interrupt+0x70>
80005454:	12 1a       	sub	r10,r9
80005456:	fe 79 08 00 	mov	r9,-63488
8000545a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000545e:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005460:	58 1a       	cp.w	r10,1
80005462:	c0 a1       	brne	80005476 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80005464:	49 09       	lddpc	r9,800054a4 <INTC_register_interrupt+0x6c>
80005466:	49 2a       	lddpc	r10,800054ac <INTC_register_interrupt+0x74>
80005468:	12 1a       	sub	r10,r9
8000546a:	bf aa       	sbr	r10,0x1e
8000546c:	fe 79 08 00 	mov	r9,-63488
80005470:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005474:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80005476:	58 2a       	cp.w	r10,2
80005478:	c0 a1       	brne	8000548c <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000547a:	48 b9       	lddpc	r9,800054a4 <INTC_register_interrupt+0x6c>
8000547c:	48 da       	lddpc	r10,800054b0 <INTC_register_interrupt+0x78>
8000547e:	12 1a       	sub	r10,r9
80005480:	bf ba       	sbr	r10,0x1f
80005482:	fe 79 08 00 	mov	r9,-63488
80005486:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000548a:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
8000548c:	48 69       	lddpc	r9,800054a4 <INTC_register_interrupt+0x6c>
8000548e:	48 aa       	lddpc	r10,800054b4 <INTC_register_interrupt+0x7c>
80005490:	12 1a       	sub	r10,r9
80005492:	ea 1a c0 00 	orh	r10,0xc000
80005496:	fe 79 08 00 	mov	r9,-63488
8000549a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000549e:	5e fc       	retal	r12
800054a0:	80 00       	ld.sh	r0,r0[0x0]
800054a2:	d9 70       	acall	0x97
800054a4:	80 00       	ld.sh	r0,r0[0x0]
800054a6:	ce 00       	breq	80005466 <INTC_register_interrupt+0x2e>
800054a8:	80 00       	ld.sh	r0,r0[0x0]
800054aa:	cf 04       	brge	8000548a <INTC_register_interrupt+0x52>
800054ac:	80 00       	ld.sh	r0,r0[0x0]
800054ae:	cf 12       	brcc	80005490 <INTC_register_interrupt+0x58>
800054b0:	80 00       	ld.sh	r0,r0[0x0]
800054b2:	cf 20       	breq	80005496 <INTC_register_interrupt+0x5e>
800054b4:	80 00       	ld.sh	r0,r0[0x0]
800054b6:	cf 2e       	rcall	8000529a <local_start_pll0+0x72>

800054b8 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800054b8:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800054ba:	49 18       	lddpc	r8,800054fc <INTC_init_interrupts+0x44>
800054bc:	e3 b8 00 01 	mtsr	0x4,r8
800054c0:	49 0e       	lddpc	lr,80005500 <INTC_init_interrupts+0x48>
800054c2:	30 07       	mov	r7,0
800054c4:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800054c6:	49 0c       	lddpc	r12,80005504 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800054c8:	49 05       	lddpc	r5,80005508 <INTC_init_interrupts+0x50>
800054ca:	10 15       	sub	r5,r8
800054cc:	fe 76 08 00 	mov	r6,-63488
800054d0:	c1 08       	rjmp	800054f0 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800054d2:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800054d4:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800054d6:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800054d8:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800054dc:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800054de:	10 3a       	cp.w	r10,r8
800054e0:	fe 9b ff fc 	brhi	800054d8 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800054e4:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800054e8:	2f f7       	sub	r7,-1
800054ea:	2f 8e       	sub	lr,-8
800054ec:	59 37       	cp.w	r7,19
800054ee:	c0 50       	breq	800054f8 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800054f0:	7c 08       	ld.w	r8,lr[0x0]
800054f2:	58 08       	cp.w	r8,0
800054f4:	ce f1       	brne	800054d2 <INTC_init_interrupts+0x1a>
800054f6:	cf 7b       	rjmp	800054e4 <INTC_init_interrupts+0x2c>
800054f8:	d8 22       	popm	r4-r7,pc
800054fa:	00 00       	add	r0,r0
800054fc:	80 00       	ld.sh	r0,r0[0x0]
800054fe:	ce 00       	breq	800054be <INTC_init_interrupts+0x6>
80005500:	80 00       	ld.sh	r0,r0[0x0]
80005502:	d9 70       	acall	0x97
80005504:	80 00       	ld.sh	r0,r0[0x0]
80005506:	54 34       	stdsp	sp[0x10c],r4
80005508:	80 00       	ld.sh	r0,r0[0x0]
8000550a:	cf 04       	brge	800054ea <INTC_init_interrupts+0x32>

8000550c <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
8000550c:	fe 78 08 00 	mov	r8,-63488
80005510:	e0 69 00 83 	mov	r9,131
80005514:	f2 0c 01 0c 	sub	r12,r9,r12
80005518:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
8000551c:	f2 ca ff c0 	sub	r10,r9,-64
80005520:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005524:	58 08       	cp.w	r8,0
80005526:	c0 21       	brne	8000552a <_get_interrupt_handler+0x1e>
80005528:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000552a:	f0 08 12 00 	clz	r8,r8
8000552e:	48 5a       	lddpc	r10,80005540 <_get_interrupt_handler+0x34>
80005530:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005534:	f0 08 11 1f 	rsub	r8,r8,31
80005538:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000553a:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000553e:	5e fc       	retal	r12
80005540:	80 00       	ld.sh	r0,r0[0x0]
80005542:	d9 70       	acall	0x97

80005544 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80005544:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
80005546:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000554a:	99 a8       	st.w	r12[0x28],r8
}
8000554c:	5e fc       	retal	r12
8000554e:	d7 03       	nop

80005550 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80005550:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80005552:	ec 5b bb 9f 	cp.w	r11,899999
80005556:	e0 8b 00 04 	brhi	8000555e <pm_enable_osc0_crystal+0xe>
8000555a:	30 4b       	mov	r11,4
8000555c:	c1 38       	rjmp	80005582 <pm_enable_osc0_crystal+0x32>
8000555e:	e0 68 c6 bf 	mov	r8,50879
80005562:	ea 18 00 2d 	orh	r8,0x2d
80005566:	10 3b       	cp.w	r11,r8
80005568:	e0 8b 00 04 	brhi	80005570 <pm_enable_osc0_crystal+0x20>
8000556c:	30 5b       	mov	r11,5
8000556e:	c0 a8       	rjmp	80005582 <pm_enable_osc0_crystal+0x32>
80005570:	e0 68 12 00 	mov	r8,4608
80005574:	ea 18 00 7a 	orh	r8,0x7a
80005578:	10 3b       	cp.w	r11,r8
8000557a:	f9 bb 03 06 	movlo	r11,6
8000557e:	f9 bb 02 07 	movhs	r11,7
80005582:	f0 1f 00 02 	mcall	80005588 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80005586:	d8 02       	popm	pc
80005588:	80 00       	ld.sh	r0,r0[0x0]
8000558a:	55 44       	stdsp	sp[0x150],r4

8000558c <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
8000558c:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
8000558e:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80005592:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80005594:	78 08       	ld.w	r8,r12[0x0]
80005596:	a3 a8       	sbr	r8,0x2
80005598:	99 08       	st.w	r12[0x0],r8
}
8000559a:	5e fc       	retal	r12

8000559c <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
8000559c:	79 58       	ld.w	r8,r12[0x54]
8000559e:	e2 18 00 80 	andl	r8,0x80,COH
800055a2:	cf d0       	breq	8000559c <pm_wait_for_clk0_ready>
}
800055a4:	5e fc       	retal	r12
800055a6:	d7 03       	nop

800055a8 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
800055a8:	eb cd 40 80 	pushm	r7,lr
800055ac:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
800055ae:	f0 1f 00 04 	mcall	800055bc <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
800055b2:	0e 9c       	mov	r12,r7
800055b4:	f0 1f 00 03 	mcall	800055c0 <pm_enable_clk0+0x18>
}
800055b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800055bc:	80 00       	ld.sh	r0,r0[0x0]
800055be:	55 8c       	stdsp	sp[0x160],r12
800055c0:	80 00       	ld.sh	r0,r0[0x0]
800055c2:	55 9c       	stdsp	sp[0x164],r12

800055c4 <pm_set_osc32_mode>:
 * \param mode 32-kHz oscillator mode (i.e. AVR32_PM_OSCCTRL32_MODE_x).
 */
static void pm_set_osc32_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
800055c4:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.mode = mode;
800055c6:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
800055ca:	99 c8       	st.w	r12[0x30],r8
}
800055cc:	5e fc       	retal	r12
800055ce:	d7 03       	nop

800055d0 <pm_enable_osc32_crystal>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
}


void pm_enable_osc32_crystal(volatile avr32_pm_t *pm)
{
800055d0:	d4 01       	pushm	lr
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
800055d2:	30 1b       	mov	r11,1
800055d4:	f0 1f 00 02 	mcall	800055dc <pm_enable_osc32_crystal+0xc>
}
800055d8:	d8 02       	popm	pc
800055da:	00 00       	add	r0,r0
800055dc:	80 00       	ld.sh	r0,r0[0x0]
800055de:	55 c4       	stdsp	sp[0x170],r4

800055e0 <pm_enable_clk32_no_wait>:


void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
800055e0:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.osc32en = 1;
800055e2:	30 19       	mov	r9,1
800055e4:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_pm_oscctrl32.OSCCTRL32.startup = startup;
800055e8:	f1 db d2 03 	bfins	r8,r11,0x10,0x3
  // Write back
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
800055ec:	99 c8       	st.w	r12[0x30],r8
}
800055ee:	5e fc       	retal	r12

800055f0 <pm_wait_for_clk32_ready>:


void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC32RDY_MASK));
800055f0:	79 58       	ld.w	r8,r12[0x54]
800055f2:	e2 18 02 00 	andl	r8,0x200,COH
800055f6:	cf d0       	breq	800055f0 <pm_wait_for_clk32_ready>
}
800055f8:	5e fc       	retal	r12
800055fa:	d7 03       	nop

800055fc <pm_enable_clk32>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
}


void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup)
{
800055fc:	eb cd 40 80 	pushm	r7,lr
80005600:	18 97       	mov	r7,r12
  pm_enable_clk32_no_wait(pm, startup);
80005602:	f0 1f 00 04 	mcall	80005610 <pm_enable_clk32+0x14>
  pm_wait_for_clk32_ready(pm);
80005606:	0e 9c       	mov	r12,r7
80005608:	f0 1f 00 03 	mcall	80005614 <pm_enable_clk32+0x18>
}
8000560c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005610:	80 00       	ld.sh	r0,r0[0x0]
80005612:	55 e0       	stdsp	sp[0x178],r0
80005614:	80 00       	ld.sh	r0,r0[0x0]
80005616:	55 f0       	stdsp	sp[0x17c],r0

80005618 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
80005618:	eb cd 40 d0 	pushm	r4,r6-r7,lr
8000561c:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80005620:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
80005622:	09 f7       	ld.ub	r7,r4[0x7]
80005624:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
80005628:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
8000562c:	09 b4       	ld.ub	r4,r4[0x3]
8000562e:	08 96       	mov	r6,r4
80005630:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
80005634:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
80005638:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
8000563c:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
80005640:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
80005644:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
80005648:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
8000564c:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
80005650:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
80005652:	79 58       	ld.w	r8,r12[0x54]
80005654:	e2 18 00 20 	andl	r8,0x20,COH
80005658:	cf d0       	breq	80005652 <pm_cksel+0x3a>
}
8000565a:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

8000565e <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
8000565e:	eb cd 40 80 	pushm	r7,lr
80005662:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
80005664:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
80005666:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
8000566a:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
8000566e:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
80005672:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
80005676:	2f 8b       	sub	r11,-8
80005678:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
8000567c:	e3 cd 80 80 	ldm	sp++,r7,pc

80005680 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80005680:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
80005682:	2f 8b       	sub	r11,-8
80005684:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
80005688:	f5 e9 10 19 	or	r9,r10,r9<<0x1
8000568c:	f3 e8 10 28 	or	r8,r9,r8<<0x2
80005690:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
80005694:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80005698:	d8 02       	popm	pc

8000569a <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
8000569a:	2f 8b       	sub	r11,-8
8000569c:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
800056a0:	a1 a8       	sbr	r8,0x0
800056a2:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
800056a6:	5e fc       	retal	r12

800056a8 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800056a8:	79 58       	ld.w	r8,r12[0x54]
800056aa:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800056ae:	cf d0       	breq	800056a8 <pm_wait_for_pll0_locked>
}
800056b0:	5e fc       	retal	r12

800056b2 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
800056b2:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
800056b4:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
800056b8:	99 08       	st.w	r12[0x0],r8
}
800056ba:	5e fc       	retal	r12

800056bc <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
800056bc:	eb cd 40 c0 	pushm	r6-r7,lr
800056c0:	18 97       	mov	r7,r12
800056c2:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
800056c4:	f0 1f 00 06 	mcall	800056dc <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
800056c8:	0c 9b       	mov	r11,r6
800056ca:	0e 9c       	mov	r12,r7
800056cc:	f0 1f 00 05 	mcall	800056e0 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
800056d0:	30 1b       	mov	r11,1
800056d2:	0e 9c       	mov	r12,r7
800056d4:	f0 1f 00 04 	mcall	800056e4 <pm_switch_to_osc0+0x28>
}
800056d8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800056dc:	80 00       	ld.sh	r0,r0[0x0]
800056de:	55 50       	stdsp	sp[0x154],r0
800056e0:	80 00       	ld.sh	r0,r0[0x0]
800056e2:	55 a8       	stdsp	sp[0x168],r8
800056e4:	80 00       	ld.sh	r0,r0[0x0]
800056e6:	56 b2       	stdsp	sp[0x1ac],r2

800056e8 <rtc_is_busy>:
#include "rtc.h"


int rtc_is_busy(volatile avr32_rtc_t *rtc)
{
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
800056e8:	78 0c       	ld.w	r12,r12[0x0]
}
800056ea:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
800056ee:	5e fc       	retal	r12

800056f0 <rtc_set_value>:
  return 1;
}


void rtc_set_value(volatile avr32_rtc_t *rtc, unsigned long val)
{
800056f0:	eb cd 40 c0 	pushm	r6-r7,lr
800056f4:	18 97       	mov	r7,r12
800056f6:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
800056f8:	0e 9c       	mov	r12,r7
800056fa:	f0 1f 00 06 	mcall	80005710 <rtc_set_value+0x20>
800056fe:	cf d1       	brne	800056f8 <rtc_set_value+0x8>
  // Set the new val value
  rtc->val = val;
80005700:	8f 16       	st.w	r7[0x4],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
80005702:	0e 9c       	mov	r12,r7
80005704:	f0 1f 00 03 	mcall	80005710 <rtc_set_value+0x20>
80005708:	cf d1       	brne	80005702 <rtc_set_value+0x12>
}
8000570a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000570e:	00 00       	add	r0,r0
80005710:	80 00       	ld.sh	r0,r0[0x0]
80005712:	56 e8       	stdsp	sp[0x1b8],r8

80005714 <rtc_enable>:
  while (rtc_is_busy(rtc));
}


void rtc_enable(volatile avr32_rtc_t *rtc)
{
80005714:	eb cd 40 80 	pushm	r7,lr
80005718:	18 97       	mov	r7,r12
  // Wait until the rtc CTRL register is up-to-date
  while (rtc_is_busy(rtc));
8000571a:	0e 9c       	mov	r12,r7
8000571c:	f0 1f 00 06 	mcall	80005734 <rtc_enable+0x20>
80005720:	cf d1       	brne	8000571a <rtc_enable+0x6>
  // Enable the RTC
  rtc->ctrl |= AVR32_RTC_CTRL_EN_MASK;
80005722:	6e 08       	ld.w	r8,r7[0x0]
80005724:	a1 a8       	sbr	r8,0x0
80005726:	8f 08       	st.w	r7[0x0],r8
  // Wait until write is done
  while (rtc_is_busy(rtc));
80005728:	0e 9c       	mov	r12,r7
8000572a:	f0 1f 00 03 	mcall	80005734 <rtc_enable+0x20>
8000572e:	cf d1       	brne	80005728 <rtc_enable+0x14>
}
80005730:	e3 cd 80 80 	ldm	sp++,r7,pc
80005734:	80 00       	ld.sh	r0,r0[0x0]
80005736:	56 e8       	stdsp	sp[0x1b8],r8

80005738 <rtc_enable_interrupt>:
}


void rtc_enable_interrupt(volatile avr32_rtc_t *rtc)
{
  rtc->ier = AVR32_RTC_IER_TOPI_MASK;
80005738:	30 18       	mov	r8,1
8000573a:	99 48       	st.w	r12[0x10],r8
}
8000573c:	5e fc       	retal	r12
8000573e:	d7 03       	nop

80005740 <rtc_set_top_value>:
  if (global_interrupt_enabled) cpu_irq_enable();
}


void rtc_set_top_value(volatile avr32_rtc_t *rtc, unsigned long top)
{
80005740:	eb cd 40 c0 	pushm	r6-r7,lr
80005744:	18 97       	mov	r7,r12
80005746:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
80005748:	0e 9c       	mov	r12,r7
8000574a:	f0 1f 00 06 	mcall	80005760 <rtc_set_top_value+0x20>
8000574e:	cf d1       	brne	80005748 <rtc_set_top_value+0x8>
  // Set the new val value
  rtc->top = top;
80005750:	8f 26       	st.w	r7[0x8],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
80005752:	0e 9c       	mov	r12,r7
80005754:	f0 1f 00 03 	mcall	80005760 <rtc_set_top_value+0x20>
80005758:	cf d1       	brne	80005752 <rtc_set_top_value+0x12>
}
8000575a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000575e:	00 00       	add	r0,r0
80005760:	80 00       	ld.sh	r0,r0[0x0]
80005762:	56 e8       	stdsp	sp[0x1b8],r8

80005764 <rtc_clear_interrupt>:
}


void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005764:	e1 b8 00 00 	mfsr	r8,0x0

  if (global_interrupt_enabled) cpu_irq_disable();
80005768:	e6 18 00 01 	andh	r8,0x1,COH
8000576c:	c0 71       	brne	8000577a <rtc_clear_interrupt+0x16>
8000576e:	d3 03       	ssrf	0x10
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
80005770:	30 18       	mov	r8,1
80005772:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80005774:	78 78       	ld.w	r8,r12[0x1c]
  if (global_interrupt_enabled) cpu_irq_enable();
80005776:	d5 03       	csrf	0x10
80005778:	5e fc       	retal	r12
void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  if (global_interrupt_enabled) cpu_irq_disable();
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
8000577a:	30 18       	mov	r8,1
8000577c:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
8000577e:	78 78       	ld.w	r8,r12[0x1c]
80005780:	5e fc       	retal	r12
80005782:	d7 03       	nop

80005784 <rtc_init>:
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
}


int rtc_init(volatile avr32_rtc_t *rtc, unsigned char osc_type, unsigned char psel)
{
80005784:	eb cd 40 e0 	pushm	r5-r7,lr
80005788:	18 97       	mov	r7,r12
8000578a:	16 96       	mov	r6,r11
8000578c:	14 95       	mov	r5,r10
  // If exit, it means that the configuration has not been set correctly
  if (osc_type > (1 << AVR32_RTC_CTRL_CLK32_SIZE) - 1 ||
8000578e:	30 18       	mov	r8,1
80005790:	f0 0b 18 00 	cp.b	r11,r8
80005794:	5f b9       	srhi	r9
80005796:	30 f8       	mov	r8,15
80005798:	f0 0a 18 00 	cp.b	r10,r8
8000579c:	5f b8       	srhi	r8
8000579e:	f3 e8 10 08 	or	r8,r9,r8
800057a2:	c0 30       	breq	800057a8 <rtc_init+0x24>
800057a4:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
      psel > (1 << AVR32_RTC_CTRL_PSEL_SIZE) - 1)
    return 0;

  // If we use the 32-kHz oscillator, we have to enable it first
  if (osc_type == RTC_OSC_32KHZ)
800057a8:	30 18       	mov	r8,1
800057aa:	f0 0b 18 00 	cp.b	r11,r8
800057ae:	c0 a1       	brne	800057c2 <rtc_init+0x3e>
  {
    // Select the 32-kHz oscillator crystal
    pm_enable_osc32_crystal(&AVR32_PM);
800057b0:	fe 7c 0c 00 	mov	r12,-62464
800057b4:	f0 1f 00 0f 	mcall	800057f0 <rtc_init+0x6c>
    // Enable the 32-kHz clock and wait until the osc32 clock is ready.
    pm_enable_clk32(&AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC);
800057b8:	30 0b       	mov	r11,0
800057ba:	fe 7c 0c 00 	mov	r12,-62464
800057be:	f0 1f 00 0e 	mcall	800057f4 <rtc_init+0x70>
  }

  // Wait until the rtc accepts writes to the CTRL register
  while (rtc_is_busy(rtc));
800057c2:	0e 9c       	mov	r12,r7
800057c4:	f0 1f 00 0d 	mcall	800057f8 <rtc_init+0x74>
800057c8:	cf d1       	brne	800057c2 <rtc_init+0x3e>

  // Set the new RTC configuration
  rtc->ctrl = osc_type << AVR32_RTC_CTRL_CLK32_OFFSET |
800057ca:	a3 76       	lsl	r6,0x3
800057cc:	b1 a6       	sbr	r6,0x10
800057ce:	ed e5 10 85 	or	r5,r6,r5<<0x8
800057d2:	8f 05       	st.w	r7[0x0],r5
              psel << AVR32_RTC_CTRL_PSEL_OFFSET |
              AVR32_RTC_CTRL_CLKEN_MASK;

  // Wait until write is done
  while (rtc_is_busy(rtc));
800057d4:	0e 9c       	mov	r12,r7
800057d6:	f0 1f 00 09 	mcall	800057f8 <rtc_init+0x74>
800057da:	cf d1       	brne	800057d4 <rtc_init+0x50>

  // Set the counter value to 0
  rtc_set_value(rtc, 0x00000000);
800057dc:	30 0b       	mov	r11,0
800057de:	0e 9c       	mov	r12,r7
800057e0:	f0 1f 00 07 	mcall	800057fc <rtc_init+0x78>
  // Set the top value to 0xFFFFFFFF
  rtc_set_top_value(rtc, 0xFFFFFFFF);
800057e4:	3f fb       	mov	r11,-1
800057e6:	0e 9c       	mov	r12,r7
800057e8:	f0 1f 00 06 	mcall	80005800 <rtc_init+0x7c>
800057ec:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800057f0:	80 00       	ld.sh	r0,r0[0x0]
800057f2:	55 d0       	stdsp	sp[0x174],r0
800057f4:	80 00       	ld.sh	r0,r0[0x0]
800057f6:	55 fc       	stdsp	sp[0x17c],r12
800057f8:	80 00       	ld.sh	r0,r0[0x0]
800057fa:	56 e8       	stdsp	sp[0x1b8],r8
800057fc:	80 00       	ld.sh	r0,r0[0x0]
800057fe:	56 f0       	stdsp	sp[0x1bc],r0
80005800:	80 00       	ld.sh	r0,r0[0x0]
80005802:	57 40       	stdsp	sp[0x1d0],r0

80005804 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80005804:	f8 c8 00 01 	sub	r8,r12,1
80005808:	f0 0b 00 0b 	add	r11,r8,r11
8000580c:	f6 0c 0d 0a 	divu	r10,r11,r12
80005810:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80005812:	f4 c8 00 01 	sub	r8,r10,1
80005816:	e0 48 00 fe 	cp.w	r8,254
8000581a:	e0 88 00 03 	brls	80005820 <getBaudDiv+0x1c>
8000581e:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80005820:	5c 8c       	casts.h	r12
}
80005822:	5e fc       	retal	r12

80005824 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80005824:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005828:	30 18       	mov	r8,1
8000582a:	f0 09 18 00 	cp.b	r9,r8
8000582e:	e0 88 00 04 	brls	80005836 <spi_initMaster+0x12>
80005832:	30 2c       	mov	r12,2
80005834:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
80005836:	e0 68 00 80 	mov	r8,128
8000583a:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
8000583c:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
8000583e:	30 19       	mov	r9,1
80005840:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80005844:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005848:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
8000584c:	30 09       	mov	r9,0
8000584e:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80005852:	30 fa       	mov	r10,15
80005854:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80005858:	99 18       	st.w	r12[0x4],r8
8000585a:	5e f9       	retal	r9

8000585c <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
8000585c:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
8000585e:	30 18       	mov	r8,1
80005860:	f0 0b 18 00 	cp.b	r11,r8
80005864:	5f be       	srhi	lr
80005866:	f0 0a 18 00 	cp.b	r10,r8
8000586a:	5f b8       	srhi	r8
8000586c:	fd e8 10 08 	or	r8,lr,r8
80005870:	c0 30       	breq	80005876 <spi_selectionMode+0x1a>
80005872:	30 2c       	mov	r12,2
80005874:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80005876:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80005878:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
8000587c:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80005880:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80005884:	99 18       	st.w	r12[0x4],r8
80005886:	d8 0a       	popm	pc,r12=0

80005888 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80005888:	30 18       	mov	r8,1
8000588a:	99 08       	st.w	r12[0x0],r8
}
8000588c:	5e fc       	retal	r12

8000588e <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
8000588e:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005892:	c0 58       	rjmp	8000589c <spi_write+0xe>
		if (!timeout--) {
80005894:	58 08       	cp.w	r8,0
80005896:	c0 21       	brne	8000589a <spi_write+0xc>
80005898:	5e ff       	retal	1
8000589a:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000589c:	78 49       	ld.w	r9,r12[0x10]
8000589e:	e2 19 00 02 	andl	r9,0x2,COH
800058a2:	cf 90       	breq	80005894 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
800058a4:	5c 7b       	castu.h	r11
800058a6:	99 3b       	st.w	r12[0xc],r11
800058a8:	5e fd       	retal	0

800058aa <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
800058aa:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800058ae:	c0 58       	rjmp	800058b8 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
800058b0:	58 08       	cp.w	r8,0
800058b2:	c0 21       	brne	800058b6 <spi_read+0xc>
800058b4:	5e ff       	retal	1
800058b6:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800058b8:	78 49       	ld.w	r9,r12[0x10]
800058ba:	e2 19 02 01 	andl	r9,0x201,COH
800058be:	e0 49 02 01 	cp.w	r9,513
800058c2:	cf 71       	brne	800058b0 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
800058c4:	78 28       	ld.w	r8,r12[0x8]
800058c6:	b6 08       	st.h	r11[0x0],r8
800058c8:	5e fd       	retal	0
800058ca:	d7 03       	nop

800058cc <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
800058cc:	eb cd 40 f8 	pushm	r3-r7,lr
800058d0:	18 95       	mov	r5,r12
800058d2:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800058d4:	f7 36 00 0c 	ld.ub	r6,r11[12]
800058d8:	30 38       	mov	r8,3
800058da:	f0 06 18 00 	cp.b	r6,r8
800058de:	e0 8b 00 5e 	brhi	8000599a <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
800058e2:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800058e6:	30 18       	mov	r8,1
800058e8:	f0 04 18 00 	cp.b	r4,r8
800058ec:	e0 8b 00 57 	brhi	8000599a <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
800058f0:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800058f4:	30 78       	mov	r8,7
800058f6:	f0 03 18 00 	cp.b	r3,r8
800058fa:	e0 88 00 50 	brls	8000599a <spi_setupChipReg+0xce>
800058fe:	31 08       	mov	r8,16
80005900:	f0 03 18 00 	cp.b	r3,r8
80005904:	e0 8b 00 4b 	brhi	8000599a <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80005908:	14 9b       	mov	r11,r10
8000590a:	6e 1c       	ld.w	r12,r7[0x4]
8000590c:	f0 1f 00 26 	mcall	800059a4 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
80005910:	c4 55       	brlt	8000599a <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80005912:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80005914:	ec 09 16 01 	lsr	r9,r6,0x1
80005918:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
8000591c:	ec 16 00 01 	eorl	r6,0x1
80005920:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80005924:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80005928:	20 83       	sub	r3,8
8000592a:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
8000592e:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80005932:	ef 39 00 09 	ld.ub	r9,r7[9]
80005936:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
8000593a:	ef 39 00 0a 	ld.ub	r9,r7[10]
8000593e:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80005942:	0f 89       	ld.ub	r9,r7[0x0]
80005944:	30 1a       	mov	r10,1
80005946:	f4 09 18 00 	cp.b	r9,r10
8000594a:	c0 d0       	breq	80005964 <spi_setupChipReg+0x98>
8000594c:	c0 a3       	brcs	80005960 <spi_setupChipReg+0x94>
8000594e:	30 2a       	mov	r10,2
80005950:	f4 09 18 00 	cp.b	r9,r10
80005954:	c0 a0       	breq	80005968 <spi_setupChipReg+0x9c>
80005956:	30 3a       	mov	r10,3
80005958:	f4 09 18 00 	cp.b	r9,r10
8000595c:	c1 f1       	brne	8000599a <spi_setupChipReg+0xce>
8000595e:	c0 78       	rjmp	8000596c <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80005960:	8b c8       	st.w	r5[0x30],r8
		break;
80005962:	c0 68       	rjmp	8000596e <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80005964:	8b d8       	st.w	r5[0x34],r8
		break;
80005966:	c0 48       	rjmp	8000596e <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80005968:	8b e8       	st.w	r5[0x38],r8
		break;
8000596a:	c0 28       	rjmp	8000596e <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
8000596c:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
8000596e:	48 f8       	lddpc	r8,800059a8 <spi_setupChipReg+0xdc>
80005970:	70 08       	ld.w	r8,r8[0x0]
80005972:	58 08       	cp.w	r8,0
80005974:	c1 61       	brne	800059a0 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
80005976:	30 0b       	mov	r11,0
80005978:	30 1c       	mov	r12,1
8000597a:	f0 1f 00 0d 	mcall	800059ac <spi_setupChipReg+0xe0>
8000597e:	48 b8       	lddpc	r8,800059a8 <spi_setupChipReg+0xdc>
80005980:	91 0c       	st.w	r8[0x0],r12
80005982:	58 0c       	cp.w	r12,0
80005984:	c0 a0       	breq	80005998 <spi_setupChipReg+0xcc>
80005986:	30 09       	mov	r9,0
80005988:	12 9a       	mov	r10,r9
8000598a:	12 9b       	mov	r11,r9
8000598c:	f0 1f 00 09 	mcall	800059b0 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80005990:	48 68       	lddpc	r8,800059a8 <spi_setupChipReg+0xdc>
80005992:	70 08       	ld.w	r8,r8[0x0]
80005994:	58 08       	cp.w	r8,0
80005996:	c0 51       	brne	800059a0 <spi_setupChipReg+0xd4>
80005998:	c0 08       	rjmp	80005998 <spi_setupChipReg+0xcc>
8000599a:	30 2c       	mov	r12,2
8000599c:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800059a0:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800059a4:	80 00       	ld.sh	r0,r0[0x0]
800059a6:	58 04       	cp.w	r4,0
800059a8:	00 00       	add	r0,r0
800059aa:	53 b0       	stdsp	sp[0xec],r0
800059ac:	80 00       	ld.sh	r0,r0[0x0]
800059ae:	64 f0       	ld.w	r0,r2[0x3c]
800059b0:	80 00       	ld.sh	r0,r0[0x0]
800059b2:	63 98       	ld.w	r8,r1[0x64]

800059b4 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800059b4:	d4 01       	pushm	lr
800059b6:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800059ba:	c0 58       	rjmp	800059c4 <spi_unselectChip+0x10>
		if (!timeout--) {
800059bc:	58 08       	cp.w	r8,0
800059be:	c0 21       	brne	800059c2 <spi_unselectChip+0xe>
800059c0:	da 0a       	popm	pc,r12=1
800059c2:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800059c4:	78 49       	ld.w	r9,r12[0x10]
800059c6:	e2 19 02 00 	andl	r9,0x200,COH
800059ca:	cf 90       	breq	800059bc <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800059cc:	78 18       	ld.w	r8,r12[0x4]
800059ce:	ea 18 00 0f 	orh	r8,0xf
800059d2:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
800059d4:	fc 18 01 00 	movh	r8,0x100
800059d8:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
800059da:	30 09       	mov	r9,0
800059dc:	12 9a       	mov	r10,r9
800059de:	12 9b       	mov	r11,r9
800059e0:	48 38       	lddpc	r8,800059ec <spi_unselectChip+0x38>
800059e2:	70 0c       	ld.w	r12,r8[0x0]
800059e4:	f0 1f 00 03 	mcall	800059f0 <spi_unselectChip+0x3c>
800059e8:	d8 0a       	popm	pc,r12=0
800059ea:	00 00       	add	r0,r0
800059ec:	00 00       	add	r0,r0
800059ee:	53 b0       	stdsp	sp[0xec],r0
800059f0:	80 00       	ld.sh	r0,r0[0x0]
800059f2:	63 98       	ld.w	r8,r1[0x64]

800059f4 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800059f4:	eb cd 40 f8 	pushm	r3-r7,lr
800059f8:	18 94       	mov	r4,r12
800059fa:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
800059fc:	49 a6       	lddpc	r6,80005a64 <spi_selectChip+0x70>
800059fe:	30 07       	mov	r7,0
80005a00:	31 45       	mov	r5,20
80005a02:	0e 99       	mov	r9,r7
80005a04:	0a 9a       	mov	r10,r5
80005a06:	0e 9b       	mov	r11,r7
80005a08:	6c 0c       	ld.w	r12,r6[0x0]
80005a0a:	f0 1f 00 18 	mcall	80005a68 <spi_selectChip+0x74>
80005a0e:	cf a0       	breq	80005a02 <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005a10:	68 18       	ld.w	r8,r4[0x4]
80005a12:	ea 18 00 0f 	orh	r8,0xf
80005a16:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005a18:	68 18       	ld.w	r8,r4[0x4]
80005a1a:	e2 18 00 04 	andl	r8,0x4,COH
80005a1e:	c1 10       	breq	80005a40 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80005a20:	30 e8       	mov	r8,14
80005a22:	f0 03 18 00 	cp.b	r3,r8
80005a26:	e0 8b 00 1c 	brhi	80005a5e <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80005a2a:	68 19       	ld.w	r9,r4[0x4]
80005a2c:	e6 08 15 10 	lsl	r8,r3,0x10
80005a30:	ea 18 ff f0 	orh	r8,0xfff0
80005a34:	e8 18 ff ff 	orl	r8,0xffff
80005a38:	12 68       	and	r8,r9
80005a3a:	89 18       	st.w	r4[0x4],r8
80005a3c:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80005a40:	30 38       	mov	r8,3
80005a42:	f0 03 18 00 	cp.b	r3,r8
80005a46:	e0 8b 00 0c 	brhi	80005a5e <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005a4a:	68 19       	ld.w	r9,r4[0x4]
80005a4c:	2f 03       	sub	r3,-16
80005a4e:	30 18       	mov	r8,1
80005a50:	f0 03 09 48 	lsl	r8,r8,r3
80005a54:	5c d8       	com	r8
80005a56:	12 68       	and	r8,r9
80005a58:	89 18       	st.w	r4[0x4],r8
80005a5a:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005a5e:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80005a60:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005a64:	00 00       	add	r0,r0
80005a66:	53 b0       	stdsp	sp[0xec],r0
80005a68:	80 00       	ld.sh	r0,r0[0x0]
80005a6a:	61 8c       	ld.w	r12,r0[0x60]

80005a6c <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005a6c:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005a6e:	f6 08 15 04 	lsl	r8,r11,0x4
80005a72:	14 38       	cp.w	r8,r10
80005a74:	f9 b8 08 10 	movls	r8,16
80005a78:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005a7c:	f0 0b 02 4b 	mul	r11,r8,r11
80005a80:	f6 09 16 01 	lsr	r9,r11,0x1
80005a84:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80005a88:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005a8c:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005a90:	f2 cb 00 01 	sub	r11,r9,1
80005a94:	e0 4b ff fe 	cp.w	r11,65534
80005a98:	e0 88 00 03 	brls	80005a9e <usart_set_async_baudrate+0x32>
80005a9c:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005a9e:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005aa0:	e8 6e 00 00 	mov	lr,524288
80005aa4:	59 08       	cp.w	r8,16
80005aa6:	fc 08 17 10 	movne	r8,lr
80005aaa:	f9 b8 00 00 	moveq	r8,0
80005aae:	e4 1b ff f7 	andh	r11,0xfff7
80005ab2:	e0 1b fe cf 	andl	r11,0xfecf
80005ab6:	16 48       	or	r8,r11
80005ab8:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005aba:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005abe:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005ac2:	99 89       	st.w	r12[0x20],r9
80005ac4:	d8 0a       	popm	pc,r12=0

80005ac6 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80005ac6:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005ac8:	e2 18 00 02 	andl	r8,0x2,COH
80005acc:	c0 31       	brne	80005ad2 <usart_write_char+0xc>
80005ace:	30 2c       	mov	r12,2
80005ad0:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005ad2:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80005ad6:	99 7b       	st.w	r12[0x1c],r11
80005ad8:	5e fd       	retal	0
80005ada:	d7 03       	nop

80005adc <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005adc:	eb cd 40 e0 	pushm	r5-r7,lr
80005ae0:	18 96       	mov	r6,r12
80005ae2:	16 95       	mov	r5,r11
80005ae4:	e0 67 27 0f 	mov	r7,9999
80005ae8:	c0 68       	rjmp	80005af4 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80005aea:	58 07       	cp.w	r7,0
80005aec:	c0 31       	brne	80005af2 <usart_putchar+0x16>
80005aee:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80005af2:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005af4:	0a 9b       	mov	r11,r5
80005af6:	0c 9c       	mov	r12,r6
80005af8:	f0 1f 00 03 	mcall	80005b04 <usart_putchar+0x28>
80005afc:	cf 71       	brne	80005aea <usart_putchar+0xe>

  return USART_SUCCESS;
}
80005afe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005b02:	00 00       	add	r0,r0
80005b04:	80 00       	ld.sh	r0,r0[0x0]
80005b06:	5a c6       	cp.w	r6,-20

80005b08 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80005b08:	78 58       	ld.w	r8,r12[0x14]
80005b0a:	e2 18 00 e0 	andl	r8,0xe0,COH
80005b0e:	c0 30       	breq	80005b14 <usart_read_char+0xc>
80005b10:	30 4c       	mov	r12,4
80005b12:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80005b14:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80005b16:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005b1a:	c0 31       	brne	80005b20 <usart_read_char+0x18>
80005b1c:	30 3c       	mov	r12,3
80005b1e:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80005b20:	78 68       	ld.w	r8,r12[0x18]
80005b22:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80005b26:	97 08       	st.w	r11[0x0],r8
80005b28:	5e fd       	retal	0
80005b2a:	d7 03       	nop

80005b2c <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80005b2c:	eb cd 40 c0 	pushm	r6-r7,lr
80005b30:	20 1d       	sub	sp,4
80005b32:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80005b34:	1a 97       	mov	r7,sp
80005b36:	1a 9b       	mov	r11,sp
80005b38:	0c 9c       	mov	r12,r6
80005b3a:	f0 1f 00 07 	mcall	80005b54 <usart_getchar+0x28>
80005b3e:	58 3c       	cp.w	r12,3
80005b40:	cf b0       	breq	80005b36 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80005b42:	58 4c       	cp.w	r12,4
80005b44:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80005b48:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005b4c:	2f fd       	sub	sp,-4
80005b4e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005b52:	00 00       	add	r0,r0
80005b54:	80 00       	ld.sh	r0,r0[0x0]
80005b56:	5b 08       	cp.w	r8,-16

80005b58 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80005b58:	eb cd 40 c0 	pushm	r6-r7,lr
80005b5c:	18 96       	mov	r6,r12
80005b5e:	16 97       	mov	r7,r11
  while (*string != '\0')
80005b60:	17 8b       	ld.ub	r11,r11[0x0]
80005b62:	58 0b       	cp.w	r11,0
80005b64:	c0 80       	breq	80005b74 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80005b66:	2f f7       	sub	r7,-1
80005b68:	0c 9c       	mov	r12,r6
80005b6a:	f0 1f 00 04 	mcall	80005b78 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005b6e:	0f 8b       	ld.ub	r11,r7[0x0]
80005b70:	58 0b       	cp.w	r11,0
80005b72:	cf a1       	brne	80005b66 <usart_write_line+0xe>
80005b74:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005b78:	80 00       	ld.sh	r0,r0[0x0]
80005b7a:	5a dc       	cp.w	r12,-19

80005b7c <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005b7c:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005b80:	e6 18 00 01 	andh	r8,0x1,COH
80005b84:	c0 71       	brne	80005b92 <usart_reset+0x16>
80005b86:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005b88:	3f f8       	mov	r8,-1
80005b8a:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005b8c:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005b8e:	d5 03       	csrf	0x10
80005b90:	c0 48       	rjmp	80005b98 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005b92:	3f f8       	mov	r8,-1
80005b94:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005b96:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005b98:	30 08       	mov	r8,0
80005b9a:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005b9c:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005b9e:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005ba0:	ea 68 61 0c 	mov	r8,680204
80005ba4:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80005ba6:	5e fc       	retal	r12

80005ba8 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005ba8:	eb cd 40 e0 	pushm	r5-r7,lr
80005bac:	18 96       	mov	r6,r12
80005bae:	16 97       	mov	r7,r11
80005bb0:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005bb2:	f0 1f 00 2f 	mcall	80005c6c <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80005bb6:	58 07       	cp.w	r7,0
80005bb8:	c5 80       	breq	80005c68 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005bba:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005bbc:	30 49       	mov	r9,4
80005bbe:	f2 08 18 00 	cp.b	r8,r9
80005bc2:	e0 88 00 53 	brls	80005c68 <usart_init_rs232+0xc0>
80005bc6:	30 99       	mov	r9,9
80005bc8:	f2 08 18 00 	cp.b	r8,r9
80005bcc:	e0 8b 00 4e 	brhi	80005c68 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005bd0:	0f d9       	ld.ub	r9,r7[0x5]
80005bd2:	30 78       	mov	r8,7
80005bd4:	f0 09 18 00 	cp.b	r9,r8
80005bd8:	e0 8b 00 48 	brhi	80005c68 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005bdc:	8e 39       	ld.sh	r9,r7[0x6]
80005bde:	e0 68 01 01 	mov	r8,257
80005be2:	f0 09 19 00 	cp.h	r9,r8
80005be6:	e0 8b 00 41 	brhi	80005c68 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005bea:	ef 39 00 08 	ld.ub	r9,r7[8]
80005bee:	30 38       	mov	r8,3
80005bf0:	f0 09 18 00 	cp.b	r9,r8
80005bf4:	e0 8b 00 3a 	brhi	80005c68 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005bf8:	0a 9a       	mov	r10,r5
80005bfa:	6e 0b       	ld.w	r11,r7[0x0]
80005bfc:	0c 9c       	mov	r12,r6
80005bfe:	f0 1f 00 1d 	mcall	80005c70 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005c02:	58 1c       	cp.w	r12,1
80005c04:	c3 20       	breq	80005c68 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80005c06:	0f c8       	ld.ub	r8,r7[0x4]
80005c08:	30 99       	mov	r9,9
80005c0a:	f2 08 18 00 	cp.b	r8,r9
80005c0e:	c0 51       	brne	80005c18 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005c10:	6c 18       	ld.w	r8,r6[0x4]
80005c12:	b1 b8       	sbr	r8,0x11
80005c14:	8d 18       	st.w	r6[0x4],r8
80005c16:	c0 68       	rjmp	80005c22 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005c18:	6c 19       	ld.w	r9,r6[0x4]
80005c1a:	20 58       	sub	r8,5
80005c1c:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005c20:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005c22:	6c 19       	ld.w	r9,r6[0x4]
80005c24:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005c28:	0f d8       	ld.ub	r8,r7[0x5]
80005c2a:	a9 78       	lsl	r8,0x9
80005c2c:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005c30:	12 48       	or	r8,r9
80005c32:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005c34:	8e 38       	ld.sh	r8,r7[0x6]
80005c36:	30 29       	mov	r9,2
80005c38:	f2 08 19 00 	cp.h	r8,r9
80005c3c:	e0 88 00 09 	brls	80005c4e <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005c40:	6c 18       	ld.w	r8,r6[0x4]
80005c42:	ad b8       	sbr	r8,0xd
80005c44:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005c46:	8e b8       	ld.uh	r8,r7[0x6]
80005c48:	20 28       	sub	r8,2
80005c4a:	8d a8       	st.w	r6[0x28],r8
80005c4c:	c0 68       	rjmp	80005c58 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005c4e:	6c 19       	ld.w	r9,r6[0x4]
80005c50:	5c 78       	castu.h	r8
80005c52:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005c56:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005c58:	6c 18       	ld.w	r8,r6[0x4]
80005c5a:	e0 18 ff f0 	andl	r8,0xfff0
80005c5e:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005c60:	35 08       	mov	r8,80
80005c62:	8d 08       	st.w	r6[0x0],r8
80005c64:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005c68:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005c6c:	80 00       	ld.sh	r0,r0[0x0]
80005c6e:	5b 7c       	cp.w	r12,-9
80005c70:	80 00       	ld.sh	r0,r0[0x0]
80005c72:	5a 6c       	cp.w	r12,-26

80005c74 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005c74:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005c78:	fe c0 8e 78 	sub	r0,pc,-29064

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005c7c:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005c80:	d5 53       	csrf	0x15
  cp      r0, r1
80005c82:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005c84:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005c88:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80005c8a:	c0 62       	brcc	80005c96 <idata_load_loop_end>
  cp      r0, r1
80005c8c:	48 92       	lddpc	r2,80005cb0 <udata_clear_loop_end+0x4>

80005c8e <idata_load_loop>:
  brlo    idata_load_loop
80005c8e:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005c90:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005c92:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005c94:	cf d3       	brcs	80005c8e <idata_load_loop>

80005c96 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005c96:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
80005c9a:	e0 61 53 c0 	mov	r1,21440
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005c9e:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005ca0:	c0 62       	brcc	80005cac <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005ca2:	30 02       	mov	r2,0
80005ca4:	30 03       	mov	r3,0

80005ca6 <udata_clear_loop>:
80005ca6:	a1 22       	st.d	r0++,r2
80005ca8:	02 30       	cp.w	r0,r1
80005caa:	cf e3       	brcs	80005ca6 <udata_clear_loop>

80005cac <udata_clear_loop_end>:
80005cac:	fe cf e9 28 	sub	pc,pc,-5848
80005cb0:	80 00       	ld.sh	r0,r0[0x0]
80005cb2:	e2 a0 f8 c8 	rcall	80064e42 <_data_lma+0x56ba2>

80005cb4 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005cb4:	f8 c8 ff f8 	sub	r8,r12,-8
80005cb8:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005cba:	3f f9       	mov	r9,-1
80005cbc:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005cbe:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005cc0:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005cc2:	30 08       	mov	r8,0
80005cc4:	99 08       	st.w	r12[0x0],r8
}
80005cc6:	5e fc       	retal	r12

80005cc8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005cc8:	30 08       	mov	r8,0
80005cca:	99 48       	st.w	r12[0x10],r8
}
80005ccc:	5e fc       	retal	r12

80005cce <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005cce:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005cd0:	70 19       	ld.w	r9,r8[0x4]
80005cd2:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005cd4:	78 19       	ld.w	r9,r12[0x4]
80005cd6:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005cd8:	70 19       	ld.w	r9,r8[0x4]
80005cda:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005cdc:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005cde:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005ce0:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005ce2:	78 08       	ld.w	r8,r12[0x0]
80005ce4:	2f f8       	sub	r8,-1
80005ce6:	99 08       	st.w	r12[0x0],r8
}
80005ce8:	5e fc       	retal	r12

80005cea <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005cea:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005cec:	5b fa       	cp.w	r10,-1
80005cee:	c0 31       	brne	80005cf4 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005cf0:	78 48       	ld.w	r8,r12[0x10]
80005cf2:	c0 c8       	rjmp	80005d0a <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005cf4:	f8 c8 ff f8 	sub	r8,r12,-8
80005cf8:	70 19       	ld.w	r9,r8[0x4]
80005cfa:	72 09       	ld.w	r9,r9[0x0]
80005cfc:	12 3a       	cp.w	r10,r9
80005cfe:	c0 63       	brcs	80005d0a <vListInsert+0x20>
80005d00:	70 18       	ld.w	r8,r8[0x4]
80005d02:	70 19       	ld.w	r9,r8[0x4]
80005d04:	72 09       	ld.w	r9,r9[0x0]
80005d06:	12 3a       	cp.w	r10,r9
80005d08:	cf c2       	brcc	80005d00 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005d0a:	70 19       	ld.w	r9,r8[0x4]
80005d0c:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005d0e:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005d10:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005d12:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005d14:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005d16:	78 08       	ld.w	r8,r12[0x0]
80005d18:	2f f8       	sub	r8,-1
80005d1a:	99 08       	st.w	r12[0x0],r8
}
80005d1c:	5e fc       	retal	r12

80005d1e <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005d1e:	78 18       	ld.w	r8,r12[0x4]
80005d20:	78 29       	ld.w	r9,r12[0x8]
80005d22:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005d24:	78 28       	ld.w	r8,r12[0x8]
80005d26:	78 19       	ld.w	r9,r12[0x4]
80005d28:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005d2a:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005d2c:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005d2e:	18 39       	cp.w	r9,r12
80005d30:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005d34:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005d38:	30 09       	mov	r9,0
80005d3a:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005d3c:	70 09       	ld.w	r9,r8[0x0]
80005d3e:	20 19       	sub	r9,1
80005d40:	91 09       	st.w	r8[0x0],r9
}
80005d42:	5e fc       	retal	r12

80005d44 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005d44:	e0 68 08 08 	mov	r8,2056
80005d48:	ea 18 08 08 	orh	r8,0x808
80005d4c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005d4e:	e0 68 09 09 	mov	r8,2313
80005d52:	ea 18 09 09 	orh	r8,0x909
80005d56:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005d58:	e0 68 0a 0a 	mov	r8,2570
80005d5c:	ea 18 0a 0a 	orh	r8,0xa0a
80005d60:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005d62:	e0 68 0b 0b 	mov	r8,2827
80005d66:	ea 18 0b 0b 	orh	r8,0xb0b
80005d6a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005d6c:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005d6e:	e0 68 be ef 	mov	r8,48879
80005d72:	ea 18 de ad 	orh	r8,0xdead
80005d76:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005d78:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005d7a:	fc 18 00 40 	movh	r8,0x40
80005d7e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005d80:	e0 68 00 ff 	mov	r8,255
80005d84:	ea 18 ff 00 	orh	r8,0xff00
80005d88:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005d8a:	e0 68 01 01 	mov	r8,257
80005d8e:	ea 18 01 01 	orh	r8,0x101
80005d92:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005d94:	e0 68 02 02 	mov	r8,514
80005d98:	ea 18 02 02 	orh	r8,0x202
80005d9c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005d9e:	e0 68 03 03 	mov	r8,771
80005da2:	ea 18 03 03 	orh	r8,0x303
80005da6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005da8:	e0 68 04 04 	mov	r8,1028
80005dac:	ea 18 04 04 	orh	r8,0x404
80005db0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005db2:	e0 68 05 05 	mov	r8,1285
80005db6:	ea 18 05 05 	orh	r8,0x505
80005dba:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005dbc:	e0 68 06 06 	mov	r8,1542
80005dc0:	ea 18 06 06 	orh	r8,0x606
80005dc4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005dc6:	e0 68 07 07 	mov	r8,1799
80005dca:	ea 18 07 07 	orh	r8,0x707
80005dce:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005dd0:	30 08       	mov	r8,0
80005dd2:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005dd4:	5e fc       	retal	r12
80005dd6:	d7 03       	nop

80005dd8 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005dd8:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005dda:	48 38       	lddpc	r8,80005de4 <vPortEnterCritical+0xc>
80005ddc:	70 09       	ld.w	r9,r8[0x0]
80005dde:	2f f9       	sub	r9,-1
80005de0:	91 09       	st.w	r8[0x0],r9
}
80005de2:	5e fc       	retal	r12
80005de4:	00 00       	add	r0,r0
80005de6:	05 34       	ld.ub	r4,r2++

80005de8 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005de8:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005dea:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005dec:	30 0a       	mov	r10,0
80005dee:	14 9b       	mov	r11,r10
80005df0:	49 2c       	lddpc	r12,80005e38 <xPortStartScheduler+0x50>
80005df2:	f0 1f 00 13 	mcall	80005e3c <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005df6:	e0 68 5d c0 	mov	r8,24000
80005dfa:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005dfe:	30 08       	mov	r8,0
80005e00:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005e04:	e0 68 0c e4 	mov	r8,3300
80005e08:	ea 18 00 00 	orh	r8,0x0
80005e0c:	70 00       	ld.w	r0,r8[0x0]
80005e0e:	60 0d       	ld.w	sp,r0[0x0]
80005e10:	1b 00       	ld.w	r0,sp++
80005e12:	e0 68 05 34 	mov	r8,1332
80005e16:	ea 18 00 00 	orh	r8,0x0
80005e1a:	91 00       	st.w	r8[0x0],r0
80005e1c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005e20:	2f ed       	sub	sp,-8
80005e22:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005e26:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005e2a:	e3 b0 00 00 	mtsr	0x0,r0
80005e2e:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005e32:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005e36:	d8 0a       	popm	pc,r12=0
80005e38:	80 00       	ld.sh	r0,r0[0x0]
80005e3a:	5f 04       	sreq	r4
80005e3c:	80 00       	ld.sh	r0,r0[0x0]
80005e3e:	54 38       	stdsp	sp[0x10c],r8

80005e40 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005e40:	20 6d       	sub	sp,24
80005e42:	eb cd 00 ff 	pushm	r0-r7
80005e46:	fa c7 ff c0 	sub	r7,sp,-64
80005e4a:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005e4e:	ef 40 ff e0 	st.w	r7[-32],r0
80005e52:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005e56:	ef 40 ff e4 	st.w	r7[-28],r0
80005e5a:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005e5e:	e0 68 05 34 	mov	r8,1332
80005e62:	ea 18 00 00 	orh	r8,0x0
80005e66:	70 00       	ld.w	r0,r8[0x0]
80005e68:	1a d0       	st.w	--sp,r0
80005e6a:	f0 1f 00 1a 	mcall	80005ed0 <LABEL_RET_SCALL_263+0x14>
80005e6e:	e0 68 0c e4 	mov	r8,3300
80005e72:	ea 18 00 00 	orh	r8,0x0
80005e76:	70 00       	ld.w	r0,r8[0x0]
80005e78:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005e7a:	f0 1f 00 17 	mcall	80005ed4 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005e7e:	e0 68 0c e4 	mov	r8,3300
80005e82:	ea 18 00 00 	orh	r8,0x0
80005e86:	70 00       	ld.w	r0,r8[0x0]
80005e88:	60 0d       	ld.w	sp,r0[0x0]
80005e8a:	1b 00       	ld.w	r0,sp++
80005e8c:	e0 68 05 34 	mov	r8,1332
80005e90:	ea 18 00 00 	orh	r8,0x0
80005e94:	91 00       	st.w	r8[0x0],r0
80005e96:	fa c7 ff d8 	sub	r7,sp,-40
80005e9a:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005e9e:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005ea2:	e0 61 05 34 	mov	r1,1332
80005ea6:	ea 11 00 00 	orh	r1,0x0
80005eaa:	62 02       	ld.w	r2,r1[0x0]
80005eac:	58 02       	cp.w	r2,0
80005eae:	c0 70       	breq	80005ebc <LABEL_RET_SCALL_263>
80005eb0:	e4 c2 00 01 	sub	r2,r2,1
80005eb4:	83 02       	st.w	r1[0x0],r2
80005eb6:	58 02       	cp.w	r2,0
80005eb8:	c0 21       	brne	80005ebc <LABEL_RET_SCALL_263>
80005eba:	b1 c0       	cbr	r0,0x10

80005ebc <LABEL_RET_SCALL_263>:
80005ebc:	ef 40 ff f8 	st.w	r7[-8],r0
80005ec0:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005ec4:	ef 40 ff fc 	st.w	r7[-4],r0
80005ec8:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005ecc:	2f ad       	sub	sp,-24
80005ece:	d6 13       	rets
80005ed0:	80 00       	ld.sh	r0,r0[0x0]
80005ed2:	5d d8       	*unknown*
80005ed4:	80 00       	ld.sh	r0,r0[0x0]
80005ed6:	65 74       	ld.w	r4,r2[0x5c]

80005ed8 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005ed8:	e1 b8 00 43 	mfsr	r8,0x10c
80005edc:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005ee0:	5e fc       	retal	r12
80005ee2:	d7 03       	nop

80005ee4 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005ee4:	48 78       	lddpc	r8,80005f00 <vPortExitCritical+0x1c>
80005ee6:	70 08       	ld.w	r8,r8[0x0]
80005ee8:	58 08       	cp.w	r8,0
80005eea:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005eec:	48 58       	lddpc	r8,80005f00 <vPortExitCritical+0x1c>
80005eee:	70 09       	ld.w	r9,r8[0x0]
80005ef0:	20 19       	sub	r9,1
80005ef2:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005ef4:	70 08       	ld.w	r8,r8[0x0]
80005ef6:	58 08       	cp.w	r8,0
80005ef8:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005efa:	d5 03       	csrf	0x10
80005efc:	5e fc       	retal	r12
80005efe:	00 00       	add	r0,r0
80005f00:	00 00       	add	r0,r0
80005f02:	05 34       	ld.ub	r4,r2++

80005f04 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005f04:	eb cd 00 ff 	pushm	r0-r7
80005f08:	e0 68 05 34 	mov	r8,1332
80005f0c:	ea 18 00 00 	orh	r8,0x0
80005f10:	70 00       	ld.w	r0,r8[0x0]
80005f12:	1a d0       	st.w	--sp,r0
80005f14:	7a 90       	ld.w	r0,sp[0x24]
80005f16:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005f1a:	58 10       	cp.w	r0,1
80005f1c:	e0 8b 00 08 	brhi	80005f2c <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005f20:	e0 68 0c e4 	mov	r8,3300
80005f24:	ea 18 00 00 	orh	r8,0x0
80005f28:	70 00       	ld.w	r0,r8[0x0]
80005f2a:	81 0d       	st.w	r0[0x0],sp

80005f2c <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005f2c:	f0 1f 00 12 	mcall	80005f74 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005f30:	f0 1f 00 12 	mcall	80005f78 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005f34:	f0 1f 00 12 	mcall	80005f7c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005f38:	f0 1f 00 12 	mcall	80005f80 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005f3c:	7a 90       	ld.w	r0,sp[0x24]
80005f3e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005f42:	58 10       	cp.w	r0,1
80005f44:	e0 8b 00 0e 	brhi	80005f60 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005f48:	f0 1f 00 0c 	mcall	80005f78 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005f4c:	f0 1f 00 0e 	mcall	80005f84 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005f50:	f0 1f 00 0c 	mcall	80005f80 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005f54:	e0 68 0c e4 	mov	r8,3300
80005f58:	ea 18 00 00 	orh	r8,0x0
80005f5c:	70 00       	ld.w	r0,r8[0x0]
80005f5e:	60 0d       	ld.w	sp,r0[0x0]

80005f60 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005f60:	1b 00       	ld.w	r0,sp++
80005f62:	e0 68 05 34 	mov	r8,1332
80005f66:	ea 18 00 00 	orh	r8,0x0
80005f6a:	91 00       	st.w	r8[0x0],r0
80005f6c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005f70:	d6 03       	rete
80005f72:	00 00       	add	r0,r0
80005f74:	80 00       	ld.sh	r0,r0[0x0]
80005f76:	5e d8       	retvc	r8
80005f78:	80 00       	ld.sh	r0,r0[0x0]
80005f7a:	5d d8       	*unknown*
80005f7c:	80 00       	ld.sh	r0,r0[0x0]
80005f7e:	67 78       	ld.w	r8,r3[0x5c]
80005f80:	80 00       	ld.sh	r0,r0[0x0]
80005f82:	5e e4       	retqs	r4
80005f84:	80 00       	ld.sh	r0,r0[0x0]
80005f86:	65 74       	ld.w	r4,r2[0x5c]

80005f88 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005f88:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005f8a:	f0 1f 00 02 	mcall	80005f90 <__malloc_lock+0x8>
}
80005f8e:	d8 02       	popm	pc
80005f90:	80 00       	ld.sh	r0,r0[0x0]
80005f92:	65 64       	ld.w	r4,r2[0x58]

80005f94 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005f94:	d4 01       	pushm	lr
	xTaskResumeAll();
80005f96:	f0 1f 00 02 	mcall	80005f9c <__malloc_unlock+0x8>
}
80005f9a:	d8 02       	popm	pc
80005f9c:	80 00       	ld.sh	r0,r0[0x0]
80005f9e:	69 20       	ld.w	r0,r4[0x48]

80005fa0 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005fa0:	d4 21       	pushm	r4-r7,lr
80005fa2:	16 95       	mov	r5,r11
80005fa4:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005fa6:	58 0c       	cp.w	r12,0
80005fa8:	c0 30       	breq	80005fae <_read+0xe>
80005faa:	3f f7       	mov	r7,-1
80005fac:	c1 48       	rjmp	80005fd4 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005fae:	58 0a       	cp.w	r10,0
80005fb0:	e0 89 00 04 	brgt	80005fb8 <_read+0x18>
80005fb4:	30 07       	mov	r7,0
80005fb6:	c0 f8       	rjmp	80005fd4 <_read+0x34>
80005fb8:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005fba:	48 84       	lddpc	r4,80005fd8 <_read+0x38>
80005fbc:	68 0c       	ld.w	r12,r4[0x0]
80005fbe:	f0 1f 00 08 	mcall	80005fdc <_read+0x3c>
    if (c < 0)
80005fc2:	c0 95       	brlt	80005fd4 <_read+0x34>
      break;

    *ptr++ = c;
80005fc4:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005fc8:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005fca:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005fce:	58 08       	cp.w	r8,0
80005fd0:	fe 99 ff f6 	brgt	80005fbc <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005fd4:	0e 9c       	mov	r12,r7
80005fd6:	d8 22       	popm	r4-r7,pc
80005fd8:	00 00       	add	r0,r0
80005fda:	53 b4       	stdsp	sp[0xec],r4
80005fdc:	80 00       	ld.sh	r0,r0[0x0]
80005fde:	5b 2c       	cp.w	r12,-14

80005fe0 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005fe0:	d4 21       	pushm	r4-r7,lr
80005fe2:	16 95       	mov	r5,r11
80005fe4:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005fe6:	20 1c       	sub	r12,1
80005fe8:	58 2c       	cp.w	r12,2
80005fea:	e0 8b 00 12 	brhi	8000600e <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005fee:	58 0a       	cp.w	r10,0
80005ff0:	c0 31       	brne	80005ff6 <_write+0x16>
80005ff2:	30 07       	mov	r7,0
80005ff4:	c0 e8       	rjmp	80006010 <_write+0x30>
80005ff6:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005ff8:	48 74       	lddpc	r4,80006014 <_write+0x34>
80005ffa:	68 0c       	ld.w	r12,r4[0x0]
80005ffc:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80006000:	f0 1f 00 06 	mcall	80006018 <_write+0x38>
80006004:	c0 55       	brlt	8000600e <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80006006:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006008:	0e 36       	cp.w	r6,r7
8000600a:	cf 81       	brne	80005ffa <_write+0x1a>
8000600c:	c0 28       	rjmp	80006010 <_write+0x30>
8000600e:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80006010:	0e 9c       	mov	r12,r7
80006012:	d8 22       	popm	r4-r7,pc
80006014:	00 00       	add	r0,r0
80006016:	53 b4       	stdsp	sp[0xec],r4
80006018:	80 00       	ld.sh	r0,r0[0x0]
8000601a:	5a dc       	cp.w	r12,-19

8000601c <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
8000601c:	eb cd 40 80 	pushm	r7,lr
80006020:	18 97       	mov	r7,r12
	if( pv )
80006022:	58 0c       	cp.w	r12,0
80006024:	c0 80       	breq	80006034 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80006026:	f0 1f 00 05 	mcall	80006038 <vPortFree+0x1c>
		{
			free( pv );
8000602a:	0e 9c       	mov	r12,r7
8000602c:	f0 1f 00 04 	mcall	8000603c <vPortFree+0x20>
		}
		xTaskResumeAll();
80006030:	f0 1f 00 04 	mcall	80006040 <vPortFree+0x24>
80006034:	e3 cd 80 80 	ldm	sp++,r7,pc
80006038:	80 00       	ld.sh	r0,r0[0x0]
8000603a:	65 64       	ld.w	r4,r2[0x58]
8000603c:	80 00       	ld.sh	r0,r0[0x0]
8000603e:	73 fc       	ld.w	r12,r9[0x7c]
80006040:	80 00       	ld.sh	r0,r0[0x0]
80006042:	69 20       	ld.w	r0,r4[0x48]

80006044 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80006044:	eb cd 40 80 	pushm	r7,lr
80006048:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
8000604a:	f0 1f 00 06 	mcall	80006060 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
8000604e:	0e 9c       	mov	r12,r7
80006050:	f0 1f 00 05 	mcall	80006064 <pvPortMalloc+0x20>
80006054:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80006056:	f0 1f 00 05 	mcall	80006068 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
8000605a:	0e 9c       	mov	r12,r7
8000605c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006060:	80 00       	ld.sh	r0,r0[0x0]
80006062:	65 64       	ld.w	r4,r2[0x58]
80006064:	80 00       	ld.sh	r0,r0[0x0]
80006066:	74 0c       	ld.w	r12,r10[0x0]
80006068:	80 00       	ld.sh	r0,r0[0x0]
8000606a:	69 20       	ld.w	r0,r4[0x48]

8000606c <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
8000606c:	d4 01       	pushm	lr
8000606e:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80006070:	78 09       	ld.w	r9,r12[0x0]
80006072:	58 09       	cp.w	r9,0
80006074:	c1 10       	breq	80006096 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80006076:	78 3a       	ld.w	r10,r12[0xc]
80006078:	79 09       	ld.w	r9,r12[0x40]
8000607a:	f4 09 00 09 	add	r9,r10,r9
8000607e:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80006080:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80006082:	14 39       	cp.w	r9,r10
80006084:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80006088:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
8000608c:	79 0a       	ld.w	r10,r12[0x40]
8000608e:	78 3b       	ld.w	r11,r12[0xc]
80006090:	10 9c       	mov	r12,r8
80006092:	f0 1f 00 02 	mcall	80006098 <prvCopyDataFromQueue+0x2c>
80006096:	d8 02       	popm	pc
80006098:	80 00       	ld.sh	r0,r0[0x0]
8000609a:	78 54       	ld.w	r4,r12[0x14]

8000609c <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
8000609c:	eb cd 40 c0 	pushm	r6-r7,lr
800060a0:	18 97       	mov	r7,r12
800060a2:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800060a4:	78 e8       	ld.w	r8,r12[0x38]
800060a6:	58 08       	cp.w	r8,0
800060a8:	c0 31       	brne	800060ae <xQueueReceiveFromISR+0x12>
800060aa:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
800060ae:	f0 1f 00 0e 	mcall	800060e4 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
800060b2:	6e e8       	ld.w	r8,r7[0x38]
800060b4:	20 18       	sub	r8,1
800060b6:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
800060b8:	6f 18       	ld.w	r8,r7[0x44]
800060ba:	5b f8       	cp.w	r8,-1
800060bc:	c0 d1       	brne	800060d6 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800060be:	6e 48       	ld.w	r8,r7[0x10]
800060c0:	58 08       	cp.w	r8,0
800060c2:	c0 f0       	breq	800060e0 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800060c4:	ee cc ff f0 	sub	r12,r7,-16
800060c8:	f0 1f 00 08 	mcall	800060e8 <xQueueReceiveFromISR+0x4c>
800060cc:	c0 a0       	breq	800060e0 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
800060ce:	30 1c       	mov	r12,1
800060d0:	8d 0c       	st.w	r6[0x0],r12
800060d2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
800060d6:	2f f8       	sub	r8,-1
800060d8:	ef 48 00 44 	st.w	r7[68],r8
800060dc:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800060e0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800060e4:	80 00       	ld.sh	r0,r0[0x0]
800060e6:	60 6c       	ld.w	r12,r0[0x18]
800060e8:	80 00       	ld.sh	r0,r0[0x0]
800060ea:	66 fc       	ld.w	r12,r3[0x3c]

800060ec <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
800060ec:	eb cd 40 c0 	pushm	r6-r7,lr
800060f0:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
800060f2:	f0 1f 00 23 	mcall	8000617c <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800060f6:	6f 28       	ld.w	r8,r7[0x48]
800060f8:	58 08       	cp.w	r8,0
800060fa:	e0 8a 00 18 	brle	8000612a <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800060fe:	6e 98       	ld.w	r8,r7[0x24]
80006100:	58 08       	cp.w	r8,0
80006102:	c1 40       	breq	8000612a <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006104:	ee c6 ff dc 	sub	r6,r7,-36
80006108:	c0 48       	rjmp	80006110 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000610a:	6e 98       	ld.w	r8,r7[0x24]
8000610c:	58 08       	cp.w	r8,0
8000610e:	c0 e0       	breq	8000612a <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006110:	0c 9c       	mov	r12,r6
80006112:	f0 1f 00 1c 	mcall	80006180 <prvUnlockQueue+0x94>
80006116:	c0 30       	breq	8000611c <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80006118:	f0 1f 00 1b 	mcall	80006184 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
8000611c:	6f 28       	ld.w	r8,r7[0x48]
8000611e:	20 18       	sub	r8,1
80006120:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80006124:	58 08       	cp.w	r8,0
80006126:	fe 99 ff f2 	brgt	8000610a <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
8000612a:	3f f8       	mov	r8,-1
8000612c:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80006130:	f0 1f 00 16 	mcall	80006188 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80006134:	f0 1f 00 12 	mcall	8000617c <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80006138:	6f 18       	ld.w	r8,r7[0x44]
8000613a:	58 08       	cp.w	r8,0
8000613c:	e0 8a 00 18 	brle	8000616c <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006140:	6e 48       	ld.w	r8,r7[0x10]
80006142:	58 08       	cp.w	r8,0
80006144:	c1 40       	breq	8000616c <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006146:	ee c6 ff f0 	sub	r6,r7,-16
8000614a:	c0 48       	rjmp	80006152 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000614c:	6e 48       	ld.w	r8,r7[0x10]
8000614e:	58 08       	cp.w	r8,0
80006150:	c0 e0       	breq	8000616c <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006152:	0c 9c       	mov	r12,r6
80006154:	f0 1f 00 0b 	mcall	80006180 <prvUnlockQueue+0x94>
80006158:	c0 30       	breq	8000615e <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
8000615a:	f0 1f 00 0b 	mcall	80006184 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
8000615e:	6f 18       	ld.w	r8,r7[0x44]
80006160:	20 18       	sub	r8,1
80006162:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80006166:	58 08       	cp.w	r8,0
80006168:	fe 99 ff f2 	brgt	8000614c <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
8000616c:	3f f8       	mov	r8,-1
8000616e:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80006172:	f0 1f 00 06 	mcall	80006188 <prvUnlockQueue+0x9c>
}
80006176:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000617a:	00 00       	add	r0,r0
8000617c:	80 00       	ld.sh	r0,r0[0x0]
8000617e:	5d d8       	*unknown*
80006180:	80 00       	ld.sh	r0,r0[0x0]
80006182:	66 fc       	ld.w	r12,r3[0x3c]
80006184:	80 00       	ld.sh	r0,r0[0x0]
80006186:	66 08       	ld.w	r8,r3[0x0]
80006188:	80 00       	ld.sh	r0,r0[0x0]
8000618a:	5e e4       	retqs	r4

8000618c <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
8000618c:	d4 31       	pushm	r0-r7,lr
8000618e:	20 5d       	sub	sp,20
80006190:	18 97       	mov	r7,r12
80006192:	50 0b       	stdsp	sp[0x0],r11
80006194:	50 2a       	stdsp	sp[0x8],r10
80006196:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006198:	f8 c2 ff dc 	sub	r2,r12,-36
8000619c:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000619e:	fa c4 ff f4 	sub	r4,sp,-12
800061a2:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800061a4:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800061a6:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
800061aa:	f0 1f 00 3e 	mcall	800062a0 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800061ae:	6e e8       	ld.w	r8,r7[0x38]
800061b0:	58 08       	cp.w	r8,0
800061b2:	c2 a0       	breq	80006206 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800061b4:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800061b6:	40 0b       	lddsp	r11,sp[0x0]
800061b8:	0e 9c       	mov	r12,r7
800061ba:	f0 1f 00 3b 	mcall	800062a4 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
800061be:	40 18       	lddsp	r8,sp[0x4]
800061c0:	58 08       	cp.w	r8,0
800061c2:	c1 51       	brne	800061ec <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800061c4:	6e e8       	ld.w	r8,r7[0x38]
800061c6:	20 18       	sub	r8,1
800061c8:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800061ca:	6e 08       	ld.w	r8,r7[0x0]
800061cc:	58 08       	cp.w	r8,0
800061ce:	c0 41       	brne	800061d6 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
800061d0:	f0 1f 00 36 	mcall	800062a8 <xQueueGenericReceive+0x11c>
800061d4:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800061d6:	6e 48       	ld.w	r8,r7[0x10]
800061d8:	58 08       	cp.w	r8,0
800061da:	c1 20       	breq	800061fe <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800061dc:	ee cc ff f0 	sub	r12,r7,-16
800061e0:	f0 1f 00 33 	mcall	800062ac <xQueueGenericReceive+0x120>
800061e4:	58 1c       	cp.w	r12,1
800061e6:	c0 c1       	brne	800061fe <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
800061e8:	d7 33       	scall
800061ea:	c0 a8       	rjmp	800061fe <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800061ec:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800061ee:	6e 98       	ld.w	r8,r7[0x24]
800061f0:	58 08       	cp.w	r8,0
800061f2:	c0 60       	breq	800061fe <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800061f4:	04 9c       	mov	r12,r2
800061f6:	f0 1f 00 2e 	mcall	800062ac <xQueueGenericReceive+0x120>
800061fa:	c0 20       	breq	800061fe <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
800061fc:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
800061fe:	f0 1f 00 2d 	mcall	800062b0 <xQueueGenericReceive+0x124>
80006202:	30 1c       	mov	r12,1
				return pdPASS;
80006204:	c4 c8       	rjmp	8000629c <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80006206:	40 28       	lddsp	r8,sp[0x8]
80006208:	58 08       	cp.w	r8,0
8000620a:	c0 51       	brne	80006214 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8000620c:	f0 1f 00 29 	mcall	800062b0 <xQueueGenericReceive+0x124>
80006210:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80006212:	c4 58       	rjmp	8000629c <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80006214:	58 05       	cp.w	r5,0
80006216:	c0 51       	brne	80006220 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006218:	08 9c       	mov	r12,r4
8000621a:	f0 1f 00 27 	mcall	800062b4 <xQueueGenericReceive+0x128>
8000621e:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006220:	f0 1f 00 24 	mcall	800062b0 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006224:	f0 1f 00 25 	mcall	800062b8 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80006228:	f0 1f 00 1e 	mcall	800062a0 <xQueueGenericReceive+0x114>
8000622c:	6f 18       	ld.w	r8,r7[0x44]
8000622e:	5b f8       	cp.w	r8,-1
80006230:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006234:	6f 28       	ld.w	r8,r7[0x48]
80006236:	5b f8       	cp.w	r8,-1
80006238:	ef f1 0a 12 	st.weq	r7[0x48],r1
8000623c:	f0 1f 00 1d 	mcall	800062b0 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006240:	06 9b       	mov	r11,r3
80006242:	08 9c       	mov	r12,r4
80006244:	f0 1f 00 1e 	mcall	800062bc <xQueueGenericReceive+0x130>
80006248:	c2 41       	brne	80006290 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000624a:	f0 1f 00 16 	mcall	800062a0 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
8000624e:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80006250:	f0 1f 00 18 	mcall	800062b0 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80006254:	58 06       	cp.w	r6,0
80006256:	c1 71       	brne	80006284 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006258:	6e 08       	ld.w	r8,r7[0x0]
8000625a:	58 08       	cp.w	r8,0
8000625c:	c0 81       	brne	8000626c <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
8000625e:	f0 1f 00 11 	mcall	800062a0 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80006262:	6e 1c       	ld.w	r12,r7[0x4]
80006264:	f0 1f 00 17 	mcall	800062c0 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80006268:	f0 1f 00 12 	mcall	800062b0 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
8000626c:	40 2b       	lddsp	r11,sp[0x8]
8000626e:	04 9c       	mov	r12,r2
80006270:	f0 1f 00 15 	mcall	800062c4 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80006274:	0e 9c       	mov	r12,r7
80006276:	f0 1f 00 15 	mcall	800062c8 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
8000627a:	f0 1f 00 15 	mcall	800062cc <xQueueGenericReceive+0x140>
8000627e:	c9 61       	brne	800061aa <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80006280:	d7 33       	scall
80006282:	c9 4b       	rjmp	800061aa <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006284:	0e 9c       	mov	r12,r7
80006286:	f0 1f 00 11 	mcall	800062c8 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
8000628a:	f0 1f 00 11 	mcall	800062cc <xQueueGenericReceive+0x140>
8000628e:	c8 eb       	rjmp	800061aa <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80006290:	0e 9c       	mov	r12,r7
80006292:	f0 1f 00 0e 	mcall	800062c8 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80006296:	f0 1f 00 0e 	mcall	800062cc <xQueueGenericReceive+0x140>
8000629a:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
8000629c:	2f bd       	sub	sp,-20
8000629e:	d8 32       	popm	r0-r7,pc
800062a0:	80 00       	ld.sh	r0,r0[0x0]
800062a2:	5d d8       	*unknown*
800062a4:	80 00       	ld.sh	r0,r0[0x0]
800062a6:	60 6c       	ld.w	r12,r0[0x18]
800062a8:	80 00       	ld.sh	r0,r0[0x0]
800062aa:	66 14       	ld.w	r4,r3[0x4]
800062ac:	80 00       	ld.sh	r0,r0[0x0]
800062ae:	66 fc       	ld.w	r12,r3[0x3c]
800062b0:	80 00       	ld.sh	r0,r0[0x0]
800062b2:	5e e4       	retqs	r4
800062b4:	80 00       	ld.sh	r0,r0[0x0]
800062b6:	65 f0       	ld.w	r0,r2[0x7c]
800062b8:	80 00       	ld.sh	r0,r0[0x0]
800062ba:	65 64       	ld.w	r4,r2[0x58]
800062bc:	80 00       	ld.sh	r0,r0[0x0]
800062be:	68 8c       	ld.w	r12,r4[0x20]
800062c0:	80 00       	ld.sh	r0,r0[0x0]
800062c2:	66 78       	ld.w	r8,r3[0x1c]
800062c4:	80 00       	ld.sh	r0,r0[0x0]
800062c6:	6b 2c       	ld.w	r12,r5[0x48]
800062c8:	80 00       	ld.sh	r0,r0[0x0]
800062ca:	60 ec       	ld.w	r12,r0[0x38]
800062cc:	80 00       	ld.sh	r0,r0[0x0]
800062ce:	69 20       	ld.w	r0,r4[0x48]

800062d0 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
800062d0:	eb cd 40 80 	pushm	r7,lr
800062d4:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
800062d6:	79 08       	ld.w	r8,r12[0x40]
800062d8:	58 08       	cp.w	r8,0
800062da:	c0 a1       	brne	800062ee <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800062dc:	78 08       	ld.w	r8,r12[0x0]
800062de:	58 08       	cp.w	r8,0
800062e0:	c2 b1       	brne	80006336 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
800062e2:	78 1c       	ld.w	r12,r12[0x4]
800062e4:	f0 1f 00 17 	mcall	80006340 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
800062e8:	30 08       	mov	r8,0
800062ea:	8f 18       	st.w	r7[0x4],r8
800062ec:	c2 58       	rjmp	80006336 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
800062ee:	58 0a       	cp.w	r10,0
800062f0:	c1 01       	brne	80006310 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800062f2:	10 9a       	mov	r10,r8
800062f4:	78 2c       	ld.w	r12,r12[0x8]
800062f6:	f0 1f 00 14 	mcall	80006344 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
800062fa:	6e 29       	ld.w	r9,r7[0x8]
800062fc:	6f 08       	ld.w	r8,r7[0x40]
800062fe:	f2 08 00 08 	add	r8,r9,r8
80006302:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80006304:	6e 19       	ld.w	r9,r7[0x4]
80006306:	12 38       	cp.w	r8,r9
80006308:	c1 73       	brcs	80006336 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
8000630a:	6e 08       	ld.w	r8,r7[0x0]
8000630c:	8f 28       	st.w	r7[0x8],r8
8000630e:	c1 48       	rjmp	80006336 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006310:	10 9a       	mov	r10,r8
80006312:	78 3c       	ld.w	r12,r12[0xc]
80006314:	f0 1f 00 0c 	mcall	80006344 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80006318:	6f 08       	ld.w	r8,r7[0x40]
8000631a:	6e 39       	ld.w	r9,r7[0xc]
8000631c:	f2 08 01 08 	sub	r8,r9,r8
80006320:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80006322:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80006324:	12 38       	cp.w	r8,r9
80006326:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
8000632a:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
8000632e:	f3 d8 e3 19 	subcs	r9,r9,r8
80006332:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80006336:	6e e8       	ld.w	r8,r7[0x38]
80006338:	2f f8       	sub	r8,-1
8000633a:	8f e8       	st.w	r7[0x38],r8
}
8000633c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006340:	80 00       	ld.sh	r0,r0[0x0]
80006342:	66 20       	ld.w	r0,r3[0x8]
80006344:	80 00       	ld.sh	r0,r0[0x0]
80006346:	78 54       	ld.w	r4,r12[0x14]

80006348 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80006348:	eb cd 40 c0 	pushm	r6-r7,lr
8000634c:	18 97       	mov	r7,r12
8000634e:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006350:	78 ec       	ld.w	r12,r12[0x38]
80006352:	6e f8       	ld.w	r8,r7[0x3c]
80006354:	10 3c       	cp.w	r12,r8
80006356:	c0 33       	brcs	8000635c <xQueueGenericSendFromISR+0x14>
80006358:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
8000635c:	12 9a       	mov	r10,r9
8000635e:	0e 9c       	mov	r12,r7
80006360:	f0 1f 00 0c 	mcall	80006390 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80006364:	6f 28       	ld.w	r8,r7[0x48]
80006366:	5b f8       	cp.w	r8,-1
80006368:	c0 d1       	brne	80006382 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000636a:	6e 98       	ld.w	r8,r7[0x24]
8000636c:	58 08       	cp.w	r8,0
8000636e:	c0 f0       	breq	8000638c <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006370:	ee cc ff dc 	sub	r12,r7,-36
80006374:	f0 1f 00 08 	mcall	80006394 <xQueueGenericSendFromISR+0x4c>
80006378:	c0 a0       	breq	8000638c <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
8000637a:	30 1c       	mov	r12,1
8000637c:	8d 0c       	st.w	r6[0x0],r12
8000637e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80006382:	2f f8       	sub	r8,-1
80006384:	ef 48 00 48 	st.w	r7[72],r8
80006388:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000638c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006390:	80 00       	ld.sh	r0,r0[0x0]
80006392:	62 d0       	ld.w	r0,r1[0x34]
80006394:	80 00       	ld.sh	r0,r0[0x0]
80006396:	66 fc       	ld.w	r12,r3[0x3c]

80006398 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80006398:	d4 31       	pushm	r0-r7,lr
8000639a:	20 5d       	sub	sp,20
8000639c:	18 97       	mov	r7,r12
8000639e:	50 0b       	stdsp	sp[0x0],r11
800063a0:	50 2a       	stdsp	sp[0x8],r10
800063a2:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800063a4:	f8 c0 ff f0 	sub	r0,r12,-16
800063a8:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800063aa:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800063ae:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800063b0:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
800063b4:	f0 1f 00 2f 	mcall	80006470 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800063b8:	6e e9       	ld.w	r9,r7[0x38]
800063ba:	6e f8       	ld.w	r8,r7[0x3c]
800063bc:	10 39       	cp.w	r9,r8
800063be:	c1 42       	brcc	800063e6 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800063c0:	40 1a       	lddsp	r10,sp[0x4]
800063c2:	40 0b       	lddsp	r11,sp[0x0]
800063c4:	0e 9c       	mov	r12,r7
800063c6:	f0 1f 00 2c 	mcall	80006474 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800063ca:	6e 98       	ld.w	r8,r7[0x24]
800063cc:	58 08       	cp.w	r8,0
800063ce:	c0 80       	breq	800063de <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
800063d0:	ee cc ff dc 	sub	r12,r7,-36
800063d4:	f0 1f 00 29 	mcall	80006478 <xQueueGenericSend+0xe0>
800063d8:	58 1c       	cp.w	r12,1
800063da:	c0 21       	brne	800063de <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
800063dc:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
800063de:	f0 1f 00 28 	mcall	8000647c <xQueueGenericSend+0xe4>
800063e2:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
800063e4:	c4 38       	rjmp	8000646a <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800063e6:	40 28       	lddsp	r8,sp[0x8]
800063e8:	58 08       	cp.w	r8,0
800063ea:	c0 51       	brne	800063f4 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800063ec:	f0 1f 00 24 	mcall	8000647c <xQueueGenericSend+0xe4>
800063f0:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800063f2:	c3 c8       	rjmp	8000646a <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
800063f4:	58 04       	cp.w	r4,0
800063f6:	c0 51       	brne	80006400 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800063f8:	06 9c       	mov	r12,r3
800063fa:	f0 1f 00 22 	mcall	80006480 <xQueueGenericSend+0xe8>
800063fe:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006400:	f0 1f 00 1f 	mcall	8000647c <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006404:	f0 1f 00 20 	mcall	80006484 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80006408:	f0 1f 00 1a 	mcall	80006470 <xQueueGenericSend+0xd8>
8000640c:	6f 18       	ld.w	r8,r7[0x44]
8000640e:	5b f8       	cp.w	r8,-1
80006410:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006414:	6f 28       	ld.w	r8,r7[0x48]
80006416:	5b f8       	cp.w	r8,-1
80006418:	ef f1 0a 12 	st.weq	r7[0x48],r1
8000641c:	f0 1f 00 18 	mcall	8000647c <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006420:	04 9b       	mov	r11,r2
80006422:	06 9c       	mov	r12,r3
80006424:	f0 1f 00 19 	mcall	80006488 <xQueueGenericSend+0xf0>
80006428:	c1 b1       	brne	8000645e <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000642a:	f0 1f 00 12 	mcall	80006470 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
8000642e:	6e e5       	ld.w	r5,r7[0x38]
80006430:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80006432:	f0 1f 00 13 	mcall	8000647c <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80006436:	0c 35       	cp.w	r5,r6
80006438:	c0 d1       	brne	80006452 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000643a:	40 2b       	lddsp	r11,sp[0x8]
8000643c:	00 9c       	mov	r12,r0
8000643e:	f0 1f 00 14 	mcall	8000648c <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80006442:	0e 9c       	mov	r12,r7
80006444:	f0 1f 00 13 	mcall	80006490 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80006448:	f0 1f 00 13 	mcall	80006494 <xQueueGenericSend+0xfc>
8000644c:	cb 41       	brne	800063b4 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
8000644e:	d7 33       	scall
80006450:	cb 2b       	rjmp	800063b4 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006452:	0e 9c       	mov	r12,r7
80006454:	f0 1f 00 0f 	mcall	80006490 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80006458:	f0 1f 00 0f 	mcall	80006494 <xQueueGenericSend+0xfc>
8000645c:	ca cb       	rjmp	800063b4 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
8000645e:	0e 9c       	mov	r12,r7
80006460:	f0 1f 00 0c 	mcall	80006490 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80006464:	f0 1f 00 0c 	mcall	80006494 <xQueueGenericSend+0xfc>
80006468:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
8000646a:	2f bd       	sub	sp,-20
8000646c:	d8 32       	popm	r0-r7,pc
8000646e:	00 00       	add	r0,r0
80006470:	80 00       	ld.sh	r0,r0[0x0]
80006472:	5d d8       	*unknown*
80006474:	80 00       	ld.sh	r0,r0[0x0]
80006476:	62 d0       	ld.w	r0,r1[0x34]
80006478:	80 00       	ld.sh	r0,r0[0x0]
8000647a:	66 fc       	ld.w	r12,r3[0x3c]
8000647c:	80 00       	ld.sh	r0,r0[0x0]
8000647e:	5e e4       	retqs	r4
80006480:	80 00       	ld.sh	r0,r0[0x0]
80006482:	65 f0       	ld.w	r0,r2[0x7c]
80006484:	80 00       	ld.sh	r0,r0[0x0]
80006486:	65 64       	ld.w	r4,r2[0x58]
80006488:	80 00       	ld.sh	r0,r0[0x0]
8000648a:	68 8c       	ld.w	r12,r4[0x20]
8000648c:	80 00       	ld.sh	r0,r0[0x0]
8000648e:	6b 2c       	ld.w	r12,r5[0x48]
80006490:	80 00       	ld.sh	r0,r0[0x0]
80006492:	60 ec       	ld.w	r12,r0[0x38]
80006494:	80 00       	ld.sh	r0,r0[0x0]
80006496:	69 20       	ld.w	r0,r4[0x48]

80006498 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80006498:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
8000649c:	34 cc       	mov	r12,76
8000649e:	f0 1f 00 12 	mcall	800064e4 <xQueueCreateMutex+0x4c>
800064a2:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
800064a4:	c1 d0       	breq	800064de <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
800064a6:	30 06       	mov	r6,0
800064a8:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
800064aa:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
800064ac:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
800064ae:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800064b0:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
800064b2:	30 18       	mov	r8,1
800064b4:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
800064b6:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
800064ba:	3f f8       	mov	r8,-1
800064bc:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
800064c0:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800064c4:	2f 0c       	sub	r12,-16
800064c6:	f0 1f 00 09 	mcall	800064e8 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800064ca:	ee cc ff dc 	sub	r12,r7,-36
800064ce:	f0 1f 00 07 	mcall	800064e8 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
800064d2:	0c 99       	mov	r9,r6
800064d4:	0c 9a       	mov	r10,r6
800064d6:	0c 9b       	mov	r11,r6
800064d8:	0e 9c       	mov	r12,r7
800064da:	f0 1f 00 05 	mcall	800064ec <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
800064de:	0e 9c       	mov	r12,r7
800064e0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800064e4:	80 00       	ld.sh	r0,r0[0x0]
800064e6:	60 44       	ld.w	r4,r0[0x10]
800064e8:	80 00       	ld.sh	r0,r0[0x0]
800064ea:	5c b4       	swap.b	r4
800064ec:	80 00       	ld.sh	r0,r0[0x0]
800064ee:	63 98       	ld.w	r8,r1[0x64]

800064f0 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800064f0:	d4 21       	pushm	r4-r7,lr
800064f2:	18 97       	mov	r7,r12
800064f4:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800064f6:	58 0c       	cp.w	r12,0
800064f8:	c2 f0       	breq	80006556 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800064fa:	34 cc       	mov	r12,76
800064fc:	f0 1f 00 17 	mcall	80006558 <xQueueCreate+0x68>
80006500:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80006502:	c2 a0       	breq	80006556 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80006504:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80006508:	e8 cc ff ff 	sub	r12,r4,-1
8000650c:	f0 1f 00 13 	mcall	80006558 <xQueueCreate+0x68>
80006510:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80006512:	c1 e0       	breq	8000654e <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80006514:	f8 04 00 04 	add	r4,r12,r4
80006518:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
8000651a:	30 08       	mov	r8,0
8000651c:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
8000651e:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80006520:	ee c8 00 01 	sub	r8,r7,1
80006524:	ad 38       	mul	r8,r6
80006526:	10 0c       	add	r12,r8
80006528:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
8000652a:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
8000652c:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80006530:	3f f8       	mov	r8,-1
80006532:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80006536:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000653a:	ea cc ff f0 	sub	r12,r5,-16
8000653e:	f0 1f 00 08 	mcall	8000655c <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80006542:	ea cc ff dc 	sub	r12,r5,-36
80006546:	f0 1f 00 06 	mcall	8000655c <xQueueCreate+0x6c>
8000654a:	0a 9c       	mov	r12,r5
8000654c:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
8000654e:	0a 9c       	mov	r12,r5
80006550:	f0 1f 00 04 	mcall	80006560 <xQueueCreate+0x70>
80006554:	d8 2a       	popm	r4-r7,pc,r12=0
80006556:	d8 2a       	popm	r4-r7,pc,r12=0
80006558:	80 00       	ld.sh	r0,r0[0x0]
8000655a:	60 44       	ld.w	r4,r0[0x10]
8000655c:	80 00       	ld.sh	r0,r0[0x0]
8000655e:	5c b4       	swap.b	r4
80006560:	80 00       	ld.sh	r0,r0[0x0]
80006562:	60 1c       	ld.w	r12,r0[0x4]

80006564 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80006564:	48 38       	lddpc	r8,80006570 <vTaskSuspendAll+0xc>
80006566:	70 09       	ld.w	r9,r8[0x0]
80006568:	2f f9       	sub	r9,-1
8000656a:	91 09       	st.w	r8[0x0],r9
}
8000656c:	5e fc       	retal	r12
8000656e:	00 00       	add	r0,r0
80006570:	00 00       	add	r0,r0
80006572:	0d 14       	ld.sh	r4,r6++

80006574 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80006574:	49 a8       	lddpc	r8,800065dc <vTaskSwitchContext+0x68>
80006576:	70 08       	ld.w	r8,r8[0x0]
80006578:	58 08       	cp.w	r8,0
8000657a:	c0 b1       	brne	80006590 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000657c:	49 98       	lddpc	r8,800065e0 <vTaskSwitchContext+0x6c>
8000657e:	70 08       	ld.w	r8,r8[0x0]
80006580:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006584:	49 89       	lddpc	r9,800065e4 <vTaskSwitchContext+0x70>
80006586:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
8000658a:	58 08       	cp.w	r8,0
8000658c:	c0 60       	breq	80006598 <vTaskSwitchContext+0x24>
8000658e:	c1 18       	rjmp	800065b0 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80006590:	30 19       	mov	r9,1
80006592:	49 68       	lddpc	r8,800065e8 <vTaskSwitchContext+0x74>
80006594:	91 09       	st.w	r8[0x0],r9
80006596:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006598:	49 28       	lddpc	r8,800065e0 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000659a:	49 3a       	lddpc	r10,800065e4 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
8000659c:	70 09       	ld.w	r9,r8[0x0]
8000659e:	20 19       	sub	r9,1
800065a0:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800065a2:	70 09       	ld.w	r9,r8[0x0]
800065a4:	f2 09 00 29 	add	r9,r9,r9<<0x2
800065a8:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800065ac:	58 09       	cp.w	r9,0
800065ae:	cf 70       	breq	8000659c <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800065b0:	48 c8       	lddpc	r8,800065e0 <vTaskSwitchContext+0x6c>
800065b2:	70 08       	ld.w	r8,r8[0x0]
800065b4:	f0 08 00 28 	add	r8,r8,r8<<0x2
800065b8:	48 b9       	lddpc	r9,800065e4 <vTaskSwitchContext+0x70>
800065ba:	f2 08 00 28 	add	r8,r9,r8<<0x2
800065be:	70 19       	ld.w	r9,r8[0x4]
800065c0:	72 19       	ld.w	r9,r9[0x4]
800065c2:	91 19       	st.w	r8[0x4],r9
800065c4:	f0 ca ff f8 	sub	r10,r8,-8
800065c8:	14 39       	cp.w	r9,r10
800065ca:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800065ce:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800065d2:	70 18       	ld.w	r8,r8[0x4]
800065d4:	70 39       	ld.w	r9,r8[0xc]
800065d6:	48 68       	lddpc	r8,800065ec <vTaskSwitchContext+0x78>
800065d8:	91 09       	st.w	r8[0x0],r9
800065da:	5e fc       	retal	r12
800065dc:	00 00       	add	r0,r0
800065de:	0d 14       	ld.sh	r4,r6++
800065e0:	00 00       	add	r0,r0
800065e2:	0d 4c       	ld.w	r12,--r6
800065e4:	00 00       	add	r0,r0
800065e6:	0c 30       	cp.w	r0,r6
800065e8:	00 00       	add	r0,r0
800065ea:	0d 34       	ld.ub	r4,r6++
800065ec:	00 00       	add	r0,r0
800065ee:	0c e4       	st.h	--r6,r4

800065f0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800065f0:	48 48       	lddpc	r8,80006600 <vTaskSetTimeOutState+0x10>
800065f2:	70 08       	ld.w	r8,r8[0x0]
800065f4:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
800065f6:	48 48       	lddpc	r8,80006604 <vTaskSetTimeOutState+0x14>
800065f8:	70 08       	ld.w	r8,r8[0x0]
800065fa:	99 18       	st.w	r12[0x4],r8
}
800065fc:	5e fc       	retal	r12
800065fe:	00 00       	add	r0,r0
80006600:	00 00       	add	r0,r0
80006602:	0c 28       	rsub	r8,r6
80006604:	00 00       	add	r0,r0
80006606:	0d 10       	ld.sh	r0,r6++

80006608 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80006608:	30 19       	mov	r9,1
8000660a:	48 28       	lddpc	r8,80006610 <vTaskMissedYield+0x8>
8000660c:	91 09       	st.w	r8[0x0],r9
}
8000660e:	5e fc       	retal	r12
80006610:	00 00       	add	r0,r0
80006612:	0d 34       	ld.ub	r4,r6++

80006614 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80006614:	48 28       	lddpc	r8,8000661c <xTaskGetCurrentTaskHandle+0x8>
80006616:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006618:	5e fc       	retal	r12
8000661a:	00 00       	add	r0,r0
8000661c:	00 00       	add	r0,r0
8000661e:	0c e4       	st.h	--r6,r4

80006620 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80006620:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80006624:	58 0c       	cp.w	r12,0
80006626:	c1 f0       	breq	80006664 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80006628:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
8000662a:	78 b9       	ld.w	r9,r12[0x2c]
8000662c:	79 18       	ld.w	r8,r12[0x44]
8000662e:	10 39       	cp.w	r9,r8
80006630:	c1 a0       	breq	80006664 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80006632:	f8 c6 ff fc 	sub	r6,r12,-4
80006636:	0c 9c       	mov	r12,r6
80006638:	f0 1f 00 0c 	mcall	80006668 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
8000663c:	6f 1c       	ld.w	r12,r7[0x44]
8000663e:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80006640:	f8 08 11 08 	rsub	r8,r12,8
80006644:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80006646:	48 a8       	lddpc	r8,8000666c <vTaskPriorityDisinherit+0x4c>
80006648:	70 08       	ld.w	r8,r8[0x0]
8000664a:	10 3c       	cp.w	r12,r8
8000664c:	e0 88 00 04 	brls	80006654 <vTaskPriorityDisinherit+0x34>
80006650:	48 78       	lddpc	r8,8000666c <vTaskPriorityDisinherit+0x4c>
80006652:	91 0c       	st.w	r8[0x0],r12
80006654:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006658:	0c 9b       	mov	r11,r6
8000665a:	48 68       	lddpc	r8,80006670 <vTaskPriorityDisinherit+0x50>
8000665c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006660:	f0 1f 00 05 	mcall	80006674 <vTaskPriorityDisinherit+0x54>
80006664:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006668:	80 00       	ld.sh	r0,r0[0x0]
8000666a:	5d 1e       	icall	lr
8000666c:	00 00       	add	r0,r0
8000666e:	0d 4c       	ld.w	r12,--r6
80006670:	00 00       	add	r0,r0
80006672:	0c 30       	cp.w	r0,r6
80006674:	80 00       	ld.sh	r0,r0[0x0]
80006676:	5c ce       	swap.bh	lr

80006678 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80006678:	eb cd 40 c0 	pushm	r6-r7,lr
8000667c:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
8000667e:	49 b8       	lddpc	r8,800066e8 <vTaskPriorityInherit+0x70>
80006680:	70 08       	ld.w	r8,r8[0x0]
80006682:	78 b9       	ld.w	r9,r12[0x2c]
80006684:	70 b8       	ld.w	r8,r8[0x2c]
80006686:	10 39       	cp.w	r9,r8
80006688:	c2 d2       	brcc	800066e2 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
8000668a:	49 88       	lddpc	r8,800066e8 <vTaskPriorityInherit+0x70>
8000668c:	70 08       	ld.w	r8,r8[0x0]
8000668e:	70 b8       	ld.w	r8,r8[0x2c]
80006690:	f0 08 11 08 	rsub	r8,r8,8
80006694:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80006696:	f2 09 00 28 	add	r8,r9,r9<<0x2
8000669a:	49 59       	lddpc	r9,800066ec <vTaskPriorityInherit+0x74>
8000669c:	f2 08 00 28 	add	r8,r9,r8<<0x2
800066a0:	78 59       	ld.w	r9,r12[0x14]
800066a2:	10 39       	cp.w	r9,r8
800066a4:	c1 b1       	brne	800066da <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800066a6:	f8 c6 ff fc 	sub	r6,r12,-4
800066aa:	0c 9c       	mov	r12,r6
800066ac:	f0 1f 00 11 	mcall	800066f0 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800066b0:	48 e8       	lddpc	r8,800066e8 <vTaskPriorityInherit+0x70>
800066b2:	70 08       	ld.w	r8,r8[0x0]
800066b4:	70 bc       	ld.w	r12,r8[0x2c]
800066b6:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800066b8:	48 f8       	lddpc	r8,800066f4 <vTaskPriorityInherit+0x7c>
800066ba:	70 08       	ld.w	r8,r8[0x0]
800066bc:	10 3c       	cp.w	r12,r8
800066be:	e0 88 00 04 	brls	800066c6 <vTaskPriorityInherit+0x4e>
800066c2:	48 d8       	lddpc	r8,800066f4 <vTaskPriorityInherit+0x7c>
800066c4:	91 0c       	st.w	r8[0x0],r12
800066c6:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800066ca:	0c 9b       	mov	r11,r6
800066cc:	48 88       	lddpc	r8,800066ec <vTaskPriorityInherit+0x74>
800066ce:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800066d2:	f0 1f 00 0a 	mcall	800066f8 <vTaskPriorityInherit+0x80>
800066d6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800066da:	48 48       	lddpc	r8,800066e8 <vTaskPriorityInherit+0x70>
800066dc:	70 08       	ld.w	r8,r8[0x0]
800066de:	70 b8       	ld.w	r8,r8[0x2c]
800066e0:	99 b8       	st.w	r12[0x2c],r8
800066e2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800066e6:	00 00       	add	r0,r0
800066e8:	00 00       	add	r0,r0
800066ea:	0c e4       	st.h	--r6,r4
800066ec:	00 00       	add	r0,r0
800066ee:	0c 30       	cp.w	r0,r6
800066f0:	80 00       	ld.sh	r0,r0[0x0]
800066f2:	5d 1e       	icall	lr
800066f4:	00 00       	add	r0,r0
800066f6:	0d 4c       	ld.w	r12,--r6
800066f8:	80 00       	ld.sh	r0,r0[0x0]
800066fa:	5c ce       	swap.bh	lr

800066fc <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800066fc:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80006700:	78 38       	ld.w	r8,r12[0xc]
80006702:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80006704:	ee c6 ff e8 	sub	r6,r7,-24
80006708:	0c 9c       	mov	r12,r6
8000670a:	f0 1f 00 15 	mcall	8000675c <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000670e:	49 58       	lddpc	r8,80006760 <xTaskRemoveFromEventList+0x64>
80006710:	70 08       	ld.w	r8,r8[0x0]
80006712:	58 08       	cp.w	r8,0
80006714:	c1 71       	brne	80006742 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80006716:	ee c6 ff fc 	sub	r6,r7,-4
8000671a:	0c 9c       	mov	r12,r6
8000671c:	f0 1f 00 10 	mcall	8000675c <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80006720:	6e bc       	ld.w	r12,r7[0x2c]
80006722:	49 18       	lddpc	r8,80006764 <xTaskRemoveFromEventList+0x68>
80006724:	70 08       	ld.w	r8,r8[0x0]
80006726:	10 3c       	cp.w	r12,r8
80006728:	e0 88 00 04 	brls	80006730 <xTaskRemoveFromEventList+0x34>
8000672c:	48 e8       	lddpc	r8,80006764 <xTaskRemoveFromEventList+0x68>
8000672e:	91 0c       	st.w	r8[0x0],r12
80006730:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006734:	0c 9b       	mov	r11,r6
80006736:	48 d8       	lddpc	r8,80006768 <xTaskRemoveFromEventList+0x6c>
80006738:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000673c:	f0 1f 00 0c 	mcall	8000676c <xTaskRemoveFromEventList+0x70>
80006740:	c0 58       	rjmp	8000674a <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80006742:	0c 9b       	mov	r11,r6
80006744:	48 bc       	lddpc	r12,80006770 <xTaskRemoveFromEventList+0x74>
80006746:	f0 1f 00 0a 	mcall	8000676c <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000674a:	48 b8       	lddpc	r8,80006774 <xTaskRemoveFromEventList+0x78>
8000674c:	70 08       	ld.w	r8,r8[0x0]
8000674e:	6e b9       	ld.w	r9,r7[0x2c]
80006750:	70 b8       	ld.w	r8,r8[0x2c]
80006752:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80006754:	5f 2c       	srhs	r12
80006756:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000675a:	00 00       	add	r0,r0
8000675c:	80 00       	ld.sh	r0,r0[0x0]
8000675e:	5d 1e       	icall	lr
80006760:	00 00       	add	r0,r0
80006762:	0d 14       	ld.sh	r4,r6++
80006764:	00 00       	add	r0,r0
80006766:	0d 4c       	ld.w	r12,--r6
80006768:	00 00       	add	r0,r0
8000676a:	0c 30       	cp.w	r0,r6
8000676c:	80 00       	ld.sh	r0,r0[0x0]
8000676e:	5c ce       	swap.bh	lr
80006770:	00 00       	add	r0,r0
80006772:	0c e8       	st.h	--r6,r8
80006774:	00 00       	add	r0,r0
80006776:	0c e4       	st.h	--r6,r4

80006778 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80006778:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000677c:	4b 98       	lddpc	r8,80006860 <vTaskIncrementTick+0xe8>
8000677e:	70 08       	ld.w	r8,r8[0x0]
80006780:	58 08       	cp.w	r8,0
80006782:	c6 91       	brne	80006854 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80006784:	4b 88       	lddpc	r8,80006864 <vTaskIncrementTick+0xec>
80006786:	70 09       	ld.w	r9,r8[0x0]
80006788:	2f f9       	sub	r9,-1
8000678a:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
8000678c:	70 08       	ld.w	r8,r8[0x0]
8000678e:	58 08       	cp.w	r8,0
80006790:	c1 a1       	brne	800067c4 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80006792:	4b 68       	lddpc	r8,80006868 <vTaskIncrementTick+0xf0>
80006794:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80006796:	4b 69       	lddpc	r9,8000686c <vTaskIncrementTick+0xf4>
80006798:	72 0b       	ld.w	r11,r9[0x0]
8000679a:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
8000679c:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
8000679e:	4b 59       	lddpc	r9,80006870 <vTaskIncrementTick+0xf8>
800067a0:	72 0a       	ld.w	r10,r9[0x0]
800067a2:	2f fa       	sub	r10,-1
800067a4:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800067a6:	70 08       	ld.w	r8,r8[0x0]
800067a8:	70 08       	ld.w	r8,r8[0x0]
800067aa:	58 08       	cp.w	r8,0
800067ac:	c0 51       	brne	800067b6 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800067ae:	3f f9       	mov	r9,-1
800067b0:	4b 18       	lddpc	r8,80006874 <vTaskIncrementTick+0xfc>
800067b2:	91 09       	st.w	r8[0x0],r9
800067b4:	c0 88       	rjmp	800067c4 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800067b6:	4a d8       	lddpc	r8,80006868 <vTaskIncrementTick+0xf0>
800067b8:	70 08       	ld.w	r8,r8[0x0]
800067ba:	70 38       	ld.w	r8,r8[0xc]
800067bc:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800067be:	70 19       	ld.w	r9,r8[0x4]
800067c0:	4a d8       	lddpc	r8,80006874 <vTaskIncrementTick+0xfc>
800067c2:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800067c4:	4a 88       	lddpc	r8,80006864 <vTaskIncrementTick+0xec>
800067c6:	70 09       	ld.w	r9,r8[0x0]
800067c8:	4a b8       	lddpc	r8,80006874 <vTaskIncrementTick+0xfc>
800067ca:	70 08       	ld.w	r8,r8[0x0]
800067cc:	10 39       	cp.w	r9,r8
800067ce:	c4 73       	brcs	8000685c <vTaskIncrementTick+0xe4>
800067d0:	4a 68       	lddpc	r8,80006868 <vTaskIncrementTick+0xf0>
800067d2:	70 08       	ld.w	r8,r8[0x0]
800067d4:	70 08       	ld.w	r8,r8[0x0]
800067d6:	58 08       	cp.w	r8,0
800067d8:	c0 c0       	breq	800067f0 <vTaskIncrementTick+0x78>
800067da:	4a 48       	lddpc	r8,80006868 <vTaskIncrementTick+0xf0>
800067dc:	70 08       	ld.w	r8,r8[0x0]
800067de:	70 38       	ld.w	r8,r8[0xc]
800067e0:	70 37       	ld.w	r7,r8[0xc]
800067e2:	6e 18       	ld.w	r8,r7[0x4]
800067e4:	4a 09       	lddpc	r9,80006864 <vTaskIncrementTick+0xec>
800067e6:	72 09       	ld.w	r9,r9[0x0]
800067e8:	12 38       	cp.w	r8,r9
800067ea:	e0 88 00 14 	brls	80006812 <vTaskIncrementTick+0x9a>
800067ee:	c0 e8       	rjmp	8000680a <vTaskIncrementTick+0x92>
800067f0:	3f f9       	mov	r9,-1
800067f2:	4a 18       	lddpc	r8,80006874 <vTaskIncrementTick+0xfc>
800067f4:	91 09       	st.w	r8[0x0],r9
800067f6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800067fa:	6a 08       	ld.w	r8,r5[0x0]
800067fc:	70 38       	ld.w	r8,r8[0xc]
800067fe:	70 37       	ld.w	r7,r8[0xc]
80006800:	6e 18       	ld.w	r8,r7[0x4]
80006802:	64 09       	ld.w	r9,r2[0x0]
80006804:	12 38       	cp.w	r8,r9
80006806:	e0 88 00 0a 	brls	8000681a <vTaskIncrementTick+0xa2>
8000680a:	49 b9       	lddpc	r9,80006874 <vTaskIncrementTick+0xfc>
8000680c:	93 08       	st.w	r9[0x0],r8
8000680e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006812:	49 a4       	lddpc	r4,80006878 <vTaskIncrementTick+0x100>
80006814:	49 a3       	lddpc	r3,8000687c <vTaskIncrementTick+0x104>
80006816:	49 55       	lddpc	r5,80006868 <vTaskIncrementTick+0xf0>
80006818:	49 32       	lddpc	r2,80006864 <vTaskIncrementTick+0xec>
8000681a:	ee c6 ff fc 	sub	r6,r7,-4
8000681e:	0c 9c       	mov	r12,r6
80006820:	f0 1f 00 18 	mcall	80006880 <vTaskIncrementTick+0x108>
80006824:	6e a8       	ld.w	r8,r7[0x28]
80006826:	58 08       	cp.w	r8,0
80006828:	c0 50       	breq	80006832 <vTaskIncrementTick+0xba>
8000682a:	ee cc ff e8 	sub	r12,r7,-24
8000682e:	f0 1f 00 15 	mcall	80006880 <vTaskIncrementTick+0x108>
80006832:	6e bc       	ld.w	r12,r7[0x2c]
80006834:	68 08       	ld.w	r8,r4[0x0]
80006836:	10 3c       	cp.w	r12,r8
80006838:	e9 fc ba 00 	st.whi	r4[0x0],r12
8000683c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006840:	0c 9b       	mov	r11,r6
80006842:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80006846:	f0 1f 00 10 	mcall	80006884 <vTaskIncrementTick+0x10c>
8000684a:	6a 08       	ld.w	r8,r5[0x0]
8000684c:	70 08       	ld.w	r8,r8[0x0]
8000684e:	58 08       	cp.w	r8,0
80006850:	cd 51       	brne	800067fa <vTaskIncrementTick+0x82>
80006852:	cc fb       	rjmp	800067f0 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80006854:	48 d8       	lddpc	r8,80006888 <vTaskIncrementTick+0x110>
80006856:	70 09       	ld.w	r9,r8[0x0]
80006858:	2f f9       	sub	r9,-1
8000685a:	91 09       	st.w	r8[0x0],r9
8000685c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006860:	00 00       	add	r0,r0
80006862:	0d 14       	ld.sh	r4,r6++
80006864:	00 00       	add	r0,r0
80006866:	0d 10       	ld.sh	r0,r6++
80006868:	00 00       	add	r0,r0
8000686a:	0c 1c       	sub	r12,r6
8000686c:	00 00       	add	r0,r0
8000686e:	0c 2c       	rsub	r12,r6
80006870:	00 00       	add	r0,r0
80006872:	0c 28       	rsub	r8,r6
80006874:	00 00       	add	r0,r0
80006876:	05 38       	ld.ub	r8,r2++
80006878:	00 00       	add	r0,r0
8000687a:	0d 4c       	ld.w	r12,--r6
8000687c:	00 00       	add	r0,r0
8000687e:	0c 30       	cp.w	r0,r6
80006880:	80 00       	ld.sh	r0,r0[0x0]
80006882:	5d 1e       	icall	lr
80006884:	80 00       	ld.sh	r0,r0[0x0]
80006886:	5c ce       	swap.bh	lr
80006888:	00 00       	add	r0,r0
8000688a:	0c 14       	sub	r4,r6

8000688c <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
8000688c:	eb cd 40 c0 	pushm	r6-r7,lr
80006890:	18 97       	mov	r7,r12
80006892:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80006894:	f0 1f 00 15 	mcall	800068e8 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80006898:	6c 08       	ld.w	r8,r6[0x0]
8000689a:	5b f8       	cp.w	r8,-1
8000689c:	c0 31       	brne	800068a2 <xTaskCheckForTimeOut+0x16>
8000689e:	30 07       	mov	r7,0
800068a0:	c1 f8       	rjmp	800068de <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800068a2:	49 39       	lddpc	r9,800068ec <xTaskCheckForTimeOut+0x60>
800068a4:	72 09       	ld.w	r9,r9[0x0]
800068a6:	6e 0a       	ld.w	r10,r7[0x0]
800068a8:	12 3a       	cp.w	r10,r9
800068aa:	c0 70       	breq	800068b8 <xTaskCheckForTimeOut+0x2c>
800068ac:	49 19       	lddpc	r9,800068f0 <xTaskCheckForTimeOut+0x64>
800068ae:	72 09       	ld.w	r9,r9[0x0]
800068b0:	6e 1a       	ld.w	r10,r7[0x4]
800068b2:	12 3a       	cp.w	r10,r9
800068b4:	e0 88 00 14 	brls	800068dc <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800068b8:	48 e9       	lddpc	r9,800068f0 <xTaskCheckForTimeOut+0x64>
800068ba:	72 0a       	ld.w	r10,r9[0x0]
800068bc:	6e 19       	ld.w	r9,r7[0x4]
800068be:	12 1a       	sub	r10,r9
800068c0:	14 38       	cp.w	r8,r10
800068c2:	e0 88 00 0d 	brls	800068dc <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800068c6:	48 ba       	lddpc	r10,800068f0 <xTaskCheckForTimeOut+0x64>
800068c8:	74 0a       	ld.w	r10,r10[0x0]
800068ca:	14 19       	sub	r9,r10
800068cc:	f2 08 00 08 	add	r8,r9,r8
800068d0:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
800068d2:	0e 9c       	mov	r12,r7
800068d4:	f0 1f 00 08 	mcall	800068f4 <xTaskCheckForTimeOut+0x68>
800068d8:	30 07       	mov	r7,0
800068da:	c0 28       	rjmp	800068de <xTaskCheckForTimeOut+0x52>
800068dc:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
800068de:	f0 1f 00 07 	mcall	800068f8 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
800068e2:	0e 9c       	mov	r12,r7
800068e4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800068e8:	80 00       	ld.sh	r0,r0[0x0]
800068ea:	5d d8       	*unknown*
800068ec:	00 00       	add	r0,r0
800068ee:	0c 28       	rsub	r8,r6
800068f0:	00 00       	add	r0,r0
800068f2:	0d 10       	ld.sh	r0,r6++
800068f4:	80 00       	ld.sh	r0,r0[0x0]
800068f6:	65 f0       	ld.w	r0,r2[0x7c]
800068f8:	80 00       	ld.sh	r0,r0[0x0]
800068fa:	5e e4       	retqs	r4

800068fc <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
800068fc:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80006900:	f0 1f 00 05 	mcall	80006914 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80006904:	48 58       	lddpc	r8,80006918 <xTaskGetTickCount+0x1c>
80006906:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80006908:	f0 1f 00 05 	mcall	8000691c <xTaskGetTickCount+0x20>

	return xTicks;
}
8000690c:	0e 9c       	mov	r12,r7
8000690e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006912:	00 00       	add	r0,r0
80006914:	80 00       	ld.sh	r0,r0[0x0]
80006916:	5d d8       	*unknown*
80006918:	00 00       	add	r0,r0
8000691a:	0d 10       	ld.sh	r0,r6++
8000691c:	80 00       	ld.sh	r0,r0[0x0]
8000691e:	5e e4       	retqs	r4

80006920 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80006920:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80006924:	f0 1f 00 2c 	mcall	800069d4 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006928:	4a c8       	lddpc	r8,800069d8 <xTaskResumeAll+0xb8>
8000692a:	70 09       	ld.w	r9,r8[0x0]
8000692c:	20 19       	sub	r9,1
8000692e:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006930:	70 08       	ld.w	r8,r8[0x0]
80006932:	58 08       	cp.w	r8,0
80006934:	c4 91       	brne	800069c6 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80006936:	4a a8       	lddpc	r8,800069dc <xTaskResumeAll+0xbc>
80006938:	70 08       	ld.w	r8,r8[0x0]
8000693a:	58 08       	cp.w	r8,0
8000693c:	c4 50       	breq	800069c6 <xTaskResumeAll+0xa6>
8000693e:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006940:	4a 85       	lddpc	r5,800069e0 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80006942:	4a 93       	lddpc	r3,800069e4 <xTaskResumeAll+0xc4>
80006944:	4a 92       	lddpc	r2,800069e8 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006946:	4a a1       	lddpc	r1,800069ec <xTaskResumeAll+0xcc>
80006948:	c1 e8       	rjmp	80006984 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
8000694a:	6a 38       	ld.w	r8,r5[0xc]
8000694c:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000694e:	ee cc ff e8 	sub	r12,r7,-24
80006952:	f0 1f 00 28 	mcall	800069f0 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80006956:	ee c6 ff fc 	sub	r6,r7,-4
8000695a:	0c 9c       	mov	r12,r6
8000695c:	f0 1f 00 25 	mcall	800069f0 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80006960:	6e bc       	ld.w	r12,r7[0x2c]
80006962:	66 08       	ld.w	r8,r3[0x0]
80006964:	10 3c       	cp.w	r12,r8
80006966:	e7 fc ba 00 	st.whi	r3[0x0],r12
8000696a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000696e:	0c 9b       	mov	r11,r6
80006970:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80006974:	f0 1f 00 20 	mcall	800069f4 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006978:	62 08       	ld.w	r8,r1[0x0]
8000697a:	6e b9       	ld.w	r9,r7[0x2c]
8000697c:	70 b8       	ld.w	r8,r8[0x2c]
8000697e:	10 39       	cp.w	r9,r8
80006980:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006984:	6a 08       	ld.w	r8,r5[0x0]
80006986:	58 08       	cp.w	r8,0
80006988:	ce 11       	brne	8000694a <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000698a:	49 c8       	lddpc	r8,800069f8 <xTaskResumeAll+0xd8>
8000698c:	70 08       	ld.w	r8,r8[0x0]
8000698e:	58 08       	cp.w	r8,0
80006990:	c0 f0       	breq	800069ae <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006992:	49 a8       	lddpc	r8,800069f8 <xTaskResumeAll+0xd8>
80006994:	70 08       	ld.w	r8,r8[0x0]
80006996:	58 08       	cp.w	r8,0
80006998:	c1 10       	breq	800069ba <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
8000699a:	49 87       	lddpc	r7,800069f8 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
8000699c:	f0 1f 00 18 	mcall	800069fc <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800069a0:	6e 08       	ld.w	r8,r7[0x0]
800069a2:	20 18       	sub	r8,1
800069a4:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800069a6:	6e 08       	ld.w	r8,r7[0x0]
800069a8:	58 08       	cp.w	r8,0
800069aa:	cf 91       	brne	8000699c <xTaskResumeAll+0x7c>
800069ac:	c0 78       	rjmp	800069ba <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800069ae:	58 14       	cp.w	r4,1
800069b0:	c0 50       	breq	800069ba <xTaskResumeAll+0x9a>
800069b2:	49 48       	lddpc	r8,80006a00 <xTaskResumeAll+0xe0>
800069b4:	70 08       	ld.w	r8,r8[0x0]
800069b6:	58 18       	cp.w	r8,1
800069b8:	c0 71       	brne	800069c6 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800069ba:	30 09       	mov	r9,0
800069bc:	49 18       	lddpc	r8,80006a00 <xTaskResumeAll+0xe0>
800069be:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800069c0:	d7 33       	scall
800069c2:	30 17       	mov	r7,1
800069c4:	c0 28       	rjmp	800069c8 <xTaskResumeAll+0xa8>
800069c6:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800069c8:	f0 1f 00 0f 	mcall	80006a04 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
800069cc:	0e 9c       	mov	r12,r7
800069ce:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800069d2:	00 00       	add	r0,r0
800069d4:	80 00       	ld.sh	r0,r0[0x0]
800069d6:	5d d8       	*unknown*
800069d8:	00 00       	add	r0,r0
800069da:	0d 14       	ld.sh	r4,r6++
800069dc:	00 00       	add	r0,r0
800069de:	0d 30       	ld.ub	r0,r6++
800069e0:	00 00       	add	r0,r0
800069e2:	0c e8       	st.h	--r6,r8
800069e4:	00 00       	add	r0,r0
800069e6:	0d 4c       	ld.w	r12,--r6
800069e8:	00 00       	add	r0,r0
800069ea:	0c 30       	cp.w	r0,r6
800069ec:	00 00       	add	r0,r0
800069ee:	0c e4       	st.h	--r6,r4
800069f0:	80 00       	ld.sh	r0,r0[0x0]
800069f2:	5d 1e       	icall	lr
800069f4:	80 00       	ld.sh	r0,r0[0x0]
800069f6:	5c ce       	swap.bh	lr
800069f8:	00 00       	add	r0,r0
800069fa:	0c 14       	sub	r4,r6
800069fc:	80 00       	ld.sh	r0,r0[0x0]
800069fe:	67 78       	ld.w	r8,r3[0x5c]
80006a00:	00 00       	add	r0,r0
80006a02:	0d 34       	ld.ub	r4,r6++
80006a04:	80 00       	ld.sh	r0,r0[0x0]
80006a06:	5e e4       	retqs	r4

80006a08 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006a08:	eb cd 40 80 	pushm	r7,lr
80006a0c:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80006a0e:	49 08       	lddpc	r8,80006a4c <prvAddCurrentTaskToDelayedList+0x44>
80006a10:	70 08       	ld.w	r8,r8[0x0]
80006a12:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006a14:	48 f8       	lddpc	r8,80006a50 <prvAddCurrentTaskToDelayedList+0x48>
80006a16:	70 08       	ld.w	r8,r8[0x0]
80006a18:	10 3c       	cp.w	r12,r8
80006a1a:	c0 a2       	brcc	80006a2e <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a1c:	48 c8       	lddpc	r8,80006a4c <prvAddCurrentTaskToDelayedList+0x44>
80006a1e:	70 0b       	ld.w	r11,r8[0x0]
80006a20:	48 d8       	lddpc	r8,80006a54 <prvAddCurrentTaskToDelayedList+0x4c>
80006a22:	70 0c       	ld.w	r12,r8[0x0]
80006a24:	2f cb       	sub	r11,-4
80006a26:	f0 1f 00 0d 	mcall	80006a58 <prvAddCurrentTaskToDelayedList+0x50>
80006a2a:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a2e:	48 88       	lddpc	r8,80006a4c <prvAddCurrentTaskToDelayedList+0x44>
80006a30:	70 0b       	ld.w	r11,r8[0x0]
80006a32:	48 b8       	lddpc	r8,80006a5c <prvAddCurrentTaskToDelayedList+0x54>
80006a34:	70 0c       	ld.w	r12,r8[0x0]
80006a36:	2f cb       	sub	r11,-4
80006a38:	f0 1f 00 08 	mcall	80006a58 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006a3c:	48 98       	lddpc	r8,80006a60 <prvAddCurrentTaskToDelayedList+0x58>
80006a3e:	70 08       	ld.w	r8,r8[0x0]
80006a40:	10 37       	cp.w	r7,r8
80006a42:	c0 32       	brcc	80006a48 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006a44:	48 78       	lddpc	r8,80006a60 <prvAddCurrentTaskToDelayedList+0x58>
80006a46:	91 07       	st.w	r8[0x0],r7
80006a48:	e3 cd 80 80 	ldm	sp++,r7,pc
80006a4c:	00 00       	add	r0,r0
80006a4e:	0c e4       	st.h	--r6,r4
80006a50:	00 00       	add	r0,r0
80006a52:	0d 10       	ld.sh	r0,r6++
80006a54:	00 00       	add	r0,r0
80006a56:	0c 2c       	rsub	r12,r6
80006a58:	80 00       	ld.sh	r0,r0[0x0]
80006a5a:	5c ea       	tnbz	r10
80006a5c:	00 00       	add	r0,r0
80006a5e:	0c 1c       	sub	r12,r6
80006a60:	00 00       	add	r0,r0
80006a62:	05 38       	ld.ub	r8,r2++

80006a64 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80006a64:	eb cd 40 c0 	pushm	r6-r7,lr
80006a68:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80006a6a:	58 0c       	cp.w	r12,0
80006a6c:	c1 10       	breq	80006a8e <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80006a6e:	f0 1f 00 0a 	mcall	80006a94 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80006a72:	48 a8       	lddpc	r8,80006a98 <vTaskDelay+0x34>
80006a74:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a76:	48 a8       	lddpc	r8,80006a9c <vTaskDelay+0x38>
80006a78:	70 0c       	ld.w	r12,r8[0x0]
80006a7a:	2f cc       	sub	r12,-4
80006a7c:	f0 1f 00 09 	mcall	80006aa0 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006a80:	ee 06 00 0c 	add	r12,r7,r6
80006a84:	f0 1f 00 08 	mcall	80006aa4 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80006a88:	f0 1f 00 08 	mcall	80006aa8 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006a8c:	c0 21       	brne	80006a90 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80006a8e:	d7 33       	scall
80006a90:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006a94:	80 00       	ld.sh	r0,r0[0x0]
80006a96:	65 64       	ld.w	r4,r2[0x58]
80006a98:	00 00       	add	r0,r0
80006a9a:	0d 10       	ld.sh	r0,r6++
80006a9c:	00 00       	add	r0,r0
80006a9e:	0c e4       	st.h	--r6,r4
80006aa0:	80 00       	ld.sh	r0,r0[0x0]
80006aa2:	5d 1e       	icall	lr
80006aa4:	80 00       	ld.sh	r0,r0[0x0]
80006aa6:	6a 08       	ld.w	r8,r5[0x0]
80006aa8:	80 00       	ld.sh	r0,r0[0x0]
80006aaa:	69 20       	ld.w	r0,r4[0x48]

80006aac <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80006aac:	eb cd 40 c0 	pushm	r6-r7,lr
80006ab0:	18 96       	mov	r6,r12
80006ab2:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80006ab4:	f0 1f 00 18 	mcall	80006b14 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80006ab8:	6c 08       	ld.w	r8,r6[0x0]
80006aba:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006abc:	49 79       	lddpc	r9,80006b18 <vTaskDelayUntil+0x6c>
80006abe:	72 09       	ld.w	r9,r9[0x0]
80006ac0:	12 38       	cp.w	r8,r9
80006ac2:	e0 88 00 0c 	brls	80006ada <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80006ac6:	0e 38       	cp.w	r8,r7
80006ac8:	e0 88 00 22 	brls	80006b0c <vTaskDelayUntil+0x60>
80006acc:	49 38       	lddpc	r8,80006b18 <vTaskDelayUntil+0x6c>
80006ace:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006ad0:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80006ad2:	10 37       	cp.w	r7,r8
80006ad4:	e0 88 00 14 	brls	80006afc <vTaskDelayUntil+0x50>
80006ad8:	c0 a8       	rjmp	80006aec <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80006ada:	0e 38       	cp.w	r8,r7
80006adc:	e0 8b 00 16 	brhi	80006b08 <vTaskDelayUntil+0x5c>
80006ae0:	48 e8       	lddpc	r8,80006b18 <vTaskDelayUntil+0x6c>
80006ae2:	70 08       	ld.w	r8,r8[0x0]
80006ae4:	10 37       	cp.w	r7,r8
80006ae6:	e0 8b 00 11 	brhi	80006b08 <vTaskDelayUntil+0x5c>
80006aea:	c1 18       	rjmp	80006b0c <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006aec:	48 c8       	lddpc	r8,80006b1c <vTaskDelayUntil+0x70>
80006aee:	70 0c       	ld.w	r12,r8[0x0]
80006af0:	2f cc       	sub	r12,-4
80006af2:	f0 1f 00 0c 	mcall	80006b20 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006af6:	0e 9c       	mov	r12,r7
80006af8:	f0 1f 00 0b 	mcall	80006b24 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006afc:	f0 1f 00 0b 	mcall	80006b28 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006b00:	c0 81       	brne	80006b10 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80006b02:	d7 33       	scall
80006b04:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006b08:	8d 07       	st.w	r6[0x0],r7
80006b0a:	cf 1b       	rjmp	80006aec <vTaskDelayUntil+0x40>
80006b0c:	8d 07       	st.w	r6[0x0],r7
80006b0e:	cf 7b       	rjmp	80006afc <vTaskDelayUntil+0x50>
80006b10:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006b14:	80 00       	ld.sh	r0,r0[0x0]
80006b16:	65 64       	ld.w	r4,r2[0x58]
80006b18:	00 00       	add	r0,r0
80006b1a:	0d 10       	ld.sh	r0,r6++
80006b1c:	00 00       	add	r0,r0
80006b1e:	0c e4       	st.h	--r6,r4
80006b20:	80 00       	ld.sh	r0,r0[0x0]
80006b22:	5d 1e       	icall	lr
80006b24:	80 00       	ld.sh	r0,r0[0x0]
80006b26:	6a 08       	ld.w	r8,r5[0x0]
80006b28:	80 00       	ld.sh	r0,r0[0x0]
80006b2a:	69 20       	ld.w	r0,r4[0x48]

80006b2c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006b2c:	eb cd 40 c0 	pushm	r6-r7,lr
80006b30:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006b32:	48 e7       	lddpc	r7,80006b68 <vTaskPlaceOnEventList+0x3c>
80006b34:	6e 0b       	ld.w	r11,r7[0x0]
80006b36:	2e 8b       	sub	r11,-24
80006b38:	f0 1f 00 0d 	mcall	80006b6c <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006b3c:	6e 0c       	ld.w	r12,r7[0x0]
80006b3e:	2f cc       	sub	r12,-4
80006b40:	f0 1f 00 0c 	mcall	80006b70 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006b44:	5b f6       	cp.w	r6,-1
80006b46:	c0 81       	brne	80006b56 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006b48:	6e 0b       	ld.w	r11,r7[0x0]
80006b4a:	2f cb       	sub	r11,-4
80006b4c:	48 ac       	lddpc	r12,80006b74 <vTaskPlaceOnEventList+0x48>
80006b4e:	f0 1f 00 0b 	mcall	80006b78 <vTaskPlaceOnEventList+0x4c>
80006b52:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006b56:	48 a8       	lddpc	r8,80006b7c <vTaskPlaceOnEventList+0x50>
80006b58:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80006b5a:	ec 0c 00 0c 	add	r12,r6,r12
80006b5e:	f0 1f 00 09 	mcall	80006b80 <vTaskPlaceOnEventList+0x54>
80006b62:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006b66:	00 00       	add	r0,r0
80006b68:	00 00       	add	r0,r0
80006b6a:	0c e4       	st.h	--r6,r4
80006b6c:	80 00       	ld.sh	r0,r0[0x0]
80006b6e:	5c ea       	tnbz	r10
80006b70:	80 00       	ld.sh	r0,r0[0x0]
80006b72:	5d 1e       	icall	lr
80006b74:	00 00       	add	r0,r0
80006b76:	0d 38       	ld.ub	r8,r6++
80006b78:	80 00       	ld.sh	r0,r0[0x0]
80006b7a:	5c ce       	swap.bh	lr
80006b7c:	00 00       	add	r0,r0
80006b7e:	0d 10       	ld.sh	r0,r6++
80006b80:	80 00       	ld.sh	r0,r0[0x0]
80006b82:	6a 08       	ld.w	r8,r5[0x0]

80006b84 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006b84:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006b88:	49 67       	lddpc	r7,80006be0 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006b8a:	49 74       	lddpc	r4,80006be4 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006b8c:	49 73       	lddpc	r3,80006be8 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006b8e:	49 85       	lddpc	r5,80006bec <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006b90:	6e 08       	ld.w	r8,r7[0x0]
80006b92:	58 08       	cp.w	r8,0
80006b94:	c1 e0       	breq	80006bd0 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80006b96:	f0 1f 00 17 	mcall	80006bf0 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006b9a:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006b9c:	f0 1f 00 16 	mcall	80006bf4 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006ba0:	58 06       	cp.w	r6,0
80006ba2:	c1 70       	breq	80006bd0 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006ba4:	f0 1f 00 15 	mcall	80006bf8 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006ba8:	68 38       	ld.w	r8,r4[0xc]
80006baa:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006bac:	ec cc ff fc 	sub	r12,r6,-4
80006bb0:	f0 1f 00 13 	mcall	80006bfc <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80006bb4:	66 08       	ld.w	r8,r3[0x0]
80006bb6:	20 18       	sub	r8,1
80006bb8:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80006bba:	6e 08       	ld.w	r8,r7[0x0]
80006bbc:	20 18       	sub	r8,1
80006bbe:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006bc0:	f0 1f 00 10 	mcall	80006c00 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006bc4:	6c cc       	ld.w	r12,r6[0x30]
80006bc6:	f0 1f 00 10 	mcall	80006c04 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80006bca:	0c 9c       	mov	r12,r6
80006bcc:	f0 1f 00 0e 	mcall	80006c04 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006bd0:	6a 08       	ld.w	r8,r5[0x0]
80006bd2:	58 18       	cp.w	r8,1
80006bd4:	e0 88 00 03 	brls	80006bda <prvIdleTask+0x56>
			{
				taskYIELD();
80006bd8:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80006bda:	f0 1f 00 0c 	mcall	80006c08 <prvIdleTask+0x84>
		}
		#endif
	}
80006bde:	cd 9b       	rjmp	80006b90 <prvIdleTask+0xc>
80006be0:	00 00       	add	r0,r0
80006be2:	0c 24       	rsub	r4,r6
80006be4:	00 00       	add	r0,r0
80006be6:	0c d0       	st.w	--r6,r0
80006be8:	00 00       	add	r0,r0
80006bea:	0d 30       	ld.ub	r0,r6++
80006bec:	00 00       	add	r0,r0
80006bee:	0c 30       	cp.w	r0,r6
80006bf0:	80 00       	ld.sh	r0,r0[0x0]
80006bf2:	65 64       	ld.w	r4,r2[0x58]
80006bf4:	80 00       	ld.sh	r0,r0[0x0]
80006bf6:	69 20       	ld.w	r0,r4[0x48]
80006bf8:	80 00       	ld.sh	r0,r0[0x0]
80006bfa:	5d d8       	*unknown*
80006bfc:	80 00       	ld.sh	r0,r0[0x0]
80006bfe:	5d 1e       	icall	lr
80006c00:	80 00       	ld.sh	r0,r0[0x0]
80006c02:	5e e4       	retqs	r4
80006c04:	80 00       	ld.sh	r0,r0[0x0]
80006c06:	60 1c       	ld.w	r12,r0[0x4]
80006c08:	80 00       	ld.sh	r0,r0[0x0]
80006c0a:	20 2c       	sub	r12,2

80006c0c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006c0c:	d4 31       	pushm	r0-r7,lr
80006c0e:	20 1d       	sub	sp,4
80006c10:	fa c4 ff d8 	sub	r4,sp,-40
80006c14:	50 0c       	stdsp	sp[0x0],r12
80006c16:	16 91       	mov	r1,r11
80006c18:	14 97       	mov	r7,r10
80006c1a:	12 90       	mov	r0,r9
80006c1c:	10 93       	mov	r3,r8
80006c1e:	68 02       	ld.w	r2,r4[0x0]
80006c20:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006c22:	34 8c       	mov	r12,72
80006c24:	f0 1f 00 5c 	mcall	80006d94 <xTaskGenericCreate+0x188>
80006c28:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80006c2a:	c0 31       	brne	80006c30 <xTaskGenericCreate+0x24>
80006c2c:	3f fc       	mov	r12,-1
80006c2e:	ca f8       	rjmp	80006d8c <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006c30:	58 06       	cp.w	r6,0
80006c32:	e0 81 00 af 	brne	80006d90 <xTaskGenericCreate+0x184>
80006c36:	0e 9c       	mov	r12,r7
80006c38:	5c 7c       	castu.h	r12
80006c3a:	a3 6c       	lsl	r12,0x2
80006c3c:	f0 1f 00 56 	mcall	80006d94 <xTaskGenericCreate+0x188>
80006c40:	18 96       	mov	r6,r12
80006c42:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006c44:	c0 61       	brne	80006c50 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006c46:	0a 9c       	mov	r12,r5
80006c48:	f0 1f 00 54 	mcall	80006d98 <xTaskGenericCreate+0x18c>
80006c4c:	3f fc       	mov	r12,-1
80006c4e:	c9 f8       	rjmp	80006d8c <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006c50:	5c 77       	castu.h	r7
80006c52:	ee 0a 15 02 	lsl	r10,r7,0x2
80006c56:	e0 6b 00 a5 	mov	r11,165
80006c5a:	0c 9c       	mov	r12,r6
80006c5c:	f0 1f 00 50 	mcall	80006d9c <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006c60:	ee c6 00 01 	sub	r6,r7,1
80006c64:	6a c8       	ld.w	r8,r5[0x30]
80006c66:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006c6a:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006c6e:	31 0a       	mov	r10,16
80006c70:	02 9b       	mov	r11,r1
80006c72:	ea cc ff cc 	sub	r12,r5,-52
80006c76:	f0 1f 00 4b 	mcall	80006da0 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006c7a:	30 08       	mov	r8,0
80006c7c:	eb 68 00 43 	st.b	r5[67],r8
80006c80:	58 73       	cp.w	r3,7
80006c82:	e6 07 17 80 	movls	r7,r3
80006c86:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006c8a:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006c8c:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006c90:	ea c4 ff fc 	sub	r4,r5,-4
80006c94:	08 9c       	mov	r12,r4
80006c96:	f0 1f 00 44 	mcall	80006da4 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006c9a:	ea cc ff e8 	sub	r12,r5,-24
80006c9e:	f0 1f 00 42 	mcall	80006da4 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006ca2:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006ca4:	ee 07 11 08 	rsub	r7,r7,8
80006ca8:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006caa:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006cac:	00 9a       	mov	r10,r0
80006cae:	40 0b       	lddsp	r11,sp[0x0]
80006cb0:	0c 9c       	mov	r12,r6
80006cb2:	f0 1f 00 3e 	mcall	80006da8 <xTaskGenericCreate+0x19c>
80006cb6:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006cb8:	58 02       	cp.w	r2,0
80006cba:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006cbe:	f0 1f 00 3c 	mcall	80006dac <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006cc2:	4b c8       	lddpc	r8,80006db0 <xTaskGenericCreate+0x1a4>
80006cc4:	70 09       	ld.w	r9,r8[0x0]
80006cc6:	2f f9       	sub	r9,-1
80006cc8:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006cca:	4b b8       	lddpc	r8,80006db4 <xTaskGenericCreate+0x1a8>
80006ccc:	70 08       	ld.w	r8,r8[0x0]
80006cce:	58 08       	cp.w	r8,0
80006cd0:	c2 61       	brne	80006d1c <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006cd2:	4b 98       	lddpc	r8,80006db4 <xTaskGenericCreate+0x1a8>
80006cd4:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006cd6:	4b 78       	lddpc	r8,80006db0 <xTaskGenericCreate+0x1a4>
80006cd8:	70 08       	ld.w	r8,r8[0x0]
80006cda:	58 18       	cp.w	r8,1
80006cdc:	c2 b1       	brne	80006d32 <xTaskGenericCreate+0x126>
80006cde:	4b 77       	lddpc	r7,80006db8 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006ce0:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006ce4:	0e 9c       	mov	r12,r7
80006ce6:	f0 1f 00 36 	mcall	80006dbc <xTaskGenericCreate+0x1b0>
80006cea:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006cec:	0c 37       	cp.w	r7,r6
80006cee:	cf b1       	brne	80006ce4 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006cf0:	4b 47       	lddpc	r7,80006dc0 <xTaskGenericCreate+0x1b4>
80006cf2:	0e 9c       	mov	r12,r7
80006cf4:	f0 1f 00 32 	mcall	80006dbc <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006cf8:	4b 36       	lddpc	r6,80006dc4 <xTaskGenericCreate+0x1b8>
80006cfa:	0c 9c       	mov	r12,r6
80006cfc:	f0 1f 00 30 	mcall	80006dbc <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006d00:	4b 2c       	lddpc	r12,80006dc8 <xTaskGenericCreate+0x1bc>
80006d02:	f0 1f 00 2f 	mcall	80006dbc <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006d06:	4b 2c       	lddpc	r12,80006dcc <xTaskGenericCreate+0x1c0>
80006d08:	f0 1f 00 2d 	mcall	80006dbc <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006d0c:	4b 1c       	lddpc	r12,80006dd0 <xTaskGenericCreate+0x1c4>
80006d0e:	f0 1f 00 2c 	mcall	80006dbc <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006d12:	4b 18       	lddpc	r8,80006dd4 <xTaskGenericCreate+0x1c8>
80006d14:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006d16:	4b 18       	lddpc	r8,80006dd8 <xTaskGenericCreate+0x1cc>
80006d18:	91 06       	st.w	r8[0x0],r6
80006d1a:	c0 c8       	rjmp	80006d32 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006d1c:	4b 08       	lddpc	r8,80006ddc <xTaskGenericCreate+0x1d0>
80006d1e:	70 08       	ld.w	r8,r8[0x0]
80006d20:	58 08       	cp.w	r8,0
80006d22:	c0 81       	brne	80006d32 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006d24:	4a 48       	lddpc	r8,80006db4 <xTaskGenericCreate+0x1a8>
80006d26:	70 08       	ld.w	r8,r8[0x0]
80006d28:	70 b8       	ld.w	r8,r8[0x2c]
80006d2a:	10 33       	cp.w	r3,r8
80006d2c:	c0 33       	brcs	80006d32 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006d2e:	4a 28       	lddpc	r8,80006db4 <xTaskGenericCreate+0x1a8>
80006d30:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006d32:	6a b8       	ld.w	r8,r5[0x2c]
80006d34:	4a b9       	lddpc	r9,80006de0 <xTaskGenericCreate+0x1d4>
80006d36:	72 09       	ld.w	r9,r9[0x0]
80006d38:	12 38       	cp.w	r8,r9
80006d3a:	e0 88 00 04 	brls	80006d42 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006d3e:	4a 99       	lddpc	r9,80006de0 <xTaskGenericCreate+0x1d4>
80006d40:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006d42:	4a 98       	lddpc	r8,80006de4 <xTaskGenericCreate+0x1d8>
80006d44:	70 09       	ld.w	r9,r8[0x0]
80006d46:	2f f9       	sub	r9,-1
80006d48:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006d4a:	6a b8       	ld.w	r8,r5[0x2c]
80006d4c:	4a 79       	lddpc	r9,80006de8 <xTaskGenericCreate+0x1dc>
80006d4e:	72 09       	ld.w	r9,r9[0x0]
80006d50:	12 38       	cp.w	r8,r9
80006d52:	e0 88 00 04 	brls	80006d5a <xTaskGenericCreate+0x14e>
80006d56:	4a 59       	lddpc	r9,80006de8 <xTaskGenericCreate+0x1dc>
80006d58:	93 08       	st.w	r9[0x0],r8
80006d5a:	6a bc       	ld.w	r12,r5[0x2c]
80006d5c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006d60:	08 9b       	mov	r11,r4
80006d62:	49 68       	lddpc	r8,80006db8 <xTaskGenericCreate+0x1ac>
80006d64:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006d68:	f0 1f 00 21 	mcall	80006dec <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006d6c:	f0 1f 00 21 	mcall	80006df0 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006d70:	49 b8       	lddpc	r8,80006ddc <xTaskGenericCreate+0x1d0>
80006d72:	70 08       	ld.w	r8,r8[0x0]
80006d74:	58 08       	cp.w	r8,0
80006d76:	c0 a0       	breq	80006d8a <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006d78:	48 f8       	lddpc	r8,80006db4 <xTaskGenericCreate+0x1a8>
80006d7a:	70 08       	ld.w	r8,r8[0x0]
80006d7c:	70 b8       	ld.w	r8,r8[0x2c]
80006d7e:	10 33       	cp.w	r3,r8
80006d80:	e0 88 00 05 	brls	80006d8a <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006d84:	d7 33       	scall
80006d86:	30 1c       	mov	r12,1
80006d88:	c0 28       	rjmp	80006d8c <xTaskGenericCreate+0x180>
80006d8a:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006d8c:	2f fd       	sub	sp,-4
80006d8e:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006d90:	99 c6       	st.w	r12[0x30],r6
80006d92:	c5 fb       	rjmp	80006c50 <xTaskGenericCreate+0x44>
80006d94:	80 00       	ld.sh	r0,r0[0x0]
80006d96:	60 44       	ld.w	r4,r0[0x10]
80006d98:	80 00       	ld.sh	r0,r0[0x0]
80006d9a:	60 1c       	ld.w	r12,r0[0x4]
80006d9c:	80 00       	ld.sh	r0,r0[0x0]
80006d9e:	79 9c       	ld.w	r12,r12[0x64]
80006da0:	80 00       	ld.sh	r0,r0[0x0]
80006da2:	7c c8       	ld.w	r8,lr[0x30]
80006da4:	80 00       	ld.sh	r0,r0[0x0]
80006da6:	5c c8       	swap.bh	r8
80006da8:	80 00       	ld.sh	r0,r0[0x0]
80006daa:	5d 44       	*unknown*
80006dac:	80 00       	ld.sh	r0,r0[0x0]
80006dae:	5d d8       	*unknown*
80006db0:	00 00       	add	r0,r0
80006db2:	0d 30       	ld.ub	r0,r6++
80006db4:	00 00       	add	r0,r0
80006db6:	0c e4       	st.h	--r6,r4
80006db8:	00 00       	add	r0,r0
80006dba:	0c 30       	cp.w	r0,r6
80006dbc:	80 00       	ld.sh	r0,r0[0x0]
80006dbe:	5c b4       	swap.b	r4
80006dc0:	00 00       	add	r0,r0
80006dc2:	0c fc       	st.b	--r6,r12
80006dc4:	00 00       	add	r0,r0
80006dc6:	0d 18       	ld.sh	r8,r6++
80006dc8:	00 00       	add	r0,r0
80006dca:	0c e8       	st.h	--r6,r8
80006dcc:	00 00       	add	r0,r0
80006dce:	0c d0       	st.w	--r6,r0
80006dd0:	00 00       	add	r0,r0
80006dd2:	0d 38       	ld.ub	r8,r6++
80006dd4:	00 00       	add	r0,r0
80006dd6:	0c 1c       	sub	r12,r6
80006dd8:	00 00       	add	r0,r0
80006dda:	0c 2c       	rsub	r12,r6
80006ddc:	00 00       	add	r0,r0
80006dde:	0c 20       	rsub	r0,r6
80006de0:	00 00       	add	r0,r0
80006de2:	0c 18       	sub	r8,r6
80006de4:	00 00       	add	r0,r0
80006de6:	0d 2c       	ld.uh	r12,r6++
80006de8:	00 00       	add	r0,r0
80006dea:	0d 4c       	ld.w	r12,--r6
80006dec:	80 00       	ld.sh	r0,r0[0x0]
80006dee:	5c ce       	swap.bh	lr
80006df0:	80 00       	ld.sh	r0,r0[0x0]
80006df2:	5e e4       	retqs	r4

80006df4 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006df4:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006df6:	30 09       	mov	r9,0
80006df8:	1a d9       	st.w	--sp,r9
80006dfa:	1a d9       	st.w	--sp,r9
80006dfc:	1a d9       	st.w	--sp,r9
80006dfe:	12 98       	mov	r8,r9
80006e00:	e0 6a 01 00 	mov	r10,256
80006e04:	48 9b       	lddpc	r11,80006e28 <vTaskStartScheduler+0x34>
80006e06:	48 ac       	lddpc	r12,80006e2c <vTaskStartScheduler+0x38>
80006e08:	f0 1f 00 0a 	mcall	80006e30 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006e0c:	2f dd       	sub	sp,-12
80006e0e:	58 1c       	cp.w	r12,1
80006e10:	c0 a1       	brne	80006e24 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006e12:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006e14:	30 19       	mov	r9,1
80006e16:	48 88       	lddpc	r8,80006e34 <vTaskStartScheduler+0x40>
80006e18:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006e1a:	30 09       	mov	r9,0
80006e1c:	48 78       	lddpc	r8,80006e38 <vTaskStartScheduler+0x44>
80006e1e:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006e20:	f0 1f 00 07 	mcall	80006e3c <vTaskStartScheduler+0x48>
80006e24:	d8 02       	popm	pc
80006e26:	00 00       	add	r0,r0
80006e28:	80 00       	ld.sh	r0,r0[0x0]
80006e2a:	da 08       	*unknown*
80006e2c:	80 00       	ld.sh	r0,r0[0x0]
80006e2e:	6b 84       	ld.w	r4,r5[0x60]
80006e30:	80 00       	ld.sh	r0,r0[0x0]
80006e32:	6c 0c       	ld.w	r12,r6[0x0]
80006e34:	00 00       	add	r0,r0
80006e36:	0c 20       	rsub	r0,r6
80006e38:	00 00       	add	r0,r0
80006e3a:	0d 10       	ld.sh	r0,r6++
80006e3c:	80 00       	ld.sh	r0,r0[0x0]
80006e3e:	5d e8       	*unknown*

80006e40 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006e40:	16 cc       	st.b	r11++,r12
	return str;
}
80006e42:	5e fb       	retal	r11

80006e44 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006e44:	eb cd 40 c0 	pushm	r6-r7,lr
80006e48:	20 3d       	sub	sp,12
80006e4a:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006e4c:	30 06       	mov	r6,0
80006e4e:	30 07       	mov	r7,0
80006e50:	fa e7 00 00 	st.d	sp[0],r6
80006e54:	30 0c       	mov	r12,0
80006e56:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006e58:	58 08       	cp.w	r8,0
80006e5a:	c1 30       	breq	80006e80 <PrintHex+0x3c>
80006e5c:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006e5e:	1a 9c       	mov	r12,sp
80006e60:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006e64:	58 9e       	cp.w	lr,9
80006e66:	e0 8a 00 04 	brle	80006e6e <PrintHex+0x2a>
80006e6a:	2c 9e       	sub	lr,-55
80006e6c:	c0 48       	rjmp	80006e74 <PrintHex+0x30>
80006e6e:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006e72:	2d 0e       	sub	lr,-48
80006e74:	f8 09 0b 0e 	st.b	r12[r9],lr
80006e78:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006e7a:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006e7c:	cf 21       	brne	80006e60 <PrintHex+0x1c>
80006e7e:	c0 48       	rjmp	80006e86 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006e80:	33 08       	mov	r8,48
80006e82:	ba 88       	st.b	sp[0x0],r8
80006e84:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006e86:	f6 09 01 08 	sub	r8,r11,r9
80006e8a:	58 08       	cp.w	r8,0
80006e8c:	e0 8a 00 13 	brle	80006eb2 <PrintHex+0x6e>
	{
		char num = len - cnt;
80006e90:	12 1b       	sub	r11,r9
80006e92:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006e96:	18 9e       	mov	lr,r12
80006e98:	58 0c       	cp.w	r12,0
80006e9a:	e0 8a 00 0c 	brle	80006eb2 <PrintHex+0x6e>
80006e9e:	1a 9b       	mov	r11,sp
80006ea0:	12 0b       	add	r11,r9
80006ea2:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006ea4:	33 07       	mov	r7,48
80006ea6:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006ea8:	2f f8       	sub	r8,-1
80006eaa:	1c 38       	cp.w	r8,lr
80006eac:	cf d5       	brlt	80006ea6 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006eae:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006eb2:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006eb6:	f0 cb ff ff 	sub	r11,r8,-1
80006eba:	58 0b       	cp.w	r11,0
80006ebc:	e0 8a 00 19 	brle	80006eee <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006ec0:	fa cb ff f4 	sub	r11,sp,-12
80006ec4:	f6 09 00 09 	add	r9,r11,r9
80006ec8:	37 8b       	mov	r11,120
80006eca:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006ece:	fa c9 ff f4 	sub	r9,sp,-12
80006ed2:	10 09       	add	r9,r8
80006ed4:	33 0b       	mov	r11,48
80006ed6:	f3 6b ff f4 	st.b	r9[-12],r11
80006eda:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006ede:	fa ce 00 01 	sub	lr,sp,1
80006ee2:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006ee4:	11 8b       	ld.ub	r11,r8[0x0]
80006ee6:	12 cb       	st.b	r9++,r11
80006ee8:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006eea:	1c 38       	cp.w	r8,lr
80006eec:	cf c1       	brne	80006ee4 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006eee:	14 9c       	mov	r12,r10
80006ef0:	2f dd       	sub	sp,-12
80006ef2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006ef6 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006ef6:	d4 21       	pushm	r4-r7,lr
80006ef8:	20 3d       	sub	sp,12
80006efa:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006efc:	30 06       	mov	r6,0
80006efe:	30 07       	mov	r7,0
80006f00:	fa e7 00 00 	st.d	sp[0],r6
80006f04:	30 0c       	mov	r12,0
80006f06:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006f08:	58 08       	cp.w	r8,0
80006f0a:	c0 35       	brlt	80006f10 <PrintDec+0x1a>
80006f0c:	14 97       	mov	r7,r10
80006f0e:	c0 58       	rjmp	80006f18 <PrintDec+0x22>
	{
		*p++ = '-';
80006f10:	14 97       	mov	r7,r10
80006f12:	32 d9       	mov	r9,45
80006f14:	0e c9       	st.b	r7++,r9
		i = -i;
80006f16:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006f18:	58 08       	cp.w	r8,0
80006f1a:	c0 51       	brne	80006f24 <PrintDec+0x2e>
80006f1c:	33 08       	mov	r8,48
80006f1e:	ba 88       	st.b	sp[0x0],r8
80006f20:	30 1e       	mov	lr,1
80006f22:	c2 f8       	rjmp	80006f80 <PrintDec+0x8a>
	
	int ten = i%10;
80006f24:	e0 65 66 67 	mov	r5,26215
80006f28:	ea 15 66 66 	orh	r5,0x6666
80006f2c:	f0 05 04 44 	muls.d	r4,r8,r5
80006f30:	ea 0c 14 02 	asr	r12,r5,0x2
80006f34:	f0 09 14 1f 	asr	r9,r8,0x1f
80006f38:	f8 09 01 09 	sub	r9,r12,r9
80006f3c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006f40:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006f44:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006f46:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006f48:	e0 66 66 67 	mov	r6,26215
80006f4c:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006f50:	2d 09       	sub	r9,-48
80006f52:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006f56:	2f fe       	sub	lr,-1
		i /= 10;
80006f58:	f0 06 04 44 	muls.d	r4,r8,r6
80006f5c:	ea 09 14 02 	asr	r9,r5,0x2
80006f60:	bf 58       	asr	r8,0x1f
80006f62:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006f66:	f0 06 04 44 	muls.d	r4,r8,r6
80006f6a:	ea 09 14 02 	asr	r9,r5,0x2
80006f6e:	f0 05 14 1f 	asr	r5,r8,0x1f
80006f72:	0a 19       	sub	r9,r5
80006f74:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006f78:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006f7c:	58 08       	cp.w	r8,0
80006f7e:	ce 91       	brne	80006f50 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006f80:	f6 0e 01 08 	sub	r8,r11,lr
80006f84:	58 08       	cp.w	r8,0
80006f86:	e0 89 00 06 	brgt	80006f92 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006f8a:	58 0e       	cp.w	lr,0
80006f8c:	e0 89 00 14 	brgt	80006fb4 <PrintDec+0xbe>
80006f90:	c1 d8       	rjmp	80006fca <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006f92:	1c 1b       	sub	r11,lr
80006f94:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006f96:	16 9c       	mov	r12,r11
80006f98:	58 0b       	cp.w	r11,0
80006f9a:	fe 9a ff f8 	brle	80006f8a <PrintDec+0x94>
80006f9e:	1a 99       	mov	r9,sp
80006fa0:	1c 09       	add	r9,lr
80006fa2:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006fa4:	33 06       	mov	r6,48
80006fa6:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006fa8:	2f f8       	sub	r8,-1
80006faa:	18 38       	cp.w	r8,r12
80006fac:	cf d5       	brlt	80006fa6 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006fae:	f6 0e 00 0e 	add	lr,r11,lr
80006fb2:	ce cb       	rjmp	80006f8a <PrintDec+0x94>
80006fb4:	fa c8 ff f4 	sub	r8,sp,-12
80006fb8:	1c 08       	add	r8,lr
80006fba:	20 d8       	sub	r8,13
80006fbc:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006fc0:	11 89       	ld.ub	r9,r8[0x0]
80006fc2:	0e c9       	st.b	r7++,r9
80006fc4:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006fc6:	16 38       	cp.w	r8,r11
80006fc8:	cf c1       	brne	80006fc0 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80006fca:	14 9c       	mov	r12,r10
80006fcc:	2f dd       	sub	sp,-12
80006fce:	d8 22       	popm	r4-r7,pc

80006fd0 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006fd0:	d4 31       	pushm	r0-r7,lr
80006fd2:	fa cd 02 08 	sub	sp,sp,520
80006fd6:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006fd8:	e0 6a 01 00 	mov	r10,256
80006fdc:	30 0b       	mov	r11,0
80006fde:	fa cc fe f8 	sub	r12,sp,-264
80006fe2:	f0 1f 00 4e 	mcall	80007118 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006fe6:	fa c4 fd d4 	sub	r4,sp,-556
80006fea:	30 0a       	mov	r10,0
80006fec:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006fee:	fa c3 ff fc 	sub	r3,sp,-4
80006ff2:	e0 61 01 00 	mov	r1,256
80006ff6:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006ff8:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006ffa:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006ffe:	02 9a       	mov	r10,r1
80007000:	00 9b       	mov	r11,r0
80007002:	06 9c       	mov	r12,r3
80007004:	f0 1f 00 45 	mcall	80007118 <log+0x148>
			
					if(*str == '%')
80007008:	0f 88       	ld.ub	r8,r7[0x0]
8000700a:	e4 08 18 00 	cp.b	r8,r2
8000700e:	c5 71       	brne	800070bc <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80007010:	ee c8 ff ff 	sub	r8,r7,-1
80007014:	11 89       	ld.ub	r9,r8[0x0]
80007016:	4c 2a       	lddpc	r10,8000711c <log+0x14c>
80007018:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
8000701a:	23 09       	sub	r9,48
8000701c:	30 9a       	mov	r10,9
8000701e:	f4 09 18 00 	cp.b	r9,r10
80007022:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80007026:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000702a:	f7 b9 08 30 	subls	r9,48
8000702e:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80007032:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80007036:	0f 88       	ld.ub	r8,r7[0x0]
80007038:	22 58       	sub	r8,37
8000703a:	e0 48 00 53 	cp.w	r8,83
8000703e:	e0 8b 00 31 	brhi	800070a0 <log+0xd0>
80007042:	4b 89       	lddpc	r9,80007120 <log+0x150>
80007044:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80007048:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
8000704c:	06 9a       	mov	r10,r3
8000704e:	40 0b       	lddsp	r11,sp[0x0]
80007050:	5c 5b       	castu.b	r11
80007052:	68 0c       	ld.w	r12,r4[0x0]
80007054:	f0 1f 00 34 	mcall	80007124 <log+0x154>
							break;
80007058:	c2 98       	rjmp	800070aa <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
8000705a:	4b 4c       	lddpc	r12,80007128 <log+0x158>
8000705c:	f0 1f 00 34 	mcall	8000712c <log+0x15c>
80007060:	08 95       	mov	r5,r4
80007062:	06 9c       	mov	r12,r3
							break;
80007064:	c2 38       	rjmp	800070aa <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80007066:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
8000706a:	06 9a       	mov	r10,r3
8000706c:	40 0b       	lddsp	r11,sp[0x0]
8000706e:	5c 5b       	castu.b	r11
80007070:	68 0c       	ld.w	r12,r4[0x0]
80007072:	f0 1f 00 30 	mcall	80007130 <log+0x160>
80007076:	06 9c       	mov	r12,r3
							break;
80007078:	c1 98       	rjmp	800070aa <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
8000707a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
8000707e:	06 9b       	mov	r11,r3
80007080:	09 bc       	ld.ub	r12,r4[0x3]
80007082:	f0 1f 00 2d 	mcall	80007134 <log+0x164>
80007086:	06 9c       	mov	r12,r3
							break;
80007088:	c1 18       	rjmp	800070aa <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
8000708a:	e8 c5 ff fc 	sub	r5,r4,-4
8000708e:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80007090:	c0 d8       	rjmp	800070aa <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80007092:	06 9b       	mov	r11,r3
80007094:	32 5c       	mov	r12,37
80007096:	f0 1f 00 28 	mcall	80007134 <log+0x164>
8000709a:	08 95       	mov	r5,r4
8000709c:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
8000709e:	c0 68       	rjmp	800070aa <log+0xda>
							
							default:
							log("I need relax.");
800070a0:	4a 6c       	lddpc	r12,80007138 <log+0x168>
800070a2:	f0 1f 00 23 	mcall	8000712c <log+0x15c>
800070a6:	08 95       	mov	r5,r4
800070a8:	06 9c       	mov	r12,r3
						}
						str++;
800070aa:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800070ac:	1a dc       	st.w	--sp,r12
800070ae:	1a d6       	st.w	--sp,r6
800070b0:	4a 3b       	lddpc	r11,8000713c <log+0x16c>
800070b2:	0c 9c       	mov	r12,r6
800070b4:	f0 1f 00 23 	mcall	80007140 <log+0x170>
800070b8:	2f ed       	sub	sp,-8
800070ba:	c0 a8       	rjmp	800070ce <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800070bc:	2f f7       	sub	r7,-1
800070be:	1a d8       	st.w	--sp,r8
800070c0:	1a d6       	st.w	--sp,r6
800070c2:	4a 1b       	lddpc	r11,80007144 <log+0x174>
800070c4:	0c 9c       	mov	r12,r6
800070c6:	f0 1f 00 1f 	mcall	80007140 <log+0x170>
800070ca:	08 95       	mov	r5,r4
800070cc:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
800070ce:	0f 89       	ld.ub	r9,r7[0x0]
800070d0:	30 08       	mov	r8,0
800070d2:	f0 09 18 00 	cp.b	r9,r8
800070d6:	c0 30       	breq	800070dc <log+0x10c>
800070d8:	0a 94       	mov	r4,r5
800070da:	c9 2b       	rjmp	80006ffe <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
800070dc:	fa c7 fe f8 	sub	r7,sp,-264
800070e0:	1a d7       	st.w	--sp,r7
800070e2:	49 ab       	lddpc	r11,80007148 <log+0x178>
800070e4:	0e 9c       	mov	r12,r7
800070e6:	f0 1f 00 17 	mcall	80007140 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
800070ea:	5c 5c       	castu.b	r12
800070ec:	f8 c6 ff ff 	sub	r6,r12,-1
800070f0:	0c 9c       	mov	r12,r6
800070f2:	f0 1f 00 17 	mcall	8000714c <log+0x17c>
800070f6:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
800070f8:	0c 9a       	mov	r10,r6
800070fa:	0e 9b       	mov	r11,r7
800070fc:	f0 1f 00 15 	mcall	80007150 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80007100:	30 09       	mov	r9,0
80007102:	30 5a       	mov	r10,5
80007104:	fa cb fe f8 	sub	r11,sp,-264
80007108:	49 38       	lddpc	r8,80007154 <log+0x184>
8000710a:	70 0c       	ld.w	r12,r8[0x0]
8000710c:	f0 1f 00 13 	mcall	80007158 <log+0x188>
80007110:	2f fd       	sub	sp,-4
	
	
}
80007112:	fe 3d fd f8 	sub	sp,-520
80007116:	d8 32       	popm	r0-r7,pc
80007118:	80 00       	ld.sh	r0,r0[0x0]
8000711a:	79 9c       	ld.w	r12,r12[0x64]
8000711c:	00 00       	add	r0,r0
8000711e:	0d 50       	ld.sh	r0,--r6
80007120:	80 00       	ld.sh	r0,r0[0x0]
80007122:	da 10       	acall	0xa1
80007124:	80 00       	ld.sh	r0,r0[0x0]
80007126:	6e f6       	ld.w	r6,r7[0x3c]
80007128:	80 00       	ld.sh	r0,r0[0x0]
8000712a:	dc bc       	*unknown*
8000712c:	80 00       	ld.sh	r0,r0[0x0]
8000712e:	6f d0       	ld.w	r0,r7[0x74]
80007130:	80 00       	ld.sh	r0,r0[0x0]
80007132:	6e 44       	ld.w	r4,r7[0x10]
80007134:	80 00       	ld.sh	r0,r0[0x0]
80007136:	6e 40       	ld.w	r0,r7[0x10]
80007138:	80 00       	ld.sh	r0,r0[0x0]
8000713a:	dc cc       	*unknown*
8000713c:	80 00       	ld.sh	r0,r0[0x0]
8000713e:	dc dc       	*unknown*
80007140:	80 00       	ld.sh	r0,r0[0x0]
80007142:	7c 8c       	ld.w	r12,lr[0x20]
80007144:	80 00       	ld.sh	r0,r0[0x0]
80007146:	dc e4       	*unknown*
80007148:	80 00       	ld.sh	r0,r0[0x0]
8000714a:	dc ec       	*unknown*
8000714c:	80 00       	ld.sh	r0,r0[0x0]
8000714e:	60 44       	ld.w	r4,r0[0x10]
80007150:	80 00       	ld.sh	r0,r0[0x0]
80007152:	78 54       	ld.w	r4,r12[0x14]
80007154:	00 00       	add	r0,r0
80007156:	53 b8       	stdsp	sp[0xec],r8
80007158:	80 00       	ld.sh	r0,r0[0x0]
8000715a:	63 98       	ld.w	r8,r1[0x64]

8000715c <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
8000715c:	d4 31       	pushm	r0-r7,lr
8000715e:	fa cd 02 0c 	sub	sp,sp,524
80007162:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80007164:	e0 6a 01 00 	mov	r10,256
80007168:	30 0b       	mov	r11,0
8000716a:	fa cc fe f4 	sub	r12,sp,-268
8000716e:	f0 1f 00 4c 	mcall	8000729c <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80007172:	fa c4 fd d0 	sub	r4,sp,-560
80007176:	30 0a       	mov	r10,0
80007178:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000717a:	fa c3 ff fc 	sub	r3,sp,-4
8000717e:	e0 61 01 00 	mov	r1,256
80007182:	14 90       	mov	r0,r10
			
			if(*str == '%')
80007184:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007186:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000718a:	02 9a       	mov	r10,r1
8000718c:	00 9b       	mov	r11,r0
8000718e:	06 9c       	mov	r12,r3
80007190:	f0 1f 00 43 	mcall	8000729c <logFromISR+0x140>
			
			if(*str == '%')
80007194:	0f 88       	ld.ub	r8,r7[0x0]
80007196:	e4 08 18 00 	cp.b	r8,r2
8000719a:	c5 11       	brne	8000723c <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
8000719c:	ee c8 ff ff 	sub	r8,r7,-1
800071a0:	11 89       	ld.ub	r9,r8[0x0]
800071a2:	4c 0a       	lddpc	r10,800072a0 <logFromISR+0x144>
800071a4:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
800071a6:	23 09       	sub	r9,48
800071a8:	30 9a       	mov	r10,9
800071aa:	f4 09 18 00 	cp.b	r9,r10
800071ae:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
800071b2:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800071b6:	f7 b9 08 30 	subls	r9,48
800071ba:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
800071be:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
800071c2:	0f 88       	ld.ub	r8,r7[0x0]
800071c4:	22 58       	sub	r8,37
800071c6:	e0 48 00 53 	cp.w	r8,83
800071ca:	e0 8b 00 2b 	brhi	80007220 <logFromISR+0xc4>
800071ce:	4b 69       	lddpc	r9,800072a4 <logFromISR+0x148>
800071d0:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
800071d4:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
800071d8:	06 9a       	mov	r10,r3
800071da:	40 0b       	lddsp	r11,sp[0x0]
800071dc:	5c 5b       	castu.b	r11
800071de:	68 0c       	ld.w	r12,r4[0x0]
800071e0:	f0 1f 00 32 	mcall	800072a8 <logFromISR+0x14c>
					break;
800071e4:	c2 38       	rjmp	8000722a <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
800071e6:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
800071ea:	06 9a       	mov	r10,r3
800071ec:	40 0b       	lddsp	r11,sp[0x0]
800071ee:	5c 5b       	castu.b	r11
800071f0:	68 0c       	ld.w	r12,r4[0x0]
800071f2:	f0 1f 00 2f 	mcall	800072ac <logFromISR+0x150>
800071f6:	06 9c       	mov	r12,r3
					break;
800071f8:	c1 98       	rjmp	8000722a <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
800071fa:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
800071fe:	06 9b       	mov	r11,r3
80007200:	09 bc       	ld.ub	r12,r4[0x3]
80007202:	f0 1f 00 2c 	mcall	800072b0 <logFromISR+0x154>
80007206:	06 9c       	mov	r12,r3
					break;
80007208:	c1 18       	rjmp	8000722a <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
8000720a:	e8 c5 ff fc 	sub	r5,r4,-4
8000720e:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80007210:	c0 d8       	rjmp	8000722a <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80007212:	06 9b       	mov	r11,r3
80007214:	32 5c       	mov	r12,37
80007216:	f0 1f 00 27 	mcall	800072b0 <logFromISR+0x154>
8000721a:	08 95       	mov	r5,r4
8000721c:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
8000721e:	c0 68       	rjmp	8000722a <logFromISR+0xce>
					default:
					log("I need relax.");
80007220:	4a 5c       	lddpc	r12,800072b4 <logFromISR+0x158>
80007222:	f0 1f 00 26 	mcall	800072b8 <logFromISR+0x15c>
80007226:	08 95       	mov	r5,r4
80007228:	06 9c       	mov	r12,r3
				}
				str++;
8000722a:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000722c:	1a dc       	st.w	--sp,r12
8000722e:	1a d6       	st.w	--sp,r6
80007230:	4a 3b       	lddpc	r11,800072bc <logFromISR+0x160>
80007232:	0c 9c       	mov	r12,r6
80007234:	f0 1f 00 23 	mcall	800072c0 <logFromISR+0x164>
80007238:	2f ed       	sub	sp,-8
8000723a:	c0 a8       	rjmp	8000724e <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000723c:	2f f7       	sub	r7,-1
8000723e:	1a d8       	st.w	--sp,r8
80007240:	1a d6       	st.w	--sp,r6
80007242:	4a 1b       	lddpc	r11,800072c4 <logFromISR+0x168>
80007244:	0c 9c       	mov	r12,r6
80007246:	f0 1f 00 1f 	mcall	800072c0 <logFromISR+0x164>
8000724a:	08 95       	mov	r5,r4
8000724c:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
8000724e:	0f 89       	ld.ub	r9,r7[0x0]
80007250:	30 08       	mov	r8,0
80007252:	f0 09 18 00 	cp.b	r9,r8
80007256:	c0 30       	breq	8000725c <logFromISR+0x100>
80007258:	0a 94       	mov	r4,r5
8000725a:	c9 8b       	rjmp	8000718a <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
8000725c:	fa c7 fe f4 	sub	r7,sp,-268
80007260:	1a d7       	st.w	--sp,r7
80007262:	49 ab       	lddpc	r11,800072c8 <logFromISR+0x16c>
80007264:	0e 9c       	mov	r12,r7
80007266:	f0 1f 00 17 	mcall	800072c0 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
8000726a:	5c 5c       	castu.b	r12
8000726c:	f8 c6 ff ff 	sub	r6,r12,-1
80007270:	0c 9c       	mov	r12,r6
80007272:	f0 1f 00 17 	mcall	800072cc <logFromISR+0x170>
80007276:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80007278:	0c 9a       	mov	r10,r6
8000727a:	0e 9b       	mov	r11,r7
8000727c:	f0 1f 00 15 	mcall	800072d0 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80007280:	30 09       	mov	r9,0
80007282:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80007284:	fa ca fe f8 	sub	r10,sp,-264
80007288:	fa cb fe f4 	sub	r11,sp,-268
8000728c:	49 28       	lddpc	r8,800072d4 <logFromISR+0x178>
8000728e:	70 0c       	ld.w	r12,r8[0x0]
80007290:	f0 1f 00 12 	mcall	800072d8 <logFromISR+0x17c>
80007294:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80007296:	fe 3d fd f4 	sub	sp,-524
8000729a:	d8 32       	popm	r0-r7,pc
8000729c:	80 00       	ld.sh	r0,r0[0x0]
8000729e:	79 9c       	ld.w	r12,r12[0x64]
800072a0:	00 00       	add	r0,r0
800072a2:	0d 51       	ld.sh	r1,--r6
800072a4:	80 00       	ld.sh	r0,r0[0x0]
800072a6:	db 60       	acall	0xb6
800072a8:	80 00       	ld.sh	r0,r0[0x0]
800072aa:	6e f6       	ld.w	r6,r7[0x3c]
800072ac:	80 00       	ld.sh	r0,r0[0x0]
800072ae:	6e 44       	ld.w	r4,r7[0x10]
800072b0:	80 00       	ld.sh	r0,r0[0x0]
800072b2:	6e 40       	ld.w	r0,r7[0x10]
800072b4:	80 00       	ld.sh	r0,r0[0x0]
800072b6:	dc cc       	*unknown*
800072b8:	80 00       	ld.sh	r0,r0[0x0]
800072ba:	6f d0       	ld.w	r0,r7[0x74]
800072bc:	80 00       	ld.sh	r0,r0[0x0]
800072be:	dc dc       	*unknown*
800072c0:	80 00       	ld.sh	r0,r0[0x0]
800072c2:	7c 8c       	ld.w	r12,lr[0x20]
800072c4:	80 00       	ld.sh	r0,r0[0x0]
800072c6:	dc e4       	*unknown*
800072c8:	80 00       	ld.sh	r0,r0[0x0]
800072ca:	dc ec       	*unknown*
800072cc:	80 00       	ld.sh	r0,r0[0x0]
800072ce:	60 44       	ld.w	r4,r0[0x10]
800072d0:	80 00       	ld.sh	r0,r0[0x0]
800072d2:	78 54       	ld.w	r4,r12[0x14]
800072d4:	00 00       	add	r0,r0
800072d6:	53 b8       	stdsp	sp[0xec],r8
800072d8:	80 00       	ld.sh	r0,r0[0x0]
800072da:	63 48       	ld.w	r8,r1[0x50]

800072dc <log_init>:
		
	return str;
}

void log_init(void)
{
800072dc:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
800072de:	30 2b       	mov	r11,2
800072e0:	48 fc       	lddpc	r12,8000731c <log_init+0x40>
800072e2:	f0 1f 00 10 	mcall	80007320 <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
800072e6:	e0 6a 36 00 	mov	r10,13824
800072ea:	ea 1a 01 6e 	orh	r10,0x16e
800072ee:	48 eb       	lddpc	r11,80007324 <log_init+0x48>
800072f0:	fe 7c 18 00 	mov	r12,-59392
800072f4:	f0 1f 00 0d 	mcall	80007328 <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
800072f8:	30 4b       	mov	r11,4
800072fa:	33 2c       	mov	r12,50
800072fc:	f0 1f 00 0c 	mcall	8000732c <log_init+0x50>
80007300:	48 c8       	lddpc	r8,80007330 <log_init+0x54>
80007302:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80007304:	30 09       	mov	r9,0
80007306:	1a d9       	st.w	--sp,r9
80007308:	1a d9       	st.w	--sp,r9
8000730a:	1a d9       	st.w	--sp,r9
8000730c:	30 28       	mov	r8,2
8000730e:	36 4a       	mov	r10,100
80007310:	48 9b       	lddpc	r11,80007334 <log_init+0x58>
80007312:	48 ac       	lddpc	r12,80007338 <log_init+0x5c>
80007314:	f0 1f 00 0a 	mcall	8000733c <log_init+0x60>
80007318:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
8000731a:	d8 02       	popm	pc
8000731c:	80 00       	ld.sh	r0,r0[0x0]
8000731e:	dc f8       	*unknown*
80007320:	80 00       	ld.sh	r0,r0[0x0]
80007322:	53 b4       	stdsp	sp[0xec],r4
80007324:	80 00       	ld.sh	r0,r0[0x0]
80007326:	dc b0       	acall	0xcb
80007328:	80 00       	ld.sh	r0,r0[0x0]
8000732a:	5b a8       	cp.w	r8,-6
8000732c:	80 00       	ld.sh	r0,r0[0x0]
8000732e:	64 f0       	ld.w	r0,r2[0x3c]
80007330:	00 00       	add	r0,r0
80007332:	53 b8       	stdsp	sp[0xec],r8
80007334:	80 00       	ld.sh	r0,r0[0x0]
80007336:	dc f4       	*unknown*
80007338:	80 00       	ld.sh	r0,r0[0x0]
8000733a:	73 40       	ld.w	r0,r9[0x50]
8000733c:	80 00       	ld.sh	r0,r0[0x0]
8000733e:	6c 0c       	ld.w	r12,r6[0x0]

80007340 <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
80007340:	eb cd 40 f8 	pushm	r3-r7,lr
80007344:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80007346:	48 c7       	lddpc	r7,80007374 <task_log+0x34>
80007348:	30 05       	mov	r5,0
8000734a:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
8000734c:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80007350:	0a 99       	mov	r9,r5
80007352:	08 9a       	mov	r10,r4
80007354:	1a 9b       	mov	r11,sp
80007356:	6e 0c       	ld.w	r12,r7[0x0]
80007358:	f0 1f 00 08 	mcall	80007378 <task_log+0x38>
8000735c:	58 1c       	cp.w	r12,1
8000735e:	cf 91       	brne	80007350 <task_log+0x10>
		{
			if( NULL != str)
80007360:	40 0b       	lddsp	r11,sp[0x0]
80007362:	58 0b       	cp.w	r11,0
80007364:	cf 60       	breq	80007350 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80007366:	06 9c       	mov	r12,r3
80007368:	f0 1f 00 05 	mcall	8000737c <task_log+0x3c>
				vPortFree(str);
8000736c:	40 0c       	lddsp	r12,sp[0x0]
8000736e:	f0 1f 00 05 	mcall	80007380 <task_log+0x40>
80007372:	ce fb       	rjmp	80007350 <task_log+0x10>
80007374:	00 00       	add	r0,r0
80007376:	53 b8       	stdsp	sp[0xec],r8
80007378:	80 00       	ld.sh	r0,r0[0x0]
8000737a:	61 8c       	ld.w	r12,r0[0x60]
8000737c:	80 00       	ld.sh	r0,r0[0x0]
8000737e:	5b 58       	cp.w	r8,-11
80007380:	80 00       	ld.sh	r0,r0[0x0]
80007382:	60 1c       	ld.w	r12,r0[0x4]

80007384 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
80007384:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80007386:	fe 78 10 00 	mov	r8,-61440
8000738a:	30 19       	mov	r9,1
8000738c:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80007390:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80007394:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80007398:	d3 03       	ssrf	0x10
	local_start_pll0();
8000739a:	f0 1f 00 0d 	mcall	800073cc <main+0x48>
		
	INTC_init_interrupts();
8000739e:	f0 1f 00 0d 	mcall	800073d0 <main+0x4c>
		
	log_init();
800073a2:	f0 1f 00 0d 	mcall	800073d4 <main+0x50>
	log("----start debug----");
800073a6:	48 dc       	lddpc	r12,800073d8 <main+0x54>
800073a8:	f0 1f 00 0d 	mcall	800073dc <main+0x58>
	
	xg_flashc_init();
800073ac:	f0 1f 00 0d 	mcall	800073e0 <main+0x5c>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
800073b0:	f0 1f 00 0d 	mcall	800073e4 <main+0x60>
		
	app_init();
800073b4:	f0 1f 00 0d 	mcall	800073e8 <main+0x64>
		
	xcmp_init();
800073b8:	f0 1f 00 0d 	mcall	800073ec <main+0x68>

	local_start_timer();
800073bc:	f0 1f 00 0d 	mcall	800073f0 <main+0x6c>
	
	xg_rtc_init();
800073c0:	f0 1f 00 0d 	mcall	800073f4 <main+0x70>
		
	vTaskStartScheduler();
800073c4:	f0 1f 00 0d 	mcall	800073f8 <main+0x74>
	return 0;
	
}
800073c8:	d8 0a       	popm	pc,r12=0
800073ca:	00 00       	add	r0,r0
800073cc:	80 00       	ld.sh	r0,r0[0x0]
800073ce:	52 28       	stdsp	sp[0x88],r8
800073d0:	80 00       	ld.sh	r0,r0[0x0]
800073d2:	54 b8       	stdsp	sp[0x12c],r8
800073d4:	80 00       	ld.sh	r0,r0[0x0]
800073d6:	72 dc       	ld.w	r12,r9[0x34]
800073d8:	80 00       	ld.sh	r0,r0[0x0]
800073da:	dd 08       	*unknown*
800073dc:	80 00       	ld.sh	r0,r0[0x0]
800073de:	6f d0       	ld.w	r0,r7[0x74]
800073e0:	80 00       	ld.sh	r0,r0[0x0]
800073e2:	52 bc       	stdsp	sp[0xac],r12
800073e4:	80 00       	ld.sh	r0,r0[0x0]
800073e6:	51 88       	stdsp	sp[0x60],r8
800073e8:	80 00       	ld.sh	r0,r0[0x0]
800073ea:	20 3c       	sub	r12,3
800073ec:	80 00       	ld.sh	r0,r0[0x0]
800073ee:	40 a4       	lddsp	r4,sp[0x28]
800073f0:	80 00       	ld.sh	r0,r0[0x0]
800073f2:	51 fc       	stdsp	sp[0x7c],r12
800073f4:	80 00       	ld.sh	r0,r0[0x0]
800073f6:	29 c8       	sub	r8,-100
800073f8:	80 00       	ld.sh	r0,r0[0x0]
800073fa:	6d f4       	ld.w	r4,r6[0x7c]

800073fc <free>:
800073fc:	d4 01       	pushm	lr
800073fe:	e0 68 0a 3c 	mov	r8,2620
80007402:	18 9b       	mov	r11,r12
80007404:	70 0c       	ld.w	r12,r8[0x0]
80007406:	e0 a0 1e 61 	rcall	8000b0c8 <_free_r>
8000740a:	d8 02       	popm	pc

8000740c <malloc>:
8000740c:	d4 01       	pushm	lr
8000740e:	e0 68 0a 3c 	mov	r8,2620
80007412:	18 9b       	mov	r11,r12
80007414:	70 0c       	ld.w	r12,r8[0x0]
80007416:	c0 3c       	rcall	8000741c <_malloc_r>
80007418:	d8 02       	popm	pc
8000741a:	d7 03       	nop

8000741c <_malloc_r>:
8000741c:	d4 31       	pushm	r0-r7,lr
8000741e:	f6 c8 ff f5 	sub	r8,r11,-11
80007422:	18 95       	mov	r5,r12
80007424:	10 97       	mov	r7,r8
80007426:	e0 17 ff f8 	andl	r7,0xfff8
8000742a:	59 68       	cp.w	r8,22
8000742c:	f9 b7 08 10 	movls	r7,16
80007430:	16 37       	cp.w	r7,r11
80007432:	5f 38       	srlo	r8
80007434:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80007438:	c0 50       	breq	80007442 <_malloc_r+0x26>
8000743a:	30 c8       	mov	r8,12
8000743c:	99 38       	st.w	r12[0xc],r8
8000743e:	e0 8f 01 fa 	bral	80007832 <_malloc_r+0x416>
80007442:	fe b0 f5 a3 	rcall	80005f88 <__malloc_lock>
80007446:	e0 47 01 f7 	cp.w	r7,503
8000744a:	e0 8b 00 1d 	brhi	80007484 <_malloc_r+0x68>
8000744e:	ee 03 16 03 	lsr	r3,r7,0x3
80007452:	e0 68 05 3c 	mov	r8,1340
80007456:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000745a:	70 36       	ld.w	r6,r8[0xc]
8000745c:	10 36       	cp.w	r6,r8
8000745e:	c0 61       	brne	8000746a <_malloc_r+0x4e>
80007460:	ec c8 ff f8 	sub	r8,r6,-8
80007464:	70 36       	ld.w	r6,r8[0xc]
80007466:	10 36       	cp.w	r6,r8
80007468:	c0 c0       	breq	80007480 <_malloc_r+0x64>
8000746a:	6c 18       	ld.w	r8,r6[0x4]
8000746c:	e0 18 ff fc 	andl	r8,0xfffc
80007470:	6c 3a       	ld.w	r10,r6[0xc]
80007472:	ec 08 00 09 	add	r9,r6,r8
80007476:	0a 9c       	mov	r12,r5
80007478:	6c 28       	ld.w	r8,r6[0x8]
8000747a:	95 28       	st.w	r10[0x8],r8
8000747c:	91 3a       	st.w	r8[0xc],r10
8000747e:	c4 78       	rjmp	8000750c <_malloc_r+0xf0>
80007480:	2f e3       	sub	r3,-2
80007482:	c4 d8       	rjmp	8000751c <_malloc_r+0x100>
80007484:	ee 03 16 09 	lsr	r3,r7,0x9
80007488:	c0 41       	brne	80007490 <_malloc_r+0x74>
8000748a:	ee 03 16 03 	lsr	r3,r7,0x3
8000748e:	c2 68       	rjmp	800074da <_malloc_r+0xbe>
80007490:	58 43       	cp.w	r3,4
80007492:	e0 8b 00 06 	brhi	8000749e <_malloc_r+0x82>
80007496:	ee 03 16 06 	lsr	r3,r7,0x6
8000749a:	2c 83       	sub	r3,-56
8000749c:	c1 f8       	rjmp	800074da <_malloc_r+0xbe>
8000749e:	59 43       	cp.w	r3,20
800074a0:	e0 8b 00 04 	brhi	800074a8 <_malloc_r+0x8c>
800074a4:	2a 53       	sub	r3,-91
800074a6:	c1 a8       	rjmp	800074da <_malloc_r+0xbe>
800074a8:	e0 43 00 54 	cp.w	r3,84
800074ac:	e0 8b 00 06 	brhi	800074b8 <_malloc_r+0x9c>
800074b0:	ee 03 16 0c 	lsr	r3,r7,0xc
800074b4:	29 23       	sub	r3,-110
800074b6:	c1 28       	rjmp	800074da <_malloc_r+0xbe>
800074b8:	e0 43 01 54 	cp.w	r3,340
800074bc:	e0 8b 00 06 	brhi	800074c8 <_malloc_r+0xac>
800074c0:	ee 03 16 0f 	lsr	r3,r7,0xf
800074c4:	28 93       	sub	r3,-119
800074c6:	c0 a8       	rjmp	800074da <_malloc_r+0xbe>
800074c8:	e0 43 05 54 	cp.w	r3,1364
800074cc:	e0 88 00 04 	brls	800074d4 <_malloc_r+0xb8>
800074d0:	37 e3       	mov	r3,126
800074d2:	c0 48       	rjmp	800074da <_malloc_r+0xbe>
800074d4:	ee 03 16 12 	lsr	r3,r7,0x12
800074d8:	28 43       	sub	r3,-124
800074da:	e0 6a 05 3c 	mov	r10,1340
800074de:	f4 03 00 3a 	add	r10,r10,r3<<0x3
800074e2:	74 36       	ld.w	r6,r10[0xc]
800074e4:	c1 98       	rjmp	80007516 <_malloc_r+0xfa>
800074e6:	6c 19       	ld.w	r9,r6[0x4]
800074e8:	e0 19 ff fc 	andl	r9,0xfffc
800074ec:	f2 07 01 0b 	sub	r11,r9,r7
800074f0:	58 fb       	cp.w	r11,15
800074f2:	e0 8a 00 04 	brle	800074fa <_malloc_r+0xde>
800074f6:	20 13       	sub	r3,1
800074f8:	c1 18       	rjmp	8000751a <_malloc_r+0xfe>
800074fa:	6c 38       	ld.w	r8,r6[0xc]
800074fc:	58 0b       	cp.w	r11,0
800074fe:	c0 b5       	brlt	80007514 <_malloc_r+0xf8>
80007500:	6c 2a       	ld.w	r10,r6[0x8]
80007502:	ec 09 00 09 	add	r9,r6,r9
80007506:	0a 9c       	mov	r12,r5
80007508:	91 2a       	st.w	r8[0x8],r10
8000750a:	95 38       	st.w	r10[0xc],r8
8000750c:	72 18       	ld.w	r8,r9[0x4]
8000750e:	a1 a8       	sbr	r8,0x0
80007510:	93 18       	st.w	r9[0x4],r8
80007512:	cb c8       	rjmp	8000768a <_malloc_r+0x26e>
80007514:	10 96       	mov	r6,r8
80007516:	14 36       	cp.w	r6,r10
80007518:	ce 71       	brne	800074e6 <_malloc_r+0xca>
8000751a:	2f f3       	sub	r3,-1
8000751c:	e0 6a 05 3c 	mov	r10,1340
80007520:	f4 cc ff f8 	sub	r12,r10,-8
80007524:	78 26       	ld.w	r6,r12[0x8]
80007526:	18 36       	cp.w	r6,r12
80007528:	c6 c0       	breq	80007600 <_malloc_r+0x1e4>
8000752a:	6c 19       	ld.w	r9,r6[0x4]
8000752c:	e0 19 ff fc 	andl	r9,0xfffc
80007530:	f2 07 01 08 	sub	r8,r9,r7
80007534:	58 f8       	cp.w	r8,15
80007536:	e0 89 00 8f 	brgt	80007654 <_malloc_r+0x238>
8000753a:	99 3c       	st.w	r12[0xc],r12
8000753c:	99 2c       	st.w	r12[0x8],r12
8000753e:	58 08       	cp.w	r8,0
80007540:	c0 55       	brlt	8000754a <_malloc_r+0x12e>
80007542:	ec 09 00 09 	add	r9,r6,r9
80007546:	0a 9c       	mov	r12,r5
80007548:	ce 2b       	rjmp	8000750c <_malloc_r+0xf0>
8000754a:	e0 49 01 ff 	cp.w	r9,511
8000754e:	e0 8b 00 13 	brhi	80007574 <_malloc_r+0x158>
80007552:	a3 99       	lsr	r9,0x3
80007554:	f4 09 00 38 	add	r8,r10,r9<<0x3
80007558:	70 2b       	ld.w	r11,r8[0x8]
8000755a:	8d 38       	st.w	r6[0xc],r8
8000755c:	8d 2b       	st.w	r6[0x8],r11
8000755e:	97 36       	st.w	r11[0xc],r6
80007560:	91 26       	st.w	r8[0x8],r6
80007562:	a3 49       	asr	r9,0x2
80007564:	74 18       	ld.w	r8,r10[0x4]
80007566:	30 1b       	mov	r11,1
80007568:	f6 09 09 49 	lsl	r9,r11,r9
8000756c:	f1 e9 10 09 	or	r9,r8,r9
80007570:	95 19       	st.w	r10[0x4],r9
80007572:	c4 78       	rjmp	80007600 <_malloc_r+0x1e4>
80007574:	f2 0a 16 09 	lsr	r10,r9,0x9
80007578:	58 4a       	cp.w	r10,4
8000757a:	e0 8b 00 07 	brhi	80007588 <_malloc_r+0x16c>
8000757e:	f2 0a 16 06 	lsr	r10,r9,0x6
80007582:	2c 8a       	sub	r10,-56
80007584:	c2 08       	rjmp	800075c4 <_malloc_r+0x1a8>
80007586:	d7 03       	nop
80007588:	59 4a       	cp.w	r10,20
8000758a:	e0 8b 00 04 	brhi	80007592 <_malloc_r+0x176>
8000758e:	2a 5a       	sub	r10,-91
80007590:	c1 a8       	rjmp	800075c4 <_malloc_r+0x1a8>
80007592:	e0 4a 00 54 	cp.w	r10,84
80007596:	e0 8b 00 06 	brhi	800075a2 <_malloc_r+0x186>
8000759a:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000759e:	29 2a       	sub	r10,-110
800075a0:	c1 28       	rjmp	800075c4 <_malloc_r+0x1a8>
800075a2:	e0 4a 01 54 	cp.w	r10,340
800075a6:	e0 8b 00 06 	brhi	800075b2 <_malloc_r+0x196>
800075aa:	f2 0a 16 0f 	lsr	r10,r9,0xf
800075ae:	28 9a       	sub	r10,-119
800075b0:	c0 a8       	rjmp	800075c4 <_malloc_r+0x1a8>
800075b2:	e0 4a 05 54 	cp.w	r10,1364
800075b6:	e0 88 00 04 	brls	800075be <_malloc_r+0x1a2>
800075ba:	37 ea       	mov	r10,126
800075bc:	c0 48       	rjmp	800075c4 <_malloc_r+0x1a8>
800075be:	f2 0a 16 12 	lsr	r10,r9,0x12
800075c2:	28 4a       	sub	r10,-124
800075c4:	e0 6b 05 3c 	mov	r11,1340
800075c8:	f6 0a 00 34 	add	r4,r11,r10<<0x3
800075cc:	68 28       	ld.w	r8,r4[0x8]
800075ce:	08 38       	cp.w	r8,r4
800075d0:	c0 e1       	brne	800075ec <_malloc_r+0x1d0>
800075d2:	76 19       	ld.w	r9,r11[0x4]
800075d4:	a3 4a       	asr	r10,0x2
800075d6:	30 1e       	mov	lr,1
800075d8:	fc 0a 09 4a 	lsl	r10,lr,r10
800075dc:	f3 ea 10 0a 	or	r10,r9,r10
800075e0:	10 99       	mov	r9,r8
800075e2:	97 1a       	st.w	r11[0x4],r10
800075e4:	c0 a8       	rjmp	800075f8 <_malloc_r+0x1dc>
800075e6:	70 28       	ld.w	r8,r8[0x8]
800075e8:	08 38       	cp.w	r8,r4
800075ea:	c0 60       	breq	800075f6 <_malloc_r+0x1da>
800075ec:	70 1a       	ld.w	r10,r8[0x4]
800075ee:	e0 1a ff fc 	andl	r10,0xfffc
800075f2:	14 39       	cp.w	r9,r10
800075f4:	cf 93       	brcs	800075e6 <_malloc_r+0x1ca>
800075f6:	70 39       	ld.w	r9,r8[0xc]
800075f8:	8d 39       	st.w	r6[0xc],r9
800075fa:	8d 28       	st.w	r6[0x8],r8
800075fc:	91 36       	st.w	r8[0xc],r6
800075fe:	93 26       	st.w	r9[0x8],r6
80007600:	e6 08 14 02 	asr	r8,r3,0x2
80007604:	30 1b       	mov	r11,1
80007606:	e0 64 05 3c 	mov	r4,1340
8000760a:	f6 08 09 4b 	lsl	r11,r11,r8
8000760e:	68 18       	ld.w	r8,r4[0x4]
80007610:	10 3b       	cp.w	r11,r8
80007612:	e0 8b 00 6b 	brhi	800076e8 <_malloc_r+0x2cc>
80007616:	f7 e8 00 09 	and	r9,r11,r8
8000761a:	c0 b1       	brne	80007630 <_malloc_r+0x214>
8000761c:	e0 13 ff fc 	andl	r3,0xfffc
80007620:	a1 7b       	lsl	r11,0x1
80007622:	2f c3       	sub	r3,-4
80007624:	c0 38       	rjmp	8000762a <_malloc_r+0x20e>
80007626:	2f c3       	sub	r3,-4
80007628:	a1 7b       	lsl	r11,0x1
8000762a:	f7 e8 00 09 	and	r9,r11,r8
8000762e:	cf c0       	breq	80007626 <_malloc_r+0x20a>
80007630:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80007634:	06 92       	mov	r2,r3
80007636:	1c 91       	mov	r1,lr
80007638:	62 36       	ld.w	r6,r1[0xc]
8000763a:	c2 e8       	rjmp	80007696 <_malloc_r+0x27a>
8000763c:	6c 1a       	ld.w	r10,r6[0x4]
8000763e:	e0 1a ff fc 	andl	r10,0xfffc
80007642:	f4 07 01 08 	sub	r8,r10,r7
80007646:	58 f8       	cp.w	r8,15
80007648:	e0 8a 00 15 	brle	80007672 <_malloc_r+0x256>
8000764c:	6c 3a       	ld.w	r10,r6[0xc]
8000764e:	6c 29       	ld.w	r9,r6[0x8]
80007650:	95 29       	st.w	r10[0x8],r9
80007652:	93 3a       	st.w	r9[0xc],r10
80007654:	0e 99       	mov	r9,r7
80007656:	ec 07 00 07 	add	r7,r6,r7
8000765a:	a1 a9       	sbr	r9,0x0
8000765c:	99 37       	st.w	r12[0xc],r7
8000765e:	99 27       	st.w	r12[0x8],r7
80007660:	8d 19       	st.w	r6[0x4],r9
80007662:	ee 08 09 08 	st.w	r7[r8],r8
80007666:	8f 2c       	st.w	r7[0x8],r12
80007668:	8f 3c       	st.w	r7[0xc],r12
8000766a:	a1 a8       	sbr	r8,0x0
8000766c:	0a 9c       	mov	r12,r5
8000766e:	8f 18       	st.w	r7[0x4],r8
80007670:	c0 d8       	rjmp	8000768a <_malloc_r+0x26e>
80007672:	6c 39       	ld.w	r9,r6[0xc]
80007674:	58 08       	cp.w	r8,0
80007676:	c0 f5       	brlt	80007694 <_malloc_r+0x278>
80007678:	ec 0a 00 0a 	add	r10,r6,r10
8000767c:	74 18       	ld.w	r8,r10[0x4]
8000767e:	a1 a8       	sbr	r8,0x0
80007680:	0a 9c       	mov	r12,r5
80007682:	95 18       	st.w	r10[0x4],r8
80007684:	6c 28       	ld.w	r8,r6[0x8]
80007686:	93 28       	st.w	r9[0x8],r8
80007688:	91 39       	st.w	r8[0xc],r9
8000768a:	fe b0 f4 85 	rcall	80005f94 <__malloc_unlock>
8000768e:	ec cc ff f8 	sub	r12,r6,-8
80007692:	d8 32       	popm	r0-r7,pc
80007694:	12 96       	mov	r6,r9
80007696:	02 36       	cp.w	r6,r1
80007698:	cd 21       	brne	8000763c <_malloc_r+0x220>
8000769a:	2f f2       	sub	r2,-1
8000769c:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800076a0:	c0 30       	breq	800076a6 <_malloc_r+0x28a>
800076a2:	2f 81       	sub	r1,-8
800076a4:	cc ab       	rjmp	80007638 <_malloc_r+0x21c>
800076a6:	1c 98       	mov	r8,lr
800076a8:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
800076ac:	c0 81       	brne	800076bc <_malloc_r+0x2a0>
800076ae:	68 19       	ld.w	r9,r4[0x4]
800076b0:	f6 08 11 ff 	rsub	r8,r11,-1
800076b4:	f3 e8 00 08 	and	r8,r9,r8
800076b8:	89 18       	st.w	r4[0x4],r8
800076ba:	c0 78       	rjmp	800076c8 <_malloc_r+0x2ac>
800076bc:	f0 c9 00 08 	sub	r9,r8,8
800076c0:	20 13       	sub	r3,1
800076c2:	70 08       	ld.w	r8,r8[0x0]
800076c4:	12 38       	cp.w	r8,r9
800076c6:	cf 10       	breq	800076a8 <_malloc_r+0x28c>
800076c8:	a1 7b       	lsl	r11,0x1
800076ca:	68 18       	ld.w	r8,r4[0x4]
800076cc:	10 3b       	cp.w	r11,r8
800076ce:	e0 8b 00 0d 	brhi	800076e8 <_malloc_r+0x2cc>
800076d2:	58 0b       	cp.w	r11,0
800076d4:	c0 a0       	breq	800076e8 <_malloc_r+0x2cc>
800076d6:	04 93       	mov	r3,r2
800076d8:	c0 38       	rjmp	800076de <_malloc_r+0x2c2>
800076da:	2f c3       	sub	r3,-4
800076dc:	a1 7b       	lsl	r11,0x1
800076de:	f7 e8 00 09 	and	r9,r11,r8
800076e2:	ca 71       	brne	80007630 <_malloc_r+0x214>
800076e4:	cf bb       	rjmp	800076da <_malloc_r+0x2be>
800076e6:	d7 03       	nop
800076e8:	68 23       	ld.w	r3,r4[0x8]
800076ea:	66 12       	ld.w	r2,r3[0x4]
800076ec:	e0 12 ff fc 	andl	r2,0xfffc
800076f0:	0e 32       	cp.w	r2,r7
800076f2:	5f 39       	srlo	r9
800076f4:	e4 07 01 08 	sub	r8,r2,r7
800076f8:	58 f8       	cp.w	r8,15
800076fa:	5f aa       	srle	r10
800076fc:	f5 e9 10 09 	or	r9,r10,r9
80007700:	e0 80 00 9a 	breq	80007834 <_malloc_r+0x418>
80007704:	e0 68 0d 5c 	mov	r8,3420
80007708:	70 01       	ld.w	r1,r8[0x0]
8000770a:	e0 68 09 48 	mov	r8,2376
8000770e:	2f 01       	sub	r1,-16
80007710:	70 08       	ld.w	r8,r8[0x0]
80007712:	0e 01       	add	r1,r7
80007714:	5b f8       	cp.w	r8,-1
80007716:	c0 40       	breq	8000771e <_malloc_r+0x302>
80007718:	28 11       	sub	r1,-127
8000771a:	e0 11 ff 80 	andl	r1,0xff80
8000771e:	02 9b       	mov	r11,r1
80007720:	0a 9c       	mov	r12,r5
80007722:	e0 a0 02 a5 	rcall	80007c6c <_sbrk_r>
80007726:	18 96       	mov	r6,r12
80007728:	5b fc       	cp.w	r12,-1
8000772a:	c7 50       	breq	80007814 <_malloc_r+0x3f8>
8000772c:	e6 02 00 08 	add	r8,r3,r2
80007730:	10 3c       	cp.w	r12,r8
80007732:	c0 32       	brcc	80007738 <_malloc_r+0x31c>
80007734:	08 33       	cp.w	r3,r4
80007736:	c6 f1       	brne	80007814 <_malloc_r+0x3f8>
80007738:	e0 6a 0d 60 	mov	r10,3424
8000773c:	74 09       	ld.w	r9,r10[0x0]
8000773e:	e2 09 00 09 	add	r9,r1,r9
80007742:	95 09       	st.w	r10[0x0],r9
80007744:	10 36       	cp.w	r6,r8
80007746:	c0 a1       	brne	8000775a <_malloc_r+0x33e>
80007748:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000774c:	c0 71       	brne	8000775a <_malloc_r+0x33e>
8000774e:	e2 02 00 02 	add	r2,r1,r2
80007752:	68 28       	ld.w	r8,r4[0x8]
80007754:	a1 a2       	sbr	r2,0x0
80007756:	91 12       	st.w	r8[0x4],r2
80007758:	c4 f8       	rjmp	800077f6 <_malloc_r+0x3da>
8000775a:	e0 6a 09 48 	mov	r10,2376
8000775e:	74 0b       	ld.w	r11,r10[0x0]
80007760:	5b fb       	cp.w	r11,-1
80007762:	c0 31       	brne	80007768 <_malloc_r+0x34c>
80007764:	95 06       	st.w	r10[0x0],r6
80007766:	c0 78       	rjmp	80007774 <_malloc_r+0x358>
80007768:	ec 09 00 09 	add	r9,r6,r9
8000776c:	e0 6a 0d 60 	mov	r10,3424
80007770:	10 19       	sub	r9,r8
80007772:	95 09       	st.w	r10[0x0],r9
80007774:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80007778:	f0 09 11 08 	rsub	r9,r8,8
8000777c:	58 08       	cp.w	r8,0
8000777e:	f2 08 17 10 	movne	r8,r9
80007782:	ed d8 e1 06 	addne	r6,r6,r8
80007786:	28 08       	sub	r8,-128
80007788:	ec 01 00 01 	add	r1,r6,r1
8000778c:	0a 9c       	mov	r12,r5
8000778e:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80007792:	f0 01 01 01 	sub	r1,r8,r1
80007796:	02 9b       	mov	r11,r1
80007798:	e0 a0 02 6a 	rcall	80007c6c <_sbrk_r>
8000779c:	e0 68 0d 60 	mov	r8,3424
800077a0:	5b fc       	cp.w	r12,-1
800077a2:	ec 0c 17 00 	moveq	r12,r6
800077a6:	f9 b1 00 00 	moveq	r1,0
800077aa:	70 09       	ld.w	r9,r8[0x0]
800077ac:	0c 1c       	sub	r12,r6
800077ae:	89 26       	st.w	r4[0x8],r6
800077b0:	02 0c       	add	r12,r1
800077b2:	12 01       	add	r1,r9
800077b4:	a1 ac       	sbr	r12,0x0
800077b6:	91 01       	st.w	r8[0x0],r1
800077b8:	8d 1c       	st.w	r6[0x4],r12
800077ba:	08 33       	cp.w	r3,r4
800077bc:	c1 d0       	breq	800077f6 <_malloc_r+0x3da>
800077be:	58 f2       	cp.w	r2,15
800077c0:	e0 8b 00 05 	brhi	800077ca <_malloc_r+0x3ae>
800077c4:	30 18       	mov	r8,1
800077c6:	8d 18       	st.w	r6[0x4],r8
800077c8:	c2 68       	rjmp	80007814 <_malloc_r+0x3f8>
800077ca:	30 59       	mov	r9,5
800077cc:	20 c2       	sub	r2,12
800077ce:	e0 12 ff f8 	andl	r2,0xfff8
800077d2:	e6 02 00 08 	add	r8,r3,r2
800077d6:	91 29       	st.w	r8[0x8],r9
800077d8:	91 19       	st.w	r8[0x4],r9
800077da:	66 18       	ld.w	r8,r3[0x4]
800077dc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800077e0:	e5 e8 10 08 	or	r8,r2,r8
800077e4:	87 18       	st.w	r3[0x4],r8
800077e6:	58 f2       	cp.w	r2,15
800077e8:	e0 88 00 07 	brls	800077f6 <_malloc_r+0x3da>
800077ec:	e6 cb ff f8 	sub	r11,r3,-8
800077f0:	0a 9c       	mov	r12,r5
800077f2:	e0 a0 1c 6b 	rcall	8000b0c8 <_free_r>
800077f6:	e0 69 0d 58 	mov	r9,3416
800077fa:	72 0a       	ld.w	r10,r9[0x0]
800077fc:	e0 68 0d 60 	mov	r8,3424
80007800:	70 08       	ld.w	r8,r8[0x0]
80007802:	14 38       	cp.w	r8,r10
80007804:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007808:	e0 69 0d 54 	mov	r9,3412
8000780c:	72 0a       	ld.w	r10,r9[0x0]
8000780e:	14 38       	cp.w	r8,r10
80007810:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007814:	68 28       	ld.w	r8,r4[0x8]
80007816:	70 18       	ld.w	r8,r8[0x4]
80007818:	e0 18 ff fc 	andl	r8,0xfffc
8000781c:	0e 38       	cp.w	r8,r7
8000781e:	5f 39       	srlo	r9
80007820:	0e 18       	sub	r8,r7
80007822:	58 f8       	cp.w	r8,15
80007824:	5f aa       	srle	r10
80007826:	f5 e9 10 09 	or	r9,r10,r9
8000782a:	c0 50       	breq	80007834 <_malloc_r+0x418>
8000782c:	0a 9c       	mov	r12,r5
8000782e:	fe b0 f3 b3 	rcall	80005f94 <__malloc_unlock>
80007832:	d8 3a       	popm	r0-r7,pc,r12=0
80007834:	68 26       	ld.w	r6,r4[0x8]
80007836:	a1 a8       	sbr	r8,0x0
80007838:	0e 99       	mov	r9,r7
8000783a:	a1 a9       	sbr	r9,0x0
8000783c:	8d 19       	st.w	r6[0x4],r9
8000783e:	ec 07 00 07 	add	r7,r6,r7
80007842:	0a 9c       	mov	r12,r5
80007844:	89 27       	st.w	r4[0x8],r7
80007846:	8f 18       	st.w	r7[0x4],r8
80007848:	fe b0 f3 a6 	rcall	80005f94 <__malloc_unlock>
8000784c:	ec cc ff f8 	sub	r12,r6,-8
80007850:	d8 32       	popm	r0-r7,pc
80007852:	d7 03       	nop

80007854 <memcpy>:
80007854:	58 8a       	cp.w	r10,8
80007856:	c2 f5       	brlt	800078b4 <memcpy+0x60>
80007858:	f9 eb 10 09 	or	r9,r12,r11
8000785c:	e2 19 00 03 	andl	r9,0x3,COH
80007860:	e0 81 00 97 	brne	8000798e <memcpy+0x13a>
80007864:	e0 4a 00 20 	cp.w	r10,32
80007868:	c3 b4       	brge	800078de <memcpy+0x8a>
8000786a:	f4 08 14 02 	asr	r8,r10,0x2
8000786e:	f0 09 11 08 	rsub	r9,r8,8
80007872:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80007876:	76 69       	ld.w	r9,r11[0x18]
80007878:	99 69       	st.w	r12[0x18],r9
8000787a:	76 59       	ld.w	r9,r11[0x14]
8000787c:	99 59       	st.w	r12[0x14],r9
8000787e:	76 49       	ld.w	r9,r11[0x10]
80007880:	99 49       	st.w	r12[0x10],r9
80007882:	76 39       	ld.w	r9,r11[0xc]
80007884:	99 39       	st.w	r12[0xc],r9
80007886:	76 29       	ld.w	r9,r11[0x8]
80007888:	99 29       	st.w	r12[0x8],r9
8000788a:	76 19       	ld.w	r9,r11[0x4]
8000788c:	99 19       	st.w	r12[0x4],r9
8000788e:	76 09       	ld.w	r9,r11[0x0]
80007890:	99 09       	st.w	r12[0x0],r9
80007892:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80007896:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000789a:	e0 1a 00 03 	andl	r10,0x3
8000789e:	f4 0a 11 04 	rsub	r10,r10,4
800078a2:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800078a6:	17 a9       	ld.ub	r9,r11[0x2]
800078a8:	b0 a9       	st.b	r8[0x2],r9
800078aa:	17 99       	ld.ub	r9,r11[0x1]
800078ac:	b0 99       	st.b	r8[0x1],r9
800078ae:	17 89       	ld.ub	r9,r11[0x0]
800078b0:	b0 89       	st.b	r8[0x0],r9
800078b2:	5e fc       	retal	r12
800078b4:	f4 0a 11 09 	rsub	r10,r10,9
800078b8:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800078bc:	17 f9       	ld.ub	r9,r11[0x7]
800078be:	b8 f9       	st.b	r12[0x7],r9
800078c0:	17 e9       	ld.ub	r9,r11[0x6]
800078c2:	b8 e9       	st.b	r12[0x6],r9
800078c4:	17 d9       	ld.ub	r9,r11[0x5]
800078c6:	b8 d9       	st.b	r12[0x5],r9
800078c8:	17 c9       	ld.ub	r9,r11[0x4]
800078ca:	b8 c9       	st.b	r12[0x4],r9
800078cc:	17 b9       	ld.ub	r9,r11[0x3]
800078ce:	b8 b9       	st.b	r12[0x3],r9
800078d0:	17 a9       	ld.ub	r9,r11[0x2]
800078d2:	b8 a9       	st.b	r12[0x2],r9
800078d4:	17 99       	ld.ub	r9,r11[0x1]
800078d6:	b8 99       	st.b	r12[0x1],r9
800078d8:	17 89       	ld.ub	r9,r11[0x0]
800078da:	b8 89       	st.b	r12[0x0],r9
800078dc:	5e fc       	retal	r12
800078de:	eb cd 40 c0 	pushm	r6-r7,lr
800078e2:	18 99       	mov	r9,r12
800078e4:	22 0a       	sub	r10,32
800078e6:	b7 07       	ld.d	r6,r11++
800078e8:	b3 26       	st.d	r9++,r6
800078ea:	b7 07       	ld.d	r6,r11++
800078ec:	b3 26       	st.d	r9++,r6
800078ee:	b7 07       	ld.d	r6,r11++
800078f0:	b3 26       	st.d	r9++,r6
800078f2:	b7 07       	ld.d	r6,r11++
800078f4:	b3 26       	st.d	r9++,r6
800078f6:	22 0a       	sub	r10,32
800078f8:	cf 74       	brge	800078e6 <memcpy+0x92>
800078fa:	2f 0a       	sub	r10,-16
800078fc:	c0 65       	brlt	80007908 <memcpy+0xb4>
800078fe:	b7 07       	ld.d	r6,r11++
80007900:	b3 26       	st.d	r9++,r6
80007902:	b7 07       	ld.d	r6,r11++
80007904:	b3 26       	st.d	r9++,r6
80007906:	21 0a       	sub	r10,16
80007908:	5c 3a       	neg	r10
8000790a:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000790e:	d7 03       	nop
80007910:	d7 03       	nop
80007912:	f7 36 00 0e 	ld.ub	r6,r11[14]
80007916:	f3 66 00 0e 	st.b	r9[14],r6
8000791a:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000791e:	f3 66 00 0d 	st.b	r9[13],r6
80007922:	f7 36 00 0c 	ld.ub	r6,r11[12]
80007926:	f3 66 00 0c 	st.b	r9[12],r6
8000792a:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000792e:	f3 66 00 0b 	st.b	r9[11],r6
80007932:	f7 36 00 0a 	ld.ub	r6,r11[10]
80007936:	f3 66 00 0a 	st.b	r9[10],r6
8000793a:	f7 36 00 09 	ld.ub	r6,r11[9]
8000793e:	f3 66 00 09 	st.b	r9[9],r6
80007942:	f7 36 00 08 	ld.ub	r6,r11[8]
80007946:	f3 66 00 08 	st.b	r9[8],r6
8000794a:	f7 36 00 07 	ld.ub	r6,r11[7]
8000794e:	f3 66 00 07 	st.b	r9[7],r6
80007952:	f7 36 00 06 	ld.ub	r6,r11[6]
80007956:	f3 66 00 06 	st.b	r9[6],r6
8000795a:	f7 36 00 05 	ld.ub	r6,r11[5]
8000795e:	f3 66 00 05 	st.b	r9[5],r6
80007962:	f7 36 00 04 	ld.ub	r6,r11[4]
80007966:	f3 66 00 04 	st.b	r9[4],r6
8000796a:	f7 36 00 03 	ld.ub	r6,r11[3]
8000796e:	f3 66 00 03 	st.b	r9[3],r6
80007972:	f7 36 00 02 	ld.ub	r6,r11[2]
80007976:	f3 66 00 02 	st.b	r9[2],r6
8000797a:	f7 36 00 01 	ld.ub	r6,r11[1]
8000797e:	f3 66 00 01 	st.b	r9[1],r6
80007982:	f7 36 00 00 	ld.ub	r6,r11[0]
80007986:	f3 66 00 00 	st.b	r9[0],r6
8000798a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000798e:	20 1a       	sub	r10,1
80007990:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80007994:	f8 0a 0b 09 	st.b	r12[r10],r9
80007998:	cf b1       	brne	8000798e <memcpy+0x13a>
8000799a:	5e fc       	retal	r12

8000799c <memset>:
8000799c:	18 98       	mov	r8,r12
8000799e:	c0 38       	rjmp	800079a4 <memset+0x8>
800079a0:	10 cb       	st.b	r8++,r11
800079a2:	20 1a       	sub	r10,1
800079a4:	58 0a       	cp.w	r10,0
800079a6:	cf d1       	brne	800079a0 <memset+0x4>
800079a8:	5e fc       	retal	r12
800079aa:	d7 03       	nop

800079ac <_realloc_r>:
800079ac:	d4 31       	pushm	r0-r7,lr
800079ae:	20 1d       	sub	sp,4
800079b0:	16 94       	mov	r4,r11
800079b2:	18 92       	mov	r2,r12
800079b4:	14 9b       	mov	r11,r10
800079b6:	58 04       	cp.w	r4,0
800079b8:	c0 51       	brne	800079c2 <_realloc_r+0x16>
800079ba:	fe b0 fd 31 	rcall	8000741c <_malloc_r>
800079be:	18 95       	mov	r5,r12
800079c0:	c5 39       	rjmp	80007c66 <_realloc_r+0x2ba>
800079c2:	50 0a       	stdsp	sp[0x0],r10
800079c4:	fe b0 f2 e2 	rcall	80005f88 <__malloc_lock>
800079c8:	40 0b       	lddsp	r11,sp[0x0]
800079ca:	f6 c8 ff f5 	sub	r8,r11,-11
800079ce:	e8 c1 00 08 	sub	r1,r4,8
800079d2:	10 96       	mov	r6,r8
800079d4:	62 1c       	ld.w	r12,r1[0x4]
800079d6:	e0 16 ff f8 	andl	r6,0xfff8
800079da:	59 68       	cp.w	r8,22
800079dc:	f9 b6 08 10 	movls	r6,16
800079e0:	16 36       	cp.w	r6,r11
800079e2:	5f 38       	srlo	r8
800079e4:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
800079e8:	c0 50       	breq	800079f2 <_realloc_r+0x46>
800079ea:	30 c8       	mov	r8,12
800079ec:	30 05       	mov	r5,0
800079ee:	85 38       	st.w	r2[0xc],r8
800079f0:	c3 b9       	rjmp	80007c66 <_realloc_r+0x2ba>
800079f2:	18 90       	mov	r0,r12
800079f4:	e0 10 ff fc 	andl	r0,0xfffc
800079f8:	0c 30       	cp.w	r0,r6
800079fa:	e0 84 01 0b 	brge	80007c10 <_realloc_r+0x264>
800079fe:	e0 68 05 3c 	mov	r8,1340
80007a02:	e2 00 00 09 	add	r9,r1,r0
80007a06:	70 25       	ld.w	r5,r8[0x8]
80007a08:	0a 39       	cp.w	r9,r5
80007a0a:	c0 90       	breq	80007a1c <_realloc_r+0x70>
80007a0c:	72 1a       	ld.w	r10,r9[0x4]
80007a0e:	a1 ca       	cbr	r10,0x0
80007a10:	f2 0a 00 0a 	add	r10,r9,r10
80007a14:	74 1a       	ld.w	r10,r10[0x4]
80007a16:	ed ba 00 00 	bld	r10,0x0
80007a1a:	c2 20       	breq	80007a5e <_realloc_r+0xb2>
80007a1c:	72 1a       	ld.w	r10,r9[0x4]
80007a1e:	e0 1a ff fc 	andl	r10,0xfffc
80007a22:	f4 00 00 03 	add	r3,r10,r0
80007a26:	0a 39       	cp.w	r9,r5
80007a28:	c1 31       	brne	80007a4e <_realloc_r+0xa2>
80007a2a:	ec c7 ff f0 	sub	r7,r6,-16
80007a2e:	0e 33       	cp.w	r3,r7
80007a30:	c1 95       	brlt	80007a62 <_realloc_r+0xb6>
80007a32:	e2 06 00 09 	add	r9,r1,r6
80007a36:	0c 13       	sub	r3,r6
80007a38:	a1 a3       	sbr	r3,0x0
80007a3a:	93 13       	st.w	r9[0x4],r3
80007a3c:	91 29       	st.w	r8[0x8],r9
80007a3e:	04 9c       	mov	r12,r2
80007a40:	62 18       	ld.w	r8,r1[0x4]
80007a42:	08 95       	mov	r5,r4
80007a44:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007a48:	10 46       	or	r6,r8
80007a4a:	83 16       	st.w	r1[0x4],r6
80007a4c:	c0 b9       	rjmp	80007c62 <_realloc_r+0x2b6>
80007a4e:	0c 33       	cp.w	r3,r6
80007a50:	c0 95       	brlt	80007a62 <_realloc_r+0xb6>
80007a52:	72 28       	ld.w	r8,r9[0x8]
80007a54:	02 97       	mov	r7,r1
80007a56:	72 39       	ld.w	r9,r9[0xc]
80007a58:	93 28       	st.w	r9[0x8],r8
80007a5a:	91 39       	st.w	r8[0xc],r9
80007a5c:	cd c8       	rjmp	80007c14 <_realloc_r+0x268>
80007a5e:	30 0a       	mov	r10,0
80007a60:	14 99       	mov	r9,r10
80007a62:	ed bc 00 00 	bld	r12,0x0
80007a66:	e0 80 00 95 	breq	80007b90 <_realloc_r+0x1e4>
80007a6a:	62 07       	ld.w	r7,r1[0x0]
80007a6c:	e2 07 01 07 	sub	r7,r1,r7
80007a70:	6e 1c       	ld.w	r12,r7[0x4]
80007a72:	e0 1c ff fc 	andl	r12,0xfffc
80007a76:	58 09       	cp.w	r9,0
80007a78:	c5 60       	breq	80007b24 <_realloc_r+0x178>
80007a7a:	f8 00 00 03 	add	r3,r12,r0
80007a7e:	0a 39       	cp.w	r9,r5
80007a80:	c4 81       	brne	80007b10 <_realloc_r+0x164>
80007a82:	14 03       	add	r3,r10
80007a84:	ec c9 ff f0 	sub	r9,r6,-16
80007a88:	12 33       	cp.w	r3,r9
80007a8a:	c4 d5       	brlt	80007b24 <_realloc_r+0x178>
80007a8c:	6e 3a       	ld.w	r10,r7[0xc]
80007a8e:	6e 29       	ld.w	r9,r7[0x8]
80007a90:	95 29       	st.w	r10[0x8],r9
80007a92:	93 3a       	st.w	r9[0xc],r10
80007a94:	ee c5 ff f8 	sub	r5,r7,-8
80007a98:	e0 ca 00 04 	sub	r10,r0,4
80007a9c:	e0 4a 00 24 	cp.w	r10,36
80007aa0:	e0 8b 00 25 	brhi	80007aea <_realloc_r+0x13e>
80007aa4:	0a 99       	mov	r9,r5
80007aa6:	59 3a       	cp.w	r10,19
80007aa8:	e0 88 00 1a 	brls	80007adc <_realloc_r+0x130>
80007aac:	09 09       	ld.w	r9,r4++
80007aae:	8b 09       	st.w	r5[0x0],r9
80007ab0:	09 09       	ld.w	r9,r4++
80007ab2:	8f 39       	st.w	r7[0xc],r9
80007ab4:	ee c9 ff f0 	sub	r9,r7,-16
80007ab8:	59 ba       	cp.w	r10,27
80007aba:	e0 88 00 11 	brls	80007adc <_realloc_r+0x130>
80007abe:	09 0b       	ld.w	r11,r4++
80007ac0:	93 0b       	st.w	r9[0x0],r11
80007ac2:	09 09       	ld.w	r9,r4++
80007ac4:	8f 59       	st.w	r7[0x14],r9
80007ac6:	ee c9 ff e8 	sub	r9,r7,-24
80007aca:	e0 4a 00 24 	cp.w	r10,36
80007ace:	c0 71       	brne	80007adc <_realloc_r+0x130>
80007ad0:	09 0a       	ld.w	r10,r4++
80007ad2:	93 0a       	st.w	r9[0x0],r10
80007ad4:	ee c9 ff e0 	sub	r9,r7,-32
80007ad8:	09 0a       	ld.w	r10,r4++
80007ada:	8f 7a       	st.w	r7[0x1c],r10
80007adc:	09 0a       	ld.w	r10,r4++
80007ade:	12 aa       	st.w	r9++,r10
80007ae0:	68 0a       	ld.w	r10,r4[0x0]
80007ae2:	93 0a       	st.w	r9[0x0],r10
80007ae4:	68 1a       	ld.w	r10,r4[0x4]
80007ae6:	93 1a       	st.w	r9[0x4],r10
80007ae8:	c0 78       	rjmp	80007af6 <_realloc_r+0x14a>
80007aea:	50 08       	stdsp	sp[0x0],r8
80007aec:	08 9b       	mov	r11,r4
80007aee:	0a 9c       	mov	r12,r5
80007af0:	e0 a0 1d 8f 	rcall	8000b60e <memmove>
80007af4:	40 08       	lddsp	r8,sp[0x0]
80007af6:	ee 06 00 09 	add	r9,r7,r6
80007afa:	0c 13       	sub	r3,r6
80007afc:	a1 a3       	sbr	r3,0x0
80007afe:	93 13       	st.w	r9[0x4],r3
80007b00:	91 29       	st.w	r8[0x8],r9
80007b02:	04 9c       	mov	r12,r2
80007b04:	6e 18       	ld.w	r8,r7[0x4]
80007b06:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007b0a:	10 46       	or	r6,r8
80007b0c:	8f 16       	st.w	r7[0x4],r6
80007b0e:	ca a8       	rjmp	80007c62 <_realloc_r+0x2b6>
80007b10:	14 03       	add	r3,r10
80007b12:	0c 33       	cp.w	r3,r6
80007b14:	c0 85       	brlt	80007b24 <_realloc_r+0x178>
80007b16:	72 28       	ld.w	r8,r9[0x8]
80007b18:	72 39       	ld.w	r9,r9[0xc]
80007b1a:	93 28       	st.w	r9[0x8],r8
80007b1c:	91 39       	st.w	r8[0xc],r9
80007b1e:	6e 28       	ld.w	r8,r7[0x8]
80007b20:	6e 39       	ld.w	r9,r7[0xc]
80007b22:	c0 78       	rjmp	80007b30 <_realloc_r+0x184>
80007b24:	f8 00 00 03 	add	r3,r12,r0
80007b28:	0c 33       	cp.w	r3,r6
80007b2a:	c3 35       	brlt	80007b90 <_realloc_r+0x1e4>
80007b2c:	6e 39       	ld.w	r9,r7[0xc]
80007b2e:	6e 28       	ld.w	r8,r7[0x8]
80007b30:	93 28       	st.w	r9[0x8],r8
80007b32:	91 39       	st.w	r8[0xc],r9
80007b34:	e0 ca 00 04 	sub	r10,r0,4
80007b38:	ee cc ff f8 	sub	r12,r7,-8
80007b3c:	e0 4a 00 24 	cp.w	r10,36
80007b40:	e0 8b 00 24 	brhi	80007b88 <_realloc_r+0x1dc>
80007b44:	59 3a       	cp.w	r10,19
80007b46:	e0 88 00 1a 	brls	80007b7a <_realloc_r+0x1ce>
80007b4a:	09 08       	ld.w	r8,r4++
80007b4c:	99 08       	st.w	r12[0x0],r8
80007b4e:	09 08       	ld.w	r8,r4++
80007b50:	8f 38       	st.w	r7[0xc],r8
80007b52:	ee cc ff f0 	sub	r12,r7,-16
80007b56:	59 ba       	cp.w	r10,27
80007b58:	e0 88 00 11 	brls	80007b7a <_realloc_r+0x1ce>
80007b5c:	09 08       	ld.w	r8,r4++
80007b5e:	99 08       	st.w	r12[0x0],r8
80007b60:	09 08       	ld.w	r8,r4++
80007b62:	8f 58       	st.w	r7[0x14],r8
80007b64:	ee cc ff e8 	sub	r12,r7,-24
80007b68:	e0 4a 00 24 	cp.w	r10,36
80007b6c:	c0 71       	brne	80007b7a <_realloc_r+0x1ce>
80007b6e:	09 08       	ld.w	r8,r4++
80007b70:	99 08       	st.w	r12[0x0],r8
80007b72:	ee cc ff e0 	sub	r12,r7,-32
80007b76:	09 08       	ld.w	r8,r4++
80007b78:	8f 78       	st.w	r7[0x1c],r8
80007b7a:	09 08       	ld.w	r8,r4++
80007b7c:	18 a8       	st.w	r12++,r8
80007b7e:	68 08       	ld.w	r8,r4[0x0]
80007b80:	99 08       	st.w	r12[0x0],r8
80007b82:	68 18       	ld.w	r8,r4[0x4]
80007b84:	99 18       	st.w	r12[0x4],r8
80007b86:	c4 78       	rjmp	80007c14 <_realloc_r+0x268>
80007b88:	08 9b       	mov	r11,r4
80007b8a:	e0 a0 1d 42 	rcall	8000b60e <memmove>
80007b8e:	c4 38       	rjmp	80007c14 <_realloc_r+0x268>
80007b90:	04 9c       	mov	r12,r2
80007b92:	fe b0 fc 45 	rcall	8000741c <_malloc_r>
80007b96:	18 95       	mov	r5,r12
80007b98:	c3 a0       	breq	80007c0c <_realloc_r+0x260>
80007b9a:	62 18       	ld.w	r8,r1[0x4]
80007b9c:	f8 c9 00 08 	sub	r9,r12,8
80007ba0:	a1 c8       	cbr	r8,0x0
80007ba2:	e2 08 00 08 	add	r8,r1,r8
80007ba6:	10 39       	cp.w	r9,r8
80007ba8:	c0 71       	brne	80007bb6 <_realloc_r+0x20a>
80007baa:	72 13       	ld.w	r3,r9[0x4]
80007bac:	02 97       	mov	r7,r1
80007bae:	e0 13 ff fc 	andl	r3,0xfffc
80007bb2:	00 03       	add	r3,r0
80007bb4:	c3 08       	rjmp	80007c14 <_realloc_r+0x268>
80007bb6:	e0 ca 00 04 	sub	r10,r0,4
80007bba:	e0 4a 00 24 	cp.w	r10,36
80007bbe:	e0 8b 00 20 	brhi	80007bfe <_realloc_r+0x252>
80007bc2:	08 99       	mov	r9,r4
80007bc4:	18 98       	mov	r8,r12
80007bc6:	59 3a       	cp.w	r10,19
80007bc8:	e0 88 00 14 	brls	80007bf0 <_realloc_r+0x244>
80007bcc:	13 0b       	ld.w	r11,r9++
80007bce:	10 ab       	st.w	r8++,r11
80007bd0:	13 0b       	ld.w	r11,r9++
80007bd2:	10 ab       	st.w	r8++,r11
80007bd4:	59 ba       	cp.w	r10,27
80007bd6:	e0 88 00 0d 	brls	80007bf0 <_realloc_r+0x244>
80007bda:	13 0b       	ld.w	r11,r9++
80007bdc:	10 ab       	st.w	r8++,r11
80007bde:	13 0b       	ld.w	r11,r9++
80007be0:	10 ab       	st.w	r8++,r11
80007be2:	e0 4a 00 24 	cp.w	r10,36
80007be6:	c0 51       	brne	80007bf0 <_realloc_r+0x244>
80007be8:	13 0a       	ld.w	r10,r9++
80007bea:	10 aa       	st.w	r8++,r10
80007bec:	13 0a       	ld.w	r10,r9++
80007bee:	10 aa       	st.w	r8++,r10
80007bf0:	13 0a       	ld.w	r10,r9++
80007bf2:	10 aa       	st.w	r8++,r10
80007bf4:	72 0a       	ld.w	r10,r9[0x0]
80007bf6:	91 0a       	st.w	r8[0x0],r10
80007bf8:	72 19       	ld.w	r9,r9[0x4]
80007bfa:	91 19       	st.w	r8[0x4],r9
80007bfc:	c0 48       	rjmp	80007c04 <_realloc_r+0x258>
80007bfe:	08 9b       	mov	r11,r4
80007c00:	e0 a0 1d 07 	rcall	8000b60e <memmove>
80007c04:	08 9b       	mov	r11,r4
80007c06:	04 9c       	mov	r12,r2
80007c08:	e0 a0 1a 60 	rcall	8000b0c8 <_free_r>
80007c0c:	04 9c       	mov	r12,r2
80007c0e:	c2 a8       	rjmp	80007c62 <_realloc_r+0x2b6>
80007c10:	00 93       	mov	r3,r0
80007c12:	02 97       	mov	r7,r1
80007c14:	e6 06 01 09 	sub	r9,r3,r6
80007c18:	6e 18       	ld.w	r8,r7[0x4]
80007c1a:	58 f9       	cp.w	r9,15
80007c1c:	e0 88 00 16 	brls	80007c48 <_realloc_r+0x29c>
80007c20:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007c24:	ed e8 10 08 	or	r8,r6,r8
80007c28:	8f 18       	st.w	r7[0x4],r8
80007c2a:	12 98       	mov	r8,r9
80007c2c:	a1 a8       	sbr	r8,0x0
80007c2e:	ee 06 00 0b 	add	r11,r7,r6
80007c32:	f6 09 00 09 	add	r9,r11,r9
80007c36:	97 18       	st.w	r11[0x4],r8
80007c38:	72 18       	ld.w	r8,r9[0x4]
80007c3a:	a1 a8       	sbr	r8,0x0
80007c3c:	2f 8b       	sub	r11,-8
80007c3e:	93 18       	st.w	r9[0x4],r8
80007c40:	04 9c       	mov	r12,r2
80007c42:	e0 a0 1a 43 	rcall	8000b0c8 <_free_r>
80007c46:	c0 b8       	rjmp	80007c5c <_realloc_r+0x2b0>
80007c48:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007c4c:	e7 e8 10 08 	or	r8,r3,r8
80007c50:	8f 18       	st.w	r7[0x4],r8
80007c52:	ee 03 00 03 	add	r3,r7,r3
80007c56:	66 18       	ld.w	r8,r3[0x4]
80007c58:	a1 a8       	sbr	r8,0x0
80007c5a:	87 18       	st.w	r3[0x4],r8
80007c5c:	04 9c       	mov	r12,r2
80007c5e:	ee c5 ff f8 	sub	r5,r7,-8
80007c62:	fe b0 f1 99 	rcall	80005f94 <__malloc_unlock>
80007c66:	0a 9c       	mov	r12,r5
80007c68:	2f fd       	sub	sp,-4
80007c6a:	d8 32       	popm	r0-r7,pc

80007c6c <_sbrk_r>:
80007c6c:	d4 21       	pushm	r4-r7,lr
80007c6e:	30 08       	mov	r8,0
80007c70:	18 97       	mov	r7,r12
80007c72:	e0 66 53 bc 	mov	r6,21436
80007c76:	16 9c       	mov	r12,r11
80007c78:	8d 08       	st.w	r6[0x0],r8
80007c7a:	c8 5c       	rcall	80007d84 <_sbrk>
80007c7c:	5b fc       	cp.w	r12,-1
80007c7e:	c0 51       	brne	80007c88 <_sbrk_r+0x1c>
80007c80:	6c 08       	ld.w	r8,r6[0x0]
80007c82:	58 08       	cp.w	r8,0
80007c84:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007c88:	d8 22       	popm	r4-r7,pc
80007c8a:	d7 03       	nop

80007c8c <sprintf>:
80007c8c:	d4 01       	pushm	lr
80007c8e:	21 7d       	sub	sp,92
80007c90:	e0 68 ff ff 	mov	r8,65535
80007c94:	ea 18 7f ff 	orh	r8,0x7fff
80007c98:	50 58       	stdsp	sp[0x14],r8
80007c9a:	50 28       	stdsp	sp[0x8],r8
80007c9c:	e0 68 02 08 	mov	r8,520
80007ca0:	ba 68       	st.h	sp[0xc],r8
80007ca2:	3f f8       	mov	r8,-1
80007ca4:	ba 78       	st.h	sp[0xe],r8
80007ca6:	e0 68 0a 3c 	mov	r8,2620
80007caa:	50 4c       	stdsp	sp[0x10],r12
80007cac:	16 9a       	mov	r10,r11
80007cae:	50 0c       	stdsp	sp[0x0],r12
80007cb0:	fa c9 ff a0 	sub	r9,sp,-96
80007cb4:	70 0c       	ld.w	r12,r8[0x0]
80007cb6:	1a 9b       	mov	r11,sp
80007cb8:	e0 a0 02 1a 	rcall	800080ec <_vfprintf_r>
80007cbc:	30 09       	mov	r9,0
80007cbe:	40 08       	lddsp	r8,sp[0x0]
80007cc0:	b0 89       	st.b	r8[0x0],r9
80007cc2:	2e 9d       	sub	sp,-92
80007cc4:	d8 02       	popm	pc
80007cc6:	d7 03       	nop

80007cc8 <strncpy>:
80007cc8:	30 08       	mov	r8,0
80007cca:	10 3a       	cp.w	r10,r8
80007ccc:	5e 0c       	reteq	r12
80007cce:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007cd2:	f8 08 0b 09 	st.b	r12[r8],r9
80007cd6:	2f f8       	sub	r8,-1
80007cd8:	58 09       	cp.w	r9,0
80007cda:	cf 81       	brne	80007cca <strncpy+0x2>
80007cdc:	10 3a       	cp.w	r10,r8
80007cde:	5e 0c       	reteq	r12
80007ce0:	f8 08 0b 09 	st.b	r12[r8],r9
80007ce4:	2f f8       	sub	r8,-1
80007ce6:	cf bb       	rjmp	80007cdc <strncpy+0x14>

80007ce8 <_close>:
80007ce8:	30 28       	mov	r8,2
80007cea:	d6 73       	breakpoint
80007cec:	3f fc       	mov	r12,-1
80007cee:	35 8b       	mov	r11,88
80007cf0:	58 0c       	cp.w	r12,0
80007cf2:	5e 4c       	retge	r12
80007cf4:	e0 6a 53 bc 	mov	r10,21436
80007cf8:	95 0b       	st.w	r10[0x0],r11
80007cfa:	5e fc       	retal	r12

80007cfc <_lseek>:
80007cfc:	30 58       	mov	r8,5
80007cfe:	d6 73       	breakpoint
80007d00:	3f fc       	mov	r12,-1
80007d02:	35 8b       	mov	r11,88
80007d04:	58 0c       	cp.w	r12,0
80007d06:	5e 4c       	retge	r12
80007d08:	e0 6a 53 bc 	mov	r10,21436
80007d0c:	95 0b       	st.w	r10[0x0],r11
80007d0e:	5e fc       	retal	r12

80007d10 <isatty>:
80007d10:	30 b8       	mov	r8,11
80007d12:	d6 73       	breakpoint
80007d14:	3f fc       	mov	r12,-1
80007d16:	35 8b       	mov	r11,88
80007d18:	58 0c       	cp.w	r12,0
80007d1a:	5e 4c       	retge	r12
80007d1c:	e0 6a 53 bc 	mov	r10,21436
80007d20:	95 0b       	st.w	r10[0x0],r11
80007d22:	5e fc       	retal	r12

80007d24 <_fstat_host>:
80007d24:	30 98       	mov	r8,9
80007d26:	d6 73       	breakpoint
80007d28:	3f fc       	mov	r12,-1
80007d2a:	35 8b       	mov	r11,88
80007d2c:	58 0c       	cp.w	r12,0
80007d2e:	5e 4c       	retge	r12
80007d30:	e0 6a 53 bc 	mov	r10,21436
80007d34:	95 0b       	st.w	r10[0x0],r11
80007d36:	5e fc       	retal	r12

80007d38 <_fstat>:
80007d38:	d4 21       	pushm	r4-r7,lr
80007d3a:	21 0d       	sub	sp,64
80007d3c:	16 97       	mov	r7,r11
80007d3e:	1a 9b       	mov	r11,sp
80007d40:	cf 2f       	rcall	80007d24 <_fstat_host>
80007d42:	c0 34       	brge	80007d48 <_fstat+0x10>
80007d44:	3f fc       	mov	r12,-1
80007d46:	c1 c8       	rjmp	80007d7e <_fstat+0x46>
80007d48:	40 08       	lddsp	r8,sp[0x0]
80007d4a:	ae 08       	st.h	r7[0x0],r8
80007d4c:	40 18       	lddsp	r8,sp[0x4]
80007d4e:	ae 18       	st.h	r7[0x2],r8
80007d50:	40 28       	lddsp	r8,sp[0x8]
80007d52:	8f 18       	st.w	r7[0x4],r8
80007d54:	40 38       	lddsp	r8,sp[0xc]
80007d56:	ae 48       	st.h	r7[0x8],r8
80007d58:	40 48       	lddsp	r8,sp[0x10]
80007d5a:	ae 58       	st.h	r7[0xa],r8
80007d5c:	40 58       	lddsp	r8,sp[0x14]
80007d5e:	ae 68       	st.h	r7[0xc],r8
80007d60:	40 68       	lddsp	r8,sp[0x18]
80007d62:	ae 78       	st.h	r7[0xe],r8
80007d64:	40 88       	lddsp	r8,sp[0x20]
80007d66:	8f 48       	st.w	r7[0x10],r8
80007d68:	40 a8       	lddsp	r8,sp[0x28]
80007d6a:	8f b8       	st.w	r7[0x2c],r8
80007d6c:	40 c8       	lddsp	r8,sp[0x30]
80007d6e:	8f c8       	st.w	r7[0x30],r8
80007d70:	40 d8       	lddsp	r8,sp[0x34]
80007d72:	8f 58       	st.w	r7[0x14],r8
80007d74:	40 e8       	lddsp	r8,sp[0x38]
80007d76:	30 0c       	mov	r12,0
80007d78:	8f 78       	st.w	r7[0x1c],r8
80007d7a:	40 f8       	lddsp	r8,sp[0x3c]
80007d7c:	8f 98       	st.w	r7[0x24],r8
80007d7e:	2f 0d       	sub	sp,-64
80007d80:	d8 22       	popm	r4-r7,pc
80007d82:	d7 03       	nop

80007d84 <_sbrk>:
80007d84:	d4 01       	pushm	lr
80007d86:	e0 68 0d 88 	mov	r8,3464
80007d8a:	70 09       	ld.w	r9,r8[0x0]
80007d8c:	58 09       	cp.w	r9,0
80007d8e:	c0 41       	brne	80007d96 <_sbrk+0x12>
80007d90:	e0 69 53 c0 	mov	r9,21440
80007d94:	91 09       	st.w	r8[0x0],r9
80007d96:	e0 69 0d 88 	mov	r9,3464
80007d9a:	e0 7a 70 00 	mov	r10,94208
80007d9e:	72 08       	ld.w	r8,r9[0x0]
80007da0:	f0 0c 00 0c 	add	r12,r8,r12
80007da4:	14 3c       	cp.w	r12,r10
80007da6:	e0 8b 00 04 	brhi	80007dae <_sbrk+0x2a>
80007daa:	93 0c       	st.w	r9[0x0],r12
80007dac:	c0 68       	rjmp	80007db8 <_sbrk+0x34>
80007dae:	e0 a0 18 15 	rcall	8000add8 <__errno>
80007db2:	30 c8       	mov	r8,12
80007db4:	99 08       	st.w	r12[0x0],r8
80007db6:	3f f8       	mov	r8,-1
80007db8:	10 9c       	mov	r12,r8
80007dba:	d8 02       	popm	pc

80007dbc <get_arg>:
80007dbc:	d4 31       	pushm	r0-r7,lr
80007dbe:	20 8d       	sub	sp,32
80007dc0:	fa c4 ff bc 	sub	r4,sp,-68
80007dc4:	50 4b       	stdsp	sp[0x10],r11
80007dc6:	68 2e       	ld.w	lr,r4[0x8]
80007dc8:	50 58       	stdsp	sp[0x14],r8
80007dca:	12 96       	mov	r6,r9
80007dcc:	7c 0b       	ld.w	r11,lr[0x0]
80007dce:	70 05       	ld.w	r5,r8[0x0]
80007dd0:	50 6e       	stdsp	sp[0x18],lr
80007dd2:	58 0b       	cp.w	r11,0
80007dd4:	f4 0b 17 00 	moveq	r11,r10
80007dd8:	68 03       	ld.w	r3,r4[0x0]
80007dda:	68 11       	ld.w	r1,r4[0x4]
80007ddc:	40 49       	lddsp	r9,sp[0x10]
80007dde:	30 08       	mov	r8,0
80007de0:	c2 89       	rjmp	80008030 <get_arg+0x274>
80007de2:	2f fb       	sub	r11,-1
80007de4:	32 5c       	mov	r12,37
80007de6:	17 8a       	ld.ub	r10,r11[0x0]
80007de8:	f8 0a 18 00 	cp.b	r10,r12
80007dec:	5f 1e       	srne	lr
80007dee:	f0 0a 18 00 	cp.b	r10,r8
80007df2:	5f 1c       	srne	r12
80007df4:	fd ec 00 0c 	and	r12,lr,r12
80007df8:	f0 0c 18 00 	cp.b	r12,r8
80007dfc:	cf 31       	brne	80007de2 <get_arg+0x26>
80007dfe:	58 0a       	cp.w	r10,0
80007e00:	e0 80 01 25 	breq	8000804a <get_arg+0x28e>
80007e04:	30 0c       	mov	r12,0
80007e06:	3f fa       	mov	r10,-1
80007e08:	18 90       	mov	r0,r12
80007e0a:	50 3a       	stdsp	sp[0xc],r10
80007e0c:	18 94       	mov	r4,r12
80007e0e:	18 92       	mov	r2,r12
80007e10:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007e14:	16 97       	mov	r7,r11
80007e16:	50 7c       	stdsp	sp[0x1c],r12
80007e18:	fe cc 9e 28 	sub	r12,pc,-25048
80007e1c:	0f 3a       	ld.ub	r10,r7++
80007e1e:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007e22:	40 7c       	lddsp	r12,sp[0x1c]
80007e24:	1c 0c       	add	r12,lr
80007e26:	fe ce 9e fe 	sub	lr,pc,-24834
80007e2a:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007e2e:	20 1e       	sub	lr,1
80007e30:	50 0e       	stdsp	sp[0x0],lr
80007e32:	fe ce 9f 76 	sub	lr,pc,-24714
80007e36:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007e3a:	50 7c       	stdsp	sp[0x1c],r12
80007e3c:	40 0c       	lddsp	r12,sp[0x0]
80007e3e:	58 7c       	cp.w	r12,7
80007e40:	e0 8b 00 f1 	brhi	80008022 <get_arg+0x266>
80007e44:	fe ce a1 28 	sub	lr,pc,-24280
80007e48:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007e4c:	36 8b       	mov	r11,104
80007e4e:	f6 0a 18 00 	cp.b	r10,r11
80007e52:	e0 80 00 e8 	breq	80008022 <get_arg+0x266>
80007e56:	37 1b       	mov	r11,113
80007e58:	f6 0a 18 00 	cp.b	r10,r11
80007e5c:	c0 70       	breq	80007e6a <get_arg+0xae>
80007e5e:	34 cb       	mov	r11,76
80007e60:	f6 0a 18 00 	cp.b	r10,r11
80007e64:	c0 51       	brne	80007e6e <get_arg+0xb2>
80007e66:	a3 b4       	sbr	r4,0x3
80007e68:	cd d8       	rjmp	80008022 <get_arg+0x266>
80007e6a:	a5 b4       	sbr	r4,0x5
80007e6c:	cd b8       	rjmp	80008022 <get_arg+0x266>
80007e6e:	08 9a       	mov	r10,r4
80007e70:	0e 9b       	mov	r11,r7
80007e72:	a5 aa       	sbr	r10,0x4
80007e74:	17 3c       	ld.ub	r12,r11++
80007e76:	a5 b4       	sbr	r4,0x5
80007e78:	36 ce       	mov	lr,108
80007e7a:	fc 0c 18 00 	cp.b	r12,lr
80007e7e:	e0 80 00 d3 	breq	80008024 <get_arg+0x268>
80007e82:	14 94       	mov	r4,r10
80007e84:	cc f8       	rjmp	80008022 <get_arg+0x266>
80007e86:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007e8a:	36 7c       	mov	r12,103
80007e8c:	f8 0a 18 00 	cp.b	r10,r12
80007e90:	e0 8b 00 27 	brhi	80007ede <get_arg+0x122>
80007e94:	36 5b       	mov	r11,101
80007e96:	f6 0a 18 00 	cp.b	r10,r11
80007e9a:	c4 82       	brcc	80007f2a <get_arg+0x16e>
80007e9c:	34 fb       	mov	r11,79
80007e9e:	f6 0a 18 00 	cp.b	r10,r11
80007ea2:	c4 80       	breq	80007f32 <get_arg+0x176>
80007ea4:	e0 8b 00 0c 	brhi	80007ebc <get_arg+0x100>
80007ea8:	34 5b       	mov	r11,69
80007eaa:	f6 0a 18 00 	cp.b	r10,r11
80007eae:	c3 e0       	breq	80007f2a <get_arg+0x16e>
80007eb0:	34 7b       	mov	r11,71
80007eb2:	f6 0a 18 00 	cp.b	r10,r11
80007eb6:	c3 a0       	breq	80007f2a <get_arg+0x16e>
80007eb8:	34 4b       	mov	r11,68
80007eba:	c0 88       	rjmp	80007eca <get_arg+0x10e>
80007ebc:	35 8b       	mov	r11,88
80007ebe:	f6 0a 18 00 	cp.b	r10,r11
80007ec2:	c2 c0       	breq	80007f1a <get_arg+0x15e>
80007ec4:	e0 8b 00 07 	brhi	80007ed2 <get_arg+0x116>
80007ec8:	35 5b       	mov	r11,85
80007eca:	f6 0a 18 00 	cp.b	r10,r11
80007ece:	c3 51       	brne	80007f38 <get_arg+0x17c>
80007ed0:	c3 18       	rjmp	80007f32 <get_arg+0x176>
80007ed2:	36 3b       	mov	r11,99
80007ed4:	f6 0a 18 00 	cp.b	r10,r11
80007ed8:	c2 f0       	breq	80007f36 <get_arg+0x17a>
80007eda:	36 4b       	mov	r11,100
80007edc:	c0 e8       	rjmp	80007ef8 <get_arg+0x13c>
80007ede:	37 0b       	mov	r11,112
80007ee0:	f6 0a 18 00 	cp.b	r10,r11
80007ee4:	c2 50       	breq	80007f2e <get_arg+0x172>
80007ee6:	e0 8b 00 0d 	brhi	80007f00 <get_arg+0x144>
80007eea:	36 eb       	mov	r11,110
80007eec:	f6 0a 18 00 	cp.b	r10,r11
80007ef0:	c1 f0       	breq	80007f2e <get_arg+0x172>
80007ef2:	e0 8b 00 14 	brhi	80007f1a <get_arg+0x15e>
80007ef6:	36 9b       	mov	r11,105
80007ef8:	f6 0a 18 00 	cp.b	r10,r11
80007efc:	c1 e1       	brne	80007f38 <get_arg+0x17c>
80007efe:	c0 e8       	rjmp	80007f1a <get_arg+0x15e>
80007f00:	37 5b       	mov	r11,117
80007f02:	f6 0a 18 00 	cp.b	r10,r11
80007f06:	c0 a0       	breq	80007f1a <get_arg+0x15e>
80007f08:	37 8b       	mov	r11,120
80007f0a:	f6 0a 18 00 	cp.b	r10,r11
80007f0e:	c0 60       	breq	80007f1a <get_arg+0x15e>
80007f10:	37 3b       	mov	r11,115
80007f12:	f6 0a 18 00 	cp.b	r10,r11
80007f16:	c1 11       	brne	80007f38 <get_arg+0x17c>
80007f18:	c0 b8       	rjmp	80007f2e <get_arg+0x172>
80007f1a:	ed b4 00 04 	bld	r4,0x4
80007f1e:	c0 a0       	breq	80007f32 <get_arg+0x176>
80007f20:	ed b4 00 05 	bld	r4,0x5
80007f24:	c0 91       	brne	80007f36 <get_arg+0x17a>
80007f26:	30 20       	mov	r0,2
80007f28:	c0 88       	rjmp	80007f38 <get_arg+0x17c>
80007f2a:	30 40       	mov	r0,4
80007f2c:	c0 68       	rjmp	80007f38 <get_arg+0x17c>
80007f2e:	30 30       	mov	r0,3
80007f30:	c0 48       	rjmp	80007f38 <get_arg+0x17c>
80007f32:	30 10       	mov	r0,1
80007f34:	c0 28       	rjmp	80007f38 <get_arg+0x17c>
80007f36:	30 00       	mov	r0,0
80007f38:	40 3b       	lddsp	r11,sp[0xc]
80007f3a:	5b fb       	cp.w	r11,-1
80007f3c:	c0 40       	breq	80007f44 <get_arg+0x188>
80007f3e:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007f42:	c7 08       	rjmp	80008022 <get_arg+0x266>
80007f44:	58 60       	cp.w	r0,6
80007f46:	e0 8b 00 6e 	brhi	80008022 <get_arg+0x266>
80007f4a:	6c 0a       	ld.w	r10,r6[0x0]
80007f4c:	ea cc ff ff 	sub	r12,r5,-1
80007f50:	fe ce a2 14 	sub	lr,pc,-24044
80007f54:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007f58:	f4 cb ff f8 	sub	r11,r10,-8
80007f5c:	8d 0b       	st.w	r6[0x0],r11
80007f5e:	f4 ea 00 00 	ld.d	r10,r10[0]
80007f62:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007f66:	c0 f8       	rjmp	80007f84 <get_arg+0x1c8>
80007f68:	f4 cb ff fc 	sub	r11,r10,-4
80007f6c:	8d 0b       	st.w	r6[0x0],r11
80007f6e:	74 0a       	ld.w	r10,r10[0x0]
80007f70:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007f74:	c0 88       	rjmp	80007f84 <get_arg+0x1c8>
80007f76:	f4 cb ff f8 	sub	r11,r10,-8
80007f7a:	8d 0b       	st.w	r6[0x0],r11
80007f7c:	f4 ea 00 00 	ld.d	r10,r10[0]
80007f80:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007f84:	0e 9b       	mov	r11,r7
80007f86:	18 95       	mov	r5,r12
80007f88:	c4 e8       	rjmp	80008024 <get_arg+0x268>
80007f8a:	62 0a       	ld.w	r10,r1[0x0]
80007f8c:	5b fa       	cp.w	r10,-1
80007f8e:	c0 b1       	brne	80007fa4 <get_arg+0x1e8>
80007f90:	50 19       	stdsp	sp[0x4],r9
80007f92:	50 28       	stdsp	sp[0x8],r8
80007f94:	e0 6a 00 80 	mov	r10,128
80007f98:	30 0b       	mov	r11,0
80007f9a:	02 9c       	mov	r12,r1
80007f9c:	fe b0 fd 00 	rcall	8000799c <memset>
80007fa0:	40 28       	lddsp	r8,sp[0x8]
80007fa2:	40 19       	lddsp	r9,sp[0x4]
80007fa4:	e4 cc 00 01 	sub	r12,r2,1
80007fa8:	0e 9b       	mov	r11,r7
80007faa:	50 3c       	stdsp	sp[0xc],r12
80007fac:	f2 0c 0c 49 	max	r9,r9,r12
80007fb0:	c3 a8       	rjmp	80008024 <get_arg+0x268>
80007fb2:	62 0a       	ld.w	r10,r1[0x0]
80007fb4:	5b fa       	cp.w	r10,-1
80007fb6:	c0 b1       	brne	80007fcc <get_arg+0x210>
80007fb8:	50 19       	stdsp	sp[0x4],r9
80007fba:	50 28       	stdsp	sp[0x8],r8
80007fbc:	e0 6a 00 80 	mov	r10,128
80007fc0:	30 0b       	mov	r11,0
80007fc2:	02 9c       	mov	r12,r1
80007fc4:	fe b0 fc ec 	rcall	8000799c <memset>
80007fc8:	40 28       	lddsp	r8,sp[0x8]
80007fca:	40 19       	lddsp	r9,sp[0x4]
80007fcc:	20 12       	sub	r2,1
80007fce:	30 0a       	mov	r10,0
80007fd0:	0e 9b       	mov	r11,r7
80007fd2:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007fd6:	f2 02 0c 49 	max	r9,r9,r2
80007fda:	c2 58       	rjmp	80008024 <get_arg+0x268>
80007fdc:	16 97       	mov	r7,r11
80007fde:	6c 0a       	ld.w	r10,r6[0x0]
80007fe0:	f4 cb ff fc 	sub	r11,r10,-4
80007fe4:	8d 0b       	st.w	r6[0x0],r11
80007fe6:	74 0a       	ld.w	r10,r10[0x0]
80007fe8:	0e 9b       	mov	r11,r7
80007fea:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007fee:	2f f5       	sub	r5,-1
80007ff0:	c1 a8       	rjmp	80008024 <get_arg+0x268>
80007ff2:	f4 c2 00 30 	sub	r2,r10,48
80007ff6:	c0 68       	rjmp	80008002 <get_arg+0x246>
80007ff8:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007ffc:	2f f7       	sub	r7,-1
80007ffe:	f4 02 00 12 	add	r2,r10,r2<<0x1
80008002:	0f 8a       	ld.ub	r10,r7[0x0]
80008004:	58 0a       	cp.w	r10,0
80008006:	c0 e0       	breq	80008022 <get_arg+0x266>
80008008:	23 0a       	sub	r10,48
8000800a:	58 9a       	cp.w	r10,9
8000800c:	fe 98 ff f6 	brls	80007ff8 <get_arg+0x23c>
80008010:	c0 98       	rjmp	80008022 <get_arg+0x266>
80008012:	2f f7       	sub	r7,-1
80008014:	0f 8a       	ld.ub	r10,r7[0x0]
80008016:	58 0a       	cp.w	r10,0
80008018:	c0 50       	breq	80008022 <get_arg+0x266>
8000801a:	23 0a       	sub	r10,48
8000801c:	58 9a       	cp.w	r10,9
8000801e:	fe 98 ff fa 	brls	80008012 <get_arg+0x256>
80008022:	0e 9b       	mov	r11,r7
80008024:	40 7c       	lddsp	r12,sp[0x1c]
80008026:	30 ba       	mov	r10,11
80008028:	f4 0c 18 00 	cp.b	r12,r10
8000802c:	fe 91 fe f2 	brne	80007e10 <get_arg+0x54>
80008030:	40 42       	lddsp	r2,sp[0x10]
80008032:	17 8c       	ld.ub	r12,r11[0x0]
80008034:	0a 32       	cp.w	r2,r5
80008036:	5f 4a       	srge	r10
80008038:	f0 0c 18 00 	cp.b	r12,r8
8000803c:	5f 1c       	srne	r12
8000803e:	f9 ea 00 0a 	and	r10,r12,r10
80008042:	f0 0a 18 00 	cp.b	r10,r8
80008046:	fe 91 fe cf 	brne	80007de4 <get_arg+0x28>
8000804a:	30 08       	mov	r8,0
8000804c:	40 4e       	lddsp	lr,sp[0x10]
8000804e:	17 8a       	ld.ub	r10,r11[0x0]
80008050:	e2 05 00 21 	add	r1,r1,r5<<0x2
80008054:	f0 0a 18 00 	cp.b	r10,r8
80008058:	fc 09 17 10 	movne	r9,lr
8000805c:	e6 05 00 38 	add	r8,r3,r5<<0x3
80008060:	06 9e       	mov	lr,r3
80008062:	c2 a8       	rjmp	800080b6 <get_arg+0x2fa>
80008064:	62 0a       	ld.w	r10,r1[0x0]
80008066:	58 3a       	cp.w	r10,3
80008068:	c1 e0       	breq	800080a4 <get_arg+0x2e8>
8000806a:	e0 89 00 07 	brgt	80008078 <get_arg+0x2bc>
8000806e:	58 1a       	cp.w	r10,1
80008070:	c1 a0       	breq	800080a4 <get_arg+0x2e8>
80008072:	58 2a       	cp.w	r10,2
80008074:	c1 81       	brne	800080a4 <get_arg+0x2e8>
80008076:	c0 58       	rjmp	80008080 <get_arg+0x2c4>
80008078:	58 5a       	cp.w	r10,5
8000807a:	c0 c0       	breq	80008092 <get_arg+0x2d6>
8000807c:	c0 b5       	brlt	80008092 <get_arg+0x2d6>
8000807e:	c1 38       	rjmp	800080a4 <get_arg+0x2e8>
80008080:	6c 0a       	ld.w	r10,r6[0x0]
80008082:	f4 cc ff f8 	sub	r12,r10,-8
80008086:	8d 0c       	st.w	r6[0x0],r12
80008088:	f4 e2 00 00 	ld.d	r2,r10[0]
8000808c:	f0 e3 00 00 	st.d	r8[0],r2
80008090:	c1 08       	rjmp	800080b0 <get_arg+0x2f4>
80008092:	6c 0a       	ld.w	r10,r6[0x0]
80008094:	f4 cc ff f8 	sub	r12,r10,-8
80008098:	8d 0c       	st.w	r6[0x0],r12
8000809a:	f4 e2 00 00 	ld.d	r2,r10[0]
8000809e:	f0 e3 00 00 	st.d	r8[0],r2
800080a2:	c0 78       	rjmp	800080b0 <get_arg+0x2f4>
800080a4:	6c 0a       	ld.w	r10,r6[0x0]
800080a6:	f4 cc ff fc 	sub	r12,r10,-4
800080aa:	8d 0c       	st.w	r6[0x0],r12
800080ac:	74 0a       	ld.w	r10,r10[0x0]
800080ae:	91 0a       	st.w	r8[0x0],r10
800080b0:	2f f5       	sub	r5,-1
800080b2:	2f 88       	sub	r8,-8
800080b4:	2f c1       	sub	r1,-4
800080b6:	12 35       	cp.w	r5,r9
800080b8:	fe 9a ff d6 	brle	80008064 <get_arg+0x2a8>
800080bc:	1c 93       	mov	r3,lr
800080be:	40 52       	lddsp	r2,sp[0x14]
800080c0:	40 6e       	lddsp	lr,sp[0x18]
800080c2:	85 05       	st.w	r2[0x0],r5
800080c4:	9d 0b       	st.w	lr[0x0],r11
800080c6:	40 4b       	lddsp	r11,sp[0x10]
800080c8:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
800080cc:	2f 8d       	sub	sp,-32
800080ce:	d8 32       	popm	r0-r7,pc

800080d0 <__sprint_r>:
800080d0:	d4 21       	pushm	r4-r7,lr
800080d2:	14 97       	mov	r7,r10
800080d4:	74 28       	ld.w	r8,r10[0x8]
800080d6:	58 08       	cp.w	r8,0
800080d8:	c0 41       	brne	800080e0 <__sprint_r+0x10>
800080da:	95 18       	st.w	r10[0x4],r8
800080dc:	10 9c       	mov	r12,r8
800080de:	d8 22       	popm	r4-r7,pc
800080e0:	e0 a0 18 ba 	rcall	8000b254 <__sfvwrite_r>
800080e4:	30 08       	mov	r8,0
800080e6:	8f 18       	st.w	r7[0x4],r8
800080e8:	8f 28       	st.w	r7[0x8],r8
800080ea:	d8 22       	popm	r4-r7,pc

800080ec <_vfprintf_r>:
800080ec:	d4 31       	pushm	r0-r7,lr
800080ee:	fa cd 06 bc 	sub	sp,sp,1724
800080f2:	51 09       	stdsp	sp[0x40],r9
800080f4:	16 91       	mov	r1,r11
800080f6:	14 97       	mov	r7,r10
800080f8:	18 95       	mov	r5,r12
800080fa:	e0 a0 1a 1d 	rcall	8000b534 <_localeconv_r>
800080fe:	78 0c       	ld.w	r12,r12[0x0]
80008100:	50 cc       	stdsp	sp[0x30],r12
80008102:	58 05       	cp.w	r5,0
80008104:	c0 70       	breq	80008112 <_vfprintf_r+0x26>
80008106:	6a 68       	ld.w	r8,r5[0x18]
80008108:	58 08       	cp.w	r8,0
8000810a:	c0 41       	brne	80008112 <_vfprintf_r+0x26>
8000810c:	0a 9c       	mov	r12,r5
8000810e:	e0 a0 17 43 	rcall	8000af94 <__sinit>
80008112:	fe c8 a0 12 	sub	r8,pc,-24558
80008116:	10 31       	cp.w	r1,r8
80008118:	c0 31       	brne	8000811e <_vfprintf_r+0x32>
8000811a:	6a 01       	ld.w	r1,r5[0x0]
8000811c:	c0 c8       	rjmp	80008134 <_vfprintf_r+0x48>
8000811e:	fe c8 9f fe 	sub	r8,pc,-24578
80008122:	10 31       	cp.w	r1,r8
80008124:	c0 31       	brne	8000812a <_vfprintf_r+0x3e>
80008126:	6a 11       	ld.w	r1,r5[0x4]
80008128:	c0 68       	rjmp	80008134 <_vfprintf_r+0x48>
8000812a:	fe c8 9f ea 	sub	r8,pc,-24598
8000812e:	10 31       	cp.w	r1,r8
80008130:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80008134:	82 68       	ld.sh	r8,r1[0xc]
80008136:	ed b8 00 03 	bld	r8,0x3
8000813a:	c0 41       	brne	80008142 <_vfprintf_r+0x56>
8000813c:	62 48       	ld.w	r8,r1[0x10]
8000813e:	58 08       	cp.w	r8,0
80008140:	c0 71       	brne	8000814e <_vfprintf_r+0x62>
80008142:	02 9b       	mov	r11,r1
80008144:	0a 9c       	mov	r12,r5
80008146:	e0 a0 0f 5d 	rcall	8000a000 <__swsetup_r>
8000814a:	e0 81 0f 54 	brne	80009ff2 <_vfprintf_r+0x1f06>
8000814e:	82 68       	ld.sh	r8,r1[0xc]
80008150:	10 99       	mov	r9,r8
80008152:	e2 19 00 1a 	andl	r9,0x1a,COH
80008156:	58 a9       	cp.w	r9,10
80008158:	c3 c1       	brne	800081d0 <_vfprintf_r+0xe4>
8000815a:	82 79       	ld.sh	r9,r1[0xe]
8000815c:	30 0a       	mov	r10,0
8000815e:	f4 09 19 00 	cp.h	r9,r10
80008162:	c3 75       	brlt	800081d0 <_vfprintf_r+0xe4>
80008164:	a1 d8       	cbr	r8,0x1
80008166:	fb 58 05 d0 	st.h	sp[1488],r8
8000816a:	62 88       	ld.w	r8,r1[0x20]
8000816c:	fb 48 05 e4 	st.w	sp[1508],r8
80008170:	62 a8       	ld.w	r8,r1[0x28]
80008172:	fb 48 05 ec 	st.w	sp[1516],r8
80008176:	fa c8 ff bc 	sub	r8,sp,-68
8000817a:	fb 48 05 d4 	st.w	sp[1492],r8
8000817e:	fb 48 05 c4 	st.w	sp[1476],r8
80008182:	e0 68 04 00 	mov	r8,1024
80008186:	fb 48 05 d8 	st.w	sp[1496],r8
8000818a:	fb 48 05 cc 	st.w	sp[1484],r8
8000818e:	30 08       	mov	r8,0
80008190:	fb 59 05 d2 	st.h	sp[1490],r9
80008194:	0e 9a       	mov	r10,r7
80008196:	41 09       	lddsp	r9,sp[0x40]
80008198:	fa c7 fa 3c 	sub	r7,sp,-1476
8000819c:	fb 48 05 dc 	st.w	sp[1500],r8
800081a0:	0a 9c       	mov	r12,r5
800081a2:	0e 9b       	mov	r11,r7
800081a4:	ca 4f       	rcall	800080ec <_vfprintf_r>
800081a6:	50 bc       	stdsp	sp[0x2c],r12
800081a8:	c0 95       	brlt	800081ba <_vfprintf_r+0xce>
800081aa:	0e 9b       	mov	r11,r7
800081ac:	0a 9c       	mov	r12,r5
800081ae:	e0 a0 16 1b 	rcall	8000ade4 <_fflush_r>
800081b2:	40 be       	lddsp	lr,sp[0x2c]
800081b4:	f9 be 01 ff 	movne	lr,-1
800081b8:	50 be       	stdsp	sp[0x2c],lr
800081ba:	fb 08 05 d0 	ld.sh	r8,sp[1488]
800081be:	ed b8 00 06 	bld	r8,0x6
800081c2:	e0 81 0f 1a 	brne	80009ff6 <_vfprintf_r+0x1f0a>
800081c6:	82 68       	ld.sh	r8,r1[0xc]
800081c8:	a7 a8       	sbr	r8,0x6
800081ca:	a2 68       	st.h	r1[0xc],r8
800081cc:	e0 8f 0f 15 	bral	80009ff6 <_vfprintf_r+0x1f0a>
800081d0:	30 08       	mov	r8,0
800081d2:	fb 48 06 b4 	st.w	sp[1716],r8
800081d6:	fb 48 06 90 	st.w	sp[1680],r8
800081da:	fb 48 06 8c 	st.w	sp[1676],r8
800081de:	fb 48 06 b0 	st.w	sp[1712],r8
800081e2:	30 08       	mov	r8,0
800081e4:	30 09       	mov	r9,0
800081e6:	50 a7       	stdsp	sp[0x28],r7
800081e8:	50 78       	stdsp	sp[0x1c],r8
800081ea:	fa c3 f9 e0 	sub	r3,sp,-1568
800081ee:	3f f8       	mov	r8,-1
800081f0:	50 59       	stdsp	sp[0x14],r9
800081f2:	fb 43 06 88 	st.w	sp[1672],r3
800081f6:	fb 48 05 44 	st.w	sp[1348],r8
800081fa:	12 9c       	mov	r12,r9
800081fc:	50 69       	stdsp	sp[0x18],r9
800081fe:	50 d9       	stdsp	sp[0x34],r9
80008200:	50 e9       	stdsp	sp[0x38],r9
80008202:	50 b9       	stdsp	sp[0x2c],r9
80008204:	12 97       	mov	r7,r9
80008206:	0a 94       	mov	r4,r5
80008208:	40 a2       	lddsp	r2,sp[0x28]
8000820a:	32 5a       	mov	r10,37
8000820c:	30 08       	mov	r8,0
8000820e:	c0 28       	rjmp	80008212 <_vfprintf_r+0x126>
80008210:	2f f2       	sub	r2,-1
80008212:	05 89       	ld.ub	r9,r2[0x0]
80008214:	f0 09 18 00 	cp.b	r9,r8
80008218:	5f 1b       	srne	r11
8000821a:	f4 09 18 00 	cp.b	r9,r10
8000821e:	5f 19       	srne	r9
80008220:	f3 eb 00 0b 	and	r11,r9,r11
80008224:	f0 0b 18 00 	cp.b	r11,r8
80008228:	cf 41       	brne	80008210 <_vfprintf_r+0x124>
8000822a:	40 ab       	lddsp	r11,sp[0x28]
8000822c:	e4 0b 01 06 	sub	r6,r2,r11
80008230:	c1 e0       	breq	8000826c <_vfprintf_r+0x180>
80008232:	fa f8 06 90 	ld.w	r8,sp[1680]
80008236:	0c 08       	add	r8,r6
80008238:	87 0b       	st.w	r3[0x0],r11
8000823a:	fb 48 06 90 	st.w	sp[1680],r8
8000823e:	87 16       	st.w	r3[0x4],r6
80008240:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008244:	2f f8       	sub	r8,-1
80008246:	fb 48 06 8c 	st.w	sp[1676],r8
8000824a:	58 78       	cp.w	r8,7
8000824c:	e0 89 00 04 	brgt	80008254 <_vfprintf_r+0x168>
80008250:	2f 83       	sub	r3,-8
80008252:	c0 a8       	rjmp	80008266 <_vfprintf_r+0x17a>
80008254:	fa ca f9 78 	sub	r10,sp,-1672
80008258:	02 9b       	mov	r11,r1
8000825a:	08 9c       	mov	r12,r4
8000825c:	c3 af       	rcall	800080d0 <__sprint_r>
8000825e:	e0 81 0e c6 	brne	80009fea <_vfprintf_r+0x1efe>
80008262:	fa c3 f9 e0 	sub	r3,sp,-1568
80008266:	40 ba       	lddsp	r10,sp[0x2c]
80008268:	0c 0a       	add	r10,r6
8000826a:	50 ba       	stdsp	sp[0x2c],r10
8000826c:	05 89       	ld.ub	r9,r2[0x0]
8000826e:	30 08       	mov	r8,0
80008270:	f0 09 18 00 	cp.b	r9,r8
80008274:	e0 80 0e aa 	breq	80009fc8 <_vfprintf_r+0x1edc>
80008278:	30 09       	mov	r9,0
8000827a:	fb 68 06 bb 	st.b	sp[1723],r8
8000827e:	0e 96       	mov	r6,r7
80008280:	e4 c8 ff ff 	sub	r8,r2,-1
80008284:	3f fe       	mov	lr,-1
80008286:	50 93       	stdsp	sp[0x24],r3
80008288:	50 41       	stdsp	sp[0x10],r1
8000828a:	0e 93       	mov	r3,r7
8000828c:	04 91       	mov	r1,r2
8000828e:	50 89       	stdsp	sp[0x20],r9
80008290:	50 a8       	stdsp	sp[0x28],r8
80008292:	50 2e       	stdsp	sp[0x8],lr
80008294:	50 39       	stdsp	sp[0xc],r9
80008296:	12 95       	mov	r5,r9
80008298:	12 90       	mov	r0,r9
8000829a:	10 97       	mov	r7,r8
8000829c:	08 92       	mov	r2,r4
8000829e:	c0 78       	rjmp	800082ac <_vfprintf_r+0x1c0>
800082a0:	3f fc       	mov	r12,-1
800082a2:	08 97       	mov	r7,r4
800082a4:	50 2c       	stdsp	sp[0x8],r12
800082a6:	c0 38       	rjmp	800082ac <_vfprintf_r+0x1c0>
800082a8:	30 0b       	mov	r11,0
800082aa:	50 3b       	stdsp	sp[0xc],r11
800082ac:	0f 38       	ld.ub	r8,r7++
800082ae:	c0 28       	rjmp	800082b2 <_vfprintf_r+0x1c6>
800082b0:	12 90       	mov	r0,r9
800082b2:	f0 c9 00 20 	sub	r9,r8,32
800082b6:	e0 49 00 58 	cp.w	r9,88
800082ba:	e0 8b 0a 30 	brhi	8000971a <_vfprintf_r+0x162e>
800082be:	fe ca a5 66 	sub	r10,pc,-23194
800082c2:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
800082c6:	50 a7       	stdsp	sp[0x28],r7
800082c8:	50 80       	stdsp	sp[0x20],r0
800082ca:	0c 97       	mov	r7,r6
800082cc:	04 94       	mov	r4,r2
800082ce:	06 96       	mov	r6,r3
800082d0:	02 92       	mov	r2,r1
800082d2:	fe c9 a3 3e 	sub	r9,pc,-23746
800082d6:	40 93       	lddsp	r3,sp[0x24]
800082d8:	10 90       	mov	r0,r8
800082da:	40 41       	lddsp	r1,sp[0x10]
800082dc:	50 d9       	stdsp	sp[0x34],r9
800082de:	e0 8f 08 8e 	bral	800093fa <_vfprintf_r+0x130e>
800082e2:	30 08       	mov	r8,0
800082e4:	fb 39 06 bb 	ld.ub	r9,sp[1723]
800082e8:	f0 09 18 00 	cp.b	r9,r8
800082ec:	ce 01       	brne	800082ac <_vfprintf_r+0x1c0>
800082ee:	32 08       	mov	r8,32
800082f0:	c6 e8       	rjmp	800083cc <_vfprintf_r+0x2e0>
800082f2:	a1 a5       	sbr	r5,0x0
800082f4:	cd cb       	rjmp	800082ac <_vfprintf_r+0x1c0>
800082f6:	0f 89       	ld.ub	r9,r7[0x0]
800082f8:	f2 c8 00 30 	sub	r8,r9,48
800082fc:	58 98       	cp.w	r8,9
800082fe:	e0 8b 00 1d 	brhi	80008338 <_vfprintf_r+0x24c>
80008302:	ee c8 ff ff 	sub	r8,r7,-1
80008306:	30 0b       	mov	r11,0
80008308:	23 09       	sub	r9,48
8000830a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000830e:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80008312:	11 39       	ld.ub	r9,r8++
80008314:	f2 ca 00 30 	sub	r10,r9,48
80008318:	58 9a       	cp.w	r10,9
8000831a:	fe 98 ff f7 	brls	80008308 <_vfprintf_r+0x21c>
8000831e:	e0 49 00 24 	cp.w	r9,36
80008322:	cc 31       	brne	800082a8 <_vfprintf_r+0x1bc>
80008324:	e0 4b 00 20 	cp.w	r11,32
80008328:	e0 89 0e 60 	brgt	80009fe8 <_vfprintf_r+0x1efc>
8000832c:	20 1b       	sub	r11,1
8000832e:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008332:	12 3b       	cp.w	r11,r9
80008334:	c0 95       	brlt	80008346 <_vfprintf_r+0x25a>
80008336:	c1 08       	rjmp	80008356 <_vfprintf_r+0x26a>
80008338:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000833c:	ec ca ff ff 	sub	r10,r6,-1
80008340:	12 36       	cp.w	r6,r9
80008342:	c1 f5       	brlt	80008380 <_vfprintf_r+0x294>
80008344:	c2 68       	rjmp	80008390 <_vfprintf_r+0x2a4>
80008346:	fa ce f9 44 	sub	lr,sp,-1724
8000834a:	10 97       	mov	r7,r8
8000834c:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80008350:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80008354:	c3 58       	rjmp	800083be <_vfprintf_r+0x2d2>
80008356:	10 97       	mov	r7,r8
80008358:	fa c8 f9 50 	sub	r8,sp,-1712
8000835c:	1a d8       	st.w	--sp,r8
8000835e:	fa c8 fa b8 	sub	r8,sp,-1352
80008362:	1a d8       	st.w	--sp,r8
80008364:	fa c8 fb b4 	sub	r8,sp,-1100
80008368:	02 9a       	mov	r10,r1
8000836a:	1a d8       	st.w	--sp,r8
8000836c:	04 9c       	mov	r12,r2
8000836e:	fa c8 f9 40 	sub	r8,sp,-1728
80008372:	fa c9 ff b4 	sub	r9,sp,-76
80008376:	fe b0 fd 23 	rcall	80007dbc <get_arg>
8000837a:	2f dd       	sub	sp,-12
8000837c:	78 00       	ld.w	r0,r12[0x0]
8000837e:	c2 08       	rjmp	800083be <_vfprintf_r+0x2d2>
80008380:	fa cc f9 44 	sub	r12,sp,-1724
80008384:	14 96       	mov	r6,r10
80008386:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000838a:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000838e:	c1 88       	rjmp	800083be <_vfprintf_r+0x2d2>
80008390:	41 08       	lddsp	r8,sp[0x40]
80008392:	59 f9       	cp.w	r9,31
80008394:	e0 89 00 11 	brgt	800083b6 <_vfprintf_r+0x2ca>
80008398:	f0 cb ff fc 	sub	r11,r8,-4
8000839c:	51 0b       	stdsp	sp[0x40],r11
8000839e:	70 00       	ld.w	r0,r8[0x0]
800083a0:	fa cb f9 44 	sub	r11,sp,-1724
800083a4:	f6 09 00 38 	add	r8,r11,r9<<0x3
800083a8:	f1 40 fd 88 	st.w	r8[-632],r0
800083ac:	2f f9       	sub	r9,-1
800083ae:	14 96       	mov	r6,r10
800083b0:	fb 49 06 b4 	st.w	sp[1716],r9
800083b4:	c0 58       	rjmp	800083be <_vfprintf_r+0x2d2>
800083b6:	70 00       	ld.w	r0,r8[0x0]
800083b8:	14 96       	mov	r6,r10
800083ba:	2f c8       	sub	r8,-4
800083bc:	51 08       	stdsp	sp[0x40],r8
800083be:	58 00       	cp.w	r0,0
800083c0:	fe 94 ff 76 	brge	800082ac <_vfprintf_r+0x1c0>
800083c4:	5c 30       	neg	r0
800083c6:	a3 a5       	sbr	r5,0x2
800083c8:	c7 2b       	rjmp	800082ac <_vfprintf_r+0x1c0>
800083ca:	32 b8       	mov	r8,43
800083cc:	fb 68 06 bb 	st.b	sp[1723],r8
800083d0:	c6 eb       	rjmp	800082ac <_vfprintf_r+0x1c0>
800083d2:	0f 38       	ld.ub	r8,r7++
800083d4:	e0 48 00 2a 	cp.w	r8,42
800083d8:	c0 30       	breq	800083de <_vfprintf_r+0x2f2>
800083da:	30 09       	mov	r9,0
800083dc:	c7 98       	rjmp	800084ce <_vfprintf_r+0x3e2>
800083de:	0f 88       	ld.ub	r8,r7[0x0]
800083e0:	f0 c9 00 30 	sub	r9,r8,48
800083e4:	58 99       	cp.w	r9,9
800083e6:	e0 8b 00 1f 	brhi	80008424 <_vfprintf_r+0x338>
800083ea:	ee c4 ff ff 	sub	r4,r7,-1
800083ee:	30 0b       	mov	r11,0
800083f0:	23 08       	sub	r8,48
800083f2:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800083f6:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
800083fa:	09 38       	ld.ub	r8,r4++
800083fc:	f0 c9 00 30 	sub	r9,r8,48
80008400:	58 99       	cp.w	r9,9
80008402:	fe 98 ff f7 	brls	800083f0 <_vfprintf_r+0x304>
80008406:	e0 48 00 24 	cp.w	r8,36
8000840a:	fe 91 ff 4f 	brne	800082a8 <_vfprintf_r+0x1bc>
8000840e:	e0 4b 00 20 	cp.w	r11,32
80008412:	e0 89 0d eb 	brgt	80009fe8 <_vfprintf_r+0x1efc>
80008416:	20 1b       	sub	r11,1
80008418:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000841c:	10 3b       	cp.w	r11,r8
8000841e:	c0 a5       	brlt	80008432 <_vfprintf_r+0x346>
80008420:	c1 18       	rjmp	80008442 <_vfprintf_r+0x356>
80008422:	d7 03       	nop
80008424:	fa fa 06 b4 	ld.w	r10,sp[1716]
80008428:	ec c9 ff ff 	sub	r9,r6,-1
8000842c:	14 36       	cp.w	r6,r10
8000842e:	c1 f5       	brlt	8000846c <_vfprintf_r+0x380>
80008430:	c2 88       	rjmp	80008480 <_vfprintf_r+0x394>
80008432:	fa ca f9 44 	sub	r10,sp,-1724
80008436:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000843a:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000843e:	50 2b       	stdsp	sp[0x8],r11
80008440:	c3 c8       	rjmp	800084b8 <_vfprintf_r+0x3cc>
80008442:	fa c8 f9 50 	sub	r8,sp,-1712
80008446:	1a d8       	st.w	--sp,r8
80008448:	fa c8 fa b8 	sub	r8,sp,-1352
8000844c:	1a d8       	st.w	--sp,r8
8000844e:	fa c8 fb b4 	sub	r8,sp,-1100
80008452:	02 9a       	mov	r10,r1
80008454:	1a d8       	st.w	--sp,r8
80008456:	04 9c       	mov	r12,r2
80008458:	fa c8 f9 40 	sub	r8,sp,-1728
8000845c:	fa c9 ff b4 	sub	r9,sp,-76
80008460:	fe b0 fc ae 	rcall	80007dbc <get_arg>
80008464:	2f dd       	sub	sp,-12
80008466:	78 0c       	ld.w	r12,r12[0x0]
80008468:	50 2c       	stdsp	sp[0x8],r12
8000846a:	c2 78       	rjmp	800084b8 <_vfprintf_r+0x3cc>
8000846c:	12 96       	mov	r6,r9
8000846e:	0e 94       	mov	r4,r7
80008470:	fa c9 f9 44 	sub	r9,sp,-1724
80008474:	f2 03 00 38 	add	r8,r9,r3<<0x3
80008478:	f0 f8 fd 88 	ld.w	r8,r8[-632]
8000847c:	50 28       	stdsp	sp[0x8],r8
8000847e:	c1 d8       	rjmp	800084b8 <_vfprintf_r+0x3cc>
80008480:	41 08       	lddsp	r8,sp[0x40]
80008482:	59 fa       	cp.w	r10,31
80008484:	e0 89 00 14 	brgt	800084ac <_vfprintf_r+0x3c0>
80008488:	f0 cb ff fc 	sub	r11,r8,-4
8000848c:	70 08       	ld.w	r8,r8[0x0]
8000848e:	51 0b       	stdsp	sp[0x40],r11
80008490:	50 28       	stdsp	sp[0x8],r8
80008492:	fa c6 f9 44 	sub	r6,sp,-1724
80008496:	40 2e       	lddsp	lr,sp[0x8]
80008498:	ec 0a 00 38 	add	r8,r6,r10<<0x3
8000849c:	f1 4e fd 88 	st.w	r8[-632],lr
800084a0:	2f fa       	sub	r10,-1
800084a2:	0e 94       	mov	r4,r7
800084a4:	fb 4a 06 b4 	st.w	sp[1716],r10
800084a8:	12 96       	mov	r6,r9
800084aa:	c0 78       	rjmp	800084b8 <_vfprintf_r+0x3cc>
800084ac:	70 0c       	ld.w	r12,r8[0x0]
800084ae:	0e 94       	mov	r4,r7
800084b0:	2f c8       	sub	r8,-4
800084b2:	50 2c       	stdsp	sp[0x8],r12
800084b4:	12 96       	mov	r6,r9
800084b6:	51 08       	stdsp	sp[0x40],r8
800084b8:	40 2b       	lddsp	r11,sp[0x8]
800084ba:	58 0b       	cp.w	r11,0
800084bc:	fe 95 fe f2 	brlt	800082a0 <_vfprintf_r+0x1b4>
800084c0:	08 97       	mov	r7,r4
800084c2:	cf 5a       	rjmp	800082ac <_vfprintf_r+0x1c0>
800084c4:	f2 09 00 29 	add	r9,r9,r9<<0x2
800084c8:	0f 38       	ld.ub	r8,r7++
800084ca:	f4 09 00 19 	add	r9,r10,r9<<0x1
800084ce:	f0 ca 00 30 	sub	r10,r8,48
800084d2:	58 9a       	cp.w	r10,9
800084d4:	fe 98 ff f8 	brls	800084c4 <_vfprintf_r+0x3d8>
800084d8:	3f fa       	mov	r10,-1
800084da:	f2 0a 0c 49 	max	r9,r9,r10
800084de:	50 29       	stdsp	sp[0x8],r9
800084e0:	ce 9a       	rjmp	800082b2 <_vfprintf_r+0x1c6>
800084e2:	a7 b5       	sbr	r5,0x7
800084e4:	ce 4a       	rjmp	800082ac <_vfprintf_r+0x1c0>
800084e6:	30 09       	mov	r9,0
800084e8:	23 08       	sub	r8,48
800084ea:	f2 09 00 29 	add	r9,r9,r9<<0x2
800084ee:	f0 09 00 19 	add	r9,r8,r9<<0x1
800084f2:	0f 38       	ld.ub	r8,r7++
800084f4:	f0 ca 00 30 	sub	r10,r8,48
800084f8:	58 9a       	cp.w	r10,9
800084fa:	fe 98 ff f7 	brls	800084e8 <_vfprintf_r+0x3fc>
800084fe:	e0 48 00 24 	cp.w	r8,36
80008502:	fe 91 fe d7 	brne	800082b0 <_vfprintf_r+0x1c4>
80008506:	e0 49 00 20 	cp.w	r9,32
8000850a:	e0 89 0d 6f 	brgt	80009fe8 <_vfprintf_r+0x1efc>
8000850e:	f2 c3 00 01 	sub	r3,r9,1
80008512:	30 19       	mov	r9,1
80008514:	50 39       	stdsp	sp[0xc],r9
80008516:	cc ba       	rjmp	800082ac <_vfprintf_r+0x1c0>
80008518:	a3 b5       	sbr	r5,0x3
8000851a:	cc 9a       	rjmp	800082ac <_vfprintf_r+0x1c0>
8000851c:	a7 a5       	sbr	r5,0x6
8000851e:	cc 7a       	rjmp	800082ac <_vfprintf_r+0x1c0>
80008520:	0a 98       	mov	r8,r5
80008522:	a5 b5       	sbr	r5,0x5
80008524:	a5 a8       	sbr	r8,0x4
80008526:	0f 89       	ld.ub	r9,r7[0x0]
80008528:	36 ce       	mov	lr,108
8000852a:	fc 09 18 00 	cp.b	r9,lr
8000852e:	f7 b7 00 ff 	subeq	r7,-1
80008532:	f0 05 17 10 	movne	r5,r8
80008536:	cb ba       	rjmp	800082ac <_vfprintf_r+0x1c0>
80008538:	a5 b5       	sbr	r5,0x5
8000853a:	cb 9a       	rjmp	800082ac <_vfprintf_r+0x1c0>
8000853c:	50 a7       	stdsp	sp[0x28],r7
8000853e:	50 80       	stdsp	sp[0x20],r0
80008540:	0c 97       	mov	r7,r6
80008542:	10 90       	mov	r0,r8
80008544:	06 96       	mov	r6,r3
80008546:	04 94       	mov	r4,r2
80008548:	40 93       	lddsp	r3,sp[0x24]
8000854a:	02 92       	mov	r2,r1
8000854c:	0e 99       	mov	r9,r7
8000854e:	40 41       	lddsp	r1,sp[0x10]
80008550:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008554:	40 3c       	lddsp	r12,sp[0xc]
80008556:	58 0c       	cp.w	r12,0
80008558:	c1 d0       	breq	80008592 <_vfprintf_r+0x4a6>
8000855a:	10 36       	cp.w	r6,r8
8000855c:	c0 64       	brge	80008568 <_vfprintf_r+0x47c>
8000855e:	fa cb f9 44 	sub	r11,sp,-1724
80008562:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008566:	c1 d8       	rjmp	800085a0 <_vfprintf_r+0x4b4>
80008568:	fa c8 f9 50 	sub	r8,sp,-1712
8000856c:	1a d8       	st.w	--sp,r8
8000856e:	fa c8 fa b8 	sub	r8,sp,-1352
80008572:	1a d8       	st.w	--sp,r8
80008574:	fa c8 fb b4 	sub	r8,sp,-1100
80008578:	1a d8       	st.w	--sp,r8
8000857a:	fa c8 f9 40 	sub	r8,sp,-1728
8000857e:	fa c9 ff b4 	sub	r9,sp,-76
80008582:	04 9a       	mov	r10,r2
80008584:	0c 9b       	mov	r11,r6
80008586:	08 9c       	mov	r12,r4
80008588:	fe b0 fc 1a 	rcall	80007dbc <get_arg>
8000858c:	2f dd       	sub	sp,-12
8000858e:	19 b8       	ld.ub	r8,r12[0x3]
80008590:	c2 28       	rjmp	800085d4 <_vfprintf_r+0x4e8>
80008592:	2f f7       	sub	r7,-1
80008594:	10 39       	cp.w	r9,r8
80008596:	c0 84       	brge	800085a6 <_vfprintf_r+0x4ba>
80008598:	fa ca f9 44 	sub	r10,sp,-1724
8000859c:	f4 06 00 36 	add	r6,r10,r6<<0x3
800085a0:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
800085a4:	c1 88       	rjmp	800085d4 <_vfprintf_r+0x4e8>
800085a6:	41 09       	lddsp	r9,sp[0x40]
800085a8:	59 f8       	cp.w	r8,31
800085aa:	e0 89 00 12 	brgt	800085ce <_vfprintf_r+0x4e2>
800085ae:	f2 ca ff fc 	sub	r10,r9,-4
800085b2:	51 0a       	stdsp	sp[0x40],r10
800085b4:	72 09       	ld.w	r9,r9[0x0]
800085b6:	fa c6 f9 44 	sub	r6,sp,-1724
800085ba:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800085be:	2f f8       	sub	r8,-1
800085c0:	f5 49 fd 88 	st.w	r10[-632],r9
800085c4:	fb 48 06 b4 	st.w	sp[1716],r8
800085c8:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800085cc:	c0 48       	rjmp	800085d4 <_vfprintf_r+0x4e8>
800085ce:	13 b8       	ld.ub	r8,r9[0x3]
800085d0:	2f c9       	sub	r9,-4
800085d2:	51 09       	stdsp	sp[0x40],r9
800085d4:	fb 68 06 60 	st.b	sp[1632],r8
800085d8:	30 0e       	mov	lr,0
800085da:	30 08       	mov	r8,0
800085dc:	30 12       	mov	r2,1
800085de:	fb 68 06 bb 	st.b	sp[1723],r8
800085e2:	50 2e       	stdsp	sp[0x8],lr
800085e4:	e0 8f 08 ad 	bral	8000973e <_vfprintf_r+0x1652>
800085e8:	50 a7       	stdsp	sp[0x28],r7
800085ea:	50 80       	stdsp	sp[0x20],r0
800085ec:	0c 97       	mov	r7,r6
800085ee:	04 94       	mov	r4,r2
800085f0:	06 96       	mov	r6,r3
800085f2:	02 92       	mov	r2,r1
800085f4:	40 93       	lddsp	r3,sp[0x24]
800085f6:	10 90       	mov	r0,r8
800085f8:	40 41       	lddsp	r1,sp[0x10]
800085fa:	a5 a5       	sbr	r5,0x4
800085fc:	c0 a8       	rjmp	80008610 <_vfprintf_r+0x524>
800085fe:	50 a7       	stdsp	sp[0x28],r7
80008600:	50 80       	stdsp	sp[0x20],r0
80008602:	0c 97       	mov	r7,r6
80008604:	04 94       	mov	r4,r2
80008606:	06 96       	mov	r6,r3
80008608:	02 92       	mov	r2,r1
8000860a:	40 93       	lddsp	r3,sp[0x24]
8000860c:	10 90       	mov	r0,r8
8000860e:	40 41       	lddsp	r1,sp[0x10]
80008610:	ed b5 00 05 	bld	r5,0x5
80008614:	c5 11       	brne	800086b6 <_vfprintf_r+0x5ca>
80008616:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000861a:	40 3c       	lddsp	r12,sp[0xc]
8000861c:	58 0c       	cp.w	r12,0
8000861e:	c1 e0       	breq	8000865a <_vfprintf_r+0x56e>
80008620:	10 36       	cp.w	r6,r8
80008622:	c0 64       	brge	8000862e <_vfprintf_r+0x542>
80008624:	fa cb f9 44 	sub	r11,sp,-1724
80008628:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000862c:	c2 08       	rjmp	8000866c <_vfprintf_r+0x580>
8000862e:	fa c8 f9 50 	sub	r8,sp,-1712
80008632:	1a d8       	st.w	--sp,r8
80008634:	fa c8 fa b8 	sub	r8,sp,-1352
80008638:	0c 9b       	mov	r11,r6
8000863a:	1a d8       	st.w	--sp,r8
8000863c:	fa c8 fb b4 	sub	r8,sp,-1100
80008640:	1a d8       	st.w	--sp,r8
80008642:	fa c9 ff b4 	sub	r9,sp,-76
80008646:	fa c8 f9 40 	sub	r8,sp,-1728
8000864a:	04 9a       	mov	r10,r2
8000864c:	08 9c       	mov	r12,r4
8000864e:	fe b0 fb b7 	rcall	80007dbc <get_arg>
80008652:	2f dd       	sub	sp,-12
80008654:	78 1b       	ld.w	r11,r12[0x4]
80008656:	78 09       	ld.w	r9,r12[0x0]
80008658:	c2 b8       	rjmp	800086ae <_vfprintf_r+0x5c2>
8000865a:	ee ca ff ff 	sub	r10,r7,-1
8000865e:	10 37       	cp.w	r7,r8
80008660:	c0 b4       	brge	80008676 <_vfprintf_r+0x58a>
80008662:	fa c9 f9 44 	sub	r9,sp,-1724
80008666:	14 97       	mov	r7,r10
80008668:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000866c:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008670:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008674:	c1 d8       	rjmp	800086ae <_vfprintf_r+0x5c2>
80008676:	41 09       	lddsp	r9,sp[0x40]
80008678:	59 f8       	cp.w	r8,31
8000867a:	e0 89 00 14 	brgt	800086a2 <_vfprintf_r+0x5b6>
8000867e:	f2 cb ff f8 	sub	r11,r9,-8
80008682:	51 0b       	stdsp	sp[0x40],r11
80008684:	fa c6 f9 44 	sub	r6,sp,-1724
80008688:	72 1b       	ld.w	r11,r9[0x4]
8000868a:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000868e:	72 09       	ld.w	r9,r9[0x0]
80008690:	f9 4b fd 8c 	st.w	r12[-628],r11
80008694:	f9 49 fd 88 	st.w	r12[-632],r9
80008698:	2f f8       	sub	r8,-1
8000869a:	14 97       	mov	r7,r10
8000869c:	fb 48 06 b4 	st.w	sp[1716],r8
800086a0:	c0 78       	rjmp	800086ae <_vfprintf_r+0x5c2>
800086a2:	f2 c8 ff f8 	sub	r8,r9,-8
800086a6:	72 1b       	ld.w	r11,r9[0x4]
800086a8:	14 97       	mov	r7,r10
800086aa:	51 08       	stdsp	sp[0x40],r8
800086ac:	72 09       	ld.w	r9,r9[0x0]
800086ae:	16 98       	mov	r8,r11
800086b0:	fa e9 00 00 	st.d	sp[0],r8
800086b4:	ca e8       	rjmp	80008810 <_vfprintf_r+0x724>
800086b6:	ed b5 00 04 	bld	r5,0x4
800086ba:	c1 71       	brne	800086e8 <_vfprintf_r+0x5fc>
800086bc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086c0:	40 3e       	lddsp	lr,sp[0xc]
800086c2:	58 0e       	cp.w	lr,0
800086c4:	c0 80       	breq	800086d4 <_vfprintf_r+0x5e8>
800086c6:	10 36       	cp.w	r6,r8
800086c8:	c6 94       	brge	8000879a <_vfprintf_r+0x6ae>
800086ca:	fa cc f9 44 	sub	r12,sp,-1724
800086ce:	f8 06 00 36 	add	r6,r12,r6<<0x3
800086d2:	c8 28       	rjmp	800087d6 <_vfprintf_r+0x6ea>
800086d4:	ee ca ff ff 	sub	r10,r7,-1
800086d8:	10 37       	cp.w	r7,r8
800086da:	e0 84 00 81 	brge	800087dc <_vfprintf_r+0x6f0>
800086de:	fa cb f9 44 	sub	r11,sp,-1724
800086e2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800086e6:	c7 78       	rjmp	800087d4 <_vfprintf_r+0x6e8>
800086e8:	ed b5 00 06 	bld	r5,0x6
800086ec:	c4 b1       	brne	80008782 <_vfprintf_r+0x696>
800086ee:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086f2:	40 3c       	lddsp	r12,sp[0xc]
800086f4:	58 0c       	cp.w	r12,0
800086f6:	c1 d0       	breq	80008730 <_vfprintf_r+0x644>
800086f8:	10 36       	cp.w	r6,r8
800086fa:	c0 64       	brge	80008706 <_vfprintf_r+0x61a>
800086fc:	fa cb f9 44 	sub	r11,sp,-1724
80008700:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008704:	c1 f8       	rjmp	80008742 <_vfprintf_r+0x656>
80008706:	fa c8 f9 50 	sub	r8,sp,-1712
8000870a:	1a d8       	st.w	--sp,r8
8000870c:	fa c8 fa b8 	sub	r8,sp,-1352
80008710:	1a d8       	st.w	--sp,r8
80008712:	fa c8 fb b4 	sub	r8,sp,-1100
80008716:	1a d8       	st.w	--sp,r8
80008718:	fa c8 f9 40 	sub	r8,sp,-1728
8000871c:	fa c9 ff b4 	sub	r9,sp,-76
80008720:	04 9a       	mov	r10,r2
80008722:	0c 9b       	mov	r11,r6
80008724:	08 9c       	mov	r12,r4
80008726:	fe b0 fb 4b 	rcall	80007dbc <get_arg>
8000872a:	2f dd       	sub	sp,-12
8000872c:	98 18       	ld.sh	r8,r12[0x2]
8000872e:	c2 68       	rjmp	8000877a <_vfprintf_r+0x68e>
80008730:	ee ca ff ff 	sub	r10,r7,-1
80008734:	10 37       	cp.w	r7,r8
80008736:	c0 94       	brge	80008748 <_vfprintf_r+0x65c>
80008738:	fa c9 f9 44 	sub	r9,sp,-1724
8000873c:	14 97       	mov	r7,r10
8000873e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008742:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008746:	c1 a8       	rjmp	8000877a <_vfprintf_r+0x68e>
80008748:	41 09       	lddsp	r9,sp[0x40]
8000874a:	59 f8       	cp.w	r8,31
8000874c:	e0 89 00 13 	brgt	80008772 <_vfprintf_r+0x686>
80008750:	f2 cb ff fc 	sub	r11,r9,-4
80008754:	51 0b       	stdsp	sp[0x40],r11
80008756:	72 09       	ld.w	r9,r9[0x0]
80008758:	fa c6 f9 44 	sub	r6,sp,-1724
8000875c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008760:	2f f8       	sub	r8,-1
80008762:	f7 49 fd 88 	st.w	r11[-632],r9
80008766:	fb 48 06 b4 	st.w	sp[1716],r8
8000876a:	14 97       	mov	r7,r10
8000876c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008770:	c0 58       	rjmp	8000877a <_vfprintf_r+0x68e>
80008772:	92 18       	ld.sh	r8,r9[0x2]
80008774:	14 97       	mov	r7,r10
80008776:	2f c9       	sub	r9,-4
80008778:	51 09       	stdsp	sp[0x40],r9
8000877a:	50 18       	stdsp	sp[0x4],r8
8000877c:	bf 58       	asr	r8,0x1f
8000877e:	50 08       	stdsp	sp[0x0],r8
80008780:	c4 88       	rjmp	80008810 <_vfprintf_r+0x724>
80008782:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008786:	40 3c       	lddsp	r12,sp[0xc]
80008788:	58 0c       	cp.w	r12,0
8000878a:	c1 d0       	breq	800087c4 <_vfprintf_r+0x6d8>
8000878c:	10 36       	cp.w	r6,r8
8000878e:	c0 64       	brge	8000879a <_vfprintf_r+0x6ae>
80008790:	fa cb f9 44 	sub	r11,sp,-1724
80008794:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008798:	c1 f8       	rjmp	800087d6 <_vfprintf_r+0x6ea>
8000879a:	fa c8 f9 50 	sub	r8,sp,-1712
8000879e:	1a d8       	st.w	--sp,r8
800087a0:	fa c8 fa b8 	sub	r8,sp,-1352
800087a4:	0c 9b       	mov	r11,r6
800087a6:	1a d8       	st.w	--sp,r8
800087a8:	fa c8 fb b4 	sub	r8,sp,-1100
800087ac:	04 9a       	mov	r10,r2
800087ae:	1a d8       	st.w	--sp,r8
800087b0:	08 9c       	mov	r12,r4
800087b2:	fa c8 f9 40 	sub	r8,sp,-1728
800087b6:	fa c9 ff b4 	sub	r9,sp,-76
800087ba:	fe b0 fb 01 	rcall	80007dbc <get_arg>
800087be:	2f dd       	sub	sp,-12
800087c0:	78 0b       	ld.w	r11,r12[0x0]
800087c2:	c2 48       	rjmp	8000880a <_vfprintf_r+0x71e>
800087c4:	ee ca ff ff 	sub	r10,r7,-1
800087c8:	10 37       	cp.w	r7,r8
800087ca:	c0 94       	brge	800087dc <_vfprintf_r+0x6f0>
800087cc:	fa c9 f9 44 	sub	r9,sp,-1724
800087d0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800087d4:	14 97       	mov	r7,r10
800087d6:	ec fb fd 88 	ld.w	r11,r6[-632]
800087da:	c1 88       	rjmp	8000880a <_vfprintf_r+0x71e>
800087dc:	41 09       	lddsp	r9,sp[0x40]
800087de:	59 f8       	cp.w	r8,31
800087e0:	e0 89 00 11 	brgt	80008802 <_vfprintf_r+0x716>
800087e4:	f2 cb ff fc 	sub	r11,r9,-4
800087e8:	51 0b       	stdsp	sp[0x40],r11
800087ea:	fa c6 f9 44 	sub	r6,sp,-1724
800087ee:	72 0b       	ld.w	r11,r9[0x0]
800087f0:	ec 08 00 39 	add	r9,r6,r8<<0x3
800087f4:	f3 4b fd 88 	st.w	r9[-632],r11
800087f8:	2f f8       	sub	r8,-1
800087fa:	14 97       	mov	r7,r10
800087fc:	fb 48 06 b4 	st.w	sp[1716],r8
80008800:	c0 58       	rjmp	8000880a <_vfprintf_r+0x71e>
80008802:	72 0b       	ld.w	r11,r9[0x0]
80008804:	14 97       	mov	r7,r10
80008806:	2f c9       	sub	r9,-4
80008808:	51 09       	stdsp	sp[0x40],r9
8000880a:	50 1b       	stdsp	sp[0x4],r11
8000880c:	bf 5b       	asr	r11,0x1f
8000880e:	50 0b       	stdsp	sp[0x0],r11
80008810:	fa ea 00 00 	ld.d	r10,sp[0]
80008814:	58 0a       	cp.w	r10,0
80008816:	5c 2b       	cpc	r11
80008818:	c0 e4       	brge	80008834 <_vfprintf_r+0x748>
8000881a:	30 08       	mov	r8,0
8000881c:	fa ea 00 00 	ld.d	r10,sp[0]
80008820:	30 09       	mov	r9,0
80008822:	f0 0a 01 0a 	sub	r10,r8,r10
80008826:	f2 0b 01 4b 	sbc	r11,r9,r11
8000882a:	32 d8       	mov	r8,45
8000882c:	fa eb 00 00 	st.d	sp[0],r10
80008830:	fb 68 06 bb 	st.b	sp[1723],r8
80008834:	30 18       	mov	r8,1
80008836:	e0 8f 06 fa 	bral	8000962a <_vfprintf_r+0x153e>
8000883a:	50 a7       	stdsp	sp[0x28],r7
8000883c:	50 80       	stdsp	sp[0x20],r0
8000883e:	0c 97       	mov	r7,r6
80008840:	04 94       	mov	r4,r2
80008842:	06 96       	mov	r6,r3
80008844:	02 92       	mov	r2,r1
80008846:	40 93       	lddsp	r3,sp[0x24]
80008848:	10 90       	mov	r0,r8
8000884a:	40 41       	lddsp	r1,sp[0x10]
8000884c:	0e 99       	mov	r9,r7
8000884e:	ed b5 00 03 	bld	r5,0x3
80008852:	c4 11       	brne	800088d4 <_vfprintf_r+0x7e8>
80008854:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008858:	40 3a       	lddsp	r10,sp[0xc]
8000885a:	58 0a       	cp.w	r10,0
8000885c:	c1 90       	breq	8000888e <_vfprintf_r+0x7a2>
8000885e:	10 36       	cp.w	r6,r8
80008860:	c6 45       	brlt	80008928 <_vfprintf_r+0x83c>
80008862:	fa c8 f9 50 	sub	r8,sp,-1712
80008866:	1a d8       	st.w	--sp,r8
80008868:	fa c8 fa b8 	sub	r8,sp,-1352
8000886c:	1a d8       	st.w	--sp,r8
8000886e:	fa c8 fb b4 	sub	r8,sp,-1100
80008872:	0c 9b       	mov	r11,r6
80008874:	1a d8       	st.w	--sp,r8
80008876:	04 9a       	mov	r10,r2
80008878:	fa c8 f9 40 	sub	r8,sp,-1728
8000887c:	fa c9 ff b4 	sub	r9,sp,-76
80008880:	08 9c       	mov	r12,r4
80008882:	fe b0 fa 9d 	rcall	80007dbc <get_arg>
80008886:	2f dd       	sub	sp,-12
80008888:	78 16       	ld.w	r6,r12[0x4]
8000888a:	50 76       	stdsp	sp[0x1c],r6
8000888c:	c4 88       	rjmp	8000891c <_vfprintf_r+0x830>
8000888e:	2f f7       	sub	r7,-1
80008890:	10 39       	cp.w	r9,r8
80008892:	c0 c4       	brge	800088aa <_vfprintf_r+0x7be>
80008894:	fa ce f9 44 	sub	lr,sp,-1724
80008898:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000889c:	ec fc fd 8c 	ld.w	r12,r6[-628]
800088a0:	50 7c       	stdsp	sp[0x1c],r12
800088a2:	ec f6 fd 88 	ld.w	r6,r6[-632]
800088a6:	50 56       	stdsp	sp[0x14],r6
800088a8:	c6 68       	rjmp	80008974 <_vfprintf_r+0x888>
800088aa:	41 09       	lddsp	r9,sp[0x40]
800088ac:	59 f8       	cp.w	r8,31
800088ae:	e0 89 00 10 	brgt	800088ce <_vfprintf_r+0x7e2>
800088b2:	f2 ca ff f8 	sub	r10,r9,-8
800088b6:	72 1b       	ld.w	r11,r9[0x4]
800088b8:	51 0a       	stdsp	sp[0x40],r10
800088ba:	72 09       	ld.w	r9,r9[0x0]
800088bc:	fa ca f9 44 	sub	r10,sp,-1724
800088c0:	50 7b       	stdsp	sp[0x1c],r11
800088c2:	50 59       	stdsp	sp[0x14],r9
800088c4:	f4 08 00 39 	add	r9,r10,r8<<0x3
800088c8:	40 5b       	lddsp	r11,sp[0x14]
800088ca:	40 7a       	lddsp	r10,sp[0x1c]
800088cc:	c4 78       	rjmp	8000895a <_vfprintf_r+0x86e>
800088ce:	72 18       	ld.w	r8,r9[0x4]
800088d0:	50 78       	stdsp	sp[0x1c],r8
800088d2:	c4 c8       	rjmp	8000896a <_vfprintf_r+0x87e>
800088d4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800088d8:	40 3e       	lddsp	lr,sp[0xc]
800088da:	58 0e       	cp.w	lr,0
800088dc:	c2 30       	breq	80008922 <_vfprintf_r+0x836>
800088de:	10 36       	cp.w	r6,r8
800088e0:	c0 94       	brge	800088f2 <_vfprintf_r+0x806>
800088e2:	fa cc f9 44 	sub	r12,sp,-1724
800088e6:	f8 06 00 36 	add	r6,r12,r6<<0x3
800088ea:	ec fb fd 8c 	ld.w	r11,r6[-628]
800088ee:	50 7b       	stdsp	sp[0x1c],r11
800088f0:	cd 9b       	rjmp	800088a2 <_vfprintf_r+0x7b6>
800088f2:	fa c8 f9 50 	sub	r8,sp,-1712
800088f6:	1a d8       	st.w	--sp,r8
800088f8:	fa c8 fa b8 	sub	r8,sp,-1352
800088fc:	04 9a       	mov	r10,r2
800088fe:	1a d8       	st.w	--sp,r8
80008900:	fa c8 fb b4 	sub	r8,sp,-1100
80008904:	0c 9b       	mov	r11,r6
80008906:	1a d8       	st.w	--sp,r8
80008908:	08 9c       	mov	r12,r4
8000890a:	fa c8 f9 40 	sub	r8,sp,-1728
8000890e:	fa c9 ff b4 	sub	r9,sp,-76
80008912:	fe b0 fa 55 	rcall	80007dbc <get_arg>
80008916:	2f dd       	sub	sp,-12
80008918:	78 1a       	ld.w	r10,r12[0x4]
8000891a:	50 7a       	stdsp	sp[0x1c],r10
8000891c:	78 0c       	ld.w	r12,r12[0x0]
8000891e:	50 5c       	stdsp	sp[0x14],r12
80008920:	c2 a8       	rjmp	80008974 <_vfprintf_r+0x888>
80008922:	2f f7       	sub	r7,-1
80008924:	10 39       	cp.w	r9,r8
80008926:	c0 94       	brge	80008938 <_vfprintf_r+0x84c>
80008928:	fa c9 f9 44 	sub	r9,sp,-1724
8000892c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008930:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80008934:	50 78       	stdsp	sp[0x1c],r8
80008936:	cb 6b       	rjmp	800088a2 <_vfprintf_r+0x7b6>
80008938:	41 09       	lddsp	r9,sp[0x40]
8000893a:	59 f8       	cp.w	r8,31
8000893c:	e0 89 00 15 	brgt	80008966 <_vfprintf_r+0x87a>
80008940:	f2 ca ff f8 	sub	r10,r9,-8
80008944:	72 16       	ld.w	r6,r9[0x4]
80008946:	72 09       	ld.w	r9,r9[0x0]
80008948:	51 0a       	stdsp	sp[0x40],r10
8000894a:	50 59       	stdsp	sp[0x14],r9
8000894c:	fa ce f9 44 	sub	lr,sp,-1724
80008950:	50 76       	stdsp	sp[0x1c],r6
80008952:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008956:	40 5b       	lddsp	r11,sp[0x14]
80008958:	0c 9a       	mov	r10,r6
8000895a:	f2 eb fd 88 	st.d	r9[-632],r10
8000895e:	2f f8       	sub	r8,-1
80008960:	fb 48 06 b4 	st.w	sp[1716],r8
80008964:	c0 88       	rjmp	80008974 <_vfprintf_r+0x888>
80008966:	72 1c       	ld.w	r12,r9[0x4]
80008968:	50 7c       	stdsp	sp[0x1c],r12
8000896a:	f2 c8 ff f8 	sub	r8,r9,-8
8000896e:	51 08       	stdsp	sp[0x40],r8
80008970:	72 09       	ld.w	r9,r9[0x0]
80008972:	50 59       	stdsp	sp[0x14],r9
80008974:	40 5b       	lddsp	r11,sp[0x14]
80008976:	40 7a       	lddsp	r10,sp[0x1c]
80008978:	e0 a0 19 54 	rcall	8000bc20 <__isinfd>
8000897c:	18 96       	mov	r6,r12
8000897e:	c1 70       	breq	800089ac <_vfprintf_r+0x8c0>
80008980:	30 08       	mov	r8,0
80008982:	30 09       	mov	r9,0
80008984:	40 5b       	lddsp	r11,sp[0x14]
80008986:	40 7a       	lddsp	r10,sp[0x1c]
80008988:	e0 a0 1d b4 	rcall	8000c4f0 <__avr32_f64_cmp_lt>
8000898c:	c0 40       	breq	80008994 <_vfprintf_r+0x8a8>
8000898e:	32 d8       	mov	r8,45
80008990:	fb 68 06 bb 	st.b	sp[1723],r8
80008994:	fe c8 a9 ec 	sub	r8,pc,-22036
80008998:	fe c6 a9 ec 	sub	r6,pc,-22036
8000899c:	a7 d5       	cbr	r5,0x7
8000899e:	e0 40 00 47 	cp.w	r0,71
800089a2:	f0 06 17 a0 	movle	r6,r8
800089a6:	30 32       	mov	r2,3
800089a8:	e0 8f 06 ce 	bral	80009744 <_vfprintf_r+0x1658>
800089ac:	40 5b       	lddsp	r11,sp[0x14]
800089ae:	40 7a       	lddsp	r10,sp[0x1c]
800089b0:	e0 a0 19 4d 	rcall	8000bc4a <__isnand>
800089b4:	c0 e0       	breq	800089d0 <_vfprintf_r+0x8e4>
800089b6:	50 26       	stdsp	sp[0x8],r6
800089b8:	fe c8 aa 08 	sub	r8,pc,-22008
800089bc:	fe c6 aa 08 	sub	r6,pc,-22008
800089c0:	a7 d5       	cbr	r5,0x7
800089c2:	e0 40 00 47 	cp.w	r0,71
800089c6:	f0 06 17 a0 	movle	r6,r8
800089ca:	30 32       	mov	r2,3
800089cc:	e0 8f 06 c2 	bral	80009750 <_vfprintf_r+0x1664>
800089d0:	40 2a       	lddsp	r10,sp[0x8]
800089d2:	5b fa       	cp.w	r10,-1
800089d4:	c0 41       	brne	800089dc <_vfprintf_r+0x8f0>
800089d6:	30 69       	mov	r9,6
800089d8:	50 29       	stdsp	sp[0x8],r9
800089da:	c1 18       	rjmp	800089fc <_vfprintf_r+0x910>
800089dc:	e0 40 00 47 	cp.w	r0,71
800089e0:	5f 09       	sreq	r9
800089e2:	e0 40 00 67 	cp.w	r0,103
800089e6:	5f 08       	sreq	r8
800089e8:	f3 e8 10 08 	or	r8,r9,r8
800089ec:	f8 08 18 00 	cp.b	r8,r12
800089f0:	c0 60       	breq	800089fc <_vfprintf_r+0x910>
800089f2:	40 28       	lddsp	r8,sp[0x8]
800089f4:	58 08       	cp.w	r8,0
800089f6:	f9 b8 00 01 	moveq	r8,1
800089fa:	50 28       	stdsp	sp[0x8],r8
800089fc:	40 78       	lddsp	r8,sp[0x1c]
800089fe:	40 59       	lddsp	r9,sp[0x14]
80008a00:	fa e9 06 94 	st.d	sp[1684],r8
80008a04:	a9 a5       	sbr	r5,0x8
80008a06:	fa f8 06 94 	ld.w	r8,sp[1684]
80008a0a:	58 08       	cp.w	r8,0
80008a0c:	c0 65       	brlt	80008a18 <_vfprintf_r+0x92c>
80008a0e:	40 5e       	lddsp	lr,sp[0x14]
80008a10:	30 0c       	mov	r12,0
80008a12:	50 6e       	stdsp	sp[0x18],lr
80008a14:	50 9c       	stdsp	sp[0x24],r12
80008a16:	c0 78       	rjmp	80008a24 <_vfprintf_r+0x938>
80008a18:	40 5b       	lddsp	r11,sp[0x14]
80008a1a:	32 da       	mov	r10,45
80008a1c:	ee 1b 80 00 	eorh	r11,0x8000
80008a20:	50 9a       	stdsp	sp[0x24],r10
80008a22:	50 6b       	stdsp	sp[0x18],r11
80008a24:	e0 40 00 46 	cp.w	r0,70
80008a28:	5f 09       	sreq	r9
80008a2a:	e0 40 00 66 	cp.w	r0,102
80008a2e:	5f 08       	sreq	r8
80008a30:	f3 e8 10 08 	or	r8,r9,r8
80008a34:	50 48       	stdsp	sp[0x10],r8
80008a36:	c0 40       	breq	80008a3e <_vfprintf_r+0x952>
80008a38:	40 22       	lddsp	r2,sp[0x8]
80008a3a:	30 39       	mov	r9,3
80008a3c:	c1 08       	rjmp	80008a5c <_vfprintf_r+0x970>
80008a3e:	e0 40 00 45 	cp.w	r0,69
80008a42:	5f 09       	sreq	r9
80008a44:	e0 40 00 65 	cp.w	r0,101
80008a48:	5f 08       	sreq	r8
80008a4a:	40 22       	lddsp	r2,sp[0x8]
80008a4c:	10 49       	or	r9,r8
80008a4e:	2f f2       	sub	r2,-1
80008a50:	40 46       	lddsp	r6,sp[0x10]
80008a52:	ec 09 18 00 	cp.b	r9,r6
80008a56:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80008a5a:	30 29       	mov	r9,2
80008a5c:	fa c8 f9 5c 	sub	r8,sp,-1700
80008a60:	1a d8       	st.w	--sp,r8
80008a62:	fa c8 f9 54 	sub	r8,sp,-1708
80008a66:	1a d8       	st.w	--sp,r8
80008a68:	fa c8 f9 4c 	sub	r8,sp,-1716
80008a6c:	08 9c       	mov	r12,r4
80008a6e:	1a d8       	st.w	--sp,r8
80008a70:	04 98       	mov	r8,r2
80008a72:	40 9b       	lddsp	r11,sp[0x24]
80008a74:	40 aa       	lddsp	r10,sp[0x28]
80008a76:	e0 a0 0b c3 	rcall	8000a1fc <_dtoa_r>
80008a7a:	e0 40 00 47 	cp.w	r0,71
80008a7e:	5f 19       	srne	r9
80008a80:	e0 40 00 67 	cp.w	r0,103
80008a84:	5f 18       	srne	r8
80008a86:	18 96       	mov	r6,r12
80008a88:	2f dd       	sub	sp,-12
80008a8a:	f3 e8 00 08 	and	r8,r9,r8
80008a8e:	c0 41       	brne	80008a96 <_vfprintf_r+0x9aa>
80008a90:	ed b5 00 00 	bld	r5,0x0
80008a94:	c3 01       	brne	80008af4 <_vfprintf_r+0xa08>
80008a96:	ec 02 00 0e 	add	lr,r6,r2
80008a9a:	50 3e       	stdsp	sp[0xc],lr
80008a9c:	40 4c       	lddsp	r12,sp[0x10]
80008a9e:	58 0c       	cp.w	r12,0
80008aa0:	c1 50       	breq	80008aca <_vfprintf_r+0x9de>
80008aa2:	0d 89       	ld.ub	r9,r6[0x0]
80008aa4:	33 08       	mov	r8,48
80008aa6:	f0 09 18 00 	cp.b	r9,r8
80008aaa:	c0 b1       	brne	80008ac0 <_vfprintf_r+0x9d4>
80008aac:	30 08       	mov	r8,0
80008aae:	30 09       	mov	r9,0
80008ab0:	40 6b       	lddsp	r11,sp[0x18]
80008ab2:	40 7a       	lddsp	r10,sp[0x1c]
80008ab4:	e0 a0 1c d7 	rcall	8000c462 <__avr32_f64_cmp_eq>
80008ab8:	fb b2 00 01 	rsubeq	r2,1
80008abc:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008ac0:	40 3b       	lddsp	r11,sp[0xc]
80008ac2:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008ac6:	10 0b       	add	r11,r8
80008ac8:	50 3b       	stdsp	sp[0xc],r11
80008aca:	40 6b       	lddsp	r11,sp[0x18]
80008acc:	30 08       	mov	r8,0
80008ace:	30 09       	mov	r9,0
80008ad0:	40 7a       	lddsp	r10,sp[0x1c]
80008ad2:	e0 a0 1c c8 	rcall	8000c462 <__avr32_f64_cmp_eq>
80008ad6:	c0 90       	breq	80008ae8 <_vfprintf_r+0x9fc>
80008ad8:	40 3a       	lddsp	r10,sp[0xc]
80008ada:	fb 4a 06 a4 	st.w	sp[1700],r10
80008ade:	c0 58       	rjmp	80008ae8 <_vfprintf_r+0x9fc>
80008ae0:	10 c9       	st.b	r8++,r9
80008ae2:	fb 48 06 a4 	st.w	sp[1700],r8
80008ae6:	c0 28       	rjmp	80008aea <_vfprintf_r+0x9fe>
80008ae8:	33 09       	mov	r9,48
80008aea:	fa f8 06 a4 	ld.w	r8,sp[1700]
80008aee:	40 3e       	lddsp	lr,sp[0xc]
80008af0:	1c 38       	cp.w	r8,lr
80008af2:	cf 73       	brcs	80008ae0 <_vfprintf_r+0x9f4>
80008af4:	e0 40 00 47 	cp.w	r0,71
80008af8:	5f 09       	sreq	r9
80008afa:	e0 40 00 67 	cp.w	r0,103
80008afe:	5f 08       	sreq	r8
80008b00:	f3 e8 10 08 	or	r8,r9,r8
80008b04:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008b08:	0c 19       	sub	r9,r6
80008b0a:	50 69       	stdsp	sp[0x18],r9
80008b0c:	58 08       	cp.w	r8,0
80008b0e:	c0 b0       	breq	80008b24 <_vfprintf_r+0xa38>
80008b10:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008b14:	5b d8       	cp.w	r8,-3
80008b16:	c0 55       	brlt	80008b20 <_vfprintf_r+0xa34>
80008b18:	40 2c       	lddsp	r12,sp[0x8]
80008b1a:	18 38       	cp.w	r8,r12
80008b1c:	e0 8a 00 6a 	brle	80008bf0 <_vfprintf_r+0xb04>
80008b20:	20 20       	sub	r0,2
80008b22:	c0 58       	rjmp	80008b2c <_vfprintf_r+0xa40>
80008b24:	e0 40 00 65 	cp.w	r0,101
80008b28:	e0 89 00 46 	brgt	80008bb4 <_vfprintf_r+0xac8>
80008b2c:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008b30:	fb 60 06 9c 	st.b	sp[1692],r0
80008b34:	20 1b       	sub	r11,1
80008b36:	fb 4b 06 ac 	st.w	sp[1708],r11
80008b3a:	c0 47       	brpl	80008b42 <_vfprintf_r+0xa56>
80008b3c:	5c 3b       	neg	r11
80008b3e:	32 d8       	mov	r8,45
80008b40:	c0 28       	rjmp	80008b44 <_vfprintf_r+0xa58>
80008b42:	32 b8       	mov	r8,43
80008b44:	fb 68 06 9d 	st.b	sp[1693],r8
80008b48:	58 9b       	cp.w	r11,9
80008b4a:	e0 8a 00 1d 	brle	80008b84 <_vfprintf_r+0xa98>
80008b4e:	fa c9 fa 35 	sub	r9,sp,-1483
80008b52:	30 aa       	mov	r10,10
80008b54:	12 98       	mov	r8,r9
80008b56:	0e 9c       	mov	r12,r7
80008b58:	0c 92       	mov	r2,r6
80008b5a:	f6 0a 0c 06 	divs	r6,r11,r10
80008b5e:	0e 9b       	mov	r11,r7
80008b60:	2d 0b       	sub	r11,-48
80008b62:	10 fb       	st.b	--r8,r11
80008b64:	0c 9b       	mov	r11,r6
80008b66:	58 96       	cp.w	r6,9
80008b68:	fe 99 ff f9 	brgt	80008b5a <_vfprintf_r+0xa6e>
80008b6c:	2d 0b       	sub	r11,-48
80008b6e:	18 97       	mov	r7,r12
80008b70:	04 96       	mov	r6,r2
80008b72:	10 fb       	st.b	--r8,r11
80008b74:	fa ca f9 62 	sub	r10,sp,-1694
80008b78:	c0 38       	rjmp	80008b7e <_vfprintf_r+0xa92>
80008b7a:	11 3b       	ld.ub	r11,r8++
80008b7c:	14 cb       	st.b	r10++,r11
80008b7e:	12 38       	cp.w	r8,r9
80008b80:	cf d3       	brcs	80008b7a <_vfprintf_r+0xa8e>
80008b82:	c0 98       	rjmp	80008b94 <_vfprintf_r+0xaa8>
80008b84:	2d 0b       	sub	r11,-48
80008b86:	33 08       	mov	r8,48
80008b88:	fb 6b 06 9f 	st.b	sp[1695],r11
80008b8c:	fb 68 06 9e 	st.b	sp[1694],r8
80008b90:	fa ca f9 60 	sub	r10,sp,-1696
80008b94:	fa c8 f9 64 	sub	r8,sp,-1692
80008b98:	f4 08 01 08 	sub	r8,r10,r8
80008b9c:	50 e8       	stdsp	sp[0x38],r8
80008b9e:	10 92       	mov	r2,r8
80008ba0:	40 6b       	lddsp	r11,sp[0x18]
80008ba2:	16 02       	add	r2,r11
80008ba4:	58 1b       	cp.w	r11,1
80008ba6:	e0 89 00 05 	brgt	80008bb0 <_vfprintf_r+0xac4>
80008baa:	ed b5 00 00 	bld	r5,0x0
80008bae:	c3 51       	brne	80008c18 <_vfprintf_r+0xb2c>
80008bb0:	2f f2       	sub	r2,-1
80008bb2:	c3 38       	rjmp	80008c18 <_vfprintf_r+0xb2c>
80008bb4:	e0 40 00 66 	cp.w	r0,102
80008bb8:	c1 c1       	brne	80008bf0 <_vfprintf_r+0xb04>
80008bba:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008bbe:	58 02       	cp.w	r2,0
80008bc0:	e0 8a 00 0c 	brle	80008bd8 <_vfprintf_r+0xaec>
80008bc4:	40 2a       	lddsp	r10,sp[0x8]
80008bc6:	58 0a       	cp.w	r10,0
80008bc8:	c0 41       	brne	80008bd0 <_vfprintf_r+0xae4>
80008bca:	ed b5 00 00 	bld	r5,0x0
80008bce:	c2 51       	brne	80008c18 <_vfprintf_r+0xb2c>
80008bd0:	2f f2       	sub	r2,-1
80008bd2:	40 29       	lddsp	r9,sp[0x8]
80008bd4:	12 02       	add	r2,r9
80008bd6:	c0 b8       	rjmp	80008bec <_vfprintf_r+0xb00>
80008bd8:	40 28       	lddsp	r8,sp[0x8]
80008bda:	58 08       	cp.w	r8,0
80008bdc:	c0 61       	brne	80008be8 <_vfprintf_r+0xafc>
80008bde:	ed b5 00 00 	bld	r5,0x0
80008be2:	c0 30       	breq	80008be8 <_vfprintf_r+0xafc>
80008be4:	30 12       	mov	r2,1
80008be6:	c1 98       	rjmp	80008c18 <_vfprintf_r+0xb2c>
80008be8:	40 22       	lddsp	r2,sp[0x8]
80008bea:	2f e2       	sub	r2,-2
80008bec:	36 60       	mov	r0,102
80008bee:	c1 58       	rjmp	80008c18 <_vfprintf_r+0xb2c>
80008bf0:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008bf4:	40 6e       	lddsp	lr,sp[0x18]
80008bf6:	1c 32       	cp.w	r2,lr
80008bf8:	c0 65       	brlt	80008c04 <_vfprintf_r+0xb18>
80008bfa:	ed b5 00 00 	bld	r5,0x0
80008bfe:	f7 b2 00 ff 	subeq	r2,-1
80008c02:	c0 a8       	rjmp	80008c16 <_vfprintf_r+0xb2a>
80008c04:	e4 08 11 02 	rsub	r8,r2,2
80008c08:	40 6c       	lddsp	r12,sp[0x18]
80008c0a:	58 02       	cp.w	r2,0
80008c0c:	f0 02 17 a0 	movle	r2,r8
80008c10:	f9 b2 09 01 	movgt	r2,1
80008c14:	18 02       	add	r2,r12
80008c16:	36 70       	mov	r0,103
80008c18:	40 9b       	lddsp	r11,sp[0x24]
80008c1a:	58 0b       	cp.w	r11,0
80008c1c:	e0 80 05 94 	breq	80009744 <_vfprintf_r+0x1658>
80008c20:	32 d8       	mov	r8,45
80008c22:	fb 68 06 bb 	st.b	sp[1723],r8
80008c26:	e0 8f 05 93 	bral	8000974c <_vfprintf_r+0x1660>
80008c2a:	50 a7       	stdsp	sp[0x28],r7
80008c2c:	04 94       	mov	r4,r2
80008c2e:	0c 97       	mov	r7,r6
80008c30:	02 92       	mov	r2,r1
80008c32:	06 96       	mov	r6,r3
80008c34:	40 41       	lddsp	r1,sp[0x10]
80008c36:	40 93       	lddsp	r3,sp[0x24]
80008c38:	0e 99       	mov	r9,r7
80008c3a:	ed b5 00 05 	bld	r5,0x5
80008c3e:	c4 81       	brne	80008cce <_vfprintf_r+0xbe2>
80008c40:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c44:	40 3e       	lddsp	lr,sp[0xc]
80008c46:	58 0e       	cp.w	lr,0
80008c48:	c1 d0       	breq	80008c82 <_vfprintf_r+0xb96>
80008c4a:	10 36       	cp.w	r6,r8
80008c4c:	c0 64       	brge	80008c58 <_vfprintf_r+0xb6c>
80008c4e:	fa cc f9 44 	sub	r12,sp,-1724
80008c52:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008c56:	c1 d8       	rjmp	80008c90 <_vfprintf_r+0xba4>
80008c58:	fa c8 f9 50 	sub	r8,sp,-1712
80008c5c:	1a d8       	st.w	--sp,r8
80008c5e:	fa c8 fa b8 	sub	r8,sp,-1352
80008c62:	04 9a       	mov	r10,r2
80008c64:	1a d8       	st.w	--sp,r8
80008c66:	fa c8 fb b4 	sub	r8,sp,-1100
80008c6a:	0c 9b       	mov	r11,r6
80008c6c:	1a d8       	st.w	--sp,r8
80008c6e:	08 9c       	mov	r12,r4
80008c70:	fa c8 f9 40 	sub	r8,sp,-1728
80008c74:	fa c9 ff b4 	sub	r9,sp,-76
80008c78:	fe b0 f8 a2 	rcall	80007dbc <get_arg>
80008c7c:	2f dd       	sub	sp,-12
80008c7e:	78 0a       	ld.w	r10,r12[0x0]
80008c80:	c2 08       	rjmp	80008cc0 <_vfprintf_r+0xbd4>
80008c82:	2f f7       	sub	r7,-1
80008c84:	10 39       	cp.w	r9,r8
80008c86:	c0 84       	brge	80008c96 <_vfprintf_r+0xbaa>
80008c88:	fa cb f9 44 	sub	r11,sp,-1724
80008c8c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c90:	ec fa fd 88 	ld.w	r10,r6[-632]
80008c94:	c1 68       	rjmp	80008cc0 <_vfprintf_r+0xbd4>
80008c96:	41 09       	lddsp	r9,sp[0x40]
80008c98:	59 f8       	cp.w	r8,31
80008c9a:	e0 89 00 10 	brgt	80008cba <_vfprintf_r+0xbce>
80008c9e:	f2 ca ff fc 	sub	r10,r9,-4
80008ca2:	51 0a       	stdsp	sp[0x40],r10
80008ca4:	fa c6 f9 44 	sub	r6,sp,-1724
80008ca8:	72 0a       	ld.w	r10,r9[0x0]
80008caa:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008cae:	f3 4a fd 88 	st.w	r9[-632],r10
80008cb2:	2f f8       	sub	r8,-1
80008cb4:	fb 48 06 b4 	st.w	sp[1716],r8
80008cb8:	c0 48       	rjmp	80008cc0 <_vfprintf_r+0xbd4>
80008cba:	72 0a       	ld.w	r10,r9[0x0]
80008cbc:	2f c9       	sub	r9,-4
80008cbe:	51 09       	stdsp	sp[0x40],r9
80008cc0:	40 be       	lddsp	lr,sp[0x2c]
80008cc2:	1c 98       	mov	r8,lr
80008cc4:	95 1e       	st.w	r10[0x4],lr
80008cc6:	bf 58       	asr	r8,0x1f
80008cc8:	95 08       	st.w	r10[0x0],r8
80008cca:	fe 9f fa 9f 	bral	80008208 <_vfprintf_r+0x11c>
80008cce:	ed b5 00 04 	bld	r5,0x4
80008cd2:	c4 80       	breq	80008d62 <_vfprintf_r+0xc76>
80008cd4:	e2 15 00 40 	andl	r5,0x40,COH
80008cd8:	c4 50       	breq	80008d62 <_vfprintf_r+0xc76>
80008cda:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008cde:	40 3c       	lddsp	r12,sp[0xc]
80008ce0:	58 0c       	cp.w	r12,0
80008ce2:	c1 d0       	breq	80008d1c <_vfprintf_r+0xc30>
80008ce4:	10 36       	cp.w	r6,r8
80008ce6:	c0 64       	brge	80008cf2 <_vfprintf_r+0xc06>
80008ce8:	fa cb f9 44 	sub	r11,sp,-1724
80008cec:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008cf0:	c1 d8       	rjmp	80008d2a <_vfprintf_r+0xc3e>
80008cf2:	fa c8 f9 50 	sub	r8,sp,-1712
80008cf6:	1a d8       	st.w	--sp,r8
80008cf8:	fa c8 fa b8 	sub	r8,sp,-1352
80008cfc:	04 9a       	mov	r10,r2
80008cfe:	1a d8       	st.w	--sp,r8
80008d00:	fa c8 fb b4 	sub	r8,sp,-1100
80008d04:	0c 9b       	mov	r11,r6
80008d06:	1a d8       	st.w	--sp,r8
80008d08:	08 9c       	mov	r12,r4
80008d0a:	fa c8 f9 40 	sub	r8,sp,-1728
80008d0e:	fa c9 ff b4 	sub	r9,sp,-76
80008d12:	fe b0 f8 55 	rcall	80007dbc <get_arg>
80008d16:	2f dd       	sub	sp,-12
80008d18:	78 0a       	ld.w	r10,r12[0x0]
80008d1a:	c2 08       	rjmp	80008d5a <_vfprintf_r+0xc6e>
80008d1c:	2f f7       	sub	r7,-1
80008d1e:	10 39       	cp.w	r9,r8
80008d20:	c0 84       	brge	80008d30 <_vfprintf_r+0xc44>
80008d22:	fa ca f9 44 	sub	r10,sp,-1724
80008d26:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008d2a:	ec fa fd 88 	ld.w	r10,r6[-632]
80008d2e:	c1 68       	rjmp	80008d5a <_vfprintf_r+0xc6e>
80008d30:	41 09       	lddsp	r9,sp[0x40]
80008d32:	59 f8       	cp.w	r8,31
80008d34:	e0 89 00 10 	brgt	80008d54 <_vfprintf_r+0xc68>
80008d38:	f2 ca ff fc 	sub	r10,r9,-4
80008d3c:	51 0a       	stdsp	sp[0x40],r10
80008d3e:	fa c6 f9 44 	sub	r6,sp,-1724
80008d42:	72 0a       	ld.w	r10,r9[0x0]
80008d44:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008d48:	f3 4a fd 88 	st.w	r9[-632],r10
80008d4c:	2f f8       	sub	r8,-1
80008d4e:	fb 48 06 b4 	st.w	sp[1716],r8
80008d52:	c0 48       	rjmp	80008d5a <_vfprintf_r+0xc6e>
80008d54:	72 0a       	ld.w	r10,r9[0x0]
80008d56:	2f c9       	sub	r9,-4
80008d58:	51 09       	stdsp	sp[0x40],r9
80008d5a:	40 be       	lddsp	lr,sp[0x2c]
80008d5c:	b4 0e       	st.h	r10[0x0],lr
80008d5e:	fe 9f fa 55 	bral	80008208 <_vfprintf_r+0x11c>
80008d62:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d66:	40 3c       	lddsp	r12,sp[0xc]
80008d68:	58 0c       	cp.w	r12,0
80008d6a:	c1 d0       	breq	80008da4 <_vfprintf_r+0xcb8>
80008d6c:	10 36       	cp.w	r6,r8
80008d6e:	c0 64       	brge	80008d7a <_vfprintf_r+0xc8e>
80008d70:	fa cb f9 44 	sub	r11,sp,-1724
80008d74:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d78:	c1 d8       	rjmp	80008db2 <_vfprintf_r+0xcc6>
80008d7a:	fa c8 f9 50 	sub	r8,sp,-1712
80008d7e:	1a d8       	st.w	--sp,r8
80008d80:	fa c8 fa b8 	sub	r8,sp,-1352
80008d84:	04 9a       	mov	r10,r2
80008d86:	1a d8       	st.w	--sp,r8
80008d88:	fa c8 fb b4 	sub	r8,sp,-1100
80008d8c:	0c 9b       	mov	r11,r6
80008d8e:	1a d8       	st.w	--sp,r8
80008d90:	08 9c       	mov	r12,r4
80008d92:	fa c8 f9 40 	sub	r8,sp,-1728
80008d96:	fa c9 ff b4 	sub	r9,sp,-76
80008d9a:	fe b0 f8 11 	rcall	80007dbc <get_arg>
80008d9e:	2f dd       	sub	sp,-12
80008da0:	78 0a       	ld.w	r10,r12[0x0]
80008da2:	c2 08       	rjmp	80008de2 <_vfprintf_r+0xcf6>
80008da4:	2f f7       	sub	r7,-1
80008da6:	10 39       	cp.w	r9,r8
80008da8:	c0 84       	brge	80008db8 <_vfprintf_r+0xccc>
80008daa:	fa ca f9 44 	sub	r10,sp,-1724
80008dae:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008db2:	ec fa fd 88 	ld.w	r10,r6[-632]
80008db6:	c1 68       	rjmp	80008de2 <_vfprintf_r+0xcf6>
80008db8:	41 09       	lddsp	r9,sp[0x40]
80008dba:	59 f8       	cp.w	r8,31
80008dbc:	e0 89 00 10 	brgt	80008ddc <_vfprintf_r+0xcf0>
80008dc0:	f2 ca ff fc 	sub	r10,r9,-4
80008dc4:	51 0a       	stdsp	sp[0x40],r10
80008dc6:	fa c6 f9 44 	sub	r6,sp,-1724
80008dca:	72 0a       	ld.w	r10,r9[0x0]
80008dcc:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008dd0:	f3 4a fd 88 	st.w	r9[-632],r10
80008dd4:	2f f8       	sub	r8,-1
80008dd6:	fb 48 06 b4 	st.w	sp[1716],r8
80008dda:	c0 48       	rjmp	80008de2 <_vfprintf_r+0xcf6>
80008ddc:	72 0a       	ld.w	r10,r9[0x0]
80008dde:	2f c9       	sub	r9,-4
80008de0:	51 09       	stdsp	sp[0x40],r9
80008de2:	40 be       	lddsp	lr,sp[0x2c]
80008de4:	95 0e       	st.w	r10[0x0],lr
80008de6:	fe 9f fa 11 	bral	80008208 <_vfprintf_r+0x11c>
80008dea:	50 a7       	stdsp	sp[0x28],r7
80008dec:	50 80       	stdsp	sp[0x20],r0
80008dee:	0c 97       	mov	r7,r6
80008df0:	04 94       	mov	r4,r2
80008df2:	06 96       	mov	r6,r3
80008df4:	02 92       	mov	r2,r1
80008df6:	40 93       	lddsp	r3,sp[0x24]
80008df8:	10 90       	mov	r0,r8
80008dfa:	40 41       	lddsp	r1,sp[0x10]
80008dfc:	a5 a5       	sbr	r5,0x4
80008dfe:	c0 a8       	rjmp	80008e12 <_vfprintf_r+0xd26>
80008e00:	50 a7       	stdsp	sp[0x28],r7
80008e02:	50 80       	stdsp	sp[0x20],r0
80008e04:	0c 97       	mov	r7,r6
80008e06:	04 94       	mov	r4,r2
80008e08:	06 96       	mov	r6,r3
80008e0a:	02 92       	mov	r2,r1
80008e0c:	40 93       	lddsp	r3,sp[0x24]
80008e0e:	10 90       	mov	r0,r8
80008e10:	40 41       	lddsp	r1,sp[0x10]
80008e12:	ed b5 00 05 	bld	r5,0x5
80008e16:	c5 d1       	brne	80008ed0 <_vfprintf_r+0xde4>
80008e18:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e1c:	40 3c       	lddsp	r12,sp[0xc]
80008e1e:	58 0c       	cp.w	r12,0
80008e20:	c2 60       	breq	80008e6c <_vfprintf_r+0xd80>
80008e22:	10 36       	cp.w	r6,r8
80008e24:	c0 a4       	brge	80008e38 <_vfprintf_r+0xd4c>
80008e26:	fa cb f9 44 	sub	r11,sp,-1724
80008e2a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e2e:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008e32:	fa e9 00 00 	st.d	sp[0],r8
80008e36:	c1 88       	rjmp	80008e66 <_vfprintf_r+0xd7a>
80008e38:	fa c8 f9 50 	sub	r8,sp,-1712
80008e3c:	1a d8       	st.w	--sp,r8
80008e3e:	fa c8 fa b8 	sub	r8,sp,-1352
80008e42:	04 9a       	mov	r10,r2
80008e44:	1a d8       	st.w	--sp,r8
80008e46:	0c 9b       	mov	r11,r6
80008e48:	fa c8 fb b4 	sub	r8,sp,-1100
80008e4c:	08 9c       	mov	r12,r4
80008e4e:	1a d8       	st.w	--sp,r8
80008e50:	fa c8 f9 40 	sub	r8,sp,-1728
80008e54:	fa c9 ff b4 	sub	r9,sp,-76
80008e58:	fe b0 f7 b2 	rcall	80007dbc <get_arg>
80008e5c:	2f dd       	sub	sp,-12
80008e5e:	f8 ea 00 00 	ld.d	r10,r12[0]
80008e62:	fa eb 00 00 	st.d	sp[0],r10
80008e66:	30 08       	mov	r8,0
80008e68:	e0 8f 03 de 	bral	80009624 <_vfprintf_r+0x1538>
80008e6c:	ee ca ff ff 	sub	r10,r7,-1
80008e70:	10 37       	cp.w	r7,r8
80008e72:	c0 b4       	brge	80008e88 <_vfprintf_r+0xd9c>
80008e74:	fa c9 f9 44 	sub	r9,sp,-1724
80008e78:	14 97       	mov	r7,r10
80008e7a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008e7e:	ec ea fd 88 	ld.d	r10,r6[-632]
80008e82:	fa eb 00 00 	st.d	sp[0],r10
80008e86:	c1 88       	rjmp	80008eb6 <_vfprintf_r+0xdca>
80008e88:	41 09       	lddsp	r9,sp[0x40]
80008e8a:	59 f8       	cp.w	r8,31
80008e8c:	e0 89 00 18 	brgt	80008ebc <_vfprintf_r+0xdd0>
80008e90:	f2 e6 00 00 	ld.d	r6,r9[0]
80008e94:	f2 cb ff f8 	sub	r11,r9,-8
80008e98:	fa e7 00 00 	st.d	sp[0],r6
80008e9c:	51 0b       	stdsp	sp[0x40],r11
80008e9e:	fa c6 f9 44 	sub	r6,sp,-1724
80008ea2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008ea6:	fa e6 00 00 	ld.d	r6,sp[0]
80008eaa:	f2 e7 fd 88 	st.d	r9[-632],r6
80008eae:	2f f8       	sub	r8,-1
80008eb0:	14 97       	mov	r7,r10
80008eb2:	fb 48 06 b4 	st.w	sp[1716],r8
80008eb6:	40 38       	lddsp	r8,sp[0xc]
80008eb8:	e0 8f 03 b6 	bral	80009624 <_vfprintf_r+0x1538>
80008ebc:	f2 e6 00 00 	ld.d	r6,r9[0]
80008ec0:	40 38       	lddsp	r8,sp[0xc]
80008ec2:	fa e7 00 00 	st.d	sp[0],r6
80008ec6:	2f 89       	sub	r9,-8
80008ec8:	14 97       	mov	r7,r10
80008eca:	51 09       	stdsp	sp[0x40],r9
80008ecc:	e0 8f 03 ac 	bral	80009624 <_vfprintf_r+0x1538>
80008ed0:	ed b5 00 04 	bld	r5,0x4
80008ed4:	c1 61       	brne	80008f00 <_vfprintf_r+0xe14>
80008ed6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008eda:	40 3e       	lddsp	lr,sp[0xc]
80008edc:	58 0e       	cp.w	lr,0
80008ede:	c0 80       	breq	80008eee <_vfprintf_r+0xe02>
80008ee0:	10 36       	cp.w	r6,r8
80008ee2:	c6 74       	brge	80008fb0 <_vfprintf_r+0xec4>
80008ee4:	fa cc f9 44 	sub	r12,sp,-1724
80008ee8:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008eec:	c8 08       	rjmp	80008fec <_vfprintf_r+0xf00>
80008eee:	ee ca ff ff 	sub	r10,r7,-1
80008ef2:	10 37       	cp.w	r7,r8
80008ef4:	c7 f4       	brge	80008ff2 <_vfprintf_r+0xf06>
80008ef6:	fa cb f9 44 	sub	r11,sp,-1724
80008efa:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008efe:	c7 68       	rjmp	80008fea <_vfprintf_r+0xefe>
80008f00:	ed b5 00 06 	bld	r5,0x6
80008f04:	c4 a1       	brne	80008f98 <_vfprintf_r+0xeac>
80008f06:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f0a:	40 3c       	lddsp	r12,sp[0xc]
80008f0c:	58 0c       	cp.w	r12,0
80008f0e:	c1 d0       	breq	80008f48 <_vfprintf_r+0xe5c>
80008f10:	10 36       	cp.w	r6,r8
80008f12:	c0 64       	brge	80008f1e <_vfprintf_r+0xe32>
80008f14:	fa cb f9 44 	sub	r11,sp,-1724
80008f18:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f1c:	c1 f8       	rjmp	80008f5a <_vfprintf_r+0xe6e>
80008f1e:	fa c8 f9 50 	sub	r8,sp,-1712
80008f22:	1a d8       	st.w	--sp,r8
80008f24:	fa c8 fa b8 	sub	r8,sp,-1352
80008f28:	1a d8       	st.w	--sp,r8
80008f2a:	fa c8 fb b4 	sub	r8,sp,-1100
80008f2e:	1a d8       	st.w	--sp,r8
80008f30:	fa c8 f9 40 	sub	r8,sp,-1728
80008f34:	fa c9 ff b4 	sub	r9,sp,-76
80008f38:	04 9a       	mov	r10,r2
80008f3a:	0c 9b       	mov	r11,r6
80008f3c:	08 9c       	mov	r12,r4
80008f3e:	fe b0 f7 3f 	rcall	80007dbc <get_arg>
80008f42:	2f dd       	sub	sp,-12
80008f44:	98 18       	ld.sh	r8,r12[0x2]
80008f46:	c2 68       	rjmp	80008f92 <_vfprintf_r+0xea6>
80008f48:	ee ca ff ff 	sub	r10,r7,-1
80008f4c:	10 37       	cp.w	r7,r8
80008f4e:	c0 94       	brge	80008f60 <_vfprintf_r+0xe74>
80008f50:	fa c9 f9 44 	sub	r9,sp,-1724
80008f54:	14 97       	mov	r7,r10
80008f56:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f5a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008f5e:	c1 a8       	rjmp	80008f92 <_vfprintf_r+0xea6>
80008f60:	41 09       	lddsp	r9,sp[0x40]
80008f62:	59 f8       	cp.w	r8,31
80008f64:	e0 89 00 13 	brgt	80008f8a <_vfprintf_r+0xe9e>
80008f68:	f2 cb ff fc 	sub	r11,r9,-4
80008f6c:	51 0b       	stdsp	sp[0x40],r11
80008f6e:	72 09       	ld.w	r9,r9[0x0]
80008f70:	fa c6 f9 44 	sub	r6,sp,-1724
80008f74:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008f78:	2f f8       	sub	r8,-1
80008f7a:	f7 49 fd 88 	st.w	r11[-632],r9
80008f7e:	fb 48 06 b4 	st.w	sp[1716],r8
80008f82:	14 97       	mov	r7,r10
80008f84:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008f88:	c0 58       	rjmp	80008f92 <_vfprintf_r+0xea6>
80008f8a:	92 18       	ld.sh	r8,r9[0x2]
80008f8c:	14 97       	mov	r7,r10
80008f8e:	2f c9       	sub	r9,-4
80008f90:	51 09       	stdsp	sp[0x40],r9
80008f92:	5c 78       	castu.h	r8
80008f94:	50 18       	stdsp	sp[0x4],r8
80008f96:	c4 68       	rjmp	80009022 <_vfprintf_r+0xf36>
80008f98:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f9c:	40 3c       	lddsp	r12,sp[0xc]
80008f9e:	58 0c       	cp.w	r12,0
80008fa0:	c1 d0       	breq	80008fda <_vfprintf_r+0xeee>
80008fa2:	10 36       	cp.w	r6,r8
80008fa4:	c0 64       	brge	80008fb0 <_vfprintf_r+0xec4>
80008fa6:	fa cb f9 44 	sub	r11,sp,-1724
80008faa:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008fae:	c1 f8       	rjmp	80008fec <_vfprintf_r+0xf00>
80008fb0:	fa c8 f9 50 	sub	r8,sp,-1712
80008fb4:	1a d8       	st.w	--sp,r8
80008fb6:	fa c8 fa b8 	sub	r8,sp,-1352
80008fba:	0c 9b       	mov	r11,r6
80008fbc:	1a d8       	st.w	--sp,r8
80008fbe:	fa c8 fb b4 	sub	r8,sp,-1100
80008fc2:	04 9a       	mov	r10,r2
80008fc4:	1a d8       	st.w	--sp,r8
80008fc6:	08 9c       	mov	r12,r4
80008fc8:	fa c8 f9 40 	sub	r8,sp,-1728
80008fcc:	fa c9 ff b4 	sub	r9,sp,-76
80008fd0:	fe b0 f6 f6 	rcall	80007dbc <get_arg>
80008fd4:	2f dd       	sub	sp,-12
80008fd6:	78 0b       	ld.w	r11,r12[0x0]
80008fd8:	c2 48       	rjmp	80009020 <_vfprintf_r+0xf34>
80008fda:	ee ca ff ff 	sub	r10,r7,-1
80008fde:	10 37       	cp.w	r7,r8
80008fe0:	c0 94       	brge	80008ff2 <_vfprintf_r+0xf06>
80008fe2:	fa c9 f9 44 	sub	r9,sp,-1724
80008fe6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008fea:	14 97       	mov	r7,r10
80008fec:	ec fb fd 88 	ld.w	r11,r6[-632]
80008ff0:	c1 88       	rjmp	80009020 <_vfprintf_r+0xf34>
80008ff2:	41 09       	lddsp	r9,sp[0x40]
80008ff4:	59 f8       	cp.w	r8,31
80008ff6:	e0 89 00 11 	brgt	80009018 <_vfprintf_r+0xf2c>
80008ffa:	f2 cb ff fc 	sub	r11,r9,-4
80008ffe:	51 0b       	stdsp	sp[0x40],r11
80009000:	fa c6 f9 44 	sub	r6,sp,-1724
80009004:	72 0b       	ld.w	r11,r9[0x0]
80009006:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000900a:	f3 4b fd 88 	st.w	r9[-632],r11
8000900e:	2f f8       	sub	r8,-1
80009010:	14 97       	mov	r7,r10
80009012:	fb 48 06 b4 	st.w	sp[1716],r8
80009016:	c0 58       	rjmp	80009020 <_vfprintf_r+0xf34>
80009018:	72 0b       	ld.w	r11,r9[0x0]
8000901a:	14 97       	mov	r7,r10
8000901c:	2f c9       	sub	r9,-4
8000901e:	51 09       	stdsp	sp[0x40],r9
80009020:	50 1b       	stdsp	sp[0x4],r11
80009022:	30 0e       	mov	lr,0
80009024:	50 0e       	stdsp	sp[0x0],lr
80009026:	1c 98       	mov	r8,lr
80009028:	e0 8f 02 fe 	bral	80009624 <_vfprintf_r+0x1538>
8000902c:	50 a7       	stdsp	sp[0x28],r7
8000902e:	50 80       	stdsp	sp[0x20],r0
80009030:	0c 97       	mov	r7,r6
80009032:	04 94       	mov	r4,r2
80009034:	06 96       	mov	r6,r3
80009036:	02 92       	mov	r2,r1
80009038:	40 93       	lddsp	r3,sp[0x24]
8000903a:	40 41       	lddsp	r1,sp[0x10]
8000903c:	0e 99       	mov	r9,r7
8000903e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009042:	40 3c       	lddsp	r12,sp[0xc]
80009044:	58 0c       	cp.w	r12,0
80009046:	c1 d0       	breq	80009080 <_vfprintf_r+0xf94>
80009048:	10 36       	cp.w	r6,r8
8000904a:	c0 64       	brge	80009056 <_vfprintf_r+0xf6a>
8000904c:	fa cb f9 44 	sub	r11,sp,-1724
80009050:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009054:	c1 d8       	rjmp	8000908e <_vfprintf_r+0xfa2>
80009056:	fa c8 f9 50 	sub	r8,sp,-1712
8000905a:	1a d8       	st.w	--sp,r8
8000905c:	fa c8 fa b8 	sub	r8,sp,-1352
80009060:	1a d8       	st.w	--sp,r8
80009062:	fa c8 fb b4 	sub	r8,sp,-1100
80009066:	1a d8       	st.w	--sp,r8
80009068:	fa c9 ff b4 	sub	r9,sp,-76
8000906c:	fa c8 f9 40 	sub	r8,sp,-1728
80009070:	04 9a       	mov	r10,r2
80009072:	0c 9b       	mov	r11,r6
80009074:	08 9c       	mov	r12,r4
80009076:	fe b0 f6 a3 	rcall	80007dbc <get_arg>
8000907a:	2f dd       	sub	sp,-12
8000907c:	78 09       	ld.w	r9,r12[0x0]
8000907e:	c2 18       	rjmp	800090c0 <_vfprintf_r+0xfd4>
80009080:	2f f7       	sub	r7,-1
80009082:	10 39       	cp.w	r9,r8
80009084:	c0 84       	brge	80009094 <_vfprintf_r+0xfa8>
80009086:	fa ca f9 44 	sub	r10,sp,-1724
8000908a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000908e:	ec f9 fd 88 	ld.w	r9,r6[-632]
80009092:	c1 78       	rjmp	800090c0 <_vfprintf_r+0xfd4>
80009094:	41 09       	lddsp	r9,sp[0x40]
80009096:	59 f8       	cp.w	r8,31
80009098:	e0 89 00 10 	brgt	800090b8 <_vfprintf_r+0xfcc>
8000909c:	f2 ca ff fc 	sub	r10,r9,-4
800090a0:	51 0a       	stdsp	sp[0x40],r10
800090a2:	fa c6 f9 44 	sub	r6,sp,-1724
800090a6:	72 09       	ld.w	r9,r9[0x0]
800090a8:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800090ac:	f5 49 fd 88 	st.w	r10[-632],r9
800090b0:	2f f8       	sub	r8,-1
800090b2:	fb 48 06 b4 	st.w	sp[1716],r8
800090b6:	c0 58       	rjmp	800090c0 <_vfprintf_r+0xfd4>
800090b8:	f2 c8 ff fc 	sub	r8,r9,-4
800090bc:	51 08       	stdsp	sp[0x40],r8
800090be:	72 09       	ld.w	r9,r9[0x0]
800090c0:	33 08       	mov	r8,48
800090c2:	fb 68 06 b8 	st.b	sp[1720],r8
800090c6:	37 88       	mov	r8,120
800090c8:	30 0e       	mov	lr,0
800090ca:	fb 68 06 b9 	st.b	sp[1721],r8
800090ce:	fe cc b1 16 	sub	r12,pc,-20202
800090d2:	50 19       	stdsp	sp[0x4],r9
800090d4:	a1 b5       	sbr	r5,0x1
800090d6:	50 0e       	stdsp	sp[0x0],lr
800090d8:	50 dc       	stdsp	sp[0x34],r12
800090da:	30 28       	mov	r8,2
800090dc:	37 80       	mov	r0,120
800090de:	e0 8f 02 a3 	bral	80009624 <_vfprintf_r+0x1538>
800090e2:	50 a7       	stdsp	sp[0x28],r7
800090e4:	50 80       	stdsp	sp[0x20],r0
800090e6:	10 90       	mov	r0,r8
800090e8:	30 08       	mov	r8,0
800090ea:	fb 68 06 bb 	st.b	sp[1723],r8
800090ee:	0c 97       	mov	r7,r6
800090f0:	04 94       	mov	r4,r2
800090f2:	06 96       	mov	r6,r3
800090f4:	02 92       	mov	r2,r1
800090f6:	40 93       	lddsp	r3,sp[0x24]
800090f8:	40 41       	lddsp	r1,sp[0x10]
800090fa:	0e 99       	mov	r9,r7
800090fc:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009100:	40 3b       	lddsp	r11,sp[0xc]
80009102:	58 0b       	cp.w	r11,0
80009104:	c1 d0       	breq	8000913e <_vfprintf_r+0x1052>
80009106:	10 36       	cp.w	r6,r8
80009108:	c0 64       	brge	80009114 <_vfprintf_r+0x1028>
8000910a:	fa ca f9 44 	sub	r10,sp,-1724
8000910e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009112:	c1 d8       	rjmp	8000914c <_vfprintf_r+0x1060>
80009114:	fa c8 f9 50 	sub	r8,sp,-1712
80009118:	1a d8       	st.w	--sp,r8
8000911a:	fa c8 fa b8 	sub	r8,sp,-1352
8000911e:	1a d8       	st.w	--sp,r8
80009120:	fa c8 fb b4 	sub	r8,sp,-1100
80009124:	0c 9b       	mov	r11,r6
80009126:	1a d8       	st.w	--sp,r8
80009128:	04 9a       	mov	r10,r2
8000912a:	fa c8 f9 40 	sub	r8,sp,-1728
8000912e:	fa c9 ff b4 	sub	r9,sp,-76
80009132:	08 9c       	mov	r12,r4
80009134:	fe b0 f6 44 	rcall	80007dbc <get_arg>
80009138:	2f dd       	sub	sp,-12
8000913a:	78 06       	ld.w	r6,r12[0x0]
8000913c:	c2 08       	rjmp	8000917c <_vfprintf_r+0x1090>
8000913e:	2f f7       	sub	r7,-1
80009140:	10 39       	cp.w	r9,r8
80009142:	c0 84       	brge	80009152 <_vfprintf_r+0x1066>
80009144:	fa c9 f9 44 	sub	r9,sp,-1724
80009148:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000914c:	ec f6 fd 88 	ld.w	r6,r6[-632]
80009150:	c1 68       	rjmp	8000917c <_vfprintf_r+0x1090>
80009152:	41 09       	lddsp	r9,sp[0x40]
80009154:	59 f8       	cp.w	r8,31
80009156:	e0 89 00 10 	brgt	80009176 <_vfprintf_r+0x108a>
8000915a:	f2 ca ff fc 	sub	r10,r9,-4
8000915e:	51 0a       	stdsp	sp[0x40],r10
80009160:	72 06       	ld.w	r6,r9[0x0]
80009162:	fa ce f9 44 	sub	lr,sp,-1724
80009166:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000916a:	f3 46 fd 88 	st.w	r9[-632],r6
8000916e:	2f f8       	sub	r8,-1
80009170:	fb 48 06 b4 	st.w	sp[1716],r8
80009174:	c0 48       	rjmp	8000917c <_vfprintf_r+0x1090>
80009176:	72 06       	ld.w	r6,r9[0x0]
80009178:	2f c9       	sub	r9,-4
8000917a:	51 09       	stdsp	sp[0x40],r9
8000917c:	40 2c       	lddsp	r12,sp[0x8]
8000917e:	58 0c       	cp.w	r12,0
80009180:	c1 05       	brlt	800091a0 <_vfprintf_r+0x10b4>
80009182:	18 9a       	mov	r10,r12
80009184:	30 0b       	mov	r11,0
80009186:	0c 9c       	mov	r12,r6
80009188:	e0 a0 12 38 	rcall	8000b5f8 <memchr>
8000918c:	e0 80 02 df 	breq	8000974a <_vfprintf_r+0x165e>
80009190:	f8 06 01 02 	sub	r2,r12,r6
80009194:	40 2b       	lddsp	r11,sp[0x8]
80009196:	16 32       	cp.w	r2,r11
80009198:	e0 89 02 d9 	brgt	8000974a <_vfprintf_r+0x165e>
8000919c:	e0 8f 02 d4 	bral	80009744 <_vfprintf_r+0x1658>
800091a0:	30 0a       	mov	r10,0
800091a2:	0c 9c       	mov	r12,r6
800091a4:	50 2a       	stdsp	sp[0x8],r10
800091a6:	e0 a0 15 99 	rcall	8000bcd8 <strlen>
800091aa:	18 92       	mov	r2,r12
800091ac:	e0 8f 02 d2 	bral	80009750 <_vfprintf_r+0x1664>
800091b0:	50 a7       	stdsp	sp[0x28],r7
800091b2:	50 80       	stdsp	sp[0x20],r0
800091b4:	0c 97       	mov	r7,r6
800091b6:	04 94       	mov	r4,r2
800091b8:	06 96       	mov	r6,r3
800091ba:	02 92       	mov	r2,r1
800091bc:	40 93       	lddsp	r3,sp[0x24]
800091be:	10 90       	mov	r0,r8
800091c0:	40 41       	lddsp	r1,sp[0x10]
800091c2:	a5 a5       	sbr	r5,0x4
800091c4:	c0 a8       	rjmp	800091d8 <_vfprintf_r+0x10ec>
800091c6:	50 a7       	stdsp	sp[0x28],r7
800091c8:	50 80       	stdsp	sp[0x20],r0
800091ca:	0c 97       	mov	r7,r6
800091cc:	04 94       	mov	r4,r2
800091ce:	06 96       	mov	r6,r3
800091d0:	02 92       	mov	r2,r1
800091d2:	40 93       	lddsp	r3,sp[0x24]
800091d4:	10 90       	mov	r0,r8
800091d6:	40 41       	lddsp	r1,sp[0x10]
800091d8:	ed b5 00 05 	bld	r5,0x5
800091dc:	c5 61       	brne	80009288 <_vfprintf_r+0x119c>
800091de:	fa f8 06 b4 	ld.w	r8,sp[1716]
800091e2:	40 39       	lddsp	r9,sp[0xc]
800091e4:	58 09       	cp.w	r9,0
800091e6:	c2 10       	breq	80009228 <_vfprintf_r+0x113c>
800091e8:	10 36       	cp.w	r6,r8
800091ea:	c0 74       	brge	800091f8 <_vfprintf_r+0x110c>
800091ec:	fa c8 f9 44 	sub	r8,sp,-1724
800091f0:	f0 06 00 36 	add	r6,r8,r6<<0x3
800091f4:	c2 38       	rjmp	8000923a <_vfprintf_r+0x114e>
800091f6:	d7 03       	nop
800091f8:	fa c8 f9 50 	sub	r8,sp,-1712
800091fc:	1a d8       	st.w	--sp,r8
800091fe:	fa c8 fa b8 	sub	r8,sp,-1352
80009202:	1a d8       	st.w	--sp,r8
80009204:	fa c8 fb b4 	sub	r8,sp,-1100
80009208:	1a d8       	st.w	--sp,r8
8000920a:	fa c8 f9 40 	sub	r8,sp,-1728
8000920e:	fa c9 ff b4 	sub	r9,sp,-76
80009212:	04 9a       	mov	r10,r2
80009214:	0c 9b       	mov	r11,r6
80009216:	08 9c       	mov	r12,r4
80009218:	fe b0 f5 d2 	rcall	80007dbc <get_arg>
8000921c:	2f dd       	sub	sp,-12
8000921e:	f8 e8 00 00 	ld.d	r8,r12[0]
80009222:	fa e9 00 00 	st.d	sp[0],r8
80009226:	c2 e8       	rjmp	80009282 <_vfprintf_r+0x1196>
80009228:	ee ca ff ff 	sub	r10,r7,-1
8000922c:	10 37       	cp.w	r7,r8
8000922e:	c0 b4       	brge	80009244 <_vfprintf_r+0x1158>
80009230:	fa c8 f9 44 	sub	r8,sp,-1724
80009234:	14 97       	mov	r7,r10
80009236:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000923a:	ec ea fd 88 	ld.d	r10,r6[-632]
8000923e:	fa eb 00 00 	st.d	sp[0],r10
80009242:	c2 08       	rjmp	80009282 <_vfprintf_r+0x1196>
80009244:	41 09       	lddsp	r9,sp[0x40]
80009246:	59 f8       	cp.w	r8,31
80009248:	e0 89 00 16 	brgt	80009274 <_vfprintf_r+0x1188>
8000924c:	f2 e6 00 00 	ld.d	r6,r9[0]
80009250:	f2 cb ff f8 	sub	r11,r9,-8
80009254:	fa e7 00 00 	st.d	sp[0],r6
80009258:	51 0b       	stdsp	sp[0x40],r11
8000925a:	fa c6 f9 44 	sub	r6,sp,-1724
8000925e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009262:	fa e6 00 00 	ld.d	r6,sp[0]
80009266:	f2 e7 fd 88 	st.d	r9[-632],r6
8000926a:	2f f8       	sub	r8,-1
8000926c:	14 97       	mov	r7,r10
8000926e:	fb 48 06 b4 	st.w	sp[1716],r8
80009272:	c0 88       	rjmp	80009282 <_vfprintf_r+0x1196>
80009274:	f2 e6 00 00 	ld.d	r6,r9[0]
80009278:	2f 89       	sub	r9,-8
8000927a:	fa e7 00 00 	st.d	sp[0],r6
8000927e:	51 09       	stdsp	sp[0x40],r9
80009280:	14 97       	mov	r7,r10
80009282:	30 18       	mov	r8,1
80009284:	e0 8f 01 d0 	bral	80009624 <_vfprintf_r+0x1538>
80009288:	ed b5 00 04 	bld	r5,0x4
8000928c:	c1 61       	brne	800092b8 <_vfprintf_r+0x11cc>
8000928e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009292:	40 3e       	lddsp	lr,sp[0xc]
80009294:	58 0e       	cp.w	lr,0
80009296:	c0 80       	breq	800092a6 <_vfprintf_r+0x11ba>
80009298:	10 36       	cp.w	r6,r8
8000929a:	c6 74       	brge	80009368 <_vfprintf_r+0x127c>
8000929c:	fa cc f9 44 	sub	r12,sp,-1724
800092a0:	f8 06 00 36 	add	r6,r12,r6<<0x3
800092a4:	c8 08       	rjmp	800093a4 <_vfprintf_r+0x12b8>
800092a6:	ee ca ff ff 	sub	r10,r7,-1
800092aa:	10 37       	cp.w	r7,r8
800092ac:	c7 f4       	brge	800093aa <_vfprintf_r+0x12be>
800092ae:	fa cb f9 44 	sub	r11,sp,-1724
800092b2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800092b6:	c7 68       	rjmp	800093a2 <_vfprintf_r+0x12b6>
800092b8:	ed b5 00 06 	bld	r5,0x6
800092bc:	c4 a1       	brne	80009350 <_vfprintf_r+0x1264>
800092be:	fa f8 06 b4 	ld.w	r8,sp[1716]
800092c2:	40 3c       	lddsp	r12,sp[0xc]
800092c4:	58 0c       	cp.w	r12,0
800092c6:	c1 d0       	breq	80009300 <_vfprintf_r+0x1214>
800092c8:	10 36       	cp.w	r6,r8
800092ca:	c0 64       	brge	800092d6 <_vfprintf_r+0x11ea>
800092cc:	fa cb f9 44 	sub	r11,sp,-1724
800092d0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800092d4:	c1 f8       	rjmp	80009312 <_vfprintf_r+0x1226>
800092d6:	fa c8 f9 50 	sub	r8,sp,-1712
800092da:	1a d8       	st.w	--sp,r8
800092dc:	fa c8 fa b8 	sub	r8,sp,-1352
800092e0:	1a d8       	st.w	--sp,r8
800092e2:	fa c8 fb b4 	sub	r8,sp,-1100
800092e6:	1a d8       	st.w	--sp,r8
800092e8:	fa c8 f9 40 	sub	r8,sp,-1728
800092ec:	fa c9 ff b4 	sub	r9,sp,-76
800092f0:	04 9a       	mov	r10,r2
800092f2:	0c 9b       	mov	r11,r6
800092f4:	08 9c       	mov	r12,r4
800092f6:	fe b0 f5 63 	rcall	80007dbc <get_arg>
800092fa:	2f dd       	sub	sp,-12
800092fc:	98 18       	ld.sh	r8,r12[0x2]
800092fe:	c2 68       	rjmp	8000934a <_vfprintf_r+0x125e>
80009300:	ee ca ff ff 	sub	r10,r7,-1
80009304:	10 37       	cp.w	r7,r8
80009306:	c0 94       	brge	80009318 <_vfprintf_r+0x122c>
80009308:	fa c9 f9 44 	sub	r9,sp,-1724
8000930c:	14 97       	mov	r7,r10
8000930e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009312:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009316:	c1 a8       	rjmp	8000934a <_vfprintf_r+0x125e>
80009318:	41 09       	lddsp	r9,sp[0x40]
8000931a:	59 f8       	cp.w	r8,31
8000931c:	e0 89 00 13 	brgt	80009342 <_vfprintf_r+0x1256>
80009320:	f2 cb ff fc 	sub	r11,r9,-4
80009324:	51 0b       	stdsp	sp[0x40],r11
80009326:	72 09       	ld.w	r9,r9[0x0]
80009328:	fa c6 f9 44 	sub	r6,sp,-1724
8000932c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009330:	2f f8       	sub	r8,-1
80009332:	f7 49 fd 88 	st.w	r11[-632],r9
80009336:	fb 48 06 b4 	st.w	sp[1716],r8
8000933a:	14 97       	mov	r7,r10
8000933c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009340:	c0 58       	rjmp	8000934a <_vfprintf_r+0x125e>
80009342:	92 18       	ld.sh	r8,r9[0x2]
80009344:	14 97       	mov	r7,r10
80009346:	2f c9       	sub	r9,-4
80009348:	51 09       	stdsp	sp[0x40],r9
8000934a:	5c 78       	castu.h	r8
8000934c:	50 18       	stdsp	sp[0x4],r8
8000934e:	c4 68       	rjmp	800093da <_vfprintf_r+0x12ee>
80009350:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009354:	40 3c       	lddsp	r12,sp[0xc]
80009356:	58 0c       	cp.w	r12,0
80009358:	c1 d0       	breq	80009392 <_vfprintf_r+0x12a6>
8000935a:	10 36       	cp.w	r6,r8
8000935c:	c0 64       	brge	80009368 <_vfprintf_r+0x127c>
8000935e:	fa cb f9 44 	sub	r11,sp,-1724
80009362:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009366:	c1 f8       	rjmp	800093a4 <_vfprintf_r+0x12b8>
80009368:	fa c8 f9 50 	sub	r8,sp,-1712
8000936c:	1a d8       	st.w	--sp,r8
8000936e:	fa c8 fa b8 	sub	r8,sp,-1352
80009372:	0c 9b       	mov	r11,r6
80009374:	1a d8       	st.w	--sp,r8
80009376:	fa c8 fb b4 	sub	r8,sp,-1100
8000937a:	04 9a       	mov	r10,r2
8000937c:	1a d8       	st.w	--sp,r8
8000937e:	08 9c       	mov	r12,r4
80009380:	fa c8 f9 40 	sub	r8,sp,-1728
80009384:	fa c9 ff b4 	sub	r9,sp,-76
80009388:	fe b0 f5 1a 	rcall	80007dbc <get_arg>
8000938c:	2f dd       	sub	sp,-12
8000938e:	78 0b       	ld.w	r11,r12[0x0]
80009390:	c2 48       	rjmp	800093d8 <_vfprintf_r+0x12ec>
80009392:	ee ca ff ff 	sub	r10,r7,-1
80009396:	10 37       	cp.w	r7,r8
80009398:	c0 94       	brge	800093aa <_vfprintf_r+0x12be>
8000939a:	fa c9 f9 44 	sub	r9,sp,-1724
8000939e:	f2 06 00 36 	add	r6,r9,r6<<0x3
800093a2:	14 97       	mov	r7,r10
800093a4:	ec fb fd 88 	ld.w	r11,r6[-632]
800093a8:	c1 88       	rjmp	800093d8 <_vfprintf_r+0x12ec>
800093aa:	41 09       	lddsp	r9,sp[0x40]
800093ac:	59 f8       	cp.w	r8,31
800093ae:	e0 89 00 11 	brgt	800093d0 <_vfprintf_r+0x12e4>
800093b2:	f2 cb ff fc 	sub	r11,r9,-4
800093b6:	51 0b       	stdsp	sp[0x40],r11
800093b8:	fa c6 f9 44 	sub	r6,sp,-1724
800093bc:	72 0b       	ld.w	r11,r9[0x0]
800093be:	ec 08 00 39 	add	r9,r6,r8<<0x3
800093c2:	f3 4b fd 88 	st.w	r9[-632],r11
800093c6:	2f f8       	sub	r8,-1
800093c8:	14 97       	mov	r7,r10
800093ca:	fb 48 06 b4 	st.w	sp[1716],r8
800093ce:	c0 58       	rjmp	800093d8 <_vfprintf_r+0x12ec>
800093d0:	72 0b       	ld.w	r11,r9[0x0]
800093d2:	14 97       	mov	r7,r10
800093d4:	2f c9       	sub	r9,-4
800093d6:	51 09       	stdsp	sp[0x40],r9
800093d8:	50 1b       	stdsp	sp[0x4],r11
800093da:	30 0e       	mov	lr,0
800093dc:	30 18       	mov	r8,1
800093de:	50 0e       	stdsp	sp[0x0],lr
800093e0:	c2 29       	rjmp	80009624 <_vfprintf_r+0x1538>
800093e2:	50 a7       	stdsp	sp[0x28],r7
800093e4:	50 80       	stdsp	sp[0x20],r0
800093e6:	0c 97       	mov	r7,r6
800093e8:	04 94       	mov	r4,r2
800093ea:	06 96       	mov	r6,r3
800093ec:	02 92       	mov	r2,r1
800093ee:	fe cc b4 36 	sub	r12,pc,-19402
800093f2:	40 93       	lddsp	r3,sp[0x24]
800093f4:	10 90       	mov	r0,r8
800093f6:	40 41       	lddsp	r1,sp[0x10]
800093f8:	50 dc       	stdsp	sp[0x34],r12
800093fa:	ed b5 00 05 	bld	r5,0x5
800093fe:	c5 51       	brne	800094a8 <_vfprintf_r+0x13bc>
80009400:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009404:	40 3b       	lddsp	r11,sp[0xc]
80009406:	58 0b       	cp.w	r11,0
80009408:	c2 20       	breq	8000944c <_vfprintf_r+0x1360>
8000940a:	10 36       	cp.w	r6,r8
8000940c:	c0 a4       	brge	80009420 <_vfprintf_r+0x1334>
8000940e:	fa ca f9 44 	sub	r10,sp,-1724
80009412:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009416:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000941a:	fa e9 00 00 	st.d	sp[0],r8
8000941e:	cf 28       	rjmp	80009602 <_vfprintf_r+0x1516>
80009420:	fa c8 f9 50 	sub	r8,sp,-1712
80009424:	1a d8       	st.w	--sp,r8
80009426:	fa c8 fa b8 	sub	r8,sp,-1352
8000942a:	04 9a       	mov	r10,r2
8000942c:	1a d8       	st.w	--sp,r8
8000942e:	0c 9b       	mov	r11,r6
80009430:	fa c8 fb b4 	sub	r8,sp,-1100
80009434:	08 9c       	mov	r12,r4
80009436:	1a d8       	st.w	--sp,r8
80009438:	fa c8 f9 40 	sub	r8,sp,-1728
8000943c:	fa c9 ff b4 	sub	r9,sp,-76
80009440:	fe b0 f4 be 	rcall	80007dbc <get_arg>
80009444:	2f dd       	sub	sp,-12
80009446:	f8 ea 00 00 	ld.d	r10,r12[0]
8000944a:	c0 c8       	rjmp	80009462 <_vfprintf_r+0x1376>
8000944c:	ee ca ff ff 	sub	r10,r7,-1
80009450:	10 37       	cp.w	r7,r8
80009452:	c0 b4       	brge	80009468 <_vfprintf_r+0x137c>
80009454:	fa c9 f9 44 	sub	r9,sp,-1724
80009458:	14 97       	mov	r7,r10
8000945a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000945e:	ec ea fd 88 	ld.d	r10,r6[-632]
80009462:	fa eb 00 00 	st.d	sp[0],r10
80009466:	cc e8       	rjmp	80009602 <_vfprintf_r+0x1516>
80009468:	41 09       	lddsp	r9,sp[0x40]
8000946a:	59 f8       	cp.w	r8,31
8000946c:	e0 89 00 16 	brgt	80009498 <_vfprintf_r+0x13ac>
80009470:	f2 e6 00 00 	ld.d	r6,r9[0]
80009474:	f2 cb ff f8 	sub	r11,r9,-8
80009478:	fa e7 00 00 	st.d	sp[0],r6
8000947c:	51 0b       	stdsp	sp[0x40],r11
8000947e:	fa c6 f9 44 	sub	r6,sp,-1724
80009482:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009486:	fa e6 00 00 	ld.d	r6,sp[0]
8000948a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000948e:	2f f8       	sub	r8,-1
80009490:	14 97       	mov	r7,r10
80009492:	fb 48 06 b4 	st.w	sp[1716],r8
80009496:	cb 68       	rjmp	80009602 <_vfprintf_r+0x1516>
80009498:	f2 e6 00 00 	ld.d	r6,r9[0]
8000949c:	2f 89       	sub	r9,-8
8000949e:	fa e7 00 00 	st.d	sp[0],r6
800094a2:	51 09       	stdsp	sp[0x40],r9
800094a4:	14 97       	mov	r7,r10
800094a6:	ca e8       	rjmp	80009602 <_vfprintf_r+0x1516>
800094a8:	ed b5 00 04 	bld	r5,0x4
800094ac:	c1 71       	brne	800094da <_vfprintf_r+0x13ee>
800094ae:	fa f8 06 b4 	ld.w	r8,sp[1716]
800094b2:	40 3e       	lddsp	lr,sp[0xc]
800094b4:	58 0e       	cp.w	lr,0
800094b6:	c0 80       	breq	800094c6 <_vfprintf_r+0x13da>
800094b8:	10 36       	cp.w	r6,r8
800094ba:	c6 94       	brge	8000958c <_vfprintf_r+0x14a0>
800094bc:	fa cc f9 44 	sub	r12,sp,-1724
800094c0:	f8 06 00 36 	add	r6,r12,r6<<0x3
800094c4:	c8 28       	rjmp	800095c8 <_vfprintf_r+0x14dc>
800094c6:	ee ca ff ff 	sub	r10,r7,-1
800094ca:	10 37       	cp.w	r7,r8
800094cc:	e0 84 00 81 	brge	800095ce <_vfprintf_r+0x14e2>
800094d0:	fa cb f9 44 	sub	r11,sp,-1724
800094d4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800094d8:	c7 78       	rjmp	800095c6 <_vfprintf_r+0x14da>
800094da:	ed b5 00 06 	bld	r5,0x6
800094de:	c4 b1       	brne	80009574 <_vfprintf_r+0x1488>
800094e0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800094e4:	40 3c       	lddsp	r12,sp[0xc]
800094e6:	58 0c       	cp.w	r12,0
800094e8:	c1 d0       	breq	80009522 <_vfprintf_r+0x1436>
800094ea:	10 36       	cp.w	r6,r8
800094ec:	c0 64       	brge	800094f8 <_vfprintf_r+0x140c>
800094ee:	fa cb f9 44 	sub	r11,sp,-1724
800094f2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800094f6:	c1 f8       	rjmp	80009534 <_vfprintf_r+0x1448>
800094f8:	fa c8 f9 50 	sub	r8,sp,-1712
800094fc:	1a d8       	st.w	--sp,r8
800094fe:	fa c8 fa b8 	sub	r8,sp,-1352
80009502:	1a d8       	st.w	--sp,r8
80009504:	fa c8 fb b4 	sub	r8,sp,-1100
80009508:	1a d8       	st.w	--sp,r8
8000950a:	fa c8 f9 40 	sub	r8,sp,-1728
8000950e:	fa c9 ff b4 	sub	r9,sp,-76
80009512:	04 9a       	mov	r10,r2
80009514:	0c 9b       	mov	r11,r6
80009516:	08 9c       	mov	r12,r4
80009518:	fe b0 f4 52 	rcall	80007dbc <get_arg>
8000951c:	2f dd       	sub	sp,-12
8000951e:	98 18       	ld.sh	r8,r12[0x2]
80009520:	c2 78       	rjmp	8000956e <_vfprintf_r+0x1482>
80009522:	ee ca ff ff 	sub	r10,r7,-1
80009526:	10 37       	cp.w	r7,r8
80009528:	c0 a4       	brge	8000953c <_vfprintf_r+0x1450>
8000952a:	fa c9 f9 44 	sub	r9,sp,-1724
8000952e:	14 97       	mov	r7,r10
80009530:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009534:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009538:	c1 b8       	rjmp	8000956e <_vfprintf_r+0x1482>
8000953a:	d7 03       	nop
8000953c:	41 09       	lddsp	r9,sp[0x40]
8000953e:	59 f8       	cp.w	r8,31
80009540:	e0 89 00 13 	brgt	80009566 <_vfprintf_r+0x147a>
80009544:	f2 cb ff fc 	sub	r11,r9,-4
80009548:	51 0b       	stdsp	sp[0x40],r11
8000954a:	72 09       	ld.w	r9,r9[0x0]
8000954c:	fa c6 f9 44 	sub	r6,sp,-1724
80009550:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009554:	2f f8       	sub	r8,-1
80009556:	f7 49 fd 88 	st.w	r11[-632],r9
8000955a:	fb 48 06 b4 	st.w	sp[1716],r8
8000955e:	14 97       	mov	r7,r10
80009560:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009564:	c0 58       	rjmp	8000956e <_vfprintf_r+0x1482>
80009566:	92 18       	ld.sh	r8,r9[0x2]
80009568:	14 97       	mov	r7,r10
8000956a:	2f c9       	sub	r9,-4
8000956c:	51 09       	stdsp	sp[0x40],r9
8000956e:	5c 78       	castu.h	r8
80009570:	50 18       	stdsp	sp[0x4],r8
80009572:	c4 68       	rjmp	800095fe <_vfprintf_r+0x1512>
80009574:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009578:	40 3c       	lddsp	r12,sp[0xc]
8000957a:	58 0c       	cp.w	r12,0
8000957c:	c1 d0       	breq	800095b6 <_vfprintf_r+0x14ca>
8000957e:	10 36       	cp.w	r6,r8
80009580:	c0 64       	brge	8000958c <_vfprintf_r+0x14a0>
80009582:	fa cb f9 44 	sub	r11,sp,-1724
80009586:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000958a:	c1 f8       	rjmp	800095c8 <_vfprintf_r+0x14dc>
8000958c:	fa c8 f9 50 	sub	r8,sp,-1712
80009590:	1a d8       	st.w	--sp,r8
80009592:	fa c8 fa b8 	sub	r8,sp,-1352
80009596:	0c 9b       	mov	r11,r6
80009598:	1a d8       	st.w	--sp,r8
8000959a:	fa c8 fb b4 	sub	r8,sp,-1100
8000959e:	04 9a       	mov	r10,r2
800095a0:	1a d8       	st.w	--sp,r8
800095a2:	08 9c       	mov	r12,r4
800095a4:	fa c8 f9 40 	sub	r8,sp,-1728
800095a8:	fa c9 ff b4 	sub	r9,sp,-76
800095ac:	fe b0 f4 08 	rcall	80007dbc <get_arg>
800095b0:	2f dd       	sub	sp,-12
800095b2:	78 0b       	ld.w	r11,r12[0x0]
800095b4:	c2 48       	rjmp	800095fc <_vfprintf_r+0x1510>
800095b6:	ee ca ff ff 	sub	r10,r7,-1
800095ba:	10 37       	cp.w	r7,r8
800095bc:	c0 94       	brge	800095ce <_vfprintf_r+0x14e2>
800095be:	fa c9 f9 44 	sub	r9,sp,-1724
800095c2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800095c6:	14 97       	mov	r7,r10
800095c8:	ec fb fd 88 	ld.w	r11,r6[-632]
800095cc:	c1 88       	rjmp	800095fc <_vfprintf_r+0x1510>
800095ce:	41 09       	lddsp	r9,sp[0x40]
800095d0:	59 f8       	cp.w	r8,31
800095d2:	e0 89 00 11 	brgt	800095f4 <_vfprintf_r+0x1508>
800095d6:	f2 cb ff fc 	sub	r11,r9,-4
800095da:	51 0b       	stdsp	sp[0x40],r11
800095dc:	fa c6 f9 44 	sub	r6,sp,-1724
800095e0:	72 0b       	ld.w	r11,r9[0x0]
800095e2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800095e6:	f3 4b fd 88 	st.w	r9[-632],r11
800095ea:	2f f8       	sub	r8,-1
800095ec:	14 97       	mov	r7,r10
800095ee:	fb 48 06 b4 	st.w	sp[1716],r8
800095f2:	c0 58       	rjmp	800095fc <_vfprintf_r+0x1510>
800095f4:	72 0b       	ld.w	r11,r9[0x0]
800095f6:	14 97       	mov	r7,r10
800095f8:	2f c9       	sub	r9,-4
800095fa:	51 09       	stdsp	sp[0x40],r9
800095fc:	50 1b       	stdsp	sp[0x4],r11
800095fe:	30 0e       	mov	lr,0
80009600:	50 0e       	stdsp	sp[0x0],lr
80009602:	40 08       	lddsp	r8,sp[0x0]
80009604:	40 1c       	lddsp	r12,sp[0x4]
80009606:	18 48       	or	r8,r12
80009608:	5f 19       	srne	r9
8000960a:	0a 98       	mov	r8,r5
8000960c:	eb e9 00 09 	and	r9,r5,r9
80009610:	a1 b8       	sbr	r8,0x1
80009612:	58 09       	cp.w	r9,0
80009614:	c0 70       	breq	80009622 <_vfprintf_r+0x1536>
80009616:	10 95       	mov	r5,r8
80009618:	fb 60 06 b9 	st.b	sp[1721],r0
8000961c:	33 08       	mov	r8,48
8000961e:	fb 68 06 b8 	st.b	sp[1720],r8
80009622:	30 28       	mov	r8,2
80009624:	30 09       	mov	r9,0
80009626:	fb 69 06 bb 	st.b	sp[1723],r9
8000962a:	0a 99       	mov	r9,r5
8000962c:	a7 d9       	cbr	r9,0x7
8000962e:	40 2b       	lddsp	r11,sp[0x8]
80009630:	40 16       	lddsp	r6,sp[0x4]
80009632:	58 0b       	cp.w	r11,0
80009634:	5f 1a       	srne	r10
80009636:	f2 05 17 40 	movge	r5,r9
8000963a:	fa c2 f9 78 	sub	r2,sp,-1672
8000963e:	40 09       	lddsp	r9,sp[0x0]
80009640:	0c 49       	or	r9,r6
80009642:	5f 19       	srne	r9
80009644:	f5 e9 10 09 	or	r9,r10,r9
80009648:	c5 c0       	breq	80009700 <_vfprintf_r+0x1614>
8000964a:	30 19       	mov	r9,1
8000964c:	f2 08 18 00 	cp.b	r8,r9
80009650:	c0 60       	breq	8000965c <_vfprintf_r+0x1570>
80009652:	30 29       	mov	r9,2
80009654:	f2 08 18 00 	cp.b	r8,r9
80009658:	c0 41       	brne	80009660 <_vfprintf_r+0x1574>
8000965a:	c3 c8       	rjmp	800096d2 <_vfprintf_r+0x15e6>
8000965c:	04 96       	mov	r6,r2
8000965e:	c3 08       	rjmp	800096be <_vfprintf_r+0x15d2>
80009660:	04 96       	mov	r6,r2
80009662:	fa e8 00 00 	ld.d	r8,sp[0]
80009666:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000966a:	2d 0a       	sub	r10,-48
8000966c:	0c fa       	st.b	--r6,r10
8000966e:	f0 0b 16 03 	lsr	r11,r8,0x3
80009672:	f2 0c 16 03 	lsr	r12,r9,0x3
80009676:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000967a:	18 99       	mov	r9,r12
8000967c:	16 98       	mov	r8,r11
8000967e:	58 08       	cp.w	r8,0
80009680:	5c 29       	cpc	r9
80009682:	cf 21       	brne	80009666 <_vfprintf_r+0x157a>
80009684:	fa e9 00 00 	st.d	sp[0],r8
80009688:	ed b5 00 00 	bld	r5,0x0
8000968c:	c4 51       	brne	80009716 <_vfprintf_r+0x162a>
8000968e:	33 09       	mov	r9,48
80009690:	f2 0a 18 00 	cp.b	r10,r9
80009694:	c4 10       	breq	80009716 <_vfprintf_r+0x162a>
80009696:	0c f9       	st.b	--r6,r9
80009698:	c3 f8       	rjmp	80009716 <_vfprintf_r+0x162a>
8000969a:	fa ea 00 00 	ld.d	r10,sp[0]
8000969e:	30 a8       	mov	r8,10
800096a0:	30 09       	mov	r9,0
800096a2:	e0 a0 1a 19 	rcall	8000cad4 <__avr32_umod64>
800096a6:	30 a8       	mov	r8,10
800096a8:	2d 0a       	sub	r10,-48
800096aa:	30 09       	mov	r9,0
800096ac:	ac 8a       	st.b	r6[0x0],r10
800096ae:	fa ea 00 00 	ld.d	r10,sp[0]
800096b2:	e0 a0 18 df 	rcall	8000c870 <__avr32_udiv64>
800096b6:	16 99       	mov	r9,r11
800096b8:	14 98       	mov	r8,r10
800096ba:	fa e9 00 00 	st.d	sp[0],r8
800096be:	20 16       	sub	r6,1
800096c0:	fa ea 00 00 	ld.d	r10,sp[0]
800096c4:	58 9a       	cp.w	r10,9
800096c6:	5c 2b       	cpc	r11
800096c8:	fe 9b ff e9 	brhi	8000969a <_vfprintf_r+0x15ae>
800096cc:	1b f8       	ld.ub	r8,sp[0x7]
800096ce:	2d 08       	sub	r8,-48
800096d0:	c2 08       	rjmp	80009710 <_vfprintf_r+0x1624>
800096d2:	04 96       	mov	r6,r2
800096d4:	fa e8 00 00 	ld.d	r8,sp[0]
800096d8:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
800096dc:	40 de       	lddsp	lr,sp[0x34]
800096de:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
800096e2:	0c fa       	st.b	--r6,r10
800096e4:	f2 0b 16 04 	lsr	r11,r9,0x4
800096e8:	f0 0a 16 04 	lsr	r10,r8,0x4
800096ec:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
800096f0:	16 99       	mov	r9,r11
800096f2:	14 98       	mov	r8,r10
800096f4:	58 08       	cp.w	r8,0
800096f6:	5c 29       	cpc	r9
800096f8:	cf 01       	brne	800096d8 <_vfprintf_r+0x15ec>
800096fa:	fa e9 00 00 	st.d	sp[0],r8
800096fe:	c0 c8       	rjmp	80009716 <_vfprintf_r+0x162a>
80009700:	58 08       	cp.w	r8,0
80009702:	c0 91       	brne	80009714 <_vfprintf_r+0x1628>
80009704:	ed b5 00 00 	bld	r5,0x0
80009708:	c0 61       	brne	80009714 <_vfprintf_r+0x1628>
8000970a:	fa c6 f9 79 	sub	r6,sp,-1671
8000970e:	33 08       	mov	r8,48
80009710:	ac 88       	st.b	r6[0x0],r8
80009712:	c0 28       	rjmp	80009716 <_vfprintf_r+0x162a>
80009714:	04 96       	mov	r6,r2
80009716:	0c 12       	sub	r2,r6
80009718:	c1 c8       	rjmp	80009750 <_vfprintf_r+0x1664>
8000971a:	50 a7       	stdsp	sp[0x28],r7
8000971c:	50 80       	stdsp	sp[0x20],r0
8000971e:	40 93       	lddsp	r3,sp[0x24]
80009720:	0c 97       	mov	r7,r6
80009722:	10 90       	mov	r0,r8
80009724:	04 94       	mov	r4,r2
80009726:	40 41       	lddsp	r1,sp[0x10]
80009728:	58 08       	cp.w	r8,0
8000972a:	e0 80 04 4f 	breq	80009fc8 <_vfprintf_r+0x1edc>
8000972e:	fb 68 06 60 	st.b	sp[1632],r8
80009732:	30 0c       	mov	r12,0
80009734:	30 08       	mov	r8,0
80009736:	30 12       	mov	r2,1
80009738:	fb 68 06 bb 	st.b	sp[1723],r8
8000973c:	50 2c       	stdsp	sp[0x8],r12
8000973e:	fa c6 f9 a0 	sub	r6,sp,-1632
80009742:	c0 78       	rjmp	80009750 <_vfprintf_r+0x1664>
80009744:	30 0b       	mov	r11,0
80009746:	50 2b       	stdsp	sp[0x8],r11
80009748:	c0 48       	rjmp	80009750 <_vfprintf_r+0x1664>
8000974a:	40 22       	lddsp	r2,sp[0x8]
8000974c:	30 0a       	mov	r10,0
8000974e:	50 2a       	stdsp	sp[0x8],r10
80009750:	40 29       	lddsp	r9,sp[0x8]
80009752:	e4 09 0c 49 	max	r9,r2,r9
80009756:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000975a:	50 39       	stdsp	sp[0xc],r9
8000975c:	0a 9e       	mov	lr,r5
8000975e:	30 09       	mov	r9,0
80009760:	e2 1e 00 02 	andl	lr,0x2,COH
80009764:	f2 08 18 00 	cp.b	r8,r9
80009768:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000976c:	f7 b8 01 ff 	subne	r8,-1
80009770:	fb f8 1a 03 	st.wne	sp[0xc],r8
80009774:	0a 9b       	mov	r11,r5
80009776:	58 0e       	cp.w	lr,0
80009778:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000977c:	f7 bc 01 fe 	subne	r12,-2
80009780:	fb fc 1a 03 	st.wne	sp[0xc],r12
80009784:	e2 1b 00 84 	andl	r11,0x84,COH
80009788:	50 fe       	stdsp	sp[0x3c],lr
8000978a:	50 9b       	stdsp	sp[0x24],r11
8000978c:	c4 71       	brne	8000981a <_vfprintf_r+0x172e>
8000978e:	40 8a       	lddsp	r10,sp[0x20]
80009790:	40 39       	lddsp	r9,sp[0xc]
80009792:	12 1a       	sub	r10,r9
80009794:	50 4a       	stdsp	sp[0x10],r10
80009796:	58 0a       	cp.w	r10,0
80009798:	e0 89 00 20 	brgt	800097d8 <_vfprintf_r+0x16ec>
8000979c:	c3 f8       	rjmp	8000981a <_vfprintf_r+0x172e>
8000979e:	2f 09       	sub	r9,-16
800097a0:	2f f8       	sub	r8,-1
800097a2:	fe ce b7 d2 	sub	lr,pc,-18478
800097a6:	31 0c       	mov	r12,16
800097a8:	fb 49 06 90 	st.w	sp[1680],r9
800097ac:	87 0e       	st.w	r3[0x0],lr
800097ae:	87 1c       	st.w	r3[0x4],r12
800097b0:	fb 48 06 8c 	st.w	sp[1676],r8
800097b4:	58 78       	cp.w	r8,7
800097b6:	e0 89 00 04 	brgt	800097be <_vfprintf_r+0x16d2>
800097ba:	2f 83       	sub	r3,-8
800097bc:	c0 b8       	rjmp	800097d2 <_vfprintf_r+0x16e6>
800097be:	fa ca f9 78 	sub	r10,sp,-1672
800097c2:	02 9b       	mov	r11,r1
800097c4:	08 9c       	mov	r12,r4
800097c6:	fe b0 f4 85 	rcall	800080d0 <__sprint_r>
800097ca:	e0 81 04 10 	brne	80009fea <_vfprintf_r+0x1efe>
800097ce:	fa c3 f9 e0 	sub	r3,sp,-1568
800097d2:	40 4b       	lddsp	r11,sp[0x10]
800097d4:	21 0b       	sub	r11,16
800097d6:	50 4b       	stdsp	sp[0x10],r11
800097d8:	fa f9 06 90 	ld.w	r9,sp[1680]
800097dc:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097e0:	fe ca b8 10 	sub	r10,pc,-18416
800097e4:	40 4e       	lddsp	lr,sp[0x10]
800097e6:	59 0e       	cp.w	lr,16
800097e8:	fe 99 ff db 	brgt	8000979e <_vfprintf_r+0x16b2>
800097ec:	1c 09       	add	r9,lr
800097ee:	2f f8       	sub	r8,-1
800097f0:	87 0a       	st.w	r3[0x0],r10
800097f2:	fb 49 06 90 	st.w	sp[1680],r9
800097f6:	87 1e       	st.w	r3[0x4],lr
800097f8:	fb 48 06 8c 	st.w	sp[1676],r8
800097fc:	58 78       	cp.w	r8,7
800097fe:	e0 89 00 04 	brgt	80009806 <_vfprintf_r+0x171a>
80009802:	2f 83       	sub	r3,-8
80009804:	c0 b8       	rjmp	8000981a <_vfprintf_r+0x172e>
80009806:	fa ca f9 78 	sub	r10,sp,-1672
8000980a:	02 9b       	mov	r11,r1
8000980c:	08 9c       	mov	r12,r4
8000980e:	fe b0 f4 61 	rcall	800080d0 <__sprint_r>
80009812:	e0 81 03 ec 	brne	80009fea <_vfprintf_r+0x1efe>
80009816:	fa c3 f9 e0 	sub	r3,sp,-1568
8000981a:	30 09       	mov	r9,0
8000981c:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009820:	f2 08 18 00 	cp.b	r8,r9
80009824:	c1 f0       	breq	80009862 <_vfprintf_r+0x1776>
80009826:	fa f8 06 90 	ld.w	r8,sp[1680]
8000982a:	fa c9 f9 45 	sub	r9,sp,-1723
8000982e:	2f f8       	sub	r8,-1
80009830:	87 09       	st.w	r3[0x0],r9
80009832:	fb 48 06 90 	st.w	sp[1680],r8
80009836:	30 19       	mov	r9,1
80009838:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000983c:	87 19       	st.w	r3[0x4],r9
8000983e:	2f f8       	sub	r8,-1
80009840:	fb 48 06 8c 	st.w	sp[1676],r8
80009844:	58 78       	cp.w	r8,7
80009846:	e0 89 00 04 	brgt	8000984e <_vfprintf_r+0x1762>
8000984a:	2f 83       	sub	r3,-8
8000984c:	c0 b8       	rjmp	80009862 <_vfprintf_r+0x1776>
8000984e:	fa ca f9 78 	sub	r10,sp,-1672
80009852:	02 9b       	mov	r11,r1
80009854:	08 9c       	mov	r12,r4
80009856:	fe b0 f4 3d 	rcall	800080d0 <__sprint_r>
8000985a:	e0 81 03 c8 	brne	80009fea <_vfprintf_r+0x1efe>
8000985e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009862:	40 fc       	lddsp	r12,sp[0x3c]
80009864:	58 0c       	cp.w	r12,0
80009866:	c1 f0       	breq	800098a4 <_vfprintf_r+0x17b8>
80009868:	fa f8 06 90 	ld.w	r8,sp[1680]
8000986c:	fa c9 f9 48 	sub	r9,sp,-1720
80009870:	2f e8       	sub	r8,-2
80009872:	87 09       	st.w	r3[0x0],r9
80009874:	fb 48 06 90 	st.w	sp[1680],r8
80009878:	30 29       	mov	r9,2
8000987a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000987e:	87 19       	st.w	r3[0x4],r9
80009880:	2f f8       	sub	r8,-1
80009882:	fb 48 06 8c 	st.w	sp[1676],r8
80009886:	58 78       	cp.w	r8,7
80009888:	e0 89 00 04 	brgt	80009890 <_vfprintf_r+0x17a4>
8000988c:	2f 83       	sub	r3,-8
8000988e:	c0 b8       	rjmp	800098a4 <_vfprintf_r+0x17b8>
80009890:	fa ca f9 78 	sub	r10,sp,-1672
80009894:	02 9b       	mov	r11,r1
80009896:	08 9c       	mov	r12,r4
80009898:	fe b0 f4 1c 	rcall	800080d0 <__sprint_r>
8000989c:	e0 81 03 a7 	brne	80009fea <_vfprintf_r+0x1efe>
800098a0:	fa c3 f9 e0 	sub	r3,sp,-1568
800098a4:	40 9b       	lddsp	r11,sp[0x24]
800098a6:	e0 4b 00 80 	cp.w	r11,128
800098aa:	c4 71       	brne	80009938 <_vfprintf_r+0x184c>
800098ac:	40 8a       	lddsp	r10,sp[0x20]
800098ae:	40 39       	lddsp	r9,sp[0xc]
800098b0:	12 1a       	sub	r10,r9
800098b2:	50 4a       	stdsp	sp[0x10],r10
800098b4:	58 0a       	cp.w	r10,0
800098b6:	e0 89 00 20 	brgt	800098f6 <_vfprintf_r+0x180a>
800098ba:	c3 f8       	rjmp	80009938 <_vfprintf_r+0x184c>
800098bc:	2f 09       	sub	r9,-16
800098be:	2f f8       	sub	r8,-1
800098c0:	fe ce b8 e0 	sub	lr,pc,-18208
800098c4:	31 0c       	mov	r12,16
800098c6:	fb 49 06 90 	st.w	sp[1680],r9
800098ca:	87 0e       	st.w	r3[0x0],lr
800098cc:	87 1c       	st.w	r3[0x4],r12
800098ce:	fb 48 06 8c 	st.w	sp[1676],r8
800098d2:	58 78       	cp.w	r8,7
800098d4:	e0 89 00 04 	brgt	800098dc <_vfprintf_r+0x17f0>
800098d8:	2f 83       	sub	r3,-8
800098da:	c0 b8       	rjmp	800098f0 <_vfprintf_r+0x1804>
800098dc:	fa ca f9 78 	sub	r10,sp,-1672
800098e0:	02 9b       	mov	r11,r1
800098e2:	08 9c       	mov	r12,r4
800098e4:	fe b0 f3 f6 	rcall	800080d0 <__sprint_r>
800098e8:	e0 81 03 81 	brne	80009fea <_vfprintf_r+0x1efe>
800098ec:	fa c3 f9 e0 	sub	r3,sp,-1568
800098f0:	40 4b       	lddsp	r11,sp[0x10]
800098f2:	21 0b       	sub	r11,16
800098f4:	50 4b       	stdsp	sp[0x10],r11
800098f6:	fa f9 06 90 	ld.w	r9,sp[1680]
800098fa:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098fe:	fe ca b9 1e 	sub	r10,pc,-18146
80009902:	40 4e       	lddsp	lr,sp[0x10]
80009904:	59 0e       	cp.w	lr,16
80009906:	fe 99 ff db 	brgt	800098bc <_vfprintf_r+0x17d0>
8000990a:	1c 09       	add	r9,lr
8000990c:	2f f8       	sub	r8,-1
8000990e:	87 0a       	st.w	r3[0x0],r10
80009910:	fb 49 06 90 	st.w	sp[1680],r9
80009914:	87 1e       	st.w	r3[0x4],lr
80009916:	fb 48 06 8c 	st.w	sp[1676],r8
8000991a:	58 78       	cp.w	r8,7
8000991c:	e0 89 00 04 	brgt	80009924 <_vfprintf_r+0x1838>
80009920:	2f 83       	sub	r3,-8
80009922:	c0 b8       	rjmp	80009938 <_vfprintf_r+0x184c>
80009924:	fa ca f9 78 	sub	r10,sp,-1672
80009928:	02 9b       	mov	r11,r1
8000992a:	08 9c       	mov	r12,r4
8000992c:	fe b0 f3 d2 	rcall	800080d0 <__sprint_r>
80009930:	e0 81 03 5d 	brne	80009fea <_vfprintf_r+0x1efe>
80009934:	fa c3 f9 e0 	sub	r3,sp,-1568
80009938:	40 2c       	lddsp	r12,sp[0x8]
8000993a:	04 1c       	sub	r12,r2
8000993c:	50 2c       	stdsp	sp[0x8],r12
8000993e:	58 0c       	cp.w	r12,0
80009940:	e0 89 00 20 	brgt	80009980 <_vfprintf_r+0x1894>
80009944:	c3 f8       	rjmp	800099c2 <_vfprintf_r+0x18d6>
80009946:	2f 09       	sub	r9,-16
80009948:	2f f8       	sub	r8,-1
8000994a:	fe cb b9 6a 	sub	r11,pc,-18070
8000994e:	31 0a       	mov	r10,16
80009950:	fb 49 06 90 	st.w	sp[1680],r9
80009954:	87 0b       	st.w	r3[0x0],r11
80009956:	87 1a       	st.w	r3[0x4],r10
80009958:	fb 48 06 8c 	st.w	sp[1676],r8
8000995c:	58 78       	cp.w	r8,7
8000995e:	e0 89 00 04 	brgt	80009966 <_vfprintf_r+0x187a>
80009962:	2f 83       	sub	r3,-8
80009964:	c0 b8       	rjmp	8000997a <_vfprintf_r+0x188e>
80009966:	fa ca f9 78 	sub	r10,sp,-1672
8000996a:	02 9b       	mov	r11,r1
8000996c:	08 9c       	mov	r12,r4
8000996e:	fe b0 f3 b1 	rcall	800080d0 <__sprint_r>
80009972:	e0 81 03 3c 	brne	80009fea <_vfprintf_r+0x1efe>
80009976:	fa c3 f9 e0 	sub	r3,sp,-1568
8000997a:	40 29       	lddsp	r9,sp[0x8]
8000997c:	21 09       	sub	r9,16
8000997e:	50 29       	stdsp	sp[0x8],r9
80009980:	fa f9 06 90 	ld.w	r9,sp[1680]
80009984:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009988:	fe ca b9 a8 	sub	r10,pc,-18008
8000998c:	40 2e       	lddsp	lr,sp[0x8]
8000998e:	59 0e       	cp.w	lr,16
80009990:	fe 99 ff db 	brgt	80009946 <_vfprintf_r+0x185a>
80009994:	1c 09       	add	r9,lr
80009996:	2f f8       	sub	r8,-1
80009998:	87 0a       	st.w	r3[0x0],r10
8000999a:	fb 49 06 90 	st.w	sp[1680],r9
8000999e:	87 1e       	st.w	r3[0x4],lr
800099a0:	fb 48 06 8c 	st.w	sp[1676],r8
800099a4:	58 78       	cp.w	r8,7
800099a6:	e0 89 00 04 	brgt	800099ae <_vfprintf_r+0x18c2>
800099aa:	2f 83       	sub	r3,-8
800099ac:	c0 b8       	rjmp	800099c2 <_vfprintf_r+0x18d6>
800099ae:	fa ca f9 78 	sub	r10,sp,-1672
800099b2:	02 9b       	mov	r11,r1
800099b4:	08 9c       	mov	r12,r4
800099b6:	fe b0 f3 8d 	rcall	800080d0 <__sprint_r>
800099ba:	e0 81 03 18 	brne	80009fea <_vfprintf_r+0x1efe>
800099be:	fa c3 f9 e0 	sub	r3,sp,-1568
800099c2:	ed b5 00 08 	bld	r5,0x8
800099c6:	c0 b0       	breq	800099dc <_vfprintf_r+0x18f0>
800099c8:	fa f8 06 90 	ld.w	r8,sp[1680]
800099cc:	87 12       	st.w	r3[0x4],r2
800099ce:	87 06       	st.w	r3[0x0],r6
800099d0:	f0 02 00 02 	add	r2,r8,r2
800099d4:	fb 42 06 90 	st.w	sp[1680],r2
800099d8:	e0 8f 01 d4 	bral	80009d80 <_vfprintf_r+0x1c94>
800099dc:	e0 40 00 65 	cp.w	r0,101
800099e0:	e0 8a 01 d6 	brle	80009d8c <_vfprintf_r+0x1ca0>
800099e4:	30 08       	mov	r8,0
800099e6:	30 09       	mov	r9,0
800099e8:	40 5b       	lddsp	r11,sp[0x14]
800099ea:	40 7a       	lddsp	r10,sp[0x1c]
800099ec:	e0 a0 15 3b 	rcall	8000c462 <__avr32_f64_cmp_eq>
800099f0:	c7 90       	breq	80009ae2 <_vfprintf_r+0x19f6>
800099f2:	fa f8 06 90 	ld.w	r8,sp[1680]
800099f6:	fe c9 ba 2a 	sub	r9,pc,-17878
800099fa:	2f f8       	sub	r8,-1
800099fc:	87 09       	st.w	r3[0x0],r9
800099fe:	fb 48 06 90 	st.w	sp[1680],r8
80009a02:	30 19       	mov	r9,1
80009a04:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a08:	87 19       	st.w	r3[0x4],r9
80009a0a:	2f f8       	sub	r8,-1
80009a0c:	fb 48 06 8c 	st.w	sp[1676],r8
80009a10:	58 78       	cp.w	r8,7
80009a12:	e0 89 00 05 	brgt	80009a1c <_vfprintf_r+0x1930>
80009a16:	2f 83       	sub	r3,-8
80009a18:	c0 c8       	rjmp	80009a30 <_vfprintf_r+0x1944>
80009a1a:	d7 03       	nop
80009a1c:	fa ca f9 78 	sub	r10,sp,-1672
80009a20:	02 9b       	mov	r11,r1
80009a22:	08 9c       	mov	r12,r4
80009a24:	fe b0 f3 56 	rcall	800080d0 <__sprint_r>
80009a28:	e0 81 02 e1 	brne	80009fea <_vfprintf_r+0x1efe>
80009a2c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a30:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009a34:	40 6c       	lddsp	r12,sp[0x18]
80009a36:	18 38       	cp.w	r8,r12
80009a38:	c0 55       	brlt	80009a42 <_vfprintf_r+0x1956>
80009a3a:	ed b5 00 00 	bld	r5,0x0
80009a3e:	e0 81 02 6b 	brne	80009f14 <_vfprintf_r+0x1e28>
80009a42:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a46:	2f f8       	sub	r8,-1
80009a48:	40 cb       	lddsp	r11,sp[0x30]
80009a4a:	fb 48 06 90 	st.w	sp[1680],r8
80009a4e:	30 19       	mov	r9,1
80009a50:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a54:	87 0b       	st.w	r3[0x0],r11
80009a56:	2f f8       	sub	r8,-1
80009a58:	87 19       	st.w	r3[0x4],r9
80009a5a:	fb 48 06 8c 	st.w	sp[1676],r8
80009a5e:	58 78       	cp.w	r8,7
80009a60:	e0 89 00 04 	brgt	80009a68 <_vfprintf_r+0x197c>
80009a64:	2f 83       	sub	r3,-8
80009a66:	c0 b8       	rjmp	80009a7c <_vfprintf_r+0x1990>
80009a68:	fa ca f9 78 	sub	r10,sp,-1672
80009a6c:	02 9b       	mov	r11,r1
80009a6e:	08 9c       	mov	r12,r4
80009a70:	fe b0 f3 30 	rcall	800080d0 <__sprint_r>
80009a74:	e0 81 02 bb 	brne	80009fea <_vfprintf_r+0x1efe>
80009a78:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a7c:	40 66       	lddsp	r6,sp[0x18]
80009a7e:	20 16       	sub	r6,1
80009a80:	58 06       	cp.w	r6,0
80009a82:	e0 89 00 1d 	brgt	80009abc <_vfprintf_r+0x19d0>
80009a86:	e0 8f 02 47 	bral	80009f14 <_vfprintf_r+0x1e28>
80009a8a:	2f 09       	sub	r9,-16
80009a8c:	2f f8       	sub	r8,-1
80009a8e:	fb 49 06 90 	st.w	sp[1680],r9
80009a92:	87 02       	st.w	r3[0x0],r2
80009a94:	87 10       	st.w	r3[0x4],r0
80009a96:	fb 48 06 8c 	st.w	sp[1676],r8
80009a9a:	58 78       	cp.w	r8,7
80009a9c:	e0 89 00 04 	brgt	80009aa4 <_vfprintf_r+0x19b8>
80009aa0:	2f 83       	sub	r3,-8
80009aa2:	c0 b8       	rjmp	80009ab8 <_vfprintf_r+0x19cc>
80009aa4:	fa ca f9 78 	sub	r10,sp,-1672
80009aa8:	02 9b       	mov	r11,r1
80009aaa:	08 9c       	mov	r12,r4
80009aac:	fe b0 f3 12 	rcall	800080d0 <__sprint_r>
80009ab0:	e0 81 02 9d 	brne	80009fea <_vfprintf_r+0x1efe>
80009ab4:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ab8:	21 06       	sub	r6,16
80009aba:	c0 48       	rjmp	80009ac2 <_vfprintf_r+0x19d6>
80009abc:	fe c2 ba dc 	sub	r2,pc,-17700
80009ac0:	31 00       	mov	r0,16
80009ac2:	fa f9 06 90 	ld.w	r9,sp[1680]
80009ac6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009aca:	fe ca ba ea 	sub	r10,pc,-17686
80009ace:	59 06       	cp.w	r6,16
80009ad0:	fe 99 ff dd 	brgt	80009a8a <_vfprintf_r+0x199e>
80009ad4:	0c 09       	add	r9,r6
80009ad6:	87 0a       	st.w	r3[0x0],r10
80009ad8:	fb 49 06 90 	st.w	sp[1680],r9
80009adc:	2f f8       	sub	r8,-1
80009ade:	87 16       	st.w	r3[0x4],r6
80009ae0:	c5 39       	rjmp	80009d86 <_vfprintf_r+0x1c9a>
80009ae2:	fa fa 06 ac 	ld.w	r10,sp[1708]
80009ae6:	58 0a       	cp.w	r10,0
80009ae8:	e0 89 00 92 	brgt	80009c0c <_vfprintf_r+0x1b20>
80009aec:	fa f8 06 90 	ld.w	r8,sp[1680]
80009af0:	fe c9 bb 24 	sub	r9,pc,-17628
80009af4:	2f f8       	sub	r8,-1
80009af6:	87 09       	st.w	r3[0x0],r9
80009af8:	fb 48 06 90 	st.w	sp[1680],r8
80009afc:	30 19       	mov	r9,1
80009afe:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b02:	87 19       	st.w	r3[0x4],r9
80009b04:	2f f8       	sub	r8,-1
80009b06:	fb 48 06 8c 	st.w	sp[1676],r8
80009b0a:	58 78       	cp.w	r8,7
80009b0c:	e0 89 00 04 	brgt	80009b14 <_vfprintf_r+0x1a28>
80009b10:	2f 83       	sub	r3,-8
80009b12:	c0 b8       	rjmp	80009b28 <_vfprintf_r+0x1a3c>
80009b14:	fa ca f9 78 	sub	r10,sp,-1672
80009b18:	02 9b       	mov	r11,r1
80009b1a:	08 9c       	mov	r12,r4
80009b1c:	fe b0 f2 da 	rcall	800080d0 <__sprint_r>
80009b20:	e0 81 02 65 	brne	80009fea <_vfprintf_r+0x1efe>
80009b24:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b28:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009b2c:	58 08       	cp.w	r8,0
80009b2e:	c0 81       	brne	80009b3e <_vfprintf_r+0x1a52>
80009b30:	40 6a       	lddsp	r10,sp[0x18]
80009b32:	58 0a       	cp.w	r10,0
80009b34:	c0 51       	brne	80009b3e <_vfprintf_r+0x1a52>
80009b36:	ed b5 00 00 	bld	r5,0x0
80009b3a:	e0 81 01 ed 	brne	80009f14 <_vfprintf_r+0x1e28>
80009b3e:	40 c9       	lddsp	r9,sp[0x30]
80009b40:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b44:	2f f8       	sub	r8,-1
80009b46:	87 09       	st.w	r3[0x0],r9
80009b48:	fb 48 06 90 	st.w	sp[1680],r8
80009b4c:	30 19       	mov	r9,1
80009b4e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b52:	87 19       	st.w	r3[0x4],r9
80009b54:	2f f8       	sub	r8,-1
80009b56:	fb 48 06 8c 	st.w	sp[1676],r8
80009b5a:	58 78       	cp.w	r8,7
80009b5c:	e0 89 00 04 	brgt	80009b64 <_vfprintf_r+0x1a78>
80009b60:	2f 83       	sub	r3,-8
80009b62:	c0 b8       	rjmp	80009b78 <_vfprintf_r+0x1a8c>
80009b64:	fa ca f9 78 	sub	r10,sp,-1672
80009b68:	02 9b       	mov	r11,r1
80009b6a:	08 9c       	mov	r12,r4
80009b6c:	fe b0 f2 b2 	rcall	800080d0 <__sprint_r>
80009b70:	e0 81 02 3d 	brne	80009fea <_vfprintf_r+0x1efe>
80009b74:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b78:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009b7c:	5c 32       	neg	r2
80009b7e:	58 02       	cp.w	r2,0
80009b80:	e0 89 00 1d 	brgt	80009bba <_vfprintf_r+0x1ace>
80009b84:	c3 d8       	rjmp	80009bfe <_vfprintf_r+0x1b12>
80009b86:	2f 09       	sub	r9,-16
80009b88:	2f f8       	sub	r8,-1
80009b8a:	31 0e       	mov	lr,16
80009b8c:	fb 49 06 90 	st.w	sp[1680],r9
80009b90:	87 00       	st.w	r3[0x0],r0
80009b92:	87 1e       	st.w	r3[0x4],lr
80009b94:	fb 48 06 8c 	st.w	sp[1676],r8
80009b98:	58 78       	cp.w	r8,7
80009b9a:	e0 89 00 04 	brgt	80009ba2 <_vfprintf_r+0x1ab6>
80009b9e:	2f 83       	sub	r3,-8
80009ba0:	c0 b8       	rjmp	80009bb6 <_vfprintf_r+0x1aca>
80009ba2:	fa ca f9 78 	sub	r10,sp,-1672
80009ba6:	02 9b       	mov	r11,r1
80009ba8:	08 9c       	mov	r12,r4
80009baa:	fe b0 f2 93 	rcall	800080d0 <__sprint_r>
80009bae:	e0 81 02 1e 	brne	80009fea <_vfprintf_r+0x1efe>
80009bb2:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bb6:	21 02       	sub	r2,16
80009bb8:	c0 38       	rjmp	80009bbe <_vfprintf_r+0x1ad2>
80009bba:	fe c0 bb da 	sub	r0,pc,-17446
80009bbe:	fa f9 06 90 	ld.w	r9,sp[1680]
80009bc2:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009bc6:	fe ca bb e6 	sub	r10,pc,-17434
80009bca:	59 02       	cp.w	r2,16
80009bcc:	fe 99 ff dd 	brgt	80009b86 <_vfprintf_r+0x1a9a>
80009bd0:	04 09       	add	r9,r2
80009bd2:	2f f8       	sub	r8,-1
80009bd4:	87 0a       	st.w	r3[0x0],r10
80009bd6:	fb 49 06 90 	st.w	sp[1680],r9
80009bda:	87 12       	st.w	r3[0x4],r2
80009bdc:	fb 48 06 8c 	st.w	sp[1676],r8
80009be0:	58 78       	cp.w	r8,7
80009be2:	e0 89 00 04 	brgt	80009bea <_vfprintf_r+0x1afe>
80009be6:	2f 83       	sub	r3,-8
80009be8:	c0 b8       	rjmp	80009bfe <_vfprintf_r+0x1b12>
80009bea:	fa ca f9 78 	sub	r10,sp,-1672
80009bee:	02 9b       	mov	r11,r1
80009bf0:	08 9c       	mov	r12,r4
80009bf2:	fe b0 f2 6f 	rcall	800080d0 <__sprint_r>
80009bf6:	e0 81 01 fa 	brne	80009fea <_vfprintf_r+0x1efe>
80009bfa:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bfe:	40 6c       	lddsp	r12,sp[0x18]
80009c00:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c04:	87 06       	st.w	r3[0x0],r6
80009c06:	87 1c       	st.w	r3[0x4],r12
80009c08:	18 08       	add	r8,r12
80009c0a:	cb 98       	rjmp	80009d7c <_vfprintf_r+0x1c90>
80009c0c:	fa f9 06 90 	ld.w	r9,sp[1680]
80009c10:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c14:	40 6b       	lddsp	r11,sp[0x18]
80009c16:	16 3a       	cp.w	r10,r11
80009c18:	c6 f5       	brlt	80009cf6 <_vfprintf_r+0x1c0a>
80009c1a:	16 09       	add	r9,r11
80009c1c:	2f f8       	sub	r8,-1
80009c1e:	87 06       	st.w	r3[0x0],r6
80009c20:	fb 49 06 90 	st.w	sp[1680],r9
80009c24:	87 1b       	st.w	r3[0x4],r11
80009c26:	fb 48 06 8c 	st.w	sp[1676],r8
80009c2a:	58 78       	cp.w	r8,7
80009c2c:	e0 89 00 04 	brgt	80009c34 <_vfprintf_r+0x1b48>
80009c30:	2f 83       	sub	r3,-8
80009c32:	c0 b8       	rjmp	80009c48 <_vfprintf_r+0x1b5c>
80009c34:	fa ca f9 78 	sub	r10,sp,-1672
80009c38:	02 9b       	mov	r11,r1
80009c3a:	08 9c       	mov	r12,r4
80009c3c:	fe b0 f2 4a 	rcall	800080d0 <__sprint_r>
80009c40:	e0 81 01 d5 	brne	80009fea <_vfprintf_r+0x1efe>
80009c44:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c48:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009c4c:	40 6a       	lddsp	r10,sp[0x18]
80009c4e:	14 16       	sub	r6,r10
80009c50:	58 06       	cp.w	r6,0
80009c52:	e0 89 00 1c 	brgt	80009c8a <_vfprintf_r+0x1b9e>
80009c56:	c3 d8       	rjmp	80009cd0 <_vfprintf_r+0x1be4>
80009c58:	2f 09       	sub	r9,-16
80009c5a:	2f f8       	sub	r8,-1
80009c5c:	fb 49 06 90 	st.w	sp[1680],r9
80009c60:	87 02       	st.w	r3[0x0],r2
80009c62:	87 10       	st.w	r3[0x4],r0
80009c64:	fb 48 06 8c 	st.w	sp[1676],r8
80009c68:	58 78       	cp.w	r8,7
80009c6a:	e0 89 00 04 	brgt	80009c72 <_vfprintf_r+0x1b86>
80009c6e:	2f 83       	sub	r3,-8
80009c70:	c0 b8       	rjmp	80009c86 <_vfprintf_r+0x1b9a>
80009c72:	fa ca f9 78 	sub	r10,sp,-1672
80009c76:	02 9b       	mov	r11,r1
80009c78:	08 9c       	mov	r12,r4
80009c7a:	fe b0 f2 2b 	rcall	800080d0 <__sprint_r>
80009c7e:	e0 81 01 b6 	brne	80009fea <_vfprintf_r+0x1efe>
80009c82:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c86:	21 06       	sub	r6,16
80009c88:	c0 48       	rjmp	80009c90 <_vfprintf_r+0x1ba4>
80009c8a:	fe c2 bc aa 	sub	r2,pc,-17238
80009c8e:	31 00       	mov	r0,16
80009c90:	fa f9 06 90 	ld.w	r9,sp[1680]
80009c94:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c98:	fe ca bc b8 	sub	r10,pc,-17224
80009c9c:	59 06       	cp.w	r6,16
80009c9e:	fe 99 ff dd 	brgt	80009c58 <_vfprintf_r+0x1b6c>
80009ca2:	0c 09       	add	r9,r6
80009ca4:	2f f8       	sub	r8,-1
80009ca6:	87 0a       	st.w	r3[0x0],r10
80009ca8:	fb 49 06 90 	st.w	sp[1680],r9
80009cac:	87 16       	st.w	r3[0x4],r6
80009cae:	fb 48 06 8c 	st.w	sp[1676],r8
80009cb2:	58 78       	cp.w	r8,7
80009cb4:	e0 89 00 04 	brgt	80009cbc <_vfprintf_r+0x1bd0>
80009cb8:	2f 83       	sub	r3,-8
80009cba:	c0 b8       	rjmp	80009cd0 <_vfprintf_r+0x1be4>
80009cbc:	fa ca f9 78 	sub	r10,sp,-1672
80009cc0:	02 9b       	mov	r11,r1
80009cc2:	08 9c       	mov	r12,r4
80009cc4:	fe b0 f2 06 	rcall	800080d0 <__sprint_r>
80009cc8:	e0 81 01 91 	brne	80009fea <_vfprintf_r+0x1efe>
80009ccc:	fa c3 f9 e0 	sub	r3,sp,-1568
80009cd0:	ed b5 00 00 	bld	r5,0x0
80009cd4:	e0 81 01 20 	brne	80009f14 <_vfprintf_r+0x1e28>
80009cd8:	40 c9       	lddsp	r9,sp[0x30]
80009cda:	fa f8 06 90 	ld.w	r8,sp[1680]
80009cde:	2f f8       	sub	r8,-1
80009ce0:	87 09       	st.w	r3[0x0],r9
80009ce2:	fb 48 06 90 	st.w	sp[1680],r8
80009ce6:	30 19       	mov	r9,1
80009ce8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009cec:	87 19       	st.w	r3[0x4],r9
80009cee:	2f f8       	sub	r8,-1
80009cf0:	fb 48 06 8c 	st.w	sp[1676],r8
80009cf4:	c0 29       	rjmp	80009ef8 <_vfprintf_r+0x1e0c>
80009cf6:	14 09       	add	r9,r10
80009cf8:	2f f8       	sub	r8,-1
80009cfa:	fb 49 06 90 	st.w	sp[1680],r9
80009cfe:	87 06       	st.w	r3[0x0],r6
80009d00:	87 1a       	st.w	r3[0x4],r10
80009d02:	fb 48 06 8c 	st.w	sp[1676],r8
80009d06:	58 78       	cp.w	r8,7
80009d08:	e0 89 00 04 	brgt	80009d10 <_vfprintf_r+0x1c24>
80009d0c:	2f 83       	sub	r3,-8
80009d0e:	c0 b8       	rjmp	80009d24 <_vfprintf_r+0x1c38>
80009d10:	fa ca f9 78 	sub	r10,sp,-1672
80009d14:	02 9b       	mov	r11,r1
80009d16:	08 9c       	mov	r12,r4
80009d18:	fe b0 f1 dc 	rcall	800080d0 <__sprint_r>
80009d1c:	e0 81 01 67 	brne	80009fea <_vfprintf_r+0x1efe>
80009d20:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d24:	40 c8       	lddsp	r8,sp[0x30]
80009d26:	87 08       	st.w	r3[0x0],r8
80009d28:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d2c:	2f f8       	sub	r8,-1
80009d2e:	30 19       	mov	r9,1
80009d30:	fb 48 06 90 	st.w	sp[1680],r8
80009d34:	87 19       	st.w	r3[0x4],r9
80009d36:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d3a:	2f f8       	sub	r8,-1
80009d3c:	fb 48 06 8c 	st.w	sp[1676],r8
80009d40:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009d44:	58 78       	cp.w	r8,7
80009d46:	e0 89 00 04 	brgt	80009d4e <_vfprintf_r+0x1c62>
80009d4a:	2f 83       	sub	r3,-8
80009d4c:	c0 b8       	rjmp	80009d62 <_vfprintf_r+0x1c76>
80009d4e:	fa ca f9 78 	sub	r10,sp,-1672
80009d52:	02 9b       	mov	r11,r1
80009d54:	08 9c       	mov	r12,r4
80009d56:	fe b0 f1 bd 	rcall	800080d0 <__sprint_r>
80009d5a:	e0 81 01 48 	brne	80009fea <_vfprintf_r+0x1efe>
80009d5e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d62:	04 06       	add	r6,r2
80009d64:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009d68:	87 06       	st.w	r3[0x0],r6
80009d6a:	fa f9 06 90 	ld.w	r9,sp[1680]
80009d6e:	40 66       	lddsp	r6,sp[0x18]
80009d70:	40 6e       	lddsp	lr,sp[0x18]
80009d72:	10 16       	sub	r6,r8
80009d74:	f2 08 01 08 	sub	r8,r9,r8
80009d78:	87 16       	st.w	r3[0x4],r6
80009d7a:	1c 08       	add	r8,lr
80009d7c:	fb 48 06 90 	st.w	sp[1680],r8
80009d80:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d84:	2f f8       	sub	r8,-1
80009d86:	fb 48 06 8c 	st.w	sp[1676],r8
80009d8a:	cb 78       	rjmp	80009ef8 <_vfprintf_r+0x1e0c>
80009d8c:	40 6c       	lddsp	r12,sp[0x18]
80009d8e:	58 1c       	cp.w	r12,1
80009d90:	e0 89 00 06 	brgt	80009d9c <_vfprintf_r+0x1cb0>
80009d94:	ed b5 00 00 	bld	r5,0x0
80009d98:	e0 81 00 85 	brne	80009ea2 <_vfprintf_r+0x1db6>
80009d9c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009da0:	2f f8       	sub	r8,-1
80009da2:	30 19       	mov	r9,1
80009da4:	fb 48 06 90 	st.w	sp[1680],r8
80009da8:	87 06       	st.w	r3[0x0],r6
80009daa:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009dae:	87 19       	st.w	r3[0x4],r9
80009db0:	2f f8       	sub	r8,-1
80009db2:	fb 48 06 8c 	st.w	sp[1676],r8
80009db6:	58 78       	cp.w	r8,7
80009db8:	e0 89 00 04 	brgt	80009dc0 <_vfprintf_r+0x1cd4>
80009dbc:	2f 83       	sub	r3,-8
80009dbe:	c0 b8       	rjmp	80009dd4 <_vfprintf_r+0x1ce8>
80009dc0:	fa ca f9 78 	sub	r10,sp,-1672
80009dc4:	02 9b       	mov	r11,r1
80009dc6:	08 9c       	mov	r12,r4
80009dc8:	fe b0 f1 84 	rcall	800080d0 <__sprint_r>
80009dcc:	e0 81 01 0f 	brne	80009fea <_vfprintf_r+0x1efe>
80009dd0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009dd4:	fa f8 06 90 	ld.w	r8,sp[1680]
80009dd8:	2f f8       	sub	r8,-1
80009dda:	40 cb       	lddsp	r11,sp[0x30]
80009ddc:	fb 48 06 90 	st.w	sp[1680],r8
80009de0:	30 19       	mov	r9,1
80009de2:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009de6:	87 0b       	st.w	r3[0x0],r11
80009de8:	2f f8       	sub	r8,-1
80009dea:	87 19       	st.w	r3[0x4],r9
80009dec:	fb 48 06 8c 	st.w	sp[1676],r8
80009df0:	58 78       	cp.w	r8,7
80009df2:	e0 89 00 05 	brgt	80009dfc <_vfprintf_r+0x1d10>
80009df6:	2f 83       	sub	r3,-8
80009df8:	c0 c8       	rjmp	80009e10 <_vfprintf_r+0x1d24>
80009dfa:	d7 03       	nop
80009dfc:	fa ca f9 78 	sub	r10,sp,-1672
80009e00:	02 9b       	mov	r11,r1
80009e02:	08 9c       	mov	r12,r4
80009e04:	fe b0 f1 66 	rcall	800080d0 <__sprint_r>
80009e08:	e0 81 00 f1 	brne	80009fea <_vfprintf_r+0x1efe>
80009e0c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e10:	30 08       	mov	r8,0
80009e12:	30 09       	mov	r9,0
80009e14:	40 5b       	lddsp	r11,sp[0x14]
80009e16:	40 7a       	lddsp	r10,sp[0x1c]
80009e18:	e0 a0 13 25 	rcall	8000c462 <__avr32_f64_cmp_eq>
80009e1c:	40 68       	lddsp	r8,sp[0x18]
80009e1e:	20 18       	sub	r8,1
80009e20:	58 0c       	cp.w	r12,0
80009e22:	c0 d1       	brne	80009e3c <_vfprintf_r+0x1d50>
80009e24:	2f f6       	sub	r6,-1
80009e26:	87 18       	st.w	r3[0x4],r8
80009e28:	87 06       	st.w	r3[0x0],r6
80009e2a:	fa f6 06 90 	ld.w	r6,sp[1680]
80009e2e:	10 06       	add	r6,r8
80009e30:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e34:	fb 46 06 90 	st.w	sp[1680],r6
80009e38:	2f f8       	sub	r8,-1
80009e3a:	c3 18       	rjmp	80009e9c <_vfprintf_r+0x1db0>
80009e3c:	10 96       	mov	r6,r8
80009e3e:	58 08       	cp.w	r8,0
80009e40:	e0 89 00 1c 	brgt	80009e78 <_vfprintf_r+0x1d8c>
80009e44:	c4 b8       	rjmp	80009eda <_vfprintf_r+0x1dee>
80009e46:	2f 09       	sub	r9,-16
80009e48:	2f f8       	sub	r8,-1
80009e4a:	fb 49 06 90 	st.w	sp[1680],r9
80009e4e:	87 02       	st.w	r3[0x0],r2
80009e50:	87 10       	st.w	r3[0x4],r0
80009e52:	fb 48 06 8c 	st.w	sp[1676],r8
80009e56:	58 78       	cp.w	r8,7
80009e58:	e0 89 00 04 	brgt	80009e60 <_vfprintf_r+0x1d74>
80009e5c:	2f 83       	sub	r3,-8
80009e5e:	c0 b8       	rjmp	80009e74 <_vfprintf_r+0x1d88>
80009e60:	fa ca f9 78 	sub	r10,sp,-1672
80009e64:	02 9b       	mov	r11,r1
80009e66:	08 9c       	mov	r12,r4
80009e68:	fe b0 f1 34 	rcall	800080d0 <__sprint_r>
80009e6c:	e0 81 00 bf 	brne	80009fea <_vfprintf_r+0x1efe>
80009e70:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e74:	21 06       	sub	r6,16
80009e76:	c0 48       	rjmp	80009e7e <_vfprintf_r+0x1d92>
80009e78:	fe c2 be 98 	sub	r2,pc,-16744
80009e7c:	31 00       	mov	r0,16
80009e7e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009e82:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e86:	fe ca be a6 	sub	r10,pc,-16730
80009e8a:	59 06       	cp.w	r6,16
80009e8c:	fe 99 ff dd 	brgt	80009e46 <_vfprintf_r+0x1d5a>
80009e90:	0c 09       	add	r9,r6
80009e92:	87 0a       	st.w	r3[0x0],r10
80009e94:	fb 49 06 90 	st.w	sp[1680],r9
80009e98:	2f f8       	sub	r8,-1
80009e9a:	87 16       	st.w	r3[0x4],r6
80009e9c:	fb 48 06 8c 	st.w	sp[1676],r8
80009ea0:	c0 e8       	rjmp	80009ebc <_vfprintf_r+0x1dd0>
80009ea2:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ea6:	2f f8       	sub	r8,-1
80009ea8:	30 19       	mov	r9,1
80009eaa:	fb 48 06 90 	st.w	sp[1680],r8
80009eae:	87 06       	st.w	r3[0x0],r6
80009eb0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009eb4:	87 19       	st.w	r3[0x4],r9
80009eb6:	2f f8       	sub	r8,-1
80009eb8:	fb 48 06 8c 	st.w	sp[1676],r8
80009ebc:	58 78       	cp.w	r8,7
80009ebe:	e0 89 00 04 	brgt	80009ec6 <_vfprintf_r+0x1dda>
80009ec2:	2f 83       	sub	r3,-8
80009ec4:	c0 b8       	rjmp	80009eda <_vfprintf_r+0x1dee>
80009ec6:	fa ca f9 78 	sub	r10,sp,-1672
80009eca:	02 9b       	mov	r11,r1
80009ecc:	08 9c       	mov	r12,r4
80009ece:	fe b0 f1 01 	rcall	800080d0 <__sprint_r>
80009ed2:	e0 81 00 8c 	brne	80009fea <_vfprintf_r+0x1efe>
80009ed6:	fa c3 f9 e0 	sub	r3,sp,-1568
80009eda:	40 ea       	lddsp	r10,sp[0x38]
80009edc:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ee0:	14 08       	add	r8,r10
80009ee2:	fa c9 f9 64 	sub	r9,sp,-1692
80009ee6:	fb 48 06 90 	st.w	sp[1680],r8
80009eea:	87 1a       	st.w	r3[0x4],r10
80009eec:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ef0:	87 09       	st.w	r3[0x0],r9
80009ef2:	2f f8       	sub	r8,-1
80009ef4:	fb 48 06 8c 	st.w	sp[1676],r8
80009ef8:	58 78       	cp.w	r8,7
80009efa:	e0 89 00 04 	brgt	80009f02 <_vfprintf_r+0x1e16>
80009efe:	2f 83       	sub	r3,-8
80009f00:	c0 a8       	rjmp	80009f14 <_vfprintf_r+0x1e28>
80009f02:	fa ca f9 78 	sub	r10,sp,-1672
80009f06:	02 9b       	mov	r11,r1
80009f08:	08 9c       	mov	r12,r4
80009f0a:	fe b0 f0 e3 	rcall	800080d0 <__sprint_r>
80009f0e:	c6 e1       	brne	80009fea <_vfprintf_r+0x1efe>
80009f10:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f14:	e2 15 00 04 	andl	r5,0x4,COH
80009f18:	c3 f0       	breq	80009f96 <_vfprintf_r+0x1eaa>
80009f1a:	40 86       	lddsp	r6,sp[0x20]
80009f1c:	40 39       	lddsp	r9,sp[0xc]
80009f1e:	12 16       	sub	r6,r9
80009f20:	58 06       	cp.w	r6,0
80009f22:	e0 89 00 1a 	brgt	80009f56 <_vfprintf_r+0x1e6a>
80009f26:	c3 88       	rjmp	80009f96 <_vfprintf_r+0x1eaa>
80009f28:	2f 09       	sub	r9,-16
80009f2a:	2f f8       	sub	r8,-1
80009f2c:	fb 49 06 90 	st.w	sp[1680],r9
80009f30:	87 05       	st.w	r3[0x0],r5
80009f32:	87 12       	st.w	r3[0x4],r2
80009f34:	fb 48 06 8c 	st.w	sp[1676],r8
80009f38:	58 78       	cp.w	r8,7
80009f3a:	e0 89 00 04 	brgt	80009f42 <_vfprintf_r+0x1e56>
80009f3e:	2f 83       	sub	r3,-8
80009f40:	c0 98       	rjmp	80009f52 <_vfprintf_r+0x1e66>
80009f42:	00 9a       	mov	r10,r0
80009f44:	02 9b       	mov	r11,r1
80009f46:	08 9c       	mov	r12,r4
80009f48:	fe b0 f0 c4 	rcall	800080d0 <__sprint_r>
80009f4c:	c4 f1       	brne	80009fea <_vfprintf_r+0x1efe>
80009f4e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f52:	21 06       	sub	r6,16
80009f54:	c0 68       	rjmp	80009f60 <_vfprintf_r+0x1e74>
80009f56:	fe c5 bf 86 	sub	r5,pc,-16506
80009f5a:	31 02       	mov	r2,16
80009f5c:	fa c0 f9 78 	sub	r0,sp,-1672
80009f60:	fa f9 06 90 	ld.w	r9,sp[1680]
80009f64:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009f68:	fe ca bf 98 	sub	r10,pc,-16488
80009f6c:	59 06       	cp.w	r6,16
80009f6e:	fe 99 ff dd 	brgt	80009f28 <_vfprintf_r+0x1e3c>
80009f72:	0c 09       	add	r9,r6
80009f74:	2f f8       	sub	r8,-1
80009f76:	87 0a       	st.w	r3[0x0],r10
80009f78:	87 16       	st.w	r3[0x4],r6
80009f7a:	fb 49 06 90 	st.w	sp[1680],r9
80009f7e:	fb 48 06 8c 	st.w	sp[1676],r8
80009f82:	58 78       	cp.w	r8,7
80009f84:	e0 8a 00 09 	brle	80009f96 <_vfprintf_r+0x1eaa>
80009f88:	fa ca f9 78 	sub	r10,sp,-1672
80009f8c:	02 9b       	mov	r11,r1
80009f8e:	08 9c       	mov	r12,r4
80009f90:	fe b0 f0 a0 	rcall	800080d0 <__sprint_r>
80009f94:	c2 b1       	brne	80009fea <_vfprintf_r+0x1efe>
80009f96:	40 bc       	lddsp	r12,sp[0x2c]
80009f98:	40 36       	lddsp	r6,sp[0xc]
80009f9a:	40 8e       	lddsp	lr,sp[0x20]
80009f9c:	ec 0e 0c 48 	max	r8,r6,lr
80009fa0:	10 0c       	add	r12,r8
80009fa2:	50 bc       	stdsp	sp[0x2c],r12
80009fa4:	fa f8 06 90 	ld.w	r8,sp[1680]
80009fa8:	58 08       	cp.w	r8,0
80009faa:	c0 80       	breq	80009fba <_vfprintf_r+0x1ece>
80009fac:	fa ca f9 78 	sub	r10,sp,-1672
80009fb0:	02 9b       	mov	r11,r1
80009fb2:	08 9c       	mov	r12,r4
80009fb4:	fe b0 f0 8e 	rcall	800080d0 <__sprint_r>
80009fb8:	c1 91       	brne	80009fea <_vfprintf_r+0x1efe>
80009fba:	30 0b       	mov	r11,0
80009fbc:	fa c3 f9 e0 	sub	r3,sp,-1568
80009fc0:	fb 4b 06 8c 	st.w	sp[1676],r11
80009fc4:	fe 9f f1 22 	bral	80008208 <_vfprintf_r+0x11c>
80009fc8:	08 95       	mov	r5,r4
80009fca:	fa f8 06 90 	ld.w	r8,sp[1680]
80009fce:	58 08       	cp.w	r8,0
80009fd0:	c0 80       	breq	80009fe0 <_vfprintf_r+0x1ef4>
80009fd2:	08 9c       	mov	r12,r4
80009fd4:	fa ca f9 78 	sub	r10,sp,-1672
80009fd8:	02 9b       	mov	r11,r1
80009fda:	fe b0 f0 7b 	rcall	800080d0 <__sprint_r>
80009fde:	c0 61       	brne	80009fea <_vfprintf_r+0x1efe>
80009fe0:	30 08       	mov	r8,0
80009fe2:	fb 48 06 8c 	st.w	sp[1676],r8
80009fe6:	c0 28       	rjmp	80009fea <_vfprintf_r+0x1efe>
80009fe8:	40 41       	lddsp	r1,sp[0x10]
80009fea:	82 68       	ld.sh	r8,r1[0xc]
80009fec:	ed b8 00 06 	bld	r8,0x6
80009ff0:	c0 31       	brne	80009ff6 <_vfprintf_r+0x1f0a>
80009ff2:	3f fa       	mov	r10,-1
80009ff4:	50 ba       	stdsp	sp[0x2c],r10
80009ff6:	40 bc       	lddsp	r12,sp[0x2c]
80009ff8:	fe 3d f9 44 	sub	sp,-1724
80009ffc:	d8 32       	popm	r0-r7,pc
80009ffe:	d7 03       	nop

8000a000 <__swsetup_r>:
8000a000:	d4 21       	pushm	r4-r7,lr
8000a002:	e0 68 0a 3c 	mov	r8,2620
8000a006:	18 96       	mov	r6,r12
8000a008:	16 97       	mov	r7,r11
8000a00a:	70 0c       	ld.w	r12,r8[0x0]
8000a00c:	58 0c       	cp.w	r12,0
8000a00e:	c0 60       	breq	8000a01a <__swsetup_r+0x1a>
8000a010:	78 68       	ld.w	r8,r12[0x18]
8000a012:	58 08       	cp.w	r8,0
8000a014:	c0 31       	brne	8000a01a <__swsetup_r+0x1a>
8000a016:	e0 a0 07 bf 	rcall	8000af94 <__sinit>
8000a01a:	fe c8 bf 1a 	sub	r8,pc,-16614
8000a01e:	10 37       	cp.w	r7,r8
8000a020:	c0 61       	brne	8000a02c <__swsetup_r+0x2c>
8000a022:	e0 68 0a 3c 	mov	r8,2620
8000a026:	70 08       	ld.w	r8,r8[0x0]
8000a028:	70 07       	ld.w	r7,r8[0x0]
8000a02a:	c1 28       	rjmp	8000a04e <__swsetup_r+0x4e>
8000a02c:	fe c8 bf 0c 	sub	r8,pc,-16628
8000a030:	10 37       	cp.w	r7,r8
8000a032:	c0 61       	brne	8000a03e <__swsetup_r+0x3e>
8000a034:	e0 68 0a 3c 	mov	r8,2620
8000a038:	70 08       	ld.w	r8,r8[0x0]
8000a03a:	70 17       	ld.w	r7,r8[0x4]
8000a03c:	c0 98       	rjmp	8000a04e <__swsetup_r+0x4e>
8000a03e:	fe c8 be fe 	sub	r8,pc,-16642
8000a042:	10 37       	cp.w	r7,r8
8000a044:	c0 51       	brne	8000a04e <__swsetup_r+0x4e>
8000a046:	e0 68 0a 3c 	mov	r8,2620
8000a04a:	70 08       	ld.w	r8,r8[0x0]
8000a04c:	70 27       	ld.w	r7,r8[0x8]
8000a04e:	8e 68       	ld.sh	r8,r7[0xc]
8000a050:	ed b8 00 03 	bld	r8,0x3
8000a054:	c1 e0       	breq	8000a090 <__swsetup_r+0x90>
8000a056:	ed b8 00 04 	bld	r8,0x4
8000a05a:	c3 e1       	brne	8000a0d6 <__swsetup_r+0xd6>
8000a05c:	ed b8 00 02 	bld	r8,0x2
8000a060:	c1 51       	brne	8000a08a <__swsetup_r+0x8a>
8000a062:	6e db       	ld.w	r11,r7[0x34]
8000a064:	58 0b       	cp.w	r11,0
8000a066:	c0 a0       	breq	8000a07a <__swsetup_r+0x7a>
8000a068:	ee c8 ff bc 	sub	r8,r7,-68
8000a06c:	10 3b       	cp.w	r11,r8
8000a06e:	c0 40       	breq	8000a076 <__swsetup_r+0x76>
8000a070:	0c 9c       	mov	r12,r6
8000a072:	e0 a0 08 2b 	rcall	8000b0c8 <_free_r>
8000a076:	30 08       	mov	r8,0
8000a078:	8f d8       	st.w	r7[0x34],r8
8000a07a:	8e 68       	ld.sh	r8,r7[0xc]
8000a07c:	e0 18 ff db 	andl	r8,0xffdb
8000a080:	ae 68       	st.h	r7[0xc],r8
8000a082:	30 08       	mov	r8,0
8000a084:	8f 18       	st.w	r7[0x4],r8
8000a086:	6e 48       	ld.w	r8,r7[0x10]
8000a088:	8f 08       	st.w	r7[0x0],r8
8000a08a:	8e 68       	ld.sh	r8,r7[0xc]
8000a08c:	a3 b8       	sbr	r8,0x3
8000a08e:	ae 68       	st.h	r7[0xc],r8
8000a090:	6e 48       	ld.w	r8,r7[0x10]
8000a092:	58 08       	cp.w	r8,0
8000a094:	c0 b1       	brne	8000a0aa <__swsetup_r+0xaa>
8000a096:	8e 68       	ld.sh	r8,r7[0xc]
8000a098:	e2 18 02 80 	andl	r8,0x280,COH
8000a09c:	e0 48 02 00 	cp.w	r8,512
8000a0a0:	c0 50       	breq	8000a0aa <__swsetup_r+0xaa>
8000a0a2:	0c 9c       	mov	r12,r6
8000a0a4:	0e 9b       	mov	r11,r7
8000a0a6:	e0 a0 0a 4b 	rcall	8000b53c <__smakebuf_r>
8000a0aa:	8e 69       	ld.sh	r9,r7[0xc]
8000a0ac:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000a0b0:	c0 70       	breq	8000a0be <__swsetup_r+0xbe>
8000a0b2:	30 08       	mov	r8,0
8000a0b4:	8f 28       	st.w	r7[0x8],r8
8000a0b6:	6e 58       	ld.w	r8,r7[0x14]
8000a0b8:	5c 38       	neg	r8
8000a0ba:	8f 68       	st.w	r7[0x18],r8
8000a0bc:	c0 68       	rjmp	8000a0c8 <__swsetup_r+0xc8>
8000a0be:	ed b9 00 01 	bld	r9,0x1
8000a0c2:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000a0c6:	8f 28       	st.w	r7[0x8],r8
8000a0c8:	6e 48       	ld.w	r8,r7[0x10]
8000a0ca:	58 08       	cp.w	r8,0
8000a0cc:	c0 61       	brne	8000a0d8 <__swsetup_r+0xd8>
8000a0ce:	8e 68       	ld.sh	r8,r7[0xc]
8000a0d0:	ed b8 00 07 	bld	r8,0x7
8000a0d4:	c0 21       	brne	8000a0d8 <__swsetup_r+0xd8>
8000a0d6:	dc 2a       	popm	r4-r7,pc,r12=-1
8000a0d8:	d8 2a       	popm	r4-r7,pc,r12=0
8000a0da:	d7 03       	nop

8000a0dc <quorem>:
8000a0dc:	d4 31       	pushm	r0-r7,lr
8000a0de:	20 2d       	sub	sp,8
8000a0e0:	18 97       	mov	r7,r12
8000a0e2:	78 48       	ld.w	r8,r12[0x10]
8000a0e4:	76 46       	ld.w	r6,r11[0x10]
8000a0e6:	0c 38       	cp.w	r8,r6
8000a0e8:	c0 34       	brge	8000a0ee <quorem+0x12>
8000a0ea:	30 0c       	mov	r12,0
8000a0ec:	c8 58       	rjmp	8000a1f6 <quorem+0x11a>
8000a0ee:	ec c2 ff fc 	sub	r2,r6,-4
8000a0f2:	f6 c3 ff ec 	sub	r3,r11,-20
8000a0f6:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000a0fa:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000a0fe:	2f f9       	sub	r9,-1
8000a100:	20 16       	sub	r6,1
8000a102:	f8 09 0d 08 	divu	r8,r12,r9
8000a106:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000a10a:	ee c4 ff ec 	sub	r4,r7,-20
8000a10e:	10 95       	mov	r5,r8
8000a110:	58 08       	cp.w	r8,0
8000a112:	c4 10       	breq	8000a194 <quorem+0xb8>
8000a114:	30 09       	mov	r9,0
8000a116:	06 9a       	mov	r10,r3
8000a118:	08 98       	mov	r8,r4
8000a11a:	12 91       	mov	r1,r9
8000a11c:	50 0b       	stdsp	sp[0x0],r11
8000a11e:	70 0e       	ld.w	lr,r8[0x0]
8000a120:	b1 8e       	lsr	lr,0x10
8000a122:	50 1e       	stdsp	sp[0x4],lr
8000a124:	15 0e       	ld.w	lr,r10++
8000a126:	fc 00 16 10 	lsr	r0,lr,0x10
8000a12a:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a12e:	ea 0e 03 41 	mac	r1,r5,lr
8000a132:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000a136:	b1 81       	lsr	r1,0x10
8000a138:	40 1b       	lddsp	r11,sp[0x4]
8000a13a:	ea 00 02 40 	mul	r0,r5,r0
8000a13e:	e2 00 00 00 	add	r0,r1,r0
8000a142:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000a146:	02 1b       	sub	r11,r1
8000a148:	50 1b       	stdsp	sp[0x4],r11
8000a14a:	70 0b       	ld.w	r11,r8[0x0]
8000a14c:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000a150:	02 09       	add	r9,r1
8000a152:	f2 0e 01 0e 	sub	lr,r9,lr
8000a156:	b0 1e       	st.h	r8[0x2],lr
8000a158:	fc 09 14 10 	asr	r9,lr,0x10
8000a15c:	40 1e       	lddsp	lr,sp[0x4]
8000a15e:	fc 09 00 09 	add	r9,lr,r9
8000a162:	b0 09       	st.h	r8[0x0],r9
8000a164:	e0 01 16 10 	lsr	r1,r0,0x10
8000a168:	2f c8       	sub	r8,-4
8000a16a:	b1 49       	asr	r9,0x10
8000a16c:	04 3a       	cp.w	r10,r2
8000a16e:	fe 98 ff d8 	brls	8000a11e <quorem+0x42>
8000a172:	40 0b       	lddsp	r11,sp[0x0]
8000a174:	58 0c       	cp.w	r12,0
8000a176:	c0 f1       	brne	8000a194 <quorem+0xb8>
8000a178:	ec c8 ff fb 	sub	r8,r6,-5
8000a17c:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a180:	c0 28       	rjmp	8000a184 <quorem+0xa8>
8000a182:	20 16       	sub	r6,1
8000a184:	20 48       	sub	r8,4
8000a186:	08 38       	cp.w	r8,r4
8000a188:	e0 88 00 05 	brls	8000a192 <quorem+0xb6>
8000a18c:	70 09       	ld.w	r9,r8[0x0]
8000a18e:	58 09       	cp.w	r9,0
8000a190:	cf 90       	breq	8000a182 <quorem+0xa6>
8000a192:	8f 46       	st.w	r7[0x10],r6
8000a194:	0e 9c       	mov	r12,r7
8000a196:	e0 a0 0a d2 	rcall	8000b73a <__mcmp>
8000a19a:	c2 d5       	brlt	8000a1f4 <quorem+0x118>
8000a19c:	2f f5       	sub	r5,-1
8000a19e:	08 98       	mov	r8,r4
8000a1a0:	30 09       	mov	r9,0
8000a1a2:	07 0b       	ld.w	r11,r3++
8000a1a4:	f6 0a 16 10 	lsr	r10,r11,0x10
8000a1a8:	70 0c       	ld.w	r12,r8[0x0]
8000a1aa:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a1ae:	f8 0e 16 10 	lsr	lr,r12,0x10
8000a1b2:	14 1e       	sub	lr,r10
8000a1b4:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000a1b8:	16 1a       	sub	r10,r11
8000a1ba:	12 0a       	add	r10,r9
8000a1bc:	b0 1a       	st.h	r8[0x2],r10
8000a1be:	b1 4a       	asr	r10,0x10
8000a1c0:	fc 0a 00 09 	add	r9,lr,r10
8000a1c4:	b0 09       	st.h	r8[0x0],r9
8000a1c6:	2f c8       	sub	r8,-4
8000a1c8:	b1 49       	asr	r9,0x10
8000a1ca:	04 33       	cp.w	r3,r2
8000a1cc:	fe 98 ff eb 	brls	8000a1a2 <quorem+0xc6>
8000a1d0:	ec c8 ff fb 	sub	r8,r6,-5
8000a1d4:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000a1d8:	58 09       	cp.w	r9,0
8000a1da:	c0 d1       	brne	8000a1f4 <quorem+0x118>
8000a1dc:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a1e0:	c0 28       	rjmp	8000a1e4 <quorem+0x108>
8000a1e2:	20 16       	sub	r6,1
8000a1e4:	20 48       	sub	r8,4
8000a1e6:	08 38       	cp.w	r8,r4
8000a1e8:	e0 88 00 05 	brls	8000a1f2 <quorem+0x116>
8000a1ec:	70 09       	ld.w	r9,r8[0x0]
8000a1ee:	58 09       	cp.w	r9,0
8000a1f0:	cf 90       	breq	8000a1e2 <quorem+0x106>
8000a1f2:	8f 46       	st.w	r7[0x10],r6
8000a1f4:	0a 9c       	mov	r12,r5
8000a1f6:	2f ed       	sub	sp,-8
8000a1f8:	d8 32       	popm	r0-r7,pc
8000a1fa:	d7 03       	nop

8000a1fc <_dtoa_r>:
8000a1fc:	d4 31       	pushm	r0-r7,lr
8000a1fe:	21 ad       	sub	sp,104
8000a200:	fa c4 ff 74 	sub	r4,sp,-140
8000a204:	18 97       	mov	r7,r12
8000a206:	16 95       	mov	r5,r11
8000a208:	68 2c       	ld.w	r12,r4[0x8]
8000a20a:	50 c9       	stdsp	sp[0x30],r9
8000a20c:	68 16       	ld.w	r6,r4[0x4]
8000a20e:	68 09       	ld.w	r9,r4[0x0]
8000a210:	50 e8       	stdsp	sp[0x38],r8
8000a212:	14 94       	mov	r4,r10
8000a214:	51 2c       	stdsp	sp[0x48],r12
8000a216:	fa e5 00 08 	st.d	sp[8],r4
8000a21a:	51 59       	stdsp	sp[0x54],r9
8000a21c:	6e 95       	ld.w	r5,r7[0x24]
8000a21e:	58 05       	cp.w	r5,0
8000a220:	c0 91       	brne	8000a232 <_dtoa_r+0x36>
8000a222:	31 0c       	mov	r12,16
8000a224:	fe b0 e8 f4 	rcall	8000740c <malloc>
8000a228:	99 35       	st.w	r12[0xc],r5
8000a22a:	8f 9c       	st.w	r7[0x24],r12
8000a22c:	99 15       	st.w	r12[0x4],r5
8000a22e:	99 25       	st.w	r12[0x8],r5
8000a230:	99 05       	st.w	r12[0x0],r5
8000a232:	6e 99       	ld.w	r9,r7[0x24]
8000a234:	72 08       	ld.w	r8,r9[0x0]
8000a236:	58 08       	cp.w	r8,0
8000a238:	c0 f0       	breq	8000a256 <_dtoa_r+0x5a>
8000a23a:	72 1a       	ld.w	r10,r9[0x4]
8000a23c:	91 1a       	st.w	r8[0x4],r10
8000a23e:	30 1a       	mov	r10,1
8000a240:	72 19       	ld.w	r9,r9[0x4]
8000a242:	f4 09 09 49 	lsl	r9,r10,r9
8000a246:	10 9b       	mov	r11,r8
8000a248:	91 29       	st.w	r8[0x8],r9
8000a24a:	0e 9c       	mov	r12,r7
8000a24c:	e0 a0 0a 90 	rcall	8000b76c <_Bfree>
8000a250:	6e 98       	ld.w	r8,r7[0x24]
8000a252:	30 09       	mov	r9,0
8000a254:	91 09       	st.w	r8[0x0],r9
8000a256:	40 28       	lddsp	r8,sp[0x8]
8000a258:	10 94       	mov	r4,r8
8000a25a:	58 08       	cp.w	r8,0
8000a25c:	c0 64       	brge	8000a268 <_dtoa_r+0x6c>
8000a25e:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000a262:	50 28       	stdsp	sp[0x8],r8
8000a264:	30 18       	mov	r8,1
8000a266:	c0 28       	rjmp	8000a26a <_dtoa_r+0x6e>
8000a268:	30 08       	mov	r8,0
8000a26a:	8d 08       	st.w	r6[0x0],r8
8000a26c:	fc 1c 7f f0 	movh	r12,0x7ff0
8000a270:	40 26       	lddsp	r6,sp[0x8]
8000a272:	0c 98       	mov	r8,r6
8000a274:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a278:	18 38       	cp.w	r8,r12
8000a27a:	c2 01       	brne	8000a2ba <_dtoa_r+0xbe>
8000a27c:	e0 68 27 0f 	mov	r8,9999
8000a280:	41 5b       	lddsp	r11,sp[0x54]
8000a282:	97 08       	st.w	r11[0x0],r8
8000a284:	40 3a       	lddsp	r10,sp[0xc]
8000a286:	58 0a       	cp.w	r10,0
8000a288:	c0 71       	brne	8000a296 <_dtoa_r+0x9a>
8000a28a:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000a28e:	c0 41       	brne	8000a296 <_dtoa_r+0x9a>
8000a290:	fe cc c1 a0 	sub	r12,pc,-15968
8000a294:	c0 38       	rjmp	8000a29a <_dtoa_r+0x9e>
8000a296:	fe cc c1 9a 	sub	r12,pc,-15974
8000a29a:	41 29       	lddsp	r9,sp[0x48]
8000a29c:	58 09       	cp.w	r9,0
8000a29e:	e0 80 05 9a 	breq	8000add2 <_dtoa_r+0xbd6>
8000a2a2:	f8 c8 ff fd 	sub	r8,r12,-3
8000a2a6:	f8 c9 ff f8 	sub	r9,r12,-8
8000a2aa:	11 8b       	ld.ub	r11,r8[0x0]
8000a2ac:	30 0a       	mov	r10,0
8000a2ae:	41 25       	lddsp	r5,sp[0x48]
8000a2b0:	f4 0b 18 00 	cp.b	r11,r10
8000a2b4:	f2 08 17 10 	movne	r8,r9
8000a2b8:	c1 68       	rjmp	8000a2e4 <_dtoa_r+0xe8>
8000a2ba:	fa ea 00 08 	ld.d	r10,sp[8]
8000a2be:	30 08       	mov	r8,0
8000a2c0:	fa eb 00 3c 	st.d	sp[60],r10
8000a2c4:	30 09       	mov	r9,0
8000a2c6:	e0 a0 10 ce 	rcall	8000c462 <__avr32_f64_cmp_eq>
8000a2ca:	c1 00       	breq	8000a2ea <_dtoa_r+0xee>
8000a2cc:	30 18       	mov	r8,1
8000a2ce:	41 5a       	lddsp	r10,sp[0x54]
8000a2d0:	95 08       	st.w	r10[0x0],r8
8000a2d2:	fe cc c3 06 	sub	r12,pc,-15610
8000a2d6:	41 29       	lddsp	r9,sp[0x48]
8000a2d8:	f8 08 00 08 	add	r8,r12,r8
8000a2dc:	58 09       	cp.w	r9,0
8000a2de:	e0 80 05 7a 	breq	8000add2 <_dtoa_r+0xbd6>
8000a2e2:	12 95       	mov	r5,r9
8000a2e4:	8b 08       	st.w	r5[0x0],r8
8000a2e6:	e0 8f 05 76 	bral	8000add2 <_dtoa_r+0xbd6>
8000a2ea:	fa c8 ff 9c 	sub	r8,sp,-100
8000a2ee:	fa c9 ff a0 	sub	r9,sp,-96
8000a2f2:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a2f6:	0e 9c       	mov	r12,r7
8000a2f8:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000a2fc:	e0 a0 0a 8a 	rcall	8000b810 <__d2b>
8000a300:	18 93       	mov	r3,r12
8000a302:	58 05       	cp.w	r5,0
8000a304:	c0 d0       	breq	8000a31e <_dtoa_r+0x122>
8000a306:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a30a:	30 04       	mov	r4,0
8000a30c:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000a310:	ea c5 03 ff 	sub	r5,r5,1023
8000a314:	10 9b       	mov	r11,r8
8000a316:	51 74       	stdsp	sp[0x5c],r4
8000a318:	ea 1b 3f f0 	orh	r11,0x3ff0
8000a31c:	c2 58       	rjmp	8000a366 <_dtoa_r+0x16a>
8000a31e:	41 88       	lddsp	r8,sp[0x60]
8000a320:	41 9c       	lddsp	r12,sp[0x64]
8000a322:	10 0c       	add	r12,r8
8000a324:	f8 c5 fb ce 	sub	r5,r12,-1074
8000a328:	e0 45 00 20 	cp.w	r5,32
8000a32c:	e0 8a 00 0e 	brle	8000a348 <_dtoa_r+0x14c>
8000a330:	f8 cc fb ee 	sub	r12,r12,-1042
8000a334:	40 3b       	lddsp	r11,sp[0xc]
8000a336:	ea 08 11 40 	rsub	r8,r5,64
8000a33a:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000a33e:	ec 08 09 46 	lsl	r6,r6,r8
8000a342:	0c 4c       	or	r12,r6
8000a344:	c0 78       	rjmp	8000a352 <_dtoa_r+0x156>
8000a346:	d7 03       	nop
8000a348:	ea 0c 11 20 	rsub	r12,r5,32
8000a34c:	40 3a       	lddsp	r10,sp[0xc]
8000a34e:	f4 0c 09 4c 	lsl	r12,r10,r12
8000a352:	e0 a0 10 14 	rcall	8000c37a <__avr32_u32_to_f64>
8000a356:	fc 18 fe 10 	movh	r8,0xfe10
8000a35a:	30 19       	mov	r9,1
8000a35c:	ea c5 04 33 	sub	r5,r5,1075
8000a360:	f0 0b 00 0b 	add	r11,r8,r11
8000a364:	51 79       	stdsp	sp[0x5c],r9
8000a366:	30 08       	mov	r8,0
8000a368:	fc 19 3f f8 	movh	r9,0x3ff8
8000a36c:	e0 a0 0e 9c 	rcall	8000c0a4 <__avr32_f64_sub>
8000a370:	e0 68 43 61 	mov	r8,17249
8000a374:	ea 18 63 6f 	orh	r8,0x636f
8000a378:	e0 69 87 a7 	mov	r9,34727
8000a37c:	ea 19 3f d2 	orh	r9,0x3fd2
8000a380:	e0 a0 0d a6 	rcall	8000becc <__avr32_f64_mul>
8000a384:	e0 68 c8 b3 	mov	r8,51379
8000a388:	ea 18 8b 60 	orh	r8,0x8b60
8000a38c:	e0 69 8a 28 	mov	r9,35368
8000a390:	ea 19 3f c6 	orh	r9,0x3fc6
8000a394:	e0 a0 0f 56 	rcall	8000c240 <__avr32_f64_add>
8000a398:	0a 9c       	mov	r12,r5
8000a39a:	14 90       	mov	r0,r10
8000a39c:	16 91       	mov	r1,r11
8000a39e:	e0 a0 0f f2 	rcall	8000c382 <__avr32_s32_to_f64>
8000a3a2:	e0 68 79 fb 	mov	r8,31227
8000a3a6:	ea 18 50 9f 	orh	r8,0x509f
8000a3aa:	e0 69 44 13 	mov	r9,17427
8000a3ae:	ea 19 3f d3 	orh	r9,0x3fd3
8000a3b2:	e0 a0 0d 8d 	rcall	8000becc <__avr32_f64_mul>
8000a3b6:	14 98       	mov	r8,r10
8000a3b8:	16 99       	mov	r9,r11
8000a3ba:	00 9a       	mov	r10,r0
8000a3bc:	02 9b       	mov	r11,r1
8000a3be:	e0 a0 0f 41 	rcall	8000c240 <__avr32_f64_add>
8000a3c2:	14 90       	mov	r0,r10
8000a3c4:	16 91       	mov	r1,r11
8000a3c6:	e0 a0 0f c7 	rcall	8000c354 <__avr32_f64_to_s32>
8000a3ca:	30 08       	mov	r8,0
8000a3cc:	18 96       	mov	r6,r12
8000a3ce:	30 09       	mov	r9,0
8000a3d0:	00 9a       	mov	r10,r0
8000a3d2:	02 9b       	mov	r11,r1
8000a3d4:	e0 a0 10 8e 	rcall	8000c4f0 <__avr32_f64_cmp_lt>
8000a3d8:	c0 c0       	breq	8000a3f0 <_dtoa_r+0x1f4>
8000a3da:	0c 9c       	mov	r12,r6
8000a3dc:	e0 a0 0f d3 	rcall	8000c382 <__avr32_s32_to_f64>
8000a3e0:	14 98       	mov	r8,r10
8000a3e2:	16 99       	mov	r9,r11
8000a3e4:	00 9a       	mov	r10,r0
8000a3e6:	02 9b       	mov	r11,r1
8000a3e8:	e0 a0 10 3d 	rcall	8000c462 <__avr32_f64_cmp_eq>
8000a3ec:	f7 b6 00 01 	subeq	r6,1
8000a3f0:	59 66       	cp.w	r6,22
8000a3f2:	e0 88 00 05 	brls	8000a3fc <_dtoa_r+0x200>
8000a3f6:	30 18       	mov	r8,1
8000a3f8:	51 48       	stdsp	sp[0x50],r8
8000a3fa:	c1 38       	rjmp	8000a420 <_dtoa_r+0x224>
8000a3fc:	fe c8 c2 4c 	sub	r8,pc,-15796
8000a400:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a404:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a408:	e0 a0 10 74 	rcall	8000c4f0 <__avr32_f64_cmp_lt>
8000a40c:	f9 b4 00 00 	moveq	r4,0
8000a410:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a414:	f7 b6 01 01 	subne	r6,1
8000a418:	f9 bc 01 00 	movne	r12,0
8000a41c:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a420:	41 90       	lddsp	r0,sp[0x64]
8000a422:	20 10       	sub	r0,1
8000a424:	0a 10       	sub	r0,r5
8000a426:	c0 46       	brmi	8000a42e <_dtoa_r+0x232>
8000a428:	50 40       	stdsp	sp[0x10],r0
8000a42a:	30 00       	mov	r0,0
8000a42c:	c0 48       	rjmp	8000a434 <_dtoa_r+0x238>
8000a42e:	30 0b       	mov	r11,0
8000a430:	5c 30       	neg	r0
8000a432:	50 4b       	stdsp	sp[0x10],r11
8000a434:	ec 02 11 00 	rsub	r2,r6,0
8000a438:	58 06       	cp.w	r6,0
8000a43a:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a43e:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a442:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a446:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a44a:	f9 b2 04 00 	movge	r2,0
8000a44e:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a452:	f9 b9 05 00 	movlt	r9,0
8000a456:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a45a:	40 c8       	lddsp	r8,sp[0x30]
8000a45c:	58 98       	cp.w	r8,9
8000a45e:	e0 8b 00 20 	brhi	8000a49e <_dtoa_r+0x2a2>
8000a462:	58 58       	cp.w	r8,5
8000a464:	f9 b4 0a 01 	movle	r4,1
8000a468:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a46c:	f7 b5 09 04 	subgt	r5,4
8000a470:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a474:	f9 b4 09 00 	movgt	r4,0
8000a478:	40 cc       	lddsp	r12,sp[0x30]
8000a47a:	58 3c       	cp.w	r12,3
8000a47c:	c2 d0       	breq	8000a4d6 <_dtoa_r+0x2da>
8000a47e:	e0 89 00 05 	brgt	8000a488 <_dtoa_r+0x28c>
8000a482:	58 2c       	cp.w	r12,2
8000a484:	c1 01       	brne	8000a4a4 <_dtoa_r+0x2a8>
8000a486:	c1 88       	rjmp	8000a4b6 <_dtoa_r+0x2ba>
8000a488:	40 cb       	lddsp	r11,sp[0x30]
8000a48a:	58 4b       	cp.w	r11,4
8000a48c:	c0 60       	breq	8000a498 <_dtoa_r+0x29c>
8000a48e:	58 5b       	cp.w	r11,5
8000a490:	c0 a1       	brne	8000a4a4 <_dtoa_r+0x2a8>
8000a492:	30 1a       	mov	r10,1
8000a494:	50 da       	stdsp	sp[0x34],r10
8000a496:	c2 28       	rjmp	8000a4da <_dtoa_r+0x2de>
8000a498:	30 19       	mov	r9,1
8000a49a:	50 d9       	stdsp	sp[0x34],r9
8000a49c:	c0 f8       	rjmp	8000a4ba <_dtoa_r+0x2be>
8000a49e:	30 08       	mov	r8,0
8000a4a0:	30 14       	mov	r4,1
8000a4a2:	50 c8       	stdsp	sp[0x30],r8
8000a4a4:	3f f5       	mov	r5,-1
8000a4a6:	30 1c       	mov	r12,1
8000a4a8:	30 0b       	mov	r11,0
8000a4aa:	50 95       	stdsp	sp[0x24],r5
8000a4ac:	50 dc       	stdsp	sp[0x34],r12
8000a4ae:	0a 91       	mov	r1,r5
8000a4b0:	31 28       	mov	r8,18
8000a4b2:	50 eb       	stdsp	sp[0x38],r11
8000a4b4:	c2 08       	rjmp	8000a4f4 <_dtoa_r+0x2f8>
8000a4b6:	30 0a       	mov	r10,0
8000a4b8:	50 da       	stdsp	sp[0x34],r10
8000a4ba:	40 e9       	lddsp	r9,sp[0x38]
8000a4bc:	58 09       	cp.w	r9,0
8000a4be:	e0 89 00 07 	brgt	8000a4cc <_dtoa_r+0x2d0>
8000a4c2:	30 18       	mov	r8,1
8000a4c4:	50 98       	stdsp	sp[0x24],r8
8000a4c6:	10 91       	mov	r1,r8
8000a4c8:	50 e8       	stdsp	sp[0x38],r8
8000a4ca:	c1 58       	rjmp	8000a4f4 <_dtoa_r+0x2f8>
8000a4cc:	40 e5       	lddsp	r5,sp[0x38]
8000a4ce:	50 95       	stdsp	sp[0x24],r5
8000a4d0:	0a 91       	mov	r1,r5
8000a4d2:	0a 98       	mov	r8,r5
8000a4d4:	c1 08       	rjmp	8000a4f4 <_dtoa_r+0x2f8>
8000a4d6:	30 0c       	mov	r12,0
8000a4d8:	50 dc       	stdsp	sp[0x34],r12
8000a4da:	40 eb       	lddsp	r11,sp[0x38]
8000a4dc:	ec 0b 00 0b 	add	r11,r6,r11
8000a4e0:	50 9b       	stdsp	sp[0x24],r11
8000a4e2:	16 98       	mov	r8,r11
8000a4e4:	2f f8       	sub	r8,-1
8000a4e6:	58 08       	cp.w	r8,0
8000a4e8:	e0 89 00 05 	brgt	8000a4f2 <_dtoa_r+0x2f6>
8000a4ec:	10 91       	mov	r1,r8
8000a4ee:	30 18       	mov	r8,1
8000a4f0:	c0 28       	rjmp	8000a4f4 <_dtoa_r+0x2f8>
8000a4f2:	10 91       	mov	r1,r8
8000a4f4:	30 09       	mov	r9,0
8000a4f6:	6e 9a       	ld.w	r10,r7[0x24]
8000a4f8:	95 19       	st.w	r10[0x4],r9
8000a4fa:	30 49       	mov	r9,4
8000a4fc:	c0 68       	rjmp	8000a508 <_dtoa_r+0x30c>
8000a4fe:	d7 03       	nop
8000a500:	6a 1a       	ld.w	r10,r5[0x4]
8000a502:	a1 79       	lsl	r9,0x1
8000a504:	2f fa       	sub	r10,-1
8000a506:	8b 1a       	st.w	r5[0x4],r10
8000a508:	6e 95       	ld.w	r5,r7[0x24]
8000a50a:	f2 ca ff ec 	sub	r10,r9,-20
8000a50e:	10 3a       	cp.w	r10,r8
8000a510:	fe 98 ff f8 	brls	8000a500 <_dtoa_r+0x304>
8000a514:	6a 1b       	ld.w	r11,r5[0x4]
8000a516:	0e 9c       	mov	r12,r7
8000a518:	e0 a0 09 44 	rcall	8000b7a0 <_Balloc>
8000a51c:	58 e1       	cp.w	r1,14
8000a51e:	5f 88       	srls	r8
8000a520:	8b 0c       	st.w	r5[0x0],r12
8000a522:	f1 e4 00 04 	and	r4,r8,r4
8000a526:	6e 98       	ld.w	r8,r7[0x24]
8000a528:	70 08       	ld.w	r8,r8[0x0]
8000a52a:	50 88       	stdsp	sp[0x20],r8
8000a52c:	e0 80 01 82 	breq	8000a830 <_dtoa_r+0x634>
8000a530:	58 06       	cp.w	r6,0
8000a532:	e0 8a 00 43 	brle	8000a5b8 <_dtoa_r+0x3bc>
8000a536:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a53a:	fe c8 c3 8a 	sub	r8,pc,-15478
8000a53e:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a542:	fa e5 00 18 	st.d	sp[24],r4
8000a546:	ec 04 14 04 	asr	r4,r6,0x4
8000a54a:	ed b4 00 04 	bld	r4,0x4
8000a54e:	c0 30       	breq	8000a554 <_dtoa_r+0x358>
8000a550:	30 25       	mov	r5,2
8000a552:	c1 08       	rjmp	8000a572 <_dtoa_r+0x376>
8000a554:	fe c8 c2 dc 	sub	r8,pc,-15652
8000a558:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a55c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a560:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a564:	e0 a0 0f fa 	rcall	8000c558 <__avr32_f64_div>
8000a568:	30 35       	mov	r5,3
8000a56a:	14 98       	mov	r8,r10
8000a56c:	16 99       	mov	r9,r11
8000a56e:	fa e9 00 08 	st.d	sp[8],r8
8000a572:	fe cc c2 fa 	sub	r12,pc,-15622
8000a576:	50 a3       	stdsp	sp[0x28],r3
8000a578:	0c 93       	mov	r3,r6
8000a57a:	18 96       	mov	r6,r12
8000a57c:	c0 f8       	rjmp	8000a59a <_dtoa_r+0x39e>
8000a57e:	fa ea 00 18 	ld.d	r10,sp[24]
8000a582:	ed b4 00 00 	bld	r4,0x0
8000a586:	c0 81       	brne	8000a596 <_dtoa_r+0x39a>
8000a588:	ec e8 00 00 	ld.d	r8,r6[0]
8000a58c:	2f f5       	sub	r5,-1
8000a58e:	e0 a0 0c 9f 	rcall	8000becc <__avr32_f64_mul>
8000a592:	fa eb 00 18 	st.d	sp[24],r10
8000a596:	a1 54       	asr	r4,0x1
8000a598:	2f 86       	sub	r6,-8
8000a59a:	58 04       	cp.w	r4,0
8000a59c:	cf 11       	brne	8000a57e <_dtoa_r+0x382>
8000a59e:	fa e8 00 18 	ld.d	r8,sp[24]
8000a5a2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a5a6:	06 96       	mov	r6,r3
8000a5a8:	e0 a0 0f d8 	rcall	8000c558 <__avr32_f64_div>
8000a5ac:	40 a3       	lddsp	r3,sp[0x28]
8000a5ae:	14 98       	mov	r8,r10
8000a5b0:	16 99       	mov	r9,r11
8000a5b2:	fa e9 00 08 	st.d	sp[8],r8
8000a5b6:	c2 f8       	rjmp	8000a614 <_dtoa_r+0x418>
8000a5b8:	ec 08 11 00 	rsub	r8,r6,0
8000a5bc:	c0 31       	brne	8000a5c2 <_dtoa_r+0x3c6>
8000a5be:	30 25       	mov	r5,2
8000a5c0:	c2 a8       	rjmp	8000a614 <_dtoa_r+0x418>
8000a5c2:	fe cc c3 4a 	sub	r12,pc,-15542
8000a5c6:	f0 04 14 04 	asr	r4,r8,0x4
8000a5ca:	50 1c       	stdsp	sp[0x4],r12
8000a5cc:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a5d0:	fe c9 c4 20 	sub	r9,pc,-15328
8000a5d4:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a5d8:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a5dc:	e0 a0 0c 78 	rcall	8000becc <__avr32_f64_mul>
8000a5e0:	40 1c       	lddsp	r12,sp[0x4]
8000a5e2:	50 63       	stdsp	sp[0x18],r3
8000a5e4:	30 25       	mov	r5,2
8000a5e6:	0c 93       	mov	r3,r6
8000a5e8:	fa eb 00 08 	st.d	sp[8],r10
8000a5ec:	18 96       	mov	r6,r12
8000a5ee:	c0 f8       	rjmp	8000a60c <_dtoa_r+0x410>
8000a5f0:	fa ea 00 08 	ld.d	r10,sp[8]
8000a5f4:	ed b4 00 00 	bld	r4,0x0
8000a5f8:	c0 81       	brne	8000a608 <_dtoa_r+0x40c>
8000a5fa:	ec e8 00 00 	ld.d	r8,r6[0]
8000a5fe:	2f f5       	sub	r5,-1
8000a600:	e0 a0 0c 66 	rcall	8000becc <__avr32_f64_mul>
8000a604:	fa eb 00 08 	st.d	sp[8],r10
8000a608:	a1 54       	asr	r4,0x1
8000a60a:	2f 86       	sub	r6,-8
8000a60c:	58 04       	cp.w	r4,0
8000a60e:	cf 11       	brne	8000a5f0 <_dtoa_r+0x3f4>
8000a610:	06 96       	mov	r6,r3
8000a612:	40 63       	lddsp	r3,sp[0x18]
8000a614:	41 4a       	lddsp	r10,sp[0x50]
8000a616:	58 0a       	cp.w	r10,0
8000a618:	c2 a0       	breq	8000a66c <_dtoa_r+0x470>
8000a61a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a61e:	58 01       	cp.w	r1,0
8000a620:	5f 94       	srgt	r4
8000a622:	fa e9 00 18 	st.d	sp[24],r8
8000a626:	30 08       	mov	r8,0
8000a628:	fc 19 3f f0 	movh	r9,0x3ff0
8000a62c:	fa ea 00 18 	ld.d	r10,sp[24]
8000a630:	e0 a0 0f 60 	rcall	8000c4f0 <__avr32_f64_cmp_lt>
8000a634:	f9 bc 00 00 	moveq	r12,0
8000a638:	f9 bc 01 01 	movne	r12,1
8000a63c:	e9 ec 00 0c 	and	r12,r4,r12
8000a640:	c1 60       	breq	8000a66c <_dtoa_r+0x470>
8000a642:	40 98       	lddsp	r8,sp[0x24]
8000a644:	58 08       	cp.w	r8,0
8000a646:	e0 8a 00 f1 	brle	8000a828 <_dtoa_r+0x62c>
8000a64a:	30 08       	mov	r8,0
8000a64c:	fc 19 40 24 	movh	r9,0x4024
8000a650:	ec c4 00 01 	sub	r4,r6,1
8000a654:	fa ea 00 18 	ld.d	r10,sp[24]
8000a658:	2f f5       	sub	r5,-1
8000a65a:	50 64       	stdsp	sp[0x18],r4
8000a65c:	e0 a0 0c 38 	rcall	8000becc <__avr32_f64_mul>
8000a660:	40 94       	lddsp	r4,sp[0x24]
8000a662:	14 98       	mov	r8,r10
8000a664:	16 99       	mov	r9,r11
8000a666:	fa e9 00 08 	st.d	sp[8],r8
8000a66a:	c0 38       	rjmp	8000a670 <_dtoa_r+0x474>
8000a66c:	50 66       	stdsp	sp[0x18],r6
8000a66e:	02 94       	mov	r4,r1
8000a670:	0a 9c       	mov	r12,r5
8000a672:	e0 a0 0e 88 	rcall	8000c382 <__avr32_s32_to_f64>
8000a676:	fa e8 00 08 	ld.d	r8,sp[8]
8000a67a:	e0 a0 0c 29 	rcall	8000becc <__avr32_f64_mul>
8000a67e:	30 08       	mov	r8,0
8000a680:	fc 19 40 1c 	movh	r9,0x401c
8000a684:	e0 a0 0d de 	rcall	8000c240 <__avr32_f64_add>
8000a688:	14 98       	mov	r8,r10
8000a68a:	16 99       	mov	r9,r11
8000a68c:	fa e9 00 28 	st.d	sp[40],r8
8000a690:	fc 18 fc c0 	movh	r8,0xfcc0
8000a694:	40 a5       	lddsp	r5,sp[0x28]
8000a696:	10 05       	add	r5,r8
8000a698:	50 a5       	stdsp	sp[0x28],r5
8000a69a:	58 04       	cp.w	r4,0
8000a69c:	c2 11       	brne	8000a6de <_dtoa_r+0x4e2>
8000a69e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a6a2:	30 08       	mov	r8,0
8000a6a4:	fc 19 40 14 	movh	r9,0x4014
8000a6a8:	e0 a0 0c fe 	rcall	8000c0a4 <__avr32_f64_sub>
8000a6ac:	40 bc       	lddsp	r12,sp[0x2c]
8000a6ae:	fa eb 00 08 	st.d	sp[8],r10
8000a6b2:	14 98       	mov	r8,r10
8000a6b4:	16 99       	mov	r9,r11
8000a6b6:	18 9a       	mov	r10,r12
8000a6b8:	0a 9b       	mov	r11,r5
8000a6ba:	e0 a0 0f 1b 	rcall	8000c4f0 <__avr32_f64_cmp_lt>
8000a6be:	e0 81 02 54 	brne	8000ab66 <_dtoa_r+0x96a>
8000a6c2:	0a 98       	mov	r8,r5
8000a6c4:	40 b9       	lddsp	r9,sp[0x2c]
8000a6c6:	ee 18 80 00 	eorh	r8,0x8000
8000a6ca:	fa ea 00 08 	ld.d	r10,sp[8]
8000a6ce:	10 95       	mov	r5,r8
8000a6d0:	12 98       	mov	r8,r9
8000a6d2:	0a 99       	mov	r9,r5
8000a6d4:	e0 a0 0f 0e 	rcall	8000c4f0 <__avr32_f64_cmp_lt>
8000a6d8:	e0 81 02 3e 	brne	8000ab54 <_dtoa_r+0x958>
8000a6dc:	ca 68       	rjmp	8000a828 <_dtoa_r+0x62c>
8000a6de:	fe c9 c5 2e 	sub	r9,pc,-15058
8000a6e2:	e8 c8 00 01 	sub	r8,r4,1
8000a6e6:	40 d5       	lddsp	r5,sp[0x34]
8000a6e8:	58 05       	cp.w	r5,0
8000a6ea:	c4 f0       	breq	8000a788 <_dtoa_r+0x58c>
8000a6ec:	30 0c       	mov	r12,0
8000a6ee:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a6f2:	51 3c       	stdsp	sp[0x4c],r12
8000a6f4:	30 0a       	mov	r10,0
8000a6f6:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a6fa:	e0 a0 0f 2f 	rcall	8000c558 <__avr32_f64_div>
8000a6fe:	fa e8 00 28 	ld.d	r8,sp[40]
8000a702:	40 85       	lddsp	r5,sp[0x20]
8000a704:	e0 a0 0c d0 	rcall	8000c0a4 <__avr32_f64_sub>
8000a708:	fa eb 00 28 	st.d	sp[40],r10
8000a70c:	fa ea 00 08 	ld.d	r10,sp[8]
8000a710:	e0 a0 0e 22 	rcall	8000c354 <__avr32_f64_to_s32>
8000a714:	51 6c       	stdsp	sp[0x58],r12
8000a716:	e0 a0 0e 36 	rcall	8000c382 <__avr32_s32_to_f64>
8000a71a:	14 98       	mov	r8,r10
8000a71c:	16 99       	mov	r9,r11
8000a71e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a722:	e0 a0 0c c1 	rcall	8000c0a4 <__avr32_f64_sub>
8000a726:	fa eb 00 08 	st.d	sp[8],r10
8000a72a:	41 68       	lddsp	r8,sp[0x58]
8000a72c:	2d 08       	sub	r8,-48
8000a72e:	0a c8       	st.b	r5++,r8
8000a730:	41 39       	lddsp	r9,sp[0x4c]
8000a732:	2f f9       	sub	r9,-1
8000a734:	51 39       	stdsp	sp[0x4c],r9
8000a736:	fa e8 00 28 	ld.d	r8,sp[40]
8000a73a:	e0 a0 0e db 	rcall	8000c4f0 <__avr32_f64_cmp_lt>
8000a73e:	e0 81 03 39 	brne	8000adb0 <_dtoa_r+0xbb4>
8000a742:	fa e8 00 08 	ld.d	r8,sp[8]
8000a746:	30 0a       	mov	r10,0
8000a748:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a74c:	e0 a0 0c ac 	rcall	8000c0a4 <__avr32_f64_sub>
8000a750:	fa e8 00 28 	ld.d	r8,sp[40]
8000a754:	e0 a0 0e ce 	rcall	8000c4f0 <__avr32_f64_cmp_lt>
8000a758:	fa ea 00 28 	ld.d	r10,sp[40]
8000a75c:	30 08       	mov	r8,0
8000a75e:	fc 19 40 24 	movh	r9,0x4024
8000a762:	e0 81 00 da 	brne	8000a916 <_dtoa_r+0x71a>
8000a766:	41 3c       	lddsp	r12,sp[0x4c]
8000a768:	08 3c       	cp.w	r12,r4
8000a76a:	c5 f4       	brge	8000a828 <_dtoa_r+0x62c>
8000a76c:	e0 a0 0b b0 	rcall	8000becc <__avr32_f64_mul>
8000a770:	30 08       	mov	r8,0
8000a772:	fa eb 00 28 	st.d	sp[40],r10
8000a776:	fc 19 40 24 	movh	r9,0x4024
8000a77a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a77e:	e0 a0 0b a7 	rcall	8000becc <__avr32_f64_mul>
8000a782:	fa eb 00 08 	st.d	sp[8],r10
8000a786:	cc 3b       	rjmp	8000a70c <_dtoa_r+0x510>
8000a788:	40 85       	lddsp	r5,sp[0x20]
8000a78a:	08 05       	add	r5,r4
8000a78c:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a790:	51 35       	stdsp	sp[0x4c],r5
8000a792:	fa e8 00 28 	ld.d	r8,sp[40]
8000a796:	40 85       	lddsp	r5,sp[0x20]
8000a798:	e0 a0 0b 9a 	rcall	8000becc <__avr32_f64_mul>
8000a79c:	fa eb 00 28 	st.d	sp[40],r10
8000a7a0:	fa ea 00 08 	ld.d	r10,sp[8]
8000a7a4:	e0 a0 0d d8 	rcall	8000c354 <__avr32_f64_to_s32>
8000a7a8:	51 6c       	stdsp	sp[0x58],r12
8000a7aa:	e0 a0 0d ec 	rcall	8000c382 <__avr32_s32_to_f64>
8000a7ae:	14 98       	mov	r8,r10
8000a7b0:	16 99       	mov	r9,r11
8000a7b2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a7b6:	e0 a0 0c 77 	rcall	8000c0a4 <__avr32_f64_sub>
8000a7ba:	fa eb 00 08 	st.d	sp[8],r10
8000a7be:	41 68       	lddsp	r8,sp[0x58]
8000a7c0:	2d 08       	sub	r8,-48
8000a7c2:	0a c8       	st.b	r5++,r8
8000a7c4:	41 3c       	lddsp	r12,sp[0x4c]
8000a7c6:	18 35       	cp.w	r5,r12
8000a7c8:	c2 81       	brne	8000a818 <_dtoa_r+0x61c>
8000a7ca:	30 08       	mov	r8,0
8000a7cc:	fc 19 3f e0 	movh	r9,0x3fe0
8000a7d0:	fa ea 00 28 	ld.d	r10,sp[40]
8000a7d4:	e0 a0 0d 36 	rcall	8000c240 <__avr32_f64_add>
8000a7d8:	40 85       	lddsp	r5,sp[0x20]
8000a7da:	fa e8 00 08 	ld.d	r8,sp[8]
8000a7de:	08 05       	add	r5,r4
8000a7e0:	e0 a0 0e 88 	rcall	8000c4f0 <__avr32_f64_cmp_lt>
8000a7e4:	e0 81 00 99 	brne	8000a916 <_dtoa_r+0x71a>
8000a7e8:	fa e8 00 28 	ld.d	r8,sp[40]
8000a7ec:	30 0a       	mov	r10,0
8000a7ee:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a7f2:	e0 a0 0c 59 	rcall	8000c0a4 <__avr32_f64_sub>
8000a7f6:	14 98       	mov	r8,r10
8000a7f8:	16 99       	mov	r9,r11
8000a7fa:	fa ea 00 08 	ld.d	r10,sp[8]
8000a7fe:	e0 a0 0e 79 	rcall	8000c4f0 <__avr32_f64_cmp_lt>
8000a802:	c1 30       	breq	8000a828 <_dtoa_r+0x62c>
8000a804:	33 09       	mov	r9,48
8000a806:	0a 98       	mov	r8,r5
8000a808:	11 7a       	ld.ub	r10,--r8
8000a80a:	f2 0a 18 00 	cp.b	r10,r9
8000a80e:	e0 81 02 d1 	brne	8000adb0 <_dtoa_r+0xbb4>
8000a812:	10 95       	mov	r5,r8
8000a814:	cf 9b       	rjmp	8000a806 <_dtoa_r+0x60a>
8000a816:	d7 03       	nop
8000a818:	30 08       	mov	r8,0
8000a81a:	fc 19 40 24 	movh	r9,0x4024
8000a81e:	e0 a0 0b 57 	rcall	8000becc <__avr32_f64_mul>
8000a822:	fa eb 00 08 	st.d	sp[8],r10
8000a826:	cb db       	rjmp	8000a7a0 <_dtoa_r+0x5a4>
8000a828:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a82c:	fa eb 00 08 	st.d	sp[8],r10
8000a830:	58 e6       	cp.w	r6,14
8000a832:	5f ab       	srle	r11
8000a834:	41 8a       	lddsp	r10,sp[0x60]
8000a836:	30 08       	mov	r8,0
8000a838:	f4 09 11 ff 	rsub	r9,r10,-1
8000a83c:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a840:	f0 09 18 00 	cp.b	r9,r8
8000a844:	e0 80 00 82 	breq	8000a948 <_dtoa_r+0x74c>
8000a848:	40 ea       	lddsp	r10,sp[0x38]
8000a84a:	58 01       	cp.w	r1,0
8000a84c:	5f a9       	srle	r9
8000a84e:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a852:	fe ca c6 a2 	sub	r10,pc,-14686
8000a856:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a85a:	fa e5 00 10 	st.d	sp[16],r4
8000a85e:	f0 09 18 00 	cp.b	r9,r8
8000a862:	c1 40       	breq	8000a88a <_dtoa_r+0x68e>
8000a864:	58 01       	cp.w	r1,0
8000a866:	e0 81 01 77 	brne	8000ab54 <_dtoa_r+0x958>
8000a86a:	30 08       	mov	r8,0
8000a86c:	fc 19 40 14 	movh	r9,0x4014
8000a870:	08 9a       	mov	r10,r4
8000a872:	0a 9b       	mov	r11,r5
8000a874:	e0 a0 0b 2c 	rcall	8000becc <__avr32_f64_mul>
8000a878:	fa e8 00 08 	ld.d	r8,sp[8]
8000a87c:	e0 a0 0e 06 	rcall	8000c488 <__avr32_f64_cmp_ge>
8000a880:	e0 81 01 6a 	brne	8000ab54 <_dtoa_r+0x958>
8000a884:	02 92       	mov	r2,r1
8000a886:	e0 8f 01 72 	bral	8000ab6a <_dtoa_r+0x96e>
8000a88a:	40 85       	lddsp	r5,sp[0x20]
8000a88c:	30 14       	mov	r4,1
8000a88e:	fa e8 00 10 	ld.d	r8,sp[16]
8000a892:	fa ea 00 08 	ld.d	r10,sp[8]
8000a896:	e0 a0 0e 61 	rcall	8000c558 <__avr32_f64_div>
8000a89a:	e0 a0 0d 5d 	rcall	8000c354 <__avr32_f64_to_s32>
8000a89e:	18 92       	mov	r2,r12
8000a8a0:	e0 a0 0d 71 	rcall	8000c382 <__avr32_s32_to_f64>
8000a8a4:	fa e8 00 10 	ld.d	r8,sp[16]
8000a8a8:	e0 a0 0b 12 	rcall	8000becc <__avr32_f64_mul>
8000a8ac:	14 98       	mov	r8,r10
8000a8ae:	16 99       	mov	r9,r11
8000a8b0:	fa ea 00 08 	ld.d	r10,sp[8]
8000a8b4:	e0 a0 0b f8 	rcall	8000c0a4 <__avr32_f64_sub>
8000a8b8:	fa eb 00 08 	st.d	sp[8],r10
8000a8bc:	e4 c8 ff d0 	sub	r8,r2,-48
8000a8c0:	0a c8       	st.b	r5++,r8
8000a8c2:	fc 19 40 24 	movh	r9,0x4024
8000a8c6:	30 08       	mov	r8,0
8000a8c8:	02 34       	cp.w	r4,r1
8000a8ca:	c3 31       	brne	8000a930 <_dtoa_r+0x734>
8000a8cc:	fa e8 00 08 	ld.d	r8,sp[8]
8000a8d0:	e0 a0 0c b8 	rcall	8000c240 <__avr32_f64_add>
8000a8d4:	16 91       	mov	r1,r11
8000a8d6:	14 90       	mov	r0,r10
8000a8d8:	14 98       	mov	r8,r10
8000a8da:	02 99       	mov	r9,r1
8000a8dc:	fa ea 00 10 	ld.d	r10,sp[16]
8000a8e0:	e0 a0 0e 08 	rcall	8000c4f0 <__avr32_f64_cmp_lt>
8000a8e4:	c1 a1       	brne	8000a918 <_dtoa_r+0x71c>
8000a8e6:	fa e8 00 10 	ld.d	r8,sp[16]
8000a8ea:	00 9a       	mov	r10,r0
8000a8ec:	02 9b       	mov	r11,r1
8000a8ee:	e0 a0 0d ba 	rcall	8000c462 <__avr32_f64_cmp_eq>
8000a8f2:	e0 80 02 5e 	breq	8000adae <_dtoa_r+0xbb2>
8000a8f6:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a8fa:	c0 f1       	brne	8000a918 <_dtoa_r+0x71c>
8000a8fc:	e0 8f 02 59 	bral	8000adae <_dtoa_r+0xbb2>
8000a900:	40 8a       	lddsp	r10,sp[0x20]
8000a902:	14 38       	cp.w	r8,r10
8000a904:	c0 30       	breq	8000a90a <_dtoa_r+0x70e>
8000a906:	10 95       	mov	r5,r8
8000a908:	c0 98       	rjmp	8000a91a <_dtoa_r+0x71e>
8000a90a:	33 08       	mov	r8,48
8000a90c:	40 89       	lddsp	r9,sp[0x20]
8000a90e:	2f f6       	sub	r6,-1
8000a910:	b2 88       	st.b	r9[0x0],r8
8000a912:	40 88       	lddsp	r8,sp[0x20]
8000a914:	c0 88       	rjmp	8000a924 <_dtoa_r+0x728>
8000a916:	40 66       	lddsp	r6,sp[0x18]
8000a918:	33 99       	mov	r9,57
8000a91a:	0a 98       	mov	r8,r5
8000a91c:	11 7a       	ld.ub	r10,--r8
8000a91e:	f2 0a 18 00 	cp.b	r10,r9
8000a922:	ce f0       	breq	8000a900 <_dtoa_r+0x704>
8000a924:	50 66       	stdsp	sp[0x18],r6
8000a926:	11 89       	ld.ub	r9,r8[0x0]
8000a928:	2f f9       	sub	r9,-1
8000a92a:	b0 89       	st.b	r8[0x0],r9
8000a92c:	e0 8f 02 42 	bral	8000adb0 <_dtoa_r+0xbb4>
8000a930:	e0 a0 0a ce 	rcall	8000becc <__avr32_f64_mul>
8000a934:	2f f4       	sub	r4,-1
8000a936:	fa eb 00 08 	st.d	sp[8],r10
8000a93a:	30 08       	mov	r8,0
8000a93c:	30 09       	mov	r9,0
8000a93e:	e0 a0 0d 92 	rcall	8000c462 <__avr32_f64_cmp_eq>
8000a942:	ca 60       	breq	8000a88e <_dtoa_r+0x692>
8000a944:	e0 8f 02 35 	bral	8000adae <_dtoa_r+0xbb2>
8000a948:	40 d8       	lddsp	r8,sp[0x34]
8000a94a:	58 08       	cp.w	r8,0
8000a94c:	c0 51       	brne	8000a956 <_dtoa_r+0x75a>
8000a94e:	04 98       	mov	r8,r2
8000a950:	00 95       	mov	r5,r0
8000a952:	40 d4       	lddsp	r4,sp[0x34]
8000a954:	c3 78       	rjmp	8000a9c2 <_dtoa_r+0x7c6>
8000a956:	40 c5       	lddsp	r5,sp[0x30]
8000a958:	58 15       	cp.w	r5,1
8000a95a:	e0 89 00 0f 	brgt	8000a978 <_dtoa_r+0x77c>
8000a95e:	41 74       	lddsp	r4,sp[0x5c]
8000a960:	58 04       	cp.w	r4,0
8000a962:	c0 40       	breq	8000a96a <_dtoa_r+0x76e>
8000a964:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a968:	c0 48       	rjmp	8000a970 <_dtoa_r+0x774>
8000a96a:	41 99       	lddsp	r9,sp[0x64]
8000a96c:	f2 09 11 36 	rsub	r9,r9,54
8000a970:	04 98       	mov	r8,r2
8000a972:	00 95       	mov	r5,r0
8000a974:	c1 c8       	rjmp	8000a9ac <_dtoa_r+0x7b0>
8000a976:	d7 03       	nop
8000a978:	e2 c8 00 01 	sub	r8,r1,1
8000a97c:	58 01       	cp.w	r1,0
8000a97e:	e0 05 17 40 	movge	r5,r0
8000a982:	e2 09 17 40 	movge	r9,r1
8000a986:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a98a:	f9 b9 05 00 	movlt	r9,0
8000a98e:	10 32       	cp.w	r2,r8
8000a990:	e5 d8 e4 18 	subge	r8,r2,r8
8000a994:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a998:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a99c:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a9a0:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a9a4:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a9a8:	f9 b8 05 00 	movlt	r8,0
8000a9ac:	40 4b       	lddsp	r11,sp[0x10]
8000a9ae:	12 0b       	add	r11,r9
8000a9b0:	50 08       	stdsp	sp[0x0],r8
8000a9b2:	50 4b       	stdsp	sp[0x10],r11
8000a9b4:	12 00       	add	r0,r9
8000a9b6:	30 1b       	mov	r11,1
8000a9b8:	0e 9c       	mov	r12,r7
8000a9ba:	e0 a0 08 a7 	rcall	8000bb08 <__i2b>
8000a9be:	40 08       	lddsp	r8,sp[0x0]
8000a9c0:	18 94       	mov	r4,r12
8000a9c2:	40 4a       	lddsp	r10,sp[0x10]
8000a9c4:	58 05       	cp.w	r5,0
8000a9c6:	5f 99       	srgt	r9
8000a9c8:	58 0a       	cp.w	r10,0
8000a9ca:	5f 9a       	srgt	r10
8000a9cc:	f5 e9 00 09 	and	r9,r10,r9
8000a9d0:	c0 80       	breq	8000a9e0 <_dtoa_r+0x7e4>
8000a9d2:	40 4c       	lddsp	r12,sp[0x10]
8000a9d4:	f8 05 0d 49 	min	r9,r12,r5
8000a9d8:	12 1c       	sub	r12,r9
8000a9da:	12 10       	sub	r0,r9
8000a9dc:	50 4c       	stdsp	sp[0x10],r12
8000a9de:	12 15       	sub	r5,r9
8000a9e0:	58 02       	cp.w	r2,0
8000a9e2:	e0 8a 00 27 	brle	8000aa30 <_dtoa_r+0x834>
8000a9e6:	40 db       	lddsp	r11,sp[0x34]
8000a9e8:	58 0b       	cp.w	r11,0
8000a9ea:	c1 d0       	breq	8000aa24 <_dtoa_r+0x828>
8000a9ec:	58 08       	cp.w	r8,0
8000a9ee:	e0 8a 00 17 	brle	8000aa1c <_dtoa_r+0x820>
8000a9f2:	10 9a       	mov	r10,r8
8000a9f4:	50 08       	stdsp	sp[0x0],r8
8000a9f6:	08 9b       	mov	r11,r4
8000a9f8:	0e 9c       	mov	r12,r7
8000a9fa:	e0 a0 08 cd 	rcall	8000bb94 <__pow5mult>
8000a9fe:	06 9a       	mov	r10,r3
8000aa00:	18 9b       	mov	r11,r12
8000aa02:	18 94       	mov	r4,r12
8000aa04:	0e 9c       	mov	r12,r7
8000aa06:	e0 a0 08 01 	rcall	8000ba08 <__multiply>
8000aa0a:	18 99       	mov	r9,r12
8000aa0c:	06 9b       	mov	r11,r3
8000aa0e:	50 19       	stdsp	sp[0x4],r9
8000aa10:	0e 9c       	mov	r12,r7
8000aa12:	e0 a0 06 ad 	rcall	8000b76c <_Bfree>
8000aa16:	40 19       	lddsp	r9,sp[0x4]
8000aa18:	40 08       	lddsp	r8,sp[0x0]
8000aa1a:	12 93       	mov	r3,r9
8000aa1c:	e4 08 01 0a 	sub	r10,r2,r8
8000aa20:	c0 80       	breq	8000aa30 <_dtoa_r+0x834>
8000aa22:	c0 28       	rjmp	8000aa26 <_dtoa_r+0x82a>
8000aa24:	04 9a       	mov	r10,r2
8000aa26:	06 9b       	mov	r11,r3
8000aa28:	0e 9c       	mov	r12,r7
8000aa2a:	e0 a0 08 b5 	rcall	8000bb94 <__pow5mult>
8000aa2e:	18 93       	mov	r3,r12
8000aa30:	30 1b       	mov	r11,1
8000aa32:	0e 9c       	mov	r12,r7
8000aa34:	e0 a0 08 6a 	rcall	8000bb08 <__i2b>
8000aa38:	41 1a       	lddsp	r10,sp[0x44]
8000aa3a:	18 92       	mov	r2,r12
8000aa3c:	58 0a       	cp.w	r10,0
8000aa3e:	e0 8a 00 07 	brle	8000aa4c <_dtoa_r+0x850>
8000aa42:	18 9b       	mov	r11,r12
8000aa44:	0e 9c       	mov	r12,r7
8000aa46:	e0 a0 08 a7 	rcall	8000bb94 <__pow5mult>
8000aa4a:	18 92       	mov	r2,r12
8000aa4c:	40 c9       	lddsp	r9,sp[0x30]
8000aa4e:	58 19       	cp.w	r9,1
8000aa50:	e0 89 00 14 	brgt	8000aa78 <_dtoa_r+0x87c>
8000aa54:	40 38       	lddsp	r8,sp[0xc]
8000aa56:	58 08       	cp.w	r8,0
8000aa58:	c1 01       	brne	8000aa78 <_dtoa_r+0x87c>
8000aa5a:	40 29       	lddsp	r9,sp[0x8]
8000aa5c:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000aa60:	c0 c1       	brne	8000aa78 <_dtoa_r+0x87c>
8000aa62:	12 98       	mov	r8,r9
8000aa64:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000aa68:	c0 80       	breq	8000aa78 <_dtoa_r+0x87c>
8000aa6a:	40 4c       	lddsp	r12,sp[0x10]
8000aa6c:	30 1b       	mov	r11,1
8000aa6e:	2f fc       	sub	r12,-1
8000aa70:	2f f0       	sub	r0,-1
8000aa72:	50 4c       	stdsp	sp[0x10],r12
8000aa74:	50 6b       	stdsp	sp[0x18],r11
8000aa76:	c0 38       	rjmp	8000aa7c <_dtoa_r+0x880>
8000aa78:	30 0a       	mov	r10,0
8000aa7a:	50 6a       	stdsp	sp[0x18],r10
8000aa7c:	41 19       	lddsp	r9,sp[0x44]
8000aa7e:	58 09       	cp.w	r9,0
8000aa80:	c0 31       	brne	8000aa86 <_dtoa_r+0x88a>
8000aa82:	30 1c       	mov	r12,1
8000aa84:	c0 98       	rjmp	8000aa96 <_dtoa_r+0x89a>
8000aa86:	64 48       	ld.w	r8,r2[0x10]
8000aa88:	2f c8       	sub	r8,-4
8000aa8a:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000aa8e:	e0 a0 05 df 	rcall	8000b64c <__hi0bits>
8000aa92:	f8 0c 11 20 	rsub	r12,r12,32
8000aa96:	40 4b       	lddsp	r11,sp[0x10]
8000aa98:	f8 0b 00 08 	add	r8,r12,r11
8000aa9c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000aaa0:	c0 c0       	breq	8000aab8 <_dtoa_r+0x8bc>
8000aaa2:	f0 08 11 20 	rsub	r8,r8,32
8000aaa6:	58 48       	cp.w	r8,4
8000aaa8:	e0 8a 00 06 	brle	8000aab4 <_dtoa_r+0x8b8>
8000aaac:	20 48       	sub	r8,4
8000aaae:	10 0b       	add	r11,r8
8000aab0:	50 4b       	stdsp	sp[0x10],r11
8000aab2:	c0 78       	rjmp	8000aac0 <_dtoa_r+0x8c4>
8000aab4:	58 48       	cp.w	r8,4
8000aab6:	c0 70       	breq	8000aac4 <_dtoa_r+0x8c8>
8000aab8:	40 4a       	lddsp	r10,sp[0x10]
8000aaba:	2e 48       	sub	r8,-28
8000aabc:	10 0a       	add	r10,r8
8000aabe:	50 4a       	stdsp	sp[0x10],r10
8000aac0:	10 00       	add	r0,r8
8000aac2:	10 05       	add	r5,r8
8000aac4:	58 00       	cp.w	r0,0
8000aac6:	e0 8a 00 08 	brle	8000aad6 <_dtoa_r+0x8da>
8000aaca:	06 9b       	mov	r11,r3
8000aacc:	00 9a       	mov	r10,r0
8000aace:	0e 9c       	mov	r12,r7
8000aad0:	e0 a0 07 58 	rcall	8000b980 <__lshift>
8000aad4:	18 93       	mov	r3,r12
8000aad6:	40 49       	lddsp	r9,sp[0x10]
8000aad8:	58 09       	cp.w	r9,0
8000aada:	e0 8a 00 08 	brle	8000aaea <_dtoa_r+0x8ee>
8000aade:	04 9b       	mov	r11,r2
8000aae0:	12 9a       	mov	r10,r9
8000aae2:	0e 9c       	mov	r12,r7
8000aae4:	e0 a0 07 4e 	rcall	8000b980 <__lshift>
8000aae8:	18 92       	mov	r2,r12
8000aaea:	41 48       	lddsp	r8,sp[0x50]
8000aaec:	58 08       	cp.w	r8,0
8000aaee:	c1 b0       	breq	8000ab24 <_dtoa_r+0x928>
8000aaf0:	04 9b       	mov	r11,r2
8000aaf2:	06 9c       	mov	r12,r3
8000aaf4:	e0 a0 06 23 	rcall	8000b73a <__mcmp>
8000aaf8:	c1 64       	brge	8000ab24 <_dtoa_r+0x928>
8000aafa:	06 9b       	mov	r11,r3
8000aafc:	30 09       	mov	r9,0
8000aafe:	30 aa       	mov	r10,10
8000ab00:	0e 9c       	mov	r12,r7
8000ab02:	e0 a0 08 0b 	rcall	8000bb18 <__multadd>
8000ab06:	20 16       	sub	r6,1
8000ab08:	18 93       	mov	r3,r12
8000ab0a:	40 dc       	lddsp	r12,sp[0x34]
8000ab0c:	58 0c       	cp.w	r12,0
8000ab0e:	c0 31       	brne	8000ab14 <_dtoa_r+0x918>
8000ab10:	40 91       	lddsp	r1,sp[0x24]
8000ab12:	c0 98       	rjmp	8000ab24 <_dtoa_r+0x928>
8000ab14:	08 9b       	mov	r11,r4
8000ab16:	40 91       	lddsp	r1,sp[0x24]
8000ab18:	30 09       	mov	r9,0
8000ab1a:	30 aa       	mov	r10,10
8000ab1c:	0e 9c       	mov	r12,r7
8000ab1e:	e0 a0 07 fd 	rcall	8000bb18 <__multadd>
8000ab22:	18 94       	mov	r4,r12
8000ab24:	58 01       	cp.w	r1,0
8000ab26:	5f a9       	srle	r9
8000ab28:	40 cb       	lddsp	r11,sp[0x30]
8000ab2a:	58 2b       	cp.w	r11,2
8000ab2c:	5f 98       	srgt	r8
8000ab2e:	f3 e8 00 08 	and	r8,r9,r8
8000ab32:	c2 50       	breq	8000ab7c <_dtoa_r+0x980>
8000ab34:	58 01       	cp.w	r1,0
8000ab36:	c1 11       	brne	8000ab58 <_dtoa_r+0x95c>
8000ab38:	04 9b       	mov	r11,r2
8000ab3a:	02 99       	mov	r9,r1
8000ab3c:	30 5a       	mov	r10,5
8000ab3e:	0e 9c       	mov	r12,r7
8000ab40:	e0 a0 07 ec 	rcall	8000bb18 <__multadd>
8000ab44:	18 92       	mov	r2,r12
8000ab46:	18 9b       	mov	r11,r12
8000ab48:	06 9c       	mov	r12,r3
8000ab4a:	e0 a0 05 f8 	rcall	8000b73a <__mcmp>
8000ab4e:	e0 89 00 0f 	brgt	8000ab6c <_dtoa_r+0x970>
8000ab52:	c0 38       	rjmp	8000ab58 <_dtoa_r+0x95c>
8000ab54:	30 02       	mov	r2,0
8000ab56:	04 94       	mov	r4,r2
8000ab58:	40 ea       	lddsp	r10,sp[0x38]
8000ab5a:	30 09       	mov	r9,0
8000ab5c:	5c da       	com	r10
8000ab5e:	40 85       	lddsp	r5,sp[0x20]
8000ab60:	50 6a       	stdsp	sp[0x18],r10
8000ab62:	50 49       	stdsp	sp[0x10],r9
8000ab64:	c0 f9       	rjmp	8000ad82 <_dtoa_r+0xb86>
8000ab66:	08 92       	mov	r2,r4
8000ab68:	40 66       	lddsp	r6,sp[0x18]
8000ab6a:	04 94       	mov	r4,r2
8000ab6c:	2f f6       	sub	r6,-1
8000ab6e:	50 66       	stdsp	sp[0x18],r6
8000ab70:	33 18       	mov	r8,49
8000ab72:	40 85       	lddsp	r5,sp[0x20]
8000ab74:	0a c8       	st.b	r5++,r8
8000ab76:	30 08       	mov	r8,0
8000ab78:	50 48       	stdsp	sp[0x10],r8
8000ab7a:	c0 49       	rjmp	8000ad82 <_dtoa_r+0xb86>
8000ab7c:	40 dc       	lddsp	r12,sp[0x34]
8000ab7e:	58 0c       	cp.w	r12,0
8000ab80:	e0 80 00 b5 	breq	8000acea <_dtoa_r+0xaee>
8000ab84:	58 05       	cp.w	r5,0
8000ab86:	e0 8a 00 08 	brle	8000ab96 <_dtoa_r+0x99a>
8000ab8a:	08 9b       	mov	r11,r4
8000ab8c:	0a 9a       	mov	r10,r5
8000ab8e:	0e 9c       	mov	r12,r7
8000ab90:	e0 a0 06 f8 	rcall	8000b980 <__lshift>
8000ab94:	18 94       	mov	r4,r12
8000ab96:	40 6b       	lddsp	r11,sp[0x18]
8000ab98:	58 0b       	cp.w	r11,0
8000ab9a:	c0 31       	brne	8000aba0 <_dtoa_r+0x9a4>
8000ab9c:	08 9c       	mov	r12,r4
8000ab9e:	c1 38       	rjmp	8000abc4 <_dtoa_r+0x9c8>
8000aba0:	68 1b       	ld.w	r11,r4[0x4]
8000aba2:	0e 9c       	mov	r12,r7
8000aba4:	e0 a0 05 fe 	rcall	8000b7a0 <_Balloc>
8000aba8:	68 4a       	ld.w	r10,r4[0x10]
8000abaa:	18 95       	mov	r5,r12
8000abac:	e8 cb ff f4 	sub	r11,r4,-12
8000abb0:	2f ea       	sub	r10,-2
8000abb2:	2f 4c       	sub	r12,-12
8000abb4:	a3 6a       	lsl	r10,0x2
8000abb6:	fe b0 e6 4f 	rcall	80007854 <memcpy>
8000abba:	0a 9b       	mov	r11,r5
8000abbc:	30 1a       	mov	r10,1
8000abbe:	0e 9c       	mov	r12,r7
8000abc0:	e0 a0 06 e0 	rcall	8000b980 <__lshift>
8000abc4:	50 44       	stdsp	sp[0x10],r4
8000abc6:	40 3a       	lddsp	r10,sp[0xc]
8000abc8:	30 19       	mov	r9,1
8000abca:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000abce:	18 94       	mov	r4,r12
8000abd0:	50 da       	stdsp	sp[0x34],r10
8000abd2:	40 85       	lddsp	r5,sp[0x20]
8000abd4:	50 99       	stdsp	sp[0x24],r9
8000abd6:	50 26       	stdsp	sp[0x8],r6
8000abd8:	50 e1       	stdsp	sp[0x38],r1
8000abda:	04 9b       	mov	r11,r2
8000abdc:	06 9c       	mov	r12,r3
8000abde:	fe b0 fa 7f 	rcall	8000a0dc <quorem>
8000abe2:	40 4b       	lddsp	r11,sp[0x10]
8000abe4:	f8 c0 ff d0 	sub	r0,r12,-48
8000abe8:	06 9c       	mov	r12,r3
8000abea:	e0 a0 05 a8 	rcall	8000b73a <__mcmp>
8000abee:	08 9a       	mov	r10,r4
8000abf0:	50 6c       	stdsp	sp[0x18],r12
8000abf2:	04 9b       	mov	r11,r2
8000abf4:	0e 9c       	mov	r12,r7
8000abf6:	e0 a0 06 5d 	rcall	8000b8b0 <__mdiff>
8000abfa:	18 91       	mov	r1,r12
8000abfc:	78 38       	ld.w	r8,r12[0xc]
8000abfe:	58 08       	cp.w	r8,0
8000ac00:	c0 30       	breq	8000ac06 <_dtoa_r+0xa0a>
8000ac02:	30 16       	mov	r6,1
8000ac04:	c0 68       	rjmp	8000ac10 <_dtoa_r+0xa14>
8000ac06:	18 9b       	mov	r11,r12
8000ac08:	06 9c       	mov	r12,r3
8000ac0a:	e0 a0 05 98 	rcall	8000b73a <__mcmp>
8000ac0e:	18 96       	mov	r6,r12
8000ac10:	0e 9c       	mov	r12,r7
8000ac12:	02 9b       	mov	r11,r1
8000ac14:	e0 a0 05 ac 	rcall	8000b76c <_Bfree>
8000ac18:	40 cc       	lddsp	r12,sp[0x30]
8000ac1a:	ed ec 10 08 	or	r8,r6,r12
8000ac1e:	c0 d1       	brne	8000ac38 <_dtoa_r+0xa3c>
8000ac20:	40 db       	lddsp	r11,sp[0x34]
8000ac22:	58 0b       	cp.w	r11,0
8000ac24:	c0 a1       	brne	8000ac38 <_dtoa_r+0xa3c>
8000ac26:	40 26       	lddsp	r6,sp[0x8]
8000ac28:	e0 40 00 39 	cp.w	r0,57
8000ac2c:	c3 00       	breq	8000ac8c <_dtoa_r+0xa90>
8000ac2e:	40 6a       	lddsp	r10,sp[0x18]
8000ac30:	58 0a       	cp.w	r10,0
8000ac32:	e0 89 00 24 	brgt	8000ac7a <_dtoa_r+0xa7e>
8000ac36:	c2 f8       	rjmp	8000ac94 <_dtoa_r+0xa98>
8000ac38:	40 69       	lddsp	r9,sp[0x18]
8000ac3a:	58 09       	cp.w	r9,0
8000ac3c:	c0 85       	brlt	8000ac4c <_dtoa_r+0xa50>
8000ac3e:	12 98       	mov	r8,r9
8000ac40:	40 cc       	lddsp	r12,sp[0x30]
8000ac42:	18 48       	or	r8,r12
8000ac44:	c1 d1       	brne	8000ac7e <_dtoa_r+0xa82>
8000ac46:	40 db       	lddsp	r11,sp[0x34]
8000ac48:	58 0b       	cp.w	r11,0
8000ac4a:	c1 a1       	brne	8000ac7e <_dtoa_r+0xa82>
8000ac4c:	0c 99       	mov	r9,r6
8000ac4e:	40 26       	lddsp	r6,sp[0x8]
8000ac50:	58 09       	cp.w	r9,0
8000ac52:	e0 8a 00 21 	brle	8000ac94 <_dtoa_r+0xa98>
8000ac56:	06 9b       	mov	r11,r3
8000ac58:	30 1a       	mov	r10,1
8000ac5a:	0e 9c       	mov	r12,r7
8000ac5c:	e0 a0 06 92 	rcall	8000b980 <__lshift>
8000ac60:	04 9b       	mov	r11,r2
8000ac62:	18 93       	mov	r3,r12
8000ac64:	e0 a0 05 6b 	rcall	8000b73a <__mcmp>
8000ac68:	e0 89 00 06 	brgt	8000ac74 <_dtoa_r+0xa78>
8000ac6c:	c1 41       	brne	8000ac94 <_dtoa_r+0xa98>
8000ac6e:	ed b0 00 00 	bld	r0,0x0
8000ac72:	c1 11       	brne	8000ac94 <_dtoa_r+0xa98>
8000ac74:	e0 40 00 39 	cp.w	r0,57
8000ac78:	c0 a0       	breq	8000ac8c <_dtoa_r+0xa90>
8000ac7a:	2f f0       	sub	r0,-1
8000ac7c:	c0 c8       	rjmp	8000ac94 <_dtoa_r+0xa98>
8000ac7e:	58 06       	cp.w	r6,0
8000ac80:	e0 8a 00 0c 	brle	8000ac98 <_dtoa_r+0xa9c>
8000ac84:	40 26       	lddsp	r6,sp[0x8]
8000ac86:	e0 40 00 39 	cp.w	r0,57
8000ac8a:	c0 41       	brne	8000ac92 <_dtoa_r+0xa96>
8000ac8c:	33 98       	mov	r8,57
8000ac8e:	0a c8       	st.b	r5++,r8
8000ac90:	c6 78       	rjmp	8000ad5e <_dtoa_r+0xb62>
8000ac92:	2f f0       	sub	r0,-1
8000ac94:	0a c0       	st.b	r5++,r0
8000ac96:	c7 58       	rjmp	8000ad80 <_dtoa_r+0xb84>
8000ac98:	0a c0       	st.b	r5++,r0
8000ac9a:	40 9a       	lddsp	r10,sp[0x24]
8000ac9c:	40 e9       	lddsp	r9,sp[0x38]
8000ac9e:	12 3a       	cp.w	r10,r9
8000aca0:	c4 30       	breq	8000ad26 <_dtoa_r+0xb2a>
8000aca2:	06 9b       	mov	r11,r3
8000aca4:	30 09       	mov	r9,0
8000aca6:	30 aa       	mov	r10,10
8000aca8:	0e 9c       	mov	r12,r7
8000acaa:	e0 a0 07 37 	rcall	8000bb18 <__multadd>
8000acae:	40 48       	lddsp	r8,sp[0x10]
8000acb0:	18 93       	mov	r3,r12
8000acb2:	08 38       	cp.w	r8,r4
8000acb4:	c0 91       	brne	8000acc6 <_dtoa_r+0xaca>
8000acb6:	10 9b       	mov	r11,r8
8000acb8:	30 09       	mov	r9,0
8000acba:	30 aa       	mov	r10,10
8000acbc:	0e 9c       	mov	r12,r7
8000acbe:	e0 a0 07 2d 	rcall	8000bb18 <__multadd>
8000acc2:	50 4c       	stdsp	sp[0x10],r12
8000acc4:	c0 e8       	rjmp	8000ace0 <_dtoa_r+0xae4>
8000acc6:	40 4b       	lddsp	r11,sp[0x10]
8000acc8:	30 09       	mov	r9,0
8000acca:	30 aa       	mov	r10,10
8000accc:	0e 9c       	mov	r12,r7
8000acce:	e0 a0 07 25 	rcall	8000bb18 <__multadd>
8000acd2:	08 9b       	mov	r11,r4
8000acd4:	50 4c       	stdsp	sp[0x10],r12
8000acd6:	30 09       	mov	r9,0
8000acd8:	30 aa       	mov	r10,10
8000acda:	0e 9c       	mov	r12,r7
8000acdc:	e0 a0 07 1e 	rcall	8000bb18 <__multadd>
8000ace0:	18 94       	mov	r4,r12
8000ace2:	40 9c       	lddsp	r12,sp[0x24]
8000ace4:	2f fc       	sub	r12,-1
8000ace6:	50 9c       	stdsp	sp[0x24],r12
8000ace8:	c7 9b       	rjmp	8000abda <_dtoa_r+0x9de>
8000acea:	30 18       	mov	r8,1
8000acec:	06 90       	mov	r0,r3
8000acee:	40 85       	lddsp	r5,sp[0x20]
8000acf0:	08 93       	mov	r3,r4
8000acf2:	0c 94       	mov	r4,r6
8000acf4:	10 96       	mov	r6,r8
8000acf6:	04 9b       	mov	r11,r2
8000acf8:	00 9c       	mov	r12,r0
8000acfa:	fe b0 f9 f1 	rcall	8000a0dc <quorem>
8000acfe:	2d 0c       	sub	r12,-48
8000ad00:	0a cc       	st.b	r5++,r12
8000ad02:	02 36       	cp.w	r6,r1
8000ad04:	c0 a4       	brge	8000ad18 <_dtoa_r+0xb1c>
8000ad06:	00 9b       	mov	r11,r0
8000ad08:	30 09       	mov	r9,0
8000ad0a:	30 aa       	mov	r10,10
8000ad0c:	0e 9c       	mov	r12,r7
8000ad0e:	2f f6       	sub	r6,-1
8000ad10:	e0 a0 07 04 	rcall	8000bb18 <__multadd>
8000ad14:	18 90       	mov	r0,r12
8000ad16:	cf 0b       	rjmp	8000acf6 <_dtoa_r+0xafa>
8000ad18:	08 96       	mov	r6,r4
8000ad1a:	30 0b       	mov	r11,0
8000ad1c:	06 94       	mov	r4,r3
8000ad1e:	50 4b       	stdsp	sp[0x10],r11
8000ad20:	00 93       	mov	r3,r0
8000ad22:	18 90       	mov	r0,r12
8000ad24:	c0 28       	rjmp	8000ad28 <_dtoa_r+0xb2c>
8000ad26:	40 26       	lddsp	r6,sp[0x8]
8000ad28:	06 9b       	mov	r11,r3
8000ad2a:	30 1a       	mov	r10,1
8000ad2c:	0e 9c       	mov	r12,r7
8000ad2e:	e0 a0 06 29 	rcall	8000b980 <__lshift>
8000ad32:	04 9b       	mov	r11,r2
8000ad34:	18 93       	mov	r3,r12
8000ad36:	e0 a0 05 02 	rcall	8000b73a <__mcmp>
8000ad3a:	e0 89 00 12 	brgt	8000ad5e <_dtoa_r+0xb62>
8000ad3e:	c1 b1       	brne	8000ad74 <_dtoa_r+0xb78>
8000ad40:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000ad44:	c0 d1       	brne	8000ad5e <_dtoa_r+0xb62>
8000ad46:	c1 78       	rjmp	8000ad74 <_dtoa_r+0xb78>
8000ad48:	40 89       	lddsp	r9,sp[0x20]
8000ad4a:	12 38       	cp.w	r8,r9
8000ad4c:	c0 30       	breq	8000ad52 <_dtoa_r+0xb56>
8000ad4e:	10 95       	mov	r5,r8
8000ad50:	c0 88       	rjmp	8000ad60 <_dtoa_r+0xb64>
8000ad52:	2f f6       	sub	r6,-1
8000ad54:	50 66       	stdsp	sp[0x18],r6
8000ad56:	33 18       	mov	r8,49
8000ad58:	40 8c       	lddsp	r12,sp[0x20]
8000ad5a:	b8 88       	st.b	r12[0x0],r8
8000ad5c:	c1 38       	rjmp	8000ad82 <_dtoa_r+0xb86>
8000ad5e:	33 9a       	mov	r10,57
8000ad60:	0a 98       	mov	r8,r5
8000ad62:	11 79       	ld.ub	r9,--r8
8000ad64:	f4 09 18 00 	cp.b	r9,r10
8000ad68:	cf 00       	breq	8000ad48 <_dtoa_r+0xb4c>
8000ad6a:	2f f9       	sub	r9,-1
8000ad6c:	b0 89       	st.b	r8[0x0],r9
8000ad6e:	c0 98       	rjmp	8000ad80 <_dtoa_r+0xb84>
8000ad70:	10 95       	mov	r5,r8
8000ad72:	c0 28       	rjmp	8000ad76 <_dtoa_r+0xb7a>
8000ad74:	33 09       	mov	r9,48
8000ad76:	0a 98       	mov	r8,r5
8000ad78:	11 7a       	ld.ub	r10,--r8
8000ad7a:	f2 0a 18 00 	cp.b	r10,r9
8000ad7e:	cf 90       	breq	8000ad70 <_dtoa_r+0xb74>
8000ad80:	50 66       	stdsp	sp[0x18],r6
8000ad82:	04 9b       	mov	r11,r2
8000ad84:	0e 9c       	mov	r12,r7
8000ad86:	e0 a0 04 f3 	rcall	8000b76c <_Bfree>
8000ad8a:	58 04       	cp.w	r4,0
8000ad8c:	c1 20       	breq	8000adb0 <_dtoa_r+0xbb4>
8000ad8e:	40 4b       	lddsp	r11,sp[0x10]
8000ad90:	08 3b       	cp.w	r11,r4
8000ad92:	5f 19       	srne	r9
8000ad94:	58 0b       	cp.w	r11,0
8000ad96:	5f 18       	srne	r8
8000ad98:	f3 e8 00 08 	and	r8,r9,r8
8000ad9c:	c0 40       	breq	8000ada4 <_dtoa_r+0xba8>
8000ad9e:	0e 9c       	mov	r12,r7
8000ada0:	e0 a0 04 e6 	rcall	8000b76c <_Bfree>
8000ada4:	08 9b       	mov	r11,r4
8000ada6:	0e 9c       	mov	r12,r7
8000ada8:	e0 a0 04 e2 	rcall	8000b76c <_Bfree>
8000adac:	c0 28       	rjmp	8000adb0 <_dtoa_r+0xbb4>
8000adae:	50 66       	stdsp	sp[0x18],r6
8000adb0:	0e 9c       	mov	r12,r7
8000adb2:	06 9b       	mov	r11,r3
8000adb4:	e0 a0 04 dc 	rcall	8000b76c <_Bfree>
8000adb8:	30 08       	mov	r8,0
8000adba:	aa 88       	st.b	r5[0x0],r8
8000adbc:	40 68       	lddsp	r8,sp[0x18]
8000adbe:	41 5a       	lddsp	r10,sp[0x54]
8000adc0:	2f f8       	sub	r8,-1
8000adc2:	41 29       	lddsp	r9,sp[0x48]
8000adc4:	95 08       	st.w	r10[0x0],r8
8000adc6:	40 8c       	lddsp	r12,sp[0x20]
8000adc8:	58 09       	cp.w	r9,0
8000adca:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000adce:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000add2:	2e 6d       	sub	sp,-104
8000add4:	d8 32       	popm	r0-r7,pc
8000add6:	d7 03       	nop

8000add8 <__errno>:
8000add8:	e0 68 0a 3c 	mov	r8,2620
8000addc:	70 0c       	ld.w	r12,r8[0x0]
8000adde:	2f 4c       	sub	r12,-12
8000ade0:	5e fc       	retal	r12
8000ade2:	d7 03       	nop

8000ade4 <_fflush_r>:
8000ade4:	d4 21       	pushm	r4-r7,lr
8000ade6:	16 97       	mov	r7,r11
8000ade8:	18 96       	mov	r6,r12
8000adea:	76 48       	ld.w	r8,r11[0x10]
8000adec:	58 08       	cp.w	r8,0
8000adee:	c7 f0       	breq	8000aeec <_fflush_r+0x108>
8000adf0:	58 0c       	cp.w	r12,0
8000adf2:	c0 50       	breq	8000adfc <_fflush_r+0x18>
8000adf4:	78 68       	ld.w	r8,r12[0x18]
8000adf6:	58 08       	cp.w	r8,0
8000adf8:	c0 21       	brne	8000adfc <_fflush_r+0x18>
8000adfa:	cc dc       	rcall	8000af94 <__sinit>
8000adfc:	fe c8 cc fc 	sub	r8,pc,-13060
8000ae00:	10 37       	cp.w	r7,r8
8000ae02:	c0 31       	brne	8000ae08 <_fflush_r+0x24>
8000ae04:	6c 07       	ld.w	r7,r6[0x0]
8000ae06:	c0 c8       	rjmp	8000ae1e <_fflush_r+0x3a>
8000ae08:	fe c8 cc e8 	sub	r8,pc,-13080
8000ae0c:	10 37       	cp.w	r7,r8
8000ae0e:	c0 31       	brne	8000ae14 <_fflush_r+0x30>
8000ae10:	6c 17       	ld.w	r7,r6[0x4]
8000ae12:	c0 68       	rjmp	8000ae1e <_fflush_r+0x3a>
8000ae14:	fe c8 cc d4 	sub	r8,pc,-13100
8000ae18:	10 37       	cp.w	r7,r8
8000ae1a:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000ae1e:	8e 6a       	ld.sh	r10,r7[0xc]
8000ae20:	14 98       	mov	r8,r10
8000ae22:	ed ba 00 03 	bld	r10,0x3
8000ae26:	c4 20       	breq	8000aeaa <_fflush_r+0xc6>
8000ae28:	ab ba       	sbr	r10,0xb
8000ae2a:	ae 6a       	st.h	r7[0xc],r10
8000ae2c:	6e 18       	ld.w	r8,r7[0x4]
8000ae2e:	58 08       	cp.w	r8,0
8000ae30:	e0 89 00 06 	brgt	8000ae3c <_fflush_r+0x58>
8000ae34:	6f 08       	ld.w	r8,r7[0x40]
8000ae36:	58 08       	cp.w	r8,0
8000ae38:	e0 8a 00 5a 	brle	8000aeec <_fflush_r+0x108>
8000ae3c:	6e b8       	ld.w	r8,r7[0x2c]
8000ae3e:	58 08       	cp.w	r8,0
8000ae40:	c5 60       	breq	8000aeec <_fflush_r+0x108>
8000ae42:	e2 1a 10 00 	andl	r10,0x1000,COH
8000ae46:	c0 30       	breq	8000ae4c <_fflush_r+0x68>
8000ae48:	6f 55       	ld.w	r5,r7[0x54]
8000ae4a:	c0 f8       	rjmp	8000ae68 <_fflush_r+0x84>
8000ae4c:	30 19       	mov	r9,1
8000ae4e:	6e 8b       	ld.w	r11,r7[0x20]
8000ae50:	0c 9c       	mov	r12,r6
8000ae52:	5d 18       	icall	r8
8000ae54:	18 95       	mov	r5,r12
8000ae56:	5b fc       	cp.w	r12,-1
8000ae58:	c0 81       	brne	8000ae68 <_fflush_r+0x84>
8000ae5a:	6c 38       	ld.w	r8,r6[0xc]
8000ae5c:	59 d8       	cp.w	r8,29
8000ae5e:	c4 70       	breq	8000aeec <_fflush_r+0x108>
8000ae60:	8e 68       	ld.sh	r8,r7[0xc]
8000ae62:	a7 a8       	sbr	r8,0x6
8000ae64:	ae 68       	st.h	r7[0xc],r8
8000ae66:	d8 22       	popm	r4-r7,pc
8000ae68:	8e 68       	ld.sh	r8,r7[0xc]
8000ae6a:	ed b8 00 02 	bld	r8,0x2
8000ae6e:	c0 91       	brne	8000ae80 <_fflush_r+0x9c>
8000ae70:	6e 18       	ld.w	r8,r7[0x4]
8000ae72:	10 15       	sub	r5,r8
8000ae74:	6e d8       	ld.w	r8,r7[0x34]
8000ae76:	58 08       	cp.w	r8,0
8000ae78:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000ae7c:	eb d8 e1 15 	subne	r5,r5,r8
8000ae80:	6e b8       	ld.w	r8,r7[0x2c]
8000ae82:	0c 9c       	mov	r12,r6
8000ae84:	30 09       	mov	r9,0
8000ae86:	0a 9a       	mov	r10,r5
8000ae88:	6e 8b       	ld.w	r11,r7[0x20]
8000ae8a:	5d 18       	icall	r8
8000ae8c:	8e 68       	ld.sh	r8,r7[0xc]
8000ae8e:	0a 3c       	cp.w	r12,r5
8000ae90:	c2 61       	brne	8000aedc <_fflush_r+0xf8>
8000ae92:	ab d8       	cbr	r8,0xb
8000ae94:	30 0c       	mov	r12,0
8000ae96:	6e 49       	ld.w	r9,r7[0x10]
8000ae98:	ae 68       	st.h	r7[0xc],r8
8000ae9a:	8f 1c       	st.w	r7[0x4],r12
8000ae9c:	8f 09       	st.w	r7[0x0],r9
8000ae9e:	ed b8 00 0c 	bld	r8,0xc
8000aea2:	c2 51       	brne	8000aeec <_fflush_r+0x108>
8000aea4:	ef 45 00 54 	st.w	r7[84],r5
8000aea8:	d8 22       	popm	r4-r7,pc
8000aeaa:	6e 45       	ld.w	r5,r7[0x10]
8000aeac:	58 05       	cp.w	r5,0
8000aeae:	c1 f0       	breq	8000aeec <_fflush_r+0x108>
8000aeb0:	6e 04       	ld.w	r4,r7[0x0]
8000aeb2:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000aeb6:	8f 05       	st.w	r7[0x0],r5
8000aeb8:	f9 b8 01 00 	movne	r8,0
8000aebc:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000aec0:	0a 14       	sub	r4,r5
8000aec2:	8f 28       	st.w	r7[0x8],r8
8000aec4:	c1 18       	rjmp	8000aee6 <_fflush_r+0x102>
8000aec6:	08 99       	mov	r9,r4
8000aec8:	0a 9a       	mov	r10,r5
8000aeca:	6e a8       	ld.w	r8,r7[0x28]
8000aecc:	6e 8b       	ld.w	r11,r7[0x20]
8000aece:	0c 9c       	mov	r12,r6
8000aed0:	5d 18       	icall	r8
8000aed2:	18 14       	sub	r4,r12
8000aed4:	58 0c       	cp.w	r12,0
8000aed6:	e0 89 00 07 	brgt	8000aee4 <_fflush_r+0x100>
8000aeda:	8e 68       	ld.sh	r8,r7[0xc]
8000aedc:	a7 a8       	sbr	r8,0x6
8000aede:	3f fc       	mov	r12,-1
8000aee0:	ae 68       	st.h	r7[0xc],r8
8000aee2:	d8 22       	popm	r4-r7,pc
8000aee4:	18 05       	add	r5,r12
8000aee6:	58 04       	cp.w	r4,0
8000aee8:	fe 99 ff ef 	brgt	8000aec6 <_fflush_r+0xe2>
8000aeec:	d8 2a       	popm	r4-r7,pc,r12=0
8000aeee:	d7 03       	nop

8000aef0 <__sfp_lock_acquire>:
8000aef0:	5e fc       	retal	r12

8000aef2 <__sfp_lock_release>:
8000aef2:	5e fc       	retal	r12

8000aef4 <_cleanup_r>:
8000aef4:	d4 01       	pushm	lr
8000aef6:	fe cb f0 ae 	sub	r11,pc,-3922
8000aefa:	e0 a0 02 f7 	rcall	8000b4e8 <_fwalk>
8000aefe:	d8 02       	popm	pc

8000af00 <__sfmoreglue>:
8000af00:	d4 21       	pushm	r4-r7,lr
8000af02:	16 95       	mov	r5,r11
8000af04:	f6 06 10 5c 	mul	r6,r11,92
8000af08:	ec cb ff f4 	sub	r11,r6,-12
8000af0c:	fe b0 e2 88 	rcall	8000741c <_malloc_r>
8000af10:	18 97       	mov	r7,r12
8000af12:	c0 90       	breq	8000af24 <__sfmoreglue+0x24>
8000af14:	99 15       	st.w	r12[0x4],r5
8000af16:	30 0b       	mov	r11,0
8000af18:	2f 4c       	sub	r12,-12
8000af1a:	0c 9a       	mov	r10,r6
8000af1c:	8f 2c       	st.w	r7[0x8],r12
8000af1e:	8f 0b       	st.w	r7[0x0],r11
8000af20:	fe b0 e5 3e 	rcall	8000799c <memset>
8000af24:	0e 9c       	mov	r12,r7
8000af26:	d8 22       	popm	r4-r7,pc

8000af28 <__sfp>:
8000af28:	d4 21       	pushm	r4-r7,lr
8000af2a:	fe c8 cd c6 	sub	r8,pc,-12858
8000af2e:	18 96       	mov	r6,r12
8000af30:	70 07       	ld.w	r7,r8[0x0]
8000af32:	6e 68       	ld.w	r8,r7[0x18]
8000af34:	58 08       	cp.w	r8,0
8000af36:	c0 31       	brne	8000af3c <__sfp+0x14>
8000af38:	0e 9c       	mov	r12,r7
8000af3a:	c2 dc       	rcall	8000af94 <__sinit>
8000af3c:	ee c7 ff 28 	sub	r7,r7,-216
8000af40:	30 05       	mov	r5,0
8000af42:	6e 2c       	ld.w	r12,r7[0x8]
8000af44:	6e 18       	ld.w	r8,r7[0x4]
8000af46:	c0 68       	rjmp	8000af52 <__sfp+0x2a>
8000af48:	98 69       	ld.sh	r9,r12[0xc]
8000af4a:	ea 09 19 00 	cp.h	r9,r5
8000af4e:	c1 10       	breq	8000af70 <__sfp+0x48>
8000af50:	2a 4c       	sub	r12,-92
8000af52:	20 18       	sub	r8,1
8000af54:	cf a7       	brpl	8000af48 <__sfp+0x20>
8000af56:	6e 08       	ld.w	r8,r7[0x0]
8000af58:	58 08       	cp.w	r8,0
8000af5a:	c0 61       	brne	8000af66 <__sfp+0x3e>
8000af5c:	30 4b       	mov	r11,4
8000af5e:	0c 9c       	mov	r12,r6
8000af60:	cd 0f       	rcall	8000af00 <__sfmoreglue>
8000af62:	8f 0c       	st.w	r7[0x0],r12
8000af64:	c0 30       	breq	8000af6a <__sfp+0x42>
8000af66:	6e 07       	ld.w	r7,r7[0x0]
8000af68:	ce db       	rjmp	8000af42 <__sfp+0x1a>
8000af6a:	30 c8       	mov	r8,12
8000af6c:	8d 38       	st.w	r6[0xc],r8
8000af6e:	d8 22       	popm	r4-r7,pc
8000af70:	30 08       	mov	r8,0
8000af72:	f9 48 00 4c 	st.w	r12[76],r8
8000af76:	99 08       	st.w	r12[0x0],r8
8000af78:	99 28       	st.w	r12[0x8],r8
8000af7a:	99 18       	st.w	r12[0x4],r8
8000af7c:	99 48       	st.w	r12[0x10],r8
8000af7e:	99 58       	st.w	r12[0x14],r8
8000af80:	99 68       	st.w	r12[0x18],r8
8000af82:	99 d8       	st.w	r12[0x34],r8
8000af84:	99 e8       	st.w	r12[0x38],r8
8000af86:	f9 48 00 48 	st.w	r12[72],r8
8000af8a:	3f f8       	mov	r8,-1
8000af8c:	b8 78       	st.h	r12[0xe],r8
8000af8e:	30 18       	mov	r8,1
8000af90:	b8 68       	st.h	r12[0xc],r8
8000af92:	d8 22       	popm	r4-r7,pc

8000af94 <__sinit>:
8000af94:	d4 21       	pushm	r4-r7,lr
8000af96:	18 96       	mov	r6,r12
8000af98:	78 67       	ld.w	r7,r12[0x18]
8000af9a:	58 07       	cp.w	r7,0
8000af9c:	c4 91       	brne	8000b02e <__sinit+0x9a>
8000af9e:	fe c8 00 aa 	sub	r8,pc,170
8000afa2:	30 15       	mov	r5,1
8000afa4:	99 a8       	st.w	r12[0x28],r8
8000afa6:	f9 47 00 d8 	st.w	r12[216],r7
8000afaa:	f9 47 00 dc 	st.w	r12[220],r7
8000afae:	f9 47 00 e0 	st.w	r12[224],r7
8000afb2:	99 65       	st.w	r12[0x18],r5
8000afb4:	cb af       	rcall	8000af28 <__sfp>
8000afb6:	8d 0c       	st.w	r6[0x0],r12
8000afb8:	0c 9c       	mov	r12,r6
8000afba:	cb 7f       	rcall	8000af28 <__sfp>
8000afbc:	8d 1c       	st.w	r6[0x4],r12
8000afbe:	0c 9c       	mov	r12,r6
8000afc0:	cb 4f       	rcall	8000af28 <__sfp>
8000afc2:	6c 09       	ld.w	r9,r6[0x0]
8000afc4:	30 48       	mov	r8,4
8000afc6:	93 07       	st.w	r9[0x0],r7
8000afc8:	b2 68       	st.h	r9[0xc],r8
8000afca:	93 17       	st.w	r9[0x4],r7
8000afcc:	93 27       	st.w	r9[0x8],r7
8000afce:	6c 18       	ld.w	r8,r6[0x4]
8000afd0:	b2 77       	st.h	r9[0xe],r7
8000afd2:	93 47       	st.w	r9[0x10],r7
8000afd4:	93 57       	st.w	r9[0x14],r7
8000afd6:	93 67       	st.w	r9[0x18],r7
8000afd8:	93 89       	st.w	r9[0x20],r9
8000afda:	91 07       	st.w	r8[0x0],r7
8000afdc:	91 17       	st.w	r8[0x4],r7
8000afde:	91 27       	st.w	r8[0x8],r7
8000afe0:	fe ce f3 24 	sub	lr,pc,-3292
8000afe4:	fe cb f3 54 	sub	r11,pc,-3244
8000afe8:	93 9e       	st.w	r9[0x24],lr
8000afea:	93 ab       	st.w	r9[0x28],r11
8000afec:	fe ca f3 7c 	sub	r10,pc,-3204
8000aff0:	fe c4 f3 88 	sub	r4,pc,-3192
8000aff4:	93 ba       	st.w	r9[0x2c],r10
8000aff6:	93 c4       	st.w	r9[0x30],r4
8000aff8:	30 99       	mov	r9,9
8000affa:	b0 69       	st.h	r8[0xc],r9
8000affc:	b0 75       	st.h	r8[0xe],r5
8000affe:	91 c4       	st.w	r8[0x30],r4
8000b000:	91 47       	st.w	r8[0x10],r7
8000b002:	91 57       	st.w	r8[0x14],r7
8000b004:	91 67       	st.w	r8[0x18],r7
8000b006:	91 88       	st.w	r8[0x20],r8
8000b008:	91 9e       	st.w	r8[0x24],lr
8000b00a:	91 ab       	st.w	r8[0x28],r11
8000b00c:	91 ba       	st.w	r8[0x2c],r10
8000b00e:	8d 2c       	st.w	r6[0x8],r12
8000b010:	31 28       	mov	r8,18
8000b012:	99 07       	st.w	r12[0x0],r7
8000b014:	b8 68       	st.h	r12[0xc],r8
8000b016:	99 17       	st.w	r12[0x4],r7
8000b018:	99 27       	st.w	r12[0x8],r7
8000b01a:	30 28       	mov	r8,2
8000b01c:	b8 78       	st.h	r12[0xe],r8
8000b01e:	99 c4       	st.w	r12[0x30],r4
8000b020:	99 67       	st.w	r12[0x18],r7
8000b022:	99 9e       	st.w	r12[0x24],lr
8000b024:	99 ab       	st.w	r12[0x28],r11
8000b026:	99 ba       	st.w	r12[0x2c],r10
8000b028:	99 47       	st.w	r12[0x10],r7
8000b02a:	99 57       	st.w	r12[0x14],r7
8000b02c:	99 8c       	st.w	r12[0x20],r12
8000b02e:	d8 22       	popm	r4-r7,pc

8000b030 <_malloc_trim_r>:
8000b030:	d4 21       	pushm	r4-r7,lr
8000b032:	16 95       	mov	r5,r11
8000b034:	18 97       	mov	r7,r12
8000b036:	fe b0 d7 a9 	rcall	80005f88 <__malloc_lock>
8000b03a:	e0 64 05 3c 	mov	r4,1340
8000b03e:	68 28       	ld.w	r8,r4[0x8]
8000b040:	70 16       	ld.w	r6,r8[0x4]
8000b042:	e0 16 ff fc 	andl	r6,0xfffc
8000b046:	ec c8 ff 91 	sub	r8,r6,-111
8000b04a:	f0 05 01 05 	sub	r5,r8,r5
8000b04e:	e0 15 ff 80 	andl	r5,0xff80
8000b052:	ea c5 00 80 	sub	r5,r5,128
8000b056:	e0 45 00 7f 	cp.w	r5,127
8000b05a:	e0 8a 00 25 	brle	8000b0a4 <_malloc_trim_r+0x74>
8000b05e:	30 0b       	mov	r11,0
8000b060:	0e 9c       	mov	r12,r7
8000b062:	fe b0 e6 05 	rcall	80007c6c <_sbrk_r>
8000b066:	68 28       	ld.w	r8,r4[0x8]
8000b068:	0c 08       	add	r8,r6
8000b06a:	10 3c       	cp.w	r12,r8
8000b06c:	c1 c1       	brne	8000b0a4 <_malloc_trim_r+0x74>
8000b06e:	ea 0b 11 00 	rsub	r11,r5,0
8000b072:	0e 9c       	mov	r12,r7
8000b074:	fe b0 e5 fc 	rcall	80007c6c <_sbrk_r>
8000b078:	5b fc       	cp.w	r12,-1
8000b07a:	c1 91       	brne	8000b0ac <_malloc_trim_r+0x7c>
8000b07c:	30 0b       	mov	r11,0
8000b07e:	0e 9c       	mov	r12,r7
8000b080:	fe b0 e5 f6 	rcall	80007c6c <_sbrk_r>
8000b084:	68 28       	ld.w	r8,r4[0x8]
8000b086:	f8 08 01 09 	sub	r9,r12,r8
8000b08a:	58 f9       	cp.w	r9,15
8000b08c:	e0 8a 00 0c 	brle	8000b0a4 <_malloc_trim_r+0x74>
8000b090:	a1 a9       	sbr	r9,0x0
8000b092:	91 19       	st.w	r8[0x4],r9
8000b094:	e0 68 09 48 	mov	r8,2376
8000b098:	70 09       	ld.w	r9,r8[0x0]
8000b09a:	e0 68 0d 60 	mov	r8,3424
8000b09e:	f8 09 01 09 	sub	r9,r12,r9
8000b0a2:	91 09       	st.w	r8[0x0],r9
8000b0a4:	0e 9c       	mov	r12,r7
8000b0a6:	fe b0 d7 77 	rcall	80005f94 <__malloc_unlock>
8000b0aa:	d8 2a       	popm	r4-r7,pc,r12=0
8000b0ac:	68 28       	ld.w	r8,r4[0x8]
8000b0ae:	0a 16       	sub	r6,r5
8000b0b0:	a1 a6       	sbr	r6,0x0
8000b0b2:	91 16       	st.w	r8[0x4],r6
8000b0b4:	e0 68 0d 60 	mov	r8,3424
8000b0b8:	70 09       	ld.w	r9,r8[0x0]
8000b0ba:	0a 19       	sub	r9,r5
8000b0bc:	0e 9c       	mov	r12,r7
8000b0be:	91 09       	st.w	r8[0x0],r9
8000b0c0:	fe b0 d7 6a 	rcall	80005f94 <__malloc_unlock>
8000b0c4:	da 2a       	popm	r4-r7,pc,r12=1
8000b0c6:	d7 03       	nop

8000b0c8 <_free_r>:
8000b0c8:	d4 21       	pushm	r4-r7,lr
8000b0ca:	16 96       	mov	r6,r11
8000b0cc:	18 97       	mov	r7,r12
8000b0ce:	58 0b       	cp.w	r11,0
8000b0d0:	e0 80 00 c0 	breq	8000b250 <_free_r+0x188>
8000b0d4:	fe b0 d7 5a 	rcall	80005f88 <__malloc_lock>
8000b0d8:	20 86       	sub	r6,8
8000b0da:	e0 6a 05 3c 	mov	r10,1340
8000b0de:	6c 18       	ld.w	r8,r6[0x4]
8000b0e0:	74 2e       	ld.w	lr,r10[0x8]
8000b0e2:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000b0e6:	a1 c8       	cbr	r8,0x0
8000b0e8:	ec 08 00 09 	add	r9,r6,r8
8000b0ec:	72 1b       	ld.w	r11,r9[0x4]
8000b0ee:	e0 1b ff fc 	andl	r11,0xfffc
8000b0f2:	1c 39       	cp.w	r9,lr
8000b0f4:	c1 e1       	brne	8000b130 <_free_r+0x68>
8000b0f6:	f6 08 00 08 	add	r8,r11,r8
8000b0fa:	58 0c       	cp.w	r12,0
8000b0fc:	c0 81       	brne	8000b10c <_free_r+0x44>
8000b0fe:	6c 09       	ld.w	r9,r6[0x0]
8000b100:	12 16       	sub	r6,r9
8000b102:	12 08       	add	r8,r9
8000b104:	6c 3b       	ld.w	r11,r6[0xc]
8000b106:	6c 29       	ld.w	r9,r6[0x8]
8000b108:	97 29       	st.w	r11[0x8],r9
8000b10a:	93 3b       	st.w	r9[0xc],r11
8000b10c:	10 99       	mov	r9,r8
8000b10e:	95 26       	st.w	r10[0x8],r6
8000b110:	a1 a9       	sbr	r9,0x0
8000b112:	8d 19       	st.w	r6[0x4],r9
8000b114:	e0 69 09 44 	mov	r9,2372
8000b118:	72 09       	ld.w	r9,r9[0x0]
8000b11a:	12 38       	cp.w	r8,r9
8000b11c:	c0 63       	brcs	8000b128 <_free_r+0x60>
8000b11e:	e0 68 0d 5c 	mov	r8,3420
8000b122:	0e 9c       	mov	r12,r7
8000b124:	70 0b       	ld.w	r11,r8[0x0]
8000b126:	c8 5f       	rcall	8000b030 <_malloc_trim_r>
8000b128:	0e 9c       	mov	r12,r7
8000b12a:	fe b0 d7 35 	rcall	80005f94 <__malloc_unlock>
8000b12e:	d8 22       	popm	r4-r7,pc
8000b130:	93 1b       	st.w	r9[0x4],r11
8000b132:	58 0c       	cp.w	r12,0
8000b134:	c0 30       	breq	8000b13a <_free_r+0x72>
8000b136:	30 0c       	mov	r12,0
8000b138:	c1 08       	rjmp	8000b158 <_free_r+0x90>
8000b13a:	6c 0e       	ld.w	lr,r6[0x0]
8000b13c:	f4 c5 ff f8 	sub	r5,r10,-8
8000b140:	1c 16       	sub	r6,lr
8000b142:	1c 08       	add	r8,lr
8000b144:	6c 2e       	ld.w	lr,r6[0x8]
8000b146:	0a 3e       	cp.w	lr,r5
8000b148:	f9 bc 00 01 	moveq	r12,1
8000b14c:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000b150:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000b154:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000b158:	f2 0b 00 0e 	add	lr,r9,r11
8000b15c:	7c 1e       	ld.w	lr,lr[0x4]
8000b15e:	ed be 00 00 	bld	lr,0x0
8000b162:	c1 40       	breq	8000b18a <_free_r+0xc2>
8000b164:	16 08       	add	r8,r11
8000b166:	58 0c       	cp.w	r12,0
8000b168:	c0 d1       	brne	8000b182 <_free_r+0xba>
8000b16a:	e0 6e 05 3c 	mov	lr,1340
8000b16e:	72 2b       	ld.w	r11,r9[0x8]
8000b170:	2f 8e       	sub	lr,-8
8000b172:	1c 3b       	cp.w	r11,lr
8000b174:	c0 71       	brne	8000b182 <_free_r+0xba>
8000b176:	97 36       	st.w	r11[0xc],r6
8000b178:	97 26       	st.w	r11[0x8],r6
8000b17a:	8d 2b       	st.w	r6[0x8],r11
8000b17c:	8d 3b       	st.w	r6[0xc],r11
8000b17e:	30 1c       	mov	r12,1
8000b180:	c0 58       	rjmp	8000b18a <_free_r+0xc2>
8000b182:	72 2b       	ld.w	r11,r9[0x8]
8000b184:	72 39       	ld.w	r9,r9[0xc]
8000b186:	93 2b       	st.w	r9[0x8],r11
8000b188:	97 39       	st.w	r11[0xc],r9
8000b18a:	10 99       	mov	r9,r8
8000b18c:	ec 08 09 08 	st.w	r6[r8],r8
8000b190:	a1 a9       	sbr	r9,0x0
8000b192:	8d 19       	st.w	r6[0x4],r9
8000b194:	58 0c       	cp.w	r12,0
8000b196:	c5 a1       	brne	8000b24a <_free_r+0x182>
8000b198:	e0 48 01 ff 	cp.w	r8,511
8000b19c:	e0 8b 00 13 	brhi	8000b1c2 <_free_r+0xfa>
8000b1a0:	a3 98       	lsr	r8,0x3
8000b1a2:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000b1a6:	72 2b       	ld.w	r11,r9[0x8]
8000b1a8:	8d 39       	st.w	r6[0xc],r9
8000b1aa:	8d 2b       	st.w	r6[0x8],r11
8000b1ac:	97 36       	st.w	r11[0xc],r6
8000b1ae:	93 26       	st.w	r9[0x8],r6
8000b1b0:	a3 48       	asr	r8,0x2
8000b1b2:	74 19       	ld.w	r9,r10[0x4]
8000b1b4:	30 1b       	mov	r11,1
8000b1b6:	f6 08 09 48 	lsl	r8,r11,r8
8000b1ba:	f3 e8 10 08 	or	r8,r9,r8
8000b1be:	95 18       	st.w	r10[0x4],r8
8000b1c0:	c4 58       	rjmp	8000b24a <_free_r+0x182>
8000b1c2:	f0 0b 16 09 	lsr	r11,r8,0x9
8000b1c6:	58 4b       	cp.w	r11,4
8000b1c8:	e0 8b 00 06 	brhi	8000b1d4 <_free_r+0x10c>
8000b1cc:	f0 0b 16 06 	lsr	r11,r8,0x6
8000b1d0:	2c 8b       	sub	r11,-56
8000b1d2:	c2 08       	rjmp	8000b212 <_free_r+0x14a>
8000b1d4:	59 4b       	cp.w	r11,20
8000b1d6:	e0 8b 00 04 	brhi	8000b1de <_free_r+0x116>
8000b1da:	2a 5b       	sub	r11,-91
8000b1dc:	c1 b8       	rjmp	8000b212 <_free_r+0x14a>
8000b1de:	e0 4b 00 54 	cp.w	r11,84
8000b1e2:	e0 8b 00 06 	brhi	8000b1ee <_free_r+0x126>
8000b1e6:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000b1ea:	29 2b       	sub	r11,-110
8000b1ec:	c1 38       	rjmp	8000b212 <_free_r+0x14a>
8000b1ee:	e0 4b 01 54 	cp.w	r11,340
8000b1f2:	e0 8b 00 06 	brhi	8000b1fe <_free_r+0x136>
8000b1f6:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000b1fa:	28 9b       	sub	r11,-119
8000b1fc:	c0 b8       	rjmp	8000b212 <_free_r+0x14a>
8000b1fe:	e0 4b 05 54 	cp.w	r11,1364
8000b202:	e0 88 00 05 	brls	8000b20c <_free_r+0x144>
8000b206:	37 eb       	mov	r11,126
8000b208:	c0 58       	rjmp	8000b212 <_free_r+0x14a>
8000b20a:	d7 03       	nop
8000b20c:	f0 0b 16 12 	lsr	r11,r8,0x12
8000b210:	28 4b       	sub	r11,-124
8000b212:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000b216:	78 29       	ld.w	r9,r12[0x8]
8000b218:	18 39       	cp.w	r9,r12
8000b21a:	c0 e1       	brne	8000b236 <_free_r+0x16e>
8000b21c:	74 18       	ld.w	r8,r10[0x4]
8000b21e:	a3 4b       	asr	r11,0x2
8000b220:	30 1c       	mov	r12,1
8000b222:	f8 0b 09 4b 	lsl	r11,r12,r11
8000b226:	f1 eb 10 0b 	or	r11,r8,r11
8000b22a:	12 98       	mov	r8,r9
8000b22c:	95 1b       	st.w	r10[0x4],r11
8000b22e:	c0 a8       	rjmp	8000b242 <_free_r+0x17a>
8000b230:	72 29       	ld.w	r9,r9[0x8]
8000b232:	18 39       	cp.w	r9,r12
8000b234:	c0 60       	breq	8000b240 <_free_r+0x178>
8000b236:	72 1a       	ld.w	r10,r9[0x4]
8000b238:	e0 1a ff fc 	andl	r10,0xfffc
8000b23c:	14 38       	cp.w	r8,r10
8000b23e:	cf 93       	brcs	8000b230 <_free_r+0x168>
8000b240:	72 38       	ld.w	r8,r9[0xc]
8000b242:	8d 38       	st.w	r6[0xc],r8
8000b244:	8d 29       	st.w	r6[0x8],r9
8000b246:	93 36       	st.w	r9[0xc],r6
8000b248:	91 26       	st.w	r8[0x8],r6
8000b24a:	0e 9c       	mov	r12,r7
8000b24c:	fe b0 d6 a4 	rcall	80005f94 <__malloc_unlock>
8000b250:	d8 22       	popm	r4-r7,pc
8000b252:	d7 03       	nop

8000b254 <__sfvwrite_r>:
8000b254:	d4 31       	pushm	r0-r7,lr
8000b256:	20 3d       	sub	sp,12
8000b258:	14 94       	mov	r4,r10
8000b25a:	18 95       	mov	r5,r12
8000b25c:	16 97       	mov	r7,r11
8000b25e:	74 28       	ld.w	r8,r10[0x8]
8000b260:	58 08       	cp.w	r8,0
8000b262:	e0 80 01 40 	breq	8000b4e2 <__sfvwrite_r+0x28e>
8000b266:	96 68       	ld.sh	r8,r11[0xc]
8000b268:	ed b8 00 03 	bld	r8,0x3
8000b26c:	c0 41       	brne	8000b274 <__sfvwrite_r+0x20>
8000b26e:	76 48       	ld.w	r8,r11[0x10]
8000b270:	58 08       	cp.w	r8,0
8000b272:	c0 c1       	brne	8000b28a <__sfvwrite_r+0x36>
8000b274:	0e 9b       	mov	r11,r7
8000b276:	0a 9c       	mov	r12,r5
8000b278:	fe b0 f6 c4 	rcall	8000a000 <__swsetup_r>
8000b27c:	c0 70       	breq	8000b28a <__sfvwrite_r+0x36>
8000b27e:	8e 68       	ld.sh	r8,r7[0xc]
8000b280:	a7 a8       	sbr	r8,0x6
8000b282:	ae 68       	st.h	r7[0xc],r8
8000b284:	30 98       	mov	r8,9
8000b286:	8b 38       	st.w	r5[0xc],r8
8000b288:	c2 b9       	rjmp	8000b4de <__sfvwrite_r+0x28a>
8000b28a:	8e 63       	ld.sh	r3,r7[0xc]
8000b28c:	68 00       	ld.w	r0,r4[0x0]
8000b28e:	06 96       	mov	r6,r3
8000b290:	e2 16 00 02 	andl	r6,0x2,COH
8000b294:	c2 10       	breq	8000b2d6 <__sfvwrite_r+0x82>
8000b296:	30 03       	mov	r3,0
8000b298:	e0 62 04 00 	mov	r2,1024
8000b29c:	06 96       	mov	r6,r3
8000b29e:	c0 48       	rjmp	8000b2a6 <__sfvwrite_r+0x52>
8000b2a0:	60 03       	ld.w	r3,r0[0x0]
8000b2a2:	60 16       	ld.w	r6,r0[0x4]
8000b2a4:	2f 80       	sub	r0,-8
8000b2a6:	58 06       	cp.w	r6,0
8000b2a8:	cf c0       	breq	8000b2a0 <__sfvwrite_r+0x4c>
8000b2aa:	e0 46 04 00 	cp.w	r6,1024
8000b2ae:	ec 09 17 80 	movls	r9,r6
8000b2b2:	e4 09 17 b0 	movhi	r9,r2
8000b2b6:	06 9a       	mov	r10,r3
8000b2b8:	6e a8       	ld.w	r8,r7[0x28]
8000b2ba:	6e 8b       	ld.w	r11,r7[0x20]
8000b2bc:	0a 9c       	mov	r12,r5
8000b2be:	5d 18       	icall	r8
8000b2c0:	18 16       	sub	r6,r12
8000b2c2:	58 0c       	cp.w	r12,0
8000b2c4:	e0 8a 01 0a 	brle	8000b4d8 <__sfvwrite_r+0x284>
8000b2c8:	68 28       	ld.w	r8,r4[0x8]
8000b2ca:	18 18       	sub	r8,r12
8000b2cc:	89 28       	st.w	r4[0x8],r8
8000b2ce:	e0 80 01 0a 	breq	8000b4e2 <__sfvwrite_r+0x28e>
8000b2d2:	18 03       	add	r3,r12
8000b2d4:	ce 9b       	rjmp	8000b2a6 <__sfvwrite_r+0x52>
8000b2d6:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000b2da:	c0 70       	breq	8000b2e8 <__sfvwrite_r+0x94>
8000b2dc:	50 06       	stdsp	sp[0x0],r6
8000b2de:	0c 93       	mov	r3,r6
8000b2e0:	0c 91       	mov	r1,r6
8000b2e2:	50 15       	stdsp	sp[0x4],r5
8000b2e4:	08 92       	mov	r2,r4
8000b2e6:	c9 c8       	rjmp	8000b41e <__sfvwrite_r+0x1ca>
8000b2e8:	06 96       	mov	r6,r3
8000b2ea:	08 91       	mov	r1,r4
8000b2ec:	c0 48       	rjmp	8000b2f4 <__sfvwrite_r+0xa0>
8000b2ee:	60 03       	ld.w	r3,r0[0x0]
8000b2f0:	60 16       	ld.w	r6,r0[0x4]
8000b2f2:	2f 80       	sub	r0,-8
8000b2f4:	58 06       	cp.w	r6,0
8000b2f6:	cf c0       	breq	8000b2ee <__sfvwrite_r+0x9a>
8000b2f8:	8e 68       	ld.sh	r8,r7[0xc]
8000b2fa:	6e 24       	ld.w	r4,r7[0x8]
8000b2fc:	10 99       	mov	r9,r8
8000b2fe:	e2 19 02 00 	andl	r9,0x200,COH
8000b302:	c5 50       	breq	8000b3ac <__sfvwrite_r+0x158>
8000b304:	08 36       	cp.w	r6,r4
8000b306:	c4 43       	brcs	8000b38e <__sfvwrite_r+0x13a>
8000b308:	10 99       	mov	r9,r8
8000b30a:	e2 19 04 80 	andl	r9,0x480,COH
8000b30e:	c4 00       	breq	8000b38e <__sfvwrite_r+0x13a>
8000b310:	6e 4b       	ld.w	r11,r7[0x10]
8000b312:	6e 09       	ld.w	r9,r7[0x0]
8000b314:	16 19       	sub	r9,r11
8000b316:	50 09       	stdsp	sp[0x0],r9
8000b318:	6e 59       	ld.w	r9,r7[0x14]
8000b31a:	10 9c       	mov	r12,r8
8000b31c:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000b320:	30 28       	mov	r8,2
8000b322:	f4 08 0c 08 	divs	r8,r10,r8
8000b326:	fa e9 00 04 	st.d	sp[4],r8
8000b32a:	10 94       	mov	r4,r8
8000b32c:	40 09       	lddsp	r9,sp[0x0]
8000b32e:	e2 1c 04 00 	andl	r12,0x400,COH
8000b332:	2f f9       	sub	r9,-1
8000b334:	0c 09       	add	r9,r6
8000b336:	12 38       	cp.w	r8,r9
8000b338:	f2 04 17 30 	movlo	r4,r9
8000b33c:	58 0c       	cp.w	r12,0
8000b33e:	c1 10       	breq	8000b360 <__sfvwrite_r+0x10c>
8000b340:	08 9b       	mov	r11,r4
8000b342:	0a 9c       	mov	r12,r5
8000b344:	fe b0 e0 6c 	rcall	8000741c <_malloc_r>
8000b348:	18 92       	mov	r2,r12
8000b34a:	c1 40       	breq	8000b372 <__sfvwrite_r+0x11e>
8000b34c:	40 0a       	lddsp	r10,sp[0x0]
8000b34e:	6e 4b       	ld.w	r11,r7[0x10]
8000b350:	fe b0 e2 82 	rcall	80007854 <memcpy>
8000b354:	8e 68       	ld.sh	r8,r7[0xc]
8000b356:	e0 18 fb 7f 	andl	r8,0xfb7f
8000b35a:	a7 b8       	sbr	r8,0x7
8000b35c:	ae 68       	st.h	r7[0xc],r8
8000b35e:	c0 d8       	rjmp	8000b378 <__sfvwrite_r+0x124>
8000b360:	08 9a       	mov	r10,r4
8000b362:	0a 9c       	mov	r12,r5
8000b364:	fe b0 e3 24 	rcall	800079ac <_realloc_r>
8000b368:	18 92       	mov	r2,r12
8000b36a:	c0 71       	brne	8000b378 <__sfvwrite_r+0x124>
8000b36c:	6e 4b       	ld.w	r11,r7[0x10]
8000b36e:	0a 9c       	mov	r12,r5
8000b370:	ca ce       	rcall	8000b0c8 <_free_r>
8000b372:	30 c8       	mov	r8,12
8000b374:	8b 38       	st.w	r5[0xc],r8
8000b376:	cb 18       	rjmp	8000b4d8 <__sfvwrite_r+0x284>
8000b378:	40 0a       	lddsp	r10,sp[0x0]
8000b37a:	40 09       	lddsp	r9,sp[0x0]
8000b37c:	e8 0a 01 0a 	sub	r10,r4,r10
8000b380:	e4 09 00 08 	add	r8,r2,r9
8000b384:	8f 54       	st.w	r7[0x14],r4
8000b386:	8f 2a       	st.w	r7[0x8],r10
8000b388:	8f 08       	st.w	r7[0x0],r8
8000b38a:	8f 42       	st.w	r7[0x10],r2
8000b38c:	0c 94       	mov	r4,r6
8000b38e:	08 36       	cp.w	r6,r4
8000b390:	ec 04 17 30 	movlo	r4,r6
8000b394:	06 9b       	mov	r11,r3
8000b396:	08 9a       	mov	r10,r4
8000b398:	6e 0c       	ld.w	r12,r7[0x0]
8000b39a:	c3 ad       	rcall	8000b60e <memmove>
8000b39c:	6e 08       	ld.w	r8,r7[0x0]
8000b39e:	08 08       	add	r8,r4
8000b3a0:	8f 08       	st.w	r7[0x0],r8
8000b3a2:	6e 28       	ld.w	r8,r7[0x8]
8000b3a4:	08 18       	sub	r8,r4
8000b3a6:	0c 94       	mov	r4,r6
8000b3a8:	8f 28       	st.w	r7[0x8],r8
8000b3aa:	c2 e8       	rjmp	8000b406 <__sfvwrite_r+0x1b2>
8000b3ac:	08 36       	cp.w	r6,r4
8000b3ae:	5f ba       	srhi	r10
8000b3b0:	6e 0c       	ld.w	r12,r7[0x0]
8000b3b2:	6e 48       	ld.w	r8,r7[0x10]
8000b3b4:	10 3c       	cp.w	r12,r8
8000b3b6:	5f b8       	srhi	r8
8000b3b8:	f5 e8 00 08 	and	r8,r10,r8
8000b3bc:	f2 08 18 00 	cp.b	r8,r9
8000b3c0:	c0 d0       	breq	8000b3da <__sfvwrite_r+0x186>
8000b3c2:	06 9b       	mov	r11,r3
8000b3c4:	08 9a       	mov	r10,r4
8000b3c6:	c2 4d       	rcall	8000b60e <memmove>
8000b3c8:	6e 08       	ld.w	r8,r7[0x0]
8000b3ca:	08 08       	add	r8,r4
8000b3cc:	0e 9b       	mov	r11,r7
8000b3ce:	8f 08       	st.w	r7[0x0],r8
8000b3d0:	0a 9c       	mov	r12,r5
8000b3d2:	fe b0 fd 09 	rcall	8000ade4 <_fflush_r>
8000b3d6:	c1 80       	breq	8000b406 <__sfvwrite_r+0x1b2>
8000b3d8:	c8 08       	rjmp	8000b4d8 <__sfvwrite_r+0x284>
8000b3da:	6e 59       	ld.w	r9,r7[0x14]
8000b3dc:	12 36       	cp.w	r6,r9
8000b3de:	c0 a3       	brcs	8000b3f2 <__sfvwrite_r+0x19e>
8000b3e0:	6e a8       	ld.w	r8,r7[0x28]
8000b3e2:	06 9a       	mov	r10,r3
8000b3e4:	6e 8b       	ld.w	r11,r7[0x20]
8000b3e6:	0a 9c       	mov	r12,r5
8000b3e8:	5d 18       	icall	r8
8000b3ea:	18 94       	mov	r4,r12
8000b3ec:	e0 89 00 0d 	brgt	8000b406 <__sfvwrite_r+0x1b2>
8000b3f0:	c7 48       	rjmp	8000b4d8 <__sfvwrite_r+0x284>
8000b3f2:	0c 9a       	mov	r10,r6
8000b3f4:	06 9b       	mov	r11,r3
8000b3f6:	c0 cd       	rcall	8000b60e <memmove>
8000b3f8:	6e 08       	ld.w	r8,r7[0x0]
8000b3fa:	0c 08       	add	r8,r6
8000b3fc:	0c 94       	mov	r4,r6
8000b3fe:	8f 08       	st.w	r7[0x0],r8
8000b400:	6e 28       	ld.w	r8,r7[0x8]
8000b402:	0c 18       	sub	r8,r6
8000b404:	8f 28       	st.w	r7[0x8],r8
8000b406:	62 28       	ld.w	r8,r1[0x8]
8000b408:	08 18       	sub	r8,r4
8000b40a:	83 28       	st.w	r1[0x8],r8
8000b40c:	c6 b0       	breq	8000b4e2 <__sfvwrite_r+0x28e>
8000b40e:	08 16       	sub	r6,r4
8000b410:	08 03       	add	r3,r4
8000b412:	c7 1b       	rjmp	8000b2f4 <__sfvwrite_r+0xa0>
8000b414:	60 03       	ld.w	r3,r0[0x0]
8000b416:	60 11       	ld.w	r1,r0[0x4]
8000b418:	30 08       	mov	r8,0
8000b41a:	2f 80       	sub	r0,-8
8000b41c:	50 08       	stdsp	sp[0x0],r8
8000b41e:	58 01       	cp.w	r1,0
8000b420:	cf a0       	breq	8000b414 <__sfvwrite_r+0x1c0>
8000b422:	40 0a       	lddsp	r10,sp[0x0]
8000b424:	58 0a       	cp.w	r10,0
8000b426:	c1 41       	brne	8000b44e <__sfvwrite_r+0x1fa>
8000b428:	e2 c6 ff ff 	sub	r6,r1,-1
8000b42c:	02 9a       	mov	r10,r1
8000b42e:	30 ab       	mov	r11,10
8000b430:	06 9c       	mov	r12,r3
8000b432:	ce 3c       	rcall	8000b5f8 <memchr>
8000b434:	f8 c8 ff ff 	sub	r8,r12,-1
8000b438:	58 0c       	cp.w	r12,0
8000b43a:	f1 d3 e1 16 	subne	r6,r8,r3
8000b43e:	f9 b9 01 01 	movne	r9,1
8000b442:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b446:	f9 b8 00 01 	moveq	r8,1
8000b44a:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b44e:	02 36       	cp.w	r6,r1
8000b450:	ec 04 17 80 	movls	r4,r6
8000b454:	e2 04 17 b0 	movhi	r4,r1
8000b458:	6e 59       	ld.w	r9,r7[0x14]
8000b45a:	6e 25       	ld.w	r5,r7[0x8]
8000b45c:	f2 05 00 05 	add	r5,r9,r5
8000b460:	0a 34       	cp.w	r4,r5
8000b462:	5f 9a       	srgt	r10
8000b464:	6e 0c       	ld.w	r12,r7[0x0]
8000b466:	6e 48       	ld.w	r8,r7[0x10]
8000b468:	10 3c       	cp.w	r12,r8
8000b46a:	5f b8       	srhi	r8
8000b46c:	f5 e8 00 08 	and	r8,r10,r8
8000b470:	30 0a       	mov	r10,0
8000b472:	f4 08 18 00 	cp.b	r8,r10
8000b476:	c0 d0       	breq	8000b490 <__sfvwrite_r+0x23c>
8000b478:	06 9b       	mov	r11,r3
8000b47a:	0a 9a       	mov	r10,r5
8000b47c:	cc 9c       	rcall	8000b60e <memmove>
8000b47e:	6e 08       	ld.w	r8,r7[0x0]
8000b480:	0a 08       	add	r8,r5
8000b482:	0e 9b       	mov	r11,r7
8000b484:	8f 08       	st.w	r7[0x0],r8
8000b486:	40 1c       	lddsp	r12,sp[0x4]
8000b488:	fe b0 fc ae 	rcall	8000ade4 <_fflush_r>
8000b48c:	c1 70       	breq	8000b4ba <__sfvwrite_r+0x266>
8000b48e:	c2 58       	rjmp	8000b4d8 <__sfvwrite_r+0x284>
8000b490:	12 34       	cp.w	r4,r9
8000b492:	c0 a5       	brlt	8000b4a6 <__sfvwrite_r+0x252>
8000b494:	6e a8       	ld.w	r8,r7[0x28]
8000b496:	06 9a       	mov	r10,r3
8000b498:	6e 8b       	ld.w	r11,r7[0x20]
8000b49a:	40 1c       	lddsp	r12,sp[0x4]
8000b49c:	5d 18       	icall	r8
8000b49e:	18 95       	mov	r5,r12
8000b4a0:	e0 89 00 0d 	brgt	8000b4ba <__sfvwrite_r+0x266>
8000b4a4:	c1 a8       	rjmp	8000b4d8 <__sfvwrite_r+0x284>
8000b4a6:	08 9a       	mov	r10,r4
8000b4a8:	06 9b       	mov	r11,r3
8000b4aa:	cb 2c       	rcall	8000b60e <memmove>
8000b4ac:	6e 08       	ld.w	r8,r7[0x0]
8000b4ae:	08 08       	add	r8,r4
8000b4b0:	08 95       	mov	r5,r4
8000b4b2:	8f 08       	st.w	r7[0x0],r8
8000b4b4:	6e 28       	ld.w	r8,r7[0x8]
8000b4b6:	08 18       	sub	r8,r4
8000b4b8:	8f 28       	st.w	r7[0x8],r8
8000b4ba:	0a 16       	sub	r6,r5
8000b4bc:	c0 71       	brne	8000b4ca <__sfvwrite_r+0x276>
8000b4be:	0e 9b       	mov	r11,r7
8000b4c0:	40 1c       	lddsp	r12,sp[0x4]
8000b4c2:	fe b0 fc 91 	rcall	8000ade4 <_fflush_r>
8000b4c6:	c0 91       	brne	8000b4d8 <__sfvwrite_r+0x284>
8000b4c8:	50 06       	stdsp	sp[0x0],r6
8000b4ca:	64 28       	ld.w	r8,r2[0x8]
8000b4cc:	0a 18       	sub	r8,r5
8000b4ce:	85 28       	st.w	r2[0x8],r8
8000b4d0:	c0 90       	breq	8000b4e2 <__sfvwrite_r+0x28e>
8000b4d2:	0a 11       	sub	r1,r5
8000b4d4:	0a 03       	add	r3,r5
8000b4d6:	ca 4b       	rjmp	8000b41e <__sfvwrite_r+0x1ca>
8000b4d8:	8e 68       	ld.sh	r8,r7[0xc]
8000b4da:	a7 a8       	sbr	r8,0x6
8000b4dc:	ae 68       	st.h	r7[0xc],r8
8000b4de:	3f fc       	mov	r12,-1
8000b4e0:	c0 28       	rjmp	8000b4e4 <__sfvwrite_r+0x290>
8000b4e2:	30 0c       	mov	r12,0
8000b4e4:	2f dd       	sub	sp,-12
8000b4e6:	d8 32       	popm	r0-r7,pc

8000b4e8 <_fwalk>:
8000b4e8:	d4 31       	pushm	r0-r7,lr
8000b4ea:	30 05       	mov	r5,0
8000b4ec:	16 91       	mov	r1,r11
8000b4ee:	f8 c7 ff 28 	sub	r7,r12,-216
8000b4f2:	0a 92       	mov	r2,r5
8000b4f4:	fe b0 fc fe 	rcall	8000aef0 <__sfp_lock_acquire>
8000b4f8:	3f f3       	mov	r3,-1
8000b4fa:	c1 68       	rjmp	8000b526 <_fwalk+0x3e>
8000b4fc:	6e 26       	ld.w	r6,r7[0x8]
8000b4fe:	6e 14       	ld.w	r4,r7[0x4]
8000b500:	2f 46       	sub	r6,-12
8000b502:	c0 c8       	rjmp	8000b51a <_fwalk+0x32>
8000b504:	8c 08       	ld.sh	r8,r6[0x0]
8000b506:	e4 08 19 00 	cp.h	r8,r2
8000b50a:	c0 70       	breq	8000b518 <_fwalk+0x30>
8000b50c:	8c 18       	ld.sh	r8,r6[0x2]
8000b50e:	e6 08 19 00 	cp.h	r8,r3
8000b512:	c0 30       	breq	8000b518 <_fwalk+0x30>
8000b514:	5d 11       	icall	r1
8000b516:	18 45       	or	r5,r12
8000b518:	2a 46       	sub	r6,-92
8000b51a:	20 14       	sub	r4,1
8000b51c:	ec cc 00 0c 	sub	r12,r6,12
8000b520:	58 04       	cp.w	r4,0
8000b522:	cf 14       	brge	8000b504 <_fwalk+0x1c>
8000b524:	6e 07       	ld.w	r7,r7[0x0]
8000b526:	58 07       	cp.w	r7,0
8000b528:	ce a1       	brne	8000b4fc <_fwalk+0x14>
8000b52a:	fe b0 fc e4 	rcall	8000aef2 <__sfp_lock_release>
8000b52e:	0a 9c       	mov	r12,r5
8000b530:	d8 32       	popm	r0-r7,pc
8000b532:	d7 03       	nop

8000b534 <_localeconv_r>:
8000b534:	fe cc d3 cc 	sub	r12,pc,-11316
8000b538:	5e fc       	retal	r12
8000b53a:	d7 03       	nop

8000b53c <__smakebuf_r>:
8000b53c:	d4 21       	pushm	r4-r7,lr
8000b53e:	20 fd       	sub	sp,60
8000b540:	96 68       	ld.sh	r8,r11[0xc]
8000b542:	16 97       	mov	r7,r11
8000b544:	18 96       	mov	r6,r12
8000b546:	e2 18 00 02 	andl	r8,0x2,COH
8000b54a:	c3 d1       	brne	8000b5c4 <__smakebuf_r+0x88>
8000b54c:	96 7b       	ld.sh	r11,r11[0xe]
8000b54e:	f0 0b 19 00 	cp.h	r11,r8
8000b552:	c0 55       	brlt	8000b55c <__smakebuf_r+0x20>
8000b554:	1a 9a       	mov	r10,sp
8000b556:	e0 a0 04 81 	rcall	8000be58 <_fstat_r>
8000b55a:	c0 f4       	brge	8000b578 <__smakebuf_r+0x3c>
8000b55c:	8e 65       	ld.sh	r5,r7[0xc]
8000b55e:	0a 98       	mov	r8,r5
8000b560:	ab b8       	sbr	r8,0xb
8000b562:	e2 15 00 80 	andl	r5,0x80,COH
8000b566:	ae 68       	st.h	r7[0xc],r8
8000b568:	30 04       	mov	r4,0
8000b56a:	e0 68 04 00 	mov	r8,1024
8000b56e:	f9 b5 01 40 	movne	r5,64
8000b572:	f0 05 17 00 	moveq	r5,r8
8000b576:	c1 c8       	rjmp	8000b5ae <__smakebuf_r+0x72>
8000b578:	40 18       	lddsp	r8,sp[0x4]
8000b57a:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b57e:	e0 48 20 00 	cp.w	r8,8192
8000b582:	5f 04       	sreq	r4
8000b584:	e0 48 80 00 	cp.w	r8,32768
8000b588:	c0 e1       	brne	8000b5a4 <__smakebuf_r+0x68>
8000b58a:	6e b9       	ld.w	r9,r7[0x2c]
8000b58c:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b590:	10 39       	cp.w	r9,r8
8000b592:	c0 91       	brne	8000b5a4 <__smakebuf_r+0x68>
8000b594:	8e 68       	ld.sh	r8,r7[0xc]
8000b596:	e0 65 04 00 	mov	r5,1024
8000b59a:	ab a8       	sbr	r8,0xa
8000b59c:	ef 45 00 50 	st.w	r7[80],r5
8000b5a0:	ae 68       	st.h	r7[0xc],r8
8000b5a2:	c0 68       	rjmp	8000b5ae <__smakebuf_r+0x72>
8000b5a4:	8e 68       	ld.sh	r8,r7[0xc]
8000b5a6:	e0 65 04 00 	mov	r5,1024
8000b5aa:	ab b8       	sbr	r8,0xb
8000b5ac:	ae 68       	st.h	r7[0xc],r8
8000b5ae:	0a 9b       	mov	r11,r5
8000b5b0:	0c 9c       	mov	r12,r6
8000b5b2:	fe b0 df 35 	rcall	8000741c <_malloc_r>
8000b5b6:	8e 68       	ld.sh	r8,r7[0xc]
8000b5b8:	c0 d1       	brne	8000b5d2 <__smakebuf_r+0x96>
8000b5ba:	ed b8 00 09 	bld	r8,0x9
8000b5be:	c1 b0       	breq	8000b5f4 <__smakebuf_r+0xb8>
8000b5c0:	a1 b8       	sbr	r8,0x1
8000b5c2:	ae 68       	st.h	r7[0xc],r8
8000b5c4:	ee c8 ff b9 	sub	r8,r7,-71
8000b5c8:	8f 48       	st.w	r7[0x10],r8
8000b5ca:	8f 08       	st.w	r7[0x0],r8
8000b5cc:	30 18       	mov	r8,1
8000b5ce:	8f 58       	st.w	r7[0x14],r8
8000b5d0:	c1 28       	rjmp	8000b5f4 <__smakebuf_r+0xb8>
8000b5d2:	a7 b8       	sbr	r8,0x7
8000b5d4:	8f 4c       	st.w	r7[0x10],r12
8000b5d6:	ae 68       	st.h	r7[0xc],r8
8000b5d8:	8f 55       	st.w	r7[0x14],r5
8000b5da:	fe c8 06 e6 	sub	r8,pc,1766
8000b5de:	8f 0c       	st.w	r7[0x0],r12
8000b5e0:	8d a8       	st.w	r6[0x28],r8
8000b5e2:	58 04       	cp.w	r4,0
8000b5e4:	c0 80       	breq	8000b5f4 <__smakebuf_r+0xb8>
8000b5e6:	8e 7c       	ld.sh	r12,r7[0xe]
8000b5e8:	fe b0 e3 94 	rcall	80007d10 <isatty>
8000b5ec:	c0 40       	breq	8000b5f4 <__smakebuf_r+0xb8>
8000b5ee:	8e 68       	ld.sh	r8,r7[0xc]
8000b5f0:	a1 a8       	sbr	r8,0x0
8000b5f2:	ae 68       	st.h	r7[0xc],r8
8000b5f4:	2f 1d       	sub	sp,-60
8000b5f6:	d8 22       	popm	r4-r7,pc

8000b5f8 <memchr>:
8000b5f8:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b5fc:	c0 68       	rjmp	8000b608 <memchr+0x10>
8000b5fe:	20 1a       	sub	r10,1
8000b600:	19 88       	ld.ub	r8,r12[0x0]
8000b602:	16 38       	cp.w	r8,r11
8000b604:	5e 0c       	reteq	r12
8000b606:	2f fc       	sub	r12,-1
8000b608:	58 0a       	cp.w	r10,0
8000b60a:	cf a1       	brne	8000b5fe <memchr+0x6>
8000b60c:	5e fa       	retal	r10

8000b60e <memmove>:
8000b60e:	d4 01       	pushm	lr
8000b610:	18 3b       	cp.w	r11,r12
8000b612:	c1 92       	brcc	8000b644 <memmove+0x36>
8000b614:	f6 0a 00 09 	add	r9,r11,r10
8000b618:	12 3c       	cp.w	r12,r9
8000b61a:	c1 52       	brcc	8000b644 <memmove+0x36>
8000b61c:	f8 0a 00 0b 	add	r11,r12,r10
8000b620:	30 08       	mov	r8,0
8000b622:	c0 68       	rjmp	8000b62e <memmove+0x20>
8000b624:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b628:	20 1a       	sub	r10,1
8000b62a:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b62e:	20 18       	sub	r8,1
8000b630:	58 0a       	cp.w	r10,0
8000b632:	cf 91       	brne	8000b624 <memmove+0x16>
8000b634:	d8 02       	popm	pc
8000b636:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b63a:	20 1a       	sub	r10,1
8000b63c:	f8 08 0b 09 	st.b	r12[r8],r9
8000b640:	2f f8       	sub	r8,-1
8000b642:	c0 28       	rjmp	8000b646 <memmove+0x38>
8000b644:	30 08       	mov	r8,0
8000b646:	58 0a       	cp.w	r10,0
8000b648:	cf 71       	brne	8000b636 <memmove+0x28>
8000b64a:	d8 02       	popm	pc

8000b64c <__hi0bits>:
8000b64c:	18 98       	mov	r8,r12
8000b64e:	e0 1c 00 00 	andl	r12,0x0
8000b652:	f0 09 15 10 	lsl	r9,r8,0x10
8000b656:	58 0c       	cp.w	r12,0
8000b658:	f2 08 17 00 	moveq	r8,r9
8000b65c:	f9 bc 00 10 	moveq	r12,16
8000b660:	f9 bc 01 00 	movne	r12,0
8000b664:	10 9a       	mov	r10,r8
8000b666:	f0 09 15 08 	lsl	r9,r8,0x8
8000b66a:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b66e:	f7 bc 00 f8 	subeq	r12,-8
8000b672:	f2 08 17 00 	moveq	r8,r9
8000b676:	10 9a       	mov	r10,r8
8000b678:	f0 09 15 04 	lsl	r9,r8,0x4
8000b67c:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b680:	f7 bc 00 fc 	subeq	r12,-4
8000b684:	f2 08 17 00 	moveq	r8,r9
8000b688:	10 9a       	mov	r10,r8
8000b68a:	f0 09 15 02 	lsl	r9,r8,0x2
8000b68e:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b692:	f7 bc 00 fe 	subeq	r12,-2
8000b696:	f2 08 17 00 	moveq	r8,r9
8000b69a:	58 08       	cp.w	r8,0
8000b69c:	5e 5c       	retlt	r12
8000b69e:	ed b8 00 1e 	bld	r8,0x1e
8000b6a2:	f9 bc 01 20 	movne	r12,32
8000b6a6:	f7 bc 00 ff 	subeq	r12,-1
8000b6aa:	5e fc       	retal	r12

8000b6ac <__lo0bits>:
8000b6ac:	18 99       	mov	r9,r12
8000b6ae:	78 08       	ld.w	r8,r12[0x0]
8000b6b0:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b6b4:	c1 50       	breq	8000b6de <__lo0bits+0x32>
8000b6b6:	ed b8 00 00 	bld	r8,0x0
8000b6ba:	c0 21       	brne	8000b6be <__lo0bits+0x12>
8000b6bc:	5e fd       	retal	0
8000b6be:	10 9b       	mov	r11,r8
8000b6c0:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b6c4:	e2 1b 00 02 	andl	r11,0x2,COH
8000b6c8:	a3 88       	lsr	r8,0x2
8000b6ca:	58 0b       	cp.w	r11,0
8000b6cc:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b6d0:	f9 bc 01 01 	movne	r12,1
8000b6d4:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b6d8:	f9 bc 00 02 	moveq	r12,2
8000b6dc:	5e fc       	retal	r12
8000b6de:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b6e2:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b6e6:	58 0a       	cp.w	r10,0
8000b6e8:	f6 08 17 00 	moveq	r8,r11
8000b6ec:	f9 bc 00 10 	moveq	r12,16
8000b6f0:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b6f4:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b6f8:	58 0b       	cp.w	r11,0
8000b6fa:	f7 bc 00 f8 	subeq	r12,-8
8000b6fe:	f4 08 17 00 	moveq	r8,r10
8000b702:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b706:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b70a:	58 0b       	cp.w	r11,0
8000b70c:	f7 bc 00 fc 	subeq	r12,-4
8000b710:	f4 08 17 00 	moveq	r8,r10
8000b714:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b718:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b71c:	58 0b       	cp.w	r11,0
8000b71e:	f7 bc 00 fe 	subeq	r12,-2
8000b722:	f4 08 17 00 	moveq	r8,r10
8000b726:	ed b8 00 00 	bld	r8,0x0
8000b72a:	c0 60       	breq	8000b736 <__lo0bits+0x8a>
8000b72c:	a1 98       	lsr	r8,0x1
8000b72e:	c0 31       	brne	8000b734 <__lo0bits+0x88>
8000b730:	32 0c       	mov	r12,32
8000b732:	5e fc       	retal	r12
8000b734:	2f fc       	sub	r12,-1
8000b736:	93 08       	st.w	r9[0x0],r8
8000b738:	5e fc       	retal	r12

8000b73a <__mcmp>:
8000b73a:	d4 01       	pushm	lr
8000b73c:	18 98       	mov	r8,r12
8000b73e:	76 49       	ld.w	r9,r11[0x10]
8000b740:	78 4c       	ld.w	r12,r12[0x10]
8000b742:	12 1c       	sub	r12,r9
8000b744:	c1 31       	brne	8000b76a <__mcmp+0x30>
8000b746:	2f b9       	sub	r9,-5
8000b748:	a3 69       	lsl	r9,0x2
8000b74a:	12 0b       	add	r11,r9
8000b74c:	f0 09 00 09 	add	r9,r8,r9
8000b750:	2e c8       	sub	r8,-20
8000b752:	13 4e       	ld.w	lr,--r9
8000b754:	17 4a       	ld.w	r10,--r11
8000b756:	14 3e       	cp.w	lr,r10
8000b758:	c0 60       	breq	8000b764 <__mcmp+0x2a>
8000b75a:	f9 bc 03 ff 	movlo	r12,-1
8000b75e:	f9 bc 02 01 	movhs	r12,1
8000b762:	d8 02       	popm	pc
8000b764:	10 39       	cp.w	r9,r8
8000b766:	fe 9b ff f6 	brhi	8000b752 <__mcmp+0x18>
8000b76a:	d8 02       	popm	pc

8000b76c <_Bfree>:
8000b76c:	d4 21       	pushm	r4-r7,lr
8000b76e:	18 97       	mov	r7,r12
8000b770:	16 95       	mov	r5,r11
8000b772:	78 96       	ld.w	r6,r12[0x24]
8000b774:	58 06       	cp.w	r6,0
8000b776:	c0 91       	brne	8000b788 <_Bfree+0x1c>
8000b778:	31 0c       	mov	r12,16
8000b77a:	fe b0 de 49 	rcall	8000740c <malloc>
8000b77e:	99 36       	st.w	r12[0xc],r6
8000b780:	8f 9c       	st.w	r7[0x24],r12
8000b782:	99 16       	st.w	r12[0x4],r6
8000b784:	99 26       	st.w	r12[0x8],r6
8000b786:	99 06       	st.w	r12[0x0],r6
8000b788:	58 05       	cp.w	r5,0
8000b78a:	c0 90       	breq	8000b79c <_Bfree+0x30>
8000b78c:	6a 19       	ld.w	r9,r5[0x4]
8000b78e:	6e 98       	ld.w	r8,r7[0x24]
8000b790:	70 38       	ld.w	r8,r8[0xc]
8000b792:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b796:	8b 0a       	st.w	r5[0x0],r10
8000b798:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b79c:	d8 22       	popm	r4-r7,pc
8000b79e:	d7 03       	nop

8000b7a0 <_Balloc>:
8000b7a0:	d4 21       	pushm	r4-r7,lr
8000b7a2:	18 97       	mov	r7,r12
8000b7a4:	16 96       	mov	r6,r11
8000b7a6:	78 95       	ld.w	r5,r12[0x24]
8000b7a8:	58 05       	cp.w	r5,0
8000b7aa:	c0 91       	brne	8000b7bc <_Balloc+0x1c>
8000b7ac:	31 0c       	mov	r12,16
8000b7ae:	fe b0 de 2f 	rcall	8000740c <malloc>
8000b7b2:	99 35       	st.w	r12[0xc],r5
8000b7b4:	8f 9c       	st.w	r7[0x24],r12
8000b7b6:	99 15       	st.w	r12[0x4],r5
8000b7b8:	99 25       	st.w	r12[0x8],r5
8000b7ba:	99 05       	st.w	r12[0x0],r5
8000b7bc:	6e 95       	ld.w	r5,r7[0x24]
8000b7be:	6a 38       	ld.w	r8,r5[0xc]
8000b7c0:	58 08       	cp.w	r8,0
8000b7c2:	c0 b1       	brne	8000b7d8 <_Balloc+0x38>
8000b7c4:	31 0a       	mov	r10,16
8000b7c6:	30 4b       	mov	r11,4
8000b7c8:	0e 9c       	mov	r12,r7
8000b7ca:	e0 a0 02 a7 	rcall	8000bd18 <_calloc_r>
8000b7ce:	8b 3c       	st.w	r5[0xc],r12
8000b7d0:	6e 98       	ld.w	r8,r7[0x24]
8000b7d2:	70 3c       	ld.w	r12,r8[0xc]
8000b7d4:	58 0c       	cp.w	r12,0
8000b7d6:	c1 b0       	breq	8000b80c <_Balloc+0x6c>
8000b7d8:	6e 98       	ld.w	r8,r7[0x24]
8000b7da:	70 38       	ld.w	r8,r8[0xc]
8000b7dc:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b7e0:	70 0c       	ld.w	r12,r8[0x0]
8000b7e2:	58 0c       	cp.w	r12,0
8000b7e4:	c0 40       	breq	8000b7ec <_Balloc+0x4c>
8000b7e6:	78 09       	ld.w	r9,r12[0x0]
8000b7e8:	91 09       	st.w	r8[0x0],r9
8000b7ea:	c0 e8       	rjmp	8000b806 <_Balloc+0x66>
8000b7ec:	0e 9c       	mov	r12,r7
8000b7ee:	30 17       	mov	r7,1
8000b7f0:	0e 9b       	mov	r11,r7
8000b7f2:	ee 06 09 47 	lsl	r7,r7,r6
8000b7f6:	ee ca ff fb 	sub	r10,r7,-5
8000b7fa:	a3 6a       	lsl	r10,0x2
8000b7fc:	e0 a0 02 8e 	rcall	8000bd18 <_calloc_r>
8000b800:	c0 60       	breq	8000b80c <_Balloc+0x6c>
8000b802:	99 16       	st.w	r12[0x4],r6
8000b804:	99 27       	st.w	r12[0x8],r7
8000b806:	30 08       	mov	r8,0
8000b808:	99 38       	st.w	r12[0xc],r8
8000b80a:	99 48       	st.w	r12[0x10],r8
8000b80c:	d8 22       	popm	r4-r7,pc
8000b80e:	d7 03       	nop

8000b810 <__d2b>:
8000b810:	d4 31       	pushm	r0-r7,lr
8000b812:	20 2d       	sub	sp,8
8000b814:	16 93       	mov	r3,r11
8000b816:	12 96       	mov	r6,r9
8000b818:	10 95       	mov	r5,r8
8000b81a:	14 92       	mov	r2,r10
8000b81c:	30 1b       	mov	r11,1
8000b81e:	cc 1f       	rcall	8000b7a0 <_Balloc>
8000b820:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b824:	50 09       	stdsp	sp[0x0],r9
8000b826:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b82a:	b5 a9       	sbr	r9,0x14
8000b82c:	f0 01 16 14 	lsr	r1,r8,0x14
8000b830:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b834:	18 94       	mov	r4,r12
8000b836:	58 02       	cp.w	r2,0
8000b838:	c1 d0       	breq	8000b872 <__d2b+0x62>
8000b83a:	fa cc ff f8 	sub	r12,sp,-8
8000b83e:	18 d2       	st.w	--r12,r2
8000b840:	c3 6f       	rcall	8000b6ac <__lo0bits>
8000b842:	40 18       	lddsp	r8,sp[0x4]
8000b844:	c0 d0       	breq	8000b85e <__d2b+0x4e>
8000b846:	40 09       	lddsp	r9,sp[0x0]
8000b848:	f8 0a 11 20 	rsub	r10,r12,32
8000b84c:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b850:	f5 e8 10 08 	or	r8,r10,r8
8000b854:	89 58       	st.w	r4[0x14],r8
8000b856:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b85a:	50 09       	stdsp	sp[0x0],r9
8000b85c:	c0 28       	rjmp	8000b860 <__d2b+0x50>
8000b85e:	89 58       	st.w	r4[0x14],r8
8000b860:	40 08       	lddsp	r8,sp[0x0]
8000b862:	58 08       	cp.w	r8,0
8000b864:	f9 b3 01 02 	movne	r3,2
8000b868:	f9 b3 00 01 	moveq	r3,1
8000b86c:	89 68       	st.w	r4[0x18],r8
8000b86e:	89 43       	st.w	r4[0x10],r3
8000b870:	c0 88       	rjmp	8000b880 <__d2b+0x70>
8000b872:	1a 9c       	mov	r12,sp
8000b874:	c1 cf       	rcall	8000b6ac <__lo0bits>
8000b876:	30 13       	mov	r3,1
8000b878:	40 08       	lddsp	r8,sp[0x0]
8000b87a:	2e 0c       	sub	r12,-32
8000b87c:	89 43       	st.w	r4[0x10],r3
8000b87e:	89 58       	st.w	r4[0x14],r8
8000b880:	58 01       	cp.w	r1,0
8000b882:	c0 90       	breq	8000b894 <__d2b+0x84>
8000b884:	e2 c1 04 33 	sub	r1,r1,1075
8000b888:	18 01       	add	r1,r12
8000b88a:	8d 01       	st.w	r6[0x0],r1
8000b88c:	f8 0c 11 35 	rsub	r12,r12,53
8000b890:	8b 0c       	st.w	r5[0x0],r12
8000b892:	c0 c8       	rjmp	8000b8aa <__d2b+0x9a>
8000b894:	e6 c8 ff fc 	sub	r8,r3,-4
8000b898:	f8 cc 04 32 	sub	r12,r12,1074
8000b89c:	a5 73       	lsl	r3,0x5
8000b89e:	8d 0c       	st.w	r6[0x0],r12
8000b8a0:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b8a4:	cd 4e       	rcall	8000b64c <__hi0bits>
8000b8a6:	18 13       	sub	r3,r12
8000b8a8:	8b 03       	st.w	r5[0x0],r3
8000b8aa:	08 9c       	mov	r12,r4
8000b8ac:	2f ed       	sub	sp,-8
8000b8ae:	d8 32       	popm	r0-r7,pc

8000b8b0 <__mdiff>:
8000b8b0:	d4 31       	pushm	r0-r7,lr
8000b8b2:	74 48       	ld.w	r8,r10[0x10]
8000b8b4:	76 45       	ld.w	r5,r11[0x10]
8000b8b6:	16 97       	mov	r7,r11
8000b8b8:	14 96       	mov	r6,r10
8000b8ba:	10 15       	sub	r5,r8
8000b8bc:	c1 31       	brne	8000b8e2 <__mdiff+0x32>
8000b8be:	2f b8       	sub	r8,-5
8000b8c0:	ee ce ff ec 	sub	lr,r7,-20
8000b8c4:	a3 68       	lsl	r8,0x2
8000b8c6:	f4 08 00 0b 	add	r11,r10,r8
8000b8ca:	ee 08 00 08 	add	r8,r7,r8
8000b8ce:	11 4a       	ld.w	r10,--r8
8000b8d0:	17 49       	ld.w	r9,--r11
8000b8d2:	12 3a       	cp.w	r10,r9
8000b8d4:	c0 30       	breq	8000b8da <__mdiff+0x2a>
8000b8d6:	c0 e2       	brcc	8000b8f2 <__mdiff+0x42>
8000b8d8:	c0 78       	rjmp	8000b8e6 <__mdiff+0x36>
8000b8da:	1c 38       	cp.w	r8,lr
8000b8dc:	fe 9b ff f9 	brhi	8000b8ce <__mdiff+0x1e>
8000b8e0:	c4 98       	rjmp	8000b972 <__mdiff+0xc2>
8000b8e2:	58 05       	cp.w	r5,0
8000b8e4:	c0 64       	brge	8000b8f0 <__mdiff+0x40>
8000b8e6:	0e 98       	mov	r8,r7
8000b8e8:	30 15       	mov	r5,1
8000b8ea:	0c 97       	mov	r7,r6
8000b8ec:	10 96       	mov	r6,r8
8000b8ee:	c0 28       	rjmp	8000b8f2 <__mdiff+0x42>
8000b8f0:	30 05       	mov	r5,0
8000b8f2:	6e 1b       	ld.w	r11,r7[0x4]
8000b8f4:	c5 6f       	rcall	8000b7a0 <_Balloc>
8000b8f6:	6e 49       	ld.w	r9,r7[0x10]
8000b8f8:	6c 44       	ld.w	r4,r6[0x10]
8000b8fa:	99 35       	st.w	r12[0xc],r5
8000b8fc:	2f b4       	sub	r4,-5
8000b8fe:	f2 c5 ff fb 	sub	r5,r9,-5
8000b902:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b906:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b90a:	2e c6       	sub	r6,-20
8000b90c:	2e c7       	sub	r7,-20
8000b90e:	f8 c8 ff ec 	sub	r8,r12,-20
8000b912:	30 0a       	mov	r10,0
8000b914:	0f 0e       	ld.w	lr,r7++
8000b916:	0d 0b       	ld.w	r11,r6++
8000b918:	fc 02 16 10 	lsr	r2,lr,0x10
8000b91c:	f6 03 16 10 	lsr	r3,r11,0x10
8000b920:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b924:	e4 03 01 03 	sub	r3,r2,r3
8000b928:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b92c:	fc 0b 01 0b 	sub	r11,lr,r11
8000b930:	f6 0a 00 0a 	add	r10,r11,r10
8000b934:	b0 1a       	st.h	r8[0x2],r10
8000b936:	b1 4a       	asr	r10,0x10
8000b938:	e6 0a 00 0a 	add	r10,r3,r10
8000b93c:	b0 0a       	st.h	r8[0x0],r10
8000b93e:	2f c8       	sub	r8,-4
8000b940:	b1 4a       	asr	r10,0x10
8000b942:	08 36       	cp.w	r6,r4
8000b944:	ce 83       	brcs	8000b914 <__mdiff+0x64>
8000b946:	c0 d8       	rjmp	8000b960 <__mdiff+0xb0>
8000b948:	0f 0b       	ld.w	r11,r7++
8000b94a:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b94e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b952:	16 0a       	add	r10,r11
8000b954:	b0 1a       	st.h	r8[0x2],r10
8000b956:	b1 4a       	asr	r10,0x10
8000b958:	1c 0a       	add	r10,lr
8000b95a:	b0 0a       	st.h	r8[0x0],r10
8000b95c:	2f c8       	sub	r8,-4
8000b95e:	b1 4a       	asr	r10,0x10
8000b960:	0a 37       	cp.w	r7,r5
8000b962:	cf 33       	brcs	8000b948 <__mdiff+0x98>
8000b964:	c0 28       	rjmp	8000b968 <__mdiff+0xb8>
8000b966:	20 19       	sub	r9,1
8000b968:	11 4a       	ld.w	r10,--r8
8000b96a:	58 0a       	cp.w	r10,0
8000b96c:	cf d0       	breq	8000b966 <__mdiff+0xb6>
8000b96e:	99 49       	st.w	r12[0x10],r9
8000b970:	d8 32       	popm	r0-r7,pc
8000b972:	30 0b       	mov	r11,0
8000b974:	c1 6f       	rcall	8000b7a0 <_Balloc>
8000b976:	30 18       	mov	r8,1
8000b978:	99 48       	st.w	r12[0x10],r8
8000b97a:	30 08       	mov	r8,0
8000b97c:	99 58       	st.w	r12[0x14],r8
8000b97e:	d8 32       	popm	r0-r7,pc

8000b980 <__lshift>:
8000b980:	d4 31       	pushm	r0-r7,lr
8000b982:	16 97       	mov	r7,r11
8000b984:	76 46       	ld.w	r6,r11[0x10]
8000b986:	f4 02 14 05 	asr	r2,r10,0x5
8000b98a:	2f f6       	sub	r6,-1
8000b98c:	14 93       	mov	r3,r10
8000b98e:	18 94       	mov	r4,r12
8000b990:	04 06       	add	r6,r2
8000b992:	76 1b       	ld.w	r11,r11[0x4]
8000b994:	6e 28       	ld.w	r8,r7[0x8]
8000b996:	c0 38       	rjmp	8000b99c <__lshift+0x1c>
8000b998:	2f fb       	sub	r11,-1
8000b99a:	a1 78       	lsl	r8,0x1
8000b99c:	10 36       	cp.w	r6,r8
8000b99e:	fe 99 ff fd 	brgt	8000b998 <__lshift+0x18>
8000b9a2:	08 9c       	mov	r12,r4
8000b9a4:	cf ee       	rcall	8000b7a0 <_Balloc>
8000b9a6:	30 09       	mov	r9,0
8000b9a8:	18 95       	mov	r5,r12
8000b9aa:	f8 c8 ff ec 	sub	r8,r12,-20
8000b9ae:	12 9a       	mov	r10,r9
8000b9b0:	c0 38       	rjmp	8000b9b6 <__lshift+0x36>
8000b9b2:	10 aa       	st.w	r8++,r10
8000b9b4:	2f f9       	sub	r9,-1
8000b9b6:	04 39       	cp.w	r9,r2
8000b9b8:	cf d5       	brlt	8000b9b2 <__lshift+0x32>
8000b9ba:	6e 4b       	ld.w	r11,r7[0x10]
8000b9bc:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b9c0:	2f bb       	sub	r11,-5
8000b9c2:	ee c9 ff ec 	sub	r9,r7,-20
8000b9c6:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b9ca:	58 03       	cp.w	r3,0
8000b9cc:	c1 30       	breq	8000b9f2 <__lshift+0x72>
8000b9ce:	e6 0c 11 20 	rsub	r12,r3,32
8000b9d2:	30 0a       	mov	r10,0
8000b9d4:	72 02       	ld.w	r2,r9[0x0]
8000b9d6:	e4 03 09 42 	lsl	r2,r2,r3
8000b9da:	04 4a       	or	r10,r2
8000b9dc:	10 aa       	st.w	r8++,r10
8000b9de:	13 0a       	ld.w	r10,r9++
8000b9e0:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b9e4:	16 39       	cp.w	r9,r11
8000b9e6:	cf 73       	brcs	8000b9d4 <__lshift+0x54>
8000b9e8:	91 0a       	st.w	r8[0x0],r10
8000b9ea:	58 0a       	cp.w	r10,0
8000b9ec:	c0 70       	breq	8000b9fa <__lshift+0x7a>
8000b9ee:	2f f6       	sub	r6,-1
8000b9f0:	c0 58       	rjmp	8000b9fa <__lshift+0x7a>
8000b9f2:	13 0a       	ld.w	r10,r9++
8000b9f4:	10 aa       	st.w	r8++,r10
8000b9f6:	16 39       	cp.w	r9,r11
8000b9f8:	cf d3       	brcs	8000b9f2 <__lshift+0x72>
8000b9fa:	08 9c       	mov	r12,r4
8000b9fc:	20 16       	sub	r6,1
8000b9fe:	0e 9b       	mov	r11,r7
8000ba00:	8b 46       	st.w	r5[0x10],r6
8000ba02:	cb 5e       	rcall	8000b76c <_Bfree>
8000ba04:	0a 9c       	mov	r12,r5
8000ba06:	d8 32       	popm	r0-r7,pc

8000ba08 <__multiply>:
8000ba08:	d4 31       	pushm	r0-r7,lr
8000ba0a:	20 2d       	sub	sp,8
8000ba0c:	76 49       	ld.w	r9,r11[0x10]
8000ba0e:	74 48       	ld.w	r8,r10[0x10]
8000ba10:	16 96       	mov	r6,r11
8000ba12:	14 95       	mov	r5,r10
8000ba14:	10 39       	cp.w	r9,r8
8000ba16:	ec 08 17 50 	movlt	r8,r6
8000ba1a:	ea 06 17 50 	movlt	r6,r5
8000ba1e:	f0 05 17 50 	movlt	r5,r8
8000ba22:	6c 28       	ld.w	r8,r6[0x8]
8000ba24:	76 43       	ld.w	r3,r11[0x10]
8000ba26:	74 42       	ld.w	r2,r10[0x10]
8000ba28:	76 1b       	ld.w	r11,r11[0x4]
8000ba2a:	e4 03 00 07 	add	r7,r2,r3
8000ba2e:	10 37       	cp.w	r7,r8
8000ba30:	f7 bb 09 ff 	subgt	r11,-1
8000ba34:	cb 6e       	rcall	8000b7a0 <_Balloc>
8000ba36:	ee c4 ff fb 	sub	r4,r7,-5
8000ba3a:	f8 c9 ff ec 	sub	r9,r12,-20
8000ba3e:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000ba42:	30 0a       	mov	r10,0
8000ba44:	12 98       	mov	r8,r9
8000ba46:	c0 28       	rjmp	8000ba4a <__multiply+0x42>
8000ba48:	10 aa       	st.w	r8++,r10
8000ba4a:	08 38       	cp.w	r8,r4
8000ba4c:	cf e3       	brcs	8000ba48 <__multiply+0x40>
8000ba4e:	2f b3       	sub	r3,-5
8000ba50:	2f b2       	sub	r2,-5
8000ba52:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000ba56:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000ba5a:	ec cb ff ec 	sub	r11,r6,-20
8000ba5e:	50 12       	stdsp	sp[0x4],r2
8000ba60:	ea ca ff ec 	sub	r10,r5,-20
8000ba64:	c4 48       	rjmp	8000baec <__multiply+0xe4>
8000ba66:	94 95       	ld.uh	r5,r10[0x2]
8000ba68:	58 05       	cp.w	r5,0
8000ba6a:	c2 00       	breq	8000baaa <__multiply+0xa2>
8000ba6c:	12 98       	mov	r8,r9
8000ba6e:	16 96       	mov	r6,r11
8000ba70:	30 0e       	mov	lr,0
8000ba72:	50 09       	stdsp	sp[0x0],r9
8000ba74:	0d 02       	ld.w	r2,r6++
8000ba76:	e4 00 16 10 	lsr	r0,r2,0x10
8000ba7a:	70 01       	ld.w	r1,r8[0x0]
8000ba7c:	70 09       	ld.w	r9,r8[0x0]
8000ba7e:	b1 81       	lsr	r1,0x10
8000ba80:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000ba84:	e0 05 03 41 	mac	r1,r0,r5
8000ba88:	ab 32       	mul	r2,r5
8000ba8a:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000ba8e:	00 02       	add	r2,r0
8000ba90:	e4 0e 00 0e 	add	lr,r2,lr
8000ba94:	b0 1e       	st.h	r8[0x2],lr
8000ba96:	b1 8e       	lsr	lr,0x10
8000ba98:	1c 01       	add	r1,lr
8000ba9a:	b0 01       	st.h	r8[0x0],r1
8000ba9c:	e2 0e 16 10 	lsr	lr,r1,0x10
8000baa0:	2f c8       	sub	r8,-4
8000baa2:	06 36       	cp.w	r6,r3
8000baa4:	ce 83       	brcs	8000ba74 <__multiply+0x6c>
8000baa6:	40 09       	lddsp	r9,sp[0x0]
8000baa8:	91 0e       	st.w	r8[0x0],lr
8000baaa:	94 86       	ld.uh	r6,r10[0x0]
8000baac:	58 06       	cp.w	r6,0
8000baae:	c1 d0       	breq	8000bae8 <__multiply+0xe0>
8000bab0:	72 02       	ld.w	r2,r9[0x0]
8000bab2:	12 98       	mov	r8,r9
8000bab4:	16 9e       	mov	lr,r11
8000bab6:	30 05       	mov	r5,0
8000bab8:	b0 12       	st.h	r8[0x2],r2
8000baba:	1d 01       	ld.w	r1,lr++
8000babc:	90 82       	ld.uh	r2,r8[0x0]
8000babe:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000bac2:	ad 30       	mul	r0,r6
8000bac4:	e0 02 00 02 	add	r2,r0,r2
8000bac8:	e4 05 00 05 	add	r5,r2,r5
8000bacc:	b0 05       	st.h	r8[0x0],r5
8000bace:	b1 85       	lsr	r5,0x10
8000bad0:	b1 81       	lsr	r1,0x10
8000bad2:	2f c8       	sub	r8,-4
8000bad4:	ad 31       	mul	r1,r6
8000bad6:	90 92       	ld.uh	r2,r8[0x2]
8000bad8:	e2 02 00 02 	add	r2,r1,r2
8000badc:	0a 02       	add	r2,r5
8000bade:	e4 05 16 10 	lsr	r5,r2,0x10
8000bae2:	06 3e       	cp.w	lr,r3
8000bae4:	ce a3       	brcs	8000bab8 <__multiply+0xb0>
8000bae6:	91 02       	st.w	r8[0x0],r2
8000bae8:	2f ca       	sub	r10,-4
8000baea:	2f c9       	sub	r9,-4
8000baec:	40 18       	lddsp	r8,sp[0x4]
8000baee:	10 3a       	cp.w	r10,r8
8000baf0:	cb b3       	brcs	8000ba66 <__multiply+0x5e>
8000baf2:	c0 28       	rjmp	8000baf6 <__multiply+0xee>
8000baf4:	20 17       	sub	r7,1
8000baf6:	58 07       	cp.w	r7,0
8000baf8:	e0 8a 00 05 	brle	8000bb02 <__multiply+0xfa>
8000bafc:	09 48       	ld.w	r8,--r4
8000bafe:	58 08       	cp.w	r8,0
8000bb00:	cf a0       	breq	8000baf4 <__multiply+0xec>
8000bb02:	99 47       	st.w	r12[0x10],r7
8000bb04:	2f ed       	sub	sp,-8
8000bb06:	d8 32       	popm	r0-r7,pc

8000bb08 <__i2b>:
8000bb08:	d4 21       	pushm	r4-r7,lr
8000bb0a:	16 97       	mov	r7,r11
8000bb0c:	30 1b       	mov	r11,1
8000bb0e:	c4 9e       	rcall	8000b7a0 <_Balloc>
8000bb10:	30 19       	mov	r9,1
8000bb12:	99 57       	st.w	r12[0x14],r7
8000bb14:	99 49       	st.w	r12[0x10],r9
8000bb16:	d8 22       	popm	r4-r7,pc

8000bb18 <__multadd>:
8000bb18:	d4 31       	pushm	r0-r7,lr
8000bb1a:	30 08       	mov	r8,0
8000bb1c:	12 95       	mov	r5,r9
8000bb1e:	16 97       	mov	r7,r11
8000bb20:	18 96       	mov	r6,r12
8000bb22:	76 44       	ld.w	r4,r11[0x10]
8000bb24:	f6 c9 ff ec 	sub	r9,r11,-20
8000bb28:	72 0b       	ld.w	r11,r9[0x0]
8000bb2a:	f6 0c 16 10 	lsr	r12,r11,0x10
8000bb2e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000bb32:	f4 0c 02 4c 	mul	r12,r10,r12
8000bb36:	f4 0b 03 45 	mac	r5,r10,r11
8000bb3a:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000bb3e:	b1 85       	lsr	r5,0x10
8000bb40:	18 05       	add	r5,r12
8000bb42:	ea 0c 15 10 	lsl	r12,r5,0x10
8000bb46:	f8 0b 00 0b 	add	r11,r12,r11
8000bb4a:	12 ab       	st.w	r9++,r11
8000bb4c:	2f f8       	sub	r8,-1
8000bb4e:	b1 85       	lsr	r5,0x10
8000bb50:	08 38       	cp.w	r8,r4
8000bb52:	ce b5       	brlt	8000bb28 <__multadd+0x10>
8000bb54:	58 05       	cp.w	r5,0
8000bb56:	c1 c0       	breq	8000bb8e <__multadd+0x76>
8000bb58:	6e 28       	ld.w	r8,r7[0x8]
8000bb5a:	10 34       	cp.w	r4,r8
8000bb5c:	c1 35       	brlt	8000bb82 <__multadd+0x6a>
8000bb5e:	6e 1b       	ld.w	r11,r7[0x4]
8000bb60:	0c 9c       	mov	r12,r6
8000bb62:	2f fb       	sub	r11,-1
8000bb64:	c1 ee       	rcall	8000b7a0 <_Balloc>
8000bb66:	6e 4a       	ld.w	r10,r7[0x10]
8000bb68:	ee cb ff f4 	sub	r11,r7,-12
8000bb6c:	18 93       	mov	r3,r12
8000bb6e:	2f ea       	sub	r10,-2
8000bb70:	2f 4c       	sub	r12,-12
8000bb72:	a3 6a       	lsl	r10,0x2
8000bb74:	fe b0 de 70 	rcall	80007854 <memcpy>
8000bb78:	0e 9b       	mov	r11,r7
8000bb7a:	0c 9c       	mov	r12,r6
8000bb7c:	fe b0 fd f8 	rcall	8000b76c <_Bfree>
8000bb80:	06 97       	mov	r7,r3
8000bb82:	e8 c8 ff ff 	sub	r8,r4,-1
8000bb86:	2f b4       	sub	r4,-5
8000bb88:	8f 48       	st.w	r7[0x10],r8
8000bb8a:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000bb8e:	0e 9c       	mov	r12,r7
8000bb90:	d8 32       	popm	r0-r7,pc
8000bb92:	d7 03       	nop

8000bb94 <__pow5mult>:
8000bb94:	d4 31       	pushm	r0-r7,lr
8000bb96:	14 96       	mov	r6,r10
8000bb98:	18 97       	mov	r7,r12
8000bb9a:	16 94       	mov	r4,r11
8000bb9c:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000bba0:	c0 90       	breq	8000bbb2 <__pow5mult+0x1e>
8000bba2:	20 18       	sub	r8,1
8000bba4:	fe c9 da 00 	sub	r9,pc,-9728
8000bba8:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000bbac:	30 09       	mov	r9,0
8000bbae:	cb 5f       	rcall	8000bb18 <__multadd>
8000bbb0:	18 94       	mov	r4,r12
8000bbb2:	a3 46       	asr	r6,0x2
8000bbb4:	c3 40       	breq	8000bc1c <__pow5mult+0x88>
8000bbb6:	6e 95       	ld.w	r5,r7[0x24]
8000bbb8:	58 05       	cp.w	r5,0
8000bbba:	c0 91       	brne	8000bbcc <__pow5mult+0x38>
8000bbbc:	31 0c       	mov	r12,16
8000bbbe:	fe b0 dc 27 	rcall	8000740c <malloc>
8000bbc2:	99 35       	st.w	r12[0xc],r5
8000bbc4:	8f 9c       	st.w	r7[0x24],r12
8000bbc6:	99 15       	st.w	r12[0x4],r5
8000bbc8:	99 25       	st.w	r12[0x8],r5
8000bbca:	99 05       	st.w	r12[0x0],r5
8000bbcc:	6e 93       	ld.w	r3,r7[0x24]
8000bbce:	66 25       	ld.w	r5,r3[0x8]
8000bbd0:	58 05       	cp.w	r5,0
8000bbd2:	c0 c1       	brne	8000bbea <__pow5mult+0x56>
8000bbd4:	e0 6b 02 71 	mov	r11,625
8000bbd8:	0e 9c       	mov	r12,r7
8000bbda:	c9 7f       	rcall	8000bb08 <__i2b>
8000bbdc:	87 2c       	st.w	r3[0x8],r12
8000bbde:	30 08       	mov	r8,0
8000bbe0:	18 95       	mov	r5,r12
8000bbe2:	99 08       	st.w	r12[0x0],r8
8000bbe4:	c0 38       	rjmp	8000bbea <__pow5mult+0x56>
8000bbe6:	06 9c       	mov	r12,r3
8000bbe8:	18 95       	mov	r5,r12
8000bbea:	ed b6 00 00 	bld	r6,0x0
8000bbee:	c0 b1       	brne	8000bc04 <__pow5mult+0x70>
8000bbf0:	08 9b       	mov	r11,r4
8000bbf2:	0a 9a       	mov	r10,r5
8000bbf4:	0e 9c       	mov	r12,r7
8000bbf6:	c0 9f       	rcall	8000ba08 <__multiply>
8000bbf8:	08 9b       	mov	r11,r4
8000bbfa:	18 93       	mov	r3,r12
8000bbfc:	0e 9c       	mov	r12,r7
8000bbfe:	06 94       	mov	r4,r3
8000bc00:	fe b0 fd b6 	rcall	8000b76c <_Bfree>
8000bc04:	a1 56       	asr	r6,0x1
8000bc06:	c0 b0       	breq	8000bc1c <__pow5mult+0x88>
8000bc08:	6a 03       	ld.w	r3,r5[0x0]
8000bc0a:	58 03       	cp.w	r3,0
8000bc0c:	ce d1       	brne	8000bbe6 <__pow5mult+0x52>
8000bc0e:	0a 9a       	mov	r10,r5
8000bc10:	0a 9b       	mov	r11,r5
8000bc12:	0e 9c       	mov	r12,r7
8000bc14:	cf ae       	rcall	8000ba08 <__multiply>
8000bc16:	8b 0c       	st.w	r5[0x0],r12
8000bc18:	99 03       	st.w	r12[0x0],r3
8000bc1a:	ce 7b       	rjmp	8000bbe8 <__pow5mult+0x54>
8000bc1c:	08 9c       	mov	r12,r4
8000bc1e:	d8 32       	popm	r0-r7,pc

8000bc20 <__isinfd>:
8000bc20:	14 98       	mov	r8,r10
8000bc22:	fc 19 7f f0 	movh	r9,0x7ff0
8000bc26:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bc2a:	f0 0b 11 00 	rsub	r11,r8,0
8000bc2e:	f7 e8 10 08 	or	r8,r11,r8
8000bc32:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000bc36:	f2 08 01 08 	sub	r8,r9,r8
8000bc3a:	f0 0c 11 00 	rsub	r12,r8,0
8000bc3e:	f9 e8 10 08 	or	r8,r12,r8
8000bc42:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000bc46:	2f fc       	sub	r12,-1
8000bc48:	5e fc       	retal	r12

8000bc4a <__isnand>:
8000bc4a:	14 98       	mov	r8,r10
8000bc4c:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bc50:	f0 0c 11 00 	rsub	r12,r8,0
8000bc54:	10 4c       	or	r12,r8
8000bc56:	fc 18 7f f0 	movh	r8,0x7ff0
8000bc5a:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000bc5e:	f0 0c 01 0c 	sub	r12,r8,r12
8000bc62:	bf 9c       	lsr	r12,0x1f
8000bc64:	5e fc       	retal	r12
8000bc66:	d7 03       	nop

8000bc68 <__sclose>:
8000bc68:	d4 01       	pushm	lr
8000bc6a:	96 7b       	ld.sh	r11,r11[0xe]
8000bc6c:	c8 2c       	rcall	8000bd70 <_close_r>
8000bc6e:	d8 02       	popm	pc

8000bc70 <__sseek>:
8000bc70:	d4 21       	pushm	r4-r7,lr
8000bc72:	16 97       	mov	r7,r11
8000bc74:	96 7b       	ld.sh	r11,r11[0xe]
8000bc76:	c0 3d       	rcall	8000be7c <_lseek_r>
8000bc78:	8e 68       	ld.sh	r8,r7[0xc]
8000bc7a:	10 99       	mov	r9,r8
8000bc7c:	ad c8       	cbr	r8,0xc
8000bc7e:	ad a9       	sbr	r9,0xc
8000bc80:	5b fc       	cp.w	r12,-1
8000bc82:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000bc86:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000bc8a:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000bc8e:	d8 22       	popm	r4-r7,pc

8000bc90 <__swrite>:
8000bc90:	d4 21       	pushm	r4-r7,lr
8000bc92:	96 68       	ld.sh	r8,r11[0xc]
8000bc94:	16 97       	mov	r7,r11
8000bc96:	14 95       	mov	r5,r10
8000bc98:	12 94       	mov	r4,r9
8000bc9a:	e2 18 01 00 	andl	r8,0x100,COH
8000bc9e:	18 96       	mov	r6,r12
8000bca0:	c0 50       	breq	8000bcaa <__swrite+0x1a>
8000bca2:	30 29       	mov	r9,2
8000bca4:	30 0a       	mov	r10,0
8000bca6:	96 7b       	ld.sh	r11,r11[0xe]
8000bca8:	ce ac       	rcall	8000be7c <_lseek_r>
8000bcaa:	8e 68       	ld.sh	r8,r7[0xc]
8000bcac:	ad c8       	cbr	r8,0xc
8000bcae:	08 99       	mov	r9,r4
8000bcb0:	0a 9a       	mov	r10,r5
8000bcb2:	8e 7b       	ld.sh	r11,r7[0xe]
8000bcb4:	0c 9c       	mov	r12,r6
8000bcb6:	ae 68       	st.h	r7[0xc],r8
8000bcb8:	c1 cc       	rcall	8000bcf0 <_write_r>
8000bcba:	d8 22       	popm	r4-r7,pc

8000bcbc <__sread>:
8000bcbc:	d4 21       	pushm	r4-r7,lr
8000bcbe:	16 97       	mov	r7,r11
8000bcc0:	96 7b       	ld.sh	r11,r11[0xe]
8000bcc2:	cf 1c       	rcall	8000bea4 <_read_r>
8000bcc4:	c0 65       	brlt	8000bcd0 <__sread+0x14>
8000bcc6:	6f 58       	ld.w	r8,r7[0x54]
8000bcc8:	18 08       	add	r8,r12
8000bcca:	ef 48 00 54 	st.w	r7[84],r8
8000bcce:	d8 22       	popm	r4-r7,pc
8000bcd0:	8e 68       	ld.sh	r8,r7[0xc]
8000bcd2:	ad c8       	cbr	r8,0xc
8000bcd4:	ae 68       	st.h	r7[0xc],r8
8000bcd6:	d8 22       	popm	r4-r7,pc

8000bcd8 <strlen>:
8000bcd8:	30 09       	mov	r9,0
8000bcda:	18 98       	mov	r8,r12
8000bcdc:	c0 28       	rjmp	8000bce0 <strlen+0x8>
8000bcde:	2f f8       	sub	r8,-1
8000bce0:	11 8a       	ld.ub	r10,r8[0x0]
8000bce2:	f2 0a 18 00 	cp.b	r10,r9
8000bce6:	cf c1       	brne	8000bcde <strlen+0x6>
8000bce8:	f0 0c 01 0c 	sub	r12,r8,r12
8000bcec:	5e fc       	retal	r12
8000bcee:	d7 03       	nop

8000bcf0 <_write_r>:
8000bcf0:	d4 21       	pushm	r4-r7,lr
8000bcf2:	16 98       	mov	r8,r11
8000bcf4:	18 97       	mov	r7,r12
8000bcf6:	10 9c       	mov	r12,r8
8000bcf8:	30 08       	mov	r8,0
8000bcfa:	14 9b       	mov	r11,r10
8000bcfc:	e0 66 53 bc 	mov	r6,21436
8000bd00:	12 9a       	mov	r10,r9
8000bd02:	8d 08       	st.w	r6[0x0],r8
8000bd04:	fe b0 d1 6e 	rcall	80005fe0 <_write>
8000bd08:	5b fc       	cp.w	r12,-1
8000bd0a:	c0 51       	brne	8000bd14 <_write_r+0x24>
8000bd0c:	6c 08       	ld.w	r8,r6[0x0]
8000bd0e:	58 08       	cp.w	r8,0
8000bd10:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bd14:	d8 22       	popm	r4-r7,pc
8000bd16:	d7 03       	nop

8000bd18 <_calloc_r>:
8000bd18:	d4 21       	pushm	r4-r7,lr
8000bd1a:	f4 0b 02 4b 	mul	r11,r10,r11
8000bd1e:	fe b0 db 7f 	rcall	8000741c <_malloc_r>
8000bd22:	18 97       	mov	r7,r12
8000bd24:	c2 30       	breq	8000bd6a <_calloc_r+0x52>
8000bd26:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000bd2a:	e0 1a ff fc 	andl	r10,0xfffc
8000bd2e:	20 4a       	sub	r10,4
8000bd30:	e0 4a 00 24 	cp.w	r10,36
8000bd34:	e0 8b 00 18 	brhi	8000bd64 <_calloc_r+0x4c>
8000bd38:	18 98       	mov	r8,r12
8000bd3a:	59 3a       	cp.w	r10,19
8000bd3c:	e0 88 00 0f 	brls	8000bd5a <_calloc_r+0x42>
8000bd40:	30 09       	mov	r9,0
8000bd42:	10 a9       	st.w	r8++,r9
8000bd44:	10 a9       	st.w	r8++,r9
8000bd46:	59 ba       	cp.w	r10,27
8000bd48:	e0 88 00 09 	brls	8000bd5a <_calloc_r+0x42>
8000bd4c:	10 a9       	st.w	r8++,r9
8000bd4e:	10 a9       	st.w	r8++,r9
8000bd50:	e0 4a 00 24 	cp.w	r10,36
8000bd54:	c0 31       	brne	8000bd5a <_calloc_r+0x42>
8000bd56:	10 a9       	st.w	r8++,r9
8000bd58:	10 a9       	st.w	r8++,r9
8000bd5a:	30 09       	mov	r9,0
8000bd5c:	10 a9       	st.w	r8++,r9
8000bd5e:	91 19       	st.w	r8[0x4],r9
8000bd60:	91 09       	st.w	r8[0x0],r9
8000bd62:	c0 48       	rjmp	8000bd6a <_calloc_r+0x52>
8000bd64:	30 0b       	mov	r11,0
8000bd66:	fe b0 de 1b 	rcall	8000799c <memset>
8000bd6a:	0e 9c       	mov	r12,r7
8000bd6c:	d8 22       	popm	r4-r7,pc
8000bd6e:	d7 03       	nop

8000bd70 <_close_r>:
8000bd70:	d4 21       	pushm	r4-r7,lr
8000bd72:	30 08       	mov	r8,0
8000bd74:	18 97       	mov	r7,r12
8000bd76:	e0 66 53 bc 	mov	r6,21436
8000bd7a:	16 9c       	mov	r12,r11
8000bd7c:	8d 08       	st.w	r6[0x0],r8
8000bd7e:	fe b0 df b5 	rcall	80007ce8 <_close>
8000bd82:	5b fc       	cp.w	r12,-1
8000bd84:	c0 51       	brne	8000bd8e <_close_r+0x1e>
8000bd86:	6c 08       	ld.w	r8,r6[0x0]
8000bd88:	58 08       	cp.w	r8,0
8000bd8a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bd8e:	d8 22       	popm	r4-r7,pc

8000bd90 <_fclose_r>:
8000bd90:	d4 21       	pushm	r4-r7,lr
8000bd92:	18 96       	mov	r6,r12
8000bd94:	16 97       	mov	r7,r11
8000bd96:	58 0b       	cp.w	r11,0
8000bd98:	c0 31       	brne	8000bd9e <_fclose_r+0xe>
8000bd9a:	16 95       	mov	r5,r11
8000bd9c:	c5 38       	rjmp	8000be42 <_fclose_r+0xb2>
8000bd9e:	fe b0 f8 a9 	rcall	8000aef0 <__sfp_lock_acquire>
8000bda2:	58 06       	cp.w	r6,0
8000bda4:	c0 70       	breq	8000bdb2 <_fclose_r+0x22>
8000bda6:	6c 68       	ld.w	r8,r6[0x18]
8000bda8:	58 08       	cp.w	r8,0
8000bdaa:	c0 41       	brne	8000bdb2 <_fclose_r+0x22>
8000bdac:	0c 9c       	mov	r12,r6
8000bdae:	fe b0 f8 f3 	rcall	8000af94 <__sinit>
8000bdb2:	fe c8 dc b2 	sub	r8,pc,-9038
8000bdb6:	10 37       	cp.w	r7,r8
8000bdb8:	c0 31       	brne	8000bdbe <_fclose_r+0x2e>
8000bdba:	6c 07       	ld.w	r7,r6[0x0]
8000bdbc:	c0 c8       	rjmp	8000bdd4 <_fclose_r+0x44>
8000bdbe:	fe c8 dc 9e 	sub	r8,pc,-9058
8000bdc2:	10 37       	cp.w	r7,r8
8000bdc4:	c0 31       	brne	8000bdca <_fclose_r+0x3a>
8000bdc6:	6c 17       	ld.w	r7,r6[0x4]
8000bdc8:	c0 68       	rjmp	8000bdd4 <_fclose_r+0x44>
8000bdca:	fe c8 dc 8a 	sub	r8,pc,-9078
8000bdce:	10 37       	cp.w	r7,r8
8000bdd0:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000bdd4:	8e 69       	ld.sh	r9,r7[0xc]
8000bdd6:	30 08       	mov	r8,0
8000bdd8:	f0 09 19 00 	cp.h	r9,r8
8000bddc:	c0 51       	brne	8000bde6 <_fclose_r+0x56>
8000bdde:	fe b0 f8 8a 	rcall	8000aef2 <__sfp_lock_release>
8000bde2:	30 05       	mov	r5,0
8000bde4:	c2 f8       	rjmp	8000be42 <_fclose_r+0xb2>
8000bde6:	0e 9b       	mov	r11,r7
8000bde8:	0c 9c       	mov	r12,r6
8000bdea:	fe b0 f7 fd 	rcall	8000ade4 <_fflush_r>
8000bdee:	6e c8       	ld.w	r8,r7[0x30]
8000bdf0:	18 95       	mov	r5,r12
8000bdf2:	58 08       	cp.w	r8,0
8000bdf4:	c0 60       	breq	8000be00 <_fclose_r+0x70>
8000bdf6:	6e 8b       	ld.w	r11,r7[0x20]
8000bdf8:	0c 9c       	mov	r12,r6
8000bdfa:	5d 18       	icall	r8
8000bdfc:	f9 b5 05 ff 	movlt	r5,-1
8000be00:	8e 68       	ld.sh	r8,r7[0xc]
8000be02:	ed b8 00 07 	bld	r8,0x7
8000be06:	c0 51       	brne	8000be10 <_fclose_r+0x80>
8000be08:	6e 4b       	ld.w	r11,r7[0x10]
8000be0a:	0c 9c       	mov	r12,r6
8000be0c:	fe b0 f9 5e 	rcall	8000b0c8 <_free_r>
8000be10:	6e db       	ld.w	r11,r7[0x34]
8000be12:	58 0b       	cp.w	r11,0
8000be14:	c0 a0       	breq	8000be28 <_fclose_r+0x98>
8000be16:	ee c8 ff bc 	sub	r8,r7,-68
8000be1a:	10 3b       	cp.w	r11,r8
8000be1c:	c0 40       	breq	8000be24 <_fclose_r+0x94>
8000be1e:	0c 9c       	mov	r12,r6
8000be20:	fe b0 f9 54 	rcall	8000b0c8 <_free_r>
8000be24:	30 08       	mov	r8,0
8000be26:	8f d8       	st.w	r7[0x34],r8
8000be28:	6f 2b       	ld.w	r11,r7[0x48]
8000be2a:	58 0b       	cp.w	r11,0
8000be2c:	c0 70       	breq	8000be3a <_fclose_r+0xaa>
8000be2e:	0c 9c       	mov	r12,r6
8000be30:	fe b0 f9 4c 	rcall	8000b0c8 <_free_r>
8000be34:	30 08       	mov	r8,0
8000be36:	ef 48 00 48 	st.w	r7[72],r8
8000be3a:	30 08       	mov	r8,0
8000be3c:	ae 68       	st.h	r7[0xc],r8
8000be3e:	fe b0 f8 5a 	rcall	8000aef2 <__sfp_lock_release>
8000be42:	0a 9c       	mov	r12,r5
8000be44:	d8 22       	popm	r4-r7,pc
8000be46:	d7 03       	nop

8000be48 <fclose>:
8000be48:	d4 01       	pushm	lr
8000be4a:	e0 68 0a 3c 	mov	r8,2620
8000be4e:	18 9b       	mov	r11,r12
8000be50:	70 0c       	ld.w	r12,r8[0x0]
8000be52:	c9 ff       	rcall	8000bd90 <_fclose_r>
8000be54:	d8 02       	popm	pc
8000be56:	d7 03       	nop

8000be58 <_fstat_r>:
8000be58:	d4 21       	pushm	r4-r7,lr
8000be5a:	16 98       	mov	r8,r11
8000be5c:	18 97       	mov	r7,r12
8000be5e:	10 9c       	mov	r12,r8
8000be60:	30 08       	mov	r8,0
8000be62:	e0 66 53 bc 	mov	r6,21436
8000be66:	14 9b       	mov	r11,r10
8000be68:	8d 08       	st.w	r6[0x0],r8
8000be6a:	fe b0 df 67 	rcall	80007d38 <_fstat>
8000be6e:	5b fc       	cp.w	r12,-1
8000be70:	c0 51       	brne	8000be7a <_fstat_r+0x22>
8000be72:	6c 08       	ld.w	r8,r6[0x0]
8000be74:	58 08       	cp.w	r8,0
8000be76:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000be7a:	d8 22       	popm	r4-r7,pc

8000be7c <_lseek_r>:
8000be7c:	d4 21       	pushm	r4-r7,lr
8000be7e:	16 98       	mov	r8,r11
8000be80:	18 97       	mov	r7,r12
8000be82:	10 9c       	mov	r12,r8
8000be84:	30 08       	mov	r8,0
8000be86:	14 9b       	mov	r11,r10
8000be88:	e0 66 53 bc 	mov	r6,21436
8000be8c:	12 9a       	mov	r10,r9
8000be8e:	8d 08       	st.w	r6[0x0],r8
8000be90:	fe b0 df 36 	rcall	80007cfc <_lseek>
8000be94:	5b fc       	cp.w	r12,-1
8000be96:	c0 51       	brne	8000bea0 <_lseek_r+0x24>
8000be98:	6c 08       	ld.w	r8,r6[0x0]
8000be9a:	58 08       	cp.w	r8,0
8000be9c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bea0:	d8 22       	popm	r4-r7,pc
8000bea2:	d7 03       	nop

8000bea4 <_read_r>:
8000bea4:	d4 21       	pushm	r4-r7,lr
8000bea6:	16 98       	mov	r8,r11
8000bea8:	18 97       	mov	r7,r12
8000beaa:	10 9c       	mov	r12,r8
8000beac:	30 08       	mov	r8,0
8000beae:	14 9b       	mov	r11,r10
8000beb0:	e0 66 53 bc 	mov	r6,21436
8000beb4:	12 9a       	mov	r10,r9
8000beb6:	8d 08       	st.w	r6[0x0],r8
8000beb8:	fe b0 d0 74 	rcall	80005fa0 <_read>
8000bebc:	5b fc       	cp.w	r12,-1
8000bebe:	c0 51       	brne	8000bec8 <_read_r+0x24>
8000bec0:	6c 08       	ld.w	r8,r6[0x0]
8000bec2:	58 08       	cp.w	r8,0
8000bec4:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bec8:	d8 22       	popm	r4-r7,pc
8000beca:	d7 03       	nop

8000becc <__avr32_f64_mul>:
8000becc:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000bed0:	e0 80 00 dc 	breq	8000c088 <__avr32_f64_mul_op1_zero>
8000bed4:	d4 21       	pushm	r4-r7,lr
8000bed6:	f7 e9 20 0e 	eor	lr,r11,r9
8000beda:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bede:	30 15       	mov	r5,1
8000bee0:	c4 30       	breq	8000bf66 <__avr32_f64_mul_op1_subnormal>
8000bee2:	ab 6b       	lsl	r11,0xa
8000bee4:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000bee8:	ab 6a       	lsl	r10,0xa
8000beea:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000beee:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bef2:	c5 c0       	breq	8000bfaa <__avr32_f64_mul_op2_subnormal>
8000bef4:	a1 78       	lsl	r8,0x1
8000bef6:	5c f9       	rol	r9
8000bef8:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000befc:	e0 47 07 ff 	cp.w	r7,2047
8000bf00:	c7 70       	breq	8000bfee <__avr32_f64_mul_op_nan_or_inf>
8000bf02:	e0 46 07 ff 	cp.w	r6,2047
8000bf06:	c7 40       	breq	8000bfee <__avr32_f64_mul_op_nan_or_inf>
8000bf08:	ee 06 00 0c 	add	r12,r7,r6
8000bf0c:	e0 2c 03 fe 	sub	r12,1022
8000bf10:	f6 08 06 44 	mulu.d	r4,r11,r8
8000bf14:	f4 09 07 44 	macu.d	r4,r10,r9
8000bf18:	f4 08 06 46 	mulu.d	r6,r10,r8
8000bf1c:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000bf20:	08 07       	add	r7,r4
8000bf22:	f4 05 00 4a 	adc	r10,r10,r5
8000bf26:	5c 0b       	acr	r11
8000bf28:	ed bb 00 14 	bld	r11,0x14
8000bf2c:	c0 50       	breq	8000bf36 <__avr32_f64_mul+0x6a>
8000bf2e:	a1 77       	lsl	r7,0x1
8000bf30:	5c fa       	rol	r10
8000bf32:	5c fb       	rol	r11
8000bf34:	20 1c       	sub	r12,1
8000bf36:	58 0c       	cp.w	r12,0
8000bf38:	e0 8a 00 6f 	brle	8000c016 <__avr32_f64_mul_res_subnormal>
8000bf3c:	e0 4c 07 ff 	cp.w	r12,2047
8000bf40:	e0 84 00 9c 	brge	8000c078 <__avr32_f64_mul_res_inf>
8000bf44:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000bf48:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000bf4c:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000bf50:	ee 17 80 00 	eorh	r7,0x8000
8000bf54:	f1 b7 04 20 	satu	r7,0x1
8000bf58:	0e 0a       	add	r10,r7
8000bf5a:	5c 0b       	acr	r11
8000bf5c:	ed be 00 1f 	bld	lr,0x1f
8000bf60:	ef bb 00 1f 	bst	r11,0x1f
8000bf64:	d8 22       	popm	r4-r7,pc

8000bf66 <__avr32_f64_mul_op1_subnormal>:
8000bf66:	e4 1b 00 0f 	andh	r11,0xf
8000bf6a:	f4 0c 12 00 	clz	r12,r10
8000bf6e:	f6 06 12 00 	clz	r6,r11
8000bf72:	f7 bc 03 e1 	sublo	r12,-31
8000bf76:	f8 06 17 30 	movlo	r6,r12
8000bf7a:	f7 b6 02 01 	subhs	r6,1
8000bf7e:	e0 46 00 20 	cp.w	r6,32
8000bf82:	c0 d4       	brge	8000bf9c <__avr32_f64_mul_op1_subnormal+0x36>
8000bf84:	ec 0c 11 20 	rsub	r12,r6,32
8000bf88:	f6 06 09 4b 	lsl	r11,r11,r6
8000bf8c:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000bf90:	18 4b       	or	r11,r12
8000bf92:	f4 06 09 4a 	lsl	r10,r10,r6
8000bf96:	20 b6       	sub	r6,11
8000bf98:	0c 17       	sub	r7,r6
8000bf9a:	ca ab       	rjmp	8000beee <__avr32_f64_mul+0x22>
8000bf9c:	f4 06 09 4b 	lsl	r11,r10,r6
8000bfa0:	c6 40       	breq	8000c068 <__avr32_f64_mul_res_zero>
8000bfa2:	30 0a       	mov	r10,0
8000bfa4:	20 b6       	sub	r6,11
8000bfa6:	0c 17       	sub	r7,r6
8000bfa8:	ca 3b       	rjmp	8000beee <__avr32_f64_mul+0x22>

8000bfaa <__avr32_f64_mul_op2_subnormal>:
8000bfaa:	e4 19 00 0f 	andh	r9,0xf
8000bfae:	f0 0c 12 00 	clz	r12,r8
8000bfb2:	f2 05 12 00 	clz	r5,r9
8000bfb6:	f7 bc 03 ea 	sublo	r12,-22
8000bfba:	f8 05 17 30 	movlo	r5,r12
8000bfbe:	f7 b5 02 0a 	subhs	r5,10
8000bfc2:	e0 45 00 20 	cp.w	r5,32
8000bfc6:	c0 d4       	brge	8000bfe0 <__avr32_f64_mul_op2_subnormal+0x36>
8000bfc8:	ea 0c 11 20 	rsub	r12,r5,32
8000bfcc:	f2 05 09 49 	lsl	r9,r9,r5
8000bfd0:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000bfd4:	18 49       	or	r9,r12
8000bfd6:	f0 05 09 48 	lsl	r8,r8,r5
8000bfda:	20 25       	sub	r5,2
8000bfdc:	0a 16       	sub	r6,r5
8000bfde:	c8 fb       	rjmp	8000befc <__avr32_f64_mul+0x30>
8000bfe0:	f0 05 09 49 	lsl	r9,r8,r5
8000bfe4:	c4 20       	breq	8000c068 <__avr32_f64_mul_res_zero>
8000bfe6:	30 08       	mov	r8,0
8000bfe8:	20 25       	sub	r5,2
8000bfea:	0a 16       	sub	r6,r5
8000bfec:	c8 8b       	rjmp	8000befc <__avr32_f64_mul+0x30>

8000bfee <__avr32_f64_mul_op_nan_or_inf>:
8000bfee:	e4 19 00 0f 	andh	r9,0xf
8000bff2:	e4 1b 00 0f 	andh	r11,0xf
8000bff6:	14 4b       	or	r11,r10
8000bff8:	10 49       	or	r9,r8
8000bffa:	e0 47 07 ff 	cp.w	r7,2047
8000bffe:	c0 91       	brne	8000c010 <__avr32_f64_mul_op1_not_naninf>
8000c000:	58 0b       	cp.w	r11,0
8000c002:	c3 81       	brne	8000c072 <__avr32_f64_mul_res_nan>
8000c004:	e0 46 07 ff 	cp.w	r6,2047
8000c008:	c3 81       	brne	8000c078 <__avr32_f64_mul_res_inf>
8000c00a:	58 09       	cp.w	r9,0
8000c00c:	c3 60       	breq	8000c078 <__avr32_f64_mul_res_inf>
8000c00e:	c3 28       	rjmp	8000c072 <__avr32_f64_mul_res_nan>

8000c010 <__avr32_f64_mul_op1_not_naninf>:
8000c010:	58 09       	cp.w	r9,0
8000c012:	c3 30       	breq	8000c078 <__avr32_f64_mul_res_inf>
8000c014:	c2 f8       	rjmp	8000c072 <__avr32_f64_mul_res_nan>

8000c016 <__avr32_f64_mul_res_subnormal>:
8000c016:	5c 3c       	neg	r12
8000c018:	2f fc       	sub	r12,-1
8000c01a:	f1 bc 04 c0 	satu	r12,0x6
8000c01e:	e0 4c 00 20 	cp.w	r12,32
8000c022:	c1 14       	brge	8000c044 <__avr32_f64_mul_res_subnormal+0x2e>
8000c024:	f8 08 11 20 	rsub	r8,r12,32
8000c028:	0e 46       	or	r6,r7
8000c02a:	ee 0c 0a 47 	lsr	r7,r7,r12
8000c02e:	f4 08 09 49 	lsl	r9,r10,r8
8000c032:	12 47       	or	r7,r9
8000c034:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c038:	f6 08 09 49 	lsl	r9,r11,r8
8000c03c:	12 4a       	or	r10,r9
8000c03e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c042:	c8 3b       	rjmp	8000bf48 <__avr32_f64_mul+0x7c>
8000c044:	f8 08 11 20 	rsub	r8,r12,32
8000c048:	f9 b9 00 00 	moveq	r9,0
8000c04c:	c0 30       	breq	8000c052 <__avr32_f64_mul_res_subnormal+0x3c>
8000c04e:	f6 08 09 49 	lsl	r9,r11,r8
8000c052:	0e 46       	or	r6,r7
8000c054:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000c058:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c05c:	f3 ea 10 07 	or	r7,r9,r10
8000c060:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000c064:	30 0b       	mov	r11,0
8000c066:	c7 1b       	rjmp	8000bf48 <__avr32_f64_mul+0x7c>

8000c068 <__avr32_f64_mul_res_zero>:
8000c068:	1c 9b       	mov	r11,lr
8000c06a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c06e:	30 0a       	mov	r10,0
8000c070:	d8 22       	popm	r4-r7,pc

8000c072 <__avr32_f64_mul_res_nan>:
8000c072:	3f fb       	mov	r11,-1
8000c074:	3f fa       	mov	r10,-1
8000c076:	d8 22       	popm	r4-r7,pc

8000c078 <__avr32_f64_mul_res_inf>:
8000c078:	f0 6b 00 00 	mov	r11,-1048576
8000c07c:	ed be 00 1f 	bld	lr,0x1f
8000c080:	ef bb 00 1f 	bst	r11,0x1f
8000c084:	30 0a       	mov	r10,0
8000c086:	d8 22       	popm	r4-r7,pc

8000c088 <__avr32_f64_mul_op1_zero>:
8000c088:	f7 e9 20 0b 	eor	r11,r11,r9
8000c08c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c090:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000c094:	e0 4c 07 ff 	cp.w	r12,2047
8000c098:	5e 1c       	retne	r12
8000c09a:	3f fa       	mov	r10,-1
8000c09c:	3f fb       	mov	r11,-1
8000c09e:	5e fc       	retal	r12

8000c0a0 <__avr32_f64_sub_from_add>:
8000c0a0:	ee 19 80 00 	eorh	r9,0x8000

8000c0a4 <__avr32_f64_sub>:
8000c0a4:	f7 e9 20 0c 	eor	r12,r11,r9
8000c0a8:	e0 86 00 ca 	brmi	8000c23c <__avr32_f64_add_from_sub>
8000c0ac:	eb cd 40 e0 	pushm	r5-r7,lr
8000c0b0:	16 9c       	mov	r12,r11
8000c0b2:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c0b6:	bf db       	cbr	r11,0x1f
8000c0b8:	bf d9       	cbr	r9,0x1f
8000c0ba:	10 3a       	cp.w	r10,r8
8000c0bc:	f2 0b 13 00 	cpc	r11,r9
8000c0c0:	c0 92       	brcc	8000c0d2 <__avr32_f64_sub+0x2e>
8000c0c2:	16 97       	mov	r7,r11
8000c0c4:	12 9b       	mov	r11,r9
8000c0c6:	0e 99       	mov	r9,r7
8000c0c8:	14 97       	mov	r7,r10
8000c0ca:	10 9a       	mov	r10,r8
8000c0cc:	0e 98       	mov	r8,r7
8000c0ce:	ee 1c 80 00 	eorh	r12,0x8000
8000c0d2:	f6 07 16 14 	lsr	r7,r11,0x14
8000c0d6:	ab 7b       	lsl	r11,0xb
8000c0d8:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c0dc:	ab 7a       	lsl	r10,0xb
8000c0de:	bf bb       	sbr	r11,0x1f
8000c0e0:	f2 06 16 14 	lsr	r6,r9,0x14
8000c0e4:	c4 40       	breq	8000c16c <__avr32_f64_sub_opL_subnormal>
8000c0e6:	ab 79       	lsl	r9,0xb
8000c0e8:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c0ec:	ab 78       	lsl	r8,0xb
8000c0ee:	bf b9       	sbr	r9,0x1f

8000c0f0 <__avr32_f64_sub_opL_subnormal_done>:
8000c0f0:	e0 47 07 ff 	cp.w	r7,2047
8000c0f4:	c4 f0       	breq	8000c192 <__avr32_f64_sub_opH_nan_or_inf>
8000c0f6:	0e 26       	rsub	r6,r7
8000c0f8:	c1 20       	breq	8000c11c <__avr32_f64_sub_shift_done>
8000c0fa:	ec 05 11 20 	rsub	r5,r6,32
8000c0fe:	e0 46 00 20 	cp.w	r6,32
8000c102:	c7 c2       	brcc	8000c1fa <__avr32_f64_sub_longshift>
8000c104:	f0 05 09 4e 	lsl	lr,r8,r5
8000c108:	f2 05 09 45 	lsl	r5,r9,r5
8000c10c:	f0 06 0a 48 	lsr	r8,r8,r6
8000c110:	f2 06 0a 49 	lsr	r9,r9,r6
8000c114:	0a 48       	or	r8,r5
8000c116:	58 0e       	cp.w	lr,0
8000c118:	5f 1e       	srne	lr
8000c11a:	1c 48       	or	r8,lr

8000c11c <__avr32_f64_sub_shift_done>:
8000c11c:	10 1a       	sub	r10,r8
8000c11e:	f6 09 01 4b 	sbc	r11,r11,r9
8000c122:	f6 06 12 00 	clz	r6,r11
8000c126:	c0 e0       	breq	8000c142 <__avr32_f64_sub_longnormalize_done>
8000c128:	c7 83       	brcs	8000c218 <__avr32_f64_sub_longnormalize>
8000c12a:	ec 0e 11 20 	rsub	lr,r6,32
8000c12e:	f6 06 09 4b 	lsl	r11,r11,r6
8000c132:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c136:	1c 4b       	or	r11,lr
8000c138:	f4 06 09 4a 	lsl	r10,r10,r6
8000c13c:	0c 17       	sub	r7,r6
8000c13e:	e0 8a 00 39 	brle	8000c1b0 <__avr32_f64_sub_subnormal_result>

8000c142 <__avr32_f64_sub_longnormalize_done>:
8000c142:	f4 09 15 15 	lsl	r9,r10,0x15
8000c146:	ab 9a       	lsr	r10,0xb
8000c148:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c14c:	ab 9b       	lsr	r11,0xb
8000c14e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c152:	18 4b       	or	r11,r12

8000c154 <__avr32_f64_sub_round>:
8000c154:	fc 17 80 00 	movh	r7,0x8000
8000c158:	ed ba 00 00 	bld	r10,0x0
8000c15c:	f7 b7 01 ff 	subne	r7,-1
8000c160:	0e 39       	cp.w	r9,r7
8000c162:	5f 29       	srhs	r9
8000c164:	12 0a       	add	r10,r9
8000c166:	5c 0b       	acr	r11
8000c168:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c16c <__avr32_f64_sub_opL_subnormal>:
8000c16c:	ab 79       	lsl	r9,0xb
8000c16e:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c172:	ab 78       	lsl	r8,0xb
8000c174:	f3 e8 10 0e 	or	lr,r9,r8
8000c178:	f9 b6 01 01 	movne	r6,1
8000c17c:	ee 0e 11 00 	rsub	lr,r7,0
8000c180:	f9 b7 00 01 	moveq	r7,1
8000c184:	ef bb 00 1f 	bst	r11,0x1f
8000c188:	f7 ea 10 0e 	or	lr,r11,r10
8000c18c:	f9 b7 00 00 	moveq	r7,0
8000c190:	cb 0b       	rjmp	8000c0f0 <__avr32_f64_sub_opL_subnormal_done>

8000c192 <__avr32_f64_sub_opH_nan_or_inf>:
8000c192:	bf db       	cbr	r11,0x1f
8000c194:	f7 ea 10 0e 	or	lr,r11,r10
8000c198:	c0 81       	brne	8000c1a8 <__avr32_f64_sub_return_nan>
8000c19a:	e0 46 07 ff 	cp.w	r6,2047
8000c19e:	c0 50       	breq	8000c1a8 <__avr32_f64_sub_return_nan>
8000c1a0:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000c1a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c1a8 <__avr32_f64_sub_return_nan>:
8000c1a8:	3f fa       	mov	r10,-1
8000c1aa:	3f fb       	mov	r11,-1
8000c1ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c1b0 <__avr32_f64_sub_subnormal_result>:
8000c1b0:	5c 37       	neg	r7
8000c1b2:	2f f7       	sub	r7,-1
8000c1b4:	f1 b7 04 c0 	satu	r7,0x6
8000c1b8:	e0 47 00 20 	cp.w	r7,32
8000c1bc:	c1 14       	brge	8000c1de <__avr32_f64_sub_subnormal_result+0x2e>
8000c1be:	ee 08 11 20 	rsub	r8,r7,32
8000c1c2:	f4 08 09 49 	lsl	r9,r10,r8
8000c1c6:	5f 16       	srne	r6
8000c1c8:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c1cc:	0c 4a       	or	r10,r6
8000c1ce:	f6 08 09 49 	lsl	r9,r11,r8
8000c1d2:	f5 e9 10 0a 	or	r10,r10,r9
8000c1d6:	f4 07 0a 4b 	lsr	r11,r10,r7
8000c1da:	30 07       	mov	r7,0
8000c1dc:	cb 3b       	rjmp	8000c142 <__avr32_f64_sub_longnormalize_done>
8000c1de:	ee 08 11 40 	rsub	r8,r7,64
8000c1e2:	f6 08 09 49 	lsl	r9,r11,r8
8000c1e6:	14 49       	or	r9,r10
8000c1e8:	5f 16       	srne	r6
8000c1ea:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c1ee:	0c 4a       	or	r10,r6
8000c1f0:	30 0b       	mov	r11,0
8000c1f2:	30 07       	mov	r7,0
8000c1f4:	ca 7b       	rjmp	8000c142 <__avr32_f64_sub_longnormalize_done>
8000c1f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c1fa <__avr32_f64_sub_longshift>:
8000c1fa:	f1 b6 04 c0 	satu	r6,0x6
8000c1fe:	f0 0e 17 00 	moveq	lr,r8
8000c202:	c0 40       	breq	8000c20a <__avr32_f64_sub_longshift+0x10>
8000c204:	f2 05 09 4e 	lsl	lr,r9,r5
8000c208:	10 4e       	or	lr,r8
8000c20a:	f2 06 0a 48 	lsr	r8,r9,r6
8000c20e:	30 09       	mov	r9,0
8000c210:	58 0e       	cp.w	lr,0
8000c212:	5f 1e       	srne	lr
8000c214:	1c 48       	or	r8,lr
8000c216:	c8 3b       	rjmp	8000c11c <__avr32_f64_sub_shift_done>

8000c218 <__avr32_f64_sub_longnormalize>:
8000c218:	f4 06 12 00 	clz	r6,r10
8000c21c:	f9 b7 03 00 	movlo	r7,0
8000c220:	f9 b6 03 00 	movlo	r6,0
8000c224:	f9 bc 03 00 	movlo	r12,0
8000c228:	f7 b6 02 e0 	subhs	r6,-32
8000c22c:	f4 06 09 4b 	lsl	r11,r10,r6
8000c230:	30 0a       	mov	r10,0
8000c232:	0c 17       	sub	r7,r6
8000c234:	fe 9a ff be 	brle	8000c1b0 <__avr32_f64_sub_subnormal_result>
8000c238:	c8 5b       	rjmp	8000c142 <__avr32_f64_sub_longnormalize_done>
8000c23a:	d7 03       	nop

8000c23c <__avr32_f64_add_from_sub>:
8000c23c:	ee 19 80 00 	eorh	r9,0x8000

8000c240 <__avr32_f64_add>:
8000c240:	f7 e9 20 0c 	eor	r12,r11,r9
8000c244:	fe 96 ff 2e 	brmi	8000c0a0 <__avr32_f64_sub_from_add>
8000c248:	eb cd 40 e0 	pushm	r5-r7,lr
8000c24c:	16 9c       	mov	r12,r11
8000c24e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c252:	bf db       	cbr	r11,0x1f
8000c254:	bf d9       	cbr	r9,0x1f
8000c256:	12 3b       	cp.w	r11,r9
8000c258:	c0 72       	brcc	8000c266 <__avr32_f64_add+0x26>
8000c25a:	16 97       	mov	r7,r11
8000c25c:	12 9b       	mov	r11,r9
8000c25e:	0e 99       	mov	r9,r7
8000c260:	14 97       	mov	r7,r10
8000c262:	10 9a       	mov	r10,r8
8000c264:	0e 98       	mov	r8,r7
8000c266:	30 0e       	mov	lr,0
8000c268:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c26c:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000c270:	b5 ab       	sbr	r11,0x14
8000c272:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c276:	c6 20       	breq	8000c33a <__avr32_f64_add_op2_subnormal>
8000c278:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000c27c:	b5 a9       	sbr	r9,0x14
8000c27e:	e0 47 07 ff 	cp.w	r7,2047
8000c282:	c2 80       	breq	8000c2d2 <__avr32_f64_add_opH_nan_or_inf>
8000c284:	0e 26       	rsub	r6,r7
8000c286:	c1 20       	breq	8000c2aa <__avr32_f64_add_shift_done>
8000c288:	e0 46 00 36 	cp.w	r6,54
8000c28c:	c1 52       	brcc	8000c2b6 <__avr32_f64_add_res_of_done>
8000c28e:	ec 05 11 20 	rsub	r5,r6,32
8000c292:	e0 46 00 20 	cp.w	r6,32
8000c296:	c3 52       	brcc	8000c300 <__avr32_f64_add_longshift>
8000c298:	f0 05 09 4e 	lsl	lr,r8,r5
8000c29c:	f2 05 09 45 	lsl	r5,r9,r5
8000c2a0:	f0 06 0a 48 	lsr	r8,r8,r6
8000c2a4:	f2 06 0a 49 	lsr	r9,r9,r6
8000c2a8:	0a 48       	or	r8,r5

8000c2aa <__avr32_f64_add_shift_done>:
8000c2aa:	10 0a       	add	r10,r8
8000c2ac:	f6 09 00 4b 	adc	r11,r11,r9
8000c2b0:	ed bb 00 15 	bld	r11,0x15
8000c2b4:	c3 40       	breq	8000c31c <__avr32_f64_add_res_of>

8000c2b6 <__avr32_f64_add_res_of_done>:
8000c2b6:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c2ba:	18 4b       	or	r11,r12

8000c2bc <__avr32_f64_add_round>:
8000c2bc:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c2c0:	18 4e       	or	lr,r12
8000c2c2:	ee 1e 80 00 	eorh	lr,0x8000
8000c2c6:	f1 be 04 20 	satu	lr,0x1
8000c2ca:	1c 0a       	add	r10,lr
8000c2cc:	5c 0b       	acr	r11
8000c2ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c2d2 <__avr32_f64_add_opH_nan_or_inf>:
8000c2d2:	b5 cb       	cbr	r11,0x14
8000c2d4:	f7 ea 10 0e 	or	lr,r11,r10
8000c2d8:	c1 01       	brne	8000c2f8 <__avr32_f64_add_return_nan>
8000c2da:	e0 46 07 ff 	cp.w	r6,2047
8000c2de:	c0 30       	breq	8000c2e4 <__avr32_f64_add_opL_nan_or_inf>
8000c2e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c2e4 <__avr32_f64_add_opL_nan_or_inf>:
8000c2e4:	b5 c9       	cbr	r9,0x14
8000c2e6:	f3 e8 10 0e 	or	lr,r9,r8
8000c2ea:	c0 71       	brne	8000c2f8 <__avr32_f64_add_return_nan>
8000c2ec:	30 0a       	mov	r10,0
8000c2ee:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c2f2:	18 4b       	or	r11,r12
8000c2f4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c2f8 <__avr32_f64_add_return_nan>:
8000c2f8:	3f fa       	mov	r10,-1
8000c2fa:	3f fb       	mov	r11,-1
8000c2fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c300 <__avr32_f64_add_longshift>:
8000c300:	f1 b6 04 c0 	satu	r6,0x6
8000c304:	f0 0e 17 00 	moveq	lr,r8
8000c308:	c0 60       	breq	8000c314 <__avr32_f64_add_longshift+0x14>
8000c30a:	f2 05 09 4e 	lsl	lr,r9,r5
8000c30e:	58 08       	cp.w	r8,0
8000c310:	5f 18       	srne	r8
8000c312:	10 4e       	or	lr,r8
8000c314:	f2 06 0a 48 	lsr	r8,r9,r6
8000c318:	30 09       	mov	r9,0
8000c31a:	cc 8b       	rjmp	8000c2aa <__avr32_f64_add_shift_done>

8000c31c <__avr32_f64_add_res_of>:
8000c31c:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c320:	a1 9b       	lsr	r11,0x1
8000c322:	5d 0a       	ror	r10
8000c324:	5d 0e       	ror	lr
8000c326:	2f f7       	sub	r7,-1
8000c328:	e0 47 07 ff 	cp.w	r7,2047
8000c32c:	f9 ba 00 00 	moveq	r10,0
8000c330:	f9 bb 00 00 	moveq	r11,0
8000c334:	f9 be 00 00 	moveq	lr,0
8000c338:	cb fb       	rjmp	8000c2b6 <__avr32_f64_add_res_of_done>

8000c33a <__avr32_f64_add_op2_subnormal>:
8000c33a:	30 16       	mov	r6,1
8000c33c:	58 07       	cp.w	r7,0
8000c33e:	ca 01       	brne	8000c27e <__avr32_f64_add+0x3e>
8000c340:	b5 cb       	cbr	r11,0x14
8000c342:	10 0a       	add	r10,r8
8000c344:	f6 09 00 4b 	adc	r11,r11,r9
8000c348:	18 4b       	or	r11,r12
8000c34a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000c34e:	d7 03       	nop

8000c350 <__avr32_f64_to_u32>:
8000c350:	58 0b       	cp.w	r11,0
8000c352:	5e 6d       	retmi	0

8000c354 <__avr32_f64_to_s32>:
8000c354:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c358:	b5 9c       	lsr	r12,0x15
8000c35a:	e0 2c 03 ff 	sub	r12,1023
8000c35e:	5e 3d       	retlo	0
8000c360:	f8 0c 11 1f 	rsub	r12,r12,31
8000c364:	16 99       	mov	r9,r11
8000c366:	ab 7b       	lsl	r11,0xb
8000c368:	bf bb       	sbr	r11,0x1f
8000c36a:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c36e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c372:	a1 79       	lsl	r9,0x1
8000c374:	5e 2b       	reths	r11
8000c376:	5c 3b       	neg	r11
8000c378:	5e fb       	retal	r11

8000c37a <__avr32_u32_to_f64>:
8000c37a:	f8 cb 00 00 	sub	r11,r12,0
8000c37e:	30 0c       	mov	r12,0
8000c380:	c0 38       	rjmp	8000c386 <__avr32_s32_to_f64+0x4>

8000c382 <__avr32_s32_to_f64>:
8000c382:	18 9b       	mov	r11,r12
8000c384:	5c 4b       	abs	r11
8000c386:	30 0a       	mov	r10,0
8000c388:	5e 0b       	reteq	r11
8000c38a:	d4 01       	pushm	lr
8000c38c:	e0 69 04 1e 	mov	r9,1054
8000c390:	f6 08 12 00 	clz	r8,r11
8000c394:	c1 70       	breq	8000c3c2 <__avr32_s32_to_f64+0x40>
8000c396:	c0 c3       	brcs	8000c3ae <__avr32_s32_to_f64+0x2c>
8000c398:	f0 0e 11 20 	rsub	lr,r8,32
8000c39c:	f6 08 09 4b 	lsl	r11,r11,r8
8000c3a0:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c3a4:	1c 4b       	or	r11,lr
8000c3a6:	f4 08 09 4a 	lsl	r10,r10,r8
8000c3aa:	10 19       	sub	r9,r8
8000c3ac:	c0 b8       	rjmp	8000c3c2 <__avr32_s32_to_f64+0x40>
8000c3ae:	f4 08 12 00 	clz	r8,r10
8000c3b2:	f9 b8 03 00 	movlo	r8,0
8000c3b6:	f7 b8 02 e0 	subhs	r8,-32
8000c3ba:	f4 08 09 4b 	lsl	r11,r10,r8
8000c3be:	30 0a       	mov	r10,0
8000c3c0:	10 19       	sub	r9,r8
8000c3c2:	58 09       	cp.w	r9,0
8000c3c4:	e0 89 00 30 	brgt	8000c424 <__avr32_s32_to_f64+0xa2>
8000c3c8:	5c 39       	neg	r9
8000c3ca:	2f f9       	sub	r9,-1
8000c3cc:	e0 49 00 36 	cp.w	r9,54
8000c3d0:	c0 43       	brcs	8000c3d8 <__avr32_s32_to_f64+0x56>
8000c3d2:	30 0b       	mov	r11,0
8000c3d4:	30 0a       	mov	r10,0
8000c3d6:	c2 68       	rjmp	8000c422 <__avr32_s32_to_f64+0xa0>
8000c3d8:	2f 69       	sub	r9,-10
8000c3da:	f2 08 11 20 	rsub	r8,r9,32
8000c3de:	e0 49 00 20 	cp.w	r9,32
8000c3e2:	c0 b2       	brcc	8000c3f8 <__avr32_s32_to_f64+0x76>
8000c3e4:	f4 08 09 4e 	lsl	lr,r10,r8
8000c3e8:	f6 08 09 48 	lsl	r8,r11,r8
8000c3ec:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c3f0:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c3f4:	10 4b       	or	r11,r8
8000c3f6:	c0 88       	rjmp	8000c406 <__avr32_s32_to_f64+0x84>
8000c3f8:	f6 08 09 4e 	lsl	lr,r11,r8
8000c3fc:	14 4e       	or	lr,r10
8000c3fe:	16 9a       	mov	r10,r11
8000c400:	30 0b       	mov	r11,0
8000c402:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c406:	ed ba 00 00 	bld	r10,0x0
8000c40a:	c0 92       	brcc	8000c41c <__avr32_s32_to_f64+0x9a>
8000c40c:	1c 7e       	tst	lr,lr
8000c40e:	c0 41       	brne	8000c416 <__avr32_s32_to_f64+0x94>
8000c410:	ed ba 00 01 	bld	r10,0x1
8000c414:	c0 42       	brcc	8000c41c <__avr32_s32_to_f64+0x9a>
8000c416:	2f fa       	sub	r10,-1
8000c418:	f7 bb 02 ff 	subhs	r11,-1
8000c41c:	5c fc       	rol	r12
8000c41e:	5d 0b       	ror	r11
8000c420:	5d 0a       	ror	r10
8000c422:	d8 02       	popm	pc
8000c424:	e0 68 03 ff 	mov	r8,1023
8000c428:	ed ba 00 0b 	bld	r10,0xb
8000c42c:	f7 b8 00 ff 	subeq	r8,-1
8000c430:	10 0a       	add	r10,r8
8000c432:	5c 0b       	acr	r11
8000c434:	f7 b9 03 fe 	sublo	r9,-2
8000c438:	e0 49 07 ff 	cp.w	r9,2047
8000c43c:	c0 55       	brlt	8000c446 <__avr32_s32_to_f64+0xc4>
8000c43e:	30 0a       	mov	r10,0
8000c440:	fc 1b ff e0 	movh	r11,0xffe0
8000c444:	c0 c8       	rjmp	8000c45c <__floatsidf_return_op1>
8000c446:	ed bb 00 1f 	bld	r11,0x1f
8000c44a:	f7 b9 01 01 	subne	r9,1
8000c44e:	ab 9a       	lsr	r10,0xb
8000c450:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c454:	a1 7b       	lsl	r11,0x1
8000c456:	ab 9b       	lsr	r11,0xb
8000c458:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c45c <__floatsidf_return_op1>:
8000c45c:	a1 7c       	lsl	r12,0x1
8000c45e:	5d 0b       	ror	r11
8000c460:	d8 02       	popm	pc

8000c462 <__avr32_f64_cmp_eq>:
8000c462:	10 3a       	cp.w	r10,r8
8000c464:	f2 0b 13 00 	cpc	r11,r9
8000c468:	c0 80       	breq	8000c478 <__avr32_f64_cmp_eq+0x16>
8000c46a:	a1 7b       	lsl	r11,0x1
8000c46c:	a1 79       	lsl	r9,0x1
8000c46e:	14 4b       	or	r11,r10
8000c470:	12 4b       	or	r11,r9
8000c472:	10 4b       	or	r11,r8
8000c474:	5e 0f       	reteq	1
8000c476:	5e fd       	retal	0
8000c478:	a1 7b       	lsl	r11,0x1
8000c47a:	fc 1c ff e0 	movh	r12,0xffe0
8000c47e:	58 0a       	cp.w	r10,0
8000c480:	f8 0b 13 00 	cpc	r11,r12
8000c484:	5e 8f       	retls	1
8000c486:	5e fd       	retal	0

8000c488 <__avr32_f64_cmp_ge>:
8000c488:	1a de       	st.w	--sp,lr
8000c48a:	1a d7       	st.w	--sp,r7
8000c48c:	a1 7b       	lsl	r11,0x1
8000c48e:	5f 3c       	srlo	r12
8000c490:	a1 79       	lsl	r9,0x1
8000c492:	5f 37       	srlo	r7
8000c494:	5c fc       	rol	r12
8000c496:	fc 1e ff e0 	movh	lr,0xffe0
8000c49a:	58 0a       	cp.w	r10,0
8000c49c:	fc 0b 13 00 	cpc	r11,lr
8000c4a0:	e0 8b 00 1d 	brhi	8000c4da <__avr32_f64_cmp_ge+0x52>
8000c4a4:	58 08       	cp.w	r8,0
8000c4a6:	fc 09 13 00 	cpc	r9,lr
8000c4aa:	e0 8b 00 18 	brhi	8000c4da <__avr32_f64_cmp_ge+0x52>
8000c4ae:	58 0b       	cp.w	r11,0
8000c4b0:	f5 ba 00 00 	subfeq	r10,0
8000c4b4:	c1 50       	breq	8000c4de <__avr32_f64_cmp_ge+0x56>
8000c4b6:	1b 07       	ld.w	r7,sp++
8000c4b8:	1b 0e       	ld.w	lr,sp++
8000c4ba:	58 3c       	cp.w	r12,3
8000c4bc:	c0 a0       	breq	8000c4d0 <__avr32_f64_cmp_ge+0x48>
8000c4be:	58 1c       	cp.w	r12,1
8000c4c0:	c0 33       	brcs	8000c4c6 <__avr32_f64_cmp_ge+0x3e>
8000c4c2:	5e 0f       	reteq	1
8000c4c4:	5e 1d       	retne	0
8000c4c6:	10 3a       	cp.w	r10,r8
8000c4c8:	f2 0b 13 00 	cpc	r11,r9
8000c4cc:	5e 2f       	reths	1
8000c4ce:	5e 3d       	retlo	0
8000c4d0:	14 38       	cp.w	r8,r10
8000c4d2:	f6 09 13 00 	cpc	r9,r11
8000c4d6:	5e 2f       	reths	1
8000c4d8:	5e 3d       	retlo	0
8000c4da:	1b 07       	ld.w	r7,sp++
8000c4dc:	d8 0a       	popm	pc,r12=0
8000c4de:	58 17       	cp.w	r7,1
8000c4e0:	5f 0c       	sreq	r12
8000c4e2:	58 09       	cp.w	r9,0
8000c4e4:	f5 b8 00 00 	subfeq	r8,0
8000c4e8:	1b 07       	ld.w	r7,sp++
8000c4ea:	1b 0e       	ld.w	lr,sp++
8000c4ec:	5e 0f       	reteq	1
8000c4ee:	5e fc       	retal	r12

8000c4f0 <__avr32_f64_cmp_lt>:
8000c4f0:	1a de       	st.w	--sp,lr
8000c4f2:	1a d7       	st.w	--sp,r7
8000c4f4:	a1 7b       	lsl	r11,0x1
8000c4f6:	5f 3c       	srlo	r12
8000c4f8:	a1 79       	lsl	r9,0x1
8000c4fa:	5f 37       	srlo	r7
8000c4fc:	5c fc       	rol	r12
8000c4fe:	fc 1e ff e0 	movh	lr,0xffe0
8000c502:	58 0a       	cp.w	r10,0
8000c504:	fc 0b 13 00 	cpc	r11,lr
8000c508:	e0 8b 00 1d 	brhi	8000c542 <__avr32_f64_cmp_lt+0x52>
8000c50c:	58 08       	cp.w	r8,0
8000c50e:	fc 09 13 00 	cpc	r9,lr
8000c512:	e0 8b 00 18 	brhi	8000c542 <__avr32_f64_cmp_lt+0x52>
8000c516:	58 0b       	cp.w	r11,0
8000c518:	f5 ba 00 00 	subfeq	r10,0
8000c51c:	c1 50       	breq	8000c546 <__avr32_f64_cmp_lt+0x56>
8000c51e:	1b 07       	ld.w	r7,sp++
8000c520:	1b 0e       	ld.w	lr,sp++
8000c522:	58 3c       	cp.w	r12,3
8000c524:	c0 a0       	breq	8000c538 <__avr32_f64_cmp_lt+0x48>
8000c526:	58 1c       	cp.w	r12,1
8000c528:	c0 33       	brcs	8000c52e <__avr32_f64_cmp_lt+0x3e>
8000c52a:	5e 0d       	reteq	0
8000c52c:	5e 1f       	retne	1
8000c52e:	10 3a       	cp.w	r10,r8
8000c530:	f2 0b 13 00 	cpc	r11,r9
8000c534:	5e 2d       	reths	0
8000c536:	5e 3f       	retlo	1
8000c538:	14 38       	cp.w	r8,r10
8000c53a:	f6 09 13 00 	cpc	r9,r11
8000c53e:	5e 2d       	reths	0
8000c540:	5e 3f       	retlo	1
8000c542:	1b 07       	ld.w	r7,sp++
8000c544:	d8 0a       	popm	pc,r12=0
8000c546:	58 17       	cp.w	r7,1
8000c548:	5f 1c       	srne	r12
8000c54a:	58 09       	cp.w	r9,0
8000c54c:	f5 b8 00 00 	subfeq	r8,0
8000c550:	1b 07       	ld.w	r7,sp++
8000c552:	1b 0e       	ld.w	lr,sp++
8000c554:	5e 0d       	reteq	0
8000c556:	5e fc       	retal	r12

8000c558 <__avr32_f64_div>:
8000c558:	eb cd 40 ff 	pushm	r0-r7,lr
8000c55c:	f7 e9 20 0e 	eor	lr,r11,r9
8000c560:	f6 07 16 14 	lsr	r7,r11,0x14
8000c564:	a9 7b       	lsl	r11,0x9
8000c566:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c56a:	a9 7a       	lsl	r10,0x9
8000c56c:	bd bb       	sbr	r11,0x1d
8000c56e:	e4 1b 3f ff 	andh	r11,0x3fff
8000c572:	ab d7       	cbr	r7,0xb
8000c574:	e0 80 00 cc 	breq	8000c70c <__avr32_f64_div_round_subnormal+0x54>
8000c578:	e0 47 07 ff 	cp.w	r7,2047
8000c57c:	e0 84 00 b5 	brge	8000c6e6 <__avr32_f64_div_round_subnormal+0x2e>
8000c580:	f2 06 16 14 	lsr	r6,r9,0x14
8000c584:	a9 79       	lsl	r9,0x9
8000c586:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c58a:	a9 78       	lsl	r8,0x9
8000c58c:	bd b9       	sbr	r9,0x1d
8000c58e:	e4 19 3f ff 	andh	r9,0x3fff
8000c592:	ab d6       	cbr	r6,0xb
8000c594:	e0 80 00 e2 	breq	8000c758 <__avr32_f64_div_round_subnormal+0xa0>
8000c598:	e0 46 07 ff 	cp.w	r6,2047
8000c59c:	e0 84 00 b2 	brge	8000c700 <__avr32_f64_div_round_subnormal+0x48>
8000c5a0:	0c 17       	sub	r7,r6
8000c5a2:	fe 37 fc 01 	sub	r7,-1023
8000c5a6:	fc 1c 80 00 	movh	r12,0x8000
8000c5aa:	f8 03 16 01 	lsr	r3,r12,0x1
8000c5ae:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c5b2:	5c d4       	com	r4
8000c5b4:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c5b8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c5bc:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c5c0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c5c4:	ea 03 15 02 	lsl	r3,r5,0x2
8000c5c8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c5cc:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c5d0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c5d4:	ea 03 15 02 	lsl	r3,r5,0x2
8000c5d8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c5dc:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c5e0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c5e4:	ea 03 15 02 	lsl	r3,r5,0x2
8000c5e8:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c5ec:	e4 09 07 40 	macu.d	r0,r2,r9
8000c5f0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c5f4:	02 04       	add	r4,r1
8000c5f6:	5c 05       	acr	r5
8000c5f8:	a3 65       	lsl	r5,0x2
8000c5fa:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c5fe:	a3 64       	lsl	r4,0x2
8000c600:	5c 34       	neg	r4
8000c602:	f8 05 01 45 	sbc	r5,r12,r5
8000c606:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c60a:	e4 05 07 40 	macu.d	r0,r2,r5
8000c60e:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c612:	02 04       	add	r4,r1
8000c614:	5c 05       	acr	r5
8000c616:	ea 03 15 02 	lsl	r3,r5,0x2
8000c61a:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c61e:	e8 02 15 02 	lsl	r2,r4,0x2
8000c622:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c626:	e4 09 07 40 	macu.d	r0,r2,r9
8000c62a:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c62e:	02 04       	add	r4,r1
8000c630:	5c 05       	acr	r5
8000c632:	a3 65       	lsl	r5,0x2
8000c634:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c638:	a3 64       	lsl	r4,0x2
8000c63a:	5c 34       	neg	r4
8000c63c:	f8 05 01 45 	sbc	r5,r12,r5
8000c640:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c644:	e4 05 07 40 	macu.d	r0,r2,r5
8000c648:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c64c:	02 04       	add	r4,r1
8000c64e:	5c 05       	acr	r5
8000c650:	ea 03 15 02 	lsl	r3,r5,0x2
8000c654:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c658:	e8 02 15 02 	lsl	r2,r4,0x2
8000c65c:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c660:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c664:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c668:	02 02       	add	r2,r1
8000c66a:	5c 03       	acr	r3
8000c66c:	ed b3 00 1c 	bld	r3,0x1c
8000c670:	c0 90       	breq	8000c682 <__avr32_f64_div+0x12a>
8000c672:	a1 72       	lsl	r2,0x1
8000c674:	5c f3       	rol	r3
8000c676:	20 17       	sub	r7,1
8000c678:	a3 9a       	lsr	r10,0x3
8000c67a:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c67e:	a3 9b       	lsr	r11,0x3
8000c680:	c0 58       	rjmp	8000c68a <__avr32_f64_div+0x132>
8000c682:	a5 8a       	lsr	r10,0x4
8000c684:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c688:	a5 8b       	lsr	r11,0x4
8000c68a:	58 07       	cp.w	r7,0
8000c68c:	e0 8a 00 8b 	brle	8000c7a2 <__avr32_f64_div_res_subnormal>
8000c690:	e0 12 ff 00 	andl	r2,0xff00
8000c694:	e8 12 00 80 	orl	r2,0x80
8000c698:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c69c:	e4 09 07 40 	macu.d	r0,r2,r9
8000c6a0:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c6a4:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c6a8:	00 05       	add	r5,r0
8000c6aa:	f0 01 00 48 	adc	r8,r8,r1
8000c6ae:	5c 09       	acr	r9
8000c6b0:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c6b4:	58 04       	cp.w	r4,0
8000c6b6:	5c 25       	cpc	r5

8000c6b8 <__avr32_f64_div_round_subnormal>:
8000c6b8:	f4 08 13 00 	cpc	r8,r10
8000c6bc:	f6 09 13 00 	cpc	r9,r11
8000c6c0:	5f 36       	srlo	r6
8000c6c2:	f8 06 17 00 	moveq	r6,r12
8000c6c6:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c6ca:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c6ce:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c6d2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c6d6:	ed be 00 1f 	bld	lr,0x1f
8000c6da:	ef bb 00 1f 	bst	r11,0x1f
8000c6de:	0c 0a       	add	r10,r6
8000c6e0:	5c 0b       	acr	r11
8000c6e2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c6e6:	e4 1b 00 0f 	andh	r11,0xf
8000c6ea:	14 4b       	or	r11,r10
8000c6ec:	e0 81 00 a7 	brne	8000c83a <__avr32_f64_div_res_subnormal+0x98>
8000c6f0:	f2 06 16 14 	lsr	r6,r9,0x14
8000c6f4:	ab d6       	cbr	r6,0xb
8000c6f6:	e0 46 07 ff 	cp.w	r6,2047
8000c6fa:	e0 81 00 a4 	brne	8000c842 <__avr32_f64_div_res_subnormal+0xa0>
8000c6fe:	c9 e8       	rjmp	8000c83a <__avr32_f64_div_res_subnormal+0x98>
8000c700:	e4 19 00 0f 	andh	r9,0xf
8000c704:	10 49       	or	r9,r8
8000c706:	e0 81 00 9a 	brne	8000c83a <__avr32_f64_div_res_subnormal+0x98>
8000c70a:	c9 28       	rjmp	8000c82e <__avr32_f64_div_res_subnormal+0x8c>
8000c70c:	a3 7b       	lsl	r11,0x3
8000c70e:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c712:	a3 7a       	lsl	r10,0x3
8000c714:	f5 eb 10 04 	or	r4,r10,r11
8000c718:	e0 80 00 a0 	breq	8000c858 <__avr32_f64_div_op1_zero>
8000c71c:	f6 04 12 00 	clz	r4,r11
8000c720:	c1 70       	breq	8000c74e <__avr32_f64_div_round_subnormal+0x96>
8000c722:	c0 c3       	brcs	8000c73a <__avr32_f64_div_round_subnormal+0x82>
8000c724:	e8 05 11 20 	rsub	r5,r4,32
8000c728:	f6 04 09 4b 	lsl	r11,r11,r4
8000c72c:	f4 05 0a 45 	lsr	r5,r10,r5
8000c730:	0a 4b       	or	r11,r5
8000c732:	f4 04 09 4a 	lsl	r10,r10,r4
8000c736:	08 17       	sub	r7,r4
8000c738:	c0 b8       	rjmp	8000c74e <__avr32_f64_div_round_subnormal+0x96>
8000c73a:	f4 04 12 00 	clz	r4,r10
8000c73e:	f9 b4 03 00 	movlo	r4,0
8000c742:	f7 b4 02 e0 	subhs	r4,-32
8000c746:	f4 04 09 4b 	lsl	r11,r10,r4
8000c74a:	30 0a       	mov	r10,0
8000c74c:	08 17       	sub	r7,r4
8000c74e:	a3 8a       	lsr	r10,0x2
8000c750:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c754:	a3 8b       	lsr	r11,0x2
8000c756:	c1 1b       	rjmp	8000c578 <__avr32_f64_div+0x20>
8000c758:	a3 79       	lsl	r9,0x3
8000c75a:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c75e:	a3 78       	lsl	r8,0x3
8000c760:	f3 e8 10 04 	or	r4,r9,r8
8000c764:	c6 f0       	breq	8000c842 <__avr32_f64_div_res_subnormal+0xa0>
8000c766:	f2 04 12 00 	clz	r4,r9
8000c76a:	c1 70       	breq	8000c798 <__avr32_f64_div_round_subnormal+0xe0>
8000c76c:	c0 c3       	brcs	8000c784 <__avr32_f64_div_round_subnormal+0xcc>
8000c76e:	e8 05 11 20 	rsub	r5,r4,32
8000c772:	f2 04 09 49 	lsl	r9,r9,r4
8000c776:	f0 05 0a 45 	lsr	r5,r8,r5
8000c77a:	0a 49       	or	r9,r5
8000c77c:	f0 04 09 48 	lsl	r8,r8,r4
8000c780:	08 16       	sub	r6,r4
8000c782:	c0 b8       	rjmp	8000c798 <__avr32_f64_div_round_subnormal+0xe0>
8000c784:	f0 04 12 00 	clz	r4,r8
8000c788:	f9 b4 03 00 	movlo	r4,0
8000c78c:	f7 b4 02 e0 	subhs	r4,-32
8000c790:	f0 04 09 49 	lsl	r9,r8,r4
8000c794:	30 08       	mov	r8,0
8000c796:	08 16       	sub	r6,r4
8000c798:	a3 88       	lsr	r8,0x2
8000c79a:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c79e:	a3 89       	lsr	r9,0x2
8000c7a0:	cf ca       	rjmp	8000c598 <__avr32_f64_div+0x40>

8000c7a2 <__avr32_f64_div_res_subnormal>:
8000c7a2:	5c 37       	neg	r7
8000c7a4:	2f f7       	sub	r7,-1
8000c7a6:	f1 b7 04 c0 	satu	r7,0x6
8000c7aa:	e0 47 00 20 	cp.w	r7,32
8000c7ae:	c1 54       	brge	8000c7d8 <__avr32_f64_div_res_subnormal+0x36>
8000c7b0:	ee 06 11 20 	rsub	r6,r7,32
8000c7b4:	e4 07 0a 42 	lsr	r2,r2,r7
8000c7b8:	e6 06 09 4c 	lsl	r12,r3,r6
8000c7bc:	18 42       	or	r2,r12
8000c7be:	e6 07 0a 43 	lsr	r3,r3,r7
8000c7c2:	f4 06 09 41 	lsl	r1,r10,r6
8000c7c6:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c7ca:	f6 06 09 4c 	lsl	r12,r11,r6
8000c7ce:	18 4a       	or	r10,r12
8000c7d0:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c7d4:	30 00       	mov	r0,0
8000c7d6:	c1 58       	rjmp	8000c800 <__avr32_f64_div_res_subnormal+0x5e>
8000c7d8:	ee 06 11 20 	rsub	r6,r7,32
8000c7dc:	f9 b0 00 00 	moveq	r0,0
8000c7e0:	f9 bc 00 00 	moveq	r12,0
8000c7e4:	c0 50       	breq	8000c7ee <__avr32_f64_div_res_subnormal+0x4c>
8000c7e6:	f4 06 09 40 	lsl	r0,r10,r6
8000c7ea:	f6 06 09 4c 	lsl	r12,r11,r6
8000c7ee:	e6 07 0a 42 	lsr	r2,r3,r7
8000c7f2:	30 03       	mov	r3,0
8000c7f4:	f4 07 0a 41 	lsr	r1,r10,r7
8000c7f8:	18 41       	or	r1,r12
8000c7fa:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c7fe:	30 0b       	mov	r11,0
8000c800:	e0 12 ff 00 	andl	r2,0xff00
8000c804:	e8 12 00 80 	orl	r2,0x80
8000c808:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c80c:	e4 09 07 46 	macu.d	r6,r2,r9
8000c810:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c814:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c818:	0c 05       	add	r5,r6
8000c81a:	f0 07 00 48 	adc	r8,r8,r7
8000c81e:	5c 09       	acr	r9
8000c820:	30 07       	mov	r7,0
8000c822:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c826:	00 34       	cp.w	r4,r0
8000c828:	e2 05 13 00 	cpc	r5,r1
8000c82c:	c4 6b       	rjmp	8000c6b8 <__avr32_f64_div_round_subnormal>
8000c82e:	1c 9b       	mov	r11,lr
8000c830:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c834:	30 0a       	mov	r10,0
8000c836:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c83a:	3f fb       	mov	r11,-1
8000c83c:	30 0a       	mov	r10,0
8000c83e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c842:	f5 eb 10 04 	or	r4,r10,r11
8000c846:	c0 90       	breq	8000c858 <__avr32_f64_div_op1_zero>
8000c848:	1c 9b       	mov	r11,lr
8000c84a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c84e:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c852:	30 0a       	mov	r10,0
8000c854:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c858 <__avr32_f64_div_op1_zero>:
8000c858:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c85c:	ce f0       	breq	8000c83a <__avr32_f64_div_res_subnormal+0x98>
8000c85e:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c862:	e0 44 07 ff 	cp.w	r4,2047
8000c866:	ce 41       	brne	8000c82e <__avr32_f64_div_res_subnormal+0x8c>
8000c868:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c86c:	ce 10       	breq	8000c82e <__avr32_f64_div_res_subnormal+0x8c>
8000c86e:	ce 6b       	rjmp	8000c83a <__avr32_f64_div_res_subnormal+0x98>

8000c870 <__avr32_udiv64>:
8000c870:	d4 31       	pushm	r0-r7,lr
8000c872:	1a 97       	mov	r7,sp
8000c874:	20 3d       	sub	sp,12
8000c876:	10 9c       	mov	r12,r8
8000c878:	12 9e       	mov	lr,r9
8000c87a:	14 93       	mov	r3,r10
8000c87c:	58 09       	cp.w	r9,0
8000c87e:	e0 81 00 bd 	brne	8000c9f8 <__avr32_udiv64+0x188>
8000c882:	16 38       	cp.w	r8,r11
8000c884:	e0 88 00 40 	brls	8000c904 <__avr32_udiv64+0x94>
8000c888:	f0 08 12 00 	clz	r8,r8
8000c88c:	c0 d0       	breq	8000c8a6 <__avr32_udiv64+0x36>
8000c88e:	f6 08 09 4b 	lsl	r11,r11,r8
8000c892:	f0 09 11 20 	rsub	r9,r8,32
8000c896:	f8 08 09 4c 	lsl	r12,r12,r8
8000c89a:	f4 09 0a 49 	lsr	r9,r10,r9
8000c89e:	f4 08 09 43 	lsl	r3,r10,r8
8000c8a2:	f3 eb 10 0b 	or	r11,r9,r11
8000c8a6:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c8aa:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c8ae:	f6 0e 0d 00 	divu	r0,r11,lr
8000c8b2:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c8b6:	00 99       	mov	r9,r0
8000c8b8:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c8bc:	e0 0a 02 48 	mul	r8,r0,r10
8000c8c0:	10 3b       	cp.w	r11,r8
8000c8c2:	c0 a2       	brcc	8000c8d6 <__avr32_udiv64+0x66>
8000c8c4:	20 19       	sub	r9,1
8000c8c6:	18 0b       	add	r11,r12
8000c8c8:	18 3b       	cp.w	r11,r12
8000c8ca:	c0 63       	brcs	8000c8d6 <__avr32_udiv64+0x66>
8000c8cc:	10 3b       	cp.w	r11,r8
8000c8ce:	f7 b9 03 01 	sublo	r9,1
8000c8d2:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c8d6:	f6 08 01 01 	sub	r1,r11,r8
8000c8da:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c8de:	e2 0e 0d 00 	divu	r0,r1,lr
8000c8e2:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c8e6:	00 98       	mov	r8,r0
8000c8e8:	e0 0a 02 4a 	mul	r10,r0,r10
8000c8ec:	14 33       	cp.w	r3,r10
8000c8ee:	c0 82       	brcc	8000c8fe <__avr32_udiv64+0x8e>
8000c8f0:	20 18       	sub	r8,1
8000c8f2:	18 03       	add	r3,r12
8000c8f4:	18 33       	cp.w	r3,r12
8000c8f6:	c0 43       	brcs	8000c8fe <__avr32_udiv64+0x8e>
8000c8f8:	14 33       	cp.w	r3,r10
8000c8fa:	f7 b8 03 01 	sublo	r8,1
8000c8fe:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c902:	cd f8       	rjmp	8000cac0 <__avr32_udiv64+0x250>
8000c904:	58 08       	cp.w	r8,0
8000c906:	c0 51       	brne	8000c910 <__avr32_udiv64+0xa0>
8000c908:	30 19       	mov	r9,1
8000c90a:	f2 08 0d 08 	divu	r8,r9,r8
8000c90e:	10 9c       	mov	r12,r8
8000c910:	f8 06 12 00 	clz	r6,r12
8000c914:	c0 41       	brne	8000c91c <__avr32_udiv64+0xac>
8000c916:	18 1b       	sub	r11,r12
8000c918:	30 19       	mov	r9,1
8000c91a:	c4 08       	rjmp	8000c99a <__avr32_udiv64+0x12a>
8000c91c:	ec 01 11 20 	rsub	r1,r6,32
8000c920:	f4 01 0a 49 	lsr	r9,r10,r1
8000c924:	f8 06 09 4c 	lsl	r12,r12,r6
8000c928:	f6 06 09 48 	lsl	r8,r11,r6
8000c92c:	f6 01 0a 41 	lsr	r1,r11,r1
8000c930:	f3 e8 10 08 	or	r8,r9,r8
8000c934:	f8 03 16 10 	lsr	r3,r12,0x10
8000c938:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c93c:	e2 03 0d 00 	divu	r0,r1,r3
8000c940:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c944:	00 9e       	mov	lr,r0
8000c946:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c94a:	e0 05 02 49 	mul	r9,r0,r5
8000c94e:	12 3b       	cp.w	r11,r9
8000c950:	c0 a2       	brcc	8000c964 <__avr32_udiv64+0xf4>
8000c952:	20 1e       	sub	lr,1
8000c954:	18 0b       	add	r11,r12
8000c956:	18 3b       	cp.w	r11,r12
8000c958:	c0 63       	brcs	8000c964 <__avr32_udiv64+0xf4>
8000c95a:	12 3b       	cp.w	r11,r9
8000c95c:	f7 be 03 01 	sublo	lr,1
8000c960:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c964:	12 1b       	sub	r11,r9
8000c966:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c96a:	f6 03 0d 02 	divu	r2,r11,r3
8000c96e:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c972:	04 99       	mov	r9,r2
8000c974:	e4 05 02 4b 	mul	r11,r2,r5
8000c978:	16 38       	cp.w	r8,r11
8000c97a:	c0 a2       	brcc	8000c98e <__avr32_udiv64+0x11e>
8000c97c:	20 19       	sub	r9,1
8000c97e:	18 08       	add	r8,r12
8000c980:	18 38       	cp.w	r8,r12
8000c982:	c0 63       	brcs	8000c98e <__avr32_udiv64+0x11e>
8000c984:	16 38       	cp.w	r8,r11
8000c986:	f7 b9 03 01 	sublo	r9,1
8000c98a:	f1 dc e3 08 	addcs	r8,r8,r12
8000c98e:	f4 06 09 43 	lsl	r3,r10,r6
8000c992:	f0 0b 01 0b 	sub	r11,r8,r11
8000c996:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c99a:	f8 06 16 10 	lsr	r6,r12,0x10
8000c99e:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c9a2:	f6 06 0d 00 	divu	r0,r11,r6
8000c9a6:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c9aa:	00 9a       	mov	r10,r0
8000c9ac:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c9b0:	e0 0e 02 48 	mul	r8,r0,lr
8000c9b4:	10 3b       	cp.w	r11,r8
8000c9b6:	c0 a2       	brcc	8000c9ca <__avr32_udiv64+0x15a>
8000c9b8:	20 1a       	sub	r10,1
8000c9ba:	18 0b       	add	r11,r12
8000c9bc:	18 3b       	cp.w	r11,r12
8000c9be:	c0 63       	brcs	8000c9ca <__avr32_udiv64+0x15a>
8000c9c0:	10 3b       	cp.w	r11,r8
8000c9c2:	f7 ba 03 01 	sublo	r10,1
8000c9c6:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c9ca:	f6 08 01 01 	sub	r1,r11,r8
8000c9ce:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c9d2:	e2 06 0d 00 	divu	r0,r1,r6
8000c9d6:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c9da:	00 98       	mov	r8,r0
8000c9dc:	e0 0e 02 4b 	mul	r11,r0,lr
8000c9e0:	16 33       	cp.w	r3,r11
8000c9e2:	c0 82       	brcc	8000c9f2 <__avr32_udiv64+0x182>
8000c9e4:	20 18       	sub	r8,1
8000c9e6:	18 03       	add	r3,r12
8000c9e8:	18 33       	cp.w	r3,r12
8000c9ea:	c0 43       	brcs	8000c9f2 <__avr32_udiv64+0x182>
8000c9ec:	16 33       	cp.w	r3,r11
8000c9ee:	f7 b8 03 01 	sublo	r8,1
8000c9f2:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c9f6:	c6 98       	rjmp	8000cac8 <__avr32_udiv64+0x258>
8000c9f8:	16 39       	cp.w	r9,r11
8000c9fa:	e0 8b 00 65 	brhi	8000cac4 <__avr32_udiv64+0x254>
8000c9fe:	f2 09 12 00 	clz	r9,r9
8000ca02:	c0 b1       	brne	8000ca18 <__avr32_udiv64+0x1a8>
8000ca04:	10 3a       	cp.w	r10,r8
8000ca06:	5f 2a       	srhs	r10
8000ca08:	1c 3b       	cp.w	r11,lr
8000ca0a:	5f b8       	srhi	r8
8000ca0c:	10 4a       	or	r10,r8
8000ca0e:	f2 0a 18 00 	cp.b	r10,r9
8000ca12:	c5 90       	breq	8000cac4 <__avr32_udiv64+0x254>
8000ca14:	30 18       	mov	r8,1
8000ca16:	c5 98       	rjmp	8000cac8 <__avr32_udiv64+0x258>
8000ca18:	f0 09 09 46 	lsl	r6,r8,r9
8000ca1c:	f2 03 11 20 	rsub	r3,r9,32
8000ca20:	fc 09 09 4e 	lsl	lr,lr,r9
8000ca24:	f0 03 0a 48 	lsr	r8,r8,r3
8000ca28:	f6 09 09 4c 	lsl	r12,r11,r9
8000ca2c:	f4 03 0a 42 	lsr	r2,r10,r3
8000ca30:	ef 46 ff f4 	st.w	r7[-12],r6
8000ca34:	f6 03 0a 43 	lsr	r3,r11,r3
8000ca38:	18 42       	or	r2,r12
8000ca3a:	f1 ee 10 0c 	or	r12,r8,lr
8000ca3e:	f8 01 16 10 	lsr	r1,r12,0x10
8000ca42:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000ca46:	e6 01 0d 04 	divu	r4,r3,r1
8000ca4a:	e4 03 16 10 	lsr	r3,r2,0x10
8000ca4e:	08 9e       	mov	lr,r4
8000ca50:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000ca54:	e8 06 02 48 	mul	r8,r4,r6
8000ca58:	10 33       	cp.w	r3,r8
8000ca5a:	c0 a2       	brcc	8000ca6e <__avr32_udiv64+0x1fe>
8000ca5c:	20 1e       	sub	lr,1
8000ca5e:	18 03       	add	r3,r12
8000ca60:	18 33       	cp.w	r3,r12
8000ca62:	c0 63       	brcs	8000ca6e <__avr32_udiv64+0x1fe>
8000ca64:	10 33       	cp.w	r3,r8
8000ca66:	f7 be 03 01 	sublo	lr,1
8000ca6a:	e7 dc e3 03 	addcs	r3,r3,r12
8000ca6e:	10 13       	sub	r3,r8
8000ca70:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000ca74:	e6 01 0d 00 	divu	r0,r3,r1
8000ca78:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000ca7c:	00 98       	mov	r8,r0
8000ca7e:	e0 06 02 46 	mul	r6,r0,r6
8000ca82:	0c 3b       	cp.w	r11,r6
8000ca84:	c0 a2       	brcc	8000ca98 <__avr32_udiv64+0x228>
8000ca86:	20 18       	sub	r8,1
8000ca88:	18 0b       	add	r11,r12
8000ca8a:	18 3b       	cp.w	r11,r12
8000ca8c:	c0 63       	brcs	8000ca98 <__avr32_udiv64+0x228>
8000ca8e:	0c 3b       	cp.w	r11,r6
8000ca90:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ca94:	f7 b8 03 01 	sublo	r8,1
8000ca98:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000ca9c:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000caa0:	0c 1b       	sub	r11,r6
8000caa2:	f0 04 06 42 	mulu.d	r2,r8,r4
8000caa6:	06 95       	mov	r5,r3
8000caa8:	16 35       	cp.w	r5,r11
8000caaa:	e0 8b 00 0a 	brhi	8000cabe <__avr32_udiv64+0x24e>
8000caae:	5f 0b       	sreq	r11
8000cab0:	f4 09 09 49 	lsl	r9,r10,r9
8000cab4:	12 32       	cp.w	r2,r9
8000cab6:	5f b9       	srhi	r9
8000cab8:	f7 e9 00 09 	and	r9,r11,r9
8000cabc:	c0 60       	breq	8000cac8 <__avr32_udiv64+0x258>
8000cabe:	20 18       	sub	r8,1
8000cac0:	30 09       	mov	r9,0
8000cac2:	c0 38       	rjmp	8000cac8 <__avr32_udiv64+0x258>
8000cac4:	30 09       	mov	r9,0
8000cac6:	12 98       	mov	r8,r9
8000cac8:	10 9a       	mov	r10,r8
8000caca:	12 93       	mov	r3,r9
8000cacc:	10 92       	mov	r2,r8
8000cace:	12 9b       	mov	r11,r9
8000cad0:	2f dd       	sub	sp,-12
8000cad2:	d8 32       	popm	r0-r7,pc

8000cad4 <__avr32_umod64>:
8000cad4:	d4 31       	pushm	r0-r7,lr
8000cad6:	1a 97       	mov	r7,sp
8000cad8:	20 3d       	sub	sp,12
8000cada:	10 9c       	mov	r12,r8
8000cadc:	12 95       	mov	r5,r9
8000cade:	14 9e       	mov	lr,r10
8000cae0:	16 91       	mov	r1,r11
8000cae2:	16 96       	mov	r6,r11
8000cae4:	58 09       	cp.w	r9,0
8000cae6:	e0 81 00 81 	brne	8000cbe8 <__avr32_umod64+0x114>
8000caea:	16 38       	cp.w	r8,r11
8000caec:	e0 88 00 12 	brls	8000cb10 <__avr32_umod64+0x3c>
8000caf0:	f0 08 12 00 	clz	r8,r8
8000caf4:	c4 e0       	breq	8000cb90 <__avr32_umod64+0xbc>
8000caf6:	f6 08 09 46 	lsl	r6,r11,r8
8000cafa:	f8 08 09 4c 	lsl	r12,r12,r8
8000cafe:	f0 0b 11 20 	rsub	r11,r8,32
8000cb02:	f4 08 09 4e 	lsl	lr,r10,r8
8000cb06:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000cb0a:	f7 e6 10 06 	or	r6,r11,r6
8000cb0e:	c4 18       	rjmp	8000cb90 <__avr32_umod64+0xbc>
8000cb10:	58 08       	cp.w	r8,0
8000cb12:	c0 51       	brne	8000cb1c <__avr32_umod64+0x48>
8000cb14:	30 19       	mov	r9,1
8000cb16:	f2 08 0d 08 	divu	r8,r9,r8
8000cb1a:	10 9c       	mov	r12,r8
8000cb1c:	f8 08 12 00 	clz	r8,r12
8000cb20:	c0 31       	brne	8000cb26 <__avr32_umod64+0x52>
8000cb22:	18 16       	sub	r6,r12
8000cb24:	c3 68       	rjmp	8000cb90 <__avr32_umod64+0xbc>
8000cb26:	f0 03 11 20 	rsub	r3,r8,32
8000cb2a:	f4 03 0a 4b 	lsr	r11,r10,r3
8000cb2e:	f8 08 09 4c 	lsl	r12,r12,r8
8000cb32:	ec 08 09 49 	lsl	r9,r6,r8
8000cb36:	ec 03 0a 43 	lsr	r3,r6,r3
8000cb3a:	f7 e9 10 09 	or	r9,r11,r9
8000cb3e:	f8 05 16 10 	lsr	r5,r12,0x10
8000cb42:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000cb46:	e6 05 0d 02 	divu	r2,r3,r5
8000cb4a:	f2 0e 16 10 	lsr	lr,r9,0x10
8000cb4e:	ec 02 02 4b 	mul	r11,r6,r2
8000cb52:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000cb56:	16 3e       	cp.w	lr,r11
8000cb58:	c0 72       	brcc	8000cb66 <__avr32_umod64+0x92>
8000cb5a:	18 0e       	add	lr,r12
8000cb5c:	18 3e       	cp.w	lr,r12
8000cb5e:	c0 43       	brcs	8000cb66 <__avr32_umod64+0x92>
8000cb60:	16 3e       	cp.w	lr,r11
8000cb62:	fd dc e3 0e 	addcs	lr,lr,r12
8000cb66:	fc 0b 01 03 	sub	r3,lr,r11
8000cb6a:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000cb6e:	e6 05 0d 02 	divu	r2,r3,r5
8000cb72:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000cb76:	a5 36       	mul	r6,r2
8000cb78:	0c 39       	cp.w	r9,r6
8000cb7a:	c0 72       	brcc	8000cb88 <__avr32_umod64+0xb4>
8000cb7c:	18 09       	add	r9,r12
8000cb7e:	18 39       	cp.w	r9,r12
8000cb80:	c0 43       	brcs	8000cb88 <__avr32_umod64+0xb4>
8000cb82:	0c 39       	cp.w	r9,r6
8000cb84:	f3 dc e3 09 	addcs	r9,r9,r12
8000cb88:	f2 06 01 06 	sub	r6,r9,r6
8000cb8c:	f4 08 09 4e 	lsl	lr,r10,r8
8000cb90:	f8 0a 16 10 	lsr	r10,r12,0x10
8000cb94:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000cb98:	ec 0a 0d 02 	divu	r2,r6,r10
8000cb9c:	fc 09 16 10 	lsr	r9,lr,0x10
8000cba0:	ea 02 02 4b 	mul	r11,r5,r2
8000cba4:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000cba8:	16 39       	cp.w	r9,r11
8000cbaa:	c0 72       	brcc	8000cbb8 <__avr32_umod64+0xe4>
8000cbac:	18 09       	add	r9,r12
8000cbae:	18 39       	cp.w	r9,r12
8000cbb0:	c0 43       	brcs	8000cbb8 <__avr32_umod64+0xe4>
8000cbb2:	16 39       	cp.w	r9,r11
8000cbb4:	f3 dc e3 09 	addcs	r9,r9,r12
8000cbb8:	f2 0b 01 0b 	sub	r11,r9,r11
8000cbbc:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000cbc0:	f6 0a 0d 0a 	divu	r10,r11,r10
8000cbc4:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000cbc8:	ea 0a 02 4a 	mul	r10,r5,r10
8000cbcc:	14 3e       	cp.w	lr,r10
8000cbce:	c0 72       	brcc	8000cbdc <__avr32_umod64+0x108>
8000cbd0:	18 0e       	add	lr,r12
8000cbd2:	18 3e       	cp.w	lr,r12
8000cbd4:	c0 43       	brcs	8000cbdc <__avr32_umod64+0x108>
8000cbd6:	14 3e       	cp.w	lr,r10
8000cbd8:	fd dc e3 0e 	addcs	lr,lr,r12
8000cbdc:	fc 0a 01 0a 	sub	r10,lr,r10
8000cbe0:	30 0b       	mov	r11,0
8000cbe2:	f4 08 0a 4a 	lsr	r10,r10,r8
8000cbe6:	c7 b8       	rjmp	8000ccdc <__avr32_umod64+0x208>
8000cbe8:	16 39       	cp.w	r9,r11
8000cbea:	e0 8b 00 79 	brhi	8000ccdc <__avr32_umod64+0x208>
8000cbee:	f2 09 12 00 	clz	r9,r9
8000cbf2:	c1 21       	brne	8000cc16 <__avr32_umod64+0x142>
8000cbf4:	10 3a       	cp.w	r10,r8
8000cbf6:	5f 2b       	srhs	r11
8000cbf8:	0a 31       	cp.w	r1,r5
8000cbfa:	5f ba       	srhi	r10
8000cbfc:	f7 ea 10 0a 	or	r10,r11,r10
8000cc00:	f2 0a 18 00 	cp.b	r10,r9
8000cc04:	c0 60       	breq	8000cc10 <__avr32_umod64+0x13c>
8000cc06:	fc 08 01 0c 	sub	r12,lr,r8
8000cc0a:	e2 05 01 46 	sbc	r6,r1,r5
8000cc0e:	18 9e       	mov	lr,r12
8000cc10:	0c 9b       	mov	r11,r6
8000cc12:	1c 9a       	mov	r10,lr
8000cc14:	c6 48       	rjmp	8000ccdc <__avr32_umod64+0x208>
8000cc16:	ea 09 09 4c 	lsl	r12,r5,r9
8000cc1a:	f2 06 11 20 	rsub	r6,r9,32
8000cc1e:	f6 09 09 4b 	lsl	r11,r11,r9
8000cc22:	f0 09 09 42 	lsl	r2,r8,r9
8000cc26:	ef 46 ff f4 	st.w	r7[-12],r6
8000cc2a:	f0 06 0a 48 	lsr	r8,r8,r6
8000cc2e:	18 48       	or	r8,r12
8000cc30:	e2 06 0a 4c 	lsr	r12,r1,r6
8000cc34:	f4 09 09 43 	lsl	r3,r10,r9
8000cc38:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000cc3c:	f4 06 0a 4a 	lsr	r10,r10,r6
8000cc40:	16 4a       	or	r10,r11
8000cc42:	f0 0b 16 10 	lsr	r11,r8,0x10
8000cc46:	f8 0b 0d 04 	divu	r4,r12,r11
8000cc4a:	f4 0c 16 10 	lsr	r12,r10,0x10
8000cc4e:	08 91       	mov	r1,r4
8000cc50:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000cc54:	e8 0e 02 46 	mul	r6,r4,lr
8000cc58:	0c 3c       	cp.w	r12,r6
8000cc5a:	c0 a2       	brcc	8000cc6e <__avr32_umod64+0x19a>
8000cc5c:	20 11       	sub	r1,1
8000cc5e:	10 0c       	add	r12,r8
8000cc60:	10 3c       	cp.w	r12,r8
8000cc62:	c0 63       	brcs	8000cc6e <__avr32_umod64+0x19a>
8000cc64:	0c 3c       	cp.w	r12,r6
8000cc66:	f7 b1 03 01 	sublo	r1,1
8000cc6a:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000cc6e:	0c 1c       	sub	r12,r6
8000cc70:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000cc74:	f8 0b 0d 04 	divu	r4,r12,r11
8000cc78:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000cc7c:	08 96       	mov	r6,r4
8000cc7e:	e8 0e 02 4e 	mul	lr,r4,lr
8000cc82:	1c 3b       	cp.w	r11,lr
8000cc84:	c0 a2       	brcc	8000cc98 <__avr32_umod64+0x1c4>
8000cc86:	20 16       	sub	r6,1
8000cc88:	10 0b       	add	r11,r8
8000cc8a:	10 3b       	cp.w	r11,r8
8000cc8c:	c0 63       	brcs	8000cc98 <__avr32_umod64+0x1c4>
8000cc8e:	1c 3b       	cp.w	r11,lr
8000cc90:	f7 b6 03 01 	sublo	r6,1
8000cc94:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000cc98:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000cc9c:	1c 1b       	sub	r11,lr
8000cc9e:	e2 02 06 40 	mulu.d	r0,r1,r2
8000cca2:	00 9e       	mov	lr,r0
8000cca4:	02 9c       	mov	r12,r1
8000cca6:	16 3c       	cp.w	r12,r11
8000cca8:	e0 8b 00 08 	brhi	8000ccb8 <__avr32_umod64+0x1e4>
8000ccac:	5f 06       	sreq	r6
8000ccae:	06 30       	cp.w	r0,r3
8000ccb0:	5f ba       	srhi	r10
8000ccb2:	ed ea 00 0a 	and	r10,r6,r10
8000ccb6:	c0 60       	breq	8000ccc2 <__avr32_umod64+0x1ee>
8000ccb8:	fc 02 01 04 	sub	r4,lr,r2
8000ccbc:	f8 08 01 4c 	sbc	r12,r12,r8
8000ccc0:	08 9e       	mov	lr,r4
8000ccc2:	e6 0e 01 0a 	sub	r10,r3,lr
8000ccc6:	f6 0c 01 4c 	sbc	r12,r11,r12
8000ccca:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000ccce:	f8 09 0a 4b 	lsr	r11,r12,r9
8000ccd2:	f4 09 0a 4a 	lsr	r10,r10,r9
8000ccd6:	f8 01 09 4c 	lsl	r12,r12,r1
8000ccda:	18 4a       	or	r10,r12
8000ccdc:	2f dd       	sub	sp,-12
8000ccde:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000ce00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000ce00:	c0 08       	rjmp	8000ce00 <_evba>
	...

8000ce04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000ce04:	c0 08       	rjmp	8000ce04 <_handle_TLB_Multiple_Hit>
	...

8000ce08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000ce08:	c0 08       	rjmp	8000ce08 <_handle_Bus_Error_Data_Fetch>
	...

8000ce0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000ce0c:	c0 08       	rjmp	8000ce0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000ce10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000ce10:	c0 08       	rjmp	8000ce10 <_handle_NMI>
	...

8000ce14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000ce14:	c0 08       	rjmp	8000ce14 <_handle_Instruction_Address>
	...

8000ce18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000ce18:	c0 08       	rjmp	8000ce18 <_handle_ITLB_Protection>
	...

8000ce1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000ce1c:	c0 08       	rjmp	8000ce1c <_handle_Breakpoint>
	...

8000ce20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000ce20:	c0 08       	rjmp	8000ce20 <_handle_Illegal_Opcode>
	...

8000ce24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000ce24:	c0 08       	rjmp	8000ce24 <_handle_Unimplemented_Instruction>
	...

8000ce28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000ce28:	c0 08       	rjmp	8000ce28 <_handle_Privilege_Violation>
	...

8000ce2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000ce2c:	c0 08       	rjmp	8000ce2c <_handle_Floating_Point>
	...

8000ce30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000ce30:	c0 08       	rjmp	8000ce30 <_handle_Coprocessor_Absent>
	...

8000ce34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000ce34:	c0 08       	rjmp	8000ce34 <_handle_Data_Address_Read>
	...

8000ce38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000ce38:	c0 08       	rjmp	8000ce38 <_handle_Data_Address_Write>
	...

8000ce3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000ce3c:	c0 08       	rjmp	8000ce3c <_handle_DTLB_Protection_Read>
	...

8000ce40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000ce40:	c0 08       	rjmp	8000ce40 <_handle_DTLB_Protection_Write>
	...

8000ce44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000ce44:	c0 08       	rjmp	8000ce44 <_handle_DTLB_Modified>
	...

8000ce50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000ce50:	c0 08       	rjmp	8000ce50 <_handle_ITLB_Miss>
	...

8000ce60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000ce60:	c0 08       	rjmp	8000ce60 <_handle_DTLB_Miss_Read>
	...

8000ce70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000ce70:	c0 08       	rjmp	8000ce70 <_handle_DTLB_Miss_Write>
	...

8000cf00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000cf00:	fe cf 70 c0 	sub	pc,pc,28864

8000cf04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000cf04:	30 0c       	mov	r12,0
8000cf06:	fe b0 c3 03 	rcall	8000550c <_get_interrupt_handler>
8000cf0a:	58 0c       	cp.w	r12,0
8000cf0c:	f8 0f 17 10 	movne	pc,r12
8000cf10:	d6 03       	rete

8000cf12 <_int1>:
8000cf12:	30 1c       	mov	r12,1
8000cf14:	fe b0 c2 fc 	rcall	8000550c <_get_interrupt_handler>
8000cf18:	58 0c       	cp.w	r12,0
8000cf1a:	f8 0f 17 10 	movne	pc,r12
8000cf1e:	d6 03       	rete

8000cf20 <_int2>:
8000cf20:	30 2c       	mov	r12,2
8000cf22:	fe b0 c2 f5 	rcall	8000550c <_get_interrupt_handler>
8000cf26:	58 0c       	cp.w	r12,0
8000cf28:	f8 0f 17 10 	movne	pc,r12
8000cf2c:	d6 03       	rete

8000cf2e <_int3>:
8000cf2e:	30 3c       	mov	r12,3
8000cf30:	fe b0 c2 ee 	rcall	8000550c <_get_interrupt_handler>
8000cf34:	58 0c       	cp.w	r12,0
8000cf36:	f8 0f 17 10 	movne	pc,r12
8000cf3a:	d6 03       	rete

8000cf3c <ipr_val>:
8000cf3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000cf4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cffc:	d7 03 d7 03                                         ....
