
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000b3a8  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000d400  8000d400  0000d800  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000013dc  8000d600  8000d600  0000da00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  8000e9dc  8000e9dc  0000eddc  2**0
                  ALLOC
  6 .data         00000a48  00000004  8000e9e0  0000f004  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a4c  8000f428  0000fa4c  2**0
                  ALLOC
  8 .bss          000049e8  00000a50  8000f428  0000fa50  2**2
                  ALLOC
  9 .comment      00000030  00000000  00000000  0000fa4c  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00001668  00000000  00000000  0000fa80  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_pubnames 00003568  00000000  00000000  000110e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   0002c4af  00000000  00000000  00014650  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 000073c8  00000000  00000000  00040aff  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   0000d632  00000000  00000000  00047ec7  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00003d08  00000000  00000000  000554fc  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00007ef4  00000000  00000000  00059204  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    0000f2f9  00000000  00000000  000610f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 19 .debug_ranges 00001728  00000000  00000000  000703f8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf be 4c 	sub	pc,pc,-16820

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0e 00       	add	r0,r7

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 70       	tst	r0,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384//1024//800//384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 04       	add	r4,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	3d 6c       	mov	r12,-42
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 90       	sub	r0,9
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	20 a4       	sub	r4,10
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	2a 00       	sub	r0,-96
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	d6 00       	acall	0x60
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	27 0c       	sub	r12,112
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	72 bc       	ld.w	r12,r9[0x2c]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 60       	and	r0,r5

80002090 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002090:	d4 01       	pushm	lr
  log("R");
80002092:	48 3c       	lddpc	r12,8000209c <app_payload_tx_proc+0xc>
80002094:	f0 1f 00 03 	mcall	800020a0 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002098:	d8 02       	popm	pc
8000209a:	00 00       	add	r0,r0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	d6 08       	*unknown*
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	76 80       	ld.w	r0,r11[0x20]

800020a4 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
800020a4:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
800020a6:	48 99       	lddpc	r9,800020c8 <app_payload_rx_proc+0x24>
800020a8:	13 88       	ld.ub	r8,r9[0x0]
800020aa:	2f f8       	sub	r8,-1
800020ac:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
800020ae:	30 39       	mov	r9,3
800020b0:	f2 08 18 00 	cp.b	r8,r9
800020b4:	c0 71       	brne	800020c2 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
800020b6:	30 09       	mov	r9,0
800020b8:	48 48       	lddpc	r8,800020c8 <app_payload_rx_proc+0x24>
800020ba:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800020bc:	48 4c       	lddpc	r12,800020cc <app_payload_rx_proc+0x28>
800020be:	f0 1f 00 05 	mcall	800020d0 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
800020c2:	48 58       	lddpc	r8,800020d4 <app_payload_rx_proc+0x30>
800020c4:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
800020c6:	d8 02       	popm	pc
800020c8:	00 00       	add	r0,r0
800020ca:	0a 6b       	and	r11,r5
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	d6 0c       	*unknown*
800020d0:	80 00       	ld.sh	r0,r0[0x0]
800020d2:	76 80       	ld.w	r0,r11[0x20]
800020d4:	00 00       	add	r0,r0
800020d6:	0a 64       	and	r4,r5

800020d8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020da:	48 3c       	lddpc	r12,800020e4 <FD_brdcst_func+0xc>
800020dc:	f0 1f 00 03 	mcall	800020e8 <FD_brdcst_func+0x10>
	
}
800020e0:	d8 02       	popm	pc
800020e2:	00 00       	add	r0,r0
800020e4:	80 00       	ld.sh	r0,r0[0x0]
800020e6:	d6 18       	*unknown*
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	76 80       	ld.w	r0,r11[0x20]

800020ec <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020ec:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ee:	48 3c       	lddpc	r12,800020f8 <FD_reply_func+0xc>
800020f0:	f0 1f 00 03 	mcall	800020fc <FD_reply_func+0x10>
	
	
}
800020f4:	d8 02       	popm	pc
800020f6:	00 00       	add	r0,r0
800020f8:	80 00       	ld.sh	r0,r0[0x0]
800020fa:	d6 38       	*unknown*
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	76 80       	ld.w	r0,r11[0x20]

80002100 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002100:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002102:	48 3c       	lddpc	r12,8000210c <FD_request_func+0xc>
80002104:	f0 1f 00 03 	mcall	80002110 <FD_request_func+0x10>
	
	
}
80002108:	d8 02       	popm	pc
8000210a:	00 00       	add	r0,r0
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	d6 54       	*unknown*
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	76 80       	ld.w	r0,r11[0x20]

80002114 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002114:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002116:	48 3c       	lddpc	r12,80002120 <EnOB_brdcst_func+0xc>
80002118:	f0 1f 00 03 	mcall	80002124 <EnOB_brdcst_func+0x10>
}
8000211c:	d8 02       	popm	pc
8000211e:	00 00       	add	r0,r0
80002120:	80 00       	ld.sh	r0,r0[0x0]
80002122:	d6 70       	acall	0x67
80002124:	80 00       	ld.sh	r0,r0[0x0]
80002126:	76 80       	ld.w	r0,r11[0x20]

80002128 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002128:	eb cd 40 80 	pushm	r7,lr
8000212c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000212e:	19 a9       	ld.ub	r9,r12[0x2]
80002130:	30 08       	mov	r8,0
80002132:	f0 09 18 00 	cp.b	r9,r8
80002136:	c1 91       	brne	80002168 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002138:	19 b8       	ld.ub	r8,r12[0x3]
8000213a:	30 19       	mov	r9,1
8000213c:	f2 08 18 00 	cp.b	r8,r9
80002140:	c0 61       	brne	8000214c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002142:	49 0c       	lddpc	r12,80002180 <EnOB_reply_func+0x58>
80002144:	f0 1f 00 10 	mcall	80002184 <EnOB_reply_func+0x5c>
80002148:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000214c:	58 08       	cp.w	r8,0
8000214e:	c0 61       	brne	8000215a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002150:	48 ec       	lddpc	r12,80002188 <EnOB_reply_func+0x60>
80002152:	f0 1f 00 0d 	mcall	80002184 <EnOB_reply_func+0x5c>
80002156:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000215a:	1a d8       	st.w	--sp,r8
8000215c:	48 cc       	lddpc	r12,8000218c <EnOB_reply_func+0x64>
8000215e:	f0 1f 00 0a 	mcall	80002184 <EnOB_reply_func+0x5c>
80002162:	2f fd       	sub	sp,-4
80002164:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002168:	48 ac       	lddpc	r12,80002190 <EnOB_reply_func+0x68>
8000216a:	f0 1f 00 07 	mcall	80002184 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000216e:	0f a8       	ld.ub	r8,r7[0x2]
80002170:	1a d8       	st.w	--sp,r8
80002172:	48 9c       	lddpc	r12,80002194 <EnOB_reply_func+0x6c>
80002174:	f0 1f 00 04 	mcall	80002184 <EnOB_reply_func+0x5c>
80002178:	2f fd       	sub	sp,-4
8000217a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	d6 88       	*unknown*
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	76 80       	ld.w	r0,r11[0x20]
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	d6 a0       	acall	0x6a
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	d6 b4       	*unknown*
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	d6 cc       	*unknown*
80002194:	80 00       	ld.sh	r0,r0[0x0]
80002196:	d6 e8       	*unknown*

80002198 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002198:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
8000219a:	19 a9       	ld.ub	r9,r12[0x2]
8000219c:	31 18       	mov	r8,17
8000219e:	f0 09 18 00 	cp.b	r9,r8
800021a2:	c0 41       	brne	800021aa <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021a4:	48 2c       	lddpc	r12,800021ac <SingleDetection_brdcst_func+0x14>
800021a6:	f0 1f 00 03 	mcall	800021b0 <SingleDetection_brdcst_func+0x18>
800021aa:	d8 02       	popm	pc
800021ac:	80 00       	ld.sh	r0,r0[0x0]
800021ae:	d7 00       	acall	0x70
800021b0:	80 00       	ld.sh	r0,r0[0x0]
800021b2:	76 80       	ld.w	r0,r11[0x20]

800021b4 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021b4:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021b6:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021ba:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021bc:	4a bc       	lddpc	r12,80002268 <ButtonConfig_brdcst_func+0xb4>
800021be:	f0 1f 00 2c 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021c2:	0f 88       	ld.ub	r8,r7[0x0]
800021c4:	1a d8       	st.w	--sp,r8
800021c6:	4a bc       	lddpc	r12,80002270 <ButtonConfig_brdcst_func+0xbc>
800021c8:	f0 1f 00 29 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021cc:	1a d5       	st.w	--sp,r5
800021ce:	4a ac       	lddpc	r12,80002274 <ButtonConfig_brdcst_func+0xc0>
800021d0:	f0 1f 00 27 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021d4:	0f a8       	ld.ub	r8,r7[0x2]
800021d6:	1a d8       	st.w	--sp,r8
800021d8:	4a 8c       	lddpc	r12,80002278 <ButtonConfig_brdcst_func+0xc4>
800021da:	f0 1f 00 25 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021de:	2f dd       	sub	sp,-12
800021e0:	58 05       	cp.w	r5,0
800021e2:	c4 10       	breq	80002264 <ButtonConfig_brdcst_func+0xb0>
800021e4:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021e6:	4a 64       	lddpc	r4,8000227c <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021e8:	4a 63       	lddpc	r3,80002280 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021ea:	4a 72       	lddpc	r2,80002284 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021ec:	4a 71       	lddpc	r1,80002288 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021ee:	4a 80       	lddpc	r0,8000228c <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021f0:	0f b9       	ld.ub	r9,r7[0x3]
800021f2:	0f c8       	ld.ub	r8,r7[0x4]
800021f4:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021f8:	1a d8       	st.w	--sp,r8
800021fa:	1a d6       	st.w	--sp,r6
800021fc:	08 9c       	mov	r12,r4
800021fe:	f0 1f 00 1c 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002202:	0f d9       	ld.ub	r9,r7[0x5]
80002204:	0f e8       	ld.ub	r8,r7[0x6]
80002206:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000220a:	1a d8       	st.w	--sp,r8
8000220c:	1a d6       	st.w	--sp,r6
8000220e:	06 9c       	mov	r12,r3
80002210:	f0 1f 00 17 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002214:	0f f9       	ld.ub	r9,r7[0x7]
80002216:	ef 38 00 08 	ld.ub	r8,r7[8]
8000221a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000221e:	1a d8       	st.w	--sp,r8
80002220:	1a d6       	st.w	--sp,r6
80002222:	04 9c       	mov	r12,r2
80002224:	f0 1f 00 12 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002228:	ef 39 00 09 	ld.ub	r9,r7[9]
8000222c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002230:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002234:	1a d8       	st.w	--sp,r8
80002236:	1a d6       	st.w	--sp,r6
80002238:	02 9c       	mov	r12,r1
8000223a:	f0 1f 00 0d 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000223e:	2f 8d       	sub	sp,-32
80002240:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002244:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002248:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000224c:	1a d8       	st.w	--sp,r8
8000224e:	1a d6       	st.w	--sp,r6
80002250:	00 9c       	mov	r12,r0
80002252:	f0 1f 00 07 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
80002256:	2f f6       	sub	r6,-1
80002258:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000225a:	2f ed       	sub	sp,-8
8000225c:	ec 05 18 00 	cp.b	r5,r6
80002260:	fe 9b ff c8 	brhi	800021f0 <ButtonConfig_brdcst_func+0x3c>
80002264:	d8 32       	popm	r0-r7,pc
80002266:	00 00       	add	r0,r0
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	d7 14       	*unknown*
8000226c:	80 00       	ld.sh	r0,r0[0x0]
8000226e:	76 80       	ld.w	r0,r11[0x20]
80002270:	80 00       	ld.sh	r0,r0[0x0]
80002272:	d7 34       	*unknown*
80002274:	80 00       	ld.sh	r0,r0[0x0]
80002276:	d7 48       	*unknown*
80002278:	80 00       	ld.sh	r0,r0[0x0]
8000227a:	d7 60       	acall	0x76
8000227c:	80 00       	ld.sh	r0,r0[0x0]
8000227e:	d7 80       	acall	0x78
80002280:	80 00       	ld.sh	r0,r0[0x0]
80002282:	d7 a8       	*unknown*
80002284:	80 00       	ld.sh	r0,r0[0x0]
80002286:	d7 d0       	acall	0x7d
80002288:	80 00       	ld.sh	r0,r0[0x0]
8000228a:	d7 f4       	*unknown*
8000228c:	80 00       	ld.sh	r0,r0[0x0]
8000228e:	d8 1c       	*unknown*

80002290 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002290:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002294:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002298:	0f 89       	ld.ub	r9,r7[0x0]
8000229a:	30 08       	mov	r8,0
8000229c:	f0 09 18 00 	cp.b	r9,r8
800022a0:	c0 c1       	brne	800022b8 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022a2:	48 9c       	lddpc	r12,800022c4 <ButtonConfig_reply_func+0x34>
800022a4:	f0 1f 00 09 	mcall	800022c8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022a8:	0f 98       	ld.ub	r8,r7[0x1]
800022aa:	1a d8       	st.w	--sp,r8
800022ac:	48 8c       	lddpc	r12,800022cc <ButtonConfig_reply_func+0x3c>
800022ae:	f0 1f 00 07 	mcall	800022c8 <ButtonConfig_reply_func+0x38>
800022b2:	2f fd       	sub	sp,-4
800022b4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022b8:	48 6c       	lddpc	r12,800022d0 <ButtonConfig_reply_func+0x40>
800022ba:	f0 1f 00 04 	mcall	800022c8 <ButtonConfig_reply_func+0x38>
800022be:	e3 cd 80 80 	ldm	sp++,r7,pc
800022c2:	00 00       	add	r0,r0
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	d8 40       	acall	0x84
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	76 80       	ld.w	r0,r11[0x20]
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	d7 34       	*unknown*
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	d8 58       	*unknown*

800022d4 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
800022d4:	eb cd 40 80 	pushm	r7,lr
800022d8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800022da:	19 a9       	ld.ub	r9,r12[0x2]
800022dc:	30 08       	mov	r8,0
800022de:	f0 09 18 00 	cp.b	r9,r8
800022e2:	c1 11       	brne	80002304 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
800022e4:	49 3c       	lddpc	r12,80002330 <DataSession_reply_func+0x5c>
800022e6:	f0 1f 00 14 	mcall	80002334 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
800022ea:	0f b8       	ld.ub	r8,r7[0x3]
800022ec:	1a d8       	st.w	--sp,r8
800022ee:	49 3c       	lddpc	r12,80002338 <DataSession_reply_func+0x64>
800022f0:	f0 1f 00 11 	mcall	80002334 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
800022f4:	0f c8       	ld.ub	r8,r7[0x4]
800022f6:	1a d8       	st.w	--sp,r8
800022f8:	49 1c       	lddpc	r12,8000233c <DataSession_reply_func+0x68>
800022fa:	f0 1f 00 0f 	mcall	80002334 <DataSession_reply_func+0x60>
800022fe:	2f ed       	sub	sp,-8
80002300:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
80002304:	48 fc       	lddpc	r12,80002340 <DataSession_reply_func+0x6c>
80002306:	f0 1f 00 0c 	mcall	80002334 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
8000230a:	0f a8       	ld.ub	r8,r7[0x2]
8000230c:	1a d8       	st.w	--sp,r8
8000230e:	48 ec       	lddpc	r12,80002344 <DataSession_reply_func+0x70>
80002310:	f0 1f 00 09 	mcall	80002334 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
80002314:	0f b8       	ld.ub	r8,r7[0x3]
80002316:	1a d8       	st.w	--sp,r8
80002318:	48 cc       	lddpc	r12,80002348 <DataSession_reply_func+0x74>
8000231a:	f0 1f 00 07 	mcall	80002334 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
8000231e:	0f c8       	ld.ub	r8,r7[0x4]
80002320:	1a d8       	st.w	--sp,r8
80002322:	48 bc       	lddpc	r12,8000234c <DataSession_reply_func+0x78>
80002324:	f0 1f 00 04 	mcall	80002334 <DataSession_reply_func+0x60>
80002328:	2f dd       	sub	sp,-12
8000232a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000232e:	00 00       	add	r0,r0
80002330:	80 00       	ld.sh	r0,r0[0x0]
80002332:	d8 74       	*unknown*
80002334:	80 00       	ld.sh	r0,r0[0x0]
80002336:	76 80       	ld.w	r0,r11[0x20]
80002338:	80 00       	ld.sh	r0,r0[0x0]
8000233a:	d8 84       	*unknown*
8000233c:	80 00       	ld.sh	r0,r0[0x0]
8000233e:	d8 90       	acall	0x89
80002340:	80 00       	ld.sh	r0,r0[0x0]
80002342:	d8 9c       	*unknown*
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	d8 ac       	*unknown*
80002348:	80 00       	ld.sh	r0,r0[0x0]
8000234a:	d8 bc       	*unknown*
8000234c:	80 00       	ld.sh	r0,r0[0x0]
8000234e:	d8 c8       	*unknown*

80002350 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002350:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002354:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002358:	0f 98       	ld.ub	r8,r7[0x1]
8000235a:	1a d8       	st.w	--sp,r8
8000235c:	48 bc       	lddpc	r12,80002388 <CallControl_brdcst_func+0x38>
8000235e:	f0 1f 00 0c 	mcall	8000238c <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
80002362:	2f fd       	sub	sp,-4
80002364:	0f 99       	ld.ub	r9,r7[0x1]
80002366:	30 38       	mov	r8,3
80002368:	f0 09 18 00 	cp.b	r9,r8
8000236c:	c0 41       	brne	80002374 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
8000236e:	30 09       	mov	r9,0
80002370:	48 88       	lddpc	r8,80002390 <CallControl_brdcst_func+0x40>
80002372:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
80002374:	0f 99       	ld.ub	r9,r7[0x1]
80002376:	30 48       	mov	r8,4
80002378:	f0 09 18 00 	cp.b	r9,r8
8000237c:	c0 41       	brne	80002384 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
8000237e:	30 19       	mov	r9,1
80002380:	48 48       	lddpc	r8,80002390 <CallControl_brdcst_func+0x40>
80002382:	b0 89       	st.b	r8[0x0],r9
80002384:	e3 cd 80 80 	ldm	sp++,r7,pc
80002388:	80 00       	ld.sh	r0,r0[0x0]
8000238a:	d8 d4       	*unknown*
8000238c:	80 00       	ld.sh	r0,r0[0x0]
8000238e:	76 80       	ld.w	r0,r11[0x20]
80002390:	00 00       	add	r0,r0
80002392:	0a 66       	and	r6,r5

80002394 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002394:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002398:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
8000239c:	0f 99       	ld.ub	r9,r7[0x1]
8000239e:	30 08       	mov	r8,0
800023a0:	f0 09 18 00 	cp.b	r9,r8
800023a4:	c0 71       	brne	800023b2 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800023a6:	48 ac       	lddpc	r12,800023cc <TransmitControl_brdcst_func+0x38>
800023a8:	f0 1f 00 0a 	mcall	800023d0 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800023ac:	30 09       	mov	r9,0
800023ae:	48 a8       	lddpc	r8,800023d4 <TransmitControl_brdcst_func+0x40>
800023b0:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800023b2:	0f 99       	ld.ub	r9,r7[0x1]
800023b4:	30 18       	mov	r8,1
800023b6:	f0 09 18 00 	cp.b	r9,r8
800023ba:	c0 71       	brne	800023c8 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800023bc:	48 7c       	lddpc	r12,800023d8 <TransmitControl_brdcst_func+0x44>
800023be:	f0 1f 00 05 	mcall	800023d0 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800023c2:	30 19       	mov	r9,1
800023c4:	48 48       	lddpc	r8,800023d4 <TransmitControl_brdcst_func+0x40>
800023c6:	b0 89       	st.b	r8[0x0],r9
800023c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800023cc:	80 00       	ld.sh	r0,r0[0x0]
800023ce:	d8 ec       	*unknown*
800023d0:	80 00       	ld.sh	r0,r0[0x0]
800023d2:	76 80       	ld.w	r0,r11[0x20]
800023d4:	00 00       	add	r0,r0
800023d6:	0a 65       	and	r5,r5
800023d8:	80 00       	ld.sh	r0,r0[0x0]
800023da:	d9 04       	*unknown*

800023dc <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
800023dc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
800023e0:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
800023e4:	0f 89       	ld.ub	r9,r7[0x0]
800023e6:	30 08       	mov	r8,0
800023e8:	f0 09 18 00 	cp.b	r9,r8
800023ec:	c1 61       	brne	80002418 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
800023ee:	48 ec       	lddpc	r12,80002424 <TransmitControl_reply_func+0x48>
800023f0:	f0 1f 00 0e 	mcall	80002428 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
800023f4:	0f 98       	ld.ub	r8,r7[0x1]
800023f6:	1a d8       	st.w	--sp,r8
800023f8:	48 dc       	lddpc	r12,8000242c <TransmitControl_reply_func+0x50>
800023fa:	f0 1f 00 0c 	mcall	80002428 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
800023fe:	0f a8       	ld.ub	r8,r7[0x2]
80002400:	1a d8       	st.w	--sp,r8
80002402:	48 cc       	lddpc	r12,80002430 <TransmitControl_reply_func+0x54>
80002404:	f0 1f 00 09 	mcall	80002428 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002408:	0f b8       	ld.ub	r8,r7[0x3]
8000240a:	1a d8       	st.w	--sp,r8
8000240c:	48 ac       	lddpc	r12,80002434 <TransmitControl_reply_func+0x58>
8000240e:	f0 1f 00 07 	mcall	80002428 <TransmitControl_reply_func+0x4c>
80002412:	2f dd       	sub	sp,-12
80002414:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002418:	48 8c       	lddpc	r12,80002438 <TransmitControl_reply_func+0x5c>
8000241a:	f0 1f 00 04 	mcall	80002428 <TransmitControl_reply_func+0x4c>
8000241e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002422:	00 00       	add	r0,r0
80002424:	80 00       	ld.sh	r0,r0[0x0]
80002426:	d9 18       	*unknown*
80002428:	80 00       	ld.sh	r0,r0[0x0]
8000242a:	76 80       	ld.w	r0,r11[0x20]
8000242c:	80 00       	ld.sh	r0,r0[0x0]
8000242e:	d9 34       	*unknown*
80002430:	80 00       	ld.sh	r0,r0[0x0]
80002432:	d9 48       	*unknown*
80002434:	80 00       	ld.sh	r0,r0[0x0]
80002436:	d9 64       	*unknown*
80002438:	80 00       	ld.sh	r0,r0[0x0]
8000243a:	d9 74       	*unknown*

8000243c <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
8000243c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000243e:	19 a9       	ld.ub	r9,r12[0x2]
80002440:	30 08       	mov	r8,0
80002442:	f0 09 18 00 	cp.b	r9,r8
80002446:	c0 51       	brne	80002450 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002448:	48 4c       	lddpc	r12,80002458 <AudioRoutingControl_reply_func+0x1c>
8000244a:	f0 1f 00 05 	mcall	8000245c <AudioRoutingControl_reply_func+0x20>
8000244e:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002450:	48 4c       	lddpc	r12,80002460 <AudioRoutingControl_reply_func+0x24>
80002452:	f0 1f 00 03 	mcall	8000245c <AudioRoutingControl_reply_func+0x20>
80002456:	d8 02       	popm	pc
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	d9 8c       	*unknown*
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	76 80       	ld.w	r0,r11[0x20]
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	d9 9c       	*unknown*

80002464 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002464:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002468:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000246c:	0f 89       	ld.ub	r9,r7[0x0]
8000246e:	30 08       	mov	r8,0
80002470:	f0 09 18 00 	cp.b	r9,r8
80002474:	c1 b1       	brne	800024aa <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002476:	0f b8       	ld.ub	r8,r7[0x3]
80002478:	31 09       	mov	r9,16
8000247a:	f2 08 18 00 	cp.b	r8,r9
8000247e:	c0 f1       	brne	8000249c <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002480:	48 dc       	lddpc	r12,800024b4 <Volume_reply_func+0x50>
80002482:	f0 1f 00 0e 	mcall	800024b8 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002486:	0f 99       	ld.ub	r9,r7[0x1]
80002488:	0f a8       	ld.ub	r8,r7[0x2]
8000248a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000248e:	1a d8       	st.w	--sp,r8
80002490:	48 bc       	lddpc	r12,800024bc <Volume_reply_func+0x58>
80002492:	f0 1f 00 0a 	mcall	800024b8 <Volume_reply_func+0x54>
80002496:	2f fd       	sub	sp,-4
80002498:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
8000249c:	1a d8       	st.w	--sp,r8
8000249e:	48 9c       	lddpc	r12,800024c0 <Volume_reply_func+0x5c>
800024a0:	f0 1f 00 06 	mcall	800024b8 <Volume_reply_func+0x54>
800024a4:	2f fd       	sub	sp,-4
800024a6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024aa:	48 7c       	lddpc	r12,800024c4 <Volume_reply_func+0x60>
800024ac:	f0 1f 00 03 	mcall	800024b8 <Volume_reply_func+0x54>
800024b0:	e3 cd 80 80 	ldm	sp++,r7,pc
800024b4:	80 00       	ld.sh	r0,r0[0x0]
800024b6:	d9 b0       	acall	0x9b
800024b8:	80 00       	ld.sh	r0,r0[0x0]
800024ba:	76 80       	ld.w	r0,r11[0x20]
800024bc:	80 00       	ld.sh	r0,r0[0x0]
800024be:	d9 c4       	*unknown*
800024c0:	80 00       	ld.sh	r0,r0[0x0]
800024c2:	d9 e0       	acall	0x9e
800024c4:	80 00       	ld.sh	r0,r0[0x0]
800024c6:	d9 f8       	*unknown*

800024c8 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800024c8:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800024ca:	19 d9       	ld.ub	r9,r12[0x5]
800024cc:	30 08       	mov	r8,0
800024ce:	f0 09 18 00 	cp.b	r9,r8
800024d2:	c0 81       	brne	800024e2 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
800024d4:	10 99       	mov	r9,r8
800024d6:	48 78       	lddpc	r8,800024f0 <spk_brdcst_func+0x28>
800024d8:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
800024da:	48 7c       	lddpc	r12,800024f4 <spk_brdcst_func+0x2c>
800024dc:	f0 1f 00 07 	mcall	800024f8 <spk_brdcst_func+0x30>
800024e0:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
800024e2:	30 19       	mov	r9,1
800024e4:	48 38       	lddpc	r8,800024f0 <spk_brdcst_func+0x28>
800024e6:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
800024e8:	48 5c       	lddpc	r12,800024fc <spk_brdcst_func+0x34>
800024ea:	f0 1f 00 04 	mcall	800024f8 <spk_brdcst_func+0x30>
800024ee:	d8 02       	popm	pc
800024f0:	00 00       	add	r0,r0
800024f2:	0a 50       	eor	r0,r5
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	da 10       	acall	0xa1
800024f8:	80 00       	ld.sh	r0,r0[0x0]
800024fa:	76 80       	ld.w	r0,r11[0x20]
800024fc:	80 00       	ld.sh	r0,r0[0x0]
800024fe:	da 20       	acall	0xa2

80002500 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002500:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002502:	19 a9       	ld.ub	r9,r12[0x2]
80002504:	30 08       	mov	r8,0
80002506:	f0 09 18 00 	cp.b	r9,r8
8000250a:	c0 f1       	brne	80002528 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
8000250c:	19 e9       	ld.ub	r9,r12[0x6]
8000250e:	f0 09 18 00 	cp.b	r9,r8
80002512:	c0 40       	breq	8000251a <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002514:	30 19       	mov	r9,1
80002516:	48 98       	lddpc	r8,80002538 <spk_reply_func+0x38>
80002518:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000251a:	19 e8       	ld.ub	r8,r12[0x6]
8000251c:	1a d8       	st.w	--sp,r8
8000251e:	48 8c       	lddpc	r12,8000253c <spk_reply_func+0x3c>
80002520:	f0 1f 00 08 	mcall	80002540 <spk_reply_func+0x40>
80002524:	2f fd       	sub	sp,-4
80002526:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002528:	30 09       	mov	r9,0
8000252a:	48 48       	lddpc	r8,80002538 <spk_reply_func+0x38>
8000252c:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000252e:	48 6c       	lddpc	r12,80002544 <spk_reply_func+0x44>
80002530:	f0 1f 00 04 	mcall	80002540 <spk_reply_func+0x40>
80002534:	d8 02       	popm	pc
80002536:	00 00       	add	r0,r0
80002538:	00 00       	add	r0,r0
8000253a:	0a 50       	eor	r0,r5
8000253c:	80 00       	ld.sh	r0,r0[0x0]
8000253e:	da 2c       	*unknown*
80002540:	80 00       	ld.sh	r0,r0[0x0]
80002542:	76 80       	ld.w	r0,r11[0x20]
80002544:	80 00       	ld.sh	r0,r0[0x0]
80002546:	da 3c       	*unknown*

80002548 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002548:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
8000254c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002550:	0f a9       	ld.ub	r9,r7[0x2]
80002552:	30 08       	mov	r8,0
80002554:	f0 09 18 00 	cp.b	r9,r8
80002558:	c0 71       	brne	80002566 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000255a:	48 dc       	lddpc	r12,8000258c <mic_brdcst_func+0x44>
8000255c:	f0 1f 00 0d 	mcall	80002590 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002560:	30 09       	mov	r9,0
80002562:	48 d8       	lddpc	r8,80002594 <mic_brdcst_func+0x4c>
80002564:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002566:	0f a9       	ld.ub	r9,r7[0x2]
80002568:	31 18       	mov	r8,17
8000256a:	f0 09 18 00 	cp.b	r9,r8
8000256e:	c0 d1       	brne	80002588 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
80002570:	48 ac       	lddpc	r12,80002598 <mic_brdcst_func+0x50>
80002572:	f0 1f 00 08 	mcall	80002590 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
80002576:	48 89       	lddpc	r9,80002594 <mic_brdcst_func+0x4c>
80002578:	30 18       	mov	r8,1
8000257a:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
8000257c:	13 89       	ld.ub	r9,r9[0x0]
8000257e:	f0 09 18 00 	cp.b	r9,r8
80002582:	c0 31       	brne	80002588 <mic_brdcst_func+0x40>
80002584:	48 68       	lddpc	r8,8000259c <mic_brdcst_func+0x54>
80002586:	11 88       	ld.ub	r8,r8[0x0]
80002588:	e3 cd 80 80 	ldm	sp++,r7,pc
8000258c:	80 00       	ld.sh	r0,r0[0x0]
8000258e:	da 48       	*unknown*
80002590:	80 00       	ld.sh	r0,r0[0x0]
80002592:	76 80       	ld.w	r0,r11[0x20]
80002594:	00 00       	add	r0,r0
80002596:	0a 6a       	and	r10,r5
80002598:	80 00       	ld.sh	r0,r0[0x0]
8000259a:	da 5c       	*unknown*
8000259c:	00 00       	add	r0,r0
8000259e:	0a 66       	and	r6,r5

800025a0 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025a0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025a4:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025a8:	49 ac       	lddpc	r12,80002610 <mic_reply_func+0x70>
800025aa:	f0 1f 00 1b 	mcall	80002614 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025ae:	0f 89       	ld.ub	r9,r7[0x0]
800025b0:	30 08       	mov	r8,0
800025b2:	f0 09 18 00 	cp.b	r9,r8
800025b6:	c2 71       	brne	80002604 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025b8:	0f 98       	ld.ub	r8,r7[0x1]
800025ba:	30 29       	mov	r9,2
800025bc:	f2 08 18 00 	cp.b	r8,r9
800025c0:	c1 b1       	brne	800025f6 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800025c2:	49 6c       	lddpc	r12,80002618 <mic_reply_func+0x78>
800025c4:	f0 1f 00 14 	mcall	80002614 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800025c8:	0f a8       	ld.ub	r8,r7[0x2]
800025ca:	1a d8       	st.w	--sp,r8
800025cc:	49 4c       	lddpc	r12,8000261c <mic_reply_func+0x7c>
800025ce:	f0 1f 00 12 	mcall	80002614 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
800025d2:	0f b8       	ld.ub	r8,r7[0x3]
800025d4:	1a d8       	st.w	--sp,r8
800025d6:	49 3c       	lddpc	r12,80002620 <mic_reply_func+0x80>
800025d8:	f0 1f 00 0f 	mcall	80002614 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
800025dc:	0f c8       	ld.ub	r8,r7[0x4]
800025de:	1a d8       	st.w	--sp,r8
800025e0:	49 1c       	lddpc	r12,80002624 <mic_reply_func+0x84>
800025e2:	f0 1f 00 0d 	mcall	80002614 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
800025e6:	0f d8       	ld.ub	r8,r7[0x5]
800025e8:	1a d8       	st.w	--sp,r8
800025ea:	49 0c       	lddpc	r12,80002628 <mic_reply_func+0x88>
800025ec:	f0 1f 00 0a 	mcall	80002614 <mic_reply_func+0x74>
800025f0:	2f cd       	sub	sp,-16
800025f2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800025f6:	1a d8       	st.w	--sp,r8
800025f8:	48 dc       	lddpc	r12,8000262c <mic_reply_func+0x8c>
800025fa:	f0 1f 00 07 	mcall	80002614 <mic_reply_func+0x74>
800025fe:	2f fd       	sub	sp,-4
80002600:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002604:	48 bc       	lddpc	r12,80002630 <mic_reply_func+0x90>
80002606:	f0 1f 00 04 	mcall	80002614 <mic_reply_func+0x74>
8000260a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000260e:	00 00       	add	r0,r0
80002610:	80 00       	ld.sh	r0,r0[0x0]
80002612:	da 70       	acall	0xa7
80002614:	80 00       	ld.sh	r0,r0[0x0]
80002616:	76 80       	ld.w	r0,r11[0x20]
80002618:	80 00       	ld.sh	r0,r0[0x0]
8000261a:	da 80       	acall	0xa8
8000261c:	80 00       	ld.sh	r0,r0[0x0]
8000261e:	da 94       	*unknown*
80002620:	80 00       	ld.sh	r0,r0[0x0]
80002622:	da a8       	*unknown*
80002624:	80 00       	ld.sh	r0,r0[0x0]
80002626:	da c4       	*unknown*
80002628:	80 00       	ld.sh	r0,r0[0x0]
8000262a:	da dc       	*unknown*
8000262c:	80 00       	ld.sh	r0,r0[0x0]
8000262e:	da f4       	*unknown*
80002630:	80 00       	ld.sh	r0,r0[0x0]
80002632:	db 0c       	*unknown*

80002634 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002634:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002638:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
8000263c:	48 bc       	lddpc	r12,80002668 <dcm_brdcst_func+0x34>
8000263e:	f0 1f 00 0c 	mcall	8000266c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002642:	0f 88       	ld.ub	r8,r7[0x0]
80002644:	1a d8       	st.w	--sp,r8
80002646:	48 bc       	lddpc	r12,80002670 <dcm_brdcst_func+0x3c>
80002648:	f0 1f 00 09 	mcall	8000266c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000264c:	0f a8       	ld.ub	r8,r7[0x2]
8000264e:	1a d8       	st.w	--sp,r8
80002650:	48 9c       	lddpc	r12,80002674 <dcm_brdcst_func+0x40>
80002652:	f0 1f 00 07 	mcall	8000266c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002656:	0f 98       	ld.ub	r8,r7[0x1]
80002658:	1a d8       	st.w	--sp,r8
8000265a:	48 8c       	lddpc	r12,80002678 <dcm_brdcst_func+0x44>
8000265c:	f0 1f 00 04 	mcall	8000266c <dcm_brdcst_func+0x38>
80002660:	2f dd       	sub	sp,-12
	
	
}
80002662:	e3 cd 80 80 	ldm	sp++,r7,pc
80002666:	00 00       	add	r0,r0
80002668:	80 00       	ld.sh	r0,r0[0x0]
8000266a:	db 1c       	*unknown*
8000266c:	80 00       	ld.sh	r0,r0[0x0]
8000266e:	76 80       	ld.w	r0,r11[0x20]
80002670:	80 00       	ld.sh	r0,r0[0x0]
80002672:	db 30       	acall	0xb3
80002674:	80 00       	ld.sh	r0,r0[0x0]
80002676:	db 44       	*unknown*
80002678:	80 00       	ld.sh	r0,r0[0x0]
8000267a:	db 5c       	*unknown*

8000267c <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
8000267c:	eb cd 40 80 	pushm	r7,lr
80002680:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002682:	19 a9       	ld.ub	r9,r12[0x2]
80002684:	30 08       	mov	r8,0
80002686:	f0 09 18 00 	cp.b	r9,r8
8000268a:	c1 b1       	brne	800026c0 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
8000268c:	19 b8       	ld.ub	r8,r12[0x3]
8000268e:	30 19       	mov	r9,1
80002690:	f2 08 18 00 	cp.b	r8,r9
80002694:	c0 51       	brne	8000269e <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
80002696:	48 ec       	lddpc	r12,800026cc <dcm_reply_func+0x50>
80002698:	f0 1f 00 0e 	mcall	800026d0 <dcm_reply_func+0x54>
8000269c:	c0 a8       	rjmp	800026b0 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
8000269e:	58 08       	cp.w	r8,0
800026a0:	c0 51       	brne	800026aa <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026a2:	48 dc       	lddpc	r12,800026d4 <dcm_reply_func+0x58>
800026a4:	f0 1f 00 0b 	mcall	800026d0 <dcm_reply_func+0x54>
800026a8:	c0 48       	rjmp	800026b0 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026aa:	48 cc       	lddpc	r12,800026d8 <dcm_reply_func+0x5c>
800026ac:	f0 1f 00 09 	mcall	800026d0 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026b0:	0f d8       	ld.ub	r8,r7[0x5]
800026b2:	1a d8       	st.w	--sp,r8
800026b4:	48 ac       	lddpc	r12,800026dc <dcm_reply_func+0x60>
800026b6:	f0 1f 00 07 	mcall	800026d0 <dcm_reply_func+0x54>
800026ba:	2f fd       	sub	sp,-4
800026bc:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800026c0:	48 8c       	lddpc	r12,800026e0 <dcm_reply_func+0x64>
800026c2:	f0 1f 00 04 	mcall	800026d0 <dcm_reply_func+0x54>
800026c6:	e3 cd 80 80 	ldm	sp++,r7,pc
800026ca:	00 00       	add	r0,r0
800026cc:	80 00       	ld.sh	r0,r0[0x0]
800026ce:	db 78       	*unknown*
800026d0:	80 00       	ld.sh	r0,r0[0x0]
800026d2:	76 80       	ld.w	r0,r11[0x20]
800026d4:	80 00       	ld.sh	r0,r0[0x0]
800026d6:	db 8c       	*unknown*
800026d8:	80 00       	ld.sh	r0,r0[0x0]
800026da:	db a0       	acall	0xba
800026dc:	80 00       	ld.sh	r0,r0[0x0]
800026de:	db b4       	*unknown*
800026e0:	80 00       	ld.sh	r0,r0[0x0]
800026e2:	db c0       	acall	0xbc

800026e4 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800026e4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800026e6:	19 a9       	ld.ub	r9,r12[0x2]
800026e8:	30 08       	mov	r8,0
800026ea:	f0 09 18 00 	cp.b	r9,r8
800026ee:	c0 51       	brne	800026f8 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
800026f0:	48 4c       	lddpc	r12,80002700 <ToneControl_reply_func+0x1c>
800026f2:	f0 1f 00 05 	mcall	80002704 <ToneControl_reply_func+0x20>
800026f6:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800026f8:	48 4c       	lddpc	r12,80002708 <ToneControl_reply_func+0x24>
800026fa:	f0 1f 00 03 	mcall	80002704 <ToneControl_reply_func+0x20>
800026fe:	d8 02       	popm	pc
80002700:	80 00       	ld.sh	r0,r0[0x0]
80002702:	db cc       	*unknown*
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	76 80       	ld.w	r0,r11[0x20]
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	db d8       	*unknown*

8000270c <app_cfg>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
8000270c:	d4 31       	pushm	r0-r7,lr
8000270e:	20 1d       	sub	sp,4
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	static const uint8_t test_data[8] = {0x11, 0x23, 0x33, 0x67, 0x89, 0xAB, 0xCD, 0xEF};
	
	 xLastWakeTime = xTaskGetTickCount();
80002710:	f0 1f 00 27 	mcall	800027ac <app_cfg+0xa0>
80002714:	4a 78       	lddpc	r8,800027b0 <app_cfg+0xa4>
80002716:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002718:	4a 76       	lddpc	r6,800027b4 <app_cfg+0xa8>
		{	
			connect_flag=1;	
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
			vTaskResume(save_handle);
		}
		else if(connect_flag)
8000271a:	4a 85       	lddpc	r5,800027b8 <app_cfg+0xac>
		else
		{
			nop();
			nop();
			nop();
			xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
8000271c:	30 62       	mov	r2,6
8000271e:	30 14       	mov	r4,1
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
			vTaskResume(save_handle);
		}
		else if(connect_flag)
		{
				if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
80002720:	4a 71       	lddpc	r1,800027bc <app_cfg+0xb0>
80002722:	30 03       	mov	r3,0
80002724:	e0 67 0f a0 	mov	r7,4000
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002728:	6c 08       	ld.w	r8,r6[0x0]
8000272a:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000272e:	58 38       	cp.w	r8,3
80002730:	c0 f1       	brne	8000274e <app_cfg+0x42>
80002732:	0b 88       	ld.ub	r8,r5[0x0]
80002734:	58 08       	cp.w	r8,0
80002736:	c0 c1       	brne	8000274e <app_cfg+0x42>
		{	
			connect_flag=1;	
80002738:	30 18       	mov	r8,1
8000273a:	aa 88       	st.b	r5[0x0],r8
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
8000273c:	30 cb       	mov	r11,12
8000273e:	08 9c       	mov	r12,r4
80002740:	f0 1f 00 20 	mcall	800027c0 <app_cfg+0xb4>
			vTaskResume(save_handle);
80002744:	4a 08       	lddpc	r8,800027c4 <app_cfg+0xb8>
80002746:	70 0c       	ld.w	r12,r8[0x0]
80002748:	f0 1f 00 20 	mcall	800027c8 <app_cfg+0xbc>
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
8000274c:	c2 78       	rjmp	8000279a <app_cfg+0x8e>
		{	
			connect_flag=1;	
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
			vTaskResume(save_handle);
		}
		else if(connect_flag)
8000274e:	0b 88       	ld.ub	r8,r5[0x0]
80002750:	58 08       	cp.w	r8,0
80002752:	c1 d0       	breq	8000278c <app_cfg+0x80>
		{
				if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
80002754:	62 0c       	ld.w	r12,r1[0x0]
80002756:	06 99       	mov	r9,r3
80002758:	0e 9a       	mov	r10,r7
8000275a:	1a 9b       	mov	r11,sp
8000275c:	f0 1f 00 1c 	mcall	800027cc <app_cfg+0xc0>
80002760:	58 1c       	cp.w	r12,1
80002762:	c1 31       	brne	80002788 <app_cfg+0x7c>
				{
					
					//xgflash_message_save(data_ptr, sizeof(Message_Protocol_t), TRUE);
					//flashc_memcpy((void *)0x80061234, (void *)test_data, 7,  true);
					set_message_store(data_ptr);
80002764:	49 b8       	lddpc	r8,800027d0 <app_cfg+0xc4>
80002766:	70 0c       	ld.w	r12,r8[0x0]
80002768:	40 0b       	lddsp	r11,sp[0x0]
8000276a:	f0 1f 00 1b 	mcall	800027d4 <app_cfg+0xc8>
					log("receive okay!\n");	
8000276e:	49 bc       	lddpc	r12,800027d8 <app_cfg+0xcc>
80002770:	f0 1f 00 1b 	mcall	800027dc <app_cfg+0xd0>
					water_value = uxTaskGetStackHighWaterMark(NULL);
80002774:	06 9c       	mov	r12,r3
80002776:	f0 1f 00 1b 	mcall	800027e0 <app_cfg+0xd4>
8000277a:	49 b8       	lddpc	r8,800027e4 <app_cfg+0xd8>
8000277c:	91 0c       	st.w	r8[0x0],r12
					log("water_value: %d\n", water_value);		
8000277e:	1a dc       	st.w	--sp,r12
80002780:	49 ac       	lddpc	r12,800027e8 <app_cfg+0xdc>
80002782:	f0 1f 00 17 	mcall	800027dc <app_cfg+0xd0>
80002786:	2f fd       	sub	sp,-4
				//}
				//else
				//{
					//log("no find card...\n");
				//}
				nop();
80002788:	d7 03       	nop
8000278a:	c0 88       	rjmp	8000279a <app_cfg+0x8e>
				//Current_time.Hour, Current_time.Minute, Current_time.Second);
				
		}
		else
		{
			nop();
8000278c:	d7 03       	nop
			nop();
8000278e:	d7 03       	nop
			nop();
80002790:	d7 03       	nop
			xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
80002792:	04 9b       	mov	r11,r2
80002794:	08 9c       	mov	r12,r4
80002796:	f0 1f 00 0b 	mcall	800027c0 <app_cfg+0xb4>
		//}
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		log("app pthread run...\n");	
8000279a:	49 5c       	lddpc	r12,800027ec <app_cfg+0xe0>
8000279c:	f0 1f 00 10 	mcall	800027dc <app_cfg+0xd0>
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800027a0:	0e 9b       	mov	r11,r7
800027a2:	48 4c       	lddpc	r12,800027b0 <app_cfg+0xa4>
800027a4:	f0 1f 00 13 	mcall	800027f0 <app_cfg+0xe4>
	}
800027a8:	cc 0b       	rjmp	80002728 <app_cfg+0x1c>
800027aa:	00 00       	add	r0,r0
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	6e 94       	ld.w	r4,r7[0x24]
800027b0:	00 00       	add	r0,r0
800027b2:	0a 54       	eor	r4,r5
800027b4:	00 00       	add	r0,r0
800027b6:	0e 00       	add	r0,r7
800027b8:	00 00       	add	r0,r0
800027ba:	0a 69       	and	r9,r5
800027bc:	00 00       	add	r0,r0
800027be:	0b 70       	ld.ub	r0,--r5
800027c0:	80 00       	ld.sh	r0,r0[0x0]
800027c2:	3e f8       	mov	r8,-17
800027c4:	00 00       	add	r0,r0
800027c6:	54 20       	stdsp	sp[0x108],r0
800027c8:	80 00       	ld.sh	r0,r0[0x0]
800027ca:	6f a0       	ld.w	r0,r7[0x68]
800027cc:	80 00       	ld.sh	r0,r0[0x0]
800027ce:	66 cc       	ld.w	r12,r3[0x30]
800027d0:	00 00       	add	r0,r0
800027d2:	0b 80       	ld.ub	r0,r5[0x0]
800027d4:	80 00       	ld.sh	r0,r0[0x0]
800027d6:	2a 80       	sub	r0,-88
800027d8:	80 00       	ld.sh	r0,r0[0x0]
800027da:	db e4       	*unknown*
800027dc:	80 00       	ld.sh	r0,r0[0x0]
800027de:	76 80       	ld.w	r0,r11[0x20]
800027e0:	80 00       	ld.sh	r0,r0[0x0]
800027e2:	6b 74       	ld.w	r4,r5[0x5c]
800027e4:	00 00       	add	r0,r0
800027e6:	0a 58       	eor	r8,r5
800027e8:	80 00       	ld.sh	r0,r0[0x0]
800027ea:	db f4       	*unknown*
800027ec:	80 00       	ld.sh	r0,r0[0x0]
800027ee:	dc 08       	*unknown*
800027f0:	80 00       	ld.sh	r0,r0[0x0]
800027f2:	71 5c       	ld.w	r12,r8[0x54]

800027f4 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800027f4:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800027f8:	19 c7       	ld.ub	r7,r12[0x4]
800027fa:	19 d8       	ld.ub	r8,r12[0x5]
800027fc:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002800:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
80002802:	48 dc       	lddpc	r12,80002834 <Phyuserinput_brdcst_func+0x40>
80002804:	f0 1f 00 0d 	mcall	80002838 <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
80002808:	36 08       	mov	r8,96
8000280a:	f0 07 19 00 	cp.h	r7,r8
8000280e:	c1 11       	brne	80002830 <Phyuserinput_brdcst_func+0x3c>
80002810:	48 b8       	lddpc	r8,8000283c <Phyuserinput_brdcst_func+0x48>
80002812:	11 89       	ld.ub	r9,r8[0x0]
80002814:	30 18       	mov	r8,1
80002816:	f0 09 18 00 	cp.b	r9,r8
8000281a:	c0 b1       	brne	80002830 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, ACK_Received_Tone);//set tone to indicate the scan!!!
8000281c:	31 4b       	mov	r11,20
8000281e:	30 1c       	mov	r12,1
80002820:	f0 1f 00 08 	mcall	80002840 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(400*2 / portTICK_RATE_MS);//延迟400ms
80002824:	e0 6c 03 20 	mov	r12,800
80002828:	f0 1f 00 07 	mcall	80002844 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		rfid_sendID_message();//send message		
8000282c:	f0 1f 00 07 	mcall	80002848 <Phyuserinput_brdcst_func+0x54>
80002830:	e3 cd 80 80 	ldm	sp++,r7,pc
80002834:	80 00       	ld.sh	r0,r0[0x0]
80002836:	dc 1c       	*unknown*
80002838:	80 00       	ld.sh	r0,r0[0x0]
8000283a:	76 80       	ld.w	r0,r11[0x20]
8000283c:	00 00       	add	r0,r0
8000283e:	0a 69       	and	r9,r5
80002840:	80 00       	ld.sh	r0,r0[0x0]
80002842:	3e f8       	mov	r8,-17
80002844:	80 00       	ld.sh	r0,r0[0x0]
80002846:	71 14       	ld.w	r4,r8[0x44]
80002848:	80 00       	ld.sh	r0,r0[0x0]
8000284a:	4e cc       	lddpc	r12,800029f8 <CalculateBurst+0x14>

8000284c <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
8000284c:	d4 31       	pushm	r0-r7,lr
8000284e:	20 9d       	sub	sp,36
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002850:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
80002854:	0d 88       	ld.ub	r8,r6[0x0]
80002856:	32 49       	mov	r9,36
80002858:	f2 08 18 00 	cp.b	r8,r9
8000285c:	c2 91       	brne	800028ae <DataSession_brdcst_func+0x62>
	{
		
		log("\n\r CSBK_RX OK \n\r");
8000285e:	4c 4c       	lddpc	r12,8000296c <DataSession_brdcst_func+0x120>
80002860:	f0 1f 00 44 	mcall	80002970 <DataSession_brdcst_func+0x124>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002864:	0d a5       	ld.ub	r5,r6[0x2]
80002866:	0d b8       	ld.ub	r8,r6[0x3]
80002868:	f1 e5 10 85 	or	r5,r8,r5<<0x8
8000286c:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
8000286e:	0d 98       	ld.ub	r8,r6[0x1]
80002870:	1a d8       	st.w	--sp,r8
80002872:	4c 1c       	lddpc	r12,80002974 <DataSession_brdcst_func+0x128>
80002874:	f0 1f 00 3f 	mcall	80002970 <DataSession_brdcst_func+0x124>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002878:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000287c:	1a d8       	st.w	--sp,r8
8000287e:	4b fc       	lddpc	r12,80002978 <DataSession_brdcst_func+0x12c>
80002880:	f0 1f 00 3c 	mcall	80002970 <DataSession_brdcst_func+0x124>
		for(i=0; i<data_length; i++)
80002884:	2f ed       	sub	sp,-8
80002886:	58 05       	cp.w	r5,0
80002888:	c7 00       	breq	80002968 <DataSession_brdcst_func+0x11c>
8000288a:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
8000288c:	4b c4       	lddpc	r4,8000297c <DataSession_brdcst_func+0x130>
8000288e:	ec 07 00 08 	add	r8,r6,r7
80002892:	11 c8       	ld.ub	r8,r8[0x4]
80002894:	1a d8       	st.w	--sp,r8
80002896:	1a d7       	st.w	--sp,r7
80002898:	08 9c       	mov	r12,r4
8000289a:	f0 1f 00 36 	mcall	80002970 <DataSession_brdcst_func+0x124>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
8000289e:	2f f7       	sub	r7,-1
800028a0:	5c 57       	castu.b	r7
800028a2:	2f ed       	sub	sp,-8
800028a4:	ee 05 19 00 	cp.h	r5,r7
800028a8:	fe 9b ff f3 	brhi	8000288e <DataSession_brdcst_func+0x42>
800028ac:	c5 e8       	rjmp	80002968 <DataSession_brdcst_func+0x11c>
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800028ae:	0d a7       	ld.ub	r7,r6[0x2]
800028b0:	0d b5       	ld.ub	r5,r6[0x3]
		log("State: %X \n", ptr->State);
800028b2:	1a d8       	st.w	--sp,r8
800028b4:	4b 3c       	lddpc	r12,80002980 <DataSession_brdcst_func+0x134>
800028b6:	f0 1f 00 2f 	mcall	80002970 <DataSession_brdcst_func+0x124>
		if (ptr->State == DATA_SESSION_TX_Suc)
800028ba:	0d 88       	ld.ub	r8,r6[0x0]
800028bc:	2f fd       	sub	sp,-4
800028be:	30 39       	mov	r9,3
800028c0:	f2 08 18 00 	cp.b	r8,r9
800028c4:	c0 51       	brne	800028ce <DataSession_brdcst_func+0x82>
		{
			log("data transmit success\n");
800028c6:	4b 0c       	lddpc	r12,80002984 <DataSession_brdcst_func+0x138>
800028c8:	f0 1f 00 2a 	mcall	80002970 <DataSession_brdcst_func+0x124>
800028cc:	c4 78       	rjmp	8000295a <DataSession_brdcst_func+0x10e>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
800028ce:	30 49       	mov	r9,4
800028d0:	f2 08 18 00 	cp.b	r8,r9
800028d4:	c4 31       	brne	8000295a <DataSession_brdcst_func+0x10e>
		{
			//Message_Protocol_t  *xgmessage = (Message_Protocol_t  *)ptr->DataPayload.DataPayload;
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
800028d6:	32 0a       	mov	r10,32
800028d8:	ec cb ff fc 	sub	r11,r6,-4
800028dc:	1a 9c       	mov	r12,sp
800028de:	f0 1f 00 2b 	mcall	80002988 <DataSession_brdcst_func+0x13c>
800028e2:	fb 36 00 1f 	ld.ub	r6,sp[31]
800028e6:	fb 34 00 1e 	ld.ub	r4,sp[30]
800028ea:	fb 33 00 1d 	ld.ub	r3,sp[29]
800028ee:	fb 32 00 1c 	ld.ub	r2,sp[28]
800028f2:	fb 31 00 1b 	ld.ub	r1,sp[27]
800028f6:	fb 30 00 1a 	ld.ub	r0,sp[26]
			log("data transmit failure\n");
800028fa:	4a 5c       	lddpc	r12,8000298c <DataSession_brdcst_func+0x140>
800028fc:	f0 1f 00 1d 	mcall	80002970 <DataSession_brdcst_func+0x124>
			log("xgmessage.XG_Time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
80002900:	1a d6       	st.w	--sp,r6
80002902:	1a d4       	st.w	--sp,r4
80002904:	1a d3       	st.w	--sp,r3
80002906:	1a d2       	st.w	--sp,r2
80002908:	1a d1       	st.w	--sp,r1
8000290a:	1a d0       	st.w	--sp,r0
8000290c:	4a 1c       	lddpc	r12,80002990 <DataSession_brdcst_func+0x144>
8000290e:	f0 1f 00 19 	mcall	80002970 <DataSession_brdcst_func+0x124>
			xgmessage.data.XG_Time.Year, xgmessage.data.XG_Time.Month, xgmessage.data.XG_Time.Day,
			xgmessage.data.XG_Time.Hour, xgmessage.data.XG_Time.Minute, xgmessage.data.XG_Time.Second);

			//return_value = xgflash_message_save(&xgmessage, sizeof(Message_Protocol_t), TRUE);

			Message_Protocol_t * myptr = get_message_store();	
80002912:	4a 18       	lddpc	r8,80002994 <DataSession_brdcst_func+0x148>
80002914:	70 0c       	ld.w	r12,r8[0x0]
80002916:	f0 1f 00 21 	mcall	80002998 <DataSession_brdcst_func+0x14c>
8000291a:	50 ec       	stdsp	sp[0x38],r12
			if(NULL != myptr)
8000291c:	2f ad       	sub	sp,-24
8000291e:	58 0c       	cp.w	r12,0
80002920:	c1 a0       	breq	80002954 <DataSession_brdcst_func+0x108>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
80002922:	fb 66 00 1f 	st.b	sp[31],r6
80002926:	fb 64 00 1e 	st.b	sp[30],r4
8000292a:	fb 63 00 1d 	st.b	sp[29],r3
8000292e:	fb 62 00 1c 	st.b	sp[28],r2
80002932:	fb 61 00 1b 	st.b	sp[27],r1
80002936:	fb 60 00 1a 	st.b	sp[26],r0
8000293a:	32 0a       	mov	r10,32
8000293c:	1a 9b       	mov	r11,sp
8000293e:	f0 1f 00 13 	mcall	80002988 <DataSession_brdcst_func+0x13c>
				xQueueSend(xg_resend_queue, &myptr, 0);
80002942:	49 78       	lddpc	r8,8000299c <DataSession_brdcst_func+0x150>
80002944:	70 0c       	ld.w	r12,r8[0x0]
80002946:	30 09       	mov	r9,0
80002948:	12 9a       	mov	r10,r9
8000294a:	fa cb ff e0 	sub	r11,sp,-32
8000294e:	f0 1f 00 15 	mcall	800029a0 <DataSession_brdcst_func+0x154>
80002952:	c0 48       	rjmp	8000295a <DataSession_brdcst_func+0x10e>
			}
			else
			{
				log("myptr: err\n\r" );
80002954:	49 4c       	lddpc	r12,800029a4 <DataSession_brdcst_func+0x158>
80002956:	f0 1f 00 07 	mcall	80002970 <DataSession_brdcst_func+0x124>
			}
			//xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate send-failure!!!
		}
		//log("Session_ID: %x \n\r",Session_number );
		log("paylaod_length: %d \n\r",data_length );
8000295a:	eb e7 10 87 	or	r7,r5,r7<<0x8
8000295e:	1a d7       	st.w	--sp,r7
80002960:	49 2c       	lddpc	r12,800029a8 <DataSession_brdcst_func+0x15c>
80002962:	f0 1f 00 04 	mcall	80002970 <DataSession_brdcst_func+0x124>
80002966:	2f fd       	sub	sp,-4
				//
		//}
		
	}
	
}
80002968:	2f 7d       	sub	sp,-36
8000296a:	d8 32       	popm	r0-r7,pc
8000296c:	80 00       	ld.sh	r0,r0[0x0]
8000296e:	dc 3c       	*unknown*
80002970:	80 00       	ld.sh	r0,r0[0x0]
80002972:	76 80       	ld.w	r0,r11[0x20]
80002974:	80 00       	ld.sh	r0,r0[0x0]
80002976:	dc 50       	acall	0xc5
80002978:	80 00       	ld.sh	r0,r0[0x0]
8000297a:	dc 68       	*unknown*
8000297c:	80 00       	ld.sh	r0,r0[0x0]
8000297e:	dc 84       	*unknown*
80002980:	80 00       	ld.sh	r0,r0[0x0]
80002982:	dc 9c       	*unknown*
80002984:	80 00       	ld.sh	r0,r0[0x0]
80002986:	dc a8       	*unknown*
80002988:	80 00       	ld.sh	r0,r0[0x0]
8000298a:	7f 22       	ld.w	r2,pc[0x48]
8000298c:	80 00       	ld.sh	r0,r0[0x0]
8000298e:	dc c0       	acall	0xcc
80002990:	80 00       	ld.sh	r0,r0[0x0]
80002992:	dc d8       	*unknown*
80002994:	00 00       	add	r0,r0
80002996:	0b 80       	ld.ub	r0,r5[0x0]
80002998:	80 00       	ld.sh	r0,r0[0x0]
8000299a:	2c 2c       	sub	r12,-62
8000299c:	00 00       	add	r0,r0
8000299e:	0b 70       	ld.ub	r0,--r5
800029a0:	80 00       	ld.sh	r0,r0[0x0]
800029a2:	68 d8       	ld.w	r8,r4[0x34]
800029a4:	80 00       	ld.sh	r0,r0[0x0]
800029a6:	dd 0c       	*unknown*
800029a8:	80 00       	ld.sh	r0,r0[0x0]
800029aa:	dd 1c       	*unknown*

800029ac <DeviceInitializationStatus_brdcst_func>:
extern volatile xQueueHandle xg_resend_queue ;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800029ac:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800029ae:	19 e8       	ld.ub	r8,r12[0x6]
800029b0:	30 19       	mov	r9,1
800029b2:	f2 08 18 00 	cp.b	r8,r9
800029b6:	c0 61       	brne	800029c2 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800029b8:	48 98       	lddpc	r8,800029dc <DeviceInitializationStatus_brdcst_func+0x30>
800029ba:	70 09       	ld.w	r9,r8[0x0]
800029bc:	a1 a9       	sbr	r9,0x0
800029be:	91 09       	st.w	r8[0x0],r9
800029c0:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800029c2:	30 29       	mov	r9,2
800029c4:	f2 08 18 00 	cp.b	r8,r9
800029c8:	c0 80       	breq	800029d8 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800029ca:	48 58       	lddpc	r8,800029dc <DeviceInitializationStatus_brdcst_func+0x30>
800029cc:	70 09       	ld.w	r9,r8[0x0]
800029ce:	e0 19 ff fc 	andl	r9,0xfffc
800029d2:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800029d4:	f0 1f 00 03 	mcall	800029e0 <DeviceInitializationStatus_brdcst_func+0x34>
800029d8:	d8 02       	popm	pc
800029da:	00 00       	add	r0,r0
800029dc:	00 00       	add	r0,r0
800029de:	0e 00       	add	r0,r7
800029e0:	80 00       	ld.sh	r0,r0[0x0]
800029e2:	3e 4c       	mov	r12,-28

800029e4 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
800029e4:	20 1c       	sub	r12,1
800029e6:	5c 5c       	castu.b	r12
800029e8:	31 18       	mov	r8,17
800029ea:	f0 0c 18 00 	cp.b	r12,r8
800029ee:	e0 88 00 03 	brls	800029f4 <CalculateBurst+0x10>
800029f2:	5e fd       	retal	0
800029f4:	48 28       	lddpc	r8,800029fc <CalculateBurst+0x18>
800029f6:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
800029fa:	5e fc       	retal	r12
800029fc:	80 00       	ld.sh	r0,r0[0x0]
800029fe:	dd 34       	*unknown*

80002a00 <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
80002a00:	48 38       	lddpc	r8,80002a0c <payload_init+0xc>
80002a02:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002a04:	48 38       	lddpc	r8,80002a10 <payload_init+0x10>
80002a06:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
80002a08:	5e fc       	retal	r12
80002a0a:	00 00       	add	r0,r0
80002a0c:	00 00       	add	r0,r0
80002a0e:	0a 74       	tst	r4,r5
80002a10:	00 00       	add	r0,r0
80002a12:	0a 78       	tst	r8,r5

80002a14 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002a14:	d4 01       	pushm	lr
80002a16:	20 2d       	sub	sp,8
80002a18:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a1a:	30 09       	mov	r9,0
80002a1c:	fa ca ff f8 	sub	r10,sp,-8
80002a20:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002a22:	1a 9b       	mov	r11,sp
80002a24:	f0 1f 00 02 	mcall	80002a2c <set_idle_store_isr+0x18>
}
80002a28:	2f ed       	sub	sp,-8
80002a2a:	d8 02       	popm	pc
80002a2c:	80 00       	ld.sh	r0,r0[0x0]
80002a2e:	68 88       	ld.w	r8,r4[0x20]

80002a30 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002a30:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
80002a32:	48 48       	lddpc	r8,80002a40 <payload_rx+0x10>
80002a34:	70 08       	ld.w	r8,r8[0x0]
80002a36:	18 9b       	mov	r11,r12
80002a38:	10 9c       	mov	r12,r8
80002a3a:	f0 1f 00 03 	mcall	80002a44 <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
80002a3e:	d8 02       	popm	pc
80002a40:	00 00       	add	r0,r0
80002a42:	0a b0       	st.h	r5++,r0
80002a44:	80 00       	ld.sh	r0,r0[0x0]
80002a46:	2a 14       	sub	r4,-95

80002a48 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002a48:	d4 01       	pushm	lr
80002a4a:	20 2d       	sub	sp,8
80002a4c:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002a4e:	58 0c       	cp.w	r12,0
80002a50:	c1 10       	breq	80002a72 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a52:	30 08       	mov	r8,0
80002a54:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002a56:	98 88       	ld.uh	r8,r12[0x0]
80002a58:	e2 18 f0 00 	andl	r8,0xf000,COH
80002a5c:	e0 48 40 00 	cp.w	r8,16384
80002a60:	c0 91       	brne	80002a72 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002a62:	48 68       	lddpc	r8,80002a78 <phy_rx+0x30>
80002a64:	70 0c       	ld.w	r12,r8[0x0]
80002a66:	30 09       	mov	r9,0
80002a68:	fa ca ff fc 	sub	r10,sp,-4
80002a6c:	1a 9b       	mov	r11,sp
80002a6e:	f0 1f 00 04 	mcall	80002a7c <phy_rx+0x34>
		}	

    }
		
 
}
80002a72:	2f ed       	sub	sp,-8
80002a74:	d8 02       	popm	pc
80002a76:	00 00       	add	r0,r0
80002a78:	00 00       	add	r0,r0
80002a7a:	0a bc       	st.h	r5++,r12
80002a7c:	80 00       	ld.sh	r0,r0[0x0]
80002a7e:	68 88       	ld.w	r8,r4[0x20]

80002a80 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002a80:	eb cd 40 80 	pushm	r7,lr
80002a84:	20 1d       	sub	sp,4
80002a86:	fa c7 ff fc 	sub	r7,sp,-4
80002a8a:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002a8c:	30 09       	mov	r9,0
80002a8e:	12 9a       	mov	r10,r9
80002a90:	1a 9b       	mov	r11,sp
80002a92:	f0 1f 00 03 	mcall	80002a9c <set_idle_store+0x1c>
}
80002a96:	2f fd       	sub	sp,-4
80002a98:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a9c:	80 00       	ld.sh	r0,r0[0x0]
80002a9e:	68 d8       	ld.w	r8,r4[0x34]

80002aa0 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002aa0:	d4 01       	pushm	lr
80002aa2:	20 1d       	sub	sp,4
80002aa4:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002aa6:	98 88       	ld.uh	r8,r12[0x0]
80002aa8:	e2 18 f0 00 	andl	r8,0xf000,COH
80002aac:	e0 48 40 00 	cp.w	r8,16384
80002ab0:	c0 d1       	brne	80002aca <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002ab2:	49 08       	lddpc	r8,80002af0 <phy_tx+0x50>
80002ab4:	70 08       	ld.w	r8,r8[0x0]
80002ab6:	58 08       	cp.w	r8,0
80002ab8:	c1 a0       	breq	80002aec <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002aba:	48 e8       	lddpc	r8,80002af0 <phy_tx+0x50>
80002abc:	70 0c       	ld.w	r12,r8[0x0]
80002abe:	30 09       	mov	r9,0
80002ac0:	12 9a       	mov	r10,r9
80002ac2:	1a 9b       	mov	r11,sp
80002ac4:	f0 1f 00 0c 	mcall	80002af4 <phy_tx+0x54>
80002ac8:	c1 28       	rjmp	80002aec <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002aca:	e0 48 10 00 	cp.w	r8,4096
80002ace:	5f 0a       	sreq	r10
80002ad0:	e0 48 20 00 	cp.w	r8,8192
80002ad4:	5f 09       	sreq	r9
80002ad6:	f5 e9 10 09 	or	r9,r10,r9
80002ada:	c0 71       	brne	80002ae8 <phy_tx+0x48>
80002adc:	e0 48 50 00 	cp.w	r8,20480
80002ae0:	c0 40       	breq	80002ae8 <phy_tx+0x48>
80002ae2:	e0 48 60 00 	cp.w	r8,24576
80002ae6:	c0 31       	brne	80002aec <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002ae8:	48 48       	lddpc	r8,80002af8 <phy_tx+0x58>
80002aea:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002aec:	2f fd       	sub	sp,-4
80002aee:	d8 02       	popm	pc
80002af0:	00 00       	add	r0,r0
80002af2:	0a dc       	st.w	--r5,r12
80002af4:	80 00       	ld.sh	r0,r0[0x0]
80002af6:	68 d8       	ld.w	r8,r4[0x34]
80002af8:	00 00       	add	r0,r0
80002afa:	0a d0       	st.w	--r5,r0

80002afc <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002afc:	d4 01       	pushm	lr
80002afe:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002b00:	30 08       	mov	r8,0
80002b02:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002b04:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002b06:	1a 9a       	mov	r10,sp
80002b08:	fa cb ff fc 	sub	r11,sp,-4
80002b0c:	f0 1f 00 05 	mcall	80002b20 <get_idle_store_isr+0x24>
80002b10:	58 1c       	cp.w	r12,1
80002b12:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002b16:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002b1a:	2f ed       	sub	sp,-8
80002b1c:	d8 02       	popm	pc
80002b1e:	00 00       	add	r0,r0
80002b20:	80 00       	ld.sh	r0,r0[0x0]
80002b22:	65 dc       	ld.w	r12,r2[0x74]

80002b24 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002b24:	eb cd 40 c0 	pushm	r6-r7,lr
80002b28:	20 1d       	sub	sp,4
80002b2a:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002b2c:	4b a8       	lddpc	r8,80002c14 <phy_tx_func+0xf0>
80002b2e:	70 08       	ld.w	r8,r8[0x0]
80002b30:	58 08       	cp.w	r8,0
80002b32:	c6 60       	breq	80002bfe <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002b34:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002b36:	30 08       	mov	r8,0
80002b38:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002b3a:	4b 88       	lddpc	r8,80002c18 <phy_tx_func+0xf4>
80002b3c:	70 08       	ld.w	r8,r8[0x0]
80002b3e:	58 18       	cp.w	r8,1
80002b40:	c2 60       	breq	80002b8c <phy_tx_func+0x68>
80002b42:	c0 43       	brcs	80002b4a <phy_tx_func+0x26>
80002b44:	58 28       	cp.w	r8,2
80002b46:	c5 c1       	brne	80002bfe <phy_tx_func+0xda>
80002b48:	c5 58       	rjmp	80002bf2 <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002b4a:	4b 38       	lddpc	r8,80002c14 <phy_tx_func+0xf0>
80002b4c:	70 0c       	ld.w	r12,r8[0x0]
80002b4e:	1a 9a       	mov	r10,sp
80002b50:	4b 3b       	lddpc	r11,80002c1c <phy_tx_func+0xf8>
80002b52:	f0 1f 00 34 	mcall	80002c20 <phy_tx_func+0xfc>
80002b56:	58 1c       	cp.w	r12,1
80002b58:	c1 41       	brne	80002b80 <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002b5a:	4b 18       	lddpc	r8,80002c1c <phy_tx_func+0xf8>
80002b5c:	70 08       	ld.w	r8,r8[0x0]
80002b5e:	90 08       	ld.sh	r8,r8[0x0]
80002b60:	10 9a       	mov	r10,r8
80002b62:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002b66:	4b 09       	lddpc	r9,80002c24 <phy_tx_func+0x100>
80002b68:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002b6a:	5c 78       	castu.h	r8
80002b6c:	ea 18 ab cd 	orh	r8,0xabcd
80002b70:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002b72:	30 19       	mov	r9,1
80002b74:	4a d8       	lddpc	r8,80002c28 <phy_tx_func+0x104>
80002b76:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002b78:	30 19       	mov	r9,1
80002b7a:	4a 88       	lddpc	r8,80002c18 <phy_tx_func+0xf4>
80002b7c:	91 09       	st.w	r8[0x0],r9
80002b7e:	c4 08       	rjmp	80002bfe <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002b80:	e0 68 5a 5a 	mov	r8,23130
80002b84:	ea 18 ab cd 	orh	r8,0xabcd
80002b88:	8f 18       	st.w	r7[0x4],r8
80002b8a:	c3 a8       	rjmp	80002bfe <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002b8c:	4a 7a       	lddpc	r10,80002c28 <phy_tx_func+0x104>
80002b8e:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002b90:	4a 39       	lddpc	r9,80002c1c <phy_tx_func+0xf8>
80002b92:	72 09       	ld.w	r9,r9[0x0]
80002b94:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002b98:	b1 69       	lsl	r9,0x10
80002b9a:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002b9c:	2f f8       	sub	r8,-1
80002b9e:	5c 58       	castu.b	r8
80002ba0:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002ba2:	4a 1b       	lddpc	r11,80002c24 <phy_tx_func+0x100>
80002ba4:	96 0c       	ld.sh	r12,r11[0x0]
80002ba6:	20 2c       	sub	r12,2
80002ba8:	5c 8c       	casts.h	r12
80002baa:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002bae:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002bb0:	30 0b       	mov	r11,0
80002bb2:	f6 0a 19 00 	cp.h	r10,r11
80002bb6:	e0 89 00 09 	brgt	80002bc8 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002bba:	e8 19 00 ba 	orl	r9,0xba
80002bbe:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002bc0:	30 09       	mov	r9,0
80002bc2:	49 68       	lddpc	r8,80002c18 <phy_tx_func+0xf4>
80002bc4:	91 09       	st.w	r8[0x0],r9
80002bc6:	c1 c8       	rjmp	80002bfe <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002bc8:	49 5a       	lddpc	r10,80002c1c <phy_tx_func+0xf8>
80002bca:	74 0a       	ld.w	r10,r10[0x0]
80002bcc:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002bd0:	14 49       	or	r9,r10
80002bd2:	8f 19       	st.w	r7[0x4],r9
80002bd4:	2f f8       	sub	r8,-1
80002bd6:	49 59       	lddpc	r9,80002c28 <phy_tx_func+0x104>
80002bd8:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002bda:	20 2c       	sub	r12,2
80002bdc:	49 28       	lddpc	r8,80002c24 <phy_tx_func+0x100>
80002bde:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002be0:	30 08       	mov	r8,0
80002be2:	f0 0c 19 00 	cp.h	r12,r8
80002be6:	e0 89 00 0c 	brgt	80002bfe <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002bea:	30 29       	mov	r9,2
80002bec:	48 b8       	lddpc	r8,80002c18 <phy_tx_func+0xf4>
80002bee:	91 09       	st.w	r8[0x0],r9
80002bf0:	c0 78       	rjmp	80002bfe <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002bf2:	fc 18 00 ba 	movh	r8,0xba
80002bf6:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002bf8:	30 09       	mov	r9,0
80002bfa:	48 88       	lddpc	r8,80002c18 <phy_tx_func+0xf4>
80002bfc:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002bfe:	e0 68 5a 5a 	mov	r8,23130
80002c02:	ea 18 ab cd 	orh	r8,0xabcd
80002c06:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002c08:	30 08       	mov	r8,0
80002c0a:	8f 38       	st.w	r7[0xc],r8
}
80002c0c:	2f fd       	sub	sp,-4
80002c0e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002c12:	00 00       	add	r0,r0
80002c14:	00 00       	add	r0,r0
80002c16:	0a dc       	st.w	--r5,r12
80002c18:	00 00       	add	r0,r0
80002c1a:	0a 9c       	mov	r12,r5
80002c1c:	00 00       	add	r0,r0
80002c1e:	0a a8       	st.w	r5++,r8
80002c20:	80 00       	ld.sh	r0,r0[0x0]
80002c22:	65 dc       	ld.w	r12,r2[0x74]
80002c24:	00 00       	add	r0,r0
80002c26:	0a c4       	st.b	r5++,r4
80002c28:	00 00       	add	r0,r0
80002c2a:	0a 7c       	tst	r12,r5

80002c2c <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002c2c:	d4 01       	pushm	lr
80002c2e:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002c30:	30 0a       	mov	r10,0
80002c32:	fa cb ff fc 	sub	r11,sp,-4
80002c36:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002c38:	14 99       	mov	r9,r10
80002c3a:	1a 9b       	mov	r11,sp
80002c3c:	f0 1f 00 05 	mcall	80002c50 <get_idle_store+0x24>
80002c40:	58 1c       	cp.w	r12,1
80002c42:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002c46:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002c4a:	2f fd       	sub	sp,-4
80002c4c:	d8 02       	popm	pc
80002c4e:	00 00       	add	r0,r0
80002c50:	80 00       	ld.sh	r0,r0[0x0]
80002c52:	66 cc       	ld.w	r12,r3[0x30]

80002c54 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002c54:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002c56:	48 5b       	lddpc	r11,80002c68 <phy_init+0x14>
80002c58:	48 5c       	lddpc	r12,80002c6c <phy_init+0x18>
80002c5a:	f0 1f 00 06 	mcall	80002c70 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002c5e:	f0 1f 00 06 	mcall	80002c74 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002c62:	f0 1f 00 06 	mcall	80002c78 <phy_init+0x24>
	
}
80002c66:	d8 02       	popm	pc
80002c68:	80 00       	ld.sh	r0,r0[0x0]
80002c6a:	2b 24       	sub	r4,-78
80002c6c:	80 00       	ld.sh	r0,r0[0x0]
80002c6e:	2c 7c       	sub	r12,-57
80002c70:	80 00       	ld.sh	r0,r0[0x0]
80002c72:	3c 50       	mov	r0,-59
80002c74:	80 00       	ld.sh	r0,r0[0x0]
80002c76:	3c 64       	mov	r4,-58
80002c78:	80 00       	ld.sh	r0,r0[0x0]
80002c7a:	46 a4       	lddsp	r4,sp[0x1a8]

80002c7c <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002c7c:	eb cd 40 e0 	pushm	r5-r7,lr
80002c80:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002c82:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002c86:	70 08       	ld.w	r8,r8[0x0]
80002c88:	58 08       	cp.w	r8,0
80002c8a:	e0 80 01 08 	breq	80002e9a <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002c8e:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002c90:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002c94:	70 09       	ld.w	r9,r8[0x0]
80002c96:	2f f9       	sub	r9,-1
80002c98:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002c9a:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002c9e:	70 08       	ld.w	r8,r8[0x0]
80002ca0:	58 18       	cp.w	r8,1
80002ca2:	e0 80 00 85 	breq	80002dac <phy_rx_func+0x130>
80002ca6:	c0 73       	brcs	80002cb4 <phy_rx_func+0x38>
80002ca8:	58 28       	cp.w	r8,2
80002caa:	c5 c0       	breq	80002d62 <phy_rx_func+0xe6>
80002cac:	58 38       	cp.w	r8,3
80002cae:	e0 81 00 f6 	brne	80002e9a <phy_rx_func+0x21e>
80002cb2:	cd 58       	rjmp	80002e5c <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002cb4:	e0 6a 5a 5a 	mov	r10,23130
80002cb8:	ea 1a ab cd 	orh	r10,0xabcd
80002cbc:	14 36       	cp.w	r6,r10
80002cbe:	e0 80 00 ee 	breq	80002e9a <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002cc2:	ec 08 16 10 	lsr	r8,r6,0x10
80002cc6:	e0 48 ab cd 	cp.w	r8,43981
80002cca:	e0 81 00 e8 	brne	80002e9a <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002cce:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002cd2:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002cd6:	20 28       	sub	r8,2
80002cd8:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002cdc:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002cde:	30 09       	mov	r9,0
80002ce0:	f2 08 19 00 	cp.h	r8,r9
80002ce4:	e0 8a 00 db 	brle	80002e9a <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002ce8:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002cec:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002cee:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002cf2:	70 0c       	ld.w	r12,r8[0x0]
80002cf4:	f0 1f 03 88 	mcall	80003b14 <phy_rx_func+0xe98>
80002cf8:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002cfc:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002cfe:	58 0c       	cp.w	r12,0
80002d00:	e0 80 00 cd 	breq	80002e9a <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002d04:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002d08:	90 09       	ld.sh	r9,r8[0x0]
80002d0a:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002d0e:	2f f9       	sub	r9,-1
80002d10:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002d12:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002d16:	74 0a       	ld.w	r10,r10[0x0]
80002d18:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002d1c:	76 0b       	ld.w	r11,r11[0x0]
80002d1e:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002d22:	2f f9       	sub	r9,-1
80002d24:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002d26:	e2 16 0f 00 	andl	r6,0xf00,COH
80002d2a:	e0 46 01 00 	cp.w	r6,256
80002d2e:	c0 c0       	breq	80002d46 <phy_rx_func+0xca>
80002d30:	e0 8b 00 05 	brhi	80002d3a <phy_rx_func+0xbe>
80002d34:	58 06       	cp.w	r6,0
80002d36:	c0 80       	breq	80002d46 <phy_rx_func+0xca>
80002d38:	c0 c8       	rjmp	80002d50 <phy_rx_func+0xd4>
80002d3a:	e0 46 02 00 	cp.w	r6,512
80002d3e:	c0 40       	breq	80002d46 <phy_rx_func+0xca>
80002d40:	e0 46 03 00 	cp.w	r6,768
80002d44:	c0 61       	brne	80002d50 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002d46:	30 29       	mov	r9,2
80002d48:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002d4c:	91 09       	st.w	r8[0x0],r9
80002d4e:	ca 68       	rjmp	80002e9a <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002d50:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002d54:	70 0c       	ld.w	r12,r8[0x0]
80002d56:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002d5a:	70 0b       	ld.w	r11,r8[0x0]
80002d5c:	f0 1f 03 70 	mcall	80003b1c <phy_rx_func+0xea0>
80002d60:	c9 d8       	rjmp	80002e9a <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002d62:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002d66:	b1 86       	lsr	r6,0x10
80002d68:	14 06       	add	r6,r10
80002d6a:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002d6e:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002d70:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002d74:	90 09       	ld.sh	r9,r8[0x0]
80002d76:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002d7a:	76 0b       	ld.w	r11,r11[0x0]
80002d7c:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002d80:	2f f9       	sub	r9,-1
80002d82:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002d84:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002d88:	92 08       	ld.sh	r8,r9[0x0]
80002d8a:	20 28       	sub	r8,2
80002d8c:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002d8e:	30 09       	mov	r9,0
80002d90:	f2 08 19 00 	cp.h	r8,r9
80002d94:	e0 8a 00 07 	brle	80002da2 <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002d98:	30 19       	mov	r9,1
80002d9a:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002d9e:	91 09       	st.w	r8[0x0],r9
80002da0:	c7 d8       	rjmp	80002e9a <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002da2:	30 39       	mov	r9,3
80002da4:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002da8:	91 09       	st.w	r8[0x0],r9
80002daa:	c7 88       	rjmp	80002e9a <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002dac:	ec 0a 14 10 	asr	r10,r6,0x10
80002db0:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002db4:	90 09       	ld.sh	r9,r8[0x0]
80002db6:	14 09       	add	r9,r10
80002db8:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002dba:	fe f9 0d 52 	ld.w	r9,pc[3410]
80002dbe:	92 08       	ld.sh	r8,r9[0x0]
80002dc0:	fe fb 0d 58 	ld.w	r11,pc[3416]
80002dc4:	76 0b       	ld.w	r11,r11[0x0]
80002dc6:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002dca:	2f f8       	sub	r8,-1
80002dcc:	5c 88       	casts.h	r8
80002dce:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002dd0:	fe fa 0d 38 	ld.w	r10,pc[3384]
80002dd4:	94 09       	ld.sh	r9,r10[0x0]
80002dd6:	20 29       	sub	r9,2
80002dd8:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80002dda:	30 0a       	mov	r10,0
80002ddc:	f4 09 19 00 	cp.h	r9,r10
80002de0:	e0 89 00 20 	brgt	80002e20 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80002de4:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80002de8:	e0 46 00 ba 	cp.w	r6,186
80002dec:	c0 d1       	brne	80002e06 <phy_rx_func+0x18a>
80002dee:	fe f8 0d 32 	ld.w	r8,pc[3378]
80002df2:	90 09       	ld.sh	r9,r8[0x0]
80002df4:	f4 09 19 00 	cp.h	r9,r10
80002df8:	c0 71       	brne	80002e06 <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80002dfa:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80002dfe:	70 0c       	ld.w	r12,r8[0x0]
80002e00:	f0 1f 03 49 	mcall	80003b24 <phy_rx_func+0xea8>
80002e04:	c0 98       	rjmp	80002e16 <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80002e06:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80002e0a:	70 0c       	ld.w	r12,r8[0x0]
80002e0c:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80002e10:	70 0b       	ld.w	r11,r8[0x0]
80002e12:	f0 1f 03 43 	mcall	80003b1c <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80002e16:	30 09       	mov	r9,0
80002e18:	fe f8 0c ec 	ld.w	r8,pc[3308]
80002e1c:	91 09       	st.w	r8[0x0],r9
80002e1e:	c3 e8       	rjmp	80002e9a <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80002e20:	5c 86       	casts.h	r6
80002e22:	fe f9 0c fe 	ld.w	r9,pc[3326]
80002e26:	92 0a       	ld.sh	r10,r9[0x0]
80002e28:	0c 0a       	add	r10,r6
80002e2a:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002e2c:	fe f9 0c ec 	ld.w	r9,pc[3308]
80002e30:	72 09       	ld.w	r9,r9[0x0]
80002e32:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80002e36:	2f f8       	sub	r8,-1
80002e38:	fe f9 0c d4 	ld.w	r9,pc[3284]
80002e3c:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80002e3e:	fe f9 0c ca 	ld.w	r9,pc[3274]
80002e42:	92 08       	ld.sh	r8,r9[0x0]
80002e44:	20 28       	sub	r8,2
80002e46:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80002e48:	30 09       	mov	r9,0
80002e4a:	f2 08 19 00 	cp.h	r8,r9
80002e4e:	e0 89 00 26 	brgt	80002e9a <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80002e52:	30 39       	mov	r9,3
80002e54:	fe f8 0c b0 	ld.w	r8,pc[3248]
80002e58:	91 09       	st.w	r8[0x0],r9
80002e5a:	c2 08       	rjmp	80002e9a <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80002e5c:	e6 16 00 ff 	andh	r6,0xff,COH
80002e60:	fc 19 00 ba 	movh	r9,0xba
80002e64:	12 36       	cp.w	r6,r9
80002e66:	c0 e1       	brne	80002e82 <phy_rx_func+0x206>
80002e68:	fe f8 0c b8 	ld.w	r8,pc[3256]
80002e6c:	90 09       	ld.sh	r9,r8[0x0]
80002e6e:	30 08       	mov	r8,0
80002e70:	f0 09 19 00 	cp.h	r9,r8
80002e74:	c0 71       	brne	80002e82 <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80002e76:	fe f8 0c a2 	ld.w	r8,pc[3234]
80002e7a:	70 0c       	ld.w	r12,r8[0x0]
80002e7c:	f0 1f 03 2a 	mcall	80003b24 <phy_rx_func+0xea8>
80002e80:	c0 98       	rjmp	80002e92 <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80002e82:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002e86:	70 0c       	ld.w	r12,r8[0x0]
80002e88:	fe f8 0c 90 	ld.w	r8,pc[3216]
80002e8c:	70 0b       	ld.w	r11,r8[0x0]
80002e8e:	f0 1f 03 24 	mcall	80003b1c <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80002e92:	30 09       	mov	r9,0
80002e94:	fe f8 0c 70 	ld.w	r8,pc[3184]
80002e98:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80002e9a:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002e9e:	11 89       	ld.ub	r9,r8[0x0]
80002ea0:	30 08       	mov	r8,0
80002ea2:	f0 09 18 00 	cp.b	r9,r8
80002ea6:	c1 31       	brne	80002ecc <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80002ea8:	fe f6 0c 84 	ld.w	r6,pc[3204]
80002eac:	6c 0c       	ld.w	r12,r6[0x0]
80002eae:	f0 1f 03 1a 	mcall	80003b14 <phy_rx_func+0xe98>
80002eb2:	fe f8 0c 7e 	ld.w	r8,pc[3198]
80002eb6:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80002eb8:	6c 0c       	ld.w	r12,r6[0x0]
80002eba:	f0 1f 03 17 	mcall	80003b14 <phy_rx_func+0xe98>
80002ebe:	fe f8 0c 76 	ld.w	r8,pc[3190]
80002ec2:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80002ec4:	30 19       	mov	r9,1
80002ec6:	fe f8 0c 62 	ld.w	r8,pc[3170]
80002eca:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80002ecc:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80002ed0:	70 08       	ld.w	r8,r8[0x0]
80002ed2:	58 28       	cp.w	r8,2
80002ed4:	e0 80 01 98 	breq	80003204 <phy_rx_func+0x588>
80002ed8:	e0 8b 00 06 	brhi	80002ee4 <phy_rx_func+0x268>
80002edc:	58 08       	cp.w	r8,0
80002ede:	c0 b0       	breq	80002ef4 <phy_rx_func+0x278>
80002ee0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002ee4:	58 38       	cp.w	r8,3
80002ee6:	e0 80 05 c5 	breq	80003a70 <phy_rx_func+0xdf4>
80002eea:	58 48       	cp.w	r8,4
80002eec:	e0 81 06 05 	brne	80003af6 <phy_rx_func+0xe7a>
80002ef0:	e0 8f 02 4b 	bral	80003386 <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80002ef4:	6e 28       	ld.w	r8,r7[0x8]
80002ef6:	e0 6a 5a 5a 	mov	r10,23130
80002efa:	ea 1a ab cd 	orh	r10,0xabcd
80002efe:	14 38       	cp.w	r8,r10
80002f00:	c0 71       	brne	80002f0e <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
80002f02:	30 09       	mov	r9,0
80002f04:	fe f8 0c 38 	ld.w	r8,pc[3128]
80002f08:	91 09       	st.w	r8[0x0],r9
80002f0a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80002f0e:	10 99       	mov	r9,r8
80002f10:	e0 19 00 00 	andl	r9,0x0
80002f14:	fc 1a ab cd 	movh	r10,0xabcd
80002f18:	14 39       	cp.w	r9,r10
80002f1a:	e0 81 05 ee 	brne	80003af6 <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80002f1e:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80002f22:	fe f9 0c 1e 	ld.w	r9,pc[3102]
80002f26:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80002f28:	6e 29       	ld.w	r9,r7[0x8]
80002f2a:	e2 19 f0 00 	andl	r9,0xf000,COH
80002f2e:	e0 49 c0 00 	cp.w	r9,49152
80002f32:	e0 81 00 ce 	brne	800030ce <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
80002f36:	30 1a       	mov	r10,1
80002f38:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80002f3c:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
80002f3e:	fe f9 0b f6 	ld.w	r9,pc[3062]
80002f42:	72 09       	ld.w	r9,r9[0x0]
80002f44:	58 09       	cp.w	r9,0
80002f46:	c0 71       	brne	80002f54 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80002f48:	fe fc 0c 00 	ld.w	r12,pc[3072]
80002f4c:	f0 1f 03 00 	mcall	80003b4c <phy_rx_func+0xed0>
80002f50:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80002f54:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80002f58:	fe f9 0b f8 	ld.w	r9,pc[3064]
80002f5c:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80002f5e:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80002f62:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
80002f66:	fe fa 0b ee 	ld.w	r10,pc[3054]
80002f6a:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80002f6c:	13 89       	ld.ub	r9,r9[0x0]
80002f6e:	37 fa       	mov	r10,127
80002f70:	f4 09 18 00 	cp.b	r9,r10
80002f74:	c6 d0       	breq	8000304e <phy_rx_func+0x3d2>
80002f76:	e0 8b 00 0c 	brhi	80002f8e <phy_rx_func+0x312>
80002f7a:	31 2a       	mov	r10,18
80002f7c:	f4 09 18 00 	cp.b	r9,r10
80002f80:	c4 20       	breq	80003004 <phy_rx_func+0x388>
80002f82:	31 3a       	mov	r10,19
80002f84:	f4 09 18 00 	cp.b	r9,r10
80002f88:	e0 81 00 83 	brne	8000308e <phy_rx_func+0x412>
80002f8c:	c5 b8       	rjmp	80003042 <phy_rx_func+0x3c6>
80002f8e:	2f 09       	sub	r9,-16
80002f90:	30 1a       	mov	r10,1
80002f92:	f4 09 18 00 	cp.b	r9,r10
80002f96:	e0 8b 00 7c 	brhi	8000308e <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80002f9a:	ef 38 00 0e 	ld.ub	r8,r7[14]
80002f9e:	e2 18 00 f0 	andl	r8,0xf0,COH
80002fa2:	59 08       	cp.w	r8,16
80002fa4:	c0 71       	brne	80002fb2 <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
80002fa6:	30 19       	mov	r9,1
80002fa8:	fe f8 0b 94 	ld.w	r8,pc[2964]
80002fac:	91 09       	st.w	r8[0x0],r9
80002fae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80002fb2:	e0 48 00 20 	cp.w	r8,32
80002fb6:	c2 11       	brne	80002ff8 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80002fb8:	30 a9       	mov	r9,10
80002fba:	fe f8 0b 82 	ld.w	r8,pc[2946]
80002fbe:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80002fc0:	fe f6 0b 98 	ld.w	r6,pc[2968]
80002fc4:	6c 08       	ld.w	r8,r6[0x0]
80002fc6:	f0 0a 11 ff 	rsub	r10,r8,-1
80002fca:	fe f7 0b 6a 	ld.w	r7,pc[2922]
80002fce:	2f f8       	sub	r8,-1
80002fd0:	6e 0c       	ld.w	r12,r7[0x0]
80002fd2:	f4 ca fe 00 	sub	r10,r10,-512
80002fd6:	30 0b       	mov	r11,0
80002fd8:	10 0c       	add	r12,r8
80002fda:	f0 1f 02 e1 	mcall	80003b5c <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80002fde:	30 08       	mov	r8,0
80002fe0:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80002fe2:	6e 0c       	ld.w	r12,r7[0x0]
80002fe4:	f0 1f 02 df 	mcall	80003b60 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80002fe8:	fe f8 0b 44 	ld.w	r8,pc[2884]
80002fec:	70 0c       	ld.w	r12,r8[0x0]
80002fee:	f0 1f 02 ca 	mcall	80003b14 <phy_rx_func+0xe98>
80002ff2:	8f 0c       	st.w	r7[0x0],r12
80002ff4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80002ff8:	30 09       	mov	r9,0
80002ffa:	fe f8 0b 42 	ld.w	r8,pc[2882]
80002ffe:	91 09       	st.w	r8[0x0],r9
80003000:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003004:	20 48       	sub	r8,4
80003006:	fe f9 0b 3a 	ld.w	r9,pc[2874]
8000300a:	93 08       	st.w	r9[0x0],r8
8000300c:	58 08       	cp.w	r8,0
8000300e:	e0 80 05 74 	breq	80003af6 <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003012:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80003016:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
8000301a:	fe f8 0b 4a 	ld.w	r8,pc[2890]
8000301e:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003020:	8e 69       	ld.sh	r9,r7[0xc]
80003022:	fe f8 0b 46 	ld.w	r8,pc[2886]
80003026:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80003028:	8e 79       	ld.sh	r9,r7[0xe]
8000302a:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
8000302c:	f0 1f 02 d0 	mcall	80003b6c <phy_rx_func+0xef0>
80003030:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80003034:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003036:	30 49       	mov	r9,4
80003038:	fe f8 0b 00 	ld.w	r8,pc[2816]
8000303c:	91 09       	st.w	r8[0x0],r9
8000303e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80003042:	30 09       	mov	r9,0
80003044:	fe f8 0a f8 	ld.w	r8,pc[2808]
80003048:	91 09       	st.w	r8[0x0],r9
8000304a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
8000304e:	20 48       	sub	r8,4
80003050:	fe f9 0a f0 	ld.w	r9,pc[2800]
80003054:	93 08       	st.w	r9[0x0],r8
80003056:	58 08       	cp.w	r8,0
80003058:	e0 80 05 4f 	breq	80003af6 <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
8000305c:	fe f8 0b 14 	ld.w	r8,pc[2836]
80003060:	70 09       	ld.w	r9,r8[0x0]
80003062:	8e 7b       	ld.sh	r11,r7[0xe]
80003064:	fe fa 0b 10 	ld.w	r10,pc[2832]
80003068:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
8000306c:	2f f9       	sub	r9,-1
8000306e:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003070:	fe f8 0a e4 	ld.w	r8,pc[2788]
80003074:	70 09       	ld.w	r9,r8[0x0]
80003076:	20 29       	sub	r9,2
80003078:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
8000307a:	30 29       	mov	r9,2
8000307c:	fe f8 0a c0 	ld.w	r8,pc[2752]
80003080:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003082:	30 39       	mov	r9,3
80003084:	fe f8 0a b4 	ld.w	r8,pc[2740]
80003088:	91 09       	st.w	r8[0x0],r9
8000308a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
8000308e:	30 3a       	mov	r10,3
80003090:	fe f9 0a ac 	ld.w	r9,pc[2732]
80003094:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003096:	6e 2a       	ld.w	r10,r7[0x8]
80003098:	fe f9 0a e0 	ld.w	r9,pc[2784]
8000309c:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
8000309e:	6e 3a       	ld.w	r10,r7[0xc]
800030a0:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
800030a2:	59 48       	cp.w	r8,20
800030a4:	c0 61       	brne	800030b0 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
800030a6:	31 89       	mov	r9,24
800030a8:	fe f8 0a 98 	ld.w	r8,pc[2712]
800030ac:	91 09       	st.w	r8[0x0],r9
800030ae:	c0 a8       	rjmp	800030c2 <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
800030b0:	fe f8 0a 90 	ld.w	r8,pc[2704]
800030b4:	70 08       	ld.w	r8,r8[0x0]
800030b6:	59 08       	cp.w	r8,16
800030b8:	c0 51       	brne	800030c2 <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
800030ba:	31 09       	mov	r9,16
800030bc:	fe f8 0a 84 	ld.w	r8,pc[2692]
800030c0:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
800030c2:	30 49       	mov	r9,4
800030c4:	fe f8 0a 74 	ld.w	r8,pc[2676]
800030c8:	91 09       	st.w	r8[0x0],r9
800030ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
800030ce:	e0 49 10 00 	cp.w	r9,4096
800030d2:	5f 1a       	srne	r10
800030d4:	e0 49 20 00 	cp.w	r9,8192
800030d8:	5f 19       	srne	r9
800030da:	f5 e9 00 09 	and	r9,r10,r9
800030de:	e0 81 05 0c 	brne	80003af6 <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
800030e2:	fe fa 0a 9a 	ld.w	r10,pc[2714]
800030e6:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
800030e8:	fe fa 0a 98 	ld.w	r10,pc[2712]
800030ec:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
800030ee:	fe fa 0a 62 	ld.w	r10,pc[2658]
800030f2:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
800030f4:	fe f9 0a 3c 	ld.w	r9,pc[2620]
800030f8:	72 09       	ld.w	r9,r9[0x0]
800030fa:	58 09       	cp.w	r9,0
800030fc:	c0 71       	brne	8000310a <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800030fe:	fe fc 0a 4a 	ld.w	r12,pc[2634]
80003102:	f0 1f 02 93 	mcall	80003b4c <phy_rx_func+0xed0>
80003106:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000310a:	6e 2a       	ld.w	r10,r7[0x8]
8000310c:	e2 1a 0f 00 	andl	r10,0xf00,COH
80003110:	58 1a       	cp.w	r10,1
80003112:	e0 8b 00 4d 	brhi	800031ac <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
80003116:	20 48       	sub	r8,4
80003118:	fe f9 0a 28 	ld.w	r9,pc[2600]
8000311c:	93 08       	st.w	r9[0x0],r8
8000311e:	58 08       	cp.w	r8,0
80003120:	e0 80 04 eb 	breq	80003af6 <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
80003124:	8e 68       	ld.sh	r8,r7[0xc]
80003126:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000312a:	fe f9 0a 5a 	ld.w	r9,pc[2650]
8000312e:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
80003130:	30 09       	mov	r9,0
80003132:	f2 08 19 00 	cp.h	r8,r9
80003136:	c0 70       	breq	80003144 <phy_rx_func+0x4c8>
80003138:	30 19       	mov	r9,1
8000313a:	f2 08 19 00 	cp.h	r8,r9
8000313e:	e0 81 04 dc 	brne	80003af6 <phy_rx_func+0xe7a>
80003142:	c2 68       	rjmp	8000318e <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003144:	fe f8 0a 44 	ld.w	r8,pc[2628]
80003148:	70 0a       	ld.w	r10,r8[0x0]
8000314a:	fe f9 09 e6 	ld.w	r9,pc[2534]
8000314e:	72 09       	ld.w	r9,r9[0x0]
80003150:	8e 7b       	ld.sh	r11,r7[0xe]
80003152:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
80003156:	70 09       	ld.w	r9,r8[0x0]
80003158:	2f f9       	sub	r9,-1
8000315a:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000315c:	e0 49 00 ff 	cp.w	r9,255
80003160:	e0 88 00 11 	brls	80003182 <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
80003164:	30 09       	mov	r9,0
80003166:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
80003168:	fe f7 09 c8 	ld.w	r7,pc[2504]
8000316c:	6e 0c       	ld.w	r12,r7[0x0]
8000316e:	f0 1f 02 7d 	mcall	80003b60 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
80003172:	fe f8 09 ba 	ld.w	r8,pc[2490]
80003176:	70 0c       	ld.w	r12,r8[0x0]
80003178:	f0 1f 02 67 	mcall	80003b14 <phy_rx_func+0xe98>
8000317c:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
8000317e:	e0 80 04 bc 	breq	80003af6 <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
80003182:	30 29       	mov	r9,2
80003184:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003188:	91 09       	st.w	r8[0x0],r9
8000318a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000318e:	8e 79       	ld.sh	r9,r7[0xe]
80003190:	30 38       	mov	r8,3
80003192:	f0 09 19 00 	cp.h	r9,r8
80003196:	c0 51       	brne	800031a0 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003198:	30 19       	mov	r9,1
8000319a:	fe f8 09 f2 	ld.w	r8,pc[2546]
8000319e:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
800031a0:	30 29       	mov	r9,2
800031a2:	fe f8 09 96 	ld.w	r8,pc[2454]
800031a6:	91 09       	st.w	r8[0x0],r9
800031a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
800031ac:	58 18       	cp.w	r8,1
800031ae:	e0 88 04 a4 	brls	80003af6 <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
800031b2:	fe f8 09 d6 	ld.w	r8,pc[2518]
800031b6:	70 0a       	ld.w	r10,r8[0x0]
800031b8:	6e 3b       	ld.w	r11,r7[0xc]
800031ba:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800031be:	70 09       	ld.w	r9,r8[0x0]
800031c0:	2f f9       	sub	r9,-1
800031c2:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800031c4:	e0 49 00 ff 	cp.w	r9,255
800031c8:	e0 88 00 11 	brls	800031ea <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
800031cc:	30 09       	mov	r9,0
800031ce:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800031d0:	fe f7 09 60 	ld.w	r7,pc[2400]
800031d4:	6e 0c       	ld.w	r12,r7[0x0]
800031d6:	f0 1f 02 63 	mcall	80003b60 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800031da:	fe f8 09 52 	ld.w	r8,pc[2386]
800031de:	70 0c       	ld.w	r12,r8[0x0]
800031e0:	f0 1f 02 4d 	mcall	80003b14 <phy_rx_func+0xe98>
800031e4:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800031e6:	e0 80 04 88 	breq	80003af6 <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
800031ea:	fe f9 09 56 	ld.w	r9,pc[2390]
800031ee:	72 08       	ld.w	r8,r9[0x0]
800031f0:	20 28       	sub	r8,2
800031f2:	93 08       	st.w	r9[0x0],r8
800031f4:	e0 80 04 81 	breq	80003af6 <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
800031f8:	30 29       	mov	r9,2
800031fa:	fe f8 09 3e 	ld.w	r8,pc[2366]
800031fe:	91 09       	st.w	r8[0x0],r9
80003200:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003204:	fe f8 09 84 	ld.w	r8,pc[2436]
80003208:	70 0a       	ld.w	r10,r8[0x0]
8000320a:	fe f9 09 26 	ld.w	r9,pc[2342]
8000320e:	72 09       	ld.w	r9,r9[0x0]
80003210:	8e 4b       	ld.sh	r11,r7[0x8]
80003212:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
80003216:	70 09       	ld.w	r9,r8[0x0]
80003218:	2f f9       	sub	r9,-1
8000321a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000321c:	e0 49 00 ff 	cp.w	r9,255
80003220:	e0 88 00 16 	brls	8000324c <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
80003224:	30 09       	mov	r9,0
80003226:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003228:	fe f6 09 08 	ld.w	r6,pc[2312]
8000322c:	6c 0c       	ld.w	r12,r6[0x0]
8000322e:	f0 1f 02 4d 	mcall	80003b60 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003232:	fe f8 08 fa 	ld.w	r8,pc[2298]
80003236:	70 0c       	ld.w	r12,r8[0x0]
80003238:	f0 1f 02 37 	mcall	80003b14 <phy_rx_func+0xe98>
8000323c:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000323e:	c0 71       	brne	8000324c <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
80003240:	30 09       	mov	r9,0
80003242:	fe f8 08 f6 	ld.w	r8,pc[2294]
80003246:	91 09       	st.w	r8[0x0],r9
80003248:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
8000324c:	fe f9 08 f4 	ld.w	r9,pc[2292]
80003250:	72 08       	ld.w	r8,r9[0x0]
80003252:	20 28       	sub	r8,2
80003254:	93 08       	st.w	r9[0x0],r8
80003256:	c0 71       	brne	80003264 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
80003258:	30 09       	mov	r9,0
8000325a:	fe f8 08 de 	ld.w	r8,pc[2270]
8000325e:	91 09       	st.w	r8[0x0],r9
80003260:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003264:	fe f8 09 24 	ld.w	r8,pc[2340]
80003268:	70 0a       	ld.w	r10,r8[0x0]
8000326a:	fe f9 08 c6 	ld.w	r9,pc[2246]
8000326e:	72 09       	ld.w	r9,r9[0x0]
80003270:	8e 5b       	ld.sh	r11,r7[0xa]
80003272:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003276:	70 09       	ld.w	r9,r8[0x0]
80003278:	2f f9       	sub	r9,-1
8000327a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000327c:	e0 49 00 ff 	cp.w	r9,255
80003280:	e0 88 00 16 	brls	800032ac <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003284:	30 09       	mov	r9,0
80003286:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003288:	fe f6 08 a8 	ld.w	r6,pc[2216]
8000328c:	6c 0c       	ld.w	r12,r6[0x0]
8000328e:	f0 1f 02 35 	mcall	80003b60 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003292:	fe f8 08 9a 	ld.w	r8,pc[2202]
80003296:	70 0c       	ld.w	r12,r8[0x0]
80003298:	f0 1f 02 1f 	mcall	80003b14 <phy_rx_func+0xe98>
8000329c:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000329e:	c0 71       	brne	800032ac <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
800032a0:	30 09       	mov	r9,0
800032a2:	fe f8 08 96 	ld.w	r8,pc[2198]
800032a6:	91 09       	st.w	r8[0x0],r9
800032a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800032ac:	fe f9 08 94 	ld.w	r9,pc[2196]
800032b0:	72 08       	ld.w	r8,r9[0x0]
800032b2:	20 28       	sub	r8,2
800032b4:	93 08       	st.w	r9[0x0],r8
800032b6:	c0 71       	brne	800032c4 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
800032b8:	30 09       	mov	r9,0
800032ba:	fe f8 08 7e 	ld.w	r8,pc[2174]
800032be:	91 09       	st.w	r8[0x0],r9
800032c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
800032c4:	fe f8 08 c4 	ld.w	r8,pc[2244]
800032c8:	70 0a       	ld.w	r10,r8[0x0]
800032ca:	fe f9 08 66 	ld.w	r9,pc[2150]
800032ce:	72 09       	ld.w	r9,r9[0x0]
800032d0:	8e 6b       	ld.sh	r11,r7[0xc]
800032d2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800032d6:	70 09       	ld.w	r9,r8[0x0]
800032d8:	2f f9       	sub	r9,-1
800032da:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800032dc:	e0 49 00 ff 	cp.w	r9,255
800032e0:	e0 88 00 16 	brls	8000330c <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
800032e4:	30 09       	mov	r9,0
800032e6:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800032e8:	fe f6 08 48 	ld.w	r6,pc[2120]
800032ec:	6c 0c       	ld.w	r12,r6[0x0]
800032ee:	f0 1f 02 1d 	mcall	80003b60 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800032f2:	fe f8 08 3a 	ld.w	r8,pc[2106]
800032f6:	70 0c       	ld.w	r12,r8[0x0]
800032f8:	f0 1f 02 07 	mcall	80003b14 <phy_rx_func+0xe98>
800032fc:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800032fe:	c0 71       	brne	8000330c <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
80003300:	30 09       	mov	r9,0
80003302:	fe f8 08 36 	ld.w	r8,pc[2102]
80003306:	91 09       	st.w	r8[0x0],r9
80003308:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
8000330c:	fe f9 08 34 	ld.w	r9,pc[2100]
80003310:	72 08       	ld.w	r8,r9[0x0]
80003312:	20 28       	sub	r8,2
80003314:	93 08       	st.w	r9[0x0],r8
80003316:	c0 71       	brne	80003324 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
80003318:	30 09       	mov	r9,0
8000331a:	fe f8 08 1e 	ld.w	r8,pc[2078]
8000331e:	91 09       	st.w	r8[0x0],r9
80003320:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003324:	fe f8 08 64 	ld.w	r8,pc[2148]
80003328:	70 0a       	ld.w	r10,r8[0x0]
8000332a:	fe f9 08 06 	ld.w	r9,pc[2054]
8000332e:	72 09       	ld.w	r9,r9[0x0]
80003330:	8e 7b       	ld.sh	r11,r7[0xe]
80003332:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003336:	70 09       	ld.w	r9,r8[0x0]
80003338:	2f f9       	sub	r9,-1
8000333a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000333c:	e0 49 00 ff 	cp.w	r9,255
80003340:	e0 88 00 16 	brls	8000336c <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
80003344:	30 09       	mov	r9,0
80003346:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003348:	fe f7 07 e8 	ld.w	r7,pc[2024]
8000334c:	6e 0c       	ld.w	r12,r7[0x0]
8000334e:	f0 1f 02 05 	mcall	80003b60 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003352:	fe f8 07 da 	ld.w	r8,pc[2010]
80003356:	70 0c       	ld.w	r12,r8[0x0]
80003358:	f0 1f 01 ef 	mcall	80003b14 <phy_rx_func+0xe98>
8000335c:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
8000335e:	c0 71       	brne	8000336c <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
80003360:	30 09       	mov	r9,0
80003362:	fe f8 07 d6 	ld.w	r8,pc[2006]
80003366:	91 09       	st.w	r8[0x0],r9
80003368:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
8000336c:	fe f9 07 d4 	ld.w	r9,pc[2004]
80003370:	72 08       	ld.w	r8,r9[0x0]
80003372:	20 28       	sub	r8,2
80003374:	93 08       	st.w	r9[0x0],r8
80003376:	e0 81 03 c0 	brne	80003af6 <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
8000337a:	30 09       	mov	r9,0
8000337c:	fe f8 07 bc 	ld.w	r8,pc[1980]
80003380:	91 09       	st.w	r8[0x0],r9
80003382:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003386:	fe f8 07 ca 	ld.w	r8,pc[1994]
8000338a:	11 89       	ld.ub	r9,r8[0x0]
8000338c:	31 28       	mov	r8,18
8000338e:	f0 09 18 00 	cp.b	r9,r8
80003392:	e0 81 01 4c 	brne	8000362a <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
80003396:	ef 39 00 09 	ld.ub	r9,r7[9]
8000339a:	fe f8 07 b6 	ld.w	r8,pc[1974]
8000339e:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
800033a0:	11 89       	ld.ub	r9,r8[0x0]
800033a2:	3f 28       	mov	r8,-14
800033a4:	f0 09 18 00 	cp.b	r9,r8
800033a8:	e0 81 01 3b 	brne	8000361e <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
800033ac:	30 19       	mov	r9,1
800033ae:	fe f8 07 ce 	ld.w	r8,pc[1998]
800033b2:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
800033b4:	6e 29       	ld.w	r9,r7[0x8]
800033b6:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
800033ba:	fe f8 07 86 	ld.w	r8,pc[1926]
800033be:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
800033c0:	8e 59       	ld.sh	r9,r7[0xa]
800033c2:	fe f8 07 ce 	ld.w	r8,pc[1998]
800033c6:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
800033c8:	8e 69       	ld.sh	r9,r7[0xc]
800033ca:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
800033cc:	8e 79       	ld.sh	r9,r7[0xe]
800033ce:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
800033d0:	fe f8 07 88 	ld.w	r8,pc[1928]
800033d4:	fe f9 07 60 	ld.w	r9,pc[1888]
800033d8:	72 0a       	ld.w	r10,r9[0x0]
800033da:	70 09       	ld.w	r9,r8[0x0]
800033dc:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800033e0:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800033e4:	70 09       	ld.w	r9,r8[0x0]
800033e6:	2f f9       	sub	r9,-1
800033e8:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800033ea:	e0 49 01 ff 	cp.w	r9,511
800033ee:	e0 88 00 16 	brls	8000341a <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
800033f2:	30 09       	mov	r9,0
800033f4:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800033f6:	fe f6 07 3e 	ld.w	r6,pc[1854]
800033fa:	6c 0c       	ld.w	r12,r6[0x0]
800033fc:	f0 1f 01 d9 	mcall	80003b60 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003400:	fe f8 07 2c 	ld.w	r8,pc[1836]
80003404:	70 0c       	ld.w	r12,r8[0x0]
80003406:	f0 1f 01 c4 	mcall	80003b14 <phy_rx_func+0xe98>
8000340a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000340c:	c0 71       	brne	8000341a <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
8000340e:	30 09       	mov	r9,0
80003410:	fe f8 07 28 	ld.w	r8,pc[1832]
80003414:	91 09       	st.w	r8[0x0],r9
80003416:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000341a:	fe f9 07 26 	ld.w	r9,pc[1830]
8000341e:	72 08       	ld.w	r8,r9[0x0]
80003420:	20 18       	sub	r8,1
80003422:	93 08       	st.w	r9[0x0],r8
80003424:	c0 71       	brne	80003432 <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
80003426:	30 09       	mov	r9,0
80003428:	fe f8 07 10 	ld.w	r8,pc[1808]
8000342c:	91 09       	st.w	r8[0x0],r9
8000342e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003432:	fe f8 07 26 	ld.w	r8,pc[1830]
80003436:	fe f9 06 fe 	ld.w	r9,pc[1790]
8000343a:	72 0a       	ld.w	r10,r9[0x0]
8000343c:	70 09       	ld.w	r9,r8[0x0]
8000343e:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003442:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003446:	70 09       	ld.w	r9,r8[0x0]
80003448:	2f f9       	sub	r9,-1
8000344a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000344c:	e0 49 01 ff 	cp.w	r9,511
80003450:	e0 88 00 16 	brls	8000347c <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
80003454:	30 09       	mov	r9,0
80003456:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003458:	fe f6 06 dc 	ld.w	r6,pc[1756]
8000345c:	6c 0c       	ld.w	r12,r6[0x0]
8000345e:	f0 1f 01 c1 	mcall	80003b60 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003462:	fe f8 06 ca 	ld.w	r8,pc[1738]
80003466:	70 0c       	ld.w	r12,r8[0x0]
80003468:	f0 1f 01 ab 	mcall	80003b14 <phy_rx_func+0xe98>
8000346c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000346e:	c0 71       	brne	8000347c <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
80003470:	30 09       	mov	r9,0
80003472:	fe f8 06 c6 	ld.w	r8,pc[1734]
80003476:	91 09       	st.w	r8[0x0],r9
80003478:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000347c:	fe f9 06 c4 	ld.w	r9,pc[1732]
80003480:	72 08       	ld.w	r8,r9[0x0]
80003482:	20 18       	sub	r8,1
80003484:	93 08       	st.w	r9[0x0],r8
80003486:	c0 71       	brne	80003494 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003488:	30 09       	mov	r9,0
8000348a:	fe f8 06 ae 	ld.w	r8,pc[1710]
8000348e:	91 09       	st.w	r8[0x0],r9
80003490:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003494:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003498:	fe f9 06 9c 	ld.w	r9,pc[1692]
8000349c:	72 0a       	ld.w	r10,r9[0x0]
8000349e:	70 09       	ld.w	r9,r8[0x0]
800034a0:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800034a4:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800034a8:	70 09       	ld.w	r9,r8[0x0]
800034aa:	2f f9       	sub	r9,-1
800034ac:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800034ae:	e0 49 01 ff 	cp.w	r9,511
800034b2:	e0 88 00 16 	brls	800034de <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
800034b6:	30 09       	mov	r9,0
800034b8:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800034ba:	fe f6 06 7a 	ld.w	r6,pc[1658]
800034be:	6c 0c       	ld.w	r12,r6[0x0]
800034c0:	f0 1f 01 a8 	mcall	80003b60 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800034c4:	fe f8 06 68 	ld.w	r8,pc[1640]
800034c8:	70 0c       	ld.w	r12,r8[0x0]
800034ca:	f0 1f 01 93 	mcall	80003b14 <phy_rx_func+0xe98>
800034ce:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800034d0:	c0 71       	brne	800034de <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
800034d2:	30 09       	mov	r9,0
800034d4:	fe f8 06 64 	ld.w	r8,pc[1636]
800034d8:	91 09       	st.w	r8[0x0],r9
800034da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800034de:	fe f9 06 62 	ld.w	r9,pc[1634]
800034e2:	72 08       	ld.w	r8,r9[0x0]
800034e4:	20 18       	sub	r8,1
800034e6:	93 08       	st.w	r9[0x0],r8
800034e8:	c0 71       	brne	800034f6 <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
800034ea:	30 09       	mov	r9,0
800034ec:	fe f8 06 4c 	ld.w	r8,pc[1612]
800034f0:	91 09       	st.w	r8[0x0],r9
800034f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
800034f6:	fe f8 06 62 	ld.w	r8,pc[1634]
800034fa:	fe f9 06 3a 	ld.w	r9,pc[1594]
800034fe:	72 0a       	ld.w	r10,r9[0x0]
80003500:	70 09       	ld.w	r9,r8[0x0]
80003502:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003506:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000350a:	70 09       	ld.w	r9,r8[0x0]
8000350c:	2f f9       	sub	r9,-1
8000350e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003510:	e0 49 01 ff 	cp.w	r9,511
80003514:	e0 88 00 16 	brls	80003540 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003518:	30 09       	mov	r9,0
8000351a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000351c:	fe f6 06 18 	ld.w	r6,pc[1560]
80003520:	6c 0c       	ld.w	r12,r6[0x0]
80003522:	f0 1f 01 90 	mcall	80003b60 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003526:	fe f8 06 06 	ld.w	r8,pc[1542]
8000352a:	70 0c       	ld.w	r12,r8[0x0]
8000352c:	f0 1f 01 7a 	mcall	80003b14 <phy_rx_func+0xe98>
80003530:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003532:	c0 71       	brne	80003540 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80003534:	30 09       	mov	r9,0
80003536:	fe f8 06 02 	ld.w	r8,pc[1538]
8000353a:	91 09       	st.w	r8[0x0],r9
8000353c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003540:	fe f9 06 00 	ld.w	r9,pc[1536]
80003544:	72 08       	ld.w	r8,r9[0x0]
80003546:	20 18       	sub	r8,1
80003548:	93 08       	st.w	r9[0x0],r8
8000354a:	c0 71       	brne	80003558 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
8000354c:	30 09       	mov	r9,0
8000354e:	fe f8 05 ea 	ld.w	r8,pc[1514]
80003552:	91 09       	st.w	r8[0x0],r9
80003554:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003558:	fe f8 06 00 	ld.w	r8,pc[1536]
8000355c:	fe f9 05 d8 	ld.w	r9,pc[1496]
80003560:	72 0a       	ld.w	r10,r9[0x0]
80003562:	70 09       	ld.w	r9,r8[0x0]
80003564:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003568:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000356c:	70 09       	ld.w	r9,r8[0x0]
8000356e:	2f f9       	sub	r9,-1
80003570:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003572:	e0 49 01 ff 	cp.w	r9,511
80003576:	e0 88 00 16 	brls	800035a2 <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
8000357a:	30 09       	mov	r9,0
8000357c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000357e:	fe f6 05 b6 	ld.w	r6,pc[1462]
80003582:	6c 0c       	ld.w	r12,r6[0x0]
80003584:	f0 1f 01 77 	mcall	80003b60 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003588:	fe f8 05 a4 	ld.w	r8,pc[1444]
8000358c:	70 0c       	ld.w	r12,r8[0x0]
8000358e:	f0 1f 01 62 	mcall	80003b14 <phy_rx_func+0xe98>
80003592:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003594:	c0 71       	brne	800035a2 <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
80003596:	30 09       	mov	r9,0
80003598:	fe f8 05 a0 	ld.w	r8,pc[1440]
8000359c:	91 09       	st.w	r8[0x0],r9
8000359e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035a2:	fe f9 05 9e 	ld.w	r9,pc[1438]
800035a6:	72 08       	ld.w	r8,r9[0x0]
800035a8:	20 18       	sub	r8,1
800035aa:	93 08       	st.w	r9[0x0],r8
800035ac:	c0 71       	brne	800035ba <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
800035ae:	30 09       	mov	r9,0
800035b0:	fe f8 05 88 	ld.w	r8,pc[1416]
800035b4:	91 09       	st.w	r8[0x0],r9
800035b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
800035ba:	fe f8 05 9e 	ld.w	r8,pc[1438]
800035be:	fe f9 05 76 	ld.w	r9,pc[1398]
800035c2:	72 0a       	ld.w	r10,r9[0x0]
800035c4:	70 09       	ld.w	r9,r8[0x0]
800035c6:	ef 3b 00 0f 	ld.ub	r11,r7[15]
800035ca:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800035ce:	70 09       	ld.w	r9,r8[0x0]
800035d0:	2f f9       	sub	r9,-1
800035d2:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035d4:	e0 49 01 ff 	cp.w	r9,511
800035d8:	e0 88 00 16 	brls	80003604 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
800035dc:	30 09       	mov	r9,0
800035de:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035e0:	fe f7 05 54 	ld.w	r7,pc[1364]
800035e4:	6e 0c       	ld.w	r12,r7[0x0]
800035e6:	f0 1f 01 5f 	mcall	80003b60 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800035ea:	fe f8 05 42 	ld.w	r8,pc[1346]
800035ee:	70 0c       	ld.w	r12,r8[0x0]
800035f0:	f0 1f 01 49 	mcall	80003b14 <phy_rx_func+0xe98>
800035f4:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035f6:	c0 71       	brne	80003604 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
800035f8:	30 09       	mov	r9,0
800035fa:	fe f8 05 3e 	ld.w	r8,pc[1342]
800035fe:	91 09       	st.w	r8[0x0],r9
80003600:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003604:	fe f9 05 3c 	ld.w	r9,pc[1340]
80003608:	72 08       	ld.w	r8,r9[0x0]
8000360a:	20 18       	sub	r8,1
8000360c:	93 08       	st.w	r9[0x0],r8
8000360e:	e0 81 02 74 	brne	80003af6 <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
80003612:	30 09       	mov	r9,0
80003614:	fe f8 05 24 	ld.w	r8,pc[1316]
80003618:	91 09       	st.w	r8[0x0],r9
8000361a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
8000361e:	30 09       	mov	r9,0
80003620:	fe f8 05 18 	ld.w	r8,pc[1304]
80003624:	91 09       	st.w	r8[0x0],r9
80003626:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
8000362a:	fe f8 05 26 	ld.w	r8,pc[1318]
8000362e:	11 89       	ld.ub	r9,r8[0x0]
80003630:	3f 28       	mov	r8,-14
80003632:	f0 09 18 00 	cp.b	r9,r8
80003636:	c4 31       	brne	800036bc <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003638:	8e 49       	ld.sh	r9,r7[0x8]
8000363a:	fe f8 05 56 	ld.w	r8,pc[1366]
8000363e:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003640:	fe f8 05 18 	ld.w	r8,pc[1304]
80003644:	fe f9 04 f0 	ld.w	r9,pc[1264]
80003648:	72 0a       	ld.w	r10,r9[0x0]
8000364a:	70 09       	ld.w	r9,r8[0x0]
8000364c:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003650:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003654:	70 09       	ld.w	r9,r8[0x0]
80003656:	2f f9       	sub	r9,-1
80003658:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000365a:	e0 49 01 ff 	cp.w	r9,511
8000365e:	e0 88 00 16 	brls	8000368a <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003662:	30 09       	mov	r9,0
80003664:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003666:	fe f7 04 ce 	ld.w	r7,pc[1230]
8000366a:	6e 0c       	ld.w	r12,r7[0x0]
8000366c:	f0 1f 01 3d 	mcall	80003b60 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003670:	fe f8 04 bc 	ld.w	r8,pc[1212]
80003674:	70 0c       	ld.w	r12,r8[0x0]
80003676:	f0 1f 01 28 	mcall	80003b14 <phy_rx_func+0xe98>
8000367a:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000367c:	c0 71       	brne	8000368a <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
8000367e:	30 09       	mov	r9,0
80003680:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003684:	91 09       	st.w	r8[0x0],r9
80003686:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000368a:	fe f9 04 b6 	ld.w	r9,pc[1206]
8000368e:	72 08       	ld.w	r8,r9[0x0]
80003690:	20 18       	sub	r8,1
80003692:	93 08       	st.w	r9[0x0],r8
80003694:	c0 71       	brne	800036a2 <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
80003696:	30 09       	mov	r9,0
80003698:	fe f8 04 a0 	ld.w	r8,pc[1184]
8000369c:	91 09       	st.w	r8[0x0],r9
8000369e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
800036a2:	20 18       	sub	r8,1
800036a4:	fe f9 04 9c 	ld.w	r9,pc[1180]
800036a8:	93 08       	st.w	r9[0x0],r8
800036aa:	58 08       	cp.w	r8,0
800036ac:	e0 81 02 25 	brne	80003af6 <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
800036b0:	30 09       	mov	r9,0
800036b2:	fe f8 04 86 	ld.w	r8,pc[1158]
800036b6:	91 09       	st.w	r8[0x0],r9
800036b8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
800036bc:	fe f8 04 94 	ld.w	r8,pc[1172]
800036c0:	11 89       	ld.ub	r9,r8[0x0]
800036c2:	3f 38       	mov	r8,-13
800036c4:	f0 09 18 00 	cp.b	r9,r8
800036c8:	e0 81 01 0c 	brne	800038e0 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
800036cc:	8e 49       	ld.sh	r9,r7[0x8]
800036ce:	fe f8 04 c2 	ld.w	r8,pc[1218]
800036d2:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
800036d4:	8e 59       	ld.sh	r9,r7[0xa]
800036d6:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
800036d8:	8e 69       	ld.sh	r9,r7[0xc]
800036da:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
800036dc:	fe f8 04 7c 	ld.w	r8,pc[1148]
800036e0:	fe f9 04 54 	ld.w	r9,pc[1108]
800036e4:	72 0a       	ld.w	r10,r9[0x0]
800036e6:	70 09       	ld.w	r9,r8[0x0]
800036e8:	ef 3b 00 08 	ld.ub	r11,r7[8]
800036ec:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800036f0:	70 09       	ld.w	r9,r8[0x0]
800036f2:	2f f9       	sub	r9,-1
800036f4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036f6:	e0 49 01 ff 	cp.w	r9,511
800036fa:	e0 88 00 16 	brls	80003726 <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
800036fe:	30 09       	mov	r9,0
80003700:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003702:	fe f6 04 32 	ld.w	r6,pc[1074]
80003706:	6c 0c       	ld.w	r12,r6[0x0]
80003708:	f0 1f 01 16 	mcall	80003b60 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000370c:	fe f8 04 20 	ld.w	r8,pc[1056]
80003710:	70 0c       	ld.w	r12,r8[0x0]
80003712:	f0 1f 01 01 	mcall	80003b14 <phy_rx_func+0xe98>
80003716:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003718:	c0 71       	brne	80003726 <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
8000371a:	30 09       	mov	r9,0
8000371c:	fe f8 04 1c 	ld.w	r8,pc[1052]
80003720:	91 09       	st.w	r8[0x0],r9
80003722:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003726:	fe f9 04 1a 	ld.w	r9,pc[1050]
8000372a:	72 08       	ld.w	r8,r9[0x0]
8000372c:	20 18       	sub	r8,1
8000372e:	93 08       	st.w	r9[0x0],r8
80003730:	c0 71       	brne	8000373e <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
80003732:	30 09       	mov	r9,0
80003734:	fe f8 04 04 	ld.w	r8,pc[1028]
80003738:	91 09       	st.w	r8[0x0],r9
8000373a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
8000373e:	fe f8 04 1a 	ld.w	r8,pc[1050]
80003742:	fe f9 03 f2 	ld.w	r9,pc[1010]
80003746:	72 0a       	ld.w	r10,r9[0x0]
80003748:	70 09       	ld.w	r9,r8[0x0]
8000374a:	ef 3b 00 09 	ld.ub	r11,r7[9]
8000374e:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003752:	70 09       	ld.w	r9,r8[0x0]
80003754:	2f f9       	sub	r9,-1
80003756:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003758:	e0 49 01 ff 	cp.w	r9,511
8000375c:	e0 88 00 16 	brls	80003788 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
80003760:	30 09       	mov	r9,0
80003762:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003764:	fe f6 03 d0 	ld.w	r6,pc[976]
80003768:	6c 0c       	ld.w	r12,r6[0x0]
8000376a:	f0 1f 00 fe 	mcall	80003b60 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000376e:	fe f8 03 be 	ld.w	r8,pc[958]
80003772:	70 0c       	ld.w	r12,r8[0x0]
80003774:	f0 1f 00 e8 	mcall	80003b14 <phy_rx_func+0xe98>
80003778:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000377a:	c0 71       	brne	80003788 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
8000377c:	30 09       	mov	r9,0
8000377e:	fe f8 03 ba 	ld.w	r8,pc[954]
80003782:	91 09       	st.w	r8[0x0],r9
80003784:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003788:	fe f9 03 b8 	ld.w	r9,pc[952]
8000378c:	72 08       	ld.w	r8,r9[0x0]
8000378e:	20 18       	sub	r8,1
80003790:	93 08       	st.w	r9[0x0],r8
80003792:	c0 71       	brne	800037a0 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80003794:	30 09       	mov	r9,0
80003796:	fe f8 03 a2 	ld.w	r8,pc[930]
8000379a:	91 09       	st.w	r8[0x0],r9
8000379c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
800037a0:	fe f8 03 b8 	ld.w	r8,pc[952]
800037a4:	fe f9 03 90 	ld.w	r9,pc[912]
800037a8:	72 0a       	ld.w	r10,r9[0x0]
800037aa:	70 09       	ld.w	r9,r8[0x0]
800037ac:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800037b0:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800037b4:	70 09       	ld.w	r9,r8[0x0]
800037b6:	2f f9       	sub	r9,-1
800037b8:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037ba:	e0 49 01 ff 	cp.w	r9,511
800037be:	e0 88 00 16 	brls	800037ea <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
800037c2:	30 09       	mov	r9,0
800037c4:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800037c6:	fe f6 03 6e 	ld.w	r6,pc[878]
800037ca:	6c 0c       	ld.w	r12,r6[0x0]
800037cc:	f0 1f 00 e5 	mcall	80003b60 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800037d0:	fe f8 03 5c 	ld.w	r8,pc[860]
800037d4:	70 0c       	ld.w	r12,r8[0x0]
800037d6:	f0 1f 00 d0 	mcall	80003b14 <phy_rx_func+0xe98>
800037da:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800037dc:	c0 71       	brne	800037ea <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
800037de:	30 09       	mov	r9,0
800037e0:	fe f8 03 58 	ld.w	r8,pc[856]
800037e4:	91 09       	st.w	r8[0x0],r9
800037e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800037ea:	fe f9 03 56 	ld.w	r9,pc[854]
800037ee:	72 08       	ld.w	r8,r9[0x0]
800037f0:	20 18       	sub	r8,1
800037f2:	93 08       	st.w	r9[0x0],r8
800037f4:	c0 71       	brne	80003802 <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
800037f6:	30 09       	mov	r9,0
800037f8:	fe f8 03 40 	ld.w	r8,pc[832]
800037fc:	91 09       	st.w	r8[0x0],r9
800037fe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003802:	fe f8 03 56 	ld.w	r8,pc[854]
80003806:	fe f9 03 2e 	ld.w	r9,pc[814]
8000380a:	72 0a       	ld.w	r10,r9[0x0]
8000380c:	70 09       	ld.w	r9,r8[0x0]
8000380e:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003812:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003816:	70 09       	ld.w	r9,r8[0x0]
80003818:	2f f9       	sub	r9,-1
8000381a:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000381c:	e0 49 01 ff 	cp.w	r9,511
80003820:	e0 88 00 16 	brls	8000384c <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003824:	30 09       	mov	r9,0
80003826:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003828:	fe f6 03 0c 	ld.w	r6,pc[780]
8000382c:	6c 0c       	ld.w	r12,r6[0x0]
8000382e:	f0 1f 00 cd 	mcall	80003b60 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003832:	fe f8 02 fa 	ld.w	r8,pc[762]
80003836:	70 0c       	ld.w	r12,r8[0x0]
80003838:	f0 1f 00 b7 	mcall	80003b14 <phy_rx_func+0xe98>
8000383c:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000383e:	c0 71       	brne	8000384c <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
80003840:	30 09       	mov	r9,0
80003842:	fe f8 02 f6 	ld.w	r8,pc[758]
80003846:	91 09       	st.w	r8[0x0],r9
80003848:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000384c:	fe f9 02 f4 	ld.w	r9,pc[756]
80003850:	72 08       	ld.w	r8,r9[0x0]
80003852:	20 18       	sub	r8,1
80003854:	93 08       	st.w	r9[0x0],r8
80003856:	c0 71       	brne	80003864 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
80003858:	30 09       	mov	r9,0
8000385a:	fe f8 02 de 	ld.w	r8,pc[734]
8000385e:	91 09       	st.w	r8[0x0],r9
80003860:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003864:	fe f8 02 f4 	ld.w	r8,pc[756]
80003868:	fe f9 02 cc 	ld.w	r9,pc[716]
8000386c:	72 0a       	ld.w	r10,r9[0x0]
8000386e:	70 09       	ld.w	r9,r8[0x0]
80003870:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003874:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003878:	70 09       	ld.w	r9,r8[0x0]
8000387a:	2f f9       	sub	r9,-1
8000387c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000387e:	e0 49 01 ff 	cp.w	r9,511
80003882:	e0 88 00 16 	brls	800038ae <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
80003886:	30 09       	mov	r9,0
80003888:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000388a:	fe f7 02 aa 	ld.w	r7,pc[682]
8000388e:	6e 0c       	ld.w	r12,r7[0x0]
80003890:	f0 1f 00 b4 	mcall	80003b60 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003894:	fe f8 02 98 	ld.w	r8,pc[664]
80003898:	70 0c       	ld.w	r12,r8[0x0]
8000389a:	f0 1f 00 9f 	mcall	80003b14 <phy_rx_func+0xe98>
8000389e:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038a0:	c0 71       	brne	800038ae <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
800038a2:	30 09       	mov	r9,0
800038a4:	fe f8 02 94 	ld.w	r8,pc[660]
800038a8:	91 09       	st.w	r8[0x0],r9
800038aa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038ae:	fe f9 02 92 	ld.w	r9,pc[658]
800038b2:	72 08       	ld.w	r8,r9[0x0]
800038b4:	20 18       	sub	r8,1
800038b6:	93 08       	st.w	r9[0x0],r8
800038b8:	c0 71       	brne	800038c6 <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
800038ba:	30 09       	mov	r9,0
800038bc:	fe f8 02 7c 	ld.w	r8,pc[636]
800038c0:	91 09       	st.w	r8[0x0],r9
800038c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
800038c6:	20 18       	sub	r8,1
800038c8:	fe f9 02 78 	ld.w	r9,pc[632]
800038cc:	93 08       	st.w	r9[0x0],r8
800038ce:	58 08       	cp.w	r8,0
800038d0:	e0 81 01 13 	brne	80003af6 <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
800038d4:	30 09       	mov	r9,0
800038d6:	fe f8 02 62 	ld.w	r8,pc[610]
800038da:	91 09       	st.w	r8[0x0],r9
800038dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
800038e0:	fe f8 02 70 	ld.w	r8,pc[624]
800038e4:	11 89       	ld.ub	r9,r8[0x0]
800038e6:	30 48       	mov	r8,4
800038e8:	f0 09 18 00 	cp.b	r9,r8
800038ec:	c0 80       	breq	800038fc <phy_rx_func+0xc80>
800038ee:	fe f8 02 62 	ld.w	r8,pc[610]
800038f2:	11 89       	ld.ub	r9,r8[0x0]
800038f4:	30 38       	mov	r8,3
800038f6:	f0 09 18 00 	cp.b	r9,r8
800038fa:	c1 41       	brne	80003922 <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
800038fc:	6e 29       	ld.w	r9,r7[0x8]
800038fe:	fe f8 02 7a 	ld.w	r8,pc[634]
80003902:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003904:	6e 39       	ld.w	r9,r7[0xc]
80003906:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003908:	fe f9 02 38 	ld.w	r9,pc[568]
8000390c:	72 08       	ld.w	r8,r9[0x0]
8000390e:	20 88       	sub	r8,8
80003910:	93 08       	st.w	r9[0x0],r8
80003912:	e0 81 00 f2 	brne	80003af6 <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003916:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003918:	fe f9 02 20 	ld.w	r9,pc[544]
8000391c:	93 08       	st.w	r9[0x0],r8
8000391e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003922:	fe f8 02 2e 	ld.w	r8,pc[558]
80003926:	11 89       	ld.ub	r9,r8[0x0]
80003928:	31 38       	mov	r8,19
8000392a:	f0 09 18 00 	cp.b	r9,r8
8000392e:	e0 81 00 9c 	brne	80003a66 <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80003932:	fe f8 02 62 	ld.w	r8,pc[610]
80003936:	11 88       	ld.ub	r8,r8[0x0]
80003938:	30 c9       	mov	r9,12
8000393a:	f2 08 18 00 	cp.b	r8,r9
8000393e:	e0 81 00 7b 	brne	80003a34 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003942:	8e 49       	ld.sh	r9,r7[0x8]
80003944:	fe f8 02 54 	ld.w	r8,pc[596]
80003948:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
8000394c:	30 09       	mov	r9,0
8000394e:	fe f8 02 46 	ld.w	r8,pc[582]
80003952:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003954:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003958:	3f 38       	mov	r8,-13
8000395a:	f0 09 18 00 	cp.b	r9,r8
8000395e:	c6 61       	brne	80003a2a <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003960:	10 99       	mov	r9,r8
80003962:	4f c8       	lddpc	r8,80003b50 <phy_rx_func+0xed4>
80003964:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003966:	ef 39 00 0c 	ld.ub	r9,r7[12]
8000396a:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
8000396e:	4f 58       	lddpc	r8,80003b40 <phy_rx_func+0xec4>
80003970:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003972:	30 19       	mov	r9,1
80003974:	fe f8 02 0c 	ld.w	r8,pc[524]
80003978:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
8000397a:	8e 79       	ld.sh	r9,r7[0xe]
8000397c:	fe f8 02 14 	ld.w	r8,pc[532]
80003980:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003982:	4f 68       	lddpc	r8,80003b58 <phy_rx_func+0xedc>
80003984:	4e c9       	lddpc	r9,80003b34 <phy_rx_func+0xeb8>
80003986:	72 0a       	ld.w	r10,r9[0x0]
80003988:	70 09       	ld.w	r9,r8[0x0]
8000398a:	ef 3b 00 0e 	ld.ub	r11,r7[14]
8000398e:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003992:	70 09       	ld.w	r9,r8[0x0]
80003994:	2f f9       	sub	r9,-1
80003996:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003998:	e0 49 01 ff 	cp.w	r9,511
8000399c:	e0 88 00 13 	brls	800039c2 <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
800039a0:	30 09       	mov	r9,0
800039a2:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
800039a4:	4e 46       	lddpc	r6,80003b34 <phy_rx_func+0xeb8>
800039a6:	6c 0c       	ld.w	r12,r6[0x0]
800039a8:	f0 1f 00 6e 	mcall	80003b60 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
800039ac:	4e 08       	lddpc	r8,80003b2c <phy_rx_func+0xeb0>
800039ae:	70 0c       	ld.w	r12,r8[0x0]
800039b0:	f0 1f 00 59 	mcall	80003b14 <phy_rx_func+0xe98>
800039b4:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
800039b6:	c0 61       	brne	800039c2 <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
800039b8:	30 09       	mov	r9,0
800039ba:	4e 08       	lddpc	r8,80003b38 <phy_rx_func+0xebc>
800039bc:	91 09       	st.w	r8[0x0],r9
800039be:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
800039c2:	4e 09       	lddpc	r9,80003b40 <phy_rx_func+0xec4>
800039c4:	72 08       	ld.w	r8,r9[0x0]
800039c6:	20 18       	sub	r8,1
800039c8:	93 08       	st.w	r9[0x0],r8
800039ca:	c0 61       	brne	800039d6 <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
800039cc:	30 09       	mov	r9,0
800039ce:	4d b8       	lddpc	r8,80003b38 <phy_rx_func+0xebc>
800039d0:	91 09       	st.w	r8[0x0],r9
800039d2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
800039d6:	4e 18       	lddpc	r8,80003b58 <phy_rx_func+0xedc>
800039d8:	4d 79       	lddpc	r9,80003b34 <phy_rx_func+0xeb8>
800039da:	72 0a       	ld.w	r10,r9[0x0]
800039dc:	70 09       	ld.w	r9,r8[0x0]
800039de:	ef 3b 00 0f 	ld.ub	r11,r7[15]
800039e2:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
800039e6:	70 09       	ld.w	r9,r8[0x0]
800039e8:	2f f9       	sub	r9,-1
800039ea:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039ec:	e0 49 01 ff 	cp.w	r9,511
800039f0:	e0 88 00 13 	brls	80003a16 <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
800039f4:	30 09       	mov	r9,0
800039f6:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
800039f8:	4c f7       	lddpc	r7,80003b34 <phy_rx_func+0xeb8>
800039fa:	6e 0c       	ld.w	r12,r7[0x0]
800039fc:	f0 1f 00 59 	mcall	80003b60 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003a00:	4c b8       	lddpc	r8,80003b2c <phy_rx_func+0xeb0>
80003a02:	70 0c       	ld.w	r12,r8[0x0]
80003a04:	f0 1f 00 44 	mcall	80003b14 <phy_rx_func+0xe98>
80003a08:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003a0a:	c0 61       	brne	80003a16 <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003a0c:	30 09       	mov	r9,0
80003a0e:	4c b8       	lddpc	r8,80003b38 <phy_rx_func+0xebc>
80003a10:	91 09       	st.w	r8[0x0],r9
80003a12:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003a16:	4c b9       	lddpc	r9,80003b40 <phy_rx_func+0xec4>
80003a18:	72 08       	ld.w	r8,r9[0x0]
80003a1a:	20 18       	sub	r8,1
80003a1c:	93 08       	st.w	r9[0x0],r8
80003a1e:	c6 c1       	brne	80003af6 <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003a20:	30 09       	mov	r9,0
80003a22:	4c 68       	lddpc	r8,80003b38 <phy_rx_func+0xebc>
80003a24:	91 09       	st.w	r8[0x0],r9
80003a26:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003a2a:	30 09       	mov	r9,0
80003a2c:	4c 38       	lddpc	r8,80003b38 <phy_rx_func+0xebc>
80003a2e:	91 09       	st.w	r8[0x0],r9
80003a30:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003a34:	8e 4a       	ld.sh	r10,r7[0x8]
80003a36:	4d 99       	lddpc	r9,80003b98 <phy_rx_func+0xf1c>
80003a38:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003a3c:	4d 6a       	lddpc	r10,80003b94 <phy_rx_func+0xf18>
80003a3e:	15 88       	ld.ub	r8,r10[0x0]
80003a40:	f0 cb ff ff 	sub	r11,r8,-1
80003a44:	8e 5c       	ld.sh	r12,r7[0xa]
80003a46:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003a4a:	f0 cb ff fe 	sub	r11,r8,-2
80003a4e:	8e 6c       	ld.sh	r12,r7[0xc]
80003a50:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003a54:	f0 cb ff fd 	sub	r11,r8,-3
80003a58:	8e 7c       	ld.sh	r12,r7[0xe]
80003a5a:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003a5e:	2f c8       	sub	r8,-4
80003a60:	b4 88       	st.b	r10[0x0],r8
80003a62:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003a66:	30 09       	mov	r9,0
80003a68:	4b 48       	lddpc	r8,80003b38 <phy_rx_func+0xebc>
80003a6a:	91 09       	st.w	r8[0x0],r9
80003a6c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003a70:	4c 08       	lddpc	r8,80003b70 <phy_rx_func+0xef4>
80003a72:	70 09       	ld.w	r9,r8[0x0]
80003a74:	8e 4b       	ld.sh	r11,r7[0x8]
80003a76:	4c 0a       	lddpc	r10,80003b74 <phy_rx_func+0xef8>
80003a78:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003a7c:	2f f9       	sub	r9,-1
80003a7e:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003a80:	4b 58       	lddpc	r8,80003b54 <phy_rx_func+0xed8>
80003a82:	70 09       	ld.w	r9,r8[0x0]
80003a84:	20 29       	sub	r9,2
80003a86:	91 09       	st.w	r8[0x0],r9
80003a88:	70 08       	ld.w	r8,r8[0x0]
80003a8a:	58 08       	cp.w	r8,0
80003a8c:	c2 f1       	brne	80003aea <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003a8e:	30 09       	mov	r9,0
80003a90:	4b 88       	lddpc	r8,80003b70 <phy_rx_func+0xef4>
80003a92:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003a94:	8e 59       	ld.sh	r9,r7[0xa]
80003a96:	fe 78 82 12 	mov	r8,-32238
80003a9a:	f0 09 19 00 	cp.h	r9,r8
80003a9e:	c2 11       	brne	80003ae0 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003aa0:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003aa4:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003aa8:	4a f8       	lddpc	r8,80003b64 <phy_rx_func+0xee8>
80003aaa:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003aac:	8e 59       	ld.sh	r9,r7[0xa]
80003aae:	4a f8       	lddpc	r8,80003b68 <phy_rx_func+0xeec>
80003ab0:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003ab2:	8e 69       	ld.sh	r9,r7[0xc]
80003ab4:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003ab6:	f0 1f 00 2e 	mcall	80003b6c <phy_rx_func+0xef0>
80003aba:	4a 18       	lddpc	r8,80003b3c <phy_rx_func+0xec0>
80003abc:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003abe:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003ac2:	31 38       	mov	r8,19
80003ac4:	f0 09 18 00 	cp.b	r9,r8
80003ac8:	c0 71       	brne	80003ad6 <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003aca:	10 99       	mov	r9,r8
80003acc:	4a 18       	lddpc	r8,80003b50 <phy_rx_func+0xed4>
80003ace:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003ad0:	30 09       	mov	r9,0
80003ad2:	49 c8       	lddpc	r8,80003b40 <phy_rx_func+0xec4>
80003ad4:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003ad6:	30 49       	mov	r9,4
80003ad8:	49 88       	lddpc	r8,80003b38 <phy_rx_func+0xebc>
80003ada:	91 09       	st.w	r8[0x0],r9
80003adc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003ae0:	30 09       	mov	r9,0
80003ae2:	49 68       	lddpc	r8,80003b38 <phy_rx_func+0xebc>
80003ae4:	91 09       	st.w	r8[0x0],r9
80003ae6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003aea:	4a dc       	lddpc	r12,80003b9c <phy_rx_func+0xf20>
80003aec:	f0 1f 00 18 	mcall	80003b4c <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003af0:	30 09       	mov	r9,0
80003af2:	49 28       	lddpc	r8,80003b38 <phy_rx_func+0xebc>
80003af4:	91 09       	st.w	r8[0x0],r9
80003af6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003afa:	00 00       	add	r0,r0
80003afc:	00 00       	add	r0,r0
80003afe:	0a bc       	st.h	r5++,r12
80003b00:	00 00       	add	r0,r0
80003b02:	0a d4       	st.w	--r5,r4
80003b04:	00 00       	add	r0,r0
80003b06:	0a b4       	st.h	r5++,r4
80003b08:	00 00       	add	r0,r0
80003b0a:	0a 96       	mov	r6,r5
80003b0c:	00 00       	add	r0,r0
80003b0e:	0a 84       	andn	r4,r5
80003b10:	00 00       	add	r0,r0
80003b12:	0a ac       	st.w	r5++,r12
80003b14:	80 00       	ld.sh	r0,r0[0x0]
80003b16:	2a fc       	sub	r12,-81
80003b18:	00 00       	add	r0,r0
80003b1a:	0a a4       	st.w	r5++,r4
80003b1c:	80 00       	ld.sh	r0,r0[0x0]
80003b1e:	2a 14       	sub	r4,-95
80003b20:	00 00       	add	r0,r0
80003b22:	0a b8       	st.h	r5++,r8
80003b24:	80 00       	ld.sh	r0,r0[0x0]
80003b26:	2a 48       	sub	r8,-92
80003b28:	00 00       	add	r0,r0
80003b2a:	0a 95       	mov	r5,r5
80003b2c:	00 00       	add	r0,r0
80003b2e:	0a b0       	st.h	r5++,r0
80003b30:	00 00       	add	r0,r0
80003b32:	0a c0       	st.b	r5++,r0
80003b34:	00 00       	add	r0,r0
80003b36:	0a 98       	mov	r8,r5
80003b38:	00 00       	add	r0,r0
80003b3a:	0a e0       	st.h	--r5,r0
80003b3c:	00 00       	add	r0,r0
80003b3e:	0a c8       	st.b	r5++,r8
80003b40:	00 00       	add	r0,r0
80003b42:	0a 80       	andn	r0,r5
80003b44:	00 00       	add	r0,r0
80003b46:	0a 68       	and	r8,r5
80003b48:	80 00       	ld.sh	r0,r0[0x0]
80003b4a:	dd 7c       	*unknown*
80003b4c:	80 00       	ld.sh	r0,r0[0x0]
80003b4e:	78 0c       	ld.w	r12,r12[0x0]
80003b50:	00 00       	add	r0,r0
80003b52:	0a 94       	mov	r4,r5
80003b54:	00 00       	add	r0,r0
80003b56:	0a ec       	st.h	--r5,r12
80003b58:	00 00       	add	r0,r0
80003b5a:	0a cc       	st.b	r5++,r12
80003b5c:	80 00       	ld.sh	r0,r0[0x0]
80003b5e:	80 6a       	ld.sh	r10,r0[0xc]
80003b60:	80 00       	ld.sh	r0,r0[0x0]
80003b62:	2a 30       	sub	r0,-93
80003b64:	00 00       	add	r0,r0
80003b66:	0a 5c       	eor	r12,r5
80003b68:	00 00       	add	r0,r0
80003b6a:	21 94       	sub	r4,25
80003b6c:	80 00       	ld.sh	r0,r0[0x0]
80003b6e:	29 e4       	sub	r4,-98
80003b70:	00 00       	add	r0,r0
80003b72:	0a 88       	andn	r8,r5
80003b74:	00 00       	add	r0,r0
80003b76:	20 98       	sub	r8,9
80003b78:	00 00       	add	r0,r0
80003b7a:	0a 8c       	andn	r12,r5
80003b7c:	00 00       	add	r0,r0
80003b7e:	0a 64       	and	r4,r5
80003b80:	00 00       	add	r0,r0
80003b82:	0a 67       	and	r7,r5
80003b84:	00 00       	add	r0,r0
80003b86:	0a e4       	st.h	--r5,r4
80003b88:	00 00       	add	r0,r0
80003b8a:	0a a0       	st.w	r5++,r0
80003b8c:	00 00       	add	r0,r0
80003b8e:	0a 6c       	and	r12,r5
80003b90:	00 00       	add	r0,r0
80003b92:	20 90       	sub	r0,9
80003b94:	00 00       	add	r0,r0
80003b96:	0a d8       	st.w	--r5,r8
80003b98:	00 00       	add	r0,r0
80003b9a:	21 98       	sub	r8,25
80003b9c:	80 00       	ld.sh	r0,r0[0x0]
80003b9e:	dd 94       	*unknown*

80003ba0 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003ba0:	fe 78 10 00 	mov	r8,-61440
80003ba4:	e0 69 0d c0 	mov	r9,3520
80003ba8:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003bac:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003bb0:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003bb4:	fe 78 34 00 	mov	r8,-52224
80003bb8:	e0 69 80 00 	mov	r9,32768
80003bbc:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003bbe:	30 09       	mov	r9,0
80003bc0:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003bc2:	e0 69 04 21 	mov	r9,1057
80003bc6:	ea 19 3f 20 	orh	r9,0x3f20
80003bca:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80003bcc:	e0 69 02 9f 	mov	r9,671
80003bd0:	ea 19 01 00 	orh	r9,0x100
80003bd4:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80003bd6:	e0 6a 04 02 	mov	r10,1026
80003bda:	ea 1a 3f 20 	orh	r10,0x3f20
80003bde:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80003be0:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003be2:	5e fc       	retal	r12

80003be4 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003be4:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003be6:	30 19       	mov	r9,1
80003be8:	49 78       	lddpc	r8,80003c44 <local_start_PDC+0x60>
80003bea:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003bec:	fe 78 00 00 	mov	r8,-65536
80003bf0:	30 7b       	mov	r11,7
80003bf2:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003bf4:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003bf6:	49 59       	lddpc	r9,80003c48 <local_start_PDC+0x64>
80003bf8:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003bfc:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003bfe:	30 3a       	mov	r10,3
80003c00:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003c02:	30 1c       	mov	r12,1
80003c04:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003c06:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003c08:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003c0a:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003c0c:	30 2c       	mov	r12,2
80003c0e:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003c10:	48 f9       	lddpc	r9,80003c4c <local_start_PDC+0x68>
80003c12:	e0 68 5a 5a 	mov	r8,23130
80003c16:	ea 18 ab cd 	orh	r8,0xabcd
80003c1a:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003c1c:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003c1e:	30 0e       	mov	lr,0
80003c20:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003c22:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003c24:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003c26:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003c28:	fe 78 00 40 	mov	r8,-65472
80003c2c:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003c2e:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003c30:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003c34:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003c36:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003c38:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003c3a:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003c3c:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003c3e:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003c40:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003c42:	d8 02       	popm	pc
80003c44:	00 00       	add	r0,r0
80003c46:	53 b8       	stdsp	sp[0xec],r8
80003c48:	00 00       	add	r0,r0
80003c4a:	53 c0       	stdsp	sp[0xf0],r0
80003c4c:	00 00       	add	r0,r0
80003c4e:	53 e0       	stdsp	sp[0xf8],r0

80003c50 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003c50:	48 38       	lddpc	r8,80003c5c <register_rx_tx_func+0xc>
80003c52:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003c54:	48 38       	lddpc	r8,80003c60 <register_rx_tx_func+0x10>
80003c56:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003c58:	5e fc       	retal	r12
80003c5a:	00 00       	add	r0,r0
80003c5c:	00 00       	add	r0,r0
80003c5e:	0a f0       	st.b	--r5,r0
80003c60:	00 00       	add	r0,r0
80003c62:	0a f8       	st.b	--r5,r8

80003c64 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003c64:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003c66:	fe 78 10 00 	mov	r8,-61440
80003c6a:	30 29       	mov	r9,2
80003c6c:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003c70:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80003c74:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
80003c76:	30 3a       	mov	r10,3
80003c78:	36 0b       	mov	r11,96
80003c7a:	49 4c       	lddpc	r12,80003cc8 <ssc_init+0x64>
80003c7c:	f0 1f 00 14 	mcall	80003ccc <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
80003c80:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003c82:	fe 79 10 00 	mov	r9,-61440
80003c86:	f2 f8 01 60 	ld.w	r8,r9[352]
80003c8a:	e2 18 00 02 	andl	r8,0x2,COH
80003c8e:	cf c0       	breq	80003c86 <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003c90:	fe 79 10 00 	mov	r9,-61440
80003c94:	f2 f8 01 60 	ld.w	r8,r9[352]
80003c98:	e2 18 00 02 	andl	r8,0x2,COH
80003c9c:	cf c1       	brne	80003c94 <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
80003c9e:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80003ca0:	f0 1f 00 0c 	mcall	80003cd0 <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
80003ca4:	f0 1f 00 0c 	mcall	80003cd4 <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003ca8:	fe 79 00 00 	mov	r9,-65536
80003cac:	30 18       	mov	r8,1
80003cae:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003cb0:	fe 7a 00 40 	mov	r10,-65472
80003cb4:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003cb6:	e0 6b 01 01 	mov	r11,257
80003cba:	fe 7a 34 00 	mov	r10,-52224
80003cbe:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80003cc0:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80003cc2:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80003cc4:	d8 02       	popm	pc
80003cc6:	00 00       	add	r0,r0
80003cc8:	80 00       	ld.sh	r0,r0[0x0]
80003cca:	3c d8       	mov	r8,-51
80003ccc:	80 00       	ld.sh	r0,r0[0x0]
80003cce:	5a e8       	cp.w	r8,-18
80003cd0:	80 00       	ld.sh	r0,r0[0x0]
80003cd2:	3b a0       	mov	r0,-70
80003cd4:	80 00       	ld.sh	r0,r0[0x0]
80003cd6:	3b e4       	mov	r4,-66

80003cd8 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003cd8:	d4 01       	pushm	lr
    
	static portBASE_TYPE xHigherPriorityTaskWoken;
	xHigherPriorityTaskWoken = pdFALSE;
80003cda:	30 09       	mov	r9,0
80003cdc:	49 c8       	lddpc	r8,80003d4c <pdca_int_handler+0x74>
80003cde:	91 09       	st.w	r8[0x0],r9
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003ce0:	49 c8       	lddpc	r8,80003d50 <pdca_int_handler+0x78>
80003ce2:	11 89       	ld.ub	r9,r8[0x0]
80003ce4:	ec 19 00 01 	eorl	r9,0x1
80003ce8:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003cea:	11 89       	ld.ub	r9,r8[0x0]
80003cec:	a5 69       	lsl	r9,0x4
80003cee:	2f c9       	sub	r9,-4
80003cf0:	49 9a       	lddpc	r10,80003d54 <pdca_int_handler+0x7c>
80003cf2:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003cf4:	fe 7a 00 40 	mov	r10,-65472
80003cf8:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003cfa:	30 39       	mov	r9,3
80003cfc:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003cfe:	11 8a       	ld.ub	r10,r8[0x0]
80003d00:	a5 6a       	lsl	r10,0x4
80003d02:	2f ca       	sub	r10,-4
80003d04:	49 58       	lddpc	r8,80003d58 <pdca_int_handler+0x80>
80003d06:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003d08:	fe 78 00 00 	mov	r8,-65536
80003d0c:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003d0e:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003d10:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003d12:	49 38       	lddpc	r8,80003d5c <pdca_int_handler+0x84>
80003d14:	70 08       	ld.w	r8,r8[0x0]
80003d16:	58 08       	cp.w	r8,0
80003d18:	c0 70       	breq	80003d26 <pdca_int_handler+0x4e>
80003d1a:	48 e9       	lddpc	r9,80003d50 <pdca_int_handler+0x78>
80003d1c:	13 89       	ld.ub	r9,r9[0x0]
80003d1e:	a5 69       	lsl	r9,0x4
80003d20:	48 ec       	lddpc	r12,80003d58 <pdca_int_handler+0x80>
80003d22:	12 0c       	add	r12,r9
80003d24:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003d26:	48 f8       	lddpc	r8,80003d60 <pdca_int_handler+0x88>
80003d28:	70 08       	ld.w	r8,r8[0x0]
80003d2a:	58 08       	cp.w	r8,0
80003d2c:	c0 70       	breq	80003d3a <pdca_int_handler+0x62>
80003d2e:	48 99       	lddpc	r9,80003d50 <pdca_int_handler+0x78>
80003d30:	13 89       	ld.ub	r9,r9[0x0]
80003d32:	a5 69       	lsl	r9,0x4
80003d34:	48 8c       	lddpc	r12,80003d54 <pdca_int_handler+0x7c>
80003d36:	12 0c       	add	r12,r9
80003d38:	5d 18       	icall	r8

	
	/* 'Give' the semaphore to unblock the task. */
	xSemaphoreGiveFromISR(xBinarySemaphore, &xHigherPriorityTaskWoken );
80003d3a:	48 b8       	lddpc	r8,80003d64 <pdca_int_handler+0x8c>
80003d3c:	70 0c       	ld.w	r12,r8[0x0]
80003d3e:	30 09       	mov	r9,0
80003d40:	48 3a       	lddpc	r10,80003d4c <pdca_int_handler+0x74>
80003d42:	12 9b       	mov	r11,r9
80003d44:	f0 1f 00 09 	mcall	80003d68 <pdca_int_handler+0x90>

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003d48:	d4 02       	popm	lr
80003d4a:	d6 03       	rete
80003d4c:	00 00       	add	r0,r0
80003d4e:	0a f4       	st.b	--r5,r4
80003d50:	00 00       	add	r0,r0
80003d52:	53 b8       	stdsp	sp[0xec],r8
80003d54:	00 00       	add	r0,r0
80003d56:	53 e0       	stdsp	sp[0xf8],r0
80003d58:	00 00       	add	r0,r0
80003d5a:	53 c0       	stdsp	sp[0xf0],r0
80003d5c:	00 00       	add	r0,r0
80003d5e:	0a f0       	st.b	--r5,r0
80003d60:	00 00       	add	r0,r0
80003d62:	0a f8       	st.b	--r5,r8
80003d64:	00 00       	add	r0,r0
80003d66:	54 1c       	stdsp	sp[0x104],r12
80003d68:	80 00       	ld.sh	r0,r0[0x0]
80003d6a:	68 88       	ld.w	r8,r4[0x20]

80003d6c <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003d6c:	48 28       	lddpc	r8,80003d74 <xcmp_register_app_list+0x8>
80003d6e:	91 0c       	st.w	r8[0x0],r12
}
80003d70:	5e fc       	retal	r12
80003d72:	00 00       	add	r0,r0
80003d74:	00 00       	add	r0,r0
80003d76:	54 00       	stdsp	sp[0x100],r0

80003d78 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003d78:	eb cd 40 80 	pushm	r7,lr
80003d7c:	fa cd 01 00 	sub	sp,sp,256
80003d80:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003d82:	16 98       	mov	r8,r11
80003d84:	2f 08       	sub	r8,-16
80003d86:	af a8       	sbr	r8,0xe
80003d88:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003d8a:	3f f8       	mov	r8,-1
80003d8c:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003d8e:	30 b9       	mov	r9,11
80003d90:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003d92:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003d94:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003d96:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003d98:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003d9a:	f6 ca ff fe 	sub	r10,r11,-2
80003d9e:	18 9b       	mov	r11,r12
80003da0:	fa cc ff f0 	sub	r12,sp,-16
80003da4:	f0 1f 00 05 	mcall	80003db8 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003da8:	2f e7       	sub	r7,-2
80003daa:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003dac:	1a 9c       	mov	r12,sp
80003dae:	f0 1f 00 04 	mcall	80003dbc <xcmp_tx+0x44>
}
80003db2:	2c 0d       	sub	sp,-256
80003db4:	e3 cd 80 80 	ldm	sp++,r7,pc
80003db8:	80 00       	ld.sh	r0,r0[0x0]
80003dba:	7f 22       	ld.w	r2,pc[0x48]
80003dbc:	80 00       	ld.sh	r0,r0[0x0]
80003dbe:	43 84       	lddsp	r4,sp[0xe0]

80003dc0 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80003dc0:	d4 21       	pushm	r4-r7,lr
80003dc2:	fa cd 00 d0 	sub	sp,sp,208
80003dc6:	18 94       	mov	r4,r12
80003dc8:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003dca:	e0 68 01 00 	mov	r8,256
80003dce:	f0 0b 19 00 	cp.h	r11,r8
80003dd2:	e0 8b 00 36 	brhi	80003e3e <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003dd6:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003dda:	e0 68 04 1d 	mov	r8,1053
80003dde:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003de0:	30 18       	mov	r8,1
80003de2:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80003de4:	32 08       	mov	r8,32
80003de6:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003de8:	30 28       	mov	r8,2
80003dea:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003dec:	30 48       	mov	r8,4
80003dee:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80003df0:	ea 1a 0c 00 	orh	r10,0xc00
80003df4:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80003df6:	30 4a       	mov	r10,4
80003df8:	1a 9b       	mov	r11,sp
80003dfa:	fa cc ff f4 	sub	r12,sp,-12
80003dfe:	f0 1f 00 12 	mcall	80003e44 <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80003e02:	30 f8       	mov	r8,15
80003e04:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80003e08:	3a 78       	mov	r8,-89
80003e0a:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80003e0e:	30 08       	mov	r8,0
80003e10:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80003e14:	0e 9a       	mov	r10,r7
80003e16:	5c 7a       	castu.h	r10
80003e18:	f4 08 16 08 	lsr	r8,r10,0x8
80003e1c:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80003e20:	0e 96       	mov	r6,r7
80003e22:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80003e26:	08 9b       	mov	r11,r4
80003e28:	fa cc ff eb 	sub	r12,sp,-21
80003e2c:	f0 1f 00 06 	mcall	80003e44 <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80003e30:	ee cb ff f3 	sub	r11,r7,-13
80003e34:	5c 5b       	castu.b	r11
80003e36:	fa cc ff fa 	sub	r12,sp,-6
80003e3a:	f0 1f 00 04 	mcall	80003e48 <xcmp_data_session_req+0x88>
}
80003e3e:	2c cd       	sub	sp,-208
80003e40:	d8 22       	popm	r4-r7,pc
80003e42:	00 00       	add	r0,r0
80003e44:	80 00       	ld.sh	r0,r0[0x0]
80003e46:	7f 22       	ld.w	r2,pc[0x48]
80003e48:	80 00       	ld.sh	r0,r0[0x0]
80003e4a:	3d 78       	mov	r8,-41

80003e4c <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003e4c:	d4 01       	pushm	lr
80003e4e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003e52:	fe 78 b4 00 	mov	r8,-19456
80003e56:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003e58:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003e5c:	30 89       	mov	r9,8
80003e5e:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003e60:	30 19       	mov	r9,1
80003e62:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003e64:	30 09       	mov	r9,0
80003e66:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003e68:	30 5a       	mov	r10,5
80003e6a:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003e6c:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003e6e:	30 7a       	mov	r10,7
80003e70:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003e72:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003e74:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003e76:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003e7a:	30 9b       	mov	r11,9
80003e7c:	fa cc ff fe 	sub	r12,sp,-2
80003e80:	f0 1f 00 02 	mcall	80003e88 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003e84:	2c dd       	sub	sp,-204
80003e86:	d8 02       	popm	pc
80003e88:	80 00       	ld.sh	r0,r0[0x0]
80003e8a:	3d 78       	mov	r8,-41

80003e8c <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003e8c:	d4 01       	pushm	lr
80003e8e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003e92:	fe 78 80 00 	mov	r8,-32768
80003e96:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003e98:	30 38       	mov	r8,3
80003e9a:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80003e9c:	30 1b       	mov	r11,1
80003e9e:	fa cc ff fe 	sub	r12,sp,-2
80003ea2:	f0 1f 00 03 	mcall	80003eac <xcmp_opcode_not_supported+0x20>
}
80003ea6:	2c dd       	sub	sp,-204
80003ea8:	d8 02       	popm	pc
80003eaa:	00 00       	add	r0,r0
80003eac:	80 00       	ld.sh	r0,r0[0x0]
80003eae:	3d 78       	mov	r8,-41

80003eb0 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80003eb0:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80003eb2:	96 88       	ld.uh	r8,r11[0x0]
80003eb4:	e2 18 f0 00 	andl	r8,0xf000,COH
80003eb8:	e0 48 80 00 	cp.w	r8,32768
80003ebc:	c0 f0       	breq	80003eda <xcmp_exec_func+0x2a>
80003ebe:	e0 48 b0 00 	cp.w	r8,45056
80003ec2:	c1 20       	breq	80003ee6 <xcmp_exec_func+0x36>
80003ec4:	58 08       	cp.w	r8,0
80003ec6:	c1 51       	brne	80003ef0 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80003ec8:	78 08       	ld.w	r8,r12[0x0]
80003eca:	58 08       	cp.w	r8,0
80003ecc:	c0 40       	breq	80003ed4 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80003ece:	16 9c       	mov	r12,r11
80003ed0:	5d 18       	icall	r8
80003ed2:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80003ed4:	f0 1f 00 08 	mcall	80003ef4 <xcmp_exec_func+0x44>
80003ed8:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80003eda:	78 18       	ld.w	r8,r12[0x4]
80003edc:	58 08       	cp.w	r8,0
80003ede:	c0 90       	breq	80003ef0 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80003ee0:	16 9c       	mov	r12,r11
80003ee2:	5d 18       	icall	r8
80003ee4:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80003ee6:	78 28       	ld.w	r8,r12[0x8]
80003ee8:	58 08       	cp.w	r8,0
80003eea:	c0 30       	breq	80003ef0 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80003eec:	16 9c       	mov	r12,r11
80003eee:	5d 18       	icall	r8
80003ef0:	d8 02       	popm	pc
80003ef2:	00 00       	add	r0,r0
80003ef4:	80 00       	ld.sh	r0,r0[0x0]
80003ef6:	3e 8c       	mov	r12,-24

80003ef8 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80003ef8:	d4 01       	pushm	lr
80003efa:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80003efe:	e0 68 04 09 	mov	r8,1033
80003f02:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80003f04:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80003f08:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
80003f0a:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
80003f0e:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80003f10:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80003f12:	30 09       	mov	r9,0
80003f14:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80003f16:	fb 69 00 08 	st.b	sp[8],r9
80003f1a:	fa c8 ff f7 	sub	r8,sp,-9
80003f1e:	b0 89       	st.b	r8[0x0],r9
80003f20:	fa c8 ff f6 	sub	r8,sp,-10
80003f24:	b0 89       	st.b	r8[0x0],r9
80003f26:	fa c8 ff f5 	sub	r8,sp,-11
80003f2a:	b0 89       	st.b	r8[0x0],r9
80003f2c:	fa c8 ff f4 	sub	r8,sp,-12
80003f30:	b0 89       	st.b	r8[0x0],r9
80003f32:	fa c8 ff f3 	sub	r8,sp,-13
80003f36:	b0 89       	st.b	r8[0x0],r9
80003f38:	fa c8 ff f2 	sub	r8,sp,-14
80003f3c:	b0 89       	st.b	r8[0x0],r9
80003f3e:	fa c8 ff f1 	sub	r8,sp,-15
80003f42:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80003f44:	30 cb       	mov	r11,12
80003f46:	fa cc ff fe 	sub	r12,sp,-2
80003f4a:	f0 1f 00 03 	mcall	80003f54 <xcmp_IdleTestTone+0x5c>
}
80003f4e:	2c dd       	sub	sp,-204
80003f50:	d8 02       	popm	pc
80003f52:	00 00       	add	r0,r0
80003f54:	80 00       	ld.sh	r0,r0[0x0]
80003f56:	3d 78       	mov	r8,-41

80003f58 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80003f58:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80003f5a:	48 dc       	lddpc	r12,80003f8c <xcmp_init+0x34>
80003f5c:	f0 1f 00 0d 	mcall	80003f90 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80003f60:	30 4b       	mov	r11,4
80003f62:	31 4c       	mov	r12,20
80003f64:	f0 1f 00 0c 	mcall	80003f94 <xcmp_init+0x3c>
80003f68:	48 c8       	lddpc	r8,80003f98 <xcmp_init+0x40>
80003f6a:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80003f6c:	30 09       	mov	r9,0
80003f6e:	1a d9       	st.w	--sp,r9
80003f70:	1a d9       	st.w	--sp,r9
80003f72:	1a d9       	st.w	--sp,r9
80003f74:	30 38       	mov	r8,3
80003f76:	e0 6a 04 00 	mov	r10,1024
80003f7a:	48 9b       	lddpc	r11,80003f9c <xcmp_init+0x44>
80003f7c:	48 9c       	lddpc	r12,80003fa0 <xcmp_init+0x48>
80003f7e:	f0 1f 00 0a 	mcall	80003fa4 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80003f82:	f0 1f 00 0a 	mcall	80003fa8 <xcmp_init+0x50>
80003f86:	2f dd       	sub	sp,-12
	
}
80003f88:	d8 02       	popm	pc
80003f8a:	00 00       	add	r0,r0
80003f8c:	80 00       	ld.sh	r0,r0[0x0]
80003f8e:	40 a8       	lddsp	r8,sp[0x28]
80003f90:	80 00       	ld.sh	r0,r0[0x0]
80003f92:	40 f4       	lddsp	r4,sp[0x3c]
80003f94:	80 00       	ld.sh	r0,r0[0x0]
80003f96:	6a 30       	ld.w	r0,r5[0xc]
80003f98:	00 00       	add	r0,r0
80003f9a:	0b 14       	ld.sh	r4,r5++
80003f9c:	80 00       	ld.sh	r0,r0[0x0]
80003f9e:	dd c0       	acall	0xdc
80003fa0:	80 00       	ld.sh	r0,r0[0x0]
80003fa2:	3f ac       	mov	r12,-6
80003fa4:	80 00       	ld.sh	r0,r0[0x0]
80003fa6:	72 bc       	ld.w	r12,r9[0x2c]
80003fa8:	80 00       	ld.sh	r0,r0[0x0]
80003faa:	41 2c       	lddsp	r12,sp[0x48]

80003fac <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80003fac:	d4 31       	pushm	r0-r7,lr
80003fae:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80003fb0:	4b 16       	lddpc	r6,80004074 <xcmp_rx_process+0xc8>
80003fb2:	30 05       	mov	r5,0
80003fb4:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80003fb6:	4b 13       	lddpc	r3,80004078 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80003fb8:	4b 12       	lddpc	r2,8000407c <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80003fba:	4b 21       	lddpc	r1,80004080 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80003fbc:	4b 20       	lddpc	r0,80004084 <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80003fbe:	6c 0c       	ld.w	r12,r6[0x0]
80003fc0:	0a 99       	mov	r9,r5
80003fc2:	08 9a       	mov	r10,r4
80003fc4:	1a 9b       	mov	r11,sp
80003fc6:	f0 1f 00 31 	mcall	80004088 <xcmp_rx_process+0xdc>
80003fca:	58 1c       	cp.w	r12,1
80003fcc:	cf 91       	brne	80003fbe <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80003fce:	40 0b       	lddsp	r11,sp[0x0]
80003fd0:	58 0b       	cp.w	r11,0
80003fd2:	cf 60       	breq	80003fbe <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
80003fd4:	96 0a       	ld.sh	r10,r11[0x0]
80003fd6:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80003fda:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80003fde:	59 c8       	cp.w	r8,28
80003fe0:	c1 e0       	breq	8000401c <xcmp_rx_process+0x70>
80003fe2:	e0 89 00 07 	brgt	80003ff0 <xcmp_rx_process+0x44>
80003fe6:	58 e8       	cp.w	r8,14
80003fe8:	c0 e0       	breq	80004004 <xcmp_rx_process+0x58>
80003fea:	58 f8       	cp.w	r8,15
80003fec:	c2 41       	brne	80004034 <xcmp_rx_process+0x88>
80003fee:	c0 f8       	rjmp	8000400c <xcmp_rx_process+0x60>
80003ff0:	e0 48 01 09 	cp.w	r8,265
80003ff4:	c1 80       	breq	80004024 <xcmp_rx_process+0x78>
80003ff6:	e0 48 01 0a 	cp.w	r8,266
80003ffa:	c1 90       	breq	8000402c <xcmp_rx_process+0x80>
80003ffc:	e0 48 00 2c 	cp.w	r8,44
80004000:	c1 a1       	brne	80004034 <xcmp_rx_process+0x88>
80004002:	c0 98       	rjmp	80004014 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004004:	4a 2c       	lddpc	r12,8000408c <xcmp_rx_process+0xe0>
80004006:	f0 1f 00 23 	mcall	80004090 <xcmp_rx_process+0xe4>
					break;
8000400a:	c2 f8       	rjmp	80004068 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
8000400c:	4a 2c       	lddpc	r12,80004094 <xcmp_rx_process+0xe8>
8000400e:	f0 1f 00 21 	mcall	80004090 <xcmp_rx_process+0xe4>
					break;
80004012:	c2 b8       	rjmp	80004068 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004014:	4a 1c       	lddpc	r12,80004098 <xcmp_rx_process+0xec>
80004016:	f0 1f 00 1f 	mcall	80004090 <xcmp_rx_process+0xe4>
					break;
8000401a:	c2 78       	rjmp	80004068 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
8000401c:	04 9c       	mov	r12,r2
8000401e:	f0 1f 00 1d 	mcall	80004090 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80004022:	c2 38       	rjmp	80004068 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004024:	02 9c       	mov	r12,r1
80004026:	f0 1f 00 1b 	mcall	80004090 <xcmp_rx_process+0xe4>
					break;
8000402a:	c1 f8       	rjmp	80004068 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
8000402c:	00 9c       	mov	r12,r0
8000402e:	f0 1f 00 19 	mcall	80004090 <xcmp_rx_process+0xe4>
					break;
80004032:	c1 b8       	rjmp	80004068 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004034:	12 98       	mov	r8,r9
80004036:	e2 18 04 00 	andl	r8,0x400,COH
8000403a:	c0 70       	breq	80004048 <xcmp_rx_process+0x9c>
8000403c:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004040:	e0 48 00 68 	cp.w	r8,104
80004044:	e0 8a 00 08 	brle	80004054 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004048:	e2 19 f0 00 	andl	r9,0xf000,COH
8000404c:	c0 e1       	brne	80004068 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
8000404e:	f0 1f 00 14 	mcall	8000409c <xcmp_rx_process+0xf0>
80004052:	c0 b8       	rjmp	80004068 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004054:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80004058:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
8000405c:	49 19       	lddpc	r9,800040a0 <xcmp_rx_process+0xf4>
8000405e:	72 08       	ld.w	r8,r9[0x0]
80004060:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004064:	f0 1f 00 0b 	mcall	80004090 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004068:	66 0c       	ld.w	r12,r3[0x0]
8000406a:	40 0b       	lddsp	r11,sp[0x0]
8000406c:	f0 1f 00 0e 	mcall	800040a4 <xcmp_rx_process+0xf8>
80004070:	ca 7b       	rjmp	80003fbe <xcmp_rx_process+0x12>
80004072:	00 00       	add	r0,r0
80004074:	00 00       	add	r0,r0
80004076:	0b 14       	ld.sh	r4,r5++
80004078:	00 00       	add	r0,r0
8000407a:	0a ac       	st.w	r5++,r12
8000407c:	00 00       	add	r0,r0
8000407e:	0b 24       	ld.uh	r4,r5++
80004080:	00 00       	add	r0,r0
80004082:	0b 18       	ld.sh	r8,r5++
80004084:	00 00       	add	r0,r0
80004086:	0b 08       	ld.w	r8,r5++
80004088:	80 00       	ld.sh	r0,r0[0x0]
8000408a:	66 cc       	ld.w	r12,r3[0x30]
8000408c:	00 00       	add	r0,r0
8000408e:	0b 3c       	ld.ub	r12,r5++
80004090:	80 00       	ld.sh	r0,r0[0x0]
80004092:	3e b0       	mov	r0,-21
80004094:	00 00       	add	r0,r0
80004096:	0a fc       	st.b	--r5,r12
80004098:	00 00       	add	r0,r0
8000409a:	0b 30       	ld.ub	r0,r5++
8000409c:	80 00       	ld.sh	r0,r0[0x0]
8000409e:	3e 8c       	mov	r12,-24
800040a0:	00 00       	add	r0,r0
800040a2:	54 00       	stdsp	sp[0x100],r0
800040a4:	80 00       	ld.sh	r0,r0[0x0]
800040a6:	2a 80       	sub	r0,-88

800040a8 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800040a8:	eb cd 40 90 	pushm	r4,r7,lr
800040ac:	20 1d       	sub	sp,4
800040ae:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800040b2:	48 c8       	lddpc	r8,800040e0 <xcmp_rx+0x38>
800040b4:	70 0c       	ld.w	r12,r8[0x0]
800040b6:	f0 1f 00 0c 	mcall	800040e4 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
800040ba:	c1 00       	breq	800040da <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800040bc:	fa c7 ff fc 	sub	r7,sp,-4
800040c0:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
800040c2:	e0 6a 00 ca 	mov	r10,202
800040c6:	08 9b       	mov	r11,r4
800040c8:	f0 1f 00 08 	mcall	800040e8 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
800040cc:	48 88       	lddpc	r8,800040ec <xcmp_rx+0x44>
800040ce:	70 0c       	ld.w	r12,r8[0x0]
800040d0:	30 09       	mov	r9,0
800040d2:	12 9a       	mov	r10,r9
800040d4:	1a 9b       	mov	r11,sp
800040d6:	f0 1f 00 07 	mcall	800040f0 <xcmp_rx+0x48>
	}	
}
800040da:	2f fd       	sub	sp,-4
800040dc:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
800040e0:	00 00       	add	r0,r0
800040e2:	0a ac       	st.w	r5++,r12
800040e4:	80 00       	ld.sh	r0,r0[0x0]
800040e6:	2c 2c       	sub	r12,-62
800040e8:	80 00       	ld.sh	r0,r0[0x0]
800040ea:	7f 22       	ld.w	r2,pc[0x48]
800040ec:	00 00       	add	r0,r0
800040ee:	0b 14       	ld.sh	r4,r5++
800040f0:	80 00       	ld.sh	r0,r0[0x0]
800040f2:	68 d8       	ld.w	r8,r4[0x34]

800040f4 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
800040f4:	48 28       	lddpc	r8,800040fc <xnl_register_xcmp_func+0x8>
800040f6:	91 0c       	st.w	r8[0x0],r12
}
800040f8:	5e fc       	retal	r12
800040fa:	00 00       	add	r0,r0
800040fc:	00 00       	add	r0,r0
800040fe:	0b 68       	ld.uh	r8,--r5

80004100 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004100:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004102:	48 88       	lddpc	r8,80004120 <xnl_get_msg_ack_func+0x20>
80004104:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004106:	98 49       	ld.sh	r9,r12[0x8]
80004108:	f0 09 19 00 	cp.h	r9,r8
8000410c:	c0 81       	brne	8000411c <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
8000410e:	48 68       	lddpc	r8,80004124 <xnl_get_msg_ack_func+0x24>
80004110:	70 0c       	ld.w	r12,r8[0x0]
80004112:	30 09       	mov	r9,0
80004114:	12 9a       	mov	r10,r9
80004116:	12 9b       	mov	r11,r9
80004118:	f0 1f 00 04 	mcall	80004128 <xnl_get_msg_ack_func+0x28>
8000411c:	d8 02       	popm	pc
8000411e:	00 00       	add	r0,r0
80004120:	00 00       	add	r0,r0
80004122:	0b 4e       	ld.w	lr,--r5
80004124:	00 00       	add	r0,r0
80004126:	0b 48       	ld.w	r8,--r5
80004128:	80 00       	ld.sh	r0,r0[0x0]
8000412a:	68 d8       	ld.w	r8,r4[0x34]

8000412c <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
8000412c:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
80004130:	30 09       	mov	r9,0
80004132:	4b 78       	lddpc	r8,8000420c <xnl_init+0xe0>
80004134:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004136:	30 0b       	mov	r11,0
80004138:	30 1c       	mov	r12,1
8000413a:	f0 1f 00 36 	mcall	80004210 <xnl_init+0xe4>
8000413e:	4b 68       	lddpc	r8,80004214 <xnl_init+0xe8>
80004140:	91 0c       	st.w	r8[0x0],r12
80004142:	70 08       	ld.w	r8,r8[0x0]
80004144:	58 08       	cp.w	r8,0
80004146:	c0 80       	breq	80004156 <xnl_init+0x2a>
80004148:	4b 38       	lddpc	r8,80004214 <xnl_init+0xe8>
8000414a:	70 0c       	ld.w	r12,r8[0x0]
8000414c:	30 09       	mov	r9,0
8000414e:	12 9a       	mov	r10,r9
80004150:	12 9b       	mov	r11,r9
80004152:	f0 1f 00 32 	mcall	80004218 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80004156:	30 4b       	mov	r11,4
80004158:	31 4c       	mov	r12,20
8000415a:	f0 1f 00 2e 	mcall	80004210 <xnl_init+0xe4>
8000415e:	4b 08       	lddpc	r8,8000421c <xnl_init+0xf0>
80004160:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80004162:	30 4b       	mov	r11,4
80004164:	31 ec       	mov	r12,30
80004166:	f0 1f 00 2b 	mcall	80004210 <xnl_init+0xe4>
8000416a:	4a e8       	lddpc	r8,80004220 <xnl_init+0xf4>
8000416c:	91 0c       	st.w	r8[0x0],r12
8000416e:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004170:	10 96       	mov	r6,r8
80004172:	4a d5       	lddpc	r5,80004224 <xnl_init+0xf8>
80004174:	6c 0c       	ld.w	r12,r6[0x0]
80004176:	ea 07 00 0b 	add	r11,r5,r7
8000417a:	f0 1f 00 2c 	mcall	80004228 <xnl_init+0xfc>
8000417e:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004182:	e0 47 1e 00 	cp.w	r7,7680
80004186:	cf 71       	brne	80004174 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004188:	30 4b       	mov	r11,4
8000418a:	31 4c       	mov	r12,20
8000418c:	f0 1f 00 21 	mcall	80004210 <xnl_init+0xe4>
80004190:	4a 78       	lddpc	r8,8000422c <xnl_init+0x100>
80004192:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004194:	30 4b       	mov	r11,4
80004196:	30 ac       	mov	r12,10
80004198:	f0 1f 00 1e 	mcall	80004210 <xnl_init+0xe4>
8000419c:	4a 58       	lddpc	r8,80004230 <xnl_init+0x104>
8000419e:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
800041a0:	30 4b       	mov	r11,4
800041a2:	30 ac       	mov	r12,10
800041a4:	f0 1f 00 1b 	mcall	80004210 <xnl_init+0xe4>
800041a8:	4a 38       	lddpc	r8,80004234 <xnl_init+0x108>
800041aa:	91 0c       	st.w	r8[0x0],r12
800041ac:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
800041ae:	10 96       	mov	r6,r8
800041b0:	4a 25       	lddpc	r5,80004238 <xnl_init+0x10c>
800041b2:	6c 0c       	ld.w	r12,r6[0x0]
800041b4:	ea 07 00 0b 	add	r11,r5,r7
800041b8:	f0 1f 00 1c 	mcall	80004228 <xnl_init+0xfc>
800041bc:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
800041c0:	e0 47 14 00 	cp.w	r7,5120
800041c4:	cf 71       	brne	800041b2 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
800041c6:	30 4b       	mov	r11,4
800041c8:	30 5c       	mov	r12,5
800041ca:	f0 1f 00 12 	mcall	80004210 <xnl_init+0xe4>
800041ce:	49 c8       	lddpc	r8,8000423c <xnl_init+0x110>
800041d0:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800041d2:	30 07       	mov	r7,0
800041d4:	1a d7       	st.w	--sp,r7
800041d6:	1a d7       	st.w	--sp,r7
800041d8:	1a d7       	st.w	--sp,r7
800041da:	30 38       	mov	r8,3
800041dc:	0e 99       	mov	r9,r7
800041de:	e0 6a 00 dc 	mov	r10,220
800041e2:	49 8b       	lddpc	r11,80004240 <xnl_init+0x114>
800041e4:	49 8c       	lddpc	r12,80004244 <xnl_init+0x118>
800041e6:	f0 1f 00 19 	mcall	80004248 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
800041ea:	1a d7       	st.w	--sp,r7
800041ec:	1a d7       	st.w	--sp,r7
800041ee:	1a d7       	st.w	--sp,r7
800041f0:	30 38       	mov	r8,3
800041f2:	0e 99       	mov	r9,r7
800041f4:	e0 6a 00 82 	mov	r10,130
800041f8:	49 5b       	lddpc	r11,8000424c <xnl_init+0x120>
800041fa:	49 6c       	lddpc	r12,80004250 <xnl_init+0x124>
800041fc:	f0 1f 00 13 	mcall	80004248 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004200:	f0 1f 00 15 	mcall	80004254 <xnl_init+0x128>
80004204:	2f ad       	sub	sp,-24
}
80004206:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000420a:	00 00       	add	r0,r0
8000420c:	00 00       	add	r0,r0
8000420e:	0b 4e       	ld.w	lr,--r5
80004210:	80 00       	ld.sh	r0,r0[0x0]
80004212:	6a 30       	ld.w	r0,r5[0xc]
80004214:	00 00       	add	r0,r0
80004216:	0b 48       	ld.w	r8,--r5
80004218:	80 00       	ld.sh	r0,r0[0x0]
8000421a:	68 d8       	ld.w	r8,r4[0x34]
8000421c:	00 00       	add	r0,r0
8000421e:	0b 5c       	ld.sh	r12,--r5
80004220:	00 00       	add	r0,r0
80004222:	0a ac       	st.w	r5++,r12
80004224:	00 00       	add	r0,r0
80004226:	35 b2       	mov	r2,91
80004228:	80 00       	ld.sh	r0,r0[0x0]
8000422a:	2a 80       	sub	r0,-88
8000422c:	00 00       	add	r0,r0
8000422e:	0a dc       	st.w	--r5,r12
80004230:	00 00       	add	r0,r0
80004232:	0a bc       	st.h	r5++,r12
80004234:	00 00       	add	r0,r0
80004236:	0a b0       	st.h	r5++,r0
80004238:	00 00       	add	r0,r0
8000423a:	21 b2       	sub	r2,27
8000423c:	00 00       	add	r0,r0
8000423e:	0a e8       	st.h	--r5,r8
80004240:	80 00       	ld.sh	r0,r0[0x0]
80004242:	dd c8       	*unknown*
80004244:	80 00       	ld.sh	r0,r0[0x0]
80004246:	42 58       	lddsp	r8,sp[0x94]
80004248:	80 00       	ld.sh	r0,r0[0x0]
8000424a:	72 bc       	ld.w	r12,r9[0x2c]
8000424c:	80 00       	ld.sh	r0,r0[0x0]
8000424e:	dd d0       	acall	0xdd
80004250:	80 00       	ld.sh	r0,r0[0x0]
80004252:	42 b8       	lddsp	r8,sp[0xac]
80004254:	80 00       	ld.sh	r0,r0[0x0]
80004256:	2c 54       	sub	r4,-59

80004258 <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
80004258:	eb cd 40 fe 	pushm	r1-r7,lr
8000425c:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000425e:	49 26       	lddpc	r6,800042a4 <xnl_rx_process+0x4c>
80004260:	30 05       	mov	r5,0
80004262:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004264:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004266:	49 11       	lddpc	r1,800042a8 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004268:	49 12       	lddpc	r2,800042ac <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000426a:	6c 0c       	ld.w	r12,r6[0x0]
8000426c:	0a 99       	mov	r9,r5
8000426e:	08 9a       	mov	r10,r4
80004270:	1a 9b       	mov	r11,sp
80004272:	f0 1f 00 10 	mcall	800042b0 <xnl_rx_process+0x58>
80004276:	58 1c       	cp.w	r12,1
80004278:	cf 91       	brne	8000426a <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
8000427a:	40 0c       	lddsp	r12,sp[0x0]
8000427c:	58 0c       	cp.w	r12,0
8000427e:	cf 60       	breq	8000426a <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004280:	98 28       	ld.sh	r8,r12[0x4]
80004282:	e6 08 19 00 	cp.h	r8,r3
80004286:	e0 8b 00 0a 	brhi	8000429a <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000428a:	5c 78       	castu.h	r8
8000428c:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004290:	58 09       	cp.w	r9,0
80004292:	c0 40       	breq	8000429a <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004294:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004298:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000429a:	62 0c       	ld.w	r12,r1[0x0]
8000429c:	40 0b       	lddsp	r11,sp[0x0]
8000429e:	f0 1f 00 06 	mcall	800042b4 <xnl_rx_process+0x5c>
800042a2:	ce 4b       	rjmp	8000426a <xnl_rx_process+0x12>
800042a4:	00 00       	add	r0,r0
800042a6:	0a bc       	st.h	r5++,r12
800042a8:	00 00       	add	r0,r0
800042aa:	0a ac       	st.w	r5++,r12
800042ac:	00 00       	add	r0,r0
800042ae:	04 f0       	st.b	--r2,r0
800042b0:	80 00       	ld.sh	r0,r0[0x0]
800042b2:	66 cc       	ld.w	r12,r3[0x30]
800042b4:	80 00       	ld.sh	r0,r0[0x0]
800042b6:	2a 80       	sub	r0,-88

800042b8 <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
800042b8:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
800042ba:	4a a6       	lddpc	r6,80004360 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800042bc:	4a a2       	lddpc	r2,80004364 <xnl_tx_process+0xac>
800042be:	4a b4       	lddpc	r4,80004368 <xnl_tx_process+0xb0>
800042c0:	30 07       	mov	r7,0
800042c2:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800042c4:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
800042c6:	4a a5       	lddpc	r5,8000436c <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800042c8:	4a a3       	lddpc	r3,80004370 <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
800042ca:	6c 08       	ld.w	r8,r6[0x0]
800042cc:	58 08       	cp.w	r8,0
800042ce:	c0 40       	breq	800042d6 <xnl_tx_process+0x1e>
800042d0:	58 18       	cp.w	r8,1
800042d2:	cf d1       	brne	800042cc <xnl_tx_process+0x14>
800042d4:	c2 48       	rjmp	8000431c <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800042d6:	64 0c       	ld.w	r12,r2[0x0]
800042d8:	0e 99       	mov	r9,r7
800042da:	02 9a       	mov	r10,r1
800042dc:	08 9b       	mov	r11,r4
800042de:	f0 1f 00 26 	mcall	80004374 <xnl_tx_process+0xbc>
800042e2:	58 1c       	cp.w	r12,1
800042e4:	cf 31       	brne	800042ca <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
800042e6:	68 0b       	ld.w	r11,r4[0x0]
800042e8:	58 0b       	cp.w	r11,0
800042ea:	cf 00       	breq	800042ca <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800042ec:	96 28       	ld.sh	r8,r11[0x4]
800042ee:	e0 08 19 00 	cp.h	r8,r0
800042f2:	c0 71       	brne	80004300 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
800042f4:	4a 18       	lddpc	r8,80004378 <xnl_tx_process+0xc0>
800042f6:	70 08       	ld.w	r8,r8[0x0]
800042f8:	10 9c       	mov	r12,r8
800042fa:	f0 1f 00 21 	mcall	8000437c <xnl_tx_process+0xc4>
						break;
800042fe:	ce 6b       	rjmp	800042ca <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004300:	16 9c       	mov	r12,r11
80004302:	f0 1f 00 20 	mcall	80004380 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004306:	30 18       	mov	r8,1
80004308:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000430a:	66 0c       	ld.w	r12,r3[0x0]
8000430c:	0e 99       	mov	r9,r7
8000430e:	0e 9a       	mov	r10,r7
80004310:	0e 9b       	mov	r11,r7
80004312:	f0 1f 00 19 	mcall	80004374 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
80004316:	30 18       	mov	r8,1
80004318:	8d 08       	st.w	r6[0x0],r8
8000431a:	cd 8b       	rjmp	800042ca <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
8000431c:	66 0c       	ld.w	r12,r3[0x0]
8000431e:	0e 99       	mov	r9,r7
80004320:	36 4a       	mov	r10,100
80004322:	0e 9b       	mov	r11,r7
80004324:	f0 1f 00 14 	mcall	80004374 <xnl_tx_process+0xbc>
80004328:	58 1c       	cp.w	r12,1
8000432a:	c0 81       	brne	8000433a <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
8000432c:	49 38       	lddpc	r8,80004378 <xnl_tx_process+0xc0>
8000432e:	70 0c       	ld.w	r12,r8[0x0]
80004330:	68 0b       	ld.w	r11,r4[0x0]
80004332:	f0 1f 00 13 	mcall	8000437c <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80004336:	8d 07       	st.w	r6[0x0],r7
80004338:	cc 9b       	rjmp	800042ca <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
8000433a:	6a 08       	ld.w	r8,r5[0x0]
8000433c:	58 38       	cp.w	r8,3
8000433e:	e0 89 00 09 	brgt	80004350 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80004342:	68 0c       	ld.w	r12,r4[0x0]
80004344:	f0 1f 00 0f 	mcall	80004380 <xnl_tx_process+0xc8>
						xnl_send_times++;
80004348:	6a 08       	ld.w	r8,r5[0x0]
8000434a:	2f f8       	sub	r8,-1
8000434c:	8b 08       	st.w	r5[0x0],r8
8000434e:	cb eb       	rjmp	800042ca <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004350:	48 a8       	lddpc	r8,80004378 <xnl_tx_process+0xc0>
80004352:	70 0c       	ld.w	r12,r8[0x0]
80004354:	68 0b       	ld.w	r11,r4[0x0]
80004356:	f0 1f 00 0a 	mcall	8000437c <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
8000435a:	8d 07       	st.w	r6[0x0],r7
8000435c:	cb 7b       	rjmp	800042ca <xnl_tx_process+0x12>
8000435e:	00 00       	add	r0,r0
80004360:	00 00       	add	r0,r0
80004362:	0b 58       	ld.sh	r8,--r5
80004364:	00 00       	add	r0,r0
80004366:	0b 5c       	ld.sh	r12,--r5
80004368:	00 00       	add	r0,r0
8000436a:	0b 64       	ld.uh	r4,--r5
8000436c:	00 00       	add	r0,r0
8000436e:	0b 60       	ld.uh	r0,--r5
80004370:	00 00       	add	r0,r0
80004372:	0b 48       	ld.w	r8,--r5
80004374:	80 00       	ld.sh	r0,r0[0x0]
80004376:	66 cc       	ld.w	r12,r3[0x30]
80004378:	00 00       	add	r0,r0
8000437a:	0a ac       	st.w	r5++,r12
8000437c:	80 00       	ld.sh	r0,r0[0x0]
8000437e:	2a 80       	sub	r0,-88
80004380:	80 00       	ld.sh	r0,r0[0x0]
80004382:	2a a0       	sub	r0,-86

80004384 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004384:	eb cd 40 c0 	pushm	r6-r7,lr
80004388:	20 1d       	sub	sp,4
8000438a:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
8000438c:	98 39       	ld.sh	r9,r12[0x6]
8000438e:	3f f8       	mov	r8,-1
80004390:	f0 09 19 00 	cp.h	r9,r8
80004394:	c0 a1       	brne	800043a8 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004396:	4a e9       	lddpc	r9,8000444c <xnl_tx+0xc8>
80004398:	13 88       	ld.ub	r8,r9[0x0]
8000439a:	2f f8       	sub	r8,-1
8000439c:	5c 58       	castu.b	r8
8000439e:	b2 88       	st.b	r9[0x0],r8
800043a0:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800043a4:	a9 a8       	sbr	r8,0x8
800043a6:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800043a8:	8c 49       	ld.sh	r9,r6[0x8]
800043aa:	3f f8       	mov	r8,-1
800043ac:	f0 09 19 00 	cp.h	r9,r8
800043b0:	c0 41       	brne	800043b8 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800043b2:	4a 88       	lddpc	r8,80004450 <xnl_tx+0xcc>
800043b4:	90 18       	ld.sh	r8,r8[0x2]
800043b6:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800043b8:	8c 59       	ld.sh	r9,r6[0xa]
800043ba:	3f f8       	mov	r8,-1
800043bc:	f0 09 19 00 	cp.h	r9,r8
800043c0:	c0 41       	brne	800043c8 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800043c2:	4a 48       	lddpc	r8,80004450 <xnl_tx+0xcc>
800043c4:	90 28       	ld.sh	r8,r8[0x4]
800043c6:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
800043c8:	8c 69       	ld.sh	r9,r6[0xc]
800043ca:	3f f8       	mov	r8,-1
800043cc:	f0 09 19 00 	cp.h	r9,r8
800043d0:	c0 e1       	brne	800043ec <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
800043d2:	4a 08       	lddpc	r8,80004450 <xnl_tx+0xcc>
800043d4:	90 49       	ld.sh	r9,r8[0x8]
800043d6:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800043d8:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
800043da:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800043dc:	90 49       	ld.sh	r9,r8[0x8]
800043de:	e0 19 ff 00 	andl	r9,0xff00
800043e2:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
800043e6:	f3 e8 10 08 	or	r8,r9,r8
800043ea:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
800043ec:	0d 98       	ld.ub	r8,r6[0x1]
800043ee:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
800043f0:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
800043f4:	10 0c       	add	r12,r8
800043f6:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800043f8:	58 0c       	cp.w	r12,0
800043fa:	e0 89 00 04 	brgt	80004402 <xnl_tx+0x7e>
800043fe:	30 09       	mov	r9,0
80004400:	c0 d8       	rjmp	8000441a <xnl_tx+0x96>
80004402:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004406:	2f ec       	sub	r12,-2
80004408:	30 09       	mov	r9,0
8000440a:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
8000440c:	15 1b       	ld.sh	r11,r10++
8000440e:	f6 09 00 09 	add	r9,r11,r9
80004412:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004414:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004416:	18 38       	cp.w	r8,r12
80004418:	cf a1       	brne	8000440c <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
8000441a:	5c 39       	neg	r9
8000441c:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000441e:	48 e8       	lddpc	r8,80004454 <xnl_tx+0xd0>
80004420:	70 0c       	ld.w	r12,r8[0x0]
80004422:	f0 1f 00 0e 	mcall	80004458 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004426:	c1 00       	breq	80004446 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004428:	fa c7 ff fc 	sub	r7,sp,-4
8000442c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
8000442e:	e0 6a 01 00 	mov	r10,256
80004432:	0c 9b       	mov	r11,r6
80004434:	f0 1f 00 0a 	mcall	8000445c <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004438:	48 a8       	lddpc	r8,80004460 <xnl_tx+0xdc>
8000443a:	70 0c       	ld.w	r12,r8[0x0]
8000443c:	30 09       	mov	r9,0
8000443e:	12 9a       	mov	r10,r9
80004440:	1a 9b       	mov	r11,sp
80004442:	f0 1f 00 09 	mcall	80004464 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004446:	2f fd       	sub	sp,-4
80004448:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000444c:	00 00       	add	r0,r0
8000444e:	0b 4c       	ld.w	r12,--r5
80004450:	00 00       	add	r0,r0
80004452:	0b 4e       	ld.w	lr,--r5
80004454:	00 00       	add	r0,r0
80004456:	0a ac       	st.w	r5++,r12
80004458:	80 00       	ld.sh	r0,r0[0x0]
8000445a:	2c 2c       	sub	r12,-62
8000445c:	80 00       	ld.sh	r0,r0[0x0]
8000445e:	7f 22       	ld.w	r2,pc[0x48]
80004460:	00 00       	add	r0,r0
80004462:	0b 5c       	ld.sh	r12,--r5
80004464:	80 00       	ld.sh	r0,r0[0x0]
80004466:	68 d8       	ld.w	r8,r4[0x34]

80004468 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004468:	eb cd 40 80 	pushm	r7,lr
8000446c:	fa cd 01 00 	sub	sp,sp,256
80004470:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004472:	e0 68 40 0e 	mov	r8,16398
80004476:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004478:	3f f8       	mov	r8,-1
8000447a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
8000447c:	30 c8       	mov	r8,12
8000447e:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004480:	98 38       	ld.sh	r8,r12[0x6]
80004482:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004484:	98 58       	ld.sh	r8,r12[0xa]
80004486:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004488:	98 48       	ld.sh	r8,r12[0x8]
8000448a:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
8000448c:	98 68       	ld.sh	r8,r12[0xc]
8000448e:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004490:	30 08       	mov	r8,0
80004492:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004494:	1a 9c       	mov	r12,sp
80004496:	f0 1f 00 0a 	mcall	800044bc <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
8000449a:	fa cd 00 cc 	sub	sp,sp,204
8000449e:	e0 6a 00 ca 	mov	r10,202
800044a2:	ee cb ff f0 	sub	r11,r7,-16
800044a6:	1a 9c       	mov	r12,sp
800044a8:	f0 1f 00 06 	mcall	800044c0 <xnl_data_msg_func+0x58>
800044ac:	48 68       	lddpc	r8,800044c4 <xnl_data_msg_func+0x5c>
800044ae:	70 08       	ld.w	r8,r8[0x0]
800044b0:	5d 18       	icall	r8
800044b2:	fa cd ff 34 	sub	sp,sp,-204
}
800044b6:	2c 0d       	sub	sp,-256
800044b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800044bc:	80 00       	ld.sh	r0,r0[0x0]
800044be:	43 84       	lddsp	r4,sp[0xe0]
800044c0:	80 00       	ld.sh	r0,r0[0x0]
800044c2:	7f 22       	ld.w	r2,pc[0x48]
800044c4:	00 00       	add	r0,r0
800044c6:	0b 68       	ld.uh	r8,--r5

800044c8 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
800044c8:	d4 21       	pushm	r4-r7,lr
800044ca:	fa cd 01 00 	sub	sp,sp,256
800044ce:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
800044d0:	4c 28       	lddpc	r8,800045d8 <xnl_device_auth_reply_func+0x110>
800044d2:	11 88       	ld.ub	r8,r8[0x0]
800044d4:	58 08       	cp.w	r8,0
800044d6:	e0 81 00 7f 	brne	800045d4 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
800044da:	4c 18       	lddpc	r8,800045dc <xnl_device_auth_reply_func+0x114>
800044dc:	70 0c       	ld.w	r12,r8[0x0]
800044de:	30 09       	mov	r9,0
800044e0:	12 9a       	mov	r10,r9
800044e2:	12 9b       	mov	r11,r9
800044e4:	f0 1f 00 3f 	mcall	800045e0 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
800044e8:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
800044ec:	4b b8       	lddpc	r8,800045d8 <xnl_device_auth_reply_func+0x110>
800044ee:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
800044f0:	ef 39 00 12 	ld.ub	r9,r7[18]
800044f4:	ef 38 00 13 	ld.ub	r8,r7[19]
800044f8:	b1 68       	lsl	r8,0x10
800044fa:	f1 e9 11 89 	or	r9,r8,r9<<0x18
800044fe:	ef 38 00 15 	ld.ub	r8,r7[21]
80004502:	f3 e8 10 08 	or	r8,r9,r8
80004506:	ef 39 00 14 	ld.ub	r9,r7[20]
8000450a:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
8000450e:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004512:	ef 38 00 17 	ld.ub	r8,r7[23]
80004516:	b1 68       	lsl	r8,0x10
80004518:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
8000451c:	ef 38 00 19 	ld.ub	r8,r7[25]
80004520:	f5 e8 10 08 	or	r8,r10,r8
80004524:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004528:	f1 ea 10 88 	or	r8,r8,r10<<0x8
8000452c:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000452e:	e0 64 79 b9 	mov	r4,31161
80004532:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004536:	e0 65 45 07 	mov	r5,17671
8000453a:	ea 15 8a bd 	orh	r5,0x8abd
8000453e:	e0 66 f9 3d 	mov	r6,63805
80004542:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004546:	e0 6e b8 cf 	mov	lr,47311
8000454a:	ea 1e 36 83 	orh	lr,0x3683
8000454e:	e0 67 aa 1c 	mov	r7,43548
80004552:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004556:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004558:	f4 08 00 0c 	add	r12,r10,r8
8000455c:	f0 0b 15 04 	lsl	r11,r8,0x4
80004560:	0a 0b       	add	r11,r5
80004562:	f9 eb 20 0b 	eor	r11,r12,r11
80004566:	f0 0c 16 05 	lsr	r12,r8,0x5
8000456a:	0c 0c       	add	r12,r6
8000456c:	18 5b       	eor	r11,r12
8000456e:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004570:	f2 0c 15 04 	lsl	r12,r9,0x4
80004574:	1c 0c       	add	r12,lr
80004576:	f2 0b 16 05 	lsr	r11,r9,0x5
8000457a:	0e 0b       	add	r11,r7
8000457c:	f9 eb 20 0b 	eor	r11,r12,r11
80004580:	f2 0a 00 0c 	add	r12,r9,r10
80004584:	18 5b       	eor	r11,r12
80004586:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004588:	e0 6b 37 20 	mov	r11,14112
8000458c:	ea 1b c6 ef 	orh	r11,0xc6ef
80004590:	16 3a       	cp.w	r10,r11
80004592:	ce 21       	brne	80004556 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004594:	e0 6a 40 1a 	mov	r10,16410
80004598:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000459a:	3f fa       	mov	r10,-1
8000459c:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
8000459e:	30 6b       	mov	r11,6
800045a0:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800045a2:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800045a4:	48 db       	lddpc	r11,800045d8 <xnl_device_auth_reply_func+0x110>
800045a6:	96 1c       	ld.sh	r12,r11[0x2]
800045a8:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
800045aa:	96 2b       	ld.sh	r11,r11[0x4]
800045ac:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800045ae:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
800045b0:	30 ca       	mov	r10,12
800045b2:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
800045b4:	30 0a       	mov	r10,0
800045b6:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
800045ba:	30 7a       	mov	r10,7
800045bc:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
800045c0:	30 2a       	mov	r10,2
800045c2:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800045c6:	fa ca ff ec 	sub	r10,sp,-20
800045ca:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800045cc:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
800045ce:	1a 9c       	mov	r12,sp
800045d0:	f0 1f 00 05 	mcall	800045e4 <xnl_device_auth_reply_func+0x11c>
}
800045d4:	2c 0d       	sub	sp,-256
800045d6:	d8 22       	popm	r4-r7,pc
800045d8:	00 00       	add	r0,r0
800045da:	0b 4e       	ld.w	lr,--r5
800045dc:	00 00       	add	r0,r0
800045de:	0b 48       	ld.w	r8,--r5
800045e0:	80 00       	ld.sh	r0,r0[0x0]
800045e2:	68 d8       	ld.w	r8,r4[0x34]
800045e4:	80 00       	ld.sh	r0,r0[0x0]
800045e6:	43 84       	lddsp	r4,sp[0xe0]

800045e8 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
800045e8:	eb cd 40 80 	pushm	r7,lr
800045ec:	fa cd 01 00 	sub	sp,sp,256
800045f0:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
800045f2:	49 28       	lddpc	r8,80004638 <xnl_master_status_brdcst_func+0x50>
800045f4:	11 88       	ld.ub	r8,r8[0x0]
800045f6:	58 08       	cp.w	r8,0
800045f8:	c1 c1       	brne	80004630 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
800045fa:	49 18       	lddpc	r8,8000463c <xnl_master_status_brdcst_func+0x54>
800045fc:	70 0c       	ld.w	r12,r8[0x0]
800045fe:	30 09       	mov	r9,0
80004600:	12 9a       	mov	r10,r9
80004602:	12 9b       	mov	r11,r9
80004604:	f0 1f 00 0f 	mcall	80004640 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004608:	8e 58       	ld.sh	r8,r7[0xa]
8000460a:	48 c9       	lddpc	r9,80004638 <xnl_master_status_brdcst_func+0x50>
8000460c:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000460e:	e0 68 40 0e 	mov	r8,16398
80004612:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004614:	3f f8       	mov	r8,-1
80004616:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004618:	30 4a       	mov	r10,4
8000461a:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
8000461c:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000461e:	92 19       	ld.sh	r9,r9[0x2]
80004620:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004622:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004624:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80004626:	30 08       	mov	r8,0
80004628:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
8000462a:	1a 9c       	mov	r12,sp
8000462c:	f0 1f 00 06 	mcall	80004644 <xnl_master_status_brdcst_func+0x5c>
}
80004630:	2c 0d       	sub	sp,-256
80004632:	e3 cd 80 80 	ldm	sp++,r7,pc
80004636:	00 00       	add	r0,r0
80004638:	00 00       	add	r0,r0
8000463a:	0b 4e       	ld.w	lr,--r5
8000463c:	00 00       	add	r0,r0
8000463e:	0b 48       	ld.w	r8,--r5
80004640:	80 00       	ld.sh	r0,r0[0x0]
80004642:	68 d8       	ld.w	r8,r4[0x34]
80004644:	80 00       	ld.sh	r0,r0[0x0]
80004646:	43 84       	lddsp	r4,sp[0xe0]

80004648 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004648:	eb cd 40 80 	pushm	r7,lr
8000464c:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
8000464e:	49 28       	lddpc	r8,80004694 <xnl_device_conn_reply_func+0x4c>
80004650:	70 0c       	ld.w	r12,r8[0x0]
80004652:	30 09       	mov	r9,0
80004654:	12 9a       	mov	r10,r9
80004656:	12 9b       	mov	r11,r9
80004658:	f0 1f 00 10 	mcall	80004698 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
8000465c:	ef 18 00 10 	ld.uh	r8,r7[16]
80004660:	10 99       	mov	r9,r8
80004662:	e2 19 ff 00 	andl	r9,0xff00,COH
80004666:	e0 49 01 00 	cp.w	r9,256
8000466a:	c0 60       	breq	80004676 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
8000466c:	0e 9c       	mov	r12,r7
8000466e:	f0 1f 00 0c 	mcall	8000469c <xnl_device_conn_reply_func+0x54>
80004672:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004676:	a9 68       	lsl	r8,0x8
80004678:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
8000467c:	48 98       	lddpc	r8,800046a0 <xnl_device_conn_reply_func+0x58>
8000467e:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004680:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004684:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004686:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
8000468a:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
8000468c:	30 19       	mov	r9,1
8000468e:	b0 89       	st.b	r8[0x0],r9
80004690:	e3 cd 80 80 	ldm	sp++,r7,pc
80004694:	00 00       	add	r0,r0
80004696:	0b 48       	ld.w	r8,--r5
80004698:	80 00       	ld.sh	r0,r0[0x0]
8000469a:	68 d8       	ld.w	r8,r4[0x34]
8000469c:	80 00       	ld.sh	r0,r0[0x0]
8000469e:	45 e8       	lddsp	r8,sp[0x178]
800046a0:	00 00       	add	r0,r0
800046a2:	0b 4e       	ld.w	lr,--r5

800046a4 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
800046a4:	d4 01       	pushm	lr
800046a6:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800046aa:	e0 68 40 0e 	mov	r8,16398
800046ae:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800046b0:	3f f8       	mov	r8,-1
800046b2:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
800046b4:	30 38       	mov	r8,3
800046b6:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
800046b8:	30 08       	mov	r8,0
800046ba:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
800046bc:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
800046be:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
800046c0:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
800046c2:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800046c4:	1a 9c       	mov	r12,sp
800046c6:	f0 1f 00 03 	mcall	800046d0 <xnl_send_device_master_query+0x2c>
}
800046ca:	2c 0d       	sub	sp,-256
800046cc:	d8 02       	popm	pc
800046ce:	00 00       	add	r0,r0
800046d0:	80 00       	ld.sh	r0,r0[0x0]
800046d2:	43 84       	lddsp	r4,sp[0xe0]

800046d4 <RC522_SPI_SetSpeed>:
	SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
800046d4:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
800046d6:	48 78       	lddpc	r8,800046f0 <RC522_SPI_SetSpeed+0x1c>
800046d8:	70 09       	ld.w	r9,r8[0x0]
800046da:	72 ca       	ld.w	r10,r9[0x30]
800046dc:	5c 7c       	castu.h	r12
800046de:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
800046e2:	f9 ea 10 0a 	or	r10,r12,r10
800046e6:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
800046e8:	70 0c       	ld.w	r12,r8[0x0]
800046ea:	f0 1f 00 03 	mcall	800046f4 <RC522_SPI_SetSpeed+0x20>
		
	
}
800046ee:	d8 02       	popm	pc
800046f0:	00 00       	add	r0,r0
800046f2:	20 8c       	sub	r12,8
800046f4:	80 00       	ld.sh	r0,r0[0x0]
800046f6:	5d c8       	*unknown*

800046f8 <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
800046f8:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0400);//baudDiv=4
800046fa:	e0 6c 04 00 	mov	r12,1024
800046fe:	f0 1f 00 02 	mcall	80004704 <RC522_SPI_SetSpeedLow+0xc>
	
}
80004702:	d8 02       	popm	pc
80004704:	80 00       	ld.sh	r0,r0[0x0]
80004706:	46 d4       	lddsp	r4,sp[0x1b4]

80004708 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
80004708:	eb cd 40 c0 	pushm	r6-r7,lr
	U16 *Data ;

	//蹇椤昏锋芥ｅ父璇诲
	spi_selectChip(spi, DF_SPI_PCS_0);
8000470c:	48 b7       	lddpc	r7,80004738 <RC522_ReadByte+0x30>
8000470e:	30 0b       	mov	r11,0
80004710:	6e 0c       	ld.w	r12,r7[0x0]
80004712:	f0 1f 00 0b 	mcall	8000473c <RC522_ReadByte+0x34>
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
80004716:	e0 6b 00 ff 	mov	r11,255
8000471a:	6e 0c       	ld.w	r12,r7[0x0]
8000471c:	f0 1f 00 09 	mcall	80004740 <RC522_ReadByte+0x38>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
80004720:	30 06       	mov	r6,0
80004722:	0c 9b       	mov	r11,r6
80004724:	6e 0c       	ld.w	r12,r7[0x0]
80004726:	f0 1f 00 08 	mcall	80004744 <RC522_ReadByte+0x3c>

	/*!< Return the shifted data */
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
8000472a:	0c 9b       	mov	r11,r6
8000472c:	6e 0c       	ld.w	r12,r7[0x0]
8000472e:	f0 1f 00 07 	mcall	80004748 <RC522_ReadByte+0x40>
	
	return (U8)(*Data);
	
}
80004732:	0d 9c       	ld.ub	r12,r6[0x1]
80004734:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004738:	00 00       	add	r0,r0
8000473a:	20 8c       	sub	r12,8
8000473c:	80 00       	ld.sh	r0,r0[0x0]
8000473e:	5f 34       	srlo	r4
80004740:	80 00       	ld.sh	r0,r0[0x0]
80004742:	5d ce       	*unknown*
80004744:	80 00       	ld.sh	r0,r0[0x0]
80004746:	5d ea       	*unknown*
80004748:	80 00       	ld.sh	r0,r0[0x0]
8000474a:	5e f4       	retal	r4

8000474c <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
8000474c:	eb cd 40 c0 	pushm	r6-r7,lr
80004750:	20 1d       	sub	sp,4
80004752:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	spi_selectChip(spi, DF_SPI_PCS_0);
80004754:	48 c7       	lddpc	r7,80004784 <RC522_WriteByte+0x38>
80004756:	30 0b       	mov	r11,0
80004758:	6e 0c       	ld.w	r12,r7[0x0]
8000475a:	f0 1f 00 0c 	mcall	80004788 <RC522_WriteByte+0x3c>
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
8000475e:	1b 8b       	ld.ub	r11,sp[0x0]
80004760:	6e 0c       	ld.w	r12,r7[0x0]
80004762:	f0 1f 00 0b 	mcall	8000478c <RC522_WriteByte+0x40>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
80004766:	1a 9b       	mov	r11,sp
80004768:	6e 0c       	ld.w	r12,r7[0x0]
8000476a:	f0 1f 00 0a 	mcall	80004790 <RC522_WriteByte+0x44>
8000476e:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004770:	30 0b       	mov	r11,0
80004772:	6e 0c       	ld.w	r12,r7[0x0]
80004774:	f0 1f 00 08 	mcall	80004794 <RC522_WriteByte+0x48>
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
80004778:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
8000477c:	2f fd       	sub	sp,-4
8000477e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004782:	00 00       	add	r0,r0
80004784:	00 00       	add	r0,r0
80004786:	20 8c       	sub	r12,8
80004788:	80 00       	ld.sh	r0,r0[0x0]
8000478a:	5f 34       	srlo	r4
8000478c:	80 00       	ld.sh	r0,r0[0x0]
8000478e:	5d ce       	*unknown*
80004790:	80 00       	ld.sh	r0,r0[0x0]
80004792:	5d ea       	*unknown*
80004794:	80 00       	ld.sh	r0,r0[0x0]
80004796:	5e f4       	retal	r4

80004798 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
80004798:	eb cd 40 c0 	pushm	r6-r7,lr
8000479c:	18 96       	mov	r6,r12
8000479e:	16 97       	mov	r7,r11
	U8   ucAddr;

	CLR_SPI_CS;	
800047a0:	31 8c       	mov	r12,24
800047a2:	f0 1f 00 09 	mcall	800047c4 <WriteRawRC+0x2c>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
800047a6:	ec 0c 15 01 	lsl	r12,r6,0x1
800047aa:	e2 1c 00 7e 	andl	r12,0x7e,COH
800047ae:	f0 1f 00 07 	mcall	800047c8 <WriteRawRC+0x30>
	RC522_WriteByte(value);
800047b2:	0e 9c       	mov	r12,r7
800047b4:	f0 1f 00 05 	mcall	800047c8 <WriteRawRC+0x30>
	
	SET_SPI_CS;
800047b8:	31 8c       	mov	r12,24
800047ba:	f0 1f 00 05 	mcall	800047cc <WriteRawRC+0x34>

}
800047be:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800047c2:	00 00       	add	r0,r0
800047c4:	80 00       	ld.sh	r0,r0[0x0]
800047c6:	5a c8       	cp.w	r8,-20
800047c8:	80 00       	ld.sh	r0,r0[0x0]
800047ca:	47 4c       	lddsp	r12,sp[0x1d0]
800047cc:	80 00       	ld.sh	r0,r0[0x0]
800047ce:	5a ac       	cp.w	r12,-22

800047d0 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
800047d0:	d4 01       	pushm	lr

	SET_RC522RST;
800047d2:	31 9c       	mov	r12,25
800047d4:	f0 1f 00 1b 	mcall	80004840 <PcdReset+0x70>
	delay_ns(10);
800047d8:	30 ac       	mov	r12,10
800047da:	f0 1f 00 1b 	mcall	80004844 <PcdReset+0x74>

	CLR_RC522RST;
800047de:	31 9c       	mov	r12,25
800047e0:	f0 1f 00 1a 	mcall	80004848 <PcdReset+0x78>
	delay_ns(10);
800047e4:	30 ac       	mov	r12,10
800047e6:	f0 1f 00 18 	mcall	80004844 <PcdReset+0x74>

	SET_RC522RST;
800047ea:	31 9c       	mov	r12,25
800047ec:	f0 1f 00 15 	mcall	80004840 <PcdReset+0x70>
	delay_ns(10);
800047f0:	30 ac       	mov	r12,10
800047f2:	f0 1f 00 15 	mcall	80004844 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
800047f6:	30 fb       	mov	r11,15
800047f8:	30 1c       	mov	r12,1
800047fa:	f0 1f 00 15 	mcall	8000484c <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
800047fe:	30 fb       	mov	r11,15
80004800:	30 1c       	mov	r12,1
80004802:	f0 1f 00 13 	mcall	8000484c <PcdReset+0x7c>
	delay_ns(10);
80004806:	30 ac       	mov	r12,10
80004808:	f0 1f 00 0f 	mcall	80004844 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
8000480c:	33 db       	mov	r11,61
8000480e:	31 1c       	mov	r12,17
80004810:	f0 1f 00 0f 	mcall	8000484c <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
80004814:	31 eb       	mov	r11,30
80004816:	32 dc       	mov	r12,45
80004818:	f0 1f 00 0d 	mcall	8000484c <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
8000481c:	30 0b       	mov	r11,0
8000481e:	32 cc       	mov	r12,44
80004820:	f0 1f 00 0b 	mcall	8000484c <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
80004824:	e0 6b 00 8d 	mov	r11,141
80004828:	32 ac       	mov	r12,42
8000482a:	f0 1f 00 09 	mcall	8000484c <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
8000482e:	33 eb       	mov	r11,62
80004830:	32 bc       	mov	r12,43
80004832:	f0 1f 00 07 	mcall	8000484c <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
80004836:	34 0b       	mov	r11,64
80004838:	31 5c       	mov	r12,21
8000483a:	f0 1f 00 05 	mcall	8000484c <PcdReset+0x7c>
	
	return MI_OK;
}
8000483e:	d8 0a       	popm	pc,r12=0
80004840:	80 00       	ld.sh	r0,r0[0x0]
80004842:	5a ac       	cp.w	r12,-22
80004844:	80 00       	ld.sh	r0,r0[0x0]
80004846:	50 48       	stdsp	sp[0x10],r8
80004848:	80 00       	ld.sh	r0,r0[0x0]
8000484a:	5a c8       	cp.w	r8,-20
8000484c:	80 00       	ld.sh	r0,r0[0x0]
8000484e:	47 98       	lddsp	r8,sp[0x1e4]

80004850 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
80004850:	eb cd 40 80 	pushm	r7,lr
80004854:	18 97       	mov	r7,r12
	U8   ucAddr;
	U8   ucResult=0;
	CLR_SPI_CS;	
80004856:	31 8c       	mov	r12,24
80004858:	f0 1f 00 0a 	mcall	80004880 <ReadRawRC+0x30>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
8000485c:	ee 08 15 01 	lsl	r8,r7,0x1
80004860:	10 9c       	mov	r12,r8
80004862:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004866:	a7 bc       	sbr	r12,0x7
80004868:	f0 1f 00 07 	mcall	80004884 <ReadRawRC+0x34>
	ucResult = RC522_ReadByte();
8000486c:	f0 1f 00 07 	mcall	80004888 <ReadRawRC+0x38>
80004870:	18 97       	mov	r7,r12
	
	SET_SPI_CS;
80004872:	31 8c       	mov	r12,24
80004874:	f0 1f 00 06 	mcall	8000488c <ReadRawRC+0x3c>
	return ucResult;
}
80004878:	0e 9c       	mov	r12,r7
8000487a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000487e:	00 00       	add	r0,r0
80004880:	80 00       	ld.sh	r0,r0[0x0]
80004882:	5a c8       	cp.w	r8,-20
80004884:	80 00       	ld.sh	r0,r0[0x0]
80004886:	47 4c       	lddsp	r12,sp[0x1d0]
80004888:	80 00       	ld.sh	r0,r0[0x0]
8000488a:	47 08       	lddsp	r8,sp[0x1c0]
8000488c:	80 00       	ld.sh	r0,r0[0x0]
8000488e:	5a ac       	cp.w	r12,-22

80004890 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80004890:	eb cd 40 c0 	pushm	r6-r7,lr
80004894:	18 97       	mov	r7,r12
80004896:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80004898:	f0 1f 00 05 	mcall	800048ac <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
8000489c:	f9 e6 10 0b 	or	r11,r12,r6
800048a0:	5c 5b       	castu.b	r11
800048a2:	0e 9c       	mov	r12,r7
800048a4:	f0 1f 00 03 	mcall	800048b0 <SetBitMask+0x20>
}
800048a8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800048ac:	80 00       	ld.sh	r0,r0[0x0]
800048ae:	48 50       	lddpc	r0,800048c0 <PcdAntennaOn+0xc>
800048b0:	80 00       	ld.sh	r0,r0[0x0]
800048b2:	47 98       	lddsp	r8,sp[0x1e4]

800048b4 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
800048b4:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
800048b6:	31 4c       	mov	r12,20
800048b8:	f0 1f 00 05 	mcall	800048cc <PcdAntennaOn+0x18>
	if (!(i & 0x03))
800048bc:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
800048c0:	c0 51       	brne	800048ca <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
800048c2:	30 3b       	mov	r11,3
800048c4:	31 4c       	mov	r12,20
800048c6:	f0 1f 00 03 	mcall	800048d0 <PcdAntennaOn+0x1c>
800048ca:	d8 02       	popm	pc
800048cc:	80 00       	ld.sh	r0,r0[0x0]
800048ce:	48 50       	lddpc	r0,800048e0 <ClearBitMask+0xc>
800048d0:	80 00       	ld.sh	r0,r0[0x0]
800048d2:	48 90       	lddpc	r0,800048f4 <ClearBitMask+0x20>

800048d4 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
800048d4:	eb cd 40 c0 	pushm	r6-r7,lr
800048d8:	18 97       	mov	r7,r12
800048da:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
800048dc:	f0 1f 00 06 	mcall	800048f4 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
800048e0:	5c d6       	com	r6
800048e2:	f9 e6 00 06 	and	r6,r12,r6
800048e6:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
800048ea:	0e 9c       	mov	r12,r7
800048ec:	f0 1f 00 03 	mcall	800048f8 <ClearBitMask+0x24>
	
}
800048f0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800048f4:	80 00       	ld.sh	r0,r0[0x0]
800048f6:	48 50       	lddpc	r0,80004908 <PcdAntennaOff+0xc>
800048f8:	80 00       	ld.sh	r0,r0[0x0]
800048fa:	47 98       	lddsp	r8,sp[0x1e4]

800048fc <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
800048fc:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
800048fe:	30 3b       	mov	r11,3
80004900:	31 4c       	mov	r12,20
80004902:	f0 1f 00 02 	mcall	80004908 <PcdAntennaOff+0xc>
}
80004906:	d8 02       	popm	pc
80004908:	80 00       	ld.sh	r0,r0[0x0]
8000490a:	48 d4       	lddpc	r4,8000493c <M500PcdConfigISOType+0x30>

8000490c <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
8000490c:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
8000490e:	34 18       	mov	r8,65
80004910:	f0 0c 18 00 	cp.b	r12,r8
80004914:	c0 20       	breq	80004918 <M500PcdConfigISOType+0xc>
80004916:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80004918:	30 8b       	mov	r11,8
8000491a:	16 9c       	mov	r12,r11
8000491c:	f0 1f 00 14 	mcall	8000496c <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
80004920:	33 db       	mov	r11,61
80004922:	31 1c       	mov	r12,17
80004924:	f0 1f 00 13 	mcall	80004970 <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80004928:	e0 6b 00 86 	mov	r11,134
8000492c:	31 7c       	mov	r12,23
8000492e:	f0 1f 00 11 	mcall	80004970 <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
80004932:	37 fb       	mov	r11,127
80004934:	32 6c       	mov	r12,38
80004936:	f0 1f 00 0f 	mcall	80004970 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
8000493a:	31 eb       	mov	r11,30
8000493c:	32 dc       	mov	r12,45
8000493e:	f0 1f 00 0d 	mcall	80004970 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
80004942:	30 0b       	mov	r11,0
80004944:	32 cc       	mov	r12,44
80004946:	f0 1f 00 0b 	mcall	80004970 <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
8000494a:	e0 6b 00 8d 	mov	r11,141
8000494e:	32 ac       	mov	r12,42
80004950:	f0 1f 00 08 	mcall	80004970 <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80004954:	33 eb       	mov	r11,62
80004956:	32 bc       	mov	r12,43
80004958:	f0 1f 00 06 	mcall	80004970 <M500PcdConfigISOType+0x64>
		delay_ns(1000);
8000495c:	e0 6c 03 e8 	mov	r12,1000
80004960:	f0 1f 00 05 	mcall	80004974 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80004964:	f0 1f 00 05 	mcall	80004978 <M500PcdConfigISOType+0x6c>
80004968:	d8 0a       	popm	pc,r12=0
8000496a:	00 00       	add	r0,r0
8000496c:	80 00       	ld.sh	r0,r0[0x0]
8000496e:	48 d4       	lddpc	r4,800049a0 <rc522_init+0x24>
80004970:	80 00       	ld.sh	r0,r0[0x0]
80004972:	47 98       	lddsp	r8,sp[0x1e4]
80004974:	80 00       	ld.sh	r0,r0[0x0]
80004976:	50 48       	stdsp	sp[0x10],r8
80004978:	80 00       	ld.sh	r0,r0[0x0]
8000497a:	48 b4       	lddpc	r4,800049a4 <rc522_init+0x28>

8000497c <rc522_init>:


//mfrc522 init

void rc522_init()
{
8000497c:	eb cd 40 c0 	pushm	r6-r7,lr
80004980:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004982:	4a 28       	lddpc	r8,80004a08 <rc522_init+0x8c>
80004984:	1a 96       	mov	r6,sp
80004986:	f0 ea 00 00 	ld.d	r10,r8[0]
8000498a:	fa eb 00 00 	st.d	sp[0],r10
8000498e:	f0 e8 00 08 	ld.d	r8,r8[8]
80004992:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80004996:	30 4b       	mov	r11,4
80004998:	49 dc       	lddpc	r12,80004a0c <rc522_init+0x90>
8000499a:	f0 1f 00 1e 	mcall	80004a10 <rc522_init+0x94>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
8000499e:	31 9c       	mov	r12,25
800049a0:	f0 1f 00 1d 	mcall	80004a14 <rc522_init+0x98>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
800049a4:	31 9c       	mov	r12,25
800049a6:	f0 1f 00 1d 	mcall	80004a18 <rc522_init+0x9c>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
800049aa:	49 d7       	lddpc	r7,80004a1c <rc522_init+0xa0>
800049ac:	fe 7c 24 00 	mov	r12,-56320
800049b0:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
800049b2:	1a 9b       	mov	r11,sp
800049b4:	f0 1f 00 1b 	mcall	80004a20 <rc522_init+0xa4>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
800049b8:	30 09       	mov	r9,0
800049ba:	12 9a       	mov	r10,r9
800049bc:	12 9b       	mov	r11,r9
800049be:	6e 0c       	ld.w	r12,r7[0x0]
800049c0:	f0 1f 00 19 	mcall	80004a24 <rc522_init+0xa8>

	// Enable SPI.
	spi_enable(spi);
800049c4:	6e 0c       	ld.w	r12,r7[0x0]
800049c6:	f0 1f 00 19 	mcall	80004a28 <rc522_init+0xac>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
800049ca:	e0 6a 36 00 	mov	r10,13824
800049ce:	ea 1a 01 6e 	orh	r10,0x16e
800049d2:	1a 9b       	mov	r11,sp
800049d4:	6e 0c       	ld.w	r12,r7[0x0]
800049d6:	f0 1f 00 16 	mcall	80004a2c <rc522_init+0xb0>
800049da:	c0 50       	breq	800049e4 <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
800049dc:	30 29       	mov	r9,2
800049de:	49 58       	lddpc	r8,80004a30 <rc522_init+0xb4>
800049e0:	b0 89       	st.b	r8[0x0],r9
800049e2:	c0 38       	rjmp	800049e8 <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
800049e4:	f0 1f 00 14 	mcall	80004a34 <rc522_init+0xb8>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
800049e8:	f0 1f 00 14 	mcall	80004a38 <rc522_init+0xbc>
	
	PcdAntennaOff();
800049ec:	f0 1f 00 14 	mcall	80004a3c <rc522_init+0xc0>
	
	delay_ms(2); 
800049f0:	30 2c       	mov	r12,2
800049f2:	f0 1f 00 14 	mcall	80004a40 <rc522_init+0xc4>
	
	PcdAntennaOn();
800049f6:	f0 1f 00 14 	mcall	80004a44 <rc522_init+0xc8>
	
	M500PcdConfigISOType( 'A' );
800049fa:	34 1c       	mov	r12,65
800049fc:	f0 1f 00 13 	mcall	80004a48 <rc522_init+0xcc>
	

80004a00:	2f cd       	sub	sp,-16
80004a02:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a06:	00 00       	add	r0,r0
80004a08:	80 00       	ld.sh	r0,r0[0x0]
80004a0a:	dd d8       	*unknown*
80004a0c:	80 00       	ld.sh	r0,r0[0x0]
80004a0e:	dd f0       	acall	0xdf
80004a10:	80 00       	ld.sh	r0,r0[0x0]
80004a12:	5a 64       	cp.w	r4,-26
80004a14:	80 00       	ld.sh	r0,r0[0x0]
80004a16:	5a 94       	cp.w	r4,-23
80004a18:	80 00       	ld.sh	r0,r0[0x0]
80004a1a:	5a ac       	cp.w	r12,-22
80004a1c:	00 00       	add	r0,r0
80004a1e:	20 8c       	sub	r12,8
80004a20:	80 00       	ld.sh	r0,r0[0x0]
80004a22:	5d 64       	*unknown*
80004a24:	80 00       	ld.sh	r0,r0[0x0]
80004a26:	5d 9c       	*unknown*
80004a28:	80 00       	ld.sh	r0,r0[0x0]
80004a2a:	5d c8       	*unknown*
80004a2c:	80 00       	ld.sh	r0,r0[0x0]
80004a2e:	5e 0c       	reteq	r12
80004a30:	00 00       	add	r0,r0
80004a32:	0b 6c       	ld.uh	r12,--r5
80004a34:	80 00       	ld.sh	r0,r0[0x0]
80004a36:	46 f8       	lddsp	r8,sp[0x1bc]
80004a38:	80 00       	ld.sh	r0,r0[0x0]
80004a3a:	47 d0       	lddsp	r0,sp[0x1f4]
80004a3c:	80 00       	ld.sh	r0,r0[0x0]
80004a3e:	48 fc       	lddpc	r12,80004a78 <PcdComMF522+0x2c>
80004a40:	80 00       	ld.sh	r0,r0[0x0]
80004a42:	50 88       	stdsp	sp[0x20],r8
80004a44:	80 00       	ld.sh	r0,r0[0x0]
80004a46:	48 b4       	lddpc	r4,80004a70 <PcdComMF522+0x24>
80004a48:	80 00       	ld.sh	r0,r0[0x0]
80004a4a:	49 0c       	lddpc	r12,80004a88 <PcdComMF522+0x3c>

80004a4c <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004a4c:	d4 31       	pushm	r0-r7,lr
80004a4e:	20 1d       	sub	sp,4
80004a50:	18 92       	mov	r2,r12
80004a52:	16 95       	mov	r5,r11
80004a54:	14 96       	mov	r6,r10
80004a56:	50 09       	stdsp	sp[0x0],r9
80004a58:	10 90       	mov	r0,r8
80004a5a:	f8 c8 00 0c 	sub	r8,r12,12
80004a5e:	5c 58       	castu.b	r8
80004a60:	30 29       	mov	r9,2
80004a62:	f2 08 18 00 	cp.b	r8,r9
80004a66:	e0 88 00 05 	brls	80004a70 <PcdComMF522+0x24>
80004a6a:	30 03       	mov	r3,0
80004a6c:	06 91       	mov	r1,r3
80004a6e:	c0 78       	rjmp	80004a7c <PcdComMF522+0x30>
80004a70:	4c f9       	lddpc	r9,80004bac <PcdComMF522+0x160>
80004a72:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004a76:	4c f9       	lddpc	r9,80004bb0 <PcdComMF522+0x164>
80004a78:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004a7c:	02 9b       	mov	r11,r1
80004a7e:	a7 bb       	sbr	r11,0x7
80004a80:	30 2c       	mov	r12,2
80004a82:	f0 1f 00 4d 	mcall	80004bb4 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004a86:	e0 6b 00 80 	mov	r11,128
80004a8a:	30 4c       	mov	r12,4
80004a8c:	f0 1f 00 4b 	mcall	80004bb8 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004a90:	30 0b       	mov	r11,0
80004a92:	30 1c       	mov	r12,1
80004a94:	f0 1f 00 48 	mcall	80004bb4 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004a98:	e0 6b 00 80 	mov	r11,128
80004a9c:	30 ac       	mov	r12,10
80004a9e:	f0 1f 00 48 	mcall	80004bbc <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004aa2:	58 06       	cp.w	r6,0
80004aa4:	c0 c0       	breq	80004abc <PcdComMF522+0x70>
80004aa6:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004aa8:	30 94       	mov	r4,9
80004aaa:	0f 3b       	ld.ub	r11,r7++
80004aac:	08 9c       	mov	r12,r4
80004aae:	f0 1f 00 42 	mcall	80004bb4 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004ab2:	0e 98       	mov	r8,r7
80004ab4:	0a 18       	sub	r8,r5
80004ab6:	ec 08 19 00 	cp.h	r8,r6
80004aba:	cf 83       	brcs	80004aaa <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004abc:	04 9b       	mov	r11,r2
80004abe:	30 1c       	mov	r12,1
80004ac0:	f0 1f 00 3d 	mcall	80004bb4 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004ac4:	30 c8       	mov	r8,12
80004ac6:	f0 02 18 00 	cp.b	r2,r8
80004aca:	c0 61       	brne	80004ad6 <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004acc:	e0 6b 00 80 	mov	r11,128
80004ad0:	30 dc       	mov	r12,13
80004ad2:	f0 1f 00 3b 	mcall	80004bbc <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004ad6:	30 4c       	mov	r12,4
80004ad8:	f0 1f 00 3a 	mcall	80004bc0 <PcdComMF522+0x174>
80004adc:	18 97       	mov	r7,r12
80004ade:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004ae2:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004ae4:	30 44       	mov	r4,4
80004ae6:	c0 88       	rjmp	80004af6 <PcdComMF522+0xaa>
80004ae8:	08 9c       	mov	r12,r4
80004aea:	f0 1f 00 36 	mcall	80004bc0 <PcdComMF522+0x174>
80004aee:	18 97       	mov	r7,r12
		i--;
80004af0:	20 16       	sub	r6,1
80004af2:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004af4:	c0 a0       	breq	80004b08 <PcdComMF522+0xbc>
80004af6:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004afa:	c4 c1       	brne	80004b92 <PcdComMF522+0x146>
80004afc:	ef e3 00 08 	and	r8,r7,r3
80004b00:	ea 08 18 00 	cp.b	r8,r5
80004b04:	cf 20       	breq	80004ae8 <PcdComMF522+0x9c>
80004b06:	c4 68       	rjmp	80004b92 <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004b08:	e0 6b 00 80 	mov	r11,128
80004b0c:	30 dc       	mov	r12,13
80004b0e:	f0 1f 00 2b 	mcall	80004bb8 <PcdComMF522+0x16c>
80004b12:	30 27       	mov	r7,2
80004b14:	c3 38       	rjmp	80004b7a <PcdComMF522+0x12e>
80004b16:	02 67       	and	r7,r1
80004b18:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004b1c:	30 c8       	mov	r8,12
80004b1e:	f0 02 18 00 	cp.b	r2,r8
80004b22:	c2 c1       	brne	80004b7a <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004b24:	30 ac       	mov	r12,10
80004b26:	f0 1f 00 27 	mcall	80004bc0 <PcdComMF522+0x174>
80004b2a:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004b2c:	30 cc       	mov	r12,12
80004b2e:	f0 1f 00 25 	mcall	80004bc0 <PcdComMF522+0x174>
80004b32:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004b36:	c0 70       	breq	80004b44 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004b38:	08 98       	mov	r8,r4
80004b3a:	20 18       	sub	r8,1
80004b3c:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004b40:	a0 8c       	st.b	r0[0x0],r12
80004b42:	c0 48       	rjmp	80004b4a <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004b44:	e8 08 15 03 	lsl	r8,r4,0x3
80004b48:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004b4a:	58 04       	cp.w	r4,0
80004b4c:	c0 61       	brne	80004b58 <PcdComMF522+0x10c>
80004b4e:	30 14       	mov	r4,1
80004b50:	40 05       	lddsp	r5,sp[0x0]
80004b52:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004b54:	30 93       	mov	r3,9
80004b56:	c0 98       	rjmp	80004b68 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004b58:	31 28       	mov	r8,18
80004b5a:	f0 04 18 00 	cp.b	r4,r8
80004b5e:	f9 b4 0b 12 	movhi	r4,18
80004b62:	58 04       	cp.w	r4,0
80004b64:	cf 61       	brne	80004b50 <PcdComMF522+0x104>
80004b66:	c0 a8       	rjmp	80004b7a <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004b68:	06 9c       	mov	r12,r3
80004b6a:	f0 1f 00 16 	mcall	80004bc0 <PcdComMF522+0x174>
80004b6e:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004b70:	ec 05 01 08 	sub	r8,r6,r5
80004b74:	e8 08 19 00 	cp.h	r8,r4
80004b78:	cf 83       	brcs	80004b68 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004b7a:	e0 6b 00 80 	mov	r11,128
80004b7e:	30 cc       	mov	r12,12
80004b80:	f0 1f 00 0f 	mcall	80004bbc <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004b84:	30 0b       	mov	r11,0
80004b86:	30 1c       	mov	r12,1
80004b88:	f0 1f 00 0b 	mcall	80004bb4 <PcdComMF522+0x168>
	return status;
}
80004b8c:	0e 9c       	mov	r12,r7
80004b8e:	2f fd       	sub	sp,-4
80004b90:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004b92:	e0 6b 00 80 	mov	r11,128
80004b96:	30 dc       	mov	r12,13
80004b98:	f0 1f 00 08 	mcall	80004bb8 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004b9c:	30 6c       	mov	r12,6
80004b9e:	f0 1f 00 09 	mcall	80004bc0 <PcdComMF522+0x174>
80004ba2:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004ba6:	cb 80       	breq	80004b16 <PcdComMF522+0xca>
80004ba8:	30 27       	mov	r7,2
80004baa:	ce 8b       	rjmp	80004b7a <PcdComMF522+0x12e>
80004bac:	80 00       	ld.sh	r0,r0[0x0]
80004bae:	dd e8       	*unknown*
80004bb0:	80 00       	ld.sh	r0,r0[0x0]
80004bb2:	dd ec       	*unknown*
80004bb4:	80 00       	ld.sh	r0,r0[0x0]
80004bb6:	47 98       	lddsp	r8,sp[0x1e4]
80004bb8:	80 00       	ld.sh	r0,r0[0x0]
80004bba:	48 d4       	lddpc	r4,80004bec <PcdAnticoll+0x28>
80004bbc:	80 00       	ld.sh	r0,r0[0x0]
80004bbe:	48 90       	lddpc	r0,80004be0 <PcdAnticoll+0x1c>
80004bc0:	80 00       	ld.sh	r0,r0[0x0]
80004bc2:	48 50       	lddpc	r0,80004bd4 <PcdAnticoll+0x10>

80004bc4 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004bc4:	eb cd 40 c0 	pushm	r6-r7,lr
80004bc8:	20 5d       	sub	sp,20
80004bca:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004bcc:	30 8b       	mov	r11,8
80004bce:	16 9c       	mov	r12,r11
80004bd0:	f0 1f 00 1a 	mcall	80004c38 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004bd4:	30 0b       	mov	r11,0
80004bd6:	30 dc       	mov	r12,13
80004bd8:	f0 1f 00 19 	mcall	80004c3c <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004bdc:	e0 6b 00 80 	mov	r11,128
80004be0:	30 ec       	mov	r12,14
80004be2:	f0 1f 00 16 	mcall	80004c38 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004be6:	39 38       	mov	r8,-109
80004be8:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004bea:	32 08       	mov	r8,32
80004bec:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004bee:	1a 9b       	mov	r11,sp
80004bf0:	fa c8 ff ed 	sub	r8,sp,-19
80004bf4:	1a 99       	mov	r9,sp
80004bf6:	30 2a       	mov	r10,2
80004bf8:	30 cc       	mov	r12,12
80004bfa:	f0 1f 00 12 	mcall	80004c40 <PcdAnticoll+0x7c>
80004bfe:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004c00:	c1 21       	brne	80004c24 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004c02:	1b 89       	ld.ub	r9,sp[0x0]
80004c04:	ac 89       	st.b	r6[0x0],r9
80004c06:	1b 98       	ld.ub	r8,sp[0x1]
80004c08:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004c0a:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004c0c:	1b a8       	ld.ub	r8,sp[0x2]
80004c0e:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004c10:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004c14:	1b b9       	ld.ub	r9,sp[0x3]
80004c16:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004c18:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004c1a:	1b c9       	ld.ub	r9,sp[0x4]
80004c1c:	f0 09 18 00 	cp.b	r9,r8
80004c20:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004c24:	e0 6b 00 80 	mov	r11,128
80004c28:	30 ec       	mov	r12,14
80004c2a:	f0 1f 00 07 	mcall	80004c44 <PcdAnticoll+0x80>
	return status;
}
80004c2e:	0e 9c       	mov	r12,r7
80004c30:	2f bd       	sub	sp,-20
80004c32:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c36:	00 00       	add	r0,r0
80004c38:	80 00       	ld.sh	r0,r0[0x0]
80004c3a:	48 d4       	lddpc	r4,80004c6c <PcdRequest+0x24>
80004c3c:	80 00       	ld.sh	r0,r0[0x0]
80004c3e:	47 98       	lddsp	r8,sp[0x1e4]
80004c40:	80 00       	ld.sh	r0,r0[0x0]
80004c42:	4a 4c       	lddpc	r12,80004cd0 <CalulateCRC+0x24>
80004c44:	80 00       	ld.sh	r0,r0[0x0]
80004c46:	48 90       	lddpc	r0,80004c68 <PcdRequest+0x20>

80004c48 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004c48:	eb cd 40 c0 	pushm	r6-r7,lr
80004c4c:	20 5d       	sub	sp,20
80004c4e:	18 97       	mov	r7,r12
80004c50:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004c52:	30 8b       	mov	r11,8
80004c54:	16 9c       	mov	r12,r11
80004c56:	f0 1f 00 12 	mcall	80004c9c <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004c5a:	30 7b       	mov	r11,7
80004c5c:	30 dc       	mov	r12,13
80004c5e:	f0 1f 00 11 	mcall	80004ca0 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004c62:	30 3b       	mov	r11,3
80004c64:	31 4c       	mov	r12,20
80004c66:	f0 1f 00 10 	mcall	80004ca4 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004c6a:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004c6c:	1a 9b       	mov	r11,sp
80004c6e:	fa c8 ff ed 	sub	r8,sp,-19
80004c72:	1a 99       	mov	r9,sp
80004c74:	30 1a       	mov	r10,1
80004c76:	30 cc       	mov	r12,12
80004c78:	f0 1f 00 0c 	mcall	80004ca8 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004c7c:	c0 c1       	brne	80004c94 <PcdRequest+0x4c>
80004c7e:	31 08       	mov	r8,16
80004c80:	fb 39 00 13 	ld.ub	r9,sp[19]
80004c84:	f0 09 18 00 	cp.b	r9,r8
80004c88:	c0 61       	brne	80004c94 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004c8a:	1b 88       	ld.ub	r8,sp[0x0]
80004c8c:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004c8e:	1b 98       	ld.ub	r8,sp[0x1]
80004c90:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004c92:	c0 28       	rjmp	80004c96 <PcdRequest+0x4e>
80004c94:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004c96:	2f bd       	sub	sp,-20
80004c98:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c9c:	80 00       	ld.sh	r0,r0[0x0]
80004c9e:	48 d4       	lddpc	r4,80004cd0 <CalulateCRC+0x24>
80004ca0:	80 00       	ld.sh	r0,r0[0x0]
80004ca2:	47 98       	lddsp	r8,sp[0x1e4]
80004ca4:	80 00       	ld.sh	r0,r0[0x0]
80004ca6:	48 90       	lddpc	r0,80004cc8 <CalulateCRC+0x1c>
80004ca8:	80 00       	ld.sh	r0,r0[0x0]
80004caa:	4a 4c       	lddpc	r12,80004d38 <PcdSelect>

80004cac <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004cac:	eb cd 40 f8 	pushm	r3-r7,lr
80004cb0:	18 95       	mov	r5,r12
80004cb2:	16 96       	mov	r6,r11
80004cb4:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004cb6:	30 4b       	mov	r11,4
80004cb8:	30 5c       	mov	r12,5
80004cba:	f0 1f 00 1c 	mcall	80004d28 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004cbe:	30 0b       	mov	r11,0
80004cc0:	30 1c       	mov	r12,1
80004cc2:	f0 1f 00 1b 	mcall	80004d2c <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004cc6:	e0 6b 00 80 	mov	r11,128
80004cca:	30 ac       	mov	r12,10
80004ccc:	f0 1f 00 19 	mcall	80004d30 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004cd0:	58 06       	cp.w	r6,0
80004cd2:	c0 c0       	breq	80004cea <CalulateCRC+0x3e>
80004cd4:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004cd6:	30 94       	mov	r4,9
80004cd8:	0f 3b       	ld.ub	r11,r7++
80004cda:	08 9c       	mov	r12,r4
80004cdc:	f0 1f 00 14 	mcall	80004d2c <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004ce0:	0e 98       	mov	r8,r7
80004ce2:	0a 18       	sub	r8,r5
80004ce4:	ec 08 18 00 	cp.b	r8,r6
80004ce8:	cf 83       	brcs	80004cd8 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004cea:	30 3b       	mov	r11,3
80004cec:	30 1c       	mov	r12,1
80004cee:	f0 1f 00 10 	mcall	80004d2c <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004cf2:	30 5c       	mov	r12,5
80004cf4:	f0 1f 00 10 	mcall	80004d34 <CalulateCRC+0x88>
80004cf8:	e0 67 00 fe 	mov	r7,254
80004cfc:	30 56       	mov	r6,5
80004cfe:	c0 78       	rjmp	80004d0c <CalulateCRC+0x60>
80004d00:	0c 9c       	mov	r12,r6
80004d02:	f0 1f 00 0d 	mcall	80004d34 <CalulateCRC+0x88>
		i--;
80004d06:	20 17       	sub	r7,1
80004d08:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004d0a:	c0 40       	breq	80004d12 <CalulateCRC+0x66>
80004d0c:	e2 1c 00 04 	andl	r12,0x4,COH
80004d10:	cf 80       	breq	80004d00 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004d12:	32 2c       	mov	r12,34
80004d14:	f0 1f 00 08 	mcall	80004d34 <CalulateCRC+0x88>
80004d18:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004d1a:	32 1c       	mov	r12,33
80004d1c:	f0 1f 00 06 	mcall	80004d34 <CalulateCRC+0x88>
80004d20:	a6 9c       	st.b	r3[0x1],r12
}
80004d22:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004d26:	00 00       	add	r0,r0
80004d28:	80 00       	ld.sh	r0,r0[0x0]
80004d2a:	48 d4       	lddpc	r4,80004d5c <PcdSelect+0x24>
80004d2c:	80 00       	ld.sh	r0,r0[0x0]
80004d2e:	47 98       	lddsp	r8,sp[0x1e4]
80004d30:	80 00       	ld.sh	r0,r0[0x0]
80004d32:	48 90       	lddpc	r0,80004d54 <PcdSelect+0x1c>
80004d34:	80 00       	ld.sh	r0,r0[0x0]
80004d36:	48 50       	lddpc	r0,80004d48 <PcdSelect+0x10>

80004d38 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004d38:	eb cd 40 80 	pushm	r7,lr
80004d3c:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004d3e:	39 38       	mov	r8,-109
80004d40:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004d42:	37 08       	mov	r8,112
80004d44:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004d46:	30 08       	mov	r8,0
80004d48:	ba e8       	st.b	sp[0x6],r8
80004d4a:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004d4e:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004d52:	19 89       	ld.ub	r9,r12[0x0]
80004d54:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004d56:	19 3a       	ld.ub	r10,r12++
80004d58:	1b e9       	ld.ub	r9,sp[0x6]
80004d5a:	f5 e9 20 09 	eor	r9,r10,r9
80004d5e:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004d60:	16 38       	cp.w	r8,r11
80004d62:	cf 81       	brne	80004d52 <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004d64:	1a 97       	mov	r7,sp
80004d66:	fa ca ff f9 	sub	r10,sp,-7
80004d6a:	30 7b       	mov	r11,7
80004d6c:	1a 9c       	mov	r12,sp
80004d6e:	f0 1f 00 0d 	mcall	80004da0 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004d72:	30 8b       	mov	r11,8
80004d74:	16 9c       	mov	r12,r11
80004d76:	f0 1f 00 0c 	mcall	80004da4 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004d7a:	fa c8 ff ed 	sub	r8,sp,-19
80004d7e:	1a 99       	mov	r9,sp
80004d80:	30 9a       	mov	r10,9
80004d82:	1a 9b       	mov	r11,sp
80004d84:	30 cc       	mov	r12,12
80004d86:	f0 1f 00 09 	mcall	80004da8 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80004d8a:	c0 71       	brne	80004d98 <PcdSelect+0x60>
80004d8c:	31 88       	mov	r8,24
80004d8e:	fb 39 00 13 	ld.ub	r9,sp[19]
80004d92:	f0 09 18 00 	cp.b	r9,r8
80004d96:	c0 20       	breq	80004d9a <PcdSelect+0x62>
80004d98:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80004d9a:	2f bd       	sub	sp,-20
80004d9c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004da0:	80 00       	ld.sh	r0,r0[0x0]
80004da2:	4c ac       	lddpc	r12,80004ec8 <rfid_auto_reader+0x11c>
80004da4:	80 00       	ld.sh	r0,r0[0x0]
80004da6:	48 d4       	lddpc	r4,80004dd8 <rfid_auto_reader+0x2c>
80004da8:	80 00       	ld.sh	r0,r0[0x0]
80004daa:	4a 4c       	lddpc	r12,80004e38 <rfid_auto_reader+0x8c>

80004dac <rfid_auto_reader>:
		
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80004dac:	eb cd 40 c0 	pushm	r6-r7,lr
80004db0:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80004db2:	f0 1f 00 37 	mcall	80004e8c <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80004db6:	4b 7b       	lddpc	r11,80004e90 <rfid_auto_reader+0xe4>
80004db8:	35 2c       	mov	r12,82
80004dba:	f0 1f 00 37 	mcall	80004e94 <rfid_auto_reader+0xe8>
80004dbe:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80004dc0:	c6 31       	brne	80004e86 <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004dc2:	4b 48       	lddpc	r8,80004e90 <rfid_auto_reader+0xe4>
80004dc4:	11 88       	ld.ub	r8,r8[0x0]
80004dc6:	30 49       	mov	r9,4
80004dc8:	f2 08 18 00 	cp.b	r8,r9
80004dcc:	c0 b1       	brne	80004de2 <rfid_auto_reader+0x36>
80004dce:	4b 19       	lddpc	r9,80004e90 <rfid_auto_reader+0xe4>
80004dd0:	13 9a       	ld.ub	r10,r9[0x1]
80004dd2:	30 09       	mov	r9,0
80004dd4:	f2 0a 18 00 	cp.b	r10,r9
80004dd8:	c0 51       	brne	80004de2 <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
80004dda:	4b 0c       	lddpc	r12,80004e98 <rfid_auto_reader+0xec>
80004ddc:	f0 1f 00 30 	mcall	80004e9c <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004de0:	c3 c8       	rjmp	80004e58 <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004de2:	30 29       	mov	r9,2
80004de4:	f2 08 18 00 	cp.b	r8,r9
80004de8:	c0 b1       	brne	80004dfe <rfid_auto_reader+0x52>
80004dea:	4a a9       	lddpc	r9,80004e90 <rfid_auto_reader+0xe4>
80004dec:	13 9a       	ld.ub	r10,r9[0x1]
80004dee:	30 09       	mov	r9,0
80004df0:	f2 0a 18 00 	cp.b	r10,r9
80004df4:	c0 51       	brne	80004dfe <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80004df6:	4a bc       	lddpc	r12,80004ea0 <rfid_auto_reader+0xf4>
80004df8:	f0 1f 00 29 	mcall	80004e9c <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004dfc:	c2 e8       	rjmp	80004e58 <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004dfe:	34 49       	mov	r9,68
80004e00:	f2 08 18 00 	cp.b	r8,r9
80004e04:	c0 b1       	brne	80004e1a <rfid_auto_reader+0x6e>
80004e06:	4a 39       	lddpc	r9,80004e90 <rfid_auto_reader+0xe4>
80004e08:	13 9a       	ld.ub	r10,r9[0x1]
80004e0a:	30 09       	mov	r9,0
80004e0c:	f2 0a 18 00 	cp.b	r10,r9
80004e10:	c0 51       	brne	80004e1a <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80004e12:	4a 5c       	lddpc	r12,80004ea4 <rfid_auto_reader+0xf8>
80004e14:	f0 1f 00 22 	mcall	80004e9c <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004e18:	c2 08       	rjmp	80004e58 <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004e1a:	30 89       	mov	r9,8
80004e1c:	f2 08 18 00 	cp.b	r8,r9
80004e20:	c0 b1       	brne	80004e36 <rfid_auto_reader+0x8a>
80004e22:	49 c9       	lddpc	r9,80004e90 <rfid_auto_reader+0xe4>
80004e24:	13 9a       	ld.ub	r10,r9[0x1]
80004e26:	30 09       	mov	r9,0
80004e28:	f2 0a 18 00 	cp.b	r10,r9
80004e2c:	c0 51       	brne	80004e36 <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80004e2e:	49 fc       	lddpc	r12,80004ea8 <rfid_auto_reader+0xfc>
80004e30:	f0 1f 00 1b 	mcall	80004e9c <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004e34:	c1 28       	rjmp	80004e58 <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004e36:	34 49       	mov	r9,68
80004e38:	f2 08 18 00 	cp.b	r8,r9
80004e3c:	c0 b1       	brne	80004e52 <rfid_auto_reader+0xa6>
80004e3e:	49 58       	lddpc	r8,80004e90 <rfid_auto_reader+0xe4>
80004e40:	11 99       	ld.ub	r9,r8[0x1]
80004e42:	30 38       	mov	r8,3
80004e44:	f0 09 18 00 	cp.b	r9,r8
80004e48:	c0 51       	brne	80004e52 <rfid_auto_reader+0xa6>
		log("MF Desire\n");
80004e4a:	49 9c       	lddpc	r12,80004eac <rfid_auto_reader+0x100>
80004e4c:	f0 1f 00 14 	mcall	80004e9c <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004e50:	c0 48       	rjmp	80004e58 <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80004e52:	49 8c       	lddpc	r12,80004eb0 <rfid_auto_reader+0x104>
80004e54:	f0 1f 00 12 	mcall	80004e9c <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80004e58:	49 7c       	lddpc	r12,80004eb4 <rfid_auto_reader+0x108>
80004e5a:	f0 1f 00 18 	mcall	80004eb8 <rfid_auto_reader+0x10c>
80004e5e:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80004e60:	c0 60       	breq	80004e6c <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
80004e62:	37 8b       	mov	r11,120
80004e64:	30 1c       	mov	r12,1
80004e66:	f0 1f 00 16 	mcall	80004ebc <rfid_auto_reader+0x110>
		return status;
80004e6a:	c0 e8       	rjmp	80004e86 <rfid_auto_reader+0xda>
	}
	//continue;
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80004e6c:	49 2c       	lddpc	r12,80004eb4 <rfid_auto_reader+0x108>
80004e6e:	f0 1f 00 15 	mcall	80004ec0 <rfid_auto_reader+0x114>
80004e72:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80004e74:	c0 91       	brne	80004e86 <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80004e76:	30 4a       	mov	r10,4
80004e78:	48 fb       	lddpc	r11,80004eb4 <rfid_auto_reader+0x108>
80004e7a:	0c 9c       	mov	r12,r6
80004e7c:	f0 1f 00 12 	mcall	80004ec4 <rfid_auto_reader+0x118>
		log("select okay\n");
80004e80:	49 2c       	lddpc	r12,80004ec8 <rfid_auto_reader+0x11c>
80004e82:	f0 1f 00 07 	mcall	80004e9c <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
80004e86:	0e 9c       	mov	r12,r7
80004e88:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004e8c:	80 00       	ld.sh	r0,r0[0x0]
80004e8e:	47 d0       	lddsp	r0,sp[0x1f4]
80004e90:	00 00       	add	r0,r0
80004e92:	54 14       	stdsp	sp[0x104],r4
80004e94:	80 00       	ld.sh	r0,r0[0x0]
80004e96:	4c 48       	lddpc	r8,80004fa4 <rfid_sendID_message+0xd8>
80004e98:	80 00       	ld.sh	r0,r0[0x0]
80004e9a:	de 10       	acall	0xe1
80004e9c:	80 00       	ld.sh	r0,r0[0x0]
80004e9e:	76 80       	ld.w	r0,r11[0x20]
80004ea0:	80 00       	ld.sh	r0,r0[0x0]
80004ea2:	de 1c       	*unknown*
80004ea4:	80 00       	ld.sh	r0,r0[0x0]
80004ea6:	de 28       	*unknown*
80004ea8:	80 00       	ld.sh	r0,r0[0x0]
80004eaa:	de 38       	*unknown*
80004eac:	80 00       	ld.sh	r0,r0[0x0]
80004eae:	de 40       	acall	0xe4
80004eb0:	80 00       	ld.sh	r0,r0[0x0]
80004eb2:	de 4c       	*unknown*
80004eb4:	00 00       	add	r0,r0
80004eb6:	54 18       	stdsp	sp[0x104],r8
80004eb8:	80 00       	ld.sh	r0,r0[0x0]
80004eba:	4b c4       	lddpc	r4,80004fa8 <rfid_sendID_message+0xdc>
80004ebc:	80 00       	ld.sh	r0,r0[0x0]
80004ebe:	3e f8       	mov	r8,-17
80004ec0:	80 00       	ld.sh	r0,r0[0x0]
80004ec2:	4d 38       	lddpc	r8,8000500c <rfid_sendID_message+0x140>
80004ec4:	80 00       	ld.sh	r0,r0[0x0]
80004ec6:	7f 22       	ld.w	r2,pc[0x48]
80004ec8:	80 00       	ld.sh	r0,r0[0x0]
80004eca:	de 58       	*unknown*

80004ecc <rfid_sendID_message>:

extern volatile DateTime_t Current_time;
U8 rfid_sendID_message()
{
80004ecc:	eb cd 40 e0 	pushm	r5-r7,lr
80004ed0:	21 fd       	sub	sp,124
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	//memset(data_buffer, 0x00, 16);
	memset(SN, 0x00, 10);
80004ed2:	fa cc ff 90 	sub	r12,sp,-112
80004ed6:	30 08       	mov	r8,0
80004ed8:	30 09       	mov	r9,0
80004eda:	f8 e9 00 00 	st.d	r12[0],r8
80004ede:	30 0a       	mov	r10,0
80004ee0:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80004ee2:	fa e9 00 20 	st.d	sp[32],r8
80004ee6:	fa e9 00 28 	st.d	sp[40],r8
80004eea:	fa e9 00 30 	st.d	sp[48],r8
80004eee:	fa e9 00 38 	st.d	sp[56],r8
80004ef2:	fa e9 00 40 	st.d	sp[64],r8
80004ef6:	fa e9 00 48 	st.d	sp[72],r8
80004efa:	fa e9 00 50 	st.d	sp[80],r8
80004efe:	fa e9 00 58 	st.d	sp[88],r8
80004f02:	fa e9 00 60 	st.d	sp[96],r8
80004f06:	fa e9 00 68 	st.d	sp[104],r8

	return_err = rfid_auto_reader(SN);
80004f0a:	f0 1f 00 43 	mcall	80005014 <rfid_sendID_message+0x148>
80004f0e:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80004f10:	c7 61       	brne	80004ffc <rfid_sendID_message+0x130>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80004f12:	fb 38 00 73 	ld.ub	r8,sp[115]
80004f16:	1a d8       	st.w	--sp,r8
80004f18:	fb 38 00 76 	ld.ub	r8,sp[118]
80004f1c:	1a d8       	st.w	--sp,r8
80004f1e:	fb 38 00 79 	ld.ub	r8,sp[121]
80004f22:	1a d8       	st.w	--sp,r8
80004f24:	fb 38 00 7c 	ld.ub	r8,sp[124]
80004f28:	1a d8       	st.w	--sp,r8
80004f2a:	4b cc       	lddpc	r12,80005018 <rfid_sendID_message+0x14c>
80004f2c:	f0 1f 00 3c 	mcall	8000501c <rfid_sendID_message+0x150>
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
80004f30:	37 7b       	mov	r11,119
80004f32:	30 1c       	mov	r12,1
80004f34:	f0 1f 00 3b 	mcall	80005020 <rfid_sendID_message+0x154>
80004f38:	fa c9 ff 80 	sub	r9,sp,-128
80004f3c:	fa c8 ff f0 	sub	r8,sp,-16
80004f40:	fa ca ff ee 	sub	r10,sp,-18
//}
	
}

extern volatile DateTime_t Current_time;
U8 rfid_sendID_message()
80004f44:	fa c5 ff 7c 	sub	r5,sp,-132
80004f48:	10 9d       	mov	sp,r8
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80004f4a:	30 9e       	mov	lr,9
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80004f4c:	30 06       	mov	r6,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80004f4e:	13 8b       	ld.ub	r11,r9[0x0]
80004f50:	f6 0c 16 04 	lsr	r12,r11,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80004f54:	fc 0c 18 00 	cp.b	r12,lr
80004f58:	f7 bc 08 d0 	subls	r12,-48
80004f5c:	f1 fc 8e 00 	st.bls	r8[0x0],r12
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
80004f60:	f7 bc 0b a9 	subhi	r12,-87
80004f64:	f1 fc be 00 	st.bhi	r8[0x0],r12
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80004f68:	b0 96       	st.b	r8[0x1],r6
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
80004f6a:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
80004f6e:	fc 0b 18 00 	cp.b	r11,lr
80004f72:	f7 bb 08 d0 	subls	r11,-48
80004f76:	f5 fb 8e 00 	st.bls	r10[0x0],r11
			 else
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
80004f7a:	f7 bb 0b a9 	subhi	r11,-87
80004f7e:	f5 fb be 00 	st.bhi	r10[0x0],r11

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
80004f82:	b0 b6       	st.b	r8[0x3],r6
80004f84:	2f f9       	sub	r9,-1
80004f86:	2f c8       	sub	r8,-4
80004f88:	2f ca       	sub	r10,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
80004f8a:	0a 39       	cp.w	r9,r5
80004f8c:	ce 11       	brne	80004f4e <rfid_sendID_message+0x82>
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
		}
		
		memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
80004f8e:	30 6a       	mov	r10,6
80004f90:	4a 5b       	lddpc	r11,80005024 <rfid_sendID_message+0x158>
80004f92:	fa cc ff f0 	sub	r12,sp,-16
80004f96:	f0 1f 00 25 	mcall	80005028 <rfid_sendID_message+0x15c>
	
		header.length = (0x0008 + sizeof(Message_Data_t));
	
		if(start_session > 0x9f)start_session = 0x80;
80004f9a:	4a 58       	lddpc	r8,8000502c <rfid_sendID_message+0x160>
80004f9c:	11 89       	ld.ub	r9,r8[0x0]
80004f9e:	39 f8       	mov	r8,-97
80004fa0:	f0 09 18 00 	cp.b	r9,r8
80004fa4:	e0 88 00 05 	brls	80004fae <rfid_sendID_message+0xe2>
80004fa8:	38 09       	mov	r9,-128
80004faa:	4a 18       	lddpc	r8,8000502c <rfid_sendID_message+0x160>
80004fac:	b0 89       	st.b	r8[0x0],r9
	
		header.session_id = (++start_session);
80004fae:	4a 08       	lddpc	r8,8000502c <rfid_sendID_message+0x160>
80004fb0:	11 86       	ld.ub	r6,r8[0x0]
80004fb2:	2f f6       	sub	r6,-1
80004fb4:	b0 86       	st.b	r8[0x0],r6
	
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
80004fb6:	30 5a       	mov	r10,5
80004fb8:	49 eb       	lddpc	r11,80005030 <rfid_sendID_message+0x164>
80004fba:	fa cc ff e5 	sub	r12,sp,-27
80004fbe:	f0 1f 00 1b 	mcall	80005028 <rfid_sendID_message+0x15c>
		header.type = 0xe000;
	
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
80004fc2:	31 e8       	mov	r8,30
80004fc4:	fb 58 00 16 	st.h	sp[22],r8
80004fc8:	fb 66 00 1a 	st.b	sp[26],r6
80004fcc:	fe 78 e0 00 	mov	r8,-8192
80004fd0:	fb 58 00 18 	st.h	sp[24],r8
80004fd4:	fa c6 ff e0 	sub	r6,sp,-32
80004fd8:	30 aa       	mov	r10,10
80004fda:	fa cb ff ea 	sub	r11,sp,-22
80004fde:	0c 9c       	mov	r12,r6
80004fe0:	f0 1f 00 12 	mcall	80005028 <rfid_sendID_message+0x15c>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
80004fe4:	31 6a       	mov	r10,22
80004fe6:	1a 9b       	mov	r11,sp
80004fe8:	fa cc ff d6 	sub	r12,sp,-42
80004fec:	f0 1f 00 0f 	mcall	80005028 <rfid_sendID_message+0x15c>
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
80004ff0:	30 9a       	mov	r10,9
80004ff2:	32 0b       	mov	r11,32
80004ff4:	0c 9c       	mov	r12,r6
80004ff6:	f0 1f 00 10 	mcall	80005034 <rfid_sendID_message+0x168>
80004ffa:	c0 88       	rjmp	8000500a <rfid_sendID_message+0x13e>
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate scan rfid failure!!!
80004ffc:	37 8b       	mov	r11,120
80004ffe:	30 1c       	mov	r12,1
80005000:	f0 1f 00 08 	mcall	80005020 <rfid_sendID_message+0x154>
		log("no card find...\n");
80005004:	48 dc       	lddpc	r12,80005038 <rfid_sendID_message+0x16c>
80005006:	f0 1f 00 06 	mcall	8000501c <rfid_sendID_message+0x150>
	}
	
	return return_err;
	
}
8000500a:	0e 9c       	mov	r12,r7
8000500c:	2e 1d       	sub	sp,-124
8000500e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005012:	00 00       	add	r0,r0
80005014:	80 00       	ld.sh	r0,r0[0x0]
80005016:	4d ac       	lddpc	r12,8000517c <create_xg_flash_test_task+0xc>
80005018:	80 00       	ld.sh	r0,r0[0x0]
8000501a:	de 68       	*unknown*
8000501c:	80 00       	ld.sh	r0,r0[0x0]
8000501e:	76 80       	ld.w	r0,r11[0x20]
80005020:	80 00       	ld.sh	r0,r0[0x0]
80005022:	3e f8       	mov	r8,-17
80005024:	00 00       	add	r0,r0
80005026:	0e 04       	add	r4,r7
80005028:	80 00       	ld.sh	r0,r0[0x0]
8000502a:	7f 22       	ld.w	r2,pc[0x48]
8000502c:	00 00       	add	r0,r0
8000502e:	05 2c       	ld.uh	r12,r2++
80005030:	00 00       	add	r0,r0
80005032:	05 24       	ld.uh	r4,r2++
80005034:	80 00       	ld.sh	r0,r0[0x0]
80005036:	3d c0       	mov	r0,-36
80005038:	80 00       	ld.sh	r0,r0[0x0]
8000503a:	de 84       	*unknown*

8000503c <rfid_init>:
U8 RFID[16];			//瀛RFID
U8 unsure_data[5]={0x04, 0x0d, 0x00, 0x0a, 0x00};


void rfid_init()
{
8000503c:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
8000503e:	f0 1f 00 02 	mcall	80005044 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		
}
80005042:	d8 02       	popm	pc
80005044:	80 00       	ld.sh	r0,r0[0x0]
80005046:	49 7c       	lddpc	r12,800050a0 <delay_ms+0x18>

80005048 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005048:	58 0c       	cp.w	r12,0
8000504a:	5e 0c       	reteq	r12
8000504c:	30 08       	mov	r8,0
	{
		nop();
8000504e:	d7 03       	nop
		nop();
80005050:	d7 03       	nop
		nop();
80005052:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005054:	2f f8       	sub	r8,-1
80005056:	10 3c       	cp.w	r12,r8
80005058:	fe 9b ff fb 	brhi	8000504e <delay_ns+0x6>
8000505c:	5e fc       	retal	r12
8000505e:	d7 03       	nop

80005060 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
80005060:	eb cd 40 e0 	pushm	r5-r7,lr
80005064:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
80005066:	58 0c       	cp.w	r12,0
80005068:	c0 b0       	breq	8000507e <delay_us+0x1e>
8000506a:	30 07       	mov	r7,0
		delay_ns(1000);
8000506c:	e0 65 03 e8 	mov	r5,1000
80005070:	0a 9c       	mov	r12,r5
80005072:	f0 1f 00 05 	mcall	80005084 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
80005076:	2f f7       	sub	r7,-1
80005078:	0e 36       	cp.w	r6,r7
8000507a:	fe 9b ff fb 	brhi	80005070 <delay_us+0x10>
8000507e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005082:	00 00       	add	r0,r0
80005084:	80 00       	ld.sh	r0,r0[0x0]
80005086:	50 48       	stdsp	sp[0x10],r8

80005088 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
80005088:	eb cd 40 e0 	pushm	r5-r7,lr
8000508c:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
8000508e:	58 0c       	cp.w	r12,0
80005090:	c0 b0       	breq	800050a6 <delay_ms+0x1e>
80005092:	30 07       	mov	r7,0
		delay_us(1000);
80005094:	e0 65 03 e8 	mov	r5,1000
80005098:	0a 9c       	mov	r12,r5
8000509a:	f0 1f 00 05 	mcall	800050ac <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
8000509e:	2f f7       	sub	r7,-1
800050a0:	0e 36       	cp.w	r6,r7
800050a2:	fe 9b ff fb 	brhi	80005098 <delay_ms+0x10>
800050a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800050aa:	00 00       	add	r0,r0
800050ac:	80 00       	ld.sh	r0,r0[0x0]
800050ae:	50 60       	stdsp	sp[0x18],r0

800050b0 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
800050b0:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
800050b2:	30 3b       	mov	r11,3
800050b4:	48 8c       	lddpc	r12,800050d4 <local_start_timer+0x24>
800050b6:	f0 1f 00 09 	mcall	800050d8 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
800050ba:	fe 78 38 00 	mov	r8,-51200
800050be:	e0 69 91 0d 	mov	r9,37133
800050c2:	ea 19 00 52 	orh	r9,0x52
800050c6:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
800050c8:	32 09       	mov	r9,32
800050ca:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800050cc:	30 59       	mov	r9,5
800050ce:	91 09       	st.w	r8[0x0],r9
}
800050d0:	d8 02       	popm	pc
800050d2:	00 00       	add	r0,r0
800050d4:	80 00       	ld.sh	r0,r0[0x0]
800050d6:	de 98       	*unknown*
800050d8:	80 00       	ld.sh	r0,r0[0x0]
800050da:	5a 64       	cp.w	r4,-26

800050dc <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
800050dc:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
800050de:	30 3a       	mov	r10,3
800050e0:	e0 6b 1b 00 	mov	r11,6912
800050e4:	ea 1b 00 b7 	orh	r11,0xb7
800050e8:	fe 7c 0c 00 	mov	r12,-62464
800050ec:	f0 1f 00 19 	mcall	80005150 <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
800050f0:	31 08       	mov	r8,16
800050f2:	1a d8       	st.w	--sp,r8
800050f4:	30 08       	mov	r8,0
800050f6:	30 19       	mov	r9,1
800050f8:	30 7a       	mov	r10,7
800050fa:	10 9b       	mov	r11,r8
800050fc:	fe 7c 0c 00 	mov	r12,-62464
80005100:	f0 1f 00 15 	mcall	80005154 <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
80005104:	30 08       	mov	r8,0
80005106:	30 19       	mov	r9,1
80005108:	12 9a       	mov	r10,r9
8000510a:	10 9b       	mov	r11,r8
8000510c:	fe 7c 0c 00 	mov	r12,-62464
80005110:	f0 1f 00 12 	mcall	80005158 <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
80005114:	30 0b       	mov	r11,0
80005116:	fe 7c 0c 00 	mov	r12,-62464
8000511a:	f0 1f 00 11 	mcall	8000515c <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
8000511e:	fe 7c 0c 00 	mov	r12,-62464
80005122:	f0 1f 00 10 	mcall	80005160 <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
80005126:	30 0a       	mov	r10,0
80005128:	1a da       	st.w	--sp,r10
8000512a:	1a da       	st.w	--sp,r10
8000512c:	14 98       	mov	r8,r10
8000512e:	14 99       	mov	r9,r10
80005130:	30 1b       	mov	r11,1
80005132:	fe 7c 0c 00 	mov	r12,-62464
80005136:	f0 1f 00 0c 	mcall	80005164 <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
8000513a:	30 1c       	mov	r12,1
8000513c:	f0 1f 00 0b 	mcall	80005168 <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
80005140:	30 2b       	mov	r11,2
80005142:	fe 7c 0c 00 	mov	r12,-62464
80005146:	f0 1f 00 0a 	mcall	8000516c <local_start_pll0+0x90>
8000514a:	2f dd       	sub	sp,-12
/****/
}
8000514c:	d8 02       	popm	pc
8000514e:	00 00       	add	r0,r0
80005150:	80 00       	ld.sh	r0,r0[0x0]
80005152:	5d 18       	icall	r8
80005154:	80 00       	ld.sh	r0,r0[0x0]
80005156:	5c ba       	swap.b	r10
80005158:	80 00       	ld.sh	r0,r0[0x0]
8000515a:	5c dc       	com	r12
8000515c:	80 00       	ld.sh	r0,r0[0x0]
8000515e:	5c f6       	rol	r6
80005160:	80 00       	ld.sh	r0,r0[0x0]
80005162:	5d 04       	ror	r4
80005164:	80 00       	ld.sh	r0,r0[0x0]
80005166:	5c 74       	castu.h	r4
80005168:	80 00       	ld.sh	r0,r0[0x0]
8000516a:	55 70       	stdsp	sp[0x15c],r0
8000516c:	80 00       	ld.sh	r0,r0[0x0]
8000516e:	5d 0e       	ror	lr

80005170 <create_xg_flash_test_task>:
	log("data_ptr == NULL,exit runXGFlashTestREAD\n");
	
}

void create_xg_flash_test_task(void)
{
80005170:	eb cd 40 80 	pushm	r7,lr
	
	xTaskCreate(
80005174:	30 09       	mov	r9,0
80005176:	1a d9       	st.w	--sp,r9
80005178:	1a d9       	st.w	--sp,r9
8000517a:	48 87       	lddpc	r7,80005198 <create_xg_flash_test_task+0x28>
8000517c:	1a d7       	st.w	--sp,r7
8000517e:	30 58       	mov	r8,5
80005180:	e0 6a 02 26 	mov	r10,550
80005184:	48 6b       	lddpc	r11,8000519c <create_xg_flash_test_task+0x2c>
80005186:	48 7c       	lddpc	r12,800051a0 <create_xg_flash_test_task+0x30>
80005188:	f0 1f 00 07 	mcall	800051a4 <create_xg_flash_test_task+0x34>
	,  NULL
	,  tskFLASH_PRIORITY+4
	//, NULL);
	,  &save_handle);
	
	vTaskSuspend(save_handle);
8000518c:	6e 0c       	ld.w	r12,r7[0x0]
8000518e:	f0 1f 00 07 	mcall	800051a8 <create_xg_flash_test_task+0x38>
80005192:	2f dd       	sub	sp,-12
	//,  configMINIMAL_STACK_SIZE
	//,  NULL
	//,  tskFLASH_PRIORITY
	//,  NULL );
	//
}
80005194:	e3 cd 80 80 	ldm	sp++,r7,pc
80005198:	00 00       	add	r0,r0
8000519a:	54 20       	stdsp	sp[0x108],r0
8000519c:	80 00       	ld.sh	r0,r0[0x0]
8000519e:	de b8       	*unknown*
800051a0:	80 00       	ld.sh	r0,r0[0x0]
800051a2:	54 c8       	stdsp	sp[0x130],r8
800051a4:	80 00       	ld.sh	r0,r0[0x0]
800051a6:	72 bc       	ld.w	r12,r9[0x2c]
800051a8:	80 00       	ld.sh	r0,r0[0x0]
800051aa:	70 20       	ld.w	r0,r8[0x8]

800051ac <xg_flashc_init>:



//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
800051ac:	d4 31       	pushm	r0-r7,lr
800051ae:	20 2d       	sub	sp,8
	
	/* Create the mutex semaphore to guard a shared xgflash.*/
	xgflash_mutex = xSemaphoreCreateMutex();
800051b0:	f0 1f 00 a7 	mcall	8000544c <xg_flashc_init+0x2a0>
800051b4:	fe f8 02 9c 	ld.w	r8,pc[668]
800051b8:	91 0c       	st.w	r8[0x0],r12
	if (xgflash_mutex == NULL)
800051ba:	70 08       	ld.w	r8,r8[0x0]
800051bc:	58 08       	cp.w	r8,0
800051be:	c0 51       	brne	800051c8 <xg_flashc_init+0x1c>
	{
		log("Create the xgflash_mutex semaphore failure\n");
800051c0:	fe fc 02 94 	ld.w	r12,pc[660]
800051c4:	f0 1f 00 a5 	mcall	80005458 <xg_flashc_init+0x2ac>
	}
	
	/* Create the binary semaphore to Synchronize other threads.*/
	vSemaphoreCreateBinary(xBinarySemaphore);
800051c8:	30 0b       	mov	r11,0
800051ca:	30 1c       	mov	r12,1
800051cc:	f0 1f 00 a4 	mcall	8000545c <xg_flashc_init+0x2b0>
800051d0:	fe f8 02 90 	ld.w	r8,pc[656]
800051d4:	91 0c       	st.w	r8[0x0],r12
800051d6:	70 08       	ld.w	r8,r8[0x0]
800051d8:	58 08       	cp.w	r8,0
800051da:	c0 90       	breq	800051ec <xg_flashc_init+0x40>
800051dc:	fe f8 02 84 	ld.w	r8,pc[644]
800051e0:	70 0c       	ld.w	r12,r8[0x0]
800051e2:	30 09       	mov	r9,0
800051e4:	12 9a       	mov	r10,r9
800051e6:	12 9b       	mov	r11,r9
800051e8:	f0 1f 00 9f 	mcall	80005464 <xg_flashc_init+0x2b8>
	
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
800051ec:	30 4b       	mov	r11,4
800051ee:	31 4c       	mov	r12,20
800051f0:	f0 1f 00 9b 	mcall	8000545c <xg_flashc_init+0x2b0>
800051f4:	fe f8 02 74 	ld.w	r8,pc[628]
800051f8:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
800051fa:	30 4b       	mov	r11,4
800051fc:	31 4c       	mov	r12,20
800051fe:	f0 1f 00 98 	mcall	8000545c <xg_flashc_init+0x2b0>
80005202:	fe f8 02 6a 	ld.w	r8,pc[618]
80005206:	91 0c       	st.w	r8[0x0],r12
80005208:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
8000520a:	10 96       	mov	r6,r8
8000520c:	fe f5 02 64 	ld.w	r5,pc[612]
80005210:	6c 0c       	ld.w	r12,r6[0x0]
80005212:	ea 07 00 0b 	add	r11,r5,r7
80005216:	f0 1f 00 98 	mcall	80005474 <xg_flashc_init+0x2c8>
8000521a:	2e 07       	sub	r7,-32
	
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
8000521c:	e0 47 02 80 	cp.w	r7,640
80005220:	cf 81       	brne	80005210 <xg_flashc_init+0x64>
	
	static U32 current_page_number =0;
	unsigned int i = 0;
	unsigned int address =0x00000000;
	static char str[80];
	memset(str, 0x00, sizeof(str));
80005222:	30 0a       	mov	r10,0
80005224:	30 0b       	mov	r11,0
80005226:	fe f8 02 52 	ld.w	r8,pc[594]
8000522a:	b1 2a       	st.d	r8++,r10
8000522c:	b1 2a       	st.d	r8++,r10
8000522e:	b1 2a       	st.d	r8++,r10
80005230:	b1 2a       	st.d	r8++,r10
80005232:	b1 2a       	st.d	r8++,r10
80005234:	b1 2a       	st.d	r8++,r10
80005236:	b1 2a       	st.d	r8++,r10
80005238:	b1 2a       	st.d	r8++,r10
8000523a:	b1 2a       	st.d	r8++,r10
8000523c:	f0 eb 00 00 	st.d	r8[0],r10
	
start:
	
	 //bytes remained less than one page 
	flashc_memcpy((void *)str, (void *)LABEL_ADDRESS, LABEL_LENGTH,  true);
80005240:	fe f7 02 38 	ld.w	r7,pc[568]
			}
			else
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
					memset(str, 0x00, sizeof(str));	
80005244:	ee c5 ff f8 	sub	r5,r7,-8
80005248:	ea c4 ff f8 	sub	r4,r5,-8
8000524c:	e8 c3 ff f8 	sub	r3,r4,-8
80005250:	e6 c2 ff f8 	sub	r2,r3,-8
80005254:	e4 c1 ff f8 	sub	r1,r2,-8
80005258:	e2 c0 ff f8 	sub	r0,r1,-8
8000525c:	e0 ca ff f8 	sub	r10,r0,-8
80005260:	50 0a       	stdsp	sp[0x0],r10
80005262:	2f 8a       	sub	r10,-8
80005264:	50 1a       	stdsp	sp[0x4],r10
	memset(str, 0x00, sizeof(str));
	
start:
	
	 //bytes remained less than one page 
	flashc_memcpy((void *)str, (void *)LABEL_ADDRESS, LABEL_LENGTH,  true);
80005266:	30 19       	mov	r9,1
80005268:	30 7a       	mov	r10,7
8000526a:	e0 6b b0 00 	mov	r11,45056
8000526e:	ea 1b 80 04 	orh	r11,0x8004
80005272:	0e 9c       	mov	r12,r7
80005274:	f0 1f 00 82 	mcall	8000547c <xg_flashc_init+0x2d0>
	flashc_memcpy((void *)LABEL_ADDRESS, (void *)LABEL_ADDRESS, LABEL_LENGTH,  false);//为了获取当前页号码
80005278:	30 09       	mov	r9,0
8000527a:	30 7a       	mov	r10,7
8000527c:	e0 6b b0 00 	mov	r11,45056
80005280:	ea 1b 80 04 	orh	r11,0x8004
80005284:	16 9c       	mov	r12,r11
80005286:	f0 1f 00 7e 	mcall	8000547c <xg_flashc_init+0x2d0>
	current_page_number = flashc_get_page_number();
8000528a:	f0 1f 00 7e 	mcall	80005480 <xg_flashc_init+0x2d4>
8000528e:	4f e8       	lddpc	r8,80005484 <xg_flashc_init+0x2d8>
80005290:	91 0c       	st.w	r8[0x0],r12
	if (flashc_is_lock_error() || flashc_is_programming_error())
80005292:	f0 1f 00 7e 	mcall	80005488 <xg_flashc_init+0x2dc>
80005296:	e0 81 00 d6 	brne	80005442 <xg_flashc_init+0x296>
8000529a:	f0 1f 00 7d 	mcall	8000548c <xg_flashc_init+0x2e0>
8000529e:	e0 81 00 d2 	brne	80005442 <xg_flashc_init+0x296>
	{
		return XG_FLASH_ACTION_FAIL;
	}
	else
	{
		if(memcmp(XGFlashLabel, str, sizeof(XGFlashLabel)-1) != 0)//compare label
800052a2:	30 7a       	mov	r10,7
800052a4:	0e 9b       	mov	r11,r7
800052a6:	4f bc       	lddpc	r12,80005490 <xg_flashc_init+0x2e4>
800052a8:	f0 1f 00 7b 	mcall	80005494 <xg_flashc_init+0x2e8>
800052ac:	c3 b0       	breq	80005322 <xg_flashc_init+0x176>
800052ae:	cc 08       	rjmp	8000542e <xg_flashc_init+0x282>
			ERASE:
			//erase:160pages		
			//for(i=0; i < ((XG_MESSAGE_DATA_BOUNDARY_ADD - XG_MESSAGE_LISTINFO_START_ADD)/(PageSize)); i++)//80k
			for(i=0; i <25; i++)//擦除太多页程序运行不正常。
			{
				current_page_number+=i;
800052b0:	6c 0c       	ld.w	r12,r6[0x0]
800052b2:	ee 0c 00 0c 	add	r12,r7,r12
800052b6:	8d 0c       	st.w	r6[0x0],r12
				flashc_erase_page(current_page_number, true);
800052b8:	0a 9b       	mov	r11,r5
800052ba:	f0 1f 00 78 	mcall	80005498 <xg_flashc_init+0x2ec>
		if(memcmp(XGFlashLabel, str, sizeof(XGFlashLabel)-1) != 0)//compare label
		{
			ERASE:
			//erase:160pages		
			//for(i=0; i < ((XG_MESSAGE_DATA_BOUNDARY_ADD - XG_MESSAGE_LISTINFO_START_ADD)/(PageSize)); i++)//80k
			for(i=0; i <25; i++)//擦除太多页程序运行不正常。
800052be:	2f f7       	sub	r7,-1
800052c0:	59 97       	cp.w	r7,25
800052c2:	cf 71       	brne	800052b0 <xg_flashc_init+0x104>
			{
				current_page_number+=i;
				flashc_erase_page(current_page_number, true);
			}
			//set label
			flashc_memcpy((void *)LABEL_ADDRESS, (void *)XGFlashLabel, LABEL_LENGTH,  true);
800052c4:	30 19       	mov	r9,1
800052c6:	30 7a       	mov	r10,7
800052c8:	4f 2b       	lddpc	r11,80005490 <xg_flashc_init+0x2e4>
800052ca:	e0 6c b0 00 	mov	r12,45056
800052ce:	ea 1c 80 04 	orh	r12,0x8004
800052d2:	f0 1f 00 6b 	mcall	8000547c <xg_flashc_init+0x2d0>
			
			//set current_voice_index
			memset(str, 0x00, sizeof(str));
800052d6:	4e 9b       	lddpc	r11,80005478 <xg_flashc_init+0x2cc>
800052d8:	30 06       	mov	r6,0
800052da:	30 07       	mov	r7,0
800052dc:	16 98       	mov	r8,r11
800052de:	b1 26       	st.d	r8++,r6
800052e0:	b1 26       	st.d	r8++,r6
800052e2:	b1 26       	st.d	r8++,r6
800052e4:	b1 26       	st.d	r8++,r6
800052e6:	b1 26       	st.d	r8++,r6
800052e8:	b1 26       	st.d	r8++,r6
800052ea:	b1 26       	st.d	r8++,r6
800052ec:	b1 26       	st.d	r8++,r6
800052ee:	b1 26       	st.d	r8++,r6
800052f0:	f0 e7 00 00 	st.d	r8[0],r6
			
			flashc_memcpy((void *)MESSAGE_NUMBERS_ADD, (void *)str, MESSAGE_NUMBERS_LENGTH,  true);
800052f4:	30 19       	mov	r9,1
800052f6:	30 2a       	mov	r10,2
800052f8:	e0 6c b0 07 	mov	r12,45063
800052fc:	ea 1c 80 04 	orh	r12,0x8004
80005300:	f0 1f 00 5f 	mcall	8000547c <xg_flashc_init+0x2d0>
			if (flashc_is_lock_error() || flashc_is_programming_error())
80005304:	f0 1f 00 61 	mcall	80005488 <xg_flashc_init+0x2dc>
80005308:	e0 81 00 9d 	brne	80005442 <xg_flashc_init+0x296>
8000530c:	f0 1f 00 60 	mcall	8000548c <xg_flashc_init+0x2e0>
80005310:	e0 81 00 99 	brne	80005442 <xg_flashc_init+0x296>
			{
				return XG_FLASH_ACTION_FAIL;
			}
			current_message_index = 0;
80005314:	30 09       	mov	r9,0
80005316:	4e 28       	lddpc	r8,8000549c <xg_flashc_init+0x2f0>
80005318:	b0 09       	st.h	r8[0x0],r9
			log("\r\n----create xg message info okay!----\r\n");
8000531a:	4e 2c       	lddpc	r12,800054a0 <xg_flashc_init+0x2f4>
8000531c:	f0 1f 00 4f 	mcall	80005458 <xg_flashc_init+0x2ac>
80005320:	c8 e8       	rjmp	8000543c <xg_flashc_init+0x290>
		}
		else//success
		{
			log("\nLABEL: %s\n", str);
80005322:	1a d7       	st.w	--sp,r7
80005324:	4e 0c       	lddpc	r12,800054a4 <xg_flashc_init+0x2f8>
80005326:	f0 1f 00 4d 	mcall	80005458 <xg_flashc_init+0x2ac>
			//Get the current voice index		
			flashc_memcpy((void *)&current_message_index, (void *)MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH,  false);
8000532a:	30 09       	mov	r9,0
8000532c:	30 2a       	mov	r10,2
8000532e:	e0 6b b0 07 	mov	r11,45063
80005332:	ea 1b 80 04 	orh	r11,0x8004
80005336:	4d ac       	lddpc	r12,8000549c <xg_flashc_init+0x2f0>
80005338:	f0 1f 00 51 	mcall	8000547c <xg_flashc_init+0x2d0>
			if (flashc_is_lock_error() || flashc_is_programming_error())
8000533c:	f0 1f 00 53 	mcall	80005488 <xg_flashc_init+0x2dc>
80005340:	2f fd       	sub	sp,-4
80005342:	58 0c       	cp.w	r12,0
80005344:	e0 81 00 7f 	brne	80005442 <xg_flashc_init+0x296>
80005348:	f0 1f 00 51 	mcall	8000548c <xg_flashc_init+0x2e0>
8000534c:	e0 81 00 7b 	brne	80005442 <xg_flashc_init+0x296>
				return XG_FLASH_ACTION_FAIL;
			}
			else
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
80005350:	4d 38       	lddpc	r8,8000549c <xg_flashc_init+0x2f0>
80005352:	90 09       	ld.sh	r9,r8[0x0]
80005354:	30 08       	mov	r8,0
80005356:	f0 09 19 00 	cp.h	r9,r8
8000535a:	c6 e0       	breq	80005436 <xg_flashc_init+0x28a>
					memset(str, 0x00, sizeof(str));	
8000535c:	30 08       	mov	r8,0
8000535e:	30 09       	mov	r9,0
80005360:	ee e9 00 00 	st.d	r7[0],r8
80005364:	ea e9 00 00 	st.d	r5[0],r8
80005368:	e8 e9 00 00 	st.d	r4[0],r8
8000536c:	e6 e9 00 00 	st.d	r3[0],r8
80005370:	e4 e9 00 00 	st.d	r2[0],r8
80005374:	e2 e9 00 00 	st.d	r1[0],r8
80005378:	e0 e9 00 00 	st.d	r0[0],r8
8000537c:	40 0a       	lddsp	r10,sp[0x0]
8000537e:	f4 e9 00 00 	st.d	r10[0],r8
80005382:	40 1a       	lddsp	r10,sp[0x4]
80005384:	b5 28       	st.d	r10++,r8
80005386:	f4 e9 00 00 	st.d	r10[0],r8
					address = XG_MESSAGE_INFO_HEADER_START_ADD + ((current_message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
					flashc_memcpy((void *)str, (void *)address, XG_MESSAGE_INFO_HEADER_LENGTH,  false);
8000538a:	4c 58       	lddpc	r8,8000549c <xg_flashc_init+0x2f0>
8000538c:	90 8b       	ld.uh	r11,r8[0x0]
8000538e:	20 1b       	sub	r11,1
80005390:	30 09       	mov	r9,0
80005392:	30 8a       	mov	r10,8
80005394:	e0 68 b0 09 	mov	r8,45065
80005398:	ea 18 80 04 	orh	r8,0x8004
8000539c:	f0 0b 00 3b 	add	r11,r8,r11<<0x3
800053a0:	0e 9c       	mov	r12,r7
800053a2:	f0 1f 00 37 	mcall	8000547c <xg_flashc_init+0x2d0>
					if (flashc_is_lock_error() || flashc_is_programming_error())
800053a6:	f0 1f 00 39 	mcall	80005488 <xg_flashc_init+0x2dc>
800053aa:	c0 41       	brne	800053b2 <xg_flashc_init+0x206>
800053ac:	f0 1f 00 38 	mcall	8000548c <xg_flashc_init+0x2e0>
800053b0:	c0 50       	breq	800053ba <xg_flashc_init+0x20e>
					{
						log("\r\n----message storage is err!!!----\r\n");
800053b2:	4b ec       	lddpc	r12,800054a8 <xg_flashc_init+0x2fc>
800053b4:	f0 1f 00 29 	mcall	80005458 <xg_flashc_init+0x2ac>
800053b8:	c3 b8       	rjmp	8000542e <xg_flashc_init+0x282>
						goto ERASE;
					}
					else
					{
						MessageList_Info_t *ptr = (MessageList_Info_t *)str;
						if(ptr->numb == current_message_index)
800053ba:	0f 89       	ld.ub	r9,r7[0x0]
800053bc:	0f 98       	ld.ub	r8,r7[0x1]
800053be:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800053c2:	4b 79       	lddpc	r9,8000549c <xg_flashc_init+0x2f0>
800053c4:	92 09       	ld.sh	r9,r9[0x0]
800053c6:	f0 09 19 00 	cp.h	r9,r8
800053ca:	c2 f1       	brne	80005428 <xg_flashc_init+0x27c>
						{
							current_save_message_offset = ptr->address + ptr->offset;
800053cc:	0f e9       	ld.ub	r9,r7[0x6]
800053ce:	0f f8       	ld.ub	r8,r7[0x7]
800053d0:	f1 e9 10 89 	or	r9,r8,r9<<0x8
800053d4:	0f aa       	ld.ub	r10,r7[0x2]
800053d6:	0f b8       	ld.ub	r8,r7[0x3]
800053d8:	b1 68       	lsl	r8,0x10
800053da:	f1 ea 11 88 	or	r8,r8,r10<<0x18
800053de:	0f ca       	ld.ub	r10,r7[0x4]
800053e0:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800053e4:	0f da       	ld.ub	r10,r7[0x5]
800053e6:	f5 e8 10 08 	or	r8,r10,r8
800053ea:	f2 08 00 08 	add	r8,r9,r8
800053ee:	4b 06       	lddpc	r6,800054ac <xg_flashc_init+0x300>
800053f0:	8d 08       	st.w	r6[0x0],r8
							log("current_save_message_offset : %X\n", current_save_message_offset);
800053f2:	1a d8       	st.w	--sp,r8
800053f4:	4a fc       	lddpc	r12,800054b0 <xg_flashc_init+0x304>
800053f6:	f0 1f 00 19 	mcall	80005458 <xg_flashc_init+0x2ac>
							if(current_save_message_offset > XG_MESSAGE_DATA_BOUNDARY_ADD){
800053fa:	2f fd       	sub	sp,-4
800053fc:	6c 08       	ld.w	r8,r6[0x0]
800053fe:	e0 69 f0 00 	mov	r9,61440
80005402:	ea 19 80 05 	orh	r9,0x8005
80005406:	12 38       	cp.w	r8,r9
80005408:	e0 88 00 17 	brls	80005436 <xg_flashc_init+0x28a>
										
								log("\r\n----message storage is full!!!----\r\n");
8000540c:	4a ac       	lddpc	r12,800054b4 <xg_flashc_init+0x308>
8000540e:	f0 1f 00 13 	mcall	80005458 <xg_flashc_init+0x2ac>
								//xgflash erase
								
								flashc_memset64((void *)LABEL_ADDRESS, (void *)0x00, LABEL_LENGTH,  true);
80005412:	30 18       	mov	r8,1
80005414:	30 79       	mov	r9,7
80005416:	30 0a       	mov	r10,0
80005418:	30 0b       	mov	r11,0
8000541a:	e0 6c b0 00 	mov	r12,45056
8000541e:	ea 1c 80 04 	orh	r12,0x8004
80005422:	f0 1f 00 26 	mcall	800054b8 <xg_flashc_init+0x30c>
80005426:	c2 0b       	rjmp	80005266 <xg_flashc_init+0xba>

							}
						}
						else
						{
							log("\r\n----message storage is err!!!----\r\n");
80005428:	4a 0c       	lddpc	r12,800054a8 <xg_flashc_init+0x2fc>
8000542a:	f0 1f 00 0c 	mcall	80005458 <xg_flashc_init+0x2ac>
8000542e:	30 07       	mov	r7,0
			ERASE:
			//erase:160pages		
			//for(i=0; i < ((XG_MESSAGE_DATA_BOUNDARY_ADD - XG_MESSAGE_LISTINFO_START_ADD)/(PageSize)); i++)//80k
			for(i=0; i <25; i++)//擦除太多页程序运行不正常。
			{
				current_page_number+=i;
80005430:	49 56       	lddpc	r6,80005484 <xg_flashc_init+0x2d8>
				flashc_erase_page(current_page_number, true);
80005432:	30 15       	mov	r5,1
80005434:	c3 eb       	rjmp	800052b0 <xg_flashc_init+0x104>
							log("\r\n----message storage is err!!!----\r\n");
							goto ERASE;
						}
					}
				}
				log("\r\n----xoxo read message info okay!----\r\n");
80005436:	4a 2c       	lddpc	r12,800054bc <xg_flashc_init+0x310>
80005438:	f0 1f 00 08 	mcall	80005458 <xg_flashc_init+0x2ac>
			}
		}
				
		//memcpy(xg_message_count_ptr, &current_message_index, sizeof(current_message_index));
		list_init_success_flag = 1;
8000543c:	30 19       	mov	r9,1
8000543e:	4a 18       	lddpc	r8,800054c0 <xg_flashc_init+0x314>
80005440:	b0 89       	st.b	r8[0x0],r9
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
	}
	
	//flashc_lock_all_regions(false);
	xgflash_list_info_init();
	create_xg_flash_test_task();
80005442:	f0 1f 00 21 	mcall	800054c4 <xg_flashc_init+0x318>
	////flash_rw_example(ch, flash_nvram_data);
	////flash_rw_example(ch, &temp_data);
	
	#endif
	
}
80005446:	2f ed       	sub	sp,-8
80005448:	d8 32       	popm	r0-r7,pc
8000544a:	00 00       	add	r0,r0
8000544c:	80 00       	ld.sh	r0,r0[0x0]
8000544e:	69 d8       	ld.w	r8,r4[0x74]
80005450:	00 00       	add	r0,r0
80005452:	0b 78       	ld.ub	r8,--r5
80005454:	80 00       	ld.sh	r0,r0[0x0]
80005456:	de c0       	acall	0xec
80005458:	80 00       	ld.sh	r0,r0[0x0]
8000545a:	76 80       	ld.w	r0,r11[0x20]
8000545c:	80 00       	ld.sh	r0,r0[0x0]
8000545e:	6a 30       	ld.w	r0,r5[0xc]
80005460:	00 00       	add	r0,r0
80005462:	54 1c       	stdsp	sp[0x104],r12
80005464:	80 00       	ld.sh	r0,r0[0x0]
80005466:	68 d8       	ld.w	r8,r4[0x34]
80005468:	00 00       	add	r0,r0
8000546a:	0b 70       	ld.ub	r0,--r5
8000546c:	00 00       	add	r0,r0
8000546e:	0b 80       	ld.ub	r0,r5[0x0]
80005470:	00 00       	add	r0,r0
80005472:	0e 0a       	add	r10,r7
80005474:	80 00       	ld.sh	r0,r0[0x0]
80005476:	2a 80       	sub	r0,-88
80005478:	00 00       	add	r0,r0
8000547a:	0b 8c       	ld.ub	r12,r5[0x0]
8000547c:	80 00       	ld.sh	r0,r0[0x0]
8000547e:	59 14       	cp.w	r4,17
80005480:	80 00       	ld.sh	r0,r0[0x0]
80005482:	55 bc       	stdsp	sp[0x16c],r12
80005484:	00 00       	add	r0,r0
80005486:	0b 84       	ld.ub	r4,r5[0x0]
80005488:	80 00       	ld.sh	r0,r0[0x0]
8000548a:	55 9c       	stdsp	sp[0x164],r12
8000548c:	80 00       	ld.sh	r0,r0[0x0]
8000548e:	55 ac       	stdsp	sp[0x168],r12
80005490:	00 00       	add	r0,r0
80005492:	05 30       	ld.ub	r0,r2++
80005494:	80 00       	ld.sh	r0,r0[0x0]
80005496:	7e fc       	ld.w	r12,pc[0x3c]
80005498:	80 00       	ld.sh	r0,r0[0x0]
8000549a:	56 44       	stdsp	sp[0x190],r4
8000549c:	00 00       	add	r0,r0
8000549e:	0b 88       	ld.ub	r8,r5[0x0]
800054a0:	80 00       	ld.sh	r0,r0[0x0]
800054a2:	de ec       	*unknown*
800054a4:	80 00       	ld.sh	r0,r0[0x0]
800054a6:	df 18       	*unknown*
800054a8:	80 00       	ld.sh	r0,r0[0x0]
800054aa:	df 24       	*unknown*
800054ac:	00 00       	add	r0,r0
800054ae:	05 38       	ld.ub	r8,r2++
800054b0:	80 00       	ld.sh	r0,r0[0x0]
800054b2:	df 4c       	*unknown*
800054b4:	80 00       	ld.sh	r0,r0[0x0]
800054b6:	df 70       	acall	0xf7
800054b8:	80 00       	ld.sh	r0,r0[0x0]
800054ba:	56 dc       	stdsp	sp[0x1b4],r12
800054bc:	80 00       	ld.sh	r0,r0[0x0]
800054be:	df 98       	*unknown*
800054c0:	00 00       	add	r0,r0
800054c2:	0b 74       	ld.ub	r4,--r5
800054c4:	80 00       	ld.sh	r0,r0[0x0]
800054c6:	51 70       	stdsp	sp[0x5c],r0

800054c8 <runXGFlashTestSAVE>:
	return status;
		
}

void runXGFlashTestSAVE( void *pvParameters )
{
800054c8:	d4 31       	pushm	r0-r7,lr
	const portTickType xFrequency = 3000;//2s,定时问题已经修正。2s x  2000hz = 4000
	Message_Protocol_t data_ptr;
	static const uint8_t write_data[8] = {0x11, 0x23, 0x33, 0x67, 0x89, 0xAB, 0xCD, 0xEF};
	static  portTickType water_value;
	
	xLastWakeTime = xTaskGetTickCount();
800054ca:	f0 1f 00 14 	mcall	80005518 <runXGFlashTestSAVE+0x50>
800054ce:	49 48       	lddpc	r8,8000551c <runXGFlashTestSAVE+0x54>
800054d0:	91 0c       	st.w	r8[0x0],r12
	
	while(1)
	{
		vTaskDelayUntil( &xLastWakeTime, xFrequency / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800054d2:	10 96       	mov	r6,r8
800054d4:	e0 67 0b b8 	mov	r7,3000

		xSemaphoreTake(xBinarySemaphore, portMAX_DELAY);
800054d8:	49 25       	lddpc	r5,80005520 <runXGFlashTestSAVE+0x58>
800054da:	30 04       	mov	r4,0
800054dc:	3f f3       	mov	r3,-1
		
		//xgflash_get_message_count();
		//Disable_interrupt_level(1);
		//taskENTER_CRITICAL();
		flashc_memcpy((void *)0x80061234, (void *)write_data, 7,  true);
800054de:	49 22       	lddpc	r2,80005524 <runXGFlashTestSAVE+0x5c>
800054e0:	30 11       	mov	r1,1
800054e2:	30 70       	mov	r0,7
	
	xLastWakeTime = xTaskGetTickCount();
	
	while(1)
	{
		vTaskDelayUntil( &xLastWakeTime, xFrequency / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800054e4:	0e 9b       	mov	r11,r7
800054e6:	0c 9c       	mov	r12,r6
800054e8:	f0 1f 00 10 	mcall	80005528 <runXGFlashTestSAVE+0x60>

		xSemaphoreTake(xBinarySemaphore, portMAX_DELAY);
800054ec:	6a 0c       	ld.w	r12,r5[0x0]
800054ee:	08 99       	mov	r9,r4
800054f0:	06 9a       	mov	r10,r3
800054f2:	08 9b       	mov	r11,r4
800054f4:	f0 1f 00 0e 	mcall	8000552c <runXGFlashTestSAVE+0x64>
		
		//xgflash_get_message_count();
		//Disable_interrupt_level(1);
		//taskENTER_CRITICAL();
		flashc_memcpy((void *)0x80061234, (void *)write_data, 7,  true);
800054f8:	02 99       	mov	r9,r1
800054fa:	00 9a       	mov	r10,r0
800054fc:	04 9b       	mov	r11,r2
800054fe:	e0 6c 12 34 	mov	r12,4660
80005502:	ea 1c 80 06 	orh	r12,0x8006
80005506:	f0 1f 00 0b 	mcall	80005530 <runXGFlashTestSAVE+0x68>
		//if (flashc_is_lock_error() || flashc_is_programming_error())
		//{
		//log("XG flashc_memcpy err...\n");
		//}
		//else
		nop();
8000550a:	d7 03       	nop
		nop();
8000550c:	d7 03       	nop
		nop();
8000550e:	d7 03       	nop
		//water_value = uxTaskGetStackHighWaterMark(NULL);
		//log("water_value: %d\n", water_value);
		log("XG save okay!\n");
80005510:	48 9c       	lddpc	r12,80005534 <runXGFlashTestSAVE+0x6c>
80005512:	f0 1f 00 0a 	mcall	80005538 <runXGFlashTestSAVE+0x70>
80005516:	ce 7b       	rjmp	800054e4 <runXGFlashTestSAVE+0x1c>
80005518:	80 00       	ld.sh	r0,r0[0x0]
8000551a:	6e 94       	ld.w	r4,r7[0x24]
8000551c:	00 00       	add	r0,r0
8000551e:	0b 7c       	ld.ub	r12,--r5
80005520:	00 00       	add	r0,r0
80005522:	54 1c       	stdsp	sp[0x104],r12
80005524:	80 00       	ld.sh	r0,r0[0x0]
80005526:	de b0       	acall	0xeb
80005528:	80 00       	ld.sh	r0,r0[0x0]
8000552a:	71 5c       	ld.w	r12,r8[0x54]
8000552c:	80 00       	ld.sh	r0,r0[0x0]
8000552e:	66 cc       	ld.w	r12,r3[0x30]
80005530:	80 00       	ld.sh	r0,r0[0x0]
80005532:	59 14       	cp.w	r4,17
80005534:	80 00       	ld.sh	r0,r0[0x0]
80005536:	df c4       	*unknown*
80005538:	80 00       	ld.sh	r0,r0[0x0]
8000553a:	76 80       	ld.w	r0,r11[0x20]

8000553c <flashc_get_flash_size>:
 */
//! @{


unsigned int flashc_get_flash_size(void)
{
8000553c:	d4 01       	pushm	lr
8000553e:	20 4d       	sub	sp,16
		256,
		384,
		512,
		768,
		1024,
	};
80005540:	31 0a       	mov	r10,16
80005542:	48 ab       	lddpc	r11,80005568 <flashc_get_flash_size+0x2c>
80005544:	1a 9c       	mov	r12,sp
80005546:	f0 1f 00 0a 	mcall	8000556c <flashc_get_flash_size+0x30>
	return ((unsigned int)FLASH_SIZE[(AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_FSZ_MASK)
8000554a:	fe 68 14 00 	mov	r8,-125952
8000554e:	70 28       	ld.w	r8,r8[0x8]
80005550:	f1 d8 c1 a3 	bfextu	r8,r8,0xd,0x3
80005554:	fa c9 ff f0 	sub	r9,sp,-16
80005558:	f2 08 00 18 	add	r8,r9,r8<<0x1
8000555c:	f1 1c ff f0 	ld.uh	r12,r8[-16]
			>> AVR32_FLASHC_FSR_FSZ_OFFSET]) << 10;
#endif
}
80005560:	ab 6c       	lsl	r12,0xa
80005562:	2f cd       	sub	sp,-16
80005564:	d8 02       	popm	pc
80005566:	00 00       	add	r0,r0
80005568:	80 00       	ld.sh	r0,r0[0x0]
8000556a:	e0 9a 80 00 	brle	8003556a <_data_lma+0x26b8a>
8000556e:	7f 22       	ld.w	r2,pc[0x48]

80005570 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
80005570:	fe 68 14 00 	mov	r8,-125952
80005574:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
80005576:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
8000557a:	91 09       	st.w	r8[0x0],r9
}
8000557c:	5e fc       	retal	r12

8000557e <flashc_is_ready>:
//! @{


bool flashc_is_ready(void)
{
	return ((AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_FRDY_MASK) != 0);
8000557e:	fe 68 14 00 	mov	r8,-125952
80005582:	70 2c       	ld.w	r12,r8[0x8]
}
80005584:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80005588:	5e fc       	retal	r12
8000558a:	d7 03       	nop

8000558c <flashc_default_wait_until_ready>:


void flashc_default_wait_until_ready(void)
{
8000558c:	d4 01       	pushm	lr
	while (!flashc_is_ready());
8000558e:	f0 1f 00 03 	mcall	80005598 <flashc_default_wait_until_ready+0xc>
80005592:	cf e0       	breq	8000558e <flashc_default_wait_until_ready+0x2>
}
80005594:	d8 02       	popm	pc
80005596:	00 00       	add	r0,r0
80005598:	80 00       	ld.sh	r0,r0[0x0]
8000559a:	55 7e       	stdsp	sp[0x15c],lr

8000559c <flashc_is_lock_error>:
//! by a function.
static unsigned int flashc_error_status = 0;


bool flashc_is_lock_error(void)
{
8000559c:	48 38       	lddpc	r8,800055a8 <flashc_is_lock_error+0xc>
8000559e:	70 0c       	ld.w	r12,r8[0x0]
	return ((flashc_error_status & AVR32_FLASHC_FSR_LOCKE_MASK) != 0);
}
800055a0:	f9 dc c0 41 	bfextu	r12,r12,0x2,0x1
800055a4:	5e fc       	retal	r12
800055a6:	00 00       	add	r0,r0
800055a8:	00 00       	add	r0,r0
800055aa:	0b dc       	ld.ub	r12,r5[0x5]

800055ac <flashc_is_programming_error>:


bool flashc_is_programming_error(void)
{
800055ac:	48 38       	lddpc	r8,800055b8 <flashc_is_programming_error+0xc>
800055ae:	70 0c       	ld.w	r12,r8[0x0]
	return ((flashc_error_status & AVR32_FLASHC_FSR_PROGE_MASK) != 0);
}
800055b0:	f9 dc c0 61 	bfextu	r12,r12,0x3,0x1
800055b4:	5e fc       	retal	r12
800055b6:	00 00       	add	r0,r0
800055b8:	00 00       	add	r0,r0
800055ba:	0b dc       	ld.ub	r12,r5[0x5]

800055bc <flashc_get_page_number>:
}


unsigned int flashc_get_page_number(void)
{
	return (AVR32_FLASHC.fcmd & AVR32_FLASHC_FCMD_PAGEN_MASK) >> AVR32_FLASHC_FCMD_PAGEN_OFFSET;
800055bc:	fe 68 14 00 	mov	r8,-125952
800055c0:	70 1c       	ld.w	r12,r8[0x4]
}
800055c2:	f9 dc c1 10 	bfextu	r12,r12,0x8,0x10
800055c6:	5e fc       	retal	r12

800055c8 <flashc_issue_command>:


void flashc_issue_command(unsigned int command, int page_number)
{
800055c8:	eb cd 40 c0 	pushm	r6-r7,lr
800055cc:	18 96       	mov	r6,r12
800055ce:	16 97       	mov	r7,r11
	u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;

	flashc_wait_until_ready();
800055d0:	48 e8       	lddpc	r8,80005608 <flashc_issue_command+0x40>
800055d2:	70 08       	ld.w	r8,r8[0x0]
800055d4:	5d 18       	icall	r8
	u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
800055d6:	fe 68 14 00 	mov	r8,-125952
800055da:	70 18       	ld.w	r8,r8[0x4]
	u_avr32_flashc_fcmd.FCMD.cmd = command;
800055dc:	f1 d6 d0 06 	bfins	r8,r6,0x0,0x6
	if (page_number >= 0) {
800055e0:	58 07       	cp.w	r7,0
800055e2:	c0 35       	brlt	800055e8 <flashc_issue_command+0x20>
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
800055e4:	f1 d7 d1 10 	bfins	r8,r7,0x8,0x10
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
800055e8:	3a 59       	mov	r9,-91
800055ea:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
800055ee:	fe 69 14 00 	mov	r9,-125952
800055f2:	93 18       	st.w	r9[0x4],r8
 *          the driver's API which instead presents \ref flashc_is_lock_error
 *          and \ref flashc_is_programming_error.
 */
static unsigned int flashc_get_error_status(void)
{
	return AVR32_FLASHC.fsr & (AVR32_FLASHC_FSR_LOCKE_MASK |
800055f4:	72 29       	ld.w	r9,r9[0x8]
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
	flashc_error_status = flashc_get_error_status();
800055f6:	e2 19 00 0c 	andl	r9,0xc,COH
800055fa:	48 58       	lddpc	r8,8000560c <flashc_issue_command+0x44>
800055fc:	91 09       	st.w	r8[0x0],r9
	flashc_wait_until_ready();
800055fe:	48 38       	lddpc	r8,80005608 <flashc_issue_command+0x40>
80005600:	70 08       	ld.w	r8,r8[0x0]
80005602:	5d 18       	icall	r8
}
80005604:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005608:	00 00       	add	r0,r0
8000560a:	05 3c       	ld.ub	r12,r2++
8000560c:	00 00       	add	r0,r0
8000560e:	0b dc       	ld.ub	r12,r5[0x5]

80005610 <flashc_clear_page_buffer>:
 */
//! @{


void flashc_clear_page_buffer(void)
{
80005610:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_CPB, -1);
80005612:	3f fb       	mov	r11,-1
80005614:	30 3c       	mov	r12,3
80005616:	f0 1f 00 02 	mcall	8000561c <flashc_clear_page_buffer+0xc>
}
8000561a:	d8 02       	popm	pc
8000561c:	80 00       	ld.sh	r0,r0[0x0]
8000561e:	55 c8       	stdsp	sp[0x170],r8

80005620 <flashc_is_page_erased>:


bool flashc_is_page_erased(void)
{
	return ((AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_QPRR_MASK) != 0);
80005620:	fe 68 14 00 	mov	r8,-125952
80005624:	70 2c       	ld.w	r12,r8[0x8]
}
80005626:	f9 dc c0 a1 	bfextu	r12,r12,0x5,0x1
8000562a:	5e fc       	retal	r12

8000562c <flashc_quick_page_read>:


bool flashc_quick_page_read(int page_number)
{
8000562c:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPR, page_number);
8000562e:	18 9b       	mov	r11,r12
80005630:	30 cc       	mov	r12,12
80005632:	f0 1f 00 03 	mcall	8000563c <flashc_quick_page_read+0x10>
	return flashc_is_page_erased();
80005636:	f0 1f 00 03 	mcall	80005640 <flashc_quick_page_read+0x14>
}
8000563a:	d8 02       	popm	pc
8000563c:	80 00       	ld.sh	r0,r0[0x0]
8000563e:	55 c8       	stdsp	sp[0x170],r8
80005640:	80 00       	ld.sh	r0,r0[0x0]
80005642:	56 20       	stdsp	sp[0x188],r0

80005644 <flashc_erase_page>:


bool flashc_erase_page(int page_number, bool check)
{
80005644:	eb cd 40 c0 	pushm	r6-r7,lr
80005648:	16 97       	mov	r7,r11
	bool page_erased = true;

	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EP, page_number);
8000564a:	18 9b       	mov	r11,r12
8000564c:	30 2c       	mov	r12,2
8000564e:	f0 1f 00 09 	mcall	80005670 <flashc_erase_page+0x2c>
	if (check) {
80005652:	58 07       	cp.w	r7,0
80005654:	c0 31       	brne	8000565a <flashc_erase_page+0x16>
80005656:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
		unsigned int error_status = flashc_error_status;
8000565a:	48 77       	lddpc	r7,80005674 <flashc_erase_page+0x30>
8000565c:	6e 06       	ld.w	r6,r7[0x0]
		page_erased = flashc_quick_page_read(-1);
8000565e:	3f fc       	mov	r12,-1
80005660:	f0 1f 00 06 	mcall	80005678 <flashc_erase_page+0x34>
		flashc_error_status |= error_status;
80005664:	6e 08       	ld.w	r8,r7[0x0]
80005666:	f1 e6 10 06 	or	r6,r8,r6
8000566a:	8f 06       	st.w	r7[0x0],r6
	}
	return page_erased;
}
8000566c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005670:	80 00       	ld.sh	r0,r0[0x0]
80005672:	55 c8       	stdsp	sp[0x170],r8
80005674:	00 00       	add	r0,r0
80005676:	0b dc       	ld.ub	r12,r5[0x5]
80005678:	80 00       	ld.sh	r0,r0[0x0]
8000567a:	56 2c       	stdsp	sp[0x188],r12

8000567c <flashc_write_page>:
	return all_pages_erased;
}


void flashc_write_page(int page_number)
{
8000567c:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WP, page_number);
8000567e:	18 9b       	mov	r11,r12
80005680:	30 1c       	mov	r12,1
80005682:	f0 1f 00 02 	mcall	80005688 <flashc_write_page+0xc>
}
80005686:	d8 02       	popm	pc
80005688:	80 00       	ld.sh	r0,r0[0x0]
8000568a:	55 c8       	stdsp	sp[0x170],r8

8000568c <flashc_quick_user_page_read>:


bool flashc_quick_user_page_read(void)
{
8000568c:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPRUP, -1);
8000568e:	3f fb       	mov	r11,-1
80005690:	30 fc       	mov	r12,15
80005692:	f0 1f 00 03 	mcall	8000569c <flashc_quick_user_page_read+0x10>
	return flashc_is_page_erased();
80005696:	f0 1f 00 03 	mcall	800056a0 <flashc_quick_user_page_read+0x14>
}
8000569a:	d8 02       	popm	pc
8000569c:	80 00       	ld.sh	r0,r0[0x0]
8000569e:	55 c8       	stdsp	sp[0x170],r8
800056a0:	80 00       	ld.sh	r0,r0[0x0]
800056a2:	56 20       	stdsp	sp[0x188],r0

800056a4 <flashc_erase_user_page>:


bool flashc_erase_user_page(bool check)
{
800056a4:	eb cd 40 80 	pushm	r7,lr
800056a8:	18 97       	mov	r7,r12
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EUP, -1);
800056aa:	3f fb       	mov	r11,-1
800056ac:	30 ec       	mov	r12,14
800056ae:	f0 1f 00 06 	mcall	800056c4 <flashc_erase_user_page+0x20>
	return (check) ? flashc_quick_user_page_read() : true;
800056b2:	58 07       	cp.w	r7,0
800056b4:	c0 31       	brne	800056ba <flashc_erase_user_page+0x16>
800056b6:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
800056ba:	f0 1f 00 04 	mcall	800056c8 <flashc_erase_user_page+0x24>
}
800056be:	e3 cd 80 80 	ldm	sp++,r7,pc
800056c2:	00 00       	add	r0,r0
800056c4:	80 00       	ld.sh	r0,r0[0x0]
800056c6:	55 c8       	stdsp	sp[0x170],r8
800056c8:	80 00       	ld.sh	r0,r0[0x0]
800056ca:	56 8c       	stdsp	sp[0x1a0],r12

800056cc <flashc_write_user_page>:


void flashc_write_user_page(void)
{
800056cc:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WUP, -1);
800056ce:	3f fb       	mov	r11,-1
800056d0:	30 dc       	mov	r12,13
800056d2:	f0 1f 00 02 	mcall	800056d8 <flashc_write_user_page+0xc>
}
800056d6:	d8 02       	popm	pc
800056d8:	80 00       	ld.sh	r0,r0[0x0]
800056da:	55 c8       	stdsp	sp[0x170],r8

800056dc <flashc_memset64>:
	return flashc_memset64(dst, src | (uint64_t)src << 32, nbytes, erase);
}


volatile void *flashc_memset64(volatile void *dst, uint64_t src, size_t nbytes, bool erase)
{
800056dc:	d4 31       	pushm	r0-r7,lr
800056de:	20 cd       	sub	sp,48
800056e0:	50 6c       	stdsp	sp[0x18],r12
800056e2:	14 94       	mov	r4,r10
800056e4:	16 95       	mov	r5,r11
800056e6:	12 96       	mov	r6,r9
800056e8:	50 38       	stdsp	sp[0xc],r8
	// Use aggregated pointers to have several alignments available for a same address.
	UnionCVPtr flash_array_end;
	UnionVPtr dest;
	Union64 source = {0};
800056ea:	30 08       	mov	r8,0
800056ec:	30 09       	mov	r9,0
800056ee:	fa e9 00 28 	st.d	sp[40],r8
	UnionVPtr tmp;
	unsigned int error_status = 0;
	unsigned int i;

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
800056f2:	f0 1f 00 82 	mcall	800058f8 <flashc_memset64+0x21c>
800056f6:	fc 18 80 00 	movh	r8,0x8000
800056fa:	f8 08 00 08 	add	r8,r12,r8
800056fe:	50 28       	stdsp	sp[0x8],r8
	dest.u8ptr = dst;
80005700:	40 6b       	lddsp	r11,sp[0x18]
80005702:	16 97       	mov	r7,r11
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
80005704:	58 04       	cp.w	r4,0
80005706:	5c 25       	cpc	r5
80005708:	c1 80       	breq	80005738 <flashc_memset64+0x5c>
8000570a:	f6 c8 ff f9 	sub	r8,r11,-7
8000570e:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
		source.u8[i] = src;
80005712:	fa c9 ff d0 	sub	r9,sp,-48
80005716:	10 09       	add	r9,r8
80005718:	f3 64 ff f8 	st.b	r9[-8],r4
		src >>= 8;
8000571c:	e8 0c 16 08 	lsr	r12,r4,0x8
80005720:	ea 0a 16 08 	lsr	r10,r5,0x8
80005724:	f9 e5 11 89 	or	r9,r12,r5<<0x18
80005728:	14 95       	mov	r5,r10
8000572a:	12 94       	mov	r4,r9

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
	dest.u8ptr = dst;
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
8000572c:	20 18       	sub	r8,1
8000572e:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
	unsigned int i;

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
	dest.u8ptr = dst;
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
80005732:	58 04       	cp.w	r4,0
80005734:	5c 25       	cpc	r5
80005736:	ce e1       	brne	80005712 <flashc_memset64+0x36>
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
		source.u8[i] = src;
		src >>= 8;
	}
	dest_end.u8ptr = dest.u8ptr + nbytes;
80005738:	f6 06 00 06 	add	r6,r11,r6
8000573c:	50 06       	stdsp	sp[0x0],r6

	// If destination is outside flash, go to next flash page if any.
	if (dest.u8ptr < AVR32_FLASH) {
8000573e:	e0 6a ff ff 	mov	r10,65535
80005742:	ea 1a 7f ff 	orh	r10,0x7fff
80005746:	14 3b       	cp.w	r11,r10
80005748:	e0 8b 00 05 	brhi	80005752 <flashc_memset64+0x76>
		dest.u8ptr = AVR32_FLASH;
8000574c:	fc 17 80 00 	movh	r7,0x8000
80005750:	c0 e8       	rjmp	8000576c <flashc_memset64+0x90>
	} else if (flash_array_end.u8ptr <= dest.u8ptr && dest.u8ptr < AVR32_FLASHC_USER_PAGE) {
80005752:	40 29       	lddsp	r9,sp[0x8]
80005754:	16 39       	cp.w	r9,r11
80005756:	e0 8b 00 0b 	brhi	8000576c <flashc_memset64+0x90>
		dest.u8ptr = AVR32_FLASHC_USER_PAGE;
8000575a:	fc 18 80 80 	movh	r8,0x8080
8000575e:	e0 6a ff ff 	mov	r10,65535
80005762:	ea 1a 80 7f 	orh	r10,0x807f
80005766:	14 3b       	cp.w	r11,r10
80005768:	f0 07 17 80 	movls	r7,r8
	}

	// If end of destination is outside flash, move it to the end of the previous flash page if any.
	if (dest_end.u8ptr > AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE) {
8000576c:	40 09       	lddsp	r9,sp[0x0]
8000576e:	e0 68 02 00 	mov	r8,512
80005772:	ea 18 80 80 	orh	r8,0x8080
80005776:	10 39       	cp.w	r9,r8
80005778:	e0 88 00 04 	brls	80005780 <flashc_memset64+0xa4>
8000577c:	50 08       	stdsp	sp[0x0],r8
8000577e:	c0 c8       	rjmp	80005796 <flashc_memset64+0xba>
		dest_end.u8ptr = AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE;
	} else if (AVR32_FLASHC_USER_PAGE >= dest_end.u8ptr && dest_end.u8ptr > flash_array_end.u8ptr) {
80005780:	40 0a       	lddsp	r10,sp[0x0]
80005782:	fc 19 80 80 	movh	r9,0x8080
80005786:	12 3a       	cp.w	r10,r9
80005788:	e0 8b 00 07 	brhi	80005796 <flashc_memset64+0xba>
8000578c:	40 28       	lddsp	r8,sp[0x8]
8000578e:	10 3a       	cp.w	r10,r8
80005790:	f0 0a 17 b0 	movhi	r10,r8
80005794:	50 0a       	stdsp	sp[0x0],r10
		dest_end.u8ptr = flash_array_end.u8ptr;
	}

	// Align each end of destination pointer with its natural boundary.
	dest_end.u16ptr = (uint16_t *)Align_down((uint32_t)dest_end.u8ptr, sizeof(uint16_t));
80005796:	40 08       	lddsp	r8,sp[0x0]
	dest_end.u32ptr = (uint32_t *)Align_down((uint32_t)dest_end.u16ptr, sizeof(uint32_t));
	dest_end.u64ptr = (uint64_t *)Align_down((uint32_t)dest_end.u32ptr, sizeof(uint64_t));
80005798:	10 9b       	mov	r11,r8
8000579a:	e0 1b ff f8 	andl	r11,0xfff8
8000579e:	50 1b       	stdsp	sp[0x4],r11
		// Determine if the current destination page has an incomplete end.
		incomplete_flash_page_end = (Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) >=
				Align_down((uint32_t)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));

		// Use a flash double-word buffer to manage unaligned accesses.
		flash_dword.u64 = source.u64;
800057a0:	fa e4 00 28 	ld.d	r4,sp[40]
800057a4:	30 03       	mov	r3,0

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;
800057a6:	4d 66       	lddpc	r6,800058fc <flashc_memset64+0x220>
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
			*dest.u64ptr++ = source.u64;
		}

		// If the current destination page has an incomplete end...
		if (incomplete_flash_page_end) {
800057a8:	10 9a       	mov	r10,r8
800057aa:	e0 1a fe 00 	andl	r10,0xfe00
800057ae:	50 4a       	stdsp	sp[0x10],r10
			// pages that have already been written to.
			{
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
800057b0:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800057b4:	50 58       	stdsp	sp[0x14],r8
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
800057b6:	40 08       	lddsp	r8,sp[0x0]
800057b8:	40 59       	lddsp	r9,sp[0x14]
800057ba:	12 18       	sub	r8,r9
800057bc:	2f 88       	sub	r8,-8
800057be:	50 78       	stdsp	sp[0x1c],r8
	dest_end.u16ptr = (uint16_t *)Align_down((uint32_t)dest_end.u8ptr, sizeof(uint16_t));
	dest_end.u32ptr = (uint32_t *)Align_down((uint32_t)dest_end.u16ptr, sizeof(uint32_t));
	dest_end.u64ptr = (uint64_t *)Align_down((uint32_t)dest_end.u32ptr, sizeof(uint64_t));

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
800057c0:	c9 18       	rjmp	800058e2 <flashc_memset64+0x206>
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
800057c2:	f0 1f 00 50 	mcall	80005900 <flashc_memset64+0x224>
		error_status |= flashc_error_status;
800057c6:	6c 08       	ld.w	r8,r6[0x0]
800057c8:	10 43       	or	r3,r8

		// Determine where the source data will end in the current flash page.
		flash_page_source_end.u64ptr =
				(uint64_t *)min((uint32_t)dest_end.u64ptr,
800057ca:	04 9c       	mov	r12,r2
800057cc:	e0 1c fe 00 	andl	r12,0xfe00
800057d0:	f8 ce fe 00 	sub	lr,r12,-512
800057d4:	40 18       	lddsp	r8,sp[0x4]
800057d6:	f0 0e 0d 4e 	min	lr,r8,lr
		// Determine if the current destination page has an incomplete end.
		incomplete_flash_page_end = (Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) >=
				Align_down((uint32_t)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));

		// Use a flash double-word buffer to manage unaligned accesses.
		flash_dword.u64 = source.u64;
800057da:	fa e5 00 20 	st.d	sp[32],r4

		// If destination does not point to the beginning of the current flash page...
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
800057de:	f1 d2 c0 09 	bfextu	r8,r2,0x0,0x9
800057e2:	c2 f0       	breq	80005840 <flashc_memset64+0x164>
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
800057e4:	18 98       	mov	r8,r12
					tmp.u64ptr < (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
800057e6:	18 90       	mov	r0,r12
800057e8:	04 91       	mov	r1,r2
800057ea:	e0 11 ff f8 	andl	r1,0xfff8
800057ee:	02 99       	mov	r9,r1
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
800057f0:	18 31       	cp.w	r1,r12
800057f2:	e0 88 00 10 	brls	80005812 <flashc_memset64+0x136>
					tmp.u64ptr < (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
					tmp.u64ptr++) {
				*tmp.u64ptr = *tmp.u64ptr;
800057f6:	f0 ea 00 00 	ld.d	r10,r8[0]
800057fa:	b1 2a       	st.d	r8++,r10
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
800057fc:	10 39       	cp.w	r9,r8
800057fe:	fe 9b ff fc 	brhi	800057f6 <flashc_memset64+0x11a>
80005802:	e0 08 11 ff 	rsub	r8,r0,-1
80005806:	02 08       	add	r8,r1
80005808:	e0 18 ff f8 	andl	r8,0xfff8
8000580c:	2f 88       	sub	r8,-8
8000580e:	e0 08 00 08 	add	r8,r0,r8
					tmp.u64ptr++) {
				*tmp.u64ptr = *tmp.u64ptr;
			}

			// If destination is not 64-bit aligned...
			if (!Test_align((uint32_t)dest.u8ptr, sizeof(uint64_t))) {
80005812:	e5 d2 c0 03 	bfextu	r2,r2,0x0,0x3
80005816:	c1 50       	breq	80005840 <flashc_memset64+0x164>
80005818:	30 0a       	mov	r10,0
8000581a:	f0 0a 00 0b 	add	r11,r8,r10
				// flash page data.
				// This is required by the hardware, even if page erase is not
				// requested, in order to be able to write successfully to erased parts
				// of flash pages that have already been written to.
				for (i = 0; i < Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)); i++) {
					flash_dword.u8[i] = *tmp.u8ptr++;
8000581e:	17 8b       	ld.ub	r11,r11[0x0]
80005820:	fa c7 ff e0 	sub	r7,sp,-32
80005824:	ee 0a 0b 0b 	st.b	r7[r10],r11
				// Fill the beginning of the flash double-word buffer with the current
				// flash page data.
				// This is required by the hardware, even if page erase is not
				// requested, in order to be able to write successfully to erased parts
				// of flash pages that have already been written to.
				for (i = 0; i < Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)); i++) {
80005828:	2f fa       	sub	r10,-1
8000582a:	04 3a       	cp.w	r10,r2
8000582c:	cf 71       	brne	8000581a <flashc_memset64+0x13e>
					flash_dword.u8[i] = *tmp.u8ptr++;
				}

				// Align the destination pointer with its 64-bit boundary.
				dest.u64ptr = (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
8000582e:	12 97       	mov	r7,r9

				// If the current destination double-word is not the last one...
				if (dest.u64ptr < dest_end.u64ptr) {
80005830:	40 1b       	lddsp	r11,sp[0x4]
80005832:	16 39       	cp.w	r9,r11
80005834:	c0 62       	brcc	80005840 <flashc_memset64+0x164>
					// Write the flash double-word buffer to the page buffer and reinitialize it.
					*dest.u64ptr++ = flash_dword.u64;
80005836:	fa e8 00 20 	ld.d	r8,sp[32]
8000583a:	af 28       	st.d	r7++,r8
					flash_dword.u64 = source.u64;
8000583c:	fa e5 00 20 	st.d	sp[32],r4
				}
			}
		}

		// Write the source data to the page buffer with 64-bit alignment.
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
80005840:	0e 99       	mov	r9,r7
80005842:	0e 1e       	sub	lr,r7
80005844:	a3 5e       	asr	lr,0x3
80005846:	c0 80       	breq	80005856 <flashc_memset64+0x17a>
80005848:	0e 9a       	mov	r10,r7
8000584a:	1c 98       	mov	r8,lr
			*dest.u64ptr++ = source.u64;
8000584c:	b5 24       	st.d	r10++,r4
				}
			}
		}

		// Write the source data to the page buffer with 64-bit alignment.
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
8000584e:	20 18       	sub	r8,1
80005850:	cf e1       	brne	8000584c <flashc_memset64+0x170>
80005852:	f2 0e 00 37 	add	r7,r9,lr<<0x3
			*dest.u64ptr++ = source.u64;
		}

		// If the current destination page has an incomplete end...
		if (incomplete_flash_page_end) {
80005856:	40 4a       	lddsp	r10,sp[0x10]
80005858:	14 3c       	cp.w	r12,r10
8000585a:	c1 d3       	brcs	80005894 <flashc_memset64+0x1b8>
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			{
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;
8000585c:	40 08       	lddsp	r8,sp[0x0]

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
8000585e:	40 59       	lddsp	r9,sp[0x14]
80005860:	58 09       	cp.w	r9,0
80005862:	c1 00       	breq	80005882 <flashc_memset64+0x1a6>
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
80005864:	10 99       	mov	r9,r8
80005866:	fa c8 ff e0 	sub	r8,sp,-32
8000586a:	40 5b       	lddsp	r11,sp[0x14]
8000586c:	16 08       	add	r8,r11
{
	return flashc_memset64(dst, src | (uint64_t)src << 32, nbytes, erase);
}


volatile void *flashc_memset64(volatile void *dst, uint64_t src, size_t nbytes, bool erase)
8000586e:	fa cb ff d8 	sub	r11,sp,-40

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
						flash_dword.u8[i] = *tmp.u8ptr++;
80005872:	13 3a       	ld.ub	r10,r9++
80005874:	10 ca       	st.b	r8++,r10
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
80005876:	16 38       	cp.w	r8,r11
80005878:	cf d1       	brne	80005872 <flashc_memset64+0x196>
8000587a:	40 78       	lddsp	r8,sp[0x1c]
						flash_dword.u8[i] = *tmp.u8ptr++;

					// Write the flash double-word buffer to the page buffer.
					*dest.u64ptr++ = flash_dword.u64;
8000587c:	fa ea 00 20 	ld.d	r10,sp[32]
80005880:	af 2a       	st.d	r7++,r10
				}

				// Fill the end of the page buffer with the current flash page data.
				for (; !Test_align((uint32_t)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++) {
80005882:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80005886:	c0 70       	breq	80005894 <flashc_memset64+0x1b8>
					*tmp.u64ptr = *tmp.u64ptr;
80005888:	f0 ea 00 00 	ld.d	r10,r8[0]
8000588c:	b1 2a       	st.d	r8++,r10
					// Write the flash double-word buffer to the page buffer.
					*dest.u64ptr++ = flash_dword.u64;
				}

				// Fill the end of the page buffer with the current flash page data.
				for (; !Test_align((uint32_t)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++) {
8000588e:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80005892:	cf b1       	brne	80005888 <flashc_memset64+0x1ac>
				}
			}
		}

		// If the current flash page is in the flash array...
		if (dest.u8ptr <= AVR32_FLASHC_USER_PAGE) {
80005894:	0e 92       	mov	r2,r7
80005896:	fc 1a 80 80 	movh	r10,0x8080
8000589a:	14 37       	cp.w	r7,r10
8000589c:	e0 8b 00 17 	brhi	800058ca <flashc_memset64+0x1ee>
			// Erase the current page if requested and write it from the page buffer.
			if (erase) {
800058a0:	40 39       	lddsp	r9,sp[0xc]
800058a2:	58 09       	cp.w	r9,0
800058a4:	c0 70       	breq	800058b2 <flashc_memset64+0x1d6>
				flashc_erase_page(-1, false);
800058a6:	30 0b       	mov	r11,0
800058a8:	3f fc       	mov	r12,-1
800058aa:	f0 1f 00 17 	mcall	80005904 <flashc_memset64+0x228>
				error_status |= flashc_error_status;
800058ae:	6c 08       	ld.w	r8,r6[0x0]
800058b0:	10 43       	or	r3,r8
			}
			flashc_write_page(-1);
800058b2:	3f fc       	mov	r12,-1
800058b4:	f0 1f 00 15 	mcall	80005908 <flashc_memset64+0x22c>
			error_status |= flashc_error_status;
800058b8:	6c 08       	ld.w	r8,r6[0x0]
800058ba:	10 43       	or	r3,r8

			// If the end of the flash array is reached, go to the User page.
			if (dest.u8ptr >= flash_array_end.u8ptr) {
				dest.u8ptr = AVR32_FLASHC_USER_PAGE;
800058bc:	fc 18 80 80 	movh	r8,0x8080
800058c0:	40 2b       	lddsp	r11,sp[0x8]
800058c2:	04 3b       	cp.w	r11,r2
800058c4:	f0 07 17 80 	movls	r7,r8
800058c8:	c0 d8       	rjmp	800058e2 <flashc_memset64+0x206>
			}
		} else {
			// Erase the User page if requested and write it from the page buffer.
			if (erase) {
800058ca:	40 3a       	lddsp	r10,sp[0xc]
800058cc:	58 0a       	cp.w	r10,0
800058ce:	c0 60       	breq	800058da <flashc_memset64+0x1fe>
				flashc_erase_user_page(false);
800058d0:	30 0c       	mov	r12,0
800058d2:	f0 1f 00 0f 	mcall	8000590c <flashc_memset64+0x230>
				error_status |= flashc_error_status;
800058d6:	6c 08       	ld.w	r8,r6[0x0]
800058d8:	10 43       	or	r3,r8
			}
			flashc_write_user_page();
800058da:	f0 1f 00 0e 	mcall	80005910 <flashc_memset64+0x234>
			error_status |= flashc_error_status;
800058de:	6c 08       	ld.w	r8,r6[0x0]
800058e0:	10 43       	or	r3,r8
	dest_end.u16ptr = (uint16_t *)Align_down((uint32_t)dest_end.u8ptr, sizeof(uint16_t));
	dest_end.u32ptr = (uint32_t *)Align_down((uint32_t)dest_end.u16ptr, sizeof(uint32_t));
	dest_end.u64ptr = (uint64_t *)Align_down((uint32_t)dest_end.u32ptr, sizeof(uint64_t));

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
800058e2:	0e 92       	mov	r2,r7
800058e4:	40 09       	lddsp	r9,sp[0x0]
800058e6:	12 37       	cp.w	r7,r9
800058e8:	fe 93 ff 6d 	brlo	800057c2 <flashc_memset64+0xe6>
			error_status |= flashc_error_status;
		}
	}

	// Update the FLASHC error status.
	flashc_error_status = error_status;
800058ec:	48 48       	lddpc	r8,800058fc <flashc_memset64+0x220>
800058ee:	91 03       	st.w	r8[0x0],r3

	// Return the initial destination pointer as the standard memset function does.
	return dst;
}
800058f0:	40 6c       	lddsp	r12,sp[0x18]
800058f2:	2f 4d       	sub	sp,-48
800058f4:	d8 32       	popm	r0-r7,pc
800058f6:	00 00       	add	r0,r0
800058f8:	80 00       	ld.sh	r0,r0[0x0]
800058fa:	55 3c       	stdsp	sp[0x14c],r12
800058fc:	00 00       	add	r0,r0
800058fe:	0b dc       	ld.ub	r12,r5[0x5]
80005900:	80 00       	ld.sh	r0,r0[0x0]
80005902:	56 10       	stdsp	sp[0x184],r0
80005904:	80 00       	ld.sh	r0,r0[0x0]
80005906:	56 44       	stdsp	sp[0x190],r4
80005908:	80 00       	ld.sh	r0,r0[0x0]
8000590a:	56 7c       	stdsp	sp[0x19c],r12
8000590c:	80 00       	ld.sh	r0,r0[0x0]
8000590e:	56 a4       	stdsp	sp[0x1a8],r4
80005910:	80 00       	ld.sh	r0,r0[0x0]
80005912:	56 cc       	stdsp	sp[0x1b0],r12

80005914 <flashc_memcpy>:


volatile void *flashc_memcpy(volatile void *dst, const void *src, size_t nbytes, bool erase)
{
80005914:	d4 31       	pushm	r0-r7,lr
80005916:	20 7d       	sub	sp,28
80005918:	50 1c       	stdsp	sp[0x4],r12
8000591a:	14 97       	mov	r7,r10
8000591c:	50 49       	stdsp	sp[0x10],r9
	Assert( (((uint8_t *)dst >= AVR32_FLASH)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASH + flashc_get_flash_size())))
			|| (((uint8_t *)dst >= AVR32_FLASHC_USER_PAGE)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE))) );

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;
8000591e:	e0 69 ff ff 	mov	r9,65535
80005922:	ea 19 80 7f 	orh	r9,0x807f
80005926:	12 3c       	cp.w	r12,r9
80005928:	5f b8       	srhi	r8
8000592a:	50 28       	stdsp	sp[0x8],r8

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));

	while (nbytes) {
8000592c:	58 0a       	cp.w	r10,0
8000592e:	c0 41       	brne	80005936 <flashc_memcpy+0x22>
80005930:	30 09       	mov	r9,0
80005932:	50 09       	stdsp	sp[0x0],r9
80005934:	c5 b8       	rjmp	800059ea <flashc_memcpy+0xd6>
	Union64 flash_dword;
	uint8_t i;
	bool b_user_page;
	unsigned int error_status = 0;
	uint8_t* flash_add;
	uint8_t* dest_add=(uint8_t*)dst;
80005936:	40 16       	lddsp	r6,sp[0x4]
	const uint8_t* src_buf=(const uint8_t*)src;
80005938:	16 94       	mov	r4,r11
			|| (((uint8_t *)dst >= AVR32_FLASHC_USER_PAGE)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE))) );

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));
8000593a:	0c 90       	mov	r0,r6
8000593c:	e0 10 fe 00 	andl	r0,0xfe00
80005940:	30 08       	mov	r8,0
80005942:	50 08       	stdsp	sp[0x0],r8

	while (nbytes) {
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;
80005944:	4a d1       	lddpc	r1,800059f8 <flashc_memcpy+0xe4>
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
				if (nbytes && (flash_add == dest_add)) {
80005946:	30 05       	mov	r5,0
					// Update page with data source
					flash_dword.u8[i] = *src_buf++;
80005948:	fa c3 ff ec 	sub	r3,sp,-20
		error_status |= flashc_error_status;

		// Loop in the page
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;
8000594c:	10 92       	mov	r2,r8

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));

	while (nbytes) {
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
8000594e:	f0 1f 00 2c 	mcall	800059fc <flashc_memcpy+0xe8>
		error_status |= flashc_error_status;
80005952:	62 08       	ld.w	r8,r1[0x0]
80005954:	40 09       	lddsp	r9,sp[0x0]
80005956:	10 49       	or	r9,r8
80005958:	50 09       	stdsp	sp[0x0],r9
8000595a:	00 9b       	mov	r11,r0
8000595c:	e0 ce fe 00 	sub	lr,r0,-512
80005960:	16 9c       	mov	r12,r11

		// Loop in the page
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;
80005962:	f6 e8 00 00 	ld.d	r8,r11[0]
80005966:	fa e9 00 14 	st.d	sp[20],r8
8000596a:	04 98       	mov	r8,r2

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
				if (nbytes && (flash_add == dest_add)) {
8000596c:	58 07       	cp.w	r7,0
8000596e:	5f 1a       	srne	r10
80005970:	f0 0b 00 09 	add	r9,r8,r11
80005974:	12 36       	cp.w	r6,r9
80005976:	5f 09       	sreq	r9
80005978:	f5 e9 00 09 	and	r9,r10,r9
8000597c:	ea 09 18 00 	cp.b	r9,r5
80005980:	c0 60       	breq	8000598c <flashc_memcpy+0x78>
					// Update page with data source
					flash_dword.u8[i] = *src_buf++;
80005982:	09 39       	ld.ub	r9,r4++
80005984:	e6 08 0b 09 	st.b	r3[r8],r9
					dest_add++;
80005988:	2f f6       	sub	r6,-1
					nbytes--;
8000598a:	20 17       	sub	r7,1
8000598c:	2f f8       	sub	r8,-1
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
8000598e:	58 88       	cp.w	r8,8
80005990:	ce e1       	brne	8000596c <flashc_memcpy+0x58>
				}
				flash_add++;
			}

			// Write the flash double-word buffer to the page buffer.
			*(volatile uint64_t*)((uint32_t)flash_add - sizeof(uint64_t))= flash_dword.u64;
80005992:	fa e8 00 14 	ld.d	r8,sp[20]
80005996:	f8 e9 00 00 	st.d	r12[0],r8
8000599a:	2f 8b       	sub	r11,-8
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;

		// Loop in the page
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
8000599c:	1c 3b       	cp.w	r11,lr
8000599e:	ce 11       	brne	80005960 <flashc_memcpy+0x4c>
800059a0:	50 37       	stdsp	sp[0xc],r7
800059a2:	e0 c0 fe 00 	sub	r0,r0,-512
			// Write the flash double-word buffer to the page buffer.
			*(volatile uint64_t*)((uint32_t)flash_add - sizeof(uint64_t))= flash_dword.u64;
		}

		// Erase the current page if requested and write it from the page buffer.
		if (erase) {
800059a6:	40 48       	lddsp	r8,sp[0x10]
800059a8:	58 08       	cp.w	r8,0
800059aa:	c1 00       	breq	800059ca <flashc_memcpy+0xb6>
			(b_user_page)? flashc_erase_user_page(false) : flashc_erase_page(-1, false);
800059ac:	40 29       	lddsp	r9,sp[0x8]
800059ae:	58 09       	cp.w	r9,0
800059b0:	c0 50       	breq	800059ba <flashc_memcpy+0xa6>
800059b2:	30 0c       	mov	r12,0
800059b4:	f0 1f 00 13 	mcall	80005a00 <flashc_memcpy+0xec>
800059b8:	c0 58       	rjmp	800059c2 <flashc_memcpy+0xae>
800059ba:	30 0b       	mov	r11,0
800059bc:	3f fc       	mov	r12,-1
800059be:	f0 1f 00 12 	mcall	80005a04 <flashc_memcpy+0xf0>
			error_status |= flashc_error_status;
800059c2:	62 08       	ld.w	r8,r1[0x0]
800059c4:	40 09       	lddsp	r9,sp[0x0]
800059c6:	10 49       	or	r9,r8
800059c8:	50 09       	stdsp	sp[0x0],r9
		}

		// Write the page
		(b_user_page)? flashc_write_user_page() : flashc_write_page(-1);
800059ca:	40 28       	lddsp	r8,sp[0x8]
800059cc:	58 08       	cp.w	r8,0
800059ce:	c0 40       	breq	800059d6 <flashc_memcpy+0xc2>
800059d0:	f0 1f 00 0e 	mcall	80005a08 <flashc_memcpy+0xf4>
800059d4:	c0 48       	rjmp	800059dc <flashc_memcpy+0xc8>
800059d6:	3f fc       	mov	r12,-1
800059d8:	f0 1f 00 0d 	mcall	80005a0c <flashc_memcpy+0xf8>
		error_status |= flashc_error_status;
800059dc:	62 08       	ld.w	r8,r1[0x0]
800059de:	40 09       	lddsp	r9,sp[0x0]
800059e0:	10 49       	or	r9,r8
800059e2:	50 09       	stdsp	sp[0x0],r9

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));

	while (nbytes) {
800059e4:	40 38       	lddsp	r8,sp[0xc]
800059e6:	58 08       	cp.w	r8,0
800059e8:	cb 31       	brne	8000594e <flashc_memcpy+0x3a>
		// Write the page
		(b_user_page)? flashc_write_user_page() : flashc_write_page(-1);
		error_status |= flashc_error_status;
	}
	// Update the FLASHC error status.
	flashc_error_status = error_status;
800059ea:	48 48       	lddpc	r8,800059f8 <flashc_memcpy+0xe4>
800059ec:	40 09       	lddsp	r9,sp[0x0]
800059ee:	91 09       	st.w	r8[0x0],r9

	// Return the initial destination pointer as the standard memcpy function does.
	return dst;
}
800059f0:	40 1c       	lddsp	r12,sp[0x4]
800059f2:	2f 9d       	sub	sp,-28
800059f4:	d8 32       	popm	r0-r7,pc
800059f6:	00 00       	add	r0,r0
800059f8:	00 00       	add	r0,r0
800059fa:	0b dc       	ld.ub	r12,r5[0x5]
800059fc:	80 00       	ld.sh	r0,r0[0x0]
800059fe:	56 10       	stdsp	sp[0x184],r0
80005a00:	80 00       	ld.sh	r0,r0[0x0]
80005a02:	56 a4       	stdsp	sp[0x1a8],r4
80005a04:	80 00       	ld.sh	r0,r0[0x0]
80005a06:	56 44       	stdsp	sp[0x190],r4
80005a08:	80 00       	ld.sh	r0,r0[0x0]
80005a0a:	56 cc       	stdsp	sp[0x1b0],r12
80005a0c:	80 00       	ld.sh	r0,r0[0x0]
80005a0e:	56 7c       	stdsp	sp[0x19c],r12

80005a10 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005a10:	f8 08 16 05 	lsr	r8,r12,0x5
80005a14:	a9 68       	lsl	r8,0x8
80005a16:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80005a1a:	58 1b       	cp.w	r11,1
80005a1c:	c0 d0       	breq	80005a36 <gpio_enable_module_pin+0x26>
80005a1e:	c0 63       	brcs	80005a2a <gpio_enable_module_pin+0x1a>
80005a20:	58 2b       	cp.w	r11,2
80005a22:	c1 00       	breq	80005a42 <gpio_enable_module_pin+0x32>
80005a24:	58 3b       	cp.w	r11,3
80005a26:	c1 40       	breq	80005a4e <gpio_enable_module_pin+0x3e>
80005a28:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005a2a:	30 19       	mov	r9,1
80005a2c:	f2 0c 09 49 	lsl	r9,r9,r12
80005a30:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005a32:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005a34:	c1 28       	rjmp	80005a58 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005a36:	30 19       	mov	r9,1
80005a38:	f2 0c 09 49 	lsl	r9,r9,r12
80005a3c:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005a3e:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005a40:	c0 c8       	rjmp	80005a58 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005a42:	30 19       	mov	r9,1
80005a44:	f2 0c 09 49 	lsl	r9,r9,r12
80005a48:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005a4a:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005a4c:	c0 68       	rjmp	80005a58 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005a4e:	30 19       	mov	r9,1
80005a50:	f2 0c 09 49 	lsl	r9,r9,r12
80005a54:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005a56:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80005a58:	30 19       	mov	r9,1
80005a5a:	f2 0c 09 4c 	lsl	r12,r9,r12
80005a5e:	91 2c       	st.w	r8[0x8],r12
80005a60:	5e fd       	retal	0
80005a62:	d7 03       	nop

80005a64 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80005a64:	d4 21       	pushm	r4-r7,lr
80005a66:	18 97       	mov	r7,r12
80005a68:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005a6a:	58 0b       	cp.w	r11,0
80005a6c:	c0 31       	brne	80005a72 <gpio_enable_module+0xe>
80005a6e:	30 05       	mov	r5,0
80005a70:	c0 d8       	rjmp	80005a8a <gpio_enable_module+0x26>
80005a72:	30 06       	mov	r6,0
80005a74:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80005a76:	6e 1b       	ld.w	r11,r7[0x4]
80005a78:	6e 0c       	ld.w	r12,r7[0x0]
80005a7a:	f0 1f 00 06 	mcall	80005a90 <gpio_enable_module+0x2c>
80005a7e:	18 45       	or	r5,r12
		gpiomap++;
80005a80:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005a82:	2f f6       	sub	r6,-1
80005a84:	0c 34       	cp.w	r4,r6
80005a86:	fe 9b ff f8 	brhi	80005a76 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80005a8a:	0a 9c       	mov	r12,r5
80005a8c:	d8 22       	popm	r4-r7,pc
80005a8e:	00 00       	add	r0,r0
80005a90:	80 00       	ld.sh	r0,r0[0x0]
80005a92:	5a 10       	cp.w	r0,-31

80005a94 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005a94:	f8 08 16 05 	lsr	r8,r12,0x5
80005a98:	a9 68       	lsl	r8,0x8
80005a9a:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80005a9e:	30 19       	mov	r9,1
80005aa0:	f2 0c 09 4c 	lsl	r12,r9,r12
80005aa4:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80005aa8:	91 1c       	st.w	r8[0x4],r12
}
80005aaa:	5e fc       	retal	r12

80005aac <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005aac:	f8 08 16 05 	lsr	r8,r12,0x5
80005ab0:	a9 68       	lsl	r8,0x8
80005ab2:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80005ab6:	30 19       	mov	r9,1
80005ab8:	f2 0c 09 4c 	lsl	r12,r9,r12
80005abc:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80005ac0:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005ac4:	91 1c       	st.w	r8[0x4],r12
}
80005ac6:	5e fc       	retal	r12

80005ac8 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005ac8:	f8 08 16 05 	lsr	r8,r12,0x5
80005acc:	a9 68       	lsl	r8,0x8
80005ace:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80005ad2:	30 19       	mov	r9,1
80005ad4:	f2 0c 09 4c 	lsl	r12,r9,r12
80005ad8:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80005adc:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005ae0:	91 1c       	st.w	r8[0x4],r12
}
80005ae2:	5e fc       	retal	r12

80005ae4 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80005ae4:	c0 08       	rjmp	80005ae4 <_unhandled_interrupt>
80005ae6:	d7 03       	nop

80005ae8 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005ae8:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005aec:	49 99       	lddpc	r9,80005b50 <INTC_register_interrupt+0x68>
80005aee:	f2 08 00 39 	add	r9,r9,r8<<0x3
80005af2:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80005af6:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80005af8:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80005afc:	58 0a       	cp.w	r10,0
80005afe:	c0 91       	brne	80005b10 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005b00:	49 59       	lddpc	r9,80005b54 <INTC_register_interrupt+0x6c>
80005b02:	49 6a       	lddpc	r10,80005b58 <INTC_register_interrupt+0x70>
80005b04:	12 1a       	sub	r10,r9
80005b06:	fe 79 08 00 	mov	r9,-63488
80005b0a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005b0e:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005b10:	58 1a       	cp.w	r10,1
80005b12:	c0 a1       	brne	80005b26 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80005b14:	49 09       	lddpc	r9,80005b54 <INTC_register_interrupt+0x6c>
80005b16:	49 2a       	lddpc	r10,80005b5c <INTC_register_interrupt+0x74>
80005b18:	12 1a       	sub	r10,r9
80005b1a:	bf aa       	sbr	r10,0x1e
80005b1c:	fe 79 08 00 	mov	r9,-63488
80005b20:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005b24:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80005b26:	58 2a       	cp.w	r10,2
80005b28:	c0 a1       	brne	80005b3c <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80005b2a:	48 b9       	lddpc	r9,80005b54 <INTC_register_interrupt+0x6c>
80005b2c:	48 da       	lddpc	r10,80005b60 <INTC_register_interrupt+0x78>
80005b2e:	12 1a       	sub	r10,r9
80005b30:	bf ba       	sbr	r10,0x1f
80005b32:	fe 79 08 00 	mov	r9,-63488
80005b36:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005b3a:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80005b3c:	48 69       	lddpc	r9,80005b54 <INTC_register_interrupt+0x6c>
80005b3e:	48 aa       	lddpc	r10,80005b64 <INTC_register_interrupt+0x7c>
80005b40:	12 1a       	sub	r10,r9
80005b42:	ea 1a c0 00 	orh	r10,0xc000
80005b46:	fe 79 08 00 	mov	r9,-63488
80005b4a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005b4e:	5e fc       	retal	r12
80005b50:	80 00       	ld.sh	r0,r0[0x0]
80005b52:	e0 ac       	*unknown*
80005b54:	80 00       	ld.sh	r0,r0[0x0]
80005b56:	d4 00       	acall	0x40
80005b58:	80 00       	ld.sh	r0,r0[0x0]
80005b5a:	d5 04       	*unknown*
80005b5c:	80 00       	ld.sh	r0,r0[0x0]
80005b5e:	d5 12       	popm	r0-r3,r11,lr
80005b60:	80 00       	ld.sh	r0,r0[0x0]
80005b62:	d5 20       	acall	0x52
80005b64:	80 00       	ld.sh	r0,r0[0x0]
80005b66:	d5 2e       	*unknown*

80005b68 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80005b68:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005b6a:	49 18       	lddpc	r8,80005bac <INTC_init_interrupts+0x44>
80005b6c:	e3 b8 00 01 	mtsr	0x4,r8
80005b70:	49 0e       	lddpc	lr,80005bb0 <INTC_init_interrupts+0x48>
80005b72:	30 07       	mov	r7,0
80005b74:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005b76:	49 0c       	lddpc	r12,80005bb4 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005b78:	49 05       	lddpc	r5,80005bb8 <INTC_init_interrupts+0x50>
80005b7a:	10 15       	sub	r5,r8
80005b7c:	fe 76 08 00 	mov	r6,-63488
80005b80:	c1 08       	rjmp	80005ba0 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005b82:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80005b84:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005b86:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005b88:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80005b8c:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005b8e:	10 3a       	cp.w	r10,r8
80005b90:	fe 9b ff fc 	brhi	80005b88 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005b94:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80005b98:	2f f7       	sub	r7,-1
80005b9a:	2f 8e       	sub	lr,-8
80005b9c:	59 37       	cp.w	r7,19
80005b9e:	c0 50       	breq	80005ba8 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005ba0:	7c 08       	ld.w	r8,lr[0x0]
80005ba2:	58 08       	cp.w	r8,0
80005ba4:	ce f1       	brne	80005b82 <INTC_init_interrupts+0x1a>
80005ba6:	cf 7b       	rjmp	80005b94 <INTC_init_interrupts+0x2c>
80005ba8:	d8 22       	popm	r4-r7,pc
80005baa:	00 00       	add	r0,r0
80005bac:	80 00       	ld.sh	r0,r0[0x0]
80005bae:	d4 00       	acall	0x40
80005bb0:	80 00       	ld.sh	r0,r0[0x0]
80005bb2:	e0 ac       	*unknown*
80005bb4:	80 00       	ld.sh	r0,r0[0x0]
80005bb6:	5a e4       	cp.w	r4,-18
80005bb8:	80 00       	ld.sh	r0,r0[0x0]
80005bba:	d5 04       	*unknown*

80005bbc <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005bbc:	fe 78 08 00 	mov	r8,-63488
80005bc0:	e0 69 00 83 	mov	r9,131
80005bc4:	f2 0c 01 0c 	sub	r12,r9,r12
80005bc8:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005bcc:	f2 ca ff c0 	sub	r10,r9,-64
80005bd0:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005bd4:	58 08       	cp.w	r8,0
80005bd6:	c0 21       	brne	80005bda <_get_interrupt_handler+0x1e>
80005bd8:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80005bda:	f0 08 12 00 	clz	r8,r8
80005bde:	48 5a       	lddpc	r10,80005bf0 <_get_interrupt_handler+0x34>
80005be0:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005be4:	f0 08 11 1f 	rsub	r8,r8,31
80005be8:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005bea:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80005bee:	5e fc       	retal	r12
80005bf0:	80 00       	ld.sh	r0,r0[0x0]
80005bf2:	e0 ac       	*unknown*

80005bf4 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80005bf4:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
80005bf6:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80005bfa:	99 a8       	st.w	r12[0x28],r8
}
80005bfc:	5e fc       	retal	r12
80005bfe:	d7 03       	nop

80005c00 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80005c00:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80005c02:	ec 5b bb 9f 	cp.w	r11,899999
80005c06:	e0 8b 00 04 	brhi	80005c0e <pm_enable_osc0_crystal+0xe>
80005c0a:	30 4b       	mov	r11,4
80005c0c:	c1 38       	rjmp	80005c32 <pm_enable_osc0_crystal+0x32>
80005c0e:	e0 68 c6 bf 	mov	r8,50879
80005c12:	ea 18 00 2d 	orh	r8,0x2d
80005c16:	10 3b       	cp.w	r11,r8
80005c18:	e0 8b 00 04 	brhi	80005c20 <pm_enable_osc0_crystal+0x20>
80005c1c:	30 5b       	mov	r11,5
80005c1e:	c0 a8       	rjmp	80005c32 <pm_enable_osc0_crystal+0x32>
80005c20:	e0 68 12 00 	mov	r8,4608
80005c24:	ea 18 00 7a 	orh	r8,0x7a
80005c28:	10 3b       	cp.w	r11,r8
80005c2a:	f9 bb 03 06 	movlo	r11,6
80005c2e:	f9 bb 02 07 	movhs	r11,7
80005c32:	f0 1f 00 02 	mcall	80005c38 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80005c36:	d8 02       	popm	pc
80005c38:	80 00       	ld.sh	r0,r0[0x0]
80005c3a:	5b f4       	cp.w	r4,-1

80005c3c <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80005c3c:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80005c3e:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80005c42:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80005c44:	78 08       	ld.w	r8,r12[0x0]
80005c46:	a3 a8       	sbr	r8,0x2
80005c48:	99 08       	st.w	r12[0x0],r8
}
80005c4a:	5e fc       	retal	r12

80005c4c <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80005c4c:	79 58       	ld.w	r8,r12[0x54]
80005c4e:	e2 18 00 80 	andl	r8,0x80,COH
80005c52:	cf d0       	breq	80005c4c <pm_wait_for_clk0_ready>
}
80005c54:	5e fc       	retal	r12
80005c56:	d7 03       	nop

80005c58 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80005c58:	eb cd 40 80 	pushm	r7,lr
80005c5c:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
80005c5e:	f0 1f 00 04 	mcall	80005c6c <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
80005c62:	0e 9c       	mov	r12,r7
80005c64:	f0 1f 00 03 	mcall	80005c70 <pm_enable_clk0+0x18>
}
80005c68:	e3 cd 80 80 	ldm	sp++,r7,pc
80005c6c:	80 00       	ld.sh	r0,r0[0x0]
80005c6e:	5c 3c       	neg	r12
80005c70:	80 00       	ld.sh	r0,r0[0x0]
80005c72:	5c 4c       	abs	r12

80005c74 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
80005c74:	eb cd 40 d0 	pushm	r4,r6-r7,lr
80005c78:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80005c7c:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
80005c7e:	09 f7       	ld.ub	r7,r4[0x7]
80005c80:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
80005c84:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
80005c88:	09 b4       	ld.ub	r4,r4[0x3]
80005c8a:	08 96       	mov	r6,r4
80005c8c:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
80005c90:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
80005c94:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
80005c98:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
80005c9c:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
80005ca0:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
80005ca4:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
80005ca8:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
80005cac:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
80005cae:	79 58       	ld.w	r8,r12[0x54]
80005cb0:	e2 18 00 20 	andl	r8,0x20,COH
80005cb4:	cf d0       	breq	80005cae <pm_cksel+0x3a>
}
80005cb6:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

80005cba <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
80005cba:	eb cd 40 80 	pushm	r7,lr
80005cbe:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
80005cc0:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
80005cc2:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
80005cc6:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
80005cca:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
80005cce:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
80005cd2:	2f 8b       	sub	r11,-8
80005cd4:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80005cd8:	e3 cd 80 80 	ldm	sp++,r7,pc

80005cdc <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80005cdc:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
80005cde:	2f 8b       	sub	r11,-8
80005ce0:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
80005ce4:	f5 e9 10 19 	or	r9,r10,r9<<0x1
80005ce8:	f3 e8 10 28 	or	r8,r9,r8<<0x2
80005cec:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
80005cf0:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80005cf4:	d8 02       	popm	pc

80005cf6 <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
80005cf6:	2f 8b       	sub	r11,-8
80005cf8:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
80005cfc:	a1 a8       	sbr	r8,0x0
80005cfe:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
80005d02:	5e fc       	retal	r12

80005d04 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80005d04:	79 58       	ld.w	r8,r12[0x54]
80005d06:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005d0a:	cf d0       	breq	80005d04 <pm_wait_for_pll0_locked>
}
80005d0c:	5e fc       	retal	r12

80005d0e <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80005d0e:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80005d10:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80005d14:	99 08       	st.w	r12[0x0],r8
}
80005d16:	5e fc       	retal	r12

80005d18 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80005d18:	eb cd 40 c0 	pushm	r6-r7,lr
80005d1c:	18 97       	mov	r7,r12
80005d1e:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80005d20:	f0 1f 00 06 	mcall	80005d38 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80005d24:	0c 9b       	mov	r11,r6
80005d26:	0e 9c       	mov	r12,r7
80005d28:	f0 1f 00 05 	mcall	80005d3c <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80005d2c:	30 1b       	mov	r11,1
80005d2e:	0e 9c       	mov	r12,r7
80005d30:	f0 1f 00 04 	mcall	80005d40 <pm_switch_to_osc0+0x28>
}
80005d34:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005d38:	80 00       	ld.sh	r0,r0[0x0]
80005d3a:	5c 00       	acr	r0
80005d3c:	80 00       	ld.sh	r0,r0[0x0]
80005d3e:	5c 58       	castu.b	r8
80005d40:	80 00       	ld.sh	r0,r0[0x0]
80005d42:	5d 0e       	ror	lr

80005d44 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80005d44:	f8 c8 00 01 	sub	r8,r12,1
80005d48:	f0 0b 00 0b 	add	r11,r8,r11
80005d4c:	f6 0c 0d 0a 	divu	r10,r11,r12
80005d50:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80005d52:	f4 c8 00 01 	sub	r8,r10,1
80005d56:	e0 48 00 fe 	cp.w	r8,254
80005d5a:	e0 88 00 03 	brls	80005d60 <getBaudDiv+0x1c>
80005d5e:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80005d60:	5c 8c       	casts.h	r12
}
80005d62:	5e fc       	retal	r12

80005d64 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80005d64:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005d68:	30 18       	mov	r8,1
80005d6a:	f0 09 18 00 	cp.b	r9,r8
80005d6e:	e0 88 00 04 	brls	80005d76 <spi_initMaster+0x12>
80005d72:	30 2c       	mov	r12,2
80005d74:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
80005d76:	e0 68 00 80 	mov	r8,128
80005d7a:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80005d7c:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
80005d7e:	30 19       	mov	r9,1
80005d80:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80005d84:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005d88:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80005d8c:	30 09       	mov	r9,0
80005d8e:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80005d92:	30 fa       	mov	r10,15
80005d94:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80005d98:	99 18       	st.w	r12[0x4],r8
80005d9a:	5e f9       	retal	r9

80005d9c <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80005d9c:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80005d9e:	30 18       	mov	r8,1
80005da0:	f0 0b 18 00 	cp.b	r11,r8
80005da4:	5f be       	srhi	lr
80005da6:	f0 0a 18 00 	cp.b	r10,r8
80005daa:	5f b8       	srhi	r8
80005dac:	fd e8 10 08 	or	r8,lr,r8
80005db0:	c0 30       	breq	80005db6 <spi_selectionMode+0x1a>
80005db2:	30 2c       	mov	r12,2
80005db4:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80005db6:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80005db8:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005dbc:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80005dc0:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80005dc4:	99 18       	st.w	r12[0x4],r8
80005dc6:	d8 0a       	popm	pc,r12=0

80005dc8 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80005dc8:	30 18       	mov	r8,1
80005dca:	99 08       	st.w	r12[0x0],r8
}
80005dcc:	5e fc       	retal	r12

80005dce <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80005dce:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005dd2:	c0 58       	rjmp	80005ddc <spi_write+0xe>
		if (!timeout--) {
80005dd4:	58 08       	cp.w	r8,0
80005dd6:	c0 21       	brne	80005dda <spi_write+0xc>
80005dd8:	5e ff       	retal	1
80005dda:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005ddc:	78 49       	ld.w	r9,r12[0x10]
80005dde:	e2 19 00 02 	andl	r9,0x2,COH
80005de2:	cf 90       	breq	80005dd4 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005de4:	5c 7b       	castu.h	r11
80005de6:	99 3b       	st.w	r12[0xc],r11
80005de8:	5e fd       	retal	0

80005dea <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80005dea:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005dee:	c0 58       	rjmp	80005df8 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80005df0:	58 08       	cp.w	r8,0
80005df2:	c0 21       	brne	80005df6 <spi_read+0xc>
80005df4:	5e ff       	retal	1
80005df6:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005df8:	78 49       	ld.w	r9,r12[0x10]
80005dfa:	e2 19 02 01 	andl	r9,0x201,COH
80005dfe:	e0 49 02 01 	cp.w	r9,513
80005e02:	cf 71       	brne	80005df0 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005e04:	78 28       	ld.w	r8,r12[0x8]
80005e06:	b6 08       	st.h	r11[0x0],r8
80005e08:	5e fd       	retal	0
80005e0a:	d7 03       	nop

80005e0c <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80005e0c:	eb cd 40 f8 	pushm	r3-r7,lr
80005e10:	18 95       	mov	r5,r12
80005e12:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005e14:	f7 36 00 0c 	ld.ub	r6,r11[12]
80005e18:	30 38       	mov	r8,3
80005e1a:	f0 06 18 00 	cp.b	r6,r8
80005e1e:	e0 8b 00 5e 	brhi	80005eda <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
80005e22:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005e26:	30 18       	mov	r8,1
80005e28:	f0 04 18 00 	cp.b	r4,r8
80005e2c:	e0 8b 00 57 	brhi	80005eda <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80005e30:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005e34:	30 78       	mov	r8,7
80005e36:	f0 03 18 00 	cp.b	r3,r8
80005e3a:	e0 88 00 50 	brls	80005eda <spi_setupChipReg+0xce>
80005e3e:	31 08       	mov	r8,16
80005e40:	f0 03 18 00 	cp.b	r3,r8
80005e44:	e0 8b 00 4b 	brhi	80005eda <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80005e48:	14 9b       	mov	r11,r10
80005e4a:	6e 1c       	ld.w	r12,r7[0x4]
80005e4c:	f0 1f 00 26 	mcall	80005ee4 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
80005e50:	c4 55       	brlt	80005eda <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80005e52:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80005e54:	ec 09 16 01 	lsr	r9,r6,0x1
80005e58:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80005e5c:	ec 16 00 01 	eorl	r6,0x1
80005e60:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80005e64:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80005e68:	20 83       	sub	r3,8
80005e6a:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80005e6e:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80005e72:	ef 39 00 09 	ld.ub	r9,r7[9]
80005e76:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80005e7a:	ef 39 00 0a 	ld.ub	r9,r7[10]
80005e7e:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80005e82:	0f 89       	ld.ub	r9,r7[0x0]
80005e84:	30 1a       	mov	r10,1
80005e86:	f4 09 18 00 	cp.b	r9,r10
80005e8a:	c0 d0       	breq	80005ea4 <spi_setupChipReg+0x98>
80005e8c:	c0 a3       	brcs	80005ea0 <spi_setupChipReg+0x94>
80005e8e:	30 2a       	mov	r10,2
80005e90:	f4 09 18 00 	cp.b	r9,r10
80005e94:	c0 a0       	breq	80005ea8 <spi_setupChipReg+0x9c>
80005e96:	30 3a       	mov	r10,3
80005e98:	f4 09 18 00 	cp.b	r9,r10
80005e9c:	c1 f1       	brne	80005eda <spi_setupChipReg+0xce>
80005e9e:	c0 78       	rjmp	80005eac <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80005ea0:	8b c8       	st.w	r5[0x30],r8
		break;
80005ea2:	c0 68       	rjmp	80005eae <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80005ea4:	8b d8       	st.w	r5[0x34],r8
		break;
80005ea6:	c0 48       	rjmp	80005eae <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80005ea8:	8b e8       	st.w	r5[0x38],r8
		break;
80005eaa:	c0 28       	rjmp	80005eae <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80005eac:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80005eae:	48 f8       	lddpc	r8,80005ee8 <spi_setupChipReg+0xdc>
80005eb0:	70 08       	ld.w	r8,r8[0x0]
80005eb2:	58 08       	cp.w	r8,0
80005eb4:	c1 61       	brne	80005ee0 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
80005eb6:	30 0b       	mov	r11,0
80005eb8:	30 1c       	mov	r12,1
80005eba:	f0 1f 00 0d 	mcall	80005eec <spi_setupChipReg+0xe0>
80005ebe:	48 b8       	lddpc	r8,80005ee8 <spi_setupChipReg+0xdc>
80005ec0:	91 0c       	st.w	r8[0x0],r12
80005ec2:	58 0c       	cp.w	r12,0
80005ec4:	c0 a0       	breq	80005ed8 <spi_setupChipReg+0xcc>
80005ec6:	30 09       	mov	r9,0
80005ec8:	12 9a       	mov	r10,r9
80005eca:	12 9b       	mov	r11,r9
80005ecc:	f0 1f 00 09 	mcall	80005ef0 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80005ed0:	48 68       	lddpc	r8,80005ee8 <spi_setupChipReg+0xdc>
80005ed2:	70 08       	ld.w	r8,r8[0x0]
80005ed4:	58 08       	cp.w	r8,0
80005ed6:	c0 51       	brne	80005ee0 <spi_setupChipReg+0xd4>
80005ed8:	c0 08       	rjmp	80005ed8 <spi_setupChipReg+0xcc>
80005eda:	30 2c       	mov	r12,2
80005edc:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005ee0:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005ee4:	80 00       	ld.sh	r0,r0[0x0]
80005ee6:	5d 44       	*unknown*
80005ee8:	00 00       	add	r0,r0
80005eea:	54 24       	stdsp	sp[0x108],r4
80005eec:	80 00       	ld.sh	r0,r0[0x0]
80005eee:	6a 30       	ld.w	r0,r5[0xc]
80005ef0:	80 00       	ld.sh	r0,r0[0x0]
80005ef2:	68 d8       	ld.w	r8,r4[0x34]

80005ef4 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005ef4:	d4 01       	pushm	lr
80005ef6:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005efa:	c0 58       	rjmp	80005f04 <spi_unselectChip+0x10>
		if (!timeout--) {
80005efc:	58 08       	cp.w	r8,0
80005efe:	c0 21       	brne	80005f02 <spi_unselectChip+0xe>
80005f00:	da 0a       	popm	pc,r12=1
80005f02:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005f04:	78 49       	ld.w	r9,r12[0x10]
80005f06:	e2 19 02 00 	andl	r9,0x200,COH
80005f0a:	cf 90       	breq	80005efc <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005f0c:	78 18       	ld.w	r8,r12[0x4]
80005f0e:	ea 18 00 0f 	orh	r8,0xf
80005f12:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80005f14:	fc 18 01 00 	movh	r8,0x100
80005f18:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80005f1a:	30 09       	mov	r9,0
80005f1c:	12 9a       	mov	r10,r9
80005f1e:	12 9b       	mov	r11,r9
80005f20:	48 38       	lddpc	r8,80005f2c <spi_unselectChip+0x38>
80005f22:	70 0c       	ld.w	r12,r8[0x0]
80005f24:	f0 1f 00 03 	mcall	80005f30 <spi_unselectChip+0x3c>
80005f28:	d8 0a       	popm	pc,r12=0
80005f2a:	00 00       	add	r0,r0
80005f2c:	00 00       	add	r0,r0
80005f2e:	54 24       	stdsp	sp[0x108],r4
80005f30:	80 00       	ld.sh	r0,r0[0x0]
80005f32:	68 d8       	ld.w	r8,r4[0x34]

80005f34 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005f34:	eb cd 40 f8 	pushm	r3-r7,lr
80005f38:	18 94       	mov	r4,r12
80005f3a:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80005f3c:	49 a6       	lddpc	r6,80005fa4 <spi_selectChip+0x70>
80005f3e:	30 07       	mov	r7,0
80005f40:	31 45       	mov	r5,20
80005f42:	0e 99       	mov	r9,r7
80005f44:	0a 9a       	mov	r10,r5
80005f46:	0e 9b       	mov	r11,r7
80005f48:	6c 0c       	ld.w	r12,r6[0x0]
80005f4a:	f0 1f 00 18 	mcall	80005fa8 <spi_selectChip+0x74>
80005f4e:	cf a0       	breq	80005f42 <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005f50:	68 18       	ld.w	r8,r4[0x4]
80005f52:	ea 18 00 0f 	orh	r8,0xf
80005f56:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005f58:	68 18       	ld.w	r8,r4[0x4]
80005f5a:	e2 18 00 04 	andl	r8,0x4,COH
80005f5e:	c1 10       	breq	80005f80 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80005f60:	30 e8       	mov	r8,14
80005f62:	f0 03 18 00 	cp.b	r3,r8
80005f66:	e0 8b 00 1c 	brhi	80005f9e <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80005f6a:	68 19       	ld.w	r9,r4[0x4]
80005f6c:	e6 08 15 10 	lsl	r8,r3,0x10
80005f70:	ea 18 ff f0 	orh	r8,0xfff0
80005f74:	e8 18 ff ff 	orl	r8,0xffff
80005f78:	12 68       	and	r8,r9
80005f7a:	89 18       	st.w	r4[0x4],r8
80005f7c:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80005f80:	30 38       	mov	r8,3
80005f82:	f0 03 18 00 	cp.b	r3,r8
80005f86:	e0 8b 00 0c 	brhi	80005f9e <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005f8a:	68 19       	ld.w	r9,r4[0x4]
80005f8c:	2f 03       	sub	r3,-16
80005f8e:	30 18       	mov	r8,1
80005f90:	f0 03 09 48 	lsl	r8,r8,r3
80005f94:	5c d8       	com	r8
80005f96:	12 68       	and	r8,r9
80005f98:	89 18       	st.w	r4[0x4],r8
80005f9a:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005f9e:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80005fa0:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005fa4:	00 00       	add	r0,r0
80005fa6:	54 24       	stdsp	sp[0x108],r4
80005fa8:	80 00       	ld.sh	r0,r0[0x0]
80005faa:	66 cc       	ld.w	r12,r3[0x30]

80005fac <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005fac:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005fae:	f6 08 15 04 	lsl	r8,r11,0x4
80005fb2:	14 38       	cp.w	r8,r10
80005fb4:	f9 b8 08 10 	movls	r8,16
80005fb8:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005fbc:	f0 0b 02 4b 	mul	r11,r8,r11
80005fc0:	f6 09 16 01 	lsr	r9,r11,0x1
80005fc4:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80005fc8:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005fcc:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005fd0:	f2 cb 00 01 	sub	r11,r9,1
80005fd4:	e0 4b ff fe 	cp.w	r11,65534
80005fd8:	e0 88 00 03 	brls	80005fde <usart_set_async_baudrate+0x32>
80005fdc:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005fde:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005fe0:	e8 6e 00 00 	mov	lr,524288
80005fe4:	59 08       	cp.w	r8,16
80005fe6:	fc 08 17 10 	movne	r8,lr
80005fea:	f9 b8 00 00 	moveq	r8,0
80005fee:	e4 1b ff f7 	andh	r11,0xfff7
80005ff2:	e0 1b fe cf 	andl	r11,0xfecf
80005ff6:	16 48       	or	r8,r11
80005ff8:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005ffa:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005ffe:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80006002:	99 89       	st.w	r12[0x20],r9
80006004:	d8 0a       	popm	pc,r12=0

80006006 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80006006:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80006008:	e2 18 00 02 	andl	r8,0x2,COH
8000600c:	c0 31       	brne	80006012 <usart_write_char+0xc>
8000600e:	30 2c       	mov	r12,2
80006010:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80006012:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80006016:	99 7b       	st.w	r12[0x1c],r11
80006018:	5e fd       	retal	0
8000601a:	d7 03       	nop

8000601c <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
8000601c:	eb cd 40 e0 	pushm	r5-r7,lr
80006020:	18 96       	mov	r6,r12
80006022:	16 95       	mov	r5,r11
80006024:	e0 67 27 0f 	mov	r7,9999
80006028:	c0 68       	rjmp	80006034 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
8000602a:	58 07       	cp.w	r7,0
8000602c:	c0 31       	brne	80006032 <usart_putchar+0x16>
8000602e:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80006032:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80006034:	0a 9b       	mov	r11,r5
80006036:	0c 9c       	mov	r12,r6
80006038:	f0 1f 00 03 	mcall	80006044 <usart_putchar+0x28>
8000603c:	cf 71       	brne	8000602a <usart_putchar+0xe>

  return USART_SUCCESS;
}
8000603e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006042:	00 00       	add	r0,r0
80006044:	80 00       	ld.sh	r0,r0[0x0]
80006046:	60 06       	ld.w	r6,r0[0x0]

80006048 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80006048:	78 58       	ld.w	r8,r12[0x14]
8000604a:	e2 18 00 e0 	andl	r8,0xe0,COH
8000604e:	c0 30       	breq	80006054 <usart_read_char+0xc>
80006050:	30 4c       	mov	r12,4
80006052:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80006054:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80006056:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000605a:	c0 31       	brne	80006060 <usart_read_char+0x18>
8000605c:	30 3c       	mov	r12,3
8000605e:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80006060:	78 68       	ld.w	r8,r12[0x18]
80006062:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80006066:	97 08       	st.w	r11[0x0],r8
80006068:	5e fd       	retal	0
8000606a:	d7 03       	nop

8000606c <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
8000606c:	eb cd 40 c0 	pushm	r6-r7,lr
80006070:	20 1d       	sub	sp,4
80006072:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80006074:	1a 97       	mov	r7,sp
80006076:	1a 9b       	mov	r11,sp
80006078:	0c 9c       	mov	r12,r6
8000607a:	f0 1f 00 07 	mcall	80006094 <usart_getchar+0x28>
8000607e:	58 3c       	cp.w	r12,3
80006080:	cf b0       	breq	80006076 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80006082:	58 4c       	cp.w	r12,4
80006084:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80006088:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
8000608c:	2f fd       	sub	sp,-4
8000608e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006092:	00 00       	add	r0,r0
80006094:	80 00       	ld.sh	r0,r0[0x0]
80006096:	60 48       	ld.w	r8,r0[0x10]

80006098 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80006098:	eb cd 40 c0 	pushm	r6-r7,lr
8000609c:	18 96       	mov	r6,r12
8000609e:	16 97       	mov	r7,r11
  while (*string != '\0')
800060a0:	17 8b       	ld.ub	r11,r11[0x0]
800060a2:	58 0b       	cp.w	r11,0
800060a4:	c0 80       	breq	800060b4 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
800060a6:	2f f7       	sub	r7,-1
800060a8:	0c 9c       	mov	r12,r6
800060aa:	f0 1f 00 04 	mcall	800060b8 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800060ae:	0f 8b       	ld.ub	r11,r7[0x0]
800060b0:	58 0b       	cp.w	r11,0
800060b2:	cf a1       	brne	800060a6 <usart_write_line+0xe>
800060b4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800060b8:	80 00       	ld.sh	r0,r0[0x0]
800060ba:	60 1c       	ld.w	r12,r0[0x4]

800060bc <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800060bc:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
800060c0:	e6 18 00 01 	andh	r8,0x1,COH
800060c4:	c0 71       	brne	800060d2 <usart_reset+0x16>
800060c6:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
800060c8:	3f f8       	mov	r8,-1
800060ca:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800060cc:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800060ce:	d5 03       	csrf	0x10
800060d0:	c0 48       	rjmp	800060d8 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
800060d2:	3f f8       	mov	r8,-1
800060d4:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800060d6:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
800060d8:	30 08       	mov	r8,0
800060da:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
800060dc:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
800060de:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
800060e0:	ea 68 61 0c 	mov	r8,680204
800060e4:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
800060e6:	5e fc       	retal	r12

800060e8 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
800060e8:	eb cd 40 e0 	pushm	r5-r7,lr
800060ec:	18 96       	mov	r6,r12
800060ee:	16 97       	mov	r7,r11
800060f0:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
800060f2:	f0 1f 00 2f 	mcall	800061ac <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
800060f6:	58 07       	cp.w	r7,0
800060f8:	c5 80       	breq	800061a8 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
800060fa:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800060fc:	30 49       	mov	r9,4
800060fe:	f2 08 18 00 	cp.b	r8,r9
80006102:	e0 88 00 53 	brls	800061a8 <usart_init_rs232+0xc0>
80006106:	30 99       	mov	r9,9
80006108:	f2 08 18 00 	cp.b	r8,r9
8000610c:	e0 8b 00 4e 	brhi	800061a8 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80006110:	0f d9       	ld.ub	r9,r7[0x5]
80006112:	30 78       	mov	r8,7
80006114:	f0 09 18 00 	cp.b	r9,r8
80006118:	e0 8b 00 48 	brhi	800061a8 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
8000611c:	8e 39       	ld.sh	r9,r7[0x6]
8000611e:	e0 68 01 01 	mov	r8,257
80006122:	f0 09 19 00 	cp.h	r9,r8
80006126:	e0 8b 00 41 	brhi	800061a8 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
8000612a:	ef 39 00 08 	ld.ub	r9,r7[8]
8000612e:	30 38       	mov	r8,3
80006130:	f0 09 18 00 	cp.b	r9,r8
80006134:	e0 8b 00 3a 	brhi	800061a8 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80006138:	0a 9a       	mov	r10,r5
8000613a:	6e 0b       	ld.w	r11,r7[0x0]
8000613c:	0c 9c       	mov	r12,r6
8000613e:	f0 1f 00 1d 	mcall	800061b0 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80006142:	58 1c       	cp.w	r12,1
80006144:	c3 20       	breq	800061a8 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80006146:	0f c8       	ld.ub	r8,r7[0x4]
80006148:	30 99       	mov	r9,9
8000614a:	f2 08 18 00 	cp.b	r8,r9
8000614e:	c0 51       	brne	80006158 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80006150:	6c 18       	ld.w	r8,r6[0x4]
80006152:	b1 b8       	sbr	r8,0x11
80006154:	8d 18       	st.w	r6[0x4],r8
80006156:	c0 68       	rjmp	80006162 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80006158:	6c 19       	ld.w	r9,r6[0x4]
8000615a:	20 58       	sub	r8,5
8000615c:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80006160:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80006162:	6c 19       	ld.w	r9,r6[0x4]
80006164:	ef 3a 00 08 	ld.ub	r10,r7[8]
80006168:	0f d8       	ld.ub	r8,r7[0x5]
8000616a:	a9 78       	lsl	r8,0x9
8000616c:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80006170:	12 48       	or	r8,r9
80006172:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80006174:	8e 38       	ld.sh	r8,r7[0x6]
80006176:	30 29       	mov	r9,2
80006178:	f2 08 19 00 	cp.h	r8,r9
8000617c:	e0 88 00 09 	brls	8000618e <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80006180:	6c 18       	ld.w	r8,r6[0x4]
80006182:	ad b8       	sbr	r8,0xd
80006184:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80006186:	8e b8       	ld.uh	r8,r7[0x6]
80006188:	20 28       	sub	r8,2
8000618a:	8d a8       	st.w	r6[0x28],r8
8000618c:	c0 68       	rjmp	80006198 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
8000618e:	6c 19       	ld.w	r9,r6[0x4]
80006190:	5c 78       	castu.h	r8
80006192:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80006196:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80006198:	6c 18       	ld.w	r8,r6[0x4]
8000619a:	e0 18 ff f0 	andl	r8,0xfff0
8000619e:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
800061a0:	35 08       	mov	r8,80
800061a2:	8d 08       	st.w	r6[0x0],r8
800061a4:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
800061a8:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800061ac:	80 00       	ld.sh	r0,r0[0x0]
800061ae:	60 bc       	ld.w	r12,r0[0x2c]
800061b0:	80 00       	ld.sh	r0,r0[0x0]
800061b2:	5f ac       	srle	r12

800061b4 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
800061b4:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
800061b8:	fe c0 8d b8 	sub	r0,pc,-29256

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
800061bc:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
800061c0:	d5 53       	csrf	0x15
  cp      r0, r1
800061c2:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
800061c4:	e0 61 0a 50 	mov	r1,2640
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
800061c8:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
800061ca:	c0 62       	brcc	800061d6 <idata_load_loop_end>
  cp      r0, r1
800061cc:	48 92       	lddpc	r2,800061f0 <udata_clear_loop_end+0x4>

800061ce <idata_load_loop>:
  brlo    idata_load_loop
800061ce:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
800061d0:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
800061d2:	02 30       	cp.w	r0,r1
  cp      r0, r1
800061d4:	cf d3       	brcs	800061ce <idata_load_loop>

800061d6 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
800061d6:	e0 60 0a 50 	mov	r0,2640
  mov     r2, 0
  mov     r3, 0
800061da:	e0 61 54 38 	mov	r1,21560
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
800061de:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
800061e0:	c0 62       	brcc	800061ec <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
800061e2:	30 02       	mov	r2,0
800061e4:	30 03       	mov	r3,0

800061e6 <udata_clear_loop>:
800061e6:	a1 22       	st.d	r0++,r2
800061e8:	02 30       	cp.w	r0,r1
800061ea:	cf e3       	brcs	800061e6 <udata_clear_loop>

800061ec <udata_clear_loop_end>:
800061ec:	fe cf e7 b8 	sub	pc,pc,-6216
800061f0:	80 00       	ld.sh	r0,r0[0x0]
800061f2:	e9 e0 f8 c8 	sthh.w	r8[0x230],r4:t,r0:t

800061f4 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
800061f4:	f8 c8 ff f8 	sub	r8,r12,-8
800061f8:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
800061fa:	3f f9       	mov	r9,-1
800061fc:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
800061fe:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80006200:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80006202:	30 08       	mov	r8,0
80006204:	99 08       	st.w	r12[0x0],r8
}
80006206:	5e fc       	retal	r12

80006208 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80006208:	30 08       	mov	r8,0
8000620a:	99 48       	st.w	r12[0x10],r8
}
8000620c:	5e fc       	retal	r12

8000620e <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
8000620e:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80006210:	70 19       	ld.w	r9,r8[0x4]
80006212:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80006214:	78 19       	ld.w	r9,r12[0x4]
80006216:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80006218:	70 19       	ld.w	r9,r8[0x4]
8000621a:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
8000621c:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
8000621e:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80006220:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80006222:	78 08       	ld.w	r8,r12[0x0]
80006224:	2f f8       	sub	r8,-1
80006226:	99 08       	st.w	r12[0x0],r8
}
80006228:	5e fc       	retal	r12

8000622a <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
8000622a:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
8000622c:	5b fa       	cp.w	r10,-1
8000622e:	c0 31       	brne	80006234 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80006230:	78 48       	ld.w	r8,r12[0x10]
80006232:	c0 c8       	rjmp	8000624a <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80006234:	f8 c8 ff f8 	sub	r8,r12,-8
80006238:	70 19       	ld.w	r9,r8[0x4]
8000623a:	72 09       	ld.w	r9,r9[0x0]
8000623c:	12 3a       	cp.w	r10,r9
8000623e:	c0 63       	brcs	8000624a <vListInsert+0x20>
80006240:	70 18       	ld.w	r8,r8[0x4]
80006242:	70 19       	ld.w	r9,r8[0x4]
80006244:	72 09       	ld.w	r9,r9[0x0]
80006246:	12 3a       	cp.w	r10,r9
80006248:	cf c2       	brcc	80006240 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
8000624a:	70 19       	ld.w	r9,r8[0x4]
8000624c:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
8000624e:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80006250:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80006252:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80006254:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80006256:	78 08       	ld.w	r8,r12[0x0]
80006258:	2f f8       	sub	r8,-1
8000625a:	99 08       	st.w	r12[0x0],r8
}
8000625c:	5e fc       	retal	r12

8000625e <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
8000625e:	78 18       	ld.w	r8,r12[0x4]
80006260:	78 29       	ld.w	r9,r12[0x8]
80006262:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80006264:	78 28       	ld.w	r8,r12[0x8]
80006266:	78 19       	ld.w	r9,r12[0x4]
80006268:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
8000626a:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
8000626c:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
8000626e:	18 39       	cp.w	r9,r12
80006270:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80006274:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80006278:	30 09       	mov	r9,0
8000627a:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
8000627c:	70 09       	ld.w	r9,r8[0x0]
8000627e:	20 19       	sub	r9,1
80006280:	91 09       	st.w	r8[0x0],r9
}
80006282:	5e fc       	retal	r12

80006284 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80006284:	e0 68 08 08 	mov	r8,2056
80006288:	ea 18 08 08 	orh	r8,0x808
8000628c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
8000628e:	e0 68 09 09 	mov	r8,2313
80006292:	ea 18 09 09 	orh	r8,0x909
80006296:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80006298:	e0 68 0a 0a 	mov	r8,2570
8000629c:	ea 18 0a 0a 	orh	r8,0xa0a
800062a0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
800062a2:	e0 68 0b 0b 	mov	r8,2827
800062a6:	ea 18 0b 0b 	orh	r8,0xb0b
800062aa:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
800062ac:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
800062ae:	e0 68 be ef 	mov	r8,48879
800062b2:	ea 18 de ad 	orh	r8,0xdead
800062b6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
800062b8:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
800062ba:	fc 18 00 40 	movh	r8,0x40
800062be:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
800062c0:	e0 68 00 ff 	mov	r8,255
800062c4:	ea 18 ff 00 	orh	r8,0xff00
800062c8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
800062ca:	e0 68 01 01 	mov	r8,257
800062ce:	ea 18 01 01 	orh	r8,0x101
800062d2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
800062d4:	e0 68 02 02 	mov	r8,514
800062d8:	ea 18 02 02 	orh	r8,0x202
800062dc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
800062de:	e0 68 03 03 	mov	r8,771
800062e2:	ea 18 03 03 	orh	r8,0x303
800062e6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
800062e8:	e0 68 04 04 	mov	r8,1028
800062ec:	ea 18 04 04 	orh	r8,0x404
800062f0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
800062f2:	e0 68 05 05 	mov	r8,1285
800062f6:	ea 18 05 05 	orh	r8,0x505
800062fa:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
800062fc:	e0 68 06 06 	mov	r8,1542
80006300:	ea 18 06 06 	orh	r8,0x606
80006304:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80006306:	e0 68 07 07 	mov	r8,1799
8000630a:	ea 18 07 07 	orh	r8,0x707
8000630e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80006310:	30 08       	mov	r8,0
80006312:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80006314:	5e fc       	retal	r12
80006316:	d7 03       	nop

80006318 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80006318:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
8000631a:	48 38       	lddpc	r8,80006324 <vPortEnterCritical+0xc>
8000631c:	70 09       	ld.w	r9,r8[0x0]
8000631e:	2f f9       	sub	r9,-1
80006320:	91 09       	st.w	r8[0x0],r9
}
80006322:	5e fc       	retal	r12
80006324:	00 00       	add	r0,r0
80006326:	05 40       	ld.w	r0,--r2

80006328 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80006328:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
8000632a:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
8000632c:	30 0a       	mov	r10,0
8000632e:	14 9b       	mov	r11,r10
80006330:	49 2c       	lddpc	r12,80006378 <xPortStartScheduler+0x50>
80006332:	f0 1f 00 13 	mcall	8000637c <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80006336:	e0 68 5d c0 	mov	r8,24000
8000633a:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
8000633e:	30 08       	mov	r8,0
80006340:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80006344:	e0 68 0d 58 	mov	r8,3416
80006348:	ea 18 00 00 	orh	r8,0x0
8000634c:	70 00       	ld.w	r0,r8[0x0]
8000634e:	60 0d       	ld.w	sp,r0[0x0]
80006350:	1b 00       	ld.w	r0,sp++
80006352:	e0 68 05 40 	mov	r8,1344
80006356:	ea 18 00 00 	orh	r8,0x0
8000635a:	91 00       	st.w	r8[0x0],r0
8000635c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006360:	2f ed       	sub	sp,-8
80006362:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80006366:	fa f0 ff e0 	ld.w	r0,sp[-32]
8000636a:	e3 b0 00 00 	mtsr	0x0,r0
8000636e:	fa f0 ff dc 	ld.w	r0,sp[-36]
80006372:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80006376:	d8 0a       	popm	pc,r12=0
80006378:	80 00       	ld.sh	r0,r0[0x0]
8000637a:	64 44       	ld.w	r4,r2[0x10]
8000637c:	80 00       	ld.sh	r0,r0[0x0]
8000637e:	5a e8       	cp.w	r8,-18

80006380 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80006380:	20 6d       	sub	sp,24
80006382:	eb cd 00 ff 	pushm	r0-r7
80006386:	fa c7 ff c0 	sub	r7,sp,-64
8000638a:	ee f0 ff f8 	ld.w	r0,r7[-8]
8000638e:	ef 40 ff e0 	st.w	r7[-32],r0
80006392:	ee f0 ff fc 	ld.w	r0,r7[-4]
80006396:	ef 40 ff e4 	st.w	r7[-28],r0
8000639a:	eb c7 5f 00 	stm	--r7,r8-r12,lr
8000639e:	e0 68 05 40 	mov	r8,1344
800063a2:	ea 18 00 00 	orh	r8,0x0
800063a6:	70 00       	ld.w	r0,r8[0x0]
800063a8:	1a d0       	st.w	--sp,r0
800063aa:	f0 1f 00 1a 	mcall	80006410 <LABEL_RET_SCALL_263+0x14>
800063ae:	e0 68 0d 58 	mov	r8,3416
800063b2:	ea 18 00 00 	orh	r8,0x0
800063b6:	70 00       	ld.w	r0,r8[0x0]
800063b8:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
800063ba:	f0 1f 00 17 	mcall	80006414 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
800063be:	e0 68 0d 58 	mov	r8,3416
800063c2:	ea 18 00 00 	orh	r8,0x0
800063c6:	70 00       	ld.w	r0,r8[0x0]
800063c8:	60 0d       	ld.w	sp,r0[0x0]
800063ca:	1b 00       	ld.w	r0,sp++
800063cc:	e0 68 05 40 	mov	r8,1344
800063d0:	ea 18 00 00 	orh	r8,0x0
800063d4:	91 00       	st.w	r8[0x0],r0
800063d6:	fa c7 ff d8 	sub	r7,sp,-40
800063da:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
800063de:	ee f0 ff e0 	ld.w	r0,r7[-32]
800063e2:	e0 61 05 40 	mov	r1,1344
800063e6:	ea 11 00 00 	orh	r1,0x0
800063ea:	62 02       	ld.w	r2,r1[0x0]
800063ec:	58 02       	cp.w	r2,0
800063ee:	c0 70       	breq	800063fc <LABEL_RET_SCALL_263>
800063f0:	e4 c2 00 01 	sub	r2,r2,1
800063f4:	83 02       	st.w	r1[0x0],r2
800063f6:	58 02       	cp.w	r2,0
800063f8:	c0 21       	brne	800063fc <LABEL_RET_SCALL_263>
800063fa:	b1 c0       	cbr	r0,0x10

800063fc <LABEL_RET_SCALL_263>:
800063fc:	ef 40 ff f8 	st.w	r7[-8],r0
80006400:	ee f0 ff e4 	ld.w	r0,r7[-28]
80006404:	ef 40 ff fc 	st.w	r7[-4],r0
80006408:	e3 cd 00 ff 	ldm	sp++,r0-r7
8000640c:	2f ad       	sub	sp,-24
8000640e:	d6 13       	rets
80006410:	80 00       	ld.sh	r0,r0[0x0]
80006412:	63 18       	ld.w	r8,r1[0x44]
80006414:	80 00       	ld.sh	r0,r0[0x0]
80006416:	6a d4       	ld.w	r4,r5[0x34]

80006418 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80006418:	e1 b8 00 43 	mfsr	r8,0x10c
8000641c:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80006420:	5e fc       	retal	r12
80006422:	d7 03       	nop

80006424 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80006424:	48 78       	lddpc	r8,80006440 <vPortExitCritical+0x1c>
80006426:	70 08       	ld.w	r8,r8[0x0]
80006428:	58 08       	cp.w	r8,0
8000642a:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
8000642c:	48 58       	lddpc	r8,80006440 <vPortExitCritical+0x1c>
8000642e:	70 09       	ld.w	r9,r8[0x0]
80006430:	20 19       	sub	r9,1
80006432:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80006434:	70 08       	ld.w	r8,r8[0x0]
80006436:	58 08       	cp.w	r8,0
80006438:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
8000643a:	d5 03       	csrf	0x10
8000643c:	5e fc       	retal	r12
8000643e:	00 00       	add	r0,r0
80006440:	00 00       	add	r0,r0
80006442:	05 40       	ld.w	r0,--r2

80006444 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80006444:	eb cd 00 ff 	pushm	r0-r7
80006448:	e0 68 05 40 	mov	r8,1344
8000644c:	ea 18 00 00 	orh	r8,0x0
80006450:	70 00       	ld.w	r0,r8[0x0]
80006452:	1a d0       	st.w	--sp,r0
80006454:	7a 90       	ld.w	r0,sp[0x24]
80006456:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000645a:	58 10       	cp.w	r0,1
8000645c:	e0 8b 00 08 	brhi	8000646c <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80006460:	e0 68 0d 58 	mov	r8,3416
80006464:	ea 18 00 00 	orh	r8,0x0
80006468:	70 00       	ld.w	r0,r8[0x0]
8000646a:	81 0d       	st.w	r0[0x0],sp

8000646c <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
8000646c:	f0 1f 00 12 	mcall	800064b4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80006470:	f0 1f 00 12 	mcall	800064b8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80006474:	f0 1f 00 12 	mcall	800064bc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80006478:	f0 1f 00 12 	mcall	800064c0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
8000647c:	7a 90       	ld.w	r0,sp[0x24]
8000647e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80006482:	58 10       	cp.w	r0,1
80006484:	e0 8b 00 0e 	brhi	800064a0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80006488:	f0 1f 00 0c 	mcall	800064b8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
8000648c:	f0 1f 00 0e 	mcall	800064c4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80006490:	f0 1f 00 0c 	mcall	800064c0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80006494:	e0 68 0d 58 	mov	r8,3416
80006498:	ea 18 00 00 	orh	r8,0x0
8000649c:	70 00       	ld.w	r0,r8[0x0]
8000649e:	60 0d       	ld.w	sp,r0[0x0]

800064a0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
800064a0:	1b 00       	ld.w	r0,sp++
800064a2:	e0 68 05 40 	mov	r8,1344
800064a6:	ea 18 00 00 	orh	r8,0x0
800064aa:	91 00       	st.w	r8[0x0],r0
800064ac:	e3 cd 00 ff 	ldm	sp++,r0-r7
800064b0:	d6 03       	rete
800064b2:	00 00       	add	r0,r0
800064b4:	80 00       	ld.sh	r0,r0[0x0]
800064b6:	64 18       	ld.w	r8,r2[0x4]
800064b8:	80 00       	ld.sh	r0,r0[0x0]
800064ba:	63 18       	ld.w	r8,r1[0x44]
800064bc:	80 00       	ld.sh	r0,r0[0x0]
800064be:	6d 10       	ld.w	r0,r6[0x44]
800064c0:	80 00       	ld.sh	r0,r0[0x0]
800064c2:	64 24       	ld.w	r4,r2[0x8]
800064c4:	80 00       	ld.sh	r0,r0[0x0]
800064c6:	6a d4       	ld.w	r4,r5[0x34]

800064c8 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
800064c8:	d4 01       	pushm	lr
	vTaskSuspendAll();
800064ca:	f0 1f 00 02 	mcall	800064d0 <__malloc_lock+0x8>
}
800064ce:	d8 02       	popm	pc
800064d0:	80 00       	ld.sh	r0,r0[0x0]
800064d2:	6a c4       	ld.w	r4,r5[0x30]

800064d4 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
800064d4:	d4 01       	pushm	lr
	xTaskResumeAll();
800064d6:	f0 1f 00 02 	mcall	800064dc <__malloc_unlock+0x8>
}
800064da:	d8 02       	popm	pc
800064dc:	80 00       	ld.sh	r0,r0[0x0]
800064de:	6e b8       	ld.w	r8,r7[0x2c]

800064e0 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
800064e0:	d4 21       	pushm	r4-r7,lr
800064e2:	16 95       	mov	r5,r11
800064e4:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
800064e6:	58 0c       	cp.w	r12,0
800064e8:	c0 30       	breq	800064ee <_read+0xe>
800064ea:	3f f7       	mov	r7,-1
800064ec:	c1 48       	rjmp	80006514 <_read+0x34>
    return -1;

  for (; len > 0; --len)
800064ee:	58 0a       	cp.w	r10,0
800064f0:	e0 89 00 04 	brgt	800064f8 <_read+0x18>
800064f4:	30 07       	mov	r7,0
800064f6:	c0 f8       	rjmp	80006514 <_read+0x34>
800064f8:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
800064fa:	48 84       	lddpc	r4,80006518 <_read+0x38>
800064fc:	68 0c       	ld.w	r12,r4[0x0]
800064fe:	f0 1f 00 08 	mcall	8000651c <_read+0x3c>
    if (c < 0)
80006502:	c0 95       	brlt	80006514 <_read+0x34>
      break;

    *ptr++ = c;
80006504:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80006508:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
8000650a:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
8000650e:	58 08       	cp.w	r8,0
80006510:	fe 99 ff f6 	brgt	800064fc <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80006514:	0e 9c       	mov	r12,r7
80006516:	d8 22       	popm	r4-r7,pc
80006518:	00 00       	add	r0,r0
8000651a:	54 28       	stdsp	sp[0x108],r8
8000651c:	80 00       	ld.sh	r0,r0[0x0]
8000651e:	60 6c       	ld.w	r12,r0[0x18]

80006520 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80006520:	d4 21       	pushm	r4-r7,lr
80006522:	16 95       	mov	r5,r11
80006524:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80006526:	20 1c       	sub	r12,1
80006528:	58 2c       	cp.w	r12,2
8000652a:	e0 8b 00 12 	brhi	8000654e <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
8000652e:	58 0a       	cp.w	r10,0
80006530:	c0 31       	brne	80006536 <_write+0x16>
80006532:	30 07       	mov	r7,0
80006534:	c0 e8       	rjmp	80006550 <_write+0x30>
80006536:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80006538:	48 74       	lddpc	r4,80006554 <_write+0x34>
8000653a:	68 0c       	ld.w	r12,r4[0x0]
8000653c:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80006540:	f0 1f 00 06 	mcall	80006558 <_write+0x38>
80006544:	c0 55       	brlt	8000654e <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80006546:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006548:	0e 36       	cp.w	r6,r7
8000654a:	cf 81       	brne	8000653a <_write+0x1a>
8000654c:	c0 28       	rjmp	80006550 <_write+0x30>
8000654e:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80006550:	0e 9c       	mov	r12,r7
80006552:	d8 22       	popm	r4-r7,pc
80006554:	00 00       	add	r0,r0
80006556:	54 28       	stdsp	sp[0x108],r8
80006558:	80 00       	ld.sh	r0,r0[0x0]
8000655a:	60 1c       	ld.w	r12,r0[0x4]

8000655c <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
8000655c:	eb cd 40 80 	pushm	r7,lr
80006560:	18 97       	mov	r7,r12
	if( pv )
80006562:	58 0c       	cp.w	r12,0
80006564:	c0 80       	breq	80006574 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80006566:	f0 1f 00 05 	mcall	80006578 <vPortFree+0x1c>
		{
			free( pv );
8000656a:	0e 9c       	mov	r12,r7
8000656c:	f0 1f 00 04 	mcall	8000657c <vPortFree+0x20>
		}
		xTaskResumeAll();
80006570:	f0 1f 00 04 	mcall	80006580 <vPortFree+0x24>
80006574:	e3 cd 80 80 	ldm	sp++,r7,pc
80006578:	80 00       	ld.sh	r0,r0[0x0]
8000657a:	6a c4       	ld.w	r4,r5[0x30]
8000657c:	80 00       	ld.sh	r0,r0[0x0]
8000657e:	7a a4       	ld.w	r4,sp[0x28]
80006580:	80 00       	ld.sh	r0,r0[0x0]
80006582:	6e b8       	ld.w	r8,r7[0x2c]

80006584 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80006584:	eb cd 40 80 	pushm	r7,lr
80006588:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
8000658a:	f0 1f 00 06 	mcall	800065a0 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
8000658e:	0e 9c       	mov	r12,r7
80006590:	f0 1f 00 05 	mcall	800065a4 <pvPortMalloc+0x20>
80006594:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80006596:	f0 1f 00 05 	mcall	800065a8 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
8000659a:	0e 9c       	mov	r12,r7
8000659c:	e3 cd 80 80 	ldm	sp++,r7,pc
800065a0:	80 00       	ld.sh	r0,r0[0x0]
800065a2:	6a c4       	ld.w	r4,r5[0x30]
800065a4:	80 00       	ld.sh	r0,r0[0x0]
800065a6:	7a b4       	ld.w	r4,sp[0x2c]
800065a8:	80 00       	ld.sh	r0,r0[0x0]
800065aa:	6e b8       	ld.w	r8,r7[0x2c]

800065ac <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
800065ac:	d4 01       	pushm	lr
800065ae:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
800065b0:	78 09       	ld.w	r9,r12[0x0]
800065b2:	58 09       	cp.w	r9,0
800065b4:	c1 10       	breq	800065d6 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
800065b6:	78 3a       	ld.w	r10,r12[0xc]
800065b8:	79 09       	ld.w	r9,r12[0x40]
800065ba:	f4 09 00 09 	add	r9,r10,r9
800065be:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
800065c0:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
800065c2:	14 39       	cp.w	r9,r10
800065c4:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
800065c8:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
800065cc:	79 0a       	ld.w	r10,r12[0x40]
800065ce:	78 3b       	ld.w	r11,r12[0xc]
800065d0:	10 9c       	mov	r12,r8
800065d2:	f0 1f 00 02 	mcall	800065d8 <prvCopyDataFromQueue+0x2c>
800065d6:	d8 02       	popm	pc
800065d8:	80 00       	ld.sh	r0,r0[0x0]
800065da:	7f 22       	ld.w	r2,pc[0x48]

800065dc <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
800065dc:	eb cd 40 c0 	pushm	r6-r7,lr
800065e0:	18 97       	mov	r7,r12
800065e2:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800065e4:	78 e8       	ld.w	r8,r12[0x38]
800065e6:	58 08       	cp.w	r8,0
800065e8:	c0 31       	brne	800065ee <xQueueReceiveFromISR+0x12>
800065ea:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
800065ee:	f0 1f 00 0e 	mcall	80006624 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
800065f2:	6e e8       	ld.w	r8,r7[0x38]
800065f4:	20 18       	sub	r8,1
800065f6:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
800065f8:	6f 18       	ld.w	r8,r7[0x44]
800065fa:	5b f8       	cp.w	r8,-1
800065fc:	c0 d1       	brne	80006616 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800065fe:	6e 48       	ld.w	r8,r7[0x10]
80006600:	58 08       	cp.w	r8,0
80006602:	c0 f0       	breq	80006620 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006604:	ee cc ff f0 	sub	r12,r7,-16
80006608:	f0 1f 00 08 	mcall	80006628 <xQueueReceiveFromISR+0x4c>
8000660c:	c0 a0       	breq	80006620 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
8000660e:	30 1c       	mov	r12,1
80006610:	8d 0c       	st.w	r6[0x0],r12
80006612:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80006616:	2f f8       	sub	r8,-1
80006618:	ef 48 00 44 	st.w	r7[68],r8
8000661c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006620:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006624:	80 00       	ld.sh	r0,r0[0x0]
80006626:	65 ac       	ld.w	r12,r2[0x68]
80006628:	80 00       	ld.sh	r0,r0[0x0]
8000662a:	6c 94       	ld.w	r4,r6[0x24]

8000662c <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
8000662c:	eb cd 40 c0 	pushm	r6-r7,lr
80006630:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80006632:	f0 1f 00 23 	mcall	800066bc <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80006636:	6f 28       	ld.w	r8,r7[0x48]
80006638:	58 08       	cp.w	r8,0
8000663a:	e0 8a 00 18 	brle	8000666a <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000663e:	6e 98       	ld.w	r8,r7[0x24]
80006640:	58 08       	cp.w	r8,0
80006642:	c1 40       	breq	8000666a <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006644:	ee c6 ff dc 	sub	r6,r7,-36
80006648:	c0 48       	rjmp	80006650 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000664a:	6e 98       	ld.w	r8,r7[0x24]
8000664c:	58 08       	cp.w	r8,0
8000664e:	c0 e0       	breq	8000666a <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006650:	0c 9c       	mov	r12,r6
80006652:	f0 1f 00 1c 	mcall	800066c0 <prvUnlockQueue+0x94>
80006656:	c0 30       	breq	8000665c <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80006658:	f0 1f 00 1b 	mcall	800066c4 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
8000665c:	6f 28       	ld.w	r8,r7[0x48]
8000665e:	20 18       	sub	r8,1
80006660:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80006664:	58 08       	cp.w	r8,0
80006666:	fe 99 ff f2 	brgt	8000664a <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
8000666a:	3f f8       	mov	r8,-1
8000666c:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80006670:	f0 1f 00 16 	mcall	800066c8 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80006674:	f0 1f 00 12 	mcall	800066bc <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80006678:	6f 18       	ld.w	r8,r7[0x44]
8000667a:	58 08       	cp.w	r8,0
8000667c:	e0 8a 00 18 	brle	800066ac <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006680:	6e 48       	ld.w	r8,r7[0x10]
80006682:	58 08       	cp.w	r8,0
80006684:	c1 40       	breq	800066ac <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006686:	ee c6 ff f0 	sub	r6,r7,-16
8000668a:	c0 48       	rjmp	80006692 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000668c:	6e 48       	ld.w	r8,r7[0x10]
8000668e:	58 08       	cp.w	r8,0
80006690:	c0 e0       	breq	800066ac <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006692:	0c 9c       	mov	r12,r6
80006694:	f0 1f 00 0b 	mcall	800066c0 <prvUnlockQueue+0x94>
80006698:	c0 30       	breq	8000669e <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
8000669a:	f0 1f 00 0b 	mcall	800066c4 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
8000669e:	6f 18       	ld.w	r8,r7[0x44]
800066a0:	20 18       	sub	r8,1
800066a2:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800066a6:	58 08       	cp.w	r8,0
800066a8:	fe 99 ff f2 	brgt	8000668c <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
800066ac:	3f f8       	mov	r8,-1
800066ae:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
800066b2:	f0 1f 00 06 	mcall	800066c8 <prvUnlockQueue+0x9c>
}
800066b6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800066ba:	00 00       	add	r0,r0
800066bc:	80 00       	ld.sh	r0,r0[0x0]
800066be:	63 18       	ld.w	r8,r1[0x44]
800066c0:	80 00       	ld.sh	r0,r0[0x0]
800066c2:	6c 94       	ld.w	r4,r6[0x24]
800066c4:	80 00       	ld.sh	r0,r0[0x0]
800066c6:	6b 68       	ld.w	r8,r5[0x58]
800066c8:	80 00       	ld.sh	r0,r0[0x0]
800066ca:	64 24       	ld.w	r4,r2[0x8]

800066cc <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
800066cc:	d4 31       	pushm	r0-r7,lr
800066ce:	20 5d       	sub	sp,20
800066d0:	18 97       	mov	r7,r12
800066d2:	50 0b       	stdsp	sp[0x0],r11
800066d4:	50 2a       	stdsp	sp[0x8],r10
800066d6:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800066d8:	f8 c2 ff dc 	sub	r2,r12,-36
800066dc:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800066de:	fa c4 ff f4 	sub	r4,sp,-12
800066e2:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800066e4:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800066e6:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
800066ea:	f0 1f 00 3e 	mcall	800067e0 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800066ee:	6e e8       	ld.w	r8,r7[0x38]
800066f0:	58 08       	cp.w	r8,0
800066f2:	c2 a0       	breq	80006746 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800066f4:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800066f6:	40 0b       	lddsp	r11,sp[0x0]
800066f8:	0e 9c       	mov	r12,r7
800066fa:	f0 1f 00 3b 	mcall	800067e4 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
800066fe:	40 18       	lddsp	r8,sp[0x4]
80006700:	58 08       	cp.w	r8,0
80006702:	c1 51       	brne	8000672c <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80006704:	6e e8       	ld.w	r8,r7[0x38]
80006706:	20 18       	sub	r8,1
80006708:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000670a:	6e 08       	ld.w	r8,r7[0x0]
8000670c:	58 08       	cp.w	r8,0
8000670e:	c0 41       	brne	80006716 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80006710:	f0 1f 00 36 	mcall	800067e8 <xQueueGenericReceive+0x11c>
80006714:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006716:	6e 48       	ld.w	r8,r7[0x10]
80006718:	58 08       	cp.w	r8,0
8000671a:	c1 20       	breq	8000673e <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
8000671c:	ee cc ff f0 	sub	r12,r7,-16
80006720:	f0 1f 00 33 	mcall	800067ec <xQueueGenericReceive+0x120>
80006724:	58 1c       	cp.w	r12,1
80006726:	c0 c1       	brne	8000673e <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80006728:	d7 33       	scall
8000672a:	c0 a8       	rjmp	8000673e <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
8000672c:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000672e:	6e 98       	ld.w	r8,r7[0x24]
80006730:	58 08       	cp.w	r8,0
80006732:	c0 60       	breq	8000673e <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006734:	04 9c       	mov	r12,r2
80006736:	f0 1f 00 2e 	mcall	800067ec <xQueueGenericReceive+0x120>
8000673a:	c0 20       	breq	8000673e <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
8000673c:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
8000673e:	f0 1f 00 2d 	mcall	800067f0 <xQueueGenericReceive+0x124>
80006742:	30 1c       	mov	r12,1
				return pdPASS;
80006744:	c4 c8       	rjmp	800067dc <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80006746:	40 28       	lddsp	r8,sp[0x8]
80006748:	58 08       	cp.w	r8,0
8000674a:	c0 51       	brne	80006754 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8000674c:	f0 1f 00 29 	mcall	800067f0 <xQueueGenericReceive+0x124>
80006750:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80006752:	c4 58       	rjmp	800067dc <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80006754:	58 05       	cp.w	r5,0
80006756:	c0 51       	brne	80006760 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006758:	08 9c       	mov	r12,r4
8000675a:	f0 1f 00 27 	mcall	800067f4 <xQueueGenericReceive+0x128>
8000675e:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006760:	f0 1f 00 24 	mcall	800067f0 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006764:	f0 1f 00 25 	mcall	800067f8 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80006768:	f0 1f 00 1e 	mcall	800067e0 <xQueueGenericReceive+0x114>
8000676c:	6f 18       	ld.w	r8,r7[0x44]
8000676e:	5b f8       	cp.w	r8,-1
80006770:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006774:	6f 28       	ld.w	r8,r7[0x48]
80006776:	5b f8       	cp.w	r8,-1
80006778:	ef f1 0a 12 	st.weq	r7[0x48],r1
8000677c:	f0 1f 00 1d 	mcall	800067f0 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006780:	06 9b       	mov	r11,r3
80006782:	08 9c       	mov	r12,r4
80006784:	f0 1f 00 1e 	mcall	800067fc <xQueueGenericReceive+0x130>
80006788:	c2 41       	brne	800067d0 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000678a:	f0 1f 00 16 	mcall	800067e0 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
8000678e:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80006790:	f0 1f 00 18 	mcall	800067f0 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80006794:	58 06       	cp.w	r6,0
80006796:	c1 71       	brne	800067c4 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006798:	6e 08       	ld.w	r8,r7[0x0]
8000679a:	58 08       	cp.w	r8,0
8000679c:	c0 81       	brne	800067ac <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
8000679e:	f0 1f 00 11 	mcall	800067e0 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
800067a2:	6e 1c       	ld.w	r12,r7[0x4]
800067a4:	f0 1f 00 17 	mcall	80006800 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
800067a8:	f0 1f 00 12 	mcall	800067f0 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800067ac:	40 2b       	lddsp	r11,sp[0x8]
800067ae:	04 9c       	mov	r12,r2
800067b0:	f0 1f 00 15 	mcall	80006804 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
800067b4:	0e 9c       	mov	r12,r7
800067b6:	f0 1f 00 15 	mcall	80006808 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
800067ba:	f0 1f 00 15 	mcall	8000680c <xQueueGenericReceive+0x140>
800067be:	c9 61       	brne	800066ea <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
800067c0:	d7 33       	scall
800067c2:	c9 4b       	rjmp	800066ea <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800067c4:	0e 9c       	mov	r12,r7
800067c6:	f0 1f 00 11 	mcall	80006808 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
800067ca:	f0 1f 00 11 	mcall	8000680c <xQueueGenericReceive+0x140>
800067ce:	c8 eb       	rjmp	800066ea <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800067d0:	0e 9c       	mov	r12,r7
800067d2:	f0 1f 00 0e 	mcall	80006808 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
800067d6:	f0 1f 00 0e 	mcall	8000680c <xQueueGenericReceive+0x140>
800067da:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
800067dc:	2f bd       	sub	sp,-20
800067de:	d8 32       	popm	r0-r7,pc
800067e0:	80 00       	ld.sh	r0,r0[0x0]
800067e2:	63 18       	ld.w	r8,r1[0x44]
800067e4:	80 00       	ld.sh	r0,r0[0x0]
800067e6:	65 ac       	ld.w	r12,r2[0x68]
800067e8:	80 00       	ld.sh	r0,r0[0x0]
800067ea:	6b ac       	ld.w	r12,r5[0x68]
800067ec:	80 00       	ld.sh	r0,r0[0x0]
800067ee:	6c 94       	ld.w	r4,r6[0x24]
800067f0:	80 00       	ld.sh	r0,r0[0x0]
800067f2:	64 24       	ld.w	r4,r2[0x8]
800067f4:	80 00       	ld.sh	r0,r0[0x0]
800067f6:	6b 50       	ld.w	r0,r5[0x54]
800067f8:	80 00       	ld.sh	r0,r0[0x0]
800067fa:	6a c4       	ld.w	r4,r5[0x30]
800067fc:	80 00       	ld.sh	r0,r0[0x0]
800067fe:	6e 24       	ld.w	r4,r7[0x8]
80006800:	80 00       	ld.sh	r0,r0[0x0]
80006802:	6c 10       	ld.w	r0,r6[0x4]
80006804:	80 00       	ld.sh	r0,r0[0x0]
80006806:	71 dc       	ld.w	r12,r8[0x74]
80006808:	80 00       	ld.sh	r0,r0[0x0]
8000680a:	66 2c       	ld.w	r12,r3[0x8]
8000680c:	80 00       	ld.sh	r0,r0[0x0]
8000680e:	6e b8       	ld.w	r8,r7[0x2c]

80006810 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80006810:	eb cd 40 80 	pushm	r7,lr
80006814:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80006816:	79 08       	ld.w	r8,r12[0x40]
80006818:	58 08       	cp.w	r8,0
8000681a:	c0 a1       	brne	8000682e <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000681c:	78 08       	ld.w	r8,r12[0x0]
8000681e:	58 08       	cp.w	r8,0
80006820:	c2 b1       	brne	80006876 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80006822:	78 1c       	ld.w	r12,r12[0x4]
80006824:	f0 1f 00 17 	mcall	80006880 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80006828:	30 08       	mov	r8,0
8000682a:	8f 18       	st.w	r7[0x4],r8
8000682c:	c2 58       	rjmp	80006876 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
8000682e:	58 0a       	cp.w	r10,0
80006830:	c1 01       	brne	80006850 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006832:	10 9a       	mov	r10,r8
80006834:	78 2c       	ld.w	r12,r12[0x8]
80006836:	f0 1f 00 14 	mcall	80006884 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
8000683a:	6e 29       	ld.w	r9,r7[0x8]
8000683c:	6f 08       	ld.w	r8,r7[0x40]
8000683e:	f2 08 00 08 	add	r8,r9,r8
80006842:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80006844:	6e 19       	ld.w	r9,r7[0x4]
80006846:	12 38       	cp.w	r8,r9
80006848:	c1 73       	brcs	80006876 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
8000684a:	6e 08       	ld.w	r8,r7[0x0]
8000684c:	8f 28       	st.w	r7[0x8],r8
8000684e:	c1 48       	rjmp	80006876 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006850:	10 9a       	mov	r10,r8
80006852:	78 3c       	ld.w	r12,r12[0xc]
80006854:	f0 1f 00 0c 	mcall	80006884 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80006858:	6f 08       	ld.w	r8,r7[0x40]
8000685a:	6e 39       	ld.w	r9,r7[0xc]
8000685c:	f2 08 01 08 	sub	r8,r9,r8
80006860:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80006862:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80006864:	12 38       	cp.w	r8,r9
80006866:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
8000686a:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
8000686e:	f3 d8 e3 19 	subcs	r9,r9,r8
80006872:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80006876:	6e e8       	ld.w	r8,r7[0x38]
80006878:	2f f8       	sub	r8,-1
8000687a:	8f e8       	st.w	r7[0x38],r8
}
8000687c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006880:	80 00       	ld.sh	r0,r0[0x0]
80006882:	6b b8       	ld.w	r8,r5[0x6c]
80006884:	80 00       	ld.sh	r0,r0[0x0]
80006886:	7f 22       	ld.w	r2,pc[0x48]

80006888 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80006888:	eb cd 40 c0 	pushm	r6-r7,lr
8000688c:	18 97       	mov	r7,r12
8000688e:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006890:	78 ec       	ld.w	r12,r12[0x38]
80006892:	6e f8       	ld.w	r8,r7[0x3c]
80006894:	10 3c       	cp.w	r12,r8
80006896:	c0 33       	brcs	8000689c <xQueueGenericSendFromISR+0x14>
80006898:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
8000689c:	12 9a       	mov	r10,r9
8000689e:	0e 9c       	mov	r12,r7
800068a0:	f0 1f 00 0c 	mcall	800068d0 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
800068a4:	6f 28       	ld.w	r8,r7[0x48]
800068a6:	5b f8       	cp.w	r8,-1
800068a8:	c0 d1       	brne	800068c2 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800068aa:	6e 98       	ld.w	r8,r7[0x24]
800068ac:	58 08       	cp.w	r8,0
800068ae:	c0 f0       	breq	800068cc <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800068b0:	ee cc ff dc 	sub	r12,r7,-36
800068b4:	f0 1f 00 08 	mcall	800068d4 <xQueueGenericSendFromISR+0x4c>
800068b8:	c0 a0       	breq	800068cc <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
800068ba:	30 1c       	mov	r12,1
800068bc:	8d 0c       	st.w	r6[0x0],r12
800068be:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
800068c2:	2f f8       	sub	r8,-1
800068c4:	ef 48 00 48 	st.w	r7[72],r8
800068c8:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800068cc:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800068d0:	80 00       	ld.sh	r0,r0[0x0]
800068d2:	68 10       	ld.w	r0,r4[0x4]
800068d4:	80 00       	ld.sh	r0,r0[0x0]
800068d6:	6c 94       	ld.w	r4,r6[0x24]

800068d8 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
800068d8:	d4 31       	pushm	r0-r7,lr
800068da:	20 5d       	sub	sp,20
800068dc:	18 97       	mov	r7,r12
800068de:	50 0b       	stdsp	sp[0x0],r11
800068e0:	50 2a       	stdsp	sp[0x8],r10
800068e2:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800068e4:	f8 c0 ff f0 	sub	r0,r12,-16
800068e8:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800068ea:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800068ee:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800068f0:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
800068f4:	f0 1f 00 2f 	mcall	800069b0 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800068f8:	6e e9       	ld.w	r9,r7[0x38]
800068fa:	6e f8       	ld.w	r8,r7[0x3c]
800068fc:	10 39       	cp.w	r9,r8
800068fe:	c1 42       	brcc	80006926 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006900:	40 1a       	lddsp	r10,sp[0x4]
80006902:	40 0b       	lddsp	r11,sp[0x0]
80006904:	0e 9c       	mov	r12,r7
80006906:	f0 1f 00 2c 	mcall	800069b4 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000690a:	6e 98       	ld.w	r8,r7[0x24]
8000690c:	58 08       	cp.w	r8,0
8000690e:	c0 80       	breq	8000691e <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80006910:	ee cc ff dc 	sub	r12,r7,-36
80006914:	f0 1f 00 29 	mcall	800069b8 <xQueueGenericSend+0xe0>
80006918:	58 1c       	cp.w	r12,1
8000691a:	c0 21       	brne	8000691e <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
8000691c:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
8000691e:	f0 1f 00 28 	mcall	800069bc <xQueueGenericSend+0xe4>
80006922:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80006924:	c4 38       	rjmp	800069aa <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80006926:	40 28       	lddsp	r8,sp[0x8]
80006928:	58 08       	cp.w	r8,0
8000692a:	c0 51       	brne	80006934 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8000692c:	f0 1f 00 24 	mcall	800069bc <xQueueGenericSend+0xe4>
80006930:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80006932:	c3 c8       	rjmp	800069aa <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80006934:	58 04       	cp.w	r4,0
80006936:	c0 51       	brne	80006940 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006938:	06 9c       	mov	r12,r3
8000693a:	f0 1f 00 22 	mcall	800069c0 <xQueueGenericSend+0xe8>
8000693e:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006940:	f0 1f 00 1f 	mcall	800069bc <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006944:	f0 1f 00 20 	mcall	800069c4 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80006948:	f0 1f 00 1a 	mcall	800069b0 <xQueueGenericSend+0xd8>
8000694c:	6f 18       	ld.w	r8,r7[0x44]
8000694e:	5b f8       	cp.w	r8,-1
80006950:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006954:	6f 28       	ld.w	r8,r7[0x48]
80006956:	5b f8       	cp.w	r8,-1
80006958:	ef f1 0a 12 	st.weq	r7[0x48],r1
8000695c:	f0 1f 00 18 	mcall	800069bc <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006960:	04 9b       	mov	r11,r2
80006962:	06 9c       	mov	r12,r3
80006964:	f0 1f 00 19 	mcall	800069c8 <xQueueGenericSend+0xf0>
80006968:	c1 b1       	brne	8000699e <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000696a:	f0 1f 00 12 	mcall	800069b0 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
8000696e:	6e e5       	ld.w	r5,r7[0x38]
80006970:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80006972:	f0 1f 00 13 	mcall	800069bc <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80006976:	0c 35       	cp.w	r5,r6
80006978:	c0 d1       	brne	80006992 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000697a:	40 2b       	lddsp	r11,sp[0x8]
8000697c:	00 9c       	mov	r12,r0
8000697e:	f0 1f 00 14 	mcall	800069cc <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80006982:	0e 9c       	mov	r12,r7
80006984:	f0 1f 00 13 	mcall	800069d0 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80006988:	f0 1f 00 13 	mcall	800069d4 <xQueueGenericSend+0xfc>
8000698c:	cb 41       	brne	800068f4 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
8000698e:	d7 33       	scall
80006990:	cb 2b       	rjmp	800068f4 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006992:	0e 9c       	mov	r12,r7
80006994:	f0 1f 00 0f 	mcall	800069d0 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80006998:	f0 1f 00 0f 	mcall	800069d4 <xQueueGenericSend+0xfc>
8000699c:	ca cb       	rjmp	800068f4 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
8000699e:	0e 9c       	mov	r12,r7
800069a0:	f0 1f 00 0c 	mcall	800069d0 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800069a4:	f0 1f 00 0c 	mcall	800069d4 <xQueueGenericSend+0xfc>
800069a8:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
800069aa:	2f bd       	sub	sp,-20
800069ac:	d8 32       	popm	r0-r7,pc
800069ae:	00 00       	add	r0,r0
800069b0:	80 00       	ld.sh	r0,r0[0x0]
800069b2:	63 18       	ld.w	r8,r1[0x44]
800069b4:	80 00       	ld.sh	r0,r0[0x0]
800069b6:	68 10       	ld.w	r0,r4[0x4]
800069b8:	80 00       	ld.sh	r0,r0[0x0]
800069ba:	6c 94       	ld.w	r4,r6[0x24]
800069bc:	80 00       	ld.sh	r0,r0[0x0]
800069be:	64 24       	ld.w	r4,r2[0x8]
800069c0:	80 00       	ld.sh	r0,r0[0x0]
800069c2:	6b 50       	ld.w	r0,r5[0x54]
800069c4:	80 00       	ld.sh	r0,r0[0x0]
800069c6:	6a c4       	ld.w	r4,r5[0x30]
800069c8:	80 00       	ld.sh	r0,r0[0x0]
800069ca:	6e 24       	ld.w	r4,r7[0x8]
800069cc:	80 00       	ld.sh	r0,r0[0x0]
800069ce:	71 dc       	ld.w	r12,r8[0x74]
800069d0:	80 00       	ld.sh	r0,r0[0x0]
800069d2:	66 2c       	ld.w	r12,r3[0x8]
800069d4:	80 00       	ld.sh	r0,r0[0x0]
800069d6:	6e b8       	ld.w	r8,r7[0x2c]

800069d8 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
800069d8:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800069dc:	34 cc       	mov	r12,76
800069de:	f0 1f 00 12 	mcall	80006a24 <xQueueCreateMutex+0x4c>
800069e2:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
800069e4:	c1 d0       	breq	80006a1e <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
800069e6:	30 06       	mov	r6,0
800069e8:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
800069ea:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
800069ec:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
800069ee:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800069f0:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
800069f2:	30 18       	mov	r8,1
800069f4:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
800069f6:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
800069fa:	3f f8       	mov	r8,-1
800069fc:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80006a00:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80006a04:	2f 0c       	sub	r12,-16
80006a06:	f0 1f 00 09 	mcall	80006a28 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80006a0a:	ee cc ff dc 	sub	r12,r7,-36
80006a0e:	f0 1f 00 07 	mcall	80006a28 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
80006a12:	0c 99       	mov	r9,r6
80006a14:	0c 9a       	mov	r10,r6
80006a16:	0c 9b       	mov	r11,r6
80006a18:	0e 9c       	mov	r12,r7
80006a1a:	f0 1f 00 05 	mcall	80006a2c <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
80006a1e:	0e 9c       	mov	r12,r7
80006a20:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006a24:	80 00       	ld.sh	r0,r0[0x0]
80006a26:	65 84       	ld.w	r4,r2[0x60]
80006a28:	80 00       	ld.sh	r0,r0[0x0]
80006a2a:	61 f4       	ld.w	r4,r0[0x7c]
80006a2c:	80 00       	ld.sh	r0,r0[0x0]
80006a2e:	68 d8       	ld.w	r8,r4[0x34]

80006a30 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80006a30:	d4 21       	pushm	r4-r7,lr
80006a32:	18 97       	mov	r7,r12
80006a34:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80006a36:	58 0c       	cp.w	r12,0
80006a38:	c2 f0       	breq	80006a96 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80006a3a:	34 cc       	mov	r12,76
80006a3c:	f0 1f 00 17 	mcall	80006a98 <xQueueCreate+0x68>
80006a40:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80006a42:	c2 a0       	breq	80006a96 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80006a44:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80006a48:	e8 cc ff ff 	sub	r12,r4,-1
80006a4c:	f0 1f 00 13 	mcall	80006a98 <xQueueCreate+0x68>
80006a50:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80006a52:	c1 e0       	breq	80006a8e <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80006a54:	f8 04 00 04 	add	r4,r12,r4
80006a58:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80006a5a:	30 08       	mov	r8,0
80006a5c:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80006a5e:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80006a60:	ee c8 00 01 	sub	r8,r7,1
80006a64:	ad 38       	mul	r8,r6
80006a66:	10 0c       	add	r12,r8
80006a68:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80006a6a:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80006a6c:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80006a70:	3f f8       	mov	r8,-1
80006a72:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80006a76:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80006a7a:	ea cc ff f0 	sub	r12,r5,-16
80006a7e:	f0 1f 00 08 	mcall	80006a9c <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80006a82:	ea cc ff dc 	sub	r12,r5,-36
80006a86:	f0 1f 00 06 	mcall	80006a9c <xQueueCreate+0x6c>
80006a8a:	0a 9c       	mov	r12,r5
80006a8c:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80006a8e:	0a 9c       	mov	r12,r5
80006a90:	f0 1f 00 04 	mcall	80006aa0 <xQueueCreate+0x70>
80006a94:	d8 2a       	popm	r4-r7,pc,r12=0
80006a96:	d8 2a       	popm	r4-r7,pc,r12=0
80006a98:	80 00       	ld.sh	r0,r0[0x0]
80006a9a:	65 84       	ld.w	r4,r2[0x60]
80006a9c:	80 00       	ld.sh	r0,r0[0x0]
80006a9e:	61 f4       	ld.w	r4,r0[0x7c]
80006aa0:	80 00       	ld.sh	r0,r0[0x0]
80006aa2:	65 5c       	ld.w	r12,r2[0x54]

80006aa4 <xTaskIsTaskSuspended>:
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
80006aa4:	78 59       	ld.w	r9,r12[0x14]
80006aa6:	48 68       	lddpc	r8,80006abc <xTaskIsTaskSuspended+0x18>
80006aa8:	10 39       	cp.w	r9,r8
80006aaa:	c0 81       	brne	80006aba <xTaskIsTaskSuspended+0x16>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
80006aac:	78 a8       	ld.w	r8,r12[0x28]
80006aae:	48 59       	lddpc	r9,80006ac0 <xTaskIsTaskSuspended+0x1c>
80006ab0:	12 38       	cp.w	r8,r9
80006ab2:	c0 40       	breq	80006aba <xTaskIsTaskSuspended+0x16>
80006ab4:	58 08       	cp.w	r8,0
80006ab6:	5f 0c       	sreq	r12
80006ab8:	5e fc       	retal	r12
80006aba:	5e fd       	retal	0
80006abc:	00 00       	add	r0,r0
80006abe:	0d ac       	ld.ub	r12,r6[0x2]
80006ac0:	00 00       	add	r0,r0
80006ac2:	0d 5c       	ld.sh	r12,--r6

80006ac4 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80006ac4:	48 38       	lddpc	r8,80006ad0 <vTaskSuspendAll+0xc>
80006ac6:	70 09       	ld.w	r9,r8[0x0]
80006ac8:	2f f9       	sub	r9,-1
80006aca:	91 09       	st.w	r8[0x0],r9
}
80006acc:	5e fc       	retal	r12
80006ace:	00 00       	add	r0,r0
80006ad0:	00 00       	add	r0,r0
80006ad2:	0d 88       	ld.ub	r8,r6[0x0]

80006ad4 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80006ad4:	49 a8       	lddpc	r8,80006b3c <vTaskSwitchContext+0x68>
80006ad6:	70 08       	ld.w	r8,r8[0x0]
80006ad8:	58 08       	cp.w	r8,0
80006ada:	c0 b1       	brne	80006af0 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006adc:	49 98       	lddpc	r8,80006b40 <vTaskSwitchContext+0x6c>
80006ade:	70 08       	ld.w	r8,r8[0x0]
80006ae0:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006ae4:	49 89       	lddpc	r9,80006b44 <vTaskSwitchContext+0x70>
80006ae6:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80006aea:	58 08       	cp.w	r8,0
80006aec:	c0 60       	breq	80006af8 <vTaskSwitchContext+0x24>
80006aee:	c1 18       	rjmp	80006b10 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80006af0:	30 19       	mov	r9,1
80006af2:	49 68       	lddpc	r8,80006b48 <vTaskSwitchContext+0x74>
80006af4:	91 09       	st.w	r8[0x0],r9
80006af6:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006af8:	49 28       	lddpc	r8,80006b40 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006afa:	49 3a       	lddpc	r10,80006b44 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006afc:	70 09       	ld.w	r9,r8[0x0]
80006afe:	20 19       	sub	r9,1
80006b00:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006b02:	70 09       	ld.w	r9,r8[0x0]
80006b04:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006b08:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80006b0c:	58 09       	cp.w	r9,0
80006b0e:	cf 70       	breq	80006afc <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80006b10:	48 c8       	lddpc	r8,80006b40 <vTaskSwitchContext+0x6c>
80006b12:	70 08       	ld.w	r8,r8[0x0]
80006b14:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006b18:	48 b9       	lddpc	r9,80006b44 <vTaskSwitchContext+0x70>
80006b1a:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006b1e:	70 19       	ld.w	r9,r8[0x4]
80006b20:	72 19       	ld.w	r9,r9[0x4]
80006b22:	91 19       	st.w	r8[0x4],r9
80006b24:	f0 ca ff f8 	sub	r10,r8,-8
80006b28:	14 39       	cp.w	r9,r10
80006b2a:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80006b2e:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80006b32:	70 18       	ld.w	r8,r8[0x4]
80006b34:	70 39       	ld.w	r9,r8[0xc]
80006b36:	48 68       	lddpc	r8,80006b4c <vTaskSwitchContext+0x78>
80006b38:	91 09       	st.w	r8[0x0],r9
80006b3a:	5e fc       	retal	r12
80006b3c:	00 00       	add	r0,r0
80006b3e:	0d 88       	ld.ub	r8,r6[0x0]
80006b40:	00 00       	add	r0,r0
80006b42:	0d c0       	ld.ub	r0,r6[0x4]
80006b44:	00 00       	add	r0,r0
80006b46:	0c a4       	st.w	r6++,r4
80006b48:	00 00       	add	r0,r0
80006b4a:	0d a8       	ld.ub	r8,r6[0x2]
80006b4c:	00 00       	add	r0,r0
80006b4e:	0d 58       	ld.sh	r8,--r6

80006b50 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80006b50:	48 48       	lddpc	r8,80006b60 <vTaskSetTimeOutState+0x10>
80006b52:	70 08       	ld.w	r8,r8[0x0]
80006b54:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80006b56:	48 48       	lddpc	r8,80006b64 <vTaskSetTimeOutState+0x14>
80006b58:	70 08       	ld.w	r8,r8[0x0]
80006b5a:	99 18       	st.w	r12[0x4],r8
}
80006b5c:	5e fc       	retal	r12
80006b5e:	00 00       	add	r0,r0
80006b60:	00 00       	add	r0,r0
80006b62:	0c 9c       	mov	r12,r6
80006b64:	00 00       	add	r0,r0
80006b66:	0d 84       	ld.ub	r4,r6[0x0]

80006b68 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80006b68:	30 19       	mov	r9,1
80006b6a:	48 28       	lddpc	r8,80006b70 <vTaskMissedYield+0x8>
80006b6c:	91 09       	st.w	r8[0x0],r9
}
80006b6e:	5e fc       	retal	r12
80006b70:	00 00       	add	r0,r0
80006b72:	0d a8       	ld.ub	r8,r6[0x2]

80006b74 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
80006b74:	58 0c       	cp.w	r12,0
80006b76:	c0 31       	brne	80006b7c <uxTaskGetStackHighWaterMark+0x8>
80006b78:	48 c8       	lddpc	r8,80006ba8 <uxTaskGetStackHighWaterMark+0x34>
80006b7a:	70 0c       	ld.w	r12,r8[0x0]

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
80006b7c:	78 ca       	ld.w	r10,r12[0x30]
80006b7e:	14 98       	mov	r8,r10

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
80006b80:	15 8b       	ld.ub	r11,r10[0x0]
80006b82:	3a 59       	mov	r9,-91
80006b84:	f2 0b 18 00 	cp.b	r11,r9
80006b88:	c0 30       	breq	80006b8e <uxTaskGetStackHighWaterMark+0x1a>
80006b8a:	30 0c       	mov	r12,0
80006b8c:	c0 b8       	rjmp	80006ba2 <uxTaskGetStackHighWaterMark+0x2e>
80006b8e:	3a 5b       	mov	r11,-91
		{
			pucStackByte -= portSTACK_GROWTH;
80006b90:	2f f8       	sub	r8,-1
80006b92:	f0 0a 01 09 	sub	r9,r8,r10
80006b96:	f9 d9 b0 10 	bfexts	r12,r9,0x0,0x10

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
80006b9a:	11 89       	ld.ub	r9,r8[0x0]
80006b9c:	f6 09 18 00 	cp.b	r9,r11
80006ba0:	cf 80       	breq	80006b90 <uxTaskGetStackHighWaterMark+0x1c>
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
80006ba2:	f9 dc c0 4e 	bfextu	r12,r12,0x2,0xe
80006ba6:	5e fc       	retal	r12
80006ba8:	00 00       	add	r0,r0
80006baa:	0d 58       	ld.sh	r8,--r6

80006bac <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80006bac:	48 28       	lddpc	r8,80006bb4 <xTaskGetCurrentTaskHandle+0x8>
80006bae:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006bb0:	5e fc       	retal	r12
80006bb2:	00 00       	add	r0,r0
80006bb4:	00 00       	add	r0,r0
80006bb6:	0d 58       	ld.sh	r8,--r6

80006bb8 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80006bb8:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80006bbc:	58 0c       	cp.w	r12,0
80006bbe:	c1 f0       	breq	80006bfc <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80006bc0:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80006bc2:	78 b9       	ld.w	r9,r12[0x2c]
80006bc4:	79 18       	ld.w	r8,r12[0x44]
80006bc6:	10 39       	cp.w	r9,r8
80006bc8:	c1 a0       	breq	80006bfc <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80006bca:	f8 c6 ff fc 	sub	r6,r12,-4
80006bce:	0c 9c       	mov	r12,r6
80006bd0:	f0 1f 00 0c 	mcall	80006c00 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80006bd4:	6f 1c       	ld.w	r12,r7[0x44]
80006bd6:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80006bd8:	f8 08 11 08 	rsub	r8,r12,8
80006bdc:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80006bde:	48 a8       	lddpc	r8,80006c04 <vTaskPriorityDisinherit+0x4c>
80006be0:	70 08       	ld.w	r8,r8[0x0]
80006be2:	10 3c       	cp.w	r12,r8
80006be4:	e0 88 00 04 	brls	80006bec <vTaskPriorityDisinherit+0x34>
80006be8:	48 78       	lddpc	r8,80006c04 <vTaskPriorityDisinherit+0x4c>
80006bea:	91 0c       	st.w	r8[0x0],r12
80006bec:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006bf0:	0c 9b       	mov	r11,r6
80006bf2:	48 68       	lddpc	r8,80006c08 <vTaskPriorityDisinherit+0x50>
80006bf4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006bf8:	f0 1f 00 05 	mcall	80006c0c <vTaskPriorityDisinherit+0x54>
80006bfc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006c00:	80 00       	ld.sh	r0,r0[0x0]
80006c02:	62 5e       	ld.w	lr,r1[0x14]
80006c04:	00 00       	add	r0,r0
80006c06:	0d c0       	ld.ub	r0,r6[0x4]
80006c08:	00 00       	add	r0,r0
80006c0a:	0c a4       	st.w	r6++,r4
80006c0c:	80 00       	ld.sh	r0,r0[0x0]
80006c0e:	62 0e       	ld.w	lr,r1[0x0]

80006c10 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80006c10:	eb cd 40 c0 	pushm	r6-r7,lr
80006c14:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80006c16:	49 b8       	lddpc	r8,80006c80 <vTaskPriorityInherit+0x70>
80006c18:	70 08       	ld.w	r8,r8[0x0]
80006c1a:	78 b9       	ld.w	r9,r12[0x2c]
80006c1c:	70 b8       	ld.w	r8,r8[0x2c]
80006c1e:	10 39       	cp.w	r9,r8
80006c20:	c2 d2       	brcc	80006c7a <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80006c22:	49 88       	lddpc	r8,80006c80 <vTaskPriorityInherit+0x70>
80006c24:	70 08       	ld.w	r8,r8[0x0]
80006c26:	70 b8       	ld.w	r8,r8[0x2c]
80006c28:	f0 08 11 08 	rsub	r8,r8,8
80006c2c:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80006c2e:	f2 09 00 28 	add	r8,r9,r9<<0x2
80006c32:	49 59       	lddpc	r9,80006c84 <vTaskPriorityInherit+0x74>
80006c34:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006c38:	78 59       	ld.w	r9,r12[0x14]
80006c3a:	10 39       	cp.w	r9,r8
80006c3c:	c1 b1       	brne	80006c72 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80006c3e:	f8 c6 ff fc 	sub	r6,r12,-4
80006c42:	0c 9c       	mov	r12,r6
80006c44:	f0 1f 00 11 	mcall	80006c88 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006c48:	48 e8       	lddpc	r8,80006c80 <vTaskPriorityInherit+0x70>
80006c4a:	70 08       	ld.w	r8,r8[0x0]
80006c4c:	70 bc       	ld.w	r12,r8[0x2c]
80006c4e:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80006c50:	48 f8       	lddpc	r8,80006c8c <vTaskPriorityInherit+0x7c>
80006c52:	70 08       	ld.w	r8,r8[0x0]
80006c54:	10 3c       	cp.w	r12,r8
80006c56:	e0 88 00 04 	brls	80006c5e <vTaskPriorityInherit+0x4e>
80006c5a:	48 d8       	lddpc	r8,80006c8c <vTaskPriorityInherit+0x7c>
80006c5c:	91 0c       	st.w	r8[0x0],r12
80006c5e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006c62:	0c 9b       	mov	r11,r6
80006c64:	48 88       	lddpc	r8,80006c84 <vTaskPriorityInherit+0x74>
80006c66:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006c6a:	f0 1f 00 0a 	mcall	80006c90 <vTaskPriorityInherit+0x80>
80006c6e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006c72:	48 48       	lddpc	r8,80006c80 <vTaskPriorityInherit+0x70>
80006c74:	70 08       	ld.w	r8,r8[0x0]
80006c76:	70 b8       	ld.w	r8,r8[0x2c]
80006c78:	99 b8       	st.w	r12[0x2c],r8
80006c7a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006c7e:	00 00       	add	r0,r0
80006c80:	00 00       	add	r0,r0
80006c82:	0d 58       	ld.sh	r8,--r6
80006c84:	00 00       	add	r0,r0
80006c86:	0c a4       	st.w	r6++,r4
80006c88:	80 00       	ld.sh	r0,r0[0x0]
80006c8a:	62 5e       	ld.w	lr,r1[0x14]
80006c8c:	00 00       	add	r0,r0
80006c8e:	0d c0       	ld.ub	r0,r6[0x4]
80006c90:	80 00       	ld.sh	r0,r0[0x0]
80006c92:	62 0e       	ld.w	lr,r1[0x0]

80006c94 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80006c94:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80006c98:	78 38       	ld.w	r8,r12[0xc]
80006c9a:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80006c9c:	ee c6 ff e8 	sub	r6,r7,-24
80006ca0:	0c 9c       	mov	r12,r6
80006ca2:	f0 1f 00 15 	mcall	80006cf4 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006ca6:	49 58       	lddpc	r8,80006cf8 <xTaskRemoveFromEventList+0x64>
80006ca8:	70 08       	ld.w	r8,r8[0x0]
80006caa:	58 08       	cp.w	r8,0
80006cac:	c1 71       	brne	80006cda <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80006cae:	ee c6 ff fc 	sub	r6,r7,-4
80006cb2:	0c 9c       	mov	r12,r6
80006cb4:	f0 1f 00 10 	mcall	80006cf4 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80006cb8:	6e bc       	ld.w	r12,r7[0x2c]
80006cba:	49 18       	lddpc	r8,80006cfc <xTaskRemoveFromEventList+0x68>
80006cbc:	70 08       	ld.w	r8,r8[0x0]
80006cbe:	10 3c       	cp.w	r12,r8
80006cc0:	e0 88 00 04 	brls	80006cc8 <xTaskRemoveFromEventList+0x34>
80006cc4:	48 e8       	lddpc	r8,80006cfc <xTaskRemoveFromEventList+0x68>
80006cc6:	91 0c       	st.w	r8[0x0],r12
80006cc8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006ccc:	0c 9b       	mov	r11,r6
80006cce:	48 d8       	lddpc	r8,80006d00 <xTaskRemoveFromEventList+0x6c>
80006cd0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006cd4:	f0 1f 00 0c 	mcall	80006d04 <xTaskRemoveFromEventList+0x70>
80006cd8:	c0 58       	rjmp	80006ce2 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80006cda:	0c 9b       	mov	r11,r6
80006cdc:	48 bc       	lddpc	r12,80006d08 <xTaskRemoveFromEventList+0x74>
80006cde:	f0 1f 00 0a 	mcall	80006d04 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006ce2:	48 b8       	lddpc	r8,80006d0c <xTaskRemoveFromEventList+0x78>
80006ce4:	70 08       	ld.w	r8,r8[0x0]
80006ce6:	6e b9       	ld.w	r9,r7[0x2c]
80006ce8:	70 b8       	ld.w	r8,r8[0x2c]
80006cea:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80006cec:	5f 2c       	srhs	r12
80006cee:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006cf2:	00 00       	add	r0,r0
80006cf4:	80 00       	ld.sh	r0,r0[0x0]
80006cf6:	62 5e       	ld.w	lr,r1[0x14]
80006cf8:	00 00       	add	r0,r0
80006cfa:	0d 88       	ld.ub	r8,r6[0x0]
80006cfc:	00 00       	add	r0,r0
80006cfe:	0d c0       	ld.ub	r0,r6[0x4]
80006d00:	00 00       	add	r0,r0
80006d02:	0c a4       	st.w	r6++,r4
80006d04:	80 00       	ld.sh	r0,r0[0x0]
80006d06:	62 0e       	ld.w	lr,r1[0x0]
80006d08:	00 00       	add	r0,r0
80006d0a:	0d 5c       	ld.sh	r12,--r6
80006d0c:	00 00       	add	r0,r0
80006d0e:	0d 58       	ld.sh	r8,--r6

80006d10 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80006d10:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006d14:	4b 98       	lddpc	r8,80006df8 <vTaskIncrementTick+0xe8>
80006d16:	70 08       	ld.w	r8,r8[0x0]
80006d18:	58 08       	cp.w	r8,0
80006d1a:	c6 91       	brne	80006dec <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80006d1c:	4b 88       	lddpc	r8,80006dfc <vTaskIncrementTick+0xec>
80006d1e:	70 09       	ld.w	r9,r8[0x0]
80006d20:	2f f9       	sub	r9,-1
80006d22:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80006d24:	70 08       	ld.w	r8,r8[0x0]
80006d26:	58 08       	cp.w	r8,0
80006d28:	c1 a1       	brne	80006d5c <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80006d2a:	4b 68       	lddpc	r8,80006e00 <vTaskIncrementTick+0xf0>
80006d2c:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80006d2e:	4b 69       	lddpc	r9,80006e04 <vTaskIncrementTick+0xf4>
80006d30:	72 0b       	ld.w	r11,r9[0x0]
80006d32:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80006d34:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80006d36:	4b 59       	lddpc	r9,80006e08 <vTaskIncrementTick+0xf8>
80006d38:	72 0a       	ld.w	r10,r9[0x0]
80006d3a:	2f fa       	sub	r10,-1
80006d3c:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80006d3e:	70 08       	ld.w	r8,r8[0x0]
80006d40:	70 08       	ld.w	r8,r8[0x0]
80006d42:	58 08       	cp.w	r8,0
80006d44:	c0 51       	brne	80006d4e <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80006d46:	3f f9       	mov	r9,-1
80006d48:	4b 18       	lddpc	r8,80006e0c <vTaskIncrementTick+0xfc>
80006d4a:	91 09       	st.w	r8[0x0],r9
80006d4c:	c0 88       	rjmp	80006d5c <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80006d4e:	4a d8       	lddpc	r8,80006e00 <vTaskIncrementTick+0xf0>
80006d50:	70 08       	ld.w	r8,r8[0x0]
80006d52:	70 38       	ld.w	r8,r8[0xc]
80006d54:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80006d56:	70 19       	ld.w	r9,r8[0x4]
80006d58:	4a d8       	lddpc	r8,80006e0c <vTaskIncrementTick+0xfc>
80006d5a:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80006d5c:	4a 88       	lddpc	r8,80006dfc <vTaskIncrementTick+0xec>
80006d5e:	70 09       	ld.w	r9,r8[0x0]
80006d60:	4a b8       	lddpc	r8,80006e0c <vTaskIncrementTick+0xfc>
80006d62:	70 08       	ld.w	r8,r8[0x0]
80006d64:	10 39       	cp.w	r9,r8
80006d66:	c4 73       	brcs	80006df4 <vTaskIncrementTick+0xe4>
80006d68:	4a 68       	lddpc	r8,80006e00 <vTaskIncrementTick+0xf0>
80006d6a:	70 08       	ld.w	r8,r8[0x0]
80006d6c:	70 08       	ld.w	r8,r8[0x0]
80006d6e:	58 08       	cp.w	r8,0
80006d70:	c0 c0       	breq	80006d88 <vTaskIncrementTick+0x78>
80006d72:	4a 48       	lddpc	r8,80006e00 <vTaskIncrementTick+0xf0>
80006d74:	70 08       	ld.w	r8,r8[0x0]
80006d76:	70 38       	ld.w	r8,r8[0xc]
80006d78:	70 37       	ld.w	r7,r8[0xc]
80006d7a:	6e 18       	ld.w	r8,r7[0x4]
80006d7c:	4a 09       	lddpc	r9,80006dfc <vTaskIncrementTick+0xec>
80006d7e:	72 09       	ld.w	r9,r9[0x0]
80006d80:	12 38       	cp.w	r8,r9
80006d82:	e0 88 00 14 	brls	80006daa <vTaskIncrementTick+0x9a>
80006d86:	c0 e8       	rjmp	80006da2 <vTaskIncrementTick+0x92>
80006d88:	3f f9       	mov	r9,-1
80006d8a:	4a 18       	lddpc	r8,80006e0c <vTaskIncrementTick+0xfc>
80006d8c:	91 09       	st.w	r8[0x0],r9
80006d8e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006d92:	6a 08       	ld.w	r8,r5[0x0]
80006d94:	70 38       	ld.w	r8,r8[0xc]
80006d96:	70 37       	ld.w	r7,r8[0xc]
80006d98:	6e 18       	ld.w	r8,r7[0x4]
80006d9a:	64 09       	ld.w	r9,r2[0x0]
80006d9c:	12 38       	cp.w	r8,r9
80006d9e:	e0 88 00 0a 	brls	80006db2 <vTaskIncrementTick+0xa2>
80006da2:	49 b9       	lddpc	r9,80006e0c <vTaskIncrementTick+0xfc>
80006da4:	93 08       	st.w	r9[0x0],r8
80006da6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006daa:	49 a4       	lddpc	r4,80006e10 <vTaskIncrementTick+0x100>
80006dac:	49 a3       	lddpc	r3,80006e14 <vTaskIncrementTick+0x104>
80006dae:	49 55       	lddpc	r5,80006e00 <vTaskIncrementTick+0xf0>
80006db0:	49 32       	lddpc	r2,80006dfc <vTaskIncrementTick+0xec>
80006db2:	ee c6 ff fc 	sub	r6,r7,-4
80006db6:	0c 9c       	mov	r12,r6
80006db8:	f0 1f 00 18 	mcall	80006e18 <vTaskIncrementTick+0x108>
80006dbc:	6e a8       	ld.w	r8,r7[0x28]
80006dbe:	58 08       	cp.w	r8,0
80006dc0:	c0 50       	breq	80006dca <vTaskIncrementTick+0xba>
80006dc2:	ee cc ff e8 	sub	r12,r7,-24
80006dc6:	f0 1f 00 15 	mcall	80006e18 <vTaskIncrementTick+0x108>
80006dca:	6e bc       	ld.w	r12,r7[0x2c]
80006dcc:	68 08       	ld.w	r8,r4[0x0]
80006dce:	10 3c       	cp.w	r12,r8
80006dd0:	e9 fc ba 00 	st.whi	r4[0x0],r12
80006dd4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006dd8:	0c 9b       	mov	r11,r6
80006dda:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80006dde:	f0 1f 00 10 	mcall	80006e1c <vTaskIncrementTick+0x10c>
80006de2:	6a 08       	ld.w	r8,r5[0x0]
80006de4:	70 08       	ld.w	r8,r8[0x0]
80006de6:	58 08       	cp.w	r8,0
80006de8:	cd 51       	brne	80006d92 <vTaskIncrementTick+0x82>
80006dea:	cc fb       	rjmp	80006d88 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80006dec:	48 d8       	lddpc	r8,80006e20 <vTaskIncrementTick+0x110>
80006dee:	70 09       	ld.w	r9,r8[0x0]
80006df0:	2f f9       	sub	r9,-1
80006df2:	91 09       	st.w	r8[0x0],r9
80006df4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006df8:	00 00       	add	r0,r0
80006dfa:	0d 88       	ld.ub	r8,r6[0x0]
80006dfc:	00 00       	add	r0,r0
80006dfe:	0d 84       	ld.ub	r4,r6[0x0]
80006e00:	00 00       	add	r0,r0
80006e02:	0c 90       	mov	r0,r6
80006e04:	00 00       	add	r0,r0
80006e06:	0c a0       	st.w	r6++,r0
80006e08:	00 00       	add	r0,r0
80006e0a:	0c 9c       	mov	r12,r6
80006e0c:	00 00       	add	r0,r0
80006e0e:	05 44       	ld.w	r4,--r2
80006e10:	00 00       	add	r0,r0
80006e12:	0d c0       	ld.ub	r0,r6[0x4]
80006e14:	00 00       	add	r0,r0
80006e16:	0c a4       	st.w	r6++,r4
80006e18:	80 00       	ld.sh	r0,r0[0x0]
80006e1a:	62 5e       	ld.w	lr,r1[0x14]
80006e1c:	80 00       	ld.sh	r0,r0[0x0]
80006e1e:	62 0e       	ld.w	lr,r1[0x0]
80006e20:	00 00       	add	r0,r0
80006e22:	0c 88       	andn	r8,r6

80006e24 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80006e24:	eb cd 40 c0 	pushm	r6-r7,lr
80006e28:	18 97       	mov	r7,r12
80006e2a:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80006e2c:	f0 1f 00 15 	mcall	80006e80 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80006e30:	6c 08       	ld.w	r8,r6[0x0]
80006e32:	5b f8       	cp.w	r8,-1
80006e34:	c0 31       	brne	80006e3a <xTaskCheckForTimeOut+0x16>
80006e36:	30 07       	mov	r7,0
80006e38:	c1 f8       	rjmp	80006e76 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80006e3a:	49 39       	lddpc	r9,80006e84 <xTaskCheckForTimeOut+0x60>
80006e3c:	72 09       	ld.w	r9,r9[0x0]
80006e3e:	6e 0a       	ld.w	r10,r7[0x0]
80006e40:	12 3a       	cp.w	r10,r9
80006e42:	c0 70       	breq	80006e50 <xTaskCheckForTimeOut+0x2c>
80006e44:	49 19       	lddpc	r9,80006e88 <xTaskCheckForTimeOut+0x64>
80006e46:	72 09       	ld.w	r9,r9[0x0]
80006e48:	6e 1a       	ld.w	r10,r7[0x4]
80006e4a:	12 3a       	cp.w	r10,r9
80006e4c:	e0 88 00 14 	brls	80006e74 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80006e50:	48 e9       	lddpc	r9,80006e88 <xTaskCheckForTimeOut+0x64>
80006e52:	72 0a       	ld.w	r10,r9[0x0]
80006e54:	6e 19       	ld.w	r9,r7[0x4]
80006e56:	12 1a       	sub	r10,r9
80006e58:	14 38       	cp.w	r8,r10
80006e5a:	e0 88 00 0d 	brls	80006e74 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80006e5e:	48 ba       	lddpc	r10,80006e88 <xTaskCheckForTimeOut+0x64>
80006e60:	74 0a       	ld.w	r10,r10[0x0]
80006e62:	14 19       	sub	r9,r10
80006e64:	f2 08 00 08 	add	r8,r9,r8
80006e68:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80006e6a:	0e 9c       	mov	r12,r7
80006e6c:	f0 1f 00 08 	mcall	80006e8c <xTaskCheckForTimeOut+0x68>
80006e70:	30 07       	mov	r7,0
80006e72:	c0 28       	rjmp	80006e76 <xTaskCheckForTimeOut+0x52>
80006e74:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80006e76:	f0 1f 00 07 	mcall	80006e90 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80006e7a:	0e 9c       	mov	r12,r7
80006e7c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006e80:	80 00       	ld.sh	r0,r0[0x0]
80006e82:	63 18       	ld.w	r8,r1[0x44]
80006e84:	00 00       	add	r0,r0
80006e86:	0c 9c       	mov	r12,r6
80006e88:	00 00       	add	r0,r0
80006e8a:	0d 84       	ld.ub	r4,r6[0x0]
80006e8c:	80 00       	ld.sh	r0,r0[0x0]
80006e8e:	6b 50       	ld.w	r0,r5[0x54]
80006e90:	80 00       	ld.sh	r0,r0[0x0]
80006e92:	64 24       	ld.w	r4,r2[0x8]

80006e94 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80006e94:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80006e98:	f0 1f 00 05 	mcall	80006eac <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80006e9c:	48 58       	lddpc	r8,80006eb0 <xTaskGetTickCount+0x1c>
80006e9e:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80006ea0:	f0 1f 00 05 	mcall	80006eb4 <xTaskGetTickCount+0x20>

	return xTicks;
}
80006ea4:	0e 9c       	mov	r12,r7
80006ea6:	e3 cd 80 80 	ldm	sp++,r7,pc
80006eaa:	00 00       	add	r0,r0
80006eac:	80 00       	ld.sh	r0,r0[0x0]
80006eae:	63 18       	ld.w	r8,r1[0x44]
80006eb0:	00 00       	add	r0,r0
80006eb2:	0d 84       	ld.ub	r4,r6[0x0]
80006eb4:	80 00       	ld.sh	r0,r0[0x0]
80006eb6:	64 24       	ld.w	r4,r2[0x8]

80006eb8 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80006eb8:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80006ebc:	f0 1f 00 2c 	mcall	80006f6c <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006ec0:	4a c8       	lddpc	r8,80006f70 <xTaskResumeAll+0xb8>
80006ec2:	70 09       	ld.w	r9,r8[0x0]
80006ec4:	20 19       	sub	r9,1
80006ec6:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006ec8:	70 08       	ld.w	r8,r8[0x0]
80006eca:	58 08       	cp.w	r8,0
80006ecc:	c4 91       	brne	80006f5e <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80006ece:	4a a8       	lddpc	r8,80006f74 <xTaskResumeAll+0xbc>
80006ed0:	70 08       	ld.w	r8,r8[0x0]
80006ed2:	58 08       	cp.w	r8,0
80006ed4:	c4 50       	breq	80006f5e <xTaskResumeAll+0xa6>
80006ed6:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006ed8:	4a 85       	lddpc	r5,80006f78 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80006eda:	4a 93       	lddpc	r3,80006f7c <xTaskResumeAll+0xc4>
80006edc:	4a 92       	lddpc	r2,80006f80 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006ede:	4a a1       	lddpc	r1,80006f84 <xTaskResumeAll+0xcc>
80006ee0:	c1 e8       	rjmp	80006f1c <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80006ee2:	6a 38       	ld.w	r8,r5[0xc]
80006ee4:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80006ee6:	ee cc ff e8 	sub	r12,r7,-24
80006eea:	f0 1f 00 28 	mcall	80006f88 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80006eee:	ee c6 ff fc 	sub	r6,r7,-4
80006ef2:	0c 9c       	mov	r12,r6
80006ef4:	f0 1f 00 25 	mcall	80006f88 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80006ef8:	6e bc       	ld.w	r12,r7[0x2c]
80006efa:	66 08       	ld.w	r8,r3[0x0]
80006efc:	10 3c       	cp.w	r12,r8
80006efe:	e7 fc ba 00 	st.whi	r3[0x0],r12
80006f02:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006f06:	0c 9b       	mov	r11,r6
80006f08:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80006f0c:	f0 1f 00 20 	mcall	80006f8c <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006f10:	62 08       	ld.w	r8,r1[0x0]
80006f12:	6e b9       	ld.w	r9,r7[0x2c]
80006f14:	70 b8       	ld.w	r8,r8[0x2c]
80006f16:	10 39       	cp.w	r9,r8
80006f18:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006f1c:	6a 08       	ld.w	r8,r5[0x0]
80006f1e:	58 08       	cp.w	r8,0
80006f20:	ce 11       	brne	80006ee2 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006f22:	49 c8       	lddpc	r8,80006f90 <xTaskResumeAll+0xd8>
80006f24:	70 08       	ld.w	r8,r8[0x0]
80006f26:	58 08       	cp.w	r8,0
80006f28:	c0 f0       	breq	80006f46 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006f2a:	49 a8       	lddpc	r8,80006f90 <xTaskResumeAll+0xd8>
80006f2c:	70 08       	ld.w	r8,r8[0x0]
80006f2e:	58 08       	cp.w	r8,0
80006f30:	c1 10       	breq	80006f52 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80006f32:	49 87       	lddpc	r7,80006f90 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80006f34:	f0 1f 00 18 	mcall	80006f94 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80006f38:	6e 08       	ld.w	r8,r7[0x0]
80006f3a:	20 18       	sub	r8,1
80006f3c:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006f3e:	6e 08       	ld.w	r8,r7[0x0]
80006f40:	58 08       	cp.w	r8,0
80006f42:	cf 91       	brne	80006f34 <xTaskResumeAll+0x7c>
80006f44:	c0 78       	rjmp	80006f52 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80006f46:	58 14       	cp.w	r4,1
80006f48:	c0 50       	breq	80006f52 <xTaskResumeAll+0x9a>
80006f4a:	49 48       	lddpc	r8,80006f98 <xTaskResumeAll+0xe0>
80006f4c:	70 08       	ld.w	r8,r8[0x0]
80006f4e:	58 18       	cp.w	r8,1
80006f50:	c0 71       	brne	80006f5e <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80006f52:	30 09       	mov	r9,0
80006f54:	49 18       	lddpc	r8,80006f98 <xTaskResumeAll+0xe0>
80006f56:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80006f58:	d7 33       	scall
80006f5a:	30 17       	mov	r7,1
80006f5c:	c0 28       	rjmp	80006f60 <xTaskResumeAll+0xa8>
80006f5e:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80006f60:	f0 1f 00 0f 	mcall	80006f9c <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80006f64:	0e 9c       	mov	r12,r7
80006f66:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80006f6a:	00 00       	add	r0,r0
80006f6c:	80 00       	ld.sh	r0,r0[0x0]
80006f6e:	63 18       	ld.w	r8,r1[0x44]
80006f70:	00 00       	add	r0,r0
80006f72:	0d 88       	ld.ub	r8,r6[0x0]
80006f74:	00 00       	add	r0,r0
80006f76:	0d a4       	ld.ub	r4,r6[0x2]
80006f78:	00 00       	add	r0,r0
80006f7a:	0d 5c       	ld.sh	r12,--r6
80006f7c:	00 00       	add	r0,r0
80006f7e:	0d c0       	ld.ub	r0,r6[0x4]
80006f80:	00 00       	add	r0,r0
80006f82:	0c a4       	st.w	r6++,r4
80006f84:	00 00       	add	r0,r0
80006f86:	0d 58       	ld.sh	r8,--r6
80006f88:	80 00       	ld.sh	r0,r0[0x0]
80006f8a:	62 5e       	ld.w	lr,r1[0x14]
80006f8c:	80 00       	ld.sh	r0,r0[0x0]
80006f8e:	62 0e       	ld.w	lr,r1[0x0]
80006f90:	00 00       	add	r0,r0
80006f92:	0c 88       	andn	r8,r6
80006f94:	80 00       	ld.sh	r0,r0[0x0]
80006f96:	6d 10       	ld.w	r0,r6[0x44]
80006f98:	00 00       	add	r0,r0
80006f9a:	0d a8       	ld.ub	r8,r6[0x2]
80006f9c:	80 00       	ld.sh	r0,r0[0x0]
80006f9e:	64 24       	ld.w	r4,r2[0x8]

80006fa0 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
80006fa0:	eb cd 40 c0 	pushm	r6-r7,lr
80006fa4:	18 97       	mov	r7,r12
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
80006fa6:	58 0c       	cp.w	r12,0
80006fa8:	c2 a0       	breq	80006ffc <vTaskResume+0x5c>
80006faa:	49 68       	lddpc	r8,80007000 <vTaskResume+0x60>
80006fac:	70 08       	ld.w	r8,r8[0x0]
80006fae:	10 3c       	cp.w	r12,r8
80006fb0:	c2 60       	breq	80006ffc <vTaskResume+0x5c>
		{
			taskENTER_CRITICAL();
80006fb2:	f0 1f 00 15 	mcall	80007004 <vTaskResume+0x64>
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
80006fb6:	0e 9c       	mov	r12,r7
80006fb8:	f0 1f 00 14 	mcall	80007008 <vTaskResume+0x68>
80006fbc:	58 1c       	cp.w	r12,1
80006fbe:	c1 d1       	brne	80006ff8 <vTaskResume+0x58>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
80006fc0:	ee c6 ff fc 	sub	r6,r7,-4
80006fc4:	0c 9c       	mov	r12,r6
80006fc6:	f0 1f 00 12 	mcall	8000700c <vTaskResume+0x6c>
					prvAddTaskToReadyQueue( pxTCB );
80006fca:	6e bc       	ld.w	r12,r7[0x2c]
80006fcc:	49 18       	lddpc	r8,80007010 <vTaskResume+0x70>
80006fce:	70 08       	ld.w	r8,r8[0x0]
80006fd0:	10 3c       	cp.w	r12,r8
80006fd2:	e0 88 00 04 	brls	80006fda <vTaskResume+0x3a>
80006fd6:	48 f8       	lddpc	r8,80007010 <vTaskResume+0x70>
80006fd8:	91 0c       	st.w	r8[0x0],r12
80006fda:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006fde:	0c 9b       	mov	r11,r6
80006fe0:	48 d8       	lddpc	r8,80007014 <vTaskResume+0x74>
80006fe2:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006fe6:	f0 1f 00 0d 	mcall	80007018 <vTaskResume+0x78>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006fea:	48 68       	lddpc	r8,80007000 <vTaskResume+0x60>
80006fec:	70 08       	ld.w	r8,r8[0x0]
80006fee:	6e b9       	ld.w	r9,r7[0x2c]
80006ff0:	70 b8       	ld.w	r8,r8[0x2c]
80006ff2:	10 39       	cp.w	r9,r8
80006ff4:	c0 23       	brcs	80006ff8 <vTaskResume+0x58>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
80006ff6:	d7 33       	scall
					}
				}
			}
			taskEXIT_CRITICAL();
80006ff8:	f0 1f 00 09 	mcall	8000701c <vTaskResume+0x7c>
80006ffc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007000:	00 00       	add	r0,r0
80007002:	0d 58       	ld.sh	r8,--r6
80007004:	80 00       	ld.sh	r0,r0[0x0]
80007006:	63 18       	ld.w	r8,r1[0x44]
80007008:	80 00       	ld.sh	r0,r0[0x0]
8000700a:	6a a4       	ld.w	r4,r5[0x28]
8000700c:	80 00       	ld.sh	r0,r0[0x0]
8000700e:	62 5e       	ld.w	lr,r1[0x14]
80007010:	00 00       	add	r0,r0
80007012:	0d c0       	ld.ub	r0,r6[0x4]
80007014:	00 00       	add	r0,r0
80007016:	0c a4       	st.w	r6++,r4
80007018:	80 00       	ld.sh	r0,r0[0x0]
8000701a:	62 0e       	ld.w	lr,r1[0x0]
8000701c:	80 00       	ld.sh	r0,r0[0x0]
8000701e:	64 24       	ld.w	r4,r2[0x8]

80007020 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
80007020:	eb cd 40 e0 	pushm	r5-r7,lr
80007024:	18 97       	mov	r7,r12
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
80007026:	f0 1f 00 1c 	mcall	80007094 <vTaskSuspend+0x74>
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
8000702a:	49 c8       	lddpc	r8,80007098 <vTaskSuspend+0x78>
8000702c:	70 08       	ld.w	r8,r8[0x0]
8000702e:	10 37       	cp.w	r7,r8
80007030:	c0 31       	brne	80007036 <vTaskSuspend+0x16>
80007032:	30 07       	mov	r7,0
80007034:	c0 38       	rjmp	8000703a <vTaskSuspend+0x1a>
			{
				pxTaskToSuspend = NULL;
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
80007036:	58 07       	cp.w	r7,0
80007038:	c0 41       	brne	80007040 <vTaskSuspend+0x20>
8000703a:	49 88       	lddpc	r8,80007098 <vTaskSuspend+0x78>
8000703c:	70 06       	ld.w	r6,r8[0x0]
8000703e:	c0 28       	rjmp	80007042 <vTaskSuspend+0x22>
80007040:	0e 96       	mov	r6,r7

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
80007042:	ec c5 ff fc 	sub	r5,r6,-4
80007046:	0a 9c       	mov	r12,r5
80007048:	f0 1f 00 15 	mcall	8000709c <vTaskSuspend+0x7c>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
8000704c:	6c a8       	ld.w	r8,r6[0x28]
8000704e:	58 08       	cp.w	r8,0
80007050:	c0 50       	breq	8000705a <vTaskSuspend+0x3a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
80007052:	ec cc ff e8 	sub	r12,r6,-24
80007056:	f0 1f 00 12 	mcall	8000709c <vTaskSuspend+0x7c>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
8000705a:	0a 9b       	mov	r11,r5
8000705c:	49 1c       	lddpc	r12,800070a0 <vTaskSuspend+0x80>
8000705e:	f0 1f 00 12 	mcall	800070a4 <vTaskSuspend+0x84>
		}
		taskEXIT_CRITICAL();
80007062:	f0 1f 00 12 	mcall	800070a8 <vTaskSuspend+0x88>

		if( ( void * ) pxTaskToSuspend == NULL )
80007066:	58 07       	cp.w	r7,0
80007068:	c1 31       	brne	8000708e <vTaskSuspend+0x6e>
		{
			if( xSchedulerRunning != pdFALSE )
8000706a:	49 18       	lddpc	r8,800070ac <vTaskSuspend+0x8c>
8000706c:	70 08       	ld.w	r8,r8[0x0]
8000706e:	58 08       	cp.w	r8,0
80007070:	c0 40       	breq	80007078 <vTaskSuspend+0x58>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
80007072:	d7 33       	scall
80007074:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1U )
80007078:	48 e8       	lddpc	r8,800070b0 <vTaskSuspend+0x90>
8000707a:	70 08       	ld.w	r8,r8[0x0]
8000707c:	58 18       	cp.w	r8,1
8000707e:	c0 61       	brne	8000708a <vTaskSuspend+0x6a>
				{
					/* No other tasks are defined, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
80007080:	30 09       	mov	r9,0
80007082:	48 68       	lddpc	r8,80007098 <vTaskSuspend+0x78>
80007084:	91 09       	st.w	r8[0x0],r9
80007086:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				}
				else
				{
					vTaskSwitchContext();
8000708a:	f0 1f 00 0b 	mcall	800070b4 <vTaskSuspend+0x94>
8000708e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80007092:	00 00       	add	r0,r0
80007094:	80 00       	ld.sh	r0,r0[0x0]
80007096:	63 18       	ld.w	r8,r1[0x44]
80007098:	00 00       	add	r0,r0
8000709a:	0d 58       	ld.sh	r8,--r6
8000709c:	80 00       	ld.sh	r0,r0[0x0]
8000709e:	62 5e       	ld.w	lr,r1[0x14]
800070a0:	00 00       	add	r0,r0
800070a2:	0d ac       	ld.ub	r12,r6[0x2]
800070a4:	80 00       	ld.sh	r0,r0[0x0]
800070a6:	62 0e       	ld.w	lr,r1[0x0]
800070a8:	80 00       	ld.sh	r0,r0[0x0]
800070aa:	64 24       	ld.w	r4,r2[0x8]
800070ac:	00 00       	add	r0,r0
800070ae:	0c 94       	mov	r4,r6
800070b0:	00 00       	add	r0,r0
800070b2:	0d a4       	ld.ub	r4,r6[0x2]
800070b4:	80 00       	ld.sh	r0,r0[0x0]
800070b6:	6a d4       	ld.w	r4,r5[0x34]

800070b8 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
800070b8:	eb cd 40 80 	pushm	r7,lr
800070bc:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
800070be:	49 08       	lddpc	r8,800070fc <prvAddCurrentTaskToDelayedList+0x44>
800070c0:	70 08       	ld.w	r8,r8[0x0]
800070c2:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
800070c4:	48 f8       	lddpc	r8,80007100 <prvAddCurrentTaskToDelayedList+0x48>
800070c6:	70 08       	ld.w	r8,r8[0x0]
800070c8:	10 3c       	cp.w	r12,r8
800070ca:	c0 a2       	brcc	800070de <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800070cc:	48 c8       	lddpc	r8,800070fc <prvAddCurrentTaskToDelayedList+0x44>
800070ce:	70 0b       	ld.w	r11,r8[0x0]
800070d0:	48 d8       	lddpc	r8,80007104 <prvAddCurrentTaskToDelayedList+0x4c>
800070d2:	70 0c       	ld.w	r12,r8[0x0]
800070d4:	2f cb       	sub	r11,-4
800070d6:	f0 1f 00 0d 	mcall	80007108 <prvAddCurrentTaskToDelayedList+0x50>
800070da:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800070de:	48 88       	lddpc	r8,800070fc <prvAddCurrentTaskToDelayedList+0x44>
800070e0:	70 0b       	ld.w	r11,r8[0x0]
800070e2:	48 b8       	lddpc	r8,8000710c <prvAddCurrentTaskToDelayedList+0x54>
800070e4:	70 0c       	ld.w	r12,r8[0x0]
800070e6:	2f cb       	sub	r11,-4
800070e8:	f0 1f 00 08 	mcall	80007108 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
800070ec:	48 98       	lddpc	r8,80007110 <prvAddCurrentTaskToDelayedList+0x58>
800070ee:	70 08       	ld.w	r8,r8[0x0]
800070f0:	10 37       	cp.w	r7,r8
800070f2:	c0 32       	brcc	800070f8 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
800070f4:	48 78       	lddpc	r8,80007110 <prvAddCurrentTaskToDelayedList+0x58>
800070f6:	91 07       	st.w	r8[0x0],r7
800070f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800070fc:	00 00       	add	r0,r0
800070fe:	0d 58       	ld.sh	r8,--r6
80007100:	00 00       	add	r0,r0
80007102:	0d 84       	ld.ub	r4,r6[0x0]
80007104:	00 00       	add	r0,r0
80007106:	0c a0       	st.w	r6++,r0
80007108:	80 00       	ld.sh	r0,r0[0x0]
8000710a:	62 2a       	ld.w	r10,r1[0x8]
8000710c:	00 00       	add	r0,r0
8000710e:	0c 90       	mov	r0,r6
80007110:	00 00       	add	r0,r0
80007112:	05 44       	ld.w	r4,--r2

80007114 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80007114:	eb cd 40 c0 	pushm	r6-r7,lr
80007118:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
8000711a:	58 0c       	cp.w	r12,0
8000711c:	c1 10       	breq	8000713e <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
8000711e:	f0 1f 00 0a 	mcall	80007144 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80007122:	48 a8       	lddpc	r8,80007148 <vTaskDelay+0x34>
80007124:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007126:	48 a8       	lddpc	r8,8000714c <vTaskDelay+0x38>
80007128:	70 0c       	ld.w	r12,r8[0x0]
8000712a:	2f cc       	sub	r12,-4
8000712c:	f0 1f 00 09 	mcall	80007150 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80007130:	ee 06 00 0c 	add	r12,r7,r6
80007134:	f0 1f 00 08 	mcall	80007154 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80007138:	f0 1f 00 08 	mcall	80007158 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
8000713c:	c0 21       	brne	80007140 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
8000713e:	d7 33       	scall
80007140:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007144:	80 00       	ld.sh	r0,r0[0x0]
80007146:	6a c4       	ld.w	r4,r5[0x30]
80007148:	00 00       	add	r0,r0
8000714a:	0d 84       	ld.ub	r4,r6[0x0]
8000714c:	00 00       	add	r0,r0
8000714e:	0d 58       	ld.sh	r8,--r6
80007150:	80 00       	ld.sh	r0,r0[0x0]
80007152:	62 5e       	ld.w	lr,r1[0x14]
80007154:	80 00       	ld.sh	r0,r0[0x0]
80007156:	70 b8       	ld.w	r8,r8[0x2c]
80007158:	80 00       	ld.sh	r0,r0[0x0]
8000715a:	6e b8       	ld.w	r8,r7[0x2c]

8000715c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
8000715c:	eb cd 40 c0 	pushm	r6-r7,lr
80007160:	18 96       	mov	r6,r12
80007162:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80007164:	f0 1f 00 18 	mcall	800071c4 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80007168:	6c 08       	ld.w	r8,r6[0x0]
8000716a:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
8000716c:	49 79       	lddpc	r9,800071c8 <vTaskDelayUntil+0x6c>
8000716e:	72 09       	ld.w	r9,r9[0x0]
80007170:	12 38       	cp.w	r8,r9
80007172:	e0 88 00 0c 	brls	8000718a <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80007176:	0e 38       	cp.w	r8,r7
80007178:	e0 88 00 22 	brls	800071bc <vTaskDelayUntil+0x60>
8000717c:	49 38       	lddpc	r8,800071c8 <vTaskDelayUntil+0x6c>
8000717e:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80007180:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80007182:	10 37       	cp.w	r7,r8
80007184:	e0 88 00 14 	brls	800071ac <vTaskDelayUntil+0x50>
80007188:	c0 a8       	rjmp	8000719c <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
8000718a:	0e 38       	cp.w	r8,r7
8000718c:	e0 8b 00 16 	brhi	800071b8 <vTaskDelayUntil+0x5c>
80007190:	48 e8       	lddpc	r8,800071c8 <vTaskDelayUntil+0x6c>
80007192:	70 08       	ld.w	r8,r8[0x0]
80007194:	10 37       	cp.w	r7,r8
80007196:	e0 8b 00 11 	brhi	800071b8 <vTaskDelayUntil+0x5c>
8000719a:	c1 18       	rjmp	800071bc <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000719c:	48 c8       	lddpc	r8,800071cc <vTaskDelayUntil+0x70>
8000719e:	70 0c       	ld.w	r12,r8[0x0]
800071a0:	2f cc       	sub	r12,-4
800071a2:	f0 1f 00 0c 	mcall	800071d0 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800071a6:	0e 9c       	mov	r12,r7
800071a8:	f0 1f 00 0b 	mcall	800071d4 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
800071ac:	f0 1f 00 0b 	mcall	800071d8 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800071b0:	c0 81       	brne	800071c0 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
800071b2:	d7 33       	scall
800071b4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800071b8:	8d 07       	st.w	r6[0x0],r7
800071ba:	cf 1b       	rjmp	8000719c <vTaskDelayUntil+0x40>
800071bc:	8d 07       	st.w	r6[0x0],r7
800071be:	cf 7b       	rjmp	800071ac <vTaskDelayUntil+0x50>
800071c0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800071c4:	80 00       	ld.sh	r0,r0[0x0]
800071c6:	6a c4       	ld.w	r4,r5[0x30]
800071c8:	00 00       	add	r0,r0
800071ca:	0d 84       	ld.ub	r4,r6[0x0]
800071cc:	00 00       	add	r0,r0
800071ce:	0d 58       	ld.sh	r8,--r6
800071d0:	80 00       	ld.sh	r0,r0[0x0]
800071d2:	62 5e       	ld.w	lr,r1[0x14]
800071d4:	80 00       	ld.sh	r0,r0[0x0]
800071d6:	70 b8       	ld.w	r8,r8[0x2c]
800071d8:	80 00       	ld.sh	r0,r0[0x0]
800071da:	6e b8       	ld.w	r8,r7[0x2c]

800071dc <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
800071dc:	eb cd 40 c0 	pushm	r6-r7,lr
800071e0:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
800071e2:	48 e7       	lddpc	r7,80007218 <vTaskPlaceOnEventList+0x3c>
800071e4:	6e 0b       	ld.w	r11,r7[0x0]
800071e6:	2e 8b       	sub	r11,-24
800071e8:	f0 1f 00 0d 	mcall	8000721c <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800071ec:	6e 0c       	ld.w	r12,r7[0x0]
800071ee:	2f cc       	sub	r12,-4
800071f0:	f0 1f 00 0c 	mcall	80007220 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
800071f4:	5b f6       	cp.w	r6,-1
800071f6:	c0 81       	brne	80007206 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800071f8:	6e 0b       	ld.w	r11,r7[0x0]
800071fa:	2f cb       	sub	r11,-4
800071fc:	48 ac       	lddpc	r12,80007224 <vTaskPlaceOnEventList+0x48>
800071fe:	f0 1f 00 0b 	mcall	80007228 <vTaskPlaceOnEventList+0x4c>
80007202:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80007206:	48 a8       	lddpc	r8,8000722c <vTaskPlaceOnEventList+0x50>
80007208:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
8000720a:	ec 0c 00 0c 	add	r12,r6,r12
8000720e:	f0 1f 00 09 	mcall	80007230 <vTaskPlaceOnEventList+0x54>
80007212:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007216:	00 00       	add	r0,r0
80007218:	00 00       	add	r0,r0
8000721a:	0d 58       	ld.sh	r8,--r6
8000721c:	80 00       	ld.sh	r0,r0[0x0]
8000721e:	62 2a       	ld.w	r10,r1[0x8]
80007220:	80 00       	ld.sh	r0,r0[0x0]
80007222:	62 5e       	ld.w	lr,r1[0x14]
80007224:	00 00       	add	r0,r0
80007226:	0d ac       	ld.ub	r12,r6[0x2]
80007228:	80 00       	ld.sh	r0,r0[0x0]
8000722a:	62 0e       	ld.w	lr,r1[0x0]
8000722c:	00 00       	add	r0,r0
8000722e:	0d 84       	ld.ub	r4,r6[0x0]
80007230:	80 00       	ld.sh	r0,r0[0x0]
80007232:	70 b8       	ld.w	r8,r8[0x2c]

80007234 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80007234:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80007238:	49 67       	lddpc	r7,80007290 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000723a:	49 74       	lddpc	r4,80007294 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
8000723c:	49 73       	lddpc	r3,80007298 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
8000723e:	49 85       	lddpc	r5,8000729c <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80007240:	6e 08       	ld.w	r8,r7[0x0]
80007242:	58 08       	cp.w	r8,0
80007244:	c1 e0       	breq	80007280 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80007246:	f0 1f 00 17 	mcall	800072a0 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000724a:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
8000724c:	f0 1f 00 16 	mcall	800072a4 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80007250:	58 06       	cp.w	r6,0
80007252:	c1 70       	breq	80007280 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80007254:	f0 1f 00 15 	mcall	800072a8 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80007258:	68 38       	ld.w	r8,r4[0xc]
8000725a:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
8000725c:	ec cc ff fc 	sub	r12,r6,-4
80007260:	f0 1f 00 13 	mcall	800072ac <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80007264:	66 08       	ld.w	r8,r3[0x0]
80007266:	20 18       	sub	r8,1
80007268:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
8000726a:	6e 08       	ld.w	r8,r7[0x0]
8000726c:	20 18       	sub	r8,1
8000726e:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80007270:	f0 1f 00 10 	mcall	800072b0 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80007274:	6c cc       	ld.w	r12,r6[0x30]
80007276:	f0 1f 00 10 	mcall	800072b4 <prvIdleTask+0x80>
		vPortFree( pxTCB );
8000727a:	0c 9c       	mov	r12,r6
8000727c:	f0 1f 00 0e 	mcall	800072b4 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80007280:	6a 08       	ld.w	r8,r5[0x0]
80007282:	58 18       	cp.w	r8,1
80007284:	e0 88 00 03 	brls	8000728a <prvIdleTask+0x56>
			{
				taskYIELD();
80007288:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
8000728a:	f0 1f 00 0c 	mcall	800072b8 <prvIdleTask+0x84>
		}
		#endif
	}
8000728e:	cd 9b       	rjmp	80007240 <prvIdleTask+0xc>
80007290:	00 00       	add	r0,r0
80007292:	0c 98       	mov	r8,r6
80007294:	00 00       	add	r0,r0
80007296:	0d 44       	ld.w	r4,--r6
80007298:	00 00       	add	r0,r0
8000729a:	0d a4       	ld.ub	r4,r6[0x2]
8000729c:	00 00       	add	r0,r0
8000729e:	0c a4       	st.w	r6++,r4
800072a0:	80 00       	ld.sh	r0,r0[0x0]
800072a2:	6a c4       	ld.w	r4,r5[0x30]
800072a4:	80 00       	ld.sh	r0,r0[0x0]
800072a6:	6e b8       	ld.w	r8,r7[0x2c]
800072a8:	80 00       	ld.sh	r0,r0[0x0]
800072aa:	63 18       	ld.w	r8,r1[0x44]
800072ac:	80 00       	ld.sh	r0,r0[0x0]
800072ae:	62 5e       	ld.w	lr,r1[0x14]
800072b0:	80 00       	ld.sh	r0,r0[0x0]
800072b2:	64 24       	ld.w	r4,r2[0x8]
800072b4:	80 00       	ld.sh	r0,r0[0x0]
800072b6:	65 5c       	ld.w	r12,r2[0x54]
800072b8:	80 00       	ld.sh	r0,r0[0x0]
800072ba:	20 2c       	sub	r12,2

800072bc <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
800072bc:	d4 31       	pushm	r0-r7,lr
800072be:	20 1d       	sub	sp,4
800072c0:	fa c4 ff d8 	sub	r4,sp,-40
800072c4:	50 0c       	stdsp	sp[0x0],r12
800072c6:	16 91       	mov	r1,r11
800072c8:	14 97       	mov	r7,r10
800072ca:	12 90       	mov	r0,r9
800072cc:	10 93       	mov	r3,r8
800072ce:	68 02       	ld.w	r2,r4[0x0]
800072d0:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
800072d2:	34 8c       	mov	r12,72
800072d4:	f0 1f 00 5c 	mcall	80007444 <xTaskGenericCreate+0x188>
800072d8:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
800072da:	c0 31       	brne	800072e0 <xTaskGenericCreate+0x24>
800072dc:	3f fc       	mov	r12,-1
800072de:	ca f8       	rjmp	8000743c <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800072e0:	58 06       	cp.w	r6,0
800072e2:	e0 81 00 af 	brne	80007440 <xTaskGenericCreate+0x184>
800072e6:	0e 9c       	mov	r12,r7
800072e8:	5c 7c       	castu.h	r12
800072ea:	a3 6c       	lsl	r12,0x2
800072ec:	f0 1f 00 56 	mcall	80007444 <xTaskGenericCreate+0x188>
800072f0:	18 96       	mov	r6,r12
800072f2:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
800072f4:	c0 61       	brne	80007300 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
800072f6:	0a 9c       	mov	r12,r5
800072f8:	f0 1f 00 54 	mcall	80007448 <xTaskGenericCreate+0x18c>
800072fc:	3f fc       	mov	r12,-1
800072fe:	c9 f8       	rjmp	8000743c <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80007300:	5c 77       	castu.h	r7
80007302:	ee 0a 15 02 	lsl	r10,r7,0x2
80007306:	e0 6b 00 a5 	mov	r11,165
8000730a:	0c 9c       	mov	r12,r6
8000730c:	f0 1f 00 50 	mcall	8000744c <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80007310:	ee c6 00 01 	sub	r6,r7,1
80007314:	6a c8       	ld.w	r8,r5[0x30]
80007316:	f0 06 00 26 	add	r6,r8,r6<<0x2
8000731a:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
8000731e:	31 0a       	mov	r10,16
80007320:	02 9b       	mov	r11,r1
80007322:	ea cc ff cc 	sub	r12,r5,-52
80007326:	f0 1f 00 4b 	mcall	80007450 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
8000732a:	30 08       	mov	r8,0
8000732c:	eb 68 00 43 	st.b	r5[67],r8
80007330:	58 73       	cp.w	r3,7
80007332:	e6 07 17 80 	movls	r7,r3
80007336:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
8000733a:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
8000733c:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80007340:	ea c4 ff fc 	sub	r4,r5,-4
80007344:	08 9c       	mov	r12,r4
80007346:	f0 1f 00 44 	mcall	80007454 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
8000734a:	ea cc ff e8 	sub	r12,r5,-24
8000734e:	f0 1f 00 42 	mcall	80007454 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80007352:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80007354:	ee 07 11 08 	rsub	r7,r7,8
80007358:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
8000735a:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
8000735c:	00 9a       	mov	r10,r0
8000735e:	40 0b       	lddsp	r11,sp[0x0]
80007360:	0c 9c       	mov	r12,r6
80007362:	f0 1f 00 3e 	mcall	80007458 <xTaskGenericCreate+0x19c>
80007366:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80007368:	58 02       	cp.w	r2,0
8000736a:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
8000736e:	f0 1f 00 3c 	mcall	8000745c <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80007372:	4b c8       	lddpc	r8,80007460 <xTaskGenericCreate+0x1a4>
80007374:	70 09       	ld.w	r9,r8[0x0]
80007376:	2f f9       	sub	r9,-1
80007378:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
8000737a:	4b b8       	lddpc	r8,80007464 <xTaskGenericCreate+0x1a8>
8000737c:	70 08       	ld.w	r8,r8[0x0]
8000737e:	58 08       	cp.w	r8,0
80007380:	c2 61       	brne	800073cc <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80007382:	4b 98       	lddpc	r8,80007464 <xTaskGenericCreate+0x1a8>
80007384:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80007386:	4b 78       	lddpc	r8,80007460 <xTaskGenericCreate+0x1a4>
80007388:	70 08       	ld.w	r8,r8[0x0]
8000738a:	58 18       	cp.w	r8,1
8000738c:	c2 b1       	brne	800073e2 <xTaskGenericCreate+0x126>
8000738e:	4b 77       	lddpc	r7,80007468 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80007390:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80007394:	0e 9c       	mov	r12,r7
80007396:	f0 1f 00 36 	mcall	8000746c <xTaskGenericCreate+0x1b0>
8000739a:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
8000739c:	0c 37       	cp.w	r7,r6
8000739e:	cf b1       	brne	80007394 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
800073a0:	4b 47       	lddpc	r7,80007470 <xTaskGenericCreate+0x1b4>
800073a2:	0e 9c       	mov	r12,r7
800073a4:	f0 1f 00 32 	mcall	8000746c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
800073a8:	4b 36       	lddpc	r6,80007474 <xTaskGenericCreate+0x1b8>
800073aa:	0c 9c       	mov	r12,r6
800073ac:	f0 1f 00 30 	mcall	8000746c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
800073b0:	4b 2c       	lddpc	r12,80007478 <xTaskGenericCreate+0x1bc>
800073b2:	f0 1f 00 2f 	mcall	8000746c <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
800073b6:	4b 2c       	lddpc	r12,8000747c <xTaskGenericCreate+0x1c0>
800073b8:	f0 1f 00 2d 	mcall	8000746c <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
800073bc:	4b 1c       	lddpc	r12,80007480 <xTaskGenericCreate+0x1c4>
800073be:	f0 1f 00 2c 	mcall	8000746c <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
800073c2:	4b 18       	lddpc	r8,80007484 <xTaskGenericCreate+0x1c8>
800073c4:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
800073c6:	4b 18       	lddpc	r8,80007488 <xTaskGenericCreate+0x1cc>
800073c8:	91 06       	st.w	r8[0x0],r6
800073ca:	c0 c8       	rjmp	800073e2 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
800073cc:	4b 08       	lddpc	r8,8000748c <xTaskGenericCreate+0x1d0>
800073ce:	70 08       	ld.w	r8,r8[0x0]
800073d0:	58 08       	cp.w	r8,0
800073d2:	c0 81       	brne	800073e2 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
800073d4:	4a 48       	lddpc	r8,80007464 <xTaskGenericCreate+0x1a8>
800073d6:	70 08       	ld.w	r8,r8[0x0]
800073d8:	70 b8       	ld.w	r8,r8[0x2c]
800073da:	10 33       	cp.w	r3,r8
800073dc:	c0 33       	brcs	800073e2 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
800073de:	4a 28       	lddpc	r8,80007464 <xTaskGenericCreate+0x1a8>
800073e0:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
800073e2:	6a b8       	ld.w	r8,r5[0x2c]
800073e4:	4a b9       	lddpc	r9,80007490 <xTaskGenericCreate+0x1d4>
800073e6:	72 09       	ld.w	r9,r9[0x0]
800073e8:	12 38       	cp.w	r8,r9
800073ea:	e0 88 00 04 	brls	800073f2 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
800073ee:	4a 99       	lddpc	r9,80007490 <xTaskGenericCreate+0x1d4>
800073f0:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
800073f2:	4a 98       	lddpc	r8,80007494 <xTaskGenericCreate+0x1d8>
800073f4:	70 09       	ld.w	r9,r8[0x0]
800073f6:	2f f9       	sub	r9,-1
800073f8:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
800073fa:	6a b8       	ld.w	r8,r5[0x2c]
800073fc:	4a 79       	lddpc	r9,80007498 <xTaskGenericCreate+0x1dc>
800073fe:	72 09       	ld.w	r9,r9[0x0]
80007400:	12 38       	cp.w	r8,r9
80007402:	e0 88 00 04 	brls	8000740a <xTaskGenericCreate+0x14e>
80007406:	4a 59       	lddpc	r9,80007498 <xTaskGenericCreate+0x1dc>
80007408:	93 08       	st.w	r9[0x0],r8
8000740a:	6a bc       	ld.w	r12,r5[0x2c]
8000740c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007410:	08 9b       	mov	r11,r4
80007412:	49 68       	lddpc	r8,80007468 <xTaskGenericCreate+0x1ac>
80007414:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007418:	f0 1f 00 21 	mcall	8000749c <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
8000741c:	f0 1f 00 21 	mcall	800074a0 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80007420:	49 b8       	lddpc	r8,8000748c <xTaskGenericCreate+0x1d0>
80007422:	70 08       	ld.w	r8,r8[0x0]
80007424:	58 08       	cp.w	r8,0
80007426:	c0 a0       	breq	8000743a <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80007428:	48 f8       	lddpc	r8,80007464 <xTaskGenericCreate+0x1a8>
8000742a:	70 08       	ld.w	r8,r8[0x0]
8000742c:	70 b8       	ld.w	r8,r8[0x2c]
8000742e:	10 33       	cp.w	r3,r8
80007430:	e0 88 00 05 	brls	8000743a <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80007434:	d7 33       	scall
80007436:	30 1c       	mov	r12,1
80007438:	c0 28       	rjmp	8000743c <xTaskGenericCreate+0x180>
8000743a:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
8000743c:	2f fd       	sub	sp,-4
8000743e:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80007440:	99 c6       	st.w	r12[0x30],r6
80007442:	c5 fb       	rjmp	80007300 <xTaskGenericCreate+0x44>
80007444:	80 00       	ld.sh	r0,r0[0x0]
80007446:	65 84       	ld.w	r4,r2[0x60]
80007448:	80 00       	ld.sh	r0,r0[0x0]
8000744a:	65 5c       	ld.w	r12,r2[0x54]
8000744c:	80 00       	ld.sh	r0,r0[0x0]
8000744e:	80 6a       	ld.sh	r10,r0[0xc]
80007450:	80 00       	ld.sh	r0,r0[0x0]
80007452:	83 94       	st.w	r1[0x24],r4
80007454:	80 00       	ld.sh	r0,r0[0x0]
80007456:	62 08       	ld.w	r8,r1[0x0]
80007458:	80 00       	ld.sh	r0,r0[0x0]
8000745a:	62 84       	ld.w	r4,r1[0x20]
8000745c:	80 00       	ld.sh	r0,r0[0x0]
8000745e:	63 18       	ld.w	r8,r1[0x44]
80007460:	00 00       	add	r0,r0
80007462:	0d a4       	ld.ub	r4,r6[0x2]
80007464:	00 00       	add	r0,r0
80007466:	0d 58       	ld.sh	r8,--r6
80007468:	00 00       	add	r0,r0
8000746a:	0c a4       	st.w	r6++,r4
8000746c:	80 00       	ld.sh	r0,r0[0x0]
8000746e:	61 f4       	ld.w	r4,r0[0x7c]
80007470:	00 00       	add	r0,r0
80007472:	0d 70       	ld.ub	r0,--r6
80007474:	00 00       	add	r0,r0
80007476:	0d 8c       	ld.ub	r12,r6[0x0]
80007478:	00 00       	add	r0,r0
8000747a:	0d 5c       	ld.sh	r12,--r6
8000747c:	00 00       	add	r0,r0
8000747e:	0d 44       	ld.w	r4,--r6
80007480:	00 00       	add	r0,r0
80007482:	0d ac       	ld.ub	r12,r6[0x2]
80007484:	00 00       	add	r0,r0
80007486:	0c 90       	mov	r0,r6
80007488:	00 00       	add	r0,r0
8000748a:	0c a0       	st.w	r6++,r0
8000748c:	00 00       	add	r0,r0
8000748e:	0c 94       	mov	r4,r6
80007490:	00 00       	add	r0,r0
80007492:	0c 8c       	andn	r12,r6
80007494:	00 00       	add	r0,r0
80007496:	0d a0       	ld.ub	r0,r6[0x2]
80007498:	00 00       	add	r0,r0
8000749a:	0d c0       	ld.ub	r0,r6[0x4]
8000749c:	80 00       	ld.sh	r0,r0[0x0]
8000749e:	62 0e       	ld.w	lr,r1[0x0]
800074a0:	80 00       	ld.sh	r0,r0[0x0]
800074a2:	64 24       	ld.w	r4,r2[0x8]

800074a4 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
800074a4:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
800074a6:	30 09       	mov	r9,0
800074a8:	1a d9       	st.w	--sp,r9
800074aa:	1a d9       	st.w	--sp,r9
800074ac:	1a d9       	st.w	--sp,r9
800074ae:	12 98       	mov	r8,r9
800074b0:	e0 6a 01 00 	mov	r10,256
800074b4:	48 9b       	lddpc	r11,800074d8 <vTaskStartScheduler+0x34>
800074b6:	48 ac       	lddpc	r12,800074dc <vTaskStartScheduler+0x38>
800074b8:	f0 1f 00 0a 	mcall	800074e0 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
800074bc:	2f dd       	sub	sp,-12
800074be:	58 1c       	cp.w	r12,1
800074c0:	c0 a1       	brne	800074d4 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
800074c2:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
800074c4:	30 19       	mov	r9,1
800074c6:	48 88       	lddpc	r8,800074e4 <vTaskStartScheduler+0x40>
800074c8:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
800074ca:	30 09       	mov	r9,0
800074cc:	48 78       	lddpc	r8,800074e8 <vTaskStartScheduler+0x44>
800074ce:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
800074d0:	f0 1f 00 07 	mcall	800074ec <vTaskStartScheduler+0x48>
800074d4:	d8 02       	popm	pc
800074d6:	00 00       	add	r0,r0
800074d8:	80 00       	ld.sh	r0,r0[0x0]
800074da:	e1 44 80 00 	st.w	r0[-32768],r4
800074de:	72 34       	ld.w	r4,r9[0xc]
800074e0:	80 00       	ld.sh	r0,r0[0x0]
800074e2:	72 bc       	ld.w	r12,r9[0x2c]
800074e4:	00 00       	add	r0,r0
800074e6:	0c 94       	mov	r4,r6
800074e8:	00 00       	add	r0,r0
800074ea:	0d 84       	ld.ub	r4,r6[0x0]
800074ec:	80 00       	ld.sh	r0,r0[0x0]
800074ee:	63 28       	ld.w	r8,r1[0x48]

800074f0 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
800074f0:	16 cc       	st.b	r11++,r12
	return str;
}
800074f2:	5e fb       	retal	r11

800074f4 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
800074f4:	eb cd 40 c0 	pushm	r6-r7,lr
800074f8:	20 3d       	sub	sp,12
800074fa:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
800074fc:	30 06       	mov	r6,0
800074fe:	30 07       	mov	r7,0
80007500:	fa e7 00 00 	st.d	sp[0],r6
80007504:	30 0c       	mov	r12,0
80007506:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80007508:	58 08       	cp.w	r8,0
8000750a:	c1 30       	breq	80007530 <PrintHex+0x3c>
8000750c:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
8000750e:	1a 9c       	mov	r12,sp
80007510:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80007514:	58 9e       	cp.w	lr,9
80007516:	e0 8a 00 04 	brle	8000751e <PrintHex+0x2a>
8000751a:	2c 9e       	sub	lr,-55
8000751c:	c0 48       	rjmp	80007524 <PrintHex+0x30>
8000751e:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80007522:	2d 0e       	sub	lr,-48
80007524:	f8 09 0b 0e 	st.b	r12[r9],lr
80007528:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
8000752a:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
8000752c:	cf 21       	brne	80007510 <PrintHex+0x1c>
8000752e:	c0 48       	rjmp	80007536 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80007530:	33 08       	mov	r8,48
80007532:	ba 88       	st.b	sp[0x0],r8
80007534:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80007536:	f6 09 01 08 	sub	r8,r11,r9
8000753a:	58 08       	cp.w	r8,0
8000753c:	e0 8a 00 13 	brle	80007562 <PrintHex+0x6e>
	{
		char num = len - cnt;
80007540:	12 1b       	sub	r11,r9
80007542:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80007546:	18 9e       	mov	lr,r12
80007548:	58 0c       	cp.w	r12,0
8000754a:	e0 8a 00 0c 	brle	80007562 <PrintHex+0x6e>
8000754e:	1a 9b       	mov	r11,sp
80007550:	12 0b       	add	r11,r9
80007552:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80007554:	33 07       	mov	r7,48
80007556:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007558:	2f f8       	sub	r8,-1
8000755a:	1c 38       	cp.w	r8,lr
8000755c:	cf d5       	brlt	80007556 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000755e:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80007562:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80007566:	f0 cb ff ff 	sub	r11,r8,-1
8000756a:	58 0b       	cp.w	r11,0
8000756c:	e0 8a 00 19 	brle	8000759e <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80007570:	fa cb ff f4 	sub	r11,sp,-12
80007574:	f6 09 00 09 	add	r9,r11,r9
80007578:	37 8b       	mov	r11,120
8000757a:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
8000757e:	fa c9 ff f4 	sub	r9,sp,-12
80007582:	10 09       	add	r9,r8
80007584:	33 0b       	mov	r11,48
80007586:	f3 6b ff f4 	st.b	r9[-12],r11
8000758a:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000758e:	fa ce 00 01 	sub	lr,sp,1
80007592:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80007594:	11 8b       	ld.ub	r11,r8[0x0]
80007596:	12 cb       	st.b	r9++,r11
80007598:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
8000759a:	1c 38       	cp.w	r8,lr
8000759c:	cf c1       	brne	80007594 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
8000759e:	14 9c       	mov	r12,r10
800075a0:	2f dd       	sub	sp,-12
800075a2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

800075a6 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
800075a6:	d4 21       	pushm	r4-r7,lr
800075a8:	20 3d       	sub	sp,12
800075aa:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
800075ac:	30 06       	mov	r6,0
800075ae:	30 07       	mov	r7,0
800075b0:	fa e7 00 00 	st.d	sp[0],r6
800075b4:	30 0c       	mov	r12,0
800075b6:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
800075b8:	58 08       	cp.w	r8,0
800075ba:	c0 35       	brlt	800075c0 <PrintDec+0x1a>
800075bc:	14 97       	mov	r7,r10
800075be:	c0 58       	rjmp	800075c8 <PrintDec+0x22>
	{
		*p++ = '-';
800075c0:	14 97       	mov	r7,r10
800075c2:	32 d9       	mov	r9,45
800075c4:	0e c9       	st.b	r7++,r9
		i = -i;
800075c6:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
800075c8:	58 08       	cp.w	r8,0
800075ca:	c0 51       	brne	800075d4 <PrintDec+0x2e>
800075cc:	33 08       	mov	r8,48
800075ce:	ba 88       	st.b	sp[0x0],r8
800075d0:	30 1e       	mov	lr,1
800075d2:	c2 f8       	rjmp	80007630 <PrintDec+0x8a>
	
	int ten = i%10;
800075d4:	e0 65 66 67 	mov	r5,26215
800075d8:	ea 15 66 66 	orh	r5,0x6666
800075dc:	f0 05 04 44 	muls.d	r4,r8,r5
800075e0:	ea 0c 14 02 	asr	r12,r5,0x2
800075e4:	f0 09 14 1f 	asr	r9,r8,0x1f
800075e8:	f8 09 01 09 	sub	r9,r12,r9
800075ec:	f2 09 00 29 	add	r9,r9,r9<<0x2
800075f0:	f0 09 01 19 	sub	r9,r8,r9<<0x1
800075f4:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
800075f6:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
800075f8:	e0 66 66 67 	mov	r6,26215
800075fc:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80007600:	2d 09       	sub	r9,-48
80007602:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80007606:	2f fe       	sub	lr,-1
		i /= 10;
80007608:	f0 06 04 44 	muls.d	r4,r8,r6
8000760c:	ea 09 14 02 	asr	r9,r5,0x2
80007610:	bf 58       	asr	r8,0x1f
80007612:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80007616:	f0 06 04 44 	muls.d	r4,r8,r6
8000761a:	ea 09 14 02 	asr	r9,r5,0x2
8000761e:	f0 05 14 1f 	asr	r5,r8,0x1f
80007622:	0a 19       	sub	r9,r5
80007624:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007628:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
8000762c:	58 08       	cp.w	r8,0
8000762e:	ce 91       	brne	80007600 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80007630:	f6 0e 01 08 	sub	r8,r11,lr
80007634:	58 08       	cp.w	r8,0
80007636:	e0 89 00 06 	brgt	80007642 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000763a:	58 0e       	cp.w	lr,0
8000763c:	e0 89 00 14 	brgt	80007664 <PrintDec+0xbe>
80007640:	c1 d8       	rjmp	8000767a <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80007642:	1c 1b       	sub	r11,lr
80007644:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80007646:	16 9c       	mov	r12,r11
80007648:	58 0b       	cp.w	r11,0
8000764a:	fe 9a ff f8 	brle	8000763a <PrintDec+0x94>
8000764e:	1a 99       	mov	r9,sp
80007650:	1c 09       	add	r9,lr
80007652:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80007654:	33 06       	mov	r6,48
80007656:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007658:	2f f8       	sub	r8,-1
8000765a:	18 38       	cp.w	r8,r12
8000765c:	cf d5       	brlt	80007656 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
8000765e:	f6 0e 00 0e 	add	lr,r11,lr
80007662:	ce cb       	rjmp	8000763a <PrintDec+0x94>
80007664:	fa c8 ff f4 	sub	r8,sp,-12
80007668:	1c 08       	add	r8,lr
8000766a:	20 d8       	sub	r8,13
8000766c:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80007670:	11 89       	ld.ub	r9,r8[0x0]
80007672:	0e c9       	st.b	r7++,r9
80007674:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80007676:	16 38       	cp.w	r8,r11
80007678:	cf c1       	brne	80007670 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
8000767a:	14 9c       	mov	r12,r10
8000767c:	2f dd       	sub	sp,-12
8000767e:	d8 22       	popm	r4-r7,pc

80007680 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80007680:	d4 31       	pushm	r0-r7,lr
80007682:	fa cd 02 08 	sub	sp,sp,520
80007686:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80007688:	e0 6a 01 00 	mov	r10,256
8000768c:	30 0b       	mov	r11,0
8000768e:	fa cc fe f8 	sub	r12,sp,-264
80007692:	f0 1f 00 4e 	mcall	800077c8 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80007696:	fa c4 fd d4 	sub	r4,sp,-556
8000769a:	30 0a       	mov	r10,0
8000769c:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000769e:	fa c3 ff fc 	sub	r3,sp,-4
800076a2:	e0 61 01 00 	mov	r1,256
800076a6:	14 90       	mov	r0,r10
			
					if(*str == '%')
800076a8:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800076aa:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800076ae:	02 9a       	mov	r10,r1
800076b0:	00 9b       	mov	r11,r0
800076b2:	06 9c       	mov	r12,r3
800076b4:	f0 1f 00 45 	mcall	800077c8 <log+0x148>
			
					if(*str == '%')
800076b8:	0f 88       	ld.ub	r8,r7[0x0]
800076ba:	e4 08 18 00 	cp.b	r8,r2
800076be:	c5 71       	brne	8000776c <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
800076c0:	ee c8 ff ff 	sub	r8,r7,-1
800076c4:	11 89       	ld.ub	r9,r8[0x0]
800076c6:	4c 2a       	lddpc	r10,800077cc <log+0x14c>
800076c8:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
800076ca:	23 09       	sub	r9,48
800076cc:	30 9a       	mov	r10,9
800076ce:	f4 09 18 00 	cp.b	r9,r10
800076d2:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
800076d6:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800076da:	f7 b9 08 30 	subls	r9,48
800076de:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
800076e2:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
800076e6:	0f 88       	ld.ub	r8,r7[0x0]
800076e8:	22 58       	sub	r8,37
800076ea:	e0 48 00 53 	cp.w	r8,83
800076ee:	e0 8b 00 31 	brhi	80007750 <log+0xd0>
800076f2:	4b 89       	lddpc	r9,800077d0 <log+0x150>
800076f4:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
800076f8:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
800076fc:	06 9a       	mov	r10,r3
800076fe:	40 0b       	lddsp	r11,sp[0x0]
80007700:	5c 5b       	castu.b	r11
80007702:	68 0c       	ld.w	r12,r4[0x0]
80007704:	f0 1f 00 34 	mcall	800077d4 <log+0x154>
							break;
80007708:	c2 98       	rjmp	8000775a <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
8000770a:	4b 4c       	lddpc	r12,800077d8 <log+0x158>
8000770c:	f0 1f 00 34 	mcall	800077dc <log+0x15c>
80007710:	08 95       	mov	r5,r4
80007712:	06 9c       	mov	r12,r3
							break;
80007714:	c2 38       	rjmp	8000775a <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80007716:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
8000771a:	06 9a       	mov	r10,r3
8000771c:	40 0b       	lddsp	r11,sp[0x0]
8000771e:	5c 5b       	castu.b	r11
80007720:	68 0c       	ld.w	r12,r4[0x0]
80007722:	f0 1f 00 30 	mcall	800077e0 <log+0x160>
80007726:	06 9c       	mov	r12,r3
							break;
80007728:	c1 98       	rjmp	8000775a <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
8000772a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
8000772e:	06 9b       	mov	r11,r3
80007730:	09 bc       	ld.ub	r12,r4[0x3]
80007732:	f0 1f 00 2d 	mcall	800077e4 <log+0x164>
80007736:	06 9c       	mov	r12,r3
							break;
80007738:	c1 18       	rjmp	8000775a <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
8000773a:	e8 c5 ff fc 	sub	r5,r4,-4
8000773e:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80007740:	c0 d8       	rjmp	8000775a <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80007742:	06 9b       	mov	r11,r3
80007744:	32 5c       	mov	r12,37
80007746:	f0 1f 00 28 	mcall	800077e4 <log+0x164>
8000774a:	08 95       	mov	r5,r4
8000774c:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
8000774e:	c0 68       	rjmp	8000775a <log+0xda>
							
							default:
							log("I need relax.");
80007750:	4a 6c       	lddpc	r12,800077e8 <log+0x168>
80007752:	f0 1f 00 23 	mcall	800077dc <log+0x15c>
80007756:	08 95       	mov	r5,r4
80007758:	06 9c       	mov	r12,r3
						}
						str++;
8000775a:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000775c:	1a dc       	st.w	--sp,r12
8000775e:	1a d6       	st.w	--sp,r6
80007760:	4a 3b       	lddpc	r11,800077ec <log+0x16c>
80007762:	0c 9c       	mov	r12,r6
80007764:	f0 1f 00 23 	mcall	800077f0 <log+0x170>
80007768:	2f ed       	sub	sp,-8
8000776a:	c0 a8       	rjmp	8000777e <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000776c:	2f f7       	sub	r7,-1
8000776e:	1a d8       	st.w	--sp,r8
80007770:	1a d6       	st.w	--sp,r6
80007772:	4a 1b       	lddpc	r11,800077f4 <log+0x174>
80007774:	0c 9c       	mov	r12,r6
80007776:	f0 1f 00 1f 	mcall	800077f0 <log+0x170>
8000777a:	08 95       	mov	r5,r4
8000777c:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
8000777e:	0f 89       	ld.ub	r9,r7[0x0]
80007780:	30 08       	mov	r8,0
80007782:	f0 09 18 00 	cp.b	r9,r8
80007786:	c0 30       	breq	8000778c <log+0x10c>
80007788:	0a 94       	mov	r4,r5
8000778a:	c9 2b       	rjmp	800076ae <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
8000778c:	fa c7 fe f8 	sub	r7,sp,-264
80007790:	1a d7       	st.w	--sp,r7
80007792:	49 ab       	lddpc	r11,800077f8 <log+0x178>
80007794:	0e 9c       	mov	r12,r7
80007796:	f0 1f 00 17 	mcall	800077f0 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
8000779a:	5c 5c       	castu.b	r12
8000779c:	f8 c6 ff ff 	sub	r6,r12,-1
800077a0:	0c 9c       	mov	r12,r6
800077a2:	f0 1f 00 17 	mcall	800077fc <log+0x17c>
800077a6:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
800077a8:	0c 9a       	mov	r10,r6
800077aa:	0e 9b       	mov	r11,r7
800077ac:	f0 1f 00 15 	mcall	80007800 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
800077b0:	30 09       	mov	r9,0
800077b2:	30 5a       	mov	r10,5
800077b4:	fa cb fe f8 	sub	r11,sp,-264
800077b8:	49 38       	lddpc	r8,80007804 <log+0x184>
800077ba:	70 0c       	ld.w	r12,r8[0x0]
800077bc:	f0 1f 00 13 	mcall	80007808 <log+0x188>
800077c0:	2f fd       	sub	sp,-4
	
	
}
800077c2:	fe 3d fd f8 	sub	sp,-520
800077c6:	d8 32       	popm	r0-r7,pc
800077c8:	80 00       	ld.sh	r0,r0[0x0]
800077ca:	80 6a       	ld.sh	r10,r0[0xc]
800077cc:	00 00       	add	r0,r0
800077ce:	0d c4       	ld.ub	r4,r6[0x4]
800077d0:	80 00       	ld.sh	r0,r0[0x0]
800077d2:	e1 4c 80 00 	st.w	r0[-32768],r12
800077d6:	75 a6       	ld.w	r6,r10[0x68]
800077d8:	80 00       	ld.sh	r0,r0[0x0]
800077da:	e3 f8 80 00 	ld.wls	r8,r1[0x0]
800077de:	76 80       	ld.w	r0,r11[0x20]
800077e0:	80 00       	ld.sh	r0,r0[0x0]
800077e2:	74 f4       	ld.w	r4,r10[0x3c]
800077e4:	80 00       	ld.sh	r0,r0[0x0]
800077e6:	74 f0       	ld.w	r0,r10[0x3c]
800077e8:	80 00       	ld.sh	r0,r0[0x0]
800077ea:	e4 08       	*unknown*
800077ec:	80 00       	ld.sh	r0,r0[0x0]
800077ee:	e4 18 80 00 	andh	r8,0x8000
800077f2:	83 58       	st.w	r1[0x14],r8
800077f4:	80 00       	ld.sh	r0,r0[0x0]
800077f6:	e4 20 80 00 	sub	r0,294912
800077fa:	e4 28 80 00 	sub	r8,294912
800077fe:	65 84       	ld.w	r4,r2[0x60]
80007800:	80 00       	ld.sh	r0,r0[0x0]
80007802:	7f 22       	ld.w	r2,pc[0x48]
80007804:	00 00       	add	r0,r0
80007806:	54 2c       	stdsp	sp[0x108],r12
80007808:	80 00       	ld.sh	r0,r0[0x0]
8000780a:	68 d8       	ld.w	r8,r4[0x34]

8000780c <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
8000780c:	d4 31       	pushm	r0-r7,lr
8000780e:	fa cd 02 0c 	sub	sp,sp,524
80007812:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80007814:	e0 6a 01 00 	mov	r10,256
80007818:	30 0b       	mov	r11,0
8000781a:	fa cc fe f4 	sub	r12,sp,-268
8000781e:	f0 1f 00 4c 	mcall	8000794c <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80007822:	fa c4 fd d0 	sub	r4,sp,-560
80007826:	30 0a       	mov	r10,0
80007828:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000782a:	fa c3 ff fc 	sub	r3,sp,-4
8000782e:	e0 61 01 00 	mov	r1,256
80007832:	14 90       	mov	r0,r10
			
			if(*str == '%')
80007834:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007836:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000783a:	02 9a       	mov	r10,r1
8000783c:	00 9b       	mov	r11,r0
8000783e:	06 9c       	mov	r12,r3
80007840:	f0 1f 00 43 	mcall	8000794c <logFromISR+0x140>
			
			if(*str == '%')
80007844:	0f 88       	ld.ub	r8,r7[0x0]
80007846:	e4 08 18 00 	cp.b	r8,r2
8000784a:	c5 11       	brne	800078ec <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
8000784c:	ee c8 ff ff 	sub	r8,r7,-1
80007850:	11 89       	ld.ub	r9,r8[0x0]
80007852:	4c 0a       	lddpc	r10,80007950 <logFromISR+0x144>
80007854:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80007856:	23 09       	sub	r9,48
80007858:	30 9a       	mov	r10,9
8000785a:	f4 09 18 00 	cp.b	r9,r10
8000785e:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80007862:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80007866:	f7 b9 08 30 	subls	r9,48
8000786a:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
8000786e:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80007872:	0f 88       	ld.ub	r8,r7[0x0]
80007874:	22 58       	sub	r8,37
80007876:	e0 48 00 53 	cp.w	r8,83
8000787a:	e0 8b 00 2b 	brhi	800078d0 <logFromISR+0xc4>
8000787e:	4b 69       	lddpc	r9,80007954 <logFromISR+0x148>
80007880:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80007884:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80007888:	06 9a       	mov	r10,r3
8000788a:	40 0b       	lddsp	r11,sp[0x0]
8000788c:	5c 5b       	castu.b	r11
8000788e:	68 0c       	ld.w	r12,r4[0x0]
80007890:	f0 1f 00 32 	mcall	80007958 <logFromISR+0x14c>
					break;
80007894:	c2 38       	rjmp	800078da <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80007896:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
8000789a:	06 9a       	mov	r10,r3
8000789c:	40 0b       	lddsp	r11,sp[0x0]
8000789e:	5c 5b       	castu.b	r11
800078a0:	68 0c       	ld.w	r12,r4[0x0]
800078a2:	f0 1f 00 2f 	mcall	8000795c <logFromISR+0x150>
800078a6:	06 9c       	mov	r12,r3
					break;
800078a8:	c1 98       	rjmp	800078da <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
800078aa:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
800078ae:	06 9b       	mov	r11,r3
800078b0:	09 bc       	ld.ub	r12,r4[0x3]
800078b2:	f0 1f 00 2c 	mcall	80007960 <logFromISR+0x154>
800078b6:	06 9c       	mov	r12,r3
					break;
800078b8:	c1 18       	rjmp	800078da <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
800078ba:	e8 c5 ff fc 	sub	r5,r4,-4
800078be:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
800078c0:	c0 d8       	rjmp	800078da <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
800078c2:	06 9b       	mov	r11,r3
800078c4:	32 5c       	mov	r12,37
800078c6:	f0 1f 00 27 	mcall	80007960 <logFromISR+0x154>
800078ca:	08 95       	mov	r5,r4
800078cc:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
800078ce:	c0 68       	rjmp	800078da <logFromISR+0xce>
					default:
					log("I need relax.");
800078d0:	4a 5c       	lddpc	r12,80007964 <logFromISR+0x158>
800078d2:	f0 1f 00 26 	mcall	80007968 <logFromISR+0x15c>
800078d6:	08 95       	mov	r5,r4
800078d8:	06 9c       	mov	r12,r3
				}
				str++;
800078da:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800078dc:	1a dc       	st.w	--sp,r12
800078de:	1a d6       	st.w	--sp,r6
800078e0:	4a 3b       	lddpc	r11,8000796c <logFromISR+0x160>
800078e2:	0c 9c       	mov	r12,r6
800078e4:	f0 1f 00 23 	mcall	80007970 <logFromISR+0x164>
800078e8:	2f ed       	sub	sp,-8
800078ea:	c0 a8       	rjmp	800078fe <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800078ec:	2f f7       	sub	r7,-1
800078ee:	1a d8       	st.w	--sp,r8
800078f0:	1a d6       	st.w	--sp,r6
800078f2:	4a 1b       	lddpc	r11,80007974 <logFromISR+0x168>
800078f4:	0c 9c       	mov	r12,r6
800078f6:	f0 1f 00 1f 	mcall	80007970 <logFromISR+0x164>
800078fa:	08 95       	mov	r5,r4
800078fc:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
800078fe:	0f 89       	ld.ub	r9,r7[0x0]
80007900:	30 08       	mov	r8,0
80007902:	f0 09 18 00 	cp.b	r9,r8
80007906:	c0 30       	breq	8000790c <logFromISR+0x100>
80007908:	0a 94       	mov	r4,r5
8000790a:	c9 8b       	rjmp	8000783a <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
8000790c:	fa c7 fe f4 	sub	r7,sp,-268
80007910:	1a d7       	st.w	--sp,r7
80007912:	49 ab       	lddpc	r11,80007978 <logFromISR+0x16c>
80007914:	0e 9c       	mov	r12,r7
80007916:	f0 1f 00 17 	mcall	80007970 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
8000791a:	5c 5c       	castu.b	r12
8000791c:	f8 c6 ff ff 	sub	r6,r12,-1
80007920:	0c 9c       	mov	r12,r6
80007922:	f0 1f 00 17 	mcall	8000797c <logFromISR+0x170>
80007926:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80007928:	0c 9a       	mov	r10,r6
8000792a:	0e 9b       	mov	r11,r7
8000792c:	f0 1f 00 15 	mcall	80007980 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80007930:	30 09       	mov	r9,0
80007932:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80007934:	fa ca fe f8 	sub	r10,sp,-264
80007938:	fa cb fe f4 	sub	r11,sp,-268
8000793c:	49 28       	lddpc	r8,80007984 <logFromISR+0x178>
8000793e:	70 0c       	ld.w	r12,r8[0x0]
80007940:	f0 1f 00 12 	mcall	80007988 <logFromISR+0x17c>
80007944:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80007946:	fe 3d fd f4 	sub	sp,-524
8000794a:	d8 32       	popm	r0-r7,pc
8000794c:	80 00       	ld.sh	r0,r0[0x0]
8000794e:	80 6a       	ld.sh	r10,r0[0xc]
80007950:	00 00       	add	r0,r0
80007952:	0d c5       	ld.ub	r5,r6[0x4]
80007954:	80 00       	ld.sh	r0,r0[0x0]
80007956:	e2 9c 80 00 	brvs	80077956 <_data_lma+0x68f76>
8000795a:	75 a6       	ld.w	r6,r10[0x68]
8000795c:	80 00       	ld.sh	r0,r0[0x0]
8000795e:	74 f4       	ld.w	r4,r10[0x3c]
80007960:	80 00       	ld.sh	r0,r0[0x0]
80007962:	74 f0       	ld.w	r0,r10[0x3c]
80007964:	80 00       	ld.sh	r0,r0[0x0]
80007966:	e4 08       	*unknown*
80007968:	80 00       	ld.sh	r0,r0[0x0]
8000796a:	76 80       	ld.w	r0,r11[0x20]
8000796c:	80 00       	ld.sh	r0,r0[0x0]
8000796e:	e4 18 80 00 	andh	r8,0x8000
80007972:	83 58       	st.w	r1[0x14],r8
80007974:	80 00       	ld.sh	r0,r0[0x0]
80007976:	e4 20 80 00 	sub	r0,294912
8000797a:	e4 28 80 00 	sub	r8,294912
8000797e:	65 84       	ld.w	r4,r2[0x60]
80007980:	80 00       	ld.sh	r0,r0[0x0]
80007982:	7f 22       	ld.w	r2,pc[0x48]
80007984:	00 00       	add	r0,r0
80007986:	54 2c       	stdsp	sp[0x108],r12
80007988:	80 00       	ld.sh	r0,r0[0x0]
8000798a:	68 88       	ld.w	r8,r4[0x20]

8000798c <log_init>:
		
	return str;
}

void log_init(void)
{
8000798c:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000798e:	30 2b       	mov	r11,2
80007990:	48 fc       	lddpc	r12,800079cc <log_init+0x40>
80007992:	f0 1f 00 10 	mcall	800079d0 <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80007996:	e0 6a 36 00 	mov	r10,13824
8000799a:	ea 1a 01 6e 	orh	r10,0x16e
8000799e:	48 eb       	lddpc	r11,800079d4 <log_init+0x48>
800079a0:	fe 7c 18 00 	mov	r12,-59392
800079a4:	f0 1f 00 0d 	mcall	800079d8 <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
800079a8:	30 4b       	mov	r11,4
800079aa:	33 2c       	mov	r12,50
800079ac:	f0 1f 00 0c 	mcall	800079dc <log_init+0x50>
800079b0:	48 c8       	lddpc	r8,800079e0 <log_init+0x54>
800079b2:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
800079b4:	30 09       	mov	r9,0
800079b6:	1a d9       	st.w	--sp,r9
800079b8:	1a d9       	st.w	--sp,r9
800079ba:	1a d9       	st.w	--sp,r9
800079bc:	30 28       	mov	r8,2
800079be:	36 4a       	mov	r10,100
800079c0:	48 9b       	lddpc	r11,800079e4 <log_init+0x58>
800079c2:	48 ac       	lddpc	r12,800079e8 <log_init+0x5c>
800079c4:	f0 1f 00 0a 	mcall	800079ec <log_init+0x60>
800079c8:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
800079ca:	d8 02       	popm	pc
800079cc:	80 00       	ld.sh	r0,r0[0x0]
800079ce:	e4 34 80 00 	sub	r4,360448
800079d2:	5a 64       	cp.w	r4,-26
800079d4:	80 00       	ld.sh	r0,r0[0x0]
800079d6:	e3 ec 80 00 	sthh.w	r0[r0],r1:b,r12:b
800079da:	60 e8       	ld.w	r8,r0[0x38]
800079dc:	80 00       	ld.sh	r0,r0[0x0]
800079de:	6a 30       	ld.w	r0,r5[0xc]
800079e0:	00 00       	add	r0,r0
800079e2:	54 2c       	stdsp	sp[0x108],r12
800079e4:	80 00       	ld.sh	r0,r0[0x0]
800079e6:	e4 30 80 00 	sub	r0,360448
800079ea:	79 f0       	ld.w	r0,r12[0x7c]
800079ec:	80 00       	ld.sh	r0,r0[0x0]
800079ee:	72 bc       	ld.w	r12,r9[0x2c]

800079f0 <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
800079f0:	eb cd 40 f8 	pushm	r3-r7,lr
800079f4:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800079f6:	48 c7       	lddpc	r7,80007a24 <task_log+0x34>
800079f8:	30 05       	mov	r5,0
800079fa:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
800079fc:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80007a00:	0a 99       	mov	r9,r5
80007a02:	08 9a       	mov	r10,r4
80007a04:	1a 9b       	mov	r11,sp
80007a06:	6e 0c       	ld.w	r12,r7[0x0]
80007a08:	f0 1f 00 08 	mcall	80007a28 <task_log+0x38>
80007a0c:	58 1c       	cp.w	r12,1
80007a0e:	cf 91       	brne	80007a00 <task_log+0x10>
		{
			if( NULL != str)
80007a10:	40 0b       	lddsp	r11,sp[0x0]
80007a12:	58 0b       	cp.w	r11,0
80007a14:	cf 60       	breq	80007a00 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80007a16:	06 9c       	mov	r12,r3
80007a18:	f0 1f 00 05 	mcall	80007a2c <task_log+0x3c>
				vPortFree(str);
80007a1c:	40 0c       	lddsp	r12,sp[0x0]
80007a1e:	f0 1f 00 05 	mcall	80007a30 <task_log+0x40>
80007a22:	ce fb       	rjmp	80007a00 <task_log+0x10>
80007a24:	00 00       	add	r0,r0
80007a26:	54 2c       	stdsp	sp[0x108],r12
80007a28:	80 00       	ld.sh	r0,r0[0x0]
80007a2a:	66 cc       	ld.w	r12,r3[0x30]
80007a2c:	80 00       	ld.sh	r0,r0[0x0]
80007a2e:	60 98       	ld.w	r8,r0[0x24]
80007a30:	80 00       	ld.sh	r0,r0[0x0]
80007a32:	65 5c       	ld.w	r12,r2[0x54]

80007a34 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
80007a34:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80007a36:	fe 78 10 00 	mov	r8,-61440
80007a3a:	30 19       	mov	r9,1
80007a3c:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80007a40:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80007a44:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80007a48:	d3 03       	ssrf	0x10
	local_start_pll0();
80007a4a:	f0 1f 00 0c 	mcall	80007a78 <main+0x44>
		
	INTC_init_interrupts();
80007a4e:	f0 1f 00 0c 	mcall	80007a7c <main+0x48>
		
	log_init();
80007a52:	f0 1f 00 0c 	mcall	80007a80 <main+0x4c>
	log("----start debug----");
80007a56:	48 cc       	lddpc	r12,80007a84 <main+0x50>
80007a58:	f0 1f 00 0c 	mcall	80007a88 <main+0x54>
	
	xg_flashc_init();
80007a5c:	f0 1f 00 0c 	mcall	80007a8c <main+0x58>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
80007a60:	f0 1f 00 0c 	mcall	80007a90 <main+0x5c>
		
	app_init();
80007a64:	f0 1f 00 0c 	mcall	80007a94 <main+0x60>
		
	xcmp_init();
80007a68:	f0 1f 00 0c 	mcall	80007a98 <main+0x64>

	local_start_timer();
80007a6c:	f0 1f 00 0c 	mcall	80007a9c <main+0x68>
	
	//xg_rtc_init();
		
	vTaskStartScheduler();
80007a70:	f0 1f 00 0c 	mcall	80007aa0 <main+0x6c>
	return 0;
	
}
80007a74:	d8 0a       	popm	pc,r12=0
80007a76:	00 00       	add	r0,r0
80007a78:	80 00       	ld.sh	r0,r0[0x0]
80007a7a:	50 dc       	stdsp	sp[0x34],r12
80007a7c:	80 00       	ld.sh	r0,r0[0x0]
80007a7e:	5b 68       	cp.w	r8,-10
80007a80:	80 00       	ld.sh	r0,r0[0x0]
80007a82:	79 8c       	ld.w	r12,r12[0x60]
80007a84:	80 00       	ld.sh	r0,r0[0x0]
80007a86:	e4 44 80 00 	cp.w	r4,294912
80007a8a:	76 80       	ld.w	r0,r11[0x20]
80007a8c:	80 00       	ld.sh	r0,r0[0x0]
80007a8e:	51 ac       	stdsp	sp[0x68],r12
80007a90:	80 00       	ld.sh	r0,r0[0x0]
80007a92:	50 3c       	stdsp	sp[0xc],r12
80007a94:	80 00       	ld.sh	r0,r0[0x0]
80007a96:	20 3c       	sub	r12,3
80007a98:	80 00       	ld.sh	r0,r0[0x0]
80007a9a:	3f 58       	mov	r8,-11
80007a9c:	80 00       	ld.sh	r0,r0[0x0]
80007a9e:	50 b0       	stdsp	sp[0x2c],r0
80007aa0:	80 00       	ld.sh	r0,r0[0x0]
80007aa2:	74 a4       	ld.w	r4,r10[0x28]

80007aa4 <free>:
80007aa4:	d4 01       	pushm	lr
80007aa6:	e0 68 0a 48 	mov	r8,2632
80007aaa:	18 9b       	mov	r11,r12
80007aac:	70 0c       	ld.w	r12,r8[0x0]
80007aae:	e0 a0 1e 73 	rcall	8000b794 <_free_r>
80007ab2:	d8 02       	popm	pc

80007ab4 <malloc>:
80007ab4:	d4 01       	pushm	lr
80007ab6:	e0 68 0a 48 	mov	r8,2632
80007aba:	18 9b       	mov	r11,r12
80007abc:	70 0c       	ld.w	r12,r8[0x0]
80007abe:	c0 3c       	rcall	80007ac4 <_malloc_r>
80007ac0:	d8 02       	popm	pc
80007ac2:	d7 03       	nop

80007ac4 <_malloc_r>:
80007ac4:	d4 31       	pushm	r0-r7,lr
80007ac6:	f6 c8 ff f5 	sub	r8,r11,-11
80007aca:	18 95       	mov	r5,r12
80007acc:	10 97       	mov	r7,r8
80007ace:	e0 17 ff f8 	andl	r7,0xfff8
80007ad2:	59 68       	cp.w	r8,22
80007ad4:	f9 b7 08 10 	movls	r7,16
80007ad8:	16 37       	cp.w	r7,r11
80007ada:	5f 38       	srlo	r8
80007adc:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80007ae0:	c0 50       	breq	80007aea <_malloc_r+0x26>
80007ae2:	30 c8       	mov	r8,12
80007ae4:	99 38       	st.w	r12[0xc],r8
80007ae6:	e0 8f 01 fa 	bral	80007eda <_malloc_r+0x416>
80007aea:	fe b0 f4 ef 	rcall	800064c8 <__malloc_lock>
80007aee:	e0 47 01 f7 	cp.w	r7,503
80007af2:	e0 8b 00 1d 	brhi	80007b2c <_malloc_r+0x68>
80007af6:	ee 03 16 03 	lsr	r3,r7,0x3
80007afa:	e0 68 05 48 	mov	r8,1352
80007afe:	f0 03 00 38 	add	r8,r8,r3<<0x3
80007b02:	70 36       	ld.w	r6,r8[0xc]
80007b04:	10 36       	cp.w	r6,r8
80007b06:	c0 61       	brne	80007b12 <_malloc_r+0x4e>
80007b08:	ec c8 ff f8 	sub	r8,r6,-8
80007b0c:	70 36       	ld.w	r6,r8[0xc]
80007b0e:	10 36       	cp.w	r6,r8
80007b10:	c0 c0       	breq	80007b28 <_malloc_r+0x64>
80007b12:	6c 18       	ld.w	r8,r6[0x4]
80007b14:	e0 18 ff fc 	andl	r8,0xfffc
80007b18:	6c 3a       	ld.w	r10,r6[0xc]
80007b1a:	ec 08 00 09 	add	r9,r6,r8
80007b1e:	0a 9c       	mov	r12,r5
80007b20:	6c 28       	ld.w	r8,r6[0x8]
80007b22:	95 28       	st.w	r10[0x8],r8
80007b24:	91 3a       	st.w	r8[0xc],r10
80007b26:	c4 78       	rjmp	80007bb4 <_malloc_r+0xf0>
80007b28:	2f e3       	sub	r3,-2
80007b2a:	c4 d8       	rjmp	80007bc4 <_malloc_r+0x100>
80007b2c:	ee 03 16 09 	lsr	r3,r7,0x9
80007b30:	c0 41       	brne	80007b38 <_malloc_r+0x74>
80007b32:	ee 03 16 03 	lsr	r3,r7,0x3
80007b36:	c2 68       	rjmp	80007b82 <_malloc_r+0xbe>
80007b38:	58 43       	cp.w	r3,4
80007b3a:	e0 8b 00 06 	brhi	80007b46 <_malloc_r+0x82>
80007b3e:	ee 03 16 06 	lsr	r3,r7,0x6
80007b42:	2c 83       	sub	r3,-56
80007b44:	c1 f8       	rjmp	80007b82 <_malloc_r+0xbe>
80007b46:	59 43       	cp.w	r3,20
80007b48:	e0 8b 00 04 	brhi	80007b50 <_malloc_r+0x8c>
80007b4c:	2a 53       	sub	r3,-91
80007b4e:	c1 a8       	rjmp	80007b82 <_malloc_r+0xbe>
80007b50:	e0 43 00 54 	cp.w	r3,84
80007b54:	e0 8b 00 06 	brhi	80007b60 <_malloc_r+0x9c>
80007b58:	ee 03 16 0c 	lsr	r3,r7,0xc
80007b5c:	29 23       	sub	r3,-110
80007b5e:	c1 28       	rjmp	80007b82 <_malloc_r+0xbe>
80007b60:	e0 43 01 54 	cp.w	r3,340
80007b64:	e0 8b 00 06 	brhi	80007b70 <_malloc_r+0xac>
80007b68:	ee 03 16 0f 	lsr	r3,r7,0xf
80007b6c:	28 93       	sub	r3,-119
80007b6e:	c0 a8       	rjmp	80007b82 <_malloc_r+0xbe>
80007b70:	e0 43 05 54 	cp.w	r3,1364
80007b74:	e0 88 00 04 	brls	80007b7c <_malloc_r+0xb8>
80007b78:	37 e3       	mov	r3,126
80007b7a:	c0 48       	rjmp	80007b82 <_malloc_r+0xbe>
80007b7c:	ee 03 16 12 	lsr	r3,r7,0x12
80007b80:	28 43       	sub	r3,-124
80007b82:	e0 6a 05 48 	mov	r10,1352
80007b86:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80007b8a:	74 36       	ld.w	r6,r10[0xc]
80007b8c:	c1 98       	rjmp	80007bbe <_malloc_r+0xfa>
80007b8e:	6c 19       	ld.w	r9,r6[0x4]
80007b90:	e0 19 ff fc 	andl	r9,0xfffc
80007b94:	f2 07 01 0b 	sub	r11,r9,r7
80007b98:	58 fb       	cp.w	r11,15
80007b9a:	e0 8a 00 04 	brle	80007ba2 <_malloc_r+0xde>
80007b9e:	20 13       	sub	r3,1
80007ba0:	c1 18       	rjmp	80007bc2 <_malloc_r+0xfe>
80007ba2:	6c 38       	ld.w	r8,r6[0xc]
80007ba4:	58 0b       	cp.w	r11,0
80007ba6:	c0 b5       	brlt	80007bbc <_malloc_r+0xf8>
80007ba8:	6c 2a       	ld.w	r10,r6[0x8]
80007baa:	ec 09 00 09 	add	r9,r6,r9
80007bae:	0a 9c       	mov	r12,r5
80007bb0:	91 2a       	st.w	r8[0x8],r10
80007bb2:	95 38       	st.w	r10[0xc],r8
80007bb4:	72 18       	ld.w	r8,r9[0x4]
80007bb6:	a1 a8       	sbr	r8,0x0
80007bb8:	93 18       	st.w	r9[0x4],r8
80007bba:	cb c8       	rjmp	80007d32 <_malloc_r+0x26e>
80007bbc:	10 96       	mov	r6,r8
80007bbe:	14 36       	cp.w	r6,r10
80007bc0:	ce 71       	brne	80007b8e <_malloc_r+0xca>
80007bc2:	2f f3       	sub	r3,-1
80007bc4:	e0 6a 05 48 	mov	r10,1352
80007bc8:	f4 cc ff f8 	sub	r12,r10,-8
80007bcc:	78 26       	ld.w	r6,r12[0x8]
80007bce:	18 36       	cp.w	r6,r12
80007bd0:	c6 c0       	breq	80007ca8 <_malloc_r+0x1e4>
80007bd2:	6c 19       	ld.w	r9,r6[0x4]
80007bd4:	e0 19 ff fc 	andl	r9,0xfffc
80007bd8:	f2 07 01 08 	sub	r8,r9,r7
80007bdc:	58 f8       	cp.w	r8,15
80007bde:	e0 89 00 8f 	brgt	80007cfc <_malloc_r+0x238>
80007be2:	99 3c       	st.w	r12[0xc],r12
80007be4:	99 2c       	st.w	r12[0x8],r12
80007be6:	58 08       	cp.w	r8,0
80007be8:	c0 55       	brlt	80007bf2 <_malloc_r+0x12e>
80007bea:	ec 09 00 09 	add	r9,r6,r9
80007bee:	0a 9c       	mov	r12,r5
80007bf0:	ce 2b       	rjmp	80007bb4 <_malloc_r+0xf0>
80007bf2:	e0 49 01 ff 	cp.w	r9,511
80007bf6:	e0 8b 00 13 	brhi	80007c1c <_malloc_r+0x158>
80007bfa:	a3 99       	lsr	r9,0x3
80007bfc:	f4 09 00 38 	add	r8,r10,r9<<0x3
80007c00:	70 2b       	ld.w	r11,r8[0x8]
80007c02:	8d 38       	st.w	r6[0xc],r8
80007c04:	8d 2b       	st.w	r6[0x8],r11
80007c06:	97 36       	st.w	r11[0xc],r6
80007c08:	91 26       	st.w	r8[0x8],r6
80007c0a:	a3 49       	asr	r9,0x2
80007c0c:	74 18       	ld.w	r8,r10[0x4]
80007c0e:	30 1b       	mov	r11,1
80007c10:	f6 09 09 49 	lsl	r9,r11,r9
80007c14:	f1 e9 10 09 	or	r9,r8,r9
80007c18:	95 19       	st.w	r10[0x4],r9
80007c1a:	c4 78       	rjmp	80007ca8 <_malloc_r+0x1e4>
80007c1c:	f2 0a 16 09 	lsr	r10,r9,0x9
80007c20:	58 4a       	cp.w	r10,4
80007c22:	e0 8b 00 07 	brhi	80007c30 <_malloc_r+0x16c>
80007c26:	f2 0a 16 06 	lsr	r10,r9,0x6
80007c2a:	2c 8a       	sub	r10,-56
80007c2c:	c2 08       	rjmp	80007c6c <_malloc_r+0x1a8>
80007c2e:	d7 03       	nop
80007c30:	59 4a       	cp.w	r10,20
80007c32:	e0 8b 00 04 	brhi	80007c3a <_malloc_r+0x176>
80007c36:	2a 5a       	sub	r10,-91
80007c38:	c1 a8       	rjmp	80007c6c <_malloc_r+0x1a8>
80007c3a:	e0 4a 00 54 	cp.w	r10,84
80007c3e:	e0 8b 00 06 	brhi	80007c4a <_malloc_r+0x186>
80007c42:	f2 0a 16 0c 	lsr	r10,r9,0xc
80007c46:	29 2a       	sub	r10,-110
80007c48:	c1 28       	rjmp	80007c6c <_malloc_r+0x1a8>
80007c4a:	e0 4a 01 54 	cp.w	r10,340
80007c4e:	e0 8b 00 06 	brhi	80007c5a <_malloc_r+0x196>
80007c52:	f2 0a 16 0f 	lsr	r10,r9,0xf
80007c56:	28 9a       	sub	r10,-119
80007c58:	c0 a8       	rjmp	80007c6c <_malloc_r+0x1a8>
80007c5a:	e0 4a 05 54 	cp.w	r10,1364
80007c5e:	e0 88 00 04 	brls	80007c66 <_malloc_r+0x1a2>
80007c62:	37 ea       	mov	r10,126
80007c64:	c0 48       	rjmp	80007c6c <_malloc_r+0x1a8>
80007c66:	f2 0a 16 12 	lsr	r10,r9,0x12
80007c6a:	28 4a       	sub	r10,-124
80007c6c:	e0 6b 05 48 	mov	r11,1352
80007c70:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80007c74:	68 28       	ld.w	r8,r4[0x8]
80007c76:	08 38       	cp.w	r8,r4
80007c78:	c0 e1       	brne	80007c94 <_malloc_r+0x1d0>
80007c7a:	76 19       	ld.w	r9,r11[0x4]
80007c7c:	a3 4a       	asr	r10,0x2
80007c7e:	30 1e       	mov	lr,1
80007c80:	fc 0a 09 4a 	lsl	r10,lr,r10
80007c84:	f3 ea 10 0a 	or	r10,r9,r10
80007c88:	10 99       	mov	r9,r8
80007c8a:	97 1a       	st.w	r11[0x4],r10
80007c8c:	c0 a8       	rjmp	80007ca0 <_malloc_r+0x1dc>
80007c8e:	70 28       	ld.w	r8,r8[0x8]
80007c90:	08 38       	cp.w	r8,r4
80007c92:	c0 60       	breq	80007c9e <_malloc_r+0x1da>
80007c94:	70 1a       	ld.w	r10,r8[0x4]
80007c96:	e0 1a ff fc 	andl	r10,0xfffc
80007c9a:	14 39       	cp.w	r9,r10
80007c9c:	cf 93       	brcs	80007c8e <_malloc_r+0x1ca>
80007c9e:	70 39       	ld.w	r9,r8[0xc]
80007ca0:	8d 39       	st.w	r6[0xc],r9
80007ca2:	8d 28       	st.w	r6[0x8],r8
80007ca4:	91 36       	st.w	r8[0xc],r6
80007ca6:	93 26       	st.w	r9[0x8],r6
80007ca8:	e6 08 14 02 	asr	r8,r3,0x2
80007cac:	30 1b       	mov	r11,1
80007cae:	e0 64 05 48 	mov	r4,1352
80007cb2:	f6 08 09 4b 	lsl	r11,r11,r8
80007cb6:	68 18       	ld.w	r8,r4[0x4]
80007cb8:	10 3b       	cp.w	r11,r8
80007cba:	e0 8b 00 6b 	brhi	80007d90 <_malloc_r+0x2cc>
80007cbe:	f7 e8 00 09 	and	r9,r11,r8
80007cc2:	c0 b1       	brne	80007cd8 <_malloc_r+0x214>
80007cc4:	e0 13 ff fc 	andl	r3,0xfffc
80007cc8:	a1 7b       	lsl	r11,0x1
80007cca:	2f c3       	sub	r3,-4
80007ccc:	c0 38       	rjmp	80007cd2 <_malloc_r+0x20e>
80007cce:	2f c3       	sub	r3,-4
80007cd0:	a1 7b       	lsl	r11,0x1
80007cd2:	f7 e8 00 09 	and	r9,r11,r8
80007cd6:	cf c0       	breq	80007cce <_malloc_r+0x20a>
80007cd8:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80007cdc:	06 92       	mov	r2,r3
80007cde:	1c 91       	mov	r1,lr
80007ce0:	62 36       	ld.w	r6,r1[0xc]
80007ce2:	c2 e8       	rjmp	80007d3e <_malloc_r+0x27a>
80007ce4:	6c 1a       	ld.w	r10,r6[0x4]
80007ce6:	e0 1a ff fc 	andl	r10,0xfffc
80007cea:	f4 07 01 08 	sub	r8,r10,r7
80007cee:	58 f8       	cp.w	r8,15
80007cf0:	e0 8a 00 15 	brle	80007d1a <_malloc_r+0x256>
80007cf4:	6c 3a       	ld.w	r10,r6[0xc]
80007cf6:	6c 29       	ld.w	r9,r6[0x8]
80007cf8:	95 29       	st.w	r10[0x8],r9
80007cfa:	93 3a       	st.w	r9[0xc],r10
80007cfc:	0e 99       	mov	r9,r7
80007cfe:	ec 07 00 07 	add	r7,r6,r7
80007d02:	a1 a9       	sbr	r9,0x0
80007d04:	99 37       	st.w	r12[0xc],r7
80007d06:	99 27       	st.w	r12[0x8],r7
80007d08:	8d 19       	st.w	r6[0x4],r9
80007d0a:	ee 08 09 08 	st.w	r7[r8],r8
80007d0e:	8f 2c       	st.w	r7[0x8],r12
80007d10:	8f 3c       	st.w	r7[0xc],r12
80007d12:	a1 a8       	sbr	r8,0x0
80007d14:	0a 9c       	mov	r12,r5
80007d16:	8f 18       	st.w	r7[0x4],r8
80007d18:	c0 d8       	rjmp	80007d32 <_malloc_r+0x26e>
80007d1a:	6c 39       	ld.w	r9,r6[0xc]
80007d1c:	58 08       	cp.w	r8,0
80007d1e:	c0 f5       	brlt	80007d3c <_malloc_r+0x278>
80007d20:	ec 0a 00 0a 	add	r10,r6,r10
80007d24:	74 18       	ld.w	r8,r10[0x4]
80007d26:	a1 a8       	sbr	r8,0x0
80007d28:	0a 9c       	mov	r12,r5
80007d2a:	95 18       	st.w	r10[0x4],r8
80007d2c:	6c 28       	ld.w	r8,r6[0x8]
80007d2e:	93 28       	st.w	r9[0x8],r8
80007d30:	91 39       	st.w	r8[0xc],r9
80007d32:	fe b0 f3 d1 	rcall	800064d4 <__malloc_unlock>
80007d36:	ec cc ff f8 	sub	r12,r6,-8
80007d3a:	d8 32       	popm	r0-r7,pc
80007d3c:	12 96       	mov	r6,r9
80007d3e:	02 36       	cp.w	r6,r1
80007d40:	cd 21       	brne	80007ce4 <_malloc_r+0x220>
80007d42:	2f f2       	sub	r2,-1
80007d44:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80007d48:	c0 30       	breq	80007d4e <_malloc_r+0x28a>
80007d4a:	2f 81       	sub	r1,-8
80007d4c:	cc ab       	rjmp	80007ce0 <_malloc_r+0x21c>
80007d4e:	1c 98       	mov	r8,lr
80007d50:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80007d54:	c0 81       	brne	80007d64 <_malloc_r+0x2a0>
80007d56:	68 19       	ld.w	r9,r4[0x4]
80007d58:	f6 08 11 ff 	rsub	r8,r11,-1
80007d5c:	f3 e8 00 08 	and	r8,r9,r8
80007d60:	89 18       	st.w	r4[0x4],r8
80007d62:	c0 78       	rjmp	80007d70 <_malloc_r+0x2ac>
80007d64:	f0 c9 00 08 	sub	r9,r8,8
80007d68:	20 13       	sub	r3,1
80007d6a:	70 08       	ld.w	r8,r8[0x0]
80007d6c:	12 38       	cp.w	r8,r9
80007d6e:	cf 10       	breq	80007d50 <_malloc_r+0x28c>
80007d70:	a1 7b       	lsl	r11,0x1
80007d72:	68 18       	ld.w	r8,r4[0x4]
80007d74:	10 3b       	cp.w	r11,r8
80007d76:	e0 8b 00 0d 	brhi	80007d90 <_malloc_r+0x2cc>
80007d7a:	58 0b       	cp.w	r11,0
80007d7c:	c0 a0       	breq	80007d90 <_malloc_r+0x2cc>
80007d7e:	04 93       	mov	r3,r2
80007d80:	c0 38       	rjmp	80007d86 <_malloc_r+0x2c2>
80007d82:	2f c3       	sub	r3,-4
80007d84:	a1 7b       	lsl	r11,0x1
80007d86:	f7 e8 00 09 	and	r9,r11,r8
80007d8a:	ca 71       	brne	80007cd8 <_malloc_r+0x214>
80007d8c:	cf bb       	rjmp	80007d82 <_malloc_r+0x2be>
80007d8e:	d7 03       	nop
80007d90:	68 23       	ld.w	r3,r4[0x8]
80007d92:	66 12       	ld.w	r2,r3[0x4]
80007d94:	e0 12 ff fc 	andl	r2,0xfffc
80007d98:	0e 32       	cp.w	r2,r7
80007d9a:	5f 39       	srlo	r9
80007d9c:	e4 07 01 08 	sub	r8,r2,r7
80007da0:	58 f8       	cp.w	r8,15
80007da2:	5f aa       	srle	r10
80007da4:	f5 e9 10 09 	or	r9,r10,r9
80007da8:	e0 80 00 9a 	breq	80007edc <_malloc_r+0x418>
80007dac:	e0 68 0d d0 	mov	r8,3536
80007db0:	70 01       	ld.w	r1,r8[0x0]
80007db2:	e0 68 09 54 	mov	r8,2388
80007db6:	2f 01       	sub	r1,-16
80007db8:	70 08       	ld.w	r8,r8[0x0]
80007dba:	0e 01       	add	r1,r7
80007dbc:	5b f8       	cp.w	r8,-1
80007dbe:	c0 40       	breq	80007dc6 <_malloc_r+0x302>
80007dc0:	28 11       	sub	r1,-127
80007dc2:	e0 11 ff 80 	andl	r1,0xff80
80007dc6:	02 9b       	mov	r11,r1
80007dc8:	0a 9c       	mov	r12,r5
80007dca:	e0 a0 02 b7 	rcall	80008338 <_sbrk_r>
80007dce:	18 96       	mov	r6,r12
80007dd0:	5b fc       	cp.w	r12,-1
80007dd2:	c7 50       	breq	80007ebc <_malloc_r+0x3f8>
80007dd4:	e6 02 00 08 	add	r8,r3,r2
80007dd8:	10 3c       	cp.w	r12,r8
80007dda:	c0 32       	brcc	80007de0 <_malloc_r+0x31c>
80007ddc:	08 33       	cp.w	r3,r4
80007dde:	c6 f1       	brne	80007ebc <_malloc_r+0x3f8>
80007de0:	e0 6a 0d d4 	mov	r10,3540
80007de4:	74 09       	ld.w	r9,r10[0x0]
80007de6:	e2 09 00 09 	add	r9,r1,r9
80007dea:	95 09       	st.w	r10[0x0],r9
80007dec:	10 36       	cp.w	r6,r8
80007dee:	c0 a1       	brne	80007e02 <_malloc_r+0x33e>
80007df0:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80007df4:	c0 71       	brne	80007e02 <_malloc_r+0x33e>
80007df6:	e2 02 00 02 	add	r2,r1,r2
80007dfa:	68 28       	ld.w	r8,r4[0x8]
80007dfc:	a1 a2       	sbr	r2,0x0
80007dfe:	91 12       	st.w	r8[0x4],r2
80007e00:	c4 f8       	rjmp	80007e9e <_malloc_r+0x3da>
80007e02:	e0 6a 09 54 	mov	r10,2388
80007e06:	74 0b       	ld.w	r11,r10[0x0]
80007e08:	5b fb       	cp.w	r11,-1
80007e0a:	c0 31       	brne	80007e10 <_malloc_r+0x34c>
80007e0c:	95 06       	st.w	r10[0x0],r6
80007e0e:	c0 78       	rjmp	80007e1c <_malloc_r+0x358>
80007e10:	ec 09 00 09 	add	r9,r6,r9
80007e14:	e0 6a 0d d4 	mov	r10,3540
80007e18:	10 19       	sub	r9,r8
80007e1a:	95 09       	st.w	r10[0x0],r9
80007e1c:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80007e20:	f0 09 11 08 	rsub	r9,r8,8
80007e24:	58 08       	cp.w	r8,0
80007e26:	f2 08 17 10 	movne	r8,r9
80007e2a:	ed d8 e1 06 	addne	r6,r6,r8
80007e2e:	28 08       	sub	r8,-128
80007e30:	ec 01 00 01 	add	r1,r6,r1
80007e34:	0a 9c       	mov	r12,r5
80007e36:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80007e3a:	f0 01 01 01 	sub	r1,r8,r1
80007e3e:	02 9b       	mov	r11,r1
80007e40:	e0 a0 02 7c 	rcall	80008338 <_sbrk_r>
80007e44:	e0 68 0d d4 	mov	r8,3540
80007e48:	5b fc       	cp.w	r12,-1
80007e4a:	ec 0c 17 00 	moveq	r12,r6
80007e4e:	f9 b1 00 00 	moveq	r1,0
80007e52:	70 09       	ld.w	r9,r8[0x0]
80007e54:	0c 1c       	sub	r12,r6
80007e56:	89 26       	st.w	r4[0x8],r6
80007e58:	02 0c       	add	r12,r1
80007e5a:	12 01       	add	r1,r9
80007e5c:	a1 ac       	sbr	r12,0x0
80007e5e:	91 01       	st.w	r8[0x0],r1
80007e60:	8d 1c       	st.w	r6[0x4],r12
80007e62:	08 33       	cp.w	r3,r4
80007e64:	c1 d0       	breq	80007e9e <_malloc_r+0x3da>
80007e66:	58 f2       	cp.w	r2,15
80007e68:	e0 8b 00 05 	brhi	80007e72 <_malloc_r+0x3ae>
80007e6c:	30 18       	mov	r8,1
80007e6e:	8d 18       	st.w	r6[0x4],r8
80007e70:	c2 68       	rjmp	80007ebc <_malloc_r+0x3f8>
80007e72:	30 59       	mov	r9,5
80007e74:	20 c2       	sub	r2,12
80007e76:	e0 12 ff f8 	andl	r2,0xfff8
80007e7a:	e6 02 00 08 	add	r8,r3,r2
80007e7e:	91 29       	st.w	r8[0x8],r9
80007e80:	91 19       	st.w	r8[0x4],r9
80007e82:	66 18       	ld.w	r8,r3[0x4]
80007e84:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007e88:	e5 e8 10 08 	or	r8,r2,r8
80007e8c:	87 18       	st.w	r3[0x4],r8
80007e8e:	58 f2       	cp.w	r2,15
80007e90:	e0 88 00 07 	brls	80007e9e <_malloc_r+0x3da>
80007e94:	e6 cb ff f8 	sub	r11,r3,-8
80007e98:	0a 9c       	mov	r12,r5
80007e9a:	e0 a0 1c 7d 	rcall	8000b794 <_free_r>
80007e9e:	e0 69 0d cc 	mov	r9,3532
80007ea2:	72 0a       	ld.w	r10,r9[0x0]
80007ea4:	e0 68 0d d4 	mov	r8,3540
80007ea8:	70 08       	ld.w	r8,r8[0x0]
80007eaa:	14 38       	cp.w	r8,r10
80007eac:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007eb0:	e0 69 0d c8 	mov	r9,3528
80007eb4:	72 0a       	ld.w	r10,r9[0x0]
80007eb6:	14 38       	cp.w	r8,r10
80007eb8:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007ebc:	68 28       	ld.w	r8,r4[0x8]
80007ebe:	70 18       	ld.w	r8,r8[0x4]
80007ec0:	e0 18 ff fc 	andl	r8,0xfffc
80007ec4:	0e 38       	cp.w	r8,r7
80007ec6:	5f 39       	srlo	r9
80007ec8:	0e 18       	sub	r8,r7
80007eca:	58 f8       	cp.w	r8,15
80007ecc:	5f aa       	srle	r10
80007ece:	f5 e9 10 09 	or	r9,r10,r9
80007ed2:	c0 50       	breq	80007edc <_malloc_r+0x418>
80007ed4:	0a 9c       	mov	r12,r5
80007ed6:	fe b0 f2 ff 	rcall	800064d4 <__malloc_unlock>
80007eda:	d8 3a       	popm	r0-r7,pc,r12=0
80007edc:	68 26       	ld.w	r6,r4[0x8]
80007ede:	a1 a8       	sbr	r8,0x0
80007ee0:	0e 99       	mov	r9,r7
80007ee2:	a1 a9       	sbr	r9,0x0
80007ee4:	8d 19       	st.w	r6[0x4],r9
80007ee6:	ec 07 00 07 	add	r7,r6,r7
80007eea:	0a 9c       	mov	r12,r5
80007eec:	89 27       	st.w	r4[0x8],r7
80007eee:	8f 18       	st.w	r7[0x4],r8
80007ef0:	fe b0 f2 f2 	rcall	800064d4 <__malloc_unlock>
80007ef4:	ec cc ff f8 	sub	r12,r6,-8
80007ef8:	d8 32       	popm	r0-r7,pc
80007efa:	d7 03       	nop

80007efc <memcmp>:
80007efc:	d4 01       	pushm	lr
80007efe:	30 08       	mov	r8,0
80007f00:	c0 d8       	rjmp	80007f1a <memcmp+0x1e>
80007f02:	f8 08 07 0e 	ld.ub	lr,r12[r8]
80007f06:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007f0a:	20 1a       	sub	r10,1
80007f0c:	2f f8       	sub	r8,-1
80007f0e:	f2 0e 18 00 	cp.b	lr,r9
80007f12:	c0 40       	breq	80007f1a <memcmp+0x1e>
80007f14:	fc 09 01 0c 	sub	r12,lr,r9
80007f18:	d8 02       	popm	pc
80007f1a:	58 0a       	cp.w	r10,0
80007f1c:	cf 31       	brne	80007f02 <memcmp+0x6>
80007f1e:	14 9c       	mov	r12,r10
80007f20:	d8 02       	popm	pc

80007f22 <memcpy>:
80007f22:	58 8a       	cp.w	r10,8
80007f24:	c2 f5       	brlt	80007f82 <memcpy+0x60>
80007f26:	f9 eb 10 09 	or	r9,r12,r11
80007f2a:	e2 19 00 03 	andl	r9,0x3,COH
80007f2e:	e0 81 00 97 	brne	8000805c <memcpy+0x13a>
80007f32:	e0 4a 00 20 	cp.w	r10,32
80007f36:	c3 b4       	brge	80007fac <memcpy+0x8a>
80007f38:	f4 08 14 02 	asr	r8,r10,0x2
80007f3c:	f0 09 11 08 	rsub	r9,r8,8
80007f40:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80007f44:	76 69       	ld.w	r9,r11[0x18]
80007f46:	99 69       	st.w	r12[0x18],r9
80007f48:	76 59       	ld.w	r9,r11[0x14]
80007f4a:	99 59       	st.w	r12[0x14],r9
80007f4c:	76 49       	ld.w	r9,r11[0x10]
80007f4e:	99 49       	st.w	r12[0x10],r9
80007f50:	76 39       	ld.w	r9,r11[0xc]
80007f52:	99 39       	st.w	r12[0xc],r9
80007f54:	76 29       	ld.w	r9,r11[0x8]
80007f56:	99 29       	st.w	r12[0x8],r9
80007f58:	76 19       	ld.w	r9,r11[0x4]
80007f5a:	99 19       	st.w	r12[0x4],r9
80007f5c:	76 09       	ld.w	r9,r11[0x0]
80007f5e:	99 09       	st.w	r12[0x0],r9
80007f60:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80007f64:	f8 08 00 28 	add	r8,r12,r8<<0x2
80007f68:	e0 1a 00 03 	andl	r10,0x3
80007f6c:	f4 0a 11 04 	rsub	r10,r10,4
80007f70:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007f74:	17 a9       	ld.ub	r9,r11[0x2]
80007f76:	b0 a9       	st.b	r8[0x2],r9
80007f78:	17 99       	ld.ub	r9,r11[0x1]
80007f7a:	b0 99       	st.b	r8[0x1],r9
80007f7c:	17 89       	ld.ub	r9,r11[0x0]
80007f7e:	b0 89       	st.b	r8[0x0],r9
80007f80:	5e fc       	retal	r12
80007f82:	f4 0a 11 09 	rsub	r10,r10,9
80007f86:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007f8a:	17 f9       	ld.ub	r9,r11[0x7]
80007f8c:	b8 f9       	st.b	r12[0x7],r9
80007f8e:	17 e9       	ld.ub	r9,r11[0x6]
80007f90:	b8 e9       	st.b	r12[0x6],r9
80007f92:	17 d9       	ld.ub	r9,r11[0x5]
80007f94:	b8 d9       	st.b	r12[0x5],r9
80007f96:	17 c9       	ld.ub	r9,r11[0x4]
80007f98:	b8 c9       	st.b	r12[0x4],r9
80007f9a:	17 b9       	ld.ub	r9,r11[0x3]
80007f9c:	b8 b9       	st.b	r12[0x3],r9
80007f9e:	17 a9       	ld.ub	r9,r11[0x2]
80007fa0:	b8 a9       	st.b	r12[0x2],r9
80007fa2:	17 99       	ld.ub	r9,r11[0x1]
80007fa4:	b8 99       	st.b	r12[0x1],r9
80007fa6:	17 89       	ld.ub	r9,r11[0x0]
80007fa8:	b8 89       	st.b	r12[0x0],r9
80007faa:	5e fc       	retal	r12
80007fac:	eb cd 40 c0 	pushm	r6-r7,lr
80007fb0:	18 99       	mov	r9,r12
80007fb2:	22 0a       	sub	r10,32
80007fb4:	b7 07       	ld.d	r6,r11++
80007fb6:	b3 26       	st.d	r9++,r6
80007fb8:	b7 07       	ld.d	r6,r11++
80007fba:	b3 26       	st.d	r9++,r6
80007fbc:	b7 07       	ld.d	r6,r11++
80007fbe:	b3 26       	st.d	r9++,r6
80007fc0:	b7 07       	ld.d	r6,r11++
80007fc2:	b3 26       	st.d	r9++,r6
80007fc4:	22 0a       	sub	r10,32
80007fc6:	cf 74       	brge	80007fb4 <memcpy+0x92>
80007fc8:	2f 0a       	sub	r10,-16
80007fca:	c0 65       	brlt	80007fd6 <memcpy+0xb4>
80007fcc:	b7 07       	ld.d	r6,r11++
80007fce:	b3 26       	st.d	r9++,r6
80007fd0:	b7 07       	ld.d	r6,r11++
80007fd2:	b3 26       	st.d	r9++,r6
80007fd4:	21 0a       	sub	r10,16
80007fd6:	5c 3a       	neg	r10
80007fd8:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80007fdc:	d7 03       	nop
80007fde:	d7 03       	nop
80007fe0:	f7 36 00 0e 	ld.ub	r6,r11[14]
80007fe4:	f3 66 00 0e 	st.b	r9[14],r6
80007fe8:	f7 36 00 0d 	ld.ub	r6,r11[13]
80007fec:	f3 66 00 0d 	st.b	r9[13],r6
80007ff0:	f7 36 00 0c 	ld.ub	r6,r11[12]
80007ff4:	f3 66 00 0c 	st.b	r9[12],r6
80007ff8:	f7 36 00 0b 	ld.ub	r6,r11[11]
80007ffc:	f3 66 00 0b 	st.b	r9[11],r6
80008000:	f7 36 00 0a 	ld.ub	r6,r11[10]
80008004:	f3 66 00 0a 	st.b	r9[10],r6
80008008:	f7 36 00 09 	ld.ub	r6,r11[9]
8000800c:	f3 66 00 09 	st.b	r9[9],r6
80008010:	f7 36 00 08 	ld.ub	r6,r11[8]
80008014:	f3 66 00 08 	st.b	r9[8],r6
80008018:	f7 36 00 07 	ld.ub	r6,r11[7]
8000801c:	f3 66 00 07 	st.b	r9[7],r6
80008020:	f7 36 00 06 	ld.ub	r6,r11[6]
80008024:	f3 66 00 06 	st.b	r9[6],r6
80008028:	f7 36 00 05 	ld.ub	r6,r11[5]
8000802c:	f3 66 00 05 	st.b	r9[5],r6
80008030:	f7 36 00 04 	ld.ub	r6,r11[4]
80008034:	f3 66 00 04 	st.b	r9[4],r6
80008038:	f7 36 00 03 	ld.ub	r6,r11[3]
8000803c:	f3 66 00 03 	st.b	r9[3],r6
80008040:	f7 36 00 02 	ld.ub	r6,r11[2]
80008044:	f3 66 00 02 	st.b	r9[2],r6
80008048:	f7 36 00 01 	ld.ub	r6,r11[1]
8000804c:	f3 66 00 01 	st.b	r9[1],r6
80008050:	f7 36 00 00 	ld.ub	r6,r11[0]
80008054:	f3 66 00 00 	st.b	r9[0],r6
80008058:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000805c:	20 1a       	sub	r10,1
8000805e:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80008062:	f8 0a 0b 09 	st.b	r12[r10],r9
80008066:	cf b1       	brne	8000805c <memcpy+0x13a>
80008068:	5e fc       	retal	r12

8000806a <memset>:
8000806a:	18 98       	mov	r8,r12
8000806c:	c0 38       	rjmp	80008072 <memset+0x8>
8000806e:	10 cb       	st.b	r8++,r11
80008070:	20 1a       	sub	r10,1
80008072:	58 0a       	cp.w	r10,0
80008074:	cf d1       	brne	8000806e <memset+0x4>
80008076:	5e fc       	retal	r12

80008078 <_realloc_r>:
80008078:	d4 31       	pushm	r0-r7,lr
8000807a:	20 1d       	sub	sp,4
8000807c:	16 94       	mov	r4,r11
8000807e:	18 92       	mov	r2,r12
80008080:	14 9b       	mov	r11,r10
80008082:	58 04       	cp.w	r4,0
80008084:	c0 51       	brne	8000808e <_realloc_r+0x16>
80008086:	fe b0 fd 1f 	rcall	80007ac4 <_malloc_r>
8000808a:	18 95       	mov	r5,r12
8000808c:	c5 39       	rjmp	80008332 <_realloc_r+0x2ba>
8000808e:	50 0a       	stdsp	sp[0x0],r10
80008090:	fe b0 f2 1c 	rcall	800064c8 <__malloc_lock>
80008094:	40 0b       	lddsp	r11,sp[0x0]
80008096:	f6 c8 ff f5 	sub	r8,r11,-11
8000809a:	e8 c1 00 08 	sub	r1,r4,8
8000809e:	10 96       	mov	r6,r8
800080a0:	62 1c       	ld.w	r12,r1[0x4]
800080a2:	e0 16 ff f8 	andl	r6,0xfff8
800080a6:	59 68       	cp.w	r8,22
800080a8:	f9 b6 08 10 	movls	r6,16
800080ac:	16 36       	cp.w	r6,r11
800080ae:	5f 38       	srlo	r8
800080b0:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
800080b4:	c0 50       	breq	800080be <_realloc_r+0x46>
800080b6:	30 c8       	mov	r8,12
800080b8:	30 05       	mov	r5,0
800080ba:	85 38       	st.w	r2[0xc],r8
800080bc:	c3 b9       	rjmp	80008332 <_realloc_r+0x2ba>
800080be:	18 90       	mov	r0,r12
800080c0:	e0 10 ff fc 	andl	r0,0xfffc
800080c4:	0c 30       	cp.w	r0,r6
800080c6:	e0 84 01 0b 	brge	800082dc <_realloc_r+0x264>
800080ca:	e0 68 05 48 	mov	r8,1352
800080ce:	e2 00 00 09 	add	r9,r1,r0
800080d2:	70 25       	ld.w	r5,r8[0x8]
800080d4:	0a 39       	cp.w	r9,r5
800080d6:	c0 90       	breq	800080e8 <_realloc_r+0x70>
800080d8:	72 1a       	ld.w	r10,r9[0x4]
800080da:	a1 ca       	cbr	r10,0x0
800080dc:	f2 0a 00 0a 	add	r10,r9,r10
800080e0:	74 1a       	ld.w	r10,r10[0x4]
800080e2:	ed ba 00 00 	bld	r10,0x0
800080e6:	c2 20       	breq	8000812a <_realloc_r+0xb2>
800080e8:	72 1a       	ld.w	r10,r9[0x4]
800080ea:	e0 1a ff fc 	andl	r10,0xfffc
800080ee:	f4 00 00 03 	add	r3,r10,r0
800080f2:	0a 39       	cp.w	r9,r5
800080f4:	c1 31       	brne	8000811a <_realloc_r+0xa2>
800080f6:	ec c7 ff f0 	sub	r7,r6,-16
800080fa:	0e 33       	cp.w	r3,r7
800080fc:	c1 95       	brlt	8000812e <_realloc_r+0xb6>
800080fe:	e2 06 00 09 	add	r9,r1,r6
80008102:	0c 13       	sub	r3,r6
80008104:	a1 a3       	sbr	r3,0x0
80008106:	93 13       	st.w	r9[0x4],r3
80008108:	91 29       	st.w	r8[0x8],r9
8000810a:	04 9c       	mov	r12,r2
8000810c:	62 18       	ld.w	r8,r1[0x4]
8000810e:	08 95       	mov	r5,r4
80008110:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008114:	10 46       	or	r6,r8
80008116:	83 16       	st.w	r1[0x4],r6
80008118:	c0 b9       	rjmp	8000832e <_realloc_r+0x2b6>
8000811a:	0c 33       	cp.w	r3,r6
8000811c:	c0 95       	brlt	8000812e <_realloc_r+0xb6>
8000811e:	72 28       	ld.w	r8,r9[0x8]
80008120:	02 97       	mov	r7,r1
80008122:	72 39       	ld.w	r9,r9[0xc]
80008124:	93 28       	st.w	r9[0x8],r8
80008126:	91 39       	st.w	r8[0xc],r9
80008128:	cd c8       	rjmp	800082e0 <_realloc_r+0x268>
8000812a:	30 0a       	mov	r10,0
8000812c:	14 99       	mov	r9,r10
8000812e:	ed bc 00 00 	bld	r12,0x0
80008132:	e0 80 00 95 	breq	8000825c <_realloc_r+0x1e4>
80008136:	62 07       	ld.w	r7,r1[0x0]
80008138:	e2 07 01 07 	sub	r7,r1,r7
8000813c:	6e 1c       	ld.w	r12,r7[0x4]
8000813e:	e0 1c ff fc 	andl	r12,0xfffc
80008142:	58 09       	cp.w	r9,0
80008144:	c5 60       	breq	800081f0 <_realloc_r+0x178>
80008146:	f8 00 00 03 	add	r3,r12,r0
8000814a:	0a 39       	cp.w	r9,r5
8000814c:	c4 81       	brne	800081dc <_realloc_r+0x164>
8000814e:	14 03       	add	r3,r10
80008150:	ec c9 ff f0 	sub	r9,r6,-16
80008154:	12 33       	cp.w	r3,r9
80008156:	c4 d5       	brlt	800081f0 <_realloc_r+0x178>
80008158:	6e 3a       	ld.w	r10,r7[0xc]
8000815a:	6e 29       	ld.w	r9,r7[0x8]
8000815c:	95 29       	st.w	r10[0x8],r9
8000815e:	93 3a       	st.w	r9[0xc],r10
80008160:	ee c5 ff f8 	sub	r5,r7,-8
80008164:	e0 ca 00 04 	sub	r10,r0,4
80008168:	e0 4a 00 24 	cp.w	r10,36
8000816c:	e0 8b 00 25 	brhi	800081b6 <_realloc_r+0x13e>
80008170:	0a 99       	mov	r9,r5
80008172:	59 3a       	cp.w	r10,19
80008174:	e0 88 00 1a 	brls	800081a8 <_realloc_r+0x130>
80008178:	09 09       	ld.w	r9,r4++
8000817a:	8b 09       	st.w	r5[0x0],r9
8000817c:	09 09       	ld.w	r9,r4++
8000817e:	8f 39       	st.w	r7[0xc],r9
80008180:	ee c9 ff f0 	sub	r9,r7,-16
80008184:	59 ba       	cp.w	r10,27
80008186:	e0 88 00 11 	brls	800081a8 <_realloc_r+0x130>
8000818a:	09 0b       	ld.w	r11,r4++
8000818c:	93 0b       	st.w	r9[0x0],r11
8000818e:	09 09       	ld.w	r9,r4++
80008190:	8f 59       	st.w	r7[0x14],r9
80008192:	ee c9 ff e8 	sub	r9,r7,-24
80008196:	e0 4a 00 24 	cp.w	r10,36
8000819a:	c0 71       	brne	800081a8 <_realloc_r+0x130>
8000819c:	09 0a       	ld.w	r10,r4++
8000819e:	93 0a       	st.w	r9[0x0],r10
800081a0:	ee c9 ff e0 	sub	r9,r7,-32
800081a4:	09 0a       	ld.w	r10,r4++
800081a6:	8f 7a       	st.w	r7[0x1c],r10
800081a8:	09 0a       	ld.w	r10,r4++
800081aa:	12 aa       	st.w	r9++,r10
800081ac:	68 0a       	ld.w	r10,r4[0x0]
800081ae:	93 0a       	st.w	r9[0x0],r10
800081b0:	68 1a       	ld.w	r10,r4[0x4]
800081b2:	93 1a       	st.w	r9[0x4],r10
800081b4:	c0 78       	rjmp	800081c2 <_realloc_r+0x14a>
800081b6:	50 08       	stdsp	sp[0x0],r8
800081b8:	08 9b       	mov	r11,r4
800081ba:	0a 9c       	mov	r12,r5
800081bc:	e0 a0 1d 8f 	rcall	8000bcda <memmove>
800081c0:	40 08       	lddsp	r8,sp[0x0]
800081c2:	ee 06 00 09 	add	r9,r7,r6
800081c6:	0c 13       	sub	r3,r6
800081c8:	a1 a3       	sbr	r3,0x0
800081ca:	93 13       	st.w	r9[0x4],r3
800081cc:	91 29       	st.w	r8[0x8],r9
800081ce:	04 9c       	mov	r12,r2
800081d0:	6e 18       	ld.w	r8,r7[0x4]
800081d2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800081d6:	10 46       	or	r6,r8
800081d8:	8f 16       	st.w	r7[0x4],r6
800081da:	ca a8       	rjmp	8000832e <_realloc_r+0x2b6>
800081dc:	14 03       	add	r3,r10
800081de:	0c 33       	cp.w	r3,r6
800081e0:	c0 85       	brlt	800081f0 <_realloc_r+0x178>
800081e2:	72 28       	ld.w	r8,r9[0x8]
800081e4:	72 39       	ld.w	r9,r9[0xc]
800081e6:	93 28       	st.w	r9[0x8],r8
800081e8:	91 39       	st.w	r8[0xc],r9
800081ea:	6e 28       	ld.w	r8,r7[0x8]
800081ec:	6e 39       	ld.w	r9,r7[0xc]
800081ee:	c0 78       	rjmp	800081fc <_realloc_r+0x184>
800081f0:	f8 00 00 03 	add	r3,r12,r0
800081f4:	0c 33       	cp.w	r3,r6
800081f6:	c3 35       	brlt	8000825c <_realloc_r+0x1e4>
800081f8:	6e 39       	ld.w	r9,r7[0xc]
800081fa:	6e 28       	ld.w	r8,r7[0x8]
800081fc:	93 28       	st.w	r9[0x8],r8
800081fe:	91 39       	st.w	r8[0xc],r9
80008200:	e0 ca 00 04 	sub	r10,r0,4
80008204:	ee cc ff f8 	sub	r12,r7,-8
80008208:	e0 4a 00 24 	cp.w	r10,36
8000820c:	e0 8b 00 24 	brhi	80008254 <_realloc_r+0x1dc>
80008210:	59 3a       	cp.w	r10,19
80008212:	e0 88 00 1a 	brls	80008246 <_realloc_r+0x1ce>
80008216:	09 08       	ld.w	r8,r4++
80008218:	99 08       	st.w	r12[0x0],r8
8000821a:	09 08       	ld.w	r8,r4++
8000821c:	8f 38       	st.w	r7[0xc],r8
8000821e:	ee cc ff f0 	sub	r12,r7,-16
80008222:	59 ba       	cp.w	r10,27
80008224:	e0 88 00 11 	brls	80008246 <_realloc_r+0x1ce>
80008228:	09 08       	ld.w	r8,r4++
8000822a:	99 08       	st.w	r12[0x0],r8
8000822c:	09 08       	ld.w	r8,r4++
8000822e:	8f 58       	st.w	r7[0x14],r8
80008230:	ee cc ff e8 	sub	r12,r7,-24
80008234:	e0 4a 00 24 	cp.w	r10,36
80008238:	c0 71       	brne	80008246 <_realloc_r+0x1ce>
8000823a:	09 08       	ld.w	r8,r4++
8000823c:	99 08       	st.w	r12[0x0],r8
8000823e:	ee cc ff e0 	sub	r12,r7,-32
80008242:	09 08       	ld.w	r8,r4++
80008244:	8f 78       	st.w	r7[0x1c],r8
80008246:	09 08       	ld.w	r8,r4++
80008248:	18 a8       	st.w	r12++,r8
8000824a:	68 08       	ld.w	r8,r4[0x0]
8000824c:	99 08       	st.w	r12[0x0],r8
8000824e:	68 18       	ld.w	r8,r4[0x4]
80008250:	99 18       	st.w	r12[0x4],r8
80008252:	c4 78       	rjmp	800082e0 <_realloc_r+0x268>
80008254:	08 9b       	mov	r11,r4
80008256:	e0 a0 1d 42 	rcall	8000bcda <memmove>
8000825a:	c4 38       	rjmp	800082e0 <_realloc_r+0x268>
8000825c:	04 9c       	mov	r12,r2
8000825e:	fe b0 fc 33 	rcall	80007ac4 <_malloc_r>
80008262:	18 95       	mov	r5,r12
80008264:	c3 a0       	breq	800082d8 <_realloc_r+0x260>
80008266:	62 18       	ld.w	r8,r1[0x4]
80008268:	f8 c9 00 08 	sub	r9,r12,8
8000826c:	a1 c8       	cbr	r8,0x0
8000826e:	e2 08 00 08 	add	r8,r1,r8
80008272:	10 39       	cp.w	r9,r8
80008274:	c0 71       	brne	80008282 <_realloc_r+0x20a>
80008276:	72 13       	ld.w	r3,r9[0x4]
80008278:	02 97       	mov	r7,r1
8000827a:	e0 13 ff fc 	andl	r3,0xfffc
8000827e:	00 03       	add	r3,r0
80008280:	c3 08       	rjmp	800082e0 <_realloc_r+0x268>
80008282:	e0 ca 00 04 	sub	r10,r0,4
80008286:	e0 4a 00 24 	cp.w	r10,36
8000828a:	e0 8b 00 20 	brhi	800082ca <_realloc_r+0x252>
8000828e:	08 99       	mov	r9,r4
80008290:	18 98       	mov	r8,r12
80008292:	59 3a       	cp.w	r10,19
80008294:	e0 88 00 14 	brls	800082bc <_realloc_r+0x244>
80008298:	13 0b       	ld.w	r11,r9++
8000829a:	10 ab       	st.w	r8++,r11
8000829c:	13 0b       	ld.w	r11,r9++
8000829e:	10 ab       	st.w	r8++,r11
800082a0:	59 ba       	cp.w	r10,27
800082a2:	e0 88 00 0d 	brls	800082bc <_realloc_r+0x244>
800082a6:	13 0b       	ld.w	r11,r9++
800082a8:	10 ab       	st.w	r8++,r11
800082aa:	13 0b       	ld.w	r11,r9++
800082ac:	10 ab       	st.w	r8++,r11
800082ae:	e0 4a 00 24 	cp.w	r10,36
800082b2:	c0 51       	brne	800082bc <_realloc_r+0x244>
800082b4:	13 0a       	ld.w	r10,r9++
800082b6:	10 aa       	st.w	r8++,r10
800082b8:	13 0a       	ld.w	r10,r9++
800082ba:	10 aa       	st.w	r8++,r10
800082bc:	13 0a       	ld.w	r10,r9++
800082be:	10 aa       	st.w	r8++,r10
800082c0:	72 0a       	ld.w	r10,r9[0x0]
800082c2:	91 0a       	st.w	r8[0x0],r10
800082c4:	72 19       	ld.w	r9,r9[0x4]
800082c6:	91 19       	st.w	r8[0x4],r9
800082c8:	c0 48       	rjmp	800082d0 <_realloc_r+0x258>
800082ca:	08 9b       	mov	r11,r4
800082cc:	e0 a0 1d 07 	rcall	8000bcda <memmove>
800082d0:	08 9b       	mov	r11,r4
800082d2:	04 9c       	mov	r12,r2
800082d4:	e0 a0 1a 60 	rcall	8000b794 <_free_r>
800082d8:	04 9c       	mov	r12,r2
800082da:	c2 a8       	rjmp	8000832e <_realloc_r+0x2b6>
800082dc:	00 93       	mov	r3,r0
800082de:	02 97       	mov	r7,r1
800082e0:	e6 06 01 09 	sub	r9,r3,r6
800082e4:	6e 18       	ld.w	r8,r7[0x4]
800082e6:	58 f9       	cp.w	r9,15
800082e8:	e0 88 00 16 	brls	80008314 <_realloc_r+0x29c>
800082ec:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800082f0:	ed e8 10 08 	or	r8,r6,r8
800082f4:	8f 18       	st.w	r7[0x4],r8
800082f6:	12 98       	mov	r8,r9
800082f8:	a1 a8       	sbr	r8,0x0
800082fa:	ee 06 00 0b 	add	r11,r7,r6
800082fe:	f6 09 00 09 	add	r9,r11,r9
80008302:	97 18       	st.w	r11[0x4],r8
80008304:	72 18       	ld.w	r8,r9[0x4]
80008306:	a1 a8       	sbr	r8,0x0
80008308:	2f 8b       	sub	r11,-8
8000830a:	93 18       	st.w	r9[0x4],r8
8000830c:	04 9c       	mov	r12,r2
8000830e:	e0 a0 1a 43 	rcall	8000b794 <_free_r>
80008312:	c0 b8       	rjmp	80008328 <_realloc_r+0x2b0>
80008314:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008318:	e7 e8 10 08 	or	r8,r3,r8
8000831c:	8f 18       	st.w	r7[0x4],r8
8000831e:	ee 03 00 03 	add	r3,r7,r3
80008322:	66 18       	ld.w	r8,r3[0x4]
80008324:	a1 a8       	sbr	r8,0x0
80008326:	87 18       	st.w	r3[0x4],r8
80008328:	04 9c       	mov	r12,r2
8000832a:	ee c5 ff f8 	sub	r5,r7,-8
8000832e:	fe b0 f0 d3 	rcall	800064d4 <__malloc_unlock>
80008332:	0a 9c       	mov	r12,r5
80008334:	2f fd       	sub	sp,-4
80008336:	d8 32       	popm	r0-r7,pc

80008338 <_sbrk_r>:
80008338:	d4 21       	pushm	r4-r7,lr
8000833a:	30 08       	mov	r8,0
8000833c:	18 97       	mov	r7,r12
8000833e:	e0 66 54 30 	mov	r6,21552
80008342:	16 9c       	mov	r12,r11
80008344:	8d 08       	st.w	r6[0x0],r8
80008346:	c8 5c       	rcall	80008450 <_sbrk>
80008348:	5b fc       	cp.w	r12,-1
8000834a:	c0 51       	brne	80008354 <_sbrk_r+0x1c>
8000834c:	6c 08       	ld.w	r8,r6[0x0]
8000834e:	58 08       	cp.w	r8,0
80008350:	ef f8 1a 03 	st.wne	r7[0xc],r8
80008354:	d8 22       	popm	r4-r7,pc
80008356:	d7 03       	nop

80008358 <sprintf>:
80008358:	d4 01       	pushm	lr
8000835a:	21 7d       	sub	sp,92
8000835c:	e0 68 ff ff 	mov	r8,65535
80008360:	ea 18 7f ff 	orh	r8,0x7fff
80008364:	50 58       	stdsp	sp[0x14],r8
80008366:	50 28       	stdsp	sp[0x8],r8
80008368:	e0 68 02 08 	mov	r8,520
8000836c:	ba 68       	st.h	sp[0xc],r8
8000836e:	3f f8       	mov	r8,-1
80008370:	ba 78       	st.h	sp[0xe],r8
80008372:	e0 68 0a 48 	mov	r8,2632
80008376:	50 4c       	stdsp	sp[0x10],r12
80008378:	16 9a       	mov	r10,r11
8000837a:	50 0c       	stdsp	sp[0x0],r12
8000837c:	fa c9 ff a0 	sub	r9,sp,-96
80008380:	70 0c       	ld.w	r12,r8[0x0]
80008382:	1a 9b       	mov	r11,sp
80008384:	e0 a0 02 1a 	rcall	800087b8 <_vfprintf_r>
80008388:	30 09       	mov	r9,0
8000838a:	40 08       	lddsp	r8,sp[0x0]
8000838c:	b0 89       	st.b	r8[0x0],r9
8000838e:	2e 9d       	sub	sp,-92
80008390:	d8 02       	popm	pc
80008392:	d7 03       	nop

80008394 <strncpy>:
80008394:	30 08       	mov	r8,0
80008396:	10 3a       	cp.w	r10,r8
80008398:	5e 0c       	reteq	r12
8000839a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000839e:	f8 08 0b 09 	st.b	r12[r8],r9
800083a2:	2f f8       	sub	r8,-1
800083a4:	58 09       	cp.w	r9,0
800083a6:	cf 81       	brne	80008396 <strncpy+0x2>
800083a8:	10 3a       	cp.w	r10,r8
800083aa:	5e 0c       	reteq	r12
800083ac:	f8 08 0b 09 	st.b	r12[r8],r9
800083b0:	2f f8       	sub	r8,-1
800083b2:	cf bb       	rjmp	800083a8 <strncpy+0x14>

800083b4 <_close>:
800083b4:	30 28       	mov	r8,2
800083b6:	d6 73       	breakpoint
800083b8:	3f fc       	mov	r12,-1
800083ba:	35 8b       	mov	r11,88
800083bc:	58 0c       	cp.w	r12,0
800083be:	5e 4c       	retge	r12
800083c0:	e0 6a 54 30 	mov	r10,21552
800083c4:	95 0b       	st.w	r10[0x0],r11
800083c6:	5e fc       	retal	r12

800083c8 <_lseek>:
800083c8:	30 58       	mov	r8,5
800083ca:	d6 73       	breakpoint
800083cc:	3f fc       	mov	r12,-1
800083ce:	35 8b       	mov	r11,88
800083d0:	58 0c       	cp.w	r12,0
800083d2:	5e 4c       	retge	r12
800083d4:	e0 6a 54 30 	mov	r10,21552
800083d8:	95 0b       	st.w	r10[0x0],r11
800083da:	5e fc       	retal	r12

800083dc <isatty>:
800083dc:	30 b8       	mov	r8,11
800083de:	d6 73       	breakpoint
800083e0:	3f fc       	mov	r12,-1
800083e2:	35 8b       	mov	r11,88
800083e4:	58 0c       	cp.w	r12,0
800083e6:	5e 4c       	retge	r12
800083e8:	e0 6a 54 30 	mov	r10,21552
800083ec:	95 0b       	st.w	r10[0x0],r11
800083ee:	5e fc       	retal	r12

800083f0 <_fstat_host>:
800083f0:	30 98       	mov	r8,9
800083f2:	d6 73       	breakpoint
800083f4:	3f fc       	mov	r12,-1
800083f6:	35 8b       	mov	r11,88
800083f8:	58 0c       	cp.w	r12,0
800083fa:	5e 4c       	retge	r12
800083fc:	e0 6a 54 30 	mov	r10,21552
80008400:	95 0b       	st.w	r10[0x0],r11
80008402:	5e fc       	retal	r12

80008404 <_fstat>:
80008404:	d4 21       	pushm	r4-r7,lr
80008406:	21 0d       	sub	sp,64
80008408:	16 97       	mov	r7,r11
8000840a:	1a 9b       	mov	r11,sp
8000840c:	cf 2f       	rcall	800083f0 <_fstat_host>
8000840e:	c0 34       	brge	80008414 <_fstat+0x10>
80008410:	3f fc       	mov	r12,-1
80008412:	c1 c8       	rjmp	8000844a <_fstat+0x46>
80008414:	40 08       	lddsp	r8,sp[0x0]
80008416:	ae 08       	st.h	r7[0x0],r8
80008418:	40 18       	lddsp	r8,sp[0x4]
8000841a:	ae 18       	st.h	r7[0x2],r8
8000841c:	40 28       	lddsp	r8,sp[0x8]
8000841e:	8f 18       	st.w	r7[0x4],r8
80008420:	40 38       	lddsp	r8,sp[0xc]
80008422:	ae 48       	st.h	r7[0x8],r8
80008424:	40 48       	lddsp	r8,sp[0x10]
80008426:	ae 58       	st.h	r7[0xa],r8
80008428:	40 58       	lddsp	r8,sp[0x14]
8000842a:	ae 68       	st.h	r7[0xc],r8
8000842c:	40 68       	lddsp	r8,sp[0x18]
8000842e:	ae 78       	st.h	r7[0xe],r8
80008430:	40 88       	lddsp	r8,sp[0x20]
80008432:	8f 48       	st.w	r7[0x10],r8
80008434:	40 a8       	lddsp	r8,sp[0x28]
80008436:	8f b8       	st.w	r7[0x2c],r8
80008438:	40 c8       	lddsp	r8,sp[0x30]
8000843a:	8f c8       	st.w	r7[0x30],r8
8000843c:	40 d8       	lddsp	r8,sp[0x34]
8000843e:	8f 58       	st.w	r7[0x14],r8
80008440:	40 e8       	lddsp	r8,sp[0x38]
80008442:	30 0c       	mov	r12,0
80008444:	8f 78       	st.w	r7[0x1c],r8
80008446:	40 f8       	lddsp	r8,sp[0x3c]
80008448:	8f 98       	st.w	r7[0x24],r8
8000844a:	2f 0d       	sub	sp,-64
8000844c:	d8 22       	popm	r4-r7,pc
8000844e:	d7 03       	nop

80008450 <_sbrk>:
80008450:	d4 01       	pushm	lr
80008452:	e0 68 0d fc 	mov	r8,3580
80008456:	70 09       	ld.w	r9,r8[0x0]
80008458:	58 09       	cp.w	r9,0
8000845a:	c0 41       	brne	80008462 <_sbrk+0x12>
8000845c:	e0 69 54 38 	mov	r9,21560
80008460:	91 09       	st.w	r8[0x0],r9
80008462:	e0 69 0d fc 	mov	r9,3580
80008466:	e0 7a 70 00 	mov	r10,94208
8000846a:	72 08       	ld.w	r8,r9[0x0]
8000846c:	f0 0c 00 0c 	add	r12,r8,r12
80008470:	14 3c       	cp.w	r12,r10
80008472:	e0 8b 00 04 	brhi	8000847a <_sbrk+0x2a>
80008476:	93 0c       	st.w	r9[0x0],r12
80008478:	c0 68       	rjmp	80008484 <_sbrk+0x34>
8000847a:	e0 a0 18 15 	rcall	8000b4a4 <__errno>
8000847e:	30 c8       	mov	r8,12
80008480:	99 08       	st.w	r12[0x0],r8
80008482:	3f f8       	mov	r8,-1
80008484:	10 9c       	mov	r12,r8
80008486:	d8 02       	popm	pc

80008488 <get_arg>:
80008488:	d4 31       	pushm	r0-r7,lr
8000848a:	20 8d       	sub	sp,32
8000848c:	fa c4 ff bc 	sub	r4,sp,-68
80008490:	50 4b       	stdsp	sp[0x10],r11
80008492:	68 2e       	ld.w	lr,r4[0x8]
80008494:	50 58       	stdsp	sp[0x14],r8
80008496:	12 96       	mov	r6,r9
80008498:	7c 0b       	ld.w	r11,lr[0x0]
8000849a:	70 05       	ld.w	r5,r8[0x0]
8000849c:	50 6e       	stdsp	sp[0x18],lr
8000849e:	58 0b       	cp.w	r11,0
800084a0:	f4 0b 17 00 	moveq	r11,r10
800084a4:	68 03       	ld.w	r3,r4[0x0]
800084a6:	68 11       	ld.w	r1,r4[0x4]
800084a8:	40 49       	lddsp	r9,sp[0x10]
800084aa:	30 08       	mov	r8,0
800084ac:	c2 89       	rjmp	800086fc <get_arg+0x274>
800084ae:	2f fb       	sub	r11,-1
800084b0:	32 5c       	mov	r12,37
800084b2:	17 8a       	ld.ub	r10,r11[0x0]
800084b4:	f8 0a 18 00 	cp.b	r10,r12
800084b8:	5f 1e       	srne	lr
800084ba:	f0 0a 18 00 	cp.b	r10,r8
800084be:	5f 1c       	srne	r12
800084c0:	fd ec 00 0c 	and	r12,lr,r12
800084c4:	f0 0c 18 00 	cp.b	r12,r8
800084c8:	cf 31       	brne	800084ae <get_arg+0x26>
800084ca:	58 0a       	cp.w	r10,0
800084cc:	e0 80 01 25 	breq	80008716 <get_arg+0x28e>
800084d0:	30 0c       	mov	r12,0
800084d2:	3f fa       	mov	r10,-1
800084d4:	18 90       	mov	r0,r12
800084d6:	50 3a       	stdsp	sp[0xc],r10
800084d8:	18 94       	mov	r4,r12
800084da:	18 92       	mov	r2,r12
800084dc:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
800084e0:	16 97       	mov	r7,r11
800084e2:	50 7c       	stdsp	sp[0x1c],r12
800084e4:	fe cc 9d b8 	sub	r12,pc,-25160
800084e8:	0f 3a       	ld.ub	r10,r7++
800084ea:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
800084ee:	40 7c       	lddsp	r12,sp[0x1c]
800084f0:	1c 0c       	add	r12,lr
800084f2:	fe ce 9e 8e 	sub	lr,pc,-24946
800084f6:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
800084fa:	20 1e       	sub	lr,1
800084fc:	50 0e       	stdsp	sp[0x0],lr
800084fe:	fe ce 9f 06 	sub	lr,pc,-24826
80008502:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80008506:	50 7c       	stdsp	sp[0x1c],r12
80008508:	40 0c       	lddsp	r12,sp[0x0]
8000850a:	58 7c       	cp.w	r12,7
8000850c:	e0 8b 00 f1 	brhi	800086ee <get_arg+0x266>
80008510:	fe ce a0 b8 	sub	lr,pc,-24392
80008514:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80008518:	36 8b       	mov	r11,104
8000851a:	f6 0a 18 00 	cp.b	r10,r11
8000851e:	e0 80 00 e8 	breq	800086ee <get_arg+0x266>
80008522:	37 1b       	mov	r11,113
80008524:	f6 0a 18 00 	cp.b	r10,r11
80008528:	c0 70       	breq	80008536 <get_arg+0xae>
8000852a:	34 cb       	mov	r11,76
8000852c:	f6 0a 18 00 	cp.b	r10,r11
80008530:	c0 51       	brne	8000853a <get_arg+0xb2>
80008532:	a3 b4       	sbr	r4,0x3
80008534:	cd d8       	rjmp	800086ee <get_arg+0x266>
80008536:	a5 b4       	sbr	r4,0x5
80008538:	cd b8       	rjmp	800086ee <get_arg+0x266>
8000853a:	08 9a       	mov	r10,r4
8000853c:	0e 9b       	mov	r11,r7
8000853e:	a5 aa       	sbr	r10,0x4
80008540:	17 3c       	ld.ub	r12,r11++
80008542:	a5 b4       	sbr	r4,0x5
80008544:	36 ce       	mov	lr,108
80008546:	fc 0c 18 00 	cp.b	r12,lr
8000854a:	e0 80 00 d3 	breq	800086f0 <get_arg+0x268>
8000854e:	14 94       	mov	r4,r10
80008550:	cc f8       	rjmp	800086ee <get_arg+0x266>
80008552:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80008556:	36 7c       	mov	r12,103
80008558:	f8 0a 18 00 	cp.b	r10,r12
8000855c:	e0 8b 00 27 	brhi	800085aa <get_arg+0x122>
80008560:	36 5b       	mov	r11,101
80008562:	f6 0a 18 00 	cp.b	r10,r11
80008566:	c4 82       	brcc	800085f6 <get_arg+0x16e>
80008568:	34 fb       	mov	r11,79
8000856a:	f6 0a 18 00 	cp.b	r10,r11
8000856e:	c4 80       	breq	800085fe <get_arg+0x176>
80008570:	e0 8b 00 0c 	brhi	80008588 <get_arg+0x100>
80008574:	34 5b       	mov	r11,69
80008576:	f6 0a 18 00 	cp.b	r10,r11
8000857a:	c3 e0       	breq	800085f6 <get_arg+0x16e>
8000857c:	34 7b       	mov	r11,71
8000857e:	f6 0a 18 00 	cp.b	r10,r11
80008582:	c3 a0       	breq	800085f6 <get_arg+0x16e>
80008584:	34 4b       	mov	r11,68
80008586:	c0 88       	rjmp	80008596 <get_arg+0x10e>
80008588:	35 8b       	mov	r11,88
8000858a:	f6 0a 18 00 	cp.b	r10,r11
8000858e:	c2 c0       	breq	800085e6 <get_arg+0x15e>
80008590:	e0 8b 00 07 	brhi	8000859e <get_arg+0x116>
80008594:	35 5b       	mov	r11,85
80008596:	f6 0a 18 00 	cp.b	r10,r11
8000859a:	c3 51       	brne	80008604 <get_arg+0x17c>
8000859c:	c3 18       	rjmp	800085fe <get_arg+0x176>
8000859e:	36 3b       	mov	r11,99
800085a0:	f6 0a 18 00 	cp.b	r10,r11
800085a4:	c2 f0       	breq	80008602 <get_arg+0x17a>
800085a6:	36 4b       	mov	r11,100
800085a8:	c0 e8       	rjmp	800085c4 <get_arg+0x13c>
800085aa:	37 0b       	mov	r11,112
800085ac:	f6 0a 18 00 	cp.b	r10,r11
800085b0:	c2 50       	breq	800085fa <get_arg+0x172>
800085b2:	e0 8b 00 0d 	brhi	800085cc <get_arg+0x144>
800085b6:	36 eb       	mov	r11,110
800085b8:	f6 0a 18 00 	cp.b	r10,r11
800085bc:	c1 f0       	breq	800085fa <get_arg+0x172>
800085be:	e0 8b 00 14 	brhi	800085e6 <get_arg+0x15e>
800085c2:	36 9b       	mov	r11,105
800085c4:	f6 0a 18 00 	cp.b	r10,r11
800085c8:	c1 e1       	brne	80008604 <get_arg+0x17c>
800085ca:	c0 e8       	rjmp	800085e6 <get_arg+0x15e>
800085cc:	37 5b       	mov	r11,117
800085ce:	f6 0a 18 00 	cp.b	r10,r11
800085d2:	c0 a0       	breq	800085e6 <get_arg+0x15e>
800085d4:	37 8b       	mov	r11,120
800085d6:	f6 0a 18 00 	cp.b	r10,r11
800085da:	c0 60       	breq	800085e6 <get_arg+0x15e>
800085dc:	37 3b       	mov	r11,115
800085de:	f6 0a 18 00 	cp.b	r10,r11
800085e2:	c1 11       	brne	80008604 <get_arg+0x17c>
800085e4:	c0 b8       	rjmp	800085fa <get_arg+0x172>
800085e6:	ed b4 00 04 	bld	r4,0x4
800085ea:	c0 a0       	breq	800085fe <get_arg+0x176>
800085ec:	ed b4 00 05 	bld	r4,0x5
800085f0:	c0 91       	brne	80008602 <get_arg+0x17a>
800085f2:	30 20       	mov	r0,2
800085f4:	c0 88       	rjmp	80008604 <get_arg+0x17c>
800085f6:	30 40       	mov	r0,4
800085f8:	c0 68       	rjmp	80008604 <get_arg+0x17c>
800085fa:	30 30       	mov	r0,3
800085fc:	c0 48       	rjmp	80008604 <get_arg+0x17c>
800085fe:	30 10       	mov	r0,1
80008600:	c0 28       	rjmp	80008604 <get_arg+0x17c>
80008602:	30 00       	mov	r0,0
80008604:	40 3b       	lddsp	r11,sp[0xc]
80008606:	5b fb       	cp.w	r11,-1
80008608:	c0 40       	breq	80008610 <get_arg+0x188>
8000860a:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000860e:	c7 08       	rjmp	800086ee <get_arg+0x266>
80008610:	58 60       	cp.w	r0,6
80008612:	e0 8b 00 6e 	brhi	800086ee <get_arg+0x266>
80008616:	6c 0a       	ld.w	r10,r6[0x0]
80008618:	ea cc ff ff 	sub	r12,r5,-1
8000861c:	fe ce a1 a4 	sub	lr,pc,-24156
80008620:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80008624:	f4 cb ff f8 	sub	r11,r10,-8
80008628:	8d 0b       	st.w	r6[0x0],r11
8000862a:	f4 ea 00 00 	ld.d	r10,r10[0]
8000862e:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008632:	c0 f8       	rjmp	80008650 <get_arg+0x1c8>
80008634:	f4 cb ff fc 	sub	r11,r10,-4
80008638:	8d 0b       	st.w	r6[0x0],r11
8000863a:	74 0a       	ld.w	r10,r10[0x0]
8000863c:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80008640:	c0 88       	rjmp	80008650 <get_arg+0x1c8>
80008642:	f4 cb ff f8 	sub	r11,r10,-8
80008646:	8d 0b       	st.w	r6[0x0],r11
80008648:	f4 ea 00 00 	ld.d	r10,r10[0]
8000864c:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008650:	0e 9b       	mov	r11,r7
80008652:	18 95       	mov	r5,r12
80008654:	c4 e8       	rjmp	800086f0 <get_arg+0x268>
80008656:	62 0a       	ld.w	r10,r1[0x0]
80008658:	5b fa       	cp.w	r10,-1
8000865a:	c0 b1       	brne	80008670 <get_arg+0x1e8>
8000865c:	50 19       	stdsp	sp[0x4],r9
8000865e:	50 28       	stdsp	sp[0x8],r8
80008660:	e0 6a 00 80 	mov	r10,128
80008664:	30 0b       	mov	r11,0
80008666:	02 9c       	mov	r12,r1
80008668:	fe b0 fd 01 	rcall	8000806a <memset>
8000866c:	40 28       	lddsp	r8,sp[0x8]
8000866e:	40 19       	lddsp	r9,sp[0x4]
80008670:	e4 cc 00 01 	sub	r12,r2,1
80008674:	0e 9b       	mov	r11,r7
80008676:	50 3c       	stdsp	sp[0xc],r12
80008678:	f2 0c 0c 49 	max	r9,r9,r12
8000867c:	c3 a8       	rjmp	800086f0 <get_arg+0x268>
8000867e:	62 0a       	ld.w	r10,r1[0x0]
80008680:	5b fa       	cp.w	r10,-1
80008682:	c0 b1       	brne	80008698 <get_arg+0x210>
80008684:	50 19       	stdsp	sp[0x4],r9
80008686:	50 28       	stdsp	sp[0x8],r8
80008688:	e0 6a 00 80 	mov	r10,128
8000868c:	30 0b       	mov	r11,0
8000868e:	02 9c       	mov	r12,r1
80008690:	fe b0 fc ed 	rcall	8000806a <memset>
80008694:	40 28       	lddsp	r8,sp[0x8]
80008696:	40 19       	lddsp	r9,sp[0x4]
80008698:	20 12       	sub	r2,1
8000869a:	30 0a       	mov	r10,0
8000869c:	0e 9b       	mov	r11,r7
8000869e:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
800086a2:	f2 02 0c 49 	max	r9,r9,r2
800086a6:	c2 58       	rjmp	800086f0 <get_arg+0x268>
800086a8:	16 97       	mov	r7,r11
800086aa:	6c 0a       	ld.w	r10,r6[0x0]
800086ac:	f4 cb ff fc 	sub	r11,r10,-4
800086b0:	8d 0b       	st.w	r6[0x0],r11
800086b2:	74 0a       	ld.w	r10,r10[0x0]
800086b4:	0e 9b       	mov	r11,r7
800086b6:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800086ba:	2f f5       	sub	r5,-1
800086bc:	c1 a8       	rjmp	800086f0 <get_arg+0x268>
800086be:	f4 c2 00 30 	sub	r2,r10,48
800086c2:	c0 68       	rjmp	800086ce <get_arg+0x246>
800086c4:	e4 02 00 22 	add	r2,r2,r2<<0x2
800086c8:	2f f7       	sub	r7,-1
800086ca:	f4 02 00 12 	add	r2,r10,r2<<0x1
800086ce:	0f 8a       	ld.ub	r10,r7[0x0]
800086d0:	58 0a       	cp.w	r10,0
800086d2:	c0 e0       	breq	800086ee <get_arg+0x266>
800086d4:	23 0a       	sub	r10,48
800086d6:	58 9a       	cp.w	r10,9
800086d8:	fe 98 ff f6 	brls	800086c4 <get_arg+0x23c>
800086dc:	c0 98       	rjmp	800086ee <get_arg+0x266>
800086de:	2f f7       	sub	r7,-1
800086e0:	0f 8a       	ld.ub	r10,r7[0x0]
800086e2:	58 0a       	cp.w	r10,0
800086e4:	c0 50       	breq	800086ee <get_arg+0x266>
800086e6:	23 0a       	sub	r10,48
800086e8:	58 9a       	cp.w	r10,9
800086ea:	fe 98 ff fa 	brls	800086de <get_arg+0x256>
800086ee:	0e 9b       	mov	r11,r7
800086f0:	40 7c       	lddsp	r12,sp[0x1c]
800086f2:	30 ba       	mov	r10,11
800086f4:	f4 0c 18 00 	cp.b	r12,r10
800086f8:	fe 91 fe f2 	brne	800084dc <get_arg+0x54>
800086fc:	40 42       	lddsp	r2,sp[0x10]
800086fe:	17 8c       	ld.ub	r12,r11[0x0]
80008700:	0a 32       	cp.w	r2,r5
80008702:	5f 4a       	srge	r10
80008704:	f0 0c 18 00 	cp.b	r12,r8
80008708:	5f 1c       	srne	r12
8000870a:	f9 ea 00 0a 	and	r10,r12,r10
8000870e:	f0 0a 18 00 	cp.b	r10,r8
80008712:	fe 91 fe cf 	brne	800084b0 <get_arg+0x28>
80008716:	30 08       	mov	r8,0
80008718:	40 4e       	lddsp	lr,sp[0x10]
8000871a:	17 8a       	ld.ub	r10,r11[0x0]
8000871c:	e2 05 00 21 	add	r1,r1,r5<<0x2
80008720:	f0 0a 18 00 	cp.b	r10,r8
80008724:	fc 09 17 10 	movne	r9,lr
80008728:	e6 05 00 38 	add	r8,r3,r5<<0x3
8000872c:	06 9e       	mov	lr,r3
8000872e:	c2 a8       	rjmp	80008782 <get_arg+0x2fa>
80008730:	62 0a       	ld.w	r10,r1[0x0]
80008732:	58 3a       	cp.w	r10,3
80008734:	c1 e0       	breq	80008770 <get_arg+0x2e8>
80008736:	e0 89 00 07 	brgt	80008744 <get_arg+0x2bc>
8000873a:	58 1a       	cp.w	r10,1
8000873c:	c1 a0       	breq	80008770 <get_arg+0x2e8>
8000873e:	58 2a       	cp.w	r10,2
80008740:	c1 81       	brne	80008770 <get_arg+0x2e8>
80008742:	c0 58       	rjmp	8000874c <get_arg+0x2c4>
80008744:	58 5a       	cp.w	r10,5
80008746:	c0 c0       	breq	8000875e <get_arg+0x2d6>
80008748:	c0 b5       	brlt	8000875e <get_arg+0x2d6>
8000874a:	c1 38       	rjmp	80008770 <get_arg+0x2e8>
8000874c:	6c 0a       	ld.w	r10,r6[0x0]
8000874e:	f4 cc ff f8 	sub	r12,r10,-8
80008752:	8d 0c       	st.w	r6[0x0],r12
80008754:	f4 e2 00 00 	ld.d	r2,r10[0]
80008758:	f0 e3 00 00 	st.d	r8[0],r2
8000875c:	c1 08       	rjmp	8000877c <get_arg+0x2f4>
8000875e:	6c 0a       	ld.w	r10,r6[0x0]
80008760:	f4 cc ff f8 	sub	r12,r10,-8
80008764:	8d 0c       	st.w	r6[0x0],r12
80008766:	f4 e2 00 00 	ld.d	r2,r10[0]
8000876a:	f0 e3 00 00 	st.d	r8[0],r2
8000876e:	c0 78       	rjmp	8000877c <get_arg+0x2f4>
80008770:	6c 0a       	ld.w	r10,r6[0x0]
80008772:	f4 cc ff fc 	sub	r12,r10,-4
80008776:	8d 0c       	st.w	r6[0x0],r12
80008778:	74 0a       	ld.w	r10,r10[0x0]
8000877a:	91 0a       	st.w	r8[0x0],r10
8000877c:	2f f5       	sub	r5,-1
8000877e:	2f 88       	sub	r8,-8
80008780:	2f c1       	sub	r1,-4
80008782:	12 35       	cp.w	r5,r9
80008784:	fe 9a ff d6 	brle	80008730 <get_arg+0x2a8>
80008788:	1c 93       	mov	r3,lr
8000878a:	40 52       	lddsp	r2,sp[0x14]
8000878c:	40 6e       	lddsp	lr,sp[0x18]
8000878e:	85 05       	st.w	r2[0x0],r5
80008790:	9d 0b       	st.w	lr[0x0],r11
80008792:	40 4b       	lddsp	r11,sp[0x10]
80008794:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80008798:	2f 8d       	sub	sp,-32
8000879a:	d8 32       	popm	r0-r7,pc

8000879c <__sprint_r>:
8000879c:	d4 21       	pushm	r4-r7,lr
8000879e:	14 97       	mov	r7,r10
800087a0:	74 28       	ld.w	r8,r10[0x8]
800087a2:	58 08       	cp.w	r8,0
800087a4:	c0 41       	brne	800087ac <__sprint_r+0x10>
800087a6:	95 18       	st.w	r10[0x4],r8
800087a8:	10 9c       	mov	r12,r8
800087aa:	d8 22       	popm	r4-r7,pc
800087ac:	e0 a0 18 ba 	rcall	8000b920 <__sfvwrite_r>
800087b0:	30 08       	mov	r8,0
800087b2:	8f 18       	st.w	r7[0x4],r8
800087b4:	8f 28       	st.w	r7[0x8],r8
800087b6:	d8 22       	popm	r4-r7,pc

800087b8 <_vfprintf_r>:
800087b8:	d4 31       	pushm	r0-r7,lr
800087ba:	fa cd 06 bc 	sub	sp,sp,1724
800087be:	51 09       	stdsp	sp[0x40],r9
800087c0:	16 91       	mov	r1,r11
800087c2:	14 97       	mov	r7,r10
800087c4:	18 95       	mov	r5,r12
800087c6:	e0 a0 1a 1d 	rcall	8000bc00 <_localeconv_r>
800087ca:	78 0c       	ld.w	r12,r12[0x0]
800087cc:	50 cc       	stdsp	sp[0x30],r12
800087ce:	58 05       	cp.w	r5,0
800087d0:	c0 70       	breq	800087de <_vfprintf_r+0x26>
800087d2:	6a 68       	ld.w	r8,r5[0x18]
800087d4:	58 08       	cp.w	r8,0
800087d6:	c0 41       	brne	800087de <_vfprintf_r+0x26>
800087d8:	0a 9c       	mov	r12,r5
800087da:	e0 a0 17 43 	rcall	8000b660 <__sinit>
800087de:	fe c8 9f a2 	sub	r8,pc,-24670
800087e2:	10 31       	cp.w	r1,r8
800087e4:	c0 31       	brne	800087ea <_vfprintf_r+0x32>
800087e6:	6a 01       	ld.w	r1,r5[0x0]
800087e8:	c0 c8       	rjmp	80008800 <_vfprintf_r+0x48>
800087ea:	fe c8 9f 8e 	sub	r8,pc,-24690
800087ee:	10 31       	cp.w	r1,r8
800087f0:	c0 31       	brne	800087f6 <_vfprintf_r+0x3e>
800087f2:	6a 11       	ld.w	r1,r5[0x4]
800087f4:	c0 68       	rjmp	80008800 <_vfprintf_r+0x48>
800087f6:	fe c8 9f 7a 	sub	r8,pc,-24710
800087fa:	10 31       	cp.w	r1,r8
800087fc:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80008800:	82 68       	ld.sh	r8,r1[0xc]
80008802:	ed b8 00 03 	bld	r8,0x3
80008806:	c0 41       	brne	8000880e <_vfprintf_r+0x56>
80008808:	62 48       	ld.w	r8,r1[0x10]
8000880a:	58 08       	cp.w	r8,0
8000880c:	c0 71       	brne	8000881a <_vfprintf_r+0x62>
8000880e:	02 9b       	mov	r11,r1
80008810:	0a 9c       	mov	r12,r5
80008812:	e0 a0 0f 5d 	rcall	8000a6cc <__swsetup_r>
80008816:	e0 81 0f 54 	brne	8000a6be <_vfprintf_r+0x1f06>
8000881a:	82 68       	ld.sh	r8,r1[0xc]
8000881c:	10 99       	mov	r9,r8
8000881e:	e2 19 00 1a 	andl	r9,0x1a,COH
80008822:	58 a9       	cp.w	r9,10
80008824:	c3 c1       	brne	8000889c <_vfprintf_r+0xe4>
80008826:	82 79       	ld.sh	r9,r1[0xe]
80008828:	30 0a       	mov	r10,0
8000882a:	f4 09 19 00 	cp.h	r9,r10
8000882e:	c3 75       	brlt	8000889c <_vfprintf_r+0xe4>
80008830:	a1 d8       	cbr	r8,0x1
80008832:	fb 58 05 d0 	st.h	sp[1488],r8
80008836:	62 88       	ld.w	r8,r1[0x20]
80008838:	fb 48 05 e4 	st.w	sp[1508],r8
8000883c:	62 a8       	ld.w	r8,r1[0x28]
8000883e:	fb 48 05 ec 	st.w	sp[1516],r8
80008842:	fa c8 ff bc 	sub	r8,sp,-68
80008846:	fb 48 05 d4 	st.w	sp[1492],r8
8000884a:	fb 48 05 c4 	st.w	sp[1476],r8
8000884e:	e0 68 04 00 	mov	r8,1024
80008852:	fb 48 05 d8 	st.w	sp[1496],r8
80008856:	fb 48 05 cc 	st.w	sp[1484],r8
8000885a:	30 08       	mov	r8,0
8000885c:	fb 59 05 d2 	st.h	sp[1490],r9
80008860:	0e 9a       	mov	r10,r7
80008862:	41 09       	lddsp	r9,sp[0x40]
80008864:	fa c7 fa 3c 	sub	r7,sp,-1476
80008868:	fb 48 05 dc 	st.w	sp[1500],r8
8000886c:	0a 9c       	mov	r12,r5
8000886e:	0e 9b       	mov	r11,r7
80008870:	ca 4f       	rcall	800087b8 <_vfprintf_r>
80008872:	50 bc       	stdsp	sp[0x2c],r12
80008874:	c0 95       	brlt	80008886 <_vfprintf_r+0xce>
80008876:	0e 9b       	mov	r11,r7
80008878:	0a 9c       	mov	r12,r5
8000887a:	e0 a0 16 1b 	rcall	8000b4b0 <_fflush_r>
8000887e:	40 be       	lddsp	lr,sp[0x2c]
80008880:	f9 be 01 ff 	movne	lr,-1
80008884:	50 be       	stdsp	sp[0x2c],lr
80008886:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000888a:	ed b8 00 06 	bld	r8,0x6
8000888e:	e0 81 0f 1a 	brne	8000a6c2 <_vfprintf_r+0x1f0a>
80008892:	82 68       	ld.sh	r8,r1[0xc]
80008894:	a7 a8       	sbr	r8,0x6
80008896:	a2 68       	st.h	r1[0xc],r8
80008898:	e0 8f 0f 15 	bral	8000a6c2 <_vfprintf_r+0x1f0a>
8000889c:	30 08       	mov	r8,0
8000889e:	fb 48 06 b4 	st.w	sp[1716],r8
800088a2:	fb 48 06 90 	st.w	sp[1680],r8
800088a6:	fb 48 06 8c 	st.w	sp[1676],r8
800088aa:	fb 48 06 b0 	st.w	sp[1712],r8
800088ae:	30 08       	mov	r8,0
800088b0:	30 09       	mov	r9,0
800088b2:	50 a7       	stdsp	sp[0x28],r7
800088b4:	50 78       	stdsp	sp[0x1c],r8
800088b6:	fa c3 f9 e0 	sub	r3,sp,-1568
800088ba:	3f f8       	mov	r8,-1
800088bc:	50 59       	stdsp	sp[0x14],r9
800088be:	fb 43 06 88 	st.w	sp[1672],r3
800088c2:	fb 48 05 44 	st.w	sp[1348],r8
800088c6:	12 9c       	mov	r12,r9
800088c8:	50 69       	stdsp	sp[0x18],r9
800088ca:	50 d9       	stdsp	sp[0x34],r9
800088cc:	50 e9       	stdsp	sp[0x38],r9
800088ce:	50 b9       	stdsp	sp[0x2c],r9
800088d0:	12 97       	mov	r7,r9
800088d2:	0a 94       	mov	r4,r5
800088d4:	40 a2       	lddsp	r2,sp[0x28]
800088d6:	32 5a       	mov	r10,37
800088d8:	30 08       	mov	r8,0
800088da:	c0 28       	rjmp	800088de <_vfprintf_r+0x126>
800088dc:	2f f2       	sub	r2,-1
800088de:	05 89       	ld.ub	r9,r2[0x0]
800088e0:	f0 09 18 00 	cp.b	r9,r8
800088e4:	5f 1b       	srne	r11
800088e6:	f4 09 18 00 	cp.b	r9,r10
800088ea:	5f 19       	srne	r9
800088ec:	f3 eb 00 0b 	and	r11,r9,r11
800088f0:	f0 0b 18 00 	cp.b	r11,r8
800088f4:	cf 41       	brne	800088dc <_vfprintf_r+0x124>
800088f6:	40 ab       	lddsp	r11,sp[0x28]
800088f8:	e4 0b 01 06 	sub	r6,r2,r11
800088fc:	c1 e0       	breq	80008938 <_vfprintf_r+0x180>
800088fe:	fa f8 06 90 	ld.w	r8,sp[1680]
80008902:	0c 08       	add	r8,r6
80008904:	87 0b       	st.w	r3[0x0],r11
80008906:	fb 48 06 90 	st.w	sp[1680],r8
8000890a:	87 16       	st.w	r3[0x4],r6
8000890c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008910:	2f f8       	sub	r8,-1
80008912:	fb 48 06 8c 	st.w	sp[1676],r8
80008916:	58 78       	cp.w	r8,7
80008918:	e0 89 00 04 	brgt	80008920 <_vfprintf_r+0x168>
8000891c:	2f 83       	sub	r3,-8
8000891e:	c0 a8       	rjmp	80008932 <_vfprintf_r+0x17a>
80008920:	fa ca f9 78 	sub	r10,sp,-1672
80008924:	02 9b       	mov	r11,r1
80008926:	08 9c       	mov	r12,r4
80008928:	c3 af       	rcall	8000879c <__sprint_r>
8000892a:	e0 81 0e c6 	brne	8000a6b6 <_vfprintf_r+0x1efe>
8000892e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008932:	40 ba       	lddsp	r10,sp[0x2c]
80008934:	0c 0a       	add	r10,r6
80008936:	50 ba       	stdsp	sp[0x2c],r10
80008938:	05 89       	ld.ub	r9,r2[0x0]
8000893a:	30 08       	mov	r8,0
8000893c:	f0 09 18 00 	cp.b	r9,r8
80008940:	e0 80 0e aa 	breq	8000a694 <_vfprintf_r+0x1edc>
80008944:	30 09       	mov	r9,0
80008946:	fb 68 06 bb 	st.b	sp[1723],r8
8000894a:	0e 96       	mov	r6,r7
8000894c:	e4 c8 ff ff 	sub	r8,r2,-1
80008950:	3f fe       	mov	lr,-1
80008952:	50 93       	stdsp	sp[0x24],r3
80008954:	50 41       	stdsp	sp[0x10],r1
80008956:	0e 93       	mov	r3,r7
80008958:	04 91       	mov	r1,r2
8000895a:	50 89       	stdsp	sp[0x20],r9
8000895c:	50 a8       	stdsp	sp[0x28],r8
8000895e:	50 2e       	stdsp	sp[0x8],lr
80008960:	50 39       	stdsp	sp[0xc],r9
80008962:	12 95       	mov	r5,r9
80008964:	12 90       	mov	r0,r9
80008966:	10 97       	mov	r7,r8
80008968:	08 92       	mov	r2,r4
8000896a:	c0 78       	rjmp	80008978 <_vfprintf_r+0x1c0>
8000896c:	3f fc       	mov	r12,-1
8000896e:	08 97       	mov	r7,r4
80008970:	50 2c       	stdsp	sp[0x8],r12
80008972:	c0 38       	rjmp	80008978 <_vfprintf_r+0x1c0>
80008974:	30 0b       	mov	r11,0
80008976:	50 3b       	stdsp	sp[0xc],r11
80008978:	0f 38       	ld.ub	r8,r7++
8000897a:	c0 28       	rjmp	8000897e <_vfprintf_r+0x1c6>
8000897c:	12 90       	mov	r0,r9
8000897e:	f0 c9 00 20 	sub	r9,r8,32
80008982:	e0 49 00 58 	cp.w	r9,88
80008986:	e0 8b 0a 30 	brhi	80009de6 <_vfprintf_r+0x162e>
8000898a:	fe ca a4 f6 	sub	r10,pc,-23306
8000898e:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80008992:	50 a7       	stdsp	sp[0x28],r7
80008994:	50 80       	stdsp	sp[0x20],r0
80008996:	0c 97       	mov	r7,r6
80008998:	04 94       	mov	r4,r2
8000899a:	06 96       	mov	r6,r3
8000899c:	02 92       	mov	r2,r1
8000899e:	fe c9 a2 ce 	sub	r9,pc,-23858
800089a2:	40 93       	lddsp	r3,sp[0x24]
800089a4:	10 90       	mov	r0,r8
800089a6:	40 41       	lddsp	r1,sp[0x10]
800089a8:	50 d9       	stdsp	sp[0x34],r9
800089aa:	e0 8f 08 8e 	bral	80009ac6 <_vfprintf_r+0x130e>
800089ae:	30 08       	mov	r8,0
800089b0:	fb 39 06 bb 	ld.ub	r9,sp[1723]
800089b4:	f0 09 18 00 	cp.b	r9,r8
800089b8:	ce 01       	brne	80008978 <_vfprintf_r+0x1c0>
800089ba:	32 08       	mov	r8,32
800089bc:	c6 e8       	rjmp	80008a98 <_vfprintf_r+0x2e0>
800089be:	a1 a5       	sbr	r5,0x0
800089c0:	cd cb       	rjmp	80008978 <_vfprintf_r+0x1c0>
800089c2:	0f 89       	ld.ub	r9,r7[0x0]
800089c4:	f2 c8 00 30 	sub	r8,r9,48
800089c8:	58 98       	cp.w	r8,9
800089ca:	e0 8b 00 1d 	brhi	80008a04 <_vfprintf_r+0x24c>
800089ce:	ee c8 ff ff 	sub	r8,r7,-1
800089d2:	30 0b       	mov	r11,0
800089d4:	23 09       	sub	r9,48
800089d6:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800089da:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
800089de:	11 39       	ld.ub	r9,r8++
800089e0:	f2 ca 00 30 	sub	r10,r9,48
800089e4:	58 9a       	cp.w	r10,9
800089e6:	fe 98 ff f7 	brls	800089d4 <_vfprintf_r+0x21c>
800089ea:	e0 49 00 24 	cp.w	r9,36
800089ee:	cc 31       	brne	80008974 <_vfprintf_r+0x1bc>
800089f0:	e0 4b 00 20 	cp.w	r11,32
800089f4:	e0 89 0e 60 	brgt	8000a6b4 <_vfprintf_r+0x1efc>
800089f8:	20 1b       	sub	r11,1
800089fa:	fa f9 06 b4 	ld.w	r9,sp[1716]
800089fe:	12 3b       	cp.w	r11,r9
80008a00:	c0 95       	brlt	80008a12 <_vfprintf_r+0x25a>
80008a02:	c1 08       	rjmp	80008a22 <_vfprintf_r+0x26a>
80008a04:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008a08:	ec ca ff ff 	sub	r10,r6,-1
80008a0c:	12 36       	cp.w	r6,r9
80008a0e:	c1 f5       	brlt	80008a4c <_vfprintf_r+0x294>
80008a10:	c2 68       	rjmp	80008a5c <_vfprintf_r+0x2a4>
80008a12:	fa ce f9 44 	sub	lr,sp,-1724
80008a16:	10 97       	mov	r7,r8
80008a18:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80008a1c:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80008a20:	c3 58       	rjmp	80008a8a <_vfprintf_r+0x2d2>
80008a22:	10 97       	mov	r7,r8
80008a24:	fa c8 f9 50 	sub	r8,sp,-1712
80008a28:	1a d8       	st.w	--sp,r8
80008a2a:	fa c8 fa b8 	sub	r8,sp,-1352
80008a2e:	1a d8       	st.w	--sp,r8
80008a30:	fa c8 fb b4 	sub	r8,sp,-1100
80008a34:	02 9a       	mov	r10,r1
80008a36:	1a d8       	st.w	--sp,r8
80008a38:	04 9c       	mov	r12,r2
80008a3a:	fa c8 f9 40 	sub	r8,sp,-1728
80008a3e:	fa c9 ff b4 	sub	r9,sp,-76
80008a42:	fe b0 fd 23 	rcall	80008488 <get_arg>
80008a46:	2f dd       	sub	sp,-12
80008a48:	78 00       	ld.w	r0,r12[0x0]
80008a4a:	c2 08       	rjmp	80008a8a <_vfprintf_r+0x2d2>
80008a4c:	fa cc f9 44 	sub	r12,sp,-1724
80008a50:	14 96       	mov	r6,r10
80008a52:	f8 03 00 38 	add	r8,r12,r3<<0x3
80008a56:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80008a5a:	c1 88       	rjmp	80008a8a <_vfprintf_r+0x2d2>
80008a5c:	41 08       	lddsp	r8,sp[0x40]
80008a5e:	59 f9       	cp.w	r9,31
80008a60:	e0 89 00 11 	brgt	80008a82 <_vfprintf_r+0x2ca>
80008a64:	f0 cb ff fc 	sub	r11,r8,-4
80008a68:	51 0b       	stdsp	sp[0x40],r11
80008a6a:	70 00       	ld.w	r0,r8[0x0]
80008a6c:	fa cb f9 44 	sub	r11,sp,-1724
80008a70:	f6 09 00 38 	add	r8,r11,r9<<0x3
80008a74:	f1 40 fd 88 	st.w	r8[-632],r0
80008a78:	2f f9       	sub	r9,-1
80008a7a:	14 96       	mov	r6,r10
80008a7c:	fb 49 06 b4 	st.w	sp[1716],r9
80008a80:	c0 58       	rjmp	80008a8a <_vfprintf_r+0x2d2>
80008a82:	70 00       	ld.w	r0,r8[0x0]
80008a84:	14 96       	mov	r6,r10
80008a86:	2f c8       	sub	r8,-4
80008a88:	51 08       	stdsp	sp[0x40],r8
80008a8a:	58 00       	cp.w	r0,0
80008a8c:	fe 94 ff 76 	brge	80008978 <_vfprintf_r+0x1c0>
80008a90:	5c 30       	neg	r0
80008a92:	a3 a5       	sbr	r5,0x2
80008a94:	c7 2b       	rjmp	80008978 <_vfprintf_r+0x1c0>
80008a96:	32 b8       	mov	r8,43
80008a98:	fb 68 06 bb 	st.b	sp[1723],r8
80008a9c:	c6 eb       	rjmp	80008978 <_vfprintf_r+0x1c0>
80008a9e:	0f 38       	ld.ub	r8,r7++
80008aa0:	e0 48 00 2a 	cp.w	r8,42
80008aa4:	c0 30       	breq	80008aaa <_vfprintf_r+0x2f2>
80008aa6:	30 09       	mov	r9,0
80008aa8:	c7 98       	rjmp	80008b9a <_vfprintf_r+0x3e2>
80008aaa:	0f 88       	ld.ub	r8,r7[0x0]
80008aac:	f0 c9 00 30 	sub	r9,r8,48
80008ab0:	58 99       	cp.w	r9,9
80008ab2:	e0 8b 00 1f 	brhi	80008af0 <_vfprintf_r+0x338>
80008ab6:	ee c4 ff ff 	sub	r4,r7,-1
80008aba:	30 0b       	mov	r11,0
80008abc:	23 08       	sub	r8,48
80008abe:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008ac2:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80008ac6:	09 38       	ld.ub	r8,r4++
80008ac8:	f0 c9 00 30 	sub	r9,r8,48
80008acc:	58 99       	cp.w	r9,9
80008ace:	fe 98 ff f7 	brls	80008abc <_vfprintf_r+0x304>
80008ad2:	e0 48 00 24 	cp.w	r8,36
80008ad6:	fe 91 ff 4f 	brne	80008974 <_vfprintf_r+0x1bc>
80008ada:	e0 4b 00 20 	cp.w	r11,32
80008ade:	e0 89 0d eb 	brgt	8000a6b4 <_vfprintf_r+0x1efc>
80008ae2:	20 1b       	sub	r11,1
80008ae4:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ae8:	10 3b       	cp.w	r11,r8
80008aea:	c0 a5       	brlt	80008afe <_vfprintf_r+0x346>
80008aec:	c1 18       	rjmp	80008b0e <_vfprintf_r+0x356>
80008aee:	d7 03       	nop
80008af0:	fa fa 06 b4 	ld.w	r10,sp[1716]
80008af4:	ec c9 ff ff 	sub	r9,r6,-1
80008af8:	14 36       	cp.w	r6,r10
80008afa:	c1 f5       	brlt	80008b38 <_vfprintf_r+0x380>
80008afc:	c2 88       	rjmp	80008b4c <_vfprintf_r+0x394>
80008afe:	fa ca f9 44 	sub	r10,sp,-1724
80008b02:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80008b06:	f6 fb fd 88 	ld.w	r11,r11[-632]
80008b0a:	50 2b       	stdsp	sp[0x8],r11
80008b0c:	c3 c8       	rjmp	80008b84 <_vfprintf_r+0x3cc>
80008b0e:	fa c8 f9 50 	sub	r8,sp,-1712
80008b12:	1a d8       	st.w	--sp,r8
80008b14:	fa c8 fa b8 	sub	r8,sp,-1352
80008b18:	1a d8       	st.w	--sp,r8
80008b1a:	fa c8 fb b4 	sub	r8,sp,-1100
80008b1e:	02 9a       	mov	r10,r1
80008b20:	1a d8       	st.w	--sp,r8
80008b22:	04 9c       	mov	r12,r2
80008b24:	fa c8 f9 40 	sub	r8,sp,-1728
80008b28:	fa c9 ff b4 	sub	r9,sp,-76
80008b2c:	fe b0 fc ae 	rcall	80008488 <get_arg>
80008b30:	2f dd       	sub	sp,-12
80008b32:	78 0c       	ld.w	r12,r12[0x0]
80008b34:	50 2c       	stdsp	sp[0x8],r12
80008b36:	c2 78       	rjmp	80008b84 <_vfprintf_r+0x3cc>
80008b38:	12 96       	mov	r6,r9
80008b3a:	0e 94       	mov	r4,r7
80008b3c:	fa c9 f9 44 	sub	r9,sp,-1724
80008b40:	f2 03 00 38 	add	r8,r9,r3<<0x3
80008b44:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80008b48:	50 28       	stdsp	sp[0x8],r8
80008b4a:	c1 d8       	rjmp	80008b84 <_vfprintf_r+0x3cc>
80008b4c:	41 08       	lddsp	r8,sp[0x40]
80008b4e:	59 fa       	cp.w	r10,31
80008b50:	e0 89 00 14 	brgt	80008b78 <_vfprintf_r+0x3c0>
80008b54:	f0 cb ff fc 	sub	r11,r8,-4
80008b58:	70 08       	ld.w	r8,r8[0x0]
80008b5a:	51 0b       	stdsp	sp[0x40],r11
80008b5c:	50 28       	stdsp	sp[0x8],r8
80008b5e:	fa c6 f9 44 	sub	r6,sp,-1724
80008b62:	40 2e       	lddsp	lr,sp[0x8]
80008b64:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80008b68:	f1 4e fd 88 	st.w	r8[-632],lr
80008b6c:	2f fa       	sub	r10,-1
80008b6e:	0e 94       	mov	r4,r7
80008b70:	fb 4a 06 b4 	st.w	sp[1716],r10
80008b74:	12 96       	mov	r6,r9
80008b76:	c0 78       	rjmp	80008b84 <_vfprintf_r+0x3cc>
80008b78:	70 0c       	ld.w	r12,r8[0x0]
80008b7a:	0e 94       	mov	r4,r7
80008b7c:	2f c8       	sub	r8,-4
80008b7e:	50 2c       	stdsp	sp[0x8],r12
80008b80:	12 96       	mov	r6,r9
80008b82:	51 08       	stdsp	sp[0x40],r8
80008b84:	40 2b       	lddsp	r11,sp[0x8]
80008b86:	58 0b       	cp.w	r11,0
80008b88:	fe 95 fe f2 	brlt	8000896c <_vfprintf_r+0x1b4>
80008b8c:	08 97       	mov	r7,r4
80008b8e:	cf 5a       	rjmp	80008978 <_vfprintf_r+0x1c0>
80008b90:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008b94:	0f 38       	ld.ub	r8,r7++
80008b96:	f4 09 00 19 	add	r9,r10,r9<<0x1
80008b9a:	f0 ca 00 30 	sub	r10,r8,48
80008b9e:	58 9a       	cp.w	r10,9
80008ba0:	fe 98 ff f8 	brls	80008b90 <_vfprintf_r+0x3d8>
80008ba4:	3f fa       	mov	r10,-1
80008ba6:	f2 0a 0c 49 	max	r9,r9,r10
80008baa:	50 29       	stdsp	sp[0x8],r9
80008bac:	ce 9a       	rjmp	8000897e <_vfprintf_r+0x1c6>
80008bae:	a7 b5       	sbr	r5,0x7
80008bb0:	ce 4a       	rjmp	80008978 <_vfprintf_r+0x1c0>
80008bb2:	30 09       	mov	r9,0
80008bb4:	23 08       	sub	r8,48
80008bb6:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008bba:	f0 09 00 19 	add	r9,r8,r9<<0x1
80008bbe:	0f 38       	ld.ub	r8,r7++
80008bc0:	f0 ca 00 30 	sub	r10,r8,48
80008bc4:	58 9a       	cp.w	r10,9
80008bc6:	fe 98 ff f7 	brls	80008bb4 <_vfprintf_r+0x3fc>
80008bca:	e0 48 00 24 	cp.w	r8,36
80008bce:	fe 91 fe d7 	brne	8000897c <_vfprintf_r+0x1c4>
80008bd2:	e0 49 00 20 	cp.w	r9,32
80008bd6:	e0 89 0d 6f 	brgt	8000a6b4 <_vfprintf_r+0x1efc>
80008bda:	f2 c3 00 01 	sub	r3,r9,1
80008bde:	30 19       	mov	r9,1
80008be0:	50 39       	stdsp	sp[0xc],r9
80008be2:	cc ba       	rjmp	80008978 <_vfprintf_r+0x1c0>
80008be4:	a3 b5       	sbr	r5,0x3
80008be6:	cc 9a       	rjmp	80008978 <_vfprintf_r+0x1c0>
80008be8:	a7 a5       	sbr	r5,0x6
80008bea:	cc 7a       	rjmp	80008978 <_vfprintf_r+0x1c0>
80008bec:	0a 98       	mov	r8,r5
80008bee:	a5 b5       	sbr	r5,0x5
80008bf0:	a5 a8       	sbr	r8,0x4
80008bf2:	0f 89       	ld.ub	r9,r7[0x0]
80008bf4:	36 ce       	mov	lr,108
80008bf6:	fc 09 18 00 	cp.b	r9,lr
80008bfa:	f7 b7 00 ff 	subeq	r7,-1
80008bfe:	f0 05 17 10 	movne	r5,r8
80008c02:	cb ba       	rjmp	80008978 <_vfprintf_r+0x1c0>
80008c04:	a5 b5       	sbr	r5,0x5
80008c06:	cb 9a       	rjmp	80008978 <_vfprintf_r+0x1c0>
80008c08:	50 a7       	stdsp	sp[0x28],r7
80008c0a:	50 80       	stdsp	sp[0x20],r0
80008c0c:	0c 97       	mov	r7,r6
80008c0e:	10 90       	mov	r0,r8
80008c10:	06 96       	mov	r6,r3
80008c12:	04 94       	mov	r4,r2
80008c14:	40 93       	lddsp	r3,sp[0x24]
80008c16:	02 92       	mov	r2,r1
80008c18:	0e 99       	mov	r9,r7
80008c1a:	40 41       	lddsp	r1,sp[0x10]
80008c1c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c20:	40 3c       	lddsp	r12,sp[0xc]
80008c22:	58 0c       	cp.w	r12,0
80008c24:	c1 d0       	breq	80008c5e <_vfprintf_r+0x4a6>
80008c26:	10 36       	cp.w	r6,r8
80008c28:	c0 64       	brge	80008c34 <_vfprintf_r+0x47c>
80008c2a:	fa cb f9 44 	sub	r11,sp,-1724
80008c2e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c32:	c1 d8       	rjmp	80008c6c <_vfprintf_r+0x4b4>
80008c34:	fa c8 f9 50 	sub	r8,sp,-1712
80008c38:	1a d8       	st.w	--sp,r8
80008c3a:	fa c8 fa b8 	sub	r8,sp,-1352
80008c3e:	1a d8       	st.w	--sp,r8
80008c40:	fa c8 fb b4 	sub	r8,sp,-1100
80008c44:	1a d8       	st.w	--sp,r8
80008c46:	fa c8 f9 40 	sub	r8,sp,-1728
80008c4a:	fa c9 ff b4 	sub	r9,sp,-76
80008c4e:	04 9a       	mov	r10,r2
80008c50:	0c 9b       	mov	r11,r6
80008c52:	08 9c       	mov	r12,r4
80008c54:	fe b0 fc 1a 	rcall	80008488 <get_arg>
80008c58:	2f dd       	sub	sp,-12
80008c5a:	19 b8       	ld.ub	r8,r12[0x3]
80008c5c:	c2 28       	rjmp	80008ca0 <_vfprintf_r+0x4e8>
80008c5e:	2f f7       	sub	r7,-1
80008c60:	10 39       	cp.w	r9,r8
80008c62:	c0 84       	brge	80008c72 <_vfprintf_r+0x4ba>
80008c64:	fa ca f9 44 	sub	r10,sp,-1724
80008c68:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008c6c:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80008c70:	c1 88       	rjmp	80008ca0 <_vfprintf_r+0x4e8>
80008c72:	41 09       	lddsp	r9,sp[0x40]
80008c74:	59 f8       	cp.w	r8,31
80008c76:	e0 89 00 12 	brgt	80008c9a <_vfprintf_r+0x4e2>
80008c7a:	f2 ca ff fc 	sub	r10,r9,-4
80008c7e:	51 0a       	stdsp	sp[0x40],r10
80008c80:	72 09       	ld.w	r9,r9[0x0]
80008c82:	fa c6 f9 44 	sub	r6,sp,-1724
80008c86:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008c8a:	2f f8       	sub	r8,-1
80008c8c:	f5 49 fd 88 	st.w	r10[-632],r9
80008c90:	fb 48 06 b4 	st.w	sp[1716],r8
80008c94:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80008c98:	c0 48       	rjmp	80008ca0 <_vfprintf_r+0x4e8>
80008c9a:	13 b8       	ld.ub	r8,r9[0x3]
80008c9c:	2f c9       	sub	r9,-4
80008c9e:	51 09       	stdsp	sp[0x40],r9
80008ca0:	fb 68 06 60 	st.b	sp[1632],r8
80008ca4:	30 0e       	mov	lr,0
80008ca6:	30 08       	mov	r8,0
80008ca8:	30 12       	mov	r2,1
80008caa:	fb 68 06 bb 	st.b	sp[1723],r8
80008cae:	50 2e       	stdsp	sp[0x8],lr
80008cb0:	e0 8f 08 ad 	bral	80009e0a <_vfprintf_r+0x1652>
80008cb4:	50 a7       	stdsp	sp[0x28],r7
80008cb6:	50 80       	stdsp	sp[0x20],r0
80008cb8:	0c 97       	mov	r7,r6
80008cba:	04 94       	mov	r4,r2
80008cbc:	06 96       	mov	r6,r3
80008cbe:	02 92       	mov	r2,r1
80008cc0:	40 93       	lddsp	r3,sp[0x24]
80008cc2:	10 90       	mov	r0,r8
80008cc4:	40 41       	lddsp	r1,sp[0x10]
80008cc6:	a5 a5       	sbr	r5,0x4
80008cc8:	c0 a8       	rjmp	80008cdc <_vfprintf_r+0x524>
80008cca:	50 a7       	stdsp	sp[0x28],r7
80008ccc:	50 80       	stdsp	sp[0x20],r0
80008cce:	0c 97       	mov	r7,r6
80008cd0:	04 94       	mov	r4,r2
80008cd2:	06 96       	mov	r6,r3
80008cd4:	02 92       	mov	r2,r1
80008cd6:	40 93       	lddsp	r3,sp[0x24]
80008cd8:	10 90       	mov	r0,r8
80008cda:	40 41       	lddsp	r1,sp[0x10]
80008cdc:	ed b5 00 05 	bld	r5,0x5
80008ce0:	c5 11       	brne	80008d82 <_vfprintf_r+0x5ca>
80008ce2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ce6:	40 3c       	lddsp	r12,sp[0xc]
80008ce8:	58 0c       	cp.w	r12,0
80008cea:	c1 e0       	breq	80008d26 <_vfprintf_r+0x56e>
80008cec:	10 36       	cp.w	r6,r8
80008cee:	c0 64       	brge	80008cfa <_vfprintf_r+0x542>
80008cf0:	fa cb f9 44 	sub	r11,sp,-1724
80008cf4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008cf8:	c2 08       	rjmp	80008d38 <_vfprintf_r+0x580>
80008cfa:	fa c8 f9 50 	sub	r8,sp,-1712
80008cfe:	1a d8       	st.w	--sp,r8
80008d00:	fa c8 fa b8 	sub	r8,sp,-1352
80008d04:	0c 9b       	mov	r11,r6
80008d06:	1a d8       	st.w	--sp,r8
80008d08:	fa c8 fb b4 	sub	r8,sp,-1100
80008d0c:	1a d8       	st.w	--sp,r8
80008d0e:	fa c9 ff b4 	sub	r9,sp,-76
80008d12:	fa c8 f9 40 	sub	r8,sp,-1728
80008d16:	04 9a       	mov	r10,r2
80008d18:	08 9c       	mov	r12,r4
80008d1a:	fe b0 fb b7 	rcall	80008488 <get_arg>
80008d1e:	2f dd       	sub	sp,-12
80008d20:	78 1b       	ld.w	r11,r12[0x4]
80008d22:	78 09       	ld.w	r9,r12[0x0]
80008d24:	c2 b8       	rjmp	80008d7a <_vfprintf_r+0x5c2>
80008d26:	ee ca ff ff 	sub	r10,r7,-1
80008d2a:	10 37       	cp.w	r7,r8
80008d2c:	c0 b4       	brge	80008d42 <_vfprintf_r+0x58a>
80008d2e:	fa c9 f9 44 	sub	r9,sp,-1724
80008d32:	14 97       	mov	r7,r10
80008d34:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008d38:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008d3c:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008d40:	c1 d8       	rjmp	80008d7a <_vfprintf_r+0x5c2>
80008d42:	41 09       	lddsp	r9,sp[0x40]
80008d44:	59 f8       	cp.w	r8,31
80008d46:	e0 89 00 14 	brgt	80008d6e <_vfprintf_r+0x5b6>
80008d4a:	f2 cb ff f8 	sub	r11,r9,-8
80008d4e:	51 0b       	stdsp	sp[0x40],r11
80008d50:	fa c6 f9 44 	sub	r6,sp,-1724
80008d54:	72 1b       	ld.w	r11,r9[0x4]
80008d56:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80008d5a:	72 09       	ld.w	r9,r9[0x0]
80008d5c:	f9 4b fd 8c 	st.w	r12[-628],r11
80008d60:	f9 49 fd 88 	st.w	r12[-632],r9
80008d64:	2f f8       	sub	r8,-1
80008d66:	14 97       	mov	r7,r10
80008d68:	fb 48 06 b4 	st.w	sp[1716],r8
80008d6c:	c0 78       	rjmp	80008d7a <_vfprintf_r+0x5c2>
80008d6e:	f2 c8 ff f8 	sub	r8,r9,-8
80008d72:	72 1b       	ld.w	r11,r9[0x4]
80008d74:	14 97       	mov	r7,r10
80008d76:	51 08       	stdsp	sp[0x40],r8
80008d78:	72 09       	ld.w	r9,r9[0x0]
80008d7a:	16 98       	mov	r8,r11
80008d7c:	fa e9 00 00 	st.d	sp[0],r8
80008d80:	ca e8       	rjmp	80008edc <_vfprintf_r+0x724>
80008d82:	ed b5 00 04 	bld	r5,0x4
80008d86:	c1 71       	brne	80008db4 <_vfprintf_r+0x5fc>
80008d88:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d8c:	40 3e       	lddsp	lr,sp[0xc]
80008d8e:	58 0e       	cp.w	lr,0
80008d90:	c0 80       	breq	80008da0 <_vfprintf_r+0x5e8>
80008d92:	10 36       	cp.w	r6,r8
80008d94:	c6 94       	brge	80008e66 <_vfprintf_r+0x6ae>
80008d96:	fa cc f9 44 	sub	r12,sp,-1724
80008d9a:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008d9e:	c8 28       	rjmp	80008ea2 <_vfprintf_r+0x6ea>
80008da0:	ee ca ff ff 	sub	r10,r7,-1
80008da4:	10 37       	cp.w	r7,r8
80008da6:	e0 84 00 81 	brge	80008ea8 <_vfprintf_r+0x6f0>
80008daa:	fa cb f9 44 	sub	r11,sp,-1724
80008dae:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008db2:	c7 78       	rjmp	80008ea0 <_vfprintf_r+0x6e8>
80008db4:	ed b5 00 06 	bld	r5,0x6
80008db8:	c4 b1       	brne	80008e4e <_vfprintf_r+0x696>
80008dba:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008dbe:	40 3c       	lddsp	r12,sp[0xc]
80008dc0:	58 0c       	cp.w	r12,0
80008dc2:	c1 d0       	breq	80008dfc <_vfprintf_r+0x644>
80008dc4:	10 36       	cp.w	r6,r8
80008dc6:	c0 64       	brge	80008dd2 <_vfprintf_r+0x61a>
80008dc8:	fa cb f9 44 	sub	r11,sp,-1724
80008dcc:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008dd0:	c1 f8       	rjmp	80008e0e <_vfprintf_r+0x656>
80008dd2:	fa c8 f9 50 	sub	r8,sp,-1712
80008dd6:	1a d8       	st.w	--sp,r8
80008dd8:	fa c8 fa b8 	sub	r8,sp,-1352
80008ddc:	1a d8       	st.w	--sp,r8
80008dde:	fa c8 fb b4 	sub	r8,sp,-1100
80008de2:	1a d8       	st.w	--sp,r8
80008de4:	fa c8 f9 40 	sub	r8,sp,-1728
80008de8:	fa c9 ff b4 	sub	r9,sp,-76
80008dec:	04 9a       	mov	r10,r2
80008dee:	0c 9b       	mov	r11,r6
80008df0:	08 9c       	mov	r12,r4
80008df2:	fe b0 fb 4b 	rcall	80008488 <get_arg>
80008df6:	2f dd       	sub	sp,-12
80008df8:	98 18       	ld.sh	r8,r12[0x2]
80008dfa:	c2 68       	rjmp	80008e46 <_vfprintf_r+0x68e>
80008dfc:	ee ca ff ff 	sub	r10,r7,-1
80008e00:	10 37       	cp.w	r7,r8
80008e02:	c0 94       	brge	80008e14 <_vfprintf_r+0x65c>
80008e04:	fa c9 f9 44 	sub	r9,sp,-1724
80008e08:	14 97       	mov	r7,r10
80008e0a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008e0e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008e12:	c1 a8       	rjmp	80008e46 <_vfprintf_r+0x68e>
80008e14:	41 09       	lddsp	r9,sp[0x40]
80008e16:	59 f8       	cp.w	r8,31
80008e18:	e0 89 00 13 	brgt	80008e3e <_vfprintf_r+0x686>
80008e1c:	f2 cb ff fc 	sub	r11,r9,-4
80008e20:	51 0b       	stdsp	sp[0x40],r11
80008e22:	72 09       	ld.w	r9,r9[0x0]
80008e24:	fa c6 f9 44 	sub	r6,sp,-1724
80008e28:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008e2c:	2f f8       	sub	r8,-1
80008e2e:	f7 49 fd 88 	st.w	r11[-632],r9
80008e32:	fb 48 06 b4 	st.w	sp[1716],r8
80008e36:	14 97       	mov	r7,r10
80008e38:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008e3c:	c0 58       	rjmp	80008e46 <_vfprintf_r+0x68e>
80008e3e:	92 18       	ld.sh	r8,r9[0x2]
80008e40:	14 97       	mov	r7,r10
80008e42:	2f c9       	sub	r9,-4
80008e44:	51 09       	stdsp	sp[0x40],r9
80008e46:	50 18       	stdsp	sp[0x4],r8
80008e48:	bf 58       	asr	r8,0x1f
80008e4a:	50 08       	stdsp	sp[0x0],r8
80008e4c:	c4 88       	rjmp	80008edc <_vfprintf_r+0x724>
80008e4e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e52:	40 3c       	lddsp	r12,sp[0xc]
80008e54:	58 0c       	cp.w	r12,0
80008e56:	c1 d0       	breq	80008e90 <_vfprintf_r+0x6d8>
80008e58:	10 36       	cp.w	r6,r8
80008e5a:	c0 64       	brge	80008e66 <_vfprintf_r+0x6ae>
80008e5c:	fa cb f9 44 	sub	r11,sp,-1724
80008e60:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e64:	c1 f8       	rjmp	80008ea2 <_vfprintf_r+0x6ea>
80008e66:	fa c8 f9 50 	sub	r8,sp,-1712
80008e6a:	1a d8       	st.w	--sp,r8
80008e6c:	fa c8 fa b8 	sub	r8,sp,-1352
80008e70:	0c 9b       	mov	r11,r6
80008e72:	1a d8       	st.w	--sp,r8
80008e74:	fa c8 fb b4 	sub	r8,sp,-1100
80008e78:	04 9a       	mov	r10,r2
80008e7a:	1a d8       	st.w	--sp,r8
80008e7c:	08 9c       	mov	r12,r4
80008e7e:	fa c8 f9 40 	sub	r8,sp,-1728
80008e82:	fa c9 ff b4 	sub	r9,sp,-76
80008e86:	fe b0 fb 01 	rcall	80008488 <get_arg>
80008e8a:	2f dd       	sub	sp,-12
80008e8c:	78 0b       	ld.w	r11,r12[0x0]
80008e8e:	c2 48       	rjmp	80008ed6 <_vfprintf_r+0x71e>
80008e90:	ee ca ff ff 	sub	r10,r7,-1
80008e94:	10 37       	cp.w	r7,r8
80008e96:	c0 94       	brge	80008ea8 <_vfprintf_r+0x6f0>
80008e98:	fa c9 f9 44 	sub	r9,sp,-1724
80008e9c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008ea0:	14 97       	mov	r7,r10
80008ea2:	ec fb fd 88 	ld.w	r11,r6[-632]
80008ea6:	c1 88       	rjmp	80008ed6 <_vfprintf_r+0x71e>
80008ea8:	41 09       	lddsp	r9,sp[0x40]
80008eaa:	59 f8       	cp.w	r8,31
80008eac:	e0 89 00 11 	brgt	80008ece <_vfprintf_r+0x716>
80008eb0:	f2 cb ff fc 	sub	r11,r9,-4
80008eb4:	51 0b       	stdsp	sp[0x40],r11
80008eb6:	fa c6 f9 44 	sub	r6,sp,-1724
80008eba:	72 0b       	ld.w	r11,r9[0x0]
80008ebc:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008ec0:	f3 4b fd 88 	st.w	r9[-632],r11
80008ec4:	2f f8       	sub	r8,-1
80008ec6:	14 97       	mov	r7,r10
80008ec8:	fb 48 06 b4 	st.w	sp[1716],r8
80008ecc:	c0 58       	rjmp	80008ed6 <_vfprintf_r+0x71e>
80008ece:	72 0b       	ld.w	r11,r9[0x0]
80008ed0:	14 97       	mov	r7,r10
80008ed2:	2f c9       	sub	r9,-4
80008ed4:	51 09       	stdsp	sp[0x40],r9
80008ed6:	50 1b       	stdsp	sp[0x4],r11
80008ed8:	bf 5b       	asr	r11,0x1f
80008eda:	50 0b       	stdsp	sp[0x0],r11
80008edc:	fa ea 00 00 	ld.d	r10,sp[0]
80008ee0:	58 0a       	cp.w	r10,0
80008ee2:	5c 2b       	cpc	r11
80008ee4:	c0 e4       	brge	80008f00 <_vfprintf_r+0x748>
80008ee6:	30 08       	mov	r8,0
80008ee8:	fa ea 00 00 	ld.d	r10,sp[0]
80008eec:	30 09       	mov	r9,0
80008eee:	f0 0a 01 0a 	sub	r10,r8,r10
80008ef2:	f2 0b 01 4b 	sbc	r11,r9,r11
80008ef6:	32 d8       	mov	r8,45
80008ef8:	fa eb 00 00 	st.d	sp[0],r10
80008efc:	fb 68 06 bb 	st.b	sp[1723],r8
80008f00:	30 18       	mov	r8,1
80008f02:	e0 8f 06 fa 	bral	80009cf6 <_vfprintf_r+0x153e>
80008f06:	50 a7       	stdsp	sp[0x28],r7
80008f08:	50 80       	stdsp	sp[0x20],r0
80008f0a:	0c 97       	mov	r7,r6
80008f0c:	04 94       	mov	r4,r2
80008f0e:	06 96       	mov	r6,r3
80008f10:	02 92       	mov	r2,r1
80008f12:	40 93       	lddsp	r3,sp[0x24]
80008f14:	10 90       	mov	r0,r8
80008f16:	40 41       	lddsp	r1,sp[0x10]
80008f18:	0e 99       	mov	r9,r7
80008f1a:	ed b5 00 03 	bld	r5,0x3
80008f1e:	c4 11       	brne	80008fa0 <_vfprintf_r+0x7e8>
80008f20:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f24:	40 3a       	lddsp	r10,sp[0xc]
80008f26:	58 0a       	cp.w	r10,0
80008f28:	c1 90       	breq	80008f5a <_vfprintf_r+0x7a2>
80008f2a:	10 36       	cp.w	r6,r8
80008f2c:	c6 45       	brlt	80008ff4 <_vfprintf_r+0x83c>
80008f2e:	fa c8 f9 50 	sub	r8,sp,-1712
80008f32:	1a d8       	st.w	--sp,r8
80008f34:	fa c8 fa b8 	sub	r8,sp,-1352
80008f38:	1a d8       	st.w	--sp,r8
80008f3a:	fa c8 fb b4 	sub	r8,sp,-1100
80008f3e:	0c 9b       	mov	r11,r6
80008f40:	1a d8       	st.w	--sp,r8
80008f42:	04 9a       	mov	r10,r2
80008f44:	fa c8 f9 40 	sub	r8,sp,-1728
80008f48:	fa c9 ff b4 	sub	r9,sp,-76
80008f4c:	08 9c       	mov	r12,r4
80008f4e:	fe b0 fa 9d 	rcall	80008488 <get_arg>
80008f52:	2f dd       	sub	sp,-12
80008f54:	78 16       	ld.w	r6,r12[0x4]
80008f56:	50 76       	stdsp	sp[0x1c],r6
80008f58:	c4 88       	rjmp	80008fe8 <_vfprintf_r+0x830>
80008f5a:	2f f7       	sub	r7,-1
80008f5c:	10 39       	cp.w	r9,r8
80008f5e:	c0 c4       	brge	80008f76 <_vfprintf_r+0x7be>
80008f60:	fa ce f9 44 	sub	lr,sp,-1724
80008f64:	fc 06 00 36 	add	r6,lr,r6<<0x3
80008f68:	ec fc fd 8c 	ld.w	r12,r6[-628]
80008f6c:	50 7c       	stdsp	sp[0x1c],r12
80008f6e:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008f72:	50 56       	stdsp	sp[0x14],r6
80008f74:	c6 68       	rjmp	80009040 <_vfprintf_r+0x888>
80008f76:	41 09       	lddsp	r9,sp[0x40]
80008f78:	59 f8       	cp.w	r8,31
80008f7a:	e0 89 00 10 	brgt	80008f9a <_vfprintf_r+0x7e2>
80008f7e:	f2 ca ff f8 	sub	r10,r9,-8
80008f82:	72 1b       	ld.w	r11,r9[0x4]
80008f84:	51 0a       	stdsp	sp[0x40],r10
80008f86:	72 09       	ld.w	r9,r9[0x0]
80008f88:	fa ca f9 44 	sub	r10,sp,-1724
80008f8c:	50 7b       	stdsp	sp[0x1c],r11
80008f8e:	50 59       	stdsp	sp[0x14],r9
80008f90:	f4 08 00 39 	add	r9,r10,r8<<0x3
80008f94:	40 5b       	lddsp	r11,sp[0x14]
80008f96:	40 7a       	lddsp	r10,sp[0x1c]
80008f98:	c4 78       	rjmp	80009026 <_vfprintf_r+0x86e>
80008f9a:	72 18       	ld.w	r8,r9[0x4]
80008f9c:	50 78       	stdsp	sp[0x1c],r8
80008f9e:	c4 c8       	rjmp	80009036 <_vfprintf_r+0x87e>
80008fa0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008fa4:	40 3e       	lddsp	lr,sp[0xc]
80008fa6:	58 0e       	cp.w	lr,0
80008fa8:	c2 30       	breq	80008fee <_vfprintf_r+0x836>
80008faa:	10 36       	cp.w	r6,r8
80008fac:	c0 94       	brge	80008fbe <_vfprintf_r+0x806>
80008fae:	fa cc f9 44 	sub	r12,sp,-1724
80008fb2:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008fb6:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008fba:	50 7b       	stdsp	sp[0x1c],r11
80008fbc:	cd 9b       	rjmp	80008f6e <_vfprintf_r+0x7b6>
80008fbe:	fa c8 f9 50 	sub	r8,sp,-1712
80008fc2:	1a d8       	st.w	--sp,r8
80008fc4:	fa c8 fa b8 	sub	r8,sp,-1352
80008fc8:	04 9a       	mov	r10,r2
80008fca:	1a d8       	st.w	--sp,r8
80008fcc:	fa c8 fb b4 	sub	r8,sp,-1100
80008fd0:	0c 9b       	mov	r11,r6
80008fd2:	1a d8       	st.w	--sp,r8
80008fd4:	08 9c       	mov	r12,r4
80008fd6:	fa c8 f9 40 	sub	r8,sp,-1728
80008fda:	fa c9 ff b4 	sub	r9,sp,-76
80008fde:	fe b0 fa 55 	rcall	80008488 <get_arg>
80008fe2:	2f dd       	sub	sp,-12
80008fe4:	78 1a       	ld.w	r10,r12[0x4]
80008fe6:	50 7a       	stdsp	sp[0x1c],r10
80008fe8:	78 0c       	ld.w	r12,r12[0x0]
80008fea:	50 5c       	stdsp	sp[0x14],r12
80008fec:	c2 a8       	rjmp	80009040 <_vfprintf_r+0x888>
80008fee:	2f f7       	sub	r7,-1
80008ff0:	10 39       	cp.w	r9,r8
80008ff2:	c0 94       	brge	80009004 <_vfprintf_r+0x84c>
80008ff4:	fa c9 f9 44 	sub	r9,sp,-1724
80008ff8:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008ffc:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80009000:	50 78       	stdsp	sp[0x1c],r8
80009002:	cb 6b       	rjmp	80008f6e <_vfprintf_r+0x7b6>
80009004:	41 09       	lddsp	r9,sp[0x40]
80009006:	59 f8       	cp.w	r8,31
80009008:	e0 89 00 15 	brgt	80009032 <_vfprintf_r+0x87a>
8000900c:	f2 ca ff f8 	sub	r10,r9,-8
80009010:	72 16       	ld.w	r6,r9[0x4]
80009012:	72 09       	ld.w	r9,r9[0x0]
80009014:	51 0a       	stdsp	sp[0x40],r10
80009016:	50 59       	stdsp	sp[0x14],r9
80009018:	fa ce f9 44 	sub	lr,sp,-1724
8000901c:	50 76       	stdsp	sp[0x1c],r6
8000901e:	fc 08 00 39 	add	r9,lr,r8<<0x3
80009022:	40 5b       	lddsp	r11,sp[0x14]
80009024:	0c 9a       	mov	r10,r6
80009026:	f2 eb fd 88 	st.d	r9[-632],r10
8000902a:	2f f8       	sub	r8,-1
8000902c:	fb 48 06 b4 	st.w	sp[1716],r8
80009030:	c0 88       	rjmp	80009040 <_vfprintf_r+0x888>
80009032:	72 1c       	ld.w	r12,r9[0x4]
80009034:	50 7c       	stdsp	sp[0x1c],r12
80009036:	f2 c8 ff f8 	sub	r8,r9,-8
8000903a:	51 08       	stdsp	sp[0x40],r8
8000903c:	72 09       	ld.w	r9,r9[0x0]
8000903e:	50 59       	stdsp	sp[0x14],r9
80009040:	40 5b       	lddsp	r11,sp[0x14]
80009042:	40 7a       	lddsp	r10,sp[0x1c]
80009044:	e0 a0 19 54 	rcall	8000c2ec <__isinfd>
80009048:	18 96       	mov	r6,r12
8000904a:	c1 70       	breq	80009078 <_vfprintf_r+0x8c0>
8000904c:	30 08       	mov	r8,0
8000904e:	30 09       	mov	r9,0
80009050:	40 5b       	lddsp	r11,sp[0x14]
80009052:	40 7a       	lddsp	r10,sp[0x1c]
80009054:	e0 a0 1d b4 	rcall	8000cbbc <__avr32_f64_cmp_lt>
80009058:	c0 40       	breq	80009060 <_vfprintf_r+0x8a8>
8000905a:	32 d8       	mov	r8,45
8000905c:	fb 68 06 bb 	st.b	sp[1723],r8
80009060:	fe c8 a9 7c 	sub	r8,pc,-22148
80009064:	fe c6 a9 7c 	sub	r6,pc,-22148
80009068:	a7 d5       	cbr	r5,0x7
8000906a:	e0 40 00 47 	cp.w	r0,71
8000906e:	f0 06 17 a0 	movle	r6,r8
80009072:	30 32       	mov	r2,3
80009074:	e0 8f 06 ce 	bral	80009e10 <_vfprintf_r+0x1658>
80009078:	40 5b       	lddsp	r11,sp[0x14]
8000907a:	40 7a       	lddsp	r10,sp[0x1c]
8000907c:	e0 a0 19 4d 	rcall	8000c316 <__isnand>
80009080:	c0 e0       	breq	8000909c <_vfprintf_r+0x8e4>
80009082:	50 26       	stdsp	sp[0x8],r6
80009084:	fe c8 a9 98 	sub	r8,pc,-22120
80009088:	fe c6 a9 98 	sub	r6,pc,-22120
8000908c:	a7 d5       	cbr	r5,0x7
8000908e:	e0 40 00 47 	cp.w	r0,71
80009092:	f0 06 17 a0 	movle	r6,r8
80009096:	30 32       	mov	r2,3
80009098:	e0 8f 06 c2 	bral	80009e1c <_vfprintf_r+0x1664>
8000909c:	40 2a       	lddsp	r10,sp[0x8]
8000909e:	5b fa       	cp.w	r10,-1
800090a0:	c0 41       	brne	800090a8 <_vfprintf_r+0x8f0>
800090a2:	30 69       	mov	r9,6
800090a4:	50 29       	stdsp	sp[0x8],r9
800090a6:	c1 18       	rjmp	800090c8 <_vfprintf_r+0x910>
800090a8:	e0 40 00 47 	cp.w	r0,71
800090ac:	5f 09       	sreq	r9
800090ae:	e0 40 00 67 	cp.w	r0,103
800090b2:	5f 08       	sreq	r8
800090b4:	f3 e8 10 08 	or	r8,r9,r8
800090b8:	f8 08 18 00 	cp.b	r8,r12
800090bc:	c0 60       	breq	800090c8 <_vfprintf_r+0x910>
800090be:	40 28       	lddsp	r8,sp[0x8]
800090c0:	58 08       	cp.w	r8,0
800090c2:	f9 b8 00 01 	moveq	r8,1
800090c6:	50 28       	stdsp	sp[0x8],r8
800090c8:	40 78       	lddsp	r8,sp[0x1c]
800090ca:	40 59       	lddsp	r9,sp[0x14]
800090cc:	fa e9 06 94 	st.d	sp[1684],r8
800090d0:	a9 a5       	sbr	r5,0x8
800090d2:	fa f8 06 94 	ld.w	r8,sp[1684]
800090d6:	58 08       	cp.w	r8,0
800090d8:	c0 65       	brlt	800090e4 <_vfprintf_r+0x92c>
800090da:	40 5e       	lddsp	lr,sp[0x14]
800090dc:	30 0c       	mov	r12,0
800090de:	50 6e       	stdsp	sp[0x18],lr
800090e0:	50 9c       	stdsp	sp[0x24],r12
800090e2:	c0 78       	rjmp	800090f0 <_vfprintf_r+0x938>
800090e4:	40 5b       	lddsp	r11,sp[0x14]
800090e6:	32 da       	mov	r10,45
800090e8:	ee 1b 80 00 	eorh	r11,0x8000
800090ec:	50 9a       	stdsp	sp[0x24],r10
800090ee:	50 6b       	stdsp	sp[0x18],r11
800090f0:	e0 40 00 46 	cp.w	r0,70
800090f4:	5f 09       	sreq	r9
800090f6:	e0 40 00 66 	cp.w	r0,102
800090fa:	5f 08       	sreq	r8
800090fc:	f3 e8 10 08 	or	r8,r9,r8
80009100:	50 48       	stdsp	sp[0x10],r8
80009102:	c0 40       	breq	8000910a <_vfprintf_r+0x952>
80009104:	40 22       	lddsp	r2,sp[0x8]
80009106:	30 39       	mov	r9,3
80009108:	c1 08       	rjmp	80009128 <_vfprintf_r+0x970>
8000910a:	e0 40 00 45 	cp.w	r0,69
8000910e:	5f 09       	sreq	r9
80009110:	e0 40 00 65 	cp.w	r0,101
80009114:	5f 08       	sreq	r8
80009116:	40 22       	lddsp	r2,sp[0x8]
80009118:	10 49       	or	r9,r8
8000911a:	2f f2       	sub	r2,-1
8000911c:	40 46       	lddsp	r6,sp[0x10]
8000911e:	ec 09 18 00 	cp.b	r9,r6
80009122:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80009126:	30 29       	mov	r9,2
80009128:	fa c8 f9 5c 	sub	r8,sp,-1700
8000912c:	1a d8       	st.w	--sp,r8
8000912e:	fa c8 f9 54 	sub	r8,sp,-1708
80009132:	1a d8       	st.w	--sp,r8
80009134:	fa c8 f9 4c 	sub	r8,sp,-1716
80009138:	08 9c       	mov	r12,r4
8000913a:	1a d8       	st.w	--sp,r8
8000913c:	04 98       	mov	r8,r2
8000913e:	40 9b       	lddsp	r11,sp[0x24]
80009140:	40 aa       	lddsp	r10,sp[0x28]
80009142:	e0 a0 0b c3 	rcall	8000a8c8 <_dtoa_r>
80009146:	e0 40 00 47 	cp.w	r0,71
8000914a:	5f 19       	srne	r9
8000914c:	e0 40 00 67 	cp.w	r0,103
80009150:	5f 18       	srne	r8
80009152:	18 96       	mov	r6,r12
80009154:	2f dd       	sub	sp,-12
80009156:	f3 e8 00 08 	and	r8,r9,r8
8000915a:	c0 41       	brne	80009162 <_vfprintf_r+0x9aa>
8000915c:	ed b5 00 00 	bld	r5,0x0
80009160:	c3 01       	brne	800091c0 <_vfprintf_r+0xa08>
80009162:	ec 02 00 0e 	add	lr,r6,r2
80009166:	50 3e       	stdsp	sp[0xc],lr
80009168:	40 4c       	lddsp	r12,sp[0x10]
8000916a:	58 0c       	cp.w	r12,0
8000916c:	c1 50       	breq	80009196 <_vfprintf_r+0x9de>
8000916e:	0d 89       	ld.ub	r9,r6[0x0]
80009170:	33 08       	mov	r8,48
80009172:	f0 09 18 00 	cp.b	r9,r8
80009176:	c0 b1       	brne	8000918c <_vfprintf_r+0x9d4>
80009178:	30 08       	mov	r8,0
8000917a:	30 09       	mov	r9,0
8000917c:	40 6b       	lddsp	r11,sp[0x18]
8000917e:	40 7a       	lddsp	r10,sp[0x1c]
80009180:	e0 a0 1c d7 	rcall	8000cb2e <__avr32_f64_cmp_eq>
80009184:	fb b2 00 01 	rsubeq	r2,1
80009188:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
8000918c:	40 3b       	lddsp	r11,sp[0xc]
8000918e:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009192:	10 0b       	add	r11,r8
80009194:	50 3b       	stdsp	sp[0xc],r11
80009196:	40 6b       	lddsp	r11,sp[0x18]
80009198:	30 08       	mov	r8,0
8000919a:	30 09       	mov	r9,0
8000919c:	40 7a       	lddsp	r10,sp[0x1c]
8000919e:	e0 a0 1c c8 	rcall	8000cb2e <__avr32_f64_cmp_eq>
800091a2:	c0 90       	breq	800091b4 <_vfprintf_r+0x9fc>
800091a4:	40 3a       	lddsp	r10,sp[0xc]
800091a6:	fb 4a 06 a4 	st.w	sp[1700],r10
800091aa:	c0 58       	rjmp	800091b4 <_vfprintf_r+0x9fc>
800091ac:	10 c9       	st.b	r8++,r9
800091ae:	fb 48 06 a4 	st.w	sp[1700],r8
800091b2:	c0 28       	rjmp	800091b6 <_vfprintf_r+0x9fe>
800091b4:	33 09       	mov	r9,48
800091b6:	fa f8 06 a4 	ld.w	r8,sp[1700]
800091ba:	40 3e       	lddsp	lr,sp[0xc]
800091bc:	1c 38       	cp.w	r8,lr
800091be:	cf 73       	brcs	800091ac <_vfprintf_r+0x9f4>
800091c0:	e0 40 00 47 	cp.w	r0,71
800091c4:	5f 09       	sreq	r9
800091c6:	e0 40 00 67 	cp.w	r0,103
800091ca:	5f 08       	sreq	r8
800091cc:	f3 e8 10 08 	or	r8,r9,r8
800091d0:	fa f9 06 a4 	ld.w	r9,sp[1700]
800091d4:	0c 19       	sub	r9,r6
800091d6:	50 69       	stdsp	sp[0x18],r9
800091d8:	58 08       	cp.w	r8,0
800091da:	c0 b0       	breq	800091f0 <_vfprintf_r+0xa38>
800091dc:	fa f8 06 ac 	ld.w	r8,sp[1708]
800091e0:	5b d8       	cp.w	r8,-3
800091e2:	c0 55       	brlt	800091ec <_vfprintf_r+0xa34>
800091e4:	40 2c       	lddsp	r12,sp[0x8]
800091e6:	18 38       	cp.w	r8,r12
800091e8:	e0 8a 00 6a 	brle	800092bc <_vfprintf_r+0xb04>
800091ec:	20 20       	sub	r0,2
800091ee:	c0 58       	rjmp	800091f8 <_vfprintf_r+0xa40>
800091f0:	e0 40 00 65 	cp.w	r0,101
800091f4:	e0 89 00 46 	brgt	80009280 <_vfprintf_r+0xac8>
800091f8:	fa fb 06 ac 	ld.w	r11,sp[1708]
800091fc:	fb 60 06 9c 	st.b	sp[1692],r0
80009200:	20 1b       	sub	r11,1
80009202:	fb 4b 06 ac 	st.w	sp[1708],r11
80009206:	c0 47       	brpl	8000920e <_vfprintf_r+0xa56>
80009208:	5c 3b       	neg	r11
8000920a:	32 d8       	mov	r8,45
8000920c:	c0 28       	rjmp	80009210 <_vfprintf_r+0xa58>
8000920e:	32 b8       	mov	r8,43
80009210:	fb 68 06 9d 	st.b	sp[1693],r8
80009214:	58 9b       	cp.w	r11,9
80009216:	e0 8a 00 1d 	brle	80009250 <_vfprintf_r+0xa98>
8000921a:	fa c9 fa 35 	sub	r9,sp,-1483
8000921e:	30 aa       	mov	r10,10
80009220:	12 98       	mov	r8,r9
80009222:	0e 9c       	mov	r12,r7
80009224:	0c 92       	mov	r2,r6
80009226:	f6 0a 0c 06 	divs	r6,r11,r10
8000922a:	0e 9b       	mov	r11,r7
8000922c:	2d 0b       	sub	r11,-48
8000922e:	10 fb       	st.b	--r8,r11
80009230:	0c 9b       	mov	r11,r6
80009232:	58 96       	cp.w	r6,9
80009234:	fe 99 ff f9 	brgt	80009226 <_vfprintf_r+0xa6e>
80009238:	2d 0b       	sub	r11,-48
8000923a:	18 97       	mov	r7,r12
8000923c:	04 96       	mov	r6,r2
8000923e:	10 fb       	st.b	--r8,r11
80009240:	fa ca f9 62 	sub	r10,sp,-1694
80009244:	c0 38       	rjmp	8000924a <_vfprintf_r+0xa92>
80009246:	11 3b       	ld.ub	r11,r8++
80009248:	14 cb       	st.b	r10++,r11
8000924a:	12 38       	cp.w	r8,r9
8000924c:	cf d3       	brcs	80009246 <_vfprintf_r+0xa8e>
8000924e:	c0 98       	rjmp	80009260 <_vfprintf_r+0xaa8>
80009250:	2d 0b       	sub	r11,-48
80009252:	33 08       	mov	r8,48
80009254:	fb 6b 06 9f 	st.b	sp[1695],r11
80009258:	fb 68 06 9e 	st.b	sp[1694],r8
8000925c:	fa ca f9 60 	sub	r10,sp,-1696
80009260:	fa c8 f9 64 	sub	r8,sp,-1692
80009264:	f4 08 01 08 	sub	r8,r10,r8
80009268:	50 e8       	stdsp	sp[0x38],r8
8000926a:	10 92       	mov	r2,r8
8000926c:	40 6b       	lddsp	r11,sp[0x18]
8000926e:	16 02       	add	r2,r11
80009270:	58 1b       	cp.w	r11,1
80009272:	e0 89 00 05 	brgt	8000927c <_vfprintf_r+0xac4>
80009276:	ed b5 00 00 	bld	r5,0x0
8000927a:	c3 51       	brne	800092e4 <_vfprintf_r+0xb2c>
8000927c:	2f f2       	sub	r2,-1
8000927e:	c3 38       	rjmp	800092e4 <_vfprintf_r+0xb2c>
80009280:	e0 40 00 66 	cp.w	r0,102
80009284:	c1 c1       	brne	800092bc <_vfprintf_r+0xb04>
80009286:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000928a:	58 02       	cp.w	r2,0
8000928c:	e0 8a 00 0c 	brle	800092a4 <_vfprintf_r+0xaec>
80009290:	40 2a       	lddsp	r10,sp[0x8]
80009292:	58 0a       	cp.w	r10,0
80009294:	c0 41       	brne	8000929c <_vfprintf_r+0xae4>
80009296:	ed b5 00 00 	bld	r5,0x0
8000929a:	c2 51       	brne	800092e4 <_vfprintf_r+0xb2c>
8000929c:	2f f2       	sub	r2,-1
8000929e:	40 29       	lddsp	r9,sp[0x8]
800092a0:	12 02       	add	r2,r9
800092a2:	c0 b8       	rjmp	800092b8 <_vfprintf_r+0xb00>
800092a4:	40 28       	lddsp	r8,sp[0x8]
800092a6:	58 08       	cp.w	r8,0
800092a8:	c0 61       	brne	800092b4 <_vfprintf_r+0xafc>
800092aa:	ed b5 00 00 	bld	r5,0x0
800092ae:	c0 30       	breq	800092b4 <_vfprintf_r+0xafc>
800092b0:	30 12       	mov	r2,1
800092b2:	c1 98       	rjmp	800092e4 <_vfprintf_r+0xb2c>
800092b4:	40 22       	lddsp	r2,sp[0x8]
800092b6:	2f e2       	sub	r2,-2
800092b8:	36 60       	mov	r0,102
800092ba:	c1 58       	rjmp	800092e4 <_vfprintf_r+0xb2c>
800092bc:	fa f2 06 ac 	ld.w	r2,sp[1708]
800092c0:	40 6e       	lddsp	lr,sp[0x18]
800092c2:	1c 32       	cp.w	r2,lr
800092c4:	c0 65       	brlt	800092d0 <_vfprintf_r+0xb18>
800092c6:	ed b5 00 00 	bld	r5,0x0
800092ca:	f7 b2 00 ff 	subeq	r2,-1
800092ce:	c0 a8       	rjmp	800092e2 <_vfprintf_r+0xb2a>
800092d0:	e4 08 11 02 	rsub	r8,r2,2
800092d4:	40 6c       	lddsp	r12,sp[0x18]
800092d6:	58 02       	cp.w	r2,0
800092d8:	f0 02 17 a0 	movle	r2,r8
800092dc:	f9 b2 09 01 	movgt	r2,1
800092e0:	18 02       	add	r2,r12
800092e2:	36 70       	mov	r0,103
800092e4:	40 9b       	lddsp	r11,sp[0x24]
800092e6:	58 0b       	cp.w	r11,0
800092e8:	e0 80 05 94 	breq	80009e10 <_vfprintf_r+0x1658>
800092ec:	32 d8       	mov	r8,45
800092ee:	fb 68 06 bb 	st.b	sp[1723],r8
800092f2:	e0 8f 05 93 	bral	80009e18 <_vfprintf_r+0x1660>
800092f6:	50 a7       	stdsp	sp[0x28],r7
800092f8:	04 94       	mov	r4,r2
800092fa:	0c 97       	mov	r7,r6
800092fc:	02 92       	mov	r2,r1
800092fe:	06 96       	mov	r6,r3
80009300:	40 41       	lddsp	r1,sp[0x10]
80009302:	40 93       	lddsp	r3,sp[0x24]
80009304:	0e 99       	mov	r9,r7
80009306:	ed b5 00 05 	bld	r5,0x5
8000930a:	c4 81       	brne	8000939a <_vfprintf_r+0xbe2>
8000930c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009310:	40 3e       	lddsp	lr,sp[0xc]
80009312:	58 0e       	cp.w	lr,0
80009314:	c1 d0       	breq	8000934e <_vfprintf_r+0xb96>
80009316:	10 36       	cp.w	r6,r8
80009318:	c0 64       	brge	80009324 <_vfprintf_r+0xb6c>
8000931a:	fa cc f9 44 	sub	r12,sp,-1724
8000931e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009322:	c1 d8       	rjmp	8000935c <_vfprintf_r+0xba4>
80009324:	fa c8 f9 50 	sub	r8,sp,-1712
80009328:	1a d8       	st.w	--sp,r8
8000932a:	fa c8 fa b8 	sub	r8,sp,-1352
8000932e:	04 9a       	mov	r10,r2
80009330:	1a d8       	st.w	--sp,r8
80009332:	fa c8 fb b4 	sub	r8,sp,-1100
80009336:	0c 9b       	mov	r11,r6
80009338:	1a d8       	st.w	--sp,r8
8000933a:	08 9c       	mov	r12,r4
8000933c:	fa c8 f9 40 	sub	r8,sp,-1728
80009340:	fa c9 ff b4 	sub	r9,sp,-76
80009344:	fe b0 f8 a2 	rcall	80008488 <get_arg>
80009348:	2f dd       	sub	sp,-12
8000934a:	78 0a       	ld.w	r10,r12[0x0]
8000934c:	c2 08       	rjmp	8000938c <_vfprintf_r+0xbd4>
8000934e:	2f f7       	sub	r7,-1
80009350:	10 39       	cp.w	r9,r8
80009352:	c0 84       	brge	80009362 <_vfprintf_r+0xbaa>
80009354:	fa cb f9 44 	sub	r11,sp,-1724
80009358:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000935c:	ec fa fd 88 	ld.w	r10,r6[-632]
80009360:	c1 68       	rjmp	8000938c <_vfprintf_r+0xbd4>
80009362:	41 09       	lddsp	r9,sp[0x40]
80009364:	59 f8       	cp.w	r8,31
80009366:	e0 89 00 10 	brgt	80009386 <_vfprintf_r+0xbce>
8000936a:	f2 ca ff fc 	sub	r10,r9,-4
8000936e:	51 0a       	stdsp	sp[0x40],r10
80009370:	fa c6 f9 44 	sub	r6,sp,-1724
80009374:	72 0a       	ld.w	r10,r9[0x0]
80009376:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000937a:	f3 4a fd 88 	st.w	r9[-632],r10
8000937e:	2f f8       	sub	r8,-1
80009380:	fb 48 06 b4 	st.w	sp[1716],r8
80009384:	c0 48       	rjmp	8000938c <_vfprintf_r+0xbd4>
80009386:	72 0a       	ld.w	r10,r9[0x0]
80009388:	2f c9       	sub	r9,-4
8000938a:	51 09       	stdsp	sp[0x40],r9
8000938c:	40 be       	lddsp	lr,sp[0x2c]
8000938e:	1c 98       	mov	r8,lr
80009390:	95 1e       	st.w	r10[0x4],lr
80009392:	bf 58       	asr	r8,0x1f
80009394:	95 08       	st.w	r10[0x0],r8
80009396:	fe 9f fa 9f 	bral	800088d4 <_vfprintf_r+0x11c>
8000939a:	ed b5 00 04 	bld	r5,0x4
8000939e:	c4 80       	breq	8000942e <_vfprintf_r+0xc76>
800093a0:	e2 15 00 40 	andl	r5,0x40,COH
800093a4:	c4 50       	breq	8000942e <_vfprintf_r+0xc76>
800093a6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800093aa:	40 3c       	lddsp	r12,sp[0xc]
800093ac:	58 0c       	cp.w	r12,0
800093ae:	c1 d0       	breq	800093e8 <_vfprintf_r+0xc30>
800093b0:	10 36       	cp.w	r6,r8
800093b2:	c0 64       	brge	800093be <_vfprintf_r+0xc06>
800093b4:	fa cb f9 44 	sub	r11,sp,-1724
800093b8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800093bc:	c1 d8       	rjmp	800093f6 <_vfprintf_r+0xc3e>
800093be:	fa c8 f9 50 	sub	r8,sp,-1712
800093c2:	1a d8       	st.w	--sp,r8
800093c4:	fa c8 fa b8 	sub	r8,sp,-1352
800093c8:	04 9a       	mov	r10,r2
800093ca:	1a d8       	st.w	--sp,r8
800093cc:	fa c8 fb b4 	sub	r8,sp,-1100
800093d0:	0c 9b       	mov	r11,r6
800093d2:	1a d8       	st.w	--sp,r8
800093d4:	08 9c       	mov	r12,r4
800093d6:	fa c8 f9 40 	sub	r8,sp,-1728
800093da:	fa c9 ff b4 	sub	r9,sp,-76
800093de:	fe b0 f8 55 	rcall	80008488 <get_arg>
800093e2:	2f dd       	sub	sp,-12
800093e4:	78 0a       	ld.w	r10,r12[0x0]
800093e6:	c2 08       	rjmp	80009426 <_vfprintf_r+0xc6e>
800093e8:	2f f7       	sub	r7,-1
800093ea:	10 39       	cp.w	r9,r8
800093ec:	c0 84       	brge	800093fc <_vfprintf_r+0xc44>
800093ee:	fa ca f9 44 	sub	r10,sp,-1724
800093f2:	f4 06 00 36 	add	r6,r10,r6<<0x3
800093f6:	ec fa fd 88 	ld.w	r10,r6[-632]
800093fa:	c1 68       	rjmp	80009426 <_vfprintf_r+0xc6e>
800093fc:	41 09       	lddsp	r9,sp[0x40]
800093fe:	59 f8       	cp.w	r8,31
80009400:	e0 89 00 10 	brgt	80009420 <_vfprintf_r+0xc68>
80009404:	f2 ca ff fc 	sub	r10,r9,-4
80009408:	51 0a       	stdsp	sp[0x40],r10
8000940a:	fa c6 f9 44 	sub	r6,sp,-1724
8000940e:	72 0a       	ld.w	r10,r9[0x0]
80009410:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009414:	f3 4a fd 88 	st.w	r9[-632],r10
80009418:	2f f8       	sub	r8,-1
8000941a:	fb 48 06 b4 	st.w	sp[1716],r8
8000941e:	c0 48       	rjmp	80009426 <_vfprintf_r+0xc6e>
80009420:	72 0a       	ld.w	r10,r9[0x0]
80009422:	2f c9       	sub	r9,-4
80009424:	51 09       	stdsp	sp[0x40],r9
80009426:	40 be       	lddsp	lr,sp[0x2c]
80009428:	b4 0e       	st.h	r10[0x0],lr
8000942a:	fe 9f fa 55 	bral	800088d4 <_vfprintf_r+0x11c>
8000942e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009432:	40 3c       	lddsp	r12,sp[0xc]
80009434:	58 0c       	cp.w	r12,0
80009436:	c1 d0       	breq	80009470 <_vfprintf_r+0xcb8>
80009438:	10 36       	cp.w	r6,r8
8000943a:	c0 64       	brge	80009446 <_vfprintf_r+0xc8e>
8000943c:	fa cb f9 44 	sub	r11,sp,-1724
80009440:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009444:	c1 d8       	rjmp	8000947e <_vfprintf_r+0xcc6>
80009446:	fa c8 f9 50 	sub	r8,sp,-1712
8000944a:	1a d8       	st.w	--sp,r8
8000944c:	fa c8 fa b8 	sub	r8,sp,-1352
80009450:	04 9a       	mov	r10,r2
80009452:	1a d8       	st.w	--sp,r8
80009454:	fa c8 fb b4 	sub	r8,sp,-1100
80009458:	0c 9b       	mov	r11,r6
8000945a:	1a d8       	st.w	--sp,r8
8000945c:	08 9c       	mov	r12,r4
8000945e:	fa c8 f9 40 	sub	r8,sp,-1728
80009462:	fa c9 ff b4 	sub	r9,sp,-76
80009466:	fe b0 f8 11 	rcall	80008488 <get_arg>
8000946a:	2f dd       	sub	sp,-12
8000946c:	78 0a       	ld.w	r10,r12[0x0]
8000946e:	c2 08       	rjmp	800094ae <_vfprintf_r+0xcf6>
80009470:	2f f7       	sub	r7,-1
80009472:	10 39       	cp.w	r9,r8
80009474:	c0 84       	brge	80009484 <_vfprintf_r+0xccc>
80009476:	fa ca f9 44 	sub	r10,sp,-1724
8000947a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000947e:	ec fa fd 88 	ld.w	r10,r6[-632]
80009482:	c1 68       	rjmp	800094ae <_vfprintf_r+0xcf6>
80009484:	41 09       	lddsp	r9,sp[0x40]
80009486:	59 f8       	cp.w	r8,31
80009488:	e0 89 00 10 	brgt	800094a8 <_vfprintf_r+0xcf0>
8000948c:	f2 ca ff fc 	sub	r10,r9,-4
80009490:	51 0a       	stdsp	sp[0x40],r10
80009492:	fa c6 f9 44 	sub	r6,sp,-1724
80009496:	72 0a       	ld.w	r10,r9[0x0]
80009498:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000949c:	f3 4a fd 88 	st.w	r9[-632],r10
800094a0:	2f f8       	sub	r8,-1
800094a2:	fb 48 06 b4 	st.w	sp[1716],r8
800094a6:	c0 48       	rjmp	800094ae <_vfprintf_r+0xcf6>
800094a8:	72 0a       	ld.w	r10,r9[0x0]
800094aa:	2f c9       	sub	r9,-4
800094ac:	51 09       	stdsp	sp[0x40],r9
800094ae:	40 be       	lddsp	lr,sp[0x2c]
800094b0:	95 0e       	st.w	r10[0x0],lr
800094b2:	fe 9f fa 11 	bral	800088d4 <_vfprintf_r+0x11c>
800094b6:	50 a7       	stdsp	sp[0x28],r7
800094b8:	50 80       	stdsp	sp[0x20],r0
800094ba:	0c 97       	mov	r7,r6
800094bc:	04 94       	mov	r4,r2
800094be:	06 96       	mov	r6,r3
800094c0:	02 92       	mov	r2,r1
800094c2:	40 93       	lddsp	r3,sp[0x24]
800094c4:	10 90       	mov	r0,r8
800094c6:	40 41       	lddsp	r1,sp[0x10]
800094c8:	a5 a5       	sbr	r5,0x4
800094ca:	c0 a8       	rjmp	800094de <_vfprintf_r+0xd26>
800094cc:	50 a7       	stdsp	sp[0x28],r7
800094ce:	50 80       	stdsp	sp[0x20],r0
800094d0:	0c 97       	mov	r7,r6
800094d2:	04 94       	mov	r4,r2
800094d4:	06 96       	mov	r6,r3
800094d6:	02 92       	mov	r2,r1
800094d8:	40 93       	lddsp	r3,sp[0x24]
800094da:	10 90       	mov	r0,r8
800094dc:	40 41       	lddsp	r1,sp[0x10]
800094de:	ed b5 00 05 	bld	r5,0x5
800094e2:	c5 d1       	brne	8000959c <_vfprintf_r+0xde4>
800094e4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800094e8:	40 3c       	lddsp	r12,sp[0xc]
800094ea:	58 0c       	cp.w	r12,0
800094ec:	c2 60       	breq	80009538 <_vfprintf_r+0xd80>
800094ee:	10 36       	cp.w	r6,r8
800094f0:	c0 a4       	brge	80009504 <_vfprintf_r+0xd4c>
800094f2:	fa cb f9 44 	sub	r11,sp,-1724
800094f6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800094fa:	ec e8 fd 88 	ld.d	r8,r6[-632]
800094fe:	fa e9 00 00 	st.d	sp[0],r8
80009502:	c1 88       	rjmp	80009532 <_vfprintf_r+0xd7a>
80009504:	fa c8 f9 50 	sub	r8,sp,-1712
80009508:	1a d8       	st.w	--sp,r8
8000950a:	fa c8 fa b8 	sub	r8,sp,-1352
8000950e:	04 9a       	mov	r10,r2
80009510:	1a d8       	st.w	--sp,r8
80009512:	0c 9b       	mov	r11,r6
80009514:	fa c8 fb b4 	sub	r8,sp,-1100
80009518:	08 9c       	mov	r12,r4
8000951a:	1a d8       	st.w	--sp,r8
8000951c:	fa c8 f9 40 	sub	r8,sp,-1728
80009520:	fa c9 ff b4 	sub	r9,sp,-76
80009524:	fe b0 f7 b2 	rcall	80008488 <get_arg>
80009528:	2f dd       	sub	sp,-12
8000952a:	f8 ea 00 00 	ld.d	r10,r12[0]
8000952e:	fa eb 00 00 	st.d	sp[0],r10
80009532:	30 08       	mov	r8,0
80009534:	e0 8f 03 de 	bral	80009cf0 <_vfprintf_r+0x1538>
80009538:	ee ca ff ff 	sub	r10,r7,-1
8000953c:	10 37       	cp.w	r7,r8
8000953e:	c0 b4       	brge	80009554 <_vfprintf_r+0xd9c>
80009540:	fa c9 f9 44 	sub	r9,sp,-1724
80009544:	14 97       	mov	r7,r10
80009546:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000954a:	ec ea fd 88 	ld.d	r10,r6[-632]
8000954e:	fa eb 00 00 	st.d	sp[0],r10
80009552:	c1 88       	rjmp	80009582 <_vfprintf_r+0xdca>
80009554:	41 09       	lddsp	r9,sp[0x40]
80009556:	59 f8       	cp.w	r8,31
80009558:	e0 89 00 18 	brgt	80009588 <_vfprintf_r+0xdd0>
8000955c:	f2 e6 00 00 	ld.d	r6,r9[0]
80009560:	f2 cb ff f8 	sub	r11,r9,-8
80009564:	fa e7 00 00 	st.d	sp[0],r6
80009568:	51 0b       	stdsp	sp[0x40],r11
8000956a:	fa c6 f9 44 	sub	r6,sp,-1724
8000956e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009572:	fa e6 00 00 	ld.d	r6,sp[0]
80009576:	f2 e7 fd 88 	st.d	r9[-632],r6
8000957a:	2f f8       	sub	r8,-1
8000957c:	14 97       	mov	r7,r10
8000957e:	fb 48 06 b4 	st.w	sp[1716],r8
80009582:	40 38       	lddsp	r8,sp[0xc]
80009584:	e0 8f 03 b6 	bral	80009cf0 <_vfprintf_r+0x1538>
80009588:	f2 e6 00 00 	ld.d	r6,r9[0]
8000958c:	40 38       	lddsp	r8,sp[0xc]
8000958e:	fa e7 00 00 	st.d	sp[0],r6
80009592:	2f 89       	sub	r9,-8
80009594:	14 97       	mov	r7,r10
80009596:	51 09       	stdsp	sp[0x40],r9
80009598:	e0 8f 03 ac 	bral	80009cf0 <_vfprintf_r+0x1538>
8000959c:	ed b5 00 04 	bld	r5,0x4
800095a0:	c1 61       	brne	800095cc <_vfprintf_r+0xe14>
800095a2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800095a6:	40 3e       	lddsp	lr,sp[0xc]
800095a8:	58 0e       	cp.w	lr,0
800095aa:	c0 80       	breq	800095ba <_vfprintf_r+0xe02>
800095ac:	10 36       	cp.w	r6,r8
800095ae:	c6 74       	brge	8000967c <_vfprintf_r+0xec4>
800095b0:	fa cc f9 44 	sub	r12,sp,-1724
800095b4:	f8 06 00 36 	add	r6,r12,r6<<0x3
800095b8:	c8 08       	rjmp	800096b8 <_vfprintf_r+0xf00>
800095ba:	ee ca ff ff 	sub	r10,r7,-1
800095be:	10 37       	cp.w	r7,r8
800095c0:	c7 f4       	brge	800096be <_vfprintf_r+0xf06>
800095c2:	fa cb f9 44 	sub	r11,sp,-1724
800095c6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800095ca:	c7 68       	rjmp	800096b6 <_vfprintf_r+0xefe>
800095cc:	ed b5 00 06 	bld	r5,0x6
800095d0:	c4 a1       	brne	80009664 <_vfprintf_r+0xeac>
800095d2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800095d6:	40 3c       	lddsp	r12,sp[0xc]
800095d8:	58 0c       	cp.w	r12,0
800095da:	c1 d0       	breq	80009614 <_vfprintf_r+0xe5c>
800095dc:	10 36       	cp.w	r6,r8
800095de:	c0 64       	brge	800095ea <_vfprintf_r+0xe32>
800095e0:	fa cb f9 44 	sub	r11,sp,-1724
800095e4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800095e8:	c1 f8       	rjmp	80009626 <_vfprintf_r+0xe6e>
800095ea:	fa c8 f9 50 	sub	r8,sp,-1712
800095ee:	1a d8       	st.w	--sp,r8
800095f0:	fa c8 fa b8 	sub	r8,sp,-1352
800095f4:	1a d8       	st.w	--sp,r8
800095f6:	fa c8 fb b4 	sub	r8,sp,-1100
800095fa:	1a d8       	st.w	--sp,r8
800095fc:	fa c8 f9 40 	sub	r8,sp,-1728
80009600:	fa c9 ff b4 	sub	r9,sp,-76
80009604:	04 9a       	mov	r10,r2
80009606:	0c 9b       	mov	r11,r6
80009608:	08 9c       	mov	r12,r4
8000960a:	fe b0 f7 3f 	rcall	80008488 <get_arg>
8000960e:	2f dd       	sub	sp,-12
80009610:	98 18       	ld.sh	r8,r12[0x2]
80009612:	c2 68       	rjmp	8000965e <_vfprintf_r+0xea6>
80009614:	ee ca ff ff 	sub	r10,r7,-1
80009618:	10 37       	cp.w	r7,r8
8000961a:	c0 94       	brge	8000962c <_vfprintf_r+0xe74>
8000961c:	fa c9 f9 44 	sub	r9,sp,-1724
80009620:	14 97       	mov	r7,r10
80009622:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009626:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000962a:	c1 a8       	rjmp	8000965e <_vfprintf_r+0xea6>
8000962c:	41 09       	lddsp	r9,sp[0x40]
8000962e:	59 f8       	cp.w	r8,31
80009630:	e0 89 00 13 	brgt	80009656 <_vfprintf_r+0xe9e>
80009634:	f2 cb ff fc 	sub	r11,r9,-4
80009638:	51 0b       	stdsp	sp[0x40],r11
8000963a:	72 09       	ld.w	r9,r9[0x0]
8000963c:	fa c6 f9 44 	sub	r6,sp,-1724
80009640:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009644:	2f f8       	sub	r8,-1
80009646:	f7 49 fd 88 	st.w	r11[-632],r9
8000964a:	fb 48 06 b4 	st.w	sp[1716],r8
8000964e:	14 97       	mov	r7,r10
80009650:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009654:	c0 58       	rjmp	8000965e <_vfprintf_r+0xea6>
80009656:	92 18       	ld.sh	r8,r9[0x2]
80009658:	14 97       	mov	r7,r10
8000965a:	2f c9       	sub	r9,-4
8000965c:	51 09       	stdsp	sp[0x40],r9
8000965e:	5c 78       	castu.h	r8
80009660:	50 18       	stdsp	sp[0x4],r8
80009662:	c4 68       	rjmp	800096ee <_vfprintf_r+0xf36>
80009664:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009668:	40 3c       	lddsp	r12,sp[0xc]
8000966a:	58 0c       	cp.w	r12,0
8000966c:	c1 d0       	breq	800096a6 <_vfprintf_r+0xeee>
8000966e:	10 36       	cp.w	r6,r8
80009670:	c0 64       	brge	8000967c <_vfprintf_r+0xec4>
80009672:	fa cb f9 44 	sub	r11,sp,-1724
80009676:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000967a:	c1 f8       	rjmp	800096b8 <_vfprintf_r+0xf00>
8000967c:	fa c8 f9 50 	sub	r8,sp,-1712
80009680:	1a d8       	st.w	--sp,r8
80009682:	fa c8 fa b8 	sub	r8,sp,-1352
80009686:	0c 9b       	mov	r11,r6
80009688:	1a d8       	st.w	--sp,r8
8000968a:	fa c8 fb b4 	sub	r8,sp,-1100
8000968e:	04 9a       	mov	r10,r2
80009690:	1a d8       	st.w	--sp,r8
80009692:	08 9c       	mov	r12,r4
80009694:	fa c8 f9 40 	sub	r8,sp,-1728
80009698:	fa c9 ff b4 	sub	r9,sp,-76
8000969c:	fe b0 f6 f6 	rcall	80008488 <get_arg>
800096a0:	2f dd       	sub	sp,-12
800096a2:	78 0b       	ld.w	r11,r12[0x0]
800096a4:	c2 48       	rjmp	800096ec <_vfprintf_r+0xf34>
800096a6:	ee ca ff ff 	sub	r10,r7,-1
800096aa:	10 37       	cp.w	r7,r8
800096ac:	c0 94       	brge	800096be <_vfprintf_r+0xf06>
800096ae:	fa c9 f9 44 	sub	r9,sp,-1724
800096b2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800096b6:	14 97       	mov	r7,r10
800096b8:	ec fb fd 88 	ld.w	r11,r6[-632]
800096bc:	c1 88       	rjmp	800096ec <_vfprintf_r+0xf34>
800096be:	41 09       	lddsp	r9,sp[0x40]
800096c0:	59 f8       	cp.w	r8,31
800096c2:	e0 89 00 11 	brgt	800096e4 <_vfprintf_r+0xf2c>
800096c6:	f2 cb ff fc 	sub	r11,r9,-4
800096ca:	51 0b       	stdsp	sp[0x40],r11
800096cc:	fa c6 f9 44 	sub	r6,sp,-1724
800096d0:	72 0b       	ld.w	r11,r9[0x0]
800096d2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800096d6:	f3 4b fd 88 	st.w	r9[-632],r11
800096da:	2f f8       	sub	r8,-1
800096dc:	14 97       	mov	r7,r10
800096de:	fb 48 06 b4 	st.w	sp[1716],r8
800096e2:	c0 58       	rjmp	800096ec <_vfprintf_r+0xf34>
800096e4:	72 0b       	ld.w	r11,r9[0x0]
800096e6:	14 97       	mov	r7,r10
800096e8:	2f c9       	sub	r9,-4
800096ea:	51 09       	stdsp	sp[0x40],r9
800096ec:	50 1b       	stdsp	sp[0x4],r11
800096ee:	30 0e       	mov	lr,0
800096f0:	50 0e       	stdsp	sp[0x0],lr
800096f2:	1c 98       	mov	r8,lr
800096f4:	e0 8f 02 fe 	bral	80009cf0 <_vfprintf_r+0x1538>
800096f8:	50 a7       	stdsp	sp[0x28],r7
800096fa:	50 80       	stdsp	sp[0x20],r0
800096fc:	0c 97       	mov	r7,r6
800096fe:	04 94       	mov	r4,r2
80009700:	06 96       	mov	r6,r3
80009702:	02 92       	mov	r2,r1
80009704:	40 93       	lddsp	r3,sp[0x24]
80009706:	40 41       	lddsp	r1,sp[0x10]
80009708:	0e 99       	mov	r9,r7
8000970a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000970e:	40 3c       	lddsp	r12,sp[0xc]
80009710:	58 0c       	cp.w	r12,0
80009712:	c1 d0       	breq	8000974c <_vfprintf_r+0xf94>
80009714:	10 36       	cp.w	r6,r8
80009716:	c0 64       	brge	80009722 <_vfprintf_r+0xf6a>
80009718:	fa cb f9 44 	sub	r11,sp,-1724
8000971c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009720:	c1 d8       	rjmp	8000975a <_vfprintf_r+0xfa2>
80009722:	fa c8 f9 50 	sub	r8,sp,-1712
80009726:	1a d8       	st.w	--sp,r8
80009728:	fa c8 fa b8 	sub	r8,sp,-1352
8000972c:	1a d8       	st.w	--sp,r8
8000972e:	fa c8 fb b4 	sub	r8,sp,-1100
80009732:	1a d8       	st.w	--sp,r8
80009734:	fa c9 ff b4 	sub	r9,sp,-76
80009738:	fa c8 f9 40 	sub	r8,sp,-1728
8000973c:	04 9a       	mov	r10,r2
8000973e:	0c 9b       	mov	r11,r6
80009740:	08 9c       	mov	r12,r4
80009742:	fe b0 f6 a3 	rcall	80008488 <get_arg>
80009746:	2f dd       	sub	sp,-12
80009748:	78 09       	ld.w	r9,r12[0x0]
8000974a:	c2 18       	rjmp	8000978c <_vfprintf_r+0xfd4>
8000974c:	2f f7       	sub	r7,-1
8000974e:	10 39       	cp.w	r9,r8
80009750:	c0 84       	brge	80009760 <_vfprintf_r+0xfa8>
80009752:	fa ca f9 44 	sub	r10,sp,-1724
80009756:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000975a:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000975e:	c1 78       	rjmp	8000978c <_vfprintf_r+0xfd4>
80009760:	41 09       	lddsp	r9,sp[0x40]
80009762:	59 f8       	cp.w	r8,31
80009764:	e0 89 00 10 	brgt	80009784 <_vfprintf_r+0xfcc>
80009768:	f2 ca ff fc 	sub	r10,r9,-4
8000976c:	51 0a       	stdsp	sp[0x40],r10
8000976e:	fa c6 f9 44 	sub	r6,sp,-1724
80009772:	72 09       	ld.w	r9,r9[0x0]
80009774:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80009778:	f5 49 fd 88 	st.w	r10[-632],r9
8000977c:	2f f8       	sub	r8,-1
8000977e:	fb 48 06 b4 	st.w	sp[1716],r8
80009782:	c0 58       	rjmp	8000978c <_vfprintf_r+0xfd4>
80009784:	f2 c8 ff fc 	sub	r8,r9,-4
80009788:	51 08       	stdsp	sp[0x40],r8
8000978a:	72 09       	ld.w	r9,r9[0x0]
8000978c:	33 08       	mov	r8,48
8000978e:	fb 68 06 b8 	st.b	sp[1720],r8
80009792:	37 88       	mov	r8,120
80009794:	30 0e       	mov	lr,0
80009796:	fb 68 06 b9 	st.b	sp[1721],r8
8000979a:	fe cc b0 a6 	sub	r12,pc,-20314
8000979e:	50 19       	stdsp	sp[0x4],r9
800097a0:	a1 b5       	sbr	r5,0x1
800097a2:	50 0e       	stdsp	sp[0x0],lr
800097a4:	50 dc       	stdsp	sp[0x34],r12
800097a6:	30 28       	mov	r8,2
800097a8:	37 80       	mov	r0,120
800097aa:	e0 8f 02 a3 	bral	80009cf0 <_vfprintf_r+0x1538>
800097ae:	50 a7       	stdsp	sp[0x28],r7
800097b0:	50 80       	stdsp	sp[0x20],r0
800097b2:	10 90       	mov	r0,r8
800097b4:	30 08       	mov	r8,0
800097b6:	fb 68 06 bb 	st.b	sp[1723],r8
800097ba:	0c 97       	mov	r7,r6
800097bc:	04 94       	mov	r4,r2
800097be:	06 96       	mov	r6,r3
800097c0:	02 92       	mov	r2,r1
800097c2:	40 93       	lddsp	r3,sp[0x24]
800097c4:	40 41       	lddsp	r1,sp[0x10]
800097c6:	0e 99       	mov	r9,r7
800097c8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800097cc:	40 3b       	lddsp	r11,sp[0xc]
800097ce:	58 0b       	cp.w	r11,0
800097d0:	c1 d0       	breq	8000980a <_vfprintf_r+0x1052>
800097d2:	10 36       	cp.w	r6,r8
800097d4:	c0 64       	brge	800097e0 <_vfprintf_r+0x1028>
800097d6:	fa ca f9 44 	sub	r10,sp,-1724
800097da:	f4 06 00 36 	add	r6,r10,r6<<0x3
800097de:	c1 d8       	rjmp	80009818 <_vfprintf_r+0x1060>
800097e0:	fa c8 f9 50 	sub	r8,sp,-1712
800097e4:	1a d8       	st.w	--sp,r8
800097e6:	fa c8 fa b8 	sub	r8,sp,-1352
800097ea:	1a d8       	st.w	--sp,r8
800097ec:	fa c8 fb b4 	sub	r8,sp,-1100
800097f0:	0c 9b       	mov	r11,r6
800097f2:	1a d8       	st.w	--sp,r8
800097f4:	04 9a       	mov	r10,r2
800097f6:	fa c8 f9 40 	sub	r8,sp,-1728
800097fa:	fa c9 ff b4 	sub	r9,sp,-76
800097fe:	08 9c       	mov	r12,r4
80009800:	fe b0 f6 44 	rcall	80008488 <get_arg>
80009804:	2f dd       	sub	sp,-12
80009806:	78 06       	ld.w	r6,r12[0x0]
80009808:	c2 08       	rjmp	80009848 <_vfprintf_r+0x1090>
8000980a:	2f f7       	sub	r7,-1
8000980c:	10 39       	cp.w	r9,r8
8000980e:	c0 84       	brge	8000981e <_vfprintf_r+0x1066>
80009810:	fa c9 f9 44 	sub	r9,sp,-1724
80009814:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009818:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000981c:	c1 68       	rjmp	80009848 <_vfprintf_r+0x1090>
8000981e:	41 09       	lddsp	r9,sp[0x40]
80009820:	59 f8       	cp.w	r8,31
80009822:	e0 89 00 10 	brgt	80009842 <_vfprintf_r+0x108a>
80009826:	f2 ca ff fc 	sub	r10,r9,-4
8000982a:	51 0a       	stdsp	sp[0x40],r10
8000982c:	72 06       	ld.w	r6,r9[0x0]
8000982e:	fa ce f9 44 	sub	lr,sp,-1724
80009832:	fc 08 00 39 	add	r9,lr,r8<<0x3
80009836:	f3 46 fd 88 	st.w	r9[-632],r6
8000983a:	2f f8       	sub	r8,-1
8000983c:	fb 48 06 b4 	st.w	sp[1716],r8
80009840:	c0 48       	rjmp	80009848 <_vfprintf_r+0x1090>
80009842:	72 06       	ld.w	r6,r9[0x0]
80009844:	2f c9       	sub	r9,-4
80009846:	51 09       	stdsp	sp[0x40],r9
80009848:	40 2c       	lddsp	r12,sp[0x8]
8000984a:	58 0c       	cp.w	r12,0
8000984c:	c1 05       	brlt	8000986c <_vfprintf_r+0x10b4>
8000984e:	18 9a       	mov	r10,r12
80009850:	30 0b       	mov	r11,0
80009852:	0c 9c       	mov	r12,r6
80009854:	e0 a0 12 38 	rcall	8000bcc4 <memchr>
80009858:	e0 80 02 df 	breq	80009e16 <_vfprintf_r+0x165e>
8000985c:	f8 06 01 02 	sub	r2,r12,r6
80009860:	40 2b       	lddsp	r11,sp[0x8]
80009862:	16 32       	cp.w	r2,r11
80009864:	e0 89 02 d9 	brgt	80009e16 <_vfprintf_r+0x165e>
80009868:	e0 8f 02 d4 	bral	80009e10 <_vfprintf_r+0x1658>
8000986c:	30 0a       	mov	r10,0
8000986e:	0c 9c       	mov	r12,r6
80009870:	50 2a       	stdsp	sp[0x8],r10
80009872:	e0 a0 15 99 	rcall	8000c3a4 <strlen>
80009876:	18 92       	mov	r2,r12
80009878:	e0 8f 02 d2 	bral	80009e1c <_vfprintf_r+0x1664>
8000987c:	50 a7       	stdsp	sp[0x28],r7
8000987e:	50 80       	stdsp	sp[0x20],r0
80009880:	0c 97       	mov	r7,r6
80009882:	04 94       	mov	r4,r2
80009884:	06 96       	mov	r6,r3
80009886:	02 92       	mov	r2,r1
80009888:	40 93       	lddsp	r3,sp[0x24]
8000988a:	10 90       	mov	r0,r8
8000988c:	40 41       	lddsp	r1,sp[0x10]
8000988e:	a5 a5       	sbr	r5,0x4
80009890:	c0 a8       	rjmp	800098a4 <_vfprintf_r+0x10ec>
80009892:	50 a7       	stdsp	sp[0x28],r7
80009894:	50 80       	stdsp	sp[0x20],r0
80009896:	0c 97       	mov	r7,r6
80009898:	04 94       	mov	r4,r2
8000989a:	06 96       	mov	r6,r3
8000989c:	02 92       	mov	r2,r1
8000989e:	40 93       	lddsp	r3,sp[0x24]
800098a0:	10 90       	mov	r0,r8
800098a2:	40 41       	lddsp	r1,sp[0x10]
800098a4:	ed b5 00 05 	bld	r5,0x5
800098a8:	c5 61       	brne	80009954 <_vfprintf_r+0x119c>
800098aa:	fa f8 06 b4 	ld.w	r8,sp[1716]
800098ae:	40 39       	lddsp	r9,sp[0xc]
800098b0:	58 09       	cp.w	r9,0
800098b2:	c2 10       	breq	800098f4 <_vfprintf_r+0x113c>
800098b4:	10 36       	cp.w	r6,r8
800098b6:	c0 74       	brge	800098c4 <_vfprintf_r+0x110c>
800098b8:	fa c8 f9 44 	sub	r8,sp,-1724
800098bc:	f0 06 00 36 	add	r6,r8,r6<<0x3
800098c0:	c2 38       	rjmp	80009906 <_vfprintf_r+0x114e>
800098c2:	d7 03       	nop
800098c4:	fa c8 f9 50 	sub	r8,sp,-1712
800098c8:	1a d8       	st.w	--sp,r8
800098ca:	fa c8 fa b8 	sub	r8,sp,-1352
800098ce:	1a d8       	st.w	--sp,r8
800098d0:	fa c8 fb b4 	sub	r8,sp,-1100
800098d4:	1a d8       	st.w	--sp,r8
800098d6:	fa c8 f9 40 	sub	r8,sp,-1728
800098da:	fa c9 ff b4 	sub	r9,sp,-76
800098de:	04 9a       	mov	r10,r2
800098e0:	0c 9b       	mov	r11,r6
800098e2:	08 9c       	mov	r12,r4
800098e4:	fe b0 f5 d2 	rcall	80008488 <get_arg>
800098e8:	2f dd       	sub	sp,-12
800098ea:	f8 e8 00 00 	ld.d	r8,r12[0]
800098ee:	fa e9 00 00 	st.d	sp[0],r8
800098f2:	c2 e8       	rjmp	8000994e <_vfprintf_r+0x1196>
800098f4:	ee ca ff ff 	sub	r10,r7,-1
800098f8:	10 37       	cp.w	r7,r8
800098fa:	c0 b4       	brge	80009910 <_vfprintf_r+0x1158>
800098fc:	fa c8 f9 44 	sub	r8,sp,-1724
80009900:	14 97       	mov	r7,r10
80009902:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009906:	ec ea fd 88 	ld.d	r10,r6[-632]
8000990a:	fa eb 00 00 	st.d	sp[0],r10
8000990e:	c2 08       	rjmp	8000994e <_vfprintf_r+0x1196>
80009910:	41 09       	lddsp	r9,sp[0x40]
80009912:	59 f8       	cp.w	r8,31
80009914:	e0 89 00 16 	brgt	80009940 <_vfprintf_r+0x1188>
80009918:	f2 e6 00 00 	ld.d	r6,r9[0]
8000991c:	f2 cb ff f8 	sub	r11,r9,-8
80009920:	fa e7 00 00 	st.d	sp[0],r6
80009924:	51 0b       	stdsp	sp[0x40],r11
80009926:	fa c6 f9 44 	sub	r6,sp,-1724
8000992a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000992e:	fa e6 00 00 	ld.d	r6,sp[0]
80009932:	f2 e7 fd 88 	st.d	r9[-632],r6
80009936:	2f f8       	sub	r8,-1
80009938:	14 97       	mov	r7,r10
8000993a:	fb 48 06 b4 	st.w	sp[1716],r8
8000993e:	c0 88       	rjmp	8000994e <_vfprintf_r+0x1196>
80009940:	f2 e6 00 00 	ld.d	r6,r9[0]
80009944:	2f 89       	sub	r9,-8
80009946:	fa e7 00 00 	st.d	sp[0],r6
8000994a:	51 09       	stdsp	sp[0x40],r9
8000994c:	14 97       	mov	r7,r10
8000994e:	30 18       	mov	r8,1
80009950:	e0 8f 01 d0 	bral	80009cf0 <_vfprintf_r+0x1538>
80009954:	ed b5 00 04 	bld	r5,0x4
80009958:	c1 61       	brne	80009984 <_vfprintf_r+0x11cc>
8000995a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000995e:	40 3e       	lddsp	lr,sp[0xc]
80009960:	58 0e       	cp.w	lr,0
80009962:	c0 80       	breq	80009972 <_vfprintf_r+0x11ba>
80009964:	10 36       	cp.w	r6,r8
80009966:	c6 74       	brge	80009a34 <_vfprintf_r+0x127c>
80009968:	fa cc f9 44 	sub	r12,sp,-1724
8000996c:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009970:	c8 08       	rjmp	80009a70 <_vfprintf_r+0x12b8>
80009972:	ee ca ff ff 	sub	r10,r7,-1
80009976:	10 37       	cp.w	r7,r8
80009978:	c7 f4       	brge	80009a76 <_vfprintf_r+0x12be>
8000997a:	fa cb f9 44 	sub	r11,sp,-1724
8000997e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009982:	c7 68       	rjmp	80009a6e <_vfprintf_r+0x12b6>
80009984:	ed b5 00 06 	bld	r5,0x6
80009988:	c4 a1       	brne	80009a1c <_vfprintf_r+0x1264>
8000998a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000998e:	40 3c       	lddsp	r12,sp[0xc]
80009990:	58 0c       	cp.w	r12,0
80009992:	c1 d0       	breq	800099cc <_vfprintf_r+0x1214>
80009994:	10 36       	cp.w	r6,r8
80009996:	c0 64       	brge	800099a2 <_vfprintf_r+0x11ea>
80009998:	fa cb f9 44 	sub	r11,sp,-1724
8000999c:	f6 06 00 36 	add	r6,r11,r6<<0x3
800099a0:	c1 f8       	rjmp	800099de <_vfprintf_r+0x1226>
800099a2:	fa c8 f9 50 	sub	r8,sp,-1712
800099a6:	1a d8       	st.w	--sp,r8
800099a8:	fa c8 fa b8 	sub	r8,sp,-1352
800099ac:	1a d8       	st.w	--sp,r8
800099ae:	fa c8 fb b4 	sub	r8,sp,-1100
800099b2:	1a d8       	st.w	--sp,r8
800099b4:	fa c8 f9 40 	sub	r8,sp,-1728
800099b8:	fa c9 ff b4 	sub	r9,sp,-76
800099bc:	04 9a       	mov	r10,r2
800099be:	0c 9b       	mov	r11,r6
800099c0:	08 9c       	mov	r12,r4
800099c2:	fe b0 f5 63 	rcall	80008488 <get_arg>
800099c6:	2f dd       	sub	sp,-12
800099c8:	98 18       	ld.sh	r8,r12[0x2]
800099ca:	c2 68       	rjmp	80009a16 <_vfprintf_r+0x125e>
800099cc:	ee ca ff ff 	sub	r10,r7,-1
800099d0:	10 37       	cp.w	r7,r8
800099d2:	c0 94       	brge	800099e4 <_vfprintf_r+0x122c>
800099d4:	fa c9 f9 44 	sub	r9,sp,-1724
800099d8:	14 97       	mov	r7,r10
800099da:	f2 06 00 36 	add	r6,r9,r6<<0x3
800099de:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800099e2:	c1 a8       	rjmp	80009a16 <_vfprintf_r+0x125e>
800099e4:	41 09       	lddsp	r9,sp[0x40]
800099e6:	59 f8       	cp.w	r8,31
800099e8:	e0 89 00 13 	brgt	80009a0e <_vfprintf_r+0x1256>
800099ec:	f2 cb ff fc 	sub	r11,r9,-4
800099f0:	51 0b       	stdsp	sp[0x40],r11
800099f2:	72 09       	ld.w	r9,r9[0x0]
800099f4:	fa c6 f9 44 	sub	r6,sp,-1724
800099f8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800099fc:	2f f8       	sub	r8,-1
800099fe:	f7 49 fd 88 	st.w	r11[-632],r9
80009a02:	fb 48 06 b4 	st.w	sp[1716],r8
80009a06:	14 97       	mov	r7,r10
80009a08:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009a0c:	c0 58       	rjmp	80009a16 <_vfprintf_r+0x125e>
80009a0e:	92 18       	ld.sh	r8,r9[0x2]
80009a10:	14 97       	mov	r7,r10
80009a12:	2f c9       	sub	r9,-4
80009a14:	51 09       	stdsp	sp[0x40],r9
80009a16:	5c 78       	castu.h	r8
80009a18:	50 18       	stdsp	sp[0x4],r8
80009a1a:	c4 68       	rjmp	80009aa6 <_vfprintf_r+0x12ee>
80009a1c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009a20:	40 3c       	lddsp	r12,sp[0xc]
80009a22:	58 0c       	cp.w	r12,0
80009a24:	c1 d0       	breq	80009a5e <_vfprintf_r+0x12a6>
80009a26:	10 36       	cp.w	r6,r8
80009a28:	c0 64       	brge	80009a34 <_vfprintf_r+0x127c>
80009a2a:	fa cb f9 44 	sub	r11,sp,-1724
80009a2e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009a32:	c1 f8       	rjmp	80009a70 <_vfprintf_r+0x12b8>
80009a34:	fa c8 f9 50 	sub	r8,sp,-1712
80009a38:	1a d8       	st.w	--sp,r8
80009a3a:	fa c8 fa b8 	sub	r8,sp,-1352
80009a3e:	0c 9b       	mov	r11,r6
80009a40:	1a d8       	st.w	--sp,r8
80009a42:	fa c8 fb b4 	sub	r8,sp,-1100
80009a46:	04 9a       	mov	r10,r2
80009a48:	1a d8       	st.w	--sp,r8
80009a4a:	08 9c       	mov	r12,r4
80009a4c:	fa c8 f9 40 	sub	r8,sp,-1728
80009a50:	fa c9 ff b4 	sub	r9,sp,-76
80009a54:	fe b0 f5 1a 	rcall	80008488 <get_arg>
80009a58:	2f dd       	sub	sp,-12
80009a5a:	78 0b       	ld.w	r11,r12[0x0]
80009a5c:	c2 48       	rjmp	80009aa4 <_vfprintf_r+0x12ec>
80009a5e:	ee ca ff ff 	sub	r10,r7,-1
80009a62:	10 37       	cp.w	r7,r8
80009a64:	c0 94       	brge	80009a76 <_vfprintf_r+0x12be>
80009a66:	fa c9 f9 44 	sub	r9,sp,-1724
80009a6a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009a6e:	14 97       	mov	r7,r10
80009a70:	ec fb fd 88 	ld.w	r11,r6[-632]
80009a74:	c1 88       	rjmp	80009aa4 <_vfprintf_r+0x12ec>
80009a76:	41 09       	lddsp	r9,sp[0x40]
80009a78:	59 f8       	cp.w	r8,31
80009a7a:	e0 89 00 11 	brgt	80009a9c <_vfprintf_r+0x12e4>
80009a7e:	f2 cb ff fc 	sub	r11,r9,-4
80009a82:	51 0b       	stdsp	sp[0x40],r11
80009a84:	fa c6 f9 44 	sub	r6,sp,-1724
80009a88:	72 0b       	ld.w	r11,r9[0x0]
80009a8a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009a8e:	f3 4b fd 88 	st.w	r9[-632],r11
80009a92:	2f f8       	sub	r8,-1
80009a94:	14 97       	mov	r7,r10
80009a96:	fb 48 06 b4 	st.w	sp[1716],r8
80009a9a:	c0 58       	rjmp	80009aa4 <_vfprintf_r+0x12ec>
80009a9c:	72 0b       	ld.w	r11,r9[0x0]
80009a9e:	14 97       	mov	r7,r10
80009aa0:	2f c9       	sub	r9,-4
80009aa2:	51 09       	stdsp	sp[0x40],r9
80009aa4:	50 1b       	stdsp	sp[0x4],r11
80009aa6:	30 0e       	mov	lr,0
80009aa8:	30 18       	mov	r8,1
80009aaa:	50 0e       	stdsp	sp[0x0],lr
80009aac:	c2 29       	rjmp	80009cf0 <_vfprintf_r+0x1538>
80009aae:	50 a7       	stdsp	sp[0x28],r7
80009ab0:	50 80       	stdsp	sp[0x20],r0
80009ab2:	0c 97       	mov	r7,r6
80009ab4:	04 94       	mov	r4,r2
80009ab6:	06 96       	mov	r6,r3
80009ab8:	02 92       	mov	r2,r1
80009aba:	fe cc b3 c6 	sub	r12,pc,-19514
80009abe:	40 93       	lddsp	r3,sp[0x24]
80009ac0:	10 90       	mov	r0,r8
80009ac2:	40 41       	lddsp	r1,sp[0x10]
80009ac4:	50 dc       	stdsp	sp[0x34],r12
80009ac6:	ed b5 00 05 	bld	r5,0x5
80009aca:	c5 51       	brne	80009b74 <_vfprintf_r+0x13bc>
80009acc:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009ad0:	40 3b       	lddsp	r11,sp[0xc]
80009ad2:	58 0b       	cp.w	r11,0
80009ad4:	c2 20       	breq	80009b18 <_vfprintf_r+0x1360>
80009ad6:	10 36       	cp.w	r6,r8
80009ad8:	c0 a4       	brge	80009aec <_vfprintf_r+0x1334>
80009ada:	fa ca f9 44 	sub	r10,sp,-1724
80009ade:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009ae2:	ec e8 fd 88 	ld.d	r8,r6[-632]
80009ae6:	fa e9 00 00 	st.d	sp[0],r8
80009aea:	cf 28       	rjmp	80009cce <_vfprintf_r+0x1516>
80009aec:	fa c8 f9 50 	sub	r8,sp,-1712
80009af0:	1a d8       	st.w	--sp,r8
80009af2:	fa c8 fa b8 	sub	r8,sp,-1352
80009af6:	04 9a       	mov	r10,r2
80009af8:	1a d8       	st.w	--sp,r8
80009afa:	0c 9b       	mov	r11,r6
80009afc:	fa c8 fb b4 	sub	r8,sp,-1100
80009b00:	08 9c       	mov	r12,r4
80009b02:	1a d8       	st.w	--sp,r8
80009b04:	fa c8 f9 40 	sub	r8,sp,-1728
80009b08:	fa c9 ff b4 	sub	r9,sp,-76
80009b0c:	fe b0 f4 be 	rcall	80008488 <get_arg>
80009b10:	2f dd       	sub	sp,-12
80009b12:	f8 ea 00 00 	ld.d	r10,r12[0]
80009b16:	c0 c8       	rjmp	80009b2e <_vfprintf_r+0x1376>
80009b18:	ee ca ff ff 	sub	r10,r7,-1
80009b1c:	10 37       	cp.w	r7,r8
80009b1e:	c0 b4       	brge	80009b34 <_vfprintf_r+0x137c>
80009b20:	fa c9 f9 44 	sub	r9,sp,-1724
80009b24:	14 97       	mov	r7,r10
80009b26:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009b2a:	ec ea fd 88 	ld.d	r10,r6[-632]
80009b2e:	fa eb 00 00 	st.d	sp[0],r10
80009b32:	cc e8       	rjmp	80009cce <_vfprintf_r+0x1516>
80009b34:	41 09       	lddsp	r9,sp[0x40]
80009b36:	59 f8       	cp.w	r8,31
80009b38:	e0 89 00 16 	brgt	80009b64 <_vfprintf_r+0x13ac>
80009b3c:	f2 e6 00 00 	ld.d	r6,r9[0]
80009b40:	f2 cb ff f8 	sub	r11,r9,-8
80009b44:	fa e7 00 00 	st.d	sp[0],r6
80009b48:	51 0b       	stdsp	sp[0x40],r11
80009b4a:	fa c6 f9 44 	sub	r6,sp,-1724
80009b4e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009b52:	fa e6 00 00 	ld.d	r6,sp[0]
80009b56:	f2 e7 fd 88 	st.d	r9[-632],r6
80009b5a:	2f f8       	sub	r8,-1
80009b5c:	14 97       	mov	r7,r10
80009b5e:	fb 48 06 b4 	st.w	sp[1716],r8
80009b62:	cb 68       	rjmp	80009cce <_vfprintf_r+0x1516>
80009b64:	f2 e6 00 00 	ld.d	r6,r9[0]
80009b68:	2f 89       	sub	r9,-8
80009b6a:	fa e7 00 00 	st.d	sp[0],r6
80009b6e:	51 09       	stdsp	sp[0x40],r9
80009b70:	14 97       	mov	r7,r10
80009b72:	ca e8       	rjmp	80009cce <_vfprintf_r+0x1516>
80009b74:	ed b5 00 04 	bld	r5,0x4
80009b78:	c1 71       	brne	80009ba6 <_vfprintf_r+0x13ee>
80009b7a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009b7e:	40 3e       	lddsp	lr,sp[0xc]
80009b80:	58 0e       	cp.w	lr,0
80009b82:	c0 80       	breq	80009b92 <_vfprintf_r+0x13da>
80009b84:	10 36       	cp.w	r6,r8
80009b86:	c6 94       	brge	80009c58 <_vfprintf_r+0x14a0>
80009b88:	fa cc f9 44 	sub	r12,sp,-1724
80009b8c:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009b90:	c8 28       	rjmp	80009c94 <_vfprintf_r+0x14dc>
80009b92:	ee ca ff ff 	sub	r10,r7,-1
80009b96:	10 37       	cp.w	r7,r8
80009b98:	e0 84 00 81 	brge	80009c9a <_vfprintf_r+0x14e2>
80009b9c:	fa cb f9 44 	sub	r11,sp,-1724
80009ba0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009ba4:	c7 78       	rjmp	80009c92 <_vfprintf_r+0x14da>
80009ba6:	ed b5 00 06 	bld	r5,0x6
80009baa:	c4 b1       	brne	80009c40 <_vfprintf_r+0x1488>
80009bac:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009bb0:	40 3c       	lddsp	r12,sp[0xc]
80009bb2:	58 0c       	cp.w	r12,0
80009bb4:	c1 d0       	breq	80009bee <_vfprintf_r+0x1436>
80009bb6:	10 36       	cp.w	r6,r8
80009bb8:	c0 64       	brge	80009bc4 <_vfprintf_r+0x140c>
80009bba:	fa cb f9 44 	sub	r11,sp,-1724
80009bbe:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009bc2:	c1 f8       	rjmp	80009c00 <_vfprintf_r+0x1448>
80009bc4:	fa c8 f9 50 	sub	r8,sp,-1712
80009bc8:	1a d8       	st.w	--sp,r8
80009bca:	fa c8 fa b8 	sub	r8,sp,-1352
80009bce:	1a d8       	st.w	--sp,r8
80009bd0:	fa c8 fb b4 	sub	r8,sp,-1100
80009bd4:	1a d8       	st.w	--sp,r8
80009bd6:	fa c8 f9 40 	sub	r8,sp,-1728
80009bda:	fa c9 ff b4 	sub	r9,sp,-76
80009bde:	04 9a       	mov	r10,r2
80009be0:	0c 9b       	mov	r11,r6
80009be2:	08 9c       	mov	r12,r4
80009be4:	fe b0 f4 52 	rcall	80008488 <get_arg>
80009be8:	2f dd       	sub	sp,-12
80009bea:	98 18       	ld.sh	r8,r12[0x2]
80009bec:	c2 78       	rjmp	80009c3a <_vfprintf_r+0x1482>
80009bee:	ee ca ff ff 	sub	r10,r7,-1
80009bf2:	10 37       	cp.w	r7,r8
80009bf4:	c0 a4       	brge	80009c08 <_vfprintf_r+0x1450>
80009bf6:	fa c9 f9 44 	sub	r9,sp,-1724
80009bfa:	14 97       	mov	r7,r10
80009bfc:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009c00:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009c04:	c1 b8       	rjmp	80009c3a <_vfprintf_r+0x1482>
80009c06:	d7 03       	nop
80009c08:	41 09       	lddsp	r9,sp[0x40]
80009c0a:	59 f8       	cp.w	r8,31
80009c0c:	e0 89 00 13 	brgt	80009c32 <_vfprintf_r+0x147a>
80009c10:	f2 cb ff fc 	sub	r11,r9,-4
80009c14:	51 0b       	stdsp	sp[0x40],r11
80009c16:	72 09       	ld.w	r9,r9[0x0]
80009c18:	fa c6 f9 44 	sub	r6,sp,-1724
80009c1c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009c20:	2f f8       	sub	r8,-1
80009c22:	f7 49 fd 88 	st.w	r11[-632],r9
80009c26:	fb 48 06 b4 	st.w	sp[1716],r8
80009c2a:	14 97       	mov	r7,r10
80009c2c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009c30:	c0 58       	rjmp	80009c3a <_vfprintf_r+0x1482>
80009c32:	92 18       	ld.sh	r8,r9[0x2]
80009c34:	14 97       	mov	r7,r10
80009c36:	2f c9       	sub	r9,-4
80009c38:	51 09       	stdsp	sp[0x40],r9
80009c3a:	5c 78       	castu.h	r8
80009c3c:	50 18       	stdsp	sp[0x4],r8
80009c3e:	c4 68       	rjmp	80009cca <_vfprintf_r+0x1512>
80009c40:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009c44:	40 3c       	lddsp	r12,sp[0xc]
80009c46:	58 0c       	cp.w	r12,0
80009c48:	c1 d0       	breq	80009c82 <_vfprintf_r+0x14ca>
80009c4a:	10 36       	cp.w	r6,r8
80009c4c:	c0 64       	brge	80009c58 <_vfprintf_r+0x14a0>
80009c4e:	fa cb f9 44 	sub	r11,sp,-1724
80009c52:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009c56:	c1 f8       	rjmp	80009c94 <_vfprintf_r+0x14dc>
80009c58:	fa c8 f9 50 	sub	r8,sp,-1712
80009c5c:	1a d8       	st.w	--sp,r8
80009c5e:	fa c8 fa b8 	sub	r8,sp,-1352
80009c62:	0c 9b       	mov	r11,r6
80009c64:	1a d8       	st.w	--sp,r8
80009c66:	fa c8 fb b4 	sub	r8,sp,-1100
80009c6a:	04 9a       	mov	r10,r2
80009c6c:	1a d8       	st.w	--sp,r8
80009c6e:	08 9c       	mov	r12,r4
80009c70:	fa c8 f9 40 	sub	r8,sp,-1728
80009c74:	fa c9 ff b4 	sub	r9,sp,-76
80009c78:	fe b0 f4 08 	rcall	80008488 <get_arg>
80009c7c:	2f dd       	sub	sp,-12
80009c7e:	78 0b       	ld.w	r11,r12[0x0]
80009c80:	c2 48       	rjmp	80009cc8 <_vfprintf_r+0x1510>
80009c82:	ee ca ff ff 	sub	r10,r7,-1
80009c86:	10 37       	cp.w	r7,r8
80009c88:	c0 94       	brge	80009c9a <_vfprintf_r+0x14e2>
80009c8a:	fa c9 f9 44 	sub	r9,sp,-1724
80009c8e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009c92:	14 97       	mov	r7,r10
80009c94:	ec fb fd 88 	ld.w	r11,r6[-632]
80009c98:	c1 88       	rjmp	80009cc8 <_vfprintf_r+0x1510>
80009c9a:	41 09       	lddsp	r9,sp[0x40]
80009c9c:	59 f8       	cp.w	r8,31
80009c9e:	e0 89 00 11 	brgt	80009cc0 <_vfprintf_r+0x1508>
80009ca2:	f2 cb ff fc 	sub	r11,r9,-4
80009ca6:	51 0b       	stdsp	sp[0x40],r11
80009ca8:	fa c6 f9 44 	sub	r6,sp,-1724
80009cac:	72 0b       	ld.w	r11,r9[0x0]
80009cae:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009cb2:	f3 4b fd 88 	st.w	r9[-632],r11
80009cb6:	2f f8       	sub	r8,-1
80009cb8:	14 97       	mov	r7,r10
80009cba:	fb 48 06 b4 	st.w	sp[1716],r8
80009cbe:	c0 58       	rjmp	80009cc8 <_vfprintf_r+0x1510>
80009cc0:	72 0b       	ld.w	r11,r9[0x0]
80009cc2:	14 97       	mov	r7,r10
80009cc4:	2f c9       	sub	r9,-4
80009cc6:	51 09       	stdsp	sp[0x40],r9
80009cc8:	50 1b       	stdsp	sp[0x4],r11
80009cca:	30 0e       	mov	lr,0
80009ccc:	50 0e       	stdsp	sp[0x0],lr
80009cce:	40 08       	lddsp	r8,sp[0x0]
80009cd0:	40 1c       	lddsp	r12,sp[0x4]
80009cd2:	18 48       	or	r8,r12
80009cd4:	5f 19       	srne	r9
80009cd6:	0a 98       	mov	r8,r5
80009cd8:	eb e9 00 09 	and	r9,r5,r9
80009cdc:	a1 b8       	sbr	r8,0x1
80009cde:	58 09       	cp.w	r9,0
80009ce0:	c0 70       	breq	80009cee <_vfprintf_r+0x1536>
80009ce2:	10 95       	mov	r5,r8
80009ce4:	fb 60 06 b9 	st.b	sp[1721],r0
80009ce8:	33 08       	mov	r8,48
80009cea:	fb 68 06 b8 	st.b	sp[1720],r8
80009cee:	30 28       	mov	r8,2
80009cf0:	30 09       	mov	r9,0
80009cf2:	fb 69 06 bb 	st.b	sp[1723],r9
80009cf6:	0a 99       	mov	r9,r5
80009cf8:	a7 d9       	cbr	r9,0x7
80009cfa:	40 2b       	lddsp	r11,sp[0x8]
80009cfc:	40 16       	lddsp	r6,sp[0x4]
80009cfe:	58 0b       	cp.w	r11,0
80009d00:	5f 1a       	srne	r10
80009d02:	f2 05 17 40 	movge	r5,r9
80009d06:	fa c2 f9 78 	sub	r2,sp,-1672
80009d0a:	40 09       	lddsp	r9,sp[0x0]
80009d0c:	0c 49       	or	r9,r6
80009d0e:	5f 19       	srne	r9
80009d10:	f5 e9 10 09 	or	r9,r10,r9
80009d14:	c5 c0       	breq	80009dcc <_vfprintf_r+0x1614>
80009d16:	30 19       	mov	r9,1
80009d18:	f2 08 18 00 	cp.b	r8,r9
80009d1c:	c0 60       	breq	80009d28 <_vfprintf_r+0x1570>
80009d1e:	30 29       	mov	r9,2
80009d20:	f2 08 18 00 	cp.b	r8,r9
80009d24:	c0 41       	brne	80009d2c <_vfprintf_r+0x1574>
80009d26:	c3 c8       	rjmp	80009d9e <_vfprintf_r+0x15e6>
80009d28:	04 96       	mov	r6,r2
80009d2a:	c3 08       	rjmp	80009d8a <_vfprintf_r+0x15d2>
80009d2c:	04 96       	mov	r6,r2
80009d2e:	fa e8 00 00 	ld.d	r8,sp[0]
80009d32:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80009d36:	2d 0a       	sub	r10,-48
80009d38:	0c fa       	st.b	--r6,r10
80009d3a:	f0 0b 16 03 	lsr	r11,r8,0x3
80009d3e:	f2 0c 16 03 	lsr	r12,r9,0x3
80009d42:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80009d46:	18 99       	mov	r9,r12
80009d48:	16 98       	mov	r8,r11
80009d4a:	58 08       	cp.w	r8,0
80009d4c:	5c 29       	cpc	r9
80009d4e:	cf 21       	brne	80009d32 <_vfprintf_r+0x157a>
80009d50:	fa e9 00 00 	st.d	sp[0],r8
80009d54:	ed b5 00 00 	bld	r5,0x0
80009d58:	c4 51       	brne	80009de2 <_vfprintf_r+0x162a>
80009d5a:	33 09       	mov	r9,48
80009d5c:	f2 0a 18 00 	cp.b	r10,r9
80009d60:	c4 10       	breq	80009de2 <_vfprintf_r+0x162a>
80009d62:	0c f9       	st.b	--r6,r9
80009d64:	c3 f8       	rjmp	80009de2 <_vfprintf_r+0x162a>
80009d66:	fa ea 00 00 	ld.d	r10,sp[0]
80009d6a:	30 a8       	mov	r8,10
80009d6c:	30 09       	mov	r9,0
80009d6e:	e0 a0 1a 19 	rcall	8000d1a0 <__avr32_umod64>
80009d72:	30 a8       	mov	r8,10
80009d74:	2d 0a       	sub	r10,-48
80009d76:	30 09       	mov	r9,0
80009d78:	ac 8a       	st.b	r6[0x0],r10
80009d7a:	fa ea 00 00 	ld.d	r10,sp[0]
80009d7e:	e0 a0 18 df 	rcall	8000cf3c <__avr32_udiv64>
80009d82:	16 99       	mov	r9,r11
80009d84:	14 98       	mov	r8,r10
80009d86:	fa e9 00 00 	st.d	sp[0],r8
80009d8a:	20 16       	sub	r6,1
80009d8c:	fa ea 00 00 	ld.d	r10,sp[0]
80009d90:	58 9a       	cp.w	r10,9
80009d92:	5c 2b       	cpc	r11
80009d94:	fe 9b ff e9 	brhi	80009d66 <_vfprintf_r+0x15ae>
80009d98:	1b f8       	ld.ub	r8,sp[0x7]
80009d9a:	2d 08       	sub	r8,-48
80009d9c:	c2 08       	rjmp	80009ddc <_vfprintf_r+0x1624>
80009d9e:	04 96       	mov	r6,r2
80009da0:	fa e8 00 00 	ld.d	r8,sp[0]
80009da4:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80009da8:	40 de       	lddsp	lr,sp[0x34]
80009daa:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80009dae:	0c fa       	st.b	--r6,r10
80009db0:	f2 0b 16 04 	lsr	r11,r9,0x4
80009db4:	f0 0a 16 04 	lsr	r10,r8,0x4
80009db8:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009dbc:	16 99       	mov	r9,r11
80009dbe:	14 98       	mov	r8,r10
80009dc0:	58 08       	cp.w	r8,0
80009dc2:	5c 29       	cpc	r9
80009dc4:	cf 01       	brne	80009da4 <_vfprintf_r+0x15ec>
80009dc6:	fa e9 00 00 	st.d	sp[0],r8
80009dca:	c0 c8       	rjmp	80009de2 <_vfprintf_r+0x162a>
80009dcc:	58 08       	cp.w	r8,0
80009dce:	c0 91       	brne	80009de0 <_vfprintf_r+0x1628>
80009dd0:	ed b5 00 00 	bld	r5,0x0
80009dd4:	c0 61       	brne	80009de0 <_vfprintf_r+0x1628>
80009dd6:	fa c6 f9 79 	sub	r6,sp,-1671
80009dda:	33 08       	mov	r8,48
80009ddc:	ac 88       	st.b	r6[0x0],r8
80009dde:	c0 28       	rjmp	80009de2 <_vfprintf_r+0x162a>
80009de0:	04 96       	mov	r6,r2
80009de2:	0c 12       	sub	r2,r6
80009de4:	c1 c8       	rjmp	80009e1c <_vfprintf_r+0x1664>
80009de6:	50 a7       	stdsp	sp[0x28],r7
80009de8:	50 80       	stdsp	sp[0x20],r0
80009dea:	40 93       	lddsp	r3,sp[0x24]
80009dec:	0c 97       	mov	r7,r6
80009dee:	10 90       	mov	r0,r8
80009df0:	04 94       	mov	r4,r2
80009df2:	40 41       	lddsp	r1,sp[0x10]
80009df4:	58 08       	cp.w	r8,0
80009df6:	e0 80 04 4f 	breq	8000a694 <_vfprintf_r+0x1edc>
80009dfa:	fb 68 06 60 	st.b	sp[1632],r8
80009dfe:	30 0c       	mov	r12,0
80009e00:	30 08       	mov	r8,0
80009e02:	30 12       	mov	r2,1
80009e04:	fb 68 06 bb 	st.b	sp[1723],r8
80009e08:	50 2c       	stdsp	sp[0x8],r12
80009e0a:	fa c6 f9 a0 	sub	r6,sp,-1632
80009e0e:	c0 78       	rjmp	80009e1c <_vfprintf_r+0x1664>
80009e10:	30 0b       	mov	r11,0
80009e12:	50 2b       	stdsp	sp[0x8],r11
80009e14:	c0 48       	rjmp	80009e1c <_vfprintf_r+0x1664>
80009e16:	40 22       	lddsp	r2,sp[0x8]
80009e18:	30 0a       	mov	r10,0
80009e1a:	50 2a       	stdsp	sp[0x8],r10
80009e1c:	40 29       	lddsp	r9,sp[0x8]
80009e1e:	e4 09 0c 49 	max	r9,r2,r9
80009e22:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009e26:	50 39       	stdsp	sp[0xc],r9
80009e28:	0a 9e       	mov	lr,r5
80009e2a:	30 09       	mov	r9,0
80009e2c:	e2 1e 00 02 	andl	lr,0x2,COH
80009e30:	f2 08 18 00 	cp.b	r8,r9
80009e34:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80009e38:	f7 b8 01 ff 	subne	r8,-1
80009e3c:	fb f8 1a 03 	st.wne	sp[0xc],r8
80009e40:	0a 9b       	mov	r11,r5
80009e42:	58 0e       	cp.w	lr,0
80009e44:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80009e48:	f7 bc 01 fe 	subne	r12,-2
80009e4c:	fb fc 1a 03 	st.wne	sp[0xc],r12
80009e50:	e2 1b 00 84 	andl	r11,0x84,COH
80009e54:	50 fe       	stdsp	sp[0x3c],lr
80009e56:	50 9b       	stdsp	sp[0x24],r11
80009e58:	c4 71       	brne	80009ee6 <_vfprintf_r+0x172e>
80009e5a:	40 8a       	lddsp	r10,sp[0x20]
80009e5c:	40 39       	lddsp	r9,sp[0xc]
80009e5e:	12 1a       	sub	r10,r9
80009e60:	50 4a       	stdsp	sp[0x10],r10
80009e62:	58 0a       	cp.w	r10,0
80009e64:	e0 89 00 20 	brgt	80009ea4 <_vfprintf_r+0x16ec>
80009e68:	c3 f8       	rjmp	80009ee6 <_vfprintf_r+0x172e>
80009e6a:	2f 09       	sub	r9,-16
80009e6c:	2f f8       	sub	r8,-1
80009e6e:	fe ce b7 62 	sub	lr,pc,-18590
80009e72:	31 0c       	mov	r12,16
80009e74:	fb 49 06 90 	st.w	sp[1680],r9
80009e78:	87 0e       	st.w	r3[0x0],lr
80009e7a:	87 1c       	st.w	r3[0x4],r12
80009e7c:	fb 48 06 8c 	st.w	sp[1676],r8
80009e80:	58 78       	cp.w	r8,7
80009e82:	e0 89 00 04 	brgt	80009e8a <_vfprintf_r+0x16d2>
80009e86:	2f 83       	sub	r3,-8
80009e88:	c0 b8       	rjmp	80009e9e <_vfprintf_r+0x16e6>
80009e8a:	fa ca f9 78 	sub	r10,sp,-1672
80009e8e:	02 9b       	mov	r11,r1
80009e90:	08 9c       	mov	r12,r4
80009e92:	fe b0 f4 85 	rcall	8000879c <__sprint_r>
80009e96:	e0 81 04 10 	brne	8000a6b6 <_vfprintf_r+0x1efe>
80009e9a:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e9e:	40 4b       	lddsp	r11,sp[0x10]
80009ea0:	21 0b       	sub	r11,16
80009ea2:	50 4b       	stdsp	sp[0x10],r11
80009ea4:	fa f9 06 90 	ld.w	r9,sp[1680]
80009ea8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009eac:	fe ca b7 a0 	sub	r10,pc,-18528
80009eb0:	40 4e       	lddsp	lr,sp[0x10]
80009eb2:	59 0e       	cp.w	lr,16
80009eb4:	fe 99 ff db 	brgt	80009e6a <_vfprintf_r+0x16b2>
80009eb8:	1c 09       	add	r9,lr
80009eba:	2f f8       	sub	r8,-1
80009ebc:	87 0a       	st.w	r3[0x0],r10
80009ebe:	fb 49 06 90 	st.w	sp[1680],r9
80009ec2:	87 1e       	st.w	r3[0x4],lr
80009ec4:	fb 48 06 8c 	st.w	sp[1676],r8
80009ec8:	58 78       	cp.w	r8,7
80009eca:	e0 89 00 04 	brgt	80009ed2 <_vfprintf_r+0x171a>
80009ece:	2f 83       	sub	r3,-8
80009ed0:	c0 b8       	rjmp	80009ee6 <_vfprintf_r+0x172e>
80009ed2:	fa ca f9 78 	sub	r10,sp,-1672
80009ed6:	02 9b       	mov	r11,r1
80009ed8:	08 9c       	mov	r12,r4
80009eda:	fe b0 f4 61 	rcall	8000879c <__sprint_r>
80009ede:	e0 81 03 ec 	brne	8000a6b6 <_vfprintf_r+0x1efe>
80009ee2:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ee6:	30 09       	mov	r9,0
80009ee8:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009eec:	f2 08 18 00 	cp.b	r8,r9
80009ef0:	c1 f0       	breq	80009f2e <_vfprintf_r+0x1776>
80009ef2:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ef6:	fa c9 f9 45 	sub	r9,sp,-1723
80009efa:	2f f8       	sub	r8,-1
80009efc:	87 09       	st.w	r3[0x0],r9
80009efe:	fb 48 06 90 	st.w	sp[1680],r8
80009f02:	30 19       	mov	r9,1
80009f04:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009f08:	87 19       	st.w	r3[0x4],r9
80009f0a:	2f f8       	sub	r8,-1
80009f0c:	fb 48 06 8c 	st.w	sp[1676],r8
80009f10:	58 78       	cp.w	r8,7
80009f12:	e0 89 00 04 	brgt	80009f1a <_vfprintf_r+0x1762>
80009f16:	2f 83       	sub	r3,-8
80009f18:	c0 b8       	rjmp	80009f2e <_vfprintf_r+0x1776>
80009f1a:	fa ca f9 78 	sub	r10,sp,-1672
80009f1e:	02 9b       	mov	r11,r1
80009f20:	08 9c       	mov	r12,r4
80009f22:	fe b0 f4 3d 	rcall	8000879c <__sprint_r>
80009f26:	e0 81 03 c8 	brne	8000a6b6 <_vfprintf_r+0x1efe>
80009f2a:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f2e:	40 fc       	lddsp	r12,sp[0x3c]
80009f30:	58 0c       	cp.w	r12,0
80009f32:	c1 f0       	breq	80009f70 <_vfprintf_r+0x17b8>
80009f34:	fa f8 06 90 	ld.w	r8,sp[1680]
80009f38:	fa c9 f9 48 	sub	r9,sp,-1720
80009f3c:	2f e8       	sub	r8,-2
80009f3e:	87 09       	st.w	r3[0x0],r9
80009f40:	fb 48 06 90 	st.w	sp[1680],r8
80009f44:	30 29       	mov	r9,2
80009f46:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009f4a:	87 19       	st.w	r3[0x4],r9
80009f4c:	2f f8       	sub	r8,-1
80009f4e:	fb 48 06 8c 	st.w	sp[1676],r8
80009f52:	58 78       	cp.w	r8,7
80009f54:	e0 89 00 04 	brgt	80009f5c <_vfprintf_r+0x17a4>
80009f58:	2f 83       	sub	r3,-8
80009f5a:	c0 b8       	rjmp	80009f70 <_vfprintf_r+0x17b8>
80009f5c:	fa ca f9 78 	sub	r10,sp,-1672
80009f60:	02 9b       	mov	r11,r1
80009f62:	08 9c       	mov	r12,r4
80009f64:	fe b0 f4 1c 	rcall	8000879c <__sprint_r>
80009f68:	e0 81 03 a7 	brne	8000a6b6 <_vfprintf_r+0x1efe>
80009f6c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f70:	40 9b       	lddsp	r11,sp[0x24]
80009f72:	e0 4b 00 80 	cp.w	r11,128
80009f76:	c4 71       	brne	8000a004 <_vfprintf_r+0x184c>
80009f78:	40 8a       	lddsp	r10,sp[0x20]
80009f7a:	40 39       	lddsp	r9,sp[0xc]
80009f7c:	12 1a       	sub	r10,r9
80009f7e:	50 4a       	stdsp	sp[0x10],r10
80009f80:	58 0a       	cp.w	r10,0
80009f82:	e0 89 00 20 	brgt	80009fc2 <_vfprintf_r+0x180a>
80009f86:	c3 f8       	rjmp	8000a004 <_vfprintf_r+0x184c>
80009f88:	2f 09       	sub	r9,-16
80009f8a:	2f f8       	sub	r8,-1
80009f8c:	fe ce b8 70 	sub	lr,pc,-18320
80009f90:	31 0c       	mov	r12,16
80009f92:	fb 49 06 90 	st.w	sp[1680],r9
80009f96:	87 0e       	st.w	r3[0x0],lr
80009f98:	87 1c       	st.w	r3[0x4],r12
80009f9a:	fb 48 06 8c 	st.w	sp[1676],r8
80009f9e:	58 78       	cp.w	r8,7
80009fa0:	e0 89 00 04 	brgt	80009fa8 <_vfprintf_r+0x17f0>
80009fa4:	2f 83       	sub	r3,-8
80009fa6:	c0 b8       	rjmp	80009fbc <_vfprintf_r+0x1804>
80009fa8:	fa ca f9 78 	sub	r10,sp,-1672
80009fac:	02 9b       	mov	r11,r1
80009fae:	08 9c       	mov	r12,r4
80009fb0:	fe b0 f3 f6 	rcall	8000879c <__sprint_r>
80009fb4:	e0 81 03 81 	brne	8000a6b6 <_vfprintf_r+0x1efe>
80009fb8:	fa c3 f9 e0 	sub	r3,sp,-1568
80009fbc:	40 4b       	lddsp	r11,sp[0x10]
80009fbe:	21 0b       	sub	r11,16
80009fc0:	50 4b       	stdsp	sp[0x10],r11
80009fc2:	fa f9 06 90 	ld.w	r9,sp[1680]
80009fc6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009fca:	fe ca b8 ae 	sub	r10,pc,-18258
80009fce:	40 4e       	lddsp	lr,sp[0x10]
80009fd0:	59 0e       	cp.w	lr,16
80009fd2:	fe 99 ff db 	brgt	80009f88 <_vfprintf_r+0x17d0>
80009fd6:	1c 09       	add	r9,lr
80009fd8:	2f f8       	sub	r8,-1
80009fda:	87 0a       	st.w	r3[0x0],r10
80009fdc:	fb 49 06 90 	st.w	sp[1680],r9
80009fe0:	87 1e       	st.w	r3[0x4],lr
80009fe2:	fb 48 06 8c 	st.w	sp[1676],r8
80009fe6:	58 78       	cp.w	r8,7
80009fe8:	e0 89 00 04 	brgt	80009ff0 <_vfprintf_r+0x1838>
80009fec:	2f 83       	sub	r3,-8
80009fee:	c0 b8       	rjmp	8000a004 <_vfprintf_r+0x184c>
80009ff0:	fa ca f9 78 	sub	r10,sp,-1672
80009ff4:	02 9b       	mov	r11,r1
80009ff6:	08 9c       	mov	r12,r4
80009ff8:	fe b0 f3 d2 	rcall	8000879c <__sprint_r>
80009ffc:	e0 81 03 5d 	brne	8000a6b6 <_vfprintf_r+0x1efe>
8000a000:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a004:	40 2c       	lddsp	r12,sp[0x8]
8000a006:	04 1c       	sub	r12,r2
8000a008:	50 2c       	stdsp	sp[0x8],r12
8000a00a:	58 0c       	cp.w	r12,0
8000a00c:	e0 89 00 20 	brgt	8000a04c <_vfprintf_r+0x1894>
8000a010:	c3 f8       	rjmp	8000a08e <_vfprintf_r+0x18d6>
8000a012:	2f 09       	sub	r9,-16
8000a014:	2f f8       	sub	r8,-1
8000a016:	fe cb b8 fa 	sub	r11,pc,-18182
8000a01a:	31 0a       	mov	r10,16
8000a01c:	fb 49 06 90 	st.w	sp[1680],r9
8000a020:	87 0b       	st.w	r3[0x0],r11
8000a022:	87 1a       	st.w	r3[0x4],r10
8000a024:	fb 48 06 8c 	st.w	sp[1676],r8
8000a028:	58 78       	cp.w	r8,7
8000a02a:	e0 89 00 04 	brgt	8000a032 <_vfprintf_r+0x187a>
8000a02e:	2f 83       	sub	r3,-8
8000a030:	c0 b8       	rjmp	8000a046 <_vfprintf_r+0x188e>
8000a032:	fa ca f9 78 	sub	r10,sp,-1672
8000a036:	02 9b       	mov	r11,r1
8000a038:	08 9c       	mov	r12,r4
8000a03a:	fe b0 f3 b1 	rcall	8000879c <__sprint_r>
8000a03e:	e0 81 03 3c 	brne	8000a6b6 <_vfprintf_r+0x1efe>
8000a042:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a046:	40 29       	lddsp	r9,sp[0x8]
8000a048:	21 09       	sub	r9,16
8000a04a:	50 29       	stdsp	sp[0x8],r9
8000a04c:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a050:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a054:	fe ca b9 38 	sub	r10,pc,-18120
8000a058:	40 2e       	lddsp	lr,sp[0x8]
8000a05a:	59 0e       	cp.w	lr,16
8000a05c:	fe 99 ff db 	brgt	8000a012 <_vfprintf_r+0x185a>
8000a060:	1c 09       	add	r9,lr
8000a062:	2f f8       	sub	r8,-1
8000a064:	87 0a       	st.w	r3[0x0],r10
8000a066:	fb 49 06 90 	st.w	sp[1680],r9
8000a06a:	87 1e       	st.w	r3[0x4],lr
8000a06c:	fb 48 06 8c 	st.w	sp[1676],r8
8000a070:	58 78       	cp.w	r8,7
8000a072:	e0 89 00 04 	brgt	8000a07a <_vfprintf_r+0x18c2>
8000a076:	2f 83       	sub	r3,-8
8000a078:	c0 b8       	rjmp	8000a08e <_vfprintf_r+0x18d6>
8000a07a:	fa ca f9 78 	sub	r10,sp,-1672
8000a07e:	02 9b       	mov	r11,r1
8000a080:	08 9c       	mov	r12,r4
8000a082:	fe b0 f3 8d 	rcall	8000879c <__sprint_r>
8000a086:	e0 81 03 18 	brne	8000a6b6 <_vfprintf_r+0x1efe>
8000a08a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a08e:	ed b5 00 08 	bld	r5,0x8
8000a092:	c0 b0       	breq	8000a0a8 <_vfprintf_r+0x18f0>
8000a094:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a098:	87 12       	st.w	r3[0x4],r2
8000a09a:	87 06       	st.w	r3[0x0],r6
8000a09c:	f0 02 00 02 	add	r2,r8,r2
8000a0a0:	fb 42 06 90 	st.w	sp[1680],r2
8000a0a4:	e0 8f 01 d4 	bral	8000a44c <_vfprintf_r+0x1c94>
8000a0a8:	e0 40 00 65 	cp.w	r0,101
8000a0ac:	e0 8a 01 d6 	brle	8000a458 <_vfprintf_r+0x1ca0>
8000a0b0:	30 08       	mov	r8,0
8000a0b2:	30 09       	mov	r9,0
8000a0b4:	40 5b       	lddsp	r11,sp[0x14]
8000a0b6:	40 7a       	lddsp	r10,sp[0x1c]
8000a0b8:	e0 a0 15 3b 	rcall	8000cb2e <__avr32_f64_cmp_eq>
8000a0bc:	c7 90       	breq	8000a1ae <_vfprintf_r+0x19f6>
8000a0be:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a0c2:	fe c9 b9 ba 	sub	r9,pc,-17990
8000a0c6:	2f f8       	sub	r8,-1
8000a0c8:	87 09       	st.w	r3[0x0],r9
8000a0ca:	fb 48 06 90 	st.w	sp[1680],r8
8000a0ce:	30 19       	mov	r9,1
8000a0d0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a0d4:	87 19       	st.w	r3[0x4],r9
8000a0d6:	2f f8       	sub	r8,-1
8000a0d8:	fb 48 06 8c 	st.w	sp[1676],r8
8000a0dc:	58 78       	cp.w	r8,7
8000a0de:	e0 89 00 05 	brgt	8000a0e8 <_vfprintf_r+0x1930>
8000a0e2:	2f 83       	sub	r3,-8
8000a0e4:	c0 c8       	rjmp	8000a0fc <_vfprintf_r+0x1944>
8000a0e6:	d7 03       	nop
8000a0e8:	fa ca f9 78 	sub	r10,sp,-1672
8000a0ec:	02 9b       	mov	r11,r1
8000a0ee:	08 9c       	mov	r12,r4
8000a0f0:	fe b0 f3 56 	rcall	8000879c <__sprint_r>
8000a0f4:	e0 81 02 e1 	brne	8000a6b6 <_vfprintf_r+0x1efe>
8000a0f8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a0fc:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000a100:	40 6c       	lddsp	r12,sp[0x18]
8000a102:	18 38       	cp.w	r8,r12
8000a104:	c0 55       	brlt	8000a10e <_vfprintf_r+0x1956>
8000a106:	ed b5 00 00 	bld	r5,0x0
8000a10a:	e0 81 02 6b 	brne	8000a5e0 <_vfprintf_r+0x1e28>
8000a10e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a112:	2f f8       	sub	r8,-1
8000a114:	40 cb       	lddsp	r11,sp[0x30]
8000a116:	fb 48 06 90 	st.w	sp[1680],r8
8000a11a:	30 19       	mov	r9,1
8000a11c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a120:	87 0b       	st.w	r3[0x0],r11
8000a122:	2f f8       	sub	r8,-1
8000a124:	87 19       	st.w	r3[0x4],r9
8000a126:	fb 48 06 8c 	st.w	sp[1676],r8
8000a12a:	58 78       	cp.w	r8,7
8000a12c:	e0 89 00 04 	brgt	8000a134 <_vfprintf_r+0x197c>
8000a130:	2f 83       	sub	r3,-8
8000a132:	c0 b8       	rjmp	8000a148 <_vfprintf_r+0x1990>
8000a134:	fa ca f9 78 	sub	r10,sp,-1672
8000a138:	02 9b       	mov	r11,r1
8000a13a:	08 9c       	mov	r12,r4
8000a13c:	fe b0 f3 30 	rcall	8000879c <__sprint_r>
8000a140:	e0 81 02 bb 	brne	8000a6b6 <_vfprintf_r+0x1efe>
8000a144:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a148:	40 66       	lddsp	r6,sp[0x18]
8000a14a:	20 16       	sub	r6,1
8000a14c:	58 06       	cp.w	r6,0
8000a14e:	e0 89 00 1d 	brgt	8000a188 <_vfprintf_r+0x19d0>
8000a152:	e0 8f 02 47 	bral	8000a5e0 <_vfprintf_r+0x1e28>
8000a156:	2f 09       	sub	r9,-16
8000a158:	2f f8       	sub	r8,-1
8000a15a:	fb 49 06 90 	st.w	sp[1680],r9
8000a15e:	87 02       	st.w	r3[0x0],r2
8000a160:	87 10       	st.w	r3[0x4],r0
8000a162:	fb 48 06 8c 	st.w	sp[1676],r8
8000a166:	58 78       	cp.w	r8,7
8000a168:	e0 89 00 04 	brgt	8000a170 <_vfprintf_r+0x19b8>
8000a16c:	2f 83       	sub	r3,-8
8000a16e:	c0 b8       	rjmp	8000a184 <_vfprintf_r+0x19cc>
8000a170:	fa ca f9 78 	sub	r10,sp,-1672
8000a174:	02 9b       	mov	r11,r1
8000a176:	08 9c       	mov	r12,r4
8000a178:	fe b0 f3 12 	rcall	8000879c <__sprint_r>
8000a17c:	e0 81 02 9d 	brne	8000a6b6 <_vfprintf_r+0x1efe>
8000a180:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a184:	21 06       	sub	r6,16
8000a186:	c0 48       	rjmp	8000a18e <_vfprintf_r+0x19d6>
8000a188:	fe c2 ba 6c 	sub	r2,pc,-17812
8000a18c:	31 00       	mov	r0,16
8000a18e:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a192:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a196:	fe ca ba 7a 	sub	r10,pc,-17798
8000a19a:	59 06       	cp.w	r6,16
8000a19c:	fe 99 ff dd 	brgt	8000a156 <_vfprintf_r+0x199e>
8000a1a0:	0c 09       	add	r9,r6
8000a1a2:	87 0a       	st.w	r3[0x0],r10
8000a1a4:	fb 49 06 90 	st.w	sp[1680],r9
8000a1a8:	2f f8       	sub	r8,-1
8000a1aa:	87 16       	st.w	r3[0x4],r6
8000a1ac:	c5 39       	rjmp	8000a452 <_vfprintf_r+0x1c9a>
8000a1ae:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000a1b2:	58 0a       	cp.w	r10,0
8000a1b4:	e0 89 00 92 	brgt	8000a2d8 <_vfprintf_r+0x1b20>
8000a1b8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a1bc:	fe c9 ba b4 	sub	r9,pc,-17740
8000a1c0:	2f f8       	sub	r8,-1
8000a1c2:	87 09       	st.w	r3[0x0],r9
8000a1c4:	fb 48 06 90 	st.w	sp[1680],r8
8000a1c8:	30 19       	mov	r9,1
8000a1ca:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a1ce:	87 19       	st.w	r3[0x4],r9
8000a1d0:	2f f8       	sub	r8,-1
8000a1d2:	fb 48 06 8c 	st.w	sp[1676],r8
8000a1d6:	58 78       	cp.w	r8,7
8000a1d8:	e0 89 00 04 	brgt	8000a1e0 <_vfprintf_r+0x1a28>
8000a1dc:	2f 83       	sub	r3,-8
8000a1de:	c0 b8       	rjmp	8000a1f4 <_vfprintf_r+0x1a3c>
8000a1e0:	fa ca f9 78 	sub	r10,sp,-1672
8000a1e4:	02 9b       	mov	r11,r1
8000a1e6:	08 9c       	mov	r12,r4
8000a1e8:	fe b0 f2 da 	rcall	8000879c <__sprint_r>
8000a1ec:	e0 81 02 65 	brne	8000a6b6 <_vfprintf_r+0x1efe>
8000a1f0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a1f4:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000a1f8:	58 08       	cp.w	r8,0
8000a1fa:	c0 81       	brne	8000a20a <_vfprintf_r+0x1a52>
8000a1fc:	40 6a       	lddsp	r10,sp[0x18]
8000a1fe:	58 0a       	cp.w	r10,0
8000a200:	c0 51       	brne	8000a20a <_vfprintf_r+0x1a52>
8000a202:	ed b5 00 00 	bld	r5,0x0
8000a206:	e0 81 01 ed 	brne	8000a5e0 <_vfprintf_r+0x1e28>
8000a20a:	40 c9       	lddsp	r9,sp[0x30]
8000a20c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a210:	2f f8       	sub	r8,-1
8000a212:	87 09       	st.w	r3[0x0],r9
8000a214:	fb 48 06 90 	st.w	sp[1680],r8
8000a218:	30 19       	mov	r9,1
8000a21a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a21e:	87 19       	st.w	r3[0x4],r9
8000a220:	2f f8       	sub	r8,-1
8000a222:	fb 48 06 8c 	st.w	sp[1676],r8
8000a226:	58 78       	cp.w	r8,7
8000a228:	e0 89 00 04 	brgt	8000a230 <_vfprintf_r+0x1a78>
8000a22c:	2f 83       	sub	r3,-8
8000a22e:	c0 b8       	rjmp	8000a244 <_vfprintf_r+0x1a8c>
8000a230:	fa ca f9 78 	sub	r10,sp,-1672
8000a234:	02 9b       	mov	r11,r1
8000a236:	08 9c       	mov	r12,r4
8000a238:	fe b0 f2 b2 	rcall	8000879c <__sprint_r>
8000a23c:	e0 81 02 3d 	brne	8000a6b6 <_vfprintf_r+0x1efe>
8000a240:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a244:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000a248:	5c 32       	neg	r2
8000a24a:	58 02       	cp.w	r2,0
8000a24c:	e0 89 00 1d 	brgt	8000a286 <_vfprintf_r+0x1ace>
8000a250:	c3 d8       	rjmp	8000a2ca <_vfprintf_r+0x1b12>
8000a252:	2f 09       	sub	r9,-16
8000a254:	2f f8       	sub	r8,-1
8000a256:	31 0e       	mov	lr,16
8000a258:	fb 49 06 90 	st.w	sp[1680],r9
8000a25c:	87 00       	st.w	r3[0x0],r0
8000a25e:	87 1e       	st.w	r3[0x4],lr
8000a260:	fb 48 06 8c 	st.w	sp[1676],r8
8000a264:	58 78       	cp.w	r8,7
8000a266:	e0 89 00 04 	brgt	8000a26e <_vfprintf_r+0x1ab6>
8000a26a:	2f 83       	sub	r3,-8
8000a26c:	c0 b8       	rjmp	8000a282 <_vfprintf_r+0x1aca>
8000a26e:	fa ca f9 78 	sub	r10,sp,-1672
8000a272:	02 9b       	mov	r11,r1
8000a274:	08 9c       	mov	r12,r4
8000a276:	fe b0 f2 93 	rcall	8000879c <__sprint_r>
8000a27a:	e0 81 02 1e 	brne	8000a6b6 <_vfprintf_r+0x1efe>
8000a27e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a282:	21 02       	sub	r2,16
8000a284:	c0 38       	rjmp	8000a28a <_vfprintf_r+0x1ad2>
8000a286:	fe c0 bb 6a 	sub	r0,pc,-17558
8000a28a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a28e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a292:	fe ca bb 76 	sub	r10,pc,-17546
8000a296:	59 02       	cp.w	r2,16
8000a298:	fe 99 ff dd 	brgt	8000a252 <_vfprintf_r+0x1a9a>
8000a29c:	04 09       	add	r9,r2
8000a29e:	2f f8       	sub	r8,-1
8000a2a0:	87 0a       	st.w	r3[0x0],r10
8000a2a2:	fb 49 06 90 	st.w	sp[1680],r9
8000a2a6:	87 12       	st.w	r3[0x4],r2
8000a2a8:	fb 48 06 8c 	st.w	sp[1676],r8
8000a2ac:	58 78       	cp.w	r8,7
8000a2ae:	e0 89 00 04 	brgt	8000a2b6 <_vfprintf_r+0x1afe>
8000a2b2:	2f 83       	sub	r3,-8
8000a2b4:	c0 b8       	rjmp	8000a2ca <_vfprintf_r+0x1b12>
8000a2b6:	fa ca f9 78 	sub	r10,sp,-1672
8000a2ba:	02 9b       	mov	r11,r1
8000a2bc:	08 9c       	mov	r12,r4
8000a2be:	fe b0 f2 6f 	rcall	8000879c <__sprint_r>
8000a2c2:	e0 81 01 fa 	brne	8000a6b6 <_vfprintf_r+0x1efe>
8000a2c6:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a2ca:	40 6c       	lddsp	r12,sp[0x18]
8000a2cc:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a2d0:	87 06       	st.w	r3[0x0],r6
8000a2d2:	87 1c       	st.w	r3[0x4],r12
8000a2d4:	18 08       	add	r8,r12
8000a2d6:	cb 98       	rjmp	8000a448 <_vfprintf_r+0x1c90>
8000a2d8:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a2dc:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a2e0:	40 6b       	lddsp	r11,sp[0x18]
8000a2e2:	16 3a       	cp.w	r10,r11
8000a2e4:	c6 f5       	brlt	8000a3c2 <_vfprintf_r+0x1c0a>
8000a2e6:	16 09       	add	r9,r11
8000a2e8:	2f f8       	sub	r8,-1
8000a2ea:	87 06       	st.w	r3[0x0],r6
8000a2ec:	fb 49 06 90 	st.w	sp[1680],r9
8000a2f0:	87 1b       	st.w	r3[0x4],r11
8000a2f2:	fb 48 06 8c 	st.w	sp[1676],r8
8000a2f6:	58 78       	cp.w	r8,7
8000a2f8:	e0 89 00 04 	brgt	8000a300 <_vfprintf_r+0x1b48>
8000a2fc:	2f 83       	sub	r3,-8
8000a2fe:	c0 b8       	rjmp	8000a314 <_vfprintf_r+0x1b5c>
8000a300:	fa ca f9 78 	sub	r10,sp,-1672
8000a304:	02 9b       	mov	r11,r1
8000a306:	08 9c       	mov	r12,r4
8000a308:	fe b0 f2 4a 	rcall	8000879c <__sprint_r>
8000a30c:	e0 81 01 d5 	brne	8000a6b6 <_vfprintf_r+0x1efe>
8000a310:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a314:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000a318:	40 6a       	lddsp	r10,sp[0x18]
8000a31a:	14 16       	sub	r6,r10
8000a31c:	58 06       	cp.w	r6,0
8000a31e:	e0 89 00 1c 	brgt	8000a356 <_vfprintf_r+0x1b9e>
8000a322:	c3 d8       	rjmp	8000a39c <_vfprintf_r+0x1be4>
8000a324:	2f 09       	sub	r9,-16
8000a326:	2f f8       	sub	r8,-1
8000a328:	fb 49 06 90 	st.w	sp[1680],r9
8000a32c:	87 02       	st.w	r3[0x0],r2
8000a32e:	87 10       	st.w	r3[0x4],r0
8000a330:	fb 48 06 8c 	st.w	sp[1676],r8
8000a334:	58 78       	cp.w	r8,7
8000a336:	e0 89 00 04 	brgt	8000a33e <_vfprintf_r+0x1b86>
8000a33a:	2f 83       	sub	r3,-8
8000a33c:	c0 b8       	rjmp	8000a352 <_vfprintf_r+0x1b9a>
8000a33e:	fa ca f9 78 	sub	r10,sp,-1672
8000a342:	02 9b       	mov	r11,r1
8000a344:	08 9c       	mov	r12,r4
8000a346:	fe b0 f2 2b 	rcall	8000879c <__sprint_r>
8000a34a:	e0 81 01 b6 	brne	8000a6b6 <_vfprintf_r+0x1efe>
8000a34e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a352:	21 06       	sub	r6,16
8000a354:	c0 48       	rjmp	8000a35c <_vfprintf_r+0x1ba4>
8000a356:	fe c2 bc 3a 	sub	r2,pc,-17350
8000a35a:	31 00       	mov	r0,16
8000a35c:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a360:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a364:	fe ca bc 48 	sub	r10,pc,-17336
8000a368:	59 06       	cp.w	r6,16
8000a36a:	fe 99 ff dd 	brgt	8000a324 <_vfprintf_r+0x1b6c>
8000a36e:	0c 09       	add	r9,r6
8000a370:	2f f8       	sub	r8,-1
8000a372:	87 0a       	st.w	r3[0x0],r10
8000a374:	fb 49 06 90 	st.w	sp[1680],r9
8000a378:	87 16       	st.w	r3[0x4],r6
8000a37a:	fb 48 06 8c 	st.w	sp[1676],r8
8000a37e:	58 78       	cp.w	r8,7
8000a380:	e0 89 00 04 	brgt	8000a388 <_vfprintf_r+0x1bd0>
8000a384:	2f 83       	sub	r3,-8
8000a386:	c0 b8       	rjmp	8000a39c <_vfprintf_r+0x1be4>
8000a388:	fa ca f9 78 	sub	r10,sp,-1672
8000a38c:	02 9b       	mov	r11,r1
8000a38e:	08 9c       	mov	r12,r4
8000a390:	fe b0 f2 06 	rcall	8000879c <__sprint_r>
8000a394:	e0 81 01 91 	brne	8000a6b6 <_vfprintf_r+0x1efe>
8000a398:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a39c:	ed b5 00 00 	bld	r5,0x0
8000a3a0:	e0 81 01 20 	brne	8000a5e0 <_vfprintf_r+0x1e28>
8000a3a4:	40 c9       	lddsp	r9,sp[0x30]
8000a3a6:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a3aa:	2f f8       	sub	r8,-1
8000a3ac:	87 09       	st.w	r3[0x0],r9
8000a3ae:	fb 48 06 90 	st.w	sp[1680],r8
8000a3b2:	30 19       	mov	r9,1
8000a3b4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a3b8:	87 19       	st.w	r3[0x4],r9
8000a3ba:	2f f8       	sub	r8,-1
8000a3bc:	fb 48 06 8c 	st.w	sp[1676],r8
8000a3c0:	c0 29       	rjmp	8000a5c4 <_vfprintf_r+0x1e0c>
8000a3c2:	14 09       	add	r9,r10
8000a3c4:	2f f8       	sub	r8,-1
8000a3c6:	fb 49 06 90 	st.w	sp[1680],r9
8000a3ca:	87 06       	st.w	r3[0x0],r6
8000a3cc:	87 1a       	st.w	r3[0x4],r10
8000a3ce:	fb 48 06 8c 	st.w	sp[1676],r8
8000a3d2:	58 78       	cp.w	r8,7
8000a3d4:	e0 89 00 04 	brgt	8000a3dc <_vfprintf_r+0x1c24>
8000a3d8:	2f 83       	sub	r3,-8
8000a3da:	c0 b8       	rjmp	8000a3f0 <_vfprintf_r+0x1c38>
8000a3dc:	fa ca f9 78 	sub	r10,sp,-1672
8000a3e0:	02 9b       	mov	r11,r1
8000a3e2:	08 9c       	mov	r12,r4
8000a3e4:	fe b0 f1 dc 	rcall	8000879c <__sprint_r>
8000a3e8:	e0 81 01 67 	brne	8000a6b6 <_vfprintf_r+0x1efe>
8000a3ec:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a3f0:	40 c8       	lddsp	r8,sp[0x30]
8000a3f2:	87 08       	st.w	r3[0x0],r8
8000a3f4:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a3f8:	2f f8       	sub	r8,-1
8000a3fa:	30 19       	mov	r9,1
8000a3fc:	fb 48 06 90 	st.w	sp[1680],r8
8000a400:	87 19       	st.w	r3[0x4],r9
8000a402:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a406:	2f f8       	sub	r8,-1
8000a408:	fb 48 06 8c 	st.w	sp[1676],r8
8000a40c:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000a410:	58 78       	cp.w	r8,7
8000a412:	e0 89 00 04 	brgt	8000a41a <_vfprintf_r+0x1c62>
8000a416:	2f 83       	sub	r3,-8
8000a418:	c0 b8       	rjmp	8000a42e <_vfprintf_r+0x1c76>
8000a41a:	fa ca f9 78 	sub	r10,sp,-1672
8000a41e:	02 9b       	mov	r11,r1
8000a420:	08 9c       	mov	r12,r4
8000a422:	fe b0 f1 bd 	rcall	8000879c <__sprint_r>
8000a426:	e0 81 01 48 	brne	8000a6b6 <_vfprintf_r+0x1efe>
8000a42a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a42e:	04 06       	add	r6,r2
8000a430:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000a434:	87 06       	st.w	r3[0x0],r6
8000a436:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a43a:	40 66       	lddsp	r6,sp[0x18]
8000a43c:	40 6e       	lddsp	lr,sp[0x18]
8000a43e:	10 16       	sub	r6,r8
8000a440:	f2 08 01 08 	sub	r8,r9,r8
8000a444:	87 16       	st.w	r3[0x4],r6
8000a446:	1c 08       	add	r8,lr
8000a448:	fb 48 06 90 	st.w	sp[1680],r8
8000a44c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a450:	2f f8       	sub	r8,-1
8000a452:	fb 48 06 8c 	st.w	sp[1676],r8
8000a456:	cb 78       	rjmp	8000a5c4 <_vfprintf_r+0x1e0c>
8000a458:	40 6c       	lddsp	r12,sp[0x18]
8000a45a:	58 1c       	cp.w	r12,1
8000a45c:	e0 89 00 06 	brgt	8000a468 <_vfprintf_r+0x1cb0>
8000a460:	ed b5 00 00 	bld	r5,0x0
8000a464:	e0 81 00 85 	brne	8000a56e <_vfprintf_r+0x1db6>
8000a468:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a46c:	2f f8       	sub	r8,-1
8000a46e:	30 19       	mov	r9,1
8000a470:	fb 48 06 90 	st.w	sp[1680],r8
8000a474:	87 06       	st.w	r3[0x0],r6
8000a476:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a47a:	87 19       	st.w	r3[0x4],r9
8000a47c:	2f f8       	sub	r8,-1
8000a47e:	fb 48 06 8c 	st.w	sp[1676],r8
8000a482:	58 78       	cp.w	r8,7
8000a484:	e0 89 00 04 	brgt	8000a48c <_vfprintf_r+0x1cd4>
8000a488:	2f 83       	sub	r3,-8
8000a48a:	c0 b8       	rjmp	8000a4a0 <_vfprintf_r+0x1ce8>
8000a48c:	fa ca f9 78 	sub	r10,sp,-1672
8000a490:	02 9b       	mov	r11,r1
8000a492:	08 9c       	mov	r12,r4
8000a494:	fe b0 f1 84 	rcall	8000879c <__sprint_r>
8000a498:	e0 81 01 0f 	brne	8000a6b6 <_vfprintf_r+0x1efe>
8000a49c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a4a0:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a4a4:	2f f8       	sub	r8,-1
8000a4a6:	40 cb       	lddsp	r11,sp[0x30]
8000a4a8:	fb 48 06 90 	st.w	sp[1680],r8
8000a4ac:	30 19       	mov	r9,1
8000a4ae:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a4b2:	87 0b       	st.w	r3[0x0],r11
8000a4b4:	2f f8       	sub	r8,-1
8000a4b6:	87 19       	st.w	r3[0x4],r9
8000a4b8:	fb 48 06 8c 	st.w	sp[1676],r8
8000a4bc:	58 78       	cp.w	r8,7
8000a4be:	e0 89 00 05 	brgt	8000a4c8 <_vfprintf_r+0x1d10>
8000a4c2:	2f 83       	sub	r3,-8
8000a4c4:	c0 c8       	rjmp	8000a4dc <_vfprintf_r+0x1d24>
8000a4c6:	d7 03       	nop
8000a4c8:	fa ca f9 78 	sub	r10,sp,-1672
8000a4cc:	02 9b       	mov	r11,r1
8000a4ce:	08 9c       	mov	r12,r4
8000a4d0:	fe b0 f1 66 	rcall	8000879c <__sprint_r>
8000a4d4:	e0 81 00 f1 	brne	8000a6b6 <_vfprintf_r+0x1efe>
8000a4d8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a4dc:	30 08       	mov	r8,0
8000a4de:	30 09       	mov	r9,0
8000a4e0:	40 5b       	lddsp	r11,sp[0x14]
8000a4e2:	40 7a       	lddsp	r10,sp[0x1c]
8000a4e4:	e0 a0 13 25 	rcall	8000cb2e <__avr32_f64_cmp_eq>
8000a4e8:	40 68       	lddsp	r8,sp[0x18]
8000a4ea:	20 18       	sub	r8,1
8000a4ec:	58 0c       	cp.w	r12,0
8000a4ee:	c0 d1       	brne	8000a508 <_vfprintf_r+0x1d50>
8000a4f0:	2f f6       	sub	r6,-1
8000a4f2:	87 18       	st.w	r3[0x4],r8
8000a4f4:	87 06       	st.w	r3[0x0],r6
8000a4f6:	fa f6 06 90 	ld.w	r6,sp[1680]
8000a4fa:	10 06       	add	r6,r8
8000a4fc:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a500:	fb 46 06 90 	st.w	sp[1680],r6
8000a504:	2f f8       	sub	r8,-1
8000a506:	c3 18       	rjmp	8000a568 <_vfprintf_r+0x1db0>
8000a508:	10 96       	mov	r6,r8
8000a50a:	58 08       	cp.w	r8,0
8000a50c:	e0 89 00 1c 	brgt	8000a544 <_vfprintf_r+0x1d8c>
8000a510:	c4 b8       	rjmp	8000a5a6 <_vfprintf_r+0x1dee>
8000a512:	2f 09       	sub	r9,-16
8000a514:	2f f8       	sub	r8,-1
8000a516:	fb 49 06 90 	st.w	sp[1680],r9
8000a51a:	87 02       	st.w	r3[0x0],r2
8000a51c:	87 10       	st.w	r3[0x4],r0
8000a51e:	fb 48 06 8c 	st.w	sp[1676],r8
8000a522:	58 78       	cp.w	r8,7
8000a524:	e0 89 00 04 	brgt	8000a52c <_vfprintf_r+0x1d74>
8000a528:	2f 83       	sub	r3,-8
8000a52a:	c0 b8       	rjmp	8000a540 <_vfprintf_r+0x1d88>
8000a52c:	fa ca f9 78 	sub	r10,sp,-1672
8000a530:	02 9b       	mov	r11,r1
8000a532:	08 9c       	mov	r12,r4
8000a534:	fe b0 f1 34 	rcall	8000879c <__sprint_r>
8000a538:	e0 81 00 bf 	brne	8000a6b6 <_vfprintf_r+0x1efe>
8000a53c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a540:	21 06       	sub	r6,16
8000a542:	c0 48       	rjmp	8000a54a <_vfprintf_r+0x1d92>
8000a544:	fe c2 be 28 	sub	r2,pc,-16856
8000a548:	31 00       	mov	r0,16
8000a54a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a54e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a552:	fe ca be 36 	sub	r10,pc,-16842
8000a556:	59 06       	cp.w	r6,16
8000a558:	fe 99 ff dd 	brgt	8000a512 <_vfprintf_r+0x1d5a>
8000a55c:	0c 09       	add	r9,r6
8000a55e:	87 0a       	st.w	r3[0x0],r10
8000a560:	fb 49 06 90 	st.w	sp[1680],r9
8000a564:	2f f8       	sub	r8,-1
8000a566:	87 16       	st.w	r3[0x4],r6
8000a568:	fb 48 06 8c 	st.w	sp[1676],r8
8000a56c:	c0 e8       	rjmp	8000a588 <_vfprintf_r+0x1dd0>
8000a56e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a572:	2f f8       	sub	r8,-1
8000a574:	30 19       	mov	r9,1
8000a576:	fb 48 06 90 	st.w	sp[1680],r8
8000a57a:	87 06       	st.w	r3[0x0],r6
8000a57c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a580:	87 19       	st.w	r3[0x4],r9
8000a582:	2f f8       	sub	r8,-1
8000a584:	fb 48 06 8c 	st.w	sp[1676],r8
8000a588:	58 78       	cp.w	r8,7
8000a58a:	e0 89 00 04 	brgt	8000a592 <_vfprintf_r+0x1dda>
8000a58e:	2f 83       	sub	r3,-8
8000a590:	c0 b8       	rjmp	8000a5a6 <_vfprintf_r+0x1dee>
8000a592:	fa ca f9 78 	sub	r10,sp,-1672
8000a596:	02 9b       	mov	r11,r1
8000a598:	08 9c       	mov	r12,r4
8000a59a:	fe b0 f1 01 	rcall	8000879c <__sprint_r>
8000a59e:	e0 81 00 8c 	brne	8000a6b6 <_vfprintf_r+0x1efe>
8000a5a2:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a5a6:	40 ea       	lddsp	r10,sp[0x38]
8000a5a8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a5ac:	14 08       	add	r8,r10
8000a5ae:	fa c9 f9 64 	sub	r9,sp,-1692
8000a5b2:	fb 48 06 90 	st.w	sp[1680],r8
8000a5b6:	87 1a       	st.w	r3[0x4],r10
8000a5b8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a5bc:	87 09       	st.w	r3[0x0],r9
8000a5be:	2f f8       	sub	r8,-1
8000a5c0:	fb 48 06 8c 	st.w	sp[1676],r8
8000a5c4:	58 78       	cp.w	r8,7
8000a5c6:	e0 89 00 04 	brgt	8000a5ce <_vfprintf_r+0x1e16>
8000a5ca:	2f 83       	sub	r3,-8
8000a5cc:	c0 a8       	rjmp	8000a5e0 <_vfprintf_r+0x1e28>
8000a5ce:	fa ca f9 78 	sub	r10,sp,-1672
8000a5d2:	02 9b       	mov	r11,r1
8000a5d4:	08 9c       	mov	r12,r4
8000a5d6:	fe b0 f0 e3 	rcall	8000879c <__sprint_r>
8000a5da:	c6 e1       	brne	8000a6b6 <_vfprintf_r+0x1efe>
8000a5dc:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a5e0:	e2 15 00 04 	andl	r5,0x4,COH
8000a5e4:	c3 f0       	breq	8000a662 <_vfprintf_r+0x1eaa>
8000a5e6:	40 86       	lddsp	r6,sp[0x20]
8000a5e8:	40 39       	lddsp	r9,sp[0xc]
8000a5ea:	12 16       	sub	r6,r9
8000a5ec:	58 06       	cp.w	r6,0
8000a5ee:	e0 89 00 1a 	brgt	8000a622 <_vfprintf_r+0x1e6a>
8000a5f2:	c3 88       	rjmp	8000a662 <_vfprintf_r+0x1eaa>
8000a5f4:	2f 09       	sub	r9,-16
8000a5f6:	2f f8       	sub	r8,-1
8000a5f8:	fb 49 06 90 	st.w	sp[1680],r9
8000a5fc:	87 05       	st.w	r3[0x0],r5
8000a5fe:	87 12       	st.w	r3[0x4],r2
8000a600:	fb 48 06 8c 	st.w	sp[1676],r8
8000a604:	58 78       	cp.w	r8,7
8000a606:	e0 89 00 04 	brgt	8000a60e <_vfprintf_r+0x1e56>
8000a60a:	2f 83       	sub	r3,-8
8000a60c:	c0 98       	rjmp	8000a61e <_vfprintf_r+0x1e66>
8000a60e:	00 9a       	mov	r10,r0
8000a610:	02 9b       	mov	r11,r1
8000a612:	08 9c       	mov	r12,r4
8000a614:	fe b0 f0 c4 	rcall	8000879c <__sprint_r>
8000a618:	c4 f1       	brne	8000a6b6 <_vfprintf_r+0x1efe>
8000a61a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a61e:	21 06       	sub	r6,16
8000a620:	c0 68       	rjmp	8000a62c <_vfprintf_r+0x1e74>
8000a622:	fe c5 bf 16 	sub	r5,pc,-16618
8000a626:	31 02       	mov	r2,16
8000a628:	fa c0 f9 78 	sub	r0,sp,-1672
8000a62c:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a630:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a634:	fe ca bf 28 	sub	r10,pc,-16600
8000a638:	59 06       	cp.w	r6,16
8000a63a:	fe 99 ff dd 	brgt	8000a5f4 <_vfprintf_r+0x1e3c>
8000a63e:	0c 09       	add	r9,r6
8000a640:	2f f8       	sub	r8,-1
8000a642:	87 0a       	st.w	r3[0x0],r10
8000a644:	87 16       	st.w	r3[0x4],r6
8000a646:	fb 49 06 90 	st.w	sp[1680],r9
8000a64a:	fb 48 06 8c 	st.w	sp[1676],r8
8000a64e:	58 78       	cp.w	r8,7
8000a650:	e0 8a 00 09 	brle	8000a662 <_vfprintf_r+0x1eaa>
8000a654:	fa ca f9 78 	sub	r10,sp,-1672
8000a658:	02 9b       	mov	r11,r1
8000a65a:	08 9c       	mov	r12,r4
8000a65c:	fe b0 f0 a0 	rcall	8000879c <__sprint_r>
8000a660:	c2 b1       	brne	8000a6b6 <_vfprintf_r+0x1efe>
8000a662:	40 bc       	lddsp	r12,sp[0x2c]
8000a664:	40 36       	lddsp	r6,sp[0xc]
8000a666:	40 8e       	lddsp	lr,sp[0x20]
8000a668:	ec 0e 0c 48 	max	r8,r6,lr
8000a66c:	10 0c       	add	r12,r8
8000a66e:	50 bc       	stdsp	sp[0x2c],r12
8000a670:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a674:	58 08       	cp.w	r8,0
8000a676:	c0 80       	breq	8000a686 <_vfprintf_r+0x1ece>
8000a678:	fa ca f9 78 	sub	r10,sp,-1672
8000a67c:	02 9b       	mov	r11,r1
8000a67e:	08 9c       	mov	r12,r4
8000a680:	fe b0 f0 8e 	rcall	8000879c <__sprint_r>
8000a684:	c1 91       	brne	8000a6b6 <_vfprintf_r+0x1efe>
8000a686:	30 0b       	mov	r11,0
8000a688:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a68c:	fb 4b 06 8c 	st.w	sp[1676],r11
8000a690:	fe 9f f1 22 	bral	800088d4 <_vfprintf_r+0x11c>
8000a694:	08 95       	mov	r5,r4
8000a696:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a69a:	58 08       	cp.w	r8,0
8000a69c:	c0 80       	breq	8000a6ac <_vfprintf_r+0x1ef4>
8000a69e:	08 9c       	mov	r12,r4
8000a6a0:	fa ca f9 78 	sub	r10,sp,-1672
8000a6a4:	02 9b       	mov	r11,r1
8000a6a6:	fe b0 f0 7b 	rcall	8000879c <__sprint_r>
8000a6aa:	c0 61       	brne	8000a6b6 <_vfprintf_r+0x1efe>
8000a6ac:	30 08       	mov	r8,0
8000a6ae:	fb 48 06 8c 	st.w	sp[1676],r8
8000a6b2:	c0 28       	rjmp	8000a6b6 <_vfprintf_r+0x1efe>
8000a6b4:	40 41       	lddsp	r1,sp[0x10]
8000a6b6:	82 68       	ld.sh	r8,r1[0xc]
8000a6b8:	ed b8 00 06 	bld	r8,0x6
8000a6bc:	c0 31       	brne	8000a6c2 <_vfprintf_r+0x1f0a>
8000a6be:	3f fa       	mov	r10,-1
8000a6c0:	50 ba       	stdsp	sp[0x2c],r10
8000a6c2:	40 bc       	lddsp	r12,sp[0x2c]
8000a6c4:	fe 3d f9 44 	sub	sp,-1724
8000a6c8:	d8 32       	popm	r0-r7,pc
8000a6ca:	d7 03       	nop

8000a6cc <__swsetup_r>:
8000a6cc:	d4 21       	pushm	r4-r7,lr
8000a6ce:	e0 68 0a 48 	mov	r8,2632
8000a6d2:	18 96       	mov	r6,r12
8000a6d4:	16 97       	mov	r7,r11
8000a6d6:	70 0c       	ld.w	r12,r8[0x0]
8000a6d8:	58 0c       	cp.w	r12,0
8000a6da:	c0 60       	breq	8000a6e6 <__swsetup_r+0x1a>
8000a6dc:	78 68       	ld.w	r8,r12[0x18]
8000a6de:	58 08       	cp.w	r8,0
8000a6e0:	c0 31       	brne	8000a6e6 <__swsetup_r+0x1a>
8000a6e2:	e0 a0 07 bf 	rcall	8000b660 <__sinit>
8000a6e6:	fe c8 be aa 	sub	r8,pc,-16726
8000a6ea:	10 37       	cp.w	r7,r8
8000a6ec:	c0 61       	brne	8000a6f8 <__swsetup_r+0x2c>
8000a6ee:	e0 68 0a 48 	mov	r8,2632
8000a6f2:	70 08       	ld.w	r8,r8[0x0]
8000a6f4:	70 07       	ld.w	r7,r8[0x0]
8000a6f6:	c1 28       	rjmp	8000a71a <__swsetup_r+0x4e>
8000a6f8:	fe c8 be 9c 	sub	r8,pc,-16740
8000a6fc:	10 37       	cp.w	r7,r8
8000a6fe:	c0 61       	brne	8000a70a <__swsetup_r+0x3e>
8000a700:	e0 68 0a 48 	mov	r8,2632
8000a704:	70 08       	ld.w	r8,r8[0x0]
8000a706:	70 17       	ld.w	r7,r8[0x4]
8000a708:	c0 98       	rjmp	8000a71a <__swsetup_r+0x4e>
8000a70a:	fe c8 be 8e 	sub	r8,pc,-16754
8000a70e:	10 37       	cp.w	r7,r8
8000a710:	c0 51       	brne	8000a71a <__swsetup_r+0x4e>
8000a712:	e0 68 0a 48 	mov	r8,2632
8000a716:	70 08       	ld.w	r8,r8[0x0]
8000a718:	70 27       	ld.w	r7,r8[0x8]
8000a71a:	8e 68       	ld.sh	r8,r7[0xc]
8000a71c:	ed b8 00 03 	bld	r8,0x3
8000a720:	c1 e0       	breq	8000a75c <__swsetup_r+0x90>
8000a722:	ed b8 00 04 	bld	r8,0x4
8000a726:	c3 e1       	brne	8000a7a2 <__swsetup_r+0xd6>
8000a728:	ed b8 00 02 	bld	r8,0x2
8000a72c:	c1 51       	brne	8000a756 <__swsetup_r+0x8a>
8000a72e:	6e db       	ld.w	r11,r7[0x34]
8000a730:	58 0b       	cp.w	r11,0
8000a732:	c0 a0       	breq	8000a746 <__swsetup_r+0x7a>
8000a734:	ee c8 ff bc 	sub	r8,r7,-68
8000a738:	10 3b       	cp.w	r11,r8
8000a73a:	c0 40       	breq	8000a742 <__swsetup_r+0x76>
8000a73c:	0c 9c       	mov	r12,r6
8000a73e:	e0 a0 08 2b 	rcall	8000b794 <_free_r>
8000a742:	30 08       	mov	r8,0
8000a744:	8f d8       	st.w	r7[0x34],r8
8000a746:	8e 68       	ld.sh	r8,r7[0xc]
8000a748:	e0 18 ff db 	andl	r8,0xffdb
8000a74c:	ae 68       	st.h	r7[0xc],r8
8000a74e:	30 08       	mov	r8,0
8000a750:	8f 18       	st.w	r7[0x4],r8
8000a752:	6e 48       	ld.w	r8,r7[0x10]
8000a754:	8f 08       	st.w	r7[0x0],r8
8000a756:	8e 68       	ld.sh	r8,r7[0xc]
8000a758:	a3 b8       	sbr	r8,0x3
8000a75a:	ae 68       	st.h	r7[0xc],r8
8000a75c:	6e 48       	ld.w	r8,r7[0x10]
8000a75e:	58 08       	cp.w	r8,0
8000a760:	c0 b1       	brne	8000a776 <__swsetup_r+0xaa>
8000a762:	8e 68       	ld.sh	r8,r7[0xc]
8000a764:	e2 18 02 80 	andl	r8,0x280,COH
8000a768:	e0 48 02 00 	cp.w	r8,512
8000a76c:	c0 50       	breq	8000a776 <__swsetup_r+0xaa>
8000a76e:	0c 9c       	mov	r12,r6
8000a770:	0e 9b       	mov	r11,r7
8000a772:	e0 a0 0a 4b 	rcall	8000bc08 <__smakebuf_r>
8000a776:	8e 69       	ld.sh	r9,r7[0xc]
8000a778:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000a77c:	c0 70       	breq	8000a78a <__swsetup_r+0xbe>
8000a77e:	30 08       	mov	r8,0
8000a780:	8f 28       	st.w	r7[0x8],r8
8000a782:	6e 58       	ld.w	r8,r7[0x14]
8000a784:	5c 38       	neg	r8
8000a786:	8f 68       	st.w	r7[0x18],r8
8000a788:	c0 68       	rjmp	8000a794 <__swsetup_r+0xc8>
8000a78a:	ed b9 00 01 	bld	r9,0x1
8000a78e:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000a792:	8f 28       	st.w	r7[0x8],r8
8000a794:	6e 48       	ld.w	r8,r7[0x10]
8000a796:	58 08       	cp.w	r8,0
8000a798:	c0 61       	brne	8000a7a4 <__swsetup_r+0xd8>
8000a79a:	8e 68       	ld.sh	r8,r7[0xc]
8000a79c:	ed b8 00 07 	bld	r8,0x7
8000a7a0:	c0 21       	brne	8000a7a4 <__swsetup_r+0xd8>
8000a7a2:	dc 2a       	popm	r4-r7,pc,r12=-1
8000a7a4:	d8 2a       	popm	r4-r7,pc,r12=0
8000a7a6:	d7 03       	nop

8000a7a8 <quorem>:
8000a7a8:	d4 31       	pushm	r0-r7,lr
8000a7aa:	20 2d       	sub	sp,8
8000a7ac:	18 97       	mov	r7,r12
8000a7ae:	78 48       	ld.w	r8,r12[0x10]
8000a7b0:	76 46       	ld.w	r6,r11[0x10]
8000a7b2:	0c 38       	cp.w	r8,r6
8000a7b4:	c0 34       	brge	8000a7ba <quorem+0x12>
8000a7b6:	30 0c       	mov	r12,0
8000a7b8:	c8 58       	rjmp	8000a8c2 <quorem+0x11a>
8000a7ba:	ec c2 ff fc 	sub	r2,r6,-4
8000a7be:	f6 c3 ff ec 	sub	r3,r11,-20
8000a7c2:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000a7c6:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000a7ca:	2f f9       	sub	r9,-1
8000a7cc:	20 16       	sub	r6,1
8000a7ce:	f8 09 0d 08 	divu	r8,r12,r9
8000a7d2:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000a7d6:	ee c4 ff ec 	sub	r4,r7,-20
8000a7da:	10 95       	mov	r5,r8
8000a7dc:	58 08       	cp.w	r8,0
8000a7de:	c4 10       	breq	8000a860 <quorem+0xb8>
8000a7e0:	30 09       	mov	r9,0
8000a7e2:	06 9a       	mov	r10,r3
8000a7e4:	08 98       	mov	r8,r4
8000a7e6:	12 91       	mov	r1,r9
8000a7e8:	50 0b       	stdsp	sp[0x0],r11
8000a7ea:	70 0e       	ld.w	lr,r8[0x0]
8000a7ec:	b1 8e       	lsr	lr,0x10
8000a7ee:	50 1e       	stdsp	sp[0x4],lr
8000a7f0:	15 0e       	ld.w	lr,r10++
8000a7f2:	fc 00 16 10 	lsr	r0,lr,0x10
8000a7f6:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a7fa:	ea 0e 03 41 	mac	r1,r5,lr
8000a7fe:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000a802:	b1 81       	lsr	r1,0x10
8000a804:	40 1b       	lddsp	r11,sp[0x4]
8000a806:	ea 00 02 40 	mul	r0,r5,r0
8000a80a:	e2 00 00 00 	add	r0,r1,r0
8000a80e:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000a812:	02 1b       	sub	r11,r1
8000a814:	50 1b       	stdsp	sp[0x4],r11
8000a816:	70 0b       	ld.w	r11,r8[0x0]
8000a818:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000a81c:	02 09       	add	r9,r1
8000a81e:	f2 0e 01 0e 	sub	lr,r9,lr
8000a822:	b0 1e       	st.h	r8[0x2],lr
8000a824:	fc 09 14 10 	asr	r9,lr,0x10
8000a828:	40 1e       	lddsp	lr,sp[0x4]
8000a82a:	fc 09 00 09 	add	r9,lr,r9
8000a82e:	b0 09       	st.h	r8[0x0],r9
8000a830:	e0 01 16 10 	lsr	r1,r0,0x10
8000a834:	2f c8       	sub	r8,-4
8000a836:	b1 49       	asr	r9,0x10
8000a838:	04 3a       	cp.w	r10,r2
8000a83a:	fe 98 ff d8 	brls	8000a7ea <quorem+0x42>
8000a83e:	40 0b       	lddsp	r11,sp[0x0]
8000a840:	58 0c       	cp.w	r12,0
8000a842:	c0 f1       	brne	8000a860 <quorem+0xb8>
8000a844:	ec c8 ff fb 	sub	r8,r6,-5
8000a848:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a84c:	c0 28       	rjmp	8000a850 <quorem+0xa8>
8000a84e:	20 16       	sub	r6,1
8000a850:	20 48       	sub	r8,4
8000a852:	08 38       	cp.w	r8,r4
8000a854:	e0 88 00 05 	brls	8000a85e <quorem+0xb6>
8000a858:	70 09       	ld.w	r9,r8[0x0]
8000a85a:	58 09       	cp.w	r9,0
8000a85c:	cf 90       	breq	8000a84e <quorem+0xa6>
8000a85e:	8f 46       	st.w	r7[0x10],r6
8000a860:	0e 9c       	mov	r12,r7
8000a862:	e0 a0 0a d2 	rcall	8000be06 <__mcmp>
8000a866:	c2 d5       	brlt	8000a8c0 <quorem+0x118>
8000a868:	2f f5       	sub	r5,-1
8000a86a:	08 98       	mov	r8,r4
8000a86c:	30 09       	mov	r9,0
8000a86e:	07 0b       	ld.w	r11,r3++
8000a870:	f6 0a 16 10 	lsr	r10,r11,0x10
8000a874:	70 0c       	ld.w	r12,r8[0x0]
8000a876:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a87a:	f8 0e 16 10 	lsr	lr,r12,0x10
8000a87e:	14 1e       	sub	lr,r10
8000a880:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000a884:	16 1a       	sub	r10,r11
8000a886:	12 0a       	add	r10,r9
8000a888:	b0 1a       	st.h	r8[0x2],r10
8000a88a:	b1 4a       	asr	r10,0x10
8000a88c:	fc 0a 00 09 	add	r9,lr,r10
8000a890:	b0 09       	st.h	r8[0x0],r9
8000a892:	2f c8       	sub	r8,-4
8000a894:	b1 49       	asr	r9,0x10
8000a896:	04 33       	cp.w	r3,r2
8000a898:	fe 98 ff eb 	brls	8000a86e <quorem+0xc6>
8000a89c:	ec c8 ff fb 	sub	r8,r6,-5
8000a8a0:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000a8a4:	58 09       	cp.w	r9,0
8000a8a6:	c0 d1       	brne	8000a8c0 <quorem+0x118>
8000a8a8:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a8ac:	c0 28       	rjmp	8000a8b0 <quorem+0x108>
8000a8ae:	20 16       	sub	r6,1
8000a8b0:	20 48       	sub	r8,4
8000a8b2:	08 38       	cp.w	r8,r4
8000a8b4:	e0 88 00 05 	brls	8000a8be <quorem+0x116>
8000a8b8:	70 09       	ld.w	r9,r8[0x0]
8000a8ba:	58 09       	cp.w	r9,0
8000a8bc:	cf 90       	breq	8000a8ae <quorem+0x106>
8000a8be:	8f 46       	st.w	r7[0x10],r6
8000a8c0:	0a 9c       	mov	r12,r5
8000a8c2:	2f ed       	sub	sp,-8
8000a8c4:	d8 32       	popm	r0-r7,pc
8000a8c6:	d7 03       	nop

8000a8c8 <_dtoa_r>:
8000a8c8:	d4 31       	pushm	r0-r7,lr
8000a8ca:	21 ad       	sub	sp,104
8000a8cc:	fa c4 ff 74 	sub	r4,sp,-140
8000a8d0:	18 97       	mov	r7,r12
8000a8d2:	16 95       	mov	r5,r11
8000a8d4:	68 2c       	ld.w	r12,r4[0x8]
8000a8d6:	50 c9       	stdsp	sp[0x30],r9
8000a8d8:	68 16       	ld.w	r6,r4[0x4]
8000a8da:	68 09       	ld.w	r9,r4[0x0]
8000a8dc:	50 e8       	stdsp	sp[0x38],r8
8000a8de:	14 94       	mov	r4,r10
8000a8e0:	51 2c       	stdsp	sp[0x48],r12
8000a8e2:	fa e5 00 08 	st.d	sp[8],r4
8000a8e6:	51 59       	stdsp	sp[0x54],r9
8000a8e8:	6e 95       	ld.w	r5,r7[0x24]
8000a8ea:	58 05       	cp.w	r5,0
8000a8ec:	c0 91       	brne	8000a8fe <_dtoa_r+0x36>
8000a8ee:	31 0c       	mov	r12,16
8000a8f0:	fe b0 e8 e2 	rcall	80007ab4 <malloc>
8000a8f4:	99 35       	st.w	r12[0xc],r5
8000a8f6:	8f 9c       	st.w	r7[0x24],r12
8000a8f8:	99 15       	st.w	r12[0x4],r5
8000a8fa:	99 25       	st.w	r12[0x8],r5
8000a8fc:	99 05       	st.w	r12[0x0],r5
8000a8fe:	6e 99       	ld.w	r9,r7[0x24]
8000a900:	72 08       	ld.w	r8,r9[0x0]
8000a902:	58 08       	cp.w	r8,0
8000a904:	c0 f0       	breq	8000a922 <_dtoa_r+0x5a>
8000a906:	72 1a       	ld.w	r10,r9[0x4]
8000a908:	91 1a       	st.w	r8[0x4],r10
8000a90a:	30 1a       	mov	r10,1
8000a90c:	72 19       	ld.w	r9,r9[0x4]
8000a90e:	f4 09 09 49 	lsl	r9,r10,r9
8000a912:	10 9b       	mov	r11,r8
8000a914:	91 29       	st.w	r8[0x8],r9
8000a916:	0e 9c       	mov	r12,r7
8000a918:	e0 a0 0a 90 	rcall	8000be38 <_Bfree>
8000a91c:	6e 98       	ld.w	r8,r7[0x24]
8000a91e:	30 09       	mov	r9,0
8000a920:	91 09       	st.w	r8[0x0],r9
8000a922:	40 28       	lddsp	r8,sp[0x8]
8000a924:	10 94       	mov	r4,r8
8000a926:	58 08       	cp.w	r8,0
8000a928:	c0 64       	brge	8000a934 <_dtoa_r+0x6c>
8000a92a:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000a92e:	50 28       	stdsp	sp[0x8],r8
8000a930:	30 18       	mov	r8,1
8000a932:	c0 28       	rjmp	8000a936 <_dtoa_r+0x6e>
8000a934:	30 08       	mov	r8,0
8000a936:	8d 08       	st.w	r6[0x0],r8
8000a938:	fc 1c 7f f0 	movh	r12,0x7ff0
8000a93c:	40 26       	lddsp	r6,sp[0x8]
8000a93e:	0c 98       	mov	r8,r6
8000a940:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a944:	18 38       	cp.w	r8,r12
8000a946:	c2 01       	brne	8000a986 <_dtoa_r+0xbe>
8000a948:	e0 68 27 0f 	mov	r8,9999
8000a94c:	41 5b       	lddsp	r11,sp[0x54]
8000a94e:	97 08       	st.w	r11[0x0],r8
8000a950:	40 3a       	lddsp	r10,sp[0xc]
8000a952:	58 0a       	cp.w	r10,0
8000a954:	c0 71       	brne	8000a962 <_dtoa_r+0x9a>
8000a956:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000a95a:	c0 41       	brne	8000a962 <_dtoa_r+0x9a>
8000a95c:	fe cc c1 30 	sub	r12,pc,-16080
8000a960:	c0 38       	rjmp	8000a966 <_dtoa_r+0x9e>
8000a962:	fe cc c1 2a 	sub	r12,pc,-16086
8000a966:	41 29       	lddsp	r9,sp[0x48]
8000a968:	58 09       	cp.w	r9,0
8000a96a:	e0 80 05 9a 	breq	8000b49e <_dtoa_r+0xbd6>
8000a96e:	f8 c8 ff fd 	sub	r8,r12,-3
8000a972:	f8 c9 ff f8 	sub	r9,r12,-8
8000a976:	11 8b       	ld.ub	r11,r8[0x0]
8000a978:	30 0a       	mov	r10,0
8000a97a:	41 25       	lddsp	r5,sp[0x48]
8000a97c:	f4 0b 18 00 	cp.b	r11,r10
8000a980:	f2 08 17 10 	movne	r8,r9
8000a984:	c1 68       	rjmp	8000a9b0 <_dtoa_r+0xe8>
8000a986:	fa ea 00 08 	ld.d	r10,sp[8]
8000a98a:	30 08       	mov	r8,0
8000a98c:	fa eb 00 3c 	st.d	sp[60],r10
8000a990:	30 09       	mov	r9,0
8000a992:	e0 a0 10 ce 	rcall	8000cb2e <__avr32_f64_cmp_eq>
8000a996:	c1 00       	breq	8000a9b6 <_dtoa_r+0xee>
8000a998:	30 18       	mov	r8,1
8000a99a:	41 5a       	lddsp	r10,sp[0x54]
8000a99c:	95 08       	st.w	r10[0x0],r8
8000a99e:	fe cc c2 96 	sub	r12,pc,-15722
8000a9a2:	41 29       	lddsp	r9,sp[0x48]
8000a9a4:	f8 08 00 08 	add	r8,r12,r8
8000a9a8:	58 09       	cp.w	r9,0
8000a9aa:	e0 80 05 7a 	breq	8000b49e <_dtoa_r+0xbd6>
8000a9ae:	12 95       	mov	r5,r9
8000a9b0:	8b 08       	st.w	r5[0x0],r8
8000a9b2:	e0 8f 05 76 	bral	8000b49e <_dtoa_r+0xbd6>
8000a9b6:	fa c8 ff 9c 	sub	r8,sp,-100
8000a9ba:	fa c9 ff a0 	sub	r9,sp,-96
8000a9be:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a9c2:	0e 9c       	mov	r12,r7
8000a9c4:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000a9c8:	e0 a0 0a 8a 	rcall	8000bedc <__d2b>
8000a9cc:	18 93       	mov	r3,r12
8000a9ce:	58 05       	cp.w	r5,0
8000a9d0:	c0 d0       	breq	8000a9ea <_dtoa_r+0x122>
8000a9d2:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a9d6:	30 04       	mov	r4,0
8000a9d8:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000a9dc:	ea c5 03 ff 	sub	r5,r5,1023
8000a9e0:	10 9b       	mov	r11,r8
8000a9e2:	51 74       	stdsp	sp[0x5c],r4
8000a9e4:	ea 1b 3f f0 	orh	r11,0x3ff0
8000a9e8:	c2 58       	rjmp	8000aa32 <_dtoa_r+0x16a>
8000a9ea:	41 88       	lddsp	r8,sp[0x60]
8000a9ec:	41 9c       	lddsp	r12,sp[0x64]
8000a9ee:	10 0c       	add	r12,r8
8000a9f0:	f8 c5 fb ce 	sub	r5,r12,-1074
8000a9f4:	e0 45 00 20 	cp.w	r5,32
8000a9f8:	e0 8a 00 0e 	brle	8000aa14 <_dtoa_r+0x14c>
8000a9fc:	f8 cc fb ee 	sub	r12,r12,-1042
8000aa00:	40 3b       	lddsp	r11,sp[0xc]
8000aa02:	ea 08 11 40 	rsub	r8,r5,64
8000aa06:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000aa0a:	ec 08 09 46 	lsl	r6,r6,r8
8000aa0e:	0c 4c       	or	r12,r6
8000aa10:	c0 78       	rjmp	8000aa1e <_dtoa_r+0x156>
8000aa12:	d7 03       	nop
8000aa14:	ea 0c 11 20 	rsub	r12,r5,32
8000aa18:	40 3a       	lddsp	r10,sp[0xc]
8000aa1a:	f4 0c 09 4c 	lsl	r12,r10,r12
8000aa1e:	e0 a0 10 14 	rcall	8000ca46 <__avr32_u32_to_f64>
8000aa22:	fc 18 fe 10 	movh	r8,0xfe10
8000aa26:	30 19       	mov	r9,1
8000aa28:	ea c5 04 33 	sub	r5,r5,1075
8000aa2c:	f0 0b 00 0b 	add	r11,r8,r11
8000aa30:	51 79       	stdsp	sp[0x5c],r9
8000aa32:	30 08       	mov	r8,0
8000aa34:	fc 19 3f f8 	movh	r9,0x3ff8
8000aa38:	e0 a0 0e 9c 	rcall	8000c770 <__avr32_f64_sub>
8000aa3c:	e0 68 43 61 	mov	r8,17249
8000aa40:	ea 18 63 6f 	orh	r8,0x636f
8000aa44:	e0 69 87 a7 	mov	r9,34727
8000aa48:	ea 19 3f d2 	orh	r9,0x3fd2
8000aa4c:	e0 a0 0d a6 	rcall	8000c598 <__avr32_f64_mul>
8000aa50:	e0 68 c8 b3 	mov	r8,51379
8000aa54:	ea 18 8b 60 	orh	r8,0x8b60
8000aa58:	e0 69 8a 28 	mov	r9,35368
8000aa5c:	ea 19 3f c6 	orh	r9,0x3fc6
8000aa60:	e0 a0 0f 56 	rcall	8000c90c <__avr32_f64_add>
8000aa64:	0a 9c       	mov	r12,r5
8000aa66:	14 90       	mov	r0,r10
8000aa68:	16 91       	mov	r1,r11
8000aa6a:	e0 a0 0f f2 	rcall	8000ca4e <__avr32_s32_to_f64>
8000aa6e:	e0 68 79 fb 	mov	r8,31227
8000aa72:	ea 18 50 9f 	orh	r8,0x509f
8000aa76:	e0 69 44 13 	mov	r9,17427
8000aa7a:	ea 19 3f d3 	orh	r9,0x3fd3
8000aa7e:	e0 a0 0d 8d 	rcall	8000c598 <__avr32_f64_mul>
8000aa82:	14 98       	mov	r8,r10
8000aa84:	16 99       	mov	r9,r11
8000aa86:	00 9a       	mov	r10,r0
8000aa88:	02 9b       	mov	r11,r1
8000aa8a:	e0 a0 0f 41 	rcall	8000c90c <__avr32_f64_add>
8000aa8e:	14 90       	mov	r0,r10
8000aa90:	16 91       	mov	r1,r11
8000aa92:	e0 a0 0f c7 	rcall	8000ca20 <__avr32_f64_to_s32>
8000aa96:	30 08       	mov	r8,0
8000aa98:	18 96       	mov	r6,r12
8000aa9a:	30 09       	mov	r9,0
8000aa9c:	00 9a       	mov	r10,r0
8000aa9e:	02 9b       	mov	r11,r1
8000aaa0:	e0 a0 10 8e 	rcall	8000cbbc <__avr32_f64_cmp_lt>
8000aaa4:	c0 c0       	breq	8000aabc <_dtoa_r+0x1f4>
8000aaa6:	0c 9c       	mov	r12,r6
8000aaa8:	e0 a0 0f d3 	rcall	8000ca4e <__avr32_s32_to_f64>
8000aaac:	14 98       	mov	r8,r10
8000aaae:	16 99       	mov	r9,r11
8000aab0:	00 9a       	mov	r10,r0
8000aab2:	02 9b       	mov	r11,r1
8000aab4:	e0 a0 10 3d 	rcall	8000cb2e <__avr32_f64_cmp_eq>
8000aab8:	f7 b6 00 01 	subeq	r6,1
8000aabc:	59 66       	cp.w	r6,22
8000aabe:	e0 88 00 05 	brls	8000aac8 <_dtoa_r+0x200>
8000aac2:	30 18       	mov	r8,1
8000aac4:	51 48       	stdsp	sp[0x50],r8
8000aac6:	c1 38       	rjmp	8000aaec <_dtoa_r+0x224>
8000aac8:	fe c8 c1 dc 	sub	r8,pc,-15908
8000aacc:	fa ea 00 3c 	ld.d	r10,sp[60]
8000aad0:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000aad4:	e0 a0 10 74 	rcall	8000cbbc <__avr32_f64_cmp_lt>
8000aad8:	f9 b4 00 00 	moveq	r4,0
8000aadc:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000aae0:	f7 b6 01 01 	subne	r6,1
8000aae4:	f9 bc 01 00 	movne	r12,0
8000aae8:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000aaec:	41 90       	lddsp	r0,sp[0x64]
8000aaee:	20 10       	sub	r0,1
8000aaf0:	0a 10       	sub	r0,r5
8000aaf2:	c0 46       	brmi	8000aafa <_dtoa_r+0x232>
8000aaf4:	50 40       	stdsp	sp[0x10],r0
8000aaf6:	30 00       	mov	r0,0
8000aaf8:	c0 48       	rjmp	8000ab00 <_dtoa_r+0x238>
8000aafa:	30 0b       	mov	r11,0
8000aafc:	5c 30       	neg	r0
8000aafe:	50 4b       	stdsp	sp[0x10],r11
8000ab00:	ec 02 11 00 	rsub	r2,r6,0
8000ab04:	58 06       	cp.w	r6,0
8000ab06:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000ab0a:	f5 d6 e4 0a 	addge	r10,r10,r6
8000ab0e:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000ab12:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000ab16:	f9 b2 04 00 	movge	r2,0
8000ab1a:	e1 d6 e5 10 	sublt	r0,r0,r6
8000ab1e:	f9 b9 05 00 	movlt	r9,0
8000ab22:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000ab26:	40 c8       	lddsp	r8,sp[0x30]
8000ab28:	58 98       	cp.w	r8,9
8000ab2a:	e0 8b 00 20 	brhi	8000ab6a <_dtoa_r+0x2a2>
8000ab2e:	58 58       	cp.w	r8,5
8000ab30:	f9 b4 0a 01 	movle	r4,1
8000ab34:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000ab38:	f7 b5 09 04 	subgt	r5,4
8000ab3c:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000ab40:	f9 b4 09 00 	movgt	r4,0
8000ab44:	40 cc       	lddsp	r12,sp[0x30]
8000ab46:	58 3c       	cp.w	r12,3
8000ab48:	c2 d0       	breq	8000aba2 <_dtoa_r+0x2da>
8000ab4a:	e0 89 00 05 	brgt	8000ab54 <_dtoa_r+0x28c>
8000ab4e:	58 2c       	cp.w	r12,2
8000ab50:	c1 01       	brne	8000ab70 <_dtoa_r+0x2a8>
8000ab52:	c1 88       	rjmp	8000ab82 <_dtoa_r+0x2ba>
8000ab54:	40 cb       	lddsp	r11,sp[0x30]
8000ab56:	58 4b       	cp.w	r11,4
8000ab58:	c0 60       	breq	8000ab64 <_dtoa_r+0x29c>
8000ab5a:	58 5b       	cp.w	r11,5
8000ab5c:	c0 a1       	brne	8000ab70 <_dtoa_r+0x2a8>
8000ab5e:	30 1a       	mov	r10,1
8000ab60:	50 da       	stdsp	sp[0x34],r10
8000ab62:	c2 28       	rjmp	8000aba6 <_dtoa_r+0x2de>
8000ab64:	30 19       	mov	r9,1
8000ab66:	50 d9       	stdsp	sp[0x34],r9
8000ab68:	c0 f8       	rjmp	8000ab86 <_dtoa_r+0x2be>
8000ab6a:	30 08       	mov	r8,0
8000ab6c:	30 14       	mov	r4,1
8000ab6e:	50 c8       	stdsp	sp[0x30],r8
8000ab70:	3f f5       	mov	r5,-1
8000ab72:	30 1c       	mov	r12,1
8000ab74:	30 0b       	mov	r11,0
8000ab76:	50 95       	stdsp	sp[0x24],r5
8000ab78:	50 dc       	stdsp	sp[0x34],r12
8000ab7a:	0a 91       	mov	r1,r5
8000ab7c:	31 28       	mov	r8,18
8000ab7e:	50 eb       	stdsp	sp[0x38],r11
8000ab80:	c2 08       	rjmp	8000abc0 <_dtoa_r+0x2f8>
8000ab82:	30 0a       	mov	r10,0
8000ab84:	50 da       	stdsp	sp[0x34],r10
8000ab86:	40 e9       	lddsp	r9,sp[0x38]
8000ab88:	58 09       	cp.w	r9,0
8000ab8a:	e0 89 00 07 	brgt	8000ab98 <_dtoa_r+0x2d0>
8000ab8e:	30 18       	mov	r8,1
8000ab90:	50 98       	stdsp	sp[0x24],r8
8000ab92:	10 91       	mov	r1,r8
8000ab94:	50 e8       	stdsp	sp[0x38],r8
8000ab96:	c1 58       	rjmp	8000abc0 <_dtoa_r+0x2f8>
8000ab98:	40 e5       	lddsp	r5,sp[0x38]
8000ab9a:	50 95       	stdsp	sp[0x24],r5
8000ab9c:	0a 91       	mov	r1,r5
8000ab9e:	0a 98       	mov	r8,r5
8000aba0:	c1 08       	rjmp	8000abc0 <_dtoa_r+0x2f8>
8000aba2:	30 0c       	mov	r12,0
8000aba4:	50 dc       	stdsp	sp[0x34],r12
8000aba6:	40 eb       	lddsp	r11,sp[0x38]
8000aba8:	ec 0b 00 0b 	add	r11,r6,r11
8000abac:	50 9b       	stdsp	sp[0x24],r11
8000abae:	16 98       	mov	r8,r11
8000abb0:	2f f8       	sub	r8,-1
8000abb2:	58 08       	cp.w	r8,0
8000abb4:	e0 89 00 05 	brgt	8000abbe <_dtoa_r+0x2f6>
8000abb8:	10 91       	mov	r1,r8
8000abba:	30 18       	mov	r8,1
8000abbc:	c0 28       	rjmp	8000abc0 <_dtoa_r+0x2f8>
8000abbe:	10 91       	mov	r1,r8
8000abc0:	30 09       	mov	r9,0
8000abc2:	6e 9a       	ld.w	r10,r7[0x24]
8000abc4:	95 19       	st.w	r10[0x4],r9
8000abc6:	30 49       	mov	r9,4
8000abc8:	c0 68       	rjmp	8000abd4 <_dtoa_r+0x30c>
8000abca:	d7 03       	nop
8000abcc:	6a 1a       	ld.w	r10,r5[0x4]
8000abce:	a1 79       	lsl	r9,0x1
8000abd0:	2f fa       	sub	r10,-1
8000abd2:	8b 1a       	st.w	r5[0x4],r10
8000abd4:	6e 95       	ld.w	r5,r7[0x24]
8000abd6:	f2 ca ff ec 	sub	r10,r9,-20
8000abda:	10 3a       	cp.w	r10,r8
8000abdc:	fe 98 ff f8 	brls	8000abcc <_dtoa_r+0x304>
8000abe0:	6a 1b       	ld.w	r11,r5[0x4]
8000abe2:	0e 9c       	mov	r12,r7
8000abe4:	e0 a0 09 44 	rcall	8000be6c <_Balloc>
8000abe8:	58 e1       	cp.w	r1,14
8000abea:	5f 88       	srls	r8
8000abec:	8b 0c       	st.w	r5[0x0],r12
8000abee:	f1 e4 00 04 	and	r4,r8,r4
8000abf2:	6e 98       	ld.w	r8,r7[0x24]
8000abf4:	70 08       	ld.w	r8,r8[0x0]
8000abf6:	50 88       	stdsp	sp[0x20],r8
8000abf8:	e0 80 01 82 	breq	8000aefc <_dtoa_r+0x634>
8000abfc:	58 06       	cp.w	r6,0
8000abfe:	e0 8a 00 43 	brle	8000ac84 <_dtoa_r+0x3bc>
8000ac02:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000ac06:	fe c8 c3 1a 	sub	r8,pc,-15590
8000ac0a:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000ac0e:	fa e5 00 18 	st.d	sp[24],r4
8000ac12:	ec 04 14 04 	asr	r4,r6,0x4
8000ac16:	ed b4 00 04 	bld	r4,0x4
8000ac1a:	c0 30       	breq	8000ac20 <_dtoa_r+0x358>
8000ac1c:	30 25       	mov	r5,2
8000ac1e:	c1 08       	rjmp	8000ac3e <_dtoa_r+0x376>
8000ac20:	fe c8 c2 6c 	sub	r8,pc,-15764
8000ac24:	f0 e8 00 20 	ld.d	r8,r8[32]
8000ac28:	fa ea 00 3c 	ld.d	r10,sp[60]
8000ac2c:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000ac30:	e0 a0 0f fa 	rcall	8000cc24 <__avr32_f64_div>
8000ac34:	30 35       	mov	r5,3
8000ac36:	14 98       	mov	r8,r10
8000ac38:	16 99       	mov	r9,r11
8000ac3a:	fa e9 00 08 	st.d	sp[8],r8
8000ac3e:	fe cc c2 8a 	sub	r12,pc,-15734
8000ac42:	50 a3       	stdsp	sp[0x28],r3
8000ac44:	0c 93       	mov	r3,r6
8000ac46:	18 96       	mov	r6,r12
8000ac48:	c0 f8       	rjmp	8000ac66 <_dtoa_r+0x39e>
8000ac4a:	fa ea 00 18 	ld.d	r10,sp[24]
8000ac4e:	ed b4 00 00 	bld	r4,0x0
8000ac52:	c0 81       	brne	8000ac62 <_dtoa_r+0x39a>
8000ac54:	ec e8 00 00 	ld.d	r8,r6[0]
8000ac58:	2f f5       	sub	r5,-1
8000ac5a:	e0 a0 0c 9f 	rcall	8000c598 <__avr32_f64_mul>
8000ac5e:	fa eb 00 18 	st.d	sp[24],r10
8000ac62:	a1 54       	asr	r4,0x1
8000ac64:	2f 86       	sub	r6,-8
8000ac66:	58 04       	cp.w	r4,0
8000ac68:	cf 11       	brne	8000ac4a <_dtoa_r+0x382>
8000ac6a:	fa e8 00 18 	ld.d	r8,sp[24]
8000ac6e:	fa ea 00 08 	ld.d	r10,sp[8]
8000ac72:	06 96       	mov	r6,r3
8000ac74:	e0 a0 0f d8 	rcall	8000cc24 <__avr32_f64_div>
8000ac78:	40 a3       	lddsp	r3,sp[0x28]
8000ac7a:	14 98       	mov	r8,r10
8000ac7c:	16 99       	mov	r9,r11
8000ac7e:	fa e9 00 08 	st.d	sp[8],r8
8000ac82:	c2 f8       	rjmp	8000ace0 <_dtoa_r+0x418>
8000ac84:	ec 08 11 00 	rsub	r8,r6,0
8000ac88:	c0 31       	brne	8000ac8e <_dtoa_r+0x3c6>
8000ac8a:	30 25       	mov	r5,2
8000ac8c:	c2 a8       	rjmp	8000ace0 <_dtoa_r+0x418>
8000ac8e:	fe cc c2 da 	sub	r12,pc,-15654
8000ac92:	f0 04 14 04 	asr	r4,r8,0x4
8000ac96:	50 1c       	stdsp	sp[0x4],r12
8000ac98:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000ac9c:	fe c9 c3 b0 	sub	r9,pc,-15440
8000aca0:	fa ea 00 3c 	ld.d	r10,sp[60]
8000aca4:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000aca8:	e0 a0 0c 78 	rcall	8000c598 <__avr32_f64_mul>
8000acac:	40 1c       	lddsp	r12,sp[0x4]
8000acae:	50 63       	stdsp	sp[0x18],r3
8000acb0:	30 25       	mov	r5,2
8000acb2:	0c 93       	mov	r3,r6
8000acb4:	fa eb 00 08 	st.d	sp[8],r10
8000acb8:	18 96       	mov	r6,r12
8000acba:	c0 f8       	rjmp	8000acd8 <_dtoa_r+0x410>
8000acbc:	fa ea 00 08 	ld.d	r10,sp[8]
8000acc0:	ed b4 00 00 	bld	r4,0x0
8000acc4:	c0 81       	brne	8000acd4 <_dtoa_r+0x40c>
8000acc6:	ec e8 00 00 	ld.d	r8,r6[0]
8000acca:	2f f5       	sub	r5,-1
8000accc:	e0 a0 0c 66 	rcall	8000c598 <__avr32_f64_mul>
8000acd0:	fa eb 00 08 	st.d	sp[8],r10
8000acd4:	a1 54       	asr	r4,0x1
8000acd6:	2f 86       	sub	r6,-8
8000acd8:	58 04       	cp.w	r4,0
8000acda:	cf 11       	brne	8000acbc <_dtoa_r+0x3f4>
8000acdc:	06 96       	mov	r6,r3
8000acde:	40 63       	lddsp	r3,sp[0x18]
8000ace0:	41 4a       	lddsp	r10,sp[0x50]
8000ace2:	58 0a       	cp.w	r10,0
8000ace4:	c2 a0       	breq	8000ad38 <_dtoa_r+0x470>
8000ace6:	fa e8 00 08 	ld.d	r8,sp[8]
8000acea:	58 01       	cp.w	r1,0
8000acec:	5f 94       	srgt	r4
8000acee:	fa e9 00 18 	st.d	sp[24],r8
8000acf2:	30 08       	mov	r8,0
8000acf4:	fc 19 3f f0 	movh	r9,0x3ff0
8000acf8:	fa ea 00 18 	ld.d	r10,sp[24]
8000acfc:	e0 a0 0f 60 	rcall	8000cbbc <__avr32_f64_cmp_lt>
8000ad00:	f9 bc 00 00 	moveq	r12,0
8000ad04:	f9 bc 01 01 	movne	r12,1
8000ad08:	e9 ec 00 0c 	and	r12,r4,r12
8000ad0c:	c1 60       	breq	8000ad38 <_dtoa_r+0x470>
8000ad0e:	40 98       	lddsp	r8,sp[0x24]
8000ad10:	58 08       	cp.w	r8,0
8000ad12:	e0 8a 00 f1 	brle	8000aef4 <_dtoa_r+0x62c>
8000ad16:	30 08       	mov	r8,0
8000ad18:	fc 19 40 24 	movh	r9,0x4024
8000ad1c:	ec c4 00 01 	sub	r4,r6,1
8000ad20:	fa ea 00 18 	ld.d	r10,sp[24]
8000ad24:	2f f5       	sub	r5,-1
8000ad26:	50 64       	stdsp	sp[0x18],r4
8000ad28:	e0 a0 0c 38 	rcall	8000c598 <__avr32_f64_mul>
8000ad2c:	40 94       	lddsp	r4,sp[0x24]
8000ad2e:	14 98       	mov	r8,r10
8000ad30:	16 99       	mov	r9,r11
8000ad32:	fa e9 00 08 	st.d	sp[8],r8
8000ad36:	c0 38       	rjmp	8000ad3c <_dtoa_r+0x474>
8000ad38:	50 66       	stdsp	sp[0x18],r6
8000ad3a:	02 94       	mov	r4,r1
8000ad3c:	0a 9c       	mov	r12,r5
8000ad3e:	e0 a0 0e 88 	rcall	8000ca4e <__avr32_s32_to_f64>
8000ad42:	fa e8 00 08 	ld.d	r8,sp[8]
8000ad46:	e0 a0 0c 29 	rcall	8000c598 <__avr32_f64_mul>
8000ad4a:	30 08       	mov	r8,0
8000ad4c:	fc 19 40 1c 	movh	r9,0x401c
8000ad50:	e0 a0 0d de 	rcall	8000c90c <__avr32_f64_add>
8000ad54:	14 98       	mov	r8,r10
8000ad56:	16 99       	mov	r9,r11
8000ad58:	fa e9 00 28 	st.d	sp[40],r8
8000ad5c:	fc 18 fc c0 	movh	r8,0xfcc0
8000ad60:	40 a5       	lddsp	r5,sp[0x28]
8000ad62:	10 05       	add	r5,r8
8000ad64:	50 a5       	stdsp	sp[0x28],r5
8000ad66:	58 04       	cp.w	r4,0
8000ad68:	c2 11       	brne	8000adaa <_dtoa_r+0x4e2>
8000ad6a:	fa ea 00 08 	ld.d	r10,sp[8]
8000ad6e:	30 08       	mov	r8,0
8000ad70:	fc 19 40 14 	movh	r9,0x4014
8000ad74:	e0 a0 0c fe 	rcall	8000c770 <__avr32_f64_sub>
8000ad78:	40 bc       	lddsp	r12,sp[0x2c]
8000ad7a:	fa eb 00 08 	st.d	sp[8],r10
8000ad7e:	14 98       	mov	r8,r10
8000ad80:	16 99       	mov	r9,r11
8000ad82:	18 9a       	mov	r10,r12
8000ad84:	0a 9b       	mov	r11,r5
8000ad86:	e0 a0 0f 1b 	rcall	8000cbbc <__avr32_f64_cmp_lt>
8000ad8a:	e0 81 02 54 	brne	8000b232 <_dtoa_r+0x96a>
8000ad8e:	0a 98       	mov	r8,r5
8000ad90:	40 b9       	lddsp	r9,sp[0x2c]
8000ad92:	ee 18 80 00 	eorh	r8,0x8000
8000ad96:	fa ea 00 08 	ld.d	r10,sp[8]
8000ad9a:	10 95       	mov	r5,r8
8000ad9c:	12 98       	mov	r8,r9
8000ad9e:	0a 99       	mov	r9,r5
8000ada0:	e0 a0 0f 0e 	rcall	8000cbbc <__avr32_f64_cmp_lt>
8000ada4:	e0 81 02 3e 	brne	8000b220 <_dtoa_r+0x958>
8000ada8:	ca 68       	rjmp	8000aef4 <_dtoa_r+0x62c>
8000adaa:	fe c9 c4 be 	sub	r9,pc,-15170
8000adae:	e8 c8 00 01 	sub	r8,r4,1
8000adb2:	40 d5       	lddsp	r5,sp[0x34]
8000adb4:	58 05       	cp.w	r5,0
8000adb6:	c4 f0       	breq	8000ae54 <_dtoa_r+0x58c>
8000adb8:	30 0c       	mov	r12,0
8000adba:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000adbe:	51 3c       	stdsp	sp[0x4c],r12
8000adc0:	30 0a       	mov	r10,0
8000adc2:	fc 1b 3f e0 	movh	r11,0x3fe0
8000adc6:	e0 a0 0f 2f 	rcall	8000cc24 <__avr32_f64_div>
8000adca:	fa e8 00 28 	ld.d	r8,sp[40]
8000adce:	40 85       	lddsp	r5,sp[0x20]
8000add0:	e0 a0 0c d0 	rcall	8000c770 <__avr32_f64_sub>
8000add4:	fa eb 00 28 	st.d	sp[40],r10
8000add8:	fa ea 00 08 	ld.d	r10,sp[8]
8000addc:	e0 a0 0e 22 	rcall	8000ca20 <__avr32_f64_to_s32>
8000ade0:	51 6c       	stdsp	sp[0x58],r12
8000ade2:	e0 a0 0e 36 	rcall	8000ca4e <__avr32_s32_to_f64>
8000ade6:	14 98       	mov	r8,r10
8000ade8:	16 99       	mov	r9,r11
8000adea:	fa ea 00 08 	ld.d	r10,sp[8]
8000adee:	e0 a0 0c c1 	rcall	8000c770 <__avr32_f64_sub>
8000adf2:	fa eb 00 08 	st.d	sp[8],r10
8000adf6:	41 68       	lddsp	r8,sp[0x58]
8000adf8:	2d 08       	sub	r8,-48
8000adfa:	0a c8       	st.b	r5++,r8
8000adfc:	41 39       	lddsp	r9,sp[0x4c]
8000adfe:	2f f9       	sub	r9,-1
8000ae00:	51 39       	stdsp	sp[0x4c],r9
8000ae02:	fa e8 00 28 	ld.d	r8,sp[40]
8000ae06:	e0 a0 0e db 	rcall	8000cbbc <__avr32_f64_cmp_lt>
8000ae0a:	e0 81 03 39 	brne	8000b47c <_dtoa_r+0xbb4>
8000ae0e:	fa e8 00 08 	ld.d	r8,sp[8]
8000ae12:	30 0a       	mov	r10,0
8000ae14:	fc 1b 3f f0 	movh	r11,0x3ff0
8000ae18:	e0 a0 0c ac 	rcall	8000c770 <__avr32_f64_sub>
8000ae1c:	fa e8 00 28 	ld.d	r8,sp[40]
8000ae20:	e0 a0 0e ce 	rcall	8000cbbc <__avr32_f64_cmp_lt>
8000ae24:	fa ea 00 28 	ld.d	r10,sp[40]
8000ae28:	30 08       	mov	r8,0
8000ae2a:	fc 19 40 24 	movh	r9,0x4024
8000ae2e:	e0 81 00 da 	brne	8000afe2 <_dtoa_r+0x71a>
8000ae32:	41 3c       	lddsp	r12,sp[0x4c]
8000ae34:	08 3c       	cp.w	r12,r4
8000ae36:	c5 f4       	brge	8000aef4 <_dtoa_r+0x62c>
8000ae38:	e0 a0 0b b0 	rcall	8000c598 <__avr32_f64_mul>
8000ae3c:	30 08       	mov	r8,0
8000ae3e:	fa eb 00 28 	st.d	sp[40],r10
8000ae42:	fc 19 40 24 	movh	r9,0x4024
8000ae46:	fa ea 00 08 	ld.d	r10,sp[8]
8000ae4a:	e0 a0 0b a7 	rcall	8000c598 <__avr32_f64_mul>
8000ae4e:	fa eb 00 08 	st.d	sp[8],r10
8000ae52:	cc 3b       	rjmp	8000add8 <_dtoa_r+0x510>
8000ae54:	40 85       	lddsp	r5,sp[0x20]
8000ae56:	08 05       	add	r5,r4
8000ae58:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000ae5c:	51 35       	stdsp	sp[0x4c],r5
8000ae5e:	fa e8 00 28 	ld.d	r8,sp[40]
8000ae62:	40 85       	lddsp	r5,sp[0x20]
8000ae64:	e0 a0 0b 9a 	rcall	8000c598 <__avr32_f64_mul>
8000ae68:	fa eb 00 28 	st.d	sp[40],r10
8000ae6c:	fa ea 00 08 	ld.d	r10,sp[8]
8000ae70:	e0 a0 0d d8 	rcall	8000ca20 <__avr32_f64_to_s32>
8000ae74:	51 6c       	stdsp	sp[0x58],r12
8000ae76:	e0 a0 0d ec 	rcall	8000ca4e <__avr32_s32_to_f64>
8000ae7a:	14 98       	mov	r8,r10
8000ae7c:	16 99       	mov	r9,r11
8000ae7e:	fa ea 00 08 	ld.d	r10,sp[8]
8000ae82:	e0 a0 0c 77 	rcall	8000c770 <__avr32_f64_sub>
8000ae86:	fa eb 00 08 	st.d	sp[8],r10
8000ae8a:	41 68       	lddsp	r8,sp[0x58]
8000ae8c:	2d 08       	sub	r8,-48
8000ae8e:	0a c8       	st.b	r5++,r8
8000ae90:	41 3c       	lddsp	r12,sp[0x4c]
8000ae92:	18 35       	cp.w	r5,r12
8000ae94:	c2 81       	brne	8000aee4 <_dtoa_r+0x61c>
8000ae96:	30 08       	mov	r8,0
8000ae98:	fc 19 3f e0 	movh	r9,0x3fe0
8000ae9c:	fa ea 00 28 	ld.d	r10,sp[40]
8000aea0:	e0 a0 0d 36 	rcall	8000c90c <__avr32_f64_add>
8000aea4:	40 85       	lddsp	r5,sp[0x20]
8000aea6:	fa e8 00 08 	ld.d	r8,sp[8]
8000aeaa:	08 05       	add	r5,r4
8000aeac:	e0 a0 0e 88 	rcall	8000cbbc <__avr32_f64_cmp_lt>
8000aeb0:	e0 81 00 99 	brne	8000afe2 <_dtoa_r+0x71a>
8000aeb4:	fa e8 00 28 	ld.d	r8,sp[40]
8000aeb8:	30 0a       	mov	r10,0
8000aeba:	fc 1b 3f e0 	movh	r11,0x3fe0
8000aebe:	e0 a0 0c 59 	rcall	8000c770 <__avr32_f64_sub>
8000aec2:	14 98       	mov	r8,r10
8000aec4:	16 99       	mov	r9,r11
8000aec6:	fa ea 00 08 	ld.d	r10,sp[8]
8000aeca:	e0 a0 0e 79 	rcall	8000cbbc <__avr32_f64_cmp_lt>
8000aece:	c1 30       	breq	8000aef4 <_dtoa_r+0x62c>
8000aed0:	33 09       	mov	r9,48
8000aed2:	0a 98       	mov	r8,r5
8000aed4:	11 7a       	ld.ub	r10,--r8
8000aed6:	f2 0a 18 00 	cp.b	r10,r9
8000aeda:	e0 81 02 d1 	brne	8000b47c <_dtoa_r+0xbb4>
8000aede:	10 95       	mov	r5,r8
8000aee0:	cf 9b       	rjmp	8000aed2 <_dtoa_r+0x60a>
8000aee2:	d7 03       	nop
8000aee4:	30 08       	mov	r8,0
8000aee6:	fc 19 40 24 	movh	r9,0x4024
8000aeea:	e0 a0 0b 57 	rcall	8000c598 <__avr32_f64_mul>
8000aeee:	fa eb 00 08 	st.d	sp[8],r10
8000aef2:	cb db       	rjmp	8000ae6c <_dtoa_r+0x5a4>
8000aef4:	fa ea 00 3c 	ld.d	r10,sp[60]
8000aef8:	fa eb 00 08 	st.d	sp[8],r10
8000aefc:	58 e6       	cp.w	r6,14
8000aefe:	5f ab       	srle	r11
8000af00:	41 8a       	lddsp	r10,sp[0x60]
8000af02:	30 08       	mov	r8,0
8000af04:	f4 09 11 ff 	rsub	r9,r10,-1
8000af08:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000af0c:	f0 09 18 00 	cp.b	r9,r8
8000af10:	e0 80 00 82 	breq	8000b014 <_dtoa_r+0x74c>
8000af14:	40 ea       	lddsp	r10,sp[0x38]
8000af16:	58 01       	cp.w	r1,0
8000af18:	5f a9       	srle	r9
8000af1a:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000af1e:	fe ca c6 32 	sub	r10,pc,-14798
8000af22:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000af26:	fa e5 00 10 	st.d	sp[16],r4
8000af2a:	f0 09 18 00 	cp.b	r9,r8
8000af2e:	c1 40       	breq	8000af56 <_dtoa_r+0x68e>
8000af30:	58 01       	cp.w	r1,0
8000af32:	e0 81 01 77 	brne	8000b220 <_dtoa_r+0x958>
8000af36:	30 08       	mov	r8,0
8000af38:	fc 19 40 14 	movh	r9,0x4014
8000af3c:	08 9a       	mov	r10,r4
8000af3e:	0a 9b       	mov	r11,r5
8000af40:	e0 a0 0b 2c 	rcall	8000c598 <__avr32_f64_mul>
8000af44:	fa e8 00 08 	ld.d	r8,sp[8]
8000af48:	e0 a0 0e 06 	rcall	8000cb54 <__avr32_f64_cmp_ge>
8000af4c:	e0 81 01 6a 	brne	8000b220 <_dtoa_r+0x958>
8000af50:	02 92       	mov	r2,r1
8000af52:	e0 8f 01 72 	bral	8000b236 <_dtoa_r+0x96e>
8000af56:	40 85       	lddsp	r5,sp[0x20]
8000af58:	30 14       	mov	r4,1
8000af5a:	fa e8 00 10 	ld.d	r8,sp[16]
8000af5e:	fa ea 00 08 	ld.d	r10,sp[8]
8000af62:	e0 a0 0e 61 	rcall	8000cc24 <__avr32_f64_div>
8000af66:	e0 a0 0d 5d 	rcall	8000ca20 <__avr32_f64_to_s32>
8000af6a:	18 92       	mov	r2,r12
8000af6c:	e0 a0 0d 71 	rcall	8000ca4e <__avr32_s32_to_f64>
8000af70:	fa e8 00 10 	ld.d	r8,sp[16]
8000af74:	e0 a0 0b 12 	rcall	8000c598 <__avr32_f64_mul>
8000af78:	14 98       	mov	r8,r10
8000af7a:	16 99       	mov	r9,r11
8000af7c:	fa ea 00 08 	ld.d	r10,sp[8]
8000af80:	e0 a0 0b f8 	rcall	8000c770 <__avr32_f64_sub>
8000af84:	fa eb 00 08 	st.d	sp[8],r10
8000af88:	e4 c8 ff d0 	sub	r8,r2,-48
8000af8c:	0a c8       	st.b	r5++,r8
8000af8e:	fc 19 40 24 	movh	r9,0x4024
8000af92:	30 08       	mov	r8,0
8000af94:	02 34       	cp.w	r4,r1
8000af96:	c3 31       	brne	8000affc <_dtoa_r+0x734>
8000af98:	fa e8 00 08 	ld.d	r8,sp[8]
8000af9c:	e0 a0 0c b8 	rcall	8000c90c <__avr32_f64_add>
8000afa0:	16 91       	mov	r1,r11
8000afa2:	14 90       	mov	r0,r10
8000afa4:	14 98       	mov	r8,r10
8000afa6:	02 99       	mov	r9,r1
8000afa8:	fa ea 00 10 	ld.d	r10,sp[16]
8000afac:	e0 a0 0e 08 	rcall	8000cbbc <__avr32_f64_cmp_lt>
8000afb0:	c1 a1       	brne	8000afe4 <_dtoa_r+0x71c>
8000afb2:	fa e8 00 10 	ld.d	r8,sp[16]
8000afb6:	00 9a       	mov	r10,r0
8000afb8:	02 9b       	mov	r11,r1
8000afba:	e0 a0 0d ba 	rcall	8000cb2e <__avr32_f64_cmp_eq>
8000afbe:	e0 80 02 5e 	breq	8000b47a <_dtoa_r+0xbb2>
8000afc2:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000afc6:	c0 f1       	brne	8000afe4 <_dtoa_r+0x71c>
8000afc8:	e0 8f 02 59 	bral	8000b47a <_dtoa_r+0xbb2>
8000afcc:	40 8a       	lddsp	r10,sp[0x20]
8000afce:	14 38       	cp.w	r8,r10
8000afd0:	c0 30       	breq	8000afd6 <_dtoa_r+0x70e>
8000afd2:	10 95       	mov	r5,r8
8000afd4:	c0 98       	rjmp	8000afe6 <_dtoa_r+0x71e>
8000afd6:	33 08       	mov	r8,48
8000afd8:	40 89       	lddsp	r9,sp[0x20]
8000afda:	2f f6       	sub	r6,-1
8000afdc:	b2 88       	st.b	r9[0x0],r8
8000afde:	40 88       	lddsp	r8,sp[0x20]
8000afe0:	c0 88       	rjmp	8000aff0 <_dtoa_r+0x728>
8000afe2:	40 66       	lddsp	r6,sp[0x18]
8000afe4:	33 99       	mov	r9,57
8000afe6:	0a 98       	mov	r8,r5
8000afe8:	11 7a       	ld.ub	r10,--r8
8000afea:	f2 0a 18 00 	cp.b	r10,r9
8000afee:	ce f0       	breq	8000afcc <_dtoa_r+0x704>
8000aff0:	50 66       	stdsp	sp[0x18],r6
8000aff2:	11 89       	ld.ub	r9,r8[0x0]
8000aff4:	2f f9       	sub	r9,-1
8000aff6:	b0 89       	st.b	r8[0x0],r9
8000aff8:	e0 8f 02 42 	bral	8000b47c <_dtoa_r+0xbb4>
8000affc:	e0 a0 0a ce 	rcall	8000c598 <__avr32_f64_mul>
8000b000:	2f f4       	sub	r4,-1
8000b002:	fa eb 00 08 	st.d	sp[8],r10
8000b006:	30 08       	mov	r8,0
8000b008:	30 09       	mov	r9,0
8000b00a:	e0 a0 0d 92 	rcall	8000cb2e <__avr32_f64_cmp_eq>
8000b00e:	ca 60       	breq	8000af5a <_dtoa_r+0x692>
8000b010:	e0 8f 02 35 	bral	8000b47a <_dtoa_r+0xbb2>
8000b014:	40 d8       	lddsp	r8,sp[0x34]
8000b016:	58 08       	cp.w	r8,0
8000b018:	c0 51       	brne	8000b022 <_dtoa_r+0x75a>
8000b01a:	04 98       	mov	r8,r2
8000b01c:	00 95       	mov	r5,r0
8000b01e:	40 d4       	lddsp	r4,sp[0x34]
8000b020:	c3 78       	rjmp	8000b08e <_dtoa_r+0x7c6>
8000b022:	40 c5       	lddsp	r5,sp[0x30]
8000b024:	58 15       	cp.w	r5,1
8000b026:	e0 89 00 0f 	brgt	8000b044 <_dtoa_r+0x77c>
8000b02a:	41 74       	lddsp	r4,sp[0x5c]
8000b02c:	58 04       	cp.w	r4,0
8000b02e:	c0 40       	breq	8000b036 <_dtoa_r+0x76e>
8000b030:	f4 c9 fb cd 	sub	r9,r10,-1075
8000b034:	c0 48       	rjmp	8000b03c <_dtoa_r+0x774>
8000b036:	41 99       	lddsp	r9,sp[0x64]
8000b038:	f2 09 11 36 	rsub	r9,r9,54
8000b03c:	04 98       	mov	r8,r2
8000b03e:	00 95       	mov	r5,r0
8000b040:	c1 c8       	rjmp	8000b078 <_dtoa_r+0x7b0>
8000b042:	d7 03       	nop
8000b044:	e2 c8 00 01 	sub	r8,r1,1
8000b048:	58 01       	cp.w	r1,0
8000b04a:	e0 05 17 40 	movge	r5,r0
8000b04e:	e2 09 17 40 	movge	r9,r1
8000b052:	e1 d1 e5 15 	sublt	r5,r0,r1
8000b056:	f9 b9 05 00 	movlt	r9,0
8000b05a:	10 32       	cp.w	r2,r8
8000b05c:	e5 d8 e4 18 	subge	r8,r2,r8
8000b060:	f1 d2 e5 18 	sublt	r8,r8,r2
8000b064:	e5 d8 e5 02 	addlt	r2,r2,r8
8000b068:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000b06c:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000b070:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000b074:	f9 b8 05 00 	movlt	r8,0
8000b078:	40 4b       	lddsp	r11,sp[0x10]
8000b07a:	12 0b       	add	r11,r9
8000b07c:	50 08       	stdsp	sp[0x0],r8
8000b07e:	50 4b       	stdsp	sp[0x10],r11
8000b080:	12 00       	add	r0,r9
8000b082:	30 1b       	mov	r11,1
8000b084:	0e 9c       	mov	r12,r7
8000b086:	e0 a0 08 a7 	rcall	8000c1d4 <__i2b>
8000b08a:	40 08       	lddsp	r8,sp[0x0]
8000b08c:	18 94       	mov	r4,r12
8000b08e:	40 4a       	lddsp	r10,sp[0x10]
8000b090:	58 05       	cp.w	r5,0
8000b092:	5f 99       	srgt	r9
8000b094:	58 0a       	cp.w	r10,0
8000b096:	5f 9a       	srgt	r10
8000b098:	f5 e9 00 09 	and	r9,r10,r9
8000b09c:	c0 80       	breq	8000b0ac <_dtoa_r+0x7e4>
8000b09e:	40 4c       	lddsp	r12,sp[0x10]
8000b0a0:	f8 05 0d 49 	min	r9,r12,r5
8000b0a4:	12 1c       	sub	r12,r9
8000b0a6:	12 10       	sub	r0,r9
8000b0a8:	50 4c       	stdsp	sp[0x10],r12
8000b0aa:	12 15       	sub	r5,r9
8000b0ac:	58 02       	cp.w	r2,0
8000b0ae:	e0 8a 00 27 	brle	8000b0fc <_dtoa_r+0x834>
8000b0b2:	40 db       	lddsp	r11,sp[0x34]
8000b0b4:	58 0b       	cp.w	r11,0
8000b0b6:	c1 d0       	breq	8000b0f0 <_dtoa_r+0x828>
8000b0b8:	58 08       	cp.w	r8,0
8000b0ba:	e0 8a 00 17 	brle	8000b0e8 <_dtoa_r+0x820>
8000b0be:	10 9a       	mov	r10,r8
8000b0c0:	50 08       	stdsp	sp[0x0],r8
8000b0c2:	08 9b       	mov	r11,r4
8000b0c4:	0e 9c       	mov	r12,r7
8000b0c6:	e0 a0 08 cd 	rcall	8000c260 <__pow5mult>
8000b0ca:	06 9a       	mov	r10,r3
8000b0cc:	18 9b       	mov	r11,r12
8000b0ce:	18 94       	mov	r4,r12
8000b0d0:	0e 9c       	mov	r12,r7
8000b0d2:	e0 a0 08 01 	rcall	8000c0d4 <__multiply>
8000b0d6:	18 99       	mov	r9,r12
8000b0d8:	06 9b       	mov	r11,r3
8000b0da:	50 19       	stdsp	sp[0x4],r9
8000b0dc:	0e 9c       	mov	r12,r7
8000b0de:	e0 a0 06 ad 	rcall	8000be38 <_Bfree>
8000b0e2:	40 19       	lddsp	r9,sp[0x4]
8000b0e4:	40 08       	lddsp	r8,sp[0x0]
8000b0e6:	12 93       	mov	r3,r9
8000b0e8:	e4 08 01 0a 	sub	r10,r2,r8
8000b0ec:	c0 80       	breq	8000b0fc <_dtoa_r+0x834>
8000b0ee:	c0 28       	rjmp	8000b0f2 <_dtoa_r+0x82a>
8000b0f0:	04 9a       	mov	r10,r2
8000b0f2:	06 9b       	mov	r11,r3
8000b0f4:	0e 9c       	mov	r12,r7
8000b0f6:	e0 a0 08 b5 	rcall	8000c260 <__pow5mult>
8000b0fa:	18 93       	mov	r3,r12
8000b0fc:	30 1b       	mov	r11,1
8000b0fe:	0e 9c       	mov	r12,r7
8000b100:	e0 a0 08 6a 	rcall	8000c1d4 <__i2b>
8000b104:	41 1a       	lddsp	r10,sp[0x44]
8000b106:	18 92       	mov	r2,r12
8000b108:	58 0a       	cp.w	r10,0
8000b10a:	e0 8a 00 07 	brle	8000b118 <_dtoa_r+0x850>
8000b10e:	18 9b       	mov	r11,r12
8000b110:	0e 9c       	mov	r12,r7
8000b112:	e0 a0 08 a7 	rcall	8000c260 <__pow5mult>
8000b116:	18 92       	mov	r2,r12
8000b118:	40 c9       	lddsp	r9,sp[0x30]
8000b11a:	58 19       	cp.w	r9,1
8000b11c:	e0 89 00 14 	brgt	8000b144 <_dtoa_r+0x87c>
8000b120:	40 38       	lddsp	r8,sp[0xc]
8000b122:	58 08       	cp.w	r8,0
8000b124:	c1 01       	brne	8000b144 <_dtoa_r+0x87c>
8000b126:	40 29       	lddsp	r9,sp[0x8]
8000b128:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000b12c:	c0 c1       	brne	8000b144 <_dtoa_r+0x87c>
8000b12e:	12 98       	mov	r8,r9
8000b130:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000b134:	c0 80       	breq	8000b144 <_dtoa_r+0x87c>
8000b136:	40 4c       	lddsp	r12,sp[0x10]
8000b138:	30 1b       	mov	r11,1
8000b13a:	2f fc       	sub	r12,-1
8000b13c:	2f f0       	sub	r0,-1
8000b13e:	50 4c       	stdsp	sp[0x10],r12
8000b140:	50 6b       	stdsp	sp[0x18],r11
8000b142:	c0 38       	rjmp	8000b148 <_dtoa_r+0x880>
8000b144:	30 0a       	mov	r10,0
8000b146:	50 6a       	stdsp	sp[0x18],r10
8000b148:	41 19       	lddsp	r9,sp[0x44]
8000b14a:	58 09       	cp.w	r9,0
8000b14c:	c0 31       	brne	8000b152 <_dtoa_r+0x88a>
8000b14e:	30 1c       	mov	r12,1
8000b150:	c0 98       	rjmp	8000b162 <_dtoa_r+0x89a>
8000b152:	64 48       	ld.w	r8,r2[0x10]
8000b154:	2f c8       	sub	r8,-4
8000b156:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000b15a:	e0 a0 05 df 	rcall	8000bd18 <__hi0bits>
8000b15e:	f8 0c 11 20 	rsub	r12,r12,32
8000b162:	40 4b       	lddsp	r11,sp[0x10]
8000b164:	f8 0b 00 08 	add	r8,r12,r11
8000b168:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000b16c:	c0 c0       	breq	8000b184 <_dtoa_r+0x8bc>
8000b16e:	f0 08 11 20 	rsub	r8,r8,32
8000b172:	58 48       	cp.w	r8,4
8000b174:	e0 8a 00 06 	brle	8000b180 <_dtoa_r+0x8b8>
8000b178:	20 48       	sub	r8,4
8000b17a:	10 0b       	add	r11,r8
8000b17c:	50 4b       	stdsp	sp[0x10],r11
8000b17e:	c0 78       	rjmp	8000b18c <_dtoa_r+0x8c4>
8000b180:	58 48       	cp.w	r8,4
8000b182:	c0 70       	breq	8000b190 <_dtoa_r+0x8c8>
8000b184:	40 4a       	lddsp	r10,sp[0x10]
8000b186:	2e 48       	sub	r8,-28
8000b188:	10 0a       	add	r10,r8
8000b18a:	50 4a       	stdsp	sp[0x10],r10
8000b18c:	10 00       	add	r0,r8
8000b18e:	10 05       	add	r5,r8
8000b190:	58 00       	cp.w	r0,0
8000b192:	e0 8a 00 08 	brle	8000b1a2 <_dtoa_r+0x8da>
8000b196:	06 9b       	mov	r11,r3
8000b198:	00 9a       	mov	r10,r0
8000b19a:	0e 9c       	mov	r12,r7
8000b19c:	e0 a0 07 58 	rcall	8000c04c <__lshift>
8000b1a0:	18 93       	mov	r3,r12
8000b1a2:	40 49       	lddsp	r9,sp[0x10]
8000b1a4:	58 09       	cp.w	r9,0
8000b1a6:	e0 8a 00 08 	brle	8000b1b6 <_dtoa_r+0x8ee>
8000b1aa:	04 9b       	mov	r11,r2
8000b1ac:	12 9a       	mov	r10,r9
8000b1ae:	0e 9c       	mov	r12,r7
8000b1b0:	e0 a0 07 4e 	rcall	8000c04c <__lshift>
8000b1b4:	18 92       	mov	r2,r12
8000b1b6:	41 48       	lddsp	r8,sp[0x50]
8000b1b8:	58 08       	cp.w	r8,0
8000b1ba:	c1 b0       	breq	8000b1f0 <_dtoa_r+0x928>
8000b1bc:	04 9b       	mov	r11,r2
8000b1be:	06 9c       	mov	r12,r3
8000b1c0:	e0 a0 06 23 	rcall	8000be06 <__mcmp>
8000b1c4:	c1 64       	brge	8000b1f0 <_dtoa_r+0x928>
8000b1c6:	06 9b       	mov	r11,r3
8000b1c8:	30 09       	mov	r9,0
8000b1ca:	30 aa       	mov	r10,10
8000b1cc:	0e 9c       	mov	r12,r7
8000b1ce:	e0 a0 08 0b 	rcall	8000c1e4 <__multadd>
8000b1d2:	20 16       	sub	r6,1
8000b1d4:	18 93       	mov	r3,r12
8000b1d6:	40 dc       	lddsp	r12,sp[0x34]
8000b1d8:	58 0c       	cp.w	r12,0
8000b1da:	c0 31       	brne	8000b1e0 <_dtoa_r+0x918>
8000b1dc:	40 91       	lddsp	r1,sp[0x24]
8000b1de:	c0 98       	rjmp	8000b1f0 <_dtoa_r+0x928>
8000b1e0:	08 9b       	mov	r11,r4
8000b1e2:	40 91       	lddsp	r1,sp[0x24]
8000b1e4:	30 09       	mov	r9,0
8000b1e6:	30 aa       	mov	r10,10
8000b1e8:	0e 9c       	mov	r12,r7
8000b1ea:	e0 a0 07 fd 	rcall	8000c1e4 <__multadd>
8000b1ee:	18 94       	mov	r4,r12
8000b1f0:	58 01       	cp.w	r1,0
8000b1f2:	5f a9       	srle	r9
8000b1f4:	40 cb       	lddsp	r11,sp[0x30]
8000b1f6:	58 2b       	cp.w	r11,2
8000b1f8:	5f 98       	srgt	r8
8000b1fa:	f3 e8 00 08 	and	r8,r9,r8
8000b1fe:	c2 50       	breq	8000b248 <_dtoa_r+0x980>
8000b200:	58 01       	cp.w	r1,0
8000b202:	c1 11       	brne	8000b224 <_dtoa_r+0x95c>
8000b204:	04 9b       	mov	r11,r2
8000b206:	02 99       	mov	r9,r1
8000b208:	30 5a       	mov	r10,5
8000b20a:	0e 9c       	mov	r12,r7
8000b20c:	e0 a0 07 ec 	rcall	8000c1e4 <__multadd>
8000b210:	18 92       	mov	r2,r12
8000b212:	18 9b       	mov	r11,r12
8000b214:	06 9c       	mov	r12,r3
8000b216:	e0 a0 05 f8 	rcall	8000be06 <__mcmp>
8000b21a:	e0 89 00 0f 	brgt	8000b238 <_dtoa_r+0x970>
8000b21e:	c0 38       	rjmp	8000b224 <_dtoa_r+0x95c>
8000b220:	30 02       	mov	r2,0
8000b222:	04 94       	mov	r4,r2
8000b224:	40 ea       	lddsp	r10,sp[0x38]
8000b226:	30 09       	mov	r9,0
8000b228:	5c da       	com	r10
8000b22a:	40 85       	lddsp	r5,sp[0x20]
8000b22c:	50 6a       	stdsp	sp[0x18],r10
8000b22e:	50 49       	stdsp	sp[0x10],r9
8000b230:	c0 f9       	rjmp	8000b44e <_dtoa_r+0xb86>
8000b232:	08 92       	mov	r2,r4
8000b234:	40 66       	lddsp	r6,sp[0x18]
8000b236:	04 94       	mov	r4,r2
8000b238:	2f f6       	sub	r6,-1
8000b23a:	50 66       	stdsp	sp[0x18],r6
8000b23c:	33 18       	mov	r8,49
8000b23e:	40 85       	lddsp	r5,sp[0x20]
8000b240:	0a c8       	st.b	r5++,r8
8000b242:	30 08       	mov	r8,0
8000b244:	50 48       	stdsp	sp[0x10],r8
8000b246:	c0 49       	rjmp	8000b44e <_dtoa_r+0xb86>
8000b248:	40 dc       	lddsp	r12,sp[0x34]
8000b24a:	58 0c       	cp.w	r12,0
8000b24c:	e0 80 00 b5 	breq	8000b3b6 <_dtoa_r+0xaee>
8000b250:	58 05       	cp.w	r5,0
8000b252:	e0 8a 00 08 	brle	8000b262 <_dtoa_r+0x99a>
8000b256:	08 9b       	mov	r11,r4
8000b258:	0a 9a       	mov	r10,r5
8000b25a:	0e 9c       	mov	r12,r7
8000b25c:	e0 a0 06 f8 	rcall	8000c04c <__lshift>
8000b260:	18 94       	mov	r4,r12
8000b262:	40 6b       	lddsp	r11,sp[0x18]
8000b264:	58 0b       	cp.w	r11,0
8000b266:	c0 31       	brne	8000b26c <_dtoa_r+0x9a4>
8000b268:	08 9c       	mov	r12,r4
8000b26a:	c1 38       	rjmp	8000b290 <_dtoa_r+0x9c8>
8000b26c:	68 1b       	ld.w	r11,r4[0x4]
8000b26e:	0e 9c       	mov	r12,r7
8000b270:	e0 a0 05 fe 	rcall	8000be6c <_Balloc>
8000b274:	68 4a       	ld.w	r10,r4[0x10]
8000b276:	18 95       	mov	r5,r12
8000b278:	e8 cb ff f4 	sub	r11,r4,-12
8000b27c:	2f ea       	sub	r10,-2
8000b27e:	2f 4c       	sub	r12,-12
8000b280:	a3 6a       	lsl	r10,0x2
8000b282:	fe b0 e6 50 	rcall	80007f22 <memcpy>
8000b286:	0a 9b       	mov	r11,r5
8000b288:	30 1a       	mov	r10,1
8000b28a:	0e 9c       	mov	r12,r7
8000b28c:	e0 a0 06 e0 	rcall	8000c04c <__lshift>
8000b290:	50 44       	stdsp	sp[0x10],r4
8000b292:	40 3a       	lddsp	r10,sp[0xc]
8000b294:	30 19       	mov	r9,1
8000b296:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000b29a:	18 94       	mov	r4,r12
8000b29c:	50 da       	stdsp	sp[0x34],r10
8000b29e:	40 85       	lddsp	r5,sp[0x20]
8000b2a0:	50 99       	stdsp	sp[0x24],r9
8000b2a2:	50 26       	stdsp	sp[0x8],r6
8000b2a4:	50 e1       	stdsp	sp[0x38],r1
8000b2a6:	04 9b       	mov	r11,r2
8000b2a8:	06 9c       	mov	r12,r3
8000b2aa:	fe b0 fa 7f 	rcall	8000a7a8 <quorem>
8000b2ae:	40 4b       	lddsp	r11,sp[0x10]
8000b2b0:	f8 c0 ff d0 	sub	r0,r12,-48
8000b2b4:	06 9c       	mov	r12,r3
8000b2b6:	e0 a0 05 a8 	rcall	8000be06 <__mcmp>
8000b2ba:	08 9a       	mov	r10,r4
8000b2bc:	50 6c       	stdsp	sp[0x18],r12
8000b2be:	04 9b       	mov	r11,r2
8000b2c0:	0e 9c       	mov	r12,r7
8000b2c2:	e0 a0 06 5d 	rcall	8000bf7c <__mdiff>
8000b2c6:	18 91       	mov	r1,r12
8000b2c8:	78 38       	ld.w	r8,r12[0xc]
8000b2ca:	58 08       	cp.w	r8,0
8000b2cc:	c0 30       	breq	8000b2d2 <_dtoa_r+0xa0a>
8000b2ce:	30 16       	mov	r6,1
8000b2d0:	c0 68       	rjmp	8000b2dc <_dtoa_r+0xa14>
8000b2d2:	18 9b       	mov	r11,r12
8000b2d4:	06 9c       	mov	r12,r3
8000b2d6:	e0 a0 05 98 	rcall	8000be06 <__mcmp>
8000b2da:	18 96       	mov	r6,r12
8000b2dc:	0e 9c       	mov	r12,r7
8000b2de:	02 9b       	mov	r11,r1
8000b2e0:	e0 a0 05 ac 	rcall	8000be38 <_Bfree>
8000b2e4:	40 cc       	lddsp	r12,sp[0x30]
8000b2e6:	ed ec 10 08 	or	r8,r6,r12
8000b2ea:	c0 d1       	brne	8000b304 <_dtoa_r+0xa3c>
8000b2ec:	40 db       	lddsp	r11,sp[0x34]
8000b2ee:	58 0b       	cp.w	r11,0
8000b2f0:	c0 a1       	brne	8000b304 <_dtoa_r+0xa3c>
8000b2f2:	40 26       	lddsp	r6,sp[0x8]
8000b2f4:	e0 40 00 39 	cp.w	r0,57
8000b2f8:	c3 00       	breq	8000b358 <_dtoa_r+0xa90>
8000b2fa:	40 6a       	lddsp	r10,sp[0x18]
8000b2fc:	58 0a       	cp.w	r10,0
8000b2fe:	e0 89 00 24 	brgt	8000b346 <_dtoa_r+0xa7e>
8000b302:	c2 f8       	rjmp	8000b360 <_dtoa_r+0xa98>
8000b304:	40 69       	lddsp	r9,sp[0x18]
8000b306:	58 09       	cp.w	r9,0
8000b308:	c0 85       	brlt	8000b318 <_dtoa_r+0xa50>
8000b30a:	12 98       	mov	r8,r9
8000b30c:	40 cc       	lddsp	r12,sp[0x30]
8000b30e:	18 48       	or	r8,r12
8000b310:	c1 d1       	brne	8000b34a <_dtoa_r+0xa82>
8000b312:	40 db       	lddsp	r11,sp[0x34]
8000b314:	58 0b       	cp.w	r11,0
8000b316:	c1 a1       	brne	8000b34a <_dtoa_r+0xa82>
8000b318:	0c 99       	mov	r9,r6
8000b31a:	40 26       	lddsp	r6,sp[0x8]
8000b31c:	58 09       	cp.w	r9,0
8000b31e:	e0 8a 00 21 	brle	8000b360 <_dtoa_r+0xa98>
8000b322:	06 9b       	mov	r11,r3
8000b324:	30 1a       	mov	r10,1
8000b326:	0e 9c       	mov	r12,r7
8000b328:	e0 a0 06 92 	rcall	8000c04c <__lshift>
8000b32c:	04 9b       	mov	r11,r2
8000b32e:	18 93       	mov	r3,r12
8000b330:	e0 a0 05 6b 	rcall	8000be06 <__mcmp>
8000b334:	e0 89 00 06 	brgt	8000b340 <_dtoa_r+0xa78>
8000b338:	c1 41       	brne	8000b360 <_dtoa_r+0xa98>
8000b33a:	ed b0 00 00 	bld	r0,0x0
8000b33e:	c1 11       	brne	8000b360 <_dtoa_r+0xa98>
8000b340:	e0 40 00 39 	cp.w	r0,57
8000b344:	c0 a0       	breq	8000b358 <_dtoa_r+0xa90>
8000b346:	2f f0       	sub	r0,-1
8000b348:	c0 c8       	rjmp	8000b360 <_dtoa_r+0xa98>
8000b34a:	58 06       	cp.w	r6,0
8000b34c:	e0 8a 00 0c 	brle	8000b364 <_dtoa_r+0xa9c>
8000b350:	40 26       	lddsp	r6,sp[0x8]
8000b352:	e0 40 00 39 	cp.w	r0,57
8000b356:	c0 41       	brne	8000b35e <_dtoa_r+0xa96>
8000b358:	33 98       	mov	r8,57
8000b35a:	0a c8       	st.b	r5++,r8
8000b35c:	c6 78       	rjmp	8000b42a <_dtoa_r+0xb62>
8000b35e:	2f f0       	sub	r0,-1
8000b360:	0a c0       	st.b	r5++,r0
8000b362:	c7 58       	rjmp	8000b44c <_dtoa_r+0xb84>
8000b364:	0a c0       	st.b	r5++,r0
8000b366:	40 9a       	lddsp	r10,sp[0x24]
8000b368:	40 e9       	lddsp	r9,sp[0x38]
8000b36a:	12 3a       	cp.w	r10,r9
8000b36c:	c4 30       	breq	8000b3f2 <_dtoa_r+0xb2a>
8000b36e:	06 9b       	mov	r11,r3
8000b370:	30 09       	mov	r9,0
8000b372:	30 aa       	mov	r10,10
8000b374:	0e 9c       	mov	r12,r7
8000b376:	e0 a0 07 37 	rcall	8000c1e4 <__multadd>
8000b37a:	40 48       	lddsp	r8,sp[0x10]
8000b37c:	18 93       	mov	r3,r12
8000b37e:	08 38       	cp.w	r8,r4
8000b380:	c0 91       	brne	8000b392 <_dtoa_r+0xaca>
8000b382:	10 9b       	mov	r11,r8
8000b384:	30 09       	mov	r9,0
8000b386:	30 aa       	mov	r10,10
8000b388:	0e 9c       	mov	r12,r7
8000b38a:	e0 a0 07 2d 	rcall	8000c1e4 <__multadd>
8000b38e:	50 4c       	stdsp	sp[0x10],r12
8000b390:	c0 e8       	rjmp	8000b3ac <_dtoa_r+0xae4>
8000b392:	40 4b       	lddsp	r11,sp[0x10]
8000b394:	30 09       	mov	r9,0
8000b396:	30 aa       	mov	r10,10
8000b398:	0e 9c       	mov	r12,r7
8000b39a:	e0 a0 07 25 	rcall	8000c1e4 <__multadd>
8000b39e:	08 9b       	mov	r11,r4
8000b3a0:	50 4c       	stdsp	sp[0x10],r12
8000b3a2:	30 09       	mov	r9,0
8000b3a4:	30 aa       	mov	r10,10
8000b3a6:	0e 9c       	mov	r12,r7
8000b3a8:	e0 a0 07 1e 	rcall	8000c1e4 <__multadd>
8000b3ac:	18 94       	mov	r4,r12
8000b3ae:	40 9c       	lddsp	r12,sp[0x24]
8000b3b0:	2f fc       	sub	r12,-1
8000b3b2:	50 9c       	stdsp	sp[0x24],r12
8000b3b4:	c7 9b       	rjmp	8000b2a6 <_dtoa_r+0x9de>
8000b3b6:	30 18       	mov	r8,1
8000b3b8:	06 90       	mov	r0,r3
8000b3ba:	40 85       	lddsp	r5,sp[0x20]
8000b3bc:	08 93       	mov	r3,r4
8000b3be:	0c 94       	mov	r4,r6
8000b3c0:	10 96       	mov	r6,r8
8000b3c2:	04 9b       	mov	r11,r2
8000b3c4:	00 9c       	mov	r12,r0
8000b3c6:	fe b0 f9 f1 	rcall	8000a7a8 <quorem>
8000b3ca:	2d 0c       	sub	r12,-48
8000b3cc:	0a cc       	st.b	r5++,r12
8000b3ce:	02 36       	cp.w	r6,r1
8000b3d0:	c0 a4       	brge	8000b3e4 <_dtoa_r+0xb1c>
8000b3d2:	00 9b       	mov	r11,r0
8000b3d4:	30 09       	mov	r9,0
8000b3d6:	30 aa       	mov	r10,10
8000b3d8:	0e 9c       	mov	r12,r7
8000b3da:	2f f6       	sub	r6,-1
8000b3dc:	e0 a0 07 04 	rcall	8000c1e4 <__multadd>
8000b3e0:	18 90       	mov	r0,r12
8000b3e2:	cf 0b       	rjmp	8000b3c2 <_dtoa_r+0xafa>
8000b3e4:	08 96       	mov	r6,r4
8000b3e6:	30 0b       	mov	r11,0
8000b3e8:	06 94       	mov	r4,r3
8000b3ea:	50 4b       	stdsp	sp[0x10],r11
8000b3ec:	00 93       	mov	r3,r0
8000b3ee:	18 90       	mov	r0,r12
8000b3f0:	c0 28       	rjmp	8000b3f4 <_dtoa_r+0xb2c>
8000b3f2:	40 26       	lddsp	r6,sp[0x8]
8000b3f4:	06 9b       	mov	r11,r3
8000b3f6:	30 1a       	mov	r10,1
8000b3f8:	0e 9c       	mov	r12,r7
8000b3fa:	e0 a0 06 29 	rcall	8000c04c <__lshift>
8000b3fe:	04 9b       	mov	r11,r2
8000b400:	18 93       	mov	r3,r12
8000b402:	e0 a0 05 02 	rcall	8000be06 <__mcmp>
8000b406:	e0 89 00 12 	brgt	8000b42a <_dtoa_r+0xb62>
8000b40a:	c1 b1       	brne	8000b440 <_dtoa_r+0xb78>
8000b40c:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000b410:	c0 d1       	brne	8000b42a <_dtoa_r+0xb62>
8000b412:	c1 78       	rjmp	8000b440 <_dtoa_r+0xb78>
8000b414:	40 89       	lddsp	r9,sp[0x20]
8000b416:	12 38       	cp.w	r8,r9
8000b418:	c0 30       	breq	8000b41e <_dtoa_r+0xb56>
8000b41a:	10 95       	mov	r5,r8
8000b41c:	c0 88       	rjmp	8000b42c <_dtoa_r+0xb64>
8000b41e:	2f f6       	sub	r6,-1
8000b420:	50 66       	stdsp	sp[0x18],r6
8000b422:	33 18       	mov	r8,49
8000b424:	40 8c       	lddsp	r12,sp[0x20]
8000b426:	b8 88       	st.b	r12[0x0],r8
8000b428:	c1 38       	rjmp	8000b44e <_dtoa_r+0xb86>
8000b42a:	33 9a       	mov	r10,57
8000b42c:	0a 98       	mov	r8,r5
8000b42e:	11 79       	ld.ub	r9,--r8
8000b430:	f4 09 18 00 	cp.b	r9,r10
8000b434:	cf 00       	breq	8000b414 <_dtoa_r+0xb4c>
8000b436:	2f f9       	sub	r9,-1
8000b438:	b0 89       	st.b	r8[0x0],r9
8000b43a:	c0 98       	rjmp	8000b44c <_dtoa_r+0xb84>
8000b43c:	10 95       	mov	r5,r8
8000b43e:	c0 28       	rjmp	8000b442 <_dtoa_r+0xb7a>
8000b440:	33 09       	mov	r9,48
8000b442:	0a 98       	mov	r8,r5
8000b444:	11 7a       	ld.ub	r10,--r8
8000b446:	f2 0a 18 00 	cp.b	r10,r9
8000b44a:	cf 90       	breq	8000b43c <_dtoa_r+0xb74>
8000b44c:	50 66       	stdsp	sp[0x18],r6
8000b44e:	04 9b       	mov	r11,r2
8000b450:	0e 9c       	mov	r12,r7
8000b452:	e0 a0 04 f3 	rcall	8000be38 <_Bfree>
8000b456:	58 04       	cp.w	r4,0
8000b458:	c1 20       	breq	8000b47c <_dtoa_r+0xbb4>
8000b45a:	40 4b       	lddsp	r11,sp[0x10]
8000b45c:	08 3b       	cp.w	r11,r4
8000b45e:	5f 19       	srne	r9
8000b460:	58 0b       	cp.w	r11,0
8000b462:	5f 18       	srne	r8
8000b464:	f3 e8 00 08 	and	r8,r9,r8
8000b468:	c0 40       	breq	8000b470 <_dtoa_r+0xba8>
8000b46a:	0e 9c       	mov	r12,r7
8000b46c:	e0 a0 04 e6 	rcall	8000be38 <_Bfree>
8000b470:	08 9b       	mov	r11,r4
8000b472:	0e 9c       	mov	r12,r7
8000b474:	e0 a0 04 e2 	rcall	8000be38 <_Bfree>
8000b478:	c0 28       	rjmp	8000b47c <_dtoa_r+0xbb4>
8000b47a:	50 66       	stdsp	sp[0x18],r6
8000b47c:	0e 9c       	mov	r12,r7
8000b47e:	06 9b       	mov	r11,r3
8000b480:	e0 a0 04 dc 	rcall	8000be38 <_Bfree>
8000b484:	30 08       	mov	r8,0
8000b486:	aa 88       	st.b	r5[0x0],r8
8000b488:	40 68       	lddsp	r8,sp[0x18]
8000b48a:	41 5a       	lddsp	r10,sp[0x54]
8000b48c:	2f f8       	sub	r8,-1
8000b48e:	41 29       	lddsp	r9,sp[0x48]
8000b490:	95 08       	st.w	r10[0x0],r8
8000b492:	40 8c       	lddsp	r12,sp[0x20]
8000b494:	58 09       	cp.w	r9,0
8000b496:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000b49a:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000b49e:	2e 6d       	sub	sp,-104
8000b4a0:	d8 32       	popm	r0-r7,pc
8000b4a2:	d7 03       	nop

8000b4a4 <__errno>:
8000b4a4:	e0 68 0a 48 	mov	r8,2632
8000b4a8:	70 0c       	ld.w	r12,r8[0x0]
8000b4aa:	2f 4c       	sub	r12,-12
8000b4ac:	5e fc       	retal	r12
8000b4ae:	d7 03       	nop

8000b4b0 <_fflush_r>:
8000b4b0:	d4 21       	pushm	r4-r7,lr
8000b4b2:	16 97       	mov	r7,r11
8000b4b4:	18 96       	mov	r6,r12
8000b4b6:	76 48       	ld.w	r8,r11[0x10]
8000b4b8:	58 08       	cp.w	r8,0
8000b4ba:	c7 f0       	breq	8000b5b8 <_fflush_r+0x108>
8000b4bc:	58 0c       	cp.w	r12,0
8000b4be:	c0 50       	breq	8000b4c8 <_fflush_r+0x18>
8000b4c0:	78 68       	ld.w	r8,r12[0x18]
8000b4c2:	58 08       	cp.w	r8,0
8000b4c4:	c0 21       	brne	8000b4c8 <_fflush_r+0x18>
8000b4c6:	cc dc       	rcall	8000b660 <__sinit>
8000b4c8:	fe c8 cc 8c 	sub	r8,pc,-13172
8000b4cc:	10 37       	cp.w	r7,r8
8000b4ce:	c0 31       	brne	8000b4d4 <_fflush_r+0x24>
8000b4d0:	6c 07       	ld.w	r7,r6[0x0]
8000b4d2:	c0 c8       	rjmp	8000b4ea <_fflush_r+0x3a>
8000b4d4:	fe c8 cc 78 	sub	r8,pc,-13192
8000b4d8:	10 37       	cp.w	r7,r8
8000b4da:	c0 31       	brne	8000b4e0 <_fflush_r+0x30>
8000b4dc:	6c 17       	ld.w	r7,r6[0x4]
8000b4de:	c0 68       	rjmp	8000b4ea <_fflush_r+0x3a>
8000b4e0:	fe c8 cc 64 	sub	r8,pc,-13212
8000b4e4:	10 37       	cp.w	r7,r8
8000b4e6:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b4ea:	8e 6a       	ld.sh	r10,r7[0xc]
8000b4ec:	14 98       	mov	r8,r10
8000b4ee:	ed ba 00 03 	bld	r10,0x3
8000b4f2:	c4 20       	breq	8000b576 <_fflush_r+0xc6>
8000b4f4:	ab ba       	sbr	r10,0xb
8000b4f6:	ae 6a       	st.h	r7[0xc],r10
8000b4f8:	6e 18       	ld.w	r8,r7[0x4]
8000b4fa:	58 08       	cp.w	r8,0
8000b4fc:	e0 89 00 06 	brgt	8000b508 <_fflush_r+0x58>
8000b500:	6f 08       	ld.w	r8,r7[0x40]
8000b502:	58 08       	cp.w	r8,0
8000b504:	e0 8a 00 5a 	brle	8000b5b8 <_fflush_r+0x108>
8000b508:	6e b8       	ld.w	r8,r7[0x2c]
8000b50a:	58 08       	cp.w	r8,0
8000b50c:	c5 60       	breq	8000b5b8 <_fflush_r+0x108>
8000b50e:	e2 1a 10 00 	andl	r10,0x1000,COH
8000b512:	c0 30       	breq	8000b518 <_fflush_r+0x68>
8000b514:	6f 55       	ld.w	r5,r7[0x54]
8000b516:	c0 f8       	rjmp	8000b534 <_fflush_r+0x84>
8000b518:	30 19       	mov	r9,1
8000b51a:	6e 8b       	ld.w	r11,r7[0x20]
8000b51c:	0c 9c       	mov	r12,r6
8000b51e:	5d 18       	icall	r8
8000b520:	18 95       	mov	r5,r12
8000b522:	5b fc       	cp.w	r12,-1
8000b524:	c0 81       	brne	8000b534 <_fflush_r+0x84>
8000b526:	6c 38       	ld.w	r8,r6[0xc]
8000b528:	59 d8       	cp.w	r8,29
8000b52a:	c4 70       	breq	8000b5b8 <_fflush_r+0x108>
8000b52c:	8e 68       	ld.sh	r8,r7[0xc]
8000b52e:	a7 a8       	sbr	r8,0x6
8000b530:	ae 68       	st.h	r7[0xc],r8
8000b532:	d8 22       	popm	r4-r7,pc
8000b534:	8e 68       	ld.sh	r8,r7[0xc]
8000b536:	ed b8 00 02 	bld	r8,0x2
8000b53a:	c0 91       	brne	8000b54c <_fflush_r+0x9c>
8000b53c:	6e 18       	ld.w	r8,r7[0x4]
8000b53e:	10 15       	sub	r5,r8
8000b540:	6e d8       	ld.w	r8,r7[0x34]
8000b542:	58 08       	cp.w	r8,0
8000b544:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000b548:	eb d8 e1 15 	subne	r5,r5,r8
8000b54c:	6e b8       	ld.w	r8,r7[0x2c]
8000b54e:	0c 9c       	mov	r12,r6
8000b550:	30 09       	mov	r9,0
8000b552:	0a 9a       	mov	r10,r5
8000b554:	6e 8b       	ld.w	r11,r7[0x20]
8000b556:	5d 18       	icall	r8
8000b558:	8e 68       	ld.sh	r8,r7[0xc]
8000b55a:	0a 3c       	cp.w	r12,r5
8000b55c:	c2 61       	brne	8000b5a8 <_fflush_r+0xf8>
8000b55e:	ab d8       	cbr	r8,0xb
8000b560:	30 0c       	mov	r12,0
8000b562:	6e 49       	ld.w	r9,r7[0x10]
8000b564:	ae 68       	st.h	r7[0xc],r8
8000b566:	8f 1c       	st.w	r7[0x4],r12
8000b568:	8f 09       	st.w	r7[0x0],r9
8000b56a:	ed b8 00 0c 	bld	r8,0xc
8000b56e:	c2 51       	brne	8000b5b8 <_fflush_r+0x108>
8000b570:	ef 45 00 54 	st.w	r7[84],r5
8000b574:	d8 22       	popm	r4-r7,pc
8000b576:	6e 45       	ld.w	r5,r7[0x10]
8000b578:	58 05       	cp.w	r5,0
8000b57a:	c1 f0       	breq	8000b5b8 <_fflush_r+0x108>
8000b57c:	6e 04       	ld.w	r4,r7[0x0]
8000b57e:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000b582:	8f 05       	st.w	r7[0x0],r5
8000b584:	f9 b8 01 00 	movne	r8,0
8000b588:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000b58c:	0a 14       	sub	r4,r5
8000b58e:	8f 28       	st.w	r7[0x8],r8
8000b590:	c1 18       	rjmp	8000b5b2 <_fflush_r+0x102>
8000b592:	08 99       	mov	r9,r4
8000b594:	0a 9a       	mov	r10,r5
8000b596:	6e a8       	ld.w	r8,r7[0x28]
8000b598:	6e 8b       	ld.w	r11,r7[0x20]
8000b59a:	0c 9c       	mov	r12,r6
8000b59c:	5d 18       	icall	r8
8000b59e:	18 14       	sub	r4,r12
8000b5a0:	58 0c       	cp.w	r12,0
8000b5a2:	e0 89 00 07 	brgt	8000b5b0 <_fflush_r+0x100>
8000b5a6:	8e 68       	ld.sh	r8,r7[0xc]
8000b5a8:	a7 a8       	sbr	r8,0x6
8000b5aa:	3f fc       	mov	r12,-1
8000b5ac:	ae 68       	st.h	r7[0xc],r8
8000b5ae:	d8 22       	popm	r4-r7,pc
8000b5b0:	18 05       	add	r5,r12
8000b5b2:	58 04       	cp.w	r4,0
8000b5b4:	fe 99 ff ef 	brgt	8000b592 <_fflush_r+0xe2>
8000b5b8:	d8 2a       	popm	r4-r7,pc,r12=0
8000b5ba:	d7 03       	nop

8000b5bc <__sfp_lock_acquire>:
8000b5bc:	5e fc       	retal	r12

8000b5be <__sfp_lock_release>:
8000b5be:	5e fc       	retal	r12

8000b5c0 <_cleanup_r>:
8000b5c0:	d4 01       	pushm	lr
8000b5c2:	fe cb f0 ae 	sub	r11,pc,-3922
8000b5c6:	e0 a0 02 f7 	rcall	8000bbb4 <_fwalk>
8000b5ca:	d8 02       	popm	pc

8000b5cc <__sfmoreglue>:
8000b5cc:	d4 21       	pushm	r4-r7,lr
8000b5ce:	16 95       	mov	r5,r11
8000b5d0:	f6 06 10 5c 	mul	r6,r11,92
8000b5d4:	ec cb ff f4 	sub	r11,r6,-12
8000b5d8:	fe b0 e2 76 	rcall	80007ac4 <_malloc_r>
8000b5dc:	18 97       	mov	r7,r12
8000b5de:	c0 90       	breq	8000b5f0 <__sfmoreglue+0x24>
8000b5e0:	99 15       	st.w	r12[0x4],r5
8000b5e2:	30 0b       	mov	r11,0
8000b5e4:	2f 4c       	sub	r12,-12
8000b5e6:	0c 9a       	mov	r10,r6
8000b5e8:	8f 2c       	st.w	r7[0x8],r12
8000b5ea:	8f 0b       	st.w	r7[0x0],r11
8000b5ec:	fe b0 e5 3f 	rcall	8000806a <memset>
8000b5f0:	0e 9c       	mov	r12,r7
8000b5f2:	d8 22       	popm	r4-r7,pc

8000b5f4 <__sfp>:
8000b5f4:	d4 21       	pushm	r4-r7,lr
8000b5f6:	fe c8 cd 56 	sub	r8,pc,-12970
8000b5fa:	18 96       	mov	r6,r12
8000b5fc:	70 07       	ld.w	r7,r8[0x0]
8000b5fe:	6e 68       	ld.w	r8,r7[0x18]
8000b600:	58 08       	cp.w	r8,0
8000b602:	c0 31       	brne	8000b608 <__sfp+0x14>
8000b604:	0e 9c       	mov	r12,r7
8000b606:	c2 dc       	rcall	8000b660 <__sinit>
8000b608:	ee c7 ff 28 	sub	r7,r7,-216
8000b60c:	30 05       	mov	r5,0
8000b60e:	6e 2c       	ld.w	r12,r7[0x8]
8000b610:	6e 18       	ld.w	r8,r7[0x4]
8000b612:	c0 68       	rjmp	8000b61e <__sfp+0x2a>
8000b614:	98 69       	ld.sh	r9,r12[0xc]
8000b616:	ea 09 19 00 	cp.h	r9,r5
8000b61a:	c1 10       	breq	8000b63c <__sfp+0x48>
8000b61c:	2a 4c       	sub	r12,-92
8000b61e:	20 18       	sub	r8,1
8000b620:	cf a7       	brpl	8000b614 <__sfp+0x20>
8000b622:	6e 08       	ld.w	r8,r7[0x0]
8000b624:	58 08       	cp.w	r8,0
8000b626:	c0 61       	brne	8000b632 <__sfp+0x3e>
8000b628:	30 4b       	mov	r11,4
8000b62a:	0c 9c       	mov	r12,r6
8000b62c:	cd 0f       	rcall	8000b5cc <__sfmoreglue>
8000b62e:	8f 0c       	st.w	r7[0x0],r12
8000b630:	c0 30       	breq	8000b636 <__sfp+0x42>
8000b632:	6e 07       	ld.w	r7,r7[0x0]
8000b634:	ce db       	rjmp	8000b60e <__sfp+0x1a>
8000b636:	30 c8       	mov	r8,12
8000b638:	8d 38       	st.w	r6[0xc],r8
8000b63a:	d8 22       	popm	r4-r7,pc
8000b63c:	30 08       	mov	r8,0
8000b63e:	f9 48 00 4c 	st.w	r12[76],r8
8000b642:	99 08       	st.w	r12[0x0],r8
8000b644:	99 28       	st.w	r12[0x8],r8
8000b646:	99 18       	st.w	r12[0x4],r8
8000b648:	99 48       	st.w	r12[0x10],r8
8000b64a:	99 58       	st.w	r12[0x14],r8
8000b64c:	99 68       	st.w	r12[0x18],r8
8000b64e:	99 d8       	st.w	r12[0x34],r8
8000b650:	99 e8       	st.w	r12[0x38],r8
8000b652:	f9 48 00 48 	st.w	r12[72],r8
8000b656:	3f f8       	mov	r8,-1
8000b658:	b8 78       	st.h	r12[0xe],r8
8000b65a:	30 18       	mov	r8,1
8000b65c:	b8 68       	st.h	r12[0xc],r8
8000b65e:	d8 22       	popm	r4-r7,pc

8000b660 <__sinit>:
8000b660:	d4 21       	pushm	r4-r7,lr
8000b662:	18 96       	mov	r6,r12
8000b664:	78 67       	ld.w	r7,r12[0x18]
8000b666:	58 07       	cp.w	r7,0
8000b668:	c4 91       	brne	8000b6fa <__sinit+0x9a>
8000b66a:	fe c8 00 aa 	sub	r8,pc,170
8000b66e:	30 15       	mov	r5,1
8000b670:	99 a8       	st.w	r12[0x28],r8
8000b672:	f9 47 00 d8 	st.w	r12[216],r7
8000b676:	f9 47 00 dc 	st.w	r12[220],r7
8000b67a:	f9 47 00 e0 	st.w	r12[224],r7
8000b67e:	99 65       	st.w	r12[0x18],r5
8000b680:	cb af       	rcall	8000b5f4 <__sfp>
8000b682:	8d 0c       	st.w	r6[0x0],r12
8000b684:	0c 9c       	mov	r12,r6
8000b686:	cb 7f       	rcall	8000b5f4 <__sfp>
8000b688:	8d 1c       	st.w	r6[0x4],r12
8000b68a:	0c 9c       	mov	r12,r6
8000b68c:	cb 4f       	rcall	8000b5f4 <__sfp>
8000b68e:	6c 09       	ld.w	r9,r6[0x0]
8000b690:	30 48       	mov	r8,4
8000b692:	93 07       	st.w	r9[0x0],r7
8000b694:	b2 68       	st.h	r9[0xc],r8
8000b696:	93 17       	st.w	r9[0x4],r7
8000b698:	93 27       	st.w	r9[0x8],r7
8000b69a:	6c 18       	ld.w	r8,r6[0x4]
8000b69c:	b2 77       	st.h	r9[0xe],r7
8000b69e:	93 47       	st.w	r9[0x10],r7
8000b6a0:	93 57       	st.w	r9[0x14],r7
8000b6a2:	93 67       	st.w	r9[0x18],r7
8000b6a4:	93 89       	st.w	r9[0x20],r9
8000b6a6:	91 07       	st.w	r8[0x0],r7
8000b6a8:	91 17       	st.w	r8[0x4],r7
8000b6aa:	91 27       	st.w	r8[0x8],r7
8000b6ac:	fe ce f3 24 	sub	lr,pc,-3292
8000b6b0:	fe cb f3 54 	sub	r11,pc,-3244
8000b6b4:	93 9e       	st.w	r9[0x24],lr
8000b6b6:	93 ab       	st.w	r9[0x28],r11
8000b6b8:	fe ca f3 7c 	sub	r10,pc,-3204
8000b6bc:	fe c4 f3 88 	sub	r4,pc,-3192
8000b6c0:	93 ba       	st.w	r9[0x2c],r10
8000b6c2:	93 c4       	st.w	r9[0x30],r4
8000b6c4:	30 99       	mov	r9,9
8000b6c6:	b0 69       	st.h	r8[0xc],r9
8000b6c8:	b0 75       	st.h	r8[0xe],r5
8000b6ca:	91 c4       	st.w	r8[0x30],r4
8000b6cc:	91 47       	st.w	r8[0x10],r7
8000b6ce:	91 57       	st.w	r8[0x14],r7
8000b6d0:	91 67       	st.w	r8[0x18],r7
8000b6d2:	91 88       	st.w	r8[0x20],r8
8000b6d4:	91 9e       	st.w	r8[0x24],lr
8000b6d6:	91 ab       	st.w	r8[0x28],r11
8000b6d8:	91 ba       	st.w	r8[0x2c],r10
8000b6da:	8d 2c       	st.w	r6[0x8],r12
8000b6dc:	31 28       	mov	r8,18
8000b6de:	99 07       	st.w	r12[0x0],r7
8000b6e0:	b8 68       	st.h	r12[0xc],r8
8000b6e2:	99 17       	st.w	r12[0x4],r7
8000b6e4:	99 27       	st.w	r12[0x8],r7
8000b6e6:	30 28       	mov	r8,2
8000b6e8:	b8 78       	st.h	r12[0xe],r8
8000b6ea:	99 c4       	st.w	r12[0x30],r4
8000b6ec:	99 67       	st.w	r12[0x18],r7
8000b6ee:	99 9e       	st.w	r12[0x24],lr
8000b6f0:	99 ab       	st.w	r12[0x28],r11
8000b6f2:	99 ba       	st.w	r12[0x2c],r10
8000b6f4:	99 47       	st.w	r12[0x10],r7
8000b6f6:	99 57       	st.w	r12[0x14],r7
8000b6f8:	99 8c       	st.w	r12[0x20],r12
8000b6fa:	d8 22       	popm	r4-r7,pc

8000b6fc <_malloc_trim_r>:
8000b6fc:	d4 21       	pushm	r4-r7,lr
8000b6fe:	16 95       	mov	r5,r11
8000b700:	18 97       	mov	r7,r12
8000b702:	fe b0 d6 e3 	rcall	800064c8 <__malloc_lock>
8000b706:	e0 64 05 48 	mov	r4,1352
8000b70a:	68 28       	ld.w	r8,r4[0x8]
8000b70c:	70 16       	ld.w	r6,r8[0x4]
8000b70e:	e0 16 ff fc 	andl	r6,0xfffc
8000b712:	ec c8 ff 91 	sub	r8,r6,-111
8000b716:	f0 05 01 05 	sub	r5,r8,r5
8000b71a:	e0 15 ff 80 	andl	r5,0xff80
8000b71e:	ea c5 00 80 	sub	r5,r5,128
8000b722:	e0 45 00 7f 	cp.w	r5,127
8000b726:	e0 8a 00 25 	brle	8000b770 <_malloc_trim_r+0x74>
8000b72a:	30 0b       	mov	r11,0
8000b72c:	0e 9c       	mov	r12,r7
8000b72e:	fe b0 e6 05 	rcall	80008338 <_sbrk_r>
8000b732:	68 28       	ld.w	r8,r4[0x8]
8000b734:	0c 08       	add	r8,r6
8000b736:	10 3c       	cp.w	r12,r8
8000b738:	c1 c1       	brne	8000b770 <_malloc_trim_r+0x74>
8000b73a:	ea 0b 11 00 	rsub	r11,r5,0
8000b73e:	0e 9c       	mov	r12,r7
8000b740:	fe b0 e5 fc 	rcall	80008338 <_sbrk_r>
8000b744:	5b fc       	cp.w	r12,-1
8000b746:	c1 91       	brne	8000b778 <_malloc_trim_r+0x7c>
8000b748:	30 0b       	mov	r11,0
8000b74a:	0e 9c       	mov	r12,r7
8000b74c:	fe b0 e5 f6 	rcall	80008338 <_sbrk_r>
8000b750:	68 28       	ld.w	r8,r4[0x8]
8000b752:	f8 08 01 09 	sub	r9,r12,r8
8000b756:	58 f9       	cp.w	r9,15
8000b758:	e0 8a 00 0c 	brle	8000b770 <_malloc_trim_r+0x74>
8000b75c:	a1 a9       	sbr	r9,0x0
8000b75e:	91 19       	st.w	r8[0x4],r9
8000b760:	e0 68 09 54 	mov	r8,2388
8000b764:	70 09       	ld.w	r9,r8[0x0]
8000b766:	e0 68 0d d4 	mov	r8,3540
8000b76a:	f8 09 01 09 	sub	r9,r12,r9
8000b76e:	91 09       	st.w	r8[0x0],r9
8000b770:	0e 9c       	mov	r12,r7
8000b772:	fe b0 d6 b1 	rcall	800064d4 <__malloc_unlock>
8000b776:	d8 2a       	popm	r4-r7,pc,r12=0
8000b778:	68 28       	ld.w	r8,r4[0x8]
8000b77a:	0a 16       	sub	r6,r5
8000b77c:	a1 a6       	sbr	r6,0x0
8000b77e:	91 16       	st.w	r8[0x4],r6
8000b780:	e0 68 0d d4 	mov	r8,3540
8000b784:	70 09       	ld.w	r9,r8[0x0]
8000b786:	0a 19       	sub	r9,r5
8000b788:	0e 9c       	mov	r12,r7
8000b78a:	91 09       	st.w	r8[0x0],r9
8000b78c:	fe b0 d6 a4 	rcall	800064d4 <__malloc_unlock>
8000b790:	da 2a       	popm	r4-r7,pc,r12=1
8000b792:	d7 03       	nop

8000b794 <_free_r>:
8000b794:	d4 21       	pushm	r4-r7,lr
8000b796:	16 96       	mov	r6,r11
8000b798:	18 97       	mov	r7,r12
8000b79a:	58 0b       	cp.w	r11,0
8000b79c:	e0 80 00 c0 	breq	8000b91c <_free_r+0x188>
8000b7a0:	fe b0 d6 94 	rcall	800064c8 <__malloc_lock>
8000b7a4:	20 86       	sub	r6,8
8000b7a6:	e0 6a 05 48 	mov	r10,1352
8000b7aa:	6c 18       	ld.w	r8,r6[0x4]
8000b7ac:	74 2e       	ld.w	lr,r10[0x8]
8000b7ae:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000b7b2:	a1 c8       	cbr	r8,0x0
8000b7b4:	ec 08 00 09 	add	r9,r6,r8
8000b7b8:	72 1b       	ld.w	r11,r9[0x4]
8000b7ba:	e0 1b ff fc 	andl	r11,0xfffc
8000b7be:	1c 39       	cp.w	r9,lr
8000b7c0:	c1 e1       	brne	8000b7fc <_free_r+0x68>
8000b7c2:	f6 08 00 08 	add	r8,r11,r8
8000b7c6:	58 0c       	cp.w	r12,0
8000b7c8:	c0 81       	brne	8000b7d8 <_free_r+0x44>
8000b7ca:	6c 09       	ld.w	r9,r6[0x0]
8000b7cc:	12 16       	sub	r6,r9
8000b7ce:	12 08       	add	r8,r9
8000b7d0:	6c 3b       	ld.w	r11,r6[0xc]
8000b7d2:	6c 29       	ld.w	r9,r6[0x8]
8000b7d4:	97 29       	st.w	r11[0x8],r9
8000b7d6:	93 3b       	st.w	r9[0xc],r11
8000b7d8:	10 99       	mov	r9,r8
8000b7da:	95 26       	st.w	r10[0x8],r6
8000b7dc:	a1 a9       	sbr	r9,0x0
8000b7de:	8d 19       	st.w	r6[0x4],r9
8000b7e0:	e0 69 09 50 	mov	r9,2384
8000b7e4:	72 09       	ld.w	r9,r9[0x0]
8000b7e6:	12 38       	cp.w	r8,r9
8000b7e8:	c0 63       	brcs	8000b7f4 <_free_r+0x60>
8000b7ea:	e0 68 0d d0 	mov	r8,3536
8000b7ee:	0e 9c       	mov	r12,r7
8000b7f0:	70 0b       	ld.w	r11,r8[0x0]
8000b7f2:	c8 5f       	rcall	8000b6fc <_malloc_trim_r>
8000b7f4:	0e 9c       	mov	r12,r7
8000b7f6:	fe b0 d6 6f 	rcall	800064d4 <__malloc_unlock>
8000b7fa:	d8 22       	popm	r4-r7,pc
8000b7fc:	93 1b       	st.w	r9[0x4],r11
8000b7fe:	58 0c       	cp.w	r12,0
8000b800:	c0 30       	breq	8000b806 <_free_r+0x72>
8000b802:	30 0c       	mov	r12,0
8000b804:	c1 08       	rjmp	8000b824 <_free_r+0x90>
8000b806:	6c 0e       	ld.w	lr,r6[0x0]
8000b808:	f4 c5 ff f8 	sub	r5,r10,-8
8000b80c:	1c 16       	sub	r6,lr
8000b80e:	1c 08       	add	r8,lr
8000b810:	6c 2e       	ld.w	lr,r6[0x8]
8000b812:	0a 3e       	cp.w	lr,r5
8000b814:	f9 bc 00 01 	moveq	r12,1
8000b818:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000b81c:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000b820:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000b824:	f2 0b 00 0e 	add	lr,r9,r11
8000b828:	7c 1e       	ld.w	lr,lr[0x4]
8000b82a:	ed be 00 00 	bld	lr,0x0
8000b82e:	c1 40       	breq	8000b856 <_free_r+0xc2>
8000b830:	16 08       	add	r8,r11
8000b832:	58 0c       	cp.w	r12,0
8000b834:	c0 d1       	brne	8000b84e <_free_r+0xba>
8000b836:	e0 6e 05 48 	mov	lr,1352
8000b83a:	72 2b       	ld.w	r11,r9[0x8]
8000b83c:	2f 8e       	sub	lr,-8
8000b83e:	1c 3b       	cp.w	r11,lr
8000b840:	c0 71       	brne	8000b84e <_free_r+0xba>
8000b842:	97 36       	st.w	r11[0xc],r6
8000b844:	97 26       	st.w	r11[0x8],r6
8000b846:	8d 2b       	st.w	r6[0x8],r11
8000b848:	8d 3b       	st.w	r6[0xc],r11
8000b84a:	30 1c       	mov	r12,1
8000b84c:	c0 58       	rjmp	8000b856 <_free_r+0xc2>
8000b84e:	72 2b       	ld.w	r11,r9[0x8]
8000b850:	72 39       	ld.w	r9,r9[0xc]
8000b852:	93 2b       	st.w	r9[0x8],r11
8000b854:	97 39       	st.w	r11[0xc],r9
8000b856:	10 99       	mov	r9,r8
8000b858:	ec 08 09 08 	st.w	r6[r8],r8
8000b85c:	a1 a9       	sbr	r9,0x0
8000b85e:	8d 19       	st.w	r6[0x4],r9
8000b860:	58 0c       	cp.w	r12,0
8000b862:	c5 a1       	brne	8000b916 <_free_r+0x182>
8000b864:	e0 48 01 ff 	cp.w	r8,511
8000b868:	e0 8b 00 13 	brhi	8000b88e <_free_r+0xfa>
8000b86c:	a3 98       	lsr	r8,0x3
8000b86e:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000b872:	72 2b       	ld.w	r11,r9[0x8]
8000b874:	8d 39       	st.w	r6[0xc],r9
8000b876:	8d 2b       	st.w	r6[0x8],r11
8000b878:	97 36       	st.w	r11[0xc],r6
8000b87a:	93 26       	st.w	r9[0x8],r6
8000b87c:	a3 48       	asr	r8,0x2
8000b87e:	74 19       	ld.w	r9,r10[0x4]
8000b880:	30 1b       	mov	r11,1
8000b882:	f6 08 09 48 	lsl	r8,r11,r8
8000b886:	f3 e8 10 08 	or	r8,r9,r8
8000b88a:	95 18       	st.w	r10[0x4],r8
8000b88c:	c4 58       	rjmp	8000b916 <_free_r+0x182>
8000b88e:	f0 0b 16 09 	lsr	r11,r8,0x9
8000b892:	58 4b       	cp.w	r11,4
8000b894:	e0 8b 00 06 	brhi	8000b8a0 <_free_r+0x10c>
8000b898:	f0 0b 16 06 	lsr	r11,r8,0x6
8000b89c:	2c 8b       	sub	r11,-56
8000b89e:	c2 08       	rjmp	8000b8de <_free_r+0x14a>
8000b8a0:	59 4b       	cp.w	r11,20
8000b8a2:	e0 8b 00 04 	brhi	8000b8aa <_free_r+0x116>
8000b8a6:	2a 5b       	sub	r11,-91
8000b8a8:	c1 b8       	rjmp	8000b8de <_free_r+0x14a>
8000b8aa:	e0 4b 00 54 	cp.w	r11,84
8000b8ae:	e0 8b 00 06 	brhi	8000b8ba <_free_r+0x126>
8000b8b2:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000b8b6:	29 2b       	sub	r11,-110
8000b8b8:	c1 38       	rjmp	8000b8de <_free_r+0x14a>
8000b8ba:	e0 4b 01 54 	cp.w	r11,340
8000b8be:	e0 8b 00 06 	brhi	8000b8ca <_free_r+0x136>
8000b8c2:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000b8c6:	28 9b       	sub	r11,-119
8000b8c8:	c0 b8       	rjmp	8000b8de <_free_r+0x14a>
8000b8ca:	e0 4b 05 54 	cp.w	r11,1364
8000b8ce:	e0 88 00 05 	brls	8000b8d8 <_free_r+0x144>
8000b8d2:	37 eb       	mov	r11,126
8000b8d4:	c0 58       	rjmp	8000b8de <_free_r+0x14a>
8000b8d6:	d7 03       	nop
8000b8d8:	f0 0b 16 12 	lsr	r11,r8,0x12
8000b8dc:	28 4b       	sub	r11,-124
8000b8de:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000b8e2:	78 29       	ld.w	r9,r12[0x8]
8000b8e4:	18 39       	cp.w	r9,r12
8000b8e6:	c0 e1       	brne	8000b902 <_free_r+0x16e>
8000b8e8:	74 18       	ld.w	r8,r10[0x4]
8000b8ea:	a3 4b       	asr	r11,0x2
8000b8ec:	30 1c       	mov	r12,1
8000b8ee:	f8 0b 09 4b 	lsl	r11,r12,r11
8000b8f2:	f1 eb 10 0b 	or	r11,r8,r11
8000b8f6:	12 98       	mov	r8,r9
8000b8f8:	95 1b       	st.w	r10[0x4],r11
8000b8fa:	c0 a8       	rjmp	8000b90e <_free_r+0x17a>
8000b8fc:	72 29       	ld.w	r9,r9[0x8]
8000b8fe:	18 39       	cp.w	r9,r12
8000b900:	c0 60       	breq	8000b90c <_free_r+0x178>
8000b902:	72 1a       	ld.w	r10,r9[0x4]
8000b904:	e0 1a ff fc 	andl	r10,0xfffc
8000b908:	14 38       	cp.w	r8,r10
8000b90a:	cf 93       	brcs	8000b8fc <_free_r+0x168>
8000b90c:	72 38       	ld.w	r8,r9[0xc]
8000b90e:	8d 38       	st.w	r6[0xc],r8
8000b910:	8d 29       	st.w	r6[0x8],r9
8000b912:	93 36       	st.w	r9[0xc],r6
8000b914:	91 26       	st.w	r8[0x8],r6
8000b916:	0e 9c       	mov	r12,r7
8000b918:	fe b0 d5 de 	rcall	800064d4 <__malloc_unlock>
8000b91c:	d8 22       	popm	r4-r7,pc
8000b91e:	d7 03       	nop

8000b920 <__sfvwrite_r>:
8000b920:	d4 31       	pushm	r0-r7,lr
8000b922:	20 3d       	sub	sp,12
8000b924:	14 94       	mov	r4,r10
8000b926:	18 95       	mov	r5,r12
8000b928:	16 97       	mov	r7,r11
8000b92a:	74 28       	ld.w	r8,r10[0x8]
8000b92c:	58 08       	cp.w	r8,0
8000b92e:	e0 80 01 40 	breq	8000bbae <__sfvwrite_r+0x28e>
8000b932:	96 68       	ld.sh	r8,r11[0xc]
8000b934:	ed b8 00 03 	bld	r8,0x3
8000b938:	c0 41       	brne	8000b940 <__sfvwrite_r+0x20>
8000b93a:	76 48       	ld.w	r8,r11[0x10]
8000b93c:	58 08       	cp.w	r8,0
8000b93e:	c0 c1       	brne	8000b956 <__sfvwrite_r+0x36>
8000b940:	0e 9b       	mov	r11,r7
8000b942:	0a 9c       	mov	r12,r5
8000b944:	fe b0 f6 c4 	rcall	8000a6cc <__swsetup_r>
8000b948:	c0 70       	breq	8000b956 <__sfvwrite_r+0x36>
8000b94a:	8e 68       	ld.sh	r8,r7[0xc]
8000b94c:	a7 a8       	sbr	r8,0x6
8000b94e:	ae 68       	st.h	r7[0xc],r8
8000b950:	30 98       	mov	r8,9
8000b952:	8b 38       	st.w	r5[0xc],r8
8000b954:	c2 b9       	rjmp	8000bbaa <__sfvwrite_r+0x28a>
8000b956:	8e 63       	ld.sh	r3,r7[0xc]
8000b958:	68 00       	ld.w	r0,r4[0x0]
8000b95a:	06 96       	mov	r6,r3
8000b95c:	e2 16 00 02 	andl	r6,0x2,COH
8000b960:	c2 10       	breq	8000b9a2 <__sfvwrite_r+0x82>
8000b962:	30 03       	mov	r3,0
8000b964:	e0 62 04 00 	mov	r2,1024
8000b968:	06 96       	mov	r6,r3
8000b96a:	c0 48       	rjmp	8000b972 <__sfvwrite_r+0x52>
8000b96c:	60 03       	ld.w	r3,r0[0x0]
8000b96e:	60 16       	ld.w	r6,r0[0x4]
8000b970:	2f 80       	sub	r0,-8
8000b972:	58 06       	cp.w	r6,0
8000b974:	cf c0       	breq	8000b96c <__sfvwrite_r+0x4c>
8000b976:	e0 46 04 00 	cp.w	r6,1024
8000b97a:	ec 09 17 80 	movls	r9,r6
8000b97e:	e4 09 17 b0 	movhi	r9,r2
8000b982:	06 9a       	mov	r10,r3
8000b984:	6e a8       	ld.w	r8,r7[0x28]
8000b986:	6e 8b       	ld.w	r11,r7[0x20]
8000b988:	0a 9c       	mov	r12,r5
8000b98a:	5d 18       	icall	r8
8000b98c:	18 16       	sub	r6,r12
8000b98e:	58 0c       	cp.w	r12,0
8000b990:	e0 8a 01 0a 	brle	8000bba4 <__sfvwrite_r+0x284>
8000b994:	68 28       	ld.w	r8,r4[0x8]
8000b996:	18 18       	sub	r8,r12
8000b998:	89 28       	st.w	r4[0x8],r8
8000b99a:	e0 80 01 0a 	breq	8000bbae <__sfvwrite_r+0x28e>
8000b99e:	18 03       	add	r3,r12
8000b9a0:	ce 9b       	rjmp	8000b972 <__sfvwrite_r+0x52>
8000b9a2:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000b9a6:	c0 70       	breq	8000b9b4 <__sfvwrite_r+0x94>
8000b9a8:	50 06       	stdsp	sp[0x0],r6
8000b9aa:	0c 93       	mov	r3,r6
8000b9ac:	0c 91       	mov	r1,r6
8000b9ae:	50 15       	stdsp	sp[0x4],r5
8000b9b0:	08 92       	mov	r2,r4
8000b9b2:	c9 c8       	rjmp	8000baea <__sfvwrite_r+0x1ca>
8000b9b4:	06 96       	mov	r6,r3
8000b9b6:	08 91       	mov	r1,r4
8000b9b8:	c0 48       	rjmp	8000b9c0 <__sfvwrite_r+0xa0>
8000b9ba:	60 03       	ld.w	r3,r0[0x0]
8000b9bc:	60 16       	ld.w	r6,r0[0x4]
8000b9be:	2f 80       	sub	r0,-8
8000b9c0:	58 06       	cp.w	r6,0
8000b9c2:	cf c0       	breq	8000b9ba <__sfvwrite_r+0x9a>
8000b9c4:	8e 68       	ld.sh	r8,r7[0xc]
8000b9c6:	6e 24       	ld.w	r4,r7[0x8]
8000b9c8:	10 99       	mov	r9,r8
8000b9ca:	e2 19 02 00 	andl	r9,0x200,COH
8000b9ce:	c5 50       	breq	8000ba78 <__sfvwrite_r+0x158>
8000b9d0:	08 36       	cp.w	r6,r4
8000b9d2:	c4 43       	brcs	8000ba5a <__sfvwrite_r+0x13a>
8000b9d4:	10 99       	mov	r9,r8
8000b9d6:	e2 19 04 80 	andl	r9,0x480,COH
8000b9da:	c4 00       	breq	8000ba5a <__sfvwrite_r+0x13a>
8000b9dc:	6e 4b       	ld.w	r11,r7[0x10]
8000b9de:	6e 09       	ld.w	r9,r7[0x0]
8000b9e0:	16 19       	sub	r9,r11
8000b9e2:	50 09       	stdsp	sp[0x0],r9
8000b9e4:	6e 59       	ld.w	r9,r7[0x14]
8000b9e6:	10 9c       	mov	r12,r8
8000b9e8:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000b9ec:	30 28       	mov	r8,2
8000b9ee:	f4 08 0c 08 	divs	r8,r10,r8
8000b9f2:	fa e9 00 04 	st.d	sp[4],r8
8000b9f6:	10 94       	mov	r4,r8
8000b9f8:	40 09       	lddsp	r9,sp[0x0]
8000b9fa:	e2 1c 04 00 	andl	r12,0x400,COH
8000b9fe:	2f f9       	sub	r9,-1
8000ba00:	0c 09       	add	r9,r6
8000ba02:	12 38       	cp.w	r8,r9
8000ba04:	f2 04 17 30 	movlo	r4,r9
8000ba08:	58 0c       	cp.w	r12,0
8000ba0a:	c1 10       	breq	8000ba2c <__sfvwrite_r+0x10c>
8000ba0c:	08 9b       	mov	r11,r4
8000ba0e:	0a 9c       	mov	r12,r5
8000ba10:	fe b0 e0 5a 	rcall	80007ac4 <_malloc_r>
8000ba14:	18 92       	mov	r2,r12
8000ba16:	c1 40       	breq	8000ba3e <__sfvwrite_r+0x11e>
8000ba18:	40 0a       	lddsp	r10,sp[0x0]
8000ba1a:	6e 4b       	ld.w	r11,r7[0x10]
8000ba1c:	fe b0 e2 83 	rcall	80007f22 <memcpy>
8000ba20:	8e 68       	ld.sh	r8,r7[0xc]
8000ba22:	e0 18 fb 7f 	andl	r8,0xfb7f
8000ba26:	a7 b8       	sbr	r8,0x7
8000ba28:	ae 68       	st.h	r7[0xc],r8
8000ba2a:	c0 d8       	rjmp	8000ba44 <__sfvwrite_r+0x124>
8000ba2c:	08 9a       	mov	r10,r4
8000ba2e:	0a 9c       	mov	r12,r5
8000ba30:	fe b0 e3 24 	rcall	80008078 <_realloc_r>
8000ba34:	18 92       	mov	r2,r12
8000ba36:	c0 71       	brne	8000ba44 <__sfvwrite_r+0x124>
8000ba38:	6e 4b       	ld.w	r11,r7[0x10]
8000ba3a:	0a 9c       	mov	r12,r5
8000ba3c:	ca ce       	rcall	8000b794 <_free_r>
8000ba3e:	30 c8       	mov	r8,12
8000ba40:	8b 38       	st.w	r5[0xc],r8
8000ba42:	cb 18       	rjmp	8000bba4 <__sfvwrite_r+0x284>
8000ba44:	40 0a       	lddsp	r10,sp[0x0]
8000ba46:	40 09       	lddsp	r9,sp[0x0]
8000ba48:	e8 0a 01 0a 	sub	r10,r4,r10
8000ba4c:	e4 09 00 08 	add	r8,r2,r9
8000ba50:	8f 54       	st.w	r7[0x14],r4
8000ba52:	8f 2a       	st.w	r7[0x8],r10
8000ba54:	8f 08       	st.w	r7[0x0],r8
8000ba56:	8f 42       	st.w	r7[0x10],r2
8000ba58:	0c 94       	mov	r4,r6
8000ba5a:	08 36       	cp.w	r6,r4
8000ba5c:	ec 04 17 30 	movlo	r4,r6
8000ba60:	06 9b       	mov	r11,r3
8000ba62:	08 9a       	mov	r10,r4
8000ba64:	6e 0c       	ld.w	r12,r7[0x0]
8000ba66:	c3 ad       	rcall	8000bcda <memmove>
8000ba68:	6e 08       	ld.w	r8,r7[0x0]
8000ba6a:	08 08       	add	r8,r4
8000ba6c:	8f 08       	st.w	r7[0x0],r8
8000ba6e:	6e 28       	ld.w	r8,r7[0x8]
8000ba70:	08 18       	sub	r8,r4
8000ba72:	0c 94       	mov	r4,r6
8000ba74:	8f 28       	st.w	r7[0x8],r8
8000ba76:	c2 e8       	rjmp	8000bad2 <__sfvwrite_r+0x1b2>
8000ba78:	08 36       	cp.w	r6,r4
8000ba7a:	5f ba       	srhi	r10
8000ba7c:	6e 0c       	ld.w	r12,r7[0x0]
8000ba7e:	6e 48       	ld.w	r8,r7[0x10]
8000ba80:	10 3c       	cp.w	r12,r8
8000ba82:	5f b8       	srhi	r8
8000ba84:	f5 e8 00 08 	and	r8,r10,r8
8000ba88:	f2 08 18 00 	cp.b	r8,r9
8000ba8c:	c0 d0       	breq	8000baa6 <__sfvwrite_r+0x186>
8000ba8e:	06 9b       	mov	r11,r3
8000ba90:	08 9a       	mov	r10,r4
8000ba92:	c2 4d       	rcall	8000bcda <memmove>
8000ba94:	6e 08       	ld.w	r8,r7[0x0]
8000ba96:	08 08       	add	r8,r4
8000ba98:	0e 9b       	mov	r11,r7
8000ba9a:	8f 08       	st.w	r7[0x0],r8
8000ba9c:	0a 9c       	mov	r12,r5
8000ba9e:	fe b0 fd 09 	rcall	8000b4b0 <_fflush_r>
8000baa2:	c1 80       	breq	8000bad2 <__sfvwrite_r+0x1b2>
8000baa4:	c8 08       	rjmp	8000bba4 <__sfvwrite_r+0x284>
8000baa6:	6e 59       	ld.w	r9,r7[0x14]
8000baa8:	12 36       	cp.w	r6,r9
8000baaa:	c0 a3       	brcs	8000babe <__sfvwrite_r+0x19e>
8000baac:	6e a8       	ld.w	r8,r7[0x28]
8000baae:	06 9a       	mov	r10,r3
8000bab0:	6e 8b       	ld.w	r11,r7[0x20]
8000bab2:	0a 9c       	mov	r12,r5
8000bab4:	5d 18       	icall	r8
8000bab6:	18 94       	mov	r4,r12
8000bab8:	e0 89 00 0d 	brgt	8000bad2 <__sfvwrite_r+0x1b2>
8000babc:	c7 48       	rjmp	8000bba4 <__sfvwrite_r+0x284>
8000babe:	0c 9a       	mov	r10,r6
8000bac0:	06 9b       	mov	r11,r3
8000bac2:	c0 cd       	rcall	8000bcda <memmove>
8000bac4:	6e 08       	ld.w	r8,r7[0x0]
8000bac6:	0c 08       	add	r8,r6
8000bac8:	0c 94       	mov	r4,r6
8000baca:	8f 08       	st.w	r7[0x0],r8
8000bacc:	6e 28       	ld.w	r8,r7[0x8]
8000bace:	0c 18       	sub	r8,r6
8000bad0:	8f 28       	st.w	r7[0x8],r8
8000bad2:	62 28       	ld.w	r8,r1[0x8]
8000bad4:	08 18       	sub	r8,r4
8000bad6:	83 28       	st.w	r1[0x8],r8
8000bad8:	c6 b0       	breq	8000bbae <__sfvwrite_r+0x28e>
8000bada:	08 16       	sub	r6,r4
8000badc:	08 03       	add	r3,r4
8000bade:	c7 1b       	rjmp	8000b9c0 <__sfvwrite_r+0xa0>
8000bae0:	60 03       	ld.w	r3,r0[0x0]
8000bae2:	60 11       	ld.w	r1,r0[0x4]
8000bae4:	30 08       	mov	r8,0
8000bae6:	2f 80       	sub	r0,-8
8000bae8:	50 08       	stdsp	sp[0x0],r8
8000baea:	58 01       	cp.w	r1,0
8000baec:	cf a0       	breq	8000bae0 <__sfvwrite_r+0x1c0>
8000baee:	40 0a       	lddsp	r10,sp[0x0]
8000baf0:	58 0a       	cp.w	r10,0
8000baf2:	c1 41       	brne	8000bb1a <__sfvwrite_r+0x1fa>
8000baf4:	e2 c6 ff ff 	sub	r6,r1,-1
8000baf8:	02 9a       	mov	r10,r1
8000bafa:	30 ab       	mov	r11,10
8000bafc:	06 9c       	mov	r12,r3
8000bafe:	ce 3c       	rcall	8000bcc4 <memchr>
8000bb00:	f8 c8 ff ff 	sub	r8,r12,-1
8000bb04:	58 0c       	cp.w	r12,0
8000bb06:	f1 d3 e1 16 	subne	r6,r8,r3
8000bb0a:	f9 b9 01 01 	movne	r9,1
8000bb0e:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000bb12:	f9 b8 00 01 	moveq	r8,1
8000bb16:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000bb1a:	02 36       	cp.w	r6,r1
8000bb1c:	ec 04 17 80 	movls	r4,r6
8000bb20:	e2 04 17 b0 	movhi	r4,r1
8000bb24:	6e 59       	ld.w	r9,r7[0x14]
8000bb26:	6e 25       	ld.w	r5,r7[0x8]
8000bb28:	f2 05 00 05 	add	r5,r9,r5
8000bb2c:	0a 34       	cp.w	r4,r5
8000bb2e:	5f 9a       	srgt	r10
8000bb30:	6e 0c       	ld.w	r12,r7[0x0]
8000bb32:	6e 48       	ld.w	r8,r7[0x10]
8000bb34:	10 3c       	cp.w	r12,r8
8000bb36:	5f b8       	srhi	r8
8000bb38:	f5 e8 00 08 	and	r8,r10,r8
8000bb3c:	30 0a       	mov	r10,0
8000bb3e:	f4 08 18 00 	cp.b	r8,r10
8000bb42:	c0 d0       	breq	8000bb5c <__sfvwrite_r+0x23c>
8000bb44:	06 9b       	mov	r11,r3
8000bb46:	0a 9a       	mov	r10,r5
8000bb48:	cc 9c       	rcall	8000bcda <memmove>
8000bb4a:	6e 08       	ld.w	r8,r7[0x0]
8000bb4c:	0a 08       	add	r8,r5
8000bb4e:	0e 9b       	mov	r11,r7
8000bb50:	8f 08       	st.w	r7[0x0],r8
8000bb52:	40 1c       	lddsp	r12,sp[0x4]
8000bb54:	fe b0 fc ae 	rcall	8000b4b0 <_fflush_r>
8000bb58:	c1 70       	breq	8000bb86 <__sfvwrite_r+0x266>
8000bb5a:	c2 58       	rjmp	8000bba4 <__sfvwrite_r+0x284>
8000bb5c:	12 34       	cp.w	r4,r9
8000bb5e:	c0 a5       	brlt	8000bb72 <__sfvwrite_r+0x252>
8000bb60:	6e a8       	ld.w	r8,r7[0x28]
8000bb62:	06 9a       	mov	r10,r3
8000bb64:	6e 8b       	ld.w	r11,r7[0x20]
8000bb66:	40 1c       	lddsp	r12,sp[0x4]
8000bb68:	5d 18       	icall	r8
8000bb6a:	18 95       	mov	r5,r12
8000bb6c:	e0 89 00 0d 	brgt	8000bb86 <__sfvwrite_r+0x266>
8000bb70:	c1 a8       	rjmp	8000bba4 <__sfvwrite_r+0x284>
8000bb72:	08 9a       	mov	r10,r4
8000bb74:	06 9b       	mov	r11,r3
8000bb76:	cb 2c       	rcall	8000bcda <memmove>
8000bb78:	6e 08       	ld.w	r8,r7[0x0]
8000bb7a:	08 08       	add	r8,r4
8000bb7c:	08 95       	mov	r5,r4
8000bb7e:	8f 08       	st.w	r7[0x0],r8
8000bb80:	6e 28       	ld.w	r8,r7[0x8]
8000bb82:	08 18       	sub	r8,r4
8000bb84:	8f 28       	st.w	r7[0x8],r8
8000bb86:	0a 16       	sub	r6,r5
8000bb88:	c0 71       	brne	8000bb96 <__sfvwrite_r+0x276>
8000bb8a:	0e 9b       	mov	r11,r7
8000bb8c:	40 1c       	lddsp	r12,sp[0x4]
8000bb8e:	fe b0 fc 91 	rcall	8000b4b0 <_fflush_r>
8000bb92:	c0 91       	brne	8000bba4 <__sfvwrite_r+0x284>
8000bb94:	50 06       	stdsp	sp[0x0],r6
8000bb96:	64 28       	ld.w	r8,r2[0x8]
8000bb98:	0a 18       	sub	r8,r5
8000bb9a:	85 28       	st.w	r2[0x8],r8
8000bb9c:	c0 90       	breq	8000bbae <__sfvwrite_r+0x28e>
8000bb9e:	0a 11       	sub	r1,r5
8000bba0:	0a 03       	add	r3,r5
8000bba2:	ca 4b       	rjmp	8000baea <__sfvwrite_r+0x1ca>
8000bba4:	8e 68       	ld.sh	r8,r7[0xc]
8000bba6:	a7 a8       	sbr	r8,0x6
8000bba8:	ae 68       	st.h	r7[0xc],r8
8000bbaa:	3f fc       	mov	r12,-1
8000bbac:	c0 28       	rjmp	8000bbb0 <__sfvwrite_r+0x290>
8000bbae:	30 0c       	mov	r12,0
8000bbb0:	2f dd       	sub	sp,-12
8000bbb2:	d8 32       	popm	r0-r7,pc

8000bbb4 <_fwalk>:
8000bbb4:	d4 31       	pushm	r0-r7,lr
8000bbb6:	30 05       	mov	r5,0
8000bbb8:	16 91       	mov	r1,r11
8000bbba:	f8 c7 ff 28 	sub	r7,r12,-216
8000bbbe:	0a 92       	mov	r2,r5
8000bbc0:	fe b0 fc fe 	rcall	8000b5bc <__sfp_lock_acquire>
8000bbc4:	3f f3       	mov	r3,-1
8000bbc6:	c1 68       	rjmp	8000bbf2 <_fwalk+0x3e>
8000bbc8:	6e 26       	ld.w	r6,r7[0x8]
8000bbca:	6e 14       	ld.w	r4,r7[0x4]
8000bbcc:	2f 46       	sub	r6,-12
8000bbce:	c0 c8       	rjmp	8000bbe6 <_fwalk+0x32>
8000bbd0:	8c 08       	ld.sh	r8,r6[0x0]
8000bbd2:	e4 08 19 00 	cp.h	r8,r2
8000bbd6:	c0 70       	breq	8000bbe4 <_fwalk+0x30>
8000bbd8:	8c 18       	ld.sh	r8,r6[0x2]
8000bbda:	e6 08 19 00 	cp.h	r8,r3
8000bbde:	c0 30       	breq	8000bbe4 <_fwalk+0x30>
8000bbe0:	5d 11       	icall	r1
8000bbe2:	18 45       	or	r5,r12
8000bbe4:	2a 46       	sub	r6,-92
8000bbe6:	20 14       	sub	r4,1
8000bbe8:	ec cc 00 0c 	sub	r12,r6,12
8000bbec:	58 04       	cp.w	r4,0
8000bbee:	cf 14       	brge	8000bbd0 <_fwalk+0x1c>
8000bbf0:	6e 07       	ld.w	r7,r7[0x0]
8000bbf2:	58 07       	cp.w	r7,0
8000bbf4:	ce a1       	brne	8000bbc8 <_fwalk+0x14>
8000bbf6:	fe b0 fc e4 	rcall	8000b5be <__sfp_lock_release>
8000bbfa:	0a 9c       	mov	r12,r5
8000bbfc:	d8 32       	popm	r0-r7,pc
8000bbfe:	d7 03       	nop

8000bc00 <_localeconv_r>:
8000bc00:	fe cc d3 5c 	sub	r12,pc,-11428
8000bc04:	5e fc       	retal	r12
8000bc06:	d7 03       	nop

8000bc08 <__smakebuf_r>:
8000bc08:	d4 21       	pushm	r4-r7,lr
8000bc0a:	20 fd       	sub	sp,60
8000bc0c:	96 68       	ld.sh	r8,r11[0xc]
8000bc0e:	16 97       	mov	r7,r11
8000bc10:	18 96       	mov	r6,r12
8000bc12:	e2 18 00 02 	andl	r8,0x2,COH
8000bc16:	c3 d1       	brne	8000bc90 <__smakebuf_r+0x88>
8000bc18:	96 7b       	ld.sh	r11,r11[0xe]
8000bc1a:	f0 0b 19 00 	cp.h	r11,r8
8000bc1e:	c0 55       	brlt	8000bc28 <__smakebuf_r+0x20>
8000bc20:	1a 9a       	mov	r10,sp
8000bc22:	e0 a0 04 81 	rcall	8000c524 <_fstat_r>
8000bc26:	c0 f4       	brge	8000bc44 <__smakebuf_r+0x3c>
8000bc28:	8e 65       	ld.sh	r5,r7[0xc]
8000bc2a:	0a 98       	mov	r8,r5
8000bc2c:	ab b8       	sbr	r8,0xb
8000bc2e:	e2 15 00 80 	andl	r5,0x80,COH
8000bc32:	ae 68       	st.h	r7[0xc],r8
8000bc34:	30 04       	mov	r4,0
8000bc36:	e0 68 04 00 	mov	r8,1024
8000bc3a:	f9 b5 01 40 	movne	r5,64
8000bc3e:	f0 05 17 00 	moveq	r5,r8
8000bc42:	c1 c8       	rjmp	8000bc7a <__smakebuf_r+0x72>
8000bc44:	40 18       	lddsp	r8,sp[0x4]
8000bc46:	e2 18 f0 00 	andl	r8,0xf000,COH
8000bc4a:	e0 48 20 00 	cp.w	r8,8192
8000bc4e:	5f 04       	sreq	r4
8000bc50:	e0 48 80 00 	cp.w	r8,32768
8000bc54:	c0 e1       	brne	8000bc70 <__smakebuf_r+0x68>
8000bc56:	6e b9       	ld.w	r9,r7[0x2c]
8000bc58:	fe c8 f9 1c 	sub	r8,pc,-1764
8000bc5c:	10 39       	cp.w	r9,r8
8000bc5e:	c0 91       	brne	8000bc70 <__smakebuf_r+0x68>
8000bc60:	8e 68       	ld.sh	r8,r7[0xc]
8000bc62:	e0 65 04 00 	mov	r5,1024
8000bc66:	ab a8       	sbr	r8,0xa
8000bc68:	ef 45 00 50 	st.w	r7[80],r5
8000bc6c:	ae 68       	st.h	r7[0xc],r8
8000bc6e:	c0 68       	rjmp	8000bc7a <__smakebuf_r+0x72>
8000bc70:	8e 68       	ld.sh	r8,r7[0xc]
8000bc72:	e0 65 04 00 	mov	r5,1024
8000bc76:	ab b8       	sbr	r8,0xb
8000bc78:	ae 68       	st.h	r7[0xc],r8
8000bc7a:	0a 9b       	mov	r11,r5
8000bc7c:	0c 9c       	mov	r12,r6
8000bc7e:	fe b0 df 23 	rcall	80007ac4 <_malloc_r>
8000bc82:	8e 68       	ld.sh	r8,r7[0xc]
8000bc84:	c0 d1       	brne	8000bc9e <__smakebuf_r+0x96>
8000bc86:	ed b8 00 09 	bld	r8,0x9
8000bc8a:	c1 b0       	breq	8000bcc0 <__smakebuf_r+0xb8>
8000bc8c:	a1 b8       	sbr	r8,0x1
8000bc8e:	ae 68       	st.h	r7[0xc],r8
8000bc90:	ee c8 ff b9 	sub	r8,r7,-71
8000bc94:	8f 48       	st.w	r7[0x10],r8
8000bc96:	8f 08       	st.w	r7[0x0],r8
8000bc98:	30 18       	mov	r8,1
8000bc9a:	8f 58       	st.w	r7[0x14],r8
8000bc9c:	c1 28       	rjmp	8000bcc0 <__smakebuf_r+0xb8>
8000bc9e:	a7 b8       	sbr	r8,0x7
8000bca0:	8f 4c       	st.w	r7[0x10],r12
8000bca2:	ae 68       	st.h	r7[0xc],r8
8000bca4:	8f 55       	st.w	r7[0x14],r5
8000bca6:	fe c8 06 e6 	sub	r8,pc,1766
8000bcaa:	8f 0c       	st.w	r7[0x0],r12
8000bcac:	8d a8       	st.w	r6[0x28],r8
8000bcae:	58 04       	cp.w	r4,0
8000bcb0:	c0 80       	breq	8000bcc0 <__smakebuf_r+0xb8>
8000bcb2:	8e 7c       	ld.sh	r12,r7[0xe]
8000bcb4:	fe b0 e3 94 	rcall	800083dc <isatty>
8000bcb8:	c0 40       	breq	8000bcc0 <__smakebuf_r+0xb8>
8000bcba:	8e 68       	ld.sh	r8,r7[0xc]
8000bcbc:	a1 a8       	sbr	r8,0x0
8000bcbe:	ae 68       	st.h	r7[0xc],r8
8000bcc0:	2f 1d       	sub	sp,-60
8000bcc2:	d8 22       	popm	r4-r7,pc

8000bcc4 <memchr>:
8000bcc4:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000bcc8:	c0 68       	rjmp	8000bcd4 <memchr+0x10>
8000bcca:	20 1a       	sub	r10,1
8000bccc:	19 88       	ld.ub	r8,r12[0x0]
8000bcce:	16 38       	cp.w	r8,r11
8000bcd0:	5e 0c       	reteq	r12
8000bcd2:	2f fc       	sub	r12,-1
8000bcd4:	58 0a       	cp.w	r10,0
8000bcd6:	cf a1       	brne	8000bcca <memchr+0x6>
8000bcd8:	5e fa       	retal	r10

8000bcda <memmove>:
8000bcda:	d4 01       	pushm	lr
8000bcdc:	18 3b       	cp.w	r11,r12
8000bcde:	c1 92       	brcc	8000bd10 <memmove+0x36>
8000bce0:	f6 0a 00 09 	add	r9,r11,r10
8000bce4:	12 3c       	cp.w	r12,r9
8000bce6:	c1 52       	brcc	8000bd10 <memmove+0x36>
8000bce8:	f8 0a 00 0b 	add	r11,r12,r10
8000bcec:	30 08       	mov	r8,0
8000bcee:	c0 68       	rjmp	8000bcfa <memmove+0x20>
8000bcf0:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000bcf4:	20 1a       	sub	r10,1
8000bcf6:	f6 08 0b 0e 	st.b	r11[r8],lr
8000bcfa:	20 18       	sub	r8,1
8000bcfc:	58 0a       	cp.w	r10,0
8000bcfe:	cf 91       	brne	8000bcf0 <memmove+0x16>
8000bd00:	d8 02       	popm	pc
8000bd02:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000bd06:	20 1a       	sub	r10,1
8000bd08:	f8 08 0b 09 	st.b	r12[r8],r9
8000bd0c:	2f f8       	sub	r8,-1
8000bd0e:	c0 28       	rjmp	8000bd12 <memmove+0x38>
8000bd10:	30 08       	mov	r8,0
8000bd12:	58 0a       	cp.w	r10,0
8000bd14:	cf 71       	brne	8000bd02 <memmove+0x28>
8000bd16:	d8 02       	popm	pc

8000bd18 <__hi0bits>:
8000bd18:	18 98       	mov	r8,r12
8000bd1a:	e0 1c 00 00 	andl	r12,0x0
8000bd1e:	f0 09 15 10 	lsl	r9,r8,0x10
8000bd22:	58 0c       	cp.w	r12,0
8000bd24:	f2 08 17 00 	moveq	r8,r9
8000bd28:	f9 bc 00 10 	moveq	r12,16
8000bd2c:	f9 bc 01 00 	movne	r12,0
8000bd30:	10 9a       	mov	r10,r8
8000bd32:	f0 09 15 08 	lsl	r9,r8,0x8
8000bd36:	e6 1a ff 00 	andh	r10,0xff00,COH
8000bd3a:	f7 bc 00 f8 	subeq	r12,-8
8000bd3e:	f2 08 17 00 	moveq	r8,r9
8000bd42:	10 9a       	mov	r10,r8
8000bd44:	f0 09 15 04 	lsl	r9,r8,0x4
8000bd48:	e6 1a f0 00 	andh	r10,0xf000,COH
8000bd4c:	f7 bc 00 fc 	subeq	r12,-4
8000bd50:	f2 08 17 00 	moveq	r8,r9
8000bd54:	10 9a       	mov	r10,r8
8000bd56:	f0 09 15 02 	lsl	r9,r8,0x2
8000bd5a:	e6 1a c0 00 	andh	r10,0xc000,COH
8000bd5e:	f7 bc 00 fe 	subeq	r12,-2
8000bd62:	f2 08 17 00 	moveq	r8,r9
8000bd66:	58 08       	cp.w	r8,0
8000bd68:	5e 5c       	retlt	r12
8000bd6a:	ed b8 00 1e 	bld	r8,0x1e
8000bd6e:	f9 bc 01 20 	movne	r12,32
8000bd72:	f7 bc 00 ff 	subeq	r12,-1
8000bd76:	5e fc       	retal	r12

8000bd78 <__lo0bits>:
8000bd78:	18 99       	mov	r9,r12
8000bd7a:	78 08       	ld.w	r8,r12[0x0]
8000bd7c:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000bd80:	c1 50       	breq	8000bdaa <__lo0bits+0x32>
8000bd82:	ed b8 00 00 	bld	r8,0x0
8000bd86:	c0 21       	brne	8000bd8a <__lo0bits+0x12>
8000bd88:	5e fd       	retal	0
8000bd8a:	10 9b       	mov	r11,r8
8000bd8c:	f0 0a 16 01 	lsr	r10,r8,0x1
8000bd90:	e2 1b 00 02 	andl	r11,0x2,COH
8000bd94:	a3 88       	lsr	r8,0x2
8000bd96:	58 0b       	cp.w	r11,0
8000bd98:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000bd9c:	f9 bc 01 01 	movne	r12,1
8000bda0:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000bda4:	f9 bc 00 02 	moveq	r12,2
8000bda8:	5e fc       	retal	r12
8000bdaa:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000bdae:	f0 0b 16 10 	lsr	r11,r8,0x10
8000bdb2:	58 0a       	cp.w	r10,0
8000bdb4:	f6 08 17 00 	moveq	r8,r11
8000bdb8:	f9 bc 00 10 	moveq	r12,16
8000bdbc:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000bdc0:	f0 0a 16 08 	lsr	r10,r8,0x8
8000bdc4:	58 0b       	cp.w	r11,0
8000bdc6:	f7 bc 00 f8 	subeq	r12,-8
8000bdca:	f4 08 17 00 	moveq	r8,r10
8000bdce:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000bdd2:	f0 0a 16 04 	lsr	r10,r8,0x4
8000bdd6:	58 0b       	cp.w	r11,0
8000bdd8:	f7 bc 00 fc 	subeq	r12,-4
8000bddc:	f4 08 17 00 	moveq	r8,r10
8000bde0:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000bde4:	f0 0a 16 02 	lsr	r10,r8,0x2
8000bde8:	58 0b       	cp.w	r11,0
8000bdea:	f7 bc 00 fe 	subeq	r12,-2
8000bdee:	f4 08 17 00 	moveq	r8,r10
8000bdf2:	ed b8 00 00 	bld	r8,0x0
8000bdf6:	c0 60       	breq	8000be02 <__lo0bits+0x8a>
8000bdf8:	a1 98       	lsr	r8,0x1
8000bdfa:	c0 31       	brne	8000be00 <__lo0bits+0x88>
8000bdfc:	32 0c       	mov	r12,32
8000bdfe:	5e fc       	retal	r12
8000be00:	2f fc       	sub	r12,-1
8000be02:	93 08       	st.w	r9[0x0],r8
8000be04:	5e fc       	retal	r12

8000be06 <__mcmp>:
8000be06:	d4 01       	pushm	lr
8000be08:	18 98       	mov	r8,r12
8000be0a:	76 49       	ld.w	r9,r11[0x10]
8000be0c:	78 4c       	ld.w	r12,r12[0x10]
8000be0e:	12 1c       	sub	r12,r9
8000be10:	c1 31       	brne	8000be36 <__mcmp+0x30>
8000be12:	2f b9       	sub	r9,-5
8000be14:	a3 69       	lsl	r9,0x2
8000be16:	12 0b       	add	r11,r9
8000be18:	f0 09 00 09 	add	r9,r8,r9
8000be1c:	2e c8       	sub	r8,-20
8000be1e:	13 4e       	ld.w	lr,--r9
8000be20:	17 4a       	ld.w	r10,--r11
8000be22:	14 3e       	cp.w	lr,r10
8000be24:	c0 60       	breq	8000be30 <__mcmp+0x2a>
8000be26:	f9 bc 03 ff 	movlo	r12,-1
8000be2a:	f9 bc 02 01 	movhs	r12,1
8000be2e:	d8 02       	popm	pc
8000be30:	10 39       	cp.w	r9,r8
8000be32:	fe 9b ff f6 	brhi	8000be1e <__mcmp+0x18>
8000be36:	d8 02       	popm	pc

8000be38 <_Bfree>:
8000be38:	d4 21       	pushm	r4-r7,lr
8000be3a:	18 97       	mov	r7,r12
8000be3c:	16 95       	mov	r5,r11
8000be3e:	78 96       	ld.w	r6,r12[0x24]
8000be40:	58 06       	cp.w	r6,0
8000be42:	c0 91       	brne	8000be54 <_Bfree+0x1c>
8000be44:	31 0c       	mov	r12,16
8000be46:	fe b0 de 37 	rcall	80007ab4 <malloc>
8000be4a:	99 36       	st.w	r12[0xc],r6
8000be4c:	8f 9c       	st.w	r7[0x24],r12
8000be4e:	99 16       	st.w	r12[0x4],r6
8000be50:	99 26       	st.w	r12[0x8],r6
8000be52:	99 06       	st.w	r12[0x0],r6
8000be54:	58 05       	cp.w	r5,0
8000be56:	c0 90       	breq	8000be68 <_Bfree+0x30>
8000be58:	6a 19       	ld.w	r9,r5[0x4]
8000be5a:	6e 98       	ld.w	r8,r7[0x24]
8000be5c:	70 38       	ld.w	r8,r8[0xc]
8000be5e:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000be62:	8b 0a       	st.w	r5[0x0],r10
8000be64:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000be68:	d8 22       	popm	r4-r7,pc
8000be6a:	d7 03       	nop

8000be6c <_Balloc>:
8000be6c:	d4 21       	pushm	r4-r7,lr
8000be6e:	18 97       	mov	r7,r12
8000be70:	16 96       	mov	r6,r11
8000be72:	78 95       	ld.w	r5,r12[0x24]
8000be74:	58 05       	cp.w	r5,0
8000be76:	c0 91       	brne	8000be88 <_Balloc+0x1c>
8000be78:	31 0c       	mov	r12,16
8000be7a:	fe b0 de 1d 	rcall	80007ab4 <malloc>
8000be7e:	99 35       	st.w	r12[0xc],r5
8000be80:	8f 9c       	st.w	r7[0x24],r12
8000be82:	99 15       	st.w	r12[0x4],r5
8000be84:	99 25       	st.w	r12[0x8],r5
8000be86:	99 05       	st.w	r12[0x0],r5
8000be88:	6e 95       	ld.w	r5,r7[0x24]
8000be8a:	6a 38       	ld.w	r8,r5[0xc]
8000be8c:	58 08       	cp.w	r8,0
8000be8e:	c0 b1       	brne	8000bea4 <_Balloc+0x38>
8000be90:	31 0a       	mov	r10,16
8000be92:	30 4b       	mov	r11,4
8000be94:	0e 9c       	mov	r12,r7
8000be96:	e0 a0 02 a7 	rcall	8000c3e4 <_calloc_r>
8000be9a:	8b 3c       	st.w	r5[0xc],r12
8000be9c:	6e 98       	ld.w	r8,r7[0x24]
8000be9e:	70 3c       	ld.w	r12,r8[0xc]
8000bea0:	58 0c       	cp.w	r12,0
8000bea2:	c1 b0       	breq	8000bed8 <_Balloc+0x6c>
8000bea4:	6e 98       	ld.w	r8,r7[0x24]
8000bea6:	70 38       	ld.w	r8,r8[0xc]
8000bea8:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000beac:	70 0c       	ld.w	r12,r8[0x0]
8000beae:	58 0c       	cp.w	r12,0
8000beb0:	c0 40       	breq	8000beb8 <_Balloc+0x4c>
8000beb2:	78 09       	ld.w	r9,r12[0x0]
8000beb4:	91 09       	st.w	r8[0x0],r9
8000beb6:	c0 e8       	rjmp	8000bed2 <_Balloc+0x66>
8000beb8:	0e 9c       	mov	r12,r7
8000beba:	30 17       	mov	r7,1
8000bebc:	0e 9b       	mov	r11,r7
8000bebe:	ee 06 09 47 	lsl	r7,r7,r6
8000bec2:	ee ca ff fb 	sub	r10,r7,-5
8000bec6:	a3 6a       	lsl	r10,0x2
8000bec8:	e0 a0 02 8e 	rcall	8000c3e4 <_calloc_r>
8000becc:	c0 60       	breq	8000bed8 <_Balloc+0x6c>
8000bece:	99 16       	st.w	r12[0x4],r6
8000bed0:	99 27       	st.w	r12[0x8],r7
8000bed2:	30 08       	mov	r8,0
8000bed4:	99 38       	st.w	r12[0xc],r8
8000bed6:	99 48       	st.w	r12[0x10],r8
8000bed8:	d8 22       	popm	r4-r7,pc
8000beda:	d7 03       	nop

8000bedc <__d2b>:
8000bedc:	d4 31       	pushm	r0-r7,lr
8000bede:	20 2d       	sub	sp,8
8000bee0:	16 93       	mov	r3,r11
8000bee2:	12 96       	mov	r6,r9
8000bee4:	10 95       	mov	r5,r8
8000bee6:	14 92       	mov	r2,r10
8000bee8:	30 1b       	mov	r11,1
8000beea:	cc 1f       	rcall	8000be6c <_Balloc>
8000beec:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000bef0:	50 09       	stdsp	sp[0x0],r9
8000bef2:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000bef6:	b5 a9       	sbr	r9,0x14
8000bef8:	f0 01 16 14 	lsr	r1,r8,0x14
8000befc:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000bf00:	18 94       	mov	r4,r12
8000bf02:	58 02       	cp.w	r2,0
8000bf04:	c1 d0       	breq	8000bf3e <__d2b+0x62>
8000bf06:	fa cc ff f8 	sub	r12,sp,-8
8000bf0a:	18 d2       	st.w	--r12,r2
8000bf0c:	c3 6f       	rcall	8000bd78 <__lo0bits>
8000bf0e:	40 18       	lddsp	r8,sp[0x4]
8000bf10:	c0 d0       	breq	8000bf2a <__d2b+0x4e>
8000bf12:	40 09       	lddsp	r9,sp[0x0]
8000bf14:	f8 0a 11 20 	rsub	r10,r12,32
8000bf18:	f2 0a 09 4a 	lsl	r10,r9,r10
8000bf1c:	f5 e8 10 08 	or	r8,r10,r8
8000bf20:	89 58       	st.w	r4[0x14],r8
8000bf22:	f2 0c 0a 49 	lsr	r9,r9,r12
8000bf26:	50 09       	stdsp	sp[0x0],r9
8000bf28:	c0 28       	rjmp	8000bf2c <__d2b+0x50>
8000bf2a:	89 58       	st.w	r4[0x14],r8
8000bf2c:	40 08       	lddsp	r8,sp[0x0]
8000bf2e:	58 08       	cp.w	r8,0
8000bf30:	f9 b3 01 02 	movne	r3,2
8000bf34:	f9 b3 00 01 	moveq	r3,1
8000bf38:	89 68       	st.w	r4[0x18],r8
8000bf3a:	89 43       	st.w	r4[0x10],r3
8000bf3c:	c0 88       	rjmp	8000bf4c <__d2b+0x70>
8000bf3e:	1a 9c       	mov	r12,sp
8000bf40:	c1 cf       	rcall	8000bd78 <__lo0bits>
8000bf42:	30 13       	mov	r3,1
8000bf44:	40 08       	lddsp	r8,sp[0x0]
8000bf46:	2e 0c       	sub	r12,-32
8000bf48:	89 43       	st.w	r4[0x10],r3
8000bf4a:	89 58       	st.w	r4[0x14],r8
8000bf4c:	58 01       	cp.w	r1,0
8000bf4e:	c0 90       	breq	8000bf60 <__d2b+0x84>
8000bf50:	e2 c1 04 33 	sub	r1,r1,1075
8000bf54:	18 01       	add	r1,r12
8000bf56:	8d 01       	st.w	r6[0x0],r1
8000bf58:	f8 0c 11 35 	rsub	r12,r12,53
8000bf5c:	8b 0c       	st.w	r5[0x0],r12
8000bf5e:	c0 c8       	rjmp	8000bf76 <__d2b+0x9a>
8000bf60:	e6 c8 ff fc 	sub	r8,r3,-4
8000bf64:	f8 cc 04 32 	sub	r12,r12,1074
8000bf68:	a5 73       	lsl	r3,0x5
8000bf6a:	8d 0c       	st.w	r6[0x0],r12
8000bf6c:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000bf70:	cd 4e       	rcall	8000bd18 <__hi0bits>
8000bf72:	18 13       	sub	r3,r12
8000bf74:	8b 03       	st.w	r5[0x0],r3
8000bf76:	08 9c       	mov	r12,r4
8000bf78:	2f ed       	sub	sp,-8
8000bf7a:	d8 32       	popm	r0-r7,pc

8000bf7c <__mdiff>:
8000bf7c:	d4 31       	pushm	r0-r7,lr
8000bf7e:	74 48       	ld.w	r8,r10[0x10]
8000bf80:	76 45       	ld.w	r5,r11[0x10]
8000bf82:	16 97       	mov	r7,r11
8000bf84:	14 96       	mov	r6,r10
8000bf86:	10 15       	sub	r5,r8
8000bf88:	c1 31       	brne	8000bfae <__mdiff+0x32>
8000bf8a:	2f b8       	sub	r8,-5
8000bf8c:	ee ce ff ec 	sub	lr,r7,-20
8000bf90:	a3 68       	lsl	r8,0x2
8000bf92:	f4 08 00 0b 	add	r11,r10,r8
8000bf96:	ee 08 00 08 	add	r8,r7,r8
8000bf9a:	11 4a       	ld.w	r10,--r8
8000bf9c:	17 49       	ld.w	r9,--r11
8000bf9e:	12 3a       	cp.w	r10,r9
8000bfa0:	c0 30       	breq	8000bfa6 <__mdiff+0x2a>
8000bfa2:	c0 e2       	brcc	8000bfbe <__mdiff+0x42>
8000bfa4:	c0 78       	rjmp	8000bfb2 <__mdiff+0x36>
8000bfa6:	1c 38       	cp.w	r8,lr
8000bfa8:	fe 9b ff f9 	brhi	8000bf9a <__mdiff+0x1e>
8000bfac:	c4 98       	rjmp	8000c03e <__mdiff+0xc2>
8000bfae:	58 05       	cp.w	r5,0
8000bfb0:	c0 64       	brge	8000bfbc <__mdiff+0x40>
8000bfb2:	0e 98       	mov	r8,r7
8000bfb4:	30 15       	mov	r5,1
8000bfb6:	0c 97       	mov	r7,r6
8000bfb8:	10 96       	mov	r6,r8
8000bfba:	c0 28       	rjmp	8000bfbe <__mdiff+0x42>
8000bfbc:	30 05       	mov	r5,0
8000bfbe:	6e 1b       	ld.w	r11,r7[0x4]
8000bfc0:	c5 6f       	rcall	8000be6c <_Balloc>
8000bfc2:	6e 49       	ld.w	r9,r7[0x10]
8000bfc4:	6c 44       	ld.w	r4,r6[0x10]
8000bfc6:	99 35       	st.w	r12[0xc],r5
8000bfc8:	2f b4       	sub	r4,-5
8000bfca:	f2 c5 ff fb 	sub	r5,r9,-5
8000bfce:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000bfd2:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000bfd6:	2e c6       	sub	r6,-20
8000bfd8:	2e c7       	sub	r7,-20
8000bfda:	f8 c8 ff ec 	sub	r8,r12,-20
8000bfde:	30 0a       	mov	r10,0
8000bfe0:	0f 0e       	ld.w	lr,r7++
8000bfe2:	0d 0b       	ld.w	r11,r6++
8000bfe4:	fc 02 16 10 	lsr	r2,lr,0x10
8000bfe8:	f6 03 16 10 	lsr	r3,r11,0x10
8000bfec:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000bff0:	e4 03 01 03 	sub	r3,r2,r3
8000bff4:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000bff8:	fc 0b 01 0b 	sub	r11,lr,r11
8000bffc:	f6 0a 00 0a 	add	r10,r11,r10
8000c000:	b0 1a       	st.h	r8[0x2],r10
8000c002:	b1 4a       	asr	r10,0x10
8000c004:	e6 0a 00 0a 	add	r10,r3,r10
8000c008:	b0 0a       	st.h	r8[0x0],r10
8000c00a:	2f c8       	sub	r8,-4
8000c00c:	b1 4a       	asr	r10,0x10
8000c00e:	08 36       	cp.w	r6,r4
8000c010:	ce 83       	brcs	8000bfe0 <__mdiff+0x64>
8000c012:	c0 d8       	rjmp	8000c02c <__mdiff+0xb0>
8000c014:	0f 0b       	ld.w	r11,r7++
8000c016:	f6 0e 16 10 	lsr	lr,r11,0x10
8000c01a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c01e:	16 0a       	add	r10,r11
8000c020:	b0 1a       	st.h	r8[0x2],r10
8000c022:	b1 4a       	asr	r10,0x10
8000c024:	1c 0a       	add	r10,lr
8000c026:	b0 0a       	st.h	r8[0x0],r10
8000c028:	2f c8       	sub	r8,-4
8000c02a:	b1 4a       	asr	r10,0x10
8000c02c:	0a 37       	cp.w	r7,r5
8000c02e:	cf 33       	brcs	8000c014 <__mdiff+0x98>
8000c030:	c0 28       	rjmp	8000c034 <__mdiff+0xb8>
8000c032:	20 19       	sub	r9,1
8000c034:	11 4a       	ld.w	r10,--r8
8000c036:	58 0a       	cp.w	r10,0
8000c038:	cf d0       	breq	8000c032 <__mdiff+0xb6>
8000c03a:	99 49       	st.w	r12[0x10],r9
8000c03c:	d8 32       	popm	r0-r7,pc
8000c03e:	30 0b       	mov	r11,0
8000c040:	c1 6f       	rcall	8000be6c <_Balloc>
8000c042:	30 18       	mov	r8,1
8000c044:	99 48       	st.w	r12[0x10],r8
8000c046:	30 08       	mov	r8,0
8000c048:	99 58       	st.w	r12[0x14],r8
8000c04a:	d8 32       	popm	r0-r7,pc

8000c04c <__lshift>:
8000c04c:	d4 31       	pushm	r0-r7,lr
8000c04e:	16 97       	mov	r7,r11
8000c050:	76 46       	ld.w	r6,r11[0x10]
8000c052:	f4 02 14 05 	asr	r2,r10,0x5
8000c056:	2f f6       	sub	r6,-1
8000c058:	14 93       	mov	r3,r10
8000c05a:	18 94       	mov	r4,r12
8000c05c:	04 06       	add	r6,r2
8000c05e:	76 1b       	ld.w	r11,r11[0x4]
8000c060:	6e 28       	ld.w	r8,r7[0x8]
8000c062:	c0 38       	rjmp	8000c068 <__lshift+0x1c>
8000c064:	2f fb       	sub	r11,-1
8000c066:	a1 78       	lsl	r8,0x1
8000c068:	10 36       	cp.w	r6,r8
8000c06a:	fe 99 ff fd 	brgt	8000c064 <__lshift+0x18>
8000c06e:	08 9c       	mov	r12,r4
8000c070:	cf ee       	rcall	8000be6c <_Balloc>
8000c072:	30 09       	mov	r9,0
8000c074:	18 95       	mov	r5,r12
8000c076:	f8 c8 ff ec 	sub	r8,r12,-20
8000c07a:	12 9a       	mov	r10,r9
8000c07c:	c0 38       	rjmp	8000c082 <__lshift+0x36>
8000c07e:	10 aa       	st.w	r8++,r10
8000c080:	2f f9       	sub	r9,-1
8000c082:	04 39       	cp.w	r9,r2
8000c084:	cf d5       	brlt	8000c07e <__lshift+0x32>
8000c086:	6e 4b       	ld.w	r11,r7[0x10]
8000c088:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000c08c:	2f bb       	sub	r11,-5
8000c08e:	ee c9 ff ec 	sub	r9,r7,-20
8000c092:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000c096:	58 03       	cp.w	r3,0
8000c098:	c1 30       	breq	8000c0be <__lshift+0x72>
8000c09a:	e6 0c 11 20 	rsub	r12,r3,32
8000c09e:	30 0a       	mov	r10,0
8000c0a0:	72 02       	ld.w	r2,r9[0x0]
8000c0a2:	e4 03 09 42 	lsl	r2,r2,r3
8000c0a6:	04 4a       	or	r10,r2
8000c0a8:	10 aa       	st.w	r8++,r10
8000c0aa:	13 0a       	ld.w	r10,r9++
8000c0ac:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c0b0:	16 39       	cp.w	r9,r11
8000c0b2:	cf 73       	brcs	8000c0a0 <__lshift+0x54>
8000c0b4:	91 0a       	st.w	r8[0x0],r10
8000c0b6:	58 0a       	cp.w	r10,0
8000c0b8:	c0 70       	breq	8000c0c6 <__lshift+0x7a>
8000c0ba:	2f f6       	sub	r6,-1
8000c0bc:	c0 58       	rjmp	8000c0c6 <__lshift+0x7a>
8000c0be:	13 0a       	ld.w	r10,r9++
8000c0c0:	10 aa       	st.w	r8++,r10
8000c0c2:	16 39       	cp.w	r9,r11
8000c0c4:	cf d3       	brcs	8000c0be <__lshift+0x72>
8000c0c6:	08 9c       	mov	r12,r4
8000c0c8:	20 16       	sub	r6,1
8000c0ca:	0e 9b       	mov	r11,r7
8000c0cc:	8b 46       	st.w	r5[0x10],r6
8000c0ce:	cb 5e       	rcall	8000be38 <_Bfree>
8000c0d0:	0a 9c       	mov	r12,r5
8000c0d2:	d8 32       	popm	r0-r7,pc

8000c0d4 <__multiply>:
8000c0d4:	d4 31       	pushm	r0-r7,lr
8000c0d6:	20 2d       	sub	sp,8
8000c0d8:	76 49       	ld.w	r9,r11[0x10]
8000c0da:	74 48       	ld.w	r8,r10[0x10]
8000c0dc:	16 96       	mov	r6,r11
8000c0de:	14 95       	mov	r5,r10
8000c0e0:	10 39       	cp.w	r9,r8
8000c0e2:	ec 08 17 50 	movlt	r8,r6
8000c0e6:	ea 06 17 50 	movlt	r6,r5
8000c0ea:	f0 05 17 50 	movlt	r5,r8
8000c0ee:	6c 28       	ld.w	r8,r6[0x8]
8000c0f0:	76 43       	ld.w	r3,r11[0x10]
8000c0f2:	74 42       	ld.w	r2,r10[0x10]
8000c0f4:	76 1b       	ld.w	r11,r11[0x4]
8000c0f6:	e4 03 00 07 	add	r7,r2,r3
8000c0fa:	10 37       	cp.w	r7,r8
8000c0fc:	f7 bb 09 ff 	subgt	r11,-1
8000c100:	cb 6e       	rcall	8000be6c <_Balloc>
8000c102:	ee c4 ff fb 	sub	r4,r7,-5
8000c106:	f8 c9 ff ec 	sub	r9,r12,-20
8000c10a:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000c10e:	30 0a       	mov	r10,0
8000c110:	12 98       	mov	r8,r9
8000c112:	c0 28       	rjmp	8000c116 <__multiply+0x42>
8000c114:	10 aa       	st.w	r8++,r10
8000c116:	08 38       	cp.w	r8,r4
8000c118:	cf e3       	brcs	8000c114 <__multiply+0x40>
8000c11a:	2f b3       	sub	r3,-5
8000c11c:	2f b2       	sub	r2,-5
8000c11e:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000c122:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000c126:	ec cb ff ec 	sub	r11,r6,-20
8000c12a:	50 12       	stdsp	sp[0x4],r2
8000c12c:	ea ca ff ec 	sub	r10,r5,-20
8000c130:	c4 48       	rjmp	8000c1b8 <__multiply+0xe4>
8000c132:	94 95       	ld.uh	r5,r10[0x2]
8000c134:	58 05       	cp.w	r5,0
8000c136:	c2 00       	breq	8000c176 <__multiply+0xa2>
8000c138:	12 98       	mov	r8,r9
8000c13a:	16 96       	mov	r6,r11
8000c13c:	30 0e       	mov	lr,0
8000c13e:	50 09       	stdsp	sp[0x0],r9
8000c140:	0d 02       	ld.w	r2,r6++
8000c142:	e4 00 16 10 	lsr	r0,r2,0x10
8000c146:	70 01       	ld.w	r1,r8[0x0]
8000c148:	70 09       	ld.w	r9,r8[0x0]
8000c14a:	b1 81       	lsr	r1,0x10
8000c14c:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000c150:	e0 05 03 41 	mac	r1,r0,r5
8000c154:	ab 32       	mul	r2,r5
8000c156:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000c15a:	00 02       	add	r2,r0
8000c15c:	e4 0e 00 0e 	add	lr,r2,lr
8000c160:	b0 1e       	st.h	r8[0x2],lr
8000c162:	b1 8e       	lsr	lr,0x10
8000c164:	1c 01       	add	r1,lr
8000c166:	b0 01       	st.h	r8[0x0],r1
8000c168:	e2 0e 16 10 	lsr	lr,r1,0x10
8000c16c:	2f c8       	sub	r8,-4
8000c16e:	06 36       	cp.w	r6,r3
8000c170:	ce 83       	brcs	8000c140 <__multiply+0x6c>
8000c172:	40 09       	lddsp	r9,sp[0x0]
8000c174:	91 0e       	st.w	r8[0x0],lr
8000c176:	94 86       	ld.uh	r6,r10[0x0]
8000c178:	58 06       	cp.w	r6,0
8000c17a:	c1 d0       	breq	8000c1b4 <__multiply+0xe0>
8000c17c:	72 02       	ld.w	r2,r9[0x0]
8000c17e:	12 98       	mov	r8,r9
8000c180:	16 9e       	mov	lr,r11
8000c182:	30 05       	mov	r5,0
8000c184:	b0 12       	st.h	r8[0x2],r2
8000c186:	1d 01       	ld.w	r1,lr++
8000c188:	90 82       	ld.uh	r2,r8[0x0]
8000c18a:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000c18e:	ad 30       	mul	r0,r6
8000c190:	e0 02 00 02 	add	r2,r0,r2
8000c194:	e4 05 00 05 	add	r5,r2,r5
8000c198:	b0 05       	st.h	r8[0x0],r5
8000c19a:	b1 85       	lsr	r5,0x10
8000c19c:	b1 81       	lsr	r1,0x10
8000c19e:	2f c8       	sub	r8,-4
8000c1a0:	ad 31       	mul	r1,r6
8000c1a2:	90 92       	ld.uh	r2,r8[0x2]
8000c1a4:	e2 02 00 02 	add	r2,r1,r2
8000c1a8:	0a 02       	add	r2,r5
8000c1aa:	e4 05 16 10 	lsr	r5,r2,0x10
8000c1ae:	06 3e       	cp.w	lr,r3
8000c1b0:	ce a3       	brcs	8000c184 <__multiply+0xb0>
8000c1b2:	91 02       	st.w	r8[0x0],r2
8000c1b4:	2f ca       	sub	r10,-4
8000c1b6:	2f c9       	sub	r9,-4
8000c1b8:	40 18       	lddsp	r8,sp[0x4]
8000c1ba:	10 3a       	cp.w	r10,r8
8000c1bc:	cb b3       	brcs	8000c132 <__multiply+0x5e>
8000c1be:	c0 28       	rjmp	8000c1c2 <__multiply+0xee>
8000c1c0:	20 17       	sub	r7,1
8000c1c2:	58 07       	cp.w	r7,0
8000c1c4:	e0 8a 00 05 	brle	8000c1ce <__multiply+0xfa>
8000c1c8:	09 48       	ld.w	r8,--r4
8000c1ca:	58 08       	cp.w	r8,0
8000c1cc:	cf a0       	breq	8000c1c0 <__multiply+0xec>
8000c1ce:	99 47       	st.w	r12[0x10],r7
8000c1d0:	2f ed       	sub	sp,-8
8000c1d2:	d8 32       	popm	r0-r7,pc

8000c1d4 <__i2b>:
8000c1d4:	d4 21       	pushm	r4-r7,lr
8000c1d6:	16 97       	mov	r7,r11
8000c1d8:	30 1b       	mov	r11,1
8000c1da:	c4 9e       	rcall	8000be6c <_Balloc>
8000c1dc:	30 19       	mov	r9,1
8000c1de:	99 57       	st.w	r12[0x14],r7
8000c1e0:	99 49       	st.w	r12[0x10],r9
8000c1e2:	d8 22       	popm	r4-r7,pc

8000c1e4 <__multadd>:
8000c1e4:	d4 31       	pushm	r0-r7,lr
8000c1e6:	30 08       	mov	r8,0
8000c1e8:	12 95       	mov	r5,r9
8000c1ea:	16 97       	mov	r7,r11
8000c1ec:	18 96       	mov	r6,r12
8000c1ee:	76 44       	ld.w	r4,r11[0x10]
8000c1f0:	f6 c9 ff ec 	sub	r9,r11,-20
8000c1f4:	72 0b       	ld.w	r11,r9[0x0]
8000c1f6:	f6 0c 16 10 	lsr	r12,r11,0x10
8000c1fa:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c1fe:	f4 0c 02 4c 	mul	r12,r10,r12
8000c202:	f4 0b 03 45 	mac	r5,r10,r11
8000c206:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000c20a:	b1 85       	lsr	r5,0x10
8000c20c:	18 05       	add	r5,r12
8000c20e:	ea 0c 15 10 	lsl	r12,r5,0x10
8000c212:	f8 0b 00 0b 	add	r11,r12,r11
8000c216:	12 ab       	st.w	r9++,r11
8000c218:	2f f8       	sub	r8,-1
8000c21a:	b1 85       	lsr	r5,0x10
8000c21c:	08 38       	cp.w	r8,r4
8000c21e:	ce b5       	brlt	8000c1f4 <__multadd+0x10>
8000c220:	58 05       	cp.w	r5,0
8000c222:	c1 c0       	breq	8000c25a <__multadd+0x76>
8000c224:	6e 28       	ld.w	r8,r7[0x8]
8000c226:	10 34       	cp.w	r4,r8
8000c228:	c1 35       	brlt	8000c24e <__multadd+0x6a>
8000c22a:	6e 1b       	ld.w	r11,r7[0x4]
8000c22c:	0c 9c       	mov	r12,r6
8000c22e:	2f fb       	sub	r11,-1
8000c230:	c1 ee       	rcall	8000be6c <_Balloc>
8000c232:	6e 4a       	ld.w	r10,r7[0x10]
8000c234:	ee cb ff f4 	sub	r11,r7,-12
8000c238:	18 93       	mov	r3,r12
8000c23a:	2f ea       	sub	r10,-2
8000c23c:	2f 4c       	sub	r12,-12
8000c23e:	a3 6a       	lsl	r10,0x2
8000c240:	fe b0 de 71 	rcall	80007f22 <memcpy>
8000c244:	0e 9b       	mov	r11,r7
8000c246:	0c 9c       	mov	r12,r6
8000c248:	fe b0 fd f8 	rcall	8000be38 <_Bfree>
8000c24c:	06 97       	mov	r7,r3
8000c24e:	e8 c8 ff ff 	sub	r8,r4,-1
8000c252:	2f b4       	sub	r4,-5
8000c254:	8f 48       	st.w	r7[0x10],r8
8000c256:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000c25a:	0e 9c       	mov	r12,r7
8000c25c:	d8 32       	popm	r0-r7,pc
8000c25e:	d7 03       	nop

8000c260 <__pow5mult>:
8000c260:	d4 31       	pushm	r0-r7,lr
8000c262:	14 96       	mov	r6,r10
8000c264:	18 97       	mov	r7,r12
8000c266:	16 94       	mov	r4,r11
8000c268:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000c26c:	c0 90       	breq	8000c27e <__pow5mult+0x1e>
8000c26e:	20 18       	sub	r8,1
8000c270:	fe c9 d9 90 	sub	r9,pc,-9840
8000c274:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000c278:	30 09       	mov	r9,0
8000c27a:	cb 5f       	rcall	8000c1e4 <__multadd>
8000c27c:	18 94       	mov	r4,r12
8000c27e:	a3 46       	asr	r6,0x2
8000c280:	c3 40       	breq	8000c2e8 <__pow5mult+0x88>
8000c282:	6e 95       	ld.w	r5,r7[0x24]
8000c284:	58 05       	cp.w	r5,0
8000c286:	c0 91       	brne	8000c298 <__pow5mult+0x38>
8000c288:	31 0c       	mov	r12,16
8000c28a:	fe b0 dc 15 	rcall	80007ab4 <malloc>
8000c28e:	99 35       	st.w	r12[0xc],r5
8000c290:	8f 9c       	st.w	r7[0x24],r12
8000c292:	99 15       	st.w	r12[0x4],r5
8000c294:	99 25       	st.w	r12[0x8],r5
8000c296:	99 05       	st.w	r12[0x0],r5
8000c298:	6e 93       	ld.w	r3,r7[0x24]
8000c29a:	66 25       	ld.w	r5,r3[0x8]
8000c29c:	58 05       	cp.w	r5,0
8000c29e:	c0 c1       	brne	8000c2b6 <__pow5mult+0x56>
8000c2a0:	e0 6b 02 71 	mov	r11,625
8000c2a4:	0e 9c       	mov	r12,r7
8000c2a6:	c9 7f       	rcall	8000c1d4 <__i2b>
8000c2a8:	87 2c       	st.w	r3[0x8],r12
8000c2aa:	30 08       	mov	r8,0
8000c2ac:	18 95       	mov	r5,r12
8000c2ae:	99 08       	st.w	r12[0x0],r8
8000c2b0:	c0 38       	rjmp	8000c2b6 <__pow5mult+0x56>
8000c2b2:	06 9c       	mov	r12,r3
8000c2b4:	18 95       	mov	r5,r12
8000c2b6:	ed b6 00 00 	bld	r6,0x0
8000c2ba:	c0 b1       	brne	8000c2d0 <__pow5mult+0x70>
8000c2bc:	08 9b       	mov	r11,r4
8000c2be:	0a 9a       	mov	r10,r5
8000c2c0:	0e 9c       	mov	r12,r7
8000c2c2:	c0 9f       	rcall	8000c0d4 <__multiply>
8000c2c4:	08 9b       	mov	r11,r4
8000c2c6:	18 93       	mov	r3,r12
8000c2c8:	0e 9c       	mov	r12,r7
8000c2ca:	06 94       	mov	r4,r3
8000c2cc:	fe b0 fd b6 	rcall	8000be38 <_Bfree>
8000c2d0:	a1 56       	asr	r6,0x1
8000c2d2:	c0 b0       	breq	8000c2e8 <__pow5mult+0x88>
8000c2d4:	6a 03       	ld.w	r3,r5[0x0]
8000c2d6:	58 03       	cp.w	r3,0
8000c2d8:	ce d1       	brne	8000c2b2 <__pow5mult+0x52>
8000c2da:	0a 9a       	mov	r10,r5
8000c2dc:	0a 9b       	mov	r11,r5
8000c2de:	0e 9c       	mov	r12,r7
8000c2e0:	cf ae       	rcall	8000c0d4 <__multiply>
8000c2e2:	8b 0c       	st.w	r5[0x0],r12
8000c2e4:	99 03       	st.w	r12[0x0],r3
8000c2e6:	ce 7b       	rjmp	8000c2b4 <__pow5mult+0x54>
8000c2e8:	08 9c       	mov	r12,r4
8000c2ea:	d8 32       	popm	r0-r7,pc

8000c2ec <__isinfd>:
8000c2ec:	14 98       	mov	r8,r10
8000c2ee:	fc 19 7f f0 	movh	r9,0x7ff0
8000c2f2:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000c2f6:	f0 0b 11 00 	rsub	r11,r8,0
8000c2fa:	f7 e8 10 08 	or	r8,r11,r8
8000c2fe:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000c302:	f2 08 01 08 	sub	r8,r9,r8
8000c306:	f0 0c 11 00 	rsub	r12,r8,0
8000c30a:	f9 e8 10 08 	or	r8,r12,r8
8000c30e:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000c312:	2f fc       	sub	r12,-1
8000c314:	5e fc       	retal	r12

8000c316 <__isnand>:
8000c316:	14 98       	mov	r8,r10
8000c318:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000c31c:	f0 0c 11 00 	rsub	r12,r8,0
8000c320:	10 4c       	or	r12,r8
8000c322:	fc 18 7f f0 	movh	r8,0x7ff0
8000c326:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000c32a:	f0 0c 01 0c 	sub	r12,r8,r12
8000c32e:	bf 9c       	lsr	r12,0x1f
8000c330:	5e fc       	retal	r12
8000c332:	d7 03       	nop

8000c334 <__sclose>:
8000c334:	d4 01       	pushm	lr
8000c336:	96 7b       	ld.sh	r11,r11[0xe]
8000c338:	c8 2c       	rcall	8000c43c <_close_r>
8000c33a:	d8 02       	popm	pc

8000c33c <__sseek>:
8000c33c:	d4 21       	pushm	r4-r7,lr
8000c33e:	16 97       	mov	r7,r11
8000c340:	96 7b       	ld.sh	r11,r11[0xe]
8000c342:	c0 3d       	rcall	8000c548 <_lseek_r>
8000c344:	8e 68       	ld.sh	r8,r7[0xc]
8000c346:	10 99       	mov	r9,r8
8000c348:	ad c8       	cbr	r8,0xc
8000c34a:	ad a9       	sbr	r9,0xc
8000c34c:	5b fc       	cp.w	r12,-1
8000c34e:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000c352:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000c356:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000c35a:	d8 22       	popm	r4-r7,pc

8000c35c <__swrite>:
8000c35c:	d4 21       	pushm	r4-r7,lr
8000c35e:	96 68       	ld.sh	r8,r11[0xc]
8000c360:	16 97       	mov	r7,r11
8000c362:	14 95       	mov	r5,r10
8000c364:	12 94       	mov	r4,r9
8000c366:	e2 18 01 00 	andl	r8,0x100,COH
8000c36a:	18 96       	mov	r6,r12
8000c36c:	c0 50       	breq	8000c376 <__swrite+0x1a>
8000c36e:	30 29       	mov	r9,2
8000c370:	30 0a       	mov	r10,0
8000c372:	96 7b       	ld.sh	r11,r11[0xe]
8000c374:	ce ac       	rcall	8000c548 <_lseek_r>
8000c376:	8e 68       	ld.sh	r8,r7[0xc]
8000c378:	ad c8       	cbr	r8,0xc
8000c37a:	08 99       	mov	r9,r4
8000c37c:	0a 9a       	mov	r10,r5
8000c37e:	8e 7b       	ld.sh	r11,r7[0xe]
8000c380:	0c 9c       	mov	r12,r6
8000c382:	ae 68       	st.h	r7[0xc],r8
8000c384:	c1 cc       	rcall	8000c3bc <_write_r>
8000c386:	d8 22       	popm	r4-r7,pc

8000c388 <__sread>:
8000c388:	d4 21       	pushm	r4-r7,lr
8000c38a:	16 97       	mov	r7,r11
8000c38c:	96 7b       	ld.sh	r11,r11[0xe]
8000c38e:	cf 1c       	rcall	8000c570 <_read_r>
8000c390:	c0 65       	brlt	8000c39c <__sread+0x14>
8000c392:	6f 58       	ld.w	r8,r7[0x54]
8000c394:	18 08       	add	r8,r12
8000c396:	ef 48 00 54 	st.w	r7[84],r8
8000c39a:	d8 22       	popm	r4-r7,pc
8000c39c:	8e 68       	ld.sh	r8,r7[0xc]
8000c39e:	ad c8       	cbr	r8,0xc
8000c3a0:	ae 68       	st.h	r7[0xc],r8
8000c3a2:	d8 22       	popm	r4-r7,pc

8000c3a4 <strlen>:
8000c3a4:	30 09       	mov	r9,0
8000c3a6:	18 98       	mov	r8,r12
8000c3a8:	c0 28       	rjmp	8000c3ac <strlen+0x8>
8000c3aa:	2f f8       	sub	r8,-1
8000c3ac:	11 8a       	ld.ub	r10,r8[0x0]
8000c3ae:	f2 0a 18 00 	cp.b	r10,r9
8000c3b2:	cf c1       	brne	8000c3aa <strlen+0x6>
8000c3b4:	f0 0c 01 0c 	sub	r12,r8,r12
8000c3b8:	5e fc       	retal	r12
8000c3ba:	d7 03       	nop

8000c3bc <_write_r>:
8000c3bc:	d4 21       	pushm	r4-r7,lr
8000c3be:	16 98       	mov	r8,r11
8000c3c0:	18 97       	mov	r7,r12
8000c3c2:	10 9c       	mov	r12,r8
8000c3c4:	30 08       	mov	r8,0
8000c3c6:	14 9b       	mov	r11,r10
8000c3c8:	e0 66 54 30 	mov	r6,21552
8000c3cc:	12 9a       	mov	r10,r9
8000c3ce:	8d 08       	st.w	r6[0x0],r8
8000c3d0:	fe b0 d0 a8 	rcall	80006520 <_write>
8000c3d4:	5b fc       	cp.w	r12,-1
8000c3d6:	c0 51       	brne	8000c3e0 <_write_r+0x24>
8000c3d8:	6c 08       	ld.w	r8,r6[0x0]
8000c3da:	58 08       	cp.w	r8,0
8000c3dc:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c3e0:	d8 22       	popm	r4-r7,pc
8000c3e2:	d7 03       	nop

8000c3e4 <_calloc_r>:
8000c3e4:	d4 21       	pushm	r4-r7,lr
8000c3e6:	f4 0b 02 4b 	mul	r11,r10,r11
8000c3ea:	fe b0 db 6d 	rcall	80007ac4 <_malloc_r>
8000c3ee:	18 97       	mov	r7,r12
8000c3f0:	c2 30       	breq	8000c436 <_calloc_r+0x52>
8000c3f2:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000c3f6:	e0 1a ff fc 	andl	r10,0xfffc
8000c3fa:	20 4a       	sub	r10,4
8000c3fc:	e0 4a 00 24 	cp.w	r10,36
8000c400:	e0 8b 00 18 	brhi	8000c430 <_calloc_r+0x4c>
8000c404:	18 98       	mov	r8,r12
8000c406:	59 3a       	cp.w	r10,19
8000c408:	e0 88 00 0f 	brls	8000c426 <_calloc_r+0x42>
8000c40c:	30 09       	mov	r9,0
8000c40e:	10 a9       	st.w	r8++,r9
8000c410:	10 a9       	st.w	r8++,r9
8000c412:	59 ba       	cp.w	r10,27
8000c414:	e0 88 00 09 	brls	8000c426 <_calloc_r+0x42>
8000c418:	10 a9       	st.w	r8++,r9
8000c41a:	10 a9       	st.w	r8++,r9
8000c41c:	e0 4a 00 24 	cp.w	r10,36
8000c420:	c0 31       	brne	8000c426 <_calloc_r+0x42>
8000c422:	10 a9       	st.w	r8++,r9
8000c424:	10 a9       	st.w	r8++,r9
8000c426:	30 09       	mov	r9,0
8000c428:	10 a9       	st.w	r8++,r9
8000c42a:	91 19       	st.w	r8[0x4],r9
8000c42c:	91 09       	st.w	r8[0x0],r9
8000c42e:	c0 48       	rjmp	8000c436 <_calloc_r+0x52>
8000c430:	30 0b       	mov	r11,0
8000c432:	fe b0 de 1c 	rcall	8000806a <memset>
8000c436:	0e 9c       	mov	r12,r7
8000c438:	d8 22       	popm	r4-r7,pc
8000c43a:	d7 03       	nop

8000c43c <_close_r>:
8000c43c:	d4 21       	pushm	r4-r7,lr
8000c43e:	30 08       	mov	r8,0
8000c440:	18 97       	mov	r7,r12
8000c442:	e0 66 54 30 	mov	r6,21552
8000c446:	16 9c       	mov	r12,r11
8000c448:	8d 08       	st.w	r6[0x0],r8
8000c44a:	fe b0 df b5 	rcall	800083b4 <_close>
8000c44e:	5b fc       	cp.w	r12,-1
8000c450:	c0 51       	brne	8000c45a <_close_r+0x1e>
8000c452:	6c 08       	ld.w	r8,r6[0x0]
8000c454:	58 08       	cp.w	r8,0
8000c456:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c45a:	d8 22       	popm	r4-r7,pc

8000c45c <_fclose_r>:
8000c45c:	d4 21       	pushm	r4-r7,lr
8000c45e:	18 96       	mov	r6,r12
8000c460:	16 97       	mov	r7,r11
8000c462:	58 0b       	cp.w	r11,0
8000c464:	c0 31       	brne	8000c46a <_fclose_r+0xe>
8000c466:	16 95       	mov	r5,r11
8000c468:	c5 38       	rjmp	8000c50e <_fclose_r+0xb2>
8000c46a:	fe b0 f8 a9 	rcall	8000b5bc <__sfp_lock_acquire>
8000c46e:	58 06       	cp.w	r6,0
8000c470:	c0 70       	breq	8000c47e <_fclose_r+0x22>
8000c472:	6c 68       	ld.w	r8,r6[0x18]
8000c474:	58 08       	cp.w	r8,0
8000c476:	c0 41       	brne	8000c47e <_fclose_r+0x22>
8000c478:	0c 9c       	mov	r12,r6
8000c47a:	fe b0 f8 f3 	rcall	8000b660 <__sinit>
8000c47e:	fe c8 dc 42 	sub	r8,pc,-9150
8000c482:	10 37       	cp.w	r7,r8
8000c484:	c0 31       	brne	8000c48a <_fclose_r+0x2e>
8000c486:	6c 07       	ld.w	r7,r6[0x0]
8000c488:	c0 c8       	rjmp	8000c4a0 <_fclose_r+0x44>
8000c48a:	fe c8 dc 2e 	sub	r8,pc,-9170
8000c48e:	10 37       	cp.w	r7,r8
8000c490:	c0 31       	brne	8000c496 <_fclose_r+0x3a>
8000c492:	6c 17       	ld.w	r7,r6[0x4]
8000c494:	c0 68       	rjmp	8000c4a0 <_fclose_r+0x44>
8000c496:	fe c8 dc 1a 	sub	r8,pc,-9190
8000c49a:	10 37       	cp.w	r7,r8
8000c49c:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000c4a0:	8e 69       	ld.sh	r9,r7[0xc]
8000c4a2:	30 08       	mov	r8,0
8000c4a4:	f0 09 19 00 	cp.h	r9,r8
8000c4a8:	c0 51       	brne	8000c4b2 <_fclose_r+0x56>
8000c4aa:	fe b0 f8 8a 	rcall	8000b5be <__sfp_lock_release>
8000c4ae:	30 05       	mov	r5,0
8000c4b0:	c2 f8       	rjmp	8000c50e <_fclose_r+0xb2>
8000c4b2:	0e 9b       	mov	r11,r7
8000c4b4:	0c 9c       	mov	r12,r6
8000c4b6:	fe b0 f7 fd 	rcall	8000b4b0 <_fflush_r>
8000c4ba:	6e c8       	ld.w	r8,r7[0x30]
8000c4bc:	18 95       	mov	r5,r12
8000c4be:	58 08       	cp.w	r8,0
8000c4c0:	c0 60       	breq	8000c4cc <_fclose_r+0x70>
8000c4c2:	6e 8b       	ld.w	r11,r7[0x20]
8000c4c4:	0c 9c       	mov	r12,r6
8000c4c6:	5d 18       	icall	r8
8000c4c8:	f9 b5 05 ff 	movlt	r5,-1
8000c4cc:	8e 68       	ld.sh	r8,r7[0xc]
8000c4ce:	ed b8 00 07 	bld	r8,0x7
8000c4d2:	c0 51       	brne	8000c4dc <_fclose_r+0x80>
8000c4d4:	6e 4b       	ld.w	r11,r7[0x10]
8000c4d6:	0c 9c       	mov	r12,r6
8000c4d8:	fe b0 f9 5e 	rcall	8000b794 <_free_r>
8000c4dc:	6e db       	ld.w	r11,r7[0x34]
8000c4de:	58 0b       	cp.w	r11,0
8000c4e0:	c0 a0       	breq	8000c4f4 <_fclose_r+0x98>
8000c4e2:	ee c8 ff bc 	sub	r8,r7,-68
8000c4e6:	10 3b       	cp.w	r11,r8
8000c4e8:	c0 40       	breq	8000c4f0 <_fclose_r+0x94>
8000c4ea:	0c 9c       	mov	r12,r6
8000c4ec:	fe b0 f9 54 	rcall	8000b794 <_free_r>
8000c4f0:	30 08       	mov	r8,0
8000c4f2:	8f d8       	st.w	r7[0x34],r8
8000c4f4:	6f 2b       	ld.w	r11,r7[0x48]
8000c4f6:	58 0b       	cp.w	r11,0
8000c4f8:	c0 70       	breq	8000c506 <_fclose_r+0xaa>
8000c4fa:	0c 9c       	mov	r12,r6
8000c4fc:	fe b0 f9 4c 	rcall	8000b794 <_free_r>
8000c500:	30 08       	mov	r8,0
8000c502:	ef 48 00 48 	st.w	r7[72],r8
8000c506:	30 08       	mov	r8,0
8000c508:	ae 68       	st.h	r7[0xc],r8
8000c50a:	fe b0 f8 5a 	rcall	8000b5be <__sfp_lock_release>
8000c50e:	0a 9c       	mov	r12,r5
8000c510:	d8 22       	popm	r4-r7,pc
8000c512:	d7 03       	nop

8000c514 <fclose>:
8000c514:	d4 01       	pushm	lr
8000c516:	e0 68 0a 48 	mov	r8,2632
8000c51a:	18 9b       	mov	r11,r12
8000c51c:	70 0c       	ld.w	r12,r8[0x0]
8000c51e:	c9 ff       	rcall	8000c45c <_fclose_r>
8000c520:	d8 02       	popm	pc
8000c522:	d7 03       	nop

8000c524 <_fstat_r>:
8000c524:	d4 21       	pushm	r4-r7,lr
8000c526:	16 98       	mov	r8,r11
8000c528:	18 97       	mov	r7,r12
8000c52a:	10 9c       	mov	r12,r8
8000c52c:	30 08       	mov	r8,0
8000c52e:	e0 66 54 30 	mov	r6,21552
8000c532:	14 9b       	mov	r11,r10
8000c534:	8d 08       	st.w	r6[0x0],r8
8000c536:	fe b0 df 67 	rcall	80008404 <_fstat>
8000c53a:	5b fc       	cp.w	r12,-1
8000c53c:	c0 51       	brne	8000c546 <_fstat_r+0x22>
8000c53e:	6c 08       	ld.w	r8,r6[0x0]
8000c540:	58 08       	cp.w	r8,0
8000c542:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c546:	d8 22       	popm	r4-r7,pc

8000c548 <_lseek_r>:
8000c548:	d4 21       	pushm	r4-r7,lr
8000c54a:	16 98       	mov	r8,r11
8000c54c:	18 97       	mov	r7,r12
8000c54e:	10 9c       	mov	r12,r8
8000c550:	30 08       	mov	r8,0
8000c552:	14 9b       	mov	r11,r10
8000c554:	e0 66 54 30 	mov	r6,21552
8000c558:	12 9a       	mov	r10,r9
8000c55a:	8d 08       	st.w	r6[0x0],r8
8000c55c:	fe b0 df 36 	rcall	800083c8 <_lseek>
8000c560:	5b fc       	cp.w	r12,-1
8000c562:	c0 51       	brne	8000c56c <_lseek_r+0x24>
8000c564:	6c 08       	ld.w	r8,r6[0x0]
8000c566:	58 08       	cp.w	r8,0
8000c568:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c56c:	d8 22       	popm	r4-r7,pc
8000c56e:	d7 03       	nop

8000c570 <_read_r>:
8000c570:	d4 21       	pushm	r4-r7,lr
8000c572:	16 98       	mov	r8,r11
8000c574:	18 97       	mov	r7,r12
8000c576:	10 9c       	mov	r12,r8
8000c578:	30 08       	mov	r8,0
8000c57a:	14 9b       	mov	r11,r10
8000c57c:	e0 66 54 30 	mov	r6,21552
8000c580:	12 9a       	mov	r10,r9
8000c582:	8d 08       	st.w	r6[0x0],r8
8000c584:	fe b0 cf ae 	rcall	800064e0 <_read>
8000c588:	5b fc       	cp.w	r12,-1
8000c58a:	c0 51       	brne	8000c594 <_read_r+0x24>
8000c58c:	6c 08       	ld.w	r8,r6[0x0]
8000c58e:	58 08       	cp.w	r8,0
8000c590:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c594:	d8 22       	popm	r4-r7,pc
8000c596:	d7 03       	nop

8000c598 <__avr32_f64_mul>:
8000c598:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000c59c:	e0 80 00 dc 	breq	8000c754 <__avr32_f64_mul_op1_zero>
8000c5a0:	d4 21       	pushm	r4-r7,lr
8000c5a2:	f7 e9 20 0e 	eor	lr,r11,r9
8000c5a6:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c5aa:	30 15       	mov	r5,1
8000c5ac:	c4 30       	breq	8000c632 <__avr32_f64_mul_op1_subnormal>
8000c5ae:	ab 6b       	lsl	r11,0xa
8000c5b0:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000c5b4:	ab 6a       	lsl	r10,0xa
8000c5b6:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000c5ba:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c5be:	c5 c0       	breq	8000c676 <__avr32_f64_mul_op2_subnormal>
8000c5c0:	a1 78       	lsl	r8,0x1
8000c5c2:	5c f9       	rol	r9
8000c5c4:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000c5c8:	e0 47 07 ff 	cp.w	r7,2047
8000c5cc:	c7 70       	breq	8000c6ba <__avr32_f64_mul_op_nan_or_inf>
8000c5ce:	e0 46 07 ff 	cp.w	r6,2047
8000c5d2:	c7 40       	breq	8000c6ba <__avr32_f64_mul_op_nan_or_inf>
8000c5d4:	ee 06 00 0c 	add	r12,r7,r6
8000c5d8:	e0 2c 03 fe 	sub	r12,1022
8000c5dc:	f6 08 06 44 	mulu.d	r4,r11,r8
8000c5e0:	f4 09 07 44 	macu.d	r4,r10,r9
8000c5e4:	f4 08 06 46 	mulu.d	r6,r10,r8
8000c5e8:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000c5ec:	08 07       	add	r7,r4
8000c5ee:	f4 05 00 4a 	adc	r10,r10,r5
8000c5f2:	5c 0b       	acr	r11
8000c5f4:	ed bb 00 14 	bld	r11,0x14
8000c5f8:	c0 50       	breq	8000c602 <__avr32_f64_mul+0x6a>
8000c5fa:	a1 77       	lsl	r7,0x1
8000c5fc:	5c fa       	rol	r10
8000c5fe:	5c fb       	rol	r11
8000c600:	20 1c       	sub	r12,1
8000c602:	58 0c       	cp.w	r12,0
8000c604:	e0 8a 00 6f 	brle	8000c6e2 <__avr32_f64_mul_res_subnormal>
8000c608:	e0 4c 07 ff 	cp.w	r12,2047
8000c60c:	e0 84 00 9c 	brge	8000c744 <__avr32_f64_mul_res_inf>
8000c610:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000c614:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000c618:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000c61c:	ee 17 80 00 	eorh	r7,0x8000
8000c620:	f1 b7 04 20 	satu	r7,0x1
8000c624:	0e 0a       	add	r10,r7
8000c626:	5c 0b       	acr	r11
8000c628:	ed be 00 1f 	bld	lr,0x1f
8000c62c:	ef bb 00 1f 	bst	r11,0x1f
8000c630:	d8 22       	popm	r4-r7,pc

8000c632 <__avr32_f64_mul_op1_subnormal>:
8000c632:	e4 1b 00 0f 	andh	r11,0xf
8000c636:	f4 0c 12 00 	clz	r12,r10
8000c63a:	f6 06 12 00 	clz	r6,r11
8000c63e:	f7 bc 03 e1 	sublo	r12,-31
8000c642:	f8 06 17 30 	movlo	r6,r12
8000c646:	f7 b6 02 01 	subhs	r6,1
8000c64a:	e0 46 00 20 	cp.w	r6,32
8000c64e:	c0 d4       	brge	8000c668 <__avr32_f64_mul_op1_subnormal+0x36>
8000c650:	ec 0c 11 20 	rsub	r12,r6,32
8000c654:	f6 06 09 4b 	lsl	r11,r11,r6
8000c658:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000c65c:	18 4b       	or	r11,r12
8000c65e:	f4 06 09 4a 	lsl	r10,r10,r6
8000c662:	20 b6       	sub	r6,11
8000c664:	0c 17       	sub	r7,r6
8000c666:	ca ab       	rjmp	8000c5ba <__avr32_f64_mul+0x22>
8000c668:	f4 06 09 4b 	lsl	r11,r10,r6
8000c66c:	c6 40       	breq	8000c734 <__avr32_f64_mul_res_zero>
8000c66e:	30 0a       	mov	r10,0
8000c670:	20 b6       	sub	r6,11
8000c672:	0c 17       	sub	r7,r6
8000c674:	ca 3b       	rjmp	8000c5ba <__avr32_f64_mul+0x22>

8000c676 <__avr32_f64_mul_op2_subnormal>:
8000c676:	e4 19 00 0f 	andh	r9,0xf
8000c67a:	f0 0c 12 00 	clz	r12,r8
8000c67e:	f2 05 12 00 	clz	r5,r9
8000c682:	f7 bc 03 ea 	sublo	r12,-22
8000c686:	f8 05 17 30 	movlo	r5,r12
8000c68a:	f7 b5 02 0a 	subhs	r5,10
8000c68e:	e0 45 00 20 	cp.w	r5,32
8000c692:	c0 d4       	brge	8000c6ac <__avr32_f64_mul_op2_subnormal+0x36>
8000c694:	ea 0c 11 20 	rsub	r12,r5,32
8000c698:	f2 05 09 49 	lsl	r9,r9,r5
8000c69c:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000c6a0:	18 49       	or	r9,r12
8000c6a2:	f0 05 09 48 	lsl	r8,r8,r5
8000c6a6:	20 25       	sub	r5,2
8000c6a8:	0a 16       	sub	r6,r5
8000c6aa:	c8 fb       	rjmp	8000c5c8 <__avr32_f64_mul+0x30>
8000c6ac:	f0 05 09 49 	lsl	r9,r8,r5
8000c6b0:	c4 20       	breq	8000c734 <__avr32_f64_mul_res_zero>
8000c6b2:	30 08       	mov	r8,0
8000c6b4:	20 25       	sub	r5,2
8000c6b6:	0a 16       	sub	r6,r5
8000c6b8:	c8 8b       	rjmp	8000c5c8 <__avr32_f64_mul+0x30>

8000c6ba <__avr32_f64_mul_op_nan_or_inf>:
8000c6ba:	e4 19 00 0f 	andh	r9,0xf
8000c6be:	e4 1b 00 0f 	andh	r11,0xf
8000c6c2:	14 4b       	or	r11,r10
8000c6c4:	10 49       	or	r9,r8
8000c6c6:	e0 47 07 ff 	cp.w	r7,2047
8000c6ca:	c0 91       	brne	8000c6dc <__avr32_f64_mul_op1_not_naninf>
8000c6cc:	58 0b       	cp.w	r11,0
8000c6ce:	c3 81       	brne	8000c73e <__avr32_f64_mul_res_nan>
8000c6d0:	e0 46 07 ff 	cp.w	r6,2047
8000c6d4:	c3 81       	brne	8000c744 <__avr32_f64_mul_res_inf>
8000c6d6:	58 09       	cp.w	r9,0
8000c6d8:	c3 60       	breq	8000c744 <__avr32_f64_mul_res_inf>
8000c6da:	c3 28       	rjmp	8000c73e <__avr32_f64_mul_res_nan>

8000c6dc <__avr32_f64_mul_op1_not_naninf>:
8000c6dc:	58 09       	cp.w	r9,0
8000c6de:	c3 30       	breq	8000c744 <__avr32_f64_mul_res_inf>
8000c6e0:	c2 f8       	rjmp	8000c73e <__avr32_f64_mul_res_nan>

8000c6e2 <__avr32_f64_mul_res_subnormal>:
8000c6e2:	5c 3c       	neg	r12
8000c6e4:	2f fc       	sub	r12,-1
8000c6e6:	f1 bc 04 c0 	satu	r12,0x6
8000c6ea:	e0 4c 00 20 	cp.w	r12,32
8000c6ee:	c1 14       	brge	8000c710 <__avr32_f64_mul_res_subnormal+0x2e>
8000c6f0:	f8 08 11 20 	rsub	r8,r12,32
8000c6f4:	0e 46       	or	r6,r7
8000c6f6:	ee 0c 0a 47 	lsr	r7,r7,r12
8000c6fa:	f4 08 09 49 	lsl	r9,r10,r8
8000c6fe:	12 47       	or	r7,r9
8000c700:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c704:	f6 08 09 49 	lsl	r9,r11,r8
8000c708:	12 4a       	or	r10,r9
8000c70a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c70e:	c8 3b       	rjmp	8000c614 <__avr32_f64_mul+0x7c>
8000c710:	f8 08 11 20 	rsub	r8,r12,32
8000c714:	f9 b9 00 00 	moveq	r9,0
8000c718:	c0 30       	breq	8000c71e <__avr32_f64_mul_res_subnormal+0x3c>
8000c71a:	f6 08 09 49 	lsl	r9,r11,r8
8000c71e:	0e 46       	or	r6,r7
8000c720:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000c724:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c728:	f3 ea 10 07 	or	r7,r9,r10
8000c72c:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000c730:	30 0b       	mov	r11,0
8000c732:	c7 1b       	rjmp	8000c614 <__avr32_f64_mul+0x7c>

8000c734 <__avr32_f64_mul_res_zero>:
8000c734:	1c 9b       	mov	r11,lr
8000c736:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c73a:	30 0a       	mov	r10,0
8000c73c:	d8 22       	popm	r4-r7,pc

8000c73e <__avr32_f64_mul_res_nan>:
8000c73e:	3f fb       	mov	r11,-1
8000c740:	3f fa       	mov	r10,-1
8000c742:	d8 22       	popm	r4-r7,pc

8000c744 <__avr32_f64_mul_res_inf>:
8000c744:	f0 6b 00 00 	mov	r11,-1048576
8000c748:	ed be 00 1f 	bld	lr,0x1f
8000c74c:	ef bb 00 1f 	bst	r11,0x1f
8000c750:	30 0a       	mov	r10,0
8000c752:	d8 22       	popm	r4-r7,pc

8000c754 <__avr32_f64_mul_op1_zero>:
8000c754:	f7 e9 20 0b 	eor	r11,r11,r9
8000c758:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c75c:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000c760:	e0 4c 07 ff 	cp.w	r12,2047
8000c764:	5e 1c       	retne	r12
8000c766:	3f fa       	mov	r10,-1
8000c768:	3f fb       	mov	r11,-1
8000c76a:	5e fc       	retal	r12

8000c76c <__avr32_f64_sub_from_add>:
8000c76c:	ee 19 80 00 	eorh	r9,0x8000

8000c770 <__avr32_f64_sub>:
8000c770:	f7 e9 20 0c 	eor	r12,r11,r9
8000c774:	e0 86 00 ca 	brmi	8000c908 <__avr32_f64_add_from_sub>
8000c778:	eb cd 40 e0 	pushm	r5-r7,lr
8000c77c:	16 9c       	mov	r12,r11
8000c77e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c782:	bf db       	cbr	r11,0x1f
8000c784:	bf d9       	cbr	r9,0x1f
8000c786:	10 3a       	cp.w	r10,r8
8000c788:	f2 0b 13 00 	cpc	r11,r9
8000c78c:	c0 92       	brcc	8000c79e <__avr32_f64_sub+0x2e>
8000c78e:	16 97       	mov	r7,r11
8000c790:	12 9b       	mov	r11,r9
8000c792:	0e 99       	mov	r9,r7
8000c794:	14 97       	mov	r7,r10
8000c796:	10 9a       	mov	r10,r8
8000c798:	0e 98       	mov	r8,r7
8000c79a:	ee 1c 80 00 	eorh	r12,0x8000
8000c79e:	f6 07 16 14 	lsr	r7,r11,0x14
8000c7a2:	ab 7b       	lsl	r11,0xb
8000c7a4:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c7a8:	ab 7a       	lsl	r10,0xb
8000c7aa:	bf bb       	sbr	r11,0x1f
8000c7ac:	f2 06 16 14 	lsr	r6,r9,0x14
8000c7b0:	c4 40       	breq	8000c838 <__avr32_f64_sub_opL_subnormal>
8000c7b2:	ab 79       	lsl	r9,0xb
8000c7b4:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c7b8:	ab 78       	lsl	r8,0xb
8000c7ba:	bf b9       	sbr	r9,0x1f

8000c7bc <__avr32_f64_sub_opL_subnormal_done>:
8000c7bc:	e0 47 07 ff 	cp.w	r7,2047
8000c7c0:	c4 f0       	breq	8000c85e <__avr32_f64_sub_opH_nan_or_inf>
8000c7c2:	0e 26       	rsub	r6,r7
8000c7c4:	c1 20       	breq	8000c7e8 <__avr32_f64_sub_shift_done>
8000c7c6:	ec 05 11 20 	rsub	r5,r6,32
8000c7ca:	e0 46 00 20 	cp.w	r6,32
8000c7ce:	c7 c2       	brcc	8000c8c6 <__avr32_f64_sub_longshift>
8000c7d0:	f0 05 09 4e 	lsl	lr,r8,r5
8000c7d4:	f2 05 09 45 	lsl	r5,r9,r5
8000c7d8:	f0 06 0a 48 	lsr	r8,r8,r6
8000c7dc:	f2 06 0a 49 	lsr	r9,r9,r6
8000c7e0:	0a 48       	or	r8,r5
8000c7e2:	58 0e       	cp.w	lr,0
8000c7e4:	5f 1e       	srne	lr
8000c7e6:	1c 48       	or	r8,lr

8000c7e8 <__avr32_f64_sub_shift_done>:
8000c7e8:	10 1a       	sub	r10,r8
8000c7ea:	f6 09 01 4b 	sbc	r11,r11,r9
8000c7ee:	f6 06 12 00 	clz	r6,r11
8000c7f2:	c0 e0       	breq	8000c80e <__avr32_f64_sub_longnormalize_done>
8000c7f4:	c7 83       	brcs	8000c8e4 <__avr32_f64_sub_longnormalize>
8000c7f6:	ec 0e 11 20 	rsub	lr,r6,32
8000c7fa:	f6 06 09 4b 	lsl	r11,r11,r6
8000c7fe:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c802:	1c 4b       	or	r11,lr
8000c804:	f4 06 09 4a 	lsl	r10,r10,r6
8000c808:	0c 17       	sub	r7,r6
8000c80a:	e0 8a 00 39 	brle	8000c87c <__avr32_f64_sub_subnormal_result>

8000c80e <__avr32_f64_sub_longnormalize_done>:
8000c80e:	f4 09 15 15 	lsl	r9,r10,0x15
8000c812:	ab 9a       	lsr	r10,0xb
8000c814:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c818:	ab 9b       	lsr	r11,0xb
8000c81a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c81e:	18 4b       	or	r11,r12

8000c820 <__avr32_f64_sub_round>:
8000c820:	fc 17 80 00 	movh	r7,0x8000
8000c824:	ed ba 00 00 	bld	r10,0x0
8000c828:	f7 b7 01 ff 	subne	r7,-1
8000c82c:	0e 39       	cp.w	r9,r7
8000c82e:	5f 29       	srhs	r9
8000c830:	12 0a       	add	r10,r9
8000c832:	5c 0b       	acr	r11
8000c834:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c838 <__avr32_f64_sub_opL_subnormal>:
8000c838:	ab 79       	lsl	r9,0xb
8000c83a:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c83e:	ab 78       	lsl	r8,0xb
8000c840:	f3 e8 10 0e 	or	lr,r9,r8
8000c844:	f9 b6 01 01 	movne	r6,1
8000c848:	ee 0e 11 00 	rsub	lr,r7,0
8000c84c:	f9 b7 00 01 	moveq	r7,1
8000c850:	ef bb 00 1f 	bst	r11,0x1f
8000c854:	f7 ea 10 0e 	or	lr,r11,r10
8000c858:	f9 b7 00 00 	moveq	r7,0
8000c85c:	cb 0b       	rjmp	8000c7bc <__avr32_f64_sub_opL_subnormal_done>

8000c85e <__avr32_f64_sub_opH_nan_or_inf>:
8000c85e:	bf db       	cbr	r11,0x1f
8000c860:	f7 ea 10 0e 	or	lr,r11,r10
8000c864:	c0 81       	brne	8000c874 <__avr32_f64_sub_return_nan>
8000c866:	e0 46 07 ff 	cp.w	r6,2047
8000c86a:	c0 50       	breq	8000c874 <__avr32_f64_sub_return_nan>
8000c86c:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000c870:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c874 <__avr32_f64_sub_return_nan>:
8000c874:	3f fa       	mov	r10,-1
8000c876:	3f fb       	mov	r11,-1
8000c878:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c87c <__avr32_f64_sub_subnormal_result>:
8000c87c:	5c 37       	neg	r7
8000c87e:	2f f7       	sub	r7,-1
8000c880:	f1 b7 04 c0 	satu	r7,0x6
8000c884:	e0 47 00 20 	cp.w	r7,32
8000c888:	c1 14       	brge	8000c8aa <__avr32_f64_sub_subnormal_result+0x2e>
8000c88a:	ee 08 11 20 	rsub	r8,r7,32
8000c88e:	f4 08 09 49 	lsl	r9,r10,r8
8000c892:	5f 16       	srne	r6
8000c894:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c898:	0c 4a       	or	r10,r6
8000c89a:	f6 08 09 49 	lsl	r9,r11,r8
8000c89e:	f5 e9 10 0a 	or	r10,r10,r9
8000c8a2:	f4 07 0a 4b 	lsr	r11,r10,r7
8000c8a6:	30 07       	mov	r7,0
8000c8a8:	cb 3b       	rjmp	8000c80e <__avr32_f64_sub_longnormalize_done>
8000c8aa:	ee 08 11 40 	rsub	r8,r7,64
8000c8ae:	f6 08 09 49 	lsl	r9,r11,r8
8000c8b2:	14 49       	or	r9,r10
8000c8b4:	5f 16       	srne	r6
8000c8b6:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c8ba:	0c 4a       	or	r10,r6
8000c8bc:	30 0b       	mov	r11,0
8000c8be:	30 07       	mov	r7,0
8000c8c0:	ca 7b       	rjmp	8000c80e <__avr32_f64_sub_longnormalize_done>
8000c8c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c8c6 <__avr32_f64_sub_longshift>:
8000c8c6:	f1 b6 04 c0 	satu	r6,0x6
8000c8ca:	f0 0e 17 00 	moveq	lr,r8
8000c8ce:	c0 40       	breq	8000c8d6 <__avr32_f64_sub_longshift+0x10>
8000c8d0:	f2 05 09 4e 	lsl	lr,r9,r5
8000c8d4:	10 4e       	or	lr,r8
8000c8d6:	f2 06 0a 48 	lsr	r8,r9,r6
8000c8da:	30 09       	mov	r9,0
8000c8dc:	58 0e       	cp.w	lr,0
8000c8de:	5f 1e       	srne	lr
8000c8e0:	1c 48       	or	r8,lr
8000c8e2:	c8 3b       	rjmp	8000c7e8 <__avr32_f64_sub_shift_done>

8000c8e4 <__avr32_f64_sub_longnormalize>:
8000c8e4:	f4 06 12 00 	clz	r6,r10
8000c8e8:	f9 b7 03 00 	movlo	r7,0
8000c8ec:	f9 b6 03 00 	movlo	r6,0
8000c8f0:	f9 bc 03 00 	movlo	r12,0
8000c8f4:	f7 b6 02 e0 	subhs	r6,-32
8000c8f8:	f4 06 09 4b 	lsl	r11,r10,r6
8000c8fc:	30 0a       	mov	r10,0
8000c8fe:	0c 17       	sub	r7,r6
8000c900:	fe 9a ff be 	brle	8000c87c <__avr32_f64_sub_subnormal_result>
8000c904:	c8 5b       	rjmp	8000c80e <__avr32_f64_sub_longnormalize_done>
8000c906:	d7 03       	nop

8000c908 <__avr32_f64_add_from_sub>:
8000c908:	ee 19 80 00 	eorh	r9,0x8000

8000c90c <__avr32_f64_add>:
8000c90c:	f7 e9 20 0c 	eor	r12,r11,r9
8000c910:	fe 96 ff 2e 	brmi	8000c76c <__avr32_f64_sub_from_add>
8000c914:	eb cd 40 e0 	pushm	r5-r7,lr
8000c918:	16 9c       	mov	r12,r11
8000c91a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c91e:	bf db       	cbr	r11,0x1f
8000c920:	bf d9       	cbr	r9,0x1f
8000c922:	12 3b       	cp.w	r11,r9
8000c924:	c0 72       	brcc	8000c932 <__avr32_f64_add+0x26>
8000c926:	16 97       	mov	r7,r11
8000c928:	12 9b       	mov	r11,r9
8000c92a:	0e 99       	mov	r9,r7
8000c92c:	14 97       	mov	r7,r10
8000c92e:	10 9a       	mov	r10,r8
8000c930:	0e 98       	mov	r8,r7
8000c932:	30 0e       	mov	lr,0
8000c934:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c938:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000c93c:	b5 ab       	sbr	r11,0x14
8000c93e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c942:	c6 20       	breq	8000ca06 <__avr32_f64_add_op2_subnormal>
8000c944:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000c948:	b5 a9       	sbr	r9,0x14
8000c94a:	e0 47 07 ff 	cp.w	r7,2047
8000c94e:	c2 80       	breq	8000c99e <__avr32_f64_add_opH_nan_or_inf>
8000c950:	0e 26       	rsub	r6,r7
8000c952:	c1 20       	breq	8000c976 <__avr32_f64_add_shift_done>
8000c954:	e0 46 00 36 	cp.w	r6,54
8000c958:	c1 52       	brcc	8000c982 <__avr32_f64_add_res_of_done>
8000c95a:	ec 05 11 20 	rsub	r5,r6,32
8000c95e:	e0 46 00 20 	cp.w	r6,32
8000c962:	c3 52       	brcc	8000c9cc <__avr32_f64_add_longshift>
8000c964:	f0 05 09 4e 	lsl	lr,r8,r5
8000c968:	f2 05 09 45 	lsl	r5,r9,r5
8000c96c:	f0 06 0a 48 	lsr	r8,r8,r6
8000c970:	f2 06 0a 49 	lsr	r9,r9,r6
8000c974:	0a 48       	or	r8,r5

8000c976 <__avr32_f64_add_shift_done>:
8000c976:	10 0a       	add	r10,r8
8000c978:	f6 09 00 4b 	adc	r11,r11,r9
8000c97c:	ed bb 00 15 	bld	r11,0x15
8000c980:	c3 40       	breq	8000c9e8 <__avr32_f64_add_res_of>

8000c982 <__avr32_f64_add_res_of_done>:
8000c982:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c986:	18 4b       	or	r11,r12

8000c988 <__avr32_f64_add_round>:
8000c988:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c98c:	18 4e       	or	lr,r12
8000c98e:	ee 1e 80 00 	eorh	lr,0x8000
8000c992:	f1 be 04 20 	satu	lr,0x1
8000c996:	1c 0a       	add	r10,lr
8000c998:	5c 0b       	acr	r11
8000c99a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c99e <__avr32_f64_add_opH_nan_or_inf>:
8000c99e:	b5 cb       	cbr	r11,0x14
8000c9a0:	f7 ea 10 0e 	or	lr,r11,r10
8000c9a4:	c1 01       	brne	8000c9c4 <__avr32_f64_add_return_nan>
8000c9a6:	e0 46 07 ff 	cp.w	r6,2047
8000c9aa:	c0 30       	breq	8000c9b0 <__avr32_f64_add_opL_nan_or_inf>
8000c9ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c9b0 <__avr32_f64_add_opL_nan_or_inf>:
8000c9b0:	b5 c9       	cbr	r9,0x14
8000c9b2:	f3 e8 10 0e 	or	lr,r9,r8
8000c9b6:	c0 71       	brne	8000c9c4 <__avr32_f64_add_return_nan>
8000c9b8:	30 0a       	mov	r10,0
8000c9ba:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c9be:	18 4b       	or	r11,r12
8000c9c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c9c4 <__avr32_f64_add_return_nan>:
8000c9c4:	3f fa       	mov	r10,-1
8000c9c6:	3f fb       	mov	r11,-1
8000c9c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c9cc <__avr32_f64_add_longshift>:
8000c9cc:	f1 b6 04 c0 	satu	r6,0x6
8000c9d0:	f0 0e 17 00 	moveq	lr,r8
8000c9d4:	c0 60       	breq	8000c9e0 <__avr32_f64_add_longshift+0x14>
8000c9d6:	f2 05 09 4e 	lsl	lr,r9,r5
8000c9da:	58 08       	cp.w	r8,0
8000c9dc:	5f 18       	srne	r8
8000c9de:	10 4e       	or	lr,r8
8000c9e0:	f2 06 0a 48 	lsr	r8,r9,r6
8000c9e4:	30 09       	mov	r9,0
8000c9e6:	cc 8b       	rjmp	8000c976 <__avr32_f64_add_shift_done>

8000c9e8 <__avr32_f64_add_res_of>:
8000c9e8:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c9ec:	a1 9b       	lsr	r11,0x1
8000c9ee:	5d 0a       	ror	r10
8000c9f0:	5d 0e       	ror	lr
8000c9f2:	2f f7       	sub	r7,-1
8000c9f4:	e0 47 07 ff 	cp.w	r7,2047
8000c9f8:	f9 ba 00 00 	moveq	r10,0
8000c9fc:	f9 bb 00 00 	moveq	r11,0
8000ca00:	f9 be 00 00 	moveq	lr,0
8000ca04:	cb fb       	rjmp	8000c982 <__avr32_f64_add_res_of_done>

8000ca06 <__avr32_f64_add_op2_subnormal>:
8000ca06:	30 16       	mov	r6,1
8000ca08:	58 07       	cp.w	r7,0
8000ca0a:	ca 01       	brne	8000c94a <__avr32_f64_add+0x3e>
8000ca0c:	b5 cb       	cbr	r11,0x14
8000ca0e:	10 0a       	add	r10,r8
8000ca10:	f6 09 00 4b 	adc	r11,r11,r9
8000ca14:	18 4b       	or	r11,r12
8000ca16:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000ca1a:	d7 03       	nop

8000ca1c <__avr32_f64_to_u32>:
8000ca1c:	58 0b       	cp.w	r11,0
8000ca1e:	5e 6d       	retmi	0

8000ca20 <__avr32_f64_to_s32>:
8000ca20:	f6 0c 15 01 	lsl	r12,r11,0x1
8000ca24:	b5 9c       	lsr	r12,0x15
8000ca26:	e0 2c 03 ff 	sub	r12,1023
8000ca2a:	5e 3d       	retlo	0
8000ca2c:	f8 0c 11 1f 	rsub	r12,r12,31
8000ca30:	16 99       	mov	r9,r11
8000ca32:	ab 7b       	lsl	r11,0xb
8000ca34:	bf bb       	sbr	r11,0x1f
8000ca36:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000ca3a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000ca3e:	a1 79       	lsl	r9,0x1
8000ca40:	5e 2b       	reths	r11
8000ca42:	5c 3b       	neg	r11
8000ca44:	5e fb       	retal	r11

8000ca46 <__avr32_u32_to_f64>:
8000ca46:	f8 cb 00 00 	sub	r11,r12,0
8000ca4a:	30 0c       	mov	r12,0
8000ca4c:	c0 38       	rjmp	8000ca52 <__avr32_s32_to_f64+0x4>

8000ca4e <__avr32_s32_to_f64>:
8000ca4e:	18 9b       	mov	r11,r12
8000ca50:	5c 4b       	abs	r11
8000ca52:	30 0a       	mov	r10,0
8000ca54:	5e 0b       	reteq	r11
8000ca56:	d4 01       	pushm	lr
8000ca58:	e0 69 04 1e 	mov	r9,1054
8000ca5c:	f6 08 12 00 	clz	r8,r11
8000ca60:	c1 70       	breq	8000ca8e <__avr32_s32_to_f64+0x40>
8000ca62:	c0 c3       	brcs	8000ca7a <__avr32_s32_to_f64+0x2c>
8000ca64:	f0 0e 11 20 	rsub	lr,r8,32
8000ca68:	f6 08 09 4b 	lsl	r11,r11,r8
8000ca6c:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000ca70:	1c 4b       	or	r11,lr
8000ca72:	f4 08 09 4a 	lsl	r10,r10,r8
8000ca76:	10 19       	sub	r9,r8
8000ca78:	c0 b8       	rjmp	8000ca8e <__avr32_s32_to_f64+0x40>
8000ca7a:	f4 08 12 00 	clz	r8,r10
8000ca7e:	f9 b8 03 00 	movlo	r8,0
8000ca82:	f7 b8 02 e0 	subhs	r8,-32
8000ca86:	f4 08 09 4b 	lsl	r11,r10,r8
8000ca8a:	30 0a       	mov	r10,0
8000ca8c:	10 19       	sub	r9,r8
8000ca8e:	58 09       	cp.w	r9,0
8000ca90:	e0 89 00 30 	brgt	8000caf0 <__avr32_s32_to_f64+0xa2>
8000ca94:	5c 39       	neg	r9
8000ca96:	2f f9       	sub	r9,-1
8000ca98:	e0 49 00 36 	cp.w	r9,54
8000ca9c:	c0 43       	brcs	8000caa4 <__avr32_s32_to_f64+0x56>
8000ca9e:	30 0b       	mov	r11,0
8000caa0:	30 0a       	mov	r10,0
8000caa2:	c2 68       	rjmp	8000caee <__avr32_s32_to_f64+0xa0>
8000caa4:	2f 69       	sub	r9,-10
8000caa6:	f2 08 11 20 	rsub	r8,r9,32
8000caaa:	e0 49 00 20 	cp.w	r9,32
8000caae:	c0 b2       	brcc	8000cac4 <__avr32_s32_to_f64+0x76>
8000cab0:	f4 08 09 4e 	lsl	lr,r10,r8
8000cab4:	f6 08 09 48 	lsl	r8,r11,r8
8000cab8:	f4 09 0a 4a 	lsr	r10,r10,r9
8000cabc:	f6 09 0a 4b 	lsr	r11,r11,r9
8000cac0:	10 4b       	or	r11,r8
8000cac2:	c0 88       	rjmp	8000cad2 <__avr32_s32_to_f64+0x84>
8000cac4:	f6 08 09 4e 	lsl	lr,r11,r8
8000cac8:	14 4e       	or	lr,r10
8000caca:	16 9a       	mov	r10,r11
8000cacc:	30 0b       	mov	r11,0
8000cace:	f4 09 0a 4a 	lsr	r10,r10,r9
8000cad2:	ed ba 00 00 	bld	r10,0x0
8000cad6:	c0 92       	brcc	8000cae8 <__avr32_s32_to_f64+0x9a>
8000cad8:	1c 7e       	tst	lr,lr
8000cada:	c0 41       	brne	8000cae2 <__avr32_s32_to_f64+0x94>
8000cadc:	ed ba 00 01 	bld	r10,0x1
8000cae0:	c0 42       	brcc	8000cae8 <__avr32_s32_to_f64+0x9a>
8000cae2:	2f fa       	sub	r10,-1
8000cae4:	f7 bb 02 ff 	subhs	r11,-1
8000cae8:	5c fc       	rol	r12
8000caea:	5d 0b       	ror	r11
8000caec:	5d 0a       	ror	r10
8000caee:	d8 02       	popm	pc
8000caf0:	e0 68 03 ff 	mov	r8,1023
8000caf4:	ed ba 00 0b 	bld	r10,0xb
8000caf8:	f7 b8 00 ff 	subeq	r8,-1
8000cafc:	10 0a       	add	r10,r8
8000cafe:	5c 0b       	acr	r11
8000cb00:	f7 b9 03 fe 	sublo	r9,-2
8000cb04:	e0 49 07 ff 	cp.w	r9,2047
8000cb08:	c0 55       	brlt	8000cb12 <__avr32_s32_to_f64+0xc4>
8000cb0a:	30 0a       	mov	r10,0
8000cb0c:	fc 1b ff e0 	movh	r11,0xffe0
8000cb10:	c0 c8       	rjmp	8000cb28 <__floatsidf_return_op1>
8000cb12:	ed bb 00 1f 	bld	r11,0x1f
8000cb16:	f7 b9 01 01 	subne	r9,1
8000cb1a:	ab 9a       	lsr	r10,0xb
8000cb1c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000cb20:	a1 7b       	lsl	r11,0x1
8000cb22:	ab 9b       	lsr	r11,0xb
8000cb24:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000cb28 <__floatsidf_return_op1>:
8000cb28:	a1 7c       	lsl	r12,0x1
8000cb2a:	5d 0b       	ror	r11
8000cb2c:	d8 02       	popm	pc

8000cb2e <__avr32_f64_cmp_eq>:
8000cb2e:	10 3a       	cp.w	r10,r8
8000cb30:	f2 0b 13 00 	cpc	r11,r9
8000cb34:	c0 80       	breq	8000cb44 <__avr32_f64_cmp_eq+0x16>
8000cb36:	a1 7b       	lsl	r11,0x1
8000cb38:	a1 79       	lsl	r9,0x1
8000cb3a:	14 4b       	or	r11,r10
8000cb3c:	12 4b       	or	r11,r9
8000cb3e:	10 4b       	or	r11,r8
8000cb40:	5e 0f       	reteq	1
8000cb42:	5e fd       	retal	0
8000cb44:	a1 7b       	lsl	r11,0x1
8000cb46:	fc 1c ff e0 	movh	r12,0xffe0
8000cb4a:	58 0a       	cp.w	r10,0
8000cb4c:	f8 0b 13 00 	cpc	r11,r12
8000cb50:	5e 8f       	retls	1
8000cb52:	5e fd       	retal	0

8000cb54 <__avr32_f64_cmp_ge>:
8000cb54:	1a de       	st.w	--sp,lr
8000cb56:	1a d7       	st.w	--sp,r7
8000cb58:	a1 7b       	lsl	r11,0x1
8000cb5a:	5f 3c       	srlo	r12
8000cb5c:	a1 79       	lsl	r9,0x1
8000cb5e:	5f 37       	srlo	r7
8000cb60:	5c fc       	rol	r12
8000cb62:	fc 1e ff e0 	movh	lr,0xffe0
8000cb66:	58 0a       	cp.w	r10,0
8000cb68:	fc 0b 13 00 	cpc	r11,lr
8000cb6c:	e0 8b 00 1d 	brhi	8000cba6 <__avr32_f64_cmp_ge+0x52>
8000cb70:	58 08       	cp.w	r8,0
8000cb72:	fc 09 13 00 	cpc	r9,lr
8000cb76:	e0 8b 00 18 	brhi	8000cba6 <__avr32_f64_cmp_ge+0x52>
8000cb7a:	58 0b       	cp.w	r11,0
8000cb7c:	f5 ba 00 00 	subfeq	r10,0
8000cb80:	c1 50       	breq	8000cbaa <__avr32_f64_cmp_ge+0x56>
8000cb82:	1b 07       	ld.w	r7,sp++
8000cb84:	1b 0e       	ld.w	lr,sp++
8000cb86:	58 3c       	cp.w	r12,3
8000cb88:	c0 a0       	breq	8000cb9c <__avr32_f64_cmp_ge+0x48>
8000cb8a:	58 1c       	cp.w	r12,1
8000cb8c:	c0 33       	brcs	8000cb92 <__avr32_f64_cmp_ge+0x3e>
8000cb8e:	5e 0f       	reteq	1
8000cb90:	5e 1d       	retne	0
8000cb92:	10 3a       	cp.w	r10,r8
8000cb94:	f2 0b 13 00 	cpc	r11,r9
8000cb98:	5e 2f       	reths	1
8000cb9a:	5e 3d       	retlo	0
8000cb9c:	14 38       	cp.w	r8,r10
8000cb9e:	f6 09 13 00 	cpc	r9,r11
8000cba2:	5e 2f       	reths	1
8000cba4:	5e 3d       	retlo	0
8000cba6:	1b 07       	ld.w	r7,sp++
8000cba8:	d8 0a       	popm	pc,r12=0
8000cbaa:	58 17       	cp.w	r7,1
8000cbac:	5f 0c       	sreq	r12
8000cbae:	58 09       	cp.w	r9,0
8000cbb0:	f5 b8 00 00 	subfeq	r8,0
8000cbb4:	1b 07       	ld.w	r7,sp++
8000cbb6:	1b 0e       	ld.w	lr,sp++
8000cbb8:	5e 0f       	reteq	1
8000cbba:	5e fc       	retal	r12

8000cbbc <__avr32_f64_cmp_lt>:
8000cbbc:	1a de       	st.w	--sp,lr
8000cbbe:	1a d7       	st.w	--sp,r7
8000cbc0:	a1 7b       	lsl	r11,0x1
8000cbc2:	5f 3c       	srlo	r12
8000cbc4:	a1 79       	lsl	r9,0x1
8000cbc6:	5f 37       	srlo	r7
8000cbc8:	5c fc       	rol	r12
8000cbca:	fc 1e ff e0 	movh	lr,0xffe0
8000cbce:	58 0a       	cp.w	r10,0
8000cbd0:	fc 0b 13 00 	cpc	r11,lr
8000cbd4:	e0 8b 00 1d 	brhi	8000cc0e <__avr32_f64_cmp_lt+0x52>
8000cbd8:	58 08       	cp.w	r8,0
8000cbda:	fc 09 13 00 	cpc	r9,lr
8000cbde:	e0 8b 00 18 	brhi	8000cc0e <__avr32_f64_cmp_lt+0x52>
8000cbe2:	58 0b       	cp.w	r11,0
8000cbe4:	f5 ba 00 00 	subfeq	r10,0
8000cbe8:	c1 50       	breq	8000cc12 <__avr32_f64_cmp_lt+0x56>
8000cbea:	1b 07       	ld.w	r7,sp++
8000cbec:	1b 0e       	ld.w	lr,sp++
8000cbee:	58 3c       	cp.w	r12,3
8000cbf0:	c0 a0       	breq	8000cc04 <__avr32_f64_cmp_lt+0x48>
8000cbf2:	58 1c       	cp.w	r12,1
8000cbf4:	c0 33       	brcs	8000cbfa <__avr32_f64_cmp_lt+0x3e>
8000cbf6:	5e 0d       	reteq	0
8000cbf8:	5e 1f       	retne	1
8000cbfa:	10 3a       	cp.w	r10,r8
8000cbfc:	f2 0b 13 00 	cpc	r11,r9
8000cc00:	5e 2d       	reths	0
8000cc02:	5e 3f       	retlo	1
8000cc04:	14 38       	cp.w	r8,r10
8000cc06:	f6 09 13 00 	cpc	r9,r11
8000cc0a:	5e 2d       	reths	0
8000cc0c:	5e 3f       	retlo	1
8000cc0e:	1b 07       	ld.w	r7,sp++
8000cc10:	d8 0a       	popm	pc,r12=0
8000cc12:	58 17       	cp.w	r7,1
8000cc14:	5f 1c       	srne	r12
8000cc16:	58 09       	cp.w	r9,0
8000cc18:	f5 b8 00 00 	subfeq	r8,0
8000cc1c:	1b 07       	ld.w	r7,sp++
8000cc1e:	1b 0e       	ld.w	lr,sp++
8000cc20:	5e 0d       	reteq	0
8000cc22:	5e fc       	retal	r12

8000cc24 <__avr32_f64_div>:
8000cc24:	eb cd 40 ff 	pushm	r0-r7,lr
8000cc28:	f7 e9 20 0e 	eor	lr,r11,r9
8000cc2c:	f6 07 16 14 	lsr	r7,r11,0x14
8000cc30:	a9 7b       	lsl	r11,0x9
8000cc32:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000cc36:	a9 7a       	lsl	r10,0x9
8000cc38:	bd bb       	sbr	r11,0x1d
8000cc3a:	e4 1b 3f ff 	andh	r11,0x3fff
8000cc3e:	ab d7       	cbr	r7,0xb
8000cc40:	e0 80 00 cc 	breq	8000cdd8 <__avr32_f64_div_round_subnormal+0x54>
8000cc44:	e0 47 07 ff 	cp.w	r7,2047
8000cc48:	e0 84 00 b5 	brge	8000cdb2 <__avr32_f64_div_round_subnormal+0x2e>
8000cc4c:	f2 06 16 14 	lsr	r6,r9,0x14
8000cc50:	a9 79       	lsl	r9,0x9
8000cc52:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000cc56:	a9 78       	lsl	r8,0x9
8000cc58:	bd b9       	sbr	r9,0x1d
8000cc5a:	e4 19 3f ff 	andh	r9,0x3fff
8000cc5e:	ab d6       	cbr	r6,0xb
8000cc60:	e0 80 00 e2 	breq	8000ce24 <__avr32_f64_div_round_subnormal+0xa0>
8000cc64:	e0 46 07 ff 	cp.w	r6,2047
8000cc68:	e0 84 00 b2 	brge	8000cdcc <__avr32_f64_div_round_subnormal+0x48>
8000cc6c:	0c 17       	sub	r7,r6
8000cc6e:	fe 37 fc 01 	sub	r7,-1023
8000cc72:	fc 1c 80 00 	movh	r12,0x8000
8000cc76:	f8 03 16 01 	lsr	r3,r12,0x1
8000cc7a:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000cc7e:	5c d4       	com	r4
8000cc80:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000cc84:	e6 09 06 44 	mulu.d	r4,r3,r9
8000cc88:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000cc8c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000cc90:	ea 03 15 02 	lsl	r3,r5,0x2
8000cc94:	e6 09 06 44 	mulu.d	r4,r3,r9
8000cc98:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000cc9c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000cca0:	ea 03 15 02 	lsl	r3,r5,0x2
8000cca4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000cca8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000ccac:	e6 05 06 44 	mulu.d	r4,r3,r5
8000ccb0:	ea 03 15 02 	lsl	r3,r5,0x2
8000ccb4:	e6 08 06 40 	mulu.d	r0,r3,r8
8000ccb8:	e4 09 07 40 	macu.d	r0,r2,r9
8000ccbc:	e6 09 06 44 	mulu.d	r4,r3,r9
8000ccc0:	02 04       	add	r4,r1
8000ccc2:	5c 05       	acr	r5
8000ccc4:	a3 65       	lsl	r5,0x2
8000ccc6:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000ccca:	a3 64       	lsl	r4,0x2
8000cccc:	5c 34       	neg	r4
8000ccce:	f8 05 01 45 	sbc	r5,r12,r5
8000ccd2:	e6 04 06 40 	mulu.d	r0,r3,r4
8000ccd6:	e4 05 07 40 	macu.d	r0,r2,r5
8000ccda:	e6 05 06 44 	mulu.d	r4,r3,r5
8000ccde:	02 04       	add	r4,r1
8000cce0:	5c 05       	acr	r5
8000cce2:	ea 03 15 02 	lsl	r3,r5,0x2
8000cce6:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000ccea:	e8 02 15 02 	lsl	r2,r4,0x2
8000ccee:	e6 08 06 40 	mulu.d	r0,r3,r8
8000ccf2:	e4 09 07 40 	macu.d	r0,r2,r9
8000ccf6:	e6 09 06 44 	mulu.d	r4,r3,r9
8000ccfa:	02 04       	add	r4,r1
8000ccfc:	5c 05       	acr	r5
8000ccfe:	a3 65       	lsl	r5,0x2
8000cd00:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000cd04:	a3 64       	lsl	r4,0x2
8000cd06:	5c 34       	neg	r4
8000cd08:	f8 05 01 45 	sbc	r5,r12,r5
8000cd0c:	e6 04 06 40 	mulu.d	r0,r3,r4
8000cd10:	e4 05 07 40 	macu.d	r0,r2,r5
8000cd14:	e6 05 06 44 	mulu.d	r4,r3,r5
8000cd18:	02 04       	add	r4,r1
8000cd1a:	5c 05       	acr	r5
8000cd1c:	ea 03 15 02 	lsl	r3,r5,0x2
8000cd20:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000cd24:	e8 02 15 02 	lsl	r2,r4,0x2
8000cd28:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000cd2c:	e4 0b 07 40 	macu.d	r0,r2,r11
8000cd30:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000cd34:	02 02       	add	r2,r1
8000cd36:	5c 03       	acr	r3
8000cd38:	ed b3 00 1c 	bld	r3,0x1c
8000cd3c:	c0 90       	breq	8000cd4e <__avr32_f64_div+0x12a>
8000cd3e:	a1 72       	lsl	r2,0x1
8000cd40:	5c f3       	rol	r3
8000cd42:	20 17       	sub	r7,1
8000cd44:	a3 9a       	lsr	r10,0x3
8000cd46:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000cd4a:	a3 9b       	lsr	r11,0x3
8000cd4c:	c0 58       	rjmp	8000cd56 <__avr32_f64_div+0x132>
8000cd4e:	a5 8a       	lsr	r10,0x4
8000cd50:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000cd54:	a5 8b       	lsr	r11,0x4
8000cd56:	58 07       	cp.w	r7,0
8000cd58:	e0 8a 00 8b 	brle	8000ce6e <__avr32_f64_div_res_subnormal>
8000cd5c:	e0 12 ff 00 	andl	r2,0xff00
8000cd60:	e8 12 00 80 	orl	r2,0x80
8000cd64:	e6 08 06 40 	mulu.d	r0,r3,r8
8000cd68:	e4 09 07 40 	macu.d	r0,r2,r9
8000cd6c:	e4 08 06 44 	mulu.d	r4,r2,r8
8000cd70:	e6 09 06 48 	mulu.d	r8,r3,r9
8000cd74:	00 05       	add	r5,r0
8000cd76:	f0 01 00 48 	adc	r8,r8,r1
8000cd7a:	5c 09       	acr	r9
8000cd7c:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000cd80:	58 04       	cp.w	r4,0
8000cd82:	5c 25       	cpc	r5

8000cd84 <__avr32_f64_div_round_subnormal>:
8000cd84:	f4 08 13 00 	cpc	r8,r10
8000cd88:	f6 09 13 00 	cpc	r9,r11
8000cd8c:	5f 36       	srlo	r6
8000cd8e:	f8 06 17 00 	moveq	r6,r12
8000cd92:	e4 0a 16 08 	lsr	r10,r2,0x8
8000cd96:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000cd9a:	e6 0b 16 08 	lsr	r11,r3,0x8
8000cd9e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000cda2:	ed be 00 1f 	bld	lr,0x1f
8000cda6:	ef bb 00 1f 	bst	r11,0x1f
8000cdaa:	0c 0a       	add	r10,r6
8000cdac:	5c 0b       	acr	r11
8000cdae:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000cdb2:	e4 1b 00 0f 	andh	r11,0xf
8000cdb6:	14 4b       	or	r11,r10
8000cdb8:	e0 81 00 a7 	brne	8000cf06 <__avr32_f64_div_res_subnormal+0x98>
8000cdbc:	f2 06 16 14 	lsr	r6,r9,0x14
8000cdc0:	ab d6       	cbr	r6,0xb
8000cdc2:	e0 46 07 ff 	cp.w	r6,2047
8000cdc6:	e0 81 00 a4 	brne	8000cf0e <__avr32_f64_div_res_subnormal+0xa0>
8000cdca:	c9 e8       	rjmp	8000cf06 <__avr32_f64_div_res_subnormal+0x98>
8000cdcc:	e4 19 00 0f 	andh	r9,0xf
8000cdd0:	10 49       	or	r9,r8
8000cdd2:	e0 81 00 9a 	brne	8000cf06 <__avr32_f64_div_res_subnormal+0x98>
8000cdd6:	c9 28       	rjmp	8000cefa <__avr32_f64_div_res_subnormal+0x8c>
8000cdd8:	a3 7b       	lsl	r11,0x3
8000cdda:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000cdde:	a3 7a       	lsl	r10,0x3
8000cde0:	f5 eb 10 04 	or	r4,r10,r11
8000cde4:	e0 80 00 a0 	breq	8000cf24 <__avr32_f64_div_op1_zero>
8000cde8:	f6 04 12 00 	clz	r4,r11
8000cdec:	c1 70       	breq	8000ce1a <__avr32_f64_div_round_subnormal+0x96>
8000cdee:	c0 c3       	brcs	8000ce06 <__avr32_f64_div_round_subnormal+0x82>
8000cdf0:	e8 05 11 20 	rsub	r5,r4,32
8000cdf4:	f6 04 09 4b 	lsl	r11,r11,r4
8000cdf8:	f4 05 0a 45 	lsr	r5,r10,r5
8000cdfc:	0a 4b       	or	r11,r5
8000cdfe:	f4 04 09 4a 	lsl	r10,r10,r4
8000ce02:	08 17       	sub	r7,r4
8000ce04:	c0 b8       	rjmp	8000ce1a <__avr32_f64_div_round_subnormal+0x96>
8000ce06:	f4 04 12 00 	clz	r4,r10
8000ce0a:	f9 b4 03 00 	movlo	r4,0
8000ce0e:	f7 b4 02 e0 	subhs	r4,-32
8000ce12:	f4 04 09 4b 	lsl	r11,r10,r4
8000ce16:	30 0a       	mov	r10,0
8000ce18:	08 17       	sub	r7,r4
8000ce1a:	a3 8a       	lsr	r10,0x2
8000ce1c:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000ce20:	a3 8b       	lsr	r11,0x2
8000ce22:	c1 1b       	rjmp	8000cc44 <__avr32_f64_div+0x20>
8000ce24:	a3 79       	lsl	r9,0x3
8000ce26:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000ce2a:	a3 78       	lsl	r8,0x3
8000ce2c:	f3 e8 10 04 	or	r4,r9,r8
8000ce30:	c6 f0       	breq	8000cf0e <__avr32_f64_div_res_subnormal+0xa0>
8000ce32:	f2 04 12 00 	clz	r4,r9
8000ce36:	c1 70       	breq	8000ce64 <__avr32_f64_div_round_subnormal+0xe0>
8000ce38:	c0 c3       	brcs	8000ce50 <__avr32_f64_div_round_subnormal+0xcc>
8000ce3a:	e8 05 11 20 	rsub	r5,r4,32
8000ce3e:	f2 04 09 49 	lsl	r9,r9,r4
8000ce42:	f0 05 0a 45 	lsr	r5,r8,r5
8000ce46:	0a 49       	or	r9,r5
8000ce48:	f0 04 09 48 	lsl	r8,r8,r4
8000ce4c:	08 16       	sub	r6,r4
8000ce4e:	c0 b8       	rjmp	8000ce64 <__avr32_f64_div_round_subnormal+0xe0>
8000ce50:	f0 04 12 00 	clz	r4,r8
8000ce54:	f9 b4 03 00 	movlo	r4,0
8000ce58:	f7 b4 02 e0 	subhs	r4,-32
8000ce5c:	f0 04 09 49 	lsl	r9,r8,r4
8000ce60:	30 08       	mov	r8,0
8000ce62:	08 16       	sub	r6,r4
8000ce64:	a3 88       	lsr	r8,0x2
8000ce66:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000ce6a:	a3 89       	lsr	r9,0x2
8000ce6c:	cf ca       	rjmp	8000cc64 <__avr32_f64_div+0x40>

8000ce6e <__avr32_f64_div_res_subnormal>:
8000ce6e:	5c 37       	neg	r7
8000ce70:	2f f7       	sub	r7,-1
8000ce72:	f1 b7 04 c0 	satu	r7,0x6
8000ce76:	e0 47 00 20 	cp.w	r7,32
8000ce7a:	c1 54       	brge	8000cea4 <__avr32_f64_div_res_subnormal+0x36>
8000ce7c:	ee 06 11 20 	rsub	r6,r7,32
8000ce80:	e4 07 0a 42 	lsr	r2,r2,r7
8000ce84:	e6 06 09 4c 	lsl	r12,r3,r6
8000ce88:	18 42       	or	r2,r12
8000ce8a:	e6 07 0a 43 	lsr	r3,r3,r7
8000ce8e:	f4 06 09 41 	lsl	r1,r10,r6
8000ce92:	f4 07 0a 4a 	lsr	r10,r10,r7
8000ce96:	f6 06 09 4c 	lsl	r12,r11,r6
8000ce9a:	18 4a       	or	r10,r12
8000ce9c:	f6 07 0a 4b 	lsr	r11,r11,r7
8000cea0:	30 00       	mov	r0,0
8000cea2:	c1 58       	rjmp	8000cecc <__avr32_f64_div_res_subnormal+0x5e>
8000cea4:	ee 06 11 20 	rsub	r6,r7,32
8000cea8:	f9 b0 00 00 	moveq	r0,0
8000ceac:	f9 bc 00 00 	moveq	r12,0
8000ceb0:	c0 50       	breq	8000ceba <__avr32_f64_div_res_subnormal+0x4c>
8000ceb2:	f4 06 09 40 	lsl	r0,r10,r6
8000ceb6:	f6 06 09 4c 	lsl	r12,r11,r6
8000ceba:	e6 07 0a 42 	lsr	r2,r3,r7
8000cebe:	30 03       	mov	r3,0
8000cec0:	f4 07 0a 41 	lsr	r1,r10,r7
8000cec4:	18 41       	or	r1,r12
8000cec6:	f6 07 0a 4a 	lsr	r10,r11,r7
8000ceca:	30 0b       	mov	r11,0
8000cecc:	e0 12 ff 00 	andl	r2,0xff00
8000ced0:	e8 12 00 80 	orl	r2,0x80
8000ced4:	e6 08 06 46 	mulu.d	r6,r3,r8
8000ced8:	e4 09 07 46 	macu.d	r6,r2,r9
8000cedc:	e4 08 06 44 	mulu.d	r4,r2,r8
8000cee0:	e6 09 06 48 	mulu.d	r8,r3,r9
8000cee4:	0c 05       	add	r5,r6
8000cee6:	f0 07 00 48 	adc	r8,r8,r7
8000ceea:	5c 09       	acr	r9
8000ceec:	30 07       	mov	r7,0
8000ceee:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000cef2:	00 34       	cp.w	r4,r0
8000cef4:	e2 05 13 00 	cpc	r5,r1
8000cef8:	c4 6b       	rjmp	8000cd84 <__avr32_f64_div_round_subnormal>
8000cefa:	1c 9b       	mov	r11,lr
8000cefc:	e6 1b 80 00 	andh	r11,0x8000,COH
8000cf00:	30 0a       	mov	r10,0
8000cf02:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000cf06:	3f fb       	mov	r11,-1
8000cf08:	30 0a       	mov	r10,0
8000cf0a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000cf0e:	f5 eb 10 04 	or	r4,r10,r11
8000cf12:	c0 90       	breq	8000cf24 <__avr32_f64_div_op1_zero>
8000cf14:	1c 9b       	mov	r11,lr
8000cf16:	e6 1b 80 00 	andh	r11,0x8000,COH
8000cf1a:	ea 1b 7f f0 	orh	r11,0x7ff0
8000cf1e:	30 0a       	mov	r10,0
8000cf20:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000cf24 <__avr32_f64_div_op1_zero>:
8000cf24:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000cf28:	ce f0       	breq	8000cf06 <__avr32_f64_div_res_subnormal+0x98>
8000cf2a:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000cf2e:	e0 44 07 ff 	cp.w	r4,2047
8000cf32:	ce 41       	brne	8000cefa <__avr32_f64_div_res_subnormal+0x8c>
8000cf34:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000cf38:	ce 10       	breq	8000cefa <__avr32_f64_div_res_subnormal+0x8c>
8000cf3a:	ce 6b       	rjmp	8000cf06 <__avr32_f64_div_res_subnormal+0x98>

8000cf3c <__avr32_udiv64>:
8000cf3c:	d4 31       	pushm	r0-r7,lr
8000cf3e:	1a 97       	mov	r7,sp
8000cf40:	20 3d       	sub	sp,12
8000cf42:	10 9c       	mov	r12,r8
8000cf44:	12 9e       	mov	lr,r9
8000cf46:	14 93       	mov	r3,r10
8000cf48:	58 09       	cp.w	r9,0
8000cf4a:	e0 81 00 bd 	brne	8000d0c4 <__avr32_udiv64+0x188>
8000cf4e:	16 38       	cp.w	r8,r11
8000cf50:	e0 88 00 40 	brls	8000cfd0 <__avr32_udiv64+0x94>
8000cf54:	f0 08 12 00 	clz	r8,r8
8000cf58:	c0 d0       	breq	8000cf72 <__avr32_udiv64+0x36>
8000cf5a:	f6 08 09 4b 	lsl	r11,r11,r8
8000cf5e:	f0 09 11 20 	rsub	r9,r8,32
8000cf62:	f8 08 09 4c 	lsl	r12,r12,r8
8000cf66:	f4 09 0a 49 	lsr	r9,r10,r9
8000cf6a:	f4 08 09 43 	lsl	r3,r10,r8
8000cf6e:	f3 eb 10 0b 	or	r11,r9,r11
8000cf72:	f8 0e 16 10 	lsr	lr,r12,0x10
8000cf76:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000cf7a:	f6 0e 0d 00 	divu	r0,r11,lr
8000cf7e:	e6 0b 16 10 	lsr	r11,r3,0x10
8000cf82:	00 99       	mov	r9,r0
8000cf84:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000cf88:	e0 0a 02 48 	mul	r8,r0,r10
8000cf8c:	10 3b       	cp.w	r11,r8
8000cf8e:	c0 a2       	brcc	8000cfa2 <__avr32_udiv64+0x66>
8000cf90:	20 19       	sub	r9,1
8000cf92:	18 0b       	add	r11,r12
8000cf94:	18 3b       	cp.w	r11,r12
8000cf96:	c0 63       	brcs	8000cfa2 <__avr32_udiv64+0x66>
8000cf98:	10 3b       	cp.w	r11,r8
8000cf9a:	f7 b9 03 01 	sublo	r9,1
8000cf9e:	f7 dc e3 0b 	addcs	r11,r11,r12
8000cfa2:	f6 08 01 01 	sub	r1,r11,r8
8000cfa6:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000cfaa:	e2 0e 0d 00 	divu	r0,r1,lr
8000cfae:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000cfb2:	00 98       	mov	r8,r0
8000cfb4:	e0 0a 02 4a 	mul	r10,r0,r10
8000cfb8:	14 33       	cp.w	r3,r10
8000cfba:	c0 82       	brcc	8000cfca <__avr32_udiv64+0x8e>
8000cfbc:	20 18       	sub	r8,1
8000cfbe:	18 03       	add	r3,r12
8000cfc0:	18 33       	cp.w	r3,r12
8000cfc2:	c0 43       	brcs	8000cfca <__avr32_udiv64+0x8e>
8000cfc4:	14 33       	cp.w	r3,r10
8000cfc6:	f7 b8 03 01 	sublo	r8,1
8000cfca:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000cfce:	cd f8       	rjmp	8000d18c <__avr32_udiv64+0x250>
8000cfd0:	58 08       	cp.w	r8,0
8000cfd2:	c0 51       	brne	8000cfdc <__avr32_udiv64+0xa0>
8000cfd4:	30 19       	mov	r9,1
8000cfd6:	f2 08 0d 08 	divu	r8,r9,r8
8000cfda:	10 9c       	mov	r12,r8
8000cfdc:	f8 06 12 00 	clz	r6,r12
8000cfe0:	c0 41       	brne	8000cfe8 <__avr32_udiv64+0xac>
8000cfe2:	18 1b       	sub	r11,r12
8000cfe4:	30 19       	mov	r9,1
8000cfe6:	c4 08       	rjmp	8000d066 <__avr32_udiv64+0x12a>
8000cfe8:	ec 01 11 20 	rsub	r1,r6,32
8000cfec:	f4 01 0a 49 	lsr	r9,r10,r1
8000cff0:	f8 06 09 4c 	lsl	r12,r12,r6
8000cff4:	f6 06 09 48 	lsl	r8,r11,r6
8000cff8:	f6 01 0a 41 	lsr	r1,r11,r1
8000cffc:	f3 e8 10 08 	or	r8,r9,r8
8000d000:	f8 03 16 10 	lsr	r3,r12,0x10
8000d004:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000d008:	e2 03 0d 00 	divu	r0,r1,r3
8000d00c:	f0 0b 16 10 	lsr	r11,r8,0x10
8000d010:	00 9e       	mov	lr,r0
8000d012:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d016:	e0 05 02 49 	mul	r9,r0,r5
8000d01a:	12 3b       	cp.w	r11,r9
8000d01c:	c0 a2       	brcc	8000d030 <__avr32_udiv64+0xf4>
8000d01e:	20 1e       	sub	lr,1
8000d020:	18 0b       	add	r11,r12
8000d022:	18 3b       	cp.w	r11,r12
8000d024:	c0 63       	brcs	8000d030 <__avr32_udiv64+0xf4>
8000d026:	12 3b       	cp.w	r11,r9
8000d028:	f7 be 03 01 	sublo	lr,1
8000d02c:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d030:	12 1b       	sub	r11,r9
8000d032:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000d036:	f6 03 0d 02 	divu	r2,r11,r3
8000d03a:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000d03e:	04 99       	mov	r9,r2
8000d040:	e4 05 02 4b 	mul	r11,r2,r5
8000d044:	16 38       	cp.w	r8,r11
8000d046:	c0 a2       	brcc	8000d05a <__avr32_udiv64+0x11e>
8000d048:	20 19       	sub	r9,1
8000d04a:	18 08       	add	r8,r12
8000d04c:	18 38       	cp.w	r8,r12
8000d04e:	c0 63       	brcs	8000d05a <__avr32_udiv64+0x11e>
8000d050:	16 38       	cp.w	r8,r11
8000d052:	f7 b9 03 01 	sublo	r9,1
8000d056:	f1 dc e3 08 	addcs	r8,r8,r12
8000d05a:	f4 06 09 43 	lsl	r3,r10,r6
8000d05e:	f0 0b 01 0b 	sub	r11,r8,r11
8000d062:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000d066:	f8 06 16 10 	lsr	r6,r12,0x10
8000d06a:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000d06e:	f6 06 0d 00 	divu	r0,r11,r6
8000d072:	e6 0b 16 10 	lsr	r11,r3,0x10
8000d076:	00 9a       	mov	r10,r0
8000d078:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d07c:	e0 0e 02 48 	mul	r8,r0,lr
8000d080:	10 3b       	cp.w	r11,r8
8000d082:	c0 a2       	brcc	8000d096 <__avr32_udiv64+0x15a>
8000d084:	20 1a       	sub	r10,1
8000d086:	18 0b       	add	r11,r12
8000d088:	18 3b       	cp.w	r11,r12
8000d08a:	c0 63       	brcs	8000d096 <__avr32_udiv64+0x15a>
8000d08c:	10 3b       	cp.w	r11,r8
8000d08e:	f7 ba 03 01 	sublo	r10,1
8000d092:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d096:	f6 08 01 01 	sub	r1,r11,r8
8000d09a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000d09e:	e2 06 0d 00 	divu	r0,r1,r6
8000d0a2:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000d0a6:	00 98       	mov	r8,r0
8000d0a8:	e0 0e 02 4b 	mul	r11,r0,lr
8000d0ac:	16 33       	cp.w	r3,r11
8000d0ae:	c0 82       	brcc	8000d0be <__avr32_udiv64+0x182>
8000d0b0:	20 18       	sub	r8,1
8000d0b2:	18 03       	add	r3,r12
8000d0b4:	18 33       	cp.w	r3,r12
8000d0b6:	c0 43       	brcs	8000d0be <__avr32_udiv64+0x182>
8000d0b8:	16 33       	cp.w	r3,r11
8000d0ba:	f7 b8 03 01 	sublo	r8,1
8000d0be:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000d0c2:	c6 98       	rjmp	8000d194 <__avr32_udiv64+0x258>
8000d0c4:	16 39       	cp.w	r9,r11
8000d0c6:	e0 8b 00 65 	brhi	8000d190 <__avr32_udiv64+0x254>
8000d0ca:	f2 09 12 00 	clz	r9,r9
8000d0ce:	c0 b1       	brne	8000d0e4 <__avr32_udiv64+0x1a8>
8000d0d0:	10 3a       	cp.w	r10,r8
8000d0d2:	5f 2a       	srhs	r10
8000d0d4:	1c 3b       	cp.w	r11,lr
8000d0d6:	5f b8       	srhi	r8
8000d0d8:	10 4a       	or	r10,r8
8000d0da:	f2 0a 18 00 	cp.b	r10,r9
8000d0de:	c5 90       	breq	8000d190 <__avr32_udiv64+0x254>
8000d0e0:	30 18       	mov	r8,1
8000d0e2:	c5 98       	rjmp	8000d194 <__avr32_udiv64+0x258>
8000d0e4:	f0 09 09 46 	lsl	r6,r8,r9
8000d0e8:	f2 03 11 20 	rsub	r3,r9,32
8000d0ec:	fc 09 09 4e 	lsl	lr,lr,r9
8000d0f0:	f0 03 0a 48 	lsr	r8,r8,r3
8000d0f4:	f6 09 09 4c 	lsl	r12,r11,r9
8000d0f8:	f4 03 0a 42 	lsr	r2,r10,r3
8000d0fc:	ef 46 ff f4 	st.w	r7[-12],r6
8000d100:	f6 03 0a 43 	lsr	r3,r11,r3
8000d104:	18 42       	or	r2,r12
8000d106:	f1 ee 10 0c 	or	r12,r8,lr
8000d10a:	f8 01 16 10 	lsr	r1,r12,0x10
8000d10e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000d112:	e6 01 0d 04 	divu	r4,r3,r1
8000d116:	e4 03 16 10 	lsr	r3,r2,0x10
8000d11a:	08 9e       	mov	lr,r4
8000d11c:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000d120:	e8 06 02 48 	mul	r8,r4,r6
8000d124:	10 33       	cp.w	r3,r8
8000d126:	c0 a2       	brcc	8000d13a <__avr32_udiv64+0x1fe>
8000d128:	20 1e       	sub	lr,1
8000d12a:	18 03       	add	r3,r12
8000d12c:	18 33       	cp.w	r3,r12
8000d12e:	c0 63       	brcs	8000d13a <__avr32_udiv64+0x1fe>
8000d130:	10 33       	cp.w	r3,r8
8000d132:	f7 be 03 01 	sublo	lr,1
8000d136:	e7 dc e3 03 	addcs	r3,r3,r12
8000d13a:	10 13       	sub	r3,r8
8000d13c:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000d140:	e6 01 0d 00 	divu	r0,r3,r1
8000d144:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d148:	00 98       	mov	r8,r0
8000d14a:	e0 06 02 46 	mul	r6,r0,r6
8000d14e:	0c 3b       	cp.w	r11,r6
8000d150:	c0 a2       	brcc	8000d164 <__avr32_udiv64+0x228>
8000d152:	20 18       	sub	r8,1
8000d154:	18 0b       	add	r11,r12
8000d156:	18 3b       	cp.w	r11,r12
8000d158:	c0 63       	brcs	8000d164 <__avr32_udiv64+0x228>
8000d15a:	0c 3b       	cp.w	r11,r6
8000d15c:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d160:	f7 b8 03 01 	sublo	r8,1
8000d164:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000d168:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000d16c:	0c 1b       	sub	r11,r6
8000d16e:	f0 04 06 42 	mulu.d	r2,r8,r4
8000d172:	06 95       	mov	r5,r3
8000d174:	16 35       	cp.w	r5,r11
8000d176:	e0 8b 00 0a 	brhi	8000d18a <__avr32_udiv64+0x24e>
8000d17a:	5f 0b       	sreq	r11
8000d17c:	f4 09 09 49 	lsl	r9,r10,r9
8000d180:	12 32       	cp.w	r2,r9
8000d182:	5f b9       	srhi	r9
8000d184:	f7 e9 00 09 	and	r9,r11,r9
8000d188:	c0 60       	breq	8000d194 <__avr32_udiv64+0x258>
8000d18a:	20 18       	sub	r8,1
8000d18c:	30 09       	mov	r9,0
8000d18e:	c0 38       	rjmp	8000d194 <__avr32_udiv64+0x258>
8000d190:	30 09       	mov	r9,0
8000d192:	12 98       	mov	r8,r9
8000d194:	10 9a       	mov	r10,r8
8000d196:	12 93       	mov	r3,r9
8000d198:	10 92       	mov	r2,r8
8000d19a:	12 9b       	mov	r11,r9
8000d19c:	2f dd       	sub	sp,-12
8000d19e:	d8 32       	popm	r0-r7,pc

8000d1a0 <__avr32_umod64>:
8000d1a0:	d4 31       	pushm	r0-r7,lr
8000d1a2:	1a 97       	mov	r7,sp
8000d1a4:	20 3d       	sub	sp,12
8000d1a6:	10 9c       	mov	r12,r8
8000d1a8:	12 95       	mov	r5,r9
8000d1aa:	14 9e       	mov	lr,r10
8000d1ac:	16 91       	mov	r1,r11
8000d1ae:	16 96       	mov	r6,r11
8000d1b0:	58 09       	cp.w	r9,0
8000d1b2:	e0 81 00 81 	brne	8000d2b4 <__avr32_umod64+0x114>
8000d1b6:	16 38       	cp.w	r8,r11
8000d1b8:	e0 88 00 12 	brls	8000d1dc <__avr32_umod64+0x3c>
8000d1bc:	f0 08 12 00 	clz	r8,r8
8000d1c0:	c4 e0       	breq	8000d25c <__avr32_umod64+0xbc>
8000d1c2:	f6 08 09 46 	lsl	r6,r11,r8
8000d1c6:	f8 08 09 4c 	lsl	r12,r12,r8
8000d1ca:	f0 0b 11 20 	rsub	r11,r8,32
8000d1ce:	f4 08 09 4e 	lsl	lr,r10,r8
8000d1d2:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000d1d6:	f7 e6 10 06 	or	r6,r11,r6
8000d1da:	c4 18       	rjmp	8000d25c <__avr32_umod64+0xbc>
8000d1dc:	58 08       	cp.w	r8,0
8000d1de:	c0 51       	brne	8000d1e8 <__avr32_umod64+0x48>
8000d1e0:	30 19       	mov	r9,1
8000d1e2:	f2 08 0d 08 	divu	r8,r9,r8
8000d1e6:	10 9c       	mov	r12,r8
8000d1e8:	f8 08 12 00 	clz	r8,r12
8000d1ec:	c0 31       	brne	8000d1f2 <__avr32_umod64+0x52>
8000d1ee:	18 16       	sub	r6,r12
8000d1f0:	c3 68       	rjmp	8000d25c <__avr32_umod64+0xbc>
8000d1f2:	f0 03 11 20 	rsub	r3,r8,32
8000d1f6:	f4 03 0a 4b 	lsr	r11,r10,r3
8000d1fa:	f8 08 09 4c 	lsl	r12,r12,r8
8000d1fe:	ec 08 09 49 	lsl	r9,r6,r8
8000d202:	ec 03 0a 43 	lsr	r3,r6,r3
8000d206:	f7 e9 10 09 	or	r9,r11,r9
8000d20a:	f8 05 16 10 	lsr	r5,r12,0x10
8000d20e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000d212:	e6 05 0d 02 	divu	r2,r3,r5
8000d216:	f2 0e 16 10 	lsr	lr,r9,0x10
8000d21a:	ec 02 02 4b 	mul	r11,r6,r2
8000d21e:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000d222:	16 3e       	cp.w	lr,r11
8000d224:	c0 72       	brcc	8000d232 <__avr32_umod64+0x92>
8000d226:	18 0e       	add	lr,r12
8000d228:	18 3e       	cp.w	lr,r12
8000d22a:	c0 43       	brcs	8000d232 <__avr32_umod64+0x92>
8000d22c:	16 3e       	cp.w	lr,r11
8000d22e:	fd dc e3 0e 	addcs	lr,lr,r12
8000d232:	fc 0b 01 03 	sub	r3,lr,r11
8000d236:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000d23a:	e6 05 0d 02 	divu	r2,r3,r5
8000d23e:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000d242:	a5 36       	mul	r6,r2
8000d244:	0c 39       	cp.w	r9,r6
8000d246:	c0 72       	brcc	8000d254 <__avr32_umod64+0xb4>
8000d248:	18 09       	add	r9,r12
8000d24a:	18 39       	cp.w	r9,r12
8000d24c:	c0 43       	brcs	8000d254 <__avr32_umod64+0xb4>
8000d24e:	0c 39       	cp.w	r9,r6
8000d250:	f3 dc e3 09 	addcs	r9,r9,r12
8000d254:	f2 06 01 06 	sub	r6,r9,r6
8000d258:	f4 08 09 4e 	lsl	lr,r10,r8
8000d25c:	f8 0a 16 10 	lsr	r10,r12,0x10
8000d260:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000d264:	ec 0a 0d 02 	divu	r2,r6,r10
8000d268:	fc 09 16 10 	lsr	r9,lr,0x10
8000d26c:	ea 02 02 4b 	mul	r11,r5,r2
8000d270:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000d274:	16 39       	cp.w	r9,r11
8000d276:	c0 72       	brcc	8000d284 <__avr32_umod64+0xe4>
8000d278:	18 09       	add	r9,r12
8000d27a:	18 39       	cp.w	r9,r12
8000d27c:	c0 43       	brcs	8000d284 <__avr32_umod64+0xe4>
8000d27e:	16 39       	cp.w	r9,r11
8000d280:	f3 dc e3 09 	addcs	r9,r9,r12
8000d284:	f2 0b 01 0b 	sub	r11,r9,r11
8000d288:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000d28c:	f6 0a 0d 0a 	divu	r10,r11,r10
8000d290:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000d294:	ea 0a 02 4a 	mul	r10,r5,r10
8000d298:	14 3e       	cp.w	lr,r10
8000d29a:	c0 72       	brcc	8000d2a8 <__avr32_umod64+0x108>
8000d29c:	18 0e       	add	lr,r12
8000d29e:	18 3e       	cp.w	lr,r12
8000d2a0:	c0 43       	brcs	8000d2a8 <__avr32_umod64+0x108>
8000d2a2:	14 3e       	cp.w	lr,r10
8000d2a4:	fd dc e3 0e 	addcs	lr,lr,r12
8000d2a8:	fc 0a 01 0a 	sub	r10,lr,r10
8000d2ac:	30 0b       	mov	r11,0
8000d2ae:	f4 08 0a 4a 	lsr	r10,r10,r8
8000d2b2:	c7 b8       	rjmp	8000d3a8 <__avr32_umod64+0x208>
8000d2b4:	16 39       	cp.w	r9,r11
8000d2b6:	e0 8b 00 79 	brhi	8000d3a8 <__avr32_umod64+0x208>
8000d2ba:	f2 09 12 00 	clz	r9,r9
8000d2be:	c1 21       	brne	8000d2e2 <__avr32_umod64+0x142>
8000d2c0:	10 3a       	cp.w	r10,r8
8000d2c2:	5f 2b       	srhs	r11
8000d2c4:	0a 31       	cp.w	r1,r5
8000d2c6:	5f ba       	srhi	r10
8000d2c8:	f7 ea 10 0a 	or	r10,r11,r10
8000d2cc:	f2 0a 18 00 	cp.b	r10,r9
8000d2d0:	c0 60       	breq	8000d2dc <__avr32_umod64+0x13c>
8000d2d2:	fc 08 01 0c 	sub	r12,lr,r8
8000d2d6:	e2 05 01 46 	sbc	r6,r1,r5
8000d2da:	18 9e       	mov	lr,r12
8000d2dc:	0c 9b       	mov	r11,r6
8000d2de:	1c 9a       	mov	r10,lr
8000d2e0:	c6 48       	rjmp	8000d3a8 <__avr32_umod64+0x208>
8000d2e2:	ea 09 09 4c 	lsl	r12,r5,r9
8000d2e6:	f2 06 11 20 	rsub	r6,r9,32
8000d2ea:	f6 09 09 4b 	lsl	r11,r11,r9
8000d2ee:	f0 09 09 42 	lsl	r2,r8,r9
8000d2f2:	ef 46 ff f4 	st.w	r7[-12],r6
8000d2f6:	f0 06 0a 48 	lsr	r8,r8,r6
8000d2fa:	18 48       	or	r8,r12
8000d2fc:	e2 06 0a 4c 	lsr	r12,r1,r6
8000d300:	f4 09 09 43 	lsl	r3,r10,r9
8000d304:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000d308:	f4 06 0a 4a 	lsr	r10,r10,r6
8000d30c:	16 4a       	or	r10,r11
8000d30e:	f0 0b 16 10 	lsr	r11,r8,0x10
8000d312:	f8 0b 0d 04 	divu	r4,r12,r11
8000d316:	f4 0c 16 10 	lsr	r12,r10,0x10
8000d31a:	08 91       	mov	r1,r4
8000d31c:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000d320:	e8 0e 02 46 	mul	r6,r4,lr
8000d324:	0c 3c       	cp.w	r12,r6
8000d326:	c0 a2       	brcc	8000d33a <__avr32_umod64+0x19a>
8000d328:	20 11       	sub	r1,1
8000d32a:	10 0c       	add	r12,r8
8000d32c:	10 3c       	cp.w	r12,r8
8000d32e:	c0 63       	brcs	8000d33a <__avr32_umod64+0x19a>
8000d330:	0c 3c       	cp.w	r12,r6
8000d332:	f7 b1 03 01 	sublo	r1,1
8000d336:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000d33a:	0c 1c       	sub	r12,r6
8000d33c:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000d340:	f8 0b 0d 04 	divu	r4,r12,r11
8000d344:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000d348:	08 96       	mov	r6,r4
8000d34a:	e8 0e 02 4e 	mul	lr,r4,lr
8000d34e:	1c 3b       	cp.w	r11,lr
8000d350:	c0 a2       	brcc	8000d364 <__avr32_umod64+0x1c4>
8000d352:	20 16       	sub	r6,1
8000d354:	10 0b       	add	r11,r8
8000d356:	10 3b       	cp.w	r11,r8
8000d358:	c0 63       	brcs	8000d364 <__avr32_umod64+0x1c4>
8000d35a:	1c 3b       	cp.w	r11,lr
8000d35c:	f7 b6 03 01 	sublo	r6,1
8000d360:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000d364:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000d368:	1c 1b       	sub	r11,lr
8000d36a:	e2 02 06 40 	mulu.d	r0,r1,r2
8000d36e:	00 9e       	mov	lr,r0
8000d370:	02 9c       	mov	r12,r1
8000d372:	16 3c       	cp.w	r12,r11
8000d374:	e0 8b 00 08 	brhi	8000d384 <__avr32_umod64+0x1e4>
8000d378:	5f 06       	sreq	r6
8000d37a:	06 30       	cp.w	r0,r3
8000d37c:	5f ba       	srhi	r10
8000d37e:	ed ea 00 0a 	and	r10,r6,r10
8000d382:	c0 60       	breq	8000d38e <__avr32_umod64+0x1ee>
8000d384:	fc 02 01 04 	sub	r4,lr,r2
8000d388:	f8 08 01 4c 	sbc	r12,r12,r8
8000d38c:	08 9e       	mov	lr,r4
8000d38e:	e6 0e 01 0a 	sub	r10,r3,lr
8000d392:	f6 0c 01 4c 	sbc	r12,r11,r12
8000d396:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000d39a:	f8 09 0a 4b 	lsr	r11,r12,r9
8000d39e:	f4 09 0a 4a 	lsr	r10,r10,r9
8000d3a2:	f8 01 09 4c 	lsl	r12,r12,r1
8000d3a6:	18 4a       	or	r10,r12
8000d3a8:	2f dd       	sub	sp,-12
8000d3aa:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000d400 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000d400:	c0 08       	rjmp	8000d400 <_evba>
	...

8000d404 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000d404:	c0 08       	rjmp	8000d404 <_handle_TLB_Multiple_Hit>
	...

8000d408 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000d408:	c0 08       	rjmp	8000d408 <_handle_Bus_Error_Data_Fetch>
	...

8000d40c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000d40c:	c0 08       	rjmp	8000d40c <_handle_Bus_Error_Instruction_Fetch>
	...

8000d410 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000d410:	c0 08       	rjmp	8000d410 <_handle_NMI>
	...

8000d414 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000d414:	c0 08       	rjmp	8000d414 <_handle_Instruction_Address>
	...

8000d418 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000d418:	c0 08       	rjmp	8000d418 <_handle_ITLB_Protection>
	...

8000d41c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000d41c:	c0 08       	rjmp	8000d41c <_handle_Breakpoint>
	...

8000d420 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000d420:	c0 08       	rjmp	8000d420 <_handle_Illegal_Opcode>
	...

8000d424 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000d424:	c0 08       	rjmp	8000d424 <_handle_Unimplemented_Instruction>
	...

8000d428 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000d428:	c0 08       	rjmp	8000d428 <_handle_Privilege_Violation>
	...

8000d42c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000d42c:	c0 08       	rjmp	8000d42c <_handle_Floating_Point>
	...

8000d430 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000d430:	c0 08       	rjmp	8000d430 <_handle_Coprocessor_Absent>
	...

8000d434 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000d434:	c0 08       	rjmp	8000d434 <_handle_Data_Address_Read>
	...

8000d438 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000d438:	c0 08       	rjmp	8000d438 <_handle_Data_Address_Write>
	...

8000d43c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000d43c:	c0 08       	rjmp	8000d43c <_handle_DTLB_Protection_Read>
	...

8000d440 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000d440:	c0 08       	rjmp	8000d440 <_handle_DTLB_Protection_Write>
	...

8000d444 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000d444:	c0 08       	rjmp	8000d444 <_handle_DTLB_Modified>
	...

8000d450 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000d450:	c0 08       	rjmp	8000d450 <_handle_ITLB_Miss>
	...

8000d460 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000d460:	c0 08       	rjmp	8000d460 <_handle_DTLB_Miss_Read>
	...

8000d470 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000d470:	c0 08       	rjmp	8000d470 <_handle_DTLB_Miss_Write>
	...

8000d500 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000d500:	fe cf 71 80 	sub	pc,pc,29056

8000d504 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000d504:	30 0c       	mov	r12,0
8000d506:	fe b0 c3 5b 	rcall	80005bbc <_get_interrupt_handler>
8000d50a:	58 0c       	cp.w	r12,0
8000d50c:	f8 0f 17 10 	movne	pc,r12
8000d510:	d6 03       	rete

8000d512 <_int1>:
8000d512:	30 1c       	mov	r12,1
8000d514:	fe b0 c3 54 	rcall	80005bbc <_get_interrupt_handler>
8000d518:	58 0c       	cp.w	r12,0
8000d51a:	f8 0f 17 10 	movne	pc,r12
8000d51e:	d6 03       	rete

8000d520 <_int2>:
8000d520:	30 2c       	mov	r12,2
8000d522:	fe b0 c3 4d 	rcall	80005bbc <_get_interrupt_handler>
8000d526:	58 0c       	cp.w	r12,0
8000d528:	f8 0f 17 10 	movne	pc,r12
8000d52c:	d6 03       	rete

8000d52e <_int3>:
8000d52e:	30 3c       	mov	r12,3
8000d530:	fe b0 c3 46 	rcall	80005bbc <_get_interrupt_handler>
8000d534:	58 0c       	cp.w	r12,0
8000d536:	f8 0f 17 10 	movne	pc,r12
8000d53a:	d6 03       	rete

8000d53c <ipr_val>:
8000d53c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000d54c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d55c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d56c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d57c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d58c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d59c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d5ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d5bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d5cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d5dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d5ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d5fc:	d7 03 d7 03                                         ....
