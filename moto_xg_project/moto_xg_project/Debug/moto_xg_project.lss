
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000ab2c  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000cc00  8000cc00  0000d000  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001290  8000ce00  8000ce00  0000d200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a3c  00000004  8000e090  0000e804  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00005130  00000a40  8000eacc  0000f240  2**2
                  ALLOC
  7 .comment      00000030  00000000  00000000  0000f240  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00001688  00000000  00000000  0000f270  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 00003620  00000000  00000000  000108f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0002c40d  00000000  00000000  00013f18  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00007283  00000000  00000000  00040325  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000d421  00000000  00000000  000475a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00003d14  00000000  00000000  000549cc  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00007f95  00000000  00000000  000586e0  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0000f391  00000000  00000000  00060675  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 17 .debug_ranges 00001750  00000000  00000000  0006fa08  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c4 dc 	sub	pc,pc,-15140

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d 98       	ld.ub	r8,r6[0x1]

80002028 <Volume_brdcst_func>:
	//log("Attenuator_Number: %x \n",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("Audio_Parameter: %x \n", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 60       	and	r0,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 03 20 	mov	r10,800
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  800//1024//800//384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 08       	add	r8,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	3d fc       	mov	r12,-33
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 90       	sub	r0,9
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	20 a4       	sub	r4,10
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	2a a4       	sub	r4,-86
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	ce 00       	breq	80002042 <app_init+0x6>
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	27 a8       	sub	r8,122
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	6a 64       	ld.w	r4,r5[0x18]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 48       	or	r8,r5

80002090 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002090:	d4 01       	pushm	lr
  log("R");
80002092:	48 3c       	lddpc	r12,8000209c <app_payload_tx_proc+0xc>
80002094:	f0 1f 00 03 	mcall	800020a0 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002098:	d8 02       	popm	pc
8000209a:	00 00       	add	r0,r0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	ce 08       	rjmp	8000225e <ButtonConfig_brdcst_func+0x7a>
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	6e 28       	ld.w	r8,r7[0x8]

800020a4 <app_payload_rx_proc>:
}



static void app_payload_rx_proc(void  * payload)
{
800020a4:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
800020a6:	48 99       	lddpc	r9,800020c8 <app_payload_rx_proc+0x24>
800020a8:	13 88       	ld.ub	r8,r9[0x0]
800020aa:	2f f8       	sub	r8,-1
800020ac:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
800020ae:	30 39       	mov	r9,3
800020b0:	f2 08 18 00 	cp.b	r8,r9
800020b4:	c0 71       	brne	800020c2 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
800020b6:	30 09       	mov	r9,0
800020b8:	48 48       	lddpc	r8,800020c8 <app_payload_rx_proc+0x24>
800020ba:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800020bc:	48 4c       	lddpc	r12,800020cc <app_payload_rx_proc+0x28>
800020be:	f0 1f 00 05 	mcall	800020d0 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
800020c2:	48 58       	lddpc	r8,800020d4 <app_payload_rx_proc+0x30>
800020c4:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
800020c6:	d8 02       	popm	pc
800020c8:	00 00       	add	r0,r0
800020ca:	0a 5c       	eor	r12,r5
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	ce 0c       	rcall	8000228e <ButtonConfig_brdcst_func+0xaa>
800020d0:	80 00       	ld.sh	r0,r0[0x0]
800020d2:	6e 28       	ld.w	r8,r7[0x8]
800020d4:	00 00       	add	r0,r0
800020d6:	0a 45       	or	r5,r5

800020d8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020da:	48 3c       	lddpc	r12,800020e4 <FD_brdcst_func+0xc>
800020dc:	f0 1f 00 03 	mcall	800020e8 <FD_brdcst_func+0x10>
	
}
800020e0:	d8 02       	popm	pc
800020e2:	00 00       	add	r0,r0
800020e4:	80 00       	ld.sh	r0,r0[0x0]
800020e6:	ce 18       	rjmp	800022a8 <ButtonConfig_brdcst_func+0xc4>
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	6e 28       	ld.w	r8,r7[0x8]

800020ec <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020ec:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ee:	48 3c       	lddpc	r12,800020f8 <FD_reply_func+0xc>
800020f0:	f0 1f 00 03 	mcall	800020fc <FD_reply_func+0x10>
	
	
}
800020f4:	d8 02       	popm	pc
800020f6:	00 00       	add	r0,r0
800020f8:	80 00       	ld.sh	r0,r0[0x0]
800020fa:	ce 38       	rjmp	800022c0 <ButtonConfig_reply_func>
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	6e 28       	ld.w	r8,r7[0x8]

80002100 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002100:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002102:	48 3c       	lddpc	r12,8000210c <FD_request_func+0xc>
80002104:	f0 1f 00 03 	mcall	80002110 <FD_request_func+0x10>
	
	
}
80002108:	d8 02       	popm	pc
8000210a:	00 00       	add	r0,r0
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	ce 54       	brge	800020d8 <FD_brdcst_func>
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	6e 28       	ld.w	r8,r7[0x8]

80002114 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002114:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002116:	48 3c       	lddpc	r12,80002120 <EnOB_brdcst_func+0xc>
80002118:	f0 1f 00 03 	mcall	80002124 <EnOB_brdcst_func+0x10>
}
8000211c:	d8 02       	popm	pc
8000211e:	00 00       	add	r0,r0
80002120:	80 00       	ld.sh	r0,r0[0x0]
80002122:	ce 70       	breq	800020f0 <FD_reply_func+0x4>
80002124:	80 00       	ld.sh	r0,r0[0x0]
80002126:	6e 28       	ld.w	r8,r7[0x8]

80002128 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002128:	eb cd 40 80 	pushm	r7,lr
8000212c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000212e:	19 a9       	ld.ub	r9,r12[0x2]
80002130:	30 08       	mov	r8,0
80002132:	f0 09 18 00 	cp.b	r9,r8
80002136:	c1 91       	brne	80002168 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002138:	19 b8       	ld.ub	r8,r12[0x3]
8000213a:	30 19       	mov	r9,1
8000213c:	f2 08 18 00 	cp.b	r8,r9
80002140:	c0 61       	brne	8000214c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002142:	49 0c       	lddpc	r12,80002180 <EnOB_reply_func+0x58>
80002144:	f0 1f 00 10 	mcall	80002184 <EnOB_reply_func+0x5c>
80002148:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000214c:	58 08       	cp.w	r8,0
8000214e:	c0 61       	brne	8000215a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002150:	48 ec       	lddpc	r12,80002188 <EnOB_reply_func+0x60>
80002152:	f0 1f 00 0d 	mcall	80002184 <EnOB_reply_func+0x5c>
80002156:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000215a:	1a d8       	st.w	--sp,r8
8000215c:	48 cc       	lddpc	r12,8000218c <EnOB_reply_func+0x64>
8000215e:	f0 1f 00 0a 	mcall	80002184 <EnOB_reply_func+0x5c>
80002162:	2f fd       	sub	sp,-4
80002164:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002168:	48 ac       	lddpc	r12,80002190 <EnOB_reply_func+0x68>
8000216a:	f0 1f 00 07 	mcall	80002184 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000216e:	0f a8       	ld.ub	r8,r7[0x2]
80002170:	1a d8       	st.w	--sp,r8
80002172:	48 9c       	lddpc	r12,80002194 <EnOB_reply_func+0x6c>
80002174:	f0 1f 00 04 	mcall	80002184 <EnOB_reply_func+0x5c>
80002178:	2f fd       	sub	sp,-4
8000217a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	ce 88       	rjmp	80002352 <ShutDown_brdcst_func+0x12>
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	6e 28       	ld.w	r8,r7[0x8]
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	ce a0       	breq	8000215e <EnOB_reply_func+0x36>
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	ce b4       	brge	80002164 <EnOB_reply_func+0x3c>
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	ce cc       	rcall	8000236a <ShutDown_brdcst_func+0x2a>
80002194:	80 00       	ld.sh	r0,r0[0x0]
80002196:	ce e8       	rjmp	80002372 <DataSession_reply_func+0x2>

80002198 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002198:	eb cd 40 80 	pushm	r7,lr
8000219c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000219e:	19 a9       	ld.ub	r9,r12[0x2]
800021a0:	31 18       	mov	r8,17
800021a2:	f0 09 18 00 	cp.b	r9,r8
800021a6:	c0 91       	brne	800021b8 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021a8:	48 ac       	lddpc	r12,800021d0 <SingleDetection_brdcst_func+0x38>
800021aa:	f0 1f 00 0b 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
800021ae:	30 19       	mov	r9,1
800021b0:	48 a8       	lddpc	r8,800021d8 <SingleDetection_brdcst_func+0x40>
800021b2:	b0 89       	st.b	r8[0x0],r9
800021b4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
800021b8:	48 9c       	lddpc	r12,800021dc <SingleDetection_brdcst_func+0x44>
800021ba:	f0 1f 00 07 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
800021be:	0f a8       	ld.ub	r8,r7[0x2]
800021c0:	1a d8       	st.w	--sp,r8
800021c2:	48 8c       	lddpc	r12,800021e0 <SingleDetection_brdcst_func+0x48>
800021c4:	f0 1f 00 04 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
800021c8:	2f fd       	sub	sp,-4
800021ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800021ce:	00 00       	add	r0,r0
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	cf 00       	breq	800021b2 <SingleDetection_brdcst_func+0x1a>
800021d4:	80 00       	ld.sh	r0,r0[0x0]
800021d6:	6e 28       	ld.w	r8,r7[0x8]
800021d8:	00 00       	add	r0,r0
800021da:	00 04       	add	r4,r0
800021dc:	80 00       	ld.sh	r0,r0[0x0]
800021de:	cf 14       	brge	800021c0 <SingleDetection_brdcst_func+0x28>
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	cf 24       	brge	800021c6 <SingleDetection_brdcst_func+0x2e>

800021e4 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021e4:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021e6:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021ea:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021ec:	4a bc       	lddpc	r12,80002298 <ButtonConfig_brdcst_func+0xb4>
800021ee:	f0 1f 00 2c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021f2:	0f 88       	ld.ub	r8,r7[0x0]
800021f4:	1a d8       	st.w	--sp,r8
800021f6:	4a bc       	lddpc	r12,800022a0 <ButtonConfig_brdcst_func+0xbc>
800021f8:	f0 1f 00 29 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021fc:	1a d5       	st.w	--sp,r5
800021fe:	4a ac       	lddpc	r12,800022a4 <ButtonConfig_brdcst_func+0xc0>
80002200:	f0 1f 00 27 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002204:	0f a8       	ld.ub	r8,r7[0x2]
80002206:	1a d8       	st.w	--sp,r8
80002208:	4a 8c       	lddpc	r12,800022a8 <ButtonConfig_brdcst_func+0xc4>
8000220a:	f0 1f 00 25 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000220e:	2f dd       	sub	sp,-12
80002210:	58 05       	cp.w	r5,0
80002212:	c4 10       	breq	80002294 <ButtonConfig_brdcst_func+0xb0>
80002214:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002216:	4a 64       	lddpc	r4,800022ac <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002218:	4a 63       	lddpc	r3,800022b0 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000221a:	4a 72       	lddpc	r2,800022b4 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000221c:	4a 71       	lddpc	r1,800022b8 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000221e:	4a 80       	lddpc	r0,800022bc <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002220:	0f b9       	ld.ub	r9,r7[0x3]
80002222:	0f c8       	ld.ub	r8,r7[0x4]
80002224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002228:	1a d8       	st.w	--sp,r8
8000222a:	1a d6       	st.w	--sp,r6
8000222c:	08 9c       	mov	r12,r4
8000222e:	f0 1f 00 1c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002232:	0f d9       	ld.ub	r9,r7[0x5]
80002234:	0f e8       	ld.ub	r8,r7[0x6]
80002236:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000223a:	1a d8       	st.w	--sp,r8
8000223c:	1a d6       	st.w	--sp,r6
8000223e:	06 9c       	mov	r12,r3
80002240:	f0 1f 00 17 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002244:	0f f9       	ld.ub	r9,r7[0x7]
80002246:	ef 38 00 08 	ld.ub	r8,r7[8]
8000224a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000224e:	1a d8       	st.w	--sp,r8
80002250:	1a d6       	st.w	--sp,r6
80002252:	04 9c       	mov	r12,r2
80002254:	f0 1f 00 12 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002258:	ef 39 00 09 	ld.ub	r9,r7[9]
8000225c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002260:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002264:	1a d8       	st.w	--sp,r8
80002266:	1a d6       	st.w	--sp,r6
80002268:	02 9c       	mov	r12,r1
8000226a:	f0 1f 00 0d 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000226e:	2f 8d       	sub	sp,-32
80002270:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002274:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002278:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227c:	1a d8       	st.w	--sp,r8
8000227e:	1a d6       	st.w	--sp,r6
80002280:	00 9c       	mov	r12,r0
80002282:	f0 1f 00 07 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
80002286:	2f f6       	sub	r6,-1
80002288:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000228a:	2f ed       	sub	sp,-8
8000228c:	ec 05 18 00 	cp.b	r5,r6
80002290:	fe 9b ff c8 	brhi	80002220 <ButtonConfig_brdcst_func+0x3c>
80002294:	d8 32       	popm	r0-r7,pc
80002296:	00 00       	add	r0,r0
80002298:	80 00       	ld.sh	r0,r0[0x0]
8000229a:	cf 38       	rjmp	80002480 <TransmitControl_reply_func+0x8>
8000229c:	80 00       	ld.sh	r0,r0[0x0]
8000229e:	6e 28       	ld.w	r8,r7[0x8]
800022a0:	80 00       	ld.sh	r0,r0[0x0]
800022a2:	cf 58       	rjmp	8000248c <TransmitControl_reply_func+0x14>
800022a4:	80 00       	ld.sh	r0,r0[0x0]
800022a6:	cf 6c       	rcall	80002492 <TransmitControl_reply_func+0x1a>
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	cf 84       	brge	8000229a <ButtonConfig_brdcst_func+0xb6>
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	cf a4       	brge	800022a2 <ButtonConfig_brdcst_func+0xbe>
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	cf cc       	rcall	800024aa <TransmitControl_reply_func+0x32>
800022b4:	80 00       	ld.sh	r0,r0[0x0]
800022b6:	cf f4       	brge	800022b4 <ButtonConfig_brdcst_func+0xd0>
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	d0 18       	*unknown*
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	d0 40       	acall	0x4

800022c0 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022c0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022c4:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022c8:	0f 89       	ld.ub	r9,r7[0x0]
800022ca:	30 08       	mov	r8,0
800022cc:	f0 09 18 00 	cp.b	r9,r8
800022d0:	c0 c1       	brne	800022e8 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022d2:	48 9c       	lddpc	r12,800022f4 <ButtonConfig_reply_func+0x34>
800022d4:	f0 1f 00 09 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022d8:	0f 98       	ld.ub	r8,r7[0x1]
800022da:	1a d8       	st.w	--sp,r8
800022dc:	48 8c       	lddpc	r12,800022fc <ButtonConfig_reply_func+0x3c>
800022de:	f0 1f 00 07 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022e2:	2f fd       	sub	sp,-4
800022e4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022e8:	48 6c       	lddpc	r12,80002300 <ButtonConfig_reply_func+0x40>
800022ea:	f0 1f 00 04 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800022f2:	00 00       	add	r0,r0
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	d0 64       	*unknown*
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	6e 28       	ld.w	r8,r7[0x8]
800022fc:	80 00       	ld.sh	r0,r0[0x0]
800022fe:	cf 58       	rjmp	800024e8 <AudioRoutingControl_reply_func+0x10>
80002300:	80 00       	ld.sh	r0,r0[0x0]
80002302:	d0 7c       	*unknown*

80002304 <BatteryLevel_brdcst_func>:
	
}


void BatteryLevel_brdcst_func(xcmp_fragment_t * xcmp)
{
80002304:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	BatteryLevel_brdcast_t *ptr = (BatteryLevel_brdcast_t* )(xcmp->u8);
80002308:	f8 c7 ff fe 	sub	r7,r12,-2
	if(ptr->State == Battery_Okay)
8000230c:	0f 89       	ld.ub	r9,r7[0x0]
8000230e:	30 08       	mov	r8,0
80002310:	f0 09 18 00 	cp.b	r9,r8
80002314:	c0 51       	brne	8000231e <BatteryLevel_brdcst_func+0x1a>
		log("\n Battery Okay\n");
80002316:	48 7c       	lddpc	r12,80002330 <BatteryLevel_brdcst_func+0x2c>
80002318:	f0 1f 00 07 	mcall	80002334 <BatteryLevel_brdcst_func+0x30>
8000231c:	c0 48       	rjmp	80002324 <BatteryLevel_brdcst_func+0x20>
	else
		log("\n Battery Low !!!\n");
8000231e:	48 7c       	lddpc	r12,80002338 <BatteryLevel_brdcst_func+0x34>
80002320:	f0 1f 00 05 	mcall	80002334 <BatteryLevel_brdcst_func+0x30>
		
	//log("\n Battery charge: %X \n" , ptr->Charge);
	//log("\n Battery voltage: %X \n" , ptr->Voltage);
	
	Battery_Flag = ptr->State;
80002324:	0f 89       	ld.ub	r9,r7[0x0]
80002326:	48 68       	lddpc	r8,8000233c <BatteryLevel_brdcst_func+0x38>
80002328:	b0 89       	st.b	r8[0x0],r9

}
8000232a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000232e:	00 00       	add	r0,r0
80002330:	80 00       	ld.sh	r0,r0[0x0]
80002332:	d0 98       	*unknown*
80002334:	80 00       	ld.sh	r0,r0[0x0]
80002336:	6e 28       	ld.w	r8,r7[0x8]
80002338:	80 00       	ld.sh	r0,r0[0x0]
8000233a:	d0 a8       	*unknown*
8000233c:	00 00       	add	r0,r0
8000233e:	0a 41       	or	r1,r5

80002340 <ShutDown_brdcst_func>:
		log("ID:  %X \n", xcmp->u8[2]);
	}
	
}
void ShutDown_brdcst_func(xcmp_fragment_t * xcmp)
{
80002340:	d4 01       	pushm	lr
	if (xcmp->u8[0] == Shut_Down_Device)
80002342:	19 a8       	ld.ub	r8,r12[0x2]
80002344:	30 19       	mov	r9,1
80002346:	f2 08 18 00 	cp.b	r8,r9
8000234a:	c0 51       	brne	80002354 <ShutDown_brdcst_func+0x14>
	{
		log("Shut_Down_Device \n");
8000234c:	48 6c       	lddpc	r12,80002364 <ShutDown_brdcst_func+0x24>
8000234e:	f0 1f 00 07 	mcall	80002368 <ShutDown_brdcst_func+0x28>
80002352:	d8 02       	popm	pc
		
	}
	else if(xcmp->u8[0] == Reset_Device)
80002354:	30 29       	mov	r9,2
80002356:	f2 08 18 00 	cp.b	r8,r9
8000235a:	c0 41       	brne	80002362 <ShutDown_brdcst_func+0x22>
	{
		log("Reset_Device \n");
8000235c:	48 4c       	lddpc	r12,8000236c <ShutDown_brdcst_func+0x2c>
8000235e:	f0 1f 00 03 	mcall	80002368 <ShutDown_brdcst_func+0x28>
80002362:	d8 02       	popm	pc
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	d0 bc       	*unknown*
80002368:	80 00       	ld.sh	r0,r0[0x0]
8000236a:	6e 28       	ld.w	r8,r7[0x8]
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	d0 d0       	acall	0xd

80002370 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002370:	eb cd 40 80 	pushm	r7,lr
80002374:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002376:	19 a9       	ld.ub	r9,r12[0x2]
80002378:	30 08       	mov	r8,0
8000237a:	f0 09 18 00 	cp.b	r9,r8
8000237e:	c1 11       	brne	800023a0 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
80002380:	49 3c       	lddpc	r12,800023cc <DataSession_reply_func+0x5c>
80002382:	f0 1f 00 14 	mcall	800023d0 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
80002386:	0f b8       	ld.ub	r8,r7[0x3]
80002388:	1a d8       	st.w	--sp,r8
8000238a:	49 3c       	lddpc	r12,800023d4 <DataSession_reply_func+0x64>
8000238c:	f0 1f 00 11 	mcall	800023d0 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
80002390:	0f c8       	ld.ub	r8,r7[0x4]
80002392:	1a d8       	st.w	--sp,r8
80002394:	49 1c       	lddpc	r12,800023d8 <DataSession_reply_func+0x68>
80002396:	f0 1f 00 0f 	mcall	800023d0 <DataSession_reply_func+0x60>
8000239a:	2f ed       	sub	sp,-8
8000239c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
800023a0:	48 fc       	lddpc	r12,800023dc <DataSession_reply_func+0x6c>
800023a2:	f0 1f 00 0c 	mcall	800023d0 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
800023a6:	0f a8       	ld.ub	r8,r7[0x2]
800023a8:	1a d8       	st.w	--sp,r8
800023aa:	48 ec       	lddpc	r12,800023e0 <DataSession_reply_func+0x70>
800023ac:	f0 1f 00 09 	mcall	800023d0 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
800023b0:	0f b8       	ld.ub	r8,r7[0x3]
800023b2:	1a d8       	st.w	--sp,r8
800023b4:	48 cc       	lddpc	r12,800023e4 <DataSession_reply_func+0x74>
800023b6:	f0 1f 00 07 	mcall	800023d0 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
800023ba:	0f c8       	ld.ub	r8,r7[0x4]
800023bc:	1a d8       	st.w	--sp,r8
800023be:	48 bc       	lddpc	r12,800023e8 <DataSession_reply_func+0x78>
800023c0:	f0 1f 00 04 	mcall	800023d0 <DataSession_reply_func+0x60>
800023c4:	2f dd       	sub	sp,-12
800023c6:	e3 cd 80 80 	ldm	sp++,r7,pc
800023ca:	00 00       	add	r0,r0
800023cc:	80 00       	ld.sh	r0,r0[0x0]
800023ce:	d0 e0       	acall	0xe
800023d0:	80 00       	ld.sh	r0,r0[0x0]
800023d2:	6e 28       	ld.w	r8,r7[0x8]
800023d4:	80 00       	ld.sh	r0,r0[0x0]
800023d6:	d0 f0       	acall	0xf
800023d8:	80 00       	ld.sh	r0,r0[0x0]
800023da:	d0 fc       	*unknown*
800023dc:	80 00       	ld.sh	r0,r0[0x0]
800023de:	d1 08       	*unknown*
800023e0:	80 00       	ld.sh	r0,r0[0x0]
800023e2:	d1 18       	*unknown*
800023e4:	80 00       	ld.sh	r0,r0[0x0]
800023e6:	d1 28       	*unknown*
800023e8:	80 00       	ld.sh	r0,r0[0x0]
800023ea:	d1 34       	*unknown*

800023ec <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023ec:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
800023f0:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
800023f4:	0f 98       	ld.ub	r8,r7[0x1]
800023f6:	1a d8       	st.w	--sp,r8
800023f8:	48 bc       	lddpc	r12,80002424 <CallControl_brdcst_func+0x38>
800023fa:	f0 1f 00 0c 	mcall	80002428 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
800023fe:	2f fd       	sub	sp,-4
80002400:	0f 99       	ld.ub	r9,r7[0x1]
80002402:	30 38       	mov	r8,3
80002404:	f0 09 18 00 	cp.b	r9,r8
80002408:	c0 41       	brne	80002410 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
8000240a:	30 09       	mov	r9,0
8000240c:	48 88       	lddpc	r8,8000242c <CallControl_brdcst_func+0x40>
8000240e:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
80002410:	0f 99       	ld.ub	r9,r7[0x1]
80002412:	30 48       	mov	r8,4
80002414:	f0 09 18 00 	cp.b	r9,r8
80002418:	c0 41       	brne	80002420 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
8000241a:	30 19       	mov	r9,1
8000241c:	48 48       	lddpc	r8,8000242c <CallControl_brdcst_func+0x40>
8000241e:	b0 89       	st.b	r8[0x0],r9
80002420:	e3 cd 80 80 	ldm	sp++,r7,pc
80002424:	80 00       	ld.sh	r0,r0[0x0]
80002426:	d1 40       	acall	0x14
80002428:	80 00       	ld.sh	r0,r0[0x0]
8000242a:	6e 28       	ld.w	r8,r7[0x8]
8000242c:	00 00       	add	r0,r0
8000242e:	0a 47       	or	r7,r5

80002430 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002430:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002434:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002438:	0f 99       	ld.ub	r9,r7[0x1]
8000243a:	30 08       	mov	r8,0
8000243c:	f0 09 18 00 	cp.b	r9,r8
80002440:	c0 71       	brne	8000244e <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
80002442:	48 ac       	lddpc	r12,80002468 <TransmitControl_brdcst_func+0x38>
80002444:	f0 1f 00 0a 	mcall	8000246c <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
80002448:	30 09       	mov	r9,0
8000244a:	48 a8       	lddpc	r8,80002470 <TransmitControl_brdcst_func+0x40>
8000244c:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
8000244e:	0f 99       	ld.ub	r9,r7[0x1]
80002450:	30 18       	mov	r8,1
80002452:	f0 09 18 00 	cp.b	r9,r8
80002456:	c0 71       	brne	80002464 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
80002458:	48 7c       	lddpc	r12,80002474 <TransmitControl_brdcst_func+0x44>
8000245a:	f0 1f 00 05 	mcall	8000246c <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
8000245e:	30 19       	mov	r9,1
80002460:	48 48       	lddpc	r8,80002470 <TransmitControl_brdcst_func+0x40>
80002462:	b0 89       	st.b	r8[0x0],r9
80002464:	e3 cd 80 80 	ldm	sp++,r7,pc
80002468:	80 00       	ld.sh	r0,r0[0x0]
8000246a:	d1 58       	*unknown*
8000246c:	80 00       	ld.sh	r0,r0[0x0]
8000246e:	6e 28       	ld.w	r8,r7[0x8]
80002470:	00 00       	add	r0,r0
80002472:	0a 46       	or	r6,r5
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	d1 70       	acall	0x17

80002478 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002478:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
8000247c:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002480:	0f 89       	ld.ub	r9,r7[0x0]
80002482:	30 08       	mov	r8,0
80002484:	f0 09 18 00 	cp.b	r9,r8
80002488:	c1 61       	brne	800024b4 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000248a:	48 ec       	lddpc	r12,800024c0 <TransmitControl_reply_func+0x48>
8000248c:	f0 1f 00 0e 	mcall	800024c4 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002490:	0f 98       	ld.ub	r8,r7[0x1]
80002492:	1a d8       	st.w	--sp,r8
80002494:	48 dc       	lddpc	r12,800024c8 <TransmitControl_reply_func+0x50>
80002496:	f0 1f 00 0c 	mcall	800024c4 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000249a:	0f a8       	ld.ub	r8,r7[0x2]
8000249c:	1a d8       	st.w	--sp,r8
8000249e:	48 cc       	lddpc	r12,800024cc <TransmitControl_reply_func+0x54>
800024a0:	f0 1f 00 09 	mcall	800024c4 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
800024a4:	0f b8       	ld.ub	r8,r7[0x3]
800024a6:	1a d8       	st.w	--sp,r8
800024a8:	48 ac       	lddpc	r12,800024d0 <TransmitControl_reply_func+0x58>
800024aa:	f0 1f 00 07 	mcall	800024c4 <TransmitControl_reply_func+0x4c>
800024ae:	2f dd       	sub	sp,-12
800024b0:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
800024b4:	48 8c       	lddpc	r12,800024d4 <TransmitControl_reply_func+0x5c>
800024b6:	f0 1f 00 04 	mcall	800024c4 <TransmitControl_reply_func+0x4c>
800024ba:	e3 cd 80 80 	ldm	sp++,r7,pc
800024be:	00 00       	add	r0,r0
800024c0:	80 00       	ld.sh	r0,r0[0x0]
800024c2:	d1 84       	*unknown*
800024c4:	80 00       	ld.sh	r0,r0[0x0]
800024c6:	6e 28       	ld.w	r8,r7[0x8]
800024c8:	80 00       	ld.sh	r0,r0[0x0]
800024ca:	d1 a0       	acall	0x1a
800024cc:	80 00       	ld.sh	r0,r0[0x0]
800024ce:	d1 b4       	*unknown*
800024d0:	80 00       	ld.sh	r0,r0[0x0]
800024d2:	d1 d0       	acall	0x1d
800024d4:	80 00       	ld.sh	r0,r0[0x0]
800024d6:	d1 e0       	acall	0x1e

800024d8 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
800024d8:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800024da:	19 a9       	ld.ub	r9,r12[0x2]
800024dc:	30 08       	mov	r8,0
800024de:	f0 09 18 00 	cp.b	r9,r8
800024e2:	c0 51       	brne	800024ec <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
800024e4:	48 4c       	lddpc	r12,800024f4 <AudioRoutingControl_reply_func+0x1c>
800024e6:	f0 1f 00 05 	mcall	800024f8 <AudioRoutingControl_reply_func+0x20>
800024ea:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
800024ec:	48 4c       	lddpc	r12,800024fc <AudioRoutingControl_reply_func+0x24>
800024ee:	f0 1f 00 03 	mcall	800024f8 <AudioRoutingControl_reply_func+0x20>
800024f2:	d8 02       	popm	pc
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	d1 f8       	*unknown*
800024f8:	80 00       	ld.sh	r0,r0[0x0]
800024fa:	6e 28       	ld.w	r8,r7[0x8]
800024fc:	80 00       	ld.sh	r0,r0[0x0]
800024fe:	d2 08       	*unknown*

80002500 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002500:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002504:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80002508:	0f 89       	ld.ub	r9,r7[0x0]
8000250a:	30 08       	mov	r8,0
8000250c:	f0 09 18 00 	cp.b	r9,r8
80002510:	c1 b1       	brne	80002546 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002512:	0f b8       	ld.ub	r8,r7[0x3]
80002514:	31 09       	mov	r9,16
80002516:	f2 08 18 00 	cp.b	r8,r9
8000251a:	c0 f1       	brne	80002538 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
8000251c:	48 dc       	lddpc	r12,80002550 <Volume_reply_func+0x50>
8000251e:	f0 1f 00 0e 	mcall	80002554 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002522:	0f 99       	ld.ub	r9,r7[0x1]
80002524:	0f a8       	ld.ub	r8,r7[0x2]
80002526:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000252a:	1a d8       	st.w	--sp,r8
8000252c:	48 bc       	lddpc	r12,80002558 <Volume_reply_func+0x58>
8000252e:	f0 1f 00 0a 	mcall	80002554 <Volume_reply_func+0x54>
80002532:	2f fd       	sub	sp,-4
80002534:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
80002538:	1a d8       	st.w	--sp,r8
8000253a:	48 9c       	lddpc	r12,8000255c <Volume_reply_func+0x5c>
8000253c:	f0 1f 00 06 	mcall	80002554 <Volume_reply_func+0x54>
80002540:	2f fd       	sub	sp,-4
80002542:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
80002546:	48 7c       	lddpc	r12,80002560 <Volume_reply_func+0x60>
80002548:	f0 1f 00 03 	mcall	80002554 <Volume_reply_func+0x54>
8000254c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002550:	80 00       	ld.sh	r0,r0[0x0]
80002552:	d2 1c       	*unknown*
80002554:	80 00       	ld.sh	r0,r0[0x0]
80002556:	6e 28       	ld.w	r8,r7[0x8]
80002558:	80 00       	ld.sh	r0,r0[0x0]
8000255a:	d2 30       	acall	0x23
8000255c:	80 00       	ld.sh	r0,r0[0x0]
8000255e:	d2 4c       	*unknown*
80002560:	80 00       	ld.sh	r0,r0[0x0]
80002562:	d2 64       	*unknown*

80002564 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002564:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002566:	19 d9       	ld.ub	r9,r12[0x5]
80002568:	30 08       	mov	r8,0
8000256a:	f0 09 18 00 	cp.b	r9,r8
8000256e:	c0 81       	brne	8000257e <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002570:	10 99       	mov	r9,r8
80002572:	48 78       	lddpc	r8,8000258c <spk_brdcst_func+0x28>
80002574:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
80002576:	48 7c       	lddpc	r12,80002590 <spk_brdcst_func+0x2c>
80002578:	f0 1f 00 07 	mcall	80002594 <spk_brdcst_func+0x30>
8000257c:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
8000257e:	30 19       	mov	r9,1
80002580:	48 38       	lddpc	r8,8000258c <spk_brdcst_func+0x28>
80002582:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002584:	48 5c       	lddpc	r12,80002598 <spk_brdcst_func+0x34>
80002586:	f0 1f 00 04 	mcall	80002594 <spk_brdcst_func+0x30>
8000258a:	d8 02       	popm	pc
8000258c:	00 00       	add	r0,r0
8000258e:	0a 40       	or	r0,r5
80002590:	80 00       	ld.sh	r0,r0[0x0]
80002592:	d2 7c       	*unknown*
80002594:	80 00       	ld.sh	r0,r0[0x0]
80002596:	6e 28       	ld.w	r8,r7[0x8]
80002598:	80 00       	ld.sh	r0,r0[0x0]
8000259a:	d2 8c       	*unknown*

8000259c <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
8000259c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000259e:	19 a9       	ld.ub	r9,r12[0x2]
800025a0:	30 08       	mov	r8,0
800025a2:	f0 09 18 00 	cp.b	r9,r8
800025a6:	c0 f1       	brne	800025c4 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
800025a8:	19 e9       	ld.ub	r9,r12[0x6]
800025aa:	f0 09 18 00 	cp.b	r9,r8
800025ae:	c0 40       	breq	800025b6 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
800025b0:	30 19       	mov	r9,1
800025b2:	48 98       	lddpc	r8,800025d4 <spk_reply_func+0x38>
800025b4:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
800025b6:	19 e8       	ld.ub	r8,r12[0x6]
800025b8:	1a d8       	st.w	--sp,r8
800025ba:	48 8c       	lddpc	r12,800025d8 <spk_reply_func+0x3c>
800025bc:	f0 1f 00 08 	mcall	800025dc <spk_reply_func+0x40>
800025c0:	2f fd       	sub	sp,-4
800025c2:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
800025c4:	30 09       	mov	r9,0
800025c6:	48 48       	lddpc	r8,800025d4 <spk_reply_func+0x38>
800025c8:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
800025ca:	48 6c       	lddpc	r12,800025e0 <spk_reply_func+0x44>
800025cc:	f0 1f 00 04 	mcall	800025dc <spk_reply_func+0x40>
800025d0:	d8 02       	popm	pc
800025d2:	00 00       	add	r0,r0
800025d4:	00 00       	add	r0,r0
800025d6:	0a 40       	or	r0,r5
800025d8:	80 00       	ld.sh	r0,r0[0x0]
800025da:	d2 98       	*unknown*
800025dc:	80 00       	ld.sh	r0,r0[0x0]
800025de:	6e 28       	ld.w	r8,r7[0x8]
800025e0:	80 00       	ld.sh	r0,r0[0x0]
800025e2:	d2 a8       	*unknown*

800025e4 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
800025e4:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
800025e8:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
800025ec:	0f a9       	ld.ub	r9,r7[0x2]
800025ee:	30 08       	mov	r8,0
800025f0:	f0 09 18 00 	cp.b	r9,r8
800025f4:	c0 71       	brne	80002602 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
800025f6:	48 dc       	lddpc	r12,80002628 <mic_brdcst_func+0x44>
800025f8:	f0 1f 00 0d 	mcall	8000262c <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
800025fc:	30 09       	mov	r9,0
800025fe:	48 d8       	lddpc	r8,80002630 <mic_brdcst_func+0x4c>
80002600:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002602:	0f a9       	ld.ub	r9,r7[0x2]
80002604:	31 18       	mov	r8,17
80002606:	f0 09 18 00 	cp.b	r9,r8
8000260a:	c0 d1       	brne	80002624 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
8000260c:	48 ac       	lddpc	r12,80002634 <mic_brdcst_func+0x50>
8000260e:	f0 1f 00 08 	mcall	8000262c <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
80002612:	48 89       	lddpc	r9,80002630 <mic_brdcst_func+0x4c>
80002614:	30 18       	mov	r8,1
80002616:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
80002618:	13 89       	ld.ub	r9,r9[0x0]
8000261a:	f0 09 18 00 	cp.b	r9,r8
8000261e:	c0 31       	brne	80002624 <mic_brdcst_func+0x40>
80002620:	48 68       	lddpc	r8,80002638 <mic_brdcst_func+0x54>
80002622:	11 88       	ld.ub	r8,r8[0x0]
80002624:	e3 cd 80 80 	ldm	sp++,r7,pc
80002628:	80 00       	ld.sh	r0,r0[0x0]
8000262a:	d2 b4       	*unknown*
8000262c:	80 00       	ld.sh	r0,r0[0x0]
8000262e:	6e 28       	ld.w	r8,r7[0x8]
80002630:	00 00       	add	r0,r0
80002632:	0a 54       	eor	r4,r5
80002634:	80 00       	ld.sh	r0,r0[0x0]
80002636:	d2 c8       	*unknown*
80002638:	00 00       	add	r0,r0
8000263a:	0a 47       	or	r7,r5

8000263c <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
8000263c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002640:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002644:	49 ac       	lddpc	r12,800026ac <mic_reply_func+0x70>
80002646:	f0 1f 00 1b 	mcall	800026b0 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
8000264a:	0f 89       	ld.ub	r9,r7[0x0]
8000264c:	30 08       	mov	r8,0
8000264e:	f0 09 18 00 	cp.b	r9,r8
80002652:	c2 71       	brne	800026a0 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
80002654:	0f 98       	ld.ub	r8,r7[0x1]
80002656:	30 29       	mov	r9,2
80002658:	f2 08 18 00 	cp.b	r8,r9
8000265c:	c1 b1       	brne	80002692 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
8000265e:	49 6c       	lddpc	r12,800026b4 <mic_reply_func+0x78>
80002660:	f0 1f 00 14 	mcall	800026b0 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002664:	0f a8       	ld.ub	r8,r7[0x2]
80002666:	1a d8       	st.w	--sp,r8
80002668:	49 4c       	lddpc	r12,800026b8 <mic_reply_func+0x7c>
8000266a:	f0 1f 00 12 	mcall	800026b0 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
8000266e:	0f b8       	ld.ub	r8,r7[0x3]
80002670:	1a d8       	st.w	--sp,r8
80002672:	49 3c       	lddpc	r12,800026bc <mic_reply_func+0x80>
80002674:	f0 1f 00 0f 	mcall	800026b0 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002678:	0f c8       	ld.ub	r8,r7[0x4]
8000267a:	1a d8       	st.w	--sp,r8
8000267c:	49 1c       	lddpc	r12,800026c0 <mic_reply_func+0x84>
8000267e:	f0 1f 00 0d 	mcall	800026b0 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002682:	0f d8       	ld.ub	r8,r7[0x5]
80002684:	1a d8       	st.w	--sp,r8
80002686:	49 0c       	lddpc	r12,800026c4 <mic_reply_func+0x88>
80002688:	f0 1f 00 0a 	mcall	800026b0 <mic_reply_func+0x74>
8000268c:	2f cd       	sub	sp,-16
8000268e:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002692:	1a d8       	st.w	--sp,r8
80002694:	48 dc       	lddpc	r12,800026c8 <mic_reply_func+0x8c>
80002696:	f0 1f 00 07 	mcall	800026b0 <mic_reply_func+0x74>
8000269a:	2f fd       	sub	sp,-4
8000269c:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800026a0:	48 bc       	lddpc	r12,800026cc <mic_reply_func+0x90>
800026a2:	f0 1f 00 04 	mcall	800026b0 <mic_reply_func+0x74>
800026a6:	e3 cd 80 80 	ldm	sp++,r7,pc
800026aa:	00 00       	add	r0,r0
800026ac:	80 00       	ld.sh	r0,r0[0x0]
800026ae:	d2 dc       	*unknown*
800026b0:	80 00       	ld.sh	r0,r0[0x0]
800026b2:	6e 28       	ld.w	r8,r7[0x8]
800026b4:	80 00       	ld.sh	r0,r0[0x0]
800026b6:	d2 ec       	*unknown*
800026b8:	80 00       	ld.sh	r0,r0[0x0]
800026ba:	d3 00       	acall	0x30
800026bc:	80 00       	ld.sh	r0,r0[0x0]
800026be:	d3 14       	*unknown*
800026c0:	80 00       	ld.sh	r0,r0[0x0]
800026c2:	d3 30       	acall	0x33
800026c4:	80 00       	ld.sh	r0,r0[0x0]
800026c6:	d3 48       	*unknown*
800026c8:	80 00       	ld.sh	r0,r0[0x0]
800026ca:	d3 60       	acall	0x36
800026cc:	80 00       	ld.sh	r0,r0[0x0]
800026ce:	d3 78       	*unknown*

800026d0 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800026d0:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800026d4:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
800026d8:	48 bc       	lddpc	r12,80002704 <dcm_brdcst_func+0x34>
800026da:	f0 1f 00 0c 	mcall	80002708 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
800026de:	0f 88       	ld.ub	r8,r7[0x0]
800026e0:	1a d8       	st.w	--sp,r8
800026e2:	48 bc       	lddpc	r12,8000270c <dcm_brdcst_func+0x3c>
800026e4:	f0 1f 00 09 	mcall	80002708 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
800026e8:	0f a8       	ld.ub	r8,r7[0x2]
800026ea:	1a d8       	st.w	--sp,r8
800026ec:	48 9c       	lddpc	r12,80002710 <dcm_brdcst_func+0x40>
800026ee:	f0 1f 00 07 	mcall	80002708 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
800026f2:	0f 98       	ld.ub	r8,r7[0x1]
800026f4:	1a d8       	st.w	--sp,r8
800026f6:	48 8c       	lddpc	r12,80002714 <dcm_brdcst_func+0x44>
800026f8:	f0 1f 00 04 	mcall	80002708 <dcm_brdcst_func+0x38>
800026fc:	2f dd       	sub	sp,-12
	
	
}
800026fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002702:	00 00       	add	r0,r0
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	d3 88       	*unknown*
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	6e 28       	ld.w	r8,r7[0x8]
8000270c:	80 00       	ld.sh	r0,r0[0x0]
8000270e:	d3 9c       	*unknown*
80002710:	80 00       	ld.sh	r0,r0[0x0]
80002712:	d3 b0       	acall	0x3b
80002714:	80 00       	ld.sh	r0,r0[0x0]
80002716:	d3 c8       	*unknown*

80002718 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002718:	eb cd 40 80 	pushm	r7,lr
8000271c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000271e:	19 a9       	ld.ub	r9,r12[0x2]
80002720:	30 08       	mov	r8,0
80002722:	f0 09 18 00 	cp.b	r9,r8
80002726:	c1 b1       	brne	8000275c <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
80002728:	19 b8       	ld.ub	r8,r12[0x3]
8000272a:	30 19       	mov	r9,1
8000272c:	f2 08 18 00 	cp.b	r8,r9
80002730:	c0 51       	brne	8000273a <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
80002732:	48 ec       	lddpc	r12,80002768 <dcm_reply_func+0x50>
80002734:	f0 1f 00 0e 	mcall	8000276c <dcm_reply_func+0x54>
80002738:	c0 a8       	rjmp	8000274c <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
8000273a:	58 08       	cp.w	r8,0
8000273c:	c0 51       	brne	80002746 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
8000273e:	48 dc       	lddpc	r12,80002770 <dcm_reply_func+0x58>
80002740:	f0 1f 00 0b 	mcall	8000276c <dcm_reply_func+0x54>
80002744:	c0 48       	rjmp	8000274c <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
80002746:	48 cc       	lddpc	r12,80002774 <dcm_reply_func+0x5c>
80002748:	f0 1f 00 09 	mcall	8000276c <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
8000274c:	0f d8       	ld.ub	r8,r7[0x5]
8000274e:	1a d8       	st.w	--sp,r8
80002750:	48 ac       	lddpc	r12,80002778 <dcm_reply_func+0x60>
80002752:	f0 1f 00 07 	mcall	8000276c <dcm_reply_func+0x54>
80002756:	2f fd       	sub	sp,-4
80002758:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
8000275c:	48 8c       	lddpc	r12,8000277c <dcm_reply_func+0x64>
8000275e:	f0 1f 00 04 	mcall	8000276c <dcm_reply_func+0x54>
80002762:	e3 cd 80 80 	ldm	sp++,r7,pc
80002766:	00 00       	add	r0,r0
80002768:	80 00       	ld.sh	r0,r0[0x0]
8000276a:	d3 e4       	*unknown*
8000276c:	80 00       	ld.sh	r0,r0[0x0]
8000276e:	6e 28       	ld.w	r8,r7[0x8]
80002770:	80 00       	ld.sh	r0,r0[0x0]
80002772:	d3 f8       	*unknown*
80002774:	80 00       	ld.sh	r0,r0[0x0]
80002776:	d4 0c       	*unknown*
80002778:	80 00       	ld.sh	r0,r0[0x0]
8000277a:	d4 20       	acall	0x42
8000277c:	80 00       	ld.sh	r0,r0[0x0]
8000277e:	d4 2c       	*unknown*

80002780 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002780:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002782:	19 a9       	ld.ub	r9,r12[0x2]
80002784:	30 08       	mov	r8,0
80002786:	f0 09 18 00 	cp.b	r9,r8
8000278a:	c0 51       	brne	80002794 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
8000278c:	48 4c       	lddpc	r12,8000279c <ToneControl_reply_func+0x1c>
8000278e:	f0 1f 00 05 	mcall	800027a0 <ToneControl_reply_func+0x20>
80002792:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002794:	48 4c       	lddpc	r12,800027a4 <ToneControl_reply_func+0x24>
80002796:	f0 1f 00 03 	mcall	800027a0 <ToneControl_reply_func+0x20>
8000279a:	d8 02       	popm	pc
8000279c:	80 00       	ld.sh	r0,r0[0x0]
8000279e:	d4 38       	*unknown*
800027a0:	80 00       	ld.sh	r0,r0[0x0]
800027a2:	6e 28       	ld.w	r8,r7[0x8]
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	d4 44       	*unknown*

800027a8 <app_cfg>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
800027a8:	d4 31       	pushm	r0-r7,lr
800027aa:	20 1d       	sub	sp,4
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	Message_Protocol_t *m_buff = (Message_Protocol_t *) pvPortMalloc(sizeof(Message_Protocol_t));
800027ac:	31 ac       	mov	r12,26
800027ae:	f0 1f 00 37 	mcall	80002888 <app_cfg+0xe0>
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	static xgflash_status_t status = XG_ERROR;
	xLastWakeTime = xTaskGetTickCount();
800027b2:	f0 1f 00 37 	mcall	8000288c <app_cfg+0xe4>
800027b6:	4b 78       	lddpc	r8,80002890 <app_cfg+0xe8>
800027b8:	91 0c       	st.w	r8[0x0],r12
	
	/* 'Give' the semaphore to unblock the task. */
	 if( xBinarySemaphore != NULL ){
800027ba:	4b 78       	lddpc	r8,80002894 <app_cfg+0xec>
800027bc:	70 08       	ld.w	r8,r8[0x0]
800027be:	58 08       	cp.w	r8,0
800027c0:	c0 80       	breq	800027d0 <app_cfg+0x28>
		xSemaphoreGive(xBinarySemaphore);
800027c2:	4b 58       	lddpc	r8,80002894 <app_cfg+0xec>
800027c4:	70 0c       	ld.w	r12,r8[0x0]
800027c6:	30 09       	mov	r9,0
800027c8:	12 9a       	mov	r10,r9
800027ca:	12 9b       	mov	r11,r9
800027cc:	f0 1f 00 33 	mcall	80002898 <app_cfg+0xf0>
	 }
		
	for(;;)
	{
		switch(OB_State)
800027d0:	4b 36       	lddpc	r6,8000289c <app_cfg+0xf4>
			

					//if (xSemaphoreTake(xBinarySemaphore, (1000*2) / portTICK_RATE_MS) == pdPASS)
					{
					
						if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
800027d2:	4b 41       	lddpc	r1,800028a0 <app_cfg+0xf8>
800027d4:	30 05       	mov	r5,0
800027d6:	e0 67 0f a0 	mov	r7,4000
							
								log("receive Okay!\n");		
								do 
								{
									log("wait message Ack\n");	
								} while (xSemaphoreTake(xBinarySemaphore, (5000*2) / portTICK_RATE_MS) == pdFALSE);
800027da:	4a f3       	lddpc	r3,80002894 <app_cfg+0xec>
							if(data_ptr!=NULL){//resend message
							
								log("receive Okay!\n");		
								do 
								{
									log("wait message Ack\n");	
800027dc:	4b 22       	lddpc	r2,800028a4 <app_cfg+0xfc>
		xSemaphoreGive(xBinarySemaphore);
	 }
		
	for(;;)
	{
		switch(OB_State)
800027de:	6c 08       	ld.w	r8,r6[0x0]
800027e0:	58 08       	cp.w	r8,0
800027e2:	c0 40       	breq	800027ea <app_cfg+0x42>
800027e4:	58 38       	cp.w	r8,3
800027e6:	c4 b1       	brne	8000287c <app_cfg+0xd4>
800027e8:	c1 f8       	rjmp	80002826 <app_cfg+0x7e>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027ea:	4b 08       	lddpc	r8,800028a8 <app_cfg+0x100>
800027ec:	70 08       	ld.w	r8,r8[0x0]
800027ee:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800027f2:	58 38       	cp.w	r8,3
800027f4:	c1 21       	brne	80002818 <app_cfg+0x70>
800027f6:	4a e8       	lddpc	r8,800028ac <app_cfg+0x104>
800027f8:	11 88       	ld.ub	r8,r8[0x0]
800027fa:	58 08       	cp.w	r8,0
800027fc:	c0 e1       	brne	80002818 <app_cfg+0x70>
				{
					connect_flag=1;
800027fe:	30 19       	mov	r9,1
80002800:	4a b8       	lddpc	r8,800028ac <app_cfg+0x104>
80002802:	b0 89       	st.b	r8[0x0],r9
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002804:	30 cb       	mov	r11,12
80002806:	30 1c       	mov	r12,1
80002808:	f0 1f 00 2a 	mcall	800028b0 <app_cfg+0x108>
					OB_State = OB_WAITINGAPPTASK;
8000280c:	30 38       	mov	r8,3
8000280e:	8d 08       	st.w	r6[0x0],r8
					log("connect OB okay!\n");
80002810:	4a 9c       	lddpc	r12,800028b4 <app_cfg+0x10c>
80002812:	f0 1f 00 2a 	mcall	800028b8 <app_cfg+0x110>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002816:	c3 38       	rjmp	8000287c <app_cfg+0xd4>
					OB_State = OB_WAITINGAPPTASK;
					log("connect OB okay!\n");
				}
				else
				{
					nop();
80002818:	d7 03       	nop
					nop();
8000281a:	d7 03       	nop
					nop();
8000281c:	d7 03       	nop
					log("connecting...\n");
8000281e:	4a 8c       	lddpc	r12,800028bc <app_cfg+0x114>
80002820:	f0 1f 00 26 	mcall	800028b8 <app_cfg+0x110>
80002824:	c2 c8       	rjmp	8000287c <app_cfg+0xd4>
			

					//if (xSemaphoreTake(xBinarySemaphore, (1000*2) / portTICK_RATE_MS) == pdPASS)
					{
					
						if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
80002826:	62 0c       	ld.w	r12,r1[0x0]
80002828:	0a 99       	mov	r9,r5
8000282a:	0e 9a       	mov	r10,r7
8000282c:	1a 9b       	mov	r11,sp
8000282e:	f0 1f 00 25 	mcall	800028c0 <app_cfg+0x118>
80002832:	58 1c       	cp.w	r12,1
80002834:	c2 01       	brne	80002874 <app_cfg+0xcc>
						{
							if(data_ptr!=NULL){//resend message
80002836:	40 08       	lddsp	r8,sp[0x0]
80002838:	58 08       	cp.w	r8,0
8000283a:	c1 d0       	breq	80002874 <app_cfg+0xcc>
							
								log("receive Okay!\n");		
8000283c:	4a 2c       	lddpc	r12,800028c4 <app_cfg+0x11c>
8000283e:	f0 1f 00 1f 	mcall	800028b8 <app_cfg+0x110>
								do 
								{
									log("wait message Ack\n");	
								} while (xSemaphoreTake(xBinarySemaphore, (5000*2) / portTICK_RATE_MS) == pdFALSE);
80002842:	e0 64 27 10 	mov	r4,10000
							if(data_ptr!=NULL){//resend message
							
								log("receive Okay!\n");		
								do 
								{
									log("wait message Ack\n");	
80002846:	04 9c       	mov	r12,r2
80002848:	f0 1f 00 1c 	mcall	800028b8 <app_cfg+0x110>
								} while (xSemaphoreTake(xBinarySemaphore, (5000*2) / portTICK_RATE_MS) == pdFALSE);
8000284c:	66 0c       	ld.w	r12,r3[0x0]
8000284e:	0a 99       	mov	r9,r5
80002850:	08 9a       	mov	r10,r4
80002852:	0a 9b       	mov	r11,r5
80002854:	f0 1f 00 1b 	mcall	800028c0 <app_cfg+0x118>
80002858:	cf 70       	breq	80002846 <app_cfg+0x9e>
												
								xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);								
8000285a:	36 4a       	mov	r10,100
8000285c:	31 ab       	mov	r11,26
8000285e:	40 0c       	lddsp	r12,sp[0x0]
80002860:	f0 1f 00 1a 	mcall	800028c8 <app_cfg+0x120>
								set_message_store(data_ptr);
80002864:	49 a8       	lddpc	r8,800028cc <app_cfg+0x124>
80002866:	70 0c       	ld.w	r12,r8[0x0]
80002868:	40 0b       	lddsp	r11,sp[0x0]
8000286a:	f0 1f 00 1a 	mcall	800028d0 <app_cfg+0x128>
								log("send message\n");
8000286e:	49 ac       	lddpc	r12,800028d4 <app_cfg+0x12c>
80002870:	f0 1f 00 12 	mcall	800028b8 <app_cfg+0x110>
							}
						
						}
					}
										
					nop();
80002874:	d7 03       	nop
					log("app task run!\n");
80002876:	49 9c       	lddpc	r12,800028d8 <app_cfg+0x130>
80002878:	f0 1f 00 10 	mcall	800028b8 <app_cfg+0x110>
			break;
			default:
			break;
				
		} //End of switch on OB_State.
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
8000287c:	0e 9b       	mov	r11,r7
8000287e:	48 5c       	lddpc	r12,80002890 <app_cfg+0xe8>
80002880:	f0 1f 00 17 	mcall	800028dc <app_cfg+0x134>
	}
80002884:	ca db       	rjmp	800027de <app_cfg+0x36>
80002886:	00 00       	add	r0,r0
80002888:	80 00       	ld.sh	r0,r0[0x0]
8000288a:	5e f4       	retal	r4
8000288c:	80 00       	ld.sh	r0,r0[0x0]
8000288e:	67 54       	ld.w	r4,r3[0x54]
80002890:	00 00       	add	r0,r0
80002892:	0a 58       	eor	r8,r5
80002894:	00 00       	add	r0,r0
80002896:	0b 74       	ld.ub	r4,--r5
80002898:	80 00       	ld.sh	r0,r0[0x0]
8000289a:	62 48       	ld.w	r8,r1[0x10]
8000289c:	00 00       	add	r0,r0
8000289e:	0a 50       	eor	r0,r5
800028a0:	00 00       	add	r0,r0
800028a2:	0b 6c       	ld.uh	r12,--r5
800028a4:	80 00       	ld.sh	r0,r0[0x0]
800028a6:	d4 84       	*unknown*
800028a8:	00 00       	add	r0,r0
800028aa:	0d 98       	ld.ub	r8,r6[0x1]
800028ac:	00 00       	add	r0,r0
800028ae:	0a 42       	or	r2,r5
800028b0:	80 00       	ld.sh	r0,r0[0x0]
800028b2:	3f 88       	mov	r8,-8
800028b4:	80 00       	ld.sh	r0,r0[0x0]
800028b6:	d4 50       	acall	0x45
800028b8:	80 00       	ld.sh	r0,r0[0x0]
800028ba:	6e 28       	ld.w	r8,r7[0x8]
800028bc:	80 00       	ld.sh	r0,r0[0x0]
800028be:	d4 64       	*unknown*
800028c0:	80 00       	ld.sh	r0,r0[0x0]
800028c2:	60 3c       	ld.w	r12,r0[0xc]
800028c4:	80 00       	ld.sh	r0,r0[0x0]
800028c6:	d4 74       	*unknown*
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	3e 50       	mov	r0,-27
800028cc:	00 00       	add	r0,r0
800028ce:	0b 70       	ld.ub	r0,--r5
800028d0:	80 00       	ld.sh	r0,r0[0x0]
800028d2:	2b 24       	sub	r4,-78
800028d4:	80 00       	ld.sh	r0,r0[0x0]
800028d6:	d4 98       	*unknown*
800028d8:	80 00       	ld.sh	r0,r0[0x0]
800028da:	d4 a8       	*unknown*
800028dc:	80 00       	ld.sh	r0,r0[0x0]
800028de:	69 04       	ld.w	r4,r4[0x40]

800028e0 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800028e0:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800028e4:	19 c7       	ld.ub	r7,r12[0x4]
800028e6:	19 d8       	ld.ub	r8,r12[0x5]
800028e8:	f1 e7 10 87 	or	r7,r8,r7<<0x8
800028ec:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
800028ee:	48 dc       	lddpc	r12,80002920 <Phyuserinput_brdcst_func+0x40>
800028f0:	f0 1f 00 0d 	mcall	80002924 <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
800028f4:	36 08       	mov	r8,96
800028f6:	f0 07 19 00 	cp.h	r7,r8
800028fa:	c1 11       	brne	8000291c <Phyuserinput_brdcst_func+0x3c>
800028fc:	48 b8       	lddpc	r8,80002928 <Phyuserinput_brdcst_func+0x48>
800028fe:	11 89       	ld.ub	r9,r8[0x0]
80002900:	30 18       	mov	r8,1
80002902:	f0 09 18 00 	cp.b	r9,r8
80002906:	c0 b1       	brne	8000291c <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, ACK_Received_Tone);//set tone to indicate the scan!!!
80002908:	31 4b       	mov	r11,20
8000290a:	30 1c       	mov	r12,1
8000290c:	f0 1f 00 08 	mcall	8000292c <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(200*2 / portTICK_RATE_MS);//延迟200ms
80002910:	e0 6c 01 90 	mov	r12,400
80002914:	f0 1f 00 07 	mcall	80002930 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		//rfid_sendID_message();//send message	
		scan_rfid_save_message();//scan and save message	
80002918:	f0 1f 00 07 	mcall	80002934 <Phyuserinput_brdcst_func+0x54>
8000291c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002920:	80 00       	ld.sh	r0,r0[0x0]
80002922:	d4 b8       	*unknown*
80002924:	80 00       	ld.sh	r0,r0[0x0]
80002926:	6e 28       	ld.w	r8,r7[0x8]
80002928:	00 00       	add	r0,r0
8000292a:	0a 42       	or	r2,r5
8000292c:	80 00       	ld.sh	r0,r0[0x0]
8000292e:	3f 88       	mov	r8,-8
80002930:	80 00       	ld.sh	r0,r0[0x0]
80002932:	68 bc       	ld.w	r12,r4[0x2c]
80002934:	80 00       	ld.sh	r0,r0[0x0]
80002936:	4f ec       	lddpc	r12,80002b2c <set_idle_store+0x8>

80002938 <DataSession_brdcst_func>:
	Battery_Flag = ptr->State;

}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002938:	d4 21       	pushm	r4-r7,lr
8000293a:	20 8d       	sub	sp,32
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
8000293c:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
80002940:	0d 88       	ld.ub	r8,r6[0x0]
80002942:	32 49       	mov	r9,36
80002944:	f2 08 18 00 	cp.b	r8,r9
80002948:	c2 91       	brne	8000299a <DataSession_brdcst_func+0x62>
	{
		
		log("\n\r CSBK_RX OK \n\r");
8000294a:	4b 3c       	lddpc	r12,80002a14 <DataSession_brdcst_func+0xdc>
8000294c:	f0 1f 00 33 	mcall	80002a18 <DataSession_brdcst_func+0xe0>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002950:	0d a5       	ld.ub	r5,r6[0x2]
80002952:	0d b8       	ld.ub	r8,r6[0x3]
80002954:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002958:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
8000295a:	0d 98       	ld.ub	r8,r6[0x1]
8000295c:	1a d8       	st.w	--sp,r8
8000295e:	4b 0c       	lddpc	r12,80002a1c <DataSession_brdcst_func+0xe4>
80002960:	f0 1f 00 2e 	mcall	80002a18 <DataSession_brdcst_func+0xe0>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002964:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002968:	1a d8       	st.w	--sp,r8
8000296a:	4a ec       	lddpc	r12,80002a20 <DataSession_brdcst_func+0xe8>
8000296c:	f0 1f 00 2b 	mcall	80002a18 <DataSession_brdcst_func+0xe0>
		for(i=0; i<data_length; i++)
80002970:	2f ed       	sub	sp,-8
80002972:	58 05       	cp.w	r5,0
80002974:	c4 e0       	breq	80002a10 <DataSession_brdcst_func+0xd8>
80002976:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002978:	4a b4       	lddpc	r4,80002a24 <DataSession_brdcst_func+0xec>
8000297a:	ec 07 00 08 	add	r8,r6,r7
8000297e:	11 c8       	ld.ub	r8,r8[0x4]
80002980:	1a d8       	st.w	--sp,r8
80002982:	1a d7       	st.w	--sp,r7
80002984:	08 9c       	mov	r12,r4
80002986:	f0 1f 00 25 	mcall	80002a18 <DataSession_brdcst_func+0xe0>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
8000298a:	2f f7       	sub	r7,-1
8000298c:	5c 57       	castu.b	r7
8000298e:	2f ed       	sub	sp,-8
80002990:	ee 05 19 00 	cp.h	r5,r7
80002994:	fe 9b ff f3 	brhi	8000297a <DataSession_brdcst_func+0x42>
80002998:	c3 c8       	rjmp	80002a10 <DataSession_brdcst_func+0xd8>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
8000299a:	1a d8       	st.w	--sp,r8
8000299c:	4a 3c       	lddpc	r12,80002a28 <DataSession_brdcst_func+0xf0>
8000299e:	f0 1f 00 1f 	mcall	80002a18 <DataSession_brdcst_func+0xe0>
		if (ptr->State == DATA_SESSION_TX_Suc)
800029a2:	0d 88       	ld.ub	r8,r6[0x0]
800029a4:	2f fd       	sub	sp,-4
800029a6:	30 39       	mov	r9,3
800029a8:	f2 08 18 00 	cp.b	r8,r9
800029ac:	c0 91       	brne	800029be <DataSession_brdcst_func+0x86>
		{
			log("data transmit success\n");
800029ae:	4a 0c       	lddpc	r12,80002a2c <DataSession_brdcst_func+0xf4>
800029b0:	f0 1f 00 1a 	mcall	80002a18 <DataSession_brdcst_func+0xe0>
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
800029b4:	30 cb       	mov	r11,12
800029b6:	30 1c       	mov	r12,1
800029b8:	f0 1f 00 1e 	mcall	80002a30 <DataSession_brdcst_func+0xf8>
800029bc:	c2 38       	rjmp	80002a02 <DataSession_brdcst_func+0xca>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
800029be:	30 49       	mov	r9,4
800029c0:	f2 08 18 00 	cp.b	r8,r9
800029c4:	c1 f1       	brne	80002a02 <DataSession_brdcst_func+0xca>
		{
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
800029c6:	31 aa       	mov	r10,26
800029c8:	ec cb ff fc 	sub	r11,r6,-4
800029cc:	fa cc ff fe 	sub	r12,sp,-2
800029d0:	f0 1f 00 19 	mcall	80002a34 <DataSession_brdcst_func+0xfc>

			Message_Protocol_t * myptr = get_message_store();	
800029d4:	49 98       	lddpc	r8,80002a38 <DataSession_brdcst_func+0x100>
800029d6:	70 0c       	ld.w	r12,r8[0x0]
800029d8:	f0 1f 00 19 	mcall	80002a3c <DataSession_brdcst_func+0x104>
800029dc:	50 7c       	stdsp	sp[0x1c],r12
			if(NULL != myptr)
800029de:	c0 f0       	breq	800029fc <DataSession_brdcst_func+0xc4>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
800029e0:	31 aa       	mov	r10,26
800029e2:	fa cb ff fe 	sub	r11,sp,-2
800029e6:	f0 1f 00 14 	mcall	80002a34 <DataSession_brdcst_func+0xfc>
				xQueueSend(xg_resend_queue, &myptr, 0);
800029ea:	49 68       	lddpc	r8,80002a40 <DataSession_brdcst_func+0x108>
800029ec:	70 0c       	ld.w	r12,r8[0x0]
800029ee:	30 09       	mov	r9,0
800029f0:	12 9a       	mov	r10,r9
800029f2:	fa cb ff e4 	sub	r11,sp,-28
800029f6:	f0 1f 00 14 	mcall	80002a44 <DataSession_brdcst_func+0x10c>
800029fa:	c0 48       	rjmp	80002a02 <DataSession_brdcst_func+0xca>
			}
			else
			{
				log("myptr: err\n\r" );
800029fc:	49 3c       	lddpc	r12,80002a48 <DataSession_brdcst_func+0x110>
800029fe:	f0 1f 00 07 	mcall	80002a18 <DataSession_brdcst_func+0xe0>
			}
			//xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate send-failure!!!
		}
		
		/* 'Give' the semaphore to unblock the task. */
		xSemaphoreGive(xBinarySemaphore);
80002a02:	49 38       	lddpc	r8,80002a4c <DataSession_brdcst_func+0x114>
80002a04:	70 0c       	ld.w	r12,r8[0x0]
80002a06:	30 09       	mov	r9,0
80002a08:	12 9a       	mov	r10,r9
80002a0a:	12 9b       	mov	r11,r9
80002a0c:	f0 1f 00 0e 	mcall	80002a44 <DataSession_brdcst_func+0x10c>
				//
		//}
		
	}
	
}
80002a10:	2f 8d       	sub	sp,-32
80002a12:	d8 22       	popm	r4-r7,pc
80002a14:	80 00       	ld.sh	r0,r0[0x0]
80002a16:	d4 d8       	*unknown*
80002a18:	80 00       	ld.sh	r0,r0[0x0]
80002a1a:	6e 28       	ld.w	r8,r7[0x8]
80002a1c:	80 00       	ld.sh	r0,r0[0x0]
80002a1e:	d4 ec       	*unknown*
80002a20:	80 00       	ld.sh	r0,r0[0x0]
80002a22:	d5 04       	*unknown*
80002a24:	80 00       	ld.sh	r0,r0[0x0]
80002a26:	d5 20       	acall	0x52
80002a28:	80 00       	ld.sh	r0,r0[0x0]
80002a2a:	d5 38       	*unknown*
80002a2c:	80 00       	ld.sh	r0,r0[0x0]
80002a2e:	d5 44       	*unknown*
80002a30:	80 00       	ld.sh	r0,r0[0x0]
80002a32:	3f 88       	mov	r8,-8
80002a34:	80 00       	ld.sh	r0,r0[0x0]
80002a36:	76 a4       	ld.w	r4,r11[0x28]
80002a38:	00 00       	add	r0,r0
80002a3a:	0b 70       	ld.ub	r0,--r5
80002a3c:	80 00       	ld.sh	r0,r0[0x0]
80002a3e:	2c d0       	sub	r0,-51
80002a40:	00 00       	add	r0,r0
80002a42:	0b 6c       	ld.uh	r12,--r5
80002a44:	80 00       	ld.sh	r0,r0[0x0]
80002a46:	62 48       	ld.w	r8,r1[0x10]
80002a48:	80 00       	ld.sh	r0,r0[0x0]
80002a4a:	d5 5c       	*unknown*
80002a4c:	00 00       	add	r0,r0
80002a4e:	0b 74       	ld.ub	r4,--r5

80002a50 <DeviceInitializationStatus_brdcst_func>:


//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002a50:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002a52:	19 e8       	ld.ub	r8,r12[0x6]
80002a54:	30 19       	mov	r9,1
80002a56:	f2 08 18 00 	cp.b	r8,r9
80002a5a:	c0 61       	brne	80002a66 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002a5c:	48 98       	lddpc	r8,80002a80 <DeviceInitializationStatus_brdcst_func+0x30>
80002a5e:	70 09       	ld.w	r9,r8[0x0]
80002a60:	a1 a9       	sbr	r9,0x0
80002a62:	91 09       	st.w	r8[0x0],r9
80002a64:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
80002a66:	30 29       	mov	r9,2
80002a68:	f2 08 18 00 	cp.b	r8,r9
80002a6c:	c0 80       	breq	80002a7c <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002a6e:	48 58       	lddpc	r8,80002a80 <DeviceInitializationStatus_brdcst_func+0x30>
80002a70:	70 09       	ld.w	r9,r8[0x0]
80002a72:	e0 19 ff fc 	andl	r9,0xfffc
80002a76:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002a78:	f0 1f 00 03 	mcall	80002a84 <DeviceInitializationStatus_brdcst_func+0x34>
80002a7c:	d8 02       	popm	pc
80002a7e:	00 00       	add	r0,r0
80002a80:	00 00       	add	r0,r0
80002a82:	0d 98       	ld.ub	r8,r6[0x1]
80002a84:	80 00       	ld.sh	r0,r0[0x0]
80002a86:	3e dc       	mov	r12,-19

80002a88 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002a88:	20 1c       	sub	r12,1
80002a8a:	5c 5c       	castu.b	r12
80002a8c:	31 18       	mov	r8,17
80002a8e:	f0 0c 18 00 	cp.b	r12,r8
80002a92:	e0 88 00 03 	brls	80002a98 <CalculateBurst+0x10>
80002a96:	5e fd       	retal	0
80002a98:	48 28       	lddpc	r8,80002aa0 <CalculateBurst+0x18>
80002a9a:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002a9e:	5e fc       	retal	r12
80002aa0:	80 00       	ld.sh	r0,r0[0x0]
80002aa2:	d5 6c       	*unknown*

80002aa4 <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
80002aa4:	48 38       	lddpc	r8,80002ab0 <payload_init+0xc>
80002aa6:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002aa8:	48 38       	lddpc	r8,80002ab4 <payload_init+0x10>
80002aaa:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
80002aac:	5e fc       	retal	r12
80002aae:	00 00       	add	r0,r0
80002ab0:	00 00       	add	r0,r0
80002ab2:	0a 64       	and	r4,r5
80002ab4:	00 00       	add	r0,r0
80002ab6:	0a 68       	and	r8,r5

80002ab8 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002ab8:	d4 01       	pushm	lr
80002aba:	20 2d       	sub	sp,8
80002abc:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002abe:	30 09       	mov	r9,0
80002ac0:	fa ca ff f8 	sub	r10,sp,-8
80002ac4:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002ac6:	1a 9b       	mov	r11,sp
80002ac8:	f0 1f 00 02 	mcall	80002ad0 <set_idle_store_isr+0x18>
}
80002acc:	2f ed       	sub	sp,-8
80002ace:	d8 02       	popm	pc
80002ad0:	80 00       	ld.sh	r0,r0[0x0]
80002ad2:	61 f8       	ld.w	r8,r0[0x7c]

80002ad4 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002ad4:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
80002ad6:	48 48       	lddpc	r8,80002ae4 <payload_rx+0x10>
80002ad8:	70 08       	ld.w	r8,r8[0x0]
80002ada:	18 9b       	mov	r11,r12
80002adc:	10 9c       	mov	r12,r8
80002ade:	f0 1f 00 03 	mcall	80002ae8 <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
80002ae2:	d8 02       	popm	pc
80002ae4:	00 00       	add	r0,r0
80002ae6:	0a a0       	st.w	r5++,r0
80002ae8:	80 00       	ld.sh	r0,r0[0x0]
80002aea:	2a b8       	sub	r8,-85

80002aec <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002aec:	d4 01       	pushm	lr
80002aee:	20 2d       	sub	sp,8
80002af0:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002af2:	58 0c       	cp.w	r12,0
80002af4:	c1 10       	breq	80002b16 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002af6:	30 08       	mov	r8,0
80002af8:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002afa:	98 88       	ld.uh	r8,r12[0x0]
80002afc:	e2 18 f0 00 	andl	r8,0xf000,COH
80002b00:	e0 48 40 00 	cp.w	r8,16384
80002b04:	c0 91       	brne	80002b16 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002b06:	48 68       	lddpc	r8,80002b1c <phy_rx+0x30>
80002b08:	70 0c       	ld.w	r12,r8[0x0]
80002b0a:	30 09       	mov	r9,0
80002b0c:	fa ca ff fc 	sub	r10,sp,-4
80002b10:	1a 9b       	mov	r11,sp
80002b12:	f0 1f 00 04 	mcall	80002b20 <phy_rx+0x34>
		}	

    }
		
 
}
80002b16:	2f ed       	sub	sp,-8
80002b18:	d8 02       	popm	pc
80002b1a:	00 00       	add	r0,r0
80002b1c:	00 00       	add	r0,r0
80002b1e:	0a ac       	st.w	r5++,r12
80002b20:	80 00       	ld.sh	r0,r0[0x0]
80002b22:	61 f8       	ld.w	r8,r0[0x7c]

80002b24 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002b24:	eb cd 40 80 	pushm	r7,lr
80002b28:	20 1d       	sub	sp,4
80002b2a:	fa c7 ff fc 	sub	r7,sp,-4
80002b2e:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002b30:	30 09       	mov	r9,0
80002b32:	12 9a       	mov	r10,r9
80002b34:	1a 9b       	mov	r11,sp
80002b36:	f0 1f 00 03 	mcall	80002b40 <set_idle_store+0x1c>
}
80002b3a:	2f fd       	sub	sp,-4
80002b3c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002b40:	80 00       	ld.sh	r0,r0[0x0]
80002b42:	62 48       	ld.w	r8,r1[0x10]

80002b44 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002b44:	d4 01       	pushm	lr
80002b46:	20 1d       	sub	sp,4
80002b48:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002b4a:	98 88       	ld.uh	r8,r12[0x0]
80002b4c:	e2 18 f0 00 	andl	r8,0xf000,COH
80002b50:	e0 48 40 00 	cp.w	r8,16384
80002b54:	c0 d1       	brne	80002b6e <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002b56:	49 08       	lddpc	r8,80002b94 <phy_tx+0x50>
80002b58:	70 08       	ld.w	r8,r8[0x0]
80002b5a:	58 08       	cp.w	r8,0
80002b5c:	c1 a0       	breq	80002b90 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002b5e:	48 e8       	lddpc	r8,80002b94 <phy_tx+0x50>
80002b60:	70 0c       	ld.w	r12,r8[0x0]
80002b62:	30 09       	mov	r9,0
80002b64:	12 9a       	mov	r10,r9
80002b66:	1a 9b       	mov	r11,sp
80002b68:	f0 1f 00 0c 	mcall	80002b98 <phy_tx+0x54>
80002b6c:	c1 28       	rjmp	80002b90 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002b6e:	e0 48 10 00 	cp.w	r8,4096
80002b72:	5f 0a       	sreq	r10
80002b74:	e0 48 20 00 	cp.w	r8,8192
80002b78:	5f 09       	sreq	r9
80002b7a:	f5 e9 10 09 	or	r9,r10,r9
80002b7e:	c0 71       	brne	80002b8c <phy_tx+0x48>
80002b80:	e0 48 50 00 	cp.w	r8,20480
80002b84:	c0 40       	breq	80002b8c <phy_tx+0x48>
80002b86:	e0 48 60 00 	cp.w	r8,24576
80002b8a:	c0 31       	brne	80002b90 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002b8c:	48 48       	lddpc	r8,80002b9c <phy_tx+0x58>
80002b8e:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002b90:	2f fd       	sub	sp,-4
80002b92:	d8 02       	popm	pc
80002b94:	00 00       	add	r0,r0
80002b96:	0a cc       	st.b	r5++,r12
80002b98:	80 00       	ld.sh	r0,r0[0x0]
80002b9a:	62 48       	ld.w	r8,r1[0x10]
80002b9c:	00 00       	add	r0,r0
80002b9e:	0a c0       	st.b	r5++,r0

80002ba0 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002ba0:	d4 01       	pushm	lr
80002ba2:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002ba4:	30 08       	mov	r8,0
80002ba6:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002ba8:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002baa:	1a 9a       	mov	r10,sp
80002bac:	fa cb ff fc 	sub	r11,sp,-4
80002bb0:	f0 1f 00 05 	mcall	80002bc4 <get_idle_store_isr+0x24>
80002bb4:	58 1c       	cp.w	r12,1
80002bb6:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002bba:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002bbe:	2f ed       	sub	sp,-8
80002bc0:	d8 02       	popm	pc
80002bc2:	00 00       	add	r0,r0
80002bc4:	80 00       	ld.sh	r0,r0[0x0]
80002bc6:	5f 4c       	srge	r12

80002bc8 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002bc8:	eb cd 40 c0 	pushm	r6-r7,lr
80002bcc:	20 1d       	sub	sp,4
80002bce:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002bd0:	4b a8       	lddpc	r8,80002cb8 <phy_tx_func+0xf0>
80002bd2:	70 08       	ld.w	r8,r8[0x0]
80002bd4:	58 08       	cp.w	r8,0
80002bd6:	c6 60       	breq	80002ca2 <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002bd8:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002bda:	30 08       	mov	r8,0
80002bdc:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002bde:	4b 88       	lddpc	r8,80002cbc <phy_tx_func+0xf4>
80002be0:	70 08       	ld.w	r8,r8[0x0]
80002be2:	58 18       	cp.w	r8,1
80002be4:	c2 60       	breq	80002c30 <phy_tx_func+0x68>
80002be6:	c0 43       	brcs	80002bee <phy_tx_func+0x26>
80002be8:	58 28       	cp.w	r8,2
80002bea:	c5 c1       	brne	80002ca2 <phy_tx_func+0xda>
80002bec:	c5 58       	rjmp	80002c96 <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002bee:	4b 38       	lddpc	r8,80002cb8 <phy_tx_func+0xf0>
80002bf0:	70 0c       	ld.w	r12,r8[0x0]
80002bf2:	1a 9a       	mov	r10,sp
80002bf4:	4b 3b       	lddpc	r11,80002cc0 <phy_tx_func+0xf8>
80002bf6:	f0 1f 00 34 	mcall	80002cc4 <phy_tx_func+0xfc>
80002bfa:	58 1c       	cp.w	r12,1
80002bfc:	c1 41       	brne	80002c24 <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002bfe:	4b 18       	lddpc	r8,80002cc0 <phy_tx_func+0xf8>
80002c00:	70 08       	ld.w	r8,r8[0x0]
80002c02:	90 08       	ld.sh	r8,r8[0x0]
80002c04:	10 9a       	mov	r10,r8
80002c06:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002c0a:	4b 09       	lddpc	r9,80002cc8 <phy_tx_func+0x100>
80002c0c:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002c0e:	5c 78       	castu.h	r8
80002c10:	ea 18 ab cd 	orh	r8,0xabcd
80002c14:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002c16:	30 19       	mov	r9,1
80002c18:	4a d8       	lddpc	r8,80002ccc <phy_tx_func+0x104>
80002c1a:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002c1c:	30 19       	mov	r9,1
80002c1e:	4a 88       	lddpc	r8,80002cbc <phy_tx_func+0xf4>
80002c20:	91 09       	st.w	r8[0x0],r9
80002c22:	c4 08       	rjmp	80002ca2 <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002c24:	e0 68 5a 5a 	mov	r8,23130
80002c28:	ea 18 ab cd 	orh	r8,0xabcd
80002c2c:	8f 18       	st.w	r7[0x4],r8
80002c2e:	c3 a8       	rjmp	80002ca2 <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002c30:	4a 7a       	lddpc	r10,80002ccc <phy_tx_func+0x104>
80002c32:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002c34:	4a 39       	lddpc	r9,80002cc0 <phy_tx_func+0xf8>
80002c36:	72 09       	ld.w	r9,r9[0x0]
80002c38:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002c3c:	b1 69       	lsl	r9,0x10
80002c3e:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002c40:	2f f8       	sub	r8,-1
80002c42:	5c 58       	castu.b	r8
80002c44:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002c46:	4a 1b       	lddpc	r11,80002cc8 <phy_tx_func+0x100>
80002c48:	96 0c       	ld.sh	r12,r11[0x0]
80002c4a:	20 2c       	sub	r12,2
80002c4c:	5c 8c       	casts.h	r12
80002c4e:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002c52:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002c54:	30 0b       	mov	r11,0
80002c56:	f6 0a 19 00 	cp.h	r10,r11
80002c5a:	e0 89 00 09 	brgt	80002c6c <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002c5e:	e8 19 00 ba 	orl	r9,0xba
80002c62:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002c64:	30 09       	mov	r9,0
80002c66:	49 68       	lddpc	r8,80002cbc <phy_tx_func+0xf4>
80002c68:	91 09       	st.w	r8[0x0],r9
80002c6a:	c1 c8       	rjmp	80002ca2 <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002c6c:	49 5a       	lddpc	r10,80002cc0 <phy_tx_func+0xf8>
80002c6e:	74 0a       	ld.w	r10,r10[0x0]
80002c70:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002c74:	14 49       	or	r9,r10
80002c76:	8f 19       	st.w	r7[0x4],r9
80002c78:	2f f8       	sub	r8,-1
80002c7a:	49 59       	lddpc	r9,80002ccc <phy_tx_func+0x104>
80002c7c:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002c7e:	20 2c       	sub	r12,2
80002c80:	49 28       	lddpc	r8,80002cc8 <phy_tx_func+0x100>
80002c82:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002c84:	30 08       	mov	r8,0
80002c86:	f0 0c 19 00 	cp.h	r12,r8
80002c8a:	e0 89 00 0c 	brgt	80002ca2 <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002c8e:	30 29       	mov	r9,2
80002c90:	48 b8       	lddpc	r8,80002cbc <phy_tx_func+0xf4>
80002c92:	91 09       	st.w	r8[0x0],r9
80002c94:	c0 78       	rjmp	80002ca2 <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002c96:	fc 18 00 ba 	movh	r8,0xba
80002c9a:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002c9c:	30 09       	mov	r9,0
80002c9e:	48 88       	lddpc	r8,80002cbc <phy_tx_func+0xf4>
80002ca0:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002ca2:	e0 68 5a 5a 	mov	r8,23130
80002ca6:	ea 18 ab cd 	orh	r8,0xabcd
80002caa:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002cac:	30 08       	mov	r8,0
80002cae:	8f 38       	st.w	r7[0xc],r8
}
80002cb0:	2f fd       	sub	sp,-4
80002cb2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002cb6:	00 00       	add	r0,r0
80002cb8:	00 00       	add	r0,r0
80002cba:	0a cc       	st.b	r5++,r12
80002cbc:	00 00       	add	r0,r0
80002cbe:	0a 8c       	andn	r12,r5
80002cc0:	00 00       	add	r0,r0
80002cc2:	0a 98       	mov	r8,r5
80002cc4:	80 00       	ld.sh	r0,r0[0x0]
80002cc6:	5f 4c       	srge	r12
80002cc8:	00 00       	add	r0,r0
80002cca:	0a b4       	st.h	r5++,r4
80002ccc:	00 00       	add	r0,r0
80002cce:	0a 6c       	and	r12,r5

80002cd0 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002cd0:	d4 01       	pushm	lr
80002cd2:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002cd4:	30 0a       	mov	r10,0
80002cd6:	fa cb ff fc 	sub	r11,sp,-4
80002cda:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002cdc:	14 99       	mov	r9,r10
80002cde:	1a 9b       	mov	r11,sp
80002ce0:	f0 1f 00 05 	mcall	80002cf4 <get_idle_store+0x24>
80002ce4:	58 1c       	cp.w	r12,1
80002ce6:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002cea:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002cee:	2f fd       	sub	sp,-4
80002cf0:	d8 02       	popm	pc
80002cf2:	00 00       	add	r0,r0
80002cf4:	80 00       	ld.sh	r0,r0[0x0]
80002cf6:	60 3c       	ld.w	r12,r0[0xc]

80002cf8 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002cf8:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002cfa:	48 5b       	lddpc	r11,80002d0c <phy_init+0x14>
80002cfc:	48 5c       	lddpc	r12,80002d10 <phy_init+0x18>
80002cfe:	f0 1f 00 06 	mcall	80002d14 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002d02:	f0 1f 00 06 	mcall	80002d18 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002d06:	f0 1f 00 06 	mcall	80002d1c <phy_init+0x24>
	
}
80002d0a:	d8 02       	popm	pc
80002d0c:	80 00       	ld.sh	r0,r0[0x0]
80002d0e:	2b c8       	sub	r8,-68
80002d10:	80 00       	ld.sh	r0,r0[0x0]
80002d12:	2d 20       	sub	r0,-46
80002d14:	80 00       	ld.sh	r0,r0[0x0]
80002d16:	3d 74       	mov	r4,-41
80002d18:	80 00       	ld.sh	r0,r0[0x0]
80002d1a:	3d 88       	mov	r8,-40
80002d1c:	80 00       	ld.sh	r0,r0[0x0]
80002d1e:	47 34       	lddsp	r4,sp[0x1cc]

80002d20 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002d20:	eb cd 40 e0 	pushm	r5-r7,lr
80002d24:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002d26:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002d2a:	70 08       	ld.w	r8,r8[0x0]
80002d2c:	58 08       	cp.w	r8,0
80002d2e:	e0 80 01 08 	breq	80002f3e <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002d32:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002d34:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002d38:	70 09       	ld.w	r9,r8[0x0]
80002d3a:	2f f9       	sub	r9,-1
80002d3c:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002d3e:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002d42:	70 08       	ld.w	r8,r8[0x0]
80002d44:	58 18       	cp.w	r8,1
80002d46:	e0 80 00 85 	breq	80002e50 <phy_rx_func+0x130>
80002d4a:	c0 73       	brcs	80002d58 <phy_rx_func+0x38>
80002d4c:	58 28       	cp.w	r8,2
80002d4e:	c5 c0       	breq	80002e06 <phy_rx_func+0xe6>
80002d50:	58 38       	cp.w	r8,3
80002d52:	e0 81 00 f6 	brne	80002f3e <phy_rx_func+0x21e>
80002d56:	cd 58       	rjmp	80002f00 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002d58:	e0 6a 5a 5a 	mov	r10,23130
80002d5c:	ea 1a ab cd 	orh	r10,0xabcd
80002d60:	14 36       	cp.w	r6,r10
80002d62:	e0 80 00 ee 	breq	80002f3e <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002d66:	ec 08 16 10 	lsr	r8,r6,0x10
80002d6a:	e0 48 ab cd 	cp.w	r8,43981
80002d6e:	e0 81 00 e8 	brne	80002f3e <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002d72:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002d76:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002d7a:	20 28       	sub	r8,2
80002d7c:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002d80:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002d82:	30 09       	mov	r9,0
80002d84:	f2 08 19 00 	cp.h	r8,r9
80002d88:	e0 8a 00 db 	brle	80002f3e <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002d8c:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002d90:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002d92:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002d96:	70 0c       	ld.w	r12,r8[0x0]
80002d98:	f0 1f 03 88 	mcall	80003bb8 <phy_rx_func+0xe98>
80002d9c:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002da0:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002da2:	58 0c       	cp.w	r12,0
80002da4:	e0 80 00 cd 	breq	80002f3e <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002da8:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002dac:	90 09       	ld.sh	r9,r8[0x0]
80002dae:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002db2:	2f f9       	sub	r9,-1
80002db4:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002db6:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002dba:	74 0a       	ld.w	r10,r10[0x0]
80002dbc:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002dc0:	76 0b       	ld.w	r11,r11[0x0]
80002dc2:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002dc6:	2f f9       	sub	r9,-1
80002dc8:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002dca:	e2 16 0f 00 	andl	r6,0xf00,COH
80002dce:	e0 46 01 00 	cp.w	r6,256
80002dd2:	c0 c0       	breq	80002dea <phy_rx_func+0xca>
80002dd4:	e0 8b 00 05 	brhi	80002dde <phy_rx_func+0xbe>
80002dd8:	58 06       	cp.w	r6,0
80002dda:	c0 80       	breq	80002dea <phy_rx_func+0xca>
80002ddc:	c0 c8       	rjmp	80002df4 <phy_rx_func+0xd4>
80002dde:	e0 46 02 00 	cp.w	r6,512
80002de2:	c0 40       	breq	80002dea <phy_rx_func+0xca>
80002de4:	e0 46 03 00 	cp.w	r6,768
80002de8:	c0 61       	brne	80002df4 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002dea:	30 29       	mov	r9,2
80002dec:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002df0:	91 09       	st.w	r8[0x0],r9
80002df2:	ca 68       	rjmp	80002f3e <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002df4:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002df8:	70 0c       	ld.w	r12,r8[0x0]
80002dfa:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002dfe:	70 0b       	ld.w	r11,r8[0x0]
80002e00:	f0 1f 03 70 	mcall	80003bc0 <phy_rx_func+0xea0>
80002e04:	c9 d8       	rjmp	80002f3e <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002e06:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002e0a:	b1 86       	lsr	r6,0x10
80002e0c:	14 06       	add	r6,r10
80002e0e:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002e12:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002e14:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002e18:	90 09       	ld.sh	r9,r8[0x0]
80002e1a:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002e1e:	76 0b       	ld.w	r11,r11[0x0]
80002e20:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002e24:	2f f9       	sub	r9,-1
80002e26:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002e28:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002e2c:	92 08       	ld.sh	r8,r9[0x0]
80002e2e:	20 28       	sub	r8,2
80002e30:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002e32:	30 09       	mov	r9,0
80002e34:	f2 08 19 00 	cp.h	r8,r9
80002e38:	e0 8a 00 07 	brle	80002e46 <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002e3c:	30 19       	mov	r9,1
80002e3e:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002e42:	91 09       	st.w	r8[0x0],r9
80002e44:	c7 d8       	rjmp	80002f3e <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002e46:	30 39       	mov	r9,3
80002e48:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002e4c:	91 09       	st.w	r8[0x0],r9
80002e4e:	c7 88       	rjmp	80002f3e <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002e50:	ec 0a 14 10 	asr	r10,r6,0x10
80002e54:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002e58:	90 09       	ld.sh	r9,r8[0x0]
80002e5a:	14 09       	add	r9,r10
80002e5c:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002e5e:	fe f9 0d 52 	ld.w	r9,pc[3410]
80002e62:	92 08       	ld.sh	r8,r9[0x0]
80002e64:	fe fb 0d 58 	ld.w	r11,pc[3416]
80002e68:	76 0b       	ld.w	r11,r11[0x0]
80002e6a:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002e6e:	2f f8       	sub	r8,-1
80002e70:	5c 88       	casts.h	r8
80002e72:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002e74:	fe fa 0d 38 	ld.w	r10,pc[3384]
80002e78:	94 09       	ld.sh	r9,r10[0x0]
80002e7a:	20 29       	sub	r9,2
80002e7c:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80002e7e:	30 0a       	mov	r10,0
80002e80:	f4 09 19 00 	cp.h	r9,r10
80002e84:	e0 89 00 20 	brgt	80002ec4 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80002e88:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80002e8c:	e0 46 00 ba 	cp.w	r6,186
80002e90:	c0 d1       	brne	80002eaa <phy_rx_func+0x18a>
80002e92:	fe f8 0d 32 	ld.w	r8,pc[3378]
80002e96:	90 09       	ld.sh	r9,r8[0x0]
80002e98:	f4 09 19 00 	cp.h	r9,r10
80002e9c:	c0 71       	brne	80002eaa <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80002e9e:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80002ea2:	70 0c       	ld.w	r12,r8[0x0]
80002ea4:	f0 1f 03 49 	mcall	80003bc8 <phy_rx_func+0xea8>
80002ea8:	c0 98       	rjmp	80002eba <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80002eaa:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80002eae:	70 0c       	ld.w	r12,r8[0x0]
80002eb0:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80002eb4:	70 0b       	ld.w	r11,r8[0x0]
80002eb6:	f0 1f 03 43 	mcall	80003bc0 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80002eba:	30 09       	mov	r9,0
80002ebc:	fe f8 0c ec 	ld.w	r8,pc[3308]
80002ec0:	91 09       	st.w	r8[0x0],r9
80002ec2:	c3 e8       	rjmp	80002f3e <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80002ec4:	5c 86       	casts.h	r6
80002ec6:	fe f9 0c fe 	ld.w	r9,pc[3326]
80002eca:	92 0a       	ld.sh	r10,r9[0x0]
80002ecc:	0c 0a       	add	r10,r6
80002ece:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002ed0:	fe f9 0c ec 	ld.w	r9,pc[3308]
80002ed4:	72 09       	ld.w	r9,r9[0x0]
80002ed6:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80002eda:	2f f8       	sub	r8,-1
80002edc:	fe f9 0c d4 	ld.w	r9,pc[3284]
80002ee0:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80002ee2:	fe f9 0c ca 	ld.w	r9,pc[3274]
80002ee6:	92 08       	ld.sh	r8,r9[0x0]
80002ee8:	20 28       	sub	r8,2
80002eea:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80002eec:	30 09       	mov	r9,0
80002eee:	f2 08 19 00 	cp.h	r8,r9
80002ef2:	e0 89 00 26 	brgt	80002f3e <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80002ef6:	30 39       	mov	r9,3
80002ef8:	fe f8 0c b0 	ld.w	r8,pc[3248]
80002efc:	91 09       	st.w	r8[0x0],r9
80002efe:	c2 08       	rjmp	80002f3e <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80002f00:	e6 16 00 ff 	andh	r6,0xff,COH
80002f04:	fc 19 00 ba 	movh	r9,0xba
80002f08:	12 36       	cp.w	r6,r9
80002f0a:	c0 e1       	brne	80002f26 <phy_rx_func+0x206>
80002f0c:	fe f8 0c b8 	ld.w	r8,pc[3256]
80002f10:	90 09       	ld.sh	r9,r8[0x0]
80002f12:	30 08       	mov	r8,0
80002f14:	f0 09 19 00 	cp.h	r9,r8
80002f18:	c0 71       	brne	80002f26 <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80002f1a:	fe f8 0c a2 	ld.w	r8,pc[3234]
80002f1e:	70 0c       	ld.w	r12,r8[0x0]
80002f20:	f0 1f 03 2a 	mcall	80003bc8 <phy_rx_func+0xea8>
80002f24:	c0 98       	rjmp	80002f36 <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80002f26:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002f2a:	70 0c       	ld.w	r12,r8[0x0]
80002f2c:	fe f8 0c 90 	ld.w	r8,pc[3216]
80002f30:	70 0b       	ld.w	r11,r8[0x0]
80002f32:	f0 1f 03 24 	mcall	80003bc0 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80002f36:	30 09       	mov	r9,0
80002f38:	fe f8 0c 70 	ld.w	r8,pc[3184]
80002f3c:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80002f3e:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002f42:	11 89       	ld.ub	r9,r8[0x0]
80002f44:	30 08       	mov	r8,0
80002f46:	f0 09 18 00 	cp.b	r9,r8
80002f4a:	c1 31       	brne	80002f70 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80002f4c:	fe f6 0c 84 	ld.w	r6,pc[3204]
80002f50:	6c 0c       	ld.w	r12,r6[0x0]
80002f52:	f0 1f 03 1a 	mcall	80003bb8 <phy_rx_func+0xe98>
80002f56:	fe f8 0c 7e 	ld.w	r8,pc[3198]
80002f5a:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80002f5c:	6c 0c       	ld.w	r12,r6[0x0]
80002f5e:	f0 1f 03 17 	mcall	80003bb8 <phy_rx_func+0xe98>
80002f62:	fe f8 0c 76 	ld.w	r8,pc[3190]
80002f66:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80002f68:	30 19       	mov	r9,1
80002f6a:	fe f8 0c 62 	ld.w	r8,pc[3170]
80002f6e:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80002f70:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80002f74:	70 08       	ld.w	r8,r8[0x0]
80002f76:	58 28       	cp.w	r8,2
80002f78:	e0 80 01 98 	breq	800032a8 <phy_rx_func+0x588>
80002f7c:	e0 8b 00 06 	brhi	80002f88 <phy_rx_func+0x268>
80002f80:	58 08       	cp.w	r8,0
80002f82:	c0 b0       	breq	80002f98 <phy_rx_func+0x278>
80002f84:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002f88:	58 38       	cp.w	r8,3
80002f8a:	e0 80 05 c5 	breq	80003b14 <phy_rx_func+0xdf4>
80002f8e:	58 48       	cp.w	r8,4
80002f90:	e0 81 06 05 	brne	80003b9a <phy_rx_func+0xe7a>
80002f94:	e0 8f 02 4b 	bral	8000342a <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80002f98:	6e 28       	ld.w	r8,r7[0x8]
80002f9a:	e0 6a 5a 5a 	mov	r10,23130
80002f9e:	ea 1a ab cd 	orh	r10,0xabcd
80002fa2:	14 38       	cp.w	r8,r10
80002fa4:	c0 71       	brne	80002fb2 <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
80002fa6:	30 09       	mov	r9,0
80002fa8:	fe f8 0c 38 	ld.w	r8,pc[3128]
80002fac:	91 09       	st.w	r8[0x0],r9
80002fae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80002fb2:	10 99       	mov	r9,r8
80002fb4:	e0 19 00 00 	andl	r9,0x0
80002fb8:	fc 1a ab cd 	movh	r10,0xabcd
80002fbc:	14 39       	cp.w	r9,r10
80002fbe:	e0 81 05 ee 	brne	80003b9a <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80002fc2:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80002fc6:	fe f9 0c 1e 	ld.w	r9,pc[3102]
80002fca:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80002fcc:	6e 29       	ld.w	r9,r7[0x8]
80002fce:	e2 19 f0 00 	andl	r9,0xf000,COH
80002fd2:	e0 49 c0 00 	cp.w	r9,49152
80002fd6:	e0 81 00 ce 	brne	80003172 <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
80002fda:	30 1a       	mov	r10,1
80002fdc:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80002fe0:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
80002fe2:	fe f9 0b f6 	ld.w	r9,pc[3062]
80002fe6:	72 09       	ld.w	r9,r9[0x0]
80002fe8:	58 09       	cp.w	r9,0
80002fea:	c0 71       	brne	80002ff8 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80002fec:	fe fc 0c 00 	ld.w	r12,pc[3072]
80002ff0:	f0 1f 03 00 	mcall	80003bf0 <phy_rx_func+0xed0>
80002ff4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80002ff8:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80002ffc:	fe f9 0b f8 	ld.w	r9,pc[3064]
80003000:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80003002:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003006:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
8000300a:	fe fa 0b ee 	ld.w	r10,pc[3054]
8000300e:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80003010:	13 89       	ld.ub	r9,r9[0x0]
80003012:	37 fa       	mov	r10,127
80003014:	f4 09 18 00 	cp.b	r9,r10
80003018:	c6 d0       	breq	800030f2 <phy_rx_func+0x3d2>
8000301a:	e0 8b 00 0c 	brhi	80003032 <phy_rx_func+0x312>
8000301e:	31 2a       	mov	r10,18
80003020:	f4 09 18 00 	cp.b	r9,r10
80003024:	c4 20       	breq	800030a8 <phy_rx_func+0x388>
80003026:	31 3a       	mov	r10,19
80003028:	f4 09 18 00 	cp.b	r9,r10
8000302c:	e0 81 00 83 	brne	80003132 <phy_rx_func+0x412>
80003030:	c5 b8       	rjmp	800030e6 <phy_rx_func+0x3c6>
80003032:	2f 09       	sub	r9,-16
80003034:	30 1a       	mov	r10,1
80003036:	f4 09 18 00 	cp.b	r9,r10
8000303a:	e0 8b 00 7c 	brhi	80003132 <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
8000303e:	ef 38 00 0e 	ld.ub	r8,r7[14]
80003042:	e2 18 00 f0 	andl	r8,0xf0,COH
80003046:	59 08       	cp.w	r8,16
80003048:	c0 71       	brne	80003056 <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
8000304a:	30 19       	mov	r9,1
8000304c:	fe f8 0b 94 	ld.w	r8,pc[2964]
80003050:	91 09       	st.w	r8[0x0],r9
80003052:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80003056:	e0 48 00 20 	cp.w	r8,32
8000305a:	c2 11       	brne	8000309c <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
8000305c:	30 a9       	mov	r9,10
8000305e:	fe f8 0b 82 	ld.w	r8,pc[2946]
80003062:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003064:	fe f6 0b 98 	ld.w	r6,pc[2968]
80003068:	6c 08       	ld.w	r8,r6[0x0]
8000306a:	f0 0a 11 ff 	rsub	r10,r8,-1
8000306e:	fe f7 0b 6a 	ld.w	r7,pc[2922]
80003072:	2f f8       	sub	r8,-1
80003074:	6e 0c       	ld.w	r12,r7[0x0]
80003076:	f4 ca fe 00 	sub	r10,r10,-512
8000307a:	30 0b       	mov	r11,0
8000307c:	10 0c       	add	r12,r8
8000307e:	f0 1f 02 e1 	mcall	80003c00 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80003082:	30 08       	mov	r8,0
80003084:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80003086:	6e 0c       	ld.w	r12,r7[0x0]
80003088:	f0 1f 02 df 	mcall	80003c04 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000308c:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003090:	70 0c       	ld.w	r12,r8[0x0]
80003092:	f0 1f 02 ca 	mcall	80003bb8 <phy_rx_func+0xe98>
80003096:	8f 0c       	st.w	r7[0x0],r12
80003098:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
8000309c:	30 09       	mov	r9,0
8000309e:	fe f8 0b 42 	ld.w	r8,pc[2882]
800030a2:	91 09       	st.w	r8[0x0],r9
800030a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800030a8:	20 48       	sub	r8,4
800030aa:	fe f9 0b 3a 	ld.w	r9,pc[2874]
800030ae:	93 08       	st.w	r9[0x0],r8
800030b0:	58 08       	cp.w	r8,0
800030b2:	e0 80 05 74 	breq	80003b9a <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
800030b6:	ef 3c 00 0f 	ld.ub	r12,r7[15]
800030ba:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
800030be:	fe f8 0b 4a 	ld.w	r8,pc[2890]
800030c2:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
800030c4:	8e 69       	ld.sh	r9,r7[0xc]
800030c6:	fe f8 0b 46 	ld.w	r8,pc[2886]
800030ca:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
800030cc:	8e 79       	ld.sh	r9,r7[0xe]
800030ce:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
800030d0:	f0 1f 02 d0 	mcall	80003c10 <phy_rx_func+0xef0>
800030d4:	fe f8 0b 0c 	ld.w	r8,pc[2828]
800030d8:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
800030da:	30 49       	mov	r9,4
800030dc:	fe f8 0b 00 	ld.w	r8,pc[2816]
800030e0:	91 09       	st.w	r8[0x0],r9
800030e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
800030e6:	30 09       	mov	r9,0
800030e8:	fe f8 0a f8 	ld.w	r8,pc[2808]
800030ec:	91 09       	st.w	r8[0x0],r9
800030ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800030f2:	20 48       	sub	r8,4
800030f4:	fe f9 0a f0 	ld.w	r9,pc[2800]
800030f8:	93 08       	st.w	r9[0x0],r8
800030fa:	58 08       	cp.w	r8,0
800030fc:	e0 80 05 4f 	breq	80003b9a <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003100:	fe f8 0b 14 	ld.w	r8,pc[2836]
80003104:	70 09       	ld.w	r9,r8[0x0]
80003106:	8e 7b       	ld.sh	r11,r7[0xe]
80003108:	fe fa 0b 10 	ld.w	r10,pc[2832]
8000310c:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003110:	2f f9       	sub	r9,-1
80003112:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003114:	fe f8 0a e4 	ld.w	r8,pc[2788]
80003118:	70 09       	ld.w	r9,r8[0x0]
8000311a:	20 29       	sub	r9,2
8000311c:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
8000311e:	30 29       	mov	r9,2
80003120:	fe f8 0a c0 	ld.w	r8,pc[2752]
80003124:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003126:	30 39       	mov	r9,3
80003128:	fe f8 0a b4 	ld.w	r8,pc[2740]
8000312c:	91 09       	st.w	r8[0x0],r9
8000312e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003132:	30 3a       	mov	r10,3
80003134:	fe f9 0a ac 	ld.w	r9,pc[2732]
80003138:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
8000313a:	6e 2a       	ld.w	r10,r7[0x8]
8000313c:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003140:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003142:	6e 3a       	ld.w	r10,r7[0xc]
80003144:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
80003146:	59 48       	cp.w	r8,20
80003148:	c0 61       	brne	80003154 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
8000314a:	31 89       	mov	r9,24
8000314c:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003150:	91 09       	st.w	r8[0x0],r9
80003152:	c0 a8       	rjmp	80003166 <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003154:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003158:	70 08       	ld.w	r8,r8[0x0]
8000315a:	59 08       	cp.w	r8,16
8000315c:	c0 51       	brne	80003166 <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
8000315e:	31 09       	mov	r9,16
80003160:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003164:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003166:	30 49       	mov	r9,4
80003168:	fe f8 0a 74 	ld.w	r8,pc[2676]
8000316c:	91 09       	st.w	r8[0x0],r9
8000316e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80003172:	e0 49 10 00 	cp.w	r9,4096
80003176:	5f 1a       	srne	r10
80003178:	e0 49 20 00 	cp.w	r9,8192
8000317c:	5f 19       	srne	r9
8000317e:	f5 e9 00 09 	and	r9,r10,r9
80003182:	e0 81 05 0c 	brne	80003b9a <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
80003186:	fe fa 0a 9a 	ld.w	r10,pc[2714]
8000318a:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
8000318c:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003190:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
80003192:	fe fa 0a 62 	ld.w	r10,pc[2658]
80003196:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
80003198:	fe f9 0a 3c 	ld.w	r9,pc[2620]
8000319c:	72 09       	ld.w	r9,r9[0x0]
8000319e:	58 09       	cp.w	r9,0
800031a0:	c0 71       	brne	800031ae <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800031a2:	fe fc 0a 4a 	ld.w	r12,pc[2634]
800031a6:	f0 1f 02 93 	mcall	80003bf0 <phy_rx_func+0xed0>
800031aa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800031ae:	6e 2a       	ld.w	r10,r7[0x8]
800031b0:	e2 1a 0f 00 	andl	r10,0xf00,COH
800031b4:	58 1a       	cp.w	r10,1
800031b6:	e0 8b 00 4d 	brhi	80003250 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
800031ba:	20 48       	sub	r8,4
800031bc:	fe f9 0a 28 	ld.w	r9,pc[2600]
800031c0:	93 08       	st.w	r9[0x0],r8
800031c2:	58 08       	cp.w	r8,0
800031c4:	e0 80 04 eb 	breq	80003b9a <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
800031c8:	8e 68       	ld.sh	r8,r7[0xc]
800031ca:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
800031ce:	fe f9 0a 5a 	ld.w	r9,pc[2650]
800031d2:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
800031d4:	30 09       	mov	r9,0
800031d6:	f2 08 19 00 	cp.h	r8,r9
800031da:	c0 70       	breq	800031e8 <phy_rx_func+0x4c8>
800031dc:	30 19       	mov	r9,1
800031de:	f2 08 19 00 	cp.h	r8,r9
800031e2:	e0 81 04 dc 	brne	80003b9a <phy_rx_func+0xe7a>
800031e6:	c2 68       	rjmp	80003232 <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800031e8:	fe f8 0a 44 	ld.w	r8,pc[2628]
800031ec:	70 0a       	ld.w	r10,r8[0x0]
800031ee:	fe f9 09 e6 	ld.w	r9,pc[2534]
800031f2:	72 09       	ld.w	r9,r9[0x0]
800031f4:	8e 7b       	ld.sh	r11,r7[0xe]
800031f6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800031fa:	70 09       	ld.w	r9,r8[0x0]
800031fc:	2f f9       	sub	r9,-1
800031fe:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003200:	e0 49 00 ff 	cp.w	r9,255
80003204:	e0 88 00 11 	brls	80003226 <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
80003208:	30 09       	mov	r9,0
8000320a:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
8000320c:	fe f7 09 c8 	ld.w	r7,pc[2504]
80003210:	6e 0c       	ld.w	r12,r7[0x0]
80003212:	f0 1f 02 7d 	mcall	80003c04 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
80003216:	fe f8 09 ba 	ld.w	r8,pc[2490]
8000321a:	70 0c       	ld.w	r12,r8[0x0]
8000321c:	f0 1f 02 67 	mcall	80003bb8 <phy_rx_func+0xe98>
80003220:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
80003222:	e0 80 04 bc 	breq	80003b9a <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
80003226:	30 29       	mov	r9,2
80003228:	fe f8 09 b4 	ld.w	r8,pc[2484]
8000322c:	91 09       	st.w	r8[0x0],r9
8000322e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003232:	8e 79       	ld.sh	r9,r7[0xe]
80003234:	30 38       	mov	r8,3
80003236:	f0 09 19 00 	cp.h	r9,r8
8000323a:	c0 51       	brne	80003244 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
8000323c:	30 19       	mov	r9,1
8000323e:	fe f8 09 f2 	ld.w	r8,pc[2546]
80003242:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
80003244:	30 29       	mov	r9,2
80003246:	fe f8 09 96 	ld.w	r8,pc[2454]
8000324a:	91 09       	st.w	r8[0x0],r9
8000324c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003250:	58 18       	cp.w	r8,1
80003252:	e0 88 04 a4 	brls	80003b9a <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003256:	fe f8 09 d6 	ld.w	r8,pc[2518]
8000325a:	70 0a       	ld.w	r10,r8[0x0]
8000325c:	6e 3b       	ld.w	r11,r7[0xc]
8000325e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003262:	70 09       	ld.w	r9,r8[0x0]
80003264:	2f f9       	sub	r9,-1
80003266:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003268:	e0 49 00 ff 	cp.w	r9,255
8000326c:	e0 88 00 11 	brls	8000328e <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003270:	30 09       	mov	r9,0
80003272:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003274:	fe f7 09 60 	ld.w	r7,pc[2400]
80003278:	6e 0c       	ld.w	r12,r7[0x0]
8000327a:	f0 1f 02 63 	mcall	80003c04 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000327e:	fe f8 09 52 	ld.w	r8,pc[2386]
80003282:	70 0c       	ld.w	r12,r8[0x0]
80003284:	f0 1f 02 4d 	mcall	80003bb8 <phy_rx_func+0xe98>
80003288:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
8000328a:	e0 80 04 88 	breq	80003b9a <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
8000328e:	fe f9 09 56 	ld.w	r9,pc[2390]
80003292:	72 08       	ld.w	r8,r9[0x0]
80003294:	20 28       	sub	r8,2
80003296:	93 08       	st.w	r9[0x0],r8
80003298:	e0 80 04 81 	breq	80003b9a <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
8000329c:	30 29       	mov	r9,2
8000329e:	fe f8 09 3e 	ld.w	r8,pc[2366]
800032a2:	91 09       	st.w	r8[0x0],r9
800032a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
800032a8:	fe f8 09 84 	ld.w	r8,pc[2436]
800032ac:	70 0a       	ld.w	r10,r8[0x0]
800032ae:	fe f9 09 26 	ld.w	r9,pc[2342]
800032b2:	72 09       	ld.w	r9,r9[0x0]
800032b4:	8e 4b       	ld.sh	r11,r7[0x8]
800032b6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
800032ba:	70 09       	ld.w	r9,r8[0x0]
800032bc:	2f f9       	sub	r9,-1
800032be:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800032c0:	e0 49 00 ff 	cp.w	r9,255
800032c4:	e0 88 00 16 	brls	800032f0 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
800032c8:	30 09       	mov	r9,0
800032ca:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800032cc:	fe f6 09 08 	ld.w	r6,pc[2312]
800032d0:	6c 0c       	ld.w	r12,r6[0x0]
800032d2:	f0 1f 02 4d 	mcall	80003c04 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800032d6:	fe f8 08 fa 	ld.w	r8,pc[2298]
800032da:	70 0c       	ld.w	r12,r8[0x0]
800032dc:	f0 1f 02 37 	mcall	80003bb8 <phy_rx_func+0xe98>
800032e0:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800032e2:	c0 71       	brne	800032f0 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
800032e4:	30 09       	mov	r9,0
800032e6:	fe f8 08 f6 	ld.w	r8,pc[2294]
800032ea:	91 09       	st.w	r8[0x0],r9
800032ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
800032f0:	fe f9 08 f4 	ld.w	r9,pc[2292]
800032f4:	72 08       	ld.w	r8,r9[0x0]
800032f6:	20 28       	sub	r8,2
800032f8:	93 08       	st.w	r9[0x0],r8
800032fa:	c0 71       	brne	80003308 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
800032fc:	30 09       	mov	r9,0
800032fe:	fe f8 08 de 	ld.w	r8,pc[2270]
80003302:	91 09       	st.w	r8[0x0],r9
80003304:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003308:	fe f8 09 24 	ld.w	r8,pc[2340]
8000330c:	70 0a       	ld.w	r10,r8[0x0]
8000330e:	fe f9 08 c6 	ld.w	r9,pc[2246]
80003312:	72 09       	ld.w	r9,r9[0x0]
80003314:	8e 5b       	ld.sh	r11,r7[0xa]
80003316:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000331a:	70 09       	ld.w	r9,r8[0x0]
8000331c:	2f f9       	sub	r9,-1
8000331e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003320:	e0 49 00 ff 	cp.w	r9,255
80003324:	e0 88 00 16 	brls	80003350 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003328:	30 09       	mov	r9,0
8000332a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000332c:	fe f6 08 a8 	ld.w	r6,pc[2216]
80003330:	6c 0c       	ld.w	r12,r6[0x0]
80003332:	f0 1f 02 35 	mcall	80003c04 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003336:	fe f8 08 9a 	ld.w	r8,pc[2202]
8000333a:	70 0c       	ld.w	r12,r8[0x0]
8000333c:	f0 1f 02 1f 	mcall	80003bb8 <phy_rx_func+0xe98>
80003340:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003342:	c0 71       	brne	80003350 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003344:	30 09       	mov	r9,0
80003346:	fe f8 08 96 	ld.w	r8,pc[2198]
8000334a:	91 09       	st.w	r8[0x0],r9
8000334c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003350:	fe f9 08 94 	ld.w	r9,pc[2196]
80003354:	72 08       	ld.w	r8,r9[0x0]
80003356:	20 28       	sub	r8,2
80003358:	93 08       	st.w	r9[0x0],r8
8000335a:	c0 71       	brne	80003368 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
8000335c:	30 09       	mov	r9,0
8000335e:	fe f8 08 7e 	ld.w	r8,pc[2174]
80003362:	91 09       	st.w	r8[0x0],r9
80003364:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003368:	fe f8 08 c4 	ld.w	r8,pc[2244]
8000336c:	70 0a       	ld.w	r10,r8[0x0]
8000336e:	fe f9 08 66 	ld.w	r9,pc[2150]
80003372:	72 09       	ld.w	r9,r9[0x0]
80003374:	8e 6b       	ld.sh	r11,r7[0xc]
80003376:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000337a:	70 09       	ld.w	r9,r8[0x0]
8000337c:	2f f9       	sub	r9,-1
8000337e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003380:	e0 49 00 ff 	cp.w	r9,255
80003384:	e0 88 00 16 	brls	800033b0 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003388:	30 09       	mov	r9,0
8000338a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000338c:	fe f6 08 48 	ld.w	r6,pc[2120]
80003390:	6c 0c       	ld.w	r12,r6[0x0]
80003392:	f0 1f 02 1d 	mcall	80003c04 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003396:	fe f8 08 3a 	ld.w	r8,pc[2106]
8000339a:	70 0c       	ld.w	r12,r8[0x0]
8000339c:	f0 1f 02 07 	mcall	80003bb8 <phy_rx_func+0xe98>
800033a0:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800033a2:	c0 71       	brne	800033b0 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
800033a4:	30 09       	mov	r9,0
800033a6:	fe f8 08 36 	ld.w	r8,pc[2102]
800033aa:	91 09       	st.w	r8[0x0],r9
800033ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800033b0:	fe f9 08 34 	ld.w	r9,pc[2100]
800033b4:	72 08       	ld.w	r8,r9[0x0]
800033b6:	20 28       	sub	r8,2
800033b8:	93 08       	st.w	r9[0x0],r8
800033ba:	c0 71       	brne	800033c8 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
800033bc:	30 09       	mov	r9,0
800033be:	fe f8 08 1e 	ld.w	r8,pc[2078]
800033c2:	91 09       	st.w	r8[0x0],r9
800033c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800033c8:	fe f8 08 64 	ld.w	r8,pc[2148]
800033cc:	70 0a       	ld.w	r10,r8[0x0]
800033ce:	fe f9 08 06 	ld.w	r9,pc[2054]
800033d2:	72 09       	ld.w	r9,r9[0x0]
800033d4:	8e 7b       	ld.sh	r11,r7[0xe]
800033d6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800033da:	70 09       	ld.w	r9,r8[0x0]
800033dc:	2f f9       	sub	r9,-1
800033de:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800033e0:	e0 49 00 ff 	cp.w	r9,255
800033e4:	e0 88 00 16 	brls	80003410 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
800033e8:	30 09       	mov	r9,0
800033ea:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800033ec:	fe f7 07 e8 	ld.w	r7,pc[2024]
800033f0:	6e 0c       	ld.w	r12,r7[0x0]
800033f2:	f0 1f 02 05 	mcall	80003c04 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800033f6:	fe f8 07 da 	ld.w	r8,pc[2010]
800033fa:	70 0c       	ld.w	r12,r8[0x0]
800033fc:	f0 1f 01 ef 	mcall	80003bb8 <phy_rx_func+0xe98>
80003400:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003402:	c0 71       	brne	80003410 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
80003404:	30 09       	mov	r9,0
80003406:	fe f8 07 d6 	ld.w	r8,pc[2006]
8000340a:	91 09       	st.w	r8[0x0],r9
8000340c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003410:	fe f9 07 d4 	ld.w	r9,pc[2004]
80003414:	72 08       	ld.w	r8,r9[0x0]
80003416:	20 28       	sub	r8,2
80003418:	93 08       	st.w	r9[0x0],r8
8000341a:	e0 81 03 c0 	brne	80003b9a <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
8000341e:	30 09       	mov	r9,0
80003420:	fe f8 07 bc 	ld.w	r8,pc[1980]
80003424:	91 09       	st.w	r8[0x0],r9
80003426:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
8000342a:	fe f8 07 ca 	ld.w	r8,pc[1994]
8000342e:	11 89       	ld.ub	r9,r8[0x0]
80003430:	31 28       	mov	r8,18
80003432:	f0 09 18 00 	cp.b	r9,r8
80003436:	e0 81 01 4c 	brne	800036ce <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
8000343a:	ef 39 00 09 	ld.ub	r9,r7[9]
8000343e:	fe f8 07 b6 	ld.w	r8,pc[1974]
80003442:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003444:	11 89       	ld.ub	r9,r8[0x0]
80003446:	3f 28       	mov	r8,-14
80003448:	f0 09 18 00 	cp.b	r9,r8
8000344c:	e0 81 01 3b 	brne	800036c2 <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003450:	30 19       	mov	r9,1
80003452:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003456:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003458:	6e 29       	ld.w	r9,r7[0x8]
8000345a:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
8000345e:	fe f8 07 86 	ld.w	r8,pc[1926]
80003462:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003464:	8e 59       	ld.sh	r9,r7[0xa]
80003466:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000346a:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
8000346c:	8e 69       	ld.sh	r9,r7[0xc]
8000346e:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003470:	8e 79       	ld.sh	r9,r7[0xe]
80003472:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003474:	fe f8 07 88 	ld.w	r8,pc[1928]
80003478:	fe f9 07 60 	ld.w	r9,pc[1888]
8000347c:	72 0a       	ld.w	r10,r9[0x0]
8000347e:	70 09       	ld.w	r9,r8[0x0]
80003480:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003484:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003488:	70 09       	ld.w	r9,r8[0x0]
8000348a:	2f f9       	sub	r9,-1
8000348c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000348e:	e0 49 01 ff 	cp.w	r9,511
80003492:	e0 88 00 16 	brls	800034be <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
80003496:	30 09       	mov	r9,0
80003498:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000349a:	fe f6 07 3e 	ld.w	r6,pc[1854]
8000349e:	6c 0c       	ld.w	r12,r6[0x0]
800034a0:	f0 1f 01 d9 	mcall	80003c04 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800034a4:	fe f8 07 2c 	ld.w	r8,pc[1836]
800034a8:	70 0c       	ld.w	r12,r8[0x0]
800034aa:	f0 1f 01 c4 	mcall	80003bb8 <phy_rx_func+0xe98>
800034ae:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800034b0:	c0 71       	brne	800034be <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
800034b2:	30 09       	mov	r9,0
800034b4:	fe f8 07 28 	ld.w	r8,pc[1832]
800034b8:	91 09       	st.w	r8[0x0],r9
800034ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800034be:	fe f9 07 26 	ld.w	r9,pc[1830]
800034c2:	72 08       	ld.w	r8,r9[0x0]
800034c4:	20 18       	sub	r8,1
800034c6:	93 08       	st.w	r9[0x0],r8
800034c8:	c0 71       	brne	800034d6 <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
800034ca:	30 09       	mov	r9,0
800034cc:	fe f8 07 10 	ld.w	r8,pc[1808]
800034d0:	91 09       	st.w	r8[0x0],r9
800034d2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
800034d6:	fe f8 07 26 	ld.w	r8,pc[1830]
800034da:	fe f9 06 fe 	ld.w	r9,pc[1790]
800034de:	72 0a       	ld.w	r10,r9[0x0]
800034e0:	70 09       	ld.w	r9,r8[0x0]
800034e2:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800034e6:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800034ea:	70 09       	ld.w	r9,r8[0x0]
800034ec:	2f f9       	sub	r9,-1
800034ee:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800034f0:	e0 49 01 ff 	cp.w	r9,511
800034f4:	e0 88 00 16 	brls	80003520 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
800034f8:	30 09       	mov	r9,0
800034fa:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800034fc:	fe f6 06 dc 	ld.w	r6,pc[1756]
80003500:	6c 0c       	ld.w	r12,r6[0x0]
80003502:	f0 1f 01 c1 	mcall	80003c04 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003506:	fe f8 06 ca 	ld.w	r8,pc[1738]
8000350a:	70 0c       	ld.w	r12,r8[0x0]
8000350c:	f0 1f 01 ab 	mcall	80003bb8 <phy_rx_func+0xe98>
80003510:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003512:	c0 71       	brne	80003520 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
80003514:	30 09       	mov	r9,0
80003516:	fe f8 06 c6 	ld.w	r8,pc[1734]
8000351a:	91 09       	st.w	r8[0x0],r9
8000351c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003520:	fe f9 06 c4 	ld.w	r9,pc[1732]
80003524:	72 08       	ld.w	r8,r9[0x0]
80003526:	20 18       	sub	r8,1
80003528:	93 08       	st.w	r9[0x0],r8
8000352a:	c0 71       	brne	80003538 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
8000352c:	30 09       	mov	r9,0
8000352e:	fe f8 06 ae 	ld.w	r8,pc[1710]
80003532:	91 09       	st.w	r8[0x0],r9
80003534:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003538:	fe f8 06 c4 	ld.w	r8,pc[1732]
8000353c:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003540:	72 0a       	ld.w	r10,r9[0x0]
80003542:	70 09       	ld.w	r9,r8[0x0]
80003544:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003548:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000354c:	70 09       	ld.w	r9,r8[0x0]
8000354e:	2f f9       	sub	r9,-1
80003550:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003552:	e0 49 01 ff 	cp.w	r9,511
80003556:	e0 88 00 16 	brls	80003582 <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
8000355a:	30 09       	mov	r9,0
8000355c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000355e:	fe f6 06 7a 	ld.w	r6,pc[1658]
80003562:	6c 0c       	ld.w	r12,r6[0x0]
80003564:	f0 1f 01 a8 	mcall	80003c04 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003568:	fe f8 06 68 	ld.w	r8,pc[1640]
8000356c:	70 0c       	ld.w	r12,r8[0x0]
8000356e:	f0 1f 01 93 	mcall	80003bb8 <phy_rx_func+0xe98>
80003572:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003574:	c0 71       	brne	80003582 <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80003576:	30 09       	mov	r9,0
80003578:	fe f8 06 64 	ld.w	r8,pc[1636]
8000357c:	91 09       	st.w	r8[0x0],r9
8000357e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003582:	fe f9 06 62 	ld.w	r9,pc[1634]
80003586:	72 08       	ld.w	r8,r9[0x0]
80003588:	20 18       	sub	r8,1
8000358a:	93 08       	st.w	r9[0x0],r8
8000358c:	c0 71       	brne	8000359a <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
8000358e:	30 09       	mov	r9,0
80003590:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003594:	91 09       	st.w	r8[0x0],r9
80003596:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
8000359a:	fe f8 06 62 	ld.w	r8,pc[1634]
8000359e:	fe f9 06 3a 	ld.w	r9,pc[1594]
800035a2:	72 0a       	ld.w	r10,r9[0x0]
800035a4:	70 09       	ld.w	r9,r8[0x0]
800035a6:	ef 3b 00 0d 	ld.ub	r11,r7[13]
800035aa:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800035ae:	70 09       	ld.w	r9,r8[0x0]
800035b0:	2f f9       	sub	r9,-1
800035b2:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035b4:	e0 49 01 ff 	cp.w	r9,511
800035b8:	e0 88 00 16 	brls	800035e4 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
800035bc:	30 09       	mov	r9,0
800035be:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035c0:	fe f6 06 18 	ld.w	r6,pc[1560]
800035c4:	6c 0c       	ld.w	r12,r6[0x0]
800035c6:	f0 1f 01 90 	mcall	80003c04 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800035ca:	fe f8 06 06 	ld.w	r8,pc[1542]
800035ce:	70 0c       	ld.w	r12,r8[0x0]
800035d0:	f0 1f 01 7a 	mcall	80003bb8 <phy_rx_func+0xe98>
800035d4:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035d6:	c0 71       	brne	800035e4 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
800035d8:	30 09       	mov	r9,0
800035da:	fe f8 06 02 	ld.w	r8,pc[1538]
800035de:	91 09       	st.w	r8[0x0],r9
800035e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035e4:	fe f9 06 00 	ld.w	r9,pc[1536]
800035e8:	72 08       	ld.w	r8,r9[0x0]
800035ea:	20 18       	sub	r8,1
800035ec:	93 08       	st.w	r9[0x0],r8
800035ee:	c0 71       	brne	800035fc <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
800035f0:	30 09       	mov	r9,0
800035f2:	fe f8 05 ea 	ld.w	r8,pc[1514]
800035f6:	91 09       	st.w	r8[0x0],r9
800035f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
800035fc:	fe f8 06 00 	ld.w	r8,pc[1536]
80003600:	fe f9 05 d8 	ld.w	r9,pc[1496]
80003604:	72 0a       	ld.w	r10,r9[0x0]
80003606:	70 09       	ld.w	r9,r8[0x0]
80003608:	ef 3b 00 0e 	ld.ub	r11,r7[14]
8000360c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003610:	70 09       	ld.w	r9,r8[0x0]
80003612:	2f f9       	sub	r9,-1
80003614:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003616:	e0 49 01 ff 	cp.w	r9,511
8000361a:	e0 88 00 16 	brls	80003646 <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
8000361e:	30 09       	mov	r9,0
80003620:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003622:	fe f6 05 b6 	ld.w	r6,pc[1462]
80003626:	6c 0c       	ld.w	r12,r6[0x0]
80003628:	f0 1f 01 77 	mcall	80003c04 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000362c:	fe f8 05 a4 	ld.w	r8,pc[1444]
80003630:	70 0c       	ld.w	r12,r8[0x0]
80003632:	f0 1f 01 62 	mcall	80003bb8 <phy_rx_func+0xe98>
80003636:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003638:	c0 71       	brne	80003646 <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
8000363a:	30 09       	mov	r9,0
8000363c:	fe f8 05 a0 	ld.w	r8,pc[1440]
80003640:	91 09       	st.w	r8[0x0],r9
80003642:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003646:	fe f9 05 9e 	ld.w	r9,pc[1438]
8000364a:	72 08       	ld.w	r8,r9[0x0]
8000364c:	20 18       	sub	r8,1
8000364e:	93 08       	st.w	r9[0x0],r8
80003650:	c0 71       	brne	8000365e <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
80003652:	30 09       	mov	r9,0
80003654:	fe f8 05 88 	ld.w	r8,pc[1416]
80003658:	91 09       	st.w	r8[0x0],r9
8000365a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
8000365e:	fe f8 05 9e 	ld.w	r8,pc[1438]
80003662:	fe f9 05 76 	ld.w	r9,pc[1398]
80003666:	72 0a       	ld.w	r10,r9[0x0]
80003668:	70 09       	ld.w	r9,r8[0x0]
8000366a:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000366e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003672:	70 09       	ld.w	r9,r8[0x0]
80003674:	2f f9       	sub	r9,-1
80003676:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003678:	e0 49 01 ff 	cp.w	r9,511
8000367c:	e0 88 00 16 	brls	800036a8 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003680:	30 09       	mov	r9,0
80003682:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003684:	fe f7 05 54 	ld.w	r7,pc[1364]
80003688:	6e 0c       	ld.w	r12,r7[0x0]
8000368a:	f0 1f 01 5f 	mcall	80003c04 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000368e:	fe f8 05 42 	ld.w	r8,pc[1346]
80003692:	70 0c       	ld.w	r12,r8[0x0]
80003694:	f0 1f 01 49 	mcall	80003bb8 <phy_rx_func+0xe98>
80003698:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000369a:	c0 71       	brne	800036a8 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
8000369c:	30 09       	mov	r9,0
8000369e:	fe f8 05 3e 	ld.w	r8,pc[1342]
800036a2:	91 09       	st.w	r8[0x0],r9
800036a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800036a8:	fe f9 05 3c 	ld.w	r9,pc[1340]
800036ac:	72 08       	ld.w	r8,r9[0x0]
800036ae:	20 18       	sub	r8,1
800036b0:	93 08       	st.w	r9[0x0],r8
800036b2:	e0 81 02 74 	brne	80003b9a <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
800036b6:	30 09       	mov	r9,0
800036b8:	fe f8 05 24 	ld.w	r8,pc[1316]
800036bc:	91 09       	st.w	r8[0x0],r9
800036be:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
800036c2:	30 09       	mov	r9,0
800036c4:	fe f8 05 18 	ld.w	r8,pc[1304]
800036c8:	91 09       	st.w	r8[0x0],r9
800036ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
800036ce:	fe f8 05 26 	ld.w	r8,pc[1318]
800036d2:	11 89       	ld.ub	r9,r8[0x0]
800036d4:	3f 28       	mov	r8,-14
800036d6:	f0 09 18 00 	cp.b	r9,r8
800036da:	c4 31       	brne	80003760 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
800036dc:	8e 49       	ld.sh	r9,r7[0x8]
800036de:	fe f8 05 56 	ld.w	r8,pc[1366]
800036e2:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
800036e4:	fe f8 05 18 	ld.w	r8,pc[1304]
800036e8:	fe f9 04 f0 	ld.w	r9,pc[1264]
800036ec:	72 0a       	ld.w	r10,r9[0x0]
800036ee:	70 09       	ld.w	r9,r8[0x0]
800036f0:	ef 3b 00 08 	ld.ub	r11,r7[8]
800036f4:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800036f8:	70 09       	ld.w	r9,r8[0x0]
800036fa:	2f f9       	sub	r9,-1
800036fc:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036fe:	e0 49 01 ff 	cp.w	r9,511
80003702:	e0 88 00 16 	brls	8000372e <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003706:	30 09       	mov	r9,0
80003708:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000370a:	fe f7 04 ce 	ld.w	r7,pc[1230]
8000370e:	6e 0c       	ld.w	r12,r7[0x0]
80003710:	f0 1f 01 3d 	mcall	80003c04 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003714:	fe f8 04 bc 	ld.w	r8,pc[1212]
80003718:	70 0c       	ld.w	r12,r8[0x0]
8000371a:	f0 1f 01 28 	mcall	80003bb8 <phy_rx_func+0xe98>
8000371e:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003720:	c0 71       	brne	8000372e <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
80003722:	30 09       	mov	r9,0
80003724:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003728:	91 09       	st.w	r8[0x0],r9
8000372a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000372e:	fe f9 04 b6 	ld.w	r9,pc[1206]
80003732:	72 08       	ld.w	r8,r9[0x0]
80003734:	20 18       	sub	r8,1
80003736:	93 08       	st.w	r9[0x0],r8
80003738:	c0 71       	brne	80003746 <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
8000373a:	30 09       	mov	r9,0
8000373c:	fe f8 04 a0 	ld.w	r8,pc[1184]
80003740:	91 09       	st.w	r8[0x0],r9
80003742:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003746:	20 18       	sub	r8,1
80003748:	fe f9 04 9c 	ld.w	r9,pc[1180]
8000374c:	93 08       	st.w	r9[0x0],r8
8000374e:	58 08       	cp.w	r8,0
80003750:	e0 81 02 25 	brne	80003b9a <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80003754:	30 09       	mov	r9,0
80003756:	fe f8 04 86 	ld.w	r8,pc[1158]
8000375a:	91 09       	st.w	r8[0x0],r9
8000375c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003760:	fe f8 04 94 	ld.w	r8,pc[1172]
80003764:	11 89       	ld.ub	r9,r8[0x0]
80003766:	3f 38       	mov	r8,-13
80003768:	f0 09 18 00 	cp.b	r9,r8
8000376c:	e0 81 01 0c 	brne	80003984 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003770:	8e 49       	ld.sh	r9,r7[0x8]
80003772:	fe f8 04 c2 	ld.w	r8,pc[1218]
80003776:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003778:	8e 59       	ld.sh	r9,r7[0xa]
8000377a:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
8000377c:	8e 69       	ld.sh	r9,r7[0xc]
8000377e:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003780:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003784:	fe f9 04 54 	ld.w	r9,pc[1108]
80003788:	72 0a       	ld.w	r10,r9[0x0]
8000378a:	70 09       	ld.w	r9,r8[0x0]
8000378c:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003790:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003794:	70 09       	ld.w	r9,r8[0x0]
80003796:	2f f9       	sub	r9,-1
80003798:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000379a:	e0 49 01 ff 	cp.w	r9,511
8000379e:	e0 88 00 16 	brls	800037ca <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
800037a2:	30 09       	mov	r9,0
800037a4:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800037a6:	fe f6 04 32 	ld.w	r6,pc[1074]
800037aa:	6c 0c       	ld.w	r12,r6[0x0]
800037ac:	f0 1f 01 16 	mcall	80003c04 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800037b0:	fe f8 04 20 	ld.w	r8,pc[1056]
800037b4:	70 0c       	ld.w	r12,r8[0x0]
800037b6:	f0 1f 01 01 	mcall	80003bb8 <phy_rx_func+0xe98>
800037ba:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800037bc:	c0 71       	brne	800037ca <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
800037be:	30 09       	mov	r9,0
800037c0:	fe f8 04 1c 	ld.w	r8,pc[1052]
800037c4:	91 09       	st.w	r8[0x0],r9
800037c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800037ca:	fe f9 04 1a 	ld.w	r9,pc[1050]
800037ce:	72 08       	ld.w	r8,r9[0x0]
800037d0:	20 18       	sub	r8,1
800037d2:	93 08       	st.w	r9[0x0],r8
800037d4:	c0 71       	brne	800037e2 <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
800037d6:	30 09       	mov	r9,0
800037d8:	fe f8 04 04 	ld.w	r8,pc[1028]
800037dc:	91 09       	st.w	r8[0x0],r9
800037de:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
800037e2:	fe f8 04 1a 	ld.w	r8,pc[1050]
800037e6:	fe f9 03 f2 	ld.w	r9,pc[1010]
800037ea:	72 0a       	ld.w	r10,r9[0x0]
800037ec:	70 09       	ld.w	r9,r8[0x0]
800037ee:	ef 3b 00 09 	ld.ub	r11,r7[9]
800037f2:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800037f6:	70 09       	ld.w	r9,r8[0x0]
800037f8:	2f f9       	sub	r9,-1
800037fa:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037fc:	e0 49 01 ff 	cp.w	r9,511
80003800:	e0 88 00 16 	brls	8000382c <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
80003804:	30 09       	mov	r9,0
80003806:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003808:	fe f6 03 d0 	ld.w	r6,pc[976]
8000380c:	6c 0c       	ld.w	r12,r6[0x0]
8000380e:	f0 1f 00 fe 	mcall	80003c04 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003812:	fe f8 03 be 	ld.w	r8,pc[958]
80003816:	70 0c       	ld.w	r12,r8[0x0]
80003818:	f0 1f 00 e8 	mcall	80003bb8 <phy_rx_func+0xe98>
8000381c:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000381e:	c0 71       	brne	8000382c <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
80003820:	30 09       	mov	r9,0
80003822:	fe f8 03 ba 	ld.w	r8,pc[954]
80003826:	91 09       	st.w	r8[0x0],r9
80003828:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000382c:	fe f9 03 b8 	ld.w	r9,pc[952]
80003830:	72 08       	ld.w	r8,r9[0x0]
80003832:	20 18       	sub	r8,1
80003834:	93 08       	st.w	r9[0x0],r8
80003836:	c0 71       	brne	80003844 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80003838:	30 09       	mov	r9,0
8000383a:	fe f8 03 a2 	ld.w	r8,pc[930]
8000383e:	91 09       	st.w	r8[0x0],r9
80003840:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003844:	fe f8 03 b8 	ld.w	r8,pc[952]
80003848:	fe f9 03 90 	ld.w	r9,pc[912]
8000384c:	72 0a       	ld.w	r10,r9[0x0]
8000384e:	70 09       	ld.w	r9,r8[0x0]
80003850:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003854:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003858:	70 09       	ld.w	r9,r8[0x0]
8000385a:	2f f9       	sub	r9,-1
8000385c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000385e:	e0 49 01 ff 	cp.w	r9,511
80003862:	e0 88 00 16 	brls	8000388e <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003866:	30 09       	mov	r9,0
80003868:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000386a:	fe f6 03 6e 	ld.w	r6,pc[878]
8000386e:	6c 0c       	ld.w	r12,r6[0x0]
80003870:	f0 1f 00 e5 	mcall	80003c04 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003874:	fe f8 03 5c 	ld.w	r8,pc[860]
80003878:	70 0c       	ld.w	r12,r8[0x0]
8000387a:	f0 1f 00 d0 	mcall	80003bb8 <phy_rx_func+0xe98>
8000387e:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003880:	c0 71       	brne	8000388e <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
80003882:	30 09       	mov	r9,0
80003884:	fe f8 03 58 	ld.w	r8,pc[856]
80003888:	91 09       	st.w	r8[0x0],r9
8000388a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000388e:	fe f9 03 56 	ld.w	r9,pc[854]
80003892:	72 08       	ld.w	r8,r9[0x0]
80003894:	20 18       	sub	r8,1
80003896:	93 08       	st.w	r9[0x0],r8
80003898:	c0 71       	brne	800038a6 <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
8000389a:	30 09       	mov	r9,0
8000389c:	fe f8 03 40 	ld.w	r8,pc[832]
800038a0:	91 09       	st.w	r8[0x0],r9
800038a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
800038a6:	fe f8 03 56 	ld.w	r8,pc[854]
800038aa:	fe f9 03 2e 	ld.w	r9,pc[814]
800038ae:	72 0a       	ld.w	r10,r9[0x0]
800038b0:	70 09       	ld.w	r9,r8[0x0]
800038b2:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800038b6:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800038ba:	70 09       	ld.w	r9,r8[0x0]
800038bc:	2f f9       	sub	r9,-1
800038be:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038c0:	e0 49 01 ff 	cp.w	r9,511
800038c4:	e0 88 00 16 	brls	800038f0 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
800038c8:	30 09       	mov	r9,0
800038ca:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800038cc:	fe f6 03 0c 	ld.w	r6,pc[780]
800038d0:	6c 0c       	ld.w	r12,r6[0x0]
800038d2:	f0 1f 00 cd 	mcall	80003c04 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800038d6:	fe f8 02 fa 	ld.w	r8,pc[762]
800038da:	70 0c       	ld.w	r12,r8[0x0]
800038dc:	f0 1f 00 b7 	mcall	80003bb8 <phy_rx_func+0xe98>
800038e0:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038e2:	c0 71       	brne	800038f0 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
800038e4:	30 09       	mov	r9,0
800038e6:	fe f8 02 f6 	ld.w	r8,pc[758]
800038ea:	91 09       	st.w	r8[0x0],r9
800038ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038f0:	fe f9 02 f4 	ld.w	r9,pc[756]
800038f4:	72 08       	ld.w	r8,r9[0x0]
800038f6:	20 18       	sub	r8,1
800038f8:	93 08       	st.w	r9[0x0],r8
800038fa:	c0 71       	brne	80003908 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
800038fc:	30 09       	mov	r9,0
800038fe:	fe f8 02 de 	ld.w	r8,pc[734]
80003902:	91 09       	st.w	r8[0x0],r9
80003904:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003908:	fe f8 02 f4 	ld.w	r8,pc[756]
8000390c:	fe f9 02 cc 	ld.w	r9,pc[716]
80003910:	72 0a       	ld.w	r10,r9[0x0]
80003912:	70 09       	ld.w	r9,r8[0x0]
80003914:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003918:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000391c:	70 09       	ld.w	r9,r8[0x0]
8000391e:	2f f9       	sub	r9,-1
80003920:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003922:	e0 49 01 ff 	cp.w	r9,511
80003926:	e0 88 00 16 	brls	80003952 <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
8000392a:	30 09       	mov	r9,0
8000392c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000392e:	fe f7 02 aa 	ld.w	r7,pc[682]
80003932:	6e 0c       	ld.w	r12,r7[0x0]
80003934:	f0 1f 00 b4 	mcall	80003c04 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003938:	fe f8 02 98 	ld.w	r8,pc[664]
8000393c:	70 0c       	ld.w	r12,r8[0x0]
8000393e:	f0 1f 00 9f 	mcall	80003bb8 <phy_rx_func+0xe98>
80003942:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003944:	c0 71       	brne	80003952 <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80003946:	30 09       	mov	r9,0
80003948:	fe f8 02 94 	ld.w	r8,pc[660]
8000394c:	91 09       	st.w	r8[0x0],r9
8000394e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003952:	fe f9 02 92 	ld.w	r9,pc[658]
80003956:	72 08       	ld.w	r8,r9[0x0]
80003958:	20 18       	sub	r8,1
8000395a:	93 08       	st.w	r9[0x0],r8
8000395c:	c0 71       	brne	8000396a <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
8000395e:	30 09       	mov	r9,0
80003960:	fe f8 02 7c 	ld.w	r8,pc[636]
80003964:	91 09       	st.w	r8[0x0],r9
80003966:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
8000396a:	20 18       	sub	r8,1
8000396c:	fe f9 02 78 	ld.w	r9,pc[632]
80003970:	93 08       	st.w	r9[0x0],r8
80003972:	58 08       	cp.w	r8,0
80003974:	e0 81 01 13 	brne	80003b9a <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003978:	30 09       	mov	r9,0
8000397a:	fe f8 02 62 	ld.w	r8,pc[610]
8000397e:	91 09       	st.w	r8[0x0],r9
80003980:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003984:	fe f8 02 70 	ld.w	r8,pc[624]
80003988:	11 89       	ld.ub	r9,r8[0x0]
8000398a:	30 48       	mov	r8,4
8000398c:	f0 09 18 00 	cp.b	r9,r8
80003990:	c0 80       	breq	800039a0 <phy_rx_func+0xc80>
80003992:	fe f8 02 62 	ld.w	r8,pc[610]
80003996:	11 89       	ld.ub	r9,r8[0x0]
80003998:	30 38       	mov	r8,3
8000399a:	f0 09 18 00 	cp.b	r9,r8
8000399e:	c1 41       	brne	800039c6 <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
800039a0:	6e 29       	ld.w	r9,r7[0x8]
800039a2:	fe f8 02 7a 	ld.w	r8,pc[634]
800039a6:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
800039a8:	6e 39       	ld.w	r9,r7[0xc]
800039aa:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
800039ac:	fe f9 02 38 	ld.w	r9,pc[568]
800039b0:	72 08       	ld.w	r8,r9[0x0]
800039b2:	20 88       	sub	r8,8
800039b4:	93 08       	st.w	r9[0x0],r8
800039b6:	e0 81 00 f2 	brne	80003b9a <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
800039ba:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
800039bc:	fe f9 02 20 	ld.w	r9,pc[544]
800039c0:	93 08       	st.w	r9[0x0],r8
800039c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
800039c6:	fe f8 02 2e 	ld.w	r8,pc[558]
800039ca:	11 89       	ld.ub	r9,r8[0x0]
800039cc:	31 38       	mov	r8,19
800039ce:	f0 09 18 00 	cp.b	r9,r8
800039d2:	e0 81 00 9c 	brne	80003b0a <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
800039d6:	fe f8 02 62 	ld.w	r8,pc[610]
800039da:	11 88       	ld.ub	r8,r8[0x0]
800039dc:	30 c9       	mov	r9,12
800039de:	f2 08 18 00 	cp.b	r8,r9
800039e2:	e0 81 00 7b 	brne	80003ad8 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
800039e6:	8e 49       	ld.sh	r9,r7[0x8]
800039e8:	fe f8 02 54 	ld.w	r8,pc[596]
800039ec:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
800039f0:	30 09       	mov	r9,0
800039f2:	fe f8 02 46 	ld.w	r8,pc[582]
800039f6:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800039f8:	ef 39 00 0d 	ld.ub	r9,r7[13]
800039fc:	3f 38       	mov	r8,-13
800039fe:	f0 09 18 00 	cp.b	r9,r8
80003a02:	c6 61       	brne	80003ace <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003a04:	10 99       	mov	r9,r8
80003a06:	4f c8       	lddpc	r8,80003bf4 <phy_rx_func+0xed4>
80003a08:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003a0a:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003a0e:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003a12:	4f 58       	lddpc	r8,80003be4 <phy_rx_func+0xec4>
80003a14:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003a16:	30 19       	mov	r9,1
80003a18:	fe f8 02 0c 	ld.w	r8,pc[524]
80003a1c:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003a1e:	8e 79       	ld.sh	r9,r7[0xe]
80003a20:	fe f8 02 14 	ld.w	r8,pc[532]
80003a24:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003a26:	4f 68       	lddpc	r8,80003bfc <phy_rx_func+0xedc>
80003a28:	4e c9       	lddpc	r9,80003bd8 <phy_rx_func+0xeb8>
80003a2a:	72 0a       	ld.w	r10,r9[0x0]
80003a2c:	70 09       	ld.w	r9,r8[0x0]
80003a2e:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003a32:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003a36:	70 09       	ld.w	r9,r8[0x0]
80003a38:	2f f9       	sub	r9,-1
80003a3a:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a3c:	e0 49 01 ff 	cp.w	r9,511
80003a40:	e0 88 00 13 	brls	80003a66 <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003a44:	30 09       	mov	r9,0
80003a46:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003a48:	4e 46       	lddpc	r6,80003bd8 <phy_rx_func+0xeb8>
80003a4a:	6c 0c       	ld.w	r12,r6[0x0]
80003a4c:	f0 1f 00 6e 	mcall	80003c04 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003a50:	4e 08       	lddpc	r8,80003bd0 <phy_rx_func+0xeb0>
80003a52:	70 0c       	ld.w	r12,r8[0x0]
80003a54:	f0 1f 00 59 	mcall	80003bb8 <phy_rx_func+0xe98>
80003a58:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003a5a:	c0 61       	brne	80003a66 <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003a5c:	30 09       	mov	r9,0
80003a5e:	4e 08       	lddpc	r8,80003bdc <phy_rx_func+0xebc>
80003a60:	91 09       	st.w	r8[0x0],r9
80003a62:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003a66:	4e 09       	lddpc	r9,80003be4 <phy_rx_func+0xec4>
80003a68:	72 08       	ld.w	r8,r9[0x0]
80003a6a:	20 18       	sub	r8,1
80003a6c:	93 08       	st.w	r9[0x0],r8
80003a6e:	c0 61       	brne	80003a7a <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003a70:	30 09       	mov	r9,0
80003a72:	4d b8       	lddpc	r8,80003bdc <phy_rx_func+0xebc>
80003a74:	91 09       	st.w	r8[0x0],r9
80003a76:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003a7a:	4e 18       	lddpc	r8,80003bfc <phy_rx_func+0xedc>
80003a7c:	4d 79       	lddpc	r9,80003bd8 <phy_rx_func+0xeb8>
80003a7e:	72 0a       	ld.w	r10,r9[0x0]
80003a80:	70 09       	ld.w	r9,r8[0x0]
80003a82:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003a86:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003a8a:	70 09       	ld.w	r9,r8[0x0]
80003a8c:	2f f9       	sub	r9,-1
80003a8e:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a90:	e0 49 01 ff 	cp.w	r9,511
80003a94:	e0 88 00 13 	brls	80003aba <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003a98:	30 09       	mov	r9,0
80003a9a:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003a9c:	4c f7       	lddpc	r7,80003bd8 <phy_rx_func+0xeb8>
80003a9e:	6e 0c       	ld.w	r12,r7[0x0]
80003aa0:	f0 1f 00 59 	mcall	80003c04 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003aa4:	4c b8       	lddpc	r8,80003bd0 <phy_rx_func+0xeb0>
80003aa6:	70 0c       	ld.w	r12,r8[0x0]
80003aa8:	f0 1f 00 44 	mcall	80003bb8 <phy_rx_func+0xe98>
80003aac:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003aae:	c0 61       	brne	80003aba <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003ab0:	30 09       	mov	r9,0
80003ab2:	4c b8       	lddpc	r8,80003bdc <phy_rx_func+0xebc>
80003ab4:	91 09       	st.w	r8[0x0],r9
80003ab6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003aba:	4c b9       	lddpc	r9,80003be4 <phy_rx_func+0xec4>
80003abc:	72 08       	ld.w	r8,r9[0x0]
80003abe:	20 18       	sub	r8,1
80003ac0:	93 08       	st.w	r9[0x0],r8
80003ac2:	c6 c1       	brne	80003b9a <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003ac4:	30 09       	mov	r9,0
80003ac6:	4c 68       	lddpc	r8,80003bdc <phy_rx_func+0xebc>
80003ac8:	91 09       	st.w	r8[0x0],r9
80003aca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003ace:	30 09       	mov	r9,0
80003ad0:	4c 38       	lddpc	r8,80003bdc <phy_rx_func+0xebc>
80003ad2:	91 09       	st.w	r8[0x0],r9
80003ad4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003ad8:	8e 4a       	ld.sh	r10,r7[0x8]
80003ada:	4d 99       	lddpc	r9,80003c3c <phy_rx_func+0xf1c>
80003adc:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003ae0:	4d 6a       	lddpc	r10,80003c38 <phy_rx_func+0xf18>
80003ae2:	15 88       	ld.ub	r8,r10[0x0]
80003ae4:	f0 cb ff ff 	sub	r11,r8,-1
80003ae8:	8e 5c       	ld.sh	r12,r7[0xa]
80003aea:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003aee:	f0 cb ff fe 	sub	r11,r8,-2
80003af2:	8e 6c       	ld.sh	r12,r7[0xc]
80003af4:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003af8:	f0 cb ff fd 	sub	r11,r8,-3
80003afc:	8e 7c       	ld.sh	r12,r7[0xe]
80003afe:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003b02:	2f c8       	sub	r8,-4
80003b04:	b4 88       	st.b	r10[0x0],r8
80003b06:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003b0a:	30 09       	mov	r9,0
80003b0c:	4b 48       	lddpc	r8,80003bdc <phy_rx_func+0xebc>
80003b0e:	91 09       	st.w	r8[0x0],r9
80003b10:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003b14:	4c 08       	lddpc	r8,80003c14 <phy_rx_func+0xef4>
80003b16:	70 09       	ld.w	r9,r8[0x0]
80003b18:	8e 4b       	ld.sh	r11,r7[0x8]
80003b1a:	4c 0a       	lddpc	r10,80003c18 <phy_rx_func+0xef8>
80003b1c:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003b20:	2f f9       	sub	r9,-1
80003b22:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003b24:	4b 58       	lddpc	r8,80003bf8 <phy_rx_func+0xed8>
80003b26:	70 09       	ld.w	r9,r8[0x0]
80003b28:	20 29       	sub	r9,2
80003b2a:	91 09       	st.w	r8[0x0],r9
80003b2c:	70 08       	ld.w	r8,r8[0x0]
80003b2e:	58 08       	cp.w	r8,0
80003b30:	c2 f1       	brne	80003b8e <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003b32:	30 09       	mov	r9,0
80003b34:	4b 88       	lddpc	r8,80003c14 <phy_rx_func+0xef4>
80003b36:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003b38:	8e 59       	ld.sh	r9,r7[0xa]
80003b3a:	fe 78 82 12 	mov	r8,-32238
80003b3e:	f0 09 19 00 	cp.h	r9,r8
80003b42:	c2 11       	brne	80003b84 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003b44:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003b48:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003b4c:	4a f8       	lddpc	r8,80003c08 <phy_rx_func+0xee8>
80003b4e:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003b50:	8e 59       	ld.sh	r9,r7[0xa]
80003b52:	4a f8       	lddpc	r8,80003c0c <phy_rx_func+0xeec>
80003b54:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003b56:	8e 69       	ld.sh	r9,r7[0xc]
80003b58:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003b5a:	f0 1f 00 2e 	mcall	80003c10 <phy_rx_func+0xef0>
80003b5e:	4a 18       	lddpc	r8,80003be0 <phy_rx_func+0xec0>
80003b60:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003b62:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003b66:	31 38       	mov	r8,19
80003b68:	f0 09 18 00 	cp.b	r9,r8
80003b6c:	c0 71       	brne	80003b7a <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003b6e:	10 99       	mov	r9,r8
80003b70:	4a 18       	lddpc	r8,80003bf4 <phy_rx_func+0xed4>
80003b72:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003b74:	30 09       	mov	r9,0
80003b76:	49 c8       	lddpc	r8,80003be4 <phy_rx_func+0xec4>
80003b78:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003b7a:	30 49       	mov	r9,4
80003b7c:	49 88       	lddpc	r8,80003bdc <phy_rx_func+0xebc>
80003b7e:	91 09       	st.w	r8[0x0],r9
80003b80:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003b84:	30 09       	mov	r9,0
80003b86:	49 68       	lddpc	r8,80003bdc <phy_rx_func+0xebc>
80003b88:	91 09       	st.w	r8[0x0],r9
80003b8a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003b8e:	4a dc       	lddpc	r12,80003c40 <phy_rx_func+0xf20>
80003b90:	f0 1f 00 18 	mcall	80003bf0 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003b94:	30 09       	mov	r9,0
80003b96:	49 28       	lddpc	r8,80003bdc <phy_rx_func+0xebc>
80003b98:	91 09       	st.w	r8[0x0],r9
80003b9a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003b9e:	00 00       	add	r0,r0
80003ba0:	00 00       	add	r0,r0
80003ba2:	0a ac       	st.w	r5++,r12
80003ba4:	00 00       	add	r0,r0
80003ba6:	0a c4       	st.b	r5++,r4
80003ba8:	00 00       	add	r0,r0
80003baa:	0a a4       	st.w	r5++,r4
80003bac:	00 00       	add	r0,r0
80003bae:	0a 86       	andn	r6,r5
80003bb0:	00 00       	add	r0,r0
80003bb2:	0a 74       	tst	r4,r5
80003bb4:	00 00       	add	r0,r0
80003bb6:	0a 9c       	mov	r12,r5
80003bb8:	80 00       	ld.sh	r0,r0[0x0]
80003bba:	2b a0       	sub	r0,-70
80003bbc:	00 00       	add	r0,r0
80003bbe:	0a 94       	mov	r4,r5
80003bc0:	80 00       	ld.sh	r0,r0[0x0]
80003bc2:	2a b8       	sub	r8,-85
80003bc4:	00 00       	add	r0,r0
80003bc6:	0a a8       	st.w	r5++,r8
80003bc8:	80 00       	ld.sh	r0,r0[0x0]
80003bca:	2a ec       	sub	r12,-82
80003bcc:	00 00       	add	r0,r0
80003bce:	0a 85       	andn	r5,r5
80003bd0:	00 00       	add	r0,r0
80003bd2:	0a a0       	st.w	r5++,r0
80003bd4:	00 00       	add	r0,r0
80003bd6:	0a b0       	st.h	r5++,r0
80003bd8:	00 00       	add	r0,r0
80003bda:	0a 88       	andn	r8,r5
80003bdc:	00 00       	add	r0,r0
80003bde:	0a d0       	st.w	--r5,r0
80003be0:	00 00       	add	r0,r0
80003be2:	0a b8       	st.h	r5++,r8
80003be4:	00 00       	add	r0,r0
80003be6:	0a 70       	tst	r0,r5
80003be8:	00 00       	add	r0,r0
80003bea:	0a 4c       	or	r12,r5
80003bec:	80 00       	ld.sh	r0,r0[0x0]
80003bee:	d5 b4       	*unknown*
80003bf0:	80 00       	ld.sh	r0,r0[0x0]
80003bf2:	6f b4       	ld.w	r4,r7[0x6c]
80003bf4:	00 00       	add	r0,r0
80003bf6:	0a 84       	andn	r4,r5
80003bf8:	00 00       	add	r0,r0
80003bfa:	0a dc       	st.w	--r5,r12
80003bfc:	00 00       	add	r0,r0
80003bfe:	0a bc       	st.h	r5++,r12
80003c00:	80 00       	ld.sh	r0,r0[0x0]
80003c02:	77 ec       	ld.w	r12,r11[0x78]
80003c04:	80 00       	ld.sh	r0,r0[0x0]
80003c06:	2a d4       	sub	r4,-83
80003c08:	00 00       	add	r0,r0
80003c0a:	0a 44       	or	r4,r5
80003c0c:	00 00       	add	r0,r0
80003c0e:	1e ac       	st.w	pc++,r12
80003c10:	80 00       	ld.sh	r0,r0[0x0]
80003c12:	2a 88       	sub	r8,-88
80003c14:	00 00       	add	r0,r0
80003c16:	0a 78       	tst	r8,r5
80003c18:	00 00       	add	r0,r0
80003c1a:	1d b0       	ld.ub	r0,lr[0x3]
80003c1c:	00 00       	add	r0,r0
80003c1e:	0a 7c       	tst	r12,r5
80003c20:	00 00       	add	r0,r0
80003c22:	0a 45       	or	r5,r5
80003c24:	00 00       	add	r0,r0
80003c26:	0a 43       	or	r3,r5
80003c28:	00 00       	add	r0,r0
80003c2a:	0a d4       	st.w	--r5,r4
80003c2c:	00 00       	add	r0,r0
80003c2e:	0a 90       	mov	r0,r5
80003c30:	00 00       	add	r0,r0
80003c32:	0a 5d       	eor	sp,r5
80003c34:	00 00       	add	r0,r0
80003c36:	1d a8       	ld.ub	r8,lr[0x2]
80003c38:	00 00       	add	r0,r0
80003c3a:	0a c8       	st.b	r5++,r8
80003c3c:	00 00       	add	r0,r0
80003c3e:	1e b0       	st.h	pc++,r0
80003c40:	80 00       	ld.sh	r0,r0[0x0]
80003c42:	d5 cc       	*unknown*

80003c44 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003c44:	d4 01       	pushm	lr
	//xHigherPriorityTaskWoken = pdFALSE;
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
80003c46:	49 a8       	lddpc	r8,80003cac <pdca_int_handler+0x68>
80003c48:	70 09       	ld.w	r9,r8[0x0]
80003c4a:	2f f9       	sub	r9,-1
80003c4c:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003c4e:	49 98       	lddpc	r8,80003cb0 <pdca_int_handler+0x6c>
80003c50:	11 89       	ld.ub	r9,r8[0x0]
80003c52:	ec 19 00 01 	eorl	r9,0x1
80003c56:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003c58:	11 89       	ld.ub	r9,r8[0x0]
80003c5a:	a5 69       	lsl	r9,0x4
80003c5c:	2f c9       	sub	r9,-4
80003c5e:	49 6a       	lddpc	r10,80003cb4 <pdca_int_handler+0x70>
80003c60:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003c62:	fe 7a 00 40 	mov	r10,-65472
80003c66:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003c68:	30 39       	mov	r9,3
80003c6a:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003c6c:	11 8a       	ld.ub	r10,r8[0x0]
80003c6e:	a5 6a       	lsl	r10,0x4
80003c70:	2f ca       	sub	r10,-4
80003c72:	49 28       	lddpc	r8,80003cb8 <pdca_int_handler+0x74>
80003c74:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003c76:	fe 78 00 00 	mov	r8,-65536
80003c7a:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003c7c:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003c7e:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003c80:	48 f8       	lddpc	r8,80003cbc <pdca_int_handler+0x78>
80003c82:	70 08       	ld.w	r8,r8[0x0]
80003c84:	58 08       	cp.w	r8,0
80003c86:	c0 70       	breq	80003c94 <pdca_int_handler+0x50>
80003c88:	48 a9       	lddpc	r9,80003cb0 <pdca_int_handler+0x6c>
80003c8a:	13 89       	ld.ub	r9,r9[0x0]
80003c8c:	a5 69       	lsl	r9,0x4
80003c8e:	48 bc       	lddpc	r12,80003cb8 <pdca_int_handler+0x74>
80003c90:	12 0c       	add	r12,r9
80003c92:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003c94:	48 b8       	lddpc	r8,80003cc0 <pdca_int_handler+0x7c>
80003c96:	70 08       	ld.w	r8,r8[0x0]
80003c98:	58 08       	cp.w	r8,0
80003c9a:	c0 70       	breq	80003ca8 <pdca_int_handler+0x64>
80003c9c:	48 59       	lddpc	r9,80003cb0 <pdca_int_handler+0x6c>
80003c9e:	13 89       	ld.ub	r9,r9[0x0]
80003ca0:	a5 69       	lsl	r9,0x4
80003ca2:	48 5c       	lddpc	r12,80003cb4 <pdca_int_handler+0x70>
80003ca4:	12 0c       	add	r12,r9
80003ca6:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003ca8:	d4 02       	popm	lr
80003caa:	d6 03       	rete
80003cac:	00 00       	add	r0,r0
80003cae:	0a e4       	st.h	--r5,r4
80003cb0:	00 00       	add	r0,r0
80003cb2:	50 d0       	stdsp	sp[0x34],r0
80003cb4:	00 00       	add	r0,r0
80003cb6:	50 f8       	stdsp	sp[0x3c],r8
80003cb8:	00 00       	add	r0,r0
80003cba:	50 d8       	stdsp	sp[0x34],r8
80003cbc:	00 00       	add	r0,r0
80003cbe:	0a e0       	st.h	--r5,r0
80003cc0:	00 00       	add	r0,r0
80003cc2:	0a e8       	st.h	--r5,r8

80003cc4 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003cc4:	fe 78 10 00 	mov	r8,-61440
80003cc8:	e0 69 0d c0 	mov	r9,3520
80003ccc:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003cd0:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003cd4:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003cd8:	fe 78 34 00 	mov	r8,-52224
80003cdc:	e0 69 80 00 	mov	r9,32768
80003ce0:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003ce2:	30 09       	mov	r9,0
80003ce4:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003ce6:	e0 69 04 21 	mov	r9,1057
80003cea:	ea 19 3f 20 	orh	r9,0x3f20
80003cee:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80003cf0:	e0 69 02 9f 	mov	r9,671
80003cf4:	ea 19 01 00 	orh	r9,0x100
80003cf8:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80003cfa:	e0 6a 04 02 	mov	r10,1026
80003cfe:	ea 1a 3f 20 	orh	r10,0x3f20
80003d02:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80003d04:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003d06:	5e fc       	retal	r12

80003d08 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003d08:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003d0a:	30 19       	mov	r9,1
80003d0c:	49 78       	lddpc	r8,80003d68 <local_start_PDC+0x60>
80003d0e:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003d10:	fe 78 00 00 	mov	r8,-65536
80003d14:	30 7b       	mov	r11,7
80003d16:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003d18:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003d1a:	49 59       	lddpc	r9,80003d6c <local_start_PDC+0x64>
80003d1c:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003d20:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003d22:	30 3a       	mov	r10,3
80003d24:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003d26:	30 1c       	mov	r12,1
80003d28:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003d2a:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003d2c:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003d2e:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003d30:	30 2c       	mov	r12,2
80003d32:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003d34:	48 f9       	lddpc	r9,80003d70 <local_start_PDC+0x68>
80003d36:	e0 68 5a 5a 	mov	r8,23130
80003d3a:	ea 18 ab cd 	orh	r8,0xabcd
80003d3e:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003d40:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003d42:	30 0e       	mov	lr,0
80003d44:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003d46:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003d48:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003d4a:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003d4c:	fe 78 00 40 	mov	r8,-65472
80003d50:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003d52:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003d54:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003d58:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003d5a:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003d5c:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003d5e:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003d60:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003d62:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003d64:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003d66:	d8 02       	popm	pc
80003d68:	00 00       	add	r0,r0
80003d6a:	50 d0       	stdsp	sp[0x34],r0
80003d6c:	00 00       	add	r0,r0
80003d6e:	50 d8       	stdsp	sp[0x34],r8
80003d70:	00 00       	add	r0,r0
80003d72:	50 f8       	stdsp	sp[0x3c],r8

80003d74 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003d74:	48 38       	lddpc	r8,80003d80 <register_rx_tx_func+0xc>
80003d76:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003d78:	48 38       	lddpc	r8,80003d84 <register_rx_tx_func+0x10>
80003d7a:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003d7c:	5e fc       	retal	r12
80003d7e:	00 00       	add	r0,r0
80003d80:	00 00       	add	r0,r0
80003d82:	0a e0       	st.h	--r5,r0
80003d84:	00 00       	add	r0,r0
80003d86:	0a e8       	st.h	--r5,r8

80003d88 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003d88:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003d8a:	fe 78 10 00 	mov	r8,-61440
80003d8e:	30 29       	mov	r9,2
80003d90:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003d94:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80003d98:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
80003d9a:	30 3a       	mov	r10,3
80003d9c:	36 0b       	mov	r11,96
80003d9e:	49 4c       	lddpc	r12,80003dec <ssc_init+0x64>
80003da0:	f0 1f 00 14 	mcall	80003df0 <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
80003da4:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003da6:	fe 79 10 00 	mov	r9,-61440
80003daa:	f2 f8 01 60 	ld.w	r8,r9[352]
80003dae:	e2 18 00 02 	andl	r8,0x2,COH
80003db2:	cf c0       	breq	80003daa <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003db4:	fe 79 10 00 	mov	r9,-61440
80003db8:	f2 f8 01 60 	ld.w	r8,r9[352]
80003dbc:	e2 18 00 02 	andl	r8,0x2,COH
80003dc0:	cf c1       	brne	80003db8 <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
80003dc2:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80003dc4:	f0 1f 00 0c 	mcall	80003df4 <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
80003dc8:	f0 1f 00 0c 	mcall	80003df8 <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003dcc:	fe 79 00 00 	mov	r9,-65536
80003dd0:	30 18       	mov	r8,1
80003dd2:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003dd4:	fe 7a 00 40 	mov	r10,-65472
80003dd8:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003dda:	e0 6b 01 01 	mov	r11,257
80003dde:	fe 7a 34 00 	mov	r10,-52224
80003de2:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80003de4:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80003de6:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80003de8:	d8 02       	popm	pc
80003dea:	00 00       	add	r0,r0
80003dec:	80 00       	ld.sh	r0,r0[0x0]
80003dee:	3c 44       	mov	r4,-60
80003df0:	80 00       	ld.sh	r0,r0[0x0]
80003df2:	54 58       	stdsp	sp[0x114],r8
80003df4:	80 00       	ld.sh	r0,r0[0x0]
80003df6:	3c c4       	mov	r4,-52
80003df8:	80 00       	ld.sh	r0,r0[0x0]
80003dfa:	3d 08       	mov	r8,-48

80003dfc <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003dfc:	48 28       	lddpc	r8,80003e04 <xcmp_register_app_list+0x8>
80003dfe:	91 0c       	st.w	r8[0x0],r12
}
80003e00:	5e fc       	retal	r12
80003e02:	00 00       	add	r0,r0
80003e04:	00 00       	add	r0,r0
80003e06:	51 18       	stdsp	sp[0x44],r8

80003e08 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003e08:	eb cd 40 80 	pushm	r7,lr
80003e0c:	fa cd 01 00 	sub	sp,sp,256
80003e10:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003e12:	16 98       	mov	r8,r11
80003e14:	2f 08       	sub	r8,-16
80003e16:	af a8       	sbr	r8,0xe
80003e18:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003e1a:	3f f8       	mov	r8,-1
80003e1c:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003e1e:	30 b9       	mov	r9,11
80003e20:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003e22:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003e24:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003e26:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003e28:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003e2a:	f6 ca ff fe 	sub	r10,r11,-2
80003e2e:	18 9b       	mov	r11,r12
80003e30:	fa cc ff f0 	sub	r12,sp,-16
80003e34:	f0 1f 00 05 	mcall	80003e48 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003e38:	2f e7       	sub	r7,-2
80003e3a:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003e3c:	1a 9c       	mov	r12,sp
80003e3e:	f0 1f 00 04 	mcall	80003e4c <xcmp_tx+0x44>
}
80003e42:	2c 0d       	sub	sp,-256
80003e44:	e3 cd 80 80 	ldm	sp++,r7,pc
80003e48:	80 00       	ld.sh	r0,r0[0x0]
80003e4a:	76 a4       	ld.w	r4,r11[0x28]
80003e4c:	80 00       	ld.sh	r0,r0[0x0]
80003e4e:	44 14       	lddsp	r4,sp[0x104]

80003e50 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80003e50:	d4 21       	pushm	r4-r7,lr
80003e52:	fa cd 00 d0 	sub	sp,sp,208
80003e56:	18 94       	mov	r4,r12
80003e58:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003e5a:	e0 68 01 00 	mov	r8,256
80003e5e:	f0 0b 19 00 	cp.h	r11,r8
80003e62:	e0 8b 00 36 	brhi	80003ece <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003e66:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003e6a:	e0 68 04 1d 	mov	r8,1053
80003e6e:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003e70:	30 18       	mov	r8,1
80003e72:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80003e74:	32 08       	mov	r8,32
80003e76:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003e78:	30 28       	mov	r8,2
80003e7a:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003e7c:	30 48       	mov	r8,4
80003e7e:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80003e80:	ea 1a 0c 00 	orh	r10,0xc00
80003e84:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80003e86:	30 4a       	mov	r10,4
80003e88:	1a 9b       	mov	r11,sp
80003e8a:	fa cc ff f4 	sub	r12,sp,-12
80003e8e:	f0 1f 00 12 	mcall	80003ed4 <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80003e92:	30 f8       	mov	r8,15
80003e94:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80003e98:	3a 78       	mov	r8,-89
80003e9a:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80003e9e:	30 08       	mov	r8,0
80003ea0:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80003ea4:	0e 9a       	mov	r10,r7
80003ea6:	5c 7a       	castu.h	r10
80003ea8:	f4 08 16 08 	lsr	r8,r10,0x8
80003eac:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80003eb0:	0e 96       	mov	r6,r7
80003eb2:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80003eb6:	08 9b       	mov	r11,r4
80003eb8:	fa cc ff eb 	sub	r12,sp,-21
80003ebc:	f0 1f 00 06 	mcall	80003ed4 <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80003ec0:	ee cb ff f3 	sub	r11,r7,-13
80003ec4:	5c 5b       	castu.b	r11
80003ec6:	fa cc ff fa 	sub	r12,sp,-6
80003eca:	f0 1f 00 04 	mcall	80003ed8 <xcmp_data_session_req+0x88>
}
80003ece:	2c cd       	sub	sp,-208
80003ed0:	d8 22       	popm	r4-r7,pc
80003ed2:	00 00       	add	r0,r0
80003ed4:	80 00       	ld.sh	r0,r0[0x0]
80003ed6:	76 a4       	ld.w	r4,r11[0x28]
80003ed8:	80 00       	ld.sh	r0,r0[0x0]
80003eda:	3e 08       	mov	r8,-32

80003edc <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003edc:	d4 01       	pushm	lr
80003ede:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003ee2:	fe 78 b4 00 	mov	r8,-19456
80003ee6:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003ee8:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003eec:	30 89       	mov	r9,8
80003eee:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003ef0:	30 19       	mov	r9,1
80003ef2:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003ef4:	30 09       	mov	r9,0
80003ef6:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003ef8:	30 5a       	mov	r10,5
80003efa:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003efc:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003efe:	30 7a       	mov	r10,7
80003f00:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003f02:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003f04:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003f06:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003f0a:	30 9b       	mov	r11,9
80003f0c:	fa cc ff fe 	sub	r12,sp,-2
80003f10:	f0 1f 00 02 	mcall	80003f18 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003f14:	2c dd       	sub	sp,-204
80003f16:	d8 02       	popm	pc
80003f18:	80 00       	ld.sh	r0,r0[0x0]
80003f1a:	3e 08       	mov	r8,-32

80003f1c <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003f1c:	d4 01       	pushm	lr
80003f1e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003f22:	fe 78 80 00 	mov	r8,-32768
80003f26:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003f28:	30 38       	mov	r8,3
80003f2a:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80003f2c:	30 1b       	mov	r11,1
80003f2e:	fa cc ff fe 	sub	r12,sp,-2
80003f32:	f0 1f 00 03 	mcall	80003f3c <xcmp_opcode_not_supported+0x20>
}
80003f36:	2c dd       	sub	sp,-204
80003f38:	d8 02       	popm	pc
80003f3a:	00 00       	add	r0,r0
80003f3c:	80 00       	ld.sh	r0,r0[0x0]
80003f3e:	3e 08       	mov	r8,-32

80003f40 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80003f40:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80003f42:	96 88       	ld.uh	r8,r11[0x0]
80003f44:	e2 18 f0 00 	andl	r8,0xf000,COH
80003f48:	e0 48 80 00 	cp.w	r8,32768
80003f4c:	c0 f0       	breq	80003f6a <xcmp_exec_func+0x2a>
80003f4e:	e0 48 b0 00 	cp.w	r8,45056
80003f52:	c1 20       	breq	80003f76 <xcmp_exec_func+0x36>
80003f54:	58 08       	cp.w	r8,0
80003f56:	c1 51       	brne	80003f80 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80003f58:	78 08       	ld.w	r8,r12[0x0]
80003f5a:	58 08       	cp.w	r8,0
80003f5c:	c0 40       	breq	80003f64 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80003f5e:	16 9c       	mov	r12,r11
80003f60:	5d 18       	icall	r8
80003f62:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80003f64:	f0 1f 00 08 	mcall	80003f84 <xcmp_exec_func+0x44>
80003f68:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80003f6a:	78 18       	ld.w	r8,r12[0x4]
80003f6c:	58 08       	cp.w	r8,0
80003f6e:	c0 90       	breq	80003f80 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80003f70:	16 9c       	mov	r12,r11
80003f72:	5d 18       	icall	r8
80003f74:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80003f76:	78 28       	ld.w	r8,r12[0x8]
80003f78:	58 08       	cp.w	r8,0
80003f7a:	c0 30       	breq	80003f80 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80003f7c:	16 9c       	mov	r12,r11
80003f7e:	5d 18       	icall	r8
80003f80:	d8 02       	popm	pc
80003f82:	00 00       	add	r0,r0
80003f84:	80 00       	ld.sh	r0,r0[0x0]
80003f86:	3f 1c       	mov	r12,-15

80003f88 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80003f88:	d4 01       	pushm	lr
80003f8a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80003f8e:	e0 68 04 09 	mov	r8,1033
80003f92:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80003f94:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80003f98:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
80003f9a:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
80003f9e:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80003fa0:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80003fa2:	30 09       	mov	r9,0
80003fa4:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80003fa6:	fb 69 00 08 	st.b	sp[8],r9
80003faa:	fa c8 ff f7 	sub	r8,sp,-9
80003fae:	b0 89       	st.b	r8[0x0],r9
80003fb0:	fa c8 ff f6 	sub	r8,sp,-10
80003fb4:	b0 89       	st.b	r8[0x0],r9
80003fb6:	fa c8 ff f5 	sub	r8,sp,-11
80003fba:	b0 89       	st.b	r8[0x0],r9
80003fbc:	fa c8 ff f4 	sub	r8,sp,-12
80003fc0:	b0 89       	st.b	r8[0x0],r9
80003fc2:	fa c8 ff f3 	sub	r8,sp,-13
80003fc6:	b0 89       	st.b	r8[0x0],r9
80003fc8:	fa c8 ff f2 	sub	r8,sp,-14
80003fcc:	b0 89       	st.b	r8[0x0],r9
80003fce:	fa c8 ff f1 	sub	r8,sp,-15
80003fd2:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80003fd4:	30 cb       	mov	r11,12
80003fd6:	fa cc ff fe 	sub	r12,sp,-2
80003fda:	f0 1f 00 03 	mcall	80003fe4 <xcmp_IdleTestTone+0x5c>
}
80003fde:	2c dd       	sub	sp,-204
80003fe0:	d8 02       	popm	pc
80003fe2:	00 00       	add	r0,r0
80003fe4:	80 00       	ld.sh	r0,r0[0x0]
80003fe6:	3e 08       	mov	r8,-32

80003fe8 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80003fe8:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80003fea:	48 dc       	lddpc	r12,8000401c <xcmp_init+0x34>
80003fec:	f0 1f 00 0d 	mcall	80004020 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80003ff0:	30 4b       	mov	r11,4
80003ff2:	31 4c       	mov	r12,20
80003ff4:	f0 1f 00 0c 	mcall	80004024 <xcmp_init+0x3c>
80003ff8:	48 c8       	lddpc	r8,80004028 <xcmp_init+0x40>
80003ffa:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80003ffc:	30 09       	mov	r9,0
80003ffe:	1a d9       	st.w	--sp,r9
80004000:	1a d9       	st.w	--sp,r9
80004002:	1a d9       	st.w	--sp,r9
80004004:	30 38       	mov	r8,3
80004006:	e0 6a 04 00 	mov	r10,1024
8000400a:	48 9b       	lddpc	r11,8000402c <xcmp_init+0x44>
8000400c:	48 9c       	lddpc	r12,80004030 <xcmp_init+0x48>
8000400e:	f0 1f 00 0a 	mcall	80004034 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80004012:	f0 1f 00 0a 	mcall	80004038 <xcmp_init+0x50>
80004016:	2f dd       	sub	sp,-12
	
}
80004018:	d8 02       	popm	pc
8000401a:	00 00       	add	r0,r0
8000401c:	80 00       	ld.sh	r0,r0[0x0]
8000401e:	41 38       	lddsp	r8,sp[0x4c]
80004020:	80 00       	ld.sh	r0,r0[0x0]
80004022:	41 84       	lddsp	r4,sp[0x60]
80004024:	80 00       	ld.sh	r0,r0[0x0]
80004026:	63 48       	ld.w	r8,r1[0x50]
80004028:	00 00       	add	r0,r0
8000402a:	0b 04       	ld.w	r4,r5++
8000402c:	80 00       	ld.sh	r0,r0[0x0]
8000402e:	d5 f8       	*unknown*
80004030:	80 00       	ld.sh	r0,r0[0x0]
80004032:	40 3c       	lddsp	r12,sp[0xc]
80004034:	80 00       	ld.sh	r0,r0[0x0]
80004036:	6a 64       	ld.w	r4,r5[0x18]
80004038:	80 00       	ld.sh	r0,r0[0x0]
8000403a:	41 bc       	lddsp	r12,sp[0x6c]

8000403c <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
8000403c:	d4 31       	pushm	r0-r7,lr
8000403e:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004040:	4b 16       	lddpc	r6,80004104 <xcmp_rx_process+0xc8>
80004042:	30 05       	mov	r5,0
80004044:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004046:	4b 13       	lddpc	r3,80004108 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004048:	4b 12       	lddpc	r2,8000410c <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000404a:	4b 21       	lddpc	r1,80004110 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
8000404c:	4b 20       	lddpc	r0,80004114 <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000404e:	6c 0c       	ld.w	r12,r6[0x0]
80004050:	0a 99       	mov	r9,r5
80004052:	08 9a       	mov	r10,r4
80004054:	1a 9b       	mov	r11,sp
80004056:	f0 1f 00 31 	mcall	80004118 <xcmp_rx_process+0xdc>
8000405a:	58 1c       	cp.w	r12,1
8000405c:	cf 91       	brne	8000404e <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
8000405e:	40 0b       	lddsp	r11,sp[0x0]
80004060:	58 0b       	cp.w	r11,0
80004062:	cf 60       	breq	8000404e <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
80004064:	96 0a       	ld.sh	r10,r11[0x0]
80004066:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000406a:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
8000406e:	59 c8       	cp.w	r8,28
80004070:	c1 e0       	breq	800040ac <xcmp_rx_process+0x70>
80004072:	e0 89 00 07 	brgt	80004080 <xcmp_rx_process+0x44>
80004076:	58 e8       	cp.w	r8,14
80004078:	c0 e0       	breq	80004094 <xcmp_rx_process+0x58>
8000407a:	58 f8       	cp.w	r8,15
8000407c:	c2 41       	brne	800040c4 <xcmp_rx_process+0x88>
8000407e:	c0 f8       	rjmp	8000409c <xcmp_rx_process+0x60>
80004080:	e0 48 01 09 	cp.w	r8,265
80004084:	c1 80       	breq	800040b4 <xcmp_rx_process+0x78>
80004086:	e0 48 01 0a 	cp.w	r8,266
8000408a:	c1 90       	breq	800040bc <xcmp_rx_process+0x80>
8000408c:	e0 48 00 2c 	cp.w	r8,44
80004090:	c1 a1       	brne	800040c4 <xcmp_rx_process+0x88>
80004092:	c0 98       	rjmp	800040a4 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004094:	4a 2c       	lddpc	r12,8000411c <xcmp_rx_process+0xe0>
80004096:	f0 1f 00 23 	mcall	80004120 <xcmp_rx_process+0xe4>
					break;
8000409a:	c2 f8       	rjmp	800040f8 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
8000409c:	4a 2c       	lddpc	r12,80004124 <xcmp_rx_process+0xe8>
8000409e:	f0 1f 00 21 	mcall	80004120 <xcmp_rx_process+0xe4>
					break;
800040a2:	c2 b8       	rjmp	800040f8 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
800040a4:	4a 1c       	lddpc	r12,80004128 <xcmp_rx_process+0xec>
800040a6:	f0 1f 00 1f 	mcall	80004120 <xcmp_rx_process+0xe4>
					break;
800040aa:	c2 78       	rjmp	800040f8 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800040ac:	04 9c       	mov	r12,r2
800040ae:	f0 1f 00 1d 	mcall	80004120 <xcmp_rx_process+0xe4>
						, ptr);
					break;
800040b2:	c2 38       	rjmp	800040f8 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800040b4:	02 9c       	mov	r12,r1
800040b6:	f0 1f 00 1b 	mcall	80004120 <xcmp_rx_process+0xe4>
					break;
800040ba:	c1 f8       	rjmp	800040f8 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800040bc:	00 9c       	mov	r12,r0
800040be:	f0 1f 00 19 	mcall	80004120 <xcmp_rx_process+0xe4>
					break;
800040c2:	c1 b8       	rjmp	800040f8 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
800040c4:	12 98       	mov	r8,r9
800040c6:	e2 18 04 00 	andl	r8,0x400,COH
800040ca:	c0 70       	breq	800040d8 <xcmp_rx_process+0x9c>
800040cc:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800040d0:	e0 48 00 68 	cp.w	r8,104
800040d4:	e0 8a 00 08 	brle	800040e4 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
800040d8:	e2 19 f0 00 	andl	r9,0xf000,COH
800040dc:	c0 e1       	brne	800040f8 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
800040de:	f0 1f 00 14 	mcall	8000412c <xcmp_rx_process+0xf0>
800040e2:	c0 b8       	rjmp	800040f8 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800040e4:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800040e8:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800040ec:	49 19       	lddpc	r9,80004130 <xcmp_rx_process+0xf4>
800040ee:	72 08       	ld.w	r8,r9[0x0]
800040f0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800040f4:	f0 1f 00 0b 	mcall	80004120 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800040f8:	66 0c       	ld.w	r12,r3[0x0]
800040fa:	40 0b       	lddsp	r11,sp[0x0]
800040fc:	f0 1f 00 0e 	mcall	80004134 <xcmp_rx_process+0xf8>
80004100:	ca 7b       	rjmp	8000404e <xcmp_rx_process+0x12>
80004102:	00 00       	add	r0,r0
80004104:	00 00       	add	r0,r0
80004106:	0b 04       	ld.w	r4,r5++
80004108:	00 00       	add	r0,r0
8000410a:	0a 9c       	mov	r12,r5
8000410c:	00 00       	add	r0,r0
8000410e:	0b 14       	ld.sh	r4,r5++
80004110:	00 00       	add	r0,r0
80004112:	0b 08       	ld.w	r8,r5++
80004114:	00 00       	add	r0,r0
80004116:	0a f8       	st.b	--r5,r8
80004118:	80 00       	ld.sh	r0,r0[0x0]
8000411a:	60 3c       	ld.w	r12,r0[0xc]
8000411c:	00 00       	add	r0,r0
8000411e:	0b 2c       	ld.uh	r12,r5++
80004120:	80 00       	ld.sh	r0,r0[0x0]
80004122:	3f 40       	mov	r0,-12
80004124:	00 00       	add	r0,r0
80004126:	0a ec       	st.h	--r5,r12
80004128:	00 00       	add	r0,r0
8000412a:	0b 20       	ld.uh	r0,r5++
8000412c:	80 00       	ld.sh	r0,r0[0x0]
8000412e:	3f 1c       	mov	r12,-15
80004130:	00 00       	add	r0,r0
80004132:	51 18       	stdsp	sp[0x44],r8
80004134:	80 00       	ld.sh	r0,r0[0x0]
80004136:	2b 24       	sub	r4,-78

80004138 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004138:	eb cd 40 90 	pushm	r4,r7,lr
8000413c:	20 1d       	sub	sp,4
8000413e:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004142:	48 c8       	lddpc	r8,80004170 <xcmp_rx+0x38>
80004144:	70 0c       	ld.w	r12,r8[0x0]
80004146:	f0 1f 00 0c 	mcall	80004174 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000414a:	c1 00       	breq	8000416a <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000414c:	fa c7 ff fc 	sub	r7,sp,-4
80004150:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004152:	e0 6a 00 ca 	mov	r10,202
80004156:	08 9b       	mov	r11,r4
80004158:	f0 1f 00 08 	mcall	80004178 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
8000415c:	48 88       	lddpc	r8,8000417c <xcmp_rx+0x44>
8000415e:	70 0c       	ld.w	r12,r8[0x0]
80004160:	30 09       	mov	r9,0
80004162:	12 9a       	mov	r10,r9
80004164:	1a 9b       	mov	r11,sp
80004166:	f0 1f 00 07 	mcall	80004180 <xcmp_rx+0x48>
	}	
}
8000416a:	2f fd       	sub	sp,-4
8000416c:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004170:	00 00       	add	r0,r0
80004172:	0a 9c       	mov	r12,r5
80004174:	80 00       	ld.sh	r0,r0[0x0]
80004176:	2c d0       	sub	r0,-51
80004178:	80 00       	ld.sh	r0,r0[0x0]
8000417a:	76 a4       	ld.w	r4,r11[0x28]
8000417c:	00 00       	add	r0,r0
8000417e:	0b 04       	ld.w	r4,r5++
80004180:	80 00       	ld.sh	r0,r0[0x0]
80004182:	62 48       	ld.w	r8,r1[0x10]

80004184 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004184:	48 28       	lddpc	r8,8000418c <xnl_register_xcmp_func+0x8>
80004186:	91 0c       	st.w	r8[0x0],r12
}
80004188:	5e fc       	retal	r12
8000418a:	00 00       	add	r0,r0
8000418c:	00 00       	add	r0,r0
8000418e:	0b 58       	ld.sh	r8,--r5

80004190 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004190:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004192:	48 88       	lddpc	r8,800041b0 <xnl_get_msg_ack_func+0x20>
80004194:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004196:	98 49       	ld.sh	r9,r12[0x8]
80004198:	f0 09 19 00 	cp.h	r9,r8
8000419c:	c0 81       	brne	800041ac <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
8000419e:	48 68       	lddpc	r8,800041b4 <xnl_get_msg_ack_func+0x24>
800041a0:	70 0c       	ld.w	r12,r8[0x0]
800041a2:	30 09       	mov	r9,0
800041a4:	12 9a       	mov	r10,r9
800041a6:	12 9b       	mov	r11,r9
800041a8:	f0 1f 00 04 	mcall	800041b8 <xnl_get_msg_ack_func+0x28>
800041ac:	d8 02       	popm	pc
800041ae:	00 00       	add	r0,r0
800041b0:	00 00       	add	r0,r0
800041b2:	0b 3e       	ld.ub	lr,r5++
800041b4:	00 00       	add	r0,r0
800041b6:	0b 38       	ld.ub	r8,r5++
800041b8:	80 00       	ld.sh	r0,r0[0x0]
800041ba:	62 48       	ld.w	r8,r1[0x10]

800041bc <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800041bc:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
800041c0:	30 09       	mov	r9,0
800041c2:	4b 78       	lddpc	r8,8000429c <xnl_init+0xe0>
800041c4:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800041c6:	30 0b       	mov	r11,0
800041c8:	30 1c       	mov	r12,1
800041ca:	f0 1f 00 36 	mcall	800042a0 <xnl_init+0xe4>
800041ce:	4b 68       	lddpc	r8,800042a4 <xnl_init+0xe8>
800041d0:	91 0c       	st.w	r8[0x0],r12
800041d2:	70 08       	ld.w	r8,r8[0x0]
800041d4:	58 08       	cp.w	r8,0
800041d6:	c0 80       	breq	800041e6 <xnl_init+0x2a>
800041d8:	4b 38       	lddpc	r8,800042a4 <xnl_init+0xe8>
800041da:	70 0c       	ld.w	r12,r8[0x0]
800041dc:	30 09       	mov	r9,0
800041de:	12 9a       	mov	r10,r9
800041e0:	12 9b       	mov	r11,r9
800041e2:	f0 1f 00 32 	mcall	800042a8 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
800041e6:	30 4b       	mov	r11,4
800041e8:	31 4c       	mov	r12,20
800041ea:	f0 1f 00 2e 	mcall	800042a0 <xnl_init+0xe4>
800041ee:	4b 08       	lddpc	r8,800042ac <xnl_init+0xf0>
800041f0:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800041f2:	30 4b       	mov	r11,4
800041f4:	31 ec       	mov	r12,30
800041f6:	f0 1f 00 2b 	mcall	800042a0 <xnl_init+0xe4>
800041fa:	4a e8       	lddpc	r8,800042b0 <xnl_init+0xf4>
800041fc:	91 0c       	st.w	r8[0x0],r12
800041fe:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004200:	10 96       	mov	r6,r8
80004202:	4a d5       	lddpc	r5,800042b4 <xnl_init+0xf8>
80004204:	6c 0c       	ld.w	r12,r6[0x0]
80004206:	ea 07 00 0b 	add	r11,r5,r7
8000420a:	f0 1f 00 2c 	mcall	800042b8 <xnl_init+0xfc>
8000420e:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004212:	e0 47 1e 00 	cp.w	r7,7680
80004216:	cf 71       	brne	80004204 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004218:	30 4b       	mov	r11,4
8000421a:	31 4c       	mov	r12,20
8000421c:	f0 1f 00 21 	mcall	800042a0 <xnl_init+0xe4>
80004220:	4a 78       	lddpc	r8,800042bc <xnl_init+0x100>
80004222:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004224:	30 4b       	mov	r11,4
80004226:	30 ac       	mov	r12,10
80004228:	f0 1f 00 1e 	mcall	800042a0 <xnl_init+0xe4>
8000422c:	4a 58       	lddpc	r8,800042c0 <xnl_init+0x104>
8000422e:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004230:	30 4b       	mov	r11,4
80004232:	30 ac       	mov	r12,10
80004234:	f0 1f 00 1b 	mcall	800042a0 <xnl_init+0xe4>
80004238:	4a 38       	lddpc	r8,800042c4 <xnl_init+0x108>
8000423a:	91 0c       	st.w	r8[0x0],r12
8000423c:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
8000423e:	10 96       	mov	r6,r8
80004240:	4a 25       	lddpc	r5,800042c8 <xnl_init+0x10c>
80004242:	6c 0c       	ld.w	r12,r6[0x0]
80004244:	ea 07 00 0b 	add	r11,r5,r7
80004248:	f0 1f 00 1c 	mcall	800042b8 <xnl_init+0xfc>
8000424c:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004250:	e0 47 14 00 	cp.w	r7,5120
80004254:	cf 71       	brne	80004242 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004256:	30 4b       	mov	r11,4
80004258:	30 5c       	mov	r12,5
8000425a:	f0 1f 00 12 	mcall	800042a0 <xnl_init+0xe4>
8000425e:	49 c8       	lddpc	r8,800042cc <xnl_init+0x110>
80004260:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004262:	30 07       	mov	r7,0
80004264:	1a d7       	st.w	--sp,r7
80004266:	1a d7       	st.w	--sp,r7
80004268:	1a d7       	st.w	--sp,r7
8000426a:	30 38       	mov	r8,3
8000426c:	0e 99       	mov	r9,r7
8000426e:	e0 6a 00 dc 	mov	r10,220
80004272:	49 8b       	lddpc	r11,800042d0 <xnl_init+0x114>
80004274:	49 8c       	lddpc	r12,800042d4 <xnl_init+0x118>
80004276:	f0 1f 00 19 	mcall	800042d8 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
8000427a:	1a d7       	st.w	--sp,r7
8000427c:	1a d7       	st.w	--sp,r7
8000427e:	1a d7       	st.w	--sp,r7
80004280:	30 38       	mov	r8,3
80004282:	0e 99       	mov	r9,r7
80004284:	e0 6a 00 82 	mov	r10,130
80004288:	49 5b       	lddpc	r11,800042dc <xnl_init+0x120>
8000428a:	49 6c       	lddpc	r12,800042e0 <xnl_init+0x124>
8000428c:	f0 1f 00 13 	mcall	800042d8 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004290:	f0 1f 00 15 	mcall	800042e4 <xnl_init+0x128>
80004294:	2f ad       	sub	sp,-24
}
80004296:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000429a:	00 00       	add	r0,r0
8000429c:	00 00       	add	r0,r0
8000429e:	0b 3e       	ld.ub	lr,r5++
800042a0:	80 00       	ld.sh	r0,r0[0x0]
800042a2:	63 48       	ld.w	r8,r1[0x50]
800042a4:	00 00       	add	r0,r0
800042a6:	0b 38       	ld.ub	r8,r5++
800042a8:	80 00       	ld.sh	r0,r0[0x0]
800042aa:	62 48       	ld.w	r8,r1[0x10]
800042ac:	00 00       	add	r0,r0
800042ae:	0b 4c       	ld.w	r12,--r5
800042b0:	00 00       	add	r0,r0
800042b2:	0a 9c       	mov	r12,r5
800042b4:	00 00       	add	r0,r0
800042b6:	32 ca       	mov	r10,44
800042b8:	80 00       	ld.sh	r0,r0[0x0]
800042ba:	2b 24       	sub	r4,-78
800042bc:	00 00       	add	r0,r0
800042be:	0a cc       	st.b	r5++,r12
800042c0:	00 00       	add	r0,r0
800042c2:	0a ac       	st.w	r5++,r12
800042c4:	00 00       	add	r0,r0
800042c6:	0a a0       	st.w	r5++,r0
800042c8:	00 00       	add	r0,r0
800042ca:	1e ca       	st.b	pc++,r10
800042cc:	00 00       	add	r0,r0
800042ce:	0a d8       	st.w	--r5,r8
800042d0:	80 00       	ld.sh	r0,r0[0x0]
800042d2:	d6 00       	acall	0x60
800042d4:	80 00       	ld.sh	r0,r0[0x0]
800042d6:	42 e8       	lddsp	r8,sp[0xb8]
800042d8:	80 00       	ld.sh	r0,r0[0x0]
800042da:	6a 64       	ld.w	r4,r5[0x18]
800042dc:	80 00       	ld.sh	r0,r0[0x0]
800042de:	d6 08       	*unknown*
800042e0:	80 00       	ld.sh	r0,r0[0x0]
800042e2:	43 48       	lddsp	r8,sp[0xd0]
800042e4:	80 00       	ld.sh	r0,r0[0x0]
800042e6:	2c f8       	sub	r8,-49

800042e8 <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
800042e8:	eb cd 40 fe 	pushm	r1-r7,lr
800042ec:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800042ee:	49 26       	lddpc	r6,80004334 <xnl_rx_process+0x4c>
800042f0:	30 05       	mov	r5,0
800042f2:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800042f4:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800042f6:	49 11       	lddpc	r1,80004338 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800042f8:	49 12       	lddpc	r2,8000433c <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800042fa:	6c 0c       	ld.w	r12,r6[0x0]
800042fc:	0a 99       	mov	r9,r5
800042fe:	08 9a       	mov	r10,r4
80004300:	1a 9b       	mov	r11,sp
80004302:	f0 1f 00 10 	mcall	80004340 <xnl_rx_process+0x58>
80004306:	58 1c       	cp.w	r12,1
80004308:	cf 91       	brne	800042fa <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
8000430a:	40 0c       	lddsp	r12,sp[0x0]
8000430c:	58 0c       	cp.w	r12,0
8000430e:	cf 60       	breq	800042fa <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004310:	98 28       	ld.sh	r8,r12[0x4]
80004312:	e6 08 19 00 	cp.h	r8,r3
80004316:	e0 8b 00 0a 	brhi	8000432a <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000431a:	5c 78       	castu.h	r8
8000431c:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004320:	58 09       	cp.w	r9,0
80004322:	c0 40       	breq	8000432a <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004324:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004328:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000432a:	62 0c       	ld.w	r12,r1[0x0]
8000432c:	40 0b       	lddsp	r11,sp[0x0]
8000432e:	f0 1f 00 06 	mcall	80004344 <xnl_rx_process+0x5c>
80004332:	ce 4b       	rjmp	800042fa <xnl_rx_process+0x12>
80004334:	00 00       	add	r0,r0
80004336:	0a ac       	st.w	r5++,r12
80004338:	00 00       	add	r0,r0
8000433a:	0a 9c       	mov	r12,r5
8000433c:	00 00       	add	r0,r0
8000433e:	04 f4       	st.b	--r2,r4
80004340:	80 00       	ld.sh	r0,r0[0x0]
80004342:	60 3c       	ld.w	r12,r0[0xc]
80004344:	80 00       	ld.sh	r0,r0[0x0]
80004346:	2b 24       	sub	r4,-78

80004348 <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
80004348:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
8000434a:	4a a6       	lddpc	r6,800043f0 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000434c:	4a a2       	lddpc	r2,800043f4 <xnl_tx_process+0xac>
8000434e:	4a b4       	lddpc	r4,800043f8 <xnl_tx_process+0xb0>
80004350:	30 07       	mov	r7,0
80004352:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004354:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004356:	4a a5       	lddpc	r5,800043fc <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004358:	4a a3       	lddpc	r3,80004400 <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
8000435a:	6c 08       	ld.w	r8,r6[0x0]
8000435c:	58 08       	cp.w	r8,0
8000435e:	c0 40       	breq	80004366 <xnl_tx_process+0x1e>
80004360:	58 18       	cp.w	r8,1
80004362:	cf d1       	brne	8000435c <xnl_tx_process+0x14>
80004364:	c2 48       	rjmp	800043ac <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004366:	64 0c       	ld.w	r12,r2[0x0]
80004368:	0e 99       	mov	r9,r7
8000436a:	02 9a       	mov	r10,r1
8000436c:	08 9b       	mov	r11,r4
8000436e:	f0 1f 00 26 	mcall	80004404 <xnl_tx_process+0xbc>
80004372:	58 1c       	cp.w	r12,1
80004374:	cf 31       	brne	8000435a <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004376:	68 0b       	ld.w	r11,r4[0x0]
80004378:	58 0b       	cp.w	r11,0
8000437a:	cf 00       	breq	8000435a <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
8000437c:	96 28       	ld.sh	r8,r11[0x4]
8000437e:	e0 08 19 00 	cp.h	r8,r0
80004382:	c0 71       	brne	80004390 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004384:	4a 18       	lddpc	r8,80004408 <xnl_tx_process+0xc0>
80004386:	70 08       	ld.w	r8,r8[0x0]
80004388:	10 9c       	mov	r12,r8
8000438a:	f0 1f 00 21 	mcall	8000440c <xnl_tx_process+0xc4>
						break;
8000438e:	ce 6b       	rjmp	8000435a <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004390:	16 9c       	mov	r12,r11
80004392:	f0 1f 00 20 	mcall	80004410 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004396:	30 18       	mov	r8,1
80004398:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000439a:	66 0c       	ld.w	r12,r3[0x0]
8000439c:	0e 99       	mov	r9,r7
8000439e:	0e 9a       	mov	r10,r7
800043a0:	0e 9b       	mov	r11,r7
800043a2:	f0 1f 00 19 	mcall	80004404 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
800043a6:	30 18       	mov	r8,1
800043a8:	8d 08       	st.w	r6[0x0],r8
800043aa:	cd 8b       	rjmp	8000435a <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800043ac:	66 0c       	ld.w	r12,r3[0x0]
800043ae:	0e 99       	mov	r9,r7
800043b0:	36 4a       	mov	r10,100
800043b2:	0e 9b       	mov	r11,r7
800043b4:	f0 1f 00 14 	mcall	80004404 <xnl_tx_process+0xbc>
800043b8:	58 1c       	cp.w	r12,1
800043ba:	c0 81       	brne	800043ca <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
800043bc:	49 38       	lddpc	r8,80004408 <xnl_tx_process+0xc0>
800043be:	70 0c       	ld.w	r12,r8[0x0]
800043c0:	68 0b       	ld.w	r11,r4[0x0]
800043c2:	f0 1f 00 13 	mcall	8000440c <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800043c6:	8d 07       	st.w	r6[0x0],r7
800043c8:	cc 9b       	rjmp	8000435a <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800043ca:	6a 08       	ld.w	r8,r5[0x0]
800043cc:	58 38       	cp.w	r8,3
800043ce:	e0 89 00 09 	brgt	800043e0 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
800043d2:	68 0c       	ld.w	r12,r4[0x0]
800043d4:	f0 1f 00 0f 	mcall	80004410 <xnl_tx_process+0xc8>
						xnl_send_times++;
800043d8:	6a 08       	ld.w	r8,r5[0x0]
800043da:	2f f8       	sub	r8,-1
800043dc:	8b 08       	st.w	r5[0x0],r8
800043de:	cb eb       	rjmp	8000435a <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
800043e0:	48 a8       	lddpc	r8,80004408 <xnl_tx_process+0xc0>
800043e2:	70 0c       	ld.w	r12,r8[0x0]
800043e4:	68 0b       	ld.w	r11,r4[0x0]
800043e6:	f0 1f 00 0a 	mcall	8000440c <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800043ea:	8d 07       	st.w	r6[0x0],r7
800043ec:	cb 7b       	rjmp	8000435a <xnl_tx_process+0x12>
800043ee:	00 00       	add	r0,r0
800043f0:	00 00       	add	r0,r0
800043f2:	0b 48       	ld.w	r8,--r5
800043f4:	00 00       	add	r0,r0
800043f6:	0b 4c       	ld.w	r12,--r5
800043f8:	00 00       	add	r0,r0
800043fa:	0b 54       	ld.sh	r4,--r5
800043fc:	00 00       	add	r0,r0
800043fe:	0b 50       	ld.sh	r0,--r5
80004400:	00 00       	add	r0,r0
80004402:	0b 38       	ld.ub	r8,r5++
80004404:	80 00       	ld.sh	r0,r0[0x0]
80004406:	60 3c       	ld.w	r12,r0[0xc]
80004408:	00 00       	add	r0,r0
8000440a:	0a 9c       	mov	r12,r5
8000440c:	80 00       	ld.sh	r0,r0[0x0]
8000440e:	2b 24       	sub	r4,-78
80004410:	80 00       	ld.sh	r0,r0[0x0]
80004412:	2b 44       	sub	r4,-76

80004414 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004414:	eb cd 40 c0 	pushm	r6-r7,lr
80004418:	20 1d       	sub	sp,4
8000441a:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
8000441c:	98 39       	ld.sh	r9,r12[0x6]
8000441e:	3f f8       	mov	r8,-1
80004420:	f0 09 19 00 	cp.h	r9,r8
80004424:	c0 a1       	brne	80004438 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004426:	4a e9       	lddpc	r9,800044dc <xnl_tx+0xc8>
80004428:	13 88       	ld.ub	r8,r9[0x0]
8000442a:	2f f8       	sub	r8,-1
8000442c:	5c 58       	castu.b	r8
8000442e:	b2 88       	st.b	r9[0x0],r8
80004430:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004434:	a9 a8       	sbr	r8,0x8
80004436:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004438:	8c 49       	ld.sh	r9,r6[0x8]
8000443a:	3f f8       	mov	r8,-1
8000443c:	f0 09 19 00 	cp.h	r9,r8
80004440:	c0 41       	brne	80004448 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004442:	4a 88       	lddpc	r8,800044e0 <xnl_tx+0xcc>
80004444:	90 18       	ld.sh	r8,r8[0x2]
80004446:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004448:	8c 59       	ld.sh	r9,r6[0xa]
8000444a:	3f f8       	mov	r8,-1
8000444c:	f0 09 19 00 	cp.h	r9,r8
80004450:	c0 41       	brne	80004458 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004452:	4a 48       	lddpc	r8,800044e0 <xnl_tx+0xcc>
80004454:	90 28       	ld.sh	r8,r8[0x4]
80004456:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004458:	8c 69       	ld.sh	r9,r6[0xc]
8000445a:	3f f8       	mov	r8,-1
8000445c:	f0 09 19 00 	cp.h	r9,r8
80004460:	c0 e1       	brne	8000447c <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004462:	4a 08       	lddpc	r8,800044e0 <xnl_tx+0xcc>
80004464:	90 49       	ld.sh	r9,r8[0x8]
80004466:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004468:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
8000446a:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
8000446c:	90 49       	ld.sh	r9,r8[0x8]
8000446e:	e0 19 ff 00 	andl	r9,0xff00
80004472:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004476:	f3 e8 10 08 	or	r8,r9,r8
8000447a:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
8000447c:	0d 98       	ld.ub	r8,r6[0x1]
8000447e:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004480:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004484:	10 0c       	add	r12,r8
80004486:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004488:	58 0c       	cp.w	r12,0
8000448a:	e0 89 00 04 	brgt	80004492 <xnl_tx+0x7e>
8000448e:	30 09       	mov	r9,0
80004490:	c0 d8       	rjmp	800044aa <xnl_tx+0x96>
80004492:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004496:	2f ec       	sub	r12,-2
80004498:	30 09       	mov	r9,0
8000449a:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
8000449c:	15 1b       	ld.sh	r11,r10++
8000449e:	f6 09 00 09 	add	r9,r11,r9
800044a2:	5c 89       	casts.h	r9
		indextohWord     += 1;
800044a4:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800044a6:	18 38       	cp.w	r8,r12
800044a8:	cf a1       	brne	8000449c <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
800044aa:	5c 39       	neg	r9
800044ac:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800044ae:	48 e8       	lddpc	r8,800044e4 <xnl_tx+0xd0>
800044b0:	70 0c       	ld.w	r12,r8[0x0]
800044b2:	f0 1f 00 0e 	mcall	800044e8 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800044b6:	c1 00       	breq	800044d6 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800044b8:	fa c7 ff fc 	sub	r7,sp,-4
800044bc:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
800044be:	e0 6a 01 00 	mov	r10,256
800044c2:	0c 9b       	mov	r11,r6
800044c4:	f0 1f 00 0a 	mcall	800044ec <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
800044c8:	48 a8       	lddpc	r8,800044f0 <xnl_tx+0xdc>
800044ca:	70 0c       	ld.w	r12,r8[0x0]
800044cc:	30 09       	mov	r9,0
800044ce:	12 9a       	mov	r10,r9
800044d0:	1a 9b       	mov	r11,sp
800044d2:	f0 1f 00 09 	mcall	800044f4 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
800044d6:	2f fd       	sub	sp,-4
800044d8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800044dc:	00 00       	add	r0,r0
800044de:	0b 3c       	ld.ub	r12,r5++
800044e0:	00 00       	add	r0,r0
800044e2:	0b 3e       	ld.ub	lr,r5++
800044e4:	00 00       	add	r0,r0
800044e6:	0a 9c       	mov	r12,r5
800044e8:	80 00       	ld.sh	r0,r0[0x0]
800044ea:	2c d0       	sub	r0,-51
800044ec:	80 00       	ld.sh	r0,r0[0x0]
800044ee:	76 a4       	ld.w	r4,r11[0x28]
800044f0:	00 00       	add	r0,r0
800044f2:	0b 4c       	ld.w	r12,--r5
800044f4:	80 00       	ld.sh	r0,r0[0x0]
800044f6:	62 48       	ld.w	r8,r1[0x10]

800044f8 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800044f8:	eb cd 40 80 	pushm	r7,lr
800044fc:	fa cd 01 00 	sub	sp,sp,256
80004500:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004502:	e0 68 40 0e 	mov	r8,16398
80004506:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004508:	3f f8       	mov	r8,-1
8000450a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
8000450c:	30 c8       	mov	r8,12
8000450e:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004510:	98 38       	ld.sh	r8,r12[0x6]
80004512:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004514:	98 58       	ld.sh	r8,r12[0xa]
80004516:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004518:	98 48       	ld.sh	r8,r12[0x8]
8000451a:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
8000451c:	98 68       	ld.sh	r8,r12[0xc]
8000451e:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004520:	30 08       	mov	r8,0
80004522:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004524:	1a 9c       	mov	r12,sp
80004526:	f0 1f 00 0a 	mcall	8000454c <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
8000452a:	fa cd 00 cc 	sub	sp,sp,204
8000452e:	e0 6a 00 ca 	mov	r10,202
80004532:	ee cb ff f0 	sub	r11,r7,-16
80004536:	1a 9c       	mov	r12,sp
80004538:	f0 1f 00 06 	mcall	80004550 <xnl_data_msg_func+0x58>
8000453c:	48 68       	lddpc	r8,80004554 <xnl_data_msg_func+0x5c>
8000453e:	70 08       	ld.w	r8,r8[0x0]
80004540:	5d 18       	icall	r8
80004542:	fa cd ff 34 	sub	sp,sp,-204
}
80004546:	2c 0d       	sub	sp,-256
80004548:	e3 cd 80 80 	ldm	sp++,r7,pc
8000454c:	80 00       	ld.sh	r0,r0[0x0]
8000454e:	44 14       	lddsp	r4,sp[0x104]
80004550:	80 00       	ld.sh	r0,r0[0x0]
80004552:	76 a4       	ld.w	r4,r11[0x28]
80004554:	00 00       	add	r0,r0
80004556:	0b 58       	ld.sh	r8,--r5

80004558 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004558:	d4 21       	pushm	r4-r7,lr
8000455a:	fa cd 01 00 	sub	sp,sp,256
8000455e:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004560:	4c 28       	lddpc	r8,80004668 <xnl_device_auth_reply_func+0x110>
80004562:	11 88       	ld.ub	r8,r8[0x0]
80004564:	58 08       	cp.w	r8,0
80004566:	e0 81 00 7f 	brne	80004664 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
8000456a:	4c 18       	lddpc	r8,8000466c <xnl_device_auth_reply_func+0x114>
8000456c:	70 0c       	ld.w	r12,r8[0x0]
8000456e:	30 09       	mov	r9,0
80004570:	12 9a       	mov	r10,r9
80004572:	12 9b       	mov	r11,r9
80004574:	f0 1f 00 3f 	mcall	80004670 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004578:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
8000457c:	4b b8       	lddpc	r8,80004668 <xnl_device_auth_reply_func+0x110>
8000457e:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004580:	ef 39 00 12 	ld.ub	r9,r7[18]
80004584:	ef 38 00 13 	ld.ub	r8,r7[19]
80004588:	b1 68       	lsl	r8,0x10
8000458a:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000458e:	ef 38 00 15 	ld.ub	r8,r7[21]
80004592:	f3 e8 10 08 	or	r8,r9,r8
80004596:	ef 39 00 14 	ld.ub	r9,r7[20]
8000459a:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
8000459e:	ef 3a 00 16 	ld.ub	r10,r7[22]
800045a2:	ef 38 00 17 	ld.ub	r8,r7[23]
800045a6:	b1 68       	lsl	r8,0x10
800045a8:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
800045ac:	ef 38 00 19 	ld.ub	r8,r7[25]
800045b0:	f5 e8 10 08 	or	r8,r10,r8
800045b4:	ef 3a 00 18 	ld.ub	r10,r7[24]
800045b8:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800045bc:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800045be:	e0 64 79 b9 	mov	r4,31161
800045c2:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800045c6:	e0 65 45 07 	mov	r5,17671
800045ca:	ea 15 8a bd 	orh	r5,0x8abd
800045ce:	e0 66 f9 3d 	mov	r6,63805
800045d2:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800045d6:	e0 6e b8 cf 	mov	lr,47311
800045da:	ea 1e 36 83 	orh	lr,0x3683
800045de:	e0 67 aa 1c 	mov	r7,43548
800045e2:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800045e6:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800045e8:	f4 08 00 0c 	add	r12,r10,r8
800045ec:	f0 0b 15 04 	lsl	r11,r8,0x4
800045f0:	0a 0b       	add	r11,r5
800045f2:	f9 eb 20 0b 	eor	r11,r12,r11
800045f6:	f0 0c 16 05 	lsr	r12,r8,0x5
800045fa:	0c 0c       	add	r12,r6
800045fc:	18 5b       	eor	r11,r12
800045fe:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004600:	f2 0c 15 04 	lsl	r12,r9,0x4
80004604:	1c 0c       	add	r12,lr
80004606:	f2 0b 16 05 	lsr	r11,r9,0x5
8000460a:	0e 0b       	add	r11,r7
8000460c:	f9 eb 20 0b 	eor	r11,r12,r11
80004610:	f2 0a 00 0c 	add	r12,r9,r10
80004614:	18 5b       	eor	r11,r12
80004616:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004618:	e0 6b 37 20 	mov	r11,14112
8000461c:	ea 1b c6 ef 	orh	r11,0xc6ef
80004620:	16 3a       	cp.w	r10,r11
80004622:	ce 21       	brne	800045e6 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004624:	e0 6a 40 1a 	mov	r10,16410
80004628:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000462a:	3f fa       	mov	r10,-1
8000462c:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
8000462e:	30 6b       	mov	r11,6
80004630:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004632:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004634:	48 db       	lddpc	r11,80004668 <xnl_device_auth_reply_func+0x110>
80004636:	96 1c       	ld.sh	r12,r11[0x2]
80004638:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
8000463a:	96 2b       	ld.sh	r11,r11[0x4]
8000463c:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000463e:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004640:	30 ca       	mov	r10,12
80004642:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004644:	30 0a       	mov	r10,0
80004646:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
8000464a:	30 7a       	mov	r10,7
8000464c:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004650:	30 2a       	mov	r10,2
80004652:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004656:	fa ca ff ec 	sub	r10,sp,-20
8000465a:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000465c:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000465e:	1a 9c       	mov	r12,sp
80004660:	f0 1f 00 05 	mcall	80004674 <xnl_device_auth_reply_func+0x11c>
}
80004664:	2c 0d       	sub	sp,-256
80004666:	d8 22       	popm	r4-r7,pc
80004668:	00 00       	add	r0,r0
8000466a:	0b 3e       	ld.ub	lr,r5++
8000466c:	00 00       	add	r0,r0
8000466e:	0b 38       	ld.ub	r8,r5++
80004670:	80 00       	ld.sh	r0,r0[0x0]
80004672:	62 48       	ld.w	r8,r1[0x10]
80004674:	80 00       	ld.sh	r0,r0[0x0]
80004676:	44 14       	lddsp	r4,sp[0x104]

80004678 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004678:	eb cd 40 80 	pushm	r7,lr
8000467c:	fa cd 01 00 	sub	sp,sp,256
80004680:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004682:	49 28       	lddpc	r8,800046c8 <xnl_master_status_brdcst_func+0x50>
80004684:	11 88       	ld.ub	r8,r8[0x0]
80004686:	58 08       	cp.w	r8,0
80004688:	c1 c1       	brne	800046c0 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
8000468a:	49 18       	lddpc	r8,800046cc <xnl_master_status_brdcst_func+0x54>
8000468c:	70 0c       	ld.w	r12,r8[0x0]
8000468e:	30 09       	mov	r9,0
80004690:	12 9a       	mov	r10,r9
80004692:	12 9b       	mov	r11,r9
80004694:	f0 1f 00 0f 	mcall	800046d0 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004698:	8e 58       	ld.sh	r8,r7[0xa]
8000469a:	48 c9       	lddpc	r9,800046c8 <xnl_master_status_brdcst_func+0x50>
8000469c:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000469e:	e0 68 40 0e 	mov	r8,16398
800046a2:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800046a4:	3f f8       	mov	r8,-1
800046a6:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
800046a8:	30 4a       	mov	r10,4
800046aa:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800046ac:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800046ae:	92 19       	ld.sh	r9,r9[0x2]
800046b0:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
800046b2:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800046b4:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800046b6:	30 08       	mov	r8,0
800046b8:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800046ba:	1a 9c       	mov	r12,sp
800046bc:	f0 1f 00 06 	mcall	800046d4 <xnl_master_status_brdcst_func+0x5c>
}
800046c0:	2c 0d       	sub	sp,-256
800046c2:	e3 cd 80 80 	ldm	sp++,r7,pc
800046c6:	00 00       	add	r0,r0
800046c8:	00 00       	add	r0,r0
800046ca:	0b 3e       	ld.ub	lr,r5++
800046cc:	00 00       	add	r0,r0
800046ce:	0b 38       	ld.ub	r8,r5++
800046d0:	80 00       	ld.sh	r0,r0[0x0]
800046d2:	62 48       	ld.w	r8,r1[0x10]
800046d4:	80 00       	ld.sh	r0,r0[0x0]
800046d6:	44 14       	lddsp	r4,sp[0x104]

800046d8 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
800046d8:	eb cd 40 80 	pushm	r7,lr
800046dc:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
800046de:	49 28       	lddpc	r8,80004724 <xnl_device_conn_reply_func+0x4c>
800046e0:	70 0c       	ld.w	r12,r8[0x0]
800046e2:	30 09       	mov	r9,0
800046e4:	12 9a       	mov	r10,r9
800046e6:	12 9b       	mov	r11,r9
800046e8:	f0 1f 00 10 	mcall	80004728 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800046ec:	ef 18 00 10 	ld.uh	r8,r7[16]
800046f0:	10 99       	mov	r9,r8
800046f2:	e2 19 ff 00 	andl	r9,0xff00,COH
800046f6:	e0 49 01 00 	cp.w	r9,256
800046fa:	c0 60       	breq	80004706 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800046fc:	0e 9c       	mov	r12,r7
800046fe:	f0 1f 00 0c 	mcall	8000472c <xnl_device_conn_reply_func+0x54>
80004702:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004706:	a9 68       	lsl	r8,0x8
80004708:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
8000470c:	48 98       	lddpc	r8,80004730 <xnl_device_conn_reply_func+0x58>
8000470e:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004710:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004714:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004716:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
8000471a:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
8000471c:	30 19       	mov	r9,1
8000471e:	b0 89       	st.b	r8[0x0],r9
80004720:	e3 cd 80 80 	ldm	sp++,r7,pc
80004724:	00 00       	add	r0,r0
80004726:	0b 38       	ld.ub	r8,r5++
80004728:	80 00       	ld.sh	r0,r0[0x0]
8000472a:	62 48       	ld.w	r8,r1[0x10]
8000472c:	80 00       	ld.sh	r0,r0[0x0]
8000472e:	46 78       	lddsp	r8,sp[0x19c]
80004730:	00 00       	add	r0,r0
80004732:	0b 3e       	ld.ub	lr,r5++

80004734 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
80004734:	d4 01       	pushm	lr
80004736:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000473a:	e0 68 40 0e 	mov	r8,16398
8000473e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004740:	3f f8       	mov	r8,-1
80004742:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004744:	30 38       	mov	r8,3
80004746:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004748:	30 08       	mov	r8,0
8000474a:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
8000474c:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
8000474e:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004750:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004752:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004754:	1a 9c       	mov	r12,sp
80004756:	f0 1f 00 03 	mcall	80004760 <xnl_send_device_master_query+0x2c>
}
8000475a:	2c 0d       	sub	sp,-256
8000475c:	d8 02       	popm	pc
8000475e:	00 00       	add	r0,r0
80004760:	80 00       	ld.sh	r0,r0[0x0]
80004762:	44 14       	lddsp	r4,sp[0x104]

80004764 <RC522_SPI_SetSpeed>:
	//SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80004764:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
80004766:	48 78       	lddpc	r8,80004780 <RC522_SPI_SetSpeed+0x1c>
80004768:	70 09       	ld.w	r9,r8[0x0]
8000476a:	72 ca       	ld.w	r10,r9[0x30]
8000476c:	5c 7c       	castu.h	r12
8000476e:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80004772:	f9 ea 10 0a 	or	r10,r12,r10
80004776:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
80004778:	70 0c       	ld.w	r12,r8[0x0]
8000477a:	f0 1f 00 03 	mcall	80004784 <RC522_SPI_SetSpeed+0x20>
		
	
}
8000477e:	d8 02       	popm	pc
80004780:	00 00       	add	r0,r0
80004782:	1d a4       	ld.ub	r4,lr[0x2]
80004784:	80 00       	ld.sh	r0,r0[0x0]
80004786:	57 38       	stdsp	sp[0x1cc],r8

80004788 <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
80004788:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0A00);//baudDiv=4
8000478a:	e0 6c 0a 00 	mov	r12,2560
8000478e:	f0 1f 00 02 	mcall	80004794 <RC522_SPI_SetSpeedLow+0xc>
	
}
80004792:	d8 02       	popm	pc
80004794:	80 00       	ld.sh	r0,r0[0x0]
80004796:	47 64       	lddsp	r4,sp[0x1d8]

80004798 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
80004798:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
8000479c:	48 76       	lddpc	r6,800047b8 <RC522_ReadByte+0x20>
8000479e:	e0 6b 00 ff 	mov	r11,255
800047a2:	6c 0c       	ld.w	r12,r6[0x0]
800047a4:	f0 1f 00 06 	mcall	800047bc <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
800047a8:	30 07       	mov	r7,0
800047aa:	0e 9b       	mov	r11,r7
800047ac:	6c 0c       	ld.w	r12,r6[0x0]
800047ae:	f0 1f 00 05 	mcall	800047c0 <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
800047b2:	0f 9c       	ld.ub	r12,r7[0x1]
800047b4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800047b8:	00 00       	add	r0,r0
800047ba:	1d a4       	ld.ub	r4,lr[0x2]
800047bc:	80 00       	ld.sh	r0,r0[0x0]
800047be:	57 3e       	stdsp	sp[0x1cc],lr
800047c0:	80 00       	ld.sh	r0,r0[0x0]
800047c2:	57 5a       	stdsp	sp[0x1d4],r10

800047c4 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
800047c4:	eb cd 40 80 	pushm	r7,lr
800047c8:	20 1d       	sub	sp,4
800047ca:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
800047cc:	48 77       	lddpc	r7,800047e8 <RC522_WriteByte+0x24>
800047ce:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
800047d2:	6e 0c       	ld.w	r12,r7[0x0]
800047d4:	f0 1f 00 06 	mcall	800047ec <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
800047d8:	1a 9b       	mov	r11,sp
800047da:	6e 0c       	ld.w	r12,r7[0x0]
800047dc:	f0 1f 00 05 	mcall	800047f0 <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
800047e0:	5c 5c       	castu.b	r12
800047e2:	2f fd       	sub	sp,-4
800047e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800047e8:	00 00       	add	r0,r0
800047ea:	1d a4       	ld.ub	r4,lr[0x2]
800047ec:	80 00       	ld.sh	r0,r0[0x0]
800047ee:	57 3e       	stdsp	sp[0x1cc],lr
800047f0:	80 00       	ld.sh	r0,r0[0x0]
800047f2:	57 5a       	stdsp	sp[0x1d4],r10

800047f4 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
800047f4:	eb cd 40 e0 	pushm	r5-r7,lr
800047f8:	18 96       	mov	r6,r12
800047fa:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
800047fc:	48 a7       	lddpc	r7,80004824 <WriteRawRC+0x30>
800047fe:	30 0b       	mov	r11,0
80004800:	6e 0c       	ld.w	r12,r7[0x0]
80004802:	f0 1f 00 0a 	mcall	80004828 <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
80004806:	ec 0c 15 01 	lsl	r12,r6,0x1
8000480a:	e2 1c 00 7e 	andl	r12,0x7e,COH
8000480e:	f0 1f 00 08 	mcall	8000482c <WriteRawRC+0x38>
	RC522_WriteByte(value);
80004812:	0a 9c       	mov	r12,r5
80004814:	f0 1f 00 06 	mcall	8000482c <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004818:	30 0b       	mov	r11,0
8000481a:	6e 0c       	ld.w	r12,r7[0x0]
8000481c:	f0 1f 00 05 	mcall	80004830 <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
80004820:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004824:	00 00       	add	r0,r0
80004826:	1d a4       	ld.ub	r4,lr[0x2]
80004828:	80 00       	ld.sh	r0,r0[0x0]
8000482a:	58 a4       	cp.w	r4,10
8000482c:	80 00       	ld.sh	r0,r0[0x0]
8000482e:	47 c4       	lddsp	r4,sp[0x1f0]
80004830:	80 00       	ld.sh	r0,r0[0x0]
80004832:	58 64       	cp.w	r4,6

80004834 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
80004834:	d4 01       	pushm	lr

	SET_RC522RST;
80004836:	31 9c       	mov	r12,25
80004838:	f0 1f 00 1b 	mcall	800048a4 <PcdReset+0x70>
	delay_ns(10);
8000483c:	30 ac       	mov	r12,10
8000483e:	f0 1f 00 1b 	mcall	800048a8 <PcdReset+0x74>

	CLR_RC522RST;
80004842:	31 9c       	mov	r12,25
80004844:	f0 1f 00 1a 	mcall	800048ac <PcdReset+0x78>
	delay_ns(10);
80004848:	30 ac       	mov	r12,10
8000484a:	f0 1f 00 18 	mcall	800048a8 <PcdReset+0x74>

	SET_RC522RST;
8000484e:	31 9c       	mov	r12,25
80004850:	f0 1f 00 15 	mcall	800048a4 <PcdReset+0x70>
	delay_ns(10);
80004854:	30 ac       	mov	r12,10
80004856:	f0 1f 00 15 	mcall	800048a8 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
8000485a:	30 fb       	mov	r11,15
8000485c:	30 1c       	mov	r12,1
8000485e:	f0 1f 00 15 	mcall	800048b0 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004862:	30 fb       	mov	r11,15
80004864:	30 1c       	mov	r12,1
80004866:	f0 1f 00 13 	mcall	800048b0 <PcdReset+0x7c>
	delay_ns(10);
8000486a:	30 ac       	mov	r12,10
8000486c:	f0 1f 00 0f 	mcall	800048a8 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80004870:	33 db       	mov	r11,61
80004872:	31 1c       	mov	r12,17
80004874:	f0 1f 00 0f 	mcall	800048b0 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
80004878:	31 eb       	mov	r11,30
8000487a:	32 dc       	mov	r12,45
8000487c:	f0 1f 00 0d 	mcall	800048b0 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80004880:	30 0b       	mov	r11,0
80004882:	32 cc       	mov	r12,44
80004884:	f0 1f 00 0b 	mcall	800048b0 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
80004888:	e0 6b 00 8d 	mov	r11,141
8000488c:	32 ac       	mov	r12,42
8000488e:	f0 1f 00 09 	mcall	800048b0 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
80004892:	33 eb       	mov	r11,62
80004894:	32 bc       	mov	r12,43
80004896:	f0 1f 00 07 	mcall	800048b0 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
8000489a:	34 0b       	mov	r11,64
8000489c:	31 5c       	mov	r12,21
8000489e:	f0 1f 00 05 	mcall	800048b0 <PcdReset+0x7c>
	
	return MI_OK;
}
800048a2:	d8 0a       	popm	pc,r12=0
800048a4:	80 00       	ld.sh	r0,r0[0x0]
800048a6:	54 1c       	stdsp	sp[0x104],r12
800048a8:	80 00       	ld.sh	r0,r0[0x0]
800048aa:	51 c0       	stdsp	sp[0x70],r0
800048ac:	80 00       	ld.sh	r0,r0[0x0]
800048ae:	54 38       	stdsp	sp[0x10c],r8
800048b0:	80 00       	ld.sh	r0,r0[0x0]
800048b2:	47 f4       	lddsp	r4,sp[0x1fc]

800048b4 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
800048b4:	eb cd 40 c0 	pushm	r6-r7,lr
800048b8:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
800048ba:	48 c7       	lddpc	r7,800048e8 <ReadRawRC+0x34>
800048bc:	30 0b       	mov	r11,0
800048be:	6e 0c       	ld.w	r12,r7[0x0]
800048c0:	f0 1f 00 0b 	mcall	800048ec <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
800048c4:	a1 76       	lsl	r6,0x1
800048c6:	0c 9c       	mov	r12,r6
800048c8:	e2 1c 00 7e 	andl	r12,0x7e,COH
800048cc:	a7 bc       	sbr	r12,0x7
800048ce:	f0 1f 00 09 	mcall	800048f0 <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
800048d2:	f0 1f 00 09 	mcall	800048f4 <ReadRawRC+0x40>
800048d6:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800048d8:	30 0b       	mov	r11,0
800048da:	6e 0c       	ld.w	r12,r7[0x0]
800048dc:	f0 1f 00 07 	mcall	800048f8 <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
800048e0:	0c 9c       	mov	r12,r6
800048e2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800048e6:	00 00       	add	r0,r0
800048e8:	00 00       	add	r0,r0
800048ea:	1d a4       	ld.ub	r4,lr[0x2]
800048ec:	80 00       	ld.sh	r0,r0[0x0]
800048ee:	58 a4       	cp.w	r4,10
800048f0:	80 00       	ld.sh	r0,r0[0x0]
800048f2:	47 c4       	lddsp	r4,sp[0x1f0]
800048f4:	80 00       	ld.sh	r0,r0[0x0]
800048f6:	47 98       	lddsp	r8,sp[0x1e4]
800048f8:	80 00       	ld.sh	r0,r0[0x0]
800048fa:	58 64       	cp.w	r4,6

800048fc <Wait_Wakeup_RC522>:

/////////////////////////////////////////////////////////////////////
//    斤绛寰RC522
/////////////////////////////////////////////////////////////////////
void Wait_Wakeup_RC522(void)
{
800048fc:	d4 01       	pushm	lr
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	do 
	{
		tmp = ReadRawRC(reg);
800048fe:	30 1c       	mov	r12,1
80004900:	f0 1f 00 02 	mcall	80004908 <Wait_Wakeup_RC522+0xc>
			
	//tmp = ReadRawRC(reg);
	//if((tmp & 0x10) == 0)
	//WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
	
}
80004904:	d8 02       	popm	pc
80004906:	00 00       	add	r0,r0
80004908:	80 00       	ld.sh	r0,r0[0x0]
8000490a:	48 b4       	lddpc	r4,80004934 <Powerdown_RC522+0x28>

8000490c <Powerdown_RC522>:
/////////////////////////////////////////////////////////////////////
//    斤浣RC522杩ヨ蒋垫ā寮
//
/////////////////////////////////////////////////////////////////////
void Powerdown_RC522(U8 act)
{
8000490c:	eb cd 40 80 	pushm	r7,lr
80004910:	18 97       	mov	r7,r12
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	tmp = ReadRawRC(reg);
80004912:	30 1c       	mov	r12,1
80004914:	f0 1f 00 0d 	mcall	80004948 <Powerdown_RC522+0x3c>
	if(act == ENTER_POWERDOWN)//1
80004918:	30 18       	mov	r8,1
8000491a:	f0 07 18 00 	cp.b	r7,r8
8000491e:	c0 91       	brne	80004930 <Powerdown_RC522+0x24>
		WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
80004920:	18 9b       	mov	r11,r12
80004922:	a5 ab       	sbr	r11,0x4
80004924:	5c 5b       	castu.b	r11
80004926:	30 1c       	mov	r12,1
80004928:	f0 1f 00 09 	mcall	8000494c <Powerdown_RC522+0x40>
8000492c:	e3 cd 80 80 	ldm	sp++,r7,pc
	else
	{
		WriteRawRC(reg,tmp | PCD_IDLE);  // wake up rc522
80004930:	18 9b       	mov	r11,r12
80004932:	30 1c       	mov	r12,1
80004934:	f0 1f 00 06 	mcall	8000494c <Powerdown_RC522+0x40>
		delay_ns(2);
80004938:	30 2c       	mov	r12,2
8000493a:	f0 1f 00 06 	mcall	80004950 <Powerdown_RC522+0x44>
		Wait_Wakeup_RC522();
8000493e:	f0 1f 00 06 	mcall	80004954 <Powerdown_RC522+0x48>
80004942:	e3 cd 80 80 	ldm	sp++,r7,pc
80004946:	00 00       	add	r0,r0
80004948:	80 00       	ld.sh	r0,r0[0x0]
8000494a:	48 b4       	lddpc	r4,80004974 <SetBitMask+0x1c>
8000494c:	80 00       	ld.sh	r0,r0[0x0]
8000494e:	47 f4       	lddsp	r4,sp[0x1fc]
80004950:	80 00       	ld.sh	r0,r0[0x0]
80004952:	51 c0       	stdsp	sp[0x70],r0
80004954:	80 00       	ld.sh	r0,r0[0x0]
80004956:	48 fc       	lddpc	r12,80004990 <PcdAntennaOn+0x14>

80004958 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80004958:	eb cd 40 c0 	pushm	r6-r7,lr
8000495c:	18 97       	mov	r7,r12
8000495e:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80004960:	f0 1f 00 05 	mcall	80004974 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80004964:	f9 e6 10 0b 	or	r11,r12,r6
80004968:	5c 5b       	castu.b	r11
8000496a:	0e 9c       	mov	r12,r7
8000496c:	f0 1f 00 03 	mcall	80004978 <SetBitMask+0x20>
}
80004970:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004974:	80 00       	ld.sh	r0,r0[0x0]
80004976:	48 b4       	lddpc	r4,800049a0 <ClearBitMask+0x4>
80004978:	80 00       	ld.sh	r0,r0[0x0]
8000497a:	47 f4       	lddsp	r4,sp[0x1fc]

8000497c <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
8000497c:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
8000497e:	31 4c       	mov	r12,20
80004980:	f0 1f 00 05 	mcall	80004994 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80004984:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80004988:	c0 51       	brne	80004992 <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
8000498a:	30 3b       	mov	r11,3
8000498c:	31 4c       	mov	r12,20
8000498e:	f0 1f 00 03 	mcall	80004998 <PcdAntennaOn+0x1c>
80004992:	d8 02       	popm	pc
80004994:	80 00       	ld.sh	r0,r0[0x0]
80004996:	48 b4       	lddpc	r4,800049c0 <ClearBitMask+0x24>
80004998:	80 00       	ld.sh	r0,r0[0x0]
8000499a:	49 58       	lddpc	r8,800049ec <M500PcdConfigISOType+0x18>

8000499c <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
8000499c:	eb cd 40 c0 	pushm	r6-r7,lr
800049a0:	18 97       	mov	r7,r12
800049a2:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
800049a4:	f0 1f 00 06 	mcall	800049bc <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
800049a8:	5c d6       	com	r6
800049aa:	f9 e6 00 06 	and	r6,r12,r6
800049ae:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
800049b2:	0e 9c       	mov	r12,r7
800049b4:	f0 1f 00 03 	mcall	800049c0 <ClearBitMask+0x24>
	
}
800049b8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800049bc:	80 00       	ld.sh	r0,r0[0x0]
800049be:	48 b4       	lddpc	r4,800049e8 <M500PcdConfigISOType+0x14>
800049c0:	80 00       	ld.sh	r0,r0[0x0]
800049c2:	47 f4       	lddsp	r4,sp[0x1fc]

800049c4 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
800049c4:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
800049c6:	30 3b       	mov	r11,3
800049c8:	31 4c       	mov	r12,20
800049ca:	f0 1f 00 02 	mcall	800049d0 <PcdAntennaOff+0xc>
}
800049ce:	d8 02       	popm	pc
800049d0:	80 00       	ld.sh	r0,r0[0x0]
800049d2:	49 9c       	lddpc	r12,80004a34 <M500PcdConfigISOType+0x60>

800049d4 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
800049d4:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
800049d6:	34 18       	mov	r8,65
800049d8:	f0 0c 18 00 	cp.b	r12,r8
800049dc:	c0 20       	breq	800049e0 <M500PcdConfigISOType+0xc>
800049de:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
800049e0:	30 8b       	mov	r11,8
800049e2:	16 9c       	mov	r12,r11
800049e4:	f0 1f 00 14 	mcall	80004a34 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
800049e8:	33 db       	mov	r11,61
800049ea:	31 1c       	mov	r12,17
800049ec:	f0 1f 00 13 	mcall	80004a38 <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
800049f0:	e0 6b 00 86 	mov	r11,134
800049f4:	31 7c       	mov	r12,23
800049f6:	f0 1f 00 11 	mcall	80004a38 <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
800049fa:	37 fb       	mov	r11,127
800049fc:	32 6c       	mov	r12,38
800049fe:	f0 1f 00 0f 	mcall	80004a38 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
80004a02:	31 eb       	mov	r11,30
80004a04:	32 dc       	mov	r12,45
80004a06:	f0 1f 00 0d 	mcall	80004a38 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
80004a0a:	30 0b       	mov	r11,0
80004a0c:	32 cc       	mov	r12,44
80004a0e:	f0 1f 00 0b 	mcall	80004a38 <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
80004a12:	e0 6b 00 8d 	mov	r11,141
80004a16:	32 ac       	mov	r12,42
80004a18:	f0 1f 00 08 	mcall	80004a38 <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80004a1c:	33 eb       	mov	r11,62
80004a1e:	32 bc       	mov	r12,43
80004a20:	f0 1f 00 06 	mcall	80004a38 <M500PcdConfigISOType+0x64>
		delay_ns(1000);
80004a24:	e0 6c 03 e8 	mov	r12,1000
80004a28:	f0 1f 00 05 	mcall	80004a3c <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80004a2c:	f0 1f 00 05 	mcall	80004a40 <M500PcdConfigISOType+0x6c>
80004a30:	d8 0a       	popm	pc,r12=0
80004a32:	00 00       	add	r0,r0
80004a34:	80 00       	ld.sh	r0,r0[0x0]
80004a36:	49 9c       	lddpc	r12,80004a98 <rc522_init+0x54>
80004a38:	80 00       	ld.sh	r0,r0[0x0]
80004a3a:	47 f4       	lddsp	r4,sp[0x1fc]
80004a3c:	80 00       	ld.sh	r0,r0[0x0]
80004a3e:	51 c0       	stdsp	sp[0x70],r0
80004a40:	80 00       	ld.sh	r0,r0[0x0]
80004a42:	49 7c       	lddpc	r12,80004a9c <rc522_init+0x58>

80004a44 <rc522_init>:


//mfrc522 init

void rc522_init()
{
80004a44:	eb cd 40 c0 	pushm	r6-r7,lr
80004a48:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004a4a:	4a 38       	lddpc	r8,80004ad4 <rc522_init+0x90>
80004a4c:	1a 96       	mov	r6,sp
80004a4e:	f0 ea 00 00 	ld.d	r10,r8[0]
80004a52:	fa eb 00 00 	st.d	sp[0],r10
80004a56:	f0 e8 00 08 	ld.d	r8,r8[8]
80004a5a:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80004a5e:	30 4b       	mov	r11,4
80004a60:	49 ec       	lddpc	r12,80004ad8 <rc522_init+0x94>
80004a62:	f0 1f 00 1f 	mcall	80004adc <rc522_init+0x98>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80004a66:	31 9c       	mov	r12,25
80004a68:	f0 1f 00 1e 	mcall	80004ae0 <rc522_init+0x9c>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80004a6c:	31 9c       	mov	r12,25
80004a6e:	f0 1f 00 1e 	mcall	80004ae4 <rc522_init+0xa0>

	spi = &AVR32_SPI;
80004a72:	49 e7       	lddpc	r7,80004ae8 <rc522_init+0xa4>
80004a74:	fe 7c 24 00 	mov	r12,-56320
80004a78:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80004a7a:	1a 9b       	mov	r11,sp
80004a7c:	f0 1f 00 1c 	mcall	80004aec <rc522_init+0xa8>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80004a80:	30 09       	mov	r9,0
80004a82:	12 9a       	mov	r10,r9
80004a84:	12 9b       	mov	r11,r9
80004a86:	6e 0c       	ld.w	r12,r7[0x0]
80004a88:	f0 1f 00 1a 	mcall	80004af0 <rc522_init+0xac>

	// Enable SPI.
	spi_enable(spi);
80004a8c:	6e 0c       	ld.w	r12,r7[0x0]
80004a8e:	f0 1f 00 1a 	mcall	80004af4 <rc522_init+0xb0>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80004a92:	e0 6a 36 00 	mov	r10,13824
80004a96:	ea 1a 01 6e 	orh	r10,0x16e
80004a9a:	1a 9b       	mov	r11,sp
80004a9c:	6e 0c       	ld.w	r12,r7[0x0]
80004a9e:	f0 1f 00 17 	mcall	80004af8 <rc522_init+0xb4>
80004aa2:	c0 50       	breq	80004aac <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80004aa4:	30 29       	mov	r9,2
80004aa6:	49 68       	lddpc	r8,80004afc <rc522_init+0xb8>
80004aa8:	b0 89       	st.b	r8[0x0],r9
80004aaa:	c0 38       	rjmp	80004ab0 <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80004aac:	f0 1f 00 15 	mcall	80004b00 <rc522_init+0xbc>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80004ab0:	f0 1f 00 15 	mcall	80004b04 <rc522_init+0xc0>
	
	PcdAntennaOff();
80004ab4:	f0 1f 00 15 	mcall	80004b08 <rc522_init+0xc4>
	
	delay_ms(2); 
80004ab8:	30 2c       	mov	r12,2
80004aba:	f0 1f 00 15 	mcall	80004b0c <rc522_init+0xc8>
	
	PcdAntennaOn();
80004abe:	f0 1f 00 15 	mcall	80004b10 <rc522_init+0xcc>
	
	M500PcdConfigISOType( 'A' );
80004ac2:	34 1c       	mov	r12,65
80004ac4:	f0 1f 00 14 	mcall	80004b14 <rc522_init+0xd0>
	
	Powerdown_RC522(ENTER_POWERDOWN);
80004ac8:	30 1c       	mov	r12,1
80004aca:	f0 1f 00 14 	mcall	80004b18 <rc522_init+0xd4>
	//Powerdown_RC522(ENTER_POWERDOWN);
	
	//Powerdown_RC522(WAKEUP_RC522);
	

80004ace:	2f cd       	sub	sp,-16
80004ad0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004ad4:	80 00       	ld.sh	r0,r0[0x0]
80004ad6:	d6 18       	*unknown*
80004ad8:	80 00       	ld.sh	r0,r0[0x0]
80004ada:	d6 28       	*unknown*
80004adc:	80 00       	ld.sh	r0,r0[0x0]
80004ade:	53 d4       	stdsp	sp[0xf4],r4
80004ae0:	80 00       	ld.sh	r0,r0[0x0]
80004ae2:	54 04       	stdsp	sp[0x100],r4
80004ae4:	80 00       	ld.sh	r0,r0[0x0]
80004ae6:	54 1c       	stdsp	sp[0x104],r12
80004ae8:	00 00       	add	r0,r0
80004aea:	1d a4       	ld.ub	r4,lr[0x2]
80004aec:	80 00       	ld.sh	r0,r0[0x0]
80004aee:	56 d4       	stdsp	sp[0x1b4],r4
80004af0:	80 00       	ld.sh	r0,r0[0x0]
80004af2:	57 0c       	stdsp	sp[0x1c0],r12
80004af4:	80 00       	ld.sh	r0,r0[0x0]
80004af6:	57 38       	stdsp	sp[0x1cc],r8
80004af8:	80 00       	ld.sh	r0,r0[0x0]
80004afa:	57 7c       	stdsp	sp[0x1dc],r12
80004afc:	00 00       	add	r0,r0
80004afe:	0b 5c       	ld.sh	r12,--r5
80004b00:	80 00       	ld.sh	r0,r0[0x0]
80004b02:	47 88       	lddsp	r8,sp[0x1e0]
80004b04:	80 00       	ld.sh	r0,r0[0x0]
80004b06:	48 34       	lddpc	r4,80004b10 <rc522_init+0xcc>
80004b08:	80 00       	ld.sh	r0,r0[0x0]
80004b0a:	49 c4       	lddpc	r4,80004b78 <PcdComMF522+0x5c>
80004b0c:	80 00       	ld.sh	r0,r0[0x0]
80004b0e:	52 00       	stdsp	sp[0x80],r0
80004b10:	80 00       	ld.sh	r0,r0[0x0]
80004b12:	49 7c       	lddpc	r12,80004b6c <PcdComMF522+0x50>
80004b14:	80 00       	ld.sh	r0,r0[0x0]
80004b16:	49 d4       	lddpc	r4,80004b88 <PcdComMF522+0x6c>
80004b18:	80 00       	ld.sh	r0,r0[0x0]
80004b1a:	49 0c       	lddpc	r12,80004b58 <PcdComMF522+0x3c>

80004b1c <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004b1c:	d4 31       	pushm	r0-r7,lr
80004b1e:	20 1d       	sub	sp,4
80004b20:	18 92       	mov	r2,r12
80004b22:	16 95       	mov	r5,r11
80004b24:	14 96       	mov	r6,r10
80004b26:	50 09       	stdsp	sp[0x0],r9
80004b28:	10 90       	mov	r0,r8
80004b2a:	f8 c8 00 0c 	sub	r8,r12,12
80004b2e:	5c 58       	castu.b	r8
80004b30:	30 29       	mov	r9,2
80004b32:	f2 08 18 00 	cp.b	r8,r9
80004b36:	e0 88 00 05 	brls	80004b40 <PcdComMF522+0x24>
80004b3a:	30 03       	mov	r3,0
80004b3c:	06 91       	mov	r1,r3
80004b3e:	c0 78       	rjmp	80004b4c <PcdComMF522+0x30>
80004b40:	4c f9       	lddpc	r9,80004c7c <PcdComMF522+0x160>
80004b42:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004b46:	4c f9       	lddpc	r9,80004c80 <PcdComMF522+0x164>
80004b48:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004b4c:	02 9b       	mov	r11,r1
80004b4e:	a7 bb       	sbr	r11,0x7
80004b50:	30 2c       	mov	r12,2
80004b52:	f0 1f 00 4d 	mcall	80004c84 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004b56:	e0 6b 00 80 	mov	r11,128
80004b5a:	30 4c       	mov	r12,4
80004b5c:	f0 1f 00 4b 	mcall	80004c88 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004b60:	30 0b       	mov	r11,0
80004b62:	30 1c       	mov	r12,1
80004b64:	f0 1f 00 48 	mcall	80004c84 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004b68:	e0 6b 00 80 	mov	r11,128
80004b6c:	30 ac       	mov	r12,10
80004b6e:	f0 1f 00 48 	mcall	80004c8c <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004b72:	58 06       	cp.w	r6,0
80004b74:	c0 c0       	breq	80004b8c <PcdComMF522+0x70>
80004b76:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004b78:	30 94       	mov	r4,9
80004b7a:	0f 3b       	ld.ub	r11,r7++
80004b7c:	08 9c       	mov	r12,r4
80004b7e:	f0 1f 00 42 	mcall	80004c84 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004b82:	0e 98       	mov	r8,r7
80004b84:	0a 18       	sub	r8,r5
80004b86:	ec 08 19 00 	cp.h	r8,r6
80004b8a:	cf 83       	brcs	80004b7a <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004b8c:	04 9b       	mov	r11,r2
80004b8e:	30 1c       	mov	r12,1
80004b90:	f0 1f 00 3d 	mcall	80004c84 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004b94:	30 c8       	mov	r8,12
80004b96:	f0 02 18 00 	cp.b	r2,r8
80004b9a:	c0 61       	brne	80004ba6 <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004b9c:	e0 6b 00 80 	mov	r11,128
80004ba0:	30 dc       	mov	r12,13
80004ba2:	f0 1f 00 3b 	mcall	80004c8c <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004ba6:	30 4c       	mov	r12,4
80004ba8:	f0 1f 00 3a 	mcall	80004c90 <PcdComMF522+0x174>
80004bac:	18 97       	mov	r7,r12
80004bae:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004bb2:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004bb4:	30 44       	mov	r4,4
80004bb6:	c0 88       	rjmp	80004bc6 <PcdComMF522+0xaa>
80004bb8:	08 9c       	mov	r12,r4
80004bba:	f0 1f 00 36 	mcall	80004c90 <PcdComMF522+0x174>
80004bbe:	18 97       	mov	r7,r12
		i--;
80004bc0:	20 16       	sub	r6,1
80004bc2:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004bc4:	c0 a0       	breq	80004bd8 <PcdComMF522+0xbc>
80004bc6:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004bca:	c4 c1       	brne	80004c62 <PcdComMF522+0x146>
80004bcc:	ef e3 00 08 	and	r8,r7,r3
80004bd0:	ea 08 18 00 	cp.b	r8,r5
80004bd4:	cf 20       	breq	80004bb8 <PcdComMF522+0x9c>
80004bd6:	c4 68       	rjmp	80004c62 <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004bd8:	e0 6b 00 80 	mov	r11,128
80004bdc:	30 dc       	mov	r12,13
80004bde:	f0 1f 00 2b 	mcall	80004c88 <PcdComMF522+0x16c>
80004be2:	30 27       	mov	r7,2
80004be4:	c3 38       	rjmp	80004c4a <PcdComMF522+0x12e>
80004be6:	02 67       	and	r7,r1
80004be8:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004bec:	30 c8       	mov	r8,12
80004bee:	f0 02 18 00 	cp.b	r2,r8
80004bf2:	c2 c1       	brne	80004c4a <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004bf4:	30 ac       	mov	r12,10
80004bf6:	f0 1f 00 27 	mcall	80004c90 <PcdComMF522+0x174>
80004bfa:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004bfc:	30 cc       	mov	r12,12
80004bfe:	f0 1f 00 25 	mcall	80004c90 <PcdComMF522+0x174>
80004c02:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004c06:	c0 70       	breq	80004c14 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004c08:	08 98       	mov	r8,r4
80004c0a:	20 18       	sub	r8,1
80004c0c:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004c10:	a0 8c       	st.b	r0[0x0],r12
80004c12:	c0 48       	rjmp	80004c1a <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004c14:	e8 08 15 03 	lsl	r8,r4,0x3
80004c18:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004c1a:	58 04       	cp.w	r4,0
80004c1c:	c0 61       	brne	80004c28 <PcdComMF522+0x10c>
80004c1e:	30 14       	mov	r4,1
80004c20:	40 05       	lddsp	r5,sp[0x0]
80004c22:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004c24:	30 93       	mov	r3,9
80004c26:	c0 98       	rjmp	80004c38 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004c28:	31 28       	mov	r8,18
80004c2a:	f0 04 18 00 	cp.b	r4,r8
80004c2e:	f9 b4 0b 12 	movhi	r4,18
80004c32:	58 04       	cp.w	r4,0
80004c34:	cf 61       	brne	80004c20 <PcdComMF522+0x104>
80004c36:	c0 a8       	rjmp	80004c4a <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004c38:	06 9c       	mov	r12,r3
80004c3a:	f0 1f 00 16 	mcall	80004c90 <PcdComMF522+0x174>
80004c3e:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004c40:	ec 05 01 08 	sub	r8,r6,r5
80004c44:	e8 08 19 00 	cp.h	r8,r4
80004c48:	cf 83       	brcs	80004c38 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004c4a:	e0 6b 00 80 	mov	r11,128
80004c4e:	30 cc       	mov	r12,12
80004c50:	f0 1f 00 0f 	mcall	80004c8c <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004c54:	30 0b       	mov	r11,0
80004c56:	30 1c       	mov	r12,1
80004c58:	f0 1f 00 0b 	mcall	80004c84 <PcdComMF522+0x168>
	return status;
}
80004c5c:	0e 9c       	mov	r12,r7
80004c5e:	2f fd       	sub	sp,-4
80004c60:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004c62:	e0 6b 00 80 	mov	r11,128
80004c66:	30 dc       	mov	r12,13
80004c68:	f0 1f 00 08 	mcall	80004c88 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004c6c:	30 6c       	mov	r12,6
80004c6e:	f0 1f 00 09 	mcall	80004c90 <PcdComMF522+0x174>
80004c72:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004c76:	cb 80       	breq	80004be6 <PcdComMF522+0xca>
80004c78:	30 27       	mov	r7,2
80004c7a:	ce 8b       	rjmp	80004c4a <PcdComMF522+0x12e>
80004c7c:	80 00       	ld.sh	r0,r0[0x0]
80004c7e:	d6 10       	acall	0x61
80004c80:	80 00       	ld.sh	r0,r0[0x0]
80004c82:	d6 14       	*unknown*
80004c84:	80 00       	ld.sh	r0,r0[0x0]
80004c86:	47 f4       	lddsp	r4,sp[0x1fc]
80004c88:	80 00       	ld.sh	r0,r0[0x0]
80004c8a:	49 9c       	lddpc	r12,80004cec <PcdAnticoll+0x58>
80004c8c:	80 00       	ld.sh	r0,r0[0x0]
80004c8e:	49 58       	lddpc	r8,80004ce0 <PcdAnticoll+0x4c>
80004c90:	80 00       	ld.sh	r0,r0[0x0]
80004c92:	48 b4       	lddpc	r4,80004cbc <PcdAnticoll+0x28>

80004c94 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004c94:	eb cd 40 c0 	pushm	r6-r7,lr
80004c98:	20 5d       	sub	sp,20
80004c9a:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004c9c:	30 8b       	mov	r11,8
80004c9e:	16 9c       	mov	r12,r11
80004ca0:	f0 1f 00 1a 	mcall	80004d08 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004ca4:	30 0b       	mov	r11,0
80004ca6:	30 dc       	mov	r12,13
80004ca8:	f0 1f 00 19 	mcall	80004d0c <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004cac:	e0 6b 00 80 	mov	r11,128
80004cb0:	30 ec       	mov	r12,14
80004cb2:	f0 1f 00 16 	mcall	80004d08 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004cb6:	39 38       	mov	r8,-109
80004cb8:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004cba:	32 08       	mov	r8,32
80004cbc:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004cbe:	1a 9b       	mov	r11,sp
80004cc0:	fa c8 ff ed 	sub	r8,sp,-19
80004cc4:	1a 99       	mov	r9,sp
80004cc6:	30 2a       	mov	r10,2
80004cc8:	30 cc       	mov	r12,12
80004cca:	f0 1f 00 12 	mcall	80004d10 <PcdAnticoll+0x7c>
80004cce:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004cd0:	c1 21       	brne	80004cf4 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004cd2:	1b 89       	ld.ub	r9,sp[0x0]
80004cd4:	ac 89       	st.b	r6[0x0],r9
80004cd6:	1b 98       	ld.ub	r8,sp[0x1]
80004cd8:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004cda:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004cdc:	1b a8       	ld.ub	r8,sp[0x2]
80004cde:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004ce0:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004ce4:	1b b9       	ld.ub	r9,sp[0x3]
80004ce6:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004ce8:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004cea:	1b c9       	ld.ub	r9,sp[0x4]
80004cec:	f0 09 18 00 	cp.b	r9,r8
80004cf0:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004cf4:	e0 6b 00 80 	mov	r11,128
80004cf8:	30 ec       	mov	r12,14
80004cfa:	f0 1f 00 07 	mcall	80004d14 <PcdAnticoll+0x80>
	return status;
}
80004cfe:	0e 9c       	mov	r12,r7
80004d00:	2f bd       	sub	sp,-20
80004d02:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004d06:	00 00       	add	r0,r0
80004d08:	80 00       	ld.sh	r0,r0[0x0]
80004d0a:	49 9c       	lddpc	r12,80004d6c <PcdRequest+0x54>
80004d0c:	80 00       	ld.sh	r0,r0[0x0]
80004d0e:	47 f4       	lddsp	r4,sp[0x1fc]
80004d10:	80 00       	ld.sh	r0,r0[0x0]
80004d12:	4b 1c       	lddpc	r12,80004dd4 <CalulateCRC+0x58>
80004d14:	80 00       	ld.sh	r0,r0[0x0]
80004d16:	49 58       	lddpc	r8,80004d68 <PcdRequest+0x50>

80004d18 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004d18:	eb cd 40 c0 	pushm	r6-r7,lr
80004d1c:	20 5d       	sub	sp,20
80004d1e:	18 97       	mov	r7,r12
80004d20:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004d22:	30 8b       	mov	r11,8
80004d24:	16 9c       	mov	r12,r11
80004d26:	f0 1f 00 12 	mcall	80004d6c <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004d2a:	30 7b       	mov	r11,7
80004d2c:	30 dc       	mov	r12,13
80004d2e:	f0 1f 00 11 	mcall	80004d70 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004d32:	30 3b       	mov	r11,3
80004d34:	31 4c       	mov	r12,20
80004d36:	f0 1f 00 10 	mcall	80004d74 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004d3a:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004d3c:	1a 9b       	mov	r11,sp
80004d3e:	fa c8 ff ed 	sub	r8,sp,-19
80004d42:	1a 99       	mov	r9,sp
80004d44:	30 1a       	mov	r10,1
80004d46:	30 cc       	mov	r12,12
80004d48:	f0 1f 00 0c 	mcall	80004d78 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004d4c:	c0 c1       	brne	80004d64 <PcdRequest+0x4c>
80004d4e:	31 08       	mov	r8,16
80004d50:	fb 39 00 13 	ld.ub	r9,sp[19]
80004d54:	f0 09 18 00 	cp.b	r9,r8
80004d58:	c0 61       	brne	80004d64 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004d5a:	1b 88       	ld.ub	r8,sp[0x0]
80004d5c:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004d5e:	1b 98       	ld.ub	r8,sp[0x1]
80004d60:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004d62:	c0 28       	rjmp	80004d66 <PcdRequest+0x4e>
80004d64:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004d66:	2f bd       	sub	sp,-20
80004d68:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004d6c:	80 00       	ld.sh	r0,r0[0x0]
80004d6e:	49 9c       	lddpc	r12,80004dd0 <CalulateCRC+0x54>
80004d70:	80 00       	ld.sh	r0,r0[0x0]
80004d72:	47 f4       	lddsp	r4,sp[0x1fc]
80004d74:	80 00       	ld.sh	r0,r0[0x0]
80004d76:	49 58       	lddpc	r8,80004dc8 <CalulateCRC+0x4c>
80004d78:	80 00       	ld.sh	r0,r0[0x0]
80004d7a:	4b 1c       	lddpc	r12,80004e3c <PcdSelect+0x34>

80004d7c <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004d7c:	eb cd 40 f8 	pushm	r3-r7,lr
80004d80:	18 95       	mov	r5,r12
80004d82:	16 96       	mov	r6,r11
80004d84:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004d86:	30 4b       	mov	r11,4
80004d88:	30 5c       	mov	r12,5
80004d8a:	f0 1f 00 1c 	mcall	80004df8 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004d8e:	30 0b       	mov	r11,0
80004d90:	30 1c       	mov	r12,1
80004d92:	f0 1f 00 1b 	mcall	80004dfc <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004d96:	e0 6b 00 80 	mov	r11,128
80004d9a:	30 ac       	mov	r12,10
80004d9c:	f0 1f 00 19 	mcall	80004e00 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004da0:	58 06       	cp.w	r6,0
80004da2:	c0 c0       	breq	80004dba <CalulateCRC+0x3e>
80004da4:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004da6:	30 94       	mov	r4,9
80004da8:	0f 3b       	ld.ub	r11,r7++
80004daa:	08 9c       	mov	r12,r4
80004dac:	f0 1f 00 14 	mcall	80004dfc <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004db0:	0e 98       	mov	r8,r7
80004db2:	0a 18       	sub	r8,r5
80004db4:	ec 08 18 00 	cp.b	r8,r6
80004db8:	cf 83       	brcs	80004da8 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004dba:	30 3b       	mov	r11,3
80004dbc:	30 1c       	mov	r12,1
80004dbe:	f0 1f 00 10 	mcall	80004dfc <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004dc2:	30 5c       	mov	r12,5
80004dc4:	f0 1f 00 10 	mcall	80004e04 <CalulateCRC+0x88>
80004dc8:	e0 67 00 fe 	mov	r7,254
80004dcc:	30 56       	mov	r6,5
80004dce:	c0 78       	rjmp	80004ddc <CalulateCRC+0x60>
80004dd0:	0c 9c       	mov	r12,r6
80004dd2:	f0 1f 00 0d 	mcall	80004e04 <CalulateCRC+0x88>
		i--;
80004dd6:	20 17       	sub	r7,1
80004dd8:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004dda:	c0 40       	breq	80004de2 <CalulateCRC+0x66>
80004ddc:	e2 1c 00 04 	andl	r12,0x4,COH
80004de0:	cf 80       	breq	80004dd0 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004de2:	32 2c       	mov	r12,34
80004de4:	f0 1f 00 08 	mcall	80004e04 <CalulateCRC+0x88>
80004de8:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004dea:	32 1c       	mov	r12,33
80004dec:	f0 1f 00 06 	mcall	80004e04 <CalulateCRC+0x88>
80004df0:	a6 9c       	st.b	r3[0x1],r12
}
80004df2:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004df6:	00 00       	add	r0,r0
80004df8:	80 00       	ld.sh	r0,r0[0x0]
80004dfa:	49 9c       	lddpc	r12,80004e5c <PcdSelect+0x54>
80004dfc:	80 00       	ld.sh	r0,r0[0x0]
80004dfe:	47 f4       	lddsp	r4,sp[0x1fc]
80004e00:	80 00       	ld.sh	r0,r0[0x0]
80004e02:	49 58       	lddpc	r8,80004e54 <PcdSelect+0x4c>
80004e04:	80 00       	ld.sh	r0,r0[0x0]
80004e06:	48 b4       	lddpc	r4,80004e30 <PcdSelect+0x28>

80004e08 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004e08:	eb cd 40 80 	pushm	r7,lr
80004e0c:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004e0e:	39 38       	mov	r8,-109
80004e10:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004e12:	37 08       	mov	r8,112
80004e14:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004e16:	30 08       	mov	r8,0
80004e18:	ba e8       	st.b	sp[0x6],r8
80004e1a:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004e1e:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004e22:	19 89       	ld.ub	r9,r12[0x0]
80004e24:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004e26:	19 3a       	ld.ub	r10,r12++
80004e28:	1b e9       	ld.ub	r9,sp[0x6]
80004e2a:	f5 e9 20 09 	eor	r9,r10,r9
80004e2e:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004e30:	16 38       	cp.w	r8,r11
80004e32:	cf 81       	brne	80004e22 <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004e34:	1a 97       	mov	r7,sp
80004e36:	fa ca ff f9 	sub	r10,sp,-7
80004e3a:	30 7b       	mov	r11,7
80004e3c:	1a 9c       	mov	r12,sp
80004e3e:	f0 1f 00 0d 	mcall	80004e70 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004e42:	30 8b       	mov	r11,8
80004e44:	16 9c       	mov	r12,r11
80004e46:	f0 1f 00 0c 	mcall	80004e74 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004e4a:	fa c8 ff ed 	sub	r8,sp,-19
80004e4e:	1a 99       	mov	r9,sp
80004e50:	30 9a       	mov	r10,9
80004e52:	1a 9b       	mov	r11,sp
80004e54:	30 cc       	mov	r12,12
80004e56:	f0 1f 00 09 	mcall	80004e78 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80004e5a:	c0 71       	brne	80004e68 <PcdSelect+0x60>
80004e5c:	31 88       	mov	r8,24
80004e5e:	fb 39 00 13 	ld.ub	r9,sp[19]
80004e62:	f0 09 18 00 	cp.b	r9,r8
80004e66:	c0 20       	breq	80004e6a <PcdSelect+0x62>
80004e68:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80004e6a:	2f bd       	sub	sp,-20
80004e6c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004e70:	80 00       	ld.sh	r0,r0[0x0]
80004e72:	4d 7c       	lddpc	r12,80004fcc <scan_patrol+0x30>
80004e74:	80 00       	ld.sh	r0,r0[0x0]
80004e76:	49 9c       	lddpc	r12,80004ed8 <rfid_auto_reader+0x5c>
80004e78:	80 00       	ld.sh	r0,r0[0x0]
80004e7a:	4b 1c       	lddpc	r12,80004f3c <rfid_auto_reader+0xc0>

80004e7c <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80004e7c:	eb cd 40 c0 	pushm	r6-r7,lr
80004e80:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80004e82:	f0 1f 00 37 	mcall	80004f5c <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80004e86:	4b 7b       	lddpc	r11,80004f60 <rfid_auto_reader+0xe4>
80004e88:	35 2c       	mov	r12,82
80004e8a:	f0 1f 00 37 	mcall	80004f64 <rfid_auto_reader+0xe8>
80004e8e:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80004e90:	c6 31       	brne	80004f56 <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004e92:	4b 48       	lddpc	r8,80004f60 <rfid_auto_reader+0xe4>
80004e94:	11 88       	ld.ub	r8,r8[0x0]
80004e96:	30 49       	mov	r9,4
80004e98:	f2 08 18 00 	cp.b	r8,r9
80004e9c:	c0 b1       	brne	80004eb2 <rfid_auto_reader+0x36>
80004e9e:	4b 19       	lddpc	r9,80004f60 <rfid_auto_reader+0xe4>
80004ea0:	13 9a       	ld.ub	r10,r9[0x1]
80004ea2:	30 09       	mov	r9,0
80004ea4:	f2 0a 18 00 	cp.b	r10,r9
80004ea8:	c0 51       	brne	80004eb2 <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
80004eaa:	4b 0c       	lddpc	r12,80004f68 <rfid_auto_reader+0xec>
80004eac:	f0 1f 00 30 	mcall	80004f6c <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004eb0:	c3 c8       	rjmp	80004f28 <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004eb2:	30 29       	mov	r9,2
80004eb4:	f2 08 18 00 	cp.b	r8,r9
80004eb8:	c0 b1       	brne	80004ece <rfid_auto_reader+0x52>
80004eba:	4a a9       	lddpc	r9,80004f60 <rfid_auto_reader+0xe4>
80004ebc:	13 9a       	ld.ub	r10,r9[0x1]
80004ebe:	30 09       	mov	r9,0
80004ec0:	f2 0a 18 00 	cp.b	r10,r9
80004ec4:	c0 51       	brne	80004ece <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80004ec6:	4a bc       	lddpc	r12,80004f70 <rfid_auto_reader+0xf4>
80004ec8:	f0 1f 00 29 	mcall	80004f6c <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004ecc:	c2 e8       	rjmp	80004f28 <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004ece:	34 49       	mov	r9,68
80004ed0:	f2 08 18 00 	cp.b	r8,r9
80004ed4:	c0 b1       	brne	80004eea <rfid_auto_reader+0x6e>
80004ed6:	4a 39       	lddpc	r9,80004f60 <rfid_auto_reader+0xe4>
80004ed8:	13 9a       	ld.ub	r10,r9[0x1]
80004eda:	30 09       	mov	r9,0
80004edc:	f2 0a 18 00 	cp.b	r10,r9
80004ee0:	c0 51       	brne	80004eea <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80004ee2:	4a 5c       	lddpc	r12,80004f74 <rfid_auto_reader+0xf8>
80004ee4:	f0 1f 00 22 	mcall	80004f6c <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004ee8:	c2 08       	rjmp	80004f28 <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004eea:	30 89       	mov	r9,8
80004eec:	f2 08 18 00 	cp.b	r8,r9
80004ef0:	c0 b1       	brne	80004f06 <rfid_auto_reader+0x8a>
80004ef2:	49 c9       	lddpc	r9,80004f60 <rfid_auto_reader+0xe4>
80004ef4:	13 9a       	ld.ub	r10,r9[0x1]
80004ef6:	30 09       	mov	r9,0
80004ef8:	f2 0a 18 00 	cp.b	r10,r9
80004efc:	c0 51       	brne	80004f06 <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80004efe:	49 fc       	lddpc	r12,80004f78 <rfid_auto_reader+0xfc>
80004f00:	f0 1f 00 1b 	mcall	80004f6c <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004f04:	c1 28       	rjmp	80004f28 <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004f06:	34 49       	mov	r9,68
80004f08:	f2 08 18 00 	cp.b	r8,r9
80004f0c:	c0 b1       	brne	80004f22 <rfid_auto_reader+0xa6>
80004f0e:	49 58       	lddpc	r8,80004f60 <rfid_auto_reader+0xe4>
80004f10:	11 99       	ld.ub	r9,r8[0x1]
80004f12:	30 38       	mov	r8,3
80004f14:	f0 09 18 00 	cp.b	r9,r8
80004f18:	c0 51       	brne	80004f22 <rfid_auto_reader+0xa6>
		log("MF Desire\n");
80004f1a:	49 9c       	lddpc	r12,80004f7c <rfid_auto_reader+0x100>
80004f1c:	f0 1f 00 14 	mcall	80004f6c <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004f20:	c0 48       	rjmp	80004f28 <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80004f22:	49 8c       	lddpc	r12,80004f80 <rfid_auto_reader+0x104>
80004f24:	f0 1f 00 12 	mcall	80004f6c <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80004f28:	49 7c       	lddpc	r12,80004f84 <rfid_auto_reader+0x108>
80004f2a:	f0 1f 00 18 	mcall	80004f88 <rfid_auto_reader+0x10c>
80004f2e:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80004f30:	c0 60       	breq	80004f3c <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
80004f32:	37 8b       	mov	r11,120
80004f34:	30 1c       	mov	r12,1
80004f36:	f0 1f 00 16 	mcall	80004f8c <rfid_auto_reader+0x110>
		return status;
80004f3a:	c0 e8       	rjmp	80004f56 <rfid_auto_reader+0xda>
		//continue;
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80004f3c:	49 2c       	lddpc	r12,80004f84 <rfid_auto_reader+0x108>
80004f3e:	f0 1f 00 15 	mcall	80004f90 <rfid_auto_reader+0x114>
80004f42:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80004f44:	c0 91       	brne	80004f56 <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80004f46:	30 4a       	mov	r10,4
80004f48:	48 fb       	lddpc	r11,80004f84 <rfid_auto_reader+0x108>
80004f4a:	0c 9c       	mov	r12,r6
80004f4c:	f0 1f 00 12 	mcall	80004f94 <rfid_auto_reader+0x118>
		log("select okay\n");
80004f50:	49 2c       	lddpc	r12,80004f98 <rfid_auto_reader+0x11c>
80004f52:	f0 1f 00 07 	mcall	80004f6c <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
80004f56:	0e 9c       	mov	r12,r7
80004f58:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004f5c:	80 00       	ld.sh	r0,r0[0x0]
80004f5e:	48 34       	lddpc	r4,80004f68 <rfid_auto_reader+0xec>
80004f60:	00 00       	add	r0,r0
80004f62:	51 2c       	stdsp	sp[0x48],r12
80004f64:	80 00       	ld.sh	r0,r0[0x0]
80004f66:	4d 18       	lddpc	r8,800050a8 <scan_rfid_save_message+0xbc>
80004f68:	80 00       	ld.sh	r0,r0[0x0]
80004f6a:	d6 48       	*unknown*
80004f6c:	80 00       	ld.sh	r0,r0[0x0]
80004f6e:	6e 28       	ld.w	r8,r7[0x8]
80004f70:	80 00       	ld.sh	r0,r0[0x0]
80004f72:	d6 54       	*unknown*
80004f74:	80 00       	ld.sh	r0,r0[0x0]
80004f76:	d6 60       	acall	0x66
80004f78:	80 00       	ld.sh	r0,r0[0x0]
80004f7a:	d6 70       	acall	0x67
80004f7c:	80 00       	ld.sh	r0,r0[0x0]
80004f7e:	d6 78       	*unknown*
80004f80:	80 00       	ld.sh	r0,r0[0x0]
80004f82:	d6 84       	*unknown*
80004f84:	00 00       	add	r0,r0
80004f86:	51 30       	stdsp	sp[0x4c],r0
80004f88:	80 00       	ld.sh	r0,r0[0x0]
80004f8a:	4c 94       	lddpc	r4,800050ac <scan_rfid_save_message+0xc0>
80004f8c:	80 00       	ld.sh	r0,r0[0x0]
80004f8e:	3f 88       	mov	r8,-8
80004f90:	80 00       	ld.sh	r0,r0[0x0]
80004f92:	4e 08       	lddpc	r8,80005110 <scan_rfid_save_message+0x124>
80004f94:	80 00       	ld.sh	r0,r0[0x0]
80004f96:	76 a4       	ld.w	r4,r11[0x28]
80004f98:	80 00       	ld.sh	r0,r0[0x0]
80004f9a:	d6 90       	acall	0x69

80004f9c <scan_patrol>:
	return return_err;
	
}

U8 scan_patrol(char* SN)
{
80004f9c:	eb cd 40 80 	pushm	r7,lr
80004fa0:	18 97       	mov	r7,r12
	U8 return_err = MI_ERR;
	
	PcdReset();
80004fa2:	f0 1f 00 0d 	mcall	80004fd4 <scan_patrol+0x38>
	Powerdown_RC522(WAKEUP_RC522);
80004fa6:	30 0c       	mov	r12,0
80004fa8:	f0 1f 00 0c 	mcall	80004fd8 <scan_patrol+0x3c>
	return_err = rfid_auto_reader(SN);
80004fac:	0e 9c       	mov	r12,r7
80004fae:	f0 1f 00 0c 	mcall	80004fdc <scan_patrol+0x40>
80004fb2:	18 97       	mov	r7,r12
	Powerdown_RC522(ENTER_POWERDOWN);
80004fb4:	30 1c       	mov	r12,1
80004fb6:	f0 1f 00 09 	mcall	80004fd8 <scan_patrol+0x3c>
	if(return_err == 0)
80004fba:	58 07       	cp.w	r7,0
80004fbc:	c0 51       	brne	80004fc6 <scan_patrol+0x2a>
		log("scan_patrol okay!\n");
80004fbe:	48 9c       	lddpc	r12,80004fe0 <scan_patrol+0x44>
80004fc0:	f0 1f 00 09 	mcall	80004fe4 <scan_patrol+0x48>
80004fc4:	c0 48       	rjmp	80004fcc <scan_patrol+0x30>
	else
		log("scan_patrol err!\n");
80004fc6:	48 9c       	lddpc	r12,80004fe8 <scan_patrol+0x4c>
80004fc8:	f0 1f 00 07 	mcall	80004fe4 <scan_patrol+0x48>
		
	return return_err;

}
80004fcc:	0e 9c       	mov	r12,r7
80004fce:	e3 cd 80 80 	ldm	sp++,r7,pc
80004fd2:	00 00       	add	r0,r0
80004fd4:	80 00       	ld.sh	r0,r0[0x0]
80004fd6:	48 34       	lddpc	r4,80004fe0 <scan_patrol+0x44>
80004fd8:	80 00       	ld.sh	r0,r0[0x0]
80004fda:	49 0c       	lddpc	r12,80005018 <scan_rfid_save_message+0x2c>
80004fdc:	80 00       	ld.sh	r0,r0[0x0]
80004fde:	4e 7c       	lddpc	r12,80005178 <scan_rfid_save_message+0x18c>
80004fe0:	80 00       	ld.sh	r0,r0[0x0]
80004fe2:	d6 a0       	acall	0x6a
80004fe4:	80 00       	ld.sh	r0,r0[0x0]
80004fe6:	6e 28       	ld.w	r8,r7[0x8]
80004fe8:	80 00       	ld.sh	r0,r0[0x0]
80004fea:	d6 b4       	*unknown*

80004fec <scan_rfid_save_message>:
U8 scan_rfid_save_message()
{
80004fec:	eb cd 40 e0 	pushm	r5-r7,lr
80004ff0:	fa cd 00 8c 	sub	sp,sp,140
	U8 destination = DEST;
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	memset(SN, 0x00, 10);
80004ff4:	4e 0c       	lddpc	r12,80005174 <scan_rfid_save_message+0x188>
80004ff6:	30 08       	mov	r8,0
80004ff8:	30 09       	mov	r9,0
80004ffa:	f8 e9 00 00 	st.d	r12[0],r8
80004ffe:	30 0a       	mov	r10,0
80005000:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80005002:	fa e9 00 3c 	st.d	sp[60],r8
80005006:	fa e9 00 44 	st.d	sp[68],r8
8000500a:	fa e9 00 4c 	st.d	sp[76],r8
8000500e:	fa e9 00 54 	st.d	sp[84],r8
80005012:	fa e9 00 5c 	st.d	sp[92],r8
80005016:	fa e9 00 64 	st.d	sp[100],r8
8000501a:	fa e9 00 6c 	st.d	sp[108],r8
8000501e:	fa e9 00 74 	st.d	sp[116],r8
80005022:	fa e9 00 7c 	st.d	sp[124],r8
80005026:	fa e9 00 84 	st.d	sp[132],r8
	
	return_err = scan_patrol(SN);
8000502a:	f0 1f 00 54 	mcall	80005178 <scan_rfid_save_message+0x18c>
8000502e:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80005030:	e0 81 00 96 	brne	8000515c <scan_rfid_save_message+0x170>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80005034:	4d 06       	lddpc	r6,80005174 <scan_rfid_save_message+0x188>
80005036:	0d b8       	ld.ub	r8,r6[0x3]
80005038:	1a d8       	st.w	--sp,r8
8000503a:	0d a8       	ld.ub	r8,r6[0x2]
8000503c:	1a d8       	st.w	--sp,r8
8000503e:	0d 98       	ld.ub	r8,r6[0x1]
80005040:	1a d8       	st.w	--sp,r8
80005042:	0d 88       	ld.ub	r8,r6[0x0]
80005044:	1a d8       	st.w	--sp,r8
80005046:	4c ec       	lddpc	r12,8000517c <scan_rfid_save_message+0x190>
80005048:	f0 1f 00 4e 	mcall	80005180 <scan_rfid_save_message+0x194>
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!
8000504c:	37 7b       	mov	r11,119
8000504e:	30 1c       	mov	r12,1
80005050:	f0 1f 00 4d 	mcall	80005184 <scan_rfid_save_message+0x198>
80005054:	fa c8 ff ce 	sub	r8,sp,-50
80005058:	fa c9 ff cc 	sub	r9,sp,-52
		log("scan_patrol err!\n");
		
	return return_err;

}
U8 scan_rfid_save_message()
8000505c:	ec c5 ff fc 	sub	r5,r6,-4
80005060:	2f cd       	sub	sp,-16
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80005062:	30 9e       	mov	lr,9
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
80005064:	30 0c       	mov	r12,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80005066:	0d 8a       	ld.ub	r10,r6[0x0]
80005068:	f4 0b 16 04 	lsr	r11,r10,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
8000506c:	fc 0b 18 00 	cp.b	r11,lr
80005070:	f7 bb 08 d0 	subls	r11,-48
80005074:	f1 fb 8e 00 	st.bls	r8[0x0],r11
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
80005078:	f7 bb 0b a9 	subhi	r11,-87
8000507c:	f1 fb be 00 	st.bhi	r8[0x0],r11
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
80005080:	b0 9c       	st.b	r8[0x1],r12
			
			temp = (SN[i] & 0x0F);//瀛浣浣
80005082:	f5 da c0 04 	bfextu	r10,r10,0x0,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
80005086:	fc 0a 18 00 	cp.b	r10,lr
8000508a:	f7 ba 08 d0 	subls	r10,-48
8000508e:	f3 fa 8e 00 	st.bls	r9[0x0],r10
			else
			data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
80005092:	f7 ba 0b a9 	subhi	r10,-87
80005096:	f3 fa be 00 	st.bhi	r9[0x0],r10

			data_buffer.RFID_ID[i*4+3] = 0x00;
8000509a:	b0 bc       	st.b	r8[0x3],r12
8000509c:	2f f6       	sub	r6,-1
8000509e:	2f c8       	sub	r8,-4
800050a0:	2f c9       	sub	r9,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
800050a2:	0a 36       	cp.w	r6,r5
800050a4:	ce 11       	brne	80005066 <scan_rfid_save_message+0x7a>
		
		//memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
		
		header.length = (0x0008 + sizeof(Message_Data_t));
		
		if(start_session > 0x9f)start_session = 0x80;
800050a6:	4b 98       	lddpc	r8,80005188 <scan_rfid_save_message+0x19c>
800050a8:	11 89       	ld.ub	r9,r8[0x0]
800050aa:	39 f8       	mov	r8,-97
800050ac:	f0 09 18 00 	cp.b	r9,r8
800050b0:	e0 88 00 05 	brls	800050ba <scan_rfid_save_message+0xce>
800050b4:	38 09       	mov	r9,-128
800050b6:	4b 58       	lddpc	r8,80005188 <scan_rfid_save_message+0x19c>
800050b8:	b0 89       	st.b	r8[0x0],r9
		
		header.session_id = (++start_session);
800050ba:	4b 48       	lddpc	r8,80005188 <scan_rfid_save_message+0x19c>
800050bc:	11 86       	ld.ub	r6,r8[0x0]
800050be:	2f f6       	sub	r6,-1
800050c0:	b0 86       	st.b	r8[0x0],r6
		
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
800050c2:	30 5a       	mov	r10,5
800050c4:	4b 2b       	lddpc	r11,8000518c <scan_rfid_save_message+0x1a0>
800050c6:	fa cc ff c9 	sub	r12,sp,-55
800050ca:	f0 1f 00 32 	mcall	80005190 <scan_rfid_save_message+0x1a4>
		header.type = 0xe000;
		
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
800050ce:	31 88       	mov	r8,24
800050d0:	fb 58 00 32 	st.h	sp[50],r8
800050d4:	fb 66 00 36 	st.b	sp[54],r6
800050d8:	fe 78 e0 00 	mov	r8,-8192
800050dc:	fb 58 00 34 	st.h	sp[52],r8
800050e0:	fa c6 ff c4 	sub	r6,sp,-60
800050e4:	30 aa       	mov	r10,10
800050e6:	fa cb ff ce 	sub	r11,sp,-50
800050ea:	0c 9c       	mov	r12,r6
800050ec:	f0 1f 00 29 	mcall	80005190 <scan_rfid_save_message+0x1a4>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
800050f0:	31 0a       	mov	r10,16
800050f2:	fa cb ff de 	sub	r11,sp,-34
800050f6:	fa cc ff ba 	sub	r12,sp,-70
800050fa:	f0 1f 00 26 	mcall	80005190 <scan_rfid_save_message+0x1a4>
		
		//xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
		Message_Protocol_t  xgmessage;
		memcpy(&xgmessage, message, sizeof(Message_Protocol_t));
800050fe:	31 aa       	mov	r10,26
80005100:	0c 9b       	mov	r11,r6
80005102:	fa cc ff fe 	sub	r12,sp,-2
80005106:	f0 1f 00 23 	mcall	80005190 <scan_rfid_save_message+0x1a4>

		Message_Protocol_t * myptr = get_message_store();
8000510a:	4a 38       	lddpc	r8,80005194 <scan_rfid_save_message+0x1a8>
8000510c:	70 0c       	ld.w	r12,r8[0x0]
8000510e:	f0 1f 00 23 	mcall	80005198 <scan_rfid_save_message+0x1ac>
80005112:	50 7c       	stdsp	sp[0x1c],r12
		if(NULL != myptr)
80005114:	c2 00       	breq	80005154 <scan_rfid_save_message+0x168>
		{
			memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));
80005116:	31 aa       	mov	r10,26
80005118:	fa cb ff fe 	sub	r11,sp,-2
8000511c:	f0 1f 00 1d 	mcall	80005190 <scan_rfid_save_message+0x1a4>
			if (xQueueSend(xg_resend_queue, &myptr, 0) != pdPASS)
80005120:	49 f8       	lddpc	r8,8000519c <scan_rfid_save_message+0x1b0>
80005122:	70 0c       	ld.w	r12,r8[0x0]
80005124:	30 09       	mov	r9,0
80005126:	12 9a       	mov	r10,r9
80005128:	fa cb ff e4 	sub	r11,sp,-28
8000512c:	f0 1f 00 1d 	mcall	800051a0 <scan_rfid_save_message+0x1b4>
80005130:	58 1c       	cp.w	r12,1
80005132:	c1 c0       	breq	8000516a <scan_rfid_save_message+0x17e>
			{
				log("xg_resend_queue: full\n" );
80005134:	49 cc       	lddpc	r12,800051a4 <scan_rfid_save_message+0x1b8>
80005136:	f0 1f 00 13 	mcall	80005180 <scan_rfid_save_message+0x194>
				xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
8000513a:	32 3b       	mov	r11,35
8000513c:	30 1c       	mov	r12,1
8000513e:	f0 1f 00 12 	mcall	80005184 <scan_rfid_save_message+0x198>
				vTaskDelay(1500*2 / portTICK_RATE_MS);//寤惰1500ms
80005142:	e0 6c 0b b8 	mov	r12,3000
80005146:	f0 1f 00 19 	mcall	800051a8 <scan_rfid_save_message+0x1bc>
				xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
8000514a:	32 3b       	mov	r11,35
8000514c:	30 0c       	mov	r12,0
8000514e:	f0 1f 00 0e 	mcall	80005184 <scan_rfid_save_message+0x198>
80005152:	c0 c8       	rjmp	8000516a <scan_rfid_save_message+0x17e>
			}

		}
		else
		{
			log("myptr: err\n\r" );
80005154:	49 6c       	lddpc	r12,800051ac <scan_rfid_save_message+0x1c0>
80005156:	f0 1f 00 0b 	mcall	80005180 <scan_rfid_save_message+0x194>
8000515a:	c0 88       	rjmp	8000516a <scan_rfid_save_message+0x17e>
		}
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate scan rfid failure!!!
8000515c:	37 8b       	mov	r11,120
8000515e:	30 1c       	mov	r12,1
80005160:	f0 1f 00 09 	mcall	80005184 <scan_rfid_save_message+0x198>
		log("no card find...\n");
80005164:	49 3c       	lddpc	r12,800051b0 <scan_rfid_save_message+0x1c4>
80005166:	f0 1f 00 07 	mcall	80005180 <scan_rfid_save_message+0x194>
	}
	
	return return_err;
	
}
8000516a:	0e 9c       	mov	r12,r7
8000516c:	2d dd       	sub	sp,-140
8000516e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005172:	00 00       	add	r0,r0
80005174:	00 00       	add	r0,r0
80005176:	0b 60       	ld.uh	r0,--r5
80005178:	80 00       	ld.sh	r0,r0[0x0]
8000517a:	4f 9c       	lddpc	r12,8000535c <xg_flashc_init+0x74>
8000517c:	80 00       	ld.sh	r0,r0[0x0]
8000517e:	d6 c8       	*unknown*
80005180:	80 00       	ld.sh	r0,r0[0x0]
80005182:	6e 28       	ld.w	r8,r7[0x8]
80005184:	80 00       	ld.sh	r0,r0[0x0]
80005186:	3f 88       	mov	r8,-8
80005188:	00 00       	add	r0,r0
8000518a:	05 30       	ld.ub	r0,r2++
8000518c:	00 00       	add	r0,r0
8000518e:	05 28       	ld.uh	r8,r2++
80005190:	80 00       	ld.sh	r0,r0[0x0]
80005192:	76 a4       	ld.w	r4,r11[0x28]
80005194:	00 00       	add	r0,r0
80005196:	0b 70       	ld.ub	r0,--r5
80005198:	80 00       	ld.sh	r0,r0[0x0]
8000519a:	2c d0       	sub	r0,-51
8000519c:	00 00       	add	r0,r0
8000519e:	0b 6c       	ld.uh	r12,--r5
800051a0:	80 00       	ld.sh	r0,r0[0x0]
800051a2:	62 48       	ld.w	r8,r1[0x10]
800051a4:	80 00       	ld.sh	r0,r0[0x0]
800051a6:	d6 e4       	*unknown*
800051a8:	80 00       	ld.sh	r0,r0[0x0]
800051aa:	68 bc       	ld.w	r12,r4[0x2c]
800051ac:	80 00       	ld.sh	r0,r0[0x0]
800051ae:	d5 5c       	*unknown*
800051b0:	80 00       	ld.sh	r0,r0[0x0]
800051b2:	d6 fc       	*unknown*

800051b4 <rfid_init>:
/*the queue is used to receive failure-send message*/
extern volatile xQueueHandle xg_resend_queue ;


void rfid_init()
{
800051b4:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
800051b6:	f0 1f 00 02 	mcall	800051bc <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		//
}
800051ba:	d8 02       	popm	pc
800051bc:	80 00       	ld.sh	r0,r0[0x0]
800051be:	4a 44       	lddpc	r4,8000524c <local_start_timer+0x24>

800051c0 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
800051c0:	58 0c       	cp.w	r12,0
800051c2:	5e 0c       	reteq	r12
800051c4:	30 08       	mov	r8,0
	{
		nop();
800051c6:	d7 03       	nop
		nop();
800051c8:	d7 03       	nop
		nop();
800051ca:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
800051cc:	2f f8       	sub	r8,-1
800051ce:	10 3c       	cp.w	r12,r8
800051d0:	fe 9b ff fb 	brhi	800051c6 <delay_ns+0x6>
800051d4:	5e fc       	retal	r12
800051d6:	d7 03       	nop

800051d8 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
800051d8:	eb cd 40 e0 	pushm	r5-r7,lr
800051dc:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
800051de:	58 0c       	cp.w	r12,0
800051e0:	c0 b0       	breq	800051f6 <delay_us+0x1e>
800051e2:	30 07       	mov	r7,0
		delay_ns(1000);
800051e4:	e0 65 03 e8 	mov	r5,1000
800051e8:	0a 9c       	mov	r12,r5
800051ea:	f0 1f 00 05 	mcall	800051fc <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
800051ee:	2f f7       	sub	r7,-1
800051f0:	0e 36       	cp.w	r6,r7
800051f2:	fe 9b ff fb 	brhi	800051e8 <delay_us+0x10>
800051f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800051fa:	00 00       	add	r0,r0
800051fc:	80 00       	ld.sh	r0,r0[0x0]
800051fe:	51 c0       	stdsp	sp[0x70],r0

80005200 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
80005200:	eb cd 40 e0 	pushm	r5-r7,lr
80005204:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
80005206:	58 0c       	cp.w	r12,0
80005208:	c0 b0       	breq	8000521e <delay_ms+0x1e>
8000520a:	30 07       	mov	r7,0
		delay_us(1000);
8000520c:	e0 65 03 e8 	mov	r5,1000
80005210:	0a 9c       	mov	r12,r5
80005212:	f0 1f 00 05 	mcall	80005224 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
80005216:	2f f7       	sub	r7,-1
80005218:	0e 36       	cp.w	r6,r7
8000521a:	fe 9b ff fb 	brhi	80005210 <delay_ms+0x10>
8000521e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005222:	00 00       	add	r0,r0
80005224:	80 00       	ld.sh	r0,r0[0x0]
80005226:	51 d8       	stdsp	sp[0x74],r8

80005228 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80005228:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
8000522a:	30 3b       	mov	r11,3
8000522c:	48 8c       	lddpc	r12,8000524c <local_start_timer+0x24>
8000522e:	f0 1f 00 09 	mcall	80005250 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
80005232:	fe 78 38 00 	mov	r8,-51200
80005236:	e0 69 91 0d 	mov	r9,37133
8000523a:	ea 19 00 52 	orh	r9,0x52
8000523e:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005240:	32 09       	mov	r9,32
80005242:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005244:	30 59       	mov	r9,5
80005246:	91 09       	st.w	r8[0x0],r9
}
80005248:	d8 02       	popm	pc
8000524a:	00 00       	add	r0,r0
8000524c:	80 00       	ld.sh	r0,r0[0x0]
8000524e:	d7 10       	acall	0x71
80005250:	80 00       	ld.sh	r0,r0[0x0]
80005252:	53 d4       	stdsp	sp[0xf4],r4

80005254 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
80005254:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
80005256:	30 3a       	mov	r10,3
80005258:	e0 6b 1b 00 	mov	r11,6912
8000525c:	ea 1b 00 b7 	orh	r11,0xb7
80005260:	fe 7c 0c 00 	mov	r12,-62464
80005264:	f0 1f 00 19 	mcall	800052c8 <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
80005268:	31 08       	mov	r8,16
8000526a:	1a d8       	st.w	--sp,r8
8000526c:	30 08       	mov	r8,0
8000526e:	30 19       	mov	r9,1
80005270:	30 7a       	mov	r10,7
80005272:	10 9b       	mov	r11,r8
80005274:	fe 7c 0c 00 	mov	r12,-62464
80005278:	f0 1f 00 15 	mcall	800052cc <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
8000527c:	30 08       	mov	r8,0
8000527e:	30 19       	mov	r9,1
80005280:	12 9a       	mov	r10,r9
80005282:	10 9b       	mov	r11,r8
80005284:	fe 7c 0c 00 	mov	r12,-62464
80005288:	f0 1f 00 12 	mcall	800052d0 <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
8000528c:	30 0b       	mov	r11,0
8000528e:	fe 7c 0c 00 	mov	r12,-62464
80005292:	f0 1f 00 11 	mcall	800052d4 <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
80005296:	fe 7c 0c 00 	mov	r12,-62464
8000529a:	f0 1f 00 10 	mcall	800052d8 <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
8000529e:	30 0a       	mov	r10,0
800052a0:	1a da       	st.w	--sp,r10
800052a2:	1a da       	st.w	--sp,r10
800052a4:	14 98       	mov	r8,r10
800052a6:	14 99       	mov	r9,r10
800052a8:	30 1b       	mov	r11,1
800052aa:	fe 7c 0c 00 	mov	r12,-62464
800052ae:	f0 1f 00 0c 	mcall	800052dc <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
800052b2:	30 1c       	mov	r12,1
800052b4:	f0 1f 00 0b 	mcall	800052e0 <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
800052b8:	30 2b       	mov	r11,2
800052ba:	fe 7c 0c 00 	mov	r12,-62464
800052be:	f0 1f 00 0a 	mcall	800052e4 <local_start_pll0+0x90>
800052c2:	2f dd       	sub	sp,-12
/****/
}
800052c4:	d8 02       	popm	pc
800052c6:	00 00       	add	r0,r0
800052c8:	80 00       	ld.sh	r0,r0[0x0]
800052ca:	56 88       	stdsp	sp[0x1a0],r8
800052cc:	80 00       	ld.sh	r0,r0[0x0]
800052ce:	56 2a       	stdsp	sp[0x188],r10
800052d0:	80 00       	ld.sh	r0,r0[0x0]
800052d2:	56 4c       	stdsp	sp[0x190],r12
800052d4:	80 00       	ld.sh	r0,r0[0x0]
800052d6:	56 66       	stdsp	sp[0x198],r6
800052d8:	80 00       	ld.sh	r0,r0[0x0]
800052da:	56 74       	stdsp	sp[0x19c],r4
800052dc:	80 00       	ld.sh	r0,r0[0x0]
800052de:	55 e4       	stdsp	sp[0x178],r4
800052e0:	80 00       	ld.sh	r0,r0[0x0]
800052e2:	53 74       	stdsp	sp[0xdc],r4
800052e4:	80 00       	ld.sh	r0,r0[0x0]
800052e6:	56 7e       	stdsp	sp[0x19c],lr

800052e8 <xg_flashc_init>:
}


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
800052e8:	eb cd 40 e0 	pushm	r5-r7,lr
	//{
		//log("Create the xgflash_mutex semaphore failure\n");
	//}
	//
	/* Create the binary semaphore to Synchronize other threads.*/
	vSemaphoreCreateBinary(xBinarySemaphore);
800052ec:	30 0b       	mov	r11,0
800052ee:	30 1c       	mov	r12,1
800052f0:	f0 1f 00 18 	mcall	80005350 <xg_flashc_init+0x68>
800052f4:	49 88       	lddpc	r8,80005354 <xg_flashc_init+0x6c>
800052f6:	91 0c       	st.w	r8[0x0],r12
800052f8:	70 08       	ld.w	r8,r8[0x0]
800052fa:	58 08       	cp.w	r8,0
800052fc:	c0 80       	breq	8000530c <xg_flashc_init+0x24>
800052fe:	49 68       	lddpc	r8,80005354 <xg_flashc_init+0x6c>
80005300:	70 0c       	ld.w	r12,r8[0x0]
80005302:	30 09       	mov	r9,0
80005304:	12 9a       	mov	r10,r9
80005306:	12 9b       	mov	r11,r9
80005308:	f0 1f 00 14 	mcall	80005358 <xg_flashc_init+0x70>
	if (xBinarySemaphore == NULL)
8000530c:	49 28       	lddpc	r8,80005354 <xg_flashc_init+0x6c>
8000530e:	70 08       	ld.w	r8,r8[0x0]
80005310:	58 08       	cp.w	r8,0
80005312:	c0 41       	brne	8000531a <xg_flashc_init+0x32>
	{
		log("Create the xBinarySemaphore failure\n");
80005314:	49 2c       	lddpc	r12,8000535c <xg_flashc_init+0x74>
80005316:	f0 1f 00 13 	mcall	80005360 <xg_flashc_init+0x78>
	//if (SendM_CountingSemaphore == NULL)
	//{
		//log("Create the SendM_Counting semaphore failure\n");
	//}
	//
	xg_resend_queue = xQueueCreate(100, sizeof(U32));
8000531a:	30 4b       	mov	r11,4
8000531c:	36 4c       	mov	r12,100
8000531e:	f0 1f 00 0d 	mcall	80005350 <xg_flashc_init+0x68>
80005322:	49 18       	lddpc	r8,80005364 <xg_flashc_init+0x7c>
80005324:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(100, sizeof(U32));
80005326:	30 4b       	mov	r11,4
80005328:	36 4c       	mov	r12,100
8000532a:	f0 1f 00 0a 	mcall	80005350 <xg_flashc_init+0x68>
8000532e:	48 f8       	lddpc	r8,80005368 <xg_flashc_init+0x80>
80005330:	91 0c       	st.w	r8[0x0],r12
80005332:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
80005334:	10 96       	mov	r6,r8
80005336:	48 e5       	lddpc	r5,8000536c <xg_flashc_init+0x84>
80005338:	6c 0c       	ld.w	r12,r6[0x0]
8000533a:	ea 07 00 0b 	add	r11,r5,r7
8000533e:	f0 1f 00 0d 	mcall	80005370 <xg_flashc_init+0x88>
80005342:	2e 67       	sub	r7,-26
	//}
	//
	xg_resend_queue = xQueueCreate(100, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(100, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
80005344:	e0 47 0a 28 	cp.w	r7,2600
80005348:	cf 81       	brne	80005338 <xg_flashc_init+0x50>
	//flashc_lock_all_regions(false);
	//xgflash_list_info_init();
	
	
	//create_xg_flash_test_task();
}
8000534a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000534e:	00 00       	add	r0,r0
80005350:	80 00       	ld.sh	r0,r0[0x0]
80005352:	63 48       	ld.w	r8,r1[0x50]
80005354:	00 00       	add	r0,r0
80005356:	0b 74       	ld.ub	r4,--r5
80005358:	80 00       	ld.sh	r0,r0[0x0]
8000535a:	62 48       	ld.w	r8,r1[0x10]
8000535c:	80 00       	ld.sh	r0,r0[0x0]
8000535e:	d7 28       	*unknown*
80005360:	80 00       	ld.sh	r0,r0[0x0]
80005362:	6e 28       	ld.w	r8,r7[0x8]
80005364:	00 00       	add	r0,r0
80005366:	0b 6c       	ld.uh	r12,--r5
80005368:	00 00       	add	r0,r0
8000536a:	0b 70       	ld.ub	r0,--r5
8000536c:	00 00       	add	r0,r0
8000536e:	51 34       	stdsp	sp[0x4c],r4
80005370:	80 00       	ld.sh	r0,r0[0x0]
80005372:	2b 24       	sub	r4,-78

80005374 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
80005374:	fe 68 14 00 	mov	r8,-125952
80005378:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
8000537a:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
8000537e:	91 09       	st.w	r8[0x0],r9
}
80005380:	5e fc       	retal	r12

80005382 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005382:	f8 08 16 05 	lsr	r8,r12,0x5
80005386:	a9 68       	lsl	r8,0x8
80005388:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
8000538c:	58 1b       	cp.w	r11,1
8000538e:	c0 d0       	breq	800053a8 <gpio_enable_module_pin+0x26>
80005390:	c0 63       	brcs	8000539c <gpio_enable_module_pin+0x1a>
80005392:	58 2b       	cp.w	r11,2
80005394:	c1 00       	breq	800053b4 <gpio_enable_module_pin+0x32>
80005396:	58 3b       	cp.w	r11,3
80005398:	c1 40       	breq	800053c0 <gpio_enable_module_pin+0x3e>
8000539a:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000539c:	30 19       	mov	r9,1
8000539e:	f2 0c 09 49 	lsl	r9,r9,r12
800053a2:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800053a4:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800053a6:	c1 28       	rjmp	800053ca <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800053a8:	30 19       	mov	r9,1
800053aa:	f2 0c 09 49 	lsl	r9,r9,r12
800053ae:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800053b0:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800053b2:	c0 c8       	rjmp	800053ca <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800053b4:	30 19       	mov	r9,1
800053b6:	f2 0c 09 49 	lsl	r9,r9,r12
800053ba:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800053bc:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800053be:	c0 68       	rjmp	800053ca <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800053c0:	30 19       	mov	r9,1
800053c2:	f2 0c 09 49 	lsl	r9,r9,r12
800053c6:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800053c8:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800053ca:	30 19       	mov	r9,1
800053cc:	f2 0c 09 4c 	lsl	r12,r9,r12
800053d0:	91 2c       	st.w	r8[0x8],r12
800053d2:	5e fd       	retal	0

800053d4 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800053d4:	d4 21       	pushm	r4-r7,lr
800053d6:	18 97       	mov	r7,r12
800053d8:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800053da:	58 0b       	cp.w	r11,0
800053dc:	c0 31       	brne	800053e2 <gpio_enable_module+0xe>
800053de:	30 05       	mov	r5,0
800053e0:	c0 d8       	rjmp	800053fa <gpio_enable_module+0x26>
800053e2:	30 06       	mov	r6,0
800053e4:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800053e6:	6e 1b       	ld.w	r11,r7[0x4]
800053e8:	6e 0c       	ld.w	r12,r7[0x0]
800053ea:	f0 1f 00 06 	mcall	80005400 <gpio_enable_module+0x2c>
800053ee:	18 45       	or	r5,r12
		gpiomap++;
800053f0:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800053f2:	2f f6       	sub	r6,-1
800053f4:	0c 34       	cp.w	r4,r6
800053f6:	fe 9b ff f8 	brhi	800053e6 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
800053fa:	0a 9c       	mov	r12,r5
800053fc:	d8 22       	popm	r4-r7,pc
800053fe:	00 00       	add	r0,r0
80005400:	80 00       	ld.sh	r0,r0[0x0]
80005402:	53 82       	stdsp	sp[0xe0],r2

80005404 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005404:	f8 08 16 05 	lsr	r8,r12,0x5
80005408:	a9 68       	lsl	r8,0x8
8000540a:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
8000540e:	30 19       	mov	r9,1
80005410:	f2 0c 09 4c 	lsl	r12,r9,r12
80005414:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80005418:	91 1c       	st.w	r8[0x4],r12
}
8000541a:	5e fc       	retal	r12

8000541c <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000541c:	f8 08 16 05 	lsr	r8,r12,0x5
80005420:	a9 68       	lsl	r8,0x8
80005422:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80005426:	30 19       	mov	r9,1
80005428:	f2 0c 09 4c 	lsl	r12,r9,r12
8000542c:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80005430:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005434:	91 1c       	st.w	r8[0x4],r12
}
80005436:	5e fc       	retal	r12

80005438 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005438:	f8 08 16 05 	lsr	r8,r12,0x5
8000543c:	a9 68       	lsl	r8,0x8
8000543e:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80005442:	30 19       	mov	r9,1
80005444:	f2 0c 09 4c 	lsl	r12,r9,r12
80005448:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
8000544c:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005450:	91 1c       	st.w	r8[0x4],r12
}
80005452:	5e fc       	retal	r12

80005454 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80005454:	c0 08       	rjmp	80005454 <_unhandled_interrupt>
80005456:	d7 03       	nop

80005458 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005458:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
8000545c:	49 99       	lddpc	r9,800054c0 <INTC_register_interrupt+0x68>
8000545e:	f2 08 00 39 	add	r9,r9,r8<<0x3
80005462:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80005466:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80005468:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
8000546c:	58 0a       	cp.w	r10,0
8000546e:	c0 91       	brne	80005480 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005470:	49 59       	lddpc	r9,800054c4 <INTC_register_interrupt+0x6c>
80005472:	49 6a       	lddpc	r10,800054c8 <INTC_register_interrupt+0x70>
80005474:	12 1a       	sub	r10,r9
80005476:	fe 79 08 00 	mov	r9,-63488
8000547a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000547e:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005480:	58 1a       	cp.w	r10,1
80005482:	c0 a1       	brne	80005496 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80005484:	49 09       	lddpc	r9,800054c4 <INTC_register_interrupt+0x6c>
80005486:	49 2a       	lddpc	r10,800054cc <INTC_register_interrupt+0x74>
80005488:	12 1a       	sub	r10,r9
8000548a:	bf aa       	sbr	r10,0x1e
8000548c:	fe 79 08 00 	mov	r9,-63488
80005490:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005494:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80005496:	58 2a       	cp.w	r10,2
80005498:	c0 a1       	brne	800054ac <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000549a:	48 b9       	lddpc	r9,800054c4 <INTC_register_interrupt+0x6c>
8000549c:	48 da       	lddpc	r10,800054d0 <INTC_register_interrupt+0x78>
8000549e:	12 1a       	sub	r10,r9
800054a0:	bf ba       	sbr	r10,0x1f
800054a2:	fe 79 08 00 	mov	r9,-63488
800054a6:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800054aa:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800054ac:	48 69       	lddpc	r9,800054c4 <INTC_register_interrupt+0x6c>
800054ae:	48 aa       	lddpc	r10,800054d4 <INTC_register_interrupt+0x7c>
800054b0:	12 1a       	sub	r10,r9
800054b2:	ea 1a c0 00 	orh	r10,0xc000
800054b6:	fe 79 08 00 	mov	r9,-63488
800054ba:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800054be:	5e fc       	retal	r12
800054c0:	80 00       	ld.sh	r0,r0[0x0]
800054c2:	d7 60       	acall	0x76
800054c4:	80 00       	ld.sh	r0,r0[0x0]
800054c6:	cc 00       	breq	80005446 <gpio_clr_gpio_pin+0xe>
800054c8:	80 00       	ld.sh	r0,r0[0x0]
800054ca:	cd 04       	brge	8000546a <INTC_register_interrupt+0x12>
800054cc:	80 00       	ld.sh	r0,r0[0x0]
800054ce:	cd 12       	brcc	80005470 <INTC_register_interrupt+0x18>
800054d0:	80 00       	ld.sh	r0,r0[0x0]
800054d2:	cd 20       	breq	80005476 <INTC_register_interrupt+0x1e>
800054d4:	80 00       	ld.sh	r0,r0[0x0]
800054d6:	cd 2e       	rcall	8000527a <local_start_pll0+0x26>

800054d8 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800054d8:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800054da:	49 18       	lddpc	r8,8000551c <INTC_init_interrupts+0x44>
800054dc:	e3 b8 00 01 	mtsr	0x4,r8
800054e0:	49 0e       	lddpc	lr,80005520 <INTC_init_interrupts+0x48>
800054e2:	30 07       	mov	r7,0
800054e4:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800054e6:	49 0c       	lddpc	r12,80005524 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800054e8:	49 05       	lddpc	r5,80005528 <INTC_init_interrupts+0x50>
800054ea:	10 15       	sub	r5,r8
800054ec:	fe 76 08 00 	mov	r6,-63488
800054f0:	c1 08       	rjmp	80005510 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800054f2:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800054f4:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800054f6:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800054f8:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800054fc:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800054fe:	10 3a       	cp.w	r10,r8
80005500:	fe 9b ff fc 	brhi	800054f8 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005504:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80005508:	2f f7       	sub	r7,-1
8000550a:	2f 8e       	sub	lr,-8
8000550c:	59 37       	cp.w	r7,19
8000550e:	c0 50       	breq	80005518 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005510:	7c 08       	ld.w	r8,lr[0x0]
80005512:	58 08       	cp.w	r8,0
80005514:	ce f1       	brne	800054f2 <INTC_init_interrupts+0x1a>
80005516:	cf 7b       	rjmp	80005504 <INTC_init_interrupts+0x2c>
80005518:	d8 22       	popm	r4-r7,pc
8000551a:	00 00       	add	r0,r0
8000551c:	80 00       	ld.sh	r0,r0[0x0]
8000551e:	cc 00       	breq	8000549e <INTC_register_interrupt+0x46>
80005520:	80 00       	ld.sh	r0,r0[0x0]
80005522:	d7 60       	acall	0x76
80005524:	80 00       	ld.sh	r0,r0[0x0]
80005526:	54 54       	stdsp	sp[0x114],r4
80005528:	80 00       	ld.sh	r0,r0[0x0]
8000552a:	cd 04       	brge	800054ca <INTC_register_interrupt+0x72>

8000552c <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
8000552c:	fe 78 08 00 	mov	r8,-63488
80005530:	e0 69 00 83 	mov	r9,131
80005534:	f2 0c 01 0c 	sub	r12,r9,r12
80005538:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
8000553c:	f2 ca ff c0 	sub	r10,r9,-64
80005540:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005544:	58 08       	cp.w	r8,0
80005546:	c0 21       	brne	8000554a <_get_interrupt_handler+0x1e>
80005548:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000554a:	f0 08 12 00 	clz	r8,r8
8000554e:	48 5a       	lddpc	r10,80005560 <_get_interrupt_handler+0x34>
80005550:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005554:	f0 08 11 1f 	rsub	r8,r8,31
80005558:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000555a:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000555e:	5e fc       	retal	r12
80005560:	80 00       	ld.sh	r0,r0[0x0]
80005562:	d7 60       	acall	0x76

80005564 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80005564:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
80005566:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000556a:	99 a8       	st.w	r12[0x28],r8
}
8000556c:	5e fc       	retal	r12
8000556e:	d7 03       	nop

80005570 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80005570:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80005572:	ec 5b bb 9f 	cp.w	r11,899999
80005576:	e0 8b 00 04 	brhi	8000557e <pm_enable_osc0_crystal+0xe>
8000557a:	30 4b       	mov	r11,4
8000557c:	c1 38       	rjmp	800055a2 <pm_enable_osc0_crystal+0x32>
8000557e:	e0 68 c6 bf 	mov	r8,50879
80005582:	ea 18 00 2d 	orh	r8,0x2d
80005586:	10 3b       	cp.w	r11,r8
80005588:	e0 8b 00 04 	brhi	80005590 <pm_enable_osc0_crystal+0x20>
8000558c:	30 5b       	mov	r11,5
8000558e:	c0 a8       	rjmp	800055a2 <pm_enable_osc0_crystal+0x32>
80005590:	e0 68 12 00 	mov	r8,4608
80005594:	ea 18 00 7a 	orh	r8,0x7a
80005598:	10 3b       	cp.w	r11,r8
8000559a:	f9 bb 03 06 	movlo	r11,6
8000559e:	f9 bb 02 07 	movhs	r11,7
800055a2:	f0 1f 00 02 	mcall	800055a8 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
800055a6:	d8 02       	popm	pc
800055a8:	80 00       	ld.sh	r0,r0[0x0]
800055aa:	55 64       	stdsp	sp[0x158],r4

800055ac <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800055ac:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
800055ae:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800055b2:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
800055b4:	78 08       	ld.w	r8,r12[0x0]
800055b6:	a3 a8       	sbr	r8,0x2
800055b8:	99 08       	st.w	r12[0x0],r8
}
800055ba:	5e fc       	retal	r12

800055bc <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800055bc:	79 58       	ld.w	r8,r12[0x54]
800055be:	e2 18 00 80 	andl	r8,0x80,COH
800055c2:	cf d0       	breq	800055bc <pm_wait_for_clk0_ready>
}
800055c4:	5e fc       	retal	r12
800055c6:	d7 03       	nop

800055c8 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
800055c8:	eb cd 40 80 	pushm	r7,lr
800055cc:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
800055ce:	f0 1f 00 04 	mcall	800055dc <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
800055d2:	0e 9c       	mov	r12,r7
800055d4:	f0 1f 00 03 	mcall	800055e0 <pm_enable_clk0+0x18>
}
800055d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800055dc:	80 00       	ld.sh	r0,r0[0x0]
800055de:	55 ac       	stdsp	sp[0x168],r12
800055e0:	80 00       	ld.sh	r0,r0[0x0]
800055e2:	55 bc       	stdsp	sp[0x16c],r12

800055e4 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
800055e4:	eb cd 40 d0 	pushm	r4,r6-r7,lr
800055e8:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
800055ec:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
800055ee:	09 f7       	ld.ub	r7,r4[0x7]
800055f0:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
800055f4:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
800055f8:	09 b4       	ld.ub	r4,r4[0x3]
800055fa:	08 96       	mov	r6,r4
800055fc:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
80005600:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
80005604:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
80005608:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
8000560c:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
80005610:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
80005614:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
80005618:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
8000561c:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
8000561e:	79 58       	ld.w	r8,r12[0x54]
80005620:	e2 18 00 20 	andl	r8,0x20,COH
80005624:	cf d0       	breq	8000561e <pm_cksel+0x3a>
}
80005626:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

8000562a <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
8000562a:	eb cd 40 80 	pushm	r7,lr
8000562e:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
80005630:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
80005632:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
80005636:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
8000563a:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
8000563e:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
80005642:	2f 8b       	sub	r11,-8
80005644:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80005648:	e3 cd 80 80 	ldm	sp++,r7,pc

8000564c <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
8000564c:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
8000564e:	2f 8b       	sub	r11,-8
80005650:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
80005654:	f5 e9 10 19 	or	r9,r10,r9<<0x1
80005658:	f3 e8 10 28 	or	r8,r9,r8<<0x2
8000565c:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
80005660:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80005664:	d8 02       	popm	pc

80005666 <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
80005666:	2f 8b       	sub	r11,-8
80005668:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
8000566c:	a1 a8       	sbr	r8,0x0
8000566e:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
80005672:	5e fc       	retal	r12

80005674 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80005674:	79 58       	ld.w	r8,r12[0x54]
80005676:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000567a:	cf d0       	breq	80005674 <pm_wait_for_pll0_locked>
}
8000567c:	5e fc       	retal	r12

8000567e <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
8000567e:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80005680:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80005684:	99 08       	st.w	r12[0x0],r8
}
80005686:	5e fc       	retal	r12

80005688 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80005688:	eb cd 40 c0 	pushm	r6-r7,lr
8000568c:	18 97       	mov	r7,r12
8000568e:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80005690:	f0 1f 00 06 	mcall	800056a8 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80005694:	0c 9b       	mov	r11,r6
80005696:	0e 9c       	mov	r12,r7
80005698:	f0 1f 00 05 	mcall	800056ac <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
8000569c:	30 1b       	mov	r11,1
8000569e:	0e 9c       	mov	r12,r7
800056a0:	f0 1f 00 04 	mcall	800056b0 <pm_switch_to_osc0+0x28>
}
800056a4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800056a8:	80 00       	ld.sh	r0,r0[0x0]
800056aa:	55 70       	stdsp	sp[0x15c],r0
800056ac:	80 00       	ld.sh	r0,r0[0x0]
800056ae:	55 c8       	stdsp	sp[0x170],r8
800056b0:	80 00       	ld.sh	r0,r0[0x0]
800056b2:	56 7e       	stdsp	sp[0x19c],lr

800056b4 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
800056b4:	f8 c8 00 01 	sub	r8,r12,1
800056b8:	f0 0b 00 0b 	add	r11,r8,r11
800056bc:	f6 0c 0d 0a 	divu	r10,r11,r12
800056c0:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
800056c2:	f4 c8 00 01 	sub	r8,r10,1
800056c6:	e0 48 00 fe 	cp.w	r8,254
800056ca:	e0 88 00 03 	brls	800056d0 <getBaudDiv+0x1c>
800056ce:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
800056d0:	5c 8c       	casts.h	r12
}
800056d2:	5e fc       	retal	r12

800056d4 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800056d4:	f7 39 00 0d 	ld.ub	r9,r11[13]
800056d8:	30 18       	mov	r8,1
800056da:	f0 09 18 00 	cp.b	r9,r8
800056de:	e0 88 00 04 	brls	800056e6 <spi_initMaster+0x12>
800056e2:	30 2c       	mov	r12,2
800056e4:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800056e6:	e0 68 00 80 	mov	r8,128
800056ea:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
800056ec:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
800056ee:	30 19       	mov	r9,1
800056f0:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800056f4:	f7 39 00 0d 	ld.ub	r9,r11[13]
800056f8:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
800056fc:	30 09       	mov	r9,0
800056fe:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80005702:	30 fa       	mov	r10,15
80005704:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80005708:	99 18       	st.w	r12[0x4],r8
8000570a:	5e f9       	retal	r9

8000570c <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
8000570c:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
8000570e:	30 18       	mov	r8,1
80005710:	f0 0b 18 00 	cp.b	r11,r8
80005714:	5f be       	srhi	lr
80005716:	f0 0a 18 00 	cp.b	r10,r8
8000571a:	5f b8       	srhi	r8
8000571c:	fd e8 10 08 	or	r8,lr,r8
80005720:	c0 30       	breq	80005726 <spi_selectionMode+0x1a>
80005722:	30 2c       	mov	r12,2
80005724:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80005726:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80005728:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
8000572c:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80005730:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80005734:	99 18       	st.w	r12[0x4],r8
80005736:	d8 0a       	popm	pc,r12=0

80005738 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80005738:	30 18       	mov	r8,1
8000573a:	99 08       	st.w	r12[0x0],r8
}
8000573c:	5e fc       	retal	r12

8000573e <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
8000573e:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005742:	c0 58       	rjmp	8000574c <spi_write+0xe>
		if (!timeout--) {
80005744:	58 08       	cp.w	r8,0
80005746:	c0 21       	brne	8000574a <spi_write+0xc>
80005748:	5e ff       	retal	1
8000574a:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000574c:	78 49       	ld.w	r9,r12[0x10]
8000574e:	e2 19 00 02 	andl	r9,0x2,COH
80005752:	cf 90       	breq	80005744 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005754:	5c 7b       	castu.h	r11
80005756:	99 3b       	st.w	r12[0xc],r11
80005758:	5e fd       	retal	0

8000575a <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
8000575a:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
8000575e:	c0 58       	rjmp	80005768 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80005760:	58 08       	cp.w	r8,0
80005762:	c0 21       	brne	80005766 <spi_read+0xc>
80005764:	5e ff       	retal	1
80005766:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005768:	78 49       	ld.w	r9,r12[0x10]
8000576a:	e2 19 02 01 	andl	r9,0x201,COH
8000576e:	e0 49 02 01 	cp.w	r9,513
80005772:	cf 71       	brne	80005760 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005774:	78 28       	ld.w	r8,r12[0x8]
80005776:	b6 08       	st.h	r11[0x0],r8
80005778:	5e fd       	retal	0
8000577a:	d7 03       	nop

8000577c <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
8000577c:	eb cd 40 f8 	pushm	r3-r7,lr
80005780:	18 95       	mov	r5,r12
80005782:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005784:	f7 36 00 0c 	ld.ub	r6,r11[12]
80005788:	30 38       	mov	r8,3
8000578a:	f0 06 18 00 	cp.b	r6,r8
8000578e:	e0 8b 00 5e 	brhi	8000584a <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
80005792:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005796:	30 18       	mov	r8,1
80005798:	f0 04 18 00 	cp.b	r4,r8
8000579c:	e0 8b 00 57 	brhi	8000584a <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
800057a0:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800057a4:	30 78       	mov	r8,7
800057a6:	f0 03 18 00 	cp.b	r3,r8
800057aa:	e0 88 00 50 	brls	8000584a <spi_setupChipReg+0xce>
800057ae:	31 08       	mov	r8,16
800057b0:	f0 03 18 00 	cp.b	r3,r8
800057b4:	e0 8b 00 4b 	brhi	8000584a <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
800057b8:	14 9b       	mov	r11,r10
800057ba:	6e 1c       	ld.w	r12,r7[0x4]
800057bc:	f0 1f 00 26 	mcall	80005854 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
800057c0:	c4 55       	brlt	8000584a <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
800057c2:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
800057c4:	ec 09 16 01 	lsr	r9,r6,0x1
800057c8:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800057cc:	ec 16 00 01 	eorl	r6,0x1
800057d0:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
800057d4:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800057d8:	20 83       	sub	r3,8
800057da:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
800057de:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
800057e2:	ef 39 00 09 	ld.ub	r9,r7[9]
800057e6:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
800057ea:	ef 39 00 0a 	ld.ub	r9,r7[10]
800057ee:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
800057f2:	0f 89       	ld.ub	r9,r7[0x0]
800057f4:	30 1a       	mov	r10,1
800057f6:	f4 09 18 00 	cp.b	r9,r10
800057fa:	c0 d0       	breq	80005814 <spi_setupChipReg+0x98>
800057fc:	c0 a3       	brcs	80005810 <spi_setupChipReg+0x94>
800057fe:	30 2a       	mov	r10,2
80005800:	f4 09 18 00 	cp.b	r9,r10
80005804:	c0 a0       	breq	80005818 <spi_setupChipReg+0x9c>
80005806:	30 3a       	mov	r10,3
80005808:	f4 09 18 00 	cp.b	r9,r10
8000580c:	c1 f1       	brne	8000584a <spi_setupChipReg+0xce>
8000580e:	c0 78       	rjmp	8000581c <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80005810:	8b c8       	st.w	r5[0x30],r8
		break;
80005812:	c0 68       	rjmp	8000581e <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80005814:	8b d8       	st.w	r5[0x34],r8
		break;
80005816:	c0 48       	rjmp	8000581e <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80005818:	8b e8       	st.w	r5[0x38],r8
		break;
8000581a:	c0 28       	rjmp	8000581e <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
8000581c:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
8000581e:	48 f8       	lddpc	r8,80005858 <spi_setupChipReg+0xdc>
80005820:	70 08       	ld.w	r8,r8[0x0]
80005822:	58 08       	cp.w	r8,0
80005824:	c1 61       	brne	80005850 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
80005826:	30 0b       	mov	r11,0
80005828:	30 1c       	mov	r12,1
8000582a:	f0 1f 00 0d 	mcall	8000585c <spi_setupChipReg+0xe0>
8000582e:	48 b8       	lddpc	r8,80005858 <spi_setupChipReg+0xdc>
80005830:	91 0c       	st.w	r8[0x0],r12
80005832:	58 0c       	cp.w	r12,0
80005834:	c0 a0       	breq	80005848 <spi_setupChipReg+0xcc>
80005836:	30 09       	mov	r9,0
80005838:	12 9a       	mov	r10,r9
8000583a:	12 9b       	mov	r11,r9
8000583c:	f0 1f 00 09 	mcall	80005860 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80005840:	48 68       	lddpc	r8,80005858 <spi_setupChipReg+0xdc>
80005842:	70 08       	ld.w	r8,r8[0x0]
80005844:	58 08       	cp.w	r8,0
80005846:	c0 51       	brne	80005850 <spi_setupChipReg+0xd4>
80005848:	c0 08       	rjmp	80005848 <spi_setupChipReg+0xcc>
8000584a:	30 2c       	mov	r12,2
8000584c:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005850:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005854:	80 00       	ld.sh	r0,r0[0x0]
80005856:	56 b4       	stdsp	sp[0x1ac],r4
80005858:	00 00       	add	r0,r0
8000585a:	5b 60       	cp.w	r0,-10
8000585c:	80 00       	ld.sh	r0,r0[0x0]
8000585e:	63 48       	ld.w	r8,r1[0x50]
80005860:	80 00       	ld.sh	r0,r0[0x0]
80005862:	62 48       	ld.w	r8,r1[0x10]

80005864 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005864:	d4 01       	pushm	lr
80005866:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000586a:	c0 58       	rjmp	80005874 <spi_unselectChip+0x10>
		if (!timeout--) {
8000586c:	58 08       	cp.w	r8,0
8000586e:	c0 21       	brne	80005872 <spi_unselectChip+0xe>
80005870:	da 0a       	popm	pc,r12=1
80005872:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005874:	78 49       	ld.w	r9,r12[0x10]
80005876:	e2 19 02 00 	andl	r9,0x200,COH
8000587a:	cf 90       	breq	8000586c <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
8000587c:	78 18       	ld.w	r8,r12[0x4]
8000587e:	ea 18 00 0f 	orh	r8,0xf
80005882:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80005884:	fc 18 01 00 	movh	r8,0x100
80005888:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
8000588a:	30 09       	mov	r9,0
8000588c:	12 9a       	mov	r10,r9
8000588e:	12 9b       	mov	r11,r9
80005890:	48 38       	lddpc	r8,8000589c <spi_unselectChip+0x38>
80005892:	70 0c       	ld.w	r12,r8[0x0]
80005894:	f0 1f 00 03 	mcall	800058a0 <spi_unselectChip+0x3c>
80005898:	d8 0a       	popm	pc,r12=0
8000589a:	00 00       	add	r0,r0
8000589c:	00 00       	add	r0,r0
8000589e:	5b 60       	cp.w	r0,-10
800058a0:	80 00       	ld.sh	r0,r0[0x0]
800058a2:	62 48       	ld.w	r8,r1[0x10]

800058a4 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800058a4:	eb cd 40 f8 	pushm	r3-r7,lr
800058a8:	18 94       	mov	r4,r12
800058aa:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
800058ac:	49 a6       	lddpc	r6,80005914 <spi_selectChip+0x70>
800058ae:	30 07       	mov	r7,0
800058b0:	31 45       	mov	r5,20
800058b2:	0e 99       	mov	r9,r7
800058b4:	0a 9a       	mov	r10,r5
800058b6:	0e 9b       	mov	r11,r7
800058b8:	6c 0c       	ld.w	r12,r6[0x0]
800058ba:	f0 1f 00 18 	mcall	80005918 <spi_selectChip+0x74>
800058be:	cf a0       	breq	800058b2 <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800058c0:	68 18       	ld.w	r8,r4[0x4]
800058c2:	ea 18 00 0f 	orh	r8,0xf
800058c6:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
800058c8:	68 18       	ld.w	r8,r4[0x4]
800058ca:	e2 18 00 04 	andl	r8,0x4,COH
800058ce:	c1 10       	breq	800058f0 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
800058d0:	30 e8       	mov	r8,14
800058d2:	f0 03 18 00 	cp.b	r3,r8
800058d6:	e0 8b 00 1c 	brhi	8000590e <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800058da:	68 19       	ld.w	r9,r4[0x4]
800058dc:	e6 08 15 10 	lsl	r8,r3,0x10
800058e0:	ea 18 ff f0 	orh	r8,0xfff0
800058e4:	e8 18 ff ff 	orl	r8,0xffff
800058e8:	12 68       	and	r8,r9
800058ea:	89 18       	st.w	r4[0x4],r8
800058ec:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800058f0:	30 38       	mov	r8,3
800058f2:	f0 03 18 00 	cp.b	r3,r8
800058f6:	e0 8b 00 0c 	brhi	8000590e <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800058fa:	68 19       	ld.w	r9,r4[0x4]
800058fc:	2f 03       	sub	r3,-16
800058fe:	30 18       	mov	r8,1
80005900:	f0 03 09 48 	lsl	r8,r8,r3
80005904:	5c d8       	com	r8
80005906:	12 68       	and	r8,r9
80005908:	89 18       	st.w	r4[0x4],r8
8000590a:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
8000590e:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80005910:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005914:	00 00       	add	r0,r0
80005916:	5b 60       	cp.w	r0,-10
80005918:	80 00       	ld.sh	r0,r0[0x0]
8000591a:	60 3c       	ld.w	r12,r0[0xc]

8000591c <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
8000591c:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
8000591e:	f6 08 15 04 	lsl	r8,r11,0x4
80005922:	14 38       	cp.w	r8,r10
80005924:	f9 b8 08 10 	movls	r8,16
80005928:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
8000592c:	f0 0b 02 4b 	mul	r11,r8,r11
80005930:	f6 09 16 01 	lsr	r9,r11,0x1
80005934:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80005938:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
8000593c:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005940:	f2 cb 00 01 	sub	r11,r9,1
80005944:	e0 4b ff fe 	cp.w	r11,65534
80005948:	e0 88 00 03 	brls	8000594e <usart_set_async_baudrate+0x32>
8000594c:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
8000594e:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005950:	e8 6e 00 00 	mov	lr,524288
80005954:	59 08       	cp.w	r8,16
80005956:	fc 08 17 10 	movne	r8,lr
8000595a:	f9 b8 00 00 	moveq	r8,0
8000595e:	e4 1b ff f7 	andh	r11,0xfff7
80005962:	e0 1b fe cf 	andl	r11,0xfecf
80005966:	16 48       	or	r8,r11
80005968:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
8000596a:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
8000596e:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005972:	99 89       	st.w	r12[0x20],r9
80005974:	d8 0a       	popm	pc,r12=0

80005976 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80005976:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005978:	e2 18 00 02 	andl	r8,0x2,COH
8000597c:	c0 31       	brne	80005982 <usart_write_char+0xc>
8000597e:	30 2c       	mov	r12,2
80005980:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005982:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80005986:	99 7b       	st.w	r12[0x1c],r11
80005988:	5e fd       	retal	0
8000598a:	d7 03       	nop

8000598c <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
8000598c:	eb cd 40 e0 	pushm	r5-r7,lr
80005990:	18 96       	mov	r6,r12
80005992:	16 95       	mov	r5,r11
80005994:	e0 67 27 0f 	mov	r7,9999
80005998:	c0 68       	rjmp	800059a4 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
8000599a:	58 07       	cp.w	r7,0
8000599c:	c0 31       	brne	800059a2 <usart_putchar+0x16>
8000599e:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
800059a2:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
800059a4:	0a 9b       	mov	r11,r5
800059a6:	0c 9c       	mov	r12,r6
800059a8:	f0 1f 00 03 	mcall	800059b4 <usart_putchar+0x28>
800059ac:	cf 71       	brne	8000599a <usart_putchar+0xe>

  return USART_SUCCESS;
}
800059ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800059b2:	00 00       	add	r0,r0
800059b4:	80 00       	ld.sh	r0,r0[0x0]
800059b6:	59 76       	cp.w	r6,23

800059b8 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
800059b8:	78 58       	ld.w	r8,r12[0x14]
800059ba:	e2 18 00 e0 	andl	r8,0xe0,COH
800059be:	c0 30       	breq	800059c4 <usart_read_char+0xc>
800059c0:	30 4c       	mov	r12,4
800059c2:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
800059c4:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
800059c6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800059ca:	c0 31       	brne	800059d0 <usart_read_char+0x18>
800059cc:	30 3c       	mov	r12,3
800059ce:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
800059d0:	78 68       	ld.w	r8,r12[0x18]
800059d2:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800059d6:	97 08       	st.w	r11[0x0],r8
800059d8:	5e fd       	retal	0
800059da:	d7 03       	nop

800059dc <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
800059dc:	eb cd 40 c0 	pushm	r6-r7,lr
800059e0:	20 1d       	sub	sp,4
800059e2:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
800059e4:	1a 97       	mov	r7,sp
800059e6:	1a 9b       	mov	r11,sp
800059e8:	0c 9c       	mov	r12,r6
800059ea:	f0 1f 00 07 	mcall	80005a04 <usart_getchar+0x28>
800059ee:	58 3c       	cp.w	r12,3
800059f0:	cf b0       	breq	800059e6 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
800059f2:	58 4c       	cp.w	r12,4
800059f4:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
800059f8:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
800059fc:	2f fd       	sub	sp,-4
800059fe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005a02:	00 00       	add	r0,r0
80005a04:	80 00       	ld.sh	r0,r0[0x0]
80005a06:	59 b8       	cp.w	r8,27

80005a08 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80005a08:	eb cd 40 c0 	pushm	r6-r7,lr
80005a0c:	18 96       	mov	r6,r12
80005a0e:	16 97       	mov	r7,r11
  while (*string != '\0')
80005a10:	17 8b       	ld.ub	r11,r11[0x0]
80005a12:	58 0b       	cp.w	r11,0
80005a14:	c0 80       	breq	80005a24 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80005a16:	2f f7       	sub	r7,-1
80005a18:	0c 9c       	mov	r12,r6
80005a1a:	f0 1f 00 04 	mcall	80005a28 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005a1e:	0f 8b       	ld.ub	r11,r7[0x0]
80005a20:	58 0b       	cp.w	r11,0
80005a22:	cf a1       	brne	80005a16 <usart_write_line+0xe>
80005a24:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005a28:	80 00       	ld.sh	r0,r0[0x0]
80005a2a:	59 8c       	cp.w	r12,24

80005a2c <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005a2c:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005a30:	e6 18 00 01 	andh	r8,0x1,COH
80005a34:	c0 71       	brne	80005a42 <usart_reset+0x16>
80005a36:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005a38:	3f f8       	mov	r8,-1
80005a3a:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005a3c:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005a3e:	d5 03       	csrf	0x10
80005a40:	c0 48       	rjmp	80005a48 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005a42:	3f f8       	mov	r8,-1
80005a44:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005a46:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005a48:	30 08       	mov	r8,0
80005a4a:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005a4c:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005a4e:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005a50:	ea 68 61 0c 	mov	r8,680204
80005a54:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80005a56:	5e fc       	retal	r12

80005a58 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005a58:	eb cd 40 e0 	pushm	r5-r7,lr
80005a5c:	18 96       	mov	r6,r12
80005a5e:	16 97       	mov	r7,r11
80005a60:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005a62:	f0 1f 00 2f 	mcall	80005b1c <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80005a66:	58 07       	cp.w	r7,0
80005a68:	c5 80       	breq	80005b18 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005a6a:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005a6c:	30 49       	mov	r9,4
80005a6e:	f2 08 18 00 	cp.b	r8,r9
80005a72:	e0 88 00 53 	brls	80005b18 <usart_init_rs232+0xc0>
80005a76:	30 99       	mov	r9,9
80005a78:	f2 08 18 00 	cp.b	r8,r9
80005a7c:	e0 8b 00 4e 	brhi	80005b18 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005a80:	0f d9       	ld.ub	r9,r7[0x5]
80005a82:	30 78       	mov	r8,7
80005a84:	f0 09 18 00 	cp.b	r9,r8
80005a88:	e0 8b 00 48 	brhi	80005b18 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005a8c:	8e 39       	ld.sh	r9,r7[0x6]
80005a8e:	e0 68 01 01 	mov	r8,257
80005a92:	f0 09 19 00 	cp.h	r9,r8
80005a96:	e0 8b 00 41 	brhi	80005b18 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005a9a:	ef 39 00 08 	ld.ub	r9,r7[8]
80005a9e:	30 38       	mov	r8,3
80005aa0:	f0 09 18 00 	cp.b	r9,r8
80005aa4:	e0 8b 00 3a 	brhi	80005b18 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005aa8:	0a 9a       	mov	r10,r5
80005aaa:	6e 0b       	ld.w	r11,r7[0x0]
80005aac:	0c 9c       	mov	r12,r6
80005aae:	f0 1f 00 1d 	mcall	80005b20 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005ab2:	58 1c       	cp.w	r12,1
80005ab4:	c3 20       	breq	80005b18 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80005ab6:	0f c8       	ld.ub	r8,r7[0x4]
80005ab8:	30 99       	mov	r9,9
80005aba:	f2 08 18 00 	cp.b	r8,r9
80005abe:	c0 51       	brne	80005ac8 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005ac0:	6c 18       	ld.w	r8,r6[0x4]
80005ac2:	b1 b8       	sbr	r8,0x11
80005ac4:	8d 18       	st.w	r6[0x4],r8
80005ac6:	c0 68       	rjmp	80005ad2 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005ac8:	6c 19       	ld.w	r9,r6[0x4]
80005aca:	20 58       	sub	r8,5
80005acc:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005ad0:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005ad2:	6c 19       	ld.w	r9,r6[0x4]
80005ad4:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005ad8:	0f d8       	ld.ub	r8,r7[0x5]
80005ada:	a9 78       	lsl	r8,0x9
80005adc:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005ae0:	12 48       	or	r8,r9
80005ae2:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005ae4:	8e 38       	ld.sh	r8,r7[0x6]
80005ae6:	30 29       	mov	r9,2
80005ae8:	f2 08 19 00 	cp.h	r8,r9
80005aec:	e0 88 00 09 	brls	80005afe <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005af0:	6c 18       	ld.w	r8,r6[0x4]
80005af2:	ad b8       	sbr	r8,0xd
80005af4:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005af6:	8e b8       	ld.uh	r8,r7[0x6]
80005af8:	20 28       	sub	r8,2
80005afa:	8d a8       	st.w	r6[0x28],r8
80005afc:	c0 68       	rjmp	80005b08 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005afe:	6c 19       	ld.w	r9,r6[0x4]
80005b00:	5c 78       	castu.h	r8
80005b02:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005b06:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005b08:	6c 18       	ld.w	r8,r6[0x4]
80005b0a:	e0 18 ff f0 	andl	r8,0xfff0
80005b0e:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005b10:	35 08       	mov	r8,80
80005b12:	8d 08       	st.w	r6[0x0],r8
80005b14:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005b18:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005b1c:	80 00       	ld.sh	r0,r0[0x0]
80005b1e:	5a 2c       	cp.w	r12,-30
80005b20:	80 00       	ld.sh	r0,r0[0x0]
80005b22:	59 1c       	cp.w	r12,17

80005b24 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005b24:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005b28:	fe c0 8f 28 	sub	r0,pc,-28888

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005b2c:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005b30:	d5 53       	csrf	0x15
  cp      r0, r1
80005b32:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005b34:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005b38:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80005b3a:	c0 62       	brcc	80005b46 <idata_load_loop_end>
  cp      r0, r1
80005b3c:	48 92       	lddpc	r2,80005b60 <udata_clear_loop_end+0x4>

80005b3e <idata_load_loop>:
  brlo    idata_load_loop
80005b3e:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005b40:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005b42:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005b44:	cf d3       	brcs	80005b3e <idata_load_loop>

80005b46 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005b46:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
80005b4a:	e0 61 5b 70 	mov	r1,23408
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005b4e:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005b50:	c0 62       	brcc	80005b5c <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005b52:	30 02       	mov	r2,0
80005b54:	30 03       	mov	r3,0

80005b56 <udata_clear_loop>:
80005b56:	a1 22       	st.d	r0++,r2
80005b58:	02 30       	cp.w	r0,r1
80005b5a:	cf e3       	brcs	80005b56 <udata_clear_loop>

80005b5c <udata_clear_loop_end>:
80005b5c:	fe cf e9 80 	sub	pc,pc,-5760
80005b60:	80 00       	ld.sh	r0,r0[0x0]
80005b62:	e0 90 f8 c8 	breq	80044cf2 <_data_lma+0x36c62>

80005b64 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005b64:	f8 c8 ff f8 	sub	r8,r12,-8
80005b68:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005b6a:	3f f9       	mov	r9,-1
80005b6c:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005b6e:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005b70:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005b72:	30 08       	mov	r8,0
80005b74:	99 08       	st.w	r12[0x0],r8
}
80005b76:	5e fc       	retal	r12

80005b78 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005b78:	30 08       	mov	r8,0
80005b7a:	99 48       	st.w	r12[0x10],r8
}
80005b7c:	5e fc       	retal	r12

80005b7e <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005b7e:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005b80:	70 19       	ld.w	r9,r8[0x4]
80005b82:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005b84:	78 19       	ld.w	r9,r12[0x4]
80005b86:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005b88:	70 19       	ld.w	r9,r8[0x4]
80005b8a:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005b8c:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005b8e:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005b90:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005b92:	78 08       	ld.w	r8,r12[0x0]
80005b94:	2f f8       	sub	r8,-1
80005b96:	99 08       	st.w	r12[0x0],r8
}
80005b98:	5e fc       	retal	r12

80005b9a <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005b9a:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005b9c:	5b fa       	cp.w	r10,-1
80005b9e:	c0 31       	brne	80005ba4 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005ba0:	78 48       	ld.w	r8,r12[0x10]
80005ba2:	c0 c8       	rjmp	80005bba <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005ba4:	f8 c8 ff f8 	sub	r8,r12,-8
80005ba8:	70 19       	ld.w	r9,r8[0x4]
80005baa:	72 09       	ld.w	r9,r9[0x0]
80005bac:	12 3a       	cp.w	r10,r9
80005bae:	c0 63       	brcs	80005bba <vListInsert+0x20>
80005bb0:	70 18       	ld.w	r8,r8[0x4]
80005bb2:	70 19       	ld.w	r9,r8[0x4]
80005bb4:	72 09       	ld.w	r9,r9[0x0]
80005bb6:	12 3a       	cp.w	r10,r9
80005bb8:	cf c2       	brcc	80005bb0 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005bba:	70 19       	ld.w	r9,r8[0x4]
80005bbc:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005bbe:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005bc0:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005bc2:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005bc4:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005bc6:	78 08       	ld.w	r8,r12[0x0]
80005bc8:	2f f8       	sub	r8,-1
80005bca:	99 08       	st.w	r12[0x0],r8
}
80005bcc:	5e fc       	retal	r12

80005bce <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005bce:	78 18       	ld.w	r8,r12[0x4]
80005bd0:	78 29       	ld.w	r9,r12[0x8]
80005bd2:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005bd4:	78 28       	ld.w	r8,r12[0x8]
80005bd6:	78 19       	ld.w	r9,r12[0x4]
80005bd8:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005bda:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005bdc:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005bde:	18 39       	cp.w	r9,r12
80005be0:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005be4:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005be8:	30 09       	mov	r9,0
80005bea:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005bec:	70 09       	ld.w	r9,r8[0x0]
80005bee:	20 19       	sub	r9,1
80005bf0:	91 09       	st.w	r8[0x0],r9
}
80005bf2:	5e fc       	retal	r12

80005bf4 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005bf4:	e0 68 08 08 	mov	r8,2056
80005bf8:	ea 18 08 08 	orh	r8,0x808
80005bfc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005bfe:	e0 68 09 09 	mov	r8,2313
80005c02:	ea 18 09 09 	orh	r8,0x909
80005c06:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005c08:	e0 68 0a 0a 	mov	r8,2570
80005c0c:	ea 18 0a 0a 	orh	r8,0xa0a
80005c10:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005c12:	e0 68 0b 0b 	mov	r8,2827
80005c16:	ea 18 0b 0b 	orh	r8,0xb0b
80005c1a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005c1c:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005c1e:	e0 68 be ef 	mov	r8,48879
80005c22:	ea 18 de ad 	orh	r8,0xdead
80005c26:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005c28:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005c2a:	fc 18 00 40 	movh	r8,0x40
80005c2e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005c30:	e0 68 00 ff 	mov	r8,255
80005c34:	ea 18 ff 00 	orh	r8,0xff00
80005c38:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005c3a:	e0 68 01 01 	mov	r8,257
80005c3e:	ea 18 01 01 	orh	r8,0x101
80005c42:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005c44:	e0 68 02 02 	mov	r8,514
80005c48:	ea 18 02 02 	orh	r8,0x202
80005c4c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005c4e:	e0 68 03 03 	mov	r8,771
80005c52:	ea 18 03 03 	orh	r8,0x303
80005c56:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005c58:	e0 68 04 04 	mov	r8,1028
80005c5c:	ea 18 04 04 	orh	r8,0x404
80005c60:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005c62:	e0 68 05 05 	mov	r8,1285
80005c66:	ea 18 05 05 	orh	r8,0x505
80005c6a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005c6c:	e0 68 06 06 	mov	r8,1542
80005c70:	ea 18 06 06 	orh	r8,0x606
80005c74:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005c76:	e0 68 07 07 	mov	r8,1799
80005c7a:	ea 18 07 07 	orh	r8,0x707
80005c7e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005c80:	30 08       	mov	r8,0
80005c82:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005c84:	5e fc       	retal	r12
80005c86:	d7 03       	nop

80005c88 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005c88:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005c8a:	48 38       	lddpc	r8,80005c94 <vPortEnterCritical+0xc>
80005c8c:	70 09       	ld.w	r9,r8[0x0]
80005c8e:	2f f9       	sub	r9,-1
80005c90:	91 09       	st.w	r8[0x0],r9
}
80005c92:	5e fc       	retal	r12
80005c94:	00 00       	add	r0,r0
80005c96:	05 34       	ld.ub	r4,r2++

80005c98 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005c98:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005c9a:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005c9c:	30 0a       	mov	r10,0
80005c9e:	14 9b       	mov	r11,r10
80005ca0:	49 2c       	lddpc	r12,80005ce8 <xPortStartScheduler+0x50>
80005ca2:	f0 1f 00 13 	mcall	80005cec <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005ca6:	e0 68 5d c0 	mov	r8,24000
80005caa:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005cae:	30 08       	mov	r8,0
80005cb0:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005cb4:	e0 68 0c f0 	mov	r8,3312
80005cb8:	ea 18 00 00 	orh	r8,0x0
80005cbc:	70 00       	ld.w	r0,r8[0x0]
80005cbe:	60 0d       	ld.w	sp,r0[0x0]
80005cc0:	1b 00       	ld.w	r0,sp++
80005cc2:	e0 68 05 34 	mov	r8,1332
80005cc6:	ea 18 00 00 	orh	r8,0x0
80005cca:	91 00       	st.w	r8[0x0],r0
80005ccc:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005cd0:	2f ed       	sub	sp,-8
80005cd2:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005cd6:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005cda:	e3 b0 00 00 	mtsr	0x0,r0
80005cde:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005ce2:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005ce6:	d8 0a       	popm	pc,r12=0
80005ce8:	80 00       	ld.sh	r0,r0[0x0]
80005cea:	5d b4       	*unknown*
80005cec:	80 00       	ld.sh	r0,r0[0x0]
80005cee:	54 58       	stdsp	sp[0x114],r8

80005cf0 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005cf0:	20 6d       	sub	sp,24
80005cf2:	eb cd 00 ff 	pushm	r0-r7
80005cf6:	fa c7 ff c0 	sub	r7,sp,-64
80005cfa:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005cfe:	ef 40 ff e0 	st.w	r7[-32],r0
80005d02:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005d06:	ef 40 ff e4 	st.w	r7[-28],r0
80005d0a:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005d0e:	e0 68 05 34 	mov	r8,1332
80005d12:	ea 18 00 00 	orh	r8,0x0
80005d16:	70 00       	ld.w	r0,r8[0x0]
80005d18:	1a d0       	st.w	--sp,r0
80005d1a:	f0 1f 00 1a 	mcall	80005d80 <LABEL_RET_SCALL_263+0x14>
80005d1e:	e0 68 0c f0 	mov	r8,3312
80005d22:	ea 18 00 00 	orh	r8,0x0
80005d26:	70 00       	ld.w	r0,r8[0x0]
80005d28:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005d2a:	f0 1f 00 17 	mcall	80005d84 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005d2e:	e0 68 0c f0 	mov	r8,3312
80005d32:	ea 18 00 00 	orh	r8,0x0
80005d36:	70 00       	ld.w	r0,r8[0x0]
80005d38:	60 0d       	ld.w	sp,r0[0x0]
80005d3a:	1b 00       	ld.w	r0,sp++
80005d3c:	e0 68 05 34 	mov	r8,1332
80005d40:	ea 18 00 00 	orh	r8,0x0
80005d44:	91 00       	st.w	r8[0x0],r0
80005d46:	fa c7 ff d8 	sub	r7,sp,-40
80005d4a:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005d4e:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005d52:	e0 61 05 34 	mov	r1,1332
80005d56:	ea 11 00 00 	orh	r1,0x0
80005d5a:	62 02       	ld.w	r2,r1[0x0]
80005d5c:	58 02       	cp.w	r2,0
80005d5e:	c0 70       	breq	80005d6c <LABEL_RET_SCALL_263>
80005d60:	e4 c2 00 01 	sub	r2,r2,1
80005d64:	83 02       	st.w	r1[0x0],r2
80005d66:	58 02       	cp.w	r2,0
80005d68:	c0 21       	brne	80005d6c <LABEL_RET_SCALL_263>
80005d6a:	b1 c0       	cbr	r0,0x10

80005d6c <LABEL_RET_SCALL_263>:
80005d6c:	ef 40 ff f8 	st.w	r7[-8],r0
80005d70:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005d74:	ef 40 ff fc 	st.w	r7[-4],r0
80005d78:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005d7c:	2f ad       	sub	sp,-24
80005d7e:	d6 13       	rets
80005d80:	80 00       	ld.sh	r0,r0[0x0]
80005d82:	5c 88       	casts.h	r8
80005d84:	80 00       	ld.sh	r0,r0[0x0]
80005d86:	63 cc       	ld.w	r12,r1[0x70]

80005d88 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005d88:	e1 b8 00 43 	mfsr	r8,0x10c
80005d8c:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005d90:	5e fc       	retal	r12
80005d92:	d7 03       	nop

80005d94 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005d94:	48 78       	lddpc	r8,80005db0 <vPortExitCritical+0x1c>
80005d96:	70 08       	ld.w	r8,r8[0x0]
80005d98:	58 08       	cp.w	r8,0
80005d9a:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005d9c:	48 58       	lddpc	r8,80005db0 <vPortExitCritical+0x1c>
80005d9e:	70 09       	ld.w	r9,r8[0x0]
80005da0:	20 19       	sub	r9,1
80005da2:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005da4:	70 08       	ld.w	r8,r8[0x0]
80005da6:	58 08       	cp.w	r8,0
80005da8:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005daa:	d5 03       	csrf	0x10
80005dac:	5e fc       	retal	r12
80005dae:	00 00       	add	r0,r0
80005db0:	00 00       	add	r0,r0
80005db2:	05 34       	ld.ub	r4,r2++

80005db4 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005db4:	eb cd 00 ff 	pushm	r0-r7
80005db8:	e0 68 05 34 	mov	r8,1332
80005dbc:	ea 18 00 00 	orh	r8,0x0
80005dc0:	70 00       	ld.w	r0,r8[0x0]
80005dc2:	1a d0       	st.w	--sp,r0
80005dc4:	7a 90       	ld.w	r0,sp[0x24]
80005dc6:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005dca:	58 10       	cp.w	r0,1
80005dcc:	e0 8b 00 08 	brhi	80005ddc <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005dd0:	e0 68 0c f0 	mov	r8,3312
80005dd4:	ea 18 00 00 	orh	r8,0x0
80005dd8:	70 00       	ld.w	r0,r8[0x0]
80005dda:	81 0d       	st.w	r0[0x0],sp

80005ddc <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005ddc:	f0 1f 00 12 	mcall	80005e24 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005de0:	f0 1f 00 12 	mcall	80005e28 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005de4:	f0 1f 00 12 	mcall	80005e2c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005de8:	f0 1f 00 12 	mcall	80005e30 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005dec:	7a 90       	ld.w	r0,sp[0x24]
80005dee:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005df2:	58 10       	cp.w	r0,1
80005df4:	e0 8b 00 0e 	brhi	80005e10 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005df8:	f0 1f 00 0c 	mcall	80005e28 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005dfc:	f0 1f 00 0e 	mcall	80005e34 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005e00:	f0 1f 00 0c 	mcall	80005e30 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005e04:	e0 68 0c f0 	mov	r8,3312
80005e08:	ea 18 00 00 	orh	r8,0x0
80005e0c:	70 00       	ld.w	r0,r8[0x0]
80005e0e:	60 0d       	ld.w	sp,r0[0x0]

80005e10 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005e10:	1b 00       	ld.w	r0,sp++
80005e12:	e0 68 05 34 	mov	r8,1332
80005e16:	ea 18 00 00 	orh	r8,0x0
80005e1a:	91 00       	st.w	r8[0x0],r0
80005e1c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005e20:	d6 03       	rete
80005e22:	00 00       	add	r0,r0
80005e24:	80 00       	ld.sh	r0,r0[0x0]
80005e26:	5d 88       	*unknown*
80005e28:	80 00       	ld.sh	r0,r0[0x0]
80005e2a:	5c 88       	casts.h	r8
80005e2c:	80 00       	ld.sh	r0,r0[0x0]
80005e2e:	65 d0       	ld.w	r0,r2[0x74]
80005e30:	80 00       	ld.sh	r0,r0[0x0]
80005e32:	5d 94       	*unknown*
80005e34:	80 00       	ld.sh	r0,r0[0x0]
80005e36:	63 cc       	ld.w	r12,r1[0x70]

80005e38 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005e38:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005e3a:	f0 1f 00 02 	mcall	80005e40 <__malloc_lock+0x8>
}
80005e3e:	d8 02       	popm	pc
80005e40:	80 00       	ld.sh	r0,r0[0x0]
80005e42:	63 bc       	ld.w	r12,r1[0x6c]

80005e44 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005e44:	d4 01       	pushm	lr
	xTaskResumeAll();
80005e46:	f0 1f 00 02 	mcall	80005e4c <__malloc_unlock+0x8>
}
80005e4a:	d8 02       	popm	pc
80005e4c:	80 00       	ld.sh	r0,r0[0x0]
80005e4e:	67 78       	ld.w	r8,r3[0x5c]

80005e50 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005e50:	d4 21       	pushm	r4-r7,lr
80005e52:	16 95       	mov	r5,r11
80005e54:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005e56:	58 0c       	cp.w	r12,0
80005e58:	c0 30       	breq	80005e5e <_read+0xe>
80005e5a:	3f f7       	mov	r7,-1
80005e5c:	c1 48       	rjmp	80005e84 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005e5e:	58 0a       	cp.w	r10,0
80005e60:	e0 89 00 04 	brgt	80005e68 <_read+0x18>
80005e64:	30 07       	mov	r7,0
80005e66:	c0 f8       	rjmp	80005e84 <_read+0x34>
80005e68:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005e6a:	48 84       	lddpc	r4,80005e88 <_read+0x38>
80005e6c:	68 0c       	ld.w	r12,r4[0x0]
80005e6e:	f0 1f 00 08 	mcall	80005e8c <_read+0x3c>
    if (c < 0)
80005e72:	c0 95       	brlt	80005e84 <_read+0x34>
      break;

    *ptr++ = c;
80005e74:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005e78:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005e7a:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005e7e:	58 08       	cp.w	r8,0
80005e80:	fe 99 ff f6 	brgt	80005e6c <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005e84:	0e 9c       	mov	r12,r7
80005e86:	d8 22       	popm	r4-r7,pc
80005e88:	00 00       	add	r0,r0
80005e8a:	5b 64       	cp.w	r4,-10
80005e8c:	80 00       	ld.sh	r0,r0[0x0]
80005e8e:	59 dc       	cp.w	r12,29

80005e90 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005e90:	d4 21       	pushm	r4-r7,lr
80005e92:	16 95       	mov	r5,r11
80005e94:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005e96:	20 1c       	sub	r12,1
80005e98:	58 2c       	cp.w	r12,2
80005e9a:	e0 8b 00 12 	brhi	80005ebe <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005e9e:	58 0a       	cp.w	r10,0
80005ea0:	c0 31       	brne	80005ea6 <_write+0x16>
80005ea2:	30 07       	mov	r7,0
80005ea4:	c0 e8       	rjmp	80005ec0 <_write+0x30>
80005ea6:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005ea8:	48 74       	lddpc	r4,80005ec4 <_write+0x34>
80005eaa:	68 0c       	ld.w	r12,r4[0x0]
80005eac:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005eb0:	f0 1f 00 06 	mcall	80005ec8 <_write+0x38>
80005eb4:	c0 55       	brlt	80005ebe <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005eb6:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005eb8:	0e 36       	cp.w	r6,r7
80005eba:	cf 81       	brne	80005eaa <_write+0x1a>
80005ebc:	c0 28       	rjmp	80005ec0 <_write+0x30>
80005ebe:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005ec0:	0e 9c       	mov	r12,r7
80005ec2:	d8 22       	popm	r4-r7,pc
80005ec4:	00 00       	add	r0,r0
80005ec6:	5b 64       	cp.w	r4,-10
80005ec8:	80 00       	ld.sh	r0,r0[0x0]
80005eca:	59 8c       	cp.w	r12,24

80005ecc <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005ecc:	eb cd 40 80 	pushm	r7,lr
80005ed0:	18 97       	mov	r7,r12
	if( pv )
80005ed2:	58 0c       	cp.w	r12,0
80005ed4:	c0 80       	breq	80005ee4 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005ed6:	f0 1f 00 05 	mcall	80005ee8 <vPortFree+0x1c>
		{
			free( pv );
80005eda:	0e 9c       	mov	r12,r7
80005edc:	f0 1f 00 04 	mcall	80005eec <vPortFree+0x20>
		}
		xTaskResumeAll();
80005ee0:	f0 1f 00 04 	mcall	80005ef0 <vPortFree+0x24>
80005ee4:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ee8:	80 00       	ld.sh	r0,r0[0x0]
80005eea:	63 bc       	ld.w	r12,r1[0x6c]
80005eec:	80 00       	ld.sh	r0,r0[0x0]
80005eee:	72 4c       	ld.w	r12,r9[0x10]
80005ef0:	80 00       	ld.sh	r0,r0[0x0]
80005ef2:	67 78       	ld.w	r8,r3[0x5c]

80005ef4 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005ef4:	eb cd 40 80 	pushm	r7,lr
80005ef8:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005efa:	f0 1f 00 06 	mcall	80005f10 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005efe:	0e 9c       	mov	r12,r7
80005f00:	f0 1f 00 05 	mcall	80005f14 <pvPortMalloc+0x20>
80005f04:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005f06:	f0 1f 00 05 	mcall	80005f18 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005f0a:	0e 9c       	mov	r12,r7
80005f0c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005f10:	80 00       	ld.sh	r0,r0[0x0]
80005f12:	63 bc       	ld.w	r12,r1[0x6c]
80005f14:	80 00       	ld.sh	r0,r0[0x0]
80005f16:	72 5c       	ld.w	r12,r9[0x14]
80005f18:	80 00       	ld.sh	r0,r0[0x0]
80005f1a:	67 78       	ld.w	r8,r3[0x5c]

80005f1c <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005f1c:	d4 01       	pushm	lr
80005f1e:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005f20:	78 09       	ld.w	r9,r12[0x0]
80005f22:	58 09       	cp.w	r9,0
80005f24:	c1 10       	breq	80005f46 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005f26:	78 3a       	ld.w	r10,r12[0xc]
80005f28:	79 09       	ld.w	r9,r12[0x40]
80005f2a:	f4 09 00 09 	add	r9,r10,r9
80005f2e:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005f30:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005f32:	14 39       	cp.w	r9,r10
80005f34:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005f38:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005f3c:	79 0a       	ld.w	r10,r12[0x40]
80005f3e:	78 3b       	ld.w	r11,r12[0xc]
80005f40:	10 9c       	mov	r12,r8
80005f42:	f0 1f 00 02 	mcall	80005f48 <prvCopyDataFromQueue+0x2c>
80005f46:	d8 02       	popm	pc
80005f48:	80 00       	ld.sh	r0,r0[0x0]
80005f4a:	76 a4       	ld.w	r4,r11[0x28]

80005f4c <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005f4c:	eb cd 40 c0 	pushm	r6-r7,lr
80005f50:	18 97       	mov	r7,r12
80005f52:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005f54:	78 e8       	ld.w	r8,r12[0x38]
80005f56:	58 08       	cp.w	r8,0
80005f58:	c0 31       	brne	80005f5e <xQueueReceiveFromISR+0x12>
80005f5a:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005f5e:	f0 1f 00 0e 	mcall	80005f94 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80005f62:	6e e8       	ld.w	r8,r7[0x38]
80005f64:	20 18       	sub	r8,1
80005f66:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80005f68:	6f 18       	ld.w	r8,r7[0x44]
80005f6a:	5b f8       	cp.w	r8,-1
80005f6c:	c0 d1       	brne	80005f86 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005f6e:	6e 48       	ld.w	r8,r7[0x10]
80005f70:	58 08       	cp.w	r8,0
80005f72:	c0 f0       	breq	80005f90 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005f74:	ee cc ff f0 	sub	r12,r7,-16
80005f78:	f0 1f 00 08 	mcall	80005f98 <xQueueReceiveFromISR+0x4c>
80005f7c:	c0 a0       	breq	80005f90 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80005f7e:	30 1c       	mov	r12,1
80005f80:	8d 0c       	st.w	r6[0x0],r12
80005f82:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80005f86:	2f f8       	sub	r8,-1
80005f88:	ef 48 00 44 	st.w	r7[68],r8
80005f8c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005f90:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005f94:	80 00       	ld.sh	r0,r0[0x0]
80005f96:	5f 1c       	srne	r12
80005f98:	80 00       	ld.sh	r0,r0[0x0]
80005f9a:	65 54       	ld.w	r4,r2[0x54]

80005f9c <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005f9c:	eb cd 40 c0 	pushm	r6-r7,lr
80005fa0:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005fa2:	f0 1f 00 23 	mcall	8000602c <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005fa6:	6f 28       	ld.w	r8,r7[0x48]
80005fa8:	58 08       	cp.w	r8,0
80005faa:	e0 8a 00 18 	brle	80005fda <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005fae:	6e 98       	ld.w	r8,r7[0x24]
80005fb0:	58 08       	cp.w	r8,0
80005fb2:	c1 40       	breq	80005fda <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005fb4:	ee c6 ff dc 	sub	r6,r7,-36
80005fb8:	c0 48       	rjmp	80005fc0 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005fba:	6e 98       	ld.w	r8,r7[0x24]
80005fbc:	58 08       	cp.w	r8,0
80005fbe:	c0 e0       	breq	80005fda <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005fc0:	0c 9c       	mov	r12,r6
80005fc2:	f0 1f 00 1c 	mcall	80006030 <prvUnlockQueue+0x94>
80005fc6:	c0 30       	breq	80005fcc <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005fc8:	f0 1f 00 1b 	mcall	80006034 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005fcc:	6f 28       	ld.w	r8,r7[0x48]
80005fce:	20 18       	sub	r8,1
80005fd0:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005fd4:	58 08       	cp.w	r8,0
80005fd6:	fe 99 ff f2 	brgt	80005fba <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005fda:	3f f8       	mov	r8,-1
80005fdc:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005fe0:	f0 1f 00 16 	mcall	80006038 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005fe4:	f0 1f 00 12 	mcall	8000602c <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005fe8:	6f 18       	ld.w	r8,r7[0x44]
80005fea:	58 08       	cp.w	r8,0
80005fec:	e0 8a 00 18 	brle	8000601c <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005ff0:	6e 48       	ld.w	r8,r7[0x10]
80005ff2:	58 08       	cp.w	r8,0
80005ff4:	c1 40       	breq	8000601c <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005ff6:	ee c6 ff f0 	sub	r6,r7,-16
80005ffa:	c0 48       	rjmp	80006002 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005ffc:	6e 48       	ld.w	r8,r7[0x10]
80005ffe:	58 08       	cp.w	r8,0
80006000:	c0 e0       	breq	8000601c <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006002:	0c 9c       	mov	r12,r6
80006004:	f0 1f 00 0b 	mcall	80006030 <prvUnlockQueue+0x94>
80006008:	c0 30       	breq	8000600e <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
8000600a:	f0 1f 00 0b 	mcall	80006034 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
8000600e:	6f 18       	ld.w	r8,r7[0x44]
80006010:	20 18       	sub	r8,1
80006012:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80006016:	58 08       	cp.w	r8,0
80006018:	fe 99 ff f2 	brgt	80005ffc <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
8000601c:	3f f8       	mov	r8,-1
8000601e:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80006022:	f0 1f 00 06 	mcall	80006038 <prvUnlockQueue+0x9c>
}
80006026:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000602a:	00 00       	add	r0,r0
8000602c:	80 00       	ld.sh	r0,r0[0x0]
8000602e:	5c 88       	casts.h	r8
80006030:	80 00       	ld.sh	r0,r0[0x0]
80006032:	65 54       	ld.w	r4,r2[0x54]
80006034:	80 00       	ld.sh	r0,r0[0x0]
80006036:	64 60       	ld.w	r0,r2[0x18]
80006038:	80 00       	ld.sh	r0,r0[0x0]
8000603a:	5d 94       	*unknown*

8000603c <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
8000603c:	d4 31       	pushm	r0-r7,lr
8000603e:	20 5d       	sub	sp,20
80006040:	18 97       	mov	r7,r12
80006042:	50 0b       	stdsp	sp[0x0],r11
80006044:	50 2a       	stdsp	sp[0x8],r10
80006046:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006048:	f8 c2 ff dc 	sub	r2,r12,-36
8000604c:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000604e:	fa c4 ff f4 	sub	r4,sp,-12
80006052:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80006054:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006056:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
8000605a:	f0 1f 00 3e 	mcall	80006150 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
8000605e:	6e e8       	ld.w	r8,r7[0x38]
80006060:	58 08       	cp.w	r8,0
80006062:	c2 a0       	breq	800060b6 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80006064:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80006066:	40 0b       	lddsp	r11,sp[0x0]
80006068:	0e 9c       	mov	r12,r7
8000606a:	f0 1f 00 3b 	mcall	80006154 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
8000606e:	40 18       	lddsp	r8,sp[0x4]
80006070:	58 08       	cp.w	r8,0
80006072:	c1 51       	brne	8000609c <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80006074:	6e e8       	ld.w	r8,r7[0x38]
80006076:	20 18       	sub	r8,1
80006078:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000607a:	6e 08       	ld.w	r8,r7[0x0]
8000607c:	58 08       	cp.w	r8,0
8000607e:	c0 41       	brne	80006086 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80006080:	f0 1f 00 36 	mcall	80006158 <xQueueGenericReceive+0x11c>
80006084:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006086:	6e 48       	ld.w	r8,r7[0x10]
80006088:	58 08       	cp.w	r8,0
8000608a:	c1 20       	breq	800060ae <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
8000608c:	ee cc ff f0 	sub	r12,r7,-16
80006090:	f0 1f 00 33 	mcall	8000615c <xQueueGenericReceive+0x120>
80006094:	58 1c       	cp.w	r12,1
80006096:	c0 c1       	brne	800060ae <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80006098:	d7 33       	scall
8000609a:	c0 a8       	rjmp	800060ae <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
8000609c:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000609e:	6e 98       	ld.w	r8,r7[0x24]
800060a0:	58 08       	cp.w	r8,0
800060a2:	c0 60       	breq	800060ae <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800060a4:	04 9c       	mov	r12,r2
800060a6:	f0 1f 00 2e 	mcall	8000615c <xQueueGenericReceive+0x120>
800060aa:	c0 20       	breq	800060ae <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
800060ac:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
800060ae:	f0 1f 00 2d 	mcall	80006160 <xQueueGenericReceive+0x124>
800060b2:	30 1c       	mov	r12,1
				return pdPASS;
800060b4:	c4 c8       	rjmp	8000614c <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800060b6:	40 28       	lddsp	r8,sp[0x8]
800060b8:	58 08       	cp.w	r8,0
800060ba:	c0 51       	brne	800060c4 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800060bc:	f0 1f 00 29 	mcall	80006160 <xQueueGenericReceive+0x124>
800060c0:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
800060c2:	c4 58       	rjmp	8000614c <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
800060c4:	58 05       	cp.w	r5,0
800060c6:	c0 51       	brne	800060d0 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800060c8:	08 9c       	mov	r12,r4
800060ca:	f0 1f 00 27 	mcall	80006164 <xQueueGenericReceive+0x128>
800060ce:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800060d0:	f0 1f 00 24 	mcall	80006160 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800060d4:	f0 1f 00 25 	mcall	80006168 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
800060d8:	f0 1f 00 1e 	mcall	80006150 <xQueueGenericReceive+0x114>
800060dc:	6f 18       	ld.w	r8,r7[0x44]
800060de:	5b f8       	cp.w	r8,-1
800060e0:	ef f1 0a 11 	st.weq	r7[0x44],r1
800060e4:	6f 28       	ld.w	r8,r7[0x48]
800060e6:	5b f8       	cp.w	r8,-1
800060e8:	ef f1 0a 12 	st.weq	r7[0x48],r1
800060ec:	f0 1f 00 1d 	mcall	80006160 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800060f0:	06 9b       	mov	r11,r3
800060f2:	08 9c       	mov	r12,r4
800060f4:	f0 1f 00 1e 	mcall	8000616c <xQueueGenericReceive+0x130>
800060f8:	c2 41       	brne	80006140 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800060fa:	f0 1f 00 16 	mcall	80006150 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
800060fe:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80006100:	f0 1f 00 18 	mcall	80006160 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80006104:	58 06       	cp.w	r6,0
80006106:	c1 71       	brne	80006134 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006108:	6e 08       	ld.w	r8,r7[0x0]
8000610a:	58 08       	cp.w	r8,0
8000610c:	c0 81       	brne	8000611c <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
8000610e:	f0 1f 00 11 	mcall	80006150 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80006112:	6e 1c       	ld.w	r12,r7[0x4]
80006114:	f0 1f 00 17 	mcall	80006170 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80006118:	f0 1f 00 12 	mcall	80006160 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
8000611c:	40 2b       	lddsp	r11,sp[0x8]
8000611e:	04 9c       	mov	r12,r2
80006120:	f0 1f 00 15 	mcall	80006174 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80006124:	0e 9c       	mov	r12,r7
80006126:	f0 1f 00 15 	mcall	80006178 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
8000612a:	f0 1f 00 15 	mcall	8000617c <xQueueGenericReceive+0x140>
8000612e:	c9 61       	brne	8000605a <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80006130:	d7 33       	scall
80006132:	c9 4b       	rjmp	8000605a <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006134:	0e 9c       	mov	r12,r7
80006136:	f0 1f 00 11 	mcall	80006178 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
8000613a:	f0 1f 00 11 	mcall	8000617c <xQueueGenericReceive+0x140>
8000613e:	c8 eb       	rjmp	8000605a <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80006140:	0e 9c       	mov	r12,r7
80006142:	f0 1f 00 0e 	mcall	80006178 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80006146:	f0 1f 00 0e 	mcall	8000617c <xQueueGenericReceive+0x140>
8000614a:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
8000614c:	2f bd       	sub	sp,-20
8000614e:	d8 32       	popm	r0-r7,pc
80006150:	80 00       	ld.sh	r0,r0[0x0]
80006152:	5c 88       	casts.h	r8
80006154:	80 00       	ld.sh	r0,r0[0x0]
80006156:	5f 1c       	srne	r12
80006158:	80 00       	ld.sh	r0,r0[0x0]
8000615a:	64 6c       	ld.w	r12,r2[0x18]
8000615c:	80 00       	ld.sh	r0,r0[0x0]
8000615e:	65 54       	ld.w	r4,r2[0x54]
80006160:	80 00       	ld.sh	r0,r0[0x0]
80006162:	5d 94       	*unknown*
80006164:	80 00       	ld.sh	r0,r0[0x0]
80006166:	64 48       	ld.w	r8,r2[0x10]
80006168:	80 00       	ld.sh	r0,r0[0x0]
8000616a:	63 bc       	ld.w	r12,r1[0x6c]
8000616c:	80 00       	ld.sh	r0,r0[0x0]
8000616e:	66 e4       	ld.w	r4,r3[0x38]
80006170:	80 00       	ld.sh	r0,r0[0x0]
80006172:	64 d0       	ld.w	r0,r2[0x34]
80006174:	80 00       	ld.sh	r0,r0[0x0]
80006176:	69 84       	ld.w	r4,r4[0x60]
80006178:	80 00       	ld.sh	r0,r0[0x0]
8000617a:	5f 9c       	srgt	r12
8000617c:	80 00       	ld.sh	r0,r0[0x0]
8000617e:	67 78       	ld.w	r8,r3[0x5c]

80006180 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80006180:	eb cd 40 80 	pushm	r7,lr
80006184:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80006186:	79 08       	ld.w	r8,r12[0x40]
80006188:	58 08       	cp.w	r8,0
8000618a:	c0 a1       	brne	8000619e <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000618c:	78 08       	ld.w	r8,r12[0x0]
8000618e:	58 08       	cp.w	r8,0
80006190:	c2 b1       	brne	800061e6 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80006192:	78 1c       	ld.w	r12,r12[0x4]
80006194:	f0 1f 00 17 	mcall	800061f0 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80006198:	30 08       	mov	r8,0
8000619a:	8f 18       	st.w	r7[0x4],r8
8000619c:	c2 58       	rjmp	800061e6 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
8000619e:	58 0a       	cp.w	r10,0
800061a0:	c1 01       	brne	800061c0 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800061a2:	10 9a       	mov	r10,r8
800061a4:	78 2c       	ld.w	r12,r12[0x8]
800061a6:	f0 1f 00 14 	mcall	800061f4 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
800061aa:	6e 29       	ld.w	r9,r7[0x8]
800061ac:	6f 08       	ld.w	r8,r7[0x40]
800061ae:	f2 08 00 08 	add	r8,r9,r8
800061b2:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
800061b4:	6e 19       	ld.w	r9,r7[0x4]
800061b6:	12 38       	cp.w	r8,r9
800061b8:	c1 73       	brcs	800061e6 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
800061ba:	6e 08       	ld.w	r8,r7[0x0]
800061bc:	8f 28       	st.w	r7[0x8],r8
800061be:	c1 48       	rjmp	800061e6 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800061c0:	10 9a       	mov	r10,r8
800061c2:	78 3c       	ld.w	r12,r12[0xc]
800061c4:	f0 1f 00 0c 	mcall	800061f4 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
800061c8:	6f 08       	ld.w	r8,r7[0x40]
800061ca:	6e 39       	ld.w	r9,r7[0xc]
800061cc:	f2 08 01 08 	sub	r8,r9,r8
800061d0:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800061d2:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800061d4:	12 38       	cp.w	r8,r9
800061d6:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
800061da:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
800061de:	f3 d8 e3 19 	subcs	r9,r9,r8
800061e2:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800061e6:	6e e8       	ld.w	r8,r7[0x38]
800061e8:	2f f8       	sub	r8,-1
800061ea:	8f e8       	st.w	r7[0x38],r8
}
800061ec:	e3 cd 80 80 	ldm	sp++,r7,pc
800061f0:	80 00       	ld.sh	r0,r0[0x0]
800061f2:	64 78       	ld.w	r8,r2[0x1c]
800061f4:	80 00       	ld.sh	r0,r0[0x0]
800061f6:	76 a4       	ld.w	r4,r11[0x28]

800061f8 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
800061f8:	eb cd 40 c0 	pushm	r6-r7,lr
800061fc:	18 97       	mov	r7,r12
800061fe:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006200:	78 ec       	ld.w	r12,r12[0x38]
80006202:	6e f8       	ld.w	r8,r7[0x3c]
80006204:	10 3c       	cp.w	r12,r8
80006206:	c0 33       	brcs	8000620c <xQueueGenericSendFromISR+0x14>
80006208:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
8000620c:	12 9a       	mov	r10,r9
8000620e:	0e 9c       	mov	r12,r7
80006210:	f0 1f 00 0c 	mcall	80006240 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80006214:	6f 28       	ld.w	r8,r7[0x48]
80006216:	5b f8       	cp.w	r8,-1
80006218:	c0 d1       	brne	80006232 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000621a:	6e 98       	ld.w	r8,r7[0x24]
8000621c:	58 08       	cp.w	r8,0
8000621e:	c0 f0       	breq	8000623c <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006220:	ee cc ff dc 	sub	r12,r7,-36
80006224:	f0 1f 00 08 	mcall	80006244 <xQueueGenericSendFromISR+0x4c>
80006228:	c0 a0       	breq	8000623c <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
8000622a:	30 1c       	mov	r12,1
8000622c:	8d 0c       	st.w	r6[0x0],r12
8000622e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80006232:	2f f8       	sub	r8,-1
80006234:	ef 48 00 48 	st.w	r7[72],r8
80006238:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000623c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006240:	80 00       	ld.sh	r0,r0[0x0]
80006242:	61 80       	ld.w	r0,r0[0x60]
80006244:	80 00       	ld.sh	r0,r0[0x0]
80006246:	65 54       	ld.w	r4,r2[0x54]

80006248 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80006248:	d4 31       	pushm	r0-r7,lr
8000624a:	20 5d       	sub	sp,20
8000624c:	18 97       	mov	r7,r12
8000624e:	50 0b       	stdsp	sp[0x0],r11
80006250:	50 2a       	stdsp	sp[0x8],r10
80006252:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80006254:	f8 c0 ff f0 	sub	r0,r12,-16
80006258:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000625a:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
8000625e:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006260:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80006264:	f0 1f 00 2f 	mcall	80006320 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006268:	6e e9       	ld.w	r9,r7[0x38]
8000626a:	6e f8       	ld.w	r8,r7[0x3c]
8000626c:	10 39       	cp.w	r9,r8
8000626e:	c1 42       	brcc	80006296 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006270:	40 1a       	lddsp	r10,sp[0x4]
80006272:	40 0b       	lddsp	r11,sp[0x0]
80006274:	0e 9c       	mov	r12,r7
80006276:	f0 1f 00 2c 	mcall	80006324 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000627a:	6e 98       	ld.w	r8,r7[0x24]
8000627c:	58 08       	cp.w	r8,0
8000627e:	c0 80       	breq	8000628e <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80006280:	ee cc ff dc 	sub	r12,r7,-36
80006284:	f0 1f 00 29 	mcall	80006328 <xQueueGenericSend+0xe0>
80006288:	58 1c       	cp.w	r12,1
8000628a:	c0 21       	brne	8000628e <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
8000628c:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
8000628e:	f0 1f 00 28 	mcall	8000632c <xQueueGenericSend+0xe4>
80006292:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80006294:	c4 38       	rjmp	8000631a <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80006296:	40 28       	lddsp	r8,sp[0x8]
80006298:	58 08       	cp.w	r8,0
8000629a:	c0 51       	brne	800062a4 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8000629c:	f0 1f 00 24 	mcall	8000632c <xQueueGenericSend+0xe4>
800062a0:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800062a2:	c3 c8       	rjmp	8000631a <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
800062a4:	58 04       	cp.w	r4,0
800062a6:	c0 51       	brne	800062b0 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800062a8:	06 9c       	mov	r12,r3
800062aa:	f0 1f 00 22 	mcall	80006330 <xQueueGenericSend+0xe8>
800062ae:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800062b0:	f0 1f 00 1f 	mcall	8000632c <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800062b4:	f0 1f 00 20 	mcall	80006334 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
800062b8:	f0 1f 00 1a 	mcall	80006320 <xQueueGenericSend+0xd8>
800062bc:	6f 18       	ld.w	r8,r7[0x44]
800062be:	5b f8       	cp.w	r8,-1
800062c0:	ef f1 0a 11 	st.weq	r7[0x44],r1
800062c4:	6f 28       	ld.w	r8,r7[0x48]
800062c6:	5b f8       	cp.w	r8,-1
800062c8:	ef f1 0a 12 	st.weq	r7[0x48],r1
800062cc:	f0 1f 00 18 	mcall	8000632c <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800062d0:	04 9b       	mov	r11,r2
800062d2:	06 9c       	mov	r12,r3
800062d4:	f0 1f 00 19 	mcall	80006338 <xQueueGenericSend+0xf0>
800062d8:	c1 b1       	brne	8000630e <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800062da:	f0 1f 00 12 	mcall	80006320 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800062de:	6e e5       	ld.w	r5,r7[0x38]
800062e0:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800062e2:	f0 1f 00 13 	mcall	8000632c <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800062e6:	0c 35       	cp.w	r5,r6
800062e8:	c0 d1       	brne	80006302 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800062ea:	40 2b       	lddsp	r11,sp[0x8]
800062ec:	00 9c       	mov	r12,r0
800062ee:	f0 1f 00 14 	mcall	8000633c <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800062f2:	0e 9c       	mov	r12,r7
800062f4:	f0 1f 00 13 	mcall	80006340 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800062f8:	f0 1f 00 13 	mcall	80006344 <xQueueGenericSend+0xfc>
800062fc:	cb 41       	brne	80006264 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
800062fe:	d7 33       	scall
80006300:	cb 2b       	rjmp	80006264 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006302:	0e 9c       	mov	r12,r7
80006304:	f0 1f 00 0f 	mcall	80006340 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80006308:	f0 1f 00 0f 	mcall	80006344 <xQueueGenericSend+0xfc>
8000630c:	ca cb       	rjmp	80006264 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
8000630e:	0e 9c       	mov	r12,r7
80006310:	f0 1f 00 0c 	mcall	80006340 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80006314:	f0 1f 00 0c 	mcall	80006344 <xQueueGenericSend+0xfc>
80006318:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
8000631a:	2f bd       	sub	sp,-20
8000631c:	d8 32       	popm	r0-r7,pc
8000631e:	00 00       	add	r0,r0
80006320:	80 00       	ld.sh	r0,r0[0x0]
80006322:	5c 88       	casts.h	r8
80006324:	80 00       	ld.sh	r0,r0[0x0]
80006326:	61 80       	ld.w	r0,r0[0x60]
80006328:	80 00       	ld.sh	r0,r0[0x0]
8000632a:	65 54       	ld.w	r4,r2[0x54]
8000632c:	80 00       	ld.sh	r0,r0[0x0]
8000632e:	5d 94       	*unknown*
80006330:	80 00       	ld.sh	r0,r0[0x0]
80006332:	64 48       	ld.w	r8,r2[0x10]
80006334:	80 00       	ld.sh	r0,r0[0x0]
80006336:	63 bc       	ld.w	r12,r1[0x6c]
80006338:	80 00       	ld.sh	r0,r0[0x0]
8000633a:	66 e4       	ld.w	r4,r3[0x38]
8000633c:	80 00       	ld.sh	r0,r0[0x0]
8000633e:	69 84       	ld.w	r4,r4[0x60]
80006340:	80 00       	ld.sh	r0,r0[0x0]
80006342:	5f 9c       	srgt	r12
80006344:	80 00       	ld.sh	r0,r0[0x0]
80006346:	67 78       	ld.w	r8,r3[0x5c]

80006348 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80006348:	d4 21       	pushm	r4-r7,lr
8000634a:	18 97       	mov	r7,r12
8000634c:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
8000634e:	58 0c       	cp.w	r12,0
80006350:	c2 f0       	breq	800063ae <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80006352:	34 cc       	mov	r12,76
80006354:	f0 1f 00 17 	mcall	800063b0 <xQueueCreate+0x68>
80006358:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000635a:	c2 a0       	breq	800063ae <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
8000635c:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80006360:	e8 cc ff ff 	sub	r12,r4,-1
80006364:	f0 1f 00 13 	mcall	800063b0 <xQueueCreate+0x68>
80006368:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000636a:	c1 e0       	breq	800063a6 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
8000636c:	f8 04 00 04 	add	r4,r12,r4
80006370:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80006372:	30 08       	mov	r8,0
80006374:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80006376:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80006378:	ee c8 00 01 	sub	r8,r7,1
8000637c:	ad 38       	mul	r8,r6
8000637e:	10 0c       	add	r12,r8
80006380:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80006382:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80006384:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80006388:	3f f8       	mov	r8,-1
8000638a:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
8000638e:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80006392:	ea cc ff f0 	sub	r12,r5,-16
80006396:	f0 1f 00 08 	mcall	800063b4 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000639a:	ea cc ff dc 	sub	r12,r5,-36
8000639e:	f0 1f 00 06 	mcall	800063b4 <xQueueCreate+0x6c>
800063a2:	0a 9c       	mov	r12,r5
800063a4:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800063a6:	0a 9c       	mov	r12,r5
800063a8:	f0 1f 00 04 	mcall	800063b8 <xQueueCreate+0x70>
800063ac:	d8 2a       	popm	r4-r7,pc,r12=0
800063ae:	d8 2a       	popm	r4-r7,pc,r12=0
800063b0:	80 00       	ld.sh	r0,r0[0x0]
800063b2:	5e f4       	retal	r4
800063b4:	80 00       	ld.sh	r0,r0[0x0]
800063b6:	5b 64       	cp.w	r4,-10
800063b8:	80 00       	ld.sh	r0,r0[0x0]
800063ba:	5e cc       	retvs	r12

800063bc <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800063bc:	48 38       	lddpc	r8,800063c8 <vTaskSuspendAll+0xc>
800063be:	70 09       	ld.w	r9,r8[0x0]
800063c0:	2f f9       	sub	r9,-1
800063c2:	91 09       	st.w	r8[0x0],r9
}
800063c4:	5e fc       	retal	r12
800063c6:	00 00       	add	r0,r0
800063c8:	00 00       	add	r0,r0
800063ca:	0d 20       	ld.uh	r0,r6++

800063cc <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800063cc:	49 a8       	lddpc	r8,80006434 <vTaskSwitchContext+0x68>
800063ce:	70 08       	ld.w	r8,r8[0x0]
800063d0:	58 08       	cp.w	r8,0
800063d2:	c0 b1       	brne	800063e8 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800063d4:	49 98       	lddpc	r8,80006438 <vTaskSwitchContext+0x6c>
800063d6:	70 08       	ld.w	r8,r8[0x0]
800063d8:	f0 08 00 28 	add	r8,r8,r8<<0x2
800063dc:	49 89       	lddpc	r9,8000643c <vTaskSwitchContext+0x70>
800063de:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800063e2:	58 08       	cp.w	r8,0
800063e4:	c0 60       	breq	800063f0 <vTaskSwitchContext+0x24>
800063e6:	c1 18       	rjmp	80006408 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800063e8:	30 19       	mov	r9,1
800063ea:	49 68       	lddpc	r8,80006440 <vTaskSwitchContext+0x74>
800063ec:	91 09       	st.w	r8[0x0],r9
800063ee:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800063f0:	49 28       	lddpc	r8,80006438 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800063f2:	49 3a       	lddpc	r10,8000643c <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800063f4:	70 09       	ld.w	r9,r8[0x0]
800063f6:	20 19       	sub	r9,1
800063f8:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800063fa:	70 09       	ld.w	r9,r8[0x0]
800063fc:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006400:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80006404:	58 09       	cp.w	r9,0
80006406:	cf 70       	breq	800063f4 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80006408:	48 c8       	lddpc	r8,80006438 <vTaskSwitchContext+0x6c>
8000640a:	70 08       	ld.w	r8,r8[0x0]
8000640c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006410:	48 b9       	lddpc	r9,8000643c <vTaskSwitchContext+0x70>
80006412:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006416:	70 19       	ld.w	r9,r8[0x4]
80006418:	72 19       	ld.w	r9,r9[0x4]
8000641a:	91 19       	st.w	r8[0x4],r9
8000641c:	f0 ca ff f8 	sub	r10,r8,-8
80006420:	14 39       	cp.w	r9,r10
80006422:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80006426:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000642a:	70 18       	ld.w	r8,r8[0x4]
8000642c:	70 39       	ld.w	r9,r8[0xc]
8000642e:	48 68       	lddpc	r8,80006444 <vTaskSwitchContext+0x78>
80006430:	91 09       	st.w	r8[0x0],r9
80006432:	5e fc       	retal	r12
80006434:	00 00       	add	r0,r0
80006436:	0d 20       	ld.uh	r0,r6++
80006438:	00 00       	add	r0,r0
8000643a:	0d 58       	ld.sh	r8,--r6
8000643c:	00 00       	add	r0,r0
8000643e:	0c 3c       	cp.w	r12,r6
80006440:	00 00       	add	r0,r0
80006442:	0d 40       	ld.w	r0,--r6
80006444:	00 00       	add	r0,r0
80006446:	0c f0       	st.b	--r6,r0

80006448 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80006448:	48 48       	lddpc	r8,80006458 <vTaskSetTimeOutState+0x10>
8000644a:	70 08       	ld.w	r8,r8[0x0]
8000644c:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
8000644e:	48 48       	lddpc	r8,8000645c <vTaskSetTimeOutState+0x14>
80006450:	70 08       	ld.w	r8,r8[0x0]
80006452:	99 18       	st.w	r12[0x4],r8
}
80006454:	5e fc       	retal	r12
80006456:	00 00       	add	r0,r0
80006458:	00 00       	add	r0,r0
8000645a:	0c 34       	cp.w	r4,r6
8000645c:	00 00       	add	r0,r0
8000645e:	0d 1c       	ld.sh	r12,r6++

80006460 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80006460:	30 19       	mov	r9,1
80006462:	48 28       	lddpc	r8,80006468 <vTaskMissedYield+0x8>
80006464:	91 09       	st.w	r8[0x0],r9
}
80006466:	5e fc       	retal	r12
80006468:	00 00       	add	r0,r0
8000646a:	0d 40       	ld.w	r0,--r6

8000646c <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
8000646c:	48 28       	lddpc	r8,80006474 <xTaskGetCurrentTaskHandle+0x8>
8000646e:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006470:	5e fc       	retal	r12
80006472:	00 00       	add	r0,r0
80006474:	00 00       	add	r0,r0
80006476:	0c f0       	st.b	--r6,r0

80006478 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80006478:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
8000647c:	58 0c       	cp.w	r12,0
8000647e:	c1 f0       	breq	800064bc <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80006480:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80006482:	78 b9       	ld.w	r9,r12[0x2c]
80006484:	79 18       	ld.w	r8,r12[0x44]
80006486:	10 39       	cp.w	r9,r8
80006488:	c1 a0       	breq	800064bc <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000648a:	f8 c6 ff fc 	sub	r6,r12,-4
8000648e:	0c 9c       	mov	r12,r6
80006490:	f0 1f 00 0c 	mcall	800064c0 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80006494:	6f 1c       	ld.w	r12,r7[0x44]
80006496:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80006498:	f8 08 11 08 	rsub	r8,r12,8
8000649c:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
8000649e:	48 a8       	lddpc	r8,800064c4 <vTaskPriorityDisinherit+0x4c>
800064a0:	70 08       	ld.w	r8,r8[0x0]
800064a2:	10 3c       	cp.w	r12,r8
800064a4:	e0 88 00 04 	brls	800064ac <vTaskPriorityDisinherit+0x34>
800064a8:	48 78       	lddpc	r8,800064c4 <vTaskPriorityDisinherit+0x4c>
800064aa:	91 0c       	st.w	r8[0x0],r12
800064ac:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800064b0:	0c 9b       	mov	r11,r6
800064b2:	48 68       	lddpc	r8,800064c8 <vTaskPriorityDisinherit+0x50>
800064b4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800064b8:	f0 1f 00 05 	mcall	800064cc <vTaskPriorityDisinherit+0x54>
800064bc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800064c0:	80 00       	ld.sh	r0,r0[0x0]
800064c2:	5b ce       	cp.w	lr,-4
800064c4:	00 00       	add	r0,r0
800064c6:	0d 58       	ld.sh	r8,--r6
800064c8:	00 00       	add	r0,r0
800064ca:	0c 3c       	cp.w	r12,r6
800064cc:	80 00       	ld.sh	r0,r0[0x0]
800064ce:	5b 7e       	cp.w	lr,-9

800064d0 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800064d0:	eb cd 40 c0 	pushm	r6-r7,lr
800064d4:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
800064d6:	49 b8       	lddpc	r8,80006540 <vTaskPriorityInherit+0x70>
800064d8:	70 08       	ld.w	r8,r8[0x0]
800064da:	78 b9       	ld.w	r9,r12[0x2c]
800064dc:	70 b8       	ld.w	r8,r8[0x2c]
800064de:	10 39       	cp.w	r9,r8
800064e0:	c2 d2       	brcc	8000653a <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800064e2:	49 88       	lddpc	r8,80006540 <vTaskPriorityInherit+0x70>
800064e4:	70 08       	ld.w	r8,r8[0x0]
800064e6:	70 b8       	ld.w	r8,r8[0x2c]
800064e8:	f0 08 11 08 	rsub	r8,r8,8
800064ec:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800064ee:	f2 09 00 28 	add	r8,r9,r9<<0x2
800064f2:	49 59       	lddpc	r9,80006544 <vTaskPriorityInherit+0x74>
800064f4:	f2 08 00 28 	add	r8,r9,r8<<0x2
800064f8:	78 59       	ld.w	r9,r12[0x14]
800064fa:	10 39       	cp.w	r9,r8
800064fc:	c1 b1       	brne	80006532 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800064fe:	f8 c6 ff fc 	sub	r6,r12,-4
80006502:	0c 9c       	mov	r12,r6
80006504:	f0 1f 00 11 	mcall	80006548 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006508:	48 e8       	lddpc	r8,80006540 <vTaskPriorityInherit+0x70>
8000650a:	70 08       	ld.w	r8,r8[0x0]
8000650c:	70 bc       	ld.w	r12,r8[0x2c]
8000650e:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80006510:	48 f8       	lddpc	r8,8000654c <vTaskPriorityInherit+0x7c>
80006512:	70 08       	ld.w	r8,r8[0x0]
80006514:	10 3c       	cp.w	r12,r8
80006516:	e0 88 00 04 	brls	8000651e <vTaskPriorityInherit+0x4e>
8000651a:	48 d8       	lddpc	r8,8000654c <vTaskPriorityInherit+0x7c>
8000651c:	91 0c       	st.w	r8[0x0],r12
8000651e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006522:	0c 9b       	mov	r11,r6
80006524:	48 88       	lddpc	r8,80006544 <vTaskPriorityInherit+0x74>
80006526:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000652a:	f0 1f 00 0a 	mcall	80006550 <vTaskPriorityInherit+0x80>
8000652e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006532:	48 48       	lddpc	r8,80006540 <vTaskPriorityInherit+0x70>
80006534:	70 08       	ld.w	r8,r8[0x0]
80006536:	70 b8       	ld.w	r8,r8[0x2c]
80006538:	99 b8       	st.w	r12[0x2c],r8
8000653a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000653e:	00 00       	add	r0,r0
80006540:	00 00       	add	r0,r0
80006542:	0c f0       	st.b	--r6,r0
80006544:	00 00       	add	r0,r0
80006546:	0c 3c       	cp.w	r12,r6
80006548:	80 00       	ld.sh	r0,r0[0x0]
8000654a:	5b ce       	cp.w	lr,-4
8000654c:	00 00       	add	r0,r0
8000654e:	0d 58       	ld.sh	r8,--r6
80006550:	80 00       	ld.sh	r0,r0[0x0]
80006552:	5b 7e       	cp.w	lr,-9

80006554 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80006554:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80006558:	78 38       	ld.w	r8,r12[0xc]
8000655a:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
8000655c:	ee c6 ff e8 	sub	r6,r7,-24
80006560:	0c 9c       	mov	r12,r6
80006562:	f0 1f 00 15 	mcall	800065b4 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006566:	49 58       	lddpc	r8,800065b8 <xTaskRemoveFromEventList+0x64>
80006568:	70 08       	ld.w	r8,r8[0x0]
8000656a:	58 08       	cp.w	r8,0
8000656c:	c1 71       	brne	8000659a <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
8000656e:	ee c6 ff fc 	sub	r6,r7,-4
80006572:	0c 9c       	mov	r12,r6
80006574:	f0 1f 00 10 	mcall	800065b4 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80006578:	6e bc       	ld.w	r12,r7[0x2c]
8000657a:	49 18       	lddpc	r8,800065bc <xTaskRemoveFromEventList+0x68>
8000657c:	70 08       	ld.w	r8,r8[0x0]
8000657e:	10 3c       	cp.w	r12,r8
80006580:	e0 88 00 04 	brls	80006588 <xTaskRemoveFromEventList+0x34>
80006584:	48 e8       	lddpc	r8,800065bc <xTaskRemoveFromEventList+0x68>
80006586:	91 0c       	st.w	r8[0x0],r12
80006588:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000658c:	0c 9b       	mov	r11,r6
8000658e:	48 d8       	lddpc	r8,800065c0 <xTaskRemoveFromEventList+0x6c>
80006590:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006594:	f0 1f 00 0c 	mcall	800065c4 <xTaskRemoveFromEventList+0x70>
80006598:	c0 58       	rjmp	800065a2 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000659a:	0c 9b       	mov	r11,r6
8000659c:	48 bc       	lddpc	r12,800065c8 <xTaskRemoveFromEventList+0x74>
8000659e:	f0 1f 00 0a 	mcall	800065c4 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800065a2:	48 b8       	lddpc	r8,800065cc <xTaskRemoveFromEventList+0x78>
800065a4:	70 08       	ld.w	r8,r8[0x0]
800065a6:	6e b9       	ld.w	r9,r7[0x2c]
800065a8:	70 b8       	ld.w	r8,r8[0x2c]
800065aa:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
800065ac:	5f 2c       	srhs	r12
800065ae:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800065b2:	00 00       	add	r0,r0
800065b4:	80 00       	ld.sh	r0,r0[0x0]
800065b6:	5b ce       	cp.w	lr,-4
800065b8:	00 00       	add	r0,r0
800065ba:	0d 20       	ld.uh	r0,r6++
800065bc:	00 00       	add	r0,r0
800065be:	0d 58       	ld.sh	r8,--r6
800065c0:	00 00       	add	r0,r0
800065c2:	0c 3c       	cp.w	r12,r6
800065c4:	80 00       	ld.sh	r0,r0[0x0]
800065c6:	5b 7e       	cp.w	lr,-9
800065c8:	00 00       	add	r0,r0
800065ca:	0c f4       	st.b	--r6,r4
800065cc:	00 00       	add	r0,r0
800065ce:	0c f0       	st.b	--r6,r0

800065d0 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800065d0:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800065d4:	4b 98       	lddpc	r8,800066b8 <vTaskIncrementTick+0xe8>
800065d6:	70 08       	ld.w	r8,r8[0x0]
800065d8:	58 08       	cp.w	r8,0
800065da:	c6 91       	brne	800066ac <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800065dc:	4b 88       	lddpc	r8,800066bc <vTaskIncrementTick+0xec>
800065de:	70 09       	ld.w	r9,r8[0x0]
800065e0:	2f f9       	sub	r9,-1
800065e2:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800065e4:	70 08       	ld.w	r8,r8[0x0]
800065e6:	58 08       	cp.w	r8,0
800065e8:	c1 a1       	brne	8000661c <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800065ea:	4b 68       	lddpc	r8,800066c0 <vTaskIncrementTick+0xf0>
800065ec:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800065ee:	4b 69       	lddpc	r9,800066c4 <vTaskIncrementTick+0xf4>
800065f0:	72 0b       	ld.w	r11,r9[0x0]
800065f2:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800065f4:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800065f6:	4b 59       	lddpc	r9,800066c8 <vTaskIncrementTick+0xf8>
800065f8:	72 0a       	ld.w	r10,r9[0x0]
800065fa:	2f fa       	sub	r10,-1
800065fc:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800065fe:	70 08       	ld.w	r8,r8[0x0]
80006600:	70 08       	ld.w	r8,r8[0x0]
80006602:	58 08       	cp.w	r8,0
80006604:	c0 51       	brne	8000660e <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80006606:	3f f9       	mov	r9,-1
80006608:	4b 18       	lddpc	r8,800066cc <vTaskIncrementTick+0xfc>
8000660a:	91 09       	st.w	r8[0x0],r9
8000660c:	c0 88       	rjmp	8000661c <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
8000660e:	4a d8       	lddpc	r8,800066c0 <vTaskIncrementTick+0xf0>
80006610:	70 08       	ld.w	r8,r8[0x0]
80006612:	70 38       	ld.w	r8,r8[0xc]
80006614:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80006616:	70 19       	ld.w	r9,r8[0x4]
80006618:	4a d8       	lddpc	r8,800066cc <vTaskIncrementTick+0xfc>
8000661a:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
8000661c:	4a 88       	lddpc	r8,800066bc <vTaskIncrementTick+0xec>
8000661e:	70 09       	ld.w	r9,r8[0x0]
80006620:	4a b8       	lddpc	r8,800066cc <vTaskIncrementTick+0xfc>
80006622:	70 08       	ld.w	r8,r8[0x0]
80006624:	10 39       	cp.w	r9,r8
80006626:	c4 73       	brcs	800066b4 <vTaskIncrementTick+0xe4>
80006628:	4a 68       	lddpc	r8,800066c0 <vTaskIncrementTick+0xf0>
8000662a:	70 08       	ld.w	r8,r8[0x0]
8000662c:	70 08       	ld.w	r8,r8[0x0]
8000662e:	58 08       	cp.w	r8,0
80006630:	c0 c0       	breq	80006648 <vTaskIncrementTick+0x78>
80006632:	4a 48       	lddpc	r8,800066c0 <vTaskIncrementTick+0xf0>
80006634:	70 08       	ld.w	r8,r8[0x0]
80006636:	70 38       	ld.w	r8,r8[0xc]
80006638:	70 37       	ld.w	r7,r8[0xc]
8000663a:	6e 18       	ld.w	r8,r7[0x4]
8000663c:	4a 09       	lddpc	r9,800066bc <vTaskIncrementTick+0xec>
8000663e:	72 09       	ld.w	r9,r9[0x0]
80006640:	12 38       	cp.w	r8,r9
80006642:	e0 88 00 14 	brls	8000666a <vTaskIncrementTick+0x9a>
80006646:	c0 e8       	rjmp	80006662 <vTaskIncrementTick+0x92>
80006648:	3f f9       	mov	r9,-1
8000664a:	4a 18       	lddpc	r8,800066cc <vTaskIncrementTick+0xfc>
8000664c:	91 09       	st.w	r8[0x0],r9
8000664e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006652:	6a 08       	ld.w	r8,r5[0x0]
80006654:	70 38       	ld.w	r8,r8[0xc]
80006656:	70 37       	ld.w	r7,r8[0xc]
80006658:	6e 18       	ld.w	r8,r7[0x4]
8000665a:	64 09       	ld.w	r9,r2[0x0]
8000665c:	12 38       	cp.w	r8,r9
8000665e:	e0 88 00 0a 	brls	80006672 <vTaskIncrementTick+0xa2>
80006662:	49 b9       	lddpc	r9,800066cc <vTaskIncrementTick+0xfc>
80006664:	93 08       	st.w	r9[0x0],r8
80006666:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000666a:	49 a4       	lddpc	r4,800066d0 <vTaskIncrementTick+0x100>
8000666c:	49 a3       	lddpc	r3,800066d4 <vTaskIncrementTick+0x104>
8000666e:	49 55       	lddpc	r5,800066c0 <vTaskIncrementTick+0xf0>
80006670:	49 32       	lddpc	r2,800066bc <vTaskIncrementTick+0xec>
80006672:	ee c6 ff fc 	sub	r6,r7,-4
80006676:	0c 9c       	mov	r12,r6
80006678:	f0 1f 00 18 	mcall	800066d8 <vTaskIncrementTick+0x108>
8000667c:	6e a8       	ld.w	r8,r7[0x28]
8000667e:	58 08       	cp.w	r8,0
80006680:	c0 50       	breq	8000668a <vTaskIncrementTick+0xba>
80006682:	ee cc ff e8 	sub	r12,r7,-24
80006686:	f0 1f 00 15 	mcall	800066d8 <vTaskIncrementTick+0x108>
8000668a:	6e bc       	ld.w	r12,r7[0x2c]
8000668c:	68 08       	ld.w	r8,r4[0x0]
8000668e:	10 3c       	cp.w	r12,r8
80006690:	e9 fc ba 00 	st.whi	r4[0x0],r12
80006694:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006698:	0c 9b       	mov	r11,r6
8000669a:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
8000669e:	f0 1f 00 10 	mcall	800066dc <vTaskIncrementTick+0x10c>
800066a2:	6a 08       	ld.w	r8,r5[0x0]
800066a4:	70 08       	ld.w	r8,r8[0x0]
800066a6:	58 08       	cp.w	r8,0
800066a8:	cd 51       	brne	80006652 <vTaskIncrementTick+0x82>
800066aa:	cc fb       	rjmp	80006648 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800066ac:	48 d8       	lddpc	r8,800066e0 <vTaskIncrementTick+0x110>
800066ae:	70 09       	ld.w	r9,r8[0x0]
800066b0:	2f f9       	sub	r9,-1
800066b2:	91 09       	st.w	r8[0x0],r9
800066b4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800066b8:	00 00       	add	r0,r0
800066ba:	0d 20       	ld.uh	r0,r6++
800066bc:	00 00       	add	r0,r0
800066be:	0d 1c       	ld.sh	r12,r6++
800066c0:	00 00       	add	r0,r0
800066c2:	0c 28       	rsub	r8,r6
800066c4:	00 00       	add	r0,r0
800066c6:	0c 38       	cp.w	r8,r6
800066c8:	00 00       	add	r0,r0
800066ca:	0c 34       	cp.w	r4,r6
800066cc:	00 00       	add	r0,r0
800066ce:	05 38       	ld.ub	r8,r2++
800066d0:	00 00       	add	r0,r0
800066d2:	0d 58       	ld.sh	r8,--r6
800066d4:	00 00       	add	r0,r0
800066d6:	0c 3c       	cp.w	r12,r6
800066d8:	80 00       	ld.sh	r0,r0[0x0]
800066da:	5b ce       	cp.w	lr,-4
800066dc:	80 00       	ld.sh	r0,r0[0x0]
800066de:	5b 7e       	cp.w	lr,-9
800066e0:	00 00       	add	r0,r0
800066e2:	0c 20       	rsub	r0,r6

800066e4 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800066e4:	eb cd 40 c0 	pushm	r6-r7,lr
800066e8:	18 97       	mov	r7,r12
800066ea:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800066ec:	f0 1f 00 15 	mcall	80006740 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800066f0:	6c 08       	ld.w	r8,r6[0x0]
800066f2:	5b f8       	cp.w	r8,-1
800066f4:	c0 31       	brne	800066fa <xTaskCheckForTimeOut+0x16>
800066f6:	30 07       	mov	r7,0
800066f8:	c1 f8       	rjmp	80006736 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800066fa:	49 39       	lddpc	r9,80006744 <xTaskCheckForTimeOut+0x60>
800066fc:	72 09       	ld.w	r9,r9[0x0]
800066fe:	6e 0a       	ld.w	r10,r7[0x0]
80006700:	12 3a       	cp.w	r10,r9
80006702:	c0 70       	breq	80006710 <xTaskCheckForTimeOut+0x2c>
80006704:	49 19       	lddpc	r9,80006748 <xTaskCheckForTimeOut+0x64>
80006706:	72 09       	ld.w	r9,r9[0x0]
80006708:	6e 1a       	ld.w	r10,r7[0x4]
8000670a:	12 3a       	cp.w	r10,r9
8000670c:	e0 88 00 14 	brls	80006734 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80006710:	48 e9       	lddpc	r9,80006748 <xTaskCheckForTimeOut+0x64>
80006712:	72 0a       	ld.w	r10,r9[0x0]
80006714:	6e 19       	ld.w	r9,r7[0x4]
80006716:	12 1a       	sub	r10,r9
80006718:	14 38       	cp.w	r8,r10
8000671a:	e0 88 00 0d 	brls	80006734 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
8000671e:	48 ba       	lddpc	r10,80006748 <xTaskCheckForTimeOut+0x64>
80006720:	74 0a       	ld.w	r10,r10[0x0]
80006722:	14 19       	sub	r9,r10
80006724:	f2 08 00 08 	add	r8,r9,r8
80006728:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000672a:	0e 9c       	mov	r12,r7
8000672c:	f0 1f 00 08 	mcall	8000674c <xTaskCheckForTimeOut+0x68>
80006730:	30 07       	mov	r7,0
80006732:	c0 28       	rjmp	80006736 <xTaskCheckForTimeOut+0x52>
80006734:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80006736:	f0 1f 00 07 	mcall	80006750 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000673a:	0e 9c       	mov	r12,r7
8000673c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006740:	80 00       	ld.sh	r0,r0[0x0]
80006742:	5c 88       	casts.h	r8
80006744:	00 00       	add	r0,r0
80006746:	0c 34       	cp.w	r4,r6
80006748:	00 00       	add	r0,r0
8000674a:	0d 1c       	ld.sh	r12,r6++
8000674c:	80 00       	ld.sh	r0,r0[0x0]
8000674e:	64 48       	ld.w	r8,r2[0x10]
80006750:	80 00       	ld.sh	r0,r0[0x0]
80006752:	5d 94       	*unknown*

80006754 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80006754:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80006758:	f0 1f 00 05 	mcall	8000676c <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
8000675c:	48 58       	lddpc	r8,80006770 <xTaskGetTickCount+0x1c>
8000675e:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80006760:	f0 1f 00 05 	mcall	80006774 <xTaskGetTickCount+0x20>

	return xTicks;
}
80006764:	0e 9c       	mov	r12,r7
80006766:	e3 cd 80 80 	ldm	sp++,r7,pc
8000676a:	00 00       	add	r0,r0
8000676c:	80 00       	ld.sh	r0,r0[0x0]
8000676e:	5c 88       	casts.h	r8
80006770:	00 00       	add	r0,r0
80006772:	0d 1c       	ld.sh	r12,r6++
80006774:	80 00       	ld.sh	r0,r0[0x0]
80006776:	5d 94       	*unknown*

80006778 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80006778:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
8000677c:	f0 1f 00 2c 	mcall	8000682c <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006780:	4a c8       	lddpc	r8,80006830 <xTaskResumeAll+0xb8>
80006782:	70 09       	ld.w	r9,r8[0x0]
80006784:	20 19       	sub	r9,1
80006786:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006788:	70 08       	ld.w	r8,r8[0x0]
8000678a:	58 08       	cp.w	r8,0
8000678c:	c4 91       	brne	8000681e <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
8000678e:	4a a8       	lddpc	r8,80006834 <xTaskResumeAll+0xbc>
80006790:	70 08       	ld.w	r8,r8[0x0]
80006792:	58 08       	cp.w	r8,0
80006794:	c4 50       	breq	8000681e <xTaskResumeAll+0xa6>
80006796:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006798:	4a 85       	lddpc	r5,80006838 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
8000679a:	4a 93       	lddpc	r3,8000683c <xTaskResumeAll+0xc4>
8000679c:	4a 92       	lddpc	r2,80006840 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000679e:	4a a1       	lddpc	r1,80006844 <xTaskResumeAll+0xcc>
800067a0:	c1 e8       	rjmp	800067dc <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800067a2:	6a 38       	ld.w	r8,r5[0xc]
800067a4:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
800067a6:	ee cc ff e8 	sub	r12,r7,-24
800067aa:	f0 1f 00 28 	mcall	80006848 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800067ae:	ee c6 ff fc 	sub	r6,r7,-4
800067b2:	0c 9c       	mov	r12,r6
800067b4:	f0 1f 00 25 	mcall	80006848 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800067b8:	6e bc       	ld.w	r12,r7[0x2c]
800067ba:	66 08       	ld.w	r8,r3[0x0]
800067bc:	10 3c       	cp.w	r12,r8
800067be:	e7 fc ba 00 	st.whi	r3[0x0],r12
800067c2:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800067c6:	0c 9b       	mov	r11,r6
800067c8:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800067cc:	f0 1f 00 20 	mcall	8000684c <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800067d0:	62 08       	ld.w	r8,r1[0x0]
800067d2:	6e b9       	ld.w	r9,r7[0x2c]
800067d4:	70 b8       	ld.w	r8,r8[0x2c]
800067d6:	10 39       	cp.w	r9,r8
800067d8:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800067dc:	6a 08       	ld.w	r8,r5[0x0]
800067de:	58 08       	cp.w	r8,0
800067e0:	ce 11       	brne	800067a2 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800067e2:	49 c8       	lddpc	r8,80006850 <xTaskResumeAll+0xd8>
800067e4:	70 08       	ld.w	r8,r8[0x0]
800067e6:	58 08       	cp.w	r8,0
800067e8:	c0 f0       	breq	80006806 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800067ea:	49 a8       	lddpc	r8,80006850 <xTaskResumeAll+0xd8>
800067ec:	70 08       	ld.w	r8,r8[0x0]
800067ee:	58 08       	cp.w	r8,0
800067f0:	c1 10       	breq	80006812 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800067f2:	49 87       	lddpc	r7,80006850 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800067f4:	f0 1f 00 18 	mcall	80006854 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800067f8:	6e 08       	ld.w	r8,r7[0x0]
800067fa:	20 18       	sub	r8,1
800067fc:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800067fe:	6e 08       	ld.w	r8,r7[0x0]
80006800:	58 08       	cp.w	r8,0
80006802:	cf 91       	brne	800067f4 <xTaskResumeAll+0x7c>
80006804:	c0 78       	rjmp	80006812 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80006806:	58 14       	cp.w	r4,1
80006808:	c0 50       	breq	80006812 <xTaskResumeAll+0x9a>
8000680a:	49 48       	lddpc	r8,80006858 <xTaskResumeAll+0xe0>
8000680c:	70 08       	ld.w	r8,r8[0x0]
8000680e:	58 18       	cp.w	r8,1
80006810:	c0 71       	brne	8000681e <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80006812:	30 09       	mov	r9,0
80006814:	49 18       	lddpc	r8,80006858 <xTaskResumeAll+0xe0>
80006816:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80006818:	d7 33       	scall
8000681a:	30 17       	mov	r7,1
8000681c:	c0 28       	rjmp	80006820 <xTaskResumeAll+0xa8>
8000681e:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80006820:	f0 1f 00 0f 	mcall	8000685c <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80006824:	0e 9c       	mov	r12,r7
80006826:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000682a:	00 00       	add	r0,r0
8000682c:	80 00       	ld.sh	r0,r0[0x0]
8000682e:	5c 88       	casts.h	r8
80006830:	00 00       	add	r0,r0
80006832:	0d 20       	ld.uh	r0,r6++
80006834:	00 00       	add	r0,r0
80006836:	0d 3c       	ld.ub	r12,r6++
80006838:	00 00       	add	r0,r0
8000683a:	0c f4       	st.b	--r6,r4
8000683c:	00 00       	add	r0,r0
8000683e:	0d 58       	ld.sh	r8,--r6
80006840:	00 00       	add	r0,r0
80006842:	0c 3c       	cp.w	r12,r6
80006844:	00 00       	add	r0,r0
80006846:	0c f0       	st.b	--r6,r0
80006848:	80 00       	ld.sh	r0,r0[0x0]
8000684a:	5b ce       	cp.w	lr,-4
8000684c:	80 00       	ld.sh	r0,r0[0x0]
8000684e:	5b 7e       	cp.w	lr,-9
80006850:	00 00       	add	r0,r0
80006852:	0c 20       	rsub	r0,r6
80006854:	80 00       	ld.sh	r0,r0[0x0]
80006856:	65 d0       	ld.w	r0,r2[0x74]
80006858:	00 00       	add	r0,r0
8000685a:	0d 40       	ld.w	r0,--r6
8000685c:	80 00       	ld.sh	r0,r0[0x0]
8000685e:	5d 94       	*unknown*

80006860 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006860:	eb cd 40 80 	pushm	r7,lr
80006864:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80006866:	49 08       	lddpc	r8,800068a4 <prvAddCurrentTaskToDelayedList+0x44>
80006868:	70 08       	ld.w	r8,r8[0x0]
8000686a:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
8000686c:	48 f8       	lddpc	r8,800068a8 <prvAddCurrentTaskToDelayedList+0x48>
8000686e:	70 08       	ld.w	r8,r8[0x0]
80006870:	10 3c       	cp.w	r12,r8
80006872:	c0 a2       	brcc	80006886 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006874:	48 c8       	lddpc	r8,800068a4 <prvAddCurrentTaskToDelayedList+0x44>
80006876:	70 0b       	ld.w	r11,r8[0x0]
80006878:	48 d8       	lddpc	r8,800068ac <prvAddCurrentTaskToDelayedList+0x4c>
8000687a:	70 0c       	ld.w	r12,r8[0x0]
8000687c:	2f cb       	sub	r11,-4
8000687e:	f0 1f 00 0d 	mcall	800068b0 <prvAddCurrentTaskToDelayedList+0x50>
80006882:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006886:	48 88       	lddpc	r8,800068a4 <prvAddCurrentTaskToDelayedList+0x44>
80006888:	70 0b       	ld.w	r11,r8[0x0]
8000688a:	48 b8       	lddpc	r8,800068b4 <prvAddCurrentTaskToDelayedList+0x54>
8000688c:	70 0c       	ld.w	r12,r8[0x0]
8000688e:	2f cb       	sub	r11,-4
80006890:	f0 1f 00 08 	mcall	800068b0 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006894:	48 98       	lddpc	r8,800068b8 <prvAddCurrentTaskToDelayedList+0x58>
80006896:	70 08       	ld.w	r8,r8[0x0]
80006898:	10 37       	cp.w	r7,r8
8000689a:	c0 32       	brcc	800068a0 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
8000689c:	48 78       	lddpc	r8,800068b8 <prvAddCurrentTaskToDelayedList+0x58>
8000689e:	91 07       	st.w	r8[0x0],r7
800068a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800068a4:	00 00       	add	r0,r0
800068a6:	0c f0       	st.b	--r6,r0
800068a8:	00 00       	add	r0,r0
800068aa:	0d 1c       	ld.sh	r12,r6++
800068ac:	00 00       	add	r0,r0
800068ae:	0c 38       	cp.w	r8,r6
800068b0:	80 00       	ld.sh	r0,r0[0x0]
800068b2:	5b 9a       	cp.w	r10,-7
800068b4:	00 00       	add	r0,r0
800068b6:	0c 28       	rsub	r8,r6
800068b8:	00 00       	add	r0,r0
800068ba:	05 38       	ld.ub	r8,r2++

800068bc <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
800068bc:	eb cd 40 c0 	pushm	r6-r7,lr
800068c0:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
800068c2:	58 0c       	cp.w	r12,0
800068c4:	c1 10       	breq	800068e6 <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
800068c6:	f0 1f 00 0a 	mcall	800068ec <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
800068ca:	48 a8       	lddpc	r8,800068f0 <vTaskDelay+0x34>
800068cc:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800068ce:	48 a8       	lddpc	r8,800068f4 <vTaskDelay+0x38>
800068d0:	70 0c       	ld.w	r12,r8[0x0]
800068d2:	2f cc       	sub	r12,-4
800068d4:	f0 1f 00 09 	mcall	800068f8 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800068d8:	ee 06 00 0c 	add	r12,r7,r6
800068dc:	f0 1f 00 08 	mcall	800068fc <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
800068e0:	f0 1f 00 08 	mcall	80006900 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800068e4:	c0 21       	brne	800068e8 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
800068e6:	d7 33       	scall
800068e8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800068ec:	80 00       	ld.sh	r0,r0[0x0]
800068ee:	63 bc       	ld.w	r12,r1[0x6c]
800068f0:	00 00       	add	r0,r0
800068f2:	0d 1c       	ld.sh	r12,r6++
800068f4:	00 00       	add	r0,r0
800068f6:	0c f0       	st.b	--r6,r0
800068f8:	80 00       	ld.sh	r0,r0[0x0]
800068fa:	5b ce       	cp.w	lr,-4
800068fc:	80 00       	ld.sh	r0,r0[0x0]
800068fe:	68 60       	ld.w	r0,r4[0x18]
80006900:	80 00       	ld.sh	r0,r0[0x0]
80006902:	67 78       	ld.w	r8,r3[0x5c]

80006904 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80006904:	eb cd 40 c0 	pushm	r6-r7,lr
80006908:	18 96       	mov	r6,r12
8000690a:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
8000690c:	f0 1f 00 18 	mcall	8000696c <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80006910:	6c 08       	ld.w	r8,r6[0x0]
80006912:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006914:	49 79       	lddpc	r9,80006970 <vTaskDelayUntil+0x6c>
80006916:	72 09       	ld.w	r9,r9[0x0]
80006918:	12 38       	cp.w	r8,r9
8000691a:	e0 88 00 0c 	brls	80006932 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
8000691e:	0e 38       	cp.w	r8,r7
80006920:	e0 88 00 22 	brls	80006964 <vTaskDelayUntil+0x60>
80006924:	49 38       	lddpc	r8,80006970 <vTaskDelayUntil+0x6c>
80006926:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006928:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
8000692a:	10 37       	cp.w	r7,r8
8000692c:	e0 88 00 14 	brls	80006954 <vTaskDelayUntil+0x50>
80006930:	c0 a8       	rjmp	80006944 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80006932:	0e 38       	cp.w	r8,r7
80006934:	e0 8b 00 16 	brhi	80006960 <vTaskDelayUntil+0x5c>
80006938:	48 e8       	lddpc	r8,80006970 <vTaskDelayUntil+0x6c>
8000693a:	70 08       	ld.w	r8,r8[0x0]
8000693c:	10 37       	cp.w	r7,r8
8000693e:	e0 8b 00 11 	brhi	80006960 <vTaskDelayUntil+0x5c>
80006942:	c1 18       	rjmp	80006964 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006944:	48 c8       	lddpc	r8,80006974 <vTaskDelayUntil+0x70>
80006946:	70 0c       	ld.w	r12,r8[0x0]
80006948:	2f cc       	sub	r12,-4
8000694a:	f0 1f 00 0c 	mcall	80006978 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
8000694e:	0e 9c       	mov	r12,r7
80006950:	f0 1f 00 0b 	mcall	8000697c <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006954:	f0 1f 00 0b 	mcall	80006980 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006958:	c0 81       	brne	80006968 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
8000695a:	d7 33       	scall
8000695c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006960:	8d 07       	st.w	r6[0x0],r7
80006962:	cf 1b       	rjmp	80006944 <vTaskDelayUntil+0x40>
80006964:	8d 07       	st.w	r6[0x0],r7
80006966:	cf 7b       	rjmp	80006954 <vTaskDelayUntil+0x50>
80006968:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000696c:	80 00       	ld.sh	r0,r0[0x0]
8000696e:	63 bc       	ld.w	r12,r1[0x6c]
80006970:	00 00       	add	r0,r0
80006972:	0d 1c       	ld.sh	r12,r6++
80006974:	00 00       	add	r0,r0
80006976:	0c f0       	st.b	--r6,r0
80006978:	80 00       	ld.sh	r0,r0[0x0]
8000697a:	5b ce       	cp.w	lr,-4
8000697c:	80 00       	ld.sh	r0,r0[0x0]
8000697e:	68 60       	ld.w	r0,r4[0x18]
80006980:	80 00       	ld.sh	r0,r0[0x0]
80006982:	67 78       	ld.w	r8,r3[0x5c]

80006984 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006984:	eb cd 40 c0 	pushm	r6-r7,lr
80006988:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
8000698a:	48 e7       	lddpc	r7,800069c0 <vTaskPlaceOnEventList+0x3c>
8000698c:	6e 0b       	ld.w	r11,r7[0x0]
8000698e:	2e 8b       	sub	r11,-24
80006990:	f0 1f 00 0d 	mcall	800069c4 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006994:	6e 0c       	ld.w	r12,r7[0x0]
80006996:	2f cc       	sub	r12,-4
80006998:	f0 1f 00 0c 	mcall	800069c8 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
8000699c:	5b f6       	cp.w	r6,-1
8000699e:	c0 81       	brne	800069ae <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800069a0:	6e 0b       	ld.w	r11,r7[0x0]
800069a2:	2f cb       	sub	r11,-4
800069a4:	48 ac       	lddpc	r12,800069cc <vTaskPlaceOnEventList+0x48>
800069a6:	f0 1f 00 0b 	mcall	800069d0 <vTaskPlaceOnEventList+0x4c>
800069aa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
800069ae:	48 a8       	lddpc	r8,800069d4 <vTaskPlaceOnEventList+0x50>
800069b0:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
800069b2:	ec 0c 00 0c 	add	r12,r6,r12
800069b6:	f0 1f 00 09 	mcall	800069d8 <vTaskPlaceOnEventList+0x54>
800069ba:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800069be:	00 00       	add	r0,r0
800069c0:	00 00       	add	r0,r0
800069c2:	0c f0       	st.b	--r6,r0
800069c4:	80 00       	ld.sh	r0,r0[0x0]
800069c6:	5b 9a       	cp.w	r10,-7
800069c8:	80 00       	ld.sh	r0,r0[0x0]
800069ca:	5b ce       	cp.w	lr,-4
800069cc:	00 00       	add	r0,r0
800069ce:	0d 44       	ld.w	r4,--r6
800069d0:	80 00       	ld.sh	r0,r0[0x0]
800069d2:	5b 7e       	cp.w	lr,-9
800069d4:	00 00       	add	r0,r0
800069d6:	0d 1c       	ld.sh	r12,r6++
800069d8:	80 00       	ld.sh	r0,r0[0x0]
800069da:	68 60       	ld.w	r0,r4[0x18]

800069dc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
800069dc:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800069e0:	49 67       	lddpc	r7,80006a38 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800069e2:	49 74       	lddpc	r4,80006a3c <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
800069e4:	49 73       	lddpc	r3,80006a40 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800069e6:	49 85       	lddpc	r5,80006a44 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800069e8:	6e 08       	ld.w	r8,r7[0x0]
800069ea:	58 08       	cp.w	r8,0
800069ec:	c1 e0       	breq	80006a28 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
800069ee:	f0 1f 00 17 	mcall	80006a48 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800069f2:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
800069f4:	f0 1f 00 16 	mcall	80006a4c <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
800069f8:	58 06       	cp.w	r6,0
800069fa:	c1 70       	breq	80006a28 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
800069fc:	f0 1f 00 15 	mcall	80006a50 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006a00:	68 38       	ld.w	r8,r4[0xc]
80006a02:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006a04:	ec cc ff fc 	sub	r12,r6,-4
80006a08:	f0 1f 00 13 	mcall	80006a54 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80006a0c:	66 08       	ld.w	r8,r3[0x0]
80006a0e:	20 18       	sub	r8,1
80006a10:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80006a12:	6e 08       	ld.w	r8,r7[0x0]
80006a14:	20 18       	sub	r8,1
80006a16:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006a18:	f0 1f 00 10 	mcall	80006a58 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006a1c:	6c cc       	ld.w	r12,r6[0x30]
80006a1e:	f0 1f 00 10 	mcall	80006a5c <prvIdleTask+0x80>
		vPortFree( pxTCB );
80006a22:	0c 9c       	mov	r12,r6
80006a24:	f0 1f 00 0e 	mcall	80006a5c <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006a28:	6a 08       	ld.w	r8,r5[0x0]
80006a2a:	58 18       	cp.w	r8,1
80006a2c:	e0 88 00 03 	brls	80006a32 <prvIdleTask+0x56>
			{
				taskYIELD();
80006a30:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80006a32:	f0 1f 00 0c 	mcall	80006a60 <prvIdleTask+0x84>
		}
		#endif
	}
80006a36:	cd 9b       	rjmp	800069e8 <prvIdleTask+0xc>
80006a38:	00 00       	add	r0,r0
80006a3a:	0c 30       	cp.w	r0,r6
80006a3c:	00 00       	add	r0,r0
80006a3e:	0c dc       	st.w	--r6,r12
80006a40:	00 00       	add	r0,r0
80006a42:	0d 3c       	ld.ub	r12,r6++
80006a44:	00 00       	add	r0,r0
80006a46:	0c 3c       	cp.w	r12,r6
80006a48:	80 00       	ld.sh	r0,r0[0x0]
80006a4a:	63 bc       	ld.w	r12,r1[0x6c]
80006a4c:	80 00       	ld.sh	r0,r0[0x0]
80006a4e:	67 78       	ld.w	r8,r3[0x5c]
80006a50:	80 00       	ld.sh	r0,r0[0x0]
80006a52:	5c 88       	casts.h	r8
80006a54:	80 00       	ld.sh	r0,r0[0x0]
80006a56:	5b ce       	cp.w	lr,-4
80006a58:	80 00       	ld.sh	r0,r0[0x0]
80006a5a:	5d 94       	*unknown*
80006a5c:	80 00       	ld.sh	r0,r0[0x0]
80006a5e:	5e cc       	retvs	r12
80006a60:	80 00       	ld.sh	r0,r0[0x0]
80006a62:	20 2c       	sub	r12,2

80006a64 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006a64:	d4 31       	pushm	r0-r7,lr
80006a66:	20 1d       	sub	sp,4
80006a68:	fa c4 ff d8 	sub	r4,sp,-40
80006a6c:	50 0c       	stdsp	sp[0x0],r12
80006a6e:	16 91       	mov	r1,r11
80006a70:	14 97       	mov	r7,r10
80006a72:	12 90       	mov	r0,r9
80006a74:	10 93       	mov	r3,r8
80006a76:	68 02       	ld.w	r2,r4[0x0]
80006a78:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006a7a:	34 8c       	mov	r12,72
80006a7c:	f0 1f 00 5c 	mcall	80006bec <xTaskGenericCreate+0x188>
80006a80:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80006a82:	c0 31       	brne	80006a88 <xTaskGenericCreate+0x24>
80006a84:	3f fc       	mov	r12,-1
80006a86:	ca f8       	rjmp	80006be4 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006a88:	58 06       	cp.w	r6,0
80006a8a:	e0 81 00 af 	brne	80006be8 <xTaskGenericCreate+0x184>
80006a8e:	0e 9c       	mov	r12,r7
80006a90:	5c 7c       	castu.h	r12
80006a92:	a3 6c       	lsl	r12,0x2
80006a94:	f0 1f 00 56 	mcall	80006bec <xTaskGenericCreate+0x188>
80006a98:	18 96       	mov	r6,r12
80006a9a:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006a9c:	c0 61       	brne	80006aa8 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006a9e:	0a 9c       	mov	r12,r5
80006aa0:	f0 1f 00 54 	mcall	80006bf0 <xTaskGenericCreate+0x18c>
80006aa4:	3f fc       	mov	r12,-1
80006aa6:	c9 f8       	rjmp	80006be4 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006aa8:	5c 77       	castu.h	r7
80006aaa:	ee 0a 15 02 	lsl	r10,r7,0x2
80006aae:	e0 6b 00 a5 	mov	r11,165
80006ab2:	0c 9c       	mov	r12,r6
80006ab4:	f0 1f 00 50 	mcall	80006bf4 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006ab8:	ee c6 00 01 	sub	r6,r7,1
80006abc:	6a c8       	ld.w	r8,r5[0x30]
80006abe:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006ac2:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006ac6:	31 0a       	mov	r10,16
80006ac8:	02 9b       	mov	r11,r1
80006aca:	ea cc ff cc 	sub	r12,r5,-52
80006ace:	f0 1f 00 4b 	mcall	80006bf8 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006ad2:	30 08       	mov	r8,0
80006ad4:	eb 68 00 43 	st.b	r5[67],r8
80006ad8:	58 73       	cp.w	r3,7
80006ada:	e6 07 17 80 	movls	r7,r3
80006ade:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006ae2:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006ae4:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006ae8:	ea c4 ff fc 	sub	r4,r5,-4
80006aec:	08 9c       	mov	r12,r4
80006aee:	f0 1f 00 44 	mcall	80006bfc <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006af2:	ea cc ff e8 	sub	r12,r5,-24
80006af6:	f0 1f 00 42 	mcall	80006bfc <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006afa:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006afc:	ee 07 11 08 	rsub	r7,r7,8
80006b00:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006b02:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006b04:	00 9a       	mov	r10,r0
80006b06:	40 0b       	lddsp	r11,sp[0x0]
80006b08:	0c 9c       	mov	r12,r6
80006b0a:	f0 1f 00 3e 	mcall	80006c00 <xTaskGenericCreate+0x19c>
80006b0e:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006b10:	58 02       	cp.w	r2,0
80006b12:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006b16:	f0 1f 00 3c 	mcall	80006c04 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006b1a:	4b c8       	lddpc	r8,80006c08 <xTaskGenericCreate+0x1a4>
80006b1c:	70 09       	ld.w	r9,r8[0x0]
80006b1e:	2f f9       	sub	r9,-1
80006b20:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006b22:	4b b8       	lddpc	r8,80006c0c <xTaskGenericCreate+0x1a8>
80006b24:	70 08       	ld.w	r8,r8[0x0]
80006b26:	58 08       	cp.w	r8,0
80006b28:	c2 61       	brne	80006b74 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006b2a:	4b 98       	lddpc	r8,80006c0c <xTaskGenericCreate+0x1a8>
80006b2c:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006b2e:	4b 78       	lddpc	r8,80006c08 <xTaskGenericCreate+0x1a4>
80006b30:	70 08       	ld.w	r8,r8[0x0]
80006b32:	58 18       	cp.w	r8,1
80006b34:	c2 b1       	brne	80006b8a <xTaskGenericCreate+0x126>
80006b36:	4b 77       	lddpc	r7,80006c10 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006b38:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006b3c:	0e 9c       	mov	r12,r7
80006b3e:	f0 1f 00 36 	mcall	80006c14 <xTaskGenericCreate+0x1b0>
80006b42:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006b44:	0c 37       	cp.w	r7,r6
80006b46:	cf b1       	brne	80006b3c <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006b48:	4b 47       	lddpc	r7,80006c18 <xTaskGenericCreate+0x1b4>
80006b4a:	0e 9c       	mov	r12,r7
80006b4c:	f0 1f 00 32 	mcall	80006c14 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006b50:	4b 36       	lddpc	r6,80006c1c <xTaskGenericCreate+0x1b8>
80006b52:	0c 9c       	mov	r12,r6
80006b54:	f0 1f 00 30 	mcall	80006c14 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006b58:	4b 2c       	lddpc	r12,80006c20 <xTaskGenericCreate+0x1bc>
80006b5a:	f0 1f 00 2f 	mcall	80006c14 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006b5e:	4b 2c       	lddpc	r12,80006c24 <xTaskGenericCreate+0x1c0>
80006b60:	f0 1f 00 2d 	mcall	80006c14 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006b64:	4b 1c       	lddpc	r12,80006c28 <xTaskGenericCreate+0x1c4>
80006b66:	f0 1f 00 2c 	mcall	80006c14 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006b6a:	4b 18       	lddpc	r8,80006c2c <xTaskGenericCreate+0x1c8>
80006b6c:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006b6e:	4b 18       	lddpc	r8,80006c30 <xTaskGenericCreate+0x1cc>
80006b70:	91 06       	st.w	r8[0x0],r6
80006b72:	c0 c8       	rjmp	80006b8a <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006b74:	4b 08       	lddpc	r8,80006c34 <xTaskGenericCreate+0x1d0>
80006b76:	70 08       	ld.w	r8,r8[0x0]
80006b78:	58 08       	cp.w	r8,0
80006b7a:	c0 81       	brne	80006b8a <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006b7c:	4a 48       	lddpc	r8,80006c0c <xTaskGenericCreate+0x1a8>
80006b7e:	70 08       	ld.w	r8,r8[0x0]
80006b80:	70 b8       	ld.w	r8,r8[0x2c]
80006b82:	10 33       	cp.w	r3,r8
80006b84:	c0 33       	brcs	80006b8a <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006b86:	4a 28       	lddpc	r8,80006c0c <xTaskGenericCreate+0x1a8>
80006b88:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006b8a:	6a b8       	ld.w	r8,r5[0x2c]
80006b8c:	4a b9       	lddpc	r9,80006c38 <xTaskGenericCreate+0x1d4>
80006b8e:	72 09       	ld.w	r9,r9[0x0]
80006b90:	12 38       	cp.w	r8,r9
80006b92:	e0 88 00 04 	brls	80006b9a <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006b96:	4a 99       	lddpc	r9,80006c38 <xTaskGenericCreate+0x1d4>
80006b98:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006b9a:	4a 98       	lddpc	r8,80006c3c <xTaskGenericCreate+0x1d8>
80006b9c:	70 09       	ld.w	r9,r8[0x0]
80006b9e:	2f f9       	sub	r9,-1
80006ba0:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006ba2:	6a b8       	ld.w	r8,r5[0x2c]
80006ba4:	4a 79       	lddpc	r9,80006c40 <xTaskGenericCreate+0x1dc>
80006ba6:	72 09       	ld.w	r9,r9[0x0]
80006ba8:	12 38       	cp.w	r8,r9
80006baa:	e0 88 00 04 	brls	80006bb2 <xTaskGenericCreate+0x14e>
80006bae:	4a 59       	lddpc	r9,80006c40 <xTaskGenericCreate+0x1dc>
80006bb0:	93 08       	st.w	r9[0x0],r8
80006bb2:	6a bc       	ld.w	r12,r5[0x2c]
80006bb4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006bb8:	08 9b       	mov	r11,r4
80006bba:	49 68       	lddpc	r8,80006c10 <xTaskGenericCreate+0x1ac>
80006bbc:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006bc0:	f0 1f 00 21 	mcall	80006c44 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006bc4:	f0 1f 00 21 	mcall	80006c48 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006bc8:	49 b8       	lddpc	r8,80006c34 <xTaskGenericCreate+0x1d0>
80006bca:	70 08       	ld.w	r8,r8[0x0]
80006bcc:	58 08       	cp.w	r8,0
80006bce:	c0 a0       	breq	80006be2 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006bd0:	48 f8       	lddpc	r8,80006c0c <xTaskGenericCreate+0x1a8>
80006bd2:	70 08       	ld.w	r8,r8[0x0]
80006bd4:	70 b8       	ld.w	r8,r8[0x2c]
80006bd6:	10 33       	cp.w	r3,r8
80006bd8:	e0 88 00 05 	brls	80006be2 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006bdc:	d7 33       	scall
80006bde:	30 1c       	mov	r12,1
80006be0:	c0 28       	rjmp	80006be4 <xTaskGenericCreate+0x180>
80006be2:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006be4:	2f fd       	sub	sp,-4
80006be6:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006be8:	99 c6       	st.w	r12[0x30],r6
80006bea:	c5 fb       	rjmp	80006aa8 <xTaskGenericCreate+0x44>
80006bec:	80 00       	ld.sh	r0,r0[0x0]
80006bee:	5e f4       	retal	r4
80006bf0:	80 00       	ld.sh	r0,r0[0x0]
80006bf2:	5e cc       	retvs	r12
80006bf4:	80 00       	ld.sh	r0,r0[0x0]
80006bf6:	77 ec       	ld.w	r12,r11[0x78]
80006bf8:	80 00       	ld.sh	r0,r0[0x0]
80006bfa:	7b 18       	ld.w	r8,sp[0x44]
80006bfc:	80 00       	ld.sh	r0,r0[0x0]
80006bfe:	5b 78       	cp.w	r8,-9
80006c00:	80 00       	ld.sh	r0,r0[0x0]
80006c02:	5b f4       	cp.w	r4,-1
80006c04:	80 00       	ld.sh	r0,r0[0x0]
80006c06:	5c 88       	casts.h	r8
80006c08:	00 00       	add	r0,r0
80006c0a:	0d 3c       	ld.ub	r12,r6++
80006c0c:	00 00       	add	r0,r0
80006c0e:	0c f0       	st.b	--r6,r0
80006c10:	00 00       	add	r0,r0
80006c12:	0c 3c       	cp.w	r12,r6
80006c14:	80 00       	ld.sh	r0,r0[0x0]
80006c16:	5b 64       	cp.w	r4,-10
80006c18:	00 00       	add	r0,r0
80006c1a:	0d 08       	ld.w	r8,r6++
80006c1c:	00 00       	add	r0,r0
80006c1e:	0d 24       	ld.uh	r4,r6++
80006c20:	00 00       	add	r0,r0
80006c22:	0c f4       	st.b	--r6,r4
80006c24:	00 00       	add	r0,r0
80006c26:	0c dc       	st.w	--r6,r12
80006c28:	00 00       	add	r0,r0
80006c2a:	0d 44       	ld.w	r4,--r6
80006c2c:	00 00       	add	r0,r0
80006c2e:	0c 28       	rsub	r8,r6
80006c30:	00 00       	add	r0,r0
80006c32:	0c 38       	cp.w	r8,r6
80006c34:	00 00       	add	r0,r0
80006c36:	0c 2c       	rsub	r12,r6
80006c38:	00 00       	add	r0,r0
80006c3a:	0c 24       	rsub	r4,r6
80006c3c:	00 00       	add	r0,r0
80006c3e:	0d 38       	ld.ub	r8,r6++
80006c40:	00 00       	add	r0,r0
80006c42:	0d 58       	ld.sh	r8,--r6
80006c44:	80 00       	ld.sh	r0,r0[0x0]
80006c46:	5b 7e       	cp.w	lr,-9
80006c48:	80 00       	ld.sh	r0,r0[0x0]
80006c4a:	5d 94       	*unknown*

80006c4c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006c4c:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006c4e:	30 09       	mov	r9,0
80006c50:	1a d9       	st.w	--sp,r9
80006c52:	1a d9       	st.w	--sp,r9
80006c54:	1a d9       	st.w	--sp,r9
80006c56:	12 98       	mov	r8,r9
80006c58:	e0 6a 01 00 	mov	r10,256
80006c5c:	48 9b       	lddpc	r11,80006c80 <vTaskStartScheduler+0x34>
80006c5e:	48 ac       	lddpc	r12,80006c84 <vTaskStartScheduler+0x38>
80006c60:	f0 1f 00 0a 	mcall	80006c88 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006c64:	2f dd       	sub	sp,-12
80006c66:	58 1c       	cp.w	r12,1
80006c68:	c0 a1       	brne	80006c7c <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006c6a:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006c6c:	30 19       	mov	r9,1
80006c6e:	48 88       	lddpc	r8,80006c8c <vTaskStartScheduler+0x40>
80006c70:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006c72:	30 09       	mov	r9,0
80006c74:	48 78       	lddpc	r8,80006c90 <vTaskStartScheduler+0x44>
80006c76:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006c78:	f0 1f 00 07 	mcall	80006c94 <vTaskStartScheduler+0x48>
80006c7c:	d8 02       	popm	pc
80006c7e:	00 00       	add	r0,r0
80006c80:	80 00       	ld.sh	r0,r0[0x0]
80006c82:	d7 f8       	*unknown*
80006c84:	80 00       	ld.sh	r0,r0[0x0]
80006c86:	69 dc       	ld.w	r12,r4[0x74]
80006c88:	80 00       	ld.sh	r0,r0[0x0]
80006c8a:	6a 64       	ld.w	r4,r5[0x18]
80006c8c:	00 00       	add	r0,r0
80006c8e:	0c 2c       	rsub	r12,r6
80006c90:	00 00       	add	r0,r0
80006c92:	0d 1c       	ld.sh	r12,r6++
80006c94:	80 00       	ld.sh	r0,r0[0x0]
80006c96:	5c 98       	brev	r8

80006c98 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006c98:	16 cc       	st.b	r11++,r12
	return str;
}
80006c9a:	5e fb       	retal	r11

80006c9c <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006c9c:	eb cd 40 c0 	pushm	r6-r7,lr
80006ca0:	20 3d       	sub	sp,12
80006ca2:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006ca4:	30 06       	mov	r6,0
80006ca6:	30 07       	mov	r7,0
80006ca8:	fa e7 00 00 	st.d	sp[0],r6
80006cac:	30 0c       	mov	r12,0
80006cae:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006cb0:	58 08       	cp.w	r8,0
80006cb2:	c1 30       	breq	80006cd8 <PrintHex+0x3c>
80006cb4:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006cb6:	1a 9c       	mov	r12,sp
80006cb8:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006cbc:	58 9e       	cp.w	lr,9
80006cbe:	e0 8a 00 04 	brle	80006cc6 <PrintHex+0x2a>
80006cc2:	2c 9e       	sub	lr,-55
80006cc4:	c0 48       	rjmp	80006ccc <PrintHex+0x30>
80006cc6:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006cca:	2d 0e       	sub	lr,-48
80006ccc:	f8 09 0b 0e 	st.b	r12[r9],lr
80006cd0:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006cd2:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006cd4:	cf 21       	brne	80006cb8 <PrintHex+0x1c>
80006cd6:	c0 48       	rjmp	80006cde <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006cd8:	33 08       	mov	r8,48
80006cda:	ba 88       	st.b	sp[0x0],r8
80006cdc:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006cde:	f6 09 01 08 	sub	r8,r11,r9
80006ce2:	58 08       	cp.w	r8,0
80006ce4:	e0 8a 00 13 	brle	80006d0a <PrintHex+0x6e>
	{
		char num = len - cnt;
80006ce8:	12 1b       	sub	r11,r9
80006cea:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006cee:	18 9e       	mov	lr,r12
80006cf0:	58 0c       	cp.w	r12,0
80006cf2:	e0 8a 00 0c 	brle	80006d0a <PrintHex+0x6e>
80006cf6:	1a 9b       	mov	r11,sp
80006cf8:	12 0b       	add	r11,r9
80006cfa:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006cfc:	33 07       	mov	r7,48
80006cfe:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006d00:	2f f8       	sub	r8,-1
80006d02:	1c 38       	cp.w	r8,lr
80006d04:	cf d5       	brlt	80006cfe <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006d06:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006d0a:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006d0e:	f0 cb ff ff 	sub	r11,r8,-1
80006d12:	58 0b       	cp.w	r11,0
80006d14:	e0 8a 00 19 	brle	80006d46 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006d18:	fa cb ff f4 	sub	r11,sp,-12
80006d1c:	f6 09 00 09 	add	r9,r11,r9
80006d20:	37 8b       	mov	r11,120
80006d22:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006d26:	fa c9 ff f4 	sub	r9,sp,-12
80006d2a:	10 09       	add	r9,r8
80006d2c:	33 0b       	mov	r11,48
80006d2e:	f3 6b ff f4 	st.b	r9[-12],r11
80006d32:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006d36:	fa ce 00 01 	sub	lr,sp,1
80006d3a:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006d3c:	11 8b       	ld.ub	r11,r8[0x0]
80006d3e:	12 cb       	st.b	r9++,r11
80006d40:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006d42:	1c 38       	cp.w	r8,lr
80006d44:	cf c1       	brne	80006d3c <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006d46:	14 9c       	mov	r12,r10
80006d48:	2f dd       	sub	sp,-12
80006d4a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006d4e <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006d4e:	d4 21       	pushm	r4-r7,lr
80006d50:	20 3d       	sub	sp,12
80006d52:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006d54:	30 06       	mov	r6,0
80006d56:	30 07       	mov	r7,0
80006d58:	fa e7 00 00 	st.d	sp[0],r6
80006d5c:	30 0c       	mov	r12,0
80006d5e:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006d60:	58 08       	cp.w	r8,0
80006d62:	c0 35       	brlt	80006d68 <PrintDec+0x1a>
80006d64:	14 97       	mov	r7,r10
80006d66:	c0 58       	rjmp	80006d70 <PrintDec+0x22>
	{
		*p++ = '-';
80006d68:	14 97       	mov	r7,r10
80006d6a:	32 d9       	mov	r9,45
80006d6c:	0e c9       	st.b	r7++,r9
		i = -i;
80006d6e:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006d70:	58 08       	cp.w	r8,0
80006d72:	c0 51       	brne	80006d7c <PrintDec+0x2e>
80006d74:	33 08       	mov	r8,48
80006d76:	ba 88       	st.b	sp[0x0],r8
80006d78:	30 1e       	mov	lr,1
80006d7a:	c2 f8       	rjmp	80006dd8 <PrintDec+0x8a>
	
	int ten = i%10;
80006d7c:	e0 65 66 67 	mov	r5,26215
80006d80:	ea 15 66 66 	orh	r5,0x6666
80006d84:	f0 05 04 44 	muls.d	r4,r8,r5
80006d88:	ea 0c 14 02 	asr	r12,r5,0x2
80006d8c:	f0 09 14 1f 	asr	r9,r8,0x1f
80006d90:	f8 09 01 09 	sub	r9,r12,r9
80006d94:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006d98:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006d9c:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006d9e:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006da0:	e0 66 66 67 	mov	r6,26215
80006da4:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006da8:	2d 09       	sub	r9,-48
80006daa:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006dae:	2f fe       	sub	lr,-1
		i /= 10;
80006db0:	f0 06 04 44 	muls.d	r4,r8,r6
80006db4:	ea 09 14 02 	asr	r9,r5,0x2
80006db8:	bf 58       	asr	r8,0x1f
80006dba:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006dbe:	f0 06 04 44 	muls.d	r4,r8,r6
80006dc2:	ea 09 14 02 	asr	r9,r5,0x2
80006dc6:	f0 05 14 1f 	asr	r5,r8,0x1f
80006dca:	0a 19       	sub	r9,r5
80006dcc:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006dd0:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006dd4:	58 08       	cp.w	r8,0
80006dd6:	ce 91       	brne	80006da8 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006dd8:	f6 0e 01 08 	sub	r8,r11,lr
80006ddc:	58 08       	cp.w	r8,0
80006dde:	e0 89 00 06 	brgt	80006dea <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006de2:	58 0e       	cp.w	lr,0
80006de4:	e0 89 00 14 	brgt	80006e0c <PrintDec+0xbe>
80006de8:	c1 d8       	rjmp	80006e22 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006dea:	1c 1b       	sub	r11,lr
80006dec:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006dee:	16 9c       	mov	r12,r11
80006df0:	58 0b       	cp.w	r11,0
80006df2:	fe 9a ff f8 	brle	80006de2 <PrintDec+0x94>
80006df6:	1a 99       	mov	r9,sp
80006df8:	1c 09       	add	r9,lr
80006dfa:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006dfc:	33 06       	mov	r6,48
80006dfe:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006e00:	2f f8       	sub	r8,-1
80006e02:	18 38       	cp.w	r8,r12
80006e04:	cf d5       	brlt	80006dfe <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006e06:	f6 0e 00 0e 	add	lr,r11,lr
80006e0a:	ce cb       	rjmp	80006de2 <PrintDec+0x94>
80006e0c:	fa c8 ff f4 	sub	r8,sp,-12
80006e10:	1c 08       	add	r8,lr
80006e12:	20 d8       	sub	r8,13
80006e14:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006e18:	11 89       	ld.ub	r9,r8[0x0]
80006e1a:	0e c9       	st.b	r7++,r9
80006e1c:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006e1e:	16 38       	cp.w	r8,r11
80006e20:	cf c1       	brne	80006e18 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80006e22:	14 9c       	mov	r12,r10
80006e24:	2f dd       	sub	sp,-12
80006e26:	d8 22       	popm	r4-r7,pc

80006e28 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006e28:	d4 31       	pushm	r0-r7,lr
80006e2a:	fa cd 02 08 	sub	sp,sp,520
80006e2e:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006e30:	e0 6a 01 00 	mov	r10,256
80006e34:	30 0b       	mov	r11,0
80006e36:	fa cc fe f8 	sub	r12,sp,-264
80006e3a:	f0 1f 00 4e 	mcall	80006f70 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006e3e:	fa c4 fd d4 	sub	r4,sp,-556
80006e42:	30 0a       	mov	r10,0
80006e44:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006e46:	fa c3 ff fc 	sub	r3,sp,-4
80006e4a:	e0 61 01 00 	mov	r1,256
80006e4e:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006e50:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006e52:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006e56:	02 9a       	mov	r10,r1
80006e58:	00 9b       	mov	r11,r0
80006e5a:	06 9c       	mov	r12,r3
80006e5c:	f0 1f 00 45 	mcall	80006f70 <log+0x148>
			
					if(*str == '%')
80006e60:	0f 88       	ld.ub	r8,r7[0x0]
80006e62:	e4 08 18 00 	cp.b	r8,r2
80006e66:	c5 71       	brne	80006f14 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80006e68:	ee c8 ff ff 	sub	r8,r7,-1
80006e6c:	11 89       	ld.ub	r9,r8[0x0]
80006e6e:	4c 2a       	lddpc	r10,80006f74 <log+0x14c>
80006e70:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80006e72:	23 09       	sub	r9,48
80006e74:	30 9a       	mov	r10,9
80006e76:	f4 09 18 00 	cp.b	r9,r10
80006e7a:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80006e7e:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006e82:	f7 b9 08 30 	subls	r9,48
80006e86:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80006e8a:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80006e8e:	0f 88       	ld.ub	r8,r7[0x0]
80006e90:	22 58       	sub	r8,37
80006e92:	e0 48 00 53 	cp.w	r8,83
80006e96:	e0 8b 00 31 	brhi	80006ef8 <log+0xd0>
80006e9a:	4b 89       	lddpc	r9,80006f78 <log+0x150>
80006e9c:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006ea0:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006ea4:	06 9a       	mov	r10,r3
80006ea6:	40 0b       	lddsp	r11,sp[0x0]
80006ea8:	5c 5b       	castu.b	r11
80006eaa:	68 0c       	ld.w	r12,r4[0x0]
80006eac:	f0 1f 00 34 	mcall	80006f7c <log+0x154>
							break;
80006eb0:	c2 98       	rjmp	80006f02 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006eb2:	4b 4c       	lddpc	r12,80006f80 <log+0x158>
80006eb4:	f0 1f 00 34 	mcall	80006f84 <log+0x15c>
80006eb8:	08 95       	mov	r5,r4
80006eba:	06 9c       	mov	r12,r3
							break;
80006ebc:	c2 38       	rjmp	80006f02 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80006ebe:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006ec2:	06 9a       	mov	r10,r3
80006ec4:	40 0b       	lddsp	r11,sp[0x0]
80006ec6:	5c 5b       	castu.b	r11
80006ec8:	68 0c       	ld.w	r12,r4[0x0]
80006eca:	f0 1f 00 30 	mcall	80006f88 <log+0x160>
80006ece:	06 9c       	mov	r12,r3
							break;
80006ed0:	c1 98       	rjmp	80006f02 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006ed2:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006ed6:	06 9b       	mov	r11,r3
80006ed8:	09 bc       	ld.ub	r12,r4[0x3]
80006eda:	f0 1f 00 2d 	mcall	80006f8c <log+0x164>
80006ede:	06 9c       	mov	r12,r3
							break;
80006ee0:	c1 18       	rjmp	80006f02 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006ee2:	e8 c5 ff fc 	sub	r5,r4,-4
80006ee6:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006ee8:	c0 d8       	rjmp	80006f02 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006eea:	06 9b       	mov	r11,r3
80006eec:	32 5c       	mov	r12,37
80006eee:	f0 1f 00 28 	mcall	80006f8c <log+0x164>
80006ef2:	08 95       	mov	r5,r4
80006ef4:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80006ef6:	c0 68       	rjmp	80006f02 <log+0xda>
							
							default:
							log("I need relax.");
80006ef8:	4a 6c       	lddpc	r12,80006f90 <log+0x168>
80006efa:	f0 1f 00 23 	mcall	80006f84 <log+0x15c>
80006efe:	08 95       	mov	r5,r4
80006f00:	06 9c       	mov	r12,r3
						}
						str++;
80006f02:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006f04:	1a dc       	st.w	--sp,r12
80006f06:	1a d6       	st.w	--sp,r6
80006f08:	4a 3b       	lddpc	r11,80006f94 <log+0x16c>
80006f0a:	0c 9c       	mov	r12,r6
80006f0c:	f0 1f 00 23 	mcall	80006f98 <log+0x170>
80006f10:	2f ed       	sub	sp,-8
80006f12:	c0 a8       	rjmp	80006f26 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006f14:	2f f7       	sub	r7,-1
80006f16:	1a d8       	st.w	--sp,r8
80006f18:	1a d6       	st.w	--sp,r6
80006f1a:	4a 1b       	lddpc	r11,80006f9c <log+0x174>
80006f1c:	0c 9c       	mov	r12,r6
80006f1e:	f0 1f 00 1f 	mcall	80006f98 <log+0x170>
80006f22:	08 95       	mov	r5,r4
80006f24:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80006f26:	0f 89       	ld.ub	r9,r7[0x0]
80006f28:	30 08       	mov	r8,0
80006f2a:	f0 09 18 00 	cp.b	r9,r8
80006f2e:	c0 30       	breq	80006f34 <log+0x10c>
80006f30:	0a 94       	mov	r4,r5
80006f32:	c9 2b       	rjmp	80006e56 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006f34:	fa c7 fe f8 	sub	r7,sp,-264
80006f38:	1a d7       	st.w	--sp,r7
80006f3a:	49 ab       	lddpc	r11,80006fa0 <log+0x178>
80006f3c:	0e 9c       	mov	r12,r7
80006f3e:	f0 1f 00 17 	mcall	80006f98 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80006f42:	5c 5c       	castu.b	r12
80006f44:	f8 c6 ff ff 	sub	r6,r12,-1
80006f48:	0c 9c       	mov	r12,r6
80006f4a:	f0 1f 00 17 	mcall	80006fa4 <log+0x17c>
80006f4e:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80006f50:	0c 9a       	mov	r10,r6
80006f52:	0e 9b       	mov	r11,r7
80006f54:	f0 1f 00 15 	mcall	80006fa8 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80006f58:	30 09       	mov	r9,0
80006f5a:	30 5a       	mov	r10,5
80006f5c:	fa cb fe f8 	sub	r11,sp,-264
80006f60:	49 38       	lddpc	r8,80006fac <log+0x184>
80006f62:	70 0c       	ld.w	r12,r8[0x0]
80006f64:	f0 1f 00 13 	mcall	80006fb0 <log+0x188>
80006f68:	2f fd       	sub	sp,-4
	
	
}
80006f6a:	fe 3d fd f8 	sub	sp,-520
80006f6e:	d8 32       	popm	r0-r7,pc
80006f70:	80 00       	ld.sh	r0,r0[0x0]
80006f72:	77 ec       	ld.w	r12,r11[0x78]
80006f74:	00 00       	add	r0,r0
80006f76:	0d 5c       	ld.sh	r12,--r6
80006f78:	80 00       	ld.sh	r0,r0[0x0]
80006f7a:	d8 00       	acall	0x80
80006f7c:	80 00       	ld.sh	r0,r0[0x0]
80006f7e:	6d 4e       	ld.w	lr,r6[0x50]
80006f80:	80 00       	ld.sh	r0,r0[0x0]
80006f82:	da ac       	*unknown*
80006f84:	80 00       	ld.sh	r0,r0[0x0]
80006f86:	6e 28       	ld.w	r8,r7[0x8]
80006f88:	80 00       	ld.sh	r0,r0[0x0]
80006f8a:	6c 9c       	ld.w	r12,r6[0x24]
80006f8c:	80 00       	ld.sh	r0,r0[0x0]
80006f8e:	6c 98       	ld.w	r8,r6[0x24]
80006f90:	80 00       	ld.sh	r0,r0[0x0]
80006f92:	da bc       	*unknown*
80006f94:	80 00       	ld.sh	r0,r0[0x0]
80006f96:	da cc       	*unknown*
80006f98:	80 00       	ld.sh	r0,r0[0x0]
80006f9a:	7a dc       	ld.w	r12,sp[0x34]
80006f9c:	80 00       	ld.sh	r0,r0[0x0]
80006f9e:	da d4       	*unknown*
80006fa0:	80 00       	ld.sh	r0,r0[0x0]
80006fa2:	da dc       	*unknown*
80006fa4:	80 00       	ld.sh	r0,r0[0x0]
80006fa6:	5e f4       	retal	r4
80006fa8:	80 00       	ld.sh	r0,r0[0x0]
80006faa:	76 a4       	ld.w	r4,r11[0x28]
80006fac:	00 00       	add	r0,r0
80006fae:	5b 68       	cp.w	r8,-10
80006fb0:	80 00       	ld.sh	r0,r0[0x0]
80006fb2:	62 48       	ld.w	r8,r1[0x10]

80006fb4 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006fb4:	d4 31       	pushm	r0-r7,lr
80006fb6:	fa cd 02 0c 	sub	sp,sp,524
80006fba:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006fbc:	e0 6a 01 00 	mov	r10,256
80006fc0:	30 0b       	mov	r11,0
80006fc2:	fa cc fe f4 	sub	r12,sp,-268
80006fc6:	f0 1f 00 4c 	mcall	800070f4 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80006fca:	fa c4 fd d0 	sub	r4,sp,-560
80006fce:	30 0a       	mov	r10,0
80006fd0:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006fd2:	fa c3 ff fc 	sub	r3,sp,-4
80006fd6:	e0 61 01 00 	mov	r1,256
80006fda:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006fdc:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006fde:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006fe2:	02 9a       	mov	r10,r1
80006fe4:	00 9b       	mov	r11,r0
80006fe6:	06 9c       	mov	r12,r3
80006fe8:	f0 1f 00 43 	mcall	800070f4 <logFromISR+0x140>
			
			if(*str == '%')
80006fec:	0f 88       	ld.ub	r8,r7[0x0]
80006fee:	e4 08 18 00 	cp.b	r8,r2
80006ff2:	c5 11       	brne	80007094 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80006ff4:	ee c8 ff ff 	sub	r8,r7,-1
80006ff8:	11 89       	ld.ub	r9,r8[0x0]
80006ffa:	4c 0a       	lddpc	r10,800070f8 <logFromISR+0x144>
80006ffc:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80006ffe:	23 09       	sub	r9,48
80007000:	30 9a       	mov	r10,9
80007002:	f4 09 18 00 	cp.b	r9,r10
80007006:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
8000700a:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000700e:	f7 b9 08 30 	subls	r9,48
80007012:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80007016:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
8000701a:	0f 88       	ld.ub	r8,r7[0x0]
8000701c:	22 58       	sub	r8,37
8000701e:	e0 48 00 53 	cp.w	r8,83
80007022:	e0 8b 00 2b 	brhi	80007078 <logFromISR+0xc4>
80007026:	4b 69       	lddpc	r9,800070fc <logFromISR+0x148>
80007028:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
8000702c:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80007030:	06 9a       	mov	r10,r3
80007032:	40 0b       	lddsp	r11,sp[0x0]
80007034:	5c 5b       	castu.b	r11
80007036:	68 0c       	ld.w	r12,r4[0x0]
80007038:	f0 1f 00 32 	mcall	80007100 <logFromISR+0x14c>
					break;
8000703c:	c2 38       	rjmp	80007082 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
8000703e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80007042:	06 9a       	mov	r10,r3
80007044:	40 0b       	lddsp	r11,sp[0x0]
80007046:	5c 5b       	castu.b	r11
80007048:	68 0c       	ld.w	r12,r4[0x0]
8000704a:	f0 1f 00 2f 	mcall	80007104 <logFromISR+0x150>
8000704e:	06 9c       	mov	r12,r3
					break;
80007050:	c1 98       	rjmp	80007082 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80007052:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80007056:	06 9b       	mov	r11,r3
80007058:	09 bc       	ld.ub	r12,r4[0x3]
8000705a:	f0 1f 00 2c 	mcall	80007108 <logFromISR+0x154>
8000705e:	06 9c       	mov	r12,r3
					break;
80007060:	c1 18       	rjmp	80007082 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80007062:	e8 c5 ff fc 	sub	r5,r4,-4
80007066:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80007068:	c0 d8       	rjmp	80007082 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
8000706a:	06 9b       	mov	r11,r3
8000706c:	32 5c       	mov	r12,37
8000706e:	f0 1f 00 27 	mcall	80007108 <logFromISR+0x154>
80007072:	08 95       	mov	r5,r4
80007074:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80007076:	c0 68       	rjmp	80007082 <logFromISR+0xce>
					default:
					log("I need relax.");
80007078:	4a 5c       	lddpc	r12,8000710c <logFromISR+0x158>
8000707a:	f0 1f 00 26 	mcall	80007110 <logFromISR+0x15c>
8000707e:	08 95       	mov	r5,r4
80007080:	06 9c       	mov	r12,r3
				}
				str++;
80007082:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80007084:	1a dc       	st.w	--sp,r12
80007086:	1a d6       	st.w	--sp,r6
80007088:	4a 3b       	lddpc	r11,80007114 <logFromISR+0x160>
8000708a:	0c 9c       	mov	r12,r6
8000708c:	f0 1f 00 23 	mcall	80007118 <logFromISR+0x164>
80007090:	2f ed       	sub	sp,-8
80007092:	c0 a8       	rjmp	800070a6 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007094:	2f f7       	sub	r7,-1
80007096:	1a d8       	st.w	--sp,r8
80007098:	1a d6       	st.w	--sp,r6
8000709a:	4a 1b       	lddpc	r11,8000711c <logFromISR+0x168>
8000709c:	0c 9c       	mov	r12,r6
8000709e:	f0 1f 00 1f 	mcall	80007118 <logFromISR+0x164>
800070a2:	08 95       	mov	r5,r4
800070a4:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
800070a6:	0f 89       	ld.ub	r9,r7[0x0]
800070a8:	30 08       	mov	r8,0
800070aa:	f0 09 18 00 	cp.b	r9,r8
800070ae:	c0 30       	breq	800070b4 <logFromISR+0x100>
800070b0:	0a 94       	mov	r4,r5
800070b2:	c9 8b       	rjmp	80006fe2 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
800070b4:	fa c7 fe f4 	sub	r7,sp,-268
800070b8:	1a d7       	st.w	--sp,r7
800070ba:	49 ab       	lddpc	r11,80007120 <logFromISR+0x16c>
800070bc:	0e 9c       	mov	r12,r7
800070be:	f0 1f 00 17 	mcall	80007118 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
800070c2:	5c 5c       	castu.b	r12
800070c4:	f8 c6 ff ff 	sub	r6,r12,-1
800070c8:	0c 9c       	mov	r12,r6
800070ca:	f0 1f 00 17 	mcall	80007124 <logFromISR+0x170>
800070ce:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
800070d0:	0c 9a       	mov	r10,r6
800070d2:	0e 9b       	mov	r11,r7
800070d4:	f0 1f 00 15 	mcall	80007128 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800070d8:	30 09       	mov	r9,0
800070da:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
800070dc:	fa ca fe f8 	sub	r10,sp,-264
800070e0:	fa cb fe f4 	sub	r11,sp,-268
800070e4:	49 28       	lddpc	r8,8000712c <logFromISR+0x178>
800070e6:	70 0c       	ld.w	r12,r8[0x0]
800070e8:	f0 1f 00 12 	mcall	80007130 <logFromISR+0x17c>
800070ec:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
800070ee:	fe 3d fd f4 	sub	sp,-524
800070f2:	d8 32       	popm	r0-r7,pc
800070f4:	80 00       	ld.sh	r0,r0[0x0]
800070f6:	77 ec       	ld.w	r12,r11[0x78]
800070f8:	00 00       	add	r0,r0
800070fa:	0d 5d       	ld.sh	sp,--r6
800070fc:	80 00       	ld.sh	r0,r0[0x0]
800070fe:	d9 50       	acall	0x95
80007100:	80 00       	ld.sh	r0,r0[0x0]
80007102:	6d 4e       	ld.w	lr,r6[0x50]
80007104:	80 00       	ld.sh	r0,r0[0x0]
80007106:	6c 9c       	ld.w	r12,r6[0x24]
80007108:	80 00       	ld.sh	r0,r0[0x0]
8000710a:	6c 98       	ld.w	r8,r6[0x24]
8000710c:	80 00       	ld.sh	r0,r0[0x0]
8000710e:	da bc       	*unknown*
80007110:	80 00       	ld.sh	r0,r0[0x0]
80007112:	6e 28       	ld.w	r8,r7[0x8]
80007114:	80 00       	ld.sh	r0,r0[0x0]
80007116:	da cc       	*unknown*
80007118:	80 00       	ld.sh	r0,r0[0x0]
8000711a:	7a dc       	ld.w	r12,sp[0x34]
8000711c:	80 00       	ld.sh	r0,r0[0x0]
8000711e:	da d4       	*unknown*
80007120:	80 00       	ld.sh	r0,r0[0x0]
80007122:	da dc       	*unknown*
80007124:	80 00       	ld.sh	r0,r0[0x0]
80007126:	5e f4       	retal	r4
80007128:	80 00       	ld.sh	r0,r0[0x0]
8000712a:	76 a4       	ld.w	r4,r11[0x28]
8000712c:	00 00       	add	r0,r0
8000712e:	5b 68       	cp.w	r8,-10
80007130:	80 00       	ld.sh	r0,r0[0x0]
80007132:	61 f8       	ld.w	r8,r0[0x7c]

80007134 <log_init>:
		
	return str;
}

void log_init(void)
{
80007134:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80007136:	30 2b       	mov	r11,2
80007138:	48 fc       	lddpc	r12,80007174 <log_init+0x40>
8000713a:	f0 1f 00 10 	mcall	80007178 <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
8000713e:	e0 6a 36 00 	mov	r10,13824
80007142:	ea 1a 01 6e 	orh	r10,0x16e
80007146:	48 eb       	lddpc	r11,8000717c <log_init+0x48>
80007148:	fe 7c 18 00 	mov	r12,-59392
8000714c:	f0 1f 00 0d 	mcall	80007180 <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80007150:	30 4b       	mov	r11,4
80007152:	33 2c       	mov	r12,50
80007154:	f0 1f 00 0c 	mcall	80007184 <log_init+0x50>
80007158:	48 c8       	lddpc	r8,80007188 <log_init+0x54>
8000715a:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
8000715c:	30 09       	mov	r9,0
8000715e:	1a d9       	st.w	--sp,r9
80007160:	1a d9       	st.w	--sp,r9
80007162:	1a d9       	st.w	--sp,r9
80007164:	30 28       	mov	r8,2
80007166:	36 4a       	mov	r10,100
80007168:	48 9b       	lddpc	r11,8000718c <log_init+0x58>
8000716a:	48 ac       	lddpc	r12,80007190 <log_init+0x5c>
8000716c:	f0 1f 00 0a 	mcall	80007194 <log_init+0x60>
80007170:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80007172:	d8 02       	popm	pc
80007174:	80 00       	ld.sh	r0,r0[0x0]
80007176:	da e8       	*unknown*
80007178:	80 00       	ld.sh	r0,r0[0x0]
8000717a:	53 d4       	stdsp	sp[0xf4],r4
8000717c:	80 00       	ld.sh	r0,r0[0x0]
8000717e:	da a0       	acall	0xaa
80007180:	80 00       	ld.sh	r0,r0[0x0]
80007182:	5a 58       	cp.w	r8,-27
80007184:	80 00       	ld.sh	r0,r0[0x0]
80007186:	63 48       	ld.w	r8,r1[0x50]
80007188:	00 00       	add	r0,r0
8000718a:	5b 68       	cp.w	r8,-10
8000718c:	80 00       	ld.sh	r0,r0[0x0]
8000718e:	da e4       	*unknown*
80007190:	80 00       	ld.sh	r0,r0[0x0]
80007192:	71 98       	ld.w	r8,r8[0x64]
80007194:	80 00       	ld.sh	r0,r0[0x0]
80007196:	6a 64       	ld.w	r4,r5[0x18]

80007198 <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
80007198:	eb cd 40 f8 	pushm	r3-r7,lr
8000719c:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000719e:	48 c7       	lddpc	r7,800071cc <task_log+0x34>
800071a0:	30 05       	mov	r5,0
800071a2:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
800071a4:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800071a8:	0a 99       	mov	r9,r5
800071aa:	08 9a       	mov	r10,r4
800071ac:	1a 9b       	mov	r11,sp
800071ae:	6e 0c       	ld.w	r12,r7[0x0]
800071b0:	f0 1f 00 08 	mcall	800071d0 <task_log+0x38>
800071b4:	58 1c       	cp.w	r12,1
800071b6:	cf 91       	brne	800071a8 <task_log+0x10>
		{
			if( NULL != str)
800071b8:	40 0b       	lddsp	r11,sp[0x0]
800071ba:	58 0b       	cp.w	r11,0
800071bc:	cf 60       	breq	800071a8 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
800071be:	06 9c       	mov	r12,r3
800071c0:	f0 1f 00 05 	mcall	800071d4 <task_log+0x3c>
				vPortFree(str);
800071c4:	40 0c       	lddsp	r12,sp[0x0]
800071c6:	f0 1f 00 05 	mcall	800071d8 <task_log+0x40>
800071ca:	ce fb       	rjmp	800071a8 <task_log+0x10>
800071cc:	00 00       	add	r0,r0
800071ce:	5b 68       	cp.w	r8,-10
800071d0:	80 00       	ld.sh	r0,r0[0x0]
800071d2:	60 3c       	ld.w	r12,r0[0xc]
800071d4:	80 00       	ld.sh	r0,r0[0x0]
800071d6:	5a 08       	cp.w	r8,-32
800071d8:	80 00       	ld.sh	r0,r0[0x0]
800071da:	5e cc       	retvs	r12

800071dc <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
800071dc:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
800071de:	fe 78 10 00 	mov	r8,-61440
800071e2:	30 19       	mov	r9,1
800071e4:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
800071e8:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
800071ec:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
800071f0:	d3 03       	ssrf	0x10
	local_start_pll0();
800071f2:	f0 1f 00 0c 	mcall	80007220 <main+0x44>
		
	INTC_init_interrupts();
800071f6:	f0 1f 00 0c 	mcall	80007224 <main+0x48>
		
	log_init();
800071fa:	f0 1f 00 0c 	mcall	80007228 <main+0x4c>
	log("----start debug----");
800071fe:	48 cc       	lddpc	r12,8000722c <main+0x50>
80007200:	f0 1f 00 0c 	mcall	80007230 <main+0x54>
	
	xg_flashc_init();
80007204:	f0 1f 00 0c 	mcall	80007234 <main+0x58>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
80007208:	f0 1f 00 0c 	mcall	80007238 <main+0x5c>
		
	app_init();
8000720c:	f0 1f 00 0c 	mcall	8000723c <main+0x60>
	
	//xg_rtc_init();
		
	xcmp_init();
80007210:	f0 1f 00 0c 	mcall	80007240 <main+0x64>

	local_start_timer();
80007214:	f0 1f 00 0c 	mcall	80007244 <main+0x68>
		
	vTaskStartScheduler();
80007218:	f0 1f 00 0c 	mcall	80007248 <main+0x6c>
	return 0;
	
}
8000721c:	d8 0a       	popm	pc,r12=0
8000721e:	00 00       	add	r0,r0
80007220:	80 00       	ld.sh	r0,r0[0x0]
80007222:	52 54       	stdsp	sp[0x94],r4
80007224:	80 00       	ld.sh	r0,r0[0x0]
80007226:	54 d8       	stdsp	sp[0x134],r8
80007228:	80 00       	ld.sh	r0,r0[0x0]
8000722a:	71 34       	ld.w	r4,r8[0x4c]
8000722c:	80 00       	ld.sh	r0,r0[0x0]
8000722e:	da f8       	*unknown*
80007230:	80 00       	ld.sh	r0,r0[0x0]
80007232:	6e 28       	ld.w	r8,r7[0x8]
80007234:	80 00       	ld.sh	r0,r0[0x0]
80007236:	52 e8       	stdsp	sp[0xb8],r8
80007238:	80 00       	ld.sh	r0,r0[0x0]
8000723a:	51 b4       	stdsp	sp[0x6c],r4
8000723c:	80 00       	ld.sh	r0,r0[0x0]
8000723e:	20 3c       	sub	r12,3
80007240:	80 00       	ld.sh	r0,r0[0x0]
80007242:	3f e8       	mov	r8,-2
80007244:	80 00       	ld.sh	r0,r0[0x0]
80007246:	52 28       	stdsp	sp[0x88],r8
80007248:	80 00       	ld.sh	r0,r0[0x0]
8000724a:	6c 4c       	ld.w	r12,r6[0x10]

8000724c <free>:
8000724c:	d4 01       	pushm	lr
8000724e:	e0 68 0a 3c 	mov	r8,2620
80007252:	18 9b       	mov	r11,r12
80007254:	70 0c       	ld.w	r12,r8[0x0]
80007256:	e0 a0 1e 61 	rcall	8000af18 <_free_r>
8000725a:	d8 02       	popm	pc

8000725c <malloc>:
8000725c:	d4 01       	pushm	lr
8000725e:	e0 68 0a 3c 	mov	r8,2620
80007262:	18 9b       	mov	r11,r12
80007264:	70 0c       	ld.w	r12,r8[0x0]
80007266:	c0 3c       	rcall	8000726c <_malloc_r>
80007268:	d8 02       	popm	pc
8000726a:	d7 03       	nop

8000726c <_malloc_r>:
8000726c:	d4 31       	pushm	r0-r7,lr
8000726e:	f6 c8 ff f5 	sub	r8,r11,-11
80007272:	18 95       	mov	r5,r12
80007274:	10 97       	mov	r7,r8
80007276:	e0 17 ff f8 	andl	r7,0xfff8
8000727a:	59 68       	cp.w	r8,22
8000727c:	f9 b7 08 10 	movls	r7,16
80007280:	16 37       	cp.w	r7,r11
80007282:	5f 38       	srlo	r8
80007284:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80007288:	c0 50       	breq	80007292 <_malloc_r+0x26>
8000728a:	30 c8       	mov	r8,12
8000728c:	99 38       	st.w	r12[0xc],r8
8000728e:	e0 8f 01 fa 	bral	80007682 <_malloc_r+0x416>
80007292:	fe b0 f5 d3 	rcall	80005e38 <__malloc_lock>
80007296:	e0 47 01 f7 	cp.w	r7,503
8000729a:	e0 8b 00 1d 	brhi	800072d4 <_malloc_r+0x68>
8000729e:	ee 03 16 03 	lsr	r3,r7,0x3
800072a2:	e0 68 05 3c 	mov	r8,1340
800072a6:	f0 03 00 38 	add	r8,r8,r3<<0x3
800072aa:	70 36       	ld.w	r6,r8[0xc]
800072ac:	10 36       	cp.w	r6,r8
800072ae:	c0 61       	brne	800072ba <_malloc_r+0x4e>
800072b0:	ec c8 ff f8 	sub	r8,r6,-8
800072b4:	70 36       	ld.w	r6,r8[0xc]
800072b6:	10 36       	cp.w	r6,r8
800072b8:	c0 c0       	breq	800072d0 <_malloc_r+0x64>
800072ba:	6c 18       	ld.w	r8,r6[0x4]
800072bc:	e0 18 ff fc 	andl	r8,0xfffc
800072c0:	6c 3a       	ld.w	r10,r6[0xc]
800072c2:	ec 08 00 09 	add	r9,r6,r8
800072c6:	0a 9c       	mov	r12,r5
800072c8:	6c 28       	ld.w	r8,r6[0x8]
800072ca:	95 28       	st.w	r10[0x8],r8
800072cc:	91 3a       	st.w	r8[0xc],r10
800072ce:	c4 78       	rjmp	8000735c <_malloc_r+0xf0>
800072d0:	2f e3       	sub	r3,-2
800072d2:	c4 d8       	rjmp	8000736c <_malloc_r+0x100>
800072d4:	ee 03 16 09 	lsr	r3,r7,0x9
800072d8:	c0 41       	brne	800072e0 <_malloc_r+0x74>
800072da:	ee 03 16 03 	lsr	r3,r7,0x3
800072de:	c2 68       	rjmp	8000732a <_malloc_r+0xbe>
800072e0:	58 43       	cp.w	r3,4
800072e2:	e0 8b 00 06 	brhi	800072ee <_malloc_r+0x82>
800072e6:	ee 03 16 06 	lsr	r3,r7,0x6
800072ea:	2c 83       	sub	r3,-56
800072ec:	c1 f8       	rjmp	8000732a <_malloc_r+0xbe>
800072ee:	59 43       	cp.w	r3,20
800072f0:	e0 8b 00 04 	brhi	800072f8 <_malloc_r+0x8c>
800072f4:	2a 53       	sub	r3,-91
800072f6:	c1 a8       	rjmp	8000732a <_malloc_r+0xbe>
800072f8:	e0 43 00 54 	cp.w	r3,84
800072fc:	e0 8b 00 06 	brhi	80007308 <_malloc_r+0x9c>
80007300:	ee 03 16 0c 	lsr	r3,r7,0xc
80007304:	29 23       	sub	r3,-110
80007306:	c1 28       	rjmp	8000732a <_malloc_r+0xbe>
80007308:	e0 43 01 54 	cp.w	r3,340
8000730c:	e0 8b 00 06 	brhi	80007318 <_malloc_r+0xac>
80007310:	ee 03 16 0f 	lsr	r3,r7,0xf
80007314:	28 93       	sub	r3,-119
80007316:	c0 a8       	rjmp	8000732a <_malloc_r+0xbe>
80007318:	e0 43 05 54 	cp.w	r3,1364
8000731c:	e0 88 00 04 	brls	80007324 <_malloc_r+0xb8>
80007320:	37 e3       	mov	r3,126
80007322:	c0 48       	rjmp	8000732a <_malloc_r+0xbe>
80007324:	ee 03 16 12 	lsr	r3,r7,0x12
80007328:	28 43       	sub	r3,-124
8000732a:	e0 6a 05 3c 	mov	r10,1340
8000732e:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80007332:	74 36       	ld.w	r6,r10[0xc]
80007334:	c1 98       	rjmp	80007366 <_malloc_r+0xfa>
80007336:	6c 19       	ld.w	r9,r6[0x4]
80007338:	e0 19 ff fc 	andl	r9,0xfffc
8000733c:	f2 07 01 0b 	sub	r11,r9,r7
80007340:	58 fb       	cp.w	r11,15
80007342:	e0 8a 00 04 	brle	8000734a <_malloc_r+0xde>
80007346:	20 13       	sub	r3,1
80007348:	c1 18       	rjmp	8000736a <_malloc_r+0xfe>
8000734a:	6c 38       	ld.w	r8,r6[0xc]
8000734c:	58 0b       	cp.w	r11,0
8000734e:	c0 b5       	brlt	80007364 <_malloc_r+0xf8>
80007350:	6c 2a       	ld.w	r10,r6[0x8]
80007352:	ec 09 00 09 	add	r9,r6,r9
80007356:	0a 9c       	mov	r12,r5
80007358:	91 2a       	st.w	r8[0x8],r10
8000735a:	95 38       	st.w	r10[0xc],r8
8000735c:	72 18       	ld.w	r8,r9[0x4]
8000735e:	a1 a8       	sbr	r8,0x0
80007360:	93 18       	st.w	r9[0x4],r8
80007362:	cb c8       	rjmp	800074da <_malloc_r+0x26e>
80007364:	10 96       	mov	r6,r8
80007366:	14 36       	cp.w	r6,r10
80007368:	ce 71       	brne	80007336 <_malloc_r+0xca>
8000736a:	2f f3       	sub	r3,-1
8000736c:	e0 6a 05 3c 	mov	r10,1340
80007370:	f4 cc ff f8 	sub	r12,r10,-8
80007374:	78 26       	ld.w	r6,r12[0x8]
80007376:	18 36       	cp.w	r6,r12
80007378:	c6 c0       	breq	80007450 <_malloc_r+0x1e4>
8000737a:	6c 19       	ld.w	r9,r6[0x4]
8000737c:	e0 19 ff fc 	andl	r9,0xfffc
80007380:	f2 07 01 08 	sub	r8,r9,r7
80007384:	58 f8       	cp.w	r8,15
80007386:	e0 89 00 8f 	brgt	800074a4 <_malloc_r+0x238>
8000738a:	99 3c       	st.w	r12[0xc],r12
8000738c:	99 2c       	st.w	r12[0x8],r12
8000738e:	58 08       	cp.w	r8,0
80007390:	c0 55       	brlt	8000739a <_malloc_r+0x12e>
80007392:	ec 09 00 09 	add	r9,r6,r9
80007396:	0a 9c       	mov	r12,r5
80007398:	ce 2b       	rjmp	8000735c <_malloc_r+0xf0>
8000739a:	e0 49 01 ff 	cp.w	r9,511
8000739e:	e0 8b 00 13 	brhi	800073c4 <_malloc_r+0x158>
800073a2:	a3 99       	lsr	r9,0x3
800073a4:	f4 09 00 38 	add	r8,r10,r9<<0x3
800073a8:	70 2b       	ld.w	r11,r8[0x8]
800073aa:	8d 38       	st.w	r6[0xc],r8
800073ac:	8d 2b       	st.w	r6[0x8],r11
800073ae:	97 36       	st.w	r11[0xc],r6
800073b0:	91 26       	st.w	r8[0x8],r6
800073b2:	a3 49       	asr	r9,0x2
800073b4:	74 18       	ld.w	r8,r10[0x4]
800073b6:	30 1b       	mov	r11,1
800073b8:	f6 09 09 49 	lsl	r9,r11,r9
800073bc:	f1 e9 10 09 	or	r9,r8,r9
800073c0:	95 19       	st.w	r10[0x4],r9
800073c2:	c4 78       	rjmp	80007450 <_malloc_r+0x1e4>
800073c4:	f2 0a 16 09 	lsr	r10,r9,0x9
800073c8:	58 4a       	cp.w	r10,4
800073ca:	e0 8b 00 07 	brhi	800073d8 <_malloc_r+0x16c>
800073ce:	f2 0a 16 06 	lsr	r10,r9,0x6
800073d2:	2c 8a       	sub	r10,-56
800073d4:	c2 08       	rjmp	80007414 <_malloc_r+0x1a8>
800073d6:	d7 03       	nop
800073d8:	59 4a       	cp.w	r10,20
800073da:	e0 8b 00 04 	brhi	800073e2 <_malloc_r+0x176>
800073de:	2a 5a       	sub	r10,-91
800073e0:	c1 a8       	rjmp	80007414 <_malloc_r+0x1a8>
800073e2:	e0 4a 00 54 	cp.w	r10,84
800073e6:	e0 8b 00 06 	brhi	800073f2 <_malloc_r+0x186>
800073ea:	f2 0a 16 0c 	lsr	r10,r9,0xc
800073ee:	29 2a       	sub	r10,-110
800073f0:	c1 28       	rjmp	80007414 <_malloc_r+0x1a8>
800073f2:	e0 4a 01 54 	cp.w	r10,340
800073f6:	e0 8b 00 06 	brhi	80007402 <_malloc_r+0x196>
800073fa:	f2 0a 16 0f 	lsr	r10,r9,0xf
800073fe:	28 9a       	sub	r10,-119
80007400:	c0 a8       	rjmp	80007414 <_malloc_r+0x1a8>
80007402:	e0 4a 05 54 	cp.w	r10,1364
80007406:	e0 88 00 04 	brls	8000740e <_malloc_r+0x1a2>
8000740a:	37 ea       	mov	r10,126
8000740c:	c0 48       	rjmp	80007414 <_malloc_r+0x1a8>
8000740e:	f2 0a 16 12 	lsr	r10,r9,0x12
80007412:	28 4a       	sub	r10,-124
80007414:	e0 6b 05 3c 	mov	r11,1340
80007418:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000741c:	68 28       	ld.w	r8,r4[0x8]
8000741e:	08 38       	cp.w	r8,r4
80007420:	c0 e1       	brne	8000743c <_malloc_r+0x1d0>
80007422:	76 19       	ld.w	r9,r11[0x4]
80007424:	a3 4a       	asr	r10,0x2
80007426:	30 1e       	mov	lr,1
80007428:	fc 0a 09 4a 	lsl	r10,lr,r10
8000742c:	f3 ea 10 0a 	or	r10,r9,r10
80007430:	10 99       	mov	r9,r8
80007432:	97 1a       	st.w	r11[0x4],r10
80007434:	c0 a8       	rjmp	80007448 <_malloc_r+0x1dc>
80007436:	70 28       	ld.w	r8,r8[0x8]
80007438:	08 38       	cp.w	r8,r4
8000743a:	c0 60       	breq	80007446 <_malloc_r+0x1da>
8000743c:	70 1a       	ld.w	r10,r8[0x4]
8000743e:	e0 1a ff fc 	andl	r10,0xfffc
80007442:	14 39       	cp.w	r9,r10
80007444:	cf 93       	brcs	80007436 <_malloc_r+0x1ca>
80007446:	70 39       	ld.w	r9,r8[0xc]
80007448:	8d 39       	st.w	r6[0xc],r9
8000744a:	8d 28       	st.w	r6[0x8],r8
8000744c:	91 36       	st.w	r8[0xc],r6
8000744e:	93 26       	st.w	r9[0x8],r6
80007450:	e6 08 14 02 	asr	r8,r3,0x2
80007454:	30 1b       	mov	r11,1
80007456:	e0 64 05 3c 	mov	r4,1340
8000745a:	f6 08 09 4b 	lsl	r11,r11,r8
8000745e:	68 18       	ld.w	r8,r4[0x4]
80007460:	10 3b       	cp.w	r11,r8
80007462:	e0 8b 00 6b 	brhi	80007538 <_malloc_r+0x2cc>
80007466:	f7 e8 00 09 	and	r9,r11,r8
8000746a:	c0 b1       	brne	80007480 <_malloc_r+0x214>
8000746c:	e0 13 ff fc 	andl	r3,0xfffc
80007470:	a1 7b       	lsl	r11,0x1
80007472:	2f c3       	sub	r3,-4
80007474:	c0 38       	rjmp	8000747a <_malloc_r+0x20e>
80007476:	2f c3       	sub	r3,-4
80007478:	a1 7b       	lsl	r11,0x1
8000747a:	f7 e8 00 09 	and	r9,r11,r8
8000747e:	cf c0       	breq	80007476 <_malloc_r+0x20a>
80007480:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80007484:	06 92       	mov	r2,r3
80007486:	1c 91       	mov	r1,lr
80007488:	62 36       	ld.w	r6,r1[0xc]
8000748a:	c2 e8       	rjmp	800074e6 <_malloc_r+0x27a>
8000748c:	6c 1a       	ld.w	r10,r6[0x4]
8000748e:	e0 1a ff fc 	andl	r10,0xfffc
80007492:	f4 07 01 08 	sub	r8,r10,r7
80007496:	58 f8       	cp.w	r8,15
80007498:	e0 8a 00 15 	brle	800074c2 <_malloc_r+0x256>
8000749c:	6c 3a       	ld.w	r10,r6[0xc]
8000749e:	6c 29       	ld.w	r9,r6[0x8]
800074a0:	95 29       	st.w	r10[0x8],r9
800074a2:	93 3a       	st.w	r9[0xc],r10
800074a4:	0e 99       	mov	r9,r7
800074a6:	ec 07 00 07 	add	r7,r6,r7
800074aa:	a1 a9       	sbr	r9,0x0
800074ac:	99 37       	st.w	r12[0xc],r7
800074ae:	99 27       	st.w	r12[0x8],r7
800074b0:	8d 19       	st.w	r6[0x4],r9
800074b2:	ee 08 09 08 	st.w	r7[r8],r8
800074b6:	8f 2c       	st.w	r7[0x8],r12
800074b8:	8f 3c       	st.w	r7[0xc],r12
800074ba:	a1 a8       	sbr	r8,0x0
800074bc:	0a 9c       	mov	r12,r5
800074be:	8f 18       	st.w	r7[0x4],r8
800074c0:	c0 d8       	rjmp	800074da <_malloc_r+0x26e>
800074c2:	6c 39       	ld.w	r9,r6[0xc]
800074c4:	58 08       	cp.w	r8,0
800074c6:	c0 f5       	brlt	800074e4 <_malloc_r+0x278>
800074c8:	ec 0a 00 0a 	add	r10,r6,r10
800074cc:	74 18       	ld.w	r8,r10[0x4]
800074ce:	a1 a8       	sbr	r8,0x0
800074d0:	0a 9c       	mov	r12,r5
800074d2:	95 18       	st.w	r10[0x4],r8
800074d4:	6c 28       	ld.w	r8,r6[0x8]
800074d6:	93 28       	st.w	r9[0x8],r8
800074d8:	91 39       	st.w	r8[0xc],r9
800074da:	fe b0 f4 b5 	rcall	80005e44 <__malloc_unlock>
800074de:	ec cc ff f8 	sub	r12,r6,-8
800074e2:	d8 32       	popm	r0-r7,pc
800074e4:	12 96       	mov	r6,r9
800074e6:	02 36       	cp.w	r6,r1
800074e8:	cd 21       	brne	8000748c <_malloc_r+0x220>
800074ea:	2f f2       	sub	r2,-1
800074ec:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800074f0:	c0 30       	breq	800074f6 <_malloc_r+0x28a>
800074f2:	2f 81       	sub	r1,-8
800074f4:	cc ab       	rjmp	80007488 <_malloc_r+0x21c>
800074f6:	1c 98       	mov	r8,lr
800074f8:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
800074fc:	c0 81       	brne	8000750c <_malloc_r+0x2a0>
800074fe:	68 19       	ld.w	r9,r4[0x4]
80007500:	f6 08 11 ff 	rsub	r8,r11,-1
80007504:	f3 e8 00 08 	and	r8,r9,r8
80007508:	89 18       	st.w	r4[0x4],r8
8000750a:	c0 78       	rjmp	80007518 <_malloc_r+0x2ac>
8000750c:	f0 c9 00 08 	sub	r9,r8,8
80007510:	20 13       	sub	r3,1
80007512:	70 08       	ld.w	r8,r8[0x0]
80007514:	12 38       	cp.w	r8,r9
80007516:	cf 10       	breq	800074f8 <_malloc_r+0x28c>
80007518:	a1 7b       	lsl	r11,0x1
8000751a:	68 18       	ld.w	r8,r4[0x4]
8000751c:	10 3b       	cp.w	r11,r8
8000751e:	e0 8b 00 0d 	brhi	80007538 <_malloc_r+0x2cc>
80007522:	58 0b       	cp.w	r11,0
80007524:	c0 a0       	breq	80007538 <_malloc_r+0x2cc>
80007526:	04 93       	mov	r3,r2
80007528:	c0 38       	rjmp	8000752e <_malloc_r+0x2c2>
8000752a:	2f c3       	sub	r3,-4
8000752c:	a1 7b       	lsl	r11,0x1
8000752e:	f7 e8 00 09 	and	r9,r11,r8
80007532:	ca 71       	brne	80007480 <_malloc_r+0x214>
80007534:	cf bb       	rjmp	8000752a <_malloc_r+0x2be>
80007536:	d7 03       	nop
80007538:	68 23       	ld.w	r3,r4[0x8]
8000753a:	66 12       	ld.w	r2,r3[0x4]
8000753c:	e0 12 ff fc 	andl	r2,0xfffc
80007540:	0e 32       	cp.w	r2,r7
80007542:	5f 39       	srlo	r9
80007544:	e4 07 01 08 	sub	r8,r2,r7
80007548:	58 f8       	cp.w	r8,15
8000754a:	5f aa       	srle	r10
8000754c:	f5 e9 10 09 	or	r9,r10,r9
80007550:	e0 80 00 9a 	breq	80007684 <_malloc_r+0x418>
80007554:	e0 68 0d 68 	mov	r8,3432
80007558:	70 01       	ld.w	r1,r8[0x0]
8000755a:	e0 68 09 48 	mov	r8,2376
8000755e:	2f 01       	sub	r1,-16
80007560:	70 08       	ld.w	r8,r8[0x0]
80007562:	0e 01       	add	r1,r7
80007564:	5b f8       	cp.w	r8,-1
80007566:	c0 40       	breq	8000756e <_malloc_r+0x302>
80007568:	28 11       	sub	r1,-127
8000756a:	e0 11 ff 80 	andl	r1,0xff80
8000756e:	02 9b       	mov	r11,r1
80007570:	0a 9c       	mov	r12,r5
80007572:	e0 a0 02 a5 	rcall	80007abc <_sbrk_r>
80007576:	18 96       	mov	r6,r12
80007578:	5b fc       	cp.w	r12,-1
8000757a:	c7 50       	breq	80007664 <_malloc_r+0x3f8>
8000757c:	e6 02 00 08 	add	r8,r3,r2
80007580:	10 3c       	cp.w	r12,r8
80007582:	c0 32       	brcc	80007588 <_malloc_r+0x31c>
80007584:	08 33       	cp.w	r3,r4
80007586:	c6 f1       	brne	80007664 <_malloc_r+0x3f8>
80007588:	e0 6a 0d 6c 	mov	r10,3436
8000758c:	74 09       	ld.w	r9,r10[0x0]
8000758e:	e2 09 00 09 	add	r9,r1,r9
80007592:	95 09       	st.w	r10[0x0],r9
80007594:	10 36       	cp.w	r6,r8
80007596:	c0 a1       	brne	800075aa <_malloc_r+0x33e>
80007598:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000759c:	c0 71       	brne	800075aa <_malloc_r+0x33e>
8000759e:	e2 02 00 02 	add	r2,r1,r2
800075a2:	68 28       	ld.w	r8,r4[0x8]
800075a4:	a1 a2       	sbr	r2,0x0
800075a6:	91 12       	st.w	r8[0x4],r2
800075a8:	c4 f8       	rjmp	80007646 <_malloc_r+0x3da>
800075aa:	e0 6a 09 48 	mov	r10,2376
800075ae:	74 0b       	ld.w	r11,r10[0x0]
800075b0:	5b fb       	cp.w	r11,-1
800075b2:	c0 31       	brne	800075b8 <_malloc_r+0x34c>
800075b4:	95 06       	st.w	r10[0x0],r6
800075b6:	c0 78       	rjmp	800075c4 <_malloc_r+0x358>
800075b8:	ec 09 00 09 	add	r9,r6,r9
800075bc:	e0 6a 0d 6c 	mov	r10,3436
800075c0:	10 19       	sub	r9,r8
800075c2:	95 09       	st.w	r10[0x0],r9
800075c4:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
800075c8:	f0 09 11 08 	rsub	r9,r8,8
800075cc:	58 08       	cp.w	r8,0
800075ce:	f2 08 17 10 	movne	r8,r9
800075d2:	ed d8 e1 06 	addne	r6,r6,r8
800075d6:	28 08       	sub	r8,-128
800075d8:	ec 01 00 01 	add	r1,r6,r1
800075dc:	0a 9c       	mov	r12,r5
800075de:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800075e2:	f0 01 01 01 	sub	r1,r8,r1
800075e6:	02 9b       	mov	r11,r1
800075e8:	e0 a0 02 6a 	rcall	80007abc <_sbrk_r>
800075ec:	e0 68 0d 6c 	mov	r8,3436
800075f0:	5b fc       	cp.w	r12,-1
800075f2:	ec 0c 17 00 	moveq	r12,r6
800075f6:	f9 b1 00 00 	moveq	r1,0
800075fa:	70 09       	ld.w	r9,r8[0x0]
800075fc:	0c 1c       	sub	r12,r6
800075fe:	89 26       	st.w	r4[0x8],r6
80007600:	02 0c       	add	r12,r1
80007602:	12 01       	add	r1,r9
80007604:	a1 ac       	sbr	r12,0x0
80007606:	91 01       	st.w	r8[0x0],r1
80007608:	8d 1c       	st.w	r6[0x4],r12
8000760a:	08 33       	cp.w	r3,r4
8000760c:	c1 d0       	breq	80007646 <_malloc_r+0x3da>
8000760e:	58 f2       	cp.w	r2,15
80007610:	e0 8b 00 05 	brhi	8000761a <_malloc_r+0x3ae>
80007614:	30 18       	mov	r8,1
80007616:	8d 18       	st.w	r6[0x4],r8
80007618:	c2 68       	rjmp	80007664 <_malloc_r+0x3f8>
8000761a:	30 59       	mov	r9,5
8000761c:	20 c2       	sub	r2,12
8000761e:	e0 12 ff f8 	andl	r2,0xfff8
80007622:	e6 02 00 08 	add	r8,r3,r2
80007626:	91 29       	st.w	r8[0x8],r9
80007628:	91 19       	st.w	r8[0x4],r9
8000762a:	66 18       	ld.w	r8,r3[0x4]
8000762c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007630:	e5 e8 10 08 	or	r8,r2,r8
80007634:	87 18       	st.w	r3[0x4],r8
80007636:	58 f2       	cp.w	r2,15
80007638:	e0 88 00 07 	brls	80007646 <_malloc_r+0x3da>
8000763c:	e6 cb ff f8 	sub	r11,r3,-8
80007640:	0a 9c       	mov	r12,r5
80007642:	e0 a0 1c 6b 	rcall	8000af18 <_free_r>
80007646:	e0 69 0d 64 	mov	r9,3428
8000764a:	72 0a       	ld.w	r10,r9[0x0]
8000764c:	e0 68 0d 6c 	mov	r8,3436
80007650:	70 08       	ld.w	r8,r8[0x0]
80007652:	14 38       	cp.w	r8,r10
80007654:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007658:	e0 69 0d 60 	mov	r9,3424
8000765c:	72 0a       	ld.w	r10,r9[0x0]
8000765e:	14 38       	cp.w	r8,r10
80007660:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007664:	68 28       	ld.w	r8,r4[0x8]
80007666:	70 18       	ld.w	r8,r8[0x4]
80007668:	e0 18 ff fc 	andl	r8,0xfffc
8000766c:	0e 38       	cp.w	r8,r7
8000766e:	5f 39       	srlo	r9
80007670:	0e 18       	sub	r8,r7
80007672:	58 f8       	cp.w	r8,15
80007674:	5f aa       	srle	r10
80007676:	f5 e9 10 09 	or	r9,r10,r9
8000767a:	c0 50       	breq	80007684 <_malloc_r+0x418>
8000767c:	0a 9c       	mov	r12,r5
8000767e:	fe b0 f3 e3 	rcall	80005e44 <__malloc_unlock>
80007682:	d8 3a       	popm	r0-r7,pc,r12=0
80007684:	68 26       	ld.w	r6,r4[0x8]
80007686:	a1 a8       	sbr	r8,0x0
80007688:	0e 99       	mov	r9,r7
8000768a:	a1 a9       	sbr	r9,0x0
8000768c:	8d 19       	st.w	r6[0x4],r9
8000768e:	ec 07 00 07 	add	r7,r6,r7
80007692:	0a 9c       	mov	r12,r5
80007694:	89 27       	st.w	r4[0x8],r7
80007696:	8f 18       	st.w	r7[0x4],r8
80007698:	fe b0 f3 d6 	rcall	80005e44 <__malloc_unlock>
8000769c:	ec cc ff f8 	sub	r12,r6,-8
800076a0:	d8 32       	popm	r0-r7,pc
800076a2:	d7 03       	nop

800076a4 <memcpy>:
800076a4:	58 8a       	cp.w	r10,8
800076a6:	c2 f5       	brlt	80007704 <memcpy+0x60>
800076a8:	f9 eb 10 09 	or	r9,r12,r11
800076ac:	e2 19 00 03 	andl	r9,0x3,COH
800076b0:	e0 81 00 97 	brne	800077de <memcpy+0x13a>
800076b4:	e0 4a 00 20 	cp.w	r10,32
800076b8:	c3 b4       	brge	8000772e <memcpy+0x8a>
800076ba:	f4 08 14 02 	asr	r8,r10,0x2
800076be:	f0 09 11 08 	rsub	r9,r8,8
800076c2:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800076c6:	76 69       	ld.w	r9,r11[0x18]
800076c8:	99 69       	st.w	r12[0x18],r9
800076ca:	76 59       	ld.w	r9,r11[0x14]
800076cc:	99 59       	st.w	r12[0x14],r9
800076ce:	76 49       	ld.w	r9,r11[0x10]
800076d0:	99 49       	st.w	r12[0x10],r9
800076d2:	76 39       	ld.w	r9,r11[0xc]
800076d4:	99 39       	st.w	r12[0xc],r9
800076d6:	76 29       	ld.w	r9,r11[0x8]
800076d8:	99 29       	st.w	r12[0x8],r9
800076da:	76 19       	ld.w	r9,r11[0x4]
800076dc:	99 19       	st.w	r12[0x4],r9
800076de:	76 09       	ld.w	r9,r11[0x0]
800076e0:	99 09       	st.w	r12[0x0],r9
800076e2:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800076e6:	f8 08 00 28 	add	r8,r12,r8<<0x2
800076ea:	e0 1a 00 03 	andl	r10,0x3
800076ee:	f4 0a 11 04 	rsub	r10,r10,4
800076f2:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800076f6:	17 a9       	ld.ub	r9,r11[0x2]
800076f8:	b0 a9       	st.b	r8[0x2],r9
800076fa:	17 99       	ld.ub	r9,r11[0x1]
800076fc:	b0 99       	st.b	r8[0x1],r9
800076fe:	17 89       	ld.ub	r9,r11[0x0]
80007700:	b0 89       	st.b	r8[0x0],r9
80007702:	5e fc       	retal	r12
80007704:	f4 0a 11 09 	rsub	r10,r10,9
80007708:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000770c:	17 f9       	ld.ub	r9,r11[0x7]
8000770e:	b8 f9       	st.b	r12[0x7],r9
80007710:	17 e9       	ld.ub	r9,r11[0x6]
80007712:	b8 e9       	st.b	r12[0x6],r9
80007714:	17 d9       	ld.ub	r9,r11[0x5]
80007716:	b8 d9       	st.b	r12[0x5],r9
80007718:	17 c9       	ld.ub	r9,r11[0x4]
8000771a:	b8 c9       	st.b	r12[0x4],r9
8000771c:	17 b9       	ld.ub	r9,r11[0x3]
8000771e:	b8 b9       	st.b	r12[0x3],r9
80007720:	17 a9       	ld.ub	r9,r11[0x2]
80007722:	b8 a9       	st.b	r12[0x2],r9
80007724:	17 99       	ld.ub	r9,r11[0x1]
80007726:	b8 99       	st.b	r12[0x1],r9
80007728:	17 89       	ld.ub	r9,r11[0x0]
8000772a:	b8 89       	st.b	r12[0x0],r9
8000772c:	5e fc       	retal	r12
8000772e:	eb cd 40 c0 	pushm	r6-r7,lr
80007732:	18 99       	mov	r9,r12
80007734:	22 0a       	sub	r10,32
80007736:	b7 07       	ld.d	r6,r11++
80007738:	b3 26       	st.d	r9++,r6
8000773a:	b7 07       	ld.d	r6,r11++
8000773c:	b3 26       	st.d	r9++,r6
8000773e:	b7 07       	ld.d	r6,r11++
80007740:	b3 26       	st.d	r9++,r6
80007742:	b7 07       	ld.d	r6,r11++
80007744:	b3 26       	st.d	r9++,r6
80007746:	22 0a       	sub	r10,32
80007748:	cf 74       	brge	80007736 <memcpy+0x92>
8000774a:	2f 0a       	sub	r10,-16
8000774c:	c0 65       	brlt	80007758 <memcpy+0xb4>
8000774e:	b7 07       	ld.d	r6,r11++
80007750:	b3 26       	st.d	r9++,r6
80007752:	b7 07       	ld.d	r6,r11++
80007754:	b3 26       	st.d	r9++,r6
80007756:	21 0a       	sub	r10,16
80007758:	5c 3a       	neg	r10
8000775a:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000775e:	d7 03       	nop
80007760:	d7 03       	nop
80007762:	f7 36 00 0e 	ld.ub	r6,r11[14]
80007766:	f3 66 00 0e 	st.b	r9[14],r6
8000776a:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000776e:	f3 66 00 0d 	st.b	r9[13],r6
80007772:	f7 36 00 0c 	ld.ub	r6,r11[12]
80007776:	f3 66 00 0c 	st.b	r9[12],r6
8000777a:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000777e:	f3 66 00 0b 	st.b	r9[11],r6
80007782:	f7 36 00 0a 	ld.ub	r6,r11[10]
80007786:	f3 66 00 0a 	st.b	r9[10],r6
8000778a:	f7 36 00 09 	ld.ub	r6,r11[9]
8000778e:	f3 66 00 09 	st.b	r9[9],r6
80007792:	f7 36 00 08 	ld.ub	r6,r11[8]
80007796:	f3 66 00 08 	st.b	r9[8],r6
8000779a:	f7 36 00 07 	ld.ub	r6,r11[7]
8000779e:	f3 66 00 07 	st.b	r9[7],r6
800077a2:	f7 36 00 06 	ld.ub	r6,r11[6]
800077a6:	f3 66 00 06 	st.b	r9[6],r6
800077aa:	f7 36 00 05 	ld.ub	r6,r11[5]
800077ae:	f3 66 00 05 	st.b	r9[5],r6
800077b2:	f7 36 00 04 	ld.ub	r6,r11[4]
800077b6:	f3 66 00 04 	st.b	r9[4],r6
800077ba:	f7 36 00 03 	ld.ub	r6,r11[3]
800077be:	f3 66 00 03 	st.b	r9[3],r6
800077c2:	f7 36 00 02 	ld.ub	r6,r11[2]
800077c6:	f3 66 00 02 	st.b	r9[2],r6
800077ca:	f7 36 00 01 	ld.ub	r6,r11[1]
800077ce:	f3 66 00 01 	st.b	r9[1],r6
800077d2:	f7 36 00 00 	ld.ub	r6,r11[0]
800077d6:	f3 66 00 00 	st.b	r9[0],r6
800077da:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800077de:	20 1a       	sub	r10,1
800077e0:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800077e4:	f8 0a 0b 09 	st.b	r12[r10],r9
800077e8:	cf b1       	brne	800077de <memcpy+0x13a>
800077ea:	5e fc       	retal	r12

800077ec <memset>:
800077ec:	18 98       	mov	r8,r12
800077ee:	c0 38       	rjmp	800077f4 <memset+0x8>
800077f0:	10 cb       	st.b	r8++,r11
800077f2:	20 1a       	sub	r10,1
800077f4:	58 0a       	cp.w	r10,0
800077f6:	cf d1       	brne	800077f0 <memset+0x4>
800077f8:	5e fc       	retal	r12
800077fa:	d7 03       	nop

800077fc <_realloc_r>:
800077fc:	d4 31       	pushm	r0-r7,lr
800077fe:	20 1d       	sub	sp,4
80007800:	16 94       	mov	r4,r11
80007802:	18 92       	mov	r2,r12
80007804:	14 9b       	mov	r11,r10
80007806:	58 04       	cp.w	r4,0
80007808:	c0 51       	brne	80007812 <_realloc_r+0x16>
8000780a:	fe b0 fd 31 	rcall	8000726c <_malloc_r>
8000780e:	18 95       	mov	r5,r12
80007810:	c5 39       	rjmp	80007ab6 <_realloc_r+0x2ba>
80007812:	50 0a       	stdsp	sp[0x0],r10
80007814:	fe b0 f3 12 	rcall	80005e38 <__malloc_lock>
80007818:	40 0b       	lddsp	r11,sp[0x0]
8000781a:	f6 c8 ff f5 	sub	r8,r11,-11
8000781e:	e8 c1 00 08 	sub	r1,r4,8
80007822:	10 96       	mov	r6,r8
80007824:	62 1c       	ld.w	r12,r1[0x4]
80007826:	e0 16 ff f8 	andl	r6,0xfff8
8000782a:	59 68       	cp.w	r8,22
8000782c:	f9 b6 08 10 	movls	r6,16
80007830:	16 36       	cp.w	r6,r11
80007832:	5f 38       	srlo	r8
80007834:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80007838:	c0 50       	breq	80007842 <_realloc_r+0x46>
8000783a:	30 c8       	mov	r8,12
8000783c:	30 05       	mov	r5,0
8000783e:	85 38       	st.w	r2[0xc],r8
80007840:	c3 b9       	rjmp	80007ab6 <_realloc_r+0x2ba>
80007842:	18 90       	mov	r0,r12
80007844:	e0 10 ff fc 	andl	r0,0xfffc
80007848:	0c 30       	cp.w	r0,r6
8000784a:	e0 84 01 0b 	brge	80007a60 <_realloc_r+0x264>
8000784e:	e0 68 05 3c 	mov	r8,1340
80007852:	e2 00 00 09 	add	r9,r1,r0
80007856:	70 25       	ld.w	r5,r8[0x8]
80007858:	0a 39       	cp.w	r9,r5
8000785a:	c0 90       	breq	8000786c <_realloc_r+0x70>
8000785c:	72 1a       	ld.w	r10,r9[0x4]
8000785e:	a1 ca       	cbr	r10,0x0
80007860:	f2 0a 00 0a 	add	r10,r9,r10
80007864:	74 1a       	ld.w	r10,r10[0x4]
80007866:	ed ba 00 00 	bld	r10,0x0
8000786a:	c2 20       	breq	800078ae <_realloc_r+0xb2>
8000786c:	72 1a       	ld.w	r10,r9[0x4]
8000786e:	e0 1a ff fc 	andl	r10,0xfffc
80007872:	f4 00 00 03 	add	r3,r10,r0
80007876:	0a 39       	cp.w	r9,r5
80007878:	c1 31       	brne	8000789e <_realloc_r+0xa2>
8000787a:	ec c7 ff f0 	sub	r7,r6,-16
8000787e:	0e 33       	cp.w	r3,r7
80007880:	c1 95       	brlt	800078b2 <_realloc_r+0xb6>
80007882:	e2 06 00 09 	add	r9,r1,r6
80007886:	0c 13       	sub	r3,r6
80007888:	a1 a3       	sbr	r3,0x0
8000788a:	93 13       	st.w	r9[0x4],r3
8000788c:	91 29       	st.w	r8[0x8],r9
8000788e:	04 9c       	mov	r12,r2
80007890:	62 18       	ld.w	r8,r1[0x4]
80007892:	08 95       	mov	r5,r4
80007894:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007898:	10 46       	or	r6,r8
8000789a:	83 16       	st.w	r1[0x4],r6
8000789c:	c0 b9       	rjmp	80007ab2 <_realloc_r+0x2b6>
8000789e:	0c 33       	cp.w	r3,r6
800078a0:	c0 95       	brlt	800078b2 <_realloc_r+0xb6>
800078a2:	72 28       	ld.w	r8,r9[0x8]
800078a4:	02 97       	mov	r7,r1
800078a6:	72 39       	ld.w	r9,r9[0xc]
800078a8:	93 28       	st.w	r9[0x8],r8
800078aa:	91 39       	st.w	r8[0xc],r9
800078ac:	cd c8       	rjmp	80007a64 <_realloc_r+0x268>
800078ae:	30 0a       	mov	r10,0
800078b0:	14 99       	mov	r9,r10
800078b2:	ed bc 00 00 	bld	r12,0x0
800078b6:	e0 80 00 95 	breq	800079e0 <_realloc_r+0x1e4>
800078ba:	62 07       	ld.w	r7,r1[0x0]
800078bc:	e2 07 01 07 	sub	r7,r1,r7
800078c0:	6e 1c       	ld.w	r12,r7[0x4]
800078c2:	e0 1c ff fc 	andl	r12,0xfffc
800078c6:	58 09       	cp.w	r9,0
800078c8:	c5 60       	breq	80007974 <_realloc_r+0x178>
800078ca:	f8 00 00 03 	add	r3,r12,r0
800078ce:	0a 39       	cp.w	r9,r5
800078d0:	c4 81       	brne	80007960 <_realloc_r+0x164>
800078d2:	14 03       	add	r3,r10
800078d4:	ec c9 ff f0 	sub	r9,r6,-16
800078d8:	12 33       	cp.w	r3,r9
800078da:	c4 d5       	brlt	80007974 <_realloc_r+0x178>
800078dc:	6e 3a       	ld.w	r10,r7[0xc]
800078de:	6e 29       	ld.w	r9,r7[0x8]
800078e0:	95 29       	st.w	r10[0x8],r9
800078e2:	93 3a       	st.w	r9[0xc],r10
800078e4:	ee c5 ff f8 	sub	r5,r7,-8
800078e8:	e0 ca 00 04 	sub	r10,r0,4
800078ec:	e0 4a 00 24 	cp.w	r10,36
800078f0:	e0 8b 00 25 	brhi	8000793a <_realloc_r+0x13e>
800078f4:	0a 99       	mov	r9,r5
800078f6:	59 3a       	cp.w	r10,19
800078f8:	e0 88 00 1a 	brls	8000792c <_realloc_r+0x130>
800078fc:	09 09       	ld.w	r9,r4++
800078fe:	8b 09       	st.w	r5[0x0],r9
80007900:	09 09       	ld.w	r9,r4++
80007902:	8f 39       	st.w	r7[0xc],r9
80007904:	ee c9 ff f0 	sub	r9,r7,-16
80007908:	59 ba       	cp.w	r10,27
8000790a:	e0 88 00 11 	brls	8000792c <_realloc_r+0x130>
8000790e:	09 0b       	ld.w	r11,r4++
80007910:	93 0b       	st.w	r9[0x0],r11
80007912:	09 09       	ld.w	r9,r4++
80007914:	8f 59       	st.w	r7[0x14],r9
80007916:	ee c9 ff e8 	sub	r9,r7,-24
8000791a:	e0 4a 00 24 	cp.w	r10,36
8000791e:	c0 71       	brne	8000792c <_realloc_r+0x130>
80007920:	09 0a       	ld.w	r10,r4++
80007922:	93 0a       	st.w	r9[0x0],r10
80007924:	ee c9 ff e0 	sub	r9,r7,-32
80007928:	09 0a       	ld.w	r10,r4++
8000792a:	8f 7a       	st.w	r7[0x1c],r10
8000792c:	09 0a       	ld.w	r10,r4++
8000792e:	12 aa       	st.w	r9++,r10
80007930:	68 0a       	ld.w	r10,r4[0x0]
80007932:	93 0a       	st.w	r9[0x0],r10
80007934:	68 1a       	ld.w	r10,r4[0x4]
80007936:	93 1a       	st.w	r9[0x4],r10
80007938:	c0 78       	rjmp	80007946 <_realloc_r+0x14a>
8000793a:	50 08       	stdsp	sp[0x0],r8
8000793c:	08 9b       	mov	r11,r4
8000793e:	0a 9c       	mov	r12,r5
80007940:	e0 a0 1d 8f 	rcall	8000b45e <memmove>
80007944:	40 08       	lddsp	r8,sp[0x0]
80007946:	ee 06 00 09 	add	r9,r7,r6
8000794a:	0c 13       	sub	r3,r6
8000794c:	a1 a3       	sbr	r3,0x0
8000794e:	93 13       	st.w	r9[0x4],r3
80007950:	91 29       	st.w	r8[0x8],r9
80007952:	04 9c       	mov	r12,r2
80007954:	6e 18       	ld.w	r8,r7[0x4]
80007956:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000795a:	10 46       	or	r6,r8
8000795c:	8f 16       	st.w	r7[0x4],r6
8000795e:	ca a8       	rjmp	80007ab2 <_realloc_r+0x2b6>
80007960:	14 03       	add	r3,r10
80007962:	0c 33       	cp.w	r3,r6
80007964:	c0 85       	brlt	80007974 <_realloc_r+0x178>
80007966:	72 28       	ld.w	r8,r9[0x8]
80007968:	72 39       	ld.w	r9,r9[0xc]
8000796a:	93 28       	st.w	r9[0x8],r8
8000796c:	91 39       	st.w	r8[0xc],r9
8000796e:	6e 28       	ld.w	r8,r7[0x8]
80007970:	6e 39       	ld.w	r9,r7[0xc]
80007972:	c0 78       	rjmp	80007980 <_realloc_r+0x184>
80007974:	f8 00 00 03 	add	r3,r12,r0
80007978:	0c 33       	cp.w	r3,r6
8000797a:	c3 35       	brlt	800079e0 <_realloc_r+0x1e4>
8000797c:	6e 39       	ld.w	r9,r7[0xc]
8000797e:	6e 28       	ld.w	r8,r7[0x8]
80007980:	93 28       	st.w	r9[0x8],r8
80007982:	91 39       	st.w	r8[0xc],r9
80007984:	e0 ca 00 04 	sub	r10,r0,4
80007988:	ee cc ff f8 	sub	r12,r7,-8
8000798c:	e0 4a 00 24 	cp.w	r10,36
80007990:	e0 8b 00 24 	brhi	800079d8 <_realloc_r+0x1dc>
80007994:	59 3a       	cp.w	r10,19
80007996:	e0 88 00 1a 	brls	800079ca <_realloc_r+0x1ce>
8000799a:	09 08       	ld.w	r8,r4++
8000799c:	99 08       	st.w	r12[0x0],r8
8000799e:	09 08       	ld.w	r8,r4++
800079a0:	8f 38       	st.w	r7[0xc],r8
800079a2:	ee cc ff f0 	sub	r12,r7,-16
800079a6:	59 ba       	cp.w	r10,27
800079a8:	e0 88 00 11 	brls	800079ca <_realloc_r+0x1ce>
800079ac:	09 08       	ld.w	r8,r4++
800079ae:	99 08       	st.w	r12[0x0],r8
800079b0:	09 08       	ld.w	r8,r4++
800079b2:	8f 58       	st.w	r7[0x14],r8
800079b4:	ee cc ff e8 	sub	r12,r7,-24
800079b8:	e0 4a 00 24 	cp.w	r10,36
800079bc:	c0 71       	brne	800079ca <_realloc_r+0x1ce>
800079be:	09 08       	ld.w	r8,r4++
800079c0:	99 08       	st.w	r12[0x0],r8
800079c2:	ee cc ff e0 	sub	r12,r7,-32
800079c6:	09 08       	ld.w	r8,r4++
800079c8:	8f 78       	st.w	r7[0x1c],r8
800079ca:	09 08       	ld.w	r8,r4++
800079cc:	18 a8       	st.w	r12++,r8
800079ce:	68 08       	ld.w	r8,r4[0x0]
800079d0:	99 08       	st.w	r12[0x0],r8
800079d2:	68 18       	ld.w	r8,r4[0x4]
800079d4:	99 18       	st.w	r12[0x4],r8
800079d6:	c4 78       	rjmp	80007a64 <_realloc_r+0x268>
800079d8:	08 9b       	mov	r11,r4
800079da:	e0 a0 1d 42 	rcall	8000b45e <memmove>
800079de:	c4 38       	rjmp	80007a64 <_realloc_r+0x268>
800079e0:	04 9c       	mov	r12,r2
800079e2:	fe b0 fc 45 	rcall	8000726c <_malloc_r>
800079e6:	18 95       	mov	r5,r12
800079e8:	c3 a0       	breq	80007a5c <_realloc_r+0x260>
800079ea:	62 18       	ld.w	r8,r1[0x4]
800079ec:	f8 c9 00 08 	sub	r9,r12,8
800079f0:	a1 c8       	cbr	r8,0x0
800079f2:	e2 08 00 08 	add	r8,r1,r8
800079f6:	10 39       	cp.w	r9,r8
800079f8:	c0 71       	brne	80007a06 <_realloc_r+0x20a>
800079fa:	72 13       	ld.w	r3,r9[0x4]
800079fc:	02 97       	mov	r7,r1
800079fe:	e0 13 ff fc 	andl	r3,0xfffc
80007a02:	00 03       	add	r3,r0
80007a04:	c3 08       	rjmp	80007a64 <_realloc_r+0x268>
80007a06:	e0 ca 00 04 	sub	r10,r0,4
80007a0a:	e0 4a 00 24 	cp.w	r10,36
80007a0e:	e0 8b 00 20 	brhi	80007a4e <_realloc_r+0x252>
80007a12:	08 99       	mov	r9,r4
80007a14:	18 98       	mov	r8,r12
80007a16:	59 3a       	cp.w	r10,19
80007a18:	e0 88 00 14 	brls	80007a40 <_realloc_r+0x244>
80007a1c:	13 0b       	ld.w	r11,r9++
80007a1e:	10 ab       	st.w	r8++,r11
80007a20:	13 0b       	ld.w	r11,r9++
80007a22:	10 ab       	st.w	r8++,r11
80007a24:	59 ba       	cp.w	r10,27
80007a26:	e0 88 00 0d 	brls	80007a40 <_realloc_r+0x244>
80007a2a:	13 0b       	ld.w	r11,r9++
80007a2c:	10 ab       	st.w	r8++,r11
80007a2e:	13 0b       	ld.w	r11,r9++
80007a30:	10 ab       	st.w	r8++,r11
80007a32:	e0 4a 00 24 	cp.w	r10,36
80007a36:	c0 51       	brne	80007a40 <_realloc_r+0x244>
80007a38:	13 0a       	ld.w	r10,r9++
80007a3a:	10 aa       	st.w	r8++,r10
80007a3c:	13 0a       	ld.w	r10,r9++
80007a3e:	10 aa       	st.w	r8++,r10
80007a40:	13 0a       	ld.w	r10,r9++
80007a42:	10 aa       	st.w	r8++,r10
80007a44:	72 0a       	ld.w	r10,r9[0x0]
80007a46:	91 0a       	st.w	r8[0x0],r10
80007a48:	72 19       	ld.w	r9,r9[0x4]
80007a4a:	91 19       	st.w	r8[0x4],r9
80007a4c:	c0 48       	rjmp	80007a54 <_realloc_r+0x258>
80007a4e:	08 9b       	mov	r11,r4
80007a50:	e0 a0 1d 07 	rcall	8000b45e <memmove>
80007a54:	08 9b       	mov	r11,r4
80007a56:	04 9c       	mov	r12,r2
80007a58:	e0 a0 1a 60 	rcall	8000af18 <_free_r>
80007a5c:	04 9c       	mov	r12,r2
80007a5e:	c2 a8       	rjmp	80007ab2 <_realloc_r+0x2b6>
80007a60:	00 93       	mov	r3,r0
80007a62:	02 97       	mov	r7,r1
80007a64:	e6 06 01 09 	sub	r9,r3,r6
80007a68:	6e 18       	ld.w	r8,r7[0x4]
80007a6a:	58 f9       	cp.w	r9,15
80007a6c:	e0 88 00 16 	brls	80007a98 <_realloc_r+0x29c>
80007a70:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007a74:	ed e8 10 08 	or	r8,r6,r8
80007a78:	8f 18       	st.w	r7[0x4],r8
80007a7a:	12 98       	mov	r8,r9
80007a7c:	a1 a8       	sbr	r8,0x0
80007a7e:	ee 06 00 0b 	add	r11,r7,r6
80007a82:	f6 09 00 09 	add	r9,r11,r9
80007a86:	97 18       	st.w	r11[0x4],r8
80007a88:	72 18       	ld.w	r8,r9[0x4]
80007a8a:	a1 a8       	sbr	r8,0x0
80007a8c:	2f 8b       	sub	r11,-8
80007a8e:	93 18       	st.w	r9[0x4],r8
80007a90:	04 9c       	mov	r12,r2
80007a92:	e0 a0 1a 43 	rcall	8000af18 <_free_r>
80007a96:	c0 b8       	rjmp	80007aac <_realloc_r+0x2b0>
80007a98:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007a9c:	e7 e8 10 08 	or	r8,r3,r8
80007aa0:	8f 18       	st.w	r7[0x4],r8
80007aa2:	ee 03 00 03 	add	r3,r7,r3
80007aa6:	66 18       	ld.w	r8,r3[0x4]
80007aa8:	a1 a8       	sbr	r8,0x0
80007aaa:	87 18       	st.w	r3[0x4],r8
80007aac:	04 9c       	mov	r12,r2
80007aae:	ee c5 ff f8 	sub	r5,r7,-8
80007ab2:	fe b0 f1 c9 	rcall	80005e44 <__malloc_unlock>
80007ab6:	0a 9c       	mov	r12,r5
80007ab8:	2f fd       	sub	sp,-4
80007aba:	d8 32       	popm	r0-r7,pc

80007abc <_sbrk_r>:
80007abc:	d4 21       	pushm	r4-r7,lr
80007abe:	30 08       	mov	r8,0
80007ac0:	18 97       	mov	r7,r12
80007ac2:	e0 66 5b 6c 	mov	r6,23404
80007ac6:	16 9c       	mov	r12,r11
80007ac8:	8d 08       	st.w	r6[0x0],r8
80007aca:	c8 5c       	rcall	80007bd4 <_sbrk>
80007acc:	5b fc       	cp.w	r12,-1
80007ace:	c0 51       	brne	80007ad8 <_sbrk_r+0x1c>
80007ad0:	6c 08       	ld.w	r8,r6[0x0]
80007ad2:	58 08       	cp.w	r8,0
80007ad4:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007ad8:	d8 22       	popm	r4-r7,pc
80007ada:	d7 03       	nop

80007adc <sprintf>:
80007adc:	d4 01       	pushm	lr
80007ade:	21 7d       	sub	sp,92
80007ae0:	e0 68 ff ff 	mov	r8,65535
80007ae4:	ea 18 7f ff 	orh	r8,0x7fff
80007ae8:	50 58       	stdsp	sp[0x14],r8
80007aea:	50 28       	stdsp	sp[0x8],r8
80007aec:	e0 68 02 08 	mov	r8,520
80007af0:	ba 68       	st.h	sp[0xc],r8
80007af2:	3f f8       	mov	r8,-1
80007af4:	ba 78       	st.h	sp[0xe],r8
80007af6:	e0 68 0a 3c 	mov	r8,2620
80007afa:	50 4c       	stdsp	sp[0x10],r12
80007afc:	16 9a       	mov	r10,r11
80007afe:	50 0c       	stdsp	sp[0x0],r12
80007b00:	fa c9 ff a0 	sub	r9,sp,-96
80007b04:	70 0c       	ld.w	r12,r8[0x0]
80007b06:	1a 9b       	mov	r11,sp
80007b08:	e0 a0 02 1a 	rcall	80007f3c <_vfprintf_r>
80007b0c:	30 09       	mov	r9,0
80007b0e:	40 08       	lddsp	r8,sp[0x0]
80007b10:	b0 89       	st.b	r8[0x0],r9
80007b12:	2e 9d       	sub	sp,-92
80007b14:	d8 02       	popm	pc
80007b16:	d7 03       	nop

80007b18 <strncpy>:
80007b18:	30 08       	mov	r8,0
80007b1a:	10 3a       	cp.w	r10,r8
80007b1c:	5e 0c       	reteq	r12
80007b1e:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007b22:	f8 08 0b 09 	st.b	r12[r8],r9
80007b26:	2f f8       	sub	r8,-1
80007b28:	58 09       	cp.w	r9,0
80007b2a:	cf 81       	brne	80007b1a <strncpy+0x2>
80007b2c:	10 3a       	cp.w	r10,r8
80007b2e:	5e 0c       	reteq	r12
80007b30:	f8 08 0b 09 	st.b	r12[r8],r9
80007b34:	2f f8       	sub	r8,-1
80007b36:	cf bb       	rjmp	80007b2c <strncpy+0x14>

80007b38 <_close>:
80007b38:	30 28       	mov	r8,2
80007b3a:	d6 73       	breakpoint
80007b3c:	3f fc       	mov	r12,-1
80007b3e:	35 8b       	mov	r11,88
80007b40:	58 0c       	cp.w	r12,0
80007b42:	5e 4c       	retge	r12
80007b44:	e0 6a 5b 6c 	mov	r10,23404
80007b48:	95 0b       	st.w	r10[0x0],r11
80007b4a:	5e fc       	retal	r12

80007b4c <_lseek>:
80007b4c:	30 58       	mov	r8,5
80007b4e:	d6 73       	breakpoint
80007b50:	3f fc       	mov	r12,-1
80007b52:	35 8b       	mov	r11,88
80007b54:	58 0c       	cp.w	r12,0
80007b56:	5e 4c       	retge	r12
80007b58:	e0 6a 5b 6c 	mov	r10,23404
80007b5c:	95 0b       	st.w	r10[0x0],r11
80007b5e:	5e fc       	retal	r12

80007b60 <isatty>:
80007b60:	30 b8       	mov	r8,11
80007b62:	d6 73       	breakpoint
80007b64:	3f fc       	mov	r12,-1
80007b66:	35 8b       	mov	r11,88
80007b68:	58 0c       	cp.w	r12,0
80007b6a:	5e 4c       	retge	r12
80007b6c:	e0 6a 5b 6c 	mov	r10,23404
80007b70:	95 0b       	st.w	r10[0x0],r11
80007b72:	5e fc       	retal	r12

80007b74 <_fstat_host>:
80007b74:	30 98       	mov	r8,9
80007b76:	d6 73       	breakpoint
80007b78:	3f fc       	mov	r12,-1
80007b7a:	35 8b       	mov	r11,88
80007b7c:	58 0c       	cp.w	r12,0
80007b7e:	5e 4c       	retge	r12
80007b80:	e0 6a 5b 6c 	mov	r10,23404
80007b84:	95 0b       	st.w	r10[0x0],r11
80007b86:	5e fc       	retal	r12

80007b88 <_fstat>:
80007b88:	d4 21       	pushm	r4-r7,lr
80007b8a:	21 0d       	sub	sp,64
80007b8c:	16 97       	mov	r7,r11
80007b8e:	1a 9b       	mov	r11,sp
80007b90:	cf 2f       	rcall	80007b74 <_fstat_host>
80007b92:	c0 34       	brge	80007b98 <_fstat+0x10>
80007b94:	3f fc       	mov	r12,-1
80007b96:	c1 c8       	rjmp	80007bce <_fstat+0x46>
80007b98:	40 08       	lddsp	r8,sp[0x0]
80007b9a:	ae 08       	st.h	r7[0x0],r8
80007b9c:	40 18       	lddsp	r8,sp[0x4]
80007b9e:	ae 18       	st.h	r7[0x2],r8
80007ba0:	40 28       	lddsp	r8,sp[0x8]
80007ba2:	8f 18       	st.w	r7[0x4],r8
80007ba4:	40 38       	lddsp	r8,sp[0xc]
80007ba6:	ae 48       	st.h	r7[0x8],r8
80007ba8:	40 48       	lddsp	r8,sp[0x10]
80007baa:	ae 58       	st.h	r7[0xa],r8
80007bac:	40 58       	lddsp	r8,sp[0x14]
80007bae:	ae 68       	st.h	r7[0xc],r8
80007bb0:	40 68       	lddsp	r8,sp[0x18]
80007bb2:	ae 78       	st.h	r7[0xe],r8
80007bb4:	40 88       	lddsp	r8,sp[0x20]
80007bb6:	8f 48       	st.w	r7[0x10],r8
80007bb8:	40 a8       	lddsp	r8,sp[0x28]
80007bba:	8f b8       	st.w	r7[0x2c],r8
80007bbc:	40 c8       	lddsp	r8,sp[0x30]
80007bbe:	8f c8       	st.w	r7[0x30],r8
80007bc0:	40 d8       	lddsp	r8,sp[0x34]
80007bc2:	8f 58       	st.w	r7[0x14],r8
80007bc4:	40 e8       	lddsp	r8,sp[0x38]
80007bc6:	30 0c       	mov	r12,0
80007bc8:	8f 78       	st.w	r7[0x1c],r8
80007bca:	40 f8       	lddsp	r8,sp[0x3c]
80007bcc:	8f 98       	st.w	r7[0x24],r8
80007bce:	2f 0d       	sub	sp,-64
80007bd0:	d8 22       	popm	r4-r7,pc
80007bd2:	d7 03       	nop

80007bd4 <_sbrk>:
80007bd4:	d4 01       	pushm	lr
80007bd6:	e0 68 0d 94 	mov	r8,3476
80007bda:	70 09       	ld.w	r9,r8[0x0]
80007bdc:	58 09       	cp.w	r9,0
80007bde:	c0 41       	brne	80007be6 <_sbrk+0x12>
80007be0:	e0 69 5b 70 	mov	r9,23408
80007be4:	91 09       	st.w	r8[0x0],r9
80007be6:	e0 69 0d 94 	mov	r9,3476
80007bea:	e0 7a 70 00 	mov	r10,94208
80007bee:	72 08       	ld.w	r8,r9[0x0]
80007bf0:	f0 0c 00 0c 	add	r12,r8,r12
80007bf4:	14 3c       	cp.w	r12,r10
80007bf6:	e0 8b 00 04 	brhi	80007bfe <_sbrk+0x2a>
80007bfa:	93 0c       	st.w	r9[0x0],r12
80007bfc:	c0 68       	rjmp	80007c08 <_sbrk+0x34>
80007bfe:	e0 a0 18 15 	rcall	8000ac28 <__errno>
80007c02:	30 c8       	mov	r8,12
80007c04:	99 08       	st.w	r12[0x0],r8
80007c06:	3f f8       	mov	r8,-1
80007c08:	10 9c       	mov	r12,r8
80007c0a:	d8 02       	popm	pc

80007c0c <get_arg>:
80007c0c:	d4 31       	pushm	r0-r7,lr
80007c0e:	20 8d       	sub	sp,32
80007c10:	fa c4 ff bc 	sub	r4,sp,-68
80007c14:	50 4b       	stdsp	sp[0x10],r11
80007c16:	68 2e       	ld.w	lr,r4[0x8]
80007c18:	50 58       	stdsp	sp[0x14],r8
80007c1a:	12 96       	mov	r6,r9
80007c1c:	7c 0b       	ld.w	r11,lr[0x0]
80007c1e:	70 05       	ld.w	r5,r8[0x0]
80007c20:	50 6e       	stdsp	sp[0x18],lr
80007c22:	58 0b       	cp.w	r11,0
80007c24:	f4 0b 17 00 	moveq	r11,r10
80007c28:	68 03       	ld.w	r3,r4[0x0]
80007c2a:	68 11       	ld.w	r1,r4[0x4]
80007c2c:	40 49       	lddsp	r9,sp[0x10]
80007c2e:	30 08       	mov	r8,0
80007c30:	c2 89       	rjmp	80007e80 <get_arg+0x274>
80007c32:	2f fb       	sub	r11,-1
80007c34:	32 5c       	mov	r12,37
80007c36:	17 8a       	ld.ub	r10,r11[0x0]
80007c38:	f8 0a 18 00 	cp.b	r10,r12
80007c3c:	5f 1e       	srne	lr
80007c3e:	f0 0a 18 00 	cp.b	r10,r8
80007c42:	5f 1c       	srne	r12
80007c44:	fd ec 00 0c 	and	r12,lr,r12
80007c48:	f0 0c 18 00 	cp.b	r12,r8
80007c4c:	cf 31       	brne	80007c32 <get_arg+0x26>
80007c4e:	58 0a       	cp.w	r10,0
80007c50:	e0 80 01 25 	breq	80007e9a <get_arg+0x28e>
80007c54:	30 0c       	mov	r12,0
80007c56:	3f fa       	mov	r10,-1
80007c58:	18 90       	mov	r0,r12
80007c5a:	50 3a       	stdsp	sp[0xc],r10
80007c5c:	18 94       	mov	r4,r12
80007c5e:	18 92       	mov	r2,r12
80007c60:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007c64:	16 97       	mov	r7,r11
80007c66:	50 7c       	stdsp	sp[0x1c],r12
80007c68:	fe cc 9e 88 	sub	r12,pc,-24952
80007c6c:	0f 3a       	ld.ub	r10,r7++
80007c6e:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007c72:	40 7c       	lddsp	r12,sp[0x1c]
80007c74:	1c 0c       	add	r12,lr
80007c76:	fe ce 9f 5e 	sub	lr,pc,-24738
80007c7a:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007c7e:	20 1e       	sub	lr,1
80007c80:	50 0e       	stdsp	sp[0x0],lr
80007c82:	fe ce 9f d6 	sub	lr,pc,-24618
80007c86:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007c8a:	50 7c       	stdsp	sp[0x1c],r12
80007c8c:	40 0c       	lddsp	r12,sp[0x0]
80007c8e:	58 7c       	cp.w	r12,7
80007c90:	e0 8b 00 f1 	brhi	80007e72 <get_arg+0x266>
80007c94:	fe ce a1 88 	sub	lr,pc,-24184
80007c98:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007c9c:	36 8b       	mov	r11,104
80007c9e:	f6 0a 18 00 	cp.b	r10,r11
80007ca2:	e0 80 00 e8 	breq	80007e72 <get_arg+0x266>
80007ca6:	37 1b       	mov	r11,113
80007ca8:	f6 0a 18 00 	cp.b	r10,r11
80007cac:	c0 70       	breq	80007cba <get_arg+0xae>
80007cae:	34 cb       	mov	r11,76
80007cb0:	f6 0a 18 00 	cp.b	r10,r11
80007cb4:	c0 51       	brne	80007cbe <get_arg+0xb2>
80007cb6:	a3 b4       	sbr	r4,0x3
80007cb8:	cd d8       	rjmp	80007e72 <get_arg+0x266>
80007cba:	a5 b4       	sbr	r4,0x5
80007cbc:	cd b8       	rjmp	80007e72 <get_arg+0x266>
80007cbe:	08 9a       	mov	r10,r4
80007cc0:	0e 9b       	mov	r11,r7
80007cc2:	a5 aa       	sbr	r10,0x4
80007cc4:	17 3c       	ld.ub	r12,r11++
80007cc6:	a5 b4       	sbr	r4,0x5
80007cc8:	36 ce       	mov	lr,108
80007cca:	fc 0c 18 00 	cp.b	r12,lr
80007cce:	e0 80 00 d3 	breq	80007e74 <get_arg+0x268>
80007cd2:	14 94       	mov	r4,r10
80007cd4:	cc f8       	rjmp	80007e72 <get_arg+0x266>
80007cd6:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007cda:	36 7c       	mov	r12,103
80007cdc:	f8 0a 18 00 	cp.b	r10,r12
80007ce0:	e0 8b 00 27 	brhi	80007d2e <get_arg+0x122>
80007ce4:	36 5b       	mov	r11,101
80007ce6:	f6 0a 18 00 	cp.b	r10,r11
80007cea:	c4 82       	brcc	80007d7a <get_arg+0x16e>
80007cec:	34 fb       	mov	r11,79
80007cee:	f6 0a 18 00 	cp.b	r10,r11
80007cf2:	c4 80       	breq	80007d82 <get_arg+0x176>
80007cf4:	e0 8b 00 0c 	brhi	80007d0c <get_arg+0x100>
80007cf8:	34 5b       	mov	r11,69
80007cfa:	f6 0a 18 00 	cp.b	r10,r11
80007cfe:	c3 e0       	breq	80007d7a <get_arg+0x16e>
80007d00:	34 7b       	mov	r11,71
80007d02:	f6 0a 18 00 	cp.b	r10,r11
80007d06:	c3 a0       	breq	80007d7a <get_arg+0x16e>
80007d08:	34 4b       	mov	r11,68
80007d0a:	c0 88       	rjmp	80007d1a <get_arg+0x10e>
80007d0c:	35 8b       	mov	r11,88
80007d0e:	f6 0a 18 00 	cp.b	r10,r11
80007d12:	c2 c0       	breq	80007d6a <get_arg+0x15e>
80007d14:	e0 8b 00 07 	brhi	80007d22 <get_arg+0x116>
80007d18:	35 5b       	mov	r11,85
80007d1a:	f6 0a 18 00 	cp.b	r10,r11
80007d1e:	c3 51       	brne	80007d88 <get_arg+0x17c>
80007d20:	c3 18       	rjmp	80007d82 <get_arg+0x176>
80007d22:	36 3b       	mov	r11,99
80007d24:	f6 0a 18 00 	cp.b	r10,r11
80007d28:	c2 f0       	breq	80007d86 <get_arg+0x17a>
80007d2a:	36 4b       	mov	r11,100
80007d2c:	c0 e8       	rjmp	80007d48 <get_arg+0x13c>
80007d2e:	37 0b       	mov	r11,112
80007d30:	f6 0a 18 00 	cp.b	r10,r11
80007d34:	c2 50       	breq	80007d7e <get_arg+0x172>
80007d36:	e0 8b 00 0d 	brhi	80007d50 <get_arg+0x144>
80007d3a:	36 eb       	mov	r11,110
80007d3c:	f6 0a 18 00 	cp.b	r10,r11
80007d40:	c1 f0       	breq	80007d7e <get_arg+0x172>
80007d42:	e0 8b 00 14 	brhi	80007d6a <get_arg+0x15e>
80007d46:	36 9b       	mov	r11,105
80007d48:	f6 0a 18 00 	cp.b	r10,r11
80007d4c:	c1 e1       	brne	80007d88 <get_arg+0x17c>
80007d4e:	c0 e8       	rjmp	80007d6a <get_arg+0x15e>
80007d50:	37 5b       	mov	r11,117
80007d52:	f6 0a 18 00 	cp.b	r10,r11
80007d56:	c0 a0       	breq	80007d6a <get_arg+0x15e>
80007d58:	37 8b       	mov	r11,120
80007d5a:	f6 0a 18 00 	cp.b	r10,r11
80007d5e:	c0 60       	breq	80007d6a <get_arg+0x15e>
80007d60:	37 3b       	mov	r11,115
80007d62:	f6 0a 18 00 	cp.b	r10,r11
80007d66:	c1 11       	brne	80007d88 <get_arg+0x17c>
80007d68:	c0 b8       	rjmp	80007d7e <get_arg+0x172>
80007d6a:	ed b4 00 04 	bld	r4,0x4
80007d6e:	c0 a0       	breq	80007d82 <get_arg+0x176>
80007d70:	ed b4 00 05 	bld	r4,0x5
80007d74:	c0 91       	brne	80007d86 <get_arg+0x17a>
80007d76:	30 20       	mov	r0,2
80007d78:	c0 88       	rjmp	80007d88 <get_arg+0x17c>
80007d7a:	30 40       	mov	r0,4
80007d7c:	c0 68       	rjmp	80007d88 <get_arg+0x17c>
80007d7e:	30 30       	mov	r0,3
80007d80:	c0 48       	rjmp	80007d88 <get_arg+0x17c>
80007d82:	30 10       	mov	r0,1
80007d84:	c0 28       	rjmp	80007d88 <get_arg+0x17c>
80007d86:	30 00       	mov	r0,0
80007d88:	40 3b       	lddsp	r11,sp[0xc]
80007d8a:	5b fb       	cp.w	r11,-1
80007d8c:	c0 40       	breq	80007d94 <get_arg+0x188>
80007d8e:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007d92:	c7 08       	rjmp	80007e72 <get_arg+0x266>
80007d94:	58 60       	cp.w	r0,6
80007d96:	e0 8b 00 6e 	brhi	80007e72 <get_arg+0x266>
80007d9a:	6c 0a       	ld.w	r10,r6[0x0]
80007d9c:	ea cc ff ff 	sub	r12,r5,-1
80007da0:	fe ce a2 74 	sub	lr,pc,-23948
80007da4:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007da8:	f4 cb ff f8 	sub	r11,r10,-8
80007dac:	8d 0b       	st.w	r6[0x0],r11
80007dae:	f4 ea 00 00 	ld.d	r10,r10[0]
80007db2:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007db6:	c0 f8       	rjmp	80007dd4 <get_arg+0x1c8>
80007db8:	f4 cb ff fc 	sub	r11,r10,-4
80007dbc:	8d 0b       	st.w	r6[0x0],r11
80007dbe:	74 0a       	ld.w	r10,r10[0x0]
80007dc0:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007dc4:	c0 88       	rjmp	80007dd4 <get_arg+0x1c8>
80007dc6:	f4 cb ff f8 	sub	r11,r10,-8
80007dca:	8d 0b       	st.w	r6[0x0],r11
80007dcc:	f4 ea 00 00 	ld.d	r10,r10[0]
80007dd0:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007dd4:	0e 9b       	mov	r11,r7
80007dd6:	18 95       	mov	r5,r12
80007dd8:	c4 e8       	rjmp	80007e74 <get_arg+0x268>
80007dda:	62 0a       	ld.w	r10,r1[0x0]
80007ddc:	5b fa       	cp.w	r10,-1
80007dde:	c0 b1       	brne	80007df4 <get_arg+0x1e8>
80007de0:	50 19       	stdsp	sp[0x4],r9
80007de2:	50 28       	stdsp	sp[0x8],r8
80007de4:	e0 6a 00 80 	mov	r10,128
80007de8:	30 0b       	mov	r11,0
80007dea:	02 9c       	mov	r12,r1
80007dec:	fe b0 fd 00 	rcall	800077ec <memset>
80007df0:	40 28       	lddsp	r8,sp[0x8]
80007df2:	40 19       	lddsp	r9,sp[0x4]
80007df4:	e4 cc 00 01 	sub	r12,r2,1
80007df8:	0e 9b       	mov	r11,r7
80007dfa:	50 3c       	stdsp	sp[0xc],r12
80007dfc:	f2 0c 0c 49 	max	r9,r9,r12
80007e00:	c3 a8       	rjmp	80007e74 <get_arg+0x268>
80007e02:	62 0a       	ld.w	r10,r1[0x0]
80007e04:	5b fa       	cp.w	r10,-1
80007e06:	c0 b1       	brne	80007e1c <get_arg+0x210>
80007e08:	50 19       	stdsp	sp[0x4],r9
80007e0a:	50 28       	stdsp	sp[0x8],r8
80007e0c:	e0 6a 00 80 	mov	r10,128
80007e10:	30 0b       	mov	r11,0
80007e12:	02 9c       	mov	r12,r1
80007e14:	fe b0 fc ec 	rcall	800077ec <memset>
80007e18:	40 28       	lddsp	r8,sp[0x8]
80007e1a:	40 19       	lddsp	r9,sp[0x4]
80007e1c:	20 12       	sub	r2,1
80007e1e:	30 0a       	mov	r10,0
80007e20:	0e 9b       	mov	r11,r7
80007e22:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007e26:	f2 02 0c 49 	max	r9,r9,r2
80007e2a:	c2 58       	rjmp	80007e74 <get_arg+0x268>
80007e2c:	16 97       	mov	r7,r11
80007e2e:	6c 0a       	ld.w	r10,r6[0x0]
80007e30:	f4 cb ff fc 	sub	r11,r10,-4
80007e34:	8d 0b       	st.w	r6[0x0],r11
80007e36:	74 0a       	ld.w	r10,r10[0x0]
80007e38:	0e 9b       	mov	r11,r7
80007e3a:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007e3e:	2f f5       	sub	r5,-1
80007e40:	c1 a8       	rjmp	80007e74 <get_arg+0x268>
80007e42:	f4 c2 00 30 	sub	r2,r10,48
80007e46:	c0 68       	rjmp	80007e52 <get_arg+0x246>
80007e48:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007e4c:	2f f7       	sub	r7,-1
80007e4e:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007e52:	0f 8a       	ld.ub	r10,r7[0x0]
80007e54:	58 0a       	cp.w	r10,0
80007e56:	c0 e0       	breq	80007e72 <get_arg+0x266>
80007e58:	23 0a       	sub	r10,48
80007e5a:	58 9a       	cp.w	r10,9
80007e5c:	fe 98 ff f6 	brls	80007e48 <get_arg+0x23c>
80007e60:	c0 98       	rjmp	80007e72 <get_arg+0x266>
80007e62:	2f f7       	sub	r7,-1
80007e64:	0f 8a       	ld.ub	r10,r7[0x0]
80007e66:	58 0a       	cp.w	r10,0
80007e68:	c0 50       	breq	80007e72 <get_arg+0x266>
80007e6a:	23 0a       	sub	r10,48
80007e6c:	58 9a       	cp.w	r10,9
80007e6e:	fe 98 ff fa 	brls	80007e62 <get_arg+0x256>
80007e72:	0e 9b       	mov	r11,r7
80007e74:	40 7c       	lddsp	r12,sp[0x1c]
80007e76:	30 ba       	mov	r10,11
80007e78:	f4 0c 18 00 	cp.b	r12,r10
80007e7c:	fe 91 fe f2 	brne	80007c60 <get_arg+0x54>
80007e80:	40 42       	lddsp	r2,sp[0x10]
80007e82:	17 8c       	ld.ub	r12,r11[0x0]
80007e84:	0a 32       	cp.w	r2,r5
80007e86:	5f 4a       	srge	r10
80007e88:	f0 0c 18 00 	cp.b	r12,r8
80007e8c:	5f 1c       	srne	r12
80007e8e:	f9 ea 00 0a 	and	r10,r12,r10
80007e92:	f0 0a 18 00 	cp.b	r10,r8
80007e96:	fe 91 fe cf 	brne	80007c34 <get_arg+0x28>
80007e9a:	30 08       	mov	r8,0
80007e9c:	40 4e       	lddsp	lr,sp[0x10]
80007e9e:	17 8a       	ld.ub	r10,r11[0x0]
80007ea0:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007ea4:	f0 0a 18 00 	cp.b	r10,r8
80007ea8:	fc 09 17 10 	movne	r9,lr
80007eac:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007eb0:	06 9e       	mov	lr,r3
80007eb2:	c2 a8       	rjmp	80007f06 <get_arg+0x2fa>
80007eb4:	62 0a       	ld.w	r10,r1[0x0]
80007eb6:	58 3a       	cp.w	r10,3
80007eb8:	c1 e0       	breq	80007ef4 <get_arg+0x2e8>
80007eba:	e0 89 00 07 	brgt	80007ec8 <get_arg+0x2bc>
80007ebe:	58 1a       	cp.w	r10,1
80007ec0:	c1 a0       	breq	80007ef4 <get_arg+0x2e8>
80007ec2:	58 2a       	cp.w	r10,2
80007ec4:	c1 81       	brne	80007ef4 <get_arg+0x2e8>
80007ec6:	c0 58       	rjmp	80007ed0 <get_arg+0x2c4>
80007ec8:	58 5a       	cp.w	r10,5
80007eca:	c0 c0       	breq	80007ee2 <get_arg+0x2d6>
80007ecc:	c0 b5       	brlt	80007ee2 <get_arg+0x2d6>
80007ece:	c1 38       	rjmp	80007ef4 <get_arg+0x2e8>
80007ed0:	6c 0a       	ld.w	r10,r6[0x0]
80007ed2:	f4 cc ff f8 	sub	r12,r10,-8
80007ed6:	8d 0c       	st.w	r6[0x0],r12
80007ed8:	f4 e2 00 00 	ld.d	r2,r10[0]
80007edc:	f0 e3 00 00 	st.d	r8[0],r2
80007ee0:	c1 08       	rjmp	80007f00 <get_arg+0x2f4>
80007ee2:	6c 0a       	ld.w	r10,r6[0x0]
80007ee4:	f4 cc ff f8 	sub	r12,r10,-8
80007ee8:	8d 0c       	st.w	r6[0x0],r12
80007eea:	f4 e2 00 00 	ld.d	r2,r10[0]
80007eee:	f0 e3 00 00 	st.d	r8[0],r2
80007ef2:	c0 78       	rjmp	80007f00 <get_arg+0x2f4>
80007ef4:	6c 0a       	ld.w	r10,r6[0x0]
80007ef6:	f4 cc ff fc 	sub	r12,r10,-4
80007efa:	8d 0c       	st.w	r6[0x0],r12
80007efc:	74 0a       	ld.w	r10,r10[0x0]
80007efe:	91 0a       	st.w	r8[0x0],r10
80007f00:	2f f5       	sub	r5,-1
80007f02:	2f 88       	sub	r8,-8
80007f04:	2f c1       	sub	r1,-4
80007f06:	12 35       	cp.w	r5,r9
80007f08:	fe 9a ff d6 	brle	80007eb4 <get_arg+0x2a8>
80007f0c:	1c 93       	mov	r3,lr
80007f0e:	40 52       	lddsp	r2,sp[0x14]
80007f10:	40 6e       	lddsp	lr,sp[0x18]
80007f12:	85 05       	st.w	r2[0x0],r5
80007f14:	9d 0b       	st.w	lr[0x0],r11
80007f16:	40 4b       	lddsp	r11,sp[0x10]
80007f18:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007f1c:	2f 8d       	sub	sp,-32
80007f1e:	d8 32       	popm	r0-r7,pc

80007f20 <__sprint_r>:
80007f20:	d4 21       	pushm	r4-r7,lr
80007f22:	14 97       	mov	r7,r10
80007f24:	74 28       	ld.w	r8,r10[0x8]
80007f26:	58 08       	cp.w	r8,0
80007f28:	c0 41       	brne	80007f30 <__sprint_r+0x10>
80007f2a:	95 18       	st.w	r10[0x4],r8
80007f2c:	10 9c       	mov	r12,r8
80007f2e:	d8 22       	popm	r4-r7,pc
80007f30:	e0 a0 18 ba 	rcall	8000b0a4 <__sfvwrite_r>
80007f34:	30 08       	mov	r8,0
80007f36:	8f 18       	st.w	r7[0x4],r8
80007f38:	8f 28       	st.w	r7[0x8],r8
80007f3a:	d8 22       	popm	r4-r7,pc

80007f3c <_vfprintf_r>:
80007f3c:	d4 31       	pushm	r0-r7,lr
80007f3e:	fa cd 06 bc 	sub	sp,sp,1724
80007f42:	51 09       	stdsp	sp[0x40],r9
80007f44:	16 91       	mov	r1,r11
80007f46:	14 97       	mov	r7,r10
80007f48:	18 95       	mov	r5,r12
80007f4a:	e0 a0 1a 1d 	rcall	8000b384 <_localeconv_r>
80007f4e:	78 0c       	ld.w	r12,r12[0x0]
80007f50:	50 cc       	stdsp	sp[0x30],r12
80007f52:	58 05       	cp.w	r5,0
80007f54:	c0 70       	breq	80007f62 <_vfprintf_r+0x26>
80007f56:	6a 68       	ld.w	r8,r5[0x18]
80007f58:	58 08       	cp.w	r8,0
80007f5a:	c0 41       	brne	80007f62 <_vfprintf_r+0x26>
80007f5c:	0a 9c       	mov	r12,r5
80007f5e:	e0 a0 17 43 	rcall	8000ade4 <__sinit>
80007f62:	fe c8 a0 72 	sub	r8,pc,-24462
80007f66:	10 31       	cp.w	r1,r8
80007f68:	c0 31       	brne	80007f6e <_vfprintf_r+0x32>
80007f6a:	6a 01       	ld.w	r1,r5[0x0]
80007f6c:	c0 c8       	rjmp	80007f84 <_vfprintf_r+0x48>
80007f6e:	fe c8 a0 5e 	sub	r8,pc,-24482
80007f72:	10 31       	cp.w	r1,r8
80007f74:	c0 31       	brne	80007f7a <_vfprintf_r+0x3e>
80007f76:	6a 11       	ld.w	r1,r5[0x4]
80007f78:	c0 68       	rjmp	80007f84 <_vfprintf_r+0x48>
80007f7a:	fe c8 a0 4a 	sub	r8,pc,-24502
80007f7e:	10 31       	cp.w	r1,r8
80007f80:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007f84:	82 68       	ld.sh	r8,r1[0xc]
80007f86:	ed b8 00 03 	bld	r8,0x3
80007f8a:	c0 41       	brne	80007f92 <_vfprintf_r+0x56>
80007f8c:	62 48       	ld.w	r8,r1[0x10]
80007f8e:	58 08       	cp.w	r8,0
80007f90:	c0 71       	brne	80007f9e <_vfprintf_r+0x62>
80007f92:	02 9b       	mov	r11,r1
80007f94:	0a 9c       	mov	r12,r5
80007f96:	e0 a0 0f 5d 	rcall	80009e50 <__swsetup_r>
80007f9a:	e0 81 0f 54 	brne	80009e42 <_vfprintf_r+0x1f06>
80007f9e:	82 68       	ld.sh	r8,r1[0xc]
80007fa0:	10 99       	mov	r9,r8
80007fa2:	e2 19 00 1a 	andl	r9,0x1a,COH
80007fa6:	58 a9       	cp.w	r9,10
80007fa8:	c3 c1       	brne	80008020 <_vfprintf_r+0xe4>
80007faa:	82 79       	ld.sh	r9,r1[0xe]
80007fac:	30 0a       	mov	r10,0
80007fae:	f4 09 19 00 	cp.h	r9,r10
80007fb2:	c3 75       	brlt	80008020 <_vfprintf_r+0xe4>
80007fb4:	a1 d8       	cbr	r8,0x1
80007fb6:	fb 58 05 d0 	st.h	sp[1488],r8
80007fba:	62 88       	ld.w	r8,r1[0x20]
80007fbc:	fb 48 05 e4 	st.w	sp[1508],r8
80007fc0:	62 a8       	ld.w	r8,r1[0x28]
80007fc2:	fb 48 05 ec 	st.w	sp[1516],r8
80007fc6:	fa c8 ff bc 	sub	r8,sp,-68
80007fca:	fb 48 05 d4 	st.w	sp[1492],r8
80007fce:	fb 48 05 c4 	st.w	sp[1476],r8
80007fd2:	e0 68 04 00 	mov	r8,1024
80007fd6:	fb 48 05 d8 	st.w	sp[1496],r8
80007fda:	fb 48 05 cc 	st.w	sp[1484],r8
80007fde:	30 08       	mov	r8,0
80007fe0:	fb 59 05 d2 	st.h	sp[1490],r9
80007fe4:	0e 9a       	mov	r10,r7
80007fe6:	41 09       	lddsp	r9,sp[0x40]
80007fe8:	fa c7 fa 3c 	sub	r7,sp,-1476
80007fec:	fb 48 05 dc 	st.w	sp[1500],r8
80007ff0:	0a 9c       	mov	r12,r5
80007ff2:	0e 9b       	mov	r11,r7
80007ff4:	ca 4f       	rcall	80007f3c <_vfprintf_r>
80007ff6:	50 bc       	stdsp	sp[0x2c],r12
80007ff8:	c0 95       	brlt	8000800a <_vfprintf_r+0xce>
80007ffa:	0e 9b       	mov	r11,r7
80007ffc:	0a 9c       	mov	r12,r5
80007ffe:	e0 a0 16 1b 	rcall	8000ac34 <_fflush_r>
80008002:	40 be       	lddsp	lr,sp[0x2c]
80008004:	f9 be 01 ff 	movne	lr,-1
80008008:	50 be       	stdsp	sp[0x2c],lr
8000800a:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000800e:	ed b8 00 06 	bld	r8,0x6
80008012:	e0 81 0f 1a 	brne	80009e46 <_vfprintf_r+0x1f0a>
80008016:	82 68       	ld.sh	r8,r1[0xc]
80008018:	a7 a8       	sbr	r8,0x6
8000801a:	a2 68       	st.h	r1[0xc],r8
8000801c:	e0 8f 0f 15 	bral	80009e46 <_vfprintf_r+0x1f0a>
80008020:	30 08       	mov	r8,0
80008022:	fb 48 06 b4 	st.w	sp[1716],r8
80008026:	fb 48 06 90 	st.w	sp[1680],r8
8000802a:	fb 48 06 8c 	st.w	sp[1676],r8
8000802e:	fb 48 06 b0 	st.w	sp[1712],r8
80008032:	30 08       	mov	r8,0
80008034:	30 09       	mov	r9,0
80008036:	50 a7       	stdsp	sp[0x28],r7
80008038:	50 78       	stdsp	sp[0x1c],r8
8000803a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000803e:	3f f8       	mov	r8,-1
80008040:	50 59       	stdsp	sp[0x14],r9
80008042:	fb 43 06 88 	st.w	sp[1672],r3
80008046:	fb 48 05 44 	st.w	sp[1348],r8
8000804a:	12 9c       	mov	r12,r9
8000804c:	50 69       	stdsp	sp[0x18],r9
8000804e:	50 d9       	stdsp	sp[0x34],r9
80008050:	50 e9       	stdsp	sp[0x38],r9
80008052:	50 b9       	stdsp	sp[0x2c],r9
80008054:	12 97       	mov	r7,r9
80008056:	0a 94       	mov	r4,r5
80008058:	40 a2       	lddsp	r2,sp[0x28]
8000805a:	32 5a       	mov	r10,37
8000805c:	30 08       	mov	r8,0
8000805e:	c0 28       	rjmp	80008062 <_vfprintf_r+0x126>
80008060:	2f f2       	sub	r2,-1
80008062:	05 89       	ld.ub	r9,r2[0x0]
80008064:	f0 09 18 00 	cp.b	r9,r8
80008068:	5f 1b       	srne	r11
8000806a:	f4 09 18 00 	cp.b	r9,r10
8000806e:	5f 19       	srne	r9
80008070:	f3 eb 00 0b 	and	r11,r9,r11
80008074:	f0 0b 18 00 	cp.b	r11,r8
80008078:	cf 41       	brne	80008060 <_vfprintf_r+0x124>
8000807a:	40 ab       	lddsp	r11,sp[0x28]
8000807c:	e4 0b 01 06 	sub	r6,r2,r11
80008080:	c1 e0       	breq	800080bc <_vfprintf_r+0x180>
80008082:	fa f8 06 90 	ld.w	r8,sp[1680]
80008086:	0c 08       	add	r8,r6
80008088:	87 0b       	st.w	r3[0x0],r11
8000808a:	fb 48 06 90 	st.w	sp[1680],r8
8000808e:	87 16       	st.w	r3[0x4],r6
80008090:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008094:	2f f8       	sub	r8,-1
80008096:	fb 48 06 8c 	st.w	sp[1676],r8
8000809a:	58 78       	cp.w	r8,7
8000809c:	e0 89 00 04 	brgt	800080a4 <_vfprintf_r+0x168>
800080a0:	2f 83       	sub	r3,-8
800080a2:	c0 a8       	rjmp	800080b6 <_vfprintf_r+0x17a>
800080a4:	fa ca f9 78 	sub	r10,sp,-1672
800080a8:	02 9b       	mov	r11,r1
800080aa:	08 9c       	mov	r12,r4
800080ac:	c3 af       	rcall	80007f20 <__sprint_r>
800080ae:	e0 81 0e c6 	brne	80009e3a <_vfprintf_r+0x1efe>
800080b2:	fa c3 f9 e0 	sub	r3,sp,-1568
800080b6:	40 ba       	lddsp	r10,sp[0x2c]
800080b8:	0c 0a       	add	r10,r6
800080ba:	50 ba       	stdsp	sp[0x2c],r10
800080bc:	05 89       	ld.ub	r9,r2[0x0]
800080be:	30 08       	mov	r8,0
800080c0:	f0 09 18 00 	cp.b	r9,r8
800080c4:	e0 80 0e aa 	breq	80009e18 <_vfprintf_r+0x1edc>
800080c8:	30 09       	mov	r9,0
800080ca:	fb 68 06 bb 	st.b	sp[1723],r8
800080ce:	0e 96       	mov	r6,r7
800080d0:	e4 c8 ff ff 	sub	r8,r2,-1
800080d4:	3f fe       	mov	lr,-1
800080d6:	50 93       	stdsp	sp[0x24],r3
800080d8:	50 41       	stdsp	sp[0x10],r1
800080da:	0e 93       	mov	r3,r7
800080dc:	04 91       	mov	r1,r2
800080de:	50 89       	stdsp	sp[0x20],r9
800080e0:	50 a8       	stdsp	sp[0x28],r8
800080e2:	50 2e       	stdsp	sp[0x8],lr
800080e4:	50 39       	stdsp	sp[0xc],r9
800080e6:	12 95       	mov	r5,r9
800080e8:	12 90       	mov	r0,r9
800080ea:	10 97       	mov	r7,r8
800080ec:	08 92       	mov	r2,r4
800080ee:	c0 78       	rjmp	800080fc <_vfprintf_r+0x1c0>
800080f0:	3f fc       	mov	r12,-1
800080f2:	08 97       	mov	r7,r4
800080f4:	50 2c       	stdsp	sp[0x8],r12
800080f6:	c0 38       	rjmp	800080fc <_vfprintf_r+0x1c0>
800080f8:	30 0b       	mov	r11,0
800080fa:	50 3b       	stdsp	sp[0xc],r11
800080fc:	0f 38       	ld.ub	r8,r7++
800080fe:	c0 28       	rjmp	80008102 <_vfprintf_r+0x1c6>
80008100:	12 90       	mov	r0,r9
80008102:	f0 c9 00 20 	sub	r9,r8,32
80008106:	e0 49 00 58 	cp.w	r9,88
8000810a:	e0 8b 0a 30 	brhi	8000956a <_vfprintf_r+0x162e>
8000810e:	fe ca a5 c6 	sub	r10,pc,-23098
80008112:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80008116:	50 a7       	stdsp	sp[0x28],r7
80008118:	50 80       	stdsp	sp[0x20],r0
8000811a:	0c 97       	mov	r7,r6
8000811c:	04 94       	mov	r4,r2
8000811e:	06 96       	mov	r6,r3
80008120:	02 92       	mov	r2,r1
80008122:	fe c9 a3 9e 	sub	r9,pc,-23650
80008126:	40 93       	lddsp	r3,sp[0x24]
80008128:	10 90       	mov	r0,r8
8000812a:	40 41       	lddsp	r1,sp[0x10]
8000812c:	50 d9       	stdsp	sp[0x34],r9
8000812e:	e0 8f 08 8e 	bral	8000924a <_vfprintf_r+0x130e>
80008132:	30 08       	mov	r8,0
80008134:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80008138:	f0 09 18 00 	cp.b	r9,r8
8000813c:	ce 01       	brne	800080fc <_vfprintf_r+0x1c0>
8000813e:	32 08       	mov	r8,32
80008140:	c6 e8       	rjmp	8000821c <_vfprintf_r+0x2e0>
80008142:	a1 a5       	sbr	r5,0x0
80008144:	cd cb       	rjmp	800080fc <_vfprintf_r+0x1c0>
80008146:	0f 89       	ld.ub	r9,r7[0x0]
80008148:	f2 c8 00 30 	sub	r8,r9,48
8000814c:	58 98       	cp.w	r8,9
8000814e:	e0 8b 00 1d 	brhi	80008188 <_vfprintf_r+0x24c>
80008152:	ee c8 ff ff 	sub	r8,r7,-1
80008156:	30 0b       	mov	r11,0
80008158:	23 09       	sub	r9,48
8000815a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000815e:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80008162:	11 39       	ld.ub	r9,r8++
80008164:	f2 ca 00 30 	sub	r10,r9,48
80008168:	58 9a       	cp.w	r10,9
8000816a:	fe 98 ff f7 	brls	80008158 <_vfprintf_r+0x21c>
8000816e:	e0 49 00 24 	cp.w	r9,36
80008172:	cc 31       	brne	800080f8 <_vfprintf_r+0x1bc>
80008174:	e0 4b 00 20 	cp.w	r11,32
80008178:	e0 89 0e 60 	brgt	80009e38 <_vfprintf_r+0x1efc>
8000817c:	20 1b       	sub	r11,1
8000817e:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008182:	12 3b       	cp.w	r11,r9
80008184:	c0 95       	brlt	80008196 <_vfprintf_r+0x25a>
80008186:	c1 08       	rjmp	800081a6 <_vfprintf_r+0x26a>
80008188:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000818c:	ec ca ff ff 	sub	r10,r6,-1
80008190:	12 36       	cp.w	r6,r9
80008192:	c1 f5       	brlt	800081d0 <_vfprintf_r+0x294>
80008194:	c2 68       	rjmp	800081e0 <_vfprintf_r+0x2a4>
80008196:	fa ce f9 44 	sub	lr,sp,-1724
8000819a:	10 97       	mov	r7,r8
8000819c:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
800081a0:	f6 f0 fd 88 	ld.w	r0,r11[-632]
800081a4:	c3 58       	rjmp	8000820e <_vfprintf_r+0x2d2>
800081a6:	10 97       	mov	r7,r8
800081a8:	fa c8 f9 50 	sub	r8,sp,-1712
800081ac:	1a d8       	st.w	--sp,r8
800081ae:	fa c8 fa b8 	sub	r8,sp,-1352
800081b2:	1a d8       	st.w	--sp,r8
800081b4:	fa c8 fb b4 	sub	r8,sp,-1100
800081b8:	02 9a       	mov	r10,r1
800081ba:	1a d8       	st.w	--sp,r8
800081bc:	04 9c       	mov	r12,r2
800081be:	fa c8 f9 40 	sub	r8,sp,-1728
800081c2:	fa c9 ff b4 	sub	r9,sp,-76
800081c6:	fe b0 fd 23 	rcall	80007c0c <get_arg>
800081ca:	2f dd       	sub	sp,-12
800081cc:	78 00       	ld.w	r0,r12[0x0]
800081ce:	c2 08       	rjmp	8000820e <_vfprintf_r+0x2d2>
800081d0:	fa cc f9 44 	sub	r12,sp,-1724
800081d4:	14 96       	mov	r6,r10
800081d6:	f8 03 00 38 	add	r8,r12,r3<<0x3
800081da:	f0 f0 fd 88 	ld.w	r0,r8[-632]
800081de:	c1 88       	rjmp	8000820e <_vfprintf_r+0x2d2>
800081e0:	41 08       	lddsp	r8,sp[0x40]
800081e2:	59 f9       	cp.w	r9,31
800081e4:	e0 89 00 11 	brgt	80008206 <_vfprintf_r+0x2ca>
800081e8:	f0 cb ff fc 	sub	r11,r8,-4
800081ec:	51 0b       	stdsp	sp[0x40],r11
800081ee:	70 00       	ld.w	r0,r8[0x0]
800081f0:	fa cb f9 44 	sub	r11,sp,-1724
800081f4:	f6 09 00 38 	add	r8,r11,r9<<0x3
800081f8:	f1 40 fd 88 	st.w	r8[-632],r0
800081fc:	2f f9       	sub	r9,-1
800081fe:	14 96       	mov	r6,r10
80008200:	fb 49 06 b4 	st.w	sp[1716],r9
80008204:	c0 58       	rjmp	8000820e <_vfprintf_r+0x2d2>
80008206:	70 00       	ld.w	r0,r8[0x0]
80008208:	14 96       	mov	r6,r10
8000820a:	2f c8       	sub	r8,-4
8000820c:	51 08       	stdsp	sp[0x40],r8
8000820e:	58 00       	cp.w	r0,0
80008210:	fe 94 ff 76 	brge	800080fc <_vfprintf_r+0x1c0>
80008214:	5c 30       	neg	r0
80008216:	a3 a5       	sbr	r5,0x2
80008218:	c7 2b       	rjmp	800080fc <_vfprintf_r+0x1c0>
8000821a:	32 b8       	mov	r8,43
8000821c:	fb 68 06 bb 	st.b	sp[1723],r8
80008220:	c6 eb       	rjmp	800080fc <_vfprintf_r+0x1c0>
80008222:	0f 38       	ld.ub	r8,r7++
80008224:	e0 48 00 2a 	cp.w	r8,42
80008228:	c0 30       	breq	8000822e <_vfprintf_r+0x2f2>
8000822a:	30 09       	mov	r9,0
8000822c:	c7 98       	rjmp	8000831e <_vfprintf_r+0x3e2>
8000822e:	0f 88       	ld.ub	r8,r7[0x0]
80008230:	f0 c9 00 30 	sub	r9,r8,48
80008234:	58 99       	cp.w	r9,9
80008236:	e0 8b 00 1f 	brhi	80008274 <_vfprintf_r+0x338>
8000823a:	ee c4 ff ff 	sub	r4,r7,-1
8000823e:	30 0b       	mov	r11,0
80008240:	23 08       	sub	r8,48
80008242:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008246:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000824a:	09 38       	ld.ub	r8,r4++
8000824c:	f0 c9 00 30 	sub	r9,r8,48
80008250:	58 99       	cp.w	r9,9
80008252:	fe 98 ff f7 	brls	80008240 <_vfprintf_r+0x304>
80008256:	e0 48 00 24 	cp.w	r8,36
8000825a:	fe 91 ff 4f 	brne	800080f8 <_vfprintf_r+0x1bc>
8000825e:	e0 4b 00 20 	cp.w	r11,32
80008262:	e0 89 0d eb 	brgt	80009e38 <_vfprintf_r+0x1efc>
80008266:	20 1b       	sub	r11,1
80008268:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000826c:	10 3b       	cp.w	r11,r8
8000826e:	c0 a5       	brlt	80008282 <_vfprintf_r+0x346>
80008270:	c1 18       	rjmp	80008292 <_vfprintf_r+0x356>
80008272:	d7 03       	nop
80008274:	fa fa 06 b4 	ld.w	r10,sp[1716]
80008278:	ec c9 ff ff 	sub	r9,r6,-1
8000827c:	14 36       	cp.w	r6,r10
8000827e:	c1 f5       	brlt	800082bc <_vfprintf_r+0x380>
80008280:	c2 88       	rjmp	800082d0 <_vfprintf_r+0x394>
80008282:	fa ca f9 44 	sub	r10,sp,-1724
80008286:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000828a:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000828e:	50 2b       	stdsp	sp[0x8],r11
80008290:	c3 c8       	rjmp	80008308 <_vfprintf_r+0x3cc>
80008292:	fa c8 f9 50 	sub	r8,sp,-1712
80008296:	1a d8       	st.w	--sp,r8
80008298:	fa c8 fa b8 	sub	r8,sp,-1352
8000829c:	1a d8       	st.w	--sp,r8
8000829e:	fa c8 fb b4 	sub	r8,sp,-1100
800082a2:	02 9a       	mov	r10,r1
800082a4:	1a d8       	st.w	--sp,r8
800082a6:	04 9c       	mov	r12,r2
800082a8:	fa c8 f9 40 	sub	r8,sp,-1728
800082ac:	fa c9 ff b4 	sub	r9,sp,-76
800082b0:	fe b0 fc ae 	rcall	80007c0c <get_arg>
800082b4:	2f dd       	sub	sp,-12
800082b6:	78 0c       	ld.w	r12,r12[0x0]
800082b8:	50 2c       	stdsp	sp[0x8],r12
800082ba:	c2 78       	rjmp	80008308 <_vfprintf_r+0x3cc>
800082bc:	12 96       	mov	r6,r9
800082be:	0e 94       	mov	r4,r7
800082c0:	fa c9 f9 44 	sub	r9,sp,-1724
800082c4:	f2 03 00 38 	add	r8,r9,r3<<0x3
800082c8:	f0 f8 fd 88 	ld.w	r8,r8[-632]
800082cc:	50 28       	stdsp	sp[0x8],r8
800082ce:	c1 d8       	rjmp	80008308 <_vfprintf_r+0x3cc>
800082d0:	41 08       	lddsp	r8,sp[0x40]
800082d2:	59 fa       	cp.w	r10,31
800082d4:	e0 89 00 14 	brgt	800082fc <_vfprintf_r+0x3c0>
800082d8:	f0 cb ff fc 	sub	r11,r8,-4
800082dc:	70 08       	ld.w	r8,r8[0x0]
800082de:	51 0b       	stdsp	sp[0x40],r11
800082e0:	50 28       	stdsp	sp[0x8],r8
800082e2:	fa c6 f9 44 	sub	r6,sp,-1724
800082e6:	40 2e       	lddsp	lr,sp[0x8]
800082e8:	ec 0a 00 38 	add	r8,r6,r10<<0x3
800082ec:	f1 4e fd 88 	st.w	r8[-632],lr
800082f0:	2f fa       	sub	r10,-1
800082f2:	0e 94       	mov	r4,r7
800082f4:	fb 4a 06 b4 	st.w	sp[1716],r10
800082f8:	12 96       	mov	r6,r9
800082fa:	c0 78       	rjmp	80008308 <_vfprintf_r+0x3cc>
800082fc:	70 0c       	ld.w	r12,r8[0x0]
800082fe:	0e 94       	mov	r4,r7
80008300:	2f c8       	sub	r8,-4
80008302:	50 2c       	stdsp	sp[0x8],r12
80008304:	12 96       	mov	r6,r9
80008306:	51 08       	stdsp	sp[0x40],r8
80008308:	40 2b       	lddsp	r11,sp[0x8]
8000830a:	58 0b       	cp.w	r11,0
8000830c:	fe 95 fe f2 	brlt	800080f0 <_vfprintf_r+0x1b4>
80008310:	08 97       	mov	r7,r4
80008312:	cf 5a       	rjmp	800080fc <_vfprintf_r+0x1c0>
80008314:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008318:	0f 38       	ld.ub	r8,r7++
8000831a:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000831e:	f0 ca 00 30 	sub	r10,r8,48
80008322:	58 9a       	cp.w	r10,9
80008324:	fe 98 ff f8 	brls	80008314 <_vfprintf_r+0x3d8>
80008328:	3f fa       	mov	r10,-1
8000832a:	f2 0a 0c 49 	max	r9,r9,r10
8000832e:	50 29       	stdsp	sp[0x8],r9
80008330:	ce 9a       	rjmp	80008102 <_vfprintf_r+0x1c6>
80008332:	a7 b5       	sbr	r5,0x7
80008334:	ce 4a       	rjmp	800080fc <_vfprintf_r+0x1c0>
80008336:	30 09       	mov	r9,0
80008338:	23 08       	sub	r8,48
8000833a:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000833e:	f0 09 00 19 	add	r9,r8,r9<<0x1
80008342:	0f 38       	ld.ub	r8,r7++
80008344:	f0 ca 00 30 	sub	r10,r8,48
80008348:	58 9a       	cp.w	r10,9
8000834a:	fe 98 ff f7 	brls	80008338 <_vfprintf_r+0x3fc>
8000834e:	e0 48 00 24 	cp.w	r8,36
80008352:	fe 91 fe d7 	brne	80008100 <_vfprintf_r+0x1c4>
80008356:	e0 49 00 20 	cp.w	r9,32
8000835a:	e0 89 0d 6f 	brgt	80009e38 <_vfprintf_r+0x1efc>
8000835e:	f2 c3 00 01 	sub	r3,r9,1
80008362:	30 19       	mov	r9,1
80008364:	50 39       	stdsp	sp[0xc],r9
80008366:	cc ba       	rjmp	800080fc <_vfprintf_r+0x1c0>
80008368:	a3 b5       	sbr	r5,0x3
8000836a:	cc 9a       	rjmp	800080fc <_vfprintf_r+0x1c0>
8000836c:	a7 a5       	sbr	r5,0x6
8000836e:	cc 7a       	rjmp	800080fc <_vfprintf_r+0x1c0>
80008370:	0a 98       	mov	r8,r5
80008372:	a5 b5       	sbr	r5,0x5
80008374:	a5 a8       	sbr	r8,0x4
80008376:	0f 89       	ld.ub	r9,r7[0x0]
80008378:	36 ce       	mov	lr,108
8000837a:	fc 09 18 00 	cp.b	r9,lr
8000837e:	f7 b7 00 ff 	subeq	r7,-1
80008382:	f0 05 17 10 	movne	r5,r8
80008386:	cb ba       	rjmp	800080fc <_vfprintf_r+0x1c0>
80008388:	a5 b5       	sbr	r5,0x5
8000838a:	cb 9a       	rjmp	800080fc <_vfprintf_r+0x1c0>
8000838c:	50 a7       	stdsp	sp[0x28],r7
8000838e:	50 80       	stdsp	sp[0x20],r0
80008390:	0c 97       	mov	r7,r6
80008392:	10 90       	mov	r0,r8
80008394:	06 96       	mov	r6,r3
80008396:	04 94       	mov	r4,r2
80008398:	40 93       	lddsp	r3,sp[0x24]
8000839a:	02 92       	mov	r2,r1
8000839c:	0e 99       	mov	r9,r7
8000839e:	40 41       	lddsp	r1,sp[0x10]
800083a0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800083a4:	40 3c       	lddsp	r12,sp[0xc]
800083a6:	58 0c       	cp.w	r12,0
800083a8:	c1 d0       	breq	800083e2 <_vfprintf_r+0x4a6>
800083aa:	10 36       	cp.w	r6,r8
800083ac:	c0 64       	brge	800083b8 <_vfprintf_r+0x47c>
800083ae:	fa cb f9 44 	sub	r11,sp,-1724
800083b2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800083b6:	c1 d8       	rjmp	800083f0 <_vfprintf_r+0x4b4>
800083b8:	fa c8 f9 50 	sub	r8,sp,-1712
800083bc:	1a d8       	st.w	--sp,r8
800083be:	fa c8 fa b8 	sub	r8,sp,-1352
800083c2:	1a d8       	st.w	--sp,r8
800083c4:	fa c8 fb b4 	sub	r8,sp,-1100
800083c8:	1a d8       	st.w	--sp,r8
800083ca:	fa c8 f9 40 	sub	r8,sp,-1728
800083ce:	fa c9 ff b4 	sub	r9,sp,-76
800083d2:	04 9a       	mov	r10,r2
800083d4:	0c 9b       	mov	r11,r6
800083d6:	08 9c       	mov	r12,r4
800083d8:	fe b0 fc 1a 	rcall	80007c0c <get_arg>
800083dc:	2f dd       	sub	sp,-12
800083de:	19 b8       	ld.ub	r8,r12[0x3]
800083e0:	c2 28       	rjmp	80008424 <_vfprintf_r+0x4e8>
800083e2:	2f f7       	sub	r7,-1
800083e4:	10 39       	cp.w	r9,r8
800083e6:	c0 84       	brge	800083f6 <_vfprintf_r+0x4ba>
800083e8:	fa ca f9 44 	sub	r10,sp,-1724
800083ec:	f4 06 00 36 	add	r6,r10,r6<<0x3
800083f0:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
800083f4:	c1 88       	rjmp	80008424 <_vfprintf_r+0x4e8>
800083f6:	41 09       	lddsp	r9,sp[0x40]
800083f8:	59 f8       	cp.w	r8,31
800083fa:	e0 89 00 12 	brgt	8000841e <_vfprintf_r+0x4e2>
800083fe:	f2 ca ff fc 	sub	r10,r9,-4
80008402:	51 0a       	stdsp	sp[0x40],r10
80008404:	72 09       	ld.w	r9,r9[0x0]
80008406:	fa c6 f9 44 	sub	r6,sp,-1724
8000840a:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000840e:	2f f8       	sub	r8,-1
80008410:	f5 49 fd 88 	st.w	r10[-632],r9
80008414:	fb 48 06 b4 	st.w	sp[1716],r8
80008418:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000841c:	c0 48       	rjmp	80008424 <_vfprintf_r+0x4e8>
8000841e:	13 b8       	ld.ub	r8,r9[0x3]
80008420:	2f c9       	sub	r9,-4
80008422:	51 09       	stdsp	sp[0x40],r9
80008424:	fb 68 06 60 	st.b	sp[1632],r8
80008428:	30 0e       	mov	lr,0
8000842a:	30 08       	mov	r8,0
8000842c:	30 12       	mov	r2,1
8000842e:	fb 68 06 bb 	st.b	sp[1723],r8
80008432:	50 2e       	stdsp	sp[0x8],lr
80008434:	e0 8f 08 ad 	bral	8000958e <_vfprintf_r+0x1652>
80008438:	50 a7       	stdsp	sp[0x28],r7
8000843a:	50 80       	stdsp	sp[0x20],r0
8000843c:	0c 97       	mov	r7,r6
8000843e:	04 94       	mov	r4,r2
80008440:	06 96       	mov	r6,r3
80008442:	02 92       	mov	r2,r1
80008444:	40 93       	lddsp	r3,sp[0x24]
80008446:	10 90       	mov	r0,r8
80008448:	40 41       	lddsp	r1,sp[0x10]
8000844a:	a5 a5       	sbr	r5,0x4
8000844c:	c0 a8       	rjmp	80008460 <_vfprintf_r+0x524>
8000844e:	50 a7       	stdsp	sp[0x28],r7
80008450:	50 80       	stdsp	sp[0x20],r0
80008452:	0c 97       	mov	r7,r6
80008454:	04 94       	mov	r4,r2
80008456:	06 96       	mov	r6,r3
80008458:	02 92       	mov	r2,r1
8000845a:	40 93       	lddsp	r3,sp[0x24]
8000845c:	10 90       	mov	r0,r8
8000845e:	40 41       	lddsp	r1,sp[0x10]
80008460:	ed b5 00 05 	bld	r5,0x5
80008464:	c5 11       	brne	80008506 <_vfprintf_r+0x5ca>
80008466:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000846a:	40 3c       	lddsp	r12,sp[0xc]
8000846c:	58 0c       	cp.w	r12,0
8000846e:	c1 e0       	breq	800084aa <_vfprintf_r+0x56e>
80008470:	10 36       	cp.w	r6,r8
80008472:	c0 64       	brge	8000847e <_vfprintf_r+0x542>
80008474:	fa cb f9 44 	sub	r11,sp,-1724
80008478:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000847c:	c2 08       	rjmp	800084bc <_vfprintf_r+0x580>
8000847e:	fa c8 f9 50 	sub	r8,sp,-1712
80008482:	1a d8       	st.w	--sp,r8
80008484:	fa c8 fa b8 	sub	r8,sp,-1352
80008488:	0c 9b       	mov	r11,r6
8000848a:	1a d8       	st.w	--sp,r8
8000848c:	fa c8 fb b4 	sub	r8,sp,-1100
80008490:	1a d8       	st.w	--sp,r8
80008492:	fa c9 ff b4 	sub	r9,sp,-76
80008496:	fa c8 f9 40 	sub	r8,sp,-1728
8000849a:	04 9a       	mov	r10,r2
8000849c:	08 9c       	mov	r12,r4
8000849e:	fe b0 fb b7 	rcall	80007c0c <get_arg>
800084a2:	2f dd       	sub	sp,-12
800084a4:	78 1b       	ld.w	r11,r12[0x4]
800084a6:	78 09       	ld.w	r9,r12[0x0]
800084a8:	c2 b8       	rjmp	800084fe <_vfprintf_r+0x5c2>
800084aa:	ee ca ff ff 	sub	r10,r7,-1
800084ae:	10 37       	cp.w	r7,r8
800084b0:	c0 b4       	brge	800084c6 <_vfprintf_r+0x58a>
800084b2:	fa c9 f9 44 	sub	r9,sp,-1724
800084b6:	14 97       	mov	r7,r10
800084b8:	f2 06 00 36 	add	r6,r9,r6<<0x3
800084bc:	ec fb fd 8c 	ld.w	r11,r6[-628]
800084c0:	ec f9 fd 88 	ld.w	r9,r6[-632]
800084c4:	c1 d8       	rjmp	800084fe <_vfprintf_r+0x5c2>
800084c6:	41 09       	lddsp	r9,sp[0x40]
800084c8:	59 f8       	cp.w	r8,31
800084ca:	e0 89 00 14 	brgt	800084f2 <_vfprintf_r+0x5b6>
800084ce:	f2 cb ff f8 	sub	r11,r9,-8
800084d2:	51 0b       	stdsp	sp[0x40],r11
800084d4:	fa c6 f9 44 	sub	r6,sp,-1724
800084d8:	72 1b       	ld.w	r11,r9[0x4]
800084da:	ec 08 00 3c 	add	r12,r6,r8<<0x3
800084de:	72 09       	ld.w	r9,r9[0x0]
800084e0:	f9 4b fd 8c 	st.w	r12[-628],r11
800084e4:	f9 49 fd 88 	st.w	r12[-632],r9
800084e8:	2f f8       	sub	r8,-1
800084ea:	14 97       	mov	r7,r10
800084ec:	fb 48 06 b4 	st.w	sp[1716],r8
800084f0:	c0 78       	rjmp	800084fe <_vfprintf_r+0x5c2>
800084f2:	f2 c8 ff f8 	sub	r8,r9,-8
800084f6:	72 1b       	ld.w	r11,r9[0x4]
800084f8:	14 97       	mov	r7,r10
800084fa:	51 08       	stdsp	sp[0x40],r8
800084fc:	72 09       	ld.w	r9,r9[0x0]
800084fe:	16 98       	mov	r8,r11
80008500:	fa e9 00 00 	st.d	sp[0],r8
80008504:	ca e8       	rjmp	80008660 <_vfprintf_r+0x724>
80008506:	ed b5 00 04 	bld	r5,0x4
8000850a:	c1 71       	brne	80008538 <_vfprintf_r+0x5fc>
8000850c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008510:	40 3e       	lddsp	lr,sp[0xc]
80008512:	58 0e       	cp.w	lr,0
80008514:	c0 80       	breq	80008524 <_vfprintf_r+0x5e8>
80008516:	10 36       	cp.w	r6,r8
80008518:	c6 94       	brge	800085ea <_vfprintf_r+0x6ae>
8000851a:	fa cc f9 44 	sub	r12,sp,-1724
8000851e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008522:	c8 28       	rjmp	80008626 <_vfprintf_r+0x6ea>
80008524:	ee ca ff ff 	sub	r10,r7,-1
80008528:	10 37       	cp.w	r7,r8
8000852a:	e0 84 00 81 	brge	8000862c <_vfprintf_r+0x6f0>
8000852e:	fa cb f9 44 	sub	r11,sp,-1724
80008532:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008536:	c7 78       	rjmp	80008624 <_vfprintf_r+0x6e8>
80008538:	ed b5 00 06 	bld	r5,0x6
8000853c:	c4 b1       	brne	800085d2 <_vfprintf_r+0x696>
8000853e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008542:	40 3c       	lddsp	r12,sp[0xc]
80008544:	58 0c       	cp.w	r12,0
80008546:	c1 d0       	breq	80008580 <_vfprintf_r+0x644>
80008548:	10 36       	cp.w	r6,r8
8000854a:	c0 64       	brge	80008556 <_vfprintf_r+0x61a>
8000854c:	fa cb f9 44 	sub	r11,sp,-1724
80008550:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008554:	c1 f8       	rjmp	80008592 <_vfprintf_r+0x656>
80008556:	fa c8 f9 50 	sub	r8,sp,-1712
8000855a:	1a d8       	st.w	--sp,r8
8000855c:	fa c8 fa b8 	sub	r8,sp,-1352
80008560:	1a d8       	st.w	--sp,r8
80008562:	fa c8 fb b4 	sub	r8,sp,-1100
80008566:	1a d8       	st.w	--sp,r8
80008568:	fa c8 f9 40 	sub	r8,sp,-1728
8000856c:	fa c9 ff b4 	sub	r9,sp,-76
80008570:	04 9a       	mov	r10,r2
80008572:	0c 9b       	mov	r11,r6
80008574:	08 9c       	mov	r12,r4
80008576:	fe b0 fb 4b 	rcall	80007c0c <get_arg>
8000857a:	2f dd       	sub	sp,-12
8000857c:	98 18       	ld.sh	r8,r12[0x2]
8000857e:	c2 68       	rjmp	800085ca <_vfprintf_r+0x68e>
80008580:	ee ca ff ff 	sub	r10,r7,-1
80008584:	10 37       	cp.w	r7,r8
80008586:	c0 94       	brge	80008598 <_vfprintf_r+0x65c>
80008588:	fa c9 f9 44 	sub	r9,sp,-1724
8000858c:	14 97       	mov	r7,r10
8000858e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008592:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008596:	c1 a8       	rjmp	800085ca <_vfprintf_r+0x68e>
80008598:	41 09       	lddsp	r9,sp[0x40]
8000859a:	59 f8       	cp.w	r8,31
8000859c:	e0 89 00 13 	brgt	800085c2 <_vfprintf_r+0x686>
800085a0:	f2 cb ff fc 	sub	r11,r9,-4
800085a4:	51 0b       	stdsp	sp[0x40],r11
800085a6:	72 09       	ld.w	r9,r9[0x0]
800085a8:	fa c6 f9 44 	sub	r6,sp,-1724
800085ac:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800085b0:	2f f8       	sub	r8,-1
800085b2:	f7 49 fd 88 	st.w	r11[-632],r9
800085b6:	fb 48 06 b4 	st.w	sp[1716],r8
800085ba:	14 97       	mov	r7,r10
800085bc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800085c0:	c0 58       	rjmp	800085ca <_vfprintf_r+0x68e>
800085c2:	92 18       	ld.sh	r8,r9[0x2]
800085c4:	14 97       	mov	r7,r10
800085c6:	2f c9       	sub	r9,-4
800085c8:	51 09       	stdsp	sp[0x40],r9
800085ca:	50 18       	stdsp	sp[0x4],r8
800085cc:	bf 58       	asr	r8,0x1f
800085ce:	50 08       	stdsp	sp[0x0],r8
800085d0:	c4 88       	rjmp	80008660 <_vfprintf_r+0x724>
800085d2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800085d6:	40 3c       	lddsp	r12,sp[0xc]
800085d8:	58 0c       	cp.w	r12,0
800085da:	c1 d0       	breq	80008614 <_vfprintf_r+0x6d8>
800085dc:	10 36       	cp.w	r6,r8
800085de:	c0 64       	brge	800085ea <_vfprintf_r+0x6ae>
800085e0:	fa cb f9 44 	sub	r11,sp,-1724
800085e4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800085e8:	c1 f8       	rjmp	80008626 <_vfprintf_r+0x6ea>
800085ea:	fa c8 f9 50 	sub	r8,sp,-1712
800085ee:	1a d8       	st.w	--sp,r8
800085f0:	fa c8 fa b8 	sub	r8,sp,-1352
800085f4:	0c 9b       	mov	r11,r6
800085f6:	1a d8       	st.w	--sp,r8
800085f8:	fa c8 fb b4 	sub	r8,sp,-1100
800085fc:	04 9a       	mov	r10,r2
800085fe:	1a d8       	st.w	--sp,r8
80008600:	08 9c       	mov	r12,r4
80008602:	fa c8 f9 40 	sub	r8,sp,-1728
80008606:	fa c9 ff b4 	sub	r9,sp,-76
8000860a:	fe b0 fb 01 	rcall	80007c0c <get_arg>
8000860e:	2f dd       	sub	sp,-12
80008610:	78 0b       	ld.w	r11,r12[0x0]
80008612:	c2 48       	rjmp	8000865a <_vfprintf_r+0x71e>
80008614:	ee ca ff ff 	sub	r10,r7,-1
80008618:	10 37       	cp.w	r7,r8
8000861a:	c0 94       	brge	8000862c <_vfprintf_r+0x6f0>
8000861c:	fa c9 f9 44 	sub	r9,sp,-1724
80008620:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008624:	14 97       	mov	r7,r10
80008626:	ec fb fd 88 	ld.w	r11,r6[-632]
8000862a:	c1 88       	rjmp	8000865a <_vfprintf_r+0x71e>
8000862c:	41 09       	lddsp	r9,sp[0x40]
8000862e:	59 f8       	cp.w	r8,31
80008630:	e0 89 00 11 	brgt	80008652 <_vfprintf_r+0x716>
80008634:	f2 cb ff fc 	sub	r11,r9,-4
80008638:	51 0b       	stdsp	sp[0x40],r11
8000863a:	fa c6 f9 44 	sub	r6,sp,-1724
8000863e:	72 0b       	ld.w	r11,r9[0x0]
80008640:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008644:	f3 4b fd 88 	st.w	r9[-632],r11
80008648:	2f f8       	sub	r8,-1
8000864a:	14 97       	mov	r7,r10
8000864c:	fb 48 06 b4 	st.w	sp[1716],r8
80008650:	c0 58       	rjmp	8000865a <_vfprintf_r+0x71e>
80008652:	72 0b       	ld.w	r11,r9[0x0]
80008654:	14 97       	mov	r7,r10
80008656:	2f c9       	sub	r9,-4
80008658:	51 09       	stdsp	sp[0x40],r9
8000865a:	50 1b       	stdsp	sp[0x4],r11
8000865c:	bf 5b       	asr	r11,0x1f
8000865e:	50 0b       	stdsp	sp[0x0],r11
80008660:	fa ea 00 00 	ld.d	r10,sp[0]
80008664:	58 0a       	cp.w	r10,0
80008666:	5c 2b       	cpc	r11
80008668:	c0 e4       	brge	80008684 <_vfprintf_r+0x748>
8000866a:	30 08       	mov	r8,0
8000866c:	fa ea 00 00 	ld.d	r10,sp[0]
80008670:	30 09       	mov	r9,0
80008672:	f0 0a 01 0a 	sub	r10,r8,r10
80008676:	f2 0b 01 4b 	sbc	r11,r9,r11
8000867a:	32 d8       	mov	r8,45
8000867c:	fa eb 00 00 	st.d	sp[0],r10
80008680:	fb 68 06 bb 	st.b	sp[1723],r8
80008684:	30 18       	mov	r8,1
80008686:	e0 8f 06 fa 	bral	8000947a <_vfprintf_r+0x153e>
8000868a:	50 a7       	stdsp	sp[0x28],r7
8000868c:	50 80       	stdsp	sp[0x20],r0
8000868e:	0c 97       	mov	r7,r6
80008690:	04 94       	mov	r4,r2
80008692:	06 96       	mov	r6,r3
80008694:	02 92       	mov	r2,r1
80008696:	40 93       	lddsp	r3,sp[0x24]
80008698:	10 90       	mov	r0,r8
8000869a:	40 41       	lddsp	r1,sp[0x10]
8000869c:	0e 99       	mov	r9,r7
8000869e:	ed b5 00 03 	bld	r5,0x3
800086a2:	c4 11       	brne	80008724 <_vfprintf_r+0x7e8>
800086a4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086a8:	40 3a       	lddsp	r10,sp[0xc]
800086aa:	58 0a       	cp.w	r10,0
800086ac:	c1 90       	breq	800086de <_vfprintf_r+0x7a2>
800086ae:	10 36       	cp.w	r6,r8
800086b0:	c6 45       	brlt	80008778 <_vfprintf_r+0x83c>
800086b2:	fa c8 f9 50 	sub	r8,sp,-1712
800086b6:	1a d8       	st.w	--sp,r8
800086b8:	fa c8 fa b8 	sub	r8,sp,-1352
800086bc:	1a d8       	st.w	--sp,r8
800086be:	fa c8 fb b4 	sub	r8,sp,-1100
800086c2:	0c 9b       	mov	r11,r6
800086c4:	1a d8       	st.w	--sp,r8
800086c6:	04 9a       	mov	r10,r2
800086c8:	fa c8 f9 40 	sub	r8,sp,-1728
800086cc:	fa c9 ff b4 	sub	r9,sp,-76
800086d0:	08 9c       	mov	r12,r4
800086d2:	fe b0 fa 9d 	rcall	80007c0c <get_arg>
800086d6:	2f dd       	sub	sp,-12
800086d8:	78 16       	ld.w	r6,r12[0x4]
800086da:	50 76       	stdsp	sp[0x1c],r6
800086dc:	c4 88       	rjmp	8000876c <_vfprintf_r+0x830>
800086de:	2f f7       	sub	r7,-1
800086e0:	10 39       	cp.w	r9,r8
800086e2:	c0 c4       	brge	800086fa <_vfprintf_r+0x7be>
800086e4:	fa ce f9 44 	sub	lr,sp,-1724
800086e8:	fc 06 00 36 	add	r6,lr,r6<<0x3
800086ec:	ec fc fd 8c 	ld.w	r12,r6[-628]
800086f0:	50 7c       	stdsp	sp[0x1c],r12
800086f2:	ec f6 fd 88 	ld.w	r6,r6[-632]
800086f6:	50 56       	stdsp	sp[0x14],r6
800086f8:	c6 68       	rjmp	800087c4 <_vfprintf_r+0x888>
800086fa:	41 09       	lddsp	r9,sp[0x40]
800086fc:	59 f8       	cp.w	r8,31
800086fe:	e0 89 00 10 	brgt	8000871e <_vfprintf_r+0x7e2>
80008702:	f2 ca ff f8 	sub	r10,r9,-8
80008706:	72 1b       	ld.w	r11,r9[0x4]
80008708:	51 0a       	stdsp	sp[0x40],r10
8000870a:	72 09       	ld.w	r9,r9[0x0]
8000870c:	fa ca f9 44 	sub	r10,sp,-1724
80008710:	50 7b       	stdsp	sp[0x1c],r11
80008712:	50 59       	stdsp	sp[0x14],r9
80008714:	f4 08 00 39 	add	r9,r10,r8<<0x3
80008718:	40 5b       	lddsp	r11,sp[0x14]
8000871a:	40 7a       	lddsp	r10,sp[0x1c]
8000871c:	c4 78       	rjmp	800087aa <_vfprintf_r+0x86e>
8000871e:	72 18       	ld.w	r8,r9[0x4]
80008720:	50 78       	stdsp	sp[0x1c],r8
80008722:	c4 c8       	rjmp	800087ba <_vfprintf_r+0x87e>
80008724:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008728:	40 3e       	lddsp	lr,sp[0xc]
8000872a:	58 0e       	cp.w	lr,0
8000872c:	c2 30       	breq	80008772 <_vfprintf_r+0x836>
8000872e:	10 36       	cp.w	r6,r8
80008730:	c0 94       	brge	80008742 <_vfprintf_r+0x806>
80008732:	fa cc f9 44 	sub	r12,sp,-1724
80008736:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000873a:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000873e:	50 7b       	stdsp	sp[0x1c],r11
80008740:	cd 9b       	rjmp	800086f2 <_vfprintf_r+0x7b6>
80008742:	fa c8 f9 50 	sub	r8,sp,-1712
80008746:	1a d8       	st.w	--sp,r8
80008748:	fa c8 fa b8 	sub	r8,sp,-1352
8000874c:	04 9a       	mov	r10,r2
8000874e:	1a d8       	st.w	--sp,r8
80008750:	fa c8 fb b4 	sub	r8,sp,-1100
80008754:	0c 9b       	mov	r11,r6
80008756:	1a d8       	st.w	--sp,r8
80008758:	08 9c       	mov	r12,r4
8000875a:	fa c8 f9 40 	sub	r8,sp,-1728
8000875e:	fa c9 ff b4 	sub	r9,sp,-76
80008762:	fe b0 fa 55 	rcall	80007c0c <get_arg>
80008766:	2f dd       	sub	sp,-12
80008768:	78 1a       	ld.w	r10,r12[0x4]
8000876a:	50 7a       	stdsp	sp[0x1c],r10
8000876c:	78 0c       	ld.w	r12,r12[0x0]
8000876e:	50 5c       	stdsp	sp[0x14],r12
80008770:	c2 a8       	rjmp	800087c4 <_vfprintf_r+0x888>
80008772:	2f f7       	sub	r7,-1
80008774:	10 39       	cp.w	r9,r8
80008776:	c0 94       	brge	80008788 <_vfprintf_r+0x84c>
80008778:	fa c9 f9 44 	sub	r9,sp,-1724
8000877c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008780:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80008784:	50 78       	stdsp	sp[0x1c],r8
80008786:	cb 6b       	rjmp	800086f2 <_vfprintf_r+0x7b6>
80008788:	41 09       	lddsp	r9,sp[0x40]
8000878a:	59 f8       	cp.w	r8,31
8000878c:	e0 89 00 15 	brgt	800087b6 <_vfprintf_r+0x87a>
80008790:	f2 ca ff f8 	sub	r10,r9,-8
80008794:	72 16       	ld.w	r6,r9[0x4]
80008796:	72 09       	ld.w	r9,r9[0x0]
80008798:	51 0a       	stdsp	sp[0x40],r10
8000879a:	50 59       	stdsp	sp[0x14],r9
8000879c:	fa ce f9 44 	sub	lr,sp,-1724
800087a0:	50 76       	stdsp	sp[0x1c],r6
800087a2:	fc 08 00 39 	add	r9,lr,r8<<0x3
800087a6:	40 5b       	lddsp	r11,sp[0x14]
800087a8:	0c 9a       	mov	r10,r6
800087aa:	f2 eb fd 88 	st.d	r9[-632],r10
800087ae:	2f f8       	sub	r8,-1
800087b0:	fb 48 06 b4 	st.w	sp[1716],r8
800087b4:	c0 88       	rjmp	800087c4 <_vfprintf_r+0x888>
800087b6:	72 1c       	ld.w	r12,r9[0x4]
800087b8:	50 7c       	stdsp	sp[0x1c],r12
800087ba:	f2 c8 ff f8 	sub	r8,r9,-8
800087be:	51 08       	stdsp	sp[0x40],r8
800087c0:	72 09       	ld.w	r9,r9[0x0]
800087c2:	50 59       	stdsp	sp[0x14],r9
800087c4:	40 5b       	lddsp	r11,sp[0x14]
800087c6:	40 7a       	lddsp	r10,sp[0x1c]
800087c8:	e0 a0 19 54 	rcall	8000ba70 <__isinfd>
800087cc:	18 96       	mov	r6,r12
800087ce:	c1 70       	breq	800087fc <_vfprintf_r+0x8c0>
800087d0:	30 08       	mov	r8,0
800087d2:	30 09       	mov	r9,0
800087d4:	40 5b       	lddsp	r11,sp[0x14]
800087d6:	40 7a       	lddsp	r10,sp[0x1c]
800087d8:	e0 a0 1d b4 	rcall	8000c340 <__avr32_f64_cmp_lt>
800087dc:	c0 40       	breq	800087e4 <_vfprintf_r+0x8a8>
800087de:	32 d8       	mov	r8,45
800087e0:	fb 68 06 bb 	st.b	sp[1723],r8
800087e4:	fe c8 aa 4c 	sub	r8,pc,-21940
800087e8:	fe c6 aa 4c 	sub	r6,pc,-21940
800087ec:	a7 d5       	cbr	r5,0x7
800087ee:	e0 40 00 47 	cp.w	r0,71
800087f2:	f0 06 17 a0 	movle	r6,r8
800087f6:	30 32       	mov	r2,3
800087f8:	e0 8f 06 ce 	bral	80009594 <_vfprintf_r+0x1658>
800087fc:	40 5b       	lddsp	r11,sp[0x14]
800087fe:	40 7a       	lddsp	r10,sp[0x1c]
80008800:	e0 a0 19 4d 	rcall	8000ba9a <__isnand>
80008804:	c0 e0       	breq	80008820 <_vfprintf_r+0x8e4>
80008806:	50 26       	stdsp	sp[0x8],r6
80008808:	fe c8 aa 68 	sub	r8,pc,-21912
8000880c:	fe c6 aa 68 	sub	r6,pc,-21912
80008810:	a7 d5       	cbr	r5,0x7
80008812:	e0 40 00 47 	cp.w	r0,71
80008816:	f0 06 17 a0 	movle	r6,r8
8000881a:	30 32       	mov	r2,3
8000881c:	e0 8f 06 c2 	bral	800095a0 <_vfprintf_r+0x1664>
80008820:	40 2a       	lddsp	r10,sp[0x8]
80008822:	5b fa       	cp.w	r10,-1
80008824:	c0 41       	brne	8000882c <_vfprintf_r+0x8f0>
80008826:	30 69       	mov	r9,6
80008828:	50 29       	stdsp	sp[0x8],r9
8000882a:	c1 18       	rjmp	8000884c <_vfprintf_r+0x910>
8000882c:	e0 40 00 47 	cp.w	r0,71
80008830:	5f 09       	sreq	r9
80008832:	e0 40 00 67 	cp.w	r0,103
80008836:	5f 08       	sreq	r8
80008838:	f3 e8 10 08 	or	r8,r9,r8
8000883c:	f8 08 18 00 	cp.b	r8,r12
80008840:	c0 60       	breq	8000884c <_vfprintf_r+0x910>
80008842:	40 28       	lddsp	r8,sp[0x8]
80008844:	58 08       	cp.w	r8,0
80008846:	f9 b8 00 01 	moveq	r8,1
8000884a:	50 28       	stdsp	sp[0x8],r8
8000884c:	40 78       	lddsp	r8,sp[0x1c]
8000884e:	40 59       	lddsp	r9,sp[0x14]
80008850:	fa e9 06 94 	st.d	sp[1684],r8
80008854:	a9 a5       	sbr	r5,0x8
80008856:	fa f8 06 94 	ld.w	r8,sp[1684]
8000885a:	58 08       	cp.w	r8,0
8000885c:	c0 65       	brlt	80008868 <_vfprintf_r+0x92c>
8000885e:	40 5e       	lddsp	lr,sp[0x14]
80008860:	30 0c       	mov	r12,0
80008862:	50 6e       	stdsp	sp[0x18],lr
80008864:	50 9c       	stdsp	sp[0x24],r12
80008866:	c0 78       	rjmp	80008874 <_vfprintf_r+0x938>
80008868:	40 5b       	lddsp	r11,sp[0x14]
8000886a:	32 da       	mov	r10,45
8000886c:	ee 1b 80 00 	eorh	r11,0x8000
80008870:	50 9a       	stdsp	sp[0x24],r10
80008872:	50 6b       	stdsp	sp[0x18],r11
80008874:	e0 40 00 46 	cp.w	r0,70
80008878:	5f 09       	sreq	r9
8000887a:	e0 40 00 66 	cp.w	r0,102
8000887e:	5f 08       	sreq	r8
80008880:	f3 e8 10 08 	or	r8,r9,r8
80008884:	50 48       	stdsp	sp[0x10],r8
80008886:	c0 40       	breq	8000888e <_vfprintf_r+0x952>
80008888:	40 22       	lddsp	r2,sp[0x8]
8000888a:	30 39       	mov	r9,3
8000888c:	c1 08       	rjmp	800088ac <_vfprintf_r+0x970>
8000888e:	e0 40 00 45 	cp.w	r0,69
80008892:	5f 09       	sreq	r9
80008894:	e0 40 00 65 	cp.w	r0,101
80008898:	5f 08       	sreq	r8
8000889a:	40 22       	lddsp	r2,sp[0x8]
8000889c:	10 49       	or	r9,r8
8000889e:	2f f2       	sub	r2,-1
800088a0:	40 46       	lddsp	r6,sp[0x10]
800088a2:	ec 09 18 00 	cp.b	r9,r6
800088a6:	fb f2 00 02 	ld.weq	r2,sp[0x8]
800088aa:	30 29       	mov	r9,2
800088ac:	fa c8 f9 5c 	sub	r8,sp,-1700
800088b0:	1a d8       	st.w	--sp,r8
800088b2:	fa c8 f9 54 	sub	r8,sp,-1708
800088b6:	1a d8       	st.w	--sp,r8
800088b8:	fa c8 f9 4c 	sub	r8,sp,-1716
800088bc:	08 9c       	mov	r12,r4
800088be:	1a d8       	st.w	--sp,r8
800088c0:	04 98       	mov	r8,r2
800088c2:	40 9b       	lddsp	r11,sp[0x24]
800088c4:	40 aa       	lddsp	r10,sp[0x28]
800088c6:	e0 a0 0b c3 	rcall	8000a04c <_dtoa_r>
800088ca:	e0 40 00 47 	cp.w	r0,71
800088ce:	5f 19       	srne	r9
800088d0:	e0 40 00 67 	cp.w	r0,103
800088d4:	5f 18       	srne	r8
800088d6:	18 96       	mov	r6,r12
800088d8:	2f dd       	sub	sp,-12
800088da:	f3 e8 00 08 	and	r8,r9,r8
800088de:	c0 41       	brne	800088e6 <_vfprintf_r+0x9aa>
800088e0:	ed b5 00 00 	bld	r5,0x0
800088e4:	c3 01       	brne	80008944 <_vfprintf_r+0xa08>
800088e6:	ec 02 00 0e 	add	lr,r6,r2
800088ea:	50 3e       	stdsp	sp[0xc],lr
800088ec:	40 4c       	lddsp	r12,sp[0x10]
800088ee:	58 0c       	cp.w	r12,0
800088f0:	c1 50       	breq	8000891a <_vfprintf_r+0x9de>
800088f2:	0d 89       	ld.ub	r9,r6[0x0]
800088f4:	33 08       	mov	r8,48
800088f6:	f0 09 18 00 	cp.b	r9,r8
800088fa:	c0 b1       	brne	80008910 <_vfprintf_r+0x9d4>
800088fc:	30 08       	mov	r8,0
800088fe:	30 09       	mov	r9,0
80008900:	40 6b       	lddsp	r11,sp[0x18]
80008902:	40 7a       	lddsp	r10,sp[0x1c]
80008904:	e0 a0 1c d7 	rcall	8000c2b2 <__avr32_f64_cmp_eq>
80008908:	fb b2 00 01 	rsubeq	r2,1
8000890c:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008910:	40 3b       	lddsp	r11,sp[0xc]
80008912:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008916:	10 0b       	add	r11,r8
80008918:	50 3b       	stdsp	sp[0xc],r11
8000891a:	40 6b       	lddsp	r11,sp[0x18]
8000891c:	30 08       	mov	r8,0
8000891e:	30 09       	mov	r9,0
80008920:	40 7a       	lddsp	r10,sp[0x1c]
80008922:	e0 a0 1c c8 	rcall	8000c2b2 <__avr32_f64_cmp_eq>
80008926:	c0 90       	breq	80008938 <_vfprintf_r+0x9fc>
80008928:	40 3a       	lddsp	r10,sp[0xc]
8000892a:	fb 4a 06 a4 	st.w	sp[1700],r10
8000892e:	c0 58       	rjmp	80008938 <_vfprintf_r+0x9fc>
80008930:	10 c9       	st.b	r8++,r9
80008932:	fb 48 06 a4 	st.w	sp[1700],r8
80008936:	c0 28       	rjmp	8000893a <_vfprintf_r+0x9fe>
80008938:	33 09       	mov	r9,48
8000893a:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000893e:	40 3e       	lddsp	lr,sp[0xc]
80008940:	1c 38       	cp.w	r8,lr
80008942:	cf 73       	brcs	80008930 <_vfprintf_r+0x9f4>
80008944:	e0 40 00 47 	cp.w	r0,71
80008948:	5f 09       	sreq	r9
8000894a:	e0 40 00 67 	cp.w	r0,103
8000894e:	5f 08       	sreq	r8
80008950:	f3 e8 10 08 	or	r8,r9,r8
80008954:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008958:	0c 19       	sub	r9,r6
8000895a:	50 69       	stdsp	sp[0x18],r9
8000895c:	58 08       	cp.w	r8,0
8000895e:	c0 b0       	breq	80008974 <_vfprintf_r+0xa38>
80008960:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008964:	5b d8       	cp.w	r8,-3
80008966:	c0 55       	brlt	80008970 <_vfprintf_r+0xa34>
80008968:	40 2c       	lddsp	r12,sp[0x8]
8000896a:	18 38       	cp.w	r8,r12
8000896c:	e0 8a 00 6a 	brle	80008a40 <_vfprintf_r+0xb04>
80008970:	20 20       	sub	r0,2
80008972:	c0 58       	rjmp	8000897c <_vfprintf_r+0xa40>
80008974:	e0 40 00 65 	cp.w	r0,101
80008978:	e0 89 00 46 	brgt	80008a04 <_vfprintf_r+0xac8>
8000897c:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008980:	fb 60 06 9c 	st.b	sp[1692],r0
80008984:	20 1b       	sub	r11,1
80008986:	fb 4b 06 ac 	st.w	sp[1708],r11
8000898a:	c0 47       	brpl	80008992 <_vfprintf_r+0xa56>
8000898c:	5c 3b       	neg	r11
8000898e:	32 d8       	mov	r8,45
80008990:	c0 28       	rjmp	80008994 <_vfprintf_r+0xa58>
80008992:	32 b8       	mov	r8,43
80008994:	fb 68 06 9d 	st.b	sp[1693],r8
80008998:	58 9b       	cp.w	r11,9
8000899a:	e0 8a 00 1d 	brle	800089d4 <_vfprintf_r+0xa98>
8000899e:	fa c9 fa 35 	sub	r9,sp,-1483
800089a2:	30 aa       	mov	r10,10
800089a4:	12 98       	mov	r8,r9
800089a6:	0e 9c       	mov	r12,r7
800089a8:	0c 92       	mov	r2,r6
800089aa:	f6 0a 0c 06 	divs	r6,r11,r10
800089ae:	0e 9b       	mov	r11,r7
800089b0:	2d 0b       	sub	r11,-48
800089b2:	10 fb       	st.b	--r8,r11
800089b4:	0c 9b       	mov	r11,r6
800089b6:	58 96       	cp.w	r6,9
800089b8:	fe 99 ff f9 	brgt	800089aa <_vfprintf_r+0xa6e>
800089bc:	2d 0b       	sub	r11,-48
800089be:	18 97       	mov	r7,r12
800089c0:	04 96       	mov	r6,r2
800089c2:	10 fb       	st.b	--r8,r11
800089c4:	fa ca f9 62 	sub	r10,sp,-1694
800089c8:	c0 38       	rjmp	800089ce <_vfprintf_r+0xa92>
800089ca:	11 3b       	ld.ub	r11,r8++
800089cc:	14 cb       	st.b	r10++,r11
800089ce:	12 38       	cp.w	r8,r9
800089d0:	cf d3       	brcs	800089ca <_vfprintf_r+0xa8e>
800089d2:	c0 98       	rjmp	800089e4 <_vfprintf_r+0xaa8>
800089d4:	2d 0b       	sub	r11,-48
800089d6:	33 08       	mov	r8,48
800089d8:	fb 6b 06 9f 	st.b	sp[1695],r11
800089dc:	fb 68 06 9e 	st.b	sp[1694],r8
800089e0:	fa ca f9 60 	sub	r10,sp,-1696
800089e4:	fa c8 f9 64 	sub	r8,sp,-1692
800089e8:	f4 08 01 08 	sub	r8,r10,r8
800089ec:	50 e8       	stdsp	sp[0x38],r8
800089ee:	10 92       	mov	r2,r8
800089f0:	40 6b       	lddsp	r11,sp[0x18]
800089f2:	16 02       	add	r2,r11
800089f4:	58 1b       	cp.w	r11,1
800089f6:	e0 89 00 05 	brgt	80008a00 <_vfprintf_r+0xac4>
800089fa:	ed b5 00 00 	bld	r5,0x0
800089fe:	c3 51       	brne	80008a68 <_vfprintf_r+0xb2c>
80008a00:	2f f2       	sub	r2,-1
80008a02:	c3 38       	rjmp	80008a68 <_vfprintf_r+0xb2c>
80008a04:	e0 40 00 66 	cp.w	r0,102
80008a08:	c1 c1       	brne	80008a40 <_vfprintf_r+0xb04>
80008a0a:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008a0e:	58 02       	cp.w	r2,0
80008a10:	e0 8a 00 0c 	brle	80008a28 <_vfprintf_r+0xaec>
80008a14:	40 2a       	lddsp	r10,sp[0x8]
80008a16:	58 0a       	cp.w	r10,0
80008a18:	c0 41       	brne	80008a20 <_vfprintf_r+0xae4>
80008a1a:	ed b5 00 00 	bld	r5,0x0
80008a1e:	c2 51       	brne	80008a68 <_vfprintf_r+0xb2c>
80008a20:	2f f2       	sub	r2,-1
80008a22:	40 29       	lddsp	r9,sp[0x8]
80008a24:	12 02       	add	r2,r9
80008a26:	c0 b8       	rjmp	80008a3c <_vfprintf_r+0xb00>
80008a28:	40 28       	lddsp	r8,sp[0x8]
80008a2a:	58 08       	cp.w	r8,0
80008a2c:	c0 61       	brne	80008a38 <_vfprintf_r+0xafc>
80008a2e:	ed b5 00 00 	bld	r5,0x0
80008a32:	c0 30       	breq	80008a38 <_vfprintf_r+0xafc>
80008a34:	30 12       	mov	r2,1
80008a36:	c1 98       	rjmp	80008a68 <_vfprintf_r+0xb2c>
80008a38:	40 22       	lddsp	r2,sp[0x8]
80008a3a:	2f e2       	sub	r2,-2
80008a3c:	36 60       	mov	r0,102
80008a3e:	c1 58       	rjmp	80008a68 <_vfprintf_r+0xb2c>
80008a40:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008a44:	40 6e       	lddsp	lr,sp[0x18]
80008a46:	1c 32       	cp.w	r2,lr
80008a48:	c0 65       	brlt	80008a54 <_vfprintf_r+0xb18>
80008a4a:	ed b5 00 00 	bld	r5,0x0
80008a4e:	f7 b2 00 ff 	subeq	r2,-1
80008a52:	c0 a8       	rjmp	80008a66 <_vfprintf_r+0xb2a>
80008a54:	e4 08 11 02 	rsub	r8,r2,2
80008a58:	40 6c       	lddsp	r12,sp[0x18]
80008a5a:	58 02       	cp.w	r2,0
80008a5c:	f0 02 17 a0 	movle	r2,r8
80008a60:	f9 b2 09 01 	movgt	r2,1
80008a64:	18 02       	add	r2,r12
80008a66:	36 70       	mov	r0,103
80008a68:	40 9b       	lddsp	r11,sp[0x24]
80008a6a:	58 0b       	cp.w	r11,0
80008a6c:	e0 80 05 94 	breq	80009594 <_vfprintf_r+0x1658>
80008a70:	32 d8       	mov	r8,45
80008a72:	fb 68 06 bb 	st.b	sp[1723],r8
80008a76:	e0 8f 05 93 	bral	8000959c <_vfprintf_r+0x1660>
80008a7a:	50 a7       	stdsp	sp[0x28],r7
80008a7c:	04 94       	mov	r4,r2
80008a7e:	0c 97       	mov	r7,r6
80008a80:	02 92       	mov	r2,r1
80008a82:	06 96       	mov	r6,r3
80008a84:	40 41       	lddsp	r1,sp[0x10]
80008a86:	40 93       	lddsp	r3,sp[0x24]
80008a88:	0e 99       	mov	r9,r7
80008a8a:	ed b5 00 05 	bld	r5,0x5
80008a8e:	c4 81       	brne	80008b1e <_vfprintf_r+0xbe2>
80008a90:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a94:	40 3e       	lddsp	lr,sp[0xc]
80008a96:	58 0e       	cp.w	lr,0
80008a98:	c1 d0       	breq	80008ad2 <_vfprintf_r+0xb96>
80008a9a:	10 36       	cp.w	r6,r8
80008a9c:	c0 64       	brge	80008aa8 <_vfprintf_r+0xb6c>
80008a9e:	fa cc f9 44 	sub	r12,sp,-1724
80008aa2:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008aa6:	c1 d8       	rjmp	80008ae0 <_vfprintf_r+0xba4>
80008aa8:	fa c8 f9 50 	sub	r8,sp,-1712
80008aac:	1a d8       	st.w	--sp,r8
80008aae:	fa c8 fa b8 	sub	r8,sp,-1352
80008ab2:	04 9a       	mov	r10,r2
80008ab4:	1a d8       	st.w	--sp,r8
80008ab6:	fa c8 fb b4 	sub	r8,sp,-1100
80008aba:	0c 9b       	mov	r11,r6
80008abc:	1a d8       	st.w	--sp,r8
80008abe:	08 9c       	mov	r12,r4
80008ac0:	fa c8 f9 40 	sub	r8,sp,-1728
80008ac4:	fa c9 ff b4 	sub	r9,sp,-76
80008ac8:	fe b0 f8 a2 	rcall	80007c0c <get_arg>
80008acc:	2f dd       	sub	sp,-12
80008ace:	78 0a       	ld.w	r10,r12[0x0]
80008ad0:	c2 08       	rjmp	80008b10 <_vfprintf_r+0xbd4>
80008ad2:	2f f7       	sub	r7,-1
80008ad4:	10 39       	cp.w	r9,r8
80008ad6:	c0 84       	brge	80008ae6 <_vfprintf_r+0xbaa>
80008ad8:	fa cb f9 44 	sub	r11,sp,-1724
80008adc:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008ae0:	ec fa fd 88 	ld.w	r10,r6[-632]
80008ae4:	c1 68       	rjmp	80008b10 <_vfprintf_r+0xbd4>
80008ae6:	41 09       	lddsp	r9,sp[0x40]
80008ae8:	59 f8       	cp.w	r8,31
80008aea:	e0 89 00 10 	brgt	80008b0a <_vfprintf_r+0xbce>
80008aee:	f2 ca ff fc 	sub	r10,r9,-4
80008af2:	51 0a       	stdsp	sp[0x40],r10
80008af4:	fa c6 f9 44 	sub	r6,sp,-1724
80008af8:	72 0a       	ld.w	r10,r9[0x0]
80008afa:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008afe:	f3 4a fd 88 	st.w	r9[-632],r10
80008b02:	2f f8       	sub	r8,-1
80008b04:	fb 48 06 b4 	st.w	sp[1716],r8
80008b08:	c0 48       	rjmp	80008b10 <_vfprintf_r+0xbd4>
80008b0a:	72 0a       	ld.w	r10,r9[0x0]
80008b0c:	2f c9       	sub	r9,-4
80008b0e:	51 09       	stdsp	sp[0x40],r9
80008b10:	40 be       	lddsp	lr,sp[0x2c]
80008b12:	1c 98       	mov	r8,lr
80008b14:	95 1e       	st.w	r10[0x4],lr
80008b16:	bf 58       	asr	r8,0x1f
80008b18:	95 08       	st.w	r10[0x0],r8
80008b1a:	fe 9f fa 9f 	bral	80008058 <_vfprintf_r+0x11c>
80008b1e:	ed b5 00 04 	bld	r5,0x4
80008b22:	c4 80       	breq	80008bb2 <_vfprintf_r+0xc76>
80008b24:	e2 15 00 40 	andl	r5,0x40,COH
80008b28:	c4 50       	breq	80008bb2 <_vfprintf_r+0xc76>
80008b2a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b2e:	40 3c       	lddsp	r12,sp[0xc]
80008b30:	58 0c       	cp.w	r12,0
80008b32:	c1 d0       	breq	80008b6c <_vfprintf_r+0xc30>
80008b34:	10 36       	cp.w	r6,r8
80008b36:	c0 64       	brge	80008b42 <_vfprintf_r+0xc06>
80008b38:	fa cb f9 44 	sub	r11,sp,-1724
80008b3c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008b40:	c1 d8       	rjmp	80008b7a <_vfprintf_r+0xc3e>
80008b42:	fa c8 f9 50 	sub	r8,sp,-1712
80008b46:	1a d8       	st.w	--sp,r8
80008b48:	fa c8 fa b8 	sub	r8,sp,-1352
80008b4c:	04 9a       	mov	r10,r2
80008b4e:	1a d8       	st.w	--sp,r8
80008b50:	fa c8 fb b4 	sub	r8,sp,-1100
80008b54:	0c 9b       	mov	r11,r6
80008b56:	1a d8       	st.w	--sp,r8
80008b58:	08 9c       	mov	r12,r4
80008b5a:	fa c8 f9 40 	sub	r8,sp,-1728
80008b5e:	fa c9 ff b4 	sub	r9,sp,-76
80008b62:	fe b0 f8 55 	rcall	80007c0c <get_arg>
80008b66:	2f dd       	sub	sp,-12
80008b68:	78 0a       	ld.w	r10,r12[0x0]
80008b6a:	c2 08       	rjmp	80008baa <_vfprintf_r+0xc6e>
80008b6c:	2f f7       	sub	r7,-1
80008b6e:	10 39       	cp.w	r9,r8
80008b70:	c0 84       	brge	80008b80 <_vfprintf_r+0xc44>
80008b72:	fa ca f9 44 	sub	r10,sp,-1724
80008b76:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008b7a:	ec fa fd 88 	ld.w	r10,r6[-632]
80008b7e:	c1 68       	rjmp	80008baa <_vfprintf_r+0xc6e>
80008b80:	41 09       	lddsp	r9,sp[0x40]
80008b82:	59 f8       	cp.w	r8,31
80008b84:	e0 89 00 10 	brgt	80008ba4 <_vfprintf_r+0xc68>
80008b88:	f2 ca ff fc 	sub	r10,r9,-4
80008b8c:	51 0a       	stdsp	sp[0x40],r10
80008b8e:	fa c6 f9 44 	sub	r6,sp,-1724
80008b92:	72 0a       	ld.w	r10,r9[0x0]
80008b94:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008b98:	f3 4a fd 88 	st.w	r9[-632],r10
80008b9c:	2f f8       	sub	r8,-1
80008b9e:	fb 48 06 b4 	st.w	sp[1716],r8
80008ba2:	c0 48       	rjmp	80008baa <_vfprintf_r+0xc6e>
80008ba4:	72 0a       	ld.w	r10,r9[0x0]
80008ba6:	2f c9       	sub	r9,-4
80008ba8:	51 09       	stdsp	sp[0x40],r9
80008baa:	40 be       	lddsp	lr,sp[0x2c]
80008bac:	b4 0e       	st.h	r10[0x0],lr
80008bae:	fe 9f fa 55 	bral	80008058 <_vfprintf_r+0x11c>
80008bb2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008bb6:	40 3c       	lddsp	r12,sp[0xc]
80008bb8:	58 0c       	cp.w	r12,0
80008bba:	c1 d0       	breq	80008bf4 <_vfprintf_r+0xcb8>
80008bbc:	10 36       	cp.w	r6,r8
80008bbe:	c0 64       	brge	80008bca <_vfprintf_r+0xc8e>
80008bc0:	fa cb f9 44 	sub	r11,sp,-1724
80008bc4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008bc8:	c1 d8       	rjmp	80008c02 <_vfprintf_r+0xcc6>
80008bca:	fa c8 f9 50 	sub	r8,sp,-1712
80008bce:	1a d8       	st.w	--sp,r8
80008bd0:	fa c8 fa b8 	sub	r8,sp,-1352
80008bd4:	04 9a       	mov	r10,r2
80008bd6:	1a d8       	st.w	--sp,r8
80008bd8:	fa c8 fb b4 	sub	r8,sp,-1100
80008bdc:	0c 9b       	mov	r11,r6
80008bde:	1a d8       	st.w	--sp,r8
80008be0:	08 9c       	mov	r12,r4
80008be2:	fa c8 f9 40 	sub	r8,sp,-1728
80008be6:	fa c9 ff b4 	sub	r9,sp,-76
80008bea:	fe b0 f8 11 	rcall	80007c0c <get_arg>
80008bee:	2f dd       	sub	sp,-12
80008bf0:	78 0a       	ld.w	r10,r12[0x0]
80008bf2:	c2 08       	rjmp	80008c32 <_vfprintf_r+0xcf6>
80008bf4:	2f f7       	sub	r7,-1
80008bf6:	10 39       	cp.w	r9,r8
80008bf8:	c0 84       	brge	80008c08 <_vfprintf_r+0xccc>
80008bfa:	fa ca f9 44 	sub	r10,sp,-1724
80008bfe:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008c02:	ec fa fd 88 	ld.w	r10,r6[-632]
80008c06:	c1 68       	rjmp	80008c32 <_vfprintf_r+0xcf6>
80008c08:	41 09       	lddsp	r9,sp[0x40]
80008c0a:	59 f8       	cp.w	r8,31
80008c0c:	e0 89 00 10 	brgt	80008c2c <_vfprintf_r+0xcf0>
80008c10:	f2 ca ff fc 	sub	r10,r9,-4
80008c14:	51 0a       	stdsp	sp[0x40],r10
80008c16:	fa c6 f9 44 	sub	r6,sp,-1724
80008c1a:	72 0a       	ld.w	r10,r9[0x0]
80008c1c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008c20:	f3 4a fd 88 	st.w	r9[-632],r10
80008c24:	2f f8       	sub	r8,-1
80008c26:	fb 48 06 b4 	st.w	sp[1716],r8
80008c2a:	c0 48       	rjmp	80008c32 <_vfprintf_r+0xcf6>
80008c2c:	72 0a       	ld.w	r10,r9[0x0]
80008c2e:	2f c9       	sub	r9,-4
80008c30:	51 09       	stdsp	sp[0x40],r9
80008c32:	40 be       	lddsp	lr,sp[0x2c]
80008c34:	95 0e       	st.w	r10[0x0],lr
80008c36:	fe 9f fa 11 	bral	80008058 <_vfprintf_r+0x11c>
80008c3a:	50 a7       	stdsp	sp[0x28],r7
80008c3c:	50 80       	stdsp	sp[0x20],r0
80008c3e:	0c 97       	mov	r7,r6
80008c40:	04 94       	mov	r4,r2
80008c42:	06 96       	mov	r6,r3
80008c44:	02 92       	mov	r2,r1
80008c46:	40 93       	lddsp	r3,sp[0x24]
80008c48:	10 90       	mov	r0,r8
80008c4a:	40 41       	lddsp	r1,sp[0x10]
80008c4c:	a5 a5       	sbr	r5,0x4
80008c4e:	c0 a8       	rjmp	80008c62 <_vfprintf_r+0xd26>
80008c50:	50 a7       	stdsp	sp[0x28],r7
80008c52:	50 80       	stdsp	sp[0x20],r0
80008c54:	0c 97       	mov	r7,r6
80008c56:	04 94       	mov	r4,r2
80008c58:	06 96       	mov	r6,r3
80008c5a:	02 92       	mov	r2,r1
80008c5c:	40 93       	lddsp	r3,sp[0x24]
80008c5e:	10 90       	mov	r0,r8
80008c60:	40 41       	lddsp	r1,sp[0x10]
80008c62:	ed b5 00 05 	bld	r5,0x5
80008c66:	c5 d1       	brne	80008d20 <_vfprintf_r+0xde4>
80008c68:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c6c:	40 3c       	lddsp	r12,sp[0xc]
80008c6e:	58 0c       	cp.w	r12,0
80008c70:	c2 60       	breq	80008cbc <_vfprintf_r+0xd80>
80008c72:	10 36       	cp.w	r6,r8
80008c74:	c0 a4       	brge	80008c88 <_vfprintf_r+0xd4c>
80008c76:	fa cb f9 44 	sub	r11,sp,-1724
80008c7a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c7e:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008c82:	fa e9 00 00 	st.d	sp[0],r8
80008c86:	c1 88       	rjmp	80008cb6 <_vfprintf_r+0xd7a>
80008c88:	fa c8 f9 50 	sub	r8,sp,-1712
80008c8c:	1a d8       	st.w	--sp,r8
80008c8e:	fa c8 fa b8 	sub	r8,sp,-1352
80008c92:	04 9a       	mov	r10,r2
80008c94:	1a d8       	st.w	--sp,r8
80008c96:	0c 9b       	mov	r11,r6
80008c98:	fa c8 fb b4 	sub	r8,sp,-1100
80008c9c:	08 9c       	mov	r12,r4
80008c9e:	1a d8       	st.w	--sp,r8
80008ca0:	fa c8 f9 40 	sub	r8,sp,-1728
80008ca4:	fa c9 ff b4 	sub	r9,sp,-76
80008ca8:	fe b0 f7 b2 	rcall	80007c0c <get_arg>
80008cac:	2f dd       	sub	sp,-12
80008cae:	f8 ea 00 00 	ld.d	r10,r12[0]
80008cb2:	fa eb 00 00 	st.d	sp[0],r10
80008cb6:	30 08       	mov	r8,0
80008cb8:	e0 8f 03 de 	bral	80009474 <_vfprintf_r+0x1538>
80008cbc:	ee ca ff ff 	sub	r10,r7,-1
80008cc0:	10 37       	cp.w	r7,r8
80008cc2:	c0 b4       	brge	80008cd8 <_vfprintf_r+0xd9c>
80008cc4:	fa c9 f9 44 	sub	r9,sp,-1724
80008cc8:	14 97       	mov	r7,r10
80008cca:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008cce:	ec ea fd 88 	ld.d	r10,r6[-632]
80008cd2:	fa eb 00 00 	st.d	sp[0],r10
80008cd6:	c1 88       	rjmp	80008d06 <_vfprintf_r+0xdca>
80008cd8:	41 09       	lddsp	r9,sp[0x40]
80008cda:	59 f8       	cp.w	r8,31
80008cdc:	e0 89 00 18 	brgt	80008d0c <_vfprintf_r+0xdd0>
80008ce0:	f2 e6 00 00 	ld.d	r6,r9[0]
80008ce4:	f2 cb ff f8 	sub	r11,r9,-8
80008ce8:	fa e7 00 00 	st.d	sp[0],r6
80008cec:	51 0b       	stdsp	sp[0x40],r11
80008cee:	fa c6 f9 44 	sub	r6,sp,-1724
80008cf2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008cf6:	fa e6 00 00 	ld.d	r6,sp[0]
80008cfa:	f2 e7 fd 88 	st.d	r9[-632],r6
80008cfe:	2f f8       	sub	r8,-1
80008d00:	14 97       	mov	r7,r10
80008d02:	fb 48 06 b4 	st.w	sp[1716],r8
80008d06:	40 38       	lddsp	r8,sp[0xc]
80008d08:	e0 8f 03 b6 	bral	80009474 <_vfprintf_r+0x1538>
80008d0c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008d10:	40 38       	lddsp	r8,sp[0xc]
80008d12:	fa e7 00 00 	st.d	sp[0],r6
80008d16:	2f 89       	sub	r9,-8
80008d18:	14 97       	mov	r7,r10
80008d1a:	51 09       	stdsp	sp[0x40],r9
80008d1c:	e0 8f 03 ac 	bral	80009474 <_vfprintf_r+0x1538>
80008d20:	ed b5 00 04 	bld	r5,0x4
80008d24:	c1 61       	brne	80008d50 <_vfprintf_r+0xe14>
80008d26:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d2a:	40 3e       	lddsp	lr,sp[0xc]
80008d2c:	58 0e       	cp.w	lr,0
80008d2e:	c0 80       	breq	80008d3e <_vfprintf_r+0xe02>
80008d30:	10 36       	cp.w	r6,r8
80008d32:	c6 74       	brge	80008e00 <_vfprintf_r+0xec4>
80008d34:	fa cc f9 44 	sub	r12,sp,-1724
80008d38:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008d3c:	c8 08       	rjmp	80008e3c <_vfprintf_r+0xf00>
80008d3e:	ee ca ff ff 	sub	r10,r7,-1
80008d42:	10 37       	cp.w	r7,r8
80008d44:	c7 f4       	brge	80008e42 <_vfprintf_r+0xf06>
80008d46:	fa cb f9 44 	sub	r11,sp,-1724
80008d4a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d4e:	c7 68       	rjmp	80008e3a <_vfprintf_r+0xefe>
80008d50:	ed b5 00 06 	bld	r5,0x6
80008d54:	c4 a1       	brne	80008de8 <_vfprintf_r+0xeac>
80008d56:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d5a:	40 3c       	lddsp	r12,sp[0xc]
80008d5c:	58 0c       	cp.w	r12,0
80008d5e:	c1 d0       	breq	80008d98 <_vfprintf_r+0xe5c>
80008d60:	10 36       	cp.w	r6,r8
80008d62:	c0 64       	brge	80008d6e <_vfprintf_r+0xe32>
80008d64:	fa cb f9 44 	sub	r11,sp,-1724
80008d68:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d6c:	c1 f8       	rjmp	80008daa <_vfprintf_r+0xe6e>
80008d6e:	fa c8 f9 50 	sub	r8,sp,-1712
80008d72:	1a d8       	st.w	--sp,r8
80008d74:	fa c8 fa b8 	sub	r8,sp,-1352
80008d78:	1a d8       	st.w	--sp,r8
80008d7a:	fa c8 fb b4 	sub	r8,sp,-1100
80008d7e:	1a d8       	st.w	--sp,r8
80008d80:	fa c8 f9 40 	sub	r8,sp,-1728
80008d84:	fa c9 ff b4 	sub	r9,sp,-76
80008d88:	04 9a       	mov	r10,r2
80008d8a:	0c 9b       	mov	r11,r6
80008d8c:	08 9c       	mov	r12,r4
80008d8e:	fe b0 f7 3f 	rcall	80007c0c <get_arg>
80008d92:	2f dd       	sub	sp,-12
80008d94:	98 18       	ld.sh	r8,r12[0x2]
80008d96:	c2 68       	rjmp	80008de2 <_vfprintf_r+0xea6>
80008d98:	ee ca ff ff 	sub	r10,r7,-1
80008d9c:	10 37       	cp.w	r7,r8
80008d9e:	c0 94       	brge	80008db0 <_vfprintf_r+0xe74>
80008da0:	fa c9 f9 44 	sub	r9,sp,-1724
80008da4:	14 97       	mov	r7,r10
80008da6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008daa:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008dae:	c1 a8       	rjmp	80008de2 <_vfprintf_r+0xea6>
80008db0:	41 09       	lddsp	r9,sp[0x40]
80008db2:	59 f8       	cp.w	r8,31
80008db4:	e0 89 00 13 	brgt	80008dda <_vfprintf_r+0xe9e>
80008db8:	f2 cb ff fc 	sub	r11,r9,-4
80008dbc:	51 0b       	stdsp	sp[0x40],r11
80008dbe:	72 09       	ld.w	r9,r9[0x0]
80008dc0:	fa c6 f9 44 	sub	r6,sp,-1724
80008dc4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008dc8:	2f f8       	sub	r8,-1
80008dca:	f7 49 fd 88 	st.w	r11[-632],r9
80008dce:	fb 48 06 b4 	st.w	sp[1716],r8
80008dd2:	14 97       	mov	r7,r10
80008dd4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008dd8:	c0 58       	rjmp	80008de2 <_vfprintf_r+0xea6>
80008dda:	92 18       	ld.sh	r8,r9[0x2]
80008ddc:	14 97       	mov	r7,r10
80008dde:	2f c9       	sub	r9,-4
80008de0:	51 09       	stdsp	sp[0x40],r9
80008de2:	5c 78       	castu.h	r8
80008de4:	50 18       	stdsp	sp[0x4],r8
80008de6:	c4 68       	rjmp	80008e72 <_vfprintf_r+0xf36>
80008de8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008dec:	40 3c       	lddsp	r12,sp[0xc]
80008dee:	58 0c       	cp.w	r12,0
80008df0:	c1 d0       	breq	80008e2a <_vfprintf_r+0xeee>
80008df2:	10 36       	cp.w	r6,r8
80008df4:	c0 64       	brge	80008e00 <_vfprintf_r+0xec4>
80008df6:	fa cb f9 44 	sub	r11,sp,-1724
80008dfa:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008dfe:	c1 f8       	rjmp	80008e3c <_vfprintf_r+0xf00>
80008e00:	fa c8 f9 50 	sub	r8,sp,-1712
80008e04:	1a d8       	st.w	--sp,r8
80008e06:	fa c8 fa b8 	sub	r8,sp,-1352
80008e0a:	0c 9b       	mov	r11,r6
80008e0c:	1a d8       	st.w	--sp,r8
80008e0e:	fa c8 fb b4 	sub	r8,sp,-1100
80008e12:	04 9a       	mov	r10,r2
80008e14:	1a d8       	st.w	--sp,r8
80008e16:	08 9c       	mov	r12,r4
80008e18:	fa c8 f9 40 	sub	r8,sp,-1728
80008e1c:	fa c9 ff b4 	sub	r9,sp,-76
80008e20:	fe b0 f6 f6 	rcall	80007c0c <get_arg>
80008e24:	2f dd       	sub	sp,-12
80008e26:	78 0b       	ld.w	r11,r12[0x0]
80008e28:	c2 48       	rjmp	80008e70 <_vfprintf_r+0xf34>
80008e2a:	ee ca ff ff 	sub	r10,r7,-1
80008e2e:	10 37       	cp.w	r7,r8
80008e30:	c0 94       	brge	80008e42 <_vfprintf_r+0xf06>
80008e32:	fa c9 f9 44 	sub	r9,sp,-1724
80008e36:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008e3a:	14 97       	mov	r7,r10
80008e3c:	ec fb fd 88 	ld.w	r11,r6[-632]
80008e40:	c1 88       	rjmp	80008e70 <_vfprintf_r+0xf34>
80008e42:	41 09       	lddsp	r9,sp[0x40]
80008e44:	59 f8       	cp.w	r8,31
80008e46:	e0 89 00 11 	brgt	80008e68 <_vfprintf_r+0xf2c>
80008e4a:	f2 cb ff fc 	sub	r11,r9,-4
80008e4e:	51 0b       	stdsp	sp[0x40],r11
80008e50:	fa c6 f9 44 	sub	r6,sp,-1724
80008e54:	72 0b       	ld.w	r11,r9[0x0]
80008e56:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008e5a:	f3 4b fd 88 	st.w	r9[-632],r11
80008e5e:	2f f8       	sub	r8,-1
80008e60:	14 97       	mov	r7,r10
80008e62:	fb 48 06 b4 	st.w	sp[1716],r8
80008e66:	c0 58       	rjmp	80008e70 <_vfprintf_r+0xf34>
80008e68:	72 0b       	ld.w	r11,r9[0x0]
80008e6a:	14 97       	mov	r7,r10
80008e6c:	2f c9       	sub	r9,-4
80008e6e:	51 09       	stdsp	sp[0x40],r9
80008e70:	50 1b       	stdsp	sp[0x4],r11
80008e72:	30 0e       	mov	lr,0
80008e74:	50 0e       	stdsp	sp[0x0],lr
80008e76:	1c 98       	mov	r8,lr
80008e78:	e0 8f 02 fe 	bral	80009474 <_vfprintf_r+0x1538>
80008e7c:	50 a7       	stdsp	sp[0x28],r7
80008e7e:	50 80       	stdsp	sp[0x20],r0
80008e80:	0c 97       	mov	r7,r6
80008e82:	04 94       	mov	r4,r2
80008e84:	06 96       	mov	r6,r3
80008e86:	02 92       	mov	r2,r1
80008e88:	40 93       	lddsp	r3,sp[0x24]
80008e8a:	40 41       	lddsp	r1,sp[0x10]
80008e8c:	0e 99       	mov	r9,r7
80008e8e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e92:	40 3c       	lddsp	r12,sp[0xc]
80008e94:	58 0c       	cp.w	r12,0
80008e96:	c1 d0       	breq	80008ed0 <_vfprintf_r+0xf94>
80008e98:	10 36       	cp.w	r6,r8
80008e9a:	c0 64       	brge	80008ea6 <_vfprintf_r+0xf6a>
80008e9c:	fa cb f9 44 	sub	r11,sp,-1724
80008ea0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008ea4:	c1 d8       	rjmp	80008ede <_vfprintf_r+0xfa2>
80008ea6:	fa c8 f9 50 	sub	r8,sp,-1712
80008eaa:	1a d8       	st.w	--sp,r8
80008eac:	fa c8 fa b8 	sub	r8,sp,-1352
80008eb0:	1a d8       	st.w	--sp,r8
80008eb2:	fa c8 fb b4 	sub	r8,sp,-1100
80008eb6:	1a d8       	st.w	--sp,r8
80008eb8:	fa c9 ff b4 	sub	r9,sp,-76
80008ebc:	fa c8 f9 40 	sub	r8,sp,-1728
80008ec0:	04 9a       	mov	r10,r2
80008ec2:	0c 9b       	mov	r11,r6
80008ec4:	08 9c       	mov	r12,r4
80008ec6:	fe b0 f6 a3 	rcall	80007c0c <get_arg>
80008eca:	2f dd       	sub	sp,-12
80008ecc:	78 09       	ld.w	r9,r12[0x0]
80008ece:	c2 18       	rjmp	80008f10 <_vfprintf_r+0xfd4>
80008ed0:	2f f7       	sub	r7,-1
80008ed2:	10 39       	cp.w	r9,r8
80008ed4:	c0 84       	brge	80008ee4 <_vfprintf_r+0xfa8>
80008ed6:	fa ca f9 44 	sub	r10,sp,-1724
80008eda:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008ede:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008ee2:	c1 78       	rjmp	80008f10 <_vfprintf_r+0xfd4>
80008ee4:	41 09       	lddsp	r9,sp[0x40]
80008ee6:	59 f8       	cp.w	r8,31
80008ee8:	e0 89 00 10 	brgt	80008f08 <_vfprintf_r+0xfcc>
80008eec:	f2 ca ff fc 	sub	r10,r9,-4
80008ef0:	51 0a       	stdsp	sp[0x40],r10
80008ef2:	fa c6 f9 44 	sub	r6,sp,-1724
80008ef6:	72 09       	ld.w	r9,r9[0x0]
80008ef8:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008efc:	f5 49 fd 88 	st.w	r10[-632],r9
80008f00:	2f f8       	sub	r8,-1
80008f02:	fb 48 06 b4 	st.w	sp[1716],r8
80008f06:	c0 58       	rjmp	80008f10 <_vfprintf_r+0xfd4>
80008f08:	f2 c8 ff fc 	sub	r8,r9,-4
80008f0c:	51 08       	stdsp	sp[0x40],r8
80008f0e:	72 09       	ld.w	r9,r9[0x0]
80008f10:	33 08       	mov	r8,48
80008f12:	fb 68 06 b8 	st.b	sp[1720],r8
80008f16:	37 88       	mov	r8,120
80008f18:	30 0e       	mov	lr,0
80008f1a:	fb 68 06 b9 	st.b	sp[1721],r8
80008f1e:	fe cc b1 76 	sub	r12,pc,-20106
80008f22:	50 19       	stdsp	sp[0x4],r9
80008f24:	a1 b5       	sbr	r5,0x1
80008f26:	50 0e       	stdsp	sp[0x0],lr
80008f28:	50 dc       	stdsp	sp[0x34],r12
80008f2a:	30 28       	mov	r8,2
80008f2c:	37 80       	mov	r0,120
80008f2e:	e0 8f 02 a3 	bral	80009474 <_vfprintf_r+0x1538>
80008f32:	50 a7       	stdsp	sp[0x28],r7
80008f34:	50 80       	stdsp	sp[0x20],r0
80008f36:	10 90       	mov	r0,r8
80008f38:	30 08       	mov	r8,0
80008f3a:	fb 68 06 bb 	st.b	sp[1723],r8
80008f3e:	0c 97       	mov	r7,r6
80008f40:	04 94       	mov	r4,r2
80008f42:	06 96       	mov	r6,r3
80008f44:	02 92       	mov	r2,r1
80008f46:	40 93       	lddsp	r3,sp[0x24]
80008f48:	40 41       	lddsp	r1,sp[0x10]
80008f4a:	0e 99       	mov	r9,r7
80008f4c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f50:	40 3b       	lddsp	r11,sp[0xc]
80008f52:	58 0b       	cp.w	r11,0
80008f54:	c1 d0       	breq	80008f8e <_vfprintf_r+0x1052>
80008f56:	10 36       	cp.w	r6,r8
80008f58:	c0 64       	brge	80008f64 <_vfprintf_r+0x1028>
80008f5a:	fa ca f9 44 	sub	r10,sp,-1724
80008f5e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008f62:	c1 d8       	rjmp	80008f9c <_vfprintf_r+0x1060>
80008f64:	fa c8 f9 50 	sub	r8,sp,-1712
80008f68:	1a d8       	st.w	--sp,r8
80008f6a:	fa c8 fa b8 	sub	r8,sp,-1352
80008f6e:	1a d8       	st.w	--sp,r8
80008f70:	fa c8 fb b4 	sub	r8,sp,-1100
80008f74:	0c 9b       	mov	r11,r6
80008f76:	1a d8       	st.w	--sp,r8
80008f78:	04 9a       	mov	r10,r2
80008f7a:	fa c8 f9 40 	sub	r8,sp,-1728
80008f7e:	fa c9 ff b4 	sub	r9,sp,-76
80008f82:	08 9c       	mov	r12,r4
80008f84:	fe b0 f6 44 	rcall	80007c0c <get_arg>
80008f88:	2f dd       	sub	sp,-12
80008f8a:	78 06       	ld.w	r6,r12[0x0]
80008f8c:	c2 08       	rjmp	80008fcc <_vfprintf_r+0x1090>
80008f8e:	2f f7       	sub	r7,-1
80008f90:	10 39       	cp.w	r9,r8
80008f92:	c0 84       	brge	80008fa2 <_vfprintf_r+0x1066>
80008f94:	fa c9 f9 44 	sub	r9,sp,-1724
80008f98:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f9c:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008fa0:	c1 68       	rjmp	80008fcc <_vfprintf_r+0x1090>
80008fa2:	41 09       	lddsp	r9,sp[0x40]
80008fa4:	59 f8       	cp.w	r8,31
80008fa6:	e0 89 00 10 	brgt	80008fc6 <_vfprintf_r+0x108a>
80008faa:	f2 ca ff fc 	sub	r10,r9,-4
80008fae:	51 0a       	stdsp	sp[0x40],r10
80008fb0:	72 06       	ld.w	r6,r9[0x0]
80008fb2:	fa ce f9 44 	sub	lr,sp,-1724
80008fb6:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008fba:	f3 46 fd 88 	st.w	r9[-632],r6
80008fbe:	2f f8       	sub	r8,-1
80008fc0:	fb 48 06 b4 	st.w	sp[1716],r8
80008fc4:	c0 48       	rjmp	80008fcc <_vfprintf_r+0x1090>
80008fc6:	72 06       	ld.w	r6,r9[0x0]
80008fc8:	2f c9       	sub	r9,-4
80008fca:	51 09       	stdsp	sp[0x40],r9
80008fcc:	40 2c       	lddsp	r12,sp[0x8]
80008fce:	58 0c       	cp.w	r12,0
80008fd0:	c1 05       	brlt	80008ff0 <_vfprintf_r+0x10b4>
80008fd2:	18 9a       	mov	r10,r12
80008fd4:	30 0b       	mov	r11,0
80008fd6:	0c 9c       	mov	r12,r6
80008fd8:	e0 a0 12 38 	rcall	8000b448 <memchr>
80008fdc:	e0 80 02 df 	breq	8000959a <_vfprintf_r+0x165e>
80008fe0:	f8 06 01 02 	sub	r2,r12,r6
80008fe4:	40 2b       	lddsp	r11,sp[0x8]
80008fe6:	16 32       	cp.w	r2,r11
80008fe8:	e0 89 02 d9 	brgt	8000959a <_vfprintf_r+0x165e>
80008fec:	e0 8f 02 d4 	bral	80009594 <_vfprintf_r+0x1658>
80008ff0:	30 0a       	mov	r10,0
80008ff2:	0c 9c       	mov	r12,r6
80008ff4:	50 2a       	stdsp	sp[0x8],r10
80008ff6:	e0 a0 15 99 	rcall	8000bb28 <strlen>
80008ffa:	18 92       	mov	r2,r12
80008ffc:	e0 8f 02 d2 	bral	800095a0 <_vfprintf_r+0x1664>
80009000:	50 a7       	stdsp	sp[0x28],r7
80009002:	50 80       	stdsp	sp[0x20],r0
80009004:	0c 97       	mov	r7,r6
80009006:	04 94       	mov	r4,r2
80009008:	06 96       	mov	r6,r3
8000900a:	02 92       	mov	r2,r1
8000900c:	40 93       	lddsp	r3,sp[0x24]
8000900e:	10 90       	mov	r0,r8
80009010:	40 41       	lddsp	r1,sp[0x10]
80009012:	a5 a5       	sbr	r5,0x4
80009014:	c0 a8       	rjmp	80009028 <_vfprintf_r+0x10ec>
80009016:	50 a7       	stdsp	sp[0x28],r7
80009018:	50 80       	stdsp	sp[0x20],r0
8000901a:	0c 97       	mov	r7,r6
8000901c:	04 94       	mov	r4,r2
8000901e:	06 96       	mov	r6,r3
80009020:	02 92       	mov	r2,r1
80009022:	40 93       	lddsp	r3,sp[0x24]
80009024:	10 90       	mov	r0,r8
80009026:	40 41       	lddsp	r1,sp[0x10]
80009028:	ed b5 00 05 	bld	r5,0x5
8000902c:	c5 61       	brne	800090d8 <_vfprintf_r+0x119c>
8000902e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009032:	40 39       	lddsp	r9,sp[0xc]
80009034:	58 09       	cp.w	r9,0
80009036:	c2 10       	breq	80009078 <_vfprintf_r+0x113c>
80009038:	10 36       	cp.w	r6,r8
8000903a:	c0 74       	brge	80009048 <_vfprintf_r+0x110c>
8000903c:	fa c8 f9 44 	sub	r8,sp,-1724
80009040:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009044:	c2 38       	rjmp	8000908a <_vfprintf_r+0x114e>
80009046:	d7 03       	nop
80009048:	fa c8 f9 50 	sub	r8,sp,-1712
8000904c:	1a d8       	st.w	--sp,r8
8000904e:	fa c8 fa b8 	sub	r8,sp,-1352
80009052:	1a d8       	st.w	--sp,r8
80009054:	fa c8 fb b4 	sub	r8,sp,-1100
80009058:	1a d8       	st.w	--sp,r8
8000905a:	fa c8 f9 40 	sub	r8,sp,-1728
8000905e:	fa c9 ff b4 	sub	r9,sp,-76
80009062:	04 9a       	mov	r10,r2
80009064:	0c 9b       	mov	r11,r6
80009066:	08 9c       	mov	r12,r4
80009068:	fe b0 f5 d2 	rcall	80007c0c <get_arg>
8000906c:	2f dd       	sub	sp,-12
8000906e:	f8 e8 00 00 	ld.d	r8,r12[0]
80009072:	fa e9 00 00 	st.d	sp[0],r8
80009076:	c2 e8       	rjmp	800090d2 <_vfprintf_r+0x1196>
80009078:	ee ca ff ff 	sub	r10,r7,-1
8000907c:	10 37       	cp.w	r7,r8
8000907e:	c0 b4       	brge	80009094 <_vfprintf_r+0x1158>
80009080:	fa c8 f9 44 	sub	r8,sp,-1724
80009084:	14 97       	mov	r7,r10
80009086:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000908a:	ec ea fd 88 	ld.d	r10,r6[-632]
8000908e:	fa eb 00 00 	st.d	sp[0],r10
80009092:	c2 08       	rjmp	800090d2 <_vfprintf_r+0x1196>
80009094:	41 09       	lddsp	r9,sp[0x40]
80009096:	59 f8       	cp.w	r8,31
80009098:	e0 89 00 16 	brgt	800090c4 <_vfprintf_r+0x1188>
8000909c:	f2 e6 00 00 	ld.d	r6,r9[0]
800090a0:	f2 cb ff f8 	sub	r11,r9,-8
800090a4:	fa e7 00 00 	st.d	sp[0],r6
800090a8:	51 0b       	stdsp	sp[0x40],r11
800090aa:	fa c6 f9 44 	sub	r6,sp,-1724
800090ae:	ec 08 00 39 	add	r9,r6,r8<<0x3
800090b2:	fa e6 00 00 	ld.d	r6,sp[0]
800090b6:	f2 e7 fd 88 	st.d	r9[-632],r6
800090ba:	2f f8       	sub	r8,-1
800090bc:	14 97       	mov	r7,r10
800090be:	fb 48 06 b4 	st.w	sp[1716],r8
800090c2:	c0 88       	rjmp	800090d2 <_vfprintf_r+0x1196>
800090c4:	f2 e6 00 00 	ld.d	r6,r9[0]
800090c8:	2f 89       	sub	r9,-8
800090ca:	fa e7 00 00 	st.d	sp[0],r6
800090ce:	51 09       	stdsp	sp[0x40],r9
800090d0:	14 97       	mov	r7,r10
800090d2:	30 18       	mov	r8,1
800090d4:	e0 8f 01 d0 	bral	80009474 <_vfprintf_r+0x1538>
800090d8:	ed b5 00 04 	bld	r5,0x4
800090dc:	c1 61       	brne	80009108 <_vfprintf_r+0x11cc>
800090de:	fa f8 06 b4 	ld.w	r8,sp[1716]
800090e2:	40 3e       	lddsp	lr,sp[0xc]
800090e4:	58 0e       	cp.w	lr,0
800090e6:	c0 80       	breq	800090f6 <_vfprintf_r+0x11ba>
800090e8:	10 36       	cp.w	r6,r8
800090ea:	c6 74       	brge	800091b8 <_vfprintf_r+0x127c>
800090ec:	fa cc f9 44 	sub	r12,sp,-1724
800090f0:	f8 06 00 36 	add	r6,r12,r6<<0x3
800090f4:	c8 08       	rjmp	800091f4 <_vfprintf_r+0x12b8>
800090f6:	ee ca ff ff 	sub	r10,r7,-1
800090fa:	10 37       	cp.w	r7,r8
800090fc:	c7 f4       	brge	800091fa <_vfprintf_r+0x12be>
800090fe:	fa cb f9 44 	sub	r11,sp,-1724
80009102:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009106:	c7 68       	rjmp	800091f2 <_vfprintf_r+0x12b6>
80009108:	ed b5 00 06 	bld	r5,0x6
8000910c:	c4 a1       	brne	800091a0 <_vfprintf_r+0x1264>
8000910e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009112:	40 3c       	lddsp	r12,sp[0xc]
80009114:	58 0c       	cp.w	r12,0
80009116:	c1 d0       	breq	80009150 <_vfprintf_r+0x1214>
80009118:	10 36       	cp.w	r6,r8
8000911a:	c0 64       	brge	80009126 <_vfprintf_r+0x11ea>
8000911c:	fa cb f9 44 	sub	r11,sp,-1724
80009120:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009124:	c1 f8       	rjmp	80009162 <_vfprintf_r+0x1226>
80009126:	fa c8 f9 50 	sub	r8,sp,-1712
8000912a:	1a d8       	st.w	--sp,r8
8000912c:	fa c8 fa b8 	sub	r8,sp,-1352
80009130:	1a d8       	st.w	--sp,r8
80009132:	fa c8 fb b4 	sub	r8,sp,-1100
80009136:	1a d8       	st.w	--sp,r8
80009138:	fa c8 f9 40 	sub	r8,sp,-1728
8000913c:	fa c9 ff b4 	sub	r9,sp,-76
80009140:	04 9a       	mov	r10,r2
80009142:	0c 9b       	mov	r11,r6
80009144:	08 9c       	mov	r12,r4
80009146:	fe b0 f5 63 	rcall	80007c0c <get_arg>
8000914a:	2f dd       	sub	sp,-12
8000914c:	98 18       	ld.sh	r8,r12[0x2]
8000914e:	c2 68       	rjmp	8000919a <_vfprintf_r+0x125e>
80009150:	ee ca ff ff 	sub	r10,r7,-1
80009154:	10 37       	cp.w	r7,r8
80009156:	c0 94       	brge	80009168 <_vfprintf_r+0x122c>
80009158:	fa c9 f9 44 	sub	r9,sp,-1724
8000915c:	14 97       	mov	r7,r10
8000915e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009162:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009166:	c1 a8       	rjmp	8000919a <_vfprintf_r+0x125e>
80009168:	41 09       	lddsp	r9,sp[0x40]
8000916a:	59 f8       	cp.w	r8,31
8000916c:	e0 89 00 13 	brgt	80009192 <_vfprintf_r+0x1256>
80009170:	f2 cb ff fc 	sub	r11,r9,-4
80009174:	51 0b       	stdsp	sp[0x40],r11
80009176:	72 09       	ld.w	r9,r9[0x0]
80009178:	fa c6 f9 44 	sub	r6,sp,-1724
8000917c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009180:	2f f8       	sub	r8,-1
80009182:	f7 49 fd 88 	st.w	r11[-632],r9
80009186:	fb 48 06 b4 	st.w	sp[1716],r8
8000918a:	14 97       	mov	r7,r10
8000918c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009190:	c0 58       	rjmp	8000919a <_vfprintf_r+0x125e>
80009192:	92 18       	ld.sh	r8,r9[0x2]
80009194:	14 97       	mov	r7,r10
80009196:	2f c9       	sub	r9,-4
80009198:	51 09       	stdsp	sp[0x40],r9
8000919a:	5c 78       	castu.h	r8
8000919c:	50 18       	stdsp	sp[0x4],r8
8000919e:	c4 68       	rjmp	8000922a <_vfprintf_r+0x12ee>
800091a0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800091a4:	40 3c       	lddsp	r12,sp[0xc]
800091a6:	58 0c       	cp.w	r12,0
800091a8:	c1 d0       	breq	800091e2 <_vfprintf_r+0x12a6>
800091aa:	10 36       	cp.w	r6,r8
800091ac:	c0 64       	brge	800091b8 <_vfprintf_r+0x127c>
800091ae:	fa cb f9 44 	sub	r11,sp,-1724
800091b2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800091b6:	c1 f8       	rjmp	800091f4 <_vfprintf_r+0x12b8>
800091b8:	fa c8 f9 50 	sub	r8,sp,-1712
800091bc:	1a d8       	st.w	--sp,r8
800091be:	fa c8 fa b8 	sub	r8,sp,-1352
800091c2:	0c 9b       	mov	r11,r6
800091c4:	1a d8       	st.w	--sp,r8
800091c6:	fa c8 fb b4 	sub	r8,sp,-1100
800091ca:	04 9a       	mov	r10,r2
800091cc:	1a d8       	st.w	--sp,r8
800091ce:	08 9c       	mov	r12,r4
800091d0:	fa c8 f9 40 	sub	r8,sp,-1728
800091d4:	fa c9 ff b4 	sub	r9,sp,-76
800091d8:	fe b0 f5 1a 	rcall	80007c0c <get_arg>
800091dc:	2f dd       	sub	sp,-12
800091de:	78 0b       	ld.w	r11,r12[0x0]
800091e0:	c2 48       	rjmp	80009228 <_vfprintf_r+0x12ec>
800091e2:	ee ca ff ff 	sub	r10,r7,-1
800091e6:	10 37       	cp.w	r7,r8
800091e8:	c0 94       	brge	800091fa <_vfprintf_r+0x12be>
800091ea:	fa c9 f9 44 	sub	r9,sp,-1724
800091ee:	f2 06 00 36 	add	r6,r9,r6<<0x3
800091f2:	14 97       	mov	r7,r10
800091f4:	ec fb fd 88 	ld.w	r11,r6[-632]
800091f8:	c1 88       	rjmp	80009228 <_vfprintf_r+0x12ec>
800091fa:	41 09       	lddsp	r9,sp[0x40]
800091fc:	59 f8       	cp.w	r8,31
800091fe:	e0 89 00 11 	brgt	80009220 <_vfprintf_r+0x12e4>
80009202:	f2 cb ff fc 	sub	r11,r9,-4
80009206:	51 0b       	stdsp	sp[0x40],r11
80009208:	fa c6 f9 44 	sub	r6,sp,-1724
8000920c:	72 0b       	ld.w	r11,r9[0x0]
8000920e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009212:	f3 4b fd 88 	st.w	r9[-632],r11
80009216:	2f f8       	sub	r8,-1
80009218:	14 97       	mov	r7,r10
8000921a:	fb 48 06 b4 	st.w	sp[1716],r8
8000921e:	c0 58       	rjmp	80009228 <_vfprintf_r+0x12ec>
80009220:	72 0b       	ld.w	r11,r9[0x0]
80009222:	14 97       	mov	r7,r10
80009224:	2f c9       	sub	r9,-4
80009226:	51 09       	stdsp	sp[0x40],r9
80009228:	50 1b       	stdsp	sp[0x4],r11
8000922a:	30 0e       	mov	lr,0
8000922c:	30 18       	mov	r8,1
8000922e:	50 0e       	stdsp	sp[0x0],lr
80009230:	c2 29       	rjmp	80009474 <_vfprintf_r+0x1538>
80009232:	50 a7       	stdsp	sp[0x28],r7
80009234:	50 80       	stdsp	sp[0x20],r0
80009236:	0c 97       	mov	r7,r6
80009238:	04 94       	mov	r4,r2
8000923a:	06 96       	mov	r6,r3
8000923c:	02 92       	mov	r2,r1
8000923e:	fe cc b4 96 	sub	r12,pc,-19306
80009242:	40 93       	lddsp	r3,sp[0x24]
80009244:	10 90       	mov	r0,r8
80009246:	40 41       	lddsp	r1,sp[0x10]
80009248:	50 dc       	stdsp	sp[0x34],r12
8000924a:	ed b5 00 05 	bld	r5,0x5
8000924e:	c5 51       	brne	800092f8 <_vfprintf_r+0x13bc>
80009250:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009254:	40 3b       	lddsp	r11,sp[0xc]
80009256:	58 0b       	cp.w	r11,0
80009258:	c2 20       	breq	8000929c <_vfprintf_r+0x1360>
8000925a:	10 36       	cp.w	r6,r8
8000925c:	c0 a4       	brge	80009270 <_vfprintf_r+0x1334>
8000925e:	fa ca f9 44 	sub	r10,sp,-1724
80009262:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009266:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000926a:	fa e9 00 00 	st.d	sp[0],r8
8000926e:	cf 28       	rjmp	80009452 <_vfprintf_r+0x1516>
80009270:	fa c8 f9 50 	sub	r8,sp,-1712
80009274:	1a d8       	st.w	--sp,r8
80009276:	fa c8 fa b8 	sub	r8,sp,-1352
8000927a:	04 9a       	mov	r10,r2
8000927c:	1a d8       	st.w	--sp,r8
8000927e:	0c 9b       	mov	r11,r6
80009280:	fa c8 fb b4 	sub	r8,sp,-1100
80009284:	08 9c       	mov	r12,r4
80009286:	1a d8       	st.w	--sp,r8
80009288:	fa c8 f9 40 	sub	r8,sp,-1728
8000928c:	fa c9 ff b4 	sub	r9,sp,-76
80009290:	fe b0 f4 be 	rcall	80007c0c <get_arg>
80009294:	2f dd       	sub	sp,-12
80009296:	f8 ea 00 00 	ld.d	r10,r12[0]
8000929a:	c0 c8       	rjmp	800092b2 <_vfprintf_r+0x1376>
8000929c:	ee ca ff ff 	sub	r10,r7,-1
800092a0:	10 37       	cp.w	r7,r8
800092a2:	c0 b4       	brge	800092b8 <_vfprintf_r+0x137c>
800092a4:	fa c9 f9 44 	sub	r9,sp,-1724
800092a8:	14 97       	mov	r7,r10
800092aa:	f2 06 00 36 	add	r6,r9,r6<<0x3
800092ae:	ec ea fd 88 	ld.d	r10,r6[-632]
800092b2:	fa eb 00 00 	st.d	sp[0],r10
800092b6:	cc e8       	rjmp	80009452 <_vfprintf_r+0x1516>
800092b8:	41 09       	lddsp	r9,sp[0x40]
800092ba:	59 f8       	cp.w	r8,31
800092bc:	e0 89 00 16 	brgt	800092e8 <_vfprintf_r+0x13ac>
800092c0:	f2 e6 00 00 	ld.d	r6,r9[0]
800092c4:	f2 cb ff f8 	sub	r11,r9,-8
800092c8:	fa e7 00 00 	st.d	sp[0],r6
800092cc:	51 0b       	stdsp	sp[0x40],r11
800092ce:	fa c6 f9 44 	sub	r6,sp,-1724
800092d2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800092d6:	fa e6 00 00 	ld.d	r6,sp[0]
800092da:	f2 e7 fd 88 	st.d	r9[-632],r6
800092de:	2f f8       	sub	r8,-1
800092e0:	14 97       	mov	r7,r10
800092e2:	fb 48 06 b4 	st.w	sp[1716],r8
800092e6:	cb 68       	rjmp	80009452 <_vfprintf_r+0x1516>
800092e8:	f2 e6 00 00 	ld.d	r6,r9[0]
800092ec:	2f 89       	sub	r9,-8
800092ee:	fa e7 00 00 	st.d	sp[0],r6
800092f2:	51 09       	stdsp	sp[0x40],r9
800092f4:	14 97       	mov	r7,r10
800092f6:	ca e8       	rjmp	80009452 <_vfprintf_r+0x1516>
800092f8:	ed b5 00 04 	bld	r5,0x4
800092fc:	c1 71       	brne	8000932a <_vfprintf_r+0x13ee>
800092fe:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009302:	40 3e       	lddsp	lr,sp[0xc]
80009304:	58 0e       	cp.w	lr,0
80009306:	c0 80       	breq	80009316 <_vfprintf_r+0x13da>
80009308:	10 36       	cp.w	r6,r8
8000930a:	c6 94       	brge	800093dc <_vfprintf_r+0x14a0>
8000930c:	fa cc f9 44 	sub	r12,sp,-1724
80009310:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009314:	c8 28       	rjmp	80009418 <_vfprintf_r+0x14dc>
80009316:	ee ca ff ff 	sub	r10,r7,-1
8000931a:	10 37       	cp.w	r7,r8
8000931c:	e0 84 00 81 	brge	8000941e <_vfprintf_r+0x14e2>
80009320:	fa cb f9 44 	sub	r11,sp,-1724
80009324:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009328:	c7 78       	rjmp	80009416 <_vfprintf_r+0x14da>
8000932a:	ed b5 00 06 	bld	r5,0x6
8000932e:	c4 b1       	brne	800093c4 <_vfprintf_r+0x1488>
80009330:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009334:	40 3c       	lddsp	r12,sp[0xc]
80009336:	58 0c       	cp.w	r12,0
80009338:	c1 d0       	breq	80009372 <_vfprintf_r+0x1436>
8000933a:	10 36       	cp.w	r6,r8
8000933c:	c0 64       	brge	80009348 <_vfprintf_r+0x140c>
8000933e:	fa cb f9 44 	sub	r11,sp,-1724
80009342:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009346:	c1 f8       	rjmp	80009384 <_vfprintf_r+0x1448>
80009348:	fa c8 f9 50 	sub	r8,sp,-1712
8000934c:	1a d8       	st.w	--sp,r8
8000934e:	fa c8 fa b8 	sub	r8,sp,-1352
80009352:	1a d8       	st.w	--sp,r8
80009354:	fa c8 fb b4 	sub	r8,sp,-1100
80009358:	1a d8       	st.w	--sp,r8
8000935a:	fa c8 f9 40 	sub	r8,sp,-1728
8000935e:	fa c9 ff b4 	sub	r9,sp,-76
80009362:	04 9a       	mov	r10,r2
80009364:	0c 9b       	mov	r11,r6
80009366:	08 9c       	mov	r12,r4
80009368:	fe b0 f4 52 	rcall	80007c0c <get_arg>
8000936c:	2f dd       	sub	sp,-12
8000936e:	98 18       	ld.sh	r8,r12[0x2]
80009370:	c2 78       	rjmp	800093be <_vfprintf_r+0x1482>
80009372:	ee ca ff ff 	sub	r10,r7,-1
80009376:	10 37       	cp.w	r7,r8
80009378:	c0 a4       	brge	8000938c <_vfprintf_r+0x1450>
8000937a:	fa c9 f9 44 	sub	r9,sp,-1724
8000937e:	14 97       	mov	r7,r10
80009380:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009384:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009388:	c1 b8       	rjmp	800093be <_vfprintf_r+0x1482>
8000938a:	d7 03       	nop
8000938c:	41 09       	lddsp	r9,sp[0x40]
8000938e:	59 f8       	cp.w	r8,31
80009390:	e0 89 00 13 	brgt	800093b6 <_vfprintf_r+0x147a>
80009394:	f2 cb ff fc 	sub	r11,r9,-4
80009398:	51 0b       	stdsp	sp[0x40],r11
8000939a:	72 09       	ld.w	r9,r9[0x0]
8000939c:	fa c6 f9 44 	sub	r6,sp,-1724
800093a0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800093a4:	2f f8       	sub	r8,-1
800093a6:	f7 49 fd 88 	st.w	r11[-632],r9
800093aa:	fb 48 06 b4 	st.w	sp[1716],r8
800093ae:	14 97       	mov	r7,r10
800093b0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800093b4:	c0 58       	rjmp	800093be <_vfprintf_r+0x1482>
800093b6:	92 18       	ld.sh	r8,r9[0x2]
800093b8:	14 97       	mov	r7,r10
800093ba:	2f c9       	sub	r9,-4
800093bc:	51 09       	stdsp	sp[0x40],r9
800093be:	5c 78       	castu.h	r8
800093c0:	50 18       	stdsp	sp[0x4],r8
800093c2:	c4 68       	rjmp	8000944e <_vfprintf_r+0x1512>
800093c4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800093c8:	40 3c       	lddsp	r12,sp[0xc]
800093ca:	58 0c       	cp.w	r12,0
800093cc:	c1 d0       	breq	80009406 <_vfprintf_r+0x14ca>
800093ce:	10 36       	cp.w	r6,r8
800093d0:	c0 64       	brge	800093dc <_vfprintf_r+0x14a0>
800093d2:	fa cb f9 44 	sub	r11,sp,-1724
800093d6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800093da:	c1 f8       	rjmp	80009418 <_vfprintf_r+0x14dc>
800093dc:	fa c8 f9 50 	sub	r8,sp,-1712
800093e0:	1a d8       	st.w	--sp,r8
800093e2:	fa c8 fa b8 	sub	r8,sp,-1352
800093e6:	0c 9b       	mov	r11,r6
800093e8:	1a d8       	st.w	--sp,r8
800093ea:	fa c8 fb b4 	sub	r8,sp,-1100
800093ee:	04 9a       	mov	r10,r2
800093f0:	1a d8       	st.w	--sp,r8
800093f2:	08 9c       	mov	r12,r4
800093f4:	fa c8 f9 40 	sub	r8,sp,-1728
800093f8:	fa c9 ff b4 	sub	r9,sp,-76
800093fc:	fe b0 f4 08 	rcall	80007c0c <get_arg>
80009400:	2f dd       	sub	sp,-12
80009402:	78 0b       	ld.w	r11,r12[0x0]
80009404:	c2 48       	rjmp	8000944c <_vfprintf_r+0x1510>
80009406:	ee ca ff ff 	sub	r10,r7,-1
8000940a:	10 37       	cp.w	r7,r8
8000940c:	c0 94       	brge	8000941e <_vfprintf_r+0x14e2>
8000940e:	fa c9 f9 44 	sub	r9,sp,-1724
80009412:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009416:	14 97       	mov	r7,r10
80009418:	ec fb fd 88 	ld.w	r11,r6[-632]
8000941c:	c1 88       	rjmp	8000944c <_vfprintf_r+0x1510>
8000941e:	41 09       	lddsp	r9,sp[0x40]
80009420:	59 f8       	cp.w	r8,31
80009422:	e0 89 00 11 	brgt	80009444 <_vfprintf_r+0x1508>
80009426:	f2 cb ff fc 	sub	r11,r9,-4
8000942a:	51 0b       	stdsp	sp[0x40],r11
8000942c:	fa c6 f9 44 	sub	r6,sp,-1724
80009430:	72 0b       	ld.w	r11,r9[0x0]
80009432:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009436:	f3 4b fd 88 	st.w	r9[-632],r11
8000943a:	2f f8       	sub	r8,-1
8000943c:	14 97       	mov	r7,r10
8000943e:	fb 48 06 b4 	st.w	sp[1716],r8
80009442:	c0 58       	rjmp	8000944c <_vfprintf_r+0x1510>
80009444:	72 0b       	ld.w	r11,r9[0x0]
80009446:	14 97       	mov	r7,r10
80009448:	2f c9       	sub	r9,-4
8000944a:	51 09       	stdsp	sp[0x40],r9
8000944c:	50 1b       	stdsp	sp[0x4],r11
8000944e:	30 0e       	mov	lr,0
80009450:	50 0e       	stdsp	sp[0x0],lr
80009452:	40 08       	lddsp	r8,sp[0x0]
80009454:	40 1c       	lddsp	r12,sp[0x4]
80009456:	18 48       	or	r8,r12
80009458:	5f 19       	srne	r9
8000945a:	0a 98       	mov	r8,r5
8000945c:	eb e9 00 09 	and	r9,r5,r9
80009460:	a1 b8       	sbr	r8,0x1
80009462:	58 09       	cp.w	r9,0
80009464:	c0 70       	breq	80009472 <_vfprintf_r+0x1536>
80009466:	10 95       	mov	r5,r8
80009468:	fb 60 06 b9 	st.b	sp[1721],r0
8000946c:	33 08       	mov	r8,48
8000946e:	fb 68 06 b8 	st.b	sp[1720],r8
80009472:	30 28       	mov	r8,2
80009474:	30 09       	mov	r9,0
80009476:	fb 69 06 bb 	st.b	sp[1723],r9
8000947a:	0a 99       	mov	r9,r5
8000947c:	a7 d9       	cbr	r9,0x7
8000947e:	40 2b       	lddsp	r11,sp[0x8]
80009480:	40 16       	lddsp	r6,sp[0x4]
80009482:	58 0b       	cp.w	r11,0
80009484:	5f 1a       	srne	r10
80009486:	f2 05 17 40 	movge	r5,r9
8000948a:	fa c2 f9 78 	sub	r2,sp,-1672
8000948e:	40 09       	lddsp	r9,sp[0x0]
80009490:	0c 49       	or	r9,r6
80009492:	5f 19       	srne	r9
80009494:	f5 e9 10 09 	or	r9,r10,r9
80009498:	c5 c0       	breq	80009550 <_vfprintf_r+0x1614>
8000949a:	30 19       	mov	r9,1
8000949c:	f2 08 18 00 	cp.b	r8,r9
800094a0:	c0 60       	breq	800094ac <_vfprintf_r+0x1570>
800094a2:	30 29       	mov	r9,2
800094a4:	f2 08 18 00 	cp.b	r8,r9
800094a8:	c0 41       	brne	800094b0 <_vfprintf_r+0x1574>
800094aa:	c3 c8       	rjmp	80009522 <_vfprintf_r+0x15e6>
800094ac:	04 96       	mov	r6,r2
800094ae:	c3 08       	rjmp	8000950e <_vfprintf_r+0x15d2>
800094b0:	04 96       	mov	r6,r2
800094b2:	fa e8 00 00 	ld.d	r8,sp[0]
800094b6:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800094ba:	2d 0a       	sub	r10,-48
800094bc:	0c fa       	st.b	--r6,r10
800094be:	f0 0b 16 03 	lsr	r11,r8,0x3
800094c2:	f2 0c 16 03 	lsr	r12,r9,0x3
800094c6:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
800094ca:	18 99       	mov	r9,r12
800094cc:	16 98       	mov	r8,r11
800094ce:	58 08       	cp.w	r8,0
800094d0:	5c 29       	cpc	r9
800094d2:	cf 21       	brne	800094b6 <_vfprintf_r+0x157a>
800094d4:	fa e9 00 00 	st.d	sp[0],r8
800094d8:	ed b5 00 00 	bld	r5,0x0
800094dc:	c4 51       	brne	80009566 <_vfprintf_r+0x162a>
800094de:	33 09       	mov	r9,48
800094e0:	f2 0a 18 00 	cp.b	r10,r9
800094e4:	c4 10       	breq	80009566 <_vfprintf_r+0x162a>
800094e6:	0c f9       	st.b	--r6,r9
800094e8:	c3 f8       	rjmp	80009566 <_vfprintf_r+0x162a>
800094ea:	fa ea 00 00 	ld.d	r10,sp[0]
800094ee:	30 a8       	mov	r8,10
800094f0:	30 09       	mov	r9,0
800094f2:	e0 a0 1a 19 	rcall	8000c924 <__avr32_umod64>
800094f6:	30 a8       	mov	r8,10
800094f8:	2d 0a       	sub	r10,-48
800094fa:	30 09       	mov	r9,0
800094fc:	ac 8a       	st.b	r6[0x0],r10
800094fe:	fa ea 00 00 	ld.d	r10,sp[0]
80009502:	e0 a0 18 df 	rcall	8000c6c0 <__avr32_udiv64>
80009506:	16 99       	mov	r9,r11
80009508:	14 98       	mov	r8,r10
8000950a:	fa e9 00 00 	st.d	sp[0],r8
8000950e:	20 16       	sub	r6,1
80009510:	fa ea 00 00 	ld.d	r10,sp[0]
80009514:	58 9a       	cp.w	r10,9
80009516:	5c 2b       	cpc	r11
80009518:	fe 9b ff e9 	brhi	800094ea <_vfprintf_r+0x15ae>
8000951c:	1b f8       	ld.ub	r8,sp[0x7]
8000951e:	2d 08       	sub	r8,-48
80009520:	c2 08       	rjmp	80009560 <_vfprintf_r+0x1624>
80009522:	04 96       	mov	r6,r2
80009524:	fa e8 00 00 	ld.d	r8,sp[0]
80009528:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000952c:	40 de       	lddsp	lr,sp[0x34]
8000952e:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80009532:	0c fa       	st.b	--r6,r10
80009534:	f2 0b 16 04 	lsr	r11,r9,0x4
80009538:	f0 0a 16 04 	lsr	r10,r8,0x4
8000953c:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009540:	16 99       	mov	r9,r11
80009542:	14 98       	mov	r8,r10
80009544:	58 08       	cp.w	r8,0
80009546:	5c 29       	cpc	r9
80009548:	cf 01       	brne	80009528 <_vfprintf_r+0x15ec>
8000954a:	fa e9 00 00 	st.d	sp[0],r8
8000954e:	c0 c8       	rjmp	80009566 <_vfprintf_r+0x162a>
80009550:	58 08       	cp.w	r8,0
80009552:	c0 91       	brne	80009564 <_vfprintf_r+0x1628>
80009554:	ed b5 00 00 	bld	r5,0x0
80009558:	c0 61       	brne	80009564 <_vfprintf_r+0x1628>
8000955a:	fa c6 f9 79 	sub	r6,sp,-1671
8000955e:	33 08       	mov	r8,48
80009560:	ac 88       	st.b	r6[0x0],r8
80009562:	c0 28       	rjmp	80009566 <_vfprintf_r+0x162a>
80009564:	04 96       	mov	r6,r2
80009566:	0c 12       	sub	r2,r6
80009568:	c1 c8       	rjmp	800095a0 <_vfprintf_r+0x1664>
8000956a:	50 a7       	stdsp	sp[0x28],r7
8000956c:	50 80       	stdsp	sp[0x20],r0
8000956e:	40 93       	lddsp	r3,sp[0x24]
80009570:	0c 97       	mov	r7,r6
80009572:	10 90       	mov	r0,r8
80009574:	04 94       	mov	r4,r2
80009576:	40 41       	lddsp	r1,sp[0x10]
80009578:	58 08       	cp.w	r8,0
8000957a:	e0 80 04 4f 	breq	80009e18 <_vfprintf_r+0x1edc>
8000957e:	fb 68 06 60 	st.b	sp[1632],r8
80009582:	30 0c       	mov	r12,0
80009584:	30 08       	mov	r8,0
80009586:	30 12       	mov	r2,1
80009588:	fb 68 06 bb 	st.b	sp[1723],r8
8000958c:	50 2c       	stdsp	sp[0x8],r12
8000958e:	fa c6 f9 a0 	sub	r6,sp,-1632
80009592:	c0 78       	rjmp	800095a0 <_vfprintf_r+0x1664>
80009594:	30 0b       	mov	r11,0
80009596:	50 2b       	stdsp	sp[0x8],r11
80009598:	c0 48       	rjmp	800095a0 <_vfprintf_r+0x1664>
8000959a:	40 22       	lddsp	r2,sp[0x8]
8000959c:	30 0a       	mov	r10,0
8000959e:	50 2a       	stdsp	sp[0x8],r10
800095a0:	40 29       	lddsp	r9,sp[0x8]
800095a2:	e4 09 0c 49 	max	r9,r2,r9
800095a6:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800095aa:	50 39       	stdsp	sp[0xc],r9
800095ac:	0a 9e       	mov	lr,r5
800095ae:	30 09       	mov	r9,0
800095b0:	e2 1e 00 02 	andl	lr,0x2,COH
800095b4:	f2 08 18 00 	cp.b	r8,r9
800095b8:	fb f8 10 03 	ld.wne	r8,sp[0xc]
800095bc:	f7 b8 01 ff 	subne	r8,-1
800095c0:	fb f8 1a 03 	st.wne	sp[0xc],r8
800095c4:	0a 9b       	mov	r11,r5
800095c6:	58 0e       	cp.w	lr,0
800095c8:	fb fc 10 03 	ld.wne	r12,sp[0xc]
800095cc:	f7 bc 01 fe 	subne	r12,-2
800095d0:	fb fc 1a 03 	st.wne	sp[0xc],r12
800095d4:	e2 1b 00 84 	andl	r11,0x84,COH
800095d8:	50 fe       	stdsp	sp[0x3c],lr
800095da:	50 9b       	stdsp	sp[0x24],r11
800095dc:	c4 71       	brne	8000966a <_vfprintf_r+0x172e>
800095de:	40 8a       	lddsp	r10,sp[0x20]
800095e0:	40 39       	lddsp	r9,sp[0xc]
800095e2:	12 1a       	sub	r10,r9
800095e4:	50 4a       	stdsp	sp[0x10],r10
800095e6:	58 0a       	cp.w	r10,0
800095e8:	e0 89 00 20 	brgt	80009628 <_vfprintf_r+0x16ec>
800095ec:	c3 f8       	rjmp	8000966a <_vfprintf_r+0x172e>
800095ee:	2f 09       	sub	r9,-16
800095f0:	2f f8       	sub	r8,-1
800095f2:	fe ce b8 32 	sub	lr,pc,-18382
800095f6:	31 0c       	mov	r12,16
800095f8:	fb 49 06 90 	st.w	sp[1680],r9
800095fc:	87 0e       	st.w	r3[0x0],lr
800095fe:	87 1c       	st.w	r3[0x4],r12
80009600:	fb 48 06 8c 	st.w	sp[1676],r8
80009604:	58 78       	cp.w	r8,7
80009606:	e0 89 00 04 	brgt	8000960e <_vfprintf_r+0x16d2>
8000960a:	2f 83       	sub	r3,-8
8000960c:	c0 b8       	rjmp	80009622 <_vfprintf_r+0x16e6>
8000960e:	fa ca f9 78 	sub	r10,sp,-1672
80009612:	02 9b       	mov	r11,r1
80009614:	08 9c       	mov	r12,r4
80009616:	fe b0 f4 85 	rcall	80007f20 <__sprint_r>
8000961a:	e0 81 04 10 	brne	80009e3a <_vfprintf_r+0x1efe>
8000961e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009622:	40 4b       	lddsp	r11,sp[0x10]
80009624:	21 0b       	sub	r11,16
80009626:	50 4b       	stdsp	sp[0x10],r11
80009628:	fa f9 06 90 	ld.w	r9,sp[1680]
8000962c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009630:	fe ca b8 70 	sub	r10,pc,-18320
80009634:	40 4e       	lddsp	lr,sp[0x10]
80009636:	59 0e       	cp.w	lr,16
80009638:	fe 99 ff db 	brgt	800095ee <_vfprintf_r+0x16b2>
8000963c:	1c 09       	add	r9,lr
8000963e:	2f f8       	sub	r8,-1
80009640:	87 0a       	st.w	r3[0x0],r10
80009642:	fb 49 06 90 	st.w	sp[1680],r9
80009646:	87 1e       	st.w	r3[0x4],lr
80009648:	fb 48 06 8c 	st.w	sp[1676],r8
8000964c:	58 78       	cp.w	r8,7
8000964e:	e0 89 00 04 	brgt	80009656 <_vfprintf_r+0x171a>
80009652:	2f 83       	sub	r3,-8
80009654:	c0 b8       	rjmp	8000966a <_vfprintf_r+0x172e>
80009656:	fa ca f9 78 	sub	r10,sp,-1672
8000965a:	02 9b       	mov	r11,r1
8000965c:	08 9c       	mov	r12,r4
8000965e:	fe b0 f4 61 	rcall	80007f20 <__sprint_r>
80009662:	e0 81 03 ec 	brne	80009e3a <_vfprintf_r+0x1efe>
80009666:	fa c3 f9 e0 	sub	r3,sp,-1568
8000966a:	30 09       	mov	r9,0
8000966c:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009670:	f2 08 18 00 	cp.b	r8,r9
80009674:	c1 f0       	breq	800096b2 <_vfprintf_r+0x1776>
80009676:	fa f8 06 90 	ld.w	r8,sp[1680]
8000967a:	fa c9 f9 45 	sub	r9,sp,-1723
8000967e:	2f f8       	sub	r8,-1
80009680:	87 09       	st.w	r3[0x0],r9
80009682:	fb 48 06 90 	st.w	sp[1680],r8
80009686:	30 19       	mov	r9,1
80009688:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000968c:	87 19       	st.w	r3[0x4],r9
8000968e:	2f f8       	sub	r8,-1
80009690:	fb 48 06 8c 	st.w	sp[1676],r8
80009694:	58 78       	cp.w	r8,7
80009696:	e0 89 00 04 	brgt	8000969e <_vfprintf_r+0x1762>
8000969a:	2f 83       	sub	r3,-8
8000969c:	c0 b8       	rjmp	800096b2 <_vfprintf_r+0x1776>
8000969e:	fa ca f9 78 	sub	r10,sp,-1672
800096a2:	02 9b       	mov	r11,r1
800096a4:	08 9c       	mov	r12,r4
800096a6:	fe b0 f4 3d 	rcall	80007f20 <__sprint_r>
800096aa:	e0 81 03 c8 	brne	80009e3a <_vfprintf_r+0x1efe>
800096ae:	fa c3 f9 e0 	sub	r3,sp,-1568
800096b2:	40 fc       	lddsp	r12,sp[0x3c]
800096b4:	58 0c       	cp.w	r12,0
800096b6:	c1 f0       	breq	800096f4 <_vfprintf_r+0x17b8>
800096b8:	fa f8 06 90 	ld.w	r8,sp[1680]
800096bc:	fa c9 f9 48 	sub	r9,sp,-1720
800096c0:	2f e8       	sub	r8,-2
800096c2:	87 09       	st.w	r3[0x0],r9
800096c4:	fb 48 06 90 	st.w	sp[1680],r8
800096c8:	30 29       	mov	r9,2
800096ca:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096ce:	87 19       	st.w	r3[0x4],r9
800096d0:	2f f8       	sub	r8,-1
800096d2:	fb 48 06 8c 	st.w	sp[1676],r8
800096d6:	58 78       	cp.w	r8,7
800096d8:	e0 89 00 04 	brgt	800096e0 <_vfprintf_r+0x17a4>
800096dc:	2f 83       	sub	r3,-8
800096de:	c0 b8       	rjmp	800096f4 <_vfprintf_r+0x17b8>
800096e0:	fa ca f9 78 	sub	r10,sp,-1672
800096e4:	02 9b       	mov	r11,r1
800096e6:	08 9c       	mov	r12,r4
800096e8:	fe b0 f4 1c 	rcall	80007f20 <__sprint_r>
800096ec:	e0 81 03 a7 	brne	80009e3a <_vfprintf_r+0x1efe>
800096f0:	fa c3 f9 e0 	sub	r3,sp,-1568
800096f4:	40 9b       	lddsp	r11,sp[0x24]
800096f6:	e0 4b 00 80 	cp.w	r11,128
800096fa:	c4 71       	brne	80009788 <_vfprintf_r+0x184c>
800096fc:	40 8a       	lddsp	r10,sp[0x20]
800096fe:	40 39       	lddsp	r9,sp[0xc]
80009700:	12 1a       	sub	r10,r9
80009702:	50 4a       	stdsp	sp[0x10],r10
80009704:	58 0a       	cp.w	r10,0
80009706:	e0 89 00 20 	brgt	80009746 <_vfprintf_r+0x180a>
8000970a:	c3 f8       	rjmp	80009788 <_vfprintf_r+0x184c>
8000970c:	2f 09       	sub	r9,-16
8000970e:	2f f8       	sub	r8,-1
80009710:	fe ce b9 40 	sub	lr,pc,-18112
80009714:	31 0c       	mov	r12,16
80009716:	fb 49 06 90 	st.w	sp[1680],r9
8000971a:	87 0e       	st.w	r3[0x0],lr
8000971c:	87 1c       	st.w	r3[0x4],r12
8000971e:	fb 48 06 8c 	st.w	sp[1676],r8
80009722:	58 78       	cp.w	r8,7
80009724:	e0 89 00 04 	brgt	8000972c <_vfprintf_r+0x17f0>
80009728:	2f 83       	sub	r3,-8
8000972a:	c0 b8       	rjmp	80009740 <_vfprintf_r+0x1804>
8000972c:	fa ca f9 78 	sub	r10,sp,-1672
80009730:	02 9b       	mov	r11,r1
80009732:	08 9c       	mov	r12,r4
80009734:	fe b0 f3 f6 	rcall	80007f20 <__sprint_r>
80009738:	e0 81 03 81 	brne	80009e3a <_vfprintf_r+0x1efe>
8000973c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009740:	40 4b       	lddsp	r11,sp[0x10]
80009742:	21 0b       	sub	r11,16
80009744:	50 4b       	stdsp	sp[0x10],r11
80009746:	fa f9 06 90 	ld.w	r9,sp[1680]
8000974a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000974e:	fe ca b9 7e 	sub	r10,pc,-18050
80009752:	40 4e       	lddsp	lr,sp[0x10]
80009754:	59 0e       	cp.w	lr,16
80009756:	fe 99 ff db 	brgt	8000970c <_vfprintf_r+0x17d0>
8000975a:	1c 09       	add	r9,lr
8000975c:	2f f8       	sub	r8,-1
8000975e:	87 0a       	st.w	r3[0x0],r10
80009760:	fb 49 06 90 	st.w	sp[1680],r9
80009764:	87 1e       	st.w	r3[0x4],lr
80009766:	fb 48 06 8c 	st.w	sp[1676],r8
8000976a:	58 78       	cp.w	r8,7
8000976c:	e0 89 00 04 	brgt	80009774 <_vfprintf_r+0x1838>
80009770:	2f 83       	sub	r3,-8
80009772:	c0 b8       	rjmp	80009788 <_vfprintf_r+0x184c>
80009774:	fa ca f9 78 	sub	r10,sp,-1672
80009778:	02 9b       	mov	r11,r1
8000977a:	08 9c       	mov	r12,r4
8000977c:	fe b0 f3 d2 	rcall	80007f20 <__sprint_r>
80009780:	e0 81 03 5d 	brne	80009e3a <_vfprintf_r+0x1efe>
80009784:	fa c3 f9 e0 	sub	r3,sp,-1568
80009788:	40 2c       	lddsp	r12,sp[0x8]
8000978a:	04 1c       	sub	r12,r2
8000978c:	50 2c       	stdsp	sp[0x8],r12
8000978e:	58 0c       	cp.w	r12,0
80009790:	e0 89 00 20 	brgt	800097d0 <_vfprintf_r+0x1894>
80009794:	c3 f8       	rjmp	80009812 <_vfprintf_r+0x18d6>
80009796:	2f 09       	sub	r9,-16
80009798:	2f f8       	sub	r8,-1
8000979a:	fe cb b9 ca 	sub	r11,pc,-17974
8000979e:	31 0a       	mov	r10,16
800097a0:	fb 49 06 90 	st.w	sp[1680],r9
800097a4:	87 0b       	st.w	r3[0x0],r11
800097a6:	87 1a       	st.w	r3[0x4],r10
800097a8:	fb 48 06 8c 	st.w	sp[1676],r8
800097ac:	58 78       	cp.w	r8,7
800097ae:	e0 89 00 04 	brgt	800097b6 <_vfprintf_r+0x187a>
800097b2:	2f 83       	sub	r3,-8
800097b4:	c0 b8       	rjmp	800097ca <_vfprintf_r+0x188e>
800097b6:	fa ca f9 78 	sub	r10,sp,-1672
800097ba:	02 9b       	mov	r11,r1
800097bc:	08 9c       	mov	r12,r4
800097be:	fe b0 f3 b1 	rcall	80007f20 <__sprint_r>
800097c2:	e0 81 03 3c 	brne	80009e3a <_vfprintf_r+0x1efe>
800097c6:	fa c3 f9 e0 	sub	r3,sp,-1568
800097ca:	40 29       	lddsp	r9,sp[0x8]
800097cc:	21 09       	sub	r9,16
800097ce:	50 29       	stdsp	sp[0x8],r9
800097d0:	fa f9 06 90 	ld.w	r9,sp[1680]
800097d4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097d8:	fe ca ba 08 	sub	r10,pc,-17912
800097dc:	40 2e       	lddsp	lr,sp[0x8]
800097de:	59 0e       	cp.w	lr,16
800097e0:	fe 99 ff db 	brgt	80009796 <_vfprintf_r+0x185a>
800097e4:	1c 09       	add	r9,lr
800097e6:	2f f8       	sub	r8,-1
800097e8:	87 0a       	st.w	r3[0x0],r10
800097ea:	fb 49 06 90 	st.w	sp[1680],r9
800097ee:	87 1e       	st.w	r3[0x4],lr
800097f0:	fb 48 06 8c 	st.w	sp[1676],r8
800097f4:	58 78       	cp.w	r8,7
800097f6:	e0 89 00 04 	brgt	800097fe <_vfprintf_r+0x18c2>
800097fa:	2f 83       	sub	r3,-8
800097fc:	c0 b8       	rjmp	80009812 <_vfprintf_r+0x18d6>
800097fe:	fa ca f9 78 	sub	r10,sp,-1672
80009802:	02 9b       	mov	r11,r1
80009804:	08 9c       	mov	r12,r4
80009806:	fe b0 f3 8d 	rcall	80007f20 <__sprint_r>
8000980a:	e0 81 03 18 	brne	80009e3a <_vfprintf_r+0x1efe>
8000980e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009812:	ed b5 00 08 	bld	r5,0x8
80009816:	c0 b0       	breq	8000982c <_vfprintf_r+0x18f0>
80009818:	fa f8 06 90 	ld.w	r8,sp[1680]
8000981c:	87 12       	st.w	r3[0x4],r2
8000981e:	87 06       	st.w	r3[0x0],r6
80009820:	f0 02 00 02 	add	r2,r8,r2
80009824:	fb 42 06 90 	st.w	sp[1680],r2
80009828:	e0 8f 01 d4 	bral	80009bd0 <_vfprintf_r+0x1c94>
8000982c:	e0 40 00 65 	cp.w	r0,101
80009830:	e0 8a 01 d6 	brle	80009bdc <_vfprintf_r+0x1ca0>
80009834:	30 08       	mov	r8,0
80009836:	30 09       	mov	r9,0
80009838:	40 5b       	lddsp	r11,sp[0x14]
8000983a:	40 7a       	lddsp	r10,sp[0x1c]
8000983c:	e0 a0 15 3b 	rcall	8000c2b2 <__avr32_f64_cmp_eq>
80009840:	c7 90       	breq	80009932 <_vfprintf_r+0x19f6>
80009842:	fa f8 06 90 	ld.w	r8,sp[1680]
80009846:	fe c9 ba 8a 	sub	r9,pc,-17782
8000984a:	2f f8       	sub	r8,-1
8000984c:	87 09       	st.w	r3[0x0],r9
8000984e:	fb 48 06 90 	st.w	sp[1680],r8
80009852:	30 19       	mov	r9,1
80009854:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009858:	87 19       	st.w	r3[0x4],r9
8000985a:	2f f8       	sub	r8,-1
8000985c:	fb 48 06 8c 	st.w	sp[1676],r8
80009860:	58 78       	cp.w	r8,7
80009862:	e0 89 00 05 	brgt	8000986c <_vfprintf_r+0x1930>
80009866:	2f 83       	sub	r3,-8
80009868:	c0 c8       	rjmp	80009880 <_vfprintf_r+0x1944>
8000986a:	d7 03       	nop
8000986c:	fa ca f9 78 	sub	r10,sp,-1672
80009870:	02 9b       	mov	r11,r1
80009872:	08 9c       	mov	r12,r4
80009874:	fe b0 f3 56 	rcall	80007f20 <__sprint_r>
80009878:	e0 81 02 e1 	brne	80009e3a <_vfprintf_r+0x1efe>
8000987c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009880:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009884:	40 6c       	lddsp	r12,sp[0x18]
80009886:	18 38       	cp.w	r8,r12
80009888:	c0 55       	brlt	80009892 <_vfprintf_r+0x1956>
8000988a:	ed b5 00 00 	bld	r5,0x0
8000988e:	e0 81 02 6b 	brne	80009d64 <_vfprintf_r+0x1e28>
80009892:	fa f8 06 90 	ld.w	r8,sp[1680]
80009896:	2f f8       	sub	r8,-1
80009898:	40 cb       	lddsp	r11,sp[0x30]
8000989a:	fb 48 06 90 	st.w	sp[1680],r8
8000989e:	30 19       	mov	r9,1
800098a0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098a4:	87 0b       	st.w	r3[0x0],r11
800098a6:	2f f8       	sub	r8,-1
800098a8:	87 19       	st.w	r3[0x4],r9
800098aa:	fb 48 06 8c 	st.w	sp[1676],r8
800098ae:	58 78       	cp.w	r8,7
800098b0:	e0 89 00 04 	brgt	800098b8 <_vfprintf_r+0x197c>
800098b4:	2f 83       	sub	r3,-8
800098b6:	c0 b8       	rjmp	800098cc <_vfprintf_r+0x1990>
800098b8:	fa ca f9 78 	sub	r10,sp,-1672
800098bc:	02 9b       	mov	r11,r1
800098be:	08 9c       	mov	r12,r4
800098c0:	fe b0 f3 30 	rcall	80007f20 <__sprint_r>
800098c4:	e0 81 02 bb 	brne	80009e3a <_vfprintf_r+0x1efe>
800098c8:	fa c3 f9 e0 	sub	r3,sp,-1568
800098cc:	40 66       	lddsp	r6,sp[0x18]
800098ce:	20 16       	sub	r6,1
800098d0:	58 06       	cp.w	r6,0
800098d2:	e0 89 00 1d 	brgt	8000990c <_vfprintf_r+0x19d0>
800098d6:	e0 8f 02 47 	bral	80009d64 <_vfprintf_r+0x1e28>
800098da:	2f 09       	sub	r9,-16
800098dc:	2f f8       	sub	r8,-1
800098de:	fb 49 06 90 	st.w	sp[1680],r9
800098e2:	87 02       	st.w	r3[0x0],r2
800098e4:	87 10       	st.w	r3[0x4],r0
800098e6:	fb 48 06 8c 	st.w	sp[1676],r8
800098ea:	58 78       	cp.w	r8,7
800098ec:	e0 89 00 04 	brgt	800098f4 <_vfprintf_r+0x19b8>
800098f0:	2f 83       	sub	r3,-8
800098f2:	c0 b8       	rjmp	80009908 <_vfprintf_r+0x19cc>
800098f4:	fa ca f9 78 	sub	r10,sp,-1672
800098f8:	02 9b       	mov	r11,r1
800098fa:	08 9c       	mov	r12,r4
800098fc:	fe b0 f3 12 	rcall	80007f20 <__sprint_r>
80009900:	e0 81 02 9d 	brne	80009e3a <_vfprintf_r+0x1efe>
80009904:	fa c3 f9 e0 	sub	r3,sp,-1568
80009908:	21 06       	sub	r6,16
8000990a:	c0 48       	rjmp	80009912 <_vfprintf_r+0x19d6>
8000990c:	fe c2 bb 3c 	sub	r2,pc,-17604
80009910:	31 00       	mov	r0,16
80009912:	fa f9 06 90 	ld.w	r9,sp[1680]
80009916:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000991a:	fe ca bb 4a 	sub	r10,pc,-17590
8000991e:	59 06       	cp.w	r6,16
80009920:	fe 99 ff dd 	brgt	800098da <_vfprintf_r+0x199e>
80009924:	0c 09       	add	r9,r6
80009926:	87 0a       	st.w	r3[0x0],r10
80009928:	fb 49 06 90 	st.w	sp[1680],r9
8000992c:	2f f8       	sub	r8,-1
8000992e:	87 16       	st.w	r3[0x4],r6
80009930:	c5 39       	rjmp	80009bd6 <_vfprintf_r+0x1c9a>
80009932:	fa fa 06 ac 	ld.w	r10,sp[1708]
80009936:	58 0a       	cp.w	r10,0
80009938:	e0 89 00 92 	brgt	80009a5c <_vfprintf_r+0x1b20>
8000993c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009940:	fe c9 bb 84 	sub	r9,pc,-17532
80009944:	2f f8       	sub	r8,-1
80009946:	87 09       	st.w	r3[0x0],r9
80009948:	fb 48 06 90 	st.w	sp[1680],r8
8000994c:	30 19       	mov	r9,1
8000994e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009952:	87 19       	st.w	r3[0x4],r9
80009954:	2f f8       	sub	r8,-1
80009956:	fb 48 06 8c 	st.w	sp[1676],r8
8000995a:	58 78       	cp.w	r8,7
8000995c:	e0 89 00 04 	brgt	80009964 <_vfprintf_r+0x1a28>
80009960:	2f 83       	sub	r3,-8
80009962:	c0 b8       	rjmp	80009978 <_vfprintf_r+0x1a3c>
80009964:	fa ca f9 78 	sub	r10,sp,-1672
80009968:	02 9b       	mov	r11,r1
8000996a:	08 9c       	mov	r12,r4
8000996c:	fe b0 f2 da 	rcall	80007f20 <__sprint_r>
80009970:	e0 81 02 65 	brne	80009e3a <_vfprintf_r+0x1efe>
80009974:	fa c3 f9 e0 	sub	r3,sp,-1568
80009978:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000997c:	58 08       	cp.w	r8,0
8000997e:	c0 81       	brne	8000998e <_vfprintf_r+0x1a52>
80009980:	40 6a       	lddsp	r10,sp[0x18]
80009982:	58 0a       	cp.w	r10,0
80009984:	c0 51       	brne	8000998e <_vfprintf_r+0x1a52>
80009986:	ed b5 00 00 	bld	r5,0x0
8000998a:	e0 81 01 ed 	brne	80009d64 <_vfprintf_r+0x1e28>
8000998e:	40 c9       	lddsp	r9,sp[0x30]
80009990:	fa f8 06 90 	ld.w	r8,sp[1680]
80009994:	2f f8       	sub	r8,-1
80009996:	87 09       	st.w	r3[0x0],r9
80009998:	fb 48 06 90 	st.w	sp[1680],r8
8000999c:	30 19       	mov	r9,1
8000999e:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099a2:	87 19       	st.w	r3[0x4],r9
800099a4:	2f f8       	sub	r8,-1
800099a6:	fb 48 06 8c 	st.w	sp[1676],r8
800099aa:	58 78       	cp.w	r8,7
800099ac:	e0 89 00 04 	brgt	800099b4 <_vfprintf_r+0x1a78>
800099b0:	2f 83       	sub	r3,-8
800099b2:	c0 b8       	rjmp	800099c8 <_vfprintf_r+0x1a8c>
800099b4:	fa ca f9 78 	sub	r10,sp,-1672
800099b8:	02 9b       	mov	r11,r1
800099ba:	08 9c       	mov	r12,r4
800099bc:	fe b0 f2 b2 	rcall	80007f20 <__sprint_r>
800099c0:	e0 81 02 3d 	brne	80009e3a <_vfprintf_r+0x1efe>
800099c4:	fa c3 f9 e0 	sub	r3,sp,-1568
800099c8:	fa f2 06 ac 	ld.w	r2,sp[1708]
800099cc:	5c 32       	neg	r2
800099ce:	58 02       	cp.w	r2,0
800099d0:	e0 89 00 1d 	brgt	80009a0a <_vfprintf_r+0x1ace>
800099d4:	c3 d8       	rjmp	80009a4e <_vfprintf_r+0x1b12>
800099d6:	2f 09       	sub	r9,-16
800099d8:	2f f8       	sub	r8,-1
800099da:	31 0e       	mov	lr,16
800099dc:	fb 49 06 90 	st.w	sp[1680],r9
800099e0:	87 00       	st.w	r3[0x0],r0
800099e2:	87 1e       	st.w	r3[0x4],lr
800099e4:	fb 48 06 8c 	st.w	sp[1676],r8
800099e8:	58 78       	cp.w	r8,7
800099ea:	e0 89 00 04 	brgt	800099f2 <_vfprintf_r+0x1ab6>
800099ee:	2f 83       	sub	r3,-8
800099f0:	c0 b8       	rjmp	80009a06 <_vfprintf_r+0x1aca>
800099f2:	fa ca f9 78 	sub	r10,sp,-1672
800099f6:	02 9b       	mov	r11,r1
800099f8:	08 9c       	mov	r12,r4
800099fa:	fe b0 f2 93 	rcall	80007f20 <__sprint_r>
800099fe:	e0 81 02 1e 	brne	80009e3a <_vfprintf_r+0x1efe>
80009a02:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a06:	21 02       	sub	r2,16
80009a08:	c0 38       	rjmp	80009a0e <_vfprintf_r+0x1ad2>
80009a0a:	fe c0 bc 3a 	sub	r0,pc,-17350
80009a0e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009a12:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a16:	fe ca bc 46 	sub	r10,pc,-17338
80009a1a:	59 02       	cp.w	r2,16
80009a1c:	fe 99 ff dd 	brgt	800099d6 <_vfprintf_r+0x1a9a>
80009a20:	04 09       	add	r9,r2
80009a22:	2f f8       	sub	r8,-1
80009a24:	87 0a       	st.w	r3[0x0],r10
80009a26:	fb 49 06 90 	st.w	sp[1680],r9
80009a2a:	87 12       	st.w	r3[0x4],r2
80009a2c:	fb 48 06 8c 	st.w	sp[1676],r8
80009a30:	58 78       	cp.w	r8,7
80009a32:	e0 89 00 04 	brgt	80009a3a <_vfprintf_r+0x1afe>
80009a36:	2f 83       	sub	r3,-8
80009a38:	c0 b8       	rjmp	80009a4e <_vfprintf_r+0x1b12>
80009a3a:	fa ca f9 78 	sub	r10,sp,-1672
80009a3e:	02 9b       	mov	r11,r1
80009a40:	08 9c       	mov	r12,r4
80009a42:	fe b0 f2 6f 	rcall	80007f20 <__sprint_r>
80009a46:	e0 81 01 fa 	brne	80009e3a <_vfprintf_r+0x1efe>
80009a4a:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a4e:	40 6c       	lddsp	r12,sp[0x18]
80009a50:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a54:	87 06       	st.w	r3[0x0],r6
80009a56:	87 1c       	st.w	r3[0x4],r12
80009a58:	18 08       	add	r8,r12
80009a5a:	cb 98       	rjmp	80009bcc <_vfprintf_r+0x1c90>
80009a5c:	fa f9 06 90 	ld.w	r9,sp[1680]
80009a60:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a64:	40 6b       	lddsp	r11,sp[0x18]
80009a66:	16 3a       	cp.w	r10,r11
80009a68:	c6 f5       	brlt	80009b46 <_vfprintf_r+0x1c0a>
80009a6a:	16 09       	add	r9,r11
80009a6c:	2f f8       	sub	r8,-1
80009a6e:	87 06       	st.w	r3[0x0],r6
80009a70:	fb 49 06 90 	st.w	sp[1680],r9
80009a74:	87 1b       	st.w	r3[0x4],r11
80009a76:	fb 48 06 8c 	st.w	sp[1676],r8
80009a7a:	58 78       	cp.w	r8,7
80009a7c:	e0 89 00 04 	brgt	80009a84 <_vfprintf_r+0x1b48>
80009a80:	2f 83       	sub	r3,-8
80009a82:	c0 b8       	rjmp	80009a98 <_vfprintf_r+0x1b5c>
80009a84:	fa ca f9 78 	sub	r10,sp,-1672
80009a88:	02 9b       	mov	r11,r1
80009a8a:	08 9c       	mov	r12,r4
80009a8c:	fe b0 f2 4a 	rcall	80007f20 <__sprint_r>
80009a90:	e0 81 01 d5 	brne	80009e3a <_vfprintf_r+0x1efe>
80009a94:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a98:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009a9c:	40 6a       	lddsp	r10,sp[0x18]
80009a9e:	14 16       	sub	r6,r10
80009aa0:	58 06       	cp.w	r6,0
80009aa2:	e0 89 00 1c 	brgt	80009ada <_vfprintf_r+0x1b9e>
80009aa6:	c3 d8       	rjmp	80009b20 <_vfprintf_r+0x1be4>
80009aa8:	2f 09       	sub	r9,-16
80009aaa:	2f f8       	sub	r8,-1
80009aac:	fb 49 06 90 	st.w	sp[1680],r9
80009ab0:	87 02       	st.w	r3[0x0],r2
80009ab2:	87 10       	st.w	r3[0x4],r0
80009ab4:	fb 48 06 8c 	st.w	sp[1676],r8
80009ab8:	58 78       	cp.w	r8,7
80009aba:	e0 89 00 04 	brgt	80009ac2 <_vfprintf_r+0x1b86>
80009abe:	2f 83       	sub	r3,-8
80009ac0:	c0 b8       	rjmp	80009ad6 <_vfprintf_r+0x1b9a>
80009ac2:	fa ca f9 78 	sub	r10,sp,-1672
80009ac6:	02 9b       	mov	r11,r1
80009ac8:	08 9c       	mov	r12,r4
80009aca:	fe b0 f2 2b 	rcall	80007f20 <__sprint_r>
80009ace:	e0 81 01 b6 	brne	80009e3a <_vfprintf_r+0x1efe>
80009ad2:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ad6:	21 06       	sub	r6,16
80009ad8:	c0 48       	rjmp	80009ae0 <_vfprintf_r+0x1ba4>
80009ada:	fe c2 bd 0a 	sub	r2,pc,-17142
80009ade:	31 00       	mov	r0,16
80009ae0:	fa f9 06 90 	ld.w	r9,sp[1680]
80009ae4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ae8:	fe ca bd 18 	sub	r10,pc,-17128
80009aec:	59 06       	cp.w	r6,16
80009aee:	fe 99 ff dd 	brgt	80009aa8 <_vfprintf_r+0x1b6c>
80009af2:	0c 09       	add	r9,r6
80009af4:	2f f8       	sub	r8,-1
80009af6:	87 0a       	st.w	r3[0x0],r10
80009af8:	fb 49 06 90 	st.w	sp[1680],r9
80009afc:	87 16       	st.w	r3[0x4],r6
80009afe:	fb 48 06 8c 	st.w	sp[1676],r8
80009b02:	58 78       	cp.w	r8,7
80009b04:	e0 89 00 04 	brgt	80009b0c <_vfprintf_r+0x1bd0>
80009b08:	2f 83       	sub	r3,-8
80009b0a:	c0 b8       	rjmp	80009b20 <_vfprintf_r+0x1be4>
80009b0c:	fa ca f9 78 	sub	r10,sp,-1672
80009b10:	02 9b       	mov	r11,r1
80009b12:	08 9c       	mov	r12,r4
80009b14:	fe b0 f2 06 	rcall	80007f20 <__sprint_r>
80009b18:	e0 81 01 91 	brne	80009e3a <_vfprintf_r+0x1efe>
80009b1c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b20:	ed b5 00 00 	bld	r5,0x0
80009b24:	e0 81 01 20 	brne	80009d64 <_vfprintf_r+0x1e28>
80009b28:	40 c9       	lddsp	r9,sp[0x30]
80009b2a:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b2e:	2f f8       	sub	r8,-1
80009b30:	87 09       	st.w	r3[0x0],r9
80009b32:	fb 48 06 90 	st.w	sp[1680],r8
80009b36:	30 19       	mov	r9,1
80009b38:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b3c:	87 19       	st.w	r3[0x4],r9
80009b3e:	2f f8       	sub	r8,-1
80009b40:	fb 48 06 8c 	st.w	sp[1676],r8
80009b44:	c0 29       	rjmp	80009d48 <_vfprintf_r+0x1e0c>
80009b46:	14 09       	add	r9,r10
80009b48:	2f f8       	sub	r8,-1
80009b4a:	fb 49 06 90 	st.w	sp[1680],r9
80009b4e:	87 06       	st.w	r3[0x0],r6
80009b50:	87 1a       	st.w	r3[0x4],r10
80009b52:	fb 48 06 8c 	st.w	sp[1676],r8
80009b56:	58 78       	cp.w	r8,7
80009b58:	e0 89 00 04 	brgt	80009b60 <_vfprintf_r+0x1c24>
80009b5c:	2f 83       	sub	r3,-8
80009b5e:	c0 b8       	rjmp	80009b74 <_vfprintf_r+0x1c38>
80009b60:	fa ca f9 78 	sub	r10,sp,-1672
80009b64:	02 9b       	mov	r11,r1
80009b66:	08 9c       	mov	r12,r4
80009b68:	fe b0 f1 dc 	rcall	80007f20 <__sprint_r>
80009b6c:	e0 81 01 67 	brne	80009e3a <_vfprintf_r+0x1efe>
80009b70:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b74:	40 c8       	lddsp	r8,sp[0x30]
80009b76:	87 08       	st.w	r3[0x0],r8
80009b78:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b7c:	2f f8       	sub	r8,-1
80009b7e:	30 19       	mov	r9,1
80009b80:	fb 48 06 90 	st.w	sp[1680],r8
80009b84:	87 19       	st.w	r3[0x4],r9
80009b86:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b8a:	2f f8       	sub	r8,-1
80009b8c:	fb 48 06 8c 	st.w	sp[1676],r8
80009b90:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009b94:	58 78       	cp.w	r8,7
80009b96:	e0 89 00 04 	brgt	80009b9e <_vfprintf_r+0x1c62>
80009b9a:	2f 83       	sub	r3,-8
80009b9c:	c0 b8       	rjmp	80009bb2 <_vfprintf_r+0x1c76>
80009b9e:	fa ca f9 78 	sub	r10,sp,-1672
80009ba2:	02 9b       	mov	r11,r1
80009ba4:	08 9c       	mov	r12,r4
80009ba6:	fe b0 f1 bd 	rcall	80007f20 <__sprint_r>
80009baa:	e0 81 01 48 	brne	80009e3a <_vfprintf_r+0x1efe>
80009bae:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bb2:	04 06       	add	r6,r2
80009bb4:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009bb8:	87 06       	st.w	r3[0x0],r6
80009bba:	fa f9 06 90 	ld.w	r9,sp[1680]
80009bbe:	40 66       	lddsp	r6,sp[0x18]
80009bc0:	40 6e       	lddsp	lr,sp[0x18]
80009bc2:	10 16       	sub	r6,r8
80009bc4:	f2 08 01 08 	sub	r8,r9,r8
80009bc8:	87 16       	st.w	r3[0x4],r6
80009bca:	1c 08       	add	r8,lr
80009bcc:	fb 48 06 90 	st.w	sp[1680],r8
80009bd0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009bd4:	2f f8       	sub	r8,-1
80009bd6:	fb 48 06 8c 	st.w	sp[1676],r8
80009bda:	cb 78       	rjmp	80009d48 <_vfprintf_r+0x1e0c>
80009bdc:	40 6c       	lddsp	r12,sp[0x18]
80009bde:	58 1c       	cp.w	r12,1
80009be0:	e0 89 00 06 	brgt	80009bec <_vfprintf_r+0x1cb0>
80009be4:	ed b5 00 00 	bld	r5,0x0
80009be8:	e0 81 00 85 	brne	80009cf2 <_vfprintf_r+0x1db6>
80009bec:	fa f8 06 90 	ld.w	r8,sp[1680]
80009bf0:	2f f8       	sub	r8,-1
80009bf2:	30 19       	mov	r9,1
80009bf4:	fb 48 06 90 	st.w	sp[1680],r8
80009bf8:	87 06       	st.w	r3[0x0],r6
80009bfa:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009bfe:	87 19       	st.w	r3[0x4],r9
80009c00:	2f f8       	sub	r8,-1
80009c02:	fb 48 06 8c 	st.w	sp[1676],r8
80009c06:	58 78       	cp.w	r8,7
80009c08:	e0 89 00 04 	brgt	80009c10 <_vfprintf_r+0x1cd4>
80009c0c:	2f 83       	sub	r3,-8
80009c0e:	c0 b8       	rjmp	80009c24 <_vfprintf_r+0x1ce8>
80009c10:	fa ca f9 78 	sub	r10,sp,-1672
80009c14:	02 9b       	mov	r11,r1
80009c16:	08 9c       	mov	r12,r4
80009c18:	fe b0 f1 84 	rcall	80007f20 <__sprint_r>
80009c1c:	e0 81 01 0f 	brne	80009e3a <_vfprintf_r+0x1efe>
80009c20:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c24:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c28:	2f f8       	sub	r8,-1
80009c2a:	40 cb       	lddsp	r11,sp[0x30]
80009c2c:	fb 48 06 90 	st.w	sp[1680],r8
80009c30:	30 19       	mov	r9,1
80009c32:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c36:	87 0b       	st.w	r3[0x0],r11
80009c38:	2f f8       	sub	r8,-1
80009c3a:	87 19       	st.w	r3[0x4],r9
80009c3c:	fb 48 06 8c 	st.w	sp[1676],r8
80009c40:	58 78       	cp.w	r8,7
80009c42:	e0 89 00 05 	brgt	80009c4c <_vfprintf_r+0x1d10>
80009c46:	2f 83       	sub	r3,-8
80009c48:	c0 c8       	rjmp	80009c60 <_vfprintf_r+0x1d24>
80009c4a:	d7 03       	nop
80009c4c:	fa ca f9 78 	sub	r10,sp,-1672
80009c50:	02 9b       	mov	r11,r1
80009c52:	08 9c       	mov	r12,r4
80009c54:	fe b0 f1 66 	rcall	80007f20 <__sprint_r>
80009c58:	e0 81 00 f1 	brne	80009e3a <_vfprintf_r+0x1efe>
80009c5c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c60:	30 08       	mov	r8,0
80009c62:	30 09       	mov	r9,0
80009c64:	40 5b       	lddsp	r11,sp[0x14]
80009c66:	40 7a       	lddsp	r10,sp[0x1c]
80009c68:	e0 a0 13 25 	rcall	8000c2b2 <__avr32_f64_cmp_eq>
80009c6c:	40 68       	lddsp	r8,sp[0x18]
80009c6e:	20 18       	sub	r8,1
80009c70:	58 0c       	cp.w	r12,0
80009c72:	c0 d1       	brne	80009c8c <_vfprintf_r+0x1d50>
80009c74:	2f f6       	sub	r6,-1
80009c76:	87 18       	st.w	r3[0x4],r8
80009c78:	87 06       	st.w	r3[0x0],r6
80009c7a:	fa f6 06 90 	ld.w	r6,sp[1680]
80009c7e:	10 06       	add	r6,r8
80009c80:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c84:	fb 46 06 90 	st.w	sp[1680],r6
80009c88:	2f f8       	sub	r8,-1
80009c8a:	c3 18       	rjmp	80009cec <_vfprintf_r+0x1db0>
80009c8c:	10 96       	mov	r6,r8
80009c8e:	58 08       	cp.w	r8,0
80009c90:	e0 89 00 1c 	brgt	80009cc8 <_vfprintf_r+0x1d8c>
80009c94:	c4 b8       	rjmp	80009d2a <_vfprintf_r+0x1dee>
80009c96:	2f 09       	sub	r9,-16
80009c98:	2f f8       	sub	r8,-1
80009c9a:	fb 49 06 90 	st.w	sp[1680],r9
80009c9e:	87 02       	st.w	r3[0x0],r2
80009ca0:	87 10       	st.w	r3[0x4],r0
80009ca2:	fb 48 06 8c 	st.w	sp[1676],r8
80009ca6:	58 78       	cp.w	r8,7
80009ca8:	e0 89 00 04 	brgt	80009cb0 <_vfprintf_r+0x1d74>
80009cac:	2f 83       	sub	r3,-8
80009cae:	c0 b8       	rjmp	80009cc4 <_vfprintf_r+0x1d88>
80009cb0:	fa ca f9 78 	sub	r10,sp,-1672
80009cb4:	02 9b       	mov	r11,r1
80009cb6:	08 9c       	mov	r12,r4
80009cb8:	fe b0 f1 34 	rcall	80007f20 <__sprint_r>
80009cbc:	e0 81 00 bf 	brne	80009e3a <_vfprintf_r+0x1efe>
80009cc0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009cc4:	21 06       	sub	r6,16
80009cc6:	c0 48       	rjmp	80009cce <_vfprintf_r+0x1d92>
80009cc8:	fe c2 be f8 	sub	r2,pc,-16648
80009ccc:	31 00       	mov	r0,16
80009cce:	fa f9 06 90 	ld.w	r9,sp[1680]
80009cd2:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009cd6:	fe ca bf 06 	sub	r10,pc,-16634
80009cda:	59 06       	cp.w	r6,16
80009cdc:	fe 99 ff dd 	brgt	80009c96 <_vfprintf_r+0x1d5a>
80009ce0:	0c 09       	add	r9,r6
80009ce2:	87 0a       	st.w	r3[0x0],r10
80009ce4:	fb 49 06 90 	st.w	sp[1680],r9
80009ce8:	2f f8       	sub	r8,-1
80009cea:	87 16       	st.w	r3[0x4],r6
80009cec:	fb 48 06 8c 	st.w	sp[1676],r8
80009cf0:	c0 e8       	rjmp	80009d0c <_vfprintf_r+0x1dd0>
80009cf2:	fa f8 06 90 	ld.w	r8,sp[1680]
80009cf6:	2f f8       	sub	r8,-1
80009cf8:	30 19       	mov	r9,1
80009cfa:	fb 48 06 90 	st.w	sp[1680],r8
80009cfe:	87 06       	st.w	r3[0x0],r6
80009d00:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d04:	87 19       	st.w	r3[0x4],r9
80009d06:	2f f8       	sub	r8,-1
80009d08:	fb 48 06 8c 	st.w	sp[1676],r8
80009d0c:	58 78       	cp.w	r8,7
80009d0e:	e0 89 00 04 	brgt	80009d16 <_vfprintf_r+0x1dda>
80009d12:	2f 83       	sub	r3,-8
80009d14:	c0 b8       	rjmp	80009d2a <_vfprintf_r+0x1dee>
80009d16:	fa ca f9 78 	sub	r10,sp,-1672
80009d1a:	02 9b       	mov	r11,r1
80009d1c:	08 9c       	mov	r12,r4
80009d1e:	fe b0 f1 01 	rcall	80007f20 <__sprint_r>
80009d22:	e0 81 00 8c 	brne	80009e3a <_vfprintf_r+0x1efe>
80009d26:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d2a:	40 ea       	lddsp	r10,sp[0x38]
80009d2c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d30:	14 08       	add	r8,r10
80009d32:	fa c9 f9 64 	sub	r9,sp,-1692
80009d36:	fb 48 06 90 	st.w	sp[1680],r8
80009d3a:	87 1a       	st.w	r3[0x4],r10
80009d3c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d40:	87 09       	st.w	r3[0x0],r9
80009d42:	2f f8       	sub	r8,-1
80009d44:	fb 48 06 8c 	st.w	sp[1676],r8
80009d48:	58 78       	cp.w	r8,7
80009d4a:	e0 89 00 04 	brgt	80009d52 <_vfprintf_r+0x1e16>
80009d4e:	2f 83       	sub	r3,-8
80009d50:	c0 a8       	rjmp	80009d64 <_vfprintf_r+0x1e28>
80009d52:	fa ca f9 78 	sub	r10,sp,-1672
80009d56:	02 9b       	mov	r11,r1
80009d58:	08 9c       	mov	r12,r4
80009d5a:	fe b0 f0 e3 	rcall	80007f20 <__sprint_r>
80009d5e:	c6 e1       	brne	80009e3a <_vfprintf_r+0x1efe>
80009d60:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d64:	e2 15 00 04 	andl	r5,0x4,COH
80009d68:	c3 f0       	breq	80009de6 <_vfprintf_r+0x1eaa>
80009d6a:	40 86       	lddsp	r6,sp[0x20]
80009d6c:	40 39       	lddsp	r9,sp[0xc]
80009d6e:	12 16       	sub	r6,r9
80009d70:	58 06       	cp.w	r6,0
80009d72:	e0 89 00 1a 	brgt	80009da6 <_vfprintf_r+0x1e6a>
80009d76:	c3 88       	rjmp	80009de6 <_vfprintf_r+0x1eaa>
80009d78:	2f 09       	sub	r9,-16
80009d7a:	2f f8       	sub	r8,-1
80009d7c:	fb 49 06 90 	st.w	sp[1680],r9
80009d80:	87 05       	st.w	r3[0x0],r5
80009d82:	87 12       	st.w	r3[0x4],r2
80009d84:	fb 48 06 8c 	st.w	sp[1676],r8
80009d88:	58 78       	cp.w	r8,7
80009d8a:	e0 89 00 04 	brgt	80009d92 <_vfprintf_r+0x1e56>
80009d8e:	2f 83       	sub	r3,-8
80009d90:	c0 98       	rjmp	80009da2 <_vfprintf_r+0x1e66>
80009d92:	00 9a       	mov	r10,r0
80009d94:	02 9b       	mov	r11,r1
80009d96:	08 9c       	mov	r12,r4
80009d98:	fe b0 f0 c4 	rcall	80007f20 <__sprint_r>
80009d9c:	c4 f1       	brne	80009e3a <_vfprintf_r+0x1efe>
80009d9e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009da2:	21 06       	sub	r6,16
80009da4:	c0 68       	rjmp	80009db0 <_vfprintf_r+0x1e74>
80009da6:	fe c5 bf e6 	sub	r5,pc,-16410
80009daa:	31 02       	mov	r2,16
80009dac:	fa c0 f9 78 	sub	r0,sp,-1672
80009db0:	fa f9 06 90 	ld.w	r9,sp[1680]
80009db4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009db8:	fe ca bf f8 	sub	r10,pc,-16392
80009dbc:	59 06       	cp.w	r6,16
80009dbe:	fe 99 ff dd 	brgt	80009d78 <_vfprintf_r+0x1e3c>
80009dc2:	0c 09       	add	r9,r6
80009dc4:	2f f8       	sub	r8,-1
80009dc6:	87 0a       	st.w	r3[0x0],r10
80009dc8:	87 16       	st.w	r3[0x4],r6
80009dca:	fb 49 06 90 	st.w	sp[1680],r9
80009dce:	fb 48 06 8c 	st.w	sp[1676],r8
80009dd2:	58 78       	cp.w	r8,7
80009dd4:	e0 8a 00 09 	brle	80009de6 <_vfprintf_r+0x1eaa>
80009dd8:	fa ca f9 78 	sub	r10,sp,-1672
80009ddc:	02 9b       	mov	r11,r1
80009dde:	08 9c       	mov	r12,r4
80009de0:	fe b0 f0 a0 	rcall	80007f20 <__sprint_r>
80009de4:	c2 b1       	brne	80009e3a <_vfprintf_r+0x1efe>
80009de6:	40 bc       	lddsp	r12,sp[0x2c]
80009de8:	40 36       	lddsp	r6,sp[0xc]
80009dea:	40 8e       	lddsp	lr,sp[0x20]
80009dec:	ec 0e 0c 48 	max	r8,r6,lr
80009df0:	10 0c       	add	r12,r8
80009df2:	50 bc       	stdsp	sp[0x2c],r12
80009df4:	fa f8 06 90 	ld.w	r8,sp[1680]
80009df8:	58 08       	cp.w	r8,0
80009dfa:	c0 80       	breq	80009e0a <_vfprintf_r+0x1ece>
80009dfc:	fa ca f9 78 	sub	r10,sp,-1672
80009e00:	02 9b       	mov	r11,r1
80009e02:	08 9c       	mov	r12,r4
80009e04:	fe b0 f0 8e 	rcall	80007f20 <__sprint_r>
80009e08:	c1 91       	brne	80009e3a <_vfprintf_r+0x1efe>
80009e0a:	30 0b       	mov	r11,0
80009e0c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e10:	fb 4b 06 8c 	st.w	sp[1676],r11
80009e14:	fe 9f f1 22 	bral	80008058 <_vfprintf_r+0x11c>
80009e18:	08 95       	mov	r5,r4
80009e1a:	fa f8 06 90 	ld.w	r8,sp[1680]
80009e1e:	58 08       	cp.w	r8,0
80009e20:	c0 80       	breq	80009e30 <_vfprintf_r+0x1ef4>
80009e22:	08 9c       	mov	r12,r4
80009e24:	fa ca f9 78 	sub	r10,sp,-1672
80009e28:	02 9b       	mov	r11,r1
80009e2a:	fe b0 f0 7b 	rcall	80007f20 <__sprint_r>
80009e2e:	c0 61       	brne	80009e3a <_vfprintf_r+0x1efe>
80009e30:	30 08       	mov	r8,0
80009e32:	fb 48 06 8c 	st.w	sp[1676],r8
80009e36:	c0 28       	rjmp	80009e3a <_vfprintf_r+0x1efe>
80009e38:	40 41       	lddsp	r1,sp[0x10]
80009e3a:	82 68       	ld.sh	r8,r1[0xc]
80009e3c:	ed b8 00 06 	bld	r8,0x6
80009e40:	c0 31       	brne	80009e46 <_vfprintf_r+0x1f0a>
80009e42:	3f fa       	mov	r10,-1
80009e44:	50 ba       	stdsp	sp[0x2c],r10
80009e46:	40 bc       	lddsp	r12,sp[0x2c]
80009e48:	fe 3d f9 44 	sub	sp,-1724
80009e4c:	d8 32       	popm	r0-r7,pc
80009e4e:	d7 03       	nop

80009e50 <__swsetup_r>:
80009e50:	d4 21       	pushm	r4-r7,lr
80009e52:	e0 68 0a 3c 	mov	r8,2620
80009e56:	18 96       	mov	r6,r12
80009e58:	16 97       	mov	r7,r11
80009e5a:	70 0c       	ld.w	r12,r8[0x0]
80009e5c:	58 0c       	cp.w	r12,0
80009e5e:	c0 60       	breq	80009e6a <__swsetup_r+0x1a>
80009e60:	78 68       	ld.w	r8,r12[0x18]
80009e62:	58 08       	cp.w	r8,0
80009e64:	c0 31       	brne	80009e6a <__swsetup_r+0x1a>
80009e66:	e0 a0 07 bf 	rcall	8000ade4 <__sinit>
80009e6a:	fe c8 bf 7a 	sub	r8,pc,-16518
80009e6e:	10 37       	cp.w	r7,r8
80009e70:	c0 61       	brne	80009e7c <__swsetup_r+0x2c>
80009e72:	e0 68 0a 3c 	mov	r8,2620
80009e76:	70 08       	ld.w	r8,r8[0x0]
80009e78:	70 07       	ld.w	r7,r8[0x0]
80009e7a:	c1 28       	rjmp	80009e9e <__swsetup_r+0x4e>
80009e7c:	fe c8 bf 6c 	sub	r8,pc,-16532
80009e80:	10 37       	cp.w	r7,r8
80009e82:	c0 61       	brne	80009e8e <__swsetup_r+0x3e>
80009e84:	e0 68 0a 3c 	mov	r8,2620
80009e88:	70 08       	ld.w	r8,r8[0x0]
80009e8a:	70 17       	ld.w	r7,r8[0x4]
80009e8c:	c0 98       	rjmp	80009e9e <__swsetup_r+0x4e>
80009e8e:	fe c8 bf 5e 	sub	r8,pc,-16546
80009e92:	10 37       	cp.w	r7,r8
80009e94:	c0 51       	brne	80009e9e <__swsetup_r+0x4e>
80009e96:	e0 68 0a 3c 	mov	r8,2620
80009e9a:	70 08       	ld.w	r8,r8[0x0]
80009e9c:	70 27       	ld.w	r7,r8[0x8]
80009e9e:	8e 68       	ld.sh	r8,r7[0xc]
80009ea0:	ed b8 00 03 	bld	r8,0x3
80009ea4:	c1 e0       	breq	80009ee0 <__swsetup_r+0x90>
80009ea6:	ed b8 00 04 	bld	r8,0x4
80009eaa:	c3 e1       	brne	80009f26 <__swsetup_r+0xd6>
80009eac:	ed b8 00 02 	bld	r8,0x2
80009eb0:	c1 51       	brne	80009eda <__swsetup_r+0x8a>
80009eb2:	6e db       	ld.w	r11,r7[0x34]
80009eb4:	58 0b       	cp.w	r11,0
80009eb6:	c0 a0       	breq	80009eca <__swsetup_r+0x7a>
80009eb8:	ee c8 ff bc 	sub	r8,r7,-68
80009ebc:	10 3b       	cp.w	r11,r8
80009ebe:	c0 40       	breq	80009ec6 <__swsetup_r+0x76>
80009ec0:	0c 9c       	mov	r12,r6
80009ec2:	e0 a0 08 2b 	rcall	8000af18 <_free_r>
80009ec6:	30 08       	mov	r8,0
80009ec8:	8f d8       	st.w	r7[0x34],r8
80009eca:	8e 68       	ld.sh	r8,r7[0xc]
80009ecc:	e0 18 ff db 	andl	r8,0xffdb
80009ed0:	ae 68       	st.h	r7[0xc],r8
80009ed2:	30 08       	mov	r8,0
80009ed4:	8f 18       	st.w	r7[0x4],r8
80009ed6:	6e 48       	ld.w	r8,r7[0x10]
80009ed8:	8f 08       	st.w	r7[0x0],r8
80009eda:	8e 68       	ld.sh	r8,r7[0xc]
80009edc:	a3 b8       	sbr	r8,0x3
80009ede:	ae 68       	st.h	r7[0xc],r8
80009ee0:	6e 48       	ld.w	r8,r7[0x10]
80009ee2:	58 08       	cp.w	r8,0
80009ee4:	c0 b1       	brne	80009efa <__swsetup_r+0xaa>
80009ee6:	8e 68       	ld.sh	r8,r7[0xc]
80009ee8:	e2 18 02 80 	andl	r8,0x280,COH
80009eec:	e0 48 02 00 	cp.w	r8,512
80009ef0:	c0 50       	breq	80009efa <__swsetup_r+0xaa>
80009ef2:	0c 9c       	mov	r12,r6
80009ef4:	0e 9b       	mov	r11,r7
80009ef6:	e0 a0 0a 4b 	rcall	8000b38c <__smakebuf_r>
80009efa:	8e 69       	ld.sh	r9,r7[0xc]
80009efc:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009f00:	c0 70       	breq	80009f0e <__swsetup_r+0xbe>
80009f02:	30 08       	mov	r8,0
80009f04:	8f 28       	st.w	r7[0x8],r8
80009f06:	6e 58       	ld.w	r8,r7[0x14]
80009f08:	5c 38       	neg	r8
80009f0a:	8f 68       	st.w	r7[0x18],r8
80009f0c:	c0 68       	rjmp	80009f18 <__swsetup_r+0xc8>
80009f0e:	ed b9 00 01 	bld	r9,0x1
80009f12:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009f16:	8f 28       	st.w	r7[0x8],r8
80009f18:	6e 48       	ld.w	r8,r7[0x10]
80009f1a:	58 08       	cp.w	r8,0
80009f1c:	c0 61       	brne	80009f28 <__swsetup_r+0xd8>
80009f1e:	8e 68       	ld.sh	r8,r7[0xc]
80009f20:	ed b8 00 07 	bld	r8,0x7
80009f24:	c0 21       	brne	80009f28 <__swsetup_r+0xd8>
80009f26:	dc 2a       	popm	r4-r7,pc,r12=-1
80009f28:	d8 2a       	popm	r4-r7,pc,r12=0
80009f2a:	d7 03       	nop

80009f2c <quorem>:
80009f2c:	d4 31       	pushm	r0-r7,lr
80009f2e:	20 2d       	sub	sp,8
80009f30:	18 97       	mov	r7,r12
80009f32:	78 48       	ld.w	r8,r12[0x10]
80009f34:	76 46       	ld.w	r6,r11[0x10]
80009f36:	0c 38       	cp.w	r8,r6
80009f38:	c0 34       	brge	80009f3e <quorem+0x12>
80009f3a:	30 0c       	mov	r12,0
80009f3c:	c8 58       	rjmp	8000a046 <quorem+0x11a>
80009f3e:	ec c2 ff fc 	sub	r2,r6,-4
80009f42:	f6 c3 ff ec 	sub	r3,r11,-20
80009f46:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80009f4a:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009f4e:	2f f9       	sub	r9,-1
80009f50:	20 16       	sub	r6,1
80009f52:	f8 09 0d 08 	divu	r8,r12,r9
80009f56:	f6 02 00 22 	add	r2,r11,r2<<0x2
80009f5a:	ee c4 ff ec 	sub	r4,r7,-20
80009f5e:	10 95       	mov	r5,r8
80009f60:	58 08       	cp.w	r8,0
80009f62:	c4 10       	breq	80009fe4 <quorem+0xb8>
80009f64:	30 09       	mov	r9,0
80009f66:	06 9a       	mov	r10,r3
80009f68:	08 98       	mov	r8,r4
80009f6a:	12 91       	mov	r1,r9
80009f6c:	50 0b       	stdsp	sp[0x0],r11
80009f6e:	70 0e       	ld.w	lr,r8[0x0]
80009f70:	b1 8e       	lsr	lr,0x10
80009f72:	50 1e       	stdsp	sp[0x4],lr
80009f74:	15 0e       	ld.w	lr,r10++
80009f76:	fc 00 16 10 	lsr	r0,lr,0x10
80009f7a:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80009f7e:	ea 0e 03 41 	mac	r1,r5,lr
80009f82:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80009f86:	b1 81       	lsr	r1,0x10
80009f88:	40 1b       	lddsp	r11,sp[0x4]
80009f8a:	ea 00 02 40 	mul	r0,r5,r0
80009f8e:	e2 00 00 00 	add	r0,r1,r0
80009f92:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80009f96:	02 1b       	sub	r11,r1
80009f98:	50 1b       	stdsp	sp[0x4],r11
80009f9a:	70 0b       	ld.w	r11,r8[0x0]
80009f9c:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009fa0:	02 09       	add	r9,r1
80009fa2:	f2 0e 01 0e 	sub	lr,r9,lr
80009fa6:	b0 1e       	st.h	r8[0x2],lr
80009fa8:	fc 09 14 10 	asr	r9,lr,0x10
80009fac:	40 1e       	lddsp	lr,sp[0x4]
80009fae:	fc 09 00 09 	add	r9,lr,r9
80009fb2:	b0 09       	st.h	r8[0x0],r9
80009fb4:	e0 01 16 10 	lsr	r1,r0,0x10
80009fb8:	2f c8       	sub	r8,-4
80009fba:	b1 49       	asr	r9,0x10
80009fbc:	04 3a       	cp.w	r10,r2
80009fbe:	fe 98 ff d8 	brls	80009f6e <quorem+0x42>
80009fc2:	40 0b       	lddsp	r11,sp[0x0]
80009fc4:	58 0c       	cp.w	r12,0
80009fc6:	c0 f1       	brne	80009fe4 <quorem+0xb8>
80009fc8:	ec c8 ff fb 	sub	r8,r6,-5
80009fcc:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009fd0:	c0 28       	rjmp	80009fd4 <quorem+0xa8>
80009fd2:	20 16       	sub	r6,1
80009fd4:	20 48       	sub	r8,4
80009fd6:	08 38       	cp.w	r8,r4
80009fd8:	e0 88 00 05 	brls	80009fe2 <quorem+0xb6>
80009fdc:	70 09       	ld.w	r9,r8[0x0]
80009fde:	58 09       	cp.w	r9,0
80009fe0:	cf 90       	breq	80009fd2 <quorem+0xa6>
80009fe2:	8f 46       	st.w	r7[0x10],r6
80009fe4:	0e 9c       	mov	r12,r7
80009fe6:	e0 a0 0a d2 	rcall	8000b58a <__mcmp>
80009fea:	c2 d5       	brlt	8000a044 <quorem+0x118>
80009fec:	2f f5       	sub	r5,-1
80009fee:	08 98       	mov	r8,r4
80009ff0:	30 09       	mov	r9,0
80009ff2:	07 0b       	ld.w	r11,r3++
80009ff4:	f6 0a 16 10 	lsr	r10,r11,0x10
80009ff8:	70 0c       	ld.w	r12,r8[0x0]
80009ffa:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009ffe:	f8 0e 16 10 	lsr	lr,r12,0x10
8000a002:	14 1e       	sub	lr,r10
8000a004:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000a008:	16 1a       	sub	r10,r11
8000a00a:	12 0a       	add	r10,r9
8000a00c:	b0 1a       	st.h	r8[0x2],r10
8000a00e:	b1 4a       	asr	r10,0x10
8000a010:	fc 0a 00 09 	add	r9,lr,r10
8000a014:	b0 09       	st.h	r8[0x0],r9
8000a016:	2f c8       	sub	r8,-4
8000a018:	b1 49       	asr	r9,0x10
8000a01a:	04 33       	cp.w	r3,r2
8000a01c:	fe 98 ff eb 	brls	80009ff2 <quorem+0xc6>
8000a020:	ec c8 ff fb 	sub	r8,r6,-5
8000a024:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000a028:	58 09       	cp.w	r9,0
8000a02a:	c0 d1       	brne	8000a044 <quorem+0x118>
8000a02c:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a030:	c0 28       	rjmp	8000a034 <quorem+0x108>
8000a032:	20 16       	sub	r6,1
8000a034:	20 48       	sub	r8,4
8000a036:	08 38       	cp.w	r8,r4
8000a038:	e0 88 00 05 	brls	8000a042 <quorem+0x116>
8000a03c:	70 09       	ld.w	r9,r8[0x0]
8000a03e:	58 09       	cp.w	r9,0
8000a040:	cf 90       	breq	8000a032 <quorem+0x106>
8000a042:	8f 46       	st.w	r7[0x10],r6
8000a044:	0a 9c       	mov	r12,r5
8000a046:	2f ed       	sub	sp,-8
8000a048:	d8 32       	popm	r0-r7,pc
8000a04a:	d7 03       	nop

8000a04c <_dtoa_r>:
8000a04c:	d4 31       	pushm	r0-r7,lr
8000a04e:	21 ad       	sub	sp,104
8000a050:	fa c4 ff 74 	sub	r4,sp,-140
8000a054:	18 97       	mov	r7,r12
8000a056:	16 95       	mov	r5,r11
8000a058:	68 2c       	ld.w	r12,r4[0x8]
8000a05a:	50 c9       	stdsp	sp[0x30],r9
8000a05c:	68 16       	ld.w	r6,r4[0x4]
8000a05e:	68 09       	ld.w	r9,r4[0x0]
8000a060:	50 e8       	stdsp	sp[0x38],r8
8000a062:	14 94       	mov	r4,r10
8000a064:	51 2c       	stdsp	sp[0x48],r12
8000a066:	fa e5 00 08 	st.d	sp[8],r4
8000a06a:	51 59       	stdsp	sp[0x54],r9
8000a06c:	6e 95       	ld.w	r5,r7[0x24]
8000a06e:	58 05       	cp.w	r5,0
8000a070:	c0 91       	brne	8000a082 <_dtoa_r+0x36>
8000a072:	31 0c       	mov	r12,16
8000a074:	fe b0 e8 f4 	rcall	8000725c <malloc>
8000a078:	99 35       	st.w	r12[0xc],r5
8000a07a:	8f 9c       	st.w	r7[0x24],r12
8000a07c:	99 15       	st.w	r12[0x4],r5
8000a07e:	99 25       	st.w	r12[0x8],r5
8000a080:	99 05       	st.w	r12[0x0],r5
8000a082:	6e 99       	ld.w	r9,r7[0x24]
8000a084:	72 08       	ld.w	r8,r9[0x0]
8000a086:	58 08       	cp.w	r8,0
8000a088:	c0 f0       	breq	8000a0a6 <_dtoa_r+0x5a>
8000a08a:	72 1a       	ld.w	r10,r9[0x4]
8000a08c:	91 1a       	st.w	r8[0x4],r10
8000a08e:	30 1a       	mov	r10,1
8000a090:	72 19       	ld.w	r9,r9[0x4]
8000a092:	f4 09 09 49 	lsl	r9,r10,r9
8000a096:	10 9b       	mov	r11,r8
8000a098:	91 29       	st.w	r8[0x8],r9
8000a09a:	0e 9c       	mov	r12,r7
8000a09c:	e0 a0 0a 90 	rcall	8000b5bc <_Bfree>
8000a0a0:	6e 98       	ld.w	r8,r7[0x24]
8000a0a2:	30 09       	mov	r9,0
8000a0a4:	91 09       	st.w	r8[0x0],r9
8000a0a6:	40 28       	lddsp	r8,sp[0x8]
8000a0a8:	10 94       	mov	r4,r8
8000a0aa:	58 08       	cp.w	r8,0
8000a0ac:	c0 64       	brge	8000a0b8 <_dtoa_r+0x6c>
8000a0ae:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000a0b2:	50 28       	stdsp	sp[0x8],r8
8000a0b4:	30 18       	mov	r8,1
8000a0b6:	c0 28       	rjmp	8000a0ba <_dtoa_r+0x6e>
8000a0b8:	30 08       	mov	r8,0
8000a0ba:	8d 08       	st.w	r6[0x0],r8
8000a0bc:	fc 1c 7f f0 	movh	r12,0x7ff0
8000a0c0:	40 26       	lddsp	r6,sp[0x8]
8000a0c2:	0c 98       	mov	r8,r6
8000a0c4:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a0c8:	18 38       	cp.w	r8,r12
8000a0ca:	c2 01       	brne	8000a10a <_dtoa_r+0xbe>
8000a0cc:	e0 68 27 0f 	mov	r8,9999
8000a0d0:	41 5b       	lddsp	r11,sp[0x54]
8000a0d2:	97 08       	st.w	r11[0x0],r8
8000a0d4:	40 3a       	lddsp	r10,sp[0xc]
8000a0d6:	58 0a       	cp.w	r10,0
8000a0d8:	c0 71       	brne	8000a0e6 <_dtoa_r+0x9a>
8000a0da:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000a0de:	c0 41       	brne	8000a0e6 <_dtoa_r+0x9a>
8000a0e0:	fe cc c2 00 	sub	r12,pc,-15872
8000a0e4:	c0 38       	rjmp	8000a0ea <_dtoa_r+0x9e>
8000a0e6:	fe cc c1 fa 	sub	r12,pc,-15878
8000a0ea:	41 29       	lddsp	r9,sp[0x48]
8000a0ec:	58 09       	cp.w	r9,0
8000a0ee:	e0 80 05 9a 	breq	8000ac22 <_dtoa_r+0xbd6>
8000a0f2:	f8 c8 ff fd 	sub	r8,r12,-3
8000a0f6:	f8 c9 ff f8 	sub	r9,r12,-8
8000a0fa:	11 8b       	ld.ub	r11,r8[0x0]
8000a0fc:	30 0a       	mov	r10,0
8000a0fe:	41 25       	lddsp	r5,sp[0x48]
8000a100:	f4 0b 18 00 	cp.b	r11,r10
8000a104:	f2 08 17 10 	movne	r8,r9
8000a108:	c1 68       	rjmp	8000a134 <_dtoa_r+0xe8>
8000a10a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a10e:	30 08       	mov	r8,0
8000a110:	fa eb 00 3c 	st.d	sp[60],r10
8000a114:	30 09       	mov	r9,0
8000a116:	e0 a0 10 ce 	rcall	8000c2b2 <__avr32_f64_cmp_eq>
8000a11a:	c1 00       	breq	8000a13a <_dtoa_r+0xee>
8000a11c:	30 18       	mov	r8,1
8000a11e:	41 5a       	lddsp	r10,sp[0x54]
8000a120:	95 08       	st.w	r10[0x0],r8
8000a122:	fe cc c3 66 	sub	r12,pc,-15514
8000a126:	41 29       	lddsp	r9,sp[0x48]
8000a128:	f8 08 00 08 	add	r8,r12,r8
8000a12c:	58 09       	cp.w	r9,0
8000a12e:	e0 80 05 7a 	breq	8000ac22 <_dtoa_r+0xbd6>
8000a132:	12 95       	mov	r5,r9
8000a134:	8b 08       	st.w	r5[0x0],r8
8000a136:	e0 8f 05 76 	bral	8000ac22 <_dtoa_r+0xbd6>
8000a13a:	fa c8 ff 9c 	sub	r8,sp,-100
8000a13e:	fa c9 ff a0 	sub	r9,sp,-96
8000a142:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a146:	0e 9c       	mov	r12,r7
8000a148:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000a14c:	e0 a0 0a 8a 	rcall	8000b660 <__d2b>
8000a150:	18 93       	mov	r3,r12
8000a152:	58 05       	cp.w	r5,0
8000a154:	c0 d0       	breq	8000a16e <_dtoa_r+0x122>
8000a156:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a15a:	30 04       	mov	r4,0
8000a15c:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000a160:	ea c5 03 ff 	sub	r5,r5,1023
8000a164:	10 9b       	mov	r11,r8
8000a166:	51 74       	stdsp	sp[0x5c],r4
8000a168:	ea 1b 3f f0 	orh	r11,0x3ff0
8000a16c:	c2 58       	rjmp	8000a1b6 <_dtoa_r+0x16a>
8000a16e:	41 88       	lddsp	r8,sp[0x60]
8000a170:	41 9c       	lddsp	r12,sp[0x64]
8000a172:	10 0c       	add	r12,r8
8000a174:	f8 c5 fb ce 	sub	r5,r12,-1074
8000a178:	e0 45 00 20 	cp.w	r5,32
8000a17c:	e0 8a 00 0e 	brle	8000a198 <_dtoa_r+0x14c>
8000a180:	f8 cc fb ee 	sub	r12,r12,-1042
8000a184:	40 3b       	lddsp	r11,sp[0xc]
8000a186:	ea 08 11 40 	rsub	r8,r5,64
8000a18a:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000a18e:	ec 08 09 46 	lsl	r6,r6,r8
8000a192:	0c 4c       	or	r12,r6
8000a194:	c0 78       	rjmp	8000a1a2 <_dtoa_r+0x156>
8000a196:	d7 03       	nop
8000a198:	ea 0c 11 20 	rsub	r12,r5,32
8000a19c:	40 3a       	lddsp	r10,sp[0xc]
8000a19e:	f4 0c 09 4c 	lsl	r12,r10,r12
8000a1a2:	e0 a0 10 14 	rcall	8000c1ca <__avr32_u32_to_f64>
8000a1a6:	fc 18 fe 10 	movh	r8,0xfe10
8000a1aa:	30 19       	mov	r9,1
8000a1ac:	ea c5 04 33 	sub	r5,r5,1075
8000a1b0:	f0 0b 00 0b 	add	r11,r8,r11
8000a1b4:	51 79       	stdsp	sp[0x5c],r9
8000a1b6:	30 08       	mov	r8,0
8000a1b8:	fc 19 3f f8 	movh	r9,0x3ff8
8000a1bc:	e0 a0 0e 9c 	rcall	8000bef4 <__avr32_f64_sub>
8000a1c0:	e0 68 43 61 	mov	r8,17249
8000a1c4:	ea 18 63 6f 	orh	r8,0x636f
8000a1c8:	e0 69 87 a7 	mov	r9,34727
8000a1cc:	ea 19 3f d2 	orh	r9,0x3fd2
8000a1d0:	e0 a0 0d a6 	rcall	8000bd1c <__avr32_f64_mul>
8000a1d4:	e0 68 c8 b3 	mov	r8,51379
8000a1d8:	ea 18 8b 60 	orh	r8,0x8b60
8000a1dc:	e0 69 8a 28 	mov	r9,35368
8000a1e0:	ea 19 3f c6 	orh	r9,0x3fc6
8000a1e4:	e0 a0 0f 56 	rcall	8000c090 <__avr32_f64_add>
8000a1e8:	0a 9c       	mov	r12,r5
8000a1ea:	14 90       	mov	r0,r10
8000a1ec:	16 91       	mov	r1,r11
8000a1ee:	e0 a0 0f f2 	rcall	8000c1d2 <__avr32_s32_to_f64>
8000a1f2:	e0 68 79 fb 	mov	r8,31227
8000a1f6:	ea 18 50 9f 	orh	r8,0x509f
8000a1fa:	e0 69 44 13 	mov	r9,17427
8000a1fe:	ea 19 3f d3 	orh	r9,0x3fd3
8000a202:	e0 a0 0d 8d 	rcall	8000bd1c <__avr32_f64_mul>
8000a206:	14 98       	mov	r8,r10
8000a208:	16 99       	mov	r9,r11
8000a20a:	00 9a       	mov	r10,r0
8000a20c:	02 9b       	mov	r11,r1
8000a20e:	e0 a0 0f 41 	rcall	8000c090 <__avr32_f64_add>
8000a212:	14 90       	mov	r0,r10
8000a214:	16 91       	mov	r1,r11
8000a216:	e0 a0 0f c7 	rcall	8000c1a4 <__avr32_f64_to_s32>
8000a21a:	30 08       	mov	r8,0
8000a21c:	18 96       	mov	r6,r12
8000a21e:	30 09       	mov	r9,0
8000a220:	00 9a       	mov	r10,r0
8000a222:	02 9b       	mov	r11,r1
8000a224:	e0 a0 10 8e 	rcall	8000c340 <__avr32_f64_cmp_lt>
8000a228:	c0 c0       	breq	8000a240 <_dtoa_r+0x1f4>
8000a22a:	0c 9c       	mov	r12,r6
8000a22c:	e0 a0 0f d3 	rcall	8000c1d2 <__avr32_s32_to_f64>
8000a230:	14 98       	mov	r8,r10
8000a232:	16 99       	mov	r9,r11
8000a234:	00 9a       	mov	r10,r0
8000a236:	02 9b       	mov	r11,r1
8000a238:	e0 a0 10 3d 	rcall	8000c2b2 <__avr32_f64_cmp_eq>
8000a23c:	f7 b6 00 01 	subeq	r6,1
8000a240:	59 66       	cp.w	r6,22
8000a242:	e0 88 00 05 	brls	8000a24c <_dtoa_r+0x200>
8000a246:	30 18       	mov	r8,1
8000a248:	51 48       	stdsp	sp[0x50],r8
8000a24a:	c1 38       	rjmp	8000a270 <_dtoa_r+0x224>
8000a24c:	fe c8 c2 ac 	sub	r8,pc,-15700
8000a250:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a254:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a258:	e0 a0 10 74 	rcall	8000c340 <__avr32_f64_cmp_lt>
8000a25c:	f9 b4 00 00 	moveq	r4,0
8000a260:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a264:	f7 b6 01 01 	subne	r6,1
8000a268:	f9 bc 01 00 	movne	r12,0
8000a26c:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a270:	41 90       	lddsp	r0,sp[0x64]
8000a272:	20 10       	sub	r0,1
8000a274:	0a 10       	sub	r0,r5
8000a276:	c0 46       	brmi	8000a27e <_dtoa_r+0x232>
8000a278:	50 40       	stdsp	sp[0x10],r0
8000a27a:	30 00       	mov	r0,0
8000a27c:	c0 48       	rjmp	8000a284 <_dtoa_r+0x238>
8000a27e:	30 0b       	mov	r11,0
8000a280:	5c 30       	neg	r0
8000a282:	50 4b       	stdsp	sp[0x10],r11
8000a284:	ec 02 11 00 	rsub	r2,r6,0
8000a288:	58 06       	cp.w	r6,0
8000a28a:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a28e:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a292:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a296:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a29a:	f9 b2 04 00 	movge	r2,0
8000a29e:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a2a2:	f9 b9 05 00 	movlt	r9,0
8000a2a6:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a2aa:	40 c8       	lddsp	r8,sp[0x30]
8000a2ac:	58 98       	cp.w	r8,9
8000a2ae:	e0 8b 00 20 	brhi	8000a2ee <_dtoa_r+0x2a2>
8000a2b2:	58 58       	cp.w	r8,5
8000a2b4:	f9 b4 0a 01 	movle	r4,1
8000a2b8:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a2bc:	f7 b5 09 04 	subgt	r5,4
8000a2c0:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a2c4:	f9 b4 09 00 	movgt	r4,0
8000a2c8:	40 cc       	lddsp	r12,sp[0x30]
8000a2ca:	58 3c       	cp.w	r12,3
8000a2cc:	c2 d0       	breq	8000a326 <_dtoa_r+0x2da>
8000a2ce:	e0 89 00 05 	brgt	8000a2d8 <_dtoa_r+0x28c>
8000a2d2:	58 2c       	cp.w	r12,2
8000a2d4:	c1 01       	brne	8000a2f4 <_dtoa_r+0x2a8>
8000a2d6:	c1 88       	rjmp	8000a306 <_dtoa_r+0x2ba>
8000a2d8:	40 cb       	lddsp	r11,sp[0x30]
8000a2da:	58 4b       	cp.w	r11,4
8000a2dc:	c0 60       	breq	8000a2e8 <_dtoa_r+0x29c>
8000a2de:	58 5b       	cp.w	r11,5
8000a2e0:	c0 a1       	brne	8000a2f4 <_dtoa_r+0x2a8>
8000a2e2:	30 1a       	mov	r10,1
8000a2e4:	50 da       	stdsp	sp[0x34],r10
8000a2e6:	c2 28       	rjmp	8000a32a <_dtoa_r+0x2de>
8000a2e8:	30 19       	mov	r9,1
8000a2ea:	50 d9       	stdsp	sp[0x34],r9
8000a2ec:	c0 f8       	rjmp	8000a30a <_dtoa_r+0x2be>
8000a2ee:	30 08       	mov	r8,0
8000a2f0:	30 14       	mov	r4,1
8000a2f2:	50 c8       	stdsp	sp[0x30],r8
8000a2f4:	3f f5       	mov	r5,-1
8000a2f6:	30 1c       	mov	r12,1
8000a2f8:	30 0b       	mov	r11,0
8000a2fa:	50 95       	stdsp	sp[0x24],r5
8000a2fc:	50 dc       	stdsp	sp[0x34],r12
8000a2fe:	0a 91       	mov	r1,r5
8000a300:	31 28       	mov	r8,18
8000a302:	50 eb       	stdsp	sp[0x38],r11
8000a304:	c2 08       	rjmp	8000a344 <_dtoa_r+0x2f8>
8000a306:	30 0a       	mov	r10,0
8000a308:	50 da       	stdsp	sp[0x34],r10
8000a30a:	40 e9       	lddsp	r9,sp[0x38]
8000a30c:	58 09       	cp.w	r9,0
8000a30e:	e0 89 00 07 	brgt	8000a31c <_dtoa_r+0x2d0>
8000a312:	30 18       	mov	r8,1
8000a314:	50 98       	stdsp	sp[0x24],r8
8000a316:	10 91       	mov	r1,r8
8000a318:	50 e8       	stdsp	sp[0x38],r8
8000a31a:	c1 58       	rjmp	8000a344 <_dtoa_r+0x2f8>
8000a31c:	40 e5       	lddsp	r5,sp[0x38]
8000a31e:	50 95       	stdsp	sp[0x24],r5
8000a320:	0a 91       	mov	r1,r5
8000a322:	0a 98       	mov	r8,r5
8000a324:	c1 08       	rjmp	8000a344 <_dtoa_r+0x2f8>
8000a326:	30 0c       	mov	r12,0
8000a328:	50 dc       	stdsp	sp[0x34],r12
8000a32a:	40 eb       	lddsp	r11,sp[0x38]
8000a32c:	ec 0b 00 0b 	add	r11,r6,r11
8000a330:	50 9b       	stdsp	sp[0x24],r11
8000a332:	16 98       	mov	r8,r11
8000a334:	2f f8       	sub	r8,-1
8000a336:	58 08       	cp.w	r8,0
8000a338:	e0 89 00 05 	brgt	8000a342 <_dtoa_r+0x2f6>
8000a33c:	10 91       	mov	r1,r8
8000a33e:	30 18       	mov	r8,1
8000a340:	c0 28       	rjmp	8000a344 <_dtoa_r+0x2f8>
8000a342:	10 91       	mov	r1,r8
8000a344:	30 09       	mov	r9,0
8000a346:	6e 9a       	ld.w	r10,r7[0x24]
8000a348:	95 19       	st.w	r10[0x4],r9
8000a34a:	30 49       	mov	r9,4
8000a34c:	c0 68       	rjmp	8000a358 <_dtoa_r+0x30c>
8000a34e:	d7 03       	nop
8000a350:	6a 1a       	ld.w	r10,r5[0x4]
8000a352:	a1 79       	lsl	r9,0x1
8000a354:	2f fa       	sub	r10,-1
8000a356:	8b 1a       	st.w	r5[0x4],r10
8000a358:	6e 95       	ld.w	r5,r7[0x24]
8000a35a:	f2 ca ff ec 	sub	r10,r9,-20
8000a35e:	10 3a       	cp.w	r10,r8
8000a360:	fe 98 ff f8 	brls	8000a350 <_dtoa_r+0x304>
8000a364:	6a 1b       	ld.w	r11,r5[0x4]
8000a366:	0e 9c       	mov	r12,r7
8000a368:	e0 a0 09 44 	rcall	8000b5f0 <_Balloc>
8000a36c:	58 e1       	cp.w	r1,14
8000a36e:	5f 88       	srls	r8
8000a370:	8b 0c       	st.w	r5[0x0],r12
8000a372:	f1 e4 00 04 	and	r4,r8,r4
8000a376:	6e 98       	ld.w	r8,r7[0x24]
8000a378:	70 08       	ld.w	r8,r8[0x0]
8000a37a:	50 88       	stdsp	sp[0x20],r8
8000a37c:	e0 80 01 82 	breq	8000a680 <_dtoa_r+0x634>
8000a380:	58 06       	cp.w	r6,0
8000a382:	e0 8a 00 43 	brle	8000a408 <_dtoa_r+0x3bc>
8000a386:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a38a:	fe c8 c3 ea 	sub	r8,pc,-15382
8000a38e:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a392:	fa e5 00 18 	st.d	sp[24],r4
8000a396:	ec 04 14 04 	asr	r4,r6,0x4
8000a39a:	ed b4 00 04 	bld	r4,0x4
8000a39e:	c0 30       	breq	8000a3a4 <_dtoa_r+0x358>
8000a3a0:	30 25       	mov	r5,2
8000a3a2:	c1 08       	rjmp	8000a3c2 <_dtoa_r+0x376>
8000a3a4:	fe c8 c3 3c 	sub	r8,pc,-15556
8000a3a8:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a3ac:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a3b0:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a3b4:	e0 a0 0f fa 	rcall	8000c3a8 <__avr32_f64_div>
8000a3b8:	30 35       	mov	r5,3
8000a3ba:	14 98       	mov	r8,r10
8000a3bc:	16 99       	mov	r9,r11
8000a3be:	fa e9 00 08 	st.d	sp[8],r8
8000a3c2:	fe cc c3 5a 	sub	r12,pc,-15526
8000a3c6:	50 a3       	stdsp	sp[0x28],r3
8000a3c8:	0c 93       	mov	r3,r6
8000a3ca:	18 96       	mov	r6,r12
8000a3cc:	c0 f8       	rjmp	8000a3ea <_dtoa_r+0x39e>
8000a3ce:	fa ea 00 18 	ld.d	r10,sp[24]
8000a3d2:	ed b4 00 00 	bld	r4,0x0
8000a3d6:	c0 81       	brne	8000a3e6 <_dtoa_r+0x39a>
8000a3d8:	ec e8 00 00 	ld.d	r8,r6[0]
8000a3dc:	2f f5       	sub	r5,-1
8000a3de:	e0 a0 0c 9f 	rcall	8000bd1c <__avr32_f64_mul>
8000a3e2:	fa eb 00 18 	st.d	sp[24],r10
8000a3e6:	a1 54       	asr	r4,0x1
8000a3e8:	2f 86       	sub	r6,-8
8000a3ea:	58 04       	cp.w	r4,0
8000a3ec:	cf 11       	brne	8000a3ce <_dtoa_r+0x382>
8000a3ee:	fa e8 00 18 	ld.d	r8,sp[24]
8000a3f2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a3f6:	06 96       	mov	r6,r3
8000a3f8:	e0 a0 0f d8 	rcall	8000c3a8 <__avr32_f64_div>
8000a3fc:	40 a3       	lddsp	r3,sp[0x28]
8000a3fe:	14 98       	mov	r8,r10
8000a400:	16 99       	mov	r9,r11
8000a402:	fa e9 00 08 	st.d	sp[8],r8
8000a406:	c2 f8       	rjmp	8000a464 <_dtoa_r+0x418>
8000a408:	ec 08 11 00 	rsub	r8,r6,0
8000a40c:	c0 31       	brne	8000a412 <_dtoa_r+0x3c6>
8000a40e:	30 25       	mov	r5,2
8000a410:	c2 a8       	rjmp	8000a464 <_dtoa_r+0x418>
8000a412:	fe cc c3 aa 	sub	r12,pc,-15446
8000a416:	f0 04 14 04 	asr	r4,r8,0x4
8000a41a:	50 1c       	stdsp	sp[0x4],r12
8000a41c:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a420:	fe c9 c4 80 	sub	r9,pc,-15232
8000a424:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a428:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a42c:	e0 a0 0c 78 	rcall	8000bd1c <__avr32_f64_mul>
8000a430:	40 1c       	lddsp	r12,sp[0x4]
8000a432:	50 63       	stdsp	sp[0x18],r3
8000a434:	30 25       	mov	r5,2
8000a436:	0c 93       	mov	r3,r6
8000a438:	fa eb 00 08 	st.d	sp[8],r10
8000a43c:	18 96       	mov	r6,r12
8000a43e:	c0 f8       	rjmp	8000a45c <_dtoa_r+0x410>
8000a440:	fa ea 00 08 	ld.d	r10,sp[8]
8000a444:	ed b4 00 00 	bld	r4,0x0
8000a448:	c0 81       	brne	8000a458 <_dtoa_r+0x40c>
8000a44a:	ec e8 00 00 	ld.d	r8,r6[0]
8000a44e:	2f f5       	sub	r5,-1
8000a450:	e0 a0 0c 66 	rcall	8000bd1c <__avr32_f64_mul>
8000a454:	fa eb 00 08 	st.d	sp[8],r10
8000a458:	a1 54       	asr	r4,0x1
8000a45a:	2f 86       	sub	r6,-8
8000a45c:	58 04       	cp.w	r4,0
8000a45e:	cf 11       	brne	8000a440 <_dtoa_r+0x3f4>
8000a460:	06 96       	mov	r6,r3
8000a462:	40 63       	lddsp	r3,sp[0x18]
8000a464:	41 4a       	lddsp	r10,sp[0x50]
8000a466:	58 0a       	cp.w	r10,0
8000a468:	c2 a0       	breq	8000a4bc <_dtoa_r+0x470>
8000a46a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a46e:	58 01       	cp.w	r1,0
8000a470:	5f 94       	srgt	r4
8000a472:	fa e9 00 18 	st.d	sp[24],r8
8000a476:	30 08       	mov	r8,0
8000a478:	fc 19 3f f0 	movh	r9,0x3ff0
8000a47c:	fa ea 00 18 	ld.d	r10,sp[24]
8000a480:	e0 a0 0f 60 	rcall	8000c340 <__avr32_f64_cmp_lt>
8000a484:	f9 bc 00 00 	moveq	r12,0
8000a488:	f9 bc 01 01 	movne	r12,1
8000a48c:	e9 ec 00 0c 	and	r12,r4,r12
8000a490:	c1 60       	breq	8000a4bc <_dtoa_r+0x470>
8000a492:	40 98       	lddsp	r8,sp[0x24]
8000a494:	58 08       	cp.w	r8,0
8000a496:	e0 8a 00 f1 	brle	8000a678 <_dtoa_r+0x62c>
8000a49a:	30 08       	mov	r8,0
8000a49c:	fc 19 40 24 	movh	r9,0x4024
8000a4a0:	ec c4 00 01 	sub	r4,r6,1
8000a4a4:	fa ea 00 18 	ld.d	r10,sp[24]
8000a4a8:	2f f5       	sub	r5,-1
8000a4aa:	50 64       	stdsp	sp[0x18],r4
8000a4ac:	e0 a0 0c 38 	rcall	8000bd1c <__avr32_f64_mul>
8000a4b0:	40 94       	lddsp	r4,sp[0x24]
8000a4b2:	14 98       	mov	r8,r10
8000a4b4:	16 99       	mov	r9,r11
8000a4b6:	fa e9 00 08 	st.d	sp[8],r8
8000a4ba:	c0 38       	rjmp	8000a4c0 <_dtoa_r+0x474>
8000a4bc:	50 66       	stdsp	sp[0x18],r6
8000a4be:	02 94       	mov	r4,r1
8000a4c0:	0a 9c       	mov	r12,r5
8000a4c2:	e0 a0 0e 88 	rcall	8000c1d2 <__avr32_s32_to_f64>
8000a4c6:	fa e8 00 08 	ld.d	r8,sp[8]
8000a4ca:	e0 a0 0c 29 	rcall	8000bd1c <__avr32_f64_mul>
8000a4ce:	30 08       	mov	r8,0
8000a4d0:	fc 19 40 1c 	movh	r9,0x401c
8000a4d4:	e0 a0 0d de 	rcall	8000c090 <__avr32_f64_add>
8000a4d8:	14 98       	mov	r8,r10
8000a4da:	16 99       	mov	r9,r11
8000a4dc:	fa e9 00 28 	st.d	sp[40],r8
8000a4e0:	fc 18 fc c0 	movh	r8,0xfcc0
8000a4e4:	40 a5       	lddsp	r5,sp[0x28]
8000a4e6:	10 05       	add	r5,r8
8000a4e8:	50 a5       	stdsp	sp[0x28],r5
8000a4ea:	58 04       	cp.w	r4,0
8000a4ec:	c2 11       	brne	8000a52e <_dtoa_r+0x4e2>
8000a4ee:	fa ea 00 08 	ld.d	r10,sp[8]
8000a4f2:	30 08       	mov	r8,0
8000a4f4:	fc 19 40 14 	movh	r9,0x4014
8000a4f8:	e0 a0 0c fe 	rcall	8000bef4 <__avr32_f64_sub>
8000a4fc:	40 bc       	lddsp	r12,sp[0x2c]
8000a4fe:	fa eb 00 08 	st.d	sp[8],r10
8000a502:	14 98       	mov	r8,r10
8000a504:	16 99       	mov	r9,r11
8000a506:	18 9a       	mov	r10,r12
8000a508:	0a 9b       	mov	r11,r5
8000a50a:	e0 a0 0f 1b 	rcall	8000c340 <__avr32_f64_cmp_lt>
8000a50e:	e0 81 02 54 	brne	8000a9b6 <_dtoa_r+0x96a>
8000a512:	0a 98       	mov	r8,r5
8000a514:	40 b9       	lddsp	r9,sp[0x2c]
8000a516:	ee 18 80 00 	eorh	r8,0x8000
8000a51a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a51e:	10 95       	mov	r5,r8
8000a520:	12 98       	mov	r8,r9
8000a522:	0a 99       	mov	r9,r5
8000a524:	e0 a0 0f 0e 	rcall	8000c340 <__avr32_f64_cmp_lt>
8000a528:	e0 81 02 3e 	brne	8000a9a4 <_dtoa_r+0x958>
8000a52c:	ca 68       	rjmp	8000a678 <_dtoa_r+0x62c>
8000a52e:	fe c9 c5 8e 	sub	r9,pc,-14962
8000a532:	e8 c8 00 01 	sub	r8,r4,1
8000a536:	40 d5       	lddsp	r5,sp[0x34]
8000a538:	58 05       	cp.w	r5,0
8000a53a:	c4 f0       	breq	8000a5d8 <_dtoa_r+0x58c>
8000a53c:	30 0c       	mov	r12,0
8000a53e:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a542:	51 3c       	stdsp	sp[0x4c],r12
8000a544:	30 0a       	mov	r10,0
8000a546:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a54a:	e0 a0 0f 2f 	rcall	8000c3a8 <__avr32_f64_div>
8000a54e:	fa e8 00 28 	ld.d	r8,sp[40]
8000a552:	40 85       	lddsp	r5,sp[0x20]
8000a554:	e0 a0 0c d0 	rcall	8000bef4 <__avr32_f64_sub>
8000a558:	fa eb 00 28 	st.d	sp[40],r10
8000a55c:	fa ea 00 08 	ld.d	r10,sp[8]
8000a560:	e0 a0 0e 22 	rcall	8000c1a4 <__avr32_f64_to_s32>
8000a564:	51 6c       	stdsp	sp[0x58],r12
8000a566:	e0 a0 0e 36 	rcall	8000c1d2 <__avr32_s32_to_f64>
8000a56a:	14 98       	mov	r8,r10
8000a56c:	16 99       	mov	r9,r11
8000a56e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a572:	e0 a0 0c c1 	rcall	8000bef4 <__avr32_f64_sub>
8000a576:	fa eb 00 08 	st.d	sp[8],r10
8000a57a:	41 68       	lddsp	r8,sp[0x58]
8000a57c:	2d 08       	sub	r8,-48
8000a57e:	0a c8       	st.b	r5++,r8
8000a580:	41 39       	lddsp	r9,sp[0x4c]
8000a582:	2f f9       	sub	r9,-1
8000a584:	51 39       	stdsp	sp[0x4c],r9
8000a586:	fa e8 00 28 	ld.d	r8,sp[40]
8000a58a:	e0 a0 0e db 	rcall	8000c340 <__avr32_f64_cmp_lt>
8000a58e:	e0 81 03 39 	brne	8000ac00 <_dtoa_r+0xbb4>
8000a592:	fa e8 00 08 	ld.d	r8,sp[8]
8000a596:	30 0a       	mov	r10,0
8000a598:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a59c:	e0 a0 0c ac 	rcall	8000bef4 <__avr32_f64_sub>
8000a5a0:	fa e8 00 28 	ld.d	r8,sp[40]
8000a5a4:	e0 a0 0e ce 	rcall	8000c340 <__avr32_f64_cmp_lt>
8000a5a8:	fa ea 00 28 	ld.d	r10,sp[40]
8000a5ac:	30 08       	mov	r8,0
8000a5ae:	fc 19 40 24 	movh	r9,0x4024
8000a5b2:	e0 81 00 da 	brne	8000a766 <_dtoa_r+0x71a>
8000a5b6:	41 3c       	lddsp	r12,sp[0x4c]
8000a5b8:	08 3c       	cp.w	r12,r4
8000a5ba:	c5 f4       	brge	8000a678 <_dtoa_r+0x62c>
8000a5bc:	e0 a0 0b b0 	rcall	8000bd1c <__avr32_f64_mul>
8000a5c0:	30 08       	mov	r8,0
8000a5c2:	fa eb 00 28 	st.d	sp[40],r10
8000a5c6:	fc 19 40 24 	movh	r9,0x4024
8000a5ca:	fa ea 00 08 	ld.d	r10,sp[8]
8000a5ce:	e0 a0 0b a7 	rcall	8000bd1c <__avr32_f64_mul>
8000a5d2:	fa eb 00 08 	st.d	sp[8],r10
8000a5d6:	cc 3b       	rjmp	8000a55c <_dtoa_r+0x510>
8000a5d8:	40 85       	lddsp	r5,sp[0x20]
8000a5da:	08 05       	add	r5,r4
8000a5dc:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a5e0:	51 35       	stdsp	sp[0x4c],r5
8000a5e2:	fa e8 00 28 	ld.d	r8,sp[40]
8000a5e6:	40 85       	lddsp	r5,sp[0x20]
8000a5e8:	e0 a0 0b 9a 	rcall	8000bd1c <__avr32_f64_mul>
8000a5ec:	fa eb 00 28 	st.d	sp[40],r10
8000a5f0:	fa ea 00 08 	ld.d	r10,sp[8]
8000a5f4:	e0 a0 0d d8 	rcall	8000c1a4 <__avr32_f64_to_s32>
8000a5f8:	51 6c       	stdsp	sp[0x58],r12
8000a5fa:	e0 a0 0d ec 	rcall	8000c1d2 <__avr32_s32_to_f64>
8000a5fe:	14 98       	mov	r8,r10
8000a600:	16 99       	mov	r9,r11
8000a602:	fa ea 00 08 	ld.d	r10,sp[8]
8000a606:	e0 a0 0c 77 	rcall	8000bef4 <__avr32_f64_sub>
8000a60a:	fa eb 00 08 	st.d	sp[8],r10
8000a60e:	41 68       	lddsp	r8,sp[0x58]
8000a610:	2d 08       	sub	r8,-48
8000a612:	0a c8       	st.b	r5++,r8
8000a614:	41 3c       	lddsp	r12,sp[0x4c]
8000a616:	18 35       	cp.w	r5,r12
8000a618:	c2 81       	brne	8000a668 <_dtoa_r+0x61c>
8000a61a:	30 08       	mov	r8,0
8000a61c:	fc 19 3f e0 	movh	r9,0x3fe0
8000a620:	fa ea 00 28 	ld.d	r10,sp[40]
8000a624:	e0 a0 0d 36 	rcall	8000c090 <__avr32_f64_add>
8000a628:	40 85       	lddsp	r5,sp[0x20]
8000a62a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a62e:	08 05       	add	r5,r4
8000a630:	e0 a0 0e 88 	rcall	8000c340 <__avr32_f64_cmp_lt>
8000a634:	e0 81 00 99 	brne	8000a766 <_dtoa_r+0x71a>
8000a638:	fa e8 00 28 	ld.d	r8,sp[40]
8000a63c:	30 0a       	mov	r10,0
8000a63e:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a642:	e0 a0 0c 59 	rcall	8000bef4 <__avr32_f64_sub>
8000a646:	14 98       	mov	r8,r10
8000a648:	16 99       	mov	r9,r11
8000a64a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a64e:	e0 a0 0e 79 	rcall	8000c340 <__avr32_f64_cmp_lt>
8000a652:	c1 30       	breq	8000a678 <_dtoa_r+0x62c>
8000a654:	33 09       	mov	r9,48
8000a656:	0a 98       	mov	r8,r5
8000a658:	11 7a       	ld.ub	r10,--r8
8000a65a:	f2 0a 18 00 	cp.b	r10,r9
8000a65e:	e0 81 02 d1 	brne	8000ac00 <_dtoa_r+0xbb4>
8000a662:	10 95       	mov	r5,r8
8000a664:	cf 9b       	rjmp	8000a656 <_dtoa_r+0x60a>
8000a666:	d7 03       	nop
8000a668:	30 08       	mov	r8,0
8000a66a:	fc 19 40 24 	movh	r9,0x4024
8000a66e:	e0 a0 0b 57 	rcall	8000bd1c <__avr32_f64_mul>
8000a672:	fa eb 00 08 	st.d	sp[8],r10
8000a676:	cb db       	rjmp	8000a5f0 <_dtoa_r+0x5a4>
8000a678:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a67c:	fa eb 00 08 	st.d	sp[8],r10
8000a680:	58 e6       	cp.w	r6,14
8000a682:	5f ab       	srle	r11
8000a684:	41 8a       	lddsp	r10,sp[0x60]
8000a686:	30 08       	mov	r8,0
8000a688:	f4 09 11 ff 	rsub	r9,r10,-1
8000a68c:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a690:	f0 09 18 00 	cp.b	r9,r8
8000a694:	e0 80 00 82 	breq	8000a798 <_dtoa_r+0x74c>
8000a698:	40 ea       	lddsp	r10,sp[0x38]
8000a69a:	58 01       	cp.w	r1,0
8000a69c:	5f a9       	srle	r9
8000a69e:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a6a2:	fe ca c7 02 	sub	r10,pc,-14590
8000a6a6:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a6aa:	fa e5 00 10 	st.d	sp[16],r4
8000a6ae:	f0 09 18 00 	cp.b	r9,r8
8000a6b2:	c1 40       	breq	8000a6da <_dtoa_r+0x68e>
8000a6b4:	58 01       	cp.w	r1,0
8000a6b6:	e0 81 01 77 	brne	8000a9a4 <_dtoa_r+0x958>
8000a6ba:	30 08       	mov	r8,0
8000a6bc:	fc 19 40 14 	movh	r9,0x4014
8000a6c0:	08 9a       	mov	r10,r4
8000a6c2:	0a 9b       	mov	r11,r5
8000a6c4:	e0 a0 0b 2c 	rcall	8000bd1c <__avr32_f64_mul>
8000a6c8:	fa e8 00 08 	ld.d	r8,sp[8]
8000a6cc:	e0 a0 0e 06 	rcall	8000c2d8 <__avr32_f64_cmp_ge>
8000a6d0:	e0 81 01 6a 	brne	8000a9a4 <_dtoa_r+0x958>
8000a6d4:	02 92       	mov	r2,r1
8000a6d6:	e0 8f 01 72 	bral	8000a9ba <_dtoa_r+0x96e>
8000a6da:	40 85       	lddsp	r5,sp[0x20]
8000a6dc:	30 14       	mov	r4,1
8000a6de:	fa e8 00 10 	ld.d	r8,sp[16]
8000a6e2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a6e6:	e0 a0 0e 61 	rcall	8000c3a8 <__avr32_f64_div>
8000a6ea:	e0 a0 0d 5d 	rcall	8000c1a4 <__avr32_f64_to_s32>
8000a6ee:	18 92       	mov	r2,r12
8000a6f0:	e0 a0 0d 71 	rcall	8000c1d2 <__avr32_s32_to_f64>
8000a6f4:	fa e8 00 10 	ld.d	r8,sp[16]
8000a6f8:	e0 a0 0b 12 	rcall	8000bd1c <__avr32_f64_mul>
8000a6fc:	14 98       	mov	r8,r10
8000a6fe:	16 99       	mov	r9,r11
8000a700:	fa ea 00 08 	ld.d	r10,sp[8]
8000a704:	e0 a0 0b f8 	rcall	8000bef4 <__avr32_f64_sub>
8000a708:	fa eb 00 08 	st.d	sp[8],r10
8000a70c:	e4 c8 ff d0 	sub	r8,r2,-48
8000a710:	0a c8       	st.b	r5++,r8
8000a712:	fc 19 40 24 	movh	r9,0x4024
8000a716:	30 08       	mov	r8,0
8000a718:	02 34       	cp.w	r4,r1
8000a71a:	c3 31       	brne	8000a780 <_dtoa_r+0x734>
8000a71c:	fa e8 00 08 	ld.d	r8,sp[8]
8000a720:	e0 a0 0c b8 	rcall	8000c090 <__avr32_f64_add>
8000a724:	16 91       	mov	r1,r11
8000a726:	14 90       	mov	r0,r10
8000a728:	14 98       	mov	r8,r10
8000a72a:	02 99       	mov	r9,r1
8000a72c:	fa ea 00 10 	ld.d	r10,sp[16]
8000a730:	e0 a0 0e 08 	rcall	8000c340 <__avr32_f64_cmp_lt>
8000a734:	c1 a1       	brne	8000a768 <_dtoa_r+0x71c>
8000a736:	fa e8 00 10 	ld.d	r8,sp[16]
8000a73a:	00 9a       	mov	r10,r0
8000a73c:	02 9b       	mov	r11,r1
8000a73e:	e0 a0 0d ba 	rcall	8000c2b2 <__avr32_f64_cmp_eq>
8000a742:	e0 80 02 5e 	breq	8000abfe <_dtoa_r+0xbb2>
8000a746:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a74a:	c0 f1       	brne	8000a768 <_dtoa_r+0x71c>
8000a74c:	e0 8f 02 59 	bral	8000abfe <_dtoa_r+0xbb2>
8000a750:	40 8a       	lddsp	r10,sp[0x20]
8000a752:	14 38       	cp.w	r8,r10
8000a754:	c0 30       	breq	8000a75a <_dtoa_r+0x70e>
8000a756:	10 95       	mov	r5,r8
8000a758:	c0 98       	rjmp	8000a76a <_dtoa_r+0x71e>
8000a75a:	33 08       	mov	r8,48
8000a75c:	40 89       	lddsp	r9,sp[0x20]
8000a75e:	2f f6       	sub	r6,-1
8000a760:	b2 88       	st.b	r9[0x0],r8
8000a762:	40 88       	lddsp	r8,sp[0x20]
8000a764:	c0 88       	rjmp	8000a774 <_dtoa_r+0x728>
8000a766:	40 66       	lddsp	r6,sp[0x18]
8000a768:	33 99       	mov	r9,57
8000a76a:	0a 98       	mov	r8,r5
8000a76c:	11 7a       	ld.ub	r10,--r8
8000a76e:	f2 0a 18 00 	cp.b	r10,r9
8000a772:	ce f0       	breq	8000a750 <_dtoa_r+0x704>
8000a774:	50 66       	stdsp	sp[0x18],r6
8000a776:	11 89       	ld.ub	r9,r8[0x0]
8000a778:	2f f9       	sub	r9,-1
8000a77a:	b0 89       	st.b	r8[0x0],r9
8000a77c:	e0 8f 02 42 	bral	8000ac00 <_dtoa_r+0xbb4>
8000a780:	e0 a0 0a ce 	rcall	8000bd1c <__avr32_f64_mul>
8000a784:	2f f4       	sub	r4,-1
8000a786:	fa eb 00 08 	st.d	sp[8],r10
8000a78a:	30 08       	mov	r8,0
8000a78c:	30 09       	mov	r9,0
8000a78e:	e0 a0 0d 92 	rcall	8000c2b2 <__avr32_f64_cmp_eq>
8000a792:	ca 60       	breq	8000a6de <_dtoa_r+0x692>
8000a794:	e0 8f 02 35 	bral	8000abfe <_dtoa_r+0xbb2>
8000a798:	40 d8       	lddsp	r8,sp[0x34]
8000a79a:	58 08       	cp.w	r8,0
8000a79c:	c0 51       	brne	8000a7a6 <_dtoa_r+0x75a>
8000a79e:	04 98       	mov	r8,r2
8000a7a0:	00 95       	mov	r5,r0
8000a7a2:	40 d4       	lddsp	r4,sp[0x34]
8000a7a4:	c3 78       	rjmp	8000a812 <_dtoa_r+0x7c6>
8000a7a6:	40 c5       	lddsp	r5,sp[0x30]
8000a7a8:	58 15       	cp.w	r5,1
8000a7aa:	e0 89 00 0f 	brgt	8000a7c8 <_dtoa_r+0x77c>
8000a7ae:	41 74       	lddsp	r4,sp[0x5c]
8000a7b0:	58 04       	cp.w	r4,0
8000a7b2:	c0 40       	breq	8000a7ba <_dtoa_r+0x76e>
8000a7b4:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a7b8:	c0 48       	rjmp	8000a7c0 <_dtoa_r+0x774>
8000a7ba:	41 99       	lddsp	r9,sp[0x64]
8000a7bc:	f2 09 11 36 	rsub	r9,r9,54
8000a7c0:	04 98       	mov	r8,r2
8000a7c2:	00 95       	mov	r5,r0
8000a7c4:	c1 c8       	rjmp	8000a7fc <_dtoa_r+0x7b0>
8000a7c6:	d7 03       	nop
8000a7c8:	e2 c8 00 01 	sub	r8,r1,1
8000a7cc:	58 01       	cp.w	r1,0
8000a7ce:	e0 05 17 40 	movge	r5,r0
8000a7d2:	e2 09 17 40 	movge	r9,r1
8000a7d6:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a7da:	f9 b9 05 00 	movlt	r9,0
8000a7de:	10 32       	cp.w	r2,r8
8000a7e0:	e5 d8 e4 18 	subge	r8,r2,r8
8000a7e4:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a7e8:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a7ec:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a7f0:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a7f4:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a7f8:	f9 b8 05 00 	movlt	r8,0
8000a7fc:	40 4b       	lddsp	r11,sp[0x10]
8000a7fe:	12 0b       	add	r11,r9
8000a800:	50 08       	stdsp	sp[0x0],r8
8000a802:	50 4b       	stdsp	sp[0x10],r11
8000a804:	12 00       	add	r0,r9
8000a806:	30 1b       	mov	r11,1
8000a808:	0e 9c       	mov	r12,r7
8000a80a:	e0 a0 08 a7 	rcall	8000b958 <__i2b>
8000a80e:	40 08       	lddsp	r8,sp[0x0]
8000a810:	18 94       	mov	r4,r12
8000a812:	40 4a       	lddsp	r10,sp[0x10]
8000a814:	58 05       	cp.w	r5,0
8000a816:	5f 99       	srgt	r9
8000a818:	58 0a       	cp.w	r10,0
8000a81a:	5f 9a       	srgt	r10
8000a81c:	f5 e9 00 09 	and	r9,r10,r9
8000a820:	c0 80       	breq	8000a830 <_dtoa_r+0x7e4>
8000a822:	40 4c       	lddsp	r12,sp[0x10]
8000a824:	f8 05 0d 49 	min	r9,r12,r5
8000a828:	12 1c       	sub	r12,r9
8000a82a:	12 10       	sub	r0,r9
8000a82c:	50 4c       	stdsp	sp[0x10],r12
8000a82e:	12 15       	sub	r5,r9
8000a830:	58 02       	cp.w	r2,0
8000a832:	e0 8a 00 27 	brle	8000a880 <_dtoa_r+0x834>
8000a836:	40 db       	lddsp	r11,sp[0x34]
8000a838:	58 0b       	cp.w	r11,0
8000a83a:	c1 d0       	breq	8000a874 <_dtoa_r+0x828>
8000a83c:	58 08       	cp.w	r8,0
8000a83e:	e0 8a 00 17 	brle	8000a86c <_dtoa_r+0x820>
8000a842:	10 9a       	mov	r10,r8
8000a844:	50 08       	stdsp	sp[0x0],r8
8000a846:	08 9b       	mov	r11,r4
8000a848:	0e 9c       	mov	r12,r7
8000a84a:	e0 a0 08 cd 	rcall	8000b9e4 <__pow5mult>
8000a84e:	06 9a       	mov	r10,r3
8000a850:	18 9b       	mov	r11,r12
8000a852:	18 94       	mov	r4,r12
8000a854:	0e 9c       	mov	r12,r7
8000a856:	e0 a0 08 01 	rcall	8000b858 <__multiply>
8000a85a:	18 99       	mov	r9,r12
8000a85c:	06 9b       	mov	r11,r3
8000a85e:	50 19       	stdsp	sp[0x4],r9
8000a860:	0e 9c       	mov	r12,r7
8000a862:	e0 a0 06 ad 	rcall	8000b5bc <_Bfree>
8000a866:	40 19       	lddsp	r9,sp[0x4]
8000a868:	40 08       	lddsp	r8,sp[0x0]
8000a86a:	12 93       	mov	r3,r9
8000a86c:	e4 08 01 0a 	sub	r10,r2,r8
8000a870:	c0 80       	breq	8000a880 <_dtoa_r+0x834>
8000a872:	c0 28       	rjmp	8000a876 <_dtoa_r+0x82a>
8000a874:	04 9a       	mov	r10,r2
8000a876:	06 9b       	mov	r11,r3
8000a878:	0e 9c       	mov	r12,r7
8000a87a:	e0 a0 08 b5 	rcall	8000b9e4 <__pow5mult>
8000a87e:	18 93       	mov	r3,r12
8000a880:	30 1b       	mov	r11,1
8000a882:	0e 9c       	mov	r12,r7
8000a884:	e0 a0 08 6a 	rcall	8000b958 <__i2b>
8000a888:	41 1a       	lddsp	r10,sp[0x44]
8000a88a:	18 92       	mov	r2,r12
8000a88c:	58 0a       	cp.w	r10,0
8000a88e:	e0 8a 00 07 	brle	8000a89c <_dtoa_r+0x850>
8000a892:	18 9b       	mov	r11,r12
8000a894:	0e 9c       	mov	r12,r7
8000a896:	e0 a0 08 a7 	rcall	8000b9e4 <__pow5mult>
8000a89a:	18 92       	mov	r2,r12
8000a89c:	40 c9       	lddsp	r9,sp[0x30]
8000a89e:	58 19       	cp.w	r9,1
8000a8a0:	e0 89 00 14 	brgt	8000a8c8 <_dtoa_r+0x87c>
8000a8a4:	40 38       	lddsp	r8,sp[0xc]
8000a8a6:	58 08       	cp.w	r8,0
8000a8a8:	c1 01       	brne	8000a8c8 <_dtoa_r+0x87c>
8000a8aa:	40 29       	lddsp	r9,sp[0x8]
8000a8ac:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a8b0:	c0 c1       	brne	8000a8c8 <_dtoa_r+0x87c>
8000a8b2:	12 98       	mov	r8,r9
8000a8b4:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a8b8:	c0 80       	breq	8000a8c8 <_dtoa_r+0x87c>
8000a8ba:	40 4c       	lddsp	r12,sp[0x10]
8000a8bc:	30 1b       	mov	r11,1
8000a8be:	2f fc       	sub	r12,-1
8000a8c0:	2f f0       	sub	r0,-1
8000a8c2:	50 4c       	stdsp	sp[0x10],r12
8000a8c4:	50 6b       	stdsp	sp[0x18],r11
8000a8c6:	c0 38       	rjmp	8000a8cc <_dtoa_r+0x880>
8000a8c8:	30 0a       	mov	r10,0
8000a8ca:	50 6a       	stdsp	sp[0x18],r10
8000a8cc:	41 19       	lddsp	r9,sp[0x44]
8000a8ce:	58 09       	cp.w	r9,0
8000a8d0:	c0 31       	brne	8000a8d6 <_dtoa_r+0x88a>
8000a8d2:	30 1c       	mov	r12,1
8000a8d4:	c0 98       	rjmp	8000a8e6 <_dtoa_r+0x89a>
8000a8d6:	64 48       	ld.w	r8,r2[0x10]
8000a8d8:	2f c8       	sub	r8,-4
8000a8da:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a8de:	e0 a0 05 df 	rcall	8000b49c <__hi0bits>
8000a8e2:	f8 0c 11 20 	rsub	r12,r12,32
8000a8e6:	40 4b       	lddsp	r11,sp[0x10]
8000a8e8:	f8 0b 00 08 	add	r8,r12,r11
8000a8ec:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a8f0:	c0 c0       	breq	8000a908 <_dtoa_r+0x8bc>
8000a8f2:	f0 08 11 20 	rsub	r8,r8,32
8000a8f6:	58 48       	cp.w	r8,4
8000a8f8:	e0 8a 00 06 	brle	8000a904 <_dtoa_r+0x8b8>
8000a8fc:	20 48       	sub	r8,4
8000a8fe:	10 0b       	add	r11,r8
8000a900:	50 4b       	stdsp	sp[0x10],r11
8000a902:	c0 78       	rjmp	8000a910 <_dtoa_r+0x8c4>
8000a904:	58 48       	cp.w	r8,4
8000a906:	c0 70       	breq	8000a914 <_dtoa_r+0x8c8>
8000a908:	40 4a       	lddsp	r10,sp[0x10]
8000a90a:	2e 48       	sub	r8,-28
8000a90c:	10 0a       	add	r10,r8
8000a90e:	50 4a       	stdsp	sp[0x10],r10
8000a910:	10 00       	add	r0,r8
8000a912:	10 05       	add	r5,r8
8000a914:	58 00       	cp.w	r0,0
8000a916:	e0 8a 00 08 	brle	8000a926 <_dtoa_r+0x8da>
8000a91a:	06 9b       	mov	r11,r3
8000a91c:	00 9a       	mov	r10,r0
8000a91e:	0e 9c       	mov	r12,r7
8000a920:	e0 a0 07 58 	rcall	8000b7d0 <__lshift>
8000a924:	18 93       	mov	r3,r12
8000a926:	40 49       	lddsp	r9,sp[0x10]
8000a928:	58 09       	cp.w	r9,0
8000a92a:	e0 8a 00 08 	brle	8000a93a <_dtoa_r+0x8ee>
8000a92e:	04 9b       	mov	r11,r2
8000a930:	12 9a       	mov	r10,r9
8000a932:	0e 9c       	mov	r12,r7
8000a934:	e0 a0 07 4e 	rcall	8000b7d0 <__lshift>
8000a938:	18 92       	mov	r2,r12
8000a93a:	41 48       	lddsp	r8,sp[0x50]
8000a93c:	58 08       	cp.w	r8,0
8000a93e:	c1 b0       	breq	8000a974 <_dtoa_r+0x928>
8000a940:	04 9b       	mov	r11,r2
8000a942:	06 9c       	mov	r12,r3
8000a944:	e0 a0 06 23 	rcall	8000b58a <__mcmp>
8000a948:	c1 64       	brge	8000a974 <_dtoa_r+0x928>
8000a94a:	06 9b       	mov	r11,r3
8000a94c:	30 09       	mov	r9,0
8000a94e:	30 aa       	mov	r10,10
8000a950:	0e 9c       	mov	r12,r7
8000a952:	e0 a0 08 0b 	rcall	8000b968 <__multadd>
8000a956:	20 16       	sub	r6,1
8000a958:	18 93       	mov	r3,r12
8000a95a:	40 dc       	lddsp	r12,sp[0x34]
8000a95c:	58 0c       	cp.w	r12,0
8000a95e:	c0 31       	brne	8000a964 <_dtoa_r+0x918>
8000a960:	40 91       	lddsp	r1,sp[0x24]
8000a962:	c0 98       	rjmp	8000a974 <_dtoa_r+0x928>
8000a964:	08 9b       	mov	r11,r4
8000a966:	40 91       	lddsp	r1,sp[0x24]
8000a968:	30 09       	mov	r9,0
8000a96a:	30 aa       	mov	r10,10
8000a96c:	0e 9c       	mov	r12,r7
8000a96e:	e0 a0 07 fd 	rcall	8000b968 <__multadd>
8000a972:	18 94       	mov	r4,r12
8000a974:	58 01       	cp.w	r1,0
8000a976:	5f a9       	srle	r9
8000a978:	40 cb       	lddsp	r11,sp[0x30]
8000a97a:	58 2b       	cp.w	r11,2
8000a97c:	5f 98       	srgt	r8
8000a97e:	f3 e8 00 08 	and	r8,r9,r8
8000a982:	c2 50       	breq	8000a9cc <_dtoa_r+0x980>
8000a984:	58 01       	cp.w	r1,0
8000a986:	c1 11       	brne	8000a9a8 <_dtoa_r+0x95c>
8000a988:	04 9b       	mov	r11,r2
8000a98a:	02 99       	mov	r9,r1
8000a98c:	30 5a       	mov	r10,5
8000a98e:	0e 9c       	mov	r12,r7
8000a990:	e0 a0 07 ec 	rcall	8000b968 <__multadd>
8000a994:	18 92       	mov	r2,r12
8000a996:	18 9b       	mov	r11,r12
8000a998:	06 9c       	mov	r12,r3
8000a99a:	e0 a0 05 f8 	rcall	8000b58a <__mcmp>
8000a99e:	e0 89 00 0f 	brgt	8000a9bc <_dtoa_r+0x970>
8000a9a2:	c0 38       	rjmp	8000a9a8 <_dtoa_r+0x95c>
8000a9a4:	30 02       	mov	r2,0
8000a9a6:	04 94       	mov	r4,r2
8000a9a8:	40 ea       	lddsp	r10,sp[0x38]
8000a9aa:	30 09       	mov	r9,0
8000a9ac:	5c da       	com	r10
8000a9ae:	40 85       	lddsp	r5,sp[0x20]
8000a9b0:	50 6a       	stdsp	sp[0x18],r10
8000a9b2:	50 49       	stdsp	sp[0x10],r9
8000a9b4:	c0 f9       	rjmp	8000abd2 <_dtoa_r+0xb86>
8000a9b6:	08 92       	mov	r2,r4
8000a9b8:	40 66       	lddsp	r6,sp[0x18]
8000a9ba:	04 94       	mov	r4,r2
8000a9bc:	2f f6       	sub	r6,-1
8000a9be:	50 66       	stdsp	sp[0x18],r6
8000a9c0:	33 18       	mov	r8,49
8000a9c2:	40 85       	lddsp	r5,sp[0x20]
8000a9c4:	0a c8       	st.b	r5++,r8
8000a9c6:	30 08       	mov	r8,0
8000a9c8:	50 48       	stdsp	sp[0x10],r8
8000a9ca:	c0 49       	rjmp	8000abd2 <_dtoa_r+0xb86>
8000a9cc:	40 dc       	lddsp	r12,sp[0x34]
8000a9ce:	58 0c       	cp.w	r12,0
8000a9d0:	e0 80 00 b5 	breq	8000ab3a <_dtoa_r+0xaee>
8000a9d4:	58 05       	cp.w	r5,0
8000a9d6:	e0 8a 00 08 	brle	8000a9e6 <_dtoa_r+0x99a>
8000a9da:	08 9b       	mov	r11,r4
8000a9dc:	0a 9a       	mov	r10,r5
8000a9de:	0e 9c       	mov	r12,r7
8000a9e0:	e0 a0 06 f8 	rcall	8000b7d0 <__lshift>
8000a9e4:	18 94       	mov	r4,r12
8000a9e6:	40 6b       	lddsp	r11,sp[0x18]
8000a9e8:	58 0b       	cp.w	r11,0
8000a9ea:	c0 31       	brne	8000a9f0 <_dtoa_r+0x9a4>
8000a9ec:	08 9c       	mov	r12,r4
8000a9ee:	c1 38       	rjmp	8000aa14 <_dtoa_r+0x9c8>
8000a9f0:	68 1b       	ld.w	r11,r4[0x4]
8000a9f2:	0e 9c       	mov	r12,r7
8000a9f4:	e0 a0 05 fe 	rcall	8000b5f0 <_Balloc>
8000a9f8:	68 4a       	ld.w	r10,r4[0x10]
8000a9fa:	18 95       	mov	r5,r12
8000a9fc:	e8 cb ff f4 	sub	r11,r4,-12
8000aa00:	2f ea       	sub	r10,-2
8000aa02:	2f 4c       	sub	r12,-12
8000aa04:	a3 6a       	lsl	r10,0x2
8000aa06:	fe b0 e6 4f 	rcall	800076a4 <memcpy>
8000aa0a:	0a 9b       	mov	r11,r5
8000aa0c:	30 1a       	mov	r10,1
8000aa0e:	0e 9c       	mov	r12,r7
8000aa10:	e0 a0 06 e0 	rcall	8000b7d0 <__lshift>
8000aa14:	50 44       	stdsp	sp[0x10],r4
8000aa16:	40 3a       	lddsp	r10,sp[0xc]
8000aa18:	30 19       	mov	r9,1
8000aa1a:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000aa1e:	18 94       	mov	r4,r12
8000aa20:	50 da       	stdsp	sp[0x34],r10
8000aa22:	40 85       	lddsp	r5,sp[0x20]
8000aa24:	50 99       	stdsp	sp[0x24],r9
8000aa26:	50 26       	stdsp	sp[0x8],r6
8000aa28:	50 e1       	stdsp	sp[0x38],r1
8000aa2a:	04 9b       	mov	r11,r2
8000aa2c:	06 9c       	mov	r12,r3
8000aa2e:	fe b0 fa 7f 	rcall	80009f2c <quorem>
8000aa32:	40 4b       	lddsp	r11,sp[0x10]
8000aa34:	f8 c0 ff d0 	sub	r0,r12,-48
8000aa38:	06 9c       	mov	r12,r3
8000aa3a:	e0 a0 05 a8 	rcall	8000b58a <__mcmp>
8000aa3e:	08 9a       	mov	r10,r4
8000aa40:	50 6c       	stdsp	sp[0x18],r12
8000aa42:	04 9b       	mov	r11,r2
8000aa44:	0e 9c       	mov	r12,r7
8000aa46:	e0 a0 06 5d 	rcall	8000b700 <__mdiff>
8000aa4a:	18 91       	mov	r1,r12
8000aa4c:	78 38       	ld.w	r8,r12[0xc]
8000aa4e:	58 08       	cp.w	r8,0
8000aa50:	c0 30       	breq	8000aa56 <_dtoa_r+0xa0a>
8000aa52:	30 16       	mov	r6,1
8000aa54:	c0 68       	rjmp	8000aa60 <_dtoa_r+0xa14>
8000aa56:	18 9b       	mov	r11,r12
8000aa58:	06 9c       	mov	r12,r3
8000aa5a:	e0 a0 05 98 	rcall	8000b58a <__mcmp>
8000aa5e:	18 96       	mov	r6,r12
8000aa60:	0e 9c       	mov	r12,r7
8000aa62:	02 9b       	mov	r11,r1
8000aa64:	e0 a0 05 ac 	rcall	8000b5bc <_Bfree>
8000aa68:	40 cc       	lddsp	r12,sp[0x30]
8000aa6a:	ed ec 10 08 	or	r8,r6,r12
8000aa6e:	c0 d1       	brne	8000aa88 <_dtoa_r+0xa3c>
8000aa70:	40 db       	lddsp	r11,sp[0x34]
8000aa72:	58 0b       	cp.w	r11,0
8000aa74:	c0 a1       	brne	8000aa88 <_dtoa_r+0xa3c>
8000aa76:	40 26       	lddsp	r6,sp[0x8]
8000aa78:	e0 40 00 39 	cp.w	r0,57
8000aa7c:	c3 00       	breq	8000aadc <_dtoa_r+0xa90>
8000aa7e:	40 6a       	lddsp	r10,sp[0x18]
8000aa80:	58 0a       	cp.w	r10,0
8000aa82:	e0 89 00 24 	brgt	8000aaca <_dtoa_r+0xa7e>
8000aa86:	c2 f8       	rjmp	8000aae4 <_dtoa_r+0xa98>
8000aa88:	40 69       	lddsp	r9,sp[0x18]
8000aa8a:	58 09       	cp.w	r9,0
8000aa8c:	c0 85       	brlt	8000aa9c <_dtoa_r+0xa50>
8000aa8e:	12 98       	mov	r8,r9
8000aa90:	40 cc       	lddsp	r12,sp[0x30]
8000aa92:	18 48       	or	r8,r12
8000aa94:	c1 d1       	brne	8000aace <_dtoa_r+0xa82>
8000aa96:	40 db       	lddsp	r11,sp[0x34]
8000aa98:	58 0b       	cp.w	r11,0
8000aa9a:	c1 a1       	brne	8000aace <_dtoa_r+0xa82>
8000aa9c:	0c 99       	mov	r9,r6
8000aa9e:	40 26       	lddsp	r6,sp[0x8]
8000aaa0:	58 09       	cp.w	r9,0
8000aaa2:	e0 8a 00 21 	brle	8000aae4 <_dtoa_r+0xa98>
8000aaa6:	06 9b       	mov	r11,r3
8000aaa8:	30 1a       	mov	r10,1
8000aaaa:	0e 9c       	mov	r12,r7
8000aaac:	e0 a0 06 92 	rcall	8000b7d0 <__lshift>
8000aab0:	04 9b       	mov	r11,r2
8000aab2:	18 93       	mov	r3,r12
8000aab4:	e0 a0 05 6b 	rcall	8000b58a <__mcmp>
8000aab8:	e0 89 00 06 	brgt	8000aac4 <_dtoa_r+0xa78>
8000aabc:	c1 41       	brne	8000aae4 <_dtoa_r+0xa98>
8000aabe:	ed b0 00 00 	bld	r0,0x0
8000aac2:	c1 11       	brne	8000aae4 <_dtoa_r+0xa98>
8000aac4:	e0 40 00 39 	cp.w	r0,57
8000aac8:	c0 a0       	breq	8000aadc <_dtoa_r+0xa90>
8000aaca:	2f f0       	sub	r0,-1
8000aacc:	c0 c8       	rjmp	8000aae4 <_dtoa_r+0xa98>
8000aace:	58 06       	cp.w	r6,0
8000aad0:	e0 8a 00 0c 	brle	8000aae8 <_dtoa_r+0xa9c>
8000aad4:	40 26       	lddsp	r6,sp[0x8]
8000aad6:	e0 40 00 39 	cp.w	r0,57
8000aada:	c0 41       	brne	8000aae2 <_dtoa_r+0xa96>
8000aadc:	33 98       	mov	r8,57
8000aade:	0a c8       	st.b	r5++,r8
8000aae0:	c6 78       	rjmp	8000abae <_dtoa_r+0xb62>
8000aae2:	2f f0       	sub	r0,-1
8000aae4:	0a c0       	st.b	r5++,r0
8000aae6:	c7 58       	rjmp	8000abd0 <_dtoa_r+0xb84>
8000aae8:	0a c0       	st.b	r5++,r0
8000aaea:	40 9a       	lddsp	r10,sp[0x24]
8000aaec:	40 e9       	lddsp	r9,sp[0x38]
8000aaee:	12 3a       	cp.w	r10,r9
8000aaf0:	c4 30       	breq	8000ab76 <_dtoa_r+0xb2a>
8000aaf2:	06 9b       	mov	r11,r3
8000aaf4:	30 09       	mov	r9,0
8000aaf6:	30 aa       	mov	r10,10
8000aaf8:	0e 9c       	mov	r12,r7
8000aafa:	e0 a0 07 37 	rcall	8000b968 <__multadd>
8000aafe:	40 48       	lddsp	r8,sp[0x10]
8000ab00:	18 93       	mov	r3,r12
8000ab02:	08 38       	cp.w	r8,r4
8000ab04:	c0 91       	brne	8000ab16 <_dtoa_r+0xaca>
8000ab06:	10 9b       	mov	r11,r8
8000ab08:	30 09       	mov	r9,0
8000ab0a:	30 aa       	mov	r10,10
8000ab0c:	0e 9c       	mov	r12,r7
8000ab0e:	e0 a0 07 2d 	rcall	8000b968 <__multadd>
8000ab12:	50 4c       	stdsp	sp[0x10],r12
8000ab14:	c0 e8       	rjmp	8000ab30 <_dtoa_r+0xae4>
8000ab16:	40 4b       	lddsp	r11,sp[0x10]
8000ab18:	30 09       	mov	r9,0
8000ab1a:	30 aa       	mov	r10,10
8000ab1c:	0e 9c       	mov	r12,r7
8000ab1e:	e0 a0 07 25 	rcall	8000b968 <__multadd>
8000ab22:	08 9b       	mov	r11,r4
8000ab24:	50 4c       	stdsp	sp[0x10],r12
8000ab26:	30 09       	mov	r9,0
8000ab28:	30 aa       	mov	r10,10
8000ab2a:	0e 9c       	mov	r12,r7
8000ab2c:	e0 a0 07 1e 	rcall	8000b968 <__multadd>
8000ab30:	18 94       	mov	r4,r12
8000ab32:	40 9c       	lddsp	r12,sp[0x24]
8000ab34:	2f fc       	sub	r12,-1
8000ab36:	50 9c       	stdsp	sp[0x24],r12
8000ab38:	c7 9b       	rjmp	8000aa2a <_dtoa_r+0x9de>
8000ab3a:	30 18       	mov	r8,1
8000ab3c:	06 90       	mov	r0,r3
8000ab3e:	40 85       	lddsp	r5,sp[0x20]
8000ab40:	08 93       	mov	r3,r4
8000ab42:	0c 94       	mov	r4,r6
8000ab44:	10 96       	mov	r6,r8
8000ab46:	04 9b       	mov	r11,r2
8000ab48:	00 9c       	mov	r12,r0
8000ab4a:	fe b0 f9 f1 	rcall	80009f2c <quorem>
8000ab4e:	2d 0c       	sub	r12,-48
8000ab50:	0a cc       	st.b	r5++,r12
8000ab52:	02 36       	cp.w	r6,r1
8000ab54:	c0 a4       	brge	8000ab68 <_dtoa_r+0xb1c>
8000ab56:	00 9b       	mov	r11,r0
8000ab58:	30 09       	mov	r9,0
8000ab5a:	30 aa       	mov	r10,10
8000ab5c:	0e 9c       	mov	r12,r7
8000ab5e:	2f f6       	sub	r6,-1
8000ab60:	e0 a0 07 04 	rcall	8000b968 <__multadd>
8000ab64:	18 90       	mov	r0,r12
8000ab66:	cf 0b       	rjmp	8000ab46 <_dtoa_r+0xafa>
8000ab68:	08 96       	mov	r6,r4
8000ab6a:	30 0b       	mov	r11,0
8000ab6c:	06 94       	mov	r4,r3
8000ab6e:	50 4b       	stdsp	sp[0x10],r11
8000ab70:	00 93       	mov	r3,r0
8000ab72:	18 90       	mov	r0,r12
8000ab74:	c0 28       	rjmp	8000ab78 <_dtoa_r+0xb2c>
8000ab76:	40 26       	lddsp	r6,sp[0x8]
8000ab78:	06 9b       	mov	r11,r3
8000ab7a:	30 1a       	mov	r10,1
8000ab7c:	0e 9c       	mov	r12,r7
8000ab7e:	e0 a0 06 29 	rcall	8000b7d0 <__lshift>
8000ab82:	04 9b       	mov	r11,r2
8000ab84:	18 93       	mov	r3,r12
8000ab86:	e0 a0 05 02 	rcall	8000b58a <__mcmp>
8000ab8a:	e0 89 00 12 	brgt	8000abae <_dtoa_r+0xb62>
8000ab8e:	c1 b1       	brne	8000abc4 <_dtoa_r+0xb78>
8000ab90:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000ab94:	c0 d1       	brne	8000abae <_dtoa_r+0xb62>
8000ab96:	c1 78       	rjmp	8000abc4 <_dtoa_r+0xb78>
8000ab98:	40 89       	lddsp	r9,sp[0x20]
8000ab9a:	12 38       	cp.w	r8,r9
8000ab9c:	c0 30       	breq	8000aba2 <_dtoa_r+0xb56>
8000ab9e:	10 95       	mov	r5,r8
8000aba0:	c0 88       	rjmp	8000abb0 <_dtoa_r+0xb64>
8000aba2:	2f f6       	sub	r6,-1
8000aba4:	50 66       	stdsp	sp[0x18],r6
8000aba6:	33 18       	mov	r8,49
8000aba8:	40 8c       	lddsp	r12,sp[0x20]
8000abaa:	b8 88       	st.b	r12[0x0],r8
8000abac:	c1 38       	rjmp	8000abd2 <_dtoa_r+0xb86>
8000abae:	33 9a       	mov	r10,57
8000abb0:	0a 98       	mov	r8,r5
8000abb2:	11 79       	ld.ub	r9,--r8
8000abb4:	f4 09 18 00 	cp.b	r9,r10
8000abb8:	cf 00       	breq	8000ab98 <_dtoa_r+0xb4c>
8000abba:	2f f9       	sub	r9,-1
8000abbc:	b0 89       	st.b	r8[0x0],r9
8000abbe:	c0 98       	rjmp	8000abd0 <_dtoa_r+0xb84>
8000abc0:	10 95       	mov	r5,r8
8000abc2:	c0 28       	rjmp	8000abc6 <_dtoa_r+0xb7a>
8000abc4:	33 09       	mov	r9,48
8000abc6:	0a 98       	mov	r8,r5
8000abc8:	11 7a       	ld.ub	r10,--r8
8000abca:	f2 0a 18 00 	cp.b	r10,r9
8000abce:	cf 90       	breq	8000abc0 <_dtoa_r+0xb74>
8000abd0:	50 66       	stdsp	sp[0x18],r6
8000abd2:	04 9b       	mov	r11,r2
8000abd4:	0e 9c       	mov	r12,r7
8000abd6:	e0 a0 04 f3 	rcall	8000b5bc <_Bfree>
8000abda:	58 04       	cp.w	r4,0
8000abdc:	c1 20       	breq	8000ac00 <_dtoa_r+0xbb4>
8000abde:	40 4b       	lddsp	r11,sp[0x10]
8000abe0:	08 3b       	cp.w	r11,r4
8000abe2:	5f 19       	srne	r9
8000abe4:	58 0b       	cp.w	r11,0
8000abe6:	5f 18       	srne	r8
8000abe8:	f3 e8 00 08 	and	r8,r9,r8
8000abec:	c0 40       	breq	8000abf4 <_dtoa_r+0xba8>
8000abee:	0e 9c       	mov	r12,r7
8000abf0:	e0 a0 04 e6 	rcall	8000b5bc <_Bfree>
8000abf4:	08 9b       	mov	r11,r4
8000abf6:	0e 9c       	mov	r12,r7
8000abf8:	e0 a0 04 e2 	rcall	8000b5bc <_Bfree>
8000abfc:	c0 28       	rjmp	8000ac00 <_dtoa_r+0xbb4>
8000abfe:	50 66       	stdsp	sp[0x18],r6
8000ac00:	0e 9c       	mov	r12,r7
8000ac02:	06 9b       	mov	r11,r3
8000ac04:	e0 a0 04 dc 	rcall	8000b5bc <_Bfree>
8000ac08:	30 08       	mov	r8,0
8000ac0a:	aa 88       	st.b	r5[0x0],r8
8000ac0c:	40 68       	lddsp	r8,sp[0x18]
8000ac0e:	41 5a       	lddsp	r10,sp[0x54]
8000ac10:	2f f8       	sub	r8,-1
8000ac12:	41 29       	lddsp	r9,sp[0x48]
8000ac14:	95 08       	st.w	r10[0x0],r8
8000ac16:	40 8c       	lddsp	r12,sp[0x20]
8000ac18:	58 09       	cp.w	r9,0
8000ac1a:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000ac1e:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000ac22:	2e 6d       	sub	sp,-104
8000ac24:	d8 32       	popm	r0-r7,pc
8000ac26:	d7 03       	nop

8000ac28 <__errno>:
8000ac28:	e0 68 0a 3c 	mov	r8,2620
8000ac2c:	70 0c       	ld.w	r12,r8[0x0]
8000ac2e:	2f 4c       	sub	r12,-12
8000ac30:	5e fc       	retal	r12
8000ac32:	d7 03       	nop

8000ac34 <_fflush_r>:
8000ac34:	d4 21       	pushm	r4-r7,lr
8000ac36:	16 97       	mov	r7,r11
8000ac38:	18 96       	mov	r6,r12
8000ac3a:	76 48       	ld.w	r8,r11[0x10]
8000ac3c:	58 08       	cp.w	r8,0
8000ac3e:	c7 f0       	breq	8000ad3c <_fflush_r+0x108>
8000ac40:	58 0c       	cp.w	r12,0
8000ac42:	c0 50       	breq	8000ac4c <_fflush_r+0x18>
8000ac44:	78 68       	ld.w	r8,r12[0x18]
8000ac46:	58 08       	cp.w	r8,0
8000ac48:	c0 21       	brne	8000ac4c <_fflush_r+0x18>
8000ac4a:	cc dc       	rcall	8000ade4 <__sinit>
8000ac4c:	fe c8 cd 5c 	sub	r8,pc,-12964
8000ac50:	10 37       	cp.w	r7,r8
8000ac52:	c0 31       	brne	8000ac58 <_fflush_r+0x24>
8000ac54:	6c 07       	ld.w	r7,r6[0x0]
8000ac56:	c0 c8       	rjmp	8000ac6e <_fflush_r+0x3a>
8000ac58:	fe c8 cd 48 	sub	r8,pc,-12984
8000ac5c:	10 37       	cp.w	r7,r8
8000ac5e:	c0 31       	brne	8000ac64 <_fflush_r+0x30>
8000ac60:	6c 17       	ld.w	r7,r6[0x4]
8000ac62:	c0 68       	rjmp	8000ac6e <_fflush_r+0x3a>
8000ac64:	fe c8 cd 34 	sub	r8,pc,-13004
8000ac68:	10 37       	cp.w	r7,r8
8000ac6a:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000ac6e:	8e 6a       	ld.sh	r10,r7[0xc]
8000ac70:	14 98       	mov	r8,r10
8000ac72:	ed ba 00 03 	bld	r10,0x3
8000ac76:	c4 20       	breq	8000acfa <_fflush_r+0xc6>
8000ac78:	ab ba       	sbr	r10,0xb
8000ac7a:	ae 6a       	st.h	r7[0xc],r10
8000ac7c:	6e 18       	ld.w	r8,r7[0x4]
8000ac7e:	58 08       	cp.w	r8,0
8000ac80:	e0 89 00 06 	brgt	8000ac8c <_fflush_r+0x58>
8000ac84:	6f 08       	ld.w	r8,r7[0x40]
8000ac86:	58 08       	cp.w	r8,0
8000ac88:	e0 8a 00 5a 	brle	8000ad3c <_fflush_r+0x108>
8000ac8c:	6e b8       	ld.w	r8,r7[0x2c]
8000ac8e:	58 08       	cp.w	r8,0
8000ac90:	c5 60       	breq	8000ad3c <_fflush_r+0x108>
8000ac92:	e2 1a 10 00 	andl	r10,0x1000,COH
8000ac96:	c0 30       	breq	8000ac9c <_fflush_r+0x68>
8000ac98:	6f 55       	ld.w	r5,r7[0x54]
8000ac9a:	c0 f8       	rjmp	8000acb8 <_fflush_r+0x84>
8000ac9c:	30 19       	mov	r9,1
8000ac9e:	6e 8b       	ld.w	r11,r7[0x20]
8000aca0:	0c 9c       	mov	r12,r6
8000aca2:	5d 18       	icall	r8
8000aca4:	18 95       	mov	r5,r12
8000aca6:	5b fc       	cp.w	r12,-1
8000aca8:	c0 81       	brne	8000acb8 <_fflush_r+0x84>
8000acaa:	6c 38       	ld.w	r8,r6[0xc]
8000acac:	59 d8       	cp.w	r8,29
8000acae:	c4 70       	breq	8000ad3c <_fflush_r+0x108>
8000acb0:	8e 68       	ld.sh	r8,r7[0xc]
8000acb2:	a7 a8       	sbr	r8,0x6
8000acb4:	ae 68       	st.h	r7[0xc],r8
8000acb6:	d8 22       	popm	r4-r7,pc
8000acb8:	8e 68       	ld.sh	r8,r7[0xc]
8000acba:	ed b8 00 02 	bld	r8,0x2
8000acbe:	c0 91       	brne	8000acd0 <_fflush_r+0x9c>
8000acc0:	6e 18       	ld.w	r8,r7[0x4]
8000acc2:	10 15       	sub	r5,r8
8000acc4:	6e d8       	ld.w	r8,r7[0x34]
8000acc6:	58 08       	cp.w	r8,0
8000acc8:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000accc:	eb d8 e1 15 	subne	r5,r5,r8
8000acd0:	6e b8       	ld.w	r8,r7[0x2c]
8000acd2:	0c 9c       	mov	r12,r6
8000acd4:	30 09       	mov	r9,0
8000acd6:	0a 9a       	mov	r10,r5
8000acd8:	6e 8b       	ld.w	r11,r7[0x20]
8000acda:	5d 18       	icall	r8
8000acdc:	8e 68       	ld.sh	r8,r7[0xc]
8000acde:	0a 3c       	cp.w	r12,r5
8000ace0:	c2 61       	brne	8000ad2c <_fflush_r+0xf8>
8000ace2:	ab d8       	cbr	r8,0xb
8000ace4:	30 0c       	mov	r12,0
8000ace6:	6e 49       	ld.w	r9,r7[0x10]
8000ace8:	ae 68       	st.h	r7[0xc],r8
8000acea:	8f 1c       	st.w	r7[0x4],r12
8000acec:	8f 09       	st.w	r7[0x0],r9
8000acee:	ed b8 00 0c 	bld	r8,0xc
8000acf2:	c2 51       	brne	8000ad3c <_fflush_r+0x108>
8000acf4:	ef 45 00 54 	st.w	r7[84],r5
8000acf8:	d8 22       	popm	r4-r7,pc
8000acfa:	6e 45       	ld.w	r5,r7[0x10]
8000acfc:	58 05       	cp.w	r5,0
8000acfe:	c1 f0       	breq	8000ad3c <_fflush_r+0x108>
8000ad00:	6e 04       	ld.w	r4,r7[0x0]
8000ad02:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000ad06:	8f 05       	st.w	r7[0x0],r5
8000ad08:	f9 b8 01 00 	movne	r8,0
8000ad0c:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000ad10:	0a 14       	sub	r4,r5
8000ad12:	8f 28       	st.w	r7[0x8],r8
8000ad14:	c1 18       	rjmp	8000ad36 <_fflush_r+0x102>
8000ad16:	08 99       	mov	r9,r4
8000ad18:	0a 9a       	mov	r10,r5
8000ad1a:	6e a8       	ld.w	r8,r7[0x28]
8000ad1c:	6e 8b       	ld.w	r11,r7[0x20]
8000ad1e:	0c 9c       	mov	r12,r6
8000ad20:	5d 18       	icall	r8
8000ad22:	18 14       	sub	r4,r12
8000ad24:	58 0c       	cp.w	r12,0
8000ad26:	e0 89 00 07 	brgt	8000ad34 <_fflush_r+0x100>
8000ad2a:	8e 68       	ld.sh	r8,r7[0xc]
8000ad2c:	a7 a8       	sbr	r8,0x6
8000ad2e:	3f fc       	mov	r12,-1
8000ad30:	ae 68       	st.h	r7[0xc],r8
8000ad32:	d8 22       	popm	r4-r7,pc
8000ad34:	18 05       	add	r5,r12
8000ad36:	58 04       	cp.w	r4,0
8000ad38:	fe 99 ff ef 	brgt	8000ad16 <_fflush_r+0xe2>
8000ad3c:	d8 2a       	popm	r4-r7,pc,r12=0
8000ad3e:	d7 03       	nop

8000ad40 <__sfp_lock_acquire>:
8000ad40:	5e fc       	retal	r12

8000ad42 <__sfp_lock_release>:
8000ad42:	5e fc       	retal	r12

8000ad44 <_cleanup_r>:
8000ad44:	d4 01       	pushm	lr
8000ad46:	fe cb f0 ae 	sub	r11,pc,-3922
8000ad4a:	e0 a0 02 f7 	rcall	8000b338 <_fwalk>
8000ad4e:	d8 02       	popm	pc

8000ad50 <__sfmoreglue>:
8000ad50:	d4 21       	pushm	r4-r7,lr
8000ad52:	16 95       	mov	r5,r11
8000ad54:	f6 06 10 5c 	mul	r6,r11,92
8000ad58:	ec cb ff f4 	sub	r11,r6,-12
8000ad5c:	fe b0 e2 88 	rcall	8000726c <_malloc_r>
8000ad60:	18 97       	mov	r7,r12
8000ad62:	c0 90       	breq	8000ad74 <__sfmoreglue+0x24>
8000ad64:	99 15       	st.w	r12[0x4],r5
8000ad66:	30 0b       	mov	r11,0
8000ad68:	2f 4c       	sub	r12,-12
8000ad6a:	0c 9a       	mov	r10,r6
8000ad6c:	8f 2c       	st.w	r7[0x8],r12
8000ad6e:	8f 0b       	st.w	r7[0x0],r11
8000ad70:	fe b0 e5 3e 	rcall	800077ec <memset>
8000ad74:	0e 9c       	mov	r12,r7
8000ad76:	d8 22       	popm	r4-r7,pc

8000ad78 <__sfp>:
8000ad78:	d4 21       	pushm	r4-r7,lr
8000ad7a:	fe c8 ce 26 	sub	r8,pc,-12762
8000ad7e:	18 96       	mov	r6,r12
8000ad80:	70 07       	ld.w	r7,r8[0x0]
8000ad82:	6e 68       	ld.w	r8,r7[0x18]
8000ad84:	58 08       	cp.w	r8,0
8000ad86:	c0 31       	brne	8000ad8c <__sfp+0x14>
8000ad88:	0e 9c       	mov	r12,r7
8000ad8a:	c2 dc       	rcall	8000ade4 <__sinit>
8000ad8c:	ee c7 ff 28 	sub	r7,r7,-216
8000ad90:	30 05       	mov	r5,0
8000ad92:	6e 2c       	ld.w	r12,r7[0x8]
8000ad94:	6e 18       	ld.w	r8,r7[0x4]
8000ad96:	c0 68       	rjmp	8000ada2 <__sfp+0x2a>
8000ad98:	98 69       	ld.sh	r9,r12[0xc]
8000ad9a:	ea 09 19 00 	cp.h	r9,r5
8000ad9e:	c1 10       	breq	8000adc0 <__sfp+0x48>
8000ada0:	2a 4c       	sub	r12,-92
8000ada2:	20 18       	sub	r8,1
8000ada4:	cf a7       	brpl	8000ad98 <__sfp+0x20>
8000ada6:	6e 08       	ld.w	r8,r7[0x0]
8000ada8:	58 08       	cp.w	r8,0
8000adaa:	c0 61       	brne	8000adb6 <__sfp+0x3e>
8000adac:	30 4b       	mov	r11,4
8000adae:	0c 9c       	mov	r12,r6
8000adb0:	cd 0f       	rcall	8000ad50 <__sfmoreglue>
8000adb2:	8f 0c       	st.w	r7[0x0],r12
8000adb4:	c0 30       	breq	8000adba <__sfp+0x42>
8000adb6:	6e 07       	ld.w	r7,r7[0x0]
8000adb8:	ce db       	rjmp	8000ad92 <__sfp+0x1a>
8000adba:	30 c8       	mov	r8,12
8000adbc:	8d 38       	st.w	r6[0xc],r8
8000adbe:	d8 22       	popm	r4-r7,pc
8000adc0:	30 08       	mov	r8,0
8000adc2:	f9 48 00 4c 	st.w	r12[76],r8
8000adc6:	99 08       	st.w	r12[0x0],r8
8000adc8:	99 28       	st.w	r12[0x8],r8
8000adca:	99 18       	st.w	r12[0x4],r8
8000adcc:	99 48       	st.w	r12[0x10],r8
8000adce:	99 58       	st.w	r12[0x14],r8
8000add0:	99 68       	st.w	r12[0x18],r8
8000add2:	99 d8       	st.w	r12[0x34],r8
8000add4:	99 e8       	st.w	r12[0x38],r8
8000add6:	f9 48 00 48 	st.w	r12[72],r8
8000adda:	3f f8       	mov	r8,-1
8000addc:	b8 78       	st.h	r12[0xe],r8
8000adde:	30 18       	mov	r8,1
8000ade0:	b8 68       	st.h	r12[0xc],r8
8000ade2:	d8 22       	popm	r4-r7,pc

8000ade4 <__sinit>:
8000ade4:	d4 21       	pushm	r4-r7,lr
8000ade6:	18 96       	mov	r6,r12
8000ade8:	78 67       	ld.w	r7,r12[0x18]
8000adea:	58 07       	cp.w	r7,0
8000adec:	c4 91       	brne	8000ae7e <__sinit+0x9a>
8000adee:	fe c8 00 aa 	sub	r8,pc,170
8000adf2:	30 15       	mov	r5,1
8000adf4:	99 a8       	st.w	r12[0x28],r8
8000adf6:	f9 47 00 d8 	st.w	r12[216],r7
8000adfa:	f9 47 00 dc 	st.w	r12[220],r7
8000adfe:	f9 47 00 e0 	st.w	r12[224],r7
8000ae02:	99 65       	st.w	r12[0x18],r5
8000ae04:	cb af       	rcall	8000ad78 <__sfp>
8000ae06:	8d 0c       	st.w	r6[0x0],r12
8000ae08:	0c 9c       	mov	r12,r6
8000ae0a:	cb 7f       	rcall	8000ad78 <__sfp>
8000ae0c:	8d 1c       	st.w	r6[0x4],r12
8000ae0e:	0c 9c       	mov	r12,r6
8000ae10:	cb 4f       	rcall	8000ad78 <__sfp>
8000ae12:	6c 09       	ld.w	r9,r6[0x0]
8000ae14:	30 48       	mov	r8,4
8000ae16:	93 07       	st.w	r9[0x0],r7
8000ae18:	b2 68       	st.h	r9[0xc],r8
8000ae1a:	93 17       	st.w	r9[0x4],r7
8000ae1c:	93 27       	st.w	r9[0x8],r7
8000ae1e:	6c 18       	ld.w	r8,r6[0x4]
8000ae20:	b2 77       	st.h	r9[0xe],r7
8000ae22:	93 47       	st.w	r9[0x10],r7
8000ae24:	93 57       	st.w	r9[0x14],r7
8000ae26:	93 67       	st.w	r9[0x18],r7
8000ae28:	93 89       	st.w	r9[0x20],r9
8000ae2a:	91 07       	st.w	r8[0x0],r7
8000ae2c:	91 17       	st.w	r8[0x4],r7
8000ae2e:	91 27       	st.w	r8[0x8],r7
8000ae30:	fe ce f3 24 	sub	lr,pc,-3292
8000ae34:	fe cb f3 54 	sub	r11,pc,-3244
8000ae38:	93 9e       	st.w	r9[0x24],lr
8000ae3a:	93 ab       	st.w	r9[0x28],r11
8000ae3c:	fe ca f3 7c 	sub	r10,pc,-3204
8000ae40:	fe c4 f3 88 	sub	r4,pc,-3192
8000ae44:	93 ba       	st.w	r9[0x2c],r10
8000ae46:	93 c4       	st.w	r9[0x30],r4
8000ae48:	30 99       	mov	r9,9
8000ae4a:	b0 69       	st.h	r8[0xc],r9
8000ae4c:	b0 75       	st.h	r8[0xe],r5
8000ae4e:	91 c4       	st.w	r8[0x30],r4
8000ae50:	91 47       	st.w	r8[0x10],r7
8000ae52:	91 57       	st.w	r8[0x14],r7
8000ae54:	91 67       	st.w	r8[0x18],r7
8000ae56:	91 88       	st.w	r8[0x20],r8
8000ae58:	91 9e       	st.w	r8[0x24],lr
8000ae5a:	91 ab       	st.w	r8[0x28],r11
8000ae5c:	91 ba       	st.w	r8[0x2c],r10
8000ae5e:	8d 2c       	st.w	r6[0x8],r12
8000ae60:	31 28       	mov	r8,18
8000ae62:	99 07       	st.w	r12[0x0],r7
8000ae64:	b8 68       	st.h	r12[0xc],r8
8000ae66:	99 17       	st.w	r12[0x4],r7
8000ae68:	99 27       	st.w	r12[0x8],r7
8000ae6a:	30 28       	mov	r8,2
8000ae6c:	b8 78       	st.h	r12[0xe],r8
8000ae6e:	99 c4       	st.w	r12[0x30],r4
8000ae70:	99 67       	st.w	r12[0x18],r7
8000ae72:	99 9e       	st.w	r12[0x24],lr
8000ae74:	99 ab       	st.w	r12[0x28],r11
8000ae76:	99 ba       	st.w	r12[0x2c],r10
8000ae78:	99 47       	st.w	r12[0x10],r7
8000ae7a:	99 57       	st.w	r12[0x14],r7
8000ae7c:	99 8c       	st.w	r12[0x20],r12
8000ae7e:	d8 22       	popm	r4-r7,pc

8000ae80 <_malloc_trim_r>:
8000ae80:	d4 21       	pushm	r4-r7,lr
8000ae82:	16 95       	mov	r5,r11
8000ae84:	18 97       	mov	r7,r12
8000ae86:	fe b0 d7 d9 	rcall	80005e38 <__malloc_lock>
8000ae8a:	e0 64 05 3c 	mov	r4,1340
8000ae8e:	68 28       	ld.w	r8,r4[0x8]
8000ae90:	70 16       	ld.w	r6,r8[0x4]
8000ae92:	e0 16 ff fc 	andl	r6,0xfffc
8000ae96:	ec c8 ff 91 	sub	r8,r6,-111
8000ae9a:	f0 05 01 05 	sub	r5,r8,r5
8000ae9e:	e0 15 ff 80 	andl	r5,0xff80
8000aea2:	ea c5 00 80 	sub	r5,r5,128
8000aea6:	e0 45 00 7f 	cp.w	r5,127
8000aeaa:	e0 8a 00 25 	brle	8000aef4 <_malloc_trim_r+0x74>
8000aeae:	30 0b       	mov	r11,0
8000aeb0:	0e 9c       	mov	r12,r7
8000aeb2:	fe b0 e6 05 	rcall	80007abc <_sbrk_r>
8000aeb6:	68 28       	ld.w	r8,r4[0x8]
8000aeb8:	0c 08       	add	r8,r6
8000aeba:	10 3c       	cp.w	r12,r8
8000aebc:	c1 c1       	brne	8000aef4 <_malloc_trim_r+0x74>
8000aebe:	ea 0b 11 00 	rsub	r11,r5,0
8000aec2:	0e 9c       	mov	r12,r7
8000aec4:	fe b0 e5 fc 	rcall	80007abc <_sbrk_r>
8000aec8:	5b fc       	cp.w	r12,-1
8000aeca:	c1 91       	brne	8000aefc <_malloc_trim_r+0x7c>
8000aecc:	30 0b       	mov	r11,0
8000aece:	0e 9c       	mov	r12,r7
8000aed0:	fe b0 e5 f6 	rcall	80007abc <_sbrk_r>
8000aed4:	68 28       	ld.w	r8,r4[0x8]
8000aed6:	f8 08 01 09 	sub	r9,r12,r8
8000aeda:	58 f9       	cp.w	r9,15
8000aedc:	e0 8a 00 0c 	brle	8000aef4 <_malloc_trim_r+0x74>
8000aee0:	a1 a9       	sbr	r9,0x0
8000aee2:	91 19       	st.w	r8[0x4],r9
8000aee4:	e0 68 09 48 	mov	r8,2376
8000aee8:	70 09       	ld.w	r9,r8[0x0]
8000aeea:	e0 68 0d 6c 	mov	r8,3436
8000aeee:	f8 09 01 09 	sub	r9,r12,r9
8000aef2:	91 09       	st.w	r8[0x0],r9
8000aef4:	0e 9c       	mov	r12,r7
8000aef6:	fe b0 d7 a7 	rcall	80005e44 <__malloc_unlock>
8000aefa:	d8 2a       	popm	r4-r7,pc,r12=0
8000aefc:	68 28       	ld.w	r8,r4[0x8]
8000aefe:	0a 16       	sub	r6,r5
8000af00:	a1 a6       	sbr	r6,0x0
8000af02:	91 16       	st.w	r8[0x4],r6
8000af04:	e0 68 0d 6c 	mov	r8,3436
8000af08:	70 09       	ld.w	r9,r8[0x0]
8000af0a:	0a 19       	sub	r9,r5
8000af0c:	0e 9c       	mov	r12,r7
8000af0e:	91 09       	st.w	r8[0x0],r9
8000af10:	fe b0 d7 9a 	rcall	80005e44 <__malloc_unlock>
8000af14:	da 2a       	popm	r4-r7,pc,r12=1
8000af16:	d7 03       	nop

8000af18 <_free_r>:
8000af18:	d4 21       	pushm	r4-r7,lr
8000af1a:	16 96       	mov	r6,r11
8000af1c:	18 97       	mov	r7,r12
8000af1e:	58 0b       	cp.w	r11,0
8000af20:	e0 80 00 c0 	breq	8000b0a0 <_free_r+0x188>
8000af24:	fe b0 d7 8a 	rcall	80005e38 <__malloc_lock>
8000af28:	20 86       	sub	r6,8
8000af2a:	e0 6a 05 3c 	mov	r10,1340
8000af2e:	6c 18       	ld.w	r8,r6[0x4]
8000af30:	74 2e       	ld.w	lr,r10[0x8]
8000af32:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000af36:	a1 c8       	cbr	r8,0x0
8000af38:	ec 08 00 09 	add	r9,r6,r8
8000af3c:	72 1b       	ld.w	r11,r9[0x4]
8000af3e:	e0 1b ff fc 	andl	r11,0xfffc
8000af42:	1c 39       	cp.w	r9,lr
8000af44:	c1 e1       	brne	8000af80 <_free_r+0x68>
8000af46:	f6 08 00 08 	add	r8,r11,r8
8000af4a:	58 0c       	cp.w	r12,0
8000af4c:	c0 81       	brne	8000af5c <_free_r+0x44>
8000af4e:	6c 09       	ld.w	r9,r6[0x0]
8000af50:	12 16       	sub	r6,r9
8000af52:	12 08       	add	r8,r9
8000af54:	6c 3b       	ld.w	r11,r6[0xc]
8000af56:	6c 29       	ld.w	r9,r6[0x8]
8000af58:	97 29       	st.w	r11[0x8],r9
8000af5a:	93 3b       	st.w	r9[0xc],r11
8000af5c:	10 99       	mov	r9,r8
8000af5e:	95 26       	st.w	r10[0x8],r6
8000af60:	a1 a9       	sbr	r9,0x0
8000af62:	8d 19       	st.w	r6[0x4],r9
8000af64:	e0 69 09 44 	mov	r9,2372
8000af68:	72 09       	ld.w	r9,r9[0x0]
8000af6a:	12 38       	cp.w	r8,r9
8000af6c:	c0 63       	brcs	8000af78 <_free_r+0x60>
8000af6e:	e0 68 0d 68 	mov	r8,3432
8000af72:	0e 9c       	mov	r12,r7
8000af74:	70 0b       	ld.w	r11,r8[0x0]
8000af76:	c8 5f       	rcall	8000ae80 <_malloc_trim_r>
8000af78:	0e 9c       	mov	r12,r7
8000af7a:	fe b0 d7 65 	rcall	80005e44 <__malloc_unlock>
8000af7e:	d8 22       	popm	r4-r7,pc
8000af80:	93 1b       	st.w	r9[0x4],r11
8000af82:	58 0c       	cp.w	r12,0
8000af84:	c0 30       	breq	8000af8a <_free_r+0x72>
8000af86:	30 0c       	mov	r12,0
8000af88:	c1 08       	rjmp	8000afa8 <_free_r+0x90>
8000af8a:	6c 0e       	ld.w	lr,r6[0x0]
8000af8c:	f4 c5 ff f8 	sub	r5,r10,-8
8000af90:	1c 16       	sub	r6,lr
8000af92:	1c 08       	add	r8,lr
8000af94:	6c 2e       	ld.w	lr,r6[0x8]
8000af96:	0a 3e       	cp.w	lr,r5
8000af98:	f9 bc 00 01 	moveq	r12,1
8000af9c:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000afa0:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000afa4:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000afa8:	f2 0b 00 0e 	add	lr,r9,r11
8000afac:	7c 1e       	ld.w	lr,lr[0x4]
8000afae:	ed be 00 00 	bld	lr,0x0
8000afb2:	c1 40       	breq	8000afda <_free_r+0xc2>
8000afb4:	16 08       	add	r8,r11
8000afb6:	58 0c       	cp.w	r12,0
8000afb8:	c0 d1       	brne	8000afd2 <_free_r+0xba>
8000afba:	e0 6e 05 3c 	mov	lr,1340
8000afbe:	72 2b       	ld.w	r11,r9[0x8]
8000afc0:	2f 8e       	sub	lr,-8
8000afc2:	1c 3b       	cp.w	r11,lr
8000afc4:	c0 71       	brne	8000afd2 <_free_r+0xba>
8000afc6:	97 36       	st.w	r11[0xc],r6
8000afc8:	97 26       	st.w	r11[0x8],r6
8000afca:	8d 2b       	st.w	r6[0x8],r11
8000afcc:	8d 3b       	st.w	r6[0xc],r11
8000afce:	30 1c       	mov	r12,1
8000afd0:	c0 58       	rjmp	8000afda <_free_r+0xc2>
8000afd2:	72 2b       	ld.w	r11,r9[0x8]
8000afd4:	72 39       	ld.w	r9,r9[0xc]
8000afd6:	93 2b       	st.w	r9[0x8],r11
8000afd8:	97 39       	st.w	r11[0xc],r9
8000afda:	10 99       	mov	r9,r8
8000afdc:	ec 08 09 08 	st.w	r6[r8],r8
8000afe0:	a1 a9       	sbr	r9,0x0
8000afe2:	8d 19       	st.w	r6[0x4],r9
8000afe4:	58 0c       	cp.w	r12,0
8000afe6:	c5 a1       	brne	8000b09a <_free_r+0x182>
8000afe8:	e0 48 01 ff 	cp.w	r8,511
8000afec:	e0 8b 00 13 	brhi	8000b012 <_free_r+0xfa>
8000aff0:	a3 98       	lsr	r8,0x3
8000aff2:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000aff6:	72 2b       	ld.w	r11,r9[0x8]
8000aff8:	8d 39       	st.w	r6[0xc],r9
8000affa:	8d 2b       	st.w	r6[0x8],r11
8000affc:	97 36       	st.w	r11[0xc],r6
8000affe:	93 26       	st.w	r9[0x8],r6
8000b000:	a3 48       	asr	r8,0x2
8000b002:	74 19       	ld.w	r9,r10[0x4]
8000b004:	30 1b       	mov	r11,1
8000b006:	f6 08 09 48 	lsl	r8,r11,r8
8000b00a:	f3 e8 10 08 	or	r8,r9,r8
8000b00e:	95 18       	st.w	r10[0x4],r8
8000b010:	c4 58       	rjmp	8000b09a <_free_r+0x182>
8000b012:	f0 0b 16 09 	lsr	r11,r8,0x9
8000b016:	58 4b       	cp.w	r11,4
8000b018:	e0 8b 00 06 	brhi	8000b024 <_free_r+0x10c>
8000b01c:	f0 0b 16 06 	lsr	r11,r8,0x6
8000b020:	2c 8b       	sub	r11,-56
8000b022:	c2 08       	rjmp	8000b062 <_free_r+0x14a>
8000b024:	59 4b       	cp.w	r11,20
8000b026:	e0 8b 00 04 	brhi	8000b02e <_free_r+0x116>
8000b02a:	2a 5b       	sub	r11,-91
8000b02c:	c1 b8       	rjmp	8000b062 <_free_r+0x14a>
8000b02e:	e0 4b 00 54 	cp.w	r11,84
8000b032:	e0 8b 00 06 	brhi	8000b03e <_free_r+0x126>
8000b036:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000b03a:	29 2b       	sub	r11,-110
8000b03c:	c1 38       	rjmp	8000b062 <_free_r+0x14a>
8000b03e:	e0 4b 01 54 	cp.w	r11,340
8000b042:	e0 8b 00 06 	brhi	8000b04e <_free_r+0x136>
8000b046:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000b04a:	28 9b       	sub	r11,-119
8000b04c:	c0 b8       	rjmp	8000b062 <_free_r+0x14a>
8000b04e:	e0 4b 05 54 	cp.w	r11,1364
8000b052:	e0 88 00 05 	brls	8000b05c <_free_r+0x144>
8000b056:	37 eb       	mov	r11,126
8000b058:	c0 58       	rjmp	8000b062 <_free_r+0x14a>
8000b05a:	d7 03       	nop
8000b05c:	f0 0b 16 12 	lsr	r11,r8,0x12
8000b060:	28 4b       	sub	r11,-124
8000b062:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000b066:	78 29       	ld.w	r9,r12[0x8]
8000b068:	18 39       	cp.w	r9,r12
8000b06a:	c0 e1       	brne	8000b086 <_free_r+0x16e>
8000b06c:	74 18       	ld.w	r8,r10[0x4]
8000b06e:	a3 4b       	asr	r11,0x2
8000b070:	30 1c       	mov	r12,1
8000b072:	f8 0b 09 4b 	lsl	r11,r12,r11
8000b076:	f1 eb 10 0b 	or	r11,r8,r11
8000b07a:	12 98       	mov	r8,r9
8000b07c:	95 1b       	st.w	r10[0x4],r11
8000b07e:	c0 a8       	rjmp	8000b092 <_free_r+0x17a>
8000b080:	72 29       	ld.w	r9,r9[0x8]
8000b082:	18 39       	cp.w	r9,r12
8000b084:	c0 60       	breq	8000b090 <_free_r+0x178>
8000b086:	72 1a       	ld.w	r10,r9[0x4]
8000b088:	e0 1a ff fc 	andl	r10,0xfffc
8000b08c:	14 38       	cp.w	r8,r10
8000b08e:	cf 93       	brcs	8000b080 <_free_r+0x168>
8000b090:	72 38       	ld.w	r8,r9[0xc]
8000b092:	8d 38       	st.w	r6[0xc],r8
8000b094:	8d 29       	st.w	r6[0x8],r9
8000b096:	93 36       	st.w	r9[0xc],r6
8000b098:	91 26       	st.w	r8[0x8],r6
8000b09a:	0e 9c       	mov	r12,r7
8000b09c:	fe b0 d6 d4 	rcall	80005e44 <__malloc_unlock>
8000b0a0:	d8 22       	popm	r4-r7,pc
8000b0a2:	d7 03       	nop

8000b0a4 <__sfvwrite_r>:
8000b0a4:	d4 31       	pushm	r0-r7,lr
8000b0a6:	20 3d       	sub	sp,12
8000b0a8:	14 94       	mov	r4,r10
8000b0aa:	18 95       	mov	r5,r12
8000b0ac:	16 97       	mov	r7,r11
8000b0ae:	74 28       	ld.w	r8,r10[0x8]
8000b0b0:	58 08       	cp.w	r8,0
8000b0b2:	e0 80 01 40 	breq	8000b332 <__sfvwrite_r+0x28e>
8000b0b6:	96 68       	ld.sh	r8,r11[0xc]
8000b0b8:	ed b8 00 03 	bld	r8,0x3
8000b0bc:	c0 41       	brne	8000b0c4 <__sfvwrite_r+0x20>
8000b0be:	76 48       	ld.w	r8,r11[0x10]
8000b0c0:	58 08       	cp.w	r8,0
8000b0c2:	c0 c1       	brne	8000b0da <__sfvwrite_r+0x36>
8000b0c4:	0e 9b       	mov	r11,r7
8000b0c6:	0a 9c       	mov	r12,r5
8000b0c8:	fe b0 f6 c4 	rcall	80009e50 <__swsetup_r>
8000b0cc:	c0 70       	breq	8000b0da <__sfvwrite_r+0x36>
8000b0ce:	8e 68       	ld.sh	r8,r7[0xc]
8000b0d0:	a7 a8       	sbr	r8,0x6
8000b0d2:	ae 68       	st.h	r7[0xc],r8
8000b0d4:	30 98       	mov	r8,9
8000b0d6:	8b 38       	st.w	r5[0xc],r8
8000b0d8:	c2 b9       	rjmp	8000b32e <__sfvwrite_r+0x28a>
8000b0da:	8e 63       	ld.sh	r3,r7[0xc]
8000b0dc:	68 00       	ld.w	r0,r4[0x0]
8000b0de:	06 96       	mov	r6,r3
8000b0e0:	e2 16 00 02 	andl	r6,0x2,COH
8000b0e4:	c2 10       	breq	8000b126 <__sfvwrite_r+0x82>
8000b0e6:	30 03       	mov	r3,0
8000b0e8:	e0 62 04 00 	mov	r2,1024
8000b0ec:	06 96       	mov	r6,r3
8000b0ee:	c0 48       	rjmp	8000b0f6 <__sfvwrite_r+0x52>
8000b0f0:	60 03       	ld.w	r3,r0[0x0]
8000b0f2:	60 16       	ld.w	r6,r0[0x4]
8000b0f4:	2f 80       	sub	r0,-8
8000b0f6:	58 06       	cp.w	r6,0
8000b0f8:	cf c0       	breq	8000b0f0 <__sfvwrite_r+0x4c>
8000b0fa:	e0 46 04 00 	cp.w	r6,1024
8000b0fe:	ec 09 17 80 	movls	r9,r6
8000b102:	e4 09 17 b0 	movhi	r9,r2
8000b106:	06 9a       	mov	r10,r3
8000b108:	6e a8       	ld.w	r8,r7[0x28]
8000b10a:	6e 8b       	ld.w	r11,r7[0x20]
8000b10c:	0a 9c       	mov	r12,r5
8000b10e:	5d 18       	icall	r8
8000b110:	18 16       	sub	r6,r12
8000b112:	58 0c       	cp.w	r12,0
8000b114:	e0 8a 01 0a 	brle	8000b328 <__sfvwrite_r+0x284>
8000b118:	68 28       	ld.w	r8,r4[0x8]
8000b11a:	18 18       	sub	r8,r12
8000b11c:	89 28       	st.w	r4[0x8],r8
8000b11e:	e0 80 01 0a 	breq	8000b332 <__sfvwrite_r+0x28e>
8000b122:	18 03       	add	r3,r12
8000b124:	ce 9b       	rjmp	8000b0f6 <__sfvwrite_r+0x52>
8000b126:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000b12a:	c0 70       	breq	8000b138 <__sfvwrite_r+0x94>
8000b12c:	50 06       	stdsp	sp[0x0],r6
8000b12e:	0c 93       	mov	r3,r6
8000b130:	0c 91       	mov	r1,r6
8000b132:	50 15       	stdsp	sp[0x4],r5
8000b134:	08 92       	mov	r2,r4
8000b136:	c9 c8       	rjmp	8000b26e <__sfvwrite_r+0x1ca>
8000b138:	06 96       	mov	r6,r3
8000b13a:	08 91       	mov	r1,r4
8000b13c:	c0 48       	rjmp	8000b144 <__sfvwrite_r+0xa0>
8000b13e:	60 03       	ld.w	r3,r0[0x0]
8000b140:	60 16       	ld.w	r6,r0[0x4]
8000b142:	2f 80       	sub	r0,-8
8000b144:	58 06       	cp.w	r6,0
8000b146:	cf c0       	breq	8000b13e <__sfvwrite_r+0x9a>
8000b148:	8e 68       	ld.sh	r8,r7[0xc]
8000b14a:	6e 24       	ld.w	r4,r7[0x8]
8000b14c:	10 99       	mov	r9,r8
8000b14e:	e2 19 02 00 	andl	r9,0x200,COH
8000b152:	c5 50       	breq	8000b1fc <__sfvwrite_r+0x158>
8000b154:	08 36       	cp.w	r6,r4
8000b156:	c4 43       	brcs	8000b1de <__sfvwrite_r+0x13a>
8000b158:	10 99       	mov	r9,r8
8000b15a:	e2 19 04 80 	andl	r9,0x480,COH
8000b15e:	c4 00       	breq	8000b1de <__sfvwrite_r+0x13a>
8000b160:	6e 4b       	ld.w	r11,r7[0x10]
8000b162:	6e 09       	ld.w	r9,r7[0x0]
8000b164:	16 19       	sub	r9,r11
8000b166:	50 09       	stdsp	sp[0x0],r9
8000b168:	6e 59       	ld.w	r9,r7[0x14]
8000b16a:	10 9c       	mov	r12,r8
8000b16c:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000b170:	30 28       	mov	r8,2
8000b172:	f4 08 0c 08 	divs	r8,r10,r8
8000b176:	fa e9 00 04 	st.d	sp[4],r8
8000b17a:	10 94       	mov	r4,r8
8000b17c:	40 09       	lddsp	r9,sp[0x0]
8000b17e:	e2 1c 04 00 	andl	r12,0x400,COH
8000b182:	2f f9       	sub	r9,-1
8000b184:	0c 09       	add	r9,r6
8000b186:	12 38       	cp.w	r8,r9
8000b188:	f2 04 17 30 	movlo	r4,r9
8000b18c:	58 0c       	cp.w	r12,0
8000b18e:	c1 10       	breq	8000b1b0 <__sfvwrite_r+0x10c>
8000b190:	08 9b       	mov	r11,r4
8000b192:	0a 9c       	mov	r12,r5
8000b194:	fe b0 e0 6c 	rcall	8000726c <_malloc_r>
8000b198:	18 92       	mov	r2,r12
8000b19a:	c1 40       	breq	8000b1c2 <__sfvwrite_r+0x11e>
8000b19c:	40 0a       	lddsp	r10,sp[0x0]
8000b19e:	6e 4b       	ld.w	r11,r7[0x10]
8000b1a0:	fe b0 e2 82 	rcall	800076a4 <memcpy>
8000b1a4:	8e 68       	ld.sh	r8,r7[0xc]
8000b1a6:	e0 18 fb 7f 	andl	r8,0xfb7f
8000b1aa:	a7 b8       	sbr	r8,0x7
8000b1ac:	ae 68       	st.h	r7[0xc],r8
8000b1ae:	c0 d8       	rjmp	8000b1c8 <__sfvwrite_r+0x124>
8000b1b0:	08 9a       	mov	r10,r4
8000b1b2:	0a 9c       	mov	r12,r5
8000b1b4:	fe b0 e3 24 	rcall	800077fc <_realloc_r>
8000b1b8:	18 92       	mov	r2,r12
8000b1ba:	c0 71       	brne	8000b1c8 <__sfvwrite_r+0x124>
8000b1bc:	6e 4b       	ld.w	r11,r7[0x10]
8000b1be:	0a 9c       	mov	r12,r5
8000b1c0:	ca ce       	rcall	8000af18 <_free_r>
8000b1c2:	30 c8       	mov	r8,12
8000b1c4:	8b 38       	st.w	r5[0xc],r8
8000b1c6:	cb 18       	rjmp	8000b328 <__sfvwrite_r+0x284>
8000b1c8:	40 0a       	lddsp	r10,sp[0x0]
8000b1ca:	40 09       	lddsp	r9,sp[0x0]
8000b1cc:	e8 0a 01 0a 	sub	r10,r4,r10
8000b1d0:	e4 09 00 08 	add	r8,r2,r9
8000b1d4:	8f 54       	st.w	r7[0x14],r4
8000b1d6:	8f 2a       	st.w	r7[0x8],r10
8000b1d8:	8f 08       	st.w	r7[0x0],r8
8000b1da:	8f 42       	st.w	r7[0x10],r2
8000b1dc:	0c 94       	mov	r4,r6
8000b1de:	08 36       	cp.w	r6,r4
8000b1e0:	ec 04 17 30 	movlo	r4,r6
8000b1e4:	06 9b       	mov	r11,r3
8000b1e6:	08 9a       	mov	r10,r4
8000b1e8:	6e 0c       	ld.w	r12,r7[0x0]
8000b1ea:	c3 ad       	rcall	8000b45e <memmove>
8000b1ec:	6e 08       	ld.w	r8,r7[0x0]
8000b1ee:	08 08       	add	r8,r4
8000b1f0:	8f 08       	st.w	r7[0x0],r8
8000b1f2:	6e 28       	ld.w	r8,r7[0x8]
8000b1f4:	08 18       	sub	r8,r4
8000b1f6:	0c 94       	mov	r4,r6
8000b1f8:	8f 28       	st.w	r7[0x8],r8
8000b1fa:	c2 e8       	rjmp	8000b256 <__sfvwrite_r+0x1b2>
8000b1fc:	08 36       	cp.w	r6,r4
8000b1fe:	5f ba       	srhi	r10
8000b200:	6e 0c       	ld.w	r12,r7[0x0]
8000b202:	6e 48       	ld.w	r8,r7[0x10]
8000b204:	10 3c       	cp.w	r12,r8
8000b206:	5f b8       	srhi	r8
8000b208:	f5 e8 00 08 	and	r8,r10,r8
8000b20c:	f2 08 18 00 	cp.b	r8,r9
8000b210:	c0 d0       	breq	8000b22a <__sfvwrite_r+0x186>
8000b212:	06 9b       	mov	r11,r3
8000b214:	08 9a       	mov	r10,r4
8000b216:	c2 4d       	rcall	8000b45e <memmove>
8000b218:	6e 08       	ld.w	r8,r7[0x0]
8000b21a:	08 08       	add	r8,r4
8000b21c:	0e 9b       	mov	r11,r7
8000b21e:	8f 08       	st.w	r7[0x0],r8
8000b220:	0a 9c       	mov	r12,r5
8000b222:	fe b0 fd 09 	rcall	8000ac34 <_fflush_r>
8000b226:	c1 80       	breq	8000b256 <__sfvwrite_r+0x1b2>
8000b228:	c8 08       	rjmp	8000b328 <__sfvwrite_r+0x284>
8000b22a:	6e 59       	ld.w	r9,r7[0x14]
8000b22c:	12 36       	cp.w	r6,r9
8000b22e:	c0 a3       	brcs	8000b242 <__sfvwrite_r+0x19e>
8000b230:	6e a8       	ld.w	r8,r7[0x28]
8000b232:	06 9a       	mov	r10,r3
8000b234:	6e 8b       	ld.w	r11,r7[0x20]
8000b236:	0a 9c       	mov	r12,r5
8000b238:	5d 18       	icall	r8
8000b23a:	18 94       	mov	r4,r12
8000b23c:	e0 89 00 0d 	brgt	8000b256 <__sfvwrite_r+0x1b2>
8000b240:	c7 48       	rjmp	8000b328 <__sfvwrite_r+0x284>
8000b242:	0c 9a       	mov	r10,r6
8000b244:	06 9b       	mov	r11,r3
8000b246:	c0 cd       	rcall	8000b45e <memmove>
8000b248:	6e 08       	ld.w	r8,r7[0x0]
8000b24a:	0c 08       	add	r8,r6
8000b24c:	0c 94       	mov	r4,r6
8000b24e:	8f 08       	st.w	r7[0x0],r8
8000b250:	6e 28       	ld.w	r8,r7[0x8]
8000b252:	0c 18       	sub	r8,r6
8000b254:	8f 28       	st.w	r7[0x8],r8
8000b256:	62 28       	ld.w	r8,r1[0x8]
8000b258:	08 18       	sub	r8,r4
8000b25a:	83 28       	st.w	r1[0x8],r8
8000b25c:	c6 b0       	breq	8000b332 <__sfvwrite_r+0x28e>
8000b25e:	08 16       	sub	r6,r4
8000b260:	08 03       	add	r3,r4
8000b262:	c7 1b       	rjmp	8000b144 <__sfvwrite_r+0xa0>
8000b264:	60 03       	ld.w	r3,r0[0x0]
8000b266:	60 11       	ld.w	r1,r0[0x4]
8000b268:	30 08       	mov	r8,0
8000b26a:	2f 80       	sub	r0,-8
8000b26c:	50 08       	stdsp	sp[0x0],r8
8000b26e:	58 01       	cp.w	r1,0
8000b270:	cf a0       	breq	8000b264 <__sfvwrite_r+0x1c0>
8000b272:	40 0a       	lddsp	r10,sp[0x0]
8000b274:	58 0a       	cp.w	r10,0
8000b276:	c1 41       	brne	8000b29e <__sfvwrite_r+0x1fa>
8000b278:	e2 c6 ff ff 	sub	r6,r1,-1
8000b27c:	02 9a       	mov	r10,r1
8000b27e:	30 ab       	mov	r11,10
8000b280:	06 9c       	mov	r12,r3
8000b282:	ce 3c       	rcall	8000b448 <memchr>
8000b284:	f8 c8 ff ff 	sub	r8,r12,-1
8000b288:	58 0c       	cp.w	r12,0
8000b28a:	f1 d3 e1 16 	subne	r6,r8,r3
8000b28e:	f9 b9 01 01 	movne	r9,1
8000b292:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b296:	f9 b8 00 01 	moveq	r8,1
8000b29a:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b29e:	02 36       	cp.w	r6,r1
8000b2a0:	ec 04 17 80 	movls	r4,r6
8000b2a4:	e2 04 17 b0 	movhi	r4,r1
8000b2a8:	6e 59       	ld.w	r9,r7[0x14]
8000b2aa:	6e 25       	ld.w	r5,r7[0x8]
8000b2ac:	f2 05 00 05 	add	r5,r9,r5
8000b2b0:	0a 34       	cp.w	r4,r5
8000b2b2:	5f 9a       	srgt	r10
8000b2b4:	6e 0c       	ld.w	r12,r7[0x0]
8000b2b6:	6e 48       	ld.w	r8,r7[0x10]
8000b2b8:	10 3c       	cp.w	r12,r8
8000b2ba:	5f b8       	srhi	r8
8000b2bc:	f5 e8 00 08 	and	r8,r10,r8
8000b2c0:	30 0a       	mov	r10,0
8000b2c2:	f4 08 18 00 	cp.b	r8,r10
8000b2c6:	c0 d0       	breq	8000b2e0 <__sfvwrite_r+0x23c>
8000b2c8:	06 9b       	mov	r11,r3
8000b2ca:	0a 9a       	mov	r10,r5
8000b2cc:	cc 9c       	rcall	8000b45e <memmove>
8000b2ce:	6e 08       	ld.w	r8,r7[0x0]
8000b2d0:	0a 08       	add	r8,r5
8000b2d2:	0e 9b       	mov	r11,r7
8000b2d4:	8f 08       	st.w	r7[0x0],r8
8000b2d6:	40 1c       	lddsp	r12,sp[0x4]
8000b2d8:	fe b0 fc ae 	rcall	8000ac34 <_fflush_r>
8000b2dc:	c1 70       	breq	8000b30a <__sfvwrite_r+0x266>
8000b2de:	c2 58       	rjmp	8000b328 <__sfvwrite_r+0x284>
8000b2e0:	12 34       	cp.w	r4,r9
8000b2e2:	c0 a5       	brlt	8000b2f6 <__sfvwrite_r+0x252>
8000b2e4:	6e a8       	ld.w	r8,r7[0x28]
8000b2e6:	06 9a       	mov	r10,r3
8000b2e8:	6e 8b       	ld.w	r11,r7[0x20]
8000b2ea:	40 1c       	lddsp	r12,sp[0x4]
8000b2ec:	5d 18       	icall	r8
8000b2ee:	18 95       	mov	r5,r12
8000b2f0:	e0 89 00 0d 	brgt	8000b30a <__sfvwrite_r+0x266>
8000b2f4:	c1 a8       	rjmp	8000b328 <__sfvwrite_r+0x284>
8000b2f6:	08 9a       	mov	r10,r4
8000b2f8:	06 9b       	mov	r11,r3
8000b2fa:	cb 2c       	rcall	8000b45e <memmove>
8000b2fc:	6e 08       	ld.w	r8,r7[0x0]
8000b2fe:	08 08       	add	r8,r4
8000b300:	08 95       	mov	r5,r4
8000b302:	8f 08       	st.w	r7[0x0],r8
8000b304:	6e 28       	ld.w	r8,r7[0x8]
8000b306:	08 18       	sub	r8,r4
8000b308:	8f 28       	st.w	r7[0x8],r8
8000b30a:	0a 16       	sub	r6,r5
8000b30c:	c0 71       	brne	8000b31a <__sfvwrite_r+0x276>
8000b30e:	0e 9b       	mov	r11,r7
8000b310:	40 1c       	lddsp	r12,sp[0x4]
8000b312:	fe b0 fc 91 	rcall	8000ac34 <_fflush_r>
8000b316:	c0 91       	brne	8000b328 <__sfvwrite_r+0x284>
8000b318:	50 06       	stdsp	sp[0x0],r6
8000b31a:	64 28       	ld.w	r8,r2[0x8]
8000b31c:	0a 18       	sub	r8,r5
8000b31e:	85 28       	st.w	r2[0x8],r8
8000b320:	c0 90       	breq	8000b332 <__sfvwrite_r+0x28e>
8000b322:	0a 11       	sub	r1,r5
8000b324:	0a 03       	add	r3,r5
8000b326:	ca 4b       	rjmp	8000b26e <__sfvwrite_r+0x1ca>
8000b328:	8e 68       	ld.sh	r8,r7[0xc]
8000b32a:	a7 a8       	sbr	r8,0x6
8000b32c:	ae 68       	st.h	r7[0xc],r8
8000b32e:	3f fc       	mov	r12,-1
8000b330:	c0 28       	rjmp	8000b334 <__sfvwrite_r+0x290>
8000b332:	30 0c       	mov	r12,0
8000b334:	2f dd       	sub	sp,-12
8000b336:	d8 32       	popm	r0-r7,pc

8000b338 <_fwalk>:
8000b338:	d4 31       	pushm	r0-r7,lr
8000b33a:	30 05       	mov	r5,0
8000b33c:	16 91       	mov	r1,r11
8000b33e:	f8 c7 ff 28 	sub	r7,r12,-216
8000b342:	0a 92       	mov	r2,r5
8000b344:	fe b0 fc fe 	rcall	8000ad40 <__sfp_lock_acquire>
8000b348:	3f f3       	mov	r3,-1
8000b34a:	c1 68       	rjmp	8000b376 <_fwalk+0x3e>
8000b34c:	6e 26       	ld.w	r6,r7[0x8]
8000b34e:	6e 14       	ld.w	r4,r7[0x4]
8000b350:	2f 46       	sub	r6,-12
8000b352:	c0 c8       	rjmp	8000b36a <_fwalk+0x32>
8000b354:	8c 08       	ld.sh	r8,r6[0x0]
8000b356:	e4 08 19 00 	cp.h	r8,r2
8000b35a:	c0 70       	breq	8000b368 <_fwalk+0x30>
8000b35c:	8c 18       	ld.sh	r8,r6[0x2]
8000b35e:	e6 08 19 00 	cp.h	r8,r3
8000b362:	c0 30       	breq	8000b368 <_fwalk+0x30>
8000b364:	5d 11       	icall	r1
8000b366:	18 45       	or	r5,r12
8000b368:	2a 46       	sub	r6,-92
8000b36a:	20 14       	sub	r4,1
8000b36c:	ec cc 00 0c 	sub	r12,r6,12
8000b370:	58 04       	cp.w	r4,0
8000b372:	cf 14       	brge	8000b354 <_fwalk+0x1c>
8000b374:	6e 07       	ld.w	r7,r7[0x0]
8000b376:	58 07       	cp.w	r7,0
8000b378:	ce a1       	brne	8000b34c <_fwalk+0x14>
8000b37a:	fe b0 fc e4 	rcall	8000ad42 <__sfp_lock_release>
8000b37e:	0a 9c       	mov	r12,r5
8000b380:	d8 32       	popm	r0-r7,pc
8000b382:	d7 03       	nop

8000b384 <_localeconv_r>:
8000b384:	fe cc d4 2c 	sub	r12,pc,-11220
8000b388:	5e fc       	retal	r12
8000b38a:	d7 03       	nop

8000b38c <__smakebuf_r>:
8000b38c:	d4 21       	pushm	r4-r7,lr
8000b38e:	20 fd       	sub	sp,60
8000b390:	96 68       	ld.sh	r8,r11[0xc]
8000b392:	16 97       	mov	r7,r11
8000b394:	18 96       	mov	r6,r12
8000b396:	e2 18 00 02 	andl	r8,0x2,COH
8000b39a:	c3 d1       	brne	8000b414 <__smakebuf_r+0x88>
8000b39c:	96 7b       	ld.sh	r11,r11[0xe]
8000b39e:	f0 0b 19 00 	cp.h	r11,r8
8000b3a2:	c0 55       	brlt	8000b3ac <__smakebuf_r+0x20>
8000b3a4:	1a 9a       	mov	r10,sp
8000b3a6:	e0 a0 04 81 	rcall	8000bca8 <_fstat_r>
8000b3aa:	c0 f4       	brge	8000b3c8 <__smakebuf_r+0x3c>
8000b3ac:	8e 65       	ld.sh	r5,r7[0xc]
8000b3ae:	0a 98       	mov	r8,r5
8000b3b0:	ab b8       	sbr	r8,0xb
8000b3b2:	e2 15 00 80 	andl	r5,0x80,COH
8000b3b6:	ae 68       	st.h	r7[0xc],r8
8000b3b8:	30 04       	mov	r4,0
8000b3ba:	e0 68 04 00 	mov	r8,1024
8000b3be:	f9 b5 01 40 	movne	r5,64
8000b3c2:	f0 05 17 00 	moveq	r5,r8
8000b3c6:	c1 c8       	rjmp	8000b3fe <__smakebuf_r+0x72>
8000b3c8:	40 18       	lddsp	r8,sp[0x4]
8000b3ca:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b3ce:	e0 48 20 00 	cp.w	r8,8192
8000b3d2:	5f 04       	sreq	r4
8000b3d4:	e0 48 80 00 	cp.w	r8,32768
8000b3d8:	c0 e1       	brne	8000b3f4 <__smakebuf_r+0x68>
8000b3da:	6e b9       	ld.w	r9,r7[0x2c]
8000b3dc:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b3e0:	10 39       	cp.w	r9,r8
8000b3e2:	c0 91       	brne	8000b3f4 <__smakebuf_r+0x68>
8000b3e4:	8e 68       	ld.sh	r8,r7[0xc]
8000b3e6:	e0 65 04 00 	mov	r5,1024
8000b3ea:	ab a8       	sbr	r8,0xa
8000b3ec:	ef 45 00 50 	st.w	r7[80],r5
8000b3f0:	ae 68       	st.h	r7[0xc],r8
8000b3f2:	c0 68       	rjmp	8000b3fe <__smakebuf_r+0x72>
8000b3f4:	8e 68       	ld.sh	r8,r7[0xc]
8000b3f6:	e0 65 04 00 	mov	r5,1024
8000b3fa:	ab b8       	sbr	r8,0xb
8000b3fc:	ae 68       	st.h	r7[0xc],r8
8000b3fe:	0a 9b       	mov	r11,r5
8000b400:	0c 9c       	mov	r12,r6
8000b402:	fe b0 df 35 	rcall	8000726c <_malloc_r>
8000b406:	8e 68       	ld.sh	r8,r7[0xc]
8000b408:	c0 d1       	brne	8000b422 <__smakebuf_r+0x96>
8000b40a:	ed b8 00 09 	bld	r8,0x9
8000b40e:	c1 b0       	breq	8000b444 <__smakebuf_r+0xb8>
8000b410:	a1 b8       	sbr	r8,0x1
8000b412:	ae 68       	st.h	r7[0xc],r8
8000b414:	ee c8 ff b9 	sub	r8,r7,-71
8000b418:	8f 48       	st.w	r7[0x10],r8
8000b41a:	8f 08       	st.w	r7[0x0],r8
8000b41c:	30 18       	mov	r8,1
8000b41e:	8f 58       	st.w	r7[0x14],r8
8000b420:	c1 28       	rjmp	8000b444 <__smakebuf_r+0xb8>
8000b422:	a7 b8       	sbr	r8,0x7
8000b424:	8f 4c       	st.w	r7[0x10],r12
8000b426:	ae 68       	st.h	r7[0xc],r8
8000b428:	8f 55       	st.w	r7[0x14],r5
8000b42a:	fe c8 06 e6 	sub	r8,pc,1766
8000b42e:	8f 0c       	st.w	r7[0x0],r12
8000b430:	8d a8       	st.w	r6[0x28],r8
8000b432:	58 04       	cp.w	r4,0
8000b434:	c0 80       	breq	8000b444 <__smakebuf_r+0xb8>
8000b436:	8e 7c       	ld.sh	r12,r7[0xe]
8000b438:	fe b0 e3 94 	rcall	80007b60 <isatty>
8000b43c:	c0 40       	breq	8000b444 <__smakebuf_r+0xb8>
8000b43e:	8e 68       	ld.sh	r8,r7[0xc]
8000b440:	a1 a8       	sbr	r8,0x0
8000b442:	ae 68       	st.h	r7[0xc],r8
8000b444:	2f 1d       	sub	sp,-60
8000b446:	d8 22       	popm	r4-r7,pc

8000b448 <memchr>:
8000b448:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b44c:	c0 68       	rjmp	8000b458 <memchr+0x10>
8000b44e:	20 1a       	sub	r10,1
8000b450:	19 88       	ld.ub	r8,r12[0x0]
8000b452:	16 38       	cp.w	r8,r11
8000b454:	5e 0c       	reteq	r12
8000b456:	2f fc       	sub	r12,-1
8000b458:	58 0a       	cp.w	r10,0
8000b45a:	cf a1       	brne	8000b44e <memchr+0x6>
8000b45c:	5e fa       	retal	r10

8000b45e <memmove>:
8000b45e:	d4 01       	pushm	lr
8000b460:	18 3b       	cp.w	r11,r12
8000b462:	c1 92       	brcc	8000b494 <memmove+0x36>
8000b464:	f6 0a 00 09 	add	r9,r11,r10
8000b468:	12 3c       	cp.w	r12,r9
8000b46a:	c1 52       	brcc	8000b494 <memmove+0x36>
8000b46c:	f8 0a 00 0b 	add	r11,r12,r10
8000b470:	30 08       	mov	r8,0
8000b472:	c0 68       	rjmp	8000b47e <memmove+0x20>
8000b474:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b478:	20 1a       	sub	r10,1
8000b47a:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b47e:	20 18       	sub	r8,1
8000b480:	58 0a       	cp.w	r10,0
8000b482:	cf 91       	brne	8000b474 <memmove+0x16>
8000b484:	d8 02       	popm	pc
8000b486:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b48a:	20 1a       	sub	r10,1
8000b48c:	f8 08 0b 09 	st.b	r12[r8],r9
8000b490:	2f f8       	sub	r8,-1
8000b492:	c0 28       	rjmp	8000b496 <memmove+0x38>
8000b494:	30 08       	mov	r8,0
8000b496:	58 0a       	cp.w	r10,0
8000b498:	cf 71       	brne	8000b486 <memmove+0x28>
8000b49a:	d8 02       	popm	pc

8000b49c <__hi0bits>:
8000b49c:	18 98       	mov	r8,r12
8000b49e:	e0 1c 00 00 	andl	r12,0x0
8000b4a2:	f0 09 15 10 	lsl	r9,r8,0x10
8000b4a6:	58 0c       	cp.w	r12,0
8000b4a8:	f2 08 17 00 	moveq	r8,r9
8000b4ac:	f9 bc 00 10 	moveq	r12,16
8000b4b0:	f9 bc 01 00 	movne	r12,0
8000b4b4:	10 9a       	mov	r10,r8
8000b4b6:	f0 09 15 08 	lsl	r9,r8,0x8
8000b4ba:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b4be:	f7 bc 00 f8 	subeq	r12,-8
8000b4c2:	f2 08 17 00 	moveq	r8,r9
8000b4c6:	10 9a       	mov	r10,r8
8000b4c8:	f0 09 15 04 	lsl	r9,r8,0x4
8000b4cc:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b4d0:	f7 bc 00 fc 	subeq	r12,-4
8000b4d4:	f2 08 17 00 	moveq	r8,r9
8000b4d8:	10 9a       	mov	r10,r8
8000b4da:	f0 09 15 02 	lsl	r9,r8,0x2
8000b4de:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b4e2:	f7 bc 00 fe 	subeq	r12,-2
8000b4e6:	f2 08 17 00 	moveq	r8,r9
8000b4ea:	58 08       	cp.w	r8,0
8000b4ec:	5e 5c       	retlt	r12
8000b4ee:	ed b8 00 1e 	bld	r8,0x1e
8000b4f2:	f9 bc 01 20 	movne	r12,32
8000b4f6:	f7 bc 00 ff 	subeq	r12,-1
8000b4fa:	5e fc       	retal	r12

8000b4fc <__lo0bits>:
8000b4fc:	18 99       	mov	r9,r12
8000b4fe:	78 08       	ld.w	r8,r12[0x0]
8000b500:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b504:	c1 50       	breq	8000b52e <__lo0bits+0x32>
8000b506:	ed b8 00 00 	bld	r8,0x0
8000b50a:	c0 21       	brne	8000b50e <__lo0bits+0x12>
8000b50c:	5e fd       	retal	0
8000b50e:	10 9b       	mov	r11,r8
8000b510:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b514:	e2 1b 00 02 	andl	r11,0x2,COH
8000b518:	a3 88       	lsr	r8,0x2
8000b51a:	58 0b       	cp.w	r11,0
8000b51c:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b520:	f9 bc 01 01 	movne	r12,1
8000b524:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b528:	f9 bc 00 02 	moveq	r12,2
8000b52c:	5e fc       	retal	r12
8000b52e:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b532:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b536:	58 0a       	cp.w	r10,0
8000b538:	f6 08 17 00 	moveq	r8,r11
8000b53c:	f9 bc 00 10 	moveq	r12,16
8000b540:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b544:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b548:	58 0b       	cp.w	r11,0
8000b54a:	f7 bc 00 f8 	subeq	r12,-8
8000b54e:	f4 08 17 00 	moveq	r8,r10
8000b552:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b556:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b55a:	58 0b       	cp.w	r11,0
8000b55c:	f7 bc 00 fc 	subeq	r12,-4
8000b560:	f4 08 17 00 	moveq	r8,r10
8000b564:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b568:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b56c:	58 0b       	cp.w	r11,0
8000b56e:	f7 bc 00 fe 	subeq	r12,-2
8000b572:	f4 08 17 00 	moveq	r8,r10
8000b576:	ed b8 00 00 	bld	r8,0x0
8000b57a:	c0 60       	breq	8000b586 <__lo0bits+0x8a>
8000b57c:	a1 98       	lsr	r8,0x1
8000b57e:	c0 31       	brne	8000b584 <__lo0bits+0x88>
8000b580:	32 0c       	mov	r12,32
8000b582:	5e fc       	retal	r12
8000b584:	2f fc       	sub	r12,-1
8000b586:	93 08       	st.w	r9[0x0],r8
8000b588:	5e fc       	retal	r12

8000b58a <__mcmp>:
8000b58a:	d4 01       	pushm	lr
8000b58c:	18 98       	mov	r8,r12
8000b58e:	76 49       	ld.w	r9,r11[0x10]
8000b590:	78 4c       	ld.w	r12,r12[0x10]
8000b592:	12 1c       	sub	r12,r9
8000b594:	c1 31       	brne	8000b5ba <__mcmp+0x30>
8000b596:	2f b9       	sub	r9,-5
8000b598:	a3 69       	lsl	r9,0x2
8000b59a:	12 0b       	add	r11,r9
8000b59c:	f0 09 00 09 	add	r9,r8,r9
8000b5a0:	2e c8       	sub	r8,-20
8000b5a2:	13 4e       	ld.w	lr,--r9
8000b5a4:	17 4a       	ld.w	r10,--r11
8000b5a6:	14 3e       	cp.w	lr,r10
8000b5a8:	c0 60       	breq	8000b5b4 <__mcmp+0x2a>
8000b5aa:	f9 bc 03 ff 	movlo	r12,-1
8000b5ae:	f9 bc 02 01 	movhs	r12,1
8000b5b2:	d8 02       	popm	pc
8000b5b4:	10 39       	cp.w	r9,r8
8000b5b6:	fe 9b ff f6 	brhi	8000b5a2 <__mcmp+0x18>
8000b5ba:	d8 02       	popm	pc

8000b5bc <_Bfree>:
8000b5bc:	d4 21       	pushm	r4-r7,lr
8000b5be:	18 97       	mov	r7,r12
8000b5c0:	16 95       	mov	r5,r11
8000b5c2:	78 96       	ld.w	r6,r12[0x24]
8000b5c4:	58 06       	cp.w	r6,0
8000b5c6:	c0 91       	brne	8000b5d8 <_Bfree+0x1c>
8000b5c8:	31 0c       	mov	r12,16
8000b5ca:	fe b0 de 49 	rcall	8000725c <malloc>
8000b5ce:	99 36       	st.w	r12[0xc],r6
8000b5d0:	8f 9c       	st.w	r7[0x24],r12
8000b5d2:	99 16       	st.w	r12[0x4],r6
8000b5d4:	99 26       	st.w	r12[0x8],r6
8000b5d6:	99 06       	st.w	r12[0x0],r6
8000b5d8:	58 05       	cp.w	r5,0
8000b5da:	c0 90       	breq	8000b5ec <_Bfree+0x30>
8000b5dc:	6a 19       	ld.w	r9,r5[0x4]
8000b5de:	6e 98       	ld.w	r8,r7[0x24]
8000b5e0:	70 38       	ld.w	r8,r8[0xc]
8000b5e2:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b5e6:	8b 0a       	st.w	r5[0x0],r10
8000b5e8:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b5ec:	d8 22       	popm	r4-r7,pc
8000b5ee:	d7 03       	nop

8000b5f0 <_Balloc>:
8000b5f0:	d4 21       	pushm	r4-r7,lr
8000b5f2:	18 97       	mov	r7,r12
8000b5f4:	16 96       	mov	r6,r11
8000b5f6:	78 95       	ld.w	r5,r12[0x24]
8000b5f8:	58 05       	cp.w	r5,0
8000b5fa:	c0 91       	brne	8000b60c <_Balloc+0x1c>
8000b5fc:	31 0c       	mov	r12,16
8000b5fe:	fe b0 de 2f 	rcall	8000725c <malloc>
8000b602:	99 35       	st.w	r12[0xc],r5
8000b604:	8f 9c       	st.w	r7[0x24],r12
8000b606:	99 15       	st.w	r12[0x4],r5
8000b608:	99 25       	st.w	r12[0x8],r5
8000b60a:	99 05       	st.w	r12[0x0],r5
8000b60c:	6e 95       	ld.w	r5,r7[0x24]
8000b60e:	6a 38       	ld.w	r8,r5[0xc]
8000b610:	58 08       	cp.w	r8,0
8000b612:	c0 b1       	brne	8000b628 <_Balloc+0x38>
8000b614:	31 0a       	mov	r10,16
8000b616:	30 4b       	mov	r11,4
8000b618:	0e 9c       	mov	r12,r7
8000b61a:	e0 a0 02 a7 	rcall	8000bb68 <_calloc_r>
8000b61e:	8b 3c       	st.w	r5[0xc],r12
8000b620:	6e 98       	ld.w	r8,r7[0x24]
8000b622:	70 3c       	ld.w	r12,r8[0xc]
8000b624:	58 0c       	cp.w	r12,0
8000b626:	c1 b0       	breq	8000b65c <_Balloc+0x6c>
8000b628:	6e 98       	ld.w	r8,r7[0x24]
8000b62a:	70 38       	ld.w	r8,r8[0xc]
8000b62c:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b630:	70 0c       	ld.w	r12,r8[0x0]
8000b632:	58 0c       	cp.w	r12,0
8000b634:	c0 40       	breq	8000b63c <_Balloc+0x4c>
8000b636:	78 09       	ld.w	r9,r12[0x0]
8000b638:	91 09       	st.w	r8[0x0],r9
8000b63a:	c0 e8       	rjmp	8000b656 <_Balloc+0x66>
8000b63c:	0e 9c       	mov	r12,r7
8000b63e:	30 17       	mov	r7,1
8000b640:	0e 9b       	mov	r11,r7
8000b642:	ee 06 09 47 	lsl	r7,r7,r6
8000b646:	ee ca ff fb 	sub	r10,r7,-5
8000b64a:	a3 6a       	lsl	r10,0x2
8000b64c:	e0 a0 02 8e 	rcall	8000bb68 <_calloc_r>
8000b650:	c0 60       	breq	8000b65c <_Balloc+0x6c>
8000b652:	99 16       	st.w	r12[0x4],r6
8000b654:	99 27       	st.w	r12[0x8],r7
8000b656:	30 08       	mov	r8,0
8000b658:	99 38       	st.w	r12[0xc],r8
8000b65a:	99 48       	st.w	r12[0x10],r8
8000b65c:	d8 22       	popm	r4-r7,pc
8000b65e:	d7 03       	nop

8000b660 <__d2b>:
8000b660:	d4 31       	pushm	r0-r7,lr
8000b662:	20 2d       	sub	sp,8
8000b664:	16 93       	mov	r3,r11
8000b666:	12 96       	mov	r6,r9
8000b668:	10 95       	mov	r5,r8
8000b66a:	14 92       	mov	r2,r10
8000b66c:	30 1b       	mov	r11,1
8000b66e:	cc 1f       	rcall	8000b5f0 <_Balloc>
8000b670:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b674:	50 09       	stdsp	sp[0x0],r9
8000b676:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b67a:	b5 a9       	sbr	r9,0x14
8000b67c:	f0 01 16 14 	lsr	r1,r8,0x14
8000b680:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b684:	18 94       	mov	r4,r12
8000b686:	58 02       	cp.w	r2,0
8000b688:	c1 d0       	breq	8000b6c2 <__d2b+0x62>
8000b68a:	fa cc ff f8 	sub	r12,sp,-8
8000b68e:	18 d2       	st.w	--r12,r2
8000b690:	c3 6f       	rcall	8000b4fc <__lo0bits>
8000b692:	40 18       	lddsp	r8,sp[0x4]
8000b694:	c0 d0       	breq	8000b6ae <__d2b+0x4e>
8000b696:	40 09       	lddsp	r9,sp[0x0]
8000b698:	f8 0a 11 20 	rsub	r10,r12,32
8000b69c:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b6a0:	f5 e8 10 08 	or	r8,r10,r8
8000b6a4:	89 58       	st.w	r4[0x14],r8
8000b6a6:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b6aa:	50 09       	stdsp	sp[0x0],r9
8000b6ac:	c0 28       	rjmp	8000b6b0 <__d2b+0x50>
8000b6ae:	89 58       	st.w	r4[0x14],r8
8000b6b0:	40 08       	lddsp	r8,sp[0x0]
8000b6b2:	58 08       	cp.w	r8,0
8000b6b4:	f9 b3 01 02 	movne	r3,2
8000b6b8:	f9 b3 00 01 	moveq	r3,1
8000b6bc:	89 68       	st.w	r4[0x18],r8
8000b6be:	89 43       	st.w	r4[0x10],r3
8000b6c0:	c0 88       	rjmp	8000b6d0 <__d2b+0x70>
8000b6c2:	1a 9c       	mov	r12,sp
8000b6c4:	c1 cf       	rcall	8000b4fc <__lo0bits>
8000b6c6:	30 13       	mov	r3,1
8000b6c8:	40 08       	lddsp	r8,sp[0x0]
8000b6ca:	2e 0c       	sub	r12,-32
8000b6cc:	89 43       	st.w	r4[0x10],r3
8000b6ce:	89 58       	st.w	r4[0x14],r8
8000b6d0:	58 01       	cp.w	r1,0
8000b6d2:	c0 90       	breq	8000b6e4 <__d2b+0x84>
8000b6d4:	e2 c1 04 33 	sub	r1,r1,1075
8000b6d8:	18 01       	add	r1,r12
8000b6da:	8d 01       	st.w	r6[0x0],r1
8000b6dc:	f8 0c 11 35 	rsub	r12,r12,53
8000b6e0:	8b 0c       	st.w	r5[0x0],r12
8000b6e2:	c0 c8       	rjmp	8000b6fa <__d2b+0x9a>
8000b6e4:	e6 c8 ff fc 	sub	r8,r3,-4
8000b6e8:	f8 cc 04 32 	sub	r12,r12,1074
8000b6ec:	a5 73       	lsl	r3,0x5
8000b6ee:	8d 0c       	st.w	r6[0x0],r12
8000b6f0:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b6f4:	cd 4e       	rcall	8000b49c <__hi0bits>
8000b6f6:	18 13       	sub	r3,r12
8000b6f8:	8b 03       	st.w	r5[0x0],r3
8000b6fa:	08 9c       	mov	r12,r4
8000b6fc:	2f ed       	sub	sp,-8
8000b6fe:	d8 32       	popm	r0-r7,pc

8000b700 <__mdiff>:
8000b700:	d4 31       	pushm	r0-r7,lr
8000b702:	74 48       	ld.w	r8,r10[0x10]
8000b704:	76 45       	ld.w	r5,r11[0x10]
8000b706:	16 97       	mov	r7,r11
8000b708:	14 96       	mov	r6,r10
8000b70a:	10 15       	sub	r5,r8
8000b70c:	c1 31       	brne	8000b732 <__mdiff+0x32>
8000b70e:	2f b8       	sub	r8,-5
8000b710:	ee ce ff ec 	sub	lr,r7,-20
8000b714:	a3 68       	lsl	r8,0x2
8000b716:	f4 08 00 0b 	add	r11,r10,r8
8000b71a:	ee 08 00 08 	add	r8,r7,r8
8000b71e:	11 4a       	ld.w	r10,--r8
8000b720:	17 49       	ld.w	r9,--r11
8000b722:	12 3a       	cp.w	r10,r9
8000b724:	c0 30       	breq	8000b72a <__mdiff+0x2a>
8000b726:	c0 e2       	brcc	8000b742 <__mdiff+0x42>
8000b728:	c0 78       	rjmp	8000b736 <__mdiff+0x36>
8000b72a:	1c 38       	cp.w	r8,lr
8000b72c:	fe 9b ff f9 	brhi	8000b71e <__mdiff+0x1e>
8000b730:	c4 98       	rjmp	8000b7c2 <__mdiff+0xc2>
8000b732:	58 05       	cp.w	r5,0
8000b734:	c0 64       	brge	8000b740 <__mdiff+0x40>
8000b736:	0e 98       	mov	r8,r7
8000b738:	30 15       	mov	r5,1
8000b73a:	0c 97       	mov	r7,r6
8000b73c:	10 96       	mov	r6,r8
8000b73e:	c0 28       	rjmp	8000b742 <__mdiff+0x42>
8000b740:	30 05       	mov	r5,0
8000b742:	6e 1b       	ld.w	r11,r7[0x4]
8000b744:	c5 6f       	rcall	8000b5f0 <_Balloc>
8000b746:	6e 49       	ld.w	r9,r7[0x10]
8000b748:	6c 44       	ld.w	r4,r6[0x10]
8000b74a:	99 35       	st.w	r12[0xc],r5
8000b74c:	2f b4       	sub	r4,-5
8000b74e:	f2 c5 ff fb 	sub	r5,r9,-5
8000b752:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b756:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b75a:	2e c6       	sub	r6,-20
8000b75c:	2e c7       	sub	r7,-20
8000b75e:	f8 c8 ff ec 	sub	r8,r12,-20
8000b762:	30 0a       	mov	r10,0
8000b764:	0f 0e       	ld.w	lr,r7++
8000b766:	0d 0b       	ld.w	r11,r6++
8000b768:	fc 02 16 10 	lsr	r2,lr,0x10
8000b76c:	f6 03 16 10 	lsr	r3,r11,0x10
8000b770:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b774:	e4 03 01 03 	sub	r3,r2,r3
8000b778:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b77c:	fc 0b 01 0b 	sub	r11,lr,r11
8000b780:	f6 0a 00 0a 	add	r10,r11,r10
8000b784:	b0 1a       	st.h	r8[0x2],r10
8000b786:	b1 4a       	asr	r10,0x10
8000b788:	e6 0a 00 0a 	add	r10,r3,r10
8000b78c:	b0 0a       	st.h	r8[0x0],r10
8000b78e:	2f c8       	sub	r8,-4
8000b790:	b1 4a       	asr	r10,0x10
8000b792:	08 36       	cp.w	r6,r4
8000b794:	ce 83       	brcs	8000b764 <__mdiff+0x64>
8000b796:	c0 d8       	rjmp	8000b7b0 <__mdiff+0xb0>
8000b798:	0f 0b       	ld.w	r11,r7++
8000b79a:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b79e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b7a2:	16 0a       	add	r10,r11
8000b7a4:	b0 1a       	st.h	r8[0x2],r10
8000b7a6:	b1 4a       	asr	r10,0x10
8000b7a8:	1c 0a       	add	r10,lr
8000b7aa:	b0 0a       	st.h	r8[0x0],r10
8000b7ac:	2f c8       	sub	r8,-4
8000b7ae:	b1 4a       	asr	r10,0x10
8000b7b0:	0a 37       	cp.w	r7,r5
8000b7b2:	cf 33       	brcs	8000b798 <__mdiff+0x98>
8000b7b4:	c0 28       	rjmp	8000b7b8 <__mdiff+0xb8>
8000b7b6:	20 19       	sub	r9,1
8000b7b8:	11 4a       	ld.w	r10,--r8
8000b7ba:	58 0a       	cp.w	r10,0
8000b7bc:	cf d0       	breq	8000b7b6 <__mdiff+0xb6>
8000b7be:	99 49       	st.w	r12[0x10],r9
8000b7c0:	d8 32       	popm	r0-r7,pc
8000b7c2:	30 0b       	mov	r11,0
8000b7c4:	c1 6f       	rcall	8000b5f0 <_Balloc>
8000b7c6:	30 18       	mov	r8,1
8000b7c8:	99 48       	st.w	r12[0x10],r8
8000b7ca:	30 08       	mov	r8,0
8000b7cc:	99 58       	st.w	r12[0x14],r8
8000b7ce:	d8 32       	popm	r0-r7,pc

8000b7d0 <__lshift>:
8000b7d0:	d4 31       	pushm	r0-r7,lr
8000b7d2:	16 97       	mov	r7,r11
8000b7d4:	76 46       	ld.w	r6,r11[0x10]
8000b7d6:	f4 02 14 05 	asr	r2,r10,0x5
8000b7da:	2f f6       	sub	r6,-1
8000b7dc:	14 93       	mov	r3,r10
8000b7de:	18 94       	mov	r4,r12
8000b7e0:	04 06       	add	r6,r2
8000b7e2:	76 1b       	ld.w	r11,r11[0x4]
8000b7e4:	6e 28       	ld.w	r8,r7[0x8]
8000b7e6:	c0 38       	rjmp	8000b7ec <__lshift+0x1c>
8000b7e8:	2f fb       	sub	r11,-1
8000b7ea:	a1 78       	lsl	r8,0x1
8000b7ec:	10 36       	cp.w	r6,r8
8000b7ee:	fe 99 ff fd 	brgt	8000b7e8 <__lshift+0x18>
8000b7f2:	08 9c       	mov	r12,r4
8000b7f4:	cf ee       	rcall	8000b5f0 <_Balloc>
8000b7f6:	30 09       	mov	r9,0
8000b7f8:	18 95       	mov	r5,r12
8000b7fa:	f8 c8 ff ec 	sub	r8,r12,-20
8000b7fe:	12 9a       	mov	r10,r9
8000b800:	c0 38       	rjmp	8000b806 <__lshift+0x36>
8000b802:	10 aa       	st.w	r8++,r10
8000b804:	2f f9       	sub	r9,-1
8000b806:	04 39       	cp.w	r9,r2
8000b808:	cf d5       	brlt	8000b802 <__lshift+0x32>
8000b80a:	6e 4b       	ld.w	r11,r7[0x10]
8000b80c:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b810:	2f bb       	sub	r11,-5
8000b812:	ee c9 ff ec 	sub	r9,r7,-20
8000b816:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b81a:	58 03       	cp.w	r3,0
8000b81c:	c1 30       	breq	8000b842 <__lshift+0x72>
8000b81e:	e6 0c 11 20 	rsub	r12,r3,32
8000b822:	30 0a       	mov	r10,0
8000b824:	72 02       	ld.w	r2,r9[0x0]
8000b826:	e4 03 09 42 	lsl	r2,r2,r3
8000b82a:	04 4a       	or	r10,r2
8000b82c:	10 aa       	st.w	r8++,r10
8000b82e:	13 0a       	ld.w	r10,r9++
8000b830:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b834:	16 39       	cp.w	r9,r11
8000b836:	cf 73       	brcs	8000b824 <__lshift+0x54>
8000b838:	91 0a       	st.w	r8[0x0],r10
8000b83a:	58 0a       	cp.w	r10,0
8000b83c:	c0 70       	breq	8000b84a <__lshift+0x7a>
8000b83e:	2f f6       	sub	r6,-1
8000b840:	c0 58       	rjmp	8000b84a <__lshift+0x7a>
8000b842:	13 0a       	ld.w	r10,r9++
8000b844:	10 aa       	st.w	r8++,r10
8000b846:	16 39       	cp.w	r9,r11
8000b848:	cf d3       	brcs	8000b842 <__lshift+0x72>
8000b84a:	08 9c       	mov	r12,r4
8000b84c:	20 16       	sub	r6,1
8000b84e:	0e 9b       	mov	r11,r7
8000b850:	8b 46       	st.w	r5[0x10],r6
8000b852:	cb 5e       	rcall	8000b5bc <_Bfree>
8000b854:	0a 9c       	mov	r12,r5
8000b856:	d8 32       	popm	r0-r7,pc

8000b858 <__multiply>:
8000b858:	d4 31       	pushm	r0-r7,lr
8000b85a:	20 2d       	sub	sp,8
8000b85c:	76 49       	ld.w	r9,r11[0x10]
8000b85e:	74 48       	ld.w	r8,r10[0x10]
8000b860:	16 96       	mov	r6,r11
8000b862:	14 95       	mov	r5,r10
8000b864:	10 39       	cp.w	r9,r8
8000b866:	ec 08 17 50 	movlt	r8,r6
8000b86a:	ea 06 17 50 	movlt	r6,r5
8000b86e:	f0 05 17 50 	movlt	r5,r8
8000b872:	6c 28       	ld.w	r8,r6[0x8]
8000b874:	76 43       	ld.w	r3,r11[0x10]
8000b876:	74 42       	ld.w	r2,r10[0x10]
8000b878:	76 1b       	ld.w	r11,r11[0x4]
8000b87a:	e4 03 00 07 	add	r7,r2,r3
8000b87e:	10 37       	cp.w	r7,r8
8000b880:	f7 bb 09 ff 	subgt	r11,-1
8000b884:	cb 6e       	rcall	8000b5f0 <_Balloc>
8000b886:	ee c4 ff fb 	sub	r4,r7,-5
8000b88a:	f8 c9 ff ec 	sub	r9,r12,-20
8000b88e:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b892:	30 0a       	mov	r10,0
8000b894:	12 98       	mov	r8,r9
8000b896:	c0 28       	rjmp	8000b89a <__multiply+0x42>
8000b898:	10 aa       	st.w	r8++,r10
8000b89a:	08 38       	cp.w	r8,r4
8000b89c:	cf e3       	brcs	8000b898 <__multiply+0x40>
8000b89e:	2f b3       	sub	r3,-5
8000b8a0:	2f b2       	sub	r2,-5
8000b8a2:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b8a6:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b8aa:	ec cb ff ec 	sub	r11,r6,-20
8000b8ae:	50 12       	stdsp	sp[0x4],r2
8000b8b0:	ea ca ff ec 	sub	r10,r5,-20
8000b8b4:	c4 48       	rjmp	8000b93c <__multiply+0xe4>
8000b8b6:	94 95       	ld.uh	r5,r10[0x2]
8000b8b8:	58 05       	cp.w	r5,0
8000b8ba:	c2 00       	breq	8000b8fa <__multiply+0xa2>
8000b8bc:	12 98       	mov	r8,r9
8000b8be:	16 96       	mov	r6,r11
8000b8c0:	30 0e       	mov	lr,0
8000b8c2:	50 09       	stdsp	sp[0x0],r9
8000b8c4:	0d 02       	ld.w	r2,r6++
8000b8c6:	e4 00 16 10 	lsr	r0,r2,0x10
8000b8ca:	70 01       	ld.w	r1,r8[0x0]
8000b8cc:	70 09       	ld.w	r9,r8[0x0]
8000b8ce:	b1 81       	lsr	r1,0x10
8000b8d0:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b8d4:	e0 05 03 41 	mac	r1,r0,r5
8000b8d8:	ab 32       	mul	r2,r5
8000b8da:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b8de:	00 02       	add	r2,r0
8000b8e0:	e4 0e 00 0e 	add	lr,r2,lr
8000b8e4:	b0 1e       	st.h	r8[0x2],lr
8000b8e6:	b1 8e       	lsr	lr,0x10
8000b8e8:	1c 01       	add	r1,lr
8000b8ea:	b0 01       	st.h	r8[0x0],r1
8000b8ec:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b8f0:	2f c8       	sub	r8,-4
8000b8f2:	06 36       	cp.w	r6,r3
8000b8f4:	ce 83       	brcs	8000b8c4 <__multiply+0x6c>
8000b8f6:	40 09       	lddsp	r9,sp[0x0]
8000b8f8:	91 0e       	st.w	r8[0x0],lr
8000b8fa:	94 86       	ld.uh	r6,r10[0x0]
8000b8fc:	58 06       	cp.w	r6,0
8000b8fe:	c1 d0       	breq	8000b938 <__multiply+0xe0>
8000b900:	72 02       	ld.w	r2,r9[0x0]
8000b902:	12 98       	mov	r8,r9
8000b904:	16 9e       	mov	lr,r11
8000b906:	30 05       	mov	r5,0
8000b908:	b0 12       	st.h	r8[0x2],r2
8000b90a:	1d 01       	ld.w	r1,lr++
8000b90c:	90 82       	ld.uh	r2,r8[0x0]
8000b90e:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b912:	ad 30       	mul	r0,r6
8000b914:	e0 02 00 02 	add	r2,r0,r2
8000b918:	e4 05 00 05 	add	r5,r2,r5
8000b91c:	b0 05       	st.h	r8[0x0],r5
8000b91e:	b1 85       	lsr	r5,0x10
8000b920:	b1 81       	lsr	r1,0x10
8000b922:	2f c8       	sub	r8,-4
8000b924:	ad 31       	mul	r1,r6
8000b926:	90 92       	ld.uh	r2,r8[0x2]
8000b928:	e2 02 00 02 	add	r2,r1,r2
8000b92c:	0a 02       	add	r2,r5
8000b92e:	e4 05 16 10 	lsr	r5,r2,0x10
8000b932:	06 3e       	cp.w	lr,r3
8000b934:	ce a3       	brcs	8000b908 <__multiply+0xb0>
8000b936:	91 02       	st.w	r8[0x0],r2
8000b938:	2f ca       	sub	r10,-4
8000b93a:	2f c9       	sub	r9,-4
8000b93c:	40 18       	lddsp	r8,sp[0x4]
8000b93e:	10 3a       	cp.w	r10,r8
8000b940:	cb b3       	brcs	8000b8b6 <__multiply+0x5e>
8000b942:	c0 28       	rjmp	8000b946 <__multiply+0xee>
8000b944:	20 17       	sub	r7,1
8000b946:	58 07       	cp.w	r7,0
8000b948:	e0 8a 00 05 	brle	8000b952 <__multiply+0xfa>
8000b94c:	09 48       	ld.w	r8,--r4
8000b94e:	58 08       	cp.w	r8,0
8000b950:	cf a0       	breq	8000b944 <__multiply+0xec>
8000b952:	99 47       	st.w	r12[0x10],r7
8000b954:	2f ed       	sub	sp,-8
8000b956:	d8 32       	popm	r0-r7,pc

8000b958 <__i2b>:
8000b958:	d4 21       	pushm	r4-r7,lr
8000b95a:	16 97       	mov	r7,r11
8000b95c:	30 1b       	mov	r11,1
8000b95e:	c4 9e       	rcall	8000b5f0 <_Balloc>
8000b960:	30 19       	mov	r9,1
8000b962:	99 57       	st.w	r12[0x14],r7
8000b964:	99 49       	st.w	r12[0x10],r9
8000b966:	d8 22       	popm	r4-r7,pc

8000b968 <__multadd>:
8000b968:	d4 31       	pushm	r0-r7,lr
8000b96a:	30 08       	mov	r8,0
8000b96c:	12 95       	mov	r5,r9
8000b96e:	16 97       	mov	r7,r11
8000b970:	18 96       	mov	r6,r12
8000b972:	76 44       	ld.w	r4,r11[0x10]
8000b974:	f6 c9 ff ec 	sub	r9,r11,-20
8000b978:	72 0b       	ld.w	r11,r9[0x0]
8000b97a:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b97e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b982:	f4 0c 02 4c 	mul	r12,r10,r12
8000b986:	f4 0b 03 45 	mac	r5,r10,r11
8000b98a:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b98e:	b1 85       	lsr	r5,0x10
8000b990:	18 05       	add	r5,r12
8000b992:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b996:	f8 0b 00 0b 	add	r11,r12,r11
8000b99a:	12 ab       	st.w	r9++,r11
8000b99c:	2f f8       	sub	r8,-1
8000b99e:	b1 85       	lsr	r5,0x10
8000b9a0:	08 38       	cp.w	r8,r4
8000b9a2:	ce b5       	brlt	8000b978 <__multadd+0x10>
8000b9a4:	58 05       	cp.w	r5,0
8000b9a6:	c1 c0       	breq	8000b9de <__multadd+0x76>
8000b9a8:	6e 28       	ld.w	r8,r7[0x8]
8000b9aa:	10 34       	cp.w	r4,r8
8000b9ac:	c1 35       	brlt	8000b9d2 <__multadd+0x6a>
8000b9ae:	6e 1b       	ld.w	r11,r7[0x4]
8000b9b0:	0c 9c       	mov	r12,r6
8000b9b2:	2f fb       	sub	r11,-1
8000b9b4:	c1 ee       	rcall	8000b5f0 <_Balloc>
8000b9b6:	6e 4a       	ld.w	r10,r7[0x10]
8000b9b8:	ee cb ff f4 	sub	r11,r7,-12
8000b9bc:	18 93       	mov	r3,r12
8000b9be:	2f ea       	sub	r10,-2
8000b9c0:	2f 4c       	sub	r12,-12
8000b9c2:	a3 6a       	lsl	r10,0x2
8000b9c4:	fe b0 de 70 	rcall	800076a4 <memcpy>
8000b9c8:	0e 9b       	mov	r11,r7
8000b9ca:	0c 9c       	mov	r12,r6
8000b9cc:	fe b0 fd f8 	rcall	8000b5bc <_Bfree>
8000b9d0:	06 97       	mov	r7,r3
8000b9d2:	e8 c8 ff ff 	sub	r8,r4,-1
8000b9d6:	2f b4       	sub	r4,-5
8000b9d8:	8f 48       	st.w	r7[0x10],r8
8000b9da:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b9de:	0e 9c       	mov	r12,r7
8000b9e0:	d8 32       	popm	r0-r7,pc
8000b9e2:	d7 03       	nop

8000b9e4 <__pow5mult>:
8000b9e4:	d4 31       	pushm	r0-r7,lr
8000b9e6:	14 96       	mov	r6,r10
8000b9e8:	18 97       	mov	r7,r12
8000b9ea:	16 94       	mov	r4,r11
8000b9ec:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b9f0:	c0 90       	breq	8000ba02 <__pow5mult+0x1e>
8000b9f2:	20 18       	sub	r8,1
8000b9f4:	fe c9 da 60 	sub	r9,pc,-9632
8000b9f8:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b9fc:	30 09       	mov	r9,0
8000b9fe:	cb 5f       	rcall	8000b968 <__multadd>
8000ba00:	18 94       	mov	r4,r12
8000ba02:	a3 46       	asr	r6,0x2
8000ba04:	c3 40       	breq	8000ba6c <__pow5mult+0x88>
8000ba06:	6e 95       	ld.w	r5,r7[0x24]
8000ba08:	58 05       	cp.w	r5,0
8000ba0a:	c0 91       	brne	8000ba1c <__pow5mult+0x38>
8000ba0c:	31 0c       	mov	r12,16
8000ba0e:	fe b0 dc 27 	rcall	8000725c <malloc>
8000ba12:	99 35       	st.w	r12[0xc],r5
8000ba14:	8f 9c       	st.w	r7[0x24],r12
8000ba16:	99 15       	st.w	r12[0x4],r5
8000ba18:	99 25       	st.w	r12[0x8],r5
8000ba1a:	99 05       	st.w	r12[0x0],r5
8000ba1c:	6e 93       	ld.w	r3,r7[0x24]
8000ba1e:	66 25       	ld.w	r5,r3[0x8]
8000ba20:	58 05       	cp.w	r5,0
8000ba22:	c0 c1       	brne	8000ba3a <__pow5mult+0x56>
8000ba24:	e0 6b 02 71 	mov	r11,625
8000ba28:	0e 9c       	mov	r12,r7
8000ba2a:	c9 7f       	rcall	8000b958 <__i2b>
8000ba2c:	87 2c       	st.w	r3[0x8],r12
8000ba2e:	30 08       	mov	r8,0
8000ba30:	18 95       	mov	r5,r12
8000ba32:	99 08       	st.w	r12[0x0],r8
8000ba34:	c0 38       	rjmp	8000ba3a <__pow5mult+0x56>
8000ba36:	06 9c       	mov	r12,r3
8000ba38:	18 95       	mov	r5,r12
8000ba3a:	ed b6 00 00 	bld	r6,0x0
8000ba3e:	c0 b1       	brne	8000ba54 <__pow5mult+0x70>
8000ba40:	08 9b       	mov	r11,r4
8000ba42:	0a 9a       	mov	r10,r5
8000ba44:	0e 9c       	mov	r12,r7
8000ba46:	c0 9f       	rcall	8000b858 <__multiply>
8000ba48:	08 9b       	mov	r11,r4
8000ba4a:	18 93       	mov	r3,r12
8000ba4c:	0e 9c       	mov	r12,r7
8000ba4e:	06 94       	mov	r4,r3
8000ba50:	fe b0 fd b6 	rcall	8000b5bc <_Bfree>
8000ba54:	a1 56       	asr	r6,0x1
8000ba56:	c0 b0       	breq	8000ba6c <__pow5mult+0x88>
8000ba58:	6a 03       	ld.w	r3,r5[0x0]
8000ba5a:	58 03       	cp.w	r3,0
8000ba5c:	ce d1       	brne	8000ba36 <__pow5mult+0x52>
8000ba5e:	0a 9a       	mov	r10,r5
8000ba60:	0a 9b       	mov	r11,r5
8000ba62:	0e 9c       	mov	r12,r7
8000ba64:	cf ae       	rcall	8000b858 <__multiply>
8000ba66:	8b 0c       	st.w	r5[0x0],r12
8000ba68:	99 03       	st.w	r12[0x0],r3
8000ba6a:	ce 7b       	rjmp	8000ba38 <__pow5mult+0x54>
8000ba6c:	08 9c       	mov	r12,r4
8000ba6e:	d8 32       	popm	r0-r7,pc

8000ba70 <__isinfd>:
8000ba70:	14 98       	mov	r8,r10
8000ba72:	fc 19 7f f0 	movh	r9,0x7ff0
8000ba76:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ba7a:	f0 0b 11 00 	rsub	r11,r8,0
8000ba7e:	f7 e8 10 08 	or	r8,r11,r8
8000ba82:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000ba86:	f2 08 01 08 	sub	r8,r9,r8
8000ba8a:	f0 0c 11 00 	rsub	r12,r8,0
8000ba8e:	f9 e8 10 08 	or	r8,r12,r8
8000ba92:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000ba96:	2f fc       	sub	r12,-1
8000ba98:	5e fc       	retal	r12

8000ba9a <__isnand>:
8000ba9a:	14 98       	mov	r8,r10
8000ba9c:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000baa0:	f0 0c 11 00 	rsub	r12,r8,0
8000baa4:	10 4c       	or	r12,r8
8000baa6:	fc 18 7f f0 	movh	r8,0x7ff0
8000baaa:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000baae:	f0 0c 01 0c 	sub	r12,r8,r12
8000bab2:	bf 9c       	lsr	r12,0x1f
8000bab4:	5e fc       	retal	r12
8000bab6:	d7 03       	nop

8000bab8 <__sclose>:
8000bab8:	d4 01       	pushm	lr
8000baba:	96 7b       	ld.sh	r11,r11[0xe]
8000babc:	c8 2c       	rcall	8000bbc0 <_close_r>
8000babe:	d8 02       	popm	pc

8000bac0 <__sseek>:
8000bac0:	d4 21       	pushm	r4-r7,lr
8000bac2:	16 97       	mov	r7,r11
8000bac4:	96 7b       	ld.sh	r11,r11[0xe]
8000bac6:	c0 3d       	rcall	8000bccc <_lseek_r>
8000bac8:	8e 68       	ld.sh	r8,r7[0xc]
8000baca:	10 99       	mov	r9,r8
8000bacc:	ad c8       	cbr	r8,0xc
8000bace:	ad a9       	sbr	r9,0xc
8000bad0:	5b fc       	cp.w	r12,-1
8000bad2:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000bad6:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000bada:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000bade:	d8 22       	popm	r4-r7,pc

8000bae0 <__swrite>:
8000bae0:	d4 21       	pushm	r4-r7,lr
8000bae2:	96 68       	ld.sh	r8,r11[0xc]
8000bae4:	16 97       	mov	r7,r11
8000bae6:	14 95       	mov	r5,r10
8000bae8:	12 94       	mov	r4,r9
8000baea:	e2 18 01 00 	andl	r8,0x100,COH
8000baee:	18 96       	mov	r6,r12
8000baf0:	c0 50       	breq	8000bafa <__swrite+0x1a>
8000baf2:	30 29       	mov	r9,2
8000baf4:	30 0a       	mov	r10,0
8000baf6:	96 7b       	ld.sh	r11,r11[0xe]
8000baf8:	ce ac       	rcall	8000bccc <_lseek_r>
8000bafa:	8e 68       	ld.sh	r8,r7[0xc]
8000bafc:	ad c8       	cbr	r8,0xc
8000bafe:	08 99       	mov	r9,r4
8000bb00:	0a 9a       	mov	r10,r5
8000bb02:	8e 7b       	ld.sh	r11,r7[0xe]
8000bb04:	0c 9c       	mov	r12,r6
8000bb06:	ae 68       	st.h	r7[0xc],r8
8000bb08:	c1 cc       	rcall	8000bb40 <_write_r>
8000bb0a:	d8 22       	popm	r4-r7,pc

8000bb0c <__sread>:
8000bb0c:	d4 21       	pushm	r4-r7,lr
8000bb0e:	16 97       	mov	r7,r11
8000bb10:	96 7b       	ld.sh	r11,r11[0xe]
8000bb12:	cf 1c       	rcall	8000bcf4 <_read_r>
8000bb14:	c0 65       	brlt	8000bb20 <__sread+0x14>
8000bb16:	6f 58       	ld.w	r8,r7[0x54]
8000bb18:	18 08       	add	r8,r12
8000bb1a:	ef 48 00 54 	st.w	r7[84],r8
8000bb1e:	d8 22       	popm	r4-r7,pc
8000bb20:	8e 68       	ld.sh	r8,r7[0xc]
8000bb22:	ad c8       	cbr	r8,0xc
8000bb24:	ae 68       	st.h	r7[0xc],r8
8000bb26:	d8 22       	popm	r4-r7,pc

8000bb28 <strlen>:
8000bb28:	30 09       	mov	r9,0
8000bb2a:	18 98       	mov	r8,r12
8000bb2c:	c0 28       	rjmp	8000bb30 <strlen+0x8>
8000bb2e:	2f f8       	sub	r8,-1
8000bb30:	11 8a       	ld.ub	r10,r8[0x0]
8000bb32:	f2 0a 18 00 	cp.b	r10,r9
8000bb36:	cf c1       	brne	8000bb2e <strlen+0x6>
8000bb38:	f0 0c 01 0c 	sub	r12,r8,r12
8000bb3c:	5e fc       	retal	r12
8000bb3e:	d7 03       	nop

8000bb40 <_write_r>:
8000bb40:	d4 21       	pushm	r4-r7,lr
8000bb42:	16 98       	mov	r8,r11
8000bb44:	18 97       	mov	r7,r12
8000bb46:	10 9c       	mov	r12,r8
8000bb48:	30 08       	mov	r8,0
8000bb4a:	14 9b       	mov	r11,r10
8000bb4c:	e0 66 5b 6c 	mov	r6,23404
8000bb50:	12 9a       	mov	r10,r9
8000bb52:	8d 08       	st.w	r6[0x0],r8
8000bb54:	fe b0 d1 9e 	rcall	80005e90 <_write>
8000bb58:	5b fc       	cp.w	r12,-1
8000bb5a:	c0 51       	brne	8000bb64 <_write_r+0x24>
8000bb5c:	6c 08       	ld.w	r8,r6[0x0]
8000bb5e:	58 08       	cp.w	r8,0
8000bb60:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bb64:	d8 22       	popm	r4-r7,pc
8000bb66:	d7 03       	nop

8000bb68 <_calloc_r>:
8000bb68:	d4 21       	pushm	r4-r7,lr
8000bb6a:	f4 0b 02 4b 	mul	r11,r10,r11
8000bb6e:	fe b0 db 7f 	rcall	8000726c <_malloc_r>
8000bb72:	18 97       	mov	r7,r12
8000bb74:	c2 30       	breq	8000bbba <_calloc_r+0x52>
8000bb76:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000bb7a:	e0 1a ff fc 	andl	r10,0xfffc
8000bb7e:	20 4a       	sub	r10,4
8000bb80:	e0 4a 00 24 	cp.w	r10,36
8000bb84:	e0 8b 00 18 	brhi	8000bbb4 <_calloc_r+0x4c>
8000bb88:	18 98       	mov	r8,r12
8000bb8a:	59 3a       	cp.w	r10,19
8000bb8c:	e0 88 00 0f 	brls	8000bbaa <_calloc_r+0x42>
8000bb90:	30 09       	mov	r9,0
8000bb92:	10 a9       	st.w	r8++,r9
8000bb94:	10 a9       	st.w	r8++,r9
8000bb96:	59 ba       	cp.w	r10,27
8000bb98:	e0 88 00 09 	brls	8000bbaa <_calloc_r+0x42>
8000bb9c:	10 a9       	st.w	r8++,r9
8000bb9e:	10 a9       	st.w	r8++,r9
8000bba0:	e0 4a 00 24 	cp.w	r10,36
8000bba4:	c0 31       	brne	8000bbaa <_calloc_r+0x42>
8000bba6:	10 a9       	st.w	r8++,r9
8000bba8:	10 a9       	st.w	r8++,r9
8000bbaa:	30 09       	mov	r9,0
8000bbac:	10 a9       	st.w	r8++,r9
8000bbae:	91 19       	st.w	r8[0x4],r9
8000bbb0:	91 09       	st.w	r8[0x0],r9
8000bbb2:	c0 48       	rjmp	8000bbba <_calloc_r+0x52>
8000bbb4:	30 0b       	mov	r11,0
8000bbb6:	fe b0 de 1b 	rcall	800077ec <memset>
8000bbba:	0e 9c       	mov	r12,r7
8000bbbc:	d8 22       	popm	r4-r7,pc
8000bbbe:	d7 03       	nop

8000bbc0 <_close_r>:
8000bbc0:	d4 21       	pushm	r4-r7,lr
8000bbc2:	30 08       	mov	r8,0
8000bbc4:	18 97       	mov	r7,r12
8000bbc6:	e0 66 5b 6c 	mov	r6,23404
8000bbca:	16 9c       	mov	r12,r11
8000bbcc:	8d 08       	st.w	r6[0x0],r8
8000bbce:	fe b0 df b5 	rcall	80007b38 <_close>
8000bbd2:	5b fc       	cp.w	r12,-1
8000bbd4:	c0 51       	brne	8000bbde <_close_r+0x1e>
8000bbd6:	6c 08       	ld.w	r8,r6[0x0]
8000bbd8:	58 08       	cp.w	r8,0
8000bbda:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bbde:	d8 22       	popm	r4-r7,pc

8000bbe0 <_fclose_r>:
8000bbe0:	d4 21       	pushm	r4-r7,lr
8000bbe2:	18 96       	mov	r6,r12
8000bbe4:	16 97       	mov	r7,r11
8000bbe6:	58 0b       	cp.w	r11,0
8000bbe8:	c0 31       	brne	8000bbee <_fclose_r+0xe>
8000bbea:	16 95       	mov	r5,r11
8000bbec:	c5 38       	rjmp	8000bc92 <_fclose_r+0xb2>
8000bbee:	fe b0 f8 a9 	rcall	8000ad40 <__sfp_lock_acquire>
8000bbf2:	58 06       	cp.w	r6,0
8000bbf4:	c0 70       	breq	8000bc02 <_fclose_r+0x22>
8000bbf6:	6c 68       	ld.w	r8,r6[0x18]
8000bbf8:	58 08       	cp.w	r8,0
8000bbfa:	c0 41       	brne	8000bc02 <_fclose_r+0x22>
8000bbfc:	0c 9c       	mov	r12,r6
8000bbfe:	fe b0 f8 f3 	rcall	8000ade4 <__sinit>
8000bc02:	fe c8 dd 12 	sub	r8,pc,-8942
8000bc06:	10 37       	cp.w	r7,r8
8000bc08:	c0 31       	brne	8000bc0e <_fclose_r+0x2e>
8000bc0a:	6c 07       	ld.w	r7,r6[0x0]
8000bc0c:	c0 c8       	rjmp	8000bc24 <_fclose_r+0x44>
8000bc0e:	fe c8 dc fe 	sub	r8,pc,-8962
8000bc12:	10 37       	cp.w	r7,r8
8000bc14:	c0 31       	brne	8000bc1a <_fclose_r+0x3a>
8000bc16:	6c 17       	ld.w	r7,r6[0x4]
8000bc18:	c0 68       	rjmp	8000bc24 <_fclose_r+0x44>
8000bc1a:	fe c8 dc ea 	sub	r8,pc,-8982
8000bc1e:	10 37       	cp.w	r7,r8
8000bc20:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000bc24:	8e 69       	ld.sh	r9,r7[0xc]
8000bc26:	30 08       	mov	r8,0
8000bc28:	f0 09 19 00 	cp.h	r9,r8
8000bc2c:	c0 51       	brne	8000bc36 <_fclose_r+0x56>
8000bc2e:	fe b0 f8 8a 	rcall	8000ad42 <__sfp_lock_release>
8000bc32:	30 05       	mov	r5,0
8000bc34:	c2 f8       	rjmp	8000bc92 <_fclose_r+0xb2>
8000bc36:	0e 9b       	mov	r11,r7
8000bc38:	0c 9c       	mov	r12,r6
8000bc3a:	fe b0 f7 fd 	rcall	8000ac34 <_fflush_r>
8000bc3e:	6e c8       	ld.w	r8,r7[0x30]
8000bc40:	18 95       	mov	r5,r12
8000bc42:	58 08       	cp.w	r8,0
8000bc44:	c0 60       	breq	8000bc50 <_fclose_r+0x70>
8000bc46:	6e 8b       	ld.w	r11,r7[0x20]
8000bc48:	0c 9c       	mov	r12,r6
8000bc4a:	5d 18       	icall	r8
8000bc4c:	f9 b5 05 ff 	movlt	r5,-1
8000bc50:	8e 68       	ld.sh	r8,r7[0xc]
8000bc52:	ed b8 00 07 	bld	r8,0x7
8000bc56:	c0 51       	brne	8000bc60 <_fclose_r+0x80>
8000bc58:	6e 4b       	ld.w	r11,r7[0x10]
8000bc5a:	0c 9c       	mov	r12,r6
8000bc5c:	fe b0 f9 5e 	rcall	8000af18 <_free_r>
8000bc60:	6e db       	ld.w	r11,r7[0x34]
8000bc62:	58 0b       	cp.w	r11,0
8000bc64:	c0 a0       	breq	8000bc78 <_fclose_r+0x98>
8000bc66:	ee c8 ff bc 	sub	r8,r7,-68
8000bc6a:	10 3b       	cp.w	r11,r8
8000bc6c:	c0 40       	breq	8000bc74 <_fclose_r+0x94>
8000bc6e:	0c 9c       	mov	r12,r6
8000bc70:	fe b0 f9 54 	rcall	8000af18 <_free_r>
8000bc74:	30 08       	mov	r8,0
8000bc76:	8f d8       	st.w	r7[0x34],r8
8000bc78:	6f 2b       	ld.w	r11,r7[0x48]
8000bc7a:	58 0b       	cp.w	r11,0
8000bc7c:	c0 70       	breq	8000bc8a <_fclose_r+0xaa>
8000bc7e:	0c 9c       	mov	r12,r6
8000bc80:	fe b0 f9 4c 	rcall	8000af18 <_free_r>
8000bc84:	30 08       	mov	r8,0
8000bc86:	ef 48 00 48 	st.w	r7[72],r8
8000bc8a:	30 08       	mov	r8,0
8000bc8c:	ae 68       	st.h	r7[0xc],r8
8000bc8e:	fe b0 f8 5a 	rcall	8000ad42 <__sfp_lock_release>
8000bc92:	0a 9c       	mov	r12,r5
8000bc94:	d8 22       	popm	r4-r7,pc
8000bc96:	d7 03       	nop

8000bc98 <fclose>:
8000bc98:	d4 01       	pushm	lr
8000bc9a:	e0 68 0a 3c 	mov	r8,2620
8000bc9e:	18 9b       	mov	r11,r12
8000bca0:	70 0c       	ld.w	r12,r8[0x0]
8000bca2:	c9 ff       	rcall	8000bbe0 <_fclose_r>
8000bca4:	d8 02       	popm	pc
8000bca6:	d7 03       	nop

8000bca8 <_fstat_r>:
8000bca8:	d4 21       	pushm	r4-r7,lr
8000bcaa:	16 98       	mov	r8,r11
8000bcac:	18 97       	mov	r7,r12
8000bcae:	10 9c       	mov	r12,r8
8000bcb0:	30 08       	mov	r8,0
8000bcb2:	e0 66 5b 6c 	mov	r6,23404
8000bcb6:	14 9b       	mov	r11,r10
8000bcb8:	8d 08       	st.w	r6[0x0],r8
8000bcba:	fe b0 df 67 	rcall	80007b88 <_fstat>
8000bcbe:	5b fc       	cp.w	r12,-1
8000bcc0:	c0 51       	brne	8000bcca <_fstat_r+0x22>
8000bcc2:	6c 08       	ld.w	r8,r6[0x0]
8000bcc4:	58 08       	cp.w	r8,0
8000bcc6:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bcca:	d8 22       	popm	r4-r7,pc

8000bccc <_lseek_r>:
8000bccc:	d4 21       	pushm	r4-r7,lr
8000bcce:	16 98       	mov	r8,r11
8000bcd0:	18 97       	mov	r7,r12
8000bcd2:	10 9c       	mov	r12,r8
8000bcd4:	30 08       	mov	r8,0
8000bcd6:	14 9b       	mov	r11,r10
8000bcd8:	e0 66 5b 6c 	mov	r6,23404
8000bcdc:	12 9a       	mov	r10,r9
8000bcde:	8d 08       	st.w	r6[0x0],r8
8000bce0:	fe b0 df 36 	rcall	80007b4c <_lseek>
8000bce4:	5b fc       	cp.w	r12,-1
8000bce6:	c0 51       	brne	8000bcf0 <_lseek_r+0x24>
8000bce8:	6c 08       	ld.w	r8,r6[0x0]
8000bcea:	58 08       	cp.w	r8,0
8000bcec:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bcf0:	d8 22       	popm	r4-r7,pc
8000bcf2:	d7 03       	nop

8000bcf4 <_read_r>:
8000bcf4:	d4 21       	pushm	r4-r7,lr
8000bcf6:	16 98       	mov	r8,r11
8000bcf8:	18 97       	mov	r7,r12
8000bcfa:	10 9c       	mov	r12,r8
8000bcfc:	30 08       	mov	r8,0
8000bcfe:	14 9b       	mov	r11,r10
8000bd00:	e0 66 5b 6c 	mov	r6,23404
8000bd04:	12 9a       	mov	r10,r9
8000bd06:	8d 08       	st.w	r6[0x0],r8
8000bd08:	fe b0 d0 a4 	rcall	80005e50 <_read>
8000bd0c:	5b fc       	cp.w	r12,-1
8000bd0e:	c0 51       	brne	8000bd18 <_read_r+0x24>
8000bd10:	6c 08       	ld.w	r8,r6[0x0]
8000bd12:	58 08       	cp.w	r8,0
8000bd14:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bd18:	d8 22       	popm	r4-r7,pc
8000bd1a:	d7 03       	nop

8000bd1c <__avr32_f64_mul>:
8000bd1c:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000bd20:	e0 80 00 dc 	breq	8000bed8 <__avr32_f64_mul_op1_zero>
8000bd24:	d4 21       	pushm	r4-r7,lr
8000bd26:	f7 e9 20 0e 	eor	lr,r11,r9
8000bd2a:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bd2e:	30 15       	mov	r5,1
8000bd30:	c4 30       	breq	8000bdb6 <__avr32_f64_mul_op1_subnormal>
8000bd32:	ab 6b       	lsl	r11,0xa
8000bd34:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000bd38:	ab 6a       	lsl	r10,0xa
8000bd3a:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000bd3e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bd42:	c5 c0       	breq	8000bdfa <__avr32_f64_mul_op2_subnormal>
8000bd44:	a1 78       	lsl	r8,0x1
8000bd46:	5c f9       	rol	r9
8000bd48:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000bd4c:	e0 47 07 ff 	cp.w	r7,2047
8000bd50:	c7 70       	breq	8000be3e <__avr32_f64_mul_op_nan_or_inf>
8000bd52:	e0 46 07 ff 	cp.w	r6,2047
8000bd56:	c7 40       	breq	8000be3e <__avr32_f64_mul_op_nan_or_inf>
8000bd58:	ee 06 00 0c 	add	r12,r7,r6
8000bd5c:	e0 2c 03 fe 	sub	r12,1022
8000bd60:	f6 08 06 44 	mulu.d	r4,r11,r8
8000bd64:	f4 09 07 44 	macu.d	r4,r10,r9
8000bd68:	f4 08 06 46 	mulu.d	r6,r10,r8
8000bd6c:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000bd70:	08 07       	add	r7,r4
8000bd72:	f4 05 00 4a 	adc	r10,r10,r5
8000bd76:	5c 0b       	acr	r11
8000bd78:	ed bb 00 14 	bld	r11,0x14
8000bd7c:	c0 50       	breq	8000bd86 <__avr32_f64_mul+0x6a>
8000bd7e:	a1 77       	lsl	r7,0x1
8000bd80:	5c fa       	rol	r10
8000bd82:	5c fb       	rol	r11
8000bd84:	20 1c       	sub	r12,1
8000bd86:	58 0c       	cp.w	r12,0
8000bd88:	e0 8a 00 6f 	brle	8000be66 <__avr32_f64_mul_res_subnormal>
8000bd8c:	e0 4c 07 ff 	cp.w	r12,2047
8000bd90:	e0 84 00 9c 	brge	8000bec8 <__avr32_f64_mul_res_inf>
8000bd94:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000bd98:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000bd9c:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000bda0:	ee 17 80 00 	eorh	r7,0x8000
8000bda4:	f1 b7 04 20 	satu	r7,0x1
8000bda8:	0e 0a       	add	r10,r7
8000bdaa:	5c 0b       	acr	r11
8000bdac:	ed be 00 1f 	bld	lr,0x1f
8000bdb0:	ef bb 00 1f 	bst	r11,0x1f
8000bdb4:	d8 22       	popm	r4-r7,pc

8000bdb6 <__avr32_f64_mul_op1_subnormal>:
8000bdb6:	e4 1b 00 0f 	andh	r11,0xf
8000bdba:	f4 0c 12 00 	clz	r12,r10
8000bdbe:	f6 06 12 00 	clz	r6,r11
8000bdc2:	f7 bc 03 e1 	sublo	r12,-31
8000bdc6:	f8 06 17 30 	movlo	r6,r12
8000bdca:	f7 b6 02 01 	subhs	r6,1
8000bdce:	e0 46 00 20 	cp.w	r6,32
8000bdd2:	c0 d4       	brge	8000bdec <__avr32_f64_mul_op1_subnormal+0x36>
8000bdd4:	ec 0c 11 20 	rsub	r12,r6,32
8000bdd8:	f6 06 09 4b 	lsl	r11,r11,r6
8000bddc:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000bde0:	18 4b       	or	r11,r12
8000bde2:	f4 06 09 4a 	lsl	r10,r10,r6
8000bde6:	20 b6       	sub	r6,11
8000bde8:	0c 17       	sub	r7,r6
8000bdea:	ca ab       	rjmp	8000bd3e <__avr32_f64_mul+0x22>
8000bdec:	f4 06 09 4b 	lsl	r11,r10,r6
8000bdf0:	c6 40       	breq	8000beb8 <__avr32_f64_mul_res_zero>
8000bdf2:	30 0a       	mov	r10,0
8000bdf4:	20 b6       	sub	r6,11
8000bdf6:	0c 17       	sub	r7,r6
8000bdf8:	ca 3b       	rjmp	8000bd3e <__avr32_f64_mul+0x22>

8000bdfa <__avr32_f64_mul_op2_subnormal>:
8000bdfa:	e4 19 00 0f 	andh	r9,0xf
8000bdfe:	f0 0c 12 00 	clz	r12,r8
8000be02:	f2 05 12 00 	clz	r5,r9
8000be06:	f7 bc 03 ea 	sublo	r12,-22
8000be0a:	f8 05 17 30 	movlo	r5,r12
8000be0e:	f7 b5 02 0a 	subhs	r5,10
8000be12:	e0 45 00 20 	cp.w	r5,32
8000be16:	c0 d4       	brge	8000be30 <__avr32_f64_mul_op2_subnormal+0x36>
8000be18:	ea 0c 11 20 	rsub	r12,r5,32
8000be1c:	f2 05 09 49 	lsl	r9,r9,r5
8000be20:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000be24:	18 49       	or	r9,r12
8000be26:	f0 05 09 48 	lsl	r8,r8,r5
8000be2a:	20 25       	sub	r5,2
8000be2c:	0a 16       	sub	r6,r5
8000be2e:	c8 fb       	rjmp	8000bd4c <__avr32_f64_mul+0x30>
8000be30:	f0 05 09 49 	lsl	r9,r8,r5
8000be34:	c4 20       	breq	8000beb8 <__avr32_f64_mul_res_zero>
8000be36:	30 08       	mov	r8,0
8000be38:	20 25       	sub	r5,2
8000be3a:	0a 16       	sub	r6,r5
8000be3c:	c8 8b       	rjmp	8000bd4c <__avr32_f64_mul+0x30>

8000be3e <__avr32_f64_mul_op_nan_or_inf>:
8000be3e:	e4 19 00 0f 	andh	r9,0xf
8000be42:	e4 1b 00 0f 	andh	r11,0xf
8000be46:	14 4b       	or	r11,r10
8000be48:	10 49       	or	r9,r8
8000be4a:	e0 47 07 ff 	cp.w	r7,2047
8000be4e:	c0 91       	brne	8000be60 <__avr32_f64_mul_op1_not_naninf>
8000be50:	58 0b       	cp.w	r11,0
8000be52:	c3 81       	brne	8000bec2 <__avr32_f64_mul_res_nan>
8000be54:	e0 46 07 ff 	cp.w	r6,2047
8000be58:	c3 81       	brne	8000bec8 <__avr32_f64_mul_res_inf>
8000be5a:	58 09       	cp.w	r9,0
8000be5c:	c3 60       	breq	8000bec8 <__avr32_f64_mul_res_inf>
8000be5e:	c3 28       	rjmp	8000bec2 <__avr32_f64_mul_res_nan>

8000be60 <__avr32_f64_mul_op1_not_naninf>:
8000be60:	58 09       	cp.w	r9,0
8000be62:	c3 30       	breq	8000bec8 <__avr32_f64_mul_res_inf>
8000be64:	c2 f8       	rjmp	8000bec2 <__avr32_f64_mul_res_nan>

8000be66 <__avr32_f64_mul_res_subnormal>:
8000be66:	5c 3c       	neg	r12
8000be68:	2f fc       	sub	r12,-1
8000be6a:	f1 bc 04 c0 	satu	r12,0x6
8000be6e:	e0 4c 00 20 	cp.w	r12,32
8000be72:	c1 14       	brge	8000be94 <__avr32_f64_mul_res_subnormal+0x2e>
8000be74:	f8 08 11 20 	rsub	r8,r12,32
8000be78:	0e 46       	or	r6,r7
8000be7a:	ee 0c 0a 47 	lsr	r7,r7,r12
8000be7e:	f4 08 09 49 	lsl	r9,r10,r8
8000be82:	12 47       	or	r7,r9
8000be84:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000be88:	f6 08 09 49 	lsl	r9,r11,r8
8000be8c:	12 4a       	or	r10,r9
8000be8e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000be92:	c8 3b       	rjmp	8000bd98 <__avr32_f64_mul+0x7c>
8000be94:	f8 08 11 20 	rsub	r8,r12,32
8000be98:	f9 b9 00 00 	moveq	r9,0
8000be9c:	c0 30       	breq	8000bea2 <__avr32_f64_mul_res_subnormal+0x3c>
8000be9e:	f6 08 09 49 	lsl	r9,r11,r8
8000bea2:	0e 46       	or	r6,r7
8000bea4:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000bea8:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000beac:	f3 ea 10 07 	or	r7,r9,r10
8000beb0:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000beb4:	30 0b       	mov	r11,0
8000beb6:	c7 1b       	rjmp	8000bd98 <__avr32_f64_mul+0x7c>

8000beb8 <__avr32_f64_mul_res_zero>:
8000beb8:	1c 9b       	mov	r11,lr
8000beba:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bebe:	30 0a       	mov	r10,0
8000bec0:	d8 22       	popm	r4-r7,pc

8000bec2 <__avr32_f64_mul_res_nan>:
8000bec2:	3f fb       	mov	r11,-1
8000bec4:	3f fa       	mov	r10,-1
8000bec6:	d8 22       	popm	r4-r7,pc

8000bec8 <__avr32_f64_mul_res_inf>:
8000bec8:	f0 6b 00 00 	mov	r11,-1048576
8000becc:	ed be 00 1f 	bld	lr,0x1f
8000bed0:	ef bb 00 1f 	bst	r11,0x1f
8000bed4:	30 0a       	mov	r10,0
8000bed6:	d8 22       	popm	r4-r7,pc

8000bed8 <__avr32_f64_mul_op1_zero>:
8000bed8:	f7 e9 20 0b 	eor	r11,r11,r9
8000bedc:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bee0:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000bee4:	e0 4c 07 ff 	cp.w	r12,2047
8000bee8:	5e 1c       	retne	r12
8000beea:	3f fa       	mov	r10,-1
8000beec:	3f fb       	mov	r11,-1
8000beee:	5e fc       	retal	r12

8000bef0 <__avr32_f64_sub_from_add>:
8000bef0:	ee 19 80 00 	eorh	r9,0x8000

8000bef4 <__avr32_f64_sub>:
8000bef4:	f7 e9 20 0c 	eor	r12,r11,r9
8000bef8:	e0 86 00 ca 	brmi	8000c08c <__avr32_f64_add_from_sub>
8000befc:	eb cd 40 e0 	pushm	r5-r7,lr
8000bf00:	16 9c       	mov	r12,r11
8000bf02:	e6 1c 80 00 	andh	r12,0x8000,COH
8000bf06:	bf db       	cbr	r11,0x1f
8000bf08:	bf d9       	cbr	r9,0x1f
8000bf0a:	10 3a       	cp.w	r10,r8
8000bf0c:	f2 0b 13 00 	cpc	r11,r9
8000bf10:	c0 92       	brcc	8000bf22 <__avr32_f64_sub+0x2e>
8000bf12:	16 97       	mov	r7,r11
8000bf14:	12 9b       	mov	r11,r9
8000bf16:	0e 99       	mov	r9,r7
8000bf18:	14 97       	mov	r7,r10
8000bf1a:	10 9a       	mov	r10,r8
8000bf1c:	0e 98       	mov	r8,r7
8000bf1e:	ee 1c 80 00 	eorh	r12,0x8000
8000bf22:	f6 07 16 14 	lsr	r7,r11,0x14
8000bf26:	ab 7b       	lsl	r11,0xb
8000bf28:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bf2c:	ab 7a       	lsl	r10,0xb
8000bf2e:	bf bb       	sbr	r11,0x1f
8000bf30:	f2 06 16 14 	lsr	r6,r9,0x14
8000bf34:	c4 40       	breq	8000bfbc <__avr32_f64_sub_opL_subnormal>
8000bf36:	ab 79       	lsl	r9,0xb
8000bf38:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bf3c:	ab 78       	lsl	r8,0xb
8000bf3e:	bf b9       	sbr	r9,0x1f

8000bf40 <__avr32_f64_sub_opL_subnormal_done>:
8000bf40:	e0 47 07 ff 	cp.w	r7,2047
8000bf44:	c4 f0       	breq	8000bfe2 <__avr32_f64_sub_opH_nan_or_inf>
8000bf46:	0e 26       	rsub	r6,r7
8000bf48:	c1 20       	breq	8000bf6c <__avr32_f64_sub_shift_done>
8000bf4a:	ec 05 11 20 	rsub	r5,r6,32
8000bf4e:	e0 46 00 20 	cp.w	r6,32
8000bf52:	c7 c2       	brcc	8000c04a <__avr32_f64_sub_longshift>
8000bf54:	f0 05 09 4e 	lsl	lr,r8,r5
8000bf58:	f2 05 09 45 	lsl	r5,r9,r5
8000bf5c:	f0 06 0a 48 	lsr	r8,r8,r6
8000bf60:	f2 06 0a 49 	lsr	r9,r9,r6
8000bf64:	0a 48       	or	r8,r5
8000bf66:	58 0e       	cp.w	lr,0
8000bf68:	5f 1e       	srne	lr
8000bf6a:	1c 48       	or	r8,lr

8000bf6c <__avr32_f64_sub_shift_done>:
8000bf6c:	10 1a       	sub	r10,r8
8000bf6e:	f6 09 01 4b 	sbc	r11,r11,r9
8000bf72:	f6 06 12 00 	clz	r6,r11
8000bf76:	c0 e0       	breq	8000bf92 <__avr32_f64_sub_longnormalize_done>
8000bf78:	c7 83       	brcs	8000c068 <__avr32_f64_sub_longnormalize>
8000bf7a:	ec 0e 11 20 	rsub	lr,r6,32
8000bf7e:	f6 06 09 4b 	lsl	r11,r11,r6
8000bf82:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bf86:	1c 4b       	or	r11,lr
8000bf88:	f4 06 09 4a 	lsl	r10,r10,r6
8000bf8c:	0c 17       	sub	r7,r6
8000bf8e:	e0 8a 00 39 	brle	8000c000 <__avr32_f64_sub_subnormal_result>

8000bf92 <__avr32_f64_sub_longnormalize_done>:
8000bf92:	f4 09 15 15 	lsl	r9,r10,0x15
8000bf96:	ab 9a       	lsr	r10,0xb
8000bf98:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bf9c:	ab 9b       	lsr	r11,0xb
8000bf9e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bfa2:	18 4b       	or	r11,r12

8000bfa4 <__avr32_f64_sub_round>:
8000bfa4:	fc 17 80 00 	movh	r7,0x8000
8000bfa8:	ed ba 00 00 	bld	r10,0x0
8000bfac:	f7 b7 01 ff 	subne	r7,-1
8000bfb0:	0e 39       	cp.w	r9,r7
8000bfb2:	5f 29       	srhs	r9
8000bfb4:	12 0a       	add	r10,r9
8000bfb6:	5c 0b       	acr	r11
8000bfb8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bfbc <__avr32_f64_sub_opL_subnormal>:
8000bfbc:	ab 79       	lsl	r9,0xb
8000bfbe:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bfc2:	ab 78       	lsl	r8,0xb
8000bfc4:	f3 e8 10 0e 	or	lr,r9,r8
8000bfc8:	f9 b6 01 01 	movne	r6,1
8000bfcc:	ee 0e 11 00 	rsub	lr,r7,0
8000bfd0:	f9 b7 00 01 	moveq	r7,1
8000bfd4:	ef bb 00 1f 	bst	r11,0x1f
8000bfd8:	f7 ea 10 0e 	or	lr,r11,r10
8000bfdc:	f9 b7 00 00 	moveq	r7,0
8000bfe0:	cb 0b       	rjmp	8000bf40 <__avr32_f64_sub_opL_subnormal_done>

8000bfe2 <__avr32_f64_sub_opH_nan_or_inf>:
8000bfe2:	bf db       	cbr	r11,0x1f
8000bfe4:	f7 ea 10 0e 	or	lr,r11,r10
8000bfe8:	c0 81       	brne	8000bff8 <__avr32_f64_sub_return_nan>
8000bfea:	e0 46 07 ff 	cp.w	r6,2047
8000bfee:	c0 50       	breq	8000bff8 <__avr32_f64_sub_return_nan>
8000bff0:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000bff4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bff8 <__avr32_f64_sub_return_nan>:
8000bff8:	3f fa       	mov	r10,-1
8000bffa:	3f fb       	mov	r11,-1
8000bffc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c000 <__avr32_f64_sub_subnormal_result>:
8000c000:	5c 37       	neg	r7
8000c002:	2f f7       	sub	r7,-1
8000c004:	f1 b7 04 c0 	satu	r7,0x6
8000c008:	e0 47 00 20 	cp.w	r7,32
8000c00c:	c1 14       	brge	8000c02e <__avr32_f64_sub_subnormal_result+0x2e>
8000c00e:	ee 08 11 20 	rsub	r8,r7,32
8000c012:	f4 08 09 49 	lsl	r9,r10,r8
8000c016:	5f 16       	srne	r6
8000c018:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c01c:	0c 4a       	or	r10,r6
8000c01e:	f6 08 09 49 	lsl	r9,r11,r8
8000c022:	f5 e9 10 0a 	or	r10,r10,r9
8000c026:	f4 07 0a 4b 	lsr	r11,r10,r7
8000c02a:	30 07       	mov	r7,0
8000c02c:	cb 3b       	rjmp	8000bf92 <__avr32_f64_sub_longnormalize_done>
8000c02e:	ee 08 11 40 	rsub	r8,r7,64
8000c032:	f6 08 09 49 	lsl	r9,r11,r8
8000c036:	14 49       	or	r9,r10
8000c038:	5f 16       	srne	r6
8000c03a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c03e:	0c 4a       	or	r10,r6
8000c040:	30 0b       	mov	r11,0
8000c042:	30 07       	mov	r7,0
8000c044:	ca 7b       	rjmp	8000bf92 <__avr32_f64_sub_longnormalize_done>
8000c046:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c04a <__avr32_f64_sub_longshift>:
8000c04a:	f1 b6 04 c0 	satu	r6,0x6
8000c04e:	f0 0e 17 00 	moveq	lr,r8
8000c052:	c0 40       	breq	8000c05a <__avr32_f64_sub_longshift+0x10>
8000c054:	f2 05 09 4e 	lsl	lr,r9,r5
8000c058:	10 4e       	or	lr,r8
8000c05a:	f2 06 0a 48 	lsr	r8,r9,r6
8000c05e:	30 09       	mov	r9,0
8000c060:	58 0e       	cp.w	lr,0
8000c062:	5f 1e       	srne	lr
8000c064:	1c 48       	or	r8,lr
8000c066:	c8 3b       	rjmp	8000bf6c <__avr32_f64_sub_shift_done>

8000c068 <__avr32_f64_sub_longnormalize>:
8000c068:	f4 06 12 00 	clz	r6,r10
8000c06c:	f9 b7 03 00 	movlo	r7,0
8000c070:	f9 b6 03 00 	movlo	r6,0
8000c074:	f9 bc 03 00 	movlo	r12,0
8000c078:	f7 b6 02 e0 	subhs	r6,-32
8000c07c:	f4 06 09 4b 	lsl	r11,r10,r6
8000c080:	30 0a       	mov	r10,0
8000c082:	0c 17       	sub	r7,r6
8000c084:	fe 9a ff be 	brle	8000c000 <__avr32_f64_sub_subnormal_result>
8000c088:	c8 5b       	rjmp	8000bf92 <__avr32_f64_sub_longnormalize_done>
8000c08a:	d7 03       	nop

8000c08c <__avr32_f64_add_from_sub>:
8000c08c:	ee 19 80 00 	eorh	r9,0x8000

8000c090 <__avr32_f64_add>:
8000c090:	f7 e9 20 0c 	eor	r12,r11,r9
8000c094:	fe 96 ff 2e 	brmi	8000bef0 <__avr32_f64_sub_from_add>
8000c098:	eb cd 40 e0 	pushm	r5-r7,lr
8000c09c:	16 9c       	mov	r12,r11
8000c09e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c0a2:	bf db       	cbr	r11,0x1f
8000c0a4:	bf d9       	cbr	r9,0x1f
8000c0a6:	12 3b       	cp.w	r11,r9
8000c0a8:	c0 72       	brcc	8000c0b6 <__avr32_f64_add+0x26>
8000c0aa:	16 97       	mov	r7,r11
8000c0ac:	12 9b       	mov	r11,r9
8000c0ae:	0e 99       	mov	r9,r7
8000c0b0:	14 97       	mov	r7,r10
8000c0b2:	10 9a       	mov	r10,r8
8000c0b4:	0e 98       	mov	r8,r7
8000c0b6:	30 0e       	mov	lr,0
8000c0b8:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c0bc:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000c0c0:	b5 ab       	sbr	r11,0x14
8000c0c2:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c0c6:	c6 20       	breq	8000c18a <__avr32_f64_add_op2_subnormal>
8000c0c8:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000c0cc:	b5 a9       	sbr	r9,0x14
8000c0ce:	e0 47 07 ff 	cp.w	r7,2047
8000c0d2:	c2 80       	breq	8000c122 <__avr32_f64_add_opH_nan_or_inf>
8000c0d4:	0e 26       	rsub	r6,r7
8000c0d6:	c1 20       	breq	8000c0fa <__avr32_f64_add_shift_done>
8000c0d8:	e0 46 00 36 	cp.w	r6,54
8000c0dc:	c1 52       	brcc	8000c106 <__avr32_f64_add_res_of_done>
8000c0de:	ec 05 11 20 	rsub	r5,r6,32
8000c0e2:	e0 46 00 20 	cp.w	r6,32
8000c0e6:	c3 52       	brcc	8000c150 <__avr32_f64_add_longshift>
8000c0e8:	f0 05 09 4e 	lsl	lr,r8,r5
8000c0ec:	f2 05 09 45 	lsl	r5,r9,r5
8000c0f0:	f0 06 0a 48 	lsr	r8,r8,r6
8000c0f4:	f2 06 0a 49 	lsr	r9,r9,r6
8000c0f8:	0a 48       	or	r8,r5

8000c0fa <__avr32_f64_add_shift_done>:
8000c0fa:	10 0a       	add	r10,r8
8000c0fc:	f6 09 00 4b 	adc	r11,r11,r9
8000c100:	ed bb 00 15 	bld	r11,0x15
8000c104:	c3 40       	breq	8000c16c <__avr32_f64_add_res_of>

8000c106 <__avr32_f64_add_res_of_done>:
8000c106:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c10a:	18 4b       	or	r11,r12

8000c10c <__avr32_f64_add_round>:
8000c10c:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c110:	18 4e       	or	lr,r12
8000c112:	ee 1e 80 00 	eorh	lr,0x8000
8000c116:	f1 be 04 20 	satu	lr,0x1
8000c11a:	1c 0a       	add	r10,lr
8000c11c:	5c 0b       	acr	r11
8000c11e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c122 <__avr32_f64_add_opH_nan_or_inf>:
8000c122:	b5 cb       	cbr	r11,0x14
8000c124:	f7 ea 10 0e 	or	lr,r11,r10
8000c128:	c1 01       	brne	8000c148 <__avr32_f64_add_return_nan>
8000c12a:	e0 46 07 ff 	cp.w	r6,2047
8000c12e:	c0 30       	breq	8000c134 <__avr32_f64_add_opL_nan_or_inf>
8000c130:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c134 <__avr32_f64_add_opL_nan_or_inf>:
8000c134:	b5 c9       	cbr	r9,0x14
8000c136:	f3 e8 10 0e 	or	lr,r9,r8
8000c13a:	c0 71       	brne	8000c148 <__avr32_f64_add_return_nan>
8000c13c:	30 0a       	mov	r10,0
8000c13e:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c142:	18 4b       	or	r11,r12
8000c144:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c148 <__avr32_f64_add_return_nan>:
8000c148:	3f fa       	mov	r10,-1
8000c14a:	3f fb       	mov	r11,-1
8000c14c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c150 <__avr32_f64_add_longshift>:
8000c150:	f1 b6 04 c0 	satu	r6,0x6
8000c154:	f0 0e 17 00 	moveq	lr,r8
8000c158:	c0 60       	breq	8000c164 <__avr32_f64_add_longshift+0x14>
8000c15a:	f2 05 09 4e 	lsl	lr,r9,r5
8000c15e:	58 08       	cp.w	r8,0
8000c160:	5f 18       	srne	r8
8000c162:	10 4e       	or	lr,r8
8000c164:	f2 06 0a 48 	lsr	r8,r9,r6
8000c168:	30 09       	mov	r9,0
8000c16a:	cc 8b       	rjmp	8000c0fa <__avr32_f64_add_shift_done>

8000c16c <__avr32_f64_add_res_of>:
8000c16c:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c170:	a1 9b       	lsr	r11,0x1
8000c172:	5d 0a       	ror	r10
8000c174:	5d 0e       	ror	lr
8000c176:	2f f7       	sub	r7,-1
8000c178:	e0 47 07 ff 	cp.w	r7,2047
8000c17c:	f9 ba 00 00 	moveq	r10,0
8000c180:	f9 bb 00 00 	moveq	r11,0
8000c184:	f9 be 00 00 	moveq	lr,0
8000c188:	cb fb       	rjmp	8000c106 <__avr32_f64_add_res_of_done>

8000c18a <__avr32_f64_add_op2_subnormal>:
8000c18a:	30 16       	mov	r6,1
8000c18c:	58 07       	cp.w	r7,0
8000c18e:	ca 01       	brne	8000c0ce <__avr32_f64_add+0x3e>
8000c190:	b5 cb       	cbr	r11,0x14
8000c192:	10 0a       	add	r10,r8
8000c194:	f6 09 00 4b 	adc	r11,r11,r9
8000c198:	18 4b       	or	r11,r12
8000c19a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000c19e:	d7 03       	nop

8000c1a0 <__avr32_f64_to_u32>:
8000c1a0:	58 0b       	cp.w	r11,0
8000c1a2:	5e 6d       	retmi	0

8000c1a4 <__avr32_f64_to_s32>:
8000c1a4:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c1a8:	b5 9c       	lsr	r12,0x15
8000c1aa:	e0 2c 03 ff 	sub	r12,1023
8000c1ae:	5e 3d       	retlo	0
8000c1b0:	f8 0c 11 1f 	rsub	r12,r12,31
8000c1b4:	16 99       	mov	r9,r11
8000c1b6:	ab 7b       	lsl	r11,0xb
8000c1b8:	bf bb       	sbr	r11,0x1f
8000c1ba:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c1be:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c1c2:	a1 79       	lsl	r9,0x1
8000c1c4:	5e 2b       	reths	r11
8000c1c6:	5c 3b       	neg	r11
8000c1c8:	5e fb       	retal	r11

8000c1ca <__avr32_u32_to_f64>:
8000c1ca:	f8 cb 00 00 	sub	r11,r12,0
8000c1ce:	30 0c       	mov	r12,0
8000c1d0:	c0 38       	rjmp	8000c1d6 <__avr32_s32_to_f64+0x4>

8000c1d2 <__avr32_s32_to_f64>:
8000c1d2:	18 9b       	mov	r11,r12
8000c1d4:	5c 4b       	abs	r11
8000c1d6:	30 0a       	mov	r10,0
8000c1d8:	5e 0b       	reteq	r11
8000c1da:	d4 01       	pushm	lr
8000c1dc:	e0 69 04 1e 	mov	r9,1054
8000c1e0:	f6 08 12 00 	clz	r8,r11
8000c1e4:	c1 70       	breq	8000c212 <__avr32_s32_to_f64+0x40>
8000c1e6:	c0 c3       	brcs	8000c1fe <__avr32_s32_to_f64+0x2c>
8000c1e8:	f0 0e 11 20 	rsub	lr,r8,32
8000c1ec:	f6 08 09 4b 	lsl	r11,r11,r8
8000c1f0:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c1f4:	1c 4b       	or	r11,lr
8000c1f6:	f4 08 09 4a 	lsl	r10,r10,r8
8000c1fa:	10 19       	sub	r9,r8
8000c1fc:	c0 b8       	rjmp	8000c212 <__avr32_s32_to_f64+0x40>
8000c1fe:	f4 08 12 00 	clz	r8,r10
8000c202:	f9 b8 03 00 	movlo	r8,0
8000c206:	f7 b8 02 e0 	subhs	r8,-32
8000c20a:	f4 08 09 4b 	lsl	r11,r10,r8
8000c20e:	30 0a       	mov	r10,0
8000c210:	10 19       	sub	r9,r8
8000c212:	58 09       	cp.w	r9,0
8000c214:	e0 89 00 30 	brgt	8000c274 <__avr32_s32_to_f64+0xa2>
8000c218:	5c 39       	neg	r9
8000c21a:	2f f9       	sub	r9,-1
8000c21c:	e0 49 00 36 	cp.w	r9,54
8000c220:	c0 43       	brcs	8000c228 <__avr32_s32_to_f64+0x56>
8000c222:	30 0b       	mov	r11,0
8000c224:	30 0a       	mov	r10,0
8000c226:	c2 68       	rjmp	8000c272 <__avr32_s32_to_f64+0xa0>
8000c228:	2f 69       	sub	r9,-10
8000c22a:	f2 08 11 20 	rsub	r8,r9,32
8000c22e:	e0 49 00 20 	cp.w	r9,32
8000c232:	c0 b2       	brcc	8000c248 <__avr32_s32_to_f64+0x76>
8000c234:	f4 08 09 4e 	lsl	lr,r10,r8
8000c238:	f6 08 09 48 	lsl	r8,r11,r8
8000c23c:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c240:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c244:	10 4b       	or	r11,r8
8000c246:	c0 88       	rjmp	8000c256 <__avr32_s32_to_f64+0x84>
8000c248:	f6 08 09 4e 	lsl	lr,r11,r8
8000c24c:	14 4e       	or	lr,r10
8000c24e:	16 9a       	mov	r10,r11
8000c250:	30 0b       	mov	r11,0
8000c252:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c256:	ed ba 00 00 	bld	r10,0x0
8000c25a:	c0 92       	brcc	8000c26c <__avr32_s32_to_f64+0x9a>
8000c25c:	1c 7e       	tst	lr,lr
8000c25e:	c0 41       	brne	8000c266 <__avr32_s32_to_f64+0x94>
8000c260:	ed ba 00 01 	bld	r10,0x1
8000c264:	c0 42       	brcc	8000c26c <__avr32_s32_to_f64+0x9a>
8000c266:	2f fa       	sub	r10,-1
8000c268:	f7 bb 02 ff 	subhs	r11,-1
8000c26c:	5c fc       	rol	r12
8000c26e:	5d 0b       	ror	r11
8000c270:	5d 0a       	ror	r10
8000c272:	d8 02       	popm	pc
8000c274:	e0 68 03 ff 	mov	r8,1023
8000c278:	ed ba 00 0b 	bld	r10,0xb
8000c27c:	f7 b8 00 ff 	subeq	r8,-1
8000c280:	10 0a       	add	r10,r8
8000c282:	5c 0b       	acr	r11
8000c284:	f7 b9 03 fe 	sublo	r9,-2
8000c288:	e0 49 07 ff 	cp.w	r9,2047
8000c28c:	c0 55       	brlt	8000c296 <__avr32_s32_to_f64+0xc4>
8000c28e:	30 0a       	mov	r10,0
8000c290:	fc 1b ff e0 	movh	r11,0xffe0
8000c294:	c0 c8       	rjmp	8000c2ac <__floatsidf_return_op1>
8000c296:	ed bb 00 1f 	bld	r11,0x1f
8000c29a:	f7 b9 01 01 	subne	r9,1
8000c29e:	ab 9a       	lsr	r10,0xb
8000c2a0:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c2a4:	a1 7b       	lsl	r11,0x1
8000c2a6:	ab 9b       	lsr	r11,0xb
8000c2a8:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c2ac <__floatsidf_return_op1>:
8000c2ac:	a1 7c       	lsl	r12,0x1
8000c2ae:	5d 0b       	ror	r11
8000c2b0:	d8 02       	popm	pc

8000c2b2 <__avr32_f64_cmp_eq>:
8000c2b2:	10 3a       	cp.w	r10,r8
8000c2b4:	f2 0b 13 00 	cpc	r11,r9
8000c2b8:	c0 80       	breq	8000c2c8 <__avr32_f64_cmp_eq+0x16>
8000c2ba:	a1 7b       	lsl	r11,0x1
8000c2bc:	a1 79       	lsl	r9,0x1
8000c2be:	14 4b       	or	r11,r10
8000c2c0:	12 4b       	or	r11,r9
8000c2c2:	10 4b       	or	r11,r8
8000c2c4:	5e 0f       	reteq	1
8000c2c6:	5e fd       	retal	0
8000c2c8:	a1 7b       	lsl	r11,0x1
8000c2ca:	fc 1c ff e0 	movh	r12,0xffe0
8000c2ce:	58 0a       	cp.w	r10,0
8000c2d0:	f8 0b 13 00 	cpc	r11,r12
8000c2d4:	5e 8f       	retls	1
8000c2d6:	5e fd       	retal	0

8000c2d8 <__avr32_f64_cmp_ge>:
8000c2d8:	1a de       	st.w	--sp,lr
8000c2da:	1a d7       	st.w	--sp,r7
8000c2dc:	a1 7b       	lsl	r11,0x1
8000c2de:	5f 3c       	srlo	r12
8000c2e0:	a1 79       	lsl	r9,0x1
8000c2e2:	5f 37       	srlo	r7
8000c2e4:	5c fc       	rol	r12
8000c2e6:	fc 1e ff e0 	movh	lr,0xffe0
8000c2ea:	58 0a       	cp.w	r10,0
8000c2ec:	fc 0b 13 00 	cpc	r11,lr
8000c2f0:	e0 8b 00 1d 	brhi	8000c32a <__avr32_f64_cmp_ge+0x52>
8000c2f4:	58 08       	cp.w	r8,0
8000c2f6:	fc 09 13 00 	cpc	r9,lr
8000c2fa:	e0 8b 00 18 	brhi	8000c32a <__avr32_f64_cmp_ge+0x52>
8000c2fe:	58 0b       	cp.w	r11,0
8000c300:	f5 ba 00 00 	subfeq	r10,0
8000c304:	c1 50       	breq	8000c32e <__avr32_f64_cmp_ge+0x56>
8000c306:	1b 07       	ld.w	r7,sp++
8000c308:	1b 0e       	ld.w	lr,sp++
8000c30a:	58 3c       	cp.w	r12,3
8000c30c:	c0 a0       	breq	8000c320 <__avr32_f64_cmp_ge+0x48>
8000c30e:	58 1c       	cp.w	r12,1
8000c310:	c0 33       	brcs	8000c316 <__avr32_f64_cmp_ge+0x3e>
8000c312:	5e 0f       	reteq	1
8000c314:	5e 1d       	retne	0
8000c316:	10 3a       	cp.w	r10,r8
8000c318:	f2 0b 13 00 	cpc	r11,r9
8000c31c:	5e 2f       	reths	1
8000c31e:	5e 3d       	retlo	0
8000c320:	14 38       	cp.w	r8,r10
8000c322:	f6 09 13 00 	cpc	r9,r11
8000c326:	5e 2f       	reths	1
8000c328:	5e 3d       	retlo	0
8000c32a:	1b 07       	ld.w	r7,sp++
8000c32c:	d8 0a       	popm	pc,r12=0
8000c32e:	58 17       	cp.w	r7,1
8000c330:	5f 0c       	sreq	r12
8000c332:	58 09       	cp.w	r9,0
8000c334:	f5 b8 00 00 	subfeq	r8,0
8000c338:	1b 07       	ld.w	r7,sp++
8000c33a:	1b 0e       	ld.w	lr,sp++
8000c33c:	5e 0f       	reteq	1
8000c33e:	5e fc       	retal	r12

8000c340 <__avr32_f64_cmp_lt>:
8000c340:	1a de       	st.w	--sp,lr
8000c342:	1a d7       	st.w	--sp,r7
8000c344:	a1 7b       	lsl	r11,0x1
8000c346:	5f 3c       	srlo	r12
8000c348:	a1 79       	lsl	r9,0x1
8000c34a:	5f 37       	srlo	r7
8000c34c:	5c fc       	rol	r12
8000c34e:	fc 1e ff e0 	movh	lr,0xffe0
8000c352:	58 0a       	cp.w	r10,0
8000c354:	fc 0b 13 00 	cpc	r11,lr
8000c358:	e0 8b 00 1d 	brhi	8000c392 <__avr32_f64_cmp_lt+0x52>
8000c35c:	58 08       	cp.w	r8,0
8000c35e:	fc 09 13 00 	cpc	r9,lr
8000c362:	e0 8b 00 18 	brhi	8000c392 <__avr32_f64_cmp_lt+0x52>
8000c366:	58 0b       	cp.w	r11,0
8000c368:	f5 ba 00 00 	subfeq	r10,0
8000c36c:	c1 50       	breq	8000c396 <__avr32_f64_cmp_lt+0x56>
8000c36e:	1b 07       	ld.w	r7,sp++
8000c370:	1b 0e       	ld.w	lr,sp++
8000c372:	58 3c       	cp.w	r12,3
8000c374:	c0 a0       	breq	8000c388 <__avr32_f64_cmp_lt+0x48>
8000c376:	58 1c       	cp.w	r12,1
8000c378:	c0 33       	brcs	8000c37e <__avr32_f64_cmp_lt+0x3e>
8000c37a:	5e 0d       	reteq	0
8000c37c:	5e 1f       	retne	1
8000c37e:	10 3a       	cp.w	r10,r8
8000c380:	f2 0b 13 00 	cpc	r11,r9
8000c384:	5e 2d       	reths	0
8000c386:	5e 3f       	retlo	1
8000c388:	14 38       	cp.w	r8,r10
8000c38a:	f6 09 13 00 	cpc	r9,r11
8000c38e:	5e 2d       	reths	0
8000c390:	5e 3f       	retlo	1
8000c392:	1b 07       	ld.w	r7,sp++
8000c394:	d8 0a       	popm	pc,r12=0
8000c396:	58 17       	cp.w	r7,1
8000c398:	5f 1c       	srne	r12
8000c39a:	58 09       	cp.w	r9,0
8000c39c:	f5 b8 00 00 	subfeq	r8,0
8000c3a0:	1b 07       	ld.w	r7,sp++
8000c3a2:	1b 0e       	ld.w	lr,sp++
8000c3a4:	5e 0d       	reteq	0
8000c3a6:	5e fc       	retal	r12

8000c3a8 <__avr32_f64_div>:
8000c3a8:	eb cd 40 ff 	pushm	r0-r7,lr
8000c3ac:	f7 e9 20 0e 	eor	lr,r11,r9
8000c3b0:	f6 07 16 14 	lsr	r7,r11,0x14
8000c3b4:	a9 7b       	lsl	r11,0x9
8000c3b6:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c3ba:	a9 7a       	lsl	r10,0x9
8000c3bc:	bd bb       	sbr	r11,0x1d
8000c3be:	e4 1b 3f ff 	andh	r11,0x3fff
8000c3c2:	ab d7       	cbr	r7,0xb
8000c3c4:	e0 80 00 cc 	breq	8000c55c <__avr32_f64_div_round_subnormal+0x54>
8000c3c8:	e0 47 07 ff 	cp.w	r7,2047
8000c3cc:	e0 84 00 b5 	brge	8000c536 <__avr32_f64_div_round_subnormal+0x2e>
8000c3d0:	f2 06 16 14 	lsr	r6,r9,0x14
8000c3d4:	a9 79       	lsl	r9,0x9
8000c3d6:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c3da:	a9 78       	lsl	r8,0x9
8000c3dc:	bd b9       	sbr	r9,0x1d
8000c3de:	e4 19 3f ff 	andh	r9,0x3fff
8000c3e2:	ab d6       	cbr	r6,0xb
8000c3e4:	e0 80 00 e2 	breq	8000c5a8 <__avr32_f64_div_round_subnormal+0xa0>
8000c3e8:	e0 46 07 ff 	cp.w	r6,2047
8000c3ec:	e0 84 00 b2 	brge	8000c550 <__avr32_f64_div_round_subnormal+0x48>
8000c3f0:	0c 17       	sub	r7,r6
8000c3f2:	fe 37 fc 01 	sub	r7,-1023
8000c3f6:	fc 1c 80 00 	movh	r12,0x8000
8000c3fa:	f8 03 16 01 	lsr	r3,r12,0x1
8000c3fe:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c402:	5c d4       	com	r4
8000c404:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c408:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c40c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c410:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c414:	ea 03 15 02 	lsl	r3,r5,0x2
8000c418:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c41c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c420:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c424:	ea 03 15 02 	lsl	r3,r5,0x2
8000c428:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c42c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c430:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c434:	ea 03 15 02 	lsl	r3,r5,0x2
8000c438:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c43c:	e4 09 07 40 	macu.d	r0,r2,r9
8000c440:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c444:	02 04       	add	r4,r1
8000c446:	5c 05       	acr	r5
8000c448:	a3 65       	lsl	r5,0x2
8000c44a:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c44e:	a3 64       	lsl	r4,0x2
8000c450:	5c 34       	neg	r4
8000c452:	f8 05 01 45 	sbc	r5,r12,r5
8000c456:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c45a:	e4 05 07 40 	macu.d	r0,r2,r5
8000c45e:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c462:	02 04       	add	r4,r1
8000c464:	5c 05       	acr	r5
8000c466:	ea 03 15 02 	lsl	r3,r5,0x2
8000c46a:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c46e:	e8 02 15 02 	lsl	r2,r4,0x2
8000c472:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c476:	e4 09 07 40 	macu.d	r0,r2,r9
8000c47a:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c47e:	02 04       	add	r4,r1
8000c480:	5c 05       	acr	r5
8000c482:	a3 65       	lsl	r5,0x2
8000c484:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c488:	a3 64       	lsl	r4,0x2
8000c48a:	5c 34       	neg	r4
8000c48c:	f8 05 01 45 	sbc	r5,r12,r5
8000c490:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c494:	e4 05 07 40 	macu.d	r0,r2,r5
8000c498:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c49c:	02 04       	add	r4,r1
8000c49e:	5c 05       	acr	r5
8000c4a0:	ea 03 15 02 	lsl	r3,r5,0x2
8000c4a4:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c4a8:	e8 02 15 02 	lsl	r2,r4,0x2
8000c4ac:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c4b0:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c4b4:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c4b8:	02 02       	add	r2,r1
8000c4ba:	5c 03       	acr	r3
8000c4bc:	ed b3 00 1c 	bld	r3,0x1c
8000c4c0:	c0 90       	breq	8000c4d2 <__avr32_f64_div+0x12a>
8000c4c2:	a1 72       	lsl	r2,0x1
8000c4c4:	5c f3       	rol	r3
8000c4c6:	20 17       	sub	r7,1
8000c4c8:	a3 9a       	lsr	r10,0x3
8000c4ca:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c4ce:	a3 9b       	lsr	r11,0x3
8000c4d0:	c0 58       	rjmp	8000c4da <__avr32_f64_div+0x132>
8000c4d2:	a5 8a       	lsr	r10,0x4
8000c4d4:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c4d8:	a5 8b       	lsr	r11,0x4
8000c4da:	58 07       	cp.w	r7,0
8000c4dc:	e0 8a 00 8b 	brle	8000c5f2 <__avr32_f64_div_res_subnormal>
8000c4e0:	e0 12 ff 00 	andl	r2,0xff00
8000c4e4:	e8 12 00 80 	orl	r2,0x80
8000c4e8:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c4ec:	e4 09 07 40 	macu.d	r0,r2,r9
8000c4f0:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c4f4:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c4f8:	00 05       	add	r5,r0
8000c4fa:	f0 01 00 48 	adc	r8,r8,r1
8000c4fe:	5c 09       	acr	r9
8000c500:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c504:	58 04       	cp.w	r4,0
8000c506:	5c 25       	cpc	r5

8000c508 <__avr32_f64_div_round_subnormal>:
8000c508:	f4 08 13 00 	cpc	r8,r10
8000c50c:	f6 09 13 00 	cpc	r9,r11
8000c510:	5f 36       	srlo	r6
8000c512:	f8 06 17 00 	moveq	r6,r12
8000c516:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c51a:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c51e:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c522:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c526:	ed be 00 1f 	bld	lr,0x1f
8000c52a:	ef bb 00 1f 	bst	r11,0x1f
8000c52e:	0c 0a       	add	r10,r6
8000c530:	5c 0b       	acr	r11
8000c532:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c536:	e4 1b 00 0f 	andh	r11,0xf
8000c53a:	14 4b       	or	r11,r10
8000c53c:	e0 81 00 a7 	brne	8000c68a <__avr32_f64_div_res_subnormal+0x98>
8000c540:	f2 06 16 14 	lsr	r6,r9,0x14
8000c544:	ab d6       	cbr	r6,0xb
8000c546:	e0 46 07 ff 	cp.w	r6,2047
8000c54a:	e0 81 00 a4 	brne	8000c692 <__avr32_f64_div_res_subnormal+0xa0>
8000c54e:	c9 e8       	rjmp	8000c68a <__avr32_f64_div_res_subnormal+0x98>
8000c550:	e4 19 00 0f 	andh	r9,0xf
8000c554:	10 49       	or	r9,r8
8000c556:	e0 81 00 9a 	brne	8000c68a <__avr32_f64_div_res_subnormal+0x98>
8000c55a:	c9 28       	rjmp	8000c67e <__avr32_f64_div_res_subnormal+0x8c>
8000c55c:	a3 7b       	lsl	r11,0x3
8000c55e:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c562:	a3 7a       	lsl	r10,0x3
8000c564:	f5 eb 10 04 	or	r4,r10,r11
8000c568:	e0 80 00 a0 	breq	8000c6a8 <__avr32_f64_div_op1_zero>
8000c56c:	f6 04 12 00 	clz	r4,r11
8000c570:	c1 70       	breq	8000c59e <__avr32_f64_div_round_subnormal+0x96>
8000c572:	c0 c3       	brcs	8000c58a <__avr32_f64_div_round_subnormal+0x82>
8000c574:	e8 05 11 20 	rsub	r5,r4,32
8000c578:	f6 04 09 4b 	lsl	r11,r11,r4
8000c57c:	f4 05 0a 45 	lsr	r5,r10,r5
8000c580:	0a 4b       	or	r11,r5
8000c582:	f4 04 09 4a 	lsl	r10,r10,r4
8000c586:	08 17       	sub	r7,r4
8000c588:	c0 b8       	rjmp	8000c59e <__avr32_f64_div_round_subnormal+0x96>
8000c58a:	f4 04 12 00 	clz	r4,r10
8000c58e:	f9 b4 03 00 	movlo	r4,0
8000c592:	f7 b4 02 e0 	subhs	r4,-32
8000c596:	f4 04 09 4b 	lsl	r11,r10,r4
8000c59a:	30 0a       	mov	r10,0
8000c59c:	08 17       	sub	r7,r4
8000c59e:	a3 8a       	lsr	r10,0x2
8000c5a0:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c5a4:	a3 8b       	lsr	r11,0x2
8000c5a6:	c1 1b       	rjmp	8000c3c8 <__avr32_f64_div+0x20>
8000c5a8:	a3 79       	lsl	r9,0x3
8000c5aa:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c5ae:	a3 78       	lsl	r8,0x3
8000c5b0:	f3 e8 10 04 	or	r4,r9,r8
8000c5b4:	c6 f0       	breq	8000c692 <__avr32_f64_div_res_subnormal+0xa0>
8000c5b6:	f2 04 12 00 	clz	r4,r9
8000c5ba:	c1 70       	breq	8000c5e8 <__avr32_f64_div_round_subnormal+0xe0>
8000c5bc:	c0 c3       	brcs	8000c5d4 <__avr32_f64_div_round_subnormal+0xcc>
8000c5be:	e8 05 11 20 	rsub	r5,r4,32
8000c5c2:	f2 04 09 49 	lsl	r9,r9,r4
8000c5c6:	f0 05 0a 45 	lsr	r5,r8,r5
8000c5ca:	0a 49       	or	r9,r5
8000c5cc:	f0 04 09 48 	lsl	r8,r8,r4
8000c5d0:	08 16       	sub	r6,r4
8000c5d2:	c0 b8       	rjmp	8000c5e8 <__avr32_f64_div_round_subnormal+0xe0>
8000c5d4:	f0 04 12 00 	clz	r4,r8
8000c5d8:	f9 b4 03 00 	movlo	r4,0
8000c5dc:	f7 b4 02 e0 	subhs	r4,-32
8000c5e0:	f0 04 09 49 	lsl	r9,r8,r4
8000c5e4:	30 08       	mov	r8,0
8000c5e6:	08 16       	sub	r6,r4
8000c5e8:	a3 88       	lsr	r8,0x2
8000c5ea:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c5ee:	a3 89       	lsr	r9,0x2
8000c5f0:	cf ca       	rjmp	8000c3e8 <__avr32_f64_div+0x40>

8000c5f2 <__avr32_f64_div_res_subnormal>:
8000c5f2:	5c 37       	neg	r7
8000c5f4:	2f f7       	sub	r7,-1
8000c5f6:	f1 b7 04 c0 	satu	r7,0x6
8000c5fa:	e0 47 00 20 	cp.w	r7,32
8000c5fe:	c1 54       	brge	8000c628 <__avr32_f64_div_res_subnormal+0x36>
8000c600:	ee 06 11 20 	rsub	r6,r7,32
8000c604:	e4 07 0a 42 	lsr	r2,r2,r7
8000c608:	e6 06 09 4c 	lsl	r12,r3,r6
8000c60c:	18 42       	or	r2,r12
8000c60e:	e6 07 0a 43 	lsr	r3,r3,r7
8000c612:	f4 06 09 41 	lsl	r1,r10,r6
8000c616:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c61a:	f6 06 09 4c 	lsl	r12,r11,r6
8000c61e:	18 4a       	or	r10,r12
8000c620:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c624:	30 00       	mov	r0,0
8000c626:	c1 58       	rjmp	8000c650 <__avr32_f64_div_res_subnormal+0x5e>
8000c628:	ee 06 11 20 	rsub	r6,r7,32
8000c62c:	f9 b0 00 00 	moveq	r0,0
8000c630:	f9 bc 00 00 	moveq	r12,0
8000c634:	c0 50       	breq	8000c63e <__avr32_f64_div_res_subnormal+0x4c>
8000c636:	f4 06 09 40 	lsl	r0,r10,r6
8000c63a:	f6 06 09 4c 	lsl	r12,r11,r6
8000c63e:	e6 07 0a 42 	lsr	r2,r3,r7
8000c642:	30 03       	mov	r3,0
8000c644:	f4 07 0a 41 	lsr	r1,r10,r7
8000c648:	18 41       	or	r1,r12
8000c64a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c64e:	30 0b       	mov	r11,0
8000c650:	e0 12 ff 00 	andl	r2,0xff00
8000c654:	e8 12 00 80 	orl	r2,0x80
8000c658:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c65c:	e4 09 07 46 	macu.d	r6,r2,r9
8000c660:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c664:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c668:	0c 05       	add	r5,r6
8000c66a:	f0 07 00 48 	adc	r8,r8,r7
8000c66e:	5c 09       	acr	r9
8000c670:	30 07       	mov	r7,0
8000c672:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c676:	00 34       	cp.w	r4,r0
8000c678:	e2 05 13 00 	cpc	r5,r1
8000c67c:	c4 6b       	rjmp	8000c508 <__avr32_f64_div_round_subnormal>
8000c67e:	1c 9b       	mov	r11,lr
8000c680:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c684:	30 0a       	mov	r10,0
8000c686:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c68a:	3f fb       	mov	r11,-1
8000c68c:	30 0a       	mov	r10,0
8000c68e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c692:	f5 eb 10 04 	or	r4,r10,r11
8000c696:	c0 90       	breq	8000c6a8 <__avr32_f64_div_op1_zero>
8000c698:	1c 9b       	mov	r11,lr
8000c69a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c69e:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c6a2:	30 0a       	mov	r10,0
8000c6a4:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c6a8 <__avr32_f64_div_op1_zero>:
8000c6a8:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c6ac:	ce f0       	breq	8000c68a <__avr32_f64_div_res_subnormal+0x98>
8000c6ae:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c6b2:	e0 44 07 ff 	cp.w	r4,2047
8000c6b6:	ce 41       	brne	8000c67e <__avr32_f64_div_res_subnormal+0x8c>
8000c6b8:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c6bc:	ce 10       	breq	8000c67e <__avr32_f64_div_res_subnormal+0x8c>
8000c6be:	ce 6b       	rjmp	8000c68a <__avr32_f64_div_res_subnormal+0x98>

8000c6c0 <__avr32_udiv64>:
8000c6c0:	d4 31       	pushm	r0-r7,lr
8000c6c2:	1a 97       	mov	r7,sp
8000c6c4:	20 3d       	sub	sp,12
8000c6c6:	10 9c       	mov	r12,r8
8000c6c8:	12 9e       	mov	lr,r9
8000c6ca:	14 93       	mov	r3,r10
8000c6cc:	58 09       	cp.w	r9,0
8000c6ce:	e0 81 00 bd 	brne	8000c848 <__avr32_udiv64+0x188>
8000c6d2:	16 38       	cp.w	r8,r11
8000c6d4:	e0 88 00 40 	brls	8000c754 <__avr32_udiv64+0x94>
8000c6d8:	f0 08 12 00 	clz	r8,r8
8000c6dc:	c0 d0       	breq	8000c6f6 <__avr32_udiv64+0x36>
8000c6de:	f6 08 09 4b 	lsl	r11,r11,r8
8000c6e2:	f0 09 11 20 	rsub	r9,r8,32
8000c6e6:	f8 08 09 4c 	lsl	r12,r12,r8
8000c6ea:	f4 09 0a 49 	lsr	r9,r10,r9
8000c6ee:	f4 08 09 43 	lsl	r3,r10,r8
8000c6f2:	f3 eb 10 0b 	or	r11,r9,r11
8000c6f6:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c6fa:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c6fe:	f6 0e 0d 00 	divu	r0,r11,lr
8000c702:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c706:	00 99       	mov	r9,r0
8000c708:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c70c:	e0 0a 02 48 	mul	r8,r0,r10
8000c710:	10 3b       	cp.w	r11,r8
8000c712:	c0 a2       	brcc	8000c726 <__avr32_udiv64+0x66>
8000c714:	20 19       	sub	r9,1
8000c716:	18 0b       	add	r11,r12
8000c718:	18 3b       	cp.w	r11,r12
8000c71a:	c0 63       	brcs	8000c726 <__avr32_udiv64+0x66>
8000c71c:	10 3b       	cp.w	r11,r8
8000c71e:	f7 b9 03 01 	sublo	r9,1
8000c722:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c726:	f6 08 01 01 	sub	r1,r11,r8
8000c72a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c72e:	e2 0e 0d 00 	divu	r0,r1,lr
8000c732:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c736:	00 98       	mov	r8,r0
8000c738:	e0 0a 02 4a 	mul	r10,r0,r10
8000c73c:	14 33       	cp.w	r3,r10
8000c73e:	c0 82       	brcc	8000c74e <__avr32_udiv64+0x8e>
8000c740:	20 18       	sub	r8,1
8000c742:	18 03       	add	r3,r12
8000c744:	18 33       	cp.w	r3,r12
8000c746:	c0 43       	brcs	8000c74e <__avr32_udiv64+0x8e>
8000c748:	14 33       	cp.w	r3,r10
8000c74a:	f7 b8 03 01 	sublo	r8,1
8000c74e:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c752:	cd f8       	rjmp	8000c910 <__avr32_udiv64+0x250>
8000c754:	58 08       	cp.w	r8,0
8000c756:	c0 51       	brne	8000c760 <__avr32_udiv64+0xa0>
8000c758:	30 19       	mov	r9,1
8000c75a:	f2 08 0d 08 	divu	r8,r9,r8
8000c75e:	10 9c       	mov	r12,r8
8000c760:	f8 06 12 00 	clz	r6,r12
8000c764:	c0 41       	brne	8000c76c <__avr32_udiv64+0xac>
8000c766:	18 1b       	sub	r11,r12
8000c768:	30 19       	mov	r9,1
8000c76a:	c4 08       	rjmp	8000c7ea <__avr32_udiv64+0x12a>
8000c76c:	ec 01 11 20 	rsub	r1,r6,32
8000c770:	f4 01 0a 49 	lsr	r9,r10,r1
8000c774:	f8 06 09 4c 	lsl	r12,r12,r6
8000c778:	f6 06 09 48 	lsl	r8,r11,r6
8000c77c:	f6 01 0a 41 	lsr	r1,r11,r1
8000c780:	f3 e8 10 08 	or	r8,r9,r8
8000c784:	f8 03 16 10 	lsr	r3,r12,0x10
8000c788:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c78c:	e2 03 0d 00 	divu	r0,r1,r3
8000c790:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c794:	00 9e       	mov	lr,r0
8000c796:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c79a:	e0 05 02 49 	mul	r9,r0,r5
8000c79e:	12 3b       	cp.w	r11,r9
8000c7a0:	c0 a2       	brcc	8000c7b4 <__avr32_udiv64+0xf4>
8000c7a2:	20 1e       	sub	lr,1
8000c7a4:	18 0b       	add	r11,r12
8000c7a6:	18 3b       	cp.w	r11,r12
8000c7a8:	c0 63       	brcs	8000c7b4 <__avr32_udiv64+0xf4>
8000c7aa:	12 3b       	cp.w	r11,r9
8000c7ac:	f7 be 03 01 	sublo	lr,1
8000c7b0:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c7b4:	12 1b       	sub	r11,r9
8000c7b6:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c7ba:	f6 03 0d 02 	divu	r2,r11,r3
8000c7be:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c7c2:	04 99       	mov	r9,r2
8000c7c4:	e4 05 02 4b 	mul	r11,r2,r5
8000c7c8:	16 38       	cp.w	r8,r11
8000c7ca:	c0 a2       	brcc	8000c7de <__avr32_udiv64+0x11e>
8000c7cc:	20 19       	sub	r9,1
8000c7ce:	18 08       	add	r8,r12
8000c7d0:	18 38       	cp.w	r8,r12
8000c7d2:	c0 63       	brcs	8000c7de <__avr32_udiv64+0x11e>
8000c7d4:	16 38       	cp.w	r8,r11
8000c7d6:	f7 b9 03 01 	sublo	r9,1
8000c7da:	f1 dc e3 08 	addcs	r8,r8,r12
8000c7de:	f4 06 09 43 	lsl	r3,r10,r6
8000c7e2:	f0 0b 01 0b 	sub	r11,r8,r11
8000c7e6:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c7ea:	f8 06 16 10 	lsr	r6,r12,0x10
8000c7ee:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c7f2:	f6 06 0d 00 	divu	r0,r11,r6
8000c7f6:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c7fa:	00 9a       	mov	r10,r0
8000c7fc:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c800:	e0 0e 02 48 	mul	r8,r0,lr
8000c804:	10 3b       	cp.w	r11,r8
8000c806:	c0 a2       	brcc	8000c81a <__avr32_udiv64+0x15a>
8000c808:	20 1a       	sub	r10,1
8000c80a:	18 0b       	add	r11,r12
8000c80c:	18 3b       	cp.w	r11,r12
8000c80e:	c0 63       	brcs	8000c81a <__avr32_udiv64+0x15a>
8000c810:	10 3b       	cp.w	r11,r8
8000c812:	f7 ba 03 01 	sublo	r10,1
8000c816:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c81a:	f6 08 01 01 	sub	r1,r11,r8
8000c81e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c822:	e2 06 0d 00 	divu	r0,r1,r6
8000c826:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c82a:	00 98       	mov	r8,r0
8000c82c:	e0 0e 02 4b 	mul	r11,r0,lr
8000c830:	16 33       	cp.w	r3,r11
8000c832:	c0 82       	brcc	8000c842 <__avr32_udiv64+0x182>
8000c834:	20 18       	sub	r8,1
8000c836:	18 03       	add	r3,r12
8000c838:	18 33       	cp.w	r3,r12
8000c83a:	c0 43       	brcs	8000c842 <__avr32_udiv64+0x182>
8000c83c:	16 33       	cp.w	r3,r11
8000c83e:	f7 b8 03 01 	sublo	r8,1
8000c842:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c846:	c6 98       	rjmp	8000c918 <__avr32_udiv64+0x258>
8000c848:	16 39       	cp.w	r9,r11
8000c84a:	e0 8b 00 65 	brhi	8000c914 <__avr32_udiv64+0x254>
8000c84e:	f2 09 12 00 	clz	r9,r9
8000c852:	c0 b1       	brne	8000c868 <__avr32_udiv64+0x1a8>
8000c854:	10 3a       	cp.w	r10,r8
8000c856:	5f 2a       	srhs	r10
8000c858:	1c 3b       	cp.w	r11,lr
8000c85a:	5f b8       	srhi	r8
8000c85c:	10 4a       	or	r10,r8
8000c85e:	f2 0a 18 00 	cp.b	r10,r9
8000c862:	c5 90       	breq	8000c914 <__avr32_udiv64+0x254>
8000c864:	30 18       	mov	r8,1
8000c866:	c5 98       	rjmp	8000c918 <__avr32_udiv64+0x258>
8000c868:	f0 09 09 46 	lsl	r6,r8,r9
8000c86c:	f2 03 11 20 	rsub	r3,r9,32
8000c870:	fc 09 09 4e 	lsl	lr,lr,r9
8000c874:	f0 03 0a 48 	lsr	r8,r8,r3
8000c878:	f6 09 09 4c 	lsl	r12,r11,r9
8000c87c:	f4 03 0a 42 	lsr	r2,r10,r3
8000c880:	ef 46 ff f4 	st.w	r7[-12],r6
8000c884:	f6 03 0a 43 	lsr	r3,r11,r3
8000c888:	18 42       	or	r2,r12
8000c88a:	f1 ee 10 0c 	or	r12,r8,lr
8000c88e:	f8 01 16 10 	lsr	r1,r12,0x10
8000c892:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c896:	e6 01 0d 04 	divu	r4,r3,r1
8000c89a:	e4 03 16 10 	lsr	r3,r2,0x10
8000c89e:	08 9e       	mov	lr,r4
8000c8a0:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c8a4:	e8 06 02 48 	mul	r8,r4,r6
8000c8a8:	10 33       	cp.w	r3,r8
8000c8aa:	c0 a2       	brcc	8000c8be <__avr32_udiv64+0x1fe>
8000c8ac:	20 1e       	sub	lr,1
8000c8ae:	18 03       	add	r3,r12
8000c8b0:	18 33       	cp.w	r3,r12
8000c8b2:	c0 63       	brcs	8000c8be <__avr32_udiv64+0x1fe>
8000c8b4:	10 33       	cp.w	r3,r8
8000c8b6:	f7 be 03 01 	sublo	lr,1
8000c8ba:	e7 dc e3 03 	addcs	r3,r3,r12
8000c8be:	10 13       	sub	r3,r8
8000c8c0:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c8c4:	e6 01 0d 00 	divu	r0,r3,r1
8000c8c8:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c8cc:	00 98       	mov	r8,r0
8000c8ce:	e0 06 02 46 	mul	r6,r0,r6
8000c8d2:	0c 3b       	cp.w	r11,r6
8000c8d4:	c0 a2       	brcc	8000c8e8 <__avr32_udiv64+0x228>
8000c8d6:	20 18       	sub	r8,1
8000c8d8:	18 0b       	add	r11,r12
8000c8da:	18 3b       	cp.w	r11,r12
8000c8dc:	c0 63       	brcs	8000c8e8 <__avr32_udiv64+0x228>
8000c8de:	0c 3b       	cp.w	r11,r6
8000c8e0:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c8e4:	f7 b8 03 01 	sublo	r8,1
8000c8e8:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c8ec:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c8f0:	0c 1b       	sub	r11,r6
8000c8f2:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c8f6:	06 95       	mov	r5,r3
8000c8f8:	16 35       	cp.w	r5,r11
8000c8fa:	e0 8b 00 0a 	brhi	8000c90e <__avr32_udiv64+0x24e>
8000c8fe:	5f 0b       	sreq	r11
8000c900:	f4 09 09 49 	lsl	r9,r10,r9
8000c904:	12 32       	cp.w	r2,r9
8000c906:	5f b9       	srhi	r9
8000c908:	f7 e9 00 09 	and	r9,r11,r9
8000c90c:	c0 60       	breq	8000c918 <__avr32_udiv64+0x258>
8000c90e:	20 18       	sub	r8,1
8000c910:	30 09       	mov	r9,0
8000c912:	c0 38       	rjmp	8000c918 <__avr32_udiv64+0x258>
8000c914:	30 09       	mov	r9,0
8000c916:	12 98       	mov	r8,r9
8000c918:	10 9a       	mov	r10,r8
8000c91a:	12 93       	mov	r3,r9
8000c91c:	10 92       	mov	r2,r8
8000c91e:	12 9b       	mov	r11,r9
8000c920:	2f dd       	sub	sp,-12
8000c922:	d8 32       	popm	r0-r7,pc

8000c924 <__avr32_umod64>:
8000c924:	d4 31       	pushm	r0-r7,lr
8000c926:	1a 97       	mov	r7,sp
8000c928:	20 3d       	sub	sp,12
8000c92a:	10 9c       	mov	r12,r8
8000c92c:	12 95       	mov	r5,r9
8000c92e:	14 9e       	mov	lr,r10
8000c930:	16 91       	mov	r1,r11
8000c932:	16 96       	mov	r6,r11
8000c934:	58 09       	cp.w	r9,0
8000c936:	e0 81 00 81 	brne	8000ca38 <__avr32_umod64+0x114>
8000c93a:	16 38       	cp.w	r8,r11
8000c93c:	e0 88 00 12 	brls	8000c960 <__avr32_umod64+0x3c>
8000c940:	f0 08 12 00 	clz	r8,r8
8000c944:	c4 e0       	breq	8000c9e0 <__avr32_umod64+0xbc>
8000c946:	f6 08 09 46 	lsl	r6,r11,r8
8000c94a:	f8 08 09 4c 	lsl	r12,r12,r8
8000c94e:	f0 0b 11 20 	rsub	r11,r8,32
8000c952:	f4 08 09 4e 	lsl	lr,r10,r8
8000c956:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c95a:	f7 e6 10 06 	or	r6,r11,r6
8000c95e:	c4 18       	rjmp	8000c9e0 <__avr32_umod64+0xbc>
8000c960:	58 08       	cp.w	r8,0
8000c962:	c0 51       	brne	8000c96c <__avr32_umod64+0x48>
8000c964:	30 19       	mov	r9,1
8000c966:	f2 08 0d 08 	divu	r8,r9,r8
8000c96a:	10 9c       	mov	r12,r8
8000c96c:	f8 08 12 00 	clz	r8,r12
8000c970:	c0 31       	brne	8000c976 <__avr32_umod64+0x52>
8000c972:	18 16       	sub	r6,r12
8000c974:	c3 68       	rjmp	8000c9e0 <__avr32_umod64+0xbc>
8000c976:	f0 03 11 20 	rsub	r3,r8,32
8000c97a:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c97e:	f8 08 09 4c 	lsl	r12,r12,r8
8000c982:	ec 08 09 49 	lsl	r9,r6,r8
8000c986:	ec 03 0a 43 	lsr	r3,r6,r3
8000c98a:	f7 e9 10 09 	or	r9,r11,r9
8000c98e:	f8 05 16 10 	lsr	r5,r12,0x10
8000c992:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c996:	e6 05 0d 02 	divu	r2,r3,r5
8000c99a:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c99e:	ec 02 02 4b 	mul	r11,r6,r2
8000c9a2:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c9a6:	16 3e       	cp.w	lr,r11
8000c9a8:	c0 72       	brcc	8000c9b6 <__avr32_umod64+0x92>
8000c9aa:	18 0e       	add	lr,r12
8000c9ac:	18 3e       	cp.w	lr,r12
8000c9ae:	c0 43       	brcs	8000c9b6 <__avr32_umod64+0x92>
8000c9b0:	16 3e       	cp.w	lr,r11
8000c9b2:	fd dc e3 0e 	addcs	lr,lr,r12
8000c9b6:	fc 0b 01 03 	sub	r3,lr,r11
8000c9ba:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c9be:	e6 05 0d 02 	divu	r2,r3,r5
8000c9c2:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c9c6:	a5 36       	mul	r6,r2
8000c9c8:	0c 39       	cp.w	r9,r6
8000c9ca:	c0 72       	brcc	8000c9d8 <__avr32_umod64+0xb4>
8000c9cc:	18 09       	add	r9,r12
8000c9ce:	18 39       	cp.w	r9,r12
8000c9d0:	c0 43       	brcs	8000c9d8 <__avr32_umod64+0xb4>
8000c9d2:	0c 39       	cp.w	r9,r6
8000c9d4:	f3 dc e3 09 	addcs	r9,r9,r12
8000c9d8:	f2 06 01 06 	sub	r6,r9,r6
8000c9dc:	f4 08 09 4e 	lsl	lr,r10,r8
8000c9e0:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c9e4:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c9e8:	ec 0a 0d 02 	divu	r2,r6,r10
8000c9ec:	fc 09 16 10 	lsr	r9,lr,0x10
8000c9f0:	ea 02 02 4b 	mul	r11,r5,r2
8000c9f4:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c9f8:	16 39       	cp.w	r9,r11
8000c9fa:	c0 72       	brcc	8000ca08 <__avr32_umod64+0xe4>
8000c9fc:	18 09       	add	r9,r12
8000c9fe:	18 39       	cp.w	r9,r12
8000ca00:	c0 43       	brcs	8000ca08 <__avr32_umod64+0xe4>
8000ca02:	16 39       	cp.w	r9,r11
8000ca04:	f3 dc e3 09 	addcs	r9,r9,r12
8000ca08:	f2 0b 01 0b 	sub	r11,r9,r11
8000ca0c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000ca10:	f6 0a 0d 0a 	divu	r10,r11,r10
8000ca14:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000ca18:	ea 0a 02 4a 	mul	r10,r5,r10
8000ca1c:	14 3e       	cp.w	lr,r10
8000ca1e:	c0 72       	brcc	8000ca2c <__avr32_umod64+0x108>
8000ca20:	18 0e       	add	lr,r12
8000ca22:	18 3e       	cp.w	lr,r12
8000ca24:	c0 43       	brcs	8000ca2c <__avr32_umod64+0x108>
8000ca26:	14 3e       	cp.w	lr,r10
8000ca28:	fd dc e3 0e 	addcs	lr,lr,r12
8000ca2c:	fc 0a 01 0a 	sub	r10,lr,r10
8000ca30:	30 0b       	mov	r11,0
8000ca32:	f4 08 0a 4a 	lsr	r10,r10,r8
8000ca36:	c7 b8       	rjmp	8000cb2c <__avr32_umod64+0x208>
8000ca38:	16 39       	cp.w	r9,r11
8000ca3a:	e0 8b 00 79 	brhi	8000cb2c <__avr32_umod64+0x208>
8000ca3e:	f2 09 12 00 	clz	r9,r9
8000ca42:	c1 21       	brne	8000ca66 <__avr32_umod64+0x142>
8000ca44:	10 3a       	cp.w	r10,r8
8000ca46:	5f 2b       	srhs	r11
8000ca48:	0a 31       	cp.w	r1,r5
8000ca4a:	5f ba       	srhi	r10
8000ca4c:	f7 ea 10 0a 	or	r10,r11,r10
8000ca50:	f2 0a 18 00 	cp.b	r10,r9
8000ca54:	c0 60       	breq	8000ca60 <__avr32_umod64+0x13c>
8000ca56:	fc 08 01 0c 	sub	r12,lr,r8
8000ca5a:	e2 05 01 46 	sbc	r6,r1,r5
8000ca5e:	18 9e       	mov	lr,r12
8000ca60:	0c 9b       	mov	r11,r6
8000ca62:	1c 9a       	mov	r10,lr
8000ca64:	c6 48       	rjmp	8000cb2c <__avr32_umod64+0x208>
8000ca66:	ea 09 09 4c 	lsl	r12,r5,r9
8000ca6a:	f2 06 11 20 	rsub	r6,r9,32
8000ca6e:	f6 09 09 4b 	lsl	r11,r11,r9
8000ca72:	f0 09 09 42 	lsl	r2,r8,r9
8000ca76:	ef 46 ff f4 	st.w	r7[-12],r6
8000ca7a:	f0 06 0a 48 	lsr	r8,r8,r6
8000ca7e:	18 48       	or	r8,r12
8000ca80:	e2 06 0a 4c 	lsr	r12,r1,r6
8000ca84:	f4 09 09 43 	lsl	r3,r10,r9
8000ca88:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000ca8c:	f4 06 0a 4a 	lsr	r10,r10,r6
8000ca90:	16 4a       	or	r10,r11
8000ca92:	f0 0b 16 10 	lsr	r11,r8,0x10
8000ca96:	f8 0b 0d 04 	divu	r4,r12,r11
8000ca9a:	f4 0c 16 10 	lsr	r12,r10,0x10
8000ca9e:	08 91       	mov	r1,r4
8000caa0:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000caa4:	e8 0e 02 46 	mul	r6,r4,lr
8000caa8:	0c 3c       	cp.w	r12,r6
8000caaa:	c0 a2       	brcc	8000cabe <__avr32_umod64+0x19a>
8000caac:	20 11       	sub	r1,1
8000caae:	10 0c       	add	r12,r8
8000cab0:	10 3c       	cp.w	r12,r8
8000cab2:	c0 63       	brcs	8000cabe <__avr32_umod64+0x19a>
8000cab4:	0c 3c       	cp.w	r12,r6
8000cab6:	f7 b1 03 01 	sublo	r1,1
8000caba:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000cabe:	0c 1c       	sub	r12,r6
8000cac0:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000cac4:	f8 0b 0d 04 	divu	r4,r12,r11
8000cac8:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000cacc:	08 96       	mov	r6,r4
8000cace:	e8 0e 02 4e 	mul	lr,r4,lr
8000cad2:	1c 3b       	cp.w	r11,lr
8000cad4:	c0 a2       	brcc	8000cae8 <__avr32_umod64+0x1c4>
8000cad6:	20 16       	sub	r6,1
8000cad8:	10 0b       	add	r11,r8
8000cada:	10 3b       	cp.w	r11,r8
8000cadc:	c0 63       	brcs	8000cae8 <__avr32_umod64+0x1c4>
8000cade:	1c 3b       	cp.w	r11,lr
8000cae0:	f7 b6 03 01 	sublo	r6,1
8000cae4:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000cae8:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000caec:	1c 1b       	sub	r11,lr
8000caee:	e2 02 06 40 	mulu.d	r0,r1,r2
8000caf2:	00 9e       	mov	lr,r0
8000caf4:	02 9c       	mov	r12,r1
8000caf6:	16 3c       	cp.w	r12,r11
8000caf8:	e0 8b 00 08 	brhi	8000cb08 <__avr32_umod64+0x1e4>
8000cafc:	5f 06       	sreq	r6
8000cafe:	06 30       	cp.w	r0,r3
8000cb00:	5f ba       	srhi	r10
8000cb02:	ed ea 00 0a 	and	r10,r6,r10
8000cb06:	c0 60       	breq	8000cb12 <__avr32_umod64+0x1ee>
8000cb08:	fc 02 01 04 	sub	r4,lr,r2
8000cb0c:	f8 08 01 4c 	sbc	r12,r12,r8
8000cb10:	08 9e       	mov	lr,r4
8000cb12:	e6 0e 01 0a 	sub	r10,r3,lr
8000cb16:	f6 0c 01 4c 	sbc	r12,r11,r12
8000cb1a:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000cb1e:	f8 09 0a 4b 	lsr	r11,r12,r9
8000cb22:	f4 09 0a 4a 	lsr	r10,r10,r9
8000cb26:	f8 01 09 4c 	lsl	r12,r12,r1
8000cb2a:	18 4a       	or	r10,r12
8000cb2c:	2f dd       	sub	sp,-12
8000cb2e:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000cc00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000cc00:	c0 08       	rjmp	8000cc00 <_evba>
	...

8000cc04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000cc04:	c0 08       	rjmp	8000cc04 <_handle_TLB_Multiple_Hit>
	...

8000cc08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000cc08:	c0 08       	rjmp	8000cc08 <_handle_Bus_Error_Data_Fetch>
	...

8000cc0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000cc0c:	c0 08       	rjmp	8000cc0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000cc10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000cc10:	c0 08       	rjmp	8000cc10 <_handle_NMI>
	...

8000cc14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000cc14:	c0 08       	rjmp	8000cc14 <_handle_Instruction_Address>
	...

8000cc18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000cc18:	c0 08       	rjmp	8000cc18 <_handle_ITLB_Protection>
	...

8000cc1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000cc1c:	c0 08       	rjmp	8000cc1c <_handle_Breakpoint>
	...

8000cc20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000cc20:	c0 08       	rjmp	8000cc20 <_handle_Illegal_Opcode>
	...

8000cc24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000cc24:	c0 08       	rjmp	8000cc24 <_handle_Unimplemented_Instruction>
	...

8000cc28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000cc28:	c0 08       	rjmp	8000cc28 <_handle_Privilege_Violation>
	...

8000cc2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000cc2c:	c0 08       	rjmp	8000cc2c <_handle_Floating_Point>
	...

8000cc30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000cc30:	c0 08       	rjmp	8000cc30 <_handle_Coprocessor_Absent>
	...

8000cc34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000cc34:	c0 08       	rjmp	8000cc34 <_handle_Data_Address_Read>
	...

8000cc38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000cc38:	c0 08       	rjmp	8000cc38 <_handle_Data_Address_Write>
	...

8000cc3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000cc3c:	c0 08       	rjmp	8000cc3c <_handle_DTLB_Protection_Read>
	...

8000cc40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000cc40:	c0 08       	rjmp	8000cc40 <_handle_DTLB_Protection_Write>
	...

8000cc44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000cc44:	c0 08       	rjmp	8000cc44 <_handle_DTLB_Modified>
	...

8000cc50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000cc50:	c0 08       	rjmp	8000cc50 <_handle_ITLB_Miss>
	...

8000cc60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000cc60:	c0 08       	rjmp	8000cc60 <_handle_DTLB_Miss_Read>
	...

8000cc70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000cc70:	c0 08       	rjmp	8000cc70 <_handle_DTLB_Miss_Write>
	...

8000cd00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000cd00:	fe cf 70 10 	sub	pc,pc,28688

8000cd04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000cd04:	30 0c       	mov	r12,0
8000cd06:	fe b0 c4 13 	rcall	8000552c <_get_interrupt_handler>
8000cd0a:	58 0c       	cp.w	r12,0
8000cd0c:	f8 0f 17 10 	movne	pc,r12
8000cd10:	d6 03       	rete

8000cd12 <_int1>:
8000cd12:	30 1c       	mov	r12,1
8000cd14:	fe b0 c4 0c 	rcall	8000552c <_get_interrupt_handler>
8000cd18:	58 0c       	cp.w	r12,0
8000cd1a:	f8 0f 17 10 	movne	pc,r12
8000cd1e:	d6 03       	rete

8000cd20 <_int2>:
8000cd20:	30 2c       	mov	r12,2
8000cd22:	fe b0 c4 05 	rcall	8000552c <_get_interrupt_handler>
8000cd26:	58 0c       	cp.w	r12,0
8000cd28:	f8 0f 17 10 	movne	pc,r12
8000cd2c:	d6 03       	rete

8000cd2e <_int3>:
8000cd2e:	30 3c       	mov	r12,3
8000cd30:	fe b0 c3 fe 	rcall	8000552c <_get_interrupt_handler>
8000cd34:	58 0c       	cp.w	r12,0
8000cd36:	f8 0f 17 10 	movne	pc,r12
8000cd3a:	d6 03       	rete

8000cd3c <ipr_val>:
8000cd3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000cd4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cddc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdfc:	d7 03 d7 03                                         ....
