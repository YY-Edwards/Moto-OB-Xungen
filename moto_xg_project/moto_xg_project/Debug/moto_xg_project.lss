
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000bcf4  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000de00  8000de00  0000e200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001640  8000e000  8000e000  0000e400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a54  00000004  8000f640  0000fc04  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          0000b300  00000a58  80010094  00010658  2**2
                  ALLOC
  7 .comment      00000030  00000000  00000000  00010658  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00001798  00000000  00000000  00010688  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 0000387d  00000000  00000000  00011e20  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0002e420  00000000  00000000  0001569d  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 0000783b  00000000  00000000  00043abd  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000dca9  00000000  00000000  0004b2f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  000040fc  00000000  00000000  00058fa4  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000832f  00000000  00000000  0005d0a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0000ffb5  00000000  00000000  000653cf  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 17 .debug_ranges 00001848  00000000  00000000  00075388  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf b3 98 	sub	pc,pc,-19560

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	f8 c8 ff fe 	sub	r8,r12,-2
void DeviceManagement_brdcst_func(xcmp_fragment_t * xcmp)
{
		U16 temp = 0;
		/*point to xcmp payload*/
		DeviceManagement_brdcast_t *ptr = (DeviceManagement_brdcast_t* )xcmp->u8;
		temp  = ptr->Device_Type << 8;
80002008:	f1 2a 00 01 	ld.sb	r10,r8[1]
		temp |= ptr->XCMP_Device_ID;
			
		//log("DeviceManagement_brdcst...\n");
		//log("temp: %x\n", temp);
		//log("xnl_information.logical_address: %x\n", xnl_information.logical_address);
		if (temp == xnl_information.logical_address)
8000200c:	48 c9       	lddpc	r9,8000203c <DeviceManagement_brdcst_func+0x38>
8000200e:	92 39       	ld.sh	r9,r9[0x6]
{
		U16 temp = 0;
		/*point to xcmp payload*/
		DeviceManagement_brdcast_t *ptr = (DeviceManagement_brdcast_t* )xcmp->u8;
		temp  = ptr->Device_Type << 8;
		temp |= ptr->XCMP_Device_ID;
80002010:	11 a8       	ld.ub	r8,r8[0x2]
80002012:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80002016:	f0 09 19 00 	cp.h	r9,r8
8000201a:	5e 1c       	retne	r12
		//log("DeviceManagement_brdcst...\n");
		//log("temp: %x\n", temp);
		//log("xnl_information.logical_address: %x\n", xnl_information.logical_address);
		if (temp == xnl_information.logical_address)
		{
			if (xcmp->u8[0] == 0x01)
8000201c:	19 a9       	ld.ub	r9,r12[0x2]
8000201e:	30 18       	mov	r8,1
80002020:	f0 09 18 00 	cp.b	r9,r8
80002024:	c0 61       	brne	80002030 <DeviceManagement_brdcst_func+0x2c>
			{
				//Enable Option Board
				bunchofrandomstatusflags |= 0x00000002;
80002026:	48 78       	lddpc	r8,80002040 <DeviceManagement_brdcst_func+0x3c>
80002028:	70 09       	ld.w	r9,r8[0x0]
8000202a:	a1 b9       	sbr	r9,0x1
8000202c:	91 09       	st.w	r8[0x0],r9
8000202e:	5e fc       	retal	r12
			}
			else
			{
				//Disable Option Board.
				//log("Device State : %d\n", );
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002030:	48 48       	lddpc	r8,80002040 <DeviceManagement_brdcst_func+0x3c>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	a1 d9       	cbr	r9,0x1
80002036:	91 09       	st.w	r8[0x0],r9
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	0e 26       	rsub	r6,r7
80002040:	00 00       	add	r0,r0
80002042:	0e 1c       	sub	r12,r7

80002044 <Volume_brdcst_func>:
	//log("Attenuator_Number: %x \n",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("Audio_Parameter: %x \n", ptr->Audio_Parameter);
	
	
}
80002044:	5e fc       	retal	r12

80002046 <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
80002046:	5e fc       	retal	r12

80002048 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002048:	48 38       	lddpc	r8,80002054 <vApplicationIdleHook+0xc>
8000204a:	70 09       	ld.w	r9,r8[0x0]
8000204c:	2f f9       	sub	r9,-1
8000204e:	91 09       	st.w	r8[0x0],r9
	
}
80002050:	5e fc       	retal	r12
80002052:	00 00       	add	r0,r0
80002054:	00 00       	add	r0,r0
80002056:	0a 74       	tst	r4,r5

80002058 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002058:	d4 01       	pushm	lr
  log("R");
8000205a:	48 3c       	lddpc	r12,80002064 <app_payload_tx_proc+0xc>
8000205c:	f0 1f 00 03 	mcall	80002068 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002060:	d8 02       	popm	pc
80002062:	00 00       	add	r0,r0
80002064:	80 00       	ld.sh	r0,r0[0x0]
80002066:	e0 00       	*unknown*
80002068:	80 00       	ld.sh	r0,r0[0x0]
8000206a:	7f c4       	ld.w	r4,pc[0x70]

8000206c <app_payload_rx_proc>:
}



static void app_payload_rx_proc(void  * payload)
{
8000206c:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
8000206e:	48 99       	lddpc	r9,80002090 <app_payload_rx_proc+0x24>
80002070:	13 88       	ld.ub	r8,r9[0x0]
80002072:	2f f8       	sub	r8,-1
80002074:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
80002076:	30 39       	mov	r9,3
80002078:	f2 08 18 00 	cp.b	r8,r9
8000207c:	c0 71       	brne	8000208a <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
8000207e:	30 09       	mov	r9,0
80002080:	48 48       	lddpc	r8,80002090 <app_payload_rx_proc+0x24>
80002082:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002084:	48 4c       	lddpc	r12,80002094 <app_payload_rx_proc+0x28>
80002086:	f0 1f 00 05 	mcall	80002098 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
8000208a:	48 58       	lddpc	r8,8000209c <app_payload_rx_proc+0x30>
8000208c:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
8000208e:	d8 02       	popm	pc
80002090:	00 00       	add	r0,r0
80002092:	0a 64       	and	r4,r5
80002094:	80 00       	ld.sh	r0,r0[0x0]
80002096:	e0 04       	*unknown*
80002098:	80 00       	ld.sh	r0,r0[0x0]
8000209a:	7f c4       	ld.w	r4,pc[0x70]
8000209c:	00 00       	add	r0,r0
8000209e:	0a 63       	and	r3,r5

800020a0 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020a0:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020a2:	48 3c       	lddpc	r12,800020ac <FD_brdcst_func+0xc>
800020a4:	f0 1f 00 03 	mcall	800020b0 <FD_brdcst_func+0x10>
	
}
800020a8:	d8 02       	popm	pc
800020aa:	00 00       	add	r0,r0
800020ac:	80 00       	ld.sh	r0,r0[0x0]
800020ae:	e0 10 80 00 	andl	r0,0x8000
800020b2:	7f c4       	ld.w	r4,pc[0x70]

800020b4 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020b4:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020b6:	48 3c       	lddpc	r12,800020c0 <FD_reply_func+0xc>
800020b8:	f0 1f 00 03 	mcall	800020c4 <FD_reply_func+0x10>
	
	
}
800020bc:	d8 02       	popm	pc
800020be:	00 00       	add	r0,r0
800020c0:	80 00       	ld.sh	r0,r0[0x0]
800020c2:	e0 30 80 00 	sub	r0,98304
800020c6:	7f c4       	ld.w	r4,pc[0x70]

800020c8 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020c8:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020ca:	48 3c       	lddpc	r12,800020d4 <FD_request_func+0xc>
800020cc:	f0 1f 00 03 	mcall	800020d8 <FD_request_func+0x10>
	
	
}
800020d0:	d8 02       	popm	pc
800020d2:	00 00       	add	r0,r0
800020d4:	80 00       	ld.sh	r0,r0[0x0]
800020d6:	e0 4c 80 00 	cp.w	r12,32768
800020da:	7f c4       	ld.w	r4,pc[0x70]

800020dc <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020dc:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020de:	48 3c       	lddpc	r12,800020e8 <EnOB_brdcst_func+0xc>
800020e0:	f0 1f 00 03 	mcall	800020ec <EnOB_brdcst_func+0x10>
}
800020e4:	d8 02       	popm	pc
800020e6:	00 00       	add	r0,r0
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	e0 68 80 00 	mov	r8,32768
800020ee:	7f c4       	ld.w	r4,pc[0x70]

800020f0 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020f0:	eb cd 40 80 	pushm	r7,lr
800020f4:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020f6:	19 a9       	ld.ub	r9,r12[0x2]
800020f8:	30 08       	mov	r8,0
800020fa:	f0 09 18 00 	cp.b	r9,r8
800020fe:	c1 91       	brne	80002130 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002100:	19 b8       	ld.ub	r8,r12[0x3]
80002102:	30 19       	mov	r9,1
80002104:	f2 08 18 00 	cp.b	r8,r9
80002108:	c0 61       	brne	80002114 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
8000210a:	49 0c       	lddpc	r12,80002148 <EnOB_reply_func+0x58>
8000210c:	f0 1f 00 10 	mcall	8000214c <EnOB_reply_func+0x5c>
80002110:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
80002114:	58 08       	cp.w	r8,0
80002116:	c0 61       	brne	80002122 <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002118:	48 ec       	lddpc	r12,80002150 <EnOB_reply_func+0x60>
8000211a:	f0 1f 00 0d 	mcall	8000214c <EnOB_reply_func+0x5c>
8000211e:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
80002122:	1a d8       	st.w	--sp,r8
80002124:	48 cc       	lddpc	r12,80002154 <EnOB_reply_func+0x64>
80002126:	f0 1f 00 0a 	mcall	8000214c <EnOB_reply_func+0x5c>
8000212a:	2f fd       	sub	sp,-4
8000212c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002130:	48 ac       	lddpc	r12,80002158 <EnOB_reply_func+0x68>
80002132:	f0 1f 00 07 	mcall	8000214c <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
80002136:	0f a8       	ld.ub	r8,r7[0x2]
80002138:	1a d8       	st.w	--sp,r8
8000213a:	48 9c       	lddpc	r12,8000215c <EnOB_reply_func+0x6c>
8000213c:	f0 1f 00 04 	mcall	8000214c <EnOB_reply_func+0x5c>
80002140:	2f fd       	sub	sp,-4
80002142:	e3 cd 80 80 	ldm	sp++,r7,pc
80002146:	00 00       	add	r0,r0
80002148:	80 00       	ld.sh	r0,r0[0x0]
8000214a:	e0 80 80 00 	breq	8001214a <_data_lma+0x2b0a>
8000214e:	7f c4       	ld.w	r4,pc[0x70]
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	e0 98 80 00 	brls	80032152 <_data_lma+0x22b12>
80002156:	e0 ac       	*unknown*
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	e0 c4 80 00 	sub	r4,r0,-32768
8000215e:	e0 e0 eb cd 	ld.d	r0,r0[-5171]

80002160 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002160:	eb cd 40 80 	pushm	r7,lr
80002164:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
80002166:	19 a9       	ld.ub	r9,r12[0x2]
80002168:	31 18       	mov	r8,17
8000216a:	f0 09 18 00 	cp.b	r9,r8
8000216e:	c0 91       	brne	80002180 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002170:	48 ac       	lddpc	r12,80002198 <SingleDetection_brdcst_func+0x38>
80002172:	f0 1f 00 0b 	mcall	8000219c <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
80002176:	30 19       	mov	r9,1
80002178:	48 a8       	lddpc	r8,800021a0 <SingleDetection_brdcst_func+0x40>
8000217a:	b0 89       	st.b	r8[0x0],r9
8000217c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
80002180:	48 9c       	lddpc	r12,800021a4 <SingleDetection_brdcst_func+0x44>
80002182:	f0 1f 00 07 	mcall	8000219c <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
80002186:	0f a8       	ld.ub	r8,r7[0x2]
80002188:	1a d8       	st.w	--sp,r8
8000218a:	48 8c       	lddpc	r12,800021a8 <SingleDetection_brdcst_func+0x48>
8000218c:	f0 1f 00 04 	mcall	8000219c <SingleDetection_brdcst_func+0x3c>
80002190:	2f fd       	sub	sp,-4
80002192:	e3 cd 80 80 	ldm	sp++,r7,pc
80002196:	00 00       	add	r0,r0
80002198:	80 00       	ld.sh	r0,r0[0x0]
8000219a:	e0 f8 80 00 	ld.w	r8,r0[-32768]
8000219e:	7f c4       	ld.w	r4,pc[0x70]
800021a0:	00 00       	add	r0,r0
800021a2:	00 08       	add	r8,r0
800021a4:	80 00       	ld.sh	r0,r0[0x0]
800021a6:	e1 0c 80 00 	ld.sh	r12,r0[-32768]
800021aa:	e1 1c d4 31 	ld.uh	r12,r0[-11215]

800021ac <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021ac:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021ae:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021b2:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021b4:	4a bc       	lddpc	r12,80002260 <ButtonConfig_brdcst_func+0xb4>
800021b6:	f0 1f 00 2c 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021ba:	0f 88       	ld.ub	r8,r7[0x0]
800021bc:	1a d8       	st.w	--sp,r8
800021be:	4a bc       	lddpc	r12,80002268 <ButtonConfig_brdcst_func+0xbc>
800021c0:	f0 1f 00 29 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021c4:	1a d5       	st.w	--sp,r5
800021c6:	4a ac       	lddpc	r12,8000226c <ButtonConfig_brdcst_func+0xc0>
800021c8:	f0 1f 00 27 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021cc:	0f a8       	ld.ub	r8,r7[0x2]
800021ce:	1a d8       	st.w	--sp,r8
800021d0:	4a 8c       	lddpc	r12,80002270 <ButtonConfig_brdcst_func+0xc4>
800021d2:	f0 1f 00 25 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021d6:	2f dd       	sub	sp,-12
800021d8:	58 05       	cp.w	r5,0
800021da:	c4 10       	breq	8000225c <ButtonConfig_brdcst_func+0xb0>
800021dc:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021de:	4a 64       	lddpc	r4,80002274 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021e0:	4a 63       	lddpc	r3,80002278 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021e2:	4a 72       	lddpc	r2,8000227c <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021e4:	4a 71       	lddpc	r1,80002280 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021e6:	4a 80       	lddpc	r0,80002284 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021e8:	0f b9       	ld.ub	r9,r7[0x3]
800021ea:	0f c8       	ld.ub	r8,r7[0x4]
800021ec:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021f0:	1a d8       	st.w	--sp,r8
800021f2:	1a d6       	st.w	--sp,r6
800021f4:	08 9c       	mov	r12,r4
800021f6:	f0 1f 00 1c 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021fa:	0f d9       	ld.ub	r9,r7[0x5]
800021fc:	0f e8       	ld.ub	r8,r7[0x6]
800021fe:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002202:	1a d8       	st.w	--sp,r8
80002204:	1a d6       	st.w	--sp,r6
80002206:	06 9c       	mov	r12,r3
80002208:	f0 1f 00 17 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000220c:	0f f9       	ld.ub	r9,r7[0x7]
8000220e:	ef 38 00 08 	ld.ub	r8,r7[8]
80002212:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002216:	1a d8       	st.w	--sp,r8
80002218:	1a d6       	st.w	--sp,r6
8000221a:	04 9c       	mov	r12,r2
8000221c:	f0 1f 00 12 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002220:	ef 39 00 09 	ld.ub	r9,r7[9]
80002224:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002228:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000222c:	1a d8       	st.w	--sp,r8
8000222e:	1a d6       	st.w	--sp,r6
80002230:	02 9c       	mov	r12,r1
80002232:	f0 1f 00 0d 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002236:	2f 8d       	sub	sp,-32
80002238:	ef 39 00 0b 	ld.ub	r9,r7[11]
8000223c:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002240:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002244:	1a d8       	st.w	--sp,r8
80002246:	1a d6       	st.w	--sp,r6
80002248:	00 9c       	mov	r12,r0
8000224a:	f0 1f 00 07 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
8000224e:	2f f6       	sub	r6,-1
80002250:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
80002252:	2f ed       	sub	sp,-8
80002254:	ec 05 18 00 	cp.b	r5,r6
80002258:	fe 9b ff c8 	brhi	800021e8 <ButtonConfig_brdcst_func+0x3c>
8000225c:	d8 32       	popm	r0-r7,pc
8000225e:	00 00       	add	r0,r0
80002260:	80 00       	ld.sh	r0,r0[0x0]
80002262:	e1 30 80 00 	ld.ub	r0,r0[-32768]
80002266:	7f c4       	ld.w	r4,pc[0x70]
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	e1 50 80 00 	st.h	r0[-32768],r0
8000226e:	e1 64 80 00 	st.b	r0[-32768],r4
80002272:	e1 7c 80 00 	stcond	r0[-32768],r12
80002276:	e1 9c       	*unknown*
80002278:	80 00       	ld.sh	r0,r0[0x0]
8000227a:	e1 c4 80 00 	ldm	r4,pc
8000227e:	e1 ec 80 00 	sthh.w	r0[r0],r0:b,r12:b
80002282:	e2 10 80 00 	andl	r0,0x8000,COH
80002286:	e2 38 eb cd 	sub	r8,256973

80002288 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002288:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
8000228c:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002290:	0f 89       	ld.ub	r9,r7[0x0]
80002292:	30 08       	mov	r8,0
80002294:	f0 09 18 00 	cp.b	r9,r8
80002298:	c0 c1       	brne	800022b0 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000229a:	48 9c       	lddpc	r12,800022bc <ButtonConfig_reply_func+0x34>
8000229c:	f0 1f 00 09 	mcall	800022c0 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022a0:	0f 98       	ld.ub	r8,r7[0x1]
800022a2:	1a d8       	st.w	--sp,r8
800022a4:	48 8c       	lddpc	r12,800022c4 <ButtonConfig_reply_func+0x3c>
800022a6:	f0 1f 00 07 	mcall	800022c0 <ButtonConfig_reply_func+0x38>
800022aa:	2f fd       	sub	sp,-4
800022ac:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022b0:	48 6c       	lddpc	r12,800022c8 <ButtonConfig_reply_func+0x40>
800022b2:	f0 1f 00 04 	mcall	800022c0 <ButtonConfig_reply_func+0x38>
800022b6:	e3 cd 80 80 	ldm	sp++,r7,pc
800022ba:	00 00       	add	r0,r0
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	e2 5c 80 00 	cp.w	r12,229376
800022c2:	7f c4       	ld.w	r4,pc[0x70]
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	e1 50 80 00 	st.h	r0[-32768],r0
800022ca:	e2 74 eb cd 	mov	r4,256973

800022cc <BatteryLevel_brdcst_func>:
	
}


void BatteryLevel_brdcst_func(xcmp_fragment_t * xcmp)
{
800022cc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	BatteryLevel_brdcast_t *ptr = (BatteryLevel_brdcast_t* )(xcmp->u8);
800022d0:	f8 c7 ff fe 	sub	r7,r12,-2
	if(ptr->State == Battery_Okay)
800022d4:	0f 89       	ld.ub	r9,r7[0x0]
800022d6:	30 08       	mov	r8,0
800022d8:	f0 09 18 00 	cp.b	r9,r8
800022dc:	c0 40       	breq	800022e4 <BatteryLevel_brdcst_func+0x18>
		;//log("\n Battery Okay\n");
	else
		log("\n Battery Low !!!\n");
800022de:	48 5c       	lddpc	r12,800022f0 <BatteryLevel_brdcst_func+0x24>
800022e0:	f0 1f 00 05 	mcall	800022f4 <BatteryLevel_brdcst_func+0x28>
		
	//log("\n Battery charge: %X \n" , ptr->Charge);
	//log("\n Battery voltage: %X \n" , ptr->Voltage);
	
	Battery_Flag = ptr->State;
800022e4:	0f 89       	ld.ub	r9,r7[0x0]
800022e6:	48 58       	lddpc	r8,800022f8 <BatteryLevel_brdcst_func+0x2c>
800022e8:	b0 89       	st.b	r8[0x0],r9

}
800022ea:	e3 cd 80 80 	ldm	sp++,r7,pc
800022ee:	00 00       	add	r0,r0
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	e2 90 80 00 	breq	800722f2 <_data_lma+0x62cb2>
800022f6:	7f c4       	ld.w	r4,pc[0x70]
800022f8:	00 00       	add	r0,r0
800022fa:	0a 88       	andn	r8,r5

800022fc <ShutDown_brdcst_func>:
		log("ID:  %X \n", xcmp->u8[2]);
	}
	
}
void ShutDown_brdcst_func(xcmp_fragment_t * xcmp)
{
800022fc:	d4 01       	pushm	lr
	if (xcmp->u8[0] == Shut_Down_Device)
800022fe:	19 a8       	ld.ub	r8,r12[0x2]
80002300:	30 19       	mov	r9,1
80002302:	f2 08 18 00 	cp.b	r8,r9
80002306:	c0 51       	brne	80002310 <ShutDown_brdcst_func+0x14>
	{
		log("Shut_Down_Device \n");
80002308:	48 6c       	lddpc	r12,80002320 <ShutDown_brdcst_func+0x24>
8000230a:	f0 1f 00 07 	mcall	80002324 <ShutDown_brdcst_func+0x28>
8000230e:	d8 02       	popm	pc
		
	}
	else if(xcmp->u8[0] == Reset_Device)
80002310:	30 29       	mov	r9,2
80002312:	f2 08 18 00 	cp.b	r8,r9
80002316:	c0 41       	brne	8000231e <ShutDown_brdcst_func+0x22>
	{
		log("Reset_Device \n");
80002318:	48 4c       	lddpc	r12,80002328 <ShutDown_brdcst_func+0x2c>
8000231a:	f0 1f 00 03 	mcall	80002324 <ShutDown_brdcst_func+0x28>
8000231e:	d8 02       	popm	pc
80002320:	80 00       	ld.sh	r0,r0[0x0]
80002322:	e2 a4       	*unknown*
80002324:	80 00       	ld.sh	r0,r0[0x0]
80002326:	7f c4       	ld.w	r4,pc[0x70]
80002328:	80 00       	ld.sh	r0,r0[0x0]
8000232a:	e2 b8       	*unknown*

8000232c <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
8000232c:	eb cd 40 80 	pushm	r7,lr
80002330:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002332:	19 a9       	ld.ub	r9,r12[0x2]
80002334:	30 08       	mov	r8,0
80002336:	f0 09 18 00 	cp.b	r9,r8
8000233a:	c0 61       	brne	80002346 <DataSession_reply_func+0x1a>
	{
		log("DATArep OK \n");
8000233c:	48 dc       	lddpc	r12,80002370 <DataSession_reply_func+0x44>
8000233e:	f0 1f 00 0e 	mcall	80002374 <DataSession_reply_func+0x48>
80002342:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("ID: %X \n", xcmp->u8[2]);
		
	}
	else
	{	
		log("DATArep error \n");
80002346:	48 dc       	lddpc	r12,80002378 <DataSession_reply_func+0x4c>
80002348:	f0 1f 00 0b 	mcall	80002374 <DataSession_reply_func+0x48>
		log("Result:  %X \n", xcmp->u8[0]);
8000234c:	0f a8       	ld.ub	r8,r7[0x2]
8000234e:	1a d8       	st.w	--sp,r8
80002350:	48 bc       	lddpc	r12,8000237c <DataSession_reply_func+0x50>
80002352:	f0 1f 00 09 	mcall	80002374 <DataSession_reply_func+0x48>
		log("Func:  %X \n", xcmp->u8[1]);
80002356:	0f b8       	ld.ub	r8,r7[0x3]
80002358:	1a d8       	st.w	--sp,r8
8000235a:	48 ac       	lddpc	r12,80002380 <DataSession_reply_func+0x54>
8000235c:	f0 1f 00 06 	mcall	80002374 <DataSession_reply_func+0x48>
		log("ID:  %X \n", xcmp->u8[2]);
80002360:	0f c8       	ld.ub	r8,r7[0x4]
80002362:	1a d8       	st.w	--sp,r8
80002364:	48 8c       	lddpc	r12,80002384 <DataSession_reply_func+0x58>
80002366:	f0 1f 00 04 	mcall	80002374 <DataSession_reply_func+0x48>
8000236a:	2f dd       	sub	sp,-12
8000236c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	e2 c8 80 00 	sub	r8,r1,-32768
80002376:	7f c4       	ld.w	r4,pc[0x70]
80002378:	80 00       	ld.sh	r0,r0[0x0]
8000237a:	e2 d8 80 00 	satsub.w	r8,r1,-32768
8000237e:	e2 e8 80 00 	ld.d	r8,r1[-32768]
80002382:	e2 f8 80 00 	ld.w	r8,r1[-32768]
80002386:	e3 04 eb cd 	ld.sh	r4,r1[-5171]

80002388 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002388:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
8000238c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002390:	0f 98       	ld.ub	r8,r7[0x1]
80002392:	1a d8       	st.w	--sp,r8
80002394:	48 bc       	lddpc	r12,800023c0 <CallControl_brdcst_func+0x38>
80002396:	f0 1f 00 0c 	mcall	800023c4 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000239a:	2f fd       	sub	sp,-4
8000239c:	0f 99       	ld.ub	r9,r7[0x1]
8000239e:	30 38       	mov	r8,3
800023a0:	f0 09 18 00 	cp.b	r9,r8
800023a4:	c0 41       	brne	800023ac <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
800023a6:	30 09       	mov	r9,0
800023a8:	48 88       	lddpc	r8,800023c8 <CallControl_brdcst_func+0x40>
800023aa:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800023ac:	0f 99       	ld.ub	r9,r7[0x1]
800023ae:	30 48       	mov	r8,4
800023b0:	f0 09 18 00 	cp.b	r9,r8
800023b4:	c0 41       	brne	800023bc <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800023b6:	30 19       	mov	r9,1
800023b8:	48 48       	lddpc	r8,800023c8 <CallControl_brdcst_func+0x40>
800023ba:	b0 89       	st.b	r8[0x0],r9
800023bc:	e3 cd 80 80 	ldm	sp++,r7,pc
800023c0:	80 00       	ld.sh	r0,r0[0x0]
800023c2:	e3 10 80 00 	ld.uh	r0,r1[-32768]
800023c6:	7f c4       	ld.w	r4,pc[0x70]
800023c8:	00 00       	add	r0,r0
800023ca:	0a 8a       	andn	r10,r5

800023cc <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023cc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800023d0:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800023d4:	0f 99       	ld.ub	r9,r7[0x1]
800023d6:	30 08       	mov	r8,0
800023d8:	f0 09 18 00 	cp.b	r9,r8
800023dc:	c0 71       	brne	800023ea <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800023de:	48 ac       	lddpc	r12,80002404 <TransmitControl_brdcst_func+0x38>
800023e0:	f0 1f 00 0a 	mcall	80002408 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800023e4:	30 09       	mov	r9,0
800023e6:	48 a8       	lddpc	r8,8000240c <TransmitControl_brdcst_func+0x40>
800023e8:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800023ea:	0f 99       	ld.ub	r9,r7[0x1]
800023ec:	30 18       	mov	r8,1
800023ee:	f0 09 18 00 	cp.b	r9,r8
800023f2:	c0 71       	brne	80002400 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800023f4:	48 7c       	lddpc	r12,80002410 <TransmitControl_brdcst_func+0x44>
800023f6:	f0 1f 00 05 	mcall	80002408 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800023fa:	30 19       	mov	r9,1
800023fc:	48 48       	lddpc	r8,8000240c <TransmitControl_brdcst_func+0x40>
800023fe:	b0 89       	st.b	r8[0x0],r9
80002400:	e3 cd 80 80 	ldm	sp++,r7,pc
80002404:	80 00       	ld.sh	r0,r0[0x0]
80002406:	e3 28 80 00 	ld.sb	r8,r1[-32768]
8000240a:	7f c4       	ld.w	r4,pc[0x70]
8000240c:	00 00       	add	r0,r0
8000240e:	0a 60       	and	r0,r5
80002410:	80 00       	ld.sh	r0,r0[0x0]
80002412:	e3 40 eb cd 	st.w	r1[-5171],r0

80002414 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002414:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002418:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000241c:	0f 89       	ld.ub	r9,r7[0x0]
8000241e:	30 08       	mov	r8,0
80002420:	f0 09 18 00 	cp.b	r9,r8
80002424:	c1 61       	brne	80002450 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002426:	48 ec       	lddpc	r12,8000245c <TransmitControl_reply_func+0x48>
80002428:	f0 1f 00 0e 	mcall	80002460 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
8000242c:	0f 98       	ld.ub	r8,r7[0x1]
8000242e:	1a d8       	st.w	--sp,r8
80002430:	48 dc       	lddpc	r12,80002464 <TransmitControl_reply_func+0x50>
80002432:	f0 1f 00 0c 	mcall	80002460 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002436:	0f a8       	ld.ub	r8,r7[0x2]
80002438:	1a d8       	st.w	--sp,r8
8000243a:	48 cc       	lddpc	r12,80002468 <TransmitControl_reply_func+0x54>
8000243c:	f0 1f 00 09 	mcall	80002460 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002440:	0f b8       	ld.ub	r8,r7[0x3]
80002442:	1a d8       	st.w	--sp,r8
80002444:	48 ac       	lddpc	r12,8000246c <TransmitControl_reply_func+0x58>
80002446:	f0 1f 00 07 	mcall	80002460 <TransmitControl_reply_func+0x4c>
8000244a:	2f dd       	sub	sp,-12
8000244c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002450:	48 8c       	lddpc	r12,80002470 <TransmitControl_reply_func+0x5c>
80002452:	f0 1f 00 04 	mcall	80002460 <TransmitControl_reply_func+0x4c>
80002456:	e3 cd 80 80 	ldm	sp++,r7,pc
8000245a:	00 00       	add	r0,r0
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	e3 54 80 00 	st.h	r1[-32768],r4
80002462:	7f c4       	ld.w	r4,pc[0x70]
80002464:	80 00       	ld.sh	r0,r0[0x0]
80002466:	e3 70 80 00 	stcond	r1[-32768],r0
8000246a:	e3 84       	*unknown*
8000246c:	80 00       	ld.sh	r0,r0[0x0]
8000246e:	e3 a0 80 00 	cop	cp4,cr0,cr0,cr0,0x20
80002472:	e3 b0       	*unknown*

80002474 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002474:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002476:	19 a9       	ld.ub	r9,r12[0x2]
80002478:	30 08       	mov	r8,0
8000247a:	f0 09 18 00 	cp.b	r9,r8
8000247e:	c0 51       	brne	80002488 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002480:	48 4c       	lddpc	r12,80002490 <AudioRoutingControl_reply_func+0x1c>
80002482:	f0 1f 00 05 	mcall	80002494 <AudioRoutingControl_reply_func+0x20>
80002486:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002488:	48 4c       	lddpc	r12,80002498 <AudioRoutingControl_reply_func+0x24>
8000248a:	f0 1f 00 03 	mcall	80002494 <AudioRoutingControl_reply_func+0x20>
8000248e:	d8 02       	popm	pc
80002490:	80 00       	ld.sh	r0,r0[0x0]
80002492:	e3 c8 80 00 	ldm	r8++,pc
80002496:	7f c4       	ld.w	r4,pc[0x70]
80002498:	80 00       	ld.sh	r0,r0[0x0]
8000249a:	e3 d8       	*unknown*

8000249c <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
8000249c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
800024a0:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
800024a4:	0f 89       	ld.ub	r9,r7[0x0]
800024a6:	30 08       	mov	r8,0
800024a8:	f0 09 18 00 	cp.b	r9,r8
800024ac:	c1 b1       	brne	800024e2 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800024ae:	0f b8       	ld.ub	r8,r7[0x3]
800024b0:	31 09       	mov	r9,16
800024b2:	f2 08 18 00 	cp.b	r8,r9
800024b6:	c0 f1       	brne	800024d4 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800024b8:	48 dc       	lddpc	r12,800024ec <Volume_reply_func+0x50>
800024ba:	f0 1f 00 0e 	mcall	800024f0 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800024be:	0f 99       	ld.ub	r9,r7[0x1]
800024c0:	0f a8       	ld.ub	r8,r7[0x2]
800024c2:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800024c6:	1a d8       	st.w	--sp,r8
800024c8:	48 bc       	lddpc	r12,800024f4 <Volume_reply_func+0x58>
800024ca:	f0 1f 00 0a 	mcall	800024f0 <Volume_reply_func+0x54>
800024ce:	2f fd       	sub	sp,-4
800024d0:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800024d4:	1a d8       	st.w	--sp,r8
800024d6:	48 9c       	lddpc	r12,800024f8 <Volume_reply_func+0x5c>
800024d8:	f0 1f 00 06 	mcall	800024f0 <Volume_reply_func+0x54>
800024dc:	2f fd       	sub	sp,-4
800024de:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024e2:	48 7c       	lddpc	r12,800024fc <Volume_reply_func+0x60>
800024e4:	f0 1f 00 03 	mcall	800024f0 <Volume_reply_func+0x54>
800024e8:	e3 cd 80 80 	ldm	sp++,r7,pc
800024ec:	80 00       	ld.sh	r0,r0[0x0]
800024ee:	e3 ec 80 00 	sthh.w	r0[r0],r1:b,r12:b
800024f2:	7f c4       	ld.w	r4,pc[0x70]
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	e4 00       	*unknown*
800024f8:	80 00       	ld.sh	r0,r0[0x0]
800024fa:	e4 1c 80 00 	andh	r12,0x8000
800024fe:	e4 34 d4 01 	sub	r4,381953

80002500 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002500:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002502:	19 d9       	ld.ub	r9,r12[0x5]
80002504:	30 08       	mov	r8,0
80002506:	f0 09 18 00 	cp.b	r9,r8
8000250a:	c0 81       	brne	8000251a <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
8000250c:	10 99       	mov	r9,r8
8000250e:	48 78       	lddpc	r8,80002528 <spk_brdcst_func+0x28>
80002510:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
80002512:	48 7c       	lddpc	r12,8000252c <spk_brdcst_func+0x2c>
80002514:	f0 1f 00 07 	mcall	80002530 <spk_brdcst_func+0x30>
80002518:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
8000251a:	30 19       	mov	r9,1
8000251c:	48 38       	lddpc	r8,80002528 <spk_brdcst_func+0x28>
8000251e:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002520:	48 5c       	lddpc	r12,80002534 <spk_brdcst_func+0x34>
80002522:	f0 1f 00 04 	mcall	80002530 <spk_brdcst_func+0x30>
80002526:	d8 02       	popm	pc
80002528:	00 00       	add	r0,r0
8000252a:	0a 81       	andn	r1,r5
8000252c:	80 00       	ld.sh	r0,r0[0x0]
8000252e:	e4 4c 80 00 	cp.w	r12,294912
80002532:	7f c4       	ld.w	r4,pc[0x70]
80002534:	80 00       	ld.sh	r0,r0[0x0]
80002536:	e4 5c d4 01 	cp.w	r12,381953

80002538 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002538:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000253a:	19 a9       	ld.ub	r9,r12[0x2]
8000253c:	30 08       	mov	r8,0
8000253e:	f0 09 18 00 	cp.b	r9,r8
80002542:	c0 f1       	brne	80002560 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002544:	19 e9       	ld.ub	r9,r12[0x6]
80002546:	f0 09 18 00 	cp.b	r9,r8
8000254a:	c0 40       	breq	80002552 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
8000254c:	30 19       	mov	r9,1
8000254e:	48 98       	lddpc	r8,80002570 <spk_reply_func+0x38>
80002550:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80002552:	19 e8       	ld.ub	r8,r12[0x6]
80002554:	1a d8       	st.w	--sp,r8
80002556:	48 8c       	lddpc	r12,80002574 <spk_reply_func+0x3c>
80002558:	f0 1f 00 08 	mcall	80002578 <spk_reply_func+0x40>
8000255c:	2f fd       	sub	sp,-4
8000255e:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002560:	30 09       	mov	r9,0
80002562:	48 48       	lddpc	r8,80002570 <spk_reply_func+0x38>
80002564:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
80002566:	48 6c       	lddpc	r12,8000257c <spk_reply_func+0x44>
80002568:	f0 1f 00 04 	mcall	80002578 <spk_reply_func+0x40>
8000256c:	d8 02       	popm	pc
8000256e:	00 00       	add	r0,r0
80002570:	00 00       	add	r0,r0
80002572:	0a 81       	andn	r1,r5
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	e4 68 80 00 	mov	r8,294912
8000257a:	7f c4       	ld.w	r4,pc[0x70]
8000257c:	80 00       	ld.sh	r0,r0[0x0]
8000257e:	e4 78 eb cd 	mov	r8,388045

80002580 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002580:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002584:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002588:	0f a9       	ld.ub	r9,r7[0x2]
8000258a:	30 08       	mov	r8,0
8000258c:	f0 09 18 00 	cp.b	r9,r8
80002590:	c0 71       	brne	8000259e <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
80002592:	48 dc       	lddpc	r12,800025c4 <mic_brdcst_func+0x44>
80002594:	f0 1f 00 0d 	mcall	800025c8 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002598:	30 09       	mov	r9,0
8000259a:	48 d8       	lddpc	r8,800025cc <mic_brdcst_func+0x4c>
8000259c:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
8000259e:	0f a9       	ld.ub	r9,r7[0x2]
800025a0:	31 18       	mov	r8,17
800025a2:	f0 09 18 00 	cp.b	r9,r8
800025a6:	c0 d1       	brne	800025c0 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800025a8:	48 ac       	lddpc	r12,800025d0 <mic_brdcst_func+0x50>
800025aa:	f0 1f 00 08 	mcall	800025c8 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800025ae:	48 89       	lddpc	r9,800025cc <mic_brdcst_func+0x4c>
800025b0:	30 18       	mov	r8,1
800025b2:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800025b4:	13 89       	ld.ub	r9,r9[0x0]
800025b6:	f0 09 18 00 	cp.b	r9,r8
800025ba:	c0 31       	brne	800025c0 <mic_brdcst_func+0x40>
800025bc:	48 68       	lddpc	r8,800025d4 <mic_brdcst_func+0x54>
800025be:	11 88       	ld.ub	r8,r8[0x0]
800025c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800025c4:	80 00       	ld.sh	r0,r0[0x0]
800025c6:	e4 84 80 00 	brge	800925c6 <_data_lma+0x82f86>
800025ca:	7f c4       	ld.w	r4,pc[0x70]
800025cc:	00 00       	add	r0,r0
800025ce:	0a 80       	andn	r0,r5
800025d0:	80 00       	ld.sh	r0,r0[0x0]
800025d2:	e4 98 00 00 	brls	800a25d2 <_data_lma+0x92f92>
800025d6:	0a 8a       	andn	r10,r5

800025d8 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025d8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025dc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025e0:	49 ac       	lddpc	r12,80002648 <mic_reply_func+0x70>
800025e2:	f0 1f 00 1b 	mcall	8000264c <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025e6:	0f 89       	ld.ub	r9,r7[0x0]
800025e8:	30 08       	mov	r8,0
800025ea:	f0 09 18 00 	cp.b	r9,r8
800025ee:	c2 71       	brne	8000263c <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025f0:	0f 98       	ld.ub	r8,r7[0x1]
800025f2:	30 29       	mov	r9,2
800025f4:	f2 08 18 00 	cp.b	r8,r9
800025f8:	c1 b1       	brne	8000262e <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800025fa:	49 6c       	lddpc	r12,80002650 <mic_reply_func+0x78>
800025fc:	f0 1f 00 14 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002600:	0f a8       	ld.ub	r8,r7[0x2]
80002602:	1a d8       	st.w	--sp,r8
80002604:	49 4c       	lddpc	r12,80002654 <mic_reply_func+0x7c>
80002606:	f0 1f 00 12 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
8000260a:	0f b8       	ld.ub	r8,r7[0x3]
8000260c:	1a d8       	st.w	--sp,r8
8000260e:	49 3c       	lddpc	r12,80002658 <mic_reply_func+0x80>
80002610:	f0 1f 00 0f 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002614:	0f c8       	ld.ub	r8,r7[0x4]
80002616:	1a d8       	st.w	--sp,r8
80002618:	49 1c       	lddpc	r12,8000265c <mic_reply_func+0x84>
8000261a:	f0 1f 00 0d 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
8000261e:	0f d8       	ld.ub	r8,r7[0x5]
80002620:	1a d8       	st.w	--sp,r8
80002622:	49 0c       	lddpc	r12,80002660 <mic_reply_func+0x88>
80002624:	f0 1f 00 0a 	mcall	8000264c <mic_reply_func+0x74>
80002628:	2f cd       	sub	sp,-16
8000262a:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
8000262e:	1a d8       	st.w	--sp,r8
80002630:	48 dc       	lddpc	r12,80002664 <mic_reply_func+0x8c>
80002632:	f0 1f 00 07 	mcall	8000264c <mic_reply_func+0x74>
80002636:	2f fd       	sub	sp,-4
80002638:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
8000263c:	48 bc       	lddpc	r12,80002668 <mic_reply_func+0x90>
8000263e:	f0 1f 00 04 	mcall	8000264c <mic_reply_func+0x74>
80002642:	e3 cd 80 80 	ldm	sp++,r7,pc
80002646:	00 00       	add	r0,r0
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	e4 ac       	*unknown*
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	7f c4       	ld.w	r4,pc[0x70]
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	e4 bc       	*unknown*
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	e4 d0 80 00 	satsub.w	r0,r2,-32768
8000265a:	e4 e4 80 00 	ld.d	r4,r2[-32768]
8000265e:	e5 00 80 00 	ld.sh	r0,r2[-32768]
80002662:	e5 18 80 00 	ld.uh	r8,r2[-32768]
80002666:	e5 30 80 00 	ld.ub	r0,r2[-32768]
8000266a:	e5 48 eb cd 	st.w	r2[-5171],r8

8000266c <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
8000266c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002670:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002674:	48 bc       	lddpc	r12,800026a0 <dcm_brdcst_func+0x34>
80002676:	f0 1f 00 0c 	mcall	800026a4 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
8000267a:	0f 88       	ld.ub	r8,r7[0x0]
8000267c:	1a d8       	st.w	--sp,r8
8000267e:	48 bc       	lddpc	r12,800026a8 <dcm_brdcst_func+0x3c>
80002680:	f0 1f 00 09 	mcall	800026a4 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002684:	0f a8       	ld.ub	r8,r7[0x2]
80002686:	1a d8       	st.w	--sp,r8
80002688:	48 9c       	lddpc	r12,800026ac <dcm_brdcst_func+0x40>
8000268a:	f0 1f 00 07 	mcall	800026a4 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
8000268e:	0f 98       	ld.ub	r8,r7[0x1]
80002690:	1a d8       	st.w	--sp,r8
80002692:	48 8c       	lddpc	r12,800026b0 <dcm_brdcst_func+0x44>
80002694:	f0 1f 00 04 	mcall	800026a4 <dcm_brdcst_func+0x38>
80002698:	2f dd       	sub	sp,-12
	
	
}
8000269a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000269e:	00 00       	add	r0,r0
800026a0:	80 00       	ld.sh	r0,r0[0x0]
800026a2:	e5 58 80 00 	st.h	r2[-32768],r8
800026a6:	7f c4       	ld.w	r4,pc[0x70]
800026a8:	80 00       	ld.sh	r0,r0[0x0]
800026aa:	e5 6c 80 00 	st.b	r2[-32768],r12
800026ae:	e5 80       	*unknown*
800026b0:	80 00       	ld.sh	r0,r0[0x0]
800026b2:	e5 98       	*unknown*

800026b4 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800026b4:	eb cd 40 80 	pushm	r7,lr
800026b8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800026ba:	19 a9       	ld.ub	r9,r12[0x2]
800026bc:	30 08       	mov	r8,0
800026be:	f0 09 18 00 	cp.b	r9,r8
800026c2:	c1 b1       	brne	800026f8 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800026c4:	19 b8       	ld.ub	r8,r12[0x3]
800026c6:	30 19       	mov	r9,1
800026c8:	f2 08 18 00 	cp.b	r8,r9
800026cc:	c0 51       	brne	800026d6 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800026ce:	48 ec       	lddpc	r12,80002704 <dcm_reply_func+0x50>
800026d0:	f0 1f 00 0e 	mcall	80002708 <dcm_reply_func+0x54>
800026d4:	c0 a8       	rjmp	800026e8 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800026d6:	58 08       	cp.w	r8,0
800026d8:	c0 51       	brne	800026e2 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026da:	48 dc       	lddpc	r12,8000270c <dcm_reply_func+0x58>
800026dc:	f0 1f 00 0b 	mcall	80002708 <dcm_reply_func+0x54>
800026e0:	c0 48       	rjmp	800026e8 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026e2:	48 cc       	lddpc	r12,80002710 <dcm_reply_func+0x5c>
800026e4:	f0 1f 00 09 	mcall	80002708 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026e8:	0f d8       	ld.ub	r8,r7[0x5]
800026ea:	1a d8       	st.w	--sp,r8
800026ec:	48 ac       	lddpc	r12,80002714 <dcm_reply_func+0x60>
800026ee:	f0 1f 00 07 	mcall	80002708 <dcm_reply_func+0x54>
800026f2:	2f fd       	sub	sp,-4
800026f4:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800026f8:	48 8c       	lddpc	r12,80002718 <dcm_reply_func+0x64>
800026fa:	f0 1f 00 04 	mcall	80002708 <dcm_reply_func+0x54>
800026fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002702:	00 00       	add	r0,r0
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	e5 b4       	*unknown*
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	7f c4       	ld.w	r4,pc[0x70]
8000270c:	80 00       	ld.sh	r0,r0[0x0]
8000270e:	e5 c8 80 00 	ldmts	r8,pc
80002712:	e5 dc 80 00 	ldswp.w	r12,r2[0]
80002716:	e5 f0 80 00 	ld.wls	r0,r2[0x0]
8000271a:	e5 fc d4 01 	ld.shvc	r12,r2[0x2]

8000271c <ToneControl_reply_func>:
			//}
		//}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
8000271c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000271e:	19 a9       	ld.ub	r9,r12[0x2]
80002720:	30 08       	mov	r8,0
80002722:	f0 09 18 00 	cp.b	r9,r8
80002726:	c0 51       	brne	80002730 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002728:	48 4c       	lddpc	r12,80002738 <ToneControl_reply_func+0x1c>
8000272a:	f0 1f 00 05 	mcall	8000273c <ToneControl_reply_func+0x20>
8000272e:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002730:	48 4c       	lddpc	r12,80002740 <ToneControl_reply_func+0x24>
80002732:	f0 1f 00 03 	mcall	8000273c <ToneControl_reply_func+0x20>
80002736:	d8 02       	popm	pc
80002738:	80 00       	ld.sh	r0,r0[0x0]
8000273a:	e6 08       	*unknown*
8000273c:	80 00       	ld.sh	r0,r0[0x0]
8000273e:	7f c4       	ld.w	r4,pc[0x70]
80002740:	80 00       	ld.sh	r0,r0[0x0]
80002742:	e6 14 eb cd 	andh	r4,0xebcd,COH

80002744 <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
80002744:	eb cd 40 c0 	pushm	r6-r7,lr
	xcmp_register_app_list(the_app_list);
80002748:	49 7c       	lddpc	r12,800027a4 <app_init+0x60>
8000274a:	f0 1f 00 18 	mcall	800027a8 <app_init+0x64>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
8000274e:	49 8b       	lddpc	r11,800027ac <app_init+0x68>
80002750:	49 8c       	lddpc	r12,800027b0 <app_init+0x6c>
80002752:	f0 1f 00 19 	mcall	800027b4 <app_init+0x70>
	
	/* Create the mutex semaphore to guard a shared global_count.*/
	count_mutex = xSemaphoreCreateMutex();
80002756:	f0 1f 00 19 	mcall	800027b8 <app_init+0x74>
8000275a:	49 98       	lddpc	r8,800027bc <app_init+0x78>
8000275c:	91 0c       	st.w	r8[0x0],r12
	if (count_mutex == NULL)
8000275e:	70 08       	ld.w	r8,r8[0x0]
80002760:	58 08       	cp.w	r8,0
80002762:	c0 41       	brne	8000276a <app_init+0x26>
	{
		log("Create the count_mutex semaphore failure\n");
80002764:	49 7c       	lddpc	r12,800027c0 <app_init+0x7c>
80002766:	f0 1f 00 18 	mcall	800027c4 <app_init+0x80>
	}
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000276a:	30 07       	mov	r7,0
8000276c:	1a d7       	st.w	--sp,r7
8000276e:	1a d7       	st.w	--sp,r7
80002770:	1a d7       	st.w	--sp,r7
80002772:	30 28       	mov	r8,2
80002774:	0e 99       	mov	r9,r7
80002776:	e0 6a 02 ee 	mov	r10,750
8000277a:	49 4b       	lddpc	r11,800027c8 <app_init+0x84>
8000277c:	49 4c       	lddpc	r12,800027cc <app_init+0x88>
8000277e:	f0 1f 00 15 	mcall	800027d0 <app_init+0x8c>
80002782:	49 56       	lddpc	r6,800027d4 <app_init+0x90>
80002784:	8d 0c       	st.w	r6[0x0],r12
	,  750//1024//800//384
	,  NULL
	,  2
	,  NULL );
	
	 res = xTaskCreate(
80002786:	1a d7       	st.w	--sp,r7
80002788:	1a d7       	st.w	--sp,r7
8000278a:	1a d7       	st.w	--sp,r7
8000278c:	30 18       	mov	r8,1
8000278e:	0e 99       	mov	r9,r7
80002790:	e0 6a 03 20 	mov	r10,800
80002794:	49 1b       	lddpc	r11,800027d8 <app_init+0x94>
80002796:	49 2c       	lddpc	r12,800027dc <app_init+0x98>
80002798:	f0 1f 00 0e 	mcall	800027d0 <app_init+0x8c>
8000279c:	8d 0c       	st.w	r6[0x0],r12
8000279e:	2f ad       	sub	sp,-24
	 ,  800
	 ,  NULL
	 ,  1
	 ,  NULL );
	
}
800027a0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800027a4:	00 00       	add	r0,r0
800027a6:	00 10       	sub	r0,r0
800027a8:	80 00       	ld.sh	r0,r0[0x0]
800027aa:	48 74       	lddpc	r4,800027c4 <app_init+0x80>
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	20 58       	sub	r8,5
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	20 6c       	sub	r12,6
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	35 1c       	mov	r12,81
800027b8:	80 00       	ld.sh	r0,r0[0x0]
800027ba:	74 8c       	ld.w	r12,r10[0x20]
800027bc:	00 00       	add	r0,r0
800027be:	0a 7c       	tst	r12,r5
800027c0:	80 00       	ld.sh	r0,r0[0x0]
800027c2:	e6 20 80 00 	sub	r0,425984
800027c6:	7f c4       	ld.w	r4,pc[0x70]
800027c8:	80 00       	ld.sh	r0,r0[0x0]
800027ca:	e6 4c 80 00 	cp.w	r12,425984
800027ce:	29 2c       	sub	r12,-110
800027d0:	80 00       	ld.sh	r0,r0[0x0]
800027d2:	7c 00       	ld.w	r0,lr[0x0]
800027d4:	00 00       	add	r0,r0
800027d6:	0a 68       	and	r8,r5
800027d8:	80 00       	ld.sh	r0,r0[0x0]
800027da:	e6 54 80 00 	cp.w	r4,491520
800027de:	27 e0       	sub	r0,126

800027e0 <send_message>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static void send_message(void * pvParameters)
{
800027e0:	d4 31       	pushm	r0-r7,lr
	static U16 message_count =0;
	U32 destination = DEST;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U16  * data_ptr;
	Message_Protocol_t *m_buff = (Message_Protocol_t *) pvPortMalloc(sizeof(Message_Protocol_t));
800027e2:	32 0c       	mov	r12,32
800027e4:	f0 1f 00 3a 	mcall	800028cc <send_message+0xec>
800027e8:	18 94       	mov	r4,r12
	static xgflash_status_t status = XG_ERROR;
	
	xLastWakeTime = xTaskGetTickCount();
800027ea:	f0 1f 00 3a 	mcall	800028d0 <send_message+0xf0>
800027ee:	4b a8       	lddpc	r8,800028d4 <send_message+0xf4>
800027f0:	91 0c       	st.w	r8[0x0],r12
	static  portTickType water_value;
	/*clear xBinarySemaphore and wait Datasession broadcast reply*/
	xSemaphoreTake(xBinarySemaphore, portMAX_DELAY);
800027f2:	4b a8       	lddpc	r8,800028d8 <send_message+0xf8>
800027f4:	70 0c       	ld.w	r12,r8[0x0]
800027f6:	30 09       	mov	r9,0
800027f8:	3f fa       	mov	r10,-1
800027fa:	12 9b       	mov	r11,r9
800027fc:	f0 1f 00 38 	mcall	800028dc <send_message+0xfc>
	
	for (;;)
	{
	
		message_count = xgflash_get_message_count();
80002800:	4b 85       	lddpc	r5,800028e0 <send_message+0x100>
			{
				log("get message err : %d\n", status);
			}
		
		}
		else if (Battery_Flag == Battery_Low)
80002802:	4b 97       	lddpc	r7,800028e4 <send_message+0x104>
80002804:	30 16       	mov	r6,1
	
	for (;;)
	{
	
		message_count = xgflash_get_message_count();
		if( (message_count!=0) && (Battery_Flag == Battery_Okay) && (connect_flag))//有缓存且电量充足，需发送短信
80002806:	4b 93       	lddpc	r3,800028e8 <send_message+0x108>
		{
			log("Current_total_message_count: %d\n", message_count);
80002808:	4b 90       	lddpc	r0,800028ec <send_message+0x10c>
			if(m_buff==NULL)break;
			status = xgflash_get_message_data(message_count, m_buff, TRUE);
8000280a:	30 12       	mov	r2,1
8000280c:	4b 91       	lddpc	r1,800028f0 <send_message+0x110>
	xSemaphoreTake(xBinarySemaphore, portMAX_DELAY);
	
	for (;;)
	{
	
		message_count = xgflash_get_message_count();
8000280e:	f0 1f 00 3a 	mcall	800028f4 <send_message+0x114>
80002812:	5c 8c       	casts.h	r12
80002814:	aa 0c       	st.h	r5[0x0],r12
		if( (message_count!=0) && (Battery_Flag == Battery_Okay) && (connect_flag))//有缓存且电量充足，需发送短信
80002816:	c4 c0       	breq	800028ae <send_message+0xce>
80002818:	0f 88       	ld.ub	r8,r7[0x0]
8000281a:	58 08       	cp.w	r8,0
8000281c:	c4 91       	brne	800028ae <send_message+0xce>
8000281e:	07 88       	ld.ub	r8,r3[0x0]
80002820:	58 08       	cp.w	r8,0
80002822:	c4 60       	breq	800028ae <send_message+0xce>
		{
			log("Current_total_message_count: %d\n", message_count);
80002824:	5c 7c       	castu.h	r12
80002826:	1a dc       	st.w	--sp,r12
80002828:	00 9c       	mov	r12,r0
8000282a:	f0 1f 00 34 	mcall	800028f8 <send_message+0x118>
			if(m_buff==NULL)break;
8000282e:	2f fd       	sub	sp,-4
80002830:	58 04       	cp.w	r4,0
80002832:	c4 b0       	breq	800028c8 <send_message+0xe8>
			status = xgflash_get_message_data(message_count, m_buff, TRUE);
80002834:	04 9a       	mov	r10,r2
80002836:	08 9b       	mov	r11,r4
80002838:	8a 8c       	ld.uh	r12,r5[0x0]
8000283a:	f0 1f 00 31 	mcall	800028fc <send_message+0x11c>
8000283e:	83 0c       	st.w	r1[0x0],r12
			if(status == XG_OK)
80002840:	c3 11       	brne	800028a2 <send_message+0xc2>
			{
				xcmp_data_session_req(m_buff, (sizeof(Message_Protocol_t)), destination);//send message
80002842:	36 4a       	mov	r10,100
80002844:	32 0b       	mov	r11,32
80002846:	08 9c       	mov	r12,r4
80002848:	f0 1f 00 2e 	mcall	80002900 <send_message+0x120>
				
				//if(xSemaphoreTake(SendM_CountingSemaphore, (20000*2) / portTICK_RATE_MS) == pdTRUE)
				if(xSemaphoreTake(xBinarySemaphore, (20000*2) / portTICK_RATE_MS) == pdTRUE)
8000284c:	4a 38       	lddpc	r8,800028d8 <send_message+0xf8>
8000284e:	70 0c       	ld.w	r12,r8[0x0]
80002850:	30 09       	mov	r9,0
80002852:	e0 6a 9c 40 	mov	r10,40000
80002856:	12 9b       	mov	r11,r9
80002858:	f0 1f 00 21 	mcall	800028dc <send_message+0xfc>
8000285c:	58 1c       	cp.w	r12,1
8000285e:	c0 91       	brne	80002870 <send_message+0x90>
				{
					log("xSemaphoreTake okay!\n");
80002860:	4a 9c       	lddpc	r12,80002904 <send_message+0x124>
80002862:	f0 1f 00 26 	mcall	800028f8 <send_message+0x118>
					vTaskDelay((2000*2) / portTICK_RATE_MS);
80002866:	e0 6c 0f a0 	mov	r12,4000
8000286a:	f0 1f 00 28 	mcall	80002908 <send_message+0x128>
8000286e:	c2 78       	rjmp	800028bc <send_message+0xdc>
				}
				else//短信丢失，手台未响应，超时后默认再次重发
				{
					log("xSemaphoreTake failure!\n");
80002870:	4a 7c       	lddpc	r12,8000290c <send_message+0x12c>
80002872:	f0 1f 00 22 	mcall	800028f8 <send_message+0x118>
					xcmp_IdleTestTone(Tone_Start, MANDOWN_DISABLE_TONE);//set tone to indicate send-failure!!!
80002876:	e0 6b 00 b7 	mov	r11,183
8000287a:	04 9c       	mov	r12,r2
8000287c:	f0 1f 00 25 	mcall	80002910 <send_message+0x130>
					status = xgflash_message_save(m_buff, sizeof(Message_Protocol_t), TRUE);
80002880:	04 9a       	mov	r10,r2
80002882:	32 0b       	mov	r11,32
80002884:	08 9c       	mov	r12,r4
80002886:	f0 1f 00 24 	mcall	80002914 <send_message+0x134>
8000288a:	83 0c       	st.w	r1[0x0],r12
					if(status == XG_OK)
8000288c:	c0 51       	brne	80002896 <send_message+0xb6>
					{
						log("save message-2 okay\n");
8000288e:	4a 3c       	lddpc	r12,80002918 <send_message+0x138>
80002890:	f0 1f 00 1a 	mcall	800028f8 <send_message+0x118>
80002894:	c1 48       	rjmp	800028bc <send_message+0xdc>
					}
					else
					{
						log("!!!save message err : %d\n", status);
80002896:	1a dc       	st.w	--sp,r12
80002898:	4a 1c       	lddpc	r12,8000291c <send_message+0x13c>
8000289a:	f0 1f 00 18 	mcall	800028f8 <send_message+0x118>
8000289e:	2f fd       	sub	sp,-4
800028a0:	c0 e8       	rjmp	800028bc <send_message+0xdc>
				
				}
			}
			else
			{
				log("get message err : %d\n", status);
800028a2:	1a dc       	st.w	--sp,r12
800028a4:	49 fc       	lddpc	r12,80002920 <send_message+0x140>
800028a6:	f0 1f 00 15 	mcall	800028f8 <send_message+0x118>
800028aa:	2f fd       	sub	sp,-4
800028ac:	c0 88       	rjmp	800028bc <send_message+0xdc>
			}
		
		}
		else if (Battery_Flag == Battery_Low)
800028ae:	0f 88       	ld.ub	r8,r7[0x0]
800028b0:	ec 08 18 00 	cp.b	r8,r6
800028b4:	c0 41       	brne	800028bc <send_message+0xdc>
		{
			log("The device battery level is low !\n");
800028b6:	49 cc       	lddpc	r12,80002924 <send_message+0x144>
800028b8:	f0 1f 00 10 	mcall	800028f8 <send_message+0x118>
		}
		
		//water_value = uxTaskGetStackHighWaterMark(NULL);
		//log("send-thread water_value: %d\n", water_value);
		vTaskDelayUntil(&xLastWakeTime, (5000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800028bc:	e0 6b 27 10 	mov	r11,10000
800028c0:	48 5c       	lddpc	r12,800028d4 <send_message+0xf4>
800028c2:	f0 1f 00 1a 	mcall	80002928 <send_message+0x148>
	
	}
800028c6:	ca 4b       	rjmp	8000280e <send_message+0x2e>
800028c8:	d8 32       	popm	r0-r7,pc
800028ca:	00 00       	add	r0,r0
800028cc:	80 00       	ld.sh	r0,r0[0x0]
800028ce:	70 38       	ld.w	r8,r8[0xc]
800028d0:	80 00       	ld.sh	r0,r0[0x0]
800028d2:	78 f0       	ld.w	r0,r12[0x3c]
800028d4:	00 00       	add	r0,r0
800028d6:	0a 70       	tst	r0,r5
800028d8:	00 00       	add	r0,r0
800028da:	0b a0       	ld.ub	r0,r5[0x2]
800028dc:	80 00       	ld.sh	r0,r0[0x0]
800028de:	71 80       	ld.w	r0,r8[0x60]
800028e0:	00 00       	add	r0,r0
800028e2:	0a 6c       	and	r12,r5
800028e4:	00 00       	add	r0,r0
800028e6:	0a 88       	andn	r8,r5
800028e8:	00 00       	add	r0,r0
800028ea:	0a 62       	and	r2,r5
800028ec:	80 00       	ld.sh	r0,r0[0x0]
800028ee:	e6 5c 00 00 	cp.w	r12,458752
800028f2:	00 04       	add	r4,r0
800028f4:	80 00       	ld.sh	r0,r0[0x0]
800028f6:	62 fc       	ld.w	r12,r1[0x3c]
800028f8:	80 00       	ld.sh	r0,r0[0x0]
800028fa:	7f c4       	ld.w	r4,pc[0x70]
800028fc:	80 00       	ld.sh	r0,r0[0x0]
800028fe:	60 1c       	ld.w	r12,r0[0x4]
80002900:	80 00       	ld.sh	r0,r0[0x0]
80002902:	48 c8       	lddpc	r8,80002930 <app_cfg+0x4>
80002904:	80 00       	ld.sh	r0,r0[0x0]
80002906:	e6 80 80 00 	breq	800d2906 <_data_lma+0xc32c6>
8000290a:	7a 58       	ld.w	r8,sp[0x14]
8000290c:	80 00       	ld.sh	r0,r0[0x0]
8000290e:	e6 98 80 00 	brls	800f290e <_data_lma+0xe32ce>
80002912:	4a 0c       	lddpc	r12,80002990 <app_cfg+0x64>
80002914:	80 00       	ld.sh	r0,r0[0x0]
80002916:	61 6c       	ld.w	r12,r0[0x58]
80002918:	80 00       	ld.sh	r0,r0[0x0]
8000291a:	e6 b4       	*unknown*
8000291c:	80 00       	ld.sh	r0,r0[0x0]
8000291e:	e6 cc 80 00 	sub	r12,r3,-32768
80002922:	e6 e8 80 00 	ld.d	r8,r3[-32768]
80002926:	e7 00 80 00 	ld.sh	r0,r3[-32768]
8000292a:	7a a0       	ld.w	r0,sp[0x28]

8000292c <app_cfg>:
}

static __app_Thread_(app_cfg)
{
8000292c:	d4 31       	pushm	r0-r7,lr
8000292e:	20 1d       	sub	sp,4
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	static xgflash_status_t status = XG_ERROR;
	xLastWakeTime = xTaskGetTickCount();
80002930:	f0 1f 00 54 	mcall	80002a80 <app_cfg+0x154>
80002934:	4d 48       	lddpc	r8,80002a84 <app_cfg+0x158>
80002936:	91 0c       	st.w	r8[0x0],r12
	static  portTickType water_value;
		
	for(;;)
	{
		switch(OB_State)
80002938:	4d 47       	lddpc	r7,80002a88 <app_cfg+0x15c>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
8000293a:	4d 53       	lddpc	r3,80002a8c <app_cfg+0x160>
							log("get time okay!\n");
							//vTaskResume(save_handle);
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
8000293c:	32 00       	mov	r0,32
8000293e:	30 06       	mov	r6,0
						}
			break;
			case OB_WAITINGAPPTASK:
			
					//if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, 0))
80002940:	4d 42       	lddpc	r2,80002a90 <app_cfg+0x164>
	xLastWakeTime = xTaskGetTickCount();
	static  portTickType water_value;
		
	for(;;)
	{
		switch(OB_State)
80002942:	6e 08       	ld.w	r8,r7[0x0]
80002944:	58 28       	cp.w	r8,2
80002946:	c4 60       	breq	800029d2 <app_cfg+0xa6>
80002948:	58 38       	cp.w	r8,3
8000294a:	c5 30       	breq	800029f0 <app_cfg+0xc4>
8000294c:	58 08       	cp.w	r8,0
8000294e:	e0 81 00 92 	brne	80002a72 <app_cfg+0x146>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002952:	4d 18       	lddpc	r8,80002a94 <app_cfg+0x168>
80002954:	70 08       	ld.w	r8,r8[0x0]
80002956:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000295a:	58 38       	cp.w	r8,3
8000295c:	c2 31       	brne	800029a2 <app_cfg+0x76>
8000295e:	4c f8       	lddpc	r8,80002a98 <app_cfg+0x16c>
80002960:	11 88       	ld.ub	r8,r8[0x0]
80002962:	58 08       	cp.w	r8,0
80002964:	c1 f1       	brne	800029a2 <app_cfg+0x76>
				{
					connect_flag=1;
80002966:	30 19       	mov	r9,1
80002968:	4c c8       	lddpc	r8,80002a98 <app_cfg+0x16c>
8000296a:	b0 89       	st.b	r8[0x0],r9
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
8000296c:	30 cb       	mov	r11,12
8000296e:	30 1c       	mov	r12,1
80002970:	f0 1f 00 4b 	mcall	80002a9c <app_cfg+0x170>
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002974:	30 cb       	mov	r11,12
80002976:	30 1c       	mov	r12,1
80002978:	f0 1f 00 49 	mcall	80002a9c <app_cfg+0x170>
					OB_State = OB_CONNECTEDWAITTINGSYNTIME;
8000297c:	30 28       	mov	r8,2
8000297e:	8f 08       	st.w	r7[0x0],r8
					log("connect OB okay!\n");
80002980:	4c 8c       	lddpc	r12,80002aa0 <app_cfg+0x174>
80002982:	f0 1f 00 49 	mcall	80002aa4 <app_cfg+0x178>
					log("XCMP_Version: %d.%d.%d.%d\n", XCMP_Version[0],  XCMP_Version[1],
					XCMP_Version[2],  XCMP_Version[3]);
80002986:	4c 98       	lddpc	r8,80002aa8 <app_cfg+0x17c>
80002988:	11 bb       	ld.ub	r11,r8[0x3]
8000298a:	11 aa       	ld.ub	r10,r8[0x2]
					connect_flag=1;
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
					OB_State = OB_CONNECTEDWAITTINGSYNTIME;
					log("connect OB okay!\n");
					log("XCMP_Version: %d.%d.%d.%d\n", XCMP_Version[0],  XCMP_Version[1],
8000298c:	11 99       	ld.ub	r9,r8[0x1]
8000298e:	11 88       	ld.ub	r8,r8[0x0]
80002990:	1a db       	st.w	--sp,r11
80002992:	1a da       	st.w	--sp,r10
80002994:	1a d9       	st.w	--sp,r9
80002996:	1a d8       	st.w	--sp,r8
80002998:	4c 5c       	lddpc	r12,80002aac <app_cfg+0x180>
8000299a:	f0 1f 00 43 	mcall	80002aa4 <app_cfg+0x178>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
8000299e:	2f cd       	sub	sp,-16
800029a0:	c6 98       	rjmp	80002a72 <app_cfg+0x146>
					XCMP_Version[2],  XCMP_Version[3]);
					
				}
				else
				{
					nop();
800029a2:	d7 03       	nop
					nop();
800029a4:	d7 03       	nop
					nop();
800029a6:	d7 03       	nop
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
800029a8:	4c 2c       	lddpc	r12,80002ab0 <app_cfg+0x184>
800029aa:	f0 1f 00 3f 	mcall	80002aa4 <app_cfg+0x178>
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
					Current_time.Hour, Current_time.Minute, Current_time.Second);
800029ae:	4c 28       	lddpc	r8,80002ab4 <app_cfg+0x188>
800029b0:	11 d5       	ld.ub	r5,r8[0x5]
800029b2:	11 cc       	ld.ub	r12,r8[0x4]
800029b4:	11 bb       	ld.ub	r11,r8[0x3]
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
800029b6:	11 aa       	ld.ub	r10,r8[0x2]
800029b8:	11 99       	ld.ub	r9,r8[0x1]
800029ba:	11 88       	ld.ub	r8,r8[0x0]
					nop();
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
800029bc:	1a d5       	st.w	--sp,r5
800029be:	1a dc       	st.w	--sp,r12
800029c0:	1a db       	st.w	--sp,r11
800029c2:	1a da       	st.w	--sp,r10
800029c4:	1a d9       	st.w	--sp,r9
800029c6:	1a d8       	st.w	--sp,r8
800029c8:	4b cc       	lddpc	r12,80002ab8 <app_cfg+0x18c>
800029ca:	f0 1f 00 37 	mcall	80002aa4 <app_cfg+0x178>
800029ce:	2f ad       	sub	sp,-24
800029d0:	c5 18       	rjmp	80002a72 <app_cfg+0x146>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
800029d2:	07 88       	ld.ub	r8,r3[0x0]
800029d4:	58 08       	cp.w	r8,0
800029d6:	c0 70       	breq	800029e4 <app_cfg+0xb8>
							
							OB_State = OB_WAITINGAPPTASK;
800029d8:	30 38       	mov	r8,3
800029da:	8f 08       	st.w	r7[0x0],r8
							log("get time okay!\n");
800029dc:	4b 8c       	lddpc	r12,80002abc <app_cfg+0x190>
800029de:	f0 1f 00 32 	mcall	80002aa4 <app_cfg+0x178>
800029e2:	c4 88       	rjmp	80002a72 <app_cfg+0x146>
							//vTaskResume(save_handle);
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
800029e4:	36 4a       	mov	r10,100
800029e6:	00 9b       	mov	r11,r0
800029e8:	0c 9c       	mov	r12,r6
800029ea:	f0 1f 00 36 	mcall	80002ac0 <app_cfg+0x194>
800029ee:	c4 28       	rjmp	80002a72 <app_cfg+0x146>
						}
			break;
			case OB_WAITINGAPPTASK:
			
					//if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, 0))
800029f0:	64 0c       	ld.w	r12,r2[0x0]
800029f2:	0c 99       	mov	r9,r6
800029f4:	0c 9a       	mov	r10,r6
800029f6:	1a 9b       	mov	r11,sp
800029f8:	f0 1f 00 33 	mcall	80002ac4 <app_cfg+0x198>
800029fc:	58 1c       	cp.w	r12,1
800029fe:	c3 61       	brne	80002a6a <app_cfg+0x13e>
					{
						if(data_ptr!=NULL){//save message
80002a00:	40 08       	lddsp	r8,sp[0x0]
80002a02:	58 08       	cp.w	r8,0
80002a04:	c3 70       	breq	80002a72 <app_cfg+0x146>
							
							log("receive okay!\n");
80002a06:	4b 1c       	lddpc	r12,80002ac8 <app_cfg+0x19c>
80002a08:	f0 1f 00 27 	mcall	80002aa4 <app_cfg+0x178>
							xSemaphoreTake(count_mutex, portMAX_DELAY);
80002a0c:	4b 04       	lddpc	r4,80002acc <app_cfg+0x1a0>
80002a0e:	68 0c       	ld.w	r12,r4[0x0]
80002a10:	0c 99       	mov	r9,r6
80002a12:	3f fa       	mov	r10,-1
80002a14:	0c 9b       	mov	r11,r6
80002a16:	f0 1f 00 2c 	mcall	80002ac4 <app_cfg+0x198>
							global_count--;
80002a1a:	4a e5       	lddpc	r5,80002ad0 <app_cfg+0x1a4>
80002a1c:	6a 08       	ld.w	r8,r5[0x0]
80002a1e:	20 18       	sub	r8,1
80002a20:	8b 08       	st.w	r5[0x0],r8
							xSemaphoreGive(count_mutex);
80002a22:	68 0c       	ld.w	r12,r4[0x0]
80002a24:	0c 99       	mov	r9,r6
80002a26:	0c 9a       	mov	r10,r6
80002a28:	0c 9b       	mov	r11,r6
80002a2a:	f0 1f 00 2b 	mcall	80002ad4 <app_cfg+0x1a8>
							log("global_count:%d\n", global_count);
80002a2e:	6a 08       	ld.w	r8,r5[0x0]
80002a30:	1a d8       	st.w	--sp,r8
80002a32:	4a ac       	lddpc	r12,80002ad8 <app_cfg+0x1ac>
80002a34:	f0 1f 00 1c 	mcall	80002aa4 <app_cfg+0x178>
							//Message_Protocol_t *ptr = (Message_Protocol_t* )data_ptr;
							status = xgflash_message_save(data_ptr, sizeof(Message_Protocol_t), TRUE);
80002a38:	30 1a       	mov	r10,1
80002a3a:	00 9b       	mov	r11,r0
80002a3c:	40 1c       	lddsp	r12,sp[0x4]
80002a3e:	f0 1f 00 28 	mcall	80002adc <app_cfg+0x1b0>
80002a42:	4a 88       	lddpc	r8,80002ae0 <app_cfg+0x1b4>
80002a44:	91 0c       	st.w	r8[0x0],r12
							//log("receive data : %d", ptr->data.XG_Time.Second);
							//xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);								
							if(status == XG_OK)
80002a46:	2f fd       	sub	sp,-4
80002a48:	58 0c       	cp.w	r12,0
80002a4a:	c0 51       	brne	80002a54 <app_cfg+0x128>
							{
								log("save message okay\n");
80002a4c:	4a 6c       	lddpc	r12,80002ae4 <app_cfg+0x1b8>
80002a4e:	f0 1f 00 16 	mcall	80002aa4 <app_cfg+0x178>
80002a52:	c0 68       	rjmp	80002a5e <app_cfg+0x132>
							}
							else
							{
								log("!!! save message err : %d\n", status);
80002a54:	1a dc       	st.w	--sp,r12
80002a56:	4a 5c       	lddpc	r12,80002ae8 <app_cfg+0x1bc>
80002a58:	f0 1f 00 13 	mcall	80002aa4 <app_cfg+0x178>
80002a5c:	2f fd       	sub	sp,-4
									
							}
							set_message_store(data_ptr);
80002a5e:	4a 48       	lddpc	r8,80002aec <app_cfg+0x1c0>
80002a60:	70 0c       	ld.w	r12,r8[0x0]
80002a62:	40 0b       	lddsp	r11,sp[0x0]
80002a64:	f0 1f 00 23 	mcall	80002af0 <app_cfg+0x1c4>
80002a68:	c0 58       	rjmp	80002a72 <app_cfg+0x146>
						
					}
					else
					{						
											
						nop();
80002a6a:	d7 03       	nop
						//water_value = uxTaskGetStackHighWaterMark(NULL);
						//log("app-thread water_value: %d\n", water_value);
						log("app task run!\n");
80002a6c:	4a 2c       	lddpc	r12,80002af4 <app_cfg+0x1c8>
80002a6e:	f0 1f 00 0e 	mcall	80002aa4 <app_cfg+0x178>
			break;
				
		} //End of switch on OB_State.
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		vTaskDelayUntil( &xLastWakeTime, (1200*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002a72:	e0 6b 09 60 	mov	r11,2400
80002a76:	48 4c       	lddpc	r12,80002a84 <app_cfg+0x158>
80002a78:	f0 1f 00 20 	mcall	80002af8 <app_cfg+0x1cc>
	}
80002a7c:	c6 3b       	rjmp	80002942 <app_cfg+0x16>
80002a7e:	00 00       	add	r0,r0
80002a80:	80 00       	ld.sh	r0,r0[0x0]
80002a82:	78 f0       	ld.w	r0,r12[0x3c]
80002a84:	00 00       	add	r0,r0
80002a86:	0a 58       	eor	r8,r5
80002a88:	00 00       	add	r0,r0
80002a8a:	0a 5c       	eor	r12,r5
80002a8c:	00 00       	add	r0,r0
80002a8e:	00 08       	add	r8,r0
80002a90:	00 00       	add	r0,r0
80002a92:	0b 8c       	ld.ub	r12,r5[0x0]
80002a94:	00 00       	add	r0,r0
80002a96:	0e 1c       	sub	r12,r7
80002a98:	00 00       	add	r0,r0
80002a9a:	0a 62       	and	r2,r5
80002a9c:	80 00       	ld.sh	r0,r0[0x0]
80002a9e:	4a 0c       	lddpc	r12,80002b1c <Phyuserinput_brdcst_func+0x20>
80002aa0:	80 00       	ld.sh	r0,r0[0x0]
80002aa2:	e7 24 80 00 	ld.sb	r4,r3[-32768]
80002aa6:	7f c4       	ld.w	r4,pc[0x70]
80002aa8:	00 00       	add	r0,r0
80002aaa:	0e 18       	sub	r8,r7
80002aac:	80 00       	ld.sh	r0,r0[0x0]
80002aae:	e7 38 80 00 	ld.ub	r8,r3[-32768]
80002ab2:	e7 54 00 00 	st.h	r3[0],r4
80002ab6:	0e 20       	rsub	r0,r7
80002ab8:	80 00       	ld.sh	r0,r0[0x0]
80002aba:	e7 64 80 00 	st.b	r3[-32768],r4
80002abe:	e7 90       	*unknown*
80002ac0:	80 00       	ld.sh	r0,r0[0x0]
80002ac2:	48 c8       	lddpc	r8,80002af0 <app_cfg+0x1c4>
80002ac4:	80 00       	ld.sh	r0,r0[0x0]
80002ac6:	71 80       	ld.w	r0,r8[0x60]
80002ac8:	80 00       	ld.sh	r0,r0[0x0]
80002aca:	e7 a0 00 00 	cop	cp0,cr0,cr0,cr0,0x60
80002ace:	0a 7c       	tst	r12,r5
80002ad0:	00 00       	add	r0,r0
80002ad2:	0a 84       	andn	r4,r5
80002ad4:	80 00       	ld.sh	r0,r0[0x0]
80002ad6:	73 8c       	ld.w	r12,r9[0x60]
80002ad8:	80 00       	ld.sh	r0,r0[0x0]
80002ada:	e7 b0       	*unknown*
80002adc:	80 00       	ld.sh	r0,r0[0x0]
80002ade:	61 6c       	ld.w	r12,r0[0x58]
80002ae0:	00 00       	add	r0,r0
80002ae2:	00 0c       	add	r12,r0
80002ae4:	80 00       	ld.sh	r0,r0[0x0]
80002ae6:	e7 c4 80 00 	ldmts	r4++,pc
80002aea:	e7 d8 00 00 	ldins.h	r8:b,r3[0]
80002aee:	0b 9c       	ld.ub	r12,r5[0x1]
80002af0:	80 00       	ld.sh	r0,r0[0x0]
80002af2:	35 9c       	mov	r12,89
80002af4:	80 00       	ld.sh	r0,r0[0x0]
80002af6:	e7 f4 80 00 	ld.wls	r4,r3[0x0]
80002afa:	7a a0       	ld.w	r0,sp[0x28]

80002afc <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002afc:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002b00:	19 c7       	ld.ub	r7,r12[0x4]
80002b02:	19 d8       	ld.ub	r8,r12[0x5]
80002b04:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002b08:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
80002b0a:	48 dc       	lddpc	r12,80002b3c <Phyuserinput_brdcst_func+0x40>
80002b0c:	f0 1f 00 0d 	mcall	80002b40 <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
80002b10:	36 08       	mov	r8,96
80002b12:	f0 07 19 00 	cp.h	r7,r8
80002b16:	c1 11       	brne	80002b38 <Phyuserinput_brdcst_func+0x3c>
80002b18:	48 b8       	lddpc	r8,80002b44 <Phyuserinput_brdcst_func+0x48>
80002b1a:	11 89       	ld.ub	r9,r8[0x0]
80002b1c:	30 18       	mov	r8,1
80002b1e:	f0 09 18 00 	cp.b	r9,r8
80002b22:	c0 b1       	brne	80002b38 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_9);//set tone to indicate the scan!!!
80002b24:	34 5b       	mov	r11,69
80002b26:	30 1c       	mov	r12,1
80002b28:	f0 1f 00 08 	mcall	80002b48 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(1000*2 / portTICK_RATE_MS);//延迟1000ms
80002b2c:	e0 6c 07 d0 	mov	r12,2000
80002b30:	f0 1f 00 07 	mcall	80002b4c <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		//rfid_sendID_message();//send message		
		scan_rfid_save_message();
80002b34:	f0 1f 00 07 	mcall	80002b50 <Phyuserinput_brdcst_func+0x54>
80002b38:	e3 cd 80 80 	ldm	sp++,r7,pc
80002b3c:	80 00       	ld.sh	r0,r0[0x0]
80002b3e:	e8 04       	*unknown*
80002b40:	80 00       	ld.sh	r0,r0[0x0]
80002b42:	7f c4       	ld.w	r4,pc[0x70]
80002b44:	00 00       	add	r0,r0
80002b46:	0a 62       	and	r2,r5
80002b48:	80 00       	ld.sh	r0,r0[0x0]
80002b4a:	4a 0c       	lddpc	r12,80002bc8 <DataSession_brdcst_func+0x74>
80002b4c:	80 00       	ld.sh	r0,r0[0x0]
80002b4e:	7a 58       	ld.w	r8,sp[0x14]
80002b50:	80 00       	ld.sh	r0,r0[0x0]
80002b52:	5a 4c       	cp.w	r12,-28

80002b54 <DataSession_brdcst_func>:
	Battery_Flag = ptr->State;

}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002b54:	d4 21       	pushm	r4-r7,lr
80002b56:	20 9d       	sub	sp,36
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002b58:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
80002b5c:	0d 88       	ld.ub	r8,r6[0x0]
80002b5e:	32 49       	mov	r9,36
80002b60:	f2 08 18 00 	cp.b	r8,r9
80002b64:	c2 a1       	brne	80002bb8 <DataSession_brdcst_func+0x64>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002b66:	4c fc       	lddpc	r12,80002ca0 <DataSession_brdcst_func+0x14c>
80002b68:	f0 1f 00 4f 	mcall	80002ca4 <DataSession_brdcst_func+0x150>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002b6c:	0d a5       	ld.ub	r5,r6[0x2]
80002b6e:	0d b8       	ld.ub	r8,r6[0x3]
80002b70:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002b74:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002b76:	0d 98       	ld.ub	r8,r6[0x1]
80002b78:	1a d8       	st.w	--sp,r8
80002b7a:	4c cc       	lddpc	r12,80002ca8 <DataSession_brdcst_func+0x154>
80002b7c:	f0 1f 00 4a 	mcall	80002ca4 <DataSession_brdcst_func+0x150>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002b80:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002b84:	1a d8       	st.w	--sp,r8
80002b86:	4c ac       	lddpc	r12,80002cac <DataSession_brdcst_func+0x158>
80002b88:	f0 1f 00 47 	mcall	80002ca4 <DataSession_brdcst_func+0x150>
		for(i=0; i<data_length; i++)
80002b8c:	2f ed       	sub	sp,-8
80002b8e:	58 05       	cp.w	r5,0
80002b90:	e0 80 00 85 	breq	80002c9a <DataSession_brdcst_func+0x146>
80002b94:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002b96:	4c 74       	lddpc	r4,80002cb0 <DataSession_brdcst_func+0x15c>
80002b98:	ec 07 00 08 	add	r8,r6,r7
80002b9c:	11 c8       	ld.ub	r8,r8[0x4]
80002b9e:	1a d8       	st.w	--sp,r8
80002ba0:	1a d7       	st.w	--sp,r7
80002ba2:	08 9c       	mov	r12,r4
80002ba4:	f0 1f 00 40 	mcall	80002ca4 <DataSession_brdcst_func+0x150>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002ba8:	2f f7       	sub	r7,-1
80002baa:	5c 57       	castu.b	r7
80002bac:	2f ed       	sub	sp,-8
80002bae:	ee 05 19 00 	cp.h	r5,r7
80002bb2:	fe 9b ff f3 	brhi	80002b98 <DataSession_brdcst_func+0x44>
80002bb6:	c7 28       	rjmp	80002c9a <DataSession_brdcst_func+0x146>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
80002bb8:	1a d8       	st.w	--sp,r8
80002bba:	4b fc       	lddpc	r12,80002cb4 <DataSession_brdcst_func+0x160>
80002bbc:	f0 1f 00 3a 	mcall	80002ca4 <DataSession_brdcst_func+0x150>
		if (ptr->State == DATA_SESSION_TX_Suc)
80002bc0:	0d 88       	ld.ub	r8,r6[0x0]
80002bc2:	2f fd       	sub	sp,-4
80002bc4:	30 39       	mov	r9,3
80002bc6:	f2 08 18 00 	cp.b	r8,r9
80002bca:	c0 d1       	brne	80002be4 <DataSession_brdcst_func+0x90>
		{
			log("data transmit success\n");
80002bcc:	4b bc       	lddpc	r12,80002cb8 <DataSession_brdcst_func+0x164>
80002bce:	f0 1f 00 36 	mcall	80002ca4 <DataSession_brdcst_func+0x150>
			vTaskDelay(1000*2 / portTICK_RATE_MS);//延迟1000ms
80002bd2:	e0 6c 07 d0 	mov	r12,2000
80002bd6:	f0 1f 00 3a 	mcall	80002cbc <DataSession_brdcst_func+0x168>
			xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate connection success!!!
80002bda:	37 7b       	mov	r11,119
80002bdc:	30 1c       	mov	r12,1
80002bde:	f0 1f 00 39 	mcall	80002cc0 <DataSession_brdcst_func+0x16c>
80002be2:	c4 98       	rjmp	80002c74 <DataSession_brdcst_func+0x120>

		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
80002be4:	30 49       	mov	r9,4
80002be6:	f2 08 18 00 	cp.b	r8,r9
80002bea:	c4 51       	brne	80002c74 <DataSession_brdcst_func+0x120>
		{
			//Message_Protocol_t  *xgmessage = (Message_Protocol_t  *)ptr->DataPayload.DataPayload;
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
80002bec:	32 0a       	mov	r10,32
80002bee:	ec cb ff fc 	sub	r11,r6,-4
80002bf2:	1a 9c       	mov	r12,sp
80002bf4:	f0 1f 00 34 	mcall	80002cc4 <DataSession_brdcst_func+0x170>
			//log("data transmit failure\n");
			//log("xgmessage.XG_Time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
			//xgmessage.data.XG_Time.Year, xgmessage.data.XG_Time.Month, xgmessage.data.XG_Time.Day,
			//xgmessage.data.XG_Time.Hour, xgmessage.data.XG_Time.Minute, xgmessage.data.XG_Time.Second);

			Message_Protocol_t * myptr = get_message_store();	
80002bf8:	4b 48       	lddpc	r8,80002cc8 <DataSession_brdcst_func+0x174>
80002bfa:	70 0c       	ld.w	r12,r8[0x0]
80002bfc:	f0 1f 00 34 	mcall	80002ccc <DataSession_brdcst_func+0x178>
80002c00:	50 8c       	stdsp	sp[0x20],r12
			if(NULL != myptr)
80002c02:	c3 10       	breq	80002c64 <DataSession_brdcst_func+0x110>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
80002c04:	32 0a       	mov	r10,32
80002c06:	1a 9b       	mov	r11,sp
80002c08:	f0 1f 00 2f 	mcall	80002cc4 <DataSession_brdcst_func+0x170>
				//xQueueSend(xg_resend_queue, &myptr, 0);
				if (xQueueSend(xg_resend_queue, &myptr, 0) != pdPASS)
80002c0c:	4b 18       	lddpc	r8,80002cd0 <DataSession_brdcst_func+0x17c>
80002c0e:	70 0c       	ld.w	r12,r8[0x0]
80002c10:	30 09       	mov	r9,0
80002c12:	12 9a       	mov	r10,r9
80002c14:	fa cb ff e0 	sub	r11,sp,-32
80002c18:	f0 1f 00 2f 	mcall	80002cd4 <DataSession_brdcst_func+0x180>
80002c1c:	58 1c       	cp.w	r12,1
80002c1e:	c1 10       	breq	80002c40 <DataSession_brdcst_func+0xec>
				{
					log("xg_resend_queue: full\n" );
80002c20:	4a ec       	lddpc	r12,80002cd8 <DataSession_brdcst_func+0x184>
80002c22:	f0 1f 00 21 	mcall	80002ca4 <DataSession_brdcst_func+0x150>
					xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
80002c26:	32 3b       	mov	r11,35
80002c28:	30 1c       	mov	r12,1
80002c2a:	f0 1f 00 26 	mcall	80002cc0 <DataSession_brdcst_func+0x16c>
					vTaskDelay(3000*2 / portTICK_RATE_MS);//延迟3000ms
80002c2e:	e0 6c 17 70 	mov	r12,6000
80002c32:	f0 1f 00 23 	mcall	80002cbc <DataSession_brdcst_func+0x168>
					xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
80002c36:	32 3b       	mov	r11,35
80002c38:	30 0c       	mov	r12,0
80002c3a:	f0 1f 00 22 	mcall	80002cc0 <DataSession_brdcst_func+0x16c>
80002c3e:	c1 68       	rjmp	80002c6a <DataSession_brdcst_func+0x116>
				}
				else
				{
					xSemaphoreTake(count_mutex, portMAX_DELAY);
80002c40:	4a 77       	lddpc	r7,80002cdc <DataSession_brdcst_func+0x188>
80002c42:	6e 0c       	ld.w	r12,r7[0x0]
80002c44:	30 09       	mov	r9,0
80002c46:	3f fa       	mov	r10,-1
80002c48:	12 9b       	mov	r11,r9
80002c4a:	f0 1f 00 26 	mcall	80002ce0 <DataSession_brdcst_func+0x18c>
					global_count++;
80002c4e:	4a 68       	lddpc	r8,80002ce4 <DataSession_brdcst_func+0x190>
80002c50:	70 09       	ld.w	r9,r8[0x0]
80002c52:	2f f9       	sub	r9,-1
80002c54:	91 09       	st.w	r8[0x0],r9
					xSemaphoreGive(count_mutex);
80002c56:	6e 0c       	ld.w	r12,r7[0x0]
80002c58:	30 09       	mov	r9,0
80002c5a:	12 9a       	mov	r10,r9
80002c5c:	12 9b       	mov	r11,r9
80002c5e:	f0 1f 00 1e 	mcall	80002cd4 <DataSession_brdcst_func+0x180>
80002c62:	c0 48       	rjmp	80002c6a <DataSession_brdcst_func+0x116>
				}
			}
			else
			{
				log("myptr: err\n\r" );
80002c64:	4a 1c       	lddpc	r12,80002ce8 <DataSession_brdcst_func+0x194>
80002c66:	f0 1f 00 10 	mcall	80002ca4 <DataSession_brdcst_func+0x150>
			}
			xcmp_IdleTestTone(Tone_Start, MANDOWN_DISABLE_TONE);//set tone to indicate send-failure!!!
80002c6a:	e0 6b 00 b7 	mov	r11,183
80002c6e:	30 1c       	mov	r12,1
80002c70:	f0 1f 00 14 	mcall	80002cc0 <DataSession_brdcst_func+0x16c>
			
		}
		
		if((ptr->State == DATA_SESSION_TX_Fail) || (ptr->State == DATA_SESSION_TX_Suc))
80002c74:	0d 89       	ld.ub	r9,r6[0x0]
80002c76:	20 39       	sub	r9,3
80002c78:	30 18       	mov	r8,1
80002c7a:	f0 09 18 00 	cp.b	r9,r8
80002c7e:	e0 8b 00 0e 	brhi	80002c9a <DataSession_brdcst_func+0x146>
		{		
			//if( xSemaphoreGive( SendM_CountingSemaphore ) != pdTRUE )
			if( xSemaphoreGive( xBinarySemaphore ) != pdTRUE )
80002c82:	49 b8       	lddpc	r8,80002cec <DataSession_brdcst_func+0x198>
80002c84:	70 0c       	ld.w	r12,r8[0x0]
80002c86:	30 09       	mov	r9,0
80002c88:	12 9a       	mov	r10,r9
80002c8a:	12 9b       	mov	r11,r9
80002c8c:	f0 1f 00 12 	mcall	80002cd4 <DataSession_brdcst_func+0x180>
80002c90:	58 1c       	cp.w	r12,1
80002c92:	c0 40       	breq	80002c9a <DataSession_brdcst_func+0x146>
			{
				log("xSemaphoreGive: err\n\r" );
80002c94:	49 7c       	lddpc	r12,80002cf0 <DataSession_brdcst_func+0x19c>
80002c96:	f0 1f 00 04 	mcall	80002ca4 <DataSession_brdcst_func+0x150>
				//
		//}
		
	}
	
}
80002c9a:	2f 7d       	sub	sp,-36
80002c9c:	d8 22       	popm	r4-r7,pc
80002c9e:	00 00       	add	r0,r0
80002ca0:	80 00       	ld.sh	r0,r0[0x0]
80002ca2:	e8 24 80 00 	sub	r4,557056
80002ca6:	7f c4       	ld.w	r4,pc[0x70]
80002ca8:	80 00       	ld.sh	r0,r0[0x0]
80002caa:	e8 38 80 00 	sub	r8,622592
80002cae:	e8 50 80 00 	cp.w	r0,622592
80002cb2:	e8 6c 80 00 	mov	r12,557056
80002cb6:	e8 84 80 00 	brge	80112cb6 <_data_lma+0x103676>
80002cba:	e8 90 80 00 	breq	80132cba <_data_lma+0x12367a>
80002cbe:	7a 58       	ld.w	r8,sp[0x14]
80002cc0:	80 00       	ld.sh	r0,r0[0x0]
80002cc2:	4a 0c       	lddpc	r12,80002d40 <DeviceInitializationStatus_brdcst_func+0x4c>
80002cc4:	80 00       	ld.sh	r0,r0[0x0]
80002cc6:	88 6e       	ld.sh	lr,r4[0xc]
80002cc8:	00 00       	add	r0,r0
80002cca:	0b 9c       	ld.ub	r12,r5[0x1]
80002ccc:	80 00       	ld.sh	r0,r0[0x0]
80002cce:	37 48       	mov	r8,116
80002cd0:	00 00       	add	r0,r0
80002cd2:	0b 8c       	ld.ub	r12,r5[0x0]
80002cd4:	80 00       	ld.sh	r0,r0[0x0]
80002cd6:	73 8c       	ld.w	r12,r9[0x60]
80002cd8:	80 00       	ld.sh	r0,r0[0x0]
80002cda:	e8 a8       	*unknown*
80002cdc:	00 00       	add	r0,r0
80002cde:	0a 7c       	tst	r12,r5
80002ce0:	80 00       	ld.sh	r0,r0[0x0]
80002ce2:	71 80       	ld.w	r0,r8[0x60]
80002ce4:	00 00       	add	r0,r0
80002ce6:	0a 84       	andn	r4,r5
80002ce8:	80 00       	ld.sh	r0,r0[0x0]
80002cea:	e8 c0 00 00 	sub	r0,r4,0
80002cee:	0b a0       	ld.ub	r0,r5[0x2]
80002cf0:	80 00       	ld.sh	r0,r0[0x0]
80002cf2:	e8 d0 eb cd 	satsub.w	r0,r4,-5171

80002cf4 <DeviceInitializationStatus_brdcst_func>:


//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002cf4:	eb cd 40 80 	pushm	r7,lr
		/*point to xcmp payload*/
		DeviceInitializationStatus_brdcst_t *ptr = (DeviceInitializationStatus_brdcst_t* )xcmp->u8;
80002cf8:	f8 c7 ff fe 	sub	r7,r12,-2
		
		//log("DeviceInitializationStatus_brdcst...\n");
		
		memcpy(XCMP_Version, &(ptr->XCMPVersion[0]), sizeof(XCMP_Version));
80002cfc:	30 4a       	mov	r10,4
80002cfe:	0e 9b       	mov	r11,r7
80002d00:	48 dc       	lddpc	r12,80002d34 <DeviceInitializationStatus_brdcst_func+0x40>
80002d02:	f0 1f 00 0e 	mcall	80002d38 <DeviceInitializationStatus_brdcst_func+0x44>
		
		if (ptr->DeviceInitType == Device_Init_Complete)
80002d06:	0f c8       	ld.ub	r8,r7[0x4]
80002d08:	30 19       	mov	r9,1
80002d0a:	f2 08 18 00 	cp.b	r8,r9
80002d0e:	c0 71       	brne	80002d1c <DeviceInitializationStatus_brdcst_func+0x28>
		{
			bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002d10:	48 b8       	lddpc	r8,80002d3c <DeviceInitializationStatus_brdcst_func+0x48>
80002d12:	70 09       	ld.w	r9,r8[0x0]
80002d14:	a1 a9       	sbr	r9,0x0
80002d16:	91 09       	st.w	r8[0x0],r9
80002d18:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else if(ptr->DeviceInitType  == Device_Init_Status)
80002d1c:	58 08       	cp.w	r8,0
80002d1e:	c0 81       	brne	80002d2e <DeviceInitializationStatus_brdcst_func+0x3a>
		{
			bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002d20:	48 78       	lddpc	r8,80002d3c <DeviceInitializationStatus_brdcst_func+0x48>
80002d22:	70 09       	ld.w	r9,r8[0x0]
80002d24:	e0 19 ff fc 	andl	r9,0xfffc
80002d28:	91 09       	st.w	r8[0x0],r9
			xcmp_DeviceInitializationStatus_request();
80002d2a:	f0 1f 00 06 	mcall	80002d40 <DeviceInitializationStatus_brdcst_func+0x4c>
80002d2e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002d32:	00 00       	add	r0,r0
80002d34:	00 00       	add	r0,r0
80002d36:	0e 18       	sub	r8,r7
80002d38:	80 00       	ld.sh	r0,r0[0x0]
80002d3a:	88 6e       	ld.sh	lr,r4[0xc]
80002d3c:	00 00       	add	r0,r0
80002d3e:	0e 1c       	sub	r12,r7
80002d40:	80 00       	ld.sh	r0,r0[0x0]
80002d42:	49 58       	lddpc	r8,80002d94 <send_flash_command+0x50>

80002d44 <send_flash_command>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
U16 send_flash_command(U16 command, U32 address, U8 *data_ptr, U16 length)
{
80002d44:	eb cd 40 fc 	pushm	r2-r7,lr
80002d48:	20 1d       	sub	sp,4
80002d4a:	18 97       	mov	r7,r12
80002d4c:	14 95       	mov	r5,r10
80002d4e:	12 96       	mov	r6,r9
	U16 status = 1;
80002d50:	30 18       	mov	r8,1
80002d52:	ba 18       	st.h	sp[0x2],r8
	U16 i = 0;

    /* in order to call spi_write(U16* data), change 3-bytes address to 3-U16 address */
	U16 addr[3];
	addr[2] = (address & 0x00ff0000) >> 16;
80002d54:	e9 db c2 08 	bfextu	r4,r11,0x10,0x8
	addr[1] = (address & 0x0000ff00) >> 8;
80002d58:	e7 db c1 08 	bfextu	r3,r11,0x8,0x8
	addr[0] = (address & 0x000000ff);
80002d5c:	e5 db c0 08 	bfextu	r2,r11,0x0,0x8

	U16 data_u16;

	spi_selectChip(spi, DF_SPI_PCS_1);
80002d60:	30 1b       	mov	r11,1
80002d62:	4e 58       	lddpc	r8,80002ef4 <send_flash_command+0x1b0>
80002d64:	70 0c       	ld.w	r12,r8[0x0]
80002d66:	f0 1f 00 65 	mcall	80002ef8 <send_flash_command+0x1b4>

    switch (command)
80002d6a:	30 58       	mov	r8,5
80002d6c:	f0 07 19 00 	cp.h	r7,r8
80002d70:	c3 40       	breq	80002dd8 <send_flash_command+0x94>
80002d72:	e0 8b 00 18 	brhi	80002da2 <send_flash_command+0x5e>
80002d76:	30 28       	mov	r8,2
80002d78:	f0 07 19 00 	cp.h	r7,r8
80002d7c:	c5 e0       	breq	80002e38 <send_flash_command+0xf4>
80002d7e:	e0 8b 00 08 	brhi	80002d8e <send_flash_command+0x4a>
80002d82:	30 18       	mov	r8,1
80002d84:	f0 07 19 00 	cp.h	r7,r8
80002d88:	e0 81 00 ad 	brne	80002ee2 <send_flash_command+0x19e>
80002d8c:	c9 e8       	rjmp	80002ec8 <send_flash_command+0x184>
80002d8e:	30 38       	mov	r8,3
80002d90:	f0 07 19 00 	cp.h	r7,r8
80002d94:	c7 20       	breq	80002e78 <send_flash_command+0x134>
80002d96:	30 48       	mov	r8,4
80002d98:	f0 07 19 00 	cp.h	r7,r8
80002d9c:	e0 81 00 a3 	brne	80002ee2 <send_flash_command+0x19e>
80002da0:	c2 c8       	rjmp	80002df8 <send_flash_command+0xb4>
80002da2:	35 28       	mov	r8,82
80002da4:	f0 07 19 00 	cp.h	r7,r8
80002da8:	c2 f0       	breq	80002e06 <send_flash_command+0xc2>
80002daa:	e0 8b 00 0c 	brhi	80002dc2 <send_flash_command+0x7e>
80002dae:	30 68       	mov	r8,6
80002db0:	f0 07 19 00 	cp.h	r7,r8
80002db4:	c2 20       	breq	80002df8 <send_flash_command+0xb4>
80002db6:	32 08       	mov	r8,32
80002db8:	f0 07 19 00 	cp.h	r7,r8
80002dbc:	e0 81 00 93 	brne	80002ee2 <send_flash_command+0x19e>
80002dc0:	c2 38       	rjmp	80002e06 <send_flash_command+0xc2>
80002dc2:	36 08       	mov	r8,96
80002dc4:	f0 07 19 00 	cp.h	r7,r8
80002dc8:	c3 20       	breq	80002e2c <send_flash_command+0xe8>
80002dca:	e0 68 00 d8 	mov	r8,216
80002dce:	f0 07 19 00 	cp.h	r7,r8
80002dd2:	e0 81 00 88 	brne	80002ee2 <send_flash_command+0x19e>
80002dd6:	c1 88       	rjmp	80002e06 <send_flash_command+0xc2>
	{
		case READ_STATUS_REG:
			spi_write_byte(command);
80002dd8:	4c 77       	lddpc	r7,80002ef4 <send_flash_command+0x1b0>
80002dda:	30 5b       	mov	r11,5
80002ddc:	6e 0c       	ld.w	r12,r7[0x0]
80002dde:	f0 1f 00 48 	mcall	80002efc <send_flash_command+0x1b8>
			spi_write_dummy();
80002de2:	e0 6b 00 ff 	mov	r11,255
80002de6:	6e 0c       	ld.w	r12,r7[0x0]
80002de8:	f0 1f 00 45 	mcall	80002efc <send_flash_command+0x1b8>
			spi_read_byte(&status);
80002dec:	fa cb ff fe 	sub	r11,sp,-2
80002df0:	6e 0c       	ld.w	r12,r7[0x0]
80002df2:	f0 1f 00 44 	mcall	80002f00 <send_flash_command+0x1bc>
			break;
80002df6:	c7 68       	rjmp	80002ee2 <send_flash_command+0x19e>
		case WRITE_ENABLE:
		case WRITE_DISABLE:
			spi_write_byte(command);
80002df8:	0e 9b       	mov	r11,r7
80002dfa:	5c 7b       	castu.h	r11
80002dfc:	4b e8       	lddpc	r8,80002ef4 <send_flash_command+0x1b0>
80002dfe:	70 0c       	ld.w	r12,r8[0x0]
80002e00:	f0 1f 00 3f 	mcall	80002efc <send_flash_command+0x1b8>
			break;
80002e04:	c6 f8       	rjmp	80002ee2 <send_flash_command+0x19e>
		case BLOCK_ERASE_4KB:
		case BLOCK_ERASE_32KB:
		case BLOCK_ERASE_64KB:
			spi_write_byte(command);
80002e06:	4b c6       	lddpc	r6,80002ef4 <send_flash_command+0x1b0>
80002e08:	0e 9b       	mov	r11,r7
80002e0a:	5c 7b       	castu.h	r11
80002e0c:	6c 0c       	ld.w	r12,r6[0x0]
80002e0e:	f0 1f 00 3c 	mcall	80002efc <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002e12:	08 9b       	mov	r11,r4
80002e14:	6c 0c       	ld.w	r12,r6[0x0]
80002e16:	f0 1f 00 3a 	mcall	80002efc <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002e1a:	06 9b       	mov	r11,r3
80002e1c:	6c 0c       	ld.w	r12,r6[0x0]
80002e1e:	f0 1f 00 38 	mcall	80002efc <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002e22:	04 9b       	mov	r11,r2
80002e24:	6c 0c       	ld.w	r12,r6[0x0]
80002e26:	f0 1f 00 36 	mcall	80002efc <send_flash_command+0x1b8>
			break;
80002e2a:	c5 c8       	rjmp	80002ee2 <send_flash_command+0x19e>
		case CHIP_ERASE:
			spi_write_byte(command);
80002e2c:	36 0b       	mov	r11,96
80002e2e:	4b 28       	lddpc	r8,80002ef4 <send_flash_command+0x1b0>
80002e30:	70 0c       	ld.w	r12,r8[0x0]
80002e32:	f0 1f 00 33 	mcall	80002efc <send_flash_command+0x1b8>
			break;
80002e36:	c5 68       	rjmp	80002ee2 <send_flash_command+0x19e>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
80002e38:	4a f7       	lddpc	r7,80002ef4 <send_flash_command+0x1b0>
80002e3a:	30 2b       	mov	r11,2
80002e3c:	6e 0c       	ld.w	r12,r7[0x0]
80002e3e:	f0 1f 00 30 	mcall	80002efc <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002e42:	08 9b       	mov	r11,r4
80002e44:	6e 0c       	ld.w	r12,r7[0x0]
80002e46:	f0 1f 00 2e 	mcall	80002efc <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002e4a:	06 9b       	mov	r11,r3
80002e4c:	6e 0c       	ld.w	r12,r7[0x0]
80002e4e:	f0 1f 00 2c 	mcall	80002efc <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002e52:	04 9b       	mov	r11,r2
80002e54:	6e 0c       	ld.w	r12,r7[0x0]
80002e56:	f0 1f 00 2a 	mcall	80002efc <send_flash_command+0x1b8>
			for (i = 0; i < length; i++)
80002e5a:	58 06       	cp.w	r6,0
80002e5c:	c4 30       	breq	80002ee2 <send_flash_command+0x19e>
80002e5e:	0a 97       	mov	r7,r5
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
				data_ptr++;
				spi_write_byte(data_u16);
80002e60:	4a 54       	lddpc	r4,80002ef4 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
80002e62:	0f 3b       	ld.ub	r11,r7++
80002e64:	ba 0b       	st.h	sp[0x0],r11
				data_ptr++;
				spi_write_byte(data_u16);
80002e66:	68 0c       	ld.w	r12,r4[0x0]
80002e68:	f0 1f 00 25 	mcall	80002efc <send_flash_command+0x1b8>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002e6c:	0e 98       	mov	r8,r7
80002e6e:	0a 18       	sub	r8,r5
80002e70:	ec 08 19 00 	cp.h	r8,r6
80002e74:	cf 73       	brcs	80002e62 <send_flash_command+0x11e>
80002e76:	c3 68       	rjmp	80002ee2 <send_flash_command+0x19e>
				data_ptr++;
				spi_write_byte(data_u16);
			}
			break;
		case READ_ARRAY:
			spi_write_byte(command);
80002e78:	49 f7       	lddpc	r7,80002ef4 <send_flash_command+0x1b0>
80002e7a:	30 3b       	mov	r11,3
80002e7c:	6e 0c       	ld.w	r12,r7[0x0]
80002e7e:	f0 1f 00 20 	mcall	80002efc <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002e82:	08 9b       	mov	r11,r4
80002e84:	6e 0c       	ld.w	r12,r7[0x0]
80002e86:	f0 1f 00 1e 	mcall	80002efc <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002e8a:	06 9b       	mov	r11,r3
80002e8c:	6e 0c       	ld.w	r12,r7[0x0]
80002e8e:	f0 1f 00 1c 	mcall	80002efc <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002e92:	04 9b       	mov	r11,r2
80002e94:	6e 0c       	ld.w	r12,r7[0x0]
80002e96:	f0 1f 00 1a 	mcall	80002efc <send_flash_command+0x1b8>
			for (i = 0; i < length; i++)
80002e9a:	58 06       	cp.w	r6,0
80002e9c:	c2 30       	breq	80002ee2 <send_flash_command+0x19e>
80002e9e:	0a 97       	mov	r7,r5
			{
				spi_write_dummy();
80002ea0:	49 54       	lddpc	r4,80002ef4 <send_flash_command+0x1b0>
80002ea2:	e0 63 00 ff 	mov	r3,255
				spi_read_byte(&data_u16);
80002ea6:	1a 92       	mov	r2,sp
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				spi_write_dummy();
80002ea8:	06 9b       	mov	r11,r3
80002eaa:	68 0c       	ld.w	r12,r4[0x0]
80002eac:	f0 1f 00 14 	mcall	80002efc <send_flash_command+0x1b8>
				spi_read_byte(&data_u16);
80002eb0:	1a 9b       	mov	r11,sp
80002eb2:	68 0c       	ld.w	r12,r4[0x0]
80002eb4:	f0 1f 00 13 	mcall	80002f00 <send_flash_command+0x1bc>
				*data_ptr = (U8)data_u16;
80002eb8:	9a 08       	ld.sh	r8,sp[0x0]
80002eba:	0e c8       	st.b	r7++,r8
		case READ_ARRAY:
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002ebc:	0e 98       	mov	r8,r7
80002ebe:	0a 18       	sub	r8,r5
80002ec0:	ec 08 19 00 	cp.h	r8,r6
80002ec4:	cf 23       	brcs	80002ea8 <send_flash_command+0x164>
80002ec6:	c0 e8       	rjmp	80002ee2 <send_flash_command+0x19e>
				*data_ptr = (U8)data_u16;
				data_ptr++;
			}
			break;
		case WRITE_STATUS_REG_BYTE_1:
			spi_write_byte(command);
80002ec8:	48 b7       	lddpc	r7,80002ef4 <send_flash_command+0x1b0>
80002eca:	30 1b       	mov	r11,1
80002ecc:	6e 0c       	ld.w	r12,r7[0x0]
80002ece:	f0 1f 00 0c 	mcall	80002efc <send_flash_command+0x1b8>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002ed2:	30 0b       	mov	r11,0
80002ed4:	6e 0c       	ld.w	r12,r7[0x0]
80002ed6:	f0 1f 00 0a 	mcall	80002efc <send_flash_command+0x1b8>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002eda:	30 0b       	mov	r11,0
80002edc:	6e 0c       	ld.w	r12,r7[0x0]
80002ede:	f0 1f 00 08 	mcall	80002efc <send_flash_command+0x1b8>
			break;
		default:
			break;
	}

	spi_unselectChip(spi, DF_SPI_PCS_1);
80002ee2:	30 1b       	mov	r11,1
80002ee4:	48 48       	lddpc	r8,80002ef4 <send_flash_command+0x1b0>
80002ee6:	70 0c       	ld.w	r12,r8[0x0]
80002ee8:	f0 1f 00 07 	mcall	80002f04 <send_flash_command+0x1c0>

	return status;
}
80002eec:	9a 1c       	ld.sh	r12,sp[0x2]
80002eee:	2f fd       	sub	sp,-4
80002ef0:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002ef4:	00 00       	add	r0,r0
80002ef6:	1e 30       	cp.w	r0,pc
80002ef8:	80 00       	ld.sh	r0,r0[0x0]
80002efa:	69 e8       	ld.w	r8,r4[0x78]
80002efc:	80 00       	ld.sh	r0,r0[0x0]
80002efe:	68 82       	ld.w	r2,r4[0x20]
80002f00:	80 00       	ld.sh	r0,r0[0x0]
80002f02:	68 9e       	ld.w	lr,r4[0x24]
80002f04:	80 00       	ld.sh	r0,r0[0x0]
80002f06:	69 a8       	ld.w	r8,r4[0x68]

80002f08 <data_flash_read_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_read_block(U32 address, U16 length, U8 *data_ptr)
{
80002f08:	d4 01       	pushm	lr
	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > 0x1000)
80002f0a:	58 0a       	cp.w	r10,0
80002f0c:	5f 09       	sreq	r9
80002f0e:	e0 68 ff fe 	mov	r8,65534
80002f12:	ea 18 00 7f 	orh	r8,0x7f
80002f16:	10 3c       	cp.w	r12,r8
80002f18:	5f b8       	srhi	r8
80002f1a:	f3 e8 10 08 	or	r8,r9,r8
80002f1e:	c0 e1       	brne	80002f3a <data_flash_read_block+0x32>
80002f20:	e0 68 10 00 	mov	r8,4096
80002f24:	f0 0b 19 00 	cp.h	r11,r8
80002f28:	e0 8b 00 09 	brhi	80002f3a <data_flash_read_block+0x32>
	{
		return DF_INVALID_PARAM;
	}

	send_flash_command(READ_ARRAY, address, data_ptr, length);
80002f2c:	f3 db c0 10 	bfextu	r9,r11,0x0,0x10
80002f30:	18 9b       	mov	r11,r12
80002f32:	30 3c       	mov	r12,3
80002f34:	f0 1f 00 02 	mcall	80002f3c <data_flash_read_block+0x34>
80002f38:	d8 0a       	popm	pc,r12=0

	return DF_OK;
80002f3a:	da 0a       	popm	pc,r12=1
80002f3c:	80 00       	ld.sh	r0,r0[0x0]
80002f3e:	2d 44       	sub	r4,-44

80002f40 <data_flash_write_page>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_page(U8 *data_ptr, U32 address, U16 length)
{
80002f40:	eb cd 40 fc 	pushm	r2-r7,lr
80002f44:	18 94       	mov	r4,r12
80002f46:	16 93       	mov	r3,r11
80002f48:	14 92       	mov	r2,r10
	U16 status = 1;
	df_status_t return_code = DF_WRITE_FAIL;
	U16 count = 0; /* to monitor write time consumption */

	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > DF_PAGE_SIZE)
80002f4a:	58 0c       	cp.w	r12,0
80002f4c:	5f 09       	sreq	r9
80002f4e:	e0 68 ff fe 	mov	r8,65534
80002f52:	ea 18 00 7f 	orh	r8,0x7f
80002f56:	10 3b       	cp.w	r11,r8
80002f58:	5f b8       	srhi	r8
80002f5a:	f3 e8 10 08 	or	r8,r9,r8
80002f5e:	c3 a1       	brne	80002fd2 <data_flash_write_page+0x92>
80002f60:	e0 68 01 00 	mov	r8,256
80002f64:	f0 0a 19 00 	cp.h	r10,r8
80002f68:	e0 8b 00 35 	brhi	80002fd2 <data_flash_write_page+0x92>
	{
		return DF_INVALID_PARAM;
	}

	while(status = send_flash_command(READ_STATUS_REG, 0, NULL, 0) == STATUS_BUSY);
80002f6c:	30 06       	mov	r6,0
80002f6e:	30 55       	mov	r5,5
80002f70:	30 17       	mov	r7,1
80002f72:	0c 99       	mov	r9,r6
80002f74:	0c 9a       	mov	r10,r6
80002f76:	0c 9b       	mov	r11,r6
80002f78:	0a 9c       	mov	r12,r5
80002f7a:	f0 1f 00 19 	mcall	80002fdc <data_flash_write_page+0x9c>
80002f7e:	ee 0c 19 00 	cp.h	r12,r7
80002f82:	cf 80       	breq	80002f72 <data_flash_write_page+0x32>
	//{
		//return DF_DEVICE_BUSY;
	//}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002f84:	30 09       	mov	r9,0
80002f86:	12 9a       	mov	r10,r9
80002f88:	12 9b       	mov	r11,r9
80002f8a:	30 6c       	mov	r12,6
80002f8c:	f0 1f 00 14 	mcall	80002fdc <data_flash_write_page+0x9c>

	/* send PAGE_PROGRAM command */
	send_flash_command(PAGE_PROGRAM, address, data_ptr, length);
80002f90:	f3 d2 c0 10 	bfextu	r9,r2,0x0,0x10
80002f94:	08 9a       	mov	r10,r4
80002f96:	06 9b       	mov	r11,r3
80002f98:	30 2c       	mov	r12,2
80002f9a:	f0 1f 00 11 	mcall	80002fdc <data_flash_write_page+0x9c>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002f9e:	30 06       	mov	r6,0
80002fa0:	30 57       	mov	r7,5
80002fa2:	0c 99       	mov	r9,r6
80002fa4:	0c 9a       	mov	r10,r6
80002fa6:	0c 9b       	mov	r11,r6
80002fa8:	0e 9c       	mov	r12,r7
80002faa:	f0 1f 00 0d 	mcall	80002fdc <data_flash_write_page+0x9c>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002fae:	5c 7c       	castu.h	r12
80002fb0:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002fb4:	cf 71       	brne	80002fa2 <data_flash_write_page+0x62>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002fb6:	18 97       	mov	r7,r12
80002fb8:	e2 17 00 20 	andl	r7,0x20,COH
80002fbc:	f9 b7 01 06 	movne	r7,6
80002fc0:	f9 b7 00 07 	moveq	r7,7
		/*  Erase Successful.  */
		return_code = DF_WRITE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002fc4:	30 09       	mov	r9,0
80002fc6:	12 9a       	mov	r10,r9
80002fc8:	12 9b       	mov	r11,r9
80002fca:	30 4c       	mov	r12,4
80002fcc:	f0 1f 00 04 	mcall	80002fdc <data_flash_write_page+0x9c>

	return return_code;
80002fd0:	c0 28       	rjmp	80002fd4 <data_flash_write_page+0x94>
80002fd2:	30 17       	mov	r7,1
}
80002fd4:	0e 9c       	mov	r12,r7
80002fd6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002fda:	00 00       	add	r0,r0
80002fdc:	80 00       	ld.sh	r0,r0[0x0]
80002fde:	2d 44       	sub	r4,-44

80002fe0 <data_flash_write_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_block(U8 *data_ptr, U32 address, U16 data_length)
{
80002fe0:	d4 31       	pushm	r0-r7,lr
80002fe2:	18 94       	mov	r4,r12
80002fe4:	ed da b0 10 	bfexts	r6,r10,0x0,0x10
80002fe8:	16 97       	mov	r7,r11
80002fea:	30 7c       	mov	r12,7
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002fec:	30 03       	mov	r3,0
80002fee:	06 92       	mov	r2,r3
	{
		if ((write_addr & 0xFF) == 0)
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002ff0:	e0 60 01 00 	mov	r0,256
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002ff4:	c4 98       	rjmp	80003086 <data_flash_write_block+0xa6>
	{
		if ((write_addr & 0xFF) == 0)
80002ff6:	eb d7 c0 08 	bfextu	r5,r7,0x0,0x8
80002ffa:	c1 b1       	brne	80003030 <data_flash_write_block+0x50>
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002ffc:	e0 06 19 00 	cp.h	r6,r0
80003000:	e0 8b 00 0a 	brhi	80003014 <data_flash_write_block+0x34>
			{
				/* bytes remained less than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80003004:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80003008:	0e 9b       	mov	r11,r7
8000300a:	08 9c       	mov	r12,r4
8000300c:	f0 1f 00 24 	mcall	8000309c <data_flash_write_block+0xbc>
80003010:	30 06       	mov	r6,0
80003012:	c3 a8       	rjmp	80003086 <data_flash_write_block+0xa6>
				bytes_remained = 0;	/* end while loop */
			}
			else /* (bytes_remained > DF_PAGE_SIZE) */
			{
				/* bytes remained more than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, DF_PAGE_SIZE);
80003014:	e0 6a 01 00 	mov	r10,256
80003018:	0e 9b       	mov	r11,r7
8000301a:	08 9c       	mov	r12,r4
8000301c:	f0 1f 00 20 	mcall	8000309c <data_flash_write_block+0xbc>
				bytes_remained -= DF_PAGE_SIZE;
80003020:	ec c6 01 00 	sub	r6,r6,256
80003024:	5c 86       	casts.h	r6
				data_ptr += DF_PAGE_SIZE;
80003026:	e8 c4 ff 00 	sub	r4,r4,-256
				write_addr += DF_PAGE_SIZE;
8000302a:	ee c7 ff 00 	sub	r7,r7,-256
8000302e:	c2 c8       	rjmp	80003086 <data_flash_write_block+0xa6>
		}
		else
		{
			/*(write_addr & 0xFF != 0), address not 256 bytes aligned */

			if (BEYOND_PAGE_BOUNDARY(write_addr, bytes_remained) == TRUE)
80003030:	f3 d6 c0 10 	bfextu	r9,r6,0x0,0x10
80003034:	0e 09       	add	r9,r7
80003036:	0e 98       	mov	r8,r7
80003038:	e4 18 00 7f 	andh	r8,0x7f
8000303c:	e0 18 ff 00 	andl	r8,0xff00
80003040:	f0 c8 ff 00 	sub	r8,r8,-256
80003044:	10 39       	cp.w	r9,r8
80003046:	e0 88 00 19 	brls	80003078 <data_flash_write_block+0x98>
			{
				/* bytes remained exceed current page, only write data within current page */
				return_code = data_flash_write_page(data_ptr, write_addr, BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr));
8000304a:	0e 91       	mov	r1,r7
8000304c:	5c 51       	castu.b	r1
8000304e:	e0 6a 01 00 	mov	r10,256
80003052:	02 1a       	sub	r10,r1
80003054:	5c 7a       	castu.h	r10
80003056:	0e 9b       	mov	r11,r7
80003058:	08 9c       	mov	r12,r4
8000305a:	f0 1f 00 11 	mcall	8000309c <data_flash_write_block+0xbc>
				bytes_remained -= BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
8000305e:	ec c6 01 00 	sub	r6,r6,256
80003062:	02 06       	add	r6,r1
80003064:	5c 86       	casts.h	r6
				data_ptr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80003066:	e0 68 01 00 	mov	r8,256
8000306a:	f0 05 01 05 	sub	r5,r8,r5
8000306e:	0a 04       	add	r4,r5
				write_addr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr); /* now became 256 bytes aligned */
80003070:	e0 17 ff 00 	andl	r7,0xff00
80003074:	10 07       	add	r7,r8
80003076:	c0 88       	rjmp	80003086 <data_flash_write_block+0xa6>
			}
			else
			{
				/* bytes remained not exceed current page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80003078:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
8000307c:	0e 9b       	mov	r11,r7
8000307e:	08 9c       	mov	r12,r4
80003080:	f0 1f 00 07 	mcall	8000309c <data_flash_write_block+0xbc>
80003084:	30 06       	mov	r6,0
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80003086:	e6 06 19 00 	cp.h	r6,r3
8000308a:	5f 19       	srne	r9
8000308c:	58 7c       	cp.w	r12,7
8000308e:	5f 08       	sreq	r8
80003090:	f3 e8 00 08 	and	r8,r9,r8
80003094:	e4 08 18 00 	cp.b	r8,r2
80003098:	ca f1       	brne	80002ff6 <data_flash_write_block+0x16>
			}
		}
	}	/* end of while */

	return return_code;
}
8000309a:	d8 32       	popm	r0-r7,pc
8000309c:	80 00       	ld.sh	r0,r0[0x0]
8000309e:	2f 40       	sub	r0,-12

800030a0 <data_flash_erase_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_erase_block(U32 address, df_block_size_t block_size)
{
800030a0:	eb cd 40 f8 	pushm	r3-r7,lr
800030a4:	18 94       	mov	r4,r12
	U16 erase_commond;
	df_status_t return_code = DF_ERASE_FAIL;
	U16 count = 0; /* to monitor erase time consumption */

	/* check input parameter */
	if (address >= DF_MAX_ADDR)
800030a6:	e0 68 ff fe 	mov	r8,65534
800030aa:	ea 18 00 7f 	orh	r8,0x7f
800030ae:	10 3c       	cp.w	r12,r8
800030b0:	e0 88 00 04 	brls	800030b8 <data_flash_erase_block+0x18>
800030b4:	30 17       	mov	r7,1
800030b6:	c3 f8       	rjmp	80003134 <data_flash_erase_block+0x94>
	{
		return DF_INVALID_PARAM;
	}

	/* determine erase command to be issued */
	if (block_size == DF_BLOCK_4KB)
800030b8:	58 1b       	cp.w	r11,1
800030ba:	c0 31       	brne	800030c0 <data_flash_erase_block+0x20>
800030bc:	32 03       	mov	r3,32
800030be:	c0 a8       	rjmp	800030d2 <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_4KB;
	else if (block_size == DF_BLOCK_32KB)
800030c0:	58 2b       	cp.w	r11,2
800030c2:	c0 31       	brne	800030c8 <data_flash_erase_block+0x28>
800030c4:	35 23       	mov	r3,82
800030c6:	c0 68       	rjmp	800030d2 <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_32KB;
	else if(block_size == DF_BLOCK_64KB)
800030c8:	e0 63 00 d8 	mov	r3,216
800030cc:	58 3b       	cp.w	r11,3
800030ce:	f9 b3 01 60 	movne	r3,96
		erase_commond = BLOCK_ERASE_64KB;
	else/*(block_size == DF_BLOCK_ALL)*/
		erase_commond = CHIP_ERASE;

	while(status = send_flash_command(READ_STATUS_REG, 0, NULL, 0) == STATUS_BUSY);
800030d2:	30 06       	mov	r6,0
800030d4:	30 55       	mov	r5,5
800030d6:	30 17       	mov	r7,1
800030d8:	0c 99       	mov	r9,r6
800030da:	0c 9a       	mov	r10,r6
800030dc:	0c 9b       	mov	r11,r6
800030de:	0a 9c       	mov	r12,r5
800030e0:	f0 1f 00 17 	mcall	8000313c <data_flash_erase_block+0x9c>
800030e4:	ee 0c 19 00 	cp.h	r12,r7
800030e8:	cf 80       	breq	800030d8 <data_flash_erase_block+0x38>
	//{
		//return DF_DEVICE_BUSY;
	//}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
800030ea:	30 09       	mov	r9,0
800030ec:	12 9a       	mov	r10,r9
800030ee:	12 9b       	mov	r11,r9
800030f0:	30 6c       	mov	r12,6
800030f2:	f0 1f 00 13 	mcall	8000313c <data_flash_erase_block+0x9c>

	/* send BLOCK_ERASE command */
	send_flash_command(erase_commond, address, NULL, 0);
800030f6:	30 09       	mov	r9,0
800030f8:	12 9a       	mov	r10,r9
800030fa:	08 9b       	mov	r11,r4
800030fc:	06 9c       	mov	r12,r3
800030fe:	f0 1f 00 10 	mcall	8000313c <data_flash_erase_block+0x9c>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80003102:	30 06       	mov	r6,0
80003104:	30 57       	mov	r7,5
80003106:	0c 99       	mov	r9,r6
80003108:	0c 9a       	mov	r10,r6
8000310a:	0c 9b       	mov	r11,r6
8000310c:	0e 9c       	mov	r12,r7
8000310e:	f0 1f 00 0c 	mcall	8000313c <data_flash_erase_block+0x9c>
		count++;
	} while((status & STATUS_BUSY) != 0);
80003112:	5c 7c       	castu.h	r12
80003114:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80003118:	cf 71       	brne	80003106 <data_flash_erase_block+0x66>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
8000311a:	18 97       	mov	r7,r12
8000311c:	e2 17 00 20 	andl	r7,0x20,COH
80003120:	f9 b7 01 04 	movne	r7,4
80003124:	f9 b7 00 05 	moveq	r7,5
		/*  Erase Successful.  */
		return_code = DF_ERASE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80003128:	30 09       	mov	r9,0
8000312a:	12 9a       	mov	r10,r9
8000312c:	12 9b       	mov	r11,r9
8000312e:	30 4c       	mov	r12,4
80003130:	f0 1f 00 03 	mcall	8000313c <data_flash_erase_block+0x9c>

	return return_code;
}
80003134:	0e 9c       	mov	r12,r7
80003136:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000313a:	00 00       	add	r0,r0
8000313c:	80 00       	ld.sh	r0,r0[0x0]
8000313e:	2d 44       	sub	r4,-44

80003140 <data_flash_write>:
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
{
80003140:	d4 31       	pushm	r0-r7,lr
80003142:	20 3d       	sub	sp,12
80003144:	50 0c       	stdsp	sp[0x0],r12
80003146:	16 91       	mov	r1,r11
80003148:	14 95       	mov	r5,r10
	U16 secremain;
	U16 i;
	df_status_t return_code = DF_OK;

	secpos	=	address/4096;//扇区地址 0~2047 for AT25DF641 
	secoff	=	address%4096;//在扇区内的偏移
8000314a:	f5 db c0 0c 	bfextu	r10,r11,0x0,0xc
8000314e:	50 1a       	stdsp	sp[0x4],r10
	secremain	=	4096-secoff;//扇区剩余空间大小
80003150:	e0 69 10 00 	mov	r9,4096
80003154:	f2 0a 01 07 	sub	r7,r9,r10
80003158:	ea 07 19 00 	cp.h	r7,r5
8000315c:	ea 07 17 b0 	movhi	r7,r5
80003160:	5c 87       	casts.h	r7
80003162:	16 92       	mov	r2,r11
80003164:	e0 12 f0 00 	andl	r2,0xf000
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80003168:	4a e4       	lddpc	r4,80003220 <data_flash_write+0xe0>
		for(i=0; i<secremain; i++)//校验数据
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
8000316a:	3f f6       	mov	r6,-1
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
8000316c:	e8 c8 ff ff 	sub	r8,r4,-1
80003170:	50 28       	stdsp	sp[0x8],r8
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
			address+=secremain;//写地址偏移
			data_length-=secremain;				//字节数递减
80003172:	12 90       	mov	r0,r9
	secoff	=	address%4096;//在扇区内的偏移
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80003174:	08 9a       	mov	r10,r4
80003176:	e0 6b 10 00 	mov	r11,4096
8000317a:	04 9c       	mov	r12,r2
8000317c:	f0 1f 00 2a 	mcall	80003224 <data_flash_write+0xe4>
		for(i=0; i<secremain; i++)//校验数据
80003180:	58 07       	cp.w	r7,0
80003182:	c3 00       	breq	800031e2 <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80003184:	40 13       	lddsp	r3,sp[0x4]
80003186:	5c 73       	castu.h	r3
80003188:	e8 03 07 08 	ld.ub	r8,r4[r3]
8000318c:	ec 08 18 00 	cp.b	r8,r6
80003190:	c1 11       	brne	800031b2 <data_flash_write+0x72>
80003192:	e6 c9 ff ff 	sub	r9,r3,-1
80003196:	08 09       	add	r9,r4
80003198:	30 08       	mov	r8,0
8000319a:	c0 58       	rjmp	800031a4 <data_flash_write+0x64>
8000319c:	13 3a       	ld.ub	r10,r9++
8000319e:	ec 0a 18 00 	cp.b	r10,r6
800031a2:	c0 81       	brne	800031b2 <data_flash_write+0x72>
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
		for(i=0; i<secremain; i++)//校验数据
800031a4:	2f f8       	sub	r8,-1
800031a6:	5c 88       	casts.h	r8
800031a8:	f0 07 19 00 	cp.h	r7,r8
800031ac:	fe 9b ff f8 	brhi	8000319c <data_flash_write+0x5c>
800031b0:	c1 98       	rjmp	800031e2 <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
800031b2:	30 1b       	mov	r11,1
800031b4:	04 9c       	mov	r12,r2
800031b6:	f0 1f 00 1d 	mcall	80003228 <data_flash_write+0xe8>
800031ba:	40 08       	lddsp	r8,sp[0x0]
800031bc:	08 03       	add	r3,r4
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
800031be:	40 2a       	lddsp	r10,sp[0x8]
800031c0:	40 19       	lddsp	r9,sp[0x4]
800031c2:	12 0a       	add	r10,r9
800031c4:	0e 99       	mov	r9,r7
800031c6:	20 19       	sub	r9,1
800031c8:	5c 79       	castu.h	r9
800031ca:	12 0a       	add	r10,r9
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
800031cc:	11 39       	ld.ub	r9,r8++
800031ce:	06 c9       	st.b	r3++,r9
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
800031d0:	14 33       	cp.w	r3,r10
800031d2:	cf d1       	brne	800031cc <data_flash_write+0x8c>
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
			}
			return_code = data_flash_write_block(FLASH_BUF, secpos*4096, 4096);//写入整个扇区
800031d4:	e0 6a 10 00 	mov	r10,4096
800031d8:	04 9b       	mov	r11,r2
800031da:	08 9c       	mov	r12,r4
800031dc:	f0 1f 00 14 	mcall	8000322c <data_flash_write+0xec>
800031e0:	c0 78       	rjmp	800031ee <data_flash_write+0xae>

		}
		else 
		{
			return_code = data_flash_write_block(data_ptr, address, secremain);//写已经擦除了的,直接写入扇区剩余区间.
800031e2:	0e 9a       	mov	r10,r7
800031e4:	5c 7a       	castu.h	r10
800031e6:	02 9b       	mov	r11,r1
800031e8:	40 0c       	lddsp	r12,sp[0x0]
800031ea:	f0 1f 00 11 	mcall	8000322c <data_flash_write+0xec>
800031ee:	e4 c2 f0 00 	sub	r2,r2,-4096
		}
		if(data_length==secremain)break;//写入结束了
800031f2:	0e 98       	mov	r8,r7
800031f4:	ee 05 19 00 	cp.h	r5,r7
800031f8:	c1 20       	breq	8000321c <data_flash_write+0xdc>
		else//写入未结束
		{
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
800031fa:	5c 78       	castu.h	r8
800031fc:	40 0a       	lddsp	r10,sp[0x0]
800031fe:	10 0a       	add	r10,r8
80003200:	50 0a       	stdsp	sp[0x0],r10
			address+=secremain;//写地址偏移
80003202:	10 01       	add	r1,r8
			data_length-=secremain;				//字节数递减
80003204:	0e 15       	sub	r5,r7
80003206:	5c 85       	casts.h	r5
80003208:	e0 05 19 00 	cp.h	r5,r0
8000320c:	ea 07 17 80 	movls	r7,r5
80003210:	e0 07 17 b0 	movhi	r7,r0
80003214:	5c 87       	casts.h	r7
80003216:	30 09       	mov	r9,0
80003218:	50 19       	stdsp	sp[0x4],r9
8000321a:	ca db       	rjmp	80003174 <data_flash_write+0x34>
		}
	}
	
	return return_code;
	
}
8000321c:	2f dd       	sub	sp,-12
8000321e:	d8 32       	popm	r0-r7,pc
80003220:	00 00       	add	r0,r0
80003222:	0e 30       	cp.w	r0,r7
80003224:	80 00       	ld.sh	r0,r0[0x0]
80003226:	2f 08       	sub	r8,-16
80003228:	80 00       	ld.sh	r0,r0[0x0]
8000322a:	30 a0       	mov	r0,10
8000322c:	80 00       	ld.sh	r0,r0[0x0]
8000322e:	2f e0       	sub	r0,-2

80003230 <W25Q64_SPI_SetSpeed>:




void W25Q64_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80003230:	d4 01       	pushm	lr
	spi->csr1 = (spi->csr1 & (U16)0x00FF) |SPI_BaudRatePrescaler;
80003232:	48 78       	lddpc	r8,8000324c <W25Q64_SPI_SetSpeed+0x1c>
80003234:	70 09       	ld.w	r9,r8[0x0]
80003236:	72 da       	ld.w	r10,r9[0x34]
80003238:	5c 7c       	castu.h	r12
8000323a:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
8000323e:	f9 ea 10 0a 	or	r10,r12,r10
80003242:	93 da       	st.w	r9[0x34],r10

	spi_enable(spi); /*!< W25Q64_SPI enable */
80003244:	70 0c       	ld.w	r12,r8[0x0]
80003246:	f0 1f 00 03 	mcall	80003250 <W25Q64_SPI_SetSpeed+0x20>
	
	
}
8000324a:	d8 02       	popm	pc
8000324c:	00 00       	add	r0,r0
8000324e:	1e 30       	cp.w	r0,pc
80003250:	80 00       	ld.sh	r0,r0[0x0]
80003252:	68 7c       	ld.w	r12,r4[0x1c]

80003254 <W25Q64_SPI_SetSpeedLow>:
void W25Q64_SPI_SetSpeedLow(void)
{
80003254:	d4 01       	pushm	lr
	W25Q64_SPI_SetSpeed(0x0200);//baudDiv=4
80003256:	e0 6c 02 00 	mov	r12,512
8000325a:	f0 1f 00 02 	mcall	80003260 <W25Q64_SPI_SetSpeedLow+0xc>
	
}
8000325e:	d8 02       	popm	pc
80003260:	80 00       	ld.sh	r0,r0[0x0]
80003262:	32 30       	mov	r0,35

80003264 <data_flash_init>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void data_flash_init(void)
{
80003264:	eb cd 40 c0 	pushm	r6-r7,lr
80003268:	20 5d       	sub	sp,20
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 1,//0,0 针对不同的存储芯片，注意模式
		.modfdis      = 1
	};
8000326a:	4b a8       	lddpc	r8,80003350 <data_flash_init+0xec>
8000326c:	fa c6 ff fc 	sub	r6,sp,-4
80003270:	f0 ea 00 00 	ld.d	r10,r8[0]
80003274:	ec eb 00 00 	st.d	r6[0],r10
80003278:	f0 e8 00 08 	ld.d	r8,r8[8]
8000327c:	ec e9 00 08 	st.d	r6[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(DF_SPI_GPIO_MAP, sizeof(DF_SPI_GPIO_MAP) / sizeof(DF_SPI_GPIO_MAP[0]));
80003280:	30 4b       	mov	r11,4
80003282:	4b 5c       	lddpc	r12,80003354 <data_flash_init+0xf0>
80003284:	f0 1f 00 35 	mcall	80003358 <data_flash_init+0xf4>

	spi = &AVR32_SPI;
80003288:	4b 57       	lddpc	r7,8000335c <data_flash_init+0xf8>
8000328a:	fe 7c 24 00 	mov	r12,-56320
8000328e:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80003290:	0c 9b       	mov	r11,r6
80003292:	f0 1f 00 34 	mcall	80003360 <data_flash_init+0xfc>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80003296:	30 09       	mov	r9,0
80003298:	12 9a       	mov	r10,r9
8000329a:	12 9b       	mov	r11,r9
8000329c:	6e 0c       	ld.w	r12,r7[0x0]
8000329e:	f0 1f 00 32 	mcall	80003364 <data_flash_init+0x100>

	// Enable SPI.
	spi_enable(spi);
800032a2:	6e 0c       	ld.w	r12,r7[0x0]
800032a4:	f0 1f 00 31 	mcall	80003368 <data_flash_init+0x104>

	W25Q64_SPI_SetSpeedLow();
800032a8:	f0 1f 00 31 	mcall	8000336c <data_flash_init+0x108>

	// Initialize data flash with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
800032ac:	e0 6a 36 00 	mov	r10,13824
800032b0:	ea 1a 01 6e 	orh	r10,0x16e
800032b4:	0c 9b       	mov	r11,r6
800032b6:	6e 0c       	ld.w	r12,r7[0x0]
800032b8:	f0 1f 00 2e 	mcall	80003370 <data_flash_init+0x10c>
800032bc:	c0 50       	breq	800032c6 <data_flash_init+0x62>
	{
		data_flash_failure = FATAL_ERROR_DATA_FLASH_SPI_INIT;
800032be:	30 29       	mov	r9,2
800032c0:	4a d8       	lddpc	r8,80003374 <data_flash_init+0x110>
800032c2:	b0 89       	st.b	r8[0x0],r9
		return;
800032c4:	c4 28       	rjmp	80003348 <data_flash_init+0xe4>
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
static Bool data_flash_check_device_id(void)
{
	U16 manufacturer_device_id[2] = {0x5A5A, 0x5A5A};
800032c6:	1a 96       	mov	r6,sp
800032c8:	30 4a       	mov	r10,4
800032ca:	4a cb       	lddpc	r11,80003378 <data_flash_init+0x114>
800032cc:	1a 9c       	mov	r12,sp
800032ce:	f0 1f 00 2c 	mcall	8000337c <data_flash_init+0x118>

	/* DF memory check. */
	/* Select the DF memory to check. */
	spi_selectChip(spi, DF_SPI_PCS_1);
800032d2:	4a 37       	lddpc	r7,8000335c <data_flash_init+0xf8>
800032d4:	30 1b       	mov	r11,1
800032d6:	6e 0c       	ld.w	r12,r7[0x0]
800032d8:	f0 1f 00 2a 	mcall	80003380 <data_flash_init+0x11c>

	/* Send the Manufacturer/Device ID Read command. */
	spi_write(spi, READ_M_D_ID);	
800032dc:	e0 6b 00 90 	mov	r11,144
800032e0:	6e 0c       	ld.w	r12,r7[0x0]
800032e2:	f0 1f 00 29 	mcall	80003384 <data_flash_init+0x120>
	spi_write_zero();
800032e6:	30 0b       	mov	r11,0
800032e8:	6e 0c       	ld.w	r12,r7[0x0]
800032ea:	f0 1f 00 27 	mcall	80003384 <data_flash_init+0x120>
	spi_write_zero();
800032ee:	30 0b       	mov	r11,0
800032f0:	6e 0c       	ld.w	r12,r7[0x0]
800032f2:	f0 1f 00 25 	mcall	80003384 <data_flash_init+0x120>
	spi_write_zero();
800032f6:	30 0b       	mov	r11,0
800032f8:	6e 0c       	ld.w	r12,r7[0x0]
800032fa:	f0 1f 00 23 	mcall	80003384 <data_flash_init+0x120>

	/* Send 2 dummy byte to read the status register. */
	
	spi_write_dummy();
800032fe:	e0 6b 00 ff 	mov	r11,255
80003302:	6e 0c       	ld.w	r12,r7[0x0]
80003304:	f0 1f 00 20 	mcall	80003384 <data_flash_init+0x120>
	spi_read(spi, &manufacturer_device_id[0]);
80003308:	1a 9b       	mov	r11,sp
8000330a:	6e 0c       	ld.w	r12,r7[0x0]
8000330c:	f0 1f 00 1f 	mcall	80003388 <data_flash_init+0x124>
	
	spi_write_dummy();
80003310:	e0 6b 00 ff 	mov	r11,255
80003314:	6e 0c       	ld.w	r12,r7[0x0]
80003316:	f0 1f 00 1c 	mcall	80003384 <data_flash_init+0x120>
	spi_read(spi, &manufacturer_device_id[1]);
8000331a:	fa cb ff fe 	sub	r11,sp,-2
8000331e:	6e 0c       	ld.w	r12,r7[0x0]
80003320:	f0 1f 00 1a 	mcall	80003388 <data_flash_init+0x124>

	/* Unselect the checked DF memory. */
	spi_unselectChip(spi, DF_SPI_PCS_1);
80003324:	30 1b       	mov	r11,1
80003326:	6e 0c       	ld.w	r12,r7[0x0]
80003328:	f0 1f 00 19 	mcall	8000338c <data_flash_init+0x128>

	/* Unexpected device ID. */
    if ((manufacturer_device_id[0] != 0xEF) || (manufacturer_device_id[1] != 0x16))
8000332c:	e0 68 00 ef 	mov	r8,239
80003330:	9a 09       	ld.sh	r9,sp[0x0]
80003332:	f0 09 19 00 	cp.h	r9,r8
80003336:	c0 61       	brne	80003342 <data_flash_init+0xde>
80003338:	31 68       	mov	r8,22
8000333a:	9a 19       	ld.sh	r9,sp[0x2]
8000333c:	f0 09 19 00 	cp.h	r9,r8
80003340:	c0 40       	breq	80003348 <data_flash_init+0xe4>
		return;
	}
	 
	if (data_flash_check_device_id() != TRUE)//check W25Q64 ID
	{
		data_flash_failure = FATAL_ERROR_DATA_FLASH_READ_ID;
80003342:	30 39       	mov	r9,3
80003344:	48 c8       	lddpc	r8,80003374 <data_flash_init+0x110>
80003346:	b0 89       	st.b	r8[0x0],r9
	//send_flash_command(WRITE_ENABLE, 0, NULL, 0);
	//send_flash_command(WRITE_STATUS_REG_BYTE_1, 0, NULL, 0);
	//status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
	
	return;
}
80003348:	2f bd       	sub	sp,-20
8000334a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000334e:	00 00       	add	r0,r0
80003350:	80 00       	ld.sh	r0,r0[0x0]
80003352:	e9 0c 80 00 	ld.sh	r12,r4[-32768]
80003356:	e8 e8 80 00 	ld.d	r8,r4[-32768]
8000335a:	63 a8       	ld.w	r8,r1[0x68]
8000335c:	00 00       	add	r0,r0
8000335e:	1e 30       	cp.w	r0,pc
80003360:	80 00       	ld.sh	r0,r0[0x0]
80003362:	68 18       	ld.w	r8,r4[0x4]
80003364:	80 00       	ld.sh	r0,r0[0x0]
80003366:	68 50       	ld.w	r0,r4[0x14]
80003368:	80 00       	ld.sh	r0,r0[0x0]
8000336a:	68 7c       	ld.w	r12,r4[0x1c]
8000336c:	80 00       	ld.sh	r0,r0[0x0]
8000336e:	32 54       	mov	r4,37
80003370:	80 00       	ld.sh	r0,r0[0x0]
80003372:	68 c0       	ld.w	r0,r4[0x30]
80003374:	00 00       	add	r0,r0
80003376:	0a 8b       	andn	r11,r5
80003378:	80 00       	ld.sh	r0,r0[0x0]
8000337a:	e9 08 80 00 	ld.sh	r8,r4[-32768]
8000337e:	88 6e       	ld.sh	lr,r4[0xc]
80003380:	80 00       	ld.sh	r0,r0[0x0]
80003382:	69 e8       	ld.w	r8,r4[0x78]
80003384:	80 00       	ld.sh	r0,r0[0x0]
80003386:	68 82       	ld.w	r2,r4[0x20]
80003388:	80 00       	ld.sh	r0,r0[0x0]
8000338a:	68 9e       	ld.w	lr,r4[0x24]
8000338c:	80 00       	ld.sh	r0,r0[0x0]
8000338e:	69 a8       	ld.w	r8,r4[0x68]

80003390 <xg_rtc_init>:
}



void xg_rtc_init(void)
{
80003390:	d4 01       	pushm	lr
	
	// Disable all interrupts. */
	Disable_global_interrupt();
80003392:	d3 03       	ssrf	0x10
	  
	// Register the RTC interrupt handler to the interrupt controller.
	INTC_register_interrupt(&rtc_irq, AVR32_RTC_IRQ, AVR32_INTC_INT0);
80003394:	30 0a       	mov	r10,0
80003396:	32 8b       	mov	r11,40
80003398:	49 5c       	lddpc	r12,800033ec <xg_rtc_init+0x5c>
8000339a:	f0 1f 00 16 	mcall	800033f0 <xg_rtc_init+0x60>

	// Initialize the RTC
	//if (!rtc_init(&AVR32_RTC, RTC_OSC_RC, RTC_PSEL_RC_1_76HZ))
	if (!rtc_init(&AVR32_RTC, RTC_OSC_32KHZ, RTC_PSEL_32KHZ_1HZ))
8000339e:	30 ea       	mov	r10,14
800033a0:	30 1b       	mov	r11,1
800033a2:	fe 7c 0d 00 	mov	r12,-62208
800033a6:	f0 1f 00 14 	mcall	800033f4 <xg_rtc_init+0x64>
800033aa:	c0 41       	brne	800033b2 <xg_rtc_init+0x22>
	{
		log("Error initializing the RTC\r\n");
800033ac:	49 3c       	lddpc	r12,800033f8 <xg_rtc_init+0x68>
800033ae:	f0 1f 00 14 	mcall	800033fc <xg_rtc_init+0x6c>
	}
	// Set top value to 0 to generate an interrupt every seconds */
	rtc_set_top_value(&AVR32_RTC, 0);
800033b2:	30 0b       	mov	r11,0
800033b4:	fe 7c 0d 00 	mov	r12,-62208
800033b8:	f0 1f 00 12 	mcall	80003400 <xg_rtc_init+0x70>
	// Enable the interrupts
	rtc_enable_interrupt(&AVR32_RTC);
800033bc:	fe 7c 0d 00 	mov	r12,-62208
800033c0:	f0 1f 00 11 	mcall	80003404 <xg_rtc_init+0x74>
	// Enable the RTC
	rtc_enable(&AVR32_RTC);
800033c4:	fe 7c 0d 00 	mov	r12,-62208
800033c8:	f0 1f 00 10 	mcall	80003408 <xg_rtc_init+0x78>

	Current_time.Year		= 16;
800033cc:	49 08       	lddpc	r8,8000340c <xg_rtc_init+0x7c>
800033ce:	31 09       	mov	r9,16
800033d0:	b0 89       	st.b	r8[0x0],r9
	Current_time.Month		= 2;
800033d2:	30 29       	mov	r9,2
800033d4:	b0 99       	st.b	r8[0x1],r9
	Current_time.Day		= 29;
800033d6:	31 d9       	mov	r9,29
800033d8:	b0 a9       	st.b	r8[0x2],r9
	Current_time.Hour		= 23;
800033da:	31 79       	mov	r9,23
800033dc:	b0 b9       	st.b	r8[0x3],r9
	Current_time.Minute		= 59;
800033de:	33 b9       	mov	r9,59
800033e0:	b0 c9       	st.b	r8[0x4],r9
	Current_time.Second		= 40;
800033e2:	32 89       	mov	r9,40
800033e4:	b0 d9       	st.b	r8[0x5],r9
	
	// Enable global interrupts
	Enable_global_interrupt();
800033e6:	d5 03       	csrf	0x10
	  
	//RTC_Test();	

}
800033e8:	d8 02       	popm	pc
800033ea:	00 00       	add	r0,r0
800033ec:	80 00       	ld.sh	r0,r0[0x0]
800033ee:	34 10       	mov	r0,65
800033f0:	80 00       	ld.sh	r0,r0[0x0]
800033f2:	64 2c       	ld.w	r12,r2[0x8]
800033f4:	80 00       	ld.sh	r0,r0[0x0]
800033f6:	67 78       	ld.w	r8,r3[0x5c]
800033f8:	80 00       	ld.sh	r0,r0[0x0]
800033fa:	e9 1c 80 00 	ld.uh	r12,r4[-32768]
800033fe:	7f c4       	ld.w	r4,pc[0x70]
80003400:	80 00       	ld.sh	r0,r0[0x0]
80003402:	67 34       	ld.w	r4,r3[0x4c]
80003404:	80 00       	ld.sh	r0,r0[0x0]
80003406:	67 2c       	ld.w	r12,r3[0x48]
80003408:	80 00       	ld.sh	r0,r0[0x0]
8000340a:	67 08       	ld.w	r8,r3[0x40]
8000340c:	00 00       	add	r0,r0
8000340e:	0e 20       	rsub	r0,r7

80003410 <rtc_irq>:
/* RTC Interrupt  */
#pragma handler = AVR32_RTC_IRQ_GROUP, 1
__interrupt
#endif
void rtc_irq(void)
{
80003410:	d4 01       	pushm	lr
	U8 T,K;
	U32 T16,K16;
	// Increment the minutes counter
	//sec++;
	
	Current_time.Second++;
80003412:	4b 98       	lddpc	r8,800034f4 <rtc_irq+0xe4>
80003414:	11 d9       	ld.ub	r9,r8[0x5]
80003416:	2f f9       	sub	r9,-1
80003418:	b0 d9       	st.b	r8[0x5],r9
	if(Current_time.Second>=60)
8000341a:	11 d9       	ld.ub	r9,r8[0x5]
8000341c:	33 b8       	mov	r8,59
8000341e:	f0 09 18 00 	cp.b	r9,r8
80003422:	e0 88 00 5f 	brls	800034e0 <rtc_irq+0xd0>
	{
		Current_time.Second =0;
80003426:	4b 48       	lddpc	r8,800034f4 <rtc_irq+0xe4>
80003428:	30 09       	mov	r9,0
8000342a:	b0 d9       	st.b	r8[0x5],r9
		Current_time.Minute++;
8000342c:	11 c9       	ld.ub	r9,r8[0x4]
8000342e:	2f f9       	sub	r9,-1
80003430:	b0 c9       	st.b	r8[0x4],r9
		if(Current_time.Minute>=60)
80003432:	11 c9       	ld.ub	r9,r8[0x4]
80003434:	33 b8       	mov	r8,59
80003436:	f0 09 18 00 	cp.b	r9,r8
8000343a:	e0 88 00 53 	brls	800034e0 <rtc_irq+0xd0>
		{
			Current_time.Minute=0;
8000343e:	4a e8       	lddpc	r8,800034f4 <rtc_irq+0xe4>
80003440:	30 09       	mov	r9,0
80003442:	b0 c9       	st.b	r8[0x4],r9
			Current_time.Hour++;
80003444:	11 b9       	ld.ub	r9,r8[0x3]
80003446:	2f f9       	sub	r9,-1
80003448:	b0 b9       	st.b	r8[0x3],r9
			if (Current_time.Hour>=24)
8000344a:	11 b9       	ld.ub	r9,r8[0x3]
8000344c:	31 78       	mov	r8,23
8000344e:	f0 09 18 00 	cp.b	r9,r8
80003452:	e0 88 00 47 	brls	800034e0 <rtc_irq+0xd0>
			{
				Current_time.Hour=0;
80003456:	4a 88       	lddpc	r8,800034f4 <rtc_irq+0xe4>
80003458:	30 09       	mov	r9,0
8000345a:	b0 b9       	st.b	r8[0x3],r9
				K16=(Current_time.Year&0x03)?365:366;				//判断当年是否为闰年,并获取当年的总天数（此算法时间起点为2000年）
8000345c:	11 88       	ld.ub	r8,r8[0x0]
8000345e:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80003462:	e0 69 01 6e 	mov	r9,366
80003466:	e0 6a 01 6d 	mov	r10,365
8000346a:	f4 08 17 10 	movne	r8,r10
8000346e:	f2 08 17 00 	moveq	r8,r9
				K16-=337;											//计算当年二月份天数
				//统计当月天数				
				K=(Current_time.Month==2)?K16:(((Current_time.Month+(Current_time.Month>>3))&0x01)+30);			
80003472:	4a 19       	lddpc	r9,800034f4 <rtc_irq+0xe4>
80003474:	13 9a       	ld.ub	r10,r9[0x1]
80003476:	30 29       	mov	r9,2
80003478:	f2 0a 18 00 	cp.b	r10,r9
8000347c:	c0 b0       	breq	80003492 <rtc_irq+0x82>
8000347e:	49 e8       	lddpc	r8,800034f4 <rtc_irq+0xe4>
80003480:	11 99       	ld.ub	r9,r8[0x1]
80003482:	11 9a       	ld.ub	r10,r8[0x1]
80003484:	a3 9a       	lsr	r10,0x3
80003486:	12 0a       	add	r10,r9
80003488:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000348c:	2e 2a       	sub	r10,-30
8000348e:	5c 5a       	castu.b	r10
80003490:	c0 58       	rjmp	8000349a <rtc_irq+0x8a>
80003492:	f0 c8 01 51 	sub	r8,r8,337
80003496:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
				Current_time.Day++;
8000349a:	49 78       	lddpc	r8,800034f4 <rtc_irq+0xe4>
8000349c:	11 a9       	ld.ub	r9,r8[0x2]
8000349e:	2f f9       	sub	r9,-1
800034a0:	b0 a9       	st.b	r8[0x2],r9
				if(Current_time.Day>K)
800034a2:	11 a8       	ld.ub	r8,r8[0x2]
800034a4:	f0 0a 18 00 	cp.b	r10,r8
800034a8:	c1 c2       	brcc	800034e0 <rtc_irq+0xd0>
				{	
					Current_time.Day = 1;//重置到下月1号
800034aa:	49 38       	lddpc	r8,800034f4 <rtc_irq+0xe4>
800034ac:	30 19       	mov	r9,1
800034ae:	b0 a9       	st.b	r8[0x2],r9
					Current_time.Month++;
800034b0:	11 99       	ld.ub	r9,r8[0x1]
800034b2:	2f f9       	sub	r9,-1
800034b4:	b0 99       	st.b	r8[0x1],r9
					if(Current_time.Month>12)
800034b6:	11 99       	ld.ub	r9,r8[0x1]
800034b8:	30 c8       	mov	r8,12
800034ba:	f0 09 18 00 	cp.b	r9,r8
800034be:	e0 88 00 11 	brls	800034e0 <rtc_irq+0xd0>
					{
						Current_time.Month = 1;//重置到下一年的第一个月
800034c2:	48 d8       	lddpc	r8,800034f4 <rtc_irq+0xe4>
800034c4:	30 19       	mov	r9,1
800034c6:	b0 99       	st.b	r8[0x1],r9
						Current_time.Year++;
800034c8:	11 89       	ld.ub	r9,r8[0x0]
800034ca:	2f f9       	sub	r9,-1
800034cc:	b0 89       	st.b	r8[0x0],r9
						if (Current_time.Year>150)Current_time.Year=0;//重置年份											
800034ce:	11 89       	ld.ub	r9,r8[0x0]
800034d0:	39 68       	mov	r8,-106
800034d2:	f0 09 18 00 	cp.b	r9,r8
800034d6:	e0 88 00 05 	brls	800034e0 <rtc_irq+0xd0>
800034da:	30 09       	mov	r9,0
800034dc:	48 68       	lddpc	r8,800034f4 <rtc_irq+0xe4>
800034de:	b0 89       	st.b	r8[0x0],r9
	}
	
	//Time_scale++;

	// clear the interrupt flag
	rtc_clear_interrupt(&AVR32_RTC);
800034e0:	fe 7c 0d 00 	mov	r12,-62208
800034e4:	f0 1f 00 05 	mcall	800034f8 <rtc_irq+0xe8>

	// specify that an interrupt has been raised
	print_sec = 1;
800034e8:	30 19       	mov	r9,1
800034ea:	48 58       	lddpc	r8,800034fc <rtc_irq+0xec>
800034ec:	91 09       	st.w	r8[0x0],r9
}
800034ee:	d4 02       	popm	lr
800034f0:	d6 03       	rete
800034f2:	00 00       	add	r0,r0
800034f4:	00 00       	add	r0,r0
800034f6:	0e 20       	rsub	r0,r7
800034f8:	80 00       	ld.sh	r0,r0[0x0]
800034fa:	67 58       	ld.w	r8,r3[0x54]
800034fc:	00 00       	add	r0,r0
800034fe:	04 fc       	st.b	--r2,r12

80003500 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80003500:	20 1c       	sub	r12,1
80003502:	5c 5c       	castu.b	r12
80003504:	31 18       	mov	r8,17
80003506:	f0 0c 18 00 	cp.b	r12,r8
8000350a:	e0 88 00 03 	brls	80003510 <CalculateBurst+0x10>
8000350e:	5e fd       	retal	0
80003510:	48 28       	lddpc	r8,80003518 <CalculateBurst+0x18>
80003512:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80003516:	5e fc       	retal	r12
80003518:	80 00       	ld.sh	r0,r0[0x0]
8000351a:	e9 3c 48 38 	ld.ub	r12,r4[18488]

8000351c <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
8000351c:	48 38       	lddpc	r8,80003528 <payload_init+0xc>
8000351e:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80003520:	48 38       	lddpc	r8,8000352c <payload_init+0x10>
80003522:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
80003524:	5e fc       	retal	r12
80003526:	00 00       	add	r0,r0
80003528:	00 00       	add	r0,r0
8000352a:	0a 8c       	andn	r12,r5
8000352c:	00 00       	add	r0,r0
8000352e:	0a 90       	mov	r0,r5

80003530 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80003530:	d4 01       	pushm	lr
80003532:	20 2d       	sub	sp,8
80003534:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003536:	30 09       	mov	r9,0
80003538:	fa ca ff f8 	sub	r10,sp,-8
8000353c:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
8000353e:	1a 9b       	mov	r11,sp
80003540:	f0 1f 00 02 	mcall	80003548 <set_idle_store_isr+0x18>
}
80003544:	2f ed       	sub	sp,-8
80003546:	d8 02       	popm	pc
80003548:	80 00       	ld.sh	r0,r0[0x0]
8000354a:	73 3c       	ld.w	r12,r9[0x4c]

8000354c <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
8000354c:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
8000354e:	48 48       	lddpc	r8,8000355c <payload_rx+0x10>
80003550:	70 08       	ld.w	r8,r8[0x0]
80003552:	18 9b       	mov	r11,r12
80003554:	10 9c       	mov	r12,r8
80003556:	f0 1f 00 03 	mcall	80003560 <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
8000355a:	d8 02       	popm	pc
8000355c:	00 00       	add	r0,r0
8000355e:	0a c8       	st.b	r5++,r8
80003560:	80 00       	ld.sh	r0,r0[0x0]
80003562:	35 30       	mov	r0,83

80003564 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80003564:	d4 01       	pushm	lr
80003566:	20 2d       	sub	sp,8
80003568:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
8000356a:	58 0c       	cp.w	r12,0
8000356c:	c1 10       	breq	8000358e <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000356e:	30 08       	mov	r8,0
80003570:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80003572:	98 88       	ld.uh	r8,r12[0x0]
80003574:	e2 18 f0 00 	andl	r8,0xf000,COH
80003578:	e0 48 40 00 	cp.w	r8,16384
8000357c:	c0 91       	brne	8000358e <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
8000357e:	48 68       	lddpc	r8,80003594 <phy_rx+0x30>
80003580:	70 0c       	ld.w	r12,r8[0x0]
80003582:	30 09       	mov	r9,0
80003584:	fa ca ff fc 	sub	r10,sp,-4
80003588:	1a 9b       	mov	r11,sp
8000358a:	f0 1f 00 04 	mcall	80003598 <phy_rx+0x34>
		}	

    }
		
 
}
8000358e:	2f ed       	sub	sp,-8
80003590:	d8 02       	popm	pc
80003592:	00 00       	add	r0,r0
80003594:	00 00       	add	r0,r0
80003596:	0a d4       	st.w	--r5,r4
80003598:	80 00       	ld.sh	r0,r0[0x0]
8000359a:	73 3c       	ld.w	r12,r9[0x4c]

8000359c <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
8000359c:	eb cd 40 80 	pushm	r7,lr
800035a0:	20 1d       	sub	sp,4
800035a2:	fa c7 ff fc 	sub	r7,sp,-4
800035a6:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
800035a8:	30 09       	mov	r9,0
800035aa:	12 9a       	mov	r10,r9
800035ac:	1a 9b       	mov	r11,sp
800035ae:	f0 1f 00 03 	mcall	800035b8 <set_idle_store+0x1c>
}
800035b2:	2f fd       	sub	sp,-4
800035b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800035b8:	80 00       	ld.sh	r0,r0[0x0]
800035ba:	73 8c       	ld.w	r12,r9[0x60]

800035bc <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
800035bc:	d4 01       	pushm	lr
800035be:	20 1d       	sub	sp,4
800035c0:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
800035c2:	98 88       	ld.uh	r8,r12[0x0]
800035c4:	e2 18 f0 00 	andl	r8,0xf000,COH
800035c8:	e0 48 40 00 	cp.w	r8,16384
800035cc:	c0 d1       	brne	800035e6 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
800035ce:	49 08       	lddpc	r8,8000360c <phy_tx+0x50>
800035d0:	70 08       	ld.w	r8,r8[0x0]
800035d2:	58 08       	cp.w	r8,0
800035d4:	c1 a0       	breq	80003608 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
800035d6:	48 e8       	lddpc	r8,8000360c <phy_tx+0x50>
800035d8:	70 0c       	ld.w	r12,r8[0x0]
800035da:	30 09       	mov	r9,0
800035dc:	12 9a       	mov	r10,r9
800035de:	1a 9b       	mov	r11,sp
800035e0:	f0 1f 00 0c 	mcall	80003610 <phy_tx+0x54>
800035e4:	c1 28       	rjmp	80003608 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
800035e6:	e0 48 10 00 	cp.w	r8,4096
800035ea:	5f 0a       	sreq	r10
800035ec:	e0 48 20 00 	cp.w	r8,8192
800035f0:	5f 09       	sreq	r9
800035f2:	f5 e9 10 09 	or	r9,r10,r9
800035f6:	c0 71       	brne	80003604 <phy_tx+0x48>
800035f8:	e0 48 50 00 	cp.w	r8,20480
800035fc:	c0 40       	breq	80003604 <phy_tx+0x48>
800035fe:	e0 48 60 00 	cp.w	r8,24576
80003602:	c0 31       	brne	80003608 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80003604:	48 48       	lddpc	r8,80003614 <phy_tx+0x58>
80003606:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80003608:	2f fd       	sub	sp,-4
8000360a:	d8 02       	popm	pc
8000360c:	00 00       	add	r0,r0
8000360e:	0a f4       	st.b	--r5,r4
80003610:	80 00       	ld.sh	r0,r0[0x0]
80003612:	73 8c       	ld.w	r12,r9[0x60]
80003614:	00 00       	add	r0,r0
80003616:	0a e8       	st.h	--r5,r8

80003618 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80003618:	d4 01       	pushm	lr
8000361a:	20 2d       	sub	sp,8
	void * ptr = NULL;
8000361c:	30 08       	mov	r8,0
8000361e:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003620:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80003622:	1a 9a       	mov	r10,sp
80003624:	fa cb ff fc 	sub	r11,sp,-4
80003628:	f0 1f 00 05 	mcall	8000363c <get_idle_store_isr+0x24>
8000362c:	58 1c       	cp.w	r12,1
8000362e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80003632:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80003636:	2f ed       	sub	sp,-8
80003638:	d8 02       	popm	pc
8000363a:	00 00       	add	r0,r0
8000363c:	80 00       	ld.sh	r0,r0[0x0]
8000363e:	70 90       	ld.w	r0,r8[0x24]

80003640 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80003640:	eb cd 40 c0 	pushm	r6-r7,lr
80003644:	20 1d       	sub	sp,4
80003646:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80003648:	4b a8       	lddpc	r8,80003730 <phy_tx_func+0xf0>
8000364a:	70 08       	ld.w	r8,r8[0x0]
8000364c:	58 08       	cp.w	r8,0
8000364e:	c6 60       	breq	8000371a <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80003650:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003652:	30 08       	mov	r8,0
80003654:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80003656:	4b 88       	lddpc	r8,80003734 <phy_tx_func+0xf4>
80003658:	70 08       	ld.w	r8,r8[0x0]
8000365a:	58 18       	cp.w	r8,1
8000365c:	c2 60       	breq	800036a8 <phy_tx_func+0x68>
8000365e:	c0 43       	brcs	80003666 <phy_tx_func+0x26>
80003660:	58 28       	cp.w	r8,2
80003662:	c5 c1       	brne	8000371a <phy_tx_func+0xda>
80003664:	c5 58       	rjmp	8000370e <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80003666:	4b 38       	lddpc	r8,80003730 <phy_tx_func+0xf0>
80003668:	70 0c       	ld.w	r12,r8[0x0]
8000366a:	1a 9a       	mov	r10,sp
8000366c:	4b 3b       	lddpc	r11,80003738 <phy_tx_func+0xf8>
8000366e:	f0 1f 00 34 	mcall	8000373c <phy_tx_func+0xfc>
80003672:	58 1c       	cp.w	r12,1
80003674:	c1 41       	brne	8000369c <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80003676:	4b 18       	lddpc	r8,80003738 <phy_tx_func+0xf8>
80003678:	70 08       	ld.w	r8,r8[0x0]
8000367a:	90 08       	ld.sh	r8,r8[0x0]
8000367c:	10 9a       	mov	r10,r8
8000367e:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80003682:	4b 09       	lddpc	r9,80003740 <phy_tx_func+0x100>
80003684:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80003686:	5c 78       	castu.h	r8
80003688:	ea 18 ab cd 	orh	r8,0xabcd
8000368c:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
8000368e:	30 19       	mov	r9,1
80003690:	4a d8       	lddpc	r8,80003744 <phy_tx_func+0x104>
80003692:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80003694:	30 19       	mov	r9,1
80003696:	4a 88       	lddpc	r8,80003734 <phy_tx_func+0xf4>
80003698:	91 09       	st.w	r8[0x0],r9
8000369a:	c4 08       	rjmp	8000371a <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
8000369c:	e0 68 5a 5a 	mov	r8,23130
800036a0:	ea 18 ab cd 	orh	r8,0xabcd
800036a4:	8f 18       	st.w	r7[0x4],r8
800036a6:	c3 a8       	rjmp	8000371a <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
800036a8:	4a 7a       	lddpc	r10,80003744 <phy_tx_func+0x104>
800036aa:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
800036ac:	4a 39       	lddpc	r9,80003738 <phy_tx_func+0xf8>
800036ae:	72 09       	ld.w	r9,r9[0x0]
800036b0:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
800036b4:	b1 69       	lsl	r9,0x10
800036b6:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
800036b8:	2f f8       	sub	r8,-1
800036ba:	5c 58       	castu.b	r8
800036bc:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
800036be:	4a 1b       	lddpc	r11,80003740 <phy_tx_func+0x100>
800036c0:	96 0c       	ld.sh	r12,r11[0x0]
800036c2:	20 2c       	sub	r12,2
800036c4:	5c 8c       	casts.h	r12
800036c6:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
800036ca:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
800036cc:	30 0b       	mov	r11,0
800036ce:	f6 0a 19 00 	cp.h	r10,r11
800036d2:	e0 89 00 09 	brgt	800036e4 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
800036d6:	e8 19 00 ba 	orl	r9,0xba
800036da:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
800036dc:	30 09       	mov	r9,0
800036de:	49 68       	lddpc	r8,80003734 <phy_tx_func+0xf4>
800036e0:	91 09       	st.w	r8[0x0],r9
800036e2:	c1 c8       	rjmp	8000371a <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
800036e4:	49 5a       	lddpc	r10,80003738 <phy_tx_func+0xf8>
800036e6:	74 0a       	ld.w	r10,r10[0x0]
800036e8:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
800036ec:	14 49       	or	r9,r10
800036ee:	8f 19       	st.w	r7[0x4],r9
800036f0:	2f f8       	sub	r8,-1
800036f2:	49 59       	lddpc	r9,80003744 <phy_tx_func+0x104>
800036f4:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
800036f6:	20 2c       	sub	r12,2
800036f8:	49 28       	lddpc	r8,80003740 <phy_tx_func+0x100>
800036fa:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
800036fc:	30 08       	mov	r8,0
800036fe:	f0 0c 19 00 	cp.h	r12,r8
80003702:	e0 89 00 0c 	brgt	8000371a <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80003706:	30 29       	mov	r9,2
80003708:	48 b8       	lddpc	r8,80003734 <phy_tx_func+0xf4>
8000370a:	91 09       	st.w	r8[0x0],r9
8000370c:	c0 78       	rjmp	8000371a <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
8000370e:	fc 18 00 ba 	movh	r8,0xba
80003712:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80003714:	30 09       	mov	r9,0
80003716:	48 88       	lddpc	r8,80003734 <phy_tx_func+0xf4>
80003718:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
8000371a:	e0 68 5a 5a 	mov	r8,23130
8000371e:	ea 18 ab cd 	orh	r8,0xabcd
80003722:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80003724:	30 08       	mov	r8,0
80003726:	8f 38       	st.w	r7[0xc],r8
}
80003728:	2f fd       	sub	sp,-4
8000372a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000372e:	00 00       	add	r0,r0
80003730:	00 00       	add	r0,r0
80003732:	0a f4       	st.b	--r5,r4
80003734:	00 00       	add	r0,r0
80003736:	0a b4       	st.h	r5++,r4
80003738:	00 00       	add	r0,r0
8000373a:	0a c0       	st.b	r5++,r0
8000373c:	80 00       	ld.sh	r0,r0[0x0]
8000373e:	70 90       	ld.w	r0,r8[0x24]
80003740:	00 00       	add	r0,r0
80003742:	0a dc       	st.w	--r5,r12
80003744:	00 00       	add	r0,r0
80003746:	0a 94       	mov	r4,r5

80003748 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80003748:	d4 01       	pushm	lr
8000374a:	20 1d       	sub	sp,4
	void * ptr = NULL;
8000374c:	30 0a       	mov	r10,0
8000374e:	fa cb ff fc 	sub	r11,sp,-4
80003752:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80003754:	14 99       	mov	r9,r10
80003756:	1a 9b       	mov	r11,sp
80003758:	f0 1f 00 05 	mcall	8000376c <get_idle_store+0x24>
8000375c:	58 1c       	cp.w	r12,1
8000375e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80003762:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80003766:	2f fd       	sub	sp,-4
80003768:	d8 02       	popm	pc
8000376a:	00 00       	add	r0,r0
8000376c:	80 00       	ld.sh	r0,r0[0x0]
8000376e:	71 80       	ld.w	r0,r8[0x60]

80003770 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80003770:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80003772:	48 5b       	lddpc	r11,80003784 <phy_init+0x14>
80003774:	48 5c       	lddpc	r12,80003788 <phy_init+0x18>
80003776:	f0 1f 00 06 	mcall	8000378c <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
8000377a:	f0 1f 00 06 	mcall	80003790 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
8000377e:	f0 1f 00 06 	mcall	80003794 <phy_init+0x24>
	
}
80003782:	d8 02       	popm	pc
80003784:	80 00       	ld.sh	r0,r0[0x0]
80003786:	36 40       	mov	r0,100
80003788:	80 00       	ld.sh	r0,r0[0x0]
8000378a:	37 98       	mov	r8,121
8000378c:	80 00       	ld.sh	r0,r0[0x0]
8000378e:	47 ec       	lddsp	r12,sp[0x1f8]
80003790:	80 00       	ld.sh	r0,r0[0x0]
80003792:	48 00       	lddpc	r0,80003790 <phy_init+0x20>
80003794:	80 00       	ld.sh	r0,r0[0x0]
80003796:	51 b8       	stdsp	sp[0x6c],r8

80003798 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80003798:	eb cd 40 e0 	pushm	r5-r7,lr
8000379c:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
8000379e:	fe f8 0e 7a 	ld.w	r8,pc[3706]
800037a2:	70 08       	ld.w	r8,r8[0x0]
800037a4:	58 08       	cp.w	r8,0
800037a6:	e0 80 01 08 	breq	800039b6 <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
800037aa:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
800037ac:	fe f8 0e 70 	ld.w	r8,pc[3696]
800037b0:	70 09       	ld.w	r9,r8[0x0]
800037b2:	2f f9       	sub	r9,-1
800037b4:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
800037b6:	fe f8 0e 6a 	ld.w	r8,pc[3690]
800037ba:	70 08       	ld.w	r8,r8[0x0]
800037bc:	58 18       	cp.w	r8,1
800037be:	e0 80 00 85 	breq	800038c8 <phy_rx_func+0x130>
800037c2:	c0 73       	brcs	800037d0 <phy_rx_func+0x38>
800037c4:	58 28       	cp.w	r8,2
800037c6:	c5 c0       	breq	8000387e <phy_rx_func+0xe6>
800037c8:	58 38       	cp.w	r8,3
800037ca:	e0 81 00 f6 	brne	800039b6 <phy_rx_func+0x21e>
800037ce:	cd 58       	rjmp	80003978 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
800037d0:	e0 6a 5a 5a 	mov	r10,23130
800037d4:	ea 1a ab cd 	orh	r10,0xabcd
800037d8:	14 36       	cp.w	r6,r10
800037da:	e0 80 00 ee 	breq	800039b6 <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
800037de:	ec 08 16 10 	lsr	r8,r6,0x10
800037e2:	e0 48 ab cd 	cp.w	r8,43981
800037e6:	e0 81 00 e8 	brne	800039b6 <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
800037ea:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
800037ee:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
800037f2:	20 28       	sub	r8,2
800037f4:	fe f9 0e 30 	ld.w	r9,pc[3632]
800037f8:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
800037fa:	30 09       	mov	r9,0
800037fc:	f2 08 19 00 	cp.h	r8,r9
80003800:	e0 8a 00 db 	brle	800039b6 <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80003804:	fe f8 0e 24 	ld.w	r8,pc[3620]
80003808:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
8000380a:	fe f8 0e 22 	ld.w	r8,pc[3618]
8000380e:	70 0c       	ld.w	r12,r8[0x0]
80003810:	f0 1f 03 88 	mcall	80004630 <phy_rx_func+0xe98>
80003814:	fe f8 0e 20 	ld.w	r8,pc[3616]
80003818:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
8000381a:	58 0c       	cp.w	r12,0
8000381c:	e0 80 00 cd 	breq	800039b6 <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80003820:	fe f8 0e 08 	ld.w	r8,pc[3592]
80003824:	90 09       	ld.sh	r9,r8[0x0]
80003826:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
8000382a:	2f f9       	sub	r9,-1
8000382c:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
8000382e:	fe fa 0e 06 	ld.w	r10,pc[3590]
80003832:	74 0a       	ld.w	r10,r10[0x0]
80003834:	fe fb 0d e8 	ld.w	r11,pc[3560]
80003838:	76 0b       	ld.w	r11,r11[0x0]
8000383a:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
8000383e:	2f f9       	sub	r9,-1
80003840:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80003842:	e2 16 0f 00 	andl	r6,0xf00,COH
80003846:	e0 46 01 00 	cp.w	r6,256
8000384a:	c0 c0       	breq	80003862 <phy_rx_func+0xca>
8000384c:	e0 8b 00 05 	brhi	80003856 <phy_rx_func+0xbe>
80003850:	58 06       	cp.w	r6,0
80003852:	c0 80       	breq	80003862 <phy_rx_func+0xca>
80003854:	c0 c8       	rjmp	8000386c <phy_rx_func+0xd4>
80003856:	e0 46 02 00 	cp.w	r6,512
8000385a:	c0 40       	breq	80003862 <phy_rx_func+0xca>
8000385c:	e0 46 03 00 	cp.w	r6,768
80003860:	c0 61       	brne	8000386c <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80003862:	30 29       	mov	r9,2
80003864:	fe f8 0d bc 	ld.w	r8,pc[3516]
80003868:	91 09       	st.w	r8[0x0],r9
8000386a:	ca 68       	rjmp	800039b6 <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
8000386c:	fe f8 0d c0 	ld.w	r8,pc[3520]
80003870:	70 0c       	ld.w	r12,r8[0x0]
80003872:	fe f8 0d c2 	ld.w	r8,pc[3522]
80003876:	70 0b       	ld.w	r11,r8[0x0]
80003878:	f0 1f 03 70 	mcall	80004638 <phy_rx_func+0xea0>
8000387c:	c9 d8       	rjmp	800039b6 <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
8000387e:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80003882:	b1 86       	lsr	r6,0x10
80003884:	14 06       	add	r6,r10
80003886:	fe f8 0d b6 	ld.w	r8,pc[3510]
8000388a:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
8000388c:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80003890:	90 09       	ld.sh	r9,r8[0x0]
80003892:	fe fb 0d a2 	ld.w	r11,pc[3490]
80003896:	76 0b       	ld.w	r11,r11[0x0]
80003898:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
8000389c:	2f f9       	sub	r9,-1
8000389e:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
800038a0:	fe f9 0d 84 	ld.w	r9,pc[3460]
800038a4:	92 08       	ld.sh	r8,r9[0x0]
800038a6:	20 28       	sub	r8,2
800038a8:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
800038aa:	30 09       	mov	r9,0
800038ac:	f2 08 19 00 	cp.h	r8,r9
800038b0:	e0 8a 00 07 	brle	800038be <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
800038b4:	30 19       	mov	r9,1
800038b6:	fe f8 0d 6a 	ld.w	r8,pc[3434]
800038ba:	91 09       	st.w	r8[0x0],r9
800038bc:	c7 d8       	rjmp	800039b6 <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
800038be:	30 39       	mov	r9,3
800038c0:	fe f8 0d 60 	ld.w	r8,pc[3424]
800038c4:	91 09       	st.w	r8[0x0],r9
800038c6:	c7 88       	rjmp	800039b6 <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
800038c8:	ec 0a 14 10 	asr	r10,r6,0x10
800038cc:	fe f8 0d 70 	ld.w	r8,pc[3440]
800038d0:	90 09       	ld.sh	r9,r8[0x0]
800038d2:	14 09       	add	r9,r10
800038d4:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800038d6:	fe f9 0d 52 	ld.w	r9,pc[3410]
800038da:	92 08       	ld.sh	r8,r9[0x0]
800038dc:	fe fb 0d 58 	ld.w	r11,pc[3416]
800038e0:	76 0b       	ld.w	r11,r11[0x0]
800038e2:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
800038e6:	2f f8       	sub	r8,-1
800038e8:	5c 88       	casts.h	r8
800038ea:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
800038ec:	fe fa 0d 38 	ld.w	r10,pc[3384]
800038f0:	94 09       	ld.sh	r9,r10[0x0]
800038f2:	20 29       	sub	r9,2
800038f4:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
800038f6:	30 0a       	mov	r10,0
800038f8:	f4 09 19 00 	cp.h	r9,r10
800038fc:	e0 89 00 20 	brgt	8000393c <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80003900:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80003904:	e0 46 00 ba 	cp.w	r6,186
80003908:	c0 d1       	brne	80003922 <phy_rx_func+0x18a>
8000390a:	fe f8 0d 32 	ld.w	r8,pc[3378]
8000390e:	90 09       	ld.sh	r9,r8[0x0]
80003910:	f4 09 19 00 	cp.h	r9,r10
80003914:	c0 71       	brne	80003922 <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80003916:	fe f8 0d 1e 	ld.w	r8,pc[3358]
8000391a:	70 0c       	ld.w	r12,r8[0x0]
8000391c:	f0 1f 03 49 	mcall	80004640 <phy_rx_func+0xea8>
80003920:	c0 98       	rjmp	80003932 <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80003922:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80003926:	70 0c       	ld.w	r12,r8[0x0]
80003928:	fe f8 0d 0c 	ld.w	r8,pc[3340]
8000392c:	70 0b       	ld.w	r11,r8[0x0]
8000392e:	f0 1f 03 43 	mcall	80004638 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80003932:	30 09       	mov	r9,0
80003934:	fe f8 0c ec 	ld.w	r8,pc[3308]
80003938:	91 09       	st.w	r8[0x0],r9
8000393a:	c3 e8       	rjmp	800039b6 <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
8000393c:	5c 86       	casts.h	r6
8000393e:	fe f9 0c fe 	ld.w	r9,pc[3326]
80003942:	92 0a       	ld.sh	r10,r9[0x0]
80003944:	0c 0a       	add	r10,r6
80003946:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003948:	fe f9 0c ec 	ld.w	r9,pc[3308]
8000394c:	72 09       	ld.w	r9,r9[0x0]
8000394e:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80003952:	2f f8       	sub	r8,-1
80003954:	fe f9 0c d4 	ld.w	r9,pc[3284]
80003958:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
8000395a:	fe f9 0c ca 	ld.w	r9,pc[3274]
8000395e:	92 08       	ld.sh	r8,r9[0x0]
80003960:	20 28       	sub	r8,2
80003962:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80003964:	30 09       	mov	r9,0
80003966:	f2 08 19 00 	cp.h	r8,r9
8000396a:	e0 89 00 26 	brgt	800039b6 <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
8000396e:	30 39       	mov	r9,3
80003970:	fe f8 0c b0 	ld.w	r8,pc[3248]
80003974:	91 09       	st.w	r8[0x0],r9
80003976:	c2 08       	rjmp	800039b6 <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80003978:	e6 16 00 ff 	andh	r6,0xff,COH
8000397c:	fc 19 00 ba 	movh	r9,0xba
80003980:	12 36       	cp.w	r6,r9
80003982:	c0 e1       	brne	8000399e <phy_rx_func+0x206>
80003984:	fe f8 0c b8 	ld.w	r8,pc[3256]
80003988:	90 09       	ld.sh	r9,r8[0x0]
8000398a:	30 08       	mov	r8,0
8000398c:	f0 09 19 00 	cp.h	r9,r8
80003990:	c0 71       	brne	8000399e <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80003992:	fe f8 0c a2 	ld.w	r8,pc[3234]
80003996:	70 0c       	ld.w	r12,r8[0x0]
80003998:	f0 1f 03 2a 	mcall	80004640 <phy_rx_func+0xea8>
8000399c:	c0 98       	rjmp	800039ae <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
8000399e:	fe f8 0c 8e 	ld.w	r8,pc[3214]
800039a2:	70 0c       	ld.w	r12,r8[0x0]
800039a4:	fe f8 0c 90 	ld.w	r8,pc[3216]
800039a8:	70 0b       	ld.w	r11,r8[0x0]
800039aa:	f0 1f 03 24 	mcall	80004638 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
800039ae:	30 09       	mov	r9,0
800039b0:	fe f8 0c 70 	ld.w	r8,pc[3184]
800039b4:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
800039b6:	fe f8 0c 8e 	ld.w	r8,pc[3214]
800039ba:	11 89       	ld.ub	r9,r8[0x0]
800039bc:	30 08       	mov	r8,0
800039be:	f0 09 18 00 	cp.b	r9,r8
800039c2:	c1 31       	brne	800039e8 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
800039c4:	fe f6 0c 84 	ld.w	r6,pc[3204]
800039c8:	6c 0c       	ld.w	r12,r6[0x0]
800039ca:	f0 1f 03 1a 	mcall	80004630 <phy_rx_func+0xe98>
800039ce:	fe f8 0c 7e 	ld.w	r8,pc[3198]
800039d2:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
800039d4:	6c 0c       	ld.w	r12,r6[0x0]
800039d6:	f0 1f 03 17 	mcall	80004630 <phy_rx_func+0xe98>
800039da:	fe f8 0c 76 	ld.w	r8,pc[3190]
800039de:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
800039e0:	30 19       	mov	r9,1
800039e2:	fe f8 0c 62 	ld.w	r8,pc[3170]
800039e6:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
800039e8:	fe f8 0c 6c 	ld.w	r8,pc[3180]
800039ec:	70 08       	ld.w	r8,r8[0x0]
800039ee:	58 28       	cp.w	r8,2
800039f0:	e0 80 01 98 	breq	80003d20 <phy_rx_func+0x588>
800039f4:	e0 8b 00 06 	brhi	80003a00 <phy_rx_func+0x268>
800039f8:	58 08       	cp.w	r8,0
800039fa:	c0 b0       	breq	80003a10 <phy_rx_func+0x278>
800039fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003a00:	58 38       	cp.w	r8,3
80003a02:	e0 80 05 c5 	breq	8000458c <phy_rx_func+0xdf4>
80003a06:	58 48       	cp.w	r8,4
80003a08:	e0 81 06 05 	brne	80004612 <phy_rx_func+0xe7a>
80003a0c:	e0 8f 02 4b 	bral	80003ea2 <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80003a10:	6e 28       	ld.w	r8,r7[0x8]
80003a12:	e0 6a 5a 5a 	mov	r10,23130
80003a16:	ea 1a ab cd 	orh	r10,0xabcd
80003a1a:	14 38       	cp.w	r8,r10
80003a1c:	c0 71       	brne	80003a2a <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
80003a1e:	30 09       	mov	r9,0
80003a20:	fe f8 0c 38 	ld.w	r8,pc[3128]
80003a24:	91 09       	st.w	r8[0x0],r9
80003a26:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80003a2a:	10 99       	mov	r9,r8
80003a2c:	e0 19 00 00 	andl	r9,0x0
80003a30:	fc 1a ab cd 	movh	r10,0xabcd
80003a34:	14 39       	cp.w	r9,r10
80003a36:	e0 81 05 ee 	brne	80004612 <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80003a3a:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80003a3e:	fe f9 0c 1e 	ld.w	r9,pc[3102]
80003a42:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80003a44:	6e 29       	ld.w	r9,r7[0x8]
80003a46:	e2 19 f0 00 	andl	r9,0xf000,COH
80003a4a:	e0 49 c0 00 	cp.w	r9,49152
80003a4e:	e0 81 00 ce 	brne	80003bea <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
80003a52:	30 1a       	mov	r10,1
80003a54:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80003a58:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
80003a5a:	fe f9 0b f6 	ld.w	r9,pc[3062]
80003a5e:	72 09       	ld.w	r9,r9[0x0]
80003a60:	58 09       	cp.w	r9,0
80003a62:	c0 71       	brne	80003a70 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003a64:	fe fc 0c 00 	ld.w	r12,pc[3072]
80003a68:	f0 1f 03 00 	mcall	80004668 <phy_rx_func+0xed0>
80003a6c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80003a70:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80003a74:	fe f9 0b f8 	ld.w	r9,pc[3064]
80003a78:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80003a7a:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003a7e:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
80003a82:	fe fa 0b ee 	ld.w	r10,pc[3054]
80003a86:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80003a88:	13 89       	ld.ub	r9,r9[0x0]
80003a8a:	37 fa       	mov	r10,127
80003a8c:	f4 09 18 00 	cp.b	r9,r10
80003a90:	c6 d0       	breq	80003b6a <phy_rx_func+0x3d2>
80003a92:	e0 8b 00 0c 	brhi	80003aaa <phy_rx_func+0x312>
80003a96:	31 2a       	mov	r10,18
80003a98:	f4 09 18 00 	cp.b	r9,r10
80003a9c:	c4 20       	breq	80003b20 <phy_rx_func+0x388>
80003a9e:	31 3a       	mov	r10,19
80003aa0:	f4 09 18 00 	cp.b	r9,r10
80003aa4:	e0 81 00 83 	brne	80003baa <phy_rx_func+0x412>
80003aa8:	c5 b8       	rjmp	80003b5e <phy_rx_func+0x3c6>
80003aaa:	2f 09       	sub	r9,-16
80003aac:	30 1a       	mov	r10,1
80003aae:	f4 09 18 00 	cp.b	r9,r10
80003ab2:	e0 8b 00 7c 	brhi	80003baa <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003ab6:	ef 38 00 0e 	ld.ub	r8,r7[14]
80003aba:	e2 18 00 f0 	andl	r8,0xf0,COH
80003abe:	59 08       	cp.w	r8,16
80003ac0:	c0 71       	brne	80003ace <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
80003ac2:	30 19       	mov	r9,1
80003ac4:	fe f8 0b 94 	ld.w	r8,pc[2964]
80003ac8:	91 09       	st.w	r8[0x0],r9
80003aca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80003ace:	e0 48 00 20 	cp.w	r8,32
80003ad2:	c2 11       	brne	80003b14 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80003ad4:	30 a9       	mov	r9,10
80003ad6:	fe f8 0b 82 	ld.w	r8,pc[2946]
80003ada:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003adc:	fe f6 0b 98 	ld.w	r6,pc[2968]
80003ae0:	6c 08       	ld.w	r8,r6[0x0]
80003ae2:	f0 0a 11 ff 	rsub	r10,r8,-1
80003ae6:	fe f7 0b 6a 	ld.w	r7,pc[2922]
80003aea:	2f f8       	sub	r8,-1
80003aec:	6e 0c       	ld.w	r12,r7[0x0]
80003aee:	f4 ca fe 00 	sub	r10,r10,-512
80003af2:	30 0b       	mov	r11,0
80003af4:	10 0c       	add	r12,r8
80003af6:	f0 1f 02 e1 	mcall	80004678 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80003afa:	30 08       	mov	r8,0
80003afc:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80003afe:	6e 0c       	ld.w	r12,r7[0x0]
80003b00:	f0 1f 02 df 	mcall	8000467c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003b04:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003b08:	70 0c       	ld.w	r12,r8[0x0]
80003b0a:	f0 1f 02 ca 	mcall	80004630 <phy_rx_func+0xe98>
80003b0e:	8f 0c       	st.w	r7[0x0],r12
80003b10:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003b14:	30 09       	mov	r9,0
80003b16:	fe f8 0b 42 	ld.w	r8,pc[2882]
80003b1a:	91 09       	st.w	r8[0x0],r9
80003b1c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003b20:	20 48       	sub	r8,4
80003b22:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80003b26:	93 08       	st.w	r9[0x0],r8
80003b28:	58 08       	cp.w	r8,0
80003b2a:	e0 80 05 74 	breq	80004612 <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003b2e:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80003b32:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003b36:	fe f8 0b 4a 	ld.w	r8,pc[2890]
80003b3a:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003b3c:	8e 69       	ld.sh	r9,r7[0xc]
80003b3e:	fe f8 0b 46 	ld.w	r8,pc[2886]
80003b42:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80003b44:	8e 79       	ld.sh	r9,r7[0xe]
80003b46:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003b48:	f0 1f 02 d0 	mcall	80004688 <phy_rx_func+0xef0>
80003b4c:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80003b50:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003b52:	30 49       	mov	r9,4
80003b54:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003b58:	91 09       	st.w	r8[0x0],r9
80003b5a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80003b5e:	30 09       	mov	r9,0
80003b60:	fe f8 0a f8 	ld.w	r8,pc[2808]
80003b64:	91 09       	st.w	r8[0x0],r9
80003b66:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003b6a:	20 48       	sub	r8,4
80003b6c:	fe f9 0a f0 	ld.w	r9,pc[2800]
80003b70:	93 08       	st.w	r9[0x0],r8
80003b72:	58 08       	cp.w	r8,0
80003b74:	e0 80 05 4f 	breq	80004612 <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003b78:	fe f8 0b 14 	ld.w	r8,pc[2836]
80003b7c:	70 09       	ld.w	r9,r8[0x0]
80003b7e:	8e 7b       	ld.sh	r11,r7[0xe]
80003b80:	fe fa 0b 10 	ld.w	r10,pc[2832]
80003b84:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003b88:	2f f9       	sub	r9,-1
80003b8a:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003b8c:	fe f8 0a e4 	ld.w	r8,pc[2788]
80003b90:	70 09       	ld.w	r9,r8[0x0]
80003b92:	20 29       	sub	r9,2
80003b94:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003b96:	30 29       	mov	r9,2
80003b98:	fe f8 0a c0 	ld.w	r8,pc[2752]
80003b9c:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003b9e:	30 39       	mov	r9,3
80003ba0:	fe f8 0a b4 	ld.w	r8,pc[2740]
80003ba4:	91 09       	st.w	r8[0x0],r9
80003ba6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003baa:	30 3a       	mov	r10,3
80003bac:	fe f9 0a ac 	ld.w	r9,pc[2732]
80003bb0:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003bb2:	6e 2a       	ld.w	r10,r7[0x8]
80003bb4:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003bb8:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003bba:	6e 3a       	ld.w	r10,r7[0xc]
80003bbc:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
80003bbe:	59 48       	cp.w	r8,20
80003bc0:	c0 61       	brne	80003bcc <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003bc2:	31 89       	mov	r9,24
80003bc4:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003bc8:	91 09       	st.w	r8[0x0],r9
80003bca:	c0 a8       	rjmp	80003bde <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003bcc:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003bd0:	70 08       	ld.w	r8,r8[0x0]
80003bd2:	59 08       	cp.w	r8,16
80003bd4:	c0 51       	brne	80003bde <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003bd6:	31 09       	mov	r9,16
80003bd8:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003bdc:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003bde:	30 49       	mov	r9,4
80003be0:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003be4:	91 09       	st.w	r8[0x0],r9
80003be6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80003bea:	e0 49 10 00 	cp.w	r9,4096
80003bee:	5f 1a       	srne	r10
80003bf0:	e0 49 20 00 	cp.w	r9,8192
80003bf4:	5f 19       	srne	r9
80003bf6:	f5 e9 00 09 	and	r9,r10,r9
80003bfa:	e0 81 05 0c 	brne	80004612 <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
80003bfe:	fe fa 0a 9a 	ld.w	r10,pc[2714]
80003c02:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003c04:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003c08:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
80003c0a:	fe fa 0a 62 	ld.w	r10,pc[2658]
80003c0e:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
80003c10:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80003c14:	72 09       	ld.w	r9,r9[0x0]
80003c16:	58 09       	cp.w	r9,0
80003c18:	c0 71       	brne	80003c26 <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003c1a:	fe fc 0a 4a 	ld.w	r12,pc[2634]
80003c1e:	f0 1f 02 93 	mcall	80004668 <phy_rx_func+0xed0>
80003c22:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003c26:	6e 2a       	ld.w	r10,r7[0x8]
80003c28:	e2 1a 0f 00 	andl	r10,0xf00,COH
80003c2c:	58 1a       	cp.w	r10,1
80003c2e:	e0 8b 00 4d 	brhi	80003cc8 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
80003c32:	20 48       	sub	r8,4
80003c34:	fe f9 0a 28 	ld.w	r9,pc[2600]
80003c38:	93 08       	st.w	r9[0x0],r8
80003c3a:	58 08       	cp.w	r8,0
80003c3c:	e0 80 04 eb 	breq	80004612 <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
80003c40:	8e 68       	ld.sh	r8,r7[0xc]
80003c42:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80003c46:	fe f9 0a 5a 	ld.w	r9,pc[2650]
80003c4a:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
80003c4c:	30 09       	mov	r9,0
80003c4e:	f2 08 19 00 	cp.h	r8,r9
80003c52:	c0 70       	breq	80003c60 <phy_rx_func+0x4c8>
80003c54:	30 19       	mov	r9,1
80003c56:	f2 08 19 00 	cp.h	r8,r9
80003c5a:	e0 81 04 dc 	brne	80004612 <phy_rx_func+0xe7a>
80003c5e:	c2 68       	rjmp	80003caa <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003c60:	fe f8 0a 44 	ld.w	r8,pc[2628]
80003c64:	70 0a       	ld.w	r10,r8[0x0]
80003c66:	fe f9 09 e6 	ld.w	r9,pc[2534]
80003c6a:	72 09       	ld.w	r9,r9[0x0]
80003c6c:	8e 7b       	ld.sh	r11,r7[0xe]
80003c6e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
80003c72:	70 09       	ld.w	r9,r8[0x0]
80003c74:	2f f9       	sub	r9,-1
80003c76:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003c78:	e0 49 00 ff 	cp.w	r9,255
80003c7c:	e0 88 00 11 	brls	80003c9e <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
80003c80:	30 09       	mov	r9,0
80003c82:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
80003c84:	fe f7 09 c8 	ld.w	r7,pc[2504]
80003c88:	6e 0c       	ld.w	r12,r7[0x0]
80003c8a:	f0 1f 02 7d 	mcall	8000467c <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
80003c8e:	fe f8 09 ba 	ld.w	r8,pc[2490]
80003c92:	70 0c       	ld.w	r12,r8[0x0]
80003c94:	f0 1f 02 67 	mcall	80004630 <phy_rx_func+0xe98>
80003c98:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
80003c9a:	e0 80 04 bc 	breq	80004612 <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
80003c9e:	30 29       	mov	r9,2
80003ca0:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003ca4:	91 09       	st.w	r8[0x0],r9
80003ca6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003caa:	8e 79       	ld.sh	r9,r7[0xe]
80003cac:	30 38       	mov	r8,3
80003cae:	f0 09 19 00 	cp.h	r9,r8
80003cb2:	c0 51       	brne	80003cbc <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003cb4:	30 19       	mov	r9,1
80003cb6:	fe f8 09 f2 	ld.w	r8,pc[2546]
80003cba:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
80003cbc:	30 29       	mov	r9,2
80003cbe:	fe f8 09 96 	ld.w	r8,pc[2454]
80003cc2:	91 09       	st.w	r8[0x0],r9
80003cc4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003cc8:	58 18       	cp.w	r8,1
80003cca:	e0 88 04 a4 	brls	80004612 <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003cce:	fe f8 09 d6 	ld.w	r8,pc[2518]
80003cd2:	70 0a       	ld.w	r10,r8[0x0]
80003cd4:	6e 3b       	ld.w	r11,r7[0xc]
80003cd6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003cda:	70 09       	ld.w	r9,r8[0x0]
80003cdc:	2f f9       	sub	r9,-1
80003cde:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003ce0:	e0 49 00 ff 	cp.w	r9,255
80003ce4:	e0 88 00 11 	brls	80003d06 <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003ce8:	30 09       	mov	r9,0
80003cea:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003cec:	fe f7 09 60 	ld.w	r7,pc[2400]
80003cf0:	6e 0c       	ld.w	r12,r7[0x0]
80003cf2:	f0 1f 02 63 	mcall	8000467c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003cf6:	fe f8 09 52 	ld.w	r8,pc[2386]
80003cfa:	70 0c       	ld.w	r12,r8[0x0]
80003cfc:	f0 1f 02 4d 	mcall	80004630 <phy_rx_func+0xe98>
80003d00:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003d02:	e0 80 04 88 	breq	80004612 <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003d06:	fe f9 09 56 	ld.w	r9,pc[2390]
80003d0a:	72 08       	ld.w	r8,r9[0x0]
80003d0c:	20 28       	sub	r8,2
80003d0e:	93 08       	st.w	r9[0x0],r8
80003d10:	e0 80 04 81 	breq	80004612 <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80003d14:	30 29       	mov	r9,2
80003d16:	fe f8 09 3e 	ld.w	r8,pc[2366]
80003d1a:	91 09       	st.w	r8[0x0],r9
80003d1c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003d20:	fe f8 09 84 	ld.w	r8,pc[2436]
80003d24:	70 0a       	ld.w	r10,r8[0x0]
80003d26:	fe f9 09 26 	ld.w	r9,pc[2342]
80003d2a:	72 09       	ld.w	r9,r9[0x0]
80003d2c:	8e 4b       	ld.sh	r11,r7[0x8]
80003d2e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
80003d32:	70 09       	ld.w	r9,r8[0x0]
80003d34:	2f f9       	sub	r9,-1
80003d36:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003d38:	e0 49 00 ff 	cp.w	r9,255
80003d3c:	e0 88 00 16 	brls	80003d68 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
80003d40:	30 09       	mov	r9,0
80003d42:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003d44:	fe f6 09 08 	ld.w	r6,pc[2312]
80003d48:	6c 0c       	ld.w	r12,r6[0x0]
80003d4a:	f0 1f 02 4d 	mcall	8000467c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003d4e:	fe f8 08 fa 	ld.w	r8,pc[2298]
80003d52:	70 0c       	ld.w	r12,r8[0x0]
80003d54:	f0 1f 02 37 	mcall	80004630 <phy_rx_func+0xe98>
80003d58:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003d5a:	c0 71       	brne	80003d68 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
80003d5c:	30 09       	mov	r9,0
80003d5e:	fe f8 08 f6 	ld.w	r8,pc[2294]
80003d62:	91 09       	st.w	r8[0x0],r9
80003d64:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
80003d68:	fe f9 08 f4 	ld.w	r9,pc[2292]
80003d6c:	72 08       	ld.w	r8,r9[0x0]
80003d6e:	20 28       	sub	r8,2
80003d70:	93 08       	st.w	r9[0x0],r8
80003d72:	c0 71       	brne	80003d80 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
80003d74:	30 09       	mov	r9,0
80003d76:	fe f8 08 de 	ld.w	r8,pc[2270]
80003d7a:	91 09       	st.w	r8[0x0],r9
80003d7c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003d80:	fe f8 09 24 	ld.w	r8,pc[2340]
80003d84:	70 0a       	ld.w	r10,r8[0x0]
80003d86:	fe f9 08 c6 	ld.w	r9,pc[2246]
80003d8a:	72 09       	ld.w	r9,r9[0x0]
80003d8c:	8e 5b       	ld.sh	r11,r7[0xa]
80003d8e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003d92:	70 09       	ld.w	r9,r8[0x0]
80003d94:	2f f9       	sub	r9,-1
80003d96:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003d98:	e0 49 00 ff 	cp.w	r9,255
80003d9c:	e0 88 00 16 	brls	80003dc8 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003da0:	30 09       	mov	r9,0
80003da2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003da4:	fe f6 08 a8 	ld.w	r6,pc[2216]
80003da8:	6c 0c       	ld.w	r12,r6[0x0]
80003daa:	f0 1f 02 35 	mcall	8000467c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003dae:	fe f8 08 9a 	ld.w	r8,pc[2202]
80003db2:	70 0c       	ld.w	r12,r8[0x0]
80003db4:	f0 1f 02 1f 	mcall	80004630 <phy_rx_func+0xe98>
80003db8:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003dba:	c0 71       	brne	80003dc8 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003dbc:	30 09       	mov	r9,0
80003dbe:	fe f8 08 96 	ld.w	r8,pc[2198]
80003dc2:	91 09       	st.w	r8[0x0],r9
80003dc4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003dc8:	fe f9 08 94 	ld.w	r9,pc[2196]
80003dcc:	72 08       	ld.w	r8,r9[0x0]
80003dce:	20 28       	sub	r8,2
80003dd0:	93 08       	st.w	r9[0x0],r8
80003dd2:	c0 71       	brne	80003de0 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003dd4:	30 09       	mov	r9,0
80003dd6:	fe f8 08 7e 	ld.w	r8,pc[2174]
80003dda:	91 09       	st.w	r8[0x0],r9
80003ddc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003de0:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003de4:	70 0a       	ld.w	r10,r8[0x0]
80003de6:	fe f9 08 66 	ld.w	r9,pc[2150]
80003dea:	72 09       	ld.w	r9,r9[0x0]
80003dec:	8e 6b       	ld.sh	r11,r7[0xc]
80003dee:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003df2:	70 09       	ld.w	r9,r8[0x0]
80003df4:	2f f9       	sub	r9,-1
80003df6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003df8:	e0 49 00 ff 	cp.w	r9,255
80003dfc:	e0 88 00 16 	brls	80003e28 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003e00:	30 09       	mov	r9,0
80003e02:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003e04:	fe f6 08 48 	ld.w	r6,pc[2120]
80003e08:	6c 0c       	ld.w	r12,r6[0x0]
80003e0a:	f0 1f 02 1d 	mcall	8000467c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003e0e:	fe f8 08 3a 	ld.w	r8,pc[2106]
80003e12:	70 0c       	ld.w	r12,r8[0x0]
80003e14:	f0 1f 02 07 	mcall	80004630 <phy_rx_func+0xe98>
80003e18:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003e1a:	c0 71       	brne	80003e28 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
80003e1c:	30 09       	mov	r9,0
80003e1e:	fe f8 08 36 	ld.w	r8,pc[2102]
80003e22:	91 09       	st.w	r8[0x0],r9
80003e24:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003e28:	fe f9 08 34 	ld.w	r9,pc[2100]
80003e2c:	72 08       	ld.w	r8,r9[0x0]
80003e2e:	20 28       	sub	r8,2
80003e30:	93 08       	st.w	r9[0x0],r8
80003e32:	c0 71       	brne	80003e40 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
80003e34:	30 09       	mov	r9,0
80003e36:	fe f8 08 1e 	ld.w	r8,pc[2078]
80003e3a:	91 09       	st.w	r8[0x0],r9
80003e3c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003e40:	fe f8 08 64 	ld.w	r8,pc[2148]
80003e44:	70 0a       	ld.w	r10,r8[0x0]
80003e46:	fe f9 08 06 	ld.w	r9,pc[2054]
80003e4a:	72 09       	ld.w	r9,r9[0x0]
80003e4c:	8e 7b       	ld.sh	r11,r7[0xe]
80003e4e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003e52:	70 09       	ld.w	r9,r8[0x0]
80003e54:	2f f9       	sub	r9,-1
80003e56:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003e58:	e0 49 00 ff 	cp.w	r9,255
80003e5c:	e0 88 00 16 	brls	80003e88 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
80003e60:	30 09       	mov	r9,0
80003e62:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003e64:	fe f7 07 e8 	ld.w	r7,pc[2024]
80003e68:	6e 0c       	ld.w	r12,r7[0x0]
80003e6a:	f0 1f 02 05 	mcall	8000467c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003e6e:	fe f8 07 da 	ld.w	r8,pc[2010]
80003e72:	70 0c       	ld.w	r12,r8[0x0]
80003e74:	f0 1f 01 ef 	mcall	80004630 <phy_rx_func+0xe98>
80003e78:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003e7a:	c0 71       	brne	80003e88 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
80003e7c:	30 09       	mov	r9,0
80003e7e:	fe f8 07 d6 	ld.w	r8,pc[2006]
80003e82:	91 09       	st.w	r8[0x0],r9
80003e84:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003e88:	fe f9 07 d4 	ld.w	r9,pc[2004]
80003e8c:	72 08       	ld.w	r8,r9[0x0]
80003e8e:	20 28       	sub	r8,2
80003e90:	93 08       	st.w	r9[0x0],r8
80003e92:	e0 81 03 c0 	brne	80004612 <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
80003e96:	30 09       	mov	r9,0
80003e98:	fe f8 07 bc 	ld.w	r8,pc[1980]
80003e9c:	91 09       	st.w	r8[0x0],r9
80003e9e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003ea2:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003ea6:	11 89       	ld.ub	r9,r8[0x0]
80003ea8:	31 28       	mov	r8,18
80003eaa:	f0 09 18 00 	cp.b	r9,r8
80003eae:	e0 81 01 4c 	brne	80004146 <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
80003eb2:	ef 39 00 09 	ld.ub	r9,r7[9]
80003eb6:	fe f8 07 b6 	ld.w	r8,pc[1974]
80003eba:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003ebc:	11 89       	ld.ub	r9,r8[0x0]
80003ebe:	3f 28       	mov	r8,-14
80003ec0:	f0 09 18 00 	cp.b	r9,r8
80003ec4:	e0 81 01 3b 	brne	8000413a <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003ec8:	30 19       	mov	r9,1
80003eca:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003ece:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003ed0:	6e 29       	ld.w	r9,r7[0x8]
80003ed2:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003ed6:	fe f8 07 86 	ld.w	r8,pc[1926]
80003eda:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003edc:	8e 59       	ld.sh	r9,r7[0xa]
80003ede:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003ee2:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003ee4:	8e 69       	ld.sh	r9,r7[0xc]
80003ee6:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003ee8:	8e 79       	ld.sh	r9,r7[0xe]
80003eea:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003eec:	fe f8 07 88 	ld.w	r8,pc[1928]
80003ef0:	fe f9 07 60 	ld.w	r9,pc[1888]
80003ef4:	72 0a       	ld.w	r10,r9[0x0]
80003ef6:	70 09       	ld.w	r9,r8[0x0]
80003ef8:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003efc:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003f00:	70 09       	ld.w	r9,r8[0x0]
80003f02:	2f f9       	sub	r9,-1
80003f04:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f06:	e0 49 01 ff 	cp.w	r9,511
80003f0a:	e0 88 00 16 	brls	80003f36 <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
80003f0e:	30 09       	mov	r9,0
80003f10:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003f12:	fe f6 07 3e 	ld.w	r6,pc[1854]
80003f16:	6c 0c       	ld.w	r12,r6[0x0]
80003f18:	f0 1f 01 d9 	mcall	8000467c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003f1c:	fe f8 07 2c 	ld.w	r8,pc[1836]
80003f20:	70 0c       	ld.w	r12,r8[0x0]
80003f22:	f0 1f 01 c4 	mcall	80004630 <phy_rx_func+0xe98>
80003f26:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003f28:	c0 71       	brne	80003f36 <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
80003f2a:	30 09       	mov	r9,0
80003f2c:	fe f8 07 28 	ld.w	r8,pc[1832]
80003f30:	91 09       	st.w	r8[0x0],r9
80003f32:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003f36:	fe f9 07 26 	ld.w	r9,pc[1830]
80003f3a:	72 08       	ld.w	r8,r9[0x0]
80003f3c:	20 18       	sub	r8,1
80003f3e:	93 08       	st.w	r9[0x0],r8
80003f40:	c0 71       	brne	80003f4e <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
80003f42:	30 09       	mov	r9,0
80003f44:	fe f8 07 10 	ld.w	r8,pc[1808]
80003f48:	91 09       	st.w	r8[0x0],r9
80003f4a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003f4e:	fe f8 07 26 	ld.w	r8,pc[1830]
80003f52:	fe f9 06 fe 	ld.w	r9,pc[1790]
80003f56:	72 0a       	ld.w	r10,r9[0x0]
80003f58:	70 09       	ld.w	r9,r8[0x0]
80003f5a:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003f5e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003f62:	70 09       	ld.w	r9,r8[0x0]
80003f64:	2f f9       	sub	r9,-1
80003f66:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f68:	e0 49 01 ff 	cp.w	r9,511
80003f6c:	e0 88 00 16 	brls	80003f98 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
80003f70:	30 09       	mov	r9,0
80003f72:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003f74:	fe f6 06 dc 	ld.w	r6,pc[1756]
80003f78:	6c 0c       	ld.w	r12,r6[0x0]
80003f7a:	f0 1f 01 c1 	mcall	8000467c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003f7e:	fe f8 06 ca 	ld.w	r8,pc[1738]
80003f82:	70 0c       	ld.w	r12,r8[0x0]
80003f84:	f0 1f 01 ab 	mcall	80004630 <phy_rx_func+0xe98>
80003f88:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003f8a:	c0 71       	brne	80003f98 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
80003f8c:	30 09       	mov	r9,0
80003f8e:	fe f8 06 c6 	ld.w	r8,pc[1734]
80003f92:	91 09       	st.w	r8[0x0],r9
80003f94:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003f98:	fe f9 06 c4 	ld.w	r9,pc[1732]
80003f9c:	72 08       	ld.w	r8,r9[0x0]
80003f9e:	20 18       	sub	r8,1
80003fa0:	93 08       	st.w	r9[0x0],r8
80003fa2:	c0 71       	brne	80003fb0 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003fa4:	30 09       	mov	r9,0
80003fa6:	fe f8 06 ae 	ld.w	r8,pc[1710]
80003faa:	91 09       	st.w	r8[0x0],r9
80003fac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003fb0:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003fb4:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003fb8:	72 0a       	ld.w	r10,r9[0x0]
80003fba:	70 09       	ld.w	r9,r8[0x0]
80003fbc:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003fc0:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003fc4:	70 09       	ld.w	r9,r8[0x0]
80003fc6:	2f f9       	sub	r9,-1
80003fc8:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003fca:	e0 49 01 ff 	cp.w	r9,511
80003fce:	e0 88 00 16 	brls	80003ffa <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80003fd2:	30 09       	mov	r9,0
80003fd4:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003fd6:	fe f6 06 7a 	ld.w	r6,pc[1658]
80003fda:	6c 0c       	ld.w	r12,r6[0x0]
80003fdc:	f0 1f 01 a8 	mcall	8000467c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003fe0:	fe f8 06 68 	ld.w	r8,pc[1640]
80003fe4:	70 0c       	ld.w	r12,r8[0x0]
80003fe6:	f0 1f 01 93 	mcall	80004630 <phy_rx_func+0xe98>
80003fea:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003fec:	c0 71       	brne	80003ffa <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80003fee:	30 09       	mov	r9,0
80003ff0:	fe f8 06 64 	ld.w	r8,pc[1636]
80003ff4:	91 09       	st.w	r8[0x0],r9
80003ff6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003ffa:	fe f9 06 62 	ld.w	r9,pc[1634]
80003ffe:	72 08       	ld.w	r8,r9[0x0]
80004000:	20 18       	sub	r8,1
80004002:	93 08       	st.w	r9[0x0],r8
80004004:	c0 71       	brne	80004012 <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
80004006:	30 09       	mov	r9,0
80004008:	fe f8 06 4c 	ld.w	r8,pc[1612]
8000400c:	91 09       	st.w	r8[0x0],r9
8000400e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80004012:	fe f8 06 62 	ld.w	r8,pc[1634]
80004016:	fe f9 06 3a 	ld.w	r9,pc[1594]
8000401a:	72 0a       	ld.w	r10,r9[0x0]
8000401c:	70 09       	ld.w	r9,r8[0x0]
8000401e:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80004022:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004026:	70 09       	ld.w	r9,r8[0x0]
80004028:	2f f9       	sub	r9,-1
8000402a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000402c:	e0 49 01 ff 	cp.w	r9,511
80004030:	e0 88 00 16 	brls	8000405c <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
80004034:	30 09       	mov	r9,0
80004036:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004038:	fe f6 06 18 	ld.w	r6,pc[1560]
8000403c:	6c 0c       	ld.w	r12,r6[0x0]
8000403e:	f0 1f 01 90 	mcall	8000467c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80004042:	fe f8 06 06 	ld.w	r8,pc[1542]
80004046:	70 0c       	ld.w	r12,r8[0x0]
80004048:	f0 1f 01 7a 	mcall	80004630 <phy_rx_func+0xe98>
8000404c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000404e:	c0 71       	brne	8000405c <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80004050:	30 09       	mov	r9,0
80004052:	fe f8 06 02 	ld.w	r8,pc[1538]
80004056:	91 09       	st.w	r8[0x0],r9
80004058:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000405c:	fe f9 06 00 	ld.w	r9,pc[1536]
80004060:	72 08       	ld.w	r8,r9[0x0]
80004062:	20 18       	sub	r8,1
80004064:	93 08       	st.w	r9[0x0],r8
80004066:	c0 71       	brne	80004074 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
80004068:	30 09       	mov	r9,0
8000406a:	fe f8 05 ea 	ld.w	r8,pc[1514]
8000406e:	91 09       	st.w	r8[0x0],r9
80004070:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80004074:	fe f8 06 00 	ld.w	r8,pc[1536]
80004078:	fe f9 05 d8 	ld.w	r9,pc[1496]
8000407c:	72 0a       	ld.w	r10,r9[0x0]
8000407e:	70 09       	ld.w	r9,r8[0x0]
80004080:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80004084:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004088:	70 09       	ld.w	r9,r8[0x0]
8000408a:	2f f9       	sub	r9,-1
8000408c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000408e:	e0 49 01 ff 	cp.w	r9,511
80004092:	e0 88 00 16 	brls	800040be <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
80004096:	30 09       	mov	r9,0
80004098:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000409a:	fe f6 05 b6 	ld.w	r6,pc[1462]
8000409e:	6c 0c       	ld.w	r12,r6[0x0]
800040a0:	f0 1f 01 77 	mcall	8000467c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800040a4:	fe f8 05 a4 	ld.w	r8,pc[1444]
800040a8:	70 0c       	ld.w	r12,r8[0x0]
800040aa:	f0 1f 01 62 	mcall	80004630 <phy_rx_func+0xe98>
800040ae:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800040b0:	c0 71       	brne	800040be <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
800040b2:	30 09       	mov	r9,0
800040b4:	fe f8 05 a0 	ld.w	r8,pc[1440]
800040b8:	91 09       	st.w	r8[0x0],r9
800040ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800040be:	fe f9 05 9e 	ld.w	r9,pc[1438]
800040c2:	72 08       	ld.w	r8,r9[0x0]
800040c4:	20 18       	sub	r8,1
800040c6:	93 08       	st.w	r9[0x0],r8
800040c8:	c0 71       	brne	800040d6 <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
800040ca:	30 09       	mov	r9,0
800040cc:	fe f8 05 88 	ld.w	r8,pc[1416]
800040d0:	91 09       	st.w	r8[0x0],r9
800040d2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
800040d6:	fe f8 05 9e 	ld.w	r8,pc[1438]
800040da:	fe f9 05 76 	ld.w	r9,pc[1398]
800040de:	72 0a       	ld.w	r10,r9[0x0]
800040e0:	70 09       	ld.w	r9,r8[0x0]
800040e2:	ef 3b 00 0f 	ld.ub	r11,r7[15]
800040e6:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800040ea:	70 09       	ld.w	r9,r8[0x0]
800040ec:	2f f9       	sub	r9,-1
800040ee:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800040f0:	e0 49 01 ff 	cp.w	r9,511
800040f4:	e0 88 00 16 	brls	80004120 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
800040f8:	30 09       	mov	r9,0
800040fa:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800040fc:	fe f7 05 54 	ld.w	r7,pc[1364]
80004100:	6e 0c       	ld.w	r12,r7[0x0]
80004102:	f0 1f 01 5f 	mcall	8000467c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80004106:	fe f8 05 42 	ld.w	r8,pc[1346]
8000410a:	70 0c       	ld.w	r12,r8[0x0]
8000410c:	f0 1f 01 49 	mcall	80004630 <phy_rx_func+0xe98>
80004110:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004112:	c0 71       	brne	80004120 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
80004114:	30 09       	mov	r9,0
80004116:	fe f8 05 3e 	ld.w	r8,pc[1342]
8000411a:	91 09       	st.w	r8[0x0],r9
8000411c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004120:	fe f9 05 3c 	ld.w	r9,pc[1340]
80004124:	72 08       	ld.w	r8,r9[0x0]
80004126:	20 18       	sub	r8,1
80004128:	93 08       	st.w	r9[0x0],r8
8000412a:	e0 81 02 74 	brne	80004612 <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
8000412e:	30 09       	mov	r9,0
80004130:	fe f8 05 24 	ld.w	r8,pc[1316]
80004134:	91 09       	st.w	r8[0x0],r9
80004136:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
8000413a:	30 09       	mov	r9,0
8000413c:	fe f8 05 18 	ld.w	r8,pc[1304]
80004140:	91 09       	st.w	r8[0x0],r9
80004142:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80004146:	fe f8 05 26 	ld.w	r8,pc[1318]
8000414a:	11 89       	ld.ub	r9,r8[0x0]
8000414c:	3f 28       	mov	r8,-14
8000414e:	f0 09 18 00 	cp.b	r9,r8
80004152:	c4 31       	brne	800041d8 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80004154:	8e 49       	ld.sh	r9,r7[0x8]
80004156:	fe f8 05 56 	ld.w	r8,pc[1366]
8000415a:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
8000415c:	fe f8 05 18 	ld.w	r8,pc[1304]
80004160:	fe f9 04 f0 	ld.w	r9,pc[1264]
80004164:	72 0a       	ld.w	r10,r9[0x0]
80004166:	70 09       	ld.w	r9,r8[0x0]
80004168:	ef 3b 00 08 	ld.ub	r11,r7[8]
8000416c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004170:	70 09       	ld.w	r9,r8[0x0]
80004172:	2f f9       	sub	r9,-1
80004174:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004176:	e0 49 01 ff 	cp.w	r9,511
8000417a:	e0 88 00 16 	brls	800041a6 <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
8000417e:	30 09       	mov	r9,0
80004180:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004182:	fe f7 04 ce 	ld.w	r7,pc[1230]
80004186:	6e 0c       	ld.w	r12,r7[0x0]
80004188:	f0 1f 01 3d 	mcall	8000467c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000418c:	fe f8 04 bc 	ld.w	r8,pc[1212]
80004190:	70 0c       	ld.w	r12,r8[0x0]
80004192:	f0 1f 01 28 	mcall	80004630 <phy_rx_func+0xe98>
80004196:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004198:	c0 71       	brne	800041a6 <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
8000419a:	30 09       	mov	r9,0
8000419c:	fe f8 04 b8 	ld.w	r8,pc[1208]
800041a0:	91 09       	st.w	r8[0x0],r9
800041a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800041a6:	fe f9 04 b6 	ld.w	r9,pc[1206]
800041aa:	72 08       	ld.w	r8,r9[0x0]
800041ac:	20 18       	sub	r8,1
800041ae:	93 08       	st.w	r9[0x0],r8
800041b0:	c0 71       	brne	800041be <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
800041b2:	30 09       	mov	r9,0
800041b4:	fe f8 04 a0 	ld.w	r8,pc[1184]
800041b8:	91 09       	st.w	r8[0x0],r9
800041ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
800041be:	20 18       	sub	r8,1
800041c0:	fe f9 04 9c 	ld.w	r9,pc[1180]
800041c4:	93 08       	st.w	r9[0x0],r8
800041c6:	58 08       	cp.w	r8,0
800041c8:	e0 81 02 25 	brne	80004612 <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
800041cc:	30 09       	mov	r9,0
800041ce:	fe f8 04 86 	ld.w	r8,pc[1158]
800041d2:	91 09       	st.w	r8[0x0],r9
800041d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
800041d8:	fe f8 04 94 	ld.w	r8,pc[1172]
800041dc:	11 89       	ld.ub	r9,r8[0x0]
800041de:	3f 38       	mov	r8,-13
800041e0:	f0 09 18 00 	cp.b	r9,r8
800041e4:	e0 81 01 0c 	brne	800043fc <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
800041e8:	8e 49       	ld.sh	r9,r7[0x8]
800041ea:	fe f8 04 c2 	ld.w	r8,pc[1218]
800041ee:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
800041f0:	8e 59       	ld.sh	r9,r7[0xa]
800041f2:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
800041f4:	8e 69       	ld.sh	r9,r7[0xc]
800041f6:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
800041f8:	fe f8 04 7c 	ld.w	r8,pc[1148]
800041fc:	fe f9 04 54 	ld.w	r9,pc[1108]
80004200:	72 0a       	ld.w	r10,r9[0x0]
80004202:	70 09       	ld.w	r9,r8[0x0]
80004204:	ef 3b 00 08 	ld.ub	r11,r7[8]
80004208:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000420c:	70 09       	ld.w	r9,r8[0x0]
8000420e:	2f f9       	sub	r9,-1
80004210:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004212:	e0 49 01 ff 	cp.w	r9,511
80004216:	e0 88 00 16 	brls	80004242 <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
8000421a:	30 09       	mov	r9,0
8000421c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000421e:	fe f6 04 32 	ld.w	r6,pc[1074]
80004222:	6c 0c       	ld.w	r12,r6[0x0]
80004224:	f0 1f 01 16 	mcall	8000467c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80004228:	fe f8 04 20 	ld.w	r8,pc[1056]
8000422c:	70 0c       	ld.w	r12,r8[0x0]
8000422e:	f0 1f 01 01 	mcall	80004630 <phy_rx_func+0xe98>
80004232:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004234:	c0 71       	brne	80004242 <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
80004236:	30 09       	mov	r9,0
80004238:	fe f8 04 1c 	ld.w	r8,pc[1052]
8000423c:	91 09       	st.w	r8[0x0],r9
8000423e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004242:	fe f9 04 1a 	ld.w	r9,pc[1050]
80004246:	72 08       	ld.w	r8,r9[0x0]
80004248:	20 18       	sub	r8,1
8000424a:	93 08       	st.w	r9[0x0],r8
8000424c:	c0 71       	brne	8000425a <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
8000424e:	30 09       	mov	r9,0
80004250:	fe f8 04 04 	ld.w	r8,pc[1028]
80004254:	91 09       	st.w	r8[0x0],r9
80004256:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
8000425a:	fe f8 04 1a 	ld.w	r8,pc[1050]
8000425e:	fe f9 03 f2 	ld.w	r9,pc[1010]
80004262:	72 0a       	ld.w	r10,r9[0x0]
80004264:	70 09       	ld.w	r9,r8[0x0]
80004266:	ef 3b 00 09 	ld.ub	r11,r7[9]
8000426a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000426e:	70 09       	ld.w	r9,r8[0x0]
80004270:	2f f9       	sub	r9,-1
80004272:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004274:	e0 49 01 ff 	cp.w	r9,511
80004278:	e0 88 00 16 	brls	800042a4 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
8000427c:	30 09       	mov	r9,0
8000427e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004280:	fe f6 03 d0 	ld.w	r6,pc[976]
80004284:	6c 0c       	ld.w	r12,r6[0x0]
80004286:	f0 1f 00 fe 	mcall	8000467c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000428a:	fe f8 03 be 	ld.w	r8,pc[958]
8000428e:	70 0c       	ld.w	r12,r8[0x0]
80004290:	f0 1f 00 e8 	mcall	80004630 <phy_rx_func+0xe98>
80004294:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004296:	c0 71       	brne	800042a4 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
80004298:	30 09       	mov	r9,0
8000429a:	fe f8 03 ba 	ld.w	r8,pc[954]
8000429e:	91 09       	st.w	r8[0x0],r9
800042a0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800042a4:	fe f9 03 b8 	ld.w	r9,pc[952]
800042a8:	72 08       	ld.w	r8,r9[0x0]
800042aa:	20 18       	sub	r8,1
800042ac:	93 08       	st.w	r9[0x0],r8
800042ae:	c0 71       	brne	800042bc <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
800042b0:	30 09       	mov	r9,0
800042b2:	fe f8 03 a2 	ld.w	r8,pc[930]
800042b6:	91 09       	st.w	r8[0x0],r9
800042b8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
800042bc:	fe f8 03 b8 	ld.w	r8,pc[952]
800042c0:	fe f9 03 90 	ld.w	r9,pc[912]
800042c4:	72 0a       	ld.w	r10,r9[0x0]
800042c6:	70 09       	ld.w	r9,r8[0x0]
800042c8:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800042cc:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800042d0:	70 09       	ld.w	r9,r8[0x0]
800042d2:	2f f9       	sub	r9,-1
800042d4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800042d6:	e0 49 01 ff 	cp.w	r9,511
800042da:	e0 88 00 16 	brls	80004306 <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
800042de:	30 09       	mov	r9,0
800042e0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800042e2:	fe f6 03 6e 	ld.w	r6,pc[878]
800042e6:	6c 0c       	ld.w	r12,r6[0x0]
800042e8:	f0 1f 00 e5 	mcall	8000467c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800042ec:	fe f8 03 5c 	ld.w	r8,pc[860]
800042f0:	70 0c       	ld.w	r12,r8[0x0]
800042f2:	f0 1f 00 d0 	mcall	80004630 <phy_rx_func+0xe98>
800042f6:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800042f8:	c0 71       	brne	80004306 <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
800042fa:	30 09       	mov	r9,0
800042fc:	fe f8 03 58 	ld.w	r8,pc[856]
80004300:	91 09       	st.w	r8[0x0],r9
80004302:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004306:	fe f9 03 56 	ld.w	r9,pc[854]
8000430a:	72 08       	ld.w	r8,r9[0x0]
8000430c:	20 18       	sub	r8,1
8000430e:	93 08       	st.w	r9[0x0],r8
80004310:	c0 71       	brne	8000431e <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
80004312:	30 09       	mov	r9,0
80004314:	fe f8 03 40 	ld.w	r8,pc[832]
80004318:	91 09       	st.w	r8[0x0],r9
8000431a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
8000431e:	fe f8 03 56 	ld.w	r8,pc[854]
80004322:	fe f9 03 2e 	ld.w	r9,pc[814]
80004326:	72 0a       	ld.w	r10,r9[0x0]
80004328:	70 09       	ld.w	r9,r8[0x0]
8000432a:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000432e:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004332:	70 09       	ld.w	r9,r8[0x0]
80004334:	2f f9       	sub	r9,-1
80004336:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004338:	e0 49 01 ff 	cp.w	r9,511
8000433c:	e0 88 00 16 	brls	80004368 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80004340:	30 09       	mov	r9,0
80004342:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004344:	fe f6 03 0c 	ld.w	r6,pc[780]
80004348:	6c 0c       	ld.w	r12,r6[0x0]
8000434a:	f0 1f 00 cd 	mcall	8000467c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000434e:	fe f8 02 fa 	ld.w	r8,pc[762]
80004352:	70 0c       	ld.w	r12,r8[0x0]
80004354:	f0 1f 00 b7 	mcall	80004630 <phy_rx_func+0xe98>
80004358:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000435a:	c0 71       	brne	80004368 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
8000435c:	30 09       	mov	r9,0
8000435e:	fe f8 02 f6 	ld.w	r8,pc[758]
80004362:	91 09       	st.w	r8[0x0],r9
80004364:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004368:	fe f9 02 f4 	ld.w	r9,pc[756]
8000436c:	72 08       	ld.w	r8,r9[0x0]
8000436e:	20 18       	sub	r8,1
80004370:	93 08       	st.w	r9[0x0],r8
80004372:	c0 71       	brne	80004380 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
80004374:	30 09       	mov	r9,0
80004376:	fe f8 02 de 	ld.w	r8,pc[734]
8000437a:	91 09       	st.w	r8[0x0],r9
8000437c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80004380:	fe f8 02 f4 	ld.w	r8,pc[756]
80004384:	fe f9 02 cc 	ld.w	r9,pc[716]
80004388:	72 0a       	ld.w	r10,r9[0x0]
8000438a:	70 09       	ld.w	r9,r8[0x0]
8000438c:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80004390:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004394:	70 09       	ld.w	r9,r8[0x0]
80004396:	2f f9       	sub	r9,-1
80004398:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000439a:	e0 49 01 ff 	cp.w	r9,511
8000439e:	e0 88 00 16 	brls	800043ca <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
800043a2:	30 09       	mov	r9,0
800043a4:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800043a6:	fe f7 02 aa 	ld.w	r7,pc[682]
800043aa:	6e 0c       	ld.w	r12,r7[0x0]
800043ac:	f0 1f 00 b4 	mcall	8000467c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800043b0:	fe f8 02 98 	ld.w	r8,pc[664]
800043b4:	70 0c       	ld.w	r12,r8[0x0]
800043b6:	f0 1f 00 9f 	mcall	80004630 <phy_rx_func+0xe98>
800043ba:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800043bc:	c0 71       	brne	800043ca <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
800043be:	30 09       	mov	r9,0
800043c0:	fe f8 02 94 	ld.w	r8,pc[660]
800043c4:	91 09       	st.w	r8[0x0],r9
800043c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800043ca:	fe f9 02 92 	ld.w	r9,pc[658]
800043ce:	72 08       	ld.w	r8,r9[0x0]
800043d0:	20 18       	sub	r8,1
800043d2:	93 08       	st.w	r9[0x0],r8
800043d4:	c0 71       	brne	800043e2 <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
800043d6:	30 09       	mov	r9,0
800043d8:	fe f8 02 7c 	ld.w	r8,pc[636]
800043dc:	91 09       	st.w	r8[0x0],r9
800043de:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
800043e2:	20 18       	sub	r8,1
800043e4:	fe f9 02 78 	ld.w	r9,pc[632]
800043e8:	93 08       	st.w	r9[0x0],r8
800043ea:	58 08       	cp.w	r8,0
800043ec:	e0 81 01 13 	brne	80004612 <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
800043f0:	30 09       	mov	r9,0
800043f2:	fe f8 02 62 	ld.w	r8,pc[610]
800043f6:	91 09       	st.w	r8[0x0],r9
800043f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
800043fc:	fe f8 02 70 	ld.w	r8,pc[624]
80004400:	11 89       	ld.ub	r9,r8[0x0]
80004402:	30 48       	mov	r8,4
80004404:	f0 09 18 00 	cp.b	r9,r8
80004408:	c0 80       	breq	80004418 <phy_rx_func+0xc80>
8000440a:	fe f8 02 62 	ld.w	r8,pc[610]
8000440e:	11 89       	ld.ub	r9,r8[0x0]
80004410:	30 38       	mov	r8,3
80004412:	f0 09 18 00 	cp.b	r9,r8
80004416:	c1 41       	brne	8000443e <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80004418:	6e 29       	ld.w	r9,r7[0x8]
8000441a:	fe f8 02 7a 	ld.w	r8,pc[634]
8000441e:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80004420:	6e 39       	ld.w	r9,r7[0xc]
80004422:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80004424:	fe f9 02 38 	ld.w	r9,pc[568]
80004428:	72 08       	ld.w	r8,r9[0x0]
8000442a:	20 88       	sub	r8,8
8000442c:	93 08       	st.w	r9[0x0],r8
8000442e:	e0 81 00 f2 	brne	80004612 <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80004432:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80004434:	fe f9 02 20 	ld.w	r9,pc[544]
80004438:	93 08       	st.w	r9[0x0],r8
8000443a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
8000443e:	fe f8 02 2e 	ld.w	r8,pc[558]
80004442:	11 89       	ld.ub	r9,r8[0x0]
80004444:	31 38       	mov	r8,19
80004446:	f0 09 18 00 	cp.b	r9,r8
8000444a:	e0 81 00 9c 	brne	80004582 <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
8000444e:	fe f8 02 62 	ld.w	r8,pc[610]
80004452:	11 88       	ld.ub	r8,r8[0x0]
80004454:	30 c9       	mov	r9,12
80004456:	f2 08 18 00 	cp.b	r8,r9
8000445a:	e0 81 00 7b 	brne	80004550 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
8000445e:	8e 49       	ld.sh	r9,r7[0x8]
80004460:	fe f8 02 54 	ld.w	r8,pc[596]
80004464:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80004468:	30 09       	mov	r9,0
8000446a:	fe f8 02 46 	ld.w	r8,pc[582]
8000446e:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004470:	ef 39 00 0d 	ld.ub	r9,r7[13]
80004474:	3f 38       	mov	r8,-13
80004476:	f0 09 18 00 	cp.b	r9,r8
8000447a:	c6 61       	brne	80004546 <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
8000447c:	10 99       	mov	r9,r8
8000447e:	4f c8       	lddpc	r8,8000466c <phy_rx_func+0xed4>
80004480:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80004482:	ef 39 00 0c 	ld.ub	r9,r7[12]
80004486:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
8000448a:	4f 58       	lddpc	r8,8000465c <phy_rx_func+0xec4>
8000448c:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
8000448e:	30 19       	mov	r9,1
80004490:	fe f8 02 0c 	ld.w	r8,pc[524]
80004494:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80004496:	8e 79       	ld.sh	r9,r7[0xe]
80004498:	fe f8 02 14 	ld.w	r8,pc[532]
8000449c:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
8000449e:	4f 68       	lddpc	r8,80004674 <phy_rx_func+0xedc>
800044a0:	4e c9       	lddpc	r9,80004650 <phy_rx_func+0xeb8>
800044a2:	72 0a       	ld.w	r10,r9[0x0]
800044a4:	70 09       	ld.w	r9,r8[0x0]
800044a6:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800044aa:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
800044ae:	70 09       	ld.w	r9,r8[0x0]
800044b0:	2f f9       	sub	r9,-1
800044b2:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800044b4:	e0 49 01 ff 	cp.w	r9,511
800044b8:	e0 88 00 13 	brls	800044de <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
800044bc:	30 09       	mov	r9,0
800044be:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
800044c0:	4e 46       	lddpc	r6,80004650 <phy_rx_func+0xeb8>
800044c2:	6c 0c       	ld.w	r12,r6[0x0]
800044c4:	f0 1f 00 6e 	mcall	8000467c <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
800044c8:	4e 08       	lddpc	r8,80004648 <phy_rx_func+0xeb0>
800044ca:	70 0c       	ld.w	r12,r8[0x0]
800044cc:	f0 1f 00 59 	mcall	80004630 <phy_rx_func+0xe98>
800044d0:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
800044d2:	c0 61       	brne	800044de <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
800044d4:	30 09       	mov	r9,0
800044d6:	4e 08       	lddpc	r8,80004654 <phy_rx_func+0xebc>
800044d8:	91 09       	st.w	r8[0x0],r9
800044da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
800044de:	4e 09       	lddpc	r9,8000465c <phy_rx_func+0xec4>
800044e0:	72 08       	ld.w	r8,r9[0x0]
800044e2:	20 18       	sub	r8,1
800044e4:	93 08       	st.w	r9[0x0],r8
800044e6:	c0 61       	brne	800044f2 <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
800044e8:	30 09       	mov	r9,0
800044ea:	4d b8       	lddpc	r8,80004654 <phy_rx_func+0xebc>
800044ec:	91 09       	st.w	r8[0x0],r9
800044ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
800044f2:	4e 18       	lddpc	r8,80004674 <phy_rx_func+0xedc>
800044f4:	4d 79       	lddpc	r9,80004650 <phy_rx_func+0xeb8>
800044f6:	72 0a       	ld.w	r10,r9[0x0]
800044f8:	70 09       	ld.w	r9,r8[0x0]
800044fa:	ef 3b 00 0f 	ld.ub	r11,r7[15]
800044fe:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80004502:	70 09       	ld.w	r9,r8[0x0]
80004504:	2f f9       	sub	r9,-1
80004506:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004508:	e0 49 01 ff 	cp.w	r9,511
8000450c:	e0 88 00 13 	brls	80004532 <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80004510:	30 09       	mov	r9,0
80004512:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80004514:	4c f7       	lddpc	r7,80004650 <phy_rx_func+0xeb8>
80004516:	6e 0c       	ld.w	r12,r7[0x0]
80004518:	f0 1f 00 59 	mcall	8000467c <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
8000451c:	4c b8       	lddpc	r8,80004648 <phy_rx_func+0xeb0>
8000451e:	70 0c       	ld.w	r12,r8[0x0]
80004520:	f0 1f 00 44 	mcall	80004630 <phy_rx_func+0xe98>
80004524:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80004526:	c0 61       	brne	80004532 <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80004528:	30 09       	mov	r9,0
8000452a:	4c b8       	lddpc	r8,80004654 <phy_rx_func+0xebc>
8000452c:	91 09       	st.w	r8[0x0],r9
8000452e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80004532:	4c b9       	lddpc	r9,8000465c <phy_rx_func+0xec4>
80004534:	72 08       	ld.w	r8,r9[0x0]
80004536:	20 18       	sub	r8,1
80004538:	93 08       	st.w	r9[0x0],r8
8000453a:	c6 c1       	brne	80004612 <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
8000453c:	30 09       	mov	r9,0
8000453e:	4c 68       	lddpc	r8,80004654 <phy_rx_func+0xebc>
80004540:	91 09       	st.w	r8[0x0],r9
80004542:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80004546:	30 09       	mov	r9,0
80004548:	4c 38       	lddpc	r8,80004654 <phy_rx_func+0xebc>
8000454a:	91 09       	st.w	r8[0x0],r9
8000454c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80004550:	8e 4a       	ld.sh	r10,r7[0x8]
80004552:	4d 99       	lddpc	r9,800046b4 <phy_rx_func+0xf1c>
80004554:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80004558:	4d 6a       	lddpc	r10,800046b0 <phy_rx_func+0xf18>
8000455a:	15 88       	ld.ub	r8,r10[0x0]
8000455c:	f0 cb ff ff 	sub	r11,r8,-1
80004560:	8e 5c       	ld.sh	r12,r7[0xa]
80004562:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80004566:	f0 cb ff fe 	sub	r11,r8,-2
8000456a:	8e 6c       	ld.sh	r12,r7[0xc]
8000456c:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80004570:	f0 cb ff fd 	sub	r11,r8,-3
80004574:	8e 7c       	ld.sh	r12,r7[0xe]
80004576:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
8000457a:	2f c8       	sub	r8,-4
8000457c:	b4 88       	st.b	r10[0x0],r8
8000457e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80004582:	30 09       	mov	r9,0
80004584:	4b 48       	lddpc	r8,80004654 <phy_rx_func+0xebc>
80004586:	91 09       	st.w	r8[0x0],r9
80004588:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
8000458c:	4c 08       	lddpc	r8,8000468c <phy_rx_func+0xef4>
8000458e:	70 09       	ld.w	r9,r8[0x0]
80004590:	8e 4b       	ld.sh	r11,r7[0x8]
80004592:	4c 0a       	lddpc	r10,80004690 <phy_rx_func+0xef8>
80004594:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80004598:	2f f9       	sub	r9,-1
8000459a:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
8000459c:	4b 58       	lddpc	r8,80004670 <phy_rx_func+0xed8>
8000459e:	70 09       	ld.w	r9,r8[0x0]
800045a0:	20 29       	sub	r9,2
800045a2:	91 09       	st.w	r8[0x0],r9
800045a4:	70 08       	ld.w	r8,r8[0x0]
800045a6:	58 08       	cp.w	r8,0
800045a8:	c2 f1       	brne	80004606 <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
800045aa:	30 09       	mov	r9,0
800045ac:	4b 88       	lddpc	r8,8000468c <phy_rx_func+0xef4>
800045ae:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800045b0:	8e 59       	ld.sh	r9,r7[0xa]
800045b2:	fe 78 82 12 	mov	r8,-32238
800045b6:	f0 09 19 00 	cp.h	r9,r8
800045ba:	c2 11       	brne	800045fc <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
800045bc:	ef 3c 00 0d 	ld.ub	r12,r7[13]
800045c0:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
800045c4:	4a f8       	lddpc	r8,80004680 <phy_rx_func+0xee8>
800045c6:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
800045c8:	8e 59       	ld.sh	r9,r7[0xa]
800045ca:	4a f8       	lddpc	r8,80004684 <phy_rx_func+0xeec>
800045cc:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
800045ce:	8e 69       	ld.sh	r9,r7[0xc]
800045d0:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
800045d2:	f0 1f 00 2e 	mcall	80004688 <phy_rx_func+0xef0>
800045d6:	4a 18       	lddpc	r8,80004658 <phy_rx_func+0xec0>
800045d8:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800045da:	ef 39 00 0f 	ld.ub	r9,r7[15]
800045de:	31 38       	mov	r8,19
800045e0:	f0 09 18 00 	cp.b	r9,r8
800045e4:	c0 71       	brne	800045f2 <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
800045e6:	10 99       	mov	r9,r8
800045e8:	4a 18       	lddpc	r8,8000466c <phy_rx_func+0xed4>
800045ea:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
800045ec:	30 09       	mov	r9,0
800045ee:	49 c8       	lddpc	r8,8000465c <phy_rx_func+0xec4>
800045f0:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
800045f2:	30 49       	mov	r9,4
800045f4:	49 88       	lddpc	r8,80004654 <phy_rx_func+0xebc>
800045f6:	91 09       	st.w	r8[0x0],r9
800045f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
800045fc:	30 09       	mov	r9,0
800045fe:	49 68       	lddpc	r8,80004654 <phy_rx_func+0xebc>
80004600:	91 09       	st.w	r8[0x0],r9
80004602:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80004606:	4a dc       	lddpc	r12,800046b8 <phy_rx_func+0xf20>
80004608:	f0 1f 00 18 	mcall	80004668 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
8000460c:	30 09       	mov	r9,0
8000460e:	49 28       	lddpc	r8,80004654 <phy_rx_func+0xebc>
80004610:	91 09       	st.w	r8[0x0],r9
80004612:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004616:	00 00       	add	r0,r0
80004618:	00 00       	add	r0,r0
8000461a:	0a d4       	st.w	--r5,r4
8000461c:	00 00       	add	r0,r0
8000461e:	0a ec       	st.h	--r5,r12
80004620:	00 00       	add	r0,r0
80004622:	0a cc       	st.b	r5++,r12
80004624:	00 00       	add	r0,r0
80004626:	0a ae       	st.w	r5++,lr
80004628:	00 00       	add	r0,r0
8000462a:	0a 9c       	mov	r12,r5
8000462c:	00 00       	add	r0,r0
8000462e:	0a c4       	st.b	r5++,r4
80004630:	80 00       	ld.sh	r0,r0[0x0]
80004632:	36 18       	mov	r8,97
80004634:	00 00       	add	r0,r0
80004636:	0a bc       	st.h	r5++,r12
80004638:	80 00       	ld.sh	r0,r0[0x0]
8000463a:	35 30       	mov	r0,83
8000463c:	00 00       	add	r0,r0
8000463e:	0a d0       	st.w	--r5,r0
80004640:	80 00       	ld.sh	r0,r0[0x0]
80004642:	35 64       	mov	r4,86
80004644:	00 00       	add	r0,r0
80004646:	0a ad       	st.w	r5++,sp
80004648:	00 00       	add	r0,r0
8000464a:	0a c8       	st.b	r5++,r8
8000464c:	00 00       	add	r0,r0
8000464e:	0a d8       	st.w	--r5,r8
80004650:	00 00       	add	r0,r0
80004652:	0a b0       	st.h	r5++,r0
80004654:	00 00       	add	r0,r0
80004656:	0a f8       	st.b	--r5,r8
80004658:	00 00       	add	r0,r0
8000465a:	0a e0       	st.h	--r5,r0
8000465c:	00 00       	add	r0,r0
8000465e:	0a 98       	mov	r8,r5
80004660:	00 00       	add	r0,r0
80004662:	0a 61       	and	r1,r5
80004664:	80 00       	ld.sh	r0,r0[0x0]
80004666:	e9 84       	*unknown*
80004668:	80 00       	ld.sh	r0,r0[0x0]
8000466a:	81 50       	st.w	r0[0x14],r0
8000466c:	00 00       	add	r0,r0
8000466e:	0a ac       	st.w	r5++,r12
80004670:	00 00       	add	r0,r0
80004672:	0b 04       	ld.w	r4,r5++
80004674:	00 00       	add	r0,r0
80004676:	0a e4       	st.h	--r5,r4
80004678:	80 00       	ld.sh	r0,r0[0x0]
8000467a:	89 b6       	st.w	r4[0x2c],r6
8000467c:	80 00       	ld.sh	r0,r0[0x0]
8000467e:	35 4c       	mov	r12,84
80004680:	00 00       	add	r0,r0
80004682:	0a 78       	tst	r8,r5
80004684:	00 00       	add	r0,r0
80004686:	1f 38       	ld.ub	r8,pc++
80004688:	80 00       	ld.sh	r0,r0[0x0]
8000468a:	35 00       	mov	r0,80
8000468c:	00 00       	add	r0,r0
8000468e:	0a a0       	st.w	r5++,r0
80004690:	00 00       	add	r0,r0
80004692:	1e 3c       	cp.w	r12,pc
80004694:	00 00       	add	r0,r0
80004696:	0a a4       	st.w	r5++,r4
80004698:	00 00       	add	r0,r0
8000469a:	0a 63       	and	r3,r5
8000469c:	00 00       	add	r0,r0
8000469e:	0a 82       	andn	r2,r5
800046a0:	00 00       	add	r0,r0
800046a2:	0a fc       	st.b	--r5,r12
800046a4:	00 00       	add	r0,r0
800046a6:	0a b8       	st.h	r5++,r8
800046a8:	00 00       	add	r0,r0
800046aa:	0a 89       	andn	r9,r5
800046ac:	00 00       	add	r0,r0
800046ae:	1e 34       	cp.w	r4,pc
800046b0:	00 00       	add	r0,r0
800046b2:	0a f0       	st.b	--r5,r0
800046b4:	00 00       	add	r0,r0
800046b6:	1f 3c       	ld.ub	r12,pc++
800046b8:	80 00       	ld.sh	r0,r0[0x0]
800046ba:	e9 9c       	*unknown*

800046bc <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
800046bc:	d4 01       	pushm	lr
	//xHigherPriorityTaskWoken = pdFALSE;
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
800046be:	49 a8       	lddpc	r8,80004724 <pdca_int_handler+0x68>
800046c0:	70 09       	ld.w	r9,r8[0x0]
800046c2:	2f f9       	sub	r9,-1
800046c4:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
800046c6:	49 98       	lddpc	r8,80004728 <pdca_int_handler+0x6c>
800046c8:	11 89       	ld.ub	r9,r8[0x0]
800046ca:	ec 19 00 01 	eorl	r9,0x1
800046ce:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
800046d0:	11 89       	ld.ub	r9,r8[0x0]
800046d2:	a5 69       	lsl	r9,0x4
800046d4:	2f c9       	sub	r9,-4
800046d6:	49 6a       	lddpc	r10,8000472c <pdca_int_handler+0x70>
800046d8:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
800046da:	fe 7a 00 40 	mov	r10,-65472
800046de:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
800046e0:	30 39       	mov	r9,3
800046e2:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
800046e4:	11 8a       	ld.ub	r10,r8[0x0]
800046e6:	a5 6a       	lsl	r10,0x4
800046e8:	2f ca       	sub	r10,-4
800046ea:	49 28       	lddpc	r8,80004730 <pdca_int_handler+0x74>
800046ec:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
800046ee:	fe 78 00 00 	mov	r8,-65536
800046f2:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
800046f4:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
800046f6:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
800046f8:	48 f8       	lddpc	r8,80004734 <pdca_int_handler+0x78>
800046fa:	70 08       	ld.w	r8,r8[0x0]
800046fc:	58 08       	cp.w	r8,0
800046fe:	c0 70       	breq	8000470c <pdca_int_handler+0x50>
80004700:	48 a9       	lddpc	r9,80004728 <pdca_int_handler+0x6c>
80004702:	13 89       	ld.ub	r9,r9[0x0]
80004704:	a5 69       	lsl	r9,0x4
80004706:	48 bc       	lddpc	r12,80004730 <pdca_int_handler+0x74>
80004708:	12 0c       	add	r12,r9
8000470a:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
8000470c:	48 b8       	lddpc	r8,80004738 <pdca_int_handler+0x7c>
8000470e:	70 08       	ld.w	r8,r8[0x0]
80004710:	58 08       	cp.w	r8,0
80004712:	c0 70       	breq	80004720 <pdca_int_handler+0x64>
80004714:	48 59       	lddpc	r9,80004728 <pdca_int_handler+0x6c>
80004716:	13 89       	ld.ub	r9,r9[0x0]
80004718:	a5 69       	lsl	r9,0x4
8000471a:	48 5c       	lddpc	r12,8000472c <pdca_int_handler+0x70>
8000471c:	12 0c       	add	r12,r9
8000471e:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80004720:	d4 02       	popm	lr
80004722:	d6 03       	rete
80004724:	00 00       	add	r0,r0
80004726:	0b 0c       	ld.w	r12,r5++
80004728:	00 00       	add	r0,r0
8000472a:	97 5c       	st.w	r11[0x14],r12
8000472c:	00 00       	add	r0,r0
8000472e:	97 84       	st.w	r11[0x20],r4
80004730:	00 00       	add	r0,r0
80004732:	97 64       	st.w	r11[0x18],r4
80004734:	00 00       	add	r0,r0
80004736:	0b 08       	ld.w	r8,r5++
80004738:	00 00       	add	r0,r0
8000473a:	0b 10       	ld.sh	r0,r5++

8000473c <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
8000473c:	fe 78 10 00 	mov	r8,-61440
80004740:	e0 69 0d c0 	mov	r9,3520
80004744:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80004748:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
8000474c:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80004750:	fe 78 34 00 	mov	r8,-52224
80004754:	e0 69 80 00 	mov	r9,32768
80004758:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
8000475a:	30 09       	mov	r9,0
8000475c:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
8000475e:	e0 69 04 21 	mov	r9,1057
80004762:	ea 19 3f 20 	orh	r9,0x3f20
80004766:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80004768:	e0 69 02 9f 	mov	r9,671
8000476c:	ea 19 01 00 	orh	r9,0x100
80004770:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80004772:	e0 6a 04 02 	mov	r10,1026
80004776:	ea 1a 3f 20 	orh	r10,0x3f20
8000477a:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
8000477c:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
8000477e:	5e fc       	retal	r12

80004780 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80004780:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80004782:	30 19       	mov	r9,1
80004784:	49 78       	lddpc	r8,800047e0 <local_start_PDC+0x60>
80004786:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80004788:	fe 78 00 00 	mov	r8,-65536
8000478c:	30 7b       	mov	r11,7
8000478e:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80004790:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80004792:	49 59       	lddpc	r9,800047e4 <local_start_PDC+0x64>
80004794:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80004798:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
8000479a:	30 3a       	mov	r10,3
8000479c:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
8000479e:	30 1c       	mov	r12,1
800047a0:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
800047a2:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
800047a4:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
800047a6:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
800047a8:	30 2c       	mov	r12,2
800047aa:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
800047ac:	48 f9       	lddpc	r9,800047e8 <local_start_PDC+0x68>
800047ae:	e0 68 5a 5a 	mov	r8,23130
800047b2:	ea 18 ab cd 	orh	r8,0xabcd
800047b6:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
800047b8:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
800047ba:	30 0e       	mov	lr,0
800047bc:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
800047be:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
800047c0:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
800047c2:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
800047c4:	fe 78 00 40 	mov	r8,-65472
800047c8:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
800047ca:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
800047cc:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
800047d0:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
800047d2:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
800047d4:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
800047d6:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
800047d8:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
800047da:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
800047dc:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
800047de:	d8 02       	popm	pc
800047e0:	00 00       	add	r0,r0
800047e2:	97 5c       	st.w	r11[0x14],r12
800047e4:	00 00       	add	r0,r0
800047e6:	97 64       	st.w	r11[0x18],r4
800047e8:	00 00       	add	r0,r0
800047ea:	97 84       	st.w	r11[0x20],r4

800047ec <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
800047ec:	48 38       	lddpc	r8,800047f8 <register_rx_tx_func+0xc>
800047ee:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
800047f0:	48 38       	lddpc	r8,800047fc <register_rx_tx_func+0x10>
800047f2:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
800047f4:	5e fc       	retal	r12
800047f6:	00 00       	add	r0,r0
800047f8:	00 00       	add	r0,r0
800047fa:	0b 08       	ld.w	r8,r5++
800047fc:	00 00       	add	r0,r0
800047fe:	0b 10       	ld.sh	r0,r5++

80004800 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80004800:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80004802:	fe 78 10 00 	mov	r8,-61440
80004806:	30 29       	mov	r9,2
80004808:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
8000480c:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80004810:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
80004812:	30 3a       	mov	r10,3
80004814:	36 0b       	mov	r11,96
80004816:	49 4c       	lddpc	r12,80004864 <ssc_init+0x64>
80004818:	f0 1f 00 14 	mcall	80004868 <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
8000481c:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
8000481e:	fe 79 10 00 	mov	r9,-61440
80004822:	f2 f8 01 60 	ld.w	r8,r9[352]
80004826:	e2 18 00 02 	andl	r8,0x2,COH
8000482a:	cf c0       	breq	80004822 <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8000482c:	fe 79 10 00 	mov	r9,-61440
80004830:	f2 f8 01 60 	ld.w	r8,r9[352]
80004834:	e2 18 00 02 	andl	r8,0x2,COH
80004838:	cf c1       	brne	80004830 <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
8000483a:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
8000483c:	f0 1f 00 0c 	mcall	8000486c <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
80004840:	f0 1f 00 0c 	mcall	80004870 <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004844:	fe 79 00 00 	mov	r9,-65536
80004848:	30 18       	mov	r8,1
8000484a:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
8000484c:	fe 7a 00 40 	mov	r10,-65472
80004850:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80004852:	e0 6b 01 01 	mov	r11,257
80004856:	fe 7a 34 00 	mov	r10,-52224
8000485a:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
8000485c:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
8000485e:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80004860:	d8 02       	popm	pc
80004862:	00 00       	add	r0,r0
80004864:	80 00       	ld.sh	r0,r0[0x0]
80004866:	46 bc       	lddsp	r12,sp[0x1ac]
80004868:	80 00       	ld.sh	r0,r0[0x0]
8000486a:	64 2c       	ld.w	r12,r2[0x8]
8000486c:	80 00       	ld.sh	r0,r0[0x0]
8000486e:	47 3c       	lddsp	r12,sp[0x1cc]
80004870:	80 00       	ld.sh	r0,r0[0x0]
80004872:	47 80       	lddsp	r0,sp[0x1e0]

80004874 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80004874:	48 28       	lddpc	r8,8000487c <xcmp_register_app_list+0x8>
80004876:	91 0c       	st.w	r8[0x0],r12
}
80004878:	5e fc       	retal	r12
8000487a:	00 00       	add	r0,r0
8000487c:	00 00       	add	r0,r0
8000487e:	97 a4       	st.w	r11[0x28],r4

80004880 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80004880:	eb cd 40 80 	pushm	r7,lr
80004884:	fa cd 01 00 	sub	sp,sp,256
80004888:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
8000488a:	16 98       	mov	r8,r11
8000488c:	2f 08       	sub	r8,-16
8000488e:	af a8       	sbr	r8,0xe
80004890:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80004892:	3f f8       	mov	r8,-1
80004894:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80004896:	30 b9       	mov	r9,11
80004898:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
8000489a:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
8000489c:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
8000489e:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800048a0:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
800048a2:	f6 ca ff fe 	sub	r10,r11,-2
800048a6:	18 9b       	mov	r11,r12
800048a8:	fa cc ff f0 	sub	r12,sp,-16
800048ac:	f0 1f 00 05 	mcall	800048c0 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
800048b0:	2f e7       	sub	r7,-2
800048b2:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
800048b4:	1a 9c       	mov	r12,sp
800048b6:	f0 1f 00 04 	mcall	800048c4 <xcmp_tx+0x44>
}
800048ba:	2c 0d       	sub	sp,-256
800048bc:	e3 cd 80 80 	ldm	sp++,r7,pc
800048c0:	80 00       	ld.sh	r0,r0[0x0]
800048c2:	88 6e       	ld.sh	lr,r4[0xc]
800048c4:	80 00       	ld.sh	r0,r0[0x0]
800048c6:	4e 98       	lddpc	r8,80004a68 <xcmp_IdleTestTone+0x5c>

800048c8 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U32 dest)
{
800048c8:	d4 21       	pushm	r4-r7,lr
800048ca:	fa cd 00 d0 	sub	sp,sp,208
800048ce:	18 94       	mov	r4,r12
800048d0:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
800048d2:	e0 68 01 00 	mov	r8,256
800048d6:	f0 0b 19 00 	cp.h	r11,r8
800048da:	e0 8b 00 38 	brhi	8000494a <xcmp_data_session_req+0x82>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
800048de:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
800048e2:	e0 68 04 1d 	mov	r8,1053
800048e6:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
800048e8:	30 18       	mov	r8,1
800048ea:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
800048ec:	32 08       	mov	r8,32
800048ee:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
800048f0:	30 28       	mov	r8,2
800048f2:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
800048f4:	30 48       	mov	r8,4
800048f6:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
800048f8:	f5 da c0 18 	bfextu	r10,r10,0x0,0x18
800048fc:	ea 1a 0c 00 	orh	r10,0xc00
80004900:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80004902:	30 4a       	mov	r10,4
80004904:	1a 9b       	mov	r11,sp
80004906:	fa cc ff f4 	sub	r12,sp,-12
8000490a:	f0 1f 00 12 	mcall	80004950 <xcmp_data_session_req+0x88>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
8000490e:	30 f8       	mov	r8,15
80004910:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80004914:	3a 78       	mov	r8,-89
80004916:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
8000491a:	30 08       	mov	r8,0
8000491c:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80004920:	0e 9a       	mov	r10,r7
80004922:	5c 7a       	castu.h	r10
80004924:	f4 08 16 08 	lsr	r8,r10,0x8
80004928:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
8000492c:	0e 96       	mov	r6,r7
8000492e:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80004932:	08 9b       	mov	r11,r4
80004934:	fa cc ff eb 	sub	r12,sp,-21
80004938:	f0 1f 00 06 	mcall	80004950 <xcmp_data_session_req+0x88>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
8000493c:	ee cb ff f3 	sub	r11,r7,-13
80004940:	5c 5b       	castu.b	r11
80004942:	fa cc ff fa 	sub	r12,sp,-6
80004946:	f0 1f 00 04 	mcall	80004954 <xcmp_data_session_req+0x8c>
}
8000494a:	2c cd       	sub	sp,-208
8000494c:	d8 22       	popm	r4-r7,pc
8000494e:	00 00       	add	r0,r0
80004950:	80 00       	ld.sh	r0,r0[0x0]
80004952:	88 6e       	ld.sh	lr,r4[0xc]
80004954:	80 00       	ld.sh	r0,r0[0x0]
80004956:	48 80       	lddpc	r0,80004974 <xcmp_DeviceInitializationStatus_request+0x1c>

80004958 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80004958:	d4 01       	pushm	lr
8000495a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
8000495e:	fe 78 b4 00 	mov	r8,-19456
80004962:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80004964:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = XCMP_Version[0];
80004968:	48 c9       	lddpc	r9,80004998 <xcmp_DeviceInitializationStatus_request+0x40>
8000496a:	13 8a       	ld.ub	r10,r9[0x0]
8000496c:	b0 8a       	st.b	r8[0x0],r10
	ptr->XCMPVersion[1] = XCMP_Version[1];
8000496e:	13 9a       	ld.ub	r10,r9[0x1]
80004970:	b0 9a       	st.b	r8[0x1],r10
	ptr->XCMPVersion[2] = XCMP_Version[2];
80004972:	13 aa       	ld.ub	r10,r9[0x2]
80004974:	b0 aa       	st.b	r8[0x2],r10
	ptr->XCMPVersion[3] = XCMP_Version[3];
80004976:	13 b9       	ld.ub	r9,r9[0x3]
80004978:	b0 b9       	st.b	r8[0x3],r9
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
8000497a:	30 09       	mov	r9,0
8000497c:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
8000497e:	30 7a       	mov	r10,7
80004980:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80004982:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80004984:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80004986:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
8000498a:	30 9b       	mov	r11,9
8000498c:	fa cc ff fe 	sub	r12,sp,-2
80004990:	f0 1f 00 03 	mcall	8000499c <xcmp_DeviceInitializationStatus_request+0x44>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80004994:	2c dd       	sub	sp,-204
80004996:	d8 02       	popm	pc
80004998:	00 00       	add	r0,r0
8000499a:	0e 18       	sub	r8,r7
8000499c:	80 00       	ld.sh	r0,r0[0x0]
8000499e:	48 80       	lddpc	r0,800049bc <xcmp_opcode_not_supported+0x1c>

800049a0 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
800049a0:	d4 01       	pushm	lr
800049a2:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
800049a6:	fe 78 80 00 	mov	r8,-32768
800049aa:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
800049ac:	30 38       	mov	r8,3
800049ae:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
800049b0:	30 1b       	mov	r11,1
800049b2:	fa cc ff fe 	sub	r12,sp,-2
800049b6:	f0 1f 00 03 	mcall	800049c0 <xcmp_opcode_not_supported+0x20>
}
800049ba:	2c dd       	sub	sp,-204
800049bc:	d8 02       	popm	pc
800049be:	00 00       	add	r0,r0
800049c0:	80 00       	ld.sh	r0,r0[0x0]
800049c2:	48 80       	lddpc	r0,800049e0 <xcmp_exec_func+0x1c>

800049c4 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
800049c4:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
800049c6:	96 88       	ld.uh	r8,r11[0x0]
800049c8:	e2 18 f0 00 	andl	r8,0xf000,COH
800049cc:	e0 48 80 00 	cp.w	r8,32768
800049d0:	c0 f0       	breq	800049ee <xcmp_exec_func+0x2a>
800049d2:	e0 48 b0 00 	cp.w	r8,45056
800049d6:	c1 20       	breq	800049fa <xcmp_exec_func+0x36>
800049d8:	58 08       	cp.w	r8,0
800049da:	c1 51       	brne	80004a04 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
800049dc:	78 08       	ld.w	r8,r12[0x0]
800049de:	58 08       	cp.w	r8,0
800049e0:	c0 40       	breq	800049e8 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
800049e2:	16 9c       	mov	r12,r11
800049e4:	5d 18       	icall	r8
800049e6:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
800049e8:	f0 1f 00 08 	mcall	80004a08 <xcmp_exec_func+0x44>
800049ec:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
800049ee:	78 18       	ld.w	r8,r12[0x4]
800049f0:	58 08       	cp.w	r8,0
800049f2:	c0 90       	breq	80004a04 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
800049f4:	16 9c       	mov	r12,r11
800049f6:	5d 18       	icall	r8
800049f8:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
800049fa:	78 28       	ld.w	r8,r12[0x8]
800049fc:	58 08       	cp.w	r8,0
800049fe:	c0 30       	breq	80004a04 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004a00:	16 9c       	mov	r12,r11
80004a02:	5d 18       	icall	r8
80004a04:	d8 02       	popm	pc
80004a06:	00 00       	add	r0,r0
80004a08:	80 00       	ld.sh	r0,r0[0x0]
80004a0a:	49 a0       	lddpc	r0,80004a70 <xcmp_init+0x4>

80004a0c <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80004a0c:	d4 01       	pushm	lr
80004a0e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80004a12:	e0 68 04 09 	mov	r8,1033
80004a16:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004a18:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80004a1c:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
80004a1e:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
80004a22:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80004a24:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80004a26:	30 09       	mov	r9,0
80004a28:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80004a2a:	fb 69 00 08 	st.b	sp[8],r9
80004a2e:	fa c8 ff f7 	sub	r8,sp,-9
80004a32:	b0 89       	st.b	r8[0x0],r9
80004a34:	fa c8 ff f6 	sub	r8,sp,-10
80004a38:	b0 89       	st.b	r8[0x0],r9
80004a3a:	fa c8 ff f5 	sub	r8,sp,-11
80004a3e:	b0 89       	st.b	r8[0x0],r9
80004a40:	fa c8 ff f4 	sub	r8,sp,-12
80004a44:	b0 89       	st.b	r8[0x0],r9
80004a46:	fa c8 ff f3 	sub	r8,sp,-13
80004a4a:	b0 89       	st.b	r8[0x0],r9
80004a4c:	fa c8 ff f2 	sub	r8,sp,-14
80004a50:	b0 89       	st.b	r8[0x0],r9
80004a52:	fa c8 ff f1 	sub	r8,sp,-15
80004a56:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80004a58:	30 cb       	mov	r11,12
80004a5a:	fa cc ff fe 	sub	r12,sp,-2
80004a5e:	f0 1f 00 03 	mcall	80004a68 <xcmp_IdleTestTone+0x5c>
}
80004a62:	2c dd       	sub	sp,-204
80004a64:	d8 02       	popm	pc
80004a66:	00 00       	add	r0,r0
80004a68:	80 00       	ld.sh	r0,r0[0x0]
80004a6a:	48 80       	lddpc	r0,80004a88 <xcmp_init+0x1c>

80004a6c <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80004a6c:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80004a6e:	48 dc       	lddpc	r12,80004aa0 <xcmp_init+0x34>
80004a70:	f0 1f 00 0d 	mcall	80004aa4 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004a74:	30 4b       	mov	r11,4
80004a76:	31 4c       	mov	r12,20
80004a78:	f0 1f 00 0c 	mcall	80004aa8 <xcmp_init+0x3c>
80004a7c:	48 c8       	lddpc	r8,80004aac <xcmp_init+0x40>
80004a7e:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80004a80:	30 09       	mov	r9,0
80004a82:	1a d9       	st.w	--sp,r9
80004a84:	1a d9       	st.w	--sp,r9
80004a86:	1a d9       	st.w	--sp,r9
80004a88:	30 38       	mov	r8,3
80004a8a:	e0 6a 04 00 	mov	r10,1024
80004a8e:	48 9b       	lddpc	r11,80004ab0 <xcmp_init+0x44>
80004a90:	48 9c       	lddpc	r12,80004ab4 <xcmp_init+0x48>
80004a92:	f0 1f 00 0a 	mcall	80004ab8 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80004a96:	f0 1f 00 0a 	mcall	80004abc <xcmp_init+0x50>
80004a9a:	2f dd       	sub	sp,-12
	
}
80004a9c:	d8 02       	popm	pc
80004a9e:	00 00       	add	r0,r0
80004aa0:	80 00       	ld.sh	r0,r0[0x0]
80004aa2:	4b bc       	lddpc	r12,80004b8c <xcmp_rx_process+0xcc>
80004aa4:	80 00       	ld.sh	r0,r0[0x0]
80004aa6:	4c 08       	lddpc	r8,80004ba4 <xcmp_rx_process+0xe4>
80004aa8:	80 00       	ld.sh	r0,r0[0x0]
80004aaa:	74 e4       	ld.w	r4,r10[0x38]
80004aac:	00 00       	add	r0,r0
80004aae:	0b 2c       	ld.uh	r12,r5++
80004ab0:	80 00       	ld.sh	r0,r0[0x0]
80004ab2:	e9 c8 80 00 	stm	r8,pc
80004ab6:	4a c0       	lddpc	r0,80004b64 <xcmp_rx_process+0xa4>
80004ab8:	80 00       	ld.sh	r0,r0[0x0]
80004aba:	7c 00       	ld.w	r0,lr[0x0]
80004abc:	80 00       	ld.sh	r0,r0[0x0]
80004abe:	4c 40       	lddpc	r0,80004bcc <xcmp_rx+0x10>

80004ac0 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004ac0:	d4 31       	pushm	r0-r7,lr
80004ac2:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004ac4:	4b 16       	lddpc	r6,80004b88 <xcmp_rx_process+0xc8>
80004ac6:	30 05       	mov	r5,0
80004ac8:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004aca:	4b 13       	lddpc	r3,80004b8c <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004acc:	4b 12       	lddpc	r2,80004b90 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004ace:	4b 21       	lddpc	r1,80004b94 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004ad0:	4b 20       	lddpc	r0,80004b98 <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004ad2:	6c 0c       	ld.w	r12,r6[0x0]
80004ad4:	0a 99       	mov	r9,r5
80004ad6:	08 9a       	mov	r10,r4
80004ad8:	1a 9b       	mov	r11,sp
80004ada:	f0 1f 00 31 	mcall	80004b9c <xcmp_rx_process+0xdc>
80004ade:	58 1c       	cp.w	r12,1
80004ae0:	cf 91       	brne	80004ad2 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80004ae2:	40 0b       	lddsp	r11,sp[0x0]
80004ae4:	58 0b       	cp.w	r11,0
80004ae6:	cf 60       	breq	80004ad2 <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
80004ae8:	96 0a       	ld.sh	r10,r11[0x0]
80004aea:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004aee:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80004af2:	59 c8       	cp.w	r8,28
80004af4:	c1 e0       	breq	80004b30 <xcmp_rx_process+0x70>
80004af6:	e0 89 00 07 	brgt	80004b04 <xcmp_rx_process+0x44>
80004afa:	58 e8       	cp.w	r8,14
80004afc:	c0 e0       	breq	80004b18 <xcmp_rx_process+0x58>
80004afe:	58 f8       	cp.w	r8,15
80004b00:	c2 41       	brne	80004b48 <xcmp_rx_process+0x88>
80004b02:	c0 f8       	rjmp	80004b20 <xcmp_rx_process+0x60>
80004b04:	e0 48 01 09 	cp.w	r8,265
80004b08:	c1 80       	breq	80004b38 <xcmp_rx_process+0x78>
80004b0a:	e0 48 01 0a 	cp.w	r8,266
80004b0e:	c1 90       	breq	80004b40 <xcmp_rx_process+0x80>
80004b10:	e0 48 00 2c 	cp.w	r8,44
80004b14:	c1 a1       	brne	80004b48 <xcmp_rx_process+0x88>
80004b16:	c0 98       	rjmp	80004b28 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004b18:	4a 2c       	lddpc	r12,80004ba0 <xcmp_rx_process+0xe0>
80004b1a:	f0 1f 00 23 	mcall	80004ba4 <xcmp_rx_process+0xe4>
					break;
80004b1e:	c2 f8       	rjmp	80004b7c <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004b20:	4a 2c       	lddpc	r12,80004ba8 <xcmp_rx_process+0xe8>
80004b22:	f0 1f 00 21 	mcall	80004ba4 <xcmp_rx_process+0xe4>
					break;
80004b26:	c2 b8       	rjmp	80004b7c <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004b28:	4a 1c       	lddpc	r12,80004bac <xcmp_rx_process+0xec>
80004b2a:	f0 1f 00 1f 	mcall	80004ba4 <xcmp_rx_process+0xe4>
					break;
80004b2e:	c2 78       	rjmp	80004b7c <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004b30:	04 9c       	mov	r12,r2
80004b32:	f0 1f 00 1d 	mcall	80004ba4 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80004b36:	c2 38       	rjmp	80004b7c <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004b38:	02 9c       	mov	r12,r1
80004b3a:	f0 1f 00 1b 	mcall	80004ba4 <xcmp_rx_process+0xe4>
					break;
80004b3e:	c1 f8       	rjmp	80004b7c <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004b40:	00 9c       	mov	r12,r0
80004b42:	f0 1f 00 19 	mcall	80004ba4 <xcmp_rx_process+0xe4>
					break;
80004b46:	c1 b8       	rjmp	80004b7c <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004b48:	12 98       	mov	r8,r9
80004b4a:	e2 18 04 00 	andl	r8,0x400,COH
80004b4e:	c0 70       	breq	80004b5c <xcmp_rx_process+0x9c>
80004b50:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004b54:	e0 48 00 68 	cp.w	r8,104
80004b58:	e0 8a 00 08 	brle	80004b68 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004b5c:	e2 19 f0 00 	andl	r9,0xf000,COH
80004b60:	c0 e1       	brne	80004b7c <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80004b62:	f0 1f 00 14 	mcall	80004bb0 <xcmp_rx_process+0xf0>
80004b66:	c0 b8       	rjmp	80004b7c <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004b68:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80004b6c:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80004b70:	49 19       	lddpc	r9,80004bb4 <xcmp_rx_process+0xf4>
80004b72:	72 08       	ld.w	r8,r9[0x0]
80004b74:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004b78:	f0 1f 00 0b 	mcall	80004ba4 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004b7c:	66 0c       	ld.w	r12,r3[0x0]
80004b7e:	40 0b       	lddsp	r11,sp[0x0]
80004b80:	f0 1f 00 0e 	mcall	80004bb8 <xcmp_rx_process+0xf8>
80004b84:	ca 7b       	rjmp	80004ad2 <xcmp_rx_process+0x12>
80004b86:	00 00       	add	r0,r0
80004b88:	00 00       	add	r0,r0
80004b8a:	0b 2c       	ld.uh	r12,r5++
80004b8c:	00 00       	add	r0,r0
80004b8e:	0a c4       	st.b	r5++,r4
80004b90:	00 00       	add	r0,r0
80004b92:	0b 3c       	ld.ub	r12,r5++
80004b94:	00 00       	add	r0,r0
80004b96:	0b 30       	ld.ub	r0,r5++
80004b98:	00 00       	add	r0,r0
80004b9a:	0b 20       	ld.uh	r0,r5++
80004b9c:	80 00       	ld.sh	r0,r0[0x0]
80004b9e:	71 80       	ld.w	r0,r8[0x60]
80004ba0:	00 00       	add	r0,r0
80004ba2:	0b 54       	ld.sh	r4,--r5
80004ba4:	80 00       	ld.sh	r0,r0[0x0]
80004ba6:	49 c4       	lddpc	r4,80004c14 <xnl_get_msg_ack_func>
80004ba8:	00 00       	add	r0,r0
80004baa:	0b 14       	ld.sh	r4,r5++
80004bac:	00 00       	add	r0,r0
80004bae:	0b 48       	ld.w	r8,--r5
80004bb0:	80 00       	ld.sh	r0,r0[0x0]
80004bb2:	49 a0       	lddpc	r0,80004c18 <xnl_get_msg_ack_func+0x4>
80004bb4:	00 00       	add	r0,r0
80004bb6:	97 a4       	st.w	r11[0x28],r4
80004bb8:	80 00       	ld.sh	r0,r0[0x0]
80004bba:	35 9c       	mov	r12,89

80004bbc <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004bbc:	eb cd 40 90 	pushm	r4,r7,lr
80004bc0:	20 1d       	sub	sp,4
80004bc2:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004bc6:	48 c8       	lddpc	r8,80004bf4 <xcmp_rx+0x38>
80004bc8:	70 0c       	ld.w	r12,r8[0x0]
80004bca:	f0 1f 00 0c 	mcall	80004bf8 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80004bce:	c1 00       	breq	80004bee <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004bd0:	fa c7 ff fc 	sub	r7,sp,-4
80004bd4:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004bd6:	e0 6a 00 ca 	mov	r10,202
80004bda:	08 9b       	mov	r11,r4
80004bdc:	f0 1f 00 08 	mcall	80004bfc <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004be0:	48 88       	lddpc	r8,80004c00 <xcmp_rx+0x44>
80004be2:	70 0c       	ld.w	r12,r8[0x0]
80004be4:	30 09       	mov	r9,0
80004be6:	12 9a       	mov	r10,r9
80004be8:	1a 9b       	mov	r11,sp
80004bea:	f0 1f 00 07 	mcall	80004c04 <xcmp_rx+0x48>
	}	
}
80004bee:	2f fd       	sub	sp,-4
80004bf0:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004bf4:	00 00       	add	r0,r0
80004bf6:	0a c4       	st.b	r5++,r4
80004bf8:	80 00       	ld.sh	r0,r0[0x0]
80004bfa:	37 48       	mov	r8,116
80004bfc:	80 00       	ld.sh	r0,r0[0x0]
80004bfe:	88 6e       	ld.sh	lr,r4[0xc]
80004c00:	00 00       	add	r0,r0
80004c02:	0b 2c       	ld.uh	r12,r5++
80004c04:	80 00       	ld.sh	r0,r0[0x0]
80004c06:	73 8c       	ld.w	r12,r9[0x60]

80004c08 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004c08:	48 28       	lddpc	r8,80004c10 <xnl_register_xcmp_func+0x8>
80004c0a:	91 0c       	st.w	r8[0x0],r12
}
80004c0c:	5e fc       	retal	r12
80004c0e:	00 00       	add	r0,r0
80004c10:	00 00       	add	r0,r0
80004c12:	0b 78       	ld.ub	r8,--r5

80004c14 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004c14:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004c16:	48 88       	lddpc	r8,80004c34 <xnl_get_msg_ack_func+0x20>
80004c18:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004c1a:	98 49       	ld.sh	r9,r12[0x8]
80004c1c:	f0 09 19 00 	cp.h	r9,r8
80004c20:	c0 81       	brne	80004c30 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80004c22:	48 68       	lddpc	r8,80004c38 <xnl_get_msg_ack_func+0x24>
80004c24:	70 0c       	ld.w	r12,r8[0x0]
80004c26:	30 09       	mov	r9,0
80004c28:	12 9a       	mov	r10,r9
80004c2a:	12 9b       	mov	r11,r9
80004c2c:	f0 1f 00 04 	mcall	80004c3c <xnl_get_msg_ack_func+0x28>
80004c30:	d8 02       	popm	pc
80004c32:	00 00       	add	r0,r0
80004c34:	00 00       	add	r0,r0
80004c36:	0e 26       	rsub	r6,r7
80004c38:	00 00       	add	r0,r0
80004c3a:	0b 60       	ld.uh	r0,--r5
80004c3c:	80 00       	ld.sh	r0,r0[0x0]
80004c3e:	73 8c       	ld.w	r12,r9[0x60]

80004c40 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004c40:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
80004c44:	30 09       	mov	r9,0
80004c46:	4b 78       	lddpc	r8,80004d20 <xnl_init+0xe0>
80004c48:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004c4a:	30 0b       	mov	r11,0
80004c4c:	30 1c       	mov	r12,1
80004c4e:	f0 1f 00 36 	mcall	80004d24 <xnl_init+0xe4>
80004c52:	4b 68       	lddpc	r8,80004d28 <xnl_init+0xe8>
80004c54:	91 0c       	st.w	r8[0x0],r12
80004c56:	70 08       	ld.w	r8,r8[0x0]
80004c58:	58 08       	cp.w	r8,0
80004c5a:	c0 80       	breq	80004c6a <xnl_init+0x2a>
80004c5c:	4b 38       	lddpc	r8,80004d28 <xnl_init+0xe8>
80004c5e:	70 0c       	ld.w	r12,r8[0x0]
80004c60:	30 09       	mov	r9,0
80004c62:	12 9a       	mov	r10,r9
80004c64:	12 9b       	mov	r11,r9
80004c66:	f0 1f 00 32 	mcall	80004d2c <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(60, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80004c6a:	30 4b       	mov	r11,4
80004c6c:	33 cc       	mov	r12,60
80004c6e:	f0 1f 00 2e 	mcall	80004d24 <xnl_init+0xe4>
80004c72:	4b 08       	lddpc	r8,80004d30 <xnl_init+0xf0>
80004c74:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80004c76:	30 4b       	mov	r11,4
80004c78:	36 4c       	mov	r12,100
80004c7a:	f0 1f 00 2b 	mcall	80004d24 <xnl_init+0xe4>
80004c7e:	4a e8       	lddpc	r8,80004d34 <xnl_init+0xf4>
80004c80:	91 0c       	st.w	r8[0x0],r12
80004c82:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004c84:	10 96       	mov	r6,r8
80004c86:	4a d5       	lddpc	r5,80004d38 <xnl_init+0xf8>
80004c88:	6c 0c       	ld.w	r12,r6[0x0]
80004c8a:	ea 07 00 0b 	add	r11,r5,r7
80004c8e:	f0 1f 00 2c 	mcall	80004d3c <xnl_init+0xfc>
80004c92:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(60, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004c96:	e0 47 64 00 	cp.w	r7,25600
80004c9a:	cf 71       	brne	80004c88 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004c9c:	30 4b       	mov	r11,4
80004c9e:	33 2c       	mov	r12,50
80004ca0:	f0 1f 00 21 	mcall	80004d24 <xnl_init+0xe4>
80004ca4:	4a 78       	lddpc	r8,80004d40 <xnl_init+0x100>
80004ca6:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004ca8:	30 4b       	mov	r11,4
80004caa:	32 8c       	mov	r12,40
80004cac:	f0 1f 00 1e 	mcall	80004d24 <xnl_init+0xe4>
80004cb0:	4a 58       	lddpc	r8,80004d44 <xnl_init+0x104>
80004cb2:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004cb4:	30 4b       	mov	r11,4
80004cb6:	30 ac       	mov	r12,10
80004cb8:	f0 1f 00 1b 	mcall	80004d24 <xnl_init+0xe4>
80004cbc:	4a 38       	lddpc	r8,80004d48 <xnl_init+0x108>
80004cbe:	91 0c       	st.w	r8[0x0],r12
80004cc0:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80004cc2:	10 96       	mov	r6,r8
80004cc4:	4a 25       	lddpc	r5,80004d4c <xnl_init+0x10c>
80004cc6:	6c 0c       	ld.w	r12,r6[0x0]
80004cc8:	ea 07 00 0b 	add	r11,r5,r7
80004ccc:	f0 1f 00 1c 	mcall	80004d3c <xnl_init+0xfc>
80004cd0:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004cd4:	e0 47 14 00 	cp.w	r7,5120
80004cd8:	cf 71       	brne	80004cc6 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004cda:	30 4b       	mov	r11,4
80004cdc:	30 5c       	mov	r12,5
80004cde:	f0 1f 00 12 	mcall	80004d24 <xnl_init+0xe4>
80004ce2:	49 c8       	lddpc	r8,80004d50 <xnl_init+0x110>
80004ce4:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004ce6:	30 07       	mov	r7,0
80004ce8:	1a d7       	st.w	--sp,r7
80004cea:	1a d7       	st.w	--sp,r7
80004cec:	1a d7       	st.w	--sp,r7
80004cee:	30 38       	mov	r8,3
80004cf0:	0e 99       	mov	r9,r7
80004cf2:	e0 6a 00 dc 	mov	r10,220
80004cf6:	49 8b       	lddpc	r11,80004d54 <xnl_init+0x114>
80004cf8:	49 8c       	lddpc	r12,80004d58 <xnl_init+0x118>
80004cfa:	f0 1f 00 19 	mcall	80004d5c <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004cfe:	1a d7       	st.w	--sp,r7
80004d00:	1a d7       	st.w	--sp,r7
80004d02:	1a d7       	st.w	--sp,r7
80004d04:	30 38       	mov	r8,3
80004d06:	0e 99       	mov	r9,r7
80004d08:	e0 6a 00 82 	mov	r10,130
80004d0c:	49 5b       	lddpc	r11,80004d60 <xnl_init+0x120>
80004d0e:	49 6c       	lddpc	r12,80004d64 <xnl_init+0x124>
80004d10:	f0 1f 00 13 	mcall	80004d5c <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004d14:	f0 1f 00 15 	mcall	80004d68 <xnl_init+0x128>
80004d18:	2f ad       	sub	sp,-24
}
80004d1a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004d1e:	00 00       	add	r0,r0
80004d20:	00 00       	add	r0,r0
80004d22:	0e 26       	rsub	r6,r7
80004d24:	80 00       	ld.sh	r0,r0[0x0]
80004d26:	74 e4       	ld.w	r4,r10[0x38]
80004d28:	00 00       	add	r0,r0
80004d2a:	0b 60       	ld.uh	r0,--r5
80004d2c:	80 00       	ld.sh	r0,r0[0x0]
80004d2e:	73 8c       	ld.w	r12,r9[0x60]
80004d30:	00 00       	add	r0,r0
80004d32:	0b 6c       	ld.uh	r12,--r5
80004d34:	00 00       	add	r0,r0
80004d36:	0a c4       	st.b	r5++,r4
80004d38:	00 00       	add	r0,r0
80004d3a:	33 56       	mov	r6,53
80004d3c:	80 00       	ld.sh	r0,r0[0x0]
80004d3e:	35 9c       	mov	r12,89
80004d40:	00 00       	add	r0,r0
80004d42:	0a f4       	st.b	--r5,r4
80004d44:	00 00       	add	r0,r0
80004d46:	0a d4       	st.w	--r5,r4
80004d48:	00 00       	add	r0,r0
80004d4a:	0a c8       	st.b	r5++,r8
80004d4c:	00 00       	add	r0,r0
80004d4e:	1f 56       	ld.sh	r6,--pc
80004d50:	00 00       	add	r0,r0
80004d52:	0b 00       	ld.w	r0,r5++
80004d54:	80 00       	ld.sh	r0,r0[0x0]
80004d56:	e9 d0 80 00 	ldswp.w	r0,r4[0]
80004d5a:	4d 6c       	lddpc	r12,80004eb0 <xnl_tx+0x18>
80004d5c:	80 00       	ld.sh	r0,r0[0x0]
80004d5e:	7c 00       	ld.w	r0,lr[0x0]
80004d60:	80 00       	ld.sh	r0,r0[0x0]
80004d62:	e9 d8 80 00 	ldswp.w	r8,r4[0]
80004d66:	4d cc       	lddpc	r12,80004ed4 <xnl_tx+0x3c>
80004d68:	80 00       	ld.sh	r0,r0[0x0]
80004d6a:	37 70       	mov	r0,119

80004d6c <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
80004d6c:	eb cd 40 fe 	pushm	r1-r7,lr
80004d70:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004d72:	49 26       	lddpc	r6,80004db8 <xnl_rx_process+0x4c>
80004d74:	30 05       	mov	r5,0
80004d76:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004d78:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004d7a:	49 11       	lddpc	r1,80004dbc <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004d7c:	49 12       	lddpc	r2,80004dc0 <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004d7e:	6c 0c       	ld.w	r12,r6[0x0]
80004d80:	0a 99       	mov	r9,r5
80004d82:	08 9a       	mov	r10,r4
80004d84:	1a 9b       	mov	r11,sp
80004d86:	f0 1f 00 10 	mcall	80004dc4 <xnl_rx_process+0x58>
80004d8a:	58 1c       	cp.w	r12,1
80004d8c:	cf 91       	brne	80004d7e <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80004d8e:	40 0c       	lddsp	r12,sp[0x0]
80004d90:	58 0c       	cp.w	r12,0
80004d92:	cf 60       	breq	80004d7e <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004d94:	98 28       	ld.sh	r8,r12[0x4]
80004d96:	e6 08 19 00 	cp.h	r8,r3
80004d9a:	e0 8b 00 0a 	brhi	80004dae <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004d9e:	5c 78       	castu.h	r8
80004da0:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004da4:	58 09       	cp.w	r9,0
80004da6:	c0 40       	breq	80004dae <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004da8:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004dac:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004dae:	62 0c       	ld.w	r12,r1[0x0]
80004db0:	40 0b       	lddsp	r11,sp[0x0]
80004db2:	f0 1f 00 06 	mcall	80004dc8 <xnl_rx_process+0x5c>
80004db6:	ce 4b       	rjmp	80004d7e <xnl_rx_process+0x12>
80004db8:	00 00       	add	r0,r0
80004dba:	0a d4       	st.w	--r5,r4
80004dbc:	00 00       	add	r0,r0
80004dbe:	0a c4       	st.b	r5++,r4
80004dc0:	00 00       	add	r0,r0
80004dc2:	05 00       	ld.w	r0,r2++
80004dc4:	80 00       	ld.sh	r0,r0[0x0]
80004dc6:	71 80       	ld.w	r0,r8[0x60]
80004dc8:	80 00       	ld.sh	r0,r0[0x0]
80004dca:	35 9c       	mov	r12,89

80004dcc <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
80004dcc:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004dce:	4a a6       	lddpc	r6,80004e74 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004dd0:	4a a2       	lddpc	r2,80004e78 <xnl_tx_process+0xac>
80004dd2:	4a b4       	lddpc	r4,80004e7c <xnl_tx_process+0xb0>
80004dd4:	30 07       	mov	r7,0
80004dd6:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004dd8:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004dda:	4a a5       	lddpc	r5,80004e80 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004ddc:	4a a3       	lddpc	r3,80004e84 <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004dde:	6c 08       	ld.w	r8,r6[0x0]
80004de0:	58 08       	cp.w	r8,0
80004de2:	c0 40       	breq	80004dea <xnl_tx_process+0x1e>
80004de4:	58 18       	cp.w	r8,1
80004de6:	cf d1       	brne	80004de0 <xnl_tx_process+0x14>
80004de8:	c2 48       	rjmp	80004e30 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004dea:	64 0c       	ld.w	r12,r2[0x0]
80004dec:	0e 99       	mov	r9,r7
80004dee:	02 9a       	mov	r10,r1
80004df0:	08 9b       	mov	r11,r4
80004df2:	f0 1f 00 26 	mcall	80004e88 <xnl_tx_process+0xbc>
80004df6:	58 1c       	cp.w	r12,1
80004df8:	cf 31       	brne	80004dde <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004dfa:	68 0b       	ld.w	r11,r4[0x0]
80004dfc:	58 0b       	cp.w	r11,0
80004dfe:	cf 00       	breq	80004dde <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004e00:	96 28       	ld.sh	r8,r11[0x4]
80004e02:	e0 08 19 00 	cp.h	r8,r0
80004e06:	c0 71       	brne	80004e14 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004e08:	4a 18       	lddpc	r8,80004e8c <xnl_tx_process+0xc0>
80004e0a:	70 08       	ld.w	r8,r8[0x0]
80004e0c:	10 9c       	mov	r12,r8
80004e0e:	f0 1f 00 21 	mcall	80004e90 <xnl_tx_process+0xc4>
						break;
80004e12:	ce 6b       	rjmp	80004dde <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004e14:	16 9c       	mov	r12,r11
80004e16:	f0 1f 00 20 	mcall	80004e94 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004e1a:	30 18       	mov	r8,1
80004e1c:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004e1e:	66 0c       	ld.w	r12,r3[0x0]
80004e20:	0e 99       	mov	r9,r7
80004e22:	0e 9a       	mov	r10,r7
80004e24:	0e 9b       	mov	r11,r7
80004e26:	f0 1f 00 19 	mcall	80004e88 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
80004e2a:	30 18       	mov	r8,1
80004e2c:	8d 08       	st.w	r6[0x0],r8
80004e2e:	cd 8b       	rjmp	80004dde <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004e30:	66 0c       	ld.w	r12,r3[0x0]
80004e32:	0e 99       	mov	r9,r7
80004e34:	36 4a       	mov	r10,100
80004e36:	0e 9b       	mov	r11,r7
80004e38:	f0 1f 00 14 	mcall	80004e88 <xnl_tx_process+0xbc>
80004e3c:	58 1c       	cp.w	r12,1
80004e3e:	c0 81       	brne	80004e4e <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
80004e40:	49 38       	lddpc	r8,80004e8c <xnl_tx_process+0xc0>
80004e42:	70 0c       	ld.w	r12,r8[0x0]
80004e44:	68 0b       	ld.w	r11,r4[0x0]
80004e46:	f0 1f 00 13 	mcall	80004e90 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80004e4a:	8d 07       	st.w	r6[0x0],r7
80004e4c:	cc 9b       	rjmp	80004dde <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004e4e:	6a 08       	ld.w	r8,r5[0x0]
80004e50:	58 38       	cp.w	r8,3
80004e52:	e0 89 00 09 	brgt	80004e64 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80004e56:	68 0c       	ld.w	r12,r4[0x0]
80004e58:	f0 1f 00 0f 	mcall	80004e94 <xnl_tx_process+0xc8>
						xnl_send_times++;
80004e5c:	6a 08       	ld.w	r8,r5[0x0]
80004e5e:	2f f8       	sub	r8,-1
80004e60:	8b 08       	st.w	r5[0x0],r8
80004e62:	cb eb       	rjmp	80004dde <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004e64:	48 a8       	lddpc	r8,80004e8c <xnl_tx_process+0xc0>
80004e66:	70 0c       	ld.w	r12,r8[0x0]
80004e68:	68 0b       	ld.w	r11,r4[0x0]
80004e6a:	f0 1f 00 0a 	mcall	80004e90 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80004e6e:	8d 07       	st.w	r6[0x0],r7
80004e70:	cb 7b       	rjmp	80004dde <xnl_tx_process+0x12>
80004e72:	00 00       	add	r0,r0
80004e74:	00 00       	add	r0,r0
80004e76:	0b 68       	ld.uh	r8,--r5
80004e78:	00 00       	add	r0,r0
80004e7a:	0b 6c       	ld.uh	r12,--r5
80004e7c:	00 00       	add	r0,r0
80004e7e:	0b 74       	ld.ub	r4,--r5
80004e80:	00 00       	add	r0,r0
80004e82:	0b 70       	ld.ub	r0,--r5
80004e84:	00 00       	add	r0,r0
80004e86:	0b 60       	ld.uh	r0,--r5
80004e88:	80 00       	ld.sh	r0,r0[0x0]
80004e8a:	71 80       	ld.w	r0,r8[0x60]
80004e8c:	00 00       	add	r0,r0
80004e8e:	0a c4       	st.b	r5++,r4
80004e90:	80 00       	ld.sh	r0,r0[0x0]
80004e92:	35 9c       	mov	r12,89
80004e94:	80 00       	ld.sh	r0,r0[0x0]
80004e96:	35 bc       	mov	r12,91

80004e98 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004e98:	eb cd 40 c0 	pushm	r6-r7,lr
80004e9c:	20 1d       	sub	sp,4
80004e9e:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004ea0:	98 39       	ld.sh	r9,r12[0x6]
80004ea2:	3f f8       	mov	r8,-1
80004ea4:	f0 09 19 00 	cp.h	r9,r8
80004ea8:	c0 a1       	brne	80004ebc <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004eaa:	4a e9       	lddpc	r9,80004f60 <xnl_tx+0xc8>
80004eac:	13 88       	ld.ub	r8,r9[0x0]
80004eae:	2f f8       	sub	r8,-1
80004eb0:	5c 58       	castu.b	r8
80004eb2:	b2 88       	st.b	r9[0x0],r8
80004eb4:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004eb8:	a9 a8       	sbr	r8,0x8
80004eba:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004ebc:	8c 49       	ld.sh	r9,r6[0x8]
80004ebe:	3f f8       	mov	r8,-1
80004ec0:	f0 09 19 00 	cp.h	r9,r8
80004ec4:	c0 41       	brne	80004ecc <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004ec6:	4a 88       	lddpc	r8,80004f64 <xnl_tx+0xcc>
80004ec8:	90 18       	ld.sh	r8,r8[0x2]
80004eca:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004ecc:	8c 59       	ld.sh	r9,r6[0xa]
80004ece:	3f f8       	mov	r8,-1
80004ed0:	f0 09 19 00 	cp.h	r9,r8
80004ed4:	c0 41       	brne	80004edc <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004ed6:	4a 48       	lddpc	r8,80004f64 <xnl_tx+0xcc>
80004ed8:	90 28       	ld.sh	r8,r8[0x4]
80004eda:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004edc:	8c 69       	ld.sh	r9,r6[0xc]
80004ede:	3f f8       	mov	r8,-1
80004ee0:	f0 09 19 00 	cp.h	r9,r8
80004ee4:	c0 e1       	brne	80004f00 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004ee6:	4a 08       	lddpc	r8,80004f64 <xnl_tx+0xcc>
80004ee8:	90 49       	ld.sh	r9,r8[0x8]
80004eea:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004eec:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004eee:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004ef0:	90 49       	ld.sh	r9,r8[0x8]
80004ef2:	e0 19 ff 00 	andl	r9,0xff00
80004ef6:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004efa:	f3 e8 10 08 	or	r8,r9,r8
80004efe:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004f00:	0d 98       	ld.ub	r8,r6[0x1]
80004f02:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004f04:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004f08:	10 0c       	add	r12,r8
80004f0a:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004f0c:	58 0c       	cp.w	r12,0
80004f0e:	e0 89 00 04 	brgt	80004f16 <xnl_tx+0x7e>
80004f12:	30 09       	mov	r9,0
80004f14:	c0 d8       	rjmp	80004f2e <xnl_tx+0x96>
80004f16:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004f1a:	2f ec       	sub	r12,-2
80004f1c:	30 09       	mov	r9,0
80004f1e:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004f20:	15 1b       	ld.sh	r11,r10++
80004f22:	f6 09 00 09 	add	r9,r11,r9
80004f26:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004f28:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004f2a:	18 38       	cp.w	r8,r12
80004f2c:	cf a1       	brne	80004f20 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004f2e:	5c 39       	neg	r9
80004f30:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004f32:	48 e8       	lddpc	r8,80004f68 <xnl_tx+0xd0>
80004f34:	70 0c       	ld.w	r12,r8[0x0]
80004f36:	f0 1f 00 0e 	mcall	80004f6c <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004f3a:	c1 00       	breq	80004f5a <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004f3c:	fa c7 ff fc 	sub	r7,sp,-4
80004f40:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80004f42:	e0 6a 01 00 	mov	r10,256
80004f46:	0c 9b       	mov	r11,r6
80004f48:	f0 1f 00 0a 	mcall	80004f70 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004f4c:	48 a8       	lddpc	r8,80004f74 <xnl_tx+0xdc>
80004f4e:	70 0c       	ld.w	r12,r8[0x0]
80004f50:	30 09       	mov	r9,0
80004f52:	12 9a       	mov	r10,r9
80004f54:	1a 9b       	mov	r11,sp
80004f56:	f0 1f 00 09 	mcall	80004f78 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004f5a:	2f fd       	sub	sp,-4
80004f5c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004f60:	00 00       	add	r0,r0
80004f62:	0b 64       	ld.uh	r4,--r5
80004f64:	00 00       	add	r0,r0
80004f66:	0e 26       	rsub	r6,r7
80004f68:	00 00       	add	r0,r0
80004f6a:	0a c4       	st.b	r5++,r4
80004f6c:	80 00       	ld.sh	r0,r0[0x0]
80004f6e:	37 48       	mov	r8,116
80004f70:	80 00       	ld.sh	r0,r0[0x0]
80004f72:	88 6e       	ld.sh	lr,r4[0xc]
80004f74:	00 00       	add	r0,r0
80004f76:	0b 6c       	ld.uh	r12,--r5
80004f78:	80 00       	ld.sh	r0,r0[0x0]
80004f7a:	73 8c       	ld.w	r12,r9[0x60]

80004f7c <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004f7c:	eb cd 40 80 	pushm	r7,lr
80004f80:	fa cd 01 00 	sub	sp,sp,256
80004f84:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004f86:	e0 68 40 0e 	mov	r8,16398
80004f8a:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004f8c:	3f f8       	mov	r8,-1
80004f8e:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004f90:	30 c8       	mov	r8,12
80004f92:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004f94:	98 38       	ld.sh	r8,r12[0x6]
80004f96:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004f98:	98 58       	ld.sh	r8,r12[0xa]
80004f9a:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004f9c:	98 48       	ld.sh	r8,r12[0x8]
80004f9e:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004fa0:	98 68       	ld.sh	r8,r12[0xc]
80004fa2:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004fa4:	30 08       	mov	r8,0
80004fa6:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004fa8:	1a 9c       	mov	r12,sp
80004faa:	f0 1f 00 0a 	mcall	80004fd0 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80004fae:	fa cd 00 cc 	sub	sp,sp,204
80004fb2:	e0 6a 00 ca 	mov	r10,202
80004fb6:	ee cb ff f0 	sub	r11,r7,-16
80004fba:	1a 9c       	mov	r12,sp
80004fbc:	f0 1f 00 06 	mcall	80004fd4 <xnl_data_msg_func+0x58>
80004fc0:	48 68       	lddpc	r8,80004fd8 <xnl_data_msg_func+0x5c>
80004fc2:	70 08       	ld.w	r8,r8[0x0]
80004fc4:	5d 18       	icall	r8
80004fc6:	fa cd ff 34 	sub	sp,sp,-204
}
80004fca:	2c 0d       	sub	sp,-256
80004fcc:	e3 cd 80 80 	ldm	sp++,r7,pc
80004fd0:	80 00       	ld.sh	r0,r0[0x0]
80004fd2:	4e 98       	lddpc	r8,80005174 <xnl_device_conn_reply_func+0x18>
80004fd4:	80 00       	ld.sh	r0,r0[0x0]
80004fd6:	88 6e       	ld.sh	lr,r4[0xc]
80004fd8:	00 00       	add	r0,r0
80004fda:	0b 78       	ld.ub	r8,--r5

80004fdc <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004fdc:	d4 21       	pushm	r4-r7,lr
80004fde:	fa cd 01 00 	sub	sp,sp,256
80004fe2:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004fe4:	4c 28       	lddpc	r8,800050ec <xnl_device_auth_reply_func+0x110>
80004fe6:	11 88       	ld.ub	r8,r8[0x0]
80004fe8:	58 08       	cp.w	r8,0
80004fea:	e0 81 00 7f 	brne	800050e8 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004fee:	4c 18       	lddpc	r8,800050f0 <xnl_device_auth_reply_func+0x114>
80004ff0:	70 0c       	ld.w	r12,r8[0x0]
80004ff2:	30 09       	mov	r9,0
80004ff4:	12 9a       	mov	r10,r9
80004ff6:	12 9b       	mov	r11,r9
80004ff8:	f0 1f 00 3f 	mcall	800050f4 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004ffc:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80005000:	4b b8       	lddpc	r8,800050ec <xnl_device_auth_reply_func+0x110>
80005002:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80005004:	ef 39 00 12 	ld.ub	r9,r7[18]
80005008:	ef 38 00 13 	ld.ub	r8,r7[19]
8000500c:	b1 68       	lsl	r8,0x10
8000500e:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80005012:	ef 38 00 15 	ld.ub	r8,r7[21]
80005016:	f3 e8 10 08 	or	r8,r9,r8
8000501a:	ef 39 00 14 	ld.ub	r9,r7[20]
8000501e:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80005022:	ef 3a 00 16 	ld.ub	r10,r7[22]
80005026:	ef 38 00 17 	ld.ub	r8,r7[23]
8000502a:	b1 68       	lsl	r8,0x10
8000502c:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80005030:	ef 38 00 19 	ld.ub	r8,r7[25]
80005034:	f5 e8 10 08 	or	r8,r10,r8
80005038:	ef 3a 00 18 	ld.ub	r10,r7[24]
8000503c:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80005040:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80005042:	e0 64 79 b9 	mov	r4,31161
80005046:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
8000504a:	e0 65 45 07 	mov	r5,17671
8000504e:	ea 15 8a bd 	orh	r5,0x8abd
80005052:	e0 66 f9 3d 	mov	r6,63805
80005056:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
8000505a:	e0 6e b8 cf 	mov	lr,47311
8000505e:	ea 1e 36 83 	orh	lr,0x3683
80005062:	e0 67 aa 1c 	mov	r7,43548
80005066:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000506a:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
8000506c:	f4 08 00 0c 	add	r12,r10,r8
80005070:	f0 0b 15 04 	lsl	r11,r8,0x4
80005074:	0a 0b       	add	r11,r5
80005076:	f9 eb 20 0b 	eor	r11,r12,r11
8000507a:	f0 0c 16 05 	lsr	r12,r8,0x5
8000507e:	0c 0c       	add	r12,r6
80005080:	18 5b       	eor	r11,r12
80005082:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80005084:	f2 0c 15 04 	lsl	r12,r9,0x4
80005088:	1c 0c       	add	r12,lr
8000508a:	f2 0b 16 05 	lsr	r11,r9,0x5
8000508e:	0e 0b       	add	r11,r7
80005090:	f9 eb 20 0b 	eor	r11,r12,r11
80005094:	f2 0a 00 0c 	add	r12,r9,r10
80005098:	18 5b       	eor	r11,r12
8000509a:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
8000509c:	e0 6b 37 20 	mov	r11,14112
800050a0:	ea 1b c6 ef 	orh	r11,0xc6ef
800050a4:	16 3a       	cp.w	r10,r11
800050a6:	ce 21       	brne	8000506a <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
800050a8:	e0 6a 40 1a 	mov	r10,16410
800050ac:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800050ae:	3f fa       	mov	r10,-1
800050b0:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
800050b2:	30 6b       	mov	r11,6
800050b4:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800050b6:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800050b8:	48 db       	lddpc	r11,800050ec <xnl_device_auth_reply_func+0x110>
800050ba:	96 1c       	ld.sh	r12,r11[0x2]
800050bc:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
800050be:	96 2b       	ld.sh	r11,r11[0x4]
800050c0:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800050c2:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
800050c4:	30 ca       	mov	r10,12
800050c6:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
800050c8:	30 0a       	mov	r10,0
800050ca:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
800050ce:	30 7a       	mov	r10,7
800050d0:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
800050d4:	30 2a       	mov	r10,2
800050d6:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800050da:	fa ca ff ec 	sub	r10,sp,-20
800050de:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800050e0:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
800050e2:	1a 9c       	mov	r12,sp
800050e4:	f0 1f 00 05 	mcall	800050f8 <xnl_device_auth_reply_func+0x11c>
}
800050e8:	2c 0d       	sub	sp,-256
800050ea:	d8 22       	popm	r4-r7,pc
800050ec:	00 00       	add	r0,r0
800050ee:	0e 26       	rsub	r6,r7
800050f0:	00 00       	add	r0,r0
800050f2:	0b 60       	ld.uh	r0,--r5
800050f4:	80 00       	ld.sh	r0,r0[0x0]
800050f6:	73 8c       	ld.w	r12,r9[0x60]
800050f8:	80 00       	ld.sh	r0,r0[0x0]
800050fa:	4e 98       	lddpc	r8,8000529c <WriteRawRC+0x24>

800050fc <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
800050fc:	eb cd 40 80 	pushm	r7,lr
80005100:	fa cd 01 00 	sub	sp,sp,256
80005104:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80005106:	49 28       	lddpc	r8,8000514c <xnl_master_status_brdcst_func+0x50>
80005108:	11 88       	ld.ub	r8,r8[0x0]
8000510a:	58 08       	cp.w	r8,0
8000510c:	c1 c1       	brne	80005144 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
8000510e:	49 18       	lddpc	r8,80005150 <xnl_master_status_brdcst_func+0x54>
80005110:	70 0c       	ld.w	r12,r8[0x0]
80005112:	30 09       	mov	r9,0
80005114:	12 9a       	mov	r10,r9
80005116:	12 9b       	mov	r11,r9
80005118:	f0 1f 00 0f 	mcall	80005154 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
8000511c:	8e 58       	ld.sh	r8,r7[0xa]
8000511e:	48 c9       	lddpc	r9,8000514c <xnl_master_status_brdcst_func+0x50>
80005120:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80005122:	e0 68 40 0e 	mov	r8,16398
80005126:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80005128:	3f f8       	mov	r8,-1
8000512a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
8000512c:	30 4a       	mov	r10,4
8000512e:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80005130:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80005132:	92 19       	ld.sh	r9,r9[0x2]
80005134:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80005136:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80005138:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
8000513a:	30 08       	mov	r8,0
8000513c:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
8000513e:	1a 9c       	mov	r12,sp
80005140:	f0 1f 00 06 	mcall	80005158 <xnl_master_status_brdcst_func+0x5c>
}
80005144:	2c 0d       	sub	sp,-256
80005146:	e3 cd 80 80 	ldm	sp++,r7,pc
8000514a:	00 00       	add	r0,r0
8000514c:	00 00       	add	r0,r0
8000514e:	0e 26       	rsub	r6,r7
80005150:	00 00       	add	r0,r0
80005152:	0b 60       	ld.uh	r0,--r5
80005154:	80 00       	ld.sh	r0,r0[0x0]
80005156:	73 8c       	ld.w	r12,r9[0x60]
80005158:	80 00       	ld.sh	r0,r0[0x0]
8000515a:	4e 98       	lddpc	r8,800052fc <PcdReset+0x44>

8000515c <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
8000515c:	eb cd 40 80 	pushm	r7,lr
80005160:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80005162:	49 28       	lddpc	r8,800051a8 <xnl_device_conn_reply_func+0x4c>
80005164:	70 0c       	ld.w	r12,r8[0x0]
80005166:	30 09       	mov	r9,0
80005168:	12 9a       	mov	r10,r9
8000516a:	12 9b       	mov	r11,r9
8000516c:	f0 1f 00 10 	mcall	800051ac <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80005170:	ef 18 00 10 	ld.uh	r8,r7[16]
80005174:	10 99       	mov	r9,r8
80005176:	e2 19 ff 00 	andl	r9,0xff00,COH
8000517a:	e0 49 01 00 	cp.w	r9,256
8000517e:	c0 60       	breq	8000518a <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80005180:	0e 9c       	mov	r12,r7
80005182:	f0 1f 00 0c 	mcall	800051b0 <xnl_device_conn_reply_func+0x54>
80005186:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
8000518a:	a9 68       	lsl	r8,0x8
8000518c:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80005190:	48 98       	lddpc	r8,800051b4 <xnl_device_conn_reply_func+0x58>
80005192:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80005194:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80005198:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
8000519a:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
8000519e:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
800051a0:	30 19       	mov	r9,1
800051a2:	b0 89       	st.b	r8[0x0],r9
800051a4:	e3 cd 80 80 	ldm	sp++,r7,pc
800051a8:	00 00       	add	r0,r0
800051aa:	0b 60       	ld.uh	r0,--r5
800051ac:	80 00       	ld.sh	r0,r0[0x0]
800051ae:	73 8c       	ld.w	r12,r9[0x60]
800051b0:	80 00       	ld.sh	r0,r0[0x0]
800051b2:	50 fc       	stdsp	sp[0x3c],r12
800051b4:	00 00       	add	r0,r0
800051b6:	0e 26       	rsub	r6,r7

800051b8 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
800051b8:	d4 01       	pushm	lr
800051ba:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800051be:	e0 68 40 0e 	mov	r8,16398
800051c2:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800051c4:	3f f8       	mov	r8,-1
800051c6:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
800051c8:	30 38       	mov	r8,3
800051ca:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
800051cc:	30 08       	mov	r8,0
800051ce:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
800051d0:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
800051d2:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
800051d4:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
800051d6:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800051d8:	1a 9c       	mov	r12,sp
800051da:	f0 1f 00 03 	mcall	800051e4 <xnl_send_device_master_query+0x2c>
}
800051de:	2c 0d       	sub	sp,-256
800051e0:	d8 02       	popm	pc
800051e2:	00 00       	add	r0,r0
800051e4:	80 00       	ld.sh	r0,r0[0x0]
800051e6:	4e 98       	lddpc	r8,80005388 <Wait_Wakeup_RC522+0x8>

800051e8 <RC522_SPI_SetSpeed>:
	//SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
800051e8:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
800051ea:	48 78       	lddpc	r8,80005204 <RC522_SPI_SetSpeed+0x1c>
800051ec:	70 09       	ld.w	r9,r8[0x0]
800051ee:	72 ca       	ld.w	r10,r9[0x30]
800051f0:	5c 7c       	castu.h	r12
800051f2:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
800051f6:	f9 ea 10 0a 	or	r10,r12,r10
800051fa:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
800051fc:	70 0c       	ld.w	r12,r8[0x0]
800051fe:	f0 1f 00 03 	mcall	80005208 <RC522_SPI_SetSpeed+0x20>
		
	
}
80005202:	d8 02       	popm	pc
80005204:	00 00       	add	r0,r0
80005206:	1e 30       	cp.w	r0,pc
80005208:	80 00       	ld.sh	r0,r0[0x0]
8000520a:	68 7c       	ld.w	r12,r4[0x1c]

8000520c <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
8000520c:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0A00);//baudDiv=4
8000520e:	e0 6c 0a 00 	mov	r12,2560
80005212:	f0 1f 00 02 	mcall	80005218 <RC522_SPI_SetSpeedLow+0xc>
	
}
80005216:	d8 02       	popm	pc
80005218:	80 00       	ld.sh	r0,r0[0x0]
8000521a:	51 e8       	stdsp	sp[0x78],r8

8000521c <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
8000521c:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
80005220:	48 76       	lddpc	r6,8000523c <RC522_ReadByte+0x20>
80005222:	e0 6b 00 ff 	mov	r11,255
80005226:	6c 0c       	ld.w	r12,r6[0x0]
80005228:	f0 1f 00 06 	mcall	80005240 <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
8000522c:	30 07       	mov	r7,0
8000522e:	0e 9b       	mov	r11,r7
80005230:	6c 0c       	ld.w	r12,r6[0x0]
80005232:	f0 1f 00 05 	mcall	80005244 <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
80005236:	0f 9c       	ld.ub	r12,r7[0x1]
80005238:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000523c:	00 00       	add	r0,r0
8000523e:	1e 30       	cp.w	r0,pc
80005240:	80 00       	ld.sh	r0,r0[0x0]
80005242:	68 82       	ld.w	r2,r4[0x20]
80005244:	80 00       	ld.sh	r0,r0[0x0]
80005246:	68 9e       	ld.w	lr,r4[0x24]

80005248 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
80005248:	eb cd 40 80 	pushm	r7,lr
8000524c:	20 1d       	sub	sp,4
8000524e:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
80005250:	48 77       	lddpc	r7,8000526c <RC522_WriteByte+0x24>
80005252:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
80005256:	6e 0c       	ld.w	r12,r7[0x0]
80005258:	f0 1f 00 06 	mcall	80005270 <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
8000525c:	1a 9b       	mov	r11,sp
8000525e:	6e 0c       	ld.w	r12,r7[0x0]
80005260:	f0 1f 00 05 	mcall	80005274 <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
80005264:	5c 5c       	castu.b	r12
80005266:	2f fd       	sub	sp,-4
80005268:	e3 cd 80 80 	ldm	sp++,r7,pc
8000526c:	00 00       	add	r0,r0
8000526e:	1e 30       	cp.w	r0,pc
80005270:	80 00       	ld.sh	r0,r0[0x0]
80005272:	68 82       	ld.w	r2,r4[0x20]
80005274:	80 00       	ld.sh	r0,r0[0x0]
80005276:	68 9e       	ld.w	lr,r4[0x24]

80005278 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
80005278:	eb cd 40 e0 	pushm	r5-r7,lr
8000527c:	18 96       	mov	r6,r12
8000527e:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
80005280:	48 a7       	lddpc	r7,800052a8 <WriteRawRC+0x30>
80005282:	30 0b       	mov	r11,0
80005284:	6e 0c       	ld.w	r12,r7[0x0]
80005286:	f0 1f 00 0a 	mcall	800052ac <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
8000528a:	ec 0c 15 01 	lsl	r12,r6,0x1
8000528e:	e2 1c 00 7e 	andl	r12,0x7e,COH
80005292:	f0 1f 00 08 	mcall	800052b0 <WriteRawRC+0x38>
	RC522_WriteByte(value);
80005296:	0a 9c       	mov	r12,r5
80005298:	f0 1f 00 06 	mcall	800052b0 <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
8000529c:	30 0b       	mov	r11,0
8000529e:	6e 0c       	ld.w	r12,r7[0x0]
800052a0:	f0 1f 00 05 	mcall	800052b4 <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
800052a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800052a8:	00 00       	add	r0,r0
800052aa:	1e 30       	cp.w	r0,pc
800052ac:	80 00       	ld.sh	r0,r0[0x0]
800052ae:	69 e8       	ld.w	r8,r4[0x78]
800052b0:	80 00       	ld.sh	r0,r0[0x0]
800052b2:	52 48       	stdsp	sp[0x90],r8
800052b4:	80 00       	ld.sh	r0,r0[0x0]
800052b6:	69 a8       	ld.w	r8,r4[0x68]

800052b8 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
800052b8:	d4 01       	pushm	lr

	SET_RC522RST;
800052ba:	31 9c       	mov	r12,25
800052bc:	f0 1f 00 1b 	mcall	80005328 <PcdReset+0x70>
	delay_ns(10);
800052c0:	30 ac       	mov	r12,10
800052c2:	f0 1f 00 1b 	mcall	8000532c <PcdReset+0x74>

	CLR_RC522RST;
800052c6:	31 9c       	mov	r12,25
800052c8:	f0 1f 00 1a 	mcall	80005330 <PcdReset+0x78>
	delay_ns(10);
800052cc:	30 ac       	mov	r12,10
800052ce:	f0 1f 00 18 	mcall	8000532c <PcdReset+0x74>

	SET_RC522RST;
800052d2:	31 9c       	mov	r12,25
800052d4:	f0 1f 00 15 	mcall	80005328 <PcdReset+0x70>
	delay_ns(10);
800052d8:	30 ac       	mov	r12,10
800052da:	f0 1f 00 15 	mcall	8000532c <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
800052de:	30 fb       	mov	r11,15
800052e0:	30 1c       	mov	r12,1
800052e2:	f0 1f 00 15 	mcall	80005334 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
800052e6:	30 fb       	mov	r11,15
800052e8:	30 1c       	mov	r12,1
800052ea:	f0 1f 00 13 	mcall	80005334 <PcdReset+0x7c>
	delay_ns(10);
800052ee:	30 ac       	mov	r12,10
800052f0:	f0 1f 00 0f 	mcall	8000532c <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
800052f4:	33 db       	mov	r11,61
800052f6:	31 1c       	mov	r12,17
800052f8:	f0 1f 00 0f 	mcall	80005334 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
800052fc:	31 eb       	mov	r11,30
800052fe:	32 dc       	mov	r12,45
80005300:	f0 1f 00 0d 	mcall	80005334 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80005304:	30 0b       	mov	r11,0
80005306:	32 cc       	mov	r12,44
80005308:	f0 1f 00 0b 	mcall	80005334 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
8000530c:	e0 6b 00 8d 	mov	r11,141
80005310:	32 ac       	mov	r12,42
80005312:	f0 1f 00 09 	mcall	80005334 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
80005316:	33 eb       	mov	r11,62
80005318:	32 bc       	mov	r12,43
8000531a:	f0 1f 00 07 	mcall	80005334 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
8000531e:	34 0b       	mov	r11,64
80005320:	31 5c       	mov	r12,21
80005322:	f0 1f 00 05 	mcall	80005334 <PcdReset+0x7c>
	
	return MI_OK;
}
80005326:	d8 0a       	popm	pc,r12=0
80005328:	80 00       	ld.sh	r0,r0[0x0]
8000532a:	63 f0       	ld.w	r0,r1[0x7c]
8000532c:	80 00       	ld.sh	r0,r0[0x0]
8000532e:	5c 50       	castu.b	r0
80005330:	80 00       	ld.sh	r0,r0[0x0]
80005332:	64 0c       	ld.w	r12,r2[0x0]
80005334:	80 00       	ld.sh	r0,r0[0x0]
80005336:	52 78       	stdsp	sp[0x9c],r8

80005338 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
80005338:	eb cd 40 c0 	pushm	r6-r7,lr
8000533c:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
8000533e:	48 c7       	lddpc	r7,8000536c <ReadRawRC+0x34>
80005340:	30 0b       	mov	r11,0
80005342:	6e 0c       	ld.w	r12,r7[0x0]
80005344:	f0 1f 00 0b 	mcall	80005370 <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
80005348:	a1 76       	lsl	r6,0x1
8000534a:	0c 9c       	mov	r12,r6
8000534c:	e2 1c 00 7e 	andl	r12,0x7e,COH
80005350:	a7 bc       	sbr	r12,0x7
80005352:	f0 1f 00 09 	mcall	80005374 <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
80005356:	f0 1f 00 09 	mcall	80005378 <ReadRawRC+0x40>
8000535a:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
8000535c:	30 0b       	mov	r11,0
8000535e:	6e 0c       	ld.w	r12,r7[0x0]
80005360:	f0 1f 00 07 	mcall	8000537c <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
80005364:	0c 9c       	mov	r12,r6
80005366:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000536a:	00 00       	add	r0,r0
8000536c:	00 00       	add	r0,r0
8000536e:	1e 30       	cp.w	r0,pc
80005370:	80 00       	ld.sh	r0,r0[0x0]
80005372:	69 e8       	ld.w	r8,r4[0x78]
80005374:	80 00       	ld.sh	r0,r0[0x0]
80005376:	52 48       	stdsp	sp[0x90],r8
80005378:	80 00       	ld.sh	r0,r0[0x0]
8000537a:	52 1c       	stdsp	sp[0x84],r12
8000537c:	80 00       	ld.sh	r0,r0[0x0]
8000537e:	69 a8       	ld.w	r8,r4[0x68]

80005380 <Wait_Wakeup_RC522>:

/////////////////////////////////////////////////////////////////////
//    斤绛寰RC522
/////////////////////////////////////////////////////////////////////
void Wait_Wakeup_RC522(void)
{
80005380:	d4 01       	pushm	lr
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	do 
	{
		tmp = ReadRawRC(reg);
80005382:	30 1c       	mov	r12,1
80005384:	f0 1f 00 02 	mcall	8000538c <Wait_Wakeup_RC522+0xc>
			
	//tmp = ReadRawRC(reg);
	//if((tmp & 0x10) == 0)
	//WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
	
}
80005388:	d8 02       	popm	pc
8000538a:	00 00       	add	r0,r0
8000538c:	80 00       	ld.sh	r0,r0[0x0]
8000538e:	53 38       	stdsp	sp[0xcc],r8

80005390 <Powerdown_RC522>:
/////////////////////////////////////////////////////////////////////
//    斤浣RC522杩ヨ蒋垫ā寮
//
/////////////////////////////////////////////////////////////////////
void Powerdown_RC522(U8 act)
{
80005390:	eb cd 40 80 	pushm	r7,lr
80005394:	18 97       	mov	r7,r12
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	tmp = ReadRawRC(reg);
80005396:	30 1c       	mov	r12,1
80005398:	f0 1f 00 0d 	mcall	800053cc <Powerdown_RC522+0x3c>
	if(act == ENTER_POWERDOWN)//1
8000539c:	30 18       	mov	r8,1
8000539e:	f0 07 18 00 	cp.b	r7,r8
800053a2:	c0 91       	brne	800053b4 <Powerdown_RC522+0x24>
		WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
800053a4:	18 9b       	mov	r11,r12
800053a6:	a5 ab       	sbr	r11,0x4
800053a8:	5c 5b       	castu.b	r11
800053aa:	30 1c       	mov	r12,1
800053ac:	f0 1f 00 09 	mcall	800053d0 <Powerdown_RC522+0x40>
800053b0:	e3 cd 80 80 	ldm	sp++,r7,pc
	else
	{
		WriteRawRC(reg,tmp | PCD_IDLE);  // wake up rc522
800053b4:	18 9b       	mov	r11,r12
800053b6:	30 1c       	mov	r12,1
800053b8:	f0 1f 00 06 	mcall	800053d0 <Powerdown_RC522+0x40>
		delay_ns(2);
800053bc:	30 2c       	mov	r12,2
800053be:	f0 1f 00 06 	mcall	800053d4 <Powerdown_RC522+0x44>
		Wait_Wakeup_RC522();
800053c2:	f0 1f 00 06 	mcall	800053d8 <Powerdown_RC522+0x48>
800053c6:	e3 cd 80 80 	ldm	sp++,r7,pc
800053ca:	00 00       	add	r0,r0
800053cc:	80 00       	ld.sh	r0,r0[0x0]
800053ce:	53 38       	stdsp	sp[0xcc],r8
800053d0:	80 00       	ld.sh	r0,r0[0x0]
800053d2:	52 78       	stdsp	sp[0x9c],r8
800053d4:	80 00       	ld.sh	r0,r0[0x0]
800053d6:	5c 50       	castu.b	r0
800053d8:	80 00       	ld.sh	r0,r0[0x0]
800053da:	53 80       	stdsp	sp[0xe0],r0

800053dc <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
800053dc:	eb cd 40 c0 	pushm	r6-r7,lr
800053e0:	18 97       	mov	r7,r12
800053e2:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
800053e4:	f0 1f 00 05 	mcall	800053f8 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
800053e8:	f9 e6 10 0b 	or	r11,r12,r6
800053ec:	5c 5b       	castu.b	r11
800053ee:	0e 9c       	mov	r12,r7
800053f0:	f0 1f 00 03 	mcall	800053fc <SetBitMask+0x20>
}
800053f4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800053f8:	80 00       	ld.sh	r0,r0[0x0]
800053fa:	53 38       	stdsp	sp[0xcc],r8
800053fc:	80 00       	ld.sh	r0,r0[0x0]
800053fe:	52 78       	stdsp	sp[0x9c],r8

80005400 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80005400:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80005402:	31 4c       	mov	r12,20
80005404:	f0 1f 00 05 	mcall	80005418 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80005408:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
8000540c:	c0 51       	brne	80005416 <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
8000540e:	30 3b       	mov	r11,3
80005410:	31 4c       	mov	r12,20
80005412:	f0 1f 00 03 	mcall	8000541c <PcdAntennaOn+0x1c>
80005416:	d8 02       	popm	pc
80005418:	80 00       	ld.sh	r0,r0[0x0]
8000541a:	53 38       	stdsp	sp[0xcc],r8
8000541c:	80 00       	ld.sh	r0,r0[0x0]
8000541e:	53 dc       	stdsp	sp[0xf4],r12

80005420 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80005420:	eb cd 40 c0 	pushm	r6-r7,lr
80005424:	18 97       	mov	r7,r12
80005426:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80005428:	f0 1f 00 06 	mcall	80005440 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
8000542c:	5c d6       	com	r6
8000542e:	f9 e6 00 06 	and	r6,r12,r6
80005432:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80005436:	0e 9c       	mov	r12,r7
80005438:	f0 1f 00 03 	mcall	80005444 <ClearBitMask+0x24>
	
}
8000543c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005440:	80 00       	ld.sh	r0,r0[0x0]
80005442:	53 38       	stdsp	sp[0xcc],r8
80005444:	80 00       	ld.sh	r0,r0[0x0]
80005446:	52 78       	stdsp	sp[0x9c],r8

80005448 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
80005448:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
8000544a:	30 3b       	mov	r11,3
8000544c:	31 4c       	mov	r12,20
8000544e:	f0 1f 00 02 	mcall	80005454 <PcdAntennaOff+0xc>
}
80005452:	d8 02       	popm	pc
80005454:	80 00       	ld.sh	r0,r0[0x0]
80005456:	54 20       	stdsp	sp[0x108],r0

80005458 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
80005458:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
8000545a:	34 18       	mov	r8,65
8000545c:	f0 0c 18 00 	cp.b	r12,r8
80005460:	c0 20       	breq	80005464 <M500PcdConfigISOType+0xc>
80005462:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80005464:	30 8b       	mov	r11,8
80005466:	16 9c       	mov	r12,r11
80005468:	f0 1f 00 14 	mcall	800054b8 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
8000546c:	33 db       	mov	r11,61
8000546e:	31 1c       	mov	r12,17
80005470:	f0 1f 00 13 	mcall	800054bc <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80005474:	e0 6b 00 86 	mov	r11,134
80005478:	31 7c       	mov	r12,23
8000547a:	f0 1f 00 11 	mcall	800054bc <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
8000547e:	37 fb       	mov	r11,127
80005480:	32 6c       	mov	r12,38
80005482:	f0 1f 00 0f 	mcall	800054bc <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
80005486:	31 eb       	mov	r11,30
80005488:	32 dc       	mov	r12,45
8000548a:	f0 1f 00 0d 	mcall	800054bc <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
8000548e:	30 0b       	mov	r11,0
80005490:	32 cc       	mov	r12,44
80005492:	f0 1f 00 0b 	mcall	800054bc <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
80005496:	e0 6b 00 8d 	mov	r11,141
8000549a:	32 ac       	mov	r12,42
8000549c:	f0 1f 00 08 	mcall	800054bc <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
800054a0:	33 eb       	mov	r11,62
800054a2:	32 bc       	mov	r12,43
800054a4:	f0 1f 00 06 	mcall	800054bc <M500PcdConfigISOType+0x64>
		delay_ns(1000);
800054a8:	e0 6c 03 e8 	mov	r12,1000
800054ac:	f0 1f 00 05 	mcall	800054c0 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
800054b0:	f0 1f 00 05 	mcall	800054c4 <M500PcdConfigISOType+0x6c>
800054b4:	d8 0a       	popm	pc,r12=0
800054b6:	00 00       	add	r0,r0
800054b8:	80 00       	ld.sh	r0,r0[0x0]
800054ba:	54 20       	stdsp	sp[0x108],r0
800054bc:	80 00       	ld.sh	r0,r0[0x0]
800054be:	52 78       	stdsp	sp[0x9c],r8
800054c0:	80 00       	ld.sh	r0,r0[0x0]
800054c2:	5c 50       	castu.b	r0
800054c4:	80 00       	ld.sh	r0,r0[0x0]
800054c6:	54 00       	stdsp	sp[0x100],r0

800054c8 <rc522_init>:


//mfrc522 init

void rc522_init()
{
800054c8:	eb cd 40 80 	pushm	r7,lr
800054cc:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
800054ce:	49 d8       	lddpc	r8,80005540 <rc522_init+0x78>
800054d0:	1a 97       	mov	r7,sp
800054d2:	f0 ea 00 00 	ld.d	r10,r8[0]
800054d6:	fa eb 00 00 	st.d	sp[0],r10
800054da:	f0 e8 00 08 	ld.d	r8,r8[8]
800054de:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
800054e2:	30 1b       	mov	r11,1
800054e4:	49 8c       	lddpc	r12,80005544 <rc522_init+0x7c>
800054e6:	f0 1f 00 19 	mcall	80005548 <rc522_init+0x80>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
800054ea:	31 9c       	mov	r12,25
800054ec:	f0 1f 00 18 	mcall	8000554c <rc522_init+0x84>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
800054f0:	31 9c       	mov	r12,25
800054f2:	f0 1f 00 18 	mcall	80005550 <rc522_init+0x88>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
800054f6:	fe 7c 24 00 	mov	r12,-56320
800054fa:	49 78       	lddpc	r8,80005554 <rc522_init+0x8c>
800054fc:	91 0c       	st.w	r8[0x0],r12

	// Enable SPI.
	//spi_enable(spi);

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
800054fe:	e0 6a 36 00 	mov	r10,13824
80005502:	ea 1a 01 6e 	orh	r10,0x16e
80005506:	1a 9b       	mov	r11,sp
80005508:	f0 1f 00 14 	mcall	80005558 <rc522_init+0x90>
8000550c:	c0 50       	breq	80005516 <rc522_init+0x4e>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
8000550e:	30 29       	mov	r9,2
80005510:	49 38       	lddpc	r8,8000555c <rc522_init+0x94>
80005512:	b0 89       	st.b	r8[0x0],r9
80005514:	c0 38       	rjmp	8000551a <rc522_init+0x52>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80005516:	f0 1f 00 13 	mcall	80005560 <rc522_init+0x98>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
8000551a:	f0 1f 00 13 	mcall	80005564 <rc522_init+0x9c>
	
	PcdAntennaOff();
8000551e:	f0 1f 00 13 	mcall	80005568 <rc522_init+0xa0>
	
	delay_ms(2); 
80005522:	30 2c       	mov	r12,2
80005524:	f0 1f 00 12 	mcall	8000556c <rc522_init+0xa4>
	
	PcdAntennaOn();
80005528:	f0 1f 00 12 	mcall	80005570 <rc522_init+0xa8>
	
	M500PcdConfigISOType( 'A' );
8000552c:	34 1c       	mov	r12,65
8000552e:	f0 1f 00 12 	mcall	80005574 <rc522_init+0xac>
	
	Powerdown_RC522(ENTER_POWERDOWN);
80005532:	30 1c       	mov	r12,1
80005534:	f0 1f 00 11 	mcall	80005578 <rc522_init+0xb0>
	//Powerdown_RC522(ENTER_POWERDOWN);
	
	//Powerdown_RC522(WAKEUP_RC522);
	

80005538:	2f cd       	sub	sp,-16
8000553a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000553e:	00 00       	add	r0,r0
80005540:	80 00       	ld.sh	r0,r0[0x0]
80005542:	e9 f0 80 00 	ld.wls	r0,r4[0x0]
80005546:	e9 e8 80 00 	sthh.w	r0[r0],r4:b,r8:b
8000554a:	63 a8       	ld.w	r8,r1[0x68]
8000554c:	80 00       	ld.sh	r0,r0[0x0]
8000554e:	63 d8       	ld.w	r8,r1[0x74]
80005550:	80 00       	ld.sh	r0,r0[0x0]
80005552:	63 f0       	ld.w	r0,r1[0x7c]
80005554:	00 00       	add	r0,r0
80005556:	1e 30       	cp.w	r0,pc
80005558:	80 00       	ld.sh	r0,r0[0x0]
8000555a:	68 c0       	ld.w	r0,r4[0x30]
8000555c:	00 00       	add	r0,r0
8000555e:	0b 7c       	ld.ub	r12,--r5
80005560:	80 00       	ld.sh	r0,r0[0x0]
80005562:	52 0c       	stdsp	sp[0x80],r12
80005564:	80 00       	ld.sh	r0,r0[0x0]
80005566:	52 b8       	stdsp	sp[0xac],r8
80005568:	80 00       	ld.sh	r0,r0[0x0]
8000556a:	54 48       	stdsp	sp[0x110],r8
8000556c:	80 00       	ld.sh	r0,r0[0x0]
8000556e:	5c 90       	brev	r0
80005570:	80 00       	ld.sh	r0,r0[0x0]
80005572:	54 00       	stdsp	sp[0x100],r0
80005574:	80 00       	ld.sh	r0,r0[0x0]
80005576:	54 58       	stdsp	sp[0x114],r8
80005578:	80 00       	ld.sh	r0,r0[0x0]
8000557a:	53 90       	stdsp	sp[0xe4],r0

8000557c <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
8000557c:	d4 31       	pushm	r0-r7,lr
8000557e:	20 1d       	sub	sp,4
80005580:	18 92       	mov	r2,r12
80005582:	16 95       	mov	r5,r11
80005584:	14 96       	mov	r6,r10
80005586:	50 09       	stdsp	sp[0x0],r9
80005588:	10 90       	mov	r0,r8
8000558a:	f8 c8 00 0c 	sub	r8,r12,12
8000558e:	5c 58       	castu.b	r8
80005590:	30 29       	mov	r9,2
80005592:	f2 08 18 00 	cp.b	r8,r9
80005596:	e0 88 00 05 	brls	800055a0 <PcdComMF522+0x24>
8000559a:	30 03       	mov	r3,0
8000559c:	06 91       	mov	r1,r3
8000559e:	c0 78       	rjmp	800055ac <PcdComMF522+0x30>
800055a0:	4c f9       	lddpc	r9,800056dc <PcdComMF522+0x160>
800055a2:	f2 08 07 01 	ld.ub	r1,r9[r8]
800055a6:	4c f9       	lddpc	r9,800056e0 <PcdComMF522+0x164>
800055a8:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
800055ac:	02 9b       	mov	r11,r1
800055ae:	a7 bb       	sbr	r11,0x7
800055b0:	30 2c       	mov	r12,2
800055b2:	f0 1f 00 4d 	mcall	800056e4 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
800055b6:	e0 6b 00 80 	mov	r11,128
800055ba:	30 4c       	mov	r12,4
800055bc:	f0 1f 00 4b 	mcall	800056e8 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
800055c0:	30 0b       	mov	r11,0
800055c2:	30 1c       	mov	r12,1
800055c4:	f0 1f 00 48 	mcall	800056e4 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
800055c8:	e0 6b 00 80 	mov	r11,128
800055cc:	30 ac       	mov	r12,10
800055ce:	f0 1f 00 48 	mcall	800056ec <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
800055d2:	58 06       	cp.w	r6,0
800055d4:	c0 c0       	breq	800055ec <PcdComMF522+0x70>
800055d6:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
800055d8:	30 94       	mov	r4,9
800055da:	0f 3b       	ld.ub	r11,r7++
800055dc:	08 9c       	mov	r12,r4
800055de:	f0 1f 00 42 	mcall	800056e4 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
800055e2:	0e 98       	mov	r8,r7
800055e4:	0a 18       	sub	r8,r5
800055e6:	ec 08 19 00 	cp.h	r8,r6
800055ea:	cf 83       	brcs	800055da <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
800055ec:	04 9b       	mov	r11,r2
800055ee:	30 1c       	mov	r12,1
800055f0:	f0 1f 00 3d 	mcall	800056e4 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
800055f4:	30 c8       	mov	r8,12
800055f6:	f0 02 18 00 	cp.b	r2,r8
800055fa:	c0 61       	brne	80005606 <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
800055fc:	e0 6b 00 80 	mov	r11,128
80005600:	30 dc       	mov	r12,13
80005602:	f0 1f 00 3b 	mcall	800056ec <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80005606:	30 4c       	mov	r12,4
80005608:	f0 1f 00 3a 	mcall	800056f0 <PcdComMF522+0x174>
8000560c:	18 97       	mov	r7,r12
8000560e:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80005612:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80005614:	30 44       	mov	r4,4
80005616:	c0 88       	rjmp	80005626 <PcdComMF522+0xaa>
80005618:	08 9c       	mov	r12,r4
8000561a:	f0 1f 00 36 	mcall	800056f0 <PcdComMF522+0x174>
8000561e:	18 97       	mov	r7,r12
		i--;
80005620:	20 16       	sub	r6,1
80005622:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80005624:	c0 a0       	breq	80005638 <PcdComMF522+0xbc>
80005626:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
8000562a:	c4 c1       	brne	800056c2 <PcdComMF522+0x146>
8000562c:	ef e3 00 08 	and	r8,r7,r3
80005630:	ea 08 18 00 	cp.b	r8,r5
80005634:	cf 20       	breq	80005618 <PcdComMF522+0x9c>
80005636:	c4 68       	rjmp	800056c2 <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80005638:	e0 6b 00 80 	mov	r11,128
8000563c:	30 dc       	mov	r12,13
8000563e:	f0 1f 00 2b 	mcall	800056e8 <PcdComMF522+0x16c>
80005642:	30 27       	mov	r7,2
80005644:	c3 38       	rjmp	800056aa <PcdComMF522+0x12e>
80005646:	02 67       	and	r7,r1
80005648:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
8000564c:	30 c8       	mov	r8,12
8000564e:	f0 02 18 00 	cp.b	r2,r8
80005652:	c2 c1       	brne	800056aa <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80005654:	30 ac       	mov	r12,10
80005656:	f0 1f 00 27 	mcall	800056f0 <PcdComMF522+0x174>
8000565a:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
8000565c:	30 cc       	mov	r12,12
8000565e:	f0 1f 00 25 	mcall	800056f0 <PcdComMF522+0x174>
80005662:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80005666:	c0 70       	breq	80005674 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80005668:	08 98       	mov	r8,r4
8000566a:	20 18       	sub	r8,1
8000566c:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80005670:	a0 8c       	st.b	r0[0x0],r12
80005672:	c0 48       	rjmp	8000567a <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80005674:	e8 08 15 03 	lsl	r8,r4,0x3
80005678:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
8000567a:	58 04       	cp.w	r4,0
8000567c:	c0 61       	brne	80005688 <PcdComMF522+0x10c>
8000567e:	30 14       	mov	r4,1
80005680:	40 05       	lddsp	r5,sp[0x0]
80005682:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80005684:	30 93       	mov	r3,9
80005686:	c0 98       	rjmp	80005698 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80005688:	31 28       	mov	r8,18
8000568a:	f0 04 18 00 	cp.b	r4,r8
8000568e:	f9 b4 0b 12 	movhi	r4,18
80005692:	58 04       	cp.w	r4,0
80005694:	cf 61       	brne	80005680 <PcdComMF522+0x104>
80005696:	c0 a8       	rjmp	800056aa <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80005698:	06 9c       	mov	r12,r3
8000569a:	f0 1f 00 16 	mcall	800056f0 <PcdComMF522+0x174>
8000569e:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
800056a0:	ec 05 01 08 	sub	r8,r6,r5
800056a4:	e8 08 19 00 	cp.h	r8,r4
800056a8:	cf 83       	brcs	80005698 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
800056aa:	e0 6b 00 80 	mov	r11,128
800056ae:	30 cc       	mov	r12,12
800056b0:	f0 1f 00 0f 	mcall	800056ec <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
800056b4:	30 0b       	mov	r11,0
800056b6:	30 1c       	mov	r12,1
800056b8:	f0 1f 00 0b 	mcall	800056e4 <PcdComMF522+0x168>
	return status;
}
800056bc:	0e 9c       	mov	r12,r7
800056be:	2f fd       	sub	sp,-4
800056c0:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
800056c2:	e0 6b 00 80 	mov	r11,128
800056c6:	30 dc       	mov	r12,13
800056c8:	f0 1f 00 08 	mcall	800056e8 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
800056cc:	30 6c       	mov	r12,6
800056ce:	f0 1f 00 09 	mcall	800056f0 <PcdComMF522+0x174>
800056d2:	e2 1c 00 1b 	andl	r12,0x1b,COH
800056d6:	cb 80       	breq	80005646 <PcdComMF522+0xca>
800056d8:	30 27       	mov	r7,2
800056da:	ce 8b       	rjmp	800056aa <PcdComMF522+0x12e>
800056dc:	80 00       	ld.sh	r0,r0[0x0]
800056de:	e9 e0 80 00 	sthh.w	r0[r0],r4:b,r0:b
800056e2:	e9 e4 80 00 	sthh.w	r0[r0],r4:b,r4:b
800056e6:	52 78       	stdsp	sp[0x9c],r8
800056e8:	80 00       	ld.sh	r0,r0[0x0]
800056ea:	54 20       	stdsp	sp[0x108],r0
800056ec:	80 00       	ld.sh	r0,r0[0x0]
800056ee:	53 dc       	stdsp	sp[0xf4],r12
800056f0:	80 00       	ld.sh	r0,r0[0x0]
800056f2:	53 38       	stdsp	sp[0xcc],r8

800056f4 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
800056f4:	eb cd 40 c0 	pushm	r6-r7,lr
800056f8:	20 5d       	sub	sp,20
800056fa:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
800056fc:	30 8b       	mov	r11,8
800056fe:	16 9c       	mov	r12,r11
80005700:	f0 1f 00 1a 	mcall	80005768 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80005704:	30 0b       	mov	r11,0
80005706:	30 dc       	mov	r12,13
80005708:	f0 1f 00 19 	mcall	8000576c <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
8000570c:	e0 6b 00 80 	mov	r11,128
80005710:	30 ec       	mov	r12,14
80005712:	f0 1f 00 16 	mcall	80005768 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80005716:	39 38       	mov	r8,-109
80005718:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
8000571a:	32 08       	mov	r8,32
8000571c:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
8000571e:	1a 9b       	mov	r11,sp
80005720:	fa c8 ff ed 	sub	r8,sp,-19
80005724:	1a 99       	mov	r9,sp
80005726:	30 2a       	mov	r10,2
80005728:	30 cc       	mov	r12,12
8000572a:	f0 1f 00 12 	mcall	80005770 <PcdAnticoll+0x7c>
8000572e:	18 97       	mov	r7,r12

	if (status == MI_OK)
80005730:	c1 21       	brne	80005754 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80005732:	1b 89       	ld.ub	r9,sp[0x0]
80005734:	ac 89       	st.b	r6[0x0],r9
80005736:	1b 98       	ld.ub	r8,sp[0x1]
80005738:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
8000573a:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
8000573c:	1b a8       	ld.ub	r8,sp[0x2]
8000573e:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80005740:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80005744:	1b b9       	ld.ub	r9,sp[0x3]
80005746:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80005748:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
8000574a:	1b c9       	ld.ub	r9,sp[0x4]
8000574c:	f0 09 18 00 	cp.b	r9,r8
80005750:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80005754:	e0 6b 00 80 	mov	r11,128
80005758:	30 ec       	mov	r12,14
8000575a:	f0 1f 00 07 	mcall	80005774 <PcdAnticoll+0x80>
	return status;
}
8000575e:	0e 9c       	mov	r12,r7
80005760:	2f bd       	sub	sp,-20
80005762:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005766:	00 00       	add	r0,r0
80005768:	80 00       	ld.sh	r0,r0[0x0]
8000576a:	54 20       	stdsp	sp[0x108],r0
8000576c:	80 00       	ld.sh	r0,r0[0x0]
8000576e:	52 78       	stdsp	sp[0x9c],r8
80005770:	80 00       	ld.sh	r0,r0[0x0]
80005772:	55 7c       	stdsp	sp[0x15c],r12
80005774:	80 00       	ld.sh	r0,r0[0x0]
80005776:	53 dc       	stdsp	sp[0xf4],r12

80005778 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80005778:	eb cd 40 c0 	pushm	r6-r7,lr
8000577c:	20 5d       	sub	sp,20
8000577e:	18 97       	mov	r7,r12
80005780:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80005782:	30 8b       	mov	r11,8
80005784:	16 9c       	mov	r12,r11
80005786:	f0 1f 00 12 	mcall	800057cc <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
8000578a:	30 7b       	mov	r11,7
8000578c:	30 dc       	mov	r12,13
8000578e:	f0 1f 00 11 	mcall	800057d0 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80005792:	30 3b       	mov	r11,3
80005794:	31 4c       	mov	r12,20
80005796:	f0 1f 00 10 	mcall	800057d4 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
8000579a:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
8000579c:	1a 9b       	mov	r11,sp
8000579e:	fa c8 ff ed 	sub	r8,sp,-19
800057a2:	1a 99       	mov	r9,sp
800057a4:	30 1a       	mov	r10,1
800057a6:	30 cc       	mov	r12,12
800057a8:	f0 1f 00 0c 	mcall	800057d8 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
800057ac:	c0 c1       	brne	800057c4 <PcdRequest+0x4c>
800057ae:	31 08       	mov	r8,16
800057b0:	fb 39 00 13 	ld.ub	r9,sp[19]
800057b4:	f0 09 18 00 	cp.b	r9,r8
800057b8:	c0 61       	brne	800057c4 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
800057ba:	1b 88       	ld.ub	r8,sp[0x0]
800057bc:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
800057be:	1b 98       	ld.ub	r8,sp[0x1]
800057c0:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
800057c2:	c0 28       	rjmp	800057c6 <PcdRequest+0x4e>
800057c4:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
800057c6:	2f bd       	sub	sp,-20
800057c8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800057cc:	80 00       	ld.sh	r0,r0[0x0]
800057ce:	54 20       	stdsp	sp[0x108],r0
800057d0:	80 00       	ld.sh	r0,r0[0x0]
800057d2:	52 78       	stdsp	sp[0x9c],r8
800057d4:	80 00       	ld.sh	r0,r0[0x0]
800057d6:	53 dc       	stdsp	sp[0xf4],r12
800057d8:	80 00       	ld.sh	r0,r0[0x0]
800057da:	55 7c       	stdsp	sp[0x15c],r12

800057dc <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
800057dc:	eb cd 40 f8 	pushm	r3-r7,lr
800057e0:	18 95       	mov	r5,r12
800057e2:	16 96       	mov	r6,r11
800057e4:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
800057e6:	30 4b       	mov	r11,4
800057e8:	30 5c       	mov	r12,5
800057ea:	f0 1f 00 1c 	mcall	80005858 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
800057ee:	30 0b       	mov	r11,0
800057f0:	30 1c       	mov	r12,1
800057f2:	f0 1f 00 1b 	mcall	8000585c <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
800057f6:	e0 6b 00 80 	mov	r11,128
800057fa:	30 ac       	mov	r12,10
800057fc:	f0 1f 00 19 	mcall	80005860 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80005800:	58 06       	cp.w	r6,0
80005802:	c0 c0       	breq	8000581a <CalulateCRC+0x3e>
80005804:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80005806:	30 94       	mov	r4,9
80005808:	0f 3b       	ld.ub	r11,r7++
8000580a:	08 9c       	mov	r12,r4
8000580c:	f0 1f 00 14 	mcall	8000585c <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80005810:	0e 98       	mov	r8,r7
80005812:	0a 18       	sub	r8,r5
80005814:	ec 08 18 00 	cp.b	r8,r6
80005818:	cf 83       	brcs	80005808 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
8000581a:	30 3b       	mov	r11,3
8000581c:	30 1c       	mov	r12,1
8000581e:	f0 1f 00 10 	mcall	8000585c <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80005822:	30 5c       	mov	r12,5
80005824:	f0 1f 00 10 	mcall	80005864 <CalulateCRC+0x88>
80005828:	e0 67 00 fe 	mov	r7,254
8000582c:	30 56       	mov	r6,5
8000582e:	c0 78       	rjmp	8000583c <CalulateCRC+0x60>
80005830:	0c 9c       	mov	r12,r6
80005832:	f0 1f 00 0d 	mcall	80005864 <CalulateCRC+0x88>
		i--;
80005836:	20 17       	sub	r7,1
80005838:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
8000583a:	c0 40       	breq	80005842 <CalulateCRC+0x66>
8000583c:	e2 1c 00 04 	andl	r12,0x4,COH
80005840:	cf 80       	breq	80005830 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80005842:	32 2c       	mov	r12,34
80005844:	f0 1f 00 08 	mcall	80005864 <CalulateCRC+0x88>
80005848:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
8000584a:	32 1c       	mov	r12,33
8000584c:	f0 1f 00 06 	mcall	80005864 <CalulateCRC+0x88>
80005850:	a6 9c       	st.b	r3[0x1],r12
}
80005852:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005856:	00 00       	add	r0,r0
80005858:	80 00       	ld.sh	r0,r0[0x0]
8000585a:	54 20       	stdsp	sp[0x108],r0
8000585c:	80 00       	ld.sh	r0,r0[0x0]
8000585e:	52 78       	stdsp	sp[0x9c],r8
80005860:	80 00       	ld.sh	r0,r0[0x0]
80005862:	53 dc       	stdsp	sp[0xf4],r12
80005864:	80 00       	ld.sh	r0,r0[0x0]
80005866:	53 38       	stdsp	sp[0xcc],r8

80005868 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80005868:	eb cd 40 80 	pushm	r7,lr
8000586c:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
8000586e:	39 38       	mov	r8,-109
80005870:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80005872:	37 08       	mov	r8,112
80005874:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80005876:	30 08       	mov	r8,0
80005878:	ba e8       	st.b	sp[0x6],r8
8000587a:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
8000587e:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80005882:	19 89       	ld.ub	r9,r12[0x0]
80005884:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80005886:	19 3a       	ld.ub	r10,r12++
80005888:	1b e9       	ld.ub	r9,sp[0x6]
8000588a:	f5 e9 20 09 	eor	r9,r10,r9
8000588e:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80005890:	16 38       	cp.w	r8,r11
80005892:	cf 81       	brne	80005882 <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80005894:	1a 97       	mov	r7,sp
80005896:	fa ca ff f9 	sub	r10,sp,-7
8000589a:	30 7b       	mov	r11,7
8000589c:	1a 9c       	mov	r12,sp
8000589e:	f0 1f 00 0d 	mcall	800058d0 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
800058a2:	30 8b       	mov	r11,8
800058a4:	16 9c       	mov	r12,r11
800058a6:	f0 1f 00 0c 	mcall	800058d4 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
800058aa:	fa c8 ff ed 	sub	r8,sp,-19
800058ae:	1a 99       	mov	r9,sp
800058b0:	30 9a       	mov	r10,9
800058b2:	1a 9b       	mov	r11,sp
800058b4:	30 cc       	mov	r12,12
800058b6:	f0 1f 00 09 	mcall	800058d8 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
800058ba:	c0 71       	brne	800058c8 <PcdSelect+0x60>
800058bc:	31 88       	mov	r8,24
800058be:	fb 39 00 13 	ld.ub	r9,sp[19]
800058c2:	f0 09 18 00 	cp.b	r9,r8
800058c6:	c0 20       	breq	800058ca <PcdSelect+0x62>
800058c8:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
800058ca:	2f bd       	sub	sp,-20
800058cc:	e3 cd 80 80 	ldm	sp++,r7,pc
800058d0:	80 00       	ld.sh	r0,r0[0x0]
800058d2:	57 dc       	stdsp	sp[0x1f4],r12
800058d4:	80 00       	ld.sh	r0,r0[0x0]
800058d6:	54 20       	stdsp	sp[0x108],r0
800058d8:	80 00       	ld.sh	r0,r0[0x0]
800058da:	55 7c       	stdsp	sp[0x15c],r12

800058dc <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
800058dc:	eb cd 40 c0 	pushm	r6-r7,lr
800058e0:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
800058e2:	f0 1f 00 37 	mcall	800059bc <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
800058e6:	4b 7b       	lddpc	r11,800059c0 <rfid_auto_reader+0xe4>
800058e8:	35 2c       	mov	r12,82
800058ea:	f0 1f 00 37 	mcall	800059c4 <rfid_auto_reader+0xe8>
800058ee:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
800058f0:	c6 31       	brne	800059b6 <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
800058f2:	4b 48       	lddpc	r8,800059c0 <rfid_auto_reader+0xe4>
800058f4:	11 88       	ld.ub	r8,r8[0x0]
800058f6:	30 49       	mov	r9,4
800058f8:	f2 08 18 00 	cp.b	r8,r9
800058fc:	c0 b1       	brne	80005912 <rfid_auto_reader+0x36>
800058fe:	4b 19       	lddpc	r9,800059c0 <rfid_auto_reader+0xe4>
80005900:	13 9a       	ld.ub	r10,r9[0x1]
80005902:	30 09       	mov	r9,0
80005904:	f2 0a 18 00 	cp.b	r10,r9
80005908:	c0 51       	brne	80005912 <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
8000590a:	4b 0c       	lddpc	r12,800059c8 <rfid_auto_reader+0xec>
8000590c:	f0 1f 00 30 	mcall	800059cc <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80005910:	c3 c8       	rjmp	80005988 <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80005912:	30 29       	mov	r9,2
80005914:	f2 08 18 00 	cp.b	r8,r9
80005918:	c0 b1       	brne	8000592e <rfid_auto_reader+0x52>
8000591a:	4a a9       	lddpc	r9,800059c0 <rfid_auto_reader+0xe4>
8000591c:	13 9a       	ld.ub	r10,r9[0x1]
8000591e:	30 09       	mov	r9,0
80005920:	f2 0a 18 00 	cp.b	r10,r9
80005924:	c0 51       	brne	8000592e <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80005926:	4a bc       	lddpc	r12,800059d0 <rfid_auto_reader+0xf4>
80005928:	f0 1f 00 29 	mcall	800059cc <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
8000592c:	c2 e8       	rjmp	80005988 <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
8000592e:	34 49       	mov	r9,68
80005930:	f2 08 18 00 	cp.b	r8,r9
80005934:	c0 b1       	brne	8000594a <rfid_auto_reader+0x6e>
80005936:	4a 39       	lddpc	r9,800059c0 <rfid_auto_reader+0xe4>
80005938:	13 9a       	ld.ub	r10,r9[0x1]
8000593a:	30 09       	mov	r9,0
8000593c:	f2 0a 18 00 	cp.b	r10,r9
80005940:	c0 51       	brne	8000594a <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80005942:	4a 5c       	lddpc	r12,800059d4 <rfid_auto_reader+0xf8>
80005944:	f0 1f 00 22 	mcall	800059cc <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80005948:	c2 08       	rjmp	80005988 <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
8000594a:	30 89       	mov	r9,8
8000594c:	f2 08 18 00 	cp.b	r8,r9
80005950:	c0 b1       	brne	80005966 <rfid_auto_reader+0x8a>
80005952:	49 c9       	lddpc	r9,800059c0 <rfid_auto_reader+0xe4>
80005954:	13 9a       	ld.ub	r10,r9[0x1]
80005956:	30 09       	mov	r9,0
80005958:	f2 0a 18 00 	cp.b	r10,r9
8000595c:	c0 51       	brne	80005966 <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
8000595e:	49 fc       	lddpc	r12,800059d8 <rfid_auto_reader+0xfc>
80005960:	f0 1f 00 1b 	mcall	800059cc <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80005964:	c1 28       	rjmp	80005988 <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80005966:	34 49       	mov	r9,68
80005968:	f2 08 18 00 	cp.b	r8,r9
8000596c:	c0 b1       	brne	80005982 <rfid_auto_reader+0xa6>
8000596e:	49 58       	lddpc	r8,800059c0 <rfid_auto_reader+0xe4>
80005970:	11 99       	ld.ub	r9,r8[0x1]
80005972:	30 38       	mov	r8,3
80005974:	f0 09 18 00 	cp.b	r9,r8
80005978:	c0 51       	brne	80005982 <rfid_auto_reader+0xa6>
		log("MF Desire\n");
8000597a:	49 9c       	lddpc	r12,800059dc <rfid_auto_reader+0x100>
8000597c:	f0 1f 00 14 	mcall	800059cc <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80005980:	c0 48       	rjmp	80005988 <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80005982:	49 8c       	lddpc	r12,800059e0 <rfid_auto_reader+0x104>
80005984:	f0 1f 00 12 	mcall	800059cc <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80005988:	49 7c       	lddpc	r12,800059e4 <rfid_auto_reader+0x108>
8000598a:	f0 1f 00 18 	mcall	800059e8 <rfid_auto_reader+0x10c>
8000598e:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80005990:	c0 60       	breq	8000599c <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, Low_Battery_3);//set tone to noticy failure!!!
80005992:	34 fb       	mov	r11,79
80005994:	30 1c       	mov	r12,1
80005996:	f0 1f 00 16 	mcall	800059ec <rfid_auto_reader+0x110>
		return status;
8000599a:	c0 e8       	rjmp	800059b6 <rfid_auto_reader+0xda>
		//continue;
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
8000599c:	49 2c       	lddpc	r12,800059e4 <rfid_auto_reader+0x108>
8000599e:	f0 1f 00 15 	mcall	800059f0 <rfid_auto_reader+0x114>
800059a2:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
800059a4:	c0 91       	brne	800059b6 <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
800059a6:	30 4a       	mov	r10,4
800059a8:	48 fb       	lddpc	r11,800059e4 <rfid_auto_reader+0x108>
800059aa:	0c 9c       	mov	r12,r6
800059ac:	f0 1f 00 12 	mcall	800059f4 <rfid_auto_reader+0x118>
		log("select okay\n");
800059b0:	49 2c       	lddpc	r12,800059f8 <rfid_auto_reader+0x11c>
800059b2:	f0 1f 00 07 	mcall	800059cc <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
800059b6:	0e 9c       	mov	r12,r7
800059b8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800059bc:	80 00       	ld.sh	r0,r0[0x0]
800059be:	52 b8       	stdsp	sp[0xac],r8
800059c0:	00 00       	add	r0,r0
800059c2:	97 b8       	st.w	r11[0x2c],r8
800059c4:	80 00       	ld.sh	r0,r0[0x0]
800059c6:	57 78       	stdsp	sp[0x1dc],r8
800059c8:	80 00       	ld.sh	r0,r0[0x0]
800059ca:	ea 00       	*unknown*
800059cc:	80 00       	ld.sh	r0,r0[0x0]
800059ce:	7f c4       	ld.w	r4,pc[0x70]
800059d0:	80 00       	ld.sh	r0,r0[0x0]
800059d2:	ea 0c       	*unknown*
800059d4:	80 00       	ld.sh	r0,r0[0x0]
800059d6:	ea 18 80 00 	orh	r8,0x8000
800059da:	ea 28 80 00 	sub	r8,688128
800059de:	ea 30 80 00 	sub	r0,753664
800059e2:	ea 3c 00 00 	sub	r12,720896
800059e6:	97 bc       	st.w	r11[0x2c],r12
800059e8:	80 00       	ld.sh	r0,r0[0x0]
800059ea:	56 f4       	stdsp	sp[0x1bc],r4
800059ec:	80 00       	ld.sh	r0,r0[0x0]
800059ee:	4a 0c       	lddpc	r12,80005a6c <scan_rfid_save_message+0x20>
800059f0:	80 00       	ld.sh	r0,r0[0x0]
800059f2:	58 68       	cp.w	r8,6
800059f4:	80 00       	ld.sh	r0,r0[0x0]
800059f6:	88 6e       	ld.sh	lr,r4[0xc]
800059f8:	80 00       	ld.sh	r0,r0[0x0]
800059fa:	ea 48 eb cd 	cp.w	r8,715725

800059fc <scan_patrol>:
	return return_err;
	
}

U8 scan_patrol(char* SN)
{
800059fc:	eb cd 40 80 	pushm	r7,lr
80005a00:	18 97       	mov	r7,r12
	U8 return_err = MI_ERR;
	
	PcdReset();
80005a02:	f0 1f 00 0d 	mcall	80005a34 <scan_patrol+0x38>
	Powerdown_RC522(WAKEUP_RC522);
80005a06:	30 0c       	mov	r12,0
80005a08:	f0 1f 00 0c 	mcall	80005a38 <scan_patrol+0x3c>
	return_err = rfid_auto_reader(SN);
80005a0c:	0e 9c       	mov	r12,r7
80005a0e:	f0 1f 00 0c 	mcall	80005a3c <scan_patrol+0x40>
80005a12:	18 97       	mov	r7,r12
	Powerdown_RC522(ENTER_POWERDOWN);
80005a14:	30 1c       	mov	r12,1
80005a16:	f0 1f 00 09 	mcall	80005a38 <scan_patrol+0x3c>
	if(return_err == 0)
80005a1a:	58 07       	cp.w	r7,0
80005a1c:	c0 51       	brne	80005a26 <scan_patrol+0x2a>
		log("scan_patrol okay!\n");
80005a1e:	48 9c       	lddpc	r12,80005a40 <scan_patrol+0x44>
80005a20:	f0 1f 00 09 	mcall	80005a44 <scan_patrol+0x48>
80005a24:	c0 48       	rjmp	80005a2c <scan_patrol+0x30>
	else
		log("scan_patrol err!\n");
80005a26:	48 9c       	lddpc	r12,80005a48 <scan_patrol+0x4c>
80005a28:	f0 1f 00 07 	mcall	80005a44 <scan_patrol+0x48>
		
	return return_err;

}
80005a2c:	0e 9c       	mov	r12,r7
80005a2e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005a32:	00 00       	add	r0,r0
80005a34:	80 00       	ld.sh	r0,r0[0x0]
80005a36:	52 b8       	stdsp	sp[0xac],r8
80005a38:	80 00       	ld.sh	r0,r0[0x0]
80005a3a:	53 90       	stdsp	sp[0xe4],r0
80005a3c:	80 00       	ld.sh	r0,r0[0x0]
80005a3e:	58 dc       	cp.w	r12,13
80005a40:	80 00       	ld.sh	r0,r0[0x0]
80005a42:	ea 58 80 00 	cp.w	r8,753664
80005a46:	7f c4       	ld.w	r4,pc[0x70]
80005a48:	80 00       	ld.sh	r0,r0[0x0]
80005a4a:	ea 6c eb cd 	mov	r12,715725

80005a4c <scan_rfid_save_message>:

extern volatile DateTime_t Current_time;
/*the queue is used to receive failure-send message*/

U8 scan_rfid_save_message()
{
80005a4c:	eb cd 40 e0 	pushm	r5-r7,lr
80005a50:	21 dd       	sub	sp,116
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	//memset(data_buffer, 0x00, 16);
	memset(SN, 0x00, 10);
80005a52:	4e 9c       	lddpc	r12,80005bf4 <scan_rfid_save_message+0x1a8>
80005a54:	30 08       	mov	r8,0
80005a56:	30 09       	mov	r9,0
80005a58:	f8 e9 00 00 	st.d	r12[0],r8
80005a5c:	30 0a       	mov	r10,0
80005a5e:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80005a60:	fa e9 00 24 	st.d	sp[36],r8
80005a64:	fa e9 00 2c 	st.d	sp[44],r8
80005a68:	fa e9 00 34 	st.d	sp[52],r8
80005a6c:	fa e9 00 3c 	st.d	sp[60],r8
80005a70:	fa e9 00 44 	st.d	sp[68],r8
80005a74:	fa e9 00 4c 	st.d	sp[76],r8
80005a78:	fa e9 00 54 	st.d	sp[84],r8
80005a7c:	fa e9 00 5c 	st.d	sp[92],r8
80005a80:	fa e9 00 64 	st.d	sp[100],r8
80005a84:	fa e9 00 6c 	st.d	sp[108],r8
	
	return_err = scan_patrol(SN);
80005a88:	f0 1f 00 5c 	mcall	80005bf8 <scan_rfid_save_message+0x1ac>
80005a8c:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80005a8e:	e0 81 00 a7 	brne	80005bdc <scan_rfid_save_message+0x190>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80005a92:	4d 96       	lddpc	r6,80005bf4 <scan_rfid_save_message+0x1a8>
80005a94:	0d b8       	ld.ub	r8,r6[0x3]
80005a96:	1a d8       	st.w	--sp,r8
80005a98:	0d a8       	ld.ub	r8,r6[0x2]
80005a9a:	1a d8       	st.w	--sp,r8
80005a9c:	0d 98       	ld.ub	r8,r6[0x1]
80005a9e:	1a d8       	st.w	--sp,r8
80005aa0:	0d 88       	ld.ub	r8,r6[0x0]
80005aa2:	1a d8       	st.w	--sp,r8
80005aa4:	4d 6c       	lddpc	r12,80005bfc <scan_rfid_save_message+0x1b0>
80005aa6:	f0 1f 00 57 	mcall	80005c00 <scan_rfid_save_message+0x1b4>
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
80005aaa:	34 4b       	mov	r11,68
80005aac:	30 1c       	mov	r12,1
80005aae:	f0 1f 00 56 	mcall	80005c04 <scan_rfid_save_message+0x1b8>
80005ab2:	fa c8 ff ec 	sub	r8,sp,-20
80005ab6:	fa c9 ff ea 	sub	r9,sp,-22
}

extern volatile DateTime_t Current_time;
/*the queue is used to receive failure-send message*/

U8 scan_rfid_save_message()
80005aba:	ec c5 ff fc 	sub	r5,r6,-4
80005abe:	2f cd       	sub	sp,-16
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80005ac0:	30 9e       	mov	lr,9
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
80005ac2:	30 0c       	mov	r12,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80005ac4:	0d 8a       	ld.ub	r10,r6[0x0]
80005ac6:	f4 0b 16 04 	lsr	r11,r10,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80005aca:	fc 0b 18 00 	cp.b	r11,lr
80005ace:	f7 bb 08 d0 	subls	r11,-48
80005ad2:	f1 fb 8e 00 	st.bls	r8[0x0],r11
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
80005ad6:	f7 bb 0b a9 	subhi	r11,-87
80005ada:	f1 fb be 00 	st.bhi	r8[0x0],r11
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
80005ade:	b0 9c       	st.b	r8[0x1],r12
			
			temp = (SN[i] & 0x0F);//瀛浣浣
80005ae0:	f5 da c0 04 	bfextu	r10,r10,0x0,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
80005ae4:	fc 0a 18 00 	cp.b	r10,lr
80005ae8:	f7 ba 08 d0 	subls	r10,-48
80005aec:	f3 fa 8e 00 	st.bls	r9[0x0],r10
			else
			data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
80005af0:	f7 ba 0b a9 	subhi	r10,-87
80005af4:	f3 fa be 00 	st.bhi	r9[0x0],r10

			data_buffer.RFID_ID[i*4+3] = 0x00;
80005af8:	b0 bc       	st.b	r8[0x3],r12
80005afa:	2f f6       	sub	r6,-1
80005afc:	2f c8       	sub	r8,-4
80005afe:	2f c9       	sub	r9,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
80005b00:	0a 36       	cp.w	r6,r5
80005b02:	ce 11       	brne	80005ac4 <scan_rfid_save_message+0x78>
			data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);

			data_buffer.RFID_ID[i*4+3] = 0x00;
		}
		
		memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
80005b04:	30 6a       	mov	r10,6
80005b06:	4c 1b       	lddpc	r11,80005c08 <scan_rfid_save_message+0x1bc>
80005b08:	fa cc ff ec 	sub	r12,sp,-20
80005b0c:	f0 1f 00 40 	mcall	80005c0c <scan_rfid_save_message+0x1c0>
		
		header.length = (0x0008 + sizeof(Message_Data_t));
		
		if(start_session > 0x9f)start_session = 0x80;
80005b10:	4c 08       	lddpc	r8,80005c10 <scan_rfid_save_message+0x1c4>
80005b12:	11 89       	ld.ub	r9,r8[0x0]
80005b14:	39 f8       	mov	r8,-97
80005b16:	f0 09 18 00 	cp.b	r9,r8
80005b1a:	e0 88 00 05 	brls	80005b24 <scan_rfid_save_message+0xd8>
80005b1e:	38 09       	mov	r9,-128
80005b20:	4b c8       	lddpc	r8,80005c10 <scan_rfid_save_message+0x1c4>
80005b22:	b0 89       	st.b	r8[0x0],r9
		
		header.session_id = (++start_session);
80005b24:	4b b8       	lddpc	r8,80005c10 <scan_rfid_save_message+0x1c4>
80005b26:	11 86       	ld.ub	r6,r8[0x0]
80005b28:	2f f6       	sub	r6,-1
80005b2a:	5c 56       	castu.b	r6
80005b2c:	b0 86       	st.b	r8[0x0],r6
		
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
80005b2e:	30 5a       	mov	r10,5
80005b30:	4b 9b       	lddpc	r11,80005c14 <scan_rfid_save_message+0x1c8>
80005b32:	fa cc ff e1 	sub	r12,sp,-31
80005b36:	f0 1f 00 36 	mcall	80005c0c <scan_rfid_save_message+0x1c0>
		header.type = 0xe000;
		
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
80005b3a:	31 e8       	mov	r8,30
80005b3c:	fb 58 00 1a 	st.h	sp[26],r8
80005b40:	fb 66 00 1e 	st.b	sp[30],r6
80005b44:	fe 78 e0 00 	mov	r8,-8192
80005b48:	fb 58 00 1c 	st.h	sp[28],r8
80005b4c:	30 aa       	mov	r10,10
80005b4e:	fa cb ff e6 	sub	r11,sp,-26
80005b52:	fa cc ff dc 	sub	r12,sp,-36
80005b56:	f0 1f 00 2e 	mcall	80005c0c <scan_rfid_save_message+0x1c0>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
80005b5a:	31 6a       	mov	r10,22
80005b5c:	fa cb ff fc 	sub	r11,sp,-4
80005b60:	fa cc ff d2 	sub	r12,sp,-46
80005b64:	f0 1f 00 2a 	mcall	80005c0c <scan_rfid_save_message+0x1c0>
		
		//xgflash_message_save(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), TRUE);
		//xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
		Message_Protocol_t * myptr = get_message_store();
80005b68:	4a c8       	lddpc	r8,80005c18 <scan_rfid_save_message+0x1cc>
80005b6a:	70 0c       	ld.w	r12,r8[0x0]
80005b6c:	f0 1f 00 2c 	mcall	80005c1c <scan_rfid_save_message+0x1d0>
80005b70:	50 0c       	stdsp	sp[0x0],r12
		if(NULL != myptr)
80005b72:	c3 10       	breq	80005bd4 <scan_rfid_save_message+0x188>
		{
			memcpy(myptr, message, sizeof(Message_Protocol_t));
80005b74:	32 0a       	mov	r10,32
80005b76:	fa cb ff dc 	sub	r11,sp,-36
80005b7a:	f0 1f 00 25 	mcall	80005c0c <scan_rfid_save_message+0x1c0>
			//xQueueSend(xg_resend_queue, &myptr, 0);
			if (xQueueSend(xg_resend_queue, &myptr, 0) != pdPASS)
80005b7e:	4a 98       	lddpc	r8,80005c20 <scan_rfid_save_message+0x1d4>
80005b80:	70 0c       	ld.w	r12,r8[0x0]
80005b82:	30 09       	mov	r9,0
80005b84:	12 9a       	mov	r10,r9
80005b86:	1a 9b       	mov	r11,sp
80005b88:	f0 1f 00 27 	mcall	80005c24 <scan_rfid_save_message+0x1d8>
80005b8c:	58 1c       	cp.w	r12,1
80005b8e:	c1 10       	breq	80005bb0 <scan_rfid_save_message+0x164>
			{
				log("xg_resend_queue: full\n" );
80005b90:	4a 6c       	lddpc	r12,80005c28 <scan_rfid_save_message+0x1dc>
80005b92:	f0 1f 00 1c 	mcall	80005c00 <scan_rfid_save_message+0x1b4>
				xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
80005b96:	32 3b       	mov	r11,35
80005b98:	30 1c       	mov	r12,1
80005b9a:	f0 1f 00 1b 	mcall	80005c04 <scan_rfid_save_message+0x1b8>
				vTaskDelay(3000*2 / portTICK_RATE_MS);//寤惰3000ms
80005b9e:	e0 6c 17 70 	mov	r12,6000
80005ba2:	f0 1f 00 23 	mcall	80005c2c <scan_rfid_save_message+0x1e0>
				xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
80005ba6:	32 3b       	mov	r11,35
80005ba8:	30 0c       	mov	r12,0
80005baa:	f0 1f 00 17 	mcall	80005c04 <scan_rfid_save_message+0x1b8>
80005bae:	c1 e8       	rjmp	80005bea <scan_rfid_save_message+0x19e>
			}
			else
			{
				xSemaphoreTake(count_mutex, portMAX_DELAY);
80005bb0:	4a 06       	lddpc	r6,80005c30 <scan_rfid_save_message+0x1e4>
80005bb2:	6c 0c       	ld.w	r12,r6[0x0]
80005bb4:	30 09       	mov	r9,0
80005bb6:	3f fa       	mov	r10,-1
80005bb8:	12 9b       	mov	r11,r9
80005bba:	f0 1f 00 1f 	mcall	80005c34 <scan_rfid_save_message+0x1e8>
				global_count++;
80005bbe:	49 f8       	lddpc	r8,80005c38 <scan_rfid_save_message+0x1ec>
80005bc0:	70 09       	ld.w	r9,r8[0x0]
80005bc2:	2f f9       	sub	r9,-1
80005bc4:	91 09       	st.w	r8[0x0],r9
				xSemaphoreGive(count_mutex);
80005bc6:	6c 0c       	ld.w	r12,r6[0x0]
80005bc8:	30 09       	mov	r9,0
80005bca:	12 9a       	mov	r10,r9
80005bcc:	12 9b       	mov	r11,r9
80005bce:	f0 1f 00 16 	mcall	80005c24 <scan_rfid_save_message+0x1d8>
80005bd2:	c0 c8       	rjmp	80005bea <scan_rfid_save_message+0x19e>
			}
		}
		else
		{
			log("myptr: err\n\r" );
80005bd4:	49 ac       	lddpc	r12,80005c3c <scan_rfid_save_message+0x1f0>
80005bd6:	f0 1f 00 0b 	mcall	80005c00 <scan_rfid_save_message+0x1b4>
80005bda:	c0 88       	rjmp	80005bea <scan_rfid_save_message+0x19e>
		
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, Low_Battery_3);//set tone to indicate scan rfid failure!!!
80005bdc:	34 fb       	mov	r11,79
80005bde:	30 1c       	mov	r12,1
80005be0:	f0 1f 00 09 	mcall	80005c04 <scan_rfid_save_message+0x1b8>
		log("no card find...\n");
80005be4:	49 7c       	lddpc	r12,80005c40 <scan_rfid_save_message+0x1f4>
80005be6:	f0 1f 00 07 	mcall	80005c00 <scan_rfid_save_message+0x1b4>
	}
	
	return return_err;
	

}
80005bea:	0e 9c       	mov	r12,r7
80005bec:	2e 3d       	sub	sp,-116
80005bee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005bf2:	00 00       	add	r0,r0
80005bf4:	00 00       	add	r0,r0
80005bf6:	0b 80       	ld.ub	r0,r5[0x0]
80005bf8:	80 00       	ld.sh	r0,r0[0x0]
80005bfa:	59 fc       	cp.w	r12,31
80005bfc:	80 00       	ld.sh	r0,r0[0x0]
80005bfe:	ea 80 80 00 	breq	80155bfe <_data_lma+0x1465be>
80005c02:	7f c4       	ld.w	r4,pc[0x70]
80005c04:	80 00       	ld.sh	r0,r0[0x0]
80005c06:	4a 0c       	lddpc	r12,80005c84 <delay_us+0x1c>
80005c08:	00 00       	add	r0,r0
80005c0a:	0e 20       	rsub	r0,r7
80005c0c:	80 00       	ld.sh	r0,r0[0x0]
80005c0e:	88 6e       	ld.sh	lr,r4[0xc]
80005c10:	00 00       	add	r0,r0
80005c12:	05 3c       	ld.ub	r12,r2++
80005c14:	00 00       	add	r0,r0
80005c16:	05 34       	ld.ub	r4,r2++
80005c18:	00 00       	add	r0,r0
80005c1a:	0b 9c       	ld.ub	r12,r5[0x1]
80005c1c:	80 00       	ld.sh	r0,r0[0x0]
80005c1e:	37 48       	mov	r8,116
80005c20:	00 00       	add	r0,r0
80005c22:	0b 8c       	ld.ub	r12,r5[0x0]
80005c24:	80 00       	ld.sh	r0,r0[0x0]
80005c26:	73 8c       	ld.w	r12,r9[0x60]
80005c28:	80 00       	ld.sh	r0,r0[0x0]
80005c2a:	e8 a8       	*unknown*
80005c2c:	80 00       	ld.sh	r0,r0[0x0]
80005c2e:	7a 58       	ld.w	r8,sp[0x14]
80005c30:	00 00       	add	r0,r0
80005c32:	0a 7c       	tst	r12,r5
80005c34:	80 00       	ld.sh	r0,r0[0x0]
80005c36:	71 80       	ld.w	r0,r8[0x60]
80005c38:	00 00       	add	r0,r0
80005c3a:	0a 84       	andn	r4,r5
80005c3c:	80 00       	ld.sh	r0,r0[0x0]
80005c3e:	e8 c0 80 00 	sub	r0,r4,-32768
80005c42:	ea 9c d4 01 	brvs	80180444 <_data_lma+0x170e04>

80005c44 <rfid_init>:
extern volatile U32 global_count;
extern volatile xSemaphoreHandle count_mutex;


void rfid_init()
{
80005c44:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
80005c46:	f0 1f 00 02 	mcall	80005c4c <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		//
}
80005c4a:	d8 02       	popm	pc
80005c4c:	80 00       	ld.sh	r0,r0[0x0]
80005c4e:	54 c8       	stdsp	sp[0x130],r8

80005c50 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005c50:	58 0c       	cp.w	r12,0
80005c52:	5e 0c       	reteq	r12
80005c54:	30 08       	mov	r8,0
	{
		nop();
80005c56:	d7 03       	nop
		nop();
80005c58:	d7 03       	nop
		nop();
80005c5a:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005c5c:	2f f8       	sub	r8,-1
80005c5e:	10 3c       	cp.w	r12,r8
80005c60:	fe 9b ff fb 	brhi	80005c56 <delay_ns+0x6>
80005c64:	5e fc       	retal	r12
80005c66:	d7 03       	nop

80005c68 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
80005c68:	eb cd 40 e0 	pushm	r5-r7,lr
80005c6c:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
80005c6e:	58 0c       	cp.w	r12,0
80005c70:	c0 b0       	breq	80005c86 <delay_us+0x1e>
80005c72:	30 07       	mov	r7,0
		delay_ns(1000);
80005c74:	e0 65 03 e8 	mov	r5,1000
80005c78:	0a 9c       	mov	r12,r5
80005c7a:	f0 1f 00 05 	mcall	80005c8c <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
80005c7e:	2f f7       	sub	r7,-1
80005c80:	0e 36       	cp.w	r6,r7
80005c82:	fe 9b ff fb 	brhi	80005c78 <delay_us+0x10>
80005c86:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005c8a:	00 00       	add	r0,r0
80005c8c:	80 00       	ld.sh	r0,r0[0x0]
80005c8e:	5c 50       	castu.b	r0

80005c90 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
80005c90:	eb cd 40 e0 	pushm	r5-r7,lr
80005c94:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
80005c96:	58 0c       	cp.w	r12,0
80005c98:	c0 b0       	breq	80005cae <delay_ms+0x1e>
80005c9a:	30 07       	mov	r7,0
		delay_us(1000);
80005c9c:	e0 65 03 e8 	mov	r5,1000
80005ca0:	0a 9c       	mov	r12,r5
80005ca2:	f0 1f 00 05 	mcall	80005cb4 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
80005ca6:	2f f7       	sub	r7,-1
80005ca8:	0e 36       	cp.w	r6,r7
80005caa:	fe 9b ff fb 	brhi	80005ca0 <delay_ms+0x10>
80005cae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005cb2:	00 00       	add	r0,r0
80005cb4:	80 00       	ld.sh	r0,r0[0x0]
80005cb6:	5c 68       	casts.b	r8

80005cb8 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80005cb8:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80005cba:	30 3b       	mov	r11,3
80005cbc:	48 8c       	lddpc	r12,80005cdc <local_start_timer+0x24>
80005cbe:	f0 1f 00 09 	mcall	80005ce0 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
80005cc2:	fe 78 38 00 	mov	r8,-51200
80005cc6:	e0 69 91 0d 	mov	r9,37133
80005cca:	ea 19 00 52 	orh	r9,0x52
80005cce:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005cd0:	32 09       	mov	r9,32
80005cd2:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005cd4:	30 59       	mov	r9,5
80005cd6:	91 09       	st.w	r8[0x0],r9
}
80005cd8:	d8 02       	popm	pc
80005cda:	00 00       	add	r0,r0
80005cdc:	80 00       	ld.sh	r0,r0[0x0]
80005cde:	ea b0 80 00 	rcall	80175cde <_data_lma+0x16669e>
80005ce2:	63 a8       	ld.w	r8,r1[0x68]

80005ce4 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
80005ce4:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
80005ce6:	30 3a       	mov	r10,3
80005ce8:	e0 6b 1b 00 	mov	r11,6912
80005cec:	ea 1b 00 b7 	orh	r11,0xb7
80005cf0:	fe 7c 0c 00 	mov	r12,-62464
80005cf4:	f0 1f 00 19 	mcall	80005d58 <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
80005cf8:	31 08       	mov	r8,16
80005cfa:	1a d8       	st.w	--sp,r8
80005cfc:	30 08       	mov	r8,0
80005cfe:	30 19       	mov	r9,1
80005d00:	30 7a       	mov	r10,7
80005d02:	10 9b       	mov	r11,r8
80005d04:	fe 7c 0c 00 	mov	r12,-62464
80005d08:	f0 1f 00 15 	mcall	80005d5c <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
80005d0c:	30 08       	mov	r8,0
80005d0e:	30 19       	mov	r9,1
80005d10:	12 9a       	mov	r10,r9
80005d12:	10 9b       	mov	r11,r8
80005d14:	fe 7c 0c 00 	mov	r12,-62464
80005d18:	f0 1f 00 12 	mcall	80005d60 <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
80005d1c:	30 0b       	mov	r11,0
80005d1e:	fe 7c 0c 00 	mov	r12,-62464
80005d22:	f0 1f 00 11 	mcall	80005d64 <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
80005d26:	fe 7c 0c 00 	mov	r12,-62464
80005d2a:	f0 1f 00 10 	mcall	80005d68 <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
80005d2e:	30 0a       	mov	r10,0
80005d30:	1a da       	st.w	--sp,r10
80005d32:	1a da       	st.w	--sp,r10
80005d34:	14 98       	mov	r8,r10
80005d36:	14 99       	mov	r9,r10
80005d38:	30 1b       	mov	r11,1
80005d3a:	fe 7c 0c 00 	mov	r12,-62464
80005d3e:	f0 1f 00 0c 	mcall	80005d6c <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
80005d42:	30 1c       	mov	r12,1
80005d44:	f0 1f 00 0b 	mcall	80005d70 <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
80005d48:	30 2b       	mov	r11,2
80005d4a:	fe 7c 0c 00 	mov	r12,-62464
80005d4e:	f0 1f 00 0a 	mcall	80005d74 <local_start_pll0+0x90>
80005d52:	2f dd       	sub	sp,-12
/****/
}
80005d54:	d8 02       	popm	pc
80005d56:	00 00       	add	r0,r0
80005d58:	80 00       	ld.sh	r0,r0[0x0]
80005d5a:	66 b0       	ld.w	r0,r3[0x2c]
80005d5c:	80 00       	ld.sh	r0,r0[0x0]
80005d5e:	66 52       	ld.w	r2,r3[0x14]
80005d60:	80 00       	ld.sh	r0,r0[0x0]
80005d62:	66 74       	ld.w	r4,r3[0x1c]
80005d64:	80 00       	ld.sh	r0,r0[0x0]
80005d66:	66 8e       	ld.w	lr,r3[0x20]
80005d68:	80 00       	ld.sh	r0,r0[0x0]
80005d6a:	66 9c       	ld.w	r12,r3[0x24]
80005d6c:	80 00       	ld.sh	r0,r0[0x0]
80005d6e:	66 0c       	ld.w	r12,r3[0x0]
80005d70:	80 00       	ld.sh	r0,r0[0x0]
80005d72:	63 48       	ld.w	r8,r1[0x50]
80005d74:	80 00       	ld.sh	r0,r0[0x0]
80005d76:	66 a6       	ld.w	r6,r3[0x28]

80005d78 <xg_flashc_init>:
}


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
80005d78:	d4 31       	pushm	r0-r7,lr
80005d7a:	20 3d       	sub	sp,12
	
	/* Create the mutex semaphore to guard a shared xgflash.*/
	xgflash_mutex = xSemaphoreCreateMutex();
80005d7c:	f0 1f 00 8a 	mcall	80005fa4 <xg_flashc_init+0x22c>
80005d80:	fe f8 02 28 	ld.w	r8,pc[552]
80005d84:	91 0c       	st.w	r8[0x0],r12
	if (xgflash_mutex == NULL)
80005d86:	70 08       	ld.w	r8,r8[0x0]
80005d88:	58 08       	cp.w	r8,0
80005d8a:	c0 51       	brne	80005d94 <xg_flashc_init+0x1c>
	{
		log("Create the xgflash_mutex semaphore failure\n");
80005d8c:	fe fc 02 20 	ld.w	r12,pc[544]
80005d90:	f0 1f 00 88 	mcall	80005fb0 <xg_flashc_init+0x238>
	}
	
	/* Create the binary semaphore to Synchronize other threads.*/
	vSemaphoreCreateBinary(xBinarySemaphore);
80005d94:	30 0b       	mov	r11,0
80005d96:	30 1c       	mov	r12,1
80005d98:	f0 1f 00 87 	mcall	80005fb4 <xg_flashc_init+0x23c>
80005d9c:	fe f8 02 1c 	ld.w	r8,pc[540]
80005da0:	91 0c       	st.w	r8[0x0],r12
80005da2:	70 08       	ld.w	r8,r8[0x0]
80005da4:	58 08       	cp.w	r8,0
80005da6:	c0 90       	breq	80005db8 <xg_flashc_init+0x40>
80005da8:	fe f8 02 10 	ld.w	r8,pc[528]
80005dac:	70 0c       	ld.w	r12,r8[0x0]
80005dae:	30 09       	mov	r9,0
80005db0:	12 9a       	mov	r10,r9
80005db2:	12 9b       	mov	r11,r9
80005db4:	f0 1f 00 82 	mcall	80005fbc <xg_flashc_init+0x244>
	if (xBinarySemaphore == NULL)
80005db8:	fe f8 02 00 	ld.w	r8,pc[512]
80005dbc:	70 08       	ld.w	r8,r8[0x0]
80005dbe:	58 08       	cp.w	r8,0
80005dc0:	c0 51       	brne	80005dca <xg_flashc_init+0x52>
	{
		log("Create the xBinarySemaphore semaphore failure\n");
80005dc2:	fe fc 01 fe 	ld.w	r12,pc[510]
80005dc6:	f0 1f 00 7b 	mcall	80005fb0 <xg_flashc_init+0x238>
	//if (SendM_CountingSemaphore == NULL)
	//{
		//log("Create the SendM_Counting semaphore failure\n");
	//}
	
	xg_resend_queue = xQueueCreate(270, sizeof(U32));
80005dca:	30 4b       	mov	r11,4
80005dcc:	e0 6c 01 0e 	mov	r12,270
80005dd0:	f0 1f 00 79 	mcall	80005fb4 <xg_flashc_init+0x23c>
80005dd4:	4f c8       	lddpc	r8,80005fc4 <xg_flashc_init+0x24c>
80005dd6:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
80005dd8:	30 4b       	mov	r11,4
80005dda:	e0 6c 01 2c 	mov	r12,300
80005dde:	f0 1f 00 76 	mcall	80005fb4 <xg_flashc_init+0x23c>
80005de2:	4f a8       	lddpc	r8,80005fc8 <xg_flashc_init+0x250>
80005de4:	91 0c       	st.w	r8[0x0],r12
80005de6:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
80005de8:	10 96       	mov	r6,r8
80005dea:	4f 95       	lddpc	r5,80005fcc <xg_flashc_init+0x254>
80005dec:	6c 0c       	ld.w	r12,r6[0x0]
80005dee:	ea 07 00 0b 	add	r11,r5,r7
80005df2:	f0 1f 00 78 	mcall	80005fd0 <xg_flashc_init+0x258>
80005df6:	2e 07       	sub	r7,-32
	//}
	
	xg_resend_queue = xQueueCreate(270, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
80005df8:	e0 47 25 80 	cp.w	r7,9600
80005dfc:	cf 81       	brne	80005dec <xg_flashc_init+0x74>
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
	}
	
	
	data_flash_init();//interface
80005dfe:	f0 1f 00 76 	mcall	80005fd4 <xg_flashc_init+0x25c>
	df_status_t return_code = DF_OK;
	static U32 current_page_number =0;
	unsigned int i = 0;
	unsigned int address =0x00000000;
	static char str[80];
	memset(str, 0x00, sizeof(str));
80005e02:	30 0a       	mov	r10,0
80005e04:	30 0b       	mov	r11,0
80005e06:	4f 58       	lddpc	r8,80005fd8 <xg_flashc_init+0x260>
80005e08:	b1 2a       	st.d	r8++,r10
80005e0a:	b1 2a       	st.d	r8++,r10
80005e0c:	b1 2a       	st.d	r8++,r10
80005e0e:	b1 2a       	st.d	r8++,r10
80005e10:	b1 2a       	st.d	r8++,r10
80005e12:	b1 2a       	st.d	r8++,r10
80005e14:	b1 2a       	st.d	r8++,r10
80005e16:	b1 2a       	st.d	r8++,r10
80005e18:	b1 2a       	st.d	r8++,r10
80005e1a:	f0 eb 00 00 	st.d	r8[0],r10
80005e1e:	30 05       	mov	r5,0
	
start:
	
	 //bytes remained less than one page 
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80005e20:	4e e7       	lddpc	r7,80005fd8 <xg_flashc_init+0x260>
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
					
					log("current_message_index: %d\n", current_message_index);
					memset(str, 0x00, sizeof(str));	
80005e22:	ee c4 ff f8 	sub	r4,r7,-8
80005e26:	e8 c3 ff f8 	sub	r3,r4,-8
80005e2a:	e6 c2 ff f8 	sub	r2,r3,-8
80005e2e:	e4 c1 ff f8 	sub	r1,r2,-8
80005e32:	e2 c0 ff f8 	sub	r0,r1,-8
80005e36:	e0 ca ff f8 	sub	r10,r0,-8
80005e3a:	50 0a       	stdsp	sp[0x0],r10
80005e3c:	2f 8a       	sub	r10,-8
80005e3e:	50 1a       	stdsp	sp[0x4],r10
80005e40:	2f 8a       	sub	r10,-8
80005e42:	50 2a       	stdsp	sp[0x8],r10
	memset(str, 0x00, sizeof(str));
	
start:
	
	 //bytes remained less than one page 
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80005e44:	0e 9a       	mov	r10,r7
80005e46:	30 6b       	mov	r11,6
80005e48:	30 0c       	mov	r12,0
80005e4a:	f0 1f 00 65 	mcall	80005fdc <xg_flashc_init+0x264>
	{
		if(memcmp(XGFlashLabel, str, sizeof(XGFlashLabel)-1) != 0)//compare label
80005e4e:	30 6a       	mov	r10,6
80005e50:	0e 9b       	mov	r11,r7
80005e52:	4e 4c       	lddpc	r12,80005fe0 <xg_flashc_init+0x268>
80005e54:	f0 1f 00 64 	mcall	80005fe4 <xg_flashc_init+0x26c>
80005e58:	c1 c0       	breq	80005e90 <xg_flashc_init+0x118>
80005e5a:	c8 b8       	rjmp	80005f70 <xg_flashc_init+0x1f8>
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
			}
			//set label
			return_code = data_flash_write(XGFlashLabel, LABEL_ADDRESS, LABEL_LENGTH);
80005e5c:	30 6a       	mov	r10,6
80005e5e:	30 0b       	mov	r11,0
80005e60:	4e 0c       	lddpc	r12,80005fe0 <xg_flashc_init+0x268>
80005e62:	f0 1f 00 62 	mcall	80005fe8 <xg_flashc_init+0x270>
			
			//set current_voice_index
			memset(str, 0x00, sizeof(str));
80005e66:	4d d7       	lddpc	r7,80005fd8 <xg_flashc_init+0x260>
80005e68:	35 0a       	mov	r10,80
80005e6a:	30 0b       	mov	r11,0
80005e6c:	0e 9c       	mov	r12,r7
80005e6e:	f0 1f 00 60 	mcall	80005fec <xg_flashc_init+0x274>
			return_code = data_flash_write(str, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
80005e72:	30 2a       	mov	r10,2
80005e74:	30 6b       	mov	r11,6
80005e76:	0e 9c       	mov	r12,r7
80005e78:	f0 1f 00 5c 	mcall	80005fe8 <xg_flashc_init+0x270>
			if(return_code != DF_WRITE_COMPLETED)
80005e7c:	58 7c       	cp.w	r12,7
80005e7e:	e0 81 00 90 	brne	80005f9e <xg_flashc_init+0x226>
			{
				return FALSE;
			}
			current_message_index = 0;
80005e82:	30 09       	mov	r9,0
80005e84:	4d b8       	lddpc	r8,80005ff0 <xg_flashc_init+0x278>
80005e86:	b0 09       	st.h	r8[0x0],r9
			log("\r\n----create xg message info okay!----\r\n");
80005e88:	4d bc       	lddpc	r12,80005ff4 <xg_flashc_init+0x27c>
80005e8a:	f0 1f 00 4a 	mcall	80005fb0 <xg_flashc_init+0x238>
80005e8e:	c8 58       	rjmp	80005f98 <xg_flashc_init+0x220>
		}
		else//success
		{
			log("\nLABEL: %s\n", str);
80005e90:	1a d7       	st.w	--sp,r7
80005e92:	4d ac       	lddpc	r12,80005ff8 <xg_flashc_init+0x280>
80005e94:	f0 1f 00 47 	mcall	80005fb0 <xg_flashc_init+0x238>
			//Get the current voice index
			return_code = data_flash_read_block(MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH, &current_message_index);								
80005e98:	4d 6a       	lddpc	r10,80005ff0 <xg_flashc_init+0x278>
80005e9a:	30 2b       	mov	r11,2
80005e9c:	30 6c       	mov	r12,6
80005e9e:	f0 1f 00 50 	mcall	80005fdc <xg_flashc_init+0x264>
			if(return_code == DF_OK)
80005ea2:	2f fd       	sub	sp,-4
80005ea4:	58 0c       	cp.w	r12,0
80005ea6:	e0 81 00 7c 	brne	80005f9e <xg_flashc_init+0x226>
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
80005eaa:	4d 28       	lddpc	r8,80005ff0 <xg_flashc_init+0x278>
80005eac:	90 08       	ld.sh	r8,r8[0x0]
80005eae:	58 08       	cp.w	r8,0
80005eb0:	c7 10       	breq	80005f92 <xg_flashc_init+0x21a>
					
					log("current_message_index: %d\n", current_message_index);
80005eb2:	5c 78       	castu.h	r8
80005eb4:	1a d8       	st.w	--sp,r8
80005eb6:	4d 2c       	lddpc	r12,80005ffc <xg_flashc_init+0x284>
80005eb8:	f0 1f 00 3e 	mcall	80005fb0 <xg_flashc_init+0x238>
					memset(str, 0x00, sizeof(str));	
80005ebc:	30 08       	mov	r8,0
80005ebe:	30 09       	mov	r9,0
80005ec0:	ee e9 00 00 	st.d	r7[0],r8
80005ec4:	e8 e9 00 00 	st.d	r4[0],r8
80005ec8:	e6 e9 00 00 	st.d	r3[0],r8
80005ecc:	e4 e9 00 00 	st.d	r2[0],r8
80005ed0:	e2 e9 00 00 	st.d	r1[0],r8
80005ed4:	e0 e9 00 00 	st.d	r0[0],r8
80005ed8:	40 1a       	lddsp	r10,sp[0x4]
80005eda:	f4 e9 00 00 	st.d	r10[0],r8
80005ede:	40 2a       	lddsp	r10,sp[0x8]
80005ee0:	f4 e9 00 00 	st.d	r10[0],r8
80005ee4:	40 3a       	lddsp	r10,sp[0xc]
80005ee6:	b5 28       	st.d	r10++,r8
80005ee8:	f4 e9 00 00 	st.d	r10[0],r8
					address = XG_MESSAGE_INFO_HEADER_START_ADD + ((current_message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
80005eec:	4c 18       	lddpc	r8,80005ff0 <xg_flashc_init+0x278>
80005eee:	90 85       	ld.uh	r5,r8[0x0]
80005ef0:	a3 75       	lsl	r5,0x3
					return_code = data_flash_read_block(address, XG_MESSAGE_INFO_HEADER_LENGTH, (U8 *)str);			
80005ef2:	0e 9a       	mov	r10,r7
80005ef4:	30 8b       	mov	r11,8
80005ef6:	0a 9c       	mov	r12,r5
80005ef8:	f0 1f 00 39 	mcall	80005fdc <xg_flashc_init+0x264>
					if(return_code == DF_OK)
80005efc:	2f fd       	sub	sp,-4
80005efe:	58 0c       	cp.w	r12,0
80005f00:	c4 91       	brne	80005f92 <xg_flashc_init+0x21a>
					{
						MessageList_Info_t *ptr = (MessageList_Info_t *)str;
						if(ptr->numb == current_message_index)
80005f02:	0f 89       	ld.ub	r9,r7[0x0]
80005f04:	0f 98       	ld.ub	r8,r7[0x1]
80005f06:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80005f0a:	4b a9       	lddpc	r9,80005ff0 <xg_flashc_init+0x278>
80005f0c:	92 09       	ld.sh	r9,r9[0x0]
80005f0e:	f0 09 19 00 	cp.h	r9,r8
80005f12:	c2 c1       	brne	80005f6a <xg_flashc_init+0x1f2>
						{
							current_save_message_offset = ptr->address + ptr->offset;
80005f14:	0f e9       	ld.ub	r9,r7[0x6]
80005f16:	0f f8       	ld.ub	r8,r7[0x7]
80005f18:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80005f1c:	0f aa       	ld.ub	r10,r7[0x2]
80005f1e:	0f b8       	ld.ub	r8,r7[0x3]
80005f20:	b1 68       	lsl	r8,0x10
80005f22:	f1 ea 11 88 	or	r8,r8,r10<<0x18
80005f26:	0f ca       	ld.ub	r10,r7[0x4]
80005f28:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80005f2c:	0f da       	ld.ub	r10,r7[0x5]
80005f2e:	f5 e8 10 08 	or	r8,r10,r8
80005f32:	f2 08 00 08 	add	r8,r9,r8
80005f36:	4b 36       	lddpc	r6,80006000 <xg_flashc_init+0x288>
80005f38:	8d 08       	st.w	r6[0x0],r8
							log("current_save_message_offset : %X\n", current_save_message_offset);
80005f3a:	1a d8       	st.w	--sp,r8
80005f3c:	4b 2c       	lddpc	r12,80006004 <xg_flashc_init+0x28c>
80005f3e:	f0 1f 00 1d 	mcall	80005fb0 <xg_flashc_init+0x238>
							if(current_save_message_offset > XG_MESSAGE_DATA_BOUNDARY_ADD){
80005f42:	2f fd       	sub	sp,-4
80005f44:	6c 08       	ld.w	r8,r6[0x0]
80005f46:	e0 69 ff ff 	mov	r9,65535
80005f4a:	ea 19 00 7f 	orh	r9,0x7f
80005f4e:	12 38       	cp.w	r8,r9
80005f50:	e0 88 00 21 	brls	80005f92 <xg_flashc_init+0x21a>
										
								log("\r\n----message storage is full!!!----\r\n");
80005f54:	4a dc       	lddpc	r12,80006008 <xg_flashc_init+0x290>
80005f56:	f0 1f 00 17 	mcall	80005fb0 <xg_flashc_init+0x238>
								//xgflash erase

								return_code = data_flash_erase_block(0, DF_BLOCK_ALL);
80005f5a:	30 4b       	mov	r11,4
80005f5c:	30 0c       	mov	r12,0
80005f5e:	f0 1f 00 2c 	mcall	8000600c <xg_flashc_init+0x294>
								if(return_code == DF_ERASE_COMPLETED)goto start;
80005f62:	58 5c       	cp.w	r12,5
80005f64:	fe 90 ff 70 	breq	80005e44 <xg_flashc_init+0xcc>
80005f68:	c1 b8       	rjmp	80005f9e <xg_flashc_init+0x226>

							}
						}
						else
						{
							log("\r\n----message storage is err!!!----\r\n");
80005f6a:	4a ac       	lddpc	r12,80006010 <xg_flashc_init+0x298>
80005f6c:	f0 1f 00 11 	mcall	80005fb0 <xg_flashc_init+0x238>
		{
			ERASE:
			//erase list
			for(i; i < (XG_MESSAGE_LISTINFO_BOUNDARY_ADD/(64*1024)); i++)//2*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80005f70:	30 3b       	mov	r11,3
80005f72:	0a 9c       	mov	r12,r5
80005f74:	f0 1f 00 26 	mcall	8000600c <xg_flashc_init+0x294>
				if(return_code != DF_ERASE_COMPLETED)
80005f78:	58 5c       	cp.w	r12,5
80005f7a:	c1 21       	brne	80005f9e <xg_flashc_init+0x226>
		{
			ERASE:
			//erase list
			for(i; i < (XG_MESSAGE_LISTINFO_BOUNDARY_ADD/(64*1024)); i++)//2*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80005f7c:	30 3b       	mov	r11,3
80005f7e:	e0 78 00 00 	mov	r8,65536
80005f82:	ea 08 00 0c 	add	r12,r5,r8
80005f86:	f0 1f 00 22 	mcall	8000600c <xg_flashc_init+0x294>
				if(return_code != DF_ERASE_COMPLETED)
80005f8a:	58 5c       	cp.w	r12,5
80005f8c:	fe 90 ff 68 	breq	80005e5c <xg_flashc_init+0xe4>
80005f90:	c0 78       	rjmp	80005f9e <xg_flashc_init+0x226>
							log("\r\n----message storage is err!!!----\r\n");
							goto ERASE;
						}
					}
				}
				log("\r\n----xoxo read message info okay!----\r\n");
80005f92:	4a 1c       	lddpc	r12,80006014 <xg_flashc_init+0x29c>
80005f94:	f0 1f 00 07 	mcall	80005fb0 <xg_flashc_init+0x238>
			else
				return FALSE;
			
		}
				
		list_init_success_flag = 1;
80005f98:	30 19       	mov	r9,1
80005f9a:	4a 08       	lddpc	r8,80006018 <xg_flashc_init+0x2a0>
80005f9c:	b0 89       	st.b	r8[0x0],r9
	
	xgflash_list_info_init();
	
	
	//create_xg_flash_test_task();
}
80005f9e:	2f dd       	sub	sp,-12
80005fa0:	d8 32       	popm	r0-r7,pc
80005fa2:	00 00       	add	r0,r0
80005fa4:	80 00       	ld.sh	r0,r0[0x0]
80005fa6:	74 8c       	ld.w	r12,r10[0x20]
80005fa8:	00 00       	add	r0,r0
80005faa:	0b 94       	ld.ub	r4,r5[0x1]
80005fac:	80 00       	ld.sh	r0,r0[0x0]
80005fae:	ea c8 80 00 	sub	r8,r5,-32768
80005fb2:	7f c4       	ld.w	r4,pc[0x70]
80005fb4:	80 00       	ld.sh	r0,r0[0x0]
80005fb6:	74 e4       	ld.w	r4,r10[0x38]
80005fb8:	00 00       	add	r0,r0
80005fba:	0b a0       	ld.ub	r0,r5[0x2]
80005fbc:	80 00       	ld.sh	r0,r0[0x0]
80005fbe:	73 8c       	ld.w	r12,r9[0x60]
80005fc0:	80 00       	ld.sh	r0,r0[0x0]
80005fc2:	ea f4 00 00 	ld.w	r4,r5[0]
80005fc6:	0b 8c       	ld.ub	r12,r5[0x0]
80005fc8:	00 00       	add	r0,r0
80005fca:	0b 9c       	ld.ub	r12,r5[0x1]
80005fcc:	00 00       	add	r0,r0
80005fce:	97 c0       	st.w	r11[0x30],r0
80005fd0:	80 00       	ld.sh	r0,r0[0x0]
80005fd2:	35 9c       	mov	r12,89
80005fd4:	80 00       	ld.sh	r0,r0[0x0]
80005fd6:	32 64       	mov	r4,38
80005fd8:	00 00       	add	r0,r0
80005fda:	0b a8       	ld.ub	r8,r5[0x2]
80005fdc:	80 00       	ld.sh	r0,r0[0x0]
80005fde:	2f 08       	sub	r8,-16
80005fe0:	00 00       	add	r0,r0
80005fe2:	05 40       	ld.w	r0,--r2
80005fe4:	80 00       	ld.sh	r0,r0[0x0]
80005fe6:	88 48       	ld.sh	r8,r4[0x8]
80005fe8:	80 00       	ld.sh	r0,r0[0x0]
80005fea:	31 40       	mov	r0,20
80005fec:	80 00       	ld.sh	r0,r0[0x0]
80005fee:	89 b6       	st.w	r4[0x2c],r6
80005ff0:	00 00       	add	r0,r0
80005ff2:	0b a4       	ld.ub	r4,r5[0x2]
80005ff4:	80 00       	ld.sh	r0,r0[0x0]
80005ff6:	eb 24 80 00 	ld.sb	r4,r5[-32768]
80005ffa:	eb 50 80 00 	st.h	r5[-32768],r0
80005ffe:	eb 5c 00 00 	st.h	r5[0],r12
80006002:	05 48       	ld.w	r8,--r2
80006004:	80 00       	ld.sh	r0,r0[0x0]
80006006:	eb 78 80 00 	stcond	r5[-32768],r8
8000600a:	eb 9c       	*unknown*
8000600c:	80 00       	ld.sh	r0,r0[0x0]
8000600e:	30 a0       	mov	r0,10
80006010:	80 00       	ld.sh	r0,r0[0x0]
80006012:	eb c4 80 00 	stm	--r4,pc
80006016:	eb ec 00 00 	and	r0,r5,r12
8000601a:	0b 90       	ld.ub	r0,r5[0x1]

8000601c <xgflash_get_message_data>:
	return XG_OK;

}

xgflash_status_t xgflash_get_message_data(U32 message_index, void *buff_ptr, bool erase)
{
8000601c:	d4 31       	pushm	r0-r7,lr
8000601e:	20 2d       	sub	sp,8
80006020:	18 95       	mov	r5,r12
80006022:	16 96       	mov	r6,r11
80006024:	14 93       	mov	r3,r10
	xgflash_status_t status = XG_ERROR;
	
	if(!list_init_success_flag)return XG_ERROR;
80006026:	4c 78       	lddpc	r8,80006140 <xgflash_get_message_data+0x124>
80006028:	11 89       	ld.ub	r9,r8[0x0]
8000602a:	30 08       	mov	r8,0
8000602c:	f0 09 18 00 	cp.b	r9,r8
80006030:	c0 31       	brne	80006036 <xgflash_get_message_data+0x1a>
80006032:	3f f7       	mov	r7,-1
80006034:	c8 28       	rjmp	80006138 <xgflash_get_message_data+0x11c>
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY);//lock
80006036:	4c 48       	lddpc	r8,80006144 <xgflash_get_message_data+0x128>
80006038:	70 0c       	ld.w	r12,r8[0x0]
8000603a:	30 09       	mov	r9,0
8000603c:	3f fa       	mov	r10,-1
8000603e:	12 9b       	mov	r11,r9
80006040:	f0 1f 00 42 	mcall	80006148 <xgflash_get_message_data+0x12c>
	/* check input parameter */
	if (message_index > current_message_index)
80006044:	4c 28       	lddpc	r8,8000614c <xgflash_get_message_data+0x130>
80006046:	90 88       	ld.uh	r8,r8[0x0]
80006048:	0a 38       	cp.w	r8,r5
8000604a:	c0 a2       	brcc	8000605e <xgflash_get_message_data+0x42>
	{
		xSemaphoreGive(xgflash_mutex);//unlock
8000604c:	4b e8       	lddpc	r8,80006144 <xgflash_get_message_data+0x128>
8000604e:	70 0c       	ld.w	r12,r8[0x0]
80006050:	30 09       	mov	r9,0
80006052:	12 9a       	mov	r10,r9
80006054:	12 9b       	mov	r11,r9
80006056:	f0 1f 00 3f 	mcall	80006150 <xgflash_get_message_data+0x134>
8000605a:	30 17       	mov	r7,1
		return XG_INVALID_PARAM;
8000605c:	c6 e8       	rjmp	80006138 <xgflash_get_message_data+0x11c>
	U32 data_address =0x00000000;
	U32 erase_address =0x00;
	U32 erase_length =0x00;
	
	char str[XG_MESSAGE_INFO_HEADER_LENGTH];
	memset(str, 0x00, sizeof(str));
8000605e:	fa ca ff f8 	sub	r10,sp,-8
80006062:	30 08       	mov	r8,0
80006064:	30 09       	mov	r9,0
80006066:	b5 29       	st.d	--r10,r8
	
	//find the message storage info by message_index
	info_address = XG_MESSAGE_INFO_HEADER_START_ADD + ((message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
	//flashc_memcpy((void *)str, (void *)info_address, XG_MESSAGE_INFO_HEADER_LENGTH,  false);
	return_code = data_flash_read_block(info_address, XG_MESSAGE_INFO_HEADER_LENGTH, (U8 *)str);
80006068:	1a 9a       	mov	r10,sp
8000606a:	30 8b       	mov	r11,8
8000606c:	ea 0c 15 03 	lsl	r12,r5,0x3
80006070:	f0 1f 00 39 	mcall	80006154 <xgflash_get_message_data+0x138>
	if (return_code == DF_OK)
80006074:	c5 a1       	brne	80006128 <xgflash_get_message_data+0x10c>
	{
		U16 bytes_remained;
		MessageList_Info_t *ptr = (MessageList_Info_t *)str;
		if(ptr->numb == message_index)
80006076:	9a 88       	ld.uh	r8,sp[0x0]
80006078:	0a 38       	cp.w	r8,r5
8000607a:	c3 31       	brne	800060e0 <xgflash_get_message_data+0xc4>
		{
			bytes_remained = ptr->offset;
8000607c:	40 18       	lddsp	r8,sp[0x4]
8000607e:	ef d8 b0 10 	bfexts	r7,r8,0x0,0x10
			erase_length = ptr->offset;
			
			data_address = ptr->address;
80006082:	9a 95       	ld.uh	r5,sp[0x2]
80006084:	b1 88       	lsr	r8,0x10
80006086:	f1 e5 11 05 	or	r5,r8,r5<<0x10
			erase_address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
8000608a:	30 04       	mov	r4,0
8000608c:	08 92       	mov	r2,r4
			{
				if(bytes_remained < DF_DATA_SPACE_SIZE)//< 512bytes
8000608e:	e0 61 01 ff 	mov	r1,511
					bytes_remained = 0;	/* end while loop */

				}
				else//bytes_remained > DF_DATA_SPACE_SIZE
				{
					return_code = data_flash_read_block(data_address, DF_DATA_SPACE_SIZE, buff_ptr);
80006092:	e0 60 02 00 	mov	r0,512
			erase_length = ptr->offset;
			
			data_address = ptr->address;
			erase_address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
80006096:	c1 98       	rjmp	800060c8 <xgflash_get_message_data+0xac>
			{
				if(bytes_remained < DF_DATA_SPACE_SIZE)//< 512bytes
80006098:	e2 07 19 00 	cp.h	r7,r1
8000609c:	e0 8b 00 0a 	brhi	800060b0 <xgflash_get_message_data+0x94>
				{
					return_code = data_flash_read_block(data_address, bytes_remained, buff_ptr);
800060a0:	0c 9a       	mov	r10,r6
800060a2:	0e 9b       	mov	r11,r7
800060a4:	5c 7b       	castu.h	r11
800060a6:	0a 9c       	mov	r12,r5
800060a8:	f0 1f 00 2b 	mcall	80006154 <xgflash_get_message_data+0x138>
800060ac:	30 07       	mov	r7,0
800060ae:	c0 d8       	rjmp	800060c8 <xgflash_get_message_data+0xac>
					bytes_remained = 0;	/* end while loop */

				}
				else//bytes_remained > DF_DATA_SPACE_SIZE
				{
					return_code = data_flash_read_block(data_address, DF_DATA_SPACE_SIZE, buff_ptr);
800060b0:	0c 9a       	mov	r10,r6
800060b2:	00 9b       	mov	r11,r0
800060b4:	0a 9c       	mov	r12,r5
800060b6:	f0 1f 00 28 	mcall	80006154 <xgflash_get_message_data+0x138>
					bytes_remained-=DF_DATA_SPACE_SIZE;
800060ba:	ee c7 02 00 	sub	r7,r7,512
800060be:	5c 87       	casts.h	r7
					data_address+=DF_DATA_SPACE_SIZE;
800060c0:	ea c5 fe 00 	sub	r5,r5,-512
					buff_ptr+=DF_DATA_SPACE_SIZE;
800060c4:	ec c6 fe 00 	sub	r6,r6,-512
			erase_length = ptr->offset;
			
			data_address = ptr->address;
			erase_address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
800060c8:	e8 07 19 00 	cp.h	r7,r4
800060cc:	5f 19       	srne	r9
800060ce:	58 0c       	cp.w	r12,0
800060d0:	5f 08       	sreq	r8
800060d2:	f3 e8 00 08 	and	r8,r9,r8
800060d6:	e4 08 18 00 	cp.b	r8,r2
800060da:	cd f1       	brne	80006098 <xgflash_get_message_data+0x7c>
800060dc:	30 07       	mov	r7,0
800060de:	c0 58       	rjmp	800060e8 <xgflash_get_message_data+0xcc>
			}
			status = XG_OK;
		}
		else
		{
			log("Err flash data\n");
800060e0:	49 ec       	lddpc	r12,80006158 <xgflash_get_message_data+0x13c>
800060e2:	f0 1f 00 1f 	mcall	8000615c <xgflash_get_message_data+0x140>
800060e6:	30 87       	mov	r7,8
			
			//xSemaphoreGive(xgflash_mutex);//unlock
			status = 8;
			//return 7;
		}
		if(erase)//erase the message
800060e8:	58 03       	cp.w	r3,0
800060ea:	c1 70       	breq	80006118 <xgflash_get_message_data+0xfc>
		{
			memset(str, 0x00, sizeof(str));
800060ec:	30 08       	mov	r8,0
800060ee:	30 09       	mov	r9,0
800060f0:	fa e9 00 00 	st.d	sp[0],r8
			//reset:current_message_index and erase info
			current_message_index-=1;
800060f4:	49 6c       	lddpc	r12,8000614c <xgflash_get_message_data+0x130>
800060f6:	98 08       	ld.sh	r8,r12[0x0]
800060f8:	20 18       	sub	r8,1
800060fa:	b8 08       	st.h	r12[0x0],r8
			return_code = data_flash_write((U8 *)&current_message_index, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
800060fc:	30 2a       	mov	r10,2
800060fe:	30 6b       	mov	r11,6
80006100:	f0 1f 00 18 	mcall	80006160 <xgflash_get_message_data+0x144>
			if (return_code != DF_WRITE_COMPLETED)
80006104:	58 7c       	cp.w	r12,7
80006106:	c0 50       	breq	80006110 <xgflash_get_message_data+0xf4>
			{
				log("data_flash_write 1...\n");
80006108:	49 7c       	lddpc	r12,80006164 <xgflash_get_message_data+0x148>
8000610a:	f0 1f 00 15 	mcall	8000615c <xgflash_get_message_data+0x140>
8000610e:	30 77       	mov	r7,7
				//status = XG_FLASH_WRITE_FAIL;
			//}
					//
			////erase data and reset:current_save_message_offset
			//return_code = data_flash_write((U8 *)str, erase_address, sizeof(str));
			current_save_message_offset-=32;//出错在这...如果掉线，未执行，则会出现存储碎片
80006110:	49 68       	lddpc	r8,80006168 <xgflash_get_message_data+0x14c>
80006112:	70 09       	ld.w	r9,r8[0x0]
80006114:	22 09       	sub	r9,32
80006116:	91 09       	st.w	r8[0x0],r9
				//status = XG_FLASH_WRITE_FAIL;
			//}
					
		}
				
		xSemaphoreGive(xgflash_mutex);//unlock
80006118:	48 b8       	lddpc	r8,80006144 <xgflash_get_message_data+0x128>
8000611a:	70 0c       	ld.w	r12,r8[0x0]
8000611c:	30 09       	mov	r9,0
8000611e:	12 9a       	mov	r10,r9
80006120:	12 9b       	mov	r11,r9
80006122:	f0 1f 00 0c 	mcall	80006150 <xgflash_get_message_data+0x134>
		//status = XG_OK;
		return status;
80006126:	c0 98       	rjmp	80006138 <xgflash_get_message_data+0x11c>
	}
	
	xSemaphoreGive(xgflash_mutex);//unlock
80006128:	48 78       	lddpc	r8,80006144 <xgflash_get_message_data+0x128>
8000612a:	70 0c       	ld.w	r12,r8[0x0]
8000612c:	30 09       	mov	r9,0
8000612e:	12 9a       	mov	r10,r9
80006130:	12 9b       	mov	r11,r9
80006132:	f0 1f 00 08 	mcall	80006150 <xgflash_get_message_data+0x134>
80006136:	30 67       	mov	r7,6
	return XG_FLASH_READ_FAIL;
		
}
80006138:	0e 9c       	mov	r12,r7
8000613a:	2f ed       	sub	sp,-8
8000613c:	d8 32       	popm	r0-r7,pc
8000613e:	00 00       	add	r0,r0
80006140:	00 00       	add	r0,r0
80006142:	0b 90       	ld.ub	r0,r5[0x1]
80006144:	00 00       	add	r0,r0
80006146:	0b 94       	ld.ub	r4,r5[0x1]
80006148:	80 00       	ld.sh	r0,r0[0x0]
8000614a:	71 80       	ld.w	r0,r8[0x60]
8000614c:	00 00       	add	r0,r0
8000614e:	0b a4       	ld.ub	r4,r5[0x2]
80006150:	80 00       	ld.sh	r0,r0[0x0]
80006152:	73 8c       	ld.w	r12,r9[0x60]
80006154:	80 00       	ld.sh	r0,r0[0x0]
80006156:	2f 08       	sub	r8,-16
80006158:	80 00       	ld.sh	r0,r0[0x0]
8000615a:	ec 28 80 00 	sub	r8,819200
8000615e:	7f c4       	ld.w	r4,pc[0x70]
80006160:	80 00       	ld.sh	r0,r0[0x0]
80006162:	31 40       	mov	r0,20
80006164:	80 00       	ld.sh	r0,r0[0x0]
80006166:	ec 38 00 00 	sub	r8,851968
8000616a:	05 48       	ld.w	r8,--r2

8000616c <xgflash_message_save>:
	
}

//static U32 current_bytes_remained = 0;
xgflash_status_t xgflash_message_save(U8 *data_ptr, U16 data_len, U8 data_end_flag)
{
8000616c:	d4 21       	pushm	r4-r7,lr
8000616e:	20 2d       	sub	sp,8
80006170:	18 96       	mov	r6,r12
80006172:	16 97       	mov	r7,r11
80006174:	14 95       	mov	r5,r10

	if(!list_init_success_flag)return XG_ERROR;
80006176:	4d 68       	lddpc	r8,800062cc <xgflash_message_save+0x160>
80006178:	11 89       	ld.ub	r9,r8[0x0]
8000617a:	30 08       	mov	r8,0
8000617c:	f0 09 18 00 	cp.b	r9,r8
80006180:	c0 31       	brne	80006186 <xgflash_message_save+0x1a>
80006182:	3f fc       	mov	r12,-1
80006184:	ca 28       	rjmp	800062c8 <xgflash_message_save+0x15c>
	U32 address = 0;
	static U32 bytes_remained = 0;
	static U32 current_bytes_remained = 0;
	df_status_t return_code = DF_WRITE_COMPLETED;
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY) ;//lock	
80006186:	4d 38       	lddpc	r8,800062d0 <xgflash_message_save+0x164>
80006188:	70 0c       	ld.w	r12,r8[0x0]
8000618a:	30 09       	mov	r9,0
8000618c:	3f fa       	mov	r10,-1
8000618e:	12 9b       	mov	r11,r9
80006190:	f0 1f 00 51 	mcall	800062d4 <xgflash_message_save+0x168>
	
	/* check input parameter */
	if (data_ptr == NULL || data_len > 0x0200)//512bytes
80006194:	58 06       	cp.w	r6,0
80006196:	5f 09       	sreq	r9
80006198:	e0 68 02 00 	mov	r8,512
8000619c:	f0 07 19 00 	cp.h	r7,r8
800061a0:	5f b8       	srhi	r8
800061a2:	f3 e8 10 08 	or	r8,r9,r8
800061a6:	c0 30       	breq	800061ac <xgflash_message_save+0x40>
800061a8:	30 1c       	mov	r12,1
800061aa:	c8 f8       	rjmp	800062c8 <xgflash_message_save+0x15c>
	{
		return XG_INVALID_PARAM;
	}
	
	current_bytes_remained+=data_len;//accumulate
800061ac:	0e 94       	mov	r4,r7
800061ae:	5c 74       	castu.h	r4
800061b0:	4c a9       	lddpc	r9,800062d8 <xgflash_message_save+0x16c>
800061b2:	72 08       	ld.w	r8,r9[0x0]
800061b4:	e8 08 00 08 	add	r8,r4,r8
800061b8:	93 08       	st.w	r9[0x0],r8
	
	if(current_bytes_remained > 0xF000)//data size > 60k,overout
800061ba:	e0 48 f0 00 	cp.w	r8,61440
800061be:	e0 88 00 07 	brls	800061cc <xgflash_message_save+0x60>
	{
		current_bytes_remained = 0;
800061c2:	30 09       	mov	r9,0
800061c4:	4c 58       	lddpc	r8,800062d8 <xgflash_message_save+0x16c>
800061c6:	91 09       	st.w	r8[0x0],r9
800061c8:	30 1c       	mov	r12,1
		return XG_INVALID_PARAM;
800061ca:	c7 f8       	rjmp	800062c8 <xgflash_message_save+0x15c>
	}
	
	//save data
	if(current_save_message_offset > XG_MESSAGE_DATA_BOUNDARY_ADD)//The message data is out of boundary
800061cc:	4c 48       	lddpc	r8,800062dc <xgflash_message_save+0x170>
800061ce:	70 0b       	ld.w	r11,r8[0x0]
800061d0:	e0 68 ff ff 	mov	r8,65535
800061d4:	ea 18 00 7f 	orh	r8,0x7f
800061d8:	10 3b       	cp.w	r11,r8
800061da:	e0 88 00 10 	brls	800061fa <xgflash_message_save+0x8e>
	{
		log("\r\n----message data is Out of bounds!!!\r\n----");
800061de:	4c 1c       	lddpc	r12,800062e0 <xgflash_message_save+0x174>
800061e0:	f0 1f 00 41 	mcall	800062e4 <xgflash_message_save+0x178>
		current_bytes_remained = 0;
800061e4:	30 0b       	mov	r11,0
800061e6:	4b d8       	lddpc	r8,800062d8 <xgflash_message_save+0x16c>
800061e8:	91 0b       	st.w	r8[0x0],r11
		xSemaphoreGive(xgflash_mutex );//unlock
800061ea:	4b a8       	lddpc	r8,800062d0 <xgflash_message_save+0x164>
800061ec:	70 0c       	ld.w	r12,r8[0x0]
800061ee:	16 99       	mov	r9,r11
800061f0:	16 9a       	mov	r10,r11
800061f2:	f0 1f 00 3e 	mcall	800062e8 <xgflash_message_save+0x17c>
800061f6:	30 3c       	mov	r12,3
		return XG_OUT_BOUNDARY;
800061f8:	c6 88       	rjmp	800062c8 <xgflash_message_save+0x15c>
	}
	
	
	return_code = data_flash_write((U8 *)data_ptr, current_save_message_offset, data_len);
800061fa:	0e 9a       	mov	r10,r7
800061fc:	5c 7a       	castu.h	r10
800061fe:	0c 9c       	mov	r12,r6
80006200:	f0 1f 00 3b 	mcall	800062ec <xgflash_message_save+0x180>
	if(return_code != DF_WRITE_COMPLETED)
80006204:	58 7c       	cp.w	r12,7
80006206:	c0 c0       	breq	8000621e <xgflash_message_save+0xb2>
	{
		current_bytes_remained = 0;
80006208:	30 0b       	mov	r11,0
8000620a:	4b 48       	lddpc	r8,800062d8 <xgflash_message_save+0x16c>
8000620c:	91 0b       	st.w	r8[0x0],r11
		xSemaphoreGive(xgflash_mutex );//unlock
8000620e:	4b 18       	lddpc	r8,800062d0 <xgflash_message_save+0x164>
80006210:	70 0c       	ld.w	r12,r8[0x0]
80006212:	16 99       	mov	r9,r11
80006214:	16 9a       	mov	r10,r11
80006216:	f0 1f 00 35 	mcall	800062e8 <xgflash_message_save+0x17c>
8000621a:	30 7c       	mov	r12,7
		return XG_FLASH_WRITE_FAIL;
8000621c:	c5 68       	rjmp	800062c8 <xgflash_message_save+0x15c>
	}
	
	current_save_message_offset+=data_len;
8000621e:	4b 08       	lddpc	r8,800062dc <xgflash_message_save+0x170>
80006220:	70 09       	ld.w	r9,r8[0x0]
80006222:	12 04       	add	r4,r9
80006224:	91 04       	st.w	r8[0x0],r4
	log("current_save_message_offset : %X\n", current_save_message_offset);
80006226:	1a d4       	st.w	--sp,r4
80006228:	4b 2c       	lddpc	r12,800062f0 <xgflash_message_save+0x184>
8000622a:	f0 1f 00 2f 	mcall	800062e4 <xgflash_message_save+0x178>
		
	MessageList_Info_t ptr;
		
	if(data_end_flag == TRUE)//save a message-info into list at the end of the resend-event
8000622e:	2f fd       	sub	sp,-4
80006230:	30 18       	mov	r8,1
80006232:	f0 05 18 00 	cp.b	r5,r8
80006236:	c4 11       	brne	800062b8 <xgflash_message_save+0x14c>
	{
		current_message_index++;
80006238:	4a f9       	lddpc	r9,800062f4 <xgflash_message_save+0x188>
8000623a:	92 08       	ld.sh	r8,r9[0x0]
8000623c:	2f f8       	sub	r8,-1
8000623e:	b2 08       	st.h	r9[0x0],r8
		ptr.numb		= current_message_index;
80006240:	ba 08       	st.h	sp[0x0],r8
		ptr.address		= (current_save_message_offset - current_bytes_remained);
80006242:	4a 69       	lddpc	r9,800062d8 <xgflash_message_save+0x16c>
80006244:	72 09       	ld.w	r9,r9[0x0]
80006246:	4a 6a       	lddpc	r10,800062dc <xgflash_message_save+0x170>
80006248:	74 0a       	ld.w	r10,r10[0x0]
8000624a:	12 1a       	sub	r10,r9
8000624c:	40 0b       	lddsp	r11,sp[0x0]
8000624e:	e0 1b 00 00 	andl	r11,0x0
80006252:	f7 ea 13 0b 	or	r11,r11,r10>>0x10
80006256:	50 0b       	stdsp	sp[0x0],r11
80006258:	ba 2a       	st.h	sp[0x4],r10
		ptr.offset		= current_bytes_remained;
8000625a:	ba 39       	st.h	sp[0x6],r9
		
		address = XG_MESSAGE_INFO_HEADER_START_ADD + ((current_message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
8000625c:	5c 78       	castu.h	r8
8000625e:	f0 0b 15 03 	lsl	r11,r8,0x3
		if(address > XG_MESSAGE_LISTINFO_BOUNDARY_ADD)//The number of messages is out of bounds
80006262:	e2 4b 00 00 	cp.w	r11,131072
80006266:	e0 88 00 10 	brls	80006286 <xgflash_message_save+0x11a>
		{
			log("\r\n----info list is Out of bounds!!!\r\n----");
8000626a:	4a 4c       	lddpc	r12,800062f8 <xgflash_message_save+0x18c>
8000626c:	f0 1f 00 1e 	mcall	800062e4 <xgflash_message_save+0x178>
			current_bytes_remained = 0;
80006270:	30 0b       	mov	r11,0
80006272:	49 a8       	lddpc	r8,800062d8 <xgflash_message_save+0x16c>
80006274:	91 0b       	st.w	r8[0x0],r11
			xSemaphoreGive(xgflash_mutex );//unlock
80006276:	49 78       	lddpc	r8,800062d0 <xgflash_message_save+0x164>
80006278:	70 0c       	ld.w	r12,r8[0x0]
8000627a:	16 99       	mov	r9,r11
8000627c:	16 9a       	mov	r10,r11
8000627e:	f0 1f 00 1b 	mcall	800062e8 <xgflash_message_save+0x17c>
80006282:	30 3c       	mov	r12,3
			return XG_OUT_BOUNDARY;
80006284:	c2 28       	rjmp	800062c8 <xgflash_message_save+0x15c>
		}
		
		
		//set a message info by current_message_index	
		return_code = data_flash_write((U8 *)&ptr, address, XG_MESSAGE_INFO_HEADER_LENGTH);
80006286:	30 8a       	mov	r10,8
80006288:	1a 9c       	mov	r12,sp
8000628a:	f0 1f 00 19 	mcall	800062ec <xgflash_message_save+0x180>
		//set message numbers
		return_code = data_flash_write(&current_message_index, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
8000628e:	30 2a       	mov	r10,2
80006290:	30 6b       	mov	r11,6
80006292:	49 9c       	lddpc	r12,800062f4 <xgflash_message_save+0x188>
80006294:	f0 1f 00 16 	mcall	800062ec <xgflash_message_save+0x180>
		if(return_code != DF_WRITE_COMPLETED)
80006298:	58 7c       	cp.w	r12,7
8000629a:	c0 c0       	breq	800062b2 <xgflash_message_save+0x146>
		{
			current_bytes_remained = 0;
8000629c:	30 0b       	mov	r11,0
8000629e:	48 f8       	lddpc	r8,800062d8 <xgflash_message_save+0x16c>
800062a0:	91 0b       	st.w	r8[0x0],r11
			xSemaphoreGive(xgflash_mutex );//unlock
800062a2:	48 c8       	lddpc	r8,800062d0 <xgflash_message_save+0x164>
800062a4:	70 0c       	ld.w	r12,r8[0x0]
800062a6:	16 99       	mov	r9,r11
800062a8:	16 9a       	mov	r10,r11
800062aa:	f0 1f 00 10 	mcall	800062e8 <xgflash_message_save+0x17c>
800062ae:	30 7c       	mov	r12,7
			return XG_FLASH_WRITE_FAIL;
800062b0:	c0 c8       	rjmp	800062c8 <xgflash_message_save+0x15c>
		}
		
		current_bytes_remained = 0;//reset 0
800062b2:	30 09       	mov	r9,0
800062b4:	48 98       	lddpc	r8,800062d8 <xgflash_message_save+0x16c>
800062b6:	91 09       	st.w	r8[0x0],r9
	}
	
	xSemaphoreGive(xgflash_mutex );//unlock
800062b8:	48 68       	lddpc	r8,800062d0 <xgflash_message_save+0x164>
800062ba:	70 0c       	ld.w	r12,r8[0x0]
800062bc:	30 09       	mov	r9,0
800062be:	12 9a       	mov	r10,r9
800062c0:	12 9b       	mov	r11,r9
800062c2:	f0 1f 00 0a 	mcall	800062e8 <xgflash_message_save+0x17c>
800062c6:	30 0c       	mov	r12,0
	return XG_OK;

}
800062c8:	2f ed       	sub	sp,-8
800062ca:	d8 22       	popm	r4-r7,pc
800062cc:	00 00       	add	r0,r0
800062ce:	0b 90       	ld.ub	r0,r5[0x1]
800062d0:	00 00       	add	r0,r0
800062d2:	0b 94       	ld.ub	r4,r5[0x1]
800062d4:	80 00       	ld.sh	r0,r0[0x0]
800062d6:	71 80       	ld.w	r0,r8[0x60]
800062d8:	00 00       	add	r0,r0
800062da:	0b 98       	ld.ub	r8,r5[0x1]
800062dc:	00 00       	add	r0,r0
800062de:	05 48       	ld.w	r8,--r2
800062e0:	80 00       	ld.sh	r0,r0[0x0]
800062e2:	ec 50 80 00 	cp.w	r0,884736
800062e6:	7f c4       	ld.w	r4,pc[0x70]
800062e8:	80 00       	ld.sh	r0,r0[0x0]
800062ea:	73 8c       	ld.w	r12,r9[0x60]
800062ec:	80 00       	ld.sh	r0,r0[0x0]
800062ee:	31 40       	mov	r0,20
800062f0:	80 00       	ld.sh	r0,r0[0x0]
800062f2:	eb 78 00 00 	stcond	r5[0],r8
800062f6:	0b a4       	ld.ub	r4,r5[0x2]
800062f8:	80 00       	ld.sh	r0,r0[0x0]
800062fa:	ec 80 eb cd 	breq	801a3a94 <_data_lma+0x194454>

800062fc <xgflash_get_message_count>:
	}
	return XG_ERROR;
	
}
U16 xgflash_get_message_count(void)
{
800062fc:	eb cd 40 c0 	pushm	r6-r7,lr
	if(!list_init_success_flag)return 0xFFFF;
80006300:	48 d8       	lddpc	r8,80006334 <xgflash_get_message_count+0x38>
80006302:	11 89       	ld.ub	r9,r8[0x0]
80006304:	30 08       	mov	r8,0
80006306:	f0 09 18 00 	cp.b	r9,r8
8000630a:	c0 31       	brne	80006310 <xgflash_get_message_count+0x14>
8000630c:	3f f7       	mov	r7,-1
8000630e:	c1 08       	rjmp	8000632e <xgflash_get_message_count+0x32>
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY);
80006310:	48 a6       	lddpc	r6,80006338 <xgflash_get_message_count+0x3c>
80006312:	6c 0c       	ld.w	r12,r6[0x0]
80006314:	30 09       	mov	r9,0
80006316:	3f fa       	mov	r10,-1
80006318:	12 9b       	mov	r11,r9
8000631a:	f0 1f 00 09 	mcall	8000633c <xgflash_get_message_count+0x40>
	U16 return_value = current_message_index;
8000631e:	48 98       	lddpc	r8,80006340 <xgflash_get_message_count+0x44>
80006320:	90 07       	ld.sh	r7,r8[0x0]
	xSemaphoreGive(xgflash_mutex );
80006322:	6c 0c       	ld.w	r12,r6[0x0]
80006324:	30 09       	mov	r9,0
80006326:	12 9a       	mov	r10,r9
80006328:	12 9b       	mov	r11,r9
8000632a:	f0 1f 00 07 	mcall	80006344 <xgflash_get_message_count+0x48>

	return return_value;
	
}
8000632e:	0e 9c       	mov	r12,r7
80006330:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006334:	00 00       	add	r0,r0
80006336:	0b 90       	ld.ub	r0,r5[0x1]
80006338:	00 00       	add	r0,r0
8000633a:	0b 94       	ld.ub	r4,r5[0x1]
8000633c:	80 00       	ld.sh	r0,r0[0x0]
8000633e:	71 80       	ld.w	r0,r8[0x60]
80006340:	00 00       	add	r0,r0
80006342:	0b a4       	ld.ub	r4,r5[0x2]
80006344:	80 00       	ld.sh	r0,r0[0x0]
80006346:	73 8c       	ld.w	r12,r9[0x60]

80006348 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
80006348:	fe 68 14 00 	mov	r8,-125952
8000634c:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
8000634e:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80006352:	91 09       	st.w	r8[0x0],r9
}
80006354:	5e fc       	retal	r12

80006356 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006356:	f8 08 16 05 	lsr	r8,r12,0x5
8000635a:	a9 68       	lsl	r8,0x8
8000635c:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80006360:	58 1b       	cp.w	r11,1
80006362:	c0 d0       	breq	8000637c <gpio_enable_module_pin+0x26>
80006364:	c0 63       	brcs	80006370 <gpio_enable_module_pin+0x1a>
80006366:	58 2b       	cp.w	r11,2
80006368:	c1 00       	breq	80006388 <gpio_enable_module_pin+0x32>
8000636a:	58 3b       	cp.w	r11,3
8000636c:	c1 40       	breq	80006394 <gpio_enable_module_pin+0x3e>
8000636e:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006370:	30 19       	mov	r9,1
80006372:	f2 0c 09 49 	lsl	r9,r9,r12
80006376:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006378:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000637a:	c1 28       	rjmp	8000639e <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000637c:	30 19       	mov	r9,1
8000637e:	f2 0c 09 49 	lsl	r9,r9,r12
80006382:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006384:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006386:	c0 c8       	rjmp	8000639e <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006388:	30 19       	mov	r9,1
8000638a:	f2 0c 09 49 	lsl	r9,r9,r12
8000638e:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80006390:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006392:	c0 68       	rjmp	8000639e <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006394:	30 19       	mov	r9,1
80006396:	f2 0c 09 49 	lsl	r9,r9,r12
8000639a:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000639c:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000639e:	30 19       	mov	r9,1
800063a0:	f2 0c 09 4c 	lsl	r12,r9,r12
800063a4:	91 2c       	st.w	r8[0x8],r12
800063a6:	5e fd       	retal	0

800063a8 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800063a8:	d4 21       	pushm	r4-r7,lr
800063aa:	18 97       	mov	r7,r12
800063ac:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800063ae:	58 0b       	cp.w	r11,0
800063b0:	c0 31       	brne	800063b6 <gpio_enable_module+0xe>
800063b2:	30 05       	mov	r5,0
800063b4:	c0 d8       	rjmp	800063ce <gpio_enable_module+0x26>
800063b6:	30 06       	mov	r6,0
800063b8:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800063ba:	6e 1b       	ld.w	r11,r7[0x4]
800063bc:	6e 0c       	ld.w	r12,r7[0x0]
800063be:	f0 1f 00 06 	mcall	800063d4 <gpio_enable_module+0x2c>
800063c2:	18 45       	or	r5,r12
		gpiomap++;
800063c4:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800063c6:	2f f6       	sub	r6,-1
800063c8:	0c 34       	cp.w	r4,r6
800063ca:	fe 9b ff f8 	brhi	800063ba <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
800063ce:	0a 9c       	mov	r12,r5
800063d0:	d8 22       	popm	r4-r7,pc
800063d2:	00 00       	add	r0,r0
800063d4:	80 00       	ld.sh	r0,r0[0x0]
800063d6:	63 56       	ld.w	r6,r1[0x54]

800063d8 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800063d8:	f8 08 16 05 	lsr	r8,r12,0x5
800063dc:	a9 68       	lsl	r8,0x8
800063de:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
800063e2:	30 19       	mov	r9,1
800063e4:	f2 0c 09 4c 	lsl	r12,r9,r12
800063e8:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
800063ec:	91 1c       	st.w	r8[0x4],r12
}
800063ee:	5e fc       	retal	r12

800063f0 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800063f0:	f8 08 16 05 	lsr	r8,r12,0x5
800063f4:	a9 68       	lsl	r8,0x8
800063f6:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
800063fa:	30 19       	mov	r9,1
800063fc:	f2 0c 09 4c 	lsl	r12,r9,r12
80006400:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80006404:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80006408:	91 1c       	st.w	r8[0x4],r12
}
8000640a:	5e fc       	retal	r12

8000640c <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000640c:	f8 08 16 05 	lsr	r8,r12,0x5
80006410:	a9 68       	lsl	r8,0x8
80006412:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80006416:	30 19       	mov	r9,1
80006418:	f2 0c 09 4c 	lsl	r12,r9,r12
8000641c:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80006420:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80006424:	91 1c       	st.w	r8[0x4],r12
}
80006426:	5e fc       	retal	r12

80006428 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80006428:	c0 08       	rjmp	80006428 <_unhandled_interrupt>
8000642a:	d7 03       	nop

8000642c <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
8000642c:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80006430:	49 99       	lddpc	r9,80006494 <INTC_register_interrupt+0x68>
80006432:	f2 08 00 39 	add	r9,r9,r8<<0x3
80006436:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000643a:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
8000643c:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80006440:	58 0a       	cp.w	r10,0
80006442:	c0 91       	brne	80006454 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80006444:	49 59       	lddpc	r9,80006498 <INTC_register_interrupt+0x6c>
80006446:	49 6a       	lddpc	r10,8000649c <INTC_register_interrupt+0x70>
80006448:	12 1a       	sub	r10,r9
8000644a:	fe 79 08 00 	mov	r9,-63488
8000644e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80006452:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80006454:	58 1a       	cp.w	r10,1
80006456:	c0 a1       	brne	8000646a <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80006458:	49 09       	lddpc	r9,80006498 <INTC_register_interrupt+0x6c>
8000645a:	49 2a       	lddpc	r10,800064a0 <INTC_register_interrupt+0x74>
8000645c:	12 1a       	sub	r10,r9
8000645e:	bf aa       	sbr	r10,0x1e
80006460:	fe 79 08 00 	mov	r9,-63488
80006464:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80006468:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000646a:	58 2a       	cp.w	r10,2
8000646c:	c0 a1       	brne	80006480 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000646e:	48 b9       	lddpc	r9,80006498 <INTC_register_interrupt+0x6c>
80006470:	48 da       	lddpc	r10,800064a4 <INTC_register_interrupt+0x78>
80006472:	12 1a       	sub	r10,r9
80006474:	bf ba       	sbr	r10,0x1f
80006476:	fe 79 08 00 	mov	r9,-63488
8000647a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000647e:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80006480:	48 69       	lddpc	r9,80006498 <INTC_register_interrupt+0x6c>
80006482:	48 aa       	lddpc	r10,800064a8 <INTC_register_interrupt+0x7c>
80006484:	12 1a       	sub	r10,r9
80006486:	ea 1a c0 00 	orh	r10,0xc000
8000648a:	fe 79 08 00 	mov	r9,-63488
8000648e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80006492:	5e fc       	retal	r12
80006494:	80 00       	ld.sh	r0,r0[0x0]
80006496:	ed 10 80 00 	ld.uh	r0,r6[-32768]
8000649a:	de 00       	acall	0xe0
8000649c:	80 00       	ld.sh	r0,r0[0x0]
8000649e:	df 04       	*unknown*
800064a0:	80 00       	ld.sh	r0,r0[0x0]
800064a2:	df 12       	popm	r0-r3,r11-r12,lr-pc
800064a4:	80 00       	ld.sh	r0,r0[0x0]
800064a6:	df 20       	acall	0xf2
800064a8:	80 00       	ld.sh	r0,r0[0x0]
800064aa:	df 2e       	*unknown*

800064ac <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800064ac:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800064ae:	49 18       	lddpc	r8,800064f0 <INTC_init_interrupts+0x44>
800064b0:	e3 b8 00 01 	mtsr	0x4,r8
800064b4:	49 0e       	lddpc	lr,800064f4 <INTC_init_interrupts+0x48>
800064b6:	30 07       	mov	r7,0
800064b8:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800064ba:	49 0c       	lddpc	r12,800064f8 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800064bc:	49 05       	lddpc	r5,800064fc <INTC_init_interrupts+0x50>
800064be:	10 15       	sub	r5,r8
800064c0:	fe 76 08 00 	mov	r6,-63488
800064c4:	c1 08       	rjmp	800064e4 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800064c6:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800064c8:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800064ca:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800064cc:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800064d0:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800064d2:	10 3a       	cp.w	r10,r8
800064d4:	fe 9b ff fc 	brhi	800064cc <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800064d8:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800064dc:	2f f7       	sub	r7,-1
800064de:	2f 8e       	sub	lr,-8
800064e0:	59 37       	cp.w	r7,19
800064e2:	c0 50       	breq	800064ec <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800064e4:	7c 08       	ld.w	r8,lr[0x0]
800064e6:	58 08       	cp.w	r8,0
800064e8:	ce f1       	brne	800064c6 <INTC_init_interrupts+0x1a>
800064ea:	cf 7b       	rjmp	800064d8 <INTC_init_interrupts+0x2c>
800064ec:	d8 22       	popm	r4-r7,pc
800064ee:	00 00       	add	r0,r0
800064f0:	80 00       	ld.sh	r0,r0[0x0]
800064f2:	de 00       	acall	0xe0
800064f4:	80 00       	ld.sh	r0,r0[0x0]
800064f6:	ed 10 80 00 	ld.uh	r0,r6[-32768]
800064fa:	64 28       	ld.w	r8,r2[0x8]
800064fc:	80 00       	ld.sh	r0,r0[0x0]
800064fe:	df 04       	*unknown*

80006500 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80006500:	fe 78 08 00 	mov	r8,-63488
80006504:	e0 69 00 83 	mov	r9,131
80006508:	f2 0c 01 0c 	sub	r12,r9,r12
8000650c:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80006510:	f2 ca ff c0 	sub	r10,r9,-64
80006514:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80006518:	58 08       	cp.w	r8,0
8000651a:	c0 21       	brne	8000651e <_get_interrupt_handler+0x1e>
8000651c:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000651e:	f0 08 12 00 	clz	r8,r8
80006522:	48 5a       	lddpc	r10,80006534 <_get_interrupt_handler+0x34>
80006524:	f4 09 00 39 	add	r9,r10,r9<<0x3
80006528:	f0 08 11 1f 	rsub	r8,r8,31
8000652c:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000652e:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80006532:	5e fc       	retal	r12
80006534:	80 00       	ld.sh	r0,r0[0x0]
80006536:	ed 10 78 a8 	ld.uh	r0,r6[30888]

80006538 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80006538:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
8000653a:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000653e:	99 a8       	st.w	r12[0x28],r8
}
80006540:	5e fc       	retal	r12
80006542:	d7 03       	nop

80006544 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80006544:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80006546:	ec 5b bb 9f 	cp.w	r11,899999
8000654a:	e0 8b 00 04 	brhi	80006552 <pm_enable_osc0_crystal+0xe>
8000654e:	30 4b       	mov	r11,4
80006550:	c1 38       	rjmp	80006576 <pm_enable_osc0_crystal+0x32>
80006552:	e0 68 c6 bf 	mov	r8,50879
80006556:	ea 18 00 2d 	orh	r8,0x2d
8000655a:	10 3b       	cp.w	r11,r8
8000655c:	e0 8b 00 04 	brhi	80006564 <pm_enable_osc0_crystal+0x20>
80006560:	30 5b       	mov	r11,5
80006562:	c0 a8       	rjmp	80006576 <pm_enable_osc0_crystal+0x32>
80006564:	e0 68 12 00 	mov	r8,4608
80006568:	ea 18 00 7a 	orh	r8,0x7a
8000656c:	10 3b       	cp.w	r11,r8
8000656e:	f9 bb 03 06 	movlo	r11,6
80006572:	f9 bb 02 07 	movhs	r11,7
80006576:	f0 1f 00 02 	mcall	8000657c <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
8000657a:	d8 02       	popm	pc
8000657c:	80 00       	ld.sh	r0,r0[0x0]
8000657e:	65 38       	ld.w	r8,r2[0x4c]

80006580 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80006580:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80006582:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80006586:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80006588:	78 08       	ld.w	r8,r12[0x0]
8000658a:	a3 a8       	sbr	r8,0x2
8000658c:	99 08       	st.w	r12[0x0],r8
}
8000658e:	5e fc       	retal	r12

80006590 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80006590:	79 58       	ld.w	r8,r12[0x54]
80006592:	e2 18 00 80 	andl	r8,0x80,COH
80006596:	cf d0       	breq	80006590 <pm_wait_for_clk0_ready>
}
80006598:	5e fc       	retal	r12
8000659a:	d7 03       	nop

8000659c <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
8000659c:	eb cd 40 80 	pushm	r7,lr
800065a0:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
800065a2:	f0 1f 00 04 	mcall	800065b0 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
800065a6:	0e 9c       	mov	r12,r7
800065a8:	f0 1f 00 03 	mcall	800065b4 <pm_enable_clk0+0x18>
}
800065ac:	e3 cd 80 80 	ldm	sp++,r7,pc
800065b0:	80 00       	ld.sh	r0,r0[0x0]
800065b2:	65 80       	ld.w	r0,r2[0x60]
800065b4:	80 00       	ld.sh	r0,r0[0x0]
800065b6:	65 90       	ld.w	r0,r2[0x64]

800065b8 <pm_set_osc32_mode>:
 * \param mode 32-kHz oscillator mode (i.e. AVR32_PM_OSCCTRL32_MODE_x).
 */
static void pm_set_osc32_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
800065b8:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.mode = mode;
800065ba:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
800065be:	99 c8       	st.w	r12[0x30],r8
}
800065c0:	5e fc       	retal	r12
800065c2:	d7 03       	nop

800065c4 <pm_enable_osc32_crystal>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
}


void pm_enable_osc32_crystal(volatile avr32_pm_t *pm)
{
800065c4:	d4 01       	pushm	lr
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
800065c6:	30 1b       	mov	r11,1
800065c8:	f0 1f 00 02 	mcall	800065d0 <pm_enable_osc32_crystal+0xc>
}
800065cc:	d8 02       	popm	pc
800065ce:	00 00       	add	r0,r0
800065d0:	80 00       	ld.sh	r0,r0[0x0]
800065d2:	65 b8       	ld.w	r8,r2[0x6c]

800065d4 <pm_enable_clk32_no_wait>:


void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
800065d4:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.osc32en = 1;
800065d6:	30 19       	mov	r9,1
800065d8:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_pm_oscctrl32.OSCCTRL32.startup = startup;
800065dc:	f1 db d2 03 	bfins	r8,r11,0x10,0x3
  // Write back
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
800065e0:	99 c8       	st.w	r12[0x30],r8
}
800065e2:	5e fc       	retal	r12

800065e4 <pm_wait_for_clk32_ready>:


void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC32RDY_MASK));
800065e4:	79 58       	ld.w	r8,r12[0x54]
800065e6:	e2 18 02 00 	andl	r8,0x200,COH
800065ea:	cf d0       	breq	800065e4 <pm_wait_for_clk32_ready>
}
800065ec:	5e fc       	retal	r12
800065ee:	d7 03       	nop

800065f0 <pm_enable_clk32>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
}


void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup)
{
800065f0:	eb cd 40 80 	pushm	r7,lr
800065f4:	18 97       	mov	r7,r12
  pm_enable_clk32_no_wait(pm, startup);
800065f6:	f0 1f 00 04 	mcall	80006604 <pm_enable_clk32+0x14>
  pm_wait_for_clk32_ready(pm);
800065fa:	0e 9c       	mov	r12,r7
800065fc:	f0 1f 00 03 	mcall	80006608 <pm_enable_clk32+0x18>
}
80006600:	e3 cd 80 80 	ldm	sp++,r7,pc
80006604:	80 00       	ld.sh	r0,r0[0x0]
80006606:	65 d4       	ld.w	r4,r2[0x74]
80006608:	80 00       	ld.sh	r0,r0[0x0]
8000660a:	65 e4       	ld.w	r4,r2[0x78]

8000660c <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
8000660c:	eb cd 40 d0 	pushm	r4,r6-r7,lr
80006610:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80006614:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
80006616:	09 f7       	ld.ub	r7,r4[0x7]
80006618:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
8000661c:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
80006620:	09 b4       	ld.ub	r4,r4[0x3]
80006622:	08 96       	mov	r6,r4
80006624:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
80006628:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
8000662c:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
80006630:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
80006634:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
80006638:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
8000663c:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
80006640:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
80006644:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
80006646:	79 58       	ld.w	r8,r12[0x54]
80006648:	e2 18 00 20 	andl	r8,0x20,COH
8000664c:	cf d0       	breq	80006646 <pm_cksel+0x3a>
}
8000664e:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

80006652 <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
80006652:	eb cd 40 80 	pushm	r7,lr
80006656:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
80006658:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
8000665a:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
8000665e:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
80006662:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
80006666:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
8000666a:	2f 8b       	sub	r11,-8
8000666c:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80006670:	e3 cd 80 80 	ldm	sp++,r7,pc

80006674 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80006674:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
80006676:	2f 8b       	sub	r11,-8
80006678:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
8000667c:	f5 e9 10 19 	or	r9,r10,r9<<0x1
80006680:	f3 e8 10 28 	or	r8,r9,r8<<0x2
80006684:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
80006688:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
8000668c:	d8 02       	popm	pc

8000668e <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
8000668e:	2f 8b       	sub	r11,-8
80006690:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
80006694:	a1 a8       	sbr	r8,0x0
80006696:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
8000669a:	5e fc       	retal	r12

8000669c <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
8000669c:	79 58       	ld.w	r8,r12[0x54]
8000669e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800066a2:	cf d0       	breq	8000669c <pm_wait_for_pll0_locked>
}
800066a4:	5e fc       	retal	r12

800066a6 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
800066a6:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
800066a8:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
800066ac:	99 08       	st.w	r12[0x0],r8
}
800066ae:	5e fc       	retal	r12

800066b0 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
800066b0:	eb cd 40 c0 	pushm	r6-r7,lr
800066b4:	18 97       	mov	r7,r12
800066b6:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
800066b8:	f0 1f 00 06 	mcall	800066d0 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
800066bc:	0c 9b       	mov	r11,r6
800066be:	0e 9c       	mov	r12,r7
800066c0:	f0 1f 00 05 	mcall	800066d4 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
800066c4:	30 1b       	mov	r11,1
800066c6:	0e 9c       	mov	r12,r7
800066c8:	f0 1f 00 04 	mcall	800066d8 <pm_switch_to_osc0+0x28>
}
800066cc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800066d0:	80 00       	ld.sh	r0,r0[0x0]
800066d2:	65 44       	ld.w	r4,r2[0x50]
800066d4:	80 00       	ld.sh	r0,r0[0x0]
800066d6:	65 9c       	ld.w	r12,r2[0x64]
800066d8:	80 00       	ld.sh	r0,r0[0x0]
800066da:	66 a6       	ld.w	r6,r3[0x28]

800066dc <rtc_is_busy>:
#include "rtc.h"


int rtc_is_busy(volatile avr32_rtc_t *rtc)
{
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
800066dc:	78 0c       	ld.w	r12,r12[0x0]
}
800066de:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
800066e2:	5e fc       	retal	r12

800066e4 <rtc_set_value>:
  return 1;
}


void rtc_set_value(volatile avr32_rtc_t *rtc, unsigned long val)
{
800066e4:	eb cd 40 c0 	pushm	r6-r7,lr
800066e8:	18 97       	mov	r7,r12
800066ea:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
800066ec:	0e 9c       	mov	r12,r7
800066ee:	f0 1f 00 06 	mcall	80006704 <rtc_set_value+0x20>
800066f2:	cf d1       	brne	800066ec <rtc_set_value+0x8>
  // Set the new val value
  rtc->val = val;
800066f4:	8f 16       	st.w	r7[0x4],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
800066f6:	0e 9c       	mov	r12,r7
800066f8:	f0 1f 00 03 	mcall	80006704 <rtc_set_value+0x20>
800066fc:	cf d1       	brne	800066f6 <rtc_set_value+0x12>
}
800066fe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006702:	00 00       	add	r0,r0
80006704:	80 00       	ld.sh	r0,r0[0x0]
80006706:	66 dc       	ld.w	r12,r3[0x34]

80006708 <rtc_enable>:
  while (rtc_is_busy(rtc));
}


void rtc_enable(volatile avr32_rtc_t *rtc)
{
80006708:	eb cd 40 80 	pushm	r7,lr
8000670c:	18 97       	mov	r7,r12
  // Wait until the rtc CTRL register is up-to-date
  while (rtc_is_busy(rtc));
8000670e:	0e 9c       	mov	r12,r7
80006710:	f0 1f 00 06 	mcall	80006728 <rtc_enable+0x20>
80006714:	cf d1       	brne	8000670e <rtc_enable+0x6>
  // Enable the RTC
  rtc->ctrl |= AVR32_RTC_CTRL_EN_MASK;
80006716:	6e 08       	ld.w	r8,r7[0x0]
80006718:	a1 a8       	sbr	r8,0x0
8000671a:	8f 08       	st.w	r7[0x0],r8
  // Wait until write is done
  while (rtc_is_busy(rtc));
8000671c:	0e 9c       	mov	r12,r7
8000671e:	f0 1f 00 03 	mcall	80006728 <rtc_enable+0x20>
80006722:	cf d1       	brne	8000671c <rtc_enable+0x14>
}
80006724:	e3 cd 80 80 	ldm	sp++,r7,pc
80006728:	80 00       	ld.sh	r0,r0[0x0]
8000672a:	66 dc       	ld.w	r12,r3[0x34]

8000672c <rtc_enable_interrupt>:
}


void rtc_enable_interrupt(volatile avr32_rtc_t *rtc)
{
  rtc->ier = AVR32_RTC_IER_TOPI_MASK;
8000672c:	30 18       	mov	r8,1
8000672e:	99 48       	st.w	r12[0x10],r8
}
80006730:	5e fc       	retal	r12
80006732:	d7 03       	nop

80006734 <rtc_set_top_value>:
  if (global_interrupt_enabled) cpu_irq_enable();
}


void rtc_set_top_value(volatile avr32_rtc_t *rtc, unsigned long top)
{
80006734:	eb cd 40 c0 	pushm	r6-r7,lr
80006738:	18 97       	mov	r7,r12
8000673a:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
8000673c:	0e 9c       	mov	r12,r7
8000673e:	f0 1f 00 06 	mcall	80006754 <rtc_set_top_value+0x20>
80006742:	cf d1       	brne	8000673c <rtc_set_top_value+0x8>
  // Set the new val value
  rtc->top = top;
80006744:	8f 26       	st.w	r7[0x8],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
80006746:	0e 9c       	mov	r12,r7
80006748:	f0 1f 00 03 	mcall	80006754 <rtc_set_top_value+0x20>
8000674c:	cf d1       	brne	80006746 <rtc_set_top_value+0x12>
}
8000674e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006752:	00 00       	add	r0,r0
80006754:	80 00       	ld.sh	r0,r0[0x0]
80006756:	66 dc       	ld.w	r12,r3[0x34]

80006758 <rtc_clear_interrupt>:
}


void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80006758:	e1 b8 00 00 	mfsr	r8,0x0

  if (global_interrupt_enabled) cpu_irq_disable();
8000675c:	e6 18 00 01 	andh	r8,0x1,COH
80006760:	c0 71       	brne	8000676e <rtc_clear_interrupt+0x16>
80006762:	d3 03       	ssrf	0x10
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
80006764:	30 18       	mov	r8,1
80006766:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80006768:	78 78       	ld.w	r8,r12[0x1c]
  if (global_interrupt_enabled) cpu_irq_enable();
8000676a:	d5 03       	csrf	0x10
8000676c:	5e fc       	retal	r12
void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  if (global_interrupt_enabled) cpu_irq_disable();
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
8000676e:	30 18       	mov	r8,1
80006770:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80006772:	78 78       	ld.w	r8,r12[0x1c]
80006774:	5e fc       	retal	r12
80006776:	d7 03       	nop

80006778 <rtc_init>:
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
}


int rtc_init(volatile avr32_rtc_t *rtc, unsigned char osc_type, unsigned char psel)
{
80006778:	eb cd 40 e0 	pushm	r5-r7,lr
8000677c:	18 97       	mov	r7,r12
8000677e:	16 96       	mov	r6,r11
80006780:	14 95       	mov	r5,r10
  // If exit, it means that the configuration has not been set correctly
  if (osc_type > (1 << AVR32_RTC_CTRL_CLK32_SIZE) - 1 ||
80006782:	30 18       	mov	r8,1
80006784:	f0 0b 18 00 	cp.b	r11,r8
80006788:	5f b9       	srhi	r9
8000678a:	30 f8       	mov	r8,15
8000678c:	f0 0a 18 00 	cp.b	r10,r8
80006790:	5f b8       	srhi	r8
80006792:	f3 e8 10 08 	or	r8,r9,r8
80006796:	c0 30       	breq	8000679c <rtc_init+0x24>
80006798:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
      psel > (1 << AVR32_RTC_CTRL_PSEL_SIZE) - 1)
    return 0;

  // If we use the 32-kHz oscillator, we have to enable it first
  if (osc_type == RTC_OSC_32KHZ)
8000679c:	30 18       	mov	r8,1
8000679e:	f0 0b 18 00 	cp.b	r11,r8
800067a2:	c0 a1       	brne	800067b6 <rtc_init+0x3e>
  {
    // Select the 32-kHz oscillator crystal
    pm_enable_osc32_crystal(&AVR32_PM);
800067a4:	fe 7c 0c 00 	mov	r12,-62464
800067a8:	f0 1f 00 0f 	mcall	800067e4 <rtc_init+0x6c>
    // Enable the 32-kHz clock and wait until the osc32 clock is ready.
    pm_enable_clk32(&AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC);
800067ac:	30 0b       	mov	r11,0
800067ae:	fe 7c 0c 00 	mov	r12,-62464
800067b2:	f0 1f 00 0e 	mcall	800067e8 <rtc_init+0x70>
  }

  // Wait until the rtc accepts writes to the CTRL register
  while (rtc_is_busy(rtc));
800067b6:	0e 9c       	mov	r12,r7
800067b8:	f0 1f 00 0d 	mcall	800067ec <rtc_init+0x74>
800067bc:	cf d1       	brne	800067b6 <rtc_init+0x3e>

  // Set the new RTC configuration
  rtc->ctrl = osc_type << AVR32_RTC_CTRL_CLK32_OFFSET |
800067be:	a3 76       	lsl	r6,0x3
800067c0:	b1 a6       	sbr	r6,0x10
800067c2:	ed e5 10 85 	or	r5,r6,r5<<0x8
800067c6:	8f 05       	st.w	r7[0x0],r5
              psel << AVR32_RTC_CTRL_PSEL_OFFSET |
              AVR32_RTC_CTRL_CLKEN_MASK;

  // Wait until write is done
  while (rtc_is_busy(rtc));
800067c8:	0e 9c       	mov	r12,r7
800067ca:	f0 1f 00 09 	mcall	800067ec <rtc_init+0x74>
800067ce:	cf d1       	brne	800067c8 <rtc_init+0x50>

  // Set the counter value to 0
  rtc_set_value(rtc, 0x00000000);
800067d0:	30 0b       	mov	r11,0
800067d2:	0e 9c       	mov	r12,r7
800067d4:	f0 1f 00 07 	mcall	800067f0 <rtc_init+0x78>
  // Set the top value to 0xFFFFFFFF
  rtc_set_top_value(rtc, 0xFFFFFFFF);
800067d8:	3f fb       	mov	r11,-1
800067da:	0e 9c       	mov	r12,r7
800067dc:	f0 1f 00 06 	mcall	800067f4 <rtc_init+0x7c>
800067e0:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800067e4:	80 00       	ld.sh	r0,r0[0x0]
800067e6:	65 c4       	ld.w	r4,r2[0x70]
800067e8:	80 00       	ld.sh	r0,r0[0x0]
800067ea:	65 f0       	ld.w	r0,r2[0x7c]
800067ec:	80 00       	ld.sh	r0,r0[0x0]
800067ee:	66 dc       	ld.w	r12,r3[0x34]
800067f0:	80 00       	ld.sh	r0,r0[0x0]
800067f2:	66 e4       	ld.w	r4,r3[0x38]
800067f4:	80 00       	ld.sh	r0,r0[0x0]
800067f6:	67 34       	ld.w	r4,r3[0x4c]

800067f8 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
800067f8:	f8 c8 00 01 	sub	r8,r12,1
800067fc:	f0 0b 00 0b 	add	r11,r8,r11
80006800:	f6 0c 0d 0a 	divu	r10,r11,r12
80006804:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80006806:	f4 c8 00 01 	sub	r8,r10,1
8000680a:	e0 48 00 fe 	cp.w	r8,254
8000680e:	e0 88 00 03 	brls	80006814 <getBaudDiv+0x1c>
80006812:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80006814:	5c 8c       	casts.h	r12
}
80006816:	5e fc       	retal	r12

80006818 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80006818:	f7 39 00 0d 	ld.ub	r9,r11[13]
8000681c:	30 18       	mov	r8,1
8000681e:	f0 09 18 00 	cp.b	r9,r8
80006822:	e0 88 00 04 	brls	8000682a <spi_initMaster+0x12>
80006826:	30 2c       	mov	r12,2
80006828:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
8000682a:	e0 68 00 80 	mov	r8,128
8000682e:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80006830:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
80006832:	30 19       	mov	r9,1
80006834:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80006838:	f7 39 00 0d 	ld.ub	r9,r11[13]
8000683c:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80006840:	30 09       	mov	r9,0
80006842:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80006846:	30 fa       	mov	r10,15
80006848:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
8000684c:	99 18       	st.w	r12[0x4],r8
8000684e:	5e f9       	retal	r9

80006850 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80006850:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80006852:	30 18       	mov	r8,1
80006854:	f0 0b 18 00 	cp.b	r11,r8
80006858:	5f be       	srhi	lr
8000685a:	f0 0a 18 00 	cp.b	r10,r8
8000685e:	5f b8       	srhi	r8
80006860:	fd e8 10 08 	or	r8,lr,r8
80006864:	c0 30       	breq	8000686a <spi_selectionMode+0x1a>
80006866:	30 2c       	mov	r12,2
80006868:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
8000686a:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
8000686c:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80006870:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80006874:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80006878:	99 18       	st.w	r12[0x4],r8
8000687a:	d8 0a       	popm	pc,r12=0

8000687c <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
8000687c:	30 18       	mov	r8,1
8000687e:	99 08       	st.w	r12[0x0],r8
}
80006880:	5e fc       	retal	r12

80006882 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80006882:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80006886:	c0 58       	rjmp	80006890 <spi_write+0xe>
		if (!timeout--) {
80006888:	58 08       	cp.w	r8,0
8000688a:	c0 21       	brne	8000688e <spi_write+0xc>
8000688c:	5e ff       	retal	1
8000688e:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80006890:	78 49       	ld.w	r9,r12[0x10]
80006892:	e2 19 00 02 	andl	r9,0x2,COH
80006896:	cf 90       	breq	80006888 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80006898:	5c 7b       	castu.h	r11
8000689a:	99 3b       	st.w	r12[0xc],r11
8000689c:	5e fd       	retal	0

8000689e <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
8000689e:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800068a2:	c0 58       	rjmp	800068ac <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
800068a4:	58 08       	cp.w	r8,0
800068a6:	c0 21       	brne	800068aa <spi_read+0xc>
800068a8:	5e ff       	retal	1
800068aa:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800068ac:	78 49       	ld.w	r9,r12[0x10]
800068ae:	e2 19 02 01 	andl	r9,0x201,COH
800068b2:	e0 49 02 01 	cp.w	r9,513
800068b6:	cf 71       	brne	800068a4 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
800068b8:	78 28       	ld.w	r8,r12[0x8]
800068ba:	b6 08       	st.h	r11[0x0],r8
800068bc:	5e fd       	retal	0
800068be:	d7 03       	nop

800068c0 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
800068c0:	eb cd 40 f8 	pushm	r3-r7,lr
800068c4:	18 95       	mov	r5,r12
800068c6:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800068c8:	f7 36 00 0c 	ld.ub	r6,r11[12]
800068cc:	30 38       	mov	r8,3
800068ce:	f0 06 18 00 	cp.b	r6,r8
800068d2:	e0 8b 00 5e 	brhi	8000698e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
800068d6:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800068da:	30 18       	mov	r8,1
800068dc:	f0 04 18 00 	cp.b	r4,r8
800068e0:	e0 8b 00 57 	brhi	8000698e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
800068e4:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800068e8:	30 78       	mov	r8,7
800068ea:	f0 03 18 00 	cp.b	r3,r8
800068ee:	e0 88 00 50 	brls	8000698e <spi_setupChipReg+0xce>
800068f2:	31 08       	mov	r8,16
800068f4:	f0 03 18 00 	cp.b	r3,r8
800068f8:	e0 8b 00 4b 	brhi	8000698e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
800068fc:	14 9b       	mov	r11,r10
800068fe:	6e 1c       	ld.w	r12,r7[0x4]
80006900:	f0 1f 00 26 	mcall	80006998 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
80006904:	c4 55       	brlt	8000698e <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80006906:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80006908:	ec 09 16 01 	lsr	r9,r6,0x1
8000690c:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80006910:	ec 16 00 01 	eorl	r6,0x1
80006914:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80006918:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
8000691c:	20 83       	sub	r3,8
8000691e:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80006922:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80006926:	ef 39 00 09 	ld.ub	r9,r7[9]
8000692a:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
8000692e:	ef 39 00 0a 	ld.ub	r9,r7[10]
80006932:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80006936:	0f 89       	ld.ub	r9,r7[0x0]
80006938:	30 1a       	mov	r10,1
8000693a:	f4 09 18 00 	cp.b	r9,r10
8000693e:	c0 d0       	breq	80006958 <spi_setupChipReg+0x98>
80006940:	c0 a3       	brcs	80006954 <spi_setupChipReg+0x94>
80006942:	30 2a       	mov	r10,2
80006944:	f4 09 18 00 	cp.b	r9,r10
80006948:	c0 a0       	breq	8000695c <spi_setupChipReg+0x9c>
8000694a:	30 3a       	mov	r10,3
8000694c:	f4 09 18 00 	cp.b	r9,r10
80006950:	c1 f1       	brne	8000698e <spi_setupChipReg+0xce>
80006952:	c0 78       	rjmp	80006960 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80006954:	8b c8       	st.w	r5[0x30],r8
		break;
80006956:	c0 68       	rjmp	80006962 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80006958:	8b d8       	st.w	r5[0x34],r8
		break;
8000695a:	c0 48       	rjmp	80006962 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
8000695c:	8b e8       	st.w	r5[0x38],r8
		break;
8000695e:	c0 28       	rjmp	80006962 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80006960:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80006962:	48 f8       	lddpc	r8,8000699c <spi_setupChipReg+0xdc>
80006964:	70 08       	ld.w	r8,r8[0x0]
80006966:	58 08       	cp.w	r8,0
80006968:	c1 61       	brne	80006994 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
8000696a:	30 0b       	mov	r11,0
8000696c:	30 1c       	mov	r12,1
8000696e:	f0 1f 00 0d 	mcall	800069a0 <spi_setupChipReg+0xe0>
80006972:	48 b8       	lddpc	r8,8000699c <spi_setupChipReg+0xdc>
80006974:	91 0c       	st.w	r8[0x0],r12
80006976:	58 0c       	cp.w	r12,0
80006978:	c0 a0       	breq	8000698c <spi_setupChipReg+0xcc>
8000697a:	30 09       	mov	r9,0
8000697c:	12 9a       	mov	r10,r9
8000697e:	12 9b       	mov	r11,r9
80006980:	f0 1f 00 09 	mcall	800069a4 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80006984:	48 68       	lddpc	r8,8000699c <spi_setupChipReg+0xdc>
80006986:	70 08       	ld.w	r8,r8[0x0]
80006988:	58 08       	cp.w	r8,0
8000698a:	c0 51       	brne	80006994 <spi_setupChipReg+0xd4>
8000698c:	c0 08       	rjmp	8000698c <spi_setupChipReg+0xcc>
8000698e:	30 2c       	mov	r12,2
80006990:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80006994:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80006998:	80 00       	ld.sh	r0,r0[0x0]
8000699a:	67 f8       	ld.w	r8,r3[0x7c]
8000699c:	00 00       	add	r0,r0
8000699e:	bd 44       	asr	r4,0x1c
800069a0:	80 00       	ld.sh	r0,r0[0x0]
800069a2:	74 e4       	ld.w	r4,r10[0x38]
800069a4:	80 00       	ld.sh	r0,r0[0x0]
800069a6:	73 8c       	ld.w	r12,r9[0x60]

800069a8 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800069a8:	d4 01       	pushm	lr
800069aa:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800069ae:	c0 58       	rjmp	800069b8 <spi_unselectChip+0x10>
		if (!timeout--) {
800069b0:	58 08       	cp.w	r8,0
800069b2:	c0 21       	brne	800069b6 <spi_unselectChip+0xe>
800069b4:	da 0a       	popm	pc,r12=1
800069b6:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800069b8:	78 49       	ld.w	r9,r12[0x10]
800069ba:	e2 19 02 00 	andl	r9,0x200,COH
800069be:	cf 90       	breq	800069b0 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800069c0:	78 18       	ld.w	r8,r12[0x4]
800069c2:	ea 18 00 0f 	orh	r8,0xf
800069c6:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
800069c8:	fc 18 01 00 	movh	r8,0x100
800069cc:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
800069ce:	30 09       	mov	r9,0
800069d0:	12 9a       	mov	r10,r9
800069d2:	12 9b       	mov	r11,r9
800069d4:	48 38       	lddpc	r8,800069e0 <spi_unselectChip+0x38>
800069d6:	70 0c       	ld.w	r12,r8[0x0]
800069d8:	f0 1f 00 03 	mcall	800069e4 <spi_unselectChip+0x3c>
800069dc:	d8 0a       	popm	pc,r12=0
800069de:	00 00       	add	r0,r0
800069e0:	00 00       	add	r0,r0
800069e2:	bd 44       	asr	r4,0x1c
800069e4:	80 00       	ld.sh	r0,r0[0x0]
800069e6:	73 8c       	ld.w	r12,r9[0x60]

800069e8 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800069e8:	eb cd 40 f8 	pushm	r3-r7,lr
800069ec:	18 94       	mov	r4,r12
800069ee:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
800069f0:	49 a6       	lddpc	r6,80006a58 <spi_selectChip+0x70>
800069f2:	30 07       	mov	r7,0
800069f4:	31 45       	mov	r5,20
800069f6:	0e 99       	mov	r9,r7
800069f8:	0a 9a       	mov	r10,r5
800069fa:	0e 9b       	mov	r11,r7
800069fc:	6c 0c       	ld.w	r12,r6[0x0]
800069fe:	f0 1f 00 18 	mcall	80006a5c <spi_selectChip+0x74>
80006a02:	cf a0       	breq	800069f6 <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80006a04:	68 18       	ld.w	r8,r4[0x4]
80006a06:	ea 18 00 0f 	orh	r8,0xf
80006a0a:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80006a0c:	68 18       	ld.w	r8,r4[0x4]
80006a0e:	e2 18 00 04 	andl	r8,0x4,COH
80006a12:	c1 10       	breq	80006a34 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80006a14:	30 e8       	mov	r8,14
80006a16:	f0 03 18 00 	cp.b	r3,r8
80006a1a:	e0 8b 00 1c 	brhi	80006a52 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80006a1e:	68 19       	ld.w	r9,r4[0x4]
80006a20:	e6 08 15 10 	lsl	r8,r3,0x10
80006a24:	ea 18 ff f0 	orh	r8,0xfff0
80006a28:	e8 18 ff ff 	orl	r8,0xffff
80006a2c:	12 68       	and	r8,r9
80006a2e:	89 18       	st.w	r4[0x4],r8
80006a30:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80006a34:	30 38       	mov	r8,3
80006a36:	f0 03 18 00 	cp.b	r3,r8
80006a3a:	e0 8b 00 0c 	brhi	80006a52 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80006a3e:	68 19       	ld.w	r9,r4[0x4]
80006a40:	2f 03       	sub	r3,-16
80006a42:	30 18       	mov	r8,1
80006a44:	f0 03 09 48 	lsl	r8,r8,r3
80006a48:	5c d8       	com	r8
80006a4a:	12 68       	and	r8,r9
80006a4c:	89 18       	st.w	r4[0x4],r8
80006a4e:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80006a52:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80006a54:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80006a58:	00 00       	add	r0,r0
80006a5a:	bd 44       	asr	r4,0x1c
80006a5c:	80 00       	ld.sh	r0,r0[0x0]
80006a5e:	71 80       	ld.w	r0,r8[0x60]

80006a60 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80006a60:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80006a62:	f6 08 15 04 	lsl	r8,r11,0x4
80006a66:	14 38       	cp.w	r8,r10
80006a68:	f9 b8 08 10 	movls	r8,16
80006a6c:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80006a70:	f0 0b 02 4b 	mul	r11,r8,r11
80006a74:	f6 09 16 01 	lsr	r9,r11,0x1
80006a78:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80006a7c:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80006a80:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80006a84:	f2 cb 00 01 	sub	r11,r9,1
80006a88:	e0 4b ff fe 	cp.w	r11,65534
80006a8c:	e0 88 00 03 	brls	80006a92 <usart_set_async_baudrate+0x32>
80006a90:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80006a92:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80006a94:	e8 6e 00 00 	mov	lr,524288
80006a98:	59 08       	cp.w	r8,16
80006a9a:	fc 08 17 10 	movne	r8,lr
80006a9e:	f9 b8 00 00 	moveq	r8,0
80006aa2:	e4 1b ff f7 	andh	r11,0xfff7
80006aa6:	e0 1b fe cf 	andl	r11,0xfecf
80006aaa:	16 48       	or	r8,r11
80006aac:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80006aae:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80006ab2:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80006ab6:	99 89       	st.w	r12[0x20],r9
80006ab8:	d8 0a       	popm	pc,r12=0

80006aba <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80006aba:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80006abc:	e2 18 00 02 	andl	r8,0x2,COH
80006ac0:	c0 31       	brne	80006ac6 <usart_write_char+0xc>
80006ac2:	30 2c       	mov	r12,2
80006ac4:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80006ac6:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80006aca:	99 7b       	st.w	r12[0x1c],r11
80006acc:	5e fd       	retal	0
80006ace:	d7 03       	nop

80006ad0 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80006ad0:	eb cd 40 e0 	pushm	r5-r7,lr
80006ad4:	18 96       	mov	r6,r12
80006ad6:	16 95       	mov	r5,r11
80006ad8:	e0 67 27 0f 	mov	r7,9999
80006adc:	c0 68       	rjmp	80006ae8 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80006ade:	58 07       	cp.w	r7,0
80006ae0:	c0 31       	brne	80006ae6 <usart_putchar+0x16>
80006ae2:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80006ae6:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80006ae8:	0a 9b       	mov	r11,r5
80006aea:	0c 9c       	mov	r12,r6
80006aec:	f0 1f 00 03 	mcall	80006af8 <usart_putchar+0x28>
80006af0:	cf 71       	brne	80006ade <usart_putchar+0xe>

  return USART_SUCCESS;
}
80006af2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006af6:	00 00       	add	r0,r0
80006af8:	80 00       	ld.sh	r0,r0[0x0]
80006afa:	6a ba       	ld.w	r10,r5[0x2c]

80006afc <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80006afc:	78 58       	ld.w	r8,r12[0x14]
80006afe:	e2 18 00 e0 	andl	r8,0xe0,COH
80006b02:	c0 30       	breq	80006b08 <usart_read_char+0xc>
80006b04:	30 4c       	mov	r12,4
80006b06:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80006b08:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80006b0a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006b0e:	c0 31       	brne	80006b14 <usart_read_char+0x18>
80006b10:	30 3c       	mov	r12,3
80006b12:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80006b14:	78 68       	ld.w	r8,r12[0x18]
80006b16:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80006b1a:	97 08       	st.w	r11[0x0],r8
80006b1c:	5e fd       	retal	0
80006b1e:	d7 03       	nop

80006b20 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80006b20:	eb cd 40 c0 	pushm	r6-r7,lr
80006b24:	20 1d       	sub	sp,4
80006b26:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80006b28:	1a 97       	mov	r7,sp
80006b2a:	1a 9b       	mov	r11,sp
80006b2c:	0c 9c       	mov	r12,r6
80006b2e:	f0 1f 00 07 	mcall	80006b48 <usart_getchar+0x28>
80006b32:	58 3c       	cp.w	r12,3
80006b34:	cf b0       	breq	80006b2a <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80006b36:	58 4c       	cp.w	r12,4
80006b38:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80006b3c:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80006b40:	2f fd       	sub	sp,-4
80006b42:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006b46:	00 00       	add	r0,r0
80006b48:	80 00       	ld.sh	r0,r0[0x0]
80006b4a:	6a fc       	ld.w	r12,r5[0x3c]

80006b4c <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80006b4c:	eb cd 40 c0 	pushm	r6-r7,lr
80006b50:	18 96       	mov	r6,r12
80006b52:	16 97       	mov	r7,r11
  while (*string != '\0')
80006b54:	17 8b       	ld.ub	r11,r11[0x0]
80006b56:	58 0b       	cp.w	r11,0
80006b58:	c0 80       	breq	80006b68 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80006b5a:	2f f7       	sub	r7,-1
80006b5c:	0c 9c       	mov	r12,r6
80006b5e:	f0 1f 00 04 	mcall	80006b6c <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80006b62:	0f 8b       	ld.ub	r11,r7[0x0]
80006b64:	58 0b       	cp.w	r11,0
80006b66:	cf a1       	brne	80006b5a <usart_write_line+0xe>
80006b68:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006b6c:	80 00       	ld.sh	r0,r0[0x0]
80006b6e:	6a d0       	ld.w	r0,r5[0x34]

80006b70 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80006b70:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80006b74:	e6 18 00 01 	andh	r8,0x1,COH
80006b78:	c0 71       	brne	80006b86 <usart_reset+0x16>
80006b7a:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80006b7c:	3f f8       	mov	r8,-1
80006b7e:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80006b80:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80006b82:	d5 03       	csrf	0x10
80006b84:	c0 48       	rjmp	80006b8c <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80006b86:	3f f8       	mov	r8,-1
80006b88:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80006b8a:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80006b8c:	30 08       	mov	r8,0
80006b8e:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80006b90:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80006b92:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80006b94:	ea 68 61 0c 	mov	r8,680204
80006b98:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80006b9a:	5e fc       	retal	r12

80006b9c <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80006b9c:	eb cd 40 e0 	pushm	r5-r7,lr
80006ba0:	18 96       	mov	r6,r12
80006ba2:	16 97       	mov	r7,r11
80006ba4:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80006ba6:	f0 1f 00 2f 	mcall	80006c60 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80006baa:	58 07       	cp.w	r7,0
80006bac:	c5 80       	breq	80006c5c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80006bae:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80006bb0:	30 49       	mov	r9,4
80006bb2:	f2 08 18 00 	cp.b	r8,r9
80006bb6:	e0 88 00 53 	brls	80006c5c <usart_init_rs232+0xc0>
80006bba:	30 99       	mov	r9,9
80006bbc:	f2 08 18 00 	cp.b	r8,r9
80006bc0:	e0 8b 00 4e 	brhi	80006c5c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80006bc4:	0f d9       	ld.ub	r9,r7[0x5]
80006bc6:	30 78       	mov	r8,7
80006bc8:	f0 09 18 00 	cp.b	r9,r8
80006bcc:	e0 8b 00 48 	brhi	80006c5c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80006bd0:	8e 39       	ld.sh	r9,r7[0x6]
80006bd2:	e0 68 01 01 	mov	r8,257
80006bd6:	f0 09 19 00 	cp.h	r9,r8
80006bda:	e0 8b 00 41 	brhi	80006c5c <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80006bde:	ef 39 00 08 	ld.ub	r9,r7[8]
80006be2:	30 38       	mov	r8,3
80006be4:	f0 09 18 00 	cp.b	r9,r8
80006be8:	e0 8b 00 3a 	brhi	80006c5c <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80006bec:	0a 9a       	mov	r10,r5
80006bee:	6e 0b       	ld.w	r11,r7[0x0]
80006bf0:	0c 9c       	mov	r12,r6
80006bf2:	f0 1f 00 1d 	mcall	80006c64 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80006bf6:	58 1c       	cp.w	r12,1
80006bf8:	c3 20       	breq	80006c5c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80006bfa:	0f c8       	ld.ub	r8,r7[0x4]
80006bfc:	30 99       	mov	r9,9
80006bfe:	f2 08 18 00 	cp.b	r8,r9
80006c02:	c0 51       	brne	80006c0c <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80006c04:	6c 18       	ld.w	r8,r6[0x4]
80006c06:	b1 b8       	sbr	r8,0x11
80006c08:	8d 18       	st.w	r6[0x4],r8
80006c0a:	c0 68       	rjmp	80006c16 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80006c0c:	6c 19       	ld.w	r9,r6[0x4]
80006c0e:	20 58       	sub	r8,5
80006c10:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80006c14:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80006c16:	6c 19       	ld.w	r9,r6[0x4]
80006c18:	ef 3a 00 08 	ld.ub	r10,r7[8]
80006c1c:	0f d8       	ld.ub	r8,r7[0x5]
80006c1e:	a9 78       	lsl	r8,0x9
80006c20:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80006c24:	12 48       	or	r8,r9
80006c26:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80006c28:	8e 38       	ld.sh	r8,r7[0x6]
80006c2a:	30 29       	mov	r9,2
80006c2c:	f2 08 19 00 	cp.h	r8,r9
80006c30:	e0 88 00 09 	brls	80006c42 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80006c34:	6c 18       	ld.w	r8,r6[0x4]
80006c36:	ad b8       	sbr	r8,0xd
80006c38:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80006c3a:	8e b8       	ld.uh	r8,r7[0x6]
80006c3c:	20 28       	sub	r8,2
80006c3e:	8d a8       	st.w	r6[0x28],r8
80006c40:	c0 68       	rjmp	80006c4c <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80006c42:	6c 19       	ld.w	r9,r6[0x4]
80006c44:	5c 78       	castu.h	r8
80006c46:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80006c4a:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80006c4c:	6c 18       	ld.w	r8,r6[0x4]
80006c4e:	e0 18 ff f0 	andl	r8,0xfff0
80006c52:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80006c54:	35 08       	mov	r8,80
80006c56:	8d 08       	st.w	r6[0x0],r8
80006c58:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80006c5c:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80006c60:	80 00       	ld.sh	r0,r0[0x0]
80006c62:	6b 70       	ld.w	r0,r5[0x5c]
80006c64:	80 00       	ld.sh	r0,r0[0x0]
80006c66:	6a 60       	ld.w	r0,r5[0x18]

80006c68 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80006c68:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80006c6c:	fe c0 8e 6c 	sub	r0,pc,-29076

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80006c70:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80006c74:	d5 53       	csrf	0x15
  cp      r0, r1
80006c76:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80006c78:	e0 61 0a 58 	mov	r1,2648
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80006c7c:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80006c7e:	c0 62       	brcc	80006c8a <idata_load_loop_end>
  cp      r0, r1
80006c80:	48 92       	lddpc	r2,80006ca4 <udata_clear_loop_end+0x4>

80006c82 <idata_load_loop>:
  brlo    idata_load_loop
80006c82:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80006c84:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80006c86:	02 30       	cp.w	r0,r1
  cp      r0, r1
80006c88:	cf d3       	brcs	80006c82 <idata_load_loop>

80006c8a <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80006c8a:	e0 60 0a 58 	mov	r0,2648
  mov     r2, 0
  mov     r3, 0
80006c8e:	e0 61 bd 58 	mov	r1,48472
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80006c92:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80006c94:	c0 62       	brcc	80006ca0 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80006c96:	30 02       	mov	r2,0
80006c98:	30 03       	mov	r3,0

80006c9a <udata_clear_loop>:
80006c9a:	a1 22       	st.d	r0++,r2
80006c9c:	02 30       	cp.w	r0,r1
80006c9e:	cf e3       	brcs	80006c9a <udata_clear_loop>

80006ca0 <udata_clear_loop_end>:
80006ca0:	fe cf e9 28 	sub	pc,pc,-5848
80006ca4:	80 00       	ld.sh	r0,r0[0x0]
80006ca6:	f6 40 f8 c8 	cp.w	r0,-591672

80006ca8 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80006ca8:	f8 c8 ff f8 	sub	r8,r12,-8
80006cac:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80006cae:	3f f9       	mov	r9,-1
80006cb0:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80006cb2:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80006cb4:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80006cb6:	30 08       	mov	r8,0
80006cb8:	99 08       	st.w	r12[0x0],r8
}
80006cba:	5e fc       	retal	r12

80006cbc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80006cbc:	30 08       	mov	r8,0
80006cbe:	99 48       	st.w	r12[0x10],r8
}
80006cc0:	5e fc       	retal	r12

80006cc2 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80006cc2:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80006cc4:	70 19       	ld.w	r9,r8[0x4]
80006cc6:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80006cc8:	78 19       	ld.w	r9,r12[0x4]
80006cca:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80006ccc:	70 19       	ld.w	r9,r8[0x4]
80006cce:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80006cd0:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80006cd2:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80006cd4:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80006cd6:	78 08       	ld.w	r8,r12[0x0]
80006cd8:	2f f8       	sub	r8,-1
80006cda:	99 08       	st.w	r12[0x0],r8
}
80006cdc:	5e fc       	retal	r12

80006cde <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80006cde:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80006ce0:	5b fa       	cp.w	r10,-1
80006ce2:	c0 31       	brne	80006ce8 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80006ce4:	78 48       	ld.w	r8,r12[0x10]
80006ce6:	c0 c8       	rjmp	80006cfe <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80006ce8:	f8 c8 ff f8 	sub	r8,r12,-8
80006cec:	70 19       	ld.w	r9,r8[0x4]
80006cee:	72 09       	ld.w	r9,r9[0x0]
80006cf0:	12 3a       	cp.w	r10,r9
80006cf2:	c0 63       	brcs	80006cfe <vListInsert+0x20>
80006cf4:	70 18       	ld.w	r8,r8[0x4]
80006cf6:	70 19       	ld.w	r9,r8[0x4]
80006cf8:	72 09       	ld.w	r9,r9[0x0]
80006cfa:	12 3a       	cp.w	r10,r9
80006cfc:	cf c2       	brcc	80006cf4 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80006cfe:	70 19       	ld.w	r9,r8[0x4]
80006d00:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80006d02:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80006d04:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80006d06:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80006d08:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80006d0a:	78 08       	ld.w	r8,r12[0x0]
80006d0c:	2f f8       	sub	r8,-1
80006d0e:	99 08       	st.w	r12[0x0],r8
}
80006d10:	5e fc       	retal	r12

80006d12 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80006d12:	78 18       	ld.w	r8,r12[0x4]
80006d14:	78 29       	ld.w	r9,r12[0x8]
80006d16:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80006d18:	78 28       	ld.w	r8,r12[0x8]
80006d1a:	78 19       	ld.w	r9,r12[0x4]
80006d1c:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80006d1e:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80006d20:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80006d22:	18 39       	cp.w	r9,r12
80006d24:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80006d28:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80006d2c:	30 09       	mov	r9,0
80006d2e:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80006d30:	70 09       	ld.w	r9,r8[0x0]
80006d32:	20 19       	sub	r9,1
80006d34:	91 09       	st.w	r8[0x0],r9
}
80006d36:	5e fc       	retal	r12

80006d38 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80006d38:	e0 68 08 08 	mov	r8,2056
80006d3c:	ea 18 08 08 	orh	r8,0x808
80006d40:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80006d42:	e0 68 09 09 	mov	r8,2313
80006d46:	ea 18 09 09 	orh	r8,0x909
80006d4a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80006d4c:	e0 68 0a 0a 	mov	r8,2570
80006d50:	ea 18 0a 0a 	orh	r8,0xa0a
80006d54:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80006d56:	e0 68 0b 0b 	mov	r8,2827
80006d5a:	ea 18 0b 0b 	orh	r8,0xb0b
80006d5e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80006d60:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80006d62:	e0 68 be ef 	mov	r8,48879
80006d66:	ea 18 de ad 	orh	r8,0xdead
80006d6a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80006d6c:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80006d6e:	fc 18 00 40 	movh	r8,0x40
80006d72:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80006d74:	e0 68 00 ff 	mov	r8,255
80006d78:	ea 18 ff 00 	orh	r8,0xff00
80006d7c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80006d7e:	e0 68 01 01 	mov	r8,257
80006d82:	ea 18 01 01 	orh	r8,0x101
80006d86:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80006d88:	e0 68 02 02 	mov	r8,514
80006d8c:	ea 18 02 02 	orh	r8,0x202
80006d90:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80006d92:	e0 68 03 03 	mov	r8,771
80006d96:	ea 18 03 03 	orh	r8,0x303
80006d9a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80006d9c:	e0 68 04 04 	mov	r8,1028
80006da0:	ea 18 04 04 	orh	r8,0x404
80006da4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80006da6:	e0 68 05 05 	mov	r8,1285
80006daa:	ea 18 05 05 	orh	r8,0x505
80006dae:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80006db0:	e0 68 06 06 	mov	r8,1542
80006db4:	ea 18 06 06 	orh	r8,0x606
80006db8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80006dba:	e0 68 07 07 	mov	r8,1799
80006dbe:	ea 18 07 07 	orh	r8,0x707
80006dc2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80006dc4:	30 08       	mov	r8,0
80006dc6:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80006dc8:	5e fc       	retal	r12
80006dca:	d7 03       	nop

80006dcc <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80006dcc:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80006dce:	48 38       	lddpc	r8,80006dd8 <vPortEnterCritical+0xc>
80006dd0:	70 09       	ld.w	r9,r8[0x0]
80006dd2:	2f f9       	sub	r9,-1
80006dd4:	91 09       	st.w	r8[0x0],r9
}
80006dd6:	5e fc       	retal	r12
80006dd8:	00 00       	add	r0,r0
80006dda:	05 4c       	ld.w	r12,--r2

80006ddc <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80006ddc:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80006dde:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80006de0:	30 0a       	mov	r10,0
80006de2:	14 9b       	mov	r11,r10
80006de4:	49 2c       	lddpc	r12,80006e2c <xPortStartScheduler+0x50>
80006de6:	f0 1f 00 13 	mcall	80006e30 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80006dea:	e0 68 5d c0 	mov	r8,24000
80006dee:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80006df2:	30 08       	mov	r8,0
80006df4:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80006df8:	e0 68 0d 70 	mov	r8,3440
80006dfc:	ea 18 00 00 	orh	r8,0x0
80006e00:	70 00       	ld.w	r0,r8[0x0]
80006e02:	60 0d       	ld.w	sp,r0[0x0]
80006e04:	1b 00       	ld.w	r0,sp++
80006e06:	e0 68 05 4c 	mov	r8,1356
80006e0a:	ea 18 00 00 	orh	r8,0x0
80006e0e:	91 00       	st.w	r8[0x0],r0
80006e10:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006e14:	2f ed       	sub	sp,-8
80006e16:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80006e1a:	fa f0 ff e0 	ld.w	r0,sp[-32]
80006e1e:	e3 b0 00 00 	mtsr	0x0,r0
80006e22:	fa f0 ff dc 	ld.w	r0,sp[-36]
80006e26:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80006e2a:	d8 0a       	popm	pc,r12=0
80006e2c:	80 00       	ld.sh	r0,r0[0x0]
80006e2e:	6e f8       	ld.w	r8,r7[0x3c]
80006e30:	80 00       	ld.sh	r0,r0[0x0]
80006e32:	64 2c       	ld.w	r12,r2[0x8]

80006e34 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80006e34:	20 6d       	sub	sp,24
80006e36:	eb cd 00 ff 	pushm	r0-r7
80006e3a:	fa c7 ff c0 	sub	r7,sp,-64
80006e3e:	ee f0 ff f8 	ld.w	r0,r7[-8]
80006e42:	ef 40 ff e0 	st.w	r7[-32],r0
80006e46:	ee f0 ff fc 	ld.w	r0,r7[-4]
80006e4a:	ef 40 ff e4 	st.w	r7[-28],r0
80006e4e:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80006e52:	e0 68 05 4c 	mov	r8,1356
80006e56:	ea 18 00 00 	orh	r8,0x0
80006e5a:	70 00       	ld.w	r0,r8[0x0]
80006e5c:	1a d0       	st.w	--sp,r0
80006e5e:	f0 1f 00 1a 	mcall	80006ec4 <LABEL_RET_SCALL_263+0x14>
80006e62:	e0 68 0d 70 	mov	r8,3440
80006e66:	ea 18 00 00 	orh	r8,0x0
80006e6a:	70 00       	ld.w	r0,r8[0x0]
80006e6c:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80006e6e:	f0 1f 00 17 	mcall	80006ec8 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80006e72:	e0 68 0d 70 	mov	r8,3440
80006e76:	ea 18 00 00 	orh	r8,0x0
80006e7a:	70 00       	ld.w	r0,r8[0x0]
80006e7c:	60 0d       	ld.w	sp,r0[0x0]
80006e7e:	1b 00       	ld.w	r0,sp++
80006e80:	e0 68 05 4c 	mov	r8,1356
80006e84:	ea 18 00 00 	orh	r8,0x0
80006e88:	91 00       	st.w	r8[0x0],r0
80006e8a:	fa c7 ff d8 	sub	r7,sp,-40
80006e8e:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80006e92:	ee f0 ff e0 	ld.w	r0,r7[-32]
80006e96:	e0 61 05 4c 	mov	r1,1356
80006e9a:	ea 11 00 00 	orh	r1,0x0
80006e9e:	62 02       	ld.w	r2,r1[0x0]
80006ea0:	58 02       	cp.w	r2,0
80006ea2:	c0 70       	breq	80006eb0 <LABEL_RET_SCALL_263>
80006ea4:	e4 c2 00 01 	sub	r2,r2,1
80006ea8:	83 02       	st.w	r1[0x0],r2
80006eaa:	58 02       	cp.w	r2,0
80006eac:	c0 21       	brne	80006eb0 <LABEL_RET_SCALL_263>
80006eae:	b1 c0       	cbr	r0,0x10

80006eb0 <LABEL_RET_SCALL_263>:
80006eb0:	ef 40 ff f8 	st.w	r7[-8],r0
80006eb4:	ee f0 ff e4 	ld.w	r0,r7[-28]
80006eb8:	ef 40 ff fc 	st.w	r7[-4],r0
80006ebc:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006ec0:	2f ad       	sub	sp,-24
80006ec2:	d6 13       	rets
80006ec4:	80 00       	ld.sh	r0,r0[0x0]
80006ec6:	6d cc       	ld.w	r12,r6[0x70]
80006ec8:	80 00       	ld.sh	r0,r0[0x0]
80006eca:	75 68       	ld.w	r8,r10[0x58]

80006ecc <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80006ecc:	e1 b8 00 43 	mfsr	r8,0x10c
80006ed0:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80006ed4:	5e fc       	retal	r12
80006ed6:	d7 03       	nop

80006ed8 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80006ed8:	48 78       	lddpc	r8,80006ef4 <vPortExitCritical+0x1c>
80006eda:	70 08       	ld.w	r8,r8[0x0]
80006edc:	58 08       	cp.w	r8,0
80006ede:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80006ee0:	48 58       	lddpc	r8,80006ef4 <vPortExitCritical+0x1c>
80006ee2:	70 09       	ld.w	r9,r8[0x0]
80006ee4:	20 19       	sub	r9,1
80006ee6:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80006ee8:	70 08       	ld.w	r8,r8[0x0]
80006eea:	58 08       	cp.w	r8,0
80006eec:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80006eee:	d5 03       	csrf	0x10
80006ef0:	5e fc       	retal	r12
80006ef2:	00 00       	add	r0,r0
80006ef4:	00 00       	add	r0,r0
80006ef6:	05 4c       	ld.w	r12,--r2

80006ef8 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80006ef8:	eb cd 00 ff 	pushm	r0-r7
80006efc:	e0 68 05 4c 	mov	r8,1356
80006f00:	ea 18 00 00 	orh	r8,0x0
80006f04:	70 00       	ld.w	r0,r8[0x0]
80006f06:	1a d0       	st.w	--sp,r0
80006f08:	7a 90       	ld.w	r0,sp[0x24]
80006f0a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80006f0e:	58 10       	cp.w	r0,1
80006f10:	e0 8b 00 08 	brhi	80006f20 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80006f14:	e0 68 0d 70 	mov	r8,3440
80006f18:	ea 18 00 00 	orh	r8,0x0
80006f1c:	70 00       	ld.w	r0,r8[0x0]
80006f1e:	81 0d       	st.w	r0[0x0],sp

80006f20 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80006f20:	f0 1f 00 12 	mcall	80006f68 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80006f24:	f0 1f 00 12 	mcall	80006f6c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80006f28:	f0 1f 00 12 	mcall	80006f70 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80006f2c:	f0 1f 00 12 	mcall	80006f74 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80006f30:	7a 90       	ld.w	r0,sp[0x24]
80006f32:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80006f36:	58 10       	cp.w	r0,1
80006f38:	e0 8b 00 0e 	brhi	80006f54 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80006f3c:	f0 1f 00 0c 	mcall	80006f6c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80006f40:	f0 1f 00 0e 	mcall	80006f78 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80006f44:	f0 1f 00 0c 	mcall	80006f74 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80006f48:	e0 68 0d 70 	mov	r8,3440
80006f4c:	ea 18 00 00 	orh	r8,0x0
80006f50:	70 00       	ld.w	r0,r8[0x0]
80006f52:	60 0d       	ld.w	sp,r0[0x0]

80006f54 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80006f54:	1b 00       	ld.w	r0,sp++
80006f56:	e0 68 05 4c 	mov	r8,1356
80006f5a:	ea 18 00 00 	orh	r8,0x0
80006f5e:	91 00       	st.w	r8[0x0],r0
80006f60:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006f64:	d6 03       	rete
80006f66:	00 00       	add	r0,r0
80006f68:	80 00       	ld.sh	r0,r0[0x0]
80006f6a:	6e cc       	ld.w	r12,r7[0x30]
80006f6c:	80 00       	ld.sh	r0,r0[0x0]
80006f6e:	6d cc       	ld.w	r12,r6[0x70]
80006f70:	80 00       	ld.sh	r0,r0[0x0]
80006f72:	77 6c       	ld.w	r12,r11[0x58]
80006f74:	80 00       	ld.sh	r0,r0[0x0]
80006f76:	6e d8       	ld.w	r8,r7[0x34]
80006f78:	80 00       	ld.sh	r0,r0[0x0]
80006f7a:	75 68       	ld.w	r8,r10[0x58]

80006f7c <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80006f7c:	d4 01       	pushm	lr
	vTaskSuspendAll();
80006f7e:	f0 1f 00 02 	mcall	80006f84 <__malloc_lock+0x8>
}
80006f82:	d8 02       	popm	pc
80006f84:	80 00       	ld.sh	r0,r0[0x0]
80006f86:	75 58       	ld.w	r8,r10[0x54]

80006f88 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80006f88:	d4 01       	pushm	lr
	xTaskResumeAll();
80006f8a:	f0 1f 00 02 	mcall	80006f90 <__malloc_unlock+0x8>
}
80006f8e:	d8 02       	popm	pc
80006f90:	80 00       	ld.sh	r0,r0[0x0]
80006f92:	79 14       	ld.w	r4,r12[0x44]

80006f94 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80006f94:	d4 21       	pushm	r4-r7,lr
80006f96:	16 95       	mov	r5,r11
80006f98:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80006f9a:	58 0c       	cp.w	r12,0
80006f9c:	c0 30       	breq	80006fa2 <_read+0xe>
80006f9e:	3f f7       	mov	r7,-1
80006fa0:	c1 48       	rjmp	80006fc8 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80006fa2:	58 0a       	cp.w	r10,0
80006fa4:	e0 89 00 04 	brgt	80006fac <_read+0x18>
80006fa8:	30 07       	mov	r7,0
80006faa:	c0 f8       	rjmp	80006fc8 <_read+0x34>
80006fac:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80006fae:	48 84       	lddpc	r4,80006fcc <_read+0x38>
80006fb0:	68 0c       	ld.w	r12,r4[0x0]
80006fb2:	f0 1f 00 08 	mcall	80006fd0 <_read+0x3c>
    if (c < 0)
80006fb6:	c0 95       	brlt	80006fc8 <_read+0x34>
      break;

    *ptr++ = c;
80006fb8:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80006fbc:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80006fbe:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80006fc2:	58 08       	cp.w	r8,0
80006fc4:	fe 99 ff f6 	brgt	80006fb0 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80006fc8:	0e 9c       	mov	r12,r7
80006fca:	d8 22       	popm	r4-r7,pc
80006fcc:	00 00       	add	r0,r0
80006fce:	bd 48       	asr	r8,0x1c
80006fd0:	80 00       	ld.sh	r0,r0[0x0]
80006fd2:	6b 20       	ld.w	r0,r5[0x48]

80006fd4 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80006fd4:	d4 21       	pushm	r4-r7,lr
80006fd6:	16 95       	mov	r5,r11
80006fd8:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80006fda:	20 1c       	sub	r12,1
80006fdc:	58 2c       	cp.w	r12,2
80006fde:	e0 8b 00 12 	brhi	80007002 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006fe2:	58 0a       	cp.w	r10,0
80006fe4:	c0 31       	brne	80006fea <_write+0x16>
80006fe6:	30 07       	mov	r7,0
80006fe8:	c0 e8       	rjmp	80007004 <_write+0x30>
80006fea:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80006fec:	48 74       	lddpc	r4,80007008 <_write+0x34>
80006fee:	68 0c       	ld.w	r12,r4[0x0]
80006ff0:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80006ff4:	f0 1f 00 06 	mcall	8000700c <_write+0x38>
80006ff8:	c0 55       	brlt	80007002 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80006ffa:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006ffc:	0e 36       	cp.w	r6,r7
80006ffe:	cf 81       	brne	80006fee <_write+0x1a>
80007000:	c0 28       	rjmp	80007004 <_write+0x30>
80007002:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80007004:	0e 9c       	mov	r12,r7
80007006:	d8 22       	popm	r4-r7,pc
80007008:	00 00       	add	r0,r0
8000700a:	bd 48       	asr	r8,0x1c
8000700c:	80 00       	ld.sh	r0,r0[0x0]
8000700e:	6a d0       	ld.w	r0,r5[0x34]

80007010 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80007010:	eb cd 40 80 	pushm	r7,lr
80007014:	18 97       	mov	r7,r12
	if( pv )
80007016:	58 0c       	cp.w	r12,0
80007018:	c0 80       	breq	80007028 <vPortFree+0x18>
	{
		vTaskSuspendAll();
8000701a:	f0 1f 00 05 	mcall	8000702c <vPortFree+0x1c>
		{
			free( pv );
8000701e:	0e 9c       	mov	r12,r7
80007020:	f0 1f 00 04 	mcall	80007030 <vPortFree+0x20>
		}
		xTaskResumeAll();
80007024:	f0 1f 00 04 	mcall	80007034 <vPortFree+0x24>
80007028:	e3 cd 80 80 	ldm	sp++,r7,pc
8000702c:	80 00       	ld.sh	r0,r0[0x0]
8000702e:	75 58       	ld.w	r8,r10[0x54]
80007030:	80 00       	ld.sh	r0,r0[0x0]
80007032:	83 f0       	st.w	r1[0x3c],r0
80007034:	80 00       	ld.sh	r0,r0[0x0]
80007036:	79 14       	ld.w	r4,r12[0x44]

80007038 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80007038:	eb cd 40 80 	pushm	r7,lr
8000703c:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
8000703e:	f0 1f 00 06 	mcall	80007054 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80007042:	0e 9c       	mov	r12,r7
80007044:	f0 1f 00 05 	mcall	80007058 <pvPortMalloc+0x20>
80007048:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
8000704a:	f0 1f 00 05 	mcall	8000705c <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
8000704e:	0e 9c       	mov	r12,r7
80007050:	e3 cd 80 80 	ldm	sp++,r7,pc
80007054:	80 00       	ld.sh	r0,r0[0x0]
80007056:	75 58       	ld.w	r8,r10[0x54]
80007058:	80 00       	ld.sh	r0,r0[0x0]
8000705a:	84 00       	ld.sh	r0,r2[0x0]
8000705c:	80 00       	ld.sh	r0,r0[0x0]
8000705e:	79 14       	ld.w	r4,r12[0x44]

80007060 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80007060:	d4 01       	pushm	lr
80007062:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80007064:	78 09       	ld.w	r9,r12[0x0]
80007066:	58 09       	cp.w	r9,0
80007068:	c1 10       	breq	8000708a <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
8000706a:	78 3a       	ld.w	r10,r12[0xc]
8000706c:	79 09       	ld.w	r9,r12[0x40]
8000706e:	f4 09 00 09 	add	r9,r10,r9
80007072:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80007074:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80007076:	14 39       	cp.w	r9,r10
80007078:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
8000707c:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80007080:	79 0a       	ld.w	r10,r12[0x40]
80007082:	78 3b       	ld.w	r11,r12[0xc]
80007084:	10 9c       	mov	r12,r8
80007086:	f0 1f 00 02 	mcall	8000708c <prvCopyDataFromQueue+0x2c>
8000708a:	d8 02       	popm	pc
8000708c:	80 00       	ld.sh	r0,r0[0x0]
8000708e:	88 6e       	ld.sh	lr,r4[0xc]

80007090 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80007090:	eb cd 40 c0 	pushm	r6-r7,lr
80007094:	18 97       	mov	r7,r12
80007096:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80007098:	78 e8       	ld.w	r8,r12[0x38]
8000709a:	58 08       	cp.w	r8,0
8000709c:	c0 31       	brne	800070a2 <xQueueReceiveFromISR+0x12>
8000709e:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
800070a2:	f0 1f 00 0e 	mcall	800070d8 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
800070a6:	6e e8       	ld.w	r8,r7[0x38]
800070a8:	20 18       	sub	r8,1
800070aa:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
800070ac:	6f 18       	ld.w	r8,r7[0x44]
800070ae:	5b f8       	cp.w	r8,-1
800070b0:	c0 d1       	brne	800070ca <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800070b2:	6e 48       	ld.w	r8,r7[0x10]
800070b4:	58 08       	cp.w	r8,0
800070b6:	c0 f0       	breq	800070d4 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800070b8:	ee cc ff f0 	sub	r12,r7,-16
800070bc:	f0 1f 00 08 	mcall	800070dc <xQueueReceiveFromISR+0x4c>
800070c0:	c0 a0       	breq	800070d4 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
800070c2:	30 1c       	mov	r12,1
800070c4:	8d 0c       	st.w	r6[0x0],r12
800070c6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
800070ca:	2f f8       	sub	r8,-1
800070cc:	ef 48 00 44 	st.w	r7[68],r8
800070d0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800070d4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800070d8:	80 00       	ld.sh	r0,r0[0x0]
800070da:	70 60       	ld.w	r0,r8[0x18]
800070dc:	80 00       	ld.sh	r0,r0[0x0]
800070de:	76 f0       	ld.w	r0,r11[0x3c]

800070e0 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
800070e0:	eb cd 40 c0 	pushm	r6-r7,lr
800070e4:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
800070e6:	f0 1f 00 23 	mcall	80007170 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800070ea:	6f 28       	ld.w	r8,r7[0x48]
800070ec:	58 08       	cp.w	r8,0
800070ee:	e0 8a 00 18 	brle	8000711e <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800070f2:	6e 98       	ld.w	r8,r7[0x24]
800070f4:	58 08       	cp.w	r8,0
800070f6:	c1 40       	breq	8000711e <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800070f8:	ee c6 ff dc 	sub	r6,r7,-36
800070fc:	c0 48       	rjmp	80007104 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800070fe:	6e 98       	ld.w	r8,r7[0x24]
80007100:	58 08       	cp.w	r8,0
80007102:	c0 e0       	breq	8000711e <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80007104:	0c 9c       	mov	r12,r6
80007106:	f0 1f 00 1c 	mcall	80007174 <prvUnlockQueue+0x94>
8000710a:	c0 30       	breq	80007110 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
8000710c:	f0 1f 00 1b 	mcall	80007178 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80007110:	6f 28       	ld.w	r8,r7[0x48]
80007112:	20 18       	sub	r8,1
80007114:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80007118:	58 08       	cp.w	r8,0
8000711a:	fe 99 ff f2 	brgt	800070fe <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
8000711e:	3f f8       	mov	r8,-1
80007120:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80007124:	f0 1f 00 16 	mcall	8000717c <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80007128:	f0 1f 00 12 	mcall	80007170 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000712c:	6f 18       	ld.w	r8,r7[0x44]
8000712e:	58 08       	cp.w	r8,0
80007130:	e0 8a 00 18 	brle	80007160 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80007134:	6e 48       	ld.w	r8,r7[0x10]
80007136:	58 08       	cp.w	r8,0
80007138:	c1 40       	breq	80007160 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000713a:	ee c6 ff f0 	sub	r6,r7,-16
8000713e:	c0 48       	rjmp	80007146 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80007140:	6e 48       	ld.w	r8,r7[0x10]
80007142:	58 08       	cp.w	r8,0
80007144:	c0 e0       	breq	80007160 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80007146:	0c 9c       	mov	r12,r6
80007148:	f0 1f 00 0b 	mcall	80007174 <prvUnlockQueue+0x94>
8000714c:	c0 30       	breq	80007152 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
8000714e:	f0 1f 00 0b 	mcall	80007178 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80007152:	6f 18       	ld.w	r8,r7[0x44]
80007154:	20 18       	sub	r8,1
80007156:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000715a:	58 08       	cp.w	r8,0
8000715c:	fe 99 ff f2 	brgt	80007140 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80007160:	3f f8       	mov	r8,-1
80007162:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80007166:	f0 1f 00 06 	mcall	8000717c <prvUnlockQueue+0x9c>
}
8000716a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000716e:	00 00       	add	r0,r0
80007170:	80 00       	ld.sh	r0,r0[0x0]
80007172:	6d cc       	ld.w	r12,r6[0x70]
80007174:	80 00       	ld.sh	r0,r0[0x0]
80007176:	76 f0       	ld.w	r0,r11[0x3c]
80007178:	80 00       	ld.sh	r0,r0[0x0]
8000717a:	75 fc       	ld.w	r12,r10[0x7c]
8000717c:	80 00       	ld.sh	r0,r0[0x0]
8000717e:	6e d8       	ld.w	r8,r7[0x34]

80007180 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80007180:	d4 31       	pushm	r0-r7,lr
80007182:	20 5d       	sub	sp,20
80007184:	18 97       	mov	r7,r12
80007186:	50 0b       	stdsp	sp[0x0],r11
80007188:	50 2a       	stdsp	sp[0x8],r10
8000718a:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
8000718c:	f8 c2 ff dc 	sub	r2,r12,-36
80007190:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80007192:	fa c4 ff f4 	sub	r4,sp,-12
80007196:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80007198:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000719a:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
8000719e:	f0 1f 00 3e 	mcall	80007294 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800071a2:	6e e8       	ld.w	r8,r7[0x38]
800071a4:	58 08       	cp.w	r8,0
800071a6:	c2 a0       	breq	800071fa <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800071a8:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800071aa:	40 0b       	lddsp	r11,sp[0x0]
800071ac:	0e 9c       	mov	r12,r7
800071ae:	f0 1f 00 3b 	mcall	80007298 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
800071b2:	40 18       	lddsp	r8,sp[0x4]
800071b4:	58 08       	cp.w	r8,0
800071b6:	c1 51       	brne	800071e0 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800071b8:	6e e8       	ld.w	r8,r7[0x38]
800071ba:	20 18       	sub	r8,1
800071bc:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800071be:	6e 08       	ld.w	r8,r7[0x0]
800071c0:	58 08       	cp.w	r8,0
800071c2:	c0 41       	brne	800071ca <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
800071c4:	f0 1f 00 36 	mcall	8000729c <xQueueGenericReceive+0x11c>
800071c8:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800071ca:	6e 48       	ld.w	r8,r7[0x10]
800071cc:	58 08       	cp.w	r8,0
800071ce:	c1 20       	breq	800071f2 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800071d0:	ee cc ff f0 	sub	r12,r7,-16
800071d4:	f0 1f 00 33 	mcall	800072a0 <xQueueGenericReceive+0x120>
800071d8:	58 1c       	cp.w	r12,1
800071da:	c0 c1       	brne	800071f2 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
800071dc:	d7 33       	scall
800071de:	c0 a8       	rjmp	800071f2 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800071e0:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800071e2:	6e 98       	ld.w	r8,r7[0x24]
800071e4:	58 08       	cp.w	r8,0
800071e6:	c0 60       	breq	800071f2 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800071e8:	04 9c       	mov	r12,r2
800071ea:	f0 1f 00 2e 	mcall	800072a0 <xQueueGenericReceive+0x120>
800071ee:	c0 20       	breq	800071f2 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
800071f0:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
800071f2:	f0 1f 00 2d 	mcall	800072a4 <xQueueGenericReceive+0x124>
800071f6:	30 1c       	mov	r12,1
				return pdPASS;
800071f8:	c4 c8       	rjmp	80007290 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800071fa:	40 28       	lddsp	r8,sp[0x8]
800071fc:	58 08       	cp.w	r8,0
800071fe:	c0 51       	brne	80007208 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80007200:	f0 1f 00 29 	mcall	800072a4 <xQueueGenericReceive+0x124>
80007204:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80007206:	c4 58       	rjmp	80007290 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80007208:	58 05       	cp.w	r5,0
8000720a:	c0 51       	brne	80007214 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000720c:	08 9c       	mov	r12,r4
8000720e:	f0 1f 00 27 	mcall	800072a8 <xQueueGenericReceive+0x128>
80007212:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80007214:	f0 1f 00 24 	mcall	800072a4 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80007218:	f0 1f 00 25 	mcall	800072ac <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
8000721c:	f0 1f 00 1e 	mcall	80007294 <xQueueGenericReceive+0x114>
80007220:	6f 18       	ld.w	r8,r7[0x44]
80007222:	5b f8       	cp.w	r8,-1
80007224:	ef f1 0a 11 	st.weq	r7[0x44],r1
80007228:	6f 28       	ld.w	r8,r7[0x48]
8000722a:	5b f8       	cp.w	r8,-1
8000722c:	ef f1 0a 12 	st.weq	r7[0x48],r1
80007230:	f0 1f 00 1d 	mcall	800072a4 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80007234:	06 9b       	mov	r11,r3
80007236:	08 9c       	mov	r12,r4
80007238:	f0 1f 00 1e 	mcall	800072b0 <xQueueGenericReceive+0x130>
8000723c:	c2 41       	brne	80007284 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000723e:	f0 1f 00 16 	mcall	80007294 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80007242:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80007244:	f0 1f 00 18 	mcall	800072a4 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80007248:	58 06       	cp.w	r6,0
8000724a:	c1 71       	brne	80007278 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000724c:	6e 08       	ld.w	r8,r7[0x0]
8000724e:	58 08       	cp.w	r8,0
80007250:	c0 81       	brne	80007260 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80007252:	f0 1f 00 11 	mcall	80007294 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80007256:	6e 1c       	ld.w	r12,r7[0x4]
80007258:	f0 1f 00 17 	mcall	800072b4 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
8000725c:	f0 1f 00 12 	mcall	800072a4 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80007260:	40 2b       	lddsp	r11,sp[0x8]
80007262:	04 9c       	mov	r12,r2
80007264:	f0 1f 00 15 	mcall	800072b8 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80007268:	0e 9c       	mov	r12,r7
8000726a:	f0 1f 00 15 	mcall	800072bc <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
8000726e:	f0 1f 00 15 	mcall	800072c0 <xQueueGenericReceive+0x140>
80007272:	c9 61       	brne	8000719e <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80007274:	d7 33       	scall
80007276:	c9 4b       	rjmp	8000719e <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80007278:	0e 9c       	mov	r12,r7
8000727a:	f0 1f 00 11 	mcall	800072bc <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
8000727e:	f0 1f 00 11 	mcall	800072c0 <xQueueGenericReceive+0x140>
80007282:	c8 eb       	rjmp	8000719e <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80007284:	0e 9c       	mov	r12,r7
80007286:	f0 1f 00 0e 	mcall	800072bc <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000728a:	f0 1f 00 0e 	mcall	800072c0 <xQueueGenericReceive+0x140>
8000728e:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80007290:	2f bd       	sub	sp,-20
80007292:	d8 32       	popm	r0-r7,pc
80007294:	80 00       	ld.sh	r0,r0[0x0]
80007296:	6d cc       	ld.w	r12,r6[0x70]
80007298:	80 00       	ld.sh	r0,r0[0x0]
8000729a:	70 60       	ld.w	r0,r8[0x18]
8000729c:	80 00       	ld.sh	r0,r0[0x0]
8000729e:	76 08       	ld.w	r8,r11[0x0]
800072a0:	80 00       	ld.sh	r0,r0[0x0]
800072a2:	76 f0       	ld.w	r0,r11[0x3c]
800072a4:	80 00       	ld.sh	r0,r0[0x0]
800072a6:	6e d8       	ld.w	r8,r7[0x34]
800072a8:	80 00       	ld.sh	r0,r0[0x0]
800072aa:	75 e4       	ld.w	r4,r10[0x78]
800072ac:	80 00       	ld.sh	r0,r0[0x0]
800072ae:	75 58       	ld.w	r8,r10[0x54]
800072b0:	80 00       	ld.sh	r0,r0[0x0]
800072b2:	78 80       	ld.w	r0,r12[0x20]
800072b4:	80 00       	ld.sh	r0,r0[0x0]
800072b6:	76 6c       	ld.w	r12,r11[0x18]
800072b8:	80 00       	ld.sh	r0,r0[0x0]
800072ba:	7b 20       	ld.w	r0,sp[0x48]
800072bc:	80 00       	ld.sh	r0,r0[0x0]
800072be:	70 e0       	ld.w	r0,r8[0x38]
800072c0:	80 00       	ld.sh	r0,r0[0x0]
800072c2:	79 14       	ld.w	r4,r12[0x44]

800072c4 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
800072c4:	eb cd 40 80 	pushm	r7,lr
800072c8:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
800072ca:	79 08       	ld.w	r8,r12[0x40]
800072cc:	58 08       	cp.w	r8,0
800072ce:	c0 a1       	brne	800072e2 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800072d0:	78 08       	ld.w	r8,r12[0x0]
800072d2:	58 08       	cp.w	r8,0
800072d4:	c2 b1       	brne	8000732a <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
800072d6:	78 1c       	ld.w	r12,r12[0x4]
800072d8:	f0 1f 00 17 	mcall	80007334 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
800072dc:	30 08       	mov	r8,0
800072de:	8f 18       	st.w	r7[0x4],r8
800072e0:	c2 58       	rjmp	8000732a <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
800072e2:	58 0a       	cp.w	r10,0
800072e4:	c1 01       	brne	80007304 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800072e6:	10 9a       	mov	r10,r8
800072e8:	78 2c       	ld.w	r12,r12[0x8]
800072ea:	f0 1f 00 14 	mcall	80007338 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
800072ee:	6e 29       	ld.w	r9,r7[0x8]
800072f0:	6f 08       	ld.w	r8,r7[0x40]
800072f2:	f2 08 00 08 	add	r8,r9,r8
800072f6:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
800072f8:	6e 19       	ld.w	r9,r7[0x4]
800072fa:	12 38       	cp.w	r8,r9
800072fc:	c1 73       	brcs	8000732a <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
800072fe:	6e 08       	ld.w	r8,r7[0x0]
80007300:	8f 28       	st.w	r7[0x8],r8
80007302:	c1 48       	rjmp	8000732a <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80007304:	10 9a       	mov	r10,r8
80007306:	78 3c       	ld.w	r12,r12[0xc]
80007308:	f0 1f 00 0c 	mcall	80007338 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
8000730c:	6f 08       	ld.w	r8,r7[0x40]
8000730e:	6e 39       	ld.w	r9,r7[0xc]
80007310:	f2 08 01 08 	sub	r8,r9,r8
80007314:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80007316:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80007318:	12 38       	cp.w	r8,r9
8000731a:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
8000731e:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80007322:	f3 d8 e3 19 	subcs	r9,r9,r8
80007326:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
8000732a:	6e e8       	ld.w	r8,r7[0x38]
8000732c:	2f f8       	sub	r8,-1
8000732e:	8f e8       	st.w	r7[0x38],r8
}
80007330:	e3 cd 80 80 	ldm	sp++,r7,pc
80007334:	80 00       	ld.sh	r0,r0[0x0]
80007336:	76 14       	ld.w	r4,r11[0x4]
80007338:	80 00       	ld.sh	r0,r0[0x0]
8000733a:	88 6e       	ld.sh	lr,r4[0xc]

8000733c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
8000733c:	eb cd 40 c0 	pushm	r6-r7,lr
80007340:	18 97       	mov	r7,r12
80007342:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80007344:	78 ec       	ld.w	r12,r12[0x38]
80007346:	6e f8       	ld.w	r8,r7[0x3c]
80007348:	10 3c       	cp.w	r12,r8
8000734a:	c0 33       	brcs	80007350 <xQueueGenericSendFromISR+0x14>
8000734c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80007350:	12 9a       	mov	r10,r9
80007352:	0e 9c       	mov	r12,r7
80007354:	f0 1f 00 0c 	mcall	80007384 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80007358:	6f 28       	ld.w	r8,r7[0x48]
8000735a:	5b f8       	cp.w	r8,-1
8000735c:	c0 d1       	brne	80007376 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000735e:	6e 98       	ld.w	r8,r7[0x24]
80007360:	58 08       	cp.w	r8,0
80007362:	c0 f0       	breq	80007380 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80007364:	ee cc ff dc 	sub	r12,r7,-36
80007368:	f0 1f 00 08 	mcall	80007388 <xQueueGenericSendFromISR+0x4c>
8000736c:	c0 a0       	breq	80007380 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
8000736e:	30 1c       	mov	r12,1
80007370:	8d 0c       	st.w	r6[0x0],r12
80007372:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80007376:	2f f8       	sub	r8,-1
80007378:	ef 48 00 48 	st.w	r7[72],r8
8000737c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80007380:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80007384:	80 00       	ld.sh	r0,r0[0x0]
80007386:	72 c4       	ld.w	r4,r9[0x30]
80007388:	80 00       	ld.sh	r0,r0[0x0]
8000738a:	76 f0       	ld.w	r0,r11[0x3c]

8000738c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
8000738c:	d4 31       	pushm	r0-r7,lr
8000738e:	20 5d       	sub	sp,20
80007390:	18 97       	mov	r7,r12
80007392:	50 0b       	stdsp	sp[0x0],r11
80007394:	50 2a       	stdsp	sp[0x8],r10
80007396:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80007398:	f8 c0 ff f0 	sub	r0,r12,-16
8000739c:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000739e:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800073a2:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800073a4:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
800073a8:	f0 1f 00 2f 	mcall	80007464 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800073ac:	6e e9       	ld.w	r9,r7[0x38]
800073ae:	6e f8       	ld.w	r8,r7[0x3c]
800073b0:	10 39       	cp.w	r9,r8
800073b2:	c1 42       	brcc	800073da <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800073b4:	40 1a       	lddsp	r10,sp[0x4]
800073b6:	40 0b       	lddsp	r11,sp[0x0]
800073b8:	0e 9c       	mov	r12,r7
800073ba:	f0 1f 00 2c 	mcall	80007468 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800073be:	6e 98       	ld.w	r8,r7[0x24]
800073c0:	58 08       	cp.w	r8,0
800073c2:	c0 80       	breq	800073d2 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
800073c4:	ee cc ff dc 	sub	r12,r7,-36
800073c8:	f0 1f 00 29 	mcall	8000746c <xQueueGenericSend+0xe0>
800073cc:	58 1c       	cp.w	r12,1
800073ce:	c0 21       	brne	800073d2 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
800073d0:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
800073d2:	f0 1f 00 28 	mcall	80007470 <xQueueGenericSend+0xe4>
800073d6:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
800073d8:	c4 38       	rjmp	8000745e <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800073da:	40 28       	lddsp	r8,sp[0x8]
800073dc:	58 08       	cp.w	r8,0
800073de:	c0 51       	brne	800073e8 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800073e0:	f0 1f 00 24 	mcall	80007470 <xQueueGenericSend+0xe4>
800073e4:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800073e6:	c3 c8       	rjmp	8000745e <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
800073e8:	58 04       	cp.w	r4,0
800073ea:	c0 51       	brne	800073f4 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800073ec:	06 9c       	mov	r12,r3
800073ee:	f0 1f 00 22 	mcall	80007474 <xQueueGenericSend+0xe8>
800073f2:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800073f4:	f0 1f 00 1f 	mcall	80007470 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800073f8:	f0 1f 00 20 	mcall	80007478 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
800073fc:	f0 1f 00 1a 	mcall	80007464 <xQueueGenericSend+0xd8>
80007400:	6f 18       	ld.w	r8,r7[0x44]
80007402:	5b f8       	cp.w	r8,-1
80007404:	ef f1 0a 11 	st.weq	r7[0x44],r1
80007408:	6f 28       	ld.w	r8,r7[0x48]
8000740a:	5b f8       	cp.w	r8,-1
8000740c:	ef f1 0a 12 	st.weq	r7[0x48],r1
80007410:	f0 1f 00 18 	mcall	80007470 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80007414:	04 9b       	mov	r11,r2
80007416:	06 9c       	mov	r12,r3
80007418:	f0 1f 00 19 	mcall	8000747c <xQueueGenericSend+0xf0>
8000741c:	c1 b1       	brne	80007452 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000741e:	f0 1f 00 12 	mcall	80007464 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80007422:	6e e5       	ld.w	r5,r7[0x38]
80007424:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80007426:	f0 1f 00 13 	mcall	80007470 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
8000742a:	0c 35       	cp.w	r5,r6
8000742c:	c0 d1       	brne	80007446 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000742e:	40 2b       	lddsp	r11,sp[0x8]
80007430:	00 9c       	mov	r12,r0
80007432:	f0 1f 00 14 	mcall	80007480 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80007436:	0e 9c       	mov	r12,r7
80007438:	f0 1f 00 13 	mcall	80007484 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
8000743c:	f0 1f 00 13 	mcall	80007488 <xQueueGenericSend+0xfc>
80007440:	cb 41       	brne	800073a8 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80007442:	d7 33       	scall
80007444:	cb 2b       	rjmp	800073a8 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80007446:	0e 9c       	mov	r12,r7
80007448:	f0 1f 00 0f 	mcall	80007484 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
8000744c:	f0 1f 00 0f 	mcall	80007488 <xQueueGenericSend+0xfc>
80007450:	ca cb       	rjmp	800073a8 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80007452:	0e 9c       	mov	r12,r7
80007454:	f0 1f 00 0c 	mcall	80007484 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80007458:	f0 1f 00 0c 	mcall	80007488 <xQueueGenericSend+0xfc>
8000745c:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
8000745e:	2f bd       	sub	sp,-20
80007460:	d8 32       	popm	r0-r7,pc
80007462:	00 00       	add	r0,r0
80007464:	80 00       	ld.sh	r0,r0[0x0]
80007466:	6d cc       	ld.w	r12,r6[0x70]
80007468:	80 00       	ld.sh	r0,r0[0x0]
8000746a:	72 c4       	ld.w	r4,r9[0x30]
8000746c:	80 00       	ld.sh	r0,r0[0x0]
8000746e:	76 f0       	ld.w	r0,r11[0x3c]
80007470:	80 00       	ld.sh	r0,r0[0x0]
80007472:	6e d8       	ld.w	r8,r7[0x34]
80007474:	80 00       	ld.sh	r0,r0[0x0]
80007476:	75 e4       	ld.w	r4,r10[0x78]
80007478:	80 00       	ld.sh	r0,r0[0x0]
8000747a:	75 58       	ld.w	r8,r10[0x54]
8000747c:	80 00       	ld.sh	r0,r0[0x0]
8000747e:	78 80       	ld.w	r0,r12[0x20]
80007480:	80 00       	ld.sh	r0,r0[0x0]
80007482:	7b 20       	ld.w	r0,sp[0x48]
80007484:	80 00       	ld.sh	r0,r0[0x0]
80007486:	70 e0       	ld.w	r0,r8[0x38]
80007488:	80 00       	ld.sh	r0,r0[0x0]
8000748a:	79 14       	ld.w	r4,r12[0x44]

8000748c <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
8000748c:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80007490:	34 cc       	mov	r12,76
80007492:	f0 1f 00 12 	mcall	800074d8 <xQueueCreateMutex+0x4c>
80007496:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
80007498:	c1 d0       	breq	800074d2 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
8000749a:	30 06       	mov	r6,0
8000749c:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
8000749e:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
800074a0:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
800074a2:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800074a4:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
800074a6:	30 18       	mov	r8,1
800074a8:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
800074aa:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
800074ae:	3f f8       	mov	r8,-1
800074b0:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
800074b4:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800074b8:	2f 0c       	sub	r12,-16
800074ba:	f0 1f 00 09 	mcall	800074dc <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800074be:	ee cc ff dc 	sub	r12,r7,-36
800074c2:	f0 1f 00 07 	mcall	800074dc <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
800074c6:	0c 99       	mov	r9,r6
800074c8:	0c 9a       	mov	r10,r6
800074ca:	0c 9b       	mov	r11,r6
800074cc:	0e 9c       	mov	r12,r7
800074ce:	f0 1f 00 05 	mcall	800074e0 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
800074d2:	0e 9c       	mov	r12,r7
800074d4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800074d8:	80 00       	ld.sh	r0,r0[0x0]
800074da:	70 38       	ld.w	r8,r8[0xc]
800074dc:	80 00       	ld.sh	r0,r0[0x0]
800074de:	6c a8       	ld.w	r8,r6[0x28]
800074e0:	80 00       	ld.sh	r0,r0[0x0]
800074e2:	73 8c       	ld.w	r12,r9[0x60]

800074e4 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800074e4:	d4 21       	pushm	r4-r7,lr
800074e6:	18 97       	mov	r7,r12
800074e8:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800074ea:	58 0c       	cp.w	r12,0
800074ec:	c2 f0       	breq	8000754a <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800074ee:	34 cc       	mov	r12,76
800074f0:	f0 1f 00 17 	mcall	8000754c <xQueueCreate+0x68>
800074f4:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
800074f6:	c2 a0       	breq	8000754a <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
800074f8:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
800074fc:	e8 cc ff ff 	sub	r12,r4,-1
80007500:	f0 1f 00 13 	mcall	8000754c <xQueueCreate+0x68>
80007504:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80007506:	c1 e0       	breq	80007542 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80007508:	f8 04 00 04 	add	r4,r12,r4
8000750c:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
8000750e:	30 08       	mov	r8,0
80007510:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80007512:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80007514:	ee c8 00 01 	sub	r8,r7,1
80007518:	ad 38       	mul	r8,r6
8000751a:	10 0c       	add	r12,r8
8000751c:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
8000751e:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80007520:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80007524:	3f f8       	mov	r8,-1
80007526:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
8000752a:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000752e:	ea cc ff f0 	sub	r12,r5,-16
80007532:	f0 1f 00 08 	mcall	80007550 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80007536:	ea cc ff dc 	sub	r12,r5,-36
8000753a:	f0 1f 00 06 	mcall	80007550 <xQueueCreate+0x6c>
8000753e:	0a 9c       	mov	r12,r5
80007540:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80007542:	0a 9c       	mov	r12,r5
80007544:	f0 1f 00 04 	mcall	80007554 <xQueueCreate+0x70>
80007548:	d8 2a       	popm	r4-r7,pc,r12=0
8000754a:	d8 2a       	popm	r4-r7,pc,r12=0
8000754c:	80 00       	ld.sh	r0,r0[0x0]
8000754e:	70 38       	ld.w	r8,r8[0xc]
80007550:	80 00       	ld.sh	r0,r0[0x0]
80007552:	6c a8       	ld.w	r8,r6[0x28]
80007554:	80 00       	ld.sh	r0,r0[0x0]
80007556:	70 10       	ld.w	r0,r8[0x4]

80007558 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80007558:	48 38       	lddpc	r8,80007564 <vTaskSuspendAll+0xc>
8000755a:	70 09       	ld.w	r9,r8[0x0]
8000755c:	2f f9       	sub	r9,-1
8000755e:	91 09       	st.w	r8[0x0],r9
}
80007560:	5e fc       	retal	r12
80007562:	00 00       	add	r0,r0
80007564:	00 00       	add	r0,r0
80007566:	0d a0       	ld.ub	r0,r6[0x2]

80007568 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80007568:	49 a8       	lddpc	r8,800075d0 <vTaskSwitchContext+0x68>
8000756a:	70 08       	ld.w	r8,r8[0x0]
8000756c:	58 08       	cp.w	r8,0
8000756e:	c0 b1       	brne	80007584 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80007570:	49 98       	lddpc	r8,800075d4 <vTaskSwitchContext+0x6c>
80007572:	70 08       	ld.w	r8,r8[0x0]
80007574:	f0 08 00 28 	add	r8,r8,r8<<0x2
80007578:	49 89       	lddpc	r9,800075d8 <vTaskSwitchContext+0x70>
8000757a:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
8000757e:	58 08       	cp.w	r8,0
80007580:	c0 60       	breq	8000758c <vTaskSwitchContext+0x24>
80007582:	c1 18       	rjmp	800075a4 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80007584:	30 19       	mov	r9,1
80007586:	49 68       	lddpc	r8,800075dc <vTaskSwitchContext+0x74>
80007588:	91 09       	st.w	r8[0x0],r9
8000758a:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
8000758c:	49 28       	lddpc	r8,800075d4 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000758e:	49 3a       	lddpc	r10,800075d8 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80007590:	70 09       	ld.w	r9,r8[0x0]
80007592:	20 19       	sub	r9,1
80007594:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80007596:	70 09       	ld.w	r9,r8[0x0]
80007598:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000759c:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800075a0:	58 09       	cp.w	r9,0
800075a2:	cf 70       	breq	80007590 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800075a4:	48 c8       	lddpc	r8,800075d4 <vTaskSwitchContext+0x6c>
800075a6:	70 08       	ld.w	r8,r8[0x0]
800075a8:	f0 08 00 28 	add	r8,r8,r8<<0x2
800075ac:	48 b9       	lddpc	r9,800075d8 <vTaskSwitchContext+0x70>
800075ae:	f2 08 00 28 	add	r8,r9,r8<<0x2
800075b2:	70 19       	ld.w	r9,r8[0x4]
800075b4:	72 19       	ld.w	r9,r9[0x4]
800075b6:	91 19       	st.w	r8[0x4],r9
800075b8:	f0 ca ff f8 	sub	r10,r8,-8
800075bc:	14 39       	cp.w	r9,r10
800075be:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800075c2:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800075c6:	70 18       	ld.w	r8,r8[0x4]
800075c8:	70 39       	ld.w	r9,r8[0xc]
800075ca:	48 68       	lddpc	r8,800075e0 <vTaskSwitchContext+0x78>
800075cc:	91 09       	st.w	r8[0x0],r9
800075ce:	5e fc       	retal	r12
800075d0:	00 00       	add	r0,r0
800075d2:	0d a0       	ld.ub	r0,r6[0x2]
800075d4:	00 00       	add	r0,r0
800075d6:	0d d8       	ld.ub	r8,r6[0x5]
800075d8:	00 00       	add	r0,r0
800075da:	0c bc       	st.h	r6++,r12
800075dc:	00 00       	add	r0,r0
800075de:	0d c0       	ld.ub	r0,r6[0x4]
800075e0:	00 00       	add	r0,r0
800075e2:	0d 70       	ld.ub	r0,--r6

800075e4 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800075e4:	48 48       	lddpc	r8,800075f4 <vTaskSetTimeOutState+0x10>
800075e6:	70 08       	ld.w	r8,r8[0x0]
800075e8:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
800075ea:	48 48       	lddpc	r8,800075f8 <vTaskSetTimeOutState+0x14>
800075ec:	70 08       	ld.w	r8,r8[0x0]
800075ee:	99 18       	st.w	r12[0x4],r8
}
800075f0:	5e fc       	retal	r12
800075f2:	00 00       	add	r0,r0
800075f4:	00 00       	add	r0,r0
800075f6:	0c b4       	st.h	r6++,r4
800075f8:	00 00       	add	r0,r0
800075fa:	0d 9c       	ld.ub	r12,r6[0x1]

800075fc <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
800075fc:	30 19       	mov	r9,1
800075fe:	48 28       	lddpc	r8,80007604 <vTaskMissedYield+0x8>
80007600:	91 09       	st.w	r8[0x0],r9
}
80007602:	5e fc       	retal	r12
80007604:	00 00       	add	r0,r0
80007606:	0d c0       	ld.ub	r0,r6[0x4]

80007608 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80007608:	48 28       	lddpc	r8,80007610 <xTaskGetCurrentTaskHandle+0x8>
8000760a:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
8000760c:	5e fc       	retal	r12
8000760e:	00 00       	add	r0,r0
80007610:	00 00       	add	r0,r0
80007612:	0d 70       	ld.ub	r0,--r6

80007614 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80007614:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80007618:	58 0c       	cp.w	r12,0
8000761a:	c1 f0       	breq	80007658 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
8000761c:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
8000761e:	78 b9       	ld.w	r9,r12[0x2c]
80007620:	79 18       	ld.w	r8,r12[0x44]
80007622:	10 39       	cp.w	r9,r8
80007624:	c1 a0       	breq	80007658 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80007626:	f8 c6 ff fc 	sub	r6,r12,-4
8000762a:	0c 9c       	mov	r12,r6
8000762c:	f0 1f 00 0c 	mcall	8000765c <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80007630:	6f 1c       	ld.w	r12,r7[0x44]
80007632:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80007634:	f8 08 11 08 	rsub	r8,r12,8
80007638:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
8000763a:	48 a8       	lddpc	r8,80007660 <vTaskPriorityDisinherit+0x4c>
8000763c:	70 08       	ld.w	r8,r8[0x0]
8000763e:	10 3c       	cp.w	r12,r8
80007640:	e0 88 00 04 	brls	80007648 <vTaskPriorityDisinherit+0x34>
80007644:	48 78       	lddpc	r8,80007660 <vTaskPriorityDisinherit+0x4c>
80007646:	91 0c       	st.w	r8[0x0],r12
80007648:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000764c:	0c 9b       	mov	r11,r6
8000764e:	48 68       	lddpc	r8,80007664 <vTaskPriorityDisinherit+0x50>
80007650:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007654:	f0 1f 00 05 	mcall	80007668 <vTaskPriorityDisinherit+0x54>
80007658:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000765c:	80 00       	ld.sh	r0,r0[0x0]
8000765e:	6d 12       	ld.w	r2,r6[0x44]
80007660:	00 00       	add	r0,r0
80007662:	0d d8       	ld.ub	r8,r6[0x5]
80007664:	00 00       	add	r0,r0
80007666:	0c bc       	st.h	r6++,r12
80007668:	80 00       	ld.sh	r0,r0[0x0]
8000766a:	6c c2       	ld.w	r2,r6[0x30]

8000766c <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
8000766c:	eb cd 40 c0 	pushm	r6-r7,lr
80007670:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80007672:	49 b8       	lddpc	r8,800076dc <vTaskPriorityInherit+0x70>
80007674:	70 08       	ld.w	r8,r8[0x0]
80007676:	78 b9       	ld.w	r9,r12[0x2c]
80007678:	70 b8       	ld.w	r8,r8[0x2c]
8000767a:	10 39       	cp.w	r9,r8
8000767c:	c2 d2       	brcc	800076d6 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
8000767e:	49 88       	lddpc	r8,800076dc <vTaskPriorityInherit+0x70>
80007680:	70 08       	ld.w	r8,r8[0x0]
80007682:	70 b8       	ld.w	r8,r8[0x2c]
80007684:	f0 08 11 08 	rsub	r8,r8,8
80007688:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
8000768a:	f2 09 00 28 	add	r8,r9,r9<<0x2
8000768e:	49 59       	lddpc	r9,800076e0 <vTaskPriorityInherit+0x74>
80007690:	f2 08 00 28 	add	r8,r9,r8<<0x2
80007694:	78 59       	ld.w	r9,r12[0x14]
80007696:	10 39       	cp.w	r9,r8
80007698:	c1 b1       	brne	800076ce <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
8000769a:	f8 c6 ff fc 	sub	r6,r12,-4
8000769e:	0c 9c       	mov	r12,r6
800076a0:	f0 1f 00 11 	mcall	800076e4 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800076a4:	48 e8       	lddpc	r8,800076dc <vTaskPriorityInherit+0x70>
800076a6:	70 08       	ld.w	r8,r8[0x0]
800076a8:	70 bc       	ld.w	r12,r8[0x2c]
800076aa:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800076ac:	48 f8       	lddpc	r8,800076e8 <vTaskPriorityInherit+0x7c>
800076ae:	70 08       	ld.w	r8,r8[0x0]
800076b0:	10 3c       	cp.w	r12,r8
800076b2:	e0 88 00 04 	brls	800076ba <vTaskPriorityInherit+0x4e>
800076b6:	48 d8       	lddpc	r8,800076e8 <vTaskPriorityInherit+0x7c>
800076b8:	91 0c       	st.w	r8[0x0],r12
800076ba:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800076be:	0c 9b       	mov	r11,r6
800076c0:	48 88       	lddpc	r8,800076e0 <vTaskPriorityInherit+0x74>
800076c2:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800076c6:	f0 1f 00 0a 	mcall	800076ec <vTaskPriorityInherit+0x80>
800076ca:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800076ce:	48 48       	lddpc	r8,800076dc <vTaskPriorityInherit+0x70>
800076d0:	70 08       	ld.w	r8,r8[0x0]
800076d2:	70 b8       	ld.w	r8,r8[0x2c]
800076d4:	99 b8       	st.w	r12[0x2c],r8
800076d6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800076da:	00 00       	add	r0,r0
800076dc:	00 00       	add	r0,r0
800076de:	0d 70       	ld.ub	r0,--r6
800076e0:	00 00       	add	r0,r0
800076e2:	0c bc       	st.h	r6++,r12
800076e4:	80 00       	ld.sh	r0,r0[0x0]
800076e6:	6d 12       	ld.w	r2,r6[0x44]
800076e8:	00 00       	add	r0,r0
800076ea:	0d d8       	ld.ub	r8,r6[0x5]
800076ec:	80 00       	ld.sh	r0,r0[0x0]
800076ee:	6c c2       	ld.w	r2,r6[0x30]

800076f0 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800076f0:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800076f4:	78 38       	ld.w	r8,r12[0xc]
800076f6:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800076f8:	ee c6 ff e8 	sub	r6,r7,-24
800076fc:	0c 9c       	mov	r12,r6
800076fe:	f0 1f 00 15 	mcall	80007750 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80007702:	49 58       	lddpc	r8,80007754 <xTaskRemoveFromEventList+0x64>
80007704:	70 08       	ld.w	r8,r8[0x0]
80007706:	58 08       	cp.w	r8,0
80007708:	c1 71       	brne	80007736 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
8000770a:	ee c6 ff fc 	sub	r6,r7,-4
8000770e:	0c 9c       	mov	r12,r6
80007710:	f0 1f 00 10 	mcall	80007750 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80007714:	6e bc       	ld.w	r12,r7[0x2c]
80007716:	49 18       	lddpc	r8,80007758 <xTaskRemoveFromEventList+0x68>
80007718:	70 08       	ld.w	r8,r8[0x0]
8000771a:	10 3c       	cp.w	r12,r8
8000771c:	e0 88 00 04 	brls	80007724 <xTaskRemoveFromEventList+0x34>
80007720:	48 e8       	lddpc	r8,80007758 <xTaskRemoveFromEventList+0x68>
80007722:	91 0c       	st.w	r8[0x0],r12
80007724:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007728:	0c 9b       	mov	r11,r6
8000772a:	48 d8       	lddpc	r8,8000775c <xTaskRemoveFromEventList+0x6c>
8000772c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007730:	f0 1f 00 0c 	mcall	80007760 <xTaskRemoveFromEventList+0x70>
80007734:	c0 58       	rjmp	8000773e <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80007736:	0c 9b       	mov	r11,r6
80007738:	48 bc       	lddpc	r12,80007764 <xTaskRemoveFromEventList+0x74>
8000773a:	f0 1f 00 0a 	mcall	80007760 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000773e:	48 b8       	lddpc	r8,80007768 <xTaskRemoveFromEventList+0x78>
80007740:	70 08       	ld.w	r8,r8[0x0]
80007742:	6e b9       	ld.w	r9,r7[0x2c]
80007744:	70 b8       	ld.w	r8,r8[0x2c]
80007746:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80007748:	5f 2c       	srhs	r12
8000774a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000774e:	00 00       	add	r0,r0
80007750:	80 00       	ld.sh	r0,r0[0x0]
80007752:	6d 12       	ld.w	r2,r6[0x44]
80007754:	00 00       	add	r0,r0
80007756:	0d a0       	ld.ub	r0,r6[0x2]
80007758:	00 00       	add	r0,r0
8000775a:	0d d8       	ld.ub	r8,r6[0x5]
8000775c:	00 00       	add	r0,r0
8000775e:	0c bc       	st.h	r6++,r12
80007760:	80 00       	ld.sh	r0,r0[0x0]
80007762:	6c c2       	ld.w	r2,r6[0x30]
80007764:	00 00       	add	r0,r0
80007766:	0d 74       	ld.ub	r4,--r6
80007768:	00 00       	add	r0,r0
8000776a:	0d 70       	ld.ub	r0,--r6

8000776c <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
8000776c:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80007770:	4b 98       	lddpc	r8,80007854 <vTaskIncrementTick+0xe8>
80007772:	70 08       	ld.w	r8,r8[0x0]
80007774:	58 08       	cp.w	r8,0
80007776:	c6 91       	brne	80007848 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80007778:	4b 88       	lddpc	r8,80007858 <vTaskIncrementTick+0xec>
8000777a:	70 09       	ld.w	r9,r8[0x0]
8000777c:	2f f9       	sub	r9,-1
8000777e:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80007780:	70 08       	ld.w	r8,r8[0x0]
80007782:	58 08       	cp.w	r8,0
80007784:	c1 a1       	brne	800077b8 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80007786:	4b 68       	lddpc	r8,8000785c <vTaskIncrementTick+0xf0>
80007788:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
8000778a:	4b 69       	lddpc	r9,80007860 <vTaskIncrementTick+0xf4>
8000778c:	72 0b       	ld.w	r11,r9[0x0]
8000778e:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80007790:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80007792:	4b 59       	lddpc	r9,80007864 <vTaskIncrementTick+0xf8>
80007794:	72 0a       	ld.w	r10,r9[0x0]
80007796:	2f fa       	sub	r10,-1
80007798:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
8000779a:	70 08       	ld.w	r8,r8[0x0]
8000779c:	70 08       	ld.w	r8,r8[0x0]
8000779e:	58 08       	cp.w	r8,0
800077a0:	c0 51       	brne	800077aa <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800077a2:	3f f9       	mov	r9,-1
800077a4:	4b 18       	lddpc	r8,80007868 <vTaskIncrementTick+0xfc>
800077a6:	91 09       	st.w	r8[0x0],r9
800077a8:	c0 88       	rjmp	800077b8 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800077aa:	4a d8       	lddpc	r8,8000785c <vTaskIncrementTick+0xf0>
800077ac:	70 08       	ld.w	r8,r8[0x0]
800077ae:	70 38       	ld.w	r8,r8[0xc]
800077b0:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800077b2:	70 19       	ld.w	r9,r8[0x4]
800077b4:	4a d8       	lddpc	r8,80007868 <vTaskIncrementTick+0xfc>
800077b6:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800077b8:	4a 88       	lddpc	r8,80007858 <vTaskIncrementTick+0xec>
800077ba:	70 09       	ld.w	r9,r8[0x0]
800077bc:	4a b8       	lddpc	r8,80007868 <vTaskIncrementTick+0xfc>
800077be:	70 08       	ld.w	r8,r8[0x0]
800077c0:	10 39       	cp.w	r9,r8
800077c2:	c4 73       	brcs	80007850 <vTaskIncrementTick+0xe4>
800077c4:	4a 68       	lddpc	r8,8000785c <vTaskIncrementTick+0xf0>
800077c6:	70 08       	ld.w	r8,r8[0x0]
800077c8:	70 08       	ld.w	r8,r8[0x0]
800077ca:	58 08       	cp.w	r8,0
800077cc:	c0 c0       	breq	800077e4 <vTaskIncrementTick+0x78>
800077ce:	4a 48       	lddpc	r8,8000785c <vTaskIncrementTick+0xf0>
800077d0:	70 08       	ld.w	r8,r8[0x0]
800077d2:	70 38       	ld.w	r8,r8[0xc]
800077d4:	70 37       	ld.w	r7,r8[0xc]
800077d6:	6e 18       	ld.w	r8,r7[0x4]
800077d8:	4a 09       	lddpc	r9,80007858 <vTaskIncrementTick+0xec>
800077da:	72 09       	ld.w	r9,r9[0x0]
800077dc:	12 38       	cp.w	r8,r9
800077de:	e0 88 00 14 	brls	80007806 <vTaskIncrementTick+0x9a>
800077e2:	c0 e8       	rjmp	800077fe <vTaskIncrementTick+0x92>
800077e4:	3f f9       	mov	r9,-1
800077e6:	4a 18       	lddpc	r8,80007868 <vTaskIncrementTick+0xfc>
800077e8:	91 09       	st.w	r8[0x0],r9
800077ea:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800077ee:	6a 08       	ld.w	r8,r5[0x0]
800077f0:	70 38       	ld.w	r8,r8[0xc]
800077f2:	70 37       	ld.w	r7,r8[0xc]
800077f4:	6e 18       	ld.w	r8,r7[0x4]
800077f6:	64 09       	ld.w	r9,r2[0x0]
800077f8:	12 38       	cp.w	r8,r9
800077fa:	e0 88 00 0a 	brls	8000780e <vTaskIncrementTick+0xa2>
800077fe:	49 b9       	lddpc	r9,80007868 <vTaskIncrementTick+0xfc>
80007800:	93 08       	st.w	r9[0x0],r8
80007802:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80007806:	49 a4       	lddpc	r4,8000786c <vTaskIncrementTick+0x100>
80007808:	49 a3       	lddpc	r3,80007870 <vTaskIncrementTick+0x104>
8000780a:	49 55       	lddpc	r5,8000785c <vTaskIncrementTick+0xf0>
8000780c:	49 32       	lddpc	r2,80007858 <vTaskIncrementTick+0xec>
8000780e:	ee c6 ff fc 	sub	r6,r7,-4
80007812:	0c 9c       	mov	r12,r6
80007814:	f0 1f 00 18 	mcall	80007874 <vTaskIncrementTick+0x108>
80007818:	6e a8       	ld.w	r8,r7[0x28]
8000781a:	58 08       	cp.w	r8,0
8000781c:	c0 50       	breq	80007826 <vTaskIncrementTick+0xba>
8000781e:	ee cc ff e8 	sub	r12,r7,-24
80007822:	f0 1f 00 15 	mcall	80007874 <vTaskIncrementTick+0x108>
80007826:	6e bc       	ld.w	r12,r7[0x2c]
80007828:	68 08       	ld.w	r8,r4[0x0]
8000782a:	10 3c       	cp.w	r12,r8
8000782c:	e9 fc ba 00 	st.whi	r4[0x0],r12
80007830:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007834:	0c 9b       	mov	r11,r6
80007836:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
8000783a:	f0 1f 00 10 	mcall	80007878 <vTaskIncrementTick+0x10c>
8000783e:	6a 08       	ld.w	r8,r5[0x0]
80007840:	70 08       	ld.w	r8,r8[0x0]
80007842:	58 08       	cp.w	r8,0
80007844:	cd 51       	brne	800077ee <vTaskIncrementTick+0x82>
80007846:	cc fb       	rjmp	800077e4 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80007848:	48 d8       	lddpc	r8,8000787c <vTaskIncrementTick+0x110>
8000784a:	70 09       	ld.w	r9,r8[0x0]
8000784c:	2f f9       	sub	r9,-1
8000784e:	91 09       	st.w	r8[0x0],r9
80007850:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80007854:	00 00       	add	r0,r0
80007856:	0d a0       	ld.ub	r0,r6[0x2]
80007858:	00 00       	add	r0,r0
8000785a:	0d 9c       	ld.ub	r12,r6[0x1]
8000785c:	00 00       	add	r0,r0
8000785e:	0c a8       	st.w	r6++,r8
80007860:	00 00       	add	r0,r0
80007862:	0c b8       	st.h	r6++,r8
80007864:	00 00       	add	r0,r0
80007866:	0c b4       	st.h	r6++,r4
80007868:	00 00       	add	r0,r0
8000786a:	05 50       	ld.sh	r0,--r2
8000786c:	00 00       	add	r0,r0
8000786e:	0d d8       	ld.ub	r8,r6[0x5]
80007870:	00 00       	add	r0,r0
80007872:	0c bc       	st.h	r6++,r12
80007874:	80 00       	ld.sh	r0,r0[0x0]
80007876:	6d 12       	ld.w	r2,r6[0x44]
80007878:	80 00       	ld.sh	r0,r0[0x0]
8000787a:	6c c2       	ld.w	r2,r6[0x30]
8000787c:	00 00       	add	r0,r0
8000787e:	0c a0       	st.w	r6++,r0

80007880 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80007880:	eb cd 40 c0 	pushm	r6-r7,lr
80007884:	18 97       	mov	r7,r12
80007886:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80007888:	f0 1f 00 15 	mcall	800078dc <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
8000788c:	6c 08       	ld.w	r8,r6[0x0]
8000788e:	5b f8       	cp.w	r8,-1
80007890:	c0 31       	brne	80007896 <xTaskCheckForTimeOut+0x16>
80007892:	30 07       	mov	r7,0
80007894:	c1 f8       	rjmp	800078d2 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80007896:	49 39       	lddpc	r9,800078e0 <xTaskCheckForTimeOut+0x60>
80007898:	72 09       	ld.w	r9,r9[0x0]
8000789a:	6e 0a       	ld.w	r10,r7[0x0]
8000789c:	12 3a       	cp.w	r10,r9
8000789e:	c0 70       	breq	800078ac <xTaskCheckForTimeOut+0x2c>
800078a0:	49 19       	lddpc	r9,800078e4 <xTaskCheckForTimeOut+0x64>
800078a2:	72 09       	ld.w	r9,r9[0x0]
800078a4:	6e 1a       	ld.w	r10,r7[0x4]
800078a6:	12 3a       	cp.w	r10,r9
800078a8:	e0 88 00 14 	brls	800078d0 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800078ac:	48 e9       	lddpc	r9,800078e4 <xTaskCheckForTimeOut+0x64>
800078ae:	72 0a       	ld.w	r10,r9[0x0]
800078b0:	6e 19       	ld.w	r9,r7[0x4]
800078b2:	12 1a       	sub	r10,r9
800078b4:	14 38       	cp.w	r8,r10
800078b6:	e0 88 00 0d 	brls	800078d0 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800078ba:	48 ba       	lddpc	r10,800078e4 <xTaskCheckForTimeOut+0x64>
800078bc:	74 0a       	ld.w	r10,r10[0x0]
800078be:	14 19       	sub	r9,r10
800078c0:	f2 08 00 08 	add	r8,r9,r8
800078c4:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
800078c6:	0e 9c       	mov	r12,r7
800078c8:	f0 1f 00 08 	mcall	800078e8 <xTaskCheckForTimeOut+0x68>
800078cc:	30 07       	mov	r7,0
800078ce:	c0 28       	rjmp	800078d2 <xTaskCheckForTimeOut+0x52>
800078d0:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
800078d2:	f0 1f 00 07 	mcall	800078ec <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
800078d6:	0e 9c       	mov	r12,r7
800078d8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800078dc:	80 00       	ld.sh	r0,r0[0x0]
800078de:	6d cc       	ld.w	r12,r6[0x70]
800078e0:	00 00       	add	r0,r0
800078e2:	0c b4       	st.h	r6++,r4
800078e4:	00 00       	add	r0,r0
800078e6:	0d 9c       	ld.ub	r12,r6[0x1]
800078e8:	80 00       	ld.sh	r0,r0[0x0]
800078ea:	75 e4       	ld.w	r4,r10[0x78]
800078ec:	80 00       	ld.sh	r0,r0[0x0]
800078ee:	6e d8       	ld.w	r8,r7[0x34]

800078f0 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
800078f0:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
800078f4:	f0 1f 00 05 	mcall	80007908 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
800078f8:	48 58       	lddpc	r8,8000790c <xTaskGetTickCount+0x1c>
800078fa:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
800078fc:	f0 1f 00 05 	mcall	80007910 <xTaskGetTickCount+0x20>

	return xTicks;
}
80007900:	0e 9c       	mov	r12,r7
80007902:	e3 cd 80 80 	ldm	sp++,r7,pc
80007906:	00 00       	add	r0,r0
80007908:	80 00       	ld.sh	r0,r0[0x0]
8000790a:	6d cc       	ld.w	r12,r6[0x70]
8000790c:	00 00       	add	r0,r0
8000790e:	0d 9c       	ld.ub	r12,r6[0x1]
80007910:	80 00       	ld.sh	r0,r0[0x0]
80007912:	6e d8       	ld.w	r8,r7[0x34]

80007914 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80007914:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80007918:	f0 1f 00 2c 	mcall	800079c8 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
8000791c:	4a c8       	lddpc	r8,800079cc <xTaskResumeAll+0xb8>
8000791e:	70 09       	ld.w	r9,r8[0x0]
80007920:	20 19       	sub	r9,1
80007922:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80007924:	70 08       	ld.w	r8,r8[0x0]
80007926:	58 08       	cp.w	r8,0
80007928:	c4 91       	brne	800079ba <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
8000792a:	4a a8       	lddpc	r8,800079d0 <xTaskResumeAll+0xbc>
8000792c:	70 08       	ld.w	r8,r8[0x0]
8000792e:	58 08       	cp.w	r8,0
80007930:	c4 50       	breq	800079ba <xTaskResumeAll+0xa6>
80007932:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80007934:	4a 85       	lddpc	r5,800079d4 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80007936:	4a 93       	lddpc	r3,800079d8 <xTaskResumeAll+0xc4>
80007938:	4a 92       	lddpc	r2,800079dc <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000793a:	4a a1       	lddpc	r1,800079e0 <xTaskResumeAll+0xcc>
8000793c:	c1 e8       	rjmp	80007978 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
8000793e:	6a 38       	ld.w	r8,r5[0xc]
80007940:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80007942:	ee cc ff e8 	sub	r12,r7,-24
80007946:	f0 1f 00 28 	mcall	800079e4 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
8000794a:	ee c6 ff fc 	sub	r6,r7,-4
8000794e:	0c 9c       	mov	r12,r6
80007950:	f0 1f 00 25 	mcall	800079e4 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80007954:	6e bc       	ld.w	r12,r7[0x2c]
80007956:	66 08       	ld.w	r8,r3[0x0]
80007958:	10 3c       	cp.w	r12,r8
8000795a:	e7 fc ba 00 	st.whi	r3[0x0],r12
8000795e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007962:	0c 9b       	mov	r11,r6
80007964:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80007968:	f0 1f 00 20 	mcall	800079e8 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000796c:	62 08       	ld.w	r8,r1[0x0]
8000796e:	6e b9       	ld.w	r9,r7[0x2c]
80007970:	70 b8       	ld.w	r8,r8[0x2c]
80007972:	10 39       	cp.w	r9,r8
80007974:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80007978:	6a 08       	ld.w	r8,r5[0x0]
8000797a:	58 08       	cp.w	r8,0
8000797c:	ce 11       	brne	8000793e <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000797e:	49 c8       	lddpc	r8,800079ec <xTaskResumeAll+0xd8>
80007980:	70 08       	ld.w	r8,r8[0x0]
80007982:	58 08       	cp.w	r8,0
80007984:	c0 f0       	breq	800079a2 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80007986:	49 a8       	lddpc	r8,800079ec <xTaskResumeAll+0xd8>
80007988:	70 08       	ld.w	r8,r8[0x0]
8000798a:	58 08       	cp.w	r8,0
8000798c:	c1 10       	breq	800079ae <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
8000798e:	49 87       	lddpc	r7,800079ec <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80007990:	f0 1f 00 18 	mcall	800079f0 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80007994:	6e 08       	ld.w	r8,r7[0x0]
80007996:	20 18       	sub	r8,1
80007998:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000799a:	6e 08       	ld.w	r8,r7[0x0]
8000799c:	58 08       	cp.w	r8,0
8000799e:	cf 91       	brne	80007990 <xTaskResumeAll+0x7c>
800079a0:	c0 78       	rjmp	800079ae <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800079a2:	58 14       	cp.w	r4,1
800079a4:	c0 50       	breq	800079ae <xTaskResumeAll+0x9a>
800079a6:	49 48       	lddpc	r8,800079f4 <xTaskResumeAll+0xe0>
800079a8:	70 08       	ld.w	r8,r8[0x0]
800079aa:	58 18       	cp.w	r8,1
800079ac:	c0 71       	brne	800079ba <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800079ae:	30 09       	mov	r9,0
800079b0:	49 18       	lddpc	r8,800079f4 <xTaskResumeAll+0xe0>
800079b2:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800079b4:	d7 33       	scall
800079b6:	30 17       	mov	r7,1
800079b8:	c0 28       	rjmp	800079bc <xTaskResumeAll+0xa8>
800079ba:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800079bc:	f0 1f 00 0f 	mcall	800079f8 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
800079c0:	0e 9c       	mov	r12,r7
800079c2:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800079c6:	00 00       	add	r0,r0
800079c8:	80 00       	ld.sh	r0,r0[0x0]
800079ca:	6d cc       	ld.w	r12,r6[0x70]
800079cc:	00 00       	add	r0,r0
800079ce:	0d a0       	ld.ub	r0,r6[0x2]
800079d0:	00 00       	add	r0,r0
800079d2:	0d bc       	ld.ub	r12,r6[0x3]
800079d4:	00 00       	add	r0,r0
800079d6:	0d 74       	ld.ub	r4,--r6
800079d8:	00 00       	add	r0,r0
800079da:	0d d8       	ld.ub	r8,r6[0x5]
800079dc:	00 00       	add	r0,r0
800079de:	0c bc       	st.h	r6++,r12
800079e0:	00 00       	add	r0,r0
800079e2:	0d 70       	ld.ub	r0,--r6
800079e4:	80 00       	ld.sh	r0,r0[0x0]
800079e6:	6d 12       	ld.w	r2,r6[0x44]
800079e8:	80 00       	ld.sh	r0,r0[0x0]
800079ea:	6c c2       	ld.w	r2,r6[0x30]
800079ec:	00 00       	add	r0,r0
800079ee:	0c a0       	st.w	r6++,r0
800079f0:	80 00       	ld.sh	r0,r0[0x0]
800079f2:	77 6c       	ld.w	r12,r11[0x58]
800079f4:	00 00       	add	r0,r0
800079f6:	0d c0       	ld.ub	r0,r6[0x4]
800079f8:	80 00       	ld.sh	r0,r0[0x0]
800079fa:	6e d8       	ld.w	r8,r7[0x34]

800079fc <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
800079fc:	eb cd 40 80 	pushm	r7,lr
80007a00:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80007a02:	49 08       	lddpc	r8,80007a40 <prvAddCurrentTaskToDelayedList+0x44>
80007a04:	70 08       	ld.w	r8,r8[0x0]
80007a06:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80007a08:	48 f8       	lddpc	r8,80007a44 <prvAddCurrentTaskToDelayedList+0x48>
80007a0a:	70 08       	ld.w	r8,r8[0x0]
80007a0c:	10 3c       	cp.w	r12,r8
80007a0e:	c0 a2       	brcc	80007a22 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007a10:	48 c8       	lddpc	r8,80007a40 <prvAddCurrentTaskToDelayedList+0x44>
80007a12:	70 0b       	ld.w	r11,r8[0x0]
80007a14:	48 d8       	lddpc	r8,80007a48 <prvAddCurrentTaskToDelayedList+0x4c>
80007a16:	70 0c       	ld.w	r12,r8[0x0]
80007a18:	2f cb       	sub	r11,-4
80007a1a:	f0 1f 00 0d 	mcall	80007a4c <prvAddCurrentTaskToDelayedList+0x50>
80007a1e:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007a22:	48 88       	lddpc	r8,80007a40 <prvAddCurrentTaskToDelayedList+0x44>
80007a24:	70 0b       	ld.w	r11,r8[0x0]
80007a26:	48 b8       	lddpc	r8,80007a50 <prvAddCurrentTaskToDelayedList+0x54>
80007a28:	70 0c       	ld.w	r12,r8[0x0]
80007a2a:	2f cb       	sub	r11,-4
80007a2c:	f0 1f 00 08 	mcall	80007a4c <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80007a30:	48 98       	lddpc	r8,80007a54 <prvAddCurrentTaskToDelayedList+0x58>
80007a32:	70 08       	ld.w	r8,r8[0x0]
80007a34:	10 37       	cp.w	r7,r8
80007a36:	c0 32       	brcc	80007a3c <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80007a38:	48 78       	lddpc	r8,80007a54 <prvAddCurrentTaskToDelayedList+0x58>
80007a3a:	91 07       	st.w	r8[0x0],r7
80007a3c:	e3 cd 80 80 	ldm	sp++,r7,pc
80007a40:	00 00       	add	r0,r0
80007a42:	0d 70       	ld.ub	r0,--r6
80007a44:	00 00       	add	r0,r0
80007a46:	0d 9c       	ld.ub	r12,r6[0x1]
80007a48:	00 00       	add	r0,r0
80007a4a:	0c b8       	st.h	r6++,r8
80007a4c:	80 00       	ld.sh	r0,r0[0x0]
80007a4e:	6c de       	ld.w	lr,r6[0x34]
80007a50:	00 00       	add	r0,r0
80007a52:	0c a8       	st.w	r6++,r8
80007a54:	00 00       	add	r0,r0
80007a56:	05 50       	ld.sh	r0,--r2

80007a58 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80007a58:	eb cd 40 c0 	pushm	r6-r7,lr
80007a5c:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80007a5e:	58 0c       	cp.w	r12,0
80007a60:	c1 10       	breq	80007a82 <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80007a62:	f0 1f 00 0a 	mcall	80007a88 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80007a66:	48 a8       	lddpc	r8,80007a8c <vTaskDelay+0x34>
80007a68:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007a6a:	48 a8       	lddpc	r8,80007a90 <vTaskDelay+0x38>
80007a6c:	70 0c       	ld.w	r12,r8[0x0]
80007a6e:	2f cc       	sub	r12,-4
80007a70:	f0 1f 00 09 	mcall	80007a94 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80007a74:	ee 06 00 0c 	add	r12,r7,r6
80007a78:	f0 1f 00 08 	mcall	80007a98 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80007a7c:	f0 1f 00 08 	mcall	80007a9c <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80007a80:	c0 21       	brne	80007a84 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80007a82:	d7 33       	scall
80007a84:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007a88:	80 00       	ld.sh	r0,r0[0x0]
80007a8a:	75 58       	ld.w	r8,r10[0x54]
80007a8c:	00 00       	add	r0,r0
80007a8e:	0d 9c       	ld.ub	r12,r6[0x1]
80007a90:	00 00       	add	r0,r0
80007a92:	0d 70       	ld.ub	r0,--r6
80007a94:	80 00       	ld.sh	r0,r0[0x0]
80007a96:	6d 12       	ld.w	r2,r6[0x44]
80007a98:	80 00       	ld.sh	r0,r0[0x0]
80007a9a:	79 fc       	ld.w	r12,r12[0x7c]
80007a9c:	80 00       	ld.sh	r0,r0[0x0]
80007a9e:	79 14       	ld.w	r4,r12[0x44]

80007aa0 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80007aa0:	eb cd 40 c0 	pushm	r6-r7,lr
80007aa4:	18 96       	mov	r6,r12
80007aa6:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80007aa8:	f0 1f 00 18 	mcall	80007b08 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80007aac:	6c 08       	ld.w	r8,r6[0x0]
80007aae:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80007ab0:	49 79       	lddpc	r9,80007b0c <vTaskDelayUntil+0x6c>
80007ab2:	72 09       	ld.w	r9,r9[0x0]
80007ab4:	12 38       	cp.w	r8,r9
80007ab6:	e0 88 00 0c 	brls	80007ace <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80007aba:	0e 38       	cp.w	r8,r7
80007abc:	e0 88 00 22 	brls	80007b00 <vTaskDelayUntil+0x60>
80007ac0:	49 38       	lddpc	r8,80007b0c <vTaskDelayUntil+0x6c>
80007ac2:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80007ac4:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80007ac6:	10 37       	cp.w	r7,r8
80007ac8:	e0 88 00 14 	brls	80007af0 <vTaskDelayUntil+0x50>
80007acc:	c0 a8       	rjmp	80007ae0 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80007ace:	0e 38       	cp.w	r8,r7
80007ad0:	e0 8b 00 16 	brhi	80007afc <vTaskDelayUntil+0x5c>
80007ad4:	48 e8       	lddpc	r8,80007b0c <vTaskDelayUntil+0x6c>
80007ad6:	70 08       	ld.w	r8,r8[0x0]
80007ad8:	10 37       	cp.w	r7,r8
80007ada:	e0 8b 00 11 	brhi	80007afc <vTaskDelayUntil+0x5c>
80007ade:	c1 18       	rjmp	80007b00 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007ae0:	48 c8       	lddpc	r8,80007b10 <vTaskDelayUntil+0x70>
80007ae2:	70 0c       	ld.w	r12,r8[0x0]
80007ae4:	2f cc       	sub	r12,-4
80007ae6:	f0 1f 00 0c 	mcall	80007b14 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80007aea:	0e 9c       	mov	r12,r7
80007aec:	f0 1f 00 0b 	mcall	80007b18 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80007af0:	f0 1f 00 0b 	mcall	80007b1c <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80007af4:	c0 81       	brne	80007b04 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80007af6:	d7 33       	scall
80007af8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80007afc:	8d 07       	st.w	r6[0x0],r7
80007afe:	cf 1b       	rjmp	80007ae0 <vTaskDelayUntil+0x40>
80007b00:	8d 07       	st.w	r6[0x0],r7
80007b02:	cf 7b       	rjmp	80007af0 <vTaskDelayUntil+0x50>
80007b04:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007b08:	80 00       	ld.sh	r0,r0[0x0]
80007b0a:	75 58       	ld.w	r8,r10[0x54]
80007b0c:	00 00       	add	r0,r0
80007b0e:	0d 9c       	ld.ub	r12,r6[0x1]
80007b10:	00 00       	add	r0,r0
80007b12:	0d 70       	ld.ub	r0,--r6
80007b14:	80 00       	ld.sh	r0,r0[0x0]
80007b16:	6d 12       	ld.w	r2,r6[0x44]
80007b18:	80 00       	ld.sh	r0,r0[0x0]
80007b1a:	79 fc       	ld.w	r12,r12[0x7c]
80007b1c:	80 00       	ld.sh	r0,r0[0x0]
80007b1e:	79 14       	ld.w	r4,r12[0x44]

80007b20 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80007b20:	eb cd 40 c0 	pushm	r6-r7,lr
80007b24:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80007b26:	48 e7       	lddpc	r7,80007b5c <vTaskPlaceOnEventList+0x3c>
80007b28:	6e 0b       	ld.w	r11,r7[0x0]
80007b2a:	2e 8b       	sub	r11,-24
80007b2c:	f0 1f 00 0d 	mcall	80007b60 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007b30:	6e 0c       	ld.w	r12,r7[0x0]
80007b32:	2f cc       	sub	r12,-4
80007b34:	f0 1f 00 0c 	mcall	80007b64 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80007b38:	5b f6       	cp.w	r6,-1
80007b3a:	c0 81       	brne	80007b4a <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007b3c:	6e 0b       	ld.w	r11,r7[0x0]
80007b3e:	2f cb       	sub	r11,-4
80007b40:	48 ac       	lddpc	r12,80007b68 <vTaskPlaceOnEventList+0x48>
80007b42:	f0 1f 00 0b 	mcall	80007b6c <vTaskPlaceOnEventList+0x4c>
80007b46:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80007b4a:	48 a8       	lddpc	r8,80007b70 <vTaskPlaceOnEventList+0x50>
80007b4c:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80007b4e:	ec 0c 00 0c 	add	r12,r6,r12
80007b52:	f0 1f 00 09 	mcall	80007b74 <vTaskPlaceOnEventList+0x54>
80007b56:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007b5a:	00 00       	add	r0,r0
80007b5c:	00 00       	add	r0,r0
80007b5e:	0d 70       	ld.ub	r0,--r6
80007b60:	80 00       	ld.sh	r0,r0[0x0]
80007b62:	6c de       	ld.w	lr,r6[0x34]
80007b64:	80 00       	ld.sh	r0,r0[0x0]
80007b66:	6d 12       	ld.w	r2,r6[0x44]
80007b68:	00 00       	add	r0,r0
80007b6a:	0d c4       	ld.ub	r4,r6[0x4]
80007b6c:	80 00       	ld.sh	r0,r0[0x0]
80007b6e:	6c c2       	ld.w	r2,r6[0x30]
80007b70:	00 00       	add	r0,r0
80007b72:	0d 9c       	ld.ub	r12,r6[0x1]
80007b74:	80 00       	ld.sh	r0,r0[0x0]
80007b76:	79 fc       	ld.w	r12,r12[0x7c]

80007b78 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80007b78:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80007b7c:	49 67       	lddpc	r7,80007bd4 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80007b7e:	49 74       	lddpc	r4,80007bd8 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80007b80:	49 73       	lddpc	r3,80007bdc <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80007b82:	49 85       	lddpc	r5,80007be0 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80007b84:	6e 08       	ld.w	r8,r7[0x0]
80007b86:	58 08       	cp.w	r8,0
80007b88:	c1 e0       	breq	80007bc4 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80007b8a:	f0 1f 00 17 	mcall	80007be4 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80007b8e:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80007b90:	f0 1f 00 16 	mcall	80007be8 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80007b94:	58 06       	cp.w	r6,0
80007b96:	c1 70       	breq	80007bc4 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80007b98:	f0 1f 00 15 	mcall	80007bec <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80007b9c:	68 38       	ld.w	r8,r4[0xc]
80007b9e:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80007ba0:	ec cc ff fc 	sub	r12,r6,-4
80007ba4:	f0 1f 00 13 	mcall	80007bf0 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80007ba8:	66 08       	ld.w	r8,r3[0x0]
80007baa:	20 18       	sub	r8,1
80007bac:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80007bae:	6e 08       	ld.w	r8,r7[0x0]
80007bb0:	20 18       	sub	r8,1
80007bb2:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80007bb4:	f0 1f 00 10 	mcall	80007bf4 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80007bb8:	6c cc       	ld.w	r12,r6[0x30]
80007bba:	f0 1f 00 10 	mcall	80007bf8 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80007bbe:	0c 9c       	mov	r12,r6
80007bc0:	f0 1f 00 0e 	mcall	80007bf8 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80007bc4:	6a 08       	ld.w	r8,r5[0x0]
80007bc6:	58 18       	cp.w	r8,1
80007bc8:	e0 88 00 03 	brls	80007bce <prvIdleTask+0x56>
			{
				taskYIELD();
80007bcc:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80007bce:	f0 1f 00 0c 	mcall	80007bfc <prvIdleTask+0x84>
		}
		#endif
	}
80007bd2:	cd 9b       	rjmp	80007b84 <prvIdleTask+0xc>
80007bd4:	00 00       	add	r0,r0
80007bd6:	0c b0       	st.h	r6++,r0
80007bd8:	00 00       	add	r0,r0
80007bda:	0d 5c       	ld.sh	r12,--r6
80007bdc:	00 00       	add	r0,r0
80007bde:	0d bc       	ld.ub	r12,r6[0x3]
80007be0:	00 00       	add	r0,r0
80007be2:	0c bc       	st.h	r6++,r12
80007be4:	80 00       	ld.sh	r0,r0[0x0]
80007be6:	75 58       	ld.w	r8,r10[0x54]
80007be8:	80 00       	ld.sh	r0,r0[0x0]
80007bea:	79 14       	ld.w	r4,r12[0x44]
80007bec:	80 00       	ld.sh	r0,r0[0x0]
80007bee:	6d cc       	ld.w	r12,r6[0x70]
80007bf0:	80 00       	ld.sh	r0,r0[0x0]
80007bf2:	6d 12       	ld.w	r2,r6[0x44]
80007bf4:	80 00       	ld.sh	r0,r0[0x0]
80007bf6:	6e d8       	ld.w	r8,r7[0x34]
80007bf8:	80 00       	ld.sh	r0,r0[0x0]
80007bfa:	70 10       	ld.w	r0,r8[0x4]
80007bfc:	80 00       	ld.sh	r0,r0[0x0]
80007bfe:	20 48       	sub	r8,4

80007c00 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80007c00:	d4 31       	pushm	r0-r7,lr
80007c02:	20 1d       	sub	sp,4
80007c04:	fa c4 ff d8 	sub	r4,sp,-40
80007c08:	50 0c       	stdsp	sp[0x0],r12
80007c0a:	16 91       	mov	r1,r11
80007c0c:	14 97       	mov	r7,r10
80007c0e:	12 90       	mov	r0,r9
80007c10:	10 93       	mov	r3,r8
80007c12:	68 02       	ld.w	r2,r4[0x0]
80007c14:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80007c16:	34 8c       	mov	r12,72
80007c18:	f0 1f 00 5c 	mcall	80007d88 <xTaskGenericCreate+0x188>
80007c1c:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80007c1e:	c0 31       	brne	80007c24 <xTaskGenericCreate+0x24>
80007c20:	3f fc       	mov	r12,-1
80007c22:	ca f8       	rjmp	80007d80 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80007c24:	58 06       	cp.w	r6,0
80007c26:	e0 81 00 af 	brne	80007d84 <xTaskGenericCreate+0x184>
80007c2a:	0e 9c       	mov	r12,r7
80007c2c:	5c 7c       	castu.h	r12
80007c2e:	a3 6c       	lsl	r12,0x2
80007c30:	f0 1f 00 56 	mcall	80007d88 <xTaskGenericCreate+0x188>
80007c34:	18 96       	mov	r6,r12
80007c36:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80007c38:	c0 61       	brne	80007c44 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80007c3a:	0a 9c       	mov	r12,r5
80007c3c:	f0 1f 00 54 	mcall	80007d8c <xTaskGenericCreate+0x18c>
80007c40:	3f fc       	mov	r12,-1
80007c42:	c9 f8       	rjmp	80007d80 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80007c44:	5c 77       	castu.h	r7
80007c46:	ee 0a 15 02 	lsl	r10,r7,0x2
80007c4a:	e0 6b 00 a5 	mov	r11,165
80007c4e:	0c 9c       	mov	r12,r6
80007c50:	f0 1f 00 50 	mcall	80007d90 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80007c54:	ee c6 00 01 	sub	r6,r7,1
80007c58:	6a c8       	ld.w	r8,r5[0x30]
80007c5a:	f0 06 00 26 	add	r6,r8,r6<<0x2
80007c5e:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80007c62:	31 0a       	mov	r10,16
80007c64:	02 9b       	mov	r11,r1
80007c66:	ea cc ff cc 	sub	r12,r5,-52
80007c6a:	f0 1f 00 4b 	mcall	80007d94 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80007c6e:	30 08       	mov	r8,0
80007c70:	eb 68 00 43 	st.b	r5[67],r8
80007c74:	58 73       	cp.w	r3,7
80007c76:	e6 07 17 80 	movls	r7,r3
80007c7a:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80007c7e:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80007c80:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80007c84:	ea c4 ff fc 	sub	r4,r5,-4
80007c88:	08 9c       	mov	r12,r4
80007c8a:	f0 1f 00 44 	mcall	80007d98 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80007c8e:	ea cc ff e8 	sub	r12,r5,-24
80007c92:	f0 1f 00 42 	mcall	80007d98 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80007c96:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80007c98:	ee 07 11 08 	rsub	r7,r7,8
80007c9c:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80007c9e:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80007ca0:	00 9a       	mov	r10,r0
80007ca2:	40 0b       	lddsp	r11,sp[0x0]
80007ca4:	0c 9c       	mov	r12,r6
80007ca6:	f0 1f 00 3e 	mcall	80007d9c <xTaskGenericCreate+0x19c>
80007caa:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80007cac:	58 02       	cp.w	r2,0
80007cae:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80007cb2:	f0 1f 00 3c 	mcall	80007da0 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80007cb6:	4b c8       	lddpc	r8,80007da4 <xTaskGenericCreate+0x1a4>
80007cb8:	70 09       	ld.w	r9,r8[0x0]
80007cba:	2f f9       	sub	r9,-1
80007cbc:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80007cbe:	4b b8       	lddpc	r8,80007da8 <xTaskGenericCreate+0x1a8>
80007cc0:	70 08       	ld.w	r8,r8[0x0]
80007cc2:	58 08       	cp.w	r8,0
80007cc4:	c2 61       	brne	80007d10 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80007cc6:	4b 98       	lddpc	r8,80007da8 <xTaskGenericCreate+0x1a8>
80007cc8:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80007cca:	4b 78       	lddpc	r8,80007da4 <xTaskGenericCreate+0x1a4>
80007ccc:	70 08       	ld.w	r8,r8[0x0]
80007cce:	58 18       	cp.w	r8,1
80007cd0:	c2 b1       	brne	80007d26 <xTaskGenericCreate+0x126>
80007cd2:	4b 77       	lddpc	r7,80007dac <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80007cd4:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80007cd8:	0e 9c       	mov	r12,r7
80007cda:	f0 1f 00 36 	mcall	80007db0 <xTaskGenericCreate+0x1b0>
80007cde:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80007ce0:	0c 37       	cp.w	r7,r6
80007ce2:	cf b1       	brne	80007cd8 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80007ce4:	4b 47       	lddpc	r7,80007db4 <xTaskGenericCreate+0x1b4>
80007ce6:	0e 9c       	mov	r12,r7
80007ce8:	f0 1f 00 32 	mcall	80007db0 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80007cec:	4b 36       	lddpc	r6,80007db8 <xTaskGenericCreate+0x1b8>
80007cee:	0c 9c       	mov	r12,r6
80007cf0:	f0 1f 00 30 	mcall	80007db0 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80007cf4:	4b 2c       	lddpc	r12,80007dbc <xTaskGenericCreate+0x1bc>
80007cf6:	f0 1f 00 2f 	mcall	80007db0 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80007cfa:	4b 2c       	lddpc	r12,80007dc0 <xTaskGenericCreate+0x1c0>
80007cfc:	f0 1f 00 2d 	mcall	80007db0 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80007d00:	4b 1c       	lddpc	r12,80007dc4 <xTaskGenericCreate+0x1c4>
80007d02:	f0 1f 00 2c 	mcall	80007db0 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80007d06:	4b 18       	lddpc	r8,80007dc8 <xTaskGenericCreate+0x1c8>
80007d08:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80007d0a:	4b 18       	lddpc	r8,80007dcc <xTaskGenericCreate+0x1cc>
80007d0c:	91 06       	st.w	r8[0x0],r6
80007d0e:	c0 c8       	rjmp	80007d26 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80007d10:	4b 08       	lddpc	r8,80007dd0 <xTaskGenericCreate+0x1d0>
80007d12:	70 08       	ld.w	r8,r8[0x0]
80007d14:	58 08       	cp.w	r8,0
80007d16:	c0 81       	brne	80007d26 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80007d18:	4a 48       	lddpc	r8,80007da8 <xTaskGenericCreate+0x1a8>
80007d1a:	70 08       	ld.w	r8,r8[0x0]
80007d1c:	70 b8       	ld.w	r8,r8[0x2c]
80007d1e:	10 33       	cp.w	r3,r8
80007d20:	c0 33       	brcs	80007d26 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80007d22:	4a 28       	lddpc	r8,80007da8 <xTaskGenericCreate+0x1a8>
80007d24:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80007d26:	6a b8       	ld.w	r8,r5[0x2c]
80007d28:	4a b9       	lddpc	r9,80007dd4 <xTaskGenericCreate+0x1d4>
80007d2a:	72 09       	ld.w	r9,r9[0x0]
80007d2c:	12 38       	cp.w	r8,r9
80007d2e:	e0 88 00 04 	brls	80007d36 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80007d32:	4a 99       	lddpc	r9,80007dd4 <xTaskGenericCreate+0x1d4>
80007d34:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80007d36:	4a 98       	lddpc	r8,80007dd8 <xTaskGenericCreate+0x1d8>
80007d38:	70 09       	ld.w	r9,r8[0x0]
80007d3a:	2f f9       	sub	r9,-1
80007d3c:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80007d3e:	6a b8       	ld.w	r8,r5[0x2c]
80007d40:	4a 79       	lddpc	r9,80007ddc <xTaskGenericCreate+0x1dc>
80007d42:	72 09       	ld.w	r9,r9[0x0]
80007d44:	12 38       	cp.w	r8,r9
80007d46:	e0 88 00 04 	brls	80007d4e <xTaskGenericCreate+0x14e>
80007d4a:	4a 59       	lddpc	r9,80007ddc <xTaskGenericCreate+0x1dc>
80007d4c:	93 08       	st.w	r9[0x0],r8
80007d4e:	6a bc       	ld.w	r12,r5[0x2c]
80007d50:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007d54:	08 9b       	mov	r11,r4
80007d56:	49 68       	lddpc	r8,80007dac <xTaskGenericCreate+0x1ac>
80007d58:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007d5c:	f0 1f 00 21 	mcall	80007de0 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80007d60:	f0 1f 00 21 	mcall	80007de4 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80007d64:	49 b8       	lddpc	r8,80007dd0 <xTaskGenericCreate+0x1d0>
80007d66:	70 08       	ld.w	r8,r8[0x0]
80007d68:	58 08       	cp.w	r8,0
80007d6a:	c0 a0       	breq	80007d7e <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80007d6c:	48 f8       	lddpc	r8,80007da8 <xTaskGenericCreate+0x1a8>
80007d6e:	70 08       	ld.w	r8,r8[0x0]
80007d70:	70 b8       	ld.w	r8,r8[0x2c]
80007d72:	10 33       	cp.w	r3,r8
80007d74:	e0 88 00 05 	brls	80007d7e <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80007d78:	d7 33       	scall
80007d7a:	30 1c       	mov	r12,1
80007d7c:	c0 28       	rjmp	80007d80 <xTaskGenericCreate+0x180>
80007d7e:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80007d80:	2f fd       	sub	sp,-4
80007d82:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80007d84:	99 c6       	st.w	r12[0x30],r6
80007d86:	c5 fb       	rjmp	80007c44 <xTaskGenericCreate+0x44>
80007d88:	80 00       	ld.sh	r0,r0[0x0]
80007d8a:	70 38       	ld.w	r8,r8[0xc]
80007d8c:	80 00       	ld.sh	r0,r0[0x0]
80007d8e:	70 10       	ld.w	r0,r8[0x4]
80007d90:	80 00       	ld.sh	r0,r0[0x0]
80007d92:	89 b6       	st.w	r4[0x2c],r6
80007d94:	80 00       	ld.sh	r0,r0[0x0]
80007d96:	8c e0       	ld.uh	r0,r6[0xc]
80007d98:	80 00       	ld.sh	r0,r0[0x0]
80007d9a:	6c bc       	ld.w	r12,r6[0x2c]
80007d9c:	80 00       	ld.sh	r0,r0[0x0]
80007d9e:	6d 38       	ld.w	r8,r6[0x4c]
80007da0:	80 00       	ld.sh	r0,r0[0x0]
80007da2:	6d cc       	ld.w	r12,r6[0x70]
80007da4:	00 00       	add	r0,r0
80007da6:	0d bc       	ld.ub	r12,r6[0x3]
80007da8:	00 00       	add	r0,r0
80007daa:	0d 70       	ld.ub	r0,--r6
80007dac:	00 00       	add	r0,r0
80007dae:	0c bc       	st.h	r6++,r12
80007db0:	80 00       	ld.sh	r0,r0[0x0]
80007db2:	6c a8       	ld.w	r8,r6[0x28]
80007db4:	00 00       	add	r0,r0
80007db6:	0d 88       	ld.ub	r8,r6[0x0]
80007db8:	00 00       	add	r0,r0
80007dba:	0d a4       	ld.ub	r4,r6[0x2]
80007dbc:	00 00       	add	r0,r0
80007dbe:	0d 74       	ld.ub	r4,--r6
80007dc0:	00 00       	add	r0,r0
80007dc2:	0d 5c       	ld.sh	r12,--r6
80007dc4:	00 00       	add	r0,r0
80007dc6:	0d c4       	ld.ub	r4,r6[0x4]
80007dc8:	00 00       	add	r0,r0
80007dca:	0c a8       	st.w	r6++,r8
80007dcc:	00 00       	add	r0,r0
80007dce:	0c b8       	st.h	r6++,r8
80007dd0:	00 00       	add	r0,r0
80007dd2:	0c ac       	st.w	r6++,r12
80007dd4:	00 00       	add	r0,r0
80007dd6:	0c a4       	st.w	r6++,r4
80007dd8:	00 00       	add	r0,r0
80007dda:	0d b8       	ld.ub	r8,r6[0x3]
80007ddc:	00 00       	add	r0,r0
80007dde:	0d d8       	ld.ub	r8,r6[0x5]
80007de0:	80 00       	ld.sh	r0,r0[0x0]
80007de2:	6c c2       	ld.w	r2,r6[0x30]
80007de4:	80 00       	ld.sh	r0,r0[0x0]
80007de6:	6e d8       	ld.w	r8,r7[0x34]

80007de8 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80007de8:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80007dea:	30 09       	mov	r9,0
80007dec:	1a d9       	st.w	--sp,r9
80007dee:	1a d9       	st.w	--sp,r9
80007df0:	1a d9       	st.w	--sp,r9
80007df2:	12 98       	mov	r8,r9
80007df4:	e0 6a 01 00 	mov	r10,256
80007df8:	48 9b       	lddpc	r11,80007e1c <vTaskStartScheduler+0x34>
80007dfa:	48 ac       	lddpc	r12,80007e20 <vTaskStartScheduler+0x38>
80007dfc:	f0 1f 00 0a 	mcall	80007e24 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80007e00:	2f dd       	sub	sp,-12
80007e02:	58 1c       	cp.w	r12,1
80007e04:	c0 a1       	brne	80007e18 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80007e06:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80007e08:	30 19       	mov	r9,1
80007e0a:	48 88       	lddpc	r8,80007e28 <vTaskStartScheduler+0x40>
80007e0c:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80007e0e:	30 09       	mov	r9,0
80007e10:	48 78       	lddpc	r8,80007e2c <vTaskStartScheduler+0x44>
80007e12:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80007e14:	f0 1f 00 07 	mcall	80007e30 <vTaskStartScheduler+0x48>
80007e18:	d8 02       	popm	pc
80007e1a:	00 00       	add	r0,r0
80007e1c:	80 00       	ld.sh	r0,r0[0x0]
80007e1e:	ed a8 80 00 	ldcm.w	cp4,r8,
80007e22:	7b 78       	ld.w	r8,sp[0x5c]
80007e24:	80 00       	ld.sh	r0,r0[0x0]
80007e26:	7c 00       	ld.w	r0,lr[0x0]
80007e28:	00 00       	add	r0,r0
80007e2a:	0c ac       	st.w	r6++,r12
80007e2c:	00 00       	add	r0,r0
80007e2e:	0d 9c       	ld.ub	r12,r6[0x1]
80007e30:	80 00       	ld.sh	r0,r0[0x0]
80007e32:	6d dc       	ld.w	r12,r6[0x74]

80007e34 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80007e34:	16 cc       	st.b	r11++,r12
	return str;
}
80007e36:	5e fb       	retal	r11

80007e38 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80007e38:	eb cd 40 c0 	pushm	r6-r7,lr
80007e3c:	20 3d       	sub	sp,12
80007e3e:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80007e40:	30 06       	mov	r6,0
80007e42:	30 07       	mov	r7,0
80007e44:	fa e7 00 00 	st.d	sp[0],r6
80007e48:	30 0c       	mov	r12,0
80007e4a:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80007e4c:	58 08       	cp.w	r8,0
80007e4e:	c1 30       	breq	80007e74 <PrintHex+0x3c>
80007e50:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80007e52:	1a 9c       	mov	r12,sp
80007e54:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80007e58:	58 9e       	cp.w	lr,9
80007e5a:	e0 8a 00 04 	brle	80007e62 <PrintHex+0x2a>
80007e5e:	2c 9e       	sub	lr,-55
80007e60:	c0 48       	rjmp	80007e68 <PrintHex+0x30>
80007e62:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80007e66:	2d 0e       	sub	lr,-48
80007e68:	f8 09 0b 0e 	st.b	r12[r9],lr
80007e6c:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80007e6e:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80007e70:	cf 21       	brne	80007e54 <PrintHex+0x1c>
80007e72:	c0 48       	rjmp	80007e7a <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80007e74:	33 08       	mov	r8,48
80007e76:	ba 88       	st.b	sp[0x0],r8
80007e78:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80007e7a:	f6 09 01 08 	sub	r8,r11,r9
80007e7e:	58 08       	cp.w	r8,0
80007e80:	e0 8a 00 13 	brle	80007ea6 <PrintHex+0x6e>
	{
		char num = len - cnt;
80007e84:	12 1b       	sub	r11,r9
80007e86:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80007e8a:	18 9e       	mov	lr,r12
80007e8c:	58 0c       	cp.w	r12,0
80007e8e:	e0 8a 00 0c 	brle	80007ea6 <PrintHex+0x6e>
80007e92:	1a 9b       	mov	r11,sp
80007e94:	12 0b       	add	r11,r9
80007e96:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80007e98:	33 07       	mov	r7,48
80007e9a:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007e9c:	2f f8       	sub	r8,-1
80007e9e:	1c 38       	cp.w	r8,lr
80007ea0:	cf d5       	brlt	80007e9a <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80007ea2:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80007ea6:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80007eaa:	f0 cb ff ff 	sub	r11,r8,-1
80007eae:	58 0b       	cp.w	r11,0
80007eb0:	e0 8a 00 19 	brle	80007ee2 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80007eb4:	fa cb ff f4 	sub	r11,sp,-12
80007eb8:	f6 09 00 09 	add	r9,r11,r9
80007ebc:	37 8b       	mov	r11,120
80007ebe:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80007ec2:	fa c9 ff f4 	sub	r9,sp,-12
80007ec6:	10 09       	add	r9,r8
80007ec8:	33 0b       	mov	r11,48
80007eca:	f3 6b ff f4 	st.b	r9[-12],r11
80007ece:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80007ed2:	fa ce 00 01 	sub	lr,sp,1
80007ed6:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80007ed8:	11 8b       	ld.ub	r11,r8[0x0]
80007eda:	12 cb       	st.b	r9++,r11
80007edc:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80007ede:	1c 38       	cp.w	r8,lr
80007ee0:	cf c1       	brne	80007ed8 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80007ee2:	14 9c       	mov	r12,r10
80007ee4:	2f dd       	sub	sp,-12
80007ee6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80007eea <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80007eea:	d4 21       	pushm	r4-r7,lr
80007eec:	20 3d       	sub	sp,12
80007eee:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80007ef0:	30 06       	mov	r6,0
80007ef2:	30 07       	mov	r7,0
80007ef4:	fa e7 00 00 	st.d	sp[0],r6
80007ef8:	30 0c       	mov	r12,0
80007efa:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80007efc:	58 08       	cp.w	r8,0
80007efe:	c0 35       	brlt	80007f04 <PrintDec+0x1a>
80007f00:	14 97       	mov	r7,r10
80007f02:	c0 58       	rjmp	80007f0c <PrintDec+0x22>
	{
		*p++ = '-';
80007f04:	14 97       	mov	r7,r10
80007f06:	32 d9       	mov	r9,45
80007f08:	0e c9       	st.b	r7++,r9
		i = -i;
80007f0a:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80007f0c:	58 08       	cp.w	r8,0
80007f0e:	c0 51       	brne	80007f18 <PrintDec+0x2e>
80007f10:	33 08       	mov	r8,48
80007f12:	ba 88       	st.b	sp[0x0],r8
80007f14:	30 1e       	mov	lr,1
80007f16:	c2 f8       	rjmp	80007f74 <PrintDec+0x8a>
	
	int ten = i%10;
80007f18:	e0 65 66 67 	mov	r5,26215
80007f1c:	ea 15 66 66 	orh	r5,0x6666
80007f20:	f0 05 04 44 	muls.d	r4,r8,r5
80007f24:	ea 0c 14 02 	asr	r12,r5,0x2
80007f28:	f0 09 14 1f 	asr	r9,r8,0x1f
80007f2c:	f8 09 01 09 	sub	r9,r12,r9
80007f30:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007f34:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80007f38:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80007f3a:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80007f3c:	e0 66 66 67 	mov	r6,26215
80007f40:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80007f44:	2d 09       	sub	r9,-48
80007f46:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80007f4a:	2f fe       	sub	lr,-1
		i /= 10;
80007f4c:	f0 06 04 44 	muls.d	r4,r8,r6
80007f50:	ea 09 14 02 	asr	r9,r5,0x2
80007f54:	bf 58       	asr	r8,0x1f
80007f56:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80007f5a:	f0 06 04 44 	muls.d	r4,r8,r6
80007f5e:	ea 09 14 02 	asr	r9,r5,0x2
80007f62:	f0 05 14 1f 	asr	r5,r8,0x1f
80007f66:	0a 19       	sub	r9,r5
80007f68:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007f6c:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80007f70:	58 08       	cp.w	r8,0
80007f72:	ce 91       	brne	80007f44 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80007f74:	f6 0e 01 08 	sub	r8,r11,lr
80007f78:	58 08       	cp.w	r8,0
80007f7a:	e0 89 00 06 	brgt	80007f86 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80007f7e:	58 0e       	cp.w	lr,0
80007f80:	e0 89 00 14 	brgt	80007fa8 <PrintDec+0xbe>
80007f84:	c1 d8       	rjmp	80007fbe <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80007f86:	1c 1b       	sub	r11,lr
80007f88:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80007f8a:	16 9c       	mov	r12,r11
80007f8c:	58 0b       	cp.w	r11,0
80007f8e:	fe 9a ff f8 	brle	80007f7e <PrintDec+0x94>
80007f92:	1a 99       	mov	r9,sp
80007f94:	1c 09       	add	r9,lr
80007f96:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80007f98:	33 06       	mov	r6,48
80007f9a:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007f9c:	2f f8       	sub	r8,-1
80007f9e:	18 38       	cp.w	r8,r12
80007fa0:	cf d5       	brlt	80007f9a <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80007fa2:	f6 0e 00 0e 	add	lr,r11,lr
80007fa6:	ce cb       	rjmp	80007f7e <PrintDec+0x94>
80007fa8:	fa c8 ff f4 	sub	r8,sp,-12
80007fac:	1c 08       	add	r8,lr
80007fae:	20 d8       	sub	r8,13
80007fb0:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80007fb4:	11 89       	ld.ub	r9,r8[0x0]
80007fb6:	0e c9       	st.b	r7++,r9
80007fb8:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80007fba:	16 38       	cp.w	r8,r11
80007fbc:	cf c1       	brne	80007fb4 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80007fbe:	14 9c       	mov	r12,r10
80007fc0:	2f dd       	sub	sp,-12
80007fc2:	d8 22       	popm	r4-r7,pc

80007fc4 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80007fc4:	d4 31       	pushm	r0-r7,lr
80007fc6:	fa cd 02 08 	sub	sp,sp,520
80007fca:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80007fcc:	e0 6a 01 00 	mov	r10,256
80007fd0:	30 0b       	mov	r11,0
80007fd2:	fa cc fe f8 	sub	r12,sp,-264
80007fd6:	f0 1f 00 4e 	mcall	8000810c <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80007fda:	fa c4 fd d4 	sub	r4,sp,-556
80007fde:	30 0a       	mov	r10,0
80007fe0:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007fe2:	fa c3 ff fc 	sub	r3,sp,-4
80007fe6:	e0 61 01 00 	mov	r1,256
80007fea:	14 90       	mov	r0,r10
			
					if(*str == '%')
80007fec:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007fee:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007ff2:	02 9a       	mov	r10,r1
80007ff4:	00 9b       	mov	r11,r0
80007ff6:	06 9c       	mov	r12,r3
80007ff8:	f0 1f 00 45 	mcall	8000810c <log+0x148>
			
					if(*str == '%')
80007ffc:	0f 88       	ld.ub	r8,r7[0x0]
80007ffe:	e4 08 18 00 	cp.b	r8,r2
80008002:	c5 71       	brne	800080b0 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80008004:	ee c8 ff ff 	sub	r8,r7,-1
80008008:	11 89       	ld.ub	r9,r8[0x0]
8000800a:	4c 2a       	lddpc	r10,80008110 <log+0x14c>
8000800c:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
8000800e:	23 09       	sub	r9,48
80008010:	30 9a       	mov	r10,9
80008012:	f4 09 18 00 	cp.b	r9,r10
80008016:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
8000801a:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000801e:	f7 b9 08 30 	subls	r9,48
80008022:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80008026:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
8000802a:	0f 88       	ld.ub	r8,r7[0x0]
8000802c:	22 58       	sub	r8,37
8000802e:	e0 48 00 53 	cp.w	r8,83
80008032:	e0 8b 00 31 	brhi	80008094 <log+0xd0>
80008036:	4b 89       	lddpc	r9,80008114 <log+0x150>
80008038:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
8000803c:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80008040:	06 9a       	mov	r10,r3
80008042:	40 0b       	lddsp	r11,sp[0x0]
80008044:	5c 5b       	castu.b	r11
80008046:	68 0c       	ld.w	r12,r4[0x0]
80008048:	f0 1f 00 34 	mcall	80008118 <log+0x154>
							break;
8000804c:	c2 98       	rjmp	8000809e <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
8000804e:	4b 4c       	lddpc	r12,8000811c <log+0x158>
80008050:	f0 1f 00 34 	mcall	80008120 <log+0x15c>
80008054:	08 95       	mov	r5,r4
80008056:	06 9c       	mov	r12,r3
							break;
80008058:	c2 38       	rjmp	8000809e <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
8000805a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
8000805e:	06 9a       	mov	r10,r3
80008060:	40 0b       	lddsp	r11,sp[0x0]
80008062:	5c 5b       	castu.b	r11
80008064:	68 0c       	ld.w	r12,r4[0x0]
80008066:	f0 1f 00 30 	mcall	80008124 <log+0x160>
8000806a:	06 9c       	mov	r12,r3
							break;
8000806c:	c1 98       	rjmp	8000809e <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
8000806e:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80008072:	06 9b       	mov	r11,r3
80008074:	09 bc       	ld.ub	r12,r4[0x3]
80008076:	f0 1f 00 2d 	mcall	80008128 <log+0x164>
8000807a:	06 9c       	mov	r12,r3
							break;
8000807c:	c1 18       	rjmp	8000809e <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
8000807e:	e8 c5 ff fc 	sub	r5,r4,-4
80008082:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80008084:	c0 d8       	rjmp	8000809e <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80008086:	06 9b       	mov	r11,r3
80008088:	32 5c       	mov	r12,37
8000808a:	f0 1f 00 28 	mcall	80008128 <log+0x164>
8000808e:	08 95       	mov	r5,r4
80008090:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80008092:	c0 68       	rjmp	8000809e <log+0xda>
							
							default:
							log("I need relax.");
80008094:	4a 6c       	lddpc	r12,8000812c <log+0x168>
80008096:	f0 1f 00 23 	mcall	80008120 <log+0x15c>
8000809a:	08 95       	mov	r5,r4
8000809c:	06 9c       	mov	r12,r3
						}
						str++;
8000809e:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800080a0:	1a dc       	st.w	--sp,r12
800080a2:	1a d6       	st.w	--sp,r6
800080a4:	4a 3b       	lddpc	r11,80008130 <log+0x16c>
800080a6:	0c 9c       	mov	r12,r6
800080a8:	f0 1f 00 23 	mcall	80008134 <log+0x170>
800080ac:	2f ed       	sub	sp,-8
800080ae:	c0 a8       	rjmp	800080c2 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800080b0:	2f f7       	sub	r7,-1
800080b2:	1a d8       	st.w	--sp,r8
800080b4:	1a d6       	st.w	--sp,r6
800080b6:	4a 1b       	lddpc	r11,80008138 <log+0x174>
800080b8:	0c 9c       	mov	r12,r6
800080ba:	f0 1f 00 1f 	mcall	80008134 <log+0x170>
800080be:	08 95       	mov	r5,r4
800080c0:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
800080c2:	0f 89       	ld.ub	r9,r7[0x0]
800080c4:	30 08       	mov	r8,0
800080c6:	f0 09 18 00 	cp.b	r9,r8
800080ca:	c0 30       	breq	800080d0 <log+0x10c>
800080cc:	0a 94       	mov	r4,r5
800080ce:	c9 2b       	rjmp	80007ff2 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
800080d0:	fa c7 fe f8 	sub	r7,sp,-264
800080d4:	1a d7       	st.w	--sp,r7
800080d6:	49 ab       	lddpc	r11,8000813c <log+0x178>
800080d8:	0e 9c       	mov	r12,r7
800080da:	f0 1f 00 17 	mcall	80008134 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
800080de:	5c 5c       	castu.b	r12
800080e0:	f8 c6 ff ff 	sub	r6,r12,-1
800080e4:	0c 9c       	mov	r12,r6
800080e6:	f0 1f 00 17 	mcall	80008140 <log+0x17c>
800080ea:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
800080ec:	0c 9a       	mov	r10,r6
800080ee:	0e 9b       	mov	r11,r7
800080f0:	f0 1f 00 15 	mcall	80008144 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
800080f4:	30 09       	mov	r9,0
800080f6:	30 5a       	mov	r10,5
800080f8:	fa cb fe f8 	sub	r11,sp,-264
800080fc:	49 38       	lddpc	r8,80008148 <log+0x184>
800080fe:	70 0c       	ld.w	r12,r8[0x0]
80008100:	f0 1f 00 13 	mcall	8000814c <log+0x188>
80008104:	2f fd       	sub	sp,-4
	
	
}
80008106:	fe 3d fd f8 	sub	sp,-520
8000810a:	d8 32       	popm	r0-r7,pc
8000810c:	80 00       	ld.sh	r0,r0[0x0]
8000810e:	89 b6       	st.w	r4[0x2c],r6
80008110:	00 00       	add	r0,r0
80008112:	0d dc       	ld.ub	r12,r6[0x5]
80008114:	80 00       	ld.sh	r0,r0[0x0]
80008116:	ed b0       	*unknown*
80008118:	80 00       	ld.sh	r0,r0[0x0]
8000811a:	7e ea       	ld.w	r10,pc[0x38]
8000811c:	80 00       	ld.sh	r0,r0[0x0]
8000811e:	f0 5c 80 00 	cp.w	r12,-950272
80008122:	7f c4       	ld.w	r4,pc[0x70]
80008124:	80 00       	ld.sh	r0,r0[0x0]
80008126:	7e 38       	ld.w	r8,pc[0xc]
80008128:	80 00       	ld.sh	r0,r0[0x0]
8000812a:	7e 34       	ld.w	r4,pc[0xc]
8000812c:	80 00       	ld.sh	r0,r0[0x0]
8000812e:	f0 6c 80 00 	mov	r12,-1015808
80008132:	f0 7c 80 00 	mov	r12,-950272
80008136:	8c a4       	ld.uh	r4,r6[0x4]
80008138:	80 00       	ld.sh	r0,r0[0x0]
8000813a:	f0 84 80 00 	brge	7fe1813a <_estack+0x7fe0013a>
8000813e:	f0 8c 80 00 	brvs	7fe1813e <_estack+0x7fe0013e>
80008142:	70 38       	ld.w	r8,r8[0xc]
80008144:	80 00       	ld.sh	r0,r0[0x0]
80008146:	88 6e       	ld.sh	lr,r4[0xc]
80008148:	00 00       	add	r0,r0
8000814a:	bd 4c       	asr	r12,0x1c
8000814c:	80 00       	ld.sh	r0,r0[0x0]
8000814e:	73 8c       	ld.w	r12,r9[0x60]

80008150 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80008150:	d4 31       	pushm	r0-r7,lr
80008152:	fa cd 02 0c 	sub	sp,sp,524
80008156:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80008158:	e0 6a 01 00 	mov	r10,256
8000815c:	30 0b       	mov	r11,0
8000815e:	fa cc fe f4 	sub	r12,sp,-268
80008162:	f0 1f 00 4c 	mcall	80008290 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80008166:	fa c4 fd d0 	sub	r4,sp,-560
8000816a:	30 0a       	mov	r10,0
8000816c:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000816e:	fa c3 ff fc 	sub	r3,sp,-4
80008172:	e0 61 01 00 	mov	r1,256
80008176:	14 90       	mov	r0,r10
			
			if(*str == '%')
80008178:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000817a:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000817e:	02 9a       	mov	r10,r1
80008180:	00 9b       	mov	r11,r0
80008182:	06 9c       	mov	r12,r3
80008184:	f0 1f 00 43 	mcall	80008290 <logFromISR+0x140>
			
			if(*str == '%')
80008188:	0f 88       	ld.ub	r8,r7[0x0]
8000818a:	e4 08 18 00 	cp.b	r8,r2
8000818e:	c5 11       	brne	80008230 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80008190:	ee c8 ff ff 	sub	r8,r7,-1
80008194:	11 89       	ld.ub	r9,r8[0x0]
80008196:	4c 0a       	lddpc	r10,80008294 <logFromISR+0x144>
80008198:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
8000819a:	23 09       	sub	r9,48
8000819c:	30 9a       	mov	r10,9
8000819e:	f4 09 18 00 	cp.b	r9,r10
800081a2:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
800081a6:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800081aa:	f7 b9 08 30 	subls	r9,48
800081ae:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
800081b2:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
800081b6:	0f 88       	ld.ub	r8,r7[0x0]
800081b8:	22 58       	sub	r8,37
800081ba:	e0 48 00 53 	cp.w	r8,83
800081be:	e0 8b 00 2b 	brhi	80008214 <logFromISR+0xc4>
800081c2:	4b 69       	lddpc	r9,80008298 <logFromISR+0x148>
800081c4:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
800081c8:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
800081cc:	06 9a       	mov	r10,r3
800081ce:	40 0b       	lddsp	r11,sp[0x0]
800081d0:	5c 5b       	castu.b	r11
800081d2:	68 0c       	ld.w	r12,r4[0x0]
800081d4:	f0 1f 00 32 	mcall	8000829c <logFromISR+0x14c>
					break;
800081d8:	c2 38       	rjmp	8000821e <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
800081da:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
800081de:	06 9a       	mov	r10,r3
800081e0:	40 0b       	lddsp	r11,sp[0x0]
800081e2:	5c 5b       	castu.b	r11
800081e4:	68 0c       	ld.w	r12,r4[0x0]
800081e6:	f0 1f 00 2f 	mcall	800082a0 <logFromISR+0x150>
800081ea:	06 9c       	mov	r12,r3
					break;
800081ec:	c1 98       	rjmp	8000821e <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
800081ee:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
800081f2:	06 9b       	mov	r11,r3
800081f4:	09 bc       	ld.ub	r12,r4[0x3]
800081f6:	f0 1f 00 2c 	mcall	800082a4 <logFromISR+0x154>
800081fa:	06 9c       	mov	r12,r3
					break;
800081fc:	c1 18       	rjmp	8000821e <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
800081fe:	e8 c5 ff fc 	sub	r5,r4,-4
80008202:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80008204:	c0 d8       	rjmp	8000821e <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80008206:	06 9b       	mov	r11,r3
80008208:	32 5c       	mov	r12,37
8000820a:	f0 1f 00 27 	mcall	800082a4 <logFromISR+0x154>
8000820e:	08 95       	mov	r5,r4
80008210:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80008212:	c0 68       	rjmp	8000821e <logFromISR+0xce>
					default:
					log("I need relax.");
80008214:	4a 5c       	lddpc	r12,800082a8 <logFromISR+0x158>
80008216:	f0 1f 00 26 	mcall	800082ac <logFromISR+0x15c>
8000821a:	08 95       	mov	r5,r4
8000821c:	06 9c       	mov	r12,r3
				}
				str++;
8000821e:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80008220:	1a dc       	st.w	--sp,r12
80008222:	1a d6       	st.w	--sp,r6
80008224:	4a 3b       	lddpc	r11,800082b0 <logFromISR+0x160>
80008226:	0c 9c       	mov	r12,r6
80008228:	f0 1f 00 23 	mcall	800082b4 <logFromISR+0x164>
8000822c:	2f ed       	sub	sp,-8
8000822e:	c0 a8       	rjmp	80008242 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80008230:	2f f7       	sub	r7,-1
80008232:	1a d8       	st.w	--sp,r8
80008234:	1a d6       	st.w	--sp,r6
80008236:	4a 1b       	lddpc	r11,800082b8 <logFromISR+0x168>
80008238:	0c 9c       	mov	r12,r6
8000823a:	f0 1f 00 1f 	mcall	800082b4 <logFromISR+0x164>
8000823e:	08 95       	mov	r5,r4
80008240:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80008242:	0f 89       	ld.ub	r9,r7[0x0]
80008244:	30 08       	mov	r8,0
80008246:	f0 09 18 00 	cp.b	r9,r8
8000824a:	c0 30       	breq	80008250 <logFromISR+0x100>
8000824c:	0a 94       	mov	r4,r5
8000824e:	c9 8b       	rjmp	8000817e <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80008250:	fa c7 fe f4 	sub	r7,sp,-268
80008254:	1a d7       	st.w	--sp,r7
80008256:	49 ab       	lddpc	r11,800082bc <logFromISR+0x16c>
80008258:	0e 9c       	mov	r12,r7
8000825a:	f0 1f 00 17 	mcall	800082b4 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
8000825e:	5c 5c       	castu.b	r12
80008260:	f8 c6 ff ff 	sub	r6,r12,-1
80008264:	0c 9c       	mov	r12,r6
80008266:	f0 1f 00 17 	mcall	800082c0 <logFromISR+0x170>
8000826a:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
8000826c:	0c 9a       	mov	r10,r6
8000826e:	0e 9b       	mov	r11,r7
80008270:	f0 1f 00 15 	mcall	800082c4 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80008274:	30 09       	mov	r9,0
80008276:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80008278:	fa ca fe f8 	sub	r10,sp,-264
8000827c:	fa cb fe f4 	sub	r11,sp,-268
80008280:	49 28       	lddpc	r8,800082c8 <logFromISR+0x178>
80008282:	70 0c       	ld.w	r12,r8[0x0]
80008284:	f0 1f 00 12 	mcall	800082cc <logFromISR+0x17c>
80008288:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
8000828a:	fe 3d fd f4 	sub	sp,-524
8000828e:	d8 32       	popm	r0-r7,pc
80008290:	80 00       	ld.sh	r0,r0[0x0]
80008292:	89 b6       	st.w	r4[0x2c],r6
80008294:	00 00       	add	r0,r0
80008296:	0d dd       	ld.ub	sp,r6[0x5]
80008298:	80 00       	ld.sh	r0,r0[0x0]
8000829a:	ef 00 80 00 	ld.sh	r0,r7[-32768]
8000829e:	7e ea       	ld.w	r10,pc[0x38]
800082a0:	80 00       	ld.sh	r0,r0[0x0]
800082a2:	7e 38       	ld.w	r8,pc[0xc]
800082a4:	80 00       	ld.sh	r0,r0[0x0]
800082a6:	7e 34       	ld.w	r4,pc[0xc]
800082a8:	80 00       	ld.sh	r0,r0[0x0]
800082aa:	f0 6c 80 00 	mov	r12,-1015808
800082ae:	7f c4       	ld.w	r4,pc[0x70]
800082b0:	80 00       	ld.sh	r0,r0[0x0]
800082b2:	f0 7c 80 00 	mov	r12,-950272
800082b6:	8c a4       	ld.uh	r4,r6[0x4]
800082b8:	80 00       	ld.sh	r0,r0[0x0]
800082ba:	f0 84 80 00 	brge	7fe182ba <_estack+0x7fe002ba>
800082be:	f0 8c 80 00 	brvs	7fe182be <_estack+0x7fe002be>
800082c2:	70 38       	ld.w	r8,r8[0xc]
800082c4:	80 00       	ld.sh	r0,r0[0x0]
800082c6:	88 6e       	ld.sh	lr,r4[0xc]
800082c8:	00 00       	add	r0,r0
800082ca:	bd 4c       	asr	r12,0x1c
800082cc:	80 00       	ld.sh	r0,r0[0x0]
800082ce:	73 3c       	ld.w	r12,r9[0x4c]

800082d0 <log_init>:
		
	return str;
}

void log_init(void)
{
800082d0:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
800082d2:	30 2b       	mov	r11,2
800082d4:	48 fc       	lddpc	r12,80008310 <log_init+0x40>
800082d6:	f0 1f 00 10 	mcall	80008314 <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
800082da:	e0 6a 36 00 	mov	r10,13824
800082de:	ea 1a 01 6e 	orh	r10,0x16e
800082e2:	48 eb       	lddpc	r11,80008318 <log_init+0x48>
800082e4:	fe 7c 18 00 	mov	r12,-59392
800082e8:	f0 1f 00 0d 	mcall	8000831c <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
800082ec:	30 4b       	mov	r11,4
800082ee:	33 2c       	mov	r12,50
800082f0:	f0 1f 00 0c 	mcall	80008320 <log_init+0x50>
800082f4:	48 c8       	lddpc	r8,80008324 <log_init+0x54>
800082f6:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
800082f8:	30 09       	mov	r9,0
800082fa:	1a d9       	st.w	--sp,r9
800082fc:	1a d9       	st.w	--sp,r9
800082fe:	1a d9       	st.w	--sp,r9
80008300:	30 28       	mov	r8,2
80008302:	36 4a       	mov	r10,100
80008304:	48 9b       	lddpc	r11,80008328 <log_init+0x58>
80008306:	48 ac       	lddpc	r12,8000832c <log_init+0x5c>
80008308:	f0 1f 00 0a 	mcall	80008330 <log_init+0x60>
8000830c:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
8000830e:	d8 02       	popm	pc
80008310:	80 00       	ld.sh	r0,r0[0x0]
80008312:	f0 98 80 00 	brls	7fe38312 <_estack+0x7fe20312>
80008316:	63 a8       	ld.w	r8,r1[0x68]
80008318:	80 00       	ld.sh	r0,r0[0x0]
8000831a:	f0 50 80 00 	cp.w	r0,-950272
8000831e:	6b 9c       	ld.w	r12,r5[0x64]
80008320:	80 00       	ld.sh	r0,r0[0x0]
80008322:	74 e4       	ld.w	r4,r10[0x38]
80008324:	00 00       	add	r0,r0
80008326:	bd 4c       	asr	r12,0x1c
80008328:	80 00       	ld.sh	r0,r0[0x0]
8000832a:	f0 94 80 00 	brge	7fe3832a <_estack+0x7fe2032a>
8000832e:	83 34       	st.w	r1[0xc],r4
80008330:	80 00       	ld.sh	r0,r0[0x0]
80008332:	7c 00       	ld.w	r0,lr[0x0]

80008334 <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
80008334:	eb cd 40 f8 	pushm	r3-r7,lr
80008338:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000833a:	48 c7       	lddpc	r7,80008368 <task_log+0x34>
8000833c:	30 05       	mov	r5,0
8000833e:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80008340:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80008344:	0a 99       	mov	r9,r5
80008346:	08 9a       	mov	r10,r4
80008348:	1a 9b       	mov	r11,sp
8000834a:	6e 0c       	ld.w	r12,r7[0x0]
8000834c:	f0 1f 00 08 	mcall	8000836c <task_log+0x38>
80008350:	58 1c       	cp.w	r12,1
80008352:	cf 91       	brne	80008344 <task_log+0x10>
		{
			if( NULL != str)
80008354:	40 0b       	lddsp	r11,sp[0x0]
80008356:	58 0b       	cp.w	r11,0
80008358:	cf 60       	breq	80008344 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
8000835a:	06 9c       	mov	r12,r3
8000835c:	f0 1f 00 05 	mcall	80008370 <task_log+0x3c>
				vPortFree(str);
80008360:	40 0c       	lddsp	r12,sp[0x0]
80008362:	f0 1f 00 05 	mcall	80008374 <task_log+0x40>
80008366:	ce fb       	rjmp	80008344 <task_log+0x10>
80008368:	00 00       	add	r0,r0
8000836a:	bd 4c       	asr	r12,0x1c
8000836c:	80 00       	ld.sh	r0,r0[0x0]
8000836e:	71 80       	ld.w	r0,r8[0x60]
80008370:	80 00       	ld.sh	r0,r0[0x0]
80008372:	6b 4c       	ld.w	r12,r5[0x50]
80008374:	80 00       	ld.sh	r0,r0[0x0]
80008376:	70 10       	ld.w	r0,r8[0x4]

80008378 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
80008378:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
8000837a:	fe 78 10 00 	mov	r8,-61440
8000837e:	30 19       	mov	r9,1
80008380:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80008384:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80008388:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
8000838c:	d3 03       	ssrf	0x10
	local_start_pll0();
8000838e:	f0 1f 00 0d 	mcall	800083c0 <main+0x48>
		
	INTC_init_interrupts();
80008392:	f0 1f 00 0d 	mcall	800083c4 <main+0x4c>
		
	log_init();
80008396:	f0 1f 00 0d 	mcall	800083c8 <main+0x50>
	log("----start debug----");
8000839a:	48 dc       	lddpc	r12,800083cc <main+0x54>
8000839c:	f0 1f 00 0d 	mcall	800083d0 <main+0x58>
	
	xg_flashc_init();
800083a0:	f0 1f 00 0d 	mcall	800083d4 <main+0x5c>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
800083a4:	f0 1f 00 0d 	mcall	800083d8 <main+0x60>
		
	app_init();
800083a8:	f0 1f 00 0d 	mcall	800083dc <main+0x64>
	
	xg_rtc_init();
800083ac:	f0 1f 00 0d 	mcall	800083e0 <main+0x68>
		
	xcmp_init();
800083b0:	f0 1f 00 0d 	mcall	800083e4 <main+0x6c>

	local_start_timer();
800083b4:	f0 1f 00 0d 	mcall	800083e8 <main+0x70>
		
	vTaskStartScheduler();
800083b8:	f0 1f 00 0d 	mcall	800083ec <main+0x74>
	return 0;
	
}
800083bc:	d8 0a       	popm	pc,r12=0
800083be:	00 00       	add	r0,r0
800083c0:	80 00       	ld.sh	r0,r0[0x0]
800083c2:	5c e4       	tnbz	r4
800083c4:	80 00       	ld.sh	r0,r0[0x0]
800083c6:	64 ac       	ld.w	r12,r2[0x28]
800083c8:	80 00       	ld.sh	r0,r0[0x0]
800083ca:	82 d0       	ld.uh	r0,r1[0xa]
800083cc:	80 00       	ld.sh	r0,r0[0x0]
800083ce:	f0 a8       	*unknown*
800083d0:	80 00       	ld.sh	r0,r0[0x0]
800083d2:	7f c4       	ld.w	r4,pc[0x70]
800083d4:	80 00       	ld.sh	r0,r0[0x0]
800083d6:	5d 78       	*unknown*
800083d8:	80 00       	ld.sh	r0,r0[0x0]
800083da:	5c 44       	abs	r4
800083dc:	80 00       	ld.sh	r0,r0[0x0]
800083de:	27 44       	sub	r4,116
800083e0:	80 00       	ld.sh	r0,r0[0x0]
800083e2:	33 90       	mov	r0,57
800083e4:	80 00       	ld.sh	r0,r0[0x0]
800083e6:	4a 6c       	lddpc	r12,8000847c <_malloc_r+0x6c>
800083e8:	80 00       	ld.sh	r0,r0[0x0]
800083ea:	5c b8       	swap.b	r8
800083ec:	80 00       	ld.sh	r0,r0[0x0]
800083ee:	7d e8       	ld.w	r8,lr[0x78]

800083f0 <free>:
800083f0:	d4 01       	pushm	lr
800083f2:	e0 68 0a 54 	mov	r8,2644
800083f6:	18 9b       	mov	r11,r12
800083f8:	70 0c       	ld.w	r12,r8[0x0]
800083fa:	e0 a0 1e 73 	rcall	8000c0e0 <_free_r>
800083fe:	d8 02       	popm	pc

80008400 <malloc>:
80008400:	d4 01       	pushm	lr
80008402:	e0 68 0a 54 	mov	r8,2644
80008406:	18 9b       	mov	r11,r12
80008408:	70 0c       	ld.w	r12,r8[0x0]
8000840a:	c0 3c       	rcall	80008410 <_malloc_r>
8000840c:	d8 02       	popm	pc
8000840e:	d7 03       	nop

80008410 <_malloc_r>:
80008410:	d4 31       	pushm	r0-r7,lr
80008412:	f6 c8 ff f5 	sub	r8,r11,-11
80008416:	18 95       	mov	r5,r12
80008418:	10 97       	mov	r7,r8
8000841a:	e0 17 ff f8 	andl	r7,0xfff8
8000841e:	59 68       	cp.w	r8,22
80008420:	f9 b7 08 10 	movls	r7,16
80008424:	16 37       	cp.w	r7,r11
80008426:	5f 38       	srlo	r8
80008428:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
8000842c:	c0 50       	breq	80008436 <_malloc_r+0x26>
8000842e:	30 c8       	mov	r8,12
80008430:	99 38       	st.w	r12[0xc],r8
80008432:	e0 8f 01 fa 	bral	80008826 <_malloc_r+0x416>
80008436:	fe b0 f5 a3 	rcall	80006f7c <__malloc_lock>
8000843a:	e0 47 01 f7 	cp.w	r7,503
8000843e:	e0 8b 00 1d 	brhi	80008478 <_malloc_r+0x68>
80008442:	ee 03 16 03 	lsr	r3,r7,0x3
80008446:	e0 68 05 54 	mov	r8,1364
8000844a:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000844e:	70 36       	ld.w	r6,r8[0xc]
80008450:	10 36       	cp.w	r6,r8
80008452:	c0 61       	brne	8000845e <_malloc_r+0x4e>
80008454:	ec c8 ff f8 	sub	r8,r6,-8
80008458:	70 36       	ld.w	r6,r8[0xc]
8000845a:	10 36       	cp.w	r6,r8
8000845c:	c0 c0       	breq	80008474 <_malloc_r+0x64>
8000845e:	6c 18       	ld.w	r8,r6[0x4]
80008460:	e0 18 ff fc 	andl	r8,0xfffc
80008464:	6c 3a       	ld.w	r10,r6[0xc]
80008466:	ec 08 00 09 	add	r9,r6,r8
8000846a:	0a 9c       	mov	r12,r5
8000846c:	6c 28       	ld.w	r8,r6[0x8]
8000846e:	95 28       	st.w	r10[0x8],r8
80008470:	91 3a       	st.w	r8[0xc],r10
80008472:	c4 78       	rjmp	80008500 <_malloc_r+0xf0>
80008474:	2f e3       	sub	r3,-2
80008476:	c4 d8       	rjmp	80008510 <_malloc_r+0x100>
80008478:	ee 03 16 09 	lsr	r3,r7,0x9
8000847c:	c0 41       	brne	80008484 <_malloc_r+0x74>
8000847e:	ee 03 16 03 	lsr	r3,r7,0x3
80008482:	c2 68       	rjmp	800084ce <_malloc_r+0xbe>
80008484:	58 43       	cp.w	r3,4
80008486:	e0 8b 00 06 	brhi	80008492 <_malloc_r+0x82>
8000848a:	ee 03 16 06 	lsr	r3,r7,0x6
8000848e:	2c 83       	sub	r3,-56
80008490:	c1 f8       	rjmp	800084ce <_malloc_r+0xbe>
80008492:	59 43       	cp.w	r3,20
80008494:	e0 8b 00 04 	brhi	8000849c <_malloc_r+0x8c>
80008498:	2a 53       	sub	r3,-91
8000849a:	c1 a8       	rjmp	800084ce <_malloc_r+0xbe>
8000849c:	e0 43 00 54 	cp.w	r3,84
800084a0:	e0 8b 00 06 	brhi	800084ac <_malloc_r+0x9c>
800084a4:	ee 03 16 0c 	lsr	r3,r7,0xc
800084a8:	29 23       	sub	r3,-110
800084aa:	c1 28       	rjmp	800084ce <_malloc_r+0xbe>
800084ac:	e0 43 01 54 	cp.w	r3,340
800084b0:	e0 8b 00 06 	brhi	800084bc <_malloc_r+0xac>
800084b4:	ee 03 16 0f 	lsr	r3,r7,0xf
800084b8:	28 93       	sub	r3,-119
800084ba:	c0 a8       	rjmp	800084ce <_malloc_r+0xbe>
800084bc:	e0 43 05 54 	cp.w	r3,1364
800084c0:	e0 88 00 04 	brls	800084c8 <_malloc_r+0xb8>
800084c4:	37 e3       	mov	r3,126
800084c6:	c0 48       	rjmp	800084ce <_malloc_r+0xbe>
800084c8:	ee 03 16 12 	lsr	r3,r7,0x12
800084cc:	28 43       	sub	r3,-124
800084ce:	e0 6a 05 54 	mov	r10,1364
800084d2:	f4 03 00 3a 	add	r10,r10,r3<<0x3
800084d6:	74 36       	ld.w	r6,r10[0xc]
800084d8:	c1 98       	rjmp	8000850a <_malloc_r+0xfa>
800084da:	6c 19       	ld.w	r9,r6[0x4]
800084dc:	e0 19 ff fc 	andl	r9,0xfffc
800084e0:	f2 07 01 0b 	sub	r11,r9,r7
800084e4:	58 fb       	cp.w	r11,15
800084e6:	e0 8a 00 04 	brle	800084ee <_malloc_r+0xde>
800084ea:	20 13       	sub	r3,1
800084ec:	c1 18       	rjmp	8000850e <_malloc_r+0xfe>
800084ee:	6c 38       	ld.w	r8,r6[0xc]
800084f0:	58 0b       	cp.w	r11,0
800084f2:	c0 b5       	brlt	80008508 <_malloc_r+0xf8>
800084f4:	6c 2a       	ld.w	r10,r6[0x8]
800084f6:	ec 09 00 09 	add	r9,r6,r9
800084fa:	0a 9c       	mov	r12,r5
800084fc:	91 2a       	st.w	r8[0x8],r10
800084fe:	95 38       	st.w	r10[0xc],r8
80008500:	72 18       	ld.w	r8,r9[0x4]
80008502:	a1 a8       	sbr	r8,0x0
80008504:	93 18       	st.w	r9[0x4],r8
80008506:	cb c8       	rjmp	8000867e <_malloc_r+0x26e>
80008508:	10 96       	mov	r6,r8
8000850a:	14 36       	cp.w	r6,r10
8000850c:	ce 71       	brne	800084da <_malloc_r+0xca>
8000850e:	2f f3       	sub	r3,-1
80008510:	e0 6a 05 54 	mov	r10,1364
80008514:	f4 cc ff f8 	sub	r12,r10,-8
80008518:	78 26       	ld.w	r6,r12[0x8]
8000851a:	18 36       	cp.w	r6,r12
8000851c:	c6 c0       	breq	800085f4 <_malloc_r+0x1e4>
8000851e:	6c 19       	ld.w	r9,r6[0x4]
80008520:	e0 19 ff fc 	andl	r9,0xfffc
80008524:	f2 07 01 08 	sub	r8,r9,r7
80008528:	58 f8       	cp.w	r8,15
8000852a:	e0 89 00 8f 	brgt	80008648 <_malloc_r+0x238>
8000852e:	99 3c       	st.w	r12[0xc],r12
80008530:	99 2c       	st.w	r12[0x8],r12
80008532:	58 08       	cp.w	r8,0
80008534:	c0 55       	brlt	8000853e <_malloc_r+0x12e>
80008536:	ec 09 00 09 	add	r9,r6,r9
8000853a:	0a 9c       	mov	r12,r5
8000853c:	ce 2b       	rjmp	80008500 <_malloc_r+0xf0>
8000853e:	e0 49 01 ff 	cp.w	r9,511
80008542:	e0 8b 00 13 	brhi	80008568 <_malloc_r+0x158>
80008546:	a3 99       	lsr	r9,0x3
80008548:	f4 09 00 38 	add	r8,r10,r9<<0x3
8000854c:	70 2b       	ld.w	r11,r8[0x8]
8000854e:	8d 38       	st.w	r6[0xc],r8
80008550:	8d 2b       	st.w	r6[0x8],r11
80008552:	97 36       	st.w	r11[0xc],r6
80008554:	91 26       	st.w	r8[0x8],r6
80008556:	a3 49       	asr	r9,0x2
80008558:	74 18       	ld.w	r8,r10[0x4]
8000855a:	30 1b       	mov	r11,1
8000855c:	f6 09 09 49 	lsl	r9,r11,r9
80008560:	f1 e9 10 09 	or	r9,r8,r9
80008564:	95 19       	st.w	r10[0x4],r9
80008566:	c4 78       	rjmp	800085f4 <_malloc_r+0x1e4>
80008568:	f2 0a 16 09 	lsr	r10,r9,0x9
8000856c:	58 4a       	cp.w	r10,4
8000856e:	e0 8b 00 07 	brhi	8000857c <_malloc_r+0x16c>
80008572:	f2 0a 16 06 	lsr	r10,r9,0x6
80008576:	2c 8a       	sub	r10,-56
80008578:	c2 08       	rjmp	800085b8 <_malloc_r+0x1a8>
8000857a:	d7 03       	nop
8000857c:	59 4a       	cp.w	r10,20
8000857e:	e0 8b 00 04 	brhi	80008586 <_malloc_r+0x176>
80008582:	2a 5a       	sub	r10,-91
80008584:	c1 a8       	rjmp	800085b8 <_malloc_r+0x1a8>
80008586:	e0 4a 00 54 	cp.w	r10,84
8000858a:	e0 8b 00 06 	brhi	80008596 <_malloc_r+0x186>
8000858e:	f2 0a 16 0c 	lsr	r10,r9,0xc
80008592:	29 2a       	sub	r10,-110
80008594:	c1 28       	rjmp	800085b8 <_malloc_r+0x1a8>
80008596:	e0 4a 01 54 	cp.w	r10,340
8000859a:	e0 8b 00 06 	brhi	800085a6 <_malloc_r+0x196>
8000859e:	f2 0a 16 0f 	lsr	r10,r9,0xf
800085a2:	28 9a       	sub	r10,-119
800085a4:	c0 a8       	rjmp	800085b8 <_malloc_r+0x1a8>
800085a6:	e0 4a 05 54 	cp.w	r10,1364
800085aa:	e0 88 00 04 	brls	800085b2 <_malloc_r+0x1a2>
800085ae:	37 ea       	mov	r10,126
800085b0:	c0 48       	rjmp	800085b8 <_malloc_r+0x1a8>
800085b2:	f2 0a 16 12 	lsr	r10,r9,0x12
800085b6:	28 4a       	sub	r10,-124
800085b8:	e0 6b 05 54 	mov	r11,1364
800085bc:	f6 0a 00 34 	add	r4,r11,r10<<0x3
800085c0:	68 28       	ld.w	r8,r4[0x8]
800085c2:	08 38       	cp.w	r8,r4
800085c4:	c0 e1       	brne	800085e0 <_malloc_r+0x1d0>
800085c6:	76 19       	ld.w	r9,r11[0x4]
800085c8:	a3 4a       	asr	r10,0x2
800085ca:	30 1e       	mov	lr,1
800085cc:	fc 0a 09 4a 	lsl	r10,lr,r10
800085d0:	f3 ea 10 0a 	or	r10,r9,r10
800085d4:	10 99       	mov	r9,r8
800085d6:	97 1a       	st.w	r11[0x4],r10
800085d8:	c0 a8       	rjmp	800085ec <_malloc_r+0x1dc>
800085da:	70 28       	ld.w	r8,r8[0x8]
800085dc:	08 38       	cp.w	r8,r4
800085de:	c0 60       	breq	800085ea <_malloc_r+0x1da>
800085e0:	70 1a       	ld.w	r10,r8[0x4]
800085e2:	e0 1a ff fc 	andl	r10,0xfffc
800085e6:	14 39       	cp.w	r9,r10
800085e8:	cf 93       	brcs	800085da <_malloc_r+0x1ca>
800085ea:	70 39       	ld.w	r9,r8[0xc]
800085ec:	8d 39       	st.w	r6[0xc],r9
800085ee:	8d 28       	st.w	r6[0x8],r8
800085f0:	91 36       	st.w	r8[0xc],r6
800085f2:	93 26       	st.w	r9[0x8],r6
800085f4:	e6 08 14 02 	asr	r8,r3,0x2
800085f8:	30 1b       	mov	r11,1
800085fa:	e0 64 05 54 	mov	r4,1364
800085fe:	f6 08 09 4b 	lsl	r11,r11,r8
80008602:	68 18       	ld.w	r8,r4[0x4]
80008604:	10 3b       	cp.w	r11,r8
80008606:	e0 8b 00 6b 	brhi	800086dc <_malloc_r+0x2cc>
8000860a:	f7 e8 00 09 	and	r9,r11,r8
8000860e:	c0 b1       	brne	80008624 <_malloc_r+0x214>
80008610:	e0 13 ff fc 	andl	r3,0xfffc
80008614:	a1 7b       	lsl	r11,0x1
80008616:	2f c3       	sub	r3,-4
80008618:	c0 38       	rjmp	8000861e <_malloc_r+0x20e>
8000861a:	2f c3       	sub	r3,-4
8000861c:	a1 7b       	lsl	r11,0x1
8000861e:	f7 e8 00 09 	and	r9,r11,r8
80008622:	cf c0       	breq	8000861a <_malloc_r+0x20a>
80008624:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80008628:	06 92       	mov	r2,r3
8000862a:	1c 91       	mov	r1,lr
8000862c:	62 36       	ld.w	r6,r1[0xc]
8000862e:	c2 e8       	rjmp	8000868a <_malloc_r+0x27a>
80008630:	6c 1a       	ld.w	r10,r6[0x4]
80008632:	e0 1a ff fc 	andl	r10,0xfffc
80008636:	f4 07 01 08 	sub	r8,r10,r7
8000863a:	58 f8       	cp.w	r8,15
8000863c:	e0 8a 00 15 	brle	80008666 <_malloc_r+0x256>
80008640:	6c 3a       	ld.w	r10,r6[0xc]
80008642:	6c 29       	ld.w	r9,r6[0x8]
80008644:	95 29       	st.w	r10[0x8],r9
80008646:	93 3a       	st.w	r9[0xc],r10
80008648:	0e 99       	mov	r9,r7
8000864a:	ec 07 00 07 	add	r7,r6,r7
8000864e:	a1 a9       	sbr	r9,0x0
80008650:	99 37       	st.w	r12[0xc],r7
80008652:	99 27       	st.w	r12[0x8],r7
80008654:	8d 19       	st.w	r6[0x4],r9
80008656:	ee 08 09 08 	st.w	r7[r8],r8
8000865a:	8f 2c       	st.w	r7[0x8],r12
8000865c:	8f 3c       	st.w	r7[0xc],r12
8000865e:	a1 a8       	sbr	r8,0x0
80008660:	0a 9c       	mov	r12,r5
80008662:	8f 18       	st.w	r7[0x4],r8
80008664:	c0 d8       	rjmp	8000867e <_malloc_r+0x26e>
80008666:	6c 39       	ld.w	r9,r6[0xc]
80008668:	58 08       	cp.w	r8,0
8000866a:	c0 f5       	brlt	80008688 <_malloc_r+0x278>
8000866c:	ec 0a 00 0a 	add	r10,r6,r10
80008670:	74 18       	ld.w	r8,r10[0x4]
80008672:	a1 a8       	sbr	r8,0x0
80008674:	0a 9c       	mov	r12,r5
80008676:	95 18       	st.w	r10[0x4],r8
80008678:	6c 28       	ld.w	r8,r6[0x8]
8000867a:	93 28       	st.w	r9[0x8],r8
8000867c:	91 39       	st.w	r8[0xc],r9
8000867e:	fe b0 f4 85 	rcall	80006f88 <__malloc_unlock>
80008682:	ec cc ff f8 	sub	r12,r6,-8
80008686:	d8 32       	popm	r0-r7,pc
80008688:	12 96       	mov	r6,r9
8000868a:	02 36       	cp.w	r6,r1
8000868c:	cd 21       	brne	80008630 <_malloc_r+0x220>
8000868e:	2f f2       	sub	r2,-1
80008690:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80008694:	c0 30       	breq	8000869a <_malloc_r+0x28a>
80008696:	2f 81       	sub	r1,-8
80008698:	cc ab       	rjmp	8000862c <_malloc_r+0x21c>
8000869a:	1c 98       	mov	r8,lr
8000869c:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
800086a0:	c0 81       	brne	800086b0 <_malloc_r+0x2a0>
800086a2:	68 19       	ld.w	r9,r4[0x4]
800086a4:	f6 08 11 ff 	rsub	r8,r11,-1
800086a8:	f3 e8 00 08 	and	r8,r9,r8
800086ac:	89 18       	st.w	r4[0x4],r8
800086ae:	c0 78       	rjmp	800086bc <_malloc_r+0x2ac>
800086b0:	f0 c9 00 08 	sub	r9,r8,8
800086b4:	20 13       	sub	r3,1
800086b6:	70 08       	ld.w	r8,r8[0x0]
800086b8:	12 38       	cp.w	r8,r9
800086ba:	cf 10       	breq	8000869c <_malloc_r+0x28c>
800086bc:	a1 7b       	lsl	r11,0x1
800086be:	68 18       	ld.w	r8,r4[0x4]
800086c0:	10 3b       	cp.w	r11,r8
800086c2:	e0 8b 00 0d 	brhi	800086dc <_malloc_r+0x2cc>
800086c6:	58 0b       	cp.w	r11,0
800086c8:	c0 a0       	breq	800086dc <_malloc_r+0x2cc>
800086ca:	04 93       	mov	r3,r2
800086cc:	c0 38       	rjmp	800086d2 <_malloc_r+0x2c2>
800086ce:	2f c3       	sub	r3,-4
800086d0:	a1 7b       	lsl	r11,0x1
800086d2:	f7 e8 00 09 	and	r9,r11,r8
800086d6:	ca 71       	brne	80008624 <_malloc_r+0x214>
800086d8:	cf bb       	rjmp	800086ce <_malloc_r+0x2be>
800086da:	d7 03       	nop
800086dc:	68 23       	ld.w	r3,r4[0x8]
800086de:	66 12       	ld.w	r2,r3[0x4]
800086e0:	e0 12 ff fc 	andl	r2,0xfffc
800086e4:	0e 32       	cp.w	r2,r7
800086e6:	5f 39       	srlo	r9
800086e8:	e4 07 01 08 	sub	r8,r2,r7
800086ec:	58 f8       	cp.w	r8,15
800086ee:	5f aa       	srle	r10
800086f0:	f5 e9 10 09 	or	r9,r10,r9
800086f4:	e0 80 00 9a 	breq	80008828 <_malloc_r+0x418>
800086f8:	e0 68 0d e8 	mov	r8,3560
800086fc:	70 01       	ld.w	r1,r8[0x0]
800086fe:	e0 68 09 60 	mov	r8,2400
80008702:	2f 01       	sub	r1,-16
80008704:	70 08       	ld.w	r8,r8[0x0]
80008706:	0e 01       	add	r1,r7
80008708:	5b f8       	cp.w	r8,-1
8000870a:	c0 40       	breq	80008712 <_malloc_r+0x302>
8000870c:	28 11       	sub	r1,-127
8000870e:	e0 11 ff 80 	andl	r1,0xff80
80008712:	02 9b       	mov	r11,r1
80008714:	0a 9c       	mov	r12,r5
80008716:	e0 a0 02 b7 	rcall	80008c84 <_sbrk_r>
8000871a:	18 96       	mov	r6,r12
8000871c:	5b fc       	cp.w	r12,-1
8000871e:	c7 50       	breq	80008808 <_malloc_r+0x3f8>
80008720:	e6 02 00 08 	add	r8,r3,r2
80008724:	10 3c       	cp.w	r12,r8
80008726:	c0 32       	brcc	8000872c <_malloc_r+0x31c>
80008728:	08 33       	cp.w	r3,r4
8000872a:	c6 f1       	brne	80008808 <_malloc_r+0x3f8>
8000872c:	e0 6a 0d ec 	mov	r10,3564
80008730:	74 09       	ld.w	r9,r10[0x0]
80008732:	e2 09 00 09 	add	r9,r1,r9
80008736:	95 09       	st.w	r10[0x0],r9
80008738:	10 36       	cp.w	r6,r8
8000873a:	c0 a1       	brne	8000874e <_malloc_r+0x33e>
8000873c:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80008740:	c0 71       	brne	8000874e <_malloc_r+0x33e>
80008742:	e2 02 00 02 	add	r2,r1,r2
80008746:	68 28       	ld.w	r8,r4[0x8]
80008748:	a1 a2       	sbr	r2,0x0
8000874a:	91 12       	st.w	r8[0x4],r2
8000874c:	c4 f8       	rjmp	800087ea <_malloc_r+0x3da>
8000874e:	e0 6a 09 60 	mov	r10,2400
80008752:	74 0b       	ld.w	r11,r10[0x0]
80008754:	5b fb       	cp.w	r11,-1
80008756:	c0 31       	brne	8000875c <_malloc_r+0x34c>
80008758:	95 06       	st.w	r10[0x0],r6
8000875a:	c0 78       	rjmp	80008768 <_malloc_r+0x358>
8000875c:	ec 09 00 09 	add	r9,r6,r9
80008760:	e0 6a 0d ec 	mov	r10,3564
80008764:	10 19       	sub	r9,r8
80008766:	95 09       	st.w	r10[0x0],r9
80008768:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000876c:	f0 09 11 08 	rsub	r9,r8,8
80008770:	58 08       	cp.w	r8,0
80008772:	f2 08 17 10 	movne	r8,r9
80008776:	ed d8 e1 06 	addne	r6,r6,r8
8000877a:	28 08       	sub	r8,-128
8000877c:	ec 01 00 01 	add	r1,r6,r1
80008780:	0a 9c       	mov	r12,r5
80008782:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80008786:	f0 01 01 01 	sub	r1,r8,r1
8000878a:	02 9b       	mov	r11,r1
8000878c:	e0 a0 02 7c 	rcall	80008c84 <_sbrk_r>
80008790:	e0 68 0d ec 	mov	r8,3564
80008794:	5b fc       	cp.w	r12,-1
80008796:	ec 0c 17 00 	moveq	r12,r6
8000879a:	f9 b1 00 00 	moveq	r1,0
8000879e:	70 09       	ld.w	r9,r8[0x0]
800087a0:	0c 1c       	sub	r12,r6
800087a2:	89 26       	st.w	r4[0x8],r6
800087a4:	02 0c       	add	r12,r1
800087a6:	12 01       	add	r1,r9
800087a8:	a1 ac       	sbr	r12,0x0
800087aa:	91 01       	st.w	r8[0x0],r1
800087ac:	8d 1c       	st.w	r6[0x4],r12
800087ae:	08 33       	cp.w	r3,r4
800087b0:	c1 d0       	breq	800087ea <_malloc_r+0x3da>
800087b2:	58 f2       	cp.w	r2,15
800087b4:	e0 8b 00 05 	brhi	800087be <_malloc_r+0x3ae>
800087b8:	30 18       	mov	r8,1
800087ba:	8d 18       	st.w	r6[0x4],r8
800087bc:	c2 68       	rjmp	80008808 <_malloc_r+0x3f8>
800087be:	30 59       	mov	r9,5
800087c0:	20 c2       	sub	r2,12
800087c2:	e0 12 ff f8 	andl	r2,0xfff8
800087c6:	e6 02 00 08 	add	r8,r3,r2
800087ca:	91 29       	st.w	r8[0x8],r9
800087cc:	91 19       	st.w	r8[0x4],r9
800087ce:	66 18       	ld.w	r8,r3[0x4]
800087d0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800087d4:	e5 e8 10 08 	or	r8,r2,r8
800087d8:	87 18       	st.w	r3[0x4],r8
800087da:	58 f2       	cp.w	r2,15
800087dc:	e0 88 00 07 	brls	800087ea <_malloc_r+0x3da>
800087e0:	e6 cb ff f8 	sub	r11,r3,-8
800087e4:	0a 9c       	mov	r12,r5
800087e6:	e0 a0 1c 7d 	rcall	8000c0e0 <_free_r>
800087ea:	e0 69 0d e4 	mov	r9,3556
800087ee:	72 0a       	ld.w	r10,r9[0x0]
800087f0:	e0 68 0d ec 	mov	r8,3564
800087f4:	70 08       	ld.w	r8,r8[0x0]
800087f6:	14 38       	cp.w	r8,r10
800087f8:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800087fc:	e0 69 0d e0 	mov	r9,3552
80008800:	72 0a       	ld.w	r10,r9[0x0]
80008802:	14 38       	cp.w	r8,r10
80008804:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80008808:	68 28       	ld.w	r8,r4[0x8]
8000880a:	70 18       	ld.w	r8,r8[0x4]
8000880c:	e0 18 ff fc 	andl	r8,0xfffc
80008810:	0e 38       	cp.w	r8,r7
80008812:	5f 39       	srlo	r9
80008814:	0e 18       	sub	r8,r7
80008816:	58 f8       	cp.w	r8,15
80008818:	5f aa       	srle	r10
8000881a:	f5 e9 10 09 	or	r9,r10,r9
8000881e:	c0 50       	breq	80008828 <_malloc_r+0x418>
80008820:	0a 9c       	mov	r12,r5
80008822:	fe b0 f3 b3 	rcall	80006f88 <__malloc_unlock>
80008826:	d8 3a       	popm	r0-r7,pc,r12=0
80008828:	68 26       	ld.w	r6,r4[0x8]
8000882a:	a1 a8       	sbr	r8,0x0
8000882c:	0e 99       	mov	r9,r7
8000882e:	a1 a9       	sbr	r9,0x0
80008830:	8d 19       	st.w	r6[0x4],r9
80008832:	ec 07 00 07 	add	r7,r6,r7
80008836:	0a 9c       	mov	r12,r5
80008838:	89 27       	st.w	r4[0x8],r7
8000883a:	8f 18       	st.w	r7[0x4],r8
8000883c:	fe b0 f3 a6 	rcall	80006f88 <__malloc_unlock>
80008840:	ec cc ff f8 	sub	r12,r6,-8
80008844:	d8 32       	popm	r0-r7,pc
80008846:	d7 03       	nop

80008848 <memcmp>:
80008848:	d4 01       	pushm	lr
8000884a:	30 08       	mov	r8,0
8000884c:	c0 d8       	rjmp	80008866 <memcmp+0x1e>
8000884e:	f8 08 07 0e 	ld.ub	lr,r12[r8]
80008852:	f6 08 07 09 	ld.ub	r9,r11[r8]
80008856:	20 1a       	sub	r10,1
80008858:	2f f8       	sub	r8,-1
8000885a:	f2 0e 18 00 	cp.b	lr,r9
8000885e:	c0 40       	breq	80008866 <memcmp+0x1e>
80008860:	fc 09 01 0c 	sub	r12,lr,r9
80008864:	d8 02       	popm	pc
80008866:	58 0a       	cp.w	r10,0
80008868:	cf 31       	brne	8000884e <memcmp+0x6>
8000886a:	14 9c       	mov	r12,r10
8000886c:	d8 02       	popm	pc

8000886e <memcpy>:
8000886e:	58 8a       	cp.w	r10,8
80008870:	c2 f5       	brlt	800088ce <memcpy+0x60>
80008872:	f9 eb 10 09 	or	r9,r12,r11
80008876:	e2 19 00 03 	andl	r9,0x3,COH
8000887a:	e0 81 00 97 	brne	800089a8 <memcpy+0x13a>
8000887e:	e0 4a 00 20 	cp.w	r10,32
80008882:	c3 b4       	brge	800088f8 <memcpy+0x8a>
80008884:	f4 08 14 02 	asr	r8,r10,0x2
80008888:	f0 09 11 08 	rsub	r9,r8,8
8000888c:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80008890:	76 69       	ld.w	r9,r11[0x18]
80008892:	99 69       	st.w	r12[0x18],r9
80008894:	76 59       	ld.w	r9,r11[0x14]
80008896:	99 59       	st.w	r12[0x14],r9
80008898:	76 49       	ld.w	r9,r11[0x10]
8000889a:	99 49       	st.w	r12[0x10],r9
8000889c:	76 39       	ld.w	r9,r11[0xc]
8000889e:	99 39       	st.w	r12[0xc],r9
800088a0:	76 29       	ld.w	r9,r11[0x8]
800088a2:	99 29       	st.w	r12[0x8],r9
800088a4:	76 19       	ld.w	r9,r11[0x4]
800088a6:	99 19       	st.w	r12[0x4],r9
800088a8:	76 09       	ld.w	r9,r11[0x0]
800088aa:	99 09       	st.w	r12[0x0],r9
800088ac:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800088b0:	f8 08 00 28 	add	r8,r12,r8<<0x2
800088b4:	e0 1a 00 03 	andl	r10,0x3
800088b8:	f4 0a 11 04 	rsub	r10,r10,4
800088bc:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800088c0:	17 a9       	ld.ub	r9,r11[0x2]
800088c2:	b0 a9       	st.b	r8[0x2],r9
800088c4:	17 99       	ld.ub	r9,r11[0x1]
800088c6:	b0 99       	st.b	r8[0x1],r9
800088c8:	17 89       	ld.ub	r9,r11[0x0]
800088ca:	b0 89       	st.b	r8[0x0],r9
800088cc:	5e fc       	retal	r12
800088ce:	f4 0a 11 09 	rsub	r10,r10,9
800088d2:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800088d6:	17 f9       	ld.ub	r9,r11[0x7]
800088d8:	b8 f9       	st.b	r12[0x7],r9
800088da:	17 e9       	ld.ub	r9,r11[0x6]
800088dc:	b8 e9       	st.b	r12[0x6],r9
800088de:	17 d9       	ld.ub	r9,r11[0x5]
800088e0:	b8 d9       	st.b	r12[0x5],r9
800088e2:	17 c9       	ld.ub	r9,r11[0x4]
800088e4:	b8 c9       	st.b	r12[0x4],r9
800088e6:	17 b9       	ld.ub	r9,r11[0x3]
800088e8:	b8 b9       	st.b	r12[0x3],r9
800088ea:	17 a9       	ld.ub	r9,r11[0x2]
800088ec:	b8 a9       	st.b	r12[0x2],r9
800088ee:	17 99       	ld.ub	r9,r11[0x1]
800088f0:	b8 99       	st.b	r12[0x1],r9
800088f2:	17 89       	ld.ub	r9,r11[0x0]
800088f4:	b8 89       	st.b	r12[0x0],r9
800088f6:	5e fc       	retal	r12
800088f8:	eb cd 40 c0 	pushm	r6-r7,lr
800088fc:	18 99       	mov	r9,r12
800088fe:	22 0a       	sub	r10,32
80008900:	b7 07       	ld.d	r6,r11++
80008902:	b3 26       	st.d	r9++,r6
80008904:	b7 07       	ld.d	r6,r11++
80008906:	b3 26       	st.d	r9++,r6
80008908:	b7 07       	ld.d	r6,r11++
8000890a:	b3 26       	st.d	r9++,r6
8000890c:	b7 07       	ld.d	r6,r11++
8000890e:	b3 26       	st.d	r9++,r6
80008910:	22 0a       	sub	r10,32
80008912:	cf 74       	brge	80008900 <memcpy+0x92>
80008914:	2f 0a       	sub	r10,-16
80008916:	c0 65       	brlt	80008922 <memcpy+0xb4>
80008918:	b7 07       	ld.d	r6,r11++
8000891a:	b3 26       	st.d	r9++,r6
8000891c:	b7 07       	ld.d	r6,r11++
8000891e:	b3 26       	st.d	r9++,r6
80008920:	21 0a       	sub	r10,16
80008922:	5c 3a       	neg	r10
80008924:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80008928:	d7 03       	nop
8000892a:	d7 03       	nop
8000892c:	f7 36 00 0e 	ld.ub	r6,r11[14]
80008930:	f3 66 00 0e 	st.b	r9[14],r6
80008934:	f7 36 00 0d 	ld.ub	r6,r11[13]
80008938:	f3 66 00 0d 	st.b	r9[13],r6
8000893c:	f7 36 00 0c 	ld.ub	r6,r11[12]
80008940:	f3 66 00 0c 	st.b	r9[12],r6
80008944:	f7 36 00 0b 	ld.ub	r6,r11[11]
80008948:	f3 66 00 0b 	st.b	r9[11],r6
8000894c:	f7 36 00 0a 	ld.ub	r6,r11[10]
80008950:	f3 66 00 0a 	st.b	r9[10],r6
80008954:	f7 36 00 09 	ld.ub	r6,r11[9]
80008958:	f3 66 00 09 	st.b	r9[9],r6
8000895c:	f7 36 00 08 	ld.ub	r6,r11[8]
80008960:	f3 66 00 08 	st.b	r9[8],r6
80008964:	f7 36 00 07 	ld.ub	r6,r11[7]
80008968:	f3 66 00 07 	st.b	r9[7],r6
8000896c:	f7 36 00 06 	ld.ub	r6,r11[6]
80008970:	f3 66 00 06 	st.b	r9[6],r6
80008974:	f7 36 00 05 	ld.ub	r6,r11[5]
80008978:	f3 66 00 05 	st.b	r9[5],r6
8000897c:	f7 36 00 04 	ld.ub	r6,r11[4]
80008980:	f3 66 00 04 	st.b	r9[4],r6
80008984:	f7 36 00 03 	ld.ub	r6,r11[3]
80008988:	f3 66 00 03 	st.b	r9[3],r6
8000898c:	f7 36 00 02 	ld.ub	r6,r11[2]
80008990:	f3 66 00 02 	st.b	r9[2],r6
80008994:	f7 36 00 01 	ld.ub	r6,r11[1]
80008998:	f3 66 00 01 	st.b	r9[1],r6
8000899c:	f7 36 00 00 	ld.ub	r6,r11[0]
800089a0:	f3 66 00 00 	st.b	r9[0],r6
800089a4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800089a8:	20 1a       	sub	r10,1
800089aa:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800089ae:	f8 0a 0b 09 	st.b	r12[r10],r9
800089b2:	cf b1       	brne	800089a8 <memcpy+0x13a>
800089b4:	5e fc       	retal	r12

800089b6 <memset>:
800089b6:	18 98       	mov	r8,r12
800089b8:	c0 38       	rjmp	800089be <memset+0x8>
800089ba:	10 cb       	st.b	r8++,r11
800089bc:	20 1a       	sub	r10,1
800089be:	58 0a       	cp.w	r10,0
800089c0:	cf d1       	brne	800089ba <memset+0x4>
800089c2:	5e fc       	retal	r12

800089c4 <_realloc_r>:
800089c4:	d4 31       	pushm	r0-r7,lr
800089c6:	20 1d       	sub	sp,4
800089c8:	16 94       	mov	r4,r11
800089ca:	18 92       	mov	r2,r12
800089cc:	14 9b       	mov	r11,r10
800089ce:	58 04       	cp.w	r4,0
800089d0:	c0 51       	brne	800089da <_realloc_r+0x16>
800089d2:	fe b0 fd 1f 	rcall	80008410 <_malloc_r>
800089d6:	18 95       	mov	r5,r12
800089d8:	c5 39       	rjmp	80008c7e <_realloc_r+0x2ba>
800089da:	50 0a       	stdsp	sp[0x0],r10
800089dc:	fe b0 f2 d0 	rcall	80006f7c <__malloc_lock>
800089e0:	40 0b       	lddsp	r11,sp[0x0]
800089e2:	f6 c8 ff f5 	sub	r8,r11,-11
800089e6:	e8 c1 00 08 	sub	r1,r4,8
800089ea:	10 96       	mov	r6,r8
800089ec:	62 1c       	ld.w	r12,r1[0x4]
800089ee:	e0 16 ff f8 	andl	r6,0xfff8
800089f2:	59 68       	cp.w	r8,22
800089f4:	f9 b6 08 10 	movls	r6,16
800089f8:	16 36       	cp.w	r6,r11
800089fa:	5f 38       	srlo	r8
800089fc:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80008a00:	c0 50       	breq	80008a0a <_realloc_r+0x46>
80008a02:	30 c8       	mov	r8,12
80008a04:	30 05       	mov	r5,0
80008a06:	85 38       	st.w	r2[0xc],r8
80008a08:	c3 b9       	rjmp	80008c7e <_realloc_r+0x2ba>
80008a0a:	18 90       	mov	r0,r12
80008a0c:	e0 10 ff fc 	andl	r0,0xfffc
80008a10:	0c 30       	cp.w	r0,r6
80008a12:	e0 84 01 0b 	brge	80008c28 <_realloc_r+0x264>
80008a16:	e0 68 05 54 	mov	r8,1364
80008a1a:	e2 00 00 09 	add	r9,r1,r0
80008a1e:	70 25       	ld.w	r5,r8[0x8]
80008a20:	0a 39       	cp.w	r9,r5
80008a22:	c0 90       	breq	80008a34 <_realloc_r+0x70>
80008a24:	72 1a       	ld.w	r10,r9[0x4]
80008a26:	a1 ca       	cbr	r10,0x0
80008a28:	f2 0a 00 0a 	add	r10,r9,r10
80008a2c:	74 1a       	ld.w	r10,r10[0x4]
80008a2e:	ed ba 00 00 	bld	r10,0x0
80008a32:	c2 20       	breq	80008a76 <_realloc_r+0xb2>
80008a34:	72 1a       	ld.w	r10,r9[0x4]
80008a36:	e0 1a ff fc 	andl	r10,0xfffc
80008a3a:	f4 00 00 03 	add	r3,r10,r0
80008a3e:	0a 39       	cp.w	r9,r5
80008a40:	c1 31       	brne	80008a66 <_realloc_r+0xa2>
80008a42:	ec c7 ff f0 	sub	r7,r6,-16
80008a46:	0e 33       	cp.w	r3,r7
80008a48:	c1 95       	brlt	80008a7a <_realloc_r+0xb6>
80008a4a:	e2 06 00 09 	add	r9,r1,r6
80008a4e:	0c 13       	sub	r3,r6
80008a50:	a1 a3       	sbr	r3,0x0
80008a52:	93 13       	st.w	r9[0x4],r3
80008a54:	91 29       	st.w	r8[0x8],r9
80008a56:	04 9c       	mov	r12,r2
80008a58:	62 18       	ld.w	r8,r1[0x4]
80008a5a:	08 95       	mov	r5,r4
80008a5c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008a60:	10 46       	or	r6,r8
80008a62:	83 16       	st.w	r1[0x4],r6
80008a64:	c0 b9       	rjmp	80008c7a <_realloc_r+0x2b6>
80008a66:	0c 33       	cp.w	r3,r6
80008a68:	c0 95       	brlt	80008a7a <_realloc_r+0xb6>
80008a6a:	72 28       	ld.w	r8,r9[0x8]
80008a6c:	02 97       	mov	r7,r1
80008a6e:	72 39       	ld.w	r9,r9[0xc]
80008a70:	93 28       	st.w	r9[0x8],r8
80008a72:	91 39       	st.w	r8[0xc],r9
80008a74:	cd c8       	rjmp	80008c2c <_realloc_r+0x268>
80008a76:	30 0a       	mov	r10,0
80008a78:	14 99       	mov	r9,r10
80008a7a:	ed bc 00 00 	bld	r12,0x0
80008a7e:	e0 80 00 95 	breq	80008ba8 <_realloc_r+0x1e4>
80008a82:	62 07       	ld.w	r7,r1[0x0]
80008a84:	e2 07 01 07 	sub	r7,r1,r7
80008a88:	6e 1c       	ld.w	r12,r7[0x4]
80008a8a:	e0 1c ff fc 	andl	r12,0xfffc
80008a8e:	58 09       	cp.w	r9,0
80008a90:	c5 60       	breq	80008b3c <_realloc_r+0x178>
80008a92:	f8 00 00 03 	add	r3,r12,r0
80008a96:	0a 39       	cp.w	r9,r5
80008a98:	c4 81       	brne	80008b28 <_realloc_r+0x164>
80008a9a:	14 03       	add	r3,r10
80008a9c:	ec c9 ff f0 	sub	r9,r6,-16
80008aa0:	12 33       	cp.w	r3,r9
80008aa2:	c4 d5       	brlt	80008b3c <_realloc_r+0x178>
80008aa4:	6e 3a       	ld.w	r10,r7[0xc]
80008aa6:	6e 29       	ld.w	r9,r7[0x8]
80008aa8:	95 29       	st.w	r10[0x8],r9
80008aaa:	93 3a       	st.w	r9[0xc],r10
80008aac:	ee c5 ff f8 	sub	r5,r7,-8
80008ab0:	e0 ca 00 04 	sub	r10,r0,4
80008ab4:	e0 4a 00 24 	cp.w	r10,36
80008ab8:	e0 8b 00 25 	brhi	80008b02 <_realloc_r+0x13e>
80008abc:	0a 99       	mov	r9,r5
80008abe:	59 3a       	cp.w	r10,19
80008ac0:	e0 88 00 1a 	brls	80008af4 <_realloc_r+0x130>
80008ac4:	09 09       	ld.w	r9,r4++
80008ac6:	8b 09       	st.w	r5[0x0],r9
80008ac8:	09 09       	ld.w	r9,r4++
80008aca:	8f 39       	st.w	r7[0xc],r9
80008acc:	ee c9 ff f0 	sub	r9,r7,-16
80008ad0:	59 ba       	cp.w	r10,27
80008ad2:	e0 88 00 11 	brls	80008af4 <_realloc_r+0x130>
80008ad6:	09 0b       	ld.w	r11,r4++
80008ad8:	93 0b       	st.w	r9[0x0],r11
80008ada:	09 09       	ld.w	r9,r4++
80008adc:	8f 59       	st.w	r7[0x14],r9
80008ade:	ee c9 ff e8 	sub	r9,r7,-24
80008ae2:	e0 4a 00 24 	cp.w	r10,36
80008ae6:	c0 71       	brne	80008af4 <_realloc_r+0x130>
80008ae8:	09 0a       	ld.w	r10,r4++
80008aea:	93 0a       	st.w	r9[0x0],r10
80008aec:	ee c9 ff e0 	sub	r9,r7,-32
80008af0:	09 0a       	ld.w	r10,r4++
80008af2:	8f 7a       	st.w	r7[0x1c],r10
80008af4:	09 0a       	ld.w	r10,r4++
80008af6:	12 aa       	st.w	r9++,r10
80008af8:	68 0a       	ld.w	r10,r4[0x0]
80008afa:	93 0a       	st.w	r9[0x0],r10
80008afc:	68 1a       	ld.w	r10,r4[0x4]
80008afe:	93 1a       	st.w	r9[0x4],r10
80008b00:	c0 78       	rjmp	80008b0e <_realloc_r+0x14a>
80008b02:	50 08       	stdsp	sp[0x0],r8
80008b04:	08 9b       	mov	r11,r4
80008b06:	0a 9c       	mov	r12,r5
80008b08:	e0 a0 1d 8f 	rcall	8000c626 <memmove>
80008b0c:	40 08       	lddsp	r8,sp[0x0]
80008b0e:	ee 06 00 09 	add	r9,r7,r6
80008b12:	0c 13       	sub	r3,r6
80008b14:	a1 a3       	sbr	r3,0x0
80008b16:	93 13       	st.w	r9[0x4],r3
80008b18:	91 29       	st.w	r8[0x8],r9
80008b1a:	04 9c       	mov	r12,r2
80008b1c:	6e 18       	ld.w	r8,r7[0x4]
80008b1e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008b22:	10 46       	or	r6,r8
80008b24:	8f 16       	st.w	r7[0x4],r6
80008b26:	ca a8       	rjmp	80008c7a <_realloc_r+0x2b6>
80008b28:	14 03       	add	r3,r10
80008b2a:	0c 33       	cp.w	r3,r6
80008b2c:	c0 85       	brlt	80008b3c <_realloc_r+0x178>
80008b2e:	72 28       	ld.w	r8,r9[0x8]
80008b30:	72 39       	ld.w	r9,r9[0xc]
80008b32:	93 28       	st.w	r9[0x8],r8
80008b34:	91 39       	st.w	r8[0xc],r9
80008b36:	6e 28       	ld.w	r8,r7[0x8]
80008b38:	6e 39       	ld.w	r9,r7[0xc]
80008b3a:	c0 78       	rjmp	80008b48 <_realloc_r+0x184>
80008b3c:	f8 00 00 03 	add	r3,r12,r0
80008b40:	0c 33       	cp.w	r3,r6
80008b42:	c3 35       	brlt	80008ba8 <_realloc_r+0x1e4>
80008b44:	6e 39       	ld.w	r9,r7[0xc]
80008b46:	6e 28       	ld.w	r8,r7[0x8]
80008b48:	93 28       	st.w	r9[0x8],r8
80008b4a:	91 39       	st.w	r8[0xc],r9
80008b4c:	e0 ca 00 04 	sub	r10,r0,4
80008b50:	ee cc ff f8 	sub	r12,r7,-8
80008b54:	e0 4a 00 24 	cp.w	r10,36
80008b58:	e0 8b 00 24 	brhi	80008ba0 <_realloc_r+0x1dc>
80008b5c:	59 3a       	cp.w	r10,19
80008b5e:	e0 88 00 1a 	brls	80008b92 <_realloc_r+0x1ce>
80008b62:	09 08       	ld.w	r8,r4++
80008b64:	99 08       	st.w	r12[0x0],r8
80008b66:	09 08       	ld.w	r8,r4++
80008b68:	8f 38       	st.w	r7[0xc],r8
80008b6a:	ee cc ff f0 	sub	r12,r7,-16
80008b6e:	59 ba       	cp.w	r10,27
80008b70:	e0 88 00 11 	brls	80008b92 <_realloc_r+0x1ce>
80008b74:	09 08       	ld.w	r8,r4++
80008b76:	99 08       	st.w	r12[0x0],r8
80008b78:	09 08       	ld.w	r8,r4++
80008b7a:	8f 58       	st.w	r7[0x14],r8
80008b7c:	ee cc ff e8 	sub	r12,r7,-24
80008b80:	e0 4a 00 24 	cp.w	r10,36
80008b84:	c0 71       	brne	80008b92 <_realloc_r+0x1ce>
80008b86:	09 08       	ld.w	r8,r4++
80008b88:	99 08       	st.w	r12[0x0],r8
80008b8a:	ee cc ff e0 	sub	r12,r7,-32
80008b8e:	09 08       	ld.w	r8,r4++
80008b90:	8f 78       	st.w	r7[0x1c],r8
80008b92:	09 08       	ld.w	r8,r4++
80008b94:	18 a8       	st.w	r12++,r8
80008b96:	68 08       	ld.w	r8,r4[0x0]
80008b98:	99 08       	st.w	r12[0x0],r8
80008b9a:	68 18       	ld.w	r8,r4[0x4]
80008b9c:	99 18       	st.w	r12[0x4],r8
80008b9e:	c4 78       	rjmp	80008c2c <_realloc_r+0x268>
80008ba0:	08 9b       	mov	r11,r4
80008ba2:	e0 a0 1d 42 	rcall	8000c626 <memmove>
80008ba6:	c4 38       	rjmp	80008c2c <_realloc_r+0x268>
80008ba8:	04 9c       	mov	r12,r2
80008baa:	fe b0 fc 33 	rcall	80008410 <_malloc_r>
80008bae:	18 95       	mov	r5,r12
80008bb0:	c3 a0       	breq	80008c24 <_realloc_r+0x260>
80008bb2:	62 18       	ld.w	r8,r1[0x4]
80008bb4:	f8 c9 00 08 	sub	r9,r12,8
80008bb8:	a1 c8       	cbr	r8,0x0
80008bba:	e2 08 00 08 	add	r8,r1,r8
80008bbe:	10 39       	cp.w	r9,r8
80008bc0:	c0 71       	brne	80008bce <_realloc_r+0x20a>
80008bc2:	72 13       	ld.w	r3,r9[0x4]
80008bc4:	02 97       	mov	r7,r1
80008bc6:	e0 13 ff fc 	andl	r3,0xfffc
80008bca:	00 03       	add	r3,r0
80008bcc:	c3 08       	rjmp	80008c2c <_realloc_r+0x268>
80008bce:	e0 ca 00 04 	sub	r10,r0,4
80008bd2:	e0 4a 00 24 	cp.w	r10,36
80008bd6:	e0 8b 00 20 	brhi	80008c16 <_realloc_r+0x252>
80008bda:	08 99       	mov	r9,r4
80008bdc:	18 98       	mov	r8,r12
80008bde:	59 3a       	cp.w	r10,19
80008be0:	e0 88 00 14 	brls	80008c08 <_realloc_r+0x244>
80008be4:	13 0b       	ld.w	r11,r9++
80008be6:	10 ab       	st.w	r8++,r11
80008be8:	13 0b       	ld.w	r11,r9++
80008bea:	10 ab       	st.w	r8++,r11
80008bec:	59 ba       	cp.w	r10,27
80008bee:	e0 88 00 0d 	brls	80008c08 <_realloc_r+0x244>
80008bf2:	13 0b       	ld.w	r11,r9++
80008bf4:	10 ab       	st.w	r8++,r11
80008bf6:	13 0b       	ld.w	r11,r9++
80008bf8:	10 ab       	st.w	r8++,r11
80008bfa:	e0 4a 00 24 	cp.w	r10,36
80008bfe:	c0 51       	brne	80008c08 <_realloc_r+0x244>
80008c00:	13 0a       	ld.w	r10,r9++
80008c02:	10 aa       	st.w	r8++,r10
80008c04:	13 0a       	ld.w	r10,r9++
80008c06:	10 aa       	st.w	r8++,r10
80008c08:	13 0a       	ld.w	r10,r9++
80008c0a:	10 aa       	st.w	r8++,r10
80008c0c:	72 0a       	ld.w	r10,r9[0x0]
80008c0e:	91 0a       	st.w	r8[0x0],r10
80008c10:	72 19       	ld.w	r9,r9[0x4]
80008c12:	91 19       	st.w	r8[0x4],r9
80008c14:	c0 48       	rjmp	80008c1c <_realloc_r+0x258>
80008c16:	08 9b       	mov	r11,r4
80008c18:	e0 a0 1d 07 	rcall	8000c626 <memmove>
80008c1c:	08 9b       	mov	r11,r4
80008c1e:	04 9c       	mov	r12,r2
80008c20:	e0 a0 1a 60 	rcall	8000c0e0 <_free_r>
80008c24:	04 9c       	mov	r12,r2
80008c26:	c2 a8       	rjmp	80008c7a <_realloc_r+0x2b6>
80008c28:	00 93       	mov	r3,r0
80008c2a:	02 97       	mov	r7,r1
80008c2c:	e6 06 01 09 	sub	r9,r3,r6
80008c30:	6e 18       	ld.w	r8,r7[0x4]
80008c32:	58 f9       	cp.w	r9,15
80008c34:	e0 88 00 16 	brls	80008c60 <_realloc_r+0x29c>
80008c38:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008c3c:	ed e8 10 08 	or	r8,r6,r8
80008c40:	8f 18       	st.w	r7[0x4],r8
80008c42:	12 98       	mov	r8,r9
80008c44:	a1 a8       	sbr	r8,0x0
80008c46:	ee 06 00 0b 	add	r11,r7,r6
80008c4a:	f6 09 00 09 	add	r9,r11,r9
80008c4e:	97 18       	st.w	r11[0x4],r8
80008c50:	72 18       	ld.w	r8,r9[0x4]
80008c52:	a1 a8       	sbr	r8,0x0
80008c54:	2f 8b       	sub	r11,-8
80008c56:	93 18       	st.w	r9[0x4],r8
80008c58:	04 9c       	mov	r12,r2
80008c5a:	e0 a0 1a 43 	rcall	8000c0e0 <_free_r>
80008c5e:	c0 b8       	rjmp	80008c74 <_realloc_r+0x2b0>
80008c60:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008c64:	e7 e8 10 08 	or	r8,r3,r8
80008c68:	8f 18       	st.w	r7[0x4],r8
80008c6a:	ee 03 00 03 	add	r3,r7,r3
80008c6e:	66 18       	ld.w	r8,r3[0x4]
80008c70:	a1 a8       	sbr	r8,0x0
80008c72:	87 18       	st.w	r3[0x4],r8
80008c74:	04 9c       	mov	r12,r2
80008c76:	ee c5 ff f8 	sub	r5,r7,-8
80008c7a:	fe b0 f1 87 	rcall	80006f88 <__malloc_unlock>
80008c7e:	0a 9c       	mov	r12,r5
80008c80:	2f fd       	sub	sp,-4
80008c82:	d8 32       	popm	r0-r7,pc

80008c84 <_sbrk_r>:
80008c84:	d4 21       	pushm	r4-r7,lr
80008c86:	30 08       	mov	r8,0
80008c88:	18 97       	mov	r7,r12
80008c8a:	e0 66 bd 50 	mov	r6,48464
80008c8e:	16 9c       	mov	r12,r11
80008c90:	8d 08       	st.w	r6[0x0],r8
80008c92:	c8 5c       	rcall	80008d9c <_sbrk>
80008c94:	5b fc       	cp.w	r12,-1
80008c96:	c0 51       	brne	80008ca0 <_sbrk_r+0x1c>
80008c98:	6c 08       	ld.w	r8,r6[0x0]
80008c9a:	58 08       	cp.w	r8,0
80008c9c:	ef f8 1a 03 	st.wne	r7[0xc],r8
80008ca0:	d8 22       	popm	r4-r7,pc
80008ca2:	d7 03       	nop

80008ca4 <sprintf>:
80008ca4:	d4 01       	pushm	lr
80008ca6:	21 7d       	sub	sp,92
80008ca8:	e0 68 ff ff 	mov	r8,65535
80008cac:	ea 18 7f ff 	orh	r8,0x7fff
80008cb0:	50 58       	stdsp	sp[0x14],r8
80008cb2:	50 28       	stdsp	sp[0x8],r8
80008cb4:	e0 68 02 08 	mov	r8,520
80008cb8:	ba 68       	st.h	sp[0xc],r8
80008cba:	3f f8       	mov	r8,-1
80008cbc:	ba 78       	st.h	sp[0xe],r8
80008cbe:	e0 68 0a 54 	mov	r8,2644
80008cc2:	50 4c       	stdsp	sp[0x10],r12
80008cc4:	16 9a       	mov	r10,r11
80008cc6:	50 0c       	stdsp	sp[0x0],r12
80008cc8:	fa c9 ff a0 	sub	r9,sp,-96
80008ccc:	70 0c       	ld.w	r12,r8[0x0]
80008cce:	1a 9b       	mov	r11,sp
80008cd0:	e0 a0 02 1a 	rcall	80009104 <_vfprintf_r>
80008cd4:	30 09       	mov	r9,0
80008cd6:	40 08       	lddsp	r8,sp[0x0]
80008cd8:	b0 89       	st.b	r8[0x0],r9
80008cda:	2e 9d       	sub	sp,-92
80008cdc:	d8 02       	popm	pc
80008cde:	d7 03       	nop

80008ce0 <strncpy>:
80008ce0:	30 08       	mov	r8,0
80008ce2:	10 3a       	cp.w	r10,r8
80008ce4:	5e 0c       	reteq	r12
80008ce6:	f6 08 07 09 	ld.ub	r9,r11[r8]
80008cea:	f8 08 0b 09 	st.b	r12[r8],r9
80008cee:	2f f8       	sub	r8,-1
80008cf0:	58 09       	cp.w	r9,0
80008cf2:	cf 81       	brne	80008ce2 <strncpy+0x2>
80008cf4:	10 3a       	cp.w	r10,r8
80008cf6:	5e 0c       	reteq	r12
80008cf8:	f8 08 0b 09 	st.b	r12[r8],r9
80008cfc:	2f f8       	sub	r8,-1
80008cfe:	cf bb       	rjmp	80008cf4 <strncpy+0x14>

80008d00 <_close>:
80008d00:	30 28       	mov	r8,2
80008d02:	d6 73       	breakpoint
80008d04:	3f fc       	mov	r12,-1
80008d06:	35 8b       	mov	r11,88
80008d08:	58 0c       	cp.w	r12,0
80008d0a:	5e 4c       	retge	r12
80008d0c:	e0 6a bd 50 	mov	r10,48464
80008d10:	95 0b       	st.w	r10[0x0],r11
80008d12:	5e fc       	retal	r12

80008d14 <_lseek>:
80008d14:	30 58       	mov	r8,5
80008d16:	d6 73       	breakpoint
80008d18:	3f fc       	mov	r12,-1
80008d1a:	35 8b       	mov	r11,88
80008d1c:	58 0c       	cp.w	r12,0
80008d1e:	5e 4c       	retge	r12
80008d20:	e0 6a bd 50 	mov	r10,48464
80008d24:	95 0b       	st.w	r10[0x0],r11
80008d26:	5e fc       	retal	r12

80008d28 <isatty>:
80008d28:	30 b8       	mov	r8,11
80008d2a:	d6 73       	breakpoint
80008d2c:	3f fc       	mov	r12,-1
80008d2e:	35 8b       	mov	r11,88
80008d30:	58 0c       	cp.w	r12,0
80008d32:	5e 4c       	retge	r12
80008d34:	e0 6a bd 50 	mov	r10,48464
80008d38:	95 0b       	st.w	r10[0x0],r11
80008d3a:	5e fc       	retal	r12

80008d3c <_fstat_host>:
80008d3c:	30 98       	mov	r8,9
80008d3e:	d6 73       	breakpoint
80008d40:	3f fc       	mov	r12,-1
80008d42:	35 8b       	mov	r11,88
80008d44:	58 0c       	cp.w	r12,0
80008d46:	5e 4c       	retge	r12
80008d48:	e0 6a bd 50 	mov	r10,48464
80008d4c:	95 0b       	st.w	r10[0x0],r11
80008d4e:	5e fc       	retal	r12

80008d50 <_fstat>:
80008d50:	d4 21       	pushm	r4-r7,lr
80008d52:	21 0d       	sub	sp,64
80008d54:	16 97       	mov	r7,r11
80008d56:	1a 9b       	mov	r11,sp
80008d58:	cf 2f       	rcall	80008d3c <_fstat_host>
80008d5a:	c0 34       	brge	80008d60 <_fstat+0x10>
80008d5c:	3f fc       	mov	r12,-1
80008d5e:	c1 c8       	rjmp	80008d96 <_fstat+0x46>
80008d60:	40 08       	lddsp	r8,sp[0x0]
80008d62:	ae 08       	st.h	r7[0x0],r8
80008d64:	40 18       	lddsp	r8,sp[0x4]
80008d66:	ae 18       	st.h	r7[0x2],r8
80008d68:	40 28       	lddsp	r8,sp[0x8]
80008d6a:	8f 18       	st.w	r7[0x4],r8
80008d6c:	40 38       	lddsp	r8,sp[0xc]
80008d6e:	ae 48       	st.h	r7[0x8],r8
80008d70:	40 48       	lddsp	r8,sp[0x10]
80008d72:	ae 58       	st.h	r7[0xa],r8
80008d74:	40 58       	lddsp	r8,sp[0x14]
80008d76:	ae 68       	st.h	r7[0xc],r8
80008d78:	40 68       	lddsp	r8,sp[0x18]
80008d7a:	ae 78       	st.h	r7[0xe],r8
80008d7c:	40 88       	lddsp	r8,sp[0x20]
80008d7e:	8f 48       	st.w	r7[0x10],r8
80008d80:	40 a8       	lddsp	r8,sp[0x28]
80008d82:	8f b8       	st.w	r7[0x2c],r8
80008d84:	40 c8       	lddsp	r8,sp[0x30]
80008d86:	8f c8       	st.w	r7[0x30],r8
80008d88:	40 d8       	lddsp	r8,sp[0x34]
80008d8a:	8f 58       	st.w	r7[0x14],r8
80008d8c:	40 e8       	lddsp	r8,sp[0x38]
80008d8e:	30 0c       	mov	r12,0
80008d90:	8f 78       	st.w	r7[0x1c],r8
80008d92:	40 f8       	lddsp	r8,sp[0x3c]
80008d94:	8f 98       	st.w	r7[0x24],r8
80008d96:	2f 0d       	sub	sp,-64
80008d98:	d8 22       	popm	r4-r7,pc
80008d9a:	d7 03       	nop

80008d9c <_sbrk>:
80008d9c:	d4 01       	pushm	lr
80008d9e:	e0 68 0e 14 	mov	r8,3604
80008da2:	70 09       	ld.w	r9,r8[0x0]
80008da4:	58 09       	cp.w	r9,0
80008da6:	c0 41       	brne	80008dae <_sbrk+0x12>
80008da8:	e0 69 bd 58 	mov	r9,48472
80008dac:	91 09       	st.w	r8[0x0],r9
80008dae:	e0 69 0e 14 	mov	r9,3604
80008db2:	e0 7a 70 00 	mov	r10,94208
80008db6:	72 08       	ld.w	r8,r9[0x0]
80008db8:	f0 0c 00 0c 	add	r12,r8,r12
80008dbc:	14 3c       	cp.w	r12,r10
80008dbe:	e0 8b 00 04 	brhi	80008dc6 <_sbrk+0x2a>
80008dc2:	93 0c       	st.w	r9[0x0],r12
80008dc4:	c0 68       	rjmp	80008dd0 <_sbrk+0x34>
80008dc6:	e0 a0 18 15 	rcall	8000bdf0 <__errno>
80008dca:	30 c8       	mov	r8,12
80008dcc:	99 08       	st.w	r12[0x0],r8
80008dce:	3f f8       	mov	r8,-1
80008dd0:	10 9c       	mov	r12,r8
80008dd2:	d8 02       	popm	pc

80008dd4 <get_arg>:
80008dd4:	d4 31       	pushm	r0-r7,lr
80008dd6:	20 8d       	sub	sp,32
80008dd8:	fa c4 ff bc 	sub	r4,sp,-68
80008ddc:	50 4b       	stdsp	sp[0x10],r11
80008dde:	68 2e       	ld.w	lr,r4[0x8]
80008de0:	50 58       	stdsp	sp[0x14],r8
80008de2:	12 96       	mov	r6,r9
80008de4:	7c 0b       	ld.w	r11,lr[0x0]
80008de6:	70 05       	ld.w	r5,r8[0x0]
80008de8:	50 6e       	stdsp	sp[0x18],lr
80008dea:	58 0b       	cp.w	r11,0
80008dec:	f4 0b 17 00 	moveq	r11,r10
80008df0:	68 03       	ld.w	r3,r4[0x0]
80008df2:	68 11       	ld.w	r1,r4[0x4]
80008df4:	40 49       	lddsp	r9,sp[0x10]
80008df6:	30 08       	mov	r8,0
80008df8:	c2 89       	rjmp	80009048 <get_arg+0x274>
80008dfa:	2f fb       	sub	r11,-1
80008dfc:	32 5c       	mov	r12,37
80008dfe:	17 8a       	ld.ub	r10,r11[0x0]
80008e00:	f8 0a 18 00 	cp.b	r10,r12
80008e04:	5f 1e       	srne	lr
80008e06:	f0 0a 18 00 	cp.b	r10,r8
80008e0a:	5f 1c       	srne	r12
80008e0c:	fd ec 00 0c 	and	r12,lr,r12
80008e10:	f0 0c 18 00 	cp.b	r12,r8
80008e14:	cf 31       	brne	80008dfa <get_arg+0x26>
80008e16:	58 0a       	cp.w	r10,0
80008e18:	e0 80 01 25 	breq	80009062 <get_arg+0x28e>
80008e1c:	30 0c       	mov	r12,0
80008e1e:	3f fa       	mov	r10,-1
80008e20:	18 90       	mov	r0,r12
80008e22:	50 3a       	stdsp	sp[0xc],r10
80008e24:	18 94       	mov	r4,r12
80008e26:	18 92       	mov	r2,r12
80008e28:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80008e2c:	16 97       	mov	r7,r11
80008e2e:	50 7c       	stdsp	sp[0x1c],r12
80008e30:	fe cc 9a a0 	sub	r12,pc,-25952
80008e34:	0f 3a       	ld.ub	r10,r7++
80008e36:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80008e3a:	40 7c       	lddsp	r12,sp[0x1c]
80008e3c:	1c 0c       	add	r12,lr
80008e3e:	fe ce 9b 76 	sub	lr,pc,-25738
80008e42:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80008e46:	20 1e       	sub	lr,1
80008e48:	50 0e       	stdsp	sp[0x0],lr
80008e4a:	fe ce 9b ee 	sub	lr,pc,-25618
80008e4e:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80008e52:	50 7c       	stdsp	sp[0x1c],r12
80008e54:	40 0c       	lddsp	r12,sp[0x0]
80008e56:	58 7c       	cp.w	r12,7
80008e58:	e0 8b 00 f1 	brhi	8000903a <get_arg+0x266>
80008e5c:	fe ce 9d a0 	sub	lr,pc,-25184
80008e60:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80008e64:	36 8b       	mov	r11,104
80008e66:	f6 0a 18 00 	cp.b	r10,r11
80008e6a:	e0 80 00 e8 	breq	8000903a <get_arg+0x266>
80008e6e:	37 1b       	mov	r11,113
80008e70:	f6 0a 18 00 	cp.b	r10,r11
80008e74:	c0 70       	breq	80008e82 <get_arg+0xae>
80008e76:	34 cb       	mov	r11,76
80008e78:	f6 0a 18 00 	cp.b	r10,r11
80008e7c:	c0 51       	brne	80008e86 <get_arg+0xb2>
80008e7e:	a3 b4       	sbr	r4,0x3
80008e80:	cd d8       	rjmp	8000903a <get_arg+0x266>
80008e82:	a5 b4       	sbr	r4,0x5
80008e84:	cd b8       	rjmp	8000903a <get_arg+0x266>
80008e86:	08 9a       	mov	r10,r4
80008e88:	0e 9b       	mov	r11,r7
80008e8a:	a5 aa       	sbr	r10,0x4
80008e8c:	17 3c       	ld.ub	r12,r11++
80008e8e:	a5 b4       	sbr	r4,0x5
80008e90:	36 ce       	mov	lr,108
80008e92:	fc 0c 18 00 	cp.b	r12,lr
80008e96:	e0 80 00 d3 	breq	8000903c <get_arg+0x268>
80008e9a:	14 94       	mov	r4,r10
80008e9c:	cc f8       	rjmp	8000903a <get_arg+0x266>
80008e9e:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80008ea2:	36 7c       	mov	r12,103
80008ea4:	f8 0a 18 00 	cp.b	r10,r12
80008ea8:	e0 8b 00 27 	brhi	80008ef6 <get_arg+0x122>
80008eac:	36 5b       	mov	r11,101
80008eae:	f6 0a 18 00 	cp.b	r10,r11
80008eb2:	c4 82       	brcc	80008f42 <get_arg+0x16e>
80008eb4:	34 fb       	mov	r11,79
80008eb6:	f6 0a 18 00 	cp.b	r10,r11
80008eba:	c4 80       	breq	80008f4a <get_arg+0x176>
80008ebc:	e0 8b 00 0c 	brhi	80008ed4 <get_arg+0x100>
80008ec0:	34 5b       	mov	r11,69
80008ec2:	f6 0a 18 00 	cp.b	r10,r11
80008ec6:	c3 e0       	breq	80008f42 <get_arg+0x16e>
80008ec8:	34 7b       	mov	r11,71
80008eca:	f6 0a 18 00 	cp.b	r10,r11
80008ece:	c3 a0       	breq	80008f42 <get_arg+0x16e>
80008ed0:	34 4b       	mov	r11,68
80008ed2:	c0 88       	rjmp	80008ee2 <get_arg+0x10e>
80008ed4:	35 8b       	mov	r11,88
80008ed6:	f6 0a 18 00 	cp.b	r10,r11
80008eda:	c2 c0       	breq	80008f32 <get_arg+0x15e>
80008edc:	e0 8b 00 07 	brhi	80008eea <get_arg+0x116>
80008ee0:	35 5b       	mov	r11,85
80008ee2:	f6 0a 18 00 	cp.b	r10,r11
80008ee6:	c3 51       	brne	80008f50 <get_arg+0x17c>
80008ee8:	c3 18       	rjmp	80008f4a <get_arg+0x176>
80008eea:	36 3b       	mov	r11,99
80008eec:	f6 0a 18 00 	cp.b	r10,r11
80008ef0:	c2 f0       	breq	80008f4e <get_arg+0x17a>
80008ef2:	36 4b       	mov	r11,100
80008ef4:	c0 e8       	rjmp	80008f10 <get_arg+0x13c>
80008ef6:	37 0b       	mov	r11,112
80008ef8:	f6 0a 18 00 	cp.b	r10,r11
80008efc:	c2 50       	breq	80008f46 <get_arg+0x172>
80008efe:	e0 8b 00 0d 	brhi	80008f18 <get_arg+0x144>
80008f02:	36 eb       	mov	r11,110
80008f04:	f6 0a 18 00 	cp.b	r10,r11
80008f08:	c1 f0       	breq	80008f46 <get_arg+0x172>
80008f0a:	e0 8b 00 14 	brhi	80008f32 <get_arg+0x15e>
80008f0e:	36 9b       	mov	r11,105
80008f10:	f6 0a 18 00 	cp.b	r10,r11
80008f14:	c1 e1       	brne	80008f50 <get_arg+0x17c>
80008f16:	c0 e8       	rjmp	80008f32 <get_arg+0x15e>
80008f18:	37 5b       	mov	r11,117
80008f1a:	f6 0a 18 00 	cp.b	r10,r11
80008f1e:	c0 a0       	breq	80008f32 <get_arg+0x15e>
80008f20:	37 8b       	mov	r11,120
80008f22:	f6 0a 18 00 	cp.b	r10,r11
80008f26:	c0 60       	breq	80008f32 <get_arg+0x15e>
80008f28:	37 3b       	mov	r11,115
80008f2a:	f6 0a 18 00 	cp.b	r10,r11
80008f2e:	c1 11       	brne	80008f50 <get_arg+0x17c>
80008f30:	c0 b8       	rjmp	80008f46 <get_arg+0x172>
80008f32:	ed b4 00 04 	bld	r4,0x4
80008f36:	c0 a0       	breq	80008f4a <get_arg+0x176>
80008f38:	ed b4 00 05 	bld	r4,0x5
80008f3c:	c0 91       	brne	80008f4e <get_arg+0x17a>
80008f3e:	30 20       	mov	r0,2
80008f40:	c0 88       	rjmp	80008f50 <get_arg+0x17c>
80008f42:	30 40       	mov	r0,4
80008f44:	c0 68       	rjmp	80008f50 <get_arg+0x17c>
80008f46:	30 30       	mov	r0,3
80008f48:	c0 48       	rjmp	80008f50 <get_arg+0x17c>
80008f4a:	30 10       	mov	r0,1
80008f4c:	c0 28       	rjmp	80008f50 <get_arg+0x17c>
80008f4e:	30 00       	mov	r0,0
80008f50:	40 3b       	lddsp	r11,sp[0xc]
80008f52:	5b fb       	cp.w	r11,-1
80008f54:	c0 40       	breq	80008f5c <get_arg+0x188>
80008f56:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80008f5a:	c7 08       	rjmp	8000903a <get_arg+0x266>
80008f5c:	58 60       	cp.w	r0,6
80008f5e:	e0 8b 00 6e 	brhi	8000903a <get_arg+0x266>
80008f62:	6c 0a       	ld.w	r10,r6[0x0]
80008f64:	ea cc ff ff 	sub	r12,r5,-1
80008f68:	fe ce 9e 8c 	sub	lr,pc,-24948
80008f6c:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80008f70:	f4 cb ff f8 	sub	r11,r10,-8
80008f74:	8d 0b       	st.w	r6[0x0],r11
80008f76:	f4 ea 00 00 	ld.d	r10,r10[0]
80008f7a:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008f7e:	c0 f8       	rjmp	80008f9c <get_arg+0x1c8>
80008f80:	f4 cb ff fc 	sub	r11,r10,-4
80008f84:	8d 0b       	st.w	r6[0x0],r11
80008f86:	74 0a       	ld.w	r10,r10[0x0]
80008f88:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80008f8c:	c0 88       	rjmp	80008f9c <get_arg+0x1c8>
80008f8e:	f4 cb ff f8 	sub	r11,r10,-8
80008f92:	8d 0b       	st.w	r6[0x0],r11
80008f94:	f4 ea 00 00 	ld.d	r10,r10[0]
80008f98:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008f9c:	0e 9b       	mov	r11,r7
80008f9e:	18 95       	mov	r5,r12
80008fa0:	c4 e8       	rjmp	8000903c <get_arg+0x268>
80008fa2:	62 0a       	ld.w	r10,r1[0x0]
80008fa4:	5b fa       	cp.w	r10,-1
80008fa6:	c0 b1       	brne	80008fbc <get_arg+0x1e8>
80008fa8:	50 19       	stdsp	sp[0x4],r9
80008faa:	50 28       	stdsp	sp[0x8],r8
80008fac:	e0 6a 00 80 	mov	r10,128
80008fb0:	30 0b       	mov	r11,0
80008fb2:	02 9c       	mov	r12,r1
80008fb4:	fe b0 fd 01 	rcall	800089b6 <memset>
80008fb8:	40 28       	lddsp	r8,sp[0x8]
80008fba:	40 19       	lddsp	r9,sp[0x4]
80008fbc:	e4 cc 00 01 	sub	r12,r2,1
80008fc0:	0e 9b       	mov	r11,r7
80008fc2:	50 3c       	stdsp	sp[0xc],r12
80008fc4:	f2 0c 0c 49 	max	r9,r9,r12
80008fc8:	c3 a8       	rjmp	8000903c <get_arg+0x268>
80008fca:	62 0a       	ld.w	r10,r1[0x0]
80008fcc:	5b fa       	cp.w	r10,-1
80008fce:	c0 b1       	brne	80008fe4 <get_arg+0x210>
80008fd0:	50 19       	stdsp	sp[0x4],r9
80008fd2:	50 28       	stdsp	sp[0x8],r8
80008fd4:	e0 6a 00 80 	mov	r10,128
80008fd8:	30 0b       	mov	r11,0
80008fda:	02 9c       	mov	r12,r1
80008fdc:	fe b0 fc ed 	rcall	800089b6 <memset>
80008fe0:	40 28       	lddsp	r8,sp[0x8]
80008fe2:	40 19       	lddsp	r9,sp[0x4]
80008fe4:	20 12       	sub	r2,1
80008fe6:	30 0a       	mov	r10,0
80008fe8:	0e 9b       	mov	r11,r7
80008fea:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80008fee:	f2 02 0c 49 	max	r9,r9,r2
80008ff2:	c2 58       	rjmp	8000903c <get_arg+0x268>
80008ff4:	16 97       	mov	r7,r11
80008ff6:	6c 0a       	ld.w	r10,r6[0x0]
80008ff8:	f4 cb ff fc 	sub	r11,r10,-4
80008ffc:	8d 0b       	st.w	r6[0x0],r11
80008ffe:	74 0a       	ld.w	r10,r10[0x0]
80009000:	0e 9b       	mov	r11,r7
80009002:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80009006:	2f f5       	sub	r5,-1
80009008:	c1 a8       	rjmp	8000903c <get_arg+0x268>
8000900a:	f4 c2 00 30 	sub	r2,r10,48
8000900e:	c0 68       	rjmp	8000901a <get_arg+0x246>
80009010:	e4 02 00 22 	add	r2,r2,r2<<0x2
80009014:	2f f7       	sub	r7,-1
80009016:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000901a:	0f 8a       	ld.ub	r10,r7[0x0]
8000901c:	58 0a       	cp.w	r10,0
8000901e:	c0 e0       	breq	8000903a <get_arg+0x266>
80009020:	23 0a       	sub	r10,48
80009022:	58 9a       	cp.w	r10,9
80009024:	fe 98 ff f6 	brls	80009010 <get_arg+0x23c>
80009028:	c0 98       	rjmp	8000903a <get_arg+0x266>
8000902a:	2f f7       	sub	r7,-1
8000902c:	0f 8a       	ld.ub	r10,r7[0x0]
8000902e:	58 0a       	cp.w	r10,0
80009030:	c0 50       	breq	8000903a <get_arg+0x266>
80009032:	23 0a       	sub	r10,48
80009034:	58 9a       	cp.w	r10,9
80009036:	fe 98 ff fa 	brls	8000902a <get_arg+0x256>
8000903a:	0e 9b       	mov	r11,r7
8000903c:	40 7c       	lddsp	r12,sp[0x1c]
8000903e:	30 ba       	mov	r10,11
80009040:	f4 0c 18 00 	cp.b	r12,r10
80009044:	fe 91 fe f2 	brne	80008e28 <get_arg+0x54>
80009048:	40 42       	lddsp	r2,sp[0x10]
8000904a:	17 8c       	ld.ub	r12,r11[0x0]
8000904c:	0a 32       	cp.w	r2,r5
8000904e:	5f 4a       	srge	r10
80009050:	f0 0c 18 00 	cp.b	r12,r8
80009054:	5f 1c       	srne	r12
80009056:	f9 ea 00 0a 	and	r10,r12,r10
8000905a:	f0 0a 18 00 	cp.b	r10,r8
8000905e:	fe 91 fe cf 	brne	80008dfc <get_arg+0x28>
80009062:	30 08       	mov	r8,0
80009064:	40 4e       	lddsp	lr,sp[0x10]
80009066:	17 8a       	ld.ub	r10,r11[0x0]
80009068:	e2 05 00 21 	add	r1,r1,r5<<0x2
8000906c:	f0 0a 18 00 	cp.b	r10,r8
80009070:	fc 09 17 10 	movne	r9,lr
80009074:	e6 05 00 38 	add	r8,r3,r5<<0x3
80009078:	06 9e       	mov	lr,r3
8000907a:	c2 a8       	rjmp	800090ce <get_arg+0x2fa>
8000907c:	62 0a       	ld.w	r10,r1[0x0]
8000907e:	58 3a       	cp.w	r10,3
80009080:	c1 e0       	breq	800090bc <get_arg+0x2e8>
80009082:	e0 89 00 07 	brgt	80009090 <get_arg+0x2bc>
80009086:	58 1a       	cp.w	r10,1
80009088:	c1 a0       	breq	800090bc <get_arg+0x2e8>
8000908a:	58 2a       	cp.w	r10,2
8000908c:	c1 81       	brne	800090bc <get_arg+0x2e8>
8000908e:	c0 58       	rjmp	80009098 <get_arg+0x2c4>
80009090:	58 5a       	cp.w	r10,5
80009092:	c0 c0       	breq	800090aa <get_arg+0x2d6>
80009094:	c0 b5       	brlt	800090aa <get_arg+0x2d6>
80009096:	c1 38       	rjmp	800090bc <get_arg+0x2e8>
80009098:	6c 0a       	ld.w	r10,r6[0x0]
8000909a:	f4 cc ff f8 	sub	r12,r10,-8
8000909e:	8d 0c       	st.w	r6[0x0],r12
800090a0:	f4 e2 00 00 	ld.d	r2,r10[0]
800090a4:	f0 e3 00 00 	st.d	r8[0],r2
800090a8:	c1 08       	rjmp	800090c8 <get_arg+0x2f4>
800090aa:	6c 0a       	ld.w	r10,r6[0x0]
800090ac:	f4 cc ff f8 	sub	r12,r10,-8
800090b0:	8d 0c       	st.w	r6[0x0],r12
800090b2:	f4 e2 00 00 	ld.d	r2,r10[0]
800090b6:	f0 e3 00 00 	st.d	r8[0],r2
800090ba:	c0 78       	rjmp	800090c8 <get_arg+0x2f4>
800090bc:	6c 0a       	ld.w	r10,r6[0x0]
800090be:	f4 cc ff fc 	sub	r12,r10,-4
800090c2:	8d 0c       	st.w	r6[0x0],r12
800090c4:	74 0a       	ld.w	r10,r10[0x0]
800090c6:	91 0a       	st.w	r8[0x0],r10
800090c8:	2f f5       	sub	r5,-1
800090ca:	2f 88       	sub	r8,-8
800090cc:	2f c1       	sub	r1,-4
800090ce:	12 35       	cp.w	r5,r9
800090d0:	fe 9a ff d6 	brle	8000907c <get_arg+0x2a8>
800090d4:	1c 93       	mov	r3,lr
800090d6:	40 52       	lddsp	r2,sp[0x14]
800090d8:	40 6e       	lddsp	lr,sp[0x18]
800090da:	85 05       	st.w	r2[0x0],r5
800090dc:	9d 0b       	st.w	lr[0x0],r11
800090de:	40 4b       	lddsp	r11,sp[0x10]
800090e0:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
800090e4:	2f 8d       	sub	sp,-32
800090e6:	d8 32       	popm	r0-r7,pc

800090e8 <__sprint_r>:
800090e8:	d4 21       	pushm	r4-r7,lr
800090ea:	14 97       	mov	r7,r10
800090ec:	74 28       	ld.w	r8,r10[0x8]
800090ee:	58 08       	cp.w	r8,0
800090f0:	c0 41       	brne	800090f8 <__sprint_r+0x10>
800090f2:	95 18       	st.w	r10[0x4],r8
800090f4:	10 9c       	mov	r12,r8
800090f6:	d8 22       	popm	r4-r7,pc
800090f8:	e0 a0 18 ba 	rcall	8000c26c <__sfvwrite_r>
800090fc:	30 08       	mov	r8,0
800090fe:	8f 18       	st.w	r7[0x4],r8
80009100:	8f 28       	st.w	r7[0x8],r8
80009102:	d8 22       	popm	r4-r7,pc

80009104 <_vfprintf_r>:
80009104:	d4 31       	pushm	r0-r7,lr
80009106:	fa cd 06 bc 	sub	sp,sp,1724
8000910a:	51 09       	stdsp	sp[0x40],r9
8000910c:	16 91       	mov	r1,r11
8000910e:	14 97       	mov	r7,r10
80009110:	18 95       	mov	r5,r12
80009112:	e0 a0 1a 1d 	rcall	8000c54c <_localeconv_r>
80009116:	78 0c       	ld.w	r12,r12[0x0]
80009118:	50 cc       	stdsp	sp[0x30],r12
8000911a:	58 05       	cp.w	r5,0
8000911c:	c0 70       	breq	8000912a <_vfprintf_r+0x26>
8000911e:	6a 68       	ld.w	r8,r5[0x18]
80009120:	58 08       	cp.w	r8,0
80009122:	c0 41       	brne	8000912a <_vfprintf_r+0x26>
80009124:	0a 9c       	mov	r12,r5
80009126:	e0 a0 17 43 	rcall	8000bfac <__sinit>
8000912a:	fe c8 9c 8a 	sub	r8,pc,-25462
8000912e:	10 31       	cp.w	r1,r8
80009130:	c0 31       	brne	80009136 <_vfprintf_r+0x32>
80009132:	6a 01       	ld.w	r1,r5[0x0]
80009134:	c0 c8       	rjmp	8000914c <_vfprintf_r+0x48>
80009136:	fe c8 9c 76 	sub	r8,pc,-25482
8000913a:	10 31       	cp.w	r1,r8
8000913c:	c0 31       	brne	80009142 <_vfprintf_r+0x3e>
8000913e:	6a 11       	ld.w	r1,r5[0x4]
80009140:	c0 68       	rjmp	8000914c <_vfprintf_r+0x48>
80009142:	fe c8 9c 62 	sub	r8,pc,-25502
80009146:	10 31       	cp.w	r1,r8
80009148:	eb f1 00 02 	ld.weq	r1,r5[0x8]
8000914c:	82 68       	ld.sh	r8,r1[0xc]
8000914e:	ed b8 00 03 	bld	r8,0x3
80009152:	c0 41       	brne	8000915a <_vfprintf_r+0x56>
80009154:	62 48       	ld.w	r8,r1[0x10]
80009156:	58 08       	cp.w	r8,0
80009158:	c0 71       	brne	80009166 <_vfprintf_r+0x62>
8000915a:	02 9b       	mov	r11,r1
8000915c:	0a 9c       	mov	r12,r5
8000915e:	e0 a0 0f 5d 	rcall	8000b018 <__swsetup_r>
80009162:	e0 81 0f 54 	brne	8000b00a <_vfprintf_r+0x1f06>
80009166:	82 68       	ld.sh	r8,r1[0xc]
80009168:	10 99       	mov	r9,r8
8000916a:	e2 19 00 1a 	andl	r9,0x1a,COH
8000916e:	58 a9       	cp.w	r9,10
80009170:	c3 c1       	brne	800091e8 <_vfprintf_r+0xe4>
80009172:	82 79       	ld.sh	r9,r1[0xe]
80009174:	30 0a       	mov	r10,0
80009176:	f4 09 19 00 	cp.h	r9,r10
8000917a:	c3 75       	brlt	800091e8 <_vfprintf_r+0xe4>
8000917c:	a1 d8       	cbr	r8,0x1
8000917e:	fb 58 05 d0 	st.h	sp[1488],r8
80009182:	62 88       	ld.w	r8,r1[0x20]
80009184:	fb 48 05 e4 	st.w	sp[1508],r8
80009188:	62 a8       	ld.w	r8,r1[0x28]
8000918a:	fb 48 05 ec 	st.w	sp[1516],r8
8000918e:	fa c8 ff bc 	sub	r8,sp,-68
80009192:	fb 48 05 d4 	st.w	sp[1492],r8
80009196:	fb 48 05 c4 	st.w	sp[1476],r8
8000919a:	e0 68 04 00 	mov	r8,1024
8000919e:	fb 48 05 d8 	st.w	sp[1496],r8
800091a2:	fb 48 05 cc 	st.w	sp[1484],r8
800091a6:	30 08       	mov	r8,0
800091a8:	fb 59 05 d2 	st.h	sp[1490],r9
800091ac:	0e 9a       	mov	r10,r7
800091ae:	41 09       	lddsp	r9,sp[0x40]
800091b0:	fa c7 fa 3c 	sub	r7,sp,-1476
800091b4:	fb 48 05 dc 	st.w	sp[1500],r8
800091b8:	0a 9c       	mov	r12,r5
800091ba:	0e 9b       	mov	r11,r7
800091bc:	ca 4f       	rcall	80009104 <_vfprintf_r>
800091be:	50 bc       	stdsp	sp[0x2c],r12
800091c0:	c0 95       	brlt	800091d2 <_vfprintf_r+0xce>
800091c2:	0e 9b       	mov	r11,r7
800091c4:	0a 9c       	mov	r12,r5
800091c6:	e0 a0 16 1b 	rcall	8000bdfc <_fflush_r>
800091ca:	40 be       	lddsp	lr,sp[0x2c]
800091cc:	f9 be 01 ff 	movne	lr,-1
800091d0:	50 be       	stdsp	sp[0x2c],lr
800091d2:	fb 08 05 d0 	ld.sh	r8,sp[1488]
800091d6:	ed b8 00 06 	bld	r8,0x6
800091da:	e0 81 0f 1a 	brne	8000b00e <_vfprintf_r+0x1f0a>
800091de:	82 68       	ld.sh	r8,r1[0xc]
800091e0:	a7 a8       	sbr	r8,0x6
800091e2:	a2 68       	st.h	r1[0xc],r8
800091e4:	e0 8f 0f 15 	bral	8000b00e <_vfprintf_r+0x1f0a>
800091e8:	30 08       	mov	r8,0
800091ea:	fb 48 06 b4 	st.w	sp[1716],r8
800091ee:	fb 48 06 90 	st.w	sp[1680],r8
800091f2:	fb 48 06 8c 	st.w	sp[1676],r8
800091f6:	fb 48 06 b0 	st.w	sp[1712],r8
800091fa:	30 08       	mov	r8,0
800091fc:	30 09       	mov	r9,0
800091fe:	50 a7       	stdsp	sp[0x28],r7
80009200:	50 78       	stdsp	sp[0x1c],r8
80009202:	fa c3 f9 e0 	sub	r3,sp,-1568
80009206:	3f f8       	mov	r8,-1
80009208:	50 59       	stdsp	sp[0x14],r9
8000920a:	fb 43 06 88 	st.w	sp[1672],r3
8000920e:	fb 48 05 44 	st.w	sp[1348],r8
80009212:	12 9c       	mov	r12,r9
80009214:	50 69       	stdsp	sp[0x18],r9
80009216:	50 d9       	stdsp	sp[0x34],r9
80009218:	50 e9       	stdsp	sp[0x38],r9
8000921a:	50 b9       	stdsp	sp[0x2c],r9
8000921c:	12 97       	mov	r7,r9
8000921e:	0a 94       	mov	r4,r5
80009220:	40 a2       	lddsp	r2,sp[0x28]
80009222:	32 5a       	mov	r10,37
80009224:	30 08       	mov	r8,0
80009226:	c0 28       	rjmp	8000922a <_vfprintf_r+0x126>
80009228:	2f f2       	sub	r2,-1
8000922a:	05 89       	ld.ub	r9,r2[0x0]
8000922c:	f0 09 18 00 	cp.b	r9,r8
80009230:	5f 1b       	srne	r11
80009232:	f4 09 18 00 	cp.b	r9,r10
80009236:	5f 19       	srne	r9
80009238:	f3 eb 00 0b 	and	r11,r9,r11
8000923c:	f0 0b 18 00 	cp.b	r11,r8
80009240:	cf 41       	brne	80009228 <_vfprintf_r+0x124>
80009242:	40 ab       	lddsp	r11,sp[0x28]
80009244:	e4 0b 01 06 	sub	r6,r2,r11
80009248:	c1 e0       	breq	80009284 <_vfprintf_r+0x180>
8000924a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000924e:	0c 08       	add	r8,r6
80009250:	87 0b       	st.w	r3[0x0],r11
80009252:	fb 48 06 90 	st.w	sp[1680],r8
80009256:	87 16       	st.w	r3[0x4],r6
80009258:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000925c:	2f f8       	sub	r8,-1
8000925e:	fb 48 06 8c 	st.w	sp[1676],r8
80009262:	58 78       	cp.w	r8,7
80009264:	e0 89 00 04 	brgt	8000926c <_vfprintf_r+0x168>
80009268:	2f 83       	sub	r3,-8
8000926a:	c0 a8       	rjmp	8000927e <_vfprintf_r+0x17a>
8000926c:	fa ca f9 78 	sub	r10,sp,-1672
80009270:	02 9b       	mov	r11,r1
80009272:	08 9c       	mov	r12,r4
80009274:	c3 af       	rcall	800090e8 <__sprint_r>
80009276:	e0 81 0e c6 	brne	8000b002 <_vfprintf_r+0x1efe>
8000927a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000927e:	40 ba       	lddsp	r10,sp[0x2c]
80009280:	0c 0a       	add	r10,r6
80009282:	50 ba       	stdsp	sp[0x2c],r10
80009284:	05 89       	ld.ub	r9,r2[0x0]
80009286:	30 08       	mov	r8,0
80009288:	f0 09 18 00 	cp.b	r9,r8
8000928c:	e0 80 0e aa 	breq	8000afe0 <_vfprintf_r+0x1edc>
80009290:	30 09       	mov	r9,0
80009292:	fb 68 06 bb 	st.b	sp[1723],r8
80009296:	0e 96       	mov	r6,r7
80009298:	e4 c8 ff ff 	sub	r8,r2,-1
8000929c:	3f fe       	mov	lr,-1
8000929e:	50 93       	stdsp	sp[0x24],r3
800092a0:	50 41       	stdsp	sp[0x10],r1
800092a2:	0e 93       	mov	r3,r7
800092a4:	04 91       	mov	r1,r2
800092a6:	50 89       	stdsp	sp[0x20],r9
800092a8:	50 a8       	stdsp	sp[0x28],r8
800092aa:	50 2e       	stdsp	sp[0x8],lr
800092ac:	50 39       	stdsp	sp[0xc],r9
800092ae:	12 95       	mov	r5,r9
800092b0:	12 90       	mov	r0,r9
800092b2:	10 97       	mov	r7,r8
800092b4:	08 92       	mov	r2,r4
800092b6:	c0 78       	rjmp	800092c4 <_vfprintf_r+0x1c0>
800092b8:	3f fc       	mov	r12,-1
800092ba:	08 97       	mov	r7,r4
800092bc:	50 2c       	stdsp	sp[0x8],r12
800092be:	c0 38       	rjmp	800092c4 <_vfprintf_r+0x1c0>
800092c0:	30 0b       	mov	r11,0
800092c2:	50 3b       	stdsp	sp[0xc],r11
800092c4:	0f 38       	ld.ub	r8,r7++
800092c6:	c0 28       	rjmp	800092ca <_vfprintf_r+0x1c6>
800092c8:	12 90       	mov	r0,r9
800092ca:	f0 c9 00 20 	sub	r9,r8,32
800092ce:	e0 49 00 58 	cp.w	r9,88
800092d2:	e0 8b 0a 30 	brhi	8000a732 <_vfprintf_r+0x162e>
800092d6:	fe ca a1 de 	sub	r10,pc,-24098
800092da:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
800092de:	50 a7       	stdsp	sp[0x28],r7
800092e0:	50 80       	stdsp	sp[0x20],r0
800092e2:	0c 97       	mov	r7,r6
800092e4:	04 94       	mov	r4,r2
800092e6:	06 96       	mov	r6,r3
800092e8:	02 92       	mov	r2,r1
800092ea:	fe c9 9f b6 	sub	r9,pc,-24650
800092ee:	40 93       	lddsp	r3,sp[0x24]
800092f0:	10 90       	mov	r0,r8
800092f2:	40 41       	lddsp	r1,sp[0x10]
800092f4:	50 d9       	stdsp	sp[0x34],r9
800092f6:	e0 8f 08 8e 	bral	8000a412 <_vfprintf_r+0x130e>
800092fa:	30 08       	mov	r8,0
800092fc:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80009300:	f0 09 18 00 	cp.b	r9,r8
80009304:	ce 01       	brne	800092c4 <_vfprintf_r+0x1c0>
80009306:	32 08       	mov	r8,32
80009308:	c6 e8       	rjmp	800093e4 <_vfprintf_r+0x2e0>
8000930a:	a1 a5       	sbr	r5,0x0
8000930c:	cd cb       	rjmp	800092c4 <_vfprintf_r+0x1c0>
8000930e:	0f 89       	ld.ub	r9,r7[0x0]
80009310:	f2 c8 00 30 	sub	r8,r9,48
80009314:	58 98       	cp.w	r8,9
80009316:	e0 8b 00 1d 	brhi	80009350 <_vfprintf_r+0x24c>
8000931a:	ee c8 ff ff 	sub	r8,r7,-1
8000931e:	30 0b       	mov	r11,0
80009320:	23 09       	sub	r9,48
80009322:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80009326:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000932a:	11 39       	ld.ub	r9,r8++
8000932c:	f2 ca 00 30 	sub	r10,r9,48
80009330:	58 9a       	cp.w	r10,9
80009332:	fe 98 ff f7 	brls	80009320 <_vfprintf_r+0x21c>
80009336:	e0 49 00 24 	cp.w	r9,36
8000933a:	cc 31       	brne	800092c0 <_vfprintf_r+0x1bc>
8000933c:	e0 4b 00 20 	cp.w	r11,32
80009340:	e0 89 0e 60 	brgt	8000b000 <_vfprintf_r+0x1efc>
80009344:	20 1b       	sub	r11,1
80009346:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000934a:	12 3b       	cp.w	r11,r9
8000934c:	c0 95       	brlt	8000935e <_vfprintf_r+0x25a>
8000934e:	c1 08       	rjmp	8000936e <_vfprintf_r+0x26a>
80009350:	fa f9 06 b4 	ld.w	r9,sp[1716]
80009354:	ec ca ff ff 	sub	r10,r6,-1
80009358:	12 36       	cp.w	r6,r9
8000935a:	c1 f5       	brlt	80009398 <_vfprintf_r+0x294>
8000935c:	c2 68       	rjmp	800093a8 <_vfprintf_r+0x2a4>
8000935e:	fa ce f9 44 	sub	lr,sp,-1724
80009362:	10 97       	mov	r7,r8
80009364:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80009368:	f6 f0 fd 88 	ld.w	r0,r11[-632]
8000936c:	c3 58       	rjmp	800093d6 <_vfprintf_r+0x2d2>
8000936e:	10 97       	mov	r7,r8
80009370:	fa c8 f9 50 	sub	r8,sp,-1712
80009374:	1a d8       	st.w	--sp,r8
80009376:	fa c8 fa b8 	sub	r8,sp,-1352
8000937a:	1a d8       	st.w	--sp,r8
8000937c:	fa c8 fb b4 	sub	r8,sp,-1100
80009380:	02 9a       	mov	r10,r1
80009382:	1a d8       	st.w	--sp,r8
80009384:	04 9c       	mov	r12,r2
80009386:	fa c8 f9 40 	sub	r8,sp,-1728
8000938a:	fa c9 ff b4 	sub	r9,sp,-76
8000938e:	fe b0 fd 23 	rcall	80008dd4 <get_arg>
80009392:	2f dd       	sub	sp,-12
80009394:	78 00       	ld.w	r0,r12[0x0]
80009396:	c2 08       	rjmp	800093d6 <_vfprintf_r+0x2d2>
80009398:	fa cc f9 44 	sub	r12,sp,-1724
8000939c:	14 96       	mov	r6,r10
8000939e:	f8 03 00 38 	add	r8,r12,r3<<0x3
800093a2:	f0 f0 fd 88 	ld.w	r0,r8[-632]
800093a6:	c1 88       	rjmp	800093d6 <_vfprintf_r+0x2d2>
800093a8:	41 08       	lddsp	r8,sp[0x40]
800093aa:	59 f9       	cp.w	r9,31
800093ac:	e0 89 00 11 	brgt	800093ce <_vfprintf_r+0x2ca>
800093b0:	f0 cb ff fc 	sub	r11,r8,-4
800093b4:	51 0b       	stdsp	sp[0x40],r11
800093b6:	70 00       	ld.w	r0,r8[0x0]
800093b8:	fa cb f9 44 	sub	r11,sp,-1724
800093bc:	f6 09 00 38 	add	r8,r11,r9<<0x3
800093c0:	f1 40 fd 88 	st.w	r8[-632],r0
800093c4:	2f f9       	sub	r9,-1
800093c6:	14 96       	mov	r6,r10
800093c8:	fb 49 06 b4 	st.w	sp[1716],r9
800093cc:	c0 58       	rjmp	800093d6 <_vfprintf_r+0x2d2>
800093ce:	70 00       	ld.w	r0,r8[0x0]
800093d0:	14 96       	mov	r6,r10
800093d2:	2f c8       	sub	r8,-4
800093d4:	51 08       	stdsp	sp[0x40],r8
800093d6:	58 00       	cp.w	r0,0
800093d8:	fe 94 ff 76 	brge	800092c4 <_vfprintf_r+0x1c0>
800093dc:	5c 30       	neg	r0
800093de:	a3 a5       	sbr	r5,0x2
800093e0:	c7 2b       	rjmp	800092c4 <_vfprintf_r+0x1c0>
800093e2:	32 b8       	mov	r8,43
800093e4:	fb 68 06 bb 	st.b	sp[1723],r8
800093e8:	c6 eb       	rjmp	800092c4 <_vfprintf_r+0x1c0>
800093ea:	0f 38       	ld.ub	r8,r7++
800093ec:	e0 48 00 2a 	cp.w	r8,42
800093f0:	c0 30       	breq	800093f6 <_vfprintf_r+0x2f2>
800093f2:	30 09       	mov	r9,0
800093f4:	c7 98       	rjmp	800094e6 <_vfprintf_r+0x3e2>
800093f6:	0f 88       	ld.ub	r8,r7[0x0]
800093f8:	f0 c9 00 30 	sub	r9,r8,48
800093fc:	58 99       	cp.w	r9,9
800093fe:	e0 8b 00 1f 	brhi	8000943c <_vfprintf_r+0x338>
80009402:	ee c4 ff ff 	sub	r4,r7,-1
80009406:	30 0b       	mov	r11,0
80009408:	23 08       	sub	r8,48
8000940a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000940e:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80009412:	09 38       	ld.ub	r8,r4++
80009414:	f0 c9 00 30 	sub	r9,r8,48
80009418:	58 99       	cp.w	r9,9
8000941a:	fe 98 ff f7 	brls	80009408 <_vfprintf_r+0x304>
8000941e:	e0 48 00 24 	cp.w	r8,36
80009422:	fe 91 ff 4f 	brne	800092c0 <_vfprintf_r+0x1bc>
80009426:	e0 4b 00 20 	cp.w	r11,32
8000942a:	e0 89 0d eb 	brgt	8000b000 <_vfprintf_r+0x1efc>
8000942e:	20 1b       	sub	r11,1
80009430:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009434:	10 3b       	cp.w	r11,r8
80009436:	c0 a5       	brlt	8000944a <_vfprintf_r+0x346>
80009438:	c1 18       	rjmp	8000945a <_vfprintf_r+0x356>
8000943a:	d7 03       	nop
8000943c:	fa fa 06 b4 	ld.w	r10,sp[1716]
80009440:	ec c9 ff ff 	sub	r9,r6,-1
80009444:	14 36       	cp.w	r6,r10
80009446:	c1 f5       	brlt	80009484 <_vfprintf_r+0x380>
80009448:	c2 88       	rjmp	80009498 <_vfprintf_r+0x394>
8000944a:	fa ca f9 44 	sub	r10,sp,-1724
8000944e:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80009452:	f6 fb fd 88 	ld.w	r11,r11[-632]
80009456:	50 2b       	stdsp	sp[0x8],r11
80009458:	c3 c8       	rjmp	800094d0 <_vfprintf_r+0x3cc>
8000945a:	fa c8 f9 50 	sub	r8,sp,-1712
8000945e:	1a d8       	st.w	--sp,r8
80009460:	fa c8 fa b8 	sub	r8,sp,-1352
80009464:	1a d8       	st.w	--sp,r8
80009466:	fa c8 fb b4 	sub	r8,sp,-1100
8000946a:	02 9a       	mov	r10,r1
8000946c:	1a d8       	st.w	--sp,r8
8000946e:	04 9c       	mov	r12,r2
80009470:	fa c8 f9 40 	sub	r8,sp,-1728
80009474:	fa c9 ff b4 	sub	r9,sp,-76
80009478:	fe b0 fc ae 	rcall	80008dd4 <get_arg>
8000947c:	2f dd       	sub	sp,-12
8000947e:	78 0c       	ld.w	r12,r12[0x0]
80009480:	50 2c       	stdsp	sp[0x8],r12
80009482:	c2 78       	rjmp	800094d0 <_vfprintf_r+0x3cc>
80009484:	12 96       	mov	r6,r9
80009486:	0e 94       	mov	r4,r7
80009488:	fa c9 f9 44 	sub	r9,sp,-1724
8000948c:	f2 03 00 38 	add	r8,r9,r3<<0x3
80009490:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80009494:	50 28       	stdsp	sp[0x8],r8
80009496:	c1 d8       	rjmp	800094d0 <_vfprintf_r+0x3cc>
80009498:	41 08       	lddsp	r8,sp[0x40]
8000949a:	59 fa       	cp.w	r10,31
8000949c:	e0 89 00 14 	brgt	800094c4 <_vfprintf_r+0x3c0>
800094a0:	f0 cb ff fc 	sub	r11,r8,-4
800094a4:	70 08       	ld.w	r8,r8[0x0]
800094a6:	51 0b       	stdsp	sp[0x40],r11
800094a8:	50 28       	stdsp	sp[0x8],r8
800094aa:	fa c6 f9 44 	sub	r6,sp,-1724
800094ae:	40 2e       	lddsp	lr,sp[0x8]
800094b0:	ec 0a 00 38 	add	r8,r6,r10<<0x3
800094b4:	f1 4e fd 88 	st.w	r8[-632],lr
800094b8:	2f fa       	sub	r10,-1
800094ba:	0e 94       	mov	r4,r7
800094bc:	fb 4a 06 b4 	st.w	sp[1716],r10
800094c0:	12 96       	mov	r6,r9
800094c2:	c0 78       	rjmp	800094d0 <_vfprintf_r+0x3cc>
800094c4:	70 0c       	ld.w	r12,r8[0x0]
800094c6:	0e 94       	mov	r4,r7
800094c8:	2f c8       	sub	r8,-4
800094ca:	50 2c       	stdsp	sp[0x8],r12
800094cc:	12 96       	mov	r6,r9
800094ce:	51 08       	stdsp	sp[0x40],r8
800094d0:	40 2b       	lddsp	r11,sp[0x8]
800094d2:	58 0b       	cp.w	r11,0
800094d4:	fe 95 fe f2 	brlt	800092b8 <_vfprintf_r+0x1b4>
800094d8:	08 97       	mov	r7,r4
800094da:	cf 5a       	rjmp	800092c4 <_vfprintf_r+0x1c0>
800094dc:	f2 09 00 29 	add	r9,r9,r9<<0x2
800094e0:	0f 38       	ld.ub	r8,r7++
800094e2:	f4 09 00 19 	add	r9,r10,r9<<0x1
800094e6:	f0 ca 00 30 	sub	r10,r8,48
800094ea:	58 9a       	cp.w	r10,9
800094ec:	fe 98 ff f8 	brls	800094dc <_vfprintf_r+0x3d8>
800094f0:	3f fa       	mov	r10,-1
800094f2:	f2 0a 0c 49 	max	r9,r9,r10
800094f6:	50 29       	stdsp	sp[0x8],r9
800094f8:	ce 9a       	rjmp	800092ca <_vfprintf_r+0x1c6>
800094fa:	a7 b5       	sbr	r5,0x7
800094fc:	ce 4a       	rjmp	800092c4 <_vfprintf_r+0x1c0>
800094fe:	30 09       	mov	r9,0
80009500:	23 08       	sub	r8,48
80009502:	f2 09 00 29 	add	r9,r9,r9<<0x2
80009506:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000950a:	0f 38       	ld.ub	r8,r7++
8000950c:	f0 ca 00 30 	sub	r10,r8,48
80009510:	58 9a       	cp.w	r10,9
80009512:	fe 98 ff f7 	brls	80009500 <_vfprintf_r+0x3fc>
80009516:	e0 48 00 24 	cp.w	r8,36
8000951a:	fe 91 fe d7 	brne	800092c8 <_vfprintf_r+0x1c4>
8000951e:	e0 49 00 20 	cp.w	r9,32
80009522:	e0 89 0d 6f 	brgt	8000b000 <_vfprintf_r+0x1efc>
80009526:	f2 c3 00 01 	sub	r3,r9,1
8000952a:	30 19       	mov	r9,1
8000952c:	50 39       	stdsp	sp[0xc],r9
8000952e:	cc ba       	rjmp	800092c4 <_vfprintf_r+0x1c0>
80009530:	a3 b5       	sbr	r5,0x3
80009532:	cc 9a       	rjmp	800092c4 <_vfprintf_r+0x1c0>
80009534:	a7 a5       	sbr	r5,0x6
80009536:	cc 7a       	rjmp	800092c4 <_vfprintf_r+0x1c0>
80009538:	0a 98       	mov	r8,r5
8000953a:	a5 b5       	sbr	r5,0x5
8000953c:	a5 a8       	sbr	r8,0x4
8000953e:	0f 89       	ld.ub	r9,r7[0x0]
80009540:	36 ce       	mov	lr,108
80009542:	fc 09 18 00 	cp.b	r9,lr
80009546:	f7 b7 00 ff 	subeq	r7,-1
8000954a:	f0 05 17 10 	movne	r5,r8
8000954e:	cb ba       	rjmp	800092c4 <_vfprintf_r+0x1c0>
80009550:	a5 b5       	sbr	r5,0x5
80009552:	cb 9a       	rjmp	800092c4 <_vfprintf_r+0x1c0>
80009554:	50 a7       	stdsp	sp[0x28],r7
80009556:	50 80       	stdsp	sp[0x20],r0
80009558:	0c 97       	mov	r7,r6
8000955a:	10 90       	mov	r0,r8
8000955c:	06 96       	mov	r6,r3
8000955e:	04 94       	mov	r4,r2
80009560:	40 93       	lddsp	r3,sp[0x24]
80009562:	02 92       	mov	r2,r1
80009564:	0e 99       	mov	r9,r7
80009566:	40 41       	lddsp	r1,sp[0x10]
80009568:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000956c:	40 3c       	lddsp	r12,sp[0xc]
8000956e:	58 0c       	cp.w	r12,0
80009570:	c1 d0       	breq	800095aa <_vfprintf_r+0x4a6>
80009572:	10 36       	cp.w	r6,r8
80009574:	c0 64       	brge	80009580 <_vfprintf_r+0x47c>
80009576:	fa cb f9 44 	sub	r11,sp,-1724
8000957a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000957e:	c1 d8       	rjmp	800095b8 <_vfprintf_r+0x4b4>
80009580:	fa c8 f9 50 	sub	r8,sp,-1712
80009584:	1a d8       	st.w	--sp,r8
80009586:	fa c8 fa b8 	sub	r8,sp,-1352
8000958a:	1a d8       	st.w	--sp,r8
8000958c:	fa c8 fb b4 	sub	r8,sp,-1100
80009590:	1a d8       	st.w	--sp,r8
80009592:	fa c8 f9 40 	sub	r8,sp,-1728
80009596:	fa c9 ff b4 	sub	r9,sp,-76
8000959a:	04 9a       	mov	r10,r2
8000959c:	0c 9b       	mov	r11,r6
8000959e:	08 9c       	mov	r12,r4
800095a0:	fe b0 fc 1a 	rcall	80008dd4 <get_arg>
800095a4:	2f dd       	sub	sp,-12
800095a6:	19 b8       	ld.ub	r8,r12[0x3]
800095a8:	c2 28       	rjmp	800095ec <_vfprintf_r+0x4e8>
800095aa:	2f f7       	sub	r7,-1
800095ac:	10 39       	cp.w	r9,r8
800095ae:	c0 84       	brge	800095be <_vfprintf_r+0x4ba>
800095b0:	fa ca f9 44 	sub	r10,sp,-1724
800095b4:	f4 06 00 36 	add	r6,r10,r6<<0x3
800095b8:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
800095bc:	c1 88       	rjmp	800095ec <_vfprintf_r+0x4e8>
800095be:	41 09       	lddsp	r9,sp[0x40]
800095c0:	59 f8       	cp.w	r8,31
800095c2:	e0 89 00 12 	brgt	800095e6 <_vfprintf_r+0x4e2>
800095c6:	f2 ca ff fc 	sub	r10,r9,-4
800095ca:	51 0a       	stdsp	sp[0x40],r10
800095cc:	72 09       	ld.w	r9,r9[0x0]
800095ce:	fa c6 f9 44 	sub	r6,sp,-1724
800095d2:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800095d6:	2f f8       	sub	r8,-1
800095d8:	f5 49 fd 88 	st.w	r10[-632],r9
800095dc:	fb 48 06 b4 	st.w	sp[1716],r8
800095e0:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800095e4:	c0 48       	rjmp	800095ec <_vfprintf_r+0x4e8>
800095e6:	13 b8       	ld.ub	r8,r9[0x3]
800095e8:	2f c9       	sub	r9,-4
800095ea:	51 09       	stdsp	sp[0x40],r9
800095ec:	fb 68 06 60 	st.b	sp[1632],r8
800095f0:	30 0e       	mov	lr,0
800095f2:	30 08       	mov	r8,0
800095f4:	30 12       	mov	r2,1
800095f6:	fb 68 06 bb 	st.b	sp[1723],r8
800095fa:	50 2e       	stdsp	sp[0x8],lr
800095fc:	e0 8f 08 ad 	bral	8000a756 <_vfprintf_r+0x1652>
80009600:	50 a7       	stdsp	sp[0x28],r7
80009602:	50 80       	stdsp	sp[0x20],r0
80009604:	0c 97       	mov	r7,r6
80009606:	04 94       	mov	r4,r2
80009608:	06 96       	mov	r6,r3
8000960a:	02 92       	mov	r2,r1
8000960c:	40 93       	lddsp	r3,sp[0x24]
8000960e:	10 90       	mov	r0,r8
80009610:	40 41       	lddsp	r1,sp[0x10]
80009612:	a5 a5       	sbr	r5,0x4
80009614:	c0 a8       	rjmp	80009628 <_vfprintf_r+0x524>
80009616:	50 a7       	stdsp	sp[0x28],r7
80009618:	50 80       	stdsp	sp[0x20],r0
8000961a:	0c 97       	mov	r7,r6
8000961c:	04 94       	mov	r4,r2
8000961e:	06 96       	mov	r6,r3
80009620:	02 92       	mov	r2,r1
80009622:	40 93       	lddsp	r3,sp[0x24]
80009624:	10 90       	mov	r0,r8
80009626:	40 41       	lddsp	r1,sp[0x10]
80009628:	ed b5 00 05 	bld	r5,0x5
8000962c:	c5 11       	brne	800096ce <_vfprintf_r+0x5ca>
8000962e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009632:	40 3c       	lddsp	r12,sp[0xc]
80009634:	58 0c       	cp.w	r12,0
80009636:	c1 e0       	breq	80009672 <_vfprintf_r+0x56e>
80009638:	10 36       	cp.w	r6,r8
8000963a:	c0 64       	brge	80009646 <_vfprintf_r+0x542>
8000963c:	fa cb f9 44 	sub	r11,sp,-1724
80009640:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009644:	c2 08       	rjmp	80009684 <_vfprintf_r+0x580>
80009646:	fa c8 f9 50 	sub	r8,sp,-1712
8000964a:	1a d8       	st.w	--sp,r8
8000964c:	fa c8 fa b8 	sub	r8,sp,-1352
80009650:	0c 9b       	mov	r11,r6
80009652:	1a d8       	st.w	--sp,r8
80009654:	fa c8 fb b4 	sub	r8,sp,-1100
80009658:	1a d8       	st.w	--sp,r8
8000965a:	fa c9 ff b4 	sub	r9,sp,-76
8000965e:	fa c8 f9 40 	sub	r8,sp,-1728
80009662:	04 9a       	mov	r10,r2
80009664:	08 9c       	mov	r12,r4
80009666:	fe b0 fb b7 	rcall	80008dd4 <get_arg>
8000966a:	2f dd       	sub	sp,-12
8000966c:	78 1b       	ld.w	r11,r12[0x4]
8000966e:	78 09       	ld.w	r9,r12[0x0]
80009670:	c2 b8       	rjmp	800096c6 <_vfprintf_r+0x5c2>
80009672:	ee ca ff ff 	sub	r10,r7,-1
80009676:	10 37       	cp.w	r7,r8
80009678:	c0 b4       	brge	8000968e <_vfprintf_r+0x58a>
8000967a:	fa c9 f9 44 	sub	r9,sp,-1724
8000967e:	14 97       	mov	r7,r10
80009680:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009684:	ec fb fd 8c 	ld.w	r11,r6[-628]
80009688:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000968c:	c1 d8       	rjmp	800096c6 <_vfprintf_r+0x5c2>
8000968e:	41 09       	lddsp	r9,sp[0x40]
80009690:	59 f8       	cp.w	r8,31
80009692:	e0 89 00 14 	brgt	800096ba <_vfprintf_r+0x5b6>
80009696:	f2 cb ff f8 	sub	r11,r9,-8
8000969a:	51 0b       	stdsp	sp[0x40],r11
8000969c:	fa c6 f9 44 	sub	r6,sp,-1724
800096a0:	72 1b       	ld.w	r11,r9[0x4]
800096a2:	ec 08 00 3c 	add	r12,r6,r8<<0x3
800096a6:	72 09       	ld.w	r9,r9[0x0]
800096a8:	f9 4b fd 8c 	st.w	r12[-628],r11
800096ac:	f9 49 fd 88 	st.w	r12[-632],r9
800096b0:	2f f8       	sub	r8,-1
800096b2:	14 97       	mov	r7,r10
800096b4:	fb 48 06 b4 	st.w	sp[1716],r8
800096b8:	c0 78       	rjmp	800096c6 <_vfprintf_r+0x5c2>
800096ba:	f2 c8 ff f8 	sub	r8,r9,-8
800096be:	72 1b       	ld.w	r11,r9[0x4]
800096c0:	14 97       	mov	r7,r10
800096c2:	51 08       	stdsp	sp[0x40],r8
800096c4:	72 09       	ld.w	r9,r9[0x0]
800096c6:	16 98       	mov	r8,r11
800096c8:	fa e9 00 00 	st.d	sp[0],r8
800096cc:	ca e8       	rjmp	80009828 <_vfprintf_r+0x724>
800096ce:	ed b5 00 04 	bld	r5,0x4
800096d2:	c1 71       	brne	80009700 <_vfprintf_r+0x5fc>
800096d4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800096d8:	40 3e       	lddsp	lr,sp[0xc]
800096da:	58 0e       	cp.w	lr,0
800096dc:	c0 80       	breq	800096ec <_vfprintf_r+0x5e8>
800096de:	10 36       	cp.w	r6,r8
800096e0:	c6 94       	brge	800097b2 <_vfprintf_r+0x6ae>
800096e2:	fa cc f9 44 	sub	r12,sp,-1724
800096e6:	f8 06 00 36 	add	r6,r12,r6<<0x3
800096ea:	c8 28       	rjmp	800097ee <_vfprintf_r+0x6ea>
800096ec:	ee ca ff ff 	sub	r10,r7,-1
800096f0:	10 37       	cp.w	r7,r8
800096f2:	e0 84 00 81 	brge	800097f4 <_vfprintf_r+0x6f0>
800096f6:	fa cb f9 44 	sub	r11,sp,-1724
800096fa:	f6 06 00 36 	add	r6,r11,r6<<0x3
800096fe:	c7 78       	rjmp	800097ec <_vfprintf_r+0x6e8>
80009700:	ed b5 00 06 	bld	r5,0x6
80009704:	c4 b1       	brne	8000979a <_vfprintf_r+0x696>
80009706:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000970a:	40 3c       	lddsp	r12,sp[0xc]
8000970c:	58 0c       	cp.w	r12,0
8000970e:	c1 d0       	breq	80009748 <_vfprintf_r+0x644>
80009710:	10 36       	cp.w	r6,r8
80009712:	c0 64       	brge	8000971e <_vfprintf_r+0x61a>
80009714:	fa cb f9 44 	sub	r11,sp,-1724
80009718:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000971c:	c1 f8       	rjmp	8000975a <_vfprintf_r+0x656>
8000971e:	fa c8 f9 50 	sub	r8,sp,-1712
80009722:	1a d8       	st.w	--sp,r8
80009724:	fa c8 fa b8 	sub	r8,sp,-1352
80009728:	1a d8       	st.w	--sp,r8
8000972a:	fa c8 fb b4 	sub	r8,sp,-1100
8000972e:	1a d8       	st.w	--sp,r8
80009730:	fa c8 f9 40 	sub	r8,sp,-1728
80009734:	fa c9 ff b4 	sub	r9,sp,-76
80009738:	04 9a       	mov	r10,r2
8000973a:	0c 9b       	mov	r11,r6
8000973c:	08 9c       	mov	r12,r4
8000973e:	fe b0 fb 4b 	rcall	80008dd4 <get_arg>
80009742:	2f dd       	sub	sp,-12
80009744:	98 18       	ld.sh	r8,r12[0x2]
80009746:	c2 68       	rjmp	80009792 <_vfprintf_r+0x68e>
80009748:	ee ca ff ff 	sub	r10,r7,-1
8000974c:	10 37       	cp.w	r7,r8
8000974e:	c0 94       	brge	80009760 <_vfprintf_r+0x65c>
80009750:	fa c9 f9 44 	sub	r9,sp,-1724
80009754:	14 97       	mov	r7,r10
80009756:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000975a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000975e:	c1 a8       	rjmp	80009792 <_vfprintf_r+0x68e>
80009760:	41 09       	lddsp	r9,sp[0x40]
80009762:	59 f8       	cp.w	r8,31
80009764:	e0 89 00 13 	brgt	8000978a <_vfprintf_r+0x686>
80009768:	f2 cb ff fc 	sub	r11,r9,-4
8000976c:	51 0b       	stdsp	sp[0x40],r11
8000976e:	72 09       	ld.w	r9,r9[0x0]
80009770:	fa c6 f9 44 	sub	r6,sp,-1724
80009774:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009778:	2f f8       	sub	r8,-1
8000977a:	f7 49 fd 88 	st.w	r11[-632],r9
8000977e:	fb 48 06 b4 	st.w	sp[1716],r8
80009782:	14 97       	mov	r7,r10
80009784:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009788:	c0 58       	rjmp	80009792 <_vfprintf_r+0x68e>
8000978a:	92 18       	ld.sh	r8,r9[0x2]
8000978c:	14 97       	mov	r7,r10
8000978e:	2f c9       	sub	r9,-4
80009790:	51 09       	stdsp	sp[0x40],r9
80009792:	50 18       	stdsp	sp[0x4],r8
80009794:	bf 58       	asr	r8,0x1f
80009796:	50 08       	stdsp	sp[0x0],r8
80009798:	c4 88       	rjmp	80009828 <_vfprintf_r+0x724>
8000979a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000979e:	40 3c       	lddsp	r12,sp[0xc]
800097a0:	58 0c       	cp.w	r12,0
800097a2:	c1 d0       	breq	800097dc <_vfprintf_r+0x6d8>
800097a4:	10 36       	cp.w	r6,r8
800097a6:	c0 64       	brge	800097b2 <_vfprintf_r+0x6ae>
800097a8:	fa cb f9 44 	sub	r11,sp,-1724
800097ac:	f6 06 00 36 	add	r6,r11,r6<<0x3
800097b0:	c1 f8       	rjmp	800097ee <_vfprintf_r+0x6ea>
800097b2:	fa c8 f9 50 	sub	r8,sp,-1712
800097b6:	1a d8       	st.w	--sp,r8
800097b8:	fa c8 fa b8 	sub	r8,sp,-1352
800097bc:	0c 9b       	mov	r11,r6
800097be:	1a d8       	st.w	--sp,r8
800097c0:	fa c8 fb b4 	sub	r8,sp,-1100
800097c4:	04 9a       	mov	r10,r2
800097c6:	1a d8       	st.w	--sp,r8
800097c8:	08 9c       	mov	r12,r4
800097ca:	fa c8 f9 40 	sub	r8,sp,-1728
800097ce:	fa c9 ff b4 	sub	r9,sp,-76
800097d2:	fe b0 fb 01 	rcall	80008dd4 <get_arg>
800097d6:	2f dd       	sub	sp,-12
800097d8:	78 0b       	ld.w	r11,r12[0x0]
800097da:	c2 48       	rjmp	80009822 <_vfprintf_r+0x71e>
800097dc:	ee ca ff ff 	sub	r10,r7,-1
800097e0:	10 37       	cp.w	r7,r8
800097e2:	c0 94       	brge	800097f4 <_vfprintf_r+0x6f0>
800097e4:	fa c9 f9 44 	sub	r9,sp,-1724
800097e8:	f2 06 00 36 	add	r6,r9,r6<<0x3
800097ec:	14 97       	mov	r7,r10
800097ee:	ec fb fd 88 	ld.w	r11,r6[-632]
800097f2:	c1 88       	rjmp	80009822 <_vfprintf_r+0x71e>
800097f4:	41 09       	lddsp	r9,sp[0x40]
800097f6:	59 f8       	cp.w	r8,31
800097f8:	e0 89 00 11 	brgt	8000981a <_vfprintf_r+0x716>
800097fc:	f2 cb ff fc 	sub	r11,r9,-4
80009800:	51 0b       	stdsp	sp[0x40],r11
80009802:	fa c6 f9 44 	sub	r6,sp,-1724
80009806:	72 0b       	ld.w	r11,r9[0x0]
80009808:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000980c:	f3 4b fd 88 	st.w	r9[-632],r11
80009810:	2f f8       	sub	r8,-1
80009812:	14 97       	mov	r7,r10
80009814:	fb 48 06 b4 	st.w	sp[1716],r8
80009818:	c0 58       	rjmp	80009822 <_vfprintf_r+0x71e>
8000981a:	72 0b       	ld.w	r11,r9[0x0]
8000981c:	14 97       	mov	r7,r10
8000981e:	2f c9       	sub	r9,-4
80009820:	51 09       	stdsp	sp[0x40],r9
80009822:	50 1b       	stdsp	sp[0x4],r11
80009824:	bf 5b       	asr	r11,0x1f
80009826:	50 0b       	stdsp	sp[0x0],r11
80009828:	fa ea 00 00 	ld.d	r10,sp[0]
8000982c:	58 0a       	cp.w	r10,0
8000982e:	5c 2b       	cpc	r11
80009830:	c0 e4       	brge	8000984c <_vfprintf_r+0x748>
80009832:	30 08       	mov	r8,0
80009834:	fa ea 00 00 	ld.d	r10,sp[0]
80009838:	30 09       	mov	r9,0
8000983a:	f0 0a 01 0a 	sub	r10,r8,r10
8000983e:	f2 0b 01 4b 	sbc	r11,r9,r11
80009842:	32 d8       	mov	r8,45
80009844:	fa eb 00 00 	st.d	sp[0],r10
80009848:	fb 68 06 bb 	st.b	sp[1723],r8
8000984c:	30 18       	mov	r8,1
8000984e:	e0 8f 06 fa 	bral	8000a642 <_vfprintf_r+0x153e>
80009852:	50 a7       	stdsp	sp[0x28],r7
80009854:	50 80       	stdsp	sp[0x20],r0
80009856:	0c 97       	mov	r7,r6
80009858:	04 94       	mov	r4,r2
8000985a:	06 96       	mov	r6,r3
8000985c:	02 92       	mov	r2,r1
8000985e:	40 93       	lddsp	r3,sp[0x24]
80009860:	10 90       	mov	r0,r8
80009862:	40 41       	lddsp	r1,sp[0x10]
80009864:	0e 99       	mov	r9,r7
80009866:	ed b5 00 03 	bld	r5,0x3
8000986a:	c4 11       	brne	800098ec <_vfprintf_r+0x7e8>
8000986c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009870:	40 3a       	lddsp	r10,sp[0xc]
80009872:	58 0a       	cp.w	r10,0
80009874:	c1 90       	breq	800098a6 <_vfprintf_r+0x7a2>
80009876:	10 36       	cp.w	r6,r8
80009878:	c6 45       	brlt	80009940 <_vfprintf_r+0x83c>
8000987a:	fa c8 f9 50 	sub	r8,sp,-1712
8000987e:	1a d8       	st.w	--sp,r8
80009880:	fa c8 fa b8 	sub	r8,sp,-1352
80009884:	1a d8       	st.w	--sp,r8
80009886:	fa c8 fb b4 	sub	r8,sp,-1100
8000988a:	0c 9b       	mov	r11,r6
8000988c:	1a d8       	st.w	--sp,r8
8000988e:	04 9a       	mov	r10,r2
80009890:	fa c8 f9 40 	sub	r8,sp,-1728
80009894:	fa c9 ff b4 	sub	r9,sp,-76
80009898:	08 9c       	mov	r12,r4
8000989a:	fe b0 fa 9d 	rcall	80008dd4 <get_arg>
8000989e:	2f dd       	sub	sp,-12
800098a0:	78 16       	ld.w	r6,r12[0x4]
800098a2:	50 76       	stdsp	sp[0x1c],r6
800098a4:	c4 88       	rjmp	80009934 <_vfprintf_r+0x830>
800098a6:	2f f7       	sub	r7,-1
800098a8:	10 39       	cp.w	r9,r8
800098aa:	c0 c4       	brge	800098c2 <_vfprintf_r+0x7be>
800098ac:	fa ce f9 44 	sub	lr,sp,-1724
800098b0:	fc 06 00 36 	add	r6,lr,r6<<0x3
800098b4:	ec fc fd 8c 	ld.w	r12,r6[-628]
800098b8:	50 7c       	stdsp	sp[0x1c],r12
800098ba:	ec f6 fd 88 	ld.w	r6,r6[-632]
800098be:	50 56       	stdsp	sp[0x14],r6
800098c0:	c6 68       	rjmp	8000998c <_vfprintf_r+0x888>
800098c2:	41 09       	lddsp	r9,sp[0x40]
800098c4:	59 f8       	cp.w	r8,31
800098c6:	e0 89 00 10 	brgt	800098e6 <_vfprintf_r+0x7e2>
800098ca:	f2 ca ff f8 	sub	r10,r9,-8
800098ce:	72 1b       	ld.w	r11,r9[0x4]
800098d0:	51 0a       	stdsp	sp[0x40],r10
800098d2:	72 09       	ld.w	r9,r9[0x0]
800098d4:	fa ca f9 44 	sub	r10,sp,-1724
800098d8:	50 7b       	stdsp	sp[0x1c],r11
800098da:	50 59       	stdsp	sp[0x14],r9
800098dc:	f4 08 00 39 	add	r9,r10,r8<<0x3
800098e0:	40 5b       	lddsp	r11,sp[0x14]
800098e2:	40 7a       	lddsp	r10,sp[0x1c]
800098e4:	c4 78       	rjmp	80009972 <_vfprintf_r+0x86e>
800098e6:	72 18       	ld.w	r8,r9[0x4]
800098e8:	50 78       	stdsp	sp[0x1c],r8
800098ea:	c4 c8       	rjmp	80009982 <_vfprintf_r+0x87e>
800098ec:	fa f8 06 b4 	ld.w	r8,sp[1716]
800098f0:	40 3e       	lddsp	lr,sp[0xc]
800098f2:	58 0e       	cp.w	lr,0
800098f4:	c2 30       	breq	8000993a <_vfprintf_r+0x836>
800098f6:	10 36       	cp.w	r6,r8
800098f8:	c0 94       	brge	8000990a <_vfprintf_r+0x806>
800098fa:	fa cc f9 44 	sub	r12,sp,-1724
800098fe:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009902:	ec fb fd 8c 	ld.w	r11,r6[-628]
80009906:	50 7b       	stdsp	sp[0x1c],r11
80009908:	cd 9b       	rjmp	800098ba <_vfprintf_r+0x7b6>
8000990a:	fa c8 f9 50 	sub	r8,sp,-1712
8000990e:	1a d8       	st.w	--sp,r8
80009910:	fa c8 fa b8 	sub	r8,sp,-1352
80009914:	04 9a       	mov	r10,r2
80009916:	1a d8       	st.w	--sp,r8
80009918:	fa c8 fb b4 	sub	r8,sp,-1100
8000991c:	0c 9b       	mov	r11,r6
8000991e:	1a d8       	st.w	--sp,r8
80009920:	08 9c       	mov	r12,r4
80009922:	fa c8 f9 40 	sub	r8,sp,-1728
80009926:	fa c9 ff b4 	sub	r9,sp,-76
8000992a:	fe b0 fa 55 	rcall	80008dd4 <get_arg>
8000992e:	2f dd       	sub	sp,-12
80009930:	78 1a       	ld.w	r10,r12[0x4]
80009932:	50 7a       	stdsp	sp[0x1c],r10
80009934:	78 0c       	ld.w	r12,r12[0x0]
80009936:	50 5c       	stdsp	sp[0x14],r12
80009938:	c2 a8       	rjmp	8000998c <_vfprintf_r+0x888>
8000993a:	2f f7       	sub	r7,-1
8000993c:	10 39       	cp.w	r9,r8
8000993e:	c0 94       	brge	80009950 <_vfprintf_r+0x84c>
80009940:	fa c9 f9 44 	sub	r9,sp,-1724
80009944:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009948:	ec f8 fd 8c 	ld.w	r8,r6[-628]
8000994c:	50 78       	stdsp	sp[0x1c],r8
8000994e:	cb 6b       	rjmp	800098ba <_vfprintf_r+0x7b6>
80009950:	41 09       	lddsp	r9,sp[0x40]
80009952:	59 f8       	cp.w	r8,31
80009954:	e0 89 00 15 	brgt	8000997e <_vfprintf_r+0x87a>
80009958:	f2 ca ff f8 	sub	r10,r9,-8
8000995c:	72 16       	ld.w	r6,r9[0x4]
8000995e:	72 09       	ld.w	r9,r9[0x0]
80009960:	51 0a       	stdsp	sp[0x40],r10
80009962:	50 59       	stdsp	sp[0x14],r9
80009964:	fa ce f9 44 	sub	lr,sp,-1724
80009968:	50 76       	stdsp	sp[0x1c],r6
8000996a:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000996e:	40 5b       	lddsp	r11,sp[0x14]
80009970:	0c 9a       	mov	r10,r6
80009972:	f2 eb fd 88 	st.d	r9[-632],r10
80009976:	2f f8       	sub	r8,-1
80009978:	fb 48 06 b4 	st.w	sp[1716],r8
8000997c:	c0 88       	rjmp	8000998c <_vfprintf_r+0x888>
8000997e:	72 1c       	ld.w	r12,r9[0x4]
80009980:	50 7c       	stdsp	sp[0x1c],r12
80009982:	f2 c8 ff f8 	sub	r8,r9,-8
80009986:	51 08       	stdsp	sp[0x40],r8
80009988:	72 09       	ld.w	r9,r9[0x0]
8000998a:	50 59       	stdsp	sp[0x14],r9
8000998c:	40 5b       	lddsp	r11,sp[0x14]
8000998e:	40 7a       	lddsp	r10,sp[0x1c]
80009990:	e0 a0 19 54 	rcall	8000cc38 <__isinfd>
80009994:	18 96       	mov	r6,r12
80009996:	c1 70       	breq	800099c4 <_vfprintf_r+0x8c0>
80009998:	30 08       	mov	r8,0
8000999a:	30 09       	mov	r9,0
8000999c:	40 5b       	lddsp	r11,sp[0x14]
8000999e:	40 7a       	lddsp	r10,sp[0x1c]
800099a0:	e0 a0 1d b4 	rcall	8000d508 <__avr32_f64_cmp_lt>
800099a4:	c0 40       	breq	800099ac <_vfprintf_r+0x8a8>
800099a6:	32 d8       	mov	r8,45
800099a8:	fb 68 06 bb 	st.b	sp[1723],r8
800099ac:	fe c8 a6 64 	sub	r8,pc,-22940
800099b0:	fe c6 a6 64 	sub	r6,pc,-22940
800099b4:	a7 d5       	cbr	r5,0x7
800099b6:	e0 40 00 47 	cp.w	r0,71
800099ba:	f0 06 17 a0 	movle	r6,r8
800099be:	30 32       	mov	r2,3
800099c0:	e0 8f 06 ce 	bral	8000a75c <_vfprintf_r+0x1658>
800099c4:	40 5b       	lddsp	r11,sp[0x14]
800099c6:	40 7a       	lddsp	r10,sp[0x1c]
800099c8:	e0 a0 19 4d 	rcall	8000cc62 <__isnand>
800099cc:	c0 e0       	breq	800099e8 <_vfprintf_r+0x8e4>
800099ce:	50 26       	stdsp	sp[0x8],r6
800099d0:	fe c8 a6 80 	sub	r8,pc,-22912
800099d4:	fe c6 a6 80 	sub	r6,pc,-22912
800099d8:	a7 d5       	cbr	r5,0x7
800099da:	e0 40 00 47 	cp.w	r0,71
800099de:	f0 06 17 a0 	movle	r6,r8
800099e2:	30 32       	mov	r2,3
800099e4:	e0 8f 06 c2 	bral	8000a768 <_vfprintf_r+0x1664>
800099e8:	40 2a       	lddsp	r10,sp[0x8]
800099ea:	5b fa       	cp.w	r10,-1
800099ec:	c0 41       	brne	800099f4 <_vfprintf_r+0x8f0>
800099ee:	30 69       	mov	r9,6
800099f0:	50 29       	stdsp	sp[0x8],r9
800099f2:	c1 18       	rjmp	80009a14 <_vfprintf_r+0x910>
800099f4:	e0 40 00 47 	cp.w	r0,71
800099f8:	5f 09       	sreq	r9
800099fa:	e0 40 00 67 	cp.w	r0,103
800099fe:	5f 08       	sreq	r8
80009a00:	f3 e8 10 08 	or	r8,r9,r8
80009a04:	f8 08 18 00 	cp.b	r8,r12
80009a08:	c0 60       	breq	80009a14 <_vfprintf_r+0x910>
80009a0a:	40 28       	lddsp	r8,sp[0x8]
80009a0c:	58 08       	cp.w	r8,0
80009a0e:	f9 b8 00 01 	moveq	r8,1
80009a12:	50 28       	stdsp	sp[0x8],r8
80009a14:	40 78       	lddsp	r8,sp[0x1c]
80009a16:	40 59       	lddsp	r9,sp[0x14]
80009a18:	fa e9 06 94 	st.d	sp[1684],r8
80009a1c:	a9 a5       	sbr	r5,0x8
80009a1e:	fa f8 06 94 	ld.w	r8,sp[1684]
80009a22:	58 08       	cp.w	r8,0
80009a24:	c0 65       	brlt	80009a30 <_vfprintf_r+0x92c>
80009a26:	40 5e       	lddsp	lr,sp[0x14]
80009a28:	30 0c       	mov	r12,0
80009a2a:	50 6e       	stdsp	sp[0x18],lr
80009a2c:	50 9c       	stdsp	sp[0x24],r12
80009a2e:	c0 78       	rjmp	80009a3c <_vfprintf_r+0x938>
80009a30:	40 5b       	lddsp	r11,sp[0x14]
80009a32:	32 da       	mov	r10,45
80009a34:	ee 1b 80 00 	eorh	r11,0x8000
80009a38:	50 9a       	stdsp	sp[0x24],r10
80009a3a:	50 6b       	stdsp	sp[0x18],r11
80009a3c:	e0 40 00 46 	cp.w	r0,70
80009a40:	5f 09       	sreq	r9
80009a42:	e0 40 00 66 	cp.w	r0,102
80009a46:	5f 08       	sreq	r8
80009a48:	f3 e8 10 08 	or	r8,r9,r8
80009a4c:	50 48       	stdsp	sp[0x10],r8
80009a4e:	c0 40       	breq	80009a56 <_vfprintf_r+0x952>
80009a50:	40 22       	lddsp	r2,sp[0x8]
80009a52:	30 39       	mov	r9,3
80009a54:	c1 08       	rjmp	80009a74 <_vfprintf_r+0x970>
80009a56:	e0 40 00 45 	cp.w	r0,69
80009a5a:	5f 09       	sreq	r9
80009a5c:	e0 40 00 65 	cp.w	r0,101
80009a60:	5f 08       	sreq	r8
80009a62:	40 22       	lddsp	r2,sp[0x8]
80009a64:	10 49       	or	r9,r8
80009a66:	2f f2       	sub	r2,-1
80009a68:	40 46       	lddsp	r6,sp[0x10]
80009a6a:	ec 09 18 00 	cp.b	r9,r6
80009a6e:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80009a72:	30 29       	mov	r9,2
80009a74:	fa c8 f9 5c 	sub	r8,sp,-1700
80009a78:	1a d8       	st.w	--sp,r8
80009a7a:	fa c8 f9 54 	sub	r8,sp,-1708
80009a7e:	1a d8       	st.w	--sp,r8
80009a80:	fa c8 f9 4c 	sub	r8,sp,-1716
80009a84:	08 9c       	mov	r12,r4
80009a86:	1a d8       	st.w	--sp,r8
80009a88:	04 98       	mov	r8,r2
80009a8a:	40 9b       	lddsp	r11,sp[0x24]
80009a8c:	40 aa       	lddsp	r10,sp[0x28]
80009a8e:	e0 a0 0b c3 	rcall	8000b214 <_dtoa_r>
80009a92:	e0 40 00 47 	cp.w	r0,71
80009a96:	5f 19       	srne	r9
80009a98:	e0 40 00 67 	cp.w	r0,103
80009a9c:	5f 18       	srne	r8
80009a9e:	18 96       	mov	r6,r12
80009aa0:	2f dd       	sub	sp,-12
80009aa2:	f3 e8 00 08 	and	r8,r9,r8
80009aa6:	c0 41       	brne	80009aae <_vfprintf_r+0x9aa>
80009aa8:	ed b5 00 00 	bld	r5,0x0
80009aac:	c3 01       	brne	80009b0c <_vfprintf_r+0xa08>
80009aae:	ec 02 00 0e 	add	lr,r6,r2
80009ab2:	50 3e       	stdsp	sp[0xc],lr
80009ab4:	40 4c       	lddsp	r12,sp[0x10]
80009ab6:	58 0c       	cp.w	r12,0
80009ab8:	c1 50       	breq	80009ae2 <_vfprintf_r+0x9de>
80009aba:	0d 89       	ld.ub	r9,r6[0x0]
80009abc:	33 08       	mov	r8,48
80009abe:	f0 09 18 00 	cp.b	r9,r8
80009ac2:	c0 b1       	brne	80009ad8 <_vfprintf_r+0x9d4>
80009ac4:	30 08       	mov	r8,0
80009ac6:	30 09       	mov	r9,0
80009ac8:	40 6b       	lddsp	r11,sp[0x18]
80009aca:	40 7a       	lddsp	r10,sp[0x1c]
80009acc:	e0 a0 1c d7 	rcall	8000d47a <__avr32_f64_cmp_eq>
80009ad0:	fb b2 00 01 	rsubeq	r2,1
80009ad4:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80009ad8:	40 3b       	lddsp	r11,sp[0xc]
80009ada:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009ade:	10 0b       	add	r11,r8
80009ae0:	50 3b       	stdsp	sp[0xc],r11
80009ae2:	40 6b       	lddsp	r11,sp[0x18]
80009ae4:	30 08       	mov	r8,0
80009ae6:	30 09       	mov	r9,0
80009ae8:	40 7a       	lddsp	r10,sp[0x1c]
80009aea:	e0 a0 1c c8 	rcall	8000d47a <__avr32_f64_cmp_eq>
80009aee:	c0 90       	breq	80009b00 <_vfprintf_r+0x9fc>
80009af0:	40 3a       	lddsp	r10,sp[0xc]
80009af2:	fb 4a 06 a4 	st.w	sp[1700],r10
80009af6:	c0 58       	rjmp	80009b00 <_vfprintf_r+0x9fc>
80009af8:	10 c9       	st.b	r8++,r9
80009afa:	fb 48 06 a4 	st.w	sp[1700],r8
80009afe:	c0 28       	rjmp	80009b02 <_vfprintf_r+0x9fe>
80009b00:	33 09       	mov	r9,48
80009b02:	fa f8 06 a4 	ld.w	r8,sp[1700]
80009b06:	40 3e       	lddsp	lr,sp[0xc]
80009b08:	1c 38       	cp.w	r8,lr
80009b0a:	cf 73       	brcs	80009af8 <_vfprintf_r+0x9f4>
80009b0c:	e0 40 00 47 	cp.w	r0,71
80009b10:	5f 09       	sreq	r9
80009b12:	e0 40 00 67 	cp.w	r0,103
80009b16:	5f 08       	sreq	r8
80009b18:	f3 e8 10 08 	or	r8,r9,r8
80009b1c:	fa f9 06 a4 	ld.w	r9,sp[1700]
80009b20:	0c 19       	sub	r9,r6
80009b22:	50 69       	stdsp	sp[0x18],r9
80009b24:	58 08       	cp.w	r8,0
80009b26:	c0 b0       	breq	80009b3c <_vfprintf_r+0xa38>
80009b28:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009b2c:	5b d8       	cp.w	r8,-3
80009b2e:	c0 55       	brlt	80009b38 <_vfprintf_r+0xa34>
80009b30:	40 2c       	lddsp	r12,sp[0x8]
80009b32:	18 38       	cp.w	r8,r12
80009b34:	e0 8a 00 6a 	brle	80009c08 <_vfprintf_r+0xb04>
80009b38:	20 20       	sub	r0,2
80009b3a:	c0 58       	rjmp	80009b44 <_vfprintf_r+0xa40>
80009b3c:	e0 40 00 65 	cp.w	r0,101
80009b40:	e0 89 00 46 	brgt	80009bcc <_vfprintf_r+0xac8>
80009b44:	fa fb 06 ac 	ld.w	r11,sp[1708]
80009b48:	fb 60 06 9c 	st.b	sp[1692],r0
80009b4c:	20 1b       	sub	r11,1
80009b4e:	fb 4b 06 ac 	st.w	sp[1708],r11
80009b52:	c0 47       	brpl	80009b5a <_vfprintf_r+0xa56>
80009b54:	5c 3b       	neg	r11
80009b56:	32 d8       	mov	r8,45
80009b58:	c0 28       	rjmp	80009b5c <_vfprintf_r+0xa58>
80009b5a:	32 b8       	mov	r8,43
80009b5c:	fb 68 06 9d 	st.b	sp[1693],r8
80009b60:	58 9b       	cp.w	r11,9
80009b62:	e0 8a 00 1d 	brle	80009b9c <_vfprintf_r+0xa98>
80009b66:	fa c9 fa 35 	sub	r9,sp,-1483
80009b6a:	30 aa       	mov	r10,10
80009b6c:	12 98       	mov	r8,r9
80009b6e:	0e 9c       	mov	r12,r7
80009b70:	0c 92       	mov	r2,r6
80009b72:	f6 0a 0c 06 	divs	r6,r11,r10
80009b76:	0e 9b       	mov	r11,r7
80009b78:	2d 0b       	sub	r11,-48
80009b7a:	10 fb       	st.b	--r8,r11
80009b7c:	0c 9b       	mov	r11,r6
80009b7e:	58 96       	cp.w	r6,9
80009b80:	fe 99 ff f9 	brgt	80009b72 <_vfprintf_r+0xa6e>
80009b84:	2d 0b       	sub	r11,-48
80009b86:	18 97       	mov	r7,r12
80009b88:	04 96       	mov	r6,r2
80009b8a:	10 fb       	st.b	--r8,r11
80009b8c:	fa ca f9 62 	sub	r10,sp,-1694
80009b90:	c0 38       	rjmp	80009b96 <_vfprintf_r+0xa92>
80009b92:	11 3b       	ld.ub	r11,r8++
80009b94:	14 cb       	st.b	r10++,r11
80009b96:	12 38       	cp.w	r8,r9
80009b98:	cf d3       	brcs	80009b92 <_vfprintf_r+0xa8e>
80009b9a:	c0 98       	rjmp	80009bac <_vfprintf_r+0xaa8>
80009b9c:	2d 0b       	sub	r11,-48
80009b9e:	33 08       	mov	r8,48
80009ba0:	fb 6b 06 9f 	st.b	sp[1695],r11
80009ba4:	fb 68 06 9e 	st.b	sp[1694],r8
80009ba8:	fa ca f9 60 	sub	r10,sp,-1696
80009bac:	fa c8 f9 64 	sub	r8,sp,-1692
80009bb0:	f4 08 01 08 	sub	r8,r10,r8
80009bb4:	50 e8       	stdsp	sp[0x38],r8
80009bb6:	10 92       	mov	r2,r8
80009bb8:	40 6b       	lddsp	r11,sp[0x18]
80009bba:	16 02       	add	r2,r11
80009bbc:	58 1b       	cp.w	r11,1
80009bbe:	e0 89 00 05 	brgt	80009bc8 <_vfprintf_r+0xac4>
80009bc2:	ed b5 00 00 	bld	r5,0x0
80009bc6:	c3 51       	brne	80009c30 <_vfprintf_r+0xb2c>
80009bc8:	2f f2       	sub	r2,-1
80009bca:	c3 38       	rjmp	80009c30 <_vfprintf_r+0xb2c>
80009bcc:	e0 40 00 66 	cp.w	r0,102
80009bd0:	c1 c1       	brne	80009c08 <_vfprintf_r+0xb04>
80009bd2:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009bd6:	58 02       	cp.w	r2,0
80009bd8:	e0 8a 00 0c 	brle	80009bf0 <_vfprintf_r+0xaec>
80009bdc:	40 2a       	lddsp	r10,sp[0x8]
80009bde:	58 0a       	cp.w	r10,0
80009be0:	c0 41       	brne	80009be8 <_vfprintf_r+0xae4>
80009be2:	ed b5 00 00 	bld	r5,0x0
80009be6:	c2 51       	brne	80009c30 <_vfprintf_r+0xb2c>
80009be8:	2f f2       	sub	r2,-1
80009bea:	40 29       	lddsp	r9,sp[0x8]
80009bec:	12 02       	add	r2,r9
80009bee:	c0 b8       	rjmp	80009c04 <_vfprintf_r+0xb00>
80009bf0:	40 28       	lddsp	r8,sp[0x8]
80009bf2:	58 08       	cp.w	r8,0
80009bf4:	c0 61       	brne	80009c00 <_vfprintf_r+0xafc>
80009bf6:	ed b5 00 00 	bld	r5,0x0
80009bfa:	c0 30       	breq	80009c00 <_vfprintf_r+0xafc>
80009bfc:	30 12       	mov	r2,1
80009bfe:	c1 98       	rjmp	80009c30 <_vfprintf_r+0xb2c>
80009c00:	40 22       	lddsp	r2,sp[0x8]
80009c02:	2f e2       	sub	r2,-2
80009c04:	36 60       	mov	r0,102
80009c06:	c1 58       	rjmp	80009c30 <_vfprintf_r+0xb2c>
80009c08:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009c0c:	40 6e       	lddsp	lr,sp[0x18]
80009c0e:	1c 32       	cp.w	r2,lr
80009c10:	c0 65       	brlt	80009c1c <_vfprintf_r+0xb18>
80009c12:	ed b5 00 00 	bld	r5,0x0
80009c16:	f7 b2 00 ff 	subeq	r2,-1
80009c1a:	c0 a8       	rjmp	80009c2e <_vfprintf_r+0xb2a>
80009c1c:	e4 08 11 02 	rsub	r8,r2,2
80009c20:	40 6c       	lddsp	r12,sp[0x18]
80009c22:	58 02       	cp.w	r2,0
80009c24:	f0 02 17 a0 	movle	r2,r8
80009c28:	f9 b2 09 01 	movgt	r2,1
80009c2c:	18 02       	add	r2,r12
80009c2e:	36 70       	mov	r0,103
80009c30:	40 9b       	lddsp	r11,sp[0x24]
80009c32:	58 0b       	cp.w	r11,0
80009c34:	e0 80 05 94 	breq	8000a75c <_vfprintf_r+0x1658>
80009c38:	32 d8       	mov	r8,45
80009c3a:	fb 68 06 bb 	st.b	sp[1723],r8
80009c3e:	e0 8f 05 93 	bral	8000a764 <_vfprintf_r+0x1660>
80009c42:	50 a7       	stdsp	sp[0x28],r7
80009c44:	04 94       	mov	r4,r2
80009c46:	0c 97       	mov	r7,r6
80009c48:	02 92       	mov	r2,r1
80009c4a:	06 96       	mov	r6,r3
80009c4c:	40 41       	lddsp	r1,sp[0x10]
80009c4e:	40 93       	lddsp	r3,sp[0x24]
80009c50:	0e 99       	mov	r9,r7
80009c52:	ed b5 00 05 	bld	r5,0x5
80009c56:	c4 81       	brne	80009ce6 <_vfprintf_r+0xbe2>
80009c58:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009c5c:	40 3e       	lddsp	lr,sp[0xc]
80009c5e:	58 0e       	cp.w	lr,0
80009c60:	c1 d0       	breq	80009c9a <_vfprintf_r+0xb96>
80009c62:	10 36       	cp.w	r6,r8
80009c64:	c0 64       	brge	80009c70 <_vfprintf_r+0xb6c>
80009c66:	fa cc f9 44 	sub	r12,sp,-1724
80009c6a:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009c6e:	c1 d8       	rjmp	80009ca8 <_vfprintf_r+0xba4>
80009c70:	fa c8 f9 50 	sub	r8,sp,-1712
80009c74:	1a d8       	st.w	--sp,r8
80009c76:	fa c8 fa b8 	sub	r8,sp,-1352
80009c7a:	04 9a       	mov	r10,r2
80009c7c:	1a d8       	st.w	--sp,r8
80009c7e:	fa c8 fb b4 	sub	r8,sp,-1100
80009c82:	0c 9b       	mov	r11,r6
80009c84:	1a d8       	st.w	--sp,r8
80009c86:	08 9c       	mov	r12,r4
80009c88:	fa c8 f9 40 	sub	r8,sp,-1728
80009c8c:	fa c9 ff b4 	sub	r9,sp,-76
80009c90:	fe b0 f8 a2 	rcall	80008dd4 <get_arg>
80009c94:	2f dd       	sub	sp,-12
80009c96:	78 0a       	ld.w	r10,r12[0x0]
80009c98:	c2 08       	rjmp	80009cd8 <_vfprintf_r+0xbd4>
80009c9a:	2f f7       	sub	r7,-1
80009c9c:	10 39       	cp.w	r9,r8
80009c9e:	c0 84       	brge	80009cae <_vfprintf_r+0xbaa>
80009ca0:	fa cb f9 44 	sub	r11,sp,-1724
80009ca4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009ca8:	ec fa fd 88 	ld.w	r10,r6[-632]
80009cac:	c1 68       	rjmp	80009cd8 <_vfprintf_r+0xbd4>
80009cae:	41 09       	lddsp	r9,sp[0x40]
80009cb0:	59 f8       	cp.w	r8,31
80009cb2:	e0 89 00 10 	brgt	80009cd2 <_vfprintf_r+0xbce>
80009cb6:	f2 ca ff fc 	sub	r10,r9,-4
80009cba:	51 0a       	stdsp	sp[0x40],r10
80009cbc:	fa c6 f9 44 	sub	r6,sp,-1724
80009cc0:	72 0a       	ld.w	r10,r9[0x0]
80009cc2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009cc6:	f3 4a fd 88 	st.w	r9[-632],r10
80009cca:	2f f8       	sub	r8,-1
80009ccc:	fb 48 06 b4 	st.w	sp[1716],r8
80009cd0:	c0 48       	rjmp	80009cd8 <_vfprintf_r+0xbd4>
80009cd2:	72 0a       	ld.w	r10,r9[0x0]
80009cd4:	2f c9       	sub	r9,-4
80009cd6:	51 09       	stdsp	sp[0x40],r9
80009cd8:	40 be       	lddsp	lr,sp[0x2c]
80009cda:	1c 98       	mov	r8,lr
80009cdc:	95 1e       	st.w	r10[0x4],lr
80009cde:	bf 58       	asr	r8,0x1f
80009ce0:	95 08       	st.w	r10[0x0],r8
80009ce2:	fe 9f fa 9f 	bral	80009220 <_vfprintf_r+0x11c>
80009ce6:	ed b5 00 04 	bld	r5,0x4
80009cea:	c4 80       	breq	80009d7a <_vfprintf_r+0xc76>
80009cec:	e2 15 00 40 	andl	r5,0x40,COH
80009cf0:	c4 50       	breq	80009d7a <_vfprintf_r+0xc76>
80009cf2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009cf6:	40 3c       	lddsp	r12,sp[0xc]
80009cf8:	58 0c       	cp.w	r12,0
80009cfa:	c1 d0       	breq	80009d34 <_vfprintf_r+0xc30>
80009cfc:	10 36       	cp.w	r6,r8
80009cfe:	c0 64       	brge	80009d0a <_vfprintf_r+0xc06>
80009d00:	fa cb f9 44 	sub	r11,sp,-1724
80009d04:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009d08:	c1 d8       	rjmp	80009d42 <_vfprintf_r+0xc3e>
80009d0a:	fa c8 f9 50 	sub	r8,sp,-1712
80009d0e:	1a d8       	st.w	--sp,r8
80009d10:	fa c8 fa b8 	sub	r8,sp,-1352
80009d14:	04 9a       	mov	r10,r2
80009d16:	1a d8       	st.w	--sp,r8
80009d18:	fa c8 fb b4 	sub	r8,sp,-1100
80009d1c:	0c 9b       	mov	r11,r6
80009d1e:	1a d8       	st.w	--sp,r8
80009d20:	08 9c       	mov	r12,r4
80009d22:	fa c8 f9 40 	sub	r8,sp,-1728
80009d26:	fa c9 ff b4 	sub	r9,sp,-76
80009d2a:	fe b0 f8 55 	rcall	80008dd4 <get_arg>
80009d2e:	2f dd       	sub	sp,-12
80009d30:	78 0a       	ld.w	r10,r12[0x0]
80009d32:	c2 08       	rjmp	80009d72 <_vfprintf_r+0xc6e>
80009d34:	2f f7       	sub	r7,-1
80009d36:	10 39       	cp.w	r9,r8
80009d38:	c0 84       	brge	80009d48 <_vfprintf_r+0xc44>
80009d3a:	fa ca f9 44 	sub	r10,sp,-1724
80009d3e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009d42:	ec fa fd 88 	ld.w	r10,r6[-632]
80009d46:	c1 68       	rjmp	80009d72 <_vfprintf_r+0xc6e>
80009d48:	41 09       	lddsp	r9,sp[0x40]
80009d4a:	59 f8       	cp.w	r8,31
80009d4c:	e0 89 00 10 	brgt	80009d6c <_vfprintf_r+0xc68>
80009d50:	f2 ca ff fc 	sub	r10,r9,-4
80009d54:	51 0a       	stdsp	sp[0x40],r10
80009d56:	fa c6 f9 44 	sub	r6,sp,-1724
80009d5a:	72 0a       	ld.w	r10,r9[0x0]
80009d5c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009d60:	f3 4a fd 88 	st.w	r9[-632],r10
80009d64:	2f f8       	sub	r8,-1
80009d66:	fb 48 06 b4 	st.w	sp[1716],r8
80009d6a:	c0 48       	rjmp	80009d72 <_vfprintf_r+0xc6e>
80009d6c:	72 0a       	ld.w	r10,r9[0x0]
80009d6e:	2f c9       	sub	r9,-4
80009d70:	51 09       	stdsp	sp[0x40],r9
80009d72:	40 be       	lddsp	lr,sp[0x2c]
80009d74:	b4 0e       	st.h	r10[0x0],lr
80009d76:	fe 9f fa 55 	bral	80009220 <_vfprintf_r+0x11c>
80009d7a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009d7e:	40 3c       	lddsp	r12,sp[0xc]
80009d80:	58 0c       	cp.w	r12,0
80009d82:	c1 d0       	breq	80009dbc <_vfprintf_r+0xcb8>
80009d84:	10 36       	cp.w	r6,r8
80009d86:	c0 64       	brge	80009d92 <_vfprintf_r+0xc8e>
80009d88:	fa cb f9 44 	sub	r11,sp,-1724
80009d8c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009d90:	c1 d8       	rjmp	80009dca <_vfprintf_r+0xcc6>
80009d92:	fa c8 f9 50 	sub	r8,sp,-1712
80009d96:	1a d8       	st.w	--sp,r8
80009d98:	fa c8 fa b8 	sub	r8,sp,-1352
80009d9c:	04 9a       	mov	r10,r2
80009d9e:	1a d8       	st.w	--sp,r8
80009da0:	fa c8 fb b4 	sub	r8,sp,-1100
80009da4:	0c 9b       	mov	r11,r6
80009da6:	1a d8       	st.w	--sp,r8
80009da8:	08 9c       	mov	r12,r4
80009daa:	fa c8 f9 40 	sub	r8,sp,-1728
80009dae:	fa c9 ff b4 	sub	r9,sp,-76
80009db2:	fe b0 f8 11 	rcall	80008dd4 <get_arg>
80009db6:	2f dd       	sub	sp,-12
80009db8:	78 0a       	ld.w	r10,r12[0x0]
80009dba:	c2 08       	rjmp	80009dfa <_vfprintf_r+0xcf6>
80009dbc:	2f f7       	sub	r7,-1
80009dbe:	10 39       	cp.w	r9,r8
80009dc0:	c0 84       	brge	80009dd0 <_vfprintf_r+0xccc>
80009dc2:	fa ca f9 44 	sub	r10,sp,-1724
80009dc6:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009dca:	ec fa fd 88 	ld.w	r10,r6[-632]
80009dce:	c1 68       	rjmp	80009dfa <_vfprintf_r+0xcf6>
80009dd0:	41 09       	lddsp	r9,sp[0x40]
80009dd2:	59 f8       	cp.w	r8,31
80009dd4:	e0 89 00 10 	brgt	80009df4 <_vfprintf_r+0xcf0>
80009dd8:	f2 ca ff fc 	sub	r10,r9,-4
80009ddc:	51 0a       	stdsp	sp[0x40],r10
80009dde:	fa c6 f9 44 	sub	r6,sp,-1724
80009de2:	72 0a       	ld.w	r10,r9[0x0]
80009de4:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009de8:	f3 4a fd 88 	st.w	r9[-632],r10
80009dec:	2f f8       	sub	r8,-1
80009dee:	fb 48 06 b4 	st.w	sp[1716],r8
80009df2:	c0 48       	rjmp	80009dfa <_vfprintf_r+0xcf6>
80009df4:	72 0a       	ld.w	r10,r9[0x0]
80009df6:	2f c9       	sub	r9,-4
80009df8:	51 09       	stdsp	sp[0x40],r9
80009dfa:	40 be       	lddsp	lr,sp[0x2c]
80009dfc:	95 0e       	st.w	r10[0x0],lr
80009dfe:	fe 9f fa 11 	bral	80009220 <_vfprintf_r+0x11c>
80009e02:	50 a7       	stdsp	sp[0x28],r7
80009e04:	50 80       	stdsp	sp[0x20],r0
80009e06:	0c 97       	mov	r7,r6
80009e08:	04 94       	mov	r4,r2
80009e0a:	06 96       	mov	r6,r3
80009e0c:	02 92       	mov	r2,r1
80009e0e:	40 93       	lddsp	r3,sp[0x24]
80009e10:	10 90       	mov	r0,r8
80009e12:	40 41       	lddsp	r1,sp[0x10]
80009e14:	a5 a5       	sbr	r5,0x4
80009e16:	c0 a8       	rjmp	80009e2a <_vfprintf_r+0xd26>
80009e18:	50 a7       	stdsp	sp[0x28],r7
80009e1a:	50 80       	stdsp	sp[0x20],r0
80009e1c:	0c 97       	mov	r7,r6
80009e1e:	04 94       	mov	r4,r2
80009e20:	06 96       	mov	r6,r3
80009e22:	02 92       	mov	r2,r1
80009e24:	40 93       	lddsp	r3,sp[0x24]
80009e26:	10 90       	mov	r0,r8
80009e28:	40 41       	lddsp	r1,sp[0x10]
80009e2a:	ed b5 00 05 	bld	r5,0x5
80009e2e:	c5 d1       	brne	80009ee8 <_vfprintf_r+0xde4>
80009e30:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009e34:	40 3c       	lddsp	r12,sp[0xc]
80009e36:	58 0c       	cp.w	r12,0
80009e38:	c2 60       	breq	80009e84 <_vfprintf_r+0xd80>
80009e3a:	10 36       	cp.w	r6,r8
80009e3c:	c0 a4       	brge	80009e50 <_vfprintf_r+0xd4c>
80009e3e:	fa cb f9 44 	sub	r11,sp,-1724
80009e42:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009e46:	ec e8 fd 88 	ld.d	r8,r6[-632]
80009e4a:	fa e9 00 00 	st.d	sp[0],r8
80009e4e:	c1 88       	rjmp	80009e7e <_vfprintf_r+0xd7a>
80009e50:	fa c8 f9 50 	sub	r8,sp,-1712
80009e54:	1a d8       	st.w	--sp,r8
80009e56:	fa c8 fa b8 	sub	r8,sp,-1352
80009e5a:	04 9a       	mov	r10,r2
80009e5c:	1a d8       	st.w	--sp,r8
80009e5e:	0c 9b       	mov	r11,r6
80009e60:	fa c8 fb b4 	sub	r8,sp,-1100
80009e64:	08 9c       	mov	r12,r4
80009e66:	1a d8       	st.w	--sp,r8
80009e68:	fa c8 f9 40 	sub	r8,sp,-1728
80009e6c:	fa c9 ff b4 	sub	r9,sp,-76
80009e70:	fe b0 f7 b2 	rcall	80008dd4 <get_arg>
80009e74:	2f dd       	sub	sp,-12
80009e76:	f8 ea 00 00 	ld.d	r10,r12[0]
80009e7a:	fa eb 00 00 	st.d	sp[0],r10
80009e7e:	30 08       	mov	r8,0
80009e80:	e0 8f 03 de 	bral	8000a63c <_vfprintf_r+0x1538>
80009e84:	ee ca ff ff 	sub	r10,r7,-1
80009e88:	10 37       	cp.w	r7,r8
80009e8a:	c0 b4       	brge	80009ea0 <_vfprintf_r+0xd9c>
80009e8c:	fa c9 f9 44 	sub	r9,sp,-1724
80009e90:	14 97       	mov	r7,r10
80009e92:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009e96:	ec ea fd 88 	ld.d	r10,r6[-632]
80009e9a:	fa eb 00 00 	st.d	sp[0],r10
80009e9e:	c1 88       	rjmp	80009ece <_vfprintf_r+0xdca>
80009ea0:	41 09       	lddsp	r9,sp[0x40]
80009ea2:	59 f8       	cp.w	r8,31
80009ea4:	e0 89 00 18 	brgt	80009ed4 <_vfprintf_r+0xdd0>
80009ea8:	f2 e6 00 00 	ld.d	r6,r9[0]
80009eac:	f2 cb ff f8 	sub	r11,r9,-8
80009eb0:	fa e7 00 00 	st.d	sp[0],r6
80009eb4:	51 0b       	stdsp	sp[0x40],r11
80009eb6:	fa c6 f9 44 	sub	r6,sp,-1724
80009eba:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009ebe:	fa e6 00 00 	ld.d	r6,sp[0]
80009ec2:	f2 e7 fd 88 	st.d	r9[-632],r6
80009ec6:	2f f8       	sub	r8,-1
80009ec8:	14 97       	mov	r7,r10
80009eca:	fb 48 06 b4 	st.w	sp[1716],r8
80009ece:	40 38       	lddsp	r8,sp[0xc]
80009ed0:	e0 8f 03 b6 	bral	8000a63c <_vfprintf_r+0x1538>
80009ed4:	f2 e6 00 00 	ld.d	r6,r9[0]
80009ed8:	40 38       	lddsp	r8,sp[0xc]
80009eda:	fa e7 00 00 	st.d	sp[0],r6
80009ede:	2f 89       	sub	r9,-8
80009ee0:	14 97       	mov	r7,r10
80009ee2:	51 09       	stdsp	sp[0x40],r9
80009ee4:	e0 8f 03 ac 	bral	8000a63c <_vfprintf_r+0x1538>
80009ee8:	ed b5 00 04 	bld	r5,0x4
80009eec:	c1 61       	brne	80009f18 <_vfprintf_r+0xe14>
80009eee:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009ef2:	40 3e       	lddsp	lr,sp[0xc]
80009ef4:	58 0e       	cp.w	lr,0
80009ef6:	c0 80       	breq	80009f06 <_vfprintf_r+0xe02>
80009ef8:	10 36       	cp.w	r6,r8
80009efa:	c6 74       	brge	80009fc8 <_vfprintf_r+0xec4>
80009efc:	fa cc f9 44 	sub	r12,sp,-1724
80009f00:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009f04:	c8 08       	rjmp	8000a004 <_vfprintf_r+0xf00>
80009f06:	ee ca ff ff 	sub	r10,r7,-1
80009f0a:	10 37       	cp.w	r7,r8
80009f0c:	c7 f4       	brge	8000a00a <_vfprintf_r+0xf06>
80009f0e:	fa cb f9 44 	sub	r11,sp,-1724
80009f12:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009f16:	c7 68       	rjmp	8000a002 <_vfprintf_r+0xefe>
80009f18:	ed b5 00 06 	bld	r5,0x6
80009f1c:	c4 a1       	brne	80009fb0 <_vfprintf_r+0xeac>
80009f1e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009f22:	40 3c       	lddsp	r12,sp[0xc]
80009f24:	58 0c       	cp.w	r12,0
80009f26:	c1 d0       	breq	80009f60 <_vfprintf_r+0xe5c>
80009f28:	10 36       	cp.w	r6,r8
80009f2a:	c0 64       	brge	80009f36 <_vfprintf_r+0xe32>
80009f2c:	fa cb f9 44 	sub	r11,sp,-1724
80009f30:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009f34:	c1 f8       	rjmp	80009f72 <_vfprintf_r+0xe6e>
80009f36:	fa c8 f9 50 	sub	r8,sp,-1712
80009f3a:	1a d8       	st.w	--sp,r8
80009f3c:	fa c8 fa b8 	sub	r8,sp,-1352
80009f40:	1a d8       	st.w	--sp,r8
80009f42:	fa c8 fb b4 	sub	r8,sp,-1100
80009f46:	1a d8       	st.w	--sp,r8
80009f48:	fa c8 f9 40 	sub	r8,sp,-1728
80009f4c:	fa c9 ff b4 	sub	r9,sp,-76
80009f50:	04 9a       	mov	r10,r2
80009f52:	0c 9b       	mov	r11,r6
80009f54:	08 9c       	mov	r12,r4
80009f56:	fe b0 f7 3f 	rcall	80008dd4 <get_arg>
80009f5a:	2f dd       	sub	sp,-12
80009f5c:	98 18       	ld.sh	r8,r12[0x2]
80009f5e:	c2 68       	rjmp	80009faa <_vfprintf_r+0xea6>
80009f60:	ee ca ff ff 	sub	r10,r7,-1
80009f64:	10 37       	cp.w	r7,r8
80009f66:	c0 94       	brge	80009f78 <_vfprintf_r+0xe74>
80009f68:	fa c9 f9 44 	sub	r9,sp,-1724
80009f6c:	14 97       	mov	r7,r10
80009f6e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009f72:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009f76:	c1 a8       	rjmp	80009faa <_vfprintf_r+0xea6>
80009f78:	41 09       	lddsp	r9,sp[0x40]
80009f7a:	59 f8       	cp.w	r8,31
80009f7c:	e0 89 00 13 	brgt	80009fa2 <_vfprintf_r+0xe9e>
80009f80:	f2 cb ff fc 	sub	r11,r9,-4
80009f84:	51 0b       	stdsp	sp[0x40],r11
80009f86:	72 09       	ld.w	r9,r9[0x0]
80009f88:	fa c6 f9 44 	sub	r6,sp,-1724
80009f8c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009f90:	2f f8       	sub	r8,-1
80009f92:	f7 49 fd 88 	st.w	r11[-632],r9
80009f96:	fb 48 06 b4 	st.w	sp[1716],r8
80009f9a:	14 97       	mov	r7,r10
80009f9c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009fa0:	c0 58       	rjmp	80009faa <_vfprintf_r+0xea6>
80009fa2:	92 18       	ld.sh	r8,r9[0x2]
80009fa4:	14 97       	mov	r7,r10
80009fa6:	2f c9       	sub	r9,-4
80009fa8:	51 09       	stdsp	sp[0x40],r9
80009faa:	5c 78       	castu.h	r8
80009fac:	50 18       	stdsp	sp[0x4],r8
80009fae:	c4 68       	rjmp	8000a03a <_vfprintf_r+0xf36>
80009fb0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009fb4:	40 3c       	lddsp	r12,sp[0xc]
80009fb6:	58 0c       	cp.w	r12,0
80009fb8:	c1 d0       	breq	80009ff2 <_vfprintf_r+0xeee>
80009fba:	10 36       	cp.w	r6,r8
80009fbc:	c0 64       	brge	80009fc8 <_vfprintf_r+0xec4>
80009fbe:	fa cb f9 44 	sub	r11,sp,-1724
80009fc2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009fc6:	c1 f8       	rjmp	8000a004 <_vfprintf_r+0xf00>
80009fc8:	fa c8 f9 50 	sub	r8,sp,-1712
80009fcc:	1a d8       	st.w	--sp,r8
80009fce:	fa c8 fa b8 	sub	r8,sp,-1352
80009fd2:	0c 9b       	mov	r11,r6
80009fd4:	1a d8       	st.w	--sp,r8
80009fd6:	fa c8 fb b4 	sub	r8,sp,-1100
80009fda:	04 9a       	mov	r10,r2
80009fdc:	1a d8       	st.w	--sp,r8
80009fde:	08 9c       	mov	r12,r4
80009fe0:	fa c8 f9 40 	sub	r8,sp,-1728
80009fe4:	fa c9 ff b4 	sub	r9,sp,-76
80009fe8:	fe b0 f6 f6 	rcall	80008dd4 <get_arg>
80009fec:	2f dd       	sub	sp,-12
80009fee:	78 0b       	ld.w	r11,r12[0x0]
80009ff0:	c2 48       	rjmp	8000a038 <_vfprintf_r+0xf34>
80009ff2:	ee ca ff ff 	sub	r10,r7,-1
80009ff6:	10 37       	cp.w	r7,r8
80009ff8:	c0 94       	brge	8000a00a <_vfprintf_r+0xf06>
80009ffa:	fa c9 f9 44 	sub	r9,sp,-1724
80009ffe:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a002:	14 97       	mov	r7,r10
8000a004:	ec fb fd 88 	ld.w	r11,r6[-632]
8000a008:	c1 88       	rjmp	8000a038 <_vfprintf_r+0xf34>
8000a00a:	41 09       	lddsp	r9,sp[0x40]
8000a00c:	59 f8       	cp.w	r8,31
8000a00e:	e0 89 00 11 	brgt	8000a030 <_vfprintf_r+0xf2c>
8000a012:	f2 cb ff fc 	sub	r11,r9,-4
8000a016:	51 0b       	stdsp	sp[0x40],r11
8000a018:	fa c6 f9 44 	sub	r6,sp,-1724
8000a01c:	72 0b       	ld.w	r11,r9[0x0]
8000a01e:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a022:	f3 4b fd 88 	st.w	r9[-632],r11
8000a026:	2f f8       	sub	r8,-1
8000a028:	14 97       	mov	r7,r10
8000a02a:	fb 48 06 b4 	st.w	sp[1716],r8
8000a02e:	c0 58       	rjmp	8000a038 <_vfprintf_r+0xf34>
8000a030:	72 0b       	ld.w	r11,r9[0x0]
8000a032:	14 97       	mov	r7,r10
8000a034:	2f c9       	sub	r9,-4
8000a036:	51 09       	stdsp	sp[0x40],r9
8000a038:	50 1b       	stdsp	sp[0x4],r11
8000a03a:	30 0e       	mov	lr,0
8000a03c:	50 0e       	stdsp	sp[0x0],lr
8000a03e:	1c 98       	mov	r8,lr
8000a040:	e0 8f 02 fe 	bral	8000a63c <_vfprintf_r+0x1538>
8000a044:	50 a7       	stdsp	sp[0x28],r7
8000a046:	50 80       	stdsp	sp[0x20],r0
8000a048:	0c 97       	mov	r7,r6
8000a04a:	04 94       	mov	r4,r2
8000a04c:	06 96       	mov	r6,r3
8000a04e:	02 92       	mov	r2,r1
8000a050:	40 93       	lddsp	r3,sp[0x24]
8000a052:	40 41       	lddsp	r1,sp[0x10]
8000a054:	0e 99       	mov	r9,r7
8000a056:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a05a:	40 3c       	lddsp	r12,sp[0xc]
8000a05c:	58 0c       	cp.w	r12,0
8000a05e:	c1 d0       	breq	8000a098 <_vfprintf_r+0xf94>
8000a060:	10 36       	cp.w	r6,r8
8000a062:	c0 64       	brge	8000a06e <_vfprintf_r+0xf6a>
8000a064:	fa cb f9 44 	sub	r11,sp,-1724
8000a068:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a06c:	c1 d8       	rjmp	8000a0a6 <_vfprintf_r+0xfa2>
8000a06e:	fa c8 f9 50 	sub	r8,sp,-1712
8000a072:	1a d8       	st.w	--sp,r8
8000a074:	fa c8 fa b8 	sub	r8,sp,-1352
8000a078:	1a d8       	st.w	--sp,r8
8000a07a:	fa c8 fb b4 	sub	r8,sp,-1100
8000a07e:	1a d8       	st.w	--sp,r8
8000a080:	fa c9 ff b4 	sub	r9,sp,-76
8000a084:	fa c8 f9 40 	sub	r8,sp,-1728
8000a088:	04 9a       	mov	r10,r2
8000a08a:	0c 9b       	mov	r11,r6
8000a08c:	08 9c       	mov	r12,r4
8000a08e:	fe b0 f6 a3 	rcall	80008dd4 <get_arg>
8000a092:	2f dd       	sub	sp,-12
8000a094:	78 09       	ld.w	r9,r12[0x0]
8000a096:	c2 18       	rjmp	8000a0d8 <_vfprintf_r+0xfd4>
8000a098:	2f f7       	sub	r7,-1
8000a09a:	10 39       	cp.w	r9,r8
8000a09c:	c0 84       	brge	8000a0ac <_vfprintf_r+0xfa8>
8000a09e:	fa ca f9 44 	sub	r10,sp,-1724
8000a0a2:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000a0a6:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000a0aa:	c1 78       	rjmp	8000a0d8 <_vfprintf_r+0xfd4>
8000a0ac:	41 09       	lddsp	r9,sp[0x40]
8000a0ae:	59 f8       	cp.w	r8,31
8000a0b0:	e0 89 00 10 	brgt	8000a0d0 <_vfprintf_r+0xfcc>
8000a0b4:	f2 ca ff fc 	sub	r10,r9,-4
8000a0b8:	51 0a       	stdsp	sp[0x40],r10
8000a0ba:	fa c6 f9 44 	sub	r6,sp,-1724
8000a0be:	72 09       	ld.w	r9,r9[0x0]
8000a0c0:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000a0c4:	f5 49 fd 88 	st.w	r10[-632],r9
8000a0c8:	2f f8       	sub	r8,-1
8000a0ca:	fb 48 06 b4 	st.w	sp[1716],r8
8000a0ce:	c0 58       	rjmp	8000a0d8 <_vfprintf_r+0xfd4>
8000a0d0:	f2 c8 ff fc 	sub	r8,r9,-4
8000a0d4:	51 08       	stdsp	sp[0x40],r8
8000a0d6:	72 09       	ld.w	r9,r9[0x0]
8000a0d8:	33 08       	mov	r8,48
8000a0da:	fb 68 06 b8 	st.b	sp[1720],r8
8000a0de:	37 88       	mov	r8,120
8000a0e0:	30 0e       	mov	lr,0
8000a0e2:	fb 68 06 b9 	st.b	sp[1721],r8
8000a0e6:	fe cc ad 8e 	sub	r12,pc,-21106
8000a0ea:	50 19       	stdsp	sp[0x4],r9
8000a0ec:	a1 b5       	sbr	r5,0x1
8000a0ee:	50 0e       	stdsp	sp[0x0],lr
8000a0f0:	50 dc       	stdsp	sp[0x34],r12
8000a0f2:	30 28       	mov	r8,2
8000a0f4:	37 80       	mov	r0,120
8000a0f6:	e0 8f 02 a3 	bral	8000a63c <_vfprintf_r+0x1538>
8000a0fa:	50 a7       	stdsp	sp[0x28],r7
8000a0fc:	50 80       	stdsp	sp[0x20],r0
8000a0fe:	10 90       	mov	r0,r8
8000a100:	30 08       	mov	r8,0
8000a102:	fb 68 06 bb 	st.b	sp[1723],r8
8000a106:	0c 97       	mov	r7,r6
8000a108:	04 94       	mov	r4,r2
8000a10a:	06 96       	mov	r6,r3
8000a10c:	02 92       	mov	r2,r1
8000a10e:	40 93       	lddsp	r3,sp[0x24]
8000a110:	40 41       	lddsp	r1,sp[0x10]
8000a112:	0e 99       	mov	r9,r7
8000a114:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a118:	40 3b       	lddsp	r11,sp[0xc]
8000a11a:	58 0b       	cp.w	r11,0
8000a11c:	c1 d0       	breq	8000a156 <_vfprintf_r+0x1052>
8000a11e:	10 36       	cp.w	r6,r8
8000a120:	c0 64       	brge	8000a12c <_vfprintf_r+0x1028>
8000a122:	fa ca f9 44 	sub	r10,sp,-1724
8000a126:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000a12a:	c1 d8       	rjmp	8000a164 <_vfprintf_r+0x1060>
8000a12c:	fa c8 f9 50 	sub	r8,sp,-1712
8000a130:	1a d8       	st.w	--sp,r8
8000a132:	fa c8 fa b8 	sub	r8,sp,-1352
8000a136:	1a d8       	st.w	--sp,r8
8000a138:	fa c8 fb b4 	sub	r8,sp,-1100
8000a13c:	0c 9b       	mov	r11,r6
8000a13e:	1a d8       	st.w	--sp,r8
8000a140:	04 9a       	mov	r10,r2
8000a142:	fa c8 f9 40 	sub	r8,sp,-1728
8000a146:	fa c9 ff b4 	sub	r9,sp,-76
8000a14a:	08 9c       	mov	r12,r4
8000a14c:	fe b0 f6 44 	rcall	80008dd4 <get_arg>
8000a150:	2f dd       	sub	sp,-12
8000a152:	78 06       	ld.w	r6,r12[0x0]
8000a154:	c2 08       	rjmp	8000a194 <_vfprintf_r+0x1090>
8000a156:	2f f7       	sub	r7,-1
8000a158:	10 39       	cp.w	r9,r8
8000a15a:	c0 84       	brge	8000a16a <_vfprintf_r+0x1066>
8000a15c:	fa c9 f9 44 	sub	r9,sp,-1724
8000a160:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a164:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000a168:	c1 68       	rjmp	8000a194 <_vfprintf_r+0x1090>
8000a16a:	41 09       	lddsp	r9,sp[0x40]
8000a16c:	59 f8       	cp.w	r8,31
8000a16e:	e0 89 00 10 	brgt	8000a18e <_vfprintf_r+0x108a>
8000a172:	f2 ca ff fc 	sub	r10,r9,-4
8000a176:	51 0a       	stdsp	sp[0x40],r10
8000a178:	72 06       	ld.w	r6,r9[0x0]
8000a17a:	fa ce f9 44 	sub	lr,sp,-1724
8000a17e:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000a182:	f3 46 fd 88 	st.w	r9[-632],r6
8000a186:	2f f8       	sub	r8,-1
8000a188:	fb 48 06 b4 	st.w	sp[1716],r8
8000a18c:	c0 48       	rjmp	8000a194 <_vfprintf_r+0x1090>
8000a18e:	72 06       	ld.w	r6,r9[0x0]
8000a190:	2f c9       	sub	r9,-4
8000a192:	51 09       	stdsp	sp[0x40],r9
8000a194:	40 2c       	lddsp	r12,sp[0x8]
8000a196:	58 0c       	cp.w	r12,0
8000a198:	c1 05       	brlt	8000a1b8 <_vfprintf_r+0x10b4>
8000a19a:	18 9a       	mov	r10,r12
8000a19c:	30 0b       	mov	r11,0
8000a19e:	0c 9c       	mov	r12,r6
8000a1a0:	e0 a0 12 38 	rcall	8000c610 <memchr>
8000a1a4:	e0 80 02 df 	breq	8000a762 <_vfprintf_r+0x165e>
8000a1a8:	f8 06 01 02 	sub	r2,r12,r6
8000a1ac:	40 2b       	lddsp	r11,sp[0x8]
8000a1ae:	16 32       	cp.w	r2,r11
8000a1b0:	e0 89 02 d9 	brgt	8000a762 <_vfprintf_r+0x165e>
8000a1b4:	e0 8f 02 d4 	bral	8000a75c <_vfprintf_r+0x1658>
8000a1b8:	30 0a       	mov	r10,0
8000a1ba:	0c 9c       	mov	r12,r6
8000a1bc:	50 2a       	stdsp	sp[0x8],r10
8000a1be:	e0 a0 15 99 	rcall	8000ccf0 <strlen>
8000a1c2:	18 92       	mov	r2,r12
8000a1c4:	e0 8f 02 d2 	bral	8000a768 <_vfprintf_r+0x1664>
8000a1c8:	50 a7       	stdsp	sp[0x28],r7
8000a1ca:	50 80       	stdsp	sp[0x20],r0
8000a1cc:	0c 97       	mov	r7,r6
8000a1ce:	04 94       	mov	r4,r2
8000a1d0:	06 96       	mov	r6,r3
8000a1d2:	02 92       	mov	r2,r1
8000a1d4:	40 93       	lddsp	r3,sp[0x24]
8000a1d6:	10 90       	mov	r0,r8
8000a1d8:	40 41       	lddsp	r1,sp[0x10]
8000a1da:	a5 a5       	sbr	r5,0x4
8000a1dc:	c0 a8       	rjmp	8000a1f0 <_vfprintf_r+0x10ec>
8000a1de:	50 a7       	stdsp	sp[0x28],r7
8000a1e0:	50 80       	stdsp	sp[0x20],r0
8000a1e2:	0c 97       	mov	r7,r6
8000a1e4:	04 94       	mov	r4,r2
8000a1e6:	06 96       	mov	r6,r3
8000a1e8:	02 92       	mov	r2,r1
8000a1ea:	40 93       	lddsp	r3,sp[0x24]
8000a1ec:	10 90       	mov	r0,r8
8000a1ee:	40 41       	lddsp	r1,sp[0x10]
8000a1f0:	ed b5 00 05 	bld	r5,0x5
8000a1f4:	c5 61       	brne	8000a2a0 <_vfprintf_r+0x119c>
8000a1f6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a1fa:	40 39       	lddsp	r9,sp[0xc]
8000a1fc:	58 09       	cp.w	r9,0
8000a1fe:	c2 10       	breq	8000a240 <_vfprintf_r+0x113c>
8000a200:	10 36       	cp.w	r6,r8
8000a202:	c0 74       	brge	8000a210 <_vfprintf_r+0x110c>
8000a204:	fa c8 f9 44 	sub	r8,sp,-1724
8000a208:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000a20c:	c2 38       	rjmp	8000a252 <_vfprintf_r+0x114e>
8000a20e:	d7 03       	nop
8000a210:	fa c8 f9 50 	sub	r8,sp,-1712
8000a214:	1a d8       	st.w	--sp,r8
8000a216:	fa c8 fa b8 	sub	r8,sp,-1352
8000a21a:	1a d8       	st.w	--sp,r8
8000a21c:	fa c8 fb b4 	sub	r8,sp,-1100
8000a220:	1a d8       	st.w	--sp,r8
8000a222:	fa c8 f9 40 	sub	r8,sp,-1728
8000a226:	fa c9 ff b4 	sub	r9,sp,-76
8000a22a:	04 9a       	mov	r10,r2
8000a22c:	0c 9b       	mov	r11,r6
8000a22e:	08 9c       	mov	r12,r4
8000a230:	fe b0 f5 d2 	rcall	80008dd4 <get_arg>
8000a234:	2f dd       	sub	sp,-12
8000a236:	f8 e8 00 00 	ld.d	r8,r12[0]
8000a23a:	fa e9 00 00 	st.d	sp[0],r8
8000a23e:	c2 e8       	rjmp	8000a29a <_vfprintf_r+0x1196>
8000a240:	ee ca ff ff 	sub	r10,r7,-1
8000a244:	10 37       	cp.w	r7,r8
8000a246:	c0 b4       	brge	8000a25c <_vfprintf_r+0x1158>
8000a248:	fa c8 f9 44 	sub	r8,sp,-1724
8000a24c:	14 97       	mov	r7,r10
8000a24e:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000a252:	ec ea fd 88 	ld.d	r10,r6[-632]
8000a256:	fa eb 00 00 	st.d	sp[0],r10
8000a25a:	c2 08       	rjmp	8000a29a <_vfprintf_r+0x1196>
8000a25c:	41 09       	lddsp	r9,sp[0x40]
8000a25e:	59 f8       	cp.w	r8,31
8000a260:	e0 89 00 16 	brgt	8000a28c <_vfprintf_r+0x1188>
8000a264:	f2 e6 00 00 	ld.d	r6,r9[0]
8000a268:	f2 cb ff f8 	sub	r11,r9,-8
8000a26c:	fa e7 00 00 	st.d	sp[0],r6
8000a270:	51 0b       	stdsp	sp[0x40],r11
8000a272:	fa c6 f9 44 	sub	r6,sp,-1724
8000a276:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a27a:	fa e6 00 00 	ld.d	r6,sp[0]
8000a27e:	f2 e7 fd 88 	st.d	r9[-632],r6
8000a282:	2f f8       	sub	r8,-1
8000a284:	14 97       	mov	r7,r10
8000a286:	fb 48 06 b4 	st.w	sp[1716],r8
8000a28a:	c0 88       	rjmp	8000a29a <_vfprintf_r+0x1196>
8000a28c:	f2 e6 00 00 	ld.d	r6,r9[0]
8000a290:	2f 89       	sub	r9,-8
8000a292:	fa e7 00 00 	st.d	sp[0],r6
8000a296:	51 09       	stdsp	sp[0x40],r9
8000a298:	14 97       	mov	r7,r10
8000a29a:	30 18       	mov	r8,1
8000a29c:	e0 8f 01 d0 	bral	8000a63c <_vfprintf_r+0x1538>
8000a2a0:	ed b5 00 04 	bld	r5,0x4
8000a2a4:	c1 61       	brne	8000a2d0 <_vfprintf_r+0x11cc>
8000a2a6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a2aa:	40 3e       	lddsp	lr,sp[0xc]
8000a2ac:	58 0e       	cp.w	lr,0
8000a2ae:	c0 80       	breq	8000a2be <_vfprintf_r+0x11ba>
8000a2b0:	10 36       	cp.w	r6,r8
8000a2b2:	c6 74       	brge	8000a380 <_vfprintf_r+0x127c>
8000a2b4:	fa cc f9 44 	sub	r12,sp,-1724
8000a2b8:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000a2bc:	c8 08       	rjmp	8000a3bc <_vfprintf_r+0x12b8>
8000a2be:	ee ca ff ff 	sub	r10,r7,-1
8000a2c2:	10 37       	cp.w	r7,r8
8000a2c4:	c7 f4       	brge	8000a3c2 <_vfprintf_r+0x12be>
8000a2c6:	fa cb f9 44 	sub	r11,sp,-1724
8000a2ca:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a2ce:	c7 68       	rjmp	8000a3ba <_vfprintf_r+0x12b6>
8000a2d0:	ed b5 00 06 	bld	r5,0x6
8000a2d4:	c4 a1       	brne	8000a368 <_vfprintf_r+0x1264>
8000a2d6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a2da:	40 3c       	lddsp	r12,sp[0xc]
8000a2dc:	58 0c       	cp.w	r12,0
8000a2de:	c1 d0       	breq	8000a318 <_vfprintf_r+0x1214>
8000a2e0:	10 36       	cp.w	r6,r8
8000a2e2:	c0 64       	brge	8000a2ee <_vfprintf_r+0x11ea>
8000a2e4:	fa cb f9 44 	sub	r11,sp,-1724
8000a2e8:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a2ec:	c1 f8       	rjmp	8000a32a <_vfprintf_r+0x1226>
8000a2ee:	fa c8 f9 50 	sub	r8,sp,-1712
8000a2f2:	1a d8       	st.w	--sp,r8
8000a2f4:	fa c8 fa b8 	sub	r8,sp,-1352
8000a2f8:	1a d8       	st.w	--sp,r8
8000a2fa:	fa c8 fb b4 	sub	r8,sp,-1100
8000a2fe:	1a d8       	st.w	--sp,r8
8000a300:	fa c8 f9 40 	sub	r8,sp,-1728
8000a304:	fa c9 ff b4 	sub	r9,sp,-76
8000a308:	04 9a       	mov	r10,r2
8000a30a:	0c 9b       	mov	r11,r6
8000a30c:	08 9c       	mov	r12,r4
8000a30e:	fe b0 f5 63 	rcall	80008dd4 <get_arg>
8000a312:	2f dd       	sub	sp,-12
8000a314:	98 18       	ld.sh	r8,r12[0x2]
8000a316:	c2 68       	rjmp	8000a362 <_vfprintf_r+0x125e>
8000a318:	ee ca ff ff 	sub	r10,r7,-1
8000a31c:	10 37       	cp.w	r7,r8
8000a31e:	c0 94       	brge	8000a330 <_vfprintf_r+0x122c>
8000a320:	fa c9 f9 44 	sub	r9,sp,-1724
8000a324:	14 97       	mov	r7,r10
8000a326:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a32a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000a32e:	c1 a8       	rjmp	8000a362 <_vfprintf_r+0x125e>
8000a330:	41 09       	lddsp	r9,sp[0x40]
8000a332:	59 f8       	cp.w	r8,31
8000a334:	e0 89 00 13 	brgt	8000a35a <_vfprintf_r+0x1256>
8000a338:	f2 cb ff fc 	sub	r11,r9,-4
8000a33c:	51 0b       	stdsp	sp[0x40],r11
8000a33e:	72 09       	ld.w	r9,r9[0x0]
8000a340:	fa c6 f9 44 	sub	r6,sp,-1724
8000a344:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000a348:	2f f8       	sub	r8,-1
8000a34a:	f7 49 fd 88 	st.w	r11[-632],r9
8000a34e:	fb 48 06 b4 	st.w	sp[1716],r8
8000a352:	14 97       	mov	r7,r10
8000a354:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000a358:	c0 58       	rjmp	8000a362 <_vfprintf_r+0x125e>
8000a35a:	92 18       	ld.sh	r8,r9[0x2]
8000a35c:	14 97       	mov	r7,r10
8000a35e:	2f c9       	sub	r9,-4
8000a360:	51 09       	stdsp	sp[0x40],r9
8000a362:	5c 78       	castu.h	r8
8000a364:	50 18       	stdsp	sp[0x4],r8
8000a366:	c4 68       	rjmp	8000a3f2 <_vfprintf_r+0x12ee>
8000a368:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a36c:	40 3c       	lddsp	r12,sp[0xc]
8000a36e:	58 0c       	cp.w	r12,0
8000a370:	c1 d0       	breq	8000a3aa <_vfprintf_r+0x12a6>
8000a372:	10 36       	cp.w	r6,r8
8000a374:	c0 64       	brge	8000a380 <_vfprintf_r+0x127c>
8000a376:	fa cb f9 44 	sub	r11,sp,-1724
8000a37a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a37e:	c1 f8       	rjmp	8000a3bc <_vfprintf_r+0x12b8>
8000a380:	fa c8 f9 50 	sub	r8,sp,-1712
8000a384:	1a d8       	st.w	--sp,r8
8000a386:	fa c8 fa b8 	sub	r8,sp,-1352
8000a38a:	0c 9b       	mov	r11,r6
8000a38c:	1a d8       	st.w	--sp,r8
8000a38e:	fa c8 fb b4 	sub	r8,sp,-1100
8000a392:	04 9a       	mov	r10,r2
8000a394:	1a d8       	st.w	--sp,r8
8000a396:	08 9c       	mov	r12,r4
8000a398:	fa c8 f9 40 	sub	r8,sp,-1728
8000a39c:	fa c9 ff b4 	sub	r9,sp,-76
8000a3a0:	fe b0 f5 1a 	rcall	80008dd4 <get_arg>
8000a3a4:	2f dd       	sub	sp,-12
8000a3a6:	78 0b       	ld.w	r11,r12[0x0]
8000a3a8:	c2 48       	rjmp	8000a3f0 <_vfprintf_r+0x12ec>
8000a3aa:	ee ca ff ff 	sub	r10,r7,-1
8000a3ae:	10 37       	cp.w	r7,r8
8000a3b0:	c0 94       	brge	8000a3c2 <_vfprintf_r+0x12be>
8000a3b2:	fa c9 f9 44 	sub	r9,sp,-1724
8000a3b6:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a3ba:	14 97       	mov	r7,r10
8000a3bc:	ec fb fd 88 	ld.w	r11,r6[-632]
8000a3c0:	c1 88       	rjmp	8000a3f0 <_vfprintf_r+0x12ec>
8000a3c2:	41 09       	lddsp	r9,sp[0x40]
8000a3c4:	59 f8       	cp.w	r8,31
8000a3c6:	e0 89 00 11 	brgt	8000a3e8 <_vfprintf_r+0x12e4>
8000a3ca:	f2 cb ff fc 	sub	r11,r9,-4
8000a3ce:	51 0b       	stdsp	sp[0x40],r11
8000a3d0:	fa c6 f9 44 	sub	r6,sp,-1724
8000a3d4:	72 0b       	ld.w	r11,r9[0x0]
8000a3d6:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a3da:	f3 4b fd 88 	st.w	r9[-632],r11
8000a3de:	2f f8       	sub	r8,-1
8000a3e0:	14 97       	mov	r7,r10
8000a3e2:	fb 48 06 b4 	st.w	sp[1716],r8
8000a3e6:	c0 58       	rjmp	8000a3f0 <_vfprintf_r+0x12ec>
8000a3e8:	72 0b       	ld.w	r11,r9[0x0]
8000a3ea:	14 97       	mov	r7,r10
8000a3ec:	2f c9       	sub	r9,-4
8000a3ee:	51 09       	stdsp	sp[0x40],r9
8000a3f0:	50 1b       	stdsp	sp[0x4],r11
8000a3f2:	30 0e       	mov	lr,0
8000a3f4:	30 18       	mov	r8,1
8000a3f6:	50 0e       	stdsp	sp[0x0],lr
8000a3f8:	c2 29       	rjmp	8000a63c <_vfprintf_r+0x1538>
8000a3fa:	50 a7       	stdsp	sp[0x28],r7
8000a3fc:	50 80       	stdsp	sp[0x20],r0
8000a3fe:	0c 97       	mov	r7,r6
8000a400:	04 94       	mov	r4,r2
8000a402:	06 96       	mov	r6,r3
8000a404:	02 92       	mov	r2,r1
8000a406:	fe cc b0 ae 	sub	r12,pc,-20306
8000a40a:	40 93       	lddsp	r3,sp[0x24]
8000a40c:	10 90       	mov	r0,r8
8000a40e:	40 41       	lddsp	r1,sp[0x10]
8000a410:	50 dc       	stdsp	sp[0x34],r12
8000a412:	ed b5 00 05 	bld	r5,0x5
8000a416:	c5 51       	brne	8000a4c0 <_vfprintf_r+0x13bc>
8000a418:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a41c:	40 3b       	lddsp	r11,sp[0xc]
8000a41e:	58 0b       	cp.w	r11,0
8000a420:	c2 20       	breq	8000a464 <_vfprintf_r+0x1360>
8000a422:	10 36       	cp.w	r6,r8
8000a424:	c0 a4       	brge	8000a438 <_vfprintf_r+0x1334>
8000a426:	fa ca f9 44 	sub	r10,sp,-1724
8000a42a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000a42e:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000a432:	fa e9 00 00 	st.d	sp[0],r8
8000a436:	cf 28       	rjmp	8000a61a <_vfprintf_r+0x1516>
8000a438:	fa c8 f9 50 	sub	r8,sp,-1712
8000a43c:	1a d8       	st.w	--sp,r8
8000a43e:	fa c8 fa b8 	sub	r8,sp,-1352
8000a442:	04 9a       	mov	r10,r2
8000a444:	1a d8       	st.w	--sp,r8
8000a446:	0c 9b       	mov	r11,r6
8000a448:	fa c8 fb b4 	sub	r8,sp,-1100
8000a44c:	08 9c       	mov	r12,r4
8000a44e:	1a d8       	st.w	--sp,r8
8000a450:	fa c8 f9 40 	sub	r8,sp,-1728
8000a454:	fa c9 ff b4 	sub	r9,sp,-76
8000a458:	fe b0 f4 be 	rcall	80008dd4 <get_arg>
8000a45c:	2f dd       	sub	sp,-12
8000a45e:	f8 ea 00 00 	ld.d	r10,r12[0]
8000a462:	c0 c8       	rjmp	8000a47a <_vfprintf_r+0x1376>
8000a464:	ee ca ff ff 	sub	r10,r7,-1
8000a468:	10 37       	cp.w	r7,r8
8000a46a:	c0 b4       	brge	8000a480 <_vfprintf_r+0x137c>
8000a46c:	fa c9 f9 44 	sub	r9,sp,-1724
8000a470:	14 97       	mov	r7,r10
8000a472:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a476:	ec ea fd 88 	ld.d	r10,r6[-632]
8000a47a:	fa eb 00 00 	st.d	sp[0],r10
8000a47e:	cc e8       	rjmp	8000a61a <_vfprintf_r+0x1516>
8000a480:	41 09       	lddsp	r9,sp[0x40]
8000a482:	59 f8       	cp.w	r8,31
8000a484:	e0 89 00 16 	brgt	8000a4b0 <_vfprintf_r+0x13ac>
8000a488:	f2 e6 00 00 	ld.d	r6,r9[0]
8000a48c:	f2 cb ff f8 	sub	r11,r9,-8
8000a490:	fa e7 00 00 	st.d	sp[0],r6
8000a494:	51 0b       	stdsp	sp[0x40],r11
8000a496:	fa c6 f9 44 	sub	r6,sp,-1724
8000a49a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a49e:	fa e6 00 00 	ld.d	r6,sp[0]
8000a4a2:	f2 e7 fd 88 	st.d	r9[-632],r6
8000a4a6:	2f f8       	sub	r8,-1
8000a4a8:	14 97       	mov	r7,r10
8000a4aa:	fb 48 06 b4 	st.w	sp[1716],r8
8000a4ae:	cb 68       	rjmp	8000a61a <_vfprintf_r+0x1516>
8000a4b0:	f2 e6 00 00 	ld.d	r6,r9[0]
8000a4b4:	2f 89       	sub	r9,-8
8000a4b6:	fa e7 00 00 	st.d	sp[0],r6
8000a4ba:	51 09       	stdsp	sp[0x40],r9
8000a4bc:	14 97       	mov	r7,r10
8000a4be:	ca e8       	rjmp	8000a61a <_vfprintf_r+0x1516>
8000a4c0:	ed b5 00 04 	bld	r5,0x4
8000a4c4:	c1 71       	brne	8000a4f2 <_vfprintf_r+0x13ee>
8000a4c6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a4ca:	40 3e       	lddsp	lr,sp[0xc]
8000a4cc:	58 0e       	cp.w	lr,0
8000a4ce:	c0 80       	breq	8000a4de <_vfprintf_r+0x13da>
8000a4d0:	10 36       	cp.w	r6,r8
8000a4d2:	c6 94       	brge	8000a5a4 <_vfprintf_r+0x14a0>
8000a4d4:	fa cc f9 44 	sub	r12,sp,-1724
8000a4d8:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000a4dc:	c8 28       	rjmp	8000a5e0 <_vfprintf_r+0x14dc>
8000a4de:	ee ca ff ff 	sub	r10,r7,-1
8000a4e2:	10 37       	cp.w	r7,r8
8000a4e4:	e0 84 00 81 	brge	8000a5e6 <_vfprintf_r+0x14e2>
8000a4e8:	fa cb f9 44 	sub	r11,sp,-1724
8000a4ec:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a4f0:	c7 78       	rjmp	8000a5de <_vfprintf_r+0x14da>
8000a4f2:	ed b5 00 06 	bld	r5,0x6
8000a4f6:	c4 b1       	brne	8000a58c <_vfprintf_r+0x1488>
8000a4f8:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a4fc:	40 3c       	lddsp	r12,sp[0xc]
8000a4fe:	58 0c       	cp.w	r12,0
8000a500:	c1 d0       	breq	8000a53a <_vfprintf_r+0x1436>
8000a502:	10 36       	cp.w	r6,r8
8000a504:	c0 64       	brge	8000a510 <_vfprintf_r+0x140c>
8000a506:	fa cb f9 44 	sub	r11,sp,-1724
8000a50a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a50e:	c1 f8       	rjmp	8000a54c <_vfprintf_r+0x1448>
8000a510:	fa c8 f9 50 	sub	r8,sp,-1712
8000a514:	1a d8       	st.w	--sp,r8
8000a516:	fa c8 fa b8 	sub	r8,sp,-1352
8000a51a:	1a d8       	st.w	--sp,r8
8000a51c:	fa c8 fb b4 	sub	r8,sp,-1100
8000a520:	1a d8       	st.w	--sp,r8
8000a522:	fa c8 f9 40 	sub	r8,sp,-1728
8000a526:	fa c9 ff b4 	sub	r9,sp,-76
8000a52a:	04 9a       	mov	r10,r2
8000a52c:	0c 9b       	mov	r11,r6
8000a52e:	08 9c       	mov	r12,r4
8000a530:	fe b0 f4 52 	rcall	80008dd4 <get_arg>
8000a534:	2f dd       	sub	sp,-12
8000a536:	98 18       	ld.sh	r8,r12[0x2]
8000a538:	c2 78       	rjmp	8000a586 <_vfprintf_r+0x1482>
8000a53a:	ee ca ff ff 	sub	r10,r7,-1
8000a53e:	10 37       	cp.w	r7,r8
8000a540:	c0 a4       	brge	8000a554 <_vfprintf_r+0x1450>
8000a542:	fa c9 f9 44 	sub	r9,sp,-1724
8000a546:	14 97       	mov	r7,r10
8000a548:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a54c:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000a550:	c1 b8       	rjmp	8000a586 <_vfprintf_r+0x1482>
8000a552:	d7 03       	nop
8000a554:	41 09       	lddsp	r9,sp[0x40]
8000a556:	59 f8       	cp.w	r8,31
8000a558:	e0 89 00 13 	brgt	8000a57e <_vfprintf_r+0x147a>
8000a55c:	f2 cb ff fc 	sub	r11,r9,-4
8000a560:	51 0b       	stdsp	sp[0x40],r11
8000a562:	72 09       	ld.w	r9,r9[0x0]
8000a564:	fa c6 f9 44 	sub	r6,sp,-1724
8000a568:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000a56c:	2f f8       	sub	r8,-1
8000a56e:	f7 49 fd 88 	st.w	r11[-632],r9
8000a572:	fb 48 06 b4 	st.w	sp[1716],r8
8000a576:	14 97       	mov	r7,r10
8000a578:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000a57c:	c0 58       	rjmp	8000a586 <_vfprintf_r+0x1482>
8000a57e:	92 18       	ld.sh	r8,r9[0x2]
8000a580:	14 97       	mov	r7,r10
8000a582:	2f c9       	sub	r9,-4
8000a584:	51 09       	stdsp	sp[0x40],r9
8000a586:	5c 78       	castu.h	r8
8000a588:	50 18       	stdsp	sp[0x4],r8
8000a58a:	c4 68       	rjmp	8000a616 <_vfprintf_r+0x1512>
8000a58c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a590:	40 3c       	lddsp	r12,sp[0xc]
8000a592:	58 0c       	cp.w	r12,0
8000a594:	c1 d0       	breq	8000a5ce <_vfprintf_r+0x14ca>
8000a596:	10 36       	cp.w	r6,r8
8000a598:	c0 64       	brge	8000a5a4 <_vfprintf_r+0x14a0>
8000a59a:	fa cb f9 44 	sub	r11,sp,-1724
8000a59e:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a5a2:	c1 f8       	rjmp	8000a5e0 <_vfprintf_r+0x14dc>
8000a5a4:	fa c8 f9 50 	sub	r8,sp,-1712
8000a5a8:	1a d8       	st.w	--sp,r8
8000a5aa:	fa c8 fa b8 	sub	r8,sp,-1352
8000a5ae:	0c 9b       	mov	r11,r6
8000a5b0:	1a d8       	st.w	--sp,r8
8000a5b2:	fa c8 fb b4 	sub	r8,sp,-1100
8000a5b6:	04 9a       	mov	r10,r2
8000a5b8:	1a d8       	st.w	--sp,r8
8000a5ba:	08 9c       	mov	r12,r4
8000a5bc:	fa c8 f9 40 	sub	r8,sp,-1728
8000a5c0:	fa c9 ff b4 	sub	r9,sp,-76
8000a5c4:	fe b0 f4 08 	rcall	80008dd4 <get_arg>
8000a5c8:	2f dd       	sub	sp,-12
8000a5ca:	78 0b       	ld.w	r11,r12[0x0]
8000a5cc:	c2 48       	rjmp	8000a614 <_vfprintf_r+0x1510>
8000a5ce:	ee ca ff ff 	sub	r10,r7,-1
8000a5d2:	10 37       	cp.w	r7,r8
8000a5d4:	c0 94       	brge	8000a5e6 <_vfprintf_r+0x14e2>
8000a5d6:	fa c9 f9 44 	sub	r9,sp,-1724
8000a5da:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a5de:	14 97       	mov	r7,r10
8000a5e0:	ec fb fd 88 	ld.w	r11,r6[-632]
8000a5e4:	c1 88       	rjmp	8000a614 <_vfprintf_r+0x1510>
8000a5e6:	41 09       	lddsp	r9,sp[0x40]
8000a5e8:	59 f8       	cp.w	r8,31
8000a5ea:	e0 89 00 11 	brgt	8000a60c <_vfprintf_r+0x1508>
8000a5ee:	f2 cb ff fc 	sub	r11,r9,-4
8000a5f2:	51 0b       	stdsp	sp[0x40],r11
8000a5f4:	fa c6 f9 44 	sub	r6,sp,-1724
8000a5f8:	72 0b       	ld.w	r11,r9[0x0]
8000a5fa:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a5fe:	f3 4b fd 88 	st.w	r9[-632],r11
8000a602:	2f f8       	sub	r8,-1
8000a604:	14 97       	mov	r7,r10
8000a606:	fb 48 06 b4 	st.w	sp[1716],r8
8000a60a:	c0 58       	rjmp	8000a614 <_vfprintf_r+0x1510>
8000a60c:	72 0b       	ld.w	r11,r9[0x0]
8000a60e:	14 97       	mov	r7,r10
8000a610:	2f c9       	sub	r9,-4
8000a612:	51 09       	stdsp	sp[0x40],r9
8000a614:	50 1b       	stdsp	sp[0x4],r11
8000a616:	30 0e       	mov	lr,0
8000a618:	50 0e       	stdsp	sp[0x0],lr
8000a61a:	40 08       	lddsp	r8,sp[0x0]
8000a61c:	40 1c       	lddsp	r12,sp[0x4]
8000a61e:	18 48       	or	r8,r12
8000a620:	5f 19       	srne	r9
8000a622:	0a 98       	mov	r8,r5
8000a624:	eb e9 00 09 	and	r9,r5,r9
8000a628:	a1 b8       	sbr	r8,0x1
8000a62a:	58 09       	cp.w	r9,0
8000a62c:	c0 70       	breq	8000a63a <_vfprintf_r+0x1536>
8000a62e:	10 95       	mov	r5,r8
8000a630:	fb 60 06 b9 	st.b	sp[1721],r0
8000a634:	33 08       	mov	r8,48
8000a636:	fb 68 06 b8 	st.b	sp[1720],r8
8000a63a:	30 28       	mov	r8,2
8000a63c:	30 09       	mov	r9,0
8000a63e:	fb 69 06 bb 	st.b	sp[1723],r9
8000a642:	0a 99       	mov	r9,r5
8000a644:	a7 d9       	cbr	r9,0x7
8000a646:	40 2b       	lddsp	r11,sp[0x8]
8000a648:	40 16       	lddsp	r6,sp[0x4]
8000a64a:	58 0b       	cp.w	r11,0
8000a64c:	5f 1a       	srne	r10
8000a64e:	f2 05 17 40 	movge	r5,r9
8000a652:	fa c2 f9 78 	sub	r2,sp,-1672
8000a656:	40 09       	lddsp	r9,sp[0x0]
8000a658:	0c 49       	or	r9,r6
8000a65a:	5f 19       	srne	r9
8000a65c:	f5 e9 10 09 	or	r9,r10,r9
8000a660:	c5 c0       	breq	8000a718 <_vfprintf_r+0x1614>
8000a662:	30 19       	mov	r9,1
8000a664:	f2 08 18 00 	cp.b	r8,r9
8000a668:	c0 60       	breq	8000a674 <_vfprintf_r+0x1570>
8000a66a:	30 29       	mov	r9,2
8000a66c:	f2 08 18 00 	cp.b	r8,r9
8000a670:	c0 41       	brne	8000a678 <_vfprintf_r+0x1574>
8000a672:	c3 c8       	rjmp	8000a6ea <_vfprintf_r+0x15e6>
8000a674:	04 96       	mov	r6,r2
8000a676:	c3 08       	rjmp	8000a6d6 <_vfprintf_r+0x15d2>
8000a678:	04 96       	mov	r6,r2
8000a67a:	fa e8 00 00 	ld.d	r8,sp[0]
8000a67e:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000a682:	2d 0a       	sub	r10,-48
8000a684:	0c fa       	st.b	--r6,r10
8000a686:	f0 0b 16 03 	lsr	r11,r8,0x3
8000a68a:	f2 0c 16 03 	lsr	r12,r9,0x3
8000a68e:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000a692:	18 99       	mov	r9,r12
8000a694:	16 98       	mov	r8,r11
8000a696:	58 08       	cp.w	r8,0
8000a698:	5c 29       	cpc	r9
8000a69a:	cf 21       	brne	8000a67e <_vfprintf_r+0x157a>
8000a69c:	fa e9 00 00 	st.d	sp[0],r8
8000a6a0:	ed b5 00 00 	bld	r5,0x0
8000a6a4:	c4 51       	brne	8000a72e <_vfprintf_r+0x162a>
8000a6a6:	33 09       	mov	r9,48
8000a6a8:	f2 0a 18 00 	cp.b	r10,r9
8000a6ac:	c4 10       	breq	8000a72e <_vfprintf_r+0x162a>
8000a6ae:	0c f9       	st.b	--r6,r9
8000a6b0:	c3 f8       	rjmp	8000a72e <_vfprintf_r+0x162a>
8000a6b2:	fa ea 00 00 	ld.d	r10,sp[0]
8000a6b6:	30 a8       	mov	r8,10
8000a6b8:	30 09       	mov	r9,0
8000a6ba:	e0 a0 1a 19 	rcall	8000daec <__avr32_umod64>
8000a6be:	30 a8       	mov	r8,10
8000a6c0:	2d 0a       	sub	r10,-48
8000a6c2:	30 09       	mov	r9,0
8000a6c4:	ac 8a       	st.b	r6[0x0],r10
8000a6c6:	fa ea 00 00 	ld.d	r10,sp[0]
8000a6ca:	e0 a0 18 df 	rcall	8000d888 <__avr32_udiv64>
8000a6ce:	16 99       	mov	r9,r11
8000a6d0:	14 98       	mov	r8,r10
8000a6d2:	fa e9 00 00 	st.d	sp[0],r8
8000a6d6:	20 16       	sub	r6,1
8000a6d8:	fa ea 00 00 	ld.d	r10,sp[0]
8000a6dc:	58 9a       	cp.w	r10,9
8000a6de:	5c 2b       	cpc	r11
8000a6e0:	fe 9b ff e9 	brhi	8000a6b2 <_vfprintf_r+0x15ae>
8000a6e4:	1b f8       	ld.ub	r8,sp[0x7]
8000a6e6:	2d 08       	sub	r8,-48
8000a6e8:	c2 08       	rjmp	8000a728 <_vfprintf_r+0x1624>
8000a6ea:	04 96       	mov	r6,r2
8000a6ec:	fa e8 00 00 	ld.d	r8,sp[0]
8000a6f0:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000a6f4:	40 de       	lddsp	lr,sp[0x34]
8000a6f6:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000a6fa:	0c fa       	st.b	--r6,r10
8000a6fc:	f2 0b 16 04 	lsr	r11,r9,0x4
8000a700:	f0 0a 16 04 	lsr	r10,r8,0x4
8000a704:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8000a708:	16 99       	mov	r9,r11
8000a70a:	14 98       	mov	r8,r10
8000a70c:	58 08       	cp.w	r8,0
8000a70e:	5c 29       	cpc	r9
8000a710:	cf 01       	brne	8000a6f0 <_vfprintf_r+0x15ec>
8000a712:	fa e9 00 00 	st.d	sp[0],r8
8000a716:	c0 c8       	rjmp	8000a72e <_vfprintf_r+0x162a>
8000a718:	58 08       	cp.w	r8,0
8000a71a:	c0 91       	brne	8000a72c <_vfprintf_r+0x1628>
8000a71c:	ed b5 00 00 	bld	r5,0x0
8000a720:	c0 61       	brne	8000a72c <_vfprintf_r+0x1628>
8000a722:	fa c6 f9 79 	sub	r6,sp,-1671
8000a726:	33 08       	mov	r8,48
8000a728:	ac 88       	st.b	r6[0x0],r8
8000a72a:	c0 28       	rjmp	8000a72e <_vfprintf_r+0x162a>
8000a72c:	04 96       	mov	r6,r2
8000a72e:	0c 12       	sub	r2,r6
8000a730:	c1 c8       	rjmp	8000a768 <_vfprintf_r+0x1664>
8000a732:	50 a7       	stdsp	sp[0x28],r7
8000a734:	50 80       	stdsp	sp[0x20],r0
8000a736:	40 93       	lddsp	r3,sp[0x24]
8000a738:	0c 97       	mov	r7,r6
8000a73a:	10 90       	mov	r0,r8
8000a73c:	04 94       	mov	r4,r2
8000a73e:	40 41       	lddsp	r1,sp[0x10]
8000a740:	58 08       	cp.w	r8,0
8000a742:	e0 80 04 4f 	breq	8000afe0 <_vfprintf_r+0x1edc>
8000a746:	fb 68 06 60 	st.b	sp[1632],r8
8000a74a:	30 0c       	mov	r12,0
8000a74c:	30 08       	mov	r8,0
8000a74e:	30 12       	mov	r2,1
8000a750:	fb 68 06 bb 	st.b	sp[1723],r8
8000a754:	50 2c       	stdsp	sp[0x8],r12
8000a756:	fa c6 f9 a0 	sub	r6,sp,-1632
8000a75a:	c0 78       	rjmp	8000a768 <_vfprintf_r+0x1664>
8000a75c:	30 0b       	mov	r11,0
8000a75e:	50 2b       	stdsp	sp[0x8],r11
8000a760:	c0 48       	rjmp	8000a768 <_vfprintf_r+0x1664>
8000a762:	40 22       	lddsp	r2,sp[0x8]
8000a764:	30 0a       	mov	r10,0
8000a766:	50 2a       	stdsp	sp[0x8],r10
8000a768:	40 29       	lddsp	r9,sp[0x8]
8000a76a:	e4 09 0c 49 	max	r9,r2,r9
8000a76e:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000a772:	50 39       	stdsp	sp[0xc],r9
8000a774:	0a 9e       	mov	lr,r5
8000a776:	30 09       	mov	r9,0
8000a778:	e2 1e 00 02 	andl	lr,0x2,COH
8000a77c:	f2 08 18 00 	cp.b	r8,r9
8000a780:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000a784:	f7 b8 01 ff 	subne	r8,-1
8000a788:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000a78c:	0a 9b       	mov	r11,r5
8000a78e:	58 0e       	cp.w	lr,0
8000a790:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000a794:	f7 bc 01 fe 	subne	r12,-2
8000a798:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000a79c:	e2 1b 00 84 	andl	r11,0x84,COH
8000a7a0:	50 fe       	stdsp	sp[0x3c],lr
8000a7a2:	50 9b       	stdsp	sp[0x24],r11
8000a7a4:	c4 71       	brne	8000a832 <_vfprintf_r+0x172e>
8000a7a6:	40 8a       	lddsp	r10,sp[0x20]
8000a7a8:	40 39       	lddsp	r9,sp[0xc]
8000a7aa:	12 1a       	sub	r10,r9
8000a7ac:	50 4a       	stdsp	sp[0x10],r10
8000a7ae:	58 0a       	cp.w	r10,0
8000a7b0:	e0 89 00 20 	brgt	8000a7f0 <_vfprintf_r+0x16ec>
8000a7b4:	c3 f8       	rjmp	8000a832 <_vfprintf_r+0x172e>
8000a7b6:	2f 09       	sub	r9,-16
8000a7b8:	2f f8       	sub	r8,-1
8000a7ba:	fe ce b4 4a 	sub	lr,pc,-19382
8000a7be:	31 0c       	mov	r12,16
8000a7c0:	fb 49 06 90 	st.w	sp[1680],r9
8000a7c4:	87 0e       	st.w	r3[0x0],lr
8000a7c6:	87 1c       	st.w	r3[0x4],r12
8000a7c8:	fb 48 06 8c 	st.w	sp[1676],r8
8000a7cc:	58 78       	cp.w	r8,7
8000a7ce:	e0 89 00 04 	brgt	8000a7d6 <_vfprintf_r+0x16d2>
8000a7d2:	2f 83       	sub	r3,-8
8000a7d4:	c0 b8       	rjmp	8000a7ea <_vfprintf_r+0x16e6>
8000a7d6:	fa ca f9 78 	sub	r10,sp,-1672
8000a7da:	02 9b       	mov	r11,r1
8000a7dc:	08 9c       	mov	r12,r4
8000a7de:	fe b0 f4 85 	rcall	800090e8 <__sprint_r>
8000a7e2:	e0 81 04 10 	brne	8000b002 <_vfprintf_r+0x1efe>
8000a7e6:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a7ea:	40 4b       	lddsp	r11,sp[0x10]
8000a7ec:	21 0b       	sub	r11,16
8000a7ee:	50 4b       	stdsp	sp[0x10],r11
8000a7f0:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a7f4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a7f8:	fe ca b4 88 	sub	r10,pc,-19320
8000a7fc:	40 4e       	lddsp	lr,sp[0x10]
8000a7fe:	59 0e       	cp.w	lr,16
8000a800:	fe 99 ff db 	brgt	8000a7b6 <_vfprintf_r+0x16b2>
8000a804:	1c 09       	add	r9,lr
8000a806:	2f f8       	sub	r8,-1
8000a808:	87 0a       	st.w	r3[0x0],r10
8000a80a:	fb 49 06 90 	st.w	sp[1680],r9
8000a80e:	87 1e       	st.w	r3[0x4],lr
8000a810:	fb 48 06 8c 	st.w	sp[1676],r8
8000a814:	58 78       	cp.w	r8,7
8000a816:	e0 89 00 04 	brgt	8000a81e <_vfprintf_r+0x171a>
8000a81a:	2f 83       	sub	r3,-8
8000a81c:	c0 b8       	rjmp	8000a832 <_vfprintf_r+0x172e>
8000a81e:	fa ca f9 78 	sub	r10,sp,-1672
8000a822:	02 9b       	mov	r11,r1
8000a824:	08 9c       	mov	r12,r4
8000a826:	fe b0 f4 61 	rcall	800090e8 <__sprint_r>
8000a82a:	e0 81 03 ec 	brne	8000b002 <_vfprintf_r+0x1efe>
8000a82e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a832:	30 09       	mov	r9,0
8000a834:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000a838:	f2 08 18 00 	cp.b	r8,r9
8000a83c:	c1 f0       	breq	8000a87a <_vfprintf_r+0x1776>
8000a83e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a842:	fa c9 f9 45 	sub	r9,sp,-1723
8000a846:	2f f8       	sub	r8,-1
8000a848:	87 09       	st.w	r3[0x0],r9
8000a84a:	fb 48 06 90 	st.w	sp[1680],r8
8000a84e:	30 19       	mov	r9,1
8000a850:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a854:	87 19       	st.w	r3[0x4],r9
8000a856:	2f f8       	sub	r8,-1
8000a858:	fb 48 06 8c 	st.w	sp[1676],r8
8000a85c:	58 78       	cp.w	r8,7
8000a85e:	e0 89 00 04 	brgt	8000a866 <_vfprintf_r+0x1762>
8000a862:	2f 83       	sub	r3,-8
8000a864:	c0 b8       	rjmp	8000a87a <_vfprintf_r+0x1776>
8000a866:	fa ca f9 78 	sub	r10,sp,-1672
8000a86a:	02 9b       	mov	r11,r1
8000a86c:	08 9c       	mov	r12,r4
8000a86e:	fe b0 f4 3d 	rcall	800090e8 <__sprint_r>
8000a872:	e0 81 03 c8 	brne	8000b002 <_vfprintf_r+0x1efe>
8000a876:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a87a:	40 fc       	lddsp	r12,sp[0x3c]
8000a87c:	58 0c       	cp.w	r12,0
8000a87e:	c1 f0       	breq	8000a8bc <_vfprintf_r+0x17b8>
8000a880:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a884:	fa c9 f9 48 	sub	r9,sp,-1720
8000a888:	2f e8       	sub	r8,-2
8000a88a:	87 09       	st.w	r3[0x0],r9
8000a88c:	fb 48 06 90 	st.w	sp[1680],r8
8000a890:	30 29       	mov	r9,2
8000a892:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a896:	87 19       	st.w	r3[0x4],r9
8000a898:	2f f8       	sub	r8,-1
8000a89a:	fb 48 06 8c 	st.w	sp[1676],r8
8000a89e:	58 78       	cp.w	r8,7
8000a8a0:	e0 89 00 04 	brgt	8000a8a8 <_vfprintf_r+0x17a4>
8000a8a4:	2f 83       	sub	r3,-8
8000a8a6:	c0 b8       	rjmp	8000a8bc <_vfprintf_r+0x17b8>
8000a8a8:	fa ca f9 78 	sub	r10,sp,-1672
8000a8ac:	02 9b       	mov	r11,r1
8000a8ae:	08 9c       	mov	r12,r4
8000a8b0:	fe b0 f4 1c 	rcall	800090e8 <__sprint_r>
8000a8b4:	e0 81 03 a7 	brne	8000b002 <_vfprintf_r+0x1efe>
8000a8b8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a8bc:	40 9b       	lddsp	r11,sp[0x24]
8000a8be:	e0 4b 00 80 	cp.w	r11,128
8000a8c2:	c4 71       	brne	8000a950 <_vfprintf_r+0x184c>
8000a8c4:	40 8a       	lddsp	r10,sp[0x20]
8000a8c6:	40 39       	lddsp	r9,sp[0xc]
8000a8c8:	12 1a       	sub	r10,r9
8000a8ca:	50 4a       	stdsp	sp[0x10],r10
8000a8cc:	58 0a       	cp.w	r10,0
8000a8ce:	e0 89 00 20 	brgt	8000a90e <_vfprintf_r+0x180a>
8000a8d2:	c3 f8       	rjmp	8000a950 <_vfprintf_r+0x184c>
8000a8d4:	2f 09       	sub	r9,-16
8000a8d6:	2f f8       	sub	r8,-1
8000a8d8:	fe ce b5 58 	sub	lr,pc,-19112
8000a8dc:	31 0c       	mov	r12,16
8000a8de:	fb 49 06 90 	st.w	sp[1680],r9
8000a8e2:	87 0e       	st.w	r3[0x0],lr
8000a8e4:	87 1c       	st.w	r3[0x4],r12
8000a8e6:	fb 48 06 8c 	st.w	sp[1676],r8
8000a8ea:	58 78       	cp.w	r8,7
8000a8ec:	e0 89 00 04 	brgt	8000a8f4 <_vfprintf_r+0x17f0>
8000a8f0:	2f 83       	sub	r3,-8
8000a8f2:	c0 b8       	rjmp	8000a908 <_vfprintf_r+0x1804>
8000a8f4:	fa ca f9 78 	sub	r10,sp,-1672
8000a8f8:	02 9b       	mov	r11,r1
8000a8fa:	08 9c       	mov	r12,r4
8000a8fc:	fe b0 f3 f6 	rcall	800090e8 <__sprint_r>
8000a900:	e0 81 03 81 	brne	8000b002 <_vfprintf_r+0x1efe>
8000a904:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a908:	40 4b       	lddsp	r11,sp[0x10]
8000a90a:	21 0b       	sub	r11,16
8000a90c:	50 4b       	stdsp	sp[0x10],r11
8000a90e:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a912:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a916:	fe ca b5 96 	sub	r10,pc,-19050
8000a91a:	40 4e       	lddsp	lr,sp[0x10]
8000a91c:	59 0e       	cp.w	lr,16
8000a91e:	fe 99 ff db 	brgt	8000a8d4 <_vfprintf_r+0x17d0>
8000a922:	1c 09       	add	r9,lr
8000a924:	2f f8       	sub	r8,-1
8000a926:	87 0a       	st.w	r3[0x0],r10
8000a928:	fb 49 06 90 	st.w	sp[1680],r9
8000a92c:	87 1e       	st.w	r3[0x4],lr
8000a92e:	fb 48 06 8c 	st.w	sp[1676],r8
8000a932:	58 78       	cp.w	r8,7
8000a934:	e0 89 00 04 	brgt	8000a93c <_vfprintf_r+0x1838>
8000a938:	2f 83       	sub	r3,-8
8000a93a:	c0 b8       	rjmp	8000a950 <_vfprintf_r+0x184c>
8000a93c:	fa ca f9 78 	sub	r10,sp,-1672
8000a940:	02 9b       	mov	r11,r1
8000a942:	08 9c       	mov	r12,r4
8000a944:	fe b0 f3 d2 	rcall	800090e8 <__sprint_r>
8000a948:	e0 81 03 5d 	brne	8000b002 <_vfprintf_r+0x1efe>
8000a94c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a950:	40 2c       	lddsp	r12,sp[0x8]
8000a952:	04 1c       	sub	r12,r2
8000a954:	50 2c       	stdsp	sp[0x8],r12
8000a956:	58 0c       	cp.w	r12,0
8000a958:	e0 89 00 20 	brgt	8000a998 <_vfprintf_r+0x1894>
8000a95c:	c3 f8       	rjmp	8000a9da <_vfprintf_r+0x18d6>
8000a95e:	2f 09       	sub	r9,-16
8000a960:	2f f8       	sub	r8,-1
8000a962:	fe cb b5 e2 	sub	r11,pc,-18974
8000a966:	31 0a       	mov	r10,16
8000a968:	fb 49 06 90 	st.w	sp[1680],r9
8000a96c:	87 0b       	st.w	r3[0x0],r11
8000a96e:	87 1a       	st.w	r3[0x4],r10
8000a970:	fb 48 06 8c 	st.w	sp[1676],r8
8000a974:	58 78       	cp.w	r8,7
8000a976:	e0 89 00 04 	brgt	8000a97e <_vfprintf_r+0x187a>
8000a97a:	2f 83       	sub	r3,-8
8000a97c:	c0 b8       	rjmp	8000a992 <_vfprintf_r+0x188e>
8000a97e:	fa ca f9 78 	sub	r10,sp,-1672
8000a982:	02 9b       	mov	r11,r1
8000a984:	08 9c       	mov	r12,r4
8000a986:	fe b0 f3 b1 	rcall	800090e8 <__sprint_r>
8000a98a:	e0 81 03 3c 	brne	8000b002 <_vfprintf_r+0x1efe>
8000a98e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a992:	40 29       	lddsp	r9,sp[0x8]
8000a994:	21 09       	sub	r9,16
8000a996:	50 29       	stdsp	sp[0x8],r9
8000a998:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a99c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a9a0:	fe ca b6 20 	sub	r10,pc,-18912
8000a9a4:	40 2e       	lddsp	lr,sp[0x8]
8000a9a6:	59 0e       	cp.w	lr,16
8000a9a8:	fe 99 ff db 	brgt	8000a95e <_vfprintf_r+0x185a>
8000a9ac:	1c 09       	add	r9,lr
8000a9ae:	2f f8       	sub	r8,-1
8000a9b0:	87 0a       	st.w	r3[0x0],r10
8000a9b2:	fb 49 06 90 	st.w	sp[1680],r9
8000a9b6:	87 1e       	st.w	r3[0x4],lr
8000a9b8:	fb 48 06 8c 	st.w	sp[1676],r8
8000a9bc:	58 78       	cp.w	r8,7
8000a9be:	e0 89 00 04 	brgt	8000a9c6 <_vfprintf_r+0x18c2>
8000a9c2:	2f 83       	sub	r3,-8
8000a9c4:	c0 b8       	rjmp	8000a9da <_vfprintf_r+0x18d6>
8000a9c6:	fa ca f9 78 	sub	r10,sp,-1672
8000a9ca:	02 9b       	mov	r11,r1
8000a9cc:	08 9c       	mov	r12,r4
8000a9ce:	fe b0 f3 8d 	rcall	800090e8 <__sprint_r>
8000a9d2:	e0 81 03 18 	brne	8000b002 <_vfprintf_r+0x1efe>
8000a9d6:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a9da:	ed b5 00 08 	bld	r5,0x8
8000a9de:	c0 b0       	breq	8000a9f4 <_vfprintf_r+0x18f0>
8000a9e0:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a9e4:	87 12       	st.w	r3[0x4],r2
8000a9e6:	87 06       	st.w	r3[0x0],r6
8000a9e8:	f0 02 00 02 	add	r2,r8,r2
8000a9ec:	fb 42 06 90 	st.w	sp[1680],r2
8000a9f0:	e0 8f 01 d4 	bral	8000ad98 <_vfprintf_r+0x1c94>
8000a9f4:	e0 40 00 65 	cp.w	r0,101
8000a9f8:	e0 8a 01 d6 	brle	8000ada4 <_vfprintf_r+0x1ca0>
8000a9fc:	30 08       	mov	r8,0
8000a9fe:	30 09       	mov	r9,0
8000aa00:	40 5b       	lddsp	r11,sp[0x14]
8000aa02:	40 7a       	lddsp	r10,sp[0x1c]
8000aa04:	e0 a0 15 3b 	rcall	8000d47a <__avr32_f64_cmp_eq>
8000aa08:	c7 90       	breq	8000aafa <_vfprintf_r+0x19f6>
8000aa0a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000aa0e:	fe c9 b6 a2 	sub	r9,pc,-18782
8000aa12:	2f f8       	sub	r8,-1
8000aa14:	87 09       	st.w	r3[0x0],r9
8000aa16:	fb 48 06 90 	st.w	sp[1680],r8
8000aa1a:	30 19       	mov	r9,1
8000aa1c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000aa20:	87 19       	st.w	r3[0x4],r9
8000aa22:	2f f8       	sub	r8,-1
8000aa24:	fb 48 06 8c 	st.w	sp[1676],r8
8000aa28:	58 78       	cp.w	r8,7
8000aa2a:	e0 89 00 05 	brgt	8000aa34 <_vfprintf_r+0x1930>
8000aa2e:	2f 83       	sub	r3,-8
8000aa30:	c0 c8       	rjmp	8000aa48 <_vfprintf_r+0x1944>
8000aa32:	d7 03       	nop
8000aa34:	fa ca f9 78 	sub	r10,sp,-1672
8000aa38:	02 9b       	mov	r11,r1
8000aa3a:	08 9c       	mov	r12,r4
8000aa3c:	fe b0 f3 56 	rcall	800090e8 <__sprint_r>
8000aa40:	e0 81 02 e1 	brne	8000b002 <_vfprintf_r+0x1efe>
8000aa44:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aa48:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000aa4c:	40 6c       	lddsp	r12,sp[0x18]
8000aa4e:	18 38       	cp.w	r8,r12
8000aa50:	c0 55       	brlt	8000aa5a <_vfprintf_r+0x1956>
8000aa52:	ed b5 00 00 	bld	r5,0x0
8000aa56:	e0 81 02 6b 	brne	8000af2c <_vfprintf_r+0x1e28>
8000aa5a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000aa5e:	2f f8       	sub	r8,-1
8000aa60:	40 cb       	lddsp	r11,sp[0x30]
8000aa62:	fb 48 06 90 	st.w	sp[1680],r8
8000aa66:	30 19       	mov	r9,1
8000aa68:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000aa6c:	87 0b       	st.w	r3[0x0],r11
8000aa6e:	2f f8       	sub	r8,-1
8000aa70:	87 19       	st.w	r3[0x4],r9
8000aa72:	fb 48 06 8c 	st.w	sp[1676],r8
8000aa76:	58 78       	cp.w	r8,7
8000aa78:	e0 89 00 04 	brgt	8000aa80 <_vfprintf_r+0x197c>
8000aa7c:	2f 83       	sub	r3,-8
8000aa7e:	c0 b8       	rjmp	8000aa94 <_vfprintf_r+0x1990>
8000aa80:	fa ca f9 78 	sub	r10,sp,-1672
8000aa84:	02 9b       	mov	r11,r1
8000aa86:	08 9c       	mov	r12,r4
8000aa88:	fe b0 f3 30 	rcall	800090e8 <__sprint_r>
8000aa8c:	e0 81 02 bb 	brne	8000b002 <_vfprintf_r+0x1efe>
8000aa90:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aa94:	40 66       	lddsp	r6,sp[0x18]
8000aa96:	20 16       	sub	r6,1
8000aa98:	58 06       	cp.w	r6,0
8000aa9a:	e0 89 00 1d 	brgt	8000aad4 <_vfprintf_r+0x19d0>
8000aa9e:	e0 8f 02 47 	bral	8000af2c <_vfprintf_r+0x1e28>
8000aaa2:	2f 09       	sub	r9,-16
8000aaa4:	2f f8       	sub	r8,-1
8000aaa6:	fb 49 06 90 	st.w	sp[1680],r9
8000aaaa:	87 02       	st.w	r3[0x0],r2
8000aaac:	87 10       	st.w	r3[0x4],r0
8000aaae:	fb 48 06 8c 	st.w	sp[1676],r8
8000aab2:	58 78       	cp.w	r8,7
8000aab4:	e0 89 00 04 	brgt	8000aabc <_vfprintf_r+0x19b8>
8000aab8:	2f 83       	sub	r3,-8
8000aaba:	c0 b8       	rjmp	8000aad0 <_vfprintf_r+0x19cc>
8000aabc:	fa ca f9 78 	sub	r10,sp,-1672
8000aac0:	02 9b       	mov	r11,r1
8000aac2:	08 9c       	mov	r12,r4
8000aac4:	fe b0 f3 12 	rcall	800090e8 <__sprint_r>
8000aac8:	e0 81 02 9d 	brne	8000b002 <_vfprintf_r+0x1efe>
8000aacc:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aad0:	21 06       	sub	r6,16
8000aad2:	c0 48       	rjmp	8000aada <_vfprintf_r+0x19d6>
8000aad4:	fe c2 b7 54 	sub	r2,pc,-18604
8000aad8:	31 00       	mov	r0,16
8000aada:	fa f9 06 90 	ld.w	r9,sp[1680]
8000aade:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000aae2:	fe ca b7 62 	sub	r10,pc,-18590
8000aae6:	59 06       	cp.w	r6,16
8000aae8:	fe 99 ff dd 	brgt	8000aaa2 <_vfprintf_r+0x199e>
8000aaec:	0c 09       	add	r9,r6
8000aaee:	87 0a       	st.w	r3[0x0],r10
8000aaf0:	fb 49 06 90 	st.w	sp[1680],r9
8000aaf4:	2f f8       	sub	r8,-1
8000aaf6:	87 16       	st.w	r3[0x4],r6
8000aaf8:	c5 39       	rjmp	8000ad9e <_vfprintf_r+0x1c9a>
8000aafa:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000aafe:	58 0a       	cp.w	r10,0
8000ab00:	e0 89 00 92 	brgt	8000ac24 <_vfprintf_r+0x1b20>
8000ab04:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ab08:	fe c9 b7 9c 	sub	r9,pc,-18532
8000ab0c:	2f f8       	sub	r8,-1
8000ab0e:	87 09       	st.w	r3[0x0],r9
8000ab10:	fb 48 06 90 	st.w	sp[1680],r8
8000ab14:	30 19       	mov	r9,1
8000ab16:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ab1a:	87 19       	st.w	r3[0x4],r9
8000ab1c:	2f f8       	sub	r8,-1
8000ab1e:	fb 48 06 8c 	st.w	sp[1676],r8
8000ab22:	58 78       	cp.w	r8,7
8000ab24:	e0 89 00 04 	brgt	8000ab2c <_vfprintf_r+0x1a28>
8000ab28:	2f 83       	sub	r3,-8
8000ab2a:	c0 b8       	rjmp	8000ab40 <_vfprintf_r+0x1a3c>
8000ab2c:	fa ca f9 78 	sub	r10,sp,-1672
8000ab30:	02 9b       	mov	r11,r1
8000ab32:	08 9c       	mov	r12,r4
8000ab34:	fe b0 f2 da 	rcall	800090e8 <__sprint_r>
8000ab38:	e0 81 02 65 	brne	8000b002 <_vfprintf_r+0x1efe>
8000ab3c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ab40:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000ab44:	58 08       	cp.w	r8,0
8000ab46:	c0 81       	brne	8000ab56 <_vfprintf_r+0x1a52>
8000ab48:	40 6a       	lddsp	r10,sp[0x18]
8000ab4a:	58 0a       	cp.w	r10,0
8000ab4c:	c0 51       	brne	8000ab56 <_vfprintf_r+0x1a52>
8000ab4e:	ed b5 00 00 	bld	r5,0x0
8000ab52:	e0 81 01 ed 	brne	8000af2c <_vfprintf_r+0x1e28>
8000ab56:	40 c9       	lddsp	r9,sp[0x30]
8000ab58:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ab5c:	2f f8       	sub	r8,-1
8000ab5e:	87 09       	st.w	r3[0x0],r9
8000ab60:	fb 48 06 90 	st.w	sp[1680],r8
8000ab64:	30 19       	mov	r9,1
8000ab66:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ab6a:	87 19       	st.w	r3[0x4],r9
8000ab6c:	2f f8       	sub	r8,-1
8000ab6e:	fb 48 06 8c 	st.w	sp[1676],r8
8000ab72:	58 78       	cp.w	r8,7
8000ab74:	e0 89 00 04 	brgt	8000ab7c <_vfprintf_r+0x1a78>
8000ab78:	2f 83       	sub	r3,-8
8000ab7a:	c0 b8       	rjmp	8000ab90 <_vfprintf_r+0x1a8c>
8000ab7c:	fa ca f9 78 	sub	r10,sp,-1672
8000ab80:	02 9b       	mov	r11,r1
8000ab82:	08 9c       	mov	r12,r4
8000ab84:	fe b0 f2 b2 	rcall	800090e8 <__sprint_r>
8000ab88:	e0 81 02 3d 	brne	8000b002 <_vfprintf_r+0x1efe>
8000ab8c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ab90:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000ab94:	5c 32       	neg	r2
8000ab96:	58 02       	cp.w	r2,0
8000ab98:	e0 89 00 1d 	brgt	8000abd2 <_vfprintf_r+0x1ace>
8000ab9c:	c3 d8       	rjmp	8000ac16 <_vfprintf_r+0x1b12>
8000ab9e:	2f 09       	sub	r9,-16
8000aba0:	2f f8       	sub	r8,-1
8000aba2:	31 0e       	mov	lr,16
8000aba4:	fb 49 06 90 	st.w	sp[1680],r9
8000aba8:	87 00       	st.w	r3[0x0],r0
8000abaa:	87 1e       	st.w	r3[0x4],lr
8000abac:	fb 48 06 8c 	st.w	sp[1676],r8
8000abb0:	58 78       	cp.w	r8,7
8000abb2:	e0 89 00 04 	brgt	8000abba <_vfprintf_r+0x1ab6>
8000abb6:	2f 83       	sub	r3,-8
8000abb8:	c0 b8       	rjmp	8000abce <_vfprintf_r+0x1aca>
8000abba:	fa ca f9 78 	sub	r10,sp,-1672
8000abbe:	02 9b       	mov	r11,r1
8000abc0:	08 9c       	mov	r12,r4
8000abc2:	fe b0 f2 93 	rcall	800090e8 <__sprint_r>
8000abc6:	e0 81 02 1e 	brne	8000b002 <_vfprintf_r+0x1efe>
8000abca:	fa c3 f9 e0 	sub	r3,sp,-1568
8000abce:	21 02       	sub	r2,16
8000abd0:	c0 38       	rjmp	8000abd6 <_vfprintf_r+0x1ad2>
8000abd2:	fe c0 b8 52 	sub	r0,pc,-18350
8000abd6:	fa f9 06 90 	ld.w	r9,sp[1680]
8000abda:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000abde:	fe ca b8 5e 	sub	r10,pc,-18338
8000abe2:	59 02       	cp.w	r2,16
8000abe4:	fe 99 ff dd 	brgt	8000ab9e <_vfprintf_r+0x1a9a>
8000abe8:	04 09       	add	r9,r2
8000abea:	2f f8       	sub	r8,-1
8000abec:	87 0a       	st.w	r3[0x0],r10
8000abee:	fb 49 06 90 	st.w	sp[1680],r9
8000abf2:	87 12       	st.w	r3[0x4],r2
8000abf4:	fb 48 06 8c 	st.w	sp[1676],r8
8000abf8:	58 78       	cp.w	r8,7
8000abfa:	e0 89 00 04 	brgt	8000ac02 <_vfprintf_r+0x1afe>
8000abfe:	2f 83       	sub	r3,-8
8000ac00:	c0 b8       	rjmp	8000ac16 <_vfprintf_r+0x1b12>
8000ac02:	fa ca f9 78 	sub	r10,sp,-1672
8000ac06:	02 9b       	mov	r11,r1
8000ac08:	08 9c       	mov	r12,r4
8000ac0a:	fe b0 f2 6f 	rcall	800090e8 <__sprint_r>
8000ac0e:	e0 81 01 fa 	brne	8000b002 <_vfprintf_r+0x1efe>
8000ac12:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ac16:	40 6c       	lddsp	r12,sp[0x18]
8000ac18:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ac1c:	87 06       	st.w	r3[0x0],r6
8000ac1e:	87 1c       	st.w	r3[0x4],r12
8000ac20:	18 08       	add	r8,r12
8000ac22:	cb 98       	rjmp	8000ad94 <_vfprintf_r+0x1c90>
8000ac24:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ac28:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ac2c:	40 6b       	lddsp	r11,sp[0x18]
8000ac2e:	16 3a       	cp.w	r10,r11
8000ac30:	c6 f5       	brlt	8000ad0e <_vfprintf_r+0x1c0a>
8000ac32:	16 09       	add	r9,r11
8000ac34:	2f f8       	sub	r8,-1
8000ac36:	87 06       	st.w	r3[0x0],r6
8000ac38:	fb 49 06 90 	st.w	sp[1680],r9
8000ac3c:	87 1b       	st.w	r3[0x4],r11
8000ac3e:	fb 48 06 8c 	st.w	sp[1676],r8
8000ac42:	58 78       	cp.w	r8,7
8000ac44:	e0 89 00 04 	brgt	8000ac4c <_vfprintf_r+0x1b48>
8000ac48:	2f 83       	sub	r3,-8
8000ac4a:	c0 b8       	rjmp	8000ac60 <_vfprintf_r+0x1b5c>
8000ac4c:	fa ca f9 78 	sub	r10,sp,-1672
8000ac50:	02 9b       	mov	r11,r1
8000ac52:	08 9c       	mov	r12,r4
8000ac54:	fe b0 f2 4a 	rcall	800090e8 <__sprint_r>
8000ac58:	e0 81 01 d5 	brne	8000b002 <_vfprintf_r+0x1efe>
8000ac5c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ac60:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000ac64:	40 6a       	lddsp	r10,sp[0x18]
8000ac66:	14 16       	sub	r6,r10
8000ac68:	58 06       	cp.w	r6,0
8000ac6a:	e0 89 00 1c 	brgt	8000aca2 <_vfprintf_r+0x1b9e>
8000ac6e:	c3 d8       	rjmp	8000ace8 <_vfprintf_r+0x1be4>
8000ac70:	2f 09       	sub	r9,-16
8000ac72:	2f f8       	sub	r8,-1
8000ac74:	fb 49 06 90 	st.w	sp[1680],r9
8000ac78:	87 02       	st.w	r3[0x0],r2
8000ac7a:	87 10       	st.w	r3[0x4],r0
8000ac7c:	fb 48 06 8c 	st.w	sp[1676],r8
8000ac80:	58 78       	cp.w	r8,7
8000ac82:	e0 89 00 04 	brgt	8000ac8a <_vfprintf_r+0x1b86>
8000ac86:	2f 83       	sub	r3,-8
8000ac88:	c0 b8       	rjmp	8000ac9e <_vfprintf_r+0x1b9a>
8000ac8a:	fa ca f9 78 	sub	r10,sp,-1672
8000ac8e:	02 9b       	mov	r11,r1
8000ac90:	08 9c       	mov	r12,r4
8000ac92:	fe b0 f2 2b 	rcall	800090e8 <__sprint_r>
8000ac96:	e0 81 01 b6 	brne	8000b002 <_vfprintf_r+0x1efe>
8000ac9a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ac9e:	21 06       	sub	r6,16
8000aca0:	c0 48       	rjmp	8000aca8 <_vfprintf_r+0x1ba4>
8000aca2:	fe c2 b9 22 	sub	r2,pc,-18142
8000aca6:	31 00       	mov	r0,16
8000aca8:	fa f9 06 90 	ld.w	r9,sp[1680]
8000acac:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000acb0:	fe ca b9 30 	sub	r10,pc,-18128
8000acb4:	59 06       	cp.w	r6,16
8000acb6:	fe 99 ff dd 	brgt	8000ac70 <_vfprintf_r+0x1b6c>
8000acba:	0c 09       	add	r9,r6
8000acbc:	2f f8       	sub	r8,-1
8000acbe:	87 0a       	st.w	r3[0x0],r10
8000acc0:	fb 49 06 90 	st.w	sp[1680],r9
8000acc4:	87 16       	st.w	r3[0x4],r6
8000acc6:	fb 48 06 8c 	st.w	sp[1676],r8
8000acca:	58 78       	cp.w	r8,7
8000accc:	e0 89 00 04 	brgt	8000acd4 <_vfprintf_r+0x1bd0>
8000acd0:	2f 83       	sub	r3,-8
8000acd2:	c0 b8       	rjmp	8000ace8 <_vfprintf_r+0x1be4>
8000acd4:	fa ca f9 78 	sub	r10,sp,-1672
8000acd8:	02 9b       	mov	r11,r1
8000acda:	08 9c       	mov	r12,r4
8000acdc:	fe b0 f2 06 	rcall	800090e8 <__sprint_r>
8000ace0:	e0 81 01 91 	brne	8000b002 <_vfprintf_r+0x1efe>
8000ace4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ace8:	ed b5 00 00 	bld	r5,0x0
8000acec:	e0 81 01 20 	brne	8000af2c <_vfprintf_r+0x1e28>
8000acf0:	40 c9       	lddsp	r9,sp[0x30]
8000acf2:	fa f8 06 90 	ld.w	r8,sp[1680]
8000acf6:	2f f8       	sub	r8,-1
8000acf8:	87 09       	st.w	r3[0x0],r9
8000acfa:	fb 48 06 90 	st.w	sp[1680],r8
8000acfe:	30 19       	mov	r9,1
8000ad00:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ad04:	87 19       	st.w	r3[0x4],r9
8000ad06:	2f f8       	sub	r8,-1
8000ad08:	fb 48 06 8c 	st.w	sp[1676],r8
8000ad0c:	c0 29       	rjmp	8000af10 <_vfprintf_r+0x1e0c>
8000ad0e:	14 09       	add	r9,r10
8000ad10:	2f f8       	sub	r8,-1
8000ad12:	fb 49 06 90 	st.w	sp[1680],r9
8000ad16:	87 06       	st.w	r3[0x0],r6
8000ad18:	87 1a       	st.w	r3[0x4],r10
8000ad1a:	fb 48 06 8c 	st.w	sp[1676],r8
8000ad1e:	58 78       	cp.w	r8,7
8000ad20:	e0 89 00 04 	brgt	8000ad28 <_vfprintf_r+0x1c24>
8000ad24:	2f 83       	sub	r3,-8
8000ad26:	c0 b8       	rjmp	8000ad3c <_vfprintf_r+0x1c38>
8000ad28:	fa ca f9 78 	sub	r10,sp,-1672
8000ad2c:	02 9b       	mov	r11,r1
8000ad2e:	08 9c       	mov	r12,r4
8000ad30:	fe b0 f1 dc 	rcall	800090e8 <__sprint_r>
8000ad34:	e0 81 01 67 	brne	8000b002 <_vfprintf_r+0x1efe>
8000ad38:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ad3c:	40 c8       	lddsp	r8,sp[0x30]
8000ad3e:	87 08       	st.w	r3[0x0],r8
8000ad40:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ad44:	2f f8       	sub	r8,-1
8000ad46:	30 19       	mov	r9,1
8000ad48:	fb 48 06 90 	st.w	sp[1680],r8
8000ad4c:	87 19       	st.w	r3[0x4],r9
8000ad4e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ad52:	2f f8       	sub	r8,-1
8000ad54:	fb 48 06 8c 	st.w	sp[1676],r8
8000ad58:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000ad5c:	58 78       	cp.w	r8,7
8000ad5e:	e0 89 00 04 	brgt	8000ad66 <_vfprintf_r+0x1c62>
8000ad62:	2f 83       	sub	r3,-8
8000ad64:	c0 b8       	rjmp	8000ad7a <_vfprintf_r+0x1c76>
8000ad66:	fa ca f9 78 	sub	r10,sp,-1672
8000ad6a:	02 9b       	mov	r11,r1
8000ad6c:	08 9c       	mov	r12,r4
8000ad6e:	fe b0 f1 bd 	rcall	800090e8 <__sprint_r>
8000ad72:	e0 81 01 48 	brne	8000b002 <_vfprintf_r+0x1efe>
8000ad76:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ad7a:	04 06       	add	r6,r2
8000ad7c:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000ad80:	87 06       	st.w	r3[0x0],r6
8000ad82:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ad86:	40 66       	lddsp	r6,sp[0x18]
8000ad88:	40 6e       	lddsp	lr,sp[0x18]
8000ad8a:	10 16       	sub	r6,r8
8000ad8c:	f2 08 01 08 	sub	r8,r9,r8
8000ad90:	87 16       	st.w	r3[0x4],r6
8000ad92:	1c 08       	add	r8,lr
8000ad94:	fb 48 06 90 	st.w	sp[1680],r8
8000ad98:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ad9c:	2f f8       	sub	r8,-1
8000ad9e:	fb 48 06 8c 	st.w	sp[1676],r8
8000ada2:	cb 78       	rjmp	8000af10 <_vfprintf_r+0x1e0c>
8000ada4:	40 6c       	lddsp	r12,sp[0x18]
8000ada6:	58 1c       	cp.w	r12,1
8000ada8:	e0 89 00 06 	brgt	8000adb4 <_vfprintf_r+0x1cb0>
8000adac:	ed b5 00 00 	bld	r5,0x0
8000adb0:	e0 81 00 85 	brne	8000aeba <_vfprintf_r+0x1db6>
8000adb4:	fa f8 06 90 	ld.w	r8,sp[1680]
8000adb8:	2f f8       	sub	r8,-1
8000adba:	30 19       	mov	r9,1
8000adbc:	fb 48 06 90 	st.w	sp[1680],r8
8000adc0:	87 06       	st.w	r3[0x0],r6
8000adc2:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000adc6:	87 19       	st.w	r3[0x4],r9
8000adc8:	2f f8       	sub	r8,-1
8000adca:	fb 48 06 8c 	st.w	sp[1676],r8
8000adce:	58 78       	cp.w	r8,7
8000add0:	e0 89 00 04 	brgt	8000add8 <_vfprintf_r+0x1cd4>
8000add4:	2f 83       	sub	r3,-8
8000add6:	c0 b8       	rjmp	8000adec <_vfprintf_r+0x1ce8>
8000add8:	fa ca f9 78 	sub	r10,sp,-1672
8000addc:	02 9b       	mov	r11,r1
8000adde:	08 9c       	mov	r12,r4
8000ade0:	fe b0 f1 84 	rcall	800090e8 <__sprint_r>
8000ade4:	e0 81 01 0f 	brne	8000b002 <_vfprintf_r+0x1efe>
8000ade8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000adec:	fa f8 06 90 	ld.w	r8,sp[1680]
8000adf0:	2f f8       	sub	r8,-1
8000adf2:	40 cb       	lddsp	r11,sp[0x30]
8000adf4:	fb 48 06 90 	st.w	sp[1680],r8
8000adf8:	30 19       	mov	r9,1
8000adfa:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000adfe:	87 0b       	st.w	r3[0x0],r11
8000ae00:	2f f8       	sub	r8,-1
8000ae02:	87 19       	st.w	r3[0x4],r9
8000ae04:	fb 48 06 8c 	st.w	sp[1676],r8
8000ae08:	58 78       	cp.w	r8,7
8000ae0a:	e0 89 00 05 	brgt	8000ae14 <_vfprintf_r+0x1d10>
8000ae0e:	2f 83       	sub	r3,-8
8000ae10:	c0 c8       	rjmp	8000ae28 <_vfprintf_r+0x1d24>
8000ae12:	d7 03       	nop
8000ae14:	fa ca f9 78 	sub	r10,sp,-1672
8000ae18:	02 9b       	mov	r11,r1
8000ae1a:	08 9c       	mov	r12,r4
8000ae1c:	fe b0 f1 66 	rcall	800090e8 <__sprint_r>
8000ae20:	e0 81 00 f1 	brne	8000b002 <_vfprintf_r+0x1efe>
8000ae24:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ae28:	30 08       	mov	r8,0
8000ae2a:	30 09       	mov	r9,0
8000ae2c:	40 5b       	lddsp	r11,sp[0x14]
8000ae2e:	40 7a       	lddsp	r10,sp[0x1c]
8000ae30:	e0 a0 13 25 	rcall	8000d47a <__avr32_f64_cmp_eq>
8000ae34:	40 68       	lddsp	r8,sp[0x18]
8000ae36:	20 18       	sub	r8,1
8000ae38:	58 0c       	cp.w	r12,0
8000ae3a:	c0 d1       	brne	8000ae54 <_vfprintf_r+0x1d50>
8000ae3c:	2f f6       	sub	r6,-1
8000ae3e:	87 18       	st.w	r3[0x4],r8
8000ae40:	87 06       	st.w	r3[0x0],r6
8000ae42:	fa f6 06 90 	ld.w	r6,sp[1680]
8000ae46:	10 06       	add	r6,r8
8000ae48:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ae4c:	fb 46 06 90 	st.w	sp[1680],r6
8000ae50:	2f f8       	sub	r8,-1
8000ae52:	c3 18       	rjmp	8000aeb4 <_vfprintf_r+0x1db0>
8000ae54:	10 96       	mov	r6,r8
8000ae56:	58 08       	cp.w	r8,0
8000ae58:	e0 89 00 1c 	brgt	8000ae90 <_vfprintf_r+0x1d8c>
8000ae5c:	c4 b8       	rjmp	8000aef2 <_vfprintf_r+0x1dee>
8000ae5e:	2f 09       	sub	r9,-16
8000ae60:	2f f8       	sub	r8,-1
8000ae62:	fb 49 06 90 	st.w	sp[1680],r9
8000ae66:	87 02       	st.w	r3[0x0],r2
8000ae68:	87 10       	st.w	r3[0x4],r0
8000ae6a:	fb 48 06 8c 	st.w	sp[1676],r8
8000ae6e:	58 78       	cp.w	r8,7
8000ae70:	e0 89 00 04 	brgt	8000ae78 <_vfprintf_r+0x1d74>
8000ae74:	2f 83       	sub	r3,-8
8000ae76:	c0 b8       	rjmp	8000ae8c <_vfprintf_r+0x1d88>
8000ae78:	fa ca f9 78 	sub	r10,sp,-1672
8000ae7c:	02 9b       	mov	r11,r1
8000ae7e:	08 9c       	mov	r12,r4
8000ae80:	fe b0 f1 34 	rcall	800090e8 <__sprint_r>
8000ae84:	e0 81 00 bf 	brne	8000b002 <_vfprintf_r+0x1efe>
8000ae88:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ae8c:	21 06       	sub	r6,16
8000ae8e:	c0 48       	rjmp	8000ae96 <_vfprintf_r+0x1d92>
8000ae90:	fe c2 bb 10 	sub	r2,pc,-17648
8000ae94:	31 00       	mov	r0,16
8000ae96:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ae9a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ae9e:	fe ca bb 1e 	sub	r10,pc,-17634
8000aea2:	59 06       	cp.w	r6,16
8000aea4:	fe 99 ff dd 	brgt	8000ae5e <_vfprintf_r+0x1d5a>
8000aea8:	0c 09       	add	r9,r6
8000aeaa:	87 0a       	st.w	r3[0x0],r10
8000aeac:	fb 49 06 90 	st.w	sp[1680],r9
8000aeb0:	2f f8       	sub	r8,-1
8000aeb2:	87 16       	st.w	r3[0x4],r6
8000aeb4:	fb 48 06 8c 	st.w	sp[1676],r8
8000aeb8:	c0 e8       	rjmp	8000aed4 <_vfprintf_r+0x1dd0>
8000aeba:	fa f8 06 90 	ld.w	r8,sp[1680]
8000aebe:	2f f8       	sub	r8,-1
8000aec0:	30 19       	mov	r9,1
8000aec2:	fb 48 06 90 	st.w	sp[1680],r8
8000aec6:	87 06       	st.w	r3[0x0],r6
8000aec8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000aecc:	87 19       	st.w	r3[0x4],r9
8000aece:	2f f8       	sub	r8,-1
8000aed0:	fb 48 06 8c 	st.w	sp[1676],r8
8000aed4:	58 78       	cp.w	r8,7
8000aed6:	e0 89 00 04 	brgt	8000aede <_vfprintf_r+0x1dda>
8000aeda:	2f 83       	sub	r3,-8
8000aedc:	c0 b8       	rjmp	8000aef2 <_vfprintf_r+0x1dee>
8000aede:	fa ca f9 78 	sub	r10,sp,-1672
8000aee2:	02 9b       	mov	r11,r1
8000aee4:	08 9c       	mov	r12,r4
8000aee6:	fe b0 f1 01 	rcall	800090e8 <__sprint_r>
8000aeea:	e0 81 00 8c 	brne	8000b002 <_vfprintf_r+0x1efe>
8000aeee:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aef2:	40 ea       	lddsp	r10,sp[0x38]
8000aef4:	fa f8 06 90 	ld.w	r8,sp[1680]
8000aef8:	14 08       	add	r8,r10
8000aefa:	fa c9 f9 64 	sub	r9,sp,-1692
8000aefe:	fb 48 06 90 	st.w	sp[1680],r8
8000af02:	87 1a       	st.w	r3[0x4],r10
8000af04:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000af08:	87 09       	st.w	r3[0x0],r9
8000af0a:	2f f8       	sub	r8,-1
8000af0c:	fb 48 06 8c 	st.w	sp[1676],r8
8000af10:	58 78       	cp.w	r8,7
8000af12:	e0 89 00 04 	brgt	8000af1a <_vfprintf_r+0x1e16>
8000af16:	2f 83       	sub	r3,-8
8000af18:	c0 a8       	rjmp	8000af2c <_vfprintf_r+0x1e28>
8000af1a:	fa ca f9 78 	sub	r10,sp,-1672
8000af1e:	02 9b       	mov	r11,r1
8000af20:	08 9c       	mov	r12,r4
8000af22:	fe b0 f0 e3 	rcall	800090e8 <__sprint_r>
8000af26:	c6 e1       	brne	8000b002 <_vfprintf_r+0x1efe>
8000af28:	fa c3 f9 e0 	sub	r3,sp,-1568
8000af2c:	e2 15 00 04 	andl	r5,0x4,COH
8000af30:	c3 f0       	breq	8000afae <_vfprintf_r+0x1eaa>
8000af32:	40 86       	lddsp	r6,sp[0x20]
8000af34:	40 39       	lddsp	r9,sp[0xc]
8000af36:	12 16       	sub	r6,r9
8000af38:	58 06       	cp.w	r6,0
8000af3a:	e0 89 00 1a 	brgt	8000af6e <_vfprintf_r+0x1e6a>
8000af3e:	c3 88       	rjmp	8000afae <_vfprintf_r+0x1eaa>
8000af40:	2f 09       	sub	r9,-16
8000af42:	2f f8       	sub	r8,-1
8000af44:	fb 49 06 90 	st.w	sp[1680],r9
8000af48:	87 05       	st.w	r3[0x0],r5
8000af4a:	87 12       	st.w	r3[0x4],r2
8000af4c:	fb 48 06 8c 	st.w	sp[1676],r8
8000af50:	58 78       	cp.w	r8,7
8000af52:	e0 89 00 04 	brgt	8000af5a <_vfprintf_r+0x1e56>
8000af56:	2f 83       	sub	r3,-8
8000af58:	c0 98       	rjmp	8000af6a <_vfprintf_r+0x1e66>
8000af5a:	00 9a       	mov	r10,r0
8000af5c:	02 9b       	mov	r11,r1
8000af5e:	08 9c       	mov	r12,r4
8000af60:	fe b0 f0 c4 	rcall	800090e8 <__sprint_r>
8000af64:	c4 f1       	brne	8000b002 <_vfprintf_r+0x1efe>
8000af66:	fa c3 f9 e0 	sub	r3,sp,-1568
8000af6a:	21 06       	sub	r6,16
8000af6c:	c0 68       	rjmp	8000af78 <_vfprintf_r+0x1e74>
8000af6e:	fe c5 bb fe 	sub	r5,pc,-17410
8000af72:	31 02       	mov	r2,16
8000af74:	fa c0 f9 78 	sub	r0,sp,-1672
8000af78:	fa f9 06 90 	ld.w	r9,sp[1680]
8000af7c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000af80:	fe ca bc 10 	sub	r10,pc,-17392
8000af84:	59 06       	cp.w	r6,16
8000af86:	fe 99 ff dd 	brgt	8000af40 <_vfprintf_r+0x1e3c>
8000af8a:	0c 09       	add	r9,r6
8000af8c:	2f f8       	sub	r8,-1
8000af8e:	87 0a       	st.w	r3[0x0],r10
8000af90:	87 16       	st.w	r3[0x4],r6
8000af92:	fb 49 06 90 	st.w	sp[1680],r9
8000af96:	fb 48 06 8c 	st.w	sp[1676],r8
8000af9a:	58 78       	cp.w	r8,7
8000af9c:	e0 8a 00 09 	brle	8000afae <_vfprintf_r+0x1eaa>
8000afa0:	fa ca f9 78 	sub	r10,sp,-1672
8000afa4:	02 9b       	mov	r11,r1
8000afa6:	08 9c       	mov	r12,r4
8000afa8:	fe b0 f0 a0 	rcall	800090e8 <__sprint_r>
8000afac:	c2 b1       	brne	8000b002 <_vfprintf_r+0x1efe>
8000afae:	40 bc       	lddsp	r12,sp[0x2c]
8000afb0:	40 36       	lddsp	r6,sp[0xc]
8000afb2:	40 8e       	lddsp	lr,sp[0x20]
8000afb4:	ec 0e 0c 48 	max	r8,r6,lr
8000afb8:	10 0c       	add	r12,r8
8000afba:	50 bc       	stdsp	sp[0x2c],r12
8000afbc:	fa f8 06 90 	ld.w	r8,sp[1680]
8000afc0:	58 08       	cp.w	r8,0
8000afc2:	c0 80       	breq	8000afd2 <_vfprintf_r+0x1ece>
8000afc4:	fa ca f9 78 	sub	r10,sp,-1672
8000afc8:	02 9b       	mov	r11,r1
8000afca:	08 9c       	mov	r12,r4
8000afcc:	fe b0 f0 8e 	rcall	800090e8 <__sprint_r>
8000afd0:	c1 91       	brne	8000b002 <_vfprintf_r+0x1efe>
8000afd2:	30 0b       	mov	r11,0
8000afd4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000afd8:	fb 4b 06 8c 	st.w	sp[1676],r11
8000afdc:	fe 9f f1 22 	bral	80009220 <_vfprintf_r+0x11c>
8000afe0:	08 95       	mov	r5,r4
8000afe2:	fa f8 06 90 	ld.w	r8,sp[1680]
8000afe6:	58 08       	cp.w	r8,0
8000afe8:	c0 80       	breq	8000aff8 <_vfprintf_r+0x1ef4>
8000afea:	08 9c       	mov	r12,r4
8000afec:	fa ca f9 78 	sub	r10,sp,-1672
8000aff0:	02 9b       	mov	r11,r1
8000aff2:	fe b0 f0 7b 	rcall	800090e8 <__sprint_r>
8000aff6:	c0 61       	brne	8000b002 <_vfprintf_r+0x1efe>
8000aff8:	30 08       	mov	r8,0
8000affa:	fb 48 06 8c 	st.w	sp[1676],r8
8000affe:	c0 28       	rjmp	8000b002 <_vfprintf_r+0x1efe>
8000b000:	40 41       	lddsp	r1,sp[0x10]
8000b002:	82 68       	ld.sh	r8,r1[0xc]
8000b004:	ed b8 00 06 	bld	r8,0x6
8000b008:	c0 31       	brne	8000b00e <_vfprintf_r+0x1f0a>
8000b00a:	3f fa       	mov	r10,-1
8000b00c:	50 ba       	stdsp	sp[0x2c],r10
8000b00e:	40 bc       	lddsp	r12,sp[0x2c]
8000b010:	fe 3d f9 44 	sub	sp,-1724
8000b014:	d8 32       	popm	r0-r7,pc
8000b016:	d7 03       	nop

8000b018 <__swsetup_r>:
8000b018:	d4 21       	pushm	r4-r7,lr
8000b01a:	e0 68 0a 54 	mov	r8,2644
8000b01e:	18 96       	mov	r6,r12
8000b020:	16 97       	mov	r7,r11
8000b022:	70 0c       	ld.w	r12,r8[0x0]
8000b024:	58 0c       	cp.w	r12,0
8000b026:	c0 60       	breq	8000b032 <__swsetup_r+0x1a>
8000b028:	78 68       	ld.w	r8,r12[0x18]
8000b02a:	58 08       	cp.w	r8,0
8000b02c:	c0 31       	brne	8000b032 <__swsetup_r+0x1a>
8000b02e:	e0 a0 07 bf 	rcall	8000bfac <__sinit>
8000b032:	fe c8 bb 92 	sub	r8,pc,-17518
8000b036:	10 37       	cp.w	r7,r8
8000b038:	c0 61       	brne	8000b044 <__swsetup_r+0x2c>
8000b03a:	e0 68 0a 54 	mov	r8,2644
8000b03e:	70 08       	ld.w	r8,r8[0x0]
8000b040:	70 07       	ld.w	r7,r8[0x0]
8000b042:	c1 28       	rjmp	8000b066 <__swsetup_r+0x4e>
8000b044:	fe c8 bb 84 	sub	r8,pc,-17532
8000b048:	10 37       	cp.w	r7,r8
8000b04a:	c0 61       	brne	8000b056 <__swsetup_r+0x3e>
8000b04c:	e0 68 0a 54 	mov	r8,2644
8000b050:	70 08       	ld.w	r8,r8[0x0]
8000b052:	70 17       	ld.w	r7,r8[0x4]
8000b054:	c0 98       	rjmp	8000b066 <__swsetup_r+0x4e>
8000b056:	fe c8 bb 76 	sub	r8,pc,-17546
8000b05a:	10 37       	cp.w	r7,r8
8000b05c:	c0 51       	brne	8000b066 <__swsetup_r+0x4e>
8000b05e:	e0 68 0a 54 	mov	r8,2644
8000b062:	70 08       	ld.w	r8,r8[0x0]
8000b064:	70 27       	ld.w	r7,r8[0x8]
8000b066:	8e 68       	ld.sh	r8,r7[0xc]
8000b068:	ed b8 00 03 	bld	r8,0x3
8000b06c:	c1 e0       	breq	8000b0a8 <__swsetup_r+0x90>
8000b06e:	ed b8 00 04 	bld	r8,0x4
8000b072:	c3 e1       	brne	8000b0ee <__swsetup_r+0xd6>
8000b074:	ed b8 00 02 	bld	r8,0x2
8000b078:	c1 51       	brne	8000b0a2 <__swsetup_r+0x8a>
8000b07a:	6e db       	ld.w	r11,r7[0x34]
8000b07c:	58 0b       	cp.w	r11,0
8000b07e:	c0 a0       	breq	8000b092 <__swsetup_r+0x7a>
8000b080:	ee c8 ff bc 	sub	r8,r7,-68
8000b084:	10 3b       	cp.w	r11,r8
8000b086:	c0 40       	breq	8000b08e <__swsetup_r+0x76>
8000b088:	0c 9c       	mov	r12,r6
8000b08a:	e0 a0 08 2b 	rcall	8000c0e0 <_free_r>
8000b08e:	30 08       	mov	r8,0
8000b090:	8f d8       	st.w	r7[0x34],r8
8000b092:	8e 68       	ld.sh	r8,r7[0xc]
8000b094:	e0 18 ff db 	andl	r8,0xffdb
8000b098:	ae 68       	st.h	r7[0xc],r8
8000b09a:	30 08       	mov	r8,0
8000b09c:	8f 18       	st.w	r7[0x4],r8
8000b09e:	6e 48       	ld.w	r8,r7[0x10]
8000b0a0:	8f 08       	st.w	r7[0x0],r8
8000b0a2:	8e 68       	ld.sh	r8,r7[0xc]
8000b0a4:	a3 b8       	sbr	r8,0x3
8000b0a6:	ae 68       	st.h	r7[0xc],r8
8000b0a8:	6e 48       	ld.w	r8,r7[0x10]
8000b0aa:	58 08       	cp.w	r8,0
8000b0ac:	c0 b1       	brne	8000b0c2 <__swsetup_r+0xaa>
8000b0ae:	8e 68       	ld.sh	r8,r7[0xc]
8000b0b0:	e2 18 02 80 	andl	r8,0x280,COH
8000b0b4:	e0 48 02 00 	cp.w	r8,512
8000b0b8:	c0 50       	breq	8000b0c2 <__swsetup_r+0xaa>
8000b0ba:	0c 9c       	mov	r12,r6
8000b0bc:	0e 9b       	mov	r11,r7
8000b0be:	e0 a0 0a 4b 	rcall	8000c554 <__smakebuf_r>
8000b0c2:	8e 69       	ld.sh	r9,r7[0xc]
8000b0c4:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000b0c8:	c0 70       	breq	8000b0d6 <__swsetup_r+0xbe>
8000b0ca:	30 08       	mov	r8,0
8000b0cc:	8f 28       	st.w	r7[0x8],r8
8000b0ce:	6e 58       	ld.w	r8,r7[0x14]
8000b0d0:	5c 38       	neg	r8
8000b0d2:	8f 68       	st.w	r7[0x18],r8
8000b0d4:	c0 68       	rjmp	8000b0e0 <__swsetup_r+0xc8>
8000b0d6:	ed b9 00 01 	bld	r9,0x1
8000b0da:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000b0de:	8f 28       	st.w	r7[0x8],r8
8000b0e0:	6e 48       	ld.w	r8,r7[0x10]
8000b0e2:	58 08       	cp.w	r8,0
8000b0e4:	c0 61       	brne	8000b0f0 <__swsetup_r+0xd8>
8000b0e6:	8e 68       	ld.sh	r8,r7[0xc]
8000b0e8:	ed b8 00 07 	bld	r8,0x7
8000b0ec:	c0 21       	brne	8000b0f0 <__swsetup_r+0xd8>
8000b0ee:	dc 2a       	popm	r4-r7,pc,r12=-1
8000b0f0:	d8 2a       	popm	r4-r7,pc,r12=0
8000b0f2:	d7 03       	nop

8000b0f4 <quorem>:
8000b0f4:	d4 31       	pushm	r0-r7,lr
8000b0f6:	20 2d       	sub	sp,8
8000b0f8:	18 97       	mov	r7,r12
8000b0fa:	78 48       	ld.w	r8,r12[0x10]
8000b0fc:	76 46       	ld.w	r6,r11[0x10]
8000b0fe:	0c 38       	cp.w	r8,r6
8000b100:	c0 34       	brge	8000b106 <quorem+0x12>
8000b102:	30 0c       	mov	r12,0
8000b104:	c8 58       	rjmp	8000b20e <quorem+0x11a>
8000b106:	ec c2 ff fc 	sub	r2,r6,-4
8000b10a:	f6 c3 ff ec 	sub	r3,r11,-20
8000b10e:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000b112:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000b116:	2f f9       	sub	r9,-1
8000b118:	20 16       	sub	r6,1
8000b11a:	f8 09 0d 08 	divu	r8,r12,r9
8000b11e:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000b122:	ee c4 ff ec 	sub	r4,r7,-20
8000b126:	10 95       	mov	r5,r8
8000b128:	58 08       	cp.w	r8,0
8000b12a:	c4 10       	breq	8000b1ac <quorem+0xb8>
8000b12c:	30 09       	mov	r9,0
8000b12e:	06 9a       	mov	r10,r3
8000b130:	08 98       	mov	r8,r4
8000b132:	12 91       	mov	r1,r9
8000b134:	50 0b       	stdsp	sp[0x0],r11
8000b136:	70 0e       	ld.w	lr,r8[0x0]
8000b138:	b1 8e       	lsr	lr,0x10
8000b13a:	50 1e       	stdsp	sp[0x4],lr
8000b13c:	15 0e       	ld.w	lr,r10++
8000b13e:	fc 00 16 10 	lsr	r0,lr,0x10
8000b142:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b146:	ea 0e 03 41 	mac	r1,r5,lr
8000b14a:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000b14e:	b1 81       	lsr	r1,0x10
8000b150:	40 1b       	lddsp	r11,sp[0x4]
8000b152:	ea 00 02 40 	mul	r0,r5,r0
8000b156:	e2 00 00 00 	add	r0,r1,r0
8000b15a:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000b15e:	02 1b       	sub	r11,r1
8000b160:	50 1b       	stdsp	sp[0x4],r11
8000b162:	70 0b       	ld.w	r11,r8[0x0]
8000b164:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000b168:	02 09       	add	r9,r1
8000b16a:	f2 0e 01 0e 	sub	lr,r9,lr
8000b16e:	b0 1e       	st.h	r8[0x2],lr
8000b170:	fc 09 14 10 	asr	r9,lr,0x10
8000b174:	40 1e       	lddsp	lr,sp[0x4]
8000b176:	fc 09 00 09 	add	r9,lr,r9
8000b17a:	b0 09       	st.h	r8[0x0],r9
8000b17c:	e0 01 16 10 	lsr	r1,r0,0x10
8000b180:	2f c8       	sub	r8,-4
8000b182:	b1 49       	asr	r9,0x10
8000b184:	04 3a       	cp.w	r10,r2
8000b186:	fe 98 ff d8 	brls	8000b136 <quorem+0x42>
8000b18a:	40 0b       	lddsp	r11,sp[0x0]
8000b18c:	58 0c       	cp.w	r12,0
8000b18e:	c0 f1       	brne	8000b1ac <quorem+0xb8>
8000b190:	ec c8 ff fb 	sub	r8,r6,-5
8000b194:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000b198:	c0 28       	rjmp	8000b19c <quorem+0xa8>
8000b19a:	20 16       	sub	r6,1
8000b19c:	20 48       	sub	r8,4
8000b19e:	08 38       	cp.w	r8,r4
8000b1a0:	e0 88 00 05 	brls	8000b1aa <quorem+0xb6>
8000b1a4:	70 09       	ld.w	r9,r8[0x0]
8000b1a6:	58 09       	cp.w	r9,0
8000b1a8:	cf 90       	breq	8000b19a <quorem+0xa6>
8000b1aa:	8f 46       	st.w	r7[0x10],r6
8000b1ac:	0e 9c       	mov	r12,r7
8000b1ae:	e0 a0 0a d2 	rcall	8000c752 <__mcmp>
8000b1b2:	c2 d5       	brlt	8000b20c <quorem+0x118>
8000b1b4:	2f f5       	sub	r5,-1
8000b1b6:	08 98       	mov	r8,r4
8000b1b8:	30 09       	mov	r9,0
8000b1ba:	07 0b       	ld.w	r11,r3++
8000b1bc:	f6 0a 16 10 	lsr	r10,r11,0x10
8000b1c0:	70 0c       	ld.w	r12,r8[0x0]
8000b1c2:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b1c6:	f8 0e 16 10 	lsr	lr,r12,0x10
8000b1ca:	14 1e       	sub	lr,r10
8000b1cc:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000b1d0:	16 1a       	sub	r10,r11
8000b1d2:	12 0a       	add	r10,r9
8000b1d4:	b0 1a       	st.h	r8[0x2],r10
8000b1d6:	b1 4a       	asr	r10,0x10
8000b1d8:	fc 0a 00 09 	add	r9,lr,r10
8000b1dc:	b0 09       	st.h	r8[0x0],r9
8000b1de:	2f c8       	sub	r8,-4
8000b1e0:	b1 49       	asr	r9,0x10
8000b1e2:	04 33       	cp.w	r3,r2
8000b1e4:	fe 98 ff eb 	brls	8000b1ba <quorem+0xc6>
8000b1e8:	ec c8 ff fb 	sub	r8,r6,-5
8000b1ec:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000b1f0:	58 09       	cp.w	r9,0
8000b1f2:	c0 d1       	brne	8000b20c <quorem+0x118>
8000b1f4:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000b1f8:	c0 28       	rjmp	8000b1fc <quorem+0x108>
8000b1fa:	20 16       	sub	r6,1
8000b1fc:	20 48       	sub	r8,4
8000b1fe:	08 38       	cp.w	r8,r4
8000b200:	e0 88 00 05 	brls	8000b20a <quorem+0x116>
8000b204:	70 09       	ld.w	r9,r8[0x0]
8000b206:	58 09       	cp.w	r9,0
8000b208:	cf 90       	breq	8000b1fa <quorem+0x106>
8000b20a:	8f 46       	st.w	r7[0x10],r6
8000b20c:	0a 9c       	mov	r12,r5
8000b20e:	2f ed       	sub	sp,-8
8000b210:	d8 32       	popm	r0-r7,pc
8000b212:	d7 03       	nop

8000b214 <_dtoa_r>:
8000b214:	d4 31       	pushm	r0-r7,lr
8000b216:	21 ad       	sub	sp,104
8000b218:	fa c4 ff 74 	sub	r4,sp,-140
8000b21c:	18 97       	mov	r7,r12
8000b21e:	16 95       	mov	r5,r11
8000b220:	68 2c       	ld.w	r12,r4[0x8]
8000b222:	50 c9       	stdsp	sp[0x30],r9
8000b224:	68 16       	ld.w	r6,r4[0x4]
8000b226:	68 09       	ld.w	r9,r4[0x0]
8000b228:	50 e8       	stdsp	sp[0x38],r8
8000b22a:	14 94       	mov	r4,r10
8000b22c:	51 2c       	stdsp	sp[0x48],r12
8000b22e:	fa e5 00 08 	st.d	sp[8],r4
8000b232:	51 59       	stdsp	sp[0x54],r9
8000b234:	6e 95       	ld.w	r5,r7[0x24]
8000b236:	58 05       	cp.w	r5,0
8000b238:	c0 91       	brne	8000b24a <_dtoa_r+0x36>
8000b23a:	31 0c       	mov	r12,16
8000b23c:	fe b0 e8 e2 	rcall	80008400 <malloc>
8000b240:	99 35       	st.w	r12[0xc],r5
8000b242:	8f 9c       	st.w	r7[0x24],r12
8000b244:	99 15       	st.w	r12[0x4],r5
8000b246:	99 25       	st.w	r12[0x8],r5
8000b248:	99 05       	st.w	r12[0x0],r5
8000b24a:	6e 99       	ld.w	r9,r7[0x24]
8000b24c:	72 08       	ld.w	r8,r9[0x0]
8000b24e:	58 08       	cp.w	r8,0
8000b250:	c0 f0       	breq	8000b26e <_dtoa_r+0x5a>
8000b252:	72 1a       	ld.w	r10,r9[0x4]
8000b254:	91 1a       	st.w	r8[0x4],r10
8000b256:	30 1a       	mov	r10,1
8000b258:	72 19       	ld.w	r9,r9[0x4]
8000b25a:	f4 09 09 49 	lsl	r9,r10,r9
8000b25e:	10 9b       	mov	r11,r8
8000b260:	91 29       	st.w	r8[0x8],r9
8000b262:	0e 9c       	mov	r12,r7
8000b264:	e0 a0 0a 90 	rcall	8000c784 <_Bfree>
8000b268:	6e 98       	ld.w	r8,r7[0x24]
8000b26a:	30 09       	mov	r9,0
8000b26c:	91 09       	st.w	r8[0x0],r9
8000b26e:	40 28       	lddsp	r8,sp[0x8]
8000b270:	10 94       	mov	r4,r8
8000b272:	58 08       	cp.w	r8,0
8000b274:	c0 64       	brge	8000b280 <_dtoa_r+0x6c>
8000b276:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000b27a:	50 28       	stdsp	sp[0x8],r8
8000b27c:	30 18       	mov	r8,1
8000b27e:	c0 28       	rjmp	8000b282 <_dtoa_r+0x6e>
8000b280:	30 08       	mov	r8,0
8000b282:	8d 08       	st.w	r6[0x0],r8
8000b284:	fc 1c 7f f0 	movh	r12,0x7ff0
8000b288:	40 26       	lddsp	r6,sp[0x8]
8000b28a:	0c 98       	mov	r8,r6
8000b28c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000b290:	18 38       	cp.w	r8,r12
8000b292:	c2 01       	brne	8000b2d2 <_dtoa_r+0xbe>
8000b294:	e0 68 27 0f 	mov	r8,9999
8000b298:	41 5b       	lddsp	r11,sp[0x54]
8000b29a:	97 08       	st.w	r11[0x0],r8
8000b29c:	40 3a       	lddsp	r10,sp[0xc]
8000b29e:	58 0a       	cp.w	r10,0
8000b2a0:	c0 71       	brne	8000b2ae <_dtoa_r+0x9a>
8000b2a2:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000b2a6:	c0 41       	brne	8000b2ae <_dtoa_r+0x9a>
8000b2a8:	fe cc be 18 	sub	r12,pc,-16872
8000b2ac:	c0 38       	rjmp	8000b2b2 <_dtoa_r+0x9e>
8000b2ae:	fe cc be 12 	sub	r12,pc,-16878
8000b2b2:	41 29       	lddsp	r9,sp[0x48]
8000b2b4:	58 09       	cp.w	r9,0
8000b2b6:	e0 80 05 9a 	breq	8000bdea <_dtoa_r+0xbd6>
8000b2ba:	f8 c8 ff fd 	sub	r8,r12,-3
8000b2be:	f8 c9 ff f8 	sub	r9,r12,-8
8000b2c2:	11 8b       	ld.ub	r11,r8[0x0]
8000b2c4:	30 0a       	mov	r10,0
8000b2c6:	41 25       	lddsp	r5,sp[0x48]
8000b2c8:	f4 0b 18 00 	cp.b	r11,r10
8000b2cc:	f2 08 17 10 	movne	r8,r9
8000b2d0:	c1 68       	rjmp	8000b2fc <_dtoa_r+0xe8>
8000b2d2:	fa ea 00 08 	ld.d	r10,sp[8]
8000b2d6:	30 08       	mov	r8,0
8000b2d8:	fa eb 00 3c 	st.d	sp[60],r10
8000b2dc:	30 09       	mov	r9,0
8000b2de:	e0 a0 10 ce 	rcall	8000d47a <__avr32_f64_cmp_eq>
8000b2e2:	c1 00       	breq	8000b302 <_dtoa_r+0xee>
8000b2e4:	30 18       	mov	r8,1
8000b2e6:	41 5a       	lddsp	r10,sp[0x54]
8000b2e8:	95 08       	st.w	r10[0x0],r8
8000b2ea:	fe cc bf 7e 	sub	r12,pc,-16514
8000b2ee:	41 29       	lddsp	r9,sp[0x48]
8000b2f0:	f8 08 00 08 	add	r8,r12,r8
8000b2f4:	58 09       	cp.w	r9,0
8000b2f6:	e0 80 05 7a 	breq	8000bdea <_dtoa_r+0xbd6>
8000b2fa:	12 95       	mov	r5,r9
8000b2fc:	8b 08       	st.w	r5[0x0],r8
8000b2fe:	e0 8f 05 76 	bral	8000bdea <_dtoa_r+0xbd6>
8000b302:	fa c8 ff 9c 	sub	r8,sp,-100
8000b306:	fa c9 ff a0 	sub	r9,sp,-96
8000b30a:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b30e:	0e 9c       	mov	r12,r7
8000b310:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000b314:	e0 a0 0a 8a 	rcall	8000c828 <__d2b>
8000b318:	18 93       	mov	r3,r12
8000b31a:	58 05       	cp.w	r5,0
8000b31c:	c0 d0       	breq	8000b336 <_dtoa_r+0x122>
8000b31e:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b322:	30 04       	mov	r4,0
8000b324:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000b328:	ea c5 03 ff 	sub	r5,r5,1023
8000b32c:	10 9b       	mov	r11,r8
8000b32e:	51 74       	stdsp	sp[0x5c],r4
8000b330:	ea 1b 3f f0 	orh	r11,0x3ff0
8000b334:	c2 58       	rjmp	8000b37e <_dtoa_r+0x16a>
8000b336:	41 88       	lddsp	r8,sp[0x60]
8000b338:	41 9c       	lddsp	r12,sp[0x64]
8000b33a:	10 0c       	add	r12,r8
8000b33c:	f8 c5 fb ce 	sub	r5,r12,-1074
8000b340:	e0 45 00 20 	cp.w	r5,32
8000b344:	e0 8a 00 0e 	brle	8000b360 <_dtoa_r+0x14c>
8000b348:	f8 cc fb ee 	sub	r12,r12,-1042
8000b34c:	40 3b       	lddsp	r11,sp[0xc]
8000b34e:	ea 08 11 40 	rsub	r8,r5,64
8000b352:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000b356:	ec 08 09 46 	lsl	r6,r6,r8
8000b35a:	0c 4c       	or	r12,r6
8000b35c:	c0 78       	rjmp	8000b36a <_dtoa_r+0x156>
8000b35e:	d7 03       	nop
8000b360:	ea 0c 11 20 	rsub	r12,r5,32
8000b364:	40 3a       	lddsp	r10,sp[0xc]
8000b366:	f4 0c 09 4c 	lsl	r12,r10,r12
8000b36a:	e0 a0 10 14 	rcall	8000d392 <__avr32_u32_to_f64>
8000b36e:	fc 18 fe 10 	movh	r8,0xfe10
8000b372:	30 19       	mov	r9,1
8000b374:	ea c5 04 33 	sub	r5,r5,1075
8000b378:	f0 0b 00 0b 	add	r11,r8,r11
8000b37c:	51 79       	stdsp	sp[0x5c],r9
8000b37e:	30 08       	mov	r8,0
8000b380:	fc 19 3f f8 	movh	r9,0x3ff8
8000b384:	e0 a0 0e 9c 	rcall	8000d0bc <__avr32_f64_sub>
8000b388:	e0 68 43 61 	mov	r8,17249
8000b38c:	ea 18 63 6f 	orh	r8,0x636f
8000b390:	e0 69 87 a7 	mov	r9,34727
8000b394:	ea 19 3f d2 	orh	r9,0x3fd2
8000b398:	e0 a0 0d a6 	rcall	8000cee4 <__avr32_f64_mul>
8000b39c:	e0 68 c8 b3 	mov	r8,51379
8000b3a0:	ea 18 8b 60 	orh	r8,0x8b60
8000b3a4:	e0 69 8a 28 	mov	r9,35368
8000b3a8:	ea 19 3f c6 	orh	r9,0x3fc6
8000b3ac:	e0 a0 0f 56 	rcall	8000d258 <__avr32_f64_add>
8000b3b0:	0a 9c       	mov	r12,r5
8000b3b2:	14 90       	mov	r0,r10
8000b3b4:	16 91       	mov	r1,r11
8000b3b6:	e0 a0 0f f2 	rcall	8000d39a <__avr32_s32_to_f64>
8000b3ba:	e0 68 79 fb 	mov	r8,31227
8000b3be:	ea 18 50 9f 	orh	r8,0x509f
8000b3c2:	e0 69 44 13 	mov	r9,17427
8000b3c6:	ea 19 3f d3 	orh	r9,0x3fd3
8000b3ca:	e0 a0 0d 8d 	rcall	8000cee4 <__avr32_f64_mul>
8000b3ce:	14 98       	mov	r8,r10
8000b3d0:	16 99       	mov	r9,r11
8000b3d2:	00 9a       	mov	r10,r0
8000b3d4:	02 9b       	mov	r11,r1
8000b3d6:	e0 a0 0f 41 	rcall	8000d258 <__avr32_f64_add>
8000b3da:	14 90       	mov	r0,r10
8000b3dc:	16 91       	mov	r1,r11
8000b3de:	e0 a0 0f c7 	rcall	8000d36c <__avr32_f64_to_s32>
8000b3e2:	30 08       	mov	r8,0
8000b3e4:	18 96       	mov	r6,r12
8000b3e6:	30 09       	mov	r9,0
8000b3e8:	00 9a       	mov	r10,r0
8000b3ea:	02 9b       	mov	r11,r1
8000b3ec:	e0 a0 10 8e 	rcall	8000d508 <__avr32_f64_cmp_lt>
8000b3f0:	c0 c0       	breq	8000b408 <_dtoa_r+0x1f4>
8000b3f2:	0c 9c       	mov	r12,r6
8000b3f4:	e0 a0 0f d3 	rcall	8000d39a <__avr32_s32_to_f64>
8000b3f8:	14 98       	mov	r8,r10
8000b3fa:	16 99       	mov	r9,r11
8000b3fc:	00 9a       	mov	r10,r0
8000b3fe:	02 9b       	mov	r11,r1
8000b400:	e0 a0 10 3d 	rcall	8000d47a <__avr32_f64_cmp_eq>
8000b404:	f7 b6 00 01 	subeq	r6,1
8000b408:	59 66       	cp.w	r6,22
8000b40a:	e0 88 00 05 	brls	8000b414 <_dtoa_r+0x200>
8000b40e:	30 18       	mov	r8,1
8000b410:	51 48       	stdsp	sp[0x50],r8
8000b412:	c1 38       	rjmp	8000b438 <_dtoa_r+0x224>
8000b414:	fe c8 be c4 	sub	r8,pc,-16700
8000b418:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b41c:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000b420:	e0 a0 10 74 	rcall	8000d508 <__avr32_f64_cmp_lt>
8000b424:	f9 b4 00 00 	moveq	r4,0
8000b428:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000b42c:	f7 b6 01 01 	subne	r6,1
8000b430:	f9 bc 01 00 	movne	r12,0
8000b434:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000b438:	41 90       	lddsp	r0,sp[0x64]
8000b43a:	20 10       	sub	r0,1
8000b43c:	0a 10       	sub	r0,r5
8000b43e:	c0 46       	brmi	8000b446 <_dtoa_r+0x232>
8000b440:	50 40       	stdsp	sp[0x10],r0
8000b442:	30 00       	mov	r0,0
8000b444:	c0 48       	rjmp	8000b44c <_dtoa_r+0x238>
8000b446:	30 0b       	mov	r11,0
8000b448:	5c 30       	neg	r0
8000b44a:	50 4b       	stdsp	sp[0x10],r11
8000b44c:	ec 02 11 00 	rsub	r2,r6,0
8000b450:	58 06       	cp.w	r6,0
8000b452:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000b456:	f5 d6 e4 0a 	addge	r10,r10,r6
8000b45a:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000b45e:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000b462:	f9 b2 04 00 	movge	r2,0
8000b466:	e1 d6 e5 10 	sublt	r0,r0,r6
8000b46a:	f9 b9 05 00 	movlt	r9,0
8000b46e:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000b472:	40 c8       	lddsp	r8,sp[0x30]
8000b474:	58 98       	cp.w	r8,9
8000b476:	e0 8b 00 20 	brhi	8000b4b6 <_dtoa_r+0x2a2>
8000b47a:	58 58       	cp.w	r8,5
8000b47c:	f9 b4 0a 01 	movle	r4,1
8000b480:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000b484:	f7 b5 09 04 	subgt	r5,4
8000b488:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000b48c:	f9 b4 09 00 	movgt	r4,0
8000b490:	40 cc       	lddsp	r12,sp[0x30]
8000b492:	58 3c       	cp.w	r12,3
8000b494:	c2 d0       	breq	8000b4ee <_dtoa_r+0x2da>
8000b496:	e0 89 00 05 	brgt	8000b4a0 <_dtoa_r+0x28c>
8000b49a:	58 2c       	cp.w	r12,2
8000b49c:	c1 01       	brne	8000b4bc <_dtoa_r+0x2a8>
8000b49e:	c1 88       	rjmp	8000b4ce <_dtoa_r+0x2ba>
8000b4a0:	40 cb       	lddsp	r11,sp[0x30]
8000b4a2:	58 4b       	cp.w	r11,4
8000b4a4:	c0 60       	breq	8000b4b0 <_dtoa_r+0x29c>
8000b4a6:	58 5b       	cp.w	r11,5
8000b4a8:	c0 a1       	brne	8000b4bc <_dtoa_r+0x2a8>
8000b4aa:	30 1a       	mov	r10,1
8000b4ac:	50 da       	stdsp	sp[0x34],r10
8000b4ae:	c2 28       	rjmp	8000b4f2 <_dtoa_r+0x2de>
8000b4b0:	30 19       	mov	r9,1
8000b4b2:	50 d9       	stdsp	sp[0x34],r9
8000b4b4:	c0 f8       	rjmp	8000b4d2 <_dtoa_r+0x2be>
8000b4b6:	30 08       	mov	r8,0
8000b4b8:	30 14       	mov	r4,1
8000b4ba:	50 c8       	stdsp	sp[0x30],r8
8000b4bc:	3f f5       	mov	r5,-1
8000b4be:	30 1c       	mov	r12,1
8000b4c0:	30 0b       	mov	r11,0
8000b4c2:	50 95       	stdsp	sp[0x24],r5
8000b4c4:	50 dc       	stdsp	sp[0x34],r12
8000b4c6:	0a 91       	mov	r1,r5
8000b4c8:	31 28       	mov	r8,18
8000b4ca:	50 eb       	stdsp	sp[0x38],r11
8000b4cc:	c2 08       	rjmp	8000b50c <_dtoa_r+0x2f8>
8000b4ce:	30 0a       	mov	r10,0
8000b4d0:	50 da       	stdsp	sp[0x34],r10
8000b4d2:	40 e9       	lddsp	r9,sp[0x38]
8000b4d4:	58 09       	cp.w	r9,0
8000b4d6:	e0 89 00 07 	brgt	8000b4e4 <_dtoa_r+0x2d0>
8000b4da:	30 18       	mov	r8,1
8000b4dc:	50 98       	stdsp	sp[0x24],r8
8000b4de:	10 91       	mov	r1,r8
8000b4e0:	50 e8       	stdsp	sp[0x38],r8
8000b4e2:	c1 58       	rjmp	8000b50c <_dtoa_r+0x2f8>
8000b4e4:	40 e5       	lddsp	r5,sp[0x38]
8000b4e6:	50 95       	stdsp	sp[0x24],r5
8000b4e8:	0a 91       	mov	r1,r5
8000b4ea:	0a 98       	mov	r8,r5
8000b4ec:	c1 08       	rjmp	8000b50c <_dtoa_r+0x2f8>
8000b4ee:	30 0c       	mov	r12,0
8000b4f0:	50 dc       	stdsp	sp[0x34],r12
8000b4f2:	40 eb       	lddsp	r11,sp[0x38]
8000b4f4:	ec 0b 00 0b 	add	r11,r6,r11
8000b4f8:	50 9b       	stdsp	sp[0x24],r11
8000b4fa:	16 98       	mov	r8,r11
8000b4fc:	2f f8       	sub	r8,-1
8000b4fe:	58 08       	cp.w	r8,0
8000b500:	e0 89 00 05 	brgt	8000b50a <_dtoa_r+0x2f6>
8000b504:	10 91       	mov	r1,r8
8000b506:	30 18       	mov	r8,1
8000b508:	c0 28       	rjmp	8000b50c <_dtoa_r+0x2f8>
8000b50a:	10 91       	mov	r1,r8
8000b50c:	30 09       	mov	r9,0
8000b50e:	6e 9a       	ld.w	r10,r7[0x24]
8000b510:	95 19       	st.w	r10[0x4],r9
8000b512:	30 49       	mov	r9,4
8000b514:	c0 68       	rjmp	8000b520 <_dtoa_r+0x30c>
8000b516:	d7 03       	nop
8000b518:	6a 1a       	ld.w	r10,r5[0x4]
8000b51a:	a1 79       	lsl	r9,0x1
8000b51c:	2f fa       	sub	r10,-1
8000b51e:	8b 1a       	st.w	r5[0x4],r10
8000b520:	6e 95       	ld.w	r5,r7[0x24]
8000b522:	f2 ca ff ec 	sub	r10,r9,-20
8000b526:	10 3a       	cp.w	r10,r8
8000b528:	fe 98 ff f8 	brls	8000b518 <_dtoa_r+0x304>
8000b52c:	6a 1b       	ld.w	r11,r5[0x4]
8000b52e:	0e 9c       	mov	r12,r7
8000b530:	e0 a0 09 44 	rcall	8000c7b8 <_Balloc>
8000b534:	58 e1       	cp.w	r1,14
8000b536:	5f 88       	srls	r8
8000b538:	8b 0c       	st.w	r5[0x0],r12
8000b53a:	f1 e4 00 04 	and	r4,r8,r4
8000b53e:	6e 98       	ld.w	r8,r7[0x24]
8000b540:	70 08       	ld.w	r8,r8[0x0]
8000b542:	50 88       	stdsp	sp[0x20],r8
8000b544:	e0 80 01 82 	breq	8000b848 <_dtoa_r+0x634>
8000b548:	58 06       	cp.w	r6,0
8000b54a:	e0 8a 00 43 	brle	8000b5d0 <_dtoa_r+0x3bc>
8000b54e:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000b552:	fe c8 c0 02 	sub	r8,pc,-16382
8000b556:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000b55a:	fa e5 00 18 	st.d	sp[24],r4
8000b55e:	ec 04 14 04 	asr	r4,r6,0x4
8000b562:	ed b4 00 04 	bld	r4,0x4
8000b566:	c0 30       	breq	8000b56c <_dtoa_r+0x358>
8000b568:	30 25       	mov	r5,2
8000b56a:	c1 08       	rjmp	8000b58a <_dtoa_r+0x376>
8000b56c:	fe c8 bf 54 	sub	r8,pc,-16556
8000b570:	f0 e8 00 20 	ld.d	r8,r8[32]
8000b574:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b578:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000b57c:	e0 a0 0f fa 	rcall	8000d570 <__avr32_f64_div>
8000b580:	30 35       	mov	r5,3
8000b582:	14 98       	mov	r8,r10
8000b584:	16 99       	mov	r9,r11
8000b586:	fa e9 00 08 	st.d	sp[8],r8
8000b58a:	fe cc bf 72 	sub	r12,pc,-16526
8000b58e:	50 a3       	stdsp	sp[0x28],r3
8000b590:	0c 93       	mov	r3,r6
8000b592:	18 96       	mov	r6,r12
8000b594:	c0 f8       	rjmp	8000b5b2 <_dtoa_r+0x39e>
8000b596:	fa ea 00 18 	ld.d	r10,sp[24]
8000b59a:	ed b4 00 00 	bld	r4,0x0
8000b59e:	c0 81       	brne	8000b5ae <_dtoa_r+0x39a>
8000b5a0:	ec e8 00 00 	ld.d	r8,r6[0]
8000b5a4:	2f f5       	sub	r5,-1
8000b5a6:	e0 a0 0c 9f 	rcall	8000cee4 <__avr32_f64_mul>
8000b5aa:	fa eb 00 18 	st.d	sp[24],r10
8000b5ae:	a1 54       	asr	r4,0x1
8000b5b0:	2f 86       	sub	r6,-8
8000b5b2:	58 04       	cp.w	r4,0
8000b5b4:	cf 11       	brne	8000b596 <_dtoa_r+0x382>
8000b5b6:	fa e8 00 18 	ld.d	r8,sp[24]
8000b5ba:	fa ea 00 08 	ld.d	r10,sp[8]
8000b5be:	06 96       	mov	r6,r3
8000b5c0:	e0 a0 0f d8 	rcall	8000d570 <__avr32_f64_div>
8000b5c4:	40 a3       	lddsp	r3,sp[0x28]
8000b5c6:	14 98       	mov	r8,r10
8000b5c8:	16 99       	mov	r9,r11
8000b5ca:	fa e9 00 08 	st.d	sp[8],r8
8000b5ce:	c2 f8       	rjmp	8000b62c <_dtoa_r+0x418>
8000b5d0:	ec 08 11 00 	rsub	r8,r6,0
8000b5d4:	c0 31       	brne	8000b5da <_dtoa_r+0x3c6>
8000b5d6:	30 25       	mov	r5,2
8000b5d8:	c2 a8       	rjmp	8000b62c <_dtoa_r+0x418>
8000b5da:	fe cc bf c2 	sub	r12,pc,-16446
8000b5de:	f0 04 14 04 	asr	r4,r8,0x4
8000b5e2:	50 1c       	stdsp	sp[0x4],r12
8000b5e4:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000b5e8:	fe c9 c0 98 	sub	r9,pc,-16232
8000b5ec:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b5f0:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000b5f4:	e0 a0 0c 78 	rcall	8000cee4 <__avr32_f64_mul>
8000b5f8:	40 1c       	lddsp	r12,sp[0x4]
8000b5fa:	50 63       	stdsp	sp[0x18],r3
8000b5fc:	30 25       	mov	r5,2
8000b5fe:	0c 93       	mov	r3,r6
8000b600:	fa eb 00 08 	st.d	sp[8],r10
8000b604:	18 96       	mov	r6,r12
8000b606:	c0 f8       	rjmp	8000b624 <_dtoa_r+0x410>
8000b608:	fa ea 00 08 	ld.d	r10,sp[8]
8000b60c:	ed b4 00 00 	bld	r4,0x0
8000b610:	c0 81       	brne	8000b620 <_dtoa_r+0x40c>
8000b612:	ec e8 00 00 	ld.d	r8,r6[0]
8000b616:	2f f5       	sub	r5,-1
8000b618:	e0 a0 0c 66 	rcall	8000cee4 <__avr32_f64_mul>
8000b61c:	fa eb 00 08 	st.d	sp[8],r10
8000b620:	a1 54       	asr	r4,0x1
8000b622:	2f 86       	sub	r6,-8
8000b624:	58 04       	cp.w	r4,0
8000b626:	cf 11       	brne	8000b608 <_dtoa_r+0x3f4>
8000b628:	06 96       	mov	r6,r3
8000b62a:	40 63       	lddsp	r3,sp[0x18]
8000b62c:	41 4a       	lddsp	r10,sp[0x50]
8000b62e:	58 0a       	cp.w	r10,0
8000b630:	c2 a0       	breq	8000b684 <_dtoa_r+0x470>
8000b632:	fa e8 00 08 	ld.d	r8,sp[8]
8000b636:	58 01       	cp.w	r1,0
8000b638:	5f 94       	srgt	r4
8000b63a:	fa e9 00 18 	st.d	sp[24],r8
8000b63e:	30 08       	mov	r8,0
8000b640:	fc 19 3f f0 	movh	r9,0x3ff0
8000b644:	fa ea 00 18 	ld.d	r10,sp[24]
8000b648:	e0 a0 0f 60 	rcall	8000d508 <__avr32_f64_cmp_lt>
8000b64c:	f9 bc 00 00 	moveq	r12,0
8000b650:	f9 bc 01 01 	movne	r12,1
8000b654:	e9 ec 00 0c 	and	r12,r4,r12
8000b658:	c1 60       	breq	8000b684 <_dtoa_r+0x470>
8000b65a:	40 98       	lddsp	r8,sp[0x24]
8000b65c:	58 08       	cp.w	r8,0
8000b65e:	e0 8a 00 f1 	brle	8000b840 <_dtoa_r+0x62c>
8000b662:	30 08       	mov	r8,0
8000b664:	fc 19 40 24 	movh	r9,0x4024
8000b668:	ec c4 00 01 	sub	r4,r6,1
8000b66c:	fa ea 00 18 	ld.d	r10,sp[24]
8000b670:	2f f5       	sub	r5,-1
8000b672:	50 64       	stdsp	sp[0x18],r4
8000b674:	e0 a0 0c 38 	rcall	8000cee4 <__avr32_f64_mul>
8000b678:	40 94       	lddsp	r4,sp[0x24]
8000b67a:	14 98       	mov	r8,r10
8000b67c:	16 99       	mov	r9,r11
8000b67e:	fa e9 00 08 	st.d	sp[8],r8
8000b682:	c0 38       	rjmp	8000b688 <_dtoa_r+0x474>
8000b684:	50 66       	stdsp	sp[0x18],r6
8000b686:	02 94       	mov	r4,r1
8000b688:	0a 9c       	mov	r12,r5
8000b68a:	e0 a0 0e 88 	rcall	8000d39a <__avr32_s32_to_f64>
8000b68e:	fa e8 00 08 	ld.d	r8,sp[8]
8000b692:	e0 a0 0c 29 	rcall	8000cee4 <__avr32_f64_mul>
8000b696:	30 08       	mov	r8,0
8000b698:	fc 19 40 1c 	movh	r9,0x401c
8000b69c:	e0 a0 0d de 	rcall	8000d258 <__avr32_f64_add>
8000b6a0:	14 98       	mov	r8,r10
8000b6a2:	16 99       	mov	r9,r11
8000b6a4:	fa e9 00 28 	st.d	sp[40],r8
8000b6a8:	fc 18 fc c0 	movh	r8,0xfcc0
8000b6ac:	40 a5       	lddsp	r5,sp[0x28]
8000b6ae:	10 05       	add	r5,r8
8000b6b0:	50 a5       	stdsp	sp[0x28],r5
8000b6b2:	58 04       	cp.w	r4,0
8000b6b4:	c2 11       	brne	8000b6f6 <_dtoa_r+0x4e2>
8000b6b6:	fa ea 00 08 	ld.d	r10,sp[8]
8000b6ba:	30 08       	mov	r8,0
8000b6bc:	fc 19 40 14 	movh	r9,0x4014
8000b6c0:	e0 a0 0c fe 	rcall	8000d0bc <__avr32_f64_sub>
8000b6c4:	40 bc       	lddsp	r12,sp[0x2c]
8000b6c6:	fa eb 00 08 	st.d	sp[8],r10
8000b6ca:	14 98       	mov	r8,r10
8000b6cc:	16 99       	mov	r9,r11
8000b6ce:	18 9a       	mov	r10,r12
8000b6d0:	0a 9b       	mov	r11,r5
8000b6d2:	e0 a0 0f 1b 	rcall	8000d508 <__avr32_f64_cmp_lt>
8000b6d6:	e0 81 02 54 	brne	8000bb7e <_dtoa_r+0x96a>
8000b6da:	0a 98       	mov	r8,r5
8000b6dc:	40 b9       	lddsp	r9,sp[0x2c]
8000b6de:	ee 18 80 00 	eorh	r8,0x8000
8000b6e2:	fa ea 00 08 	ld.d	r10,sp[8]
8000b6e6:	10 95       	mov	r5,r8
8000b6e8:	12 98       	mov	r8,r9
8000b6ea:	0a 99       	mov	r9,r5
8000b6ec:	e0 a0 0f 0e 	rcall	8000d508 <__avr32_f64_cmp_lt>
8000b6f0:	e0 81 02 3e 	brne	8000bb6c <_dtoa_r+0x958>
8000b6f4:	ca 68       	rjmp	8000b840 <_dtoa_r+0x62c>
8000b6f6:	fe c9 c1 a6 	sub	r9,pc,-15962
8000b6fa:	e8 c8 00 01 	sub	r8,r4,1
8000b6fe:	40 d5       	lddsp	r5,sp[0x34]
8000b700:	58 05       	cp.w	r5,0
8000b702:	c4 f0       	breq	8000b7a0 <_dtoa_r+0x58c>
8000b704:	30 0c       	mov	r12,0
8000b706:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000b70a:	51 3c       	stdsp	sp[0x4c],r12
8000b70c:	30 0a       	mov	r10,0
8000b70e:	fc 1b 3f e0 	movh	r11,0x3fe0
8000b712:	e0 a0 0f 2f 	rcall	8000d570 <__avr32_f64_div>
8000b716:	fa e8 00 28 	ld.d	r8,sp[40]
8000b71a:	40 85       	lddsp	r5,sp[0x20]
8000b71c:	e0 a0 0c d0 	rcall	8000d0bc <__avr32_f64_sub>
8000b720:	fa eb 00 28 	st.d	sp[40],r10
8000b724:	fa ea 00 08 	ld.d	r10,sp[8]
8000b728:	e0 a0 0e 22 	rcall	8000d36c <__avr32_f64_to_s32>
8000b72c:	51 6c       	stdsp	sp[0x58],r12
8000b72e:	e0 a0 0e 36 	rcall	8000d39a <__avr32_s32_to_f64>
8000b732:	14 98       	mov	r8,r10
8000b734:	16 99       	mov	r9,r11
8000b736:	fa ea 00 08 	ld.d	r10,sp[8]
8000b73a:	e0 a0 0c c1 	rcall	8000d0bc <__avr32_f64_sub>
8000b73e:	fa eb 00 08 	st.d	sp[8],r10
8000b742:	41 68       	lddsp	r8,sp[0x58]
8000b744:	2d 08       	sub	r8,-48
8000b746:	0a c8       	st.b	r5++,r8
8000b748:	41 39       	lddsp	r9,sp[0x4c]
8000b74a:	2f f9       	sub	r9,-1
8000b74c:	51 39       	stdsp	sp[0x4c],r9
8000b74e:	fa e8 00 28 	ld.d	r8,sp[40]
8000b752:	e0 a0 0e db 	rcall	8000d508 <__avr32_f64_cmp_lt>
8000b756:	e0 81 03 39 	brne	8000bdc8 <_dtoa_r+0xbb4>
8000b75a:	fa e8 00 08 	ld.d	r8,sp[8]
8000b75e:	30 0a       	mov	r10,0
8000b760:	fc 1b 3f f0 	movh	r11,0x3ff0
8000b764:	e0 a0 0c ac 	rcall	8000d0bc <__avr32_f64_sub>
8000b768:	fa e8 00 28 	ld.d	r8,sp[40]
8000b76c:	e0 a0 0e ce 	rcall	8000d508 <__avr32_f64_cmp_lt>
8000b770:	fa ea 00 28 	ld.d	r10,sp[40]
8000b774:	30 08       	mov	r8,0
8000b776:	fc 19 40 24 	movh	r9,0x4024
8000b77a:	e0 81 00 da 	brne	8000b92e <_dtoa_r+0x71a>
8000b77e:	41 3c       	lddsp	r12,sp[0x4c]
8000b780:	08 3c       	cp.w	r12,r4
8000b782:	c5 f4       	brge	8000b840 <_dtoa_r+0x62c>
8000b784:	e0 a0 0b b0 	rcall	8000cee4 <__avr32_f64_mul>
8000b788:	30 08       	mov	r8,0
8000b78a:	fa eb 00 28 	st.d	sp[40],r10
8000b78e:	fc 19 40 24 	movh	r9,0x4024
8000b792:	fa ea 00 08 	ld.d	r10,sp[8]
8000b796:	e0 a0 0b a7 	rcall	8000cee4 <__avr32_f64_mul>
8000b79a:	fa eb 00 08 	st.d	sp[8],r10
8000b79e:	cc 3b       	rjmp	8000b724 <_dtoa_r+0x510>
8000b7a0:	40 85       	lddsp	r5,sp[0x20]
8000b7a2:	08 05       	add	r5,r4
8000b7a4:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000b7a8:	51 35       	stdsp	sp[0x4c],r5
8000b7aa:	fa e8 00 28 	ld.d	r8,sp[40]
8000b7ae:	40 85       	lddsp	r5,sp[0x20]
8000b7b0:	e0 a0 0b 9a 	rcall	8000cee4 <__avr32_f64_mul>
8000b7b4:	fa eb 00 28 	st.d	sp[40],r10
8000b7b8:	fa ea 00 08 	ld.d	r10,sp[8]
8000b7bc:	e0 a0 0d d8 	rcall	8000d36c <__avr32_f64_to_s32>
8000b7c0:	51 6c       	stdsp	sp[0x58],r12
8000b7c2:	e0 a0 0d ec 	rcall	8000d39a <__avr32_s32_to_f64>
8000b7c6:	14 98       	mov	r8,r10
8000b7c8:	16 99       	mov	r9,r11
8000b7ca:	fa ea 00 08 	ld.d	r10,sp[8]
8000b7ce:	e0 a0 0c 77 	rcall	8000d0bc <__avr32_f64_sub>
8000b7d2:	fa eb 00 08 	st.d	sp[8],r10
8000b7d6:	41 68       	lddsp	r8,sp[0x58]
8000b7d8:	2d 08       	sub	r8,-48
8000b7da:	0a c8       	st.b	r5++,r8
8000b7dc:	41 3c       	lddsp	r12,sp[0x4c]
8000b7de:	18 35       	cp.w	r5,r12
8000b7e0:	c2 81       	brne	8000b830 <_dtoa_r+0x61c>
8000b7e2:	30 08       	mov	r8,0
8000b7e4:	fc 19 3f e0 	movh	r9,0x3fe0
8000b7e8:	fa ea 00 28 	ld.d	r10,sp[40]
8000b7ec:	e0 a0 0d 36 	rcall	8000d258 <__avr32_f64_add>
8000b7f0:	40 85       	lddsp	r5,sp[0x20]
8000b7f2:	fa e8 00 08 	ld.d	r8,sp[8]
8000b7f6:	08 05       	add	r5,r4
8000b7f8:	e0 a0 0e 88 	rcall	8000d508 <__avr32_f64_cmp_lt>
8000b7fc:	e0 81 00 99 	brne	8000b92e <_dtoa_r+0x71a>
8000b800:	fa e8 00 28 	ld.d	r8,sp[40]
8000b804:	30 0a       	mov	r10,0
8000b806:	fc 1b 3f e0 	movh	r11,0x3fe0
8000b80a:	e0 a0 0c 59 	rcall	8000d0bc <__avr32_f64_sub>
8000b80e:	14 98       	mov	r8,r10
8000b810:	16 99       	mov	r9,r11
8000b812:	fa ea 00 08 	ld.d	r10,sp[8]
8000b816:	e0 a0 0e 79 	rcall	8000d508 <__avr32_f64_cmp_lt>
8000b81a:	c1 30       	breq	8000b840 <_dtoa_r+0x62c>
8000b81c:	33 09       	mov	r9,48
8000b81e:	0a 98       	mov	r8,r5
8000b820:	11 7a       	ld.ub	r10,--r8
8000b822:	f2 0a 18 00 	cp.b	r10,r9
8000b826:	e0 81 02 d1 	brne	8000bdc8 <_dtoa_r+0xbb4>
8000b82a:	10 95       	mov	r5,r8
8000b82c:	cf 9b       	rjmp	8000b81e <_dtoa_r+0x60a>
8000b82e:	d7 03       	nop
8000b830:	30 08       	mov	r8,0
8000b832:	fc 19 40 24 	movh	r9,0x4024
8000b836:	e0 a0 0b 57 	rcall	8000cee4 <__avr32_f64_mul>
8000b83a:	fa eb 00 08 	st.d	sp[8],r10
8000b83e:	cb db       	rjmp	8000b7b8 <_dtoa_r+0x5a4>
8000b840:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b844:	fa eb 00 08 	st.d	sp[8],r10
8000b848:	58 e6       	cp.w	r6,14
8000b84a:	5f ab       	srle	r11
8000b84c:	41 8a       	lddsp	r10,sp[0x60]
8000b84e:	30 08       	mov	r8,0
8000b850:	f4 09 11 ff 	rsub	r9,r10,-1
8000b854:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000b858:	f0 09 18 00 	cp.b	r9,r8
8000b85c:	e0 80 00 82 	breq	8000b960 <_dtoa_r+0x74c>
8000b860:	40 ea       	lddsp	r10,sp[0x38]
8000b862:	58 01       	cp.w	r1,0
8000b864:	5f a9       	srle	r9
8000b866:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000b86a:	fe ca c3 1a 	sub	r10,pc,-15590
8000b86e:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000b872:	fa e5 00 10 	st.d	sp[16],r4
8000b876:	f0 09 18 00 	cp.b	r9,r8
8000b87a:	c1 40       	breq	8000b8a2 <_dtoa_r+0x68e>
8000b87c:	58 01       	cp.w	r1,0
8000b87e:	e0 81 01 77 	brne	8000bb6c <_dtoa_r+0x958>
8000b882:	30 08       	mov	r8,0
8000b884:	fc 19 40 14 	movh	r9,0x4014
8000b888:	08 9a       	mov	r10,r4
8000b88a:	0a 9b       	mov	r11,r5
8000b88c:	e0 a0 0b 2c 	rcall	8000cee4 <__avr32_f64_mul>
8000b890:	fa e8 00 08 	ld.d	r8,sp[8]
8000b894:	e0 a0 0e 06 	rcall	8000d4a0 <__avr32_f64_cmp_ge>
8000b898:	e0 81 01 6a 	brne	8000bb6c <_dtoa_r+0x958>
8000b89c:	02 92       	mov	r2,r1
8000b89e:	e0 8f 01 72 	bral	8000bb82 <_dtoa_r+0x96e>
8000b8a2:	40 85       	lddsp	r5,sp[0x20]
8000b8a4:	30 14       	mov	r4,1
8000b8a6:	fa e8 00 10 	ld.d	r8,sp[16]
8000b8aa:	fa ea 00 08 	ld.d	r10,sp[8]
8000b8ae:	e0 a0 0e 61 	rcall	8000d570 <__avr32_f64_div>
8000b8b2:	e0 a0 0d 5d 	rcall	8000d36c <__avr32_f64_to_s32>
8000b8b6:	18 92       	mov	r2,r12
8000b8b8:	e0 a0 0d 71 	rcall	8000d39a <__avr32_s32_to_f64>
8000b8bc:	fa e8 00 10 	ld.d	r8,sp[16]
8000b8c0:	e0 a0 0b 12 	rcall	8000cee4 <__avr32_f64_mul>
8000b8c4:	14 98       	mov	r8,r10
8000b8c6:	16 99       	mov	r9,r11
8000b8c8:	fa ea 00 08 	ld.d	r10,sp[8]
8000b8cc:	e0 a0 0b f8 	rcall	8000d0bc <__avr32_f64_sub>
8000b8d0:	fa eb 00 08 	st.d	sp[8],r10
8000b8d4:	e4 c8 ff d0 	sub	r8,r2,-48
8000b8d8:	0a c8       	st.b	r5++,r8
8000b8da:	fc 19 40 24 	movh	r9,0x4024
8000b8de:	30 08       	mov	r8,0
8000b8e0:	02 34       	cp.w	r4,r1
8000b8e2:	c3 31       	brne	8000b948 <_dtoa_r+0x734>
8000b8e4:	fa e8 00 08 	ld.d	r8,sp[8]
8000b8e8:	e0 a0 0c b8 	rcall	8000d258 <__avr32_f64_add>
8000b8ec:	16 91       	mov	r1,r11
8000b8ee:	14 90       	mov	r0,r10
8000b8f0:	14 98       	mov	r8,r10
8000b8f2:	02 99       	mov	r9,r1
8000b8f4:	fa ea 00 10 	ld.d	r10,sp[16]
8000b8f8:	e0 a0 0e 08 	rcall	8000d508 <__avr32_f64_cmp_lt>
8000b8fc:	c1 a1       	brne	8000b930 <_dtoa_r+0x71c>
8000b8fe:	fa e8 00 10 	ld.d	r8,sp[16]
8000b902:	00 9a       	mov	r10,r0
8000b904:	02 9b       	mov	r11,r1
8000b906:	e0 a0 0d ba 	rcall	8000d47a <__avr32_f64_cmp_eq>
8000b90a:	e0 80 02 5e 	breq	8000bdc6 <_dtoa_r+0xbb2>
8000b90e:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000b912:	c0 f1       	brne	8000b930 <_dtoa_r+0x71c>
8000b914:	e0 8f 02 59 	bral	8000bdc6 <_dtoa_r+0xbb2>
8000b918:	40 8a       	lddsp	r10,sp[0x20]
8000b91a:	14 38       	cp.w	r8,r10
8000b91c:	c0 30       	breq	8000b922 <_dtoa_r+0x70e>
8000b91e:	10 95       	mov	r5,r8
8000b920:	c0 98       	rjmp	8000b932 <_dtoa_r+0x71e>
8000b922:	33 08       	mov	r8,48
8000b924:	40 89       	lddsp	r9,sp[0x20]
8000b926:	2f f6       	sub	r6,-1
8000b928:	b2 88       	st.b	r9[0x0],r8
8000b92a:	40 88       	lddsp	r8,sp[0x20]
8000b92c:	c0 88       	rjmp	8000b93c <_dtoa_r+0x728>
8000b92e:	40 66       	lddsp	r6,sp[0x18]
8000b930:	33 99       	mov	r9,57
8000b932:	0a 98       	mov	r8,r5
8000b934:	11 7a       	ld.ub	r10,--r8
8000b936:	f2 0a 18 00 	cp.b	r10,r9
8000b93a:	ce f0       	breq	8000b918 <_dtoa_r+0x704>
8000b93c:	50 66       	stdsp	sp[0x18],r6
8000b93e:	11 89       	ld.ub	r9,r8[0x0]
8000b940:	2f f9       	sub	r9,-1
8000b942:	b0 89       	st.b	r8[0x0],r9
8000b944:	e0 8f 02 42 	bral	8000bdc8 <_dtoa_r+0xbb4>
8000b948:	e0 a0 0a ce 	rcall	8000cee4 <__avr32_f64_mul>
8000b94c:	2f f4       	sub	r4,-1
8000b94e:	fa eb 00 08 	st.d	sp[8],r10
8000b952:	30 08       	mov	r8,0
8000b954:	30 09       	mov	r9,0
8000b956:	e0 a0 0d 92 	rcall	8000d47a <__avr32_f64_cmp_eq>
8000b95a:	ca 60       	breq	8000b8a6 <_dtoa_r+0x692>
8000b95c:	e0 8f 02 35 	bral	8000bdc6 <_dtoa_r+0xbb2>
8000b960:	40 d8       	lddsp	r8,sp[0x34]
8000b962:	58 08       	cp.w	r8,0
8000b964:	c0 51       	brne	8000b96e <_dtoa_r+0x75a>
8000b966:	04 98       	mov	r8,r2
8000b968:	00 95       	mov	r5,r0
8000b96a:	40 d4       	lddsp	r4,sp[0x34]
8000b96c:	c3 78       	rjmp	8000b9da <_dtoa_r+0x7c6>
8000b96e:	40 c5       	lddsp	r5,sp[0x30]
8000b970:	58 15       	cp.w	r5,1
8000b972:	e0 89 00 0f 	brgt	8000b990 <_dtoa_r+0x77c>
8000b976:	41 74       	lddsp	r4,sp[0x5c]
8000b978:	58 04       	cp.w	r4,0
8000b97a:	c0 40       	breq	8000b982 <_dtoa_r+0x76e>
8000b97c:	f4 c9 fb cd 	sub	r9,r10,-1075
8000b980:	c0 48       	rjmp	8000b988 <_dtoa_r+0x774>
8000b982:	41 99       	lddsp	r9,sp[0x64]
8000b984:	f2 09 11 36 	rsub	r9,r9,54
8000b988:	04 98       	mov	r8,r2
8000b98a:	00 95       	mov	r5,r0
8000b98c:	c1 c8       	rjmp	8000b9c4 <_dtoa_r+0x7b0>
8000b98e:	d7 03       	nop
8000b990:	e2 c8 00 01 	sub	r8,r1,1
8000b994:	58 01       	cp.w	r1,0
8000b996:	e0 05 17 40 	movge	r5,r0
8000b99a:	e2 09 17 40 	movge	r9,r1
8000b99e:	e1 d1 e5 15 	sublt	r5,r0,r1
8000b9a2:	f9 b9 05 00 	movlt	r9,0
8000b9a6:	10 32       	cp.w	r2,r8
8000b9a8:	e5 d8 e4 18 	subge	r8,r2,r8
8000b9ac:	f1 d2 e5 18 	sublt	r8,r8,r2
8000b9b0:	e5 d8 e5 02 	addlt	r2,r2,r8
8000b9b4:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000b9b8:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000b9bc:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000b9c0:	f9 b8 05 00 	movlt	r8,0
8000b9c4:	40 4b       	lddsp	r11,sp[0x10]
8000b9c6:	12 0b       	add	r11,r9
8000b9c8:	50 08       	stdsp	sp[0x0],r8
8000b9ca:	50 4b       	stdsp	sp[0x10],r11
8000b9cc:	12 00       	add	r0,r9
8000b9ce:	30 1b       	mov	r11,1
8000b9d0:	0e 9c       	mov	r12,r7
8000b9d2:	e0 a0 08 a7 	rcall	8000cb20 <__i2b>
8000b9d6:	40 08       	lddsp	r8,sp[0x0]
8000b9d8:	18 94       	mov	r4,r12
8000b9da:	40 4a       	lddsp	r10,sp[0x10]
8000b9dc:	58 05       	cp.w	r5,0
8000b9de:	5f 99       	srgt	r9
8000b9e0:	58 0a       	cp.w	r10,0
8000b9e2:	5f 9a       	srgt	r10
8000b9e4:	f5 e9 00 09 	and	r9,r10,r9
8000b9e8:	c0 80       	breq	8000b9f8 <_dtoa_r+0x7e4>
8000b9ea:	40 4c       	lddsp	r12,sp[0x10]
8000b9ec:	f8 05 0d 49 	min	r9,r12,r5
8000b9f0:	12 1c       	sub	r12,r9
8000b9f2:	12 10       	sub	r0,r9
8000b9f4:	50 4c       	stdsp	sp[0x10],r12
8000b9f6:	12 15       	sub	r5,r9
8000b9f8:	58 02       	cp.w	r2,0
8000b9fa:	e0 8a 00 27 	brle	8000ba48 <_dtoa_r+0x834>
8000b9fe:	40 db       	lddsp	r11,sp[0x34]
8000ba00:	58 0b       	cp.w	r11,0
8000ba02:	c1 d0       	breq	8000ba3c <_dtoa_r+0x828>
8000ba04:	58 08       	cp.w	r8,0
8000ba06:	e0 8a 00 17 	brle	8000ba34 <_dtoa_r+0x820>
8000ba0a:	10 9a       	mov	r10,r8
8000ba0c:	50 08       	stdsp	sp[0x0],r8
8000ba0e:	08 9b       	mov	r11,r4
8000ba10:	0e 9c       	mov	r12,r7
8000ba12:	e0 a0 08 cd 	rcall	8000cbac <__pow5mult>
8000ba16:	06 9a       	mov	r10,r3
8000ba18:	18 9b       	mov	r11,r12
8000ba1a:	18 94       	mov	r4,r12
8000ba1c:	0e 9c       	mov	r12,r7
8000ba1e:	e0 a0 08 01 	rcall	8000ca20 <__multiply>
8000ba22:	18 99       	mov	r9,r12
8000ba24:	06 9b       	mov	r11,r3
8000ba26:	50 19       	stdsp	sp[0x4],r9
8000ba28:	0e 9c       	mov	r12,r7
8000ba2a:	e0 a0 06 ad 	rcall	8000c784 <_Bfree>
8000ba2e:	40 19       	lddsp	r9,sp[0x4]
8000ba30:	40 08       	lddsp	r8,sp[0x0]
8000ba32:	12 93       	mov	r3,r9
8000ba34:	e4 08 01 0a 	sub	r10,r2,r8
8000ba38:	c0 80       	breq	8000ba48 <_dtoa_r+0x834>
8000ba3a:	c0 28       	rjmp	8000ba3e <_dtoa_r+0x82a>
8000ba3c:	04 9a       	mov	r10,r2
8000ba3e:	06 9b       	mov	r11,r3
8000ba40:	0e 9c       	mov	r12,r7
8000ba42:	e0 a0 08 b5 	rcall	8000cbac <__pow5mult>
8000ba46:	18 93       	mov	r3,r12
8000ba48:	30 1b       	mov	r11,1
8000ba4a:	0e 9c       	mov	r12,r7
8000ba4c:	e0 a0 08 6a 	rcall	8000cb20 <__i2b>
8000ba50:	41 1a       	lddsp	r10,sp[0x44]
8000ba52:	18 92       	mov	r2,r12
8000ba54:	58 0a       	cp.w	r10,0
8000ba56:	e0 8a 00 07 	brle	8000ba64 <_dtoa_r+0x850>
8000ba5a:	18 9b       	mov	r11,r12
8000ba5c:	0e 9c       	mov	r12,r7
8000ba5e:	e0 a0 08 a7 	rcall	8000cbac <__pow5mult>
8000ba62:	18 92       	mov	r2,r12
8000ba64:	40 c9       	lddsp	r9,sp[0x30]
8000ba66:	58 19       	cp.w	r9,1
8000ba68:	e0 89 00 14 	brgt	8000ba90 <_dtoa_r+0x87c>
8000ba6c:	40 38       	lddsp	r8,sp[0xc]
8000ba6e:	58 08       	cp.w	r8,0
8000ba70:	c1 01       	brne	8000ba90 <_dtoa_r+0x87c>
8000ba72:	40 29       	lddsp	r9,sp[0x8]
8000ba74:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000ba78:	c0 c1       	brne	8000ba90 <_dtoa_r+0x87c>
8000ba7a:	12 98       	mov	r8,r9
8000ba7c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000ba80:	c0 80       	breq	8000ba90 <_dtoa_r+0x87c>
8000ba82:	40 4c       	lddsp	r12,sp[0x10]
8000ba84:	30 1b       	mov	r11,1
8000ba86:	2f fc       	sub	r12,-1
8000ba88:	2f f0       	sub	r0,-1
8000ba8a:	50 4c       	stdsp	sp[0x10],r12
8000ba8c:	50 6b       	stdsp	sp[0x18],r11
8000ba8e:	c0 38       	rjmp	8000ba94 <_dtoa_r+0x880>
8000ba90:	30 0a       	mov	r10,0
8000ba92:	50 6a       	stdsp	sp[0x18],r10
8000ba94:	41 19       	lddsp	r9,sp[0x44]
8000ba96:	58 09       	cp.w	r9,0
8000ba98:	c0 31       	brne	8000ba9e <_dtoa_r+0x88a>
8000ba9a:	30 1c       	mov	r12,1
8000ba9c:	c0 98       	rjmp	8000baae <_dtoa_r+0x89a>
8000ba9e:	64 48       	ld.w	r8,r2[0x10]
8000baa0:	2f c8       	sub	r8,-4
8000baa2:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000baa6:	e0 a0 05 df 	rcall	8000c664 <__hi0bits>
8000baaa:	f8 0c 11 20 	rsub	r12,r12,32
8000baae:	40 4b       	lddsp	r11,sp[0x10]
8000bab0:	f8 0b 00 08 	add	r8,r12,r11
8000bab4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000bab8:	c0 c0       	breq	8000bad0 <_dtoa_r+0x8bc>
8000baba:	f0 08 11 20 	rsub	r8,r8,32
8000babe:	58 48       	cp.w	r8,4
8000bac0:	e0 8a 00 06 	brle	8000bacc <_dtoa_r+0x8b8>
8000bac4:	20 48       	sub	r8,4
8000bac6:	10 0b       	add	r11,r8
8000bac8:	50 4b       	stdsp	sp[0x10],r11
8000baca:	c0 78       	rjmp	8000bad8 <_dtoa_r+0x8c4>
8000bacc:	58 48       	cp.w	r8,4
8000bace:	c0 70       	breq	8000badc <_dtoa_r+0x8c8>
8000bad0:	40 4a       	lddsp	r10,sp[0x10]
8000bad2:	2e 48       	sub	r8,-28
8000bad4:	10 0a       	add	r10,r8
8000bad6:	50 4a       	stdsp	sp[0x10],r10
8000bad8:	10 00       	add	r0,r8
8000bada:	10 05       	add	r5,r8
8000badc:	58 00       	cp.w	r0,0
8000bade:	e0 8a 00 08 	brle	8000baee <_dtoa_r+0x8da>
8000bae2:	06 9b       	mov	r11,r3
8000bae4:	00 9a       	mov	r10,r0
8000bae6:	0e 9c       	mov	r12,r7
8000bae8:	e0 a0 07 58 	rcall	8000c998 <__lshift>
8000baec:	18 93       	mov	r3,r12
8000baee:	40 49       	lddsp	r9,sp[0x10]
8000baf0:	58 09       	cp.w	r9,0
8000baf2:	e0 8a 00 08 	brle	8000bb02 <_dtoa_r+0x8ee>
8000baf6:	04 9b       	mov	r11,r2
8000baf8:	12 9a       	mov	r10,r9
8000bafa:	0e 9c       	mov	r12,r7
8000bafc:	e0 a0 07 4e 	rcall	8000c998 <__lshift>
8000bb00:	18 92       	mov	r2,r12
8000bb02:	41 48       	lddsp	r8,sp[0x50]
8000bb04:	58 08       	cp.w	r8,0
8000bb06:	c1 b0       	breq	8000bb3c <_dtoa_r+0x928>
8000bb08:	04 9b       	mov	r11,r2
8000bb0a:	06 9c       	mov	r12,r3
8000bb0c:	e0 a0 06 23 	rcall	8000c752 <__mcmp>
8000bb10:	c1 64       	brge	8000bb3c <_dtoa_r+0x928>
8000bb12:	06 9b       	mov	r11,r3
8000bb14:	30 09       	mov	r9,0
8000bb16:	30 aa       	mov	r10,10
8000bb18:	0e 9c       	mov	r12,r7
8000bb1a:	e0 a0 08 0b 	rcall	8000cb30 <__multadd>
8000bb1e:	20 16       	sub	r6,1
8000bb20:	18 93       	mov	r3,r12
8000bb22:	40 dc       	lddsp	r12,sp[0x34]
8000bb24:	58 0c       	cp.w	r12,0
8000bb26:	c0 31       	brne	8000bb2c <_dtoa_r+0x918>
8000bb28:	40 91       	lddsp	r1,sp[0x24]
8000bb2a:	c0 98       	rjmp	8000bb3c <_dtoa_r+0x928>
8000bb2c:	08 9b       	mov	r11,r4
8000bb2e:	40 91       	lddsp	r1,sp[0x24]
8000bb30:	30 09       	mov	r9,0
8000bb32:	30 aa       	mov	r10,10
8000bb34:	0e 9c       	mov	r12,r7
8000bb36:	e0 a0 07 fd 	rcall	8000cb30 <__multadd>
8000bb3a:	18 94       	mov	r4,r12
8000bb3c:	58 01       	cp.w	r1,0
8000bb3e:	5f a9       	srle	r9
8000bb40:	40 cb       	lddsp	r11,sp[0x30]
8000bb42:	58 2b       	cp.w	r11,2
8000bb44:	5f 98       	srgt	r8
8000bb46:	f3 e8 00 08 	and	r8,r9,r8
8000bb4a:	c2 50       	breq	8000bb94 <_dtoa_r+0x980>
8000bb4c:	58 01       	cp.w	r1,0
8000bb4e:	c1 11       	brne	8000bb70 <_dtoa_r+0x95c>
8000bb50:	04 9b       	mov	r11,r2
8000bb52:	02 99       	mov	r9,r1
8000bb54:	30 5a       	mov	r10,5
8000bb56:	0e 9c       	mov	r12,r7
8000bb58:	e0 a0 07 ec 	rcall	8000cb30 <__multadd>
8000bb5c:	18 92       	mov	r2,r12
8000bb5e:	18 9b       	mov	r11,r12
8000bb60:	06 9c       	mov	r12,r3
8000bb62:	e0 a0 05 f8 	rcall	8000c752 <__mcmp>
8000bb66:	e0 89 00 0f 	brgt	8000bb84 <_dtoa_r+0x970>
8000bb6a:	c0 38       	rjmp	8000bb70 <_dtoa_r+0x95c>
8000bb6c:	30 02       	mov	r2,0
8000bb6e:	04 94       	mov	r4,r2
8000bb70:	40 ea       	lddsp	r10,sp[0x38]
8000bb72:	30 09       	mov	r9,0
8000bb74:	5c da       	com	r10
8000bb76:	40 85       	lddsp	r5,sp[0x20]
8000bb78:	50 6a       	stdsp	sp[0x18],r10
8000bb7a:	50 49       	stdsp	sp[0x10],r9
8000bb7c:	c0 f9       	rjmp	8000bd9a <_dtoa_r+0xb86>
8000bb7e:	08 92       	mov	r2,r4
8000bb80:	40 66       	lddsp	r6,sp[0x18]
8000bb82:	04 94       	mov	r4,r2
8000bb84:	2f f6       	sub	r6,-1
8000bb86:	50 66       	stdsp	sp[0x18],r6
8000bb88:	33 18       	mov	r8,49
8000bb8a:	40 85       	lddsp	r5,sp[0x20]
8000bb8c:	0a c8       	st.b	r5++,r8
8000bb8e:	30 08       	mov	r8,0
8000bb90:	50 48       	stdsp	sp[0x10],r8
8000bb92:	c0 49       	rjmp	8000bd9a <_dtoa_r+0xb86>
8000bb94:	40 dc       	lddsp	r12,sp[0x34]
8000bb96:	58 0c       	cp.w	r12,0
8000bb98:	e0 80 00 b5 	breq	8000bd02 <_dtoa_r+0xaee>
8000bb9c:	58 05       	cp.w	r5,0
8000bb9e:	e0 8a 00 08 	brle	8000bbae <_dtoa_r+0x99a>
8000bba2:	08 9b       	mov	r11,r4
8000bba4:	0a 9a       	mov	r10,r5
8000bba6:	0e 9c       	mov	r12,r7
8000bba8:	e0 a0 06 f8 	rcall	8000c998 <__lshift>
8000bbac:	18 94       	mov	r4,r12
8000bbae:	40 6b       	lddsp	r11,sp[0x18]
8000bbb0:	58 0b       	cp.w	r11,0
8000bbb2:	c0 31       	brne	8000bbb8 <_dtoa_r+0x9a4>
8000bbb4:	08 9c       	mov	r12,r4
8000bbb6:	c1 38       	rjmp	8000bbdc <_dtoa_r+0x9c8>
8000bbb8:	68 1b       	ld.w	r11,r4[0x4]
8000bbba:	0e 9c       	mov	r12,r7
8000bbbc:	e0 a0 05 fe 	rcall	8000c7b8 <_Balloc>
8000bbc0:	68 4a       	ld.w	r10,r4[0x10]
8000bbc2:	18 95       	mov	r5,r12
8000bbc4:	e8 cb ff f4 	sub	r11,r4,-12
8000bbc8:	2f ea       	sub	r10,-2
8000bbca:	2f 4c       	sub	r12,-12
8000bbcc:	a3 6a       	lsl	r10,0x2
8000bbce:	fe b0 e6 50 	rcall	8000886e <memcpy>
8000bbd2:	0a 9b       	mov	r11,r5
8000bbd4:	30 1a       	mov	r10,1
8000bbd6:	0e 9c       	mov	r12,r7
8000bbd8:	e0 a0 06 e0 	rcall	8000c998 <__lshift>
8000bbdc:	50 44       	stdsp	sp[0x10],r4
8000bbde:	40 3a       	lddsp	r10,sp[0xc]
8000bbe0:	30 19       	mov	r9,1
8000bbe2:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000bbe6:	18 94       	mov	r4,r12
8000bbe8:	50 da       	stdsp	sp[0x34],r10
8000bbea:	40 85       	lddsp	r5,sp[0x20]
8000bbec:	50 99       	stdsp	sp[0x24],r9
8000bbee:	50 26       	stdsp	sp[0x8],r6
8000bbf0:	50 e1       	stdsp	sp[0x38],r1
8000bbf2:	04 9b       	mov	r11,r2
8000bbf4:	06 9c       	mov	r12,r3
8000bbf6:	fe b0 fa 7f 	rcall	8000b0f4 <quorem>
8000bbfa:	40 4b       	lddsp	r11,sp[0x10]
8000bbfc:	f8 c0 ff d0 	sub	r0,r12,-48
8000bc00:	06 9c       	mov	r12,r3
8000bc02:	e0 a0 05 a8 	rcall	8000c752 <__mcmp>
8000bc06:	08 9a       	mov	r10,r4
8000bc08:	50 6c       	stdsp	sp[0x18],r12
8000bc0a:	04 9b       	mov	r11,r2
8000bc0c:	0e 9c       	mov	r12,r7
8000bc0e:	e0 a0 06 5d 	rcall	8000c8c8 <__mdiff>
8000bc12:	18 91       	mov	r1,r12
8000bc14:	78 38       	ld.w	r8,r12[0xc]
8000bc16:	58 08       	cp.w	r8,0
8000bc18:	c0 30       	breq	8000bc1e <_dtoa_r+0xa0a>
8000bc1a:	30 16       	mov	r6,1
8000bc1c:	c0 68       	rjmp	8000bc28 <_dtoa_r+0xa14>
8000bc1e:	18 9b       	mov	r11,r12
8000bc20:	06 9c       	mov	r12,r3
8000bc22:	e0 a0 05 98 	rcall	8000c752 <__mcmp>
8000bc26:	18 96       	mov	r6,r12
8000bc28:	0e 9c       	mov	r12,r7
8000bc2a:	02 9b       	mov	r11,r1
8000bc2c:	e0 a0 05 ac 	rcall	8000c784 <_Bfree>
8000bc30:	40 cc       	lddsp	r12,sp[0x30]
8000bc32:	ed ec 10 08 	or	r8,r6,r12
8000bc36:	c0 d1       	brne	8000bc50 <_dtoa_r+0xa3c>
8000bc38:	40 db       	lddsp	r11,sp[0x34]
8000bc3a:	58 0b       	cp.w	r11,0
8000bc3c:	c0 a1       	brne	8000bc50 <_dtoa_r+0xa3c>
8000bc3e:	40 26       	lddsp	r6,sp[0x8]
8000bc40:	e0 40 00 39 	cp.w	r0,57
8000bc44:	c3 00       	breq	8000bca4 <_dtoa_r+0xa90>
8000bc46:	40 6a       	lddsp	r10,sp[0x18]
8000bc48:	58 0a       	cp.w	r10,0
8000bc4a:	e0 89 00 24 	brgt	8000bc92 <_dtoa_r+0xa7e>
8000bc4e:	c2 f8       	rjmp	8000bcac <_dtoa_r+0xa98>
8000bc50:	40 69       	lddsp	r9,sp[0x18]
8000bc52:	58 09       	cp.w	r9,0
8000bc54:	c0 85       	brlt	8000bc64 <_dtoa_r+0xa50>
8000bc56:	12 98       	mov	r8,r9
8000bc58:	40 cc       	lddsp	r12,sp[0x30]
8000bc5a:	18 48       	or	r8,r12
8000bc5c:	c1 d1       	brne	8000bc96 <_dtoa_r+0xa82>
8000bc5e:	40 db       	lddsp	r11,sp[0x34]
8000bc60:	58 0b       	cp.w	r11,0
8000bc62:	c1 a1       	brne	8000bc96 <_dtoa_r+0xa82>
8000bc64:	0c 99       	mov	r9,r6
8000bc66:	40 26       	lddsp	r6,sp[0x8]
8000bc68:	58 09       	cp.w	r9,0
8000bc6a:	e0 8a 00 21 	brle	8000bcac <_dtoa_r+0xa98>
8000bc6e:	06 9b       	mov	r11,r3
8000bc70:	30 1a       	mov	r10,1
8000bc72:	0e 9c       	mov	r12,r7
8000bc74:	e0 a0 06 92 	rcall	8000c998 <__lshift>
8000bc78:	04 9b       	mov	r11,r2
8000bc7a:	18 93       	mov	r3,r12
8000bc7c:	e0 a0 05 6b 	rcall	8000c752 <__mcmp>
8000bc80:	e0 89 00 06 	brgt	8000bc8c <_dtoa_r+0xa78>
8000bc84:	c1 41       	brne	8000bcac <_dtoa_r+0xa98>
8000bc86:	ed b0 00 00 	bld	r0,0x0
8000bc8a:	c1 11       	brne	8000bcac <_dtoa_r+0xa98>
8000bc8c:	e0 40 00 39 	cp.w	r0,57
8000bc90:	c0 a0       	breq	8000bca4 <_dtoa_r+0xa90>
8000bc92:	2f f0       	sub	r0,-1
8000bc94:	c0 c8       	rjmp	8000bcac <_dtoa_r+0xa98>
8000bc96:	58 06       	cp.w	r6,0
8000bc98:	e0 8a 00 0c 	brle	8000bcb0 <_dtoa_r+0xa9c>
8000bc9c:	40 26       	lddsp	r6,sp[0x8]
8000bc9e:	e0 40 00 39 	cp.w	r0,57
8000bca2:	c0 41       	brne	8000bcaa <_dtoa_r+0xa96>
8000bca4:	33 98       	mov	r8,57
8000bca6:	0a c8       	st.b	r5++,r8
8000bca8:	c6 78       	rjmp	8000bd76 <_dtoa_r+0xb62>
8000bcaa:	2f f0       	sub	r0,-1
8000bcac:	0a c0       	st.b	r5++,r0
8000bcae:	c7 58       	rjmp	8000bd98 <_dtoa_r+0xb84>
8000bcb0:	0a c0       	st.b	r5++,r0
8000bcb2:	40 9a       	lddsp	r10,sp[0x24]
8000bcb4:	40 e9       	lddsp	r9,sp[0x38]
8000bcb6:	12 3a       	cp.w	r10,r9
8000bcb8:	c4 30       	breq	8000bd3e <_dtoa_r+0xb2a>
8000bcba:	06 9b       	mov	r11,r3
8000bcbc:	30 09       	mov	r9,0
8000bcbe:	30 aa       	mov	r10,10
8000bcc0:	0e 9c       	mov	r12,r7
8000bcc2:	e0 a0 07 37 	rcall	8000cb30 <__multadd>
8000bcc6:	40 48       	lddsp	r8,sp[0x10]
8000bcc8:	18 93       	mov	r3,r12
8000bcca:	08 38       	cp.w	r8,r4
8000bccc:	c0 91       	brne	8000bcde <_dtoa_r+0xaca>
8000bcce:	10 9b       	mov	r11,r8
8000bcd0:	30 09       	mov	r9,0
8000bcd2:	30 aa       	mov	r10,10
8000bcd4:	0e 9c       	mov	r12,r7
8000bcd6:	e0 a0 07 2d 	rcall	8000cb30 <__multadd>
8000bcda:	50 4c       	stdsp	sp[0x10],r12
8000bcdc:	c0 e8       	rjmp	8000bcf8 <_dtoa_r+0xae4>
8000bcde:	40 4b       	lddsp	r11,sp[0x10]
8000bce0:	30 09       	mov	r9,0
8000bce2:	30 aa       	mov	r10,10
8000bce4:	0e 9c       	mov	r12,r7
8000bce6:	e0 a0 07 25 	rcall	8000cb30 <__multadd>
8000bcea:	08 9b       	mov	r11,r4
8000bcec:	50 4c       	stdsp	sp[0x10],r12
8000bcee:	30 09       	mov	r9,0
8000bcf0:	30 aa       	mov	r10,10
8000bcf2:	0e 9c       	mov	r12,r7
8000bcf4:	e0 a0 07 1e 	rcall	8000cb30 <__multadd>
8000bcf8:	18 94       	mov	r4,r12
8000bcfa:	40 9c       	lddsp	r12,sp[0x24]
8000bcfc:	2f fc       	sub	r12,-1
8000bcfe:	50 9c       	stdsp	sp[0x24],r12
8000bd00:	c7 9b       	rjmp	8000bbf2 <_dtoa_r+0x9de>
8000bd02:	30 18       	mov	r8,1
8000bd04:	06 90       	mov	r0,r3
8000bd06:	40 85       	lddsp	r5,sp[0x20]
8000bd08:	08 93       	mov	r3,r4
8000bd0a:	0c 94       	mov	r4,r6
8000bd0c:	10 96       	mov	r6,r8
8000bd0e:	04 9b       	mov	r11,r2
8000bd10:	00 9c       	mov	r12,r0
8000bd12:	fe b0 f9 f1 	rcall	8000b0f4 <quorem>
8000bd16:	2d 0c       	sub	r12,-48
8000bd18:	0a cc       	st.b	r5++,r12
8000bd1a:	02 36       	cp.w	r6,r1
8000bd1c:	c0 a4       	brge	8000bd30 <_dtoa_r+0xb1c>
8000bd1e:	00 9b       	mov	r11,r0
8000bd20:	30 09       	mov	r9,0
8000bd22:	30 aa       	mov	r10,10
8000bd24:	0e 9c       	mov	r12,r7
8000bd26:	2f f6       	sub	r6,-1
8000bd28:	e0 a0 07 04 	rcall	8000cb30 <__multadd>
8000bd2c:	18 90       	mov	r0,r12
8000bd2e:	cf 0b       	rjmp	8000bd0e <_dtoa_r+0xafa>
8000bd30:	08 96       	mov	r6,r4
8000bd32:	30 0b       	mov	r11,0
8000bd34:	06 94       	mov	r4,r3
8000bd36:	50 4b       	stdsp	sp[0x10],r11
8000bd38:	00 93       	mov	r3,r0
8000bd3a:	18 90       	mov	r0,r12
8000bd3c:	c0 28       	rjmp	8000bd40 <_dtoa_r+0xb2c>
8000bd3e:	40 26       	lddsp	r6,sp[0x8]
8000bd40:	06 9b       	mov	r11,r3
8000bd42:	30 1a       	mov	r10,1
8000bd44:	0e 9c       	mov	r12,r7
8000bd46:	e0 a0 06 29 	rcall	8000c998 <__lshift>
8000bd4a:	04 9b       	mov	r11,r2
8000bd4c:	18 93       	mov	r3,r12
8000bd4e:	e0 a0 05 02 	rcall	8000c752 <__mcmp>
8000bd52:	e0 89 00 12 	brgt	8000bd76 <_dtoa_r+0xb62>
8000bd56:	c1 b1       	brne	8000bd8c <_dtoa_r+0xb78>
8000bd58:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000bd5c:	c0 d1       	brne	8000bd76 <_dtoa_r+0xb62>
8000bd5e:	c1 78       	rjmp	8000bd8c <_dtoa_r+0xb78>
8000bd60:	40 89       	lddsp	r9,sp[0x20]
8000bd62:	12 38       	cp.w	r8,r9
8000bd64:	c0 30       	breq	8000bd6a <_dtoa_r+0xb56>
8000bd66:	10 95       	mov	r5,r8
8000bd68:	c0 88       	rjmp	8000bd78 <_dtoa_r+0xb64>
8000bd6a:	2f f6       	sub	r6,-1
8000bd6c:	50 66       	stdsp	sp[0x18],r6
8000bd6e:	33 18       	mov	r8,49
8000bd70:	40 8c       	lddsp	r12,sp[0x20]
8000bd72:	b8 88       	st.b	r12[0x0],r8
8000bd74:	c1 38       	rjmp	8000bd9a <_dtoa_r+0xb86>
8000bd76:	33 9a       	mov	r10,57
8000bd78:	0a 98       	mov	r8,r5
8000bd7a:	11 79       	ld.ub	r9,--r8
8000bd7c:	f4 09 18 00 	cp.b	r9,r10
8000bd80:	cf 00       	breq	8000bd60 <_dtoa_r+0xb4c>
8000bd82:	2f f9       	sub	r9,-1
8000bd84:	b0 89       	st.b	r8[0x0],r9
8000bd86:	c0 98       	rjmp	8000bd98 <_dtoa_r+0xb84>
8000bd88:	10 95       	mov	r5,r8
8000bd8a:	c0 28       	rjmp	8000bd8e <_dtoa_r+0xb7a>
8000bd8c:	33 09       	mov	r9,48
8000bd8e:	0a 98       	mov	r8,r5
8000bd90:	11 7a       	ld.ub	r10,--r8
8000bd92:	f2 0a 18 00 	cp.b	r10,r9
8000bd96:	cf 90       	breq	8000bd88 <_dtoa_r+0xb74>
8000bd98:	50 66       	stdsp	sp[0x18],r6
8000bd9a:	04 9b       	mov	r11,r2
8000bd9c:	0e 9c       	mov	r12,r7
8000bd9e:	e0 a0 04 f3 	rcall	8000c784 <_Bfree>
8000bda2:	58 04       	cp.w	r4,0
8000bda4:	c1 20       	breq	8000bdc8 <_dtoa_r+0xbb4>
8000bda6:	40 4b       	lddsp	r11,sp[0x10]
8000bda8:	08 3b       	cp.w	r11,r4
8000bdaa:	5f 19       	srne	r9
8000bdac:	58 0b       	cp.w	r11,0
8000bdae:	5f 18       	srne	r8
8000bdb0:	f3 e8 00 08 	and	r8,r9,r8
8000bdb4:	c0 40       	breq	8000bdbc <_dtoa_r+0xba8>
8000bdb6:	0e 9c       	mov	r12,r7
8000bdb8:	e0 a0 04 e6 	rcall	8000c784 <_Bfree>
8000bdbc:	08 9b       	mov	r11,r4
8000bdbe:	0e 9c       	mov	r12,r7
8000bdc0:	e0 a0 04 e2 	rcall	8000c784 <_Bfree>
8000bdc4:	c0 28       	rjmp	8000bdc8 <_dtoa_r+0xbb4>
8000bdc6:	50 66       	stdsp	sp[0x18],r6
8000bdc8:	0e 9c       	mov	r12,r7
8000bdca:	06 9b       	mov	r11,r3
8000bdcc:	e0 a0 04 dc 	rcall	8000c784 <_Bfree>
8000bdd0:	30 08       	mov	r8,0
8000bdd2:	aa 88       	st.b	r5[0x0],r8
8000bdd4:	40 68       	lddsp	r8,sp[0x18]
8000bdd6:	41 5a       	lddsp	r10,sp[0x54]
8000bdd8:	2f f8       	sub	r8,-1
8000bdda:	41 29       	lddsp	r9,sp[0x48]
8000bddc:	95 08       	st.w	r10[0x0],r8
8000bdde:	40 8c       	lddsp	r12,sp[0x20]
8000bde0:	58 09       	cp.w	r9,0
8000bde2:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000bde6:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000bdea:	2e 6d       	sub	sp,-104
8000bdec:	d8 32       	popm	r0-r7,pc
8000bdee:	d7 03       	nop

8000bdf0 <__errno>:
8000bdf0:	e0 68 0a 54 	mov	r8,2644
8000bdf4:	70 0c       	ld.w	r12,r8[0x0]
8000bdf6:	2f 4c       	sub	r12,-12
8000bdf8:	5e fc       	retal	r12
8000bdfa:	d7 03       	nop

8000bdfc <_fflush_r>:
8000bdfc:	d4 21       	pushm	r4-r7,lr
8000bdfe:	16 97       	mov	r7,r11
8000be00:	18 96       	mov	r6,r12
8000be02:	76 48       	ld.w	r8,r11[0x10]
8000be04:	58 08       	cp.w	r8,0
8000be06:	c7 f0       	breq	8000bf04 <_fflush_r+0x108>
8000be08:	58 0c       	cp.w	r12,0
8000be0a:	c0 50       	breq	8000be14 <_fflush_r+0x18>
8000be0c:	78 68       	ld.w	r8,r12[0x18]
8000be0e:	58 08       	cp.w	r8,0
8000be10:	c0 21       	brne	8000be14 <_fflush_r+0x18>
8000be12:	cc dc       	rcall	8000bfac <__sinit>
8000be14:	fe c8 c9 74 	sub	r8,pc,-13964
8000be18:	10 37       	cp.w	r7,r8
8000be1a:	c0 31       	brne	8000be20 <_fflush_r+0x24>
8000be1c:	6c 07       	ld.w	r7,r6[0x0]
8000be1e:	c0 c8       	rjmp	8000be36 <_fflush_r+0x3a>
8000be20:	fe c8 c9 60 	sub	r8,pc,-13984
8000be24:	10 37       	cp.w	r7,r8
8000be26:	c0 31       	brne	8000be2c <_fflush_r+0x30>
8000be28:	6c 17       	ld.w	r7,r6[0x4]
8000be2a:	c0 68       	rjmp	8000be36 <_fflush_r+0x3a>
8000be2c:	fe c8 c9 4c 	sub	r8,pc,-14004
8000be30:	10 37       	cp.w	r7,r8
8000be32:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000be36:	8e 6a       	ld.sh	r10,r7[0xc]
8000be38:	14 98       	mov	r8,r10
8000be3a:	ed ba 00 03 	bld	r10,0x3
8000be3e:	c4 20       	breq	8000bec2 <_fflush_r+0xc6>
8000be40:	ab ba       	sbr	r10,0xb
8000be42:	ae 6a       	st.h	r7[0xc],r10
8000be44:	6e 18       	ld.w	r8,r7[0x4]
8000be46:	58 08       	cp.w	r8,0
8000be48:	e0 89 00 06 	brgt	8000be54 <_fflush_r+0x58>
8000be4c:	6f 08       	ld.w	r8,r7[0x40]
8000be4e:	58 08       	cp.w	r8,0
8000be50:	e0 8a 00 5a 	brle	8000bf04 <_fflush_r+0x108>
8000be54:	6e b8       	ld.w	r8,r7[0x2c]
8000be56:	58 08       	cp.w	r8,0
8000be58:	c5 60       	breq	8000bf04 <_fflush_r+0x108>
8000be5a:	e2 1a 10 00 	andl	r10,0x1000,COH
8000be5e:	c0 30       	breq	8000be64 <_fflush_r+0x68>
8000be60:	6f 55       	ld.w	r5,r7[0x54]
8000be62:	c0 f8       	rjmp	8000be80 <_fflush_r+0x84>
8000be64:	30 19       	mov	r9,1
8000be66:	6e 8b       	ld.w	r11,r7[0x20]
8000be68:	0c 9c       	mov	r12,r6
8000be6a:	5d 18       	icall	r8
8000be6c:	18 95       	mov	r5,r12
8000be6e:	5b fc       	cp.w	r12,-1
8000be70:	c0 81       	brne	8000be80 <_fflush_r+0x84>
8000be72:	6c 38       	ld.w	r8,r6[0xc]
8000be74:	59 d8       	cp.w	r8,29
8000be76:	c4 70       	breq	8000bf04 <_fflush_r+0x108>
8000be78:	8e 68       	ld.sh	r8,r7[0xc]
8000be7a:	a7 a8       	sbr	r8,0x6
8000be7c:	ae 68       	st.h	r7[0xc],r8
8000be7e:	d8 22       	popm	r4-r7,pc
8000be80:	8e 68       	ld.sh	r8,r7[0xc]
8000be82:	ed b8 00 02 	bld	r8,0x2
8000be86:	c0 91       	brne	8000be98 <_fflush_r+0x9c>
8000be88:	6e 18       	ld.w	r8,r7[0x4]
8000be8a:	10 15       	sub	r5,r8
8000be8c:	6e d8       	ld.w	r8,r7[0x34]
8000be8e:	58 08       	cp.w	r8,0
8000be90:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000be94:	eb d8 e1 15 	subne	r5,r5,r8
8000be98:	6e b8       	ld.w	r8,r7[0x2c]
8000be9a:	0c 9c       	mov	r12,r6
8000be9c:	30 09       	mov	r9,0
8000be9e:	0a 9a       	mov	r10,r5
8000bea0:	6e 8b       	ld.w	r11,r7[0x20]
8000bea2:	5d 18       	icall	r8
8000bea4:	8e 68       	ld.sh	r8,r7[0xc]
8000bea6:	0a 3c       	cp.w	r12,r5
8000bea8:	c2 61       	brne	8000bef4 <_fflush_r+0xf8>
8000beaa:	ab d8       	cbr	r8,0xb
8000beac:	30 0c       	mov	r12,0
8000beae:	6e 49       	ld.w	r9,r7[0x10]
8000beb0:	ae 68       	st.h	r7[0xc],r8
8000beb2:	8f 1c       	st.w	r7[0x4],r12
8000beb4:	8f 09       	st.w	r7[0x0],r9
8000beb6:	ed b8 00 0c 	bld	r8,0xc
8000beba:	c2 51       	brne	8000bf04 <_fflush_r+0x108>
8000bebc:	ef 45 00 54 	st.w	r7[84],r5
8000bec0:	d8 22       	popm	r4-r7,pc
8000bec2:	6e 45       	ld.w	r5,r7[0x10]
8000bec4:	58 05       	cp.w	r5,0
8000bec6:	c1 f0       	breq	8000bf04 <_fflush_r+0x108>
8000bec8:	6e 04       	ld.w	r4,r7[0x0]
8000beca:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000bece:	8f 05       	st.w	r7[0x0],r5
8000bed0:	f9 b8 01 00 	movne	r8,0
8000bed4:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000bed8:	0a 14       	sub	r4,r5
8000beda:	8f 28       	st.w	r7[0x8],r8
8000bedc:	c1 18       	rjmp	8000befe <_fflush_r+0x102>
8000bede:	08 99       	mov	r9,r4
8000bee0:	0a 9a       	mov	r10,r5
8000bee2:	6e a8       	ld.w	r8,r7[0x28]
8000bee4:	6e 8b       	ld.w	r11,r7[0x20]
8000bee6:	0c 9c       	mov	r12,r6
8000bee8:	5d 18       	icall	r8
8000beea:	18 14       	sub	r4,r12
8000beec:	58 0c       	cp.w	r12,0
8000beee:	e0 89 00 07 	brgt	8000befc <_fflush_r+0x100>
8000bef2:	8e 68       	ld.sh	r8,r7[0xc]
8000bef4:	a7 a8       	sbr	r8,0x6
8000bef6:	3f fc       	mov	r12,-1
8000bef8:	ae 68       	st.h	r7[0xc],r8
8000befa:	d8 22       	popm	r4-r7,pc
8000befc:	18 05       	add	r5,r12
8000befe:	58 04       	cp.w	r4,0
8000bf00:	fe 99 ff ef 	brgt	8000bede <_fflush_r+0xe2>
8000bf04:	d8 2a       	popm	r4-r7,pc,r12=0
8000bf06:	d7 03       	nop

8000bf08 <__sfp_lock_acquire>:
8000bf08:	5e fc       	retal	r12

8000bf0a <__sfp_lock_release>:
8000bf0a:	5e fc       	retal	r12

8000bf0c <_cleanup_r>:
8000bf0c:	d4 01       	pushm	lr
8000bf0e:	fe cb f0 ae 	sub	r11,pc,-3922
8000bf12:	e0 a0 02 f7 	rcall	8000c500 <_fwalk>
8000bf16:	d8 02       	popm	pc

8000bf18 <__sfmoreglue>:
8000bf18:	d4 21       	pushm	r4-r7,lr
8000bf1a:	16 95       	mov	r5,r11
8000bf1c:	f6 06 10 5c 	mul	r6,r11,92
8000bf20:	ec cb ff f4 	sub	r11,r6,-12
8000bf24:	fe b0 e2 76 	rcall	80008410 <_malloc_r>
8000bf28:	18 97       	mov	r7,r12
8000bf2a:	c0 90       	breq	8000bf3c <__sfmoreglue+0x24>
8000bf2c:	99 15       	st.w	r12[0x4],r5
8000bf2e:	30 0b       	mov	r11,0
8000bf30:	2f 4c       	sub	r12,-12
8000bf32:	0c 9a       	mov	r10,r6
8000bf34:	8f 2c       	st.w	r7[0x8],r12
8000bf36:	8f 0b       	st.w	r7[0x0],r11
8000bf38:	fe b0 e5 3f 	rcall	800089b6 <memset>
8000bf3c:	0e 9c       	mov	r12,r7
8000bf3e:	d8 22       	popm	r4-r7,pc

8000bf40 <__sfp>:
8000bf40:	d4 21       	pushm	r4-r7,lr
8000bf42:	fe c8 ca 3e 	sub	r8,pc,-13762
8000bf46:	18 96       	mov	r6,r12
8000bf48:	70 07       	ld.w	r7,r8[0x0]
8000bf4a:	6e 68       	ld.w	r8,r7[0x18]
8000bf4c:	58 08       	cp.w	r8,0
8000bf4e:	c0 31       	brne	8000bf54 <__sfp+0x14>
8000bf50:	0e 9c       	mov	r12,r7
8000bf52:	c2 dc       	rcall	8000bfac <__sinit>
8000bf54:	ee c7 ff 28 	sub	r7,r7,-216
8000bf58:	30 05       	mov	r5,0
8000bf5a:	6e 2c       	ld.w	r12,r7[0x8]
8000bf5c:	6e 18       	ld.w	r8,r7[0x4]
8000bf5e:	c0 68       	rjmp	8000bf6a <__sfp+0x2a>
8000bf60:	98 69       	ld.sh	r9,r12[0xc]
8000bf62:	ea 09 19 00 	cp.h	r9,r5
8000bf66:	c1 10       	breq	8000bf88 <__sfp+0x48>
8000bf68:	2a 4c       	sub	r12,-92
8000bf6a:	20 18       	sub	r8,1
8000bf6c:	cf a7       	brpl	8000bf60 <__sfp+0x20>
8000bf6e:	6e 08       	ld.w	r8,r7[0x0]
8000bf70:	58 08       	cp.w	r8,0
8000bf72:	c0 61       	brne	8000bf7e <__sfp+0x3e>
8000bf74:	30 4b       	mov	r11,4
8000bf76:	0c 9c       	mov	r12,r6
8000bf78:	cd 0f       	rcall	8000bf18 <__sfmoreglue>
8000bf7a:	8f 0c       	st.w	r7[0x0],r12
8000bf7c:	c0 30       	breq	8000bf82 <__sfp+0x42>
8000bf7e:	6e 07       	ld.w	r7,r7[0x0]
8000bf80:	ce db       	rjmp	8000bf5a <__sfp+0x1a>
8000bf82:	30 c8       	mov	r8,12
8000bf84:	8d 38       	st.w	r6[0xc],r8
8000bf86:	d8 22       	popm	r4-r7,pc
8000bf88:	30 08       	mov	r8,0
8000bf8a:	f9 48 00 4c 	st.w	r12[76],r8
8000bf8e:	99 08       	st.w	r12[0x0],r8
8000bf90:	99 28       	st.w	r12[0x8],r8
8000bf92:	99 18       	st.w	r12[0x4],r8
8000bf94:	99 48       	st.w	r12[0x10],r8
8000bf96:	99 58       	st.w	r12[0x14],r8
8000bf98:	99 68       	st.w	r12[0x18],r8
8000bf9a:	99 d8       	st.w	r12[0x34],r8
8000bf9c:	99 e8       	st.w	r12[0x38],r8
8000bf9e:	f9 48 00 48 	st.w	r12[72],r8
8000bfa2:	3f f8       	mov	r8,-1
8000bfa4:	b8 78       	st.h	r12[0xe],r8
8000bfa6:	30 18       	mov	r8,1
8000bfa8:	b8 68       	st.h	r12[0xc],r8
8000bfaa:	d8 22       	popm	r4-r7,pc

8000bfac <__sinit>:
8000bfac:	d4 21       	pushm	r4-r7,lr
8000bfae:	18 96       	mov	r6,r12
8000bfb0:	78 67       	ld.w	r7,r12[0x18]
8000bfb2:	58 07       	cp.w	r7,0
8000bfb4:	c4 91       	brne	8000c046 <__sinit+0x9a>
8000bfb6:	fe c8 00 aa 	sub	r8,pc,170
8000bfba:	30 15       	mov	r5,1
8000bfbc:	99 a8       	st.w	r12[0x28],r8
8000bfbe:	f9 47 00 d8 	st.w	r12[216],r7
8000bfc2:	f9 47 00 dc 	st.w	r12[220],r7
8000bfc6:	f9 47 00 e0 	st.w	r12[224],r7
8000bfca:	99 65       	st.w	r12[0x18],r5
8000bfcc:	cb af       	rcall	8000bf40 <__sfp>
8000bfce:	8d 0c       	st.w	r6[0x0],r12
8000bfd0:	0c 9c       	mov	r12,r6
8000bfd2:	cb 7f       	rcall	8000bf40 <__sfp>
8000bfd4:	8d 1c       	st.w	r6[0x4],r12
8000bfd6:	0c 9c       	mov	r12,r6
8000bfd8:	cb 4f       	rcall	8000bf40 <__sfp>
8000bfda:	6c 09       	ld.w	r9,r6[0x0]
8000bfdc:	30 48       	mov	r8,4
8000bfde:	93 07       	st.w	r9[0x0],r7
8000bfe0:	b2 68       	st.h	r9[0xc],r8
8000bfe2:	93 17       	st.w	r9[0x4],r7
8000bfe4:	93 27       	st.w	r9[0x8],r7
8000bfe6:	6c 18       	ld.w	r8,r6[0x4]
8000bfe8:	b2 77       	st.h	r9[0xe],r7
8000bfea:	93 47       	st.w	r9[0x10],r7
8000bfec:	93 57       	st.w	r9[0x14],r7
8000bfee:	93 67       	st.w	r9[0x18],r7
8000bff0:	93 89       	st.w	r9[0x20],r9
8000bff2:	91 07       	st.w	r8[0x0],r7
8000bff4:	91 17       	st.w	r8[0x4],r7
8000bff6:	91 27       	st.w	r8[0x8],r7
8000bff8:	fe ce f3 24 	sub	lr,pc,-3292
8000bffc:	fe cb f3 54 	sub	r11,pc,-3244
8000c000:	93 9e       	st.w	r9[0x24],lr
8000c002:	93 ab       	st.w	r9[0x28],r11
8000c004:	fe ca f3 7c 	sub	r10,pc,-3204
8000c008:	fe c4 f3 88 	sub	r4,pc,-3192
8000c00c:	93 ba       	st.w	r9[0x2c],r10
8000c00e:	93 c4       	st.w	r9[0x30],r4
8000c010:	30 99       	mov	r9,9
8000c012:	b0 69       	st.h	r8[0xc],r9
8000c014:	b0 75       	st.h	r8[0xe],r5
8000c016:	91 c4       	st.w	r8[0x30],r4
8000c018:	91 47       	st.w	r8[0x10],r7
8000c01a:	91 57       	st.w	r8[0x14],r7
8000c01c:	91 67       	st.w	r8[0x18],r7
8000c01e:	91 88       	st.w	r8[0x20],r8
8000c020:	91 9e       	st.w	r8[0x24],lr
8000c022:	91 ab       	st.w	r8[0x28],r11
8000c024:	91 ba       	st.w	r8[0x2c],r10
8000c026:	8d 2c       	st.w	r6[0x8],r12
8000c028:	31 28       	mov	r8,18
8000c02a:	99 07       	st.w	r12[0x0],r7
8000c02c:	b8 68       	st.h	r12[0xc],r8
8000c02e:	99 17       	st.w	r12[0x4],r7
8000c030:	99 27       	st.w	r12[0x8],r7
8000c032:	30 28       	mov	r8,2
8000c034:	b8 78       	st.h	r12[0xe],r8
8000c036:	99 c4       	st.w	r12[0x30],r4
8000c038:	99 67       	st.w	r12[0x18],r7
8000c03a:	99 9e       	st.w	r12[0x24],lr
8000c03c:	99 ab       	st.w	r12[0x28],r11
8000c03e:	99 ba       	st.w	r12[0x2c],r10
8000c040:	99 47       	st.w	r12[0x10],r7
8000c042:	99 57       	st.w	r12[0x14],r7
8000c044:	99 8c       	st.w	r12[0x20],r12
8000c046:	d8 22       	popm	r4-r7,pc

8000c048 <_malloc_trim_r>:
8000c048:	d4 21       	pushm	r4-r7,lr
8000c04a:	16 95       	mov	r5,r11
8000c04c:	18 97       	mov	r7,r12
8000c04e:	fe b0 d7 97 	rcall	80006f7c <__malloc_lock>
8000c052:	e0 64 05 54 	mov	r4,1364
8000c056:	68 28       	ld.w	r8,r4[0x8]
8000c058:	70 16       	ld.w	r6,r8[0x4]
8000c05a:	e0 16 ff fc 	andl	r6,0xfffc
8000c05e:	ec c8 ff 91 	sub	r8,r6,-111
8000c062:	f0 05 01 05 	sub	r5,r8,r5
8000c066:	e0 15 ff 80 	andl	r5,0xff80
8000c06a:	ea c5 00 80 	sub	r5,r5,128
8000c06e:	e0 45 00 7f 	cp.w	r5,127
8000c072:	e0 8a 00 25 	brle	8000c0bc <_malloc_trim_r+0x74>
8000c076:	30 0b       	mov	r11,0
8000c078:	0e 9c       	mov	r12,r7
8000c07a:	fe b0 e6 05 	rcall	80008c84 <_sbrk_r>
8000c07e:	68 28       	ld.w	r8,r4[0x8]
8000c080:	0c 08       	add	r8,r6
8000c082:	10 3c       	cp.w	r12,r8
8000c084:	c1 c1       	brne	8000c0bc <_malloc_trim_r+0x74>
8000c086:	ea 0b 11 00 	rsub	r11,r5,0
8000c08a:	0e 9c       	mov	r12,r7
8000c08c:	fe b0 e5 fc 	rcall	80008c84 <_sbrk_r>
8000c090:	5b fc       	cp.w	r12,-1
8000c092:	c1 91       	brne	8000c0c4 <_malloc_trim_r+0x7c>
8000c094:	30 0b       	mov	r11,0
8000c096:	0e 9c       	mov	r12,r7
8000c098:	fe b0 e5 f6 	rcall	80008c84 <_sbrk_r>
8000c09c:	68 28       	ld.w	r8,r4[0x8]
8000c09e:	f8 08 01 09 	sub	r9,r12,r8
8000c0a2:	58 f9       	cp.w	r9,15
8000c0a4:	e0 8a 00 0c 	brle	8000c0bc <_malloc_trim_r+0x74>
8000c0a8:	a1 a9       	sbr	r9,0x0
8000c0aa:	91 19       	st.w	r8[0x4],r9
8000c0ac:	e0 68 09 60 	mov	r8,2400
8000c0b0:	70 09       	ld.w	r9,r8[0x0]
8000c0b2:	e0 68 0d ec 	mov	r8,3564
8000c0b6:	f8 09 01 09 	sub	r9,r12,r9
8000c0ba:	91 09       	st.w	r8[0x0],r9
8000c0bc:	0e 9c       	mov	r12,r7
8000c0be:	fe b0 d7 65 	rcall	80006f88 <__malloc_unlock>
8000c0c2:	d8 2a       	popm	r4-r7,pc,r12=0
8000c0c4:	68 28       	ld.w	r8,r4[0x8]
8000c0c6:	0a 16       	sub	r6,r5
8000c0c8:	a1 a6       	sbr	r6,0x0
8000c0ca:	91 16       	st.w	r8[0x4],r6
8000c0cc:	e0 68 0d ec 	mov	r8,3564
8000c0d0:	70 09       	ld.w	r9,r8[0x0]
8000c0d2:	0a 19       	sub	r9,r5
8000c0d4:	0e 9c       	mov	r12,r7
8000c0d6:	91 09       	st.w	r8[0x0],r9
8000c0d8:	fe b0 d7 58 	rcall	80006f88 <__malloc_unlock>
8000c0dc:	da 2a       	popm	r4-r7,pc,r12=1
8000c0de:	d7 03       	nop

8000c0e0 <_free_r>:
8000c0e0:	d4 21       	pushm	r4-r7,lr
8000c0e2:	16 96       	mov	r6,r11
8000c0e4:	18 97       	mov	r7,r12
8000c0e6:	58 0b       	cp.w	r11,0
8000c0e8:	e0 80 00 c0 	breq	8000c268 <_free_r+0x188>
8000c0ec:	fe b0 d7 48 	rcall	80006f7c <__malloc_lock>
8000c0f0:	20 86       	sub	r6,8
8000c0f2:	e0 6a 05 54 	mov	r10,1364
8000c0f6:	6c 18       	ld.w	r8,r6[0x4]
8000c0f8:	74 2e       	ld.w	lr,r10[0x8]
8000c0fa:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000c0fe:	a1 c8       	cbr	r8,0x0
8000c100:	ec 08 00 09 	add	r9,r6,r8
8000c104:	72 1b       	ld.w	r11,r9[0x4]
8000c106:	e0 1b ff fc 	andl	r11,0xfffc
8000c10a:	1c 39       	cp.w	r9,lr
8000c10c:	c1 e1       	brne	8000c148 <_free_r+0x68>
8000c10e:	f6 08 00 08 	add	r8,r11,r8
8000c112:	58 0c       	cp.w	r12,0
8000c114:	c0 81       	brne	8000c124 <_free_r+0x44>
8000c116:	6c 09       	ld.w	r9,r6[0x0]
8000c118:	12 16       	sub	r6,r9
8000c11a:	12 08       	add	r8,r9
8000c11c:	6c 3b       	ld.w	r11,r6[0xc]
8000c11e:	6c 29       	ld.w	r9,r6[0x8]
8000c120:	97 29       	st.w	r11[0x8],r9
8000c122:	93 3b       	st.w	r9[0xc],r11
8000c124:	10 99       	mov	r9,r8
8000c126:	95 26       	st.w	r10[0x8],r6
8000c128:	a1 a9       	sbr	r9,0x0
8000c12a:	8d 19       	st.w	r6[0x4],r9
8000c12c:	e0 69 09 5c 	mov	r9,2396
8000c130:	72 09       	ld.w	r9,r9[0x0]
8000c132:	12 38       	cp.w	r8,r9
8000c134:	c0 63       	brcs	8000c140 <_free_r+0x60>
8000c136:	e0 68 0d e8 	mov	r8,3560
8000c13a:	0e 9c       	mov	r12,r7
8000c13c:	70 0b       	ld.w	r11,r8[0x0]
8000c13e:	c8 5f       	rcall	8000c048 <_malloc_trim_r>
8000c140:	0e 9c       	mov	r12,r7
8000c142:	fe b0 d7 23 	rcall	80006f88 <__malloc_unlock>
8000c146:	d8 22       	popm	r4-r7,pc
8000c148:	93 1b       	st.w	r9[0x4],r11
8000c14a:	58 0c       	cp.w	r12,0
8000c14c:	c0 30       	breq	8000c152 <_free_r+0x72>
8000c14e:	30 0c       	mov	r12,0
8000c150:	c1 08       	rjmp	8000c170 <_free_r+0x90>
8000c152:	6c 0e       	ld.w	lr,r6[0x0]
8000c154:	f4 c5 ff f8 	sub	r5,r10,-8
8000c158:	1c 16       	sub	r6,lr
8000c15a:	1c 08       	add	r8,lr
8000c15c:	6c 2e       	ld.w	lr,r6[0x8]
8000c15e:	0a 3e       	cp.w	lr,r5
8000c160:	f9 bc 00 01 	moveq	r12,1
8000c164:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000c168:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000c16c:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000c170:	f2 0b 00 0e 	add	lr,r9,r11
8000c174:	7c 1e       	ld.w	lr,lr[0x4]
8000c176:	ed be 00 00 	bld	lr,0x0
8000c17a:	c1 40       	breq	8000c1a2 <_free_r+0xc2>
8000c17c:	16 08       	add	r8,r11
8000c17e:	58 0c       	cp.w	r12,0
8000c180:	c0 d1       	brne	8000c19a <_free_r+0xba>
8000c182:	e0 6e 05 54 	mov	lr,1364
8000c186:	72 2b       	ld.w	r11,r9[0x8]
8000c188:	2f 8e       	sub	lr,-8
8000c18a:	1c 3b       	cp.w	r11,lr
8000c18c:	c0 71       	brne	8000c19a <_free_r+0xba>
8000c18e:	97 36       	st.w	r11[0xc],r6
8000c190:	97 26       	st.w	r11[0x8],r6
8000c192:	8d 2b       	st.w	r6[0x8],r11
8000c194:	8d 3b       	st.w	r6[0xc],r11
8000c196:	30 1c       	mov	r12,1
8000c198:	c0 58       	rjmp	8000c1a2 <_free_r+0xc2>
8000c19a:	72 2b       	ld.w	r11,r9[0x8]
8000c19c:	72 39       	ld.w	r9,r9[0xc]
8000c19e:	93 2b       	st.w	r9[0x8],r11
8000c1a0:	97 39       	st.w	r11[0xc],r9
8000c1a2:	10 99       	mov	r9,r8
8000c1a4:	ec 08 09 08 	st.w	r6[r8],r8
8000c1a8:	a1 a9       	sbr	r9,0x0
8000c1aa:	8d 19       	st.w	r6[0x4],r9
8000c1ac:	58 0c       	cp.w	r12,0
8000c1ae:	c5 a1       	brne	8000c262 <_free_r+0x182>
8000c1b0:	e0 48 01 ff 	cp.w	r8,511
8000c1b4:	e0 8b 00 13 	brhi	8000c1da <_free_r+0xfa>
8000c1b8:	a3 98       	lsr	r8,0x3
8000c1ba:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000c1be:	72 2b       	ld.w	r11,r9[0x8]
8000c1c0:	8d 39       	st.w	r6[0xc],r9
8000c1c2:	8d 2b       	st.w	r6[0x8],r11
8000c1c4:	97 36       	st.w	r11[0xc],r6
8000c1c6:	93 26       	st.w	r9[0x8],r6
8000c1c8:	a3 48       	asr	r8,0x2
8000c1ca:	74 19       	ld.w	r9,r10[0x4]
8000c1cc:	30 1b       	mov	r11,1
8000c1ce:	f6 08 09 48 	lsl	r8,r11,r8
8000c1d2:	f3 e8 10 08 	or	r8,r9,r8
8000c1d6:	95 18       	st.w	r10[0x4],r8
8000c1d8:	c4 58       	rjmp	8000c262 <_free_r+0x182>
8000c1da:	f0 0b 16 09 	lsr	r11,r8,0x9
8000c1de:	58 4b       	cp.w	r11,4
8000c1e0:	e0 8b 00 06 	brhi	8000c1ec <_free_r+0x10c>
8000c1e4:	f0 0b 16 06 	lsr	r11,r8,0x6
8000c1e8:	2c 8b       	sub	r11,-56
8000c1ea:	c2 08       	rjmp	8000c22a <_free_r+0x14a>
8000c1ec:	59 4b       	cp.w	r11,20
8000c1ee:	e0 8b 00 04 	brhi	8000c1f6 <_free_r+0x116>
8000c1f2:	2a 5b       	sub	r11,-91
8000c1f4:	c1 b8       	rjmp	8000c22a <_free_r+0x14a>
8000c1f6:	e0 4b 00 54 	cp.w	r11,84
8000c1fa:	e0 8b 00 06 	brhi	8000c206 <_free_r+0x126>
8000c1fe:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000c202:	29 2b       	sub	r11,-110
8000c204:	c1 38       	rjmp	8000c22a <_free_r+0x14a>
8000c206:	e0 4b 01 54 	cp.w	r11,340
8000c20a:	e0 8b 00 06 	brhi	8000c216 <_free_r+0x136>
8000c20e:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000c212:	28 9b       	sub	r11,-119
8000c214:	c0 b8       	rjmp	8000c22a <_free_r+0x14a>
8000c216:	e0 4b 05 54 	cp.w	r11,1364
8000c21a:	e0 88 00 05 	brls	8000c224 <_free_r+0x144>
8000c21e:	37 eb       	mov	r11,126
8000c220:	c0 58       	rjmp	8000c22a <_free_r+0x14a>
8000c222:	d7 03       	nop
8000c224:	f0 0b 16 12 	lsr	r11,r8,0x12
8000c228:	28 4b       	sub	r11,-124
8000c22a:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000c22e:	78 29       	ld.w	r9,r12[0x8]
8000c230:	18 39       	cp.w	r9,r12
8000c232:	c0 e1       	brne	8000c24e <_free_r+0x16e>
8000c234:	74 18       	ld.w	r8,r10[0x4]
8000c236:	a3 4b       	asr	r11,0x2
8000c238:	30 1c       	mov	r12,1
8000c23a:	f8 0b 09 4b 	lsl	r11,r12,r11
8000c23e:	f1 eb 10 0b 	or	r11,r8,r11
8000c242:	12 98       	mov	r8,r9
8000c244:	95 1b       	st.w	r10[0x4],r11
8000c246:	c0 a8       	rjmp	8000c25a <_free_r+0x17a>
8000c248:	72 29       	ld.w	r9,r9[0x8]
8000c24a:	18 39       	cp.w	r9,r12
8000c24c:	c0 60       	breq	8000c258 <_free_r+0x178>
8000c24e:	72 1a       	ld.w	r10,r9[0x4]
8000c250:	e0 1a ff fc 	andl	r10,0xfffc
8000c254:	14 38       	cp.w	r8,r10
8000c256:	cf 93       	brcs	8000c248 <_free_r+0x168>
8000c258:	72 38       	ld.w	r8,r9[0xc]
8000c25a:	8d 38       	st.w	r6[0xc],r8
8000c25c:	8d 29       	st.w	r6[0x8],r9
8000c25e:	93 36       	st.w	r9[0xc],r6
8000c260:	91 26       	st.w	r8[0x8],r6
8000c262:	0e 9c       	mov	r12,r7
8000c264:	fe b0 d6 92 	rcall	80006f88 <__malloc_unlock>
8000c268:	d8 22       	popm	r4-r7,pc
8000c26a:	d7 03       	nop

8000c26c <__sfvwrite_r>:
8000c26c:	d4 31       	pushm	r0-r7,lr
8000c26e:	20 3d       	sub	sp,12
8000c270:	14 94       	mov	r4,r10
8000c272:	18 95       	mov	r5,r12
8000c274:	16 97       	mov	r7,r11
8000c276:	74 28       	ld.w	r8,r10[0x8]
8000c278:	58 08       	cp.w	r8,0
8000c27a:	e0 80 01 40 	breq	8000c4fa <__sfvwrite_r+0x28e>
8000c27e:	96 68       	ld.sh	r8,r11[0xc]
8000c280:	ed b8 00 03 	bld	r8,0x3
8000c284:	c0 41       	brne	8000c28c <__sfvwrite_r+0x20>
8000c286:	76 48       	ld.w	r8,r11[0x10]
8000c288:	58 08       	cp.w	r8,0
8000c28a:	c0 c1       	brne	8000c2a2 <__sfvwrite_r+0x36>
8000c28c:	0e 9b       	mov	r11,r7
8000c28e:	0a 9c       	mov	r12,r5
8000c290:	fe b0 f6 c4 	rcall	8000b018 <__swsetup_r>
8000c294:	c0 70       	breq	8000c2a2 <__sfvwrite_r+0x36>
8000c296:	8e 68       	ld.sh	r8,r7[0xc]
8000c298:	a7 a8       	sbr	r8,0x6
8000c29a:	ae 68       	st.h	r7[0xc],r8
8000c29c:	30 98       	mov	r8,9
8000c29e:	8b 38       	st.w	r5[0xc],r8
8000c2a0:	c2 b9       	rjmp	8000c4f6 <__sfvwrite_r+0x28a>
8000c2a2:	8e 63       	ld.sh	r3,r7[0xc]
8000c2a4:	68 00       	ld.w	r0,r4[0x0]
8000c2a6:	06 96       	mov	r6,r3
8000c2a8:	e2 16 00 02 	andl	r6,0x2,COH
8000c2ac:	c2 10       	breq	8000c2ee <__sfvwrite_r+0x82>
8000c2ae:	30 03       	mov	r3,0
8000c2b0:	e0 62 04 00 	mov	r2,1024
8000c2b4:	06 96       	mov	r6,r3
8000c2b6:	c0 48       	rjmp	8000c2be <__sfvwrite_r+0x52>
8000c2b8:	60 03       	ld.w	r3,r0[0x0]
8000c2ba:	60 16       	ld.w	r6,r0[0x4]
8000c2bc:	2f 80       	sub	r0,-8
8000c2be:	58 06       	cp.w	r6,0
8000c2c0:	cf c0       	breq	8000c2b8 <__sfvwrite_r+0x4c>
8000c2c2:	e0 46 04 00 	cp.w	r6,1024
8000c2c6:	ec 09 17 80 	movls	r9,r6
8000c2ca:	e4 09 17 b0 	movhi	r9,r2
8000c2ce:	06 9a       	mov	r10,r3
8000c2d0:	6e a8       	ld.w	r8,r7[0x28]
8000c2d2:	6e 8b       	ld.w	r11,r7[0x20]
8000c2d4:	0a 9c       	mov	r12,r5
8000c2d6:	5d 18       	icall	r8
8000c2d8:	18 16       	sub	r6,r12
8000c2da:	58 0c       	cp.w	r12,0
8000c2dc:	e0 8a 01 0a 	brle	8000c4f0 <__sfvwrite_r+0x284>
8000c2e0:	68 28       	ld.w	r8,r4[0x8]
8000c2e2:	18 18       	sub	r8,r12
8000c2e4:	89 28       	st.w	r4[0x8],r8
8000c2e6:	e0 80 01 0a 	breq	8000c4fa <__sfvwrite_r+0x28e>
8000c2ea:	18 03       	add	r3,r12
8000c2ec:	ce 9b       	rjmp	8000c2be <__sfvwrite_r+0x52>
8000c2ee:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000c2f2:	c0 70       	breq	8000c300 <__sfvwrite_r+0x94>
8000c2f4:	50 06       	stdsp	sp[0x0],r6
8000c2f6:	0c 93       	mov	r3,r6
8000c2f8:	0c 91       	mov	r1,r6
8000c2fa:	50 15       	stdsp	sp[0x4],r5
8000c2fc:	08 92       	mov	r2,r4
8000c2fe:	c9 c8       	rjmp	8000c436 <__sfvwrite_r+0x1ca>
8000c300:	06 96       	mov	r6,r3
8000c302:	08 91       	mov	r1,r4
8000c304:	c0 48       	rjmp	8000c30c <__sfvwrite_r+0xa0>
8000c306:	60 03       	ld.w	r3,r0[0x0]
8000c308:	60 16       	ld.w	r6,r0[0x4]
8000c30a:	2f 80       	sub	r0,-8
8000c30c:	58 06       	cp.w	r6,0
8000c30e:	cf c0       	breq	8000c306 <__sfvwrite_r+0x9a>
8000c310:	8e 68       	ld.sh	r8,r7[0xc]
8000c312:	6e 24       	ld.w	r4,r7[0x8]
8000c314:	10 99       	mov	r9,r8
8000c316:	e2 19 02 00 	andl	r9,0x200,COH
8000c31a:	c5 50       	breq	8000c3c4 <__sfvwrite_r+0x158>
8000c31c:	08 36       	cp.w	r6,r4
8000c31e:	c4 43       	brcs	8000c3a6 <__sfvwrite_r+0x13a>
8000c320:	10 99       	mov	r9,r8
8000c322:	e2 19 04 80 	andl	r9,0x480,COH
8000c326:	c4 00       	breq	8000c3a6 <__sfvwrite_r+0x13a>
8000c328:	6e 4b       	ld.w	r11,r7[0x10]
8000c32a:	6e 09       	ld.w	r9,r7[0x0]
8000c32c:	16 19       	sub	r9,r11
8000c32e:	50 09       	stdsp	sp[0x0],r9
8000c330:	6e 59       	ld.w	r9,r7[0x14]
8000c332:	10 9c       	mov	r12,r8
8000c334:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000c338:	30 28       	mov	r8,2
8000c33a:	f4 08 0c 08 	divs	r8,r10,r8
8000c33e:	fa e9 00 04 	st.d	sp[4],r8
8000c342:	10 94       	mov	r4,r8
8000c344:	40 09       	lddsp	r9,sp[0x0]
8000c346:	e2 1c 04 00 	andl	r12,0x400,COH
8000c34a:	2f f9       	sub	r9,-1
8000c34c:	0c 09       	add	r9,r6
8000c34e:	12 38       	cp.w	r8,r9
8000c350:	f2 04 17 30 	movlo	r4,r9
8000c354:	58 0c       	cp.w	r12,0
8000c356:	c1 10       	breq	8000c378 <__sfvwrite_r+0x10c>
8000c358:	08 9b       	mov	r11,r4
8000c35a:	0a 9c       	mov	r12,r5
8000c35c:	fe b0 e0 5a 	rcall	80008410 <_malloc_r>
8000c360:	18 92       	mov	r2,r12
8000c362:	c1 40       	breq	8000c38a <__sfvwrite_r+0x11e>
8000c364:	40 0a       	lddsp	r10,sp[0x0]
8000c366:	6e 4b       	ld.w	r11,r7[0x10]
8000c368:	fe b0 e2 83 	rcall	8000886e <memcpy>
8000c36c:	8e 68       	ld.sh	r8,r7[0xc]
8000c36e:	e0 18 fb 7f 	andl	r8,0xfb7f
8000c372:	a7 b8       	sbr	r8,0x7
8000c374:	ae 68       	st.h	r7[0xc],r8
8000c376:	c0 d8       	rjmp	8000c390 <__sfvwrite_r+0x124>
8000c378:	08 9a       	mov	r10,r4
8000c37a:	0a 9c       	mov	r12,r5
8000c37c:	fe b0 e3 24 	rcall	800089c4 <_realloc_r>
8000c380:	18 92       	mov	r2,r12
8000c382:	c0 71       	brne	8000c390 <__sfvwrite_r+0x124>
8000c384:	6e 4b       	ld.w	r11,r7[0x10]
8000c386:	0a 9c       	mov	r12,r5
8000c388:	ca ce       	rcall	8000c0e0 <_free_r>
8000c38a:	30 c8       	mov	r8,12
8000c38c:	8b 38       	st.w	r5[0xc],r8
8000c38e:	cb 18       	rjmp	8000c4f0 <__sfvwrite_r+0x284>
8000c390:	40 0a       	lddsp	r10,sp[0x0]
8000c392:	40 09       	lddsp	r9,sp[0x0]
8000c394:	e8 0a 01 0a 	sub	r10,r4,r10
8000c398:	e4 09 00 08 	add	r8,r2,r9
8000c39c:	8f 54       	st.w	r7[0x14],r4
8000c39e:	8f 2a       	st.w	r7[0x8],r10
8000c3a0:	8f 08       	st.w	r7[0x0],r8
8000c3a2:	8f 42       	st.w	r7[0x10],r2
8000c3a4:	0c 94       	mov	r4,r6
8000c3a6:	08 36       	cp.w	r6,r4
8000c3a8:	ec 04 17 30 	movlo	r4,r6
8000c3ac:	06 9b       	mov	r11,r3
8000c3ae:	08 9a       	mov	r10,r4
8000c3b0:	6e 0c       	ld.w	r12,r7[0x0]
8000c3b2:	c3 ad       	rcall	8000c626 <memmove>
8000c3b4:	6e 08       	ld.w	r8,r7[0x0]
8000c3b6:	08 08       	add	r8,r4
8000c3b8:	8f 08       	st.w	r7[0x0],r8
8000c3ba:	6e 28       	ld.w	r8,r7[0x8]
8000c3bc:	08 18       	sub	r8,r4
8000c3be:	0c 94       	mov	r4,r6
8000c3c0:	8f 28       	st.w	r7[0x8],r8
8000c3c2:	c2 e8       	rjmp	8000c41e <__sfvwrite_r+0x1b2>
8000c3c4:	08 36       	cp.w	r6,r4
8000c3c6:	5f ba       	srhi	r10
8000c3c8:	6e 0c       	ld.w	r12,r7[0x0]
8000c3ca:	6e 48       	ld.w	r8,r7[0x10]
8000c3cc:	10 3c       	cp.w	r12,r8
8000c3ce:	5f b8       	srhi	r8
8000c3d0:	f5 e8 00 08 	and	r8,r10,r8
8000c3d4:	f2 08 18 00 	cp.b	r8,r9
8000c3d8:	c0 d0       	breq	8000c3f2 <__sfvwrite_r+0x186>
8000c3da:	06 9b       	mov	r11,r3
8000c3dc:	08 9a       	mov	r10,r4
8000c3de:	c2 4d       	rcall	8000c626 <memmove>
8000c3e0:	6e 08       	ld.w	r8,r7[0x0]
8000c3e2:	08 08       	add	r8,r4
8000c3e4:	0e 9b       	mov	r11,r7
8000c3e6:	8f 08       	st.w	r7[0x0],r8
8000c3e8:	0a 9c       	mov	r12,r5
8000c3ea:	fe b0 fd 09 	rcall	8000bdfc <_fflush_r>
8000c3ee:	c1 80       	breq	8000c41e <__sfvwrite_r+0x1b2>
8000c3f0:	c8 08       	rjmp	8000c4f0 <__sfvwrite_r+0x284>
8000c3f2:	6e 59       	ld.w	r9,r7[0x14]
8000c3f4:	12 36       	cp.w	r6,r9
8000c3f6:	c0 a3       	brcs	8000c40a <__sfvwrite_r+0x19e>
8000c3f8:	6e a8       	ld.w	r8,r7[0x28]
8000c3fa:	06 9a       	mov	r10,r3
8000c3fc:	6e 8b       	ld.w	r11,r7[0x20]
8000c3fe:	0a 9c       	mov	r12,r5
8000c400:	5d 18       	icall	r8
8000c402:	18 94       	mov	r4,r12
8000c404:	e0 89 00 0d 	brgt	8000c41e <__sfvwrite_r+0x1b2>
8000c408:	c7 48       	rjmp	8000c4f0 <__sfvwrite_r+0x284>
8000c40a:	0c 9a       	mov	r10,r6
8000c40c:	06 9b       	mov	r11,r3
8000c40e:	c0 cd       	rcall	8000c626 <memmove>
8000c410:	6e 08       	ld.w	r8,r7[0x0]
8000c412:	0c 08       	add	r8,r6
8000c414:	0c 94       	mov	r4,r6
8000c416:	8f 08       	st.w	r7[0x0],r8
8000c418:	6e 28       	ld.w	r8,r7[0x8]
8000c41a:	0c 18       	sub	r8,r6
8000c41c:	8f 28       	st.w	r7[0x8],r8
8000c41e:	62 28       	ld.w	r8,r1[0x8]
8000c420:	08 18       	sub	r8,r4
8000c422:	83 28       	st.w	r1[0x8],r8
8000c424:	c6 b0       	breq	8000c4fa <__sfvwrite_r+0x28e>
8000c426:	08 16       	sub	r6,r4
8000c428:	08 03       	add	r3,r4
8000c42a:	c7 1b       	rjmp	8000c30c <__sfvwrite_r+0xa0>
8000c42c:	60 03       	ld.w	r3,r0[0x0]
8000c42e:	60 11       	ld.w	r1,r0[0x4]
8000c430:	30 08       	mov	r8,0
8000c432:	2f 80       	sub	r0,-8
8000c434:	50 08       	stdsp	sp[0x0],r8
8000c436:	58 01       	cp.w	r1,0
8000c438:	cf a0       	breq	8000c42c <__sfvwrite_r+0x1c0>
8000c43a:	40 0a       	lddsp	r10,sp[0x0]
8000c43c:	58 0a       	cp.w	r10,0
8000c43e:	c1 41       	brne	8000c466 <__sfvwrite_r+0x1fa>
8000c440:	e2 c6 ff ff 	sub	r6,r1,-1
8000c444:	02 9a       	mov	r10,r1
8000c446:	30 ab       	mov	r11,10
8000c448:	06 9c       	mov	r12,r3
8000c44a:	ce 3c       	rcall	8000c610 <memchr>
8000c44c:	f8 c8 ff ff 	sub	r8,r12,-1
8000c450:	58 0c       	cp.w	r12,0
8000c452:	f1 d3 e1 16 	subne	r6,r8,r3
8000c456:	f9 b9 01 01 	movne	r9,1
8000c45a:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000c45e:	f9 b8 00 01 	moveq	r8,1
8000c462:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000c466:	02 36       	cp.w	r6,r1
8000c468:	ec 04 17 80 	movls	r4,r6
8000c46c:	e2 04 17 b0 	movhi	r4,r1
8000c470:	6e 59       	ld.w	r9,r7[0x14]
8000c472:	6e 25       	ld.w	r5,r7[0x8]
8000c474:	f2 05 00 05 	add	r5,r9,r5
8000c478:	0a 34       	cp.w	r4,r5
8000c47a:	5f 9a       	srgt	r10
8000c47c:	6e 0c       	ld.w	r12,r7[0x0]
8000c47e:	6e 48       	ld.w	r8,r7[0x10]
8000c480:	10 3c       	cp.w	r12,r8
8000c482:	5f b8       	srhi	r8
8000c484:	f5 e8 00 08 	and	r8,r10,r8
8000c488:	30 0a       	mov	r10,0
8000c48a:	f4 08 18 00 	cp.b	r8,r10
8000c48e:	c0 d0       	breq	8000c4a8 <__sfvwrite_r+0x23c>
8000c490:	06 9b       	mov	r11,r3
8000c492:	0a 9a       	mov	r10,r5
8000c494:	cc 9c       	rcall	8000c626 <memmove>
8000c496:	6e 08       	ld.w	r8,r7[0x0]
8000c498:	0a 08       	add	r8,r5
8000c49a:	0e 9b       	mov	r11,r7
8000c49c:	8f 08       	st.w	r7[0x0],r8
8000c49e:	40 1c       	lddsp	r12,sp[0x4]
8000c4a0:	fe b0 fc ae 	rcall	8000bdfc <_fflush_r>
8000c4a4:	c1 70       	breq	8000c4d2 <__sfvwrite_r+0x266>
8000c4a6:	c2 58       	rjmp	8000c4f0 <__sfvwrite_r+0x284>
8000c4a8:	12 34       	cp.w	r4,r9
8000c4aa:	c0 a5       	brlt	8000c4be <__sfvwrite_r+0x252>
8000c4ac:	6e a8       	ld.w	r8,r7[0x28]
8000c4ae:	06 9a       	mov	r10,r3
8000c4b0:	6e 8b       	ld.w	r11,r7[0x20]
8000c4b2:	40 1c       	lddsp	r12,sp[0x4]
8000c4b4:	5d 18       	icall	r8
8000c4b6:	18 95       	mov	r5,r12
8000c4b8:	e0 89 00 0d 	brgt	8000c4d2 <__sfvwrite_r+0x266>
8000c4bc:	c1 a8       	rjmp	8000c4f0 <__sfvwrite_r+0x284>
8000c4be:	08 9a       	mov	r10,r4
8000c4c0:	06 9b       	mov	r11,r3
8000c4c2:	cb 2c       	rcall	8000c626 <memmove>
8000c4c4:	6e 08       	ld.w	r8,r7[0x0]
8000c4c6:	08 08       	add	r8,r4
8000c4c8:	08 95       	mov	r5,r4
8000c4ca:	8f 08       	st.w	r7[0x0],r8
8000c4cc:	6e 28       	ld.w	r8,r7[0x8]
8000c4ce:	08 18       	sub	r8,r4
8000c4d0:	8f 28       	st.w	r7[0x8],r8
8000c4d2:	0a 16       	sub	r6,r5
8000c4d4:	c0 71       	brne	8000c4e2 <__sfvwrite_r+0x276>
8000c4d6:	0e 9b       	mov	r11,r7
8000c4d8:	40 1c       	lddsp	r12,sp[0x4]
8000c4da:	fe b0 fc 91 	rcall	8000bdfc <_fflush_r>
8000c4de:	c0 91       	brne	8000c4f0 <__sfvwrite_r+0x284>
8000c4e0:	50 06       	stdsp	sp[0x0],r6
8000c4e2:	64 28       	ld.w	r8,r2[0x8]
8000c4e4:	0a 18       	sub	r8,r5
8000c4e6:	85 28       	st.w	r2[0x8],r8
8000c4e8:	c0 90       	breq	8000c4fa <__sfvwrite_r+0x28e>
8000c4ea:	0a 11       	sub	r1,r5
8000c4ec:	0a 03       	add	r3,r5
8000c4ee:	ca 4b       	rjmp	8000c436 <__sfvwrite_r+0x1ca>
8000c4f0:	8e 68       	ld.sh	r8,r7[0xc]
8000c4f2:	a7 a8       	sbr	r8,0x6
8000c4f4:	ae 68       	st.h	r7[0xc],r8
8000c4f6:	3f fc       	mov	r12,-1
8000c4f8:	c0 28       	rjmp	8000c4fc <__sfvwrite_r+0x290>
8000c4fa:	30 0c       	mov	r12,0
8000c4fc:	2f dd       	sub	sp,-12
8000c4fe:	d8 32       	popm	r0-r7,pc

8000c500 <_fwalk>:
8000c500:	d4 31       	pushm	r0-r7,lr
8000c502:	30 05       	mov	r5,0
8000c504:	16 91       	mov	r1,r11
8000c506:	f8 c7 ff 28 	sub	r7,r12,-216
8000c50a:	0a 92       	mov	r2,r5
8000c50c:	fe b0 fc fe 	rcall	8000bf08 <__sfp_lock_acquire>
8000c510:	3f f3       	mov	r3,-1
8000c512:	c1 68       	rjmp	8000c53e <_fwalk+0x3e>
8000c514:	6e 26       	ld.w	r6,r7[0x8]
8000c516:	6e 14       	ld.w	r4,r7[0x4]
8000c518:	2f 46       	sub	r6,-12
8000c51a:	c0 c8       	rjmp	8000c532 <_fwalk+0x32>
8000c51c:	8c 08       	ld.sh	r8,r6[0x0]
8000c51e:	e4 08 19 00 	cp.h	r8,r2
8000c522:	c0 70       	breq	8000c530 <_fwalk+0x30>
8000c524:	8c 18       	ld.sh	r8,r6[0x2]
8000c526:	e6 08 19 00 	cp.h	r8,r3
8000c52a:	c0 30       	breq	8000c530 <_fwalk+0x30>
8000c52c:	5d 11       	icall	r1
8000c52e:	18 45       	or	r5,r12
8000c530:	2a 46       	sub	r6,-92
8000c532:	20 14       	sub	r4,1
8000c534:	ec cc 00 0c 	sub	r12,r6,12
8000c538:	58 04       	cp.w	r4,0
8000c53a:	cf 14       	brge	8000c51c <_fwalk+0x1c>
8000c53c:	6e 07       	ld.w	r7,r7[0x0]
8000c53e:	58 07       	cp.w	r7,0
8000c540:	ce a1       	brne	8000c514 <_fwalk+0x14>
8000c542:	fe b0 fc e4 	rcall	8000bf0a <__sfp_lock_release>
8000c546:	0a 9c       	mov	r12,r5
8000c548:	d8 32       	popm	r0-r7,pc
8000c54a:	d7 03       	nop

8000c54c <_localeconv_r>:
8000c54c:	fe cc d0 44 	sub	r12,pc,-12220
8000c550:	5e fc       	retal	r12
8000c552:	d7 03       	nop

8000c554 <__smakebuf_r>:
8000c554:	d4 21       	pushm	r4-r7,lr
8000c556:	20 fd       	sub	sp,60
8000c558:	96 68       	ld.sh	r8,r11[0xc]
8000c55a:	16 97       	mov	r7,r11
8000c55c:	18 96       	mov	r6,r12
8000c55e:	e2 18 00 02 	andl	r8,0x2,COH
8000c562:	c3 d1       	brne	8000c5dc <__smakebuf_r+0x88>
8000c564:	96 7b       	ld.sh	r11,r11[0xe]
8000c566:	f0 0b 19 00 	cp.h	r11,r8
8000c56a:	c0 55       	brlt	8000c574 <__smakebuf_r+0x20>
8000c56c:	1a 9a       	mov	r10,sp
8000c56e:	e0 a0 04 81 	rcall	8000ce70 <_fstat_r>
8000c572:	c0 f4       	brge	8000c590 <__smakebuf_r+0x3c>
8000c574:	8e 65       	ld.sh	r5,r7[0xc]
8000c576:	0a 98       	mov	r8,r5
8000c578:	ab b8       	sbr	r8,0xb
8000c57a:	e2 15 00 80 	andl	r5,0x80,COH
8000c57e:	ae 68       	st.h	r7[0xc],r8
8000c580:	30 04       	mov	r4,0
8000c582:	e0 68 04 00 	mov	r8,1024
8000c586:	f9 b5 01 40 	movne	r5,64
8000c58a:	f0 05 17 00 	moveq	r5,r8
8000c58e:	c1 c8       	rjmp	8000c5c6 <__smakebuf_r+0x72>
8000c590:	40 18       	lddsp	r8,sp[0x4]
8000c592:	e2 18 f0 00 	andl	r8,0xf000,COH
8000c596:	e0 48 20 00 	cp.w	r8,8192
8000c59a:	5f 04       	sreq	r4
8000c59c:	e0 48 80 00 	cp.w	r8,32768
8000c5a0:	c0 e1       	brne	8000c5bc <__smakebuf_r+0x68>
8000c5a2:	6e b9       	ld.w	r9,r7[0x2c]
8000c5a4:	fe c8 f9 1c 	sub	r8,pc,-1764
8000c5a8:	10 39       	cp.w	r9,r8
8000c5aa:	c0 91       	brne	8000c5bc <__smakebuf_r+0x68>
8000c5ac:	8e 68       	ld.sh	r8,r7[0xc]
8000c5ae:	e0 65 04 00 	mov	r5,1024
8000c5b2:	ab a8       	sbr	r8,0xa
8000c5b4:	ef 45 00 50 	st.w	r7[80],r5
8000c5b8:	ae 68       	st.h	r7[0xc],r8
8000c5ba:	c0 68       	rjmp	8000c5c6 <__smakebuf_r+0x72>
8000c5bc:	8e 68       	ld.sh	r8,r7[0xc]
8000c5be:	e0 65 04 00 	mov	r5,1024
8000c5c2:	ab b8       	sbr	r8,0xb
8000c5c4:	ae 68       	st.h	r7[0xc],r8
8000c5c6:	0a 9b       	mov	r11,r5
8000c5c8:	0c 9c       	mov	r12,r6
8000c5ca:	fe b0 df 23 	rcall	80008410 <_malloc_r>
8000c5ce:	8e 68       	ld.sh	r8,r7[0xc]
8000c5d0:	c0 d1       	brne	8000c5ea <__smakebuf_r+0x96>
8000c5d2:	ed b8 00 09 	bld	r8,0x9
8000c5d6:	c1 b0       	breq	8000c60c <__smakebuf_r+0xb8>
8000c5d8:	a1 b8       	sbr	r8,0x1
8000c5da:	ae 68       	st.h	r7[0xc],r8
8000c5dc:	ee c8 ff b9 	sub	r8,r7,-71
8000c5e0:	8f 48       	st.w	r7[0x10],r8
8000c5e2:	8f 08       	st.w	r7[0x0],r8
8000c5e4:	30 18       	mov	r8,1
8000c5e6:	8f 58       	st.w	r7[0x14],r8
8000c5e8:	c1 28       	rjmp	8000c60c <__smakebuf_r+0xb8>
8000c5ea:	a7 b8       	sbr	r8,0x7
8000c5ec:	8f 4c       	st.w	r7[0x10],r12
8000c5ee:	ae 68       	st.h	r7[0xc],r8
8000c5f0:	8f 55       	st.w	r7[0x14],r5
8000c5f2:	fe c8 06 e6 	sub	r8,pc,1766
8000c5f6:	8f 0c       	st.w	r7[0x0],r12
8000c5f8:	8d a8       	st.w	r6[0x28],r8
8000c5fa:	58 04       	cp.w	r4,0
8000c5fc:	c0 80       	breq	8000c60c <__smakebuf_r+0xb8>
8000c5fe:	8e 7c       	ld.sh	r12,r7[0xe]
8000c600:	fe b0 e3 94 	rcall	80008d28 <isatty>
8000c604:	c0 40       	breq	8000c60c <__smakebuf_r+0xb8>
8000c606:	8e 68       	ld.sh	r8,r7[0xc]
8000c608:	a1 a8       	sbr	r8,0x0
8000c60a:	ae 68       	st.h	r7[0xc],r8
8000c60c:	2f 1d       	sub	sp,-60
8000c60e:	d8 22       	popm	r4-r7,pc

8000c610 <memchr>:
8000c610:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000c614:	c0 68       	rjmp	8000c620 <memchr+0x10>
8000c616:	20 1a       	sub	r10,1
8000c618:	19 88       	ld.ub	r8,r12[0x0]
8000c61a:	16 38       	cp.w	r8,r11
8000c61c:	5e 0c       	reteq	r12
8000c61e:	2f fc       	sub	r12,-1
8000c620:	58 0a       	cp.w	r10,0
8000c622:	cf a1       	brne	8000c616 <memchr+0x6>
8000c624:	5e fa       	retal	r10

8000c626 <memmove>:
8000c626:	d4 01       	pushm	lr
8000c628:	18 3b       	cp.w	r11,r12
8000c62a:	c1 92       	brcc	8000c65c <memmove+0x36>
8000c62c:	f6 0a 00 09 	add	r9,r11,r10
8000c630:	12 3c       	cp.w	r12,r9
8000c632:	c1 52       	brcc	8000c65c <memmove+0x36>
8000c634:	f8 0a 00 0b 	add	r11,r12,r10
8000c638:	30 08       	mov	r8,0
8000c63a:	c0 68       	rjmp	8000c646 <memmove+0x20>
8000c63c:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000c640:	20 1a       	sub	r10,1
8000c642:	f6 08 0b 0e 	st.b	r11[r8],lr
8000c646:	20 18       	sub	r8,1
8000c648:	58 0a       	cp.w	r10,0
8000c64a:	cf 91       	brne	8000c63c <memmove+0x16>
8000c64c:	d8 02       	popm	pc
8000c64e:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000c652:	20 1a       	sub	r10,1
8000c654:	f8 08 0b 09 	st.b	r12[r8],r9
8000c658:	2f f8       	sub	r8,-1
8000c65a:	c0 28       	rjmp	8000c65e <memmove+0x38>
8000c65c:	30 08       	mov	r8,0
8000c65e:	58 0a       	cp.w	r10,0
8000c660:	cf 71       	brne	8000c64e <memmove+0x28>
8000c662:	d8 02       	popm	pc

8000c664 <__hi0bits>:
8000c664:	18 98       	mov	r8,r12
8000c666:	e0 1c 00 00 	andl	r12,0x0
8000c66a:	f0 09 15 10 	lsl	r9,r8,0x10
8000c66e:	58 0c       	cp.w	r12,0
8000c670:	f2 08 17 00 	moveq	r8,r9
8000c674:	f9 bc 00 10 	moveq	r12,16
8000c678:	f9 bc 01 00 	movne	r12,0
8000c67c:	10 9a       	mov	r10,r8
8000c67e:	f0 09 15 08 	lsl	r9,r8,0x8
8000c682:	e6 1a ff 00 	andh	r10,0xff00,COH
8000c686:	f7 bc 00 f8 	subeq	r12,-8
8000c68a:	f2 08 17 00 	moveq	r8,r9
8000c68e:	10 9a       	mov	r10,r8
8000c690:	f0 09 15 04 	lsl	r9,r8,0x4
8000c694:	e6 1a f0 00 	andh	r10,0xf000,COH
8000c698:	f7 bc 00 fc 	subeq	r12,-4
8000c69c:	f2 08 17 00 	moveq	r8,r9
8000c6a0:	10 9a       	mov	r10,r8
8000c6a2:	f0 09 15 02 	lsl	r9,r8,0x2
8000c6a6:	e6 1a c0 00 	andh	r10,0xc000,COH
8000c6aa:	f7 bc 00 fe 	subeq	r12,-2
8000c6ae:	f2 08 17 00 	moveq	r8,r9
8000c6b2:	58 08       	cp.w	r8,0
8000c6b4:	5e 5c       	retlt	r12
8000c6b6:	ed b8 00 1e 	bld	r8,0x1e
8000c6ba:	f9 bc 01 20 	movne	r12,32
8000c6be:	f7 bc 00 ff 	subeq	r12,-1
8000c6c2:	5e fc       	retal	r12

8000c6c4 <__lo0bits>:
8000c6c4:	18 99       	mov	r9,r12
8000c6c6:	78 08       	ld.w	r8,r12[0x0]
8000c6c8:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000c6cc:	c1 50       	breq	8000c6f6 <__lo0bits+0x32>
8000c6ce:	ed b8 00 00 	bld	r8,0x0
8000c6d2:	c0 21       	brne	8000c6d6 <__lo0bits+0x12>
8000c6d4:	5e fd       	retal	0
8000c6d6:	10 9b       	mov	r11,r8
8000c6d8:	f0 0a 16 01 	lsr	r10,r8,0x1
8000c6dc:	e2 1b 00 02 	andl	r11,0x2,COH
8000c6e0:	a3 88       	lsr	r8,0x2
8000c6e2:	58 0b       	cp.w	r11,0
8000c6e4:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000c6e8:	f9 bc 01 01 	movne	r12,1
8000c6ec:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000c6f0:	f9 bc 00 02 	moveq	r12,2
8000c6f4:	5e fc       	retal	r12
8000c6f6:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000c6fa:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c6fe:	58 0a       	cp.w	r10,0
8000c700:	f6 08 17 00 	moveq	r8,r11
8000c704:	f9 bc 00 10 	moveq	r12,16
8000c708:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000c70c:	f0 0a 16 08 	lsr	r10,r8,0x8
8000c710:	58 0b       	cp.w	r11,0
8000c712:	f7 bc 00 f8 	subeq	r12,-8
8000c716:	f4 08 17 00 	moveq	r8,r10
8000c71a:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000c71e:	f0 0a 16 04 	lsr	r10,r8,0x4
8000c722:	58 0b       	cp.w	r11,0
8000c724:	f7 bc 00 fc 	subeq	r12,-4
8000c728:	f4 08 17 00 	moveq	r8,r10
8000c72c:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000c730:	f0 0a 16 02 	lsr	r10,r8,0x2
8000c734:	58 0b       	cp.w	r11,0
8000c736:	f7 bc 00 fe 	subeq	r12,-2
8000c73a:	f4 08 17 00 	moveq	r8,r10
8000c73e:	ed b8 00 00 	bld	r8,0x0
8000c742:	c0 60       	breq	8000c74e <__lo0bits+0x8a>
8000c744:	a1 98       	lsr	r8,0x1
8000c746:	c0 31       	brne	8000c74c <__lo0bits+0x88>
8000c748:	32 0c       	mov	r12,32
8000c74a:	5e fc       	retal	r12
8000c74c:	2f fc       	sub	r12,-1
8000c74e:	93 08       	st.w	r9[0x0],r8
8000c750:	5e fc       	retal	r12

8000c752 <__mcmp>:
8000c752:	d4 01       	pushm	lr
8000c754:	18 98       	mov	r8,r12
8000c756:	76 49       	ld.w	r9,r11[0x10]
8000c758:	78 4c       	ld.w	r12,r12[0x10]
8000c75a:	12 1c       	sub	r12,r9
8000c75c:	c1 31       	brne	8000c782 <__mcmp+0x30>
8000c75e:	2f b9       	sub	r9,-5
8000c760:	a3 69       	lsl	r9,0x2
8000c762:	12 0b       	add	r11,r9
8000c764:	f0 09 00 09 	add	r9,r8,r9
8000c768:	2e c8       	sub	r8,-20
8000c76a:	13 4e       	ld.w	lr,--r9
8000c76c:	17 4a       	ld.w	r10,--r11
8000c76e:	14 3e       	cp.w	lr,r10
8000c770:	c0 60       	breq	8000c77c <__mcmp+0x2a>
8000c772:	f9 bc 03 ff 	movlo	r12,-1
8000c776:	f9 bc 02 01 	movhs	r12,1
8000c77a:	d8 02       	popm	pc
8000c77c:	10 39       	cp.w	r9,r8
8000c77e:	fe 9b ff f6 	brhi	8000c76a <__mcmp+0x18>
8000c782:	d8 02       	popm	pc

8000c784 <_Bfree>:
8000c784:	d4 21       	pushm	r4-r7,lr
8000c786:	18 97       	mov	r7,r12
8000c788:	16 95       	mov	r5,r11
8000c78a:	78 96       	ld.w	r6,r12[0x24]
8000c78c:	58 06       	cp.w	r6,0
8000c78e:	c0 91       	brne	8000c7a0 <_Bfree+0x1c>
8000c790:	31 0c       	mov	r12,16
8000c792:	fe b0 de 37 	rcall	80008400 <malloc>
8000c796:	99 36       	st.w	r12[0xc],r6
8000c798:	8f 9c       	st.w	r7[0x24],r12
8000c79a:	99 16       	st.w	r12[0x4],r6
8000c79c:	99 26       	st.w	r12[0x8],r6
8000c79e:	99 06       	st.w	r12[0x0],r6
8000c7a0:	58 05       	cp.w	r5,0
8000c7a2:	c0 90       	breq	8000c7b4 <_Bfree+0x30>
8000c7a4:	6a 19       	ld.w	r9,r5[0x4]
8000c7a6:	6e 98       	ld.w	r8,r7[0x24]
8000c7a8:	70 38       	ld.w	r8,r8[0xc]
8000c7aa:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000c7ae:	8b 0a       	st.w	r5[0x0],r10
8000c7b0:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000c7b4:	d8 22       	popm	r4-r7,pc
8000c7b6:	d7 03       	nop

8000c7b8 <_Balloc>:
8000c7b8:	d4 21       	pushm	r4-r7,lr
8000c7ba:	18 97       	mov	r7,r12
8000c7bc:	16 96       	mov	r6,r11
8000c7be:	78 95       	ld.w	r5,r12[0x24]
8000c7c0:	58 05       	cp.w	r5,0
8000c7c2:	c0 91       	brne	8000c7d4 <_Balloc+0x1c>
8000c7c4:	31 0c       	mov	r12,16
8000c7c6:	fe b0 de 1d 	rcall	80008400 <malloc>
8000c7ca:	99 35       	st.w	r12[0xc],r5
8000c7cc:	8f 9c       	st.w	r7[0x24],r12
8000c7ce:	99 15       	st.w	r12[0x4],r5
8000c7d0:	99 25       	st.w	r12[0x8],r5
8000c7d2:	99 05       	st.w	r12[0x0],r5
8000c7d4:	6e 95       	ld.w	r5,r7[0x24]
8000c7d6:	6a 38       	ld.w	r8,r5[0xc]
8000c7d8:	58 08       	cp.w	r8,0
8000c7da:	c0 b1       	brne	8000c7f0 <_Balloc+0x38>
8000c7dc:	31 0a       	mov	r10,16
8000c7de:	30 4b       	mov	r11,4
8000c7e0:	0e 9c       	mov	r12,r7
8000c7e2:	e0 a0 02 a7 	rcall	8000cd30 <_calloc_r>
8000c7e6:	8b 3c       	st.w	r5[0xc],r12
8000c7e8:	6e 98       	ld.w	r8,r7[0x24]
8000c7ea:	70 3c       	ld.w	r12,r8[0xc]
8000c7ec:	58 0c       	cp.w	r12,0
8000c7ee:	c1 b0       	breq	8000c824 <_Balloc+0x6c>
8000c7f0:	6e 98       	ld.w	r8,r7[0x24]
8000c7f2:	70 38       	ld.w	r8,r8[0xc]
8000c7f4:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000c7f8:	70 0c       	ld.w	r12,r8[0x0]
8000c7fa:	58 0c       	cp.w	r12,0
8000c7fc:	c0 40       	breq	8000c804 <_Balloc+0x4c>
8000c7fe:	78 09       	ld.w	r9,r12[0x0]
8000c800:	91 09       	st.w	r8[0x0],r9
8000c802:	c0 e8       	rjmp	8000c81e <_Balloc+0x66>
8000c804:	0e 9c       	mov	r12,r7
8000c806:	30 17       	mov	r7,1
8000c808:	0e 9b       	mov	r11,r7
8000c80a:	ee 06 09 47 	lsl	r7,r7,r6
8000c80e:	ee ca ff fb 	sub	r10,r7,-5
8000c812:	a3 6a       	lsl	r10,0x2
8000c814:	e0 a0 02 8e 	rcall	8000cd30 <_calloc_r>
8000c818:	c0 60       	breq	8000c824 <_Balloc+0x6c>
8000c81a:	99 16       	st.w	r12[0x4],r6
8000c81c:	99 27       	st.w	r12[0x8],r7
8000c81e:	30 08       	mov	r8,0
8000c820:	99 38       	st.w	r12[0xc],r8
8000c822:	99 48       	st.w	r12[0x10],r8
8000c824:	d8 22       	popm	r4-r7,pc
8000c826:	d7 03       	nop

8000c828 <__d2b>:
8000c828:	d4 31       	pushm	r0-r7,lr
8000c82a:	20 2d       	sub	sp,8
8000c82c:	16 93       	mov	r3,r11
8000c82e:	12 96       	mov	r6,r9
8000c830:	10 95       	mov	r5,r8
8000c832:	14 92       	mov	r2,r10
8000c834:	30 1b       	mov	r11,1
8000c836:	cc 1f       	rcall	8000c7b8 <_Balloc>
8000c838:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000c83c:	50 09       	stdsp	sp[0x0],r9
8000c83e:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000c842:	b5 a9       	sbr	r9,0x14
8000c844:	f0 01 16 14 	lsr	r1,r8,0x14
8000c848:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000c84c:	18 94       	mov	r4,r12
8000c84e:	58 02       	cp.w	r2,0
8000c850:	c1 d0       	breq	8000c88a <__d2b+0x62>
8000c852:	fa cc ff f8 	sub	r12,sp,-8
8000c856:	18 d2       	st.w	--r12,r2
8000c858:	c3 6f       	rcall	8000c6c4 <__lo0bits>
8000c85a:	40 18       	lddsp	r8,sp[0x4]
8000c85c:	c0 d0       	breq	8000c876 <__d2b+0x4e>
8000c85e:	40 09       	lddsp	r9,sp[0x0]
8000c860:	f8 0a 11 20 	rsub	r10,r12,32
8000c864:	f2 0a 09 4a 	lsl	r10,r9,r10
8000c868:	f5 e8 10 08 	or	r8,r10,r8
8000c86c:	89 58       	st.w	r4[0x14],r8
8000c86e:	f2 0c 0a 49 	lsr	r9,r9,r12
8000c872:	50 09       	stdsp	sp[0x0],r9
8000c874:	c0 28       	rjmp	8000c878 <__d2b+0x50>
8000c876:	89 58       	st.w	r4[0x14],r8
8000c878:	40 08       	lddsp	r8,sp[0x0]
8000c87a:	58 08       	cp.w	r8,0
8000c87c:	f9 b3 01 02 	movne	r3,2
8000c880:	f9 b3 00 01 	moveq	r3,1
8000c884:	89 68       	st.w	r4[0x18],r8
8000c886:	89 43       	st.w	r4[0x10],r3
8000c888:	c0 88       	rjmp	8000c898 <__d2b+0x70>
8000c88a:	1a 9c       	mov	r12,sp
8000c88c:	c1 cf       	rcall	8000c6c4 <__lo0bits>
8000c88e:	30 13       	mov	r3,1
8000c890:	40 08       	lddsp	r8,sp[0x0]
8000c892:	2e 0c       	sub	r12,-32
8000c894:	89 43       	st.w	r4[0x10],r3
8000c896:	89 58       	st.w	r4[0x14],r8
8000c898:	58 01       	cp.w	r1,0
8000c89a:	c0 90       	breq	8000c8ac <__d2b+0x84>
8000c89c:	e2 c1 04 33 	sub	r1,r1,1075
8000c8a0:	18 01       	add	r1,r12
8000c8a2:	8d 01       	st.w	r6[0x0],r1
8000c8a4:	f8 0c 11 35 	rsub	r12,r12,53
8000c8a8:	8b 0c       	st.w	r5[0x0],r12
8000c8aa:	c0 c8       	rjmp	8000c8c2 <__d2b+0x9a>
8000c8ac:	e6 c8 ff fc 	sub	r8,r3,-4
8000c8b0:	f8 cc 04 32 	sub	r12,r12,1074
8000c8b4:	a5 73       	lsl	r3,0x5
8000c8b6:	8d 0c       	st.w	r6[0x0],r12
8000c8b8:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000c8bc:	cd 4e       	rcall	8000c664 <__hi0bits>
8000c8be:	18 13       	sub	r3,r12
8000c8c0:	8b 03       	st.w	r5[0x0],r3
8000c8c2:	08 9c       	mov	r12,r4
8000c8c4:	2f ed       	sub	sp,-8
8000c8c6:	d8 32       	popm	r0-r7,pc

8000c8c8 <__mdiff>:
8000c8c8:	d4 31       	pushm	r0-r7,lr
8000c8ca:	74 48       	ld.w	r8,r10[0x10]
8000c8cc:	76 45       	ld.w	r5,r11[0x10]
8000c8ce:	16 97       	mov	r7,r11
8000c8d0:	14 96       	mov	r6,r10
8000c8d2:	10 15       	sub	r5,r8
8000c8d4:	c1 31       	brne	8000c8fa <__mdiff+0x32>
8000c8d6:	2f b8       	sub	r8,-5
8000c8d8:	ee ce ff ec 	sub	lr,r7,-20
8000c8dc:	a3 68       	lsl	r8,0x2
8000c8de:	f4 08 00 0b 	add	r11,r10,r8
8000c8e2:	ee 08 00 08 	add	r8,r7,r8
8000c8e6:	11 4a       	ld.w	r10,--r8
8000c8e8:	17 49       	ld.w	r9,--r11
8000c8ea:	12 3a       	cp.w	r10,r9
8000c8ec:	c0 30       	breq	8000c8f2 <__mdiff+0x2a>
8000c8ee:	c0 e2       	brcc	8000c90a <__mdiff+0x42>
8000c8f0:	c0 78       	rjmp	8000c8fe <__mdiff+0x36>
8000c8f2:	1c 38       	cp.w	r8,lr
8000c8f4:	fe 9b ff f9 	brhi	8000c8e6 <__mdiff+0x1e>
8000c8f8:	c4 98       	rjmp	8000c98a <__mdiff+0xc2>
8000c8fa:	58 05       	cp.w	r5,0
8000c8fc:	c0 64       	brge	8000c908 <__mdiff+0x40>
8000c8fe:	0e 98       	mov	r8,r7
8000c900:	30 15       	mov	r5,1
8000c902:	0c 97       	mov	r7,r6
8000c904:	10 96       	mov	r6,r8
8000c906:	c0 28       	rjmp	8000c90a <__mdiff+0x42>
8000c908:	30 05       	mov	r5,0
8000c90a:	6e 1b       	ld.w	r11,r7[0x4]
8000c90c:	c5 6f       	rcall	8000c7b8 <_Balloc>
8000c90e:	6e 49       	ld.w	r9,r7[0x10]
8000c910:	6c 44       	ld.w	r4,r6[0x10]
8000c912:	99 35       	st.w	r12[0xc],r5
8000c914:	2f b4       	sub	r4,-5
8000c916:	f2 c5 ff fb 	sub	r5,r9,-5
8000c91a:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000c91e:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000c922:	2e c6       	sub	r6,-20
8000c924:	2e c7       	sub	r7,-20
8000c926:	f8 c8 ff ec 	sub	r8,r12,-20
8000c92a:	30 0a       	mov	r10,0
8000c92c:	0f 0e       	ld.w	lr,r7++
8000c92e:	0d 0b       	ld.w	r11,r6++
8000c930:	fc 02 16 10 	lsr	r2,lr,0x10
8000c934:	f6 03 16 10 	lsr	r3,r11,0x10
8000c938:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c93c:	e4 03 01 03 	sub	r3,r2,r3
8000c940:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c944:	fc 0b 01 0b 	sub	r11,lr,r11
8000c948:	f6 0a 00 0a 	add	r10,r11,r10
8000c94c:	b0 1a       	st.h	r8[0x2],r10
8000c94e:	b1 4a       	asr	r10,0x10
8000c950:	e6 0a 00 0a 	add	r10,r3,r10
8000c954:	b0 0a       	st.h	r8[0x0],r10
8000c956:	2f c8       	sub	r8,-4
8000c958:	b1 4a       	asr	r10,0x10
8000c95a:	08 36       	cp.w	r6,r4
8000c95c:	ce 83       	brcs	8000c92c <__mdiff+0x64>
8000c95e:	c0 d8       	rjmp	8000c978 <__mdiff+0xb0>
8000c960:	0f 0b       	ld.w	r11,r7++
8000c962:	f6 0e 16 10 	lsr	lr,r11,0x10
8000c966:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c96a:	16 0a       	add	r10,r11
8000c96c:	b0 1a       	st.h	r8[0x2],r10
8000c96e:	b1 4a       	asr	r10,0x10
8000c970:	1c 0a       	add	r10,lr
8000c972:	b0 0a       	st.h	r8[0x0],r10
8000c974:	2f c8       	sub	r8,-4
8000c976:	b1 4a       	asr	r10,0x10
8000c978:	0a 37       	cp.w	r7,r5
8000c97a:	cf 33       	brcs	8000c960 <__mdiff+0x98>
8000c97c:	c0 28       	rjmp	8000c980 <__mdiff+0xb8>
8000c97e:	20 19       	sub	r9,1
8000c980:	11 4a       	ld.w	r10,--r8
8000c982:	58 0a       	cp.w	r10,0
8000c984:	cf d0       	breq	8000c97e <__mdiff+0xb6>
8000c986:	99 49       	st.w	r12[0x10],r9
8000c988:	d8 32       	popm	r0-r7,pc
8000c98a:	30 0b       	mov	r11,0
8000c98c:	c1 6f       	rcall	8000c7b8 <_Balloc>
8000c98e:	30 18       	mov	r8,1
8000c990:	99 48       	st.w	r12[0x10],r8
8000c992:	30 08       	mov	r8,0
8000c994:	99 58       	st.w	r12[0x14],r8
8000c996:	d8 32       	popm	r0-r7,pc

8000c998 <__lshift>:
8000c998:	d4 31       	pushm	r0-r7,lr
8000c99a:	16 97       	mov	r7,r11
8000c99c:	76 46       	ld.w	r6,r11[0x10]
8000c99e:	f4 02 14 05 	asr	r2,r10,0x5
8000c9a2:	2f f6       	sub	r6,-1
8000c9a4:	14 93       	mov	r3,r10
8000c9a6:	18 94       	mov	r4,r12
8000c9a8:	04 06       	add	r6,r2
8000c9aa:	76 1b       	ld.w	r11,r11[0x4]
8000c9ac:	6e 28       	ld.w	r8,r7[0x8]
8000c9ae:	c0 38       	rjmp	8000c9b4 <__lshift+0x1c>
8000c9b0:	2f fb       	sub	r11,-1
8000c9b2:	a1 78       	lsl	r8,0x1
8000c9b4:	10 36       	cp.w	r6,r8
8000c9b6:	fe 99 ff fd 	brgt	8000c9b0 <__lshift+0x18>
8000c9ba:	08 9c       	mov	r12,r4
8000c9bc:	cf ee       	rcall	8000c7b8 <_Balloc>
8000c9be:	30 09       	mov	r9,0
8000c9c0:	18 95       	mov	r5,r12
8000c9c2:	f8 c8 ff ec 	sub	r8,r12,-20
8000c9c6:	12 9a       	mov	r10,r9
8000c9c8:	c0 38       	rjmp	8000c9ce <__lshift+0x36>
8000c9ca:	10 aa       	st.w	r8++,r10
8000c9cc:	2f f9       	sub	r9,-1
8000c9ce:	04 39       	cp.w	r9,r2
8000c9d0:	cf d5       	brlt	8000c9ca <__lshift+0x32>
8000c9d2:	6e 4b       	ld.w	r11,r7[0x10]
8000c9d4:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000c9d8:	2f bb       	sub	r11,-5
8000c9da:	ee c9 ff ec 	sub	r9,r7,-20
8000c9de:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000c9e2:	58 03       	cp.w	r3,0
8000c9e4:	c1 30       	breq	8000ca0a <__lshift+0x72>
8000c9e6:	e6 0c 11 20 	rsub	r12,r3,32
8000c9ea:	30 0a       	mov	r10,0
8000c9ec:	72 02       	ld.w	r2,r9[0x0]
8000c9ee:	e4 03 09 42 	lsl	r2,r2,r3
8000c9f2:	04 4a       	or	r10,r2
8000c9f4:	10 aa       	st.w	r8++,r10
8000c9f6:	13 0a       	ld.w	r10,r9++
8000c9f8:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c9fc:	16 39       	cp.w	r9,r11
8000c9fe:	cf 73       	brcs	8000c9ec <__lshift+0x54>
8000ca00:	91 0a       	st.w	r8[0x0],r10
8000ca02:	58 0a       	cp.w	r10,0
8000ca04:	c0 70       	breq	8000ca12 <__lshift+0x7a>
8000ca06:	2f f6       	sub	r6,-1
8000ca08:	c0 58       	rjmp	8000ca12 <__lshift+0x7a>
8000ca0a:	13 0a       	ld.w	r10,r9++
8000ca0c:	10 aa       	st.w	r8++,r10
8000ca0e:	16 39       	cp.w	r9,r11
8000ca10:	cf d3       	brcs	8000ca0a <__lshift+0x72>
8000ca12:	08 9c       	mov	r12,r4
8000ca14:	20 16       	sub	r6,1
8000ca16:	0e 9b       	mov	r11,r7
8000ca18:	8b 46       	st.w	r5[0x10],r6
8000ca1a:	cb 5e       	rcall	8000c784 <_Bfree>
8000ca1c:	0a 9c       	mov	r12,r5
8000ca1e:	d8 32       	popm	r0-r7,pc

8000ca20 <__multiply>:
8000ca20:	d4 31       	pushm	r0-r7,lr
8000ca22:	20 2d       	sub	sp,8
8000ca24:	76 49       	ld.w	r9,r11[0x10]
8000ca26:	74 48       	ld.w	r8,r10[0x10]
8000ca28:	16 96       	mov	r6,r11
8000ca2a:	14 95       	mov	r5,r10
8000ca2c:	10 39       	cp.w	r9,r8
8000ca2e:	ec 08 17 50 	movlt	r8,r6
8000ca32:	ea 06 17 50 	movlt	r6,r5
8000ca36:	f0 05 17 50 	movlt	r5,r8
8000ca3a:	6c 28       	ld.w	r8,r6[0x8]
8000ca3c:	76 43       	ld.w	r3,r11[0x10]
8000ca3e:	74 42       	ld.w	r2,r10[0x10]
8000ca40:	76 1b       	ld.w	r11,r11[0x4]
8000ca42:	e4 03 00 07 	add	r7,r2,r3
8000ca46:	10 37       	cp.w	r7,r8
8000ca48:	f7 bb 09 ff 	subgt	r11,-1
8000ca4c:	cb 6e       	rcall	8000c7b8 <_Balloc>
8000ca4e:	ee c4 ff fb 	sub	r4,r7,-5
8000ca52:	f8 c9 ff ec 	sub	r9,r12,-20
8000ca56:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000ca5a:	30 0a       	mov	r10,0
8000ca5c:	12 98       	mov	r8,r9
8000ca5e:	c0 28       	rjmp	8000ca62 <__multiply+0x42>
8000ca60:	10 aa       	st.w	r8++,r10
8000ca62:	08 38       	cp.w	r8,r4
8000ca64:	cf e3       	brcs	8000ca60 <__multiply+0x40>
8000ca66:	2f b3       	sub	r3,-5
8000ca68:	2f b2       	sub	r2,-5
8000ca6a:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000ca6e:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000ca72:	ec cb ff ec 	sub	r11,r6,-20
8000ca76:	50 12       	stdsp	sp[0x4],r2
8000ca78:	ea ca ff ec 	sub	r10,r5,-20
8000ca7c:	c4 48       	rjmp	8000cb04 <__multiply+0xe4>
8000ca7e:	94 95       	ld.uh	r5,r10[0x2]
8000ca80:	58 05       	cp.w	r5,0
8000ca82:	c2 00       	breq	8000cac2 <__multiply+0xa2>
8000ca84:	12 98       	mov	r8,r9
8000ca86:	16 96       	mov	r6,r11
8000ca88:	30 0e       	mov	lr,0
8000ca8a:	50 09       	stdsp	sp[0x0],r9
8000ca8c:	0d 02       	ld.w	r2,r6++
8000ca8e:	e4 00 16 10 	lsr	r0,r2,0x10
8000ca92:	70 01       	ld.w	r1,r8[0x0]
8000ca94:	70 09       	ld.w	r9,r8[0x0]
8000ca96:	b1 81       	lsr	r1,0x10
8000ca98:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000ca9c:	e0 05 03 41 	mac	r1,r0,r5
8000caa0:	ab 32       	mul	r2,r5
8000caa2:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000caa6:	00 02       	add	r2,r0
8000caa8:	e4 0e 00 0e 	add	lr,r2,lr
8000caac:	b0 1e       	st.h	r8[0x2],lr
8000caae:	b1 8e       	lsr	lr,0x10
8000cab0:	1c 01       	add	r1,lr
8000cab2:	b0 01       	st.h	r8[0x0],r1
8000cab4:	e2 0e 16 10 	lsr	lr,r1,0x10
8000cab8:	2f c8       	sub	r8,-4
8000caba:	06 36       	cp.w	r6,r3
8000cabc:	ce 83       	brcs	8000ca8c <__multiply+0x6c>
8000cabe:	40 09       	lddsp	r9,sp[0x0]
8000cac0:	91 0e       	st.w	r8[0x0],lr
8000cac2:	94 86       	ld.uh	r6,r10[0x0]
8000cac4:	58 06       	cp.w	r6,0
8000cac6:	c1 d0       	breq	8000cb00 <__multiply+0xe0>
8000cac8:	72 02       	ld.w	r2,r9[0x0]
8000caca:	12 98       	mov	r8,r9
8000cacc:	16 9e       	mov	lr,r11
8000cace:	30 05       	mov	r5,0
8000cad0:	b0 12       	st.h	r8[0x2],r2
8000cad2:	1d 01       	ld.w	r1,lr++
8000cad4:	90 82       	ld.uh	r2,r8[0x0]
8000cad6:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000cada:	ad 30       	mul	r0,r6
8000cadc:	e0 02 00 02 	add	r2,r0,r2
8000cae0:	e4 05 00 05 	add	r5,r2,r5
8000cae4:	b0 05       	st.h	r8[0x0],r5
8000cae6:	b1 85       	lsr	r5,0x10
8000cae8:	b1 81       	lsr	r1,0x10
8000caea:	2f c8       	sub	r8,-4
8000caec:	ad 31       	mul	r1,r6
8000caee:	90 92       	ld.uh	r2,r8[0x2]
8000caf0:	e2 02 00 02 	add	r2,r1,r2
8000caf4:	0a 02       	add	r2,r5
8000caf6:	e4 05 16 10 	lsr	r5,r2,0x10
8000cafa:	06 3e       	cp.w	lr,r3
8000cafc:	ce a3       	brcs	8000cad0 <__multiply+0xb0>
8000cafe:	91 02       	st.w	r8[0x0],r2
8000cb00:	2f ca       	sub	r10,-4
8000cb02:	2f c9       	sub	r9,-4
8000cb04:	40 18       	lddsp	r8,sp[0x4]
8000cb06:	10 3a       	cp.w	r10,r8
8000cb08:	cb b3       	brcs	8000ca7e <__multiply+0x5e>
8000cb0a:	c0 28       	rjmp	8000cb0e <__multiply+0xee>
8000cb0c:	20 17       	sub	r7,1
8000cb0e:	58 07       	cp.w	r7,0
8000cb10:	e0 8a 00 05 	brle	8000cb1a <__multiply+0xfa>
8000cb14:	09 48       	ld.w	r8,--r4
8000cb16:	58 08       	cp.w	r8,0
8000cb18:	cf a0       	breq	8000cb0c <__multiply+0xec>
8000cb1a:	99 47       	st.w	r12[0x10],r7
8000cb1c:	2f ed       	sub	sp,-8
8000cb1e:	d8 32       	popm	r0-r7,pc

8000cb20 <__i2b>:
8000cb20:	d4 21       	pushm	r4-r7,lr
8000cb22:	16 97       	mov	r7,r11
8000cb24:	30 1b       	mov	r11,1
8000cb26:	c4 9e       	rcall	8000c7b8 <_Balloc>
8000cb28:	30 19       	mov	r9,1
8000cb2a:	99 57       	st.w	r12[0x14],r7
8000cb2c:	99 49       	st.w	r12[0x10],r9
8000cb2e:	d8 22       	popm	r4-r7,pc

8000cb30 <__multadd>:
8000cb30:	d4 31       	pushm	r0-r7,lr
8000cb32:	30 08       	mov	r8,0
8000cb34:	12 95       	mov	r5,r9
8000cb36:	16 97       	mov	r7,r11
8000cb38:	18 96       	mov	r6,r12
8000cb3a:	76 44       	ld.w	r4,r11[0x10]
8000cb3c:	f6 c9 ff ec 	sub	r9,r11,-20
8000cb40:	72 0b       	ld.w	r11,r9[0x0]
8000cb42:	f6 0c 16 10 	lsr	r12,r11,0x10
8000cb46:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000cb4a:	f4 0c 02 4c 	mul	r12,r10,r12
8000cb4e:	f4 0b 03 45 	mac	r5,r10,r11
8000cb52:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000cb56:	b1 85       	lsr	r5,0x10
8000cb58:	18 05       	add	r5,r12
8000cb5a:	ea 0c 15 10 	lsl	r12,r5,0x10
8000cb5e:	f8 0b 00 0b 	add	r11,r12,r11
8000cb62:	12 ab       	st.w	r9++,r11
8000cb64:	2f f8       	sub	r8,-1
8000cb66:	b1 85       	lsr	r5,0x10
8000cb68:	08 38       	cp.w	r8,r4
8000cb6a:	ce b5       	brlt	8000cb40 <__multadd+0x10>
8000cb6c:	58 05       	cp.w	r5,0
8000cb6e:	c1 c0       	breq	8000cba6 <__multadd+0x76>
8000cb70:	6e 28       	ld.w	r8,r7[0x8]
8000cb72:	10 34       	cp.w	r4,r8
8000cb74:	c1 35       	brlt	8000cb9a <__multadd+0x6a>
8000cb76:	6e 1b       	ld.w	r11,r7[0x4]
8000cb78:	0c 9c       	mov	r12,r6
8000cb7a:	2f fb       	sub	r11,-1
8000cb7c:	c1 ee       	rcall	8000c7b8 <_Balloc>
8000cb7e:	6e 4a       	ld.w	r10,r7[0x10]
8000cb80:	ee cb ff f4 	sub	r11,r7,-12
8000cb84:	18 93       	mov	r3,r12
8000cb86:	2f ea       	sub	r10,-2
8000cb88:	2f 4c       	sub	r12,-12
8000cb8a:	a3 6a       	lsl	r10,0x2
8000cb8c:	fe b0 de 71 	rcall	8000886e <memcpy>
8000cb90:	0e 9b       	mov	r11,r7
8000cb92:	0c 9c       	mov	r12,r6
8000cb94:	fe b0 fd f8 	rcall	8000c784 <_Bfree>
8000cb98:	06 97       	mov	r7,r3
8000cb9a:	e8 c8 ff ff 	sub	r8,r4,-1
8000cb9e:	2f b4       	sub	r4,-5
8000cba0:	8f 48       	st.w	r7[0x10],r8
8000cba2:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000cba6:	0e 9c       	mov	r12,r7
8000cba8:	d8 32       	popm	r0-r7,pc
8000cbaa:	d7 03       	nop

8000cbac <__pow5mult>:
8000cbac:	d4 31       	pushm	r0-r7,lr
8000cbae:	14 96       	mov	r6,r10
8000cbb0:	18 97       	mov	r7,r12
8000cbb2:	16 94       	mov	r4,r11
8000cbb4:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000cbb8:	c0 90       	breq	8000cbca <__pow5mult+0x1e>
8000cbba:	20 18       	sub	r8,1
8000cbbc:	fe c9 d6 78 	sub	r9,pc,-10632
8000cbc0:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000cbc4:	30 09       	mov	r9,0
8000cbc6:	cb 5f       	rcall	8000cb30 <__multadd>
8000cbc8:	18 94       	mov	r4,r12
8000cbca:	a3 46       	asr	r6,0x2
8000cbcc:	c3 40       	breq	8000cc34 <__pow5mult+0x88>
8000cbce:	6e 95       	ld.w	r5,r7[0x24]
8000cbd0:	58 05       	cp.w	r5,0
8000cbd2:	c0 91       	brne	8000cbe4 <__pow5mult+0x38>
8000cbd4:	31 0c       	mov	r12,16
8000cbd6:	fe b0 dc 15 	rcall	80008400 <malloc>
8000cbda:	99 35       	st.w	r12[0xc],r5
8000cbdc:	8f 9c       	st.w	r7[0x24],r12
8000cbde:	99 15       	st.w	r12[0x4],r5
8000cbe0:	99 25       	st.w	r12[0x8],r5
8000cbe2:	99 05       	st.w	r12[0x0],r5
8000cbe4:	6e 93       	ld.w	r3,r7[0x24]
8000cbe6:	66 25       	ld.w	r5,r3[0x8]
8000cbe8:	58 05       	cp.w	r5,0
8000cbea:	c0 c1       	brne	8000cc02 <__pow5mult+0x56>
8000cbec:	e0 6b 02 71 	mov	r11,625
8000cbf0:	0e 9c       	mov	r12,r7
8000cbf2:	c9 7f       	rcall	8000cb20 <__i2b>
8000cbf4:	87 2c       	st.w	r3[0x8],r12
8000cbf6:	30 08       	mov	r8,0
8000cbf8:	18 95       	mov	r5,r12
8000cbfa:	99 08       	st.w	r12[0x0],r8
8000cbfc:	c0 38       	rjmp	8000cc02 <__pow5mult+0x56>
8000cbfe:	06 9c       	mov	r12,r3
8000cc00:	18 95       	mov	r5,r12
8000cc02:	ed b6 00 00 	bld	r6,0x0
8000cc06:	c0 b1       	brne	8000cc1c <__pow5mult+0x70>
8000cc08:	08 9b       	mov	r11,r4
8000cc0a:	0a 9a       	mov	r10,r5
8000cc0c:	0e 9c       	mov	r12,r7
8000cc0e:	c0 9f       	rcall	8000ca20 <__multiply>
8000cc10:	08 9b       	mov	r11,r4
8000cc12:	18 93       	mov	r3,r12
8000cc14:	0e 9c       	mov	r12,r7
8000cc16:	06 94       	mov	r4,r3
8000cc18:	fe b0 fd b6 	rcall	8000c784 <_Bfree>
8000cc1c:	a1 56       	asr	r6,0x1
8000cc1e:	c0 b0       	breq	8000cc34 <__pow5mult+0x88>
8000cc20:	6a 03       	ld.w	r3,r5[0x0]
8000cc22:	58 03       	cp.w	r3,0
8000cc24:	ce d1       	brne	8000cbfe <__pow5mult+0x52>
8000cc26:	0a 9a       	mov	r10,r5
8000cc28:	0a 9b       	mov	r11,r5
8000cc2a:	0e 9c       	mov	r12,r7
8000cc2c:	cf ae       	rcall	8000ca20 <__multiply>
8000cc2e:	8b 0c       	st.w	r5[0x0],r12
8000cc30:	99 03       	st.w	r12[0x0],r3
8000cc32:	ce 7b       	rjmp	8000cc00 <__pow5mult+0x54>
8000cc34:	08 9c       	mov	r12,r4
8000cc36:	d8 32       	popm	r0-r7,pc

8000cc38 <__isinfd>:
8000cc38:	14 98       	mov	r8,r10
8000cc3a:	fc 19 7f f0 	movh	r9,0x7ff0
8000cc3e:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000cc42:	f0 0b 11 00 	rsub	r11,r8,0
8000cc46:	f7 e8 10 08 	or	r8,r11,r8
8000cc4a:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000cc4e:	f2 08 01 08 	sub	r8,r9,r8
8000cc52:	f0 0c 11 00 	rsub	r12,r8,0
8000cc56:	f9 e8 10 08 	or	r8,r12,r8
8000cc5a:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000cc5e:	2f fc       	sub	r12,-1
8000cc60:	5e fc       	retal	r12

8000cc62 <__isnand>:
8000cc62:	14 98       	mov	r8,r10
8000cc64:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000cc68:	f0 0c 11 00 	rsub	r12,r8,0
8000cc6c:	10 4c       	or	r12,r8
8000cc6e:	fc 18 7f f0 	movh	r8,0x7ff0
8000cc72:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000cc76:	f0 0c 01 0c 	sub	r12,r8,r12
8000cc7a:	bf 9c       	lsr	r12,0x1f
8000cc7c:	5e fc       	retal	r12
8000cc7e:	d7 03       	nop

8000cc80 <__sclose>:
8000cc80:	d4 01       	pushm	lr
8000cc82:	96 7b       	ld.sh	r11,r11[0xe]
8000cc84:	c8 2c       	rcall	8000cd88 <_close_r>
8000cc86:	d8 02       	popm	pc

8000cc88 <__sseek>:
8000cc88:	d4 21       	pushm	r4-r7,lr
8000cc8a:	16 97       	mov	r7,r11
8000cc8c:	96 7b       	ld.sh	r11,r11[0xe]
8000cc8e:	c0 3d       	rcall	8000ce94 <_lseek_r>
8000cc90:	8e 68       	ld.sh	r8,r7[0xc]
8000cc92:	10 99       	mov	r9,r8
8000cc94:	ad c8       	cbr	r8,0xc
8000cc96:	ad a9       	sbr	r9,0xc
8000cc98:	5b fc       	cp.w	r12,-1
8000cc9a:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000cc9e:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000cca2:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000cca6:	d8 22       	popm	r4-r7,pc

8000cca8 <__swrite>:
8000cca8:	d4 21       	pushm	r4-r7,lr
8000ccaa:	96 68       	ld.sh	r8,r11[0xc]
8000ccac:	16 97       	mov	r7,r11
8000ccae:	14 95       	mov	r5,r10
8000ccb0:	12 94       	mov	r4,r9
8000ccb2:	e2 18 01 00 	andl	r8,0x100,COH
8000ccb6:	18 96       	mov	r6,r12
8000ccb8:	c0 50       	breq	8000ccc2 <__swrite+0x1a>
8000ccba:	30 29       	mov	r9,2
8000ccbc:	30 0a       	mov	r10,0
8000ccbe:	96 7b       	ld.sh	r11,r11[0xe]
8000ccc0:	ce ac       	rcall	8000ce94 <_lseek_r>
8000ccc2:	8e 68       	ld.sh	r8,r7[0xc]
8000ccc4:	ad c8       	cbr	r8,0xc
8000ccc6:	08 99       	mov	r9,r4
8000ccc8:	0a 9a       	mov	r10,r5
8000ccca:	8e 7b       	ld.sh	r11,r7[0xe]
8000cccc:	0c 9c       	mov	r12,r6
8000ccce:	ae 68       	st.h	r7[0xc],r8
8000ccd0:	c1 cc       	rcall	8000cd08 <_write_r>
8000ccd2:	d8 22       	popm	r4-r7,pc

8000ccd4 <__sread>:
8000ccd4:	d4 21       	pushm	r4-r7,lr
8000ccd6:	16 97       	mov	r7,r11
8000ccd8:	96 7b       	ld.sh	r11,r11[0xe]
8000ccda:	cf 1c       	rcall	8000cebc <_read_r>
8000ccdc:	c0 65       	brlt	8000cce8 <__sread+0x14>
8000ccde:	6f 58       	ld.w	r8,r7[0x54]
8000cce0:	18 08       	add	r8,r12
8000cce2:	ef 48 00 54 	st.w	r7[84],r8
8000cce6:	d8 22       	popm	r4-r7,pc
8000cce8:	8e 68       	ld.sh	r8,r7[0xc]
8000ccea:	ad c8       	cbr	r8,0xc
8000ccec:	ae 68       	st.h	r7[0xc],r8
8000ccee:	d8 22       	popm	r4-r7,pc

8000ccf0 <strlen>:
8000ccf0:	30 09       	mov	r9,0
8000ccf2:	18 98       	mov	r8,r12
8000ccf4:	c0 28       	rjmp	8000ccf8 <strlen+0x8>
8000ccf6:	2f f8       	sub	r8,-1
8000ccf8:	11 8a       	ld.ub	r10,r8[0x0]
8000ccfa:	f2 0a 18 00 	cp.b	r10,r9
8000ccfe:	cf c1       	brne	8000ccf6 <strlen+0x6>
8000cd00:	f0 0c 01 0c 	sub	r12,r8,r12
8000cd04:	5e fc       	retal	r12
8000cd06:	d7 03       	nop

8000cd08 <_write_r>:
8000cd08:	d4 21       	pushm	r4-r7,lr
8000cd0a:	16 98       	mov	r8,r11
8000cd0c:	18 97       	mov	r7,r12
8000cd0e:	10 9c       	mov	r12,r8
8000cd10:	30 08       	mov	r8,0
8000cd12:	14 9b       	mov	r11,r10
8000cd14:	e0 66 bd 50 	mov	r6,48464
8000cd18:	12 9a       	mov	r10,r9
8000cd1a:	8d 08       	st.w	r6[0x0],r8
8000cd1c:	fe b0 d1 5c 	rcall	80006fd4 <_write>
8000cd20:	5b fc       	cp.w	r12,-1
8000cd22:	c0 51       	brne	8000cd2c <_write_r+0x24>
8000cd24:	6c 08       	ld.w	r8,r6[0x0]
8000cd26:	58 08       	cp.w	r8,0
8000cd28:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000cd2c:	d8 22       	popm	r4-r7,pc
8000cd2e:	d7 03       	nop

8000cd30 <_calloc_r>:
8000cd30:	d4 21       	pushm	r4-r7,lr
8000cd32:	f4 0b 02 4b 	mul	r11,r10,r11
8000cd36:	fe b0 db 6d 	rcall	80008410 <_malloc_r>
8000cd3a:	18 97       	mov	r7,r12
8000cd3c:	c2 30       	breq	8000cd82 <_calloc_r+0x52>
8000cd3e:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000cd42:	e0 1a ff fc 	andl	r10,0xfffc
8000cd46:	20 4a       	sub	r10,4
8000cd48:	e0 4a 00 24 	cp.w	r10,36
8000cd4c:	e0 8b 00 18 	brhi	8000cd7c <_calloc_r+0x4c>
8000cd50:	18 98       	mov	r8,r12
8000cd52:	59 3a       	cp.w	r10,19
8000cd54:	e0 88 00 0f 	brls	8000cd72 <_calloc_r+0x42>
8000cd58:	30 09       	mov	r9,0
8000cd5a:	10 a9       	st.w	r8++,r9
8000cd5c:	10 a9       	st.w	r8++,r9
8000cd5e:	59 ba       	cp.w	r10,27
8000cd60:	e0 88 00 09 	brls	8000cd72 <_calloc_r+0x42>
8000cd64:	10 a9       	st.w	r8++,r9
8000cd66:	10 a9       	st.w	r8++,r9
8000cd68:	e0 4a 00 24 	cp.w	r10,36
8000cd6c:	c0 31       	brne	8000cd72 <_calloc_r+0x42>
8000cd6e:	10 a9       	st.w	r8++,r9
8000cd70:	10 a9       	st.w	r8++,r9
8000cd72:	30 09       	mov	r9,0
8000cd74:	10 a9       	st.w	r8++,r9
8000cd76:	91 19       	st.w	r8[0x4],r9
8000cd78:	91 09       	st.w	r8[0x0],r9
8000cd7a:	c0 48       	rjmp	8000cd82 <_calloc_r+0x52>
8000cd7c:	30 0b       	mov	r11,0
8000cd7e:	fe b0 de 1c 	rcall	800089b6 <memset>
8000cd82:	0e 9c       	mov	r12,r7
8000cd84:	d8 22       	popm	r4-r7,pc
8000cd86:	d7 03       	nop

8000cd88 <_close_r>:
8000cd88:	d4 21       	pushm	r4-r7,lr
8000cd8a:	30 08       	mov	r8,0
8000cd8c:	18 97       	mov	r7,r12
8000cd8e:	e0 66 bd 50 	mov	r6,48464
8000cd92:	16 9c       	mov	r12,r11
8000cd94:	8d 08       	st.w	r6[0x0],r8
8000cd96:	fe b0 df b5 	rcall	80008d00 <_close>
8000cd9a:	5b fc       	cp.w	r12,-1
8000cd9c:	c0 51       	brne	8000cda6 <_close_r+0x1e>
8000cd9e:	6c 08       	ld.w	r8,r6[0x0]
8000cda0:	58 08       	cp.w	r8,0
8000cda2:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000cda6:	d8 22       	popm	r4-r7,pc

8000cda8 <_fclose_r>:
8000cda8:	d4 21       	pushm	r4-r7,lr
8000cdaa:	18 96       	mov	r6,r12
8000cdac:	16 97       	mov	r7,r11
8000cdae:	58 0b       	cp.w	r11,0
8000cdb0:	c0 31       	brne	8000cdb6 <_fclose_r+0xe>
8000cdb2:	16 95       	mov	r5,r11
8000cdb4:	c5 38       	rjmp	8000ce5a <_fclose_r+0xb2>
8000cdb6:	fe b0 f8 a9 	rcall	8000bf08 <__sfp_lock_acquire>
8000cdba:	58 06       	cp.w	r6,0
8000cdbc:	c0 70       	breq	8000cdca <_fclose_r+0x22>
8000cdbe:	6c 68       	ld.w	r8,r6[0x18]
8000cdc0:	58 08       	cp.w	r8,0
8000cdc2:	c0 41       	brne	8000cdca <_fclose_r+0x22>
8000cdc4:	0c 9c       	mov	r12,r6
8000cdc6:	fe b0 f8 f3 	rcall	8000bfac <__sinit>
8000cdca:	fe c8 d9 2a 	sub	r8,pc,-9942
8000cdce:	10 37       	cp.w	r7,r8
8000cdd0:	c0 31       	brne	8000cdd6 <_fclose_r+0x2e>
8000cdd2:	6c 07       	ld.w	r7,r6[0x0]
8000cdd4:	c0 c8       	rjmp	8000cdec <_fclose_r+0x44>
8000cdd6:	fe c8 d9 16 	sub	r8,pc,-9962
8000cdda:	10 37       	cp.w	r7,r8
8000cddc:	c0 31       	brne	8000cde2 <_fclose_r+0x3a>
8000cdde:	6c 17       	ld.w	r7,r6[0x4]
8000cde0:	c0 68       	rjmp	8000cdec <_fclose_r+0x44>
8000cde2:	fe c8 d9 02 	sub	r8,pc,-9982
8000cde6:	10 37       	cp.w	r7,r8
8000cde8:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000cdec:	8e 69       	ld.sh	r9,r7[0xc]
8000cdee:	30 08       	mov	r8,0
8000cdf0:	f0 09 19 00 	cp.h	r9,r8
8000cdf4:	c0 51       	brne	8000cdfe <_fclose_r+0x56>
8000cdf6:	fe b0 f8 8a 	rcall	8000bf0a <__sfp_lock_release>
8000cdfa:	30 05       	mov	r5,0
8000cdfc:	c2 f8       	rjmp	8000ce5a <_fclose_r+0xb2>
8000cdfe:	0e 9b       	mov	r11,r7
8000ce00:	0c 9c       	mov	r12,r6
8000ce02:	fe b0 f7 fd 	rcall	8000bdfc <_fflush_r>
8000ce06:	6e c8       	ld.w	r8,r7[0x30]
8000ce08:	18 95       	mov	r5,r12
8000ce0a:	58 08       	cp.w	r8,0
8000ce0c:	c0 60       	breq	8000ce18 <_fclose_r+0x70>
8000ce0e:	6e 8b       	ld.w	r11,r7[0x20]
8000ce10:	0c 9c       	mov	r12,r6
8000ce12:	5d 18       	icall	r8
8000ce14:	f9 b5 05 ff 	movlt	r5,-1
8000ce18:	8e 68       	ld.sh	r8,r7[0xc]
8000ce1a:	ed b8 00 07 	bld	r8,0x7
8000ce1e:	c0 51       	brne	8000ce28 <_fclose_r+0x80>
8000ce20:	6e 4b       	ld.w	r11,r7[0x10]
8000ce22:	0c 9c       	mov	r12,r6
8000ce24:	fe b0 f9 5e 	rcall	8000c0e0 <_free_r>
8000ce28:	6e db       	ld.w	r11,r7[0x34]
8000ce2a:	58 0b       	cp.w	r11,0
8000ce2c:	c0 a0       	breq	8000ce40 <_fclose_r+0x98>
8000ce2e:	ee c8 ff bc 	sub	r8,r7,-68
8000ce32:	10 3b       	cp.w	r11,r8
8000ce34:	c0 40       	breq	8000ce3c <_fclose_r+0x94>
8000ce36:	0c 9c       	mov	r12,r6
8000ce38:	fe b0 f9 54 	rcall	8000c0e0 <_free_r>
8000ce3c:	30 08       	mov	r8,0
8000ce3e:	8f d8       	st.w	r7[0x34],r8
8000ce40:	6f 2b       	ld.w	r11,r7[0x48]
8000ce42:	58 0b       	cp.w	r11,0
8000ce44:	c0 70       	breq	8000ce52 <_fclose_r+0xaa>
8000ce46:	0c 9c       	mov	r12,r6
8000ce48:	fe b0 f9 4c 	rcall	8000c0e0 <_free_r>
8000ce4c:	30 08       	mov	r8,0
8000ce4e:	ef 48 00 48 	st.w	r7[72],r8
8000ce52:	30 08       	mov	r8,0
8000ce54:	ae 68       	st.h	r7[0xc],r8
8000ce56:	fe b0 f8 5a 	rcall	8000bf0a <__sfp_lock_release>
8000ce5a:	0a 9c       	mov	r12,r5
8000ce5c:	d8 22       	popm	r4-r7,pc
8000ce5e:	d7 03       	nop

8000ce60 <fclose>:
8000ce60:	d4 01       	pushm	lr
8000ce62:	e0 68 0a 54 	mov	r8,2644
8000ce66:	18 9b       	mov	r11,r12
8000ce68:	70 0c       	ld.w	r12,r8[0x0]
8000ce6a:	c9 ff       	rcall	8000cda8 <_fclose_r>
8000ce6c:	d8 02       	popm	pc
8000ce6e:	d7 03       	nop

8000ce70 <_fstat_r>:
8000ce70:	d4 21       	pushm	r4-r7,lr
8000ce72:	16 98       	mov	r8,r11
8000ce74:	18 97       	mov	r7,r12
8000ce76:	10 9c       	mov	r12,r8
8000ce78:	30 08       	mov	r8,0
8000ce7a:	e0 66 bd 50 	mov	r6,48464
8000ce7e:	14 9b       	mov	r11,r10
8000ce80:	8d 08       	st.w	r6[0x0],r8
8000ce82:	fe b0 df 67 	rcall	80008d50 <_fstat>
8000ce86:	5b fc       	cp.w	r12,-1
8000ce88:	c0 51       	brne	8000ce92 <_fstat_r+0x22>
8000ce8a:	6c 08       	ld.w	r8,r6[0x0]
8000ce8c:	58 08       	cp.w	r8,0
8000ce8e:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ce92:	d8 22       	popm	r4-r7,pc

8000ce94 <_lseek_r>:
8000ce94:	d4 21       	pushm	r4-r7,lr
8000ce96:	16 98       	mov	r8,r11
8000ce98:	18 97       	mov	r7,r12
8000ce9a:	10 9c       	mov	r12,r8
8000ce9c:	30 08       	mov	r8,0
8000ce9e:	14 9b       	mov	r11,r10
8000cea0:	e0 66 bd 50 	mov	r6,48464
8000cea4:	12 9a       	mov	r10,r9
8000cea6:	8d 08       	st.w	r6[0x0],r8
8000cea8:	fe b0 df 36 	rcall	80008d14 <_lseek>
8000ceac:	5b fc       	cp.w	r12,-1
8000ceae:	c0 51       	brne	8000ceb8 <_lseek_r+0x24>
8000ceb0:	6c 08       	ld.w	r8,r6[0x0]
8000ceb2:	58 08       	cp.w	r8,0
8000ceb4:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ceb8:	d8 22       	popm	r4-r7,pc
8000ceba:	d7 03       	nop

8000cebc <_read_r>:
8000cebc:	d4 21       	pushm	r4-r7,lr
8000cebe:	16 98       	mov	r8,r11
8000cec0:	18 97       	mov	r7,r12
8000cec2:	10 9c       	mov	r12,r8
8000cec4:	30 08       	mov	r8,0
8000cec6:	14 9b       	mov	r11,r10
8000cec8:	e0 66 bd 50 	mov	r6,48464
8000cecc:	12 9a       	mov	r10,r9
8000cece:	8d 08       	st.w	r6[0x0],r8
8000ced0:	fe b0 d0 62 	rcall	80006f94 <_read>
8000ced4:	5b fc       	cp.w	r12,-1
8000ced6:	c0 51       	brne	8000cee0 <_read_r+0x24>
8000ced8:	6c 08       	ld.w	r8,r6[0x0]
8000ceda:	58 08       	cp.w	r8,0
8000cedc:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000cee0:	d8 22       	popm	r4-r7,pc
8000cee2:	d7 03       	nop

8000cee4 <__avr32_f64_mul>:
8000cee4:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000cee8:	e0 80 00 dc 	breq	8000d0a0 <__avr32_f64_mul_op1_zero>
8000ceec:	d4 21       	pushm	r4-r7,lr
8000ceee:	f7 e9 20 0e 	eor	lr,r11,r9
8000cef2:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000cef6:	30 15       	mov	r5,1
8000cef8:	c4 30       	breq	8000cf7e <__avr32_f64_mul_op1_subnormal>
8000cefa:	ab 6b       	lsl	r11,0xa
8000cefc:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000cf00:	ab 6a       	lsl	r10,0xa
8000cf02:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000cf06:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000cf0a:	c5 c0       	breq	8000cfc2 <__avr32_f64_mul_op2_subnormal>
8000cf0c:	a1 78       	lsl	r8,0x1
8000cf0e:	5c f9       	rol	r9
8000cf10:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000cf14:	e0 47 07 ff 	cp.w	r7,2047
8000cf18:	c7 70       	breq	8000d006 <__avr32_f64_mul_op_nan_or_inf>
8000cf1a:	e0 46 07 ff 	cp.w	r6,2047
8000cf1e:	c7 40       	breq	8000d006 <__avr32_f64_mul_op_nan_or_inf>
8000cf20:	ee 06 00 0c 	add	r12,r7,r6
8000cf24:	e0 2c 03 fe 	sub	r12,1022
8000cf28:	f6 08 06 44 	mulu.d	r4,r11,r8
8000cf2c:	f4 09 07 44 	macu.d	r4,r10,r9
8000cf30:	f4 08 06 46 	mulu.d	r6,r10,r8
8000cf34:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000cf38:	08 07       	add	r7,r4
8000cf3a:	f4 05 00 4a 	adc	r10,r10,r5
8000cf3e:	5c 0b       	acr	r11
8000cf40:	ed bb 00 14 	bld	r11,0x14
8000cf44:	c0 50       	breq	8000cf4e <__avr32_f64_mul+0x6a>
8000cf46:	a1 77       	lsl	r7,0x1
8000cf48:	5c fa       	rol	r10
8000cf4a:	5c fb       	rol	r11
8000cf4c:	20 1c       	sub	r12,1
8000cf4e:	58 0c       	cp.w	r12,0
8000cf50:	e0 8a 00 6f 	brle	8000d02e <__avr32_f64_mul_res_subnormal>
8000cf54:	e0 4c 07 ff 	cp.w	r12,2047
8000cf58:	e0 84 00 9c 	brge	8000d090 <__avr32_f64_mul_res_inf>
8000cf5c:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000cf60:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000cf64:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000cf68:	ee 17 80 00 	eorh	r7,0x8000
8000cf6c:	f1 b7 04 20 	satu	r7,0x1
8000cf70:	0e 0a       	add	r10,r7
8000cf72:	5c 0b       	acr	r11
8000cf74:	ed be 00 1f 	bld	lr,0x1f
8000cf78:	ef bb 00 1f 	bst	r11,0x1f
8000cf7c:	d8 22       	popm	r4-r7,pc

8000cf7e <__avr32_f64_mul_op1_subnormal>:
8000cf7e:	e4 1b 00 0f 	andh	r11,0xf
8000cf82:	f4 0c 12 00 	clz	r12,r10
8000cf86:	f6 06 12 00 	clz	r6,r11
8000cf8a:	f7 bc 03 e1 	sublo	r12,-31
8000cf8e:	f8 06 17 30 	movlo	r6,r12
8000cf92:	f7 b6 02 01 	subhs	r6,1
8000cf96:	e0 46 00 20 	cp.w	r6,32
8000cf9a:	c0 d4       	brge	8000cfb4 <__avr32_f64_mul_op1_subnormal+0x36>
8000cf9c:	ec 0c 11 20 	rsub	r12,r6,32
8000cfa0:	f6 06 09 4b 	lsl	r11,r11,r6
8000cfa4:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000cfa8:	18 4b       	or	r11,r12
8000cfaa:	f4 06 09 4a 	lsl	r10,r10,r6
8000cfae:	20 b6       	sub	r6,11
8000cfb0:	0c 17       	sub	r7,r6
8000cfb2:	ca ab       	rjmp	8000cf06 <__avr32_f64_mul+0x22>
8000cfb4:	f4 06 09 4b 	lsl	r11,r10,r6
8000cfb8:	c6 40       	breq	8000d080 <__avr32_f64_mul_res_zero>
8000cfba:	30 0a       	mov	r10,0
8000cfbc:	20 b6       	sub	r6,11
8000cfbe:	0c 17       	sub	r7,r6
8000cfc0:	ca 3b       	rjmp	8000cf06 <__avr32_f64_mul+0x22>

8000cfc2 <__avr32_f64_mul_op2_subnormal>:
8000cfc2:	e4 19 00 0f 	andh	r9,0xf
8000cfc6:	f0 0c 12 00 	clz	r12,r8
8000cfca:	f2 05 12 00 	clz	r5,r9
8000cfce:	f7 bc 03 ea 	sublo	r12,-22
8000cfd2:	f8 05 17 30 	movlo	r5,r12
8000cfd6:	f7 b5 02 0a 	subhs	r5,10
8000cfda:	e0 45 00 20 	cp.w	r5,32
8000cfde:	c0 d4       	brge	8000cff8 <__avr32_f64_mul_op2_subnormal+0x36>
8000cfe0:	ea 0c 11 20 	rsub	r12,r5,32
8000cfe4:	f2 05 09 49 	lsl	r9,r9,r5
8000cfe8:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000cfec:	18 49       	or	r9,r12
8000cfee:	f0 05 09 48 	lsl	r8,r8,r5
8000cff2:	20 25       	sub	r5,2
8000cff4:	0a 16       	sub	r6,r5
8000cff6:	c8 fb       	rjmp	8000cf14 <__avr32_f64_mul+0x30>
8000cff8:	f0 05 09 49 	lsl	r9,r8,r5
8000cffc:	c4 20       	breq	8000d080 <__avr32_f64_mul_res_zero>
8000cffe:	30 08       	mov	r8,0
8000d000:	20 25       	sub	r5,2
8000d002:	0a 16       	sub	r6,r5
8000d004:	c8 8b       	rjmp	8000cf14 <__avr32_f64_mul+0x30>

8000d006 <__avr32_f64_mul_op_nan_or_inf>:
8000d006:	e4 19 00 0f 	andh	r9,0xf
8000d00a:	e4 1b 00 0f 	andh	r11,0xf
8000d00e:	14 4b       	or	r11,r10
8000d010:	10 49       	or	r9,r8
8000d012:	e0 47 07 ff 	cp.w	r7,2047
8000d016:	c0 91       	brne	8000d028 <__avr32_f64_mul_op1_not_naninf>
8000d018:	58 0b       	cp.w	r11,0
8000d01a:	c3 81       	brne	8000d08a <__avr32_f64_mul_res_nan>
8000d01c:	e0 46 07 ff 	cp.w	r6,2047
8000d020:	c3 81       	brne	8000d090 <__avr32_f64_mul_res_inf>
8000d022:	58 09       	cp.w	r9,0
8000d024:	c3 60       	breq	8000d090 <__avr32_f64_mul_res_inf>
8000d026:	c3 28       	rjmp	8000d08a <__avr32_f64_mul_res_nan>

8000d028 <__avr32_f64_mul_op1_not_naninf>:
8000d028:	58 09       	cp.w	r9,0
8000d02a:	c3 30       	breq	8000d090 <__avr32_f64_mul_res_inf>
8000d02c:	c2 f8       	rjmp	8000d08a <__avr32_f64_mul_res_nan>

8000d02e <__avr32_f64_mul_res_subnormal>:
8000d02e:	5c 3c       	neg	r12
8000d030:	2f fc       	sub	r12,-1
8000d032:	f1 bc 04 c0 	satu	r12,0x6
8000d036:	e0 4c 00 20 	cp.w	r12,32
8000d03a:	c1 14       	brge	8000d05c <__avr32_f64_mul_res_subnormal+0x2e>
8000d03c:	f8 08 11 20 	rsub	r8,r12,32
8000d040:	0e 46       	or	r6,r7
8000d042:	ee 0c 0a 47 	lsr	r7,r7,r12
8000d046:	f4 08 09 49 	lsl	r9,r10,r8
8000d04a:	12 47       	or	r7,r9
8000d04c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000d050:	f6 08 09 49 	lsl	r9,r11,r8
8000d054:	12 4a       	or	r10,r9
8000d056:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000d05a:	c8 3b       	rjmp	8000cf60 <__avr32_f64_mul+0x7c>
8000d05c:	f8 08 11 20 	rsub	r8,r12,32
8000d060:	f9 b9 00 00 	moveq	r9,0
8000d064:	c0 30       	breq	8000d06a <__avr32_f64_mul_res_subnormal+0x3c>
8000d066:	f6 08 09 49 	lsl	r9,r11,r8
8000d06a:	0e 46       	or	r6,r7
8000d06c:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000d070:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000d074:	f3 ea 10 07 	or	r7,r9,r10
8000d078:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000d07c:	30 0b       	mov	r11,0
8000d07e:	c7 1b       	rjmp	8000cf60 <__avr32_f64_mul+0x7c>

8000d080 <__avr32_f64_mul_res_zero>:
8000d080:	1c 9b       	mov	r11,lr
8000d082:	e6 1b 80 00 	andh	r11,0x8000,COH
8000d086:	30 0a       	mov	r10,0
8000d088:	d8 22       	popm	r4-r7,pc

8000d08a <__avr32_f64_mul_res_nan>:
8000d08a:	3f fb       	mov	r11,-1
8000d08c:	3f fa       	mov	r10,-1
8000d08e:	d8 22       	popm	r4-r7,pc

8000d090 <__avr32_f64_mul_res_inf>:
8000d090:	f0 6b 00 00 	mov	r11,-1048576
8000d094:	ed be 00 1f 	bld	lr,0x1f
8000d098:	ef bb 00 1f 	bst	r11,0x1f
8000d09c:	30 0a       	mov	r10,0
8000d09e:	d8 22       	popm	r4-r7,pc

8000d0a0 <__avr32_f64_mul_op1_zero>:
8000d0a0:	f7 e9 20 0b 	eor	r11,r11,r9
8000d0a4:	e6 1b 80 00 	andh	r11,0x8000,COH
8000d0a8:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000d0ac:	e0 4c 07 ff 	cp.w	r12,2047
8000d0b0:	5e 1c       	retne	r12
8000d0b2:	3f fa       	mov	r10,-1
8000d0b4:	3f fb       	mov	r11,-1
8000d0b6:	5e fc       	retal	r12

8000d0b8 <__avr32_f64_sub_from_add>:
8000d0b8:	ee 19 80 00 	eorh	r9,0x8000

8000d0bc <__avr32_f64_sub>:
8000d0bc:	f7 e9 20 0c 	eor	r12,r11,r9
8000d0c0:	e0 86 00 ca 	brmi	8000d254 <__avr32_f64_add_from_sub>
8000d0c4:	eb cd 40 e0 	pushm	r5-r7,lr
8000d0c8:	16 9c       	mov	r12,r11
8000d0ca:	e6 1c 80 00 	andh	r12,0x8000,COH
8000d0ce:	bf db       	cbr	r11,0x1f
8000d0d0:	bf d9       	cbr	r9,0x1f
8000d0d2:	10 3a       	cp.w	r10,r8
8000d0d4:	f2 0b 13 00 	cpc	r11,r9
8000d0d8:	c0 92       	brcc	8000d0ea <__avr32_f64_sub+0x2e>
8000d0da:	16 97       	mov	r7,r11
8000d0dc:	12 9b       	mov	r11,r9
8000d0de:	0e 99       	mov	r9,r7
8000d0e0:	14 97       	mov	r7,r10
8000d0e2:	10 9a       	mov	r10,r8
8000d0e4:	0e 98       	mov	r8,r7
8000d0e6:	ee 1c 80 00 	eorh	r12,0x8000
8000d0ea:	f6 07 16 14 	lsr	r7,r11,0x14
8000d0ee:	ab 7b       	lsl	r11,0xb
8000d0f0:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000d0f4:	ab 7a       	lsl	r10,0xb
8000d0f6:	bf bb       	sbr	r11,0x1f
8000d0f8:	f2 06 16 14 	lsr	r6,r9,0x14
8000d0fc:	c4 40       	breq	8000d184 <__avr32_f64_sub_opL_subnormal>
8000d0fe:	ab 79       	lsl	r9,0xb
8000d100:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000d104:	ab 78       	lsl	r8,0xb
8000d106:	bf b9       	sbr	r9,0x1f

8000d108 <__avr32_f64_sub_opL_subnormal_done>:
8000d108:	e0 47 07 ff 	cp.w	r7,2047
8000d10c:	c4 f0       	breq	8000d1aa <__avr32_f64_sub_opH_nan_or_inf>
8000d10e:	0e 26       	rsub	r6,r7
8000d110:	c1 20       	breq	8000d134 <__avr32_f64_sub_shift_done>
8000d112:	ec 05 11 20 	rsub	r5,r6,32
8000d116:	e0 46 00 20 	cp.w	r6,32
8000d11a:	c7 c2       	brcc	8000d212 <__avr32_f64_sub_longshift>
8000d11c:	f0 05 09 4e 	lsl	lr,r8,r5
8000d120:	f2 05 09 45 	lsl	r5,r9,r5
8000d124:	f0 06 0a 48 	lsr	r8,r8,r6
8000d128:	f2 06 0a 49 	lsr	r9,r9,r6
8000d12c:	0a 48       	or	r8,r5
8000d12e:	58 0e       	cp.w	lr,0
8000d130:	5f 1e       	srne	lr
8000d132:	1c 48       	or	r8,lr

8000d134 <__avr32_f64_sub_shift_done>:
8000d134:	10 1a       	sub	r10,r8
8000d136:	f6 09 01 4b 	sbc	r11,r11,r9
8000d13a:	f6 06 12 00 	clz	r6,r11
8000d13e:	c0 e0       	breq	8000d15a <__avr32_f64_sub_longnormalize_done>
8000d140:	c7 83       	brcs	8000d230 <__avr32_f64_sub_longnormalize>
8000d142:	ec 0e 11 20 	rsub	lr,r6,32
8000d146:	f6 06 09 4b 	lsl	r11,r11,r6
8000d14a:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000d14e:	1c 4b       	or	r11,lr
8000d150:	f4 06 09 4a 	lsl	r10,r10,r6
8000d154:	0c 17       	sub	r7,r6
8000d156:	e0 8a 00 39 	brle	8000d1c8 <__avr32_f64_sub_subnormal_result>

8000d15a <__avr32_f64_sub_longnormalize_done>:
8000d15a:	f4 09 15 15 	lsl	r9,r10,0x15
8000d15e:	ab 9a       	lsr	r10,0xb
8000d160:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000d164:	ab 9b       	lsr	r11,0xb
8000d166:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000d16a:	18 4b       	or	r11,r12

8000d16c <__avr32_f64_sub_round>:
8000d16c:	fc 17 80 00 	movh	r7,0x8000
8000d170:	ed ba 00 00 	bld	r10,0x0
8000d174:	f7 b7 01 ff 	subne	r7,-1
8000d178:	0e 39       	cp.w	r9,r7
8000d17a:	5f 29       	srhs	r9
8000d17c:	12 0a       	add	r10,r9
8000d17e:	5c 0b       	acr	r11
8000d180:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d184 <__avr32_f64_sub_opL_subnormal>:
8000d184:	ab 79       	lsl	r9,0xb
8000d186:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000d18a:	ab 78       	lsl	r8,0xb
8000d18c:	f3 e8 10 0e 	or	lr,r9,r8
8000d190:	f9 b6 01 01 	movne	r6,1
8000d194:	ee 0e 11 00 	rsub	lr,r7,0
8000d198:	f9 b7 00 01 	moveq	r7,1
8000d19c:	ef bb 00 1f 	bst	r11,0x1f
8000d1a0:	f7 ea 10 0e 	or	lr,r11,r10
8000d1a4:	f9 b7 00 00 	moveq	r7,0
8000d1a8:	cb 0b       	rjmp	8000d108 <__avr32_f64_sub_opL_subnormal_done>

8000d1aa <__avr32_f64_sub_opH_nan_or_inf>:
8000d1aa:	bf db       	cbr	r11,0x1f
8000d1ac:	f7 ea 10 0e 	or	lr,r11,r10
8000d1b0:	c0 81       	brne	8000d1c0 <__avr32_f64_sub_return_nan>
8000d1b2:	e0 46 07 ff 	cp.w	r6,2047
8000d1b6:	c0 50       	breq	8000d1c0 <__avr32_f64_sub_return_nan>
8000d1b8:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000d1bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d1c0 <__avr32_f64_sub_return_nan>:
8000d1c0:	3f fa       	mov	r10,-1
8000d1c2:	3f fb       	mov	r11,-1
8000d1c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d1c8 <__avr32_f64_sub_subnormal_result>:
8000d1c8:	5c 37       	neg	r7
8000d1ca:	2f f7       	sub	r7,-1
8000d1cc:	f1 b7 04 c0 	satu	r7,0x6
8000d1d0:	e0 47 00 20 	cp.w	r7,32
8000d1d4:	c1 14       	brge	8000d1f6 <__avr32_f64_sub_subnormal_result+0x2e>
8000d1d6:	ee 08 11 20 	rsub	r8,r7,32
8000d1da:	f4 08 09 49 	lsl	r9,r10,r8
8000d1de:	5f 16       	srne	r6
8000d1e0:	f4 07 0a 4a 	lsr	r10,r10,r7
8000d1e4:	0c 4a       	or	r10,r6
8000d1e6:	f6 08 09 49 	lsl	r9,r11,r8
8000d1ea:	f5 e9 10 0a 	or	r10,r10,r9
8000d1ee:	f4 07 0a 4b 	lsr	r11,r10,r7
8000d1f2:	30 07       	mov	r7,0
8000d1f4:	cb 3b       	rjmp	8000d15a <__avr32_f64_sub_longnormalize_done>
8000d1f6:	ee 08 11 40 	rsub	r8,r7,64
8000d1fa:	f6 08 09 49 	lsl	r9,r11,r8
8000d1fe:	14 49       	or	r9,r10
8000d200:	5f 16       	srne	r6
8000d202:	f6 07 0a 4a 	lsr	r10,r11,r7
8000d206:	0c 4a       	or	r10,r6
8000d208:	30 0b       	mov	r11,0
8000d20a:	30 07       	mov	r7,0
8000d20c:	ca 7b       	rjmp	8000d15a <__avr32_f64_sub_longnormalize_done>
8000d20e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d212 <__avr32_f64_sub_longshift>:
8000d212:	f1 b6 04 c0 	satu	r6,0x6
8000d216:	f0 0e 17 00 	moveq	lr,r8
8000d21a:	c0 40       	breq	8000d222 <__avr32_f64_sub_longshift+0x10>
8000d21c:	f2 05 09 4e 	lsl	lr,r9,r5
8000d220:	10 4e       	or	lr,r8
8000d222:	f2 06 0a 48 	lsr	r8,r9,r6
8000d226:	30 09       	mov	r9,0
8000d228:	58 0e       	cp.w	lr,0
8000d22a:	5f 1e       	srne	lr
8000d22c:	1c 48       	or	r8,lr
8000d22e:	c8 3b       	rjmp	8000d134 <__avr32_f64_sub_shift_done>

8000d230 <__avr32_f64_sub_longnormalize>:
8000d230:	f4 06 12 00 	clz	r6,r10
8000d234:	f9 b7 03 00 	movlo	r7,0
8000d238:	f9 b6 03 00 	movlo	r6,0
8000d23c:	f9 bc 03 00 	movlo	r12,0
8000d240:	f7 b6 02 e0 	subhs	r6,-32
8000d244:	f4 06 09 4b 	lsl	r11,r10,r6
8000d248:	30 0a       	mov	r10,0
8000d24a:	0c 17       	sub	r7,r6
8000d24c:	fe 9a ff be 	brle	8000d1c8 <__avr32_f64_sub_subnormal_result>
8000d250:	c8 5b       	rjmp	8000d15a <__avr32_f64_sub_longnormalize_done>
8000d252:	d7 03       	nop

8000d254 <__avr32_f64_add_from_sub>:
8000d254:	ee 19 80 00 	eorh	r9,0x8000

8000d258 <__avr32_f64_add>:
8000d258:	f7 e9 20 0c 	eor	r12,r11,r9
8000d25c:	fe 96 ff 2e 	brmi	8000d0b8 <__avr32_f64_sub_from_add>
8000d260:	eb cd 40 e0 	pushm	r5-r7,lr
8000d264:	16 9c       	mov	r12,r11
8000d266:	e6 1c 80 00 	andh	r12,0x8000,COH
8000d26a:	bf db       	cbr	r11,0x1f
8000d26c:	bf d9       	cbr	r9,0x1f
8000d26e:	12 3b       	cp.w	r11,r9
8000d270:	c0 72       	brcc	8000d27e <__avr32_f64_add+0x26>
8000d272:	16 97       	mov	r7,r11
8000d274:	12 9b       	mov	r11,r9
8000d276:	0e 99       	mov	r9,r7
8000d278:	14 97       	mov	r7,r10
8000d27a:	10 9a       	mov	r10,r8
8000d27c:	0e 98       	mov	r8,r7
8000d27e:	30 0e       	mov	lr,0
8000d280:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000d284:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000d288:	b5 ab       	sbr	r11,0x14
8000d28a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000d28e:	c6 20       	breq	8000d352 <__avr32_f64_add_op2_subnormal>
8000d290:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000d294:	b5 a9       	sbr	r9,0x14
8000d296:	e0 47 07 ff 	cp.w	r7,2047
8000d29a:	c2 80       	breq	8000d2ea <__avr32_f64_add_opH_nan_or_inf>
8000d29c:	0e 26       	rsub	r6,r7
8000d29e:	c1 20       	breq	8000d2c2 <__avr32_f64_add_shift_done>
8000d2a0:	e0 46 00 36 	cp.w	r6,54
8000d2a4:	c1 52       	brcc	8000d2ce <__avr32_f64_add_res_of_done>
8000d2a6:	ec 05 11 20 	rsub	r5,r6,32
8000d2aa:	e0 46 00 20 	cp.w	r6,32
8000d2ae:	c3 52       	brcc	8000d318 <__avr32_f64_add_longshift>
8000d2b0:	f0 05 09 4e 	lsl	lr,r8,r5
8000d2b4:	f2 05 09 45 	lsl	r5,r9,r5
8000d2b8:	f0 06 0a 48 	lsr	r8,r8,r6
8000d2bc:	f2 06 0a 49 	lsr	r9,r9,r6
8000d2c0:	0a 48       	or	r8,r5

8000d2c2 <__avr32_f64_add_shift_done>:
8000d2c2:	10 0a       	add	r10,r8
8000d2c4:	f6 09 00 4b 	adc	r11,r11,r9
8000d2c8:	ed bb 00 15 	bld	r11,0x15
8000d2cc:	c3 40       	breq	8000d334 <__avr32_f64_add_res_of>

8000d2ce <__avr32_f64_add_res_of_done>:
8000d2ce:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000d2d2:	18 4b       	or	r11,r12

8000d2d4 <__avr32_f64_add_round>:
8000d2d4:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000d2d8:	18 4e       	or	lr,r12
8000d2da:	ee 1e 80 00 	eorh	lr,0x8000
8000d2de:	f1 be 04 20 	satu	lr,0x1
8000d2e2:	1c 0a       	add	r10,lr
8000d2e4:	5c 0b       	acr	r11
8000d2e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d2ea <__avr32_f64_add_opH_nan_or_inf>:
8000d2ea:	b5 cb       	cbr	r11,0x14
8000d2ec:	f7 ea 10 0e 	or	lr,r11,r10
8000d2f0:	c1 01       	brne	8000d310 <__avr32_f64_add_return_nan>
8000d2f2:	e0 46 07 ff 	cp.w	r6,2047
8000d2f6:	c0 30       	breq	8000d2fc <__avr32_f64_add_opL_nan_or_inf>
8000d2f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d2fc <__avr32_f64_add_opL_nan_or_inf>:
8000d2fc:	b5 c9       	cbr	r9,0x14
8000d2fe:	f3 e8 10 0e 	or	lr,r9,r8
8000d302:	c0 71       	brne	8000d310 <__avr32_f64_add_return_nan>
8000d304:	30 0a       	mov	r10,0
8000d306:	fc 1b 7f f0 	movh	r11,0x7ff0
8000d30a:	18 4b       	or	r11,r12
8000d30c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d310 <__avr32_f64_add_return_nan>:
8000d310:	3f fa       	mov	r10,-1
8000d312:	3f fb       	mov	r11,-1
8000d314:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d318 <__avr32_f64_add_longshift>:
8000d318:	f1 b6 04 c0 	satu	r6,0x6
8000d31c:	f0 0e 17 00 	moveq	lr,r8
8000d320:	c0 60       	breq	8000d32c <__avr32_f64_add_longshift+0x14>
8000d322:	f2 05 09 4e 	lsl	lr,r9,r5
8000d326:	58 08       	cp.w	r8,0
8000d328:	5f 18       	srne	r8
8000d32a:	10 4e       	or	lr,r8
8000d32c:	f2 06 0a 48 	lsr	r8,r9,r6
8000d330:	30 09       	mov	r9,0
8000d332:	cc 8b       	rjmp	8000d2c2 <__avr32_f64_add_shift_done>

8000d334 <__avr32_f64_add_res_of>:
8000d334:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000d338:	a1 9b       	lsr	r11,0x1
8000d33a:	5d 0a       	ror	r10
8000d33c:	5d 0e       	ror	lr
8000d33e:	2f f7       	sub	r7,-1
8000d340:	e0 47 07 ff 	cp.w	r7,2047
8000d344:	f9 ba 00 00 	moveq	r10,0
8000d348:	f9 bb 00 00 	moveq	r11,0
8000d34c:	f9 be 00 00 	moveq	lr,0
8000d350:	cb fb       	rjmp	8000d2ce <__avr32_f64_add_res_of_done>

8000d352 <__avr32_f64_add_op2_subnormal>:
8000d352:	30 16       	mov	r6,1
8000d354:	58 07       	cp.w	r7,0
8000d356:	ca 01       	brne	8000d296 <__avr32_f64_add+0x3e>
8000d358:	b5 cb       	cbr	r11,0x14
8000d35a:	10 0a       	add	r10,r8
8000d35c:	f6 09 00 4b 	adc	r11,r11,r9
8000d360:	18 4b       	or	r11,r12
8000d362:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000d366:	d7 03       	nop

8000d368 <__avr32_f64_to_u32>:
8000d368:	58 0b       	cp.w	r11,0
8000d36a:	5e 6d       	retmi	0

8000d36c <__avr32_f64_to_s32>:
8000d36c:	f6 0c 15 01 	lsl	r12,r11,0x1
8000d370:	b5 9c       	lsr	r12,0x15
8000d372:	e0 2c 03 ff 	sub	r12,1023
8000d376:	5e 3d       	retlo	0
8000d378:	f8 0c 11 1f 	rsub	r12,r12,31
8000d37c:	16 99       	mov	r9,r11
8000d37e:	ab 7b       	lsl	r11,0xb
8000d380:	bf bb       	sbr	r11,0x1f
8000d382:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000d386:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000d38a:	a1 79       	lsl	r9,0x1
8000d38c:	5e 2b       	reths	r11
8000d38e:	5c 3b       	neg	r11
8000d390:	5e fb       	retal	r11

8000d392 <__avr32_u32_to_f64>:
8000d392:	f8 cb 00 00 	sub	r11,r12,0
8000d396:	30 0c       	mov	r12,0
8000d398:	c0 38       	rjmp	8000d39e <__avr32_s32_to_f64+0x4>

8000d39a <__avr32_s32_to_f64>:
8000d39a:	18 9b       	mov	r11,r12
8000d39c:	5c 4b       	abs	r11
8000d39e:	30 0a       	mov	r10,0
8000d3a0:	5e 0b       	reteq	r11
8000d3a2:	d4 01       	pushm	lr
8000d3a4:	e0 69 04 1e 	mov	r9,1054
8000d3a8:	f6 08 12 00 	clz	r8,r11
8000d3ac:	c1 70       	breq	8000d3da <__avr32_s32_to_f64+0x40>
8000d3ae:	c0 c3       	brcs	8000d3c6 <__avr32_s32_to_f64+0x2c>
8000d3b0:	f0 0e 11 20 	rsub	lr,r8,32
8000d3b4:	f6 08 09 4b 	lsl	r11,r11,r8
8000d3b8:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000d3bc:	1c 4b       	or	r11,lr
8000d3be:	f4 08 09 4a 	lsl	r10,r10,r8
8000d3c2:	10 19       	sub	r9,r8
8000d3c4:	c0 b8       	rjmp	8000d3da <__avr32_s32_to_f64+0x40>
8000d3c6:	f4 08 12 00 	clz	r8,r10
8000d3ca:	f9 b8 03 00 	movlo	r8,0
8000d3ce:	f7 b8 02 e0 	subhs	r8,-32
8000d3d2:	f4 08 09 4b 	lsl	r11,r10,r8
8000d3d6:	30 0a       	mov	r10,0
8000d3d8:	10 19       	sub	r9,r8
8000d3da:	58 09       	cp.w	r9,0
8000d3dc:	e0 89 00 30 	brgt	8000d43c <__avr32_s32_to_f64+0xa2>
8000d3e0:	5c 39       	neg	r9
8000d3e2:	2f f9       	sub	r9,-1
8000d3e4:	e0 49 00 36 	cp.w	r9,54
8000d3e8:	c0 43       	brcs	8000d3f0 <__avr32_s32_to_f64+0x56>
8000d3ea:	30 0b       	mov	r11,0
8000d3ec:	30 0a       	mov	r10,0
8000d3ee:	c2 68       	rjmp	8000d43a <__avr32_s32_to_f64+0xa0>
8000d3f0:	2f 69       	sub	r9,-10
8000d3f2:	f2 08 11 20 	rsub	r8,r9,32
8000d3f6:	e0 49 00 20 	cp.w	r9,32
8000d3fa:	c0 b2       	brcc	8000d410 <__avr32_s32_to_f64+0x76>
8000d3fc:	f4 08 09 4e 	lsl	lr,r10,r8
8000d400:	f6 08 09 48 	lsl	r8,r11,r8
8000d404:	f4 09 0a 4a 	lsr	r10,r10,r9
8000d408:	f6 09 0a 4b 	lsr	r11,r11,r9
8000d40c:	10 4b       	or	r11,r8
8000d40e:	c0 88       	rjmp	8000d41e <__avr32_s32_to_f64+0x84>
8000d410:	f6 08 09 4e 	lsl	lr,r11,r8
8000d414:	14 4e       	or	lr,r10
8000d416:	16 9a       	mov	r10,r11
8000d418:	30 0b       	mov	r11,0
8000d41a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000d41e:	ed ba 00 00 	bld	r10,0x0
8000d422:	c0 92       	brcc	8000d434 <__avr32_s32_to_f64+0x9a>
8000d424:	1c 7e       	tst	lr,lr
8000d426:	c0 41       	brne	8000d42e <__avr32_s32_to_f64+0x94>
8000d428:	ed ba 00 01 	bld	r10,0x1
8000d42c:	c0 42       	brcc	8000d434 <__avr32_s32_to_f64+0x9a>
8000d42e:	2f fa       	sub	r10,-1
8000d430:	f7 bb 02 ff 	subhs	r11,-1
8000d434:	5c fc       	rol	r12
8000d436:	5d 0b       	ror	r11
8000d438:	5d 0a       	ror	r10
8000d43a:	d8 02       	popm	pc
8000d43c:	e0 68 03 ff 	mov	r8,1023
8000d440:	ed ba 00 0b 	bld	r10,0xb
8000d444:	f7 b8 00 ff 	subeq	r8,-1
8000d448:	10 0a       	add	r10,r8
8000d44a:	5c 0b       	acr	r11
8000d44c:	f7 b9 03 fe 	sublo	r9,-2
8000d450:	e0 49 07 ff 	cp.w	r9,2047
8000d454:	c0 55       	brlt	8000d45e <__avr32_s32_to_f64+0xc4>
8000d456:	30 0a       	mov	r10,0
8000d458:	fc 1b ff e0 	movh	r11,0xffe0
8000d45c:	c0 c8       	rjmp	8000d474 <__floatsidf_return_op1>
8000d45e:	ed bb 00 1f 	bld	r11,0x1f
8000d462:	f7 b9 01 01 	subne	r9,1
8000d466:	ab 9a       	lsr	r10,0xb
8000d468:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000d46c:	a1 7b       	lsl	r11,0x1
8000d46e:	ab 9b       	lsr	r11,0xb
8000d470:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000d474 <__floatsidf_return_op1>:
8000d474:	a1 7c       	lsl	r12,0x1
8000d476:	5d 0b       	ror	r11
8000d478:	d8 02       	popm	pc

8000d47a <__avr32_f64_cmp_eq>:
8000d47a:	10 3a       	cp.w	r10,r8
8000d47c:	f2 0b 13 00 	cpc	r11,r9
8000d480:	c0 80       	breq	8000d490 <__avr32_f64_cmp_eq+0x16>
8000d482:	a1 7b       	lsl	r11,0x1
8000d484:	a1 79       	lsl	r9,0x1
8000d486:	14 4b       	or	r11,r10
8000d488:	12 4b       	or	r11,r9
8000d48a:	10 4b       	or	r11,r8
8000d48c:	5e 0f       	reteq	1
8000d48e:	5e fd       	retal	0
8000d490:	a1 7b       	lsl	r11,0x1
8000d492:	fc 1c ff e0 	movh	r12,0xffe0
8000d496:	58 0a       	cp.w	r10,0
8000d498:	f8 0b 13 00 	cpc	r11,r12
8000d49c:	5e 8f       	retls	1
8000d49e:	5e fd       	retal	0

8000d4a0 <__avr32_f64_cmp_ge>:
8000d4a0:	1a de       	st.w	--sp,lr
8000d4a2:	1a d7       	st.w	--sp,r7
8000d4a4:	a1 7b       	lsl	r11,0x1
8000d4a6:	5f 3c       	srlo	r12
8000d4a8:	a1 79       	lsl	r9,0x1
8000d4aa:	5f 37       	srlo	r7
8000d4ac:	5c fc       	rol	r12
8000d4ae:	fc 1e ff e0 	movh	lr,0xffe0
8000d4b2:	58 0a       	cp.w	r10,0
8000d4b4:	fc 0b 13 00 	cpc	r11,lr
8000d4b8:	e0 8b 00 1d 	brhi	8000d4f2 <__avr32_f64_cmp_ge+0x52>
8000d4bc:	58 08       	cp.w	r8,0
8000d4be:	fc 09 13 00 	cpc	r9,lr
8000d4c2:	e0 8b 00 18 	brhi	8000d4f2 <__avr32_f64_cmp_ge+0x52>
8000d4c6:	58 0b       	cp.w	r11,0
8000d4c8:	f5 ba 00 00 	subfeq	r10,0
8000d4cc:	c1 50       	breq	8000d4f6 <__avr32_f64_cmp_ge+0x56>
8000d4ce:	1b 07       	ld.w	r7,sp++
8000d4d0:	1b 0e       	ld.w	lr,sp++
8000d4d2:	58 3c       	cp.w	r12,3
8000d4d4:	c0 a0       	breq	8000d4e8 <__avr32_f64_cmp_ge+0x48>
8000d4d6:	58 1c       	cp.w	r12,1
8000d4d8:	c0 33       	brcs	8000d4de <__avr32_f64_cmp_ge+0x3e>
8000d4da:	5e 0f       	reteq	1
8000d4dc:	5e 1d       	retne	0
8000d4de:	10 3a       	cp.w	r10,r8
8000d4e0:	f2 0b 13 00 	cpc	r11,r9
8000d4e4:	5e 2f       	reths	1
8000d4e6:	5e 3d       	retlo	0
8000d4e8:	14 38       	cp.w	r8,r10
8000d4ea:	f6 09 13 00 	cpc	r9,r11
8000d4ee:	5e 2f       	reths	1
8000d4f0:	5e 3d       	retlo	0
8000d4f2:	1b 07       	ld.w	r7,sp++
8000d4f4:	d8 0a       	popm	pc,r12=0
8000d4f6:	58 17       	cp.w	r7,1
8000d4f8:	5f 0c       	sreq	r12
8000d4fa:	58 09       	cp.w	r9,0
8000d4fc:	f5 b8 00 00 	subfeq	r8,0
8000d500:	1b 07       	ld.w	r7,sp++
8000d502:	1b 0e       	ld.w	lr,sp++
8000d504:	5e 0f       	reteq	1
8000d506:	5e fc       	retal	r12

8000d508 <__avr32_f64_cmp_lt>:
8000d508:	1a de       	st.w	--sp,lr
8000d50a:	1a d7       	st.w	--sp,r7
8000d50c:	a1 7b       	lsl	r11,0x1
8000d50e:	5f 3c       	srlo	r12
8000d510:	a1 79       	lsl	r9,0x1
8000d512:	5f 37       	srlo	r7
8000d514:	5c fc       	rol	r12
8000d516:	fc 1e ff e0 	movh	lr,0xffe0
8000d51a:	58 0a       	cp.w	r10,0
8000d51c:	fc 0b 13 00 	cpc	r11,lr
8000d520:	e0 8b 00 1d 	brhi	8000d55a <__avr32_f64_cmp_lt+0x52>
8000d524:	58 08       	cp.w	r8,0
8000d526:	fc 09 13 00 	cpc	r9,lr
8000d52a:	e0 8b 00 18 	brhi	8000d55a <__avr32_f64_cmp_lt+0x52>
8000d52e:	58 0b       	cp.w	r11,0
8000d530:	f5 ba 00 00 	subfeq	r10,0
8000d534:	c1 50       	breq	8000d55e <__avr32_f64_cmp_lt+0x56>
8000d536:	1b 07       	ld.w	r7,sp++
8000d538:	1b 0e       	ld.w	lr,sp++
8000d53a:	58 3c       	cp.w	r12,3
8000d53c:	c0 a0       	breq	8000d550 <__avr32_f64_cmp_lt+0x48>
8000d53e:	58 1c       	cp.w	r12,1
8000d540:	c0 33       	brcs	8000d546 <__avr32_f64_cmp_lt+0x3e>
8000d542:	5e 0d       	reteq	0
8000d544:	5e 1f       	retne	1
8000d546:	10 3a       	cp.w	r10,r8
8000d548:	f2 0b 13 00 	cpc	r11,r9
8000d54c:	5e 2d       	reths	0
8000d54e:	5e 3f       	retlo	1
8000d550:	14 38       	cp.w	r8,r10
8000d552:	f6 09 13 00 	cpc	r9,r11
8000d556:	5e 2d       	reths	0
8000d558:	5e 3f       	retlo	1
8000d55a:	1b 07       	ld.w	r7,sp++
8000d55c:	d8 0a       	popm	pc,r12=0
8000d55e:	58 17       	cp.w	r7,1
8000d560:	5f 1c       	srne	r12
8000d562:	58 09       	cp.w	r9,0
8000d564:	f5 b8 00 00 	subfeq	r8,0
8000d568:	1b 07       	ld.w	r7,sp++
8000d56a:	1b 0e       	ld.w	lr,sp++
8000d56c:	5e 0d       	reteq	0
8000d56e:	5e fc       	retal	r12

8000d570 <__avr32_f64_div>:
8000d570:	eb cd 40 ff 	pushm	r0-r7,lr
8000d574:	f7 e9 20 0e 	eor	lr,r11,r9
8000d578:	f6 07 16 14 	lsr	r7,r11,0x14
8000d57c:	a9 7b       	lsl	r11,0x9
8000d57e:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000d582:	a9 7a       	lsl	r10,0x9
8000d584:	bd bb       	sbr	r11,0x1d
8000d586:	e4 1b 3f ff 	andh	r11,0x3fff
8000d58a:	ab d7       	cbr	r7,0xb
8000d58c:	e0 80 00 cc 	breq	8000d724 <__avr32_f64_div_round_subnormal+0x54>
8000d590:	e0 47 07 ff 	cp.w	r7,2047
8000d594:	e0 84 00 b5 	brge	8000d6fe <__avr32_f64_div_round_subnormal+0x2e>
8000d598:	f2 06 16 14 	lsr	r6,r9,0x14
8000d59c:	a9 79       	lsl	r9,0x9
8000d59e:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000d5a2:	a9 78       	lsl	r8,0x9
8000d5a4:	bd b9       	sbr	r9,0x1d
8000d5a6:	e4 19 3f ff 	andh	r9,0x3fff
8000d5aa:	ab d6       	cbr	r6,0xb
8000d5ac:	e0 80 00 e2 	breq	8000d770 <__avr32_f64_div_round_subnormal+0xa0>
8000d5b0:	e0 46 07 ff 	cp.w	r6,2047
8000d5b4:	e0 84 00 b2 	brge	8000d718 <__avr32_f64_div_round_subnormal+0x48>
8000d5b8:	0c 17       	sub	r7,r6
8000d5ba:	fe 37 fc 01 	sub	r7,-1023
8000d5be:	fc 1c 80 00 	movh	r12,0x8000
8000d5c2:	f8 03 16 01 	lsr	r3,r12,0x1
8000d5c6:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000d5ca:	5c d4       	com	r4
8000d5cc:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000d5d0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d5d4:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000d5d8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d5dc:	ea 03 15 02 	lsl	r3,r5,0x2
8000d5e0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d5e4:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000d5e8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d5ec:	ea 03 15 02 	lsl	r3,r5,0x2
8000d5f0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d5f4:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000d5f8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d5fc:	ea 03 15 02 	lsl	r3,r5,0x2
8000d600:	e6 08 06 40 	mulu.d	r0,r3,r8
8000d604:	e4 09 07 40 	macu.d	r0,r2,r9
8000d608:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d60c:	02 04       	add	r4,r1
8000d60e:	5c 05       	acr	r5
8000d610:	a3 65       	lsl	r5,0x2
8000d612:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000d616:	a3 64       	lsl	r4,0x2
8000d618:	5c 34       	neg	r4
8000d61a:	f8 05 01 45 	sbc	r5,r12,r5
8000d61e:	e6 04 06 40 	mulu.d	r0,r3,r4
8000d622:	e4 05 07 40 	macu.d	r0,r2,r5
8000d626:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d62a:	02 04       	add	r4,r1
8000d62c:	5c 05       	acr	r5
8000d62e:	ea 03 15 02 	lsl	r3,r5,0x2
8000d632:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000d636:	e8 02 15 02 	lsl	r2,r4,0x2
8000d63a:	e6 08 06 40 	mulu.d	r0,r3,r8
8000d63e:	e4 09 07 40 	macu.d	r0,r2,r9
8000d642:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d646:	02 04       	add	r4,r1
8000d648:	5c 05       	acr	r5
8000d64a:	a3 65       	lsl	r5,0x2
8000d64c:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000d650:	a3 64       	lsl	r4,0x2
8000d652:	5c 34       	neg	r4
8000d654:	f8 05 01 45 	sbc	r5,r12,r5
8000d658:	e6 04 06 40 	mulu.d	r0,r3,r4
8000d65c:	e4 05 07 40 	macu.d	r0,r2,r5
8000d660:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d664:	02 04       	add	r4,r1
8000d666:	5c 05       	acr	r5
8000d668:	ea 03 15 02 	lsl	r3,r5,0x2
8000d66c:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000d670:	e8 02 15 02 	lsl	r2,r4,0x2
8000d674:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000d678:	e4 0b 07 40 	macu.d	r0,r2,r11
8000d67c:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000d680:	02 02       	add	r2,r1
8000d682:	5c 03       	acr	r3
8000d684:	ed b3 00 1c 	bld	r3,0x1c
8000d688:	c0 90       	breq	8000d69a <__avr32_f64_div+0x12a>
8000d68a:	a1 72       	lsl	r2,0x1
8000d68c:	5c f3       	rol	r3
8000d68e:	20 17       	sub	r7,1
8000d690:	a3 9a       	lsr	r10,0x3
8000d692:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000d696:	a3 9b       	lsr	r11,0x3
8000d698:	c0 58       	rjmp	8000d6a2 <__avr32_f64_div+0x132>
8000d69a:	a5 8a       	lsr	r10,0x4
8000d69c:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000d6a0:	a5 8b       	lsr	r11,0x4
8000d6a2:	58 07       	cp.w	r7,0
8000d6a4:	e0 8a 00 8b 	brle	8000d7ba <__avr32_f64_div_res_subnormal>
8000d6a8:	e0 12 ff 00 	andl	r2,0xff00
8000d6ac:	e8 12 00 80 	orl	r2,0x80
8000d6b0:	e6 08 06 40 	mulu.d	r0,r3,r8
8000d6b4:	e4 09 07 40 	macu.d	r0,r2,r9
8000d6b8:	e4 08 06 44 	mulu.d	r4,r2,r8
8000d6bc:	e6 09 06 48 	mulu.d	r8,r3,r9
8000d6c0:	00 05       	add	r5,r0
8000d6c2:	f0 01 00 48 	adc	r8,r8,r1
8000d6c6:	5c 09       	acr	r9
8000d6c8:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000d6cc:	58 04       	cp.w	r4,0
8000d6ce:	5c 25       	cpc	r5

8000d6d0 <__avr32_f64_div_round_subnormal>:
8000d6d0:	f4 08 13 00 	cpc	r8,r10
8000d6d4:	f6 09 13 00 	cpc	r9,r11
8000d6d8:	5f 36       	srlo	r6
8000d6da:	f8 06 17 00 	moveq	r6,r12
8000d6de:	e4 0a 16 08 	lsr	r10,r2,0x8
8000d6e2:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000d6e6:	e6 0b 16 08 	lsr	r11,r3,0x8
8000d6ea:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000d6ee:	ed be 00 1f 	bld	lr,0x1f
8000d6f2:	ef bb 00 1f 	bst	r11,0x1f
8000d6f6:	0c 0a       	add	r10,r6
8000d6f8:	5c 0b       	acr	r11
8000d6fa:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000d6fe:	e4 1b 00 0f 	andh	r11,0xf
8000d702:	14 4b       	or	r11,r10
8000d704:	e0 81 00 a7 	brne	8000d852 <__avr32_f64_div_res_subnormal+0x98>
8000d708:	f2 06 16 14 	lsr	r6,r9,0x14
8000d70c:	ab d6       	cbr	r6,0xb
8000d70e:	e0 46 07 ff 	cp.w	r6,2047
8000d712:	e0 81 00 a4 	brne	8000d85a <__avr32_f64_div_res_subnormal+0xa0>
8000d716:	c9 e8       	rjmp	8000d852 <__avr32_f64_div_res_subnormal+0x98>
8000d718:	e4 19 00 0f 	andh	r9,0xf
8000d71c:	10 49       	or	r9,r8
8000d71e:	e0 81 00 9a 	brne	8000d852 <__avr32_f64_div_res_subnormal+0x98>
8000d722:	c9 28       	rjmp	8000d846 <__avr32_f64_div_res_subnormal+0x8c>
8000d724:	a3 7b       	lsl	r11,0x3
8000d726:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000d72a:	a3 7a       	lsl	r10,0x3
8000d72c:	f5 eb 10 04 	or	r4,r10,r11
8000d730:	e0 80 00 a0 	breq	8000d870 <__avr32_f64_div_op1_zero>
8000d734:	f6 04 12 00 	clz	r4,r11
8000d738:	c1 70       	breq	8000d766 <__avr32_f64_div_round_subnormal+0x96>
8000d73a:	c0 c3       	brcs	8000d752 <__avr32_f64_div_round_subnormal+0x82>
8000d73c:	e8 05 11 20 	rsub	r5,r4,32
8000d740:	f6 04 09 4b 	lsl	r11,r11,r4
8000d744:	f4 05 0a 45 	lsr	r5,r10,r5
8000d748:	0a 4b       	or	r11,r5
8000d74a:	f4 04 09 4a 	lsl	r10,r10,r4
8000d74e:	08 17       	sub	r7,r4
8000d750:	c0 b8       	rjmp	8000d766 <__avr32_f64_div_round_subnormal+0x96>
8000d752:	f4 04 12 00 	clz	r4,r10
8000d756:	f9 b4 03 00 	movlo	r4,0
8000d75a:	f7 b4 02 e0 	subhs	r4,-32
8000d75e:	f4 04 09 4b 	lsl	r11,r10,r4
8000d762:	30 0a       	mov	r10,0
8000d764:	08 17       	sub	r7,r4
8000d766:	a3 8a       	lsr	r10,0x2
8000d768:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000d76c:	a3 8b       	lsr	r11,0x2
8000d76e:	c1 1b       	rjmp	8000d590 <__avr32_f64_div+0x20>
8000d770:	a3 79       	lsl	r9,0x3
8000d772:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000d776:	a3 78       	lsl	r8,0x3
8000d778:	f3 e8 10 04 	or	r4,r9,r8
8000d77c:	c6 f0       	breq	8000d85a <__avr32_f64_div_res_subnormal+0xa0>
8000d77e:	f2 04 12 00 	clz	r4,r9
8000d782:	c1 70       	breq	8000d7b0 <__avr32_f64_div_round_subnormal+0xe0>
8000d784:	c0 c3       	brcs	8000d79c <__avr32_f64_div_round_subnormal+0xcc>
8000d786:	e8 05 11 20 	rsub	r5,r4,32
8000d78a:	f2 04 09 49 	lsl	r9,r9,r4
8000d78e:	f0 05 0a 45 	lsr	r5,r8,r5
8000d792:	0a 49       	or	r9,r5
8000d794:	f0 04 09 48 	lsl	r8,r8,r4
8000d798:	08 16       	sub	r6,r4
8000d79a:	c0 b8       	rjmp	8000d7b0 <__avr32_f64_div_round_subnormal+0xe0>
8000d79c:	f0 04 12 00 	clz	r4,r8
8000d7a0:	f9 b4 03 00 	movlo	r4,0
8000d7a4:	f7 b4 02 e0 	subhs	r4,-32
8000d7a8:	f0 04 09 49 	lsl	r9,r8,r4
8000d7ac:	30 08       	mov	r8,0
8000d7ae:	08 16       	sub	r6,r4
8000d7b0:	a3 88       	lsr	r8,0x2
8000d7b2:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000d7b6:	a3 89       	lsr	r9,0x2
8000d7b8:	cf ca       	rjmp	8000d5b0 <__avr32_f64_div+0x40>

8000d7ba <__avr32_f64_div_res_subnormal>:
8000d7ba:	5c 37       	neg	r7
8000d7bc:	2f f7       	sub	r7,-1
8000d7be:	f1 b7 04 c0 	satu	r7,0x6
8000d7c2:	e0 47 00 20 	cp.w	r7,32
8000d7c6:	c1 54       	brge	8000d7f0 <__avr32_f64_div_res_subnormal+0x36>
8000d7c8:	ee 06 11 20 	rsub	r6,r7,32
8000d7cc:	e4 07 0a 42 	lsr	r2,r2,r7
8000d7d0:	e6 06 09 4c 	lsl	r12,r3,r6
8000d7d4:	18 42       	or	r2,r12
8000d7d6:	e6 07 0a 43 	lsr	r3,r3,r7
8000d7da:	f4 06 09 41 	lsl	r1,r10,r6
8000d7de:	f4 07 0a 4a 	lsr	r10,r10,r7
8000d7e2:	f6 06 09 4c 	lsl	r12,r11,r6
8000d7e6:	18 4a       	or	r10,r12
8000d7e8:	f6 07 0a 4b 	lsr	r11,r11,r7
8000d7ec:	30 00       	mov	r0,0
8000d7ee:	c1 58       	rjmp	8000d818 <__avr32_f64_div_res_subnormal+0x5e>
8000d7f0:	ee 06 11 20 	rsub	r6,r7,32
8000d7f4:	f9 b0 00 00 	moveq	r0,0
8000d7f8:	f9 bc 00 00 	moveq	r12,0
8000d7fc:	c0 50       	breq	8000d806 <__avr32_f64_div_res_subnormal+0x4c>
8000d7fe:	f4 06 09 40 	lsl	r0,r10,r6
8000d802:	f6 06 09 4c 	lsl	r12,r11,r6
8000d806:	e6 07 0a 42 	lsr	r2,r3,r7
8000d80a:	30 03       	mov	r3,0
8000d80c:	f4 07 0a 41 	lsr	r1,r10,r7
8000d810:	18 41       	or	r1,r12
8000d812:	f6 07 0a 4a 	lsr	r10,r11,r7
8000d816:	30 0b       	mov	r11,0
8000d818:	e0 12 ff 00 	andl	r2,0xff00
8000d81c:	e8 12 00 80 	orl	r2,0x80
8000d820:	e6 08 06 46 	mulu.d	r6,r3,r8
8000d824:	e4 09 07 46 	macu.d	r6,r2,r9
8000d828:	e4 08 06 44 	mulu.d	r4,r2,r8
8000d82c:	e6 09 06 48 	mulu.d	r8,r3,r9
8000d830:	0c 05       	add	r5,r6
8000d832:	f0 07 00 48 	adc	r8,r8,r7
8000d836:	5c 09       	acr	r9
8000d838:	30 07       	mov	r7,0
8000d83a:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000d83e:	00 34       	cp.w	r4,r0
8000d840:	e2 05 13 00 	cpc	r5,r1
8000d844:	c4 6b       	rjmp	8000d6d0 <__avr32_f64_div_round_subnormal>
8000d846:	1c 9b       	mov	r11,lr
8000d848:	e6 1b 80 00 	andh	r11,0x8000,COH
8000d84c:	30 0a       	mov	r10,0
8000d84e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000d852:	3f fb       	mov	r11,-1
8000d854:	30 0a       	mov	r10,0
8000d856:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000d85a:	f5 eb 10 04 	or	r4,r10,r11
8000d85e:	c0 90       	breq	8000d870 <__avr32_f64_div_op1_zero>
8000d860:	1c 9b       	mov	r11,lr
8000d862:	e6 1b 80 00 	andh	r11,0x8000,COH
8000d866:	ea 1b 7f f0 	orh	r11,0x7ff0
8000d86a:	30 0a       	mov	r10,0
8000d86c:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000d870 <__avr32_f64_div_op1_zero>:
8000d870:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000d874:	ce f0       	breq	8000d852 <__avr32_f64_div_res_subnormal+0x98>
8000d876:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000d87a:	e0 44 07 ff 	cp.w	r4,2047
8000d87e:	ce 41       	brne	8000d846 <__avr32_f64_div_res_subnormal+0x8c>
8000d880:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000d884:	ce 10       	breq	8000d846 <__avr32_f64_div_res_subnormal+0x8c>
8000d886:	ce 6b       	rjmp	8000d852 <__avr32_f64_div_res_subnormal+0x98>

8000d888 <__avr32_udiv64>:
8000d888:	d4 31       	pushm	r0-r7,lr
8000d88a:	1a 97       	mov	r7,sp
8000d88c:	20 3d       	sub	sp,12
8000d88e:	10 9c       	mov	r12,r8
8000d890:	12 9e       	mov	lr,r9
8000d892:	14 93       	mov	r3,r10
8000d894:	58 09       	cp.w	r9,0
8000d896:	e0 81 00 bd 	brne	8000da10 <__avr32_udiv64+0x188>
8000d89a:	16 38       	cp.w	r8,r11
8000d89c:	e0 88 00 40 	brls	8000d91c <__avr32_udiv64+0x94>
8000d8a0:	f0 08 12 00 	clz	r8,r8
8000d8a4:	c0 d0       	breq	8000d8be <__avr32_udiv64+0x36>
8000d8a6:	f6 08 09 4b 	lsl	r11,r11,r8
8000d8aa:	f0 09 11 20 	rsub	r9,r8,32
8000d8ae:	f8 08 09 4c 	lsl	r12,r12,r8
8000d8b2:	f4 09 0a 49 	lsr	r9,r10,r9
8000d8b6:	f4 08 09 43 	lsl	r3,r10,r8
8000d8ba:	f3 eb 10 0b 	or	r11,r9,r11
8000d8be:	f8 0e 16 10 	lsr	lr,r12,0x10
8000d8c2:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000d8c6:	f6 0e 0d 00 	divu	r0,r11,lr
8000d8ca:	e6 0b 16 10 	lsr	r11,r3,0x10
8000d8ce:	00 99       	mov	r9,r0
8000d8d0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d8d4:	e0 0a 02 48 	mul	r8,r0,r10
8000d8d8:	10 3b       	cp.w	r11,r8
8000d8da:	c0 a2       	brcc	8000d8ee <__avr32_udiv64+0x66>
8000d8dc:	20 19       	sub	r9,1
8000d8de:	18 0b       	add	r11,r12
8000d8e0:	18 3b       	cp.w	r11,r12
8000d8e2:	c0 63       	brcs	8000d8ee <__avr32_udiv64+0x66>
8000d8e4:	10 3b       	cp.w	r11,r8
8000d8e6:	f7 b9 03 01 	sublo	r9,1
8000d8ea:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d8ee:	f6 08 01 01 	sub	r1,r11,r8
8000d8f2:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000d8f6:	e2 0e 0d 00 	divu	r0,r1,lr
8000d8fa:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000d8fe:	00 98       	mov	r8,r0
8000d900:	e0 0a 02 4a 	mul	r10,r0,r10
8000d904:	14 33       	cp.w	r3,r10
8000d906:	c0 82       	brcc	8000d916 <__avr32_udiv64+0x8e>
8000d908:	20 18       	sub	r8,1
8000d90a:	18 03       	add	r3,r12
8000d90c:	18 33       	cp.w	r3,r12
8000d90e:	c0 43       	brcs	8000d916 <__avr32_udiv64+0x8e>
8000d910:	14 33       	cp.w	r3,r10
8000d912:	f7 b8 03 01 	sublo	r8,1
8000d916:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000d91a:	cd f8       	rjmp	8000dad8 <__avr32_udiv64+0x250>
8000d91c:	58 08       	cp.w	r8,0
8000d91e:	c0 51       	brne	8000d928 <__avr32_udiv64+0xa0>
8000d920:	30 19       	mov	r9,1
8000d922:	f2 08 0d 08 	divu	r8,r9,r8
8000d926:	10 9c       	mov	r12,r8
8000d928:	f8 06 12 00 	clz	r6,r12
8000d92c:	c0 41       	brne	8000d934 <__avr32_udiv64+0xac>
8000d92e:	18 1b       	sub	r11,r12
8000d930:	30 19       	mov	r9,1
8000d932:	c4 08       	rjmp	8000d9b2 <__avr32_udiv64+0x12a>
8000d934:	ec 01 11 20 	rsub	r1,r6,32
8000d938:	f4 01 0a 49 	lsr	r9,r10,r1
8000d93c:	f8 06 09 4c 	lsl	r12,r12,r6
8000d940:	f6 06 09 48 	lsl	r8,r11,r6
8000d944:	f6 01 0a 41 	lsr	r1,r11,r1
8000d948:	f3 e8 10 08 	or	r8,r9,r8
8000d94c:	f8 03 16 10 	lsr	r3,r12,0x10
8000d950:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000d954:	e2 03 0d 00 	divu	r0,r1,r3
8000d958:	f0 0b 16 10 	lsr	r11,r8,0x10
8000d95c:	00 9e       	mov	lr,r0
8000d95e:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d962:	e0 05 02 49 	mul	r9,r0,r5
8000d966:	12 3b       	cp.w	r11,r9
8000d968:	c0 a2       	brcc	8000d97c <__avr32_udiv64+0xf4>
8000d96a:	20 1e       	sub	lr,1
8000d96c:	18 0b       	add	r11,r12
8000d96e:	18 3b       	cp.w	r11,r12
8000d970:	c0 63       	brcs	8000d97c <__avr32_udiv64+0xf4>
8000d972:	12 3b       	cp.w	r11,r9
8000d974:	f7 be 03 01 	sublo	lr,1
8000d978:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d97c:	12 1b       	sub	r11,r9
8000d97e:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000d982:	f6 03 0d 02 	divu	r2,r11,r3
8000d986:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000d98a:	04 99       	mov	r9,r2
8000d98c:	e4 05 02 4b 	mul	r11,r2,r5
8000d990:	16 38       	cp.w	r8,r11
8000d992:	c0 a2       	brcc	8000d9a6 <__avr32_udiv64+0x11e>
8000d994:	20 19       	sub	r9,1
8000d996:	18 08       	add	r8,r12
8000d998:	18 38       	cp.w	r8,r12
8000d99a:	c0 63       	brcs	8000d9a6 <__avr32_udiv64+0x11e>
8000d99c:	16 38       	cp.w	r8,r11
8000d99e:	f7 b9 03 01 	sublo	r9,1
8000d9a2:	f1 dc e3 08 	addcs	r8,r8,r12
8000d9a6:	f4 06 09 43 	lsl	r3,r10,r6
8000d9aa:	f0 0b 01 0b 	sub	r11,r8,r11
8000d9ae:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000d9b2:	f8 06 16 10 	lsr	r6,r12,0x10
8000d9b6:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000d9ba:	f6 06 0d 00 	divu	r0,r11,r6
8000d9be:	e6 0b 16 10 	lsr	r11,r3,0x10
8000d9c2:	00 9a       	mov	r10,r0
8000d9c4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d9c8:	e0 0e 02 48 	mul	r8,r0,lr
8000d9cc:	10 3b       	cp.w	r11,r8
8000d9ce:	c0 a2       	brcc	8000d9e2 <__avr32_udiv64+0x15a>
8000d9d0:	20 1a       	sub	r10,1
8000d9d2:	18 0b       	add	r11,r12
8000d9d4:	18 3b       	cp.w	r11,r12
8000d9d6:	c0 63       	brcs	8000d9e2 <__avr32_udiv64+0x15a>
8000d9d8:	10 3b       	cp.w	r11,r8
8000d9da:	f7 ba 03 01 	sublo	r10,1
8000d9de:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d9e2:	f6 08 01 01 	sub	r1,r11,r8
8000d9e6:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000d9ea:	e2 06 0d 00 	divu	r0,r1,r6
8000d9ee:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000d9f2:	00 98       	mov	r8,r0
8000d9f4:	e0 0e 02 4b 	mul	r11,r0,lr
8000d9f8:	16 33       	cp.w	r3,r11
8000d9fa:	c0 82       	brcc	8000da0a <__avr32_udiv64+0x182>
8000d9fc:	20 18       	sub	r8,1
8000d9fe:	18 03       	add	r3,r12
8000da00:	18 33       	cp.w	r3,r12
8000da02:	c0 43       	brcs	8000da0a <__avr32_udiv64+0x182>
8000da04:	16 33       	cp.w	r3,r11
8000da06:	f7 b8 03 01 	sublo	r8,1
8000da0a:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000da0e:	c6 98       	rjmp	8000dae0 <__avr32_udiv64+0x258>
8000da10:	16 39       	cp.w	r9,r11
8000da12:	e0 8b 00 65 	brhi	8000dadc <__avr32_udiv64+0x254>
8000da16:	f2 09 12 00 	clz	r9,r9
8000da1a:	c0 b1       	brne	8000da30 <__avr32_udiv64+0x1a8>
8000da1c:	10 3a       	cp.w	r10,r8
8000da1e:	5f 2a       	srhs	r10
8000da20:	1c 3b       	cp.w	r11,lr
8000da22:	5f b8       	srhi	r8
8000da24:	10 4a       	or	r10,r8
8000da26:	f2 0a 18 00 	cp.b	r10,r9
8000da2a:	c5 90       	breq	8000dadc <__avr32_udiv64+0x254>
8000da2c:	30 18       	mov	r8,1
8000da2e:	c5 98       	rjmp	8000dae0 <__avr32_udiv64+0x258>
8000da30:	f0 09 09 46 	lsl	r6,r8,r9
8000da34:	f2 03 11 20 	rsub	r3,r9,32
8000da38:	fc 09 09 4e 	lsl	lr,lr,r9
8000da3c:	f0 03 0a 48 	lsr	r8,r8,r3
8000da40:	f6 09 09 4c 	lsl	r12,r11,r9
8000da44:	f4 03 0a 42 	lsr	r2,r10,r3
8000da48:	ef 46 ff f4 	st.w	r7[-12],r6
8000da4c:	f6 03 0a 43 	lsr	r3,r11,r3
8000da50:	18 42       	or	r2,r12
8000da52:	f1 ee 10 0c 	or	r12,r8,lr
8000da56:	f8 01 16 10 	lsr	r1,r12,0x10
8000da5a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000da5e:	e6 01 0d 04 	divu	r4,r3,r1
8000da62:	e4 03 16 10 	lsr	r3,r2,0x10
8000da66:	08 9e       	mov	lr,r4
8000da68:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000da6c:	e8 06 02 48 	mul	r8,r4,r6
8000da70:	10 33       	cp.w	r3,r8
8000da72:	c0 a2       	brcc	8000da86 <__avr32_udiv64+0x1fe>
8000da74:	20 1e       	sub	lr,1
8000da76:	18 03       	add	r3,r12
8000da78:	18 33       	cp.w	r3,r12
8000da7a:	c0 63       	brcs	8000da86 <__avr32_udiv64+0x1fe>
8000da7c:	10 33       	cp.w	r3,r8
8000da7e:	f7 be 03 01 	sublo	lr,1
8000da82:	e7 dc e3 03 	addcs	r3,r3,r12
8000da86:	10 13       	sub	r3,r8
8000da88:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000da8c:	e6 01 0d 00 	divu	r0,r3,r1
8000da90:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000da94:	00 98       	mov	r8,r0
8000da96:	e0 06 02 46 	mul	r6,r0,r6
8000da9a:	0c 3b       	cp.w	r11,r6
8000da9c:	c0 a2       	brcc	8000dab0 <__avr32_udiv64+0x228>
8000da9e:	20 18       	sub	r8,1
8000daa0:	18 0b       	add	r11,r12
8000daa2:	18 3b       	cp.w	r11,r12
8000daa4:	c0 63       	brcs	8000dab0 <__avr32_udiv64+0x228>
8000daa6:	0c 3b       	cp.w	r11,r6
8000daa8:	f7 dc e3 0b 	addcs	r11,r11,r12
8000daac:	f7 b8 03 01 	sublo	r8,1
8000dab0:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000dab4:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000dab8:	0c 1b       	sub	r11,r6
8000daba:	f0 04 06 42 	mulu.d	r2,r8,r4
8000dabe:	06 95       	mov	r5,r3
8000dac0:	16 35       	cp.w	r5,r11
8000dac2:	e0 8b 00 0a 	brhi	8000dad6 <__avr32_udiv64+0x24e>
8000dac6:	5f 0b       	sreq	r11
8000dac8:	f4 09 09 49 	lsl	r9,r10,r9
8000dacc:	12 32       	cp.w	r2,r9
8000dace:	5f b9       	srhi	r9
8000dad0:	f7 e9 00 09 	and	r9,r11,r9
8000dad4:	c0 60       	breq	8000dae0 <__avr32_udiv64+0x258>
8000dad6:	20 18       	sub	r8,1
8000dad8:	30 09       	mov	r9,0
8000dada:	c0 38       	rjmp	8000dae0 <__avr32_udiv64+0x258>
8000dadc:	30 09       	mov	r9,0
8000dade:	12 98       	mov	r8,r9
8000dae0:	10 9a       	mov	r10,r8
8000dae2:	12 93       	mov	r3,r9
8000dae4:	10 92       	mov	r2,r8
8000dae6:	12 9b       	mov	r11,r9
8000dae8:	2f dd       	sub	sp,-12
8000daea:	d8 32       	popm	r0-r7,pc

8000daec <__avr32_umod64>:
8000daec:	d4 31       	pushm	r0-r7,lr
8000daee:	1a 97       	mov	r7,sp
8000daf0:	20 3d       	sub	sp,12
8000daf2:	10 9c       	mov	r12,r8
8000daf4:	12 95       	mov	r5,r9
8000daf6:	14 9e       	mov	lr,r10
8000daf8:	16 91       	mov	r1,r11
8000dafa:	16 96       	mov	r6,r11
8000dafc:	58 09       	cp.w	r9,0
8000dafe:	e0 81 00 81 	brne	8000dc00 <__avr32_umod64+0x114>
8000db02:	16 38       	cp.w	r8,r11
8000db04:	e0 88 00 12 	brls	8000db28 <__avr32_umod64+0x3c>
8000db08:	f0 08 12 00 	clz	r8,r8
8000db0c:	c4 e0       	breq	8000dba8 <__avr32_umod64+0xbc>
8000db0e:	f6 08 09 46 	lsl	r6,r11,r8
8000db12:	f8 08 09 4c 	lsl	r12,r12,r8
8000db16:	f0 0b 11 20 	rsub	r11,r8,32
8000db1a:	f4 08 09 4e 	lsl	lr,r10,r8
8000db1e:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000db22:	f7 e6 10 06 	or	r6,r11,r6
8000db26:	c4 18       	rjmp	8000dba8 <__avr32_umod64+0xbc>
8000db28:	58 08       	cp.w	r8,0
8000db2a:	c0 51       	brne	8000db34 <__avr32_umod64+0x48>
8000db2c:	30 19       	mov	r9,1
8000db2e:	f2 08 0d 08 	divu	r8,r9,r8
8000db32:	10 9c       	mov	r12,r8
8000db34:	f8 08 12 00 	clz	r8,r12
8000db38:	c0 31       	brne	8000db3e <__avr32_umod64+0x52>
8000db3a:	18 16       	sub	r6,r12
8000db3c:	c3 68       	rjmp	8000dba8 <__avr32_umod64+0xbc>
8000db3e:	f0 03 11 20 	rsub	r3,r8,32
8000db42:	f4 03 0a 4b 	lsr	r11,r10,r3
8000db46:	f8 08 09 4c 	lsl	r12,r12,r8
8000db4a:	ec 08 09 49 	lsl	r9,r6,r8
8000db4e:	ec 03 0a 43 	lsr	r3,r6,r3
8000db52:	f7 e9 10 09 	or	r9,r11,r9
8000db56:	f8 05 16 10 	lsr	r5,r12,0x10
8000db5a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000db5e:	e6 05 0d 02 	divu	r2,r3,r5
8000db62:	f2 0e 16 10 	lsr	lr,r9,0x10
8000db66:	ec 02 02 4b 	mul	r11,r6,r2
8000db6a:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000db6e:	16 3e       	cp.w	lr,r11
8000db70:	c0 72       	brcc	8000db7e <__avr32_umod64+0x92>
8000db72:	18 0e       	add	lr,r12
8000db74:	18 3e       	cp.w	lr,r12
8000db76:	c0 43       	brcs	8000db7e <__avr32_umod64+0x92>
8000db78:	16 3e       	cp.w	lr,r11
8000db7a:	fd dc e3 0e 	addcs	lr,lr,r12
8000db7e:	fc 0b 01 03 	sub	r3,lr,r11
8000db82:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000db86:	e6 05 0d 02 	divu	r2,r3,r5
8000db8a:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000db8e:	a5 36       	mul	r6,r2
8000db90:	0c 39       	cp.w	r9,r6
8000db92:	c0 72       	brcc	8000dba0 <__avr32_umod64+0xb4>
8000db94:	18 09       	add	r9,r12
8000db96:	18 39       	cp.w	r9,r12
8000db98:	c0 43       	brcs	8000dba0 <__avr32_umod64+0xb4>
8000db9a:	0c 39       	cp.w	r9,r6
8000db9c:	f3 dc e3 09 	addcs	r9,r9,r12
8000dba0:	f2 06 01 06 	sub	r6,r9,r6
8000dba4:	f4 08 09 4e 	lsl	lr,r10,r8
8000dba8:	f8 0a 16 10 	lsr	r10,r12,0x10
8000dbac:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000dbb0:	ec 0a 0d 02 	divu	r2,r6,r10
8000dbb4:	fc 09 16 10 	lsr	r9,lr,0x10
8000dbb8:	ea 02 02 4b 	mul	r11,r5,r2
8000dbbc:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000dbc0:	16 39       	cp.w	r9,r11
8000dbc2:	c0 72       	brcc	8000dbd0 <__avr32_umod64+0xe4>
8000dbc4:	18 09       	add	r9,r12
8000dbc6:	18 39       	cp.w	r9,r12
8000dbc8:	c0 43       	brcs	8000dbd0 <__avr32_umod64+0xe4>
8000dbca:	16 39       	cp.w	r9,r11
8000dbcc:	f3 dc e3 09 	addcs	r9,r9,r12
8000dbd0:	f2 0b 01 0b 	sub	r11,r9,r11
8000dbd4:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000dbd8:	f6 0a 0d 0a 	divu	r10,r11,r10
8000dbdc:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000dbe0:	ea 0a 02 4a 	mul	r10,r5,r10
8000dbe4:	14 3e       	cp.w	lr,r10
8000dbe6:	c0 72       	brcc	8000dbf4 <__avr32_umod64+0x108>
8000dbe8:	18 0e       	add	lr,r12
8000dbea:	18 3e       	cp.w	lr,r12
8000dbec:	c0 43       	brcs	8000dbf4 <__avr32_umod64+0x108>
8000dbee:	14 3e       	cp.w	lr,r10
8000dbf0:	fd dc e3 0e 	addcs	lr,lr,r12
8000dbf4:	fc 0a 01 0a 	sub	r10,lr,r10
8000dbf8:	30 0b       	mov	r11,0
8000dbfa:	f4 08 0a 4a 	lsr	r10,r10,r8
8000dbfe:	c7 b8       	rjmp	8000dcf4 <__avr32_umod64+0x208>
8000dc00:	16 39       	cp.w	r9,r11
8000dc02:	e0 8b 00 79 	brhi	8000dcf4 <__avr32_umod64+0x208>
8000dc06:	f2 09 12 00 	clz	r9,r9
8000dc0a:	c1 21       	brne	8000dc2e <__avr32_umod64+0x142>
8000dc0c:	10 3a       	cp.w	r10,r8
8000dc0e:	5f 2b       	srhs	r11
8000dc10:	0a 31       	cp.w	r1,r5
8000dc12:	5f ba       	srhi	r10
8000dc14:	f7 ea 10 0a 	or	r10,r11,r10
8000dc18:	f2 0a 18 00 	cp.b	r10,r9
8000dc1c:	c0 60       	breq	8000dc28 <__avr32_umod64+0x13c>
8000dc1e:	fc 08 01 0c 	sub	r12,lr,r8
8000dc22:	e2 05 01 46 	sbc	r6,r1,r5
8000dc26:	18 9e       	mov	lr,r12
8000dc28:	0c 9b       	mov	r11,r6
8000dc2a:	1c 9a       	mov	r10,lr
8000dc2c:	c6 48       	rjmp	8000dcf4 <__avr32_umod64+0x208>
8000dc2e:	ea 09 09 4c 	lsl	r12,r5,r9
8000dc32:	f2 06 11 20 	rsub	r6,r9,32
8000dc36:	f6 09 09 4b 	lsl	r11,r11,r9
8000dc3a:	f0 09 09 42 	lsl	r2,r8,r9
8000dc3e:	ef 46 ff f4 	st.w	r7[-12],r6
8000dc42:	f0 06 0a 48 	lsr	r8,r8,r6
8000dc46:	18 48       	or	r8,r12
8000dc48:	e2 06 0a 4c 	lsr	r12,r1,r6
8000dc4c:	f4 09 09 43 	lsl	r3,r10,r9
8000dc50:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000dc54:	f4 06 0a 4a 	lsr	r10,r10,r6
8000dc58:	16 4a       	or	r10,r11
8000dc5a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000dc5e:	f8 0b 0d 04 	divu	r4,r12,r11
8000dc62:	f4 0c 16 10 	lsr	r12,r10,0x10
8000dc66:	08 91       	mov	r1,r4
8000dc68:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000dc6c:	e8 0e 02 46 	mul	r6,r4,lr
8000dc70:	0c 3c       	cp.w	r12,r6
8000dc72:	c0 a2       	brcc	8000dc86 <__avr32_umod64+0x19a>
8000dc74:	20 11       	sub	r1,1
8000dc76:	10 0c       	add	r12,r8
8000dc78:	10 3c       	cp.w	r12,r8
8000dc7a:	c0 63       	brcs	8000dc86 <__avr32_umod64+0x19a>
8000dc7c:	0c 3c       	cp.w	r12,r6
8000dc7e:	f7 b1 03 01 	sublo	r1,1
8000dc82:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000dc86:	0c 1c       	sub	r12,r6
8000dc88:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000dc8c:	f8 0b 0d 04 	divu	r4,r12,r11
8000dc90:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000dc94:	08 96       	mov	r6,r4
8000dc96:	e8 0e 02 4e 	mul	lr,r4,lr
8000dc9a:	1c 3b       	cp.w	r11,lr
8000dc9c:	c0 a2       	brcc	8000dcb0 <__avr32_umod64+0x1c4>
8000dc9e:	20 16       	sub	r6,1
8000dca0:	10 0b       	add	r11,r8
8000dca2:	10 3b       	cp.w	r11,r8
8000dca4:	c0 63       	brcs	8000dcb0 <__avr32_umod64+0x1c4>
8000dca6:	1c 3b       	cp.w	r11,lr
8000dca8:	f7 b6 03 01 	sublo	r6,1
8000dcac:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000dcb0:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000dcb4:	1c 1b       	sub	r11,lr
8000dcb6:	e2 02 06 40 	mulu.d	r0,r1,r2
8000dcba:	00 9e       	mov	lr,r0
8000dcbc:	02 9c       	mov	r12,r1
8000dcbe:	16 3c       	cp.w	r12,r11
8000dcc0:	e0 8b 00 08 	brhi	8000dcd0 <__avr32_umod64+0x1e4>
8000dcc4:	5f 06       	sreq	r6
8000dcc6:	06 30       	cp.w	r0,r3
8000dcc8:	5f ba       	srhi	r10
8000dcca:	ed ea 00 0a 	and	r10,r6,r10
8000dcce:	c0 60       	breq	8000dcda <__avr32_umod64+0x1ee>
8000dcd0:	fc 02 01 04 	sub	r4,lr,r2
8000dcd4:	f8 08 01 4c 	sbc	r12,r12,r8
8000dcd8:	08 9e       	mov	lr,r4
8000dcda:	e6 0e 01 0a 	sub	r10,r3,lr
8000dcde:	f6 0c 01 4c 	sbc	r12,r11,r12
8000dce2:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000dce6:	f8 09 0a 4b 	lsr	r11,r12,r9
8000dcea:	f4 09 0a 4a 	lsr	r10,r10,r9
8000dcee:	f8 01 09 4c 	lsl	r12,r12,r1
8000dcf2:	18 4a       	or	r10,r12
8000dcf4:	2f dd       	sub	sp,-12
8000dcf6:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000de00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000de00:	c0 08       	rjmp	8000de00 <_evba>
	...

8000de04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000de04:	c0 08       	rjmp	8000de04 <_handle_TLB_Multiple_Hit>
	...

8000de08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000de08:	c0 08       	rjmp	8000de08 <_handle_Bus_Error_Data_Fetch>
	...

8000de0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000de0c:	c0 08       	rjmp	8000de0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000de10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000de10:	c0 08       	rjmp	8000de10 <_handle_NMI>
	...

8000de14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000de14:	c0 08       	rjmp	8000de14 <_handle_Instruction_Address>
	...

8000de18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000de18:	c0 08       	rjmp	8000de18 <_handle_ITLB_Protection>
	...

8000de1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000de1c:	c0 08       	rjmp	8000de1c <_handle_Breakpoint>
	...

8000de20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000de20:	c0 08       	rjmp	8000de20 <_handle_Illegal_Opcode>
	...

8000de24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000de24:	c0 08       	rjmp	8000de24 <_handle_Unimplemented_Instruction>
	...

8000de28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000de28:	c0 08       	rjmp	8000de28 <_handle_Privilege_Violation>
	...

8000de2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000de2c:	c0 08       	rjmp	8000de2c <_handle_Floating_Point>
	...

8000de30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000de30:	c0 08       	rjmp	8000de30 <_handle_Coprocessor_Absent>
	...

8000de34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000de34:	c0 08       	rjmp	8000de34 <_handle_Data_Address_Read>
	...

8000de38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000de38:	c0 08       	rjmp	8000de38 <_handle_Data_Address_Write>
	...

8000de3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000de3c:	c0 08       	rjmp	8000de3c <_handle_DTLB_Protection_Read>
	...

8000de40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000de40:	c0 08       	rjmp	8000de40 <_handle_DTLB_Protection_Write>
	...

8000de44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000de44:	c0 08       	rjmp	8000de44 <_handle_DTLB_Modified>
	...

8000de50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000de50:	c0 08       	rjmp	8000de50 <_handle_ITLB_Miss>
	...

8000de60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000de60:	c0 08       	rjmp	8000de60 <_handle_DTLB_Miss_Read>
	...

8000de70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000de70:	c0 08       	rjmp	8000de70 <_handle_DTLB_Miss_Write>
	...

8000df00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000df00:	fe cf 70 cc 	sub	pc,pc,28876

8000df04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000df04:	30 0c       	mov	r12,0
8000df06:	fe b0 c2 fd 	rcall	80006500 <_get_interrupt_handler>
8000df0a:	58 0c       	cp.w	r12,0
8000df0c:	f8 0f 17 10 	movne	pc,r12
8000df10:	d6 03       	rete

8000df12 <_int1>:
8000df12:	30 1c       	mov	r12,1
8000df14:	fe b0 c2 f6 	rcall	80006500 <_get_interrupt_handler>
8000df18:	58 0c       	cp.w	r12,0
8000df1a:	f8 0f 17 10 	movne	pc,r12
8000df1e:	d6 03       	rete

8000df20 <_int2>:
8000df20:	30 2c       	mov	r12,2
8000df22:	fe b0 c2 ef 	rcall	80006500 <_get_interrupt_handler>
8000df26:	58 0c       	cp.w	r12,0
8000df28:	f8 0f 17 10 	movne	pc,r12
8000df2c:	d6 03       	rete

8000df2e <_int3>:
8000df2e:	30 3c       	mov	r12,3
8000df30:	fe b0 c2 e8 	rcall	80006500 <_get_interrupt_handler>
8000df34:	58 0c       	cp.w	r12,0
8000df36:	f8 0f 17 10 	movne	pc,r12
8000df3a:	d6 03       	rete

8000df3c <ipr_val>:
8000df3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000df4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000df5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000df6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000df7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000df8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000df9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dfac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dfbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dfcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dfdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dfec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dffc:	d7 03 d7 03                                         ....
